Rubicon: Bounded VeriÔ¨Åcation of Web Applications
Joseph P . Near, Daniel Jackson
Computer Science and ArtiÔ¨Åcial Intelligence Lab
Massachusetts Institute of Technology
Cambridge, MA, USA
{jnear,dnj}@csail.mit.edu
ABSTRACT
We present Rubicon, an application of lightweight formal
methods to web programming. Rubicon provides an embed-
ded domain-specic language for writing formal specica-
tions of web applications and performs automatic bounded
checking that those specications hold. Rubicon's language
is based on the RSpec testing framework, and is designed to
be both powerful and familiar to programmers experienced
in testing. Rubicon's analysis leverages the standard Ruby
interpreter to perform symbolic execution, generating veri-
cation conditions that Rubicon discharges using the Alloy
Analyzer. We have tested Rubicon's scalability on ve real-
world applications, and found a previously unknown secu-
rity bug in Fat Free CRM, a popular customer relationship
management system.
Keywords
Formal methods, programming languages, web programming
1. INTRODUCTION
Web applications have experienced explosive growth over
recent years. Testing methodologies for web applications are
beginning to catch up, but despite their utility in building
correct programs, there has been as yet little use of formal
methods in the domain.
This paper introduces Rubicon, an application of lightweight
formal methods to web programming. Rubicon allows pro-
grammers to write specications of the behavior of their web
application and performs automatic bounded analysis to
check those specications against the implementation. Ru-
bicon aims to be both powerful and easy to use: its speci-
cation language is expressive but based on a domain-specic
language for testing.
Rubicon is implemented as a library for the Ruby program-
ming language, and targets applications written using the
popular Rails web programming framework. Rubicon's spec-ication language is an extension of the Ruby-based RSpec
domain-specic language for testing [7]; Rubicon adds the
quantiers of rst-order logic, allowing programmers to re-
place RSpec tests over a set of mock objects with general
specications over all objects. This compatibility with the
existing RSpec language makes it easy for programmers al-
ready familiar with testing to write specications, and to
convert existing RSpec tests into specications.
Rubicon's automated analysis comprises two parts: rst,
Rubicon generates verication conditions based on specica-
tions; second, Rubicon invokes a constraint solver to check
those conditions. The Rubicon library modies the envi-
ronment so that executing a specication performs symbolic
execution, producing verication conditions rather than val-
ues. To check the verication conditions, Rubicon currently
compiles them into Alloy [14], a lightweight specication lan-
guage for software design, for analysis using the Alloy An-
alyzer, a fully-automatic bounded analysis engine for Alloy.
Alloy's relational language is convenient because its seman-
tics closely match those of relational databases, but in prin-
ciple, an unbounded SMT solver or theorem prover could be
used in place of Alloy.
We tested Rubicon's performance on ve open-source web
applications for which the original developers have written
RSpec tests. We took a random sample of these tests and
converted them into Rubicon specications; in every case,
Rubicon's analysis took no more than a few seconds per
specication. In the largest of these applications, a customer
relationship management system called Fat Free CRM, Ru-
bicon's analysis uncovered a previously unknown security
bug. The authors of Fat Free CRM have acknowledged this
bug and are preparing a x.
We have released Rubicon under the terms of the GPL at:
http://people.csail.mit.edu/jnear/rubicon .
The contributions of this paper include:
Rubicon, a domain-specic language for expressing spec-
ications of web applications;
a scalable, automatic, symbolic-execution-based bounded
checker for Rubicon specications;
an evaluation of Rubicon on ve applications, and the
discovery of a previously unknown security bug.1describe UsersController do
2 it "should expose the requested user as @user and
render [show] template" do
3 @user = Factory(:user)
4 get :show, : id = >@user.id
5 assigns [: user ]. should == @user
6 response.should render template("users/show" )
7 end
8end
9
10 describe ContactsController do
11 it "should redirect to contact index if the contact
is protected " do
12 @private = Factory(:contact, : user = >
Factory(:user), : access = >" Private" )
13 get :show, : id = >@private.id
14 ash [: warning ]. should not == nil
15 response.should redirect to (contacts path)
16 end
17end
Figure 1: RSpec Tests for Displaying Users and Re-
stricting Access to Private Contacts
2. THE RUBICON LANGUAGE
Rubicon provides an embedded domain-specic language for
writing specications. This language is based on RSpec [7],
a testing framework for the Ruby language whose goal is to
make testing easier and more useful, and that has made test-
driven design popular amongst Ruby programmers. RSpec
tests are concise, avoid repetition, and resemble English
specications of application features. The framework also
encourages programmers to write documentation for each
test by providing elds for that documentation and using it
to generate error reports when tests fail.
The Rubicon language is designed for writing specications
of Rails applications. Rails is the most popular web pro-
gramming framework for Ruby, and was designed specically
to allow testing with RSpec. The integration of Rails with
RSpec means that test-driven development is just as popular
in the Rails community as it is in the larger Ruby commu-
nity, and many open-source Rails applications are shipped
with large RSpec test suites.
2.1 The RSpec Approach
To introduce the style of testing promoted by the RSpec
library, we take the open-source Rails application Fat Free
CRM1as a case study. Fat Free CRM is a customer rela-
tionship management system designed to be used to build
customized CRM systems for use in organizations. Devel-
opment of Fat Free CRM began in 2008 and the software
is currently maintained by Michael Dvorkin and Nathan
Broadbent. Fat Free CRM is released under the AGPL,
its codebase comprises 23kloc, but is reasonably simple to
understand, and the developers have written more than 1000
RSpec tests.
Figure 1 contains two examples of RSpec tests from the Fat
1http://www.fatfreecrm.com/Free CRM codebase. The rst (lines 1-8) is intended to
test that the show action correctly displays summaries of
the site's users. What it actually tests is that a particular
user (created by the call to the Factory ) is displayed. The
test begins with a natural-language specication of the fea-
ture under test (line 2); the body of the test (lines 3-7) is
Ruby code written in the RSpec domain-specic language.
This particular test constructs a mock object representing
a single user (line 3), requests the summary page for that
user (line 4), and then checks that the user that will be dis-
played matches the mock object just created (line 5). This
check is written as an RSpec assertion, the general form of
which is a.should p b , where aand bare objects and pis a
predicate describing the desired relationship between them.
The assigns variable is actually a Ruby hash populated by
the Rails framework to contain the names and values of the
instance variables set by the page request in line 4.
The second test (lines 10-17) is intended to check that pri-
vate contacts are never displayed to users other than their
owners. What it actually tests is that a particular private
contact is hidden from a particular user. The test begins by
building a mock object for the private contact owned by a
mock user (line 12). The test then attempts to display the
private contact (line 13). Since the mock user created as the
owner of the contact in line 12 is by default distinct from the
mock user representing the currently logged-in user, this re-
quest should fail. The test checks that it does indeed fail by
asserting that the value of ash [: warning] , which displays
site errors, is populated (line 14), and that the user should
be redirected to the index of contacts (line 15).
The example tests in Figure 1 check the desired properties
in only a single case; they may easily miss corner cases that
the programmer does not anticipate. For example, the sec-
ond test passes, but the intended property|that the show
action in the contacts controller preserves permissions|is
actually false! In fact, displaying a contact also causes a
summary of the associated opportunities to be displayed;
these opportunities also have associated user permissions.
The test either ignores the fact that opportunities will be
displayed, or assumes that the permissions on these oppor-
tunities will match those on the corresponding contact. If
they do not, a user may be allowed to see another user's
private opportunity. This is an example of a corner case
that is unlikely to be caught by testing alone, since test-
ing requires the programmer to specify exactly one case to
test|and the programmer is likely to test only the case in
which the permissions match.
2.2 Adding QuantiÔ¨Åers
Rubicon allows programmers to write specications for web
applications by extending the RSpec language with the quan-
tiers of rst-order logic. Rather than testing just a sin-
gle case for compliance with the application's specication,
Rubicon performs symbolic execution for a truly arbitrary
case, generates verication conditions that cover allpossi-
ble cases, and uses an automatic bounded verier to check
them.
Rubicon introduces two new methods on objects| forall and
exists |which represent the universal and existential quanti-
ers of rst-order logic. Both methods accept a single argu-SpecFile :: describe <class>do<Spec>end
Spec :: it<string >do<Expr>end
Expr ::<Ruby Expression >
j<object >. forall dojxj<Expr>end
j<object >.exists dojxj<Expr>end
j<class>. forall dojxj<Expr>end
j<class>.exists dojxj<Expr>end
j<Expr>.implies do<Expr>end
j<object >.should equal <Expr>
j<object >.should notequal <Expr>
j<object >.should <Pred> < Expr>
j<object >.should not<Pred> < Expr>
Pred ::==
jbe
j include
j raise
jthrow
jrespond to
jhave
Figure 2: Syntax of Rubicon Specications
1describe UsersController do
2 it "should expose the requested user as @user and
render [show] template" do
3 User.forall dojuserj
4 get :show, : id = >user.id
5 assigns [: user ]. should == user
6 response.should render template("users/show" )
7 end
8 end
9end
10
11 describe ContactsController do
12 it "should redirect to contact index if the contact
is protected " do
13 User.forall dojuserj
14 Contact.forall dojprivatej
15 setcurrent user(user)
16 get :show, : id = >private.id
17 ((private.access == " Private" ) &
18 (private.user != user)).implies do
19 ash [: warning ]. should not == nil
20 response.should redirect to (contacts path)
21 end
22 end
23 end
24 end
25end
Figure 3: Rubicon Specications for Displaying
Users and Restricting Access to Private Contactsment: a Ruby block, representing the property over which
the quantier ranges; quantiers succeed or fail in the same
way as other RSpec tests.
Figure 2 species the core syntax of Rubicon specications.
Rubicon's syntax is exactly that of RSpec, with the addition
of quantiers. A set of Rubicon specications begins with a
describe block specifying the class being specied; each indi-
vidual specication is written inside an itblock with a string
documenting that specication. A specication is simply a
sequence of expressions, each of which may be a standard
Ruby expression or a Rubicon assertion. A quantier is also
an assertion; a.forall dojxjb end means that the assertions
inbshould hold for all possible values of xfrom the set
a, and a.exists dojxjb end means that the assertions in b
should hold for at least one value of xfrom a.
Figure 3 presents Rubicon versions of the RSpec tests from
Figure 1. This specication for displaying users (lines 1-9)
quanties over allusers, rather than testing the intended
property for just a single user. The block passed to the
forall method is precisely the code we wrote in the original
test|only the underlined code has changed, reecting the
introduction of quantied variables in place of mock objects.
The specication for restricting access to private contacts
(lines 11-25) changes only slightly more. In order to check
that permissions are preserved no matter which user is logged
in, we quantify over users (line 13) and then set the logged-
in user correspondingly (line 15). To express the class of
contacts for which the property should hold, we introduce
a logical implication (lines 17-18) whose left-hand side re-
quires that the contact's access should be set to private and
that its owner should be distinct from the logged-in user.
2.3 The Power of SpeciÔ¨Åcation
By writing full specications of application behavior, pro-
grammers can catch errors that tests alone are unlikely to
nd. Rubicon's automated analysis of formal specications
can explore corner cases, check for general regression errors,
and build complicated object hierarchies for testing|areas
in which standard RSpec tests fall short. Moreover, Rubicon
specications are often more concise than the RSpec tests
they replace, since the programmer may replace complicated
code for constructing mock objects with simpler quantiers.
The previously mentioned fault involving the permissions on
opportunities associated with contacts, for example, is un-
likely to be caught in testing, since its discovery requires the
specic situation in which the user in question has permis-
sion to view a particular contact, but does nothave per-
mission to view the associated opportunity. Because mock
objects must take concrete values, a programmer will tend
to construct mock objects that represent the most common
situation|in this case, one in which the permissions on the
contact and its associated opportunities match.
In writing specications, on the other hand, the tendency
is to provide as little information as possible, so as to have
the highest chance of discovering corner cases that were not
considered by the programmer. The Rubicon specication
in Figure 4 checks the property that permissions are actu-
ally respected when displaying a contact. The specication1describe ContactsController do
2 it "should not display other users ' private contacts
or opportunities " do
3 User. forall dojuj
4 Contact. forall dojcj
5 Opportunity. forall dojoj
6 setcurrent user (u)
7 get :show, : id = >c.id
8
9 ((c. access == 'private') &
10 (c. user != u)). implies do
11 assigns [: contact ]. should not == c
12 end
13
14 ((o. access == 'private') &
15 (o.user != u)). implies do
16 assigns [: contact ]. opportunities should not
17 include o
18 end
19 end
20 end
21 end
22 end
23end
Figure 4: Rubicon Specication for Displaying Con-
tacts
quanties over users, contacts, and opportunities (lines 3-
5), sets the current user to the quantied one (line 6), and
requests the contact display page (line 7). The specication
then checks two properties: rst, that for any contact, if
that contact's permissions are set to private and its contact's
owner is not the current user, then that contact should not
be displayed (lines 9-12); and second, that for anyoppor-
tunity, if that opportunity's permissions are set to private
and its owner is not the current user, then that opportu-
nity should notbe included in the list of opportunities to be
displayed (lines 14-17).
This specication makes no assumptions about any prop-
erties of the contact and opportunities in question; most
importantly, it does not rule out the case that the requested
contact is public, but one of the associated opportunities is
private and not owned by the current user. Indeed, Rubi-
con catches this case immediately, returning the following
counterexample for the second property:
1=>u = Userf:id = >1 ...g
2 c = Contactf:access = >'public', : user = >u,
3 : opportunities = >[o] ...g
4 o = Opportunityf:access = >'private' ,
5 : user = >user1 ...g
This counterexample represents the case in which the cur-
rent user owns the contact being displayed, but does notown
the opportunity associated with that contact. Even though
that opportunity is private, it will be displayed to the user.
The blame for this fault lies in the assumption, made in1describe ContactsController do
2 it "should be able to associate newly created
contact with the opportunity " do
3 @opportunity = Factory(:opportunity , : id = >987);
4 @contact = Factory.build (: contact)
5 Contact.stub !(: new).and return(@contact)
6
7 xhr :post, : create , :contact = >f:rst name = >
" Billy"g, :account = >fg, :opportunity = >987
8 assigns (: contact). opportunities .should
include (@opportunity)
9 response.should render template("contacts/create ")
10 end
11end
Figure 5: RSpec Test for Contact Creation
1describe ContactsController do
2 it "should not associate another user ' s private
opportunity with newly created contact" do
3 User. forall dojuserj
4 Contact. forall dojcontactj
5 Opportunity. forall dojopportunityj
6 setcurrent user (user)
7 xhr :post, : create , :contact = >
contact.attributes , : opportunity = >
opportunity.id
8
9 (( opportunity . user != user) &
10 (opportunity . access=='private')). implies do
11 assigns [: contact ]. opportunities .should not
include opportunity
12 end
13 end
14 end
15 end
16 end
17end
Figure 6: Rubicon Specication for Contact Cre-
ation
theshow action of the contacts controller, that the permis-
sions and ownership of a contact and its opportunities will
be identical. The show method uses the mymethod of the
Contact class to determine which contact to display; the de-
velopers of Fat Free CRM have redened the mymethod
elsewhere so as to return only those records that the current
user has permission to view. Referencing a particular con-
tact's opportunities eld, however, accesses the associated
opportunities directly , bypassing the redened mymethod,
and ignoring the opportunities' permissions settings. If a
user has permission to display a contact, then, he or she will
be able to access all of its associated opportunities, regard-
less of their permission settings.
2.4 Exploiting the Bug
The corner case discovered in the previous section only qual-
ies as a serious security bug if it is possible to exploit it.
The exploit described in the counterexample requires an in-variant on the database to be broken|that the permissions
of all the opportunities associated with a particular contact
are compatible with the permissions on that contact. Ru-
bicon can help us again, this time in checking whether or
not it is possible to create a new contact that violates the
invariant.
Invariants can be checked the same way using tests, but the
contrived nature of test cases makes this strategy less use-
ful than might be hoped|run-time assertions checking for
invariant violations are therefore much more popular. Fig-
ure 5 contains the RSpec test written by the Fat Free CRM
developers to check that the invariant is preserved. As usual,
this test uses mock objects (lines 3-5) to construct the com-
mon case|one with the default permissions|creates a new
contact (line 7), and tests that the opportunity is correctly
associated with the contact (line 8).
The corresponding Rubicon specication (Figure 6), on the
other hand, quanties over all users, contacts, and opportu-
nities (lines 3-5), constructs a new contact associated with
the quantied opportunity (line 7), and checks that if the
opportunity is private and not owned by the current user,
then it should not be included in the resulting contact's set
of associated opportunities (lines 9-11)|in other words, it
should be impossible to create a contact that violates the
invariant.
Once again, Rubicon's analysis yields a counterexample, in-
forming us that it is indeed possible to violate the invariant:
1=>user = Userf:id =>1 ...g
2 contact = Contact f: opportunities = >[opportunity]
...g
3 opportunity = Opportunity f:access = >'private' ,
: user = >user1g
Investigating the code for the create action in the contacts
controller, we found that the code that looks up the at-
tached opportunity uses the nd method, rather than the
permission-enforcing mymethod, to nd the opportunity
whose ID is referenced in the HTML form submitted by
the user.
Exploiting this security bug, then, is as easy as submitting a
contact creation request with the ID of another user's oppor-
tunity in the \ opportunity id" HTML eld. The developers
of Fat Free CRM have acknowledged the bug, and are work-
ing on a x.
3. THE RUBICON ANALYSIS
Rubicon is implemented as a library on top of Ruby, RSpec,
and Rails. It extracts verication conditions from speci-
cations by using the standard Ruby interpreter to perform
symbolic, rather than concrete, execution; instead of con-
crete values, this style of execution produces abstract syntax
trees representing the appropriate verication conditions.
Rubicon then compiles the verication conditions into an
Alloy [14], a lightweight specication language for software
engineering, and performs bounded analysis using the Alloy
Analyzer.E(obj. forall b)  8 x:E(b. call ( x))
E(obj. exists b)  9 x:E(b. call ( x))
E(obj.should p e)  E(obj.p(e))
E(obj.should not p e) : E(obj.p(e))
E(e)  RubyInterpreter (e)
Figure 7: Semantics of Rubicon Specications
C(obj. forall b)  all(x, C(b. call ( x))
C(obj. exists b)  some(x, C(b. call ( x))
(x is a new symbolic object)
C(obj.should p e)  call(:should ,C(obj),C(p),C(e) )
C(obj. attribute )  eld ref(C(obj),C(args) )
C(obj.meth(args))  call( meth, C(obj), C(args) )
C(obj.where(e))  query( v, obj, C(e) )
(if obj is symbolic)
C(e)  RubyInterpreter (e)
(if e is concrete)
Figure 8: Compiling Specications to Abstract Syn-
tax Trees
3.1 Rubicon‚Äôs Semantics
Rubicon's semantics are intended to match those of Ruby
precisely, and to combine Ruby's semantics in a natural way
with the standard semantics of the quantiers of rst-order
logic. Figure 7 contains an informal summary of Rubicon's
semantics, using the standard quantier symbols ( 8;9) and a
function representing the semantics of the standard Ruby in-
terpreter (RubyInterpreter). Given standard quantication
over Ruby values, we can represent Rubicon's basic asser-
tions ( should and should not) by simply invoking the predi-
cate on the object in question; a true result means that the
assertion holds. It is the goal of Rubicon's implementation
to implement these semantics faithfully.
3.2 Rubicon‚Äôs Implementation
To implement the semantics in Figure 7, Rubicon trans-
forms specications into verication conditions represented
as abstract syntax trees and checks those conditions using a
constraint solver. Figure 8 summarizes that transformation;
the transformation is based on the use of symbolic objects
dened by the Rubicon library to represent quantied vari-
ables.
To avoid re-implementing the Ruby interpreter, Rubicon im-
plements the transformation from Figure 8 by persuading
the standard Ruby interpreter to perform symbolic execu-
tion. Rubicon accomplishes this by dening symbolic ob-
jects in such a way that all method invocations on symbolic
objects yield abstract syntax trees rather than values. Since
specications necessarily refer to symbolic objects if they use
quantiers, Rubicon can use the results of running code with
symbolic objects to build abstract syntax trees representing
verication conditions for the specication.
This strategy works especially well for web applications, for
two reasons: rst, the database schema of a web applica-
tion species exactly the set of possible symbolic objects;Figure 9: Comparison Between RSpec Execution
and Rubicon Analysis
and second, web applications typically move much of the
application's logic into the database, so the remaining code
has few branches. These two facts lend our approach its
scalability: by limiting the number of symbolic objects, we
perform as much execution as possible over concrete objects
(using the standard Ruby interpreter) and reduce the size of
the resulting verication conditions; and because the code
contains few branches, the branch-explosion problem that
typically plagues symbolic execution does not occur.
A diagram comparing Rubicon's execution model to that of
RSpec is presented in Figure 9. Rubicon's analysis proceeds
in three parts: rst, the Rubicon library stubs the standard
libraries and ActiveRecord objects; second, Rubicon runs
the specication body in the standard Ruby interpreter, pro-
ducing verication conditions; and nally, Rubicon compiles
those verication conditions for the Alloy Analyzer to check.
3.3 Preprocessing: Stubbing Objects
Rails uses the ActiveRecord class as the basis for its object-
relational mapper. In a standard Rails application, every
object to be stored in the database is descended from Ac-
tiveRecord. To determine the set of classes that should be
represented by symbolic objects, then, Rubicon builds a list
of all the classes descended from ActiveRecord.
The next step is to stub those classes|replacing them with
new classes that respond the same way to the operations de-
ned on them, but with dierent behavior. Rubicon takes
each ActiveRecord class and redenes two basic types of
methods: class methods that query the database, and in-
stance methods that allow the programmer to get and set
the attributes (values to be stored in the database) of an
object representing a particular record in the database. For
example, the call User.all returns a list of all users, and given
a user object, user.id returns that user's ID number.
Rubicon redenes these methods to produce abstract syntax
trees rather than values: User.all returns Expr Call(:all, User) ,
and user.all returns Expr Field Ref(user, :id) .
The classes that dene abstract syntax trees are dened so
that methods invoked on them produce new trees reectingT(all(x, e) )  allx:typeOf(x)jT(e)
T(some(x, e) ) some x:typeOf(x)jT(e)
T(eld ref(obj, f) ) T(obj). f
T(call(:include, obj, a) ) T(obj) inT(a)
T(call(:==, obj, a) ) T(obj) = T(a)
T(query(name, type, e) ) f name: typejT(e)g
T(call(:should, obj, p, a) ) T(call(p, obj, a) )
T(v)  v
Figure 10: Compiling Abstract Syntax Trees to Al-
loy Specications
these operations, and the should method for building asser-
tions is also redened to produce abstract syntax trees. As
a result, the following Ruby expression:
1user1. id .should == user2.id
Evaluates to the following abstract syntax tree, instead of
a value ( Expr Callrepresents the constructor of an abstract
syntax tree node):
1Expr Call (: should, :==, Expr Field Ref(user1, : id),
Expr Field Ref (user2, : id))
Having prepared the environment this way, running Rubicon
specication code in the standard Ruby interpreter yields
abstract syntax trees representing verication conditions.
3.4 Postprocessing: Producing Alloy SpeciÔ¨Å-
cations
All that remains is to translate verication conditions into
Alloy specications. Since our abstract syntax trees are de-
signed for this purpose, doing so is straightforward. We
summarize the translation in Figure 10.
The Alloy language includes all of rst-order relational logic,
plus transitive closure. Quantiers, therefore, are trans-
lated into their analogues in Alloy; eld references become
relational joins based on Alloy's global relations, database
queries become Alloy set comprehensions, and Rubicon as-
sertions turn into logical formulas.
Alloy's universe is made up of uninterpreted atoms, which
are divided into sets based on user-dened signatures . In
addition to designating a set of atoms, signatures may dene
global relations ; Alloy specications are typically based on
these global relations, and logical formulas are built from
the results of relational joins or membership tests over these
relations.
Rubicon uses Alloy's atoms to represent objects. It denes
a signature for each type of object that is mentioned in a
given specication, with relations to represent the values of
the object's elds. Given this representation, a eld refer-
ence in Ruby is equivalent to a relational join in Alloy. This
paradigm is popular in Alloy, so the syntax of relational
join is designed to make the representation of a eld refer-
ence appear similar to the typical syntax in programminglanguages| obj.f means the relational join of the atom obj
with the global relation f, but it also represents the reference
to eld fof object obj, given our encoding.
To generate a complete Alloy specication, Rubicon con-
structs a signature denition for every class referenced in
the corresponding Rubicon specication. For each signa-
ture, Rubicon consults the application's database schema
(encoded in the ActiveRecord) to determine the set of at-
tributes associated with that type, and adds a eld denition
to the signature for each attribute. For example, the rst
part of the signature denition for the User class from Fat
Free CRM is as follows:
1sigUserf
2 name: String,
3 created at : Datetime,
4 updated at: Datetime,
5 email: String ,
6 ...
7g
Rubicon combines these signature denitions with the trans-
lated verication conditions and invokes the Alloy Analyzer
to determine whether or not the specication is satised.
The Alloy Analyzer is a tool for automatic bounded anal-
ysis of Alloy specications; it places nite bounds on the
number of each type of atom present in the universe, then
reduces the specication to propositional logic. The An-
alyzer uses a model nder, Kodkod [21], which translates
to boolean satisability (SAT) using algorithms that opti-
mize relational expressions. This makes Kodkod, and thus
Alloy, especially suited to database applications. If a coun-
terexample is found, Kodkod maps the SAT result back to
a valuation for the original specication's relations.
Rubicon, in turn, maps the counterexample Alloy produces
back to a Ruby object structure, which forms the printed
counterexample the user sees when a specication is found
not to hold.
3.5 An Example: Contact Permissions
As a complete example of Rubicon's analysis, consider the
example of checking that the user has permission to view
a contact and its associated opportunities (Figure 4). Fig-
ure 11 demonstrates how the second of these two properties
is checked.
First, during execution by the Ruby interpreter, the prop-
erty, along with the Fat Free CRM implementation (in this
case, the show method dened in full in Figure ??), produce
a verication condition to be checked by the Alloy Analyzer.
The page request (line 12) passes the quantied contact's ID
to the show method, where the call to the stubbed version of
Contact.my.nd (line 2) yields a symbolic record represent-
ing precisely the quantied contact. The method returns,
having set assigns [: contact] to that symbolic record.
The two conditions on the left-hand side of the implication
(line 15) evaluate to expressions involving the quantied op-
portunity; the condition on the right-hand side of that im-
plication (line 16) evaluates to an expression involving both1def show
2 @contact = Contact.my.nd(params[:id ])
3 @stage = Setting. unroll (: opportunity stage )
4 @comment = Comment.new
5 ...
6end
7
8User. forall dojuj
9 Contact. forall dojcj
10 Opportunity. forall dojoj
11 setcurrent user (u)
12 get :show, : id = >c.id
13
14 ((o. access == 'private') &
15 (o.user != u)). implies do
16 assigns [: contact ]. opportunities should not
17 include o
18 end
19 end
20 end
21end
)
22 Expr Implies (
23 Expr And(
24 Expr Call(:==, Expr Field Ref(o, : access),
25 ' private '),
26 Expr Call (:!=, Expr Field Ref (o, : user),
27 u)),
28 Expr Not(
29 Expr Call (: include ,
30 Expr Field Ref (c, : opportunities ),
31 o)))
)
32one sig string private extends Stringfg
33 sigOpportunityf
34 id : ID, access : String , ..., user : set User
35g
36 sigContactf
37 id : ID, access : String , ..., opportunities : set
Opportunity
38g
39 sigUserf
40 id : ID, ...
41g
42
43checkf
44 allu: Userj
45 allc: Contactj
46 allo: Opportunityj
47 (o. access = string private and
48 o.user != u) implies
49 !(oinc. opportunities )
50
51gfor 5
Figure 11: Verication Condition and Correspond-
ing Alloy Specication 0 100 200 300 400 500 600 700 800 900 1000 1100
 0  2  4  6  8  10  12  14Solving Time (ms)
Finite Bound (Scope)Figure 12: Eect of Finite Bound on Solving Time
of Verication Conditions from Examples in Figures
3, 4, and 6
the symbolic record constructed above and the quantied
opportunity. The expression representing the complete ver-
ication condition is listed in lines 22-31.
Second, the Rubicon postprocessor produces an Alloy spec-
ication equivalent to the verication condition. Each ex-
pression type produced by the methods Rubicon stubs cor-
responds directly to an Alloy expression. Rubicon wraps the
verication condition produced above with the appropriate
quantiers, combines it with a set of signatures correspond-
ing to the classes used in the specication, and produces the
Alloy specication listed in lines 32-51.
4. EV ALUATION
To conrm that Rubicon's analysis is capable of scaling to
real applications, we tested it on ve open-source Rails ap-
plications whose distributions contain RSpec tests written
by the original developers. We tried to select applications
that perform a variety of tasks and that have a sizable user
base. All of the applications we examined contain extensive
RSpec test suites with documentation. The ve applications
we examined are:
Insoshi , a social networking platform
Fat Free CRM , a customer relationship management
platform
RubyTime , a time-management system
RubyURL , a URL-shortening service
Tracks , an application to implement the\Getting Things
Done" methodology
4.1 Methodology
For each application, we selected a random subset of the
les containing developer-written RSpec tests for the ap-
plication's controllers. The controller tests tend to expressproperties of the application's behavior, rather than prop-
erties about the database schema, so we considered them
both a better test of Rubicon's ability to check an applica-
tion's behavior and more likely to nd behavioral bugs in
the application.
We converted all of the tests from each selected le into Ru-
bicon specications by replacing mock objects with quan-
tiers over objects. This process was straightforward for
most tests, since the natural language description of each
test combined with the Ruby code implementing it gener-
ally described the intent of the test.
We ran both the original RSpec tests and our Rubicon spec-
ications on an Intel Core 2 Duo E7500 with 4GB RAM un-
der Ubuntu 10.04 and Ruby 1.8.7, with the latest version of
each application (when available, the development version).
Rubicon makes use of version 4.1 of the Alloy Analyzer.
By default, Rubicon uses a nite bound of ve during analy-
sis, meaning that the corresponding Alloy Analyzer analysis
searches for a counterexample in universes containing ve
atoms or fewer per Ruby class. We used this bound in our
experiments.
Specications from this evaluation are available on the Ru-
bicon webpage.2
4.2 Results
We converted a total of 250 developer-written RSpec tests
into Rubicon specications. The table in Figure 13 contains
a summary of the size of each application, the lenames of
the test les we converted, the number of tests per le, the
average execution time of the original tests and their associ-
ated Rubicon specications, and a comparison between the
number of lines of code used before and after the conversion
to Rubicon.
The results show that while analyzing Rubicon specica-
tions is several times slower, on average, than executing the
original RSpec tests, Rubicon's analysis usually takes only
a second or two. Moreover, converting the original RSpec
tests into Rubicon specications made the source code only
11% longer, suggesting that writing Rubicon specications
may not be signicantly more dicult than writing RSpec
tests.
Figure 14 is a visual representation of the range of per-
specication analysis times for each of the test les in Fig-
ure 13. For each test le, the bar represents the average
analysis time over all of that le's specications; the extent
of the error bars represents the maximum and minimum
analysis time for any specication in that le. The maxi-
mum analysis time for any test we converted was just over
ve seconds; more importantly, the maximum and minimum
analysis times were always close to the average, suggesting
that Rubicon's analysis is consistently fast.
To evaluate the eect of the nite bound on Rubicon's analy-
sis time, we generated the Alloy specications corresponding
to each of the four Rubicon specications listed in this paper
2http://people.csail.mit.edu/jnear/rubiconFilename Number Average RSpec Average Rubicon Original RSpec Rubicon
of Tests Time per Test Time per Test Lines of Code Lines of Code
Insoshi (12k LOC)
people controller spec.rb 27 0.41s 1.52s 272 314
topics controller spec.rb 4 0.52s 1.86s 42 57
comments controller spec.rb 14 0.38s 2.08s 126 143
Totals 45 0.44s 1.82s 440 514
Fat Free CRM (23k LOC)
home controller spec.rb 8 0.64s 2.45s 98 115
comments controller spec.rb 21 0.53s 2.12s 254 301
users controller spec.rb 27 0.42s 1.87s 343 386
contacts controller spec.rb 53 0.44s 1.97s 696 754
Totals 109 0.51s 2.10s 1391 1556
RubyTime (11k LOC)
users spec.rb 31 0.32s 2.11s 271 294
clients spec.rb 11 0.28s 2.54s 104 132
Totals 42 0.30s 2.35s 375 426
RubyURL (1k LOC)
links controller spec.rb 8 0.36s 2.63s 73 94
Totals 8 0.36s 2.63s 73 94
Tracks (22k LOC)
todo spec.rb 20 0.27s 2.16s 182 207
user spec.rb 26 0.23s 2.46s 174 197
Totals 46 0.25s 2.31s 356 404
Figure 13: Case-Study Summary: the Number of Tests, Average Runtime of Original Test and Corresponding
Rubicon Specication, and Lines-of-Code Comparison Between Original Tests and Rubicon Specications
 0 1 2 3 4 5 6
people_controller_spec.rb topics_controller_spec.rb comments_controller_spec.rb home_controller_spec.rb comments_controller_spec.rb users_controller_spec.rb contacts_controller_spec.rb users_spec.rb clients_spec.rb links_controller_spec.rb todo_spec.rb user_spec.rbSolving Time (s)
Figure 14: Range of Analysis Times for Rubicon Specications: Average, Maximum, and Minimum Analysis
Times for Each Test File(in Figures 3, 4, and 6) and manually tested the dierences
in solving times at dierent scopes using the Alloy Analyzer.
The results of this experiment are displayed in Figure 12. As
is common with SAT-based analyses, the solving time begins
to increase exponentially as the nite bound rises above ten
atoms per class. Rubicon's default bound of ve is a compro-
mise attempting to produce consistently fast analysis times
without missing bugs.
4.3 Fat Free CRM Bug
Of the RSpec tests we converted, only one led to the dis-
covery of a previously unknown bug. As discussed in Sec-
tions 2.2 and 2.3, testing the permissions of both contacts
and their associated opportunities, along with the ability of
bounded analysis to explore corner cases, allowed us to dis-
cover a situation in which a user can view another user's
private opportunities.
Several other tests we converted led us to the discovery (also
discussed in Section 2.3) that the Fat Free CRM developers
had redened the ActiveRecord mymethod to enforce per-
missions. Rubicon also redenes this method, and interprets
the resulting verication condition as if its use has the se-
mantics originally intended by the Rails developers. The
result was a false positive: Rubicon originally reported that
any user could view any entity in the system, regardless of
permissions. We worked around this problem by renaming
the method dened by Fat Free CRM and calling it directly.
This was the only Fat Free CRM issue that caused false
positives to be reported by Rubicon.
5. RELATED WORK
Rubicon's specication language is based on the RSpec domain-
specic language for testing [7]. Our approach of embedding
an expressive specication language directly in a program-
ming language is most heavily inuenced by QuickCheck [10],
a random testing framework for Haskell in which the pro-
grammer species properties by writing code.
Rubicon's analysis is based on symbolic execution, which
was originally developed by King [16] and which has seen
both popular use and renement (e.g. [15]) since its incep-
tion. Symbolic execution is itself a form of abstract interpre-
tation, which was formalized by Cousot [11]. The two tech-
niques remain popular with the program analysis commu-
nity. Rubicon's back-end solver is based on Alloy [14], which
is itself based on the Kodkod relational model nder [21].
Existing work on the application of formal methods to web
applications focuses on modeling applications, and especially
on building navigation models. Bordbar and Anastasakis [4],
for example, model a user's interaction with a web applica-
tion using UML, and perform bounded verication of prop-
erties of that interaction by translating the UML model into
Alloy using UML2Alloy; other approaches ([17,20]) perform
similar tasks but provide less automation.
Most techniques focus specically on navigation from one
page to another, and can analyze only those properties re-
lated to possible navigations. Some existing work ( [1, 5])
models possible navigations using UML, others ( [3]) using
directed graphs, and still others ( [8, 12, 22]) using state-
charts.Those techniques that allow programmers to specify an ap-
plication's behavior are closest in their aim to our own work.
Syriani and Mansour [19] use SDL (the Specication and De-
scription Language) to model some aspects of application,
and provide automatic test case generation based on the
model. Haydar et al. [13] use communicating automata to
build the application's model, and have explored techniques
for verifying properties of those automata. Finally, Andrews
et al. [2] use nite state machines to model applications, and
also generate test cases. All of these techniques require the
programmer to build a separate model of their web applica-
tion's behavior, and limitations of the modeling technique
used mean the set of properties that can be checked is also
limited. Rubicon, in contrast, is capable of checking any
property expressible in rst-order logic.
Techniques that do not require the programmer to build a
model of the application tend to focus on the elimination
of a certain class of bugs, rather than on full verication.
Chlipala's Ur/Web [9] statically veries user-dened security
properties of web applications, and Chaudhuri and Foster [6]
verify the absence of some particular security vulnerabilities
for Rails applications. Nijjar and Bultan [18] translate Rails
data models into Alloy to nd inconsistencies.
6. CONCLUSION
Rubicon brings together the ideas of testing, formal speci-
cation, symbolic execution, and bounded analysis, and ap-
plies them to web applications. Its combination of RSpec
and quantiers is powerful enough to express rich behavioral
specications without requiring programmers to learn a new
specication language. Leveraging the Ruby interpreter to
perform symbolic execution allows Ruby to execute concrete
parts of the application directly, resulting in smaller verica-
tion conditions and thus increased scalability. This style of
symbolic execution also resulted in decreased development
time of the Rubicon tool, since no separate symbolic eval-
uator had to be developed, and means that users need not
install a separate symbolic evaluator. Finally, the relational
language and analysis of Alloy and its Analyzer are a per-
fect match for the database-oriented verication conditions
Rubicon generates.
While it remains to be seen if the use of Rubicon is cost-
eective, we are encouraged by the ability of our prototype
implementation to perform analyses on non-trivial open-
source Rails applications, and by the fact that it has already
exposed a bug missed in several years of testing. We hope
that Rubicon's availability as open-source software will en-
courage web developers to begin writing and checking spec-
ications.
7. REFERENCES
[1] L. Alfaro. Model checking the world wide web. In
Proceedings of the 13th International Conference on
Computer Aided Verication , pages 337{349.
Springer-Verlag, 2001.
[2] A.A. Andrews, J. Outt, and R.T. Alexander. Testing
web applications by modeling with fsms. Software and
Systems Modeling , 4(3):326{345, 2005.
[3] M. Benedikt, J. Freire, and P. Godefroid. Veriweb:
Automatically testing dynamic web sites. In InProceedings of 11th International World Wide Web
Conference (WWW'2002) . Citeseer, 2002.
[4] B. Bordbar and K. Anastasakis. Mda and analysis of
web applications. Trends in Enterprise Application
Architecture , pages 44{55, 2006.
[5] D. Castelluccia, M. Mongiello, M. Ruta, and
R. Totaro. Waver: A model checking-based tool to
verify web application design. Electronic Notes in
Theoretical Computer Science , 157(1):61{76, 2006.
[6] A. Chaudhuri and J.S. Foster. Symbolic security
analysis of ruby-on-rails web applications. In
Proceedings of the 17th ACM conference on Computer
and communications security , pages 585{594. ACM,
2010.
[7] D. Chelimsky, D. Astels, Z. Dennis, A. Hellesoy,
B. Helmkamp, and D. North. The rspec book:
Behaviour driven development with rspec, cucumber,
and friends. Pragmatic Bookshelf , 2010.
[8] J. Chen and X. Zhao. Formal models for web
navigations with session control and browser cache.
Formal Methods and Software Engineering , pages
46{60, 2004.
[9] A. Chlipala and LLC Impredicative. Static checking of
dynamically-varying security policies in
database-backed applications. In Proceedings of the 9th
USENIX conference on Operating systems design and
implementation , page 1. USENIX Association, 2010.
[10] K. Claessen and J. Hughes. QuickCheck: a lightweight
tool for random testing of Haskell programs. Acm
sigplan notices , 35(9):268{279, 2000.
[11] P. Cousot and R. Cousot. Abstract interpretation: a
unied lattice model for static analysis of programs by
construction or approximation of xpoints. In
Proceedings of the 4th ACM SIGACT-SIGPLAN
symposium on Principles of programming languages ,
pages 238{252. ACM, 1977.
[12] L. De Alfaro, T.A. Henzinger, and F.Y.C. Mang.
Mcweb: A model-checking tool for web site debugging.
InPoster presented at WWW , volume 10. Citeseer,
2001.
[13] M. Haydar, A. Petrenko, and H. Sahraoui. Formal
verication of web applications modeled by
communicating automata. Formal Techniques for
Networked and Distributed Systems{FORTE 2004 ,
pages 115{132, 2004.
[14] D. Jackson. Software Abstractions: logic, language,
and analysis . The MIT Press, 2006.
[15] S. Khurshid, C. P as areanu, and W. Visser.
Generalized symbolic execution for model checking
and testing. Tools and Algorithms for the Construction
and Analysis of Systems , pages 553{568, 2003.
[16] J.C. King. Symbolic execution and program testing.
Communications of the ACM , 19(7):385{394, 1976.
[17] DR Licata and S. Krishnamurthi. Verifying interactive
web programs. In Automated Software Engineering,
2004. Proceedings. 19th International Conference on ,
pages 164{173. IEEE.
[18] J. Nijjar and T. Bultan. Analyzing ruby on rails data
models using alloy. GSWC 2010 , page 39, 2010.
[19] J. Syriani and N. Mansour. Modeling web systems
using sdl. Computer and Information Sciences-ISCIS2003, pages 1019{1026, 2003.
[20] P. Tonella and F. Ricca. Dynamic model extraction
and statistical analysis of web applications. 2002.
[21] E. Torlak and D. Jackson. Kodkod: A relational model
nder. Tools and Algorithms for the Construction and
Analysis of Systems , pages 632{647, 2007.
[22] M. Winckler and P. Palanque. Statewebcharts: A
formal description technique dedicated to navigation
modelling of web applications. Interactive Systems.
Design, Specication, and Verication , pages 279{288,
2003.