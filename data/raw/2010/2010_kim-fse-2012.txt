A Field Study of Refactoring Challenges and Beneﬁts
Miryung Kim *
miryung@ece.utexas.eduThomas Zimmermann+
tzimmer@microsoft.comNachiappan Nagappan+
nachin@microsoft.com
* The University of Texas at Austin, TX, USA
+Microsoft Research, Redmond, WA, USA
ABSTRACT
It is widely believed that refactoring improves software qual-
ity and developer productivity. However, few empirical stud-
ies quantitatively assess refactoring beneﬁts or investigate
developers’ perception towards these beneﬁts. This paper
presents a ﬁeld study of refactoring beneﬁts and challenges
at Microsoft through three complementary study methods:
a survey, semi-structured interviews with professional soft-
ware engineers, and quantitative analysis of version history
data. Our survey ﬁnds that the refactoring deﬁnition in
practice is not conﬁned to a rigorous deﬁnition of semantics-
preserving code transformations and that developers per-
ceive that refactoring involves substantial cost and risks.
We also report on interviews with a designated refactoring
team that has led a multi-year, centralized eﬀort on refac-
toring Windows. The quantitative analysis of Windows 7
version history ﬁnds that the binary modules refactored by
this team experienced signiﬁcant reduction in the number of
inter-module dependencies and post-release defects, indicat-
ing a visible beneﬁt of refactoring.
Categories and Subject Descriptors:
D.2.7 [ Software Engineering ]: Distribution, Maintenance, and
Enhancement— restructuring
General Terms: Measurement, Experimentation
Keywords: Refactoring; empirical study; software evolu-
tion; component dependencies; defects; churn.
1. INTRODUCTION
It is widely believed that refactoring improves software
quality and developer productivity by making it easier to
maintain and understand software systems [13]. Many be-
lieve that a lack of refactoring incurs technical debt to be
repaid in the form of increased maintenance cost [5]. For ex-
ample, eXtreme Programming claims that refactoring saves
development cost [4] and advocates the rule of refactor mer-
cilessly throughout the entire project life cycles. On the
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
SIGSOFT/FSE’12 November 10 - 18 2012, Raleigh, NC, USA
Copyright 2012 ACM 978-1-4503-1614 ...$10.00.other hand, there exists a conventional wisdom that software
engineers often avoid refactoring, when they are constrained
by a lack of resources (e.g., right before major software re-
leases). Some also believe that refactoring does not provide
immediate beneﬁt unlike new features or bug ﬁxes.
Recent empirical studies show contradicting evidence on
the beneﬁt of refactoring as well. Ratzinger et al. [29] found
that, if the number of refactoring edits increases in the pre-
ceding time period, the number of defects decreases. On
the other hand, Weißgerber and Diehl found that a high
ratio of refactoring edits is often followed by an increasing
ratio of bug reports [34, 35] and that incomplete or incor-
rect refactorings cause bugs [14]. In our previous study, we
found similar evidence that refactoring edits have a strong
temporal and spatial correlation with bug ﬁxes [18].
These contradicting ﬁndings motivated us to conduct a
ﬁeld study of refactoring deﬁnition, beneﬁts, and challenges
in a large software development organization and investi-
gate whether there is a visible beneﬁt of refactoring a large
system. In this paper, we address the following research
questions: (1) What is the deﬁnition of refactoring from de-
velopers’ perspectives? By refactoring, do developers indeed
mean behavior-preserving code transformations or changes
to a program structure [23, 13]? (2) What is the develop-
ers’ perception about refactoring beneﬁts and risks, and in
which contexts do developers refactor code? (3) As claimed
in the literature, are there visible refactoring beneﬁts such
as reduction in the number of bugs, reduction in the average
size of code changes after refactoring, and reduction in the
number of component dependencies?
To investigate the deﬁnition of refactoring in practice and
the value perception toward refactoring, we conducted a sur-
vey with over three hundred engineers whose check-in com-
ments included a keyword “ refactor* ” in the last two years.
From our survey participants, we also came to know about a
multi-year refactoring eﬀort on Windows. Because Windows
is one of the largest, long-surviving software systems within
Microsoft and a designated team led an intentional eﬀort
of system-wide refactoring, we focused on the case study of
Windows. We interviewed the refactoring team and then
assessed the impact of the team’s refactoring on reduction
of inter-module dependencies and post-release defects using
Windows 7 version history.
Our ﬁeld study found the following results:
•The refactoring deﬁnition in practice seems to diﬀer
from a rigorous academic deﬁnition of behavior-pre-
serving program transformations . Our survey partic-
ipants perceived that refactoring involves substantialcost and risks, and they needed various types of tool
support beyond automated refactoring within IDEs.
•The interviews with a designated Windows refactoring
team provide insights into how system-wide refactoring
was carried out in a large organization. The team led a
centralized refactoring eﬀort by conducting an analysis
of a de-facto dependency structure and by developing
custom refactoring support tools and processes.
•The binary modules refactored by the refactoring team
had signiﬁcant reduction in the number of inter-module
dependencies and the number of post-release defects.
When comparing the top 25% of most frequently refac-
tored binaries against the top 25% of most frequently
modiﬁed binaries, there is a statistically signiﬁcant dif-
ference in changes to the total number of dependencies.
Further, the top 25% of frequently refactored binaries
reduced the number of post-release defects 12.2% more
than other modiﬁed binaries on average.
While there are many anecdotes about the beneﬁt of refac-
toring, few empirical studies quantitatively assess refactor-
ing beneﬁt. To the best of our knowledge, our study is
the ﬁrst to quantitatively assess the impact of multi-year,
system-wide refactoring on inter-module dependencies and
post-release defects in a large organization. Our study pro-
vides evidence that refactoring change is likely to be more
safe and reliable than regular change in a large system . Our
survey is also the ﬁrst large-scale investigation into the refac-
toring deﬁnition in practice and the value perception about
refactoring from developers’ perspectives. Based on our
study, we propose future research directions on refactor-
ing—we need to provide various types of tool support be-
yond automated refactorings in IDEs, such as refactoring-
aware code reviews, refactoring cost and beneﬁt estimation,
and automated validation of program correctness after refac-
toring edits.
2. RELATED WORK
Refactoring Deﬁnition. While refactoring is deﬁned as
behavior-preserving code transformations in the academic
literature [23], the de-facto deﬁnition of refactoring in prac-
tice seems to be very diﬀerent from such rigorous deﬁnition.
Fowler catalogs 72 types of structural changes in object ori-
ented programs but these transformations do not necessarily
guarantee behavior preservation [13]. In fact, Fowler recom-
mends developers to write test code ﬁrst before, since these
refactorings may change a program’s behavior. Murphy-Hill
et al. analyzed refactoring logs and found that developers
often interleave refactorings with other behavior-modifying
transformations [26], indicating that pure refactoring revi-
sions are rare. Johnson’s refactoring deﬁnition is aligned
with these ﬁndings— refactoring improves behavior in some
aspects but does not necessarily preserve behavior in all as-
pects [16]. Our survey in Section 3 also ﬁnds that refactoring
is not conﬁned to low-level, semantics-preserving transfor-
mations from developers’ perspectives.
Quantitative Assessment of Refactoring Beneﬁts. While
several prior research eﬀorts have conceptually advanced our
understanding of the beneﬁt of refactoring through metaphors,
few empirical studies assess refactoring beneﬁts quantita-
tively. Sullivan et al. ﬁrst linked software modularity withoption theories [32]. A module provides an option to substi-
tute it with a better one without symmetric obligations, and
investing in refactoring activities can be seen as purchasing
options for future adaptability, which will produce beneﬁts
when changes happen and the module can be replaced eas-
ily. Baldwin and Clark [2] argued that the modularization
of a system can generate tremendous value in an industry,
given that this strategy creates valuable options for module
improvement. Ward Cunningham drew the comparison be-
tween debt and a lack of refactoring: a quick and dirty imple-
mentation leaves technical debt that incur penalties in terms
of increased maintenance costs [8]. While these projects ad-
vanced conceptual understanding of refactoring impact, they
do not quantify the beneﬁts of refactoring.
Xing and Stroulia found that 70% of structural changes
in Eclipse’s evolution history are due to refactorings and ex-
isting IDEs lack support for complex refactorings [36]. Dig
et al. studied the role of refactorings in API evolution, and
found that 80% of the changes that break client applica-
tions are API-level refactorings [10]. While these studies
focused on the frequency and types of refactorings, they did
not focus on how refactoring impacts inter-module depen-
dencies and defects. MacCormack et al. [22] deﬁned modu-
larity metrics and used these metrics to study evolution of
Mozilla and Linux. They found that the redesign of Mozilla
resulted in an architecture that was signiﬁcantly more mod-
ular than that of its predecessor. However, unlike our study
on Windows, their study merely monitored design structure
changes in terms of modularity metrics without identifying
the modules where refactoring changes are made.
Conﬂicting Evidence on Refactoring Beneﬁt. Kataoka
et al. [17] proposed a refactoring evaluation method that
compares software before and after refactoring in terms of
coupling metrics. Kolb et al. [20] performed a case study
on the design and implementation of existing software and
found that refactoring improves software with respect to
maintainability and reusability. Moser et al. [24] conducted
a case study in an industrial, agile environment and found
that refactoring enhances quality and reusability related met-
rics. Carriere et al.’s case study found the average time
taken to resolve tickets decreases after re-architecting the
system [7]. Ratzinger et al. developed defect prediction mod-
els based on software evolution attributes and found that
refactoring related features and defects have an inverse cor-
relation [29]—if the number of refactoring edits increases in
the preceding time period, the number of defects decreases.
These studies indicated that refactoring positively aﬀects
productivity or quality measurements.
On the other hand, several research eﬀorts found contra-
dicting evidence that refactoring may aﬀect software quality
negatively. Weißgerber and Diehl found that refactoring ed-
its often occur together with other types of changes and
that refactoring edits are followed by an increasing num-
ber of bugs [34]. Kim et al. found that the number of bug
ﬁxes increases after API refactorings [18]. Nagappan and
Ball found that code churn—the number of added, deleted,
and modiﬁed lines of code—is correlated with defect den-
sity [27]— since refactoring often introduces a large amount
of structural changes to the system, some question the ben-
eﬁt of refactoring. G ¨org and Weißgerber detected errors
caused by incomplete refactorings by relating API-level refac-
torings to the corresponding class hierarchy [34].Because manual refactoring is often tedious and error-
prone, modern IDEs provide features that automate the ap-
plication of refactorings [15, 30]. However, recent research
found several limitations of tool-assisted refactorings as well.
Daniel et al. found dozens of bugs in the refactoring tools in
popular IDEs [9]. Murphy-Hill et al. found that refactoring
tools do a poor job of communicating errors and program-
mers do not leverage them as eﬀectively as they could [26].
Vakilian et al. [33] and Murphy et al. [25] found that pro-
grammers do not use some automated refactorings despite
their awareness of the availability of automated refactorings.
These contradicting ﬁndings on refactoring beneﬁts moti-
vate our survey on the value perception about refactoring.
They also motivate our analysis on the relationship between
refactoring and inter-module dependencies and defects.
Refactoring Change Identiﬁcation. A number of exist-
ing techniques address the problem of automatically infer-
ring refactorings from two program versions. These tech-
niques compare code elements in terms of their name [36]
and structure similarity to identify move and rename refac-
torings [11]. Prete et al. encode Fowler’s refactoring types
in template logic rules and use a logic query approach to
automatically ﬁnd complex refactorings from two program
versions [28]. A survey of existing refactoring reconstruc-
tion techniques is described elsewhere [28]. Kim et al. use the
results of API-level refactoring reconstruction to study the
correlation between API-level refactorings and bug ﬁxes [18].
While it is certainly possible to identify refactorings us-
ing refactoring reconstruction techniques, in our Windows 7
analysis, we identify the branches that a designated refactor-
ing team created to apply and maintain refactorings exclu-
sively and isolate changes from those branches. We believe
that our method of identifying refactorings is reliable as a
designated team conﬁrmed all refactoring branches manually
and reached a consensus about the role of those refactoring
branches within the team.
Empirical Studies on Windows. Prior studies on Win-
dows focused on primarily defect prediction. Nagappan and
Ball investigated the impact of code churn on defect density
and found that relative code churn measures were very eﬀec-
tive indicators of code quality [27]. Zimmermann and Na-
gappan built a system wide dependency graph of Windows
Server 2003. By computing network centrality measures,
they observed that network measures based on dependency
structure were 10% more eﬀective in defect prediction, com-
pared to complexity metrics [37]. More recently, Bird et
al. observed that socio-technical network measures combined
with dependency measures were stronger indicators of fail-
ures than dependency measures alone [6]. Our current study
is signiﬁcantly diﬀerent from these prior studies by distin-
guishing refactoring changes from non-refactoring changes
and by focusing on the impact of refactoring on inter-module
dependencies and defects.
3. A SURVEY OF REFACTORING
PRACTICES
In order to understand refactoring practices at Microsoft,
we sent a survey to 1290 engineers whose change comments
included the keyword “refactor*” in the last 2 years in ﬁve
Microsoft products: Windows Phone, Exchange, Windows,
Oﬃce Communication and Services (OCS), and Oﬃce. Wepurposely targeted the engineers who are already familiar
with the terms, refactor, refactoring, refactored, etc. , be-
cause our goal is to understand their own refactoring deﬁni-
tion and their perception about the value of refactoring. The
survey consisted of 22 multiple choice and free-form ques-
tions, which were designed to understand the participant’s
own refactoring deﬁnition, when and how they refactor code,
including refactoring tool usage, developers’ perception to-
ward the beneﬁts, risks, and challenges of refactoring. Ta-
ble 1 shows a summary of the survey questions; the full list
is available as a technical report [19]. We analyzed the sur-
vey responses by identifying the topics and keywords and by
tagging individual responses with the identiﬁed topics. In
total, 328 engineers participated in the survey. 83% of them
were developers, 16% of them were test engineers, 0.9% of
them were build engineers, and 0.3% of them were program
managers. The participants had 6.35 years of experience at
Microsoft and 9.74 years of experience in software industry
on average with a familiarity with C++, C, and C#.
3.1 What is a Refactoring Deﬁnition in
Practice?
When we asked, “how do you deﬁne refactoring?” , we found
that developers do not necessarily consider that refactor-
ing is conﬁned to behavior preserving transformations [23].
78% deﬁne refactoring as code transformation that improves
some aspects of program behavior such as readability, main-
tainability, or performance. 46% of developers did not men-
tion preservation of behavior, semantics, or functionality in
their refactoring deﬁnition at all. This observation is con-
sistent with Johnson’s argument [16] that, while refactoring
preserves some behavior, it does not preserve behavior in all
aspects. The following shows a few examples of refactoring
deﬁnitions by developers.1
“Rewriting code to make it better in some way.”
“Changing code to make it easier to maintain. Strictly
speaking, refactoring means that behavior does not change,
but realistically speaking, it usually is done while adding
features or ﬁxing bugs.”
When we asked, “how does the abstraction level of Martin
Fowler’s refactorings or refactoring types supported by Visual
Studio match the kinds of refactoring that you perform?” , 71%
said these basic refactorings are often a part of larger, higher-
level eﬀort to improve existing software. 46% of developers
agree that refactorings supported by automated tools diﬀer
from the kind of refactorings they perform manually. In par-
ticular, one developer said, the refactorings listed in Table 1
form the minimum granular unit of any refactoring eﬀort,
but none are worthy of being called refactoring in and of
themselves. The refactorings she performs are larger eﬀorts
aimed at interfaces and contracts to reduce software com-
plexity, which may utilize any of the listed low-level refac-
toring types, but have a larger idea behind them. As another
example, a participant said,
“These (Fowler’s refactoring types or refactoring types sup-
ported by Visual Studio) are the small code transforma-
tion tasks often performed, but they are unlikely to be
performed alone. There’s usually a bigger architectural
change behind them.”
1In the following, each italicized, indented paragraph corresponds
to a quote from answers to our survey (Section 3) or interviews
(Section 4).Table 1: Summary of Survey Questions (the full list is available as a technical report [19])
Background What is your role in your team (i.e., developer, tester, program manager, team lead, dev manager, etc.)?
Which best describes your primary work area?
How many years have you worked in software industry?
Which programming languages are you familiar with?
Deﬁnition How do you deﬁne refactoring ?
Which keywords do you use or have you seen being used to mark refactoring activities in change commit messages?
How does the abstraction level of Fowler’s refactorings such as “Extract Method” match the kinds of refactorings
that you often perform?
Context How many hours per month roughly do you spend on refactoring?
How often do you perform refactoring?
In which situations do you perform refactorings?
Value- What beneﬁts have you observed from refactoring?
Perception What are the challenges associated with performing refactorings?
Based on your own experience, what are the risks involved in refactoring?
How strongly do you agree or disagree with each of the following statements?
•Refactoring improves program readability
•Refactoring introduces subtle bugs
•Refactoring breaks other people’s code
•Refactoring improves performance
•Refactoring makes it easier to ﬁx bugs . . .
Tools What tools do you use during refactoring?
What percentage of your refactoring is done manually as opposed to using automated refactoring tools?
The following lists some of the types of refactorings. Please indicate whether you know these refactorings or used
them before. [Multiple choices: (1) usually do this both manually and using automated tools (2) usually do this
manually, (3) usually do this using automated tools, (4) know this refactoring type but don’t use it, (5) don’t
know this refactoring type.]
•Rename ,Extract Method ,Encapsulate Field ,Extract Interface ,Remove Parameters , . . .
These refactoring types were selected from Fowler’s catalog.
How strongly do you agree or disagree with each of the following statements?
•I interleave refactorings with other types of changes that modify external program behavior.
•Refactorings supported by a tool diﬀer from the kind of refactorings I perform manually.
•Refactorings that I apply are higher level changes than the ones supported by tools.
•How do you ensure program correctness after refactoring? . . .
Only a few statements are shown in this paper for presentation purposes.
These remarks indicate that the scope and types of code
transformations supported by refactoring engines are often
too low-level and do not directly match the kinds of refac-
toring that developer want to make.
3.2 What Are the Challenges Associated with
Refactoring?
When we asked developers, “what are the challenges associ-
ated with doing refactorings at Microsoft?” , 28% of developers
pointed out inherent challenges such as working on large
code bases, a large amount of inter-component dependen-
cies, the needs for coordination with other developers and
teams, and the diﬃculty of ensuring program correctness af-
ter refactoring. 29% of developers also mentioned a lack of
tool support for refactoring change integration, code review
tools targeting refactoring edits, and sophisticated refactor-
ing engines in which a user can easily deﬁne new refactoring
types. The diﬃculty of merging and integration after refac-
toring often discourages people from doing refactoring. Ver-
sion control systems that they use are sensitive to rename
and move refactoring, and it makes it hard for developers to
understand code change history after refactorings. The fol-
lowing quotes describe the challenges of refactoring change
integration and code reviews after refactoring:
“Cross-branch integration was the biggest problem. We
have this sort of problem every time we ﬁx any bug or
refactor anything, although in this case it was particularly
painful because refactoring moved ﬁles, which prevented
cross-branch integration patches from being applicable.”“It (refactoring) typically increases the number of lines/ﬁles
involved in a check-in. That burdens code reviewers and
increases the odds that your change will collide with some-
one else’s change.”
Many participants also mentioned that, when a regression
test suite is inadequate, there is no safety net for checking
the correctness of refactoring. Thus, it often prevents from
developers to initiate refactoring eﬀort.
“If there are extensive unit tests, then (it’s) great, (one)
would need to refactor the unit tests and run them, and
do some sanity testing on scenarios as well. If there are
no tests, then (one) need to go from known scenarios and
make sure they all work. If there is insuﬃcient documen-
tation for scenarios, refactoring should not be done.”
In addition to these inherent and technical challenges of
refactoring reported by the participants, maintaining back-
ward compatibility often discourages them from initiating
refactoring eﬀort.
According to self-reported data, developers do most refac-
toring manually and they do not use refactoring tools despite
their awareness of refactoring types supported by the tools.
When we asked, “what percentage of your refactoring is done
manually as opposed to using automated refactoring tools?” ,
developers said they do 86% of refactoring manually on av-
erage. Surprisingly 51% of developers do all 100% of their
refactoring manually. Figure 1 shows the percentages of de-
velopers who usually apply individual refactoring types man-
ually despite the awareness and availability of automated
refactoring tool support. Considering that 55% of these de-!"#$%&'()#!%&'(*#+%&'()#!%&'"%#$%&'(,#"%&'(!#-%&'(!#-%&',$#$%&'(,#*%&',$#$%&'!"#$%"&'()*$+)&,")-./&'#+$0123$)"&45"3/&'()*$+)&6#)"*7$+"&!"%.8"&9$*$%")"*1&6#35#"&,")-./&9233&,"%:"*1&;0&921-&,"%:"*1&<.=#&!"03$+"&>.#1)*2+).*&=5)-&4$+).*?&,")-./&;1"&@$1"&A?0"&B-"*"8"*&9.115:3"&!".*/"*&9$*$%")"*1&Figure 1: The percentage of survey participants who
know individual refactoring types but do those refac-
torings manually
!"#$%&'("$!%&!!"!(%&!)"#*%&+,"#!%&#")*%&!"#$%&&$'($'))*+%&,#()&-%.&,#*/.&,$'-0)&1'$('&!+%2*!3)&41'&3-0'%&5$+1&+3"'$&3-)0)&3')4%(&!+)3&.*6!#/3&3+&!+.'&$'7*'8&
Figure 2: The risk factors associated with refactor-
ing
velopers reported that they have automated refactoring en-
gines available in their development environments, this lack
of usage of automated refactoring engines is very surprising.
With an exception of rename refactoring, more than a half
of the participants said that they apply those refactorings
manually, despite their awareness of the refactoring types
and availability of automated tool support. This result is
aligned with Vakilian et al. [33]. Our survey responses in-
dicate that the investment in tool support for refactoring
must go beyond automated code transformation, for exam-
ple, tool support for change integration, code reviews after
refactoring, validation of program correctness, estimation of
refactoring cost and beneﬁt, etc.
“I’d love a tool that could estimate the beneﬁts of refac-
toring. Also, it’d be awesome to have better tools to help
ﬁgure out who knows a lot about the existing code to have
somebody to talk to and how it has evolved to understand
why the code was written the way it was, which helps avoid
the same mistakes.”
“I hope this research leads to improved code understanding
tools. I don’t feel a great need for automated refactoring
tools, but I would like code understanding and visualization
tools to help me make sure that my manual refactorings
are valid.”
“What we need is a better validation tool that checks cor-
rectness of refactoring, not a better refactoring tool.”
3.3 What Are the Risks and Beneﬁts of Refac-
toring?
When we asked developers, “based on your experience, what
are the risks involved in refactorings?” , they reported regres-
!"#"$%&'(#($%&!)#*$%&+!#$(%&'#+!%&)#+"%&+!#$(%&!,#+-%&+*#-)%&-#-$%&!"#$%&'()"*!+,*!+*-!.,/)!"#$%&'()$'*(*-!.!,/)0'1'$)-234)!"#$%&'()#'$0%$"*+5')5%(')4!6')$'(257%+)(2#.!5*,')5%(')$'(257%+),'4,*-!.!,/)'*4!'$),%)*(()0'*,2$')!"#$%&'()"%(2.*$!,/)$'(25'()7"'),%)"*$8',)Figure 3: Various types of refactoring beneﬁts that
developers experienced
sion bugs, code churns, merge conﬂicts, time taken from
other tasks, the diﬃculty of doing code reviews after refac-
toring, and the risk of over-engineering. Figure 2 summa-
rizes the percentage of developers who mentioned each par-
ticular risk factor. Note that the total sum is over 100% as
one developer could mention more than one risk factor. 77%
of the participants consider that refactoring comes with a
risk of introducing subtle bugs and functionality regression;
12% say that code merging is hard after refactoring; and
24% mention increased testing cost.
“The primary risk is regression, mostly from misunder-
standing subtle corner cases in the original code and not
accounting for them in the refactored code.”
“Over-engineering—you may create an unnecessary archi-
tecture that is not needed by any feature but all code chunks
have to adapt to it.”
“The value of refactoring is diﬃcult to measure. How do
you measure the value of a bug that never existed, or the
time saved on a later undetermined feature? How does this
value bubble up to management? Because there’s no way
to place immediate value on the practice of refactoring, it
makes it diﬃcult to justify to management.”
When we asked, “what beneﬁts have you observed from
refactoring?” , developers reported improved maintainability
(30%), improved readability (43%), fewer bugs (27%), im-
proved performance (12%), reduction of code size (12%), re-
duction of duplicate code (18%), improved testability (12%),
improved extensibility & easier to add new feature (27%),
improved modularity (19%), reduced time to market (5%),
etc, as shown in Figure 3.
When we asked, “in which situations do you perform refac-
torings?” developers reported the symptoms of code that
help them decide on refactoring (see Figure 4). 22% men-
tioned poor readability; 11% mentioned poor maintainabil-
ity; 11% mentioned the diﬃculty of repurposing existing
code for diﬀerent scenarios and anticipated features; 9%
mentioned the diﬃculty of testing code without refactor-
ing; 13% mentioned code duplication; 8% mentioned slow
performance; 5% mentioned dependencies to other teams’
binaries; and 9% mentioned old legacy code that they need
to work on. 46% of developers said they do refactoring in the
context of bug ﬁxes and feature additions, and 57% of the
responses indicate that refactoring is driven by immediate
concrete, visible needs of changes that they must implement
in a short term, rather than potentially uncertain beneﬁts!"#!$%&'#()%&("#(*%&+#'(%&("#+,%&,#,$%&*#-)%&*#-)%&(#'"%&)#$-%&!"#$#%&'&()**+#&,(#&,#%&'&()**!"-./-01"2!".1"*3"1(#%&'&()*4.-'&5#60,*7'08*9"/:0/;#,5"*4"-",$",5)*<0=&5#'*+&1;#(5>*?#/$*(0*4"%.=*<"=#5)*50$"*Figure 4: The symptoms of code that help develop-
ers initiate refactoring
of long-term maintainability. In addition, more than 95% of
developers do refactoring across all milestones and not only
in MQ milestones—a period designated to ﬁx bugs and clean
up code without the responsibility to add new features. This
indicates the pervasiveness of refactoring eﬀort. According
to self-reported data, developers spend about 13 hours per
month working on refactoring, which is close to 10% of their
work, assuming developers work about 160 hours per month.
4. A CASE STUDY OF WINDOWS
REFACTORING
In order to examine how the survey respondents’ percep-
tion matches reality in terms of refactoring and to inves-
tigate whether there are visible beneﬁts of refactoring, we
decided to conduct follow-up interviews with a subset of
the survey participants and to analyze the version history
data. In terms of a subject program, we decided to focus
on Windows, because it is the largest, long-surviving soft-
ware system within Microsoft and because we learned from
our survey that a designated refactoring team has led an
intentional, system-wide refactoring eﬀort for many years.
Section 4.1 describes the results of semi-structured in-
terviews with six key members of the Windows refactoring
team, and Section 4.2 describes quantitative assessment of
refactoring beneﬁts using the Windows 7 version history.
4.1 Interviews
In this section, we investigate a multi-year refactoring ef-
fort made by a designated refactoring team in Windows.
To understand the goal of this refactoring project and how
the refactoring project was carried out, we conducted one-
on-one interviews with six key members of this team. The
following describes the role of interview participants. The in-
terviews with the participants were audio-recorded and tran-
scribed later for analysis. The ﬁrst author of this paper led
all interviews.
•Architect (90 minutes)
•Architect / Development Manager (30 minutes)
•Development Team Lead (75 minutes)
•Development Team Lead (85 minutes)
•Developer (75 minutes)
•Researcher (60 minutes)
The interview study results are organized by the questions
raised during the interviews.“What motivated your team to lead this refactoring eﬀort?”
The refactoring eﬀort was initiated by a few architects who
recognized that a large number of dependencies at the bi-
nary module level could be reduced and optimized to make
modular reasoning of the system more eﬃcient. The goal of
refactoring was to maximize parallel development eﬃciency,
to avoid unwanted parallel change interference, and make it
easier to selectively rebuild and retest subsystems eﬀectively.
“When we started looking at the system as a whole, there
were so many dependencies.”
[Paraphrased for conﬁdentiality] “Two diﬀerent teams work-
ing on completely diﬀerent features could cause a build to
break if they do not watch out dependencies during our
change integration across branches”
“If X percent of the binaries are at a strongly connected
component and you touch one of those things and you have
to retest X percent of the binaries again. . . ”
“What are the goals of Windows refactoring?” The refac-
toring eﬀort was driven by foresights to repurpose the ex-
isting system to target diﬀerent execution environments at
a much faster pace than before. Thus, the refactoring eﬀort
had a business value of its own. This refactoring also in-
volved breaking inter-module dependencies by moving a set
of related functionality (APIs) from one binary to another
binary (or new binaries).
“So without taking all of [the system] stack they can take
just the pieces that they want. So ideally [with] this low
layer piece, we could release [a new product] at a much
faster cadence, right?”
“The reason we’re doing the refactoring is considered as
an important reason as the feature itself.”
“How did you carry out system-wide refactorings on a very
large system?” The refactoring team made signiﬁcant eﬀort
to analyze the de-facto binary level dependency structure
before making refactoring decisions. After the initial anal-
ysis of binary level dependencies, the team came up with a
layered architecture, where individual binaries were assigned
with layer numbers, so that the partial ordering dependency
relationships among binaries could be documented and en-
forced. To help with the analysis of de-facto dependency
structure, the team used a new tool called MaX [31]. MaX
not only computes binary level dependencies but also can
distinguish benign dependency cycles within a layer from
undesirable dependencies that go from low-level layers to the
layers above. Furthermore, the refactoring team consulted
other teams about how to decompose existing functionality
into a set of logical sub-groupings (layers).
“Our goal was actually (A) to understand the system, and
to develop a layered model of the system; and (B) to pro-
tect the model programmatically and automatically. So by
developing a mathematical model of the entire system that
is based on layer numbers and associating binaries with a
layer number, we could enforce a partial ordering—that’s
what we call it, the layer map.”
The refactoring team led centralized architecting eﬀort,
while preventing architectural degradation by other teams.
The team introduced new quality gate checks , which pre-
vented developers from committing code changes that vio-
late the layer architecture constraints to the version control
system. Furthermore, the refactoring team educated otherteams about how to use new APIs to be compliant with the
layered architecture constraints. The refactoring team then
refactored the existing system by splitting existing binaries
into sub-component binaries or by replacing existing binaries
with new binaries.
“It turns out that if you do centrally, you can do a lot of
this stuﬀ for other teams. We give them the code, and
they have a test team, and their test team evaluates what
they need to retest when they take the code. So we do the
integration for them. . . ”
“We have this completely automated so when you add a de-
pendency to something, it goes through this entire quality
gate process where the binaries get analyzed using whole
program analysis techniques.”
In addition, the refactoring team created two custom soft-
ware engineering tools to ease migration of existing binary
modules to new binary modules. Similar to how Java allows
creation of abstract classes which later can be bound to con-
crete subclasses, the team created a technology that allows
other teams to import an empty header binary for each log-
ical group of API family, which can be later bound to a
concrete binary implementation depending on the system
conﬁguration. Then a customized loader technology loads
an appropriate target binary implementation instead of the
empty header binary during the binary loading time. This
technology emulates dynamic dispatching in object-oriented
programming style and has two beneﬁts. (1) It separates
API contracts from API implementations, thus avoiding in-
clusion of unnecessary binaries in a diﬀerent execution envi-
ronment, where only a minimal functionality instead of a full
functionality is desired. (2) It enables product-line devel-
opment—variant products are built by composing diﬀerent
binary implementations. The above technology takes care of
switching between two diﬀerent API implementations during
load time, but does not take care of cases where the execu-
tion of two diﬀerent API implementations must be weaved
carefully during runtime. To handle such cases, the team
systematically inserted program changes to existing code.
Such code changes followed a special coding style guideline
for better readability and were partially automated by stub
code generation functionality.
In summary, we found that the refactoring eﬀort had the
following distinctive characteristics:
•The refactoring eﬀort was driven by foresights to re-
purpose the existing system to target diﬀerent execu-
tion environments. Thus, the refactoring had a busi-
ness value of its own.
•The team’s refactoring decisions were made after sub-
stantial analysis of a de-facto dependency structure.
•The refactoring eﬀort was centralized and top down—the
designated team made software changes systematically,
integrated the changes to a main source tree, and edu-
cated others on how to use new APIs, while preventing
architectural degradation by others.
•The refactoring was enabled and facilitated by develop-
ment of custom refactoring support tools and processes
such as MaX and quality gate check .4.2 Quantitative Analysis of Windows 7
Version History
To examine whether the refactoring done by this team
had a visible beneﬁt, we analyzed Windows 7 version history
data. We examined the impact of refactoring on two spe-
ciﬁc software measures: dependencies anddefects . Because
the primary goal of the Windows refactoring team was to re-
duce undesirable dependencies between binary modules (as
mentioned in Section 4.1), we measured reduction in inter-
module dependencies to check whether the refactoring team
indeed achieved their goal of dependency reduction. We
then focused on the relationship between refactoring and
defects , because many of our survey participants perceived
that refactoring comes with a risk of introducing defects and
regression bugs.
We identiﬁed the branches that the designated refactoring
team created to apply and maintain refactoring changes ex-
clusively and isolated changes from those branches. In Win-
dows, all changes are made to speciﬁc branches and later
merged to the main trunk. We believe that our method
of identifying refactorings is reliable as a designated team
conﬁrmed all refactoring branches manually and reached
a consensus about the role of those refactoring branches
within the team. During Windows 7 development, 1.27%
of changes were changes made to the refactoring branches
owned by the refactoring team; 98.73% of changes were
made to non-refactoring branches. The number of com-
mitters who worked on the refactoring branches was 2.04%,
while the number of committers on non-refactoring branches
was 99.84%. Note that the sum of the two is greater than
100% because some committers work both on refactoring
branches and non-refactoring branches. 94.64% of binaries
were aﬀected by at least one change from the refactoring
branches and 99.05% of binaries were aﬀected by at least
one change from non-refactoring branches. In our study,
refactored binaries are binaries where at least one change
from the refactoring branches is compiled into. For exam-
ple, if the refactoring team made edits on the refactoring
branches to split a single Vista binary into three binaries in
Windows 7, we call the three binaries as refactored binaries
in Windows 7.
4.2.1 Data Collection
For our study we used a binary module level analysis, as
this unit is typically used for program analysis within Mi-
crosoft and the smallest units to which defects are accurately
mapped. Here, a binary refers to an executable ﬁle (COM,
EXE, etc.) or a dynamic-link library ﬁle (DLL) shipped
with Windows. Binaries are assembled from several source
ﬁles and typically form a logical unit, e.g., user32.dll may
provide programs with functionality to implement graph-
ical user interfaces. A software dependency is a directed
relation between two pieces of code such as expressions or
methods. There exist diﬀerent kinds of dependencies: data
dependencies between the deﬁnition and use of values and
call dependencies between the declaration of functions and
the sites where they are called. Microsoft has an automated
tool called MaX [31] that tracks dependency information at
the function level, including calls, imports, exports, RPC,
COM, and Registry access. MaX generates a system-wide
dependency graph from both native x86 and .NET man-
aged binaries. MaX is used for change impact analysis and
for integration testing [31]. For our analysis, we generateda system-wide dependency graph with MaX at the func-
tion level. Since binaries are the lowest level of granular-
ity to which defects can be accurately mapped back to, we
lifted this graph up to the binary level in a separate post-
processing step.
Microsoft records all problems that are reported for Win-
dows in a database. In this study, we measured the changes
in the number of post-release defects—defects leading to fail-
ures that occurred in the ﬁeld within six months after the ini-
tial releases of Windows Vista or Windows 7. We collected
all problem reports classiﬁed as non-trivial (in contrast to
enhancement requests [1]) and for which the problem was
ﬁxed in a later product update. The location of the ﬁx is
used as the location of the post-release defect. To under-
stand the impact of Windows 7 refactoring, we compared
the number of dependencies and the number of post-release
defects at the binary level between Windows Vista and Win-
dows 7.
4.2.2 Where was the refactoring effort focused on?
Figure 5 shows the cumulative ratio for three Windows
Vista dependency-related measures for refactored binaries
ranked in descending order by the number of refactorings:
(1) the cumulative number of outgoing dependencies, i.e.,
Outgoing Dependencies , (2) the cumulative number of the
sum of incoming and outgoing dependencies, i.e., Total De-
pendencies , and (3) the cumulative number of neighbor bi-
naries connected via dependencies, i.e., Neighbors . Between
two binaries, multiple dependencies could exist, but they
are counted only once as neighbors. The cumulative ratio
for each measure is computed as the relative cumulative sum
for its values up to the x-th most frequently refactored
binary, normalized by the total sum of the values for all N
binaries (see the equation below).
y=P
i<x(V alue )P
i<N(V alue )(1)
The arrow in Figure 5 indicates that the top 25% most
refactored binaries cover 53.09% of all neighbor relationships
in Vista for modiﬁed binaries. Top 40% most refactored bi-
naries cover 70.51% of all neighbor relationships in Vista
for modiﬁed binaries. The percentages are similar for total
number of dependencies (61.90% for top 25% and 76.06% for
top 40% and outgoing dependencies (40.68% for top 25% and
58.26% for top 40%). These results indicate that the refac-
toring eﬀort was focused on binaries with a large number
of dependencies in Vista. This is consistent with what the
refactoring team said in the interviews: their goal is to break
a large number of unwanted dependencies between certain
modules.
4.2.3 Did refactoring reduce binary-level
dependencies?
While the total of number of binary level dependencies
among modiﬁed binaries increased from Windows Vista to
Windows 7, most frequently refactored components con-
tributed to reduction of dependencies. Consider the plot
in Figure 6, in which the Delta Neighbors (Refactored DLL)
line shows the cumulative ratio of the diﬀerences in the num-
ber of dependency neighbors for the top X percent of most
frequently refactored binaries. The Delta Neighbors (All
Changed DLLs) line shows the cumulative ratio of the dif-
ferences in the number of dependency neighbors for the top
Figure 5: The cumulative ratio of Vista dependen-
cies vs. ratio refactored binaries.
Figure 6: The cumulative ratio of the changes in
the number of inter-module dependencies between
Vista and Windows 7 vs. ratio refactored binaries.
X percent of most frequently modiﬁed binaries. Along
thex-axis, the refactored binaries are ranked in descending
order by the number of refactorings. In other words, the dif-
ference between the Delta Neighbors (All Changed DLLs) line
and the Delta Neighbors (Refactored DLLs) line is that bi-
naries are ordered by the number of refactoring commits as
opposed to the number of regular commits along the x-axis.
The Delta Neighbors (Refactored DLLs) line remains be-
low zero until 0.12, meaning that the top 12% of most fre-
quently refactored binaries did not increase the total num-
ber of dependencies. Note that in the left bottom corner,
theDelta Neighbors (All Changed DLLs) line stays above the
Delta Neighbors (All Refactored DLLs) line, implying that the
group of most frequently modiﬁed binaries increase the to-
tal number of neighbor dependencies more than the group
of most refactored binaries. Figure 7 shows a bar chart that
compares the changes to the total number of neighbor de-
pendencies per binary from Windows Vista to Windows 7
for the Top 25%, Top 25% to 50%, Top 50% to 75%, andFigure 7: Changes to the total number of neighbors
per binary
Figure 8: The cumulative ratio of defects in Win-
dows 7 for modiﬁed binaries vs. refactored binaries
Top 75% to 100% of most refactored binaries (dark gray)
and most modiﬁed binaries (light gray); the values are nor-
malized to the total increase for all modiﬁed binaries.
For example, if the total number of neighbors per binary
increased by 1 on average for modiﬁed binaries, the total
number of neighbors increased only by 0.39 per binary for
the top 25% of most frequently refactored binaries, while the
corresponding top 25% of most frequently modiﬁed binaries
increased by 0.72 on average. The increase is statistically
signiﬁcant at p <0.0001 (paired Wilcoxon test). The bar
chart indicates that the increase in the number of binary-
level dependencies is relatively lower for most frequently
refactored binaries than most frequently modiﬁed binaries.
4.2.4 Are refactored binaries more likely defect-prone
than non-refactored binaries?
Figure 8 shows the cumulative ratio for post-release de-
fects in Windows 7 for the binaries with most refactorings
(gray line) and most churn (black line)—the churn is com-
puted in terms of the number of regular commits. While
the number of Windows 7 post-release defects is slightly
correlated with the number of refactorings, the correlation is
Figure 9: Changes to the total number of post-
release defects per binary
weaker than for churn (Spearman correlation of 0.20 vs. 0.30;
also indicated by orange line below red line). This implies
that refactoring changes are less likely to lead to post release
defects than regular changes . In other words, while a pre-
vious study of defect prediction in Windows by Nagappan
and Ball [27] found code churn to be highly correlated with
defects and is a good predictor of bugs, refactoring churn
is likely to be relatively more safe and reliable than regular
churn. The top 20% of most frequently refactored binaries
are responsible for 41.6% of Windows 7 post-release defects,
while the top 20% of most modiﬁed binaries are responsible
for 55.0%. The top 40% of most frequently refactored bi-
naries are responsible for 60.3% of Windows 7 post-release
defects, while the top 40% of most modiﬁed binaries are
responsible for 77.2%.
4.2.5 Did refactoring reduce post release defects more?
Most binaries that were released in Windows Vista have
fewer post-release defects in Windows 7. Figure 9 shows that
the top 25% of refactored binaries have 12 percent more
reduction in post-release defects compared to all modiﬁed
binaries. The Spearman correlation between the amount of
refactoring and change in post-release defects is 0.368 and
statistically signiﬁcant at p <0.0001: the more refactoring
changes, the higher the decrease in post-release defects.
We also computed the cumulative ratio of Vista defects
vs. ratio of refactored binaries that are ranked in descending
order by the number of refactorings. The linear increase in
the cumulative number of defects shows that the modules
refactored by the refactoring team did not necessarily focus
on the modules with a large number of defects in Vista. Yet,
looking at Figure 9, we see that these refactored modules
experienced signiﬁcant reduction in the number of defects
in Windows 7 compared to Vista. These results indicate
that Windows 7 refactoring is correlated with reduction in
the number of defects.
5. THREATS TO VALIDITY
Internal validity. Our ﬁndings in Section 4 indicate only
correlation between the refactoring eﬀort and reduction the
number of inter-module dependencies and post-release de-
fects, notcausation—there are other confounding factors
such as the expertise level of developers that we did notexamine. It is possible that the changes to the number of
binary dependencies and post-release defects in Windows
7 are caused by factors other than refactoring such as the
types of features added in Windows 7.
Construct validity. Construct validity issues arise when
there are errors in measurement. This is negated to an ex-
tent by the fact that the entire data collection process of
failures and VCS is automated. When selecting target par-
ticipants for refactoring, we searched all check-ins with the
keyword “refactor*” based on the assumption that people
who used the word know at least approximately what it
means. The deﬁnition of refactoring from developers’ per-
spectives is broader than behavior-preserving transforma-
tions, and the granularity of refactorings also varies among
the participants. For example, some survey participants re-
fer to Fowler’s refactorings, while a large number of the
participants (71%) consider that refactorings are often a
part of larger, higher-level eﬀort to improve existing soft-
ware. In our Windows case study, we focused on system-
wide refactoring, because such refactoring granularity seems
to be aligned with the refactoring granularity mentioned by
a large number of the survey participants.
External validity. In our case, we came to know about
a multi-year refactoring eﬀort in Windows from several sur-
vey participants and to leverage this best possible scenario
where intentional refactoring was performed, we focused on
the case study of Windows. As opposed to formal experi-
ments that often have a narrow focus and an emphasis on
controlling context variables, case studies test theories and
collect data through observation in an unmodiﬁed setting.
While we acknowledge that our case study on Windows may
not generalize to other systems, most development practices
are similar to those outside of Microsoft. Furthermore, de-
velopers at Microsoft are highly representative of software
developers all over the world, as they come from diverse ed-
ucational and cultural backgrounds.2We believe that lifting
the veil on the Windows refactoring process and quantify-
ing the correlation between refactoring and defect and de-
pendency reduction could be valuable to other development
organizations. To facilitate replication our study outside Mi-
crosoft, we published the full survey questions as a technical
report [19].
6. CONCLUSIONS AND FUTURE WORK
This paper presents a three-pronged view of refactoring in
a large software development organization through a survey,
interviews, and version history data analysis. To investigate
a de-facto deﬁnition and the value perception about refac-
toring in practice, we conducted a survey with over three
hundred professional software engineers. Then to examine
whether the survey respondents’ perception matches real-
ity and whether there are visible beneﬁts of refactoring, we
interviewed a subset of engineers who led the Windows refac-
toring eﬀort and analyzed Windows 7 version history data.
Our study ﬁnds the deﬁnition of refactoring in practice is
broader than behavior-preserving program transformations .
Developers perceive that refactoring involves substantial cost
and risks and they need various types of refactoring support
beyond automated refactoring within IDEs. Our case study
of Windows shows how system-wide refactoring was carried
2Global diversity and inclusion http://www.microsoft.
come/about/diversity/en/us/default.aspxout in a very large organization. The quantitative analy-
sis of Windows 7 version history shows refactored modules
experienced higher reduction in the number of inter-module
dependencies and post-release defects than other changed
modules. Our study is one of the ﬁrst to show that refac-
toring changes are likely to be relatively more reliable than
regular changes in a large system. Based on our study, we
propose future research directions such as tool support for
refactoring-aware code reviews, refactoring cost and beneﬁt
estimation, etc.
Acknowledgements
Thanks to Galen Hunt, Tom Ball, Chris Bird, Mike Barnett,
Rob DeLine, and Andy Begel for their insightful comments.
Thanks to the Microsoft Windows refactoring team for their
help in understanding the data. Thanks to many managers
and developers who volunteered their time to participate
in our research. Miryung Kim performed this work as a
visiting researcher at Microsoft Research. This work was in
part supported by National Science Foundation under the
grants CCF-1149391, CCF-1117902, and CCF-1043810, and
by a Microsoft SEIF award.
7. REFERENCES
[1]G. Antoniol, K. Ayari, M. Di Penta, F. Khomh, and
Y.-G. Gu´ eh´ eneuc. Is it a bug or an enhancement?: a
text-based approach to classify change requests. In
CASCON ’08: Proceedings of the conference of the
center for advanced studies on collaborative research:
meeting of minds , pages 304–318. ACM, 2008.
[2]C. Y. Baldwin and K. B. Clark. Design rules: The
power of modularity volume 1. Cambridge, MA, USA,
1999. MIT Press.
[3]V. Basili, F. Shull, and F. Lanubile. Building
knowledge through families of experiments. IEEE
Transactions on Software Engineering , 25(4):456–473,
Jul/Aug 1999.
[4]K. Beck. extreme Programming explained, embrace
change . Addison-Wesley Professional, 2000.
[5]L. A. Belady and M. Lehman. A Model of Large
Program Development. IBM Systems Journal ,
15(3):225–252, 1976.
[6]C. Bird, N. Nagappan, H. Gall, B. Murphy, and
P. Devanbu. Putting it all together: Using
socio-technical networks to predict failures. In
Proceedings of the 20th International Symposium on
Software Reliability Engineering , pages 109–119. IEEE
Computer Society, 2009.
[7]J. Carriere, R. Kazman, and I. Ozkaya. A cost-beneﬁt
framework for making architectural decisions in a
business context. In ICSE ’10: Proceedings of the 32nd
ACM/IEEE International Conference on Software
Engineering , pages 149–157. ACM, 2010.
[8]W. Cunningham. The wycash portfolio management
system. In OOPSLA ’92: Addendum to the
proceedings on Object-oriented programming systems,
languages, and applications , pages 29–30, New York,
NY, USA, 1992. ACM.
[9]B. Daniel, D. Dig, K. Garcia, and D. Marinov.
Automated testing of refactoring engines. In
ESEC-FSE ’07: Proceedings of the the 6th jointmeeting of the European software engineering
conference and the ACM SIGSOFT symposium on
The foundations of software engineering , pages
185–194, New York, NY, USA, 2007. ACM.
[10]D. Dig and R. Johnson. The role of refactorings in api
evolution. In ICSM ’05: Proceedings of the 21st IEEE
International Conference on Software Maintenance ,
pages 389–398, Washington, DC, USA, 2005. IEEE
Computer Society.
[11]D. Dig and R. Johnson. Automated detection of
refactorings in evolving components. In ECOOP ’06:
Proceedings of European Conference on
Object-Oriented Programming , pages 404–428.
Springer, 2006.
[12]B. Flyvbjerg. Five misunderstandings about
case-study research. Qualitative inquiry ,
12(2):219–245, 2006.
[13]M. Fowler. Refactoring: Improving the Design of
Existing Code . Addison-Wesley Professional, 2000.
[14]C. G¨org and P. Weißgerber. Error detection by
refactoring reconstruction. In MSR ’05: Proceedings of
the 2005 international workshop on Mining software
repositories , pages 1–5, New York, NY, USA, 2005.
ACM Press.
[15]W. G. Griswold. Program Restructuring as an Aid to
Software Maintenance . PhD thesis, University of
Washington, 1991.
[16]R. Johnson. Beyond behavior preservation. Microsoft
Faculty Summit 2011, Invited Talk, July 2011.
[17]Y. Kataoka, T. Imai, H. Andou, and T. Fukaya. A
quantitative evaluation of maintainability
enhancement by refactoring. In International
Conference on Software Maintenance , pages 576–585,
2002.
[18]M. Kim, D. Cai, and S. Kim. An empirical
investigation into the role of refactorings during
software evolution. In ICSE’ 11: Proceedings of the
2011 ACM and IEEE 33rd International Conference
on Software Engineering , 2011.
[19]M. Kim, T. Zimmermann, and N. Nagappan.
Appendix to a ﬁeld study of refactoring rationale,
beneﬁts, and challenges at microsoft. Technical Report
MSR-TR-2012-4, Microsoft Research, 2012.
[20]R. Kolb, D. Muthig, T. Patzke, and K. Yamauchi.
Refactoring a legacy component for reuse in a software
product line: a case study: Practice articles. J. Softw.
Maint. Evol. , 18:109–132, March 2006.
[21]A. Kuper and J. Kuper, editors. The Social Science
Encyclopedia . Routledge, 1985.
[22]A. MacCormack, J. Rusnak, and C. Y. Baldwin.
Exploring the structure of complex software designs:
An empirical study of open source and proprietary
code. volume 52, pages 1015–1030, 2006.
[23]T. Mens and T. Tourwe. A survey of software
refactoring. IEEE Transactions on Software
Engineering , 30(2):126–139, 2004.
[24]R. Moser, A. Sillitti, P. Abrahamsson, and G. Succi.
Does refactoring improve reusability? In ICSR , pages
287–297, 2006.[25]G. C. Murphy, M. Kersten, and L. Findlater. How are
java software developers using the eclipse ide?
volume 23, pages 76–83, Los Alamitos, CA, USA, July
2006. IEEE Computer Society Press.
[26]E. Murphy-Hill, C. Parnin, and A. P. Black. How we
refactor, and how we know it. In ICSE ’09:
Proceedings of the 31st International Conference on
Software Engineering , pages 287–297, Washington,
DC, USA, 2009. IEEE Computer Society.
[27]N. Nagappan and T. Ball. Use of relative code churn
measures to predict system defect density. In ICSE
’05: Proceedings of the 27th International Conference
on Software Engineering , pages 284–292, New York,
NY, USA, 2005. ACM.
[28]K. Prete, N. Rachatasumrit, N. Sudan, and M. Kim.
Template-based reconstruction of complex
refactorings. In 2010 IEEE International Conference
on Software Maintenance , pages 1 –10, 2010.
[29]J. Ratzinger, T. Sigmund, and H. C. Gall. On the
relation of refactorings and software defect prediction.
InMSR ’08: Proceedings of the 2008 international
working conference on Mining software repositories ,
pages 35–38, New York, NY, USA, 2008. ACM.
[30]D. Roberts, J. Brant, and R. Johnson. A refactoring
tool for smalltalk. Theory and Practice of Object
Systems , 3(4):253–263, 1997.
[31]A. Srivastava, J. Thiagarajan, and C. Schertz.
Eﬃcient Integration Testing using Dependency
Analysis. Technical Report MSR-TR-2005-94,
Microsoft Research, 2005.
[32]K. Sullivan, P. Chalasani, and V. Sazawal. Software
design as an investment activity: A real options
perspective. Technical report, 1998.
[33]M. Vakilian, N. Chen, S. Negara, B. A. Rajkumar,
B. P. Bailey, and R. E. Johnson. Use, disuse, and
misuse of automated refactorings. In Software
Engineering (ICSE), 2012 34th International
Conference on , pages 233 –243, june 2012.
[34]P. Weißgerber and S. Diehl. Are refactorings less
error-prone than other changes? In MSR ’06:
Proceedings of the international workshop on Mining
software repositories , pages 112–118. ACM, 2006.
[35]P. Weißgerber and S. Diehl. Identifying refactorings
from source-code changes. In ASE ’06: Proceedings of
the 21st IEEE/ACM International Conference on
Automated Software Engineering , pages 231–240,
Washington, DC, USA, 2006. IEEE Computer Society.
[36]Z. Xing and E. Stroulia. Umldiﬀ: an algorithm for
object-oriented design diﬀerencing. In ASE ’05:
Proceedings of the 20th IEEE/ACM International
Conference on Automated Software Engineering , pages
54–65, New York, NY, USA, 2005. ACM.
[37]T. Zimmermann and N. Nagappan. Predicting defects
using network analysis on dependency graphs . ICSE
’08. ACM, New York, NY, USA, 2008.
APPENDIX
Our complete refactoring survey questions are available as a
Microsoft Research technical report, MSR-TR-2012-4: http:
//http://research.microsoft.com/apps/pubs/?id=157637 .