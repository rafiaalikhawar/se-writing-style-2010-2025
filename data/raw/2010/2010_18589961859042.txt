JRF-E: Using Model Checking to give Advice on
Eliminating Memory Model-related Bugs
KyungHee Kim
University of Florida
Gainesville, FL 30611-6120
khkim@cise.uﬂ.eduTuba Y avuz-Kahveci
University of Florida
Gainesville, FL 30611-6120
tyavuz@cise.uﬂ.eduBeverly A. Sanders
University of Florida
Gainesville, FL 30611-6120
sanders@cise.uﬂ.edu
ABSTRACT
According to Java’s relaxed memory model, programs that contain
data races need not be sequentially consistent. Executions that arenot sequentially consistent may exhibit surprising behavior such asoperations on a thread occurring in a different order than indicated
by the source code or different threads having inconsistent views of
updates of shared variables. Java Raceﬁnder (JRF) is an extensionof Java Pathﬁnder (JPF), a model checker for Java bytecode. JRFprecisely detects data races as deﬁned by the memory model and
can thus be used to verify sequential consistency. We describe an
extension to JRF, JRF-Eliminator (JRF-E), that analyzes informa-
tion collected during model checking, speciﬁcally counterexampletraces and acquiring histories, and provides advice to the program-mer on how to eliminate detected data races from a program. If dataraces have been eliminated, standard model checking and other ver-iﬁcation techniques that implicitly assume sequential consistency
can be soundly employed to verify additional properties.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veriﬁcation—
Model checking ; D.1.3 [ Programming Techniques ]: Concurrent
Programming
General Terms
Veriﬁcation
Keywords
data race, memory model, counterexample
1. INTRODUCTION
Virtually all approaches for reasoning about the behavior of con-
current programs, both the informal reasoning practiced by pro-
grammers writing a concurrent program and formal methods and
tools such as model checkers, start with an assumption of sequen-
tial consistency (SC) [21]. With SC, a concurrent program behaves
as if all of its atomic actions occur in some global order that is
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted w ithout fee provided that copies are
not made or distributed for proﬁt or co mmercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, torepublish, to post on servers or to redist ribute to lists, requires prior speciﬁc
permission and/or a fee.ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1- 4503-0116-9/10/ 09 ...$10.00.consistent with the program orde r on each thread and thus that all
threads have a consistent view of the way the memory has been up-
dated. In the past, this was reasonable assumption, and indeed, one
can ﬁnd fairly recent concurrent programming textbooks that do not
even mention memory models or sequential consistency. However,
it is no longer appropriate for this issue to be ignored by program-
mers. Optimizations by compilers and hardware that signiﬁcantly
speed up programs without affecting their sequential semantics are
not necessarily benign when executed on a mulitcore machine.
As an example, consider the following program fragment.
{ computation();
done = true; }
The (non-volatile) variable done is initially false and not accessed
bycomputation() , which updates other variables. Since the
two statements are independent, the order could be reversed1with-
out changing the sequential semantics. However, if this fragment
occurs in a concurrent program and done is intended to be a signal
to other threads that computation() is ﬁnished, then another
thread ﬁnding done true may access state that reﬂects an incom-
plete execution of computation() . This scenario is legal ac-
cording to Java semantics, but violates SC and the programmer’s
expectations.
Exactly how threads interact with memory and how the program-
mer can control this is deﬁned by a memory model . Traditionally,
memory models have been deﬁned for hardware architectures, and
program behavior with respect to the memory model is constrained
using low level operations such as fences and memory barriers.
More recently memory models have become part of a program-ming language’s semantics. The Java memory model (JMM) [23,12] is an important example. A situation that can lead to non-SCbehavior is called a data race . A program that is free from data
races will behave as if it is SC, thus corresponding to programmer
intuition and the implicit assumptions of model checkers and other
tools. In the example given above, there is a data race between thewrite of variable done by the thread executing computation()
and another thread reading done which allows SC to be violated.
Here, the race could be eliminated by using the volatile keywordwhen declaring done . The meaning of volatile will be described
formally in Section 2.1. Intuitively, compilers must avoid certainoptimization and insert memory barriers around accesses to volatilevariables in order to prevent non-SC behavior.
In previous work, we have described Java Raceﬁnder (JRF) [20,
19] an extension to the Java Pathﬁnder (JPF) model checking tool
that detects data races, as deﬁned by the JMM, precisely. In most
1Among other possibilities, write buffers or holding values updated
bycomputation() in registers instead of writing to main mem-
ory could cause this effect.
215
other work on data race detection, a data race is a situation where
conﬂicting accesses2to shared variables are not ordered by syn-
chronization, SC is (implicitly) assumed and data races are of in-
terest because they may indicate some sort of concurrency related
bug, e.g. a forgotten lock. In contrast, we are interested in the
speciﬁc notion of a data race given in the Java Memory model thatallows violations of SC.
In this paper, we describe JRF-E, an extension to JRF that, when
a data race is detected, attempts to diagnose the cause and provide
advice to the programmer about how to modify the source codeto eliminate the race. The tool analyses the counterexample tracewhich is provided as a result of model checking. It also maintainsand analyzes the acquiring history which records information about
how a variable involved in a data race has been accessed. JRF-
E greatly simpliﬁes the task of the programmer in detecting andeliminating data races in concurrent programs.
2. BACKGROUND
In this section we give a brief and informal description of the
JMM [12, Chapter 17], [2, 23] and the summary function hthat we
use to detect data races. We also describe Java Raceﬁnder (JRF),
our extension of JPF. A more complete treatment can be found in
[20].
2.1 The Java Memory Model
An execution of a Java program is a set of memory model re-
lated actions (read and write, volatile read and write, lock and un-
lock a monitor lock, start a thread, detect termination of a thread,
etc.) along with an order,po→, which totally orders the actions on
each thread, and a synchronization order,so→, that totally orders
the synchronization actions. In addition, we have the value writtenfunction, V, that assigns a value to each write, and the write-seen
function Wthat assigns a write action to each read so that the value
obtained by a read action risV(W(r)). The synchronization or-
der,so→, on an execution induces a partial order on synchronization
actions called the synchronizes-with order,sw→, according to the fol-
lowing rules:
•An unlock action on a monitor lock msynchronizes-with all
subsequent lock actions on mby any thread.
•A write to a volatile variable vsynchronizes-with all subse-
quent reads of v.
•The action of starting a thread synchronizes-with the ﬁrst ac-
tion of the newly started thread.
•The ﬁnal action in a thread synchronizes-with an action in
any other thread (e.g. join, or invoking the isAlive() method)that detects the thread’s termination.
•The writing of default values of every object ﬁeld
synchronizes-with the ﬁrst access of the ﬁeld.
In the descriptions above, "subsequent" is determined by the syn-
chronization order. Finally, the happens-before order,hb→, is partial
order on the actions in an execution obtained by taking the tran-
sitive closure of the union ofsw→andpo→. Well-formedness con-
straints on executions include unsurprising requirements such as
type correctness, correct behavior of locks, and consistency with
the sequential semantics of the program. In addition, a well-formed
2Two operations by different threads conﬂict if they access the
same memory location and at least one is a write.execution satisﬁes happens-before consistency which requires that
a read rof variable vis allowed to see the results of a write
w=W(r)provided that ris not ordered before w,i . e .¬(rhb→w),
and there is no intervening write w/primetov,i . e .¬∃w/prime:whb→w/primehb→r.
Well-formedness still allows non-determinism since normal actions
on different threads need not be ordered. Also, it is not required
that the write-seen function returns the "most recent" write to the
variable in question or that the write-seen functions for actions on
different threads are consistent, thus allowing sequentially incon-
sistent behavior3. Two operations conﬂict if neither is a synchro-
nization action, they access the same memory location, and at leastone is a write. A data race is deﬁned to be a pair of conﬂicting oper-
ations notordered byhb→.Asequentially consistent (SC) execution
is one where there is a total order,sc→, on the actions consistent with
po→andso→and where a read rof variable vsees the results of the
most recent preceding write wsuch that wsc→rand there is no in-
tervening write w/primetov,i . e .¬∃w/prime:wsc→w/primesc→r. A Java program
iscorrectly synchronized if all sequentially consistent executions
are data race free. It has been shown [23, 2] that any legal execu-tion of a well-formed correctly synchronized program appears to be
sequentially consistent.
4This result justiﬁes using a model checker
to detect data races.
2.2 Summarizinghb→with h
The function hsummarizeshb→at each point in a SC execution,
allowing data races to be detected as they occur. Let Addr be the set
of (abstract) memory locations representing non-volatile variables
in the program, SynchAddr be the set of (abstract) memory loca-
tions representing variables with volatile semantics and locks, and
Threads be the set of threads. Then h:SynchAddr ∪Threads →
2Addrmaps threads and synchronization variables to sets of non-
volatile variables so that x∈h(t)means that thread tcan read or
write variable xwithout causing a data race.
For a ﬁnite sequentially consistent execution Eof program P,a
set of static non-volatile variables static (P),l e tEnbe the preﬁx
ofEof length n, i.e. the sequence of actions a0,a1,...,a n−1,
andhnbe the value of hafter performing all of the actions in En.
We assume that thread main is the single thread that initiates the
program. Initially, h0=λz.ifz=main thenstatic (P)elseφ
The way that hn+1is obtained from hndepends on the ac-
tionan. First, we deﬁne four auxiliary functions release ,acquire ,
invalidate ,a n d new. The function release (t,x )takeshand yields
a new summary function by updating h(x)to include the value
ofh(t). It is used with actions by thread tthat correspond to the
source of asw→edge.
release (t,x )h/hatwide=h[x/mapsto→h(t)∪h(x)] (1)
The function acquire (t,x )takeshand yields a new function by
updating h(t)to include the value of h(x). It is used in actions that
form the destination of asw→edge.
acquire (t,x )h/hatwide=h[t/mapsto→h(t)∪h(x)] (2)
The function invalidate yields a new function by removing xfrom
h(z)for all z/negationslash=t. It is used in actions where thread twrites non-
3Legal executions are also required to satisfy additional causality
conditions that constrain the behavior of programs with data races,
thus providing certain safety guarantees for program with races.
Since our goal is to eliminate data races, these conditions are not
relevant here.
4JRF actually uses a slightly weaker but still sound notion of cor-
rect synchronization.
216volatile x.
invalidate (t,x )h/hatwide=λz.if(t=z)thenh(z)elseh(z)\{x}
The function newyields a new summary function by adding the set
fields to the value of h(t)and initializing the previously undeﬁned
values of hfor the new volatile variables.
new (t,ﬁelds,volatiles )h/hatwide= (3)
λz. if(t=z)thenh(t)∪ﬁelds
else if (z∈volatiles )thenφelseh(z)
The deﬁnition of hn+1, which depends on hnand action an,i s
given in Figure 1.
anby thread t
 hn+1
write a volatile ﬁeld v
 release (t,v )hn
read a volatile ﬁeld v
 acquire (t,v )hn
lock the lock variable lck
 acquire (t,lck )hn
unlock the lock variable lck
 release (t,lck )hn
start thread t/prime
release (t,t/prime)hn
join thread t/prime
acquire (t,t/prime)hn
t/prime.isAlive()
 if(t/prime.isAlive ())
then (acquire (t,t/prime)hn)
elsehn
write a non-volatile ﬁeld x
 invalidate (t,x )hn
read a non-volatile ﬁeld x
 hn
instantiate an object
 new (t,ﬁelds,volatiles )hn
Figure 1: Deﬁnition of hn+1
To extend the model checker, we maintain h, and check that
norace (x,t )=x∈h(t) (4)
holds before reading or writing non-volatile xby thread t.W h e n
this condition holds for all non-volatile reads and writes in an exe-
cution, the execution is h-legal . We have shown elsewhere [20] that
if all SC executions of a well-formed program are h-legal all of its
legal executions are SC.
2.3 Java RaceFinder
Java PathFinder (JPF) [18] model checks Java byte code by read-
ing Java class ﬁles and simulating their execution using its own vir-
tual machine with on-the-ﬂy veriﬁcation of speciﬁed properties. A
property violation is reported by JPF along with a counterexample,
the execution path that led to the violation.
JPF provides a listener interface which we used to extend its
functionality for JRF. The interface provides a set of callback func-
tions allowing low level operations such as object creation, object
locking and unlocking, the start of a new thread, and each execu-
tion of an instruction to be intercepted and augmented with user-
supplied code. JRF maintains a representation of the summaryfunction hdescribed in section 2.2; the listener code intercepts rel-
evant instructions and updates the representation as described inFigure 1. In addition, the norace property, which was deﬁned in
Equation 4, is checked prior to all non-volatile reads and writes.
Because everything, including threads and locks are objects in Java,
threads, locks, and variables are handled uniformly as "memory lo-cations" in JRF ˙Additional information about the implementation,
including the data structures used for efﬁcient implementation of
hand the specialized search heuristics used during model check-
ing can be found in [19, 20]. JRF currently can handle all Java
language features related to the JMM except for ﬁnalizers.3. COUNTEREXAMPLE ANALYSIS
JRF inherits JPF’s ability to provide the sequence of statements
(the counterexample path) that leads to a data race. This is ex-
tremely valuable information, but it is a tedious job to parse the
JRF output to determine the interleaving sequence of the threads
and the reason why the data race has occurred. JRF-E adds ananalysis phase that analyzes the counterexample path and some ad-ditional information gathered during model checking and provides
the programmer with a concise diagnosis of the problem and sug-
gestions for source code modiﬁcations to eliminate a race.
Since a data race is deﬁned to be the lack of a happens-before
edge, JRF-E can leverage the information in hto identify the state-
ment containing the write involved in a data race, which we call
thesource statement ,a n dt h e manifest statement , the read or write
where the data race occurred, i.e. where the norace condition
failed. This information is then used to provide suggestions forways to eliminate the data race by creating a happens-before rela-
tionship between those statements.
In addition to maintaining the hfunction, JRF-E also maintains
the
acquiring history . The idea is to store the synchronization op-
eration that enabled a thread tto access a memory location min a
data-race free way. If accessing mby another thread t/primeresults in a
data-race, JRF-E suggests that t/primeperform the same synchronization
operation that thread thas used before.
In any run of JRF-E multiple races will be detected. Some of
these may be manifestations of the same race (i.e. the race source
and race manifest statements are the same) occurring on different
paths. The analysis can be conﬁgured to stop when threshold
number of data races have been detected (or the whole state space
is explored). For each unique race, JRF-E generates a list of sug-
gestions that will eliminate the data race on the corresponding ex-
ecution paths. A higher threshold may allow better suggestions to
be provided at the cost of longer execution time.
A simple example will illustrate the practical beneﬁts provided
by JRF-E. A Java implementation of the program shown in Figure
2 was analyzed using JRF. Both xanddone are involved in races.
Part of the output, including the counterexample path for a data race
involving xis shown in Figure 3. The omitted output gives similar
results for additional (8 more) detected races.
/g1/g17/g19/g23/g1/g26/g8
/g1/g12/g20/g20/g18/g14/g11/g19/g1/g13/g20/g19/g14/g9/g15/g11/g18/g22/g14/g8
/g1/g1/g1/g1/g1/g1/g1/g10/g16/g21/g14/g11/g13/g1/g5/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g10/g16/g21/g14/g11/g13/g1/g6/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g1/g1/g1/g1/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g1/g1/g1/g1/g1/g1/g22/g5/g7/g1/g26/g9/g5/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g23/g5/g7/g1/g25/g16/g17/g18/g14/g1/g3/g2/g13/g20/g19/g14/g4/g8/g1/g1/g1/g1/g22/g6/g7/g1/g13/g20/g19/g14/g9/g23/g21/g24/g14/g8/g1/g1/g1/g1/g1/g1/g1/g1/g23/g6/g7/g1/g11/g22/g22/g14/g21/g23/g1/g3/g26/g9/g9/g5/g4/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g1 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
Figure 2: Thread 1 notiﬁes Thread 2 that xis set through ﬂag
done
To understand what caused the detected race, we need to decode
the counterexample path given as "trace #1" . Clearly, this is
a tedious exercise, even for this simple program where the length
of the counterexample path is only six. The path length may be
several hundred in realistic examples. In contrast, Figure 4 showsthe output of the analysis produced by JRF-E. For each unique racefound, the race source statement, the race manifest statement, andsuggestions for code modiﬁcations that will eliminate that race are
given. Note that the tool recognized that marking done as volatile
is sufﬁcient, because of the transitivity of
hb→, to also eliminate the
race on x.
217/g37/g42/g33/g1/g67/g55/g68/g70/g62/g69/g68
/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g25/g1/g54/g51/g69/g51/g1/g67/g51/g53/g55/g1/g4/g14/g60/g67/g56/g11/g58/g52/g68/g55/g69/g11/g70/g69/g59/g62/g11/g35/g29/g31/g51/g69/g51/g42/g51/g53/g55/g32/g73/g53/g55/g66/g69/g59/g65/g64
/g1/g51/g69/g1/g44/g35/g42/g32/g28/g31/g1/g1/g1/g1/g1/g1/g6/g68/g59/g63/g66/g62/g55/g11/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g5/g44/g58/g67/g55/g51/g54/g15/g27/g16/g13/g14/g1/g56/g67/g65/g63/g1/g3/g44/g58/g67/g55/g51/g54/g1/g69/g14/g1/g25/g1/g64/g55/g72/g1/g44/g58/g67/g55/g51/g54/g15/g6/g7/g24/g3/g1
/g51/g69/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g18/g1/g59/g64/g1/g6/g63/g51/g59/g64/g7/g7/g1
/g1/g69/g65/g1/g39/g32/g39/g41/g42/g46/g1/g1/g1/g1/g1/g1/g6/g68/g59/g63/g66/g62/g55/g11/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g73/g1/g56/g67/g65/g63/g1/g36/g40/g36/g44/g36/g28/g38/g36/g47/g32/g42/g7/g1
/g1/g59/g64/g1/g36/g40/g43/g44/g42/g45/g30/g44/g36/g41/g40/g1/g6/g57/g55/g69/g68/g69/g51/g69/g59/g53/g7
/g1/g65/g56/g1/g43/g41/g45/g42/g30/g32/g1/g1/g1/g1/g1/g1/g6/g3/g51/g68/g68/g55/g67/g69/g1/g6/g73/g25/g25/g14/g7/g24/g3/g1/g51/g69/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g20/g17/g7
/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g1/g69/g67/g51/g53/g55/g1/g4/g14
/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g1/g69/g67/g51/g64/g68/g59/g69/g59/g65/g64/g1/g4/g13/g1/g69/g58/g67/g55/g51/g54/g23/g1/g13/g57/g65/g71/g11/g64/g51/g68/g51/g11/g60/g66/g56/g11/g60/g71/g63/g11/g53/g58/g65/g59/g53/g55/g11/g44/g58/g67/g55/g51/g54/g30/g58/g65/g59/g53/g55/g33/g67/g65/g63/g43/g55/g69/g1/g75/g26/g63/g51/g59/g64/g76/g1/g1/g1/g1/g1/g1/g48/g15/g19/g21/g21/g1/g59/g64/g68/g64/g1/g72/g12/g65/g1/g68/g65/g70/g67/g53/g55/g68/g49
/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g17/g18/g1/g1/g1/g1/g1/g1/g23/g1/g68/g69/g51/g69/g59/g53/g1/g1/g1/g1/g1/g1/g1/g52/g65/g65/g62/g55/g51/g64/g1/g54/g65/g64/g55/g25/g56/g51/g62/g68/g55/g24
/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g17/g16/g1/g1/g1/g1/g1/g1/g23/g1/g66/g70/g52/g62/g59/g53/g1/g53/g62/g51/g68/g68/g1/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g1/g75/g1/g1/g1/g1/g1/g1/g48/g14/g1/g59/g64/g68/g64/g1/g72/g12/g65/g1/g68/g65/g70/g67/g53/g55/g68/g49/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g17/g1/g1/g1/g1/g1/g1/g23/g1/g44/g58/g67/g55/g51/g54/g1/g69/g13/g1/g25/g1/g64/g55/g72/g1/g44/g58/g67/g55/g51/g54/g14/g6/g7/g24/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g13/g1/g1/g1/g1/g1/g1/g23/g1/g68/g69/g51/g69/g59/g53/g1/g53/g62/g51/g68/g68/g1/g44/g58/g67/g55/g51/g54/g14/g1/g55/g73/g69/g55/g64/g54/g68/g1/g44/g58/g67/g55/g51/g54/g1/g1/g1/g1/g1/g1/g48/g14/g21/g14/g1/g59/g64/g68/g64/g1/g72/g12/g65/g1/g68/g65/g70/g67/g53/g55/g68/g49/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g13/g1/g1/g1/g1/g1/g1/g23/g1/g68/g69/g51/g69/g59/g53/g1/g53/g62/g51/g68/g68/g1/g44/g58/g67/g55/g51/g54/g14/g1/g55/g73/g69/g55/g64/g54/g68/g1/g44/g58/g67/g55/g51/g54/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g17/g1/g1/g1/g1/g1/g1/g23/g1/g44/g58/g67/g55/g51/g54/g1/g69/g13/g1/g25/g1/g64/g55/g72/g1/g44/g58/g67/g55/g51/g54/g14/g6/g7/g24/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g18/g1/g1/g1/g1/g1/g1/g23/g1/g44/g58/g67/g55/g51/g54/g1/g69/g14/g1/g25/g1/g64/g55/g72/g1/g44/g58/g67/g55/g51/g54/g15/g6/g7/g24/g1/g1/g1/g1/g1/g1/g48/g14/g1/g59/g64/g68/g64/g1/g72/g12/g65/g1/g68/g65/g70/g67/g53/g55/g68/g49
/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g22/g1/g1/g1/g1/g1/g1/g23/g1/g68/g69/g51/g69/g59/g53/g1/g53/g62/g51/g68/g68/g1/g44/g58/g67/g55/g51/g54/g15/g1/g55/g73/g69/g55/g64/g54/g68/g1/g44/g58/g67/g55/g51/g54
/g1/g1/g1/g1/g1/g1/g48/g14/g1/g59/g64/g68/g64/g1/g72/g12/g65/g1/g68/g65/g70/g67/g53/g55/g68/g49/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g18/g1/g1/g1/g1/g1/g1/g23/g1/g44/g58/g67/g55/g51/g54/g1/g69/g14/g1/g25/g1/g64/g55/g72/g1/g44/g58/g67/g55/g51/g54/g15/g6/g7/g24/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g22/g1/g1/g1/g1/g1/g1/g23/g1/g68/g69/g51/g69/g59/g53/g1/g53/g62/g51/g68/g68/g1/g44/g58/g67/g55/g51/g54/g15/g1/g55/g73/g69/g55/g64/g54/g68/g1/g44/g58/g67/g55/g51/g54/g1/g1/g1/g1/g1/g1/g48/g14/g16/g17/g1/g59/g64/g68/g64/g1/g72/g12/g65/g1/g68/g65/g70/g67/g53/g55/g68/g49/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g22/g1/g1/g1/g1/g1/g1/g23/g1/g68/g69/g51/g69/g59/g53/g1/g53/g62/g51/g68/g68/g1/g44/g58/g67/g55/g51/g54/g15/g1/g55/g73/g69/g55/g64/g54/g68/g1/g44/g58/g67/g55/g51/g54/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g18/g1/g1/g1/g1/g1/g1/g23/g1/g44/g58/g67/g55/g51/g54/g1/g69/g14/g1/g25/g1/g64/g55/g72/g1/g44/g58/g67/g55/g51/g54/g15/g6/g7/g24/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g19/g1/g1/g1/g1/g1/g1/g23/g1/g69/g13/g11/g68/g69/g51/g67/g69/g6/g7/g24/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g1/g69/g67/g51/g64/g68/g59/g69/g59/g65/g64/g1/g4/g14/g1/g69/g58/g67/g55/g51/g54/g23/g1/g13/g57/g65/g71/g11/g64/g51/g68/g51/g11/g60/g66/g56/g11/g60/g71/g63/g11/g53/g58/g65/g59/g53/g55/g11/g44/g58/g67/g55/g51/g54/g30/g58/g65/g59/g53/g55/g33/g67/g65/g63/g43/g55/g69/g1/g75/g63/g51/g59/g64/g9/g26/g44/g58/g67/g55/g51/g54/g10/g13/g76/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g19/g1/g1/g1/g1/g1/g1/g23/g1/g69/g13/g11/g68/g69/g51/g67/g69/g6/g7/g24
/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g20/g1/g1/g1/g1/g1/g1/g23/g1/g69/g14/g11/g68/g69/g51/g67/g69/g6/g7/g24
/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g1/g69/g67/g51/g64/g68/g59/g69/g59/g65/g64/g1/g4/g15/g1/g69/g58/g67/g55/g51/g54/g23/g1/g13/g57/g65/g71/g11/g64/g51/g68/g51/g11/g60/g66/g56/g11/g60/g71/g63/g11/g53/g58/g65/g59/g53/g55/g11/g44/g58/g67/g55/g51/g54/g30/g58/g65/g59/g53/g55/g33/g67/g65/g63/g43/g55/g69/g1/g75/g63/g51/g59/g64/g9/g44/g58/g67/g55/g51/g54/g10/g13/g9/g26/g44/g58/g67/g55/g51/g54/g10/g14/g76/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g20/g1/g1/g1/g1/g1/g1/g23/g1/g69/g14/g11/g68/g69/g51/g67/g69/g6/g7/g24/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g18/g21/g1/g1/g1/g1/g1/g1/g23/g1/g76/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g1/g69/g67/g51/g64/g68/g59/g69/g59/g65/g64/g1/g4/g16/g1/g69/g58/g67/g55/g51/g54/g23/g1/g14/g57/g65/g71/g11/g64/g51/g68/g51/g11/g60/g66/g56/g11/g60/g71/g63/g11/g53/g58/g65/g59/g53/g55/g11/g44/g58/g67/g55/g51/g54/g30/g58/g65/g59/g53/g55/g33/g67/g65/g63/g43/g55/g69/g1/g75/g44/g58/g67/g55/g51/g54/g10/g13/g9/g26/g44/g58/g67/g55/g51/g54/g10/g14/g76/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g17/g1/g1/g1/g1/g1/g1/g23/g1/g73/g1/g25/g1/g14/g24/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g1/g69/g67/g51/g64/g68/g59/g69/g59/g65/g64/g1/g4/g17/g1/g69/g58/g67/g55/g51/g54/g23/g1/g14/g57/g65/g71/g11/g64/g51/g68/g51/g11/g60/g66/g56/g11/g60/g71/g63/g11/g53/g58/g65/g59/g53/g55/g11/g44/g58/g67/g55/g51/g54/g30/g58/g65/g59/g53/g55/g33/g67/g65/g63/g43/g55/g69/g1/g75/g44/g58/g67/g55/g51/g54/g10/g13/g9/g26/g44/g58/g67/g55/g51/g54/g10/g14/g76
/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g17/g1/g1/g1/g1/g1/g1/g23/g1/g73/g1/g25/g1/g14/g24
/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g18/g1/g1/g1/g1/g1/g1/g23/g1/g54/g65/g64/g55/g1/g25/g1/g69/g67/g70/g55/g24/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g1/g69/g67/g51/g64/g68/g59/g69/g59/g65/g64/g1/g4/g18/g1/g69/g58/g67/g55/g51/g54/g23/g1/g14/g57/g65/g71/g11/g64/g51/g68/g51/g11/g60/g66/g56/g11/g60/g71/g63/g11/g53/g58/g65/g59/g53/g55/g11/g44/g58/g67/g55/g51/g54/g30/g58/g65/g59/g53/g55/g33/g67/g65/g63/g43/g55/g69/g1/g75/g44/g58/g67/g55/g51/g54/g10/g13/g9/g26/g44/g58/g67/g55/g51/g54/g10/g14/g76/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g18/g1/g1/g1/g1/g1/g1/g23/g1/g54/g65/g64/g55/g1/g25/g1/g69/g67/g70/g55/g24/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g19/g19/g1/g1/g1/g1/g1/g1/g23/g1/g76/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g10/g1/g69/g67/g51/g64/g68/g59/g69/g59/g65/g64/g1/g4/g19/g1/g69/g58/g67/g55/g51/g54/g23/g1/g15
/g57/g65/g71/g11/g64/g51/g68/g51/g11/g60/g66/g56/g11/g60/g71/g63/g11/g53/g58/g65/g59/g53/g55/g11/g44/g58/g67/g55/g51/g54/g30/g58/g65/g59/g53/g55/g33/g67/g65/g63/g43/g55/g69/g1/g75/g26/g44/g58/g67/g55/g51/g54/g10/g14/g76
/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g20/g16/g1/g1/g1/g1/g1/g1/g23/g1/g72/g58/g59/g62/g55/g6/g2/g54/g65/g64/g55/g7/g1/g75/g1/g12/g8/g68/g66/g59/g64/g8/g12/g1/g76/g1/g1/g68/g59/g63/g66/g62/g55/g12/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g20/g17/g1/g1/g1/g1/g1/g1/g23/g1/g51/g68/g68/g55/g67/g69/g1/g6/g73/g25/g25/g14/g7/g24/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g1/g68/g64/g51/g66/g68/g58/g65/g69/g1/g4/g14
/g69/g58/g67/g55/g51/g54/g1/g59/g64/g54/g55/g73/g25/g15/g9/g64/g51/g63/g55/g25/g44/g58/g67/g55/g51/g54/g10/g14/g9/g68/g69/g51/g69/g70/g68/g25/g42/g45/g40/g40/g36/g40/g34/g9/g69/g58/g59/g68/g25/g68/g59/g63/g66/g62/g55/g11/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g5/g44/g58/g67/g55/g51/g54/g15/g27/g16/g13/g14/g9
/g66/g67/g59/g65/g67/g59/g69/g74/g25/g18/g9/g62/g65/g53/g61/g30/g65/g70/g64/g69/g25/g13/g9/g68/g70/g68/g66/g55/g64/g54/g30/g65/g70/g64/g69/g25/g13
/g1/g1/g53/g51/g62/g62/g1/g68/g69/g51/g53/g61/g23
/g51/g69/g1/g68/g59/g63/g66/g62/g55/g11/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g5/g44/g58/g67/g55/g51/g54/g15/g11/g67/g70/g64/g6/g43/g59/g63/g66/g62/g55/g42/g51/g53/g55/g11/g60/g51/g71/g51/g23/g20/g17/g7
/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g50/g1/g69/g67/g51/g53/g55/g1/g4/g15
/g1/g11/g1/g11/g1/g11/g1/g6/g68/g59/g63/g59/g62/g51/g67/g1/g65/g70/g69/g66/g70/g69/g1/g56/g65/g67/g1/g21/g1/g51/g54/g54/g59/g69/g59/g65/g64/g51/g62/g1/g69/g67/g51/g53/g55/g68/g1/g65/g63/g59/g69/g69/g55/g54/g7
Figure 3: Partial output from JRF for the program in Figure 2.
Eight similar traces have been omitted.
Change a (non-array element ) variable to volatile or
implement with an atomic class.
Due to the semantics of volatile variables in Java, changing a
variable involved in a race to volatile is always sufﬁcient to elimi-
nate a data race involving that variable. Since volatile variables in-
hibit compiler optimizations and accesses to volatiles incur runtime
overhead, the trivial way of eliminating races by making everythingvolatile is undesirable.
Changing a variable to volatile likely to be the most appropri-
ate in situations where this variable is being used for publication
(i.e. making the reference to a new object instance visible to other
threads). Unsafe publication [10] is a common error in concurrent
Java programs written by programmers without a good understand-ing of the JMM and can lead to a situation where another threadsees a partially initialized object.
Another guaranteed solution is to replace the variable with a ﬁ-
nal
5reference to an instance of the atomic class corresponding to
the variable’s type in the java.util.concurrent.atomic
package. For example, replace an int variable with an instance of
thejava.util.concurrent.atomic.AtomicInteger
5Final ﬁelds must be set in the constructor, cannot be modiﬁed,
and have special semantics in the JMM. Note that the value encap-
sulated in the atomic object can change, just not the object itself./g31/g35/g28/g8/g27/g1/g35/g27/g36/g38/g32/g37
/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22 /g1/g46/g43/g62/g43/g1/g60/g43/g45/g47/g1/g4/g12
/g52/g60/g48/g9/g50/g44/g61/g47/g62/g9/g63/g62/g51/g54/g9/g29/g24/g26/g43/g62/g43/g35/g43/g45/g47/g27/g66/g45/g47/g58/g62/g51/g57/g56 /g1/g9/g1/g9/g1/g9
/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42 /g1/g43/g56/g43/g54/g67/g68/g47/g1/g45/g57/g63/g56/g62/g47/g60/g1/g47/g66/g43/g55/g58/g54/g47/g1
/g46/g43/g62/g43/g1/g60/g43/g45/g47/g1/g61/g57/g63/g60/g45/g47/g1/g61/g62/g43/g62/g47/g55/g47/g56/g62 /g1/g20/g1/g3/g58/g63/g62/g61/g62/g43/g62/g51/g45 /g3/g1/g43/g62/g1/g61/g51/g55/g58/g54/g47/g10/g36/g51/g55/g58/g54/g47/g35/g43/g45/g47/g9/g52/g43/g64/g43/g20/g17/g15 /g1/g1/g20/g1/g3/g66/g1/g22/g1/g12/g21/g3
/g46/g43/g62/g43/g1/g60/g43/g45/g47/g1/g55/g43/g56/g51/g48/g47/g61/g62 /g1/g61/g62/g43/g62/g47/g55/g47/g56/g62 /g1/g20/g1/g3/g49/g47/g62/g61/g62/g43/g62/g51/g45 /g3/g1/g43/g62/g1/g61/g51/g55/g58/g54/g47/g10/g36/g51/g55/g58/g54/g47/g35/g43/g45/g47/g9/g52/g43/g64/g43/g20/g18/g15/g20 /g1/g3/g43/g61/g61/g47/g60/g62/g1/g5/g66/g22/g22/g12/g6/g21/g3
/g25/g50/g43/g56/g49/g47/g1/g62/g50/g47/g1/g48/g51/g47/g54/g46/g1/g3/g61/g51/g55/g58/g54/g47/g9/g36/g51/g55/g58/g54/g47/g35/g43/g45/g47/g9/g66 /g1/g48/g60/g57/g55/g1/g30/g33/g30/g37/g30/g23/g32/g30/g39/g27/g35 /g3/g1/g62/g57/g1/g64/g57/g54/g43/g62/g51/g54/g47/g9
/g25/g50/g43/g56/g49/g47/g1/g62/g50/g47/g1/g48/g51/g47/g54/g46/g1/g3/g61/g51/g55/g58/g54/g47/g9/g36/g51/g55/g58/g54/g47/g35/g43/g45/g47/g9/g46/g57/g56/g47 /g1/g48/g60/g57/g55/g1/g30/g33/g30/g37/g30/g23/g32/g30/g39/g27/g35 /g3/g1/g62/g57/g1/g64/g57/g54/g43/g62/g51/g54/g47/g9
/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42 /g1/g43/g46/g64/g51/g45/g47/g1/g48/g60/g57/g55/g1/g43/g45/g59/g63/g51/g60/g51/g56/g49 /g1/g50/g51/g61/g62/g57/g60/g67
/g33/g34/g33/g27
/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22/g22 /g1/g46/g43/g62/g43/g1/g60/g43/g45/g47/g1/g4/g13
/g52/g60/g48/g9/g50/g44/g61/g47/g62/g9/g63/g62/g51/g54/g9/g29/g24/g26/g43/g62/g43/g35/g43/g45/g47/g27/g66/g45/g47/g58/g62/g51/g57/g56 /g1/g9/g1/g9/g1/g9
/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42 /g1/g43/g56/g43/g54/g67/g68/g47/g1/g45/g57/g63/g56/g62/g47/g60/g1/g47/g66/g43/g55/g58/g54/g47/g1
/g46/g43/g62/g43/g1/g60/g43/g45/g47/g1/g61/g57/g63/g60/g45/g47/g1/g61/g62/g43/g62/g47/g55/g47/g56/g62 /g1/g20/g1/g3/g58/g63/g62/g61/g62/g43/g62/g51/g45 /g3/g1/g43/g62/g1/g61/g51/g55/g58/g54/g47/g10/g36/g51/g55/g58/g54/g47/g35/g43/g45/g47/g9/g52/g43/g64/g43/g20/g17/g16 /g1/g1/g20/g1/g3/g46/g57/g56/g47/g1/g22/g1/g62/g60/g63/g47/g21/g3
/g46/g43/g62/g43/g1/g60/g43/g45/g47/g1/g55/g43/g56/g51/g48/g47/g61/g62 /g1/g61/g62/g43/g62/g47/g55/g47/g56/g62 /g1/g20/g1/g3/g49/g47/g62/g61/g62/g43/g62/g51/g45 /g3/g1/g43/g62/g1/g61/g51/g55/g58/g54/g47/g10/g36/g51/g55/g58/g54/g47/g35/g43/g45/g47/g9/g52/g43/g64/g43/g20/g18/g14/g20 /g1/g3/g65/g50/g51/g54/g47/g5/g2/g46/g57/g56/g47/g6/g1/g69/g1/g10/g7/g61/g58/g51/g56/g7/g10 /g1/g70/g3
/g25/g50/g43/g56/g49/g47/g1/g62/g50/g47/g1/g48/g51/g47/g54/g46/g1/g3/g61/g51/g55/g58/g54/g47/g9/g36/g51/g55/g58/g54/g47/g35/g43/g45/g47/g9/g46/g57/g56/g47 /g1/g48/g60/g57/g55/g1/g30/g33/g30/g37/g30/g23/g32/g30/g39/g27/g35 /g3/g1/g62/g57/g1/g64/g57/g54/g43/g62/g51/g54/g47/g9
/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42 /g1/g43/g46/g64/g51/g45/g47/g1/g48/g60/g57/g55/g1/g43/g45/g59/g63/g51/g60/g51/g56/g49 /g1/g50/g51/g61/g62/g57/g60/g67
/g33/g34/g33/g27
/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42 /g1/g48/g60/g47/g59/g63/g47/g56/g45/g67 /g1/g57/g48/g1/g43/g46/g64/g51/g45/g47
/g40/g12/g62/g51/g55/g47/g61/g41 /g1/g25/g50/g43/g56/g49/g47/g1/g62/g50/g47/g1/g48/g51/g47/g54/g46/g1/g3/g61/g51/g55/g58/g54/g47/g9/g36/g51/g55/g58/g54/g47/g35/g43/g45/g47/g9/g66 /g1/g48/g60/g57/g55/g1/g30/g33/g30/g37/g30/g23/g32/g30/g39/g27/g35 /g3/g1/g62/g57/g1/g64/g57/g54/g43/g62/g51/g54/g47/g9
/g40/g13/g62/g51/g55/g47/g61/g41 /g1/g25/g50/g43/g56/g49/g47/g1/g62/g50/g47/g1/g48/g51/g47/g54/g46/g1/g3/g61/g51/g55/g58/g54/g47/g9/g36/g51/g55/g58/g54/g47/g35/g43/g45/g47/g9/g46/g57/g56/g47 /g1/g48/g60/g57/g55/g1/g30/g33/g30/g37/g30/g23/g32/g30/g39/g27/g35 /g3/g1/g62/g57/g1/g64/g57/g54/g43/g62/g51/g54/g47/g9
/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42/g42 /g1/g61/g62/g43/g62/g51/g61/g62/g51/g45
/g31/g35/g28/g1/g62/g43/g53/g47/g61/g1/g11/g20/g11/g20/g12/g1/g62/g57/g1/g48/g51/g56/g46/g1/g13/g1/g47/g59/g63/g51/g64/g43/g54/g47/g56/g62 /g1/g60/g43/g45/g47/g61/g1/g65/g51/g62/g50/g1/g19/g1/g45/g57/g63/g56/g62/g47/g60/g47/g66/g43/g55/g58/g54/g47 /g1/g62/g60/g43/g45/g47/g61/g9
/g31/g35/g28/g8/g27/g1/g62/g43/g53/g47/g61/g1/g11/g20/g11/g20/g11/g1/g51/g56/g1/g19/g1/g60/g43/g45/g47/g61/g1/g43/g56/g43/g54/g67/g61/g51/g61/g9
Figure 4: JRF-E output which explains the source of the race and
suggests how to eliminate it
class. These classes are less convenient than volatiles because they
must be accessed with get andset methods and are the better
choice only if the lock-free atomi c update methods they provide are
needed. These atomic update methods include compareAndSet ,
which is frequently used in lock-free algorithms, and where appro-
priate for the type, methods such as getAndAdd ,addAndGet ,
getAndIncrement ,e t c .
Change an array to an atomic array.
Atomic arrays for various element types are provided int the
java.util.concurrent.atomic package. They provide
volatile semantics for array elements and thus this change is always
sufﬁcient to eliminate data races involving array elements. Arrays
are objects in Java and a frequent error is to mark an array refer-
ence volatile without realizing that this does not provide volatile
semantics for the accesses to the elements.
Move source statement.
Data races can sometimes be avoided by placing the source state-
ment before a statement, s1, that is the source of a happens-before
edge. Assume that the happens-before edge is between s1and
statement s2. As long as the source statement and s1are executed
by the same thread and hence ordered by happens-before due to
program order and similarly s2and the manifest statement are or-
dered by happens-before, the move creates a happens-before edge
between the source and the manifest statements due to transitivity
of the happens-before relation.
The algorithm in Figure 6 ﬁrst calls the ﬁndHBEdges algorithm
in Figure 5 to compute all the happens-before edges that result fromsynchronization actions on the counterexample path.
A happens-before edge is a pair of instructions where the release
instruction is the source vertex and the matching acquire instruc-
tion is the destination vertex. Instructions are identiﬁed by theirpositions on the counterexample path. After having all pairs rep-resenting the happens-before edges on the counterexample path,Figure 6 compares the (source statement, manifest statement) pair,
(raceSourceIndex ,raceManifestIndex ), with all other pairs from the
set of happens-before edges. If moving the source statement be-
fore a statement that is the source of a happens-before edge and hasbeen executed before the source stat ement creates a happens-before
edge between the source statement and the manifest statement, the
move is suggested.
As an example, consider the program in Figure 7 where goFlag
218Algorithm ﬁndHBEdges (pathInstr ):Set of integer pairs
Stack pathInstr
Set of integer pairs HBEdges ←∅
forindexDest from size(pathInstr) to1do
ifpathInstr(indexDest) is an acquire then
forindexSource from indexDest-1 to1do
ifpathInstr(indexSource) is a release matching
pathInstr(indexDest) then
HBEdges ←HBEdges ∪(indexSource,indexDest)
break
return HBEdges
Figure 5: Find the set of happens-before edges through synchro-
nization actions on path pathInstr .
Algorithm makeMoveSourceInstructionSuggestions (pathInstr ,raceManifestIndex ,
raceSourceIndex )
Stack pathInstr
integer raceManifestIndex ,raceSourceIndex
Set of integer pairs HBEdges ←ﬁndHBEdges (pathInstr )
foreach pair p=(i1,i2)∈HBEdges do
ifi1<raceSourceIndex
AND
(raceSourceIndex ,raceManifestIndex )intersects p
AND
same thread executed pathInstr(i1) and pathInstr(raceSourceIndex)
ANDsame thread executed pathInstr(i2) and pathInstr(raceManifestIndex) -
then
print "Move instruction at raceSourceIndex before i1"
Figure 6: Suggest moving instruction
andpublish are shared variables. Since publish is a reference,
the object to which it refers can also be accessed by both threads.6
Thread 1 creates an object at line s1which is currently accessible
only by itself. Then it publishes the object by storing the reference
in a shared variable publish at line s2. The state of the object is
updated at line s3and shared variable goFlag is set to true at line
s4declaring that object descriptor has been set and can safely be
read by other threads. Thread 2 checks whether publish is not
null at line t1and if so, spins until the global ﬂag becomes true at
linet2and reads the object descriptor in line t3.
Figure 8 shows part of the state space of the example in Figure
7. The data race can be eliminated by moving s4before s2as
it creates a happens-before edge between s4andt2,w h i c hf o l -
lows from the transitive property of the happens-before relation-
ship: s4hb→s2,s2hb→t1,a n dt1hb→t2implies s4hb→t2.
Use a synchronized block.
Using consistent locking is one way of creating happens-before
edges between accesses to shared data. Using synchronized blocks
is one way of implementing locking in Java. The algorithm in Fig-
ure 9 ﬁnds all the locks that are released after the source statement
and before the manifest statement and suggests protecting the man-ifest statement with these locks by referring to the speciﬁc sourcelines that performs the locking.
Figure 10 shows an example in which Thread 1 acquires a lock
before accessing the shared data data whereas Thread 2 does not
acquire any lock before accessing data . Figure 11 shows the
counterexample path that manifests the data race on data .A ts3
Thread 1 unlocks lock before the manifest statement t1. The data
6Since JPF is working at the bytecode level, accessing a ﬁeld po-
tentially involves two bytecode instructions–one to get a reference
to the object and one to access the ﬁeld./g19/g29/g29/g27/g22/g18/g28/g1/g24/g29/g15/g27/g18/g24/g12
/g36/g29/g27/g18/g34/g26/g27/g22/g1/g14/g18/g34/g18/g1/g30/g35/g19/g27/g26/g33/g25/g12
/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g17/g25/g32/g22/g18/g21/g1/g7/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g17/g25/g32/g22/g18/g21/g1/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13 /g1/g1/g1/g1/g1/g1/g1/g1 /g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13/g13 /g1/g1/g1/g1
/g1/g33/g7/g11/g1/g1/g32/g1/g13/g1/g28/g22/g37/g1/g14/g18/g34/g18/g4/g5/g12/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g34 /g7/g11/g1/g26/g23/g1/g4/g30/g35/g19/g27/g26/g33/g25/g1/g2/g13/g1/g28/g35/g27/g27 /g5/g1/g38/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
/g1/g33/g8/g11/g1/g1/g30/g35/g19/g27/g26/g33/g25/g1/g13/g1/g32/g12/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g34 /g8/g11/g1/g1/g1/g1/g37 /g25/g26/g27/g22/g1/g4/g2/g24/g29/g15/g27/g18/g24/g5/g12/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
/g1/g33/g9/g11/g1/g1/g32/g6/g33/g22/g34/g14/g22/g33/g20/g4/g3/g22/g3/g5/g12 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g34 /g9/g11/g1/g1/g1/g1/g16/g34/g32/g26/g28/g24/g1/g33/g1/g13/g1/g1/g30/g35/g19/g27/g26/g33/g25/g6/g24/g22/g34/g14/g22/g33/g20/g4/g5/g12/g1/g1
/g1/g33/g10/g11/g1/g1/g24/g29/g15/g27/g18/g24/g1/g13/g1/g34/g32/g35/g22/g12/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g34 /g10/g11/g1/g1/g1/g1/g18/g33/g33/g22/g32/g34/g4/g33/g6/g22/g31/g35/g18/g27/g33/g4/g3/g22/g3/g5/g12 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g39/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
Figure 7: ViagoFlag Thread 1 notiﬁes Thread 2 when object
publish is ready to be used.
DATA RACEState space
r = new Data();
publish= r
goFlag = true;
if (publish != null)(s2)(t1)
(s3)
(s4)(s1)
(s2)
(s3)
(s4)
(t1)if (publish != null)r = new Data();
publish= r
r.setDesc();
goFlag = true;(s1)
while (!goFlag); (t2)r.setDesc();
data race source statementhappens−before edge
(not ordered by happens−before)
data race manifesting statement
2. move goFlag = true before publish = 
r1. make goFlag volatileWays to prevent data race:
NO DATA RACE
Figure 8: Part of the state space of the showing a data race free
path and a path with a data race.
Algorithm makePutInSynchronizedBlockSuggestions (pathInstr ,raceSourceIndex ,
raceManifestIndex )
Stack pathInstr
integer raceSourceIndex ,raceManifestIndex
Set of InstructionLocations syncLoc ←∅
forindex from size(pathInstr) toraceSourceIndex+1 do
ifpathInstr(index) is a MONITOREXIT instruction OR
RETURN instruction of a synchronized method then
letlocdenote the source line for pathInstr(index)
syncLoc ←syncLoc ∪{loc}
foreach source line loc∈syncLoc do
print "Put instruction pathInstr(raceManifestIndex)
in synchronized block as in line loc"
Figure 9: Suggest a synchronized block.
/g1/g20/g24/g29/g1/g17/g14/g29/g14/g10
/g1/g36/g24/g14/g23/g1/g12/g15/g21/g18/g16/g29 /g1/g23/g25/g16/g22/g11/g24/g18/g31 /g1/g12/g15/g21/g18/g16/g29/g2/g3/g10
/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g13/g19/g27/g18/g14/g17 /g1/g6/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g13/g19/g27/g18/g14/g17 /g1/g7/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11 /g1/g1/g1/g1/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11/g11 /g1/g1/g1/g1
/g1/g1/g28/g6/g9/g1/g28/g32/g24/g16/g19/g27/g25/g24/g20/g33/g18/g17 /g1/g2/g23/g25/g16/g22/g3 /g1/g34/g1/g5/g4/g23/g25/g16/g22/g4/g5 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g29/g6/g9/g1/g26/g27/g20/g24/g29/g1/g2/g17/g14/g29/g14/g3/g10 /g1/g1
/g1/g1/g28/g7/g9/g1/g17/g14/g29/g14/g1/g11/g1/g6/g10
/g1/g1/g28/g8/g9/g1/g35/g1/g5/g4/g30/g24/g23/g25/g16/g22/g4/g5 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
Figure 10: Thread 2 need to synchronize on lock to access data
race can be eliminated by making Thread 2 acquire lock before
t1.
Change other memory locations to volatile or use
atomic arrays.
One way of creating a happens-before edge between the source
and the manifest statement is to create a happens-before edge be-
tween a pair of statements (s1,s2)that come between the source
and the manifest statement in the execution sequence, i.e.,
219/g13/g32/g15/g32/g19/g1/g31/g29/g15/g17/g19/g1
/g31/g36/g27/g17/g22/g30/g28/g27/g23/g37/g19/g18/g2/g25/g28/g17/g24/g3/g1/g38/g6/g4/g25/g28/g17/g24/g4/g6/g1/g2/g31/g7/g3/g1
/g18/g15/g32/g15/g12/g7/g11/g1 /g1 /g1 /g2/g31/g8/g3/g1
/g39/g1/g6/g4/g33/g27/g25/g28/g17/g24/g4/g6/g1 /g1 /g1 /g2/g31/g9/g3/g1
/g29/g30/g23/g27/g32/g2/g18/g15/g32/g15/g3/g11/g1 /g1 /g1 /g2/g32/g7/g3/g1/g2/g1/g2/g1/g2/g1
/g5/g3/g8/g3/g1/g7/g3/g4/g6/g1 /g14/g15/g36/g31/g1/g32/g28/g1/g29/g30/g19/g34/g19/g27/g32/g1/g18/g15/g32/g15/g1/g30/g15/g17/g19/g10/g1
/g7/g5/g1/g26/g15/g24/g19/g1/g18/g15/g32/g15/g1/g34/g28/g25/g15/g32/g23/g25/g19/g1
/g8/g5/g1/g31/g36/g27/g17/g22/g30/g28/g27/g23/g37/g19/g1/g28/g27/g1/g25/g28/g17/g24/g1/g16/g19/g20/g28/g30/g19/g1/g29/g30/g23/g27/g32/g2/g35/g3/g33/g27/g25/g28/g17/g24/g1/g28/g20/g1/g25/g28/g17/g24/g1
/g18/g15/g32/g15/g1/g30/g15/g17/g19/g1/g26/g15/g27/g23/g20/g19/g31/g32/g23/g27/g21/g1/g31/g32/g15/g32/g19/g26/g19/g27/g32/g1/g1/g18/g15/g32/g15/g1/g30/g15/g17/g19/g1/g31/g28/g33/g30/g17/g19/g1/g31/g32/g15/g32/g19/g26/g19/g27/g32/g1/g1
Figure 11: Part of the state space with the unlock in between source
and manifest statements
(source, ..., s 1,s2, ..., manifest ). For this to work we need
sourcehb→s1ands2hb→manifest . If our program modiﬁcations
establish s1hb→s2, then by the transitivity of the happens-before
relation, we will have sourcehb→manifest .
Algorithm isHappensBeforeOrdered (sourceIndex ,destIndex ,hbEdges ):boolean
integer sourceIndex ,destIndex
Set of integer pairs hbEdges
ifsourceIndex anddestIndex have same executing thread then
return true;
if(sourceIndex ,destIndex )∈hbEdges then
return true;
foreach (s1, s2) ∈hbEdges
ifisHappensBeforeOrdered (sourceIndex,s1,hbEdges)
and isHappensBeforeOrdered (s2, destIndex„hbEdges) then
return true;
return false;
Algorithm makeChangeOtherToVolatileSuggestions (manifestIndex ,sourceIndex ,hbEdges )
integer manifestIndex ,sourceIndex
Set of integer pairs hbEdges
for each write of vats1between sourceIndex andmanifestIndex do
ifthere exists a read of vats2between s1andmanifestIndex
and isHappensBeforeOrdered (sourceIndex, manifestIndex, hbEdges ∪(s1,s2) )then
ifvis an array element then
print "Use atomic array ..."
else
print "Make vvolatile"
Figure 12: Suggest changing a different memory locations to
volatile
Ifs1ands2are the write and read of a variable v, respec-
tively, then changing vto volatile creates a happens-before edge
between s1ands2. Figure 12 shows the algorithm for checking
the happens-before relation and the algorithm for this type of sug-
gestion using it.
Figure 2 shows another example with two threads sharing two
variables: done andx. If JRF-E is conﬁgured with threshold >
1, it is possible to ﬁnd a counterexample that shows a data race
manifested in statement t2as shown in Figure 13. It turns out
that between the source statement ( s1) and the manifest statement
(t2), there is a write of done followed by read of done .S i n c e s1
ands2are executed by Thread 1 and t1andt2are executed by
Thread 2, changing done to volatile creates a happens-before edge
between s1andt2and eliminates the data race.
In our experience, suggestions from this class are often the most/g2/g1/g2/g1/g2/g1/g13/g32/g15/g32/g19/g1/g31/g29/g15/g17/g19/g1
/g36/g12/g8/g11/g1/g1 /g1 /g3/g31/g8/g4/g1
/g18/g28/g27/g19/g12/g32/g30/g33/g19/g11/g1 /g3/g31/g9/g4/g1
/g35/g22/g23/g25/g19/g1 /g3/g2/g18/g28/g27/g19 /g4/g11/g1/g3/g32/g8/g4/g1
/g15/g31/g31/g19/g30/g32/g1 /g3/g36/g12/g12/g8/g4/g11/g1/g3/g32/g9/g4
/g5/g3/g8/g3/g1/g7/g3/g4/g6/g1
/g14/g15/g37/g31/g1/g32/g28/g1/g29/g30/g19/g34/g19/g27/g32/g1/g18/g15/g32/g15/g1/g30/g15/g17/g19/g10/g1
/g8/g7/g1/g26/g15/g24/g19/g1/g18/g28/g27/g19/g1/g34/g28/g25/g15/g32/g23/g25/g19/g1/g18/g15/g32/g15/g1/g30/g15/g17/g19/g1/g31/g28/g33/g30/g17/g19/g1/g31/g32/g15/g32/g19/g26/g19/g27/g32/g1/g1 /g36/g12/g8/g11/g1/g1 /g1 /g3/g31/g8/g4/g1
/g18/g28/g27/g19/g12/g32/g30/g33/g19/g11/g1 /g3/g31/g9/g4/g1
/g35/g22/g23/g25/g19/g1 /g3/g2/g18/g28/g27/g19 /g4/g11/g1/g3/g32/g8/g4
/g1/g1/g1/g18/g15/g32/g15/g1/g30/g15/g17/g19/g1/g31/g28/g33/g30/g17/g19/g1/g31/g32/g15/g32/g19/g26/g19/g27/g32/g1/g1
/g18/g15/g32/g15/g1/g30/g15/g17/g19/g1/g26/g15/g27/g23/g20/g19/g31/g32/g1/g31/g32/g15/g32/g19/g26/g19/g27/g32/g1
/g18/g15/g32/g15/g1/g30/g15/g17/g19/g1/g26/g15/g27/g23/g20/g19/g31/g32/g1/g31/g32/g15/g32/g19/g26/g19/g27/g32/g1/g1
/g5/g3/g8/g3/g1/g7/g3/g4/g6/g1
/g14/g15/g37/g31/g1/g32/g28/g1/g29/g30/g19/g34/g19/g27/g32/g1/g18/g15/g32/g15/g1/g30/g15/g17/g19/g10/g1
/g8/g7/g1/g26/g15/g24/g19/g1 /g36/g1/g34/g28/g25/g15/g32/g23/g25/g19/g1
/g9/g7/g1/g26/g15/g24/g19/g1/g18/g28/g27/g19/g1/g34/g28/g25/g15/g32/g23/g25/g19/g1/g35/g30/g23/g32/g19/g6/g30/g19/g15/g18/g1/g29/g15/g23/g30/g1/g1
/g17/g15/g29/g15/g16/g25/g19/g1/g28/g20/g1/g28/g30/g18/g19/g30/g23/g27/g21/g1/g31 /g8/g5/g1/g32/g9/g1/g1
Figure 13: Part of the state space that change done to volatile can
eliminate a race on x
appropriate solution in lock-free a lgorithms that e xhibit data races
on multiple variables.
Perform the same synchronization operation.
JRF-E keeps track of the acquiring history to allow determina-
tion of how happens-before edges were created for non-racy ac-
cesses to a memory location. Formally, we deﬁne the acquiring
history as a function:
AcquireHis :Addr ⇒ 2(SynchAddr ∪Threads )×Threads.F o r a
memory location m,(v,t )∈AcquireHis (m)means that at some
point in the computation so far, thread tperformed an operation on
vthat resulted in mbeing added to h(t). The actions by thread
tthat would result in (v,t )being added to AcquireHis (m),f o r
somemcould be reading v, locking v, or joining v,w h e r e vis
a volatile ﬁeld, lock, or thread, respectively. In contrast to the
summary function h, which only applies to a particular path, the
AcquireHis is cumulative and contains information from all the
explored paths.
Figure 14 ﬁnds out how previous accesses to the data race mem-
ory location ( m) have been ordered by the happens-before relation
and suggests performing the same acquire operation. Three possi-
ble acquire operation choices are read ,lock ,a n djoin accord-
ing to the type of memory location. If the memory location is a
ﬁeld, then it must be volatile an d the corresponding acquiring op-
eration is to read it. If the memory location is a lock, the acquireoperation is to lock it. When the memory location is a reference tothread, joining it serves as an acquire.
Algorithm makePerformSameAcquireSuggestions (AcquireHis ,m)
Mapping of memoryLocation to Set of (ThreadId,agentLoc)
AcquireHis
MemoryLocation m,loc
foreach (t,loc)∈acquireHistory[m] do
iflocis reference to thread andm∈h(loc) then
print "join thread locbefore manifest instruction"
else if locis a field then
print "read field locbefore manifest instruction "
else
print "lock the object locbefore manifest instruction"
Figure 14: Suggest performing an acquire operation that can add
the data race memory location to hof the manifesting thread.
The example in Figure 15 motivates the use of the acquiring
history. In execution sequence (r1, r2, s1, s2, t1) as
shown in Figure 16, there is a data race between r1,aw r i t eo f
xby Thread 1, and t1, the read of xby Thread 3. Thread 2 also
performs a read of xbut it does not result in a data race with Thread
2201 because Thread 2 reads volatile done before reading xand this
generates a happens-before edge between the write of xby Thread
1 and the read of xby Thread 2. The acquiring history stores this in-
formation and JRF-E uses it to suggest that Thread 3 reads volatile
done before reading x to eliminate the data race.
/g1/g17/g19/g24/g1/g27/g8
/g1/g26/g20/g18/g11/g24/g17/g18/g14/g1/g12/g20/g20/g18/g14/g11/g19/g1/g13/g20/g19/g14/g9/g15/g11/g18 /g23/g14/g8
/g1/g1/g1/g1/g1/g1/g1/g10/g16 /g22/g14/g11/g13/g1 /g4/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g10/g16 /g22/g14/g11/g13/g1 /g5/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g10/g16 /g22/g14/g11/g13/g1 /g6
/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g1/g1/g1/g1/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g9/g1/g1/g1/g1/g9/g9/g9/g9/g9/g9/g9/g9/g9/g1
/g1/g1/g22/g4/g7/g1/g27/g1/g9/g1/g4/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g23/g4/g7/g1/g17/g15/g1/g2/g1/g13/g20/g19/g14/g1 /g3/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g24/g4/g7/g1/g21/g22/g17/g19/g24/g2/g27/g3/g8
/g1/g1/g22/g5/g7/g1/g13/g20/g19/g14/g1/g9/g1 /g24/g22/g25/g14/g8/g1/g1/g1/g1/g1/g1/g1 /g23/g5/g7/g1/g1/g1/g1/g11 /g23/g23/g14/g22/g24/g1/g2/g27/g9/g9/g4/g3/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g1 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1
Figure 15: Acquiring history of Thread 2 shows Thread 3 can get
race free access on xby reading done .
/g11/g30/g13/g30/g17/g1/g29/g27/g13/g15/g17/g1
/g33/g1/g10/g1/g6/g9/g1/g1 /g2 /g28/g6/g3/g1
/g16/g26/g25/g17/g1/g10/g1/g30/g28/g31/g17/g9/g1/g2/g28/g7/g3/g1
/g21/g18/g2/g16/g26/g25/g17/g3/g1 /g2 /g29/g6/g3/g1
/g13/g29/g29/g17/g28/g30/g2/g33/g10/g10/g6/g3/g9/g1/g2/g29/g7/g3/g1
/g27/g28/g21/g25/g30/g2/g33/g3/g9/g1/g2 /g30/g6/g3
/g1/g1/g1/g2/g1/g2/g1/g2/g1
/g5/g3/g8/g3/g1/g7/g3/g4/g6/g1 /g12/g13/g34/g29/g1/g30/g26/g1/g27/g28/g17/g32/g17/g25/g30/g1/g16/g13/g30/g13/g1/g28/g13/g15/g17/g8/g1
/g6/g5/g1/g24/g13/g22/g17/g1/g33/g1/g32/g26/g23/g13/g30/g21/g23/g17/g1
/g7/g5/g1/g28/g17/g13/g16/g1/g16/g26/g25/g17/g1/g14/g17/g18/g26/g28/g17/g1/g27/g28/g21/g25/g30/g2/g33/g3/g1
/g1/g1/g20/g13/g27/g27/g17/g25/g29/g4/g14/g17/g18/g26/g28/g17/g1/g17/g16/g19/g17/g1
/g16/g13/g30/g13/g1/g28/g13/g15/g17/g1/g24/g13/g25/g21/g18/g17/g29/g30/g21/g25/g19/g1/g29/g30/g13/g30/g17/g24/g17/g25/g30/g1/g1/g16/g13/g30/g13/g1/g28/g13/g15/g17/g1/g29/g26/g31/g28/g15/g17/g1/g29/g30/g13/g30/g17/g24/g17/g25/g30/g1/g1/g3/g4/g12/g16/g9/g13/g9/g10/g7/g1/g8/g9/g14/g15/g11/g13/g18/g1/g20/g17/g21/g1
/g1
/g1/g22/g1/g23/g1
/g22/g1/g23/g1
/g22/g20/g5/g11/g10/g6/g19/g2/g8/g13/g6/g3/g5/g24/g21/g23/g1
/g22/g20/g5/g11/g10/g6/g19/g2/g8/g13/g6/g3/g5/g24/g21/g23/g1/g22/g20/g5/g11/g10/g6/g19/g2/g8/g13/g6/g3/g5/g24/g21/g23/g1
Figure 16: Part of the state space with the acquiring history that
guides how to eliminate the race
The suggestions generated by the above algorithms are guaran-
teed to eliminate the data race on the path where the race was dis-
covered. The "precision" of the suggestions are improved by ﬁlter-ing the set of suggestions to only include those that appear on all ofthe paths. Given the set of suggestions, the programmer determines
the best solution and implements it. JRF-E should then be rerun.
3.1 Theoretical Results
In this section, we prove that modifying the program accord-
ing to the suggestions generated by our tool does not remove any
happens-before edges that existed before the modiﬁcation. Specif-
ically, Theorem 1 and Theorem 2 show that this is the case for all
execution paths considering changing a non-volatile to volatile and
adding a new synchronization action via putting in a synchronized
block or following an acquiring history-based suggestion, respec-
tively. Theorem 5 shows a similar result for the move suggestiononly on the counter-example path under certain conditions.
T
HEOREM 1.Changing a non-volatile variable to a volatile
variable does not remove any of the existing happens-before edges
that result from synchronization actions on any of the execution
paths but it may introduce additional happens-before edges.
PROOF .Accessing non-volatile variables are not synchroniza-
tion actions so they cannot involve in the creation of happens-
before edges resulting from synchronization actions.
Once a non-volatile variable is changed to a volatile variable, the
write accesses will become release statements and the read ac-
cesses will become acquire statements and matching release and
acquire pairs, if any, will create happens-before edges.
/g31/g35/g41/g1/g45/g16
/g24/g36/g36/g34/g27/g23/g35 /g1/g29/g36/g19/g34/g23/g29/g16
/g43/g36/g34/g23/g41/g31/g34/g27/g1/g18/g23/g41/g23/g1/g37/g42/g24/g34/g31/g40/g30/g16
/g20/g24/g32/g27/g25 /g41/g1/g36/g16
/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g22/g30/g39/g27/g23/g26 /g1/g8/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g22/g30/g39/g27/g23/g26 /g1/g9/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1 /g22/g30/g39/g27/g23/g26 /g1/g10/g1/g1/g1/g1/g1/g1/g1
/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17 /g1/g1/g1/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17 /g1/g1/g1/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17/g17 /g1/g1/g1
/g1/g40/g8/g15/g1/g1/g39/g1/g17/g1/g35/g27/g44/g1/g18/g23/g41/g23/g4/g5/g16/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g41/g8/g15/g1/g31/g28/g1/g4/g37/g42/g24/g34/g31/g40/g30/g1/g2/g17/g1/g35/g42/g34/g34/g5/g1/g48/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g42 /g8/g15/g1/g40/g46/g35/g25/g30/g39/g36/g35/g31 /g47/g27/g26/g1/g4/g36/g5/g1/g48
/g1/g40/g9/g15/g1/g1/g37/g42/g24/g34/g31/g40/g30/g1/g17/g1/g39/g16/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g41 /g9/g15/g1/g1/g1/g1/g44/g30/g31/g34/g27/g1/g4/g2/g29/g36/g19/g34/g23/g29/g5/g16 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g42 /g9/g15/g1/g1/g1/g31/g28/g1/g4/g37/g42/g24/g34/g31/g40/g30/g6/g29/g27/g41/g18/g27/g40/g25/g4/g5/g1/g2/g17/g1/g35/g42/g34/g34/g5
/g1/g40/g10/g15/g1/g1/g39/g6/g40/g27/g41/g18/g27/g40/g25/g4/g3/g27/g3/g5/g16 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g41/g10/g15/g1/g1/g1/g1/g21/g41/g39/g31/g35/g29/g1/g40/g1/g17/g1/g1/g37/g42/g24/g34/g31/g40/g30/g6/g29/g27/g41/g18/g27/g40/g25/g4/g5/g16/g1/g1/g1/g42/g10/g15/g1/g1/g1/g1/g1/g1/g29/g36/g19/g34/g23/g29 /g1/g17/g1/g41/g39/g42/g27/g16/g1/g1/g1/g1/g1/g1/g1/g1
/g1/g40/g11/g15/g1/g1/g40/g46/g35/g25/g30/g39/g36/g35/g31 /g47/g27/g26/g1/g4/g36/g5/g1/g48/g1/g1/g1/g1/g1/g1/g41/g11/g15/g1/g1/g1/g1/g23/g40/g40/g27/g39/g41/g4/g40/g6/g27/g38/g42/g23/g34/g40/g4/g3/g27/g3/g5/g16 /g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g42 /g11/g15/g1/g1/g1/g27/g34/g40/g27/g1
/g1/g40/g12/g15/g1/g1/g1/g1/g1/g45/g17/g12/g16/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g49/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g42 /g12/g15/g1/g1/g1/g1/g1/g1/g29/g36/g19/g34/g23/g29 /g1/g17/g1/g28/g23/g34/g40/g27/g16
/g1/g40/g13/g15/g1/g1/g49/g1/g7/g7/g1/g42/g35/g34/g36/g25/g33 /g1/g36/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g1/g42 /g13/g15/g1/g49/g1/g7/g7/g1/g42/g35/g34/g36/g25/g33 /g1/g36
/g1/g40/g14/g15/g1/g1/g29/g36/g19/g34/g23/g29 /g1/g17/g1/g41/g39/g42/g27/g16/g1
Figure 17: ViagoFlag Thread 1 notiﬁes Thread 2 when object
publish is ready to be used. Thread 3 can also notify Thread 2
by checking a ﬁeld of the object pointed by publish .
THEOREM 2.Changing a program by adding a synchroniza-
tion action (joining a thread, acquiring a lock, and reading a
volatile variable) that involves an existing memory location, does
not remove any of the existing happens-before edges that result
from synchronization actions or the program order on any of theexecution paths.
P
ROOF .An existing happens-before edge that result from syn-
chronization actions can be removed only by changing the source
or the destination statement of the happens-before edge. Adding asynchronization action does not change such a statement. Also,an existing happens-before edge that result from program order
does not change as a result of adding a synchronization action
as happens-before is a transitive relation and all such existing
happens-before edges would be preserved due to transitivity.
LEMMA 3.Moving an instruction that accesses a non-volatile
variable does not remove any of the existing happens-before edges
that result from synchronization actions on any of the execution
paths.
PROOF .Same reasoning as in proof of Theorem 1.
Lettid(i)denote the id of the thread that executed instruction i
on a given path.
LEMMA 4.Moving a data race source instruction, write x
at step h, before an instruction that is the source of a happens-
before edge, represented by [d,i ]where d<h<i , does not in-
troduce a new data race that involves the moved statement on the
same counter-example path if and only if the following conditions
hold:
1. Condition 1: The moved source instruction does not become
a new data race source instruction. For any read/write
xat step gs.t.d<g<h , there exists a happens-before
edge represented by range [e,f ]s.t.d<e<f<g and
tid(h)=tid(e)andtid(f)=tid(g).
PROOF .After the move, the old data source instruction
(at step h) would be at step d−1and would be ordered with
the instruction at step gby happens-before. As a concrete
example consider the sample program in Figure 17 and the
corresponding counter-example path in Figure 18.a.
2. Condition 2: The moved source instruction does not become
a new data race manifesting instruction. For the ﬁrst
read/write x at step athat precedes the instruction at d,
there exists a happens-before edge [b, c ]s.t.a<b<c<d
andtid(a)=tid(b)andtid(c)=tid(h).
221b)...publish = r (s2)  // step d...synchronized (o) { (s4) // step c...} //unlock o (u6) // step b...goFlag = false (u5) // step a...
...if (publish != null) (t1) // step i...
while (!goFlag) (t2) // step jpublish = r (s2)  // step d
} //unlock o (s6) // step esynchronized (o) { (u1) // step fgoFlag = true (u3) // step ggoFlag = true (s7) // step hif (publish != null) (t1) // step iwhile (!goFlag) (t2) // step j...
............
......
move suggestion
data race
source statement
manifest statementdata racesource statementdata race
manifest statementdata race
a)goFlag = true (s7) // step h
Figure 18: a) Instantiation of Condition 1 in Lemma 4 b) instanti-
ation of Condition 2 in Lemma 4 based on sample program in Fig-
ure 17. Happens-before edges formed by synchronization actions
are shown by lines connecting the matching release and acquireinstructions.
P
ROOF .After the move, the old data source instruction
(at step h) would be at step d−1. The instruction at step
aand the instruction at step d−1would be ordered by
happens-before. As a concrete example consider the sam-
ple program in Figure 17 and the corresponding counter-example path in Figure 18.b.
THEOREM 5.Moving a data race source instruction, write
xat step h, before an instruction that is the source of a happens-
before edge, represented by [d, i ]where d<h<i , does not
involve any new data races if and only if conditions71a n d2i n
Lemma 4 hold.
PROOF .Follows from Lemma 3 and Lemma 4.
4. EXPERIMENTAL RESULTS
In order to evaluate the usefulness and determine good threshold
values for number of data races to detect before stopping, JRF-
E was used to analyze programs taken from a variety of sources
including a textbook8on multiprocessor programming [15], the
Amino Concurrent Building Blocks library [1], barrier implemen-
tations from a Google concurrent data structures workshop [11],
the Java Grande Forum Benchmark Suite [17], and undergradu-
ate students assignments implementing a multithreaded web server
simulator. JRF discovered a data race in 19 out of 65 examplesfrom [15], 9 races in 20 Junit tests
9a n d1 0e x a m p l e si n[ 1 ]10,a n d
10 of 12 barrier implementations in [11]. We also found data races
in 6 out of 10 examples from [17] and 7 out of 28 students projects.These results show that data races are a common error in Java pro-
grams, whether written by students or experts.
Representative results are shown in Table 1. These were per-
formed on an i386/8 processor with 32GB ram using Linux/2.6.24-
16-generic OS, JPF version 5, and Java 1.6 with 1GB JVM heap
memory. The "max length" column contains the number of tran-sitions in the longest counterexample path. The memory require-
ment and elapsed time for JRF and JRF-E are given in the next four
7Checking of the two conditions in Lemma 4 has been imple-
mented in JRF and the suggestion is made only if the conditions
hold. For brevity, the algorithm in Figure 6 does not include check-
ing these conditions.
8Java implementations were obtained from the book’s companion
web site.
9183 different functions are tested in 20 Amino Junit tests
10These races involve features documented as not thread safe, thus
indicate bugs in client code, not the Amino library.columns. The overhead of counterexample analysis is the time and
memory spent in managing additional data such as the acquiring
history and path elements and applying the algorithm to generatesuggestions. The ﬁnal two columns show the ﬁeld involved in a de-tected data race and the suggestions generated by JRF-E. Each rowgives results generated using three different values for the numberof races threshold. The ﬁrst items, given in a normal font, pertain to
the single race found when the threshold is one. Entries pertaining
to results with a threshold of ten are given in italic , while entries
from runs with a threshold of 100 are given in this shape .I nt h e
suggestion column, the set of suggestions for each threshold value
also includes those from smaller thresholds. The suggestion in bold
corresponds to a solution chosen by a knowledgeable programmer
as the most appropriate way to eliminate that data race.
In the DisBarrier test, the log[] i n t e g e ra r r a yi sp a r to ft h e
test driver, not the barrier. The race on its elements could be elim-
inated trivially by changing the array to an atomic array. However,the suggestions show that changing the flag[] to an atomic array
will also correct the races on log[] , and this is the best solution.
LockFreeHashSet is implemented using AtomicIntegers and
aBucketList which is a list of Node . The bucket list
should be changed to atomic array to guarantee the volatile se-
mantics for each element access. Even though the elements
of a bucket list are not protected at all, the thread-safe access
of the BucketList provides the required ordering of accesses to
the internal list elements. JRF-E veriﬁes that using an atomic
array for bucket[] will also eliminate the races on Node ,
next ofNode ,a n d head ofBucketList . The race involv-
ingnext is quite subtle. The next ﬁeld is declared to be an
AtomicMarkableReference<Node> . This means that the
accesses of the objects referenced by the ﬁeld can be safely ac-
cessed with volatile semantics. Since the data structure is a linkedlist, accesses to Nodes other than the ﬁrst are safe. The next nodeof the head of the list however, exhibits data races.
InOptimisticList , each list element is represented by an
Entry object. Races on next andkey ﬁelds are both removable
by marking next as volatile. In MCSLock three ﬁelds of QNode
are involved in races but one change, changing next to volatile,
does not resolve the other two. From the suggestions, we can easily
deduce that one more ﬁx is needed, changing locked to volatile,
which will also correct the data race involving counter .
Thegoogle.linearSenseBarrierVolatile test illus-
trates the limitations of JRF-E’s approach. The race on _value
ofCounterWithBarrier , which is part of the test driver, not
the barrier, can be eliminated by marking it volatile. However, the
problem is that the implementation has multiple threads set the vari-able to the same value, with each update after the ﬁrst manifesting
a data race. A better solution is to avoid the multiple updates. This
sort of semantic reasoning cannot be done by JRF-E. However, the
suggestion given would eliminate the data race.
Twojgf examples have races on volatile arrays without volatile
element access IsDone[] and
sync[] and nonvolatile array
A[][] . These widely available benchmarks were implemented
before the current JMM, and before the issues relevant to the mem-
ory model were well known, and illustrate the usefulness of a tool
that can check for data races even in apparently correct code.
One test case using student code is shown. Several of the student
projects showed signiﬁcant problems related to concurrency which
need to be corrected before one could expect the results of JRF-E
to be useful.
The tests showed that in most cases, the tool gave the most ap-
propriate suggestion. This is especially true for programs where
the problem is lack of attention (or misunderstanding) of memory
222test case
 max
 memory (MB)
 time (sec)
 race ﬁeld
 suggestion
(threads, iterations)
 length
 JRF
 JRF-E
 JRF
 JRF-E
 ofclass
ﬂag[]
 use atomic array for ﬂag[]
herlihy_shavit.
 of Node
 join the updater
barrier.
 40
 35
 0
 2
 0
 use atomic array for log[]
DisBarrier
 202
 63
 34
 5
 6
 log[]
 use atomic array for ﬂag[]
(2,2)
 210
 114
 21
 20
 1:09
 ofDisBarrier
 join the updater
bucket[]
 use atomic array for bucket[]
of LockFreeHashSet
Node
 u s ea t o m i ca r r a yf o rb u c k e t [ ]
change head of BucketList to volatile
herlihy_shavit.
 50
 60
 6
 3
 0
 read volatile ﬁeld value of AtomicReference before
hash.
 53
 61
 8
 3
 6
 next
 Unsafe publication of Node
LockFreeHashSet
 55
 61
 7
 3
 6
 ofNode
 change next of Node to volatile
(2,2)
 u s ea t o m i ca r r a yf o rb u c k e t [ ]
change head of BucketList to volatile
read volatile ﬁeld value of AtomicReference before
head
 Unsafe publication of Node
ofBucketList
 change head of BucketList to volatile
u s ea t o m i ca r r a yf o rb u c k e t [ ] *
next
 change next of Entry to volatile
of Entry
herlihy_shavit.
 42
 59
 14
 2
 0
 Entry
 change next of Entry to volatile
lists.
 69
 70
 33
 4
 2
 lock the lock
OptimisticList
 221
 176
 60
 17
 2:31
 key
 Unsafe publication of Node
(3,6)
 ofEntry
 change key of Entry to volatile
change next of Entry to volatile
lock the lock
next
 change next of QNode to volatile
of QNode
 join the updater
herlihy_shavit.
 15
 29
 0
 1
 0
 counter
 change counter of QNode to volatile
spin.
 21
 29
 0
 1
 0
 ofQNode
 join the updater
MCSLock
 65
 41
 2
 2
 5
 change locked of QNode to volatile
(4,16)
 locked
 change locked of QNode to volatile
ofQNode
 join the updater
_threadDoneArray[]
 use atomic array for _threadDoneArray[]
google.
 33
 59
 0
 2
 0
 of BaseLinearSenseBarrierVolatile
 join the updater
linearSenseBarrierVolatile
 61
 59
 0
 3
 7
 _value
 change _value of CounterWithBarrier to volatile
(2,1)
 70
 90
 13
 7
 1:11
 ofCounterWithBarrier
 join the updater
amino.
 11
 47
 0
 3
 0
 cursor
 change cursor of DeqIterator to volatile
Iterator_EBDeque
 17
 41
 7
 3
 4
 of DeqIterator
 join the updater
(2,2)
 30
 66
 9
 8
 36
jgf.
 19
 29
 0
 1
 0
 IsDone[]
 use atomic array for IsDone[]
lufact
 74
 35
 0
 2
 4
 of TournamentBarrier
 move the source
(2,5)
 393
 72
 13
 5
 4:28
sync[]
 use atomic array for sync[]
jgf.
 44
 35
 2
 2
 2
 of SOR
sor
 45
 45
 3
 2
 1:40
 A[][]
 use atomic array for A[][]
(2,15)
 95
 46
 18
 3
 7:40
 ofRandomMatrix
 use atomic array for sync[]
ﬁnishedTakingRequests
 change ﬁnishedTakingRequest of WorkerThread to volatile
webserver.
 68
 90
 35
 16
 1
 of WorkerThread
 synchronized block using requestBuffer
studentA
 92
 102
 32
 15
 24
 empty
 change empty of RequestBuffer to volatile
(2,2)
 101
 126
 8
 26
 2:57
 ofRequestBuffer
 synchronized block using requestBuffer
Table 1: Selected results from JRFand JRF-E. See Section 4 for an explanation.
model issues, but the programs are basically correct. JRF-E allows
programmers to conﬁdently choose a solution where the volatility
of one variable also guards other variables from data races. In ad-
dition, the results show that when a program has only one memorylocation involved in a race, the threshold doesn’t matter. However,if the program contains races involving more than one memory lo-
cation, then considering them together helps to ﬁnd the most ap-
propriate suggestions.
5. RELATED WORK
Many tools have been developed to detect data races, statically
or dynamically, using a variety of deﬁnitions of a data race. Most of
these tools use a slightly different notion of a data race that is use-ful for ﬁnding certain types of concurrency errors in SC environ-ments rather than ﬁnding data races that indicate violation of SC.
For brevity, we limit our discussion here to more recent, memory
model aware tools, and tools that attempt to analyze counterexam-ples. A more complete discussion of related work can be found in
[19, 20].
Recently, several studies [6, 8, 16, 22] have incorporated mem-
ory model awareness into model checking. [22] uses model check-
ing to compare two hardware level memory models. The ap-
proaches presented in [6, 16] can verify sequential consistency.
[6] considers a hardware-level memory model and uses bounded
model checking and a stateless model checker. They use vector-
clocks to capture the happen-before relation. Since JPF is a state-
based model checker, we can store the happen-before informationfor each state. [16] considers C#’s memory model and a bytecode-level state-based model checker tailored for C#. Also, [16] pro-
vides simple program modiﬁcations in the form of inserting mem-
ory/barrier fences to eliminate data races. This type of suggestion
is similar to our changing a non-vo latile to a volatile. However, our
tool provides a richer set of suggestions. The technique presentedin [8] guides the model checker in generating a subset (i.e., underapproximates the JMM) of program executions which vary due to
223instruction reordering allowed in the JMM and thus generate the
legal sequentially inconsistent behaviors. Since it is an underap-
proximation, it can only be used for bug-ﬁnding not veriﬁcation.
Our tool can verify sequential consistency of a Java program with-out generating all such subsets but does not deal with sequentiallyinconsistent programs (except in the limited sense of allowing theuser to specify that certain races that the use considers to be benign
are ignored.)
[14, 3, 24, 5, 7, 13] compare a set of successful traces with a set
of erroneous ones to localize the errors or to focus the debugging
process on a relatively small part of the program. [14] considersboth transition and invariant differences on successful traces andthe counterexample paths. It provides feedback on how success-
ful traces can be transformed into counterexample paths. However,
our analysis provides feedback on how to transform a counterex-
ample path to a possibly successful trace. [3] generates multipleerror traces having independent causes and for each error cause re-ports a single error trace. [5] uses dynamic analysis and machinelearning to classify program properties as fault-revealing and non
fault-revealing and reports program invariants that are in the fault-
revealing set.
[4, 9] focus on error traces only. [4] slices a counterexample
path to ﬁnd the statements that directly or indirectly affect the fail-
ure. [9] computes the transactional happens-before edges on the
dynamically generated execution traces to detect blocks that can-
not preserve their atomicity and hence cannot be serialized.
6. CONCLUSION
Our data race detection tool, JRF is an extension of JPF that pre-
cisely detects data races, as deﬁned by the Java Memory Model, in
Java bytecode. This is important since standard JPF is unsound forprograms that contain data races. Because it is based directly on theJava memory model, JRF can handle all concurrent programming
idioms supported by Java, includi ng lock-free algorithms. In this
paper, we described JRF-E, an extension of JRF that analyses the
counterexample path and acquiring history and provides sugges-
tions for eliminating data races. The usefulness of the suggestionfacility was evaluated by applying to a number of examples. Ap-propriate suggestions were provided in each case, indicating that
JRF-E can be a practical tool.
7. REFERENCES
[1] Amino concurrent building blocks.
http://amino-cbbs.sourceforge.net/.
[2] D. Aspinall and J. Sevcik. Formalising Java’s data-race-free
guarantee. In TPHOLs 2007 (LNCS) , volume 4732, pages
22–37. Springer, 2007.
[3] T. Ball, M. Naik, and S. K. Rajamani. From symptom to
cause: localizing errors in counterexample traces. In
Principles of Programming Languages , pages 97–105, 2003.
[4] S. Basu, D. Saha, and S. A. Smolka. Localizing program
errors for cimple debugging. In FORTE , pages 79–96, 2004.
[5] Y . Brun and M. D. Ernst. Finding latent code errors via
machine learning over program executions. In ICSE , pages
480–490, 2004.
[6] S. Burckhardt and M. Musuvathi. Effective program
veriﬁcation for relaxed memory models. In CAV ’08:
Proceedings of the 20th international conference on
Computer Aided Veriﬁcation , pages 107–120, Berlin,
Heidelberg, 2008. Springer-Verlag.
[7] H. Cleve and A. Zeller. Locating causes of program failures.
InICSE , pages 342–351, 2005.[8] A. De, A. Roychoudhury, and D. D’Souza. Java memory
model aware software validation. In PASTE ’08:
Proceedings of the 8th ACM SIGPLAN-SIGSOFT workshop
on Program analysis for software tools and engineering ,
pages 8–14, New York, NY , USA, 2008. ACM.
[9] C. Flanagan, S. N. Freund, and J. Yi. Velodrome: a sound
and complete dynamic atomicity checker for multithreadedprograms. In PLDI , pages 293–303, 2008.
[10] B. Goetz, T. Peierls, J. Bloch, J. Bowbeer, D. Holmes, and
D. Lea. Java Concurrency in Practice . Addison Wesley
Professional, 2006.
[11] Google concurrent data structures workshop barriers.
http://code.google.com/p/concurrent-data-structures-workshop-barriers/.
[12] J. Gosling, B. Joy, G. Steele, and G. Bracha. Java Language
Speciﬁcation . Addison Wesley, 3rd edition, 2005.
[13] A. Groce. Error explanation with distance metrics. In Tools
and Algorithms for the Construction and Analysis of
Systems , pages 108–122, 2004.
[14] A. Groce and W. Visser. What went wrong: Explaining
counterexamples. In SPIN Workshop on Model Checking of
Software , pages 121–135. Springer, 2003.
[15] M. Herlihy and N. Shavit. The Art of Multiprocessor
Programming . Morgan Kaufmann, 2008.
[16] T. Q. Huynh and A. Roychoudhury. Memory model sensitive
bytecode veriﬁcation. Form. Methods Syst. Des. ,
31(3):281–305, 2007.
[17] The Java Grande Forum benchmark suite.
http://www2.epcc.ed.ac. uk/computing/research_
activities/java_gra nde/index_1.html.
[18] Java Pathﬁnder. http://babelﬁsh.arc.nasa.gov/trac/jpf.
[19] K. Kim, T. Yavuz-Kahveci, and B. A. Sanders. Precise data
race detection in a relaxed memory model using
heuristic-based model checking. In Proceedings of the 24th
ACM/IEEE Conference on Automated Software Engineering ,
2009.
[20] K. Kim, T. Yavuz-Kahveci, and B. A. Sanders. Precise data
race detection in a relaxed memory model using model
checking. Technical Report REP-2009-480, University of
Florida, 2009.
[21] L. Lamport. How to make a multiprocessor computer that
correctly executes multiprocess programs. IEEE
Transactions on Computers , C-28(9):690–691, September
1979.
[22] S. Mador-Haim, R. Alur, and M. M. K. Martin. Generating
litmus tests for contrasting memory consistency models. In
CAV, 2010.
[23] J. Manson, W. Pugh, and S. V . Adve. The Java memory
model. In POPL ’05: Proceedings of the 32nd ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , pages 378–391, New York, NY ,
USA, 2005. ACM Press.
[24] T. Wang and A. Roychoudhury. Automated path generation
for software fault localization. In ASE, pages 347–351, 2005.
224