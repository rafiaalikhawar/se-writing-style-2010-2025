Live API Documentation
Siddharth Subramanian, Laura Inozemtseva, and Reid Holmes
School of Computer Science
University of Waterloo
Waterloo, ON, Canada
s23subra,lminozem,rtholmes@uwaterloo.ca
ABSTRACT
Application Programming Interfaces (APIs) provide power-
ful abstraction mechanisms that enable complex functional-
ity to be used by client programs. However, this abstraction
does not come for free: understanding how to use an API can
be dicult. While API documentation can help, it is often
insucient on its own. Online sites like Stack Overow and
Github Gists have grown to ll the gap between traditional
API documentation and more example-based resources. Un-
fortunately, these two important classes of documentation
are independent.
In this paper we describe an iterative, deductive method
of linking source code examples to API documentation. We
also present an implementation of this method, called Baker,
that is highly precise (0.97) and supports both Java and
JavaScript. Baker can be used to enhance traditional API
documentation with up-to-date source code examples; it can
also be used to incorporate links to the API documentation
into the code snippets that use the API.
Categories and Subject Descriptors
D.2.6 [ Software Engineering ]: Programming Environments
General Terms
Languages, Experimentation
Keywords
Source code examples, source code search, documentation
1. INTRODUCTION
Using third-party libraries can greatly reduce the eort
required to develop a new system. Unfortunately, under-
standing how to use these libraries correctly can be di-
cult. While the application programming interface (API)
documentation can be a valuable means of understanding
the library, it can be insucient on its own. One of the
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
ICSE â€™14, May 31â€“June 7, 2014, Hyderabad, India
Copyright 14 ACM 978-1-4503-2756-5/14/05 ...$15.00.main issues is that the documentation is often out of date.
Recent work has conrmed the popular belief that writing
documentation and keeping it up to date is very dicult [8,
9]; consequently, developers ignore the documentation that
does exist and declare that \code is king" [17].
As a result of this situation, developers often turn to online
resources such as Stack Overow. Parnin et al. have previ-
ously studied online resources and have found that they do
a good job of covering APIs [15]. In fact, they found that
87% of Android classes were referenced in Stack Overow an-
swers. Unfortunately, there are rarely links between online
resources and ocial API documentation: the ocial doc-
umentation does not link to the examples that could help
developers, and the examples rarely link to the documenta-
tion.
Previous work has tried to identify source code references
within non-code resources (e.g., [2, 14, 9, 16]). Detect-
ing these references is a rst step toward linking them to
the relevant API documentation. Unfortunately, these ap-
proaches have several limitations. Some systems explicitly
ignored external references, meaning that the target sys-
tem for an analyzed document must be specied [9]. Others
only returned partially qualied names, which are insu-
cient for documentation linking [16]. Our initial investiga-
tion found that this approach could work for a subset of Java
programs [18]. However, none of the previous approaches
worked for dynamically-typed languages.
Our paper extends previous work in this area by using a
constraint-based technique to uniquely identify ne-grained
type references, method calls, and eld references in source
code snippets with high precision. We demonstrate the gen-
erality of the approach by providing implementations for
both typed (Java) and dynamic (JavaScript) languages. We
also evaluate the ability of the approach to correctly link
code to documentation.
More specically, the contributions of this paper are as
follows:
A constraint-based, iterative approach for determining
the fully qualied names of code elements in source
code snippets. This approach works with both stati-
cally and dynamically typed languages.
A prototype tool that implements this approach and
uses the results to automatically create bidirectional
links between documentation and source code exam-
ples by marking up HTML using a web browser exten-
sion.Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full citation
on the ï¬rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSEâ€™14 , May 31 â€“ June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568313
643
Section 2 presents a scenario that motivates our approach
and demonstrates the kinds of links it can identify. The ap-
proach and our implementation of it are explained in detail
in Sections 3 and 4. Section 5 then presents our evaluation of
Baker. The documentation linking prototype is described in
Section 6, followed by discussion in Section 7. Related work
is described in Section 8; Section 9 concludes the paper.
2. SCENARIO
Consider the Java code snippet shown in Figure 1. This
snippet (pertaining to a library called GWT) was posted to
Stack Overow to assist a developer who did not understand
how to manipulate the state of History objects. The gure
contains a number of bolded elements. These are the types
and methods that our tool, Baker, can uniquely link to the
API; i.e., the elements for which it can determine a fully-
qualied name. With this information we can automatically
augment the HTML version of the ocial API documenta-
tion for History by dynamically injecting the code example
into the web page. We can also inject the links to the ocial
API into the Stack Overow post; these two additions to the
documentation would make it easier for developers to learn
how to use this class.
1public FirstPanel() {
2 History .addHistoryListener (this);
3 String token = History .getToken ();
4 if (token. length () == 0) {
5 History .newItem (INIT_STATE);
6 } else {
7 History .fireCurrentHistoryState ();
8 }
9 .. rest of code
10 }
Figure 1: A Java code snippet representing a Java
API usage. Baker can associate each of the bolded
terms with a fully qualied name; this information
can be used to include the code example in the API
documentation.
Next, consider the JavaScript snippet in Figure 2, where
a developer is trying to make a web app that can take a
photo and inject it into an element in an HTML docu-
ment. This example interacts with the JavaScript DOM
(getElementById ), takes a photo using the Cordova pro-
ject ( getPicture ), and uses JQuery to detect when the
the photo should be taken ( $andon). For each of these
method references Baker can can identify the API that it is
from.
The code snippets in Figures 1 and 2 were both submit-
ted as the correct solution to problems developers posted
on Stack Overow. Since Stack Overow posts are ranked,
and accepted answers are known to have solved a real prob-
lem, Stack Overow is a good source of high quality code
snippets that demonstrate the correct usage of many APIs.
Increasing the integration between these examples and the
ocial API documentation will make documentation main-
tenance easier and increase the visibility and accessibility of
the ocial API documentation within source code examples.1$("#addphoto"). on(â€™clickâ€™,
2 function() { useGetPicture ();}
3);
4function useGetPicture () {
5 var cameraOptions = { ... };
6 navigator .camera .getPicture (onCameraSuccess ,
7 onCameraError , cameraOptions);
8}
9function onCameraSuccess (imageData) {
10 var image = document .getElementById ("..");
11 image.src = "data:image/jpeg" + imageData;
12 }
13 function onCameraError (message) {
14 alert ("Failed: " + message);
15 }
Figure 2: A JavaScript code snippet containing Cor-
dova, JQuery and JavaScript DOM API usage. Each
of the bolded elements can be linked back to the rel-
evant API documentation.
3. APPROACH
Identifying API elements in code snippets requires the
ability to parse these snippets. This is more dicult than
parsing full les because code snippets can be ambiguous.
Dagenais and Robillard highlighted four kinds of ambiguity
that can hamper the identication of elements [9]; two of
these were specic to the plain-text analysis they were per-
forming, while the other two were more generally relevant.
These two were declaration ambiguity andexternal reference
ambiguity .
Declaration Ambiguity. Snippets are, by denition, in-
complete fragments of code. That is, snippets might not be
embedded in methods or classes, they may reference elds
whose declaration is not included, and their identiers are
largely unqualied. In source code examples this is often
exacerbated by authors ending lines with `. . . ' or using
code comments to describe parts of the functionality that
are elided.
External Reference Ambiguity. Source code examples
frequently refer to external identiers; for example, Java
snippets frequently reference types from the JDK. While
a previous study [9] dealt with external references by elid-
ing everything that was not from a pre-specied library, we
designed Baker to handle these kinds of ambiguities. We ac-
complished this by using an oracle: a large database contain-
ing information about the code elements in popular APIs.
When Baker encounters an ambiguous code element, such as
theHistory class in Figure 1, it uses the oracle to identify
the possible types of the code element. In this case, there
are 58 History classes in the oracle, but by using informa-
tion from other parts of the code snippet, we can identify
which of the 58 is the correct one. Section 4 will present
more information about how the oracle is constructed, what
it contains, and how much of a problem ambiguity really is.
3.1 Deductive Linking
Baker handles declaration ambiguity and external refer-
ence ambiguity through a process we call deductive linking.
At a high level, it generates an incomplete abstract syntax
tree (AST) for the code snippet being analyzed, then uses
information from the oracle to deduce facts about the AST.
We perform this deduction step iteratively since each phase
can reveal new facts that can be used in subsequent phases.644More specically, in each phase, Baker performs a depth-
rst traversal of the AST and examines all nodes involved in
declarations, invocations, and assignments. When an AST
node of interest is encountered, Baker builds a list that rep-
resents the potential matches for that element from the or-
acle. As the traversal takes place, we track the scope of all
data being used to ensure that nodes are only combined if
allowed by the scoping rules of the language.
Once the entire AST has been traversed, the process starts
again; information uncovered in the previous iteration can
now be used to further restrict the lists of candidate ele-
ments. In theory, this iteration continues until either all
elements are associated with a single fully qualied name
(FQN), or an iteration fails to improve the results for any
element. In practice we nd that very few iterations are
typically needed.
While the goal of the approach is to identify the sole fully-
qualied element that a given identier can represent, some-
times there is not enough information to choose from a set of
candidates. In this case, Baker returns a match with cardi-
nality (c) greater than 1. When this happens, we can either
return all candidate elements or simply report that a unique
match cannot be found. Sometimes a specic FQN cannot
be identied for an element, but examining the set of candi-
dates reveals that they are all related { for example, if one
of the elements is a supertype for all other elements in the
set. In this case, we report the supertype as the match and
elide the concrete subtypes from the results.
While the core functionality of Baker is the same for both
Java and JavaScript, some language-specic functionality is
needed. Baker is thus implemented as two dierent link-
ing engines. One engine computes links between Java snip-
pets and API documentation while the other computes links
between JavaScript snippets and API documentation. Jav-
aBaker leverages the static structural relationships present
in Java code to deduce the correct links for code elements.
Though JavaScript code lacks static type information, JS-
Baker takes advantage of the fact that JavaScript library
developers are wary of naming conicts; they therefore usu-
ally use an object literal as an implied namespace and make
functions and variables properties of the object literal. This
allows us to link JavaScript objects and functions back to
the specic API they reference.
3.1.1 JavaBaker Example
To create ASTs from Java snippets we built a parser on a
headless version of Eclipse. Since the Eclipse parser is robust
to badly formed input, it was able to manage many of the
problems associated with source code snippets. However,
before any snippet could be parsed, we had to determine if
the snippet was surrounded by valid class and method dec-
larations. If it was not, we added dummy class and method
wrappers to allow parsing. We also built a web service for
the parser that enables us to use HTTP POST to send snip-
pets of code to JavaBaker and get a JSON response with
the results.
To describe the JavaBaker engine more concretely, we will
revisit the Java code fragment from Figure 1 and describe
how it would be analyzed. Since the fragment in this case
does not contain a class declaration, it is wrapped in a syn-
thetic class before the parsing process begins.1a.History.addHistoryListener(this) on line 2 is
the rst expression we encounter that requires anal-
ysis. From the oracle we retrieve all elements called
History , corresponding to the left-hand side of this
expression. These 58 candidate types are recorded for
History , along with the scope of the method call.
1b.Next, Baker considers addHistoryListener(this). Since
this method is being invoked on History , we exam-
ine its 58 candidate types to see which ones contain
a method called addHistoryListener(...) that
take a single object parameter. This results in 4 can-
didate methods. Since Baker is still evaluating the
expression, the left-hand side ( History ) is updated
to reect the number of candidates (reduced from 58
to 4).
1c.For the assignment on line 3, Baker considers the right-
hand side rst. Here, Baker assumes that the name
History refers to the same History class as the ref-
erence on line 2 and subsequently starts using its 4
candidates; this is because in Java conicting names
in the same class must be fully qualied. Evaluating
thegetToken() method, History is further reduced
to 2 candidates; getToken() also has cardinality 2.
Since we have not uniquely identied getToken() we
cannot yet use its return type to determine the type
oftoken .
1d.The same procedure continues for lines 4 through 10.
On lines 5 and 7 the scope being assigned to the His-
tory nodes is updated to reect the inner block being
analyzed. After the whole snippet has been analyzed,
Baker iterates again.
2a.Once Baker returns to line 2 History can be iden-
tied as com.google.gwt.user.client.History
because the method call constraints from lines 3, 5,
and 7 leave only one possible candidate. All other
History references are updated to the same FQN, as
are the method calls being made on it.
2b.The return type of the now-resolved getToken() can
be used to conrm that token is of type java.lang.-
String .
2c.Since all elements have been fully qualied, Baker does
not need to do another pass.
Baker uses a number of relationships to help identify ele-
ments when those relationships are available. They include
import statements (rarely present in example code), cast ex-
pressions, eld declarations, return statements, super invo-
cations, extends /implements relationships, and parame-
ter types.
3.1.2 JSBaker Example
JavaScript snippets are parsed by the ESPRIMA1parser.
ESPRIMA is very tolerant of malformed input because it
is frequently found in JavaScript code. Before the analysis
takes place, the code snippet is wrapped in a function dec-
laration if one is not already present. As with JavaBaker,
we implemented JSBaker as a web service so code snippets
could easily be parsed from a variety of applications.
1http://esprima.org/645We revisit the code snippet in Figure 2 to describe the
deductive linking process in detail.
1a.Line 1 contains two function expressions, $andon.
Checking the oracle, we nd only one instance of $
from jQuery. Because we can uniquely identify $, we
use this fact while examining any other methods in
the call chain. In this case, there is only one jQuery
method called onso it matches correctly on the rst
try (even though there are three onmethods in the or-
acle). This library preference is only used for chained
calls.
1b.The next function expression encountered is a call to
useGetPicture() . The oracle does not contain a
result for this identier.
1c.When it encounters the local function denition for use-
GetPicture() , Baker records that this function is lo-
cally dened, rather than being an external function.
1d.On line 5, the scope of cameraOptions is recorded to
ensure that any constraints applied to it do not `leak'
outside its scope. When Baker reaches the function ex-
pression getPicture , the oracle is queried for meth-
ods with the same name taking at least three variables;
this returns only one possible match. This match is
called navigator.camera.getPicture in the ora-
cle so the full expression ends up matching.
1e.The next function expression is on line 10; getElement-
ById matches 3 functions. Next, Baker checks to see if
any of these are dened as document.getElement-
ById ; this results in a single match.
1f.Some JavaScript libraries are augmented with return
type information. In this case, the oracle knows that
document.getElementById returns an Element ;
as such, image is annotated with 68 possible types.
On line 11, the reference to the property image.src
further reduces the number of possible types to three.
It is important to note that even if the returned ob-
ject did not have a src property, this would be valid
JavaScript code { a new property would be added to
the object. Baker assumes that library code will not
be dynamically augmented in this way.
1g.The function call to alert matches two elements, win-
dow.alert andnotification.alert . Since win-
dow is the default namespace for JavaScript executed
in the browser, we link alert towindow.alert .
2a.In the second iteration we link the call to useGetPic-
ture in line 1 to the function declaration on line 4.
2b.Next, we update the link between onCameraSuccess
andonCameraError on lines 5 and 7 to match the
function declarations on line 9 and 13.
2c.No new information has been learned about the exact
type of image on lines 11 and 12; as such, this element
is left with a cardinality of 3. That said, if the devel-
oper were interested in this element they could be given
the option to choose between HTMLInputElement ,
HTMLImageElement , and HTMLScriptElement .
Given the data:image/jpg string on line 11, the de-
veloper could likely make the right choice.4. ORACLE GENERATION
As demonstrated by the two detailed examples in the pre-
vious section, Baker's oracle is key to its success. In this
section, we explain why the use of an oracle is necessary,
then describe how we created our Java and JavaScript ora-
cles.
4.1 Why Use an Oracle?
For some traceability tasks, an oracle is not necessary.
For example, Rigby and Robillard developed a tool that can
extract the code elements contained in various documents
with high precision without an oracle [16]. However, with-
out an oracle, it is generally impossible to identify the fully
qualied names of the code elements in a snippet. These
fully qualied names are essential to documentation linking
tasks; thus, an oracle is required. As we will see in the re-
mainder of this section, this is not a dicult requirement to
satisfy: the initial oracle can be generated fairly quickly and
subsequent updates can be done dynamically.
4.2 Oracle Generation
We built oracles for both Java and JavaScript. The ora-
cles are implemented as web services, allowing them to be
updated dynamically by any user or program. New devel-
opment resources can be POST ed to the service and are au-
tomatically analyzed and incorporated into the oracle. Sim-
ilarly, any program or linker can query the service to deter-
mine what elements are present that meet a certain set of
constraints.
4.2.1 Java Oracle
The Java oracle is a database containing class, method
and eld signatures. We chose a graph database, Neo4j,
for this purpose; the graph data structure makes it easier
to represent the hierarchies between code elements that an
object-oriented language like Java oers. Since Java is stati-
cally typed, we include full type information in the database
including the types of classes, elds, return types, and pa-
rameters. The database also contains links for all inheri-
tance relationships so we can more eectively handle poly-
morphism in example snippets.
The Java oracle can be dynamically updated by adding an
appropriate JAR. We built a simple web service that allows
a JAR le to be uploaded and automatically analyzed and
added to the oracle by a tool called Dependency Finder2.
This tool identies the class, method and eld signatures
from the .class les contained in the JAR. These are then
added to the existing Neo4j oracle graph. We chose to im-
plement this web service to make the oracle update process
as seamless as possible.
To bootstrap our oracle we used Daniel German's list
of signatures extracted from over 1.5 million classes in the
Maven repository. In total, it contains 14 million method
signatures and 3 million eld signatures [10].
4.2.2 JavaScript Oracle
The JavaScript oracle is built by statically analyzing the
source les of the libraries to be included. We use ES-
PRIMA3to parse the source code of each library. Since
JavaScript libraries are frequently minied and obfuscated,
2https://bitbucket.org/rtholmes/depfind_uw
3http://esprima.org/646Table 1: Number of unique fully qualied names, partially qualied names, and unqualied names in the
Java oracle for each kind of indexed element. 89% of method names are ambiguous if not fully qualied while
33% of partially qualied method names are still ambiguous.
Types Methods Fields Total Average
Fully Qualied Names 1,646,650 14,206,944 3,149,206 19,002,800 /
Partially Qualied Names / 9,455,644 2,571,384 12,027,028 /
Unqualied Names 1,121,887 1,600,053 1,115,099 3,837,039 /
% Ambiguous Partially Qualied Names / 33% 37% / 37%
% Ambiguous Unqualied Names 32% 89% 65% / 80%
we used the `source' version of each library, i.e., the ver-
sion before these transformations were applied. The ES-
PRIMA parser returns a JSON representation of the AST.
From this, we identify all of the `FunctionExpression' and
`FunctionDeclaration' nodes. We traverse the path to each
of these function nodes to identify the namespace hierarchy
that would need to be used to access these functions. Since
object assignments in JavaScript are pass-by-reference, an
additional traversal of the AST is performed to map non-
trivial and indirect Function Expression assignments.
As an example, consider the snippet of code from Back-
bone.js in Figure 3. A rst pass is done to fetch all Func-
tionExpression variables, in this case, extend . An addi-
tional traversal of the AST is performed to identify transitive
aliases like History.extend andView.extend , which inherit all
properties of the extend object. In this second pass, all pos-
sible aliases are traced back and are subsequently entered
into the oracle.
JavaScript libraries often make calls to external libraries
in their source code. Function objects are passed as param-
eters to these external libraries to be modied and assigned
to other objects. We follow these assignments one level deep,
but since JavaScript does not have type information for ob-
jects returned from functions, our ability to reason about
these assignments degrades after two assignments. For this
reason, we stop after two passes.
1_.extend(History.prototype, Events, {
2
3 getHash: function(window) {
4 ...
5 },
6});
7var extend = function(protoProps, staticProps){
8 ...
9};
10 View.extend = History.extend = extend;
Figure 3: A snippet from the source code of Back-
bone.js
Generating the JavaScript oracle was somewhat harder
than generating the Java oracle, since the dynamic nature
of JavaScript makes it dicult to identify all method decla-
rations by static analysis of source code. To overcome this,
we take advantage of JSDoc4annotations (and other simi-
lar documentation tools) in the library source code whenever
they are available.
4https://github.com/jsdoc3/jsdocAnother challenge is that JavaScript is not annotated with
visibility (e.g., public andprivate ). This makes it di-
cult to dierentiate between the public API and those inter-
nal methods that are not meant for public access. Including
the internal methods in the oracle may make Baker slightly
less accurate. Source code snippets are unlikely to use the
internal methods, so these elements will rarely be matched,
but their existence in the oracle may increase ambiguity,
making it harder to match public API elements with the
same name.
In this study, we populated the oracle with source code
from seven dierent libraries, including the core JavaScript
API. These libraries contain over 1,600 API object prop-
erties including functions, properties and event handlers.
These libraries were chosen by gauging the popularity of the
libraries' Github repositories and related activity on Stack-
Overow.
To dynamically add new JavaScript libraries to the oracle,
we rely on npm5, which is a package manager for node.js .
We use npm to fetch the source code of said library. Baker
then analyzes the source code to populate API methods and
properties and add them to the existing database of API
signatures.
4.3 Naming Ambiguities
Fully qualied names are heavily used in computer pro-
grams to reduce the likelihood that program identiers (e.g.,
type names, method names, and eld names) will conict be-
tween dierent programs and libraries. For example, while
Logis a common unqualied type name (occurring 284 times
in the Java oracle), developers use fully qualied names to
identify the Log they are interested in (such as org.apa-
che.tomcat.util.log.Log vs.org.eclipse.jetty.-
util.log.Log ).
Method and eld identiers can be partially qualied if
their identier contains the type in which they are declared.
For example, while the unqualied method name getId()
occurs 27,434 times in the oracle, org.neo4j.graphdb.-
Node.getId() andjsx3.xml.Node.getId() can be used
to dierentiate between two dierent getId() declarations.
Class names cannot be partially qualied without consider-
ing either package identiers or namespaces.
Naming ambiguity is common; Dagenais and Robillard
previously found that 89% of method names are ambigu-
ous and the average method name conicts with 13 other
methods [9]. We extended their result to 1.6 million types
and extended the analysis to include types, methods, and
elds. We also investigated the dierences between fully
5https://www.npmjs.org/647Table 2: Baker's overall Java precision (0.98) and
recall (0.83). Only exact matches ( cardinality = 1)
were considered.
System TP FP FN c=1FNc>1
Android 40 1 8 1
GWT 43 0 7 0
Hibernate 37 0 13 0
Joda Time 44 3 3 0
XStream 40 0 10 0
Total 204 4 41 1
qualied names, partially qualied names, and unqualied
names. The results are detailed in Table 1.
We found the same result as Dagenais and Robillard:
89% of unqualied method names collided. We also found
that one-third of unqualied types and one-third of partially
qualied methods collide. These results conrm our earlier
statement that unqualied names are insucient to link a
code element to the correct document. Some methods, like
getId() , have thousands of unique fully-qualied declara-
tions in the oracle that all conict when unqualied.
5. EVALUATION
In evaluating Baker, we wanted to answer two research
questions: rst, can Baker accurately identify API elements
in code snippets; and second, does Baker work on a variety
of systems, or is it limited to just a few libraries?
5.1 Linker Accuracy
To answer our rst question, we manually examined a
number of the matches produced by Baker to see if the tool
could correctly identify API elements. We did this for both
Java and JavaScript code snippets.
We rst populated Baker with a number of source code ex-
amples. We obtained our snippets from the Stack Overow
data repository provided for the 2013 MSR Challenge [3].
We augmented these by pulling from a few repositories on
GitHub that were aimed at collecting source code examples.
Baker analyzed 1,000 JavaScript source code snippets and
4,000 Java source code snippets.
Table 3: Number of matched elements from 4,000
Java code snippets extracted from Stack Overow
and Github. The types and method cells are split
(total # matches / unique # elements).
System # types # methods
Android 272/64 175/104
Apache 178/79 108/97
Eclipse 104/41 53/45
GWT 149/47 122/69
Hibernate 389/133 378/199
JDK 14,252/632 7,483/1,981
Other 5,956/487 1,339/747
Total 21,300/1,483 9,658/3,242Table 4: Baker's overall JavaScript precision (0.97)
and recall (0.96). Only exact matches ( cardinality =
1) were considered.
System TP FP FN c=1FNc>1
JSCore/DOM 48 2 0 0
JQuery 47 2 1 0
Phonegap 46 2 2 0
Webworks 43 0 5 2
Total 184 6 8 2
In this context, precision is much more important than
recall. Since the web contains tens of thousands of snippets,
we would rather suer a false negative result (a failure to
infer a link that should have been identied), than a false
positive (incorrectly linking one element to another). To this
end, we also only analyzed Baker's recommendations that
had a cardinality of 1; that is, we only examined the results
that the tool was sure were correct. While the other results
could be useful for the developer, we would not display them
to the developer by default.
We chose the systems to analyze for our precision evalu-
ation by identifying the union of the systems evaluated in
the RecoDoc [9] and ACE [16] papers and in Parnin's Stack
Overow study [5]. The ve libraries used in these stud-
ies are listed in Table 2. We then randomly selected code
snippets from our repository that Baker had analyzed and
had been annotated with a tag indicating it should contain
a question of relevance to the project under study. When-
ever Baker claimed that it had identied an API element
from one of the ve libraries in Table 2, we manually ex-
amined the snippet to determine if the result returned by
Baker a) correctly matched the API intended by the devel-
oper (true positive [TP]) or b) incorrectly matched the API
(false positive [FP]). We also examined the snippet to see if
there were tokens not associated with any links at all but
that we would have expected to see a result (false negative
[FN]). We stopped once we had examined 50 code elements
for each system in this way. The overall Java precision is
0.98 with a recall of 0.83. When we included any result
with a cardinality >1 (that is, where the correct element
was found but could not be uniquely identied), the recall
increased to 0.96.
Table 5: Number of matched elements from 1,000
JavaScript code snippets extracted from Stack Over-
ow and Github. The object and properties cells are
split (total # matches / unique # elements).
System # properties
JSCore/DOM 6,467/107
JQuery 1,793/96
Phonegap 126/27
Webworks 244/52
Other 1,297/300
Total 9,927/582648Table 6: Example of an imprecise Baker match. The top row represents the correct answer.
com.thoughtworks. xstream.io.xml.AbstractDocumentReader
com.cloudbees.shaded.thoughtworks. xstream.io.xml.AbstractDocumentReader
com.ovea.jetty.session.internal. xstream.io.xml.AbstractDocumentReader
cucumber.runtime. xstream.io.xml.AbstractDocumentReader
org.pitest. xstream.io.xml.AbstractDocumentReader
For JavaScript we applied the same procedure for analyz-
ing the snippets and assessing true positives, false positives,
and true negatives. Since none of the previous papers inves-
tigated JavaScript, we just chose four Stack Overow tags
for which there were a large number of associated questions.
The JavaScript precision was 0.97 while the recall was 0.96.
We believe the dierence in the recall between the Java and
JavaScript analyses was that the Java oracle had millions
of entities in it, while the JavaScript oracle had only thou-
sands. That said, we believe the Java oracle demonstrates
that even with a huge breadth of API elements to choose
from the approach still delivers reasonably high recall.
5.2 Example Diversity
In addition to assessing Baker's ability to identify links
between source code examples and the API they represent,
we looked further into the links identied by the tool to see
the breadth of the systems it was able to generate links for.
JavaBaker parsed 4,000 source code snippets. It identied
over 30,000 links to 4,500 unique API elements. Table 3 de-
scribes the elements that were identied in more detail. To
get an idea of the projects that were referenced, we looked at
the packages that were linked to. We then aggregated these
and considered only those that had the same two initial to-
kens (e.g., all org.eclipse references would count as 1).
This resulted in 188 unique second-tier packages for which
we have examples. If we considered third-tier packages (the
same rst three tokens), 347 dierent packages were refer-
enced.
JSBaker parsed 1,000 source code snippets and identied
almost 10,000 references to over 500 unique elements. A
brief overview of the systems identied are shown in Table 5.
Looking into the elements in the `other' category, we see
a variety of popular JavaScript frameworks like Angular,
Ember, Underscore, Require, Backbone, and so on. Since
JavaScript programs tend to `mash up' many libraries, we
nd that even if the exact library being asked about is not
in the oracle, elements from other libraries are often found
interspersed with these references.
5.3 Quantifying High-Cardinality Matches
As mentioned previously, our deductive linking method
returns more than one match when there is not enough
information to uniquely identify the FQN of a method or
type. However, this is relatively rare. To quantify this, we
recorded the cardinality of the result for each of the 4,000
snippets described in Table 3; this data is plotted in Fig-
ure 4. As can be seen in the gure, the majority (69%)
of elements can be precisely identied, though there was a
long tail that had high cardinality values. We have removed
references to JDK types and methods from this gure since
many of these results had cardinality 1 and we wanted to
ensure this was not the cause of the long tail eect. The
results with them included are even better (85% preciselyidentied). This result supports the use of the tool for live
API documentation, since in the majority of cases we can
link documents that discuss the same source code element
precisely.
We performed an informal analysis of the elements that
Baker matched to with multiple targets. Surprisingly, the
most common cause of these multiple matches (more than
half) were situations where projects make internal clones of
existing source code les to avoid having to include an exter-
nal JAR le along with their project. An example of this can
be seen in Table 6. In these cases, Baker's results contain
the correct FQN; we are currently working on techniques for
dierentiating between these results.
The impact of high-cardinality matches depends on the
intended use of the data; some tasks favour recall over preci-
sion while for other tasks the reverse is preferred. For exam-
ple, when annotating a Stack Overow example with FQN
information, presenting a small number of possible type op-
tions for the developer to choose from would be reasonable
as they could use their own intuition gained from the snip-
pet text to make an informed selection. Conversely, when
annotating ocial API documentation with usage examples
we would only want to include exact matches as this context
would not be present.
5 10 15 20
Cardinality02000400060008000Number of API Method/Type usage instances excluding JDK instances
Figure 4: A histogram of the cardinality values ob-
tained when the tool was run on the 4,000 code snip-
pets described in Table 3.
5.4 Threats to Validity
The accuracy of our evaluation is subject to our ability
to correctly identify each API usage in the code snippets
we investigated. While the inherent ambiguity present in
source code snippets sometimes obscured what the devel-
oper intended, since snippets generally exist to answer spe-
cic questions within a particular context, we were usually649able to identify the intended element. When we were not,
or when Baker was incorrect, we conservatively agged the
recommendation as a false positive.
To reduce overtting and increase generalizability, the
Java systems we selected for the precision analysis were cho-
sen by taking the union of systems evaluated for Recodoc [9],
ACE [16], and Parnin's StackOverow study [5]. Baker was
executed in its default conguration for all studies. The only
exception was that JavaScript snippets were only submitted
to JSBaker while the Java snippets were sent to JavaBaker.
6. ENABLING LIVE DOCUMENTATION
We have applied the fully qualied API usages identied
by Baker to create bidirectional links between snippets using
an API and the documentation and source code represented
by the API. As previously discussed, keeping documenta-
tion current is challenging and expensive. We therefore cre-
ate links between source code examples and the ocial API
documentation being used in the code examples that are
automatically kept up to date without requiring any eort
from documentation maintainers.
Our approach augments HTML-based source code exam-
ples and API documentation by adding relevant links be-
tween pages that are related by the APIs they use (or de-
scribe). These links can occur in multiple directions. For
example, a Stack Overow snippet can be augmented with
links from a specic method call to the documentation for
the API the call represents. The API documentation can
also be updated with links back to source code examples
demonstrating its usage. To do this, we use a browser ex-
tension that is able to monitor pages to see if they contain
source code examples or are API documentation. If either
of these is true, the pages are augmented by injecting new
HTML elements into the page that represents links to other
related resources.
To ensure our example repository is always current, we
also continually monitor Stack Overow to parse new source
code examples as they are posted. Any API usage detected
in these examples is added to a database we maintain so
that usage links can be injected into API documentation.
This means that as long as questions are being asked and
answered about an API, the documentation will be updated.
It remains to be seen if this could convince API owners to
answer questions about their APIs in Stack Overow know-
ing that their answers will be tied directly back to their own
documentation.
One piece of data is missing in order for the browser exten-
sion to work: an explicit mapping between a fully-qualied
name and the corresponding ocial API documentation.
Fortunately, generating these links is easy to manage in prac-
tice. This is because the vast majority of API documenta-
tion is automatically generated and is very well formed. For
example, augmenting the Android API documentation with
examples simply requires a mapping from a Java package to
a web location, e.g., android. *!http://developer.
android.com/reference/ . With this mapping, the brow-
ser extension can automatically determine the correct target
page that should be annotated (in either direction) with ei-
ther the source code example or API documentation link.
Figure 5 shows how our browser extension modies a Stack
Overow post. Normally, the source code snippet in the post
does not contain the underlined elements and is treated as
a plain text block. In this case, the Baker extension detectsthat the user has navigated to a Stack Overow post. If
this post had not been previously parsed, it is now parsed
on demand. Once the parsing is complete, Baker has a list
of which API elements are present in the post and where
they are used. After consulting the mapping, the exten-
sion modies the code block to show all of the elements
that Baker has identied by underlining them. In this case,
Baker was able to correctly identify the fully-qualied name
formChronometer (in addition to several other types and
methods). When the developer hovers their mouse over
mChronometer (as they are in Figure 5), they are presented
with a dynamic popup that contains links to the ocial An-
droid Chronometer API documentation, to the source code
forChronometer , and links to 18 other Stack Overow
posts that also use Chronometer .
In the opposite direction, Figure 6 shows how the browser
extension augments the ocial Android documentation with
Stack Overow examples. Once again, the browser extension
detects from the mapping le that the user is visiting a page
for which it has API usage examples. While Baker actively
monitors new Stack Overow for new examples, any snippet
the browser extension has encountered can be included in
the example list. It then checks the page to see if Baker
has examples for any of the API elements on the page; if it
does, it injects a small table into the page that describes the
relevant source code examples. These example tables can be
injected for types and methods.
Baker is able to parse source code snippets found in on-
line repositories to identify fully qualied names that pertain
to API usage. It is able to use these fully qualied names
as a form of links that can be dynamically injected into
web-based code resources. This improves the utility of the
source code examples by enabling easy navigation to ocial
API documentation for any given code element while simul-
taneously enhancing the API documentation by providing
concrete usage examples that compliment the traditional
descriptions of the API. The entire process is automatic,
enabling injected markup to be dynamically updated when-
ever new resources are encountered. The Baker parser web
service and the browser extension are both available online6.
7. DISCUSSION
A number of opportunities exist for extending the utility
of the Baker data. For example, the API elements on a page
could be dynamically reordered based on how many dier-
ent examples have been found for them. While API elements
that have more examples associated with them could be in-
terpreted as being more dicult, they might also indicate
the key elements a developer should consider. PopCon [12]
explores a similar concept, but leverages a large static anal-
ysis repository rather than code examples.
While developers frequently create APIs, it is not straight-
forward for them to receive feedback on the APIs' ease of
use. Baker could allow developers to discover the common
questions people have about their APIs. This feedback could
be used to guide future API updates or simple documenta-
tion xes.
In the future, we aim to document and fully open the web
services that power Baker. This would allow anyone to add
new code to the Java and JavaScript oracles, update map-
ping les, submit snippets to be parsed, and query Baker.
6https://cs.uwaterloo.ca/~rtholmes/baker650Figure 5: Baker-augmented Stack Overow post. Note that the Baker browser extension automatically
augmented the Stack Overow post without any intervention from the teams maintaining Stack Overow,
GitHub, or the Android documentation.
Figure 6: Here we can see that the Baker browser extension has injected a list of relevant Stack Overow
posts into the ocial Android API documentation. These links dynamically update without any intervention
from the documentation team.
In addition, we will be releasing the browser extension so
that other researchers and developers can try the tool and
provide feedback.
8. RELATED WORK
As described in Section 1, previous work has shown that
writing and maintaining documentation is dicult [8, 9].
Consequently, researchers have explored ways to make this
task easier. One way of doing this is to automatically addlinks to the documentation that direct developers to other
relevant artifacts. For example, XFinder maps tutorial steps
to the classes involved in the tutorial [7].
Linking API documentation to examples of correct use is
a special case of this idea. Bacchelli et al. [1] used regular
expressions to match text terms to method names. This
technique can produce some matches, but cannot resolve
the ambiguity that results from having many methods with
the same name in the API. Chen [4], De Lucia et al. [11] and651Hsin-Yi et al. [13] used information retrieval techniques to do
coarse granularity linking (e.g., linking an entire document
to a source class). These techniques are useful, but cannot
do the ne-grained linking necessary to identify correct uses
of, for instance, a method in an API.
The two systems most similar to ours are RecoDoc [9] and
ACE [16]. RecoDoc uses partial program analysis (PPA [6])
to infer links between documentation and an API. Like Re-
coDoc, we use PPA and an oracle as part of our link nding
approach. Unlike RecoDoc, Baker uses a much bigger oracle
and does not need to be told which API corpus to use; a
single oracle is used for all queries. Moreover, Baker can be
used with dynamically typed languages.
ACE is a linking system that tries to relax two of Re-
coDoc's key assumptions: that there must be an oracle, and
that each mention of a code element in the documentation
has equal relevance to a problem. Like ACE, Baker ranks
the output based on expected relevance. However, ACE uses
an island grammar instead of PPA and cannot do documen-
tation linking because the results are not fully qualied.
9. CONCLUSION
Maintaining API documentation is a challenging, time-
consuming task; consequently, the documentation is frequent-
ly out of date. This paper presented a method and tool
for automatically generating links between API documenta-
tion and source code examples. We demonstrated that our
tool, Baker, has high precision (0.97) and is able to suc-
cessfully link code snippets to thousands of dierent Java
classes and methods along with hundreds of JavaScript func-
tions. Baker's results can be automatically integrated into
web pages for both the source code examples and the ocial
API documentation. This will increase the timeliness of the
API documentation while providing valuable reference links
for source code examples.
10. ACKNOWLEDGEMENTS
We would like to thank Daniel German for his extensive
help populating our Java oracle. We also want to thank the
anonymous reviewers for their comments which have greatly
improved the paper.
11. REFERENCES
[1] M. L. Alberto Bacchelli and R. Robbes. Linking
e-mails and source code artifacts. In Proceedings of the
International Conference on Software Engineering
(ICSE) , pages 375{384, 2010.
[2] G. Antoniol, G. Canfora, G. Casazza, A. D. Lucia,
and E. Merlo. Recovering traceability links between
code and documentation. IEEE Transactions of
Software Engineering , 28(10):970{983, 2002.
[3] A. Bacchelli. Mining challenge 2013: Stack overow.
InThe Working Conference on Mining Software
Repositories , 2013.
[4] X. Chen. Extraction and visualization of traceability
relationships between documents and source code. In
Proceedings of the International Conference on
Automated software Engineering (ASE) , pages
505{510, 2010.
[5] L. G. Chris Parnin, Christoph Treude and M.-A. D.
Storey. Crowd documentation: Exploring the coverageand the dynamics of API discussions on Stack
Overow. Technical Report GIT-CS-12-05, Georgia
Tech, 2012.
[6] B. Dagenais and L. Hendren. Enabling static analysis
for partial Java programs. In Proceedings of the
Conference on Object-Oriented Programming,
Systems, Languages and Applications (OOPSLA) ,
pages 313{328, 2008.
[7] B. Dagenais and H. Ossher. Automatically locating
framework extension examples. In Proceedings of the
International Symposium on Foundations of Software
Engineering (FSE) , pages 203{213, 2008.
[8] B. Dagenais and M. P.Robillard. Creating and
evolving developer documentation: Understanding the
decisions of open source contributors. In Proceedings
of the International Symposium on Foundations of
Software Engineering (FSE) , pages 127{136, 2010.
[9] B. Dagenais and M. P. Robillard. Recovering
traceability links between an API and its learning
resources. In Proceedings of the International
Conference on Software Engineering (ICSE) , pages
47{57, 2012.
[10] J. Davies, D. M. German, M. W. Godfrey, and
A. Hindle. Software bertillonage. Empirical Software
Engineering , 18(6):1195{1237, 2013.
[11] A. De Lucia, R. Oliveto, and G. Tortora. Adams
re-trace: Traceability link recovery via latent semantic
indexing. In Proceedings of the International
Conference on Software Engineering (ICSE) , pages
839{842, 2008.
[12] R. Holmes and R. J. Walker. A newbie's guide to
Eclipse APIs. In Proceedings of the Working
Conference on Mining Software Repositories (MSR) ,
pages 149{152, 2008.
[13] H. Jiang, T. Nguyen, I.-X. Chen, H. Jaygarl, and
C. Chang. Incremental latent semantic indexing for
automatic traceability link evolution management. In
Proceedings of the International Conference on
Automated Software Engineering (ASE) , pages 59{68,
2008.
[14] A. Marcus and J. I. Maletic. Recovering
documentation-to-source-code traceability links using
latent semantic indexing. In Proceedings of the
International Conference on Software Engineering
(ICSE) , pages 125{135, 2003.
[15] C. Parnin and C. Treude. Measuring API
documentation on the web. In Proceedings of the
International Workshop on Web 2.0 for Software
Engineering (Web2SE) , pages 25{30, 2011.
[16] P. C. Rigby and M. P. Robillard. Discovering essential
code elements in informal documentation. In
Proceedings of the International Conference on
Software Engineering (ICSE) , pages 832{841, 2013.
[17] J. Singer. Practices of software maintenance. In
Proceedings of the International Conference on
Software Maintenance (ICSM) , pages 139{145, 1998.
[18] S. Subramanian and R. Holmes. Making sense of
online code snippets. In Proceedings of the Working
Conference on Mining Software Repositories (MSR) ,
pages 85{88, 2013.652