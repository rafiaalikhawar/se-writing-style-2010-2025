See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/221555849
A cut-off approach for bou nded veriÔ¨Åcation of parameterized systems
Conf erence Paper ¬†¬† in¬†¬†Proceedings - Int ernational Conf erence on Softw are Engineering  ¬∑ May 2010
DOI: 10.1145/1806799.1806851 ¬†¬∑¬†Sour ce: DBLP
CITATIONS
21READS
181
2 author s:
Qiusong Y ang
Instit ute of Softw are, Chinese Ac ademy of Scienc es
38 PUBLICA TIONS ¬†¬†¬†200 CITATIONS ¬†¬†¬†
SEE PROFILE
Mingshu Li
Chinese Ac ademy of Scienc es
87 PUBLICA TIONS ¬†¬†¬†1,534  CITATIONS ¬†¬†¬†
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y Qiusong Y ang  on 01 June 2014.
The user has r equest ed enhanc ement of the do wnlo aded file.A Cut-off Approach for Bounded VeriÔ¨Åcation of
Parameterized Systems
Qiusong Y ang1
qiusong_yang@itechs.iscas.ac.cn
1Laboratory for Internet Software Technologies
Institute of Software, Chinese Academy of
Sciences
Beijing 100190, P .R. ChinaMingshu Li1,2
mingshu@iscas.ac.cn
2State Key Laboratory of Computer Science
Institute of Software, Chinese Academy of
Sciences
Beijing 100190, P .R. China
ABSTRACT
The features in multi-threaded programs, such as recursion,
dynamic creation and communication, pose a great challenge
to formal verication. A widely adopted strategy is to ver-
ify tentatively a system with a smaller size, by limiting the
depth of recursion or the number of replicated processes,
to nd errors without ensuring the full correctness. The
model checking of parameterized systems, a parametric in-
nite family of systems, is to decide if a property holds in ev-
ery size instance. There has been a quest for nding cut-os
for the verication of parameterized systems. The basic idea
is to nd a cut-o on the number of replicated processes or
on the maximum length of paths needed to prove a property,
standing a chance of improving verication eciency sub-
stantially if one can come up with small or modest cut-os.
In this paper, a novel approach, called Forward Bounded
Reachability Analysis (FBRA), based upon the cut-o on
the maximum lengths of paths is proposed for the verica-
tion of parameterized systems. Experimental results show
that verication eciency has been signicantly improved
as a result of the introduction of our new cut-os.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veri-
cation| Model checking, Formal methods
General Terms
Verication, Algorithms
Keywords
Parameterized System, Bounded Model Checking, Cut-o
1. INTRODUCTION
In multi-threaded programs, such as those written in the
Java and C programming languages, it may be necessary for
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô10, May 2-8 2010, Cape Town, South Africa
Copyright 2010 ACM 978-1-60558-719-6/10/05 ...$10.00.numerous replicated processes (or threads) to be dynami-
cally created during the program's execution. This may be
done, for example, to enable the concurrent manipulation
of dierent requests or to support various kinds of back-
ground computations. The verication of such kinds of sys-
tems poses a great challenge because it is often dicult, if
not impossible, to predict the precise number of replications
that may be needed for any particular execution. This may
cause the verication of such programs to be undecidable,
especially when such features as concurrency, recursion, dy-
namic creation and communication are present.
A strategy that is often adopted is to verify another pro-
gram that is derived from the original program, by limiting
the depth of recursion or the number of replicated processes.
While the verication of this derived program does not as-
sure the verication of the original, it may nd the errors
in the derived program that then might be expected to also
be present in the original program. Thus, for example, the
Java program given in Fig. 1, is derived from the producer-
consumer problem presented in [7] by the removal of the
method modier \synchronized" of the getandputmethods.
In [7], only kCreplications of a class C, a limit provided by
the analyst, are allowed to be created. This creates a bound
on the state space and enables verication of the derived
program. We note that even if this kind of reduced version
of a program is decidable, the size of the state space needed
for verication may still spiral out of control when the num-
ber of replicated processes grows. Of more concern, perhaps,
is the possibility that some errors that depend on the num-
ber of replicated processes (e.g. those that arise from higher
levels of concurrency) might not be detected when only de-
rived versions having bounded numbers of replications are
investigated. For example, a derived version of the producer-
consumer system may not be sucient to support detecting
that new elements will still be put into the buer even when
it is full if the number of replicated processes is limited to
less than the capacity of the buer, BUF CAPACITY , in
the derived version.
Therefore there is considerable interest in determining
whether it is possible to compute a cut-o on the number of
process replications or on the maximum length of paths in a
derived version that is sucient to assure that a verication
of the derived program also serves as a verication of the
original program. In this paper, we explore this possibility,
focusing on parameterized systems, a subset of concurrent
systems that involve multiple heterogeneous classes of nite-
state processes and depend on parameters that dene thenumber of replications of each class's process template [11].
An advantage of parameterized systems is that the goal of
verication of such systems is to decide if a property holds
for every system size. Thus, the verication of a property of
a parameterized system will hold irrespective of the system
size, and thus without any concern for determining a bound
on the number of process replications. Unfortunately, the
verication of general parameterized systems is undecidable
[2]. On the other hand, verication of a class of commonly
used systems consisting of many identical and nite-state
processes is decidable [19, 17, 1, 15, 13, 14, 8, 9].
Problem Statement. There has been a quest for nd-
ingcut-os , bounds on the number of replications or the
maximum length of paths, that nevertheless assure the pos-
sibility of the verication of parameterized systems. The
basic problem is to show that, for a given property Sand a
parameterized system P(n1;n2;;nk) =C1Cl
(U1;U2;;Uk)(n1;n2;;nk), denoting an innite family of
concurrent systems in which each system is composed of C1
throughClandn1replications of U1throughnkreplica-
tions ofUkrunning in parallel synchronously, there is a cut-
oC(P;S), which is invariant with respect to n1;n2;;nk,
on the number of replications of each process template or on
the maximum length of paths needed to prove the property
S. An advantage of cut-o approaches is that the verica-
tion of an innite family of systems can be turned into a
verication problem having a nite state space. If one can
come up with a cut-o that is small or moderate in size,
verication eciency might be substantial.
Prior Work. The prior work on cut-os can be clas-
sied into two categories: a)Cut-os on the number of
replications . Several pioneering attempts, such as those
based on process closures [5],bisimulation [6],process in-
variants [20], and network invariants [22], have succeeded
in reducing the verication of parameterized systems to the
verication of a system with a nite number of processes.
However, these approaches are semi-automatic and the clo-
sures or invariants needed to support these verications have
to be supplied by the analyst. More recently papers by
[11], [4], and [3] have demonstrated the existence of cut-os
for various kinds of parameterized systems and specication
logic pairs. Unfortunately , most cut-os that have been
demonstrated do not lead to ecient decision procedures or
eective means for reductions, and small cut-os have only
been demonstrated for some relatively simple types of sys-
tems. b)Cut-os on the maximum length of paths .
A cut-o phrased in terms of the maximum length of paths
would seem to oer computational complexity advantages,
as a system whose bound is on the number of nodes in its
longest path would seem to have a far smaller search space
than a system whose bound is the same number of repli-
cated processes, as the number of global states in the latter
may grow exponentially. Moreover, note that in bounding
the longest path, a cut-o on the number of replicated pro-
cesses is inferred (by assuming that each node in a path is
executed by a dierent process replication). In [17] and [12],
the authors show that a cut-o exists for the verication of
parameterized systems composed of a control process and
an arbitrary number of user processes against indexed LTL
properties. The proof of the existence of such cut-os is use-
ful in proving the decidability of the decision procedures for
such systems. However this previous work has not shown
how to compute the value of a cut-o, and thus is unable topublic class IntBuer f
protected int []data,count=0,front=0;
nal SimpleLock LockFull = new SimpleLock();
nal SimpleLock LockEmpty = new SimpleLock();
public IntBuer(int capacity) f
data = new int[capacity]; // array allocation
g
public void put(intx)f
while (count == data.length)
LockFull.await(); // wait until buer is not full
data[(front+count) % data.length] = x;
count = count + 1;
LockEmpty.notify(); // wake up a waiting process
g
public int get() f
while (count == 0 )
LockEmpty.await(); // wait until buer is not empty
intx = data[front];
front = (front + 1) % data.length;
count = count - 1;
LockFull.notify(); // wake up a waiting process
return x;
g
public class Producer implement Runnable f
protected IntBuer buf;
public Producer(IntBuer b) fbuf = b; g
public void run() f
Random random = new Random();
intval = random.nextInt();
buf.put(val);
g
g
public class Consumer implement Runnable f
protected IntBuer buf;
public Consumer(IntBuer b) fbuf = b; g
public void run() f
intval = buf.get();
System.out.println(val);
g
g
public class Main f
protected nal int BUF CAPACITY = 512;
public static void main(String []args) f
IntBuer buf = new IntBuer(BUF CAPACITY);
while (true) f
new Thread( new Consumer(buf)).start();
new Thread( new Producer(buf)).start();
g
g
Figure 1: Producer-consumer Example
help in the verication of actual systems of this kind.
Contributions. In this paper, an FBRA approach based
upon the cut- on the maximum length of paths is proposed
for the verication of parameterized systems with only ren-
dezvous actions against a property automaton , a nite state
machine specifying a set of undesirable behavior. At the
same time, the approach is sound and complete.
A Novel Approach to Determine Cut-os : Given a pa-
rameterized system and a property automaton, at most =in-
creasingly rened abstractions, fA0;A1;;Ai;;A= 1g,
are generated, where =is the total number of local states
of all class templates. Let Cibe a cut-o on the maximum
length of paths needed to decide if the property holds in
Ai. We rst show that it is straightforward to calculate C0.
Second, we prove that Ci(1i=) can be reduced to the
sum ofgiandCi 1, wheregiis a number inherent to Ai.
Finally,C=will be the cut-o that we expect.
Premature Termination: If someCi(i <=) is equal to
zero, no undesired paths are feasible in Ai. The construc-
tion ofAiensures thatC=is also equal to zero, meaningthat no undesired paths will be feasible in the original sys-
tem. Then we know that the property does hold and the
decision procedure can terminate. This makes the calcula-
tion of the nal cut-o C=unnecessary. On the other hand,
the decision procedure can also terminate with a conclusion
that the property does not hold if a counter-example found
inAiis also a feasible path of the original system.
Guided Forward Reachability Analysis : Typical for-
ward reachability analyses of parameterized systems, such
as [19] or its variant [13], use !-congurations as abstrac-
tions and xed-point algorithms to construct a nite reach-
ability graph. However, the problem with those approaches
is that the loss of information during the generation of !-
reachability graphs makes it dicult to construct a counter-
example when a property does not hold. A cut-o for for-
ward reachability analyses allows for a direct search over a
non-compacted innite reachability graph.
Experiment Results : The results show that our cut-o
technique can help with the verication of real systems against
properties of real interest. Experimental results show that
verication eciency has been greatly improved as a result
of the introduction of our new cut-os.
The rest of this paper is organized as follow: Prelimi-
nary denitions of parameterized systems are presented in
Section 2. Section 3 gives an overview of our approach and
those technical sta laying a foundation for every step of the
approach is presented in Section 4. Experimental results are
given in Section 5, and related work is included in Section
6. Section 7 concludes this paper.
2. PARAMETERIZED SYSTEMS
As for the denition of each component of a parameter-
ized system, we will follow those notions presented in [10]
except that the broadcast actions are excluded. To describe
guarded transitions of a parameterized system, we rst need
the following denition:
Boolean Guards/Actions [10] LetB=fb1;;bngbe
a set of global boolean variables, and let B0be their primed
version. A boolean guard 'gis either the formula true and
false or the conjunction of literals `1^^`p, wherepn,
such that`iis eitherbor:bfrom some b2B. A boolean
action'ais a formula b0
1=v1^^b0
n=vn, whereviis
one oftrue;false;b ifor 1in.
Process Aprocess is a tuplehS;;i, where:
{S: a nite set of states
{ : a set of actions used for constructing guarded tran-
sitions. Let 'be'g^'a. An action can be either of
the following:
Internal Action , denoted as `:'.
Rendezvous Action , including `! :'(output) and
`? (input).
The action `or`! is enabled if 'gis evaluated to be
true and the global boolean variables will be updated
according to 'aif the action is executed. The input
action`? is enabled as long as there is an enabled ren-
dezvous action `!.
{: a subset of SS, regulating a set of guarded
transitions.Parameterized System Aparameterized system is a tu-
plehB;C1;;Cl;hU1;n1i;;hUk;nkii, denoted as P(n1
;;nk), whereCi=hSCi;Ci;Cii(1il) and
Uj=hSUj;Uj;Uji(1jk). Following the termi-
nologies of [17], C1throughClare called control processes ,
which can only be created once during each execution of
the system. The templates U1throughUk, also called user
processes , can have an arbitrary number of replications, as
indicated by n1throughnk. All the control and user pro-
cesses run in parallel synchronously and share information
through the global boolean variables of B.
Global State Aglobal state of a parameterized system has
the form of G=h;g1;g2i, where=hv1;;vniwith
vi(1in)2ftrue;falsegis an evaluation of those
boolean variables in B=fb1;;bng,g1=hs1;;sli
withsi2SCi(1il) collects the set of states of control
processes, and g2=hs11;;s1n1;sk1;;sknkiwith a
dimension<=n1++nkandsij2SUi(1ik;1
jni) represents the local states of replicated processes of
U1throughUk.
Then the operational semantics of a parameterized system
is dened as:
Operational Semantics LetG=h;s1;;sl+<i,G0=
h0;s0
1;;s0
l+<i, and=[0. Then,G` !G0, denoting
that the system transits from GtoG0through a transition
`, if and only if one of the following conditions holds:
{ if there exists iandusuch thatsi`:' !uand(') =
true, thens0
i=uands0
j=sjfor allj6=i.
{ if there exists i;j;u andvsuch thatsi`! :' !u,sj`? !v,
and(') =true, thens0
i=u,s0
j=vands0
m=smfor
allm6=i;j.
In this paper, properties of parameterized systems are
expressed in property automata , whose accepting languages
(paths leading to trap states) prescribe undesirable behav-
ior of veried systems. If there exists a path accepted by a
property automaton, which is also feasible in a parameter-
ized system, we would say that the property does not hold
in the system, otherwise it does.
Property Automata Aproperty automaton is an FSM
hS;;;FS;TSi, whereSis a nite set of
states,Fis a set of accepting states, Tis a set of trap states
andSSis a set of transitions. A label in  
has one of the following forms:
{Unsubscribed Event ,`:'g, where`is an internal action
or a communication event between `! and`?.
{Subscribed Event ,`I:'g, whereIhas a form off;i;
;j;;li;;mj;g withiandjbeing indexes
to control processes and liandmjbeing indexes to
theith replication of Uland thejth replication of Um,
respectively. This event refers to a transition in which
one of the indexed processes or replications partici-
pates. If a user process' replication is referred, we also
call it a regulated replication .
Using predicate abstraction techniques [18], representing
each boolean predicate over concrete variables with a boolean
variable, the producer-consumer problem presented in Fig.
1 can be abstracted as a nite set of automata. As shown inU1:Producer
s1
s2bFull
=
trues3
LockFull:await
!bFull =false
s4putdata
s5bEmpty0=false
s6bFull
0=trues7bFull0=false
s8LockEmpty:notify !
LockEmpty:notify!C1:LockFull
s1
s2LockFull.await?
LockFull.notify?
U2:Consumer :
s1
s2bEmpty
=
trues3LockEmpty:await
!bEmpty =false
s4getdata
s5bFull0=false
s6bEmpty
0=trues7bEmpty0=false
s8LockFull:notify !
LockFull:notify!C2:LockEmpty
s1
s2LockEmpty.await?
LockEmpty.notify?
Figure 2: Control/User Processes of the Producer-consumer Example
Fig. 2, the two automata modeling the locks LockFull and
LockEmpty correspond to the control processes of the pa-
rameterized system, while the other two automata, named
Producer and Consumer , are the user processes. The set of
global boolean variables of the system consists of bFull and
bEmpty . The property automaton, stating that a Producer
can not put extra data into the buer when it is full and a
Consumer can not withdrawn data from the buer when it
is empty, is presented in Fig. 3, in which the diamond node
represents a trap state.
s1
s2s3
s4  fbFalse0=true;
bFull0=trueg
bFull0=truebEmpty0=true
putdatagetdata
 fbFull0=false;putdatag fbEmpty0=false;getdatag
Figure 3: No getdata(putdata) operation when the
buer is empty (full)
3. OVERALL APPROACH
In this section, an overall view of our approach is pre-
sented. To start with, we rst need the following denitions:
Conguration Aconguration is a vector of the form c=
hs;ai, wheresis astate vector andais acounter vector .
A conguration can be thought of as the abstraction of
a global state of a parameterized system. Instead of enu-
merating the state of each replication of user processes, the
counter vector only records the number of replications in
each local state. As a result, two global states can not be
dierentiated if they have the same number of replications
in each local state.i-bounded Congurations A vectorv2Zmis said to be
i-bounded ifv(j)0 for all 1ji, wherev(j) represents
theith component of v. A conguration is said to be i-
bounded if its counter vector is i-bounded.
i-r-bounded Congurations A vectorv2Zmis said to
bei-r-bounded if 0v(j)<rorv(j) =!for all 1ji,
where!is greater than any integer. A conguration is said
to be i-r-bounded if its counter vector is i-r-bounded. A
non-i-r-bounded conguration is an i-bounded but not i-r-
bounded conguration.
By showing how the producer-consumer program is veri-
ed against the property given in Fig. 3, we'll demonstrate
how our approach works. The verication procedure can be
summarized as follows:
Construction of Extended Reachability Graph (ERG) :
An ERG is actually the synchronous product of the prop-
erty automaton and the parameterized system. It models
the execution of control processes and regulated replications
of a parameterized system and their execution's impact on
the property automaton, while the states of other replica-
tions of user processes are collected through counter vectors.
Because two replications of a user process exhibit the same
behavior as long as they are in the same local state, it still
ensures that the original verication problem for a param-
eterized system holds if and only if all violation states are
not reachable in the generated ERG.
Instead of directly using the complete ERG corresponding to
a verication problem, a set of increasingly rened abstrac-
tions of it,fA0;;Ai;; A= 1g, is sequentially gener-
ated. In the abstraction Ai, each conguration is only re-
quired to be i-bounded. All graphs start from the same
initial conguration hs;ai, in which all global boolean vari-
ables are initialized, all control processes and regulated repli-
cations are in their initial states, and the counter vector's
elements corresponding to initial states of user processes are
set to!. The introduction of !is to ensure that a conclu-
sion will hold irrespective the size of a parameterized sys-
tem. Then, new congurations reachable from the initial
conguration are added. The procedure continues until all
reachablei-bounded congurations have been enumerated.c1 hhs1;F;T;s 1;s1i;h!p1;!c1ii
c2hhs1;F;F;s 1;s1i;h 1p4;1p5iibEmpty0=false
c6
hhs1;F;F;s 1;s1i;h 1p4;1p7iibFull0=false
c7
hhs2;T;F;s 1;s1i;h 1p4;1p6iibFull0=true
c8
hhs1;F;F;s 2;s1i;
h 1p4;1p5; 1c6;1c8iiLockFull:notifyc3hhs1;F;T;s 1;s1i;h 1p5;1p7iibFull0=false
c9
hhs1;F;T;s 1;s1i;h 2p5;2p7iibFull0=false
c10
hhs2;T;T;s 1;s1i;
h 2p5;1p6;1p7iibFull
0=
true
c11
hhs1;F;T;s 2;s1i;h 1c6;1c8; 1p5;1p7iiLockFull:notify
c4hhs1;T;T;s 1;s1i;h 1p5;1p6iibFull
0=
true
c12
hhs4;T;T;s 1;s1i;
h 1p3;1p4; 1p5;1p6iiputdatac5
hhs1;F;T;s 2;s1i;h 1c6;1c8iiLockFull:notify
Figure 4: Extended Reachability Graph A4of the producer-consumer program
However, the abstract reachability graph obtained is nor-
mally an innite reachability graph because of the existence
of!elements in counter vectors and it prevents a direct
forward reachability analysis. We will prove that Aionly
needs to include i-Ci 1-bounded congurations to deter-
mine the cut-oCi, whereis equal to 1 or 2 (because the
parameterized systems considered in this paper contain no
broadcast actions and an element in the counter vector will
be added or decreased at most by 2 during a transition). If
a non-i-Ci 1bounded conguration is encountered during
the construction of Ai, we just simply discard it.
Inductive Calculation of Cut-os : The induction ba-
sisC0is obtained by investigating the coarsest abstraction
A0. LetC0be the length of the longest shortest paths in
A0starting from one conguration to another in which the
property automaton is in a trap state if such paths exist;
otherwise,C0= 0. As for the induction of CifromCi 1,Ci
will be set to be the length of the longest shortest paths in
Aistarting from one conguration to another in which the
property automaton is in a trap state; otherwise, Ciwill be
set to the sum of Ci 1andgi, wheregiis the length of the
longesti-Ci 1bounded path of Aiif a non-i-Ci 1bounded
conguration has been discarded during the construction of
Aiand, otherwise,Ciis equal to zero.
Termination Criteria : At most=inductions are needed,
=being the total number of local states of user processes,
andC=will be the cut-o on the maximum length of paths
needed to decide if the property automaton holds in the
veried parameterized system. The verication procedure
can also terminate prematurely: a) an intermediate cut-o
Ci(i<=) is equal to zero, indicating that no undesired be-
havior exists in the upward abstraction of the original pa-
rameterized system and thus the property does hold; b) a
counter-example found in an abstract graph Ai(i<=) is not
spurious and it is also feasible in the original parameterized
system, indicating that the property does not hold.
An example abstract ERG A4for the producer-consumer
program is presented in Fig. 4. The elements of each state
vector, in left to right order, respectively correspond to the
current state of the property automaton, the global boolean
variables,bFull andbEmpty , and the current states of the
two control processes, LockFull andLockEmpty . For thesimplicity of notations, we use the notation h;kci(pi);;
mcj(pj);ito represent a vector in which the element cor-
responding to the ith local state of Consumer (Producer )
is equal tokand the element to the jth local state is equal
tom, while all other elements are zeros. As the elements
!p1and!c1will be staying unchanged in the whole reach-
ability graph, they are not explicitly specied other than in
the initial conguration.
It should be noted that a dierent abstract reachability
graph might be generated if the mapping from elements of
counter vectors to local states of user processes is changed.
For example, the conguration c3will not be 4-bounded if
the states5ofConsumer is mapped on an element whose
position index is less than 5, while it is under our current
default mapping in which the rst four elements are mapped
on the local states s2,s1,s7, ands8ofProducer from left
to right. In this paper, a randomly selected mapping is
used and the research on heuristically selecting an optimal
mapping for a verication problem is out of the scope of
this paper. In addition, we can conclude the cut-o C4of
the producer-consumer program is 2, as there is a path with
a length of 2 leading to a trap state.
4. DETAILED METHODOLOGIES
In this section, the procedure to construct an ERG from
a parameterized system is given. More importantly, sev-
eral theorems supporting every step of our approach and
their sketch proofs are provided1. Before doing that, we rst
present two simple concepts. A path is said to be i-bounded
if each conguration in it is i-bounded. An i-bounded path
is said to be i-looped (i-loop-free) if there are (no) two con-
gurations in it such that their state vectors are the same
and the rst ielements of their counter vectors are com-
ponentwise equal. Similar concepts can also be dened for
i-r-bounded congurations and paths.
Construction of ERG . Given a parameterized system
P=hB;C1;;Cl;hU1;n1i;;hUk;nkiiand a property
automaton =hS;;;F;Ticharacterizing the correct-
ness of the parameterized system. We assume that the au-
tomaton refers to a set of regulated replications that are
1Detailed proofs, further details about the experiment sys-
tems and raw data given in the next section can be seen
from http://itechs.iscas.ac.cn/qiusongyang/fbra.htmsequentially generated from user processes fUr1;;Urhg.
Ani-bounded (or i-r-bounded) ERG, is a directed graph
hV;Eisuch that:
{V: a set of congurations. Each conguration c2V
has the form ofhs;ai, wheres2SBSC1
SClSUr1SUrhcollects the current states of
the property automaton, control processes and regu-
lated replications and stores the evaluation of all global
boolean variables, and the counter vector acollects
states of non-regulated replications of user processes.
{EVV. LetC=hhs;;s 1;;sl+hi;aibe
ani-bounded ( i-r-bounded) conguration which has
already been added to the graph, C0=hhs0
;0;s0
1;
;s0
l+hi;a0i, and=[0.C` !C0, denoting that
the combination of the property automaton and the
parameter system transits from CtoC0by executing
a transition `, if and only if the appending of C0does
not form an i-looped path, and:
`:'is an internal action executed by a control
process or a regulated replication and there exists
iandusuch thatsiu !uand(') =true,
thens0
i=u,a0=a,s0
j=sjfor allj6=i, and
s0
=(s;`). Assumeis a total automaton.
`:'is an internal action executed by an unregu-
lated replication and there exists sm`:' !sn2Uv
whereUv(1vk) is a user process, (') =
true, and the sum of aandh 1sm;1sniisi-bounded
(i-r-bounded), then s0
i=sifor all 1il+h,
a0=a+h 1sm;1sni, ands0
=(s;`).
`is the communication between si`!:' !uand
sj`? !v, which are executed by a control pro-
cess and a regulated replication, respectively, and
(') =true, thens0
i=u,s0
j=v,a0=a,
s0
=(s;l) ands0
m=smfor allm6=i;j.
`is the communication between si`!:' !u, a tran-
sition executed by a control process or a regu-
lated replication, and sm`? !sn, a transition ex-
ecuted by a user process Uv, the sum of aand
h 1sm;1sniisi-bounded (i-r-bounded), and (')
=true, thens0
i=u,a0=a+h 1sm;1sni,s0
=
(s;l), ands0
j=sjfor allj6=i.
`is the communication between sm`!:' !sn, a
transition executed by a user process Uv, and
sx`? !sy, a transition executed by a user pro-
cessUz, the vector a+h 1sm;1sni+h 1sx;1syiis
i-bounded (i-r-bounded), and (') =true, then
s0
i=sifor all 1il+h,a0=a+h 1sm;1sni+
h 1sx;1syi, ands0
=(s;l).
During the construction of an ERG, it might be the case that
there is a self-loop transition in some user process such that
smandsnin a transition sm`!snrefer to the same local
state. As demonstrated in [17], we can insert intermediate
congurations to address the issue. For an i-bounded ERG,
a path of it is called a path with a trap state if the path is
ended with a conguration in which the property automaton
is in a trap state.
Then, we have the following theorems for the constructed
ERGs:Theorem 1.A property automaton holds in a parame-
terized system if and only if there are no paths with a trap
state in the corresponding =-bounded ERG.
The theorem holds because an =-bounded ERG precisely
models the behavior of the property automaton, control pro-
cesses and regulated replications. It's unnecessary to dier-
entiate one non-regulated replication from another as they
exhibit the same behavior if they are in the same local state
and thus their states can be collected using counter vectors.
LetGbe a conguration of Aiandmin(G;i) denote the
length of the shortest i-bounded path with a trap state in
Aistarting from G, if at least one such path exists; other-
wise, dene min(G;i) = 0.Ci=maxfmin(G;i)jG2Aig
is dened as the length of the longest shortest i-bounded
paths with a trap state starting from congurations of Aiif
such paths exist, otherwise dene Ci= 0. The next theorem
states howCiis calculated through inductions. Its proof is
similar to the one given in [21] to prove the decidability of
covering problems for vector addition systems.
Theorem 2.Ci+1R (2Ci)i+1+Cifor0i<=, where
R=jSjjSC1jjSCljjSUr1jjSUrhjis the product of
the size of the individual automata.
Proof. Assume that there is an ( i+ 1)-bounded path
with a trap state in the ( i+ 1)-bounded ERG (otherwise,
Ci+1= 0).
Case 1 : There is an ( i+ 1)-2Ci-bounded path with a trap
state. Then there must be an ( i+1)-2Ci-bounded path with
a trap state and the path is also ( i+ 1)-loop-free. It is
obvious that the path's length must be R (2Ci)i+1.
Case 2 : Otherwise. Then there is an ( i+ 1)-bounded
path with a trap state which is not ( i+ 1)-2Ci-bounded.
The path can be re-presented as p1p2such thatp1is (i+ 1)-
2Ci-bounded and p2begins with a conguration c=hs;ai
which is not ( i+1)-2Ci-bounded. Without loss of generality,
we assume that a(i+ 1)2Ci. From case 1, we can choose
p1to be of lengthR (2Ci)i+1.
Sincep2is ani-bounded path with a trap state, we know
that there exists a path p0
2of length Ciwhich is also
ani-bounded path with a trap state and starting with s.
Note that all the entries in a state's counter vector will be
increased or decreased less than or equal to 2 in each tran-
sition. We can conclude that p0
2is a (i+ 1)-bounded path
with a trap state. Hence, p1p0
2is an (i+ 1)-bounded path
with a trap state of length R (2Ci)i+1+Ci.
Based on Theorem 2, it is rather straightforward to con-
struct an algorithm for a cut-o based reachability analy-
sis of parameterized systems. We only need to check those
paths with a length  C=to decide if a property holds.
However,C=might be an astronomical gure if we simply
use Theorem 2. For the example verication problem pre-
sented in Fig. 2, we will get C0= 2,C166,C2278848,
C32:7751018, . To further improve verication
eciency, the following lemma holds:
Lemma 1.If there are no paths with a trap state in the
(i+ 1) -2Ci-bounded ERG and no (i+ 1) -bounded but non-
(i+1)-2Cibounded congurations have been discarded during
the construction, then Ci+1= 0.
Lemma 2.If non- (i+ 1) -2Cibounded congurations are
discarded during the construction of the (i+ 1)-2Ci-boundedTable 1: List of Example Problems Used in the Experiments.
Index Systems  jjCjCjUjUj=
P1 Bin Example Inverse Dependency (F) 24 Control 6 User 9 4
P2 Loop Example Looped Dependency (F) 32 Control 4 User 7 4
P3 Simple Protocol Mutual Exclusive (T) 36 Server 9 Client 10 5
P4 No Orphan Packets (T) 20
P5 Full Put (F) 15
P6 Producer& Empty Get (F) 18 LockFull 4 Producer 17
P7 Consumer Produce First(T) 18 LockEmpty 4 Consumer 17 16
P8 Empty Get and Full Put (F) 34
P9 Gas Station Start Pumping First (T) 19 Pump 1 12 Client 23 11
P10 Start Pumping First (T) 52 Pump 2 12
ERG,Ci+1will be less than or equal to the length of the
longest shortest i-bounded paths with a trap state if such
paths exist; otherwise, Ci+1Ci+gi+1, wheregi+1the length
of the longest path of the (i+ 1)-2Ci-bounded ERG.
The correctness of the rst lemma is rather obvious. In
Theorem 2's proof, the length of the longest ( i+ 1)-2Ci-
bounded path is bounded by R(2Ci)i+1, while Lemma 2 uses
a rather smaller bound gi+1obtained through investigating
the verication problem itself. From these two Lemmas, we
have the following theorem:
Theorem 3.To inductively calculate Ci+1fromCi, only
a nite (i+ 1)-2Ci- bounded ERG is needed.
We also have two theorems supporting the premature ter-
mination of the inductive process, making the calculation of
the nal cut-oC=unnecessary:
Theorem 4.IfCi= 0 for any 1i <=, then there
will be noj-bounded paths with a trap state in the j-bounded
ERG for any jsuch thati < j= and the property does
hold.
Theorem 5.For a path with a trap state of the (i+ 1)-
2Ci-bounded ERG, it will be a concrete counter-example in
the original parameterized system if each conguration in the
path is=-bounded and the property does not hold.
In addition, we can construct an ( i+ 1)-Ci-bounded ERG
instead of an ( i+ 1)-2Ci-bounded one if no complementary
actions are simultaneously enabled in a state of user pro-
cesses as it is impossible for an element in the counter vector
to be decreased by 2 during a transition.
5. EXPERIMENTAL RESULTS
The systems used in the following experiments are listed
in Table 1. For each example problem, the details, such as
the control processes and user processes of a parameterized
system, the property to be veried, and their sizes are pre-
sented. Here, the size of an FSA is the sum of the number
of states and transitions. The indicator \ T" or \F" shows
whether or not the property actually holds in the system
being veried. The last column, =, gives the total number
of local states of all user processes.
Our algorithm, called Forward Bounded Reachability Anal-
ysis (FBRA) , and existing typical algorithms for verication
of parameterized systems are implemented in JAVA. Each
data sample collected during the experiments consists of ex-
ecution time, size of memory space needed to store the globalstates reached during the verication and some peculiar data
to each algorithm. The algorithms were run on a HP lap-
top with a Dual P8400@2.26GHz CPU and 1GB of memory
running Windows XP.
5.1 Results of FBRA
We tested the algorithm FBRA on the example problems
listed in Table 1. For the reason of limited space, the induc-
tions to calculate cut-os for some typical example problems
are given in Table 2 (complete results are presented in the
web page given in footnote 1). The boolean variable B1i
is true if an i-bounded path with a trap state is encoun-
tered during the ith induction, while B2iis true when some
i-bounded but not i-Ci 1-bounded nodes are encountered
during the ith induction. The cut-o for each induction is
listed inCiand the number of states visited during each in-
duction is recorded in Si. FBRA's average execution time
on each example problem is given in the last column.
From Table 2, we can rst observe that Theorem 4 can
improve verication eciency dramatically by avoiding use-
less inductions for certain problems. As for the problems P4,
P9andP10, the FBRA algorithm draws a conclusive conclu-
sion that the property holds in the veried parameterized
system after the rst induction because C0is equal to zero.
In the problems P2andP5, a concrete counter-example is
found during an intermediate induction and the whole de-
cision procedure also terminates prematurely as a result of
Theorem 5.
Secondly, the variable B2iis remarkably similar to the
evaluation function in branch and bound search algorithms.
If ani-bounded but not i-Ci 1-bounded node is encoun-
tered during the ith induction, then B2ibeing set to true,
the branch rooted with the node will be discarded for further
exploration to nd an i-bounded path with a trap state. If
B2i=true for some 1i=, it also indicates that the
state space explored in the ith induction is reduced because
of the introduction of Ci 1, as shown in P1;P2andP3.
Thirdly, assume that the algorithm FBRA does not ter-
minate after the=th induction, as shown in P1andP3. The
(=+1)th induction, in which the original parameterized sys-
tem instead of one of its abstractions is used, is going to be
executed to calculate C=. IfC=is equal to zero, we can
claim that the property does hold. Otherwise, a counter-
example whose length is not greater than C=may exist in
the parameterized system. If being lucky enough, we might
encounter such one counter-example during the calculation
ofC=, in the case of P1, and the (=+ 2)th induction will
be completely unnecessary. Otherwise, all the paths withTable 2: Experimental Results of FBRA
IndexB1B2CS T(ms) IndexB1B2CS T(ms)
P1i= 0 T F 5 4 31.6P2i= 0 T F 7 8 57
i= 1 T F 5 10 i= 1 T F 7 21
i= 2 T F 5 10 i= 2 T F 7 21
i= 3 T F 5 15 i= 3 T T 228
i= 4 T T 62 P4i=0 F F 0 20 15.3
P3i= 0 T F 9 26 88.7P5i= 0 T F 3 7 47
i= 1 T F 9 20 i= 1 T F 3 7
i= 2 T F 9 20 i= 2 T F 3 7
i= 3 T F 9 21 i= 3 T F 3 12
i= 4 T F 9 23 i= 4 T F 3 12
i= 5 F T 86 238 i= 5 T T 5 20
i= 6 F F 278 i= 6 T F 5 21
P9i= 0 F F 0 60 16 i= 7 T F 7 75
F10i= 0 F F 0525 156 i= 8 T F 12 93
a lengthC=are needed to be checked to decide if a real
counter-example does exist, as shown in P3.
5.2 FBRA vs. others
Although cut-o approaches are presented in [11], [4], [3],
[17] and [12], those results highly depend on some unique
characteristics of verication problems, such as ring or net-
work topologies of processes, process symmetry, indexed logic
without the next operator. As a dierent combination of
parameterized systems and property specication is used in
this paper, it prevents the direct comparison of our approach
with existing cut-o approaches. To demonstrate the eec-
tiveness of our approach, we made a comparison between the
algorithm FBRA and typical existing algorithms for verica-
tion of parameterized systems, albeit they are not based on
cut-os. We implemented the Forward Reachability Analy-
sis (FRAKM) algorithm proposed by R.M. Karp and R.E.
Miller [19], a variant of FRAKM proposed by E.A. Emerson
and K.S. Namjoshi [13], named FRAEN, and the Backward
Reachability Analysis (BRA) algorithm proposed by P.A.
Abdulla et al. [1] (FRAEN and BRA are also both used
by J. Esparza et al. in [14]). In the literature, a lot of
algorithms have been derived from these three basic ones
to verify parameterized systems or other systems with an
innite state space.
In these algorithms, the concept of quasi-order , a binary
relationship (i.e. reexive and transitive) on the set of global
states, plays a critical part in constructing a nite reacha-
bility graph. A conguration c=hs;aiis said to be the
pre-order of another conguration c0=hs0;a0i, denoted as
cc0, ifs=s0andaa0. Letdandd0be two con-
gurations that have been added to a partially generated
reachability graph. Let ebe a new conguration backward
or forward reachable from d, but not from d0. The strategies
adopted by those algorithms to decide if the new congura-
tion is added to the existing partial reachability graph are
dierent from one another. They are summarized in Table
3, where each symbol _denotes that the algorithm in the
same row uses the rule in the same column to compact the
state space and each symbol does not. In the algorithm
BRA, the new conguration edoes not need to be explic-
itly represented if de,d0e,d=e, ord0=e. The
new conguration ewill be replaced by a corresponding !-
conguration if deord=ein the algorithm FRAKM.The algorithm FRAEN extends FRAKM by introducing an
extra rule that the new conguration eis discarded and a
new edge from e's predecessor to d0is added ifed0.
Table 3: Strategies for Discarding New States
Algorithms ded0eed0d=ed0=e
BRA____
FRAKM__
FRAEN____
FBRA__
We have implemented the above algorithms and tested
them on the example problems listed in Table 1. The re-
sults are presented in Table 4. To ease the comparison be-
tween the algorithm FBRA and the others, the FBRA's ex-
perimental results are repeated there. In summary, FBRA
outperforms BRA in P3;P4;P5;P7;P8andP10, BRA per-
forms better in P1,P2andP6, and they are matched up in
P9. FBRA outperforms FRAKM in all example problems
except forP3andP4.
Although FBRA outperforms other algorithms in many of
the example problems, its time and space eciency is rel-
atively lower in P1andP2than BRA, in P1andP3than
FRAKM, in P1;P2;P3andP10than FRAEN. The ine-
ciency of FBRA results from the enumeration of all the
states of ERGs. However, the loss of information resulted
from the introduction of !-congurations in FRAEN makes
it very dicult to eciently construct a counter-example
from the compacted reachability graph or to estimate a cut-
o of the length of i-Ci-bounded paths with a trap state
in the (i+ 1)th induction, the core of FBRA. It remains
an open problem to use the strategies adopted by other for-
ward reachability analysis algorithms, such as FRAKM and
FRAEN, to improve FBRA's eciency further.
6. RELATED WORK
To counter the state explosion problem in which the num-
ber of states of a reachability graph may grow exponen-
tially with the number of processes, some approaches are
presented in [5][6][22][20] to reduce an innite set of veri-
cation problems, a verication problem for a system with a
certain size, to a single problem. Typically in [5], the reduc-
tion is based on the collapse theorem stating that, for allTable 4: Comparison of FBRA, BRA, FRAKM, FRAEN
Index FBRA BRA FRAKM FRAEN
States Time(ms) States Time(ms) States Time(ms) States Time(ms)
P1 62 31.7 15 26.3 186 36.3 17 26
P2 228 57 46 20.7 2640 141 26 21
P3 278 88.7 886 214 14 26 13 20.7
P4 19 15.3 77 31 14 15.7 13 15.7
P5 93 47 402 286.7 Out of Memory 70468 22 57.7
P6 744 989.7 402 796.3 Out of Memory 68125 23 62
P7 2 20.7 802 57.3 5 26 2 16
P8 93 46.7 802 1849 Out of Memory 708434 22 47
P9 60 16 42 15.7 Out of Memory 32915 37 15.7
P10 525 156 1114 401 Out of Memory 31373 100 20.7
kr,MkandMrwill be ICTL-equivalent if MrPand
Mr+1Pare equivalent, where Mkis a system of kidenti-
cal nite state processes and Pis a closure of the identical
processP. However, these approaches are only partially au-
tomated, requiring human ingenuity to construct a closure
process or process invariant [12].
A decision procedure for verication of LTL properties
of single processes, i.e. speaking either about the control
process or a user process, is given in [17] based on a cut-
o on the length of paths to be considered. In essence, the
decision procedure reduces such a verication problem to a
boundness problem of vector addition systems (VASs) [21].
The problem with the approach is that the existence of a
cut-o in theory is enough to prove the decidability of the
decision problem. However, the procedure for calculating
the cut-o is notoriously complicated and it is denitely too
large to be helpful for reducing the state space to be explored
for a verication problem.
In [12], systems formed by a synchronous parallel compo-
sition of a single control process with an arbitrary number
of identical user processes are considered. The correctness
of properties are expressed in an indexed temporal logic and
dened over the control process, all user processes or every
distinct pair of processes. The decision procedure is based
on constructing an abstract graph in which one only distin-
guishes whether none or at least one process is at a certain
control location. The abstraction graph may have bad paths
that do not correspond to computation of any size instance.
The core of the algorithm is to nd an accepting good path
in the graph. The termination of the algorithm is guaran-
teed by the existence of a cut-o on the length of paths to be
explored. Similarly to [17], the cut-o is only a conservative
upper bound to prove the algorithm's decidability and the
cut-o itself does not directly contribute to the improvement
of verication eciency.
Instead of a cut-o on the length of paths to be explored,
a cut-o on the number of instances of the user process
is calculated in [11]. In the paper, asynchronous systems
comprised of an arbitrary number of homogeneous copies
of a generic process template are considered and correct-
ness properties are expressed using indexed CTL* nX. Then
model checking for systems of arbitrary size nis reduced
to model checking for systems of size up to a small cut-o
sizec. Although we have not directly compared it with our
algorithm, the state space with the given cut-o number of
processes has to be generated and explored which is usually
exponential in the number of processes.Parameterized systems dened in this paper can also be
modeled as Petri nets. To counter the explosion caused
by the high dimensionality of practical Petri nets, those
places (correspond to local states of user processes) which
are thought of being not important are discarded to con-
struct an abstraction in [16]. If the abstraction is too coarse,
an automatic renement is performed and a more precise
abstraction is obtained. The process is iterated until the
property is proved to be true or false. However, only partial
space of each abstraction is explored in our method because
of the cut-oCiand the iterative process can be terminated
whenCi= 0 for some 0i=.
7. CONCLUSION AND DISCUSSIONS
In this paper, a novel approach is proposed for the veri-
cation of parameterized systems based on cut-os on the
maximum length of paths needed to be explored. Given a
parameterized system and a property automaton stating a
set of undesirable behavior of the system, a cut-o on the
maximum length of paths to decide if the property holds
is determined through an inductive procedure. In each in-
duction, only a nite abstract reachability graph is needed
and thus the verication of a parameterized system with an
innite state space is turned into a series of verications of
nite state systems. The existence of a cut-o on the maxi-
mum length of paths allows for a direct forward reachability
analysis of parameterized systems, otherwise a compacted
nite reachability graph has to be constructed rst, and
it is rather straightforward to construct a counter-example
when a property does not hold. Experimental results show
that the algorithm outperforms typical forward and back-
ward reachability analysis algorithms in many of the exam-
ple problems.
In the denition of property automata, only behavior of
indexed user processes is considered. Actually, they can be
extended to safety properties, such as global deadlock free
properties. One way is to use property automata to describe
all possible "bad" sequences of resource acquire/release op-
erations. An alternative one is to convert a deadlock free
property as it is guaranteed that at least one of the state
transitions is always enabled. As future work, our approach
can be extended to liveness properties in B uchi Automata,
although calculating Ci+1fromCiwill become much more
complicated.
In addition, there is an implicit ordering on the local states
of user processes in this paper. As discussed previously, adierent (i+ 1)-Ci-bounded ERG might be generated if a
dierent ordering is used. As a result, the ordering of visiting
congurations during each induction will be changed. It
might be possible to heuristically nd an optimal ordering
leading to better experimental results.
Acknowledgements
The work was partially done during the rst author's visit
to the Laboratory for Advanced Software Engineering Re-
search (LASER) in the Department of Computer Science at
the University of Massachusetts Amherst. The work was
inspired by a conjecture proposed by Prof. Leon J. Oster-
weil, stating that the number of instances of user processes
is bounded for certain types of verication problems and the
bound is a function of the attributes of the system and the
property to be veried. Prof. Lori A. Clarke gave a lot of
valuable comments on how to make the presentation more
accurate and clearer. The discussions with Prof. George S.
Avrunin were also greatly helpful. The authors wish thank
anonymous reviewers for their valuable contributions and
comments.
The work was partially supported by the National Natural
Science Foundation of China under grant Nos. 60903051 and
90718042, the Hi-Tech Research and Development Program
of China under grant No. 2007AA010303, the 973 program
under grant No. 2007CB310802, as well as the Knowledge
Innovation Program of the Chinese Academy of Sciences un-
der grant No. ISCAS2009-DR09.
8. REFERENCES
[1] P. A. Abdulla, K. Cerans, B. Jonsson, and Y.-K. Tsay.
General decidability theorems for innite-state
systems. In LICS '96: Proc. of the 11th Annual IEEE
Symposium on Logic in Computer Science , page 313,
Washington, DC, USA, 1996. IEEE Computer Society.
[2] K. R. Apt and D. C. Kozen. Limits for automatic
verication of nite-state concurrent systems. Inf.
Process. Lett. , 22(6):307{309, 1986.
[3] A. Bouajjani, P. Habermehl, and T. Vojnar.
Verication of parametric concurrent systems with
prioritised fo resource management. Form. Methods
Syst. Des. , 32(2):129{172, 2008.
[4] E. Clarke, M. Talupur, T. Touili, and H. Veith.
Verication by network decomposition. volume 3170 of
LNCS , pages 276{291. Springer Berlin/Heidelberg,
2004.
[5] E. M. Clarke and O. Grumberg. Avoiding the state
explosion problem in temporal logic model checking.
InPODC '87: Proc. of the sixth annual ACM
Symposium on Principles of distributed computing ,
pages 294{303, New York, NY, USA, 1987. ACM.
[6] E. M. Clarke, O. Grumberg, and M. C. Browne.
Reasoning about networks with many identical
nite-state processes. In PODC '86: Proc. of the fth
annual ACM symposium on Principles of distributed
computing , pages 240{248, New York, NY, USA, 1986.
ACM.
[7] J. C. Corbett. Constructing compact models of
concurrent java programs. In ISSTA '98: Proc. of the
1998 ACM SIGSOFT Inter. symposium on Software
testing and analysis , pages 1{10, New York, NY, USA,
1998. ACM.[8] G. Delzanno. Constraint-based model checking for
parameterized synchronous systems. In FroCoS '02:
Proc. of the 4th Inter. Workshop on Frontiers of
Combining Systems , pages 72{86, London, UK, 2002.
Springer-Verlag.
[9] G. Delzanno and J.-F. Raskin. Symbolic
representation of upward-closed sets. In TACAS '00:
Proc. of the 6th Inter. Conf. on Tools and Algorithms
for Construction and Analysis of Systems , pages
426{440, London, UK, 2000. Springer-Verlag.
[10] G. Delzanno, J.-F. Raskin, and L. V. Begin. Towards
the automated verication of multithreaded java
programs. In TACAS '02: Proc. of the 8th Inter.
Conf. on Tools and Algorithms for the Construction
and Analysis of Systems , pages 173{187, London, UK,
2002. Springer-Verlag.
[11] E. A. Emerson and V. Kahlon. Reducing model
checking of the many to the few. In CADE-17: Proc.
of the 17th Inter. Conf. on Automated Deduction ,
pages 236{254, London, UK, 2000. Springer-Verlag.
[12] E. A. Emerson and K. S. Namjoshi. Automatic
verication of parameterized synchronous systems
(extended abstract). In CAV '96: Proc. of the 8th
Inter. Conf. on Computer Aided Verication , pages
87{98, London, UK, 1996. Springer-Verlag.
[13] E. A. Emerson and K. S. Namjoshi. On model
checking for non-deterministic innite-state systems.
InLogic in Computer Science , pages 70{80, 1998.
[14] J. Esparza, A. Finkel, and R. Mayr. On the
verication of broadcast protocols. In LICS '99: Proc.
of the 14th Annual IEEE Symposium on Logic in
Computer Science , page 352, Washington, DC, USA,
1999. IEEE Computer Society.
[15] A. Finkel and P. Schnoebelen. Well-structured
transition systems everywhere! Theor. Comput. Sci. ,
256(1-2):63{92, 2001.
[16] P. Ganty, J.-F. Raskin, and L. Van Begin. From many
places to few: Automatic abstraction renement for
petri nets. Fundam. Inf. , 88(3):275{305, 2008.
[17] S. M. German and A. P. Sistla. Reasoning about
systems with many processes. J. ACM , 39(3):675{735,
1992.
[18] S. Graf and H. Sa di. Construction of abstract state
graphs with pvs. In CAV '97: Proc. of the 9th Inter.
Conf. on Computer Aided Verication , pages 72{83,
London, UK, 1997. Springer-Verlag.
[19] R. M. Karp and R. E. Miller. Parallel program
schemata. Journal of Computer and System Sciences ,
3:147{195, 1969.
[20] R. P. Kurshan and K. McMillan. A structural
induction theorem for processes. In PODC '89: Proc.
of the eighth annual ACM Symposium on Principles of
distributed computing , pages 239{247, New York, NY,
USA, 1989. ACM.
[21] C. Racko. The covering and boundedness problems
for vector addition systems. Theor. Comput. Sci. ,
6:223{231, 1978.
[22] P. Wolper and V. Lovinfosse. Verifying properties of
large sets of processes with network invariants. In
Proc. of the Inter. workshop on Automatic verication
methods for nite state systems , pages 68{80, New
York, NY, USA, 1990. Springer-Verlag New York, Inc.
View publication stats