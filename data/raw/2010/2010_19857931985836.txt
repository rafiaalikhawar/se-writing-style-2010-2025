Frequency and Risks of Changes to Clones
Nils Göde
University of Bremen
Bremen, Germany
nils@informatik.uni-bremen.deRainer Koschke
University of Bremen
Bremen, Germany
koschke@informatik.uni-bremen.de
ABSTRACT
Code Clones—duplicated source fragments—are said to in-
crease maintenance eﬀort and to facilitate problems caused
by inconsistent changes to identical parts. While this is cer-
tainly true for some clones and certainly not true for others,
it is unclear how many clones are real threats to the system’s
quality and need to be taken care of. Our analysis of clone
evolution in mature software projects shows that most clones
are rarely changed and the number of unintentional incon-
sistent changes to clones is small. We thus have to carefully
select the clones to be managed to avoid unnecessary eﬀort
managing clones with no risk potential.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance,
and Enhancement— restructuring, reverse engineering, and
reengineering
General Terms
Experimentation, Measurement
Keywords
Software maintenance, clone detection, clone evolution
1. INTRODUCTION
Code clones are similar fragments of source code. There
are many problems caused by the presences of clones. Among
others, the source code becomes larger, change eﬀort in-
creases, and change propagation bears the risk of unwanted
inconsistencies—for example, incomplete removal of defects.
Consequently, a variety of clone detection techniques and
tools has evolved to identify duplicated source code within
a system. In addition, various tools have been created that
support developers in managing clones. These include refac-
toring support [4, 12], automated change propagation [6, 33],
and change monitoring to prevent unintentional inconsisten-
cies [30].
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’11, May 21–28, 2011, Honolulu, Hawaii, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00.There certainly exist clones that are true threats to soft-
ware maintenance. Nevertheless, recent research [19, 20]
doubts the harmfulness of clones in general and lists nu-
merous situations in which clones are a reasonable design
decision. From the clone management perspective, it is de-
sirable to detect and manage only the harmful clones, be-
cause managing clones that have no negative eﬀects creates
only additional eﬀort.
Unfortunately, state-of-the-art clone tools detect and clas-
sify clones based only on similar structures in the source
code or one of its various representations. When it comes to
clone-related problems, however, the most important char-
acteristic of a clone is its change behavior and not its struc-
ture. Only if a clone changes, it causes additional change
eﬀort. Only if a clone changes, unintentional inconsistencies
can arise. If, on the other hand, a clone never changes, there
are no additional costs induced by propagating changes and
there is no risk of unwanted inconsistencies.
Our hypothesis is that many clones detected by state-of-
the-art tools are “structurally interesting” but irrelevant to
software maintenance because they never change during their
lifetime.
Up-to-date clone detectors can eﬃciently process and de-
tect clones within huge amounts of source code, consequently
delivering huge numbers of clones. In contrast, clone assess-
ment and deciding how to proceed can be very costly even for
individual clones as we have experienced with clones in our
own code [11]. Hence, having many unproblematic clones in
the detection results creates enormous overhead for assess-
ing and managing clones that do not threaten maintenance
because they never change.
To gain a better understanding of clones’ threat potential,
we conducted an extensive study on clone evolution in dif-
ferent systems and performed a detailed tracking to detect
when and how clones had been changed. For this study, we
concentrated on two prominent clone-related problems—the
additional change eﬀort caused by clones and the risk of un-
intentional inconsistent changes. Our research questions are
the following:
Question 1 — How often are clones changed
throughout their lifetime?
Question 2 — How many changes to clones are
unintentionally inconsistent?
Contribution. The contribution of our work is a detailed
analysis of how individual clones were changed throughout
their lifetime. This includes the frequency of changes andPermission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’11, May 21–28, 2011, Waikiki, Honolulu, HI, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00
311
the risk of unintentional inconsistencies. We provide an eval-
uation of the threat potential of clones detected by a state-
of-the-art tool.
Outline. The structure of this papers is as follows. Sec-
tion 2 introduces important terminology and concepts. Re-
lated work is given in Section 3. Section 4 describes our
technique to extract the necessary clone evolution data. The
setup of our study is outlined in Section 5. The data we
collected and our results are presented in Section 6. We dis-
cuss our results in Section 7. Our conclusions are provided
in Section 8.
2. TERMINOLOGY
In this section, we introduce relevant terminology. Clone
detection, representation, and analysis can be done on dif-
ferent abstractions of a system, each of which has advan-
tages and disadvantages. Approaches may be based on text
[7, 15], tokens [9, 18], abstract syntax trees [5, 13], graphs
[21, 23], or metrics [28]. We use a token-based approach
that treats the system’s ﬁles as sequences of tokens. Token-
based approaches are language independent—except for the
lexer that translates source text into a sequence of tokens—
and scalable while maintaining a basic understanding of the
program’s structure.
Afragment is a contiguous section of source code. As
such, a fragment has a well-deﬁned start and end and is
contained in exactly one ﬁle in exactly one version of the
system. A fragment has an arbitrary number of ancestors
which are its occurrences in the previous version of the sys-
tem. Each fragment has zero or one descendant which is its
occurrence in the next version of the system.
Aclone pair relates two fragments that are similar to each
other and are contained in the same version of the system.
The degree of similarity is expressed by diﬀerent types:
Type 1. The token sequences of both fragments are iden-
tical disregarding whitespace and comments.
Type 2. A type-1 clone pair, but values of identiﬁers and
literals may diﬀer.
Type 3. A type-2 clone pair with gaps, that is, some
tokens exist in only one of the fragments.
In contrast to a clone pair, a clone class groups two or
more similar fragments. Like a clone pair, we assign one of
the three types to a clone class to describe the similarity
between its fragments. Regarding type-3 clone classes, it
is important that the clone-class relation is not transitive—
fragment abeing similar to bandbbeing similar to cdoes
not imply that ais similar to b. Details on how we construct
type-3 clone classes are given in Section 4.2.
Cloned fragments and the relations between them can be
represented as a hypergraph, where fragments are vertices,
the clone-class relation are hyperedges connecting two or
more fragments of the same version, and the ancestor rela-
tion are normal edges connecting two fragments from sub-
sequent versions. Let this be the clone evolution graph .
Figure 1 shows our visualization of a sample graph. Each
horizontal layer represents a version of the system. Cloned
fragments—the vertices—are represented as circles. Rectan-
gles are clone classes (hyperedges) containing the respective
fragments. A shaded rectangle indicates that the fragments
of the clone class have been changed between this version
(where the clone class is shaded) to the next. A light shade
indicates a consistent change, that is, exactly the same mod-
iﬁcations have been applied to each fragment of the clone
v4v3v1
v2
cf= 2 cf= 0 cf= 3 cf= 1
Figure 1: Example of an evolution graph
class. A dark shade indicates an inconsistent change, that
is, at least one fragment has been changed, but not all frag-
ments have been changed in the same way. Fragments are
connected to their ancestors and descendants by lines (nor-
mal edges).
Aclone genealogy is a connected component in the clone
evolution graph. As such, it is a set of classes all of which are
connected by the ancestry of their fragments. For example,
the graph in Figure 1 shows four clone genealogies.
3. RELATED WORK
This section presents previous research related to ours re-
garding the impact of clones on maintainability. For a gen-
eral overview of research on software clones please refer to
[22, 31]. Previous work can be roughly classiﬁed into two
categories. First, studies targeted at clone evolution and
the ways in which clones change. Second, studies analyzing
the harmfulness of clones.
3.1 Clone Evolution
One of the ﬁrst studies on clone evolution has been con-
ducted by Kim and her colleagues [20]. They analyzed the
lifetime, occurrence of consistent changes, and suitability for
refactoring of clone genealogies in two small Java systems.
Although their study has been a major inspiration, our work
diﬀers in the way that we use a more detailed clone tracking
(based on individual fragments) and we analyze changes for
individual genealogies in more detail.
Aversano and her colleagues [1] extended Kim’s study
with focus on the consistency of changes. They inspected
individual changes and classiﬁed them according to whether
clones evolved independently or were unknowingly changed
inconsistently. In contrast to our study, they inspected in-
dividual changes not considering repeated changes to the
same clones. Furthermore, clones that never changed were
not considered.
Bakota and colleagues [3] analyzed change anomalies in
the evolution of clones. They map individual fragments in-
stead of clones classes between versions. In their case study,
they found 60 anomalies in the evolution of Mozilla Firefox
of which six have been classiﬁed as true defects. The change
frequency of clones has not been investigated.
The consistency of changes to clones has been quantita-
tively investigated by Krinke [24]. Analyzing changes to
clones in ﬁve diﬀerent systems, he found that the number
of consistent changes and inconsistent changes are roughly
the same. Clones that never change, repeated changes to312the same clones, and harmfulness of changes have not been
analyzed.
In one of our previous studies [8] we analyzed clone evo-
lution in nine diﬀerent systems. Although we performed a
quantitative comparison of change consistency, we did nei-
ther analyze the frequency of changes for individual clones
nor evaluate the harmfulness of changes.
Thummalapenta and colleagues [32] analyzed change pat-
terns in the evolution of code clones. They found that most
clones were consistently changed or deliberately evolved in-
dependently. Hence, most inconsistent changes were inten-
tional. The change frequency of clones has not been consid-
ered.
While changes to clones have been analyzed in various
studies, the clones that never change have been neglected.
Furthermore, repeated changes of the same clone have not
been analyzed so far.
3.2 Harmfulness of Clones
While it is frequently stated that clones negatively aﬀect
software maintenance, there is not much proof that they
really do. Regarding the problem of clones increasing the
eﬀort to change the code, there is hardly any work to quan-
tify the additional eﬀort. While it is not known how much
additional change eﬀort is caused by clones and how many
clones are responsible for this, previous studies [1, 8, 20, 24,
32] have shown that some additional eﬀort must exists, since
numerous consistent changes to clones have been detected.
Lozano and her colleagues [27] analyzed whether functions
change more often when having clones. Their initial results
suggest that functions change more often when they have
clones compared to when they do not have clones. Never-
theless, the following study by Lozano and Wermelinger [26]
showed that change eﬀort did not increase for more than half
of the methods despite having clones. Only recently, Juer-
gens and Deissenboeck [16] presented an analytical model to
quantify the additional maintenance costs caused by clones.
The model has not been evaluated yet.
Regarding the risk of unintentional inconsistent changes
to clones, diﬀerent studies have shown that this problem ex-
ists. Li and colleagues [25] identiﬁed defects based on similar
clones that have similar but not identical sets of identiﬁers.
They found 87 defects when analyzing 955 suspicious clones.
Bakota and colleagues [3] detected six defects based on their
analysis of 60 change anomalies in the evolution of clones.
Clones in Linux and Eclipse have been analyzed by Jiang
and colleagues [14]. In addition to the clone itself, they
analyzed each clone’s context to ﬁnd defects. Out of 1342
spurious clones and their context, they detected 62 defects.
Juergens and his colleagues [17] (with the help of system
experts) checked clones that are similar but not identical for
defects. Out of 1427 candidates, 107 were found to contain
defects of diﬀerent severity.
The studies show that at least some clones facilitate de-
fects. Nevertheless, all studies except for the one by Bakota
and his colleagues analyzed clones in a single version. It is
thus possible that the defects were caused by something else
than an inconsistent change.
4. EXTRACTING GENEALOGIES
This section explains how we extract the clone evolution
graph from the history of a system. The process is based
on our incremental clone detection algorithm for eﬃcientlydetecting clones in multiple versions of a system [9, 10]. The
algorithm processes versions of the system one after another.
For each version, the following steps are performed:
(1) Process changed ﬁles and update data structures.
(2) Detect clones for the current version.
(3) Map clones between previous and current version.
These steps are repeated for every version until no more
versions are available.
4.1 Processing Changed Files
Processing changed ﬁles is done as in the algorithm’s orig-
inal version. We distinguish three primary ways in which a
ﬁle can be changed: addition ,deletion , and modiﬁcation .
Apart from that, the algorithm also supports renaming of
ﬁles. Which ﬁles have been changed or renamed is given
as input to our algorithm. The algorithm internally uses a
suﬃx tree to detect duplication. For details on how changed
ﬁles are processed and the suﬃx tree is updated, please refer
to [9, 10].
When a modiﬁed ﬁle is processed, we calculate the diﬀer-
ence between the ﬁle’s old and new version. This informa-
tion is needed later when fragments are mapped. We use our
implementation of Myers’ algorithm [29] which we adopted
to work for token sequences.
4.2 Detecting Clones
In this phase, the clones that exist in the current version
of the system are detected using a two-step process. First,
type-1 clones are extracted from the suﬃx tree. We deliber-
ately do not extract type-2 clones at this point, because this
yields repetitive structures with a high ratio of identiﬁers
which are primarily irrelevant clones. By ﬁrst extracting
only type-1 clones, we ensure that there are identical parts
of suﬃcient length, before allowing any diﬀerences. In the
second step, neighboring type-1 clones are merged to larger
clones of types 2 and 3.
We use a simple algorithm inspired by Baker’s approach
[2] to extract type-1 clone classes (identical fragments) from
the suﬃx tree. To exclude irrelevant clone classes (for ex-
ample, where each fragment is a single token), we apply a
minimum length that fragments are required to have. Note
that this is not the minimum length for the ﬁnal clones as
speciﬁed by the user.
Detection of type-2 and type-3 clones is done by merging
neighboring type-1 clones and inspired by previous work by
Ueda and colleagues [34]. The type-1 clone classes that have
been extracted from the updated GST are ﬁrst expanded
to type-1 clone pairs. These pairs are sorted into buckets
according to the two ﬁles that contain the fragments. Each
bucket is sorted based on the location of the pairs’ fragments.
Each bucket is processed separately. The pairs are pro-
cessed in sequence. For each pair, the algorithm checks
whether it can extend one of the previous pairs. Two frag-
ments are close enough, if the distance dbetween the frag-
ments equals or is less than the shorter of the two fragments.
This is driven by the assumption that the diﬀerences may
not be larger than the similarities. In practice, we have ob-
served that the diﬀerences are always much less than the
similarities if pairs are merged using this rule. If the corre-
sponding fragments of both pairs are close enough, the clone
pairs can be merged.
We provide an example in Figure 2 with two ﬁles AandB
and three clone pairs a, b, c each of which has one fragment3132 1 3 4 5 6 7
A c b a8 9 10 11
1 2 3 4 5 6 7 8 9B b c a
10 11 12d
Figure 2: Merging clones
in each ﬁle. Assume that the pairs are processed c, b, a .
The ﬁrst pair ccannot extend any pair, because it is the
ﬁrst one to be processed. Pair bcannot extend c, because
the fragments are twisted, that is, in ﬁle A,c’s fragment is
located before b’s fragment whereas in ﬁle B,c’s fragment
is located after b’s fragment. Nevertheless, clone pair acan
extend clone pair b, because the gaps are one and two tokens
long and the shortest fragment is two tokens long.
Using the described procedure, our algorithm establishes
chains of clone pairs that can be merged into a single but
larger clone pair. That is, the algorithm merges an arbi-
trary number of clone pairs into a single pair obeying a
user-speciﬁed minimum length. The algorithm has worst
case quadratic complexity with respect to the number of
identical pairs. Nevertheless, the number of identical pairs
is usually small and we exploit the sorting to eliminate un-
necessary calculations where possible.
After the gapped clone pairs have been created, they are
grouped again into clone classes according to their similar-
ities. This is done based on the common subsequence of
the pair’s fragments. For a gapped clone pair that has been
merged from smaller type-1 clone pairs, the common sub-
sequence is the concatenated token seqeunce of the type-1
pairs. We combine the fragments of two pairs into a single
clone class when the common subsequences of both pairs are
identical. Finally, we check the type of each merged clone
class. If the gaps—the non-identical parts—between the
fragments consist of only identiﬁers and literals, the clone
class is of type 2, otherwise of type 3.
The ﬁnal set of clones contains type-1 clone classes (the
ones initially extracted), as well as type-2 and type-3 clone
classes that have been merged. We then discard all type-
1 clone classes whose fragments are shorter than a user-
speciﬁed minimum clone length. This cannot be done earlier
because we required the shorter type-1 classes for merging.
Furthermore, we exclude all type-1 clone classes whose frag-
ments are completely contained in the fragments of another
clone class of type 2 or 3 (this can happen when the frag-
ments of the type-1 clone class have been merged).
4.3 Mapping Clones
The goal of mapping fragments is to ﬁnd for each frag-
ment in the current version its ancestors in the previous
version. Mapping fragments is relatively simple for ﬁles that
are added or remain unchanged. All fragments in an added
ﬁle have no ancestors. Note that duplicated ﬁles are also
treated as added. For unchanged ﬁles, each fragment has
exactly one ancestor which is found at exactly the same lo-
cation.
For modiﬁed ﬁles, we exploit the diﬀerence information
which has been calculated when changed ﬁles have been pro-
cessed. For each fragment of the system’s previous versionthat is contained in a modiﬁed ﬁle, we calculate its occur-
rence in the current version using the diﬀerence information
being a list containing information about added or deleted
token chunks. The occurrence is calculated by processing all
modiﬁcations that aﬀect the fragment. If tokens are added
or deleted before the fragment, its location is adjusted ac-
cordingly. If tokens are removed or added within the frag-
ments bounds, the fragment becomes shorter or longer, re-
spectively. After the relevant modiﬁcations have been pro-
cessed, the calculated occurrence of the fragment describes
how the fragment “would look like” in the current version if
it still existed.
After calculating a fragment’s hypothetical occurrence,
the algorithm checks whether there exists a cloned fragment
in the system’s current version that equals the calculated
occurrence. The check can be done in constant time using a
hash value computed from the fragments’ locations. If such
a fragment is found, the fragment from the previous version
is added to the set of ancestors of the fragment in the current
version.
Note that our mapping technique is independent from the
source of the diﬀerence information. We currently use a
standard diﬀerencing algorithm, but the information might
also come from other sources, for example an IDE.
5. STUDY SETUP
This section describes the setup that we used to collect the
data we need to answer the research questions. The setup
includes our choice of subject systems, parameters for our
clone detection tool, and an overview of our procedure to
collect relevant data.
5.1 Subject Systems
We used the following three subject systems for our study.
•Our ﬁrst subject system is our token-based clone de-
tection tool, clones , itself. clones is written in Ada
and part of the Bauhaus project1. We included this
system, because our knowledge of the code allows us
to much better assess clones and changes to clones in
the code.
•The second system is the web server httpd .2httpd
is part of the Apache project and written in C.
•Our third subject system is JabRef .3JabRef is a
bibliography manager written in Java.
We chose these systems, because they have been used in
some previous studies including ours [8]. All systems are
mature and have a reasonably long history. Each system
has had a multitude of developers contributing and is of
reasonable size. This mitigates the threat that a system
is more or less maintained by a single developer who is an
expert regarding every part of the system. For clones and
JabRef , 15 distinct developers contributed changes relevant
to our study. For httpd , 45 developers were involved in
maintenance.
When analyzing clone evolution based on multiple ver-
sions of a system’s source code, the interval between each
1http://www.bauhaus-stuttgart.de
2http://httpd.apache.org
3http://jabref.sourceforge.net314Table 1: Subject systems used in our study
Revision ∼KLOC
System Lang. #Vers. First Last First Last
clones Ada 820 15271 28900 5 35
httpd C 2186 208366 894526 187 218
JabRef Java 906 664 3150 52 127
pair of consecutive versions is of great importance. Increas-
ing the interval between versions leads to multiple changes
being merged into a single change and consequently results
in loss of detail. To capture data with the highest degree of
detail that is available, we consider each individual commit
to the system’s repository as a version. We excluded com-
mits that did not change source ﬁles relevant to our analysis.
In addition to the interval between consecutive versions,
we require a ﬁrst and a last version that frame the period of
the system’s lifetime that we analyze. The number of ver-
sions that we can analyze is limited by our hardware. We
chose to analyze all projects over the period of ﬁve years,
starting from the very ﬁrst version in 2005 to the very last
version in 2009. Although more versions could have been
analyzed for smaller projects, we chose the same scope for
all subject systems to make the results comparable. Table 1
summarizes our subject systems and details about the ver-
sions we have analyzed.
5.2 Clone Detection Parameters
This section describes the parameters that we used to ex-
tract the relevant clone evolution data.
Exclusion of header ﬁles. For this study, we were in-
terested in clones and changes that aﬀect the systems’ logic.
We excluded all header ﬁles ( *.h) from httpd and all Ada
speciﬁcation ﬁles ( *.ads ) from clones .
Exclusion of generated code. Generated code is not
maintained by hand and thus, most problems caused by
clones do not apply to generated code. Especially consistent
and inconsistent changes to automatically generated ﬁles are
not relevant to our study. We therefore exclude all generated
ﬁles from our analysis. For clones all generated ﬁles are a
kept in a single directory which we excluded. Regarding the
other systems, we identiﬁed generated ﬁles by searching di-
rectory and ﬁle names as well as comments inside a ﬁle for
indications.
Method Separation. Due to a token-based clone detec-
tor’s missing knowledge about syntactic structures, clones
may embrace more than a single method or function in the
source code, that is, clones may start in one method and con-
tinue into the next method. To eliminate these artifacts, we
preprocess the token sequence of each ﬁle before clone detec-
tion. We use regular expressions to identify the boundaries
of methods and functions and insert unique sentinel tokens
that can never be part of a clone. This procedure ensures
that clones do not cross method boundaries. For httpd , we
used a heuristic to identify the boundaries in the presence
of preprocessor directives.
Token Exclusion. Another source of less relevant clones
are reoccurring patterns imposed by the programming lan-
guage. Like method separation, this step preprocesses each
ﬁle’s token sequence before clones are detected. This step ex-
cludes all include -directives in the C code, with-statements
in the Ada code, and import -statements in the Java code.
cyclone(3)
(2)(1)
svnidav1
v2
v3
Figure 3: Our analysis process
It furthermore removes all array initializations (repetitive
sequences of identiﬁers and commas).
Clone types. This parameter determines which types
of clones are detected and included in the clone evolution
model. In this study, we consider two possible settings for
this parameter. The ﬁrst setting detects only type-1 clones.
The second setting detects clones of type 1, 2, and 3. We de-
liberately analyzed the systems using both settings to eval-
uate their impact on the results.
Minimum clone length. This value determines how
many tokens a clone needs to have to be considered as rel-
evant. This value is of major importance since it inﬂuences
the results signiﬁcantly. Choosing a smaller value increases
the recall because more clones are found that would not
be found otherwise. Choosing a larger value increases the
precision because fewer shorter clones are detected that just
happen to be similar due to common programming patterns.
We decided to use three distinct values. This allows us to
compare the impact of the minimum length on the results.
The values we chose are 30, 50, and 100 tokens.
5.3 Procedure
This section describes the overall procedure we used dur-
ing our analysis. The process is illustrated in Figure 3.
(1) We extracted the relevant versions of each subject sys-
tem from its subversion repository and stored them locally.
This step is necessary since fast access to the source code—
for detection and analysis—is of great advantage. It allows
to repeatedly access the source code without the overhead
of accessing a distant repository. Note that we store only
changed source code for each version, keeping the space re-
quirement low. This step had to be done only once for each
system, whereas every following step had to be done for each
combination of parameters.
(2) We used our incremental detection algorithm idato
extract the clone evolution data as described in Section 4.
(3) We used our tool cyclone to analyze and visualize
the evolution data. This includes creation of genealogies,
calculating change frequencies, and support for manual in-
spection of clones and changes to clones.
6. RESULTS
This section presents the results of our case study and
describes the measurements we used to answer our research
questions. We ﬁrst quantiﬁed the relevant data to provide
an overall impression of the cloning situation in our subject
systems.315Table 2: Detected clones and changes
System Type Min. #Cl. Classes #Geneal. Changes
clones 1 30 101,807 876 736
1 50 32,131 317 304
1 100 9,315 86 90
1–3 30 109,714 1,027 923
1–3 50 49,888 523 544
1–3 100 19,708 189 238
httpd 1 30 1,723,091 1,532 678
1 50 743,762 742 388
1 100 198,295 245 168
1–3 30 2,163,465 1,902 990
1–3 50 1,211,477 1,145 717
1–3 100 433,733 461 369
JabRef 1 30 281,957 927 548
1 50 98,493 416 244
1 100 26,299 132 72
1–3 30 376,383 1,220 754
1–3 50 196,489 731 466
1–3 100 60,692 269 177
For each subject system and each possible combination
of clone type and minimum length, we calculated the to-
tal number of clone classes aggregated over all versions, the
number of genealogies that were obtained from linking the
clone classes, and the number of situations in which a clone
class was changed. Consider our example of an evolution
graph in Figure 1. That graph contains 18 clone classes
which are grouped into four distinct genealogies based on
the ancestry of their fragments. There are six situations
in which clone classes have been changed, indicated by the
shaded clone classes.
The corresponding quantities for our subject systems are
given in Table 2. Not surprisingly, increasing the minimum
clone length reduces the number of detected clones for each
system. When searching for all types of clones, more clones
are detected compared to only looking for type-1 clones.
For every system, the number of genealogies is proportional
to the number of detected clones. Nevertheless, the num-
ber of clone classes for each genealogy diﬀers between the
systems. In clones , each genealogy embraces roughly 100
clone classes, in httpd 1000 clone classes, and in JabRef
200 clone classes. Although we have analyzed only twice as
many versions of httpd than of the other systems, the num-
ber of clone classes per genealogy is ten (ﬁve) times higher
inhttpd . This may be due to clones in httpd changing
less frequently compared to the other two systems. If clones
change less, genealogies are more stable, that is, new ge-
nealogies appear only rarely and existing genealogies dis-
appear only rarely. Consequently, genealogies contain more
clone classes due to their longer life expectancy. This is sup-
ported by the number of changes displayed in the last col-
umn of Table 2. The number of situations in which clones
were changed is not signiﬁcantly higher for httpd compared
to the other systems—although we have analyzed more than
twice as many versions for httpd and the number of de-
tected clone classes is signiﬁcantly higher.
In summary, the cloning situation is quite diﬀerent for our
subject systems. clones contains comparatively few clones
which are, however, changed more frequent. httpd has the
highest clone density but clones are changed less frequently.
JabRef falls in-between those two.6.1 Change Propagation
We now use the information about clone genealogies and
changes to clones to answer Question 1 and estimate the
additional costs of change propagation caused by clones.
We assume that clones may cause additional change eﬀort4
only when they are modiﬁed. Hence, clones that are never
changed can never induce costs for change propagation.
To analyze how often clones are changed during their life-
time, we counted the number of changes for each genealogy.
Let the change frequency (cf) of a genealogy be the number
of the genealogy’s clone classes marked as changed. Change
frequencies are also given for the genealogies in our example
shown in Figure 1. The number of genealogies and its per-
centage compared to all genealogies are shown in Table 3 for
each change frequency. We chose to include these detailed
results because the choice of clone detection parameters in-
ﬂuences the results and diﬀerent use cases may require dif-
ferent parameter settings. If furthermore allows to estimate
the impact of changing a given parameter. The number of
genealogies with a change frequency higher than 5 have been
combined due to space limitation. We provide averages at
the bottom of the table. The * represents the combination
of all values.
Never changed. We ﬁrst look at the clones that never
changed. The column labeled “0” shows how many genealo-
gies were never aﬀected by change during their lifetime.
The next column to the right gives the percentage when
compared to the number of all genealogies. The values
indicate that for httpd andJabRef , more than half of
the clone genealogies were never changed during their life-
time. These numbers tell us that roughly half of the clones
have—under no circumstances—induced costs for change
propagation. For clones , 35.1% of the genealogies were
never changed. This may be due to the high number of
changes—considering clones ’ size and the number of ver-
sions analyzed—compared to the other systems. Taking the
average of all measurements, 47.5% of all genealogies were
never changed.
The numbers are almost the same, independent of whether
we consider only type-1 clones or clones of all types. Increas-
ing the minimum length of clones reduces the percentage of
genealogies that are never changed. We think this is due to
longer clones being more susceptible to change. When the
smaller clones are not considered, the remaining longer ones
are more likely to be aﬀected by changes.
Changed once. Apart from the genealogies that never
changed, the genealogies that changed only once are of inter-
est to us. During the lifetime of these genealogies, there has
been a single change applied to one clone class of the geneal-
ogy. Assuming that removing a clone requires changing it at
least once, genealogies that were changed only once did not
cause additional costs compared to when the clone would
have been removed. It is, however, debatable, whether re-
moving a clone or performing an arbitrary change to it re-
quires more eﬀort.
Inclones 46.6%, in httpd 38.7%, and in JabRef 35.6%
of the genealogies were changed exactly once. For clones
the number of genealogies changed once is higher than the
number of genealogies that never changed. For the other two
systems, more genealogies were never changed than changed
4We refer to the act of changing the source code and exclude
the eﬀort to understand or test the code.316Table 3: Change frequency of clone genealogies
Change frequency
System Type Min. #Geneal. 0 [%] 1 [%] 2 [%] 3 [%] 4 [%] 5 [%] >5 [%]
clones 1 30 876 385 43.9 356 40.6 84 9.6 30 3.4 7 0.8 8 0.9 6 0.7
1 50 317 109 34.4 154 48.6 34 10.7 15 4.7 1 0.3 1 0.3 3 0.9
1 100 86 24 27.9 46 53.5 10 11.6 4 4.7 – – 1 1.2 1 1.2
1–3 30 1,027 434 42.3 429 41.8 89 8.69 40 3.9 12 1.2 12 1.2 11 1.1
1–3 50 523 179 34.2 247 47.2 51 9.8 26 5.0 7 1.3 5 1.0 8 1.5
1–3 100 189 53 28.0 90 47.6 22 11.6 12 6.3 4 2.1 3 1.6 5 2.6
httpd 1 30 1,532 961 62.7 497 32.4 54 3.5 14 0.9 4 0.3 1 0.1 1 0.1
1 50 742 421 56.7 275 37.1 33 4.4 8 1.1 3 0.4 1 0.1 1 0.1
1 100 245 109 44.5 116 47.3 12 4.9 5 2.0 2 0.8 1 0.4 – –
1–3 30 1,902 1,134 59.6 634 33.3 82 4.3 35 1.8 8 0.4 4 0.2 5 0.3
1–3 50 1,145 609 53.2 430 37.6 59 5.2 33 2.9 6 0.5 3 0.3 5 0.4
1–3 100 461 196 42.5 205 44.5 34 7.4 17 3.7 4 0.9 2 0.4 3 0.7
JabRef 1 30 927 515 55.6 321 34.6 63 6.8 16 1.7 10 1.1 1 0.1 1 0.1
1 50 416 221 53.1 160 38.5 25 6.0 6 1.4 4 1.0 – – – –
1 100 132 72 54.5 51 38.6 7 5.3 1 0.8 1 0.8 – – – –
1–3 30 1,220 675 55.3 410 33.6 90 7.4 27 2.2 13 1.1 4 0.3 1 0.1
1–3 50 731 386 52.8 264 36.1 56 7.7 13 1.8 9 1.2 3 0.4 – –
1–3 100 269 147 54.6 87 32.3 25 9.3 3 1.1 4 1.5 3 1.1 – –
clones * * – – 35.1 – 46.6 – 10.3 – 4.7 – 1.0 – 1.0 – 1.3
httpd * * – – 53.2 – 38.7 – 5.0 – 2.1 – 0.6 – 0.3 – 0.3
JabRef * * – – 54.3 – 35.6 – 7.1 – 1.5 – 1.1 – 0.3 – 0.0
* 1 * – – 48.1 – 41.2 – 7.0 – 2.3 – 0.6 – 0.3 – 0.3
* 1–3 * – – 46.9 – 39.3 – 7.9 – 3.2 – 1.1 – 0.7 – 0.7
* * 30 – – 53.2 – 36.1 – 6.7 – 2.3 – 0.8 – 0.5 – 0.4
* * 50 – – 47.4 – 40.9 – 7.3 – 2.8 – 0.8 – 0.4 – 0.5
* * 100 – – 42.0 – 44.0 – 8.4 – 3.1 – 1.0 – 0.8 – 0.8
* * * – – 47.5 – 40.3 – 7.5 – 2.7 – 0.9 – 0.5 – 0.5
once. The overall average of genealogies that changed ex-
actly once is 40.3%, being almost as high as the percentage
of clones that never changed.
The type of clones has only a minor impact on the results.
When considering only type-1 clones, 41.2% of the genealo-
gies were changed exactly once. Considering all types of
clones, 39.3% of genealogies were changed once. Increasing
the minimum length of clones also increases the percentage
of genealogies changed once. Interestingly, this is the inverse
compared to the genealogies that never change, where the
percentage of genealogies decreased as the minimum length
is increased.
Changed more than once. The remaining category are
clone genealogies that were changed more than once. Table 3
lists the number of genealogies for change frequencies from 2
to 5 and the aggregated number of genealogies that changed
more than ﬁve times. In general, the number of genealogies
decreases as the change frequency increases. While there are
still some genealogies that changed twice (7.5%) or thrice
(2.7%), higher change frequencies are only scattered. Clone
genealogies that change multiple times are likely to increase
the change eﬀort and should thus be regarded as harmful
clones. These clones should be inspected and removed where
possible.
When considering all types of clones, the percentage of
genealogies that are changed more than once increases com-
pared to considering only clones of type 1. Increasing the
minimum length of clones also increases the number of ge-
nealogies that are changed more than once.
In general, switching from type-1 clones to clones of all
types decreases the percentage of genealogies that were never
changed or changed only once and increases the percentageof genealogies that were changed more than once. Increas-
ing the minimum length of clones decreases the percentage of
genealogies that are never changed while increasing the per-
centage of all genealogies that changed at least once. We
believe that this is caused by the increased likelihood of
larger clones being aﬀected by change. Excluding clones
of shorter length—most of which are not changed—leaves
only the longer clones that are more susceptible to change
due to their increased length.
6.2 Unintentional Inconsistencies
Apart from increasing the change eﬀort, clones are also
said to facilitate problems caused by unintentional inconsis-
tent changes. To explore this assumption and to answer
Question 2, we analyzed the changes to clones in detail.
Unfortunately, manual assessment requires signiﬁcant eﬀort
and is always threatened to be biased. From our experience
we know, that assessing the impact of changes to code we
are not familiar with is hardly possible for the majority of
changes. To ensure familiarity with the code and its history,
we restricted this part of our study to the system clones .
Consequently, we are in a much better position to judge the
changes and to explain our ﬁndings than if we were ana-
lyzing an unfamiliar system. The disadvantage of studying
clones is, that some of its developers were aware of clone-
related problems (see our threats to validity in Section 6.3).
For assessment, we used only a single parameter setting to
keep the assessment eﬀort manageable. We chose to look at
changes to type-1 clones only, because having identical frag-
ments before the change makes the evaluation of the change
itself much easier. For the minimum clone length, we chose
50 tokens. This setting provided us with a total number of3171function I sR i g h t E x t e n s i b l e
2 (A, B : Token Table Index ;
3 Len : Natural )
4 return Boolean
5i s
6 . . .
(a) Version i
1function I sR i g h t E x t e n s i b l e
2 (A : inToken Table Index ;
3 B : inToken Table Index ;
4 Len : inNatural )
5 return Boolean
6i s
7 . . .
(b) Version i+ 1
Figure 4: Semantic-preserving change
304 changes to clone classes. To answer Question 2, every
change was analyzed to decide whether it contains an un-
intentional inconsistency—that is, a missing propagation of
the change. We further assign each unwanted inconsistency
one of two severity levels:
Low: The change should have been consistent . It does not
cause the program to crash or produce wrong results, but
may complicate future maintenance and facilitate further
inconsistencies.
High : The change must have been consistent . The incon-
sistency may cause the program to crash or produce wrong
results.
The following paragraphs summarize the results of our
analysis of changes to clones.
Consistent changes. Our objective is to identify unin-
tentional inconsistent changes within the set of all changes.
Consequently, we ﬁrst removed all consistent changes—that
is, changes where exactly the same modiﬁcations have been
done to each fragment of the clone class. In total, 173
(56.9%) of the changes were consistent. The remaining 131
inconsistent changes were inspected manually.
Semantic-preserving. Inconsistent changes are detected
based on the changes to the token sequences of the respec-
tive fragments. However, not every change to the token se-
quence changes the semantic of the program. For example,
the rewriting of the parameter list as shown in Figure 4 does
not change the semantic ( inis the default mode for parame-
ters in Ada), but may still be responsible for an inconsistent
change. If semantic-preserving changes are unwanted incon-
sistencies, their severity can be only low.
We manually checked each inconsistent change whether
it altered the semantic of the program or not. We found
that almost half (51 out of 131) of the inconsistent changes
did not change the semantic of the program. Many of the
inconsistencies resulted from unused variable declarations or
unnecessary uses of fully qualiﬁed names being removed.
Unwanted Inconsistencies. The ﬁnal and most impor-
tant assessment for each change is whether it features a miss-
ing change propagation and if it does, whether the severity
is low or high. An example for an inconsistency with high
severity is shown in Figure 5. The missing check to pre-
vent Ceiling_Prime being called with 0 (the type PositiveTable 4: Classiﬁcation of changes in clones
Total 304 100.0%
Consistent 173 56.9%
Inconsistent 131 43.1%
Semantic-preserving 51 16.8%
Unintentional 45 14.8%
Low severity 36 11.8%
High severity 9 3.0%
expects numbers greater than 0) is inserted in only one of
the fragments making this an incomplete bug removal. The
change has high severity, because the change must be prop-
agated to all fragments. Unless the missing check is inserted
in all fragments, the program may crash when encountering
empty token sequences.
Analyzing the 131 inconsistent changes, we found that 45
of them were unintentionally inconsistent. This amounts to
14.8% of the total number of changes to clones. Regarding
severity, four out of ﬁve unwanted inconsistencies had low
severity—for example changes to debugging code. Of all 36
changes classiﬁed as low, 20 are also semantic-preserving. In
total, only 9 inconsistencies with high severity were found.
This amounts to 3% of all changes. Table 4 summarizes our
results regarding the classiﬁcation of changes. Note that
changes may belong to multiple categories.
6.3 Threats to Validity
There are certain threats to the validity of our results.
Clone detection parameters. As with most studies
on clones, the parameters used for detecting clones have a
major impact on the results. We deliberately used diﬀerent
combinations of parameters to analyze their impact. This
included the type of clones that were detected and the mini-
mum length that clones were required to have. We presented
detailed results in Table 3 and described the impact of the
parameters.
Precision. The precision of a clone detection tool inﬂu-
ences the validity of the results. Although token-based clone
detection has—in general—lower precision than approaches
using abstract syntax trees or graphs, we carefully selected
our parameters to exclude irrelevant clones from the results.
Furthermore, we used a novel approach that requires clones
to have identical parts of suﬃcient length to detect type-
2 and type-3 clones—a frequent source of irrelevant clones
using traditional approaches. One of the authors manually
inspected a sample of clones to ensure that detected clones
are relevant. The only clones we found to be less relevant
are those in handling of command line parameters.
Study period. The part of a system’s history that we
used for our study also has an impact on the result. For ev-
ery subject system, we have analyzed ﬁve years of its history
to reduce the impact of special phases (e.g., major refactor-
ings). Using only a part of a system’s history also crops ge-
nealogies, that is, genealogies might have existed before the
beginning of the study period and might exist beyond the
end of the study period. When considering only genealogies
that appear after the ﬁrst version and disappear before the
last version of the study period, the majority of genealogies
has a change frequency of 1 (instead of 0). Nevertheless, the
percentage of genealogies changed more than once remains3181function Ceiling Prime
2 (Number : inP o s i t i v e )
3 return P o s i t i v e
4i s
5 . . .
6
7
8procedure I n i t i a l i z e
9i s
10 Table Size : Natural := Natural
11 ( Float ( Number OfTokens ) ∗2 . 4 ) ;
12 begin
13
14 Table Size :=
15 Ceiling Prime ( Table Size ) ;
16 . . .
17 end I n i t i a l i z e ;
(a) Version i1function Ceiling Prime
2 (Number : inP o s i t i v e )
3 return P o s i t i v e
4i s
5 . . .
6
7
8procedure I n i t i a l i z e
9i s
10 Table Size : Natural := Natural
11 ( Float ( Number OfTokens ) ∗2 . 4 ) ;
12 begin
13 i fTable Size >0then
14 Table Size :=
15 Ceiling Prime ( Table Size ) ;
16 . . .
17 end I n i t i a l i z e ;
(b) Version i+ 1
Figure 5: Unintentional inconsistency with high severity
almost the same. Consequently, the ratio between genealo-
gies changed never or once and genealogies changed more
than once remains also roughly the same.
Mapping. The mapping between fragments of consecu-
tive versions is another potential threat to the validity. As
genealogies are created based on the mapping of fragments,
a missing connection will break genealogies apart, leaving
two genealogies each of which has a change frequency equal
or less to the combined genealogy. The reason for an incom-
plete mapping can be the algorithm to calculate diﬀerences
between token sequences—which has to deal with ambigu-
ous situations—and clone classes becoming left-extensible
or right-extensible due to changes or removal of fragments.
However, according to our experience from previous stud-
ies and careful analysis of the clone evolution data, we have
found that these situations are very rare.
Analyzing clones. Another threat may arise from the
analysis of our own program clones . Although 15 diﬀerent
developers have contributed to clones , most of them knew
about clone-related problems—not saying they were aware
of them during development. This might have an impact
on the number of unintentional inconsistencies. Thus, the
percentage of unwanted inconsistencies might be higher for
projects where developers are completely unaware of clones.
Manual assessment. Manual assessment of changes to
clones depends on the judges and their expertise. We have
deliberately chosen a system we are familiar with to reliably
judge the impact of changes. Furthermore, we applied clear
assessment criteria that reduced ambivalent decisions.
7. DISCUSSION
Clones are said to increase the change eﬀort when software
is maintained, because changes have to be propagated to all
clones. However, looking at our results we have presented
in Section 6.1, we found that almost half of the clones have
never been changed during their lifetime. These clones have
never caused additional costs for change propagation. Apart
from the clones that never changed, another 40.3% changed
only once during their lifetime.
We assume that removal is the only option to prevent
additional change eﬀort since semi-automated change prop-
agation (e.g., [33]) still requires eﬀort for manual veriﬁcationof the suggested propagation. We also assume that the ad-
ditional eﬀort caused by a single change to a clone class
is less than the eﬀort to remove the respective clones by
refactoring. That means, for 87.8% of the clones (the ones
that never changed or changed once), removal would not
have been beneﬁcial because the eﬀort to remove the clones
would have been larger than the additional change eﬀort
that would have been prevented. Only for the remaining
12.2% of clones that changed more than once, removal might
have been beneﬁcial. Furthermore, we counted all changes
including those that are meant to be independent—that is,
they do not need to be propagated to the other clones of the
class. Hence, the 87.8% is an under-estimation of the true
percentage.
Our results show that the major percentage of clones does
not cause additional eﬀort, independent of whether the clone
is“structurally interesting”or not. Based on our ﬁndings, we
suggest to consult change information when deciding which
clones are relevant and which clones are not relevant. Al-
though the data describe only the past evolution of clones,
we believe it provides important information to predict their
future evolution.
When a cloned fragment is changed, the change might
need to be propagated to the other copies. If this is not
done—or not done correctly—new problems may arise or
existing problems might not be completely mitigated. We
analyzed changes to clones in our own code and found that
14.8% of all changes were unintentionally inconsistent. Re-
garding severity, 11.8% of the unwanted inconsistencies had
only low severity whereas only 9 (3.0%) of all changes were
found to have high severity.
On the one hand, we can conﬁrm the results of previous
studies [3, 14, 17, 25] that identiﬁed faults based on incon-
sistencies between clones or their contexts. There are clones
that facilitate problems when being changed. On the other
hand, our results show that 85.2% of the changes are con-
sistent or intentionally inconsistent conﬁrming ﬁndings of
previous studies [1, 32]. This is important for developing
clone-management tools, because too many false alarms re-
garding potential problems caused by inconsistent changes
may be counterproductive for the adoption of clone manage-
ment in practice.3198. CONCLUSION
Code clones are said to cause a variety of problems among
which are additional costs for change propagation and the
risk of unintentional inconsistencies. We have analyzed clone
evolution using the history of three subject systems to es-
timate the threat potential of clones. Regarding the addi-
tional change eﬀort, the answer to Question 1 is that 87.8%
of clones were never changed or changed only once during
their lifetime. Thus, we cannot say that these clones caused
additional change eﬀort (assuming the eﬀort to remove them
equals the eﬀort to change them once).
Regarding Question 2, the answer is that only 14.8% of all
changes to clones are unintentionally inconsistent. Further-
more, only few of these changes have high severity, while the
others are more or less cosmetic.
Please note that our study focused on two prominent clone-
related threats. Apart from these, there are other problems
caused by the presences of code clones. These include, for
example, increased system size and additional eﬀort to read
and understand the code. Hence, our results are not to be
regarded as a general acquittal for clones.
The implication of our results is, that the history of clones
provides important information to determine their relevance
and threat potential. This is important regarding the in-
creasing number of clone management tools. To successfully
establish these tools in the daily maintenance practice, it is
important to reliably identify the clones with high threat
potential and not besiege maintainers with false alarms.
9. REFERENCES
[1] L. Aversano, L. Cerulo, and M. Di Penta. How clones
are maintained: An empirical study. In CSMR . IEEE,
2007.
[2] B. S. Baker. Parameterized duplication in strings:
Algorithms and an application to software
maintenance. Journal on Computing , 26(5), 1997.
[3] T. Bakota, R. Ferenc, and T. Gyim´ othy. Clone smells
in software evolution. In ICSM . IEEE, 2007.
[4] M. Balazinska, E. Merlo, M. Dagenais, B. Lag ¨ue, and
K. Kontogiannis. Advanced clone-analysis to support
object-oriented system refactoring. In WCRE . IEEE,
2000.
[5] I. D. Baxter, A. Yahin, L. Moura, M. Sant’Anna, and
L. Bier. Clone detection using abstract syntax trees.
InICSM . IEEE, 1998.
[6] M. de Wit, A. Zaidman, and A. van Deursen.
Managing code clones using dynamic change tracking
and resolution. In ICSM . IEEE, 2009.
[7] S. Ducasse, M. Rieger, and S. Demeyer. A language
independent approach for detecting duplicated code.
InICSM . IEEE, 1999.
[8] N. G ¨ode. Evolution of type-1 clones. In SCAM . IEEE,
2009.
[9] N. G ¨ode and R. Koschke. Incremental clone detection.
InCSMR . IEEE, 2009.
[10] N. G ¨ode and R. Koschke. Studying clone evolution
using incremental clone detection. JSME , 2010.
[11] J. Harder and N. G ¨ode. Quo vadis, clone
management? In IWSC . ACM, 2010.
[12] Y. Higo, T. Kamiya, S. Kusumoto, and K. Inoue.
Refactoring support based on code clone analysis.
LNCS , 3009, 2004.[13] L. Jiang, G. Misherghi, Z. Su, and S. Glondu.
DECKARD: Scalable and accurate tree-based
detection of code clones. In ICSE . IEEE, 2007.
[14] L. Jiang, Z. Su, and E. Chiu. Context-based detection
of clone-related bugs. In ESEC/FSE . ACM, 2007.
[15] J. H. Johnson. Identifying redundancy in source code
using ﬁngerprints. In CASCON . IBM Press, 1993.
[16] E. Juergens and F. Deissenboeck. How much is a
clone? In SQM , 2010.
[17] E. Juergens, F. Deissenboeck, B. Hummel, and
S. Wagner. Do code clones matter? In ICSE . IEEE,
2009.
[18] T. Kamiya, S. Kusumoto, and K. Inoue. CCFinder: A
multilinguistic token-based code clone detection
system for large scale source code. TSE, 28(7), 2002.
[19] C. J. Kapser and M. W. Godfrey. ”Cloning considered
harmful” considered harmful: patterns of cloning in
software. ESE, 13(6), 2008.
[20] M. Kim, V. Sazawal, D. Notkin, and G. C. Murphy.
An empirical study of code clone genealogies. In
ESEC/FSE . ACM, 2005.
[21] R. V. Komondoor and S. Horwitz. Using slicing to
identify duplication in source code. In SAS.
Springer-Verlag, 2001.
[22] R. Koschke. Survey of research on software clones. In
R. Koschke, E. Merlo, and A. Walenstein, editors,
Duplication, Redundancy, and Similarity in Software ,
number 06301 in Dagstuhl Seminar Proceedings, 2007.
[23] J. Krinke. Identifying similar code with program
dependence graphs. In WCRE . IEEE, 2001.
[24] J. Krinke. A study of consistent and inconsistent
changes to code clones. In WCRE . IEEE, 2007.
[25] Z. Li, S. Lu, S. Myagmar, and Y. Zhou. CP-Miner:
Finding copy-paste and related bugs in large-scale
software code. TSE, 32(3), 2006.
[26] A. Lozano and M. Wermelinger. Assessing the eﬀect of
clones on changeability. In ICSM . IEEE, 2008.
[27] A. Lozano, M. Wermelinger, and B. Nuseibeh.
Evaluating the harmfulness of cloning: A change
based experiment. In MSR . IEEE, 2007.
[28] J. Mayrand, C. Leblanc, and E. Merlo. Experiment on
the automatic detection of function clones in a
software system using metrics. In ICSM . IEEE, 1996.
[29] E. W. Myers. An O(ND) diﬀerence algorithm and its
variations. Algorithmica , 1(2), 1986.
[30] T. T. Nguyen, H. A. Nguyen, N. H. Pham, J. M.
Al-Kofahi, and T. N. Nguyen. Clone-aware
conﬁguration management. In ASE. IEEE, 2009.
[31] C. K. Roy and J. R. Cordy. A survey on software
clone detection research. Technical report, Queens
University at Kingston, Ontario, Canada, 2007.
[32] S. Thummalapenta, L. Cerulo, L. Aversano, and
M. Di Penta. An empirical study on the maintenance
of source code clones. ESE, 15(1), 2010.
[33] M. Toomim, A. Begel, and S. L. Graham. Managing
duplicated code with linked editing. In Symposium on
Visual Languages and Human Centric Computing .
IEEE, 2004.
[34] Y. Ueda, T. Kamiya, S. Kusumoto, and K. Inoue. On
detection of gapped code clones using gap locations.
InAPSEC . IEEEy, 2002.320