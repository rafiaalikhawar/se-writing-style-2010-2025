Efﬁcient Data Race Prediction with Incremental
Reasoning on Time-Stamped Lock History
Malay K. Ganai
NEC Labs America, Princeton, USA
Abstract—We present an efﬁcient data race prediction algo-
rithm that uses lock-reordering based incremental search o n
time-stamped lock histories for solving multiple races eff ectively.
We balance prediction accuracy, coverage, and performance with
a specially designed pairwise reachability algorithm that can
store and re-use past search results, thereby, amortizing t he
cost of reasoning over redundant and overlapping search spa ce.
Compared to graph-based search algorithms, our algorithm
incurs much smaller overhead due to amortization, and can
potentially be used while a program under test is executing. To
demonstrate such a possibility, we implemented our approac h as
an incremental P redictive A nalysis (iPA) module in a predictive
testing framework. Our approach can handle traces with a few
hundreds to half a million events, and predict known/unknow n
real data races with a performance penalty of less than 4% in
addition to what is incurred by runtime race detectors.
I. INTRODUCTION
Concurrent programs often have bugs that are exposed
only by certain interleavings. Even for a single test input,
systematic exploration of all possible interleavings is al most
impractical, making concurrency testing a real challengin g
problem. Predictive testing [1]–[9] appears more promisin g
in managing exploration of such large interleaving space,
and discovering hard-to-ﬁnd concurrency bugs, often misse d
by race detection techniques such as [10]–[16]. The idea is
to observe a given execution trace of the program under
test, and then predict alternate interleavings (i.e., re-o rdering
of observed trace events) that are more likely to contain
scheduler-dependent bugs such as data races, atomicity vi-
olations, order violations, mismatched communication, an d
deadlocks. Search engines for prediction (i.e., to ﬁnd such
witnessinterleavings)aretypicallybasedonlight-weigh tstatic
analysis, and usually are made tractable by employing sever al
pruning and approximation techniques.
Pairwise reachability problems—checking if a pair of
threads can simultaneously be at a given pair of respective
threadlocations—oftenariseduringpredictivetestingof multi-
threadedprograms.Fore.g.,checkingatomicityviolation ,data
races, mismatched communication, and non-determinism can
be reduced to solving multiple pairwise reachability probl ems
that can arise at the rate of 103−104per second in a typical
run of a real multi-threaded application (as observed in our
experiments). Clearly, such a volume of reachability check s
would also increase the total end-to-end time for predictiv e
testing that includes several tasks: recording, identifyi ng tar-
get pairs, solving pairwise reachability, generating witn esses,
and validating the results. In general, reasoning techniqu es
typically make trade-offs between accuracy, coverage, and
performance to manage concurrency testing effectively.In this paper,we focuson designinglight-weightsearch and
pruning techniques that can solve a large volume of pairwise
reachability problems effectively, by avoiding the repeti tive
search over redundant and overlapping space. We have set a
multi-dimension goal with our unique search approach: (a)
we aim to improve performance compared to graph-based
predictiveanalysissuchas[4],althoughwearewillingtoi ncur
small performance penalty over runtime race detectors [13] –
[15], (b) we aim to improve accuracy and coverage over
race detectors, while achieving similar accuracy and cover age
as [4], (c) we aim to support applications that may also
use non-nesting locking (i.e., a lock that is ﬁrst acquired i s
notreleased last). Ultimately, we aim to improve end-to-end
predictive testing performance.
A. Basic Idea
Pairwise reachability problem . Given two threads ta,tb
with time-stamped lock histories (TLH) Ha=/an}bracketle{ta1···am/an}bracketri}ht
andHb=/an}bracketle{tb1···bn/an}bracketri}ht, where ai,biare lock events (i.e.,
acquires and releases). Assume that the threads are current ly
at locations ⊢aand⊢b, respectively. The goal is to show
that the location pair (⊢a,⊢b)is reachable along a consistent
sequence (that satisﬁes locking and causal ordering) start ing
from(a1,b1)in a most effective way . We will assume ⊢a,⊢b
are not causally ordered. Further, locksets (i.e., sets of l ocks
held by each thread) at ⊢a,⊢b, i.e.,LS(⊢a), andLS(⊢b)
respectively, are mutually exclusive LS(⊢a)∩LS(⊢b) =∅;
otherwise, a happens-before analysis [14] or lockset analy -
sis [10] would detect (⊢a,⊢b)pairwise unreachable.
Example. In the sequel, we use the following running
example to illustrate our approach. Two threads taandtb,
with various events are shown in Figure 1. TLHs comprise
only lock events such as ai,bibut not other events such as
wait/notify. We also use ai,bjto denote the thread locations
of corresponding TLH events. For e.g., the thread at locatio n
a2has completed lock(ta,L3)ata1. We do not separately
identify locations of non-lock events, but use the location s of
the immediate lock events preceding it. For e.g., we use a10
to denote the location of write(X)event that occurs between
two lock events a10anda11.
L1is a re-entrant lock in thread tb. For such a re-entrant
case, we record the outer lock/unlock events at b1/b4, and
ignore the nested ones. The waitevent (after b3) is synchro-
nized with the notifyevent (after a2) by signal S. We show
the locksets at each thread location as the tuple of Boolean
values/an}bracketle{tLH0,···,LH3/an}bracketri}htwhereLHi= 1if and only if lock
Liis heldby the thread.For e.g.,lockset /an}bracketle{t0,0,1,1/an}bracketri}htat location
a3denotesL2,L3are held by thread ta.978-1-4799-0215-6/13/$31.00 c2013 IEEE ASE 2013, Palo Alto, USA37
Lockset Threadta Threadtb Lockset
/an}bracketle{t0,0,0,0/an}bracketri}hta1.lock(L3)b1.lock(L1)/an}bracketle{t0,0,0,0/an}bracketri}ht
/an}bracketle{t0,0,0,1/an}bracketri}hta2.lock(L2)b2.lock(L3)/an}bracketle{t0,1,0,0/an}bracketri}ht
/an}bracketle{t0,0,1,1/an}bracketri}htnotify(S)b3.unlock(L3)/an}bracketle{t0,1,0,1/an}bracketri}ht
/an}bracketle{t0,0,1,1/an}bracketri}hta3.unlock(L3) wait(S)/an}bracketle{t0,1,0,0/an}bracketri}ht
/an}bracketle{t0,0,1,0/an}bracketri}hta4.lock(L1) lock(L1)//Ignore nested
/an}bracketle{t0,1,1,0/an}bracketri}hta5.unlock(L2) unlock(L1)//re-entrant (un)lock
/an}bracketle{t0,1,0,0/an}bracketri}hta6.lock(L2)b4.unlock(L1)/an}bracketle{t0,1,0,0/an}bracketri}ht
/an}bracketle{t0,1,1,0/an}bracketri}hta7.unlock(L1)b5.lock(L3)/an}bracketle{t0,0,0,0/an}bracketri}ht
/an}bracketle{t0,0,1,0/an}bracketri}hta8.lock(L0)b6.lock(L2)/an}bracketle{t0,0,0,1/an}bracketri}ht
/an}bracketle{t1,0,1,0/an}bracketri}hta9.unlock(L2)b7.lock(L0)/an}bracketle{t0,0,1,1/an}bracketri}ht
/an}bracketle{t1,0,0,0/an}bracketri}htwrite(X)b8.unlock(L3)/an}bracketle{t1,0,1,1/an}bracketri}ht
/an}bracketle{t1,0,0,0/an}bracketri}hta10.lock(L3)b9.unlock(L0)/an}bracketle{t1,0,1,0/an}bracketri}ht
read(X)/an}bracketle{t0,0,0,0/an}bracketri}ht
b10.unlock(L2)/an}bracketle{t0,0,1,0/an}bracketri}ht
/an}bracketle{t1,0,0,1/an}bracketri}htwrite(X) write(X)/an}bracketle{t0,0,0,0/an}bracketri}ht
/an}bracketle{t1,0,0,1/an}bracketri}hta11.··· b11.··· /an}bracketle{t 0,0,0,0/an}bracketri}ht
Fig. 1:Events of threads taandtb.
Our goal is to check the pairwise reachability of (a10,b10),
(a10,b11),(a11,b10)and(a11,b11)corresponding to various
data races on variable X, i.e., write-read, write-write, write-
read, and write-write, respectively.
Considerana¨ ıveapproachtocheckthepairwisereachabili ty
of(a10,b10). Conceptually, it involves traversing a lockset
graph (LG) built using the events in the lock history of each
thread, as shown in Figure 2 for threads taandtb. We use
Li/ULito denote the lock/unlock of the lock object Liresp.
For now, assume (a3,b4)is pairwise reachable. We ﬁrst
compute lockset at each thread location. A pair of thread
locations (ai,bj)with locksets LS(ai)andLS(bj)resp., is
unreachable if the locksets intersect. The LG is quadratic i n
the size of lock histories, i.e., O(m·n)wherem,nare the
sizes of lock histories of respective threads.
The na¨ ıve approach solves the pairwise reachability by
ﬁnding a consistent sequence, i.e., a sequence of TLH events
satisfying locking discipline and causal ordering,starti ng from
(a3,b4)to (a10,b10). It can ﬁnd such a sequence if and only
if the pair is reachable. A simple depth-ﬁrst-search strate gy
would require O(m·n)re-ordering steps.
(a3,b4)
L3(a4,b4)
(a5,b4)
(a10,b4)(a6,b4)
(a3,b10)UL1
L2
L0
UL3
UL0UL3
L2
UL1L1
UL2(a3,b5)
(a3,b6)
(a3,b7)
(a3,b8)
(a3,b9)
L0
UL2(a7,b4)
(a8,b4)
(a9,b4)/g898/g62/g1005/g899/g923/g271/g1008/g898/g62/g1007/g853/g62/g1006/g899/g923/g258/g1007
/g898/g62/g1006/g899/g923/g258/g1008
/g898/g62/g1006/g853/g62/g1005/g899/g923/g258/g1009
/g898/g62/g1005/g899/g923/g258/g1010
/g898/g62/g1005/g853/g62/g1006/g899/g923/g258/g1011
/g898/g62/g1006/g899/g923/g258/g1012
/g898/g62/g1004/g853/g62/g1006/g899/g923/g258/g1013
/g898/g62/g1004/g899/g923/g258/g1005/g1004/g898/g899/g923/g271/g1009
/g898/g62/g1007/g899/g923/g271/g1010
/g898/g62/g1006/g853/g62/g1007/g899/g923/g271/g1011
/g898/g62/g1004/g853/g62/g1006/g853/g62/g1007/g899/g923/g271/g1012
/g898/g62/g1004/g853/g62/g1006/g899/g923/g271/g1013
/g898/g62/g1006/g899/g923/g271/g1005/g1004
(a11,b11)(a3,b11)UL2
/g898/g899/g923/g271/g1005/g1005
(a11,b4)/g898/g62/g1004/g853/g62/g1007/g899/g923/g258/g1005/g1006L3
(a6,b11)(a5,b11)(a4,b11)
(a7,b11)
(a8,b11)
(a9,b11)
(a10,b11)(a11,b5)
(a11,b6)
(a11,b7)
(a11,b8)
(a11,b9)
(a11,b10)(a10,b10)
/g100/g258/g396/g336/g286/g410/g3/g393/g258/g349/g396/g400
Fig. 2: Check reachability of target pairs
(a10,b10),(a10,b11),(a11,b10),(a11,b11).
Preview of Our Approach. Given multiple pairwise reach-
ability problems, our primary goal is to ﬁnd for each pair aconsistentsequenceoftheTLHeventsifandonlyifoneexist s.
We solve them without traversingor constructingthe comple te
lockset graphs, and achieve almost linear time complexity
(in the length of TLHs) by amortizing the search cost over
multiple problems.
We designed a search algorithm that improves the na¨ ıve
algorithmby employingvariouspruningand incrementalste ps
to reduce the amortized cost of reasoning over redundant and
overlapping search space. Loosely speaking, redundancies in
search space occur due to independentlock events (i.e., eve nts
that do not conﬂict), while overlaps in search space occur du e
to overlapped TLHs of multiple pairwise reachability prob-
lems. Speciﬁcally, we take the following steps for checking
multiple pairwise reachability problems:
•Reduce the effective length of TLHs by selecting a suitable
starting pair. For given TLHs Ha=/an}bracketle{ta1···am/an}bracketri}ht, and
Hb=/an}bracketle{tb1···bn/an}bracketri}ht, we identify a suitable reachable
pair(astart,bstart)to start the search, where
astart∈ /an}bracketle{ta1···am/an}bracketri}ht, andbstart∈ /an}bracketle{tb1···bn/an}bracketri}ht. Such a
selection reduces the search complexity to O(δa·δb)
whereδa,δbare the lengths of the reduced sequence
/an}bracketle{tastart···am/an}bracketri}htand/an}bracketle{tbstart···bn/an}bracketri}ht, respectively.
•Identify and avoid inconsistent sequences . We will
not explore those sequences that do not satisfy locking
discipline. For e.g., a sequence /an}bracketle{ta6···b6···a7/an}bracketri}htwill not
be explored as tais holding L2at location a7.
•Identify and avoid redundant sequences w.r.t. consistent
space.Among those sequences that are equivalent [17], we
will explore only one. Our choice of the sequence will be
guided by the reduction in the inconsistent search space.
Consider a reachability target pair (a10,b10)starting
from(a3,b4). For that search space, suppose sequences
σ1=/an}bracketle{ta6·γa·b5·γ/an}bracketri}htandσ2=/an}bracketle{tb5·a6·γa·γ/an}bracketri}htare
equivalent, where γarepresents a sequence of TLH events
of thread ta, andγrepresent a sequence of TLH events of
any thread. Then, we explore only the sequence σ2andnot
σ1. The choice of σ2, however, is driven by a key insight
(ref. Lemma 5) that whether σ1,σ2are equivalent or not,
ifσ1is consistent, then σ2is also consistent. The other
way argument may not hold if they are not equivalent.
Here is a simple explanation. The lock L3is not acquired
or released by tabetween locations a5anda10. Therefore,
ifσ1is consistent, then σ2obtained after re-ordering b5
beforea6will also be consistent.
•Incrementalsearchtoamortizethecostformultiplechecks .
For checking reachability of multiple pairs, we ﬁnd that
the corresponding TLHs often overlap. To avoid repetitive
search, one can store and re-use previous search results,
and thereby, reduce the redundancy and consistency checks
during re-ordering. For e.g., there are signiﬁcant overlap s
of TLHs of target pairs (a10,b10),(a10,b11),(a11,b10)
(a11,b11)starting from (a3,b4). Instead of re-doing the
entire search for each pair, we selectively store the inter-
mediate results while targeting a pair, and re-use them for
the other target pairs.
We show later that we can reduce the number of re-ordering
steps from 97(= number of edges in lockset graph) to 8for38the target pair (a10,b10). When we target all four pairs using
our incremental search, we can reduce the total number of
re-ordering steps to 21from446(= sum total of all edges
in LG for each target). We summarize and highlight our key
contributions in the following:
•Key idea. We present anefﬁcient racepredictionalgorithm
thatuseslock-reorderingbasedsearchontime-stampedloc k
histories. We aim to reason multiple pairwise reachability
problems arising during predictive testing of multi-threa ded
programs by ﬁnding for each pair, a consistent sequence
satisfying locking discipline and causal ordering if and on ly
if one exists. In our search strategy,we store and re-use pas t
search results, and thereby, amortize the cost of reasoning
over redundant and overlapping search space. In terms of
accuracyandcoverage,weclaimsimilarlyasingraph-based
approach [4], i.e., under data abstraction, our approach
guarantees no false positive or no false negative (but not
both) for a three or more threaded concurrent program; and
guarantees no false positive and no false negative for a two-
threaded program.
•Keybeneﬁts. Ourapproachsupportsvariouslockingstyles
(as used in real programs) where locks can be acquired or
released in any manner: recursive, non-nested, or nested. I n
terms of performance cost, although the worst case search
complexity of our approach is quadratic in the length of the
TLHs, in practice, the effective running cost is linear in th e
length of TLHs due to amortization.
•Key differentiators. Our search strategy has many key
differentiating beneﬁts, which are not easily achievable b y
SMT-based [3], [6], [7], [9], [18] and graph-based search
engines [4]. It supports effective pruning of redundant
and inconsistent interleavings. It enables incremental se arch
which is a much coveted feature for solving frequently
arising multiple pairwise reachability problems. It incur s
comparatively low overhead, and ideally suited for predic-
tive testing. Thus, one may also use our search technique
at runtime testing when a program is executing.
•Proof-of-concept. We implemented our approach as an
incremental P redictive A nalysis ( iPA) module in an x86-
based binary predictive testing framework. We apply the
iPAmodule while the program-under-test is executing.
In our experimentation with various publicly available
C/C++/Java applications, we demonstrate its efﬁcacy in
handling traces with a few hundreds to half a million
events, and predicting known/unknown real data races, and
generating witness interleavings that can be validated by a n
independent replayer. Our approach incurs a performance
penalty of less than 4%in addition to what is incurred by
race detectors—imprecise but fast—based on lockset and
happens-before analysis. In a separate controlled study, w e
also evaluated the beneﬁts of incremental search over non-
incremental, and found that the former can give orders of
magnitude improvement over the latter.
B. Related Work
The related work can be categorized as: race detection
techniques such as [10]–[16], fuzzing-based runtime test-
ing [19], [20], predictive analysis [1]–[9],dynamic model
checking [21]–[23], and staticdata-race analysis [24]–[27].
Most runtime testing techniques (i.e., techniques used whi lea program-under-test is executing) use a lockset-based ana ly-
sis[10],ahappens-beforeanalysisbasedonvectorclocks[ 11],
[12], or a combination of both [1], [13], [14] for detection o f
data races.
A lockset-based analysis tracks a set of locks (i.e., lockse ts)
currently held by each thread. Pairwise reachability betwe en
the current thread locations is inferred when locksets at th ose
locations are disjoint, which can be checked in O(|L|)time
(|L| ≡number of locks). In general, this technique can give
false positives(i.e.,spuriousreachability)asit failst o consider
the causal ordering of synchronization events.
A happens-before analysis [13]–[15] is often used in con-
junction with lockset-analysis to improve accuracy. It use s
vector clocks [28], [29] to order inter-thread synchroniza tion
events such as lock/unlock, wait/notify, etc. Pairwise rea ch-
ability is inferred when the vector clocks at a pair location
arein-comparable , i.e., not ordered, which can be checked in
O(|T|)(|T| ≡number of threads). For checking data races,
the vector clock of the current memory access is compared
against that of the last observed memory access (of the same
memory location and at least of the accesses is write). A pure
happens-before analysis such as [14], however, can miss a
data race due to enforcing an inter-thread order between non -
causally ordered events such as unlock/lock events.
In practice, a hybrid approach is often used [1], [8], where
ordering between unlock/lock is not strictly enforced, the reby,
more races are detected than by a pure happens-before anal-
ysis. To avoid potential false positives, the ordering betw een
unlock/lock events is relaxed only if a read-after-write or der
is not violated. In [1], to overcome the non-linear search, i t
processes events in the order as observed, and uses sliced
causality-induced ordering and lockset based criteria to i nfer
races. In [8], a notion of causal-precedesrelation (weaker than
happens-before)was used to guarantee no false positive und er
the assumption of nested locking. To search for consistent
(i.e., feasible) schedules for the detected race candidate s, and
avoid the search for all permutations ( O(k|T|),k: number of
observedevents) variousadhoc schemes such as ﬁxed window
sizes are employed to achieve linear scalability.
To overcome the imprecision of lockset-based analysis,
and thereby, improve the accuracy of data race analysis,
lock histories (LH) are used [4], [24], [30], [31], albeit at a
higher cost. For nested locks, it was shown [24] that pairwis e
reachability can be reasoned in O(m+n), wheremandn
are the number of lock/unlock events in the history of the
respectivethreads.Particularly,an atomicitycheckingt ool was
proposed [5] that used data abstraction under nesting locki ng
for reasoning pairwise reachability.
For non-nested locks, it was shown [4] that pairwise reach-
ability can be reasoned in O(|T|2· |M|2), where |M|is
the maximum length of the synchronization events such as
lock/unlock and wait/notify. It involves building a univer sal
causality graph (UCG) using various synchronization event s
and checking if it is acyclic. Each directed edge in the
graph corresponds to happen before induced by wait/notify
events and potential race events. A cycle in the graph implie s
infeasibility, however, absence of a cycle does not imply
feasibility of a consistent sequence of lock events in gener al.
For a two-threaded program, it was shown that acyclicity
is both a necessary and sufﬁcient condition for reasoning39TABLE I: Comparing Tools for Predictive Testing.
jPredictor
PENELOPE
UCG
PECAN
BEST
CP
ExceptioNULLFeatures[1][5][4][32][18] [8][9]iPA
Prediction Hybrid HB LHGraph-based LHSMTHybrid HB SMTTLH
Search scope PPF PFPPF
Partial/Full trace
Data abstraction noyesyes yesyes noyesyes
Non-nested locks nonoyes noyes noyesyes
Incremental search nonono nonononoyes
Coverage* ++++++ +++++ +++++++
*: on relative scale, more “+” means better coverage
pairwise reachability under data abstraction. However, fo r a
program with more than two threads, acyclicity was shown to
be only the necessary but not the sufﬁcient condition [4], i. e.,
a false positive may occur.
To improve accuracy of prediction yet further, more heavy-
weight approaches such as SAT/SMT-based symbolic analy-
sis [3], [6], [7], [9], [18] are proposed. Although a symboli c
analysis can provide better precision and prediction, its h igh
overhead prohibits its use for traces of sizes more than tens
of thousands. To reduce the analysis cost, some methods
use a ﬁxed-size exploration window (bounded search) for re-
ordering events [1], [8], some others use a restrictive form of
lock synchronization (nested locks only) [5], [8], [32], wh ile
some use a ﬁxed-number of read/write pairing combined with
SMT analysis [9]; all of which can lead to false positives
and/or false negatives. The graph-based analysis [4] is in-
herently non-incremental as the acyclic check is done on a
graph built speciﬁcally for each problem instance; moreove r,
it deduces synchronization-induced edges indirectly, fur ther
adding to the analysis cost. Clearly, these search engines a s
such are not geared for incremental reasoning of multiple
problems frequently arising during a run of a real applicati on
with a general locking scheme. In Table I, we compare
qualitatively state-of-the-art predictive analysis tool s [1], [4],
[5], [8], [9], [18], [32] against our tool iPA.
DPOR-based approaches [21]–[23] explore interleaving
space by executing each interleaving, while iPAexplores
the space using light-weight static analysis. Unlike DPOR,
iPAuses lookahead to check if both ordering need to be
explored to avoid inconsistent/redundant interleavings. iPAis
goal-directed, stateful, and incremental; while DPOR is pa th-
coverage directed, stateless, and systematic.
Outline: We provide necessary background in Section II,
and present our approach in Section III. We discuss our
experiments in Section IV, proofs in Section V, and conclude
in Section VI.
II. PRELIMINARIES
A multi-threaded program consists of a set of concurrently
executing threads T, each thread with a unique identiﬁer t.
The threads communicate with shared objects, some of which
are used for synchronizationsuch as locks and signals. A tra ce
of a program πis a total ordered sequence of observed events
corresponding to various thread operations on shared objec ts.
Eachevent eofthe sequence,i.e., e∈πiscarriedoutbysome
thread denoted as tid(e)at a thread location loc(e). These
events include the following:•write/read(t,x) : write/read by ton memory object x
•lock/unlock(t,l) : acquire/release by ton a lock l
•wait/notify(t,s) : wait/notify by ton a signal s
•fork(t,t’)/thread start(t’) :tforks a thread t′
•join(t,t’)/thread end(t’):twaits until t′ends
Letc=loc(e)andc′=loc(e′). We say the pair (c,c′)
ispairwise reachable , iff the respective threads can be at
thoselocationssimultaneously.Thecorrespondingevents e,e′,
however, may not be enabled simultaneously. When obvious
fromthecontext,weuse (e,e′)toreferthelocationpair (c,c′).
A pair of read/write accesses on the same shared object
isconﬂicting if at least one of the accesses is write. A data
raceoccurs when the memory accesses by two threads are
conﬂicting, and the access locations are pairwise reachabl e.
Happens-before . Given a program trace π, ande,e′∈π,
we sayemayhappens-before e′, i.e.,e/precedesequale′, ifeisobserved
beforee′in the trace. Notably, ecompletes beforee′. We say
emusthappens-before e′(causally-ordered), i.e., e≺e′, if
e/precedesequale′holds and one of the following holds:
•e,e′are in thread (program) order, i.e., e≺poe′
•e=notify(t,s)ande′=wait(t′,s),t/ne}ationslash=t′
•e=fork(t,t′)ande′=threadstart(t′),t/ne}ationslash=t′
•e′=join(t′,t)ande=threadend(t),t/ne}ationslash=t′
•∃e1∈π.(e≺e1/precedesequale′)or∃e2∈π.(e/precedesequale2≺e′)
In the sequel, we use happens-before (or HB) to denote must
happens-before relation, unless otherwise stated.
Alinearization ofa giventrace π, is a permutationofevents
(∈π) such that causal ordering of events are preserved.
We identify the events wait,threadstart, andjoinas
blocking events ; and the events notify,fork, andthreadendas
the respective unblocking events . For correct synchronization,
a thread has to be in a blocked state by initiating one of the
blocking events ebkbefore the matching unblocking eventeuk
unblocks it, andthe unblocking event “completes” before the
blocking event. We use ≺ub(⊆≺)to denote the happens-
before relation between the matching unblocking event euk
and blocking ebkevent, i.e., euk≺ubebk.
A happens-before relation can be maintained easily using
vector clocks [13], [28], [29]. The relations ≺,≺ubcan be
checked simply by comparing the time stamps (i.e., the vecto r
clocks)oftheevents.Foraconcurrentprogramwith Tthreads,
such a check would cost O(|T|)comparison. We use e≺≻e′
todenotethat e,e′arein-comparable ,i.e.,e/ne}ationslash≺e′∧e′/ne}ationslash≺e.This
occurs if and only if the events e,e′do not have an observed
unblocking/blockingsynchronization in-between. A neces sary
condition for (e,e′)to be pairwise reachable is e≺≻e′.
Write-Read dependency . We say two events e=
write(t,x)ande′=read(t′,x)have write-read dependency
ift/ne}ationslash=t′,e/precedesequale′, andeis the last write to xbeforee′.
We refer to a linearization obtained without considering
write-read dependency on non-synchronization memory ob-
jects asdata abstraction . In this work, we consider lineariza-
tion based on data abstraction, although one can include suc h
dependencybyenforcinghappens-beforeorderingbetweent he
memory accesses. Note, including write-read dependency ca n
eliminate infeasible linearization, but may miss feasible ones.
Locking. Innested locking , all locks follow a simple rule: a
lockthatis ﬁrst acquiredisreleasedthe last. A lockingsch eme
that does not follow the nesting rule is often termed as non-
nested locking . In this work, we consider the general form of40locking, i.e., re-entrant, nested, and non-nested. For re-entrant
lockswhere lock can be acquired by a thread multiple times
without releasing, we record the ﬁrst lock and the last unloc k
operations for each re-entrant lock.
Alocksetis a set of locks held by a thread at location
c, denoted as LS(c). When c=loc(e), we use LS(c)and
LS(e)interchangeably. A necessary condition for (e,e′)to
be pairwise reachable is that LS(e)∩LS(e′)=∅.
Time-stamped Lock History (TLH): Given a thread taat
its current location ⊢a, a time-stamped lock history denoted as
Ha=/an}bracketle{ta1·a2···am/an}bracketri}htis a thread-order sequence of observed
lock/unlock events (referred henceforth as TLH events) whe re
each event is tagged with a time stamp (maintained using
vector clocks), and amis the last such event before ⊢a. A
happens-before ordering between TLH events of two threads
can be checked using time stamps in O(|T|)time.
We usenext(e)/prev(e)to denote the next/previous TLH
event w.r.t. an observed event e, respectively. For e.g., a2=
next(e)where (e=a1) or (a1≺poe≺poa2). Similarly,
a1=prev(e)where (e=a2) or (a1≺poe≺poa2).
Consistent Sequence : We say a total-ordered interleaved
sequence of TLH events is consistent iff the following two
conditions are satisﬁed: (a) between any two consecutive lo ck
events there is an unlock event on the same lock object by
a thread doing the ﬁrst lock (i.e., mutual exclusion), and
(b) TLH events follow the happens-before (≺)ordering (i.e.,
causal ordering). If (a,b)is pairwise reachable, and there
exists a consistent sequence of TLH events starting from
(a,b)such that inter-thread events a′,b′are adjacent in the
sequence, then we say (a′,b′)(i.e.,(loc(a′),loc(b))is also
pairwise reachable . The reasoning of pairwise reachability
is then reduced to checking existence of such a consistent
sequence from previously established/known reachable pai rs.
Equivalency : Two sequences of synchronization events
/an}bracketle{te1···ei·ei+1···en/an}bracketri}htand/an}bracketle{te1···ei+1·ei···en/an}bracketri}htareequivalent
ifei,ei+1do not occur on the same synchronization object.
The rule can be applied transitively to show equivalency.
III. OURAPPROACH
As mentioned before, our primary goal is to show that
there exists some consistent sequence of TLH events without
constructingortraversingtheentirelocksetgraph.Speci ﬁcally,
we take the following steps for checking multiple pairwise
reachability problems:
•Reduce the effective length of TLH by selecting a suitable
starting pair that is also pairwise reachable.
•Identify and avoid redundant and inconsistent sequences.
•Incrementalsearchtoamortizethecostformultiplechecks .
Predictive testing . Before we delve into details, we present
an overview of predictive testing using incremental Predic tive
Analysis ( iPA) as shown in Figure 3. During the execution
of a program under a given test input, the recorder observes
various synchronization events as they occur. The module
Check reachperforms reasoning of pairwise reachability,
and may not wait for the recording of the full trace. For
data race checking, it is invoked whenever a read/write even t
occurs, and each such access is then paired with the observed
conﬂicting reads/writes. It ﬁrst prunes away non-racy pair s
using lockset (LS) and happens-before causal ordering (HB)
analysis, before applying TLH analysis as discussed next./g90/g286/g272/g381/g396/g282/g286/g396/g62/g94/g3/g1085/g3/g44/g17/g3
/g4/g374/g258/g367/g455/g400/g349/g400/g100/g62/g44/g3
/g4/g374/g258/g367/g455/g400/g349/g400
/g894/g282/g381/g890/g400/g286/g258/g396/g272/g346/g895
/g449/g349/g410/g374/g286/g400/g400/g3/g400/g272/g346/g286/g282/g437/g367/g286/g90/g286/g393/g367/g258/g455
/g258/g271/g367/g286/g845
/g87/g396/g286/g282/g349/g272/g410/g349/g448/g286/g3/g100/g286/g400/g410/g349/g374/g336/g455/g286/g400
/g374/g381/g381/g271/g400/g286/g396/g448/g286/g282/g3/g286/g448/g286/g374/g410/g400/g454/g1012/g1010/g3/g3/g17/g349/g374/g258/g396/g455/g3/g3/g3/g3/g3/g1085/g3/g100/g286/g400/g410/g3/g282/g258/g410/g258/g349/g87/g4 /g894 /g18/g346/g286/g272/g364/g890/g396/g286/g258/g272/g346 /g895
Fig. 3: Predictive testing with iPA.
The search module generates witness schedules for a post-ru n
validation with an independent replayer that reports wheth er
the schedule was replayable or not.
Procedure 1 Check reach: Check pairwise reachability
1input:Given TLHs Ha=/an}bracketle{ta1···am/an}bracketri}htandHb=/an}bracketle{tb1···bn/an}bracketri}htof threads
taandtb, with their current events ⊢aand⊢b, respectively.
2goal:Check if ( ⊢a,⊢b) is pairwise reachable.
3output: success/fail
4
5// Check HB criteria
6if(⊢a≺ ⊢b)or(⊢b≺ ⊢a)return fail
7// Check lockset criteria
8if(LS(⊢a)∩LS(⊢b)/ne}ationslash=∅)return fail
9
10// Ref. Section III-A
11Let(astart,bstart)be the start-TLH-event pair.
12LetELbe a snapshot of TLH events (ref. Eqn 1)
13
14// Search pairwise reachability from (astart,bstart)
15return dosearch((astart,bstart),(⊢a,⊢b))
We now describe the procedure Check reach.
Basic check (lines 6–8). We check if the pair (⊢a,⊢b)has
a causal ordering or an intersecting locksets. If any of the
criteria holds, we return faildenoting unreachability. This
step is similar to runtime race detectors such as [13]–[15].
Identify start-TLH-event pair (lines 11-12). We ﬁrst iden-
tify a pair (astart,bstart)whereastart∈ /an}bracketle{ta1···am/an}bracketri}ht, and
bstart∈ /an}bracketle{tb1···bn/an}bracketri}htto start the search. Evidently, such a
pair could reduce the search complexity to O(δa·δb)where
δa,δbare the lengths of the reduced sequence /an}bracketle{tastart···am/an}bracketri}ht
and/an}bracketle{tbstart···bn/an}bracketri}ht, respectively. To identify such a starting
pair, we use a snapshot, i.e., collect a set of lock events per
thread whenever an unblock event occurs (discussed more in
Section III-A). Since the pair is observed reachable, we can
guarantee no false positive.
Search for reachability (line 15). We invoke a recursive
procedure dosearch(Table III) to search for a consistent
sequenceofthe TLH eventsin Ha,Hbfrom(a,b)to(⊢a,⊢b).
We discuss more in Section III-B.
We have two contrasting strategies (complementary in
strengths): strategy-I andstrategy-II . Instrategy-I ,
we ignore TLHs of the remaining threads ( /ne}ationslash=ta,tb). In this
strategy,if failisreturned,thepairisguaranteedunreachable
(Theorem 2); however, if success is returned, the pair may
be unreachable (false positive). In strategy-II ,we consider
the TLHs of remaining threads to guarantee the pairwise
reachability if success is returned (Theorem 3). However,
iffailis returned, the pair may still be reachable (false
negative). For two threads, the results of strategy-I or
strategy-II is guaranteed, i.e., a success result implies41reachability and a failresult implies unreachability (The-
orem 1). The search complexity of either strategy-I or
strategy-II isO(δa·δb).
A. Selecting Start-TLH-Event Pair
Consider two threads taandtbat their current locations
⊢aand⊢b, respectively, and their respective TLHs Ha=
/an}bracketle{ta1···am/an}bracketri}htandHb=/an}bracketle{tb1···bn/an}bracketri}ht(Figure 4). We identify
events using the following legends: a dotted box for a shared
read/write event, an unﬁlled box for a block/unblock event,
and a ﬁlled box for a lock/unlock event.
Leteukandebkbe the matching unblocking and blocking
events between taandtb, resp. In the example, eukis a notify
event atta, andebkis a wait event at tb. LetA,Bdenote the
respective thread locations of these events, i.e., A=loc(euk),
andB=loc(ebk). LetA′,B′denotenextthread locations
after these events occurred.
Lemma1:The pair (A′,B′)is pairwise reachable.
Proof. For correct synchronization, the blocking operatio n
ebkhas to block the thread before the unblocking event eukof
the otherthreadoccurs.However,as eukcompletesbefore ebk,
(A,B)has to be pairwise reachable. As tbgets unblocked,
(A′,B′)becomes pairwise reachable. (One can show that
(A′,B)and(A,B′)are pairwise unreachable.) /squaresolid
Letai+1(bj+1)be the next lock eventof ta(tb)afterA′(B′)
resp., and euk/ebkbe the last matching unblocking/blocking
events between taandtbresp., in a run.
Lemma2:The pair (ai+1,bj+1)is pairwise reachable un-
der data abstraction.
Proof. Follows from Lemma 1, and our assumption that
euk/ebkare the last matching unblock/block events. /squaresolid
We select (ai+1,bj+1)as the starting lock event pair. Note,
ifA′,B′locationscorrespondto lockeventsi.e., A′=loc(ai+1)
andB′=loc(bj+1)(left of Fig. 4), then clearly (ai+1,bj+1)
is also pairwise reachable as per Lemma 1. In the running
example (Fig. 1), we select (a3,b4)as the starting pair, as the
last matching notify/wait pair occur just before that.
Although the above case is not common, typically what
we found is that for a matching wait/notify pair (such as in
pthread cond waitandpthread cond signal),B′is
a location of a locking event which is eventually enabled by
an unlocking event ewhere (e=ai+1) or (ai+1≺poe). In
such a case, (ai+1,bj+1)is also pairwise reachable.
How to select a start-TLH-event pair if there is no matching
unblock/block events between taandtbso far in the run?
We illustrate the case in Figure 4 (right), where there are no
matchingunblock/blockeventsbetween ta,tb.Notethatsucha
situationcan onlyoccurwhenthereare morethan two threads .
Letebkdenote the last blocking event by tdw.r.t.⊢aand
⊢bin the observed run, and let eukdenote the corresponding
unblocking event by tc. Letsnapshot1denote a set of lock
events, one per thread, recorded at the instant eukcompletes.
1We use a global lock to take a snapshot. A snapshot can be taken
at any moment, however, we take it at the synchronization eve nts such
as blocking/unblocking. The argument is that these synchro nization points
between threads are chosen by developers, and they are inten ded to occur
deterministically at those program points.bel
bnceltb tc
b1 c1
blast unblock/
block events
deltd
d1
ael
amta
a1
aeukebk
ELaiA
A’B
B’wait
A= loc(notify ); A’= loc after notify
B= loc(wait); B’= loc after wait
For matching wait-notify events:
(A, B) & (A’,B’) are pairwise reachable 
(A’,B) &  (A,B’) are pairwise unreachable.ai+1
ambj
bj+1
bnta tb
a1 b1
ablast unblock/
block eventslock/unlock eventsblock/unblock eventsshared read/write events
euk ebk notify
Fig. 4: Example to illustrate start pair selection: (Left) matchin g
unblock/block events occur between ta,tb, (Right) no matching
unblock/block events occur between ta,tb.
Given the set snapshot , we obtain a set ELof TLH events
as follows:
EL={le|le=next(e)wheree∈snapshot }(1)
As shown in right of Figure 4, we obtain EL=
{ael,bel,cel,del}corresponding to euk. Depending on our
strategy, we select the start pairs2as follows:
strategy-I : We use (a1,b1)as the starting pair in our
search for reachability. It is a conservative choice to guar antee
no false negative for a given run.
strategy-II : We use (ael,bel)as the starting pair. As per
Lemma 2, (ael,bel)is pairwise reachable. We also compute
and use the set ELfor both cases shown in Figure 4, to
consider possible interference due to the other threads, an d
thereby, guarantee no false positive under data abstractio n.
B. Search for Reachability and Witness Generation
The recursiveprocedure dosearch(shownin Table III) is
used to check the pairwise reachability of (⊢a,⊢b)from(a,b)
and to ﬁnd a consistent sequence if and only if it is reachable .
If it ﬁnds one, it will return success, otherwise, it will return
fail. Each recursive call corresponds to a traversal of an edge
in LG graph (Figure 5). Note, a return with failin a nested
sub-procedure indicates the search is not over yet.
Foreaseofreadabilitywedividedthechecksin dosearch
into three groups: A,B, and C. A check in each group
determines what action to be taken when the check condition
holds. If a check condition does not hold, the check listed in
the following row is applied. For e.g., if VC: Revisit check
listed in row 1 succeeds, then the recursive sub-procedure
returnsfail, otherwise, the check in the next row, i.e., TC:
Terminal check is applied. The checks 1–16 make at most
one recursive call, and are intended to prune the search by
avoiding inconsistent and redundant recursive calls. In th e
worst case, when none of the conditionsin checks 1–16 holds,
dosearchwill be called on (a,next(b))and(next(a),b).
For incrementalsearch, we also recorda subset of reachable
pairs as established during the search in a set incpairs. We
mark those checks with “*” (shown in 3rd column, Table III)
to indicate that the pair (a,b)will be stored for a potential
start pairs. We will discuss more in Section III-C.
2We assume that there is no established reachable pair by our p revious
search; otherwise, we select that as the start pair.42Witness generation is quite straightforward. It basically in-
volvesconcatenationoftwosequences:onethatestablishe sthe
reachability of start-TLH pair, i.e., (a,b)(which could be the
preﬁxoftheoriginaltraceorapreviouslyestablishedsequ ence
to reach(a,b)), and the other that shows the reachability of
(⊢a,⊢b)from(a,b).
TABLE II: A run of Check reachon reachability of (a10,b10).
Visited
pairsNext pair CheckAvoided
pairsincpairs
(a3,b4)(a4,b5)RC3(a3,b5),
(a4,b5){}
(a4,b5)(a5,b5)RC4(a4,b6){(a4,b5)}
(a5,b5)(a6,b5)RC2(a5,b6){(a4,b5)}
(a6,b5)(a6,b6)RC5(a7,b5){(a4,b5),(a6,b5)}
(a6,b6)(a7,b6)RC7(a6,b7){(a4,b5),(a6,b5),(a6,b6)}
(a7,b6)(a8,b6)LCC4(a7,b7){(a4,b5),(a6,b5),(a6,b6)}
(a8,b6)(a9,b6)LCC4(a8,b7){(a4,b5),(a6,b5),(a6,b6)}
(a9,b6)(a10,b6)LCC4(a9,b7){(a4,b5),(a6,b5),(a6,b6)}
(a10,b6)(a10,b7)LCC3- {(a4,b5),(a6,b5),(a6,b6),(a10,b6)}
(a10,b7)- LCC2- {(a4,b5),(a6,b5),(a6,b6),
(a10,b6),(a10,b7)}
Example. We illustrate a run of Check reachin Figure 5
on checking reachability of (a10,b10)starting from (a3,b4).
We use a •/◦to denote a visited/unvisited pairs, resp; a △
to denote a start-TLH-event pair; a thick/thin arrow to show
the visited/unvisitededges,resp.; a cross ‘X’ to denoteth at the
lockeventisdisabled.Wealsoshowthelocksetsateachthre ad
location. In Table II, we show the scenarios used for detecti ng
corresponding cases where we avoid exploring both ordering
of TLH events. For now, ignore the Column with incpairs,
and distinction between bold and not bold pairs within the
avoided pairs, which we will discuss in Section III-C. In
the lattice of Figure 5, there are a total of 97edges, but
the procedure dosearchmakes only 8 recursive calls (i.e.,
visited edges) to show the pair ( a10,b10) unreachable.
C. Incremental Search
The procedure dosearchcan be used incrementally for
checking multiple pairwise reachability problems that ari se
frequently during race detection, especially, when the pai rs
underconsiderationshaveoverlappingTLHs.In the followi ng,
we discuss one such way that uses the visitedstate infor-
mation and incpairsset of pairs gathered during calls to
Check reach(checks marked with “*” in Table III).
Theincpairsis a subset of reachable pairs which are not
required to be explored in the last call of Check reach, but
may be required in future search due to new TLH events. As
shown in Table II, some of the avoided pairs (i.e., not shown
inbold) may need to be explored. We update the incpairs
accordingly in RC4, RC5, RC7, LCC3, and LCC2 checks.
Note, those avoided pairs shown in boldare truly redundant,
and are not required to be re-explored. For e.g., (a4,b6)pair
is not required for exploration in the last search due to RC4
check. However, with a new TLH event lock(ta,L3)ata10,
we may need to re-evaluate RC4 check for a future search.
Therefore, we update the set incpairswith(a4,b5).
Assume that we invoke Check reachfor given TLHs
Ha,HbwhereHa=/an}bracketle{ta1···am/an}bracketri}htandHb=/an}bracketle{tb1···bn/an}bracketri}ht,
starting from the pair (astart,bstart). LetNHa,NHbdenote
the updated TLHs where NHa=Ha· /an}bracketle{tam+1···am′/an}bracketri}ht,
andNHb=Hb· /an}bracketle{tbn+1···bn′/an}bracketri}ht. Assume that the start-
TLH-event pair (astart,bstart)used in the previous call(a3,b4)
L3(a4,b4)
(a5,b4)
(a10,b4)(a6,b4)
(a6,b10)(a5,b10)(a4,b10)(a3,b10)UL1
L2
L0
UL3
(a7,b10)UL0UL3
L2
UL1L1
UL2(a3,b5)
(a3,b6)
(a3,b7)
(a3,b8)
(a3,b9)
L0
UL2(a7,b4)
(a8,b4)
(a9,b5)
(a8,b10)
(a9,b10)
(a10,b10)/g898/g62/g1005/g899/g923/g271/g1008
/g898/g899/g923/g271/g1009
/g898/g62/g1007/g899/g923/g271/g1010
/g898/g62/g1006/g853/g62/g1007/g899/g923/g271/g1011
/g898/g62/g1004/g853/g62/g1006/g853/g62/g1007/g899/g923/g271/g1012
/g898/g62/g1004/g853/g62/g1006/g899/g923/g271/g1013
/g898/g62/g1006/g899/g923/g271/g1005/g1004/g898/g62/g1007/g853/g62/g1006/g899/g923/g258/g1007
/g898/g62/g1006/g899/g923/g258/g1008
/g898/g62/g1006/g853/g62/g1005/g899/g923/g258/g1009
/g898/g62/g1005/g899/g923/g258/g1010
/g898/g62/g1005/g853/g62/g1006/g899/g923/g258/g1011
/g898/g62/g1006/g899/g923/g258/g1012
/g898/g62/g1004/g853/g62/g1006/g899/g923/g258/g1013
/g898/g62/g1004/g899/g923/g258/g1005/g1004
Lwait edge/g28/g282/g336/g286/g400/g3/g410/g396/g258/g448/g286/g396/g400/g286/g282Starting pair
Candidate  start pair 
for  future  search
Visited pairUnvisited pair/g28/g282/g336/g286/g400/g3/g374/g381/g410/g3
/g410/g396/g258/g448/g286/g396/g400/g286/g282
Fig. 5: Check reachability of (a10,b10).
ofCheck reachhas not changed. We start the procedure
dosearchonlyfrom the pairs in the set incpairs, and use
thevisitedstate information to avoid exploring the already
visited pairs. As each pair p∈incpairsis reachable from
(astart,bstart), the reachabilityfrom pimpliesthe reachability
from(astart,bstart).
The main observation is that only the pairs in the set
incpairsare required to be re-checked, as the redundancy
conditions (RC4-RC7) and terminal conditions might have
changed due to the new TLH events. If there exists a match-
ing unblocking/blocking events (euk,ebk)that happens after
(am+1,bn+1), i.e., (am+1≺poeukandbn+1≺poebk) or
(am+1≺poebkandbn+1≺poeuk), we use TLH event pair
(next(euk),next(ebk))asthestartingpair(ref.SectionIII-A).
Example. We show how we incrementally check the reach-
ability of pairs (a10,b11),(a11,b10), and(a11,b11), as shown
in the Figure 6. We start with the pairs in the set incpairs
as shown in △. We avoid the nodes that are already visited
(shown with oval circle). We explore the alternate paths
from the pair (a6,b5)as RC5 check fails due to the new
eventlock(ta,L3)ata10. Similarly, we explore the alternate
path from the pair (a6,b6). The newly explored edges and
nodes are indicated in the ﬁgure. We ﬁnd that the pairs
(a10,b6),(a10,b7)are deadlock states (true if found using
strategy-II under data abstraction, Theorem 3). Further,
we ﬁnd that the pairs (a10,b11)and(a11,b11)are reachable
(indicating two write-write races), and that the pair (a11,b10)
is unreachable. The incremental search makes 13 recursive
calls, with a total of 21 (=13+8) total calls for solving the
four target pairs. Without incremental search but using our
pruning (as described in the previous section), we would
require 71 (=8+21*3) calls. Without any pruning checks, we
would require 446 recursive calls equal to the sum total of al l
the edges in the lock-order graphs, one graph per target pair .
Our incremental reasoning framework is geared for pre-
dictive testing with runtime analysis. The key engineering
challenge we solve in this work is to achieve similar accurac y
and coverage of UCG approach [4], andobtain comparable
performance of runtime race detectors [13]–[15].43TABLE III: Checks in a recursive procedure dosearch(a,b). If a check condition does not hold, the next check in the row i s applied;
otherwise, the corresponding action is taken as indicated i n the last column. For checks mark with ’*’, the pair (a,b)is also stored in a set
incpairsfor incremental search. Strategy-II includes all the checks, while Strategy-I includes all but row 7.
Checks in do search(a,b) If the condition holds,
Group #Type Description Return fail/success or
recurse
1VC: Revisit Check if (a,b)was previously visited Returnfail
2TC*: Terminal Check if (a,b)is(⊢a,⊢b), i.e, terminal pair Returnsuccess
A:Basic checks 3HB: Happens-before Check if (a≺b) Return dosearch(next(a),b)
4HB: Happens-before Check if (b≺a) Return dosearch(a,next(b))
5LCC1: Deadlock Check if threads ta,tbdeadlocks Returnfail
B: Inconsistency
checks6LCC2: Stall Check if one thread is waiting for a lock held by the other thre ad,
while all events in TLH of the other have been traversedReturnfail
7Strategy-II Check if Strategy-II is selected and there exists a thread /ne}ationslash=ta,tbthat
is waiting for a lock held at loc(le)or somele≺a,b,wherele∈ELReturnfail
8LCC3: Lock consistency Check if a=⊢aornext(a)is disabled due to a lock held by tbatbReturn dosearch(a,next(b))
9LCC4: Lock consistency Check if b=⊢bornext(b)is disabled due to a lock held by taataReturn dosearch(next(a),b)
10RC1: Redundancy Check ifaislock(l)andbisunlock(l′)andl/ne}ationslash=l′(apply Lemma 3) Return dosearch(a,next(b))
11RC2: Redundancy Check ifaisunlock(l)andbislock(l′)andl/ne}ationslash=l′(apply Lemma 3) Return dosearch(next(a),b)
C: Simpliﬁcation
checks12RC3: Redundancy Check if aisunlock(l)andbisunlock(l′)andl/ne}ationslash=l′(apply
Lemma 4)Return
dosearch(next(a),next(b) )
13RC4*: Redundancy Check if aislock(l)andbislock(l′)andl/ne}ationslash=l′andunlock(l)/ne}ationslash∈
/an}bracketle{tb···bn/an}bracketri}ht(apply Lemma 5)Return dosearch(next(a),b)
14RC5*: Redundancy Check if aislock(l)andbislock(l′)andl/ne}ationslash=l′andunlock(l′)/ne}ationslash∈
/an}bracketle{ta···an/an}bracketri}ht(apply Lemma 5)Return dosearch(a,next(b))
15RC6*: Redundancy Check if aislock(l)andbislock(l′)andunlock(l)/ne}ationslash∈
/an}bracketle{ta···an/an}bracketri}ht(l,l′same or different) (apply Lemma 6)Return dosearch(a,next(b))
16RC7*: Redundancy Check if aislock(l)andbislock(l′)andunlock(l′)/ne}ationslash∈
/an}bracketle{tb···bn/an}bracketri}ht(l,l′same or different) (apply Lemma 6)Return dosearch(next(a),b)
17Default: No pruning When none of the above check holds Return dosearch(a,next(b)) or
dosearch(next(a),b)
IV. EXPERIMENT
Weimplemented iPAmoduleinanx86binary-basedpredic-
tive testing framework (Figure 3). At runtime, the applicat ion
binary and dynamically loadable libraries such as pthread
are instrumented (by a recorder module) using PIN [33] a
dynamic instrumentation tool. The recorder observes vari-
ous synchronization events such as wait/notify, lock/unlo ck,
create/start, end/join, sem wait/sem post, and heap memory
accesses. In this experiment, we evaluate our approach on
reachability problems arising from predicting data races. Our
implementation of HB and Lockset analysis ( Basic Check ,
Procedure 1) closely follow that of race detectors [13]–[15 ].
We did not experimentally compare with UCG [4] as the
known implementation is not engineered to handle so many
reachability problems. We experimented on a 32-bit linux bo x
with Intel(R) CPU Q6600 2.4GHz with 4GB memory.
Benchmarks & Evaluation . We used 8 multi-threaded pub-
licly available applications(written in C/C++/Java )with 1K-
33K LOC. We used gcc/g++/gcj compilers to transform
C/C++/Java programs to x86 binaries. Table IV gives a
short description of these applications. We ran two sets of
experiments, one to evaluate the performance of our approac h
(Section IV-A), and second to compare incremental vs. non-
incremental search (Section IV-B).
A. Pairwise Reachability (Data Race) Results
We raneachapplicationwith differentthreadsettingsand/ or
test inputs. We evaluate performance of our online reasonin g
in predictingdata races, and reportresultsin Table V. We us ed
incremental search in this evaluation.
For each application (Column 1), we provide trace in-
formation (Columns 2–8), race results with HB, lockset
analysis (Columns 9–11), race results with our Check reach(a3,b4)
L3(a4,b4)
(a5,b4)
(a10,b4)(a6,b4)
(a3,b10)UL1
L2
L0
UL3
UL0UL3
L2
UL1L1
UL2(a3,b5)
(a3,b6)
(a3,b7)
(a3,b8)
(a3,b9)
Lwait edge/g28/g282/g336/g286/g400/g3/g410/g396/g258/g448/g286/g396/g400/g286/g282L0
UL2(a7,b4)
(a8,b4)
(a9,b4)/g898/g62/g1005/g899/g923/g271/g1008/g898/g62/g1007/g853/g62/g1006/g899/g923/g258/g1007
/g898/g62/g1006/g899/g923/g258/g1008
/g898/g62/g1006/g853/g62/g1005/g899/g923/g258/g1009
/g898/g62/g1005/g899/g923/g258/g1010
/g898/g62/g1005/g853/g62/g1006/g899/g923/g258/g1011
/g898/g62/g1006/g899/g923/g258/g1012
/g898/g62/g1004/g853/g62/g1006/g899/g923/g258/g1013
/g898/g62/g1004/g899/g923/g258/g1005/g1004/g898/g899/g923/g271/g1009
/g898/g62/g1007/g899/g923/g271/g1010
/g898/g62/g1006/g853/g62/g1007/g899/g923/g271/g1011
/g898/g62/g1004/g853/g62/g1006/g853/g62/g1007/g899/g923/g271/g1012
/g898/g62/g1004/g853/g62/g1006/g899/g923/g271/g1013
/g898/g62/g1006/g899/g923/g271/g1005/g1004
(a11,b11)(a3,b11)UL2
/g898/g899/g923/g271/g1005/g1005
(a11,b4)/g898/g62/g1004/g853/g62/g1007/g899/g923/g258/g1005/g1006L3
Last visited pairStarting pair
Candidate  start pair 
for  future  search
Visited pairUnvisited pair/g28/g282/g336/g286/g400/g3/g374/g381/g410/g3
/g410/g396/g258/g448/g286/g396/g400/g286/g282
Fig. 6:Check reachability of pairs (a10,b11),(a11,b10),(a11,b11)
incrementally.
TABLE IV: Short description of multi-threaded applications.
Apps Description (Ver, LOC, Lang)
account A concurrent handler for banking transactions [34] (145, Java).
aget A parallel HTTP download accelerator [35] (aget-0.4, 1.2K, C).
alsa A PCM player for unix/linux using ALSA library [36] (alsapla yer-
0.99.81, 33K, C++).
axel A concurrent replacement of wget [35] (axel-1.0b, 3.1K, C).
bzip A parallelizer of BZIP2 for SMP [36] (bzip2smp-1.0, 6.4K, C)
elevator An elevator application [37] (553, Java).
proz An HTTP/FTP downloader with multiple connections to multip le
servers [36] (prozilla-2.0.4, 2.7K, C++).
tsp A concurrent solver for traveling salesman problem [37] (71 3,Java).44TABLE V: Pairwise Reachability (Predicting data races).
1234567891011 12131415 16171819202122
Trace Information Race w/ HB, lockset Race w/ Check reach (I) Race w/ Check reach (II) Racy src lines
Apps events vars hb∩timehb∩ls#timeovhdhb∩ls#timeovhdpredtrueupper
nmelecemvlvcvhbls(sec) ∩tlhcalls(sec)(%)∩tlhcalls(sec)(%)racesracesbound
1238917K12532661831839.93 183169110.020.9 9432210.051.25511account719916K72820687879.87 876819.920.5 391279.971.05411
6350274102851523527053.42 270566893.461.2270568483.492.0444aget11684144020535121K9K4.83 9K84K4.881.0 9K77K4.901.4444
64K28164558135732227110.34 265238810.400.6 10023010.400.6362638alsa64K25924758335742937910.26 375252110.361.0 16924610.361.0443753
6467265107513283283.99 328 04.051.5 328 04.123.3333033axel1111323610212519609604.18 960 04.190.2 960 04.272.2333333
4507K357361K5552K52K19.40 703 719.580.9 0119.631.20053bzip8506K3511361K5552K52K19.51 703 719.600.5 0119.630.60053
443318K443202393910.41 392K10.420.1 302.2K10.581.6111elevator533018K7432310262610.28 261K10.30.2 181K10.391.1111
83425672146231513334313.83 4396813.90.5 4370514.001.2444proz13614711322494920198558015.93 580223616.00.4 564164716.301.7335
tsp 6141K18K927K231413M10K40.00 10K630140.20.57957755040.611.5111114
using strategy-I (Columns 12–15), race results with our
Check reachusing strategy-II (Columns 16–19), and
number of source line races (Columns 20–22).
Wealsoobservedthatmanypredictedraces(Column20)are
instances of multiple races of the same source lines execute d
in the same/different threads. To focus on unique source lev el
races that programmers would care to know and eventually
ﬁx, we project reachable pairs (i.e., predicted data races a s
shownin Columns12, 16)onuniquepairsof sourcelines(i.e. ,
x86 instruction addresses). The results are as follows: pred≡
the number of projected pairs found using strategy-II and
reported in Column 16, true≡the number of replayable pred
pairs indicating presence of malign/benign bugs, and upper≡
the number of projected pairs found using strategy-I and
reported in Column 12. We did not report similar counts for
HB+LS analysis as these are the same or more than upper(as
the dynamic counts of HB+LS analysis are same or more than
that of strategy-I ). The description of remaining Columns
2–20 are as follows:
Trace Information (Columns 2–8) . The trace characteristics
ofeachrunareasfollows:thenumberofthreads n,thenumber
of shared memory events me, the number of lock events le,
the number of communication events (blocking/unblocking)
ce, the number of shared vars mv, the number of lock vars
lv, and the number of communication vars cv.
Race w/ HB, lockset (Columns 9–11) . The results of online
detectors are as follows: the number of pairs reachable usin g
HB analysis alone hb, the number of pairs reachableusing HB
and lockset analysis hb∩ls, and the total time taken (in sec)
for HB and lockset analysis (including PIN instrumentation
and application runtime).
Race w/ Check reach (I) (Columns 12–15) . The re-
sults of TLH analysis performed by Check reachusing
strategy-I with incremental search are as follows: the
number of pairs reachable using HB, lockset, and TLH anal-
ysishb∩ls∩tlh, the number of recursive calls made to
dosearch, the total time taken (in sec) for the combined
analysis (including PIN instrumentation and application r un-
time), the time overhead (in %) over HB and lockset analysis.
Race w/ Check reach (II) (Columns 16–19) . The re-
sults are similar to Columns 12–14, but with strategy-II .
Discussion . Comparing the race results of HB+LS analysis
(Column 10), strategy-I (Column 12), and strategy-II
(Column 16), we ﬁnd that both strategies (and even more with
strategy-II ) have better accuracy than HB+LS analysis.Our proposed TLH analysis easily handles trace lengths
rangingfroma fewhundredstohalfamillionevents(Columns
3, 4, 5). The TLH analysis adds less than 4% overhead over
lockset and HB analysis (Columns 15, 19). The end-to-end
online analysis time was found to be very small, less than
a minute for these applications (Columns 14, 18). Moreover,
it narrows down the potential races obtained using HB+locke t
analysis.Forsomeapplicationsuchas bzip,thereductionwas
found to be signiﬁcant. We also observe that the upper bound
on potential races (Column 22) closely matches the predicte d
races (Column 20), indicating a tight bound.
Although we use data abstraction, we could replay most of
the witnesses corresponding to the predicted races (Column s
20 vs 21). The witness trace lengthsrange from a few hundred
to 160K. We observed that the most of these applications we
tested, the shared variables have little role in controllin g the
path of the execution. For effective management of testing
resources, this is an interesting observation as it highlig hts
that the scheduler-dependent bugs can be exposed using ligh t-
weight static analysis with data abstraction.
We do not report the original run time of individual ex-
ecutions. However, HB+LS analysis incur 10-20x slowdown.
This is a typical of DBI-based race detectors such as Google’ s
ThreadSanitizer [15]. Clearly, the overhead of TLH analysi s
is dwarfed by the instrumentation and HB+LS analysis, and
hence, race detection can be augmented with runtime predic-
tion to improve accuracy and coverage, incurring marginal
overhead. Our approach can also be integrated with parallel
data race detection [16] to further improve its performance .
Inalsa, we found many predicted races to be real. In fact,
someofthemalso ledtheapplicationtocrashduringreplay. In
elevator , we found a replayable race that was not reported
by any of previous methods [1], [5], [8] (possibly missed due
to read-after-write constraint). The race involves concur rent
update and read access of Lift.java:count variable. Our
end-to-endcheckingtakesabout11s.Tocompare,PENELOPE
tool [5] takes about an hour for ofﬂine analysis. We found
severalknownracesin account andtsp,andmanypreviously
unreported races in axelandprozapplications.
B. Incremental vs. Non-incremental
We now compare the performance and further details of
online reasoning using strategy-II with and without in-
cremental search as shown in Table VI. For these results, we
carriedoutbothincrementalandnon-incrementalchecksin the45TABLE VI: Incremental vs. Non-incremental search.
123456789101112
Incremental Non-incrementalAppspcc(c/pc)%blccrcc(c/pc)%blccrc
15K3222.2027309046.1 07250account6K1272.1010803565.8 02840
1M6.8K 0.61515.4K068K 6.32.2K47K0aget13M77K0.694371K0473K 3.59.9K335K0
19M2301.20213121.4K 7.3 0340961alsa25K2461.00229121.7K 6.8 04081.2K
00NA0000NA 000alsa00NA0000NA 000
2150.0 000150.0 000bzip2150.0 000150.0 000
447K2.2K 0.502.0K2586.3K 1.4 02.7K3.6Kelevator27K1K3.901K01.5K 5.6 01.4K40
38K7051.8801853001.3K 3.380416435proz214K1.6K 0.86094744610K 4.8605.6K2.1K
tsp1M7.5K 0.66515.2K954K 4.24.7K35K1.8K
same run,ratheron separaterunsforeach case. The rational ity
for doing so is that it is unlikely that the two respective run s
will take the same program path, and therefore, we can not
guaranteethesamenumberofreachabilityproblems.Simila rly
performing results using strategy-I are not presented due
to space constraints.
In Column 2, we present the number of potential recursive
calls made ( pc). The details of actual recursive calls made in
anincrementalsearchis shownin Columns3–7as follows:the
number of actual recursive calls made c(also in Column 17,
Table V), the ratio (in %) of actual to potential calls (c/pc)%,
the number of times both branches were taken b, the number
of times LCC branch were taken lcc, and the number of times
RC branch were taken rc. The Columns 8–12 describe similar
results for non-incremental search.
Discussion . We observe that the number of actual calls
made is a small fraction of the potential calls. Also, the
incremental search reduces the overhead of repetitive sear ch
onoverlappingspacefurtherbyanorderofmagnitudein some
cases, thereby, amortizing the search cost. In the most case s,
check conditions 1–16 holds and the procedure dosearch
avoids re-exploring both ordering of TLH events.
V. SEARCHCORRECTNESS AND COMPLEXITY
Letγarepresent a sequence of TLH events of thread ta,
andγrepresent some sequence of TLH events. Lock objects
l,l′can be same or different
Lemma3:If a sequence σ=lock(ta,l)·γa·unlock(tb,l′)·
γis consistent, then the sequence σ′=unlock(tb,l′)·
lock(ta,l)·γa·γis also consistent.
Lemma4:If a sequence σ=unlock(ta,l)·γa·
unlock(tb,l′)·γis consistent, then the sequence σ′=
unlock(tb,l′)·unlock(ta,l)·γa·γis also consistent.
Lemma5:If a sequence σ=lock(ta,l)·γa·lock(tb,l′)·γ
is consistent and unlock(ta,l′)/ne}ationslash∈γa, then the sequence σ′=
lock(tb,l′)·lock(ta,l)·γa·γis also consistent.
Lemma6:If a sequence σ=lock(ta,l)·γa·lock(tb,l′)·γ
is consistent and unlock(ta,l)/ne}ationslash∈σ, then the sequence σ′=
lock(tb,l′)·lock(ta,l)·γa·γis also consistent.
Theorem 1:For given time stamped lock histories of two-
threadedprogram,the procedureforcheckingpairwise reac ha-
bility Check reachguarantees no false positive and no false
negative under data abstraction (using either strategy I or II).
Proof. The starting pair selected is pairwise reachable as
per Lemma 2. Using Lemmas 3–6, we show that the recursivecalls made on only one branch (in RC1-RC7 checks) do
not affect the reachability. Other checks such as HB1-HB2
and LCC1-LCC4 avoid inconsistent sequence. Thus, if there
exists a consistent sequence, the procedure returns success;
otherwise, it returns fail. The claim follows. /squaresolid
Theorem 2:For given time stamped lock histories of three
ormorethreadedprogram,theprocedureforcheckingpairwi se
reachability Check reachguaranteesno false negativeunder
data abstraction using strategy-I .
Proof. In strategy-I , we ignore the locks held by the
other threads but maintain causal ordering between TLH
events. The starting pair is either reachable as per Lemma 2,
or corresponds to the very ﬁrst TLH events of the respective
threads. If a pair is found unreachable, the pair is indeed
unreachable as holding a lock by a third thread will not affec t
the unreachability result. /squaresolid
Theorem 3:For given time stamped lock histories of three
ormorethreadedprogram,theprocedureforcheckingpairwi se
reachability Check reachguarantees no false positive under
data abstraction using strategy-II .
Proof. If there is a matching unblocking/blocking events
between the corresponding thread pairs, then the starting p air
(astart,bstart)is reachable as per Lemma 2. Otherwise, we
use(astart,bstart)∈EL, where EL corresponds to the most
recent snapshot, as starting pair. This pair can be argued to be
reachable by construction and Lemma 2.
To guarantee no false positive, we show that a third
thread will not interfere with the two threads. Assume that
the procedure returns success with a consistent sequence.
For each a∈ /an}bracketle{tastart···am/an}bracketri}ht,b∈ /an}bracketle{tbstart···bn/an}bracketri}ht,le∈EL
tid(le)/ne}ationslash=ta,tb, the following holds by Strategy-II check
(listed as check 7): ( le≺≻aora≺le) and (le≺≻bor
b≺le), (LS(le)∩LS(a) =∅), andLS(le)∩LS(b) =∅.
Clearly, the sequence is consistent as each le∈ELof a third
thread (/ne}ationslash=ta,tb) will not interfere with it. /squaresolid
Search complexity . We describe the cost of each check in
the procedure dosearch.Costs of each HB checkis O(|T|),
each LCC check is O(|L|),strategy-II check isO(|L||T|),
and RC1–RC7 is O(1), respectively. Thus, each call of
dosearchcostsO(|L||T|). The locksets for each history
event can be computed in O(m+n). If we make recursive
calls by exploring only one branch (i.e., checks 1–16), then
the search complexity is O(m+n), assuming |L|,|T|are
bounded. However, if we traverse both branches btimes, the
search complexity is O(b·(m+n)). In practice b≪(m+n),
and the procedure runs almost in linear time.
VI. CONCLUSION
We presented an effective incremental reasoning to check
pairwise reachability and ﬁnd data races in predictive test ing
of multi-threaded programs. By avoiding the cost of repetit ive
reasoning over redundant and overlapping search space, our
search incurs much smaller overhead. As a proof-of-concept ,
we integrated the search module in a runtime testing, and
show it effectiveness over race detection approaches witho ut
much performance degradation. Our approach compares most
favorably in accuracy, coverage, and performance with othe r
predictive testing tools.46REFERENCES
[1] F. Chen, T. F. Serbanuta, and G. Rosu. jPredictor: A predi ctive runtime
analysis tool for Java. In Proc. of ICSE , 2008.
[2] A. Farzan, P. Madhusudan, and F. Sorrentino. Meta-analy sis for
atomicity violations under nested locking. In Proc. of CAV , 2009.
[3] C. Wang, S. Kundu, M. Ganai, and A. Gupta. Symbolic predic tive
analysis for concurrent programs. In Symposium on Formal Methods ,
2009.
[4] V. Kahlon and C. Wang. Universal Causality Graph: A Preci se Happens-
Before Model for Detecting Bugs in Concurrent Programs. In Proc. of
CAV, 2010.
[5] F. Sorrentino, A. Farzan, and M. Parthasarathy. PENELOP E: weaving
threads to expose atomicity violations. In Proc. of FSE , 2010.
[6] S. Kundu, M. Ganai, and C. Wang. CONTESSA:CONcurrency TE Sting
Augmented with Symbolic Analysis. In Proc. of CAV , 2010.
[7] M. Ganai. Scalable and precise symbolic analysis for ato micity viola-
tions. In Proc. of ASE , 2011.
[8] Y. Smaragdakis, J. M. Evans, C. Sadowski, J. Yi, and C. Fla nagan.
Sound predictive race detection in polynomial time. In Proc. of POPL ,
2012.
[9] A. Farzan, M. Parthasarathy, N. Razavi, and F. Sorrentin o. Predicting
null-pointer dereferences in concurrent programs. In Proc. of FSE ,2012.
[10] S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and T. A nderson.
Eraser: a dynamic data race detector for multithreaded prog rams. In
ACM Trans. Comput. Syst. , 1997.
[11] R. O. Callahan and J.-D. Choi. Hybrid dynamic data race d etection. In
Symposium on Principles and practice of parallel programmi ng, 2003.
[12] U. Banerjee, B. Bliss, Z. Ma, and P. Petersen. A theory of data race
detection. In Proc. of PADTAD , 2006.
[13] E. Pozniansky and A. Schuster. MultiRace: Efﬁcient on- the-ﬂy data race
detection in multithreaded C++ programs. In Proc. of Concurrency and
Computation: Practice and Experience , 2007.
[14] C. Flanagan and S. N. Freund. FastTrack: Efﬁcient and pr ecise dynamic
race detection. In Proc. of PLDI , 2009.
[15] K. Serebryany and Timur Iskhodzhanov. ThreadSanitize r - data race
detector in practice. In WBIA, 2009.
[16] B. Wester, D. Devecsery, P. M. Chen, J.FLinn, and S. Nara yanaswamy.
Parallelizing data race detection. In Proc. of ASPLOS , 2013.
[17] A. Mazurkiewicz. Basic Notions of Trace Theory. In Workshop on
Linear Time, Branching Time and Partial Order in Logics and M odels
for Concurrency , volume 354 of LNCS, pages 285–363. Springer-Verlag,
1988.[18] M. Ganai, N. Arora, A. Gupta, and G. Balakrishnan. BEST: A symbolic
testing tool for predicting multi-threaded program failur es. InProc. of
ASE, 2011.
[19] C.-S. Park and K. Sen. Randomized active atomicity viol ation detection
in concurrent programs. In Proc. of FSE , 2008.
[20] S. Park, S. Lu, and Y. Zhou. CTrigger: exposing atomicit y violation
bugs from their hiding places. In Proc. of ASPLOS , 2009.
[21] C. Flanagan. Verifying commit-atomicity using model- checking. In
Proc. of SPIN Workshop , 2004.
[22] J. Hatcliff, Robby, and M. B. Dwyer. Verifying atomicit y speciﬁcations
for concurrent object-oriented software using model-chec king. InProc.
of VMCAI , 2004.
[23] C. Flanagan and P. Godefroid. Dynamic partial-order re duction for
model checking software. In Proc. of POPL , 2005.
[24] V. Kahlon, F. Ivancic, and A. Gupta. Reasoning about thr eads commu-
nicating via locks. In Proc. of CAV , 2005.
[25] A. Farzan and P. Madhusudan. Causal Atomicity. In Proc. of CAV ,
2006.
[26] V. Kahlon, Y. Yang, S. Sankaranarayanan, and A. Gupta. F ast and
accurate static data-race detection for concurrent progra ms. InProc. of
TACAS, 2009.
[27] V. Kahlon, S. Sankaranarayanan, and A. Gupta. Semantic reduction of
thread interleavings in concurrent programs. In Proc. of TACAS , 2009.
[28] F. Mattern. Virtual time and global states of distribut ed systems. In
Workshop on Parallel and Distributed Algorithms, France , 1988.
[29] J. Fidge. Timestamps in message-passing systems that p reserve the
partial ordering. In Australian Computer Science Conference , 1988.
[30] V.Kahlon. Boundedness vs.Unboundedness oflock chain s: Characteriz-
ing decidability of pairwise cﬂ-reachability for threads c ommunicating
via locks. In Proc. IEEE Symposium on Logic in Computer Science ,
2009.
[31] V. Kahlon. Reasoning about threads with bounded lock ch ains. InProc.
of CONCUR , 2011.
[32] J. Huang and C. Zhang. Persuasive prediction of concurr ency access
anomalies. In Proc. of ISSTA , 2011.
[33] C.-K. Luk, R. S. Cohn, R. Muth, H. Patil, A. Klauser, P. G. Lowney,
S. Wallace, V. J. Reddi, and K. M. Hazelwood. PIN: Building
customized program analysis tools with dynamic instrument ation. In
Proc. of PLDI , 2005.
[34] C. Flanagan and S. Qadeer. A type and effect system for at omicity. In
Proc. of PLDI , 2003.
[35] Geeknet Inc. Freshmeat. http://freshmeat.net .
[36] Geeknet Inc. SourceForge. http://sourceforge.net .
[37] C. von Praun and T. R. Gross. Object race detection. In OOPSLA, 2001.47