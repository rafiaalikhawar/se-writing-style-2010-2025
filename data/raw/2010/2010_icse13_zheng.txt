Path Sensitive Static Analysis of Web Applications
for Remote Code Execution Vulnerability Detection
Yunhui Zheng Xiangyu Zhang
Department of Computer Science, Purdue University
Abstract —Remote code execution (RCE) attacks are one of
the most prominent security threats for web applications. I t is
a special kind of cross-site-scripting (XSS) attack that al lows
client inputs to be stored and executed as server side script s.
RCE attacks often require coordination of multiple request s and
manipulation of string and non-string inputs from the clien t side
to nullify the access control protocol and induce unusual ex ecu-
tion paths on the server side. We propose a path- and context-
sensitive interprocedural analysis to detect RCE vulnerab ilities.
The analysis features a novel way of reasoning both the strin g
and non-string behavior of a web application in a path sensit ive
fashion. It thoroughly handles the practical challenges en tailed
by modeling RCE attacks. We develop a prototype system and
evaluate it on ten real-world PHP applications. We have iden tiﬁed
21 true RCE vulnerabilities, with 8 unreported before.
I. I NTRODUCTION
The Internet has been an important social and business plat-
form for many daily activities, which are usually performed
through web applications (apps). Once a web app is put online ,
it can be accessed and used by anyone around the world. A
large volume of valuable and sensitive user data are process ed
and stored by web apps, making them attractive targets of
security attacks. According to a risk report from IBM [ 3],
in the past a few years, security attacks to web apps have
become the dominant kind of attacks (i.e., 55% of all the
attacks reported in 2010).
Among the web app attacks, Remote Code Execution (RCE)
is one of the most harmful threats [ 2]. It takes advantage of
defects of a web app to inject and execute malicious server-
side script in the context of the targeted app. Consequently ,
the attacker could gain accesses to resources authorized to the
app (e.g. user data in a database). According to a report from
theOpen Web Application Security Project (OWASP), PHP
RCE is the most widespread PHP security issue since July
2004 and thus has been ranked the number one threat on the
web apps security problem list [ 2]. We have also observed
popular apps suffering from RCE defects. One of them has
been downloaded for over six million times.
Essentially, RCE is a special kind of Cross Site Scripting
(XSS) attacks. The root cause is the same as the typical
XSS and SQL injection attacks, which is that invalid client-
side inputs are undesirably converted to scripts and execut ed.
However, RCE attacks are usually much more sophisticated.
A successful RCE attack may require coordinations between
multiple requests to more than one server side scripts. Ther e
may also be requirements on the session of these requests. In
other words, the attacks are stateful, crossing multiple ro undsof communication between a server and a client. Furthermore ,
it demands manipulating both the string and non-string part s
of the client side inputs. In some cases, the inputs have to be
so crafted that they are not even legitimate inputs allowed b y
the client side interface.
There have been a lot of works on detecting SQL injec-
tion [ 20], [31], [18], [33], XSS [ 9], [16], [21], [23], [26], [33],
and HTTP request tampering [ 8], [11] attacks. However, due
to the unique characteristics of RCE attacks, they fall shor t in
detecting and conﬁrming these attacks.
Dynamic tainting based techniques [ 11], [8] can monitor
information ﬂow inside web app execution to determine if any
client side inputs can ﬂow to critical places. They can be use d
to detect runtime instances of RCE attacks, but cannot expos e
vulnerabilities before real attacks are launched.
While static analysis has the potential of exposing vulner-
abilities, most of them [ 20], [31], [27], [33], [34], [35], [17]
cannot cohesively reason about the string and non-string pa rts
of an application and many lack path sensitivity, whereas
RCE attacks require satisfying intriguing path conditions ,
involving both strings and non-strings. Recently, researc hers
have proposed techniques that can model both strings and
non-strings in dynamic symbolic execution of web apps [ 25],
[12]. However, they focus on modeling only the executed
path, whereas vulnerability detection requires modeling a ll
program paths. A more thorough discussion of the limitation s
of existing techniques can be found in Section III.
In this paper, we propose a path- and context-sensitive inte r-
procedural static analysis that detects RCE vulnerabiliti es in
PHP scripts. It features the capabilities of reasoning both the
string and non-string parts of an application in a cohesive a nd
efﬁcient manner, and reasoning across multiple scripts and
requests. It is able to guide exploit generation (i.e. gener -
ating requests with concrete inputs) to conﬁrm the reported
vulnerabilities. It analyzes and encodes PHP scripts as two
kinds of constraints: non-string and string constraints. A novel
algorithm is developed to solve these constraints in an iter ative
and alternative fashion. Real exploits can be composed from
the satisfying solutions.
The contributions of the paper are summarized as follows.
•We develop a static analysis to automatically detect
RCE vulnerabilities in PHP code. The analysis is inter-
procedural, context- and path-sensitive, leveraging a
string solver and a SMT solver.
•We propose to abstract a web app into two separate sub-
programs: one capturing the non-string semantics andsession_name('phpMyAdmin'); 
…
48  if ( $_GET['submit_save'] ) { 
52     file_put_contents ('./config/config.inc.php' ,getConfigFile () ); 
56  } @ setup/config.php 
21  public static function getConfigFile () 
22  { 
26     $c = getConfig (); 
41     foreach ( $c['Servers'] as $id => $server) { 
42        $ret .=  …  .$id .... 
55     } 
76     return $ret; 
78  } @ setup/lib/ConfigGenerator.class.php 
474  public function getConfig () 
475  { 
476     $c = $_SESSION[‘ConfigFile0’] ;
481     return $c; 
482  } @ setup/lib/ConfigGenerator.class.php 
266  if ( $_GET['session_to_unset']) ) 
267  { 
// parse_str() parses the argument into var assignment s .
268     parse_str( $_SERVER['QUERY_STRING'] ); 
276  } @ index.php [3]  Execute the PHP script injected 
Send http://pmaURL/config/config.inc.php 
(a) Exploit steps 
(b) Code snippets relevant to  step [1] (c) Code snippets relevant to  ste p [2] [1]   Session poisoning 
Set $code = urlencode(“ arbitrary_php_script ”)
Send http://pmaURL/index.php?_SESSION[ConfigFile0][Serve rs][ $code ]=0&session_to_unset=1 
[2]  Script Injection: save the poisoned session in a PHP file 
Send http://pmaURL/setup/config.php?submit_save=1 
session_name('phpMyAdmin'); 
33    require ' swekey.auth.lib.php '; 
@ swekey.auth.lib.php 
Fig. 1: RCE in phpMyAdmin v3.4.3 (simpliﬁed)
the other modeling the string related behavior. The two
sub-programs are encoded separately. We also develop a
novel algorithm that solves the two sets of constraints
simultaneously.
•We address a number of practical challenges, including
analyzing across scripts and requests to simulate stateful
attacks, handling dynamic conditional script inclusion,
and modeling session constraints.
•We have evaluated the technique on 10 real world web
applications. We successfully identify 21 RCE vulnerabil-
ities with 8 that have not been reported in the past. We
have conﬁrmed all these vulnerabilities by constructing
real exploits based on the analysis results. The overhead
of our technique is reasonable.
II. M OTIVATING EXAMPLE
We use two examples to motivate our approach.
A. RCE in phpMyAdmin
Recently, a RCE vulnerability was reported for phpMyAd-
min v3.4.31, which is a MySQL database management tool
using a web interface. The vulnerable versions have been
downloaded over six million times according to SourceForge .
Fig.1(a) describes an exploit to the vulnerability, which
consists of three steps. The ﬁrst two are session poison-
ing and script injection . In the ﬁrst step, a crafted re-
quest is sent to index.php to change the conﬁguration
of the server. Instructed by the command session tounset ,
a key-value pair is stored to a special session array
SESSION[ConﬁgFile0][Servers] that is supposed to store the
list of servers under administration. The key-value pair co n-
tains a piece of PHP script $code as the key, which gets
stored to the current session. In the second step, another
request is sent to config.php to save the current con-
ﬁguration, including the information stored in the session
array SESSION[ConﬁgFile0][Servers] by the previous step.
1CVE-2011-2506: http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE -2011-2506Consequently, the provided code piece is stored to a PHP ﬁle,
which gets executed by the request in the third step.
The relevant code snippets are shown in Fig. 1(b-c).
Fig.1(b) shows the relevant snippets in index.php and
swekey.auth.lib.php that are executed in the ses-
sion poisoning step. index.php ﬁrst speciﬁes the cur-
rent session name. Then it executes the included script
swekey.auth.lib.php . Depending on the value of the
incoming parameter session tounset , method parse str()
is called at line 268, parsing its argument to variable
assignments. For example, parse str(‘a=1&b=2’) has the
same effect as that of executing ‘$a=1; $b=2;’ . The vari-
able $SERVER[‘QUERY STRING’] stores the query string
from the client. Hence the invocation at line 268 deﬁnes
$SESSION[‘ConﬁgFile0’][‘Servers’][‘$code’] to 0. As PHP
treats arrays as hash mappings indexed by keys, the key value
$code is stored to the session array.
Fig.1(c) shows the relevant snippets in config.php that
are executed in the script injection step. At line 52, there i s
a write to a PHP ﬁle guarded by a predicate at line 48. In
the ﬁle write, the string returned by getConﬁgFile() is written.
At line41inside getConﬁgFile() ,$c[‘Servers’] is aliased to
$SESSION[‘ConﬁgFile0’][‘Servers’] . Then in the foreach loop,
the previously stored key value $code is assigned to $idand
deﬁned as part of the return value $ret. In this way, the string
($code ) composed by the client in the previous request is
written to a PHP script.
A hidden complexity is that the session of the requests have
to be identical. In handling client side requests, if not exp licitly
speciﬁed, a default session name ( ‘PHPSESSION’ ) is assigned.
Therefore, in the session poisoning step, one cannot direct ly
send the request to swekey.auth.lib.php , even though
the request can be correctly parsed and the arguments can be
stored into the (default) session. Because the default sess ion
is different from the session speciﬁed in the second step. We
have to call index.php instead to ensure we are referring
to the same named session ‘phpMyAdmin’ as inconfig.php
in the second step.// Accessing directly is allowed in common.php 
  13  require_once ' common.php '; 
  16  $cmd =  $_REQUEST['cmd'] ;
  22  switch ($cmd) {
  23     case '_debug':
  24        …… 
  27     default:
  32        $script_cmd = $cmd . '.php'; 
  39  }
        …… 
  64     include ( $script_cmd );@ cmd.php (a) Exploit 
    35  $direct_scripts = array('cmd.php', … );
// $_SERVER[‘SCRIPT_NAME’] is the script client req uesting 
    42  $script_running = $ _SERVER['SCRIPT_NAME '];
    43  foreach ($direct_scripts as $script) {
    46     if (preg_match('$script, $script_running )) 
    47        $scriptOK = true;
    51  }
          …… 
// If script requested is not in $app[‘direct_scrip ts’], deny 
    57  if (! $scriptOK)
    62     die();          @ common.php 
     // This page not directly accessible 
    13  require_once ' common.php ';  
    32  if ($_REQUEST['search'] ) 
masort ( … , $_REQUEST[‘oderby’]  ); 
       ……  
1002  function masort ( &$data, $sortby )  {
1014     foreach ( split( ',' , $sortby ) as  $key ) 
1017        $code .= "… $key … "; 
 // turn the string held by $code into a dynamic fu nction 
1080     $CACHE = create_function ( … , $code );
1083     uasort( … , $CACHE );
1084  }@ query_engine.php Set $code = urlencode(“ arbitrary_php_script ”)
Send    http://phpLDAPadminURL/htdocs/cmd.php?cmd=query_e ngine&search =1&orderby= $code 
(b) Relevant code snippets call edge 
file inclusion 
Fig. 2: RCE in phpLDAPadmin v1.2.1.1 (Simpliﬁed)
From the example, we make a number of observations.
First, determining if a vulnerability is a true positive dem ands
reasoning both string and non-string parts. Observe that th e
path conditions at line 48 in config.php and line 266 in
swekey.auth.lib.php entail non-string reasoning while
the ﬁle name and the ﬁle content at line 52 in config.php
require string reasoning. Second, we have to reason across
requests and scripts, and handle sessions properly. Neithe r
index.php norconfig.php is vulnerable by itself. Third,
in order to successfully construct an exploit to conﬁrm the v ul-
nerability, we need to know the concrete inputs to satisfy th e
path conditions. For instance, the parameter session tounset
in the step (1) request in Fig. 1(a) is to satisfy the condition
at line 266. The parameter in the step (2) request is to satisf y
the condition at line 48. In other words, the analysis ought t o
be path-sensitive.
B. RCE in phpLDAPadmin
Another type of RCE vulnerabilities is related to eval()
that executes a string provided as its parameter. There is
a vulnerability2inphpLDAPadmin v1.2.1.1 rated “critical”
by the developer. PhpLDAPadmin provides user-friendly web
interfaces to manage a LDAP server. It is a popular tool and
has been installed for more than 242thousand times.
As shown in Fig. 2(a), the vulnerability is exploited by a
request tocmd.php , which is supposed to accept and execute
a command from the client. In the exploit, an invalid command
is provided such that a PHP script named by the command (i.e.
query_engine.php ) gets executed. The script is supposed
to be internal and cannot be requested directly. It can accep t
the rest of the parameters in the exploit request and execute
the malicious script provided by variable $code .
The relevant code snippets are shown in Fig. 2(b). The
scriptcmd.php ﬁrst gets executed. It includes common.php
for access control, which is a common design pattern for PHP
programs. The access control is conducted by comparing the
current script acquired from $SERVER[’SCRIPT NAME’] at
line 42, with a white-list speciﬁed in array $direct scripts . Ob-
serve that at line 35 in common.php ,cmd.php is listed and
the execution is allowed to proceed. Lines 16-39 in cmd.php
determine the command indicated by the client request. If it
2CVE-2011-4075: http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE -2011-4075is not a pre-deﬁned command, such as “ _debug ”, the code
constructs a PHP ﬁle name with the command argument (line
32) and tries to load and execute the ﬁle at line 64. In this
case, the script query_engine.php is executed. Inside
query_engine.php ,common.php is again included and
executed for access control. Since query_engine.php is
included by cmd.php , it inherits all its privileges. Hence,
despite the script itself is not in the while-list, the execu tion
is allowed to continue. At line 32 in query_engine.php ,
if the client parameter search is set, the masort() function is
called to execute a sorting function constructed dynamical ly by
lines 1014-1080. The construction allows the string provid ed
in the client parameter $orderby to be included as part of
the constructed function and executed at line 1083. Note tha t
variable $sortby is an alias to $orderby and uasort() at line
1083 is equivalent to eval() .
Note that the root cause of the defect is not just the masort()
function because executing a dynamically constructed func tion
is the intended semantics of masort() . It is the combination
of the mistake in access control, i.e. allowing the client to
indirectly invoke query_engine.php , and the masort()
function that constitutes the vulnerability. Hence, our te ch-
nique ought to be able to analyze access control mechanism,
which is essentially through predicates. For this example,
the request is so crafted (i.e. the cmd parameter has to be
‘query engine ’, not even a legitimate command) to get through
the access control. It is unlikely that an analysis incapabl e of
modeling path conditions would identify the exploit.
The example also illustrates the necessity of handling dy-
namic ﬁle inclusion (line 64). We have to model the fact that
the name of the ﬁle to be included is a variable in the program.
Based on the value of the variable, different ﬁles need to be
modeled and encoded as part of the constraints.
III. P ROBLEMS IN EXISTING STATIC ANALYSIS
Existing static techniques fall short in RCE vulnerability
detection and exploit generation.
String Analysis is Needed. Web apps are different from
regular programs in that they heavily rely on string operati ons.
Inputs from the client side are mostly strings. The outputs o f
web apps are mainly strings as well, such as SQL queries, html
pages, and JavaScript code pieces. In some sense, the main
functionality of a web app is often string processing. Howev er,PHP Script Non-string Abstraction String Abstraction 
01   if  ( $_POST['a'] < 3 ) {  
02     $role = "visitor"; 
03     $log = “v”; 
04  } 
05  else  { 
06     if ( $_POST['a'] < 5 ) { 
07        $role = "user"; 
08        $log = $_POST[`msg’];  
09     } 
10     else {  
11        $role = "admin"; 
12        $log = “a”; 
13     } 
14  } 
15  if  ( $role == "admin" ) 
16     writeFile(“f.php”, $log ); 101   b1 = _POST_a  < 3 ;  
102  if ( b 1 ) { 
103      T r=0; 
104      T l=0; 
105  } 
106  else  { 
107     b 2 = _POST_a < 5 ; 
108     if ( b2 ) { 
109        T r=0; 
110        T l=1; 
111     } 
112     else { 
113        T r=0; 
114        T l=0; 
115     } 
116  } 
117  if  ( b 3 ) 
118     assert1  (Tl=1); 
 201    if  (b1) {  
202      role:= "visitor"; 
203      log:= “v”; 
204   } 
205   else  { 
206      if (b2) { 
207         role:= "user"; 
208         log := _POST_msg; 
209      } 
210      else {  
211         role := "admin"; 
212         log := “a”; 
213      } 
214   } 
215   b 3=compare(role, “admin”); 
216   if  (b3) 
217       assert2  (“f.php” in “*.php”)  
 Fig. 3: Constraint Generation Example
cfg log1:="v"; cfg role1:="visitor"; //line 02-03
cfg log2:=post_msg; cfg role2:="user"; //line 07-08
cfg log3:="a"; cfg role3:="admin"; //line 11-12
cfg log4:=log2|log3; cfg role4:=role2|role 3; //line 13
cfg log5:=log1|log4; cfg role5:=role1|role 4; //line 14
assert("f.php" in " *.php"); //Assertions not in HAMPI format
assert(log5==post_msg); //Simplified for reading
Fig. 4: Path insensitive encoding
a lot of existing static analysis for regular programs [ 32], [14]
do not focus on properly modeling strings.
String Analysis Alone is Not Sufﬁcient. On the other hand,
string analysis [ 20], [31] alone is not sufﬁcient as most web
apps still have substantial non-string operations, which a re for
execution path control, access control, and arithmetic com pu-
tation. The string and non-string operations cohesively de pend
on each other. Most existing string analysis are based on
context free grammar (CFG) and only model string operations ,
abstracting away the non-string part of a web app. This could
lead to false positives. Moreover, since they do not reason
about path conditions, users can hardly use them to construc t
exploits because that requires knowing the inputs satisfyi ng
various path conditions.
HAMPI. Hampi [ 20] is a string analysis engine developed in
the past. A lot of recent web app analysis are built upon it [ 25].
It models a string assignment as a grammar rule deﬁnition.
Assignments to the same variable in the two branches of a
conditional statement become alternatives in the right han d
side of a rule.
Take the script in the left column of Fig. 3as an example.
It determines the role of the client according to the value of
$POST[‘a’] , deﬁnes the content in $log and ﬁnally writes to
a PHP ﬁle if the role is “admin” . To detect if the ﬁle write is
vulnerable to RCE attacks, at line 16, we assert that (1) the ﬁle
written is a PHP ﬁle and (2) the content written to the ﬁle is
from $POST[‘msg’] provided by the client. The ﬁrst assertion
is trivially true. However, path sensitive and path insensi tive
analysis yield different answers to the second one.
In standard string analysis such as HAMPI, the CFG gen-
erated for the program is shown in Fig. 4and the second
assertion is satisﬁable with the CFG. Therefore, a vulnerab ility
is reported. However, it is a false positive. Consider the
predicate at line 15, the reachability condition of line 16requires $role = “admin” , which implies $log = “a” . This can
only be prevented by a path-sensitive analysis modeling bot h
string and non-string behavior.
Solving String and Non-String Constraints Together is
Difﬁcult. While we need to reason about string and non-
string behavior together, existing solutions are not adequ ate.
One class of solutions models strings as bit-vectors which c an
be handled by existing SMT solvers to achieve solving string
and non-string constraints together. However, a precondit ion
in bit-vector logic is that the lengths of bit-vectors are ﬁx ed
and decidable. However, this does not hold for strings. For
example, str := post msg|“123” is a CFG rule. The length
ofstrvaries depending on the alternatives. In one of the
alternatives, it is determined by the client side input, whi ch is
uncertain. This causes difﬁculty in reasoning about constr aints
built on top of str. Most existing techniques in this category are
developed in the context of dynamic symbolic execution [ 25],
[12]. Since they only need to model the executed path, string
lengths or strong hints of string lengths can be acquired fro m
the execution. These techniques can hardly be applied in our
context as we need to model all possible paths. Another
plausible solution is to translate both string and non-stri ng
constraints to a third party constraint language [ 28] and solve
them together. However, third party languages are often lim ited
in expressiveness. For example in [ 28], the M2L constraint
language used can only model a very small set of arithmetic
operations, namely addition and subtraction, and it does no t
allow more than one variables in an expression.
Incapabilities in Modeling RCE Speciﬁc Characteristics.
As we can observe from the two cases in the previous section,
RCE attacks have speciﬁc characteristics that need to be
properly handled. For example, multiple requests to more
than one scripts need to be analyzed together; dynamic ﬁle
inclusion needs to be modeled. As far as we know, none of
the existing techniques can meet the challenges.
IV. D ESIGN
Given a web app, we ﬁrst identify the operations sensitive to
RCE attacks, called sinks . We consider two kinds of sinks: ﬁle
writes and dynamic script evaluations (e.g. eval() ). For a ﬁle
write, if we can determine along some feasible path it writes
to a.php ﬁle and the content contains values from the client, it
is considered problematic. For a dynamic script evaluation , if
the string evaluated as a script contains values from the cli ent
along some feasible path, it is considered problematic.
Our technique is an inter-procedural, context-sensitive a nd
path-sensitive static analysis. It reasons about both stri ng
and non-string behavior. To begin with, the technique creat es
two abstractions of the given app: one for the string related
behavior and the other for the non-string related behavior.
The non-string abstraction includes additional taint sema ntics
to reason about the input correlation for each variable. The
two abstractions are encoded separately. Then we solve them
together via a novel and sound, iterative and alternative
algorithm. For a potentially vulnerable ﬁle write, we query the
string constraints if the ﬁle name ends with the PHP extensio nand query the non-string constraints to determine if the wri tten
content is tainted and the ﬁle write is reachable. The soluti on
has to consistently satisfy all these queries.
A. Abstractions
For each PHP script, we create two abstractions: string and
non-string abstractions. Intuitively, one can consider th ey are
simpliﬁcations of the original program that handle only str ing
type and non-string types, respectively. To facilitate abs trac-
tion, we have implemented a number of auxiliary analysis.
One is type inference [ 22] as PHP programs are dynamically
typed. It leverage the known interface of string operations . For
example, if a statement is a string concatenation, the varia ble
holding the return value as well as the arguments are of strin g
type. Transitively, other correlated variables can be type d. The
second is a standard context-sensitive alias analysis. The third
one is a ﬁeld name analysis that identiﬁes all the ﬁeld names
or constant indices for an array. We assume a program is
normalized such that the predicate in a conditional stateme nt
is a singleton boolean variable.
TABLE I: String Abstraction Rules. Operator ‘:=’ represents deﬁni-
tion and ‘.’ concatenation. Variables $s1, $s2, $s3 are of st ring type, $a, $a1
and $a2 are of array type, and $b is of boolean type. F1,..., an d fn are constant
ﬁeld names of $a, $a1, and $a2 identiﬁed through the ﬁeld name analysis.
Statements Abstraction
(1) $s1 = $s2; s1 := s2
(2) $s1 = concat($s2, $s3) s1 := s2.s3
(3) $s1[‘c’] = $s2; s1c :=s2
(4) $s1 = $s2[‘c’]; s1 :=s2 c
(5) $a1 = $a2; a1f1 :=a2 f1
...
a1fn :=a2 fn
(6) $b= ($s1==$s2) b =compare (s1, s2)
(7)if(b){...}else{...} if(b){...}else{...}
(8)foreach ($aas$s1⇒$s2) s1:=‘f1’; s2:=a f1; /* loop body */;
/*loop body*/ ...
s1:=‘fn’; s2:=a fn;/*loop body*/;
String Abstraction. The abstraction retains the control ﬂow
structure, statements of string type, and string compariso ns in
the original program. Other statements are abstracted away . It
thus models the string related behavior in the program.
The detailed abstraction rules are presented in Table I. String
copies and concatenations (rules (1) and (2)) are straightf or-
ward. For an array access indexed by a constant ﬁeld name,
such as $a[‘c’] , we create a new variable acto denote the
ﬁeld (rules (3) and (4)). Currently, we have limited support
for dynamically constructed ﬁeld names/indices: we use fre e
variables to denote such accesses. For an array copy (rule (5 )),
we generate the deﬁnitions for the ﬁelds identiﬁed by the ﬁel d
name analysis. For a string comparison (rule (6)), we retain the
same boolean result variable and make use of the compare()
primitive that compares two strings. We will explain in late r
sections how this will be turned into string constraints and
solved by HAMPI. Rule (7) means that we retain the structure
of a conditional statement. For a regular loop, we unroll the
loop body once and turn it into a conditional statement. This
is a standard solution to handling loops in constraint based
analysis [ 13]. A foreach loop involving strings, “ foreach ($a
as$s1⇒$s2)”, means that $a is a mapping and the loop iteratesover each entry of the mapping and instantiates $s1 with a key
and $s2 the corresponding value. We unroll the loop n times
for the n ﬁelds we have identiﬁed for the array (rule (8)). In
each iteration, the ﬁeld name is associated with s1 and the
ﬁeld value is associated with s2.
Note that the string abstraction is incomplete due to the
dynamic nature of the language. For example, it is difﬁcult
to reason about string values in ﬁeld accesses through dy-
namically constructed ﬁeld names/indices. Fortunately, f rom
our experience, most ﬁeld accesses have constant names. For
example in phpLDAPadmin, 3656 out of 4636 ﬁeld accesses
have constant names. In our experiments, this has not led to
any false positives.
The third column in Fig. 3shows the string abstraction for
the program in the ﬁrst column. It is essentially a simpliﬁed
version of the original program with the integer comparison s
excluded and some unbounded boolean variables used.
TABLE II: Non-String Abstraction Rules. Variables $x, $y, $z are
of non-string type, $a is of array type, $s1, $s2 and $s3 are of string type, and
$b is of boolean type. Operator ⋄denotes a binary operation. Txrepresents
the boolean taint bit of $x. F1,..., and fn are constant indic es identiﬁed through
the ﬁeld name analysis.
Statements Abstraction
(8) $x = $y; x = y;Tx=Ty
(9) $x = $y ⋄$z; x = y⋄z;Tx=Ty|Tz
(10) $x = $a[‘c’]; x = a c;Tx=Ta|Tac
(11) if(b){...}else{...} if(b){...}else{...}
(12) foreach ($aas$x⇒$y) x=f1; y=a f1;Tx=Ta;
/*loop body*/ Ty=Ta|Taf1;/*loop body*/;
...
x=fn; y=a fn;Tx=Ta;
Ty=Ta|Tafn;/*loop body*/;
(13) $s1 = $s2; Ts1=Ts2
(14) $s1 = concat($s2, $s3) Ts1=Ts2|Ts3
(15) foreach ($aas$s1⇒$s2)Tx=Ta;Ty=Ta|Taf1;
/*loop body*/ /*loop body*/;
...
Tx=Ta;Ty=Ta|Tafn; ...
Non-String Abstraction. The Non-String abstraction retains
the same control ﬂow structure as the original program and
all the statements of a non-string type. It also introduces t aint
semantics into the abstracted program. The taint semantics
is standard, that is, a resulting variable is tainted if any o f
the operands are tainted. This is to model the correlations t o
client inputs. Hence, variables and statements of string ty pe
are not completely abstracted away. Instead, a boolean vari able
is introduced to represent the taint of a string variable. St ring
operations are abstracted to corresponding taint operatio ns.
Table. IIpresents the rules. Rules (8) and (9) are standard.
In rule (10), the result variable $x is tainted if either the a rray
$a is tainted or the speciﬁc ﬁeld is tainted. Intuitively, it means
if the entire array comes from the client, an array ﬁeld comes
from the client. This allows us to model the taint propagatio n
semantics of array accesses with dynamically constructed ﬁ eld
names/indices. For instance, in the sample code in Fig. 1.
Statically, we don’t know what variables are written by line
268 without knowing the concrete request. However, it is
straightforward to assume that the $SESSION array is tainted.
According to rule (10), $cis tainted at line 476, which leads
to$idbeing tainted at line 42, disclosing that $idcould comefrom the client. Rule (12) abstracts foreach loops with non-
string operands. Similar to that in string abstraction, it u nrolls
the loop n times for the n constant ﬁelds identiﬁed through th e
ﬁeld name analysis. Observe that the taint propagation of $y
is similar to rule (10). Rules (13-15) are for string operati ons,
which are abstracted to taint operations.
There are some operations that have string operands but
non-string results, such as getting the index of a string in a n-
other string, our implementation currently uses free varia bles
to denote the results of such operations.
The second column in Fig. 3shows the non-string abstrac-
tion of the sample program. Observe that the two abstraction s
use the same set of predicate variables, which allows us to
reason about the two parts together.
B. Constraint Encoding and Solving
With the two abstractions, the next step is to encode
them separately and then solve them together. We develop a
novel algorithm to drive the solution process. The algorith m
queries the STP solver and the HAMPI string solver iterative ly
and alternatively to derive a consistent path-sensitive so lution
for both sets of constraints. Intuitively, one can consider
the algorithm ﬁrst solves the non-string constraints and pr o-
duces a solution for the path conditions, the solution is the n
used to derive the HAMPI encoding for that path from the
string abstraction. Doing so, the imprecision caused by pat h-
insensitivity can be avoided. If HAMPI fails to resolve the
constraints for the path, it means that the solution is infea sible.
The algorithm alternates to the STP solver to explore a new
solution. In the algorithm, we leverage the observation tha t
string constraints are strong in pruning search space. In ma ny
cases, a not fully path-sensitive string encoding may not have
any solutions so that we can completely avoid exploring the
individual paths in that sub-space.
The encoding of the non-string part is standard (i.e. ﬁrst
translates the program to its SSA form and models individual
statements to bit-vector operations) and hence omitted.
Encoding and Solving String Constraints. Before encoding,
the abstracted program is translated to its SSA form in which
a unique variable name is assigned to each deﬁnition and φ
operators are used at joint points to multiplex the differen t
values along different branches. The encoding is driven by
the assignment for the boolean variables in the abstraction .
The process is detailed in Algorithm 1.
Function genStrCSTR() generates HAMPI constraints (i.e.
a CFG) for a statement in the SSA form. It is a recursive
function, driven by the abstract syntax tree (AST) of the
statement. In particular, for an assignment statement (lin es
1-2), a HAMPI CFG deﬁnition, denoted by keyword cfg,
is inserted to the CFG. For a conditional statement (lines
3-10), depending on the value assignment of the predicate
variable, one of the branch is encoded. If the variable value
is not speciﬁed, both branches are encoded. Note that, if
all predicate variables are speciﬁed, we essentially encod e a
full program path. If only some are speciﬁed, we say that
we encode a partial path , denoting a set of full paths. Inlines 11-17, φoperators are encoded, which may introduce
alternatives in the resulting grammar (line 17). Lines 18-2 2
encode string comparisons. Because HAMPI doesn’t support
direct comparison of two strings, we use rules “ assert v in s1;
assert v in s2” to query the equivalence of s1ands2withv
a free variable. Note that HAMPI will instantiate vwhen it
ﬁnds a satisfying solution.
Algorithm 1 Generate and solve string constraints
Input:S:a statement in the string abstraction in SSA form
R:assignment to boolean variables, indexed by var.
Output: the CFG Cstr.
genStrCSTR (S,R)
1:ifS≡“s1:=s2”then
2:Cstr←Cstr◦{cfg s1:=s2}
3:ifS≡“if(b)S1elseS2”then
4: ifR[b]≡true then
5: genStrCSTR( S1,R)
6: else ifR[b]≡false then
7: genStrCSTR( S2,R)
8: else
9: genStrCSTR( S1,R)
10: genStrCSTR( S2,R)
11:ifS≡“s1:=φ(b,s2,s3)”then
12: ifR[b]≡true then
13: Cstr←Cstr◦{cfg s1:=s2}
14: else ifR[b]≡false then
15: Cstr←Cstr◦{cfg s1:=s3}
16: else
17: Cstr←Cstr◦{cfg s1:=s2|s3}
18:ifS≡“b=compare (s1,s2)”then
19: ifR[b]istrue then
20: Cstr←Cstr◦{assert v in s 1;assert v in s 2;}
21: else
22: Cstr←Cstr◦{assert v in s 1;assert v not in s 2;}
Input:P:string abstraction
R:assignment to boolean variables.
Output: SAT or UNSAT.
solveStrCSTR (P,R )
//generate HAMPI CFG
23:foreach top level statement S∈Pdo
24: genStrCSTR( S,R)
25:return QueryHampi (Cstr)
Function solveStrCSTR() determines if a (partial) path,
denoted by the (partial) speciﬁcation of path conditions R,
is feasible from the perspective of the string abstraction P. It
builds the CFG by calling genStrCSTR() on all the top level
statements and then solves it by calling HAMPI.
Iterative Solving. The iterative driver algorithm is presented
in Algorithm 2. Function driver() takes the non-string con-
straintsN, (the conjunction of the non-string encoding, the
reachability assertions, and the taint assertions), and th e string
abstraction P, then produces a satisfying solution Sif there is
one. A reachability assertion dictates a sink under conside ra-
tion is reachable (e.g. asserting line 118 is reachable in Fi g.3).
A taint assertion dictates the content of a ﬁle write or eval()is tainted (e.g. the assertion at 118 in Fig. 3).
Lines 1-5 are the fast path to detect unsatisfying cases. Not e
that the invocation of the string solver at line 4 considers t he
path-insensitive encoding. Lines 6-7 are also the fast path ,
checking if the fully path-sensitive string encoding with t he
path speciﬁed by Ris satisﬁable. If so, we simply terminate
withR. If neither fast path can be taken, the recursive method
iterSolver() is called to derive a path-sensitive solution.
Algorithm 2 Iterative and Alternative Solving
Input:N:Non-string constraints.
P:String Abstraction.
Output: a satisfying solution or UNSAT.
driver (N,P )
1:(Satn,R)←querySTP( N)
2:ifSatn≡UNSAT then
3: exit UNSAT
4:ifsolveStrCSTR (P,φ)≡UNSAT then
5: exit UNSAT
6:ifsolveStrCSTR (P,R )≡SAT then
7: exitR
8:iterSolver (N,P,R,φ )
Input:R:a known satisfying solution for N
S:the generated ﬁnal solution
Output: function returns implies UNSAT
iterSolver (N,P,R,S )
9:ifR≡φthen
10: exitS
11:b←select (R),bv←R[b]
12:ifsolveStrCSTR (P,S◦{b=bv})≡SAT then
13: iterSolver (N◦{ASSERT(b⇐⇒bv)},P,R−{b},S◦{b=
bv})
14:(Satn,R′)←querySTP (N◦{ASSERT(b⇐⇒¬bv)})
15:ifSatn≡UNSAT then
16: return
17:ifsolveStrCSTR (P,S◦{b=¬bv})≡UNSAT then
18: return
19:iterSolver (N◦{ASSERT(b⇐⇒¬bv)},P,R′−{b},S◦{b=
¬bv})
Method iterSolver() takes an existing solution Rto the non-
string part Nas a reference to derive the ﬁnal solution S.
The algorithm tries to speculate a (true/false) solution fo r a
selected predicate at one iteration. The speculation is gui ded
by the provided solution R. In other words, it tries to follow the
satisfying path for the non-string part as much as possible u ntil
the string constraints become unsatisﬁable. Then it backtr acks
and tries a different speculation.
Lines 9-10 are the termination condition, it means that if we
have successfully speculated all predicates, we acquire a s olu-
tion. Line 11 selects a predicate from the provided solution R.
Right now our selection is based on the dependence distance t o
the sink under consideration. Line 12 speculates its value b ased
onRand queries the string solver. Note that Scontains all the
predicates that have been speculated thus far and it does not
specify any predicate that has not been speculated. Essenti ally,
it is equivalent to querying the string engine with partial path-stepb1b2b3 STP HAMPI
1 f - - SAT
2 f t - UNSAT
3 f f - UNSAT
4 t - - UNSAT
TABLE III: Solving the example in Fig. 3.
sensitivity . This is to leverage the observation that in many
cases even partial path-sensitive string constraints are d ifﬁcult
to satisfy, allowing us to prune search space. At line 13,
we continue speculation by recursively calling iterSolver() .
Note that Nis updated with the speculation, the predicate is
removed from R, and the speculated path (the ﬁnal solution)
Sis lengthened with the speculation.
In lines 14-19, when mis-speculation occurs, the negation
of the selected predicate is explored. If both branches of th e
selected predicate have been tried but a satisfying solutio n
could not be found, the method returns, which is equivalent
to backtracking to the previous iteration.
Our experience shows that the algorithm can quickly con-
verge in both the SAT and UNSAT cases (Section VI).
Example. Consider the example in Fig. 3. The STP solver
ﬁrst generate a solution {b1=f, b2=t, b3=t}(line
1 in Algorithm 2). The path insensitive string encoding (i.e.
the one in Fig. 4) has a satisfying solution too. But, the
path sensitive HAMPI encoding (shown as follows) is not
satisﬁable, disclosing the path is not a correct solution.
var v : 0 .. 20;
cfg role1 := "user"; // line 207
cfg log1 := post_msg ; // line 208
assert ("f.php" in " *.php);
assert (v in role1);
assert (v in "admin");
Hence, the algorithm resorts to the iterative solver. Table III
shows the process. At the beginning, it tries to follow the
SAT solution by STP. At step 1, the string constraints with
onlyb1=fspeciﬁed are SAT. So that the algorithm tries to
further speculate b2=t, but this time the string constraints
are UNSAT. It then alternates to the STP solver, exploring
b2=f, which turns out to be UNSAT. It backtracks and
exploresb1=twith the STP solver, which is UNSAT too. It
then terminates with UNSAT.
Our technique analyzes sinks one by one. To reduce com-
plexity, for each vulnerable candidate (sink), we use a PHP
slicer, which was implemented in our prior work [ 35], to prune
the irrelevant parts before abstraction and encoding. Sinc e
our technique does not handle some string operations such
asindexOf() , it is unsound. However in practice, the number
of false positives is low (Section VI).
V. H ANDLING PRACTICAL CHALLENGES
In this section, we discuss how to overcome a number of
practical challenges for RCE vulnerability detection.
Handling Dynamic Inclusion. At runtime, through dynamic
ﬁle inclusion, several PHP scripts may be combined together
as the running script. We need to model such effects. For
example, in Fig. 5, at lines 1−2inindex.php , based on
the value of $REQUEST[’role’] , different script ﬁles may be@ admin.php @ user.php 
11 function  accessControl() { 
12 if  ($_SESSION [ ‘user’ ] ! = ‘admin’)  
13        header(“Location: login.php”); 
14  } 
15 function  editData() { … } 
16  accessControl();     21 function  editData() { … } 
@ index.php 
  1 if  ( $_REQUEST[‘role’] == ‘admin’ )     include ( ‘ad min.php’ );  
  2 else    require ( ‘user.php’ ); 
  3  editData(); 
Fig. 5: Example to illustrate dynamic inclusion and access control .
/* b 1=(_REQUEST[‘role’]==‘admin’) */ 
if (b 1)  {
     inc=1;
/*inlining admin.php*/
     /* b 2=(_SESSION[‘user’]!=‘admin’) */ 
     if (b 2)  {
        exit;
     } 
} else 
     inc=2;
b3= (inc==1);
if (b 3)
    /*inlining editdata() in admin.php*/
b4= (inc==2);
if (b 4)
    /*inlining editdata() in admin.php*/lines 
1 and 2
line 3 1
2
3
4
5
6
7
8
9
10 
11 
12 
13 
14 
15 
Fig. 6: The non-string abstraction of the program in Fig. 5.
included at runtime. As a result, the function invoked at lin e
3may refer to different code bodies.
The solution is to have conditional inlining at the call
site that has multiple method bodies (e.g. line 3 in Fig. 5).
However, we need to model the fact that the condition of
inlining is not the reachability condition of the call, but r ather
the reachability condition of the inclusion site. We handle it by
introducing a dummy variable at the inclusion site to denote
the choice and later using the variable to guard the invocati on.
Example . Fig. 6shows the non-string abstraction of the
program in Fig. 5. Lines 1-9 abstract lines 1-2 in the original
code and lines 10-15 abstract the original line 3. Note that t he
deﬁnitions of b1andb2are not in the non-string abstraction,
but rather the string abstraction. The page redirection at l ine
13 in Fig. 5is abstracted as exitbecause when the page is
redirected, none of the following statements gets executed .
We introduce a dummy variable incto denote the inclusion
option and use it to guide the inlining in lines 10-15.
Reasoning Across Requests. RCE attacks may require coor-
dination of multiple requests. Since in PHP requests are pro -
cessed independently, cross-request attacks usually leve rage
sessions to preserve data. In PHP, a session can be determine d
by two parts: the session name and the session id . When
a server and a client communicate, the session name and
id are set in the HTTP header. The session name can be
explicitly deﬁned in a PHP script, otherwise the default val ue
(PHPSESSID ) is used. Also, a unique session id is assigned to
each new visiting client. In order to reason about dependenc es
across requests, we need to ensure the relevant requests are
referring to the same session. Note that as long as the attack er
ensures exploit requests are sent within the session expira tion
window, the session ids of these requests are automatically
identical. Therefore, we only need to check if the sessionstatement abstraction
string non-string
[f1] initially SNNAME f1:=PHPSESSID
[f1]session name(’C’) SNNAME f1:=’C’
[f1]parsestr(...) b=(s== SNNAME f1) Tsn=b?1:0
[f2]$x= SESSION s:=SNNAME f2 Tx=Tsn
TABLE IV: Session abstraction.
names of these requests can be made identical.
Our solution is that for a statement in which a session
value may be set, such as line 268 in the phpMyAdmin
example in Fig. 1, we abstract the statement to a taint bit set
operation guarded by a condition that the session name from
the other request must be identical to the current session na me.
Therefore, any read from session in the other request is tain ted
only when it has the same session name. Table IVexplains
the process. The 1st column lists the relevant statements wi th
f1/f2 the script. The 2nd and 3rd columns show the string
and non-string abstractions, respectively. Initially, ea ch script
has a default session name (1st row). Any invocation to
session name() is abstracted as setting the current session
name (2nd row). A statement or library call that allows the
client to set session values is abstracted as a guarded taint bit
set (3rd row). A session read in the other request f2 sets the
global variable sto its session and copies the session taint bit.
VI. E VALUATION
Our system makes use of LLVM, the PHP compiler ( phc)
[4], the STP solver and the HAMPI string solver[ 20].Phc is
used to translate PHP to C, allowing us to leverage the existi ng
analysis in LLVM (e.g. alias analysis). The main analysis is
implemented in LLVM. It takes the C program and transforms
it to constraints. The solving algorithm is implemented in C .
We apply our technique on a set of real world applications
as listed in Table V. Observe that some of them are large, with
a few hundred ﬁles and over 200k LOC. These web apps are
selected as we were able ﬁnd some RCE reports about them
on the Internet. One of our goals is to see if we can identify
these reported vulnerabilities. All experiments are run on an
Intel Dual Core i5 2.5GHz machine with 8GB memory. The
experimental results are publicly available at [ 1].
TABLE V: Program characteristics.
PHP PHP LOC
application ﬁles avg stdev max total
aidiCMS v3.55 273 157 280 2976 42843
phpMyFAQ v2.7.0 347 690 2956 30222 239380
zingiri webshop v2.2.2 457 139 304 4517 63768
phpMyAdmin v3.4.3 527 432 1498 26136 227716
phpLDAPadmin v1.2.1.1 97 293 522 3108 28456
phpScheduleIt v1.2.10 171 383 394 2157 65493
FreeWebshop v2.2.9 R2 190 198 412 4971 37636
ignition v1.3 30 118 375 2092 3542
monalbum v0.8.7 41 105 104 452 4288
webportal v0.7.4 514 59 89 1022 30266
Table VIpresents the detection results. Constraint presents
the average number of variables and constraints in the for-
mula. Sink is the number of the places that are potential
vulnerable. They are the number of ﬁle writes and dynamic
script evaluations. They are analyzed one by one. Report is
the number of vulnerable sinks that our technique reports.
Among those reported, FPpresents the number of falseTABLE VI: Analysis Result.
constraint(avg) avg solve avg non-string string
application variable constraint iteration time(s) sink report FP known new report FP report FP
aidiCMS v3.55 95.2 96.6 0.0 7.5 55 5 2 1 2 5 2 11 8
phpMyFAQ v2.7.0 58.6 59.0 0.8 9.4 25 5 2 1 2 6 3 7 4
zingiri webshop v2.2.2 159.5 159.5 6.5 22.8 68 2 1 1 0 2 1 3 2
phpMyAdmin v3.4.3 167.0 160.0 0.0 1.6 65 1 0 1 0 1 0 1 0
phpLDAPadmin v1.2.1.1 491.0 493.0 38.0 87.6 6 1 0 1 0 2 1 1 0
phpScheduleIt v1.2.10 135.5 178.0 3.0 3.0 52 4 0 4 0 25 21 4 0
FreeWebshop v2.2.9 R2 185.8 198.0 15.3 30.8 38 4 1 1 2 5 2 12 9
ignition v1.3 62.0 69.7 0.0 1.6 8 3 0 1 2 5 2 3 0
monalbum v0.8.7 174.0 200.0 0.0 11.8 2 1 0 1 0 1 0 1 0
webportal v0.7.4 13.0 11.0 0.0 0.3 39 1 0 1 0 1 0 2 1
TOTAL 358 27 6 13 8 53 32 45 24
TABLE VII: Constraint solving comparison.
algo. 2 non-guided solving
application iteration time(s) iteration time(s)
aidiCMS v3.55 0 3.33 0 3.37
phpMyFAQ v2.7.0 5 4.63 69 30.49
zingiri webshop v2.2.2 13 45.56 53 98.27
phpMyAdmin v3.4.3 0 1.09 0 1.01
phpLDAPadmin v1.2.1.1 39 84.78 187 102.53
phpScheduleIt v1.2.10 9 6.30 96 50.00
FreeWebshop v2.2.9 R2 62 86.03 1402*1843.83*
ignition v1.3 1 0.75 4 1.90
monalbum v0.8.7 0 0.01 0 0.01
webportal v0.7.4 0 0.30 0 0.29
*One UNSAT case times out. It cannot be solved in 30 minutes.
positives, Known is how many of them have been reported.
New presents those that have not been reported in the past.
Iteration reports the average number of iterations needed to
determine SAT/UNSAT (precluding the cases that are UNSAT
for either the string or the non-string constraints alone). Time
is the average analysis time including the abstraction and
constraint solving time.
For comparison, in the last four columns we also present
the results generated by considering only the string part (w hich
is equivalent to using HAMPI alone for detection [ 20]) and
only the non-string part (which is equivalent to a path-sens itive
static taint analysis [ 29]).
For the new true positive reports, we have constructed
exploits from the SAT solutions (for path conditions) to
conﬁrm them. The exploits are also available at [ 1]. They are
concrete HTTP requests that can execute an arbitrary piece o f
payload script.
We have the following observations from the results.
(1)Our technique is effective. Its false positive rate is only
22%. It identiﬁes 21 real RCE vulnerabilities, including al l the
reported ones (13) and 8 new ones.
(2)Its overhead is reasonable. Observe that the average num-
ber of iterations is small. Sometimes, it is zero if the solut ions
can be found in the fast path. It indicates our algorithm can
quickly converge for both SAT and UNSAT cases. Another
performance study can be found later.
(3)Considering either the string or the non-string part alone
produces a lot of FPs, indicating the need of reasoning both
parts cohesively.
False Positive . Our technique produces FPs. Currently we
cannot model some environment related library functions su ch
asﬁleexists() because they require dynamic information. We
have limited support for string functions such as substr() and
getExtension() due to the limit of HAMPI. We introduce free@ modul/tinymce/plugins/ajaxfilemanager/ajax_save_te xt.php
11 $path = $not_important . $_POST[’name’];
21 if ( getFileExt($_POST[’name’]) == "php" )
{ ... }
28 else
{
33 if( file_exists($path) ) { ...}
36 else {
38 $fp = fopen($path , "w+");
40 fwrite($fp, $_POST[’text’]);
...
}
} Fig. 7: FP in adidCMS
variables in the constraints to denote the outcome of these
functions. This leads to false positives sometimes.
A false positive in adidCMS is presented in Fig. 7. This
piece code saves the content ( $POST[’text’] ) posted by the
client into a ﬁle whose name ( $POST[’name’] ) is also pro-
vided by the client. If we don’t consider the path conditions ,
the ﬁle write at line 38can write the content from the client
into a PHP ﬁle named by the client. However, if the ﬁle
name ends with .php , the predicate at line 21will capture
the dangerous behavior. However, we currently cannot model
getFileExt() andﬁleexists() , leading to the false positive.
Evaluating the Constraint Solving Algorithm. We perform
another experiment to evaluate our solving algorithm. Reca ll
we use the STP solution to guide the overall process and
leverage the string solver to prune search space (Algorithm 2).
We compare the algorithm with a simple algorithm that also
solves string and non-string constraints. The simple algor ithm
acquires a SAT solution from STP and then validates it using
HAMPI. If UNSAT, it acquires a different SAT solution from
STP, until a solution is found or STP reports UNSAT. The
results are shown in Table VII. The iteration number and time
in the table are the sum of those for analyzing individual
sinks for each benchmark. The runtime is the solving time,
not including the abstraction time. Observe that our algori thm
is in general much better. The simple algorithm may run into
deep troubles for UNSAT cases (e.g. FreeWebShop ) when
the search space is large.
VII. R ELATED WORKS
The work in [ 28] also statically models the string and non-
string behavior of a program. It translates both to a common
M2L constraint language. However, M2L has limited expres-
siveness (Section III). Researchers have also modeled both
strings and non-strings in the context of dynamic symbolic
execution [ 25], [12]. However, they require knowing stringlengths beforehand and they only model the executed path
whereas we need to encode all possible paths.
String operations can also be modeled as ﬁnite state trans-
ducers(FST). The work in [ 30] introduces symbolic represen-
tations in automata to handle the inﬁnite alphabets problem in
the classical FST. In [ 24], string constraint solving is used to
repair HTML generation errors. ViewPoints [ 5] applies static
string analysis to compute inconsistency between client-s ide
and server-server input validation functions. However, th ey all
have very limited support for non-string behavior.
RCE attacks are a special kind of Cross Site Scripting
(XSS) attack and thus our work is related to detecting SQL
injection [ 20], [31], [18], XSS [ 9], [16], [21], [23], [26] and
HTTP request parameter tampering [ 8], [11] attacks. Among
these works, the dynamic analysis based approaches [ 11], [9],
[16], [21], [23], [26], [8], [10], [7], [6] require running the
program. The effectiveness of these techniques is dependen t
on the concrete executions monitored.
Static techniques [ 20], [31], [17], [35] consider all possible
executions. In particular, [ 20], [31], [33], [19] abstract away
non-string computation and reason about string manipulati ons
in a path insensitive way. In [ 17], researchers used a static
constraint solving based technique to precisely identify t he
interface of a web app. In [ 35], a path-, context- and ﬁeld-
sensitive static analysis was proposed to detect resource c on-
tention problems. However, both works have limited support
for string reasoning and only consider constant strings.
Similar to our work, researchers in [ 15] also observed that
modeling session is important in analyzing web application s.
However, the work aimed at test suite generation.
VIII. C ONCLUSION
We propose a path- and context-sensitive analysis to detect
Remote Code Execution (RCE) attacks in web apps. The
analysis reasons about the string and non-string behavior o f a
program cohesively. It ﬁrst creates two abstractions of the pro-
gram to model the string and non-string behavior, respectiv ely,
which are encoded to constraints separately. A novel algori thm
is developed to resolve the two sets of constraints together .
The technique handles a lot of RCE speciﬁc challenges by
extending the abstractions. Our experiment shows that the
technique is very effective in detecting RCE vulnerabiliti es
in real-world PHP applications, producing much fewer false
positives compared to alternative techniques. And the unde r-
lying constraint solving algorithm is very efﬁcient.
REFERENCES
[1] http://www.cs.purdue.edu/homes/zheng16/rce/index.ht ml.
[2] OWASP PHP Top 5. https://www.owasp.org/index.php/PHP Top 5.
[3] IBM threat reports. http://www.ibm.com/services/us/iss/xforce/trendrepo rts/.
[4] Phc: open source PHP compiler. http://www.phpcompiler.org/ .
[5] M. Alkhalaf, T. Bultan, S. Roy Choudhary, M. Fazzini, A. O rso
and C. Kruegel. ViewPoints: Differential String Analysis f or Dis-
covering Client and Server-Side Input Validation Inconsis tencies
InISSTA’12 .
[6] G. Antoniol, M. D. Penta and M. Zazzara. Understanding We b
Applications through Dynamic Analysis. IWPC’04
[7] S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. Paradkar a nd
M. Ernst. Finding bugs in dynamic web applications. ISSTA’08[8] M. Balduzzi, C. T. Gimenez, D. Balzarotti and E. Kirda. Au to-
mated Discovery of Parameter Pollution Vulnerabilities in Web
Applications. In NDSS’11 .
[9] D. Bates, A. Barth and C. Jackson. Regular expressions co nsid-
ered harmful in client-side XSS ﬁlters. In WWW’10 .
[10] C. Bezemer, A. Mesbah and A. Deursen Automated security
testing of web widget interactions. In FSE’09 .
[11] P. Bisht, T. Hinrichs, N. Skrupsky and V . N. Venkatakris hnan.
WAPTEC: whitebox analysis of web applications for paramete r
tampering exploit construction. In CCS’11 .
[12] N. Bjørner, N. Tillmann and A. V oronkov. Path Feasibili ty
Analysis for String-Manipulating Programs. In TACAS ’09 .
[13] E. Clarke, D. Kroening, F. Lerda. A Tool for Checking ANS I-C
Programs. In TACAS’04 .
[14] M. Das, S. Lerner, M. Seigel. ESP: path-sensitive progr am
veriﬁcation in polynomial time. In PLDI’02 .
[15] S. G. Elbaum, S. Karre and G. Rothermel. Improving Web
Application Testing with User Session Data. In ICSE’03 .
[16] M. V . Gundy and H. Chen. Noncespaces: Using Randomizati on
to Enforce Information Flow Tracking and Thwart Cross-Site
Scripting Attacks. In NDSS’09 .
[17] W. Halfond, S. Anand and A. Orso. Precise Interface Iden tiﬁ-
cation to Improve Testing and Analysis of Web Applications. In
ISSTA’09.
[18] W. Halfond and A. Orso. Preventing SQL injection attack s using
AMNESIA. In ICSE’06.
[19] P. Hooimeijer and W. Weimer. Solving string constraint s lazily.
InASE’10.
[20] A. Kiezun, V . Ganesh, P. J. Guo, P. Hooimeijer and M. D. Er nst.
HAMPI: a solver for string constraints. In ISSTA’09 .
[21] M. T. Louw and V . N. Venkatakrishnan. Blueprint: Robust
Prevention of Cross-site Scripting Attacks for Existing Br owsers.
InSP’09 .
[22] R. Milner. A theory of type polymorphism in programming .
Journal of Computer and System Sciences , 1978.
[23] Y . Nadji, P. Saxena and D. Song. Document Structure Inte grity:
A Robust Basis for Cross-site Scripting Defense. In NDSS’09 .
[24] H. Samimi, M. Schafer, S. Artzi, T. Millstein, F. Tip and
L. Hendren. Automated repair of HTML generation errors in PH P
applications using string constraint solving. In ICSE 2012 .
[25] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant and
D. Song. A Symbolic Execution Framework for JavaScript. In
SP’10 .
[26] P. Saxena, D. Molnar, B. Livshits. SCRIPTGARD: automat ic
context-sensitive sanitization for large-scale legacy we b applica-
tions. In CCS’11.
[27] F. Sun, L. Xu and Z. Su. Static Detection of Access Contro l
Vulnerabilities in Web Applications. In USENIX Security 2011.
[28] T. Tateishi, M. Pistoia and O. Tripp. Path- and index-se nsitive
string analysis based on monadic second-order logic. In ISSTA’11
[29] O. Tripp, M. Pistoia, S. Fink, M. Sridharan and O. Weisma n.
TAJ: effective taint analysis of web applications. In PLDI’09
[30] M. Veanes, P. Hooimeijer, B. Livshits, D. Molnar and
N. Bjørner. Symbolic ﬁnite state transducers: algorithms a nd
applications. In POPL’12.
[31] G. Wassermann and Z. Su. Sound and Precise Analysis of We b
Applications for Injection Vulnerabilities. In PLDI’07 .
[32] Y . Xie and A. Aiken. Saturn: A scalable framework for err or
detection using Boolean satisﬁability. In ACM Trans. Program.
Lang. Syst. May, 2007 .
[33] F. Yu, M. Alkhalaf and T. Bultan. Patching Vulnerabilit ies with
Sanitization Synthesis. In ICSE’11 .
[34] F. Yu, T. Bultan and B. Hardekopf. String Abstractions f or
String Veriﬁcation. In SPIN’11 .
[35] Y . Zheng and X. Zhang. Static Detection of Resource Con-
tention Problems in Server-Side Scripts. In ICSE’12 .