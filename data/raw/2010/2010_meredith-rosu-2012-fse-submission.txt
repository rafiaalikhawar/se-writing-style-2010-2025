Efï¬cient Parametric Runtime Veriï¬cation with
Deterministic String Rewriting
Patrick Meredith
University of Illinois at Urbana-Champaign
Urbana IL, USA
pmeredit@illinois.eduGrigore RoÂ¸ su
University of Illinois at Urbana-Champaign
Urbana IL, USA
grosu@illinois.edu
ABSTRACT
Early eorts in runtime verication and monitoring show
that parametric regular and temporal logic specications
can be monitored eciently. These approaches, however,
have limited expressiveness, since their specications always
reduce to monitors which are nite state machines. More
recent developments showed that parametric context-free
properties can be eciently monitored with overheads gener-
ally lower than 12{15%. While context-free grammars are
more expressive than nite-state approaches, they still do not
allow every computable safety property. This paper presents
a monitor synthesis algorithm for string rewriting systems
(SRS). SRSs are well known to be Turing complete, allowing
for the formal specication of any computable safety property.
Earlier attempts at Turing complete monitoring have been
relatively inecient. This paper demonstrates that monitor-
ing parametric SRSs is practical. The presented monitoring
algorithm uses a modied version of the Aho-Corasick string
searching algorithm for quick pattern matching with an in-
cremental rewriting approach that avoids reexamining parts
of the string known to contain no redexes.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veri-
cation| Assertion Checkers, Reliability ; D.2.5 [ Software
Engineering ]: Testing and Debugging| Monitors
General Terms
Algorithms, Reliability, Security, Verication
Keywords
Runtime Verication, Monitoring, String Rewriting
Supported in part by NSF grant CCF-0916893 and by NSA
contract H98230-10-C-0294.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
Copyright 20XX ACM X-XXXXX-XX-X/XX/XX ...$10.00.1. INTRODUCTION
Runtime verication (RV) is a formal analysis approach in
which specications of requirements are given together with
the code to check, as in traditional formal verication, but the
code is checked against its requirements at runtime, as in test-
ing. A large number of runtime verication techniques and
systems, including TemporalRover [18], JPaX [20], JavaMaC
[23], Hawk/Eagle [17], Tracematches [2, 3], J-Lo [8], PQL
[25], PTQL [19], MOP [15, 14], Pal [12], RuleR [5], etc., have
been developed recently, and the overall approach has gained
enough traction to spawn its own conference [4]. In a runtime
verication system, monitoring code is generated from the
specied properties and integrated with the system to moni-
tor. Therefore, a runtime verication approach consists of at
least three interrelated aspects: (1) a specication formalism,
used to state properties to monitor, (2) a monitor synthesis
algorithm, and (3) a means to instrument programs. The
chosen specication formalism determines the expressivity
of the runtime verication approach and/or system.
Monitoring safety properties is arbitrarily complex [28].
Early developments in runtime verication, showed that para-
metric regular and temporal-logic-based formal specications
can be eciently monitored against large programs. A para-
metric monitor associates monitor states with dierent object
instantiations for the given parameters. This allows for spec-
ication of properties about the relationships of objects, e.g.,
a relationship between a Collection object and its associated
Iterator objects in Java1. As shown by experiments with
Tracematches [3] and the most recent experiments using
JavaMOP [21], parametric regular and temporal logic speci-
cations can be monitored against large programs with little
runtime overhead, on the order of 15% or lower.
However, both regular expressions and temporal logics are
monitored using nite automata, so they have inherently lim-
ited expressivity. More specically, most runtime verication
approaches and systems consider only at execution traces ,
or execution traces without any structure. Consequently,
users of such runtime verication systems are prevented from
specifying and checking structured properties , those proper-
ties referring to the program structure such as properties
with requirements on the contents of the program call stack.
PQL [25], Hawk/Eagle [17], and RuleR [5] provide more
expressive logics, but these are relatively inecient [2, 3, 15].
More recently, JavaMOP was extended to support ecient
context-free monitors with runtime overheads very similar to
1Typestates [29], a popular concept in software engineering
and software analysis, can be monitored with parametric
monitors that have only one parameter.public class RandomEquality {
int numberOfNumbers;
public RandomEquality(int numberOfNumbers){
this.numberOfNumbers = numberOfNumbers;
}
public int nextNumber() {
return genNextNumber(numberOfNumbers--);
}
public boolean hasNextNumber(){
return numberOfNumbers > 0;
}
private int genNextNumber(int currentNumber){
//some logic that may or may not be correct
}
}
Figure 1: A Java class that provides random number
sequences of any length that maintain equality
the earlier nite-state logics [26]. While this work allows for
checking many structured properties, it does not have the
full power to specify any possible safety property. In this
paper, we introduce an algorithm for monitoring parametric
deterministic string rewriting systems, to serve as an ecient
runtime verication technique for specifying and monitoring
arbitrarily complex properties; indeed, string rewrite systems
are known to be as expressive as Turing machines [11]. We
also provide an implementation of our algorithm as an MOP
logic plugin [15, 14], so it can be used as integral part of the
JavaMOP runtime verication system. By abuse of vocabu-
lary, we will refer to deterministic string rewriting systems
as string rewriting systems and abbreviate them SRSs.
1.1 Examples
Safety properties that require more expressivity than a
context-free language are generally more intimately related
to the specics of the program under verication/test than
those that may be monitored using context-free or nite
logics. Conversely, less specic properties, such as correct
API usage, tend to be nite state [24]. As a relatively simple,
and admittedly contrived, example of a non context-free
property, consider the Java class, RandomEquality dened
in Figure 1. The idea of this class is to provide a random
string of numbers from the set f0;1;2gof a given length
dened by the parameter passed to the constructor that
maintains equality, that is, that the number of 2's is equal
to the number of 1's is equal to the number of 0's.
The JavaMOP specication presented in Figure 2, which
uses the new srslogic plugin, is able to catch any failures
of this class to provide equality. JavaMOP specications
begin with a declaration of the name of the specication and
parameters. Here the property is named EqualityCheck ,
and one parameter reof type RandomEquality . The parame-
ters allow us to associate separate monitor states with each
object instantiation of the parameters. In this case, with
one parameter, there will be one monitor state associated
with each object instance of RandomEquality in the program
under test. This is important because we would not wantEqualityCheck(RandomEquality re) {
event done after(RandomEquality re)
returning(boolean b) :
call(* RandomEquality.hasNextNumber())
&& target(re) && condition(!b) {}
event e0 after(RandomEquality re)
returning(int i) :
call(* RandomEquality.nextNumber())
&& target(re) && condition(i == 0) {}
event e1 after(RandomEquality re)
returning(int i) :
call(* RandomEquality.nextNumber())
&& target(re) && condition(i == 1) {}
event e2 after(RandomEquality re)
returning(int i) :
call(* RandomEquality.nextNumber())
&& target(re) && condition(i == 2) {}
srs :
e1 e0 -> e0 e1 . e2 e0 -> e0 e2 . e2 e1 -> e1 e2 .
e0 e1 -> E .
E e1 -> e1 E . E e0 -> e0 E .
E e2 -> #epsilon . e2 E -> #epsilon .
^ done -> #succeed .
e0 done -> #fail .
e1 done -> #fail .
e2 done -> #fail .
@succeed {
System.out.println(
p.toString() + " worked perfectly!"); }
@fail {
System.out.println(
p.toString() + " failed!"); }
}
Figure 2: A JavaMOP specication that nds equal-
ity failures in the RandomEquality class
calls to dierent object instances of the RandomEquality class
to interfere with each other as such would assuredly lead to
false positives and negatives.
The next part of a JavaMOP specication is the declara-
tion of events. Here we are able to generate four dierent
events: done,e0,e1, and e2. The events are dened us-
ing a superset [27] of AspectJ [22] advice with embedded
pointcuts. Here, the event done is dened to occur when
thehasNextNumber() method is called and returns false, sig-
nalling the end of the randomly generated number string2.
The events e0,e1, and e2all correspond to calls of nextNum-
ber() where the proper number in f0;1;2gis returned.
After the event denitions, we list the formalized property.
The keyword srstells JavaMOP that the following property
will be a deterministic string rewriting system. Rules in our
SRS formalism take the form \ l!r .", meaning that the
string of events on the left hand side of the arrow rewrites
to that on the right side. The three rules on the rst line
of this SRS sort the events: all e0come before all e1which
come before all e2. The rule e0 e1!Edenotes that we have
2Note that this requires properly calling hasNextNumber()
before calling hasNextNumber() . This can be ensured in
JavaMOP using a dierent, nite state, property.found a pair of e0and e1, which must be matched by an e2.
Note that the SRS rules can be applied in any order when
a new event is received, so it is user's responsibility to write
conuent SRSs or to use the deterministic order of rule
application explained in Section 3.1. The two rules on the
third line move all instances of Eto the right, so that they will
eventually become adjacent to any instances of e2. The two
rules on line four correspond to when such a situation occurs.
When Eis adjacent to e2we have found a triple, and we can
safely remove the symbol Efrom the string by rewriting it to
#epsilon , which is a keyword specic to the SRS formalism
in JavaMOP. The next rule is the success case, which occurs
when done is at the beginning of the string (denoting that all
0's, 1's, and 2's have been equal). The symbol ^corresponds
to the beginning of the string. Similarly, $corresponds to
the end, but is not used here. #succeed is a special keyword
that stops the rewriting process with the monitor signalling
that a success was found. Like #succeed ,#fail is a keyword
that stops the monitor with a failure returned.
The next three lines are the failure cases; each rewrites to
#fail . They occur when the number of 0's, 1's, and 2's was
not equal, because the string will always be empty when a
done occurs if they were properly balanced. The failure cases
rely on the incremental nature of the string rewriting process.
If taken as a normal SRS with complete strings as input, this
would not be conuent. That means, the choice of what order
to apply rules would result in dierent normal forms (See
Section 3.1). Because the normal form is computed between
the arrival of each event, e0,e1, or e2can only occur before
done in the string if an unequal number occurred. The string
rewriting process is explained fully in Sections 3.2{3.4.
The last part of a JavaMOP specication is the handler
section. Handlers are arbitrary Java code that is executed
when the monitor raises a particular condition. Here the
keywords @succeed and @fail denote that the code within the
subsequent braces is run when the string rewrites to #succeed
or#fail , respectively. In this example, the handlers simply
print out informative messages when such situations occur.
In general, handler code may be used for anything, such as
running a specic algorithm or recovering from the error
denoted by the failure of the safety property in question.
Aside from specifying properties which cannot be expressed
by context-free grammars, string rewriting systems can be
useful for expressing context-free and nite properties in a
natural, and often times more compact, form. Below are two
properties from earlier papers [26, 27] written as SRSs.
The rst property, called HasNext , is a property of the
Java Iterator interface stating that hasNext() should always
be called and return truebefore next is called. Below it is
specied as a regular expression:
(hasnexttrue next )next
The corresponding SRS is as follows:
hasnexttrue next ! #epsilon
hasnexttrue hasnexttrue ! hasnexttrue
^next! #fail
While this SRS is certainly larger than the original ERE, it
may be easier to understand by some users because it directly
captures the semantics of the property by simply enumer-
ating all the cases that one has to worry about. The rule
hasnexttrue hasnexttrue !hasnexttrue conveys the notion
that multiple calls to the hasNext() method are idempotent.hasnexttrue next rewrites to #epsilon because it is a safe op-
eration. If next is seen at the beginning of the string a failure
is raised as hasnexttrue was not properly called. Because
our algorithm is incremental and deterministically rewrites
from left to right it is not strictly necessary to match the
beginning of the string, but it is more clear conceptually.
The second property is a properly context-free property
called SafeLock which corresponds to the proper nesting
of acquiring and releasing locks. Proper nesting, in this case,
means that corresponding calls to acquire() and release()
occur within the same method body. Here begin and end
denote the beginning and end of a method body.
S!jSacquireMreleaseA
M!jMbeginMendjMacquireMrelease
A!jAbeginjAend
The property is fairly complex, and a complete explanation
can be found in [26]. The SRS for the property follows:
begin end! #epsilon
acquire release! #epsilon
begin release! #fail
acquire end! #fail
In this case, the SRS is quite a bit less complex than the
context-free grammar specifying the same safety property.
Again, it conveys interesting semantic information. From the
SRS it is clear that a begin followed immediately by a release()
results in an error because we require all release() to occur
in the same method call as the corresponding acquire() . Sim-
ilarly, an acquire() follow by a endresults in an error because
the lock is not correctly released within the method body.
begin end and acquire release rewrite to #epsilon because they
are properly nested when they occur adjacently.
1.2 Contributions
There are two main contributions to this paper:
An ecient, optimized string rewriting algorithm. It
builds upon a modication of the Aho-Corasick algo-
rithhm [1]. The original algorithm was designed for
quickly nding strings in text. Our modied algorithm
keeps track of substitution boundaries so that a rewrite
step can be performed in time linear to the length
of the right hand side of the matched rule3. To our
knowledge, this is the rst time it has been applied to
string rewriting. An optimization has also been devised,
which checks for early termination of rewriting.
An implementation and extensive evaluation of the
above algorithm as an MOP logic plugin for runtime
verication. This way, it can serve as a specication
formalism for parametric safety properties in instances
of the MOP framework, such as JavaMOP. We show
that its performance in practical runtime verication
of large systems is acceptable when compared to other
means to specify the same properties. Additionally, we
show that it outperforms one of the state-of-the-art
rewrite engines, Maude [16], which implicitly supports
string rewriting as rewriting modulo associativity.
1.3 Paper Outline
Section 2 presents related work in the eld of runtime
verication: popular runtime monitoring systems, with a
3The right hand side must be copied, so that the rule is still
viable the next time it matches.Approach Logic Scope Mode Handler
JPaX [20] LTL class oine violation
TemporalRover [18] MiTL class inline violation
JavaMaC [23] PastLTL class outline violation
Hawk [17] Eagle global inline violation
RuleR [5] RuleR global inline violation
Tracematches [3] Reg. Exp. global inline validation
J-Lo [8] LTL global inline violation
Pal [12] modied Blast global inline validation
PQL [25] PQL global inline validation
PTQL [19] SQL global outline validation
Figure 3: A Selection of Monitoring Systems
particular emphasis on those with greater than nite state
specication languages and on our framework of choice for
our implementation and experimental testbed, MOP. Sec-
tion 3 presents our string rewriting algorithm, with its use
and construction of pattern match automata and and opti-
mization that allows for early termination. Section 4 presents
our experimental results, and Section 5 concludes.
2. RELATED WORK AND MOP
Many approaches have been proposed to monitor program
execution against formally specied properties. Interested
readers can refer to [27] for an extensive discussion on ex-
isting runtime monitoring approaches. Briey, all runtime
monitoring approaches except MOP have their specication
formalisms hardwired, and few of them share the same logic.
There are four orthogonal attributes of a runtime mon-
itoring system: logic, scope, running mode, and handlers.
The logic species which formalism is used to specify the
property. The scope determines where to check the property;
it can be class invariant, global, interface, etc. The running
mode denotes where the monitoring code runs; it can be
inline (weaved into the code), online (operating at the same
time as the program), outline (receiving events from the
program remotely, e.g., over a socket), or oine (checking
logged event traces). The handlers specify what actions to
perform under exceptional conditions; such conditions in-
clude violation and/or validation of the property. It is worth
noting that for some logics, violation and validation are not
complementary to each other, i.e., the violation of a formula
does not always imply the validation of the negation of the
formula. MOP allows for handlers for any number of user
dened exceptional situations (called handler categories).
Most runtime monitoring approaches can be framed in
terms of these attributes, as illustrated in Figure 3, which
shows an (incomplete) summary of runtime monitoring sys-
tems. For example, JPaX can be regarded as an approach
that uses linear temporal logic (LTL) to specify class-scoped
properties, whose monitors work in oine mode and only
detect violation. In general, JavaMOP (the Java instance
of MOP) has proven to be the most ecient of the runtime
monitoring systems despite being generic in logical formalism.
Of the systems mentioned in Figure 3, only PQL [25],
Hawk/Eagle [17], and RuleR [5] provide logical formalisms
with greater than nite-state power. Hawk/Eagle adopts
a Turing-complete x-point logic, but it has problems with
large programs because it does not garbage collect the objects
used in monitoring. In addition, Hawk/Eagle is not publicly
available4. Because of this and the fact that Hawk/Eagle
4[3] makes an argument for the ineciency of Hawk/Eagle.has not been run on DaCapo [7] with the same properties,
we cannot compare JavaMOP with our new string rewriting
systems plugin with Hawk/Eagle. RulerR is a rule-based
monitoring system which has the ability to also specify Turing
complete properties. The current implementation of RuleR
is not built for eciency, and is, additionally, not publicly
available. PQL is not Turing-complete, and performance
comparisons with PQL using an older, less ecient, version
of JavaMOP can be found in [26]. String rewriting was used
in the context of monitoring for detection of malware in [6].
This was, in many ways, the inspiration for adding string
rewriting to MOP. However, the string rewriting patterns
allowed in that work were regular (i.e., can capture only
regular languages), while our goal is to provide a true Turing-
complete logical formalism for parametric monitoring.
MOP [15, 14] is an extensible runtime verication frame-
work that provides ecient, logic-independent support for
parametric specications. JavaMOP is an instance of MOP
for the Java programming language. It allows the devel-
oper to specify desired properties using formal specication
languages, along with code to execute when properties are
matched or fail to match. Monitoring code is then automati-
cally generated from the specied properties and integrated
together with the user-provided code into the original system.
MOP is a highly extensible and congurable runtime veri-
cation framework. The user is allowed to extend the MOP
framework with his/her own logics via logic plug-ins which en-
capsulate the monitor synthesis algorithms. This extensibility
of MOP is supported by an especially designed layered archi-
tecture [14], which separates monitor generation and monitor
integration. By standardizing the protocols between layers,
modules can be added and reused easily and independently.
MOP also provides ecient and logic-independent support
forparametric parameters [13], which is useful for specifying
properties related to groups of objects. This extension allows
associating parameters with MOP specications and generat-
ing ecient monitoring code from parametric specications
with monitor synthesis algorithms for non-parametric spec-
ications. MOP's generic support for parametric patterns
simplied our SRS plug-in's implementation.
The JavaMOP instance provides two interfaces: a web-
based interface and a command-line interface, providing the
developer with dierent means to manage and process Java-
MOP specications. AspectJ [22] is employed for monitor
integration: JavaMOP translates outputs of logic plug-ins
into AspectJ code, which is then merged within the original
program by an AspectJ compiler. Seven logic-plug-ins are
currently provided with JavaMOP: nite state machines, ex-
tended regular expressions, context-free grammars, past time
linear temporal logic, linear temporal logic with past and
future operators, past time linear temporal logic with calls
and returns, and, now, string rewriting systems. Descriptions
of the rst six plugin-ins can be found in [27].
3. MONITORING SRS SPECIFICATIONS
In this section, we present some basic notation for string
rewriting systems and our string rewriting algorithm which
was implemented as a logic plugin in the MOP framework.
Since Hawk/Eagle is not publicly available (only its rewrite
based algorithm is public [17]), the authors of Hawk/Eagle
kindly agreed to monitor some of the simple properties from
[10]. We have conrmed the ineciency claims of [3] with
the authors of Hawk/Eagle.3.1 Preliminaries
We refer the reader to [11] for an in-depth presentation of
string rewrite systems. For an alphabet , astring rewriting
system (SRS) is a binary relation, R, on, that is, a subset of
. The setfl2j(l;r)2Rgis called the domain of
R, denoted dom(R), while similarly the set fr2j(l;r)2
Rgis called the range , denoted range (R). We refer here to
any element (l;r)2Ras a rule inR, any l2dom(R)as a
left hand side (LHS) of a rule in R, and any r2range (R)
as a right hand side (RHS) of a rule in R. In our SRS
specications in this paper and in JavaMOP, rules ( l;r)2R
are written using the earlier shown syntax \ l!r".
The single-step reduction relation onthat is induced
byRis dened as: for any u;v2,u!Rvif and only if
there exists (l;r)2Rsuch that for some x;y2,u=xly
andv=xry. The reduction relation oninduced by Ris
the reexive, transitive closure of !Rand is denoted by !
R.
If forx;y2,x!
Ryandyis irreducible, yis anormal
form forx.Risconuent if there is only one such yfor any
givenx, regardless of the order in which rules are applied.
In our SRSs in MOP, the symbols s2correspond to
either events of our property or symbols that appear in the
RHS of rules in R. We call our string rewriting systems
deterministic because the same normal form will always be
chosen in the presence of a non-conuent R. Specically,
rules are applied left-to-right, with the smallest rule matching
rst in the case of overlap (e.g., for LHSs a aand a a b , the
rule with a aas its LHS will always be applied rst, starving
the other rule). In the case of a conict that is not resolved
by the above, the order of rules in the SRS specication is
used to determine which rule to apply (e.g., if two rules have
the same LHS, the one specied rst will always be applied).
3.2 String Rewriting Algorithm Overview
There are two major parts to our SRS algorithm:
1. Finding matches of the LHSs of rules; and
2. Performing replacements with RHSs of rules.
To make replacements as eciently as possible, the string
of events/symbols that we rewrite is a linked listed of the
SpliceList class, which was specially created for our purposes
to allow constant time replacement of a section of the list
with another list (splicing). The SpliceList class has a special
type of Iterator dened for it, called the SLIterator , that does
notfollow the normal Iterator interface in Java.
Rather than only having next() and hasNext() methods,
the SLIterator has next(int i) , which moves the SLIterator
forward itimes and returns true if it is successful (i.e., does
not reach the end of the SpliceList ), and get(), which returns
the current element that the SLIterator points to. SLIterator
also has a method, splice(SLIterator second, SpliceList replace-
ment) , which takes another SLIterator to the same SpliceList
and replaces the sequence denoted by those two SLIterator s,
inclusively, by a specied sequence replacement. It is because
of the inclusive nature of the splice method that the SLIterator
must have a method to retrieve its current element without
advancing. The splice method makes it imperative for our
string matching algorithm to maintain SLIterator s to the
beginning and end of the current LHS under consideration.
In Section 3.3 we discuss how this matching occurs using
a modication of the Aho-Corasick string searching algo-
rithm [1] that, unlike the base algorithm, keeps track of the
beginning of a match, so that rewrites can be performed in
constant time (after copying the RHS in time proportional toits length). To make the paper self-contained, we give all the
necessary information regarding the Aho-Corasick algorithm,
rather than only this modication, but the modication is
clearly delineated. To our knowledge, this is the rst time
any variation on the Aho-Corasick algorithm has been used
in string rewriting, and no implementations of SRSs exist,
that we could nd. In Section 3.4, we present an in-depth
explanation of how the pattern matching ts into the string
rewriting algorithm and how we optimize string rewriting to
avoid considering sequences that cannot match any LHS.
3.3 Pattern Match Automata
The pattern match automata used by our string rewriting
process, as mentioned, is a modication of the Aho-Corasick
algorithm for nding strings in text [1]. The Aho-Corasick
algorithm, which was originally not designed for string rewrit-
ing, is able to nd all matches in a string in one linear pass,
rather than performing separate passes for each rule LHS as
would a naive matching algorithm. Our modication of the
algorithm allows us to correctly adjust the SLIterator to the
beginning of our current match, facilitating quick rewrites.
3.3.1 Using Pattern Match Automata
Figure 4 shows the pattern match automaton for the Safe-
Lock property. Each node has at least its state number
and state depth, listed as a pair number :depth . The depth
is used in two places in the automata generation algorithm,
and simply states how many symbols (events) have been pro-
cessed since the start state in one of the LHSs of the rewrite
rules in our SRS. This will be explained in more detail below.
Additionally, states which correspond to matching the left
hand side of a given rule also display that rule, e.g., in state
6, the begin release!#fail rule is matched. Each edge is
marked by the list of symbols that cause that transition, as
well as a number following a \/". That number, which we
refer to as the action , is the number of times to increment
therst SLIterator except in the self-transitions of state 0.
When a self-transition in state 0 occurs, the rst Iterator
must be incremented once. When a forward transition with
\/ 0" is encountered, a transition to the next state is made,
and the next input is considered. If the transition is suxed
with something other than 0, the transition must be a back-
ward transition, and the same symbol that is currently under
consideration must be evaluated in the next state. This is
why we handle self-transitions in state 0 as a special case,
if it were suxed with \/ 1" and handled as a backward
transition, the same symbol would be considered innitely.
Figure 5 shows the pseudocode for pattern matching using
a given pattern match automaton. The only global variable
for the algorithm is the given PatternMatchAutomaton ,pma.
The algorithm begins by initializing the rst and second
SLIterator s to the beginning of the argument SpliceListl, using
thehead() method. The local currentState is initialized to
the initial machine state, here represented as 05. The while
loop beginning on line 10 will only exit when the end of
lis reached, denoted by the break statements on lines 20
and 25. We know that the end of lis reached on lines
20 and 25 when the next(int i) method returns false. We
never need to check if rst.next returns false because it may
never advance past second due to the construction of the
PatternMatchAutomaton . Lines 17{22 cover the self transition
5It is actually a class that may contain a matched rule, as
we can see in Figure 4.acquire / 0begin ,acquire / 1
end / 0
begin,end,acquire,release / 2begin,end,acquire,release / 2
release / 0end,release / 0
release / 0begin ,acquire / 1begin
,end
,acquire
,release / 2begin / 0begin,end,acquire,release / 2
end / 01 : 10 : 0
3 : 1
2 : 2
(begin end !#epsilon )5 : 2
(acquire end !#fail )4 : 2
(acquire release !#epsilon )6 : 2
(begin release !#fail )
Figure 4: Pattern match automaton for the SafeLock property (see Section 1.1)
to state 0 mentioned earlier, while lines 23{27 represent a
normal forward transition. 23{27 are a forward transition
because the action of the transition is 0. As mentioned
earlier, the only dierence between the 0 self-transition and
a forward transition is that in the self-transition the rst
SLIterator need be incremented (line 18). Lines 28{30 handle
a backward transition in the PatternMatchAutomaton . As
expected, with a backward transition the rst SLIterator is
incremented a number of times specied by the action of
transition and second isnotincremented so that the same
symbol will be considered in the next iteration of the loop.
One interesting property of this algorithm is that if one
pattern is a prex of another, such as the patterns \ aa!c"
and \a a b!d", both matches will be reported. This
is undesirable behavior for rewriting because \ aa" will be
rewritten to cimmediately and \ a a b " should no longer be
matchable. This will be accounted for in Section 3.4.
As an example of how the pattern match algorithm func-
tions, suppose that the following series of events have been
seen at a given point in a program: begin begin acquire begin
end. At this point, the SafeLock property will experience
its rst match of a rule LHS. Figure 6 shows the state transi-
tions as each symbol is considered, as well as the position of
therst SLIterator . An important thing to note is that every
time we transition back to state 0, the rst SLIterator index
is incremented by 1 (specied by the back transitions), and
the symbol is evaluated again in state 0. In general, back
transitions need not be to state 0, as we shall see. At the
end of the input, the algorithm is in state 2, which matches
the rule begin end!#epsilon . The rst SLIterator correctly
points to index 3, which is the last begin event. The second
SLIterator always points at the current input, which is end.
These SLIterator s can then be used to quickly replace begin
endwith #epsilon , as we will see in Section 3.4.3.3.2 Generating Pattern Match Automata
There are two main phases to the creation of pattern match
automata. In the rst phase the forward transitions of the
automaton are created. In the second phase, all of the back-
ward transitions and the self-transition that (almost) always
exists in state 0 are added. During the computation of the
backward transitions, the actions for the backward transition
are also computed and added to the backward transitions.
As mentioned, only backward transitions ever have non-0
actions, since they correspond to places in the automaton
where there is a switch from matching one potential set of
LHSs of rules to another. For instance, in Figure 6, between
the third begin and the rst acquire , there is a switch from
potentially matching fbegin end, begin release gtofacquire
end, acquire release g, which requires no longer considering
thebegin event for match purposes, thus the action of 1.
To create the forward transitions for an automaton, we add
one path that corresponds directly to the left hand side of
each rule in our string rewriting system. We add these paths
one at a time, and reuse as many states as possible. Each
forward transition is assigned the action 0. Figure 7 shows
the forward transitions for the pattern match automaton
originally presented in Figure 4. For each LHS, we begin at
state 0 and add a transition for the rst symbol. Because
all patterns SafeLock begin with either begin oracquire ,
we have only two transitions, one labeled with begin and
one labeled with acquire . We continue to transitively add
transitions based on the remainder of each LHS. For the two
rule LHSs beginning with begin , one ends with endand the
other ends with release , so there are two transitions out of
state 1 labeled accordingly. As each new state is added to
the machine during the forward transition phase, the depth
of the state is recorded. The depth is simply the number of
symbols from state 0. For instance, state 6 is at depth 2,
since two symbols, begin followed by end, lead to state 6. The
largest depth always corresponds to the longest rule LHS.1globals PatternMatchAutomaton pma
2locals SLIterator rst;second
3 State currentState ;nextState
4 Symbol symbol
5 Transition transition
6procedure match (SpliceListl)
7rst l:head()
8second l:head()
9currentState 0
10while (true)f
11 if(currentState :hasMatch ())f
12==signal match
13g
14 symbol second:get()
15 transition pma:get(currentState ;symbol )
16nextState transition:state
17 if(nextState = 0)f
18 rst:next(1)
19 if(:second:next(1))f
20 break
21g
22g
23 else if (transition:action = 0)f
24 if(:second:next(1))f
25 break
26g
27g
28 elsef
29 rst:next(transition:action )
30g
31 currentState nextState
32g
Figure 5: Pattern Match Algorithm
current state symbol next state rst index
0 begin 1 0
1 begin 0 1
0 begin 1 1
1 acquire 0 2
0 acquire 3 2
3 begin 0 3
0 begin 1 3
1 end 2 3
Figure 6: A run of the pattern match algorithm on
begin begin acquire begin end
0 : 0 1 : 1 3 : 1
2 : 2 6 : 2 4 : 2 5 : 2begin / 0acquire / 0
end / 0release / 0
acquire / 0end / 0
Figure 7: Forward Transitions for SafeLock
(matched rules omitted)In the second phase, the self-transition on state 0 is added
rst, if needed. The self-transition is only necessary if there
is not a forward transition out of state 0 for every symbol
used in the SRS or specied by the JavaMOP front end6.
After potentially adding the self-transition in state 0, the
backward transitions are added to the pattern match au-
tomaton. Backward transitions are only added from a given
state for symbols that do not have forward transitions out
of that state. All backward transitions from a given state, s,
will go to the same place, so we dene fail(s) =s0, wheres0
is the destination of a backward transition out of s. To nd
the destination for the backward transitions out of a state
in pattern match automaton pma with depth d, we consider
each staterof depthd 1and perform the following actions,
transitions are added in depth rst order [1]:
1.Ifpma.get(r;a)is a backward transition for all symbols
a, do nothing.
2.Otherwise, for each symbol asuch that pma.get(r;a)
=s, do the following:
(a) Lets0=fail(r).
(b) Compute s0 fail(s0) until such point as
pma:get(s0;a):action = 0. Because state 0 must
have either a forward transition or a self-transition
for every symbol, such an s0must exist.
(c)For alla0such that pma:get(s;a0)has no for-
ward transition, assign pma:get(s;a0):state =s0,
pma.get(s,a0).action =s.depth -s'.depth .
The procedure above is essentially the same as [1]. The
part in bold is specic to our algorithm for string rewriting.
The action is assigned as such because the depth of a given
state represents the number of symbols processed since state
0 in the automaton, thus the dierence in the depths tell us
the number of symbols that we need to skip with the rst
SLIterator in Figure 5. While the pattern match automaton
forSafeLock has backward transitions that only go to state
0, as mentioned, this is not always the case in general. When
the sux of one LHS overlaps with the prex of another,
backward transitions that do not go back to state 0 are
generated. An example of this can be seen in Figure 8, where
the SRS in question is b a a!#epsilon ,a a c!#epsilon .
Because b a a and a a c have a sux/prex overlap, the
backward transitions from state 3 at depth 3 go to state 5
at depth 2, resulting in an action of only 1. For example,
consider input b a a c . When we switch from matching b a a
to matching a a c, which occurs between states 3 and 5, we
wish to only \forget" the bat the beginning, an action of 1.
3.4 Rewriting using Pattern Match Automata
The rewriting algorithm we use to monitor SRS's is pre-
sented in Figure 9. Not pictured in Figure 9, is the action
of the monitor itself. As any monitoring algorithm in the
MOP framework, events arrive one at a time. As each event
occurs, we add it|as a symbol representing that event|to
aSpliceList that contains the results of rewriting previous
sequences of events. Additionally, if any rules make use of the
^ symbol, it will be added to the beginning of the SpliceList
6JavaMOP allows one to dene events that do not appear in
the specied property; these will correspond to symbols that
are never rewritten by the specied SRS.c, b / 1
a / 0
a, c, b / 1a, c, b / 3
a, b / 1 a / 0c / 0
a / 0
c / 0c, b / 1b / 0
a / 0
c, b / 11 : 10 : 0
3 : 3
(b a a!#epsilon)2 : 2
5 : 2
4 : 16 : 3
(a a c!#epsilon)
Figure 8: A pattern match automaton with overlap
and treated as a normal symbol by the rewriting algorithm.
As for uses of $, the current event must be added before $7.
After an event is added to the SpliceList , the algorithm in
Figure 9 is evaluated to completion before another event can
be accepted. The algorithm is similar to the pattern match
procedure of Figure 5. The changes are in bold. There are
three main changes: the inclusion of a loop that ensures that
a normal form is reached, the actual rewriting step itself,
and a section that recognizes early termination.
The rst new control structure to notice is the do...while
loop from line 8 to 56. This loop ensures that rewriting
continues until there is a pass through the loop in which
nothing changes, i.e., the string is in normal form. The new
boolean variable, changed , controls this loop. It is set to false
at the beginning of an iteration of the do...while loop, and to
trueon line 24, which is only executed when a rewrite occurs.
Lines 15{28 perform the actual rewriting step. The element
match of a State contains the right hand side of the rule
matched in that State . If the match is one of the two special
keywords #succeed or#fail , a success or fail handler is
executed, as appropriate, and rewriting terminates. If either
handler is executed, the monitor is considered dead unless it is
reset (see [27]). If match is something else, the splice method
is called on line 22. The splice method is a special method of
SLIterator that replaces a range specied by the thisand an
argument SLIterator with the argument sequence. Here the
range is specied by rstandsecond , and currentState .match
7Because of this there is a very small performance hit for
using $ in a rule, but ^ is essentially free.1globals PatternMatchAutomaton pma
2locals SLIterator rst;second;last
3 State currentState ;nextState
4 Symbol symbol
5 Transition transition
6 boolean changed pastLast
7procedure match (SpliceListl)
8dof
9 rst l:head()
10 second l:head()
11 currentState 0
12 changed false
13 pastLast false
14 while (true)f
15 if(currentState :hasMatch ())f
16 if(currentState .match =#succeed )f
17 //raise succeed
18 g
19 if(currentState .match =#fail)f
20 //raise fail
21 g
22 rst.splice (second ,currentState .match )
23 nextState 0
24 changed true
25 pastLast false
26 last second
27 second rst.copy()
28g
29 symbol second:get()
30 transition pma:get(currentState ;symbol )
31nextState transition:state
32 if(nextState = 0)f
33 rst:next(1)
34 if(:second:next(1))f
35 break
36g
37g
38 else if (transition:action = 0)f
39 if(:second:next(1))f
40 break
41g
42g
43 elsef
44 rst:next(transition:action )
45g
46 if(:changed )f
47 if(second =last)f
48 pastLast true
49 g
50 if(pastLast andnextState = 0) f
51 return
52 g
53 g
54 currentState nextState
55g
56gwhile (changed )
Figure 9: Rewriting Algorithmevent initial l l in normal form
begin begin begin
end begin end #epsilon
begin begin begin
acquire begin acquire begin acquire
release begin acquire release begin
acquire begin acquire begin acquire
end begin acquire end #fail
Figure 10: An SRS monitoring run for SafeLock
is passed as the replacement. Note that if the right hand
side of the rule is #epsilon , it is represented as an empty
sequence, which splice is able to handle. The splice method
also correctly sets rst and second to point to the beginning
and end of the spliced in match sequence, or the next symbol
ifmatch was #epsilon . On line 26, we set lasttosecond , so
that lastpoints to the end of the last replacement, this will be
used to determine early termination. Then, on line 27, second
is set as a copy of rst. This ensures that segments of string
which are transitively rewritten will be rewritten immediately.
Because splice changes the SpliceList , it is important to set
currentState back to state 0 because any matching will occur
in the newly rewritten segment of the SpliceList .
In the last new addition to the match algorithm, from lines
46 to 53, we test for early termination of the algorithm. The
idea here is to exit early if we enter a segment of the SpliceList
that we know for certain cannot be rewritten. This happens
when we reach a point that is past the end of the last SLIter-
ator, which was set in a previous iteration, no rewrites have
occurred in the current iteration, and currentState returns to
0. The rst two requirements are fairly straight-forward: if a
change occurs, new matches are possible, and if we are in a
segment of the SpliceList before the last rewrite, we are still
investigating symbols that are potentially new. However, if
there is no rewrite in the current iteration and we are past the
last change from the previous iteration, we are seeing symbols
that were seen in the previous iteration with no change. The
last condition, that we must return to State 0, is more subtle.
The reason for this is that there could have been a rewrite
in the last iteration that inserted a segment that appears in
the middle of a left hand side of one of the rules. A simpler
way to look at this requirement is that if pma is not in state
0 it is actively matching something . This condition for early
termination can lead to an unbounded amount of saving, as
theSpliceList can be of an unbounded length.
Figure 10 shows a monitor run as non-parametric events for
SafeLock arrive. The non-parametric events are dispatched
to the correct monitor instance by the indexing of JavaMOP
(or whatever projection method is used in future language
instances of MOP). The rst column shows the arriving
event, the second column shows the state of the SpliceListl
before any rewriting, and the last column shows the normal
form forlafter the rewriting algorithm of Figure 9 has
run. After the last event a failure has occurred, and the fail
handler will execute.
4. EVALUATION
Our SRS implementation is evaluated in two contexts: rst
we show how it compares, within the context of JavaMOP,
to nite-state logics on the DaCapo benchmark suite [7].Then we give a comparison of our underlying SRS rewrite
engine against the Maude [16] term rewriting engine, modulo
associativity. The goal of the rst evaluation is to show
that SRS monitoring is ecient enough to be used in large
programs, being not much less ecient than nite-state logics
(extended regular expressions in this case). The goal of the
second experiment is to show that our SRS implementation
is more ecient than the state-of-the-art8.
All experiments were performed on a machine with a
3.82GHz Intel RCoreTMi7 970 hexcore with Hyper-Threading
(12 hardware threads) and 24 GB of ram. Ubuntu 11.10 64
bit was used as the operating system and version 9.12 of
DaCapo was used as the benchmark suite, with default in-
puts and the -converge option to gain convergence within 3%.
OpenJDK version 1.6.0 23 as the Java virtual machine. All
compiled JavaMOP specs were weaved into DaCapo using
ajc 1.6.11. Maude 2.6 was used for comparison with Maude.
The following properties were used in the DaCapo exper-
iments. The SRS versions of them (shown below) are new,
while the extended regular expression versions were borrowed
from [10, 9, 13, 26].
HasNext : Do not use the next element in an Iterator
without checking for the existence of it (see Section 1.1);
SafeSyncCol : If a Collection is synchronized, then
its iterator also should be accessed synchronously:
sync asyncCreateIter ! #fail
sync syncCreateIter accessIter ! #fail
SafeSyncMap : If a Collection is synchronized, then
its iterators on values and keys also should be accessed
in a synchronized manner:
sync createSet asyncCreateIter ! #fail
sync createSet syncCreateIter accessIter ! #fail
UnsafeIter : Do not update a Collection when using
the Iterator interface to iterate its elements:
update use! #fail
use use! use
update update! update
createIterator! #epsilon
UnsafeMapIter : Do not update a Map when using
the Iterator interface to iterate its values or its keys:
update use! #fail
use use! use
update update! update
createIterator! #epsilon
createCollection ! #epsilon
For the comparison with Maude, strings of equal numbers
of 2's, 1's, and 0's, with the 2's preceding the 1's preceding
the 0's were generated, and the following rewrite system
applied. Note, that the language of strings that reduce to
#epsilon with this rewrite system is non-context free. It is
very similar to EqualityCheck from Section 1.1.
1 0! 0 1 2 0! 0 2
2 1! 1 2 0 1! 3
1 3! 3 1 3 0! 0 3
3 2! #epsilon 2 3! #epsilon
8Note that Maude is more general than our SRS engine, but
there is a price for that generality, and general term rewriting
makes little sense in the context of MOP event traces.Benchmark Original (ms) HasNext SafeSyncCol SafeSyncMap UnsafeIter UnsafeMapIter
ERE SRS ERE SRS ERE SRS ERE SRS ERE SRS
avrora 2317194 227 3510328 12025328841 134
batik 773 0 6 5 11 9 -1 5 3 1 2
eclipse 11749 -1 -2 -2 -4 -1 -3 -2 -2 -2 -2
fop 251 922 2091 26 24 21 20 34 57 28 42
h2 3860 9 15 6 2 0 4 15 22 8 24
jython 1400 3 4 3 3 4 2 16 18 3 3
luindex 478 2 -1 2 0 0 4 1 2 0 -5
lusearch 581 1 3 -1 1 3 3 46 46 2 0
pmd 1441 27 117 139 137 10 17 72 148 177 199
sunow 1222 5 8 0 -1 6 -3 -4 4 0 3
tomcat 1068 2 4 3 3 3 1 2 2 2 2
tradebeans 4618 2 1 -1 -3 -1 2 4 -2 -2 -1
tradesoap 3213 1 -1 1 -1 0 -2 1 0 0 0
xalan 359 5 1 5 1 6 3 90 172 7 8
Figure 11: Comparison of JavaMOP with extended regular expressions (ERE) and with the same properties
expressed as string rewriting systems (SRS): average percent overhead (convergence within 3% except those
marked with *)
N Maude Time (ms) SRS Time (ms)
100 42 33
1000 37038 236
5000 DNF 7112
10000 DNF 26132
Figure 12: Comparison of maude versus SRS
rewrite. DNF: did not nish in one hour
Figure 11 shows a comparison of nite-state properties
specied in JavaMOP using ERE and SRS. The rst column
shows the individual DaCapo [7] benchmarks, and the sec-
ond column shows runtime of the original uninstrumented
benchmarks in milliseconds. All other columns are percent
overhead. Each benchmark-property pair converged to within
3% except the instances of avrora marked with *. The results
presented for avrora that did not converge are the average of
twenty runs with outliers removed, but they are still not as
trustworthy as the converging results. This lack of conver-
gence is a problem on highly multithreaded machines. We
can see that even the uninstrumented, original run, fails
to converge. Negative overheads are the result of noise in
the experimental settings and changes in code layout due to
instrumentation resulting in slightly more ecient programs.
Overall, the average overhead on the DaCapo benchmark
suite was 58% for SRS, while it was 33% for ERE. When
fop-HasNext |which has, by far, the worst overhead of any
trial|is removed from both, the overhead drops to 29% and
20%, respectively. It must be noted, that the properties we
use are specically selected for generating large overheads;
they are very intensive properties that generate many events
(see [21]). The overhead numbers are slightly larger than
reported in previous papers because we have moved to a multi-
threaded, and quite simply faster, machine. The monitors
in JavaMOP must be synchronized, which results in higher
overhead for programs that actually make use of multiple
threads. Any monitoring system must do the same thing ifthe monitors are for cross-thread properties (like all of those
properties used here). In most of the benchmark/property
pairs, the performance of ERE and SRS are very comparable.
For pmd-HasNext and avrora -SafeSyncMap , SRS shows
more than three times the overhead of ERE, but for all other
trials SRS is never more than three times worse.
Figure 12 shows the comparison of Maude to our SRS
engine with the rewrite system discussed above. N refers to
the number of each digit, i.e., N=100 has 300 characters in
it: 100 each of 2, 1, and 0. As we can see from the results,
our SRS engine runs in 78% of the time of maude at N=100.
At N=1000, our SRS engine runs in .006% of the time of
Maude. With larger inputs, Maude fails to complete in an
hour, while our SRS engine takes less than 30 seconds on
every tested input.
5. CONCLUSION
We provided the rst means to eciently monitor para-
metric Turing-complete specications using string rewriting
systems. By using a modied version of the Aho-Corasick
string matching algorithm and a means to terminate the
rewriting process early, the resultant string rewriting algo-
rithm is quite practical, as shown in our extensive evaluation9.
The average overhead on the DaCapo benchmark suite was
58% for SRS, while it was 33% for ERE. When the largest
benchmark/property pair is removed from both, the overhead
drops to 29% and 20%, respectively. A less extensive com-
parison of our core string rewriting algorithm with the term
rewrite engine Maude, which provides implicit support for
string rewriting through its rewriting modulo associativity,
suggests that our approach can lead to new string rewriting
engines that outperform the state-of-the-art.
9Special thanks to Dongyun Jin for help with DaCapo ex-
perimental settings.6. REFERENCES
[1] A. V. Aho and M. J. Corasick. Ecient string
matching: An aid to bibliographic search.
Communications of the ACM , 18(6):333{340, 1975.
[2] C. Allan, P. Avgustinov, A. S. Christensen, L. J.
Hendren, S. Kuzins, O. Lhot ak, O. de Moor, D. Sereni,
G. Sittampalam, and J. Tibble. Adding trace matching
with free variables to AspectJ. In OOPSLA'05 , pages
345{364. ACM, 2005.
[3] P. Avgustinov, J. Tibble, and O. de Moor. Making
trace monitors feasible. In OOPSLA'07 , pages 589{608.
ACM, 2007.
[4] H. Barringer, Y. Falcone, B. Finkbeiner, K. Havelund,
I. Lee, G. J. Pace, G. Rosu, O. Sokolsky, and
N. Tillmann, editors. Runtime Verication - First
International Conference, RV 2010, St. Julians, Malta,
November 1-4, 2010. Proceedings , volume 6418 of
Lecture Notes in Computer Science . Springer, 2010.
[5] H. Barringer, D. Rydeheard, and K. Havelund. Rule
systems for run-time monitoring: from eagle to ruler. J.
Logic Computation , pages exn076+, November 2008.
[6]P. Beaucamps, I. Gnaedig, and J.-Y. Marion. Behavior
abstraction in malware analysis. In RV, pages 168{182,
2010.
[7] S. M. Blackburn, R. Garner, C. Homan, A. M. Khan,
K. S. McKinley, R. Bentzur, A. Diwan, D. Feinberg,
D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking,
M. Jump, H. Lee, J. E. B. Moss, A. Phansalkar,
D. Stefanovi c, T. VanDrunen, D. von Dincklage, and
B. Wiedermann. The DaCapo benchmarks: Java
benchmarking development and analysis. In
OOPSLA'06 , pages 169{190. ACM, 2006.
[8]E. Bodden. J-LO, a tool for runtime-checking temporal
assertions. Master's thesis, RWTH Aachen University,
2005.
[9] E. Bodden, F. Chen, and G. Ro su. Dependent advice:
A general approach to optimizing history-based aspects.
InProceedings of the 8th International Conference on
Aspect-Oriented Software Development (AOSD'09) ,
pages 3{14. ACM, 2009.
[10]E. Bodden, L. Hendren, and O. Lhot ak. A staged static
program analysis to improve the performance of
runtime monitoring. In ECOOP'07 , volume 4609 of
LNCS , pages 525{549, 2007.
[11] R. V. Book and F. Otto. String-rewriting systems .
Texts and monographs in computer science. Springer,
1993.
[12] S. Chaudhuri and R. Alur. Instumenting C programs
with nested word monitors. In Model Checking
Software(SPIN'07) , volume 4595 of LNCS , pages
279{283, 2007.
[13] F. Chen, P. Meredith, D. Jin, and G. Rosu. Ecient
formalism-independent monitoring of parametric
properties. In Automated Software Engineering
(ASE'09) , pages 383{394. IEEE, 2009.
[14] F. Chen and G. Ro su. Towards monitoring-oriented
programming: A paradigm combining specication and
implementation. In Runtime Verication(RV'03) ,
volume 89 of ENTCS , 2003.
[15] F. Chen and G. Ro su. MOP: An ecient and generic
runtime verication framework. In OOPSLA'07 , pages
569{588. ACM, 2007.[16] M. Clavel, F. Dur an, S. Eker, P. Lincoln,
N. Mart -Oliet, J. Meseguer, and C. Talcott. All About
Maude-A High-Performance Logical Framework: How
to Specify, Program, and Verify Systems in Rewriting
Logic . Springer-Verlag New York, Inc., 2007.
[17] M. d'Amorim and K. Havelund. Event-based runtime
verication of Java programs. ACM SIGSOFT Software
Engineering Notes , 30(4):1{7, 2005.
[18] D. Drusinsky. Temporal Rover, 1997{2009.
http://www.time-rover.com .
[19]S. Goldsmith, R. O'Callahan, and A. Aiken. Relational
queries over program traces. In OOPSLA'05 , pages
385{402. ACM, 2005.
[20] K. Havelund and G. Ro su. Monitoring Java programs
with Java PathExplorer. In Runtime
Verication(RV'01) , volume 55 of ENTCS , 2001.
[21] D. Jin, P. O. Meredith, D. Grith, and G. Ro su.
Garbage collection for monitoring parametric
properties. In Programming Language Design and
Implementation (PLDI'11) , pages 415{424. ACM, 2011.
[22] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten,
J. Palm, and W. G. Griswold. An overview of AspectJ.
InECOOP'01 , volume 2072 of LNCS , pages 327{353,
2001.
[23] M. Kim, M. Viswanathan, S. Kannan, I. Lee, and
O. Sokolsky. Java-MaC: A run-time assurance approach
for Java programs. Formal Methods in System Design ,
24(2):129{155, 2004.
[24] C. Lee, D. Jin, P. O. Meredith, and G. Ro su. Towards
categorizing and formalizing the JDK API. Technical
Report http://hdl.handle.net/2142/30006 ,
Department of Computer Science, University of Illinois
at Urbana-Champaign, March 2012.
[25] M. Martin, V. B. Livshits, and M. S. Lam. Finding
application errors and security aws using PQL: a
program query language. In OOPSLA'07 , pages
365{383. ACM, 2005.
[26] P. Meredith, D. Jin, F. Chen, and G. Ro su. Ecient
monitoring of parametric context-free patterns. Journal
of Automated Software Engineering , 17(2):149{180,
June 2010.
[27] P. O. Meredith, D. Jin, D. Grith, F. Chen, and
G. Ro su. An overview of the MOP runtime verication
framework. International Journal on Software
Techniques for Technology Transfer , 2011.
http://dx.doi.org/10.1007/s10009-011-0198-6.
[28] F. B. Schneider. Enforceable security policies. ACM
Transactions on Information System Security ,
3(1):30{50, 2000.
[29] R. E. Strom and S. Yemeni. Typestate: A
programming language concept for enhancing software
reliability. IEEE Transactions on Software Engineering ,
12:157{171, January 1986.