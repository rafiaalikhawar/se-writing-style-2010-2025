SemFix: Program Repair via Semantic Analysis
Hoang D. T. Nguyen Dawei Qi Abhik Roychoudhury
School of Computing, National University of Singapore
fhoangdtn,dawei,abhik g@comp.nus.edu.sgSatish Chandra
IBM Research
satishchandra@us.ibm.com
Abstract ‚ÄîDebugging consumes signiÔ¨Åcant time and effort in
any major software development project. Moreover, even after
the root cause of a bug is identiÔ¨Åed, Ô¨Åxing the bug is non-trivial.
Given this situation, automated program repair methods are of
value. In this paper, we present an automated repair method
based on symbolic execution, constraint solving and program
synthesis. In our approach, the requirement on the repaired code
to pass a given set of tests is formulated as a constraint. Such
a constraint is then solved by iterating over a layered space
of repair expressions, layered by the complexity of the repair
code. We compare our method with recently proposed genetic
programming based repair on SIR programs with seeded bugs,
as well as fragments of GNU Coreutils with real bugs. On these
subjects, our approach reports a higher success-rate than genetic
programming based repair, and produces a repair faster.
I. I NTRODUCTION
Bug Ô¨Åxing continues to be a mostly manual, time consum-
ing, and therefore expensive activity in software development.
Therefore, automated techniques to repair buggy programs
can be of tremendous value. In particular, given that compute
cycles are cheap and abundant, it makes sense to investigate
techniques that help shift the ‚Äúheavy lifting‚Äù of program repair
from the human to the computer. While a programmer might
not blindly trust a computer-generated Ô¨Åx to her code, her
task can become considerably easier: rather than Ô¨Ågure out a
Ô¨Åx, just verify that an automatically generated Ô¨Åx is correct.
Not surprisingly, researchers have recently started looking into
automated program repair tools [1]‚Äì[3].
We focus on general purpose programs, for which a test
suite is available as a way to tell whether the program is
working correctly (i.e. it passes all the tests) or not (i.e. there
exists a failing test), but otherwise no formal speciÔ¨Åcation
of correct behavior is available; this is generally the case in
practice (by contrast, kernels that manipulate data structures
often do have speciÔ¨Åcations, and automatic repair on data
structure programs have been well studied, for example see [4],
[5]). A successful repair would be a modiÔ¨Åcation of the
program such that it passes all the tests in the test suite.
One of the most successful techniques in recent work that
works on general programs is based on syntactic search. The
premise behind this technique is that, once we know where the
defective expression is in the program, a correct expression
may be present syntactically at another place in the program,
so it is a matter of searching over a space of replacements
from among existing expressions.1The technique uses genetic
programming technique for searching over this space, and has
1This is an oversimpliÔ¨Åcation, but broadly speaking this is the idea.been shown to work for large programs [6]. The limitation
of this technique is that the correct expression should be
present in the program; the technique cannot ‚Äúsynthesize‚Äù an
appropriate expression from variables and constants.
An obvious response to the limitation would be a search
over a space of syntactic expressions, without consideration of
whether those expressions appear elsewhere in the program.
Such an approach would be more in the Ô¨Çavor of sketching [7],
[8]. However, unless the space of repair expression is Ô¨Åxed
upfront (possibly as a set of templates), such a technique will
not work. Furthermore, as our experiments show, enumerating
over the set of possible repair templates is inefÔ¨Åcient.
In this paper, we explore a constraint based semantic
approach towards program repair. The repair constraints are
generated by our desire to have the repaired program pass
the given test cases. Thus, given a program location to be
Ô¨Åxed, we derive constraints on the expression to appear in
the program location, in order to have the changed program
pass all the given tests. The repair constraints are generated
via (controlled) symbolic execution and the expression to be
repaired is obtained via program synthesis. We report that,
for certain kinds of program and bugs, the semantics-based
approach can not only have a higher-success rate than a
syntactic search-based approach, but also be able to produce
a repair faster. At the same time, we do believe that symbolic
execution imposes certain scalability limitations on the size of
programs we can handle.
Our approach is a combination of three existing techniques.
Fault isolation , i.e. where to Ô¨Åx the problem. The tech-
nique uses the ranking produced by a statistical fault
isolation [9] tool (it shares this step with the search-based
techniques.) Our approach examines one buggy statement
at a time from a ranked suspicion report of statements.
Statement-level speciÔ¨Åcation inference . We automatically
discover the correct speciÔ¨Åcation of the buggy statement.
We use an idea similar to the one used in angelic
debugging [10] in converting an expression to a non-
deterministic expression. This step allows us to create,
for each input to the buggy statement, the output that
would have resulted in the test passing.
Program synthesis . The third idea is to use component-
based synthesis idea [11] to synthesize an expression that
conforms to the speciÔ¨Åcation discovered before.
The inter-play of the second and third steps is the primary
novelty of our repair tool. The statement-level speciÔ¨Åcation
narrows the search space signiÔ¨Åcantly, and sets up the problemfor component-based synthesis that is based on constraint
solving. We also apply two other important performance
optimizations. First, instead of creating a constraint over the
entire test suite, we create it using a subset of tests, adding tests
incrementally to the mix. Second, among the set of possible
expressions that can be synthesized, we explore in order of
increasing complexity, so the tool can Ô¨Ånd simple Ô¨Åxes quicker.
We have experimentally evaluated our method as well as
genetic programming on SIR subjects with seeded bugs, as
well as fragments of GNU Coreutils with real bugs. The
use of state-of-the-art SMT solvers and program synthesis
engines allow our repair timings to be less than that of genetic
programming based repair, on these subjects. For the programs
with seeded bugs, our repair method can repair three times as
many buggy versions as compared to genetic programming.
For the Coreutils programs with real bugs, our repair method
took an average of 3.8 minutes while genetic programming
took an average of 6 minutes.
II. O VERVIEW
Given a buggy program Pand a test suite Tcontaining
at least one failing test case, our program repair technique
works as follows. First, we employ statistical fault localization
to generate a list Lof program statements ranked by their
suspiciousness of being the bug. Our core program repair
method then scans through the statement list from the most
suspicious one to the least suspicious one until a successful
repair is generated. For each scanned statement s, our core
program repair method tries to repair the program by altering
statements. Assuming that statement sis the root-cause of the
failure, our core repair method consists of two major steps: i)
we Ô¨Årst generate the repair constraint that has to be satisÔ¨Åed
by a successful repair on sand ii) we try to solve the repair
constraint using program synthesis.
1int is_upward_preferred( int inhibit, int up_sep,
int down_sep) {
2 int bias;
3 if(inhibit)
4 bias = down_sep; //fix: bias=up_sep+100
5 else
6 bias = up_sep;
7 if(bias > down_sep)
8 return 1;
9 else
10 return 0;
11 }
Fig. 1. Code excerpt from Tcas
We illustrate our technique using the sample program in
Fig. 1. It is a code excerpt taken from Tcas , trafÔ¨Åc col-
lision avoidance system [12]. Suppose inhibit has only
two allowable values ( f0,1g). The intended behavior of this
program is described as follows: is_upward_preferred =
(inhibit *100 + up_sep > down_sep) . A test suite for
checking the correctness of the program is presented in Table I.
The testing result shows that the implementation is buggy as
two tests are failed. To repair this program, we Ô¨Årst employTABLE I
ATEST SUITE FOR THE PROGRAM IN FIG. 1
TestInputs Expected ObservedStatusinhibit upsep down sep output output
1 1 0 100 0 0 pass
2 1 11 110 1 0 fail
3 0 100 50 1 1 pass
4 1 -20 60 1 0 fail
5 0 0 10 0 0 pass
TABLE II
TARANTULA FAULT LOCALIZATION RESULT ON THE PROGRAM IN FIG. 1
Line Score Rank
4 0.75 1
10 0.6 2
3 0.5 3
7 0.5 3
6 0 5
8 0 5
Tarantula fault localization [13] for the buggy program using
the given test suite. Tarantula is a statistical fault localization
technique that is explained in details in Section III-A. Basi-
cally, it ranks program statements in a descending order of
their suspiciousness. A statement exercised by more failing
tests and fewer passing tests will have a higher suspiciousness
score. The result of Tarantula shown in Table II is a list of
statements ranked by their suspiciousness score. Since line 4 is
ranked at the top, we start investigating whether the program
can be repaired by changing line 4.
Suppose we want to replace line 4 with bias =f(:::),
wheref(:::)is to be Ô¨Ågured out by our method. There are four
accessible variables at line 4: inhibit ,up_sep ,down_sep
andbias . Since variable bias is not initialized, we assume
that it cannot be used by f(:::). Let us now assume the
signature of function fto be:
int f(int inhibit, int up_sep, int down_sep)
We then Ô¨Ånd the constraint that has to be satisÔ¨Åed by f(:::)
to pass all the test cases in the test suite. This is achieved
through symbolic execution.
For each test exercising line 4, we generate one constraint
onf(:::)whose satisfaction guarantees that the Ô¨Åxed pro-
gram produces the expected output. We use the second test
in Table I to explain how such a constraint is generated.
Fig. 2 presents the symbolic execution tree for test 2, with
input vectorh1;11;110i. Note that our symbolic execution
does not start with program input. Instead, the program is
executed concretely with input h1;11;110iuntil it reaches
line 4. Then the value of variable bias is replaced with a
symbolic value Xand the execution continues symbolically.
On executing the branch at line 7, the execution is faced
with two choices and both paths are executed as shown in
the symbolic execution tree. As we know the expected return
value for inputh1;11;110ishould be 1, only the path through
line 8 should be followed to make the program pass. To
follow this path, the path condition, X > 110, should be
satisÔ¨Åed. Given that the program state at line 4 is finhibit
== 1, up_sep == 11, down_sep == 110 g, we know that
fhas to satisfy f(1;11;110)>110. Similarly, we getinhibit:          1
up_sep:        11down_sep:   110bias:              XPC:               true
inhibit:          1up_sep:        11down_sep:   110bias:              XPC:              X>110return           1 inhibit:          1up_sep:        11down_sep:   110bias:              XPC:              X ‚â§110
return            0
fail pass4
8 10Fig. 2. Symbolic execution tree for test case 2 in Table I when trying to Ô¨Åx
line 4 of the program in Fig. 1. Each box denotes a program state at the line
annotated in the superscript. The program state includes all values of program
variables as well as the path condition PC.
f(1;0;100)100 from test 1 and f(1; 20;60)>60from
test 4. Therefore, the constraint that fneeds to satisfy is
f(1;11;110)>110^f(1;0;100)100^f(1; 20;60)>60.
We employ program synthesis to solve the constraint for fin
order to get a concrete function. Program synthesis requires
basic components (e.g. constants, ‚Äú +‚Äù, ‚Äú ‚Äù) as ingredients to
construct the function f. In our technique, these components
are incrementally provided to program synthesis. In the Ô¨Årst
trial, only a constant is allowed. However, no constant function
can satisfy the above constraint. We then allow function fto
use one ‚Äú +‚Äù, i.e.fcan take either the form of var1+cor
var1+var2, wherevar1andvar2are infinhibit ,up_sep ,
down_sepgandcis an integer constant. The synthesis pro-
cedure can Ô¨Ånd a solution f(inhibit;up sep;downsep) =
upsep+ 100 which is a successful repair to the program in
Fig. 1. Note that if ‚Äú  ‚Äù is used instead of ‚Äú +‚Äù, we will get
f(inhibit;up sep;downsep) =upsep ( 100) as repair.
III. B ACKGROUND
A. Statistical Fault Localization
Statistical fault localization [9], [13] aims to localize the
root-cause of a program failure by exploiting the correlation
between execution of the faulty statements and program fail-
ure. A suspiciousness score is computed for each program
statement based on its frequency of occurrence in passing and
failing executions. Based on the suspiciousness score, a ranked
list of statements is given to users. Users can then examine
the ranked list from the most suspicious statement to the least
suspicious statement until the failure root-cause is found.
In this paper, we adopt the suspiciousness score from
Tarantula technique [13]. For a statement s, its suspiciousness
scoresusp(s)is computed as
susp (s) =failed (s)=totalfailed
passed (s)=totalpassed +failed (s)=totalfailed
wherefailed (s)denotes the number of failing executions in
whichsoccurs andpassed (s)denotes the number of passingexecutions in which soccurs. The variable totalfailed de-
notes the total number of failing executions and totalpassed
denotes the total number of passing executions.
B. Component-based Program Synthesis
We brieÔ¨Çy introduce the recent advance in component-based
program synthesis [11]. Given a set of input-output pairs,
component-based program synthesis generates a program that
satisÔ¨Åes all the given input-output pairs. More speciÔ¨Åcally, if
h;iis one of the input-output pairs, then the synthesized
program must produce output when its input is . In
component based program synthesis, we provide a set of basic
components that the to-be-synthesized function fis allowed
to use. For example, to synthesize a program with linear
expressions,fconstant, minus, plus gare given as the basic
components. A set of location variables are deÔ¨Åned for each
component and the synthesis process is reduced to Ô¨Ånding
values for these location variables. The constraint over the
location variables is in Ô¨Årst-order logic and solved by an SMT
solver. If it has a solution, a unique program can be constructed
based on the values of location variables. We now explain the
encoding method.
Suppose we provide Ncomponentsff1;:::;fNgto syn-
thesize function f. Without losing generality, we assume each
component only has one output. For the ithcomponent, we
denote its input as  !iand its output as ri. We useQto denote
the set of all input variables from all components and Rto
denote the set of output variables from all components.
Q:=[N
i=1  !iR:=[N
i=1frig
We use  !to denote the input variables for function fand
userto denote the output variable of f. The set of location
variables is deÔ¨Åned as
L:=flxjx2Q[R[  ![frgg
A location variable lxdenotes where variable xis deÔ¨Åned.
Given a valuation of L, a program can be constructed using the
following procedure Lval2Prog (L). Here theithline of the
constructed program is rj=fj(r(1);:::;r())whenlrj==
iand^
k=1(lk
j==lr(k)), whereis the number of inputs
for component fjandk
jdenotes the kthinput parameter of
componentfj. The program output is produced in line lr.
We use one example below to explain the meaning of
location variable. Suppose we only provide one component +,
whose inputs are 1
+,2
+. Since there is only one component
+, we use +instead of its component number as the subscript
for clarity. The output variable for +isr+. Suppose there is
only one input for the synthesized program. Let the value of
location variables be flr+== 1;l1
+== 0;l2
+== 0;lr==
1;l1== 0g. Given that lr+== 1 ,r+is deÔ¨Åned in line 1 and
thus component +is placed in line 1. If the location variables
l1
+==l2
+== 0 , then both1
+and2
+are the same as the
variable deÔ¨Åned in line 0, which means that they are the same
as the output of line 0. Since lrequals 1, the value deÔ¨Åned at
line 1, r+, is the output of the program. From the valuation of
the location variables, we can construct the following program0 r 0= input0;
1 r += r 0+ r 0;
2 return r +;
where input0denotes the Ô¨Årst input parameter of the syn-
thesized program.
The location variables have to satisfy certain constraints so
that the corresponding program can pass on all given input-
output pairs. We Ô¨Årst give the well-formedness constraint
 wfp. LetM=j  !j+N, whereNis the number of
components provided to the program synthesis procedure.
 wfp(L;Q;R )def=^
x2Q(0lx<M)^^
x2R(j  !jlx<M)
^ cons(L;R)^ acyc(L;Q;R )
 cons(L;R)def=^
x;y2R;x6y(lx6=ly)
 acyc(L;Q;R )def=N^
i=1^
x2  !i;yrilx<ly
The constraint  cons dictates that there is only one com-
ponent in each line and  acyc encodes that inputs of each
component are deÔ¨Åned before they are used.
The constraint  wfponly guarantees that Lcorresponds to
a well-formed program f. We use the following constraint to
guarantee that the solution fsatisÔ¨Åes all the given input-output
pairs.
func(L;; )def= conn(L;  !;r;Q;R )^lib(Q;R)
^(=  !)^(=r)
lib(Q;R)def=(N^
i=1i(  !i;ri))
 conn(L;  !;r;Q;R )def=^
x;y2Q[R[  ![frg(lx=ly)x=y)
The semantics of each basic component is encoded into lib
withirepresenting the speciÔ¨Åcation of component fiand
the relation between location variables and program variables
is encoded in  conn. Collectively, func(L;i;i)represents
that when executing the synthesized function fwith inputi,
the output should be i.
def=(n^
i=1func(L;i;i))^ wfp(L;Q;R )
Finally, given ninput-output pairs fhi;iij1ing,
the constraint represents that the synthesized function f
should satisfy all input-output pairs and the function has to
be well-formed. Given a solution L0to the constraint , we
can construct a program that satisÔ¨Åes all the I/O pairs hi;ii
using the aforementioned procedure Lval2Prog .
IV. D ETAILED METHODOLOGY
We only generate repairs by altering one statement. The
generated Ô¨Åx is always with respect to a given test suite. If allthe tests in the given test suite pass after the repair is applied,
we consider the repair to be successful. We now elaborate on
the different steps of our method.
A. Generating Repair Constraint
In this paper, we focus on repairs that change the right
hand side of assignments or branch predicates. We do not
generate any repair that require changing the left hand side of
an assignment statement. Albeit simple, we will show how
common programming bugs can be Ô¨Åxed by altering only
branch predicates or the right hand side of assignments.
The repair generated by our method has one of the following
two forms:
x =fbuggy (. . . )!x =f(:::)
if(fbuggy (. . . ))!if(f(:::))
In either case, we generate an expression f(:::)that is used to
replace either the right hand side of an assignment or a branch
predicate. We require the expression f(:::)to be side-effect
free. That is, no program variable is modiÔ¨Åed when f(:::)is
evaluated. In the remainder of this paper, we do not distinguish
between these two cases unless necessary. An expression is
in essence a function. For example, the expression x+y
can be treated as the function f(x;y) =x+y. For ease of
presentation, we use function instead of expression in the rest
of this paper.
DeÔ¨Ånition 1 (Repair Constraint): Given a program P, a
test suiteT, a repair constraint Cof a function fbuggy in
programPis a constraint over function fsuch that iffj=C,
P[f=fbuggy]passes all tests in T.
Given a suspicious statement sthat contains a buggy
functionfbuggy , we now explain how to generate the repair
constraintCsuch that if a function fsatisÔ¨ÅesC, the program
can be repaired by replacing fbuggy withf. As mentioned,
the concept of repair is with respect to the given test suite
T. The repair constraint Cis a conjunction of constraints
that are derived from T. Suppose the test suite has ntests,
T=ftij1ing, which essentially are different input
vectors for running P. The repair constraint is C=Vn
i=1Ci.
For each test ti, we show in the rest of this section how to
generate a constraint Cisuch that if the function fsatisÔ¨Åes
Ci, the program generated by replacing fbuggy withfpasses
for testti.
EachCiis a second order predicate over the function f. To
generateCi, we use symbolic execution in a novel fashion.
Before we elaborate our special symbolic execution, let us
brieÔ¨Çy recap normal symbolic execution [14], [15]. Tradition-
ally, symbolic execution executes a program by considering all
input variables as symbolic. The state of each variable during
symbolic execution is represented as an expression of the
symbolic inputs. When a branch is executed, if both directions
of the branch are feasible, both paths are executed by the
symbolic execution. For each executed path, a path condition
is collected. The path condition of a path is a predicate on
the program inputs, and any input satisfying the path condition
of pathfollows path . The output of the symbolic execution
is a set of feasible paths and the corresponding path conditionsof these paths. For each path, we can also get the symbolic
representation of the program output in terms of the program
input variables.
Different from traditional symbolic execution, our symbolic
execution starts with a concrete input ti. Suppose the program
statement we try to Ô¨Åx is s. Let us assume that sis executed at
most once during one execution for the moment. We execute
the program concretely with inputtito statement s(without
executing statement s). We denote the program state before
executing statement sasi. Then we set the result of function
f(:::)as symbolic and continue symbolic execution from
statements. We useito denote the symbolic value assigned to
the result of function f(:::). Suppose the symbolic execution
exploresmpaths. For each explored path j,1jm, we
denote the associated path condition as pcjand the symbolic
expression of the output as Oj. We useO(ti)to denote the
expected output of program Pwith inputti. The constraint
Ciis
Ci:= (m_
j=1(pcj^Oj==O(ti)))^(f(i) ==i)
The Ô¨Årst part of Ci,Wm
j=1(pcj^Oj==O(ti)), dictates that
there is at least one feasible path (as guaranteed by the satis-
Ô¨Åability of path condition) along which the output of program
Pis the same as the expected output O(ti). The second part
ofCi,(f(i) ==i), builds up the input-output relationship
of function f. With program state ias input, the output of
functionf,i, has to satisfyWm
j=1(pcj^Oj==O(ti)). When
statementsis not exercised during executing program Pwith
inputti,Ciistrue if the execution passes and false if the
execution fails.
We use the same example in Section II to explain the
generation of Ci. Take the second test from Table I for
the program in Fig. 1. The symbolic execution tree for this
test case has been given in Fig. 2. We use Xto denote
the symbolic variable to be consistent with Section II. The
symbolic execution explores two paths: i) path condition is
X > 110and output is 1, and ii) path condition is X110
and output is 0. Given the output of expected output of the test
is 1, the Ô¨Årst part of Ciis then (X > 110^1 = 1)_(X
110^0 = 1) , which can be simpliÔ¨Åed to X > 110. Given
the program state at the Ô¨Åx location is finhibit == 1,
up_sep == 11, down_sep == 110 g, the second part of the
Ciisf(1;11;110) =X. Therefore, the constraint Ciis
f(1;11;110)>110.
After generating the constraint Cifrom each test ti, the full
constraint to be solved is
C:=n^
i=1((m_
j=1(pcj^Oj==O(ti)))^(f(i) ==i))
The solution of Cis a function fwhich can be used to
repair the program so that all the test cases in the test suite T
pass.
Note thatCis a constraint over function f. Current off-
the-shelf SMT solvers cannot directly solve such a formula.
We will explain in Section IV-B how we solve Cindirectlythrough program synthesis. One special case is when function
fis a constant function. In this case, we can replace f(:::)
with a free variable and constraint Cbecomes a Ô¨Årst-order
constraint that can be solved by current SMT solvers.
Repair a statement that is executed multiple times: If the
repaired statement is executed more than once (either inside a
loop or inside a function that is called multiple times) during
the execution of test ti, we usek
ito represent the value
produced by f(:::)in thekthtime it is executed. We use k
ito
represent the program state before the kthtimefis executed
when executing program Pwith inputti. Note that the variable
values ink
icould be symbolic in terms of f1
i;:::;k 1
ig.
Suppose statement sis executed wtimes during symbolic
execution. We have
Ci:= (m_
j=1(pcj^Oj==O(ti)))^(w^
k=1f(k
i) ==k
i)
C:=n^
i=1Ci
Now each symbolic output Ojis an expression in terms of
1
i;:::;w
i. The second part of Cibecomes (Vw
k=1f(k
i) ==
k
i), which means that the input-output relationship of function
fhas to be satisÔ¨Åed each time fis executed. During the kth
timefis executed, with program state k
i, the output of the
functionfisk
i.
InÔ¨Ånite loop in symbolic execution: If the termination
condition of a loop is an expression over our introduced sym-
bolic variables, the symbolic execution may never terminate
exploring inÔ¨Ånite number of loop iterations. Suppose we have
while(i<x)fx=buggy-expression; g. Each time the
buggy statement is executed, we will assign a new symbolic
value to variable x. On checking the loop condition i<x for
the next iteration, both directions are feasible since the new
symbolic value of xis unbounded. Thus, symbolic execution
continues to explore more and more loop iterations and never
terminates. To avoid such inÔ¨Ånite loop exploration, we set a
loop boundBfor all loops in symbolic execution. After a loop
is iteratedBtimes, the symbolic execution stops exploring the
path that leads to the next iteration. Note that this does not
break the validity of repair constraint. If the repair constraint C
has a solution f, for the sub-constraint Ci, one of the constraint
pcj^Oj==O(ti)is satisÔ¨Åed in Ci. It is guaranteed that when
applying the repair f, the repaired program with input tiwill
follow the path jwhose path condition is pcjand generate
the correct output. On the other hand, if the loop bound B
is too small, we may miss repairs that drive the program to
follow paths containing larger number of loop iterations.
B. Generating a Fix
After generating the repair constraint using symbolic exe-
cution, we elaborate how to solve the repair constraint in this
section. Recall that the repair constraint is
C:=n^
i=1((m_
j=1(pcj^Oj==O(ti)))^(w^
k=1f(k
i) ==k
i))To solve the repair constraint C, we leverage the recent
advance in component based program synthesis [11].
We have reviewed the core method of component based
program synthesis in Section III-B. The input-output pairs of
the to-be-synthesized program are encoded into constraints on
a set of location variables L, a valuation of which leads to
a program that satisÔ¨Åes the given input-output pairs. More
speciÔ¨Åcally, the constraint  func(L;; )dictates that the
synthesized program must produce output when given input
. In our repair constraint, we also have input-output pair
hk
i;k
iithat is generated when fis hit at the kthtime in the
execution of program Pwith inputti. However,hk
i;k
iiis
symbolic in terms of fk
ij1kwg, wherewis the number
of timesfis executed with input ti. Moreover, the variables
fk
ij1kwghave to satisfy (Wm
j=1(pcj^Oj==O(ti)))
to make the execution pass, i.e., program output is as expected.
Therefore, the constraint to be satisÔ¨Åed by fduring the
execution of input tiis
idef=9  !i;w^
k=1func(L;k
i;k
i)^(m_
j=1(pcj^Oj==O(ti)))
wherei:=fk
ij1kwg.
Conjoining the constraints from all tests together with
the well-formedness constraint  wfp, we get the following
constraint, a solution to which corresponds to a function f
that is a valid repair.
def=(n^
i=1i)^ wfp(L)
It is worth noting that program synthesis is not the only way
to solve the repair constraint. Given a set of components, an
enumeration on all possible compositions of components could
also be used. For example, given f+, -gas the components,
we could enumerate all possible expressions that can be
constructed using f+, -gand accessible program variables
at the repair location. Through enumeration, we try to Ô¨Ånd
a function that satisÔ¨Åes the repair constraint. As shown by
Gulwani, et. al. [16], program synthesis is more efÔ¨Åcient than
enumeration on all possible compositions of the components.
C. Putting it All Together
Our repair algorithm is presented in Algorithm 1. The
algorithm takes as inputs a buggy program P, a test suite T
and a ranked list of suspicious program statements RC. When
successful, our algorithm produces a repair, applying which on
PmakesPpass all tests in the test suite T.
Our algorithm scans though RCiteratively until a successful
repair can be generated. In each iteration, it Ô¨Årst takes the
most suspicious statement that has not been tried out using
Shift(RC). Shift(RC) returns the Ô¨Årst element from list RC
and removes that element from the list. Ideally, given a repair
candidate and the test suite T, we can directly apply the
technique presented in previous sections to generate a repair.
However, we notice that the test suite could be large and
thus affect the scalability of our technique. We present inAlgorithm 1 a technique to select a subset of the entire test
suite for repair generation. The selection of tests is driven
by testing. We use the set Sto maintain the tests used in
generating the repair constraint. Initially, set Sonly contains
the failing tests in T. After a repair is generated, we test
whether any test that is not in Sfails in the repaired program.
If a testt0fails in the repaired program P0, we addt0into set
Sand re-generate the repair with the augmented set S. Note
that this augmentation process is guaranteed to terminate as the
maximum size of Sis limited by the test suite T. In the worst
case, we may need to add all tests in TintoS. Nevertheless,
as evidenced by our experiments, usually a small number of
test cases is sufÔ¨Åcient compared to the test suite size.
Algorithm 1 Repair algorithm
1:Input:
2:P: The buggy program
3:T: A test suite
4:RC : A ranked list of potential bug root-cause
5:Output:
6:r: A repair for P
7:
8:while RC is not EMPTY and not TIMEOUT do
9: rc= Shift( RC) // A repair candidate
10: S=; // A test suite for repair generation
11: Tf= ExtractFailedTests( T,P);
12: while Tf6=;do
13: S=S[Tf
14: new repair = Repair (P,S,rc)
15: ifnew repair == null then
16: break
17: end if
18: P0= ApplyRepair( P, new repair)
19: Tf= ExtractFailedTests( T,P0);
20: end while
21: ifnew repair not null then
22: return new repair
23: end if
24: end while
25:
26: function Repair (P,S,rc)
27: C= GenerateRepairConstraint( P,S,rc);
28: level = 1 // The complexity of a repair
29: new repair = Synthesize( C,level );
30: while new repair == null and levelMAX LEVEL do
31: level =level + 1
32: new repair = Synthesize( C,level );
33: end while
34: return new repair
35: end function
TheRepair function in Algorithm 1 tries to generate a
repair with a program P, a set of tests Sand a repair candidate
rc. It Ô¨Årst uses symbolic execution to generate the repair
constraint using the method presented in Section IV-A. It
then employs program synthesis to solve the repair constraint.
During program synthesis, we need to provide the set of
components that can be used by the repair. In order to reduce
the complexity of the generated repair as well as increase
the scalability of program synthesis, we categorize common
components according to their complexity level and feed
them incrementally to the program synthesis procedure. The
categorization of basic components is shown in Table III.
The synthesis procedure starts with level 1, which meansTABLE III
THE CATEGORIZATION OF BASIC COMPONENTS
Level Conditional Statement Assign Statement
1 Constants Constants
2 Comparison ( >,,=,6=) Arithmetic ( +; )
3 Logic (^;_) Comparison, Ite
4 Arithmetic ( +; ) Logic
5 Ite, Array Access Array Access
6 Arithmetic () Arithmetic ( )
that only constants are allowed in the constructed repair. If
it fails, more components are provided gradually based on
their complexity level. When at level level , all the components
whose level is less than or equal to level are provided to
program synthesis. This process continues until a repair is
generated or the MAX LEVEL is reached.
V. I MPLEMENTATION
We introduce S EMFIX(Semantic-based Program Fixing)
tool as an implementation of our technique. The architecture
of our tool is presented in Fig. 3. S EMFIXreceives a buggy
program and a test suite as inputs. As the result, it generates
a repair for the buggy program. S EMFIXis the synergy of
fault localization, symbolic execution and program synthesis.
We adapted the Tarantula technique [13] as mentioned in
Section III-A to provide a ranked list of statements according
to their suspiciousness score. KLEE [14] is employed for gen-
erating repair constraints. KLEE is a static symbolic execution
engine which is mainly used for generating high coverage test
suites and Ô¨Ånding bugs. By default, it uses depth-Ô¨Årst-search
to explore all program behaviors w.r.t. predeÔ¨Åned symbolic
variables. In our program repair context, the variable that is
directly affected by a potential defect is treated as a symbolic
variable. To avoid changing and recompiling program‚Äôs source
code whenever a new potential defect is selected, symbolic
variables are instrumented at runtime. At the program location
where a new symbolic variable is introduced, the values of all
accessible variables are also gathered. To generate the repair
constraint, for each explored path, we collect the path condi-
tion as well as the symbolic output. The program synthesis
module is implemented in Perl, and Z3 SMT solver [17] is
used to solve a repair constraint. After a Ô¨Åx is constructed, it
is simpliÔ¨Åed and transformed to make it more readable. For
instance,c== 97 is transformed into c=='a' (cis in char
type), anda+ais transformed into 2a.
We use the following optimization to avoid program syn-
thesis whenever we can. Suppose we try to generate a repair
by modifying statement s. Recall that our repair constraint C
is a conjunction of each basic constraint Ci, where
Ci:= (m_
j=1(pcj^Oj==O(ti)))^(w^
k=1f(k
i) ==k
i)
LetC0
ibe(Wm
j=1(pcj^Oj==O(ti))), which is a Ô¨Årst order
constraint over the symbolic variables fk
ij1kwg, where
wis the number of symbolic variables. We check whether
eachC0
iis satisÔ¨Åable using Z3. If any C0
iis not satisÔ¨Åable,
clearlyCiis unsatisÔ¨Åable and hence the repair constraint C
Repair Buggy    
Program 
Test     
Suite  Tarantula 
KLEE    Statement 
Ranking 
Repair 
Constraint Program 
Synthesis Fig. 3. Architecture of S EMFIXtool.
TABLE IV
SUBJECT PROGRAMS FROM SIR REPOSITORY .
Subject Prog. Size (LOC) #Versions Description
Tcas 135 41 air-trafÔ¨Åc control program
Schedule 304 9 process scheduler
Schedule2 262 9 process scheduler
Replace 518 29 text processor
Grep 9366 2 text search engine
Total 90
is unsatisÔ¨Åable. In that case, we quickly conclude that the
statement is not Ô¨Åxable and avoid program synthesis.
VI. E MPIRICAL EVALUATION
To assess the efÔ¨Åciency and effectiveness of our technique,
we employed S EMFIXtool to repair seeded defects as well as
real defects in an open source software. We also compared our
method with genetic programming based repair techniques. All
the experiments were conducted on a Core 2 Quad 2.83GHz
CPU, 3GB memory computer with Ubuntu 10.04 OS.
A. Experience with SIR Programs
Subject programs used in this experiment (see Table IV) are
from Software-artifact Infrastructure Repository (SIR) [12].
They represent different kind of applications ranging from a
air-trafÔ¨Åc control system (Tcas), scheduling utilities (Schedule,
Schedule2) to strings and Ô¨Åles manipulation programs (Re-
place, Grep). Each subject program comes with a test suite
and has multiple buggy versions as shown in ‚Äú#Versions‚Äù
column. Each buggy version has one or many seeded defects
that represent common programming errors. Program versions
that pass all tests are excluded as there is no witness of failure.
Each SIR program has thousands of tests. Normally, a program
of similar size to SIR programs does not have this enormous
number of tests. Hence, a given test suite is minimized to a
set of 50 tests that achieves a maximum (line) coverage.
For S EMFIX, the maximum level ( MAX LEVEL ) is set to 3.
This level is chosen to keep search space within a reasonable
size. Higher levels are only allowed when buggy locations are
provided by users. In trying to Ô¨Åx each buggy program, we set
the time bound for S EMFIXto 4 minutes. All subject programs
but Tcas use only local variables to construct a repair. Global
variables are used to construct a repair in Tcas because they
appear in most of Tcas computations. The result of S EMFIX
on SIR programs are presented in Table V. The time taken for
SEMFIXis shown in Fig. 4. The numbers under GP (GenProg)
are explained later in Section VI-C.
We have experimented with different test suite sizes. The
success rate decreases with more number of tests. Intuitively, it
is more difÔ¨Åcult to generate a repair to pass more tests. It alsoTABLE V
COMPARING THE SUCCESS RATE BETWEEN SEMFIX(SF) AND GENPROG
(GP). X IN[X] ON THE TOP OF EACH COLUMN DENOTES THE NUMBER OF
TESTS .
Program[10]
SF/GP[20]
SF/GP[30]
SF/GP[40]
SF/GP[50]
SF/GP
Tcas 38 / 24 38 / 19 35 / 16 34 / 12 34 / 11
Schedule 5 / 1 3 / 1 4 / 1 4 / 0 4 / 0
Schedule2 4 / 4 3 / 2 4 / 2 3 / 3 2 / 1
Replace 7 / 6 7 / 5 8 / 5 7 / 6 6 / 4
Grep 2 / 0 1 / 0 1 / 0 2 / 0 2 / 0
Total 56 / 35 52 / 27 52 / 24 50 / 21 48 / 16
 050100150200250
SemFix
GenProg
Tcas  Schedule  Schedule2  Replace  Grep  Time (s)  
#Test cases  
Fig. 4. Comparing the running time between S EMFIXand GenProg.
shows that the repairs generated with small number of tests
may not be valid for some other tests that are not in the test
suite. We note that this weakness is inherent in any test suite
based program repair, since no formal program speciÔ¨Åcation
is given and repairs can only be generated with respect to
limited number of given tests. Out of the 90 buggy programs,
with a test suite size of 50 ‚Äî S EMFIXrepaired 48 buggy
programs while genetic programming repaired only 16. The
average time required by S EMFIXfor each repair is less than
100 seconds.
Repairs generated by SEMFIX:SEMFIXwas able to
correct various types of bugs. Table VI shows the number
of successful cases for each type of bug. The number of total
bugs of a particular type is speciÔ¨Åed in the second row of
Table VI. Const refers to bugs that use the wrong constant.
Arith refers to using wrong arithmetic expression, and comp
refers to using the wrong comparison operators. Logic refers
to using wrong logic operators. Programs with code missing
bugs lack some statements, and programs with redundant code
contain some statements that are not supposed to exist.
Repairs that SEMFIXcould not generate: We have
manually looked into the cases where S EMFIXfailed to repair
the buggy programs. Out of the 90 buggy program versions,
SEMFIXfailed in 42 of them. The reasons include i) the
repairs require a larger loop bound than the bound used in
our experiment (8 versions) ii) the repairs require precise
modeling of array, which is not fully supported by our current
implementation (6 versions) iii) the repairs require symbolic
execution with Ô¨Çoating-point variables, which is not supported
by KLEE (5 versions) iv) the repairs (15 versions) require
more than one line Ô¨Åx, 11 of them are from code-missingTABLE VI
SEMFIX(SF) VS. GENPROG (GP) IN REPAIRING DIFFERENT CLASS OF
BUGS WITH 50TESTS .
Bug type Const Arith Comp LogicCode RedundantAllMissing Code
Total 14 14 16 10 27 9 90
SemFix 10 6 12 10 5 5 48
GenProg 3 0 5 3 3 2 16
TABLE VII
COREUTILS SUBJECT PROGRAMS
Subject Prog. Failure Description LOC
mknod Segmentation fault. 183
mkdir Segmentation fault. 159
mkÔ¨Åfo Segmentation fault. 107
cp Failed to copy a Ô¨Åle (a ‚Äúnamed pipe‚Äù). 2272
bugs. v) other reasons that we failed to identify (8 versions).
B. Experience with Coreutils
In this section, we present our experience in repairing
GNU core utilities ‚Äî Coreutils. In total, we were able to
locate 9 buggy programs among the ones reported in earlier
research [14]. Tests available in Coreutils 6.11 are utilized to
encode the desired functionality of each utility. S EMFIXwas
able to repair 4 out of these 9 buggy programs. Table VII
shows the 4 bugs that S EMFIXwas able to repair. Three
utilities mkdir, mknod and mkÔ¨Åfo have similar defects. In each
utility, a null pointer access caused by wrong variable usage
makes the program crash. S EMFIXfound one variable as a
replacement that let the program produce expected output.
For cp, the condition guarding a Ô¨Åle deleting operation is
wrong. Because of the bug, the Ô¨Åle deleting operation was not
executed when it should be in the failing test. The status of the
Ô¨Åle is checked later. S EMFIXsuggested the function checking
the Ô¨Åle status to return true indicating that the Ô¨Åle is already
deleted. For the remaining 5 buggy programs, S EMFIXcould
not Ô¨Ånd any 1-statement transformation to repair the buggy
programs.
C. Comparison with GenProg on SIR and Coreutils
GenProg [6] is a genetic programming based repair tool.
It uses mutation (i.e. delete ,insert ,replace ) and crossover
operators to search for a program variant that passes all tests.
By applying these stochastic search operators, GenProg has
been successful in repairing a variety of applications.
We compare the success rate (Table V) and running time
(Fig. 4) of GenProg and S EMFIX. The test suites used for
running GenProg are the same as the ones used in Sec-
tion VI-A. We take the implementation of GenProg from
http://dijkstra.cs.virginia.edu/genprog/. The conÔ¨Åguration used
to run GenProg is taken from [6] (i.e. PopSize = 40 and a
maximum of 10 generations). The time bound for each repair
trial of GenProg is set the same as that of S EMFIX, which is
4 minutes.
As shown in Table V, S EMFIXoutperforms GenProg in
all subject programs but Schedule2. Most of the bugs in
Schedule2 are code missing bugs. Our tool could not Ô¨Ånd any
1-statement transformation to repair these bugs. With regard
to running times, S EMFIXis strictly faster than GenProg (seeFigure 4). Since GenProg suffers from the burden of compiling
and testing program variants, it takes longer for GenProg to
Ô¨Ånd a repair when the size of test suite increases.
We also compare the results of S EMFIXand GenProg on
different classes of bugs (Table VI). S EMFIXhas a higher
success rate than GenProg for each type of bugs. For code
missing bugs, neither S EMFIXnor GenProg has a high success
rate. We also notice that GenProg failed for all arithmetic
bugs. This conÔ¨Årms that if the repair expression does not exist
in other places of the program, genetic programming based
approaches have rather low chance of synthesizing the repair.
We also employed GenProg to repair the bugs in Coreutils.
Out of the 9 buggy programs, GenProg repaired the same
number (4) of bugs as S EMFIX. Regarding the running time,
GenProg took an average of 6 minutes while S EMX FIXtook
an average of only 3.8 minutes.
D. Comparison with Expression Enumeration
Our approach employs program synthesis to solve the repair
constraint in order to Ô¨Ånd a successful repair. Program synthe-
sis essentially searches among the set of possible expressions
that can be constructed using the provided basic components
and program variables. We conducted the following experi-
ments to examine whether program synthesis is more favorable
than explicit enumerating possible expressions.
The enumeration based program repair that we compare
with proceeds as follows: i) It uses statistical debugging to
generate a ranked list of repair candidates. ii) It scans through
the result of statistical debugging. For each scanned repair
candidate, it enumerates all possible expressions that can be
constructed based on a given set of components and program
variables. Thus, given variables fx;y;zgand operator +, it
tries outfx+y;x+z;y+z;x+x;y+y;z+zgto see if
any of them is a successful repair. The enumeration terminates
until a successful repair is generated, which is conÔ¨Årmed by
running all tests on the repaired program. We use the same set
of components and variables as in our program synthesis step.
Following the layers in Table III, we enumerate from simple
expressions to more complex expressions. We have also tried
to avoid redundant enumeration. Only one of x+yandy+x
is tried out, and expressions like x xare not tried out at all.
One of the problem with enumeration is the handling of con-
stants in expressions. Enumeration based method is unlikely
to Ô¨Ågure out the desired value of constant unless it falls within
the commonly used ones, e.g. f-1, 0, 1g. Therefore, we use
symbolic execution to Ô¨Ågure out the value of constant when an
enumerated expression contains unknown constant variables.
Suppose we want to see whether any expression of the form
x+con could be a valid repair, where x is a program variable
andcon is some unknown constant. We Ô¨Årst replace the repair
candidate with x+con and then mark con as symbolic and
use the method in Section IV-A to generate a constraint over
the symbolic value of con, solving which gives us a concrete
value of con.
We use the same set of SIR programs as in Table IV
in this comparison. For each buggy program version, theTABLE VIII
AVERAGE RATIO OF RUNNING TIME OVER ALL VERSIONS OF A SUBJECT
PROGRAM (TIME TAKEN BY ENUMERATION BASED REPAIR VS .TIME
TAKEN BY SEMFIX).
Subject Tcas Schedule Schedule2 Replace Grep All
Ratio 6.9 2.8 2.5 1.36 2.2 4.16
same set of 50 tests are used as in Section VI-A. The
enumeration based program repair was successful for 45
out of 90 program versions, and all these 45 versions are
contained in the 48 versions that S EMFIXwas able to
repair. For each of the 3 cases that S EMFIXsucceeded but
enumeration method failed, enumeration had to examine
more than 9000 expressions and timed out after 20 minutes.
In contrast, synthesis based repair took only 94 seconds
on average for these 3 cases to produce a repair. As an
example, in one version of TCAS, S EMFIXgenerated
tmp = ((Other_Capability<Alt_Layer_Value)?
Two_of_Three_Reports_Valid:Cur_Vertical_Sep);
as a replacement for tmp = Up_Separation . This is a
non-trivial Ô¨Åx generated which the program synthesis allows
SemFix to generate, and this could not be generated by
the enumeration method even when it was augmented with
symbolic execution to solve for constants.
Table VIII compares the running time of S EMFIXand
enumeration based repair. On average, the time taken for
the enumeration method is 4.16 times of the time taken by
SEMFIX.
VII. T HREATS TO VALIDITY
a) Generalization of the Ô¨Åx: The repair generated by
SEMFIXmay not be generalized to test cases that are not in
the given test suite. This is inherently due to the fact that our
repair is guided by a given test suite, not a formal speciÔ¨Åcation.
To minimize the effort required from users, we choose to
extract intended program semantics from a given test suite
via symbolic execution.
b) Other statistical debugging metrics: The choice of
statistical debugging metrics could potentially affect the effec-
tiveness of our technique. On this front, we have also tested
SEMFIXwith another popular statistical debugging metric ‚Äì
Ochiai [18]. We found that using Ochiai instead of Tarantula
has negligible impact on our experiment results. For example,
using Ochiai instead of Tarantula, S EMFIXwas able to Ô¨Åx two
more versions of Tcas but one less version of Schedule.
VIII. R ELATED WORK
Recently, there has been a growing interest in automated
program repair. We have compared our technique with genetic
programming [2], [6]. Several program repair approaches
assume the existence of program speciÔ¨Åcation. AutoFix-E [1]
and AutoFix-E2 [19] are based on the program contracts
in Eiffel programs. Fixes are generated following predeÔ¨Åned
schema so that the Ô¨Åxed programs satisfy the corresponding
program contracts. Jobstmann, et. al. [20] uses LTL speciÔ¨Åca-
tions for Ô¨Ånite state programs. The process of Ô¨Ånding a repair
is reduced to a game, a winning strategy of which correspondsto a successful repair. Gopinath, et. al. [3] use behavioral spec-
iÔ¨Åcations and encode the speciÔ¨Åcation constraint on the buggy
program into SAT constraint, a solution of which leads to a
repair. Fixes are only generated by replacing variables used in
assignments. Robert and Roderick [21] employ template based
repair for linear expressions. Template parameters are Ô¨Ågured
out through symbolic execution. In contrast to symbolic exe-
cution in our approach, their symbolic execution considers all
program inputs and template parameters as symbolic. He and
Gupta [22] compute weakest pre-condition along an execution
trace to infer the desired program state. A repair is generated
based on the difference between the actual program state
during the failing execution and the desired program state.
Dallmeier, et. al. [23] try to generate Ô¨Åxes from object
behavior anomalies. Normal program properties are mined
from successful executions and Ô¨Åxes are generated so that
previous failing executions can also satisfy the mined prop-
erties. ClearView [24] follows a similar scheme but works on
deployed binary program when high availability is required.
Learning from history repair data, BugFix [25] suggests bug-
Ô¨Åx that has been used in a similar debugging situation. The de-
bugging situation captures both static and dynamic information
to increase accuracy. Debroy and Wong [26] propose to use
mutation for program repair. A number of mutated program
versions are generated and tested in a trial-and-error fashion.
PHPRepair [27] focuses on HTML generation errors in PHP
programs. Constraints on string literals are collected from test
executions and solved through string solver. The derived string
literals from string constraint solving are then used to repair
the PHP programs.
Instead of Ô¨Åxing a buggy program, program sketching [7],
[8] allows a programmer to write a sketch of the implemen-
tation idea while leaving the low level details omitted as
holes to be automatically Ô¨Ålled up by the sketch compiler.
The programmer is also required to provide the program
speciÔ¨Åcation in the form of a reference program. In contrast,
SEMFIXrequires neither the sketch nor the program speciÔ¨Å-
cation. Instead, S EMFIXtries to synthesize a glimpse of the
intended program speciÔ¨Åcation through symbolic execution of
the given test suite.
Our usage of symbolic execution is similar to that of angelic
debugging [10]. For each expression in a buggy program,
angelic debugging uses symbolic execution to check whether
it is possible to modify the expression to Ô¨Åx the failing tests
without breaking any passing tests.
IX. CONCLUSION
We propose S EMFIXas a semantics based program repair
tool. S EMFIXderives repair constraint from a set of tests and
solves the repair constraint to generate a valid repair. S EMFIX
is able to synthesize a repair even if the repair code does
not exist anywhere in the program. Our experimental resultsdemonstrate that S EMFIXis able to Ô¨Åx various types of bugs
and outperforms search based program repair technique.
ACKNOWLEDGMENTS
This work was partially supported by Singapore Ministry
of Education grant MOE2010-T2-2-073.
REFERENCES
[1] Y . Wei, Y . Pei, C. A. Furia, L. S. Silva, S. Buchholz, B. Meyer, and
A. Zeller, ‚ÄúAutomated Ô¨Åxing of programs with contracts,‚Äù in ISSTA ,
2010.
[2] W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest, ‚ÄúAutomatically
Ô¨Ånding patches using genetic programming,‚Äù in ICSE , 2009.
[3] D. Gopinath, M. Malik, and S. Khurshid, ‚ÄúSpeciÔ¨Åcation-based program
repair using SAT,‚Äù in TACAS , 2011.
[4] B. Demsky and M. Rinard, ‚ÄúAutomatic detection and repair of errors in
data structures,‚Äù in OOPSLA , 2003.
[5] B. Demsky, M. D. Ernst, P. J. Guo, S. McCamant, J. H. Perkins, and
M. Rinard, ‚ÄúInference and enforcement of data structure consistency
speciÔ¨Åcations,‚Äù in ISSTA , 2006.
[6] C. Le Goues, M. Dewey-V ogt, S. Forrest, and W. Weimer, ‚ÄúA systematic
study of automated program repair: Fixing 55 out of 105 bugs for $8
each,‚Äù in ICSE , 2012.
[7] A. Solar-Lezama, R. Rabbah, R. Bod ¬¥ƒ±k, and K. Ebcio Àòglu, ‚ÄúProgramming
by sketching for bit-streaming programs,‚Äù in PLDI , 2005.
[8] A. Solar-Lezama, L. Tancau, R. Bodik, S. Seshia, and V . Saraswat,
‚ÄúCombinatorial sketching for Ô¨Ånite programs,‚Äù in ASPLOS , 2006.
[9] B. Liblit, A. Aiken, A. X. Zheng, and M. I. Jordan, ‚ÄúBug isolation via
remote program sampling,‚Äù in PLDI , 2003.
[10] S. Chandra, E. Torlak, S. Barman, and R. Bodik, ‚ÄúAngelic debugging,‚Äù
inICSE , 2011.
[11] S. Jha, S. Gulwani, S. Seshia, and A. Tiwari, ‚ÄúOracle-guided component-
based program synthesis,‚Äù in ICSE , 2010.
[12] H. Do, S. Elbaum, and G. Rothermel, ‚ÄúSupporting controlled experi-
mentation with testing techniques: An infrastructure and its potential
impact,‚Äù Empirical Software Engineering , vol. 10, 2005.
[13] J. A. Jones, M. J. Harrold, and J. Stasko, ‚ÄúVisualization of test infor-
mation to assist fault localization,‚Äù in ICSE , 2002.
[14] C. Cadar, D. Dunbar, and D. Engler, ‚ÄúKLEE: unassisted and automatic
generation of high-coverage tests for complex systems programs,‚Äù in
OSDI , 2008.
[15] S. Anand, C. P ÀòasÀòareanu, and W. Visser, ‚ÄúJPF‚ÄìSE: A symbolic execution
extension to java pathÔ¨Ånder,‚Äù in TACAS , 2007.
[16] S. Gulwani, S. Jha, A. Tiwari, and R. Venkatesan, ‚ÄúSynthesis of loop-
free programs,‚Äù in PLDI , 2011.
[17] L. de Moura and N. Bj√∏rner, ‚ÄúZ3: An efÔ¨Åcient SMT solver,‚Äù in TACAS ,
2008.
[18] R. Abreu, P. Zoeteweij, and A. J. C. van Gemund, ‚ÄúAn evaluation of
similarity coefÔ¨Åcients for software fault localization,‚Äù in PRDC , 2006.
[19] Y . Pei, Y . Wei, C. A. Furia, M. Nordio, and B. Meyer, ‚ÄúCode-based
automated program Ô¨Åxing,‚Äù in ASE, 2011.
[20] B. Jobstmann, A. Griesmayer, and R. Bloem, ‚ÄúProgram repair as a
game,‚Äù in CAV, 2005.
[21] R. K ¬®onighofer and R. Bloem, ‚ÄúAutomated error localization and correc-
tion for imperative programs,‚Äù in FMCAD , 2011.
[22] H. He and N. Gupta, ‚ÄúAutomated debugging using path-based weakest
preconditions,‚Äù in FASE , 2004.
[23] V . Dallmeier, A. Zeller, and B. Meyer, ‚ÄúGenerating Ô¨Åxes from object
behavior anomalies,‚Äù in ASE, 2009.
[24] J. H. Perkins et al. , ‚ÄúAutomatically patching errors in deployed soft-
ware,‚Äù in SOSP , 2009.
[25] D. Jeffrey, M. Feng, N. Gupta, and R. Gupta, ‚ÄúBugÔ¨Åx: A learning-based
tool to assist developers in Ô¨Åxing bugs,‚Äù in ICPC , 2009.
[26] V . Debroy and W. E. Wong, ‚ÄúUsing mutation to automatically suggest
Ô¨Åxes for faulty programs,‚Äù in ICST , 2010.
[27] H. Samimi, M. Sch ¬®afer, S. Artzi, T. Millstein, F. Tip, and L. Hendren,
‚ÄúAutomated repair of HTML generation errors in PHP applications using
string constraint solving,‚Äù in ICSE , 2012.