Finding Architectural Flaws using Constraints 
Radu Vanciu Marwan Abi-Antoun 
Department of Computer Science, Wayne State University, De troit, Michigan, USA 
Email:{radu, mabiantoun }@wayne.edu 
Abstract—During Architectural Risk Analysis (ARA), secu- 
rity architects use a runtime architecture to look for secur ity 
vulnerabilities that are architectural ﬂaws rather than co ding 
defects. The current ARA process, however, is mostly inform al
and manual. In this paper, we propose Scoria, a semi-automat ed 
approach for ﬁnding architectural ﬂaws. Scoria uses a sound ,
hierarchical object graph with abstract objects and dataﬂo w
edges,whereedgescanrefertonodesinthegraph.Thearchit ects 
canaugmenttheobjectgraphwithsecurityproperties,whic hcan 
express security information unavailable in code. Scoria a llows 
architectstowrite queriesonthegraphinterms ofthehiera rchy,
reachability, and provenance of a dataﬂow object. Based on t he 
query results, the architects enhance their knowledge of th e
system security and write expressive constraints. The expr essive- 
ness is richer than previous approaches that check only for t he 
presenceor absence of communicationor donottrack adataﬂo w
as an object. To evaluate Scoria, we apply these constraints to 
several extended examples adapted from the CERT standard 
for Java to conﬁrm that Scoria can detect injected architect ural
ﬂaws. Next, we write constraints to enforce an Android secur ity 
policyandﬁndonearchitecturalﬂawinoneAndroidapplicat ion.
I. I NTRODUCTION 
Although 50% of security vulnerabilities are architectura l
ﬂaws such as information disclosure [1], they receive less 
attention from security analyses that focus on coding defec ts 
such as a hard-coded password [2]. In object-oriented code, a
localcodingdefectcanbefoundbyanalyzingoneclassorone
methodatatime.Ontheotherhand,architecturalﬂawsrequi re 
reasoning about non-local information such as the context o f
architectural components.
A security analysis focused on architectural ﬂaws is Ar- 
chitectural Risk Analysis (ARA) also known as threat mod- 
eling [3]. During ARA, architects use a runtime architectur e,
which is a collection of runtime components and connectors.
The current ARA process is informal and manual. One way 
to automateARA is to executemachine-checkable constraints 
against the runtime architecture. For example, a constrain t
checks all connectors and restricts communication of com- 
ponents created in a given context. In addition, constraint s
may use security properties such as TrustLevel that architects 
assign to component and connector instances [4], [5].
In this paper, we target architectural ﬂaws such as informa-
tiondisclosureandtampering,whichmayoccurforconnecto rs 
between trusted and untrusted components. Simply checking
forthepresenceofcommunicationisinsufﬁcientandmaylea d
to false positives. Instead, architects need to reason abou t the 
content of a connector. For example, a connector that passes
conﬁdential information from a trusted source to an untrust ed destination may lead to information disclosure. On the othe r
hand,an untrustedconnectorthat hasa trusted destination and 
passes unsanitized information may lead to tampering [3].
In previous work [6], [7], we approximated a runtime 
architecture by using a static analysis to semi-automatica lly 
extract from object-oriented code with annotations a sound ,
hierarchical Ownership Object Graph (OOG) with dataﬂow 
communication edges such that the OOG approximates all
possible runtime objects and communication. A component
is represented by an abstract object and the objects in its 
substructure. A connector is represented by edges between 
abstract objects.
Inthispaper,weproposeScoria,asemi-automaticapproach
for ﬁnding architectural ﬂaws during ARA. Scoria uses a 
security graph (SecGraph) that augments the OOG with se- 
curity properties, queries, and constraints. The queries a llow 
architectsto deepentheir understandingofan abstractrun time 
architectureasneeded,andtoassignsecuritypropertiest osets 
of abstract objects and edges. The architects can then enfor ce 
a security policy as a set of constraints that are predicates on 
the sets returned by the queries.
The contributions of Scoria are queries that capture the 
thought process of how architects reason about the commu- 
nication of objects in a runtime architecture. For security ,
it is important to identify the objects that edges refer to.
Some objects that carry protected data may be part of some 
other object that seems to carry only unprotected data. In th e
SecGraph, a dataﬂow edge refers to an abstract object. This i s
similar to how a manually drawn runtime architecture used in
ARAhasmessagesratherthantypesoractionsonthedirected
edges between component instances [8]. Scoria automatical ly 
tracksthecontentofthedataﬂowthrough objecthierarchy and 
object reachability . Then, architects can write constraints by 
reasoning about the source, the destination, and the ﬂow in 
terms of abstract objects. For example, in a communication 
from a trusted source to an untrusted destination, the dataﬂ ow 
object may not be conﬁdential, but a conﬁdentialobject coul d
be reachable from it or be contained within its substructure .
Architects can also reason about object provenance when 
differentdataﬂowedgesrefertothesameobject.Objectpro ve- 
nance uses only the structure of the SecGraph. In some cases,
to supplement the information from the runtime architectur e,
architects use security properties to supply security-rel evant
design intent that is not directly available in the code or in an 
abstract object graph that is automatically extracted.
The queries also compute the indirect communication 
through object hierarchy and object reachability of the sou rce 978-1-4799-0215-6/13/$31.00 c2013 IEEE ASE 2013, Palo Alto, USA334
anddestination.Architectsmaymisssuchcommunicationth at
isnotexplicitintheSecGraphandleadstoarchitecturalﬂa ws.
To evaluate Scoria, we write machine-checkableconstraint s
for several rules in the CERT Oracle Secure Coding Standard 
for Java [9] focusing on architectural ﬂaws for which auto- 
mated detection was previously unavailable. Our evaluatio n
conﬁrms that Scoria can detect architectural ﬂaws in severa l
extended examples. As a second evaluation, we formalize 
an Android security policy as a constraint and detect one 
architectural ﬂaw in one Android application.
Contributions. Our contributions are:
•The Scoria approach of machine-checkable constraints 
on a security graph where dataﬂow edges refer to ab- 
stract objects. The constraints automatically track objec t
provenance and indirect communication through object
hierarchy and object reachability.
•An evaluation that the constraints ﬁnd architecturalﬂaws 
such as information disclosure and tampering in several
extended examples adapted from the CERT standard for 
Java and in one Android application.
Outline.Section II identiﬁes the requirements of ARA and 
describes the OOGs using a running example. Section III de- 
scribes Scoria and deﬁnes the SecGraph . Section IV describes 
the evaluation and discusses the results. Section V describ es 
related work, and Section VI concludes.
II. B ACKGROUND 
A. Running example 
We use Echo, a client-server application that highlights 
a potential information disclosure if the communication be -
tween the server and the client is not encrypted. To under- 
stand the communication, the architects need to distinguis h
between different objects of the same class InputStream .
Echo is adapted from code fragments provided as examples 
in the CERT standard [9]. Echo consists of two objects,
client:EchoClient and server:EchoServer thatcommu- 
nicate via a message ss:String received from user input.
The communicationis established via a sckt:Socket object,
whichcontainstwostreamsofdata,namely, in:InputStream 
and out:OutputStream . The object sckt:Socket does not
provide encryption and should be used only if the data trans-
mitted is not conﬁdential or if the network is trusted. Other -
wise,theimplementationshoulduseencryptionprotocolss uch 
asSecureSocketsLayer(SSL)toensurethatthechannelisno t
vulnerable. The server supports both types of communicatio n
and has an object sslSckt:SSLSocket that encrypts data.
However, to avoid the performance overhead associated with
encryption, client:EchoClient uses sckt:Socket to com- 
municate to server:EchoServer . To implement encryption 
in Java, developers should use the class SSLSocket instead 
of Socket as advised by the CERT rule [9, MSC00-J]. Oth- 
erwise, conﬁdential messages may be disclosed to malicious
applicationsthatinterceptmessagesfrom sckt:Socket .Such 
a vulnerability is an architectural ﬂaw—not a coding defect —
and according to the CERT standard, automated detection is 
unavailable.B. Requirements on an ARA Solution 
During ARA, architects use a runtime architecture rather 
than a code architecture. For object-oriented code, a runti me 
architecture shows objects as opposed to a code architectur e
that shows the code structure as packages and classes [1]. A 
runtime architecture can have multiple component instance s
of the same type that serve different conceptual purposes 
or have different security properties. For example, an obje ct
in:InputStream of standard inputserves a differentconcep- 
tual purpose from in:InputStream of a network, and the 
architecture shows them as two distinct components.
One limitation of the current ARA process is obtaining an 
initial runtime architecture that is consistent with the co de.
When developers manually document an architecture, they 
maymiss some importantcomponentsor connectorsthatexist
at runtime in some program run. Since ARA is a worst-case 
analysis, it requires a sound architecture that represents all
componentsand connectorsthat may exist at runtime because
every component or connector can introduce vulnerabilitie s.
For Echo, if server:EchoServer sends messages directly 
to out:OutputStream , the architecture should have such a 
connector even if it only occurs when an exception is thrown.
In a sound runtime architecture, one component abstracts 
multiple runtime objects used in the same context, i.e., eac h
runtime object is mapped to one component. Also, a sound 
runtime architecture does not map one runtime object to 
distinct components since architects could assign differe nt
property values to these architectural components and obta in 
misleadinganalysisresults,wheninfactthese components are 
the same runtime entity.
Legacy code has high business value, and vulnerabilities in
legacy code are expensive [10]. As a result, Scoria supports
legacy code, requiring only annotations. In particular, it does 
not require the program to be implemented using speciﬁc 
programming languages [11] or libraries [12], or to require
automated code generation as in SecureUML [13].
C. Extracting an Abstract Runtime Architecture 
Scoria builds on a recent body of work that uses static 
analysis to extract an OOG with points-to edges [6] and 
dataﬂowedges[7].InanOOG,anodeisanabstractobjectthat
represents a possibly unbounded number of runtime objects.
The OOG is sound such that each runtime object has exactly 
one abstract object as a representative. Soundness also mea ns 
that every runtime edge has a corresponding abstract edge 
between the representatives of the source and the destinati on 
runtime objects. For brevity, we use object to refer to an 
abstract object.
TheOOGisalsohierarchical.Anobjectdoesnothavechild 
object directly. Instead, an object contains domains, wher e a 
domain is a named conceptual group of objects where the 
name conveys design intent.
Notation. An object labeled obj:T indicates a reference obj 
of type T, which we then refer to as the “object obj ” to mean 
“an instance of the Tclass”. A dataﬂow communication has 335the labelobj:T to reﬂect that the same object obj:T (which 
could be a node in the graph) is ﬂowing along the edge.
The OOG supports object identity where each abstract
object has a unique identiﬁer. In Echo, the architects can 
assign differentpropertyvaluesto wrtr:OutputStream from 
the STREAMS parent domain of the sckt:Socket and to 
wrtr:OutputStream fromthe STREAMS parentdomainofthe 
sslSckt:SSLSocket (not shown) although both objects are 
of the same OutputStream class.
The architects can reason about object provenance because 
a dataﬂow edge refers to an object instead of a type. For ex- 
ample,thearchitectscanuseobjectidentitytoﬁndthatsev eral
dataﬂow edges refer to the same object such as ss:String 
in the DATA domain of m:Main . However, only some of 
these dataﬂow edges may lead to information disclosure. The
architectscantracktheinitialsourceofa dataﬂowtransit ively.
The dataﬂow might be allowed as long as the TrustLevel
value of the destination is Trusted . For example, a transi- 
tive communication of ss:String from in:InputStream to 
wrtr:OutputStream exists. The architects can reason that
the object ss is conﬁdential because the object in represents 
userinput.Hence,a dataﬂowedgethatrefersto ss andhasan 
untrusted destination may lead to information disclosure a nd 
should be investigated.
Sinceahierarchicalorganizationofobjectsisunavailabl ein 
plain Java code, the static analysis requires annotations t o be 
addedtotheprogram.Anothertoolchecksthattheannotatio ns 
are consistent with the code and with each other and convey 
designintent[6].Usingannotations,anobjectcanbepushe din 
a domainunderneathanotherobjectthathas multiple domain s
in its substructure. Therefore, an OOG allows the architect s
to reason about the content of an abstract object that has 
a substructure. For Echo, the destination of a dataﬂow is 
wrtr:OutputStream in the substructure of sckt:Socket .
The architects can reason that the wrtr object represents un- 
encrypted data because Socket does not provide encryption,
as opposed to the descendants of sslSckt:SSLSocket that
may use encryption.
AnOOGtracksobjectreachabilitythroughdataﬂow,points-
to and creation edges. In Echo, the architectsuse the points -to 
edgefrom out:PrintWriter to wrtr:OutputStream torea- 
sonthatadescendantof client:EchoClient hasapersistent
referencetoadescendantobjectof sckt:Socket .Iftheobject
client were to pass out:PrintWriter as a dataﬂowobject,
it would also provideaccess to a descendantof sckt:Socket 
because the descendant object wrtr is reachable from out .
The OOG and the code are consistent and every node and 
edge of the OOG has traceability information. If the set of 
edges returned by a query satisﬁes a constraint, the archite cts 
can trace directly to the corresponding lines of code that ma y
introduce an architectural ﬂaw. The result of a query is thus
directly actionable. This is in contrast to a manually drawn
architecture that does not have traceability to code where t he 
architects must spend additional effort reading the code an d
investigating each potential architectural ﬂaw they ﬁnd.III. T HE SCORIA APPROACH 
Scoriaisa semi-automatedapproachin whichthe architects
supported by existing tools ﬁnd architecturalﬂaws as follo ws.
First, the architects add annotations to code and typecheck
them, ﬁxing any of the typechecker warnings in the process.
Second, the architects use a static analysis that automatic ally 
extracts a SecGraph from the code with annotations. Third,
as an optional step, the architects assign security propert iesto 
objects and edges as needed using queries on the SecGraph .
Fourth,the architects write and executeconstraints on the sets 
returned by queries on the SecGraph . Finally, the architects 
trace to code from suspicious edges that constraints highli ght
and inspect potential architectural ﬂaws. The process is in cre- 
mentalsuchthatthearchitectscanbeginbyassigningprope rty 
values to only a few of the objects, while by default the rest
have the Unknown value. In the following, we deﬁne several
concepts informally introduced in the previous sections.
A. Deﬁnitions 
Dataﬂow communication means that an object a:A has a 
reference to an object o:O and passes it to an object b:B , or 
an object a:A has a reference to an object b:B and receives 
a reference to an object o:O [14]. The objects a:A and 
b:B represent the source or destination objects, and o:O is a 
dataﬂow object that the dataﬂow communication refers to. To
emphasize that a dataﬂow edge refers to an object, not a type,
we use a thin dashed edge from a dataﬂow edge to the object
that the edge refers to (Fig. 1). To capture the directionali ty 
of the ﬂow, an object graph has import and export edges. An 
importdataﬂowedgeexistsdueto thereturnvaluesofmethod
invocations or ﬁeld reads. An export dataﬂow edge exists due
to the arguments of method invocations or ﬁeld writes. A 
dataﬂow edge is relevant for security because it may lead to 
vulnerabilitiessuchasinformationdisclosureortamperi ng[3].
Object identity means that every abstract object in an object 
graphisuniquelyidentiﬁed. Asaresult,objectidentityenables 
the architects to assign a value to a security property of an 
objecto:O and enables comparison of references. Therefore,
thepropertyvaluecanbeaccessed fromallthedataﬂowedges
thatreferto o:O .Since o:O isuniquelyidentiﬁed,theproperty 
value is the same for all these dataﬂow edges. Also, two 
distinct abstract objects o1:C and o2:C can have different
property values even if o1 and o2 are of the same class C.
Object Provenance is a query that return the set of dataﬂow 
edges e1from a:A to b:B such that another dataﬂow edge 
e2exists from c:C to d:D and both e1and e2refer to the 
same object o:O (Fig. 1a). For security, the architects can 
decide if the communication of the object o:O is suspicious 
by writing a constraint that checks if the set returned by an 
object provenancequery is empty. When b:B and c:C are the 
same, the architects can reason about object transitivity.
Object Transitivity is deﬁned as the communication of an 
object o:O from a:A to c:C where a path of dataﬂow edges 
exists from a:A to c:C through some intermediate object 
b:B , where all the dataﬂow edges in the path refer to the 336a:A 
b:B o:O 
o:O 
c:C 
d:D o:O 
(a) Object Provenance: The same 
o:O that ﬂows from a:A to b:B 
should not ﬂow from c:C to d:D 
a:A b:B o:O o:O 
c:C o:O 
…o:O 
(b) Object Transitivity: All
dataﬂow edges in a path refer to 
the same o:O 
Legend 
dataflow refers to 
object dataflow 
communication o:O object 
o:O 
points-to 
communication 
parent-child 
relation in 
object hierarchy f
o:O indirect 
communication a:A b:B o:O anc:Anc 
parent:P 
o:O 
child1:C1 
desc:D …
…
child2:C2 
o2:O2 
(c) Object Hierarchy: A dataﬂow object
o:O has ancestors and descendants 
a:A b:B c:C d:D c:C o:O …
(d) Object Reachability: o:O is reachable 
from dataﬂow object c:C 
o:O a:A 
b:B 
child1:C1 
desc:D …c:D 
f:F …o:O 
o:O 
(e) Indirect Communication: a:A is con- 
nected to b:B through descendants and 
reachable objects.
Fig. 1: Information content available from communication 
same object o:O (Fig. 1b). Object transitivity is importantfor 
security to reason aboutthe initial sourceof a dataﬂowobje ct.
The object ﬂowing along an edge is not just a simple object,
it can have a substructure, or it can reach other objects.
Object Hierarchy is deﬁned as descendants and ancestors of 
an object o:O that are sets of objects such that a transitive 
parent-child relation exists between an object in the sets 
and o:O . Object hierarchy is important for security because 
conﬁdential information may be a descendant of a dataﬂow 
object, or a dataﬂow object can be part of the substructure of
an object that represents conﬁdential information (Fig. 1c ).
Object reachability is deﬁned as a path of edges of various 
typesfrom a sourceobject c:C to agivenobject o:O (Fig.1d).
The object o:O is reachable from c:C if a path exists from 
c:C to o:O . Object reachability is important for security 
becausethe objectthatrepresentsconﬁdentialinformatio ncan 
be reachable from a dataﬂow object. Then, the architects can
consider such an edge to be suspicious. There are different
types of relations between objects. In addition to dataﬂow, we 
also consider points-to and creation communication.
Apoints-tocommunication exists from the source object a:A 
to the destination object b:B if one of a’s ﬁeld fis a reference 
to b:B .Thelabelof thepoints-toedgeis the ﬁeld f.A points- 
to edge represents a persistent relation between objects an d is 
relevant for security because a dataﬂow object can be used 
to reach an object that represents conﬁdential information ,
although the dataﬂow object itself is not conﬁdential.SecGraph 
- root:SecObject
- edges():EdgeSet
- objects(): ObjSet
-objectProvenance (...): EdgeSet
-objProvenanceIndirect (...):
EdgeSet
-connectedByDF (...): EdgeSet
-getFlowToSink (...): EdgeSet
-reachables (o:SecObject, eTypes:
Set/an}bracketle{tEdgeType /an}bracketri}ht): ObjSet
ObjSetextends Set/an}bracketle{tSecObject /an}bracketri}ht
- name:String 
- prop:Property 
EdgeSetextends Set/an}bracketle{tSecEdge /an}bracketri}ht
- name:String 
- prop:Property 
SecObject extends SecElement
- C:Type 
- parentObj:SecObject
- parentDom:SecDomain 
- descendants() :ObjSet
- ancestors() :ObjSet
SecDomain extends SecElement
-d:String SecEdge extends SecElement
- src:SecObject
- dst:SecObject
- edgeType: EdgeType 
EdgeType:DataFlow PointsTo Creation 
DataFlowEdge extends SecEdge 
- ﬂow:SecObject
- direction:ImportExport
PointsToEdge extends SecEdge 
- ﬁeldName: String 
CreationEdge extends SecEdge 
- ﬂow:SecObject
SecElement
- name:String 
- traceability(): Set /an}bracketle{tTraceability /an}bracketri}ht
- trustLevel:
Trusted Untrusted Unknown 
- isConﬁdential: True False Unknown 
- isEncrypted: True False Unknown 
- isSerialized: True False Unknown 
- isSanitized: True False Unknown 
- isTransient: True False Unknown 
Traceability 
- expression: AstNode 
ClassInstanceCreation extends AstNode 
Fig. 2: Partial representation of the SecGraph . Continued in Fig. 3,4 
A creation communication exists from the source object a:A 
to the destinationobject b:B if acreates bfrom an object o:O .
Similar to a dataﬂowedge, a creation edge refersto the objec t
o:O and is relevant for security it may lead to vulnerabilities 
such as information disclosure or tampering.
Architects can obtain additional information about object s
that are indirectly connected by a dataﬂow communication 
through descendants or reachable objects.
Indirect communication exists from a source object a:A to a 
destination object b:B if a dataﬂow or a creation edge exists 
from a descendant of aor an object reachable from ato 
a descendant of bor an object reachable from b. Indirect
communication is relevant for security because a conﬁdenti al
object may be passed to a descendant of an untrusted object
and the communication is not explicit in the abstract graph.
B. Security Graph 
The SecGraph has SecObject s and SecDomain s as nodes,
and DataFlowEdge s,PointsToEdge s and CreationEdge s as 
edges (Fig. 2). The SecGraph provides queries such as de- 
scendants() for ﬁnding the set of descendants of a given 
SecObject, and reachables() for getting the set of reachable 
SecObject from a given SecObject. In the SecGraph , we omit
the detailsof the static analysisthat extractsthe OOG [7], and 
focus on the security properties, queries, and constraints . All
thesedatatypesextendthe SecElement ,whichhastraceability 
information consisting of a set of traceability entries tha t
correspond to expressions in the code. A traceability entry is 
a reference to a node in the Abstract Syntax Tree (AST) such 
as a ClassInstanceCreation . In the SecGraph , the ObjSetand 
EdgeSethave a name and property values for their elements.
An ObjSetis different from a SecDomain such that the same 
SecObject canbepartoftwo ObjSets,butthesame SecObject
cannot be part of two SecDomain s. The SecDomain allows 337Query based on object provenance 
objectProvenance (fSrc :SecObject ,fDst :SecObject ,
sSrc :SecObject ,sDst :SecObject ) : EdgeSet 
objectProvenance := /uniondisplay
{edge }s.t.edge :DataFlowEdge ∈edges () ∧
∃o∈objects () s.t.o∈ﬂow (connectedByDF (fSrc ,fDst )) ∧
edge ∈connectedByDF (sSrc ,sDst )∧edge.flow =o
ﬂow (dfEdges :Set /an}bracketle{tDataFlowEdge /an}bracketri}ht) : ObjSet 
ﬂow := /uniondisplay
{obj }s.t.obj :SecObject ∈objects () ∧
∃edge ∈dfEdges s.t.edge.flow =obj 
connectedByDF (src :SecObject ,dst :SecObject ) : EdgeSet 
connectedByDF := /uniondisplay
{edge }s.t.edge :DataFlowEdge ∈edges () ∧
(edge.src =src ∧edge.dst =dst )
objProvenanceIndirect (fSrc :SecObject ,fDst :SecObject ,
sSrc :SecObject ,sDst :SecObject ) : EdgeSet 
objProvenanceIndirect := /uniondisplay
{edge }s.t.edge: DataFlowEdge ∈edges () ∧
∃o∈objects () s.t.o∈ﬂow (connectedIndirect (fSrc ,fDst )) ∧
edge ∈connectedByDescendants (sSrc ,sDst )∨
edge ∈connectedByReachablility (sSrc ,sDst )∧edge.flow =o
Fig. 3: Object provenance queries on a SecGraph 
then the architects to place SecObject s of the same type in 
differentObjSets with different security properties.
Queries on the SecGraph .During ARA, the architects have 
some initial knowledge about the system. The queries allow 
thearchitectstoincreasetheirknowledgeasneededbyﬁndi ng 
details in the extracted architecture that they are unaware of.
The simplest queries use methods speciﬁed on an instance 
of the SecGraph ,G. For example, G.edges() returns all the 
edges in the graph. An instance edge of type DataFlowEdge ,
edge.ﬂow returns the dataﬂow object that edge refers to.
A query can also invoke methods in complex expressions 
such as edge.ﬂow.descendants() , which returns the set of all
descendants of the dataﬂow object.
The query objectProvenance returnsa set of dataﬂowedges 
such that the same object that ﬂows from a ﬁrst source to a 
ﬁrst destination also ﬂows from a second source to a second 
destination (Fig. 3). The query uses connectedByDF() that
returns the set of dataﬂow edges between two objects, and 
ﬂow() that returnsthe set of dataﬂow objects that the dataﬂow 
edges in a given set refer to.
Reasoning about object provenance may also involve in- 
direct communication through descendants and reachable ob -
jects. The query objProvenanceIndirect uses connectedByDe- 
scendants() that returns the set of dataﬂow edges from a 
descendant of the source to a descendant of the destination,
and connectedByReachability() that return the set of dataﬂow 
edges from an object reachable from the source to an object
reachable from the destination.
Enhancing OOG with security properties. To allow archi- 
tects to specify design information unavailable in the code , a 
SecElement has a extensible set of security properties. Each 
property includes predeﬁned values and the value Unknown 
used for default initialization. For example, the architec ts can 
specify objects that are trusted, or conﬁdential. The prope rty Assign property values and select objects 
setObjectsProperty (props :Set /an}bracketle{tProperty /an}bracketri}ht,cond :Condition )
∀obj ∈objects () ,s.t.cond.satisfiedBy (obj ) = ⇒
∃p:IsConfidential ∈props ∧obj.isConfidential := p∨
∃p:TrustLevel ∈props ∧obj.TrustLevel := p∨... 
getObjectsByCond (cond :Condition ) : ObjSet 
getObjectsByCond := /uniondisplay
{obj }s.t.obj :SecObject ∈objects () ∧
cond.satisfiedBy (obj )
Select edges based on security properties 
getFlowToSink (fProps :Set /an}bracketle{tProperty /an}bracketri}ht,sProps :Set /an}bracketle{tProperty /an}bracketri}ht) : EdgeSet 
flows := getObjectsByCond(fProps) sinks := getObjectsByCond(sProps) 
getFlowToSink := getFlowToSink(ﬂows,sinks) 
getFlowToSink (ﬂows :ObjSet,sinks :ObjSet ) : EdgeSet 
getFlowToSink := /uniondisplay
{e}s.t.e∈edges () ∧
e:DataFlowEdge ∨e:CreationEdge ∧
∃sink :SecObject ∈sinks ∧ ∃ o:SecObject ∈objects () s.t.
e∈connectedByDescendants (o,sink )∨
e∈connectedByReachability (o,sink, {PointsTo })∧
ﬂw ∈ﬂows ∩(e.ﬂow .descendants () ∪reachables (e.ﬂow ,{PointsTo })) 
Conditions based on type+object hierarchy 
InstanceOf (objT :Type )
satisfiedBy (obj :SecObject ):= obj.C. isSubTypeOf (objT )
IsInDomain (prntT :Type, prntD :String, objT :Type )
satisfiedBy (obj :SecObject ):= obj.C. isSubTypeOf (objT )∧
obj. parentDom .d =prntD ∧obj. parentObj .C. isSubTypeOf (prntT )
IsChildOf (prntO :SecObject,prntD :String,objT :Type )
satisfiedBy (obj :SecObject ):= obj.C. isSubTypeOf (objT )∧
obj. parentDom .d =prntD ∧obj. parentObj =prntO 
Condition based on type+object reachability 
IsInstOfRchblFromInstOf (st :Type ,dt :Type ,eType :Set /an}bracketle{tEdgeType /an}bracketri}ht)
isSrc := InstanceOf (st )isDst := InstanceOf (dt )
satisﬁedBy (obj :SecObject ) := ∃obj ∈getObjectsByCond (isSrc )∧
∃dobj ∈getObjectsByCond (isDst )∧obj ∈reachables (dobj,eType )
Condition based on type+object traceability 
IsCreateadInMD (methDecls :Set /an}bracketle{tMethodDeclaration /an}bracketri}ht)
satisﬁedBy (obj :SecObject ) := 
∃cic :ClassInstanceCreation ∈obj.traceability () s.t.
md :MethodDeclaration ∈cic. declarations () ∧md ∈methDecls 
Fig. 4: Selection and property queries on a SecGraph 
values are stored at the level of the SecGraph . In the rest
of this paper, when we say the architects assign to an object
TrustLevel .True , we mean the architects assign to the object
the security property TrustLevel with the value True .
Two types of queries traverse the SecGraph for a given 
Condition :aselectionquery,andapropertyquery.Aselection 
querysuchas getObjectsByCond() returnsthesetof objectsor 
the set of edges that satisfy the Condition . A property query 
such as setObjectsProperty() assigns security properties to a 
set of objects or a set of edges (Fig. 4). The SecGraph has 
severalCondition s that can be further extended. A Condition 
is a predicate that takes as arguments elements of the object
structure, code structure, or property values. The predica te is 
implemented by the satisﬁedBy method that is invoked for 
every element as the query traverses the SecGraph .338For example, a Condition such as IsCreatedInMD uses 
information from the code structure or the traceability inf or- 
mation.Aselectionqueryusing IsCreatedInMD returnstheset
of SecObject s instantiated in the body of one of the methods 
provided as argument. A query based on type only is less 
precise than a query that combines information from the code
structure and the SecGraph . For example, a query using the 
condition InstanceOf returns the set of all SecObject s of a 
type speciﬁed as argument.For additionalprecision, using the 
condition IsInDomain , a selection query returns a subset of 
these SecObject s by specifying the type of the parent object,
andnameofaparentdomain.Inaddition,a Condition canuse 
reachability information. For example a selection query ba sed 
on the condition IsInstOfRchblFromInstOf returns the set of 
SecObject s of a type dt that are reachable from SecObject s
of type st through various type of edges.
The SecGraph also provides the selection query getFlow- 
ToSink that takes as arguments two sets of property values 
fProps and sProps andreturnsthosedataﬂowedgesorcreation 
edgesthatrefertoa SecObject withthepropertyvalues fProps 
and has as destination a SecObject with the property values 
sProps . In the implementation, getFlowToSink also considers 
descendant and reachable SecObject s, as well as indirect
communication, such that the architects can write complex 
queries in terms of property values only.
IV. E VALUATION 
To evaluate the expressiveness of the approach, we formal- 
ize as machine-checkableconstraints several informal rul es in 
theCERT OracleSecureCodingStandardforJava[9]andone 
Android security policy. The study materials are available in 
anonlineappendix[15].Weevaluatethefollowinghypothes is:
Machine-checkable constraints in terms of object provenan ce 
andindirect communicationthatanalyze the hierarchyandt he 
reachability of abstract objects on a SecGraph can ﬁnd archi -
tectural ﬂaws such as information disclosure and tampering .
A. Constraints that Implement Rules in the CERT Standard 
We provide evidence to support the hypothesis using ﬁve 
extended examples based on the CERT rules. Each rule has 
an informal description, examples of non-compliant code,
and available solutions for automated detection. One of the
authorsofthispapercreatedcompleteexamplesfromthenon -
compliant code fragments, then, guided by the informal de- 
scription, wrote constraints to trigger the automated dete ction 
of the architectural ﬂaws. To select the ﬁve CERT rules, we 
used two criteria: the rule is related to architecturalﬂaws , and 
communication of objects, and the automated detection of th e
rule was previously unavailable.
MSC00-J. Use SSLSocket rather than Socket for secure 
dataexchange. Echo uses the Socket class to implement the 
client-server communicationover a network. However, such a
communication channel does not provide encryption and the 
communication is vulnerable to eavesdropping.
To ﬁnd a possible information disclosure, the constraint
insecureDataﬂows (line 1) uses object provenanceand checks insecureDataﬂows (g:SecGraph, isSrc :Condition, (1) 
isDst :Condition, isUntrusted :Condition )(2) 
insecureDataﬂows := /uniondisplay
{e}s.t.e:DataFlowEdge ∈g. edges () ∧(3) 
e∈g. objProvenanceIndirect (inObj,tObj,tObj,uObj )where (4) 
inObj ∈g. getObjectsByCondition (isSrc ) (5) 
tObj ∈g. getObjectsByCondition (isDst ) (6) 
uObj ∈g. getObjectsByCondition (isUntrusted ) (7) 
isSrc := IsInDomain (Main ,DATA ,InputStream ) (8) 
isDst := InstanceOf (EchoClient )∪InstanceOf (EchoServer )(9) 
isUntrusted := InstanceOf (Socket ) (10) 
{e1,e 2} ⊆ insecureDataﬂows (G, isSrc ,isDst ,isUntrusted ) (11) 
e1 := /an}bracketle{tclient:EchoClient ,out:PrintWriter ,ss:String /an}bracketri}ht(12) 
e2 := /an}bracketle{tserver:EchoServer ,wrtr:OutputStream ,ss:String /an}bracketri}ht(13) 
1class EchoClient { 
2void run(){ 
3Socket sckt = new Socket( "localhost" , 9999); 
4OutputStream out = sckt.getOutputStream(); 
5PrintWriter out = new PrintWriter(out, true ); 
6while ((userInput = System.in.read()) != null ) { 
7out.write(userInput); //inf. disclosure 
8System.out.println(userInput) //false positive 
9}
10 }
if the same object that ﬂows from an object of type 
InputStream in the domain DATA of the class Main (line 8) 
to an object of type EchoClient also ﬂows to an ob- 
jectsckt:Socket . The constraint also uses indirect object
provenance (line 4) and checks that the object ﬂows to the 
descendants or reachable objects of sckt:Socket . Indeed,
the same object ss:String ﬂows from client:EchoClient 
to the object out:Writer from which a descendant of 
sckt:Socket is reachable (line 12). The object ss also ﬂows 
from server:EchoServer to a descendant of sckt:Socket 
(line 13). The constraint highlights these two dataﬂow edge s
as suspicious. From a suspicious dataﬂow edge, the architec ts 
can trace to the method invocation out.write(stdInput) 
(line 7 in the code fragments). There are no coding defects,
however an information disclosure does exist.
If the constraint were to use the type information only and 
consider all objects of type OutputStream as untrusted, it
would report four suspicious dataﬂow edges including two 
false positives:the dataﬂowedgefrom client to the standard 
output stream, and the dataﬂow edge from server to a child 
of sslSocket:SSLSocket .
FIO05-J.Donotexposebufferscreatedusingthewrap()or 
duplicate()methodstountrustedcode. Theclass CharBuffer 
has methods that wrap an array of primitive types into an 
object of type CharBuffer . According to the Java documen- 
tation, modiﬁcations of an object of type CharBuffer cause 
the array to be modiﬁed and vice-versa [9], [16]. Therefore,
passing cb:CharBuffer to an untrusted object exposes the 
array that is reachable from cb . Instead, an object with a 
reference to a copy of the array should be passed.
The constraint bufferExposures (line 14) selects the objects 
of type CharBuffer created in the body of the method 339bufferExposures (g:SecGraph ) (14) 
bufferExposures := g. getFlowToSink ({IsConﬁdential .True }, (15) 
{TrustLevel .Untrusted })(16) 
mdWrap =G. getMethodDecl (CharBuffer.wrap ) (17) 
mdDuplicate =G. getMethodDecl (CharBuffer.duplicate )(18) 
isInMD := IsCreatedInMD ({mdWrap ,mdDuplicate }) (19) 
∀o∈getObjectsByCond (isInMD ), (20) 
isChild := IsChildOf (o, OWNED ,char[] ) (21) 
G. setObjectsProperty (IsConﬁdential .True ,isChild ) (22) 
G. setObjectsProperty (TrustLevel .Untrusted ,InstanceOf (Client )) (23) 
{e} ⊆ bufferExposures (G) (24) 
e:= /an}bracketle{tm:Main ,c:Client ,cb:CharBuffer /an}bracketri}ht (25) 
wrap or duplicate (line 19). Next, the constraint selects the 
children of these objects that are of type char[] (line 19) 
and assigns to them IsConﬁdential .True (line 22). The con- 
straint also assigns TrustLevel .Untrusted to c:Client ,which 
represents untrusted code (line 23). The query getFlowToSink 
returns a suspicious edge (line 25) because the dataﬂow 
objectcb:CharBuffer hasapoints-toedgetotheconﬁdential
object of type char[] and the destination object is c. This 
constraint may also consider objects of types that are simil ar 
to CharBuffer such as IntBuffer .
SER03-J.Donotserializeunencrypted,sensitivedata. Seri- 
alization saves an object persistently. All the ﬁelds reach able 
fromtheobjectarealsosavedunlessthedevelopersmarkthe m
as transient. An informationdisclosure exists if a conﬁden tial,
unencrypted object is serialized.
The CERT example [9, SER03-J] uses the Serializable 
interface. Since other libraries can also be used for serial iza- 
tion, the SecGraph has the property IsTransient to keep the 
constraint independent from a speciﬁc library. The constra int
insecureSerializations (line 26) assigns TrustLevel .Untrusted 
to objects of type ObjectOutputStream (line 32), then 
assigns IsConﬁdential .True and IsEncrypted .False to objects 
of type Double in the domain OWNED of objects of type 
Point (line 34).Next, it assigns IsTransient .False to points-to 
edges from objects of type Point to objects of type Double 
(line 36). Finally, insecureSerializations checksif the EdgeSet
returnedby getFlowToSink isnotemptysuchthattheoutgoing 
points-to edge from the dataﬂow object has IsTransient .False .
The constraintﬁnds an informationdisclosure as a dataﬂow 
from coord to oout (line 38), where the dataﬂow object
is p:Point that has references to value:Double . The ob- 
jectvalue:Double has the property IsConﬁdential .True and 
should not be serialized. However, the points-to edge from p
to value has IsTransient .False ,andserializationoccurs.Next,
thearchitectscan traceto codeandﬁndthe methodinvocatio n
oout.writeObject(p) in the body of Coordinates.run .
By using the condition IsInDomain , the constraint assigns 
property values only to a subset of all the objects of type 
Double , i.e., it does not include children of objects of type 
Coordinate .Iftheconstraintweretousethe InstanceOf con- 
dition instead of IsInDomain , all the objects of type Double 
would be considered conﬁdential, and insecureSerializations insecureSerializations (g:SecGraph ) (26) 
insecureSerializations := /uniondisplay
{e}e:DataﬂowEdge ∧ (27) 
e∈g. getFlowToSink ({IsConﬁdential .True ,IsEncrypted .False },(28) 
{TrustLevel .Untrusted })s.t. (29) 
∃pte ∈g. getOutEdges (e. ﬂow () ,PointsTo )∧pte .isTransient =False (30) 
isostream := InstanceOf (ObjectOutputStream ) (31) 
G. setObjectsProperty (TrustLevel .Untrusted ,isostream ) (32) 
points := IsInDomain (Coordinate ,OWNED ,Point ) (33) 
isXY := IsInDomain (Point ,OWNED ,Double ) (34) 
G. setObjectsProperty ({IsConﬁdential .True ,IsEncrypted .False },isXY )(35) 
G. setEdgesProperty (IsTransient .False ,IsPtEdge (points, isXY )) (36) 
{e} ⊆ insecureSerializations (G) (37) 
e=/an}bracketle{tcoord:Coordinates ,oout:ObjectOutputStream ,p:Point /an}bracketri}ht(38) 
insecureLogging (g:SecGraph ) (39) 
insecureLogging := g. getFlowToSink (IsConﬁdential .True , (40) 
TrustLevel .Untrusted ) (41) 
rch := IsInstOfRchblFromInstOf (InetAddress ,String ,{PointsTo })(42) 
G. setObjectsProperty (IsConﬁdential .True ,rch ) (43) 
isLog := InstanceOf (Logger ) (44) 
G. setObjectsProperty (TrustLevel .Untrusted ,isLog ) (45) 
{e} ⊆ insecureLogging (G) (46) 
e:= /an}bracketle{tsrvr:LogServer ,log:Logger ,ip:String /an}bracketri}ht (47) 
would return one false positive.
FIO13-J. Do not log sensitive information outside a trust
boundary. Logging enables a program to collect essential
information for debugging. However, logging conﬁdential i n- 
formation such as IP addresses may be prohibited by law 
in many countries [9, FIO13-J]. The class Logger in Java 
provides basic functionality for logging.
The constraint insecureLogging (line 39) checks if dataﬂow 
edgesexistsuchthata dataﬂowobjecthas IsConﬁdential .True 
and the destination has TrustLevel .Untrusted . The constraint
uses reachability information to assign IsConﬁdential .True 
only to the objects of type String reachable from an object
of type InetAddress (line 43). The constraint highlights a 
dataﬂow edge from srvr to log that refers to the object
ip:String . The architects can trace to the line of code 
logger.severe(machine.getHostAddress()) , which in- 
deed logs the IP address (line 47).
To assign the IsConﬁdential property, the architects use a 
condition that considers type and reachability informatio n. If 
the architects were to use a condition that considers only 
the type information, insecureLogging would return a false 
positivefortheexpression logger.getLogger(name) ,where 
the name argument does not refer to a conﬁdential object.
IDS07-J. Do not pass untrusted, unsanitized data to the 
Runtime.exec()method. A Java program can invoke external
commands provided by the operating system, such as a com- 
mand that lists a folder’s content. An architectural ﬂaw exi sts 
if an attacker can tamper with the input and launch arbitrary
injected commandswith the privileges of the target user. As a
solution, the program must sanitize untrusted objects ﬂowi ng 
along untrusted communication [9, IDS07-J].340commandInjections (g:SecGraph, isUntrusted :Condition, (48) 
isTrusted :Condition, mdExec :MethodDeclaration )(49) 
commandInjections := /uniondisplay
{e}s.t.e:DataFlowEdge ∧ (50) 
∃e∈g. objectProvenance (main,o,o,rt )where (51) 
(∃main :SecObject ∈g. getObjectsByCond (isUntrusted )∧(52) 
∃rt :SecObject ∈g. getObjectsByCond (isTrusted )∧ (53) 
∃o:SecObject ∈g. objects ()) ∧ (54) 
mInvk :MethodInvocation ∈edge. traceability () ∧ (55) 
mInvk.methodDecl =mdExec ∧edge.isExport () (56) 
mdExec := G. getMethodDecl (Runtime.exec ) (57) 
isUntrusted := InstanceOf (Main ) (58) 
isTrusted := InstanceOf (Runtime ) (59) 
{e} ⊆ commandInjections (G, isUntrusted ,isTrusted ,mdExec )(60) 
e:= /an}bracketle{tdirList:DirList ,rt:Runtime ,command:String /an}bracketri}ht (61) 
We adapted the example from CERT where the attacker 
can invoke arbitrary commands on Windows by tampering 
with the arguments of the method Runtime.exec . The con- 
straintcommandInjections (line 48) ﬁnds tampering by using 
object provenance, and traceability information. It uses o bject
provenance to check if the same object that is passed as 
an argument to m:Main is also passed to an object of type 
Runtime (line 51). It also uses traceability (line 55) and 
highlights only dataﬂow edges due to the method invocation 
Runtime.exec (line61).The architectstracetocodeandﬁnd 
the rt.exec("cmd.exe /C dir " + dir) .If theconstraint
were to use only informationaboutthe type of the arguments,
it would also return a false positive for rt.load(filename) .
B. Finding Architectural Flaws in an Android application 
Previousexamples presented constraintsthat foundinject ed 
architecturalﬂaws. We use Scoria to ﬁnd an architecturalﬂa w
in one Android application that the authors did not write.
An Android application is written in Java and consists of 
several Activity components that interact with the user usi ng 
a View. Two objects of type Activity communicate with 
each other using an Intent that represents a message used 
for inter- and intra-application communication. The follo wing 
security policy is documented both by researchers [17] and 
in the Android documentation [18]: “Do not put sensitive 
data into Intents used to start Activities [...]. For exam- 
ple, applications with the GET TASKS permission are able 
to see ActivityManager.RecentTaskInformation which incl udes 
the base Intent used to start Activities” .
In this case study, we evaluate if Scoria can ﬁnd an archi- 
tectural ﬂaw that violates this security policy. As our subj ect
system,weselectedUniversalPasswordManagerAndroidapp
(UPMA) version 1.13, a 4KLOC open-source Android app 
thatencryptsandstoresusernames,passwordsandconﬁdent ial
notes in a database protected by a master password. We se- 
lected UPMA because a security vulnerabilitywould impacta
largenumberofusersinterestedinprotectingtheirconﬁde ntial
information. Also, UPMA is actively maintained and has a 
repository that we can use to conﬁrm if developers changed 
the code to ﬁx the suspected architectural ﬂaws.insecureIntents (g:SecGraph ) (62) 
insecureIntents := g. getFlowToSink ({IsConﬁdential .True , (63) 
IsEncrypted .False },{TrustLevel .Untrusted })(64) 
isIntent := InstanceOf (Intent ) (65) 
setObjectsProperty (TrustLevel .Untrusted ,isIntent ) (66) 
isPwd := IsInDomain (AccountInformation ,PWD ,String ) (67) 
setObjectsProperty ({IsConﬁdential .True ,IsEncrypted .False },isPwd )(68) 
{e1,e 2,e 3,e 4} ⊆ insecureIntents (G) (69) 
e1 := /an}bracketle{tvad:VADetails ,intnt:Intent ,vad:VADetails /an}bracketri}ht (70) 
e2 := /an}bracketle{tvad:VADetails ,s:String ,pwd:String /an}bracketri}ht (71) 
e3 := /an}bracketle{tal:AccountsList ,s:String ,pwd:String /an}bracketri}ht (72) 
e4 := /an}bracketle{taea:AddEditAccount ,s:String ,pwd:String /an}bracketri}ht (73) 
Weimplementtheabovesecuritypolicyusingtheconstraint
insecureIntents . We then execute the constraint on the Sec- 
Graph extracted from annotated code of UPMA.
Information Disclosure in UPMA. A brief inspection of the 
code revealed that the class AccountInformation has the 
ﬁelds username and password to store conﬁdential informa- 
tion in plain text. The constraint insecureIntents (line 62) uses 
object hierarchy to distinguish between different objects of 
type String , where only the password and account represent
conﬁdential information (line 67). Thus, a potential infor ma- 
tion disclosure exists for those objectsof type Intent that re- 
ceivesuchinformation.Theconstraintusesthe getFlowToSink 
query (lines 63), which in turn uses indirect communication
through object hierarchy and object reachability to check 
that a dataﬂow object contains or can reach into conﬁdential
information.
Indeed, in version 1.14, the developer changes the class 
VADetails and set a security ﬂag in the method onCreate 1.
The value of the security ﬂag is checked at runtime by the 
Androidplatformtoensurethattaskmanagersandscreensho ts 
cannot disclose information if the View of this Activity is l eft
open. The following commit is associated with this change 
and shows a plus sign at the beginning of the lines added in 
VADetails . Scoria would still ﬁnd the architectural ﬂaw in 
UPMA 1.14 because it relies only on code structure infor- 
mation, and the architectural ﬂaw would be a false positive.
To prevent the false positive, the architects can change the
property value for the object intnt:Intent .
GIT commit @bd53100 
Hide accnt details in screenshots and task manager 
Security precaution to ensure a third party can’t view 
account details left open when UPM was last used. 
src/com/u17od/upm/ViewAccountDetails.java 
public void onCreate(Bundle savedInstanceState) { 
super.onCreate(savedInstanceState); 
+if (Utilities.VERSION.SDK_INT >= 
Utilities.VERSION_CODES.HONEYCOMB) { 
+ getWindow().setFlags(LayoutParams.FLAG_SECURE, 
LayoutParams.FLAG_SECURE); 
+} 
setContentView(R.layout.view_account_details); 
1https://github.com/adrian/upm-android/commit/bd5310 0.VADetails is a 
shorthand for ViewAccountDetails .341TABLE I: Summary of constraints that implement rules in the C ERT Oracle Secure Coding Standard for Java 
CERT-ID vulnerability object
prove- 
nance object
transi- 
tivity object
hierar- 
chy object
reach- 
ability object
trace- 
ability indirect
commu- 
nication suspicious 
edges avoided 
false 
positives object
security 
properties edge 
security 
properties 
MSC00-J inf.disclosure /check /check /check /check /check 2 2 0 0
FIO05-J inf.disclosure /check /check /check 1 1 2 0
SER03-J inf.disclosure /check 1 1 2 2
FIO13-J inf.disclosure /check 1 1 2 0
IDS07-J tampering /check /check /check 1 1 0 0
C. Discussion 
The results show that the SecGraph is expressive and can 
detect security vulnerabilitiesthat are architecturalﬂa ws. Two 
of the constraints use object provenance and do not require 
securityproperties.Fortheothers,thearchitectsneedto assign 
security properties to only a few of the SecElement s and 
use the defaults elsewhere (Table I). The constraints use th e
informationprovided by both types of edges in the SecGraph .
While all the constraints highlight dataﬂow edges, three of
them use reachability information through points-to edges .
Both evaluations highlight the fact that ARA requires a 
runtime architecture—not a code architecture. For example ,
bufferExposures distinguishes between different objects of 
the same type with different property values such as the 
two SecObject s of type char[] and the two SecObject s
of type CharBuffer . By using the runtime architecture, the 
constraints return fewer false positives. Some constraint s also 
use information from the code architecture, such as subtypi ng 
information or method names.
Inrecentwork[4],OOGswereabstractedintoaruntimear- 
chitecturerepresentedinanarchitecturaldescriptionla nguage.
ARA checks such as information disclosure were expressed 
as predicates that check only the presence or the absence of 
communication, which is not enough. In Scoria, not only can 
architects check the presence or absence of communication,
theycanalsoexpressconstraintsabouttheinformationcon tent
ofthecommunicationbetweenobjectsbecauseadataﬂowedge
refers to an abstract object. For example, in the constraint
insecureLogging , the SecGraph has two dataﬂow edges from 
srvr:LogServer to log:Logger . If the constraint were to 
check only for the absence of communication,it would be too 
restrictive. The communication from srvr to log is required,
otherwise the system becomes vulnerable to other security 
vulnerabilities such as repudiation. Only one dataﬂow edge
leads to information disclosure, and the constraint can tel l the 
two edges apart by tracking the object ﬂowing along the edge 
and using object provenance.
D. Limitations 
Our results may not generalize to other programs and 
architecturalﬂaws. The CERT examplescoverbothtampering
and information disclosure to evaluate the expressiveness of 
constraints. UPMA has the size of a typical Android applica-
tion and is smaller than a typical Java application [19]. Sco ria 
is focused on ﬁnding architectural ﬂaws related to connecto rs 
in a runtime architecture. The constraints are based on the 
runtimeandcodearchitectureandcouldalsoconsiderinfor ma- tion from other architectures such as deploymentarchitect ure.
Other architectural ﬂaws are related to the state of the obje ct,
and the SecGraph , which focuses only on runtime structure,
does not capture such information.
An SecGraph merges multiple objects of the same type in 
one domain, which may lead to false positive edges due to a 
method invocation in a super class [20]. None of the dataﬂow 
edgeshighlightedbytheconstraintsintheCERTexamplesis a
falsepositive.However,oneoffourdataﬂowedgeshighligh ted 
by insecureIntents inUPMAisafalsepositiveduetoexcessive 
merging of objects of type String in the domain SHARED .
A points-to edge exists from intnt:Intent to s:String 
in SHARED . A creation edge from aea:AddEditAccount 
to s:String refers to the conﬁdential object pwd:String 
(line 73). The object s:String excessively merges objects 
of type String including the object of type String created 
when the UPMA user edits an account. Sending the password 
in plain text to be changed by the user is part of the intended 
UPMA functionality and does not constitute an architectura l
ﬂaw. The architects can avoid this false positive by placing
these objects of type String in the UI domain to avoid 
excessive merging.
V. R ELATED WORK 
Static analysis of legacy object-oriented code. Many static 
analyses automatically extracted dataﬂow edges between ob -
jects in non-hierarchical object graphs [14], [20], [21]. F or 
example, Spiegel [14] builds a type graph, which he then 
unfolds into an object graph. These analyses do not track 
the content of dataﬂow edges as references to objects. Stati c
analysis frameworks such as SOOT [22] and WALA [23] 
have initially been used to compare different variants of 
alias analyses. Recently, they have been used to ﬁnd securit y
vulnerabilities in Android applications [24], [25], [26].
Analyses that ﬁnd local coding defects. Analyses that are 
fully automatic usually avoid a manual setup such as anno- 
tations [27]. They traverse the representation of the progr am 
suchastheAbstractSyntaxTree(AST)lookingforvulnerabi l- 
ities localized in a class or a method that are consequences o f
coding defects. To ﬁnd a local defect, a shallow analysis doe s
nothavetoconsidertheglobalinformationaboutthecontex tin 
whichthemethodorclassisused.Vulnerabilitiesaredescr ibed 
as patterns or AST visitors [2]. Although these pattern-bas ed 
approachesprovide automated detection, the output of a sta tic 
analysis tool still requires human evaluation [28]. While a n
AST-based analysis supports legacy, the AST representatio n
is often too detailed to ﬁnd architectural ﬂaws.342Annotation-based approaches. To enhance the code with an 
authorization mechanism such as role-based access control
many approaches use Java annotations. However, these anno-
tations are only checked at runtime.In contrast, a typechec ker 
ensures that annotations and code are consistent at compile -
time. For example, Object-sensitive Role Based Access Con-
trol (ORBAC) [29] uses a typechecker to enforce the security
policy that a user cannot read conﬁdential data of other user s
unless their roles allow him to do so. However, ORBAC does 
not handle object hierarchy and the role-based protection i s
not propagated to children objects, although the children m ay 
represent conﬁdential data.
Dynamic analysis of legacy code. A dynamic analysis can 
extract a hierarchical object graph using as input heap snap -
shots [30], [31], [32]. However, dynamic analysis can infer
a hierarchy based on only strict encapsulation where a child
object at the lower levels is accessible only throughits par ent.
In Scoria, however, a parent object can have multiple child 
objectsthatareconceptuallypartofitwithoutbeingdomin ated 
by the parent. Although a dynamic analysis has fewer false 
positivesthan a static analysis, a dynamicanalysisworks o nly 
if the architects are able to write unit tests to expose the 
vulnerability. The goal of ARA is to ﬁnd vulnerabilities tha t
may not be already known.
Operating system-level approaches. Many researchers focus 
on preventing vulnerabilities at the level of the operating sys- 
tem.However,developersmaystillintroducevulnerabilit iesat
the application level. For example, Mai et al. [33] propose a
lightweight operating system (ExpressOS) and prove that it is 
free of vulnerabilities. In the evaluation, the authors con sider 
about 300 vulnerabilities listed by the Common Weakness 
EnumerationInitiative (CWE) [34]. Although ExpressOS pre -
vented all OS-level vulnerabilities, it cannot prevent som e
application-level architectural ﬂaws.
Architectural-level approaches. Based on ARA, Sohr et al.
propose an architectural centric approach to ﬁnd architect ural
ﬂaws [35]. We share the same motivation in our work, but the 
solutions proposed differ. Their approach uses Bauhaus [36 ]
that extracts a code architecture rather than a runtime ar- 
chitecture. In a recent work [5], Bauhaus approximates the 
runtime architecture for two web applications, which are th en 
used to ﬁnd architectural ﬂaws. However, their approximate d
architecture does not distinguish between components of th e
same type used in different contexts, such as conﬁguration 
ﬁles. In Berger et al. [5], the architects can write constrai nts 
in the Object Constraint Language [37]. However, the edges 
on the runtime architecture have no labels, which makes 
it difﬁcult for the architects to write constraints about th e
information content of a dataﬂow. Indeed, the evaluation is
conductedinastylesimilartoReﬂexionmodels[38],focusi ng 
only on the presence or absence of communication.
Other researchersalso exploredthe idea formallydeﬁninga
vulnerability as a set of constraints [39]. Almorsy et al. [3 9],
[40] used OCL to write constraints on various UML models 
such as sequence and class diagram extracted from program AST. However, the static analysis that extracts the sequenc e
diagram is an AST visitor that does not consider aliasing.
Therefore, in the extracted sequence diagram, the object ty pe 
is the same as the declared type of the reference to the object ,
which can be an interface. Moreover, an interface can have 
multipleimplementations,andeachobjectofthese classes can 
have distinct property values.
He et al. [41] formalize the software architectural model
(SAM) using Petri nets. Similar to SAM, a SecGraph is 
hierarchical,butis less restrictive thana Petrinetthat r equires 
two disjoint sets of nodes: transitions and places. Dataﬂow
objects are similar to transitions, but with fewer restrict ions,
i.e., dataﬂow objects can also be nodes in the SecGraph .
Taint Analyses Similar to Scoria, a static taint analysis [26],
[42],[43],[44]ﬁndsinformationdisclosureandtampering .By 
tracking how the values ﬂow from a tainted method, such as 
the one that reads from user input, into a sink method without
beingsanitized.Astatic taintanalysisusesan inter-proc edural
control ﬂow graph that has nodes that represent variables an d
edges that account for conditional and assignment statemen ts 
andmethodinvocations.Asoundstatictaintanalysisconsi ders 
aliasing using a separate alias analysis provided by a stati c
analysis framework such as SOOT [22] or WALA [23].
However, an alias analysis may not scale if it considers all
the variables. To improve scalability, FlowDroid [44] uses an 
on-demand may-alias analysis [45] that considers only the 
variables with assigned security properties. A taint analy sis 
is thus less ﬂexible than Scoria because it hard-codes the 
constraints and the security properties.
Querying object graphs. Researchers proposed approaches 
that support querying object graphs to ﬁnd software defects
and architectural ﬂaws. For example, Object Query Language
(OQL) [46] queries are on a snapshot of a heap. Program 
Query Language (PQL) queries allow developers and archi- 
tects to reason about the results of an aliasing analysis [47 ].
Both OQL and PQL allow reasoningabout reachability.How- 
ever, since the object graphs are ﬂat, they do not support
queries in terms of object hierarchy or object provenance.
VI. C ONCLUSION 
To support ARA, we propose Scoria, a semi-automatic ap- 
proach that ﬁnds architectural ﬂaws using machine-checkab le 
constraints.Wedeﬁneasound,hierarchicalsecuritygraph with 
dataﬂow edges that refer to abstract objects. By automatica lly 
tracking object hierarchy and object reachability, Scoria en- 
ables reasoning about object provenanceand indirect commu -
nication that lead to architectural ﬂaws such as informatio n
disclosure and tampering. To evaluate Scoria, we enforce a 
subset of rules in the CERT standard for Java and an Android 
security policy using machine-checkable constraints that ﬁnd 
architectural ﬂaws in several extended examples and in one 
Android application.
ACKNOWLEDGEMENT 
This work was supported in part by the Army Research 
Ofﬁce under Award No. W911NF-09-1-0273.343REFERENCES 
[1] G. McGraw, Software Security: Building Security In . Addison-Wesley,
2006.
[2] University of Maryland, “FindBugs TM – Find Bugs in Java Programs,” 
http://ﬁndbugs.sourceforge.net/, 2007.
[3] F. Swiderski and W. Snyder, Threat Modeling . Microsoft Press, 2004.
[4] M. Abi-Antoun and J. M. Barnes, “Analyzing Security Arch itectures,” 
in IEEE/ACM International Conference on Automated Software E ngi- 
neering (ASE) , 2010, pp. 3–12.
[5] B. Berger, K. Sohr, and R. Koschke, “Extracting and Analy zing the Im- 
plemented Security Architecture ofBusiness Applications ,” in European 
Conference on Software Maintenance and Reengineering (CSM R) ,2013,
pp. 285–294.
[6] M. Abi-Antoun and J. Aldrich, “Static Extraction and Con formance 
Analysis of Hierarchical Runtime Architectural Structure using An- 
notations,” in Object-Oriented Programming, Systems, Languages & 
Applications (OOPSLA) , 2009, pp. 321–340.
[7] R. Vanciu and M. Abi-Antoun, “Ownership Object Graphs wi th 
Dataﬂow Edges,” in Working Conference on Reverse Engineering 
(WCRE) , 2012, pp. 267–276.
[8] P. Torr, “Demystifying the Threat-Modeling Process,” IEEE Security & 
Privacy , vol. 3, no. 5, pp. 66–70, 2005.
[9] F.Long,D.Mohindra, R.C.Seacord, D.F.Sutherland, and D.Svoboda,
The CERT Oracle Secure Coding Standard for Java . Addison-Wesley,
2011.
[10] M. Howard and D. LeBlanc, Writing Secure Code , 2nd ed. Microsoft
Press, 2003.
[11] J. Aldrich, C. Chambers, and D. Notkin, “ArchJava: Conn ecting Soft- 
ware Architecture to Implementation,” in International Conference on 
Software Engineering (ICSE) , 2002, pp. 187–197.
[12] J. J¨ urjens and P. Shabalin, “Automated veriﬁcation of UMLsec models 
for security requirements,” in UML: Modelling Languages and Applica- 
tions , 2004, pp. 365–379.
[13] T. Lodderstedt, D. A. Basin, and J. Doser, “SecureUML: a UML-Based 
Modeling Language for Model-Driven Security,” in UML: Modelling 
Languages and Applications , 2002, pp. 426–441.
[14] A. Spiegel, “Automatic Distribution of Object-Orient ed Programs,” 
Ph.D. dissertation, FU Berlin, 2002.
[15] R. Vanciu and M. Abi-Antoun, “Scoria Evaluation. Onlin e Appendix,” 
http://www.cs.wayne.edu/ ∼mabianto/scoria/, 2013.
[16] Oracle, “Java Platform Standard Edition 6 API Speciﬁca tion,” 2012.
[Online]. Available: http://docs.oracle.com/javase/6/ docs/api/
[17] J. Burns, “Mobile Application Security on Android,” Bl ack Hat, 2009.
[Online]. Available: http://www.blackhat.com/presenta tions/bh-usa-09/
BURNS/BHUSA09-Burns-AndroidSurgery-PAPER.pdf 
[18] Google, “Android API Guides,” http://developer.andr oid.com/training/
articles/security-tips.html, 2012.
[19] R. Minelli and M. Lanza, “Software Analytics for Mobile Applications 
– Insights & Lessons Learned,” in European Conference on Software 
Maintenance and Reengineering (CSMR) , 2013, pp. 144–153.
[20] A. Milanova, A. Rountev, and B. G. Ryder, “Parameterize d Object
Sensitivity for Points-To Analysis for Java,” ACM Transactions on 
Software Engineering and Methodology (TOSEM) , vol. 14, no. 1, pp.
1–41, 2005.
[21] D.Jackson and A. Waingold, “Lightweight Extraction of Object Models 
from Bytecode,” Transactions on Software Engineering (TSE) , vol. 27,
no. 2, pp. 156–169, 2001.
[22] P. Lam, E. Bodden, O. Lhot´ ak, and L. Hendren, “The Soot F ramework 
for Java Program Analysis: A Retrospective,” in Cetus Users and 
Compiler Infrastructure Workshop (CETUS) , 2011.
[23] IBM, “T. J. Watson Libraries for Analysis (WALA),” 2012 . [Online].
Available: http://wala.sourceforge.net
[24] A. Bartel, J. Klein, Y. Le Traon, and M. Monperrus, “Auto matically 
Securing Permission-Based Software by Reducing the Attack Surface:
An Application to Android,” in IEEE/ACM International Conference on 
Automated Software Engineering (ASE) , 2012, pp. 274–277.
[25] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri, “A Stu dy of 
Android Application Security,” in USENIX Conference on Security ,
2011, pp. 21–21.[26] A.Fuchs,A.Chaudhuri, andJ.Foster,“SCanDroid: Auto mated Security 
Certiﬁcation of Android Applications,” Univ. of Maryland, Tech. Rep.,
2009, http://babu.cs.umd.edu/ ∼avik/projects/scandroidascaa/paper.pdf.
[27] A.Bessey,K.Block, B.Chelf, A.Chou, B.Fulton, S.Hall em, C.Henri- 
Gros, A. Kamsky, S. McPeak, and D. Engler, “A few billion line s
of code later: using static analysis to ﬁnd bugs in the real wo rld,” 
Communications of the ACM (CACM) , vol. 53, no. 2, pp. 66–75, 2010.
[28] B. Chess and G. McGraw, “Static analysis for security,” IEEE Security 
& Privacy , vol. 2, no. 6, pp. 76–79, 2004.
[29] J. Fischer, D. Marino, R. Majumdar, and T. Millstein, “F ine-Grained 
Access Control with Object-Sensitive Roles,” in European Conference 
on Object-Oriented Programming (ECOOP) , 2009, pp. 173–194.
[30] A. Lienhard, S. Ducasse, and T. Gˆ ırba, “Taking an Objec t-Centric 
View on Dynamic Information with Object Flow Analysis,” Computer 
Languages, Systems and Structures (COMLAN) , vol. 35, no. 1, pp. 63– 
79, 2009.
[31] N. Mitchell, E. Schonberg, and G. Sevitsky, “Making Sen se of Large 
Heaps,” in European Conference on Object-Oriented Programming 
(ECOOP) , 2009, pp. 77–97.
[32] M.Marron, C.Sanchez, Z.Su,and M.Fahndrich, “Abstrac ting Runtime 
Heaps for Program Understanding,” Transactions on Software Engineer- 
ing (TSE) , vol. 39, no. 6, pp. 774–786, 2013.
[33] H. Mai, E. Pek, H. Xue, S. T. King, and P. Madhusudan, “Ver ifying 
Security Invariants in ExpressOS,” in Conference on Architectural 
Support for Programming Languages and Operating Systems (A SPLOS) ,
2013, pp. 293–304.
[34] MITRE Corporation, “The Common Weakness Enumeration ( CWE) 
Initiative,” 2012. [Online]. Available: http://cwe.mitr e.org 
[35] K. Sohr and B. Berger, “Idea: Towards Architecture-Cen tric Security 
Analysis of Software,” in ESSOS , 2010, pp. 70–78.
[36] A. Raza, G. Vogel, and E. Pl¨ odereder, “Bauhaus – a Tool S uite for Pro- 
gram Analysis and Reverse Engineering,” in International Conference 
on Reliable Software Technologies (Ada-Europe) , 2006, pp. 71–82.
[37] OMG, “Object Constraint Language,” 2013. [Online]. Av ailable:
http://www.omg.org/spec/OCL/
[38] G. Murphy, D. Notkin, and K. Sullivan, “Software Reﬂexi on Models:
Bridging the Gap between Design and Implementation” Transactions on 
Software Engineering (TSE) , vol. 27, no. 4, pp. 364–380, 2001.
[39] M. Almorsy, J. Grundy, and A. S. Ibrahim, “Supporting au tomated 
vulnerability analysis using formalized vulnerability si gnatures,” in 
IEEE/ACM International Conference on Automated Software E ngineer- 
ing (ASE) , 2012, pp. 100–109.
[40] ——, “Automated Software Architecture Security Risk An alysis using 
Formalized Signatures,” in International Conference on Software Engi- 
neering (ICSE) , 2013, pp. 662–671.
[41] X. He, H. Yu, T. Shi, J. Ding, and Y. Deng, “Formally Analy zing Soft- 
ware Architectural Speciﬁcations Using SAM,” J. Systems & Software ,
vol. 71, no. 1, pp. 11–29, 2004.
[42] A.C.Myers,“JFlow:Practical Mostly-Static Informat ion FlowControl,” 
in ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages (POPL) , 1999, pp. 228–241.
[43] O. Tripp, M. Pistoia, S. J. Fink, M. Sridharan, and O. Wei sman, “TAJ:
Effective Taint Analysis of Web Applications,” in ACM SIGPLAN con- 
ference on Programming Language Design and Implementation (PLDI) ,
2009, pp. 87–97.
[44] C. Fritz, S. Arzt, S. Rasthofer, E. Bodden, A. Bartel, J. Klein,
Y. le Traon, D. Octeau, and P. McDaniel, “Highly Precise Tain t
Analysis for Android Applications,” EC SPRIDE, TU Darmstad t,
Tech. Rep., 2013, https://www.informatik.tu-darmstadt. de/ﬁleadmin/
user upload/Group CASED/Publikationen/TUD-CS-2013-0113.pdf.
[45] O. Tripp, M. Pistoia, P. Cousot, R. Cousot, and S. Guarni eri, “AN- 
DROMEDA: Accurate and Scalable Security Analysis of Web Ap-
plications,” in Conference on Fundamental Approaches to Software 
Engineering (FASE) , 2013, pp. 210–225.
[46] VisualVM, “Analyzing a Heap Dump Using Object Query Lan guage 
(OQL),” 2013. [Online]. Available: http://visualvm.java .net/oqlhelp.html
[47] M. Martin, B. Livshits, and M. S. Lam, “Finding Applicat ion Errors 
and Security Flaws Using PQL: aProgram Query Language,” in Object- 
Oriented Programming, Systems, Languages & Applications ( OOPSLA) ,
2005, pp. 365–383.344