Detecting Differences across Multiple
Instances of Code Clones
Yun Lin1;2, Zhenchang Xing3, Yinxing Xue4, Y ang Liu3, Xin Peng1;2, Jun Sun5, Wenyun Zhao1;2
1School of Computer Science, Fudan University, China
2Shanghai Key Laboratory of Data Science, Fudan University, Shanghai, China
3School of Computer Engineering, Nanyang Technological University, Singapore
4School of Computing, National University of Singapore, Singapore
5Singapore University of Technology and Design, Singapore
{linyun, pengxin, wyzhao}@fudan.edu.cn, {zcxing, yangliu}@ntu.edu.sg,
dcsxuey@comp.nus.edu.sg, sunjun@sutd.edu.sg
ABSTRACT
Clone detectors Ô¨Ånd similar code fragments (i.e., instances of code
clones) and report large numbers of them for industrial systems.
To maintain or manage code clones, developers often have to in-
vestigate differences of multiple cloned code fragments. However,
existing program differencing techniques compare only two code
fragments at a time. Developers then have to manually combine
several pairwise differencing results. In this paper, we present
an approach to automatically detecting differences across multiple
clone instances. We have implemented our approach as an Eclipse
plugin and evaluated its accuracy with three Java software systems.
Our evaluation shows that our algorithm has precision over 97.66%
and recall over 95.63% in three open source Java projects. We
also conducted a user study of 18 developers to evaluate the use-
fulness of our approach for eight clone-related refactoring tasks.
Our study shows that our approach can signiÔ¨Åcantly improve de-
velopers‚Äô performance in refactoring decisions, refactoring details,
and task completion time on clone-related refactoring tasks. Au-
tomatically detecting differences across multiple clone instances
also opens opportunities for building practical applications of code
clones in software maintenance, such as auto-generation of appli-
cation skeleton, intelligent simultaneous code editing.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Maintenance
General Terms
Algorithm, Human Factors
Keywords
Code clone, Program differencing, Human study
1. INTRODUCTION
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô14, May 31 - June 7, 2014, Hyderabad, India
Copyright 14 ACM 978-1-4503-2756-5/14/05 ...$15.00.Code clones are similar code fragments in software. Many tech-
niques have been proposed to detect code clones based on token
similarity (e.g., CCFinder [17], CloneMiner [1] and CloneDetec-
tive [16]), Abstract Syntax Tree (AST) similarity (e.g., CloneDR [2],
Deckard [14]), or Program Dependence Graph similarity (e.g., [19,
22]). These clone detectors can detect not only textually identical
clones (Type I) but also parameterized clones (Type II) and gapped
clones (Type III) [3].
Textually identical clones refer to code fragments with differ-
ences only in whitespace, layout and comments. Parameterized
clones refer to syntactically identical code fragments except for
differences in identifers, literals and types. Gapped clones refer
to copied fragments with further modiÔ¨Åcations such as changed,
added or removed statements. A code clone often appears in mul-
tiple places in the system, i.e., having multiple instances. Table 1
presents a four-instances code clone in JHotDraw system. Note that
the clone instances are different in 5 places. Some clone instances
may be the same in one place but can be different in other places. In
a speciÔ¨Åc place, one clone instance may have parameterized and/or
gapped differences with other instances.
Differences in whitespace, layout and comments are not impor-
tant. But detecting and analyzing differences in parameterized and
gapped clones (parameterized and gapped differences thereafter)
such as those shown in Table 1 is important to manage and main-
tain code clones, for example to identify refactoring opportuni-
ties [40], to detect bugs [15], to support change propagation in code
clones [12, 24].
Existing program differencing techniques compare a pair of clo-
ned code fragments at a time. Pairwise differencing of multiple
clone instances cannot provide developers with a complete picture
of how multiple clone instances are different. Developers have to
manually investigate where clone instances are the same, where
they are different, and if different, which instances are different
and what types of differences. Unless developers take notes dur-
ing investigation, differences across multiple clone instances are
not readily available when developers need them in software main-
tenance tasks. Furthermore, manual analysis of clone differences
makes it impossible to automatically use clone differencing results
in software maintenance.
In this paper, we present an automatic approach to detecting dif-
ferences across multiple instances of a code clone. Our approach
MCIDiff (Multi-Clone-Instances Differencing) takes as input mul-
tiple clone instances in a clone set. It parses source code of each
clone instance into a sequence of tokens enriched with relevant syn-
tactic information (e.g., data type of a variable). MCIDiff computesPermission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE‚Äô14 , May 31 ‚Äì June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568298
164
Table 1: Code Clone Example in JHotDraw System
 
0 PertProject . java :
1 public void read ( File f ) {
2 InputStream in = null ;
3 try {
4 in = new
BufferedInputStream (
5 new FileInputStream ( f ) ) ;
6 NanoXMLLiteDOMInput domi =
7 new NanoXMLLiteDOMInput (
8 ( PertFactory )view .
9 getDOMFactory() , in ) ;
10 domi .openElement
11 ( ‚Äò ‚Äò PertDiagram ‚Äô ‚Äô ) ;
12 . . .
13 domi .closeElement () ;
14 }
15 catch ( InterruptedException e)
{
16 . . .
17 }
18 }

  
NetProject . java :
public void read ( File f ) {
InputStream in = null ;
try {
in = new
BufferedInputStream (
new FileInputStream ( f ) ) ;
NanoXMLLiteDOMInput domi =
new NanoXMLLiteDOMInput (
(NetFactory )view .
getDOMFactory() , in ) ;
. . .
}
catch ( InterruptedException e)
{
. . .
}
}

  
DrawProject . java :
public void read ( File f ) {
InputStream in = null ;
try {
in = new
BufferedInputStream (
new FileInputStream ( f ) ) ;
NanoXMLLiteDOMInput domi =
new NanoXMLLiteDOMInput (
(DrawFigureFactory )view .
getDOMFactory() , in ) ;
domi .openElement
( ‚Äò ‚ÄòPlasmaDraw ‚Äô ‚Äô ) ;
. . .
domi .closeElement () ;
}
catch ( InterruptedException e)
{
. . .
}
}

  
SVGProject . java :
public void read ( File f ) {
InputStream in = null ;
try {
in = new
BufferedInputStream (
new FileInputStream ( f ) ) ;
DOMInput domi =
new NanoXMLDOMInput (
(SVGFigureFactory )view .
getDOMFactory() , in ) ;
. . .
}
catch ( InterruptedException e)
{
. . .
}
}

 
Longest Common Subsequence (LCS) of multiple clone instances.
Then, it analyzes the LCS to determine differential ranges across
multiple clone instances, and identiÔ¨Åes similar tokens in differen-
tial ranges. MCIDiff produces as output a list of matched and dif-
ferential multisets (i.e., bags) of corresponding tokens of multiple
clone instances. Differential multisets summarize differences that
can be found in parameterized and gapped clones.
MCIDiff has been implemented as an Eclipse plugin with GUI
that allows developers to interactively investigate code clones and
their differences. Our MCIDiff tool can be downloaded at http:
//www.se.fudan.edu.cn/clonepedia/diff/. Our evaluation shows that
MCIDiff can build a detailed and accurate summary of differences
(over 97.66% precision and over 95.63% recall) across multiple
instances of a code clone. It can help developers to perform clone-
related refactoring tasks more easily and achieve better performance
in refactoring decisions, refactoring details, and task completion
time.
The rest of the paper is structured as followed. Section 2 presents
a motivating example of our work. Section 3 describes our ap-
proach to detecting clone differences. Section 4 presents our MCID-
ifftool. Section 5 discusses empirical evaluation of our approach.
Section 6 discusses our on-going work that exploits MCIDiff in
three software development tasks. Section 7 reviews related work.
Finally, we conclude and discuss the ideas for future work.
2. MOTIV ATING EXAMPLE
Table 1 shows four similar code fragments contained in read()
method of four classes (i.e., PertProject ,NetProject ,DrawProject ,
and SVGProject ) of JHotDraw applications. Such similar code
fragments are called code clones [29]. Each code fragment repre-
sents a clone instance in the clone set (see Section 3.1 for a formal
deÔ¨Ånition of clone set).
Although the four read() methods are very similar, they demon-
strate four typical types of differences across multiple clone in-
stances.
All Parameterized . All clone instances are different from one
another. For example, at line 8, four clone instances cast return
value of a method call view:getDOMFactory ()to four different
types respectively, i.e., PertFactory ,NetFactory ,DrawFigureFac-
tory, and SVGFigureFactory .Same+Parameterized . Some clone instances have no differ-
ences, others have parameterized differences. For example, at line
6,PertProject:read(),NetProject:read()andDrawProject :read()
have no difference (the data type of variable domi is the same,
i.e.,NanoXMLLiteDOMInput ), while SVGProject.read() is differ-
ent from the other three methods (the data type of variable domi is
DOMInput ). That is, SVGProject:read()and the other three meth-
ods have parameterized differences. Similar case can be found at
line 7.
Same+Gapped . Some clone instances have no differences, oth-
ers have gapped differences. For example, at line 13, both Pert-
Project.read() andDrawProject.read() calldomi.closeElements() ,
while NetProject.read() andSVGProject.read() do not call. When
comparing PertProject.read() /DrawProject.read() ) and NetProject.
read() /SVGProject.read() ), these clones have gapped differences.
Same+Parameterized+Gapped . Some clone instances have no
differences, some have parameterized differences, and others have
gapped differences. For example, at line 10/11, neither NetPro-
ject.read() norSVGProject.read() calldomi.openElements() .Pert-
Project.read() andDrawProject.read() calldomi.openElements()
with different parameters ( PertDiagram versus PlasmaDraw , i.e.,
parameterized difference). When comparing NetProject.read() /SV-
GProject.read() andPertProject.read() /DrawProject.read() , these
clones have gapped difference.
Multiple clone instances may have several differences. In our
example, four clone instances are different in Ô¨Åve places (lines
6, 7, 8, 10/11, and 13). Some clone instances may be the same
in one place but can be different in other places. For example,
PertProject:read(),NetProject:read()andDrawProject :read()are
the same at lines 6 and 7, but they have parameterized difference
at lines 8 and 10/11 and gapped difference at line 13. Further-
more, one clone instance may have different types of differences
against other clone instances in a speciÔ¨Åc place. For example, at
line 11 PertProject:read()andDrawProject :read()have parame-
terized difference, PertProject:read()andNetProject:read()have
gapped difference, while NetProject:read()andSVGProject:read()
have no difference.
Clearly, it is not an easy task to identify the above differences
through manual examination or pairwise differencing across multi-
ple clone instances. Developers have to manually determine where
clone instances are the same, where they are different, and if dif-165Figure 1: Incomplete Syntactic Units of Code Clones
ferent, which instances are different and what types of differences.
Furthermore, all manually-collected difference information is not
readily available when it is required for a software maintenance
task. Developers have to recall the information from memory or
based on notes (if any), or they may have to redo manual investiga-
tion again.
3. APPROACH
We now discuss our approach to detecting parameterized and
gapped differences across multiple clone instances.
3.1 Input
Our approach takes as input a clone set as reported by a code
clone detector. A clone set CS consists of n(n2)clone in-
stances ci k(1kn). Each clone instance cikrepresents a code
fragment. The code fragments of any pair of clone instances cikand
cil(k6=l) in a clone set CSare ‚Äúsimilar‚Äù according to similarity
metric deÔ¨Åned by the clone detector.
Code clones reported by a clone detector (e.g., token-based clone
detector) may not be complete syntactic units. For example, in
Figure 1 code fragments highlighted in green are code clones re-
ported by CloneDetective in JHotDraw applications. These code
fragments break syntactic boundary of try-block. We assume that
source code of the software is available. MCIDiff builds AST of the
method containing reported code clones. It then analyzes the AST
to Ô¨Ånd inner most syntactic unit (i.e., least common ancestor) that
contains incomplete syntactic units of cloned code fragment. The
corresponding syntactically complete code fragment is considered
as code fragment of clone instances for differencing.
Given a clone instance cik, we transform its code fragment into
atoken sequence ts (cik). According to Java Language SpeciÔ¨Åca-
tion [9], there are Ô¨Åve types of tokens in Java program, i.e., key-
word (e.g., if, while), separator (e.g., (, {), operator (e.g., +, -),
literal (e.g., ‚Äúabc‚Äù, 10) and identiÔ¨Åer. We further classify identifers
as type, method/Ô¨Åeld/variable, and label. As such, our approach
considers six categories of tokens, i.e., Type,Method/Field/Vari-
able/Literal ,Label ,Keyword ,Separator , and Operator .
Type, Method/Field/Variable/Literal and Label tokens have name
attribute. Keyword, Separator and Operator tokens have symbol
attribute. Method/Field/Variable/Literal tokens have attached data
type as token attribute. Our differencing algorithm compares cat-
egory and attribute of tokens to determine their correspondences.
We consider Method/Field/Variable/Literal as same-category of to-
kens. That is, methods, Ô¨Åelds, variables and literals are comparable
as long as they share compatible data type.
3.2 Output
Given ntoken sequences ts(cik), representing nclone instances
cikof a clone set, MCIDiff reports a list of multisets (i.e., bags) of
corresponding tokens. Each multiset MSconsists of ncorrespond-
ing tokens (one from each clone instance), i.e., MS=ftkjtk2
ts(cik)and1kng. A token tkfrom a clone instance cikcan
InputStream
[1]ci1[1, 88] ci2[1, 66]
...InputStream
[1]InputStream
[1]InputStream
[1]
in 
[2]in 
[2]in 
[2]in 
[2]
... ... ...
( 
[26]( 
[26]( 
[26]( 
[26]
PertFactory
[27]NetFactory
[27]DrawFigure
Factory [27]SVGFigure
Factory[27]
) 
[28])
 [28]) 
[28]) 
[28]... ... ... ...
domi 
[38]domi 
[38]
.
 [39]. 
[39]
openElement 
[40]openElement
[40]
Œµ ( 
[41]
‚Äú 
[42]
‚Äù 
[44]PertDiagram 
[43]( 
[41]
‚Äú 
[42]
‚Äù 
[44]PlasmaDraw 
[43]
) 
[45]) 
[45]
} 
[88]} 
[88]} 
[66]}
[66]... ... ... ...diffRange
diffRange; 
[37]; 
[37]; 
[37]; 
[37]ci3[1, 88] ci4[1, 66]
lcs[1]
lcs[2]
lcs[56]lcs[23]
lcs[24]
lcs[33]MS1={InputStream, 
InputStream, 
InputStream, 
InputStream}LCS MULTISET
MS2={in, in, in, in}
Œµ MS27={PertFactory, 
NetFactory, 
DrawFigureFactory, 
SVGFigureFactory}
MS40={openElement, 
Œµ, openElement, Œµ}
MS43={PertDiagram, Œµ, 
PlasmaDraw, Œµ}MS41={(, Œµ, (, Œµ}
SwingUtilities
[47]SwingUtilities
[38]SwingUtilities
[47]SwingUtilities
[38]; 
[46]; 
[46]
lcs[34]Figure 2: Results of MCIDiff
only be in one multiset. The token tkcan be, i.e., a placeholder to-
ken, which means that no real token from the given clone instance
corresponds to tokens from other clone instances in the given mul-
tiset.
Given a multiset MSof corresponding tokens, if all pairs of to-
kens tkandtl(k6=l) in the multiset are identical (i.e., all tokens in
this multiset have exactly the same category and attribute), the mul-
tiset is a matched multiset. Otherwise, the multiset is a differential
multiset. MCIDiff further label a differential multiset as follows. If
9tk=tl,MCIDiff attaches label ‚Äúsame‚Äù to the multiset. If 9tk6=tl,
MCIDiff attaches label ‚Äúparameterized‚Äù to the multiset. If 9tk=",
MCIDiff attaches label ‚Äúgapped‚Äù to the multiset.
Figure 2 shows partial token sequences of the four clone in-
stances shown in Table 1. We index the four clone instances from
left to right as ci1through ci4. Different colors illustrates differ-
ent categories, yellow for Types, canyon for Separators, and gray
for Method/Field/Variable/Literal. We omit datatype attribute of
Method/Field/Variable/Literal tokens for clarity.
The Ô¨Årst multiset MS1thatMCIDiff reports in this clone set is
a matched multiset { InputStream 1,InputStream 2,InputStream 3,
InputStream 4}. It consists of four identical Type tokens InputStream
from clone instances ci1,ci2,ci3, and ci4respectively. Several re-
ported differential multisets are: MS27={PertFactory 1,NetFactory 2,
DrawFigureFactory 3,SVGFigureFactory 4},MS40={openElement 1,
2,openElement 3,4},MS43={PertDiagram 1,2,PlasmaDraw 3,
4}. These differential multisets identify ‚ÄúAll Parameterized‚Äù, ‚ÄúSa-
me+Gapped‚Äù, and ‚ÄúSame+Parameterized+Gapped‚Äù differences dis-
cussed in motivating example.
3.3 Differencing Multiple Clone Instances
Algorithm 1 presents our MCIDiff algorithm. The algorithm takes
two parameters. The parameter tssconsists of ntoken sequences166Algorithm 1 MCIDiff
Require: List<TS>tss,List<Range>ciRanges
Ensure: List<Multiset<Token>>
1:results ?
2:List<int[]>lcs computeLCS (tss;ciRanges );
3:foreach token index array tokenIndices inlcsdo
4: multiset tokens at corresponding token index tokenIndecies from
token sequences in tss;
5: results:add(multiset );
6:end for
7:List<Range []>listDiffRanges 
determineDiffRanges (ciRanges;lcs);
8:foreach diffRange inlistDiffRanges do
9: derive a new list of non-empty ranges newciRanges by removing 
ranges in diffRnge ;
10: if1<newciRanges :size<ciRanges:sizethen
11: results:add(MCIDiff (tss;newciRanges ));
12: else if newciRanges :size() = ci:Ranges:sizethen
13: results:add(
identifySimilarTokens (tss;newciRanges ));
14: else if newciRanges :size= 1 then
15: foreach token index iin the non-empty range innewciRanges
do
16: multiset ?
17: Ô¨Åndrange ‚Äôs corresponding token sequence tsintss;
18: multiset:add(ts[i]);
19: results:add(multiset );
20: end for
21: end if
22:end for
23:return results ;
TSderived from code fragments of nclone instances. The param-
eterciRanges consists of a list of to-be-compared Ranges of token
sequences. Each Range speciÔ¨Åes a range of tokens (index of Ô¨Årst
andlasttokens) of a speciÔ¨Åc clone instance (identiÔ¨Åed by clone in-
stance index ciindexin the clone set). This range will be compared
with corresponding ranges of tokens of other clone instances. We
represent a Range of a speciÔ¨Åc clone instance as ciindex[Ô¨Årst;last].
Initially, ciRanges contains a Range for each clone instance. Range
atciRanges [k]is initialized as cik[1;tss[k]:length ], i.e., the whole
token sequence of clone instance cik. The algorithms generates as
output a list of multiset of corresponding tokens (can be ) intss.
Note that Ô¨Ånding the global optimal alignment for Nsequences
has been shown to be an NP-complete problem [34]. MCIDiff adopts
progressive alignment approach to compute an approximate solu-
tion. Progressive alignment approach has been widely applied to
align multiple DNA sequences [10]. It has been shown to be an
efÔ¨Åcient and accurate approach when sequences are similar. In this
work, we apply progressive alignment to align token sequences of
code clones.
3.3.1 Computing LCS
MCIDiff Ô¨Årst computes a Longest Common Subsequence (LCS)
across input token sequences tsswithin given ranges ciRanges (line
2). The computation starts with two longest token sequences, and
then proceeds to shorter token sequences one at a time. That is,
computerLCS ()Ô¨Årst computes the LCS of the two longest token
sequences, and then compares the resulting LCS with the third
longest token sequences, and so on till all token sequences are com-
pared. Given two token sequences, computeLCS ()implements dy-
namic programming algorithm [13] to compute the LCS between
them.
computeLCS ()considers only identical tokens, i.e., tokens with
exactly the same category and attributes. Note that our token is
enriched with relevant syntactic information as token attributes.This can improve accuracy of LCS computation. For example, if
two variable tokens have the same name but different data types,
computeLCS ()will not consider them as identical tokens.
The results of LCS computation is a list of token index arrays.
The length of LCS is the number of token index arrays in the list.
Each token index array contains indicies of ciRanges:size()corre-
sponding tokens, one from each toke sequence speciÔ¨Åed by ciRanges .
Take the four token sequences shown in Figure 2 as an example.
computeLCS ()reports the LCS as a list of 56 token index arrays,
i.e., the length of LCS across the four clone instances is 56. The
Ô¨Årst token index array (i.e., lcs[1])[1;1;1;1]indicates that the Ô¨Årst
token InputStream of four clone instances correspond to each other.
Similarly, the last token index array (i.e., lcs[56])[88;66;88;66]
indicates that the 88th token of clone instance ci1, 66th token of
ci2, 88th token of ci3, and 66th token of ci4correspond to each
other.
3.3.2 Determining Differential Ranges
Next, MCIDiff determine differential ranges in token sequences
that cannot be fully matched across all clone instances (line 7).
determineDiffRanges essentially determines gaps between subse-
quent token indices in the LCS of token sequences speciÔ¨Åed by
ciRanges .
For the four token sequences shown in Figure 2, determineDiff 
Ranges reports Ô¨Åve differential ranges, two of which are shown in
the Ô¨Ågure. For example, [27 27]of clone instance ci1,ci2,ci3, and
ci4is a differential range between lci[23]andlcs[24]. We represent
such a differential range as [ci1[27;27],ci2[27;27],ci3[27;27],
ci4[27;27]]. This range represents unmatched tokens PertFactory ,
NetFactory ,DrawFigureFactory , and SVGFigureFactory in four
clone instances respectively.
[ci1[38;46];ci2[];ci3[38;46];ci4[]]is another differential range.
This range represents unmatched token subsequences [domi, ., open-
Element, (, ‚Äú, PertDiagram, ‚Äù, ), ;] ,,[domi, ., openElement, (, ‚Äú,
PlasmaDraw, ‚Äù, ), ;] , andin four clone instances respectively.
Note that this differential range consists of only two non-empty to-
ken subsequences from clone instances ci1andci3. Clone instances
ci2andci4contain placeholder subsequences, i.e., no real tokens
from ci2andci4in this differential range. Furthermore, token sub-
sequences of clone instances ci1andci3can be further matched if
we compare only ci1andci3.
3.3.3 Processing Differential Ranges
If a differential range consisting of m(1<m<ciRanges:size())
non-empty token subsequences, MCIDiff ()will recursively process
these token subsequences by calling MCIDiff ()with a list of new
to-be-compared ranges derived from these non-empty token sub-
sequences (lines 9 and line 11). For example, from the differen-
tial range [ci1[38;46];ci2[];ci3[38;46];ci4[]],MCIDiff derives a
newciRanges consisting of two Ranges , i.e., ci1[38;46]andci3[38;
46]. It then calls MCIDiff ()recursively with this newciRanges .
Such recursive calls will identify as many identical tokens as
possible across clone instances before we use similarity heuristics
to determine correspondences between non-identical tokens across
clone instances. For example, the recursive call to MCIDiff ()with
to-be-compared ranges [ci1[38;46];ci3[38;46]] identiÔ¨Åes the LCS
([domi;:;openElement ;(;\;";);;]) between the two token subse-
quences, and leaves only two identiÔ¨Åers PertDiagram inci1and
PlasmaDraw inci3unmatched. This can improve efÔ¨Åciency and
accuracy of similarity-based matching of non-identical tokens.
The number of non-empty token subsequences in a differential
range can be the same as ciRanges:size(), for example, { PerFactory ,
NetFactory ,DrawFigureFactory ,SVGFigureFactory } in the initial167call to MCIDiff , and { PertDiagram ,PlasmaDraw } in the recursive
call to MCIDiff . This indicates that MCIDiff cannot identify identi-
cal tokens across all token sequences in the range ciRanges . In such
cases, MCIDiff calls identifySimilarTokens ()(line 13) to determine
correspondences between non-identical tokens based on their sim-
ilarities (see Section 3.4).
3.3.4 Generating Multisets of Corresponding Tokens
First, MCIDiff generates multisets of corresponding tokens based
on the LCS (lines 3-6). It visits each token index array in the
LCS list and creates a multiset of corresponding tokens accord-
ingly. For example, for the Ô¨Årst token index array lcs[1]=[1;1;1;1],
MCIDiff creates a multiset { InputStream 1,InputStream 2,InputStr 
eam 3,InputStream 4}. For the last token index array lcs[56]=[88,
66, 88, 66], MCIDiff creates a multiset {g1,g2,g3,g4}.
Note that the LCS determined in the recursive call to MCIDiff ()
consists of tokens from a subset of all token sequences, for exam-
ple token sequences ci1andci3in the recursive call with Ranges
[ci1[38;46];ci3[38;46]]. Thus, multisets derived from such LCSs
will consist of tokens only from this subset of token sequences. For
the rest of token sequences that are not in this subset (for example
ci2andci4), they essentially contribute tokens to the multiset.
For example, based on the LCS [ domi;:;openElement ;(;\;";)]
of two token subsequences in the ranges [ci1[38;46];ci3[38;46]],
MCIDiff creates multisets such as { domi 1,2,domi 3,4}.
Next, identifySimilarTokens ()generates multisets of correspond-
ing tokens as it determines correspondences of non-identical tokens
in a given differential range.
Finally, if a differential range consists of only one non-empty to-
ken subsequence, MCIDiff creates multisets that consist of tokens
only from this subsequence (lines 15). That is, all other clone in-
stances contribute to these multisets.
3.4 Identifying Correspondences Between Sim-
ilar Tokens
Given a list of token sequences ( tss) and a list of differential
ranges ( diffRanges ),identifySimilarTokens ()(see Algorithm 2) pro-
cesses toke sequences from the longest to the shortest (line 3). For
each to-be-compared token sequence ts,identifySimilarTokens ()
scans it from the beginning to the end. For a not-yet-matched token
tints,identifySimilarTokens ()adds it as seed token to a multiset
multiset (line 6). It then attempts to Ô¨Ånd similar tokens from the rest
of token sequences ( candTSs ) iteratively (lines 7-14). In each iter-
ation, identifySimilarTokens ()Ô¨Ånds a not-yet-matched token tcand
from all candidate token sequences that is most similar to tokens
already in the multiset (line 8).
The similarity between a candidate token and tokens in the mul-
tiset sim(tcand;multiset ) is computed as the average similarity of
tcandand each token t2multiset , i.e.,P
t2multisetsim(tcand;t)=j
multisetj. If this similarity is above the threshold h, the candi-
date token tcandis added to the multiset (line 12) and the candidate
sequence containing tcandis removed from candidate sequence list
(line 13). This process continues until no more similar enough can-
didate token can be found (lines 9-11) or candidate sequence list is
empty (i.e., all candidate sequences already contribute one token to
the multiset) (line 7). If the resulting multiset contains two or more
tokens, it is added to the results list (line 16).
Finally, identifySimilarTokens ()scans each token sequence and
identiÔ¨Åes still-not-yet-matched tokens for which identifySimilarTo-
kens() cannot Ô¨Ånd any similar enough tokens in other token se-
quences. It creates multisets for these still-not-yet-matched tokens
in each sequence. Such multisets consist of only one real token and
all other tokens are .Algorithm 2 identifySimilarTokens
Require: List<TS>tss,List<Range>diffRanges ,h
Ensure: List<Multiset<Token>>
1:results ?
2:create a new list of token subsequences tbcTSs from tssanddiffRanges ;
3:foreach token sequence tsintbcTSs (from longest to shortest) do
4: candTSs tbcTSs:remove (ts);
5: foreach not-yet-matched token tintsdo
6: multiset ?;multiset:add(t);
7: while candTSs6=?do
8: Ô¨Ånd a not-yet-matched token tcand in all candidate token se-
quences candTSs with maximum sim(tcand;multiset )
9: ifsim(tcand;multiset )<hthen
10: break;
11: end if
12: multiset:add(tcand);
13: remove the token sequence containing tcandfrom candTSs ;
14: end while
15: mark all tokens in multiset as matched;
16: ifjmultisetj>2results:add(multiset )
17: end for
18:end for
19:create multisets for all still-not-yet-matched tokens
20:return results ;
identifySimilarTokens ()only matches tokens with same category.
That is, if two tokens are of different categories, their similarity is 0.
Given two same-category tokens t1andt2,identifySimilarTokens ()
computes their similarity ( sim(t1;t2)) by comparing the attributes
of tokens and relative positions in token sequences.
For Keyword (or Separator, Operator, Label) tokens, sim attr= 1
if two tokens have the same symbol (or name), otherwise sim attr=
0. For Type (or Method/Field/Variable/Literal) tokens, sim attris
computed as Jaccard coefÔ¨Åcient of common supertypes of Type
tokens (or data (return) types of Method/Field/Variable/Literal to-
kens), i.e.,jSuperType (t1)\SuperType (t2)j=jSuperType (t1)[
SuperType (t2)j.
identifySimilarTokens ()computes position similarity ( sim pos) be-
tween two tokens t1andt2by measuring their relative positions in
corresponding token sequences. Given two ranges R1with length
len1andR2with length len2, let Ô¨Årst index of R1andR2beÔ¨Å1and
Ô¨Å2, index of t1andt2in token sequences be p1andp2, position
similarity sim pos(t1;t2)is computed as: 1 j(p1 Ô¨Å1)=len1 
(p2 Ô¨Å2)=len2j.
Given two same-category tokens, their overall similarity is then
computed as average of their attribute similarity and position simi-
larity, i.e., sim(t1;t2) = ( sim attr(t1;t2) +sim pos(t1;t2))=2.
4. TOOL SUPPORT
We have implemented MCIDiff as an Eclipse plugin. The current
implementation parses CloneDetective ‚Äôs clone detection report as
input. Note that MCIDiff does not make any speciÔ¨Åc assumption
about clone detectors. Given a different clone detector, MCIDiff
only needs a new parser to parse clone detection report of that clone
detector.
MCIDiff consists of three views Clone Set view, Clone Diff view
andDiff Property view for interactively inspecting code clones and
their differences. Figure 3 shows a snapshot of MCIDiff for ana-
lyzing code clones in our motivating example.
Clone Set view lists all the clone sets reported by CloneDetective
for a subject system. Each row corresponds to a clone set; it sum-
marizes the number of clone instances (#Ins), average length of
code of clone instances (#LOC), the number of differential multi-
sets (#Diff), and the differential ratio (#Diff/#LOC). Clone sets can168Figure 3: Snapshot for MCIDiff
Table 2: Basic statistics of three subject systems
System #Class #LOC #CloneSets Precision Recall
JavaNewIO1.6.0 132 46718 34 100% 100%
JHotDraw7.0.6 309 57031 334 97.66% 95.63%
JFreechart1.0.13 594 222812 463 98.82% 98.39%
be sorted by columns. Double clicking a clone set in Clone Set
view opens Diff Property view and Clone Diff view.
Diff Property view summarizes basic statistics of the selected
clone set. Clone Diff view visualizes differences across clone in-
stances side by side. Differential multisets are highlighted with dif-
ferent background colors, all-parameterized with red, same+param-
eterized with pink, same+gapped with green, parameterized+gapped
with purple, same+parameterized+gapped with yellow. Clicking
upordown button on top-right corner of this view highlights pre-
vious or next differential multiset in bold font.
5. EV ALUATION
In this section, we report our evaluation of MCIDiff approach
and tool support. We evaluated the accuracy of our MCIDiff algo-
rithm with three open source Java systems (JavaIO, JHotDraw, and
JFreeChart). We also conducted a user study to evaluate the use-
fulness of MCIDiff ‚Äôs differencing reports for eight clone-related
refactoring tasks.
5.1 The Accuracy of MCIDiff
Table 2 summarizes basic statistics of the three subject systems.
CloneDetective [16] reports 831 clone sets in the three systems,
among which 77% are parameterized and gapped clones. These pa-
rameterized and gapped clone sets contain 7:35:7(meanstddev)
differential multisets. About 30% lines of cloned code fragments
contain parameterized and/or gapped differences.
To examine the accuracy of MCIDiff , the third author manu-
ally investigated all parameterized and gapped clones reported by
CloneDetective . He used Eclipse Java Editor and Java Compare.
He spent about 22 hours in building ground truth set Dactual of dif-
ferences in the reported code clones. Among all 638 parameterized
and gapped clone sets, 353 contain 2 instances, 235 contain 3-5 in-
Figure 4: Reordered code elements in code clones
stances, while the rest 50 contain more than 5 instances. The third
author spent on average less than 1 minute on a 2-instances clone
set, about 2.5 minutes on a clone set consisting of 3-5 instances,
and about 10 mins on a clone set consisting more than 5 instances.
Although clone sets consisting of three or more instances account
for only 44.7% ((235+50)/638) of all clone sets reported, the third
author spent about 80% of his time on determining differences in
these clone sets.
We used precision and recall metrics to evaluate the accuracy of
MCIDiff ‚Äôs differencing results. Let Dreported be the set of differen-
tial multisets reported by MCIDiff , precision is percentage of cor-
rectly reported differential multisets, i.e., jDreported\Dactualj=j
Dreportedj, and recall is percentage of actual differential multisets
reported, i.e.,jDreported\Dactualj=jDactualj.
Table 2 presents precision and recall of MCIDiff in the three
subject systems. Overall, MCIDiff is able to detect parameterized
and gapped differences in code clones of JavaNewIO, JHotDraw,
and JFreeChart with a good combination of precision and recall.
MCIDiff is accurate in identifying parameterized differences and
added/removed statements such as those shown in our motivating
example. But the accuracy of MCIDiff will most likely suffer when
clone instances have reordered code fragments and/or complex ex-
pressions.
When code fragments are reordered across clone instances, dif-
ferencing results may become arguable. Figure 4 presents such an
example. At line 168 and 188 of two clone instances, parameters
for calling tx:translate ()are swapped and also different, (0;y 
b:y b:height=2)versus (x b:x b:width=2;0).MCIDiff reports169Figure 5: Complex expressions in code clones
Ô¨Åve differential multisets, {0, }, {y,x}, {y,x}, {height ,width }, and
{, 0}. That is, MCIDiff reports the second parameter of method
call at line 168 and the Ô¨Årst parameter of method call at line 188 as
parameterized, and reports the Ô¨Årst parameter of method call at line
168 and the second parameter of method call at line 188 as gapped.
This differencing result is arguably correct. First, these differential
multisets reveal important differences across clone instances (e.g.,
yversus x,height versus width ). Second, differential multisets {0,
} and {, 0} can still remind developers reordering of parameters.
Complex expressions pose another challenge to MCIDiff . For
example, at line 74 and 62 of the two clone instances shown in Fig-
ure 5, MCIDIFF reports gapped differences { (labels[i].length()
== 0) ? ‚Äú ‚Äù :, }, followed by a parameterized difference { labels ,
lines }, followed by matched multisets { [i],[i]}. A more intuitive
differencing result would be a differential multiset consists of the
two parameters, because it can revel that different clone instances
initialize JLabel object in different way. This is a general limitation
of token-based differencing approach, because it does not consider
syntactic structure of the program. MCIDiff favors efÔ¨Åciency and
simplicity of token-based approach over robustness of syntactic dif-
ferencing. In the context of differencing code clones (i.e., similar
code fragments), our results show that token-based approach can
produce highly accurate results, except for about less than 5% dif-
ferential multisets involving reorder code fragments and/or com-
plex expressions.
5.2 The Usefulness of MCIDiff
Having evaluated the accuracy of MCIDiff , the next question
we would like to address is ‚Äúwhat is MCIDiff ‚Äôs differencing re-
sults good for?‚Äù. We conducted a user study to investigate whether
MCIDiff can help developers achieve better performance in clone-
related refactoring tasks. We acknowledge that refactoring (or re-
moving) code clones usually involves many factors other than just
checking the differences of multiple clone instances [38]. How-
ever, detecting and understanding differences across multiple clone
instances is one of the key factors to make informed decisions on
clone refactorings. Therefore, we deem that clone refactoring is a
valid means to evaluate the usefulness of MCIDiff.
5.2.1 Study Design
In this study, we chose CloneDetective [16] as baseline clone
analysis tool to compare with our MCIDiff .CloneDetective is also
implemented as an Eclipse plugin, which allows us to make a fair
comparison between MCIDiff andCloneDetective in the same de-
velopment environment. Furthermore, CloneDetective not only de-
tects code clones, it also provides rich features for analyzing de-
tected clones, such as pairwise differencing and difference high-
lighting, ApsectJ-based visualization of code clones across multi-
ple Ô¨Åles, keyword-based searching.
We recruited 18 graduate students from the School of Software,
Fudan University. Before the experiment, we surveyed capabil-Table 3: Statistics of subject clone sets
#InstComplexity Description Refactoring
#1 2 mediumclones reside in two methods
declared in two subclasses of
the same direct superclasspull up
methods
#2 2 highclones reside in two methods
declared in two classes of the
same far-away ancestor classdo not
suggest
refactoring
#3 2 mediumclones reside in two methods
of two subclasses of the same
direct superclass; have 3
parameterized differences in
26 lines of cloned codeextract
parameters;
pull up
methods
#4 3 highclones reside in three methods
declared in three subclasses of
the same far-away ancestor
classes; have 2 parameterized
differences in method callscannot be
refactored
#5 4 lowclones reside in four methods
of the same classreplace
method body
with method
call
#6 4 mediumclones reside in four methods
declared in two subclasses of
the same direct superclass;
have 6 parameterized
differences in 40 lines of
cloned codeextract
parameters;
pull up
methods
#7 5 highclones reside in Ô¨Åve methods
of different anonymous
classes contained in three
different classes; the three
different classes have
grandparent-parent-child
relations; have 6
parameterized+gapped
differences in 16 lines of
cloned codeextract
parameters;
extract a new
method in
grandparent
class
#8 6 mediumclones reside in four methods
of the same class; have 9
same+parameterized+gapped
differences in 8 lines of
cloned codeextract
parameters;
extract
method
ity of participants, including years of programming experience, fa-
miliarity with Java and Eclipse, and familiarity with code clones
and refactoring. We used matched-participant two groups design
to allocate participants to study groups. Participants are matched
in pairs based on their capability. Each pair is then randomly allo-
cated to experimental group or control group. Experimental group
G1using MCIDiff to perform refactoring tasks, while control group
G2using CloneDetective to perform the same set of tasks. We gave
a tutorial of MCIDiff andCloneDetective tool three hours before
the experiment and asked the participants to familiarize themselves
with important concepts and features of the relevant tool they will
use.
Both groups ( G1andG2) were given 8 clone sets in JHotDraw
(see Table 3). The eight clone sets used in this study differ in the
number of clone instances and their complexity. The complexity
is determined based on whether refactoring decisions and details
require mainly localized information within clones or more global
information beyond clones (e.g, type hierarchy information).
Participants were asked to answer two questions for each clone
set: 1) refactoring decision , whether these clone sets can be refac-
tored, what refactoring can be applied and why; 2) refactoring de-
tails, what has to be done (e.g., reconcile naming inconsistencies,
extract parameters) before clones can be refactored, and what are
expected outcomes of refactorings (e.g., where to place cloned code
fragments). Participants were required to run a full-screen recorder
throughout experiment sessions. The recorded task videos enable170Table 4: Scoring Criteria for Refactoring Decisions and Details
Score Criteria
0 Irrelevant, wrong or non-sensible reason
1 General or vague reason
2 Partly speciÔ¨Åc and right reason
3 SpeciÔ¨Åc and right reason
us to analyze behaviors of each participant after the experiment.
We evaluated participants‚Äô performance in terms of correctness
and quality of their refactoring decisions and details. We invited
two experts: one expert developed and maintained an in-house
JHotDraw application for more than one year, and the other expert
is a senior software architect from Alcatel who has nine years in-
dustrial experience and is an expert on software clones and related
software maintenance issues. The two experts were asked to work
together to provide ‚Äúground-truth‚Äù answers for the eight clone sets.
They reached consensus that six clone sets can be refactored (see
Table 3). After the experiment, we asked the two experts to grade
participants‚Äô refactoring answers. A score ranging from 0 to 3 (see
Table 4) was given to quantify correctness and quality of partici-
pants‚Äô refactoring decisions and details. To avoid experimenter ex-
pectancy effects, the two experts did not know which study group
a participant belongs to when when they graded the participant‚Äôs
answers.
5.2.2 Results: Improvement on Performance
To evaluate performance improvement of MCIDiff , we compared
scores of refactoring decisions, scores of refactoring details and
task completion time of experimental group ( G1) and control group
(G2).
Hypotheses: We introduced the following null and alternative hy-
potheses to evaluate how different performance of experimental
and control groups is.
H0: The primary null hypothesis is that there is no signiÔ¨Åcant
difference between the performance of both groups.
H1: An alternative hypothesis to H0 is that there is signiÔ¨Å-
cant difference between the performance of both groups.
Results of Individual Participants: Table 5 and Table 6 present
participants‚Äô performance, in terms of each participant‚Äôs average
score of refactoring decisions, average score of refactoring details,
and average task completion time (minutes) on eight clone sets.
Overall, MCIDiff users achieved higher scores in refactoring deci-
sions ( 2:1520:577versus 1:6530:595) and refactoring details
(2:0830:430versus 1:6810:537) than CloneDetective users.
MCIDiff users also completed the tasks in shorter time ( 2m53s
44sversus 3m31s47s) than CloneDetective users.
Table 5: Performance of MCIDiff Group
Participant Decision Score Details Score Time(mins)
P1 2.625 2.750 1m53s
P2 2.750 2.500 1m46s
P3 2.125 2.250 3m18s
P4 2.875 2.250 3m51s
P5 1.875 2.250 2m10s
P6 2.375 2.125 2m40s
P7 2.250 1.625 3m27s
P8 1.500 1.625 3m54s
P9 1.000 1.375 3m24s
Average 2.152 2.083 2m53s
Std.Dev. 0.577 0.430 44sTable 6: Performance of CloneDetective Group
Participant Decision Score Details Score Time(mins)
P10 2.500 2.375 2m03s
P11 2.000 2.000 2m48s
P12 1.750 2.000 3m59s
P13 2.250 2.125 3m27s
P14 1.500 1.500 3m48s
P15 2.000 2.125 3m15s
P16 1.375 1.250 3m09s
P17 1.000 0.875 4m09s
P18 0.500 0.875 4m23s
Average 1.653 1.681 3m31s
Std.Dev. 0.595 0.537 47s
Results of Hypotheses Testing: We performed Shapiro-Wilk test
[30] on refactoring decision scores, refactoring details scores, and
task completion time of both groups. The analysis shows that the
data conforms to normal distribution. Therefore, we used paired
sample t-tests to evaluate the null hypothesis H0 in terms of refact-
oring-decision score, refactoring-details score, and task completion
time. We evaluate the hypotheses at a 0.05 level of signiÔ¨Åcance.
The results of these three tests are shown in Table 7. Based on
the results we reject null hypothesis H0 for all the measures of
refactoring-decision score, refactoring-details score, and task com-
pletion time. Therefore, we accept the alternative hypothesis H1,
i.e., there is signiÔ¨Åcant difference between the performance of par-
ticipants who use MCIDiff andCloneDetective respectively.
Table 5 and Table 6 show that MCIDiff users achieved higher
average scores in refactoring decisions and details and they com-
pleted the tasks faster. Thus, we conclude that MCIDiff group
perform signiÔ¨Åcantly better than CloneDetective group in clone-
related refactoring tasks.
5.2.3 Discussion
Our qualitative analysis of two study groups‚Äô task completion
time, refactoring decisions and refactoring details suggests that task
complete time of CloneDetective group prolongs and quality of
their refactoring decisions and details degrades as the number of
clone instances in a clone set or the complexity of clone instances
increases. In contrast, performance of MCIDiff group remains sta-
ble. Our analysis of task videos and interviews with participants
suggests that this is because MCIDiff ‚Äôs differencing results provide
a consistent and readily available means to investigate differences
across multiple clone instances.
The performance of two study groups on 2-instances clone sets
(i.e., clone sets #1, #2 and #3) were comparable. For those clone
sets, MCIDiff ‚Äôs differencing results have no fundamental differ-
ences from those of CloneDetective . However, for clone sets con-
sisting of multiple clone instances, CloneDetective users start fac-
ing two main challenges.
First, CloneDetective users have to remember which pairs of
clone instances have been analyzed. This is not an easy task be-
cause Nclone instances requires N(N 1)=2pairwise comparison.
For clone sets with four or more clone instances, screen size often
does not allow developers to see all N(N 1)=2Eclipse Java Com-
pare Editors. Some participants tried to split Eclipse editor area
into several regions to accommodate as many Compare Editors as
possible. However, such arrangement often makes each editor too
small to read code effectively. Some participants gave up pairwise
differencing when clone sets have 4 or more clone instances. They
opened cloned code fragments in multiple Eclipse Java Editor side
by side to visually search for differences. Such visual searching
is very demanding for clone sets with complex differences. For171Table 7: Results of T-Tests of Hypotheses, for the variable Refactoring-Decision score, Refactoring-Details Score and Task Comple-
tion Time. Measurements are reported in the following columns: minimum value, maximum value, median, means ( ), variance
(2), Degrees of freedom ( DF), Pearson correlation coefÔ¨Åcient ( PC), statistical signiÔ¨Åcance ( p),Tcrit, and Tstatistics.
H Var Approach Samples Min Max Median  2DF PC T Tcrit p Decision
H0Refactoring
DecisionMCIDiff 9 1.00 2.88 2.25 2.15 0.374 80.935 6.656 2.306 1.6E-4 RejectCloneDetective 9 0.50 2.50 1.75 1.65 0.398 8
Refactoring
DetailsMCIDiff 9 1.38 2.75 2.25 2.08 0.203 80.900 4.720 2.306 0.002 RejectCloneDetective 9 0.88 2.38 2.00 1.68 0.325 8
Completion
TimeMCIDiff 9 1m46s 3m54s 3m18s 2m53s 2203.188 80.698 -3.062 2.306 0.016 RejectCloneDetective 9 2m03s 4m23s 3m27s 3m31s 2518.305 8
example, clone set #7 consists of Ô¨Åve clone instances scattered in
Ô¨Åve methods of three different classes. These Ô¨Åve clone instances
are different in 6 places, each of which contains 2-5 parameterized
and/or gapped differences.
Second, CloneDetective users have to remember which clone
instances are different from other instances, where and how. As
shown in our motivating example, some clone instances may be the
same in one place but different in other places. Furthermore, one
clone instance may have different types of differences against other
clone instances in a speciÔ¨Åc place. Identifying these differences is
challenging, remembering them is even more challenging, because
the amount of information exceeds the capacity of human work-
ing memory [26]. Cognitive studies suggest that human working
memory has a capacity of about 72chunks. However, our sub-
ject clone sets have on average 3.8 differential multisets, each of
which contains 2-6 parameterized and/or gapped differences. Our
video analysis shows that CloneDetective users frequently switch
or revisit code editors. They explained in our post-experiment in-
terviews that they were trying to recall differences across multiple
clone instances. The key challenge lies in the fact that these dif-
ferences are not readily available for use, unless they took note to
keep track of all necessary information.
OurMCIDiff addresses these two challenges in a systematic way.
Differences across multiple clone instances are automatically iden-
tiÔ¨Åed with high accuracy. Differences are then visualized side by
side so that developers can know where clone instances are differ-
ent and how by a quick glance. As such, MCIDiff users spent more
time on further investigating differences and relevant program in-
formation. For example, do parameterized differences share com-
mon syntactic structure? In our motivating example, the four class
PertFactory ,NetFactory ,DrawFigureFactory , and SVGFigureFac-
tory are all subclases of DefaultDOMFactory . Such further inves-
tigation resulted in better refactoring decisions and more speciÔ¨Åc
refactoring details. In contrast, CloneDetective users spent much
more time on identifying and recalling differences, especially when
clone sets consist of multiple clone instances with complex differ-
ences. As such, their refactoring decisions and details were usually
vague and uncertain.
5.3 Runtime Performance of MCIDiff
Our MCIDiff algorithm adopts a progressive alignment strategy
to apply classic LCS algorithm [13] to multiple cloned code frag-
ments. It have time complexity O(MND) where M is the num-
ber of cloned code fragments, N is the sum of the lengths of two
compared token sequences, and D is the number of differences in
clones. LCS algorithm performs well when differences are small
(i.e., sequences are similr). MCIDiff is consequently fast because
it compares cloned code fragments that are similar to each other.
We used our MCIDiff tool to compare all 638 parameterized and
gapped clone sets on a PC with a CoreI7 CPU of 2.7GHz, 4G RAM,
and Windows 7. It took MCIDiff 67 seconds to generate differenc-
ing results of these 638 clone sets. For the largest clone set thatcontains 19 clone instances and 14 LOC on average, MCIDiff took
about 2 seconds to detect differences in this clone set. The differ-
encing result of this clone set consists of 9 differential multisets
(i.e., differential ratio of this clone set is 0.64 (9/14)).
5.4 Threats to Validity
There are mainly three threats in our evaluation. First, we only
studied three small-to-medium sized Java systems. These subject
systems may not contain all representative code clones and clone-
related refactoring tasks. Furthermore, our study involved only a
limited number of developers. Their capabilities and experience
may not be representative. Further studies are required to gener-
alize our Ô¨Åndings in large-scale industrial systems and with more
professional developers.
Second, differences in capabilities of the two groups of partici-
pants may threaten ‚Äúequivalence‚Äù between experimental group and
control group. To address this threat, we had tried our best to allo-
cate participants with comparative capabilities into different groups
based on our pre-study survey and our evaluation of participants‚Äô
capabilities.
Third, grading of eight refactoring tasks cannot be completely
objective because expert opinions may be biased. In the experi-
ment, we asked the two experts to spend as much time as they need
on providing ground-truth answers as well as on grading partici-
pants‚Äô answers. This allows the experts to fully explore the tasks
and answers. To avoid experimenter expectancy effects, we hid
the participants‚Äô group information from the experts. We hope this
helps to reduce subjectiveness to the minimum.
6. APPLICATION
We now discuss three applications (currently under development
in our group) that exploit MCIDiff ‚Äôs differencing results for soft-
ware development and maintenance.
6.1 Auto Generation of Application Skeleton
Framework-based software development becomes increasingly
common and important. Applications built on a framework must
adhere to design structure and coding convention dictated by the
framework. Complex frameworks often support generating appli-
cation skeleton based on predeÔ¨Åned code templates. However, these
predeÔ¨Åned code templates usually generate only bare bones of an
application with little or no real features. Alternatively, frameworks
are often shipped with code examples to demonstrate framework
usage. However, such code examples usually cover only some typ-
ical usage scenarios of the framework.
We are now investigating clone analysis, programming differ-
encing, and data abstraction techniques to transform crowdsourced
code examples of building applications on a speciÔ¨Åc framework
into reusable code templates. Socio-professional medias (e.g., Ecli-
pse Marketplace, github) archives fast-growing body of crowdsour-
ced code examples. The mined code templates will record not
only commonality but also variations across similar code exam-172ples. Code clone detection is used to detect similar code examples.
MCIDiff is used to identify differences across similar code exam-
ples. The differences will be represented as optional or alternative
variation points in code templates. Such code templates can be eas-
ily customized to generate application skeleton with rich features.
As such, application developers can concentrate on the speciÔ¨Åcs of
their applications.
6.2 Simultaneous Code Editing
Code clones must be made explicit so that they can be consis-
tently maintenance and managed. Several approaches [28, 31, 5,
31] have been proposed to support tracking and consistent evolu-
tion of code clones, for example during copy-paste-modify. These
approaches can propagate changes made to one clone instance to
others and thus ensure that common parts of code clones will be
consistently modiÔ¨Åed.
Our work shows that code clones can be different in various way.
A change made to one instance may not be necessary in the other
instance. In our motivating example, PertProject.read() andDraw-
Project.read() calldomi:openElement (:::)anddomi:closeElement (),
while NetProject.read() andSVGProject.read() do not. These gapped
differences represent optional method calls for reading a project
Ô¨Åle. Furthermore, a change in one instance may have to be adapted
when propagating to the other instance. In our motivating example,
suppose the developers declare a new variable of type PertFactory
inPertProject:read(), this change cannot be simply propagated to
the other three read()methods, because the other three methods
should use different factory types NetFactory ,DrawFactory , and
SVGFactory . These parameterized differences represent adaptation
that have to be made during change propagation.
Our results suggest that blindly propagating changes across clone
instances may not work. We are investigating simultaneous editing
support for code clones that can intelligently infer where to propa-
gate the change and how based on MCIDiff ‚Äôs differencing results.
6.3 Revision Control
Although MCIDiff was originally designed for analyzing code
clone differences, it can be applied in other context where several
pieces of similar code need to be compared, for example revision
control. An original piece of source code may be modiÔ¨Åed by sev-
eral developers in parallel. This can result in similar but also dif-
ferent codes. Existing reversion control supports only pairwise dif-
ferencing and merging. Given multiple revisions, developers may
have to perform cascading pairwise differencing and merging. This
cascading process may produce less optimal output because re-
visions are analyzed in pairs without considering other revisions
globally. MCIDiff can be applied to identify the differences across
multiple revisions, based on which multi-way merging of several
revisions can be supported.
7. RELATED WORK
Researchers have proposed many techniques to detect code clones
based on token [1, 16, 17, 25], AST [2, 14], and Program Depen-
dence Graph [8, 11, 20, 23]. Roy and Cordy [29] and Koschke [21]
provide comprehensive surveys of existing clone detection tech-
niques. To support scalable analysis in large systems, clone detec-
tion techniques usually rely on easy-to-compute similarity metrics
to determine similarity between code fragments. Detecting detailed
differences while identifying code clones is computational expen-
sive and thus impractical. Our approach proposes to use clone de-
tectors to identify which parts of the system are similar (i.e. where
clones are) Ô¨Årst, and then use MCIDiff identiÔ¨Åes how these clones
are different efÔ¨Åciently.Researchers proposed clone analysis approaches to aiding the
interpretation and management of software clones. For example,
Genimi [32] uses a scatter plot to visualize code clones detected by
CCFinder [17], it also computes several code metrics of clones to
aid clone analysis. These clone analysis approaches examine only
information of clones, but not differences between code clones.
However, one cannot interpret code clones (i.e. similarities) with-
out understanding their differences precisely [37]. CP-Miner [25]
Ô¨Ånds bugs based on inconsistent identiÔ¨Åers between clones. Kapser
and Godfrey [18] classify code clones through syntactic analysis
of locality of clones. These approaches analyze clone instances
pairwisely, and thus cannot systematically identify and summarize
differences across multiple clone instances.
Program differencing techniques [4, 33, 6, 36, 35] have long
been used in software maintenance tasks. Existing program differ-
encing techniques compare two programs at a time. For example,
Cottrell et al. [4] developed a pairwise differencing technique to
detect correspondences between two pieces of codes for the pur-
pose of generalization. However, simply applying existing pro-
gram differencing techniques to multiple programs will result in
combinatorial explosion of pairwise differencing operations. Our
MCIDiff performs token-based differencing. Structure differencing
algorithms such as [7] may produce more accurate differencing re-
sults, but they are more computational expensive than token-based
differencing. In our work, we favour efÔ¨Åciency rather than marginal
accuracy in the context of differencing code clones.
Techniques for multiple sequence alignments have been studied
in the area of bioinformatics for the purpose of aligning DNA se-
quences [39, 27]. Our MCIDiff is applied to software programs
that have completely different characteristics than DNA sequences.
Furthermore, our approach not only identiÔ¨Åes longest common parts
across multiple clone instances, it also zooms into differential parts
to detect detailed differences across multiple clone instances.
8. CONCLUSION AND FUTURE WORK
In this paper, we have presented MCIDiff , an automatic approach
to detecting differences across multiple clone instances. Our eval-
uation has shown that the accuracy of MCIDiff is good in practice
and it is robust to analyze different types of code clones. Our user
study has demonstrated the usefulness of MCIDiff ‚Äôs differencing
results for clone-related refactoring tasks.
MCIDiff is a key component in our clone analysis framework
that aims to enable practical use of code clones in software mainte-
nance by summarizing syntactic, semantic and differential patterns
in code clones. Within this framework, MCIDiff automatically
builds a detailed and accurate report of differences across multi-
ple instances of code clones. This open up many opportunities for
practical applications of code clones in software maintenance, such
as code-generation, simultaneous code editing, revision control.
9. ACKNOWLEDGEMENT
This work is supported by National High Technology Develop-
ment 863 Program of China under Grant No.2012AA011202, Na-
tional Natural Science Foundation of China under Grant
No.61370079 and NTU Startup Grant M4081029.020.500000.
10. REFERENCES
[1] H. A. Basit and S. Jarzabek. EfÔ¨Åcient token based clone
detection with Ô¨Çexible tokenization. In ESEC/SIGSOFT FSE ,
pages 513‚Äì516, 2007.173[2] I. D. Baxter, A. Yahin, L. M. de Moura, M. Sant‚ÄôAnna, and
L. Bier. Clone detection using abstract syntax trees. In ICSM ,
pages 368‚Äì377, 1998.
[3] S. Bellon, R. Koschke, G. Antoniol, J. Krinke, and E. Merlo.
Comparison and evaluation of clone detection tools. IEEE
Trans. Software Eng. , 33(9):577‚Äì591, 2007.
[4] R. Cottrell, J. J. C. Chang, R. J. Walker, and J. Denzinger.
Determining detailed structural correspondence for
generalization tasks. In ESEC-FSE ‚Äô07 , pages 165‚Äì174,
2007.
[5] E. D. Ekoko and M. P. Robillard. Clonetracker: tool support
for code clone management. In ICSE‚Äô08 , pages 843‚Äì846,
2008.
[6] B. Fluri, M. W√ºrsch, M. Pinzger, and H. Gall. Change
distilling: Tree differencing for Ô¨Åne-grained source code
change extraction. IEEE Trans. Software Eng. ,
33(11):725‚Äì743, 2007.
[7] B. Fluri, M. Wursch, M. Pinzger, and H. Gall. Change
distilling:tree differencing for Ô¨Åne-grained source code
change extraction. TSE‚Äô07 , 33(11):725‚Äì743, 2007.
[8] M. Gabel, L. Jiang, and Z. Su. Scalable detection of semantic
clones. In ICSE , pages 321‚Äì330, 2008.
[9] J. Gosling, B. Joy, G. Steele, G. Bracha, and A. Buckley. The
Java Language SpeciÔ¨Åcation: Java Se 7 Ed . Java Series.
Prentice Hall PTR, 2013.
[10] D. G. Higgins and P. M. Sharp. CLUSTAL: a package for
performing multiple sequence alignment on a
microcomputer. Gene , 73(1):237‚Äì244, 1988.
[11] Y . Higo and S. Kusumoto. Enhancing quality of code clone
detection with program dependency graph. In WCRE , pages
315‚Äì316, 2009.
[12] Y . Higo, Y . Ueda, S. Kusumoto, and K. Inoue. Simultaneous
modiÔ¨Åcation support based on code clone analysis. In
APSEC ‚Äô07 , pages 262‚Äì269, 2007.
[13] D. S. Hirschberg. A linear space algorithm for computing
maximal common subsequences. Commun. ACM ,
18(6):341‚Äì343.
[14] L. Jiang, G. Misherghi, Z. Su, and S. Glondu. Deckard:
Scalable and accurate tree-based detection of code clones. In
ICSE , pages 96‚Äì105, 2007.
[15] L. Jiang, Z. Su, and E. Chiu. Context-based detection of
clone-related bugs. In ESEC-FSE ‚Äô07 , pages 55‚Äì64, 2007.
[16] E. J√ºrgens, F. Deissenboeck, B. Hummel, and S. Wagner. Do
code clones matter? In ICSE , pages 485‚Äì495, 2009.
[17] T. Kamiya, S. Kusumoto, and K. Inoue. CcÔ¨Ånder: A
multilinguistic token-based code clone detection system for
large scale source code. IEEE Trans. Software Eng. ,
28(7):654‚Äì670, 2002.
[18] C. Kapser and M. W. Godfrey. Aiding comprehension of
cloning through categorization. In IWPSE , pages 85‚Äì94,
2004.
[19] R. Komondoor and S. Horwitz. Using slicing to identify
duplication in source code. In In Proceedings of the 8th
International Symposium on Static Analysis , pages 40‚Äì56,
2001.[20] R. Komondoor and S. Horwitz. Using slicing to identify
duplication in source code. In SAS, pages 40‚Äì56, 2001.
[21] R. Koschke. Survey of research on software clones. In
Duplication, Redundancy, and Similarity in Software .
[22] J. Krinke. Identifying similar code with program dependence
graphs. In WCRE‚Äô01 , pages 301‚Äì310, 2001.
[23] J. Krinke. Identifying similar code with program dependence
graphs. In WCRE , pages 301‚Äì309, 2001.
[24] J. Krinke. A study of consistent and inconsistent changes to
code clones. In WCRE ‚Äô07 , pages 170‚Äì178, 2007.
[25] Z. Li, S. Lu, S. Myagmar, and Y . Zhou. Cp-miner: Finding
copy-paste and related bugs in large-scale software code.
IEEE Trans. Software Eng. , 32(3):176‚Äì192, 2006.
[26] G. A. Miller. The magical number seven, plus or minus two:
Some limits on our capacity for processing information.
Psychological Review , 63(2):81‚Äì97, 1956.
[27] L. A. Newberg. SigniÔ¨Åcance of gapped sequence alignments.
J. Comput Biol. , 15(9):1187‚Äì1194, 2008.
[28] H. A. Nguyen, T. T. Nguyen, N. H. Pham, J. Al-Kofahi, and
T. N. Nguyen. Clone management for evolving software.
TSE, 38(5):1008‚Äì1026, 2012.
[29] C. K. Roy and J. R. Cordy. A survey on software clone
detection research. Queen‚Äôs Technical Report:541 , pages
0‚Äì115, 2007.
[30] S. S. Shapiro and M. B. Wilk. An analysis of variance test
for normality (complete samples). Biometrika ,
52(3/4):591‚Äì611, Dec. 1965.
[31] M. Toomim, A. Begel, and S. L. Graham. Managing
duplicated code with linked editing. In VLHCC ‚Äô04 , pages
173‚Äì180, 2004.
[32] Y . Ueda, T. Kamiya, S. Kusumoto, and K. Inoue. Gemini:
Maintenance support environment based on code clone
analysis. In IEEE METRICS , pages 67‚Äì76, 2002.
[33] R. A. Wagner and M. J. Fischer. The string-to-string
correction problem. J. ACM , 21(1):168‚Äì173, 1974.
[34] L. Wang and T. Jiang. On the complexity of multiple
sequence alignment. Journal of Computational Biology ,
1(4):337‚Äì348, 1994.
[35] Z. Xing. Model comparison with genericdiff. In ASE, pages
135‚Äì138, 2010.
[36] Z. Xing and E. Stroulia. Differencing logical uml models.
Autom. Softw. Eng. , 14(2):215‚Äì259, 2007.
[37] Z. Xing, Y . Xue, and S. Jarzabek. Clonedifferentiator:
Analyzing clones by differentiation. In ASE, pages 576‚Äì579,
2011.
[38] G. Zhang, X. Peng, Z. Xing, and W. Zhao. Cloning practices:
Why developers clone and what can be changed. In
ICSM‚Äô12 , pages 285‚Äì294, 2012.
[39] Z. Zhang, S. Schwartz, L. Wagner, and W. Miller. A greedy
algorithm for aligning dna sequences. IEEE Trans. Software
Eng., 7(1):203‚Äì214, 2000.
[40] M. F. Zibran and C. K. Roy. Towards Ô¨Çexible code clone
detection, management, and refactoring in ide. In IWSC ‚Äô11 ,
pages 75‚Äì76, 2011.174