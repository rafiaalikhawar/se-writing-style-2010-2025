Inference of Ô¨Åeld initialization
Technical Report UW-CSE-10-02-01
University of Washington Department of Computer Science & Engineering
February 6, 2010
Fausto Spoto
Dipartimento di Informatica
Universit√† di Verona, Italy
fausto.spoto@univr.itMichael D. Ernst
Computer Science & Engineering
University of Washington, USA
mernst@uw.edu
Abstract
Araw object is partially initialized, with only some of its Ô¨Åelds
set to legal values. A raw object may violate its object invariants,
such as that a given Ô¨Åeld is non- null . Programs often need to
manipulate partially-initialized objects, but they must do so with
care. Furthermore, analyses must be aware of rawness. For in-
stance, software veriÔ¨Åcation cannot depend on object invariants for
raw objects.
We present a static analysis that infers a safe over-approximation
of the program variables, Ô¨Åelds, or array elements that, at run-
time, might hold non-fully initialized objects. Our formalization
is Ô¨Çow-sensitive and considers the exception Ô¨Çow in the analyzed
programs. We have proved the analysis to be sound.
We have also implemented our analysis, in a tool called JULIA
that computes both nullness and rawness information. We have
evaluated JULIA on over 50K lines of code. We have compared its
output to manually-written nullness and rawness information, and
to an independently-written type-checking tool that checks nullness
and rawness. J ULIA ‚Äôs output is accurate and, we believe, useful
both to programmers and to static analyses.
1. Introduction
Object-oriented programming languages, such as Java, allow the
deÔ¨Ånition of instance variables orÔ¨Åelds , that hold the state of the
objects. Those Ô¨Åelds are normally (but not necessarily) initialized
inside the constructors deÔ¨Åned in their class. Before that initializa-
tion, in Java, they hold the default value for their static type. For
Ô¨Åelds of reference type, the default value is null .
Many type-checking systems and static veriÔ¨Åcation tools aim to
prove that some object invariant ,inv, holds for the objects of a
given class. This means that invmust be true immediately after
the object construction and must remain true every time a (public)
method is entered or exited. A typical object invariant states that
some Ô¨Åeld fis non- null . This means that all constructors must ini-
tialize fto a non- null value and that fwill never be reset to null
later. This is an important piece of information, since it guarantees
that no dereference of fwill ever throw a NullPointerException .
This conclusion is nottrueinside the constructors. Before fis ini-
tialized, it still holds the default value null . Our work focuses
on initialization properties, rather than all ways any invariant can
be violated, such as by setting a value to a non- null value that is
inconsistent with its formal speciÔ¨Åcation.
Since, in general, object invariants do not hold for partially-
initialized (‚Äúraw‚Äù [9]) objects, it is important to identify those sites
‚Äî program Ô¨Åelds, parameters, return values, or array elements ‚Äî
that might hold a raw object at run-time. These sites are not just the
this variable inside the constructors: that variable can be passed
to methods and stored in Ô¨Åelds or arrays. Moreover, a raw variable... // many non-null fields defined here
public OptionsDialog(Frame owner) {
super(owner, "Options");
// initializes a non-null field
this.owner = owner;
// initializes the remaining non-null fields
setup();
// ‚Äôthis‚Äô is non-raw here
pack();
...
}
Figure 1: A snippet of code from the JFlex program.
loses its rawness as soon as all its Ô¨Åelds have been initialized (or
some relevant subset of its Ô¨Åelds, see Section 5.4). Hence this
might be non-raw inside a constructor, from a given program point
onwards.
Figure 1 contains a snippet of code from class OptionsDialog
of the JFlex scanner generator, one of the applications that we ana-
lyze in Section 6. Method setup() is called by the constructor of
class OptionsDialog to help it build the object: this helper method
initializes most of the Ô¨Åelds of the object.
The JULIA tool performs our rawness analysis and infers that
the receiver of setup() is raw, and all other references are non-
raw, such as the receiver of pack() . Furthermore, JULIA infers
that many Ô¨Åelds are non- null . Without an inference of object ini-
tialization, a tool would either be unsound, or would be forced to
conclude that all Ô¨Åelds are possibly null . JULIA warns about any
possibly-erroneous dereference; these include possibly- null Ô¨Åelds
wherever used in the program (unless the Ô¨Åeld can be proved to be
non-null at that point), and non- null Ô¨Åelds when used before the
object is adequately initialized.
In principle, it would be correct to annotate all receivers, Ô¨Åelds,
parameters, and return values as @Raw : that would be a sound over-
approximation of the set of raw sites. However, this would not
be useful, and would hobble follow-on analyses [20] and human
understanding. We aim for a precise analysis that infers as few
rawness annotations as possible, only where needed.
We have extended the JULIA tool [16], which already contains
a highly precise nullness analysis [22], to implement our rawness
analysis. J ULIA infers precise nullness and rawness annotations
for non-trivial software, automatically, in a few minutes. We have
also integrated JULIA with toolsets for working with annotations
and pluggable type systems [2, 4]. This enables us to compare
our rawness analysis with pluggable type-checking for a nullness
and rawness type system. The type system is weaker, but compo-
sitional and with easier-to-understand results. J ULIA ‚Äôs results are
correct by construction (the analyses in the JULIA tool are formally
correct), but the type-checker still issues some warnings while type-
1checking them, because of the different perspective of the two tools.
JULIA is based on Ô¨Çow and context-sensitive static analyses and
abstract interpretation, while the checker framework is based on
type-checking, augmented by Ô¨Çow-sensitivity and some other en-
hancements [20]. Nevertheless, we have achieved a good degree of
integration of the two tools and Section 6 discusses the remaining
differences and evaluates the quality of the automatic annotation
w.r.t. that of a previous manual annotation that has been veriÔ¨Åed by
type-checking.
Our work is relevant beyond the scope of nullness analysis. Our
rawness analysis is not coupled to nullness analysis and is com-
puted independently. It can be used in other contexts, whenever
it is necessary to prove that some Ô¨Åelds are deÔ¨Ånitely initialized
at some program points. Moreover, the constraint-based analysis
of Java bytecode in Section 5, and the structure of the correctness
proof in Appendix A, can be used for other properties than rawness.
Namely, JULIA embeds a constraint-based analysis, following the
same scheme, that determines when arrays and collection classes
arefull, that is, contain non- null elements only (see Section 3).
This paper makes the following contributions:
It deÔ¨Ånes and proves correct a rawness analysis for Java byte-
code that is completely independent from any other analysis
(such as nullness).
It provides deÔ¨Ånitions and proofs that explicitly consider the
exceptional Ô¨Çows in the program.
We have implemented our rawness analysis, demonstrating its
practicality. We have also integrated it with other nullness and
rawness tools, permitting comparisons and increasing conÔ¨Å-
dence in both toolsets.
Experiments with our implementation demonstrate its preci-
sion. The experiments also yield insight into the algorithm‚Äôs
strengths and weaknesses and the properties of real code.
To the best of our knowledge, the Ô¨Årst two points above are novel.
For example, N IT‚Äôs rawness inference is coupled to nullness and
its theory does not consider exceptional Ô¨Çows [15]. Being inde-
pendent from nullness analysis simpliÔ¨Åes the formalization and the
proof of correctness, and permits applicability to other problem do-
mains. The last point above has never been investigated before. For
example, N ITdoes not dump the rawness information that it com-
putes, so its evaluation and its use for type-checking is impossible.
See Section 2 for more comparisons with related work.
The rest of the paper is organized as follows. Section 2 overviews
the most closely-related work. Section 3 reviews the nullness anal-
ysis implemented by the JULIA tool. Section 4 presents an opera-
tional semantics for Java bytecode, which is the concrete semantics
of our abstract interpretation for rawness. Section 5 deÔ¨Ånes this
constraint-based abstract interpretation. Section 6 reports on our
experiments: we compared JULIA ‚Äôs output to manual annotations
and to an independently-implemented type-checker. The proof of
correctness is found in Appendix A. The JULIA tool is available for
use through its web interface: http://julia.scienze.univr.
it.
2. Related work
F√§hndrich and Leino [9] check object initialization using a type
qualiÔ¨Åer (called ‚Äúraw‚Äù) that indicates how many Ô¨Åelds are initial-
ized. On exiting a constructor, the type is non-raw for that class
and all of its superclasses, but still raw for any subtypes whose con-
structor has not yet been exited. In a raw type, all Ô¨Åelds declared
in that type are assumed to be possibly null , and the type checker
enforces that these not-yet-initialized Ô¨Åelds are not used. The null-
ness and rawness type-checker that we used in our experiments is a
re-implementation of this algorithm, with enhancements. Delayedtypes [10] specify when Ô¨Åelds can be assumed to have been initial-
ized; by contrast, rawness speciÔ¨Åes where Ô¨Åelds can be assumed to
have been initialized.
The most closely related work is N ITand J ASTADD. N IT[15]
is a nullness inference tool that, in parallel, also infers rawness.
Unlike our work, their formalization and proofs do not consider
exceptional Ô¨Çows. The N ITtool does not output any of the rawness
annotations that it infers. J ASTADD[6] infers nullness along with a
coarser variant of rawness, in which each object is fully initialized
or fully uninitialized, without reference to how many constructors
have been exited. The rawness analysis of J ASTADDis informally
presented and is not proved correct. Rawness increased the percent-
age of references that J ASTADDreports as safe from 69% to 71%,
for three packages in the JDK. In our experiments, JULIA reported
over 98% of references to be safe. Like JULIA , NITand J ASTADD
can produce an annotation Ô¨Åle that can be inserted into Java source
code or class Ô¨Åles [2]. J ACK [19] requires annotated method signa-
tures, then does a Ô¨Çow-sensitive, alias-sensitive Ô¨Çow analysis to de-
termine nullness and rawness types for local variables. It operates
on bytecode. Like J ASTADD, it infers the coarse version of raw-
ness. Unlike JULIA , none of these tools‚Äô rawness analysis seems to
have been evaluated and compared to manually-identiÔ¨Åed correct
annotations.
Several other nullness inference tools for Java exist, but unlike
JULIA they do not infer rawness annotations. D AIKON [8] runs the
program and soundly outputs @Nullable for variables that were
ever observed to be null . It would be unsound to report @NonNull
for values that were never observed to be null . DAIKON can pro-
duce an annotation Ô¨Åle. H OUDINI [11] inserts @NonNull at every
possible location, then runs a static checker. Whenever the static
checker issues a warning, H OUDINI removes the relevant annota-
tion. H OUDINI iterates this process until it reaches a Ô¨Åxed point.
HOUDINI is neither sound nor complete. I NAPA [7] is based on
similar principles to H OUDINI . F INDBUGS [14, 13] Ô¨Ånds null
pointer dereferences by using an imprecise analysis that produces
many false warnings, but then prioritizing and Ô¨Åltering aggressively
so that few false warnings are reported to a user. It attempts to in-
fer programmer intent ( w.r.t. nullness) based on code patterns. It is
neither sound nor complete.
Our rawness analysis is a constraint-based abstract interpreta-
tion [5] of a concrete operational semantics for Java bytecode, pre-
sented in Section 4. Other operational semantics for Java bytecode
are available, such as that of Freund and Mitchell [12]. Here we fol-
low our formalization in [21], which is also the basis of the JULIA
analyser [16], and hence we match theory with implementation.
Our formalization is indebted to [17], where Java and Java byte-
code are mathematically formalized and the compilation of Java
into bytecode and its type-safeness are machine-proved. Our for-
malization of the state of the JVM (DeÔ¨Ånition 2 in Section 4.2) is
similar to theirs, as well as our formalization of heap and objects.
3. Nullness Inference
The deÔ¨Ånition of our rawness analysis does not use any previous
nullness analysis. Nevertheless, we use it here after a nullness anal-
ysis is performed to project its results (sets of initialized Ô¨Åelds) over
those Ô¨Åelds that are deemed non- null by the nullness analysis, in
order to infer rawness annotations that are useful for nullness type-
checking (see Subsection 5.4). The exact nullness analysis which
is used is not important here. We brieÔ¨Çy describe the one imple-
mented in the JULIA analysis tool.
In order to achieve a very high level of precision for nullness
analysis, JULIA uses a mix of different techniques: static analyses
based on denotational abstract interpretation and constraint-based
2abstract interpretation. Both come in different Ô¨Çavors, for inferring
properties of the local variables, Ô¨Åelds, arrays of references, and
collections.
The kernel of the nullness analysis of JULIA is a denotational,
bottom-up abstract interpretation of the bytecode, which builds log-
ical formulas whose models over-approximate the nullness behav-
iors of the variables in scope in a piece of code. This analysis has
been proved correct [25]. Since the number of variables, at a given
program point, is necessarily Ô¨Ånite, the Boolean formulas are Ô¨Ånite
and relatively small, so they can be efÔ¨Åciently represented by bi-
nary decision diagrams [3]. The drawback of this approach is that
it infers nothing about the nullness of the Ô¨Åelds of the objects. Its
precision is consequently unsatisfactory.
We now list three improvements, each of which increases pre-
cision but increases the computational cost. The overall system
achieves high precision (see our results, presented in Section 6).
A separate paper [22] presents all these techniques in detail and
compares them w.r.t. precision and cost of the resulting nullness
analyses.
(1) An optimistic approach [25] considers a Ô¨Åeld f, initialised
by all constructors, to hold a non- null value ( globally non- null )
unless a counter-example is found, that is, an assignment of a pos-
sibly null value to f. The resulting precision is slightly better than
that of N IT[15], although it is in general slower.
(2)Local non-nullness [23] recognizes Ô¨Åelds that are deÔ¨Ånitely
non-null at speciÔ¨Åc program points, because they have just been
assigned a non- null value or have been checked for non-nullness.
Local non-nullness achieves a form of Ô¨Çow-sensitivity. The analy-
sis is implemented as a denotational bottom-up abstract interpreta-
tion of the code.
(3) A constraint-based static analysis uses the same technique
that we describe in Section 5, to identify fullarrays and collection
objects (hashsets, hashmaps, linked lists, etc.), whose elements are
all non- null at some program points.
The output of a nullness analysis indicates, for every variable and
every program point (where the variable is in scope), whether the
variable may be null or is deÔ¨Ånitely non- null . This output can be
used by a lint-like bug detection tool that informs the user of places
where the null value might be dereferenced. (Most of the warn-
ings will be false alarms, but a few might be actual bugs.) The tool
output can also be inserted in the program for documentation and
debugging, or can be exported to another tool to aid in further anal-
ysis. J ULIA can produce null -dereference warnings directly, and
can output nullness annotations to program source or other tools by
using the Annotation File Utilities [2].
4. Operational Semantics
We describe here an operational semantics of the Java bytecode,
that we abstract into our rawness analysis in Section 5 and prove
correct in Appendix A.
4.1 Syntax
For simplicity of presentation, our formalism assumes intto be
the only primitive type and classes to be the only reference types;
we only allow instance Ô¨Åelds and methods. Our implementation
handles full sequential Java bytecode and all Java types. In particu-
lar, multithreading is not handled and the analysis of multithreaded
applications might yield incorrect results, because JULIA assumes
that immediately after a Ô¨Åeld is checked, it still has the same value.
We assume the Java bytecode is preprocessed into a control Ô¨Çow
graph. This same representation is used in [21, 25, 24]; a similar
representation is also chosen in [1], although, there, Prolog clauses
encode the graph, while we work directly on the graph itself. A
load¬†0¬†JFlex.gui.Options Dialog@p0
load¬†1¬†java.awt.Frame@ p1
const¬†"Options"@p2
call¬†java.awt.Dialog.<ini t>(java.awt.Frame,java. lang.String):void@p3
catch@p4
throw¬†java.lang.Throwab le@p5load¬†0¬†JFlex.gui.Options Dialog@p6
load¬†1¬†java.awt.Frame@ p7
putfield¬†JFlex.gui.Option sDialog.owner:java.awt. Frame@p8
load¬†0¬†JFlex.gui.Options Dialog@p9
call¬†JFlex.gui.OptionsDi alog.setup():void@p10
load¬†0¬†JFlex.gui.Options Dialog@p11
call¬†java.awt.Window.pa ck():void@p12
.....Figure 2: The blocks of code for the constructor in Figure 1.
control Ô¨Çow graph is a directed graph of basic blocks . All jumps
are from the end of one basic block, to the beginning of another
basic block. We graphically write
ins@p
rest!!b1bm
for a block of code starting with a bytecode instruction ins at
program point p, possibly followed by more bytecodes restand
linked to msubsequent blocks b1;:::; bm. For instance, load 1
java:awt:Frame @p1stands for an instance of the bytecode load 1
java:awt:Frame (which loads on the stack an object of class java.
awt.Frame ) occurring at program point p1. In most cases, the pro-
gram point pis irrelevant, so we write just ins. Bytecodes have
explicit, inferred types.
Exception handlers start with a catch bytecode. A conditional
bytecode, a virtual method call, or the selection of an exception
handler, on the basis of the run-time type of the receiver or excep-
tion, is translated into a block linked to many subsequent blocks.
Each subsequent block starts with a Ô¨Åltering bytecode, such as
exception _is[_not] in the case of exceptional handlers, that spec-
iÔ¨Åes when that continuation is taken. They are not needed in Fig-
ure 1 since a default handler is used there: anykind of exception is
caught and thrown back to the caller.
4.2 Semantics
Our operational semantics keeps a state , providing values for the
variables of the program. An activation stack of states is used to
model the method call mechanism, exactly as in an actual imple-
mentation of the JVM.
DeÔ¨Ånition 1. (Classes) The set of classes Kin program Pis par-
tially ordered w.r.t., which expresses the subclass relationship. A
type is an element of T=K[fintg. A class k2Khasinstance
Ô¨Åelds k:f:t(Ô¨Åeld fof type t2TdeÔ¨Åned in class k), where kandt
are often omitted, and instance methods k:m(~t):t(method mwith
arguments of type ~tT, returning a value of type t2T[fvoidg,
deÔ¨Åned in class k), where k,~t, and tare often omitted. Constructors
are seen as methods named init and returninghvoidi.
Astate provides values to program variables.
DeÔ¨Ånition 2. (State) A value is an element of Z[L[fnullg,
whereLis an inÔ¨Ånite set of memory locations . Astate is a triple
hljjsjj¬µiwhere lis an array of values (the local variables ),sa stack
3of values (the operand stack ) which grows leftwards, and ¬µamem-
ory, orheap , which binds locations to objects . The empty stack is
written e. An object obelongs to class o:k2K(is an instance of
o:k) and maps identiÔ¨Åers (the Ô¨Åelds fof class o:kand of its super-
classes) into o:f, which can be a value or uninit . The set of states
isX. We write Xi;jwhen we want to Ô¨Åx the number iof local vari-
ables and jof stack elements. If vis a value or uninit , we say that
v has type t in a statehljjsjj¬µiifv2Z[funinitgandt=int, or
v2fnull;uninitgandt2K, orv2L,t2Kand¬µ(v):kt.
Compared to [21], DeÔ¨Ånition 2 allows Ô¨Åelds to hold uninit . As
will be clear from the formal semantics, this value is a special case
ofnull or 0 that allows us to distinguish a Ô¨Åeld holding null or 0
because it has not been initialized yet, from a Ô¨Åeld already initial-
ized, possibly to null or 0.
Example 1. A possible state at the beginning of the construc-
tor in Figure 2 is s=h[`;`0]jjejj¬µi, where ¬µ(`)(owner ) =uninit .
Location `contains the receiver ¬µ (`)of the constructor , i.e.,this ,
whose Ô¨Åelds are not initialized at the beginning of the construc-
tor. Location `0contains an object of class java.awt.Frame , the
explicit argument of the constructor.
The JVM supports exceptions. Hence we distinguish normal
states Xarising during the normal execution of a piece of code,
from exceptional states Xarising just after a bytecode that throws
an exception. States in Xhave always a stack of height 1 containing
a location (bound to the thrown exception object). We write them
underlined in order to distinguish them from the normal states.
DeÔ¨Ånition 3. (JVM State) The set of JVM states (from now on
juststates ) with ilocal variables and jstack elements is Si;j=
Xi;j[Xi;1.
When we denote a state by s, we do not specify if it is normal or
exceptional. If we want to stress that we deal with a normal or with
an exceptional state, then we write hljjsjj¬µiin the Ô¨Årst case and
hljjsjj¬µiin the second.
Example 2. A state sat the beginning of the block in Figure 2
containing catch @p4might be an exceptional state arising when
the call setup() aborts because of an OutOfMemoryError (the
code of that method contains many newstatements). In that case,
we would have s=h[`;`0]jj`00jj¬µ0i, where `and`0are as in Exam-
ple 1, ¬µ0(`)(owner ) =`0002L(Ô¨Åeld owner ofthis has been already
initialized at that point), ¬µ(`00):k=OutOfMemoryError and¬µ(`00)
has no uninit Ô¨Åelds.
The semantics of a bytecode ins@pis a partial map ins:Si1;j1!
Si2;j2from an initial to aÔ¨Ånal state. The indices i1;j1;i2;j2depend
onp. The number and type of local variables and stack elements
at each pare statically known [18]. In the following we silently
assume that the bytecodes are run in a program point with ilocal
variables and jstack elements and that the semantics of the byte-
codes is undeÔ¨Åned for input states of wrong sizes or types. These
assumptions are required by [18] and must hold for legal Java byte-
code.
4.3 Basic instructions
Bytecode const vpushes v2Z[L[fnullgon the stack. When
v2L, location vmust be already allocated in the memory and hold
an object of a very restricted set of classes, with all Ô¨Åelds already
initialized [18]. Formally, the semantics of this bytecode is
const v =lhljjsjj¬µi:8
>>><
>>>:hljjv::sjj¬µiifv62Lor
(¬µ(v)is deÔ¨Åned and has
nouninit Ô¨Åeld)
undeÔ¨Åned otherwise.Thel-notation deÔ¨Ånes a partial map, because of the undeÔ¨Åned case.
Namely, this bytecode is undeÔ¨Åned when it tries to push a location
which is not already in memory or has an uninitialized Ô¨Åeld. Since,
above,hljjsjj¬µi(where smight be e) is not underlined, the map is
also undeÔ¨Åned on exceptional states , i.e., the bytecode is executed
when the JVM is not in an exceptional state. This is the case for all
bytecodes but catch , which starts the exceptional handlers from
an exceptional state.
Bytecode duptduplicates the top of the stack, of type t:
dup t =lhljjtop::sjj¬µi:hljjtop::top::sjj¬µi:
Bytecode load i tpushes on the stack the value of local variable
number i, which must exist and have type t:
load i t =lhljjsjj¬µi:hljjl[i]::sjj¬µi:
Conversely, bytecode store i tpops the top of the stack of type t
and writes it in local variable i:
store i t =lhljjtop::sjj¬µi:hl[i7!top]jjsjj¬µi:
Iflcontains less than i+1 variables, the resulting set of local vari-
ables gets expanded. The semantics of a conditional bytecode is
undeÔ¨Åned when its condition is false. For instance, if_netchecks
if the top of the stack, which must have type t, is not 0 when t=int
or is not null otherwise:
if_ne t=lhljjtop::sjj¬µi:(
hljjsjj¬µi iftop6=0 and top6=null ,
undeÔ¨Åned otherwise.
TheundeÔ¨Åned case corresponds to the fact that the JVM does not
continue the execution of the code if the condition is false. Note
that, in our formalization, conditional bytecodes are used in com-
plementary pairs (for instance, if_neandif_eq), at the beginning
of the two branches of a condition, so that only one of them is de-
Ô¨Åned for each given state.
4.4 Object-manipulating instructions
Some bytecodes create or access objects in memory. Bytecode
newkpushes on the stack a reference to a new object oof class
k, with reference Ô¨Åelds initialized to uninit , that is, o(k0:f) =
uninit for every Ô¨Åeld k0:f:twith t2Kandkk0. Its semantics,
newk, is
lhljjsjj¬µi:(
hljj`::sjj¬µ[`7!o]iif there is enough memory,
hljj`jj¬µ[`7!oome]iotherwise
with`2Lfresh and oome new instance of OutOfMemoryError .
This is the Ô¨Årst example of a bytecode that can throw an exception.
Note that the initial value of the Ô¨Åelds is Ô¨Åxed to uninit rather than
tonull or 0, as it would be in a standard semantics [21].
The semantics getÔ¨Åeld k:f:tof bytecode getfield k:f:treads
the Ô¨Åeld k:f:tof a receiver object recpopped from the stack, of
typek. Itinterprets uninit asnull or 0 before pushing it on the
stack, since the value uninit is not allowed on the stack (DeÔ¨Åni-
tion 2). Hence getÔ¨Åeld k:f:tis deÔ¨Åned as
lhljjrec::sjj¬µi:8
>>>>>>><
>>>>>>>:hljj¬µ(rec):f::sjj¬µiifrec6=null ,¬µ(rec):f6=uninit
hljjnull ::sjj¬µi ifrec6=null ,¬µ(rec):f=uninit
t2K
hljj0 ::sjj¬µi ifrec6=null ,¬µ(rec):f=uninit
t=int
hljj`jj¬µ[`7!npe]iotherwise
with`2Lfresh and npea new instance of NullPointerException .
The bytecode putfield k:f:twrites the top of the stack, of type t,
4inside Ô¨Åeld k:f:tof the object pointed to by a value recbelow the
top of the stack, of type k(`andnpeare as before). Its semantics
putÔ¨Åeld k:f:tis
lhljjtop::rec::sjj¬µi:(
hljjsjj¬µ[¬µ(rec):f7!top]iifrec6=null ,
hljj`jj¬µ[`7!npe]i otherwise.
Note that this bytecode might only remove uninit from the ap-
proximation of Ô¨Åeld f, since the value topon the stack is not al-
lowed to be uninit (DeÔ¨Ånition 2).
4.5 Exception-handling instructions
Bytecode throw kthrows, explicitly, the object pointed by the
top of the stack, of type kThrowable (`andnpeare as before):
throw k=lhljjtop::sjj¬µi:(
hljjtopjj¬µi iftop6=null ,
hljj`jj¬µ[`7!npe]iiftop=null .
Bytecode catch starts an exception handler. It takes an exceptional
state and transforms it into a normal state, subsequently used by the
handler:
catch =lhljjtopjj¬µi:hljjtopjj¬µi
where top2Lhas type Throwable . Note that catch is undeÔ¨Åned
on all normal states. After catch , bytecode exception _isKse-
lects the appropriate exception handler on the basis of the run-time
class of top. Namely, it Ô¨Ålters those states whose top of the stack is
an instance of a class in KK. Its semantics exception _is K is
lhljjtopjj¬µi:(
hljjtopjj¬µiiftop2Land¬µ(top):k2K,
undeÔ¨Åned otherwise.
Bytecode exception _is_notKis just a shortcut for the bytecode
exception _isH, where His the set of exception classes that are
not an instance of some class in K.
4.6 Method calls and return
When a caller transfers the control to a callee k:m(~t):t, the
JVM performs an operation makescope k:m(~t):twhich copies the
topmost stack elements into the corresponding local variables and
clears the stack.
DeÔ¨Ånition 4. Letk:m(~t):tbe a method or constructor and pbe
the number of stack elements needed to hold its actual parameters,
including the implicit parameter this . We deÔ¨Åne (makescope k:m(~t):
t):S!Sas
lhljjvp 1::::v1::rec::sjj¬µi:h[rec;v1;:::; vp 1]jjejj¬µi
provided rec6=null and the look-up of m(~t):tfrom the class
¬µ(rec):kleads to k:m(~t):t. We let it be undeÔ¨Åned otherwise.
This formalizes the fact that the ith local variable of the callee is a
copy of the element located (p 1) ipositions down the top of
the stack of the caller.
Bytecode return tterminates a method and clears its operand
stack. If t6=void , the return value is the only element left on the
Ô¨Ånal stack:
return void =lhljjsjj¬µi:hljjejj¬µi
return t =lhljjtop::sjj¬µi:hljjtopjj¬µi;where t6=void .insis not a call ,ins(s)is deÔ¨Åned
hins
rest!!b1bmjjsi::a)h rest!!b1bmjjins(s)i::a(1)
pis the number of parameters of the target method, including this
s=hljjvp 1::::v1::rec::sjj¬µi;rec6=null
1in;s0= (makescope ki:m)(s)is deÔ¨Åned
f=Ô¨Årst(ki:m)
hcall k1:m:::kn:m
rest!!b1bmjjsi::a)hfjjs0i::hrest!!b1bmjjhljjsjj¬µii::a
(2)
pis the number of parameters of the target method, including this
s=hljjvp 1::::v1::null ::sjj¬µi
`2Lis fresh and npeis a new instance of NullPointerException
hcall k1:m:::kn:m
rest!!b1bmjjsi::a)h rest!!b1bmjjhljj`jj¬µ[`7!npe]ii::a
(3)
hjjhljjtopjj¬µii::hbjjhl0jjs0jj¬µ0ii::a)hbjjhl0jjtop::s0jj¬µii::a(4)
hjjhljjejj¬µii::hbjjhl0jjs0jj¬µ0ii::a)hbjjhl0jjejj¬µii::a(5)
1im
h!!b1bmjjsi::a)hbijjsi::a(6)
Figure 3: The transition rules of our operational semantics for Java bytecode
(Section 4.7).
4.7 The transition rules
We can now deÔ¨Åne the operational semantics of our language.
DeÔ¨Ånition 5. AconÔ¨Åguration is a pairhbjjsiof a block band a
states. It represents the fact that the JVM is going to execute bin
states. An activation stack is a stack c1::c2::::cnof conÔ¨Ågura-
tions, where c1is the topmost, current oractive conÔ¨Åguration.
The operational semantics of a Java bytecode program is a rela-
tion between activation stacks. It models the transformation of the
activation stack induced by the execution of each single bytecode.
DeÔ¨Ånition 6. The (small step) operational semantics of a Java
bytecode program Pis a relation a0)Pa00(Pis usually omitted)
providing the immediate successor activation stack a00of an activa-
tion stack a0. It is deÔ¨Åned by the rules in Figure 3.
Rule 1 executes an instruction ins, different from call , by us-
ing its semantics ins. The JVM then moves forward to run the rest
of the instructions. Rule 2 calls a method on a non- null receiver.
It looks up the correct implementation ki:m(~t):tof the method, by
using the look-up procedures of the language, and Ô¨Ånds the block b
where that implementation starts. It then builds its initial state s0,
by using makescope , and creates a new current conÔ¨Åguration con-
taining bands0. It pops the actual arguments from the old current
conÔ¨Åguration and the call from the instructions still to be exe-
cuted at return time. Since a method call can actually call many
implementations, depending on the run-time class of the receiver,
this rule is apparently non-deterministic. However, only one thread
of execution will continue, since we assume that the method look-
up rules of the language are deterministic (as in Java bytecode).
Control returns to the caller by rule 4, which rehabilitates the con-
Ô¨Åguration of the caller but forces the memory to be that at the end
of the execution of the callee. The return value of the callee is
pushed on the stack of the caller. This rule is executed if the state
reached at the end of the caller is a normal state. If it is an excep-
tional state, rule 5 is executed instead, which propagates the excep-
tion back to the caller. If a method call occurs on a null receiver,
5hload 0 OD @p0
load 1 java :awt:Frame @p1
const ‚ÄùOptions ‚Äù@p2
call java :awt:Dialog :hiniti:::@p3!!b4b6jjh[`;`0]jjejj¬µii::a
(1))hload 1 java :awt:Frame @p1
const ‚ÄùOptions ‚Äù@p2
call java :awt:Dialog :hiniti:::@p3!!b4b6jjh[`;`0]jj`jj¬µii::a
(1))hconst ‚ÄùOptions ‚Äù@p2
call java :awt:Dialog :hiniti:::@p3!!b4b6jjh[`;`0]jj`0::`jj¬µii::a
(1))h call java :awt:Dialog :hiniti:::@p3!!b4b6jjh[`;`0]jj`00::`0::`jj¬µii::a
(2))hÔ¨Årstjjh[`;`0;`00]jjejj¬µii::h!!b4b6jjh[`;`0]jjejj¬µii::a
(:::))hjjh[`;`0;`00]jjejj¬µ0ii::h!!b4b6jjh[`;`0]jjejj¬µii::a
(4))h!!b4b6jjh[`;`0]jjejj¬µ0ii::a
(6))hload 0 OD @p6
load 1 java :awt:Frame @p7
putfield OD :owner :::@p8
load 0 OD @p9
call OD :setup ():void @p10!!b4b11jjh[`;`0]jjejj¬µ0ii::a
(1))hload 1 java :awt:Frame @p7
putfield OD :owner :::@p8
load 0 OD @p9
call OD :setup ():void @p10!!b4b11jjh[`;`0]jj`jj¬µ0ii::a
(1))hputfield OD :owner :::@p8
load 0 OD @p9
call OD :setup ():void @p10!!b4b11jjh[`;`0]jj`0::`jj¬µ0ii::a
(1))hload 0 OD @p9
call OD :setup ():void @p10!!b4b11jjh[`;`0]jjejj¬µ0[¬µ(`):owner7!`0]|{z}
¬µ00ii::a
(1))h call OD :setup ():void @p10!!b4b11jjh[`;`0]jj`jj¬µ00ii::a
Figure 4: A partial execution according to the semantics of Fig-
ure 3. bxis the block in Figure 2 starting at px.ODstands for
JFlex.gui.OptionsDialog . Location `00points to the string "Options"
from the constant pool. Ô¨Årst is the Ô¨Årst block of the constructor of
java.awt.Dialog .(:::))is a complete execution of the latter and ¬µ0is the
memory at its end.
rule 3 creates a new state whose stack contains only a reference
to aNullPointerException . No actual call happens in this case.
Rule 6 applies when all instructions inside a block have been ex-
ecuted; it runs one of its immediate successors, if any. This rule
is normally deterministic, since if a block of our formalization of
the Java bytecode has two or more immediate successors then they
start with mutually exclusive conditional instructions and only one
thread of control is actually followed.
From now on, when we use the notation ), we often specify the
rule in Figure 3 which is used at each derivation step; for instance,
we write(1))for a derivation step through rule (1).
Example 3. Consider the state h[`;`0]jjejj¬µifrom Example 1 at
p0in Figure 2. The operational semantics can proceed from p0as
in Figure 4.
5. Rawness Analysis
JULIA collects rawness information with a constraint-based raw-
ness analysis which is performed at the end and independently from
the nullness analysis. The rawness analysis builds a constraint: agraph whose nodes contain sets of Ô¨Åelds that have not been initial-
ized yet. There is a node for each local variable at a given program
point and for each method parameter and return value. There is
also a node for each Ô¨Åeld and another for the values stored into
arrays; differently from local variables, Ô¨Åelds and arrays have Ô¨Çow-
insensitive approximations. Assignments and parameter passing
are modeled as directed arcs a!bin the graph. They represent
the inclusion of the content of ain the content of b.
When an object is created by a newkbytecode, all Ô¨Åelds of k
and of its superclasses are used as an approximation for the newly
created object, left on top of the stack, since its has no initialized
Ô¨Åeld at that point. Then arcs are built to link subsequent program
points. For instance, the arc l0@p0!l0@p1is built for the pro-
gram in Figure 1. But the arc l0@p0!s0@p1is also built, since
local variable 0 at p0is loaded on the stack as its only element
s0atp1. Arcs are built for all possible Ô¨Çows of control induced
by loops, conditionals and exceptions. For instance, in Figure 1,
both arcs l0@p3!l0@p4andl0@p3!l0@p6are built. Assign-
ments to Ô¨Åelds give rise to arrows from the rightvalue to the node
for the Ô¨Åeld. For instance, the assignment at p8induces the arc:
s1@p8!owner . In order to model the fact that Ô¨Åeld owner is now
initialized, a Ô¨Åltering arc is built also, for each deÔ¨Ånite alias of the
receiver. For instance, the same assignment at p8introduces the
arcl0@p8owner!l0@p9instead ofl0@p8!l0@p9. The former arc
states that all Ô¨Åelds in l0@p8are included in l0@p9, but owner .
The deÔ¨Ånite aliasing information needed here is the same used, for
instance, in our nullness analysis (see [25]), so we can recycle it.
When all arcs have been built for the whole program, the con-
straint is solved through a least Ô¨Åxpoint calculation. The approxi-
mation of each variable is an over-approximation of the set of its
Ô¨Åelds that might not have been initialized yet. For instance, in
Figure 1, the approximation computed for l0@p0is the set S=
fowner ;:::gof all Ô¨Åelds of class OptionsDialog and of its super-
classes, and that for s0@p10 isSnfownerg, since the non- null
Ô¨Åeld owner has been already initialized at p10. The approximation
computed for s0@p12is/0, since all Ô¨Åelds of class OptionsDialog
and of its superclasses have been already initialized at p12.
5.1 The abstraction map for rawness
In order to formalize our rawness analysis and prove its correct-
ness, we deÔ¨Åne now the abstraction map from states to rawness.
DeÔ¨Ånition 7. (Rawness Abstraction) Let s=h[v0:::vi 1]jjwj 1::
::w0jj¬µibe a state (possibly underlined) with ilocal variables
andjstack elements. Its rawness abstraction a(s)maps the sym-
bolsfl0:::li 1;s0:::sj 1;f1;:::; fng, where f1;:::; fnare all the
Ô¨Åelds in P, into sets of uninitialized Ô¨Åelds , that is, Ô¨Åelds that have
not been initialized yet for each local variable, stack element or
Ô¨Åeld:
a(s)(lk) =(
/0 ifvk2Z[fnullg
ffj¬µ(vk):f=uninitgifvk2L
a(s)(sk) =(
/0 ifwk2Z[fnullg
ffj¬µ(wk):f=uninitgifwk2L
a(s)(fk) =ffjthere exists `2Ls.t.¬µ(¬µ(`):fk):f=uninitg:
By DeÔ¨Ånition 7, the rawness of a stack element or local variable is
the set of Ô¨Åelds still bound to uninit in the object they hold. The
rawness of a Ô¨Åeld fk, instead, includes a Ô¨Åeld fif there is an object
¬µ(`)at`with Ô¨Åeld fkbound to a location `0=¬µ(`):fkthat holds
an object ¬µ(`0)whose Ô¨Åeld fis still uninit . Note that we silently
6assume that ¬µ(¬µ(`):fk):fis well deÔ¨Åned , i.e., that all its compo-
nents are deÔ¨Åned. Instance Ô¨Åelds are Ô¨Çattened by this abstraction ,
i.e., they are treated as static Ô¨Åelds and we cannot distinguish Ô¨Åelds
with the same name but in different objects. This abstraction is
necessary to get a Ô¨Ånite static analysis, since the number of objects
in memory is potentially unbound.
Example 4. Consider the state s=h[`;`0]jjejj¬µifrom Exam-
ple 1. Its abstraction is such that owner2a(s)(l0).
5.2 The abstract constraint
A program Pinduces a constraint, which is a graph whose nodes
contain a set of uninitialized Ô¨Åelds. There are many kinds of nodes:
lk@pstands for the kth local variable ( k0) at program point p
sk@pstands for the kth stack element ( k0) at program point p
f@ewstands for Ô¨Åeld f, at any program point
return @mstands for the return value of method m
exception @mstands for any exception thrown by method m
lk@end of m stands for the kth local variable ( k0) at the
end of every normal execution of method m
 fk1:f1;:::;kn:fngstands for a node containing those uninitial-
ized Ô¨Åelds
Arcs are directed: n1!n2states that all the Ô¨Åelds in n1are also in
n2. The Ô¨Åltering arcn1f!n2states that all the Ô¨Åelds in n1except f
are also in n2. Arcs are built for each pair of subsequent bytecode
instructions:
DeÔ¨Ånition 8. Letins p@pandins q@qbe two bytecodes. Let
ipand jpbe the number of local variables and stack elements at
the beginning of the execution of ins p, respectively. Let Uip;jp=
flk@p!lk@qj0k<ipg[f sk@p!sk@qj0k<jpg. We
deÔ¨Åne the constraints con(ins p@p;ins q@q)as follows. If ins q
is not a catch then:
con(const v;ins q) =con(catch ;ins q)
=con(exception _is[_not]K;ins q) =Uip;jp
con(dupt;ins q) =Uip;jp[fsjp 1@p!sjp@qg
con(load x t;ins q) =Uip;jp[flx@p!sjp@qg
con(store x t;ins q) =flk@p!lk@qj0k<ip;k6=xg
[fsk@p!sk@qj0k<jp 1g[f sjp 1@p!lx@qg
con(if_net;ins q) =Uip;jp 2
con(newk;ins q) =Uip;jp[ffk0:f:tjt2Kandkk0g! sjp@qg
con(getfield f;ins q) =Uip;jp 1[ff@ew!sjp 1@qg
con(putfield f;ins q) =flk@p!lk@qj0k<ip;(lk;sjp 2)62alias pg
[fsk@p!sk@qj0k<jp 2;(sk;sjp 2)62alias pg
[flk@pf!lk@qj0k<ip;(lk;sjp 2)2alias pg
[fsk@pf!sk@qj0k<jp 2;(sk;sjp 2)2alias pg
[fsjp 1@p!f@ewg
con(call m1:::mn;ins q) =[n
k=1[p 1
u=0fsjp u 1@p!lp u 1@Ô¨Årst(mk)g
[freturn @mk!sjp p@qj1kng
[8
<
:lk@p!lk@q1k<ipand if (lk;sjp u 1)2alias p
for some 0u<pthen at least an mh
contains a store lp u 1t9
=
;
[8
><
>:lp u 1@end of m w!lk@q1k<ip;1wn;
(lk;sjp u 1)2alias p
for some 0u<pand no mh
contains a store lp u 1t9
>=
>;[8
<
:sk@p!sk@q1k<jp pand if (sk;sjp u 1)2alias p
for some 0u<pthen at least an mh
contains a store lp u 1t9
=
;
[8
><
>:lp u 1@end of m w!sk@q1k<jp p;1wn;
(sk;sjp u 1)2alias p
for some 0u<pand no mh
contains a store lp u 1t9
>=
>;:
If, instead, ins qis acatch , we deÔ¨Åne
con(throw k;catch ) =flk@p!lk@qj0k<ipg
[fsjp 1@p!s0@qg
con(call m1:::mn;catch ) =[n
k=1[p 1
u=0fsjp u 1@p!lp u 1@Ô¨Årst(mk)g
[fexception @mk!s0@qj1kng[f lk@p!lk@qj1k<ipg
con(ins p;catch ) =Uip;0;where ins pis not a throw nor a call .
Moreover, if pis a program point inside method m, we deÔ¨Åne the
constraints
Ô¨Ånal_con(throw k) =fsjp 1@p!exception @mg
Ô¨Ånal_con(return void ) =flk@p!lk@end of mj0k<ipg
Ô¨Ånal_con(return t) =flk@p!lk@end of mj0k<ipg
[fsjp 1@p!return @mg
where t6=void .
DeÔ¨Ånition 8 has two cases. The Ô¨Årst is when ins qis not a catch .
This means that the normal output state of ins pÔ¨Çows to the begin-
ning of ins q. Ifins pis aconst , the sets of uninitialized Ô¨Åelds for
local variables and stack elements do not change. This is also the
case for catch ,exception _isandexception _is_not. Hence
we build a constraint Uip;jpthat states this fact. For dup, we also
build an arc saying that the set of uninitialized Ô¨Åelds for the new top
of the stack ( sjp@q) contains all the uninitialized Ô¨Åelds of the old
top of the stack ( sjp 1@p). Similar constraints are built for load
andstore : the latter keeps the approximation of the local variables
unchanged but for lxthat gets the approximation of the old top of
the stack. If ins pis an if_ne, two elements are removed from the
stack. If it is a newk, the new top of the stack contains all Ô¨Åelds
deÔ¨Åned in kor in a superclass k0ofk, since they are not yet initial-
ized. Bytecodes getfield andputfield create arcs from and to
the node f@ewfor the accessed Ô¨Åeld f. The latter bytecode mod-
iÔ¨Åes the rawness of every deÔ¨Ånite alias of its receiver sjp 2, since
Ô¨Åeld fis being initialized. The constraints generated when ins p
is acall are the most complex. They link the actual arguments
(the topmost stack elements of the caller) to the formal arguments
(the lowest local variables at the Ô¨Årst bytecode Ô¨Årst(mk)of the ini-
tial block of each callee mk). Moreover, the local variables lkof
the caller and its stack elements skthat are not actual arguments
might keep their approximation or can see it improved when they
are a deÔ¨Ånite alias of an actual argument sjp u 1and the corre-
sponding formal argument lp u 1is not updated inside the callee.
If this is the case, then the Ô¨Ånal approximation for lp u 1inside the
callee can be used as approximation for lk(respectively, sk) after the
call. This situation is important since it allows helper functions to
improve the rawness approximation for the variables of the caller.
This is the case, for instance, of setup() in Figure 1, whose code
initializes tens of Ô¨Åelds of an OptionsDialog .
The second case of DeÔ¨Ånition 8 is when ins q@qis acatch .
This means that ins pis executed, it throws an exception ewhich
is caught by ins qand stored as s0@q. In any case, the original
rawness approximation for the local variables remains correct. If
ins pis not a call nor a throw , then eis an internal exception [18]
7without uninitialized Ô¨Åelds, so we can use Uip;0. Otherwise, emight
be the top of the stack ( sjp 1@p) forthrow or an exception thrown
by the called method(s) for call . Ifins pis acall , we also link
the actual arguments to the formal ones.
The function Ô¨Ånal_congenerates constraints for the Ô¨Ånal byte-
code of a block with no successors. That bytecode can only be a
throw or areturn inside some method m. In the Ô¨Årst case the top
of the stack ( sjp 1@p) is linked to the exception thrown by m. In
the second case it is linked to the return value of the method, if any,
and the local variables are linked to the approximation of the local
variables at the end of m.
Example 5. Consider ins p=load 1 java :awt:Frame @p1and
ins q=const ‚ÄùOptions ‚Äù@p2from Figure 1. At p1we have ip=
2 local variables and jp=1 stack elements. Thus con(ins p;ins q)=
fl0@p1!l0@p2;l1@p1!l1@p2;l1@p1!s1@p2;s0@p1!
s0@p2g.
Example 6. Letins p=call java :awt:Dialog :hiniti:::@p3
andins q=load 0 JFlex :gui:OptionsDialog @p6from Figure 1.
Atp3we have ip=2 local variables and jp=3 stack elements.
Our aliasing analysis computes alias p3=f(l0;s0);(l1;s1)g. This
call hasn=1 targets and p=3 parameters (including the implicit
this parameter). Let Ô¨Årstbe the Ô¨Årst bytecode in the initial block
of the constructor mofjava.awt.Dialog , whose code does not
contain any store 0 nor any store 1. Hence con(ins p;ins q) =
fs0@p3!l0@Ô¨Årst;s1@p3!l1@Ô¨Årst;s2@p3!l2@Ô¨Årst;
l0@end of m!l0@p6;l1@end of m!l1@p6g.
We can deÔ¨Åne the constraints induced by the whole program.
DeÔ¨Ånition 9. Letins 1

ins n!!b1bmbe a block. If m>0, its induced
constraints are[n 1
k=1con(ins k;ins k+1)[[m
h=1con(ins n;Ô¨Årst(bh)),
where Ô¨Årst(bh)is the Ô¨Årst instruction in bh. If m=0, they are
[n 1
k=1con(ins k;ins k+1)[Ô¨Ånal_con(ins n). Those induced by a
program Pare the union of the constraints induced by each block
ofP.
5.3 Correctness of the analysis
Once the constraints for Phave been built, they can be solved,
i.e., a least solution can be found, satisfying the inclusions repre-
sented by their arcs. This is possible since arcs (normal and Ô¨Ål-
tering) stand for monotonic functions from the approximation of
their source to that of their sink. Hence a least solution exists, is
unique, and can be computed, for instance, with an iterated Ô¨Åxpoint
calculation from the empty approximation for each node.
DeÔ¨Ånition 10. The solution of a constraint Gis the least as-
signment Sof sets of Ô¨Åelds to nodes, such that S(ff1;:::; fng) =
ff1;:::; fngfor every nodeff1;:::; fng2G,S(n1)S(n2)for ev-
eryn1!n22GandS(n1)nffgS(n2)for every n1f!n22
G.
Example 7. The solution of the constraints generated for the pro-
gram in Figure 1 is such that S(l0@p0) =fowner ;:::gcontains
all the Ô¨Åelds deÔ¨Åned in OptionsDialog and in its superclasses.
Moreover, owner62S(s0@p10)6=/0andS(s0@p12) =/0(that is,
all Ô¨Åelds of OptionsDialog and of its superclasses have been def-
initely assigned when calling pack() ).
We can now provide the correctness result for our analysis. It
states that the abstraction of all the states generated during the exe-cution of Paccording to our operational semantics is over-approx-
imated by the solution of the constraint generated for P. The hy-
pothesis of this proposition guarantees that the considered execu-
tion is feasible , i.e., it did not hang the Java Virtual Machine.
PROPOSITION 1.LethbÔ¨Årst(main )jjVi)hins@p
rest!!b1bmjjsi::a
be any execution of our operational semantics, from method main
and an initial state Vwhose objects in memory have no uninitial-
ized Ô¨Åelds, with ins(s)deÔ¨Åned when ins is not a call , or with
s2Xwith at least pstack elements when ins is acall withp
parameters. Let there be i local variables and j stack elements at
p. Then for every 0k<i we have a(s)(lk)S(lk@p), for every
0k<j we have a(s)(sk)S(sk@p)and for every Ô¨Åeld f kwe
have a(s)(fk)S(fk@ew).
Note that, in Java bytecode, method main receives an array of strings
as parameter and those strings have no uninitialized Ô¨Åelds. Hence
the hypothesis on Vis sensible.
Proposition 1 is proved in Appendix A.
5.4 Building the @Rawannotations
Our rawness analysis can be used whenever one wants to know
if some Ô¨Åeld of a given variable is deÔ¨Ånitely initialized at a given
program point. As we said in Section 3, this is the case for nullness
analysis, since existing type-checkers for nullness allow the spec-
iÔ¨Åcation of a set of non-null Ô¨Åelds , which are always initialized
by all constructors of their deÔ¨Åning class and are always assigned
a non- null value. Hence they do hold a non- null value, but only
after their Ô¨Årst initialization. Where this is not yet the case, rawness
must be speciÔ¨Åed.
Given a set of non- null Ô¨Åelds NN, our analysis infers a superset
of the variables vat a given program point pand a superset of the
Ô¨Åelds fof the program that should be typed as @Raw . It is enough
to check if S(v@p)\NN6=/0orS(f@ew)\NN6=/0, respectively.
Similarly for the formal parameters of the methods and for their
return value. It is also possible to derive class-speciÔ¨Åc rawness,
that is, to determine if all non- null Ô¨Åelds deÔ¨Åned in a given class
khave been initialized or not. Namely, a superset of the variables
vat a given program point pand a superset of the Ô¨Åelds fof the
program that should be typed as @Raw( k)can be determined by
checking if S(v@p)\fk:gjk:g2NNg6=/0orS(f@ew)\fk:gj
k:g2NNg6=/0, respectively.
6. Experimental results
We have implemented the analysis that is deÔ¨Åned in Section 5
and proved correct in Appendix A. This section describes experi-
ments that assess the effectiveness of the analysis. The key question
is whether JULIA ‚Äôs output is correct.
6.1 Subject programs and analysis output
We applied the inference tool, JULIA , to three programs. JFlex
1.4.3 is a scanner generator ( http://jflex.de/ ). Plume is library
of utility programs and data structures ( http://code.google.com/
p/plume-lib/ , downloaded on Feb. 3, 2010). The Annotation File
Utilities (AFU) 3.0 are tools for reading/writing Java annotations [2].
Figure 5 lists the sizes of the programs, the analysis time, and
raw data about Julia‚Äôs output.
JULIA ‚Äôs scalability depends on the size of the reachable code in
an application, rather than on the lines of source code. J ULIA starts
its analysis at all entry points to the program, and then proceeds to
discover and analyze all reachable code in the program. It treats
as entry points: (1) any public static void main(String[])
8size reachable program & libraries analysis time (sec.) dereferences inferred annotations
program (lines) methods lines bytecodes nullness rawness safe / all (%) @NonNull @Raw
JFlex 14987 3885 39097 390315 282 38584 / 8751 (98.1) 572 / 741 (77.2) 6 / 1109 (0.5)
AFU 13892 4246 38415 412332 346 35054 / 5143 (98.3) 642 / 854 (75.2) 15 / 1124 (1.3)
plume 19652 5400 49921 511277 660 48481 / 8613 (98.5) 617 / 915 (67.4) 3 / 1118 (0.3)
plume progs 6167 5400 49921 511277 660 46048 / 6148 (98.4) 235 / 300 (78.4) 3 / 339 (0.9)
Figure 5: Experimental results. ‚ÄúLines‚Äù is counted with the cloc program ( http://cloc.sourceforge.net/ ). Size is computed separately for the application
as downloaded, and for the reachable, analyzed portion of the program, including any reachable libraries but not counting unreachable methods in the program
or the libraries. Analysis time and results are for the most precise nullness analysis currently available in JULIA . Dereferences are counted only in the the
reachable application code (which does not include libraries). Safe dereferences are those that JULIA can guarantee will never throw a null pointer exception
at run time. In the ‚ÄúInferred annotation‚Äù columns, the denominator is the total number of sites at which the annotation could possibly be written, in Ô¨Åelds and
method signatures of the reachable application code. The percentage of inferred annotations is also given. The last row reports the analysis of plume , as in the
previous line, but with statistics projected over the 10 classes that have a main() method; see Section 6.2.2.
method, and (2) any public static void test*() method in a
class that extends TestCase , to handle JUnit tests.
The rawness analysis is fast ‚Äî just a few seconds. The nullness
analysis runs as long as 11 minutes on our subject programs. Most
of the nullness analysis runtime is due to the aliasing and shape
analysis that it calls as a subroutine.
Recall from Section 1 the two primary uses for a nullness/rawness
inference: to indicate locations where a null pointer exception may
be thrown, or to provide annotations for a human or a follow-on
analysis. The last two groups of columns in Ô¨Ågure 5 address these
two uses.
A ‚Äúdereference‚Äù is any location at which a variable must be non-
null to avoid throwing a null pointer exception. These include Ô¨Åeld
and method dereferences, array accesses, array length expressions,
throw statements, and synchronization operations. J ULIA proves
that over 98% of the dereferences in each application program are
safe ‚Äî that is, these locations can never throw a null pointer excep-
tion at run time. This fact can aid in optimization and reasoning.
For comparison, these numbers are around 80% in the case of N IT
(see [23] for a comparison).
Figure 5 indicates the number of annotations inferred, and the
maximum number of sites at which the annotation could possibly
be inferred. For @NonNull , the sites include Ô¨Åelds, method formal
parameters, and method return types. A single type may have mul-
tiple sites; for example, up to three @NonNull annotations could
be placed on Map<String,Object> . Receivers and constructor re-
sults are notcounted as sites, because they are trivially non- null .
Primitive and void types are never counted, because they cannot be
null . The sites for @Raw are the same as those for @NonNull , plus
receivers. Constructor results are trivially non-raw.
JULIA annotates a signiÔ¨Åcant amount of the program, lessen-
ing the programmer burden. (Either @NonNull annotations, or a
smaller but still signiÔ¨Åcant number of @Nullable annotations, are
automatically inserted into the program source code.) @Raw is in-
ferred for as much as 1.3% of all references in the program.
Our experiments count annotations on Ô¨Åelds and in method sig-
natures. These are the places that annotations are most useful. It
would also be possible to infer types for local variables or for ex-
pressions within a method body, but our experiments ignore this
possibility, and JULIA does not perform such output.
Depending on the program, JULIA proves that 67‚Äì78% of all ref-
erences can be marked as @NonNull . Furthermore, only a very few
references are marked as @Raw .
Previous evaluations of nullness inference tools have generally
reported numbers like these, quantifying the tool‚Äôs output. A prob-
lem with such numbers is that they do not indicate whether the
tool‚Äôs output is correct oruseful . Section 6.2 addresses the correct-
ness question by comparing JULIA ‚Äôs output to manual annotationsof nullness and rawness. Section 6.3 addresses usefulness of both
the nullness and rawness annotations, for one particular use: prov-
ing a program is free of null pointer dereferences, or Ô¨Åxing any
such problems in the program.
6.2 Comparison to human-written annotations
This section compares JULIA ‚Äôs annotations to a correct set of
annotations written by a human.
As part of a different project, plume was previously annotated
with nullness and rawness annotations.1The manual annotations
use@NonNull as the default (except for local variables, which de-
fault to @Nullable ), and so only write an annotation for @Nullable
references. This leads to fewer annotations overall. Plume has 508
nullness or rawness annotations on 312 distinct lines, plus another
36 warning suppression annotations.
The manual annotations were checked by a pluggable type-checker
built upon the Checker Framework [20]. The type-checker veriÔ¨Åed
both the correctness of the annotations, and that there are no in
plume. The outcome of this process is a guarantee that the annota-
tions are correct, and that plume has no null pointer dereferences.2
This gives perspective on the 132 (= 8613  8481) possibly-unsafe
dereferences that Julia reports in plume: they are probably all false
warnings.
To gain perspective on these false warnings and on JULIA ‚Äôs strengths
and weaknesses, both of this paper‚Äôs authors examined differences
between the manual annotations and JULIA ‚Äôs output. We examined
rawness annotations in all of plume, and nullness annotations in a
subset of plume.
6.2.1 Rawness comparison for all of plume
We examined all rawness differences, everywhere in plume. Plume
as downloaded contains 7 instances of @Raw , and JULIA ‚Äôs output
contains 3 instances of @Raw . One @Raw annotation is in both sets,
so there are 8 differences to examine.
Three manual @Raw annotations, on method receivers, are not in-
ferred by JULIA and are extraneous ‚Äî they are weaknesses in the
manual annotation. The program type-checks with these annota-
tions, but it also type-checks without them, so there is no need for
them. They were inserted at a time when the type-checker did need
them, because it was unable to infer that an object is initialized be-
fore its constructor exits. J ULIA and the current type-checker can
make such inferences. These annotations have since been removed
from plume.
1Except for this section, all of our experiments use a version of plume from which all
nullness/rawness annotations have been removed.
2The guarantee is modulo the fact that when the programmer annotated the program,
the programmer also suppressed some type-checking warnings. The programmer only
did so when manual reasoning indicated the warning was a false warning, but the
programmer may have made mistakes during this manual reasoning.
9Inconse- T-C Unanalyzed Manual Julia
quential artifact code error weakness err weakness
21 40 69 8 18 2 48
IMWSLA SWBO DCUC UL SUME UN MW JEPRRESIMAITJW
13 4 4 18 22 32 34 3 6 2 16 2 220 8 6 4 4 6
Figure 6: Number of lines of differences between manual annotations and
JULIA output, classiÔ¨Åed according to Section 6.2.2. In general, each dif-
ference results in two lines of diff output. The table classiÔ¨Åes the same
differences twice: once into coarser and once into Ô¨Åner-grained categories.
Three manual @Raw annotations on parameters of type Object
are not inferred by JULIA , because JULIA does more detailed anal-
ysis than the type-checker. In particular, JULIA recognizes that any
value passed to the given methods is initialized up to the @Object
constructor, even if it is not be fully initialized. The type-checker
requires these parameters to be marked @Raw because they are not
fully initialized.
Finally, two @Raw annotations inferred by JULIA are a result of
imprecision in JULIA ‚Äôs analysis.
6.2.2 Full comparison for programs in plume
We examined all differences between the manual annotations
and JULIA ‚Äôs output, for a subset of plume. For our subset, we chose
all the programs in plume: each class that contains a main method.
There are 10 such classes (out of 44), and they contain about 1/4 of
plume‚Äôs lines of code. Running the diff program on these classes
yields 206 lines of differences (compared to 1450 lines of differ-
ences for all of plume). The last line of Figure 5 provides more
measurements.
Usually, there are 2 lines of diff output per difference: one line
in the diff output shows the old code, and one shows the new code.
In some cases, such as import statements and warning suppression,
there are more or fewer. To permit counting without fear of ambi-
guity, we always use number of lines of diff output.
We classiÔ¨Åed each of the 206 lines of diff output according to the
following categories:
Inconsequential differences
IM(import statement) JULIA added an import statement that is
redundant with an existing one.
WS (whitespace) The difference is in whitespace or the order of
modiÔ¨Åers.
LA (@LazyNonNull ) The manual annotation uses @LazyNonNull ,
which means that the variable may start out as null , but once
set to a non- null value, it may continue to be reassigned but is
never again assigned to null . JULIA uses @Nullable , which
is equivalent from JULIA ‚Äôs point of view.
Type-checker artifacts
SW (@SuppressWarnings ) The difference is the removal of a @Sup-
pressWarnings annotation that was present in the original
program, in a method body. It was placed there to overcome a
limitation of the type-checker. J ULIA may or may not have a
similar limitation; if it does, that will be reÔ¨Çected in a differ-
ence in some Ô¨Åeld or method signature.
BO (inside method body) The difference is an annotation within
a method body (other than @SuppressWarnings ), which our
experiment ignores but the type-checker needs.
Unanalyzed code
DC (dead code) A method is never executed, so JULIA does not
bother to annotate it. For example, this applies to old code that
is no longer used, and to code used for debugging. As another
example that alone accounts for 25 of the 32 lines of diff, an
API required a Reader object, but did not use it, so plumecreated a DummyReader class and passed that to the API.
UC (unreachable code) JULIA cannot Ô¨Ånd a path that executes a
given method, because no such path exists in plume, though a
path may exist in client code. The prime cause for this is the
fact that one of the selected classes, EntryReader, is really a
library, not a program. Its main method is just a simple usage
example that does not fully exercise the class.
UL (unanalyzed library) JULIA cannot Ô¨Ånd a path to a method be-
cause the path starts in a library that JULIA did not analyze. For
example, a class‚Äôs boolean start(RootDoc doc) method is
called reÔ¨Çectively when Javadoc executes, but JULIA does not
add Javadoc‚Äôs main method to the set of entry points for every
program.
Errors in manual annotations
SU(static initialization unchecked) The type checker veriÔ¨Åes that
instance Ô¨Åelds are properly initialized by the time the construc-
tor exits, but does not do a similar check for static Ô¨Åelds, so a
static Ô¨Åeld marked as @NonNull may contain null . The plume
authors have subsequently veriÔ¨Åed these errors and corrected
them by changing the annotation to @Nullable .
ME (manual annotation error, other) A constructor argument was
improperly marked as @NonNull that should have been @Null-
able . This annotation has also now been Ô¨Åxed. Overall, JULIA
did not reveal any null pointer errors, only the 4 (= 8/2) incor-
rect annotations.
Weaknesses in manual annotations
UN (unannotated code) The developers did not consider this code
worth annotating: for example, the code is undocumented, is
used for testing, or is under development. J ULIA ‚Äôs inference
results would make the annotation task much easier.
MW (manual annotation weakness, other) The programmer wrote
@Nullable on a method return value that is actually always
non-null . The annotation type-checks, but the more precise
annotation is better.
Errors in Julia output
JE(errors in JULIA annotations) J ULIA uses multiple annotations
for arrays of references and for generic classes of the standard
Java library ‚Äî one annotation for the container and one for
the element type. However, JULIA does not yet do so for user-
deÔ¨Åned generic classes such as Pair<S,T> .
Weaknesses in JULIA output
PR(property) Method System.getProperty() always returns non-
null for certain properties, such as "java.class.path" and
"line.separator" ‚Äî unless the program does something
perverse like System.getProperties().remove("java.
class.path"); , which is not the case here. But JULIA does
not infer this fact.
RE (regular expressions) A call to Matcher.group() returns non-
null if it is guarded by a call to Matcher.matches() ,andthe
string representation contains parentheses at the top level. This
is beyond JULIA ‚Äôs reasoning capabilities.
SI(static initialization) A static Ô¨Åeld was initialized to non- null
at the beginning of main() , and the class was never used out-
side the dynamic scope of the main() method. J ULIA cannot
guarantee that fact about its use, and so marked the Ô¨Åeld as
@Nullable . The Ô¨Åeld was not set in the static initializer be-
cause the initializer has no access to the arguments to main .
MA (map) A map was queried via get() , using a value that came
from an iterator that was indirectly related to the map. Thus,
get() returned a map value and not null , but JULIA did not
recognize this fact.
IT(iterator) In a class that implements java.util.Iterator , a
superclass constructor somewhere in a library uses a (differ-
10ent) iterator. J ULIA was not able to establish that the two iter-
ators are not aliased.
JW (JULIA weaknesses, other) J ULIA cannot establish that the re-
sult of TimeZone.getDisplayName() is non- null . (Nor can
we, but the Javadoc implies that it is.) As a more complicated
example, CalendarBuilder.build() sets a calendar value to
null , apparently to satisfy Java‚Äôs deÔ¨Ånite assignment check,
but then calls parser.parse() which is guaranteed (by the
structure of its input) to eventually either throw an exception
or make a callback that will set the variable that Calendar-
Builder.build() eventually returns.
Suppose that a programmer wants to use a type-checker to verify
that an unannotated version of the 10 plume programs has no null
pointer errors. Further suppose that the libraries those programs use
are already annotated. (The type-checker comes with an annotated
version of the JDK and some other libraries.) The programmer can
start with JULIA ‚Äôs output, then edit approximately 75 (= (40+69+
2+48)/2) lines. This modest cost demonstrates that JULIA ‚Äôs output
is accurate and can be useful to programmers.
6.3 Type-checking of inferred annotations
JULIA infers most of the necessary nullness and rawness annota-
tions, which is a great help to a programmer who would otherwise
be forced to write them all from scratch.
Section 6.2 compared J ULIA ‚Äôs annotations to a correct set of
annotations. Another comparison would be to count the number
of type-checking errors that occur when type-checking a program
with and without J ULIA ‚Äôs annotations. We used the Nullness Checker
that is distributed with the Checker Framework [20, 4]. This type-
checker requires the programmer to annotate the program, then
veriÔ¨Åes the correctness of the annotations and the absence of null
pointer errors. It shares no code with the J ULIA inference tool,
making it an effective cross-validation for the correctness of both
tools.
Unfortunately, the number of type-checking errors is not a good
metric of annotation quality. In general, adding a correct, necessary
annotation may increase or decrease the number of compiler warn-
ings, depending on how the variable is used and the correctness and
veriÔ¨Åability of the surrounding annotations. For instance, for all of
plume (not just the programs as evaluated in Section 6.2), here is
the number of type-checking warnings:
Warnings Annotations
365 no annotations
408 JULIA nullness annotations only
411 JULIA nullness & rawness annotations
As the annotations get more complete and closer to what a pro-
grammer needs in order to verify that the program has no null
pointer errors, the number of warnings increases! Therefore, we
do not believe this is a useful metric, for evaluating annotations or
suggesting Ô¨Åxes to them.
7. Conclusion
We have deÔ¨Åned a new analysis for computing Ô¨Åeld initializa-
tion (‚Äúrawness‚Äù), proved it correct, and implemented it. Our exper-
iments compare it to human-provided and machine-checked cor-
rect annotations, and these experiments conÔ¨Årm the accuracy of the
analysis.
References
[1] E. Albert, P. Arenas, S. Genaim, G. Puebla, and D. Zanardini. Cost
analysis of Java bytecode. In ESOP , pages 157‚Äì172, Mar. 2007.[2] Annotation File Utilities website. http:
//types.cs.washington.edu/annotation-file-utilities/ ,
Feb. 3, 2010.
[3] R. E. Bryant. Graph-based algorithms for boolean function
manipulation. IEEE Trans. Comput. , 35(8):677‚Äì691, 1986.
[4] Checker Framework website.
http://types.cs.washington.edu/checker-framework/ ,
Feb. 3, 2010.
[5] Patrick Cousot and Radhia Cousot. Abstract interpretation: a uniÔ¨Åed
lattice model for static analysis of programs by construction or
approximation of Ô¨Åxpoints. In POPL , pages 238‚Äì252, 1977.
[6] Torbj√∂rn Ekman and G√∂rel Hedin. Pluggable checking and
inferencing of non-null types for Java. J. Object Tech. , 6(9):455‚Äì475,
Oct. 2007.
[7] Arnout F. M. Engelen. Nullness analysis of Java source code.
Master‚Äôs thesis, University of Nijmegen Dept. of Computer Science,
Aug. 10 2006.
[8] Michael D. Ernst, Jeff H. Perkins, Philip J. Guo, Stephen McCamant,
Carlos Pacheco, Matthew S. Tschantz, and Chen Xiao. The Daikon
system for dynamic detection of likely invariants. Science of
Computer Programming , 69(1‚Äì3):35‚Äì45, Dec. 2007.
[9] Manuel F√§hndrich and K. Rustan M. Leino. Declaring and checking
non-null types in an object-oriented language. In OOPSLA , pages
302‚Äì312, Nov. 2003.
[10] Manuel F√§hndrich and Songtao Xia. Establishing object invariants
with delayed types. In OOPSLA , pages 337‚Äì350, Oct. 2007.
[11] Cormac Flanagan, Rajeev Joshi, and K. Rustan M. Leino. Annotation
inference for modular checkers. Information Processing Letters ,
2(4):97‚Äì108, Feb. 2001.
[12] Stephen N. Freund and John C. Mitchell. A type system for object
initialization in the Java bytecode language. ACM TOPLAS ,
21(6):1196‚Äì1250, Nov. 1999.
[13] David Hovemeyer and William Pugh. Finding more null pointer
bugs, but not too many. In PASTE , pages 9‚Äì14, June 2007.
[14] David Hovemeyer, Jaime Spacco, and William Pugh. Evaluating and
tuning a static analysis to Ô¨Ånd null pointer bugs. In PASTE , pages
13‚Äì19, Sep. 2005.
[15] Laurent Hubert, Thomas Jensen, and David Pichardie. Semantic
foundations and inference of non-null annotations. In FMOODS ,
pages 132‚Äì149, 2008.
[16] Web interface to the JULIA analyzer.
http://julia.scienze.univr.it .
[17] G. Klein and T. Nipkow. A machine-checked model for a Java-like
language, virtual machine, and compiler. ACM TOPLAS ,
28(4):619‚Äì695, 2006.
[18] Tim Lindholm and Frank Yellin. The Java Virtual Machine
SpeciÔ¨Åcation . Addison-Wesley, Reading, MA, USA, 2nd edition,
1999.
[19] Chris Male and David J. Pearce. Non-null type inference with type
aliasing for Java.
http://www.mcs.vuw.ac.nz/~djp/files/MP07.pdf , Aug. 20,
2007.
[20] Matthew M. Papi, Mahmood Ali, Telmo Luis Correa Jr., Jeff H.
Perkins, and Michael D. Ernst. Practical pluggable types for Java. In
ISSTA , pages 201‚Äì212, July 2008.
[21] √â. Payet and F. Spoto. Magic-sets transformation for the analysis of
Java bytecode. In SAS, pages 452‚Äì467, Aug. 2007.
[22] F. Spoto. The nullness analyser of J ULIA . Submitted for publication,
2010.
[23] F. Spoto. Precise null-pointer analysis. Software and Systems
Modeling , 2010. To appear.
[24] F. Spoto, F. Mesnard, and √â. Payet. A termination analyser for Java
bytecode based on path-length. ACM TOPLAS , 2010. To appear.
[25] Fausto Spoto. Nullness analysis in boolean form. In SEFM , Nov.
2008.
A. Proofs
The following lemma states the correctness of the solution of
the constraints generated for a program P,w.r.t. the execution of
a single bytecode. It will be used in the proof of Proposition 1 in
11Section A.1.
LEMMA 1.Consider a blockins 1...
ins n!!b1bmin the program. Con-
sider the pairs of bytecodes hins k;ins k+1ifor k =1;:::; n 1
where ins kis not a call ; and the pairshins n;Ô¨Årst(bh)ifor h =
1;:::; m where ins nis not a call . Name those pairs, generically,
hins p@p;ins q@qi. Let spbe such that both sq=insp(sp)
and ins q(sq)are deÔ¨Åned. Let there be i plocal variables and j p
stack elements at p and i qlocal variables and j qstack elements
at q. If a(sp)(lk)S(lk@p)for every 0k<ip,a(sp)(sk)
S(sk@p)for every 0k<jpanda(sp)(fk)S(fk@ew)for all
Ô¨Åelds f k, then we have a(sq)(lk)S(lk@q)for every 0k<
iq,a(sq)(sk)S(sk@q)for every 0k<jqanda(sq)(fk)
S(fk@ew)for all Ô¨Åelds f k.
Proof. The pairs ins p@pandins q@qare exactly those consid-
ered in DeÔ¨Ånition 8. We consider the most signiÔ¨Åcant cases, from
which the others can be derived similarly.
ins pis aconst vandins qis not a catch
(The case when ins qis acatch does not exist, since const v
never throws any exception.) By DeÔ¨Ånition 8 there are arcs Uip;jp
in the constraints generated for program P. From the deÔ¨Ånition
ofconst v (Section 4), we have sp=hljjsjj¬µiandsq=hljjv::
sjj¬µi. Hence, by deÔ¨Ånition of solution (DeÔ¨Ånition 10), we have
a(sq)(lk) =a(sp)(lk)S(lk@p)S(lk@q)for every 0k<
ip=iq. Similarly, a(sq)(sk) =a(sp)(sk)S(sk@p)S(sk@q)
for every 0k<jp=jq 1. Moreover, when v2Z[fnullg,
we have a(sq)(sjq 1) =/0S(sjq 1@q). The same is true when
v2Lsince, in that case, ¬µ(v)cannot have any uninit Ô¨Åelds be-
cause const v is deÔ¨Åned (Section 4). Since spandsqhave the same
memory ¬µp, we also have a(sq)(fk) =a(sp)(fk)S(fk@ew)for
all Ô¨Åelds fk.
ins pis acatch vandins qis not a catch
(The case when ins qis acatch does not exist, since catch never
throws any exception.) By DeÔ¨Ånition 8 there are arcs Uip;jpin
the constraints generated for program P. From the deÔ¨Ånition of
catch (Section 4), we have sp=hljjtopjj¬µiandsq=hljjtopjj¬µi.
Hence, by deÔ¨Ånition of solution (DeÔ¨Ånition 10), we conclude that
a(sq)(lk) =a(sp)(lk)S(lk@p)S(lk@q)for every 0k<
ip=iq. Similarly, a(sq)(sk) =a(sp)(sk)S(sk@p)S(sk@q)
for every 0k<jp=jq. Since spandsqhave the same memory
¬µp, we also have a(sq)(fk) =a(sp)(fk)S(fk@ew)for all Ô¨Åelds
fk.
ins pis astore x tandins qis not a catch
(The case when ins qis acatch does not exist, since store x t
never throws any exception.) From the deÔ¨Ånition of store x t (Sec-
tion 4), we have sp=hljjtop::sjj¬µiandsq=hl[i7!top]jjsjj¬µi.
By DeÔ¨Ånition 8 the constraints generated for program Pinclude
the arcs lk@p!lk@qfor every 0k<ipwith k6=x, and arcs
sk@p!sk@qfor every 0k<jp 1. Hence, by deÔ¨Ånition of so-
lution (DeÔ¨Ånition 10) we have a(sq)(lk) =a(sp)(lk)S(lk@p)
S(lk@q)for every 0k<ip=iq,k6=x. Similarly, a(sq)(sk) =
a(sp)(sk)S(sk@p)S(sk@q)for every 0k<jp 1=jq.
Moreover, there is an arc sjp 1@p!lx@q, so that a(sq)(lx) =
a(sp)(sjp 1)S(sjp 1@p)S(lx@q). Since spandsqhave
the same memory ¬µp, also a(sq)(fk) =a(sp)(fk)S(fk@ew)
for all Ô¨Åelds fk.
ins pis anewkandins qis not a catchBy DeÔ¨Ånition 8 there are arcs Uip;jpin the constraints generated
for program P. From the deÔ¨Ånition of newk(Section 4), we have
sp=hljjsjj¬µiandsq=hljj`::sjj¬µ[`7!o]i(the other case of the
deÔ¨Ånition of newkcannot be used here since ins qis not a catch
and hence it is only deÔ¨Åned on non-exceptional states). We know
thatois an object of class kwhose reference Ô¨Åelds are all bound to
uninit . Moreover, spandsqhave the same memory ¬µp, but for a
fresh location `(hence not yet reachable from the Ô¨Åelds). Hence, by
deÔ¨Ånition of solution (DeÔ¨Ånition 10), we conclude that a(sq)(lk) =
a(sp)(lk)S(lk@p)S(lk@q)for every 0k<ip=iq. Simi-
larly, a(sq)(sk) =a(sp)(sk)S(sk@p)S(sk@q)for every 0
k<jp=jq 1. By deÔ¨Ånition of oand since there is an arc fk0:f:
tjt2Kandkk0g! sjq 1@q, we have a(sq)(sjq 1) =fk0:f:
tjt2Kandkk0gS(sjq 1@q). We also have a(sq)(fk) =
a(sp)(fk)S(fk@ew)for all Ô¨Åelds fk.
ins pis anewkandins qis acatch
This case exempliÔ¨Åes the situation when ins qis acatch . Sim-
ilar cases can be proved in the same way. By DeÔ¨Ånition 8 there
are arcs Uip;0in the constraints generated for program P. From the
deÔ¨Ånition of newk(Section 4), we have sp=hljjsjj¬µiandsq=
hljj`jj¬µ[`7!oome]i(the other case of the deÔ¨Ånition of newkcan-
not be used here since ins qis acatch and hence it is only deÔ¨Åned
on exceptional states). We know that oome is an object of class
OutOfMemoryError without uninit Ô¨Åelds. Moreover, spandsq
have the same memory ¬µp, but for a fresh location `(hence not yet
reachable from the Ô¨Åelds). Hence, by deÔ¨Ånition of solution (DeÔ¨Å-
nition 10), we have a(sq)(lk) =a(sp)(lk)S(lk@p)S(lk@q)
for every 0k<ip=iq. Moreover, a(sq)(s0) =/0S(s0@q).
We also have a(sq)(fk) =a(sp)(fk)S(fk@ew)for all Ô¨Åelds fk.
ins pis agetfield fandins qis not a catch
By DeÔ¨Ånition 8 there are arcs Uip;jp 1in the constraints gener-
ated for program P. From the deÔ¨Ånition of getÔ¨Åeld f (Section 4),
we have sp=hljjrec::sjj¬µiandsq=hljjx::sjj¬µiwith x2Z[
fnull;¬µp(rec):fg(the last case of the deÔ¨Ånition of getÔ¨Åeld f can-
not be used here since ins qis not a catch and hence it is only
deÔ¨Åned on non-exceptional states). Hence, by deÔ¨Ånition of solu-
tion (DeÔ¨Ånition 10), we have a(sq)(lk) =a(sp)(lk)S(lk@p)
S(lk@q)for every 0k<ip=iq. Similarly we conclude that
a(sq)(sk) =a(sp)(sk)S(sk@p)S(sk@q)for every 0k<
jp 1=jq 1. Moreover, we have a(sq)(sjq 1) =/0when x2Z[
fnullgand (DeÔ¨Ånition 7) a(sq)(sjq 1) =fgj¬µp(x):g=uninitg
when x=¬µp(rec):f2L. In the latter case, a(sq)(sjq 1)fgj
there exists `2Lsuch that ¬µp(¬µp(`):f):g=uninitg=a(sq)(f).
Since spandsqhave the same memory ¬µp, we conclude that
a(sq)(sjq 1)a(sq)(f) =a(sp)(f)S(f@ew). By DeÔ¨Åni-
tion 8, the constraints for program Pinclude the arc f@ew!
sjp 1@q. Since jp=jqand by deÔ¨Ånition of solution (DeÔ¨Åni-
tion 10), we have a(sq)(sjq 1)S(f@ew)S(sjq 1@q). Since
spandsqhave the same memory ¬µp, we conclude that a(sq)(fk) =
a(sp)(fk)S(fk@ew)for all Ô¨Åelds fk.
ins pis aputfield fandins qis not a catch
From the deÔ¨Ånition of putÔ¨Åeld f (Section 4), sp=hljjtop::rec::
sjj¬µiand
sq=hljjsjj¬µ[¬µ(rec):f7!top]|{z}
¬µqi
(the last case of the deÔ¨Ånition of putÔ¨Åeld f cannot be used here
since ins qis not a catch and hence it is only deÔ¨Åned on non-
exceptional states). By DeÔ¨Ånition 8 there are arcs lk@p!lk@q
12in the constraints generated for program P, for every 0k<ipwith
(lk;sjp 2)62alias p, and arcs lk@pf!lk@qfor every 0k<ip
with(lk;sjp 2)2alias p. In the former case, since the Ô¨Åelds of
an object can only be initialized during the execution of this byte-
code, by DeÔ¨Ånition 10 we conclude that a(sq)(lk)a(sp)(lk)
S(lk@p)S(lk@q). In the latter case, by DeÔ¨Ånition 7 we have
a(sq)(lk) =/0ifl[k]62L, anda(sq)(lk) =fgj¬µq(l[k]):g=uninitg
ifl[k]2L. Since we are assuming that (lk;sjp 2)2alias p, we
know that l[k] =rec. Since ¬µq(rec):f=top6=uninit (the value
uninit is only allowed as the value of a Ô¨Åeld, never as a value
on the stack), we conclude that f62a(sq)(lk) =fgj¬µq(rec):g=
uninitg. Since the Ô¨Åelds of an object can only be initialized dur-
ing the execution of this bytecode, by DeÔ¨Ånition 10 we conclude
that, in this case, a(sq)(lk)a(sp)(lk)nffgS(lk@p)nffg
S(lk@q). The same proof can be applied to the stack elements.
Given a Ô¨Åeld fk6=f, we have that ¬µpand¬µqagree on the val-
ues of Ô¨Åeld fkof their objects. Hence a(sq)(fk) =a(sp)(fk)
S(fk@ew). For Ô¨Åeld f, instead, we have (DeÔ¨Ånition 7) a(sq)(f) =
fgjthere exists `2Lsuch that ¬µq(¬µq(`):f):g=uninitg. Since
¬µq(`):f2f¬µp(`):f;topgand¬µq(`) =¬µp(`)for all locations `where
¬µp(`)(or, equivalently, ¬µq(`)) is deÔ¨Åned, we have a(sq)(f)fgj
there exists `2Ls.t.¬µq(¬µp(`):f):g=uninitg[f gj¬µp(top):g=
uninitg=fgjthere exists `2Ls.t.¬µp(¬µp(`):f):g=uninitg[
a(sp)(sjp 1) =a(sp)(f)[a(sp)(sjp 1). By DeÔ¨Ånition 8, we
know that there is an arc sjp 1@p!f@ewamong the arcs built
forP. Thus a(sq)(f)a(sp)(f)[a(sp)(sjp 1)S(f@ew).
A.1 Proof of Proposition 1
Proposition 1, deÔ¨Åned in Section 5.3, states that the analysis is
safe: it never reports as non-raw a reference that may not be fully
initialized. We now prove this proposition.
Proof of Proposition 1
We observe that the blocks in the conÔ¨Ågurations of an activation
stack, but the topmost, cannot be both empty and with no succes-
sors. This is because conÔ¨Ågurations are only stacked by rule (2) at
page 5 and if restis empty there, then m1 or otherwise the code
ends with a call bytecode and no return , which is illegal in Java
bytecode [18].
We proceed by induction on the length nof the execution
hbÔ¨Årst(main)jjVi)hins@p
rest!!b1bmjjsi::a.
Ifn=0, the execution is just hbÔ¨Årst(main)jjViands=V. Since
the objects in the memory of Vhave no uninitialized Ô¨Åelds, we have
a(s)(lk) =/0for every 0k<i,a(s)(sk) =/0for every 0k<j
anda(s)(fk) =/0for all Ô¨Åelds fk, so that the thesis holds.
Assume now that the thesis holds for any such execution of length
n0n. Consider an execution
hbÔ¨Årst(main)jjVi)n+1hins q@q
rest q
|{z}
bq!!b1bmjjsqi::aq (7)
with insq(sq)deÔ¨Åned. This execution must have the form
hbÔ¨Årst(main)jjVi)nphins p@p
rest p
|{z}
bp!!b0
1b0
m0jjspi::ap
)n+1 nphbqjjsqi::aq(8)with 0npn, that is, it must have a strict preÔ¨Åx of length np
whose Ô¨Ånal activation stack has a topmost conÔ¨Åguration with a non-
empty block bp. This is because, for instance, bÔ¨Årst(main)is a non-
empty block (the main method must contain at least a return ). Let
hence such npbe maximal, ipbe the number of local variables at
p,jpthe number of stack elements at pand similarly iqand jqat
q. By inductive hypothesis we know that
a(sp)(lk)S(lk@p)for all 0k<ip
a(sp)(sk)S(sk@p)for all 0k<jp
a(sp)(fk)S(fk@ew)for all Ô¨Åelds fk:(9)
We will prove that (9) holds for qinstead of palso, which com-
pletes the proof by induction. We distinguish on the basis of the
rule of the operational semantics that is applied at the beginning of
the derivation)n+1 npin Equation (8).
Rule (1).Then insp(sp)is deÔ¨Åned and ins pis not a call .
case a: ins pis not a return nor a throw
Ifrest pis non-empty then, by the maximality of np, (8) must be
hbÔ¨Årst(main)jjVi)nphins p@p
ins q@q
rest q
|{z}
bp!!b1bmjjspi::ap
(1))hins q@q
rest q
|{z}
bq!!b1bmjjinsp(sp)|{z}
sqi::ap|{z}
aq:
Otherwise m01 (legal Java bytecode can only end with a return
or athrow ) and, by the maximality of np, it must be bq=b0
hfor
a suitable 1hm0, so that (8) must have the form
hbÔ¨Årst(main)jjVi)nphins p@p
|{z}
bp!!b0
1b0
m0jjspi::ap
(1))h!!b0
1b0
m0jjinsp(sp)i::ap
(6))hbqjjinsp(sp)|{z}
sqi::ap|{z}
aq:
By the inductive hypothesis (9) for npand Lemma 1, we conclude
that (9) holds also with qinstead of p.
case b: ins pis areturn t
We show the case when t6=void , since the other is simpler (there
is no return value to consider). Then rest pis empty and m0=
0 (no code is executed after a return in legal Java bytecode,
but the method terminates) and since insp(sp)2X(deÔ¨Ånition of
return t ), (8) must be in one of these two forms, depending on the
emptiness of block bin (4):
hbÔ¨Årst(main)jjVi
)nphreturn t
|{z}
bpjjhlpjjtop::spjj¬µpi|{z}
spi::call timez}|{
hbqjjhlcjjscjj¬µcii::aq|{z}
ap
(1))hjjhlpjjtopjj¬µpii::ap(4))hbqjjhlcjjtop::scjj¬µpi|{z}
sqi::aq(10)
or
hbÔ¨Årst(main)jjVi
13)nphreturn t
|{z}
bpjjhlpjjtop::spjj¬µpi|{z}
spi::call timez}|{
h!!b0
1b0
m0jjhlcjjscjj¬µcii::aq
|{z}
ap
(1))hjjhlpjjtopjj¬µpii::ap(4))h!!b0
1b0
m0jjhlcjjtop::scjj¬µpii::aq
(6))hbqjjhlcjjtop::scjj¬µpi|{z}
sqi::aq
where, in the latter case, by maximality of np, we have bq=b0
h
for a suitable 1hm0. We only prove the case for (10), the
other being similar. Consider conÔ¨Åguration call time. Since
only rule (2) can stack conÔ¨Ågurations, it was on top when a call
was executed and (10) must have the form
hbÔ¨Årst(main)jjVi
)nchcall k1:m:::kn:m@c
ins q@q
rest q!!b0
1b0
m0jjhlcjjvp 1::::v1::rec::scjj¬µci|{z}
sci::aq
(2))hÔ¨Årst(kw:m)jjh[rec::v1::::vp 1]jjejj¬µcii::ap
)np nc 1hbpjjspi::ap(1))hjjhlpjjtopjj¬µpii::ap(4))hbqjjsqi::aq
for a suitable 1wn, where the rules in the portion )np nc 1
never make the stack lower than at the beginning of that portion.
By inductive hypothesis for npandnc, we know that (9) holds for
both pandc. Since it holds for pand the memory in sqis¬µp, we
conclude that
a(sq)(fk)S(fk@ew)for all Ô¨Åelds fk.
Since it holds for c, since the Ô¨Åelds of an object can only be ini-
tialized during the execution of the program (Section 4) and since
ic=iq, we conclude that
a(sq)(lk)a(sc)(lk)S(lk@c)for all 0k<iq
a(sq)(sk)a(sc)(sk)S(sk@c)for all 0k<jq 1:
By DeÔ¨Ånition 8, we have S(lk@c)S(lk@q)for all those lkfor
which an arc lk@c!lk@qis built (similarly for sk). For them we
havea(sq)(lk)S(lk@q)anda(sq)(sk)S(sk@q). For the lk
that, instead, at call-time, are deÔ¨Ånite alias of an actual parame-
tersjc u 1of the call and such that the corresponding formal
parameter lp u 1is never modiÔ¨Åed inside kw:m, by inductive hy-
pothesis for npwe know that
a(sq)(lk) =a(sp)(lp u 1)S(lp u 1@p)
(similarly for sk). By DeÔ¨Ånition 8, there is an arc of the form
lp u 1@end of kw:m!lk@qamong the constraints for program
P. Since ins pis areturn t, there is also an arc lp u 1@p!
lp u 1@end of kw:m. Hence
a(sq)(lk)S(lp u 1@p)S(lp u 1@end of kw:m)S(lk@q)
and similarly for skwith 0k<sjq 1. It remains to prove the
same result for sjq 1, that is, for the returned value. By induc-
tive hypothesis for npwe know that a(sp)(sjp 1)S(sjp 1@p).
By DeÔ¨Ånition 8, there are arcs sjp 1@p!return @kw:mand
return @kw:m!sjc p@q. Moreover, jc=jq 1+pso that
jc p=jq 1. We conclude that
a(sq)(sjq 1) =a(sp)(sjp 1)S(sjp 1@p)
S(return @kw:m)S(sjc p@q) =S(sjq 1@q):case c: ins pis athrow k
Ifrest pis empty and m0>0, the execution (8) must have the form
hbÔ¨Årst(main)jjVi)nphthrow k
|{z}
bp!!b0
1b0
m0jjhlpjje::spjj¬µpi|{z}
spi::ap
(1))h!!b0
1b0
m0jjhlpjjejj¬µpi
|{z}
sqi::ap(6))hbqjjsqi::ap|{z}
aq
where, by maximality of np, we have bq=b0
hfor a suitable 1
hm0. If rest pis non-empty, the execution (8) must have the
form
hbÔ¨Årst(main)jjVi)nphthrow k
catch
rest q
|{z}
bp!!b1bmjjhlpjje::spjj¬µpi|{z}
spi::ap
(1))hcatch
rest q
|{z}
bq!!b1bmjjhlpjjejj¬µpi
|{z}
sqi::ap|{z}
aq
since catch is the only bytecode whose semantics can be deÔ¨Åned
on the exceptional state sq. In both these cases, by inductive hy-
pothesis for npand Lemma 1, we have the thesis.
Ifrest pis empty and m0=0, the execution (8) must have one of
these two forms, depending on the emptiness of block bin (5):
hbÔ¨Årst(main)jjVi
)nphthrow k
|{z}
bpjjhlpjje::spjj¬µpi|{z}
spi::call timez}|{
hbqjjhlqjjsqjj¬µqii::aq|{z}
ap
(1))hjjhlpjjejj¬µpii::ap(5))hbqjjhlqjjejj¬µpi
|{z}
sqi::aq(11)
or
hbÔ¨Årst(main)jjVi
)nphthrow k
|{z}
bpjjhlpjje::spjj¬µpi|{z}
spi::call timez}|{
h!!b0
1b0
m0jjhlqjjsqjj¬µqii::aq
|{z}
ap
(1))hjjhlpjjejj¬µpii::ap(5))h!!b0
1b0
m0jjhlqjjejj¬µpi
|{z}
sqi::aq
(6))hbqjjhlqjjejj¬µpi
|{z}
sqi::aq
where, by maximality of np, we have bq=b0
hfor a suitable 1
hm0. We only prove the case (11), the other being similar.
Consider conÔ¨Åguration call time. Since only rule (2) can stack
conÔ¨Ågurations, it was on top when a call was executed and (11)
must have the form
hbÔ¨Årst(main)jjVi
)nchcall k1:m:::kn:m@c
ins q@q
rest q!!b0
1b0
m0jjhlqjjvp 1::::v1::rec::sqjj¬µqi|{z}
sci::aq
14(2))hÔ¨Årst(kw:m)jjh[rec::v1::::vp 1]jjejj¬µqii::hbqjjhlqjjsqjj¬µqii::aq
)np nc 1hbpjjspi::ap(1))hjjhlpjjejj¬µpii::ap(5))hbqjjsqi::aq:
Since insq(sq)is deÔ¨Åned and sq2X, the only possibility is that
ins qis acatch (it is the only bytecode deÔ¨Åned on exceptional
states). By DeÔ¨Ånition 8, the constraints for program Pmust in-
clude the arcs lk@c!lk@q. By inductive hypothesis (9) for nc,
we know that a(sc)(lk)S(lk@c)for 0k<ic=iq. Since
the Ô¨Åelds of an object can only be initialized during the execu-
tion of the program, by inductive hypothesis for ncwe conclude
thata(sq)(lk)a(sc)(lk)S(lk@c)S(lk@q)(because of
the arc lk@c!lk@q). Consider now s0=e, the only stack ele-
ment of sq. We have a(sq)(s0) =a(sp)(sjp 1)S(sjp 1@p)
(by inductive hypothesis for np). By DeÔ¨Ånition 8, there are arcs
sjp 1@p!exception @kw:mandexception @kw:m!s0@qin
the constraints for program P. Then a(sq)(s0)S(sjp 1@p)
S(exception @kw:m)S(s0@q). Finally, by inductive hypothe-
sis for npwe know that a(sp)(fk)S(fk@ew)for all Ô¨Åelds fk.
Since the memory of sqis still ¬µp, we conclude that a(sq)(fk)
S(fk@ew)for all Ô¨Åelds fk.
Rule (2).By deÔ¨Ånition of makescope , (8) must have the form
hbÔ¨Årst(main)jjVi)np
hcall k1:m:::kn:m@p
rest p
|{z}
bp!!b0
1b0
m0jjhlpjjvp 1::::v1::rec::sjj¬µpi|{z }
spi::ap
(2))hÔ¨Årst(ki:m)|{z}
bqjjh[rec::v1::::vp 1]jjejj¬µpi|{z}
sqi::aq:
Since spandsqhave the same memory ¬µp, for the shape of
their stack and local variable array we have a(sq)(lp u 1) =
a(sp)(sjp u 1)for every 0u<p. By DeÔ¨Ånition 8, the con-
straints for program Pinclude the arcs sjp u 1@p!lp u 1@q,
since qis the program point at the beginning of block Ô¨Årst(ki:m).
By inductive hypothesis for npwe conclude that
a(sq)(lp u 1)=a(sp)(sjp u 1)S(sjp u 1@p)S(lp u 1@q)
for every 0u<p. Since iq=p, we conclude that
a(sq)(lk)S(lk@q)
for every 0k<iq. The same result for skis vacuously true
since jq=0. For the Ô¨Åelds, we observe that spandsqhave the
same memory ¬µp. From the inductive hypothesis (9) for np, we
conclude that a(sq)(fk) =a(sp)(fk)S(fk@ew)for all Ô¨Åelds
fk.
Rule (3).Then (8) must have the form
hbÔ¨Årst(main)jjVi)np
hcall k1:m:::kn:m@p
rest p
|{z}
bp!!b0
1b0
m0jjhlpjjvp 1::::v1::null ::sjj¬µpi|{z }
spi::ap
(3))h rest p!!b0
1b0
m0|{z}
bqjjhlpjj`jj¬µp[`7!npe]i
|{z}
sqi::aq
when rest pis non-empty, while otherwise it has the form
hbÔ¨Årst(main)jjVi)nphcall k1:m:::kn:m@p
|{z}
bp!!b0
1b0
m0jjhlpjjvp 1::::v1::null ::sjj¬µpi|{z }
spi::ap
(3))h!!b0
1b0
m0jjhlpjj`jj¬µp[`7!npe]i
|{z}
sqi::aq(6))hbqjjsqi::aq
where, by maximality of np, we have bq=b0
hfor a suitable 1
hm0. In both cases, we know that `is fresh and npeis a
NullPointerException object with no uninitialized Ô¨Åelds. More-
over, sq2Xand hence ins qmust be a catch (it is the only byte-
code that is deÔ¨Åned on an exceptional state). By DeÔ¨Ånition 8,
there are arcs lk@p!lk@qfor 0k<ip=iq. We also know
thatspandsqhave the same memory ¬µp. By inductive hypothe-
sis (9) for np, we have
a(sq)(lk@q) =a(sp)(lk@p)S(lk@p)S(lk@q):
The state sqhas only one stack element `. Since npehas no unini-
tialized Ô¨Åelds, we have a(sq)(s0) =/0S(s0@q). Since spand
sqhave the same memory ¬µpand by inductive hypothesis for np,
we have a(sq)(fk) =a(sp)(fk)S(fk@ew)for all Ô¨Åelds fk.
Rules (4),(5)and(6).They cannot be applied since bpis non-
empty.
15