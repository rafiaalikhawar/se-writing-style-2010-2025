Reconciling Manual and Automatic Refactoring
Xi Ge Quinton L. DuBose Emerson Murphy-Hill
Department of Computer Science, North Carolina State Unive rsity, Raleigh, NC
{xge, qldubose }@ncsu.edu, emerson@csc.ncsu.edu
Abstract —Although useful and widely available, refactoring
tools are underused. One cause of this underuse is that a
developer sometimes fails to recognize that she is going to
refactor before she begins manually refactoring. To address this
issue, we conducted a formative study of developers’ manual
refactoring process, suggesting that developers’ reliance on
“chasing error messages” when manually refactoring is an
error-prone manual refactoring strategy. Additionally, our
study distilled a set of manual refactoring workﬂow patterns.
Using these patterns, we designed a novel refactoring tool
called BeneFactor. BeneFactor detects a developer’s manual
refactoring, reminds her that automatic refactoring is available,
and can complete her refactoring automatically. By alleviating
the burden of recognizing manual refactoring, BeneFactor is
designed to help solve the refactoring tool underuse problem.
I. I NTRODUCTION
Software is expensive to maintain. As software ages, it
must be maintained to reﬂect evolving user requirements;
this maintenance accounts for between 40 and 75% of the
total cost of software [7]. One of the primary ways that
software developers maintain software is through refactor-
ing, the process of changing the structure of code without
changing the way that it behaves [8].
Refactoring is both an effective and commonplace way
of improving non-functional requirements. Empirical stud ies
of refactoring have found that it can improve maintain-
ability [12] and reusability [14]. Not only does existing
work suggest that refactoring is useful, but it also suggest s
that refactoring is a frequent practice [17]. Cherubini and
colleagues’ survey indicates that developers rate the im-
portance of refactoring as equal to or greater than that of
understanding code and producing documentation [3].
However, refactoring by hand has long been assumed
to be error-prone. In order to help developers perform
efﬁcient and correct refactoring, various refactoring too ls
have been developed. These tools promise to help developers
refactor faster and with a smaller probability of introduci ng
defects. Refactoring tools have been integrated into most
popular development environments, making them available
in a variety of programming languages to a large population
of developers. Despite the wide availability, our previous
work shows that refactoring tools are underused; according
to two case studies, about 90% of refactorings are performed
by hand [17].Several solutions have been proposed to solve the un-
deruse problem. For example, tools with improved user
interfaces can make refactoring tools more usable [15].
Other novel tools have supported new, specialized types of
refactoring [1][4]. Other research has proposed automatic
testing to make refactoring tools more reliable [5][6].
Such solutions make one common assumption: That the
software developer recognizes that she is going to refactor
before she even begins. This assumption is false when a
developer has already started a refactoring manually by the
time she realizes that she is refactoring. One developer
outlined this situation in an interview [17] as:
I already know exactly how I want the code to look
like. Because of that, my hands start doing copy-
paste and the simple editing without my active
control. After a few seconds, I realize that this
would have been easier to do with a refactoring
[tool]. But since I already started performing it
manually, I just ﬁnish it and continue.
This situation illustrates how refactoring tools do not sup port
the developer when she does not realize she is refactoring
until after she has already begun. Without that realization , a
software developer will not use any the refactoring tool, no
matter how usable, useful, or reliable that tool is.
In this paper, we investigate how to design a refactoring
tool that is aware of a developer’s refactoring, rather than
relying on the developer’s recognition of it. In Section III
we describe a formative study about developers’ manual
refactoring. Building on the study’s results, in Section IV
we designed a novel refactoring tool. We make the following
major contributions in this paper:
•A formative study of developers’ manual refactoring.
To the best of our knowledge, we are the ﬁrst to study
developers’ manual refactoring process. Our study sug-
gests that reliance on compiler errors when manually
refactoring is a common and error-prone technique.
•A proof-of-concept refactoring tool called BeneFactor.
In addition to relieving the developer from the burden
of recognizing that she is going to refactor, BeneFactor
also allows implicit refactoring conﬁguration and the
interleaving of refactoring and non-refactoring changes.978-1-4673-1067-3/12/$31.00 c2012 IEEE ICSE 2012, Zurich, Switzerland 211
II. M OTIVATION
To use a refactoring tool, a developer must recognize that
she is refactoring and select the appropriate refactoring w ith
a menu or a hotkey. If she is unaware that she is refactoring
and begins to refactor manually, she may become aware that
she is refactoring part way through the manual refactoring.
In this case, the developer faces the late awareness dilemma:
She must either undo all the code changes that she has
already made and then invoke the refactoring tool, or keep
refactoring manually until the refactoring is complete.
We next illustrate this dilemma using two examples. Sup-
pose Grace is a developer who works on the Apache Tomcat
open source project [2]. To improve understandability, she
wants to change the name of a local variable descs to
descriptors . She starts doing this task manually from the
declaration of descs towards the tenth and last reference to
descs . After changing six names (as shown in Figure 1)
she realizes that she is performing a rename refactoring.
Grace decides it would be easier to just ﬁnish the refactorin g
manually, even at the risk of introducing a bug.
Figure 1: Rename local variable refactoring example.
Late awareness of refactoring occurs for other refactoring
types as well. Suppose that Glen is a developer who works
on the Vuze project [25]. He notices that the getRequested-
PieceNumbers() method shown in Figure 2 contains three for
loops that are nearly identical. To enhance maintainabilit y,
he intends to extract the loop as a new helper method.
Glen starts by cutting the code in the third loop, and
then declares the helper method getRequestedPieceNum-
bersHelper() . Glen then realizes that he is performing the
extract method refactoring, and that he would like to have
a refactoring tool ﬁgure out what variables to pass in to the
method. To do so, he undoes his changes and invokes the
extract method tool, even though he has to conﬁgure the
refactoring tool with the name of the helper method, which
he already speciﬁed once while manually refactoring.
Figure 2: Extract method refactoring example.
III. F ORMATIVE STUDY
In order to resolve the late awareness dilemma, we intend
to build a novel refactoring tool that can complete manual
refactorings. However, three important research question s
must be answered ﬁrst:
•RQ1. How correctly do developers refactor manually?
If developers mistakenly modify program behavior
when refactoring manually, then refactoring tools can
potentially improve the refactoring process.
•RQ2. How signiﬁcant is the late awareness problem?
If many developers do not recognize that they are
refactoring before they begin, then the late awareness
is a contributor to refactoring tool underuse.
•RQ3. What are developers’ manual refactoring work-
ﬂows? To create a refactoring tool that can complete
refactorings automatically, the tool must be able to
recognize when a developer is refactoring. Models
of manual refactoring workﬂows will help our tool
recognize when a developer is refactoring.
We conducted a formative study to answer these questions.
A. Participants and Refactorings
We recruited 12developers to participate in our study. Six
were graduate students and ﬁve were commercial software
developers. We also recruited one refactoring researcher ( not
one of the authors) who has current development experience212of more than ten years. Although we did not collect all of
the participants’ demographic information, at least 10of the
12participants had professional programming experience of
more than four years.
We asked participants to perform refactorings in the
source code of the Vuze [25] project. We chose this project
is for its large size and maturity.
We manually inspected the source code of Vuze, then lo-
cated fourteen locations where refactoring could reasonab ly
be performed. At each of the fourteen locations, we asked
participants to perform one refactoring without the assist ance
of any refactoring tools. Among the fourteen refactorings,
we chose three that were especially complex: A rename
local variable refactoring, an extract method refactoring and
a change method signature refactoring. When performing
these complex refactorings, participants needed to carefu lly
consider how to avoid changing program behavior. We
describe the complex refactorings in detail in Section III- C1.
The fourteen refactorings spanned 8refactoring types:
Rename ( 2), extract constant ( 1), extract local variable ( 2),
inline local variable ( 2), change method signature ( 2), extract
method ( 2), introduce parameter ( 2), and pull up method
(1). We chose these types from the types listed in Fowler’s
catalog [8] according to three criteria. The ﬁrst is their
frequency in real world. According to our previous research ,
using automatic tools to perform rename, extract local vari -
able, inline, extract method, and change method signature
accounts for over 85% of all refactoring tool usage [17]. This
high tool usage suggests that these refactoring types occur
frequently. Simplicity is the second criterion because sim ple
refactorings would be easier for participants to complete i n
a short study session. The third criterion is wide coverage o f
a variety of software entities, such as constants, temporar y
variables, local variables, ﬁelds, and methods. We also cho se
pull up method because it involved class inheritance.
B. Data Collected
We collected data using a pre-study questionnaire, videos
of participants’ manual refactorings, and a post-study que s-
tionnaire. To view the participants’ refactoring videos an d
their answers to the questionnaires, the reader can refer to
our study material website.1
1) Pre-study Questionnaires: We recruited developers
through email. If they were willing, we sent them a consent
form and pre-study questionnaire. One subject consented,
but did not ﬁll out the remainder of the questionnaire. We
asked the following questions in the questionnaire:
•Coding experience: About what percentage of your job
involves writing code?
•Java proﬁciency: How proﬁcient are you with the Java
programming language, rating from 1to5(1for not at
all and 5for expert)? Participants produced a slightly
1https://sites.google.com/site/refactoringstudy/skewed distribution of Java experience (median=3.5),
with all participants reporting at least some experience
and two participants considering themselves experts.
•Refactoring familiarity: How familiar are you with the
practice of refactoring, rating from 1to5(1for “not
at all” and 5for “I refactor every time I program”)?
Participants produced a fairly normal distribution of
refactoring experience (median=3).
To perform the study, participants connected to a remote
computer running the Eclipse IDE and containing the code
to be refactored. Using the online screen sharing service
join.me [10], participants could easily view and operate
Eclipse. At the same time, we established a Skype [21]
conversation with the participant to give them directions.
2) Observing Manual Refactoring: After setting up
screen sharing, we opened the ﬁrst code location where we
wanted the participant to perform a refactoring. We told
the participant which refactoring we wanted her to perform
and that no automatic refactoring tools were allowed. If
the participant was unfamiliar with the refactoring, we gav e
her an explanation of what the resulting code should look
like. We were careful to avoid telling the participant how to
perform each refactoring. Once we had answered all of the
participants’ questions about the task, we asked her to star t.
We repeated this process with all 14refactorings. While
the participant was performing these refactorings, we used
screen capture software to record the entire process, which
we analyzed after the study session ended.
To analyze each refactoring, we tagged it as either “cor-
rect,” “incorrect,” or “unknown.” “Correct” meant that the
participant’s refactoring resulted in the code structure t hat
met with Fowler’s deﬁnition [8] and did not modify the
software’s behavior. “Incorrect” indicated that the softw are’s
behavior was modiﬁed, but the participant’s refactoring
resulted in a code structure that met with Fowler’s deﬁnitio n.
Refactorings tagged as “unknown” included those that the
participant skipped; those that were ﬁnished only with our
detailed guidance (we guided some participants to spare
them the embarrassment of not being able to complete the
task); those that were ﬁnished by invoking refactoring tool s;
and those that we were not able to tell whether the new code
structure met with Fowler’s deﬁnition. Only refactorings
tagged as “correct” and “incorrect” were used in our analysi s
of refactoring workﬂows.
3) Post-study Questionnaire: After the study, we pre-
sented each participant with a questionnaire that asked the
following questions:
•Q1. How often does this situation occur: I get part way
through a code change when I realize there is a refac-
toring tool that can help me do the job. Choose from
one of the following words: Never, rarely, sometimes,
often, and always.213Figure 3: Code illustrating a complex refactoring.
•Q2. What would you do after the situation in Q1
happens? Options: (1) I ﬁnish the change without a
refactoring tool; (2) Back out of the change and redo
the change using a refactoring tool; or (3) Other.
C. Results
1) RQ1. Refactoring Correctness: Our previous research
suggests that developers may rely on compilation errors
to locate the related code to update [17]. For example, in
Figure 1, Grace is using the compilation errors to determine
what parts of the code needs to be updated. However, this
strategy is sometimes error prone because compilation erro rs
do not indicate every location that needs to be updated
for certain complex refactorings. We had participants per-
form three of these complex refactorings to determine to
what extent they used this strategy. Overall, participants
inadvertently changed behavior in eleven of the fourteen
refactorings, and very few ﬁnished participants completed
complex refactorings them correctly.
Complex Refactoring 1: We asked participants to per-
form the complex extract method refactoring shown in
Figure 2. If a developer extracts the last forloop into a
new method, the new method should return the value of
pos because the extracted forloop modiﬁes the value of
pos and the code in the original method later reads the
value. However, compilation errors do not result if posis
not returned, so relying on error messages for this part of
the refactoring is not sufﬁcient for a correct refactoring.
Only one participant correctly performed the complex
extract method refactoring, while seven performed it incor -
rectly because of failing to return the value.
Complex Refactoring 2: We asked participants to per-
form a rename local variable refactoring on code that is
summarized in Figure 3. We asked the participants to rename
lifehours tooriginal republish interval , which is also the
name of a ﬁeld of the containing class. If a developer
renames lifehours tooriginal republish interval in the dec-
laration, names in checkCacheExpiration(. . . ) that originally
bound to the ﬁeld original republish interval now bind toTable I: Questionnaire results.
Pre-study questionnaire Post-study questionnaire
Coding Java Refactoring Late Handle late awareness
experience proﬁciency familiarity awareness Manual Tool Others
80% 4 4 sometimes 100% 0% 0%
90% 4 3 sometimes 100% 0% 0%
40% 3 2 often 80% 20% 0%
75% 5 3 sometimes 65% 35% 0%
100% 4 4 rarely 80% 20% 0%
70% 5 5 often 40% 30% 30%
the local variable. No compilation error is generated when
the rebinding occurs.
No participant correctly performed complex rename local
variable refactoring, while nine performed it incorrectly .
Complex Refactoring 3: We asked participants to per-
form a change a method signature refactoring by swapping
the order of two parameters. More speciﬁcally, we asked
them to refactor setUserData(Object key, Object value) to
setUserData(Object value, Object key) ). If a developer swaps
these parameters in the method declaration, no compiler
errors are shown because all invocations of this method stil l
had arguments of correct types.
One participant performed this complex refactoring cor-
rectly, while two performed it incorrectly.
Summary: Across the three complex refactorings, 90%
were performed incorrectly. It appeared that developers
relied on compiler errors for refactoring, even in situatio ns
where that reliance was misplaced. Somewhat surprisingly,
participants also made mistakes in the non-complex refac-
torings. In total, participants completed 96non-complex
refactorings, and 21(22%) of them were incorrect. Most
of these incorrect refactorings resulted from participant s’
failing to address all compiler errors.
In addition to these results, we also observed another
problematic manual refactoring technique. When performing
the rename ﬁeld refactoring, four of the eleven participant s
invoked the “ﬁnd and replace all” tool, replacing all of the
occurrences of the original ﬁeld name in the ﬁle. Although
this technique did not happen to modify behavior in the
given code, this technique is generally unsafe because the
original name may also occur in other places not referring
to the ﬁeld, such as in a method name.
2) RQ2. Late Awareness: How signiﬁcant is the late
awareness problem? We answer this question by using
participants’ post-study questionnaires.
Among the 12participants recruited in our formative
study, six returned their post-study questionnaires. Tabl e I
shows the answers of these participants to each question
we asked.2Five of the six participants indicated that late
awareness of refactoring tools happens to them at least
“sometimes.” Two of these ﬁve participants indicated that
2The ﬁrst row shows the refactoring researcher’s answers.214late awareness of refactoring happens to them “often”. This
suggests that the late awareness problem may happen to a
variety of programmers.
Participants reported that when late awareness occurs,
a median of 80% of the time they ﬁnish the refactoring
manually. One participant indicated that she handles late
awareness through other means, but did not elaborate.
3) RQ3. Refactoring Workﬂow Patterns: What are the
developers’ manual refactoring workﬂows? To investigate
this question, we studied the videos of participants perfor m-
ing the refactorings. We distilled a set of widely adopted
refactoring workﬂows for each refactoring type, which we
refer to as refactoring workﬂow patterns. We modeled these
patterns using ﬁnite-state machines (FSMs) over a set of pa-
rameterized elementary operations to facilitate represen tation
and interpretation.
We use operations on abstract syntax tree (AST) nodes to
model refactoring workﬂow patterns. ASTs are tree repre-
sentations of the syntactic structure of source code writte n
in a programming language. Nodes inside an AST represent
software entities at various levels, such as variables, ﬁel ds,
statements, methods, and classes. We use the following
operations on the AST nodes to model our refactoring
workﬂow patterns:
•COP (x); copy node x’s source code to the clipboard.
•CUT (x); cut node x’s source code and keep it in the
clipboard.
•INS (x); insert node xinto the AST, possibly via a
Paste command.
•UPD (x); update the value of node x.
Inspired by regular expressions, we also deﬁne the fol-
lowing quantiﬁers:
•OP(x∗)indicates performing operation OPon zero or
more nodes xsimultaneously.
•OP(x)∗indicates performing OP on zero or more
nodes xsequentially.
•OP(x+)indicates performing operation OPon one or
more nodes xsimultaneously.
•OP(x)+indicates performing OP on one or more
nodes xsequentially.
Due to space limitations, we present the refactoring work-
ﬂow patterns for only rename ﬁeld and extract method, two
common refactorings [17]. For refactoring workﬂow pattern s
for other refactoring types, the reader can refer to our stud y
material website mentioned in Section III-B.
Rename Field: Participants had similar workﬂows
when manually performing the rename ﬁeld refactoring.
Eleven rename ﬁeld refactorings that were considered usabl e
(that is, correct and incorrect). Each participant used one of
two patterns:
•Seven participants ﬁrst updated the name of the ﬁeld in
its declaration, and then iteratively updated the names
of all the references to this ﬁeld. We modeled thisinit 7 UPD(Declaration) 
/f_inal 4 UPD(Name+) 7 UPD(Reference) 
7 [All updated] 
Figure 4: Refactoring patterns for rename ﬁeld.
workﬂow by the upper transitions (red) in Figure 4.
In the Figure, the number on a transition indicates the
number of participants following that transition, while
the square brackets indicate a conditional transition.
•Four participants invoked the “ﬁnd and replace” tool
to automatically replace all of the occurrences of the
ﬁeld’s name. We modeled this workﬂow by the lower
transition (blue) in the Figure 4.
Extract Method: We collected ten usable extract
method refactorings. Participants adopted several workﬂo ws
when performing extract method. Three workﬂows were
common to multiple participants:
•Two participants ﬁrst copied the statements to extract,
made a new method declaration, pasted the statements
into the new method body, added parameters to the new
method declaration, and ﬁnally replaced the statements
to extract with the new method invocation. We modeled
this workﬂow by the upper transitions (red) in Figure 5.
•Two participants ﬁrst cut the statements to extract,
made a new method declaration, pasted the statements
into the new method body, added parameters to the
new method declaration, and ﬁnally inserted the new
method invocation to the place where the extracted
statements were. We modeled this workﬂow by the
middle transitions (blue) in Figure 5.
•Two participants ﬁrst added a new method invocation
near the statements to extract, cut the statements to
extract, made the new method’s declaration, pasted
the statement into the new method body, and ﬁnally
added parameters to the new method declaration. We
modeled this workﬂow by the lower transitions (green)
in Figure 5.
We also observed the other four patterns (not shown in
Figure 5) adopted by one participant each:
•One participant ﬁrst added a new method declaration
after the method of the statements to extract, copied the
statements to extract, pasted these statements into the
new method body, replaced these statements with the215init 2 COP(St+) 
2 CUT(St+) 
2 INS(MI) 2 INS(MD) 
2 INS(MD) 
2 CUT(St+) 2 INS(St+) 
2 INS(St+) 
2 INS(MD) 2 INS(Pa)* 
2 INS(Pa)* 
2 INS(St+) 2 DEL(St+) 
/f_inal 2 INS(MI) 
2 INS(Pa)* 
Figure 5: Refactoring patterns for extract method.
new method’s invocation, and ﬁnally added parameters
to the new method declaration.
•One participant ﬁrst cut the statements to extract, added
a new method invocation at these statements’ original
place, added a method declaration after the statements’
original method, pasted the statements to extract into
the new method body, and ﬁnally add parameters to
the new method declaration.
•One participant ﬁrst cut the statements to extract, pasted
these statements after their original method, surrounded
these statements by a new method name and brackets,
added parameters to the new method declaration, and
ﬁnally inserted the new method invocation at the ex-
tracted statements’ original place.
•One participant ﬁrst copied the statements to extract,
added a method declaration below these statements
(inside their containing method), pasted the statements
into the new method declaration, cut the new method
declaration, pasted the new method declaration after
the method containing the statements to extract, added
parameters to the new method declaration, and ﬁnally
replaced the statements to extract with the invocation
of the new method.
These patterns suggest that developers manually refactor
using only a few different basic actions, but interleave tho se
actions in a variety of ways.
D. Threats to Validity
Although our formative study provides data on how devel-
opers manually refactor, there are several threats to valid ity
that should be considered when interpreting our results.
The ﬁrst threat is the criteria we used to choose refactoring
types. We chose the refactoring types whose tools are used
more frequently, yet these types of refactorings were not
always the most underused refactoring tools. In the future,
we would like to perform the study with refactoring types
for which the corresponding tool is the most underused.
Another threat is the number of participants in our study,
and that not all participants produced usable data for every
refactoring. Thus, we cannot make strong claims about how
our results generalize to other developers. For example,
some additional refactoring patterns may exist that were no texhibited by our participants. However, we believe that the
results provide a sufﬁcient starting point to begin buildin g a
proof-of-concept refactoring tool, as described in Sectio n IV.
Similarly, the selected refactorings may not be representa tive
of all refactorings performed in the wild.
Another signiﬁcant threat is that participants’ attitude
toward refactoring third-party software may be different
than their attitude towards refactoring their own software .
Speciﬁcally, because participants have no investment in
the third-party code, they may be less concerned about
introducing behavior-modifying changes, as compared to
their own code. This would cause our study to overestimate
how often refactoring errors are made. It is also possible th at
participants exercised more diligence in refactoring corr ectly
in the study, since they were not distracted by other coding
tasks. This would cause our study to underestimate how
often refactoring errors are made. In either case, a ﬁeld stu dy
may be able to shed more light onto the frequency of errors
made during manual refactoring.
IV. A PPROACH
According to our formative study, manual refactoring
can be an error-prone task (RQ1). Although conventional
refactoring tools are available to assist the developers pe r-
forming safe and efﬁcient refactoring, they are signiﬁcant ly
underused [17]. This underuse problem partially results fr om
the developers’ late awareness of refactoring (RQ2). In
order to tackle this problem, we propose a novel refac-
toring tool called BeneFactor that is built on our distilled
refactoring workﬂow patterns (RQ3). Unlike conventional
refactoring tools, BeneFactor automatically detects an on -
going manual refactoring, reminds the developers that au-
tomatic refactoring is available, and can ﬁnish the manual
refactoring after the developer’s explicit invocation wit h-
out requiring her to undo any code changes. Implemented
as a plug-in for the Eclipse IDE, a prototype of Bene-
Factor can be downloaded here: http://code.google.com/p/
ﬂexible-refactoring-tools/. BeneFactor has two major com -
ponents: Refactoring detection and code modiﬁcation.
A. Refactoring Detection
In order to assist the developer in recognizing that she
is refactoring, we designed a refactoring detection com-216ponent. In contrast to existing refactoring detection tool s
(for example, RefacLib [22] and REF-FINDER [18]), our
refactoring detection component detects refactoring whil e
the developer is programming, rather than in the version
control system. Moreover, BeneFactor detects ongoing and
unﬁnished refactorings, rather than completed ones.
The refactoring detection component runs in the back-
ground of the IDE and continuously captures the developer’s
operations on the code base. It collects two kinds of opera-
tions:
•Code-change based operations are detected by compar-
ing subsequent snapshots of code base. These snapshots
are captured after certain developer events, such as
adding a statement, deleting a ﬁeld declaration, and
updating a variable name.
•Action-based operations are detected by monitoring the
commands a developer executes, such as copying a
statement and cutting a method declaration.
The refactoring detection component detects an ongoing
refactoring by matching the operations performed by a
developer against the transitions in the manual refactorin g
workﬂow patterns from our formative study. If a developer’s
operations match with a preﬁx of refactoring type R’s
workﬂow pattern, she may be performing a refactoring of
typeR. If her operations continue to match the same pattern,
our conﬁdence that she is actually refactoring increases;
otherwise the conﬁdence decreases. When the conﬁdence
exceeds a predeﬁned threshold T, the refactoring detection
component concludes that the developer is manually per-
forming a refactoring of type Rand offers a quick-ﬁx to
help her ﬁnish it.
We next illustrate our refactoring detection algorithm
through a pseudo code example shown in Program 1. This
example outlines detecting the rename ﬁeld refactoring by
using the refactoring workﬂow pattern illustrated in the
upper transitions (red) in Figure 4. The value of conﬁdence
indicates the numbers of consecutive matches between a
developer’s operations and the states of the workﬂow patter n.
The algorithm detects an ongoing rename refactoring when
the value of conﬁdence is above a predeﬁned Threshold (line
22). We currently use a threshold value of 1, resulting in the
highest sensitivity of the detection algorithm.
If the refactoring detection component detects an ongoing
refactoring, our Eclipse plugin adds a quick-ﬁx button at th e
line of code where the developer made the latest change. The
quick-ﬁx button offers a user interface affordance to allow
BeneFactor to ﬁnish the refactoring.
B. Code Modiﬁcation
If the developer invokes BeneFactor to ﬁnish her man-
ual refactoring, BeneFactor’s code modiﬁcation component
makes the requested change. At a high level, the code mod-
iﬁcation component captures any information the developer1 c o n f i d e n c e = 0 ;
2 c u r r e n t s t a t e = i n i t ;
3while (true ){
4 o p e r a t i o n = W a i t f o r O p e r a t i o n ( ) ;
5 i f( o p e r a t i o n . i s U p d a t e ( )
6 && o p e r a t i o n . Node . isName ( )
7 && o p e r a t i o n . Node . P a r e n t .
8 i s F i e l d D e c l a r a t i o n ( ) ) {
9 c o n f i d e n c e ++;
10 c u r r e n t s t a t e = two ;
11 d e c l a r a t i o n = o p e r a t i o n . Node ;
12}
13 e l s e i f ( c u r r e n t s t a t e == two
14 && o p e r a t i o n . i s U p d a t e ( )
15 && o p e r a t i o n . Node . isName ( )
16 && ! o p e r a t i o n . Node . P a r e n t .
17 i s F i e l d D e c l a r a t i o n ( )
18 && o p e r a t i o n . bindsTo ( d e c l a r a t i o n ) )
19 c o n f i d e n c e ++;
20 e l s e i f ( c o n f i d e n c e >0)
21 c o n f i d e n c e −−;
22 i f( c o n f i d e n c e >T h r e s h o l d )
23 D e t e c t e d R e f a c t o r i n g s . add (
24 new RenameRefactoring ( b i n d i n g ) ) ; }
Program 1: refactoring detection pseudo code example
supplied while manually refactoring, recovers the code to
its original state by rolling back the manual refactoring,
and then re-applies the refactoring automatically. We disc uss
each of these steps below.
1) Conﬁguration Information Collection: The conﬁgura-
tion information collection step collects the necessary in for-
mation to perform an automatic refactoring. Some examples
of the conﬁguration information include the visibility mod -
iﬁer of the extracted method and the position of the method
in the containing class. The equivalent step in conventiona l
refactoring tools is to ask for this information via a dialog
box. But rather than asking for conﬁguration information a
second time using a dialog box, BeneFactor automatically
collects this information from the code changes that the
developer has already made.
While it is convenient to collect conﬁguration information
this way, it is not always possible to collect all informatio n
necessary to complete a refactoring. For example, if a devel -
oper invokes BeneFactor right after she cuts the statements
to be extracted, the new method’s name is not yet known.
In this situation, BeneFactor uses a default value to ﬁnish
the refactoring ﬁrst and then allows the developer to modify
the default afterwards. However, sometimes even this is not
enough. For example, when performing the move static ﬁeld
refactoring, the tool may not know the developer’s planned
destination class. In those situations, BeneFactor does no t
offer to ﬁnish a refactoring until this critical informatio n is
supplied. An alternative approach would be to collect the
missing information using a dialog box or wizard.
2) Code Recovery: The code recovery step recovers the
code base to before the manual refactoring was applied.
Undoing a manual refactoring is not a trivial task, because2171void s e l e c t i v e U n d o (
2 Stack <O p e r a t i o n >o p e r a t i o n s t a c k ,
3 R e f a c t o r i n g r e f a c t o r i n g ) {
4 Stack <Change >u n d o o p e r a t i o n s t a c k ;
5 While ( ! r e f a c t o r i n g . performedEnoughUndos ( ) ) {
6 O p e r a t i o n o p e r a t i o n = o p e r a t i o n s t a c k . pop ( ) ;
7 o p e r a t i o n . undo ( ) ;
8 u n d o o p e r a t i o n s t a c k . push ( o p e r a t i o n ) ;
9}
10while ( ! u n d o o p e r a t i o n s t a c k . isEmpty ( ) ) {
11 O p e r a t i o n o p e r a t i o n =
12 u n d o o p e r a t i o n s t a c k . pop ( ) ;
13 i f( r e f a c t o r i n g . i s R e f a c t o r i n g O p e r a t i o n ( ) )
14 o p e r a t i o n . s k i p ( ) ;
15 e l s e
16 o p e r a t i o n . g e t P a t c h . a p p l y P a t c h ( ) ; } }
Program 2: selective undo algorithm pseudo code example
the developer’s manual refactoring effort may interleave w ith
other kinds of code changes [17]. For example, when a
developer is performing a rename ﬁeld refactoring, after
renaming the ﬁeld’s declaration, she may add new statements
to the code. In this situation, arbitrarily undoing all code
changes until the beginning of the manual refactoring cause s
the developer’s non-refactoring work to be lost. To tackle t his
problem, we designed an algorithm called selective undo .
We illustrate selective undo by using the pseudo code
snippet shown in Program 2. Our selective undo algorithm
takes two parameters as input. The ﬁrst is the stack of
operations performed by the developer from the starting of
the Eclipse IDE to the moment of the algorithm’s execution,
with the latest code change at the top. The second input is
the refactoring to be completed.
In Program 2, the algorithm ﬁrst declares a local variable
undo operation stack to store all the operations that have
been undone. After the declaration, performedEnoughUndos
at line 5checks whether it needs to undo more code changes.
This method returns true if the existing automatic refactor ing
infrastructure can be applied to ﬁnish the refactoring, oth -
erwise it returns false. The implementation of performedE-
noughUndos depends on the type of refactoring. For exam-
ple, for rename refactoring, performedEnoughUndos returns
true when the name’s declaration has not been renamed;
for extract method refactoring, it returns true when the
statements to be extracted appear in their original method.
When performedEnoughUndos returns false, the selective
undo algorithm enters a loop. From line 6to line 7, the
algorithm pops the code change at the top of operation stack
and undoes it, regardless of whether or not the operation
is a refactoring operation. For every operation that has
been undone, the algorithm pushes it back to another stack
undo operation stack at line 8. The selective undo algorithm
continuously executes the code from line 6to line 8until
performedEnoughUndos returns true.
After arbitrarily undoing all of these operations, the al-
gorithm redoes only the non-refactoring operations amongthem. For each undone operation, the algorithm invokes
refactoring.isRefactoringOperation() at line 13to check
whether or not it belongs to the manual refactoring workﬂow.
refactoring.isRefactoringOperation() performs this check by
comparing the input operation with the operations in our
collected refactoring workﬂow patterns.
Ifrefactoring.isRefactoringOperation() returns true, the
algorithm skips the operation because BeneFactor will re-
apply the refactoring later, as shown at line 14. Ifrefac-
toring.isRefactoringOperation() returns false, the algorithm
reapplies this operation. Directly applying this operatio n
is unsafe because the previously skipped operations may
change the position where this operation should be applied
to. Therefore, we use the patch technique to re-apply this
operation. Widely used in source control systems, patch
allows one version to a ﬁle to be applied to the right location
in the modiﬁed version of the same ﬁle [27]. The algorithm
repeats this process from line 11to16until no operation is
left in undo operation stack .
3) Change Creation: After the code base has been recov-
ered, we perform the last step: automatically ﬁnishing the
refactoring. Eclipse ships with a set of automatic refactor ing
application programming interfaces (APIs) called the lan-
guage toolkit (LTK) [9]. Feeding the collected conﬁguratio n
information and the recovered code base as input, LTK
APIs are now able to automatically perform the intended
refactoring.
C. Example
We next illustrate how BeneFactor works by using a real-
world code example. Suppose Grace is using Eclipse with
BeneFactor installed. To enhance maintainability, she int ends
to extract the forloop in the code snippet of Figure 6
into a new method. Grace ﬁrst cuts the statement of the
forloop. BeneFactor captures this operation and detects
that the developer is possibly refactoring, and therefore
adds a marker at the line of code where Grace cuts the
statement, proposing to help her ﬁnish this refactoring, as
illustrated in Figure 7. Grace next intends to print a blank
line before the printed information in the forloop, so she
inserts System.out.println() , as illustrated by Figure 8.
Grace continues her extract method refactoring by adding
a new method declaration. She speciﬁes the visibility mod-
iﬁer, method name, and return type of the new method
declaration, as shown in Figure 9. Although interrupted
by a non-refactoring operation, Grace has performed a
sequence of operations following the refactoring workﬂow
pattern modeled by the middle transitions (blue) in Figure 5 .
Therefore, BeneFactor still detects that Grace is performi ng
an extract method refactoring. Reminded by the BeneFactor
icon, Grace realizes she can ﬁnish her manual refactoring by
invoking the tool. Hence, she chooses the quick-ﬁx item in
Figure 9 to extract the method. Finally, BeneFactor ﬁnishes
her refactoring, resulting in the code snippet shown in Figu re21810. The parameter of the extracted method is inferred by
the refactoring tool, and thus does not need to be explicitly
speciﬁed by the developer.
CachePeer[] peers = new CLCacheDiscovery().lookup(torrent);
System.out.println( “peers=”  + peers. length ); 
for (int i = 0; i<peers.length; i++){
  System. out.println(“cache:” + 
    peers[i].getAddress() + “:” + peers[i].getPort());} 
Figure 6: Code before extracting method.
CachePeer[] peers = new CLCacheDiscovery().lookup(torrent);
System.out.println( “peers=” + peers. length ); 
Figure 7: Code after cutting the statements to extract.
CachePeer[] peers =  new  CLCacheDiscovery().lookup(torrent); 
System. out.println( “peers=”  + peers. length ); 
System. out.println();
Figure 8: Code after making a non-refactoring change.
CachePeer[] peers = new CLCacheDiscovery().lookup(torrent); 
System.out.println( “peers=”  + peers. length ); 
System.out.println();
private static void printPeers
Finish extract method
Rename in /f_ile (Ctrl+2, R) 
Figure 9: Code after adding a new method declaration.
CachePeer[] peers = new CLCacheDiscovery().lookup(torrent);
System.out.println( “peers=”  + peers. length ); 
System.out.println();
printPeers (peers);
private static void  printPeers(CachePeer[] peers){
 for (int i = 0; i<peers. length ; i++){
  System. out.println( “cache:”  + 
   peers[i].getAddress() + “:” + peers[i].getPort());}}
Figure 10: Code after invoking BeneFactor.
D. Technique Challenges
While implementing BeneFactor, we faced several chal-
lenges. We believe that these challenges must be resolved
before BeneFactor can be evaluated.
False Positives: False positives in refactoring detection
refer to the situations when BeneFactor falsely assumes tha t
the developer is refactoring manually, but she is actually
not. Too many false positives may annoy the developer
with an overwhelming number of quick-ﬁx items. The false
positives may occur when (1) the developer is performingcode changes that serve partially for restructuring purpos es,
but also are intended to modify the code behavior and (2)
the default conﬁdence value is too low, resulting in an overl y
sensitive refactoring detection algorithm.
False Negatives: False negatives in refactoring detec-
tion refer to the situations when BeneFactor fails to detect
that a developer is manually refactoring. In this situation ,
the developer is not able to invoke BeneFactor to ﬁnish her
ongoing refactoring. The false negatives in refactoring de tec-
tion may be caused by: (1) A manual refactoring workﬂow
that greatly deviates from our collected manual refactorin g
workﬂow patterns; (2) A workﬂow that is dominated by non-
refactoring code changes; (3) A default conﬁdence value
that is too high, resulting in an overly insensitive refacto ring
detection algorithm.
Unresolvable Non-Refactoring Operations: As we have
mentioned, a developer’s manual refactoring operations ma y
be interleaved with operations serving some other purpose,
which we refer to as non-refactoring operations. These
non-refactoring operations are preserved during the code
recovery step. However, BeneFactor may have difﬁculty in
resolving these non-refactoring operations when they are
dependent on the interleaved refactoring.
One example of the unresolvable non-refactoring op-
eration is illustrated by Grace’s insertion of Sys-
tem.out.println(); in Figure 8. BeneFactor must ﬁgure out
the order of the inserted statement and the invocation of
the extracted method. Currently, BeneFactor assumes the
invocation happens after all the inserted statements, resu lting
in the code snippet shown in Figure 10. The developer’s
intention may have instead been to put the invocation before
the inserted statements, but BeneFactor currently has no wa y
of determining the developers’ intention.
Removing Quick-Fix Items: BeneFactor adds a quick-
ﬁx item after detecting a manual refactoring. However, it is
not trivial to decide when to remove the item. If BeneFactor
removes the item too early, the developer is not able to
invoke automatic refactoring when she later wants to. If
BeneFactor keeps the quick-ﬁx item for too long, many
quick ﬁxes may be strewn around the developer’s IDE, long
after code changes have been completed.
Scalability: We plan to enhance BeneFactor to sup-
port more types of refactorings, and as a developer uses
BeneFactor, the developer’s operations may simultaneousl y
match with workﬂow patterns of several different refactori ng
types. In this case, the developer will face multiple quick ﬁ x
options to choose from.
V.RELATED WORK
In this section, we summarize several research areas and
tools that are closely related to our work.
Empirical Studies of Refactoring . Many empirical stud-
ies have investigated refactoring. For instance, Xing and
Stroulia conducted a case study on the structural evolution219of Eclipse and concluded that refactoring is frequent [26].
Murphy-Hill and colleagues’ study of how refactoring tools
are used [17]. In contrast to existing studies, our formativ e
study focused on the process of manual refactoring.
Refactoring Detection . To help developers maintain soft-
ware, researchers proposed several algorithms for detecti ng
refactorings. For instance, Taneja and colleagues propose d
a technique called RefacLib to detect performed refactor-
ings in different versions of library ﬁles [22]. Prete and
colleagues proposed REF-FINDER that identiﬁes complex
refactorings by using template logic rules [18]. Kim and
colleagues proposed an algorithm based on heuristics to
detect rename-method refactorings between two versions of
software [11]. In contrast to these algorithms, our approac h
detects ongoing, partially-completed refactorings.
State-of-the-Art Refactoring Tools . Researchers have
proposed novel refactoring tools and guidelines for build-
ing new tools. For instance, Mealy and colleagues [13]
have distilled a list of 38usability guidelines for building
refactoring tools. Developed in parallel with BeneFactor, the
WitchDoctor tool also can help a developer automatically
ﬁnish a refactoring that was started manually [29]. The majo r
difference is that WitchDoctor uses only code changes when
specifying refactoring patterns; BeneFactor also include s
behavioral patterns, such as copying code. In some cases,
this allows BeneFactor to identify manual refactorings ear lier
than WitchDoctor would.
State-of-the-Practice Refactoring Tools . Several com-
mercial refactoring tools bear some resemblance to Bene-
Factor. For example, when you rename a variable declaration
in Eclipse, you can sometimes update all references to
that variable using a quick ﬁx. However, the rename is
purely syntactic; no safety checks are performed because
the refactoring API is not actually used. Both Refactor!
Pro [19] and ReSharper [20] can detect the ﬁrst step of a
manual refactoring workﬂow for some types of refactorings.
However, BeneFactor takes the concept further by allowing
a developer to ﬁnish her refactoring at any point in her
refactoring workﬂow.
Recommender Systems . The ﬁeld of recommender sys-
tems have been used extensively in software engineering;
speciﬁc to refactoring, such systems are known as smell
detectors [16][23][24]. They identify code that is in need
of refactoring and recommends that the developer refactor
that code. In contrast, BeneFactor detects actual refactor ings,
rather than potential refactorings; it detects refactorin g by
human operations, rather than code metrics.
Search-Based Refactoring . Search-based techniques de-
tect refactoring candidates and can refactor them automat-
ically [28]. Unlike BeneFactor, search-based refactoring is
helpful when the developer does not know what she wants
to refactor, but does not help when the developer has already
begun refactoring.VI. F UTURE WORK
Currently, BeneFactor only supports three refactoring
types: Rename, extract method and move ﬁeld. In the
future, we plan to support more refactoring types. While
BeneFactor faces several challenges (Section IV-D), we pla n
to explore solutions to tackle them. We also plan to conduct
an empirical study to investigate how BeneFactor works in
practice. We also plan to conduct a formative study with a
wider variety of programmers as participants, providing us
more conﬁdence in our refactoring workﬂow patterns.
According to our observations, sometimes developers
rely on compiler errors to help them refactor. However,
compiler errors do not reﬂect refactoring errors, making
this practice unreliable. In the future, we plan to design
a set of refactoring-aware warnings that augment compiler
errors. These warnings would warn a developer when she
violates refactoring preconditions, in a manner similar to
compiler errors. This gives developers some of the beneﬁts
of refactoring tools without forcing them to explicitly “us e
refactoring tools.”
VII. C ONCLUSION
Although refactoring tools are widely available to devel-
opers, a great portion of refactorings are still performed
by hand. Developers avoid refactoring tools partly because
of the late awareness of refactoring, that is, the situation s
when a developer recognizes she is refactoring after she has
already begun. In order to address this issue, we conducted
a formative study about developers’ manual refactoring pro -
cess. Our study suggests that manual refactoring can be an
error-prone process and that reliance on compilation error s
can hinder developers from refactoring safely. The results
conﬁrm that the late awareness of refactoring contributes t o
the refactoring tool underuse problem in the real world.
Furthermore, our formative study distills a set of manual
refactoring patterns. Building on these patterns, we prese nt
a novel refactoring tool called BeneFactor. Unlike conven-
tional refactoring tools, BeneFactor detects when a develo per
is manually refactoring, reminds her that automatic refact or-
ing is available, and can ﬁnish her refactoring automatical ly.
We believe that by alleviating developers from the burden
of recognizing when they are refactoring upfront, develope rs
will be more likely to use refactoring tools and gain the
beneﬁts that those tools provide.
ACKNOWLEDGMENTS
We thank Moin Ayazifar and Suprit Patankar for their
participation in this project. For their advice and guidanc e,
we thank Brittany Johnson, Donghoon Kim, Da Young
Lee, Yoonki Song, and Shundan Xiao. We also thank the
participants in our formative study. This research was par-
tially funded by NCSU’s Faculty Research and Professional
Development Grant.220REFERENCES
[1] A. Abadi, Y . A. Feldman, and M. Shomrat. Code-Motion for
API Migration: Fixing SQL Injection Vulnerabilities in Java .
In Proceeding of the Workshop on Refactoring Tools, pages
1-7, 2001.
[2] Apache Tomcat Open Source Project, 2011.
http://tomcat.apache.org/ .
[3] M. Cherubini, G. Venolia, R. DeLine, and A. J. Ko. Let’s
Go to the Whiteboard: How and Why Software Developers
Use Drawings . In Proceedings of the SIGCHI Conference on
Human Factors in Computing Systems, pages 557-566, 2007.
[4] K. Damevski and M. Muralimanohar. A Refactoring Tool to
Extract GPU Kernels . In Proceeding of the Workshop on
Refactoring Tools, pages 29-32, 2011.
[5] B. Daniel, D. Dig, K. Garcia, and D. Marinov. Automated Test-
ing of Eclipse and NetBeans Refactoring Tools . In Proceedings
of the Workshop on Refactoring Tools in conjunction with the
European Conference on Object-Oriented Programming, pages
42-43, 2007.
[6] B. Daniel, D. Dig, K. Garcia, and D. Marinov. Automated
Testing of Refactoring Engines . In Proceedings of the Joint
Meeting of the European Software Engineering Conference
and the ACM SIGSOFT Symposium on The Foundations of
Software Engineering, pages 185-194, 2007.
[7] J. R. Foster. Cost Factors in Software Maintenance . PhD thesis,
University of Durham, 1993.
[8] M. Fowler. Refactoring: Improving the Design of Existing
Code . Addison-Wesley Longman Publishing Co., Inc., Boston,
MA, USA, 1999.
[9] L. Frenzel. The Language Toolkit: An API for Automated
Refactorings in Eclipse-based IDEs , 2006.
[10] Join.me Remote Screen Share, 2011.
https://join.me/ .
[11] S. Kim, K. Pan, and E. J. Whitehead, Jr. When Functions
Change Their Names: Automatic Detection of Origin Relation-
ships . In Proceedings of the Working Conference on Reverse
Engineering, pages 143-152, 2005.
[12] R. Kolb, D. Muthig, T. Patzke, and K. Yamauchi. A Case
Study in Refactoring a Legacy Component for Reuse in a
Product Line . In Proceedings of the International Conference
on Software Maintenance, pages 369-378, 2005.
[13] E. Mealy, D. Carrington, P. Strooper, and P. Wyeth. Improving
Usability of Software Refactoring Tools . In Proceedings of the
Australian Software Engineering Conference, pages 307-318,
2008.
[14] R. Moser, A. Sillitti, P. Abrahamsson, and G. Succi. Does
Refactoring Improve Reusability? In Proceedings of the Inter-
national Conference on Software Reuse, pages 287-297, 2006.[15] E. Murphy-Hill and A. P. Black. Breaking the Barriers to
Successful Refactoring: Observations and Tools for Extract
Method . In Proceedings of the International Conference on
Software Engineering, pages 421-430, 2008.
[16] E. Murphy-Hill and A. P. Black. An Interactive Ambient Visu-
alization for Code Smells . In Proceedings of the International
Symposium on Software Visualization, pages 5-14, 2010.
[17] E. Murphy-Hill, C. Parnin, and A. P. Black. How We Refactor,
and How We Know It . IEEE Transactions on Software Engi-
neering, 2011.
[18] K. Prete, N. Rachatasumrit, N. Sudan, and M. Kim. Template-
based Reconstruction of Complex Refactorings . In Proceedings
of the International Conference on Software Maintenance,
pages 1-10, 2010.
[19] Refactor! Pro Add-in for Visual Studio, 2011.
http://devexpress.com .
[20] ReSharper Visual Studio Extension, 2011.
http://www.jetbrains.com/resharper/ .
[21] Skype V oice and Video Call, 2011.
http://www.skype.com .
[22] K. Taneja, D. Dig, and T. Xie. Automated Detection of API
Refactorings in Libraries . In Proceedings of the International
Conference on Automated Software Engineering, pages 377-
380, 2007.
[23] N. Tsantalis, T. Chaikalis, and A. Chatzigeorgiou. JDeodor-
ant: Identiﬁcation and Removal of Type-Checking Bad Smells .
In European Conference on Software Maintenance and Reengi-
neering, pages 329-331, 2008.
[24] E. Van Emden and L. Moonen. Java Quality Assurance
by Detecting Code Smells . In Proceedings of the Working
Conference on Reverse Engineering, pages 97-106, 2002.
[25] Vuze Open Source Project, 2011.
http://www.vuze.com/ .
[26] Z. Xing and E. Stroulia. Refactoring Practice: How it is
and How it Should be Supported-An Eclipse Case Study .
In Proceedings of the International Conference on Software
Maintenance, pages 458-468, 2006.
[27] Diff, Match and Patch libraries for Plain Text, 2011,
http://code.google.com/
p/google-diff-match-patch/
[28] Mark O’Keeffe and Mel ´O Cinn ´eide, Search-Based Refactor-
ing: an empirical study . In Journal of Software Maintenance
and Evolution: Research and Practice, 20: 345-364, 2008.
[29] S. R. Foster, W. G. Griswold, and S. Lerner, WitchDoctor:
IDE Support for Real-Time Auto-Completion of Refactorings .
In Proceedings of the International Conference on Software
Engineering, 2012. To Appear.221