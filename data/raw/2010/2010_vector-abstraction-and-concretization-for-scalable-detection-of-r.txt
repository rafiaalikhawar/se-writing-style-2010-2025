Singapor e Management Univ ersity Singapor e Management Univ ersity 
Institutional K nowledge at Singapor e Management Univ ersity Institutional K nowledge at Singapor e Management Univ ersity 
Resear ch Collection School Of Computing and 
Information Systems School of Computing and Information Systems 
11-2014 
Vector Abstr action and Concr etization for Scalable Detection of Vector Abstr action and Concr etization for Scalable Detection of 
Refact orings Refact orings 
Narcisa Andr eea MILEA 
National Univ ersity of Singapor e 
Lingxiao JI ANG 
Singapor e Management Univ ersity , lxjiang@smu.edu.sg 
Siau-Cheng KHOO 
National Univ ersity of Singapor e 
Follow this and additional works at: https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch 
 Part of the Softwar e Engineering Commons 
Citation Citation 
MILEA, Nar cisa Andr eea; JI ANG, Lingxiao; and KHOO , Siau-Cheng. V ector Abstr action and Concr etization 
for Scalable Detection of Refact orings. (2014). 22nd A CM SIGSOF T International Symposium on the 
Foundations of Softwar e Engineering (FSE 2014): Pr oceedings: Nov ember 16-21, 2014, Hong K ong, China . 
86-97. 
Available at:Available at:  https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch/2643 
This Conf erence Pr oceeding Ar ticle is br ought t o you for fr ee and open access b y the School of Computing and 
Information Systems at Institutional K nowledge at Singapor e Management Univ ersity . It has been accepted for 
inclusion in Resear ch Collection School Of Computing and Information Systems b y an authoriz ed administr ator of 
Institutional K nowledge at Singapor e Management Univ ersity . For mor e information, please email 
cher ylds@smu.edu.sg . Vector Abstraction and Concretization for
Scalable Detection of Refactorings
Narcisa Andreea Milea
School of Computing
National University of
Singapore
mileanar@comp.nus.edu.sgLingxiao Jiang
School of Information Systems
Singapore Management
University
lxjiang@smu.edu.sgSiau-Cheng Khoo
School of Computing
National University of
Singapore
khoosc@nus.edu.sg
ABSTRACT
Automated techniques have been proposed to either identify
refactoringopportunities(i.e., codefragmentsthatcanbebut
have not yet been restructured in a program), or reconstruct
historicalrefactorings(i.e., coderestructuringoperationsthat
have happened between diﬀerent versions of a program). In
this paper, we propose a new technique that can detect both
refactoring opportunities and historical refactorings in large
code bases. The key of our technique is the design of vector
abstraction and concretization operations that can encode
code changes induced by certain refactorings as characteristic
vectors. Thus, the problem of identifying refactorings can
be reduced to the problem of identifying matching vectors,
which can be solved eﬃciently. We have implemented our
technique for Java. The prototype is applied to 200 bundle
projects from the Eclipse ecosystem containing 4.5 million
lines of code, and reports in total more than 32K instances
of 17 types of refactoring opportunities, taking 25 minutes
on average for each type. The prototype is also applied to 14
versions of 3 smaller programs (JMeter, Ant, XML-Security),
and detects (1) more than 2.8K refactoring opportunities
within individual versions with a precision of about 87%, and
(2) more than 190 historical refactorings across consecutive
versions of the programs with a precision of about 92%.
Categories and Subject Descriptors :D . 2 . 7[ Software
Engineering ]: Distribution, Maintenance, andEnhancement—
Restructuring, reverse engineering, and reengineering
General Terms : Algorithms, Design, Experimentation,
PerformanceKeywords
: RefactoringDetection, SoftwareEvolution, Vector-
Based Code Representation
1. INTRODUCTION
Software development and maintenance tasks often need
to change the structure of code without changing the func-
tionality of the code. This kind of code changes are often
called refactoring, and have long been recognized as an im-
portant way to improve the design of existing code [9,35],
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copiesbear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.FSE ’14, November 16–22, 2014, Hong Kong, China
Copyright 2014 ACM 978-1-4503-3056-5/14/11 ...$15.00.making code easier to understand, maintain, adapt to new
requirements. Detecting refactoring has been a topic of long
lasting interest in the literature. Some of the studies aim
to detect refactoring opportunities , i.e., code fragments that
can, be but have not yet been restructured, and thus to
reduce“bad smells”in code and improve the design of the
code [7,20,31,56,57]; some studies focus on understanding
historic refactorings that have happened; they reconstruct
the refactoring operations used to restructure the code by
analyzing diﬀerent versions of a program to facilitate code
maintenance and evolution studies [4,5,18,27,46,52,55,60].
It is desirable to have an approach that provides scalable,
consistent detection of both refactoring opportunities and
historic refactorings, as it can enable developers to measure
more accurately their refactoring eﬀorts and progresses dur-
ing software evolution. Figure 1 illustrates some challenges in
detecting refactoring.1The ﬁrst challenge is how to identify
that code fragment (a) may be refactored? One naive way isto check (a)’s code pattern against every type of refactorings
to see whether it may match one refactoring type. Such
checks may identify many meaningless refactorings since cer-
tain refactorings may in fact be applied to any code. Then,
we may ask a more speciﬁc question: how can we identify
alikelyrefactoring type for (a)? An idea is to utilize refac-
torings that have happened: we can try to identify another
piece of code cthat has been refactored yet is similar to (a)
before it is refactored, and then we can have high conﬁdence
in saying that (a) may be refactored in the same way as c.I n
this example, the question may become how to decide (a) is
similar to a supposedly“before-refactoring”version of either
code fragments (b) or (c) shown in the ﬁgure?
This can be challenging as well. The code fragments (a)
and(b)inFigure1looksimilartoeachother, but(a)contains
extra variable declarations (the underlined red parts) and a
method call to instantiate (the bold part); they may not be
detected as similar code (a.k.a. code clones [8,23,25,28,58])
or refactoring, unless relaxed similarity conditions are used.
However, relaxed similarities can lead to many false clones
to be detected and thus imprecise refactoring detection.
We can see that (c) may in fact be more similar to (a)
than (b) if its call to the method getVector is inlined; i.e.,
by replacing the call to getVector with the actual method
body from (b) and removing one of the returnstatements,
the inlined code (denoted as (cI)) becomes syntactically
1The code fragments (a), (b), and (c) were detected by our approach
as a refactoring opportunity in a program named JMeter version 1,and still exist (with small variants) in the latest version 2.11 ( https:
//jmeter.apache.org/ ), where (a) may be refactored into (d) which is
syntactically similar to (c) but does not actually exist in the program.public static Vector getControllers(Properties properties)
{
String name = "controller.";
Vector v = new Vector();Enumeration names = properties.keys();while (names.hasMoreElements()){
String prop = (String) names.nextElement();if (prop.startsWith(name)){
Object o = instantiate (
properties.getProperty(prop),
"org.apache.jmeter.control.SamplerController");
v.addElement(o);
}
}return v;
} (a)
public static Vector getVector(Properties properties , String name ) {
Vector v = new Vector();
Enumeration names = properties.keys();while (names.hasMoreElements()) {
String prop = (String) names.nextElement();
if (prop.startsWith(name)) {
v.addElement(properties.getProperty(prop));
}
}return v;
}
(b)
public static Vector getVisualizer(Properties properties) {
return instantiate (
getVector(properties, "visualizer."), // $NON-NLS-1$
"org.apache.jmeter.visualizers.Visualizer");
}(c)
public static Vector getController T(Properties properties) {
return instantiate (
getVector(properties, "controller."),"org.apache.jmeter.control.SampleController");
} (d)
Figure 1: Sample refactoring detected from JMeter.
similar to (a), except for diﬀerences in variable declarations
(the underlined red parts) in (a). Again, usual code clone
techniques [2,11,22,24,26,41,48] may detect (a) and (cI)a s
clones only if relaxed similarity conditions are used to tolerate
the diﬀerences, but these techniques cannot ﬂexibly specify
which diﬀerences to tolerate when computing similarity, and
using a relaxed similarity to force the detection of (a) and (cI)
may produce other false clones that diﬀer in other program
elements than the variable declarations.2This indicates that
similarity-based clone detection is not suﬃcient for accurate
refactoring detection; a desired refactoring detection tool
should possess knowledge about various kinds of refactoring
operations and work ﬂexibly with speciﬁc program elements.
Last but not least, in the context of discovering refactoring
opportunities in large code bases, we may need to compare
many code fragments against each other, and there is the
added challenge to locate suitable refactoring candidates
from multitude of code very eﬃciently.
In this paper, we present a new vector-based approach for
scalable detection of both refactoring opportunities and his-
torical refactorings. We ﬁrst construct characteristic vectors
that can be used to encode syntactic features of code, and
use such vectors to encode inlinedcode so that the eﬀect of
method extraction and inlining, which are commonly per-
formed by various refactoring operations, can be captured as
well. Then, we present a novel approach via vector abstrac-
tionandconcretization that can manipulate vectors ﬂexibly
based on code changes induced by known refactorings. By
2In fact, removing the underlined variable declarations in (a) and
replacing the uses of the variables with their right-side expressions isanother kind of refactorings, called “inline temp.”using vectors and vector operations as the representation of
code and code changes, our approach reduces the problem of
detecting refactoring to the problem of ﬁnding similar vectors
satisfying certain refactoring conditions. Since vector-based
operations can be performed in almost linear time with re-
spect to the number of vectors and the dimension of each
vector, it becomes the key to the scalability of our approach.
For each code fragment identiﬁed as a refactoring candi-
date, our approach also reports the likely refactoring op-eration applicable to cby reporting a set of sample code
fragments that may have been refactored via the same kind
of refactoring operations. Such sample refactored code may
help users understand better how to refactor c.F o r t h e
example shown in Figure 1, our approach identiﬁes (a) as
a refactoring opportunity, and reports (b) and (c) together
as a sample. Then, a user could proceed to refactor (a) in a
way similar to (b) and (c), and transform (a) into (d).
We have implemented our approach for Java (for both
sourcecodeandbytecode)andenabledvectorabstractionandconcretization operations for 21 common types of refactoring
operations. Our prototype is scalable and precise: In alarge code base comprising of 200 bundle projects in the
Eclipse ecosystem (e.g., Eclipse JDT, Eclipse PDE, Apache
Commons, Hamcrest, ObjectWeb ASM, etc.) containing
4.5 million lines of code, the tool reported in total more
than 32K instances of 17 types of refactoring opportunities,
taking 25 minutes on average for each type; In a smaller code
base containing 16 versions of three Java programs (JMeter,
Ant, and XML-Security), our tool reported 191 historical
refactorings across various versions and more than 2.8K
instances of refactoring opportunities. With validation by
four graduate students, we ﬁnd that the detected refactorings
are of high precisions, about 92% for historical refactorings
and about 87% for refactoring opportunities.
Our main contributions in this paper are as follows:
•Wedesignasystematicwaytoencodesyntacticfeatures
of code and code changes needed for various types of
refactoring operations as abstraction and concretization
operations of characteristic vectors;
•Our encoding of code and code changes does not need
to diﬀerentiate code within the same version or from dif-ferent versions of a program, so that we can detect both
refactoring opportunities and historical refactorings;
•Our vector-based encoding and similarity queries are
eﬃcient and enable scalable detection of refactorings;
•We have evaluated our approach on large code bases
with scalable and precise detection results.
The rest of the paper is organized as follows. Section 2
presents related work. Section 3 presents our detection ap-
proach. Section 4 presents speciﬁc vector abstraction andconcretization operations used in our approach. Section 5
presents the results of our empirical evaluation and discusses
threats to validity. Section 6 concludes with future work.
2. RELATED WORK
This paper is related to many studies in refactoring de-
tection, and software maintenance and evolution in general.
T h ed i s c u s s i o nh e r ei sb yn om e a n sc o m p l e t e .
There are many introductions and surveys for software
refactoringandrelatedtools[9,21,30,35,38,39]. Somesurveys
and tools investigate the relations between refactoring and
code clones [8,19,54,58], and clone detection has been toutedas an important way to detect refactoring opportunities (Ex-tract or Pull-Up Method in particular). Diﬀerent from clone
detection techniques, especially the ones based on vector
representations for code [11,22], our approach extends vector
operations with abstraction and concretization, and utilizes
various characteristics speciﬁc to refactoring operations.
Many studies aiming for automatic detection of refactor-
ings (besides the studies on clone detection) rely on the
changes recorded in version control systems. Their focus
is to reconstruct historical refactoring operations that have
happened. Demeyer et al. [4] deﬁne heuristic metrics to
search for refactoring between successive versions. Hayashi
et al. [18] model the refactoring detection as a graph search
representing structural diﬀerences between two versions of a
program. Weißgerber and Diehl [60] deﬁne signatures based
on code clone detection results to look for refactoring. Preteand Kim et al. [27,46] use template logic queries to represent
refactoring operations and a logic programming engine to
search for refactoring happened between versions of a pro-
gram; their tool RefFinder can detect 63 kinds of refactorings
in Fowler’s catalog [9]. Taneja and Dig et al. [5,55] present
tools ( RefactoringCrawler and RefacLib ) to detect refac-
torings between diﬀerent versions of libraries. Soetens etal. [52] detect refactoring operations as actual changes are
happening in an integrated development environment, and
thus achieve higher accuracy than previous work. Origin anal-
ysis has also been used to detect refactoring [15] by capturing
certain kinds of cross-function changes and how call relations
change between two versions of a program. Diﬀerent from
these techniques, our detection technique is vector-based and
is not limited for changes between versions; it can search
whole code bases and detect refactoring opportunities within
t h es a m ev e r s i o no fac o d eb a s ea sw e l l .
There exist studies that detect refactoring opportunities;
they are related to many studies on detecting“bad smells”incode [9,31,37]. Tourwe and Mens [56] use logic programming
to encode several types of refactoring operations and detect
possible refactoring opportunities. Meng et al. [33] create
context-aware edit scripts from two or more examples and use
the scripts to identify edit locations and transform the code.
Thisapproachcanbeappliedtoﬁndrefactoringopportunities
and fully automated, while we have yet to automate somesteps in our approach. However, the edit-scripts are so far
limited within a single method, as their experience shows that
combining inter-procedural analysis and the expressiveness
of general-purpose edits is a very hard problem. They cannotdetect changes that require moving code from one method to
another or coordinating changes to multiple methods in the
way our approach does. Some other studies detect refactoring
opportunities by searching for user-built code that may be
replaced with certain library calls [53] or upgraded with calls
to diﬀerent versions of library APIs [42]. Those techniques
mostly rely on graph-based matching and substitution, while
we rely on compact and eﬃcient vector-based representations.
Cider [51] is another work that can detect refactoring
without code change histories. Their algorithm relies on
graphmatchingandrequiresinitialseedsthataresimilarcode
fragments at ﬁrst, and is limited within individual methods
too. Our technique does not need seeds and relies on vector
matching, making it more scalable to large code bases where
code divergences across functions occur more often. Hui et
al. [32] identify particular kinds of generalization refactoring
opportunities. Our vector-based approach detects diﬀerent
types of refactorings and can complement those studies.Many other studies on refactoring focus on the speciﬁcation
and implementation of refactoring operations. A classical
work by Opdyke [44], describes a set of refactoring operations
for C++ in terms of the preconditions needed to preserve be-
haviour. Griswold speciﬁes refactoring from the perspective
of their eﬀects on program dependence graphs [16]. L ¨am-
mel [29] and Garrido [12] use rewriting rules to represent
refactoring. Recent studies also aim to allow programmers
to script their own refactoring operations. To this end, Ver-
baere et al. [59] propose a domain speciﬁc language JunGL
for expressing dataﬂow properties on a graph representa-
tion of the program. Sch ¨afer et al. [50] improve on this
and provide high-level speciﬁcations for many refactoring
operations implemented in Eclipse. Ge and Murphy-Hill [13]
can automatically validate a manually performed refactor-
ing. Our work complements those studies in that it searches
for new refactoring opportunities. As future work, we planto investigate the development of a language for specifying
vector abstraction and concretization that would allow us
to more comprehensively and precisely specify the intended
refactorings, in addition to learning from examples.
Many of the above mentioned studies can also automat-
ically perform identiﬁed refactoring. Modern development
environments, such as Eclipse and NetBeans, have automat-
ed refactoring capabilities. Concurrencer [6] can identify
and convert sequential code that may be beneﬁted from the
java.util.concurrent supports. LambdaFicator [10], auto-
matically refactors certain anonymous inner Java classes and
forloops to lambda expressions and functional operations
available in Java 8. Our tool currently focuses on detection
only. As our tool reports refactorings together with possi-ble refactoring results, it can also be improved to perform
identiﬁed refactorings automatically.
3. METHODOLOGY
We explain the main steps of our approach along with
Figure 2. Given a source code base, we construct its syntax
trees(STs), andcallgraphs(CGs). TheSTsareusedinaway
similar to previous studies [11,22] to generate characteristic
vectors for code fragments from the code base. When the
code is compilable, we also generate the bytecode (for Java)
or binary code, and construct characteristic vectors for the
bytecode or binary code as well [49]. Using bytecode or
binary code has the beneﬁt that many code diﬀerences only
applicable to high-level languages (e.g., diﬀerent syntaxesfor writing
forloops) are uniﬁed or eliminated, which can
potentially help to detect more refactorings [49]. We also
simulate the eﬀect of method linining by manipulating the
STs based on call relations and get inlined code, and generate
vectors for code fragments in the inlined code as well. Our
tailored vector generation is described in Section 3.1.
Aftervectorsaregenerated, theyare abstracted toeliminate
or unify code characteristics related to a particular type of
refactoring γ. The particular code characteristics are semi-
automatically extracted from known sample code refactored
byγ(see Sections 3.2 and 4).
Then, hash-basedsearch(simplehashandlocality-sensitive
hashing (LSH, [14])) is used to query for similar abstract-
edvectors eﬃciently so that we can identify candidates for
refactoring (see Section 3.3). Not all candidates can be true
refactorings. We then apply vector concretization to check
whether the characteristics in the concrete vectors indeed
match the code characteristics of a particular type of refac-Inlined
Code
Vectors for•(inlined) source code
•(inlined) bytecode
Vector 
Abstraction
Vector-
ased 
Query
Vector 
Concretization
Detected
Refactorings
Vector 
Generation
Figure 2: Overview of our approach.
toring (see Section 3.4). We can aﬀord to do more detailed
checks during concretization since the number of candidates
is much smaller than the original code sizes. Finally, the code
fragments corresponding to the candidates that are likely to
be true refactorings are reported to users.
3.1 Vector Generation
In this work we use characteristic vectors for the purpose
of refactoring detection. We deﬁne vectors as follows.3
Definition 3.1 (Characteristic Vector). Given a
sequence of Kunique features denoted by [f1,...,fK],a
characteristic vector vfor a code fragment cis an array
[n1,...,nK]of sizeKsuch that n1,...,nK≥0and for each
i,niisthe number of occurrences of the feature fiinc.
An entry in a vector vcan be referred to by either an index
ior a feature fi,d e n o t e db y v[i]o rv[fi]r e s p e c t i v e l y . I n
principle, the features can be anything in the code of interest
to an application. For example, they can be diﬀerent types
of nodes in the syntax tree of cto represent the syntactic
characteristics of the code [22], or be certain parts of thesyntax tree that match slices of the program dependence
graph of the code [11]. Following the previous work, we use
the types of the nodes in syntax trees as features for this
paper. Notethatnodetypesforsourcecodeandbytecodecan
be diﬀerent and thus corresponding vectors can be diﬀerent.
Since the vectors are generated according to the number of
occurrences of program elements in code, they themselves do
not capture various speciﬁc information about each element
(e.g., the speciﬁc name of an identiﬁer, the speciﬁc value of
a constant, etc.) or relational information between elements
(e.g., the containing class of a method or a ﬁeld, the parent
class of a child class, a statement appearing before another
statement, etc.). Nevertheless, such vectors have been shown
to be eﬀective for code clone detection [11,22].
3.1.1 F or Original not-yet-Inlined Code
Given a code fragment cfrom a code base, we can identify
t h en o d e so ft h es y n t a xt r e et h a tm a t c ht h el o c a t i o no f c
and then count the number of occurrences of diﬀerent node
types. For example, sample heavily simpliﬁed vectors for
the code fragments Figure 1(a), (b), and (c) are shown in
Table 1; the table headers indicate the sample features used
for the vectors; rows 1–3 are the vectors for each of the three
methods. Separated from the usual method invocations
3We use the term “characteristic vector” and “vector” interchangeably.(“mth invoc.”),“API invoc.” refers to invocations of methods
not deﬁned in the subject program;“new invoc.” refers to
invocations of constructors (e.g., new Vector() ). The actual
number of features in the vectors depend on the numberof diﬀerent types of nodes in (either abstract or concrete)
syntax trees for a programming language. Our prototype
implementation relies on abstract syntax trees generated by
Eclipse JDT for Java, which has more than 80 node types.
Table 1: Sample partial vectors for code in Figure 1
row 
IDCode simple 
namestring 
literalvar. 
decl. 
stmt. cast if return whilemth 
invoc.new 
invoc.W/ 
invoc.
1getControllers 2 9 2 5 1 1 1111 6
2getVector 2 3 0 3 1 1 1101 6
3getVisualizer 32 0 0 01 0 2 0 0
4getVisualizer 
(inline getVector) 26-1 23 1 1 2-1 12-1 16Features
Thesevectorsonlycapturecharacteristicsofthecodeinside
the same function: if a method is invoked in a code fragment,
the vector for the code fragment does not capture any char-
acteristic of the code inside the invoked method, except the
method invocation expression and actual parameters. Thus,
in this paper we call these vectors base-level characteristic
vectors, or simply basevectors. Although refactoring can
happen on arbitrary pieces of code, our implementation only
generates base vectors for method bodies, as the bodies likely
contain refactorings in smaller scopes too and we do not aim
to detect minimal code fragments that may be refactored.
This diﬀers from the vector generation strategy for clone
detection [11,22], and helps to reduce our search space.
3.1.2 F or Inlined Code
Refactoring may involve diﬀerent ways of extracting or
inliningmethods. Toencodevariouspossiblechangesinduced
by method inlining or extraction, we also consider diﬀerent
ways to inline methods for a given code fragment c.I n
general, if cinvokesnmethods, there could be up to 2nways
to inline the nmethods in combination. To reduce the search
space in this paper, we inline methods invoked in cin mainly
three diﬀerent modes: inlining all methods invoked in call
at once, inlining all calls to each distinct method separately,
or inlining nothing. We do not inline constructor and API
invocations. In this way, the number of inlined versions CI
ofcmay equal to two plus the number of distinct methods
deﬁned in the program and called in c. An inlined version
cIforccan be the same as cwhen the mode of “inlining
n o t h i n g ”i sa p p l i e do rw h e nn om e t h o di sc a l l e di n c.We simulate the eﬀect of method inlining by summing up
the vectors for the caller and the callee and manipulating the
features in the vectors that are related to method declarations
andinvocations, i.e., thefeaturesfortheinvocations, returns,
and formal and actual parameter substitutions. Speciﬁcally
for the features shown in Table 1, we reduce the occurrence
counters for“mth invoc.” and“simple name”each by one for
each method called (“simple name”is a child node of“mth
invoc.”, representing the method name in the syntax trees
generated by Eclipse JDT for Java), and remove all counts for
returns from the callee. We assume each actual argument is
only evaluated once and the corresponding formal parameter
somehow automatically receives its value, and thus the vectormanipulations do not need to consider the eﬀect of parameter
substitution. For example, when we inline getVector into
getVisualizer , the vector for getVisualizer is changed as
the row 4 in Table 1. The red parts of the row indicatethe manipulations applied to the sum of rows 2 and 3 tosimulate the inlining. Such simulated method inlining via
vector manipulation has been shown in our previous work to
be eﬀective for detecting method extraction and inlining [36].
This paper employs the same idea of vector inlining, but
extends it to deﬁne vector abstraction and concretization for
detecting more types of refactorings.
We note that the manipulation of vectors to simulate
method inlining may be language-speciﬁc; it depends on the
structure of syntax trees as well; it can be diﬀerent for source
and bytecode too. However, the idea of encoding method
inlining as vector operations can be generally applicable to
diﬀerent programming languages.
In the following discussion, we use the following terms and
notations: given a code fragment c,w ec a l li t base code ,a n d
its vector is called base vector and denoted as vc. The set
of all possible inlined versions of cis denoted as CI,w h i l e
an instance in the set is denoted as cI. The vector for the
inlined code cIis called inlined vector and denoted as vI
c.
3.2 Vector Abstraction
Our objective here is to encode code changes induced by
a kind of refactoring operation in the form of vectors as
precisely as possible, and abstract away (or eliminate) the
changes from the vectors representing code, while maintain-
ing essential code features, so that the abstracted vector
representations for the code before and after it is refactored
can be the same. Then, the problem of searching for refac-
torings can be reduced to the problem of ﬁnding code with
the same abstracted vector representation.
Each refactoring type has a diﬀerent abstraction since they
often induce diﬀerent code changes. We useγAto denote the
abstraction operation for a refactoring type γ.γA(v)m e a n s
to apply the abstraction onto a vector v,a n dγψdenotes the
resulting abstracted vector. The“Query”portion on the left
in Figure 3 illustrates the conceptual relations among base
code, inlined code, and various kinds of vectors with respect
to a refactoring γ:Ap i e c eo fb a s ec o d eu s e da saq u e r y q
can have more than one inlined code qI;i t sb a s ev e c t o r vq
c a nb e c o m ea na b s t r a c t e db a s ev e c t o rγψq; and its inlined
vectorvI
qcan become an abstracted inlined vectorγψI
q.I ti s
possible thatγψI
qmay be the same as vI
qand/orvq.
In this paper, we use a semi-automated mechanism to
extract diﬀerences from sample code refactored by a type of
refactoring γand deﬁne the abstraction for γsystematically
based on the diﬀerences. We introduce our deﬁnitions:ݍݍ ூ inlineݒ௤ூ
Base Code Inlined CodeInlined Vector Base  VectorAbstracted 
Inlined VectorAbstracted 
Base  Vector
ݒ௤߰ఊ௤ூ߰௤ఊQuery Query Result 1
ܿଵ ܿଵூݒ௖భூݒ௖భ߰ఊ௖భூ߰ఊ௖భ(1) match 
abstracted 
vectors
(2) filter vectors
(3) check 
concrete 
vectors for 
patterns 
specific for ߛQuery Result 2
ܿଶ ܿଶூݒ௖మூݒ௖మ߰ఊ௖మூ߰ఊ௖మ
(4) check across results for higher ƉƌĞĐŝƐŝŽŶ
(5) report likely refactorings for ݍVector 
Abstraction
CodeVectorsAbstracted 
Vectors
Vector 
Generation
Figure 3: Given a piece of code q, search for code similar
toqifqmay be refactored via a refactoring operation γ.
Definition 3.2 (Vector Substitution). Given a vec-
torvand a set of mappings from features to counts ( F=
{fi/mapsto→ni}), thevector substitution is denoted by v(F);i t
generates a new vector v/prime,s u c ht h a t:
∀i∈1..K, v/prime[i]=/braceleftbigg
niif{fi/mapsto→ni}∈F
v[i]otherwise
BothniandF[i]denote the mapping result for a feature fj.
Definition 3.3 (Vector Difference). Given two vec-
torsv1andv2,t h evector diﬀerence operation δforv1and
v2is deﬁned as δ(v1,v2)=(vδ,m,D)where
1.vδis a vector called assimilation vector betweenv1and
v2:∀i∈1..K, vδ[i]=min(v1[i],v2[i]);
2.0≤m≤K;
3.Dis a feature mapping set of size m:∀i∈1..K,(fi/mapsto→
(v2[i]−v1[i]))∈Diﬀv1[i]/negationslash=v2[i].
Such vector diﬀerence operations ( vδ,m,D) encode both
“common”parts (in vδ) and diﬀerences (in D) between two
vectors. When v1andv2correspond to two sample pieces
of codec1andc2,a n dc2is the result of applying a certain
refactoring operation γontoc1, the feature mapping set D
indicates the features that may be changed by γ, and can
help us deﬁne the abstraction operationγAforγthat can
abstract away the changes that may be induced by γinto an
arbitrary vector v. The abstracted vector for vis denoted
by eitherγA(v)o rγψ. The rules below describe howγψis
generated for an arbitrary v, based on a given δ(v1,v2). The
rules are conceptually the same for source code and bytecode.
(I)γψ[i]=v[i], ifDdoes not contain a mapping for fi.
(II)if there is a subset of D, denoted as D∫={fd1/mapsto→
nd1,fd2/mapsto→nd2,...,fds/mapsto→nds}where 2 ≤s≤K
and 1≤d1≤d2...≤ds−1≤ds≤K, such that
Σs
i=1ndi=0 ,4then we consider the features in D∫as
inter-exchangeable and we merge their counts in vall
into a unique conceptual feature as follows:
•γψ[d1]=Σs
i=1v[di];
•∀i∈2..s,γψ[di]=0 .
For example, various relational operators ( <,>,<=,a n d
>=) in code are in fact inter-exchangeable, since a refac-
toring operation can reverse the condition in an ifstate-
ment and swap the branches of if. Such a refactoring
would induce changes in the counts for the individual
operators, but the total sum of the counts for these inter-
exchangeable code features should remain the same.
(III)if there is a subset of D, denoted as D∫={fd1/mapsto→
nd1,fd2/mapsto→nd2,...,fds/mapsto→nds}where 2 ≤s≤Kand
1≤d1≤d2...≤ds−1≤ds≤K, such that nd1=nd2=
4∀(fdi/mapsto→ndi)∈D,ndi/negationslash= 0 because of the rule 3 in Def.3.3....=nds, then we consider the features in D∫should be
changed together in the same way by γand we set all
t h e i rc o u n t st o1a sf o l l o w s :
•∀i∈1..s,γψ[di]=1 .
This condition helps the refactoring cases when it is not
important to count the actual number of occurrences of
a code feature as long as the feature exists in the code.
For example, the refactoring type“Consolidate Duplicate
Conditional Expression”consolidates more than one con-
ditional expression into one, so the features essential to
the conditional expressions were all set to 1.
(IV)there may be multiple subsets of Dsatisfying the above
conditions; if the subsets are disjoint, we perform the
abstraction for each subset separately; if the subsets
overlap, we manually identify a subset to abstract. In
our experiments, vector diﬀerences Dare generated from
sample refactored code in classical collections (see Section
4) and of small sizes, and it was easy to ﬁnd suitable
subsets as above eﬃciently.
(V)γψ[i] = 0, otherwise. The intuition for this rule is that
if a feature fican be changed by the refactoring γbut
not in“conjunction”with other features, fimay in fact
be changed arbitrarily byγ, and it is non-essential for
γ, and thus we abstract it away. As one can see, we
deﬁne “conjunction” as the subsets satisfying the rule
(II) or (III), and we found the simple rules are suﬃcient
for the refactoring types detected in our experiments.
Also, since the rules do not yet consider the semantics
of the features, the mapping Dgenerated from sample
refactored code may contain more features than what
are really needed for γ. So, we also manually verify each
inferred abstraction in our experiments.
For example, we can deﬁne the vector abstraction for the
kind of refactoring operation in Figure 1. Even though those
code snippets are detected by our tool, here we use them as
sample refactored code to illustrate how we deﬁne the abstrac-
tion for a refactoring operation based on sample refactored
code. For this case, the vector in row 1 in Table 1 is v1and
the other in row 4 is v2; the vector diﬀerence Dis{“simple
name”/mapsto→−4,“var. decl. stmt.” /mapsto→−2}which indicates the
removal of two variable declaration statements containing
four simple names (two are for the variable names; the other
two are for the variable types). The above abstraction rule
(V) applies, so the abstractionγAwould set the counts for
both“simple name”and“var. decl. stmt.” to zero. Table 2
shows the abstracted vectors if the abstraction is applied to
the concrete vectors in Table 1.
Table 2: Sample abstracted vectors for vectors in Table 1
row 
IDCode simple 
namestring 
literalvar. 
decl. 
stmt. cast if return whilemth 
invoc.new 
invoc.W/ 
invoc.
1getControllers 0 2 0 1 1 1111 6
2getVector 0 0 0 1 1 1101 6
3getVisualizer 0 2 0 0 0 1020 0
4getVisualizer 
(inline getVector) 0 2 0 1 1 1111 6Features
When more than one pair of sample code is provided for
a refactoring operation γ, we can reﬁne the extracted ab-
straction for γto represent the most general code changes
induced by γ. To achieve this, we can calculate the vector
diﬀerence ( vδ,m,D) for every pair, and look for the“max-
imum common diﬀerence” among all those ( vδ,m,D). In
this paper, we still employ manual eﬀorts to use appropriatethresholds and reﬁne the extracted abstraction if necessary.
As interesting future work, we plan to automate the extrac-
tion of abstraction from given sample code based on vector
arithmetics. Such automation may be in spirit similar to
studies on speciﬁcation mining [43,61 –63] and programming
by examples [17,33,34,40], but it will use a signiﬁcantly diﬀer-
ent technique based on vector representation and arithmetic
of the characteristics of code and code changes.
3.3 Vector-Based Query
When we want to ﬁnd instances of a type of refactoring
operations γin a large code base, we apply the abstraction
forγto all vectors generated from the code base. The code
diﬀerence induced by γshould thus be eliminated, and the
abstracted vectors of either refactored or non-refactored code
should appear the same. Then, we can use hash-based match-
ing techniques [3] to ﬁnd vectors that are either matching
exactly or very similar to each other [11,22].
We tailor the queries in our approach to answer the ques-
tion:can a piece of code qbe refactored via a refactoring
operation γso that it becomes similar to some other code?
As illustrated in the step (1) in Figure 3, we perform queries
on abstracted vectors for either base or inlined code, or both:
abstracted vectors (either ψqorψI
qor both) are used, each
as a query against all other available abstracted vectors to
identify the ones matching the query. Depending on the
vectors used, we can identify candidates for both historical
refactorings and refactoring opportunities:
(1)When we use every abstracted vector generated for one
version of code as a query to search for matching ones
in the set of abstracted vectors for another version of
the code, we can detect historical refactorings happened
between two versions of the code.
(2)When we use every abstracted vector generated for a
code base as a query to search for matching ones in all
abstracted vectors for the same code base, we can detect
refactoring opportunities that may be similar to some
refactorings that have happened in the code base.
The types of refactorings under investigation would aﬀect
whether the corresponding queries and matching outcomes
are drawn from either base vectors or inlined vectors or both.
For example, for the detection of the opportunity of method
inlining shown in Figure 1(a), we used the abstracted vector
for thebasevector of (a) as a query and search for its matches
among the abstracted vectors for all other inlinedcode.
Not all matched vectors can be refactorings; we apply
heuristic ﬁlters (Figure 3, step (2)) to reduce unlikely ones:
FilterSmall :When a piece of code is too small (e.g., smaller
than the number of elements involved in the abstraction
forγor the sizes of the sample code used to deﬁne the
abstraction), it may not be useful to refactor it. We can
use a threshold (e.g., 50% of the sizes of the sample code
or 10 program elements or 1 functioning statement) to
remove code that is too small.
FilterClones :When comparing the concrete vectors for
both the query code and the result code, if both vq=vc1
andvI
q=vI
c1,qandc1are very likely the same syntac-
tically, and their inlined versions are the same as well.c
1is simply a clone of qand may not indicate how to
refactor q, and thus can be removed.
FilterNames :Many refactoring operations would maintain
various names (e.g., some variable names in the code
and the name of the method/class/ﬁle containing thecode) the same before and after the refactoring. We can
remove a query result if its fully qualiﬁed method name
does not match that of the method containing the query
code. This can be useful for detecting and reconstructing
historical refactorings happened between versions, where
the query code and the result code are in diﬀerent versions
of a program and often share same name. We only turn
on this ﬁlter for across-version refactoring detection.
For the code fragments in Figure 1, (a) and (c) inlined
with (b) can be detected as likely refactorings since their
abstracted vectors (rows 1 and 4 in Table 2) are the same.
3.4 Vector Concretization
After above steps, we have a set of ﬁltered query results for
each piece of code used as a query. The following concretiza-
tion phase performs several kinds of checks on the concrete
vectors corresponding to the query and the query results to
improve the precision of refactoring detection. This phase
corresponds to steps (3) and (4) in Figure 3.
The ﬁrst kind of checks is to make sure the diﬀerences a-
mong the concrete vectors indeed subsume the diﬀerences ( D,
see Section 3.2) that may be induced by a kind of refactoringoperation γ;i . e . ,γmay really be applied to the corresponding
code. This is useful for reducing false positives since diﬀerent
refactoring operations may in fact change same features in
code and having similar abstracted vectors may not mean the
corresponding concrete vectors satisfy requirements needed
byγ(see the concretization rule (I) below).
T h es e c o n dk i n do fc h e c k si st om a k es u r et h er e p o r t e d
query results indeed have the contexts in which the refac-toring operation γcan be carried out. For example, the
refactoring“Reverse Conditional”reverses the relational op-
erator in an ifstatement and swaps the branches of the
if, and thus the refactoring can only happen when the code
contains at least one if, even though the feature representing
ifitself is not changed by the refactoring. So we perform
checks that the common parts among the concrete vectors
indeed subsume the common parts ( vδ, see Section 3.2) that
represent the contexts needed for γ(see the rule (II) below).
For certain types of refactorings, we manually add special
checks for them (see Section 4), based on our understanding
of the code changes involved in the refactorings, to help
reduce false positives. For example, a refactoring operation
may simply replace the wholebody of a method with a call
to a newly extracted method containing the replaced body.
Although such a refactoring may be classiﬁed as “Extract
Method”, it may be too simple to be useful. Thus, we ﬁlter
such cases during concretization (the rule (III)).
We also cross-check query results to improve their credi-
bility. Intuitively, the query results should be syntactically
diﬀerent from the query; otherwise, they are likely clones
only, not refactorings. Also, when there are more than one
query result that are syntactically diﬀerent from each other,
they may indicate more than one way to refactor the query
code, which may appear confusing for users. We thus choose
to remove such cases so that users can have higher conﬁdence
that the refactoring operation indicated by the ﬁnal query
results can be applied to the query code (the rule (IV)).
The rules below describe the above checks more rigorously:
(I)Calculate the vector diﬀerence between vI
qand each vI
ci:
δ(vI
q,vI
ci)=(vIδ
q,mIq,DI
q). Check them against the vector
diﬀerence ( vδ,m,D)f o rγ, and remove the query result
ciif one of the following conditions is true:(1)if∃(fi/mapsto→ni)∈D,s.t.(ni<0)∧(vI
q[i]<|ni|), it
meansγwould need to remove |ni|instances of the
code feature fibutqIdoes not contain enough;
(2)if∃(fi/mapsto→ni)∈D,s.t.eitherDI
qdoes not contain fi
or|DI
q[fi]|<|ni|. This indicates that the changes
between vI
qandvI
ciare too few in comparison with
the changes induced by γto be a real case of γ;
(3)if∃i∈1..K,s.t.(vI
q[i]<vδ[i])∨(vI
ci[i]<vδ[i]), it
meansγwould need to be carried out in a context
containing vδ[i] instances of the code feature fibut
qIorcI
idoes not contain enough;
(II)Checkvqandvciagainst ( vδ,m,D), and remove the
query result ciif the following condition is true:
(1)if∃i∈1..K,s.t.(vq[i]<vδ[i])∨(vci[i]<vδ[i]), it
meansγwould need to be carried out in a context
containing vδ[i] instances of the code feature fibut
qorcidoes not contain enough;
(III)Check all base and inlined vectors against code change
rules speciﬁc for γto remove possibly more query results;
(IV)We ﬁnally check the query results against each other
if there are still more than one result at this step. We
remove all of the results if the following condition is true:
(1)∃i,j,s.t. i /negationslash=j∧vci/negationslash=vcj;
Finally, the code corresponding to the query and checked
query results are reported as refactorings. For the code
fragments in Figure 1, one of the diﬀerences among theirconcrete vectors (Table 1, rows 4 and 1) indeed match the
vector diﬀerence operation ( {“simple name” /mapsto→−4,“var. decl.
stmt.”/mapsto→−2}). Their contexts are also matched. Thus, (a)
a n d( c )i n l i n e dw i t h( b )a r er e p o r t e da sr e f a c t o r i n g s .
4. REFACTORING AS VECTOR ABSTRAC-
TION & CONCRETIZATION
Our approach is based on abstraction and concretization
of characteristic vectors that capture various code features
before and after certain refactorings. The eﬀectiveness of ourapproach is dependent on how well the vectors can represent
code features. As mentioned in Section 3.1.1, the vectors
used in this paper only capture code features related to the
number of occurrences of program elements in code. Thus,
our approach is tailored to detect refactoring operations that
would change the number of occurrences of various program
elements in code. Some refactoring operations can inducecode changes that are not represented by the vectors. Forexample, “Pull Up Method”moves a method from a child
class to its parent class. The moved method itself is the same
before and after the refactoring, but its containing class is
changed. “Rename Method”changes the name of a method.
The characteristics of such changes are not captured in the
vectors, and thus are not yet detectable by our approach. It
will be our future work to extend the capabilities of vectors
to encode and index programs more comprehensively.
In this paper, the sample refactored code used for con-
structing abstraction and concretization rules is all fromclassical collections [9,21]. We have rules for 21 types of
refactorings, although not every type has detection results inour experiments. Due to our page limit, Table 3 only lists 11types, and uses simpliﬁed notations and descriptions, instead
of rigorous vector-based operations. Abstraction rules that
do not change the values for a feature are not shown. Some
concretization rules are the same for all types of refactorings
(as described in Section 3.4); they are also omitted.Table 3: Sample abstraction and concretization operations. In addition to the notations used in Section 3, vectors
superscripted with “S” are generated from source code, while others are generated from bytecode. Many features used
in the operations characterize bytecode instructions in our implementation, but we use more high-level names for the
features here for illustration purposes. Due to space limitation, we rely on the feature names to convey their meaning.
# Refactoring Abstractions ( ࡭ሺ࢜ሻળ or simply ȥ) Concretization Checks Descriptions 
1.  Extract Method ȥ[load] = ȥ[store] = 0 
ȥ[constant] = 0 ׍vi inlined into v c s.t. v q== v i 
(remove simple extraction methods)  
2.  Inline Method ȥ[load] = ȥ[store] = 0 
ȥ[constant] = 0 ׍vi inlined into v q s.t. v q == v i 
(remove simple extraction methods)  
3.  Inline Temp ȥ[load] = ȥ[store] = 0 vq [load] - v c [load] > 0 && 
vq [load] - v c [load] == v q[store] - v c [store] == 
vqS[var_declaration] - v cS[var_declaration] Remove the declaration of a temporary 
variable, and replace the use of the 
variable with the value of the variable. 
4.  Introduce 
Explaining 
Variable ȥ[load] = ȥ[store] = 0 vq [load] - v c [load] < 0 && 
vq [load] - v c [load] == v q[store] - v c [store] == 
vqS[var_declaration] - v cS[var_declaration] Extract a complicated expression into a 
temporary variable. 
5.  Split Temporary 
Variable ȥ[load] = v[load]+ σv[load_i] 
ȥ[store] = v[store]+ σv[store_i] 
ȥ[load_i] = ȥ[store_i] = 0 
i אሼͲǡͳǡʹǡ͵ሽ  vcS[variable_declaration_statement] >=2 && 
(vqS[assignment] - v cS[assignment]) == 
 - (vqS[var_declaration] - v cS[var_declaration])  Transform multiple assignments to a 
temporary variable into separate variable 
declarations for each assignment. 
6.  Replace Method 
With Method 
Object ȥ[load] = ȥ[store] = 0 
ȥ[getfield] = ȥ[putfield] = 0 
ȥ[new] = ȥ[invoke_init] = 0 ׌vi  inlined into v c s.t.  
ሺσ  vi[f] -  σ vq[f]) == (v i[getfield] + v i[putfield]), f אሼͲǡǤǤ Ǥሽ   
    (v i[getfield] - v q[getfield] > 0) 
    (v cI[new] - v q[new] > 0) Transform a method into its own object 
so that all the local variables become 
fields. Abstraction involved ignoring 
"new" operators and encapsulation. 
7.  Self Encapsulate 
Field ȥ[aload_0] = 0 
 
( aload_0 is used for loading "this" on 
the stack ) vq [getfield] -  v cI[getfield] > 0 // ׌ an extra field to encapsulate 
׌vi  inlined into v c s.t. 
    v i [getfield] == 1 && v i [return] == 1 && v i [aload_0] == 1 
    v i [op] == 0 where op!= getfield && op!= return && op!= aload_0 Replace direct accesses to a field with a 
getter method 
8.  Replace Magic 
Number with 
Symbolic 
Constant No abstraction needed as both are 
represented by the same bytecode. σ vqS[literal] - σ vcS[literal] > 0  // query has more magic numbers 
   literal אሼ string_literal, boolean_literal, num_literal ሽ
vqS[simple_name] - v cS[simple_name] < 0 Replace constants used in code with 
symbolic names for easier maintenance 
9.  Replace Magic 
Number with 
4uery 0ethod No abstraction needed as both are 
represented by the same bytecode. ׌vi  inlined into v c  s.t.  
     σ  viS[op] == 1, op אሼ string_literal, boolean_literal, num_literal ሽ 
     v iS[return] == 1 
     v iS[totalCount] == 2 Replace constants used in code with a 
getter method that returns the constants. 
10.  Reverse 
Conditional ȥ[eq] = v[eq] + v[neq] 
ȥ[lt] = v[lt] + σሾሿ
ȥ[neq] = ȥ[opp] = 0 
opp אሼ gt, ge, le ሽ ׌cond אሼ eq, neq} or opp אሼ lt, gt, ge, le ሽǤǤ 
   v q [cond] - v c [cond] != 0 ||  
   v q [opp] - v c [opp] != 0 Treat "==" the same as "!=" 
Treat "<=" the same as ">", ">=", and "<"
11.  Encapsulate 
Downcast ȥ[checkcast] = 0 
(ignore type casts) vq [methodinvoke_checkcast] - v c[methodinvoke_checkcast] > 0 Encapsulate type cast operations into a 
separate method returning the casted type 
5. EMPIRICAL EV ALUATION
This section presents our evaluation on four aspects: how
many historical refactorings are detected, how many refactor-
ingopportunitiesaredetected, howaccuratearetheidentiﬁed
refactorings and how scalable is our approach.
5.1 Experimental Setting
In order to provide answers to the evaluation questions we
have performed two case studies. All experiments related to
these studies were performed on a PC running Ubuntu 10.04
with Intel Xeon at 2.67GHz and 24GB of RAM.
In the ﬁrst case study we looked at three Java programs
from the Software Infrastructure Repository (SIR): JMeter,
XMLSecurity, and ANT. For JMeter, we performed experi-
ments on 6 versions (0 to 5), for Ant on 6 versions (0 to 5),
and for XMLSecurity on 4 versions. The size of these subject
programs ranges from 17KLOC to 80KLOC. The projects
were selected for comparing our prototype with the state-of-
the-art in detecting historical refactorings—RefFinder [47],
and for measuring the eﬀectiveness of detecting refactoring
opportunities by our prototype.
In the second case study we aimed to explore the scalability
of our system. As such we have applied the prototype toa large code base containing 4.5 million lines of code and
200 bundle projects from the Eclipse ecosystem (e.g., Eclipse
JDT, Eclipse PDE, Apache Commons, Hamcrest, etc.).To evaluate the precision of the results detected by our
approach, a group of four graduate students with good knowl-edgeofJavaandrefactoringwereinvitedtoinspecttheresults
independently. Due to the large number of results, we do not
evaluate every one of them. For refactoring opportunities
detected for the three subject programs, we chose to inspect
the results for the ﬁrst version of each program only. Each
result inspector was required to verify that each of the detect-
ed refactorings is correctly classiﬁed. A result was counted
as a false positive if any of the inspectors considered it as a
false positive. For historical refactorings detected, we chose
to inspect all of them due to a more manageable number.
It is not our focus to evaluate the recall of our approach due
to lack of ground truths. However, we tested our approach
on a set of examples taken from Fowlers catalog and found
our approach can successfully detect all deﬁned types of
refactorings in the example set.
5.2 Detection Results
The results of the experiments performed in the ﬁrst case
study are shown in Table 4, 5, and 6. Each row in the tables
shows the results obtained for one type of refactoring query;
the types having no detection results are not shown in the
tables. Each column having a single number (e.g. 1) as the
header name shows the refactoring opportunities within a
version of the project, while each column having a numberTable 4: Result summary for JMeter.
# ProgramVersions 00Ͳ111Ͳ222Ͳ333Ͳ444Ͳ55
1.ExtractMethod 11 7161561717
2.InlineMethod 20 16 15 48 56 60
3.Introduce Var 131720424446
4.InlineTemp 7 9 10 21 20419
5.ReplaceAssignment 
withInitialization 4 1 111 1 1
6.Downcast Encapsulate 34 37 383210 10 10
7.ReverseConditional  1 1 1
8.ReplaceDagicEumber
with^ymboliconstant1 5 526 6 6
9.SelfEncapsulate Field1717183171818
10. ReplaceParameter 
withMethod 10 10 10
 Subtotal 107 0109 1113 53 162 1173 5178
Table 5: Result summary for Ant.
# ProgramVersions 00Ͳ111Ͳ222Ͳ333Ͳ444Ͳ5 5
1.ExtractMethod 18 1312323127849106
2.InlineMethod 1831 29 29253 80
3.Introduce Var 12117175253
4.InlineTemp 2 6 9 9114 21
5.ReplaceAssignment 
withInitialization  3 3 314 4
6.Downcast Encapsulate  10 4 4 
7.ReverseConditional  3 510101415
8.ReplaceDagicEumber 
with^ymboliconstant1311317 16 179 195
9.SelfEncapsulate Field 28475555613750128
10. Introduce Parameter 
Object 1 1 1 7 8
11.SplitTemp  11 1
Subtotal 71 4 166 3 168 0 167 23 53999611
range (e.g. 0-1) as the header shows the number of detected
historical refactorings between two versions.
The number of historical refactorings we detected between
versionsrangesfrom0to99whilethenumberofopportunities
within each version ranges from 70 to 611. Out of total 2882
refactoring opportunities detected within all versions of the
three subject programs,5the students inspected 276 and
identiﬁed 35 false positives, giving a precision of 87% for our
approach in detecting refactoring opportunities .
We inspected all of the 191 historical refactorings detect-
ed. This validation was performed by the authors and the
students, to verify that the classiﬁcation reported by our
approach for an actual code change between two versions
is correct. We found 14 false positives, which resulted in a
92.6% precision for detecting historical opportunities .
The tables show that the numbers of refactoring opor-
tunities detected evolve from one version to another in a
non-monotonous manner. An increase in the numbers of
reported refactorings may imply that the size of the project
increased due to code copy-paste operations or refactorings
that have only been applied to parts of the project. A de-
crease may indicate that code was deleted, that previously
similar code has diverged in shape or that the opportunities
were applied. An example of the latter situation is exhibited
by JMeter between the versions 2 and 3 for the refactoring
Encapsulate Downcast (Row # 6 and Columns # 2, 2-3, and
3 in Table 4). In the versions 0, 1, and 2 of JMeter, a large
number of methods invoked method getProperty from class
Taskand downcasted its result to obtain a string. Another
category of methods invoked method getPropertyAsString
from class Taskwhich had the downcast pushed inside the
method. The similarity between the methods that invoked
getProperty and those that invoked getPropertyAsString
5A piece of code can be counted multiple times if it appears in mul-
tiple refactoring types in our results.Table 6: Result summary for XML-Security.
# ProgramVersions 00Ͳ111Ͳ222Ͳ33
1.ExtractMethod 41333
2.InlineMethod 24 16 6 6
3.Introduce Var 41413643
4.InlineTemp 121212 10
5.ReverseConditional  1111
6.ReplaceMagic Number  with  Symbolic  Constant 4 4 4
7.SelfEncapsulate Field 14884
8.Introduce Parameter Object 2 2 2 
Subtotal 98 2 77 072071
resulted in a number of refactoring opportunities detected
by our approach. Between versions 2 and 3, some of theseopportunities were applied and the methods that invoked
getProperty were changed to invoke getPropertyAsString .
These cases were captured by our approach by comparing
the two versions, but not detected by RefFinder.
We now discuss a few refactoring types that highlight the
strength of our approach as opposed to using either clone
detection to detect refactoring opportunities, or tools in the
literature [4,18,27,46] that detect historical refactorings:
a)Classifying refactoring involving small changes precisely :
“Self Encapsulate Field”is a refactoring that manifests itself
in terms of changes to method bodies by a change from a
direct ﬁeld access to a call to a getter method. This smallchange between the before and after methods can cause alarge number of similar methods to be returned by tradi-
tional threshold-based similarity approaches. Unfortunately,
most of the returned results are irrelevant to the“Self En-
capsulate Field”refactoring, leading to high numbers of false
positives. Our approach, on the other hand, can detect a
large number of“Self Encapsulate Field”refactorings with a
high precision. Speciﬁcally, we detect more than 50 historical
refactorings, that were not detected by RefFinder, between
the Ant versions 4 and 5 with a 100% precision.
In comparison with RefFinder, we note that RefFinder has
a diﬀerent refactoring deﬁnition for“Self Encapsulate Field”;
its deﬁnition is based on changes between two versions of a
program focusing on the creation of a getter method, and
does not capture the manifestation of self-encapsulate ﬁeld in
the methods that access it. This makes comparison between
RefFinder and our approach impractical.
RefFinder Deﬁnition of Self Encapsulate Field [45]
encapsulate ﬁeld(fFullName) ∧there are no access to the
ﬁeld besides the new getter and setter →self encapsulate ﬁeld
deleted ﬁeldmodiﬁer(fFullName, public) ∧
added ﬁeldmodiﬁer(fFullName, private) ∧
added getter(mGetFullName, fFullName) ∧
added setter(mSetFullName, fFullName) →encapsulate ﬁeld
Moreover, we note that RefFinder cannot be applied within
the same version, thus is unable to discover many refactoring
opportunities that occur within a version.
b)Detecting complex refactoring patterns : “Replace Pa-
rameter with Method”transforms a method m(which invokes
a method m1and passes its return value as an argument for
another method m2) by moving the call to m1into a modiﬁed
version of m2. Figure 4 shows an example. Detecting an
instance of this refactoring type requires a speciﬁc deﬁnition
of similarity among the caller and the callees. Our approach
can achieve the precision by specifying that the diﬀerence in
the numbers of method calls in the two versions of vectors
for the caller ( getPrice ) is the additive inverse of that in the
two versions of vectors for the callee ( discountedPrice ).public double getPrice() {
int basePrice = _quantity * _itemPrice;
- int discountLevel = getDiscountLevel();
- double finalPrice = discountedPrice (basePrice, discountLevel);  
+ double finalPrice = discountedPrice (basePrice);
return finalPrice;
}
private double discountedPrice (int basePrice) {
- if (discountLevel == 2) return basePrice * 0.1;+  if (getDiscountLevel() == 2) return basePrice * 0.1;
else return basePrice * 0.05;
}public double getPrice() {
int basePrice = _quantity * _itemPrice;int discountLevel = getDiscountLevel();double finalPrice = discountedPrice (basePrice, discountLevel);return finalPrice;
}
private double discountedPrice (int basePrice, int discountLevel) {
if (discountLevel == 2) return basePrice * 0.1;else return basePrice * 0.05;
}
Figure 4: Example of “Replace Parameter with Method.”
Table 7: Result summary for Eclipse.
ZĞĨĂĐƚŽƌŝŶŐdǇƉĞNo͘of
ZesultsTime
ǆƚƌĂĐƚDĞƚŚŽĚ ϭϯϭϬϭϳŵϮϭ
/ŶůŝŶĞDĞƚŚŽĚ ϱϮϳ ϭϰŵϳ
^ĞůĨŶĐĂƉƐƵůĂƚĞ&ŝĞůĚ Ϯϵϰϴϭϳŵϲ
ŽǁŶĐĂƐƚŶĐĂƉƐƵůĂƚĞ ϲϲϰ ϭϴŵϯϲ
/ŶƚƌŽĚƵĐĞsĂƌ ϮϮϵϰϮϮϮŵϰϯ
/ŶůŝŶĞdĞŵƉ ϮϬϭϯ ϮϮŵϮϮ
ZĞǀĞƌƐĞŽŶĚŝƚŝŽŶĂů ϭϬϮϭϮϭŵϮϭ
^ƉůŝƚdĞŵƉ Ϯϲ Ϯϲŵϱϲ
ZĞŵŽǀĞƐƐŝŐŶŵĞŶƚƚŽ/ŶŝƚŝĂůŝǌĂƚŝŽŶ ϱϬϮϲŵϱϲ
ZĞƉůĂĐĞDĂŐŝĐEƵŵďĞƌ ϭϱϳϳ Ϯϰŵϰϰ
ŽŶƐŽůŝĚĂƚĞŽŶĚŝƚŝŽŶĂů ϱϮϱϵŵϯ
ZĞƉůĂĐĞEĞƐƚĞĚŽŶĚŝƚŝŽŶĂůǁŝƚŚ'ƵĂƌĚůĂƵƐĞƐ ϲϬ ϱϵŵϮϵ
/ŶƚƌŽĚƵĐĞWĂƌĂŵĞƚĞƌKďũĞĐƚ ϯϮϱϭϴŵϱϳ
ZĞƉůĂĐĞWĂƌĂŵĞƚĞƌǁŝƚŚDĞƚŚŽĚ ϮϮϴ ϭϴŵϯϱ
,ŝĚĞĞůĞŐĂƚĞ ϭϯϭϵŵϰϰ
ZĞŵŽǀĞDŝĚĚůĞŵĂŶ ϭϬ ϭϵŵϭϰ
ZĞƉůĂĐĞDĞƚŚŽĚǁŝƚŚDĞƚŚŽĚKďũĞĐƚ Ϯϭϴŵϴ
The second case study evaluated the scalability of our
approach by applying it on a large-scale ecosystem of projects.
The results are presented in Table 7 and show that our
approach can eﬃciently detect a broad range of refactoring
types in Eclipse projects. Queries for each type of refactoring
ﬁnished in about 25 minutes on average. The exceptions were
“Consolidate Conditional”and“Replace nested conditionals
which took 59 minutes as the complex concretizations rely
on comparing features from both bytecode and source-code
vectors. As a contrast, we note that for the biggest project
in the ﬁrst case study, Ant version 5, the queries for each
type of refactorings took at most 40 seconds.
5.3 Threats to Validity & Future Work
Our approach relies on characteristic vectors, which results
in a threat to construct validity stemming from whether
the vectors can really represent refactorings. Although vec-
tors ignore various information in code (e.g., the ordering
or relations among program elements, the speciﬁc names of
identiﬁers), they have been shown to be eﬀective for code
clone detection [11,22], and the abstraction and concretiza-
tion operations take the features of each type of refactorings
into consideration, making the vectors more tailored for refac-
toring detection. However, since the vectors only count the
occurrences of basic program elements and do not encode
features needed for many other refactoring types in classical
collections [9,21], we will need to encode more features inthe vectors to go beyond the types of refactorings we can
detect now. The features encoded in the vectors are language-
dependent, so are some refactoring types; so our approach
may need adjustments for diﬀerent languages.
Our vector abstraction and concretization operations are
heuristic and learned from sample refactored code; so their
accuracies are dependent on the“quality”of the sample code.
We used sample code from classical collections, and aimed
to ensure precise encoding of the most essential changes
for each refactoring type; our results show good precisions.
However, there may also be biases in the evaluation of the
accuracy of the reported refactorings, since we relied on
manual investigation on selected samples by students, had
only compared with one previously existing tool for detectinghistorical refactorings, and we need a better way to evaluate
the recall rates of our approach.
In the near future, we plan to extend vector operations
for more refactoring types, apply our approach with more
sample refactored code to more subject programs, port our
implementation to other languages, conduct more system-
atic user studies to alleviate the above threats, and make
our tool and evaluation data available for other researchers.
Also, we plan to automate the deﬁnitions of abstraction and
concretization operations with ideas and techniques fromprogramming by examples [1,33,34] and apply detected
refactoring opportunities automatically.
6. CONCLUSION
This paper presents a new vector-based approach for s-
calable detection of refactorings. Our approach builds on
top of characteristic vectors that encode various code fea-
tures. Most importantly, it extends vectors with abstraction
and concretization operations to capture the features of the
code changes that may be induced by a refactoring opera-
tion. Such abstraction and concretization operations can be
extracted and reﬁned based on known refactored code sam-
ples. Both refactoring opportunities (i.e, code fragments that
may be restructured according to a refactoring type) and
historical refactorings (i.e., code fragments that have been
restructured according to a refactoring type) can be encoded
via concrete and abstracted vectors. Thus, our approach
reduces the problem of detecting refactorings to the problemof detecting matching vectors, which can be solved eﬃciently
in almost linear time with respect to vector numbers.
We have implemented our approach for Java and applied
the prototype to a large code base containing 200 bundleprojects from the Eclipse ecosystem and about 4.5 million
lines of code. Our prototype detects more than 32K instances
of 17 types of refactoring opportunities in about 7 hours. Wehave also applied our prototype to 14 versions of 3 programs
used in previous studies on refactoring detection, and found
191 instances of various types of historical refactorings across
consecutive versions of the programs, with a 92% precision.
Our prototype also detects more than 2.8K instances ofrefactoring opportunities within individual versions of the
programs, with a 87% precision.
7. ACKNOWLEDGMENTS
We appreciate the students’ time and eﬀorts in evaluat-
ing our results: Joseph Chan Joo Keng, Ta Quang Trung,
Liu Yang, and Zhiqing Zuo. This research is also partially
supported by a NUS research grant R-252-000-553-112.8. REFERENCES
[1]A. Cypher, editor. W a t c hW h a tID o :P r o g r a m m i n gb y
Demonstration . MIT Press, 1993.
[2]Y. Dang, D. Zhang, S. Ge, C. Chu, Y. Qiu, and T. Xie.
XIAO: tuning code clones at hands of engineers in
practice. In ACSAC, pages 369–378, 2012.
[3] M. Datar, N. Immorlica, P. Indyk, and V. S. Mirrokni.
Locality-sensitive hashing scheme based on p-stable
distributions. In 20th ACM Symposium on
Computational Geometry (SoCG) , pages 253–262, 2004.
[4] S. Demeyer, S. Ducasse, and O. Nierstrasz. Finding
refactorings via change metrics. In OOPSLA ,p a g e s
166–177, 2000.
[5]D. Dig, C. Comertoglu, D. Marinov, and R. E. Johnson.
Automated detection of refactorings in evolving
components. In ECOOP, pages 404–428, 2006.
[6] D. Dig, J. Marrero, and M. D. Ernst. Refactoring
sequential java code for concurrency via concurrent
libraries. In ICSE, pages 397–407, 2009.
[7] M. Fokaefs, N. Tsantalis, E. Stroulia, and
A. Chatzigeorgiou. JDeodorant: identiﬁcation and
application of extract class refactorings. In ICSE, pages
1037–1039, 2011.
[8] F. A. Fontana, M. Zanoni, A. Ranchetti, and
D. Ranchetti. Software clone detection and refactoring.
ISRN Software Engineering , online open access, 2013.
[ 9 ]M .F o w l e r ,K .B e c k ,J .B r a n t ,W .O p d y k e ,a n d
D. Roberts. Refactoring: Improving the Design of
Existing Code . Addison-Wesley Professional, 1999.
[10] L. Franklin, A. Gyori, J. Lahoda, and D. Dig.
LAMBDAFICATOR: from imperative to functional
programming through automated refactoring. In ICSE,
pages 1287–1290, 2013.
[11] M. Gabel, L. Jiang, and Z. Su. Scalable detection of
semantic clones. In ICSE, pages 321–330, 2008.
[12] A. Garrido and J. Meseguer. Formal speciﬁcation and
veriﬁcation of java refactorings. In 6th IEEE
International Workshop on Source Code Analysis and
Manipulation (SCAM) , pages 165–174, 2006.
[13]X. Ge and E. Murphy-Hill. Manual refactoring changes
with automated refactoring validation. In ICSE,p a g e
To appear, 2014.
[14]A. Gionis, P. Indyk, and R. Motwani. Similarity search
in high dimensions via hashing. In VLDB,p a g e s
518–529, 1999.
[15] M. W. Godfrey and L. Zou. Using origin analysis to
detect merging and splitting of source code entities.
IEEE TSE , 31(2):166–181, 2005.
[16] W. G. Griswold. Program Restructuring as an Aid to
Software Maintenance . PhD thesis, University of
Washington, 1991.
[17] W. R. Harris and S. Gulwani. Spreadsheet table
transformations from examples. In PLDI,p a g e s
317–328, 2011.
[18] S. Hayashi, Y. Tsuda, and M. Saeki. Detecting
occurrences of refactoring with heuristic search. In
APSEC, pages 453–460, 2008.
[19] Y. Higo, T. Kamiya, S. Kusumoto, and K. Inoue.
ARIES: refactoring support tool for code clone. ACM
SIGSOFT Software Engineering Notes , 30(4):1–4, 2005.[20] Y. Higo, S. Kusumoto, and K. Inoue. A metric-based
approach to identifying refactoring opportunities for
merging code clones in a java software system. Journal
of Software Maintenance , 20(6):435–461, 2008.
[21]JetBrains. Refactoring Source Code in IntelliJ IDEA 13.
http://www.jetbrains.com/idea/webhelp/
refactoring-source-code.html .
[22] L. Jiang, G. Misherghi, Z. Su, and S. Glondu.
Deckard : Scalable and accurate tree-based detection
of code clones. In ICSE, pages 96–105, 2007.
[23] E. J ¨urgens, F. Deissenboeck, B. Hummel, and
S. Wagner. Do code clones matter? In ICSE,p a g e s
485–495, 2009.
[24] T. Kamiya, S. Kusumoto, and K. Inoue. CCFinder: A
multilinguistic token-based code clone detection system
for large scale source code. IEEE TSE , 2002.
[25] C. Kapser and M. W. Godfrey.“cloning considered
harmful”considered harmful. In WCRE, 2006.
[26] H. Kim, Y. Jung, S. Kim, and K. Yi. MeCC: memory
comparison-based clone detector. In ICSE,p a g e s
301–310, 2011.
[27] M. Kim, M. Gee, A. Loh, and N. Rachatasumrit.
Ref-ﬁnder: A refactoring reconstruction tool based on
logic query templates. In FSE, pages 371–372, 2010.
[28] M. Kim, V. Sazawal, D. Notkin, and G. Murphy. An
empirical study of code clone genealogies. In
ESEC/FSE , 2005.
[29] R. L ¨ammel. Towards generic refactoring. In ACM
SIGPLAN workshop on Rule-based programming , pages
15–28, 2002.
[30] H. Liu, Y. Liu, G. Xue, and Y. Gao. Case study on
software refactoring tactics. IET Software , 8(1):1–11,
2014.
[31] H. Liu, Z. Ma, W. Shao, and Z. Niu. Schedule of bad
smell detection and resolution: A new way to saveeﬀort.IEEE TSE , 38(1):220–235, 2012.
[32] H. Liu, Z. Niu, Z. Ma, and W. Shao. Identiﬁcation of
generalization refactoring opportunities. Automated
Software Engineering , 20(1):81–110, 2013.
[33]
N. Meng, M. Kim, and K. S. McKinley. LASE: locating
and applying systematic edits by learning from
examples. In ICSE, pages 502–511, 2013.
[34] A. K. Menon, O. Tamuz, S. Gulwani, B. W. Lampson,
and A. Kalai. A machine learning framework for
programming by example. In 30th International
Conference on Machine Learning (ICML) ,p a g e s
187–195, 2013.
[35] T. Mens and T. Tourwe. A survey of software
refactoring. IEEE TSE , 30(2):126–139, Feb 2004.
[36] N. A. Milea, L. Jiang, and S.-C. Khoo. Scalable
detection of missed cross-function refactorings. In
ISSTA, pages 138–148, 2014.
[37] E. R. Murphy-Hill. Scalable, expressive, and
context-sensitive code smell display. In OOPSLA , pages
771–772, 2008.
[38] E. R. Murphy-Hill and A. P. Black. Refactoring tools:
Fitness for purpose. IEEE Software , 25(5):38–44, 2008.
[39] S. Negara, N. Chen, M. Vakilian, R. E. Johnson, and
D. Dig. A comparative study of manual and automated
refactorings. In ECOOP, pages 552–576, 2013.[40] A. T. Nguyen, T. T. Nguyen, H. A. Nguyen,
A. Tamrawi, H. V. Nguyen, J. M. Al-Kofahi, and T. N.
Nguyen. Graph-based pattern-oriented,
context-sensitive source code completion. In ICSE,
pages 69–79, 2012.
[41] H. A. Nguyen, T. T. Nguyen, N. H. Pham, J. M.
Al-Kofahi, and T. N. Nguyen. Clone management for
evolving software. IEEE TSE , 38(5):1008–1026, 2012.
[ 4 2 ]H .A .N g u y e n ,T .T .N g u y e n ,G .W i l s o n ,J r . ,A .T .
Nguyen, M. Kim, and T. N. Nguyen. A graph-based
approach to api usage adaptation. In OOPSLA ,p a g e s
302–321, 2010.
[43] T. T. Nguyen, H. A. Nguyen, N. H. Pham, J. M.
Al-Kofahi, and T. N. Nguyen. Graph-based mining of
multiple object usage patterns. In ESEC/SIGSOFT
FSE, pages 383–392, 2009.
[44] W. F. Opdyke. Refactoring Object-Oriented
Frameworks . PhD thesis, University of Illinois at
Urbana-Champaign (UIUC), 1992.
[45] K. Prete, N. Rachatasumrit, and M. Kim. A catalogue
of template refactoring rules. Technical Report
ECE-TR-04161, Department of Electrical and
Computer Engineering, University of Texas at Austin,
2010.
[46] K. Prete, N. Rachatasumrit, N. Sudan, and M. Kim.
Template-based reconstruction of complex refactorings.
InICSM, pages 1–10, 2010.
[47] N. Rachatasumrit and M. Kim. An empirical
investigation into the impact of refactoring on
regression testing. In ICSM, pages 357–366, 2012.
[48] C. K. Roy and J. R. Cordy. NICAD: Accurate
detection of near-miss intentional clones using ﬂexible
pretty-printing and code normalization. In ICPC, pages
172–181, 2008.
[49]A. Sæbjørnsen, J. Willcock, T. Panas, D. Quinlan, and
Z. Su. Detecting code clones in binary executables. In
ISSTA, pages 117–128, 2009.
[50] M. Sch ¨afer and O. de Moor. Specifying and
implementing refactorings. In OOPSLA , pages 286–301,
2010.[51] M. Shomrat and Y. Feldman. Detecting refactored
clones. In ECOOP, volume 7920 of Lecture Notes in
Computer Science , pages 502–526, 2013.
[52] Q. D. Soetens, J. Perez, and S. Demeyer. An initial
investigation into change-based reconstruction of
ﬂoss-refactorings. In ICSM, pages 384–387, 2013.
[53] C. Sun, S.-C. Khoo, and S. J. Zhang. Graph-based
detection of library api imitations. In ICSM, pages
183–192. IEEE, 2011.
[54] R. Tairas. Clone detection and refactoring. In
OOPSLA , pages 780–781, 2006.
[55]K. Taneja, D. Dig, and T. Xie. Automated detection of
API refactorings in libraries. In ASE, pages 377–380,
2007.
[56] T. Tourwe and T. Mens. Identifying refactoring
opportunities using logic meta programming. In CSMR,
pages 91–100, March 2003.
[57] N. Tsantalis and A. Chatzigeorgiou. Identiﬁcation of
extract method refactoring opportunities. In CSMR,
pages 119–128, 2009.
[58]F. Van Rysselberghe and S. Demeyer. Evaluating clone
detection techniques from a refactoring perspective. In
19th ASE , pages 336–339, 2004.
[59] M. Verbaere, R. Ettinger, and O. de Moor. JunGL: a
scripting language for refactoring. In ICSE, pages
172–181, 2006.
[60] P. Weissgerber and S. Diehl. Identifying refactorings
from source-code changes. In ASE, pages 231–240,
2006.
[61] J. Yang, D. Evans, D. Bhardwaj, T. Bhat, and M.Das.
Perracotta: Mining temporal API rules from imperfect
traces. In ICSE, 2006.
[62] H. Zhong, L. Zhang, and H. Mei. Inferring
speciﬁcations of object oriented APIs from API source
code. In APSEC, pages 221–228, 2008.
[63] H. Zhong, L. Zhang, T. Xie, and H. Mei. Inferring
resource speciﬁcations from natural language API
documentation. In ASE, pages 307–318, 2009.