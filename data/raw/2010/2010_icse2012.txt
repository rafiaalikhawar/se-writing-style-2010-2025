Maintaining Invariant Traceability through Bidirectional Transformations
Yijun Yu1, Yu Lin2, Zhenjiang Hu3, Soichiro Hidaka3, Hiroyuki Kato3, and Lionel Montrieux1
1Department of Computing, The Open University, Milton Keynes, United Kingdom
2Department of Computer Science, University of Illinois at Urbana-Champaign, USA
3National Institute of Informatics, Tokyo, Japan
Abstract ‚ÄîFollowing the ‚Äúconvention over conÔ¨Åguration‚Äù
paradigm, model-driven development (MDD) generates code to
implement the ‚Äúdefault‚Äù behaviour that has been speciÔ¨Åed by a
template separate from the input model, reducing the decision
effort of developers. For Ô¨Çexibility , users of MDD are allowed
to customise the model and the generated code in parallel. A
synchronisation of changed model or code is maintained by
reÔ¨Çecting them on the other end of the code generation, as
long as the traceability is unchanged. However, such invariant
traceability between corresponding model and code elements
can be violated either when (a) users of MDD protect custom
changes from the generated code, or when (b) developers of
MDD change the template for generating the default behaviour.
A mismatch between user and template code is inevitable as
they evolve for their own purposes. In this paper, we propose a
two-layered invariant traceability framework that reduces the
number of mismatches through bidirectional transformations.
On top of existing vertical (model $code) synchronisations be-
tween a model and the template code, a horizontal (code$code)
synchronisation between user and template code is supported,
aligning the changes in both directions. Our blinkit tool is
evaluated using the data set available from the CVS repositories
of a MDD project: Eclipse MDT/GMF.
I. I NTRODUCTION
Aiming at productivity, ‚Äúconvention over conÔ¨Åguration‚Äù
is a software design paradigm meant to reduce the decision
effort of developers while preserving Ô¨Çexibility. Following
this paradigm, model-driven development (MDD) of soft-
ware projects (e.g., Eclipse Modeling Framework, EMF)
generates code from models to implement the ‚Äúdefault‚Äù
behaviour, which was speciÔ¨Åed by a template separate from
the input model. As users of MDD, programmers are allowed
to customise the generated code, and the modellers are al-
lowed to modify the models further. To support the eventual
round-trip synchronisation of model and code [1], markers
for traceability correspondence (e.g., @generated ) are
inserted at the beginning of the generated methods by
MDD, indicating to the programmers that all changes to the
model and the template will be reÔ¨Çected by the annotated
method. In other words, any change made by programmers
on such methods will get lost after another round of code
generation. In order to protect such changes in the user code
from getting lost, programmers are allowed to modify the
@generated marker to @generated NOT , instructing
the code generators to skip the user-speciÔ¨Åed methods.
This technique is common in MDD practice, for an-
other example, the Acceleo Model2Text project uses‚Äú[protected] ... [/protected] ‚Äù annotations to
enclose user-speciÔ¨Åed parts for arbitrary textual outputs. To
illustrate its problematic use in development, we use EMF,
the Eclipse Modeling Framework (EMF)as an exemplar
MDD framework: The template code is generated by EMF
Ô¨Årst, later reÔ¨Åned manually into functioning user code. Once
programmers change the model and regenerate the template
code, its traceability to the user code becomes necessary.
Ideally, a round-trip engineering approach should support
the correct propagation of changes in both directions [2].
Current state-of-the-art MDD tools such as EMF main-
tain the synchronisation of model and code by reÔ¨Çect-
ing changes in both directions. However, such invariant
traceability links between corresponding model and code
elements can be easily violated either when (a) users of
MDD protect custom changes from the generated code by
changing @generated to@generated NOT or when (b)
developers of MDD change the template for generating the
default behaviour for those @generated methods, losing
all users‚Äô change(s). In either case, a better solution would
be to preserve the changes made by the users as well as the
changes made on the model as long as they are consistent.
In Section III, a detailed example will illustrate the problems
such a mismatch can cause.
We consider in this paper that the mismatch problem
between user-modiÔ¨Åed and template-generated (hereafter
‚Äúuser‚Äù and ‚Äútemplate‚Äù) codes is inevitable as they evolve
for their own purposes, and propose a two-layered invariant
traceability framework that merges the changes when possi-
ble through bidirectional transformations. The Ô¨Årst layer of
the framework synchronises the structural changes between
the model and the template code at the API level vertically
(denoted by model $code) using existing state-of-the-art
MDD tools such as EMF; the second layer synchronises
the behavioural changes between the template code and the
user code inside the method bodies horizontally (denoted by
code$code) if users wish to preserve both types of changes.
Aligning these changes in both directions, our blinkit
tool is evaluated using the data set available from the CVS
repositories of the Eclipse MDD projects EMF and GMF.
To effectively use the invariant traceability frame-
work, users only need to insert a traceability annotation
@generated INV , instructing the code generator to au-
See http://www.eclipse.org/modeling/emftomatically (a) compute the differences between the current
template and user-modiÔ¨Åed methods; and (b) derive a bidi-
rectional transformation for future code generation to reÔ¨Çect
changes of the model or changes of the template back to
the users methods. The tool raises warnings when there are
inconsistencies between the template and the user code.
A prototype has been successfully applied to changes
recorded in the evolution of the GMF framework from its
CVS repository, which shows that our new approach of
round-trip engineering is promising and potentially useful
in practice. Fig. 1 presents an overview of blinkit when
it is applied to the case study of EMF/GMF, where EMF
is the synchronisation framework for vertical traceability
andblinkit is the horizontal synchronisation counterpart.
Examples indicate that when the complementary changes to
templates and user-modiÔ¨Åed code are conÔ¨Çicting or redun-
dant, our tool can avoid some dead code redundancies and
raise some warnings as compilation errors.
Our major technical contributions are listed as follows:
From a user‚Äôs perspective, a new type of annotations
@generated INV is supported as explicit mark-
ers for automatic maintenance of invariant trace-
ability between template ( @generated ) and user
(@generated NOT ) code, whereas @generated
NOT marked methods only keep user‚Äôs change while
ignoring changes made to the model.
A novel algorithm is proposed for automatically gener-
ating a one-pass bidirectional transformation from the
meaningful differences between the template code and
arbitrarily modiÔ¨Åed user code such that the round-trip
relation between the structures of the model and the
code can be correctly maintained.
An empirical study is done on a CVS repository of
the state-of-the-art MDD project GMF, highlighting
thebeneÔ¨Åts of maintaining invariant traceability links,
especially when there are 178 changes to the @model
parts have impact on the bodies of 54% of the 28,070
revisions of methods marked by @generated NOT .
Compared to existing MDD and traceability approaches,
blinkit derives invariant transformations automatically
from meaningful changes in the source code [3]. Unlike our
initial work that proposes to apply bidirectional transforma-
tions directly on class diagrams and Java code [4], this work
takes full advantages of the state-of-art synchronisations of
many-to-many vertical traceability links between the model
and the template code, such that the horizontal bidirectional
transformations are applied only to the method bodies rele-
vant to the user-modiÔ¨Åed behaviours. Since the template and
the user method code are at the same level of abstraction,
blinkit is allowed to derive a forward transformation
from the user method to the generated method. Our initial
work [4] needs to monitor the execution logs of user-
speciÔ¨Åed ATL transformations, which is no longer needed.
CVS	 ¬†(GMF)	 ¬†
Generated	 ¬†elements	 ¬†(EMF	 ¬†@generated)	 ¬†
v2	 ¬†
v1	 ¬†
Modeling	 ¬†elements	 ¬†(EMF	 ¬†@model)	 ¬†
v2	 ¬†
v1	 ¬†
User	 ¬†modiÔ¨Åed	 ¬†elements	 ¬†(EMF	 ¬†@generated	 ¬†INV)	 ¬†
v2	 ¬†
v1	 ¬†Horizontal	 ¬†Bidirec2onal	 ¬†	 ¬†Sync.	 ¬†
ver=cal	 ¬†sync.	 ¬†(EMF)	 ¬†Figure 1. An overview of the horizontal and vertical traceability links in
the bidirectional invariant traceability framework: blink . V1 and V2 are
two revisions of model, template or user codes extracted from the CVS
repository of a software development project using EMF code generation.
The remainder of this paper is organised as follows:
Section II gives preliminary knowledge on EMF and in-
troduces the bidirectional transformation mechanism. Sec-
tion III provides one example to illustrate the synchronisa-
tion problem of invariant traceability. Section IV overviews
the round-trip process for horizontal and vertical invariant
traceability and indicates the position of blinkit in the
overall process. Section V describes the technical details of
blinkit , the generation of bidirectional transformations
from meaningful changes, and the one-pass optimisation for
efÔ¨Åciency. Section VI presents the observations of the CVS
evolution history of the GMF project to show the number of
cases where the @generated INV markers can be useful.
Section VII compares related work, Section VIII concludes.
II. B ACKGROUND
A. EMF as a state-of-the-art MDD framework
The Eclipse Modeling Framework (EMF) is a MDD
framework and a code generation facility for building
Eclipse tools and other applications around a structured
model. From a meta-model speciÔ¨Åed in XMI or XML
Schema, EMF generates default (i.e., template) Eclipse
plugin tools that consist of Java classes for manipulating
a model, along with Java adapter classes for viewing and
editing a model. From a rather complex meta-model, it is
impractical to generate all source code because programmers
may customise the default behaviour by modifying some
parts of the code in order to achieve their own goals. Using
EMF, the template code is generated Ô¨Årst, and later reÔ¨Åned
manually into functioning user code. Once programmers
change the model and regenerate the template code, it brings
the necessity of the traceability to and from the user code.
The MDD part of the EMF consists of one code gen-
eration component (i.e., JMerge) to generate source code
from a meta-model (i.e., .ecore). The template used by the
code generator is speciÔ¨Åed in the JavaJET template language
similar to that of JSP, which will bind the template variables1
2a 
3 b 
4c 
5a a c
6dFigure 2. A simple rooted and edge-labelled graph
with the default values speciÔ¨Åed in the corresponding .gen-
model conÔ¨Åguration Ô¨Åles. There is no one-to-one mapping
between a class operation to a Java method in this code
generation: A class in the class model can be implemented
in multiple classes in the model ,impl ,util ,edit , and
editor packages, scattered across the generated model ,
edit ,editor , and test plugins. In addition, there will
bePackage andFactory classes created and instantiated
by the classes in the model. It is hard to maintain such many-
to-many relations using traditional traceability techniques.
Note that EMF is used in this study both as a subject
matter (as part of the MDT case study), as well as a
component of our solution. Parts of the EMF tool were
generated using the EMF code generator as well. It can be
seen from the existing EMF implementation that developers
marked some methods as @generated NOT to preserve
the changes that cannot be generated from the Ecore models
alone. It can therefore be expected that the code generated
from EMF will be modiÔ¨Åed by users.
B. Bidirectional Transformation
We use GRoundTram [5] to do bidirectional graph trans-
formations. This well-behaved framework guarantees the
round-trip property in bidirectional model transformations.
A model transformation is described in UnQL+ [6], an
extension of the SQL-like graph query language UnQL [7]
with three graph update constructs to achieve efÔ¨Åciency and
expressiveness, namely Replacing, Deleting, and Extending.
The model transformation is then desugared to the core
algebra (UnCal) which consists of a set of constructors
for building graphs and a powerful structural recursion for
manipulating graphs. This graph algebra can have clear
bidirectional semantics and be efÔ¨Åciently evaluated in a
bidirectional manner [8]. Graphs (models) in UnQL+ are
rooted and edge-labelled (i.e. all information is stored as
labels on edges rather than on nodes and the labels on nodes
have no particular meaning), and represented in UnCAL or
the standard Dot format which can be visualised and edited
by the popular Graphviz tool [9].
To illustrate UnQL+, consider a simple graph $db(the
root is the node 1) in Fig. 2. We can select the subgraph
pointed by the edge labelled bfrom the root by
select $gwherefb: $ggin$db;delete the subgraph rooted at node 5reached by b:aby
delete b:a! in$db;
and insert a subgraph Gunder the node reached from the
patha:aby
extend a:a! with Gin$db:
III. A M OTIVATING EXAMPLE
To illustrate the problem concretely, we use a constructed
example here. Suppose an EMF user initially speciÔ¨Åes a
simple model that consists of one Entity class with a
single name attribute. Using the code generation feature
of EMF, she will obtain a default implementation which
consists of 8 compilation units in Java (Fig. 3).
)
Figure 3. Default code generated from the EMF meta-model
Fig. 4 lists parts of the generated code. The Entity
Java interface has getter and setter methods for the name
attribute. They are commented with @generated annota-
tions which indicate that the methods are part of the default
implementation. Similarly, such @generated annotations
are added to every generated element in the code, e.g., shown
in the skeleton of EntityImpl Java class.
The annotation @generated deÔ¨Ånes a single-trip trace-
ability contract from the model to the annotated code
element. A change in the model or a change in the mod-
elling framework can be propagated to the generated code;
however, a change on the generated code will not cause a
change to the reÔ¨Çected model and will thus be discarded
upon next code generation.
Because the default implementation is not always desired,
the code generation shall keep user speciÔ¨Åed changes as
long as they are not inside the range of generated trace-
ability, the set of methods marked by @generated that
keeps the changes of generated templates. This can be
achieved by adapting the @generated annotation into
@generated NOT , a non-binding traceability that reÔ¨Çects
programmers‚Äô intention that it will not be changed when
the implementation code is regenerated. Note that such non-
binding traceability indicated by @generated NOT is still
different from those without any annotation at all: Without
such an annotation, EMF will generate new implementation
of a method body following the templates.1package example ;
2import org . e c l i p s e . emf . e c o r e . EObject ;
3/ @model/
4p u b l i c i n t e r f a c e E n t i t y extends EObjectf
5 / @model/p u b l i c S t r i n g getName ( ) ;
6 / @generated/void setName ( S t r i n g v a l u e ) ;
7g
1package example . impl ;
2import example . E n t i t y ;
3 . . .
4/ @generated/
5p u b l i c c l a s s E n t i t y I m p l extends EObjectImpl
implements E n t i t yf
6 . . .
7 / @generated/
8 p r o t e c t e d S t r i n g name = NAME EDEFAULT;
9 . . .
10 / @generated/
11 p u b l i c S t r i n g getName ( ) freturn name ;g
12 / @generated/
13 p u b l i c void setName ( S t r i n g newName ) f. . .g
14 . . .
15 / @generated/
16 @Override
17 p u b l i c S t r i n g t o S t r i n g ( ) f
18 i f( e I s P r o x y ( ) ) return super . t o S t r i n g ( ) ;
19 S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( super
. t o S t r i n g ( ) ) ;
20 r e s u l t . append ( ‚Äù ( name : ‚Äù ) ;
21 r e s u l t . append ( name ) ;
22 r e s u l t . append ( ‚Äô ) ‚Äô ) ;
23 return r e s u l t . t o S t r i n g ( ) ;
24g
25g/ / E n t i t y I m p l
Figure 4. Parts of the generated code in Fig. 3
This workaround is not ideal. If a user parametrises the
toString() method to append an additional type to the
returned result. To guard the method from being overwritten
by future code generations, the annotation @generated
NOT is used. She also applies a Rename Method refactoring,
changing the getName method into getID . The modiÔ¨Åed
parts are shown in Fig. 5. Propagating these changes back
to the model, the name attribute will be renamed into iD
automatically, following the naming convention that attribute
identiÔ¨Åers start with a lower case character.
The regeneration of the code will result in the changes
in Fig. 6: the setter methods and the implementations of
both getter/setter methods are modiÔ¨Åed according to the
default implementation of the new model. These are ex-
pected. However, two unexpected changes are not desirable.
First, a compilation error results from the change in the
default implementation, where the attribute name used in
the user controlled code no longer exists. Second, the default
implementation of the toString() method is generated
with the original signature, which will of course become
dead code since the user has already modiÔ¨Åed all call sites
oftoString() to reÔ¨Çect the insertion of the new type.
Similarly, the user speciÔ¨Åed toString() method can also
become dead code, if it is no longer invoked by the new
default implementation.
Compilation errors are relatively easy to spot by the
programmer with the aid of the Eclipse IDE, but the dead1/ @model/
2p u b l i c i n t e r f a c e E n t i t y extends EObjectf
3/ @model/p u b l i c S t r i n g g e t Name:ID ( ) ;
4/ @generated/p u b l i c void setName ( ) ;
5g
6 . . .
7/ @generated/
8p u b l i c c l a s s E n t i t y I m p l extends EObjectImpl
implements E n t i t yf
9 / @generated/
10 p u b l i c S t r i n g g e t Name::ID ( )freturn name ;g
11 . . .
12 / @generated::::NOT/
13 @Override
14 p u b l i c S t r i n g t o S t r i n g (::::String:::type )f
15 i f( e I s P r o x y ( ) ) return super . t o S t r i n g ( ) ;
16 S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( super
. t o S t r i n g ( ) ) ;
17 r e s u l t . append ( ‚Äù ( name : ‚Äù ) ;
18 r e s u l t . append ( name ) ;
19 r e s u l t . append ( ‚Äô ) ‚Äô ) ;
20:::::::::::::result.append(type);
21 return r e s u l t . t o S t r i n g ( ) ;
22g
23g/ / E n t i t y I m p l
+
Figure 5. User modiÔ¨Åcations to the generated code: insertions are
:::::::underlined and the deletions are stroked out; the changes are reÔ¨Çected
code problems are more subtle because the IDE will not
complain. Therefore, it will be more difÔ¨Åcult for developers
to notice the consequences.
Ideally, the user should be able to specify which parts
of her changes to the code need to be kept rather than
overwritten by code generation. For this purpose, a new
annotation for invariant traceability (@generated INV )
will be used in our proposed approach. As a result, Fig. 7
illustrates the changes to be propagated to users‚Äô code after
our approach of bidirectional transformations is adopted.
IV. O VERVIEW OF blinkit
The prototype blinkitysupports our idea of main-
taining the traceability of the user code and template
code through bidirectional transformations. Fig. 8 gives
an overview of the dataÔ¨Çow of the components inside
blinkit . Dashed arrows represent the external changes
made by developers or vertical synchronisations between
models and template code, whilst the open- or close-ended
solid arrows represent forward and backward transforma-
tions, respectively. First, developers deÔ¨Åne an original EMF
model and synchronise with the template code from the EMF
engine ( 1). Developers may modify the template code into
user code to meet their requirements and mark some parts
of their code with the @generated INV annotation ( 2).
Developers can change the model if needed ( 3) and re-
yblinkit can be downloaded from http://sead1.open.ac.uk/linkit/)
 )
1/ @model/
2p u b l i c i n t e r f a c e E n t i t y extends EObjectf
3/ @model/p u b l i c S t r i n g getID ( ) ;
4/ @generated/p u b l i c void s e tName::ID ( ) ;
5g
6 . . .
7/ @generated/
8p u b l i c c l a s s E n t i t y I m p l extends EObjectImpl
implements E n t i t yf
9 / @generated/
10 p u b l i c S t r i n g getID ( ) freturn name::iD ;g
11 . . .
12::::::::::/**@generated*/
13::::public::::String:::::::toString()::f
14:if::::::::(eIsProxy()):::::return:::::::::::super.toString();
15::::::::StringBuffer::::result:=::::new::::::::::::::::::::StringBuffer(super.toString());
16::::::::::result.append(‚Äù:::(iD:::‚Äù);
17::::::::::::result.append(iD);
18::::::::::::result.append(‚Äô)‚Äô);
19::::return:::::::::::result.toString();
20:g
21 / @generated NOT /
22 p u b l i c S t r i n g t o S t r i n g ( S t r i n g t y p e ) f
23 i f( e I s P r o x y ( ) ) return super . t o S t r i n g ( ) ;
24 S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( super
. t o S t r i n g ( ) ) ;
25 r e s u l t . append ( ‚Äù ( name : ‚Äù ) ;
26 r e s u l t . append ( name ) ;
27 r e s u l t . append ( ‚Äô ) ‚Äô ) ;
28 r e s u l t . append ( t y p e ) ;
29 return r e s u l t . t o S t r i n g ( ) ;
30g
31g/ / E n t i t y I m p l
Figure 6. Regenerated code from the model: insertions are:::::::underlined and
the deletions are stroked out, the compilation error is doubly underlined.
synchronise the code using EMF ( 4). Note that, without
blinkit , (4) may lose developers‚Äô modiÔ¨Åcations.
Having the above steps performed by developers,
blinkit will generate a bidirectional transformation in
the UnQL+ language by comparing the user code (denoted
byU0) and the original template code (denoted by T). The
forward transformation uses this generated transformation.
We represent the code by speciÔ¨Åc graphs and compare the
graphs to generate UnQL+ in Section V-A. to take the mod-
iÔ¨Åed user code (denoted by U0) as inputs, which generates
an intermediate code that will be the same as the template
codeT, such that the trace information stored by the forward
transformation can be applied to the corresponding backward
transformation. In the backward transformation, the interme-
diate code Tand the modiÔ¨Åed template code (denoted by
T0) are used as inputs and the output is the merged code1/ @model/
2p u b l i c i n t e r f a c e E n t i t y extends EObjectf
3/ @model/p u b l i c S t r i n g g e t Name:ID ( ) ;
4/ @generated/p u b l i c void setName ( ) ;
5g
6 . . .
7/ @generated/
8p u b l i c c l a s s E n t i t y I m p l extends EObjectImpl
implements E n t i t yf
9 / @generated/
10 p u b l i c S t r i n g g e t Name::ID ( )freturn name ;g
11 . . .
12 / @generated:::INV/
13 @Override
14 p u b l i c S t r i n g t o S t r i n g (::::String:::type )f
15 i f( e I s P r o x y ( ) ) return super . t o S t r i n g ( ) ;
16 S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( super
. t o S t r i n g ( ) ) ;
17 r e s u l t . append ( ‚Äù ( name : ‚Äù ) ;
18 r e s u l t . append ( name ) ;
19 r e s u l t . append ( ‚Äô ) ‚Äô ) ;
20:::::::::::::result.append(type);
21 return r e s u l t . t o S t r i n g ( ) ;
22g
23g/ / E n t i t y I m p l
+
1/ @model/
2p u b l i c i n t e r f a c e E n t i t y extends EObjectf
3/ @model/p u b l i c S t r i n g getID ( ) ;
4/ @generated/p u b l i c void s e tName::ID ( ) ;
5g
6 . . .
7/ @generated/
8p u b l i c c l a s s E n t i t y I m p l extends EObjectImpl
implements E n t i t yf
9 / @generated/
10 p u b l i c S t r i n g getID ( ) freturn name::iD ;g
11 . . .
12 / @generated INV /
13 p u b l i c S t r i n g t o S t r i n g ( S t r i n g t y p e ) f
14 i f( e I s P r o x y ( ) ) return super . t o S t r i n g ( ) ;
15 S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( super
. t o S t r i n g ( ) ) ;
16 r e s u l t . append ( ‚Äù ( name:iD : ‚Äù ) ;
17 r e s u l t . append ( name:iD ) ;
18 r e s u l t . append ( ‚Äô ) ‚Äô ) ;
19 r e s u l t . append ( t y p e ) ;
20 return r e s u l t . t o S t r i n g ( ) ;
21g
22g/ / E n t i t y I m p l
Figure 7. The use of invariant traceability to propagate changes in the
backward direction resulting in T0+U0.
(denoted by T0U0), which not only reÔ¨Çects the changes
made to the model but also conserves the modiÔ¨Åcations
applied by the developers in 2. Notice that the intermediate
code is the same as the template code in our approach. We
do not substitute it by the template code because it separates
the forward and backward transformation and makes the
transformation process clearer.
V. I MPLEMENTATION OF blinkit
We will illustrate the implementation of blinkit by Ô¨Årst
explaining the overall process, then providing details for the
critical steps for correctness and efÔ¨Åciency.Original	 ¬†model	 ¬†
Template	 ¬†code	 ¬†(T)	 ¬†
1 
User-¬≠‚ÄêmodiÔ¨Åed	 ¬†code	 ¬†(U‚Äô)	 ¬†
2 
ModiÔ¨Åed	 ¬†model	 ¬†
ModiÔ¨Åed	 ¬†Template	 ¬†code	 ¬†(T‚Äô)	 ¬†
UnQL+	 ¬†transforma=on	 ¬†
‚Ç¨ 
Merged	 ¬†Code	 ¬†(T‚Äô	 ¬†	 ¬†	 ¬†	 ¬†U‚Äô)	 ¬†	 ¬†
Œî	 ¬†MCT	 ¬†
GRoundTram	 ¬†
3 
4 
External Changes Forward transf. Backward transf. 
Optional Check 
Meaningful Diff Figure 8. The data Ô¨Çows inside blinkit
A. The Overall Process
We use GRoundTramzto perform bidirectional transfor-
mations and to keep the traceability of the template and
user method bodies. GRoundTram adopts input graphs
which are represented in UnCal orDot format. Thus,
in order to perform bidirectional transformations on Java
code generated by EMF through GRoundTram , we Ô¨Årst
translate Java code into UnCal orDot (i.e. using UnCal
orDot to represent Java source code). When translating Java
code into UnCal orDot, we adopt the EMF model as an
intermediate representation of Java code since EMF model is
much more navigable than speciÔ¨Åc abstract syntax trees and
can be manipulated more easily. After we get the UnCal or
Dot graphs, we can generate UnQL+ [10] automatically and
perform bidirectional transformations using GRoundTram .
To achieve such a round-trip process, our framework
involves four engineering steps on either side of the for-
ward/backward directions to support the code $code hori-
zontal synchronisation between the evolving template and
user code (see Fig. 9). Without loss of generality, in the fol-
lowing we denote the template-generated and user-modiÔ¨Åed
codes as TandU0, the modiÔ¨Åed template codes as T0, and
the merged code as T0U0, respectively.
1) Given that Java codes T; T0were generated and syn-
chronised from the model using EMF‚Äôs built-in verti-
cal synchronisation with user‚Äôs Java codes U0except
for those methods that are marked by @generated
INV, we Ô¨Årst parse all the @generated INV meth-
ods in T; T0; U0using the JaMoPP parser on top
of the EMFtext frameworkx. The differences be-
tween TandU0are obtained using the API of
theEMFcompare framework{after the meaningful
differences were preprocessed using mctk. Here the
differences are a comprehensive representation of code
rather than editing operations;
zSee http://www.biglab.org
xSee http://www.jamopp.org
{See http://www.eclipse.org/emf/compare
kSee http://sead1.open.ac.uk/mct [3]2) The EMF models of T; T0; U0are translated into our
speciÔ¨Åc UnCal graphs using Ecore ‚Äôs reÔ¨Çection API,
and as a by-product, an UnQL+ transformation is
generated from the meaningful differences between T
andU0using the algorithm in Fig. 10;
3) The UnCal graphs of T; T0; U0are transformed into
Dot graphs by GRoundTram , which preserves the
paths from the graph root to any node on the UnCal
graphs in the equivalent Dot graphs;
4) Using the generated UnQL+ transformation and the
Dot graphs of U0as inputs, the GRoundTram system
also performs a forward transformation to output a
group of Dot graphs that represent T, guaranteed by
the one-pass optimisation described in Section V-C;
5) Backwards, using the same UnQL+ transformation on
theDot graphs of the modiÔ¨Åed template code T0,
and the internal graph traceability between TandU0
kept by the forward transformations that performs a
backward transformation to output the Dot graphs that
represent the merged user code, denoted by T0U0;
6) Path-equivalent Uncal graphs corresponding to T0
U0; are re-generated from the resulting Dot graphs;
7) An equivalent EMF model of those Uncal graphs
forT0U0is obtained using an Xtext parserof
Uncal to process its abstract syntax using EMF API;
8) Finally, the merged Java code T0U0is obtained from
the EMF model using JaMoPP ‚Äôs pretty-print function.
Since we have a TXL-based parser to generate Dot
graphs [3], our presented technique is not limited to EMF
based external representations of Java. As long as a code
generation framework for vertical synchronisation is avail-
able, it will be possible to adapt our horizontal synchornisa-
tion framework. However, we do not intend to implement the
vertical synchonisation baseline because it will be complex
to maintain one-to-many traceability links invariant.
To apply our approach effectively, one can initially at-
tach INV to all @generated Java methods as a trivial
identity bi-transformation. Once an inconsistency warning is
raised, the marker can be modiÔ¨Åed to either @generated
or@generated NOT incrementally, in order to preserve
template- or user-modiÔ¨Åed changes respectively. Users in-
troducing @generated INV are currently responsible for
resolving the warnings.
Figure 9. The multi-tier architecture of blinkit
See http://www.eclipse.org/XtextB. Generating Correct UnQL+ Transformations
To enable the use of UnQL+ on MDD, we need to
make sure that translating the artifacts between the code,
theUnCal graphs and node-traced graphs such as Graphviz
Dot does not lose information. This can be done in a multi-
tier fashion [11], and one critical step is to guarantee the
correctness of the horizontal (code $code) synchronisation,
that is to generate a correct UnQL+ bidirectional transfor-
mation from the meaningful differences between the original
template code and the modiÔ¨Åed user code.
1:function UNQLG ENERATOR (dotUser, dotTemplate)
2: rootUser the root node of dotUser
3: rootTemplate the root node of dotTemplate
4: MatchingDot(rootUser, rootTemplate)
5:end function
6:function MATCHING DOT(nodeUser; nodeTemplate )
7: edgeSetUser outgoing edges of nodeUser
8: edgeSetTemplate  outgoing edges of nodeTemplate
9: for all edgeUser2edgeSetUser do
10: flag =false
11: childNodeUser target node of edgeUser
12: for all edgeTemplate2edgeSetTemplate do
13: ifedgeUser =edgeTemplate then
14: flag =true
15: childNodeTemplate  
16: the target node of edgeTemplate
17: MatchingDot(childNodeUser, childNodeTemplate)
18: end if
19: end for
20: ifflag =false then
21: DeleteConstructor(childNodeUser)
22: end if
23: end for
24: for all edgeTemplate2edgeSetTemplate do
25: flag =false
26: childNodeTemplate  target node of edgeTemplate
27: for all edgeUser2edgeSetUser do
28: ifedgeTemplate =edgeUser then
29: flag =true
30: end if
31: end for
32: ifflag =false then
33: ExtendConstructor(childNodeTemplate)
34: end if
35: end for
36: end function
Figure 10. Procedure of generating UnQL+
We can then use the Dot graphs as inputs to perform
bidirectional transformations: GRoundTram needs to use
bidirectional transformations speciÔ¨Åed in the UnQL+ graph
transformation language. As we said in Section IV, UnQL+
is used in forward transformations to convert user code into
intermediate code which is the same as template code. Weimplemented an algorithm shown in Fig. 10 to generate the
UnQL+ transformation automatically in order to mitigate
developers‚Äô burden. After representing the Java code that
we want to synchronise using Dot graphs, we can compute
the differences between the Dot graphs and such differences
can be used to generate UnQL+ automatically.
The UnQL+ generated by our approach only contains
Deleting and Extending operations. Replacing operations
can be replaced by a Deleting and an Extending operation.
TheUnQLGenerator algorithm starts node matching from
the root in the Dot graphs. For each node pair, we compare
their outgoing edges‚Äô labels. If we Ô¨Ånd one edge which
exists in the user‚Äôs graph but does not exist in the template‚Äôs
graph, that means deletion occurs and we will generate a
Deleting operation to delete the subgraph beneath the node
under comparison (Lines 20-22 in Fig. 10); if the two edges
have the same labels, we will do node matching for their
children recursively (Lines 13-18). Similarly, for those edges
that the template‚Äôs graph has but the user‚Äôs graph does not,
we need an Extending operation (Lines 32-34). For the
Extending operation, we have to record the subgraph that
needs to be inserted. To generate UnQL+ transformation,
path information composed by edge labels is needed in order
to denote which part should be deleted or inserted. Since
the labels on the outgoing edges of one node are different
from each other in our Dot graphs, such paths which reÔ¨Çect
the changes between two Dot graphs are unique. We have
to obtain such paths to generate UnQL+ transformation and
the uniqueness of the paths guarantees the correctness of our
UnQL+ generated algorithm (i.e. if there are two outgoing
edges of a node with the same label, this algorithm may not
generate the desired UnQL+ transformation).
An example is shown to illustrate this algorithm (Fig. 11).
We transform the graph shown in Fig. 11(a) into the one in
Fig. 11(d). We have to delete the edge e,gandsubgraph
2, and insert the edge hand subgraph 4 . The algorithm
Ô¨Årst generate Deleting operations which could transform
Fig. 11(a) into Fig. 11(b). Note that the Deleting operations
contain the deletion of subgraph 3 and edge fthough they
should not be deleted. This is because when the algorithm
deletes the edge g, it will also delete its pointed subgraphs
(subgraph 3 ) and the edges connected to those subgraphs
(edge f). Then when generating the Extending operation,
the algorithm not only inserts the edge handsubgraph 4 ,
but also inserts the edge fandsubgraph 3 again. This extra
deletion and insertion may reduce the transformation‚Äôs efÔ¨Å-
ciency and more efÔ¨Åcient algorithms should be explored in
the future work. Comparison algorithms for trees and graphs
based on dynamic programming [12] may be adopted.
C. Derivation of a One-Pass Transformation
The automatically generated UnQL+ transformations are
not optimal. One performance bottleneck is that there are
typically multiple pairs of different elements, leading to mul-
tiple basic editing operations composed sequentially. Ideally,1
2 3
S u b g ra p h  14a bc
d e fg1
2 3
S u b g ra p h  24
S u b g ra p h  3abc
de fg
1
23 4
S u b g ra p h  3abc
dfh1
2 3 4abc
dfh(a ) (b )
(c ) (d )D e le tin g
E x te n d in g
S u b g ra p h  2 S u b g ra p h  3 S u b g ra p h  1
S u b g ra p h  1 S u b g ra p h  4 S u b g ra p h  1 S u b g ra p h  3 S u b g ra p h  1Figure 11. An example to illustrate the algortihm in Fig. 10
these operations should be composed in parallel as one
single graph transformation such that GRoundTram could
obtain results in one pass of traversing the graph structure. In
theory, the composition of general UnQL+ transformations
has to be sequential. However, the transformations we ob-
tained from the diff results have nice properties that make it
possible to compose the basic operations in parallel without
introducing any side effect. The rationale is given below.
Lete1; e2; : : : ; e nbe a sequence of the editing operations
obtained above, where any two editing operations, eiand
ej, are independent in the sense that neither insertion nor
deletion is done on a previously inserted/deleted part. This
can be formalised as 8i; j:eiej=ejeiholds.
We show that any editing sequence can be automatically
transformed to a one-pass traversal of graphs. Our algorithm
consists of two steps: We Ô¨Årst map the editing sequence to
composition of a set of graph transformations where each
graph transformation corresponds to an editing operation,
and then try to fuse the composition into a single one-pass
graph traversal in terms of a structural recursion in UnCal .
1) Mapping from Editing Sequence to Composition of
Graph Transformations: First, each editing operation cor-
responds to a simple graph transformation in UnQL+. Let p
denote the path from the root to the node n(i.e., a sequence
of edge labels from the root to the node n) in the graph $db.
Then, the editing operation e($db)for deleting a subgraph
fl: $ggrooted at the node ncan be translated to E($db):
delete p!fl: $ggin$db
and the edition operation e0($db)for inserting a subgraph
Gto the node ntoE0($db):
extend p!$gwith Gin$db:
Now a sequence of editing operations e1; e2; : : : ; e ncor-
responds to the composition of graph transformations of
E1($db); E2($db); : : : ; E n($db), that is,
E1(E2(: : :(En($db))):
2) Fusion of Composition of Graph Transformations:
GRoundTram provides a powerful fusion mechanism thatcan automatically fuse a composition of graph transfor-
mations into one so that unnecessary exchange of graph
structures between the individual graph transformations can
be saved. We could apply this general fusion mechanism,
but we can do better based on the fact that each graph
transformation is independent from each other. Thus we
develop a specialised but more efÔ¨Åcient fusion algorithm.
Our idea is to construct an action tree from the editing
sequence and then map the action tree to a one-pass trans-
formation. For an action tree, leaves are marked with two
action markers D(l)andI(G), denoting respectively the
deletion of a graph pointed by the edge lwhen possible
and the insertion of a graph G. Fig. 12 gives an example
Figure 12. An action tree
action tree, which describes the intention of that composed
transformation: Given a graph, for the node reached by the
path of a:bdo deletion, for the node reached by the path
b:ado deletion, and for the node reached by the path b:cdo
insertion. In fact, an action tree is a tree automaton that can
be mapped to a structural recursion in UnCal that traverses
graphs only once [7].
Let us show that a sequence of editing operations can be
represented by an action tree. First, it is clear that a single
editing operation can be represented by a simple action
tree (which is actually a tree where each node has just a
single child). Now given two action trees t1andt2, we
can combine them to merge (t1; t2), satisfying that (1) any
action in t1ort2appears in merge (t1; t2)and any action in
merge (t1; t2)appears in t1ort2and (2) there is no node that
has two outgoing edges with the same labels. The algorithm
merge (t1; t2)is deÔ¨Åned as follows:
merge ((); t2) = t2
merge (t1;()) = t1
merge (t1[t0
1; t2) = merge (t1;merge (t0
1; t2))
merge (fl:t1g;fl:t0
2g [t2) = fl:merge (t1; t0
2)g [t2
merge (fl:t1g; t2) = fl:t1g [t2
With this merge operation, we can merge all editing opera-
tions into an action tree.
VI. E VALUATION
In order to evaluate the beneÔ¨Åts of the framework, we
assess two research questions. First, does blinkit work
correctly on the examples without human intervention?
Second, given that the illustrative example is constructed,
are there realistic cases in an open-source MDD software
development project where invariant traceability links can be
synchronised using blinkit ? The Ô¨Årst question needs tobe answered Ô¨Årst since only a working blinkit prototype
can bring beneÔ¨Åts to the users. To answer these questions,
we conducted two sets of experiments.
Correctness. In the 1st experiment we create a model
using EMF as illustrated earlier and generate the default Java
source code. There is only 1 class (i.e., Entity) and 1 attribute
(i.e., name) respectively in the EMF meta-model, the code
generated by EMF has 2 classes (i.e., Entity, EntityPackage)
and 1 attribute (i.e., name) annotated by @model . In terms
of the number of @generated attributes, there are respec-
tively 8 classes, 48 attributes and 10 methods generated in
3 packages. Currently, blinkit only supports synchroni-
sation between method bodies, which users are more likely
to change in order to introduce different behaviours.
To evaluate the correctness of blinkit , we manually
modiÔ¨Åed those 9 methods annotated by @generated
into@generated INV . The blinkit tool generated an
‚Äòidentity‚Äô UnQL+ transformation for each invariant traceabil-
ity@generated INV . Then we manually modiÔ¨Åed indi-
vidual @generated INV methods by adding, removing,
and replacing some statements to simulate a possible change
by the user. In parallel, we applied the Rename Class and
the Rename Method refactorings to the 3 elements in the
model that were annotated by the @model markers to see
whether they have an impact on the user-modiÔ¨Åed code.
The simulated changes to the newly generated template
code may conÔ¨Çict with the changes introduced by user,
e.g., by renaming ‚Äúname‚Äù to ‚ÄúiD‚Äù. In those cases the
changes should be merged by blinkit . For correctness,
we checked the merged results manually to see whether
they preserve both changes in the model and in the user
code. When the changes of the @model did not affect the
changes to the @generated INV elements by the user,
all changes introduced by the user were preserved.
Intersection of the changes in @generated NOT ,
@generated and@model .To answer the second ques-
tion, we Ô¨Årst extracted all revisions of Java code from
the CVS repository of the GMF projectyy, which spans
about 6 years period between 2005/08/14 and 2011/08/13.
According to this repository, there have been 28,070 revi-
sions including all the ones before the deleted Ô¨Åles were
placed in the Attic subfolders. In order to understand
how many times the model parts have changed, we rely
on the EMF convention that all modelling elements in
the generated template code have been annotated with the
@model markers. Therefore, we extracted the interface APIs
that were marked by @model using the normalisation and
clone detection technique reported in our earlier work [3].
This way, all meaningful differences for the model can be
found among the 1185 pairs of possible revisions (we only
compare those revisions on the same Ô¨Åles). There are 178
pairs of meaningful changes, ranging from 2005/08/14 till
2011/02/28, and no more changes after that. Fig. 13 shows
yySee http://archive.eclipse.orgthe distribution of the 178 @model changes over this period.
Figure 13. The distribution of @model changes in the CVS repository
indicates that meta-models used in the GMF project is getting stabilised.
Next, we used a different normalisation on the same data-
set, this time Ô¨Åltering only those methods that have been
annotated by @generated NOT markers amongst 1,314
Java classes. For these Java methods, we moved their im-
plementation in the body into the <!-begin-user-doc>
... <!--end-user-doc> pairs in the Javadoc com-
ments, and changed their annotations into @generated
such that the code generator will overwrite the user code
with the template code, while the user modiÔ¨Åcations are
still available in the comment. Finally, we compared the
differences between the template and user codes, in order
to see whether the changed @model elements appear in
these method bodies. If they do, then we have conÔ¨Årmed
that the bidirectional transformation could be useful in
practice because the user code was indeed different from
the template code, and those differences would interact with
the modiÔ¨Åcation of the model in the immediate revisions
following the timestamps.
Throughout the data-set, we found that 15,223 revisions
amongst the total of 28,070 revisions (i.e., 54%) will be
inÔ¨Çuenced by the changes of the @model elements. There
are 146,415 modiÔ¨Åed model elements referenced by the
@generated NOT methods in the revisions. Therefore,
on average 146;415=15;223 = 9 :61modiÔ¨Åed modelling
elements are referenced by the @generated NOT method
bodies in every Java revision Ô¨Åle.
We list threats to validity and some limitations below:
Construct validity: Instead of synchronising for the
whole classes or packages, we focus on synchronising
changes to the method bodies. The reason for this choice
is practical as most of the time users would customise the
behaviour of the default class, rather than rewriting them
completely. A modiÔ¨Åcation to method bodies is also often
required because the template code would otherwise raise
UnsupportedOperationException .
External validity: blinkit is built on existing open-
source MDD toolsets EMF,EMFtext ,JaMoPP and a
transformation system TXL. It also integrates two research
prototypes GRoundTram [5] and mct [3] which are freely
available to download. The subject case study is also an
open-source one whose CVS repository is publicly available.Internal validity: Although studying committed changes
on models in the GMF repository may be conservative, it
is the only available source that we can rely on. It can be
argued that the editing changes outside the repository present
more synchronisation opportunities, however we have to
estimate the beneÔ¨Åts of our solution conservatively without
empirically monitoring developers over their shoulders.
VII. R ELATED WORK
We compare blinkit to the work in traceability, co-
evolution, and bidirectional transformations.
Precise traceability. Automated software document-code
traceability recovery has been studied by researchers
from many angles since requirements traceability was
proposed [2]: The review of the best practises in this
Ô¨Åeld [13] suggests that automated techniques such as vector
spaces [14], [15], LSI [16] are useful when part of the data-
set relies on ambiguous documentation such as requirements,
manuals and bug reports. It is expensive to obtain expert
judgements for large applications [17] and to obtain high-
quality inputs [18]. Incremental techniques have been pro-
posed to analyse evolving traceability links [16] for better
efÔ¨Åciency, however, precision cannot be greatly improved.
Auxiliary information from programs such as call-graphs or
traces [18] or XML-based (xlinkit) rules [19] could help
improve the precision to some extent, but it is still largely ex-
pensive to gain better results through feedback [20]. On the
other hand, the abstraction gap between models and code is
much narrower that that between requirements document and
code, thus precise tracing has been considered through main-
taining semi-automated refactorings [21]. However, such
refactorings are also expensive to construct, thus affordable
only for medium-sized security software applications. Here
we address the problem for general software projects that
scales while MDD has been applied.
Invariant traceability for model/code co-evolution.
When projects evolve, MDD methods face additional chal-
lenges: not only do artifacts such as models or code change
over time, their changes also need to be propagated in
order to maintain consistency even when artifacts are at
different levels of abstraction. Co-evolution needs to be
studied between models and code, between behavioural
and structural models, or even between code and program-
ming languages [22]. ModiÔ¨Åcations to a model must be
reÔ¨Çected on the corresponding code in order to keep the
model and the code synchronised . Code generators exist
to automatically generate code from UML models [23]‚Äì
[25]. In practice, however, code is often updated manually
after it has been generated, and it is therefore necessary
to reÔ¨Çect those changes back to the corresponding model.
Round-trip engineering (RTE) is one-way to synchronise
UML diagrams and code [26]. However, combining code
generation and reverse engineering approaches is still not
sufÔ¨Åcient: Changing independently, models and code needto be merged Ô¨Årst; Secondly, since models are generally
at a higher level of abstraction than code, not all changes
made to the code can be reÔ¨Çected back to models. Giese and
Wagner [27] use triple graph grammars for RTE, but their
approach is limited to elements that have a correspondence
in the model. Other approaches, like Van Paesschen et al.‚Äôs
[28], assume that both artifacts can be represented in a
common representation. Fujaba [29] is yet another RTE
approach that can generate Java code from UML class
diagrams, and regenerated class diagrams from modiÔ¨Åed
Java code, as long as developers follow Fujaba‚Äôs naming
conventions and implementation concepts. State-of-the-art
RTE tools such as EMF/GMF make use of annotations to
separate the portions of generated and user modiÔ¨Åed code,
yet it is largely manual to maintain the correspondence of
@generated NOT elements. The co-evolution of GMF
project has been studied [30] for synchronising the EMF
meta-models (model $model) used by the project. Although
we also use the same case study to evaluate the beneÔ¨Åts, our
focus is on automating the code $code synchronisations.
Bidirectional transformation [31], [32] has been re-
cently widely studied by researchers from different com-
munities of programming language, software engineering,
and database. It has many potential applications in software
development, including model synchronisation [4], [33],
round-trip engineering [34], software evolution [35], and
multiple-view software development [36]. Our work shows
that we can move from ‚Äúpotential‚Äù to ‚Äúpractical‚Äù; we achieve
scalability by proposing a two-layer bidirectional transfor-
mation framework, hiding difÔ¨Åculties in writing bidirectional
transformation by automatic deriving it from a sequence of
editing operations, and widening its application scope by
treating general graphs.
VIII. C ONCLUSIONS AND FUTURE WORK
In this paper, we presented a model-driven development
(MDD) method, supported by the blinkit prototype, to
maintain the invariant traceability between model and code
through bidirectional transformations. Using this method, if
code is annotated by @generated INV , a bidirectional
transformation will be generated to correctly propagate
changes in both directions. We tested our framework by
the example shown in Section III and observed empirically
how often blinkit can be used to maintain the invariant
traceability based on the data-set in the CVS repository of
GMF, a widely-used MDD project. It is also observed that
applying the method earlier delivers more beneÔ¨Åts since its
meta-models change more frequently. In this case study, we
also found that more changes were derived from the evolving
model than from the evolving template.
Current work considers a basic form of invariant trace-
ability where all meaningful changes are synchronised, re-
gardless of whether they were derived from the template
or from the model. Our future work will extend the syntaxand semantics of @generated INV to differentiate model
changes from template changes.
Acknowledgement. The work is supported in part by EU Se-
cureChange (www.securechange.eu), Microsoft SEIF (computing-
research.open.ac.uk/seif), and NII BiG (www.biglab.org) projects.
REFERENCES
[1] L. Angyal, L. Lengyel, and H. Charaf, ‚ÄúA Synchronizing
Technique for Syntactic Model-Code Round-Trip Engineer-
ing,‚Äù in ECBS ‚Äô08 , 2008. pp. 463‚Äì472.
[2] O. C. Z. Gotel and A. C. W. Finkelstein, ‚ÄúAn analysis of
the requirements traceability problem,‚Äù in RE‚Äô94 , 1994, pp.
94‚Äì101.
[3] Y . Yu, T. T. Tun, and B. Nuseibeh, ‚ÄúSpecifying and detecting
meaningful changes in programs,‚Äù in ASE‚Äô11 , 2011, pp. 273-
282.
[4] Y . Xiong, D. Liu, Z. Hu, H. Zhao, M. Takeichi, and H. Mei,
‚ÄúTowards automatic model synchronization from model trans-
formations,‚Äù in ASE‚Äô07 , 2007, pp. 164‚Äì173.
[5] S. Hidaka, Z. Hu, K. Inaba, H. Kato, and K. Nakano,
‚ÄúGRoundTram: An integrated framework for developing well-
behaved bidirectional model transformations‚Äù in ASE‚Äô11 ,
2011, pp. 480-483.
[6] S. Hidaka, Z. Hu, H. Kato, and K. Nakano, ‚ÄúTowards a
compositional approach to model transformation for software
development,‚Äù in SAC ‚Äô09 , 2009, pp. 468‚Äì475.
[7] P. Buneman, M. F. Fernandez, and D. Suciu, ‚ÄúUnQL: a
query language and algebra for semistructured data based on
structural recursion,‚Äù VLDB Journal: Very Large Data Bases ,
vol. 9, no. 1, pp. 76‚Äì110, 2000.
[8] S. Hidaka, Z. Hu, K. Inaba, H. Kato, K. Matsuda, and
K. Nakano, ‚ÄúBidirectionalizing graph transformations,‚Äù in
ICFP‚Äô10 , 2010, pp. 205‚Äì216.
[9] J. Ellson, E. R. Gansner, E. KoutsoÔ¨Åos, S. C. North, and
G. Woodhull, ‚ÄúGraphviz and dynagraph - static and dynamic
graph drawing tools,‚Äù in Graph Drawing Software . Springer-
Verlag, 2003, pp. 127‚Äì148.
[10] P. Buneman, M. Fernandez, and D. Suciu, ‚ÄúUnQL: a query
language and algebra for semistructured data based on struc-
tural recursion,‚Äù The VLDB Journal , vol. 9, no. 1, pp. 76‚Äì110,
2000.
[11] Y . Yu, Y . Lin, Z. Hu, S. Hidaka, H. Kato, and L. Mon-
trieux, ‚Äúblinkit: Maintaining invariant traceability through
bidirectional transformations ‚Äì a technical report,‚Äù The Open
University, Tech. Rep. TR2011/09, September 2011.
[12] W. Yang, ‚ÄúIdentifying syntactic differences between two
programs,‚Äù in Software - Practice and Experience , vol. 21,
1991, pp. 739‚Äì755.
[13] J. Cleland-Huang, B. Berenbach, S. Clark, R. Settimi, and
E. Romanova, ‚ÄúBest practices for automated traceability,‚Äù
IEEE Computer , vol. 40, no. 6, pp. 27‚Äì35, 2007.
[14] J. H. Hayes, A. Dekhtyar, and S. K. Sundaram, ‚ÄúAdvancing
candidate link generation for requirements tracing: The study
of methods,‚Äù IEEE Trans. Software Eng. , vol. 32, no. 1, pp.
4‚Äì19, 2006.
[15] G. Antoniol, G. Canfora, G. Casazza, A. D. Lucia, and
E. Merlo, ‚ÄúRecovering traceability links between code and
documentation,‚Äù IEEE Trans. Software Eng. , vol. 28, no. 10,
pp. 970‚Äì983, 2002.
[16] H. Jiang, T. N. Nguyen, I.-X. Chen, H. Jaygarl, and C. K.
Chang, ‚ÄúIncremental latent semantic indexing for automatic
traceability link evolution management,‚Äù in ASE‚Äô08 , 2008, pp.
59‚Äì68.[17] G. Antoniol, J. H. Hayes, Y .-G. Gu ¬¥eh¬¥eneuc, and M. D. Penta,
‚ÄúReuse or rewrite: Combining textual, static, and dynamic
analyses to assess the cost of keeping a system up-to-date,‚Äù
inICSM‚Äô08 , 2008, pp. 147‚Äì156.
[18] A. Egyed and P. Gr ¬®unbacher, ‚ÄúSupporting software under-
standing with automated requirements traceability,‚Äù Inter-
national Journal of Software Engineering and Knowledge
Engineering , vol. 15, no. 5, pp. 783‚Äì810, 2005.
[19] C. Nentwich, L. Capra, W. Emmerich, and A. Finkelstein,
‚Äúxlinkit: a consistency checking and smart link generation
service,‚Äù ACM Trans. Internet Techn. , vol. 2, no. 2, pp. 151‚Äì
185, 2002.
[20] A. D. Lucia, F. Fasano, R. Oliveto, and G. Tortora, ‚ÄúRecover-
ing traceability links in software artifact management systems
using information retrieval methods,‚Äù ACM Trans. Softw. Eng.
Methodol. , vol. 16, no. 4, 2007.
[21] Y . Yu, J. J ¬®urjens, and J. Mylopoulos, ‚ÄúTraceability for the
maintenance of secure software,‚Äù in ICSM‚Äô08 , 2008, pp. 297‚Äì
306.
[22] T. Mens, M. Wermelinger, S. Ducasse, S. Demeyer,
R. Hirschfeld, and M. Jazayeri, ‚ÄúChallenges in software
evolution,‚Äù in IWPSE ‚Äô05 , 2005, pp. 13‚Äì22.
[23] A. Rountev, O. V olgin, and M. Reddoch, ‚ÄúStatic control-Ô¨Çow
analysis for reverse engineering of uml sequence diagrams,‚Äù
inPASTE ‚Äô05 , 2005, pp. 96‚Äì102.
[24] M. Keschenau, ‚ÄúReverse engineering of UML speciÔ¨Åcations
from Java programs,‚Äù in OOPSLA‚Äô04 , 2004, pp. 326‚Äì327.
[25] Y .-G. Gu ¬¥eh¬¥eneuc, ‚ÄúA reverse engineering tool for precise
class diagrams,‚Äù in CASCON ‚Äô04 , 2004, pp. 28‚Äì41.
[26] T. Hettel, M. Lawley, and K. Raymond, ‚ÄúModel synchro-
nisation: DeÔ¨Ånitions for round-trip engineering,‚Äù in Theory
and Practice of Model Transformations , ser. Lecture Notes
in Computer Science. 2008, vol. 5063, pp. 31‚Äì45.
[27] H. Giese and R. Wagner, ‚ÄúIncremental model synchronization
with triple graph grammars,‚Äù in Model Driven Engineering
Languages and Systems , ser. Lecture Notes in Computer
Science. 2006, vol. 4199, pp. 543‚Äì557.
[28] E. Van Paesschen, W. De Meuter, and M. D‚ÄôHondt, ‚ÄúSelf-
Sync: A dynamic round-trip engineering environment,‚Äù in
Model Driven Engineering Languages and Systems , ser. Lec-
ture Notes in Computer Science. 2005, vol. 3713, pp. 633‚Äì
647.
[29] T. Klein, U. A. Nickel, J. Niere, and A. Z ¬®undorf, ‚ÄúFrom UML
to Java and back again,‚Äù University of Paderborn, Tech. Rep.,
1999.
[30] D. D. Ruscio, R. L ¬®ammel, and A. Pierantonio, ‚ÄúAutomated
co-evolution of GMF editor models,‚Äù in SLE, ser. Lecture
Notes in Computer Science, vol. 6563, 2010, pp. 143‚Äì162.
[31] K. Czarnecki, J. N. Foster, Z. Hu, R. L ¬®ammel, A. Sch ¬®urr,
and J. F. Terwilliger, ‚ÄúBidirectional transformations: A cross-
discipline perspective,‚Äù in ICMT‚Äô09 , 2009, pp. 260‚Äì283.
[32] Z. Hu, A. Sch ¬®urr, P. Stevens, and J. F. Terwilliger, ‚ÄúDagstuhl
seminar on bidirectional transformations (BX),‚Äù SIGMOD
Record , vol. 40, no. 1, pp. 35‚Äì39, 2011.
[33] M. Antkiewicz and K. Czarnecki, ‚ÄúDesign space of hetero-
geneous synchronization,‚Äù in GTTSE ‚Äô07 , 2007, pp. 3-46.
[34] Michal Antkiewicz and Krzysztof Czarnecki, ‚ÄúFramework-
speciÔ¨Åc modeling languages with round-trip engineering,‚Äù in
MoDELS‚Äô06 , 2006, pp. 692‚Äì706.
[35] R. L ¬®ammel, ‚ÄúCoupled Software Transformations (Extended
Abstract),‚Äù in IWSET‚Äô04 , 2004, pp. 31-35.
[36] M. Garcia, ‚ÄúBidirectional synchronization of multiple views
of software models,‚Äù in DSML‚Äô08 , vol. 324, 2008, pp. 7‚Äì19.