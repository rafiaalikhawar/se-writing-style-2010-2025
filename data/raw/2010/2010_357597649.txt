Improved Multithreaded UnitTesting
Vilas Jagannath ,Milos Gligoric ,Dongyun Jin ,
Qingzhou Luo ,Grigore Ro¸ su ,Darko Marinov
Department of Computer Science, UniversityofIllinois atU rbana-Champaign
Urbana, IL61801, USA
{vbangal2, gliga, djin3, qluo2, grosu, marinov}@illinois .edu
ABSTRACT
Multithreaded code is notoriously hard to develop and test.
A multithreaded test exercises the code under test with two
or more threads. Each test execution follows some sched-
ule/interleaving of the multiple threads, and diﬀerent sch ed-
ules can give diﬀerent results. Developers often want to en-
force a particular schedule for test execution, and to do so,
they use time delays ( Thread.sleep in Java). Unfortunately,
this approach can produce false positives or negatives, and
can result in unnecessarily long testing time.
This paper presents IMUnit, a novel approach to speci-
fying and executing schedules for multithreaded tests. We
introduce anewlanguage thatallows explicit speciﬁcation of
schedules as orderings on events encountered during test ex-
ecution. We present a tool that automatically instruments
the code to control test execution to follow the speciﬁed
schedule, and a tool that helps developers migrate their
legacy, sleep-based tests into event-based tests in IMUnit .
The migration tool uses novel techniques for inferring even ts
and schedules from the executions of sleep-based tests. We
describe our experience in migrating over 200 tests. The
inference techniques have high precision and recall of over
75%, and IMUnit reduces testing time compared to sleep-
based tests on average 3.39x.
Categories andSubject Descriptors
D.2.5 [Software Engineering ]: Testing and Debugging
General Terms
Veriﬁcation, Reliability
Keywords
IMUnit, Unit Testing, Multithreaded Code
1. INTRODUCTION
Multicore processors are here to stay. To extract greater
performance from multicore processors, developers need to
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and thefull citation on the ﬁrstpage. Tocop y otherwise, to
republish, topostonserversortoredistribute tolists,re quires priorspeciﬁc
permission and/or afee.
ESEC/FSE'11, September 5–9, 2011, Szeged, Hungary.
Copyright 2011 ACM 978-1-4503-0443-6/11/09 ...$10.00.write parallel code. The predominant paradigm for paral-
lel code is that of shared memory where multiple threads of
control communicate by readingand writing shared dataob-
jects. Shared-memory multithreaded code is often aﬄicted
by concurrency bugs, which are hard to detect because mul-
tithreadedcode can demonstrate diﬀerentbehavior based on
the scheduling of threads, and the bugs may only be trig-
gered by a small speciﬁc set of schedules.
To validate their multithreaded code, developers write
multithreaded unit tests. A multithreaded test creates and
executes two or more threads (and/or invokes code under
test that itself creates and executes two or more threads).
Each test execution follows some schedule/interleaving of
the multiple threads, and diﬀerent schedules can give diﬀer -
ent results. Developers often want to enforce a particular
schedule for a test. For example, consider two threads, one
executing a method mand the other executing a method
m′. Developers may want to ensure in one test that mﬁn-
ishes before m′starts and in another test that m′ﬁnishes
beforemstarts (and in more tests that mandm′inter-
leave in certain ways). Without controlling the schedule, i t
is impossible to write precise assertions about the executi on
because the results can diﬀer in the two scenarios, and it is
impossible to guarantee which scenarios were covered durin g
testing, even if multiple runs are performed.
To control the schedule of multithreaded tests, develop-
ers mostly use a combination of timed delays in the vari-
ous test threads. In Java, the delay is performed with the
Thread.sleep method, so we call this approach sleep-based .
A sleep pauses a thread while other threads continue exe-
cution. Using a combination of sleeps, developers attempt
to enforce the desired schedule during the execution of a
multithreaded test, and then assert the intended result for
the desired schedule. A sleep-based test can fail when an
undesired schedule gets executed even if the code under test
has no bug (false positive). Dually, a sleep-based test can
pass when an unintended schedule gets executed even if the
code undertest has abug(false negative). Indeed, sleeps ar e
an unreliable and ineﬃcient mechanism for enforcing sched-
ules. To use sleeps, one has to estimate the real-time du-
ration for which to delay a thread while the other threads
perform their work. This is usually estimated by trial and
error, starting from a small duration and increasing it un-
til the test passes consistently on the developer’s machine .
The estimated duration depends on the execution environ-
ment (hardware/software conﬁguration and the load on the
machine). Therefore, when the same test is executed in a
diﬀerent environment, the intended schedule may not be en-FSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 2011forced, leading to false positives/negatives. Moreover, s leep
can be very inaccurate even on a single machine [ 20]. In an
attempt to mitigate the unreliability of sleep, developers of-
ten end up over-estimating the duration, which in turn leads
to slow running multithreaded tests.
Researchers have previously noted the numerous prob-
lems with using sleeps to specify schedules in multithreade d
tests and have developed frameworks such as ConAn [ 22,
23], ConcJUnit[ 27], MultithreadedTC[ 26], andThreadCon-
trol [13] to tackle some problems in specifying and enforc-
ing schedules in multithreaded unit tests. However, despit e
these frameworks, multithreaded unit testing still has man y
issues that could be categorized as follows:
Readability: Most current frameworks force developers
to reason about the execution of threads relative to a global
clock. This is unintuitive since developers usually reason
about the execution of their multithreaded code in terms
of event relationships (such as mﬁnishing before m′starts).
Some frameworks requireusers towrite schedules inexterna l
scripts, which makes it even more diﬃcult to reason about
schedules. In other frameworks the schedule is implicit, as a
part of the unit test code, and hence it is diﬃcult to focus on
the schedule and reason about it separately at a higher level .
Modularity: In some current frameworks, the intended
schedule is intermixed with the test code and eﬀectively
hard-coded into a multithreaded unit test. This makes it
diﬃcult to specify multiple schedules for a particular unit
test and/or to reuse test code among diﬀerent tests.
Reliability: Some current frameworks, as well as the
legacy sleep-based tests, rely on real time. As explained,
this makes them very fragile, leading to false positives/ne g-
atives and/or slow testing time.
Migration Costs: Most currentframeworks are verydif-
ferent from the traditional sleep-based tests. This makes i t
costly to migrate the existing sleep-based tests.
We present a new framework, called IMUnit(pronounced
“immunity” ), which aims to address these issues with mul-
tithreaded unit testing. Speciﬁcally, we make the followin g
contributions:
Schedule Language: IMUnit introduces a novel lan-
guage that enables natural and explicit speciﬁcation of sch -
edules for multithreaded unit tests. Semantically, the bas ic
entity in an IMUnit schedule is an eventthat an execution
can produce at various points (e.g., a thread starting/ﬁnis h-
ing the execution of a method, or a thread getting blocked).
Wecall theIMUnitapproach event-based . AnIMUnitsched-
ule itself is a (monitorable) property [ 10,24] on the sequence
of events. More precisely, each schedule is expressed as a
set of desirable event orderings , where each event ordering
speciﬁes the order between a pair of events (note that an
IMUnit schedule need not specify a total order between all
events but only the necessary partial order).
While the ideas of IMUnit can be embodied in any lan-
guage, we have developed an implementation for Java. Syn-
tactically, the IMUnit constructs are represented using Ja va
annotations. A developer can use @Eventand@Schedule an-
notations to describe the events and intended schedules, re -
spectively, for a multithreaded unit test.
Automated Migration: We have developed two infer-
ence techniques and a tool to ease migration of legacy, sleep -
based tests to IMUnit, event-based tests. Our inference
techniques can automatically infer likely relevant events and
schedules from the execution traces of existing sleep-base dtests. We implemented our migration tool as an Eclipse
plugin which uses the results of inference to automatically
refactor a given multithreaded test into an IMUnit test.
Execution and Checking: We have implemented a tool
for execution of IMUnit multithreaded unit tests. The tool
can work in two modes. In the active mode, it controls the
thread scheduler to enforce a given IMUnit schedule dur-
ing test execution. In the passive mode, it checks whether
an arbitrary test execution, controlled by the regular JVM
thread scheduler, follows a given IMUnit schedule. To en-
force/check the schedules, our tool uses the JavaMOP mon-
itoring framework [ 10,24]. We also include a new runner for
the standard JUnit testing framework to enable execution
of IMUnit tests with our enforcement/checking tool.
Evaluation: ToguideandreﬁneourdesignoftheIMUnit
language, we have been inspecting over 200 sleep-based test s
from several open-source projects. We manually translated
198 of those tests into IMUnit, adding events and sched-
ules, and removing sleeps. As a result, the current version
of IMUnit is highly expressive, and we were able to remove
all sleeps from all but 4 tests.
We evaluated our inference techniques by automatically
inferring events/schedulesfor theoriginal tests that we m an-
ually translated (the subprojects on manual translation an d
automatic inference were performed by diﬀerent authors to
reduce the direct bias of manual translation on automatic
inference). Computing the precision and recall of the auto-
matically inferred events/schedules with respect to the ma n-
ually translated events/schedules, we ﬁnd our techniques t o
be highly eﬀective, with over 75% precision and recall.
We also compared the execution time of the original tests
and our translated tests. Because the main goal of IMUnit
is to make tests more readable, modular, and reliable, we
did not expect IMUnit to run faster. However, IMUnit did
reduce the testing time, on average 3.39x, compared to the
sleep-based tests, with the sleep duration that the origina l
tests had in the code. As mentioned earlier, these duration
values are often over-estimated, especially in older tests that
were written for slower machines. In summary, IMUnit not
only makes multithreaded unit tests more readable, modu-
lar, and reliable than the traditional sleep-based approac h,
but IMUnit can also make test execution faster.
This paper makes progress on our vision for improving
multithreaded unit testing; our position paper [ 15] proposed
the idea of event-based speciﬁcation of schedules, but the
IMUnit language and algorithms/tools for inference and ex-
ecution are completely new.
2. EXAMPLE
We now illustrate IMUnit with the help of an example
multithreaded unit test for the ArrayBlockingQueue class i n
java.util.concurrent (JSR-166) [ 17]. ArrayBlockingQueue
is an array-backed implementation of a bounded blocking
queue. One operation provided by ArrayBlockingQueue is
add, which performs a non-blocking insertion of the given el-
ement at the tail of the queue. If addis performed on a full
queue, it throws an exception. Another operation provided
by ArrayBlockingQueue is take, which removes and returns
the object at the head of the queue. If takeis performed on
an empty queue, it blocks until an element is inserted into
the queue. These operations could have bugs that get trig-
gered when the addandtakeoperations execute on diﬀerent
threads. Consider testing some scenarios for these opera-FSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 20111@Test
2public void testTakeWithAdd() {
3ArrayBlockingQueue <Integer>q;
4q =newArrayBlockingQueue <Integer>(1);
5newThread(
6newCheckedRunnable() {
7 public void realRun() {
8 q.add(1);
9 Thread.sleep(100);
10 q.add(2);
11 }
12}, ”addThread”).start();
13Thread.sleep(50);
14Integer taken = q.take();
15assertTrue(taken == 1 && q.isEmpty());
16taken = q.take();
17assertTrue(taken == 2 && q.isEmpty());
18addThread.join();
19}
(a) JUnit1public class TestTakeWithAdd
2extends MultithreadedTest {
3ArrayBlockingQueue <Integer>q;
4@Override
5public void initialize() {
6q =newArrayBlockingQueue <Integer>(1);
7}
8public void addThread() {
9q.add(1);
10waitForTick (2);
11q.add(2);
12}
13public void takeThread() {
14waitForTick (1);
15Integer taken = q.take();
16assertTrue(taken == 1 && q.isEmpty());
17taken = q.take();
18assertTick (2);
19assertTrue(taken == 2 && q.isEmpty());
20}
21}
(b) MultithreadedTC1@Test
2@Schedule (”ﬁnishedAdd1 ->startingTake1,
3 [startingTake2] ->startingAdd2”)
4public void testTakeWithAdd() {
5ArrayBlockingQueue <Integer>q;
6q =newArrayBlockingQueue <Integer>(1);
7newThread(
8newCheckedRunnable() {
9 public void realRun() {
10 q.add(1);
11 @Event(”ﬁnishedAdd1”)
12 @Event(”startingAdd2”)
13 q.add(2);
14 }
15}, ”addThread”).start();
16@Event(”startingTake1”)
17Integer taken = q.take();
18assertTrue(taken == 1 && q.isEmpty());
19@Event(”startingTake2”)
20taken = q.take();
21assertTrue(taken == 2 && q.isEmpty());
22addThread.join();
23}
(c) IMUnit
Figure 1: Example multithreaded unit test for ArrayBlockin gQueue
tions (in fact, the JSR-166 TCK provides over 100 tests for
various scenarios for similar classes).
Figure1shows amultithreadedunittest thatArrayBlock-
ingQueueexercises addandtakein twoscenarios. Inparticu-
lar, Figure 1(a)shows thetestwritten as aregular JUnittest
method, with sleeps used to specify the required schedule.
We invite the reader to consider what scenarios are speciﬁed
with that test (without looking at the other ﬁgures). It is
likely to be diﬃcult to understand which schedule is being
exercised by reading the code of this unit test. While the
sleeps provide hints as towhich thread is waiting for anothe r
thread to perform operations, it is unclear which operation s
are intended to be performed by the other thread before the
sleep ﬁnishes.
The test actually checks that takeperforms correctly both
with andwithout blocking, whenusedwith addfrom another
thread. To check both scenarios, the test exercises a sched-
ule where the ﬁrst addﬁnishes before the ﬁrst takestarts,
and the second takeblocks before the second addstarts.
Line13shows the ﬁrst sleep that is intended to pause the
mainthread1while the addThread ﬁnishes the ﬁrst add. Line9
shows the second sleep which is intended to pause the add-
Threadwhile the mainthread ﬁnishes the ﬁrst takeand then
proceeds to block while performing the second take. If the
speciﬁed schedule is notenforced duringthe execution, the re
may be a false positive/negative. For example, if both add
operations execute before a takeis performed, the test will
throw an exception and fail even if the code has no bug, and
if bothtakeoperations ﬁnish without blocking, the test will
not fail, even if the blocking takecode had a bug.
Figure1(b)shows the same test written using Multithre-
adedTC [ 26]. Note that it departs greatly from traditional
JUnit where each test is a method. In MultithreadedTC,
each test has to be written as a class, and each method in
the test class contains the code executed by a thread in the
1JVM names the thread that starts the execution mainby
default, although the name can be changed later.test. The intended schedule is speciﬁed with respect to a
global, logical clock. Since this clock measures time in ticks,
we call the approach tick-based. When a thread executes a
waitForTick , it is blocked until the global clock reaches the
requiredtick. Theclockadvancesimplicitlywhenall threa ds
are blocked (and at least one thread is blocked in a wait-
ForTick). While a MultithreadedTC test does not rely on
real time, and is thus more reliable than a sleep-based test,
the intended schedule is still not immediately clear upon
reading the test code. It is especially not clear when wait-
ForTickoperations are blocked/unblocked, because ticks are
advanced implicitly when all the threads are blocked.
Figure1(c)shows the same test written using IMUnit.
The interestingevents encountered duringtest execution a re
marked with @Eventannotations2, and the intended sched-
ule is speciﬁed with a @Schedule annotation that contains a
comma-separated set of orderings among events. An order-
ing is speciﬁed using the operator ->, where the left event is
intended to execute before the right event. An event speci-
ﬁed within square brackets denotes that the thread execut-
ingthateventis intendedtoblock after that event. Itshoul d
be clear from reading the schedule that the addThread should
ﬁnishthe ﬁrst addbefore the mainthread starts the ﬁrst take,
and that the mainthread should block while performing the
secondtakebefore the addThread starts the second add.
We now revisit, in the context of this example, the issues
with multithreaded tests listed in the introduction. In ter ms
ofreadability , we believe that making the schedules explicit,
as in IMUnit, allows easier understanding and maintenance
of schedules and code for both testing and debugging. In
terms of modularity , IMUnit allows extracting the addThread
as a helper thread (with its events) that can be reused in
2Note that @Eventannotations appear on statements. The
currentversionofJava(ver. 6)doesnotsupportannotation s
on statements, but the upcoming version of Java (ver. 7)
will add such support. For now, @Eventannotations can
be written as comments, e.g., /* @Event("finishedAdd1") */ ,
which IMUnit translates into code for test execution.FSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 2011<Schedule >::={<Ordering >[” ,”]}<Ordering >
<Ordering >::=<Condition >”->”<Basic Event >
<Condition >::=<Basic Event >|<Block Event >
|<Condition >”| |”<Condition >
|<Condition >”&&”<Condition >
|”(”<Condition >”)”
<Basic Event >::=<Event Name >[”@”<Thread Name >]
|”start ” ”@” <Thread Name >
|”end” ”@” <Thread Name >
<Block Event >::= ”[” <Basic Event >”]”
<Event Name >::={<Id>”.”}<Id>
<Thread Name >::=<Id>
Figure 2: Syntax of the IMUnit schedule language
other tests (in fact, many tests in the JSR-166 TCK [ 17] use
such helper threads). In contrast, reusing thread methods
from the MultithreadedTC test class is more involved, re-
quiringsubclassing, parametrizingtickvalues, andprovi ding
appropriate parameter values. Also, IMUnit allows specify -
ing multiple schedules for the same test code (Section 4.3).
In terms of reliability , IMUnit does not rely on real time and
hencehasnofalse positives/negativesduetounintendedsc h-
edules. In terms of migration costs , IMUnit tests resemble
legacy JUnit tests more than MultithreadedTC tests. This
similarity eases the transition of legacy tests into IMUnit :
in brief, add @Eventannotations, add @Schedule annotation,
and remove sleepcalls. Section 4presents our techniques
and tool that automate this transition.
3. SCHEDULE LANGUAGE
We nowdescribe the syntaxandsemantics ofthe language
used in IMUnit’s schedules.
3.1 Concrete Syntax
Figure2shows the concrete syntax of the implemented
IMUnit schedulelanguage. An IMUnitschedule is a comma-
separated set of orderings . Each ordering deﬁnes a condi-
tion that must hold before a basic event can take place. A
basic event is an event name possibly tagged with its is-
suing thread name when that is not understood from the
context. An event name is any identiﬁer, possibly preﬁxed
with a qualiﬁed class name. There are two implicit event
names for each thread, startandend, indicating when the
thread starts and terminates. Any other event must be ex-
plicitly introduced by the user with the @Eventannotation
(see Figure 1(c)). Acondition is a conjunctive/disjunctive
combination of basic and block events, where block events
are written as basic events in square brackets. A block event
[e′]in the condition cof an ordering c→estates that e′
must precede eand, additionally, the thread of e′is blocked
whenetakes place.
3.2 Schedule Logic
It is more convenient to deﬁne a richer logic than what
is currently supported by our IMUnit implementation; the
additional features are natural and thus may also be imple-
mented in the future. The semantics of our logic is given in
Section3.3; here is its syntax:
a∶∶=start/divides.alt0end/divides.alt0block/divides.alt0unblock/divides.alt0event names
t∶∶=thread names
e∶∶=a@t
ϕ∶∶=[t] /divides.alt0ϕ→ϕ/divides.alt0usual propositional connectivesThe intuition for [t]is“threadtis blocked”and for ϕ→ψ“if
ψheld in the past, then ϕmust have held at some moment
beforeψ”. We call these two temporal operators the block
and theordering operators, respectively. For uniformity, all
events are tagged with their thread. There are four im-
plicit events: start@tandend@twere discussed above, and
block@tandunblock@tcorrespond to when tgets blocked
and unblocked3.
For example, the following formula in our logic
(a1@t1∧([t2]∨(¬(start(t2)→a1@t1))))→a2@t2
∧(a2@t2∧([t1]∨(end(t1)→a2@t2)))→a2@t2
says that if event a2is generated by thread t2then: (1)
eventa1must have been generated before that and, when a1
was generated, t2was either blocked or not started yet; and
(2) whena2is generated by t2,t1is either blocked or termi-
nated. As explainedshortly, everyeventexcept for blockand
unblockis restricted to appear at most once in any execution
trace. Above we assumed that a1,a2∉{block,unblock}.
Before we present the precise semantics, we explain how
our current IMUnit language shown in Figure 2(whose de-
sign was driven exclusively by practical needs) is a smaller
fragment of the richer logic. An IMUnit schedule is a con-
junction (we use comma instead of ∧) of orderings, and
schedules cannot be nested. Since generating blockandun-
blockevents is expensive, IMUnit currently disallows their
explicit use in schedules. Moreover, to reduce their implic it
use to a fast check of whether a thread is blocked or not,
IMUnit also disallows the explicit use of [t]formulas. In-
stead, it allows block events of the form[a@t](note the
square brackets) in conditions. Since negations are not al-
lowed in IMUnit, and since we canshow (after we discuss the
semantics) that(ϕ1∨ϕ2)→ψequals(ϕ1→ψ)∨(ϕ2→ψ),
we can reduce any IMUnit schedule to a Boolean combina-
tion of orderings ϕ→e, whereϕis a conjunction of ba-
sic events or block events. All that is left to show is how
block events are desugared. Consider an IMUnit schedule
(ϕ∧[a1@t1])→a2@t2, saying that a1@t1andϕmust pre-
cedea2@t2andt1is blocked when a2@t2occurs. This can
be expressed as((ϕ∧a1@t1)→a2@t2)∧((a2@t2∧[t1])→
a2@t2), relying on a2@t2happening at most once.
3.3 Semantics
Our schedule logic is a carefully chosen fragment of past-
time linear temporal logic (PTLTL) over special well-formed
multithreaded system execution traces.
Program executions are abstracted as ﬁnite traces of eve-
ntsτ=e1e2...en. Unlike in conventional LTL, our traces
are ﬁnite because unit tests always terminate. Traces must
satisfy the obvious condition that events corresponding to
threadtcan only appear while the thread is alive, that is,
between start@tandend@t. Using PTLTL, this require-
ment states that for any trace τand any event a@twith
a∉{start,end}, the following holds:
τ⊧¬⟐(a@t∧(⟐end@t∨¬⟐start@t))
where⟐stands for “eventually in the past”. Moreover, ex-
cept forblock@tandunblock@tevents, we assume that each
3It is expensiveto explicitly generate block/unblockevents in
Java precisely when they occur, because it requires polling
the status of each thread; our currently implemented frag-
ment only needs, through its restricted syntax, to check if a
given thread is currently blocked or not, which is fast.FSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 2011event appears at most once in a trace. With PTLTL, this
says that the following must hold ( /varodotis“previously”):
τ⊧¬⟐(a@t∧/varodot⟐a@t)
for any trace τand anya@twitha∉{block,unblock}.
The semantics of our logic is deﬁned as follows:
e1e2...en⊧eiﬀe=en
τ⊧ϕ∧/slash.left∨ψiﬀτ⊧ϕand/orτ⊧ψ
e1e2...en⊧[t]iﬀ(∃1≤i≤n)(ei=block@tand
(∀i<j≤n)ej≠unblock@t)
e1e2...en⊧ϕ→ψiﬀ(∀1≤i≤n)e1e2...ei/slash.left⊧ψor
(∃1≤i≤n)(e1e2...ei⊧ψand
(∃1≤j≤i)e1e2...ej⊧ϕ)
It is not hard to see that the two new operators [t]and
ϕ→ψcan be expressed in terms of PTLTL as
[t]≡¬unblock@tSblock@t
ϕ→ψ≡/boxdot¬ψ∨ ⟐(ψ∧⟐ϕ)
whereSstands for“since”and /boxdotfor“always in the past”.
4. MIGRATION
We now describe the process of migrating legacy, sleep-
based tests to IMUnit, event-based tests. First we present
the steps that are typically performed during manual migra-
tion and then we describe the automated support that we
have developed for key steps of the migration.
4.1 Manual Migration
Based on our experience of manually migrating over 200
tests, the migration process typically follows these steps :
Step 1: Optionally add explicit names for threads in the
test code (by using a thread constructor with a name or by
adding a call to setName). This step is required if events are
taggedwiththeirthreadname(e.g. finishedAdd1@addThread )
in the schedule, because by default the JVM automatically
assigns a name (e.g. Thread-5) for each thread created with-
out an explicit name, and the automatic name may diﬀer
between JVMs or between diﬀerent runs on the same JVM.
Step 2:Introduce @Eventannotations for the events relevant
for the intended schedule. Some of these annotations will be
used for block events and some for basic events.
Step 3: Introduce a @Schedule annotation for the intended
schedule. Steps 2 and 3 are the hardest to perform as they
require understanding of the intended behavior of the sleep -
based test. Note that a schedule with too few orderings can
lead to failing tests that are false positives. On the other
hand, a schedule with too many orderings may lead to false
negatives whereby a bug is missed because the schedule is
over-constraining the test execution.
Step 4: Check that the orderings in the introduced sched-
ule are actually satisﬁed when running the test with sleeps
(Section 5describes the passive, checking mode).
Step 5:Remove sleeps.
Step 6:Optionallymerge multipletests with diﬀerentsched-
ules (butsimilar test code) intoonetest with multiple sche d-
ules, potentially adding schedule-speciﬁc code (Section 4.3).
4.2 Automated Migration
We have developed automated tool support to enable eas-
ier migration of sleep-based tests to IMUnit. In particular ,
we have developed inference techniques that can computeenumEntryType {SLEEPCALL, SLEEP RETURN, BLOCK CALL,
BLOCK RETURN, OTHER CALL, OTHER RETURN, TH START,
THEND, EVENT }
classLogEntry {EntryType type; ThreadID tid; String info; StmtID sid; }
Figure 3: Log Entries
likely relevant events and schedules for sleep-based tests by
inspecting the execution logs obtained from test runs. We
next describe the common infrastructure for logging the tes t
runs. We then present the techniques for inferring events
and schedules.
4.2.1 LightweightLogging
Our inference of events and schedules from sleep-based
tests is dynamic: it ﬁrst instrumentsthe test code (usingAs -
pectJ [19]) to emit entries potentially relevant for inference,
thenruns the instrumentedcode (several times, as explaine d
below) to collect logs of entries from the test executions, a nd
ﬁnally analyzes the logs to perform the inference.
Figure3shows the generic representation for log entries,
although event and schedule inference require slightly diﬀ er-
ent representations. Each log entry has a type, name/ID of
the thread that emits the entry, potential info/parameters
for the entry, and the ID of the statement that creates the
entry (which is used only for event inference). The types of
log entries and their corresponding infoare as follows:
SLEEP_CALL : Invocation of Thread.sleep method. (Only used
for inferring events.)
SLEEP_RETURN : Return from Thread.sleep method.
BLOCK_CALL : Invocation of a thread blocking method ( Lock-
Support.park orObject.wait ).
BLOCK_RETURN : Return from a thread blocking method.
OTHER_CALL : Invocation of a method (other than those listed
above)inthetestclass. The infois themethodname. (Only
used for inferring events .)
OTHER_RETURN : Return from a method executed from the test
class.
TH_START: Invocation of Thread.start . Theinfois the ID of
the started thread. (Only used for inferring schedules.)
TH_END: End of thread execution.
EVENT: Execution of an IMUnit event. The infois the name
of the event. (Only available while inferring schedules.)
Note that any logging can aﬀect timing of test execution.
Because sleep-based tests are especially sensitive to timi ng,
care must be taken to avoid false positives. We address this
in three ways. First, our logging is lightweight. The instru -
mented code only collects log entries (and their parameters )
relevant to the inference. For example, OTHER_CALL is not col-
lected for schedule inference. Also, the entries are buﬀere d
in memory during test execution, and they are converted to
strings and logged to ﬁle only at the end of test execution.
While keeping entries in memory would not work well for
very long logs, it works quite well for the relatively short
logs produced by test executions. Second, our instrumenta-
tion automatically scales the duration of sleeps by a given
constantNto compensate for the logging overhead. For ex-
ample, forN=3 it increases all sleep times 3x. Increasing
all the durations almost never makes a passing test fail, but
it does make the test run slower. Third, we perform multipleFSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 2011runs of each test and only collect logs for passing runs. This
increases the conﬁdence that the logs indeed correspond to
the intended schedules speciﬁed with sleeps.
4.2.2 InferringEvents
Figure4presentsthealgorithmforinferringIMUnitevents
from a sleep-based test. The input to the algorithm consists
of a set of logs (as described in Section 4.2.1) and a con-
fidenceThreshold . The output is a set of inferred events.
Each event includes the code location where @Eventanno-
tation should be added and the name of the event. The
intuition behind the algorithm is that SLEEP_CALL log entries
are indicative of code locations for events. More precisely , a
threadtcallssleepto wait for one or more events to happen
on other threads (those will be“ﬁnished”events) before an
event happens on t(that will be a“starting”event). Recall
our example from Section 2. When the mainthread calls
sleep, it waits for addto ﬁnish before takestarts, and thus
finishedAdd1 executes before startingTake1 .
For each log, the algorithm ﬁrst computes a set of regions,
each of which is a sequence of log entries between SLEEP_CALL
andthematching SLEEP_RETURN executedbythesame thread.
The log entries executedbyotherthreads within aregion are
potential points for the“ﬁnished”events. Regions from dif -
ferent threads can be partially or completely overlapping,
but regions from the same thread are disjoint (i.e., each
SLEEP_CALL is followed directly by SLEEP_RETURN before any
other statement is executed by the thread). Figure 5shows
two regions for a simpliﬁed log produced by our running ex-
ample. In pseudo-code, each region is represented as a pair
ofints that point to the beginning and end of the region
in the list of log entries. For each region, the algorithm
ﬁrst calls addFinishedEvents to potentially add some “ﬁn-
ished”events for threads other than the region’s thread. If
an event is added, the algorithm calls addStartingEvent to
add the matching“starting”event.
The procedure addFinishedEvents potentially adds an in-
ferred event for each thread that executes at least one state -
ment in the region. For each such thread, the procedure ﬁrst
discovers a relevant statement, which is one of SLEEP_CALL ,
BLOCK_CALL , andTH_END. Only threads that have exactly one
relevant statement in the region are considered. The intu-
ition is that sleeps usually wait for exactly one event in eac h
other thread. If a thread executes none or multiple rele-
vant statements, it is most likely independent of the thread
that started the region and therefore can be ignored. Fig-
ure5shows the relevant statements for each region. The
procedure then ﬁnds the OTHER_RETURN statement immedi-
ately before the relevant statement for each thread. This
statement determines the name for the new“ﬁnished” Stat-
icEvent, whereas the relevant statement determines the lo-
cation. Note that logging only method calls would not be
enough to properly determine the previous statement since
the call can come from a helper method in the test class. For
our example, these before log entries are OTHER_RETURN(add),
addThread, 326 andOTHER_RETURN(take), main, 336 (Fig.5).
The procedure addStartingEvent adds an event for the
thread that starts the region. The eventis placed just befor e
the ﬁrst statement that follows the end of the region. The
type of the statement can be any, including OTHER_CALL . The
same statement is used for naming the event. In Figure 5,
OTHER_CALL(take), main, 336 andOTHER_CALL(add), addThr-
ead, 330 are found following the algorithm.1// Input
2Set⟨List⟨LogEntry⟩⟩logs;
3ﬂoat conﬁdenceThreshold;
4// Output
5classStaticEvent {StmtID sid; String name; }
6Set⟨StaticEvent ⟩events;
7// State
8Bag⟨StaticEvent ⟩inferred := ∅;
9
10classRegion{intstart;intend;}
11
12voidinferEvents() {
13foreach(List⟨LogEntry⟩loginlogs){
14foreach(Region r incomputeRegions(log)) {
15 boolean addedFinished := addFinishedEvents(r, log);
16 if(addedFinished) {addStartingEvent(r, log); }
17}
18}
19ﬁlterOutLowConﬁdence(conﬁdenceThreshold);
20events := inferred.toSet();
21}
22Set⟨Region⟩computeRegions(List ⟨LogEntry⟩log){
23return{newRegion(i, j) |log(i).type = SLEEP CALL∧
24 j :=min{k|log(i).tid = log(k).tid ∧
25 log(k).type = SLEEP RETURN } }
26}
27boolean addFinishedEvents(Region r, List ⟨LogEntry⟩log){
28boolean result∶=false;
29foreach(ThreadID t in{log(i).tid |i∈r}−{log(r.start).tid }){
30Set⟨int⟩relevant := {i∈r|log(i).tid = t ∧
31 log(i).type ∈{SLEEPCALL, BLOCK CALL, TH END}∧
32 ¬(∃j∈r|log(j).tid = t ∧
33 log(j).type ∈{SLEEPRETURN, BLOCK RETURN })}
34if(relevant.size() /slash.l⟩ft =1)continue ;
35intstarting := max{j<relevant |log(j).tid = t ∧
36 log(j).type = OTHER RETURN }
37addEvent(relevant, ”ﬁnished”, starting);
38result := true;
39}
40returnresult;
41}
42voidaddStartingEvent(Region r, List ⟨LogEntry⟩log){
43intﬁnished := min{j>r.start|log(j).tid = log(r.start).tid ∧
44 log(j).type ∈{OTHER CALL, TH END} }
45addEvent(ﬁnished, ”starting”, ﬁnished);
46}
47voidaddEvent( intlocation, String namePreﬁx, intsuﬃxIdx) {
48StmtID sid = log(location).sid;
49events∪=newStaticEvent(sid, namePreﬁx +
50 log(suﬃxIdx).info + sid);
51}
Figure 4: Events-Inference Algorithm
   Region 1Region 0// calls/returns if add is a helper methodTH_START, main, 333
SLEEP_CALL, main, 334
SLEEP_CALL, addThread, 328 // relevant in 0
SLEEP_RETURN, main, 334
BLOCK_CALL, main, 155 // relevant in 1
BLOCK_RETURN, main, 155
OTHER_RETURN(take), main, 339OTHER_CALL(add), addThread, 326
SLEEP_RETURN, addThread, 328
OTHER_CALL(add), addThread, 330
OTHER_RETURN(add), addThread, 330OTHER_RETURN(add), addThread, 326
OTHER_CALL(take), main, 336
OTHER_CALL(take), main, 339OTHER_RETURN(take), main, 336
Figure 5: Snippet from a Log for Inferring EventsFSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 20114.2.3 InferringSchedules
Figure6presents the algorithm to infer an IMUnit sch-
edule for a sleep-based multithreaded unit test that alread y
contains IMUnit event annotations. These annotations can
be automatically produced by our event inference or manu-
ally provided by the user. The input to the algorithm is a
set of logs obtained from the passing executions of the sleep -
based test. Figure 7shows a snippet from one such log for
our running example sleep-based test shown in Figure 1(a).
The input also contains a confidenceThreshold which will be
described later. The output is an inferred schedule, i.e., a
set of orderings that encodes the intended schedule for the
test. The main part of the algorithm is the addSleepIn-
ducedOrderings procedure. It captures the intuition that a
thread normally executes a sleep to wait for the other active
threads to perform events. Recall line 13from our example
in Figure 1(a)where the mainthread sleeps to wait for the
threadaddThread to perform an addoperation, and line 9
whereaddThread sleeps to wait for the mainthread to ﬁrst
perform one takeoperation and then block while performing
the second takeoperation.
For each log, the procedure scans for SLEEP_RETURN entries
(line31). As shown in Figure 7, the log for our example con-
tains two SLEEP_RETURN entries, one each in the mainthread
andaddThread . For each SLEEP_RETURN that is found, the pro-
cedure does the following:
1) Retrieves the next EVENTentry for the same thread
(line33). This event will be used as the afterevent in Or-
derings induced by the SLEEP_RETURN . In the example log, the
twoafterevents are startingTake1 for the ﬁrst SLEEP_RETURN
andstartingAdd2 for the second SLEEP_RETURN .
2) Computes the other threads that were activebetween
theSLEEP_RETURN and the afterevent (line 34). In the exam-
ple, for the ﬁrst SLEEP_RETURN , the only other active thread
isaddThread and for the second SLEEP_RETURN , the only other
active thread is main.
3) Finds for each active thread the last EVENTentry that
is before the afterevent. This event will be the before
event in the Ordering induced by the SLEEP_RETURN with the
corresponding active thread (line 38). Note that this before
eventon anotherthread canbe even beforetheSLEEP_RETURN .
Eﬀectively, this event is the currentlast entry and not the
last entry at the time of the sleep. In the example, the two
beforeevents are finishedAdd1 andstartingTake2 for the
ﬁrst and second SLEEP_RETURN s, respectively.
4) Creates an Ordering for each beforeandafterevent
pair and inserts it into the inferred bag. If a beforeevent
is followed immediately by a BLOCK_CALL (within entries for
the same thread), a BlockingOrdering is created; otherwise,
aNonBlockingOrdering is created (line 41). In the exam-
ple, since startingTake2 is followed by a BLOCK_CALL , the
ordering between startingTake2 andstartingAdd2 will be
aBlockingOrdering , while the other ordering between fin-
ishedAdd1 andstartingTake1 will be a NonBlockingOrdering .
Before the addSleepInducedOrderings procedure is invoked,
eachlogis modiﬁed by the preprocessLogs procedure. This
procedure looks for SLEEP_RETURN entries followed immedi-
ately by TH_START entries for the same thread. For everysuch
instance, it swaps the SLEEP_RETURN andTH_START entries and
sets the tidof theSLEEP_RETURN entry to be the ID of the
thread that is startedby theTH_START event. The intuition
is that a SLEEP_RETURN followed by a TH_START signiﬁes that
thestartedthread, rather than the starting thread perform-1classEvent{String eventName; ThreadID tid; }
2abstract classOrdering {Event before; Event after; }
3classNonBlockingOrdering extends Ordering {};
4classBlockingOrdering extends Ordering {};
5// Input
6Set⟨List⟨LogEntry⟩⟩logs;
7ﬂoat conﬁdenceThreshold;
8// Output
9Set⟨Ordering⟩orderings;
10// State
11Bag⟨Ordering⟩inferred := ∅;
12
13voidinferSchedules() {
14foreach(List⟨LogEntry⟩loginlogs){
15List⟨LogEntry⟩preprocessed := preprocessLog(log);
16addSleepInducedOrderings(preprocessed);
17}
18minimize();
19}
20List⟨LogEntry⟩preprocessLog(List ⟨LogEntry⟩log){
21List⟨LogEntry⟩result := log.clone();
22foreach({i|log(i).type = SLEEP RETURN }){
23intj :=min{j>i|log(j).tid = log(i).tid };
24if(log(j).type = TH START) {
25 result(j) := newLogEntry(SLEEP RETURN, , log(j).info);
26 result(i) := log(j);
27} }
28returnresult;
29}
30voidaddSleepInducedOrderings(List ⟨LogEntry⟩log){
31foreach({i∈log.indexes() |log(i).type = SLEEP RETURN }){
32ThreadID t := log(i).tid;
33intj :=min{n>i|log(n).tid = t ∧log(n).type = EVENT };
34Set⟨ThreadID⟩active := {t’|(∃n<j|
35 log(n).tid = t’ ∧log(n).type = EVENT ) ∧
36 (∃n>i|log(n).tid = t’ ∧log(n).type = TH END
)};
37foreach(ThreadID t’ inactive−{t}){
38 intj’ :=max{n<j|log(n).tid = t’ ∧log(n).type = EVENT };
39 Event before := newEvent(log(j’).info, t’);
40 Event after := newEvent(log(j).info, t);
41 if(log(min{n>j’|log(n).tid = t’ }).type/slash.l⟩ft =BLOCK CALL){
42 inferred∪=newNonblockingOrdering(before, after);
43 }else{//before.type= BLOCK CALL
44 inferred∪=newBlockingOrdering(before, after);
45 } } } }
46voidminimize(List ⟨LogEntry⟩log){
47Set⟨Ordering⟩graph := inferred.toSet() ∪computeSeqOrderings(log);
48removeCyclicOrderings(graph);
49performTransitiveReduction(graph);
50inferred.onlyRetainOrderingsIn(graph);
51ﬁlterOutLowConﬁdence(conﬁdenceThreshold);
52orderings := inferred.toSet();
53}
54voidSet⟨Ordering⟩computeSeqOrderings(List ⟨LogEntry⟩log){
55return{newNonblockingOrdering(log(i), log(j)) |
56 i<j∧log(i).tid = log(j).tid ∧
57 log(i).type = log(j).type = EVENT ∧
58 ¬(∃k|i<k<j∧log(j).tid = log(k).tid
59 ∧log(k).type = EVENT) };
60}
Figure 6: Schedule-Inference Algorithm
   Ordering1 Ordering0BLOCK_CALL, mainSLEEP_RETURN, mainTH_START(addThread), main
SLEEP_RETURN, addThreadEVENT(startingTake1), mainEVENT(finishedAdd1), addThread
EVENT(startingTake2), main
EVENT(startingAdd2), addThread
Figure 7: Snippet from a Log for Inferring SchedulesFSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 2011ing the TH_START, should wait for the other active threads
to perform events. Many of the sleep-based tests that we
migrated included instances of this pattern. Eﬀectively, t his
swap makes it appear as if the sleep was at the beginning
of therunmethod for the started thread, although the sleep
was actually before the startmethod.
After each log is processed by the preprocessLogs and
addSleepInducedOrderings procedures, the inferred bag is
populated with all the inferred orderings. However, the in-
ferred orderings may contain cycles (e.g., a->bandb->a)
and transitively redundant orderings (e.g., a->b,b->c, and
a->c, where the last ordering is redundant). The minimize
procedure removes such orderings. It ﬁrst creates an or-
deringgraphby combining the edges from the inferred or-
derings with the edges implied by the sequential orderings
of events within each thread (the latter edges being com-
puted by the computeSeqOrderings procedure). It then re-
moves all the edges of the graphthat participate in cycles.
It ﬁnally performs a transitive reduction on the acyclic graph
and updates the inferred bag by removing all orderings not
included in the reduced graph. We use an open-source im-
plementation [ 12] of the transitive reduction algorithm in-
troduced by Aho et al. [ 1]. Since the transitive reduction is
performed on an acyclic graph, we can use a simpler case of
the general algorithm.
The last step of the minimize procedure is to remove the
orderings thatwere inferred withlowconﬁdence. Recall tha t
the input to our inference is a set of logs from several (pass-
ing) runs of the test being migrated. The conﬁdence of an
inferred ordering is the ratio of the count of that ordering
in theinferred bag and the number of logs/runs. For ex-
ample, an ordering may be inferred in only 60% of runs, say
3 out of 5. The confidenceThreshold deﬁnes the lowest ac-
ceptable conﬁdence. All inferred orderings with conﬁdence
lower than the speciﬁed threshold are discarded.
4.2.4 EclipsePlugin
We have developed a refactoring plugin for Eclipse to en-
able automated migration of existing sleep-based unit test s
into event-based IMUnit tests. The plugin is implemented
using the generic refactoring API provided by Eclipse. The
refactoring automates the most important steps required to
migrate a sleep-based test into an IMUnit test: introduc-
tion of events and schedule (using inference techniques) an d
checking of the introduced schedule. The refactoring can
also help the user name the threads in the test.
4.3 Multiple Schedules
As mentioned in Step 6 of Section 4.1, after converting
sleep-based tests to event-based IMUnit tests, developers
can merge several similar tests with diﬀerent schedules int o
one test with multiple IMUnit schedules. Recall our exam-
ple sleep-based test from Figure 1(a). Its intended schedule
is anaddfollowed bya non-blocking takeand a blocking take
followed by another add. Suppose that the same test class
contained another sleep-based test whose indented schedul e
is anaddfollowed by a non-blocking takeand another add
followed by another non-blocking take. Although these two
sleep-basedtests wouldbealmost identical(withthesleep at
line9moved to before line 16), they cannot share the com-
mon code without using additional conditional statements
to enable the appropriate sleeps during execution. In con-
trast, after bothtests are migrated toIMUnittests, theyca nbe easily replaced by just one new test. This new test would
have the same code as in Figure 1(a), with two added anno-
tations: (1) @Event("finishedAdd2") added after the add(2)
call, and (2) @Schedule("finishedAdd1->startingTake1, fin-
ishedAdd2->startingTake2") added before the test method.
5. ENFORCING& CHECKING
We now describe the IMUnit Runner, our tool for enforc-
ing/checking schedules for IMUnit tests. It is implemented
as a custom test runner for the JUnit testing framework.
It executes each test for each IMUnit schedule and has two
operation modes. In the active mode , it controls the thread
scheduler to enforce an execution of the test to satisfy the
given schedule. Note that this mode avoids the main prob-
lem of sleep-based tests, that of false positives and negati ves
due to the execution of unintended schedules. In the passive
mode, our tool observes and checks the execution provided
by the JVM against the given schedule.
Our runner is implemented using JavaMOP [ 10,24], a
high-performance runtime monitoring framework for Java.
JavaMOP is generic in the property speciﬁcation formalism
andprovides several such formalisms as logic plugins , includ-
ing past-time linear temporal logic (PTLTL). Although our
schedule language is a semantic fragment of PTLTL (Sec-
tion3), enforcing PTLTL speciﬁcations in their full gener-
ality on multithreaded programs is rather expensive.
Instead, we have developed a custom JavaMOP logic plu-
gin for our current IMUnit schedule language from Figure 2.
Since JavaMOP takes care of all the low-level instrumenta-
tion and monitor integration details (after a straightforw ard
mapping of IMUnit events into JavaMOP events), we here
only brieﬂy discuss our new JavaMOP logic plugin. It takes
as input an IMUnitschedule and generates as outputa mon-
itor written in pseudo-code; a Java shell for this language
then turns the monitor into AspectJ code [ 19], which is fur-
ther woven into the test program. In the active mode, the
resulting monitor enforces the schedule by blocking the vio -
lating thread until all the conditions from the schedule are
satisﬁed. Inthepassive mode, it simply printsan error when
its corresponding schedule is violated.
A generated monitor for an IMUnit schedule observes the
deﬁned events. When an event eoccurs, the monitor checks
all the conditions that the event should satisfy according t o
the schedule, i.e., a Boolean combination of basic and block
events (Figure 2). The status of each basic event is main-
tained by a Boolean variable which is true iﬀ the event oc-
curred in the past. The status of a block event is checked as
a conjunction of this variable and its thread’s blocked stat e.
In the active mode, the thread of ewill be blocked until this
Boolean expression becomes true. If the condition contains
any block event, periodic polling is used for checking threa d
states. Thus, IMUnit pauses threads only if their events are
getting out of order for the schedule. Note that the user
may have speciﬁed an infeasible schedule, which can cause a
deadlock where all threads are paused. Our runner includes
a low-overhead runtime deadlock detection that detects and
reports deadlocks.
As an example, Figure 8shows the active-mode moni-
tor generated for the schedule in Figure 1(c). When events
finishedAdd1 andstartingTake2 occur, the monitor just sets
the correspondingBoolean variables, as thereis noconditi on
for those events. For event startingTake1 , it checks if there
was an event finishedAdd1 in the past by checking the vari-FSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 20111switch ( event ) {
2caseﬁnishedAdd1:
3occurred ﬁnishedAdd1 = true; notifyAll ();
4casestartingTake2 :
5thread startingTake2 = currentThread ();
6occurred startingTake2 = true; notifyAll ();
7casestartingTake1 :
8while (! occurred ﬁnishedAdd1)
9 wait ();
10occurred startingTake1 = true; notifyAll ();
11casestartingAdd2:
12while (!( occurred startingTake2 &&
13 isBlocked ( thread startingTake2)))
14 wait ();
15occurred startingAdd2 = true; notifyAll (); }
Figure 8: Monitor for the schedule in Figure 1(c)
ableoccurred_finishedAdd1 ; ifnot, thethreadwill beblocked
untilfinishedAdd1 occurs. For event startingAdd2 , in addi-
tion to checking the Boolean variable for startingTake2 , it
also checks whether the thread of the event startingTake2 is
blocked; if not, the thread of the event startingAdd2 will be
blocked until both conditions are satisﬁed.
6. EVALUATION
ToevaluatetheIMUnitcontributions—schedulelanguage,
automated migration, and schedule execution—we analyzed
over 200 sleep-based tests from several open-source projec ts.
Table1lists theprojects andthenumberofsleep-based tests
that we manually migrated to IMUnit. We ﬁrst describe
our experience with the IMUnit language. We then present
results of our inference techniques for migration. We ﬁnall y
discuss the test running time.
6.1 Schedule Language
It is hard to quantitatively evaluate and compare lan-
guages, be it implementation or speciﬁcation languages, in -
cluding languages for specifying schedules. One metric we
use is how expressive the language is, i.e., how many sleep-
based tests can be expressed in IMUnit such that sleeps can
be removed altogether . Note that IMUnit conceptually sub-
sumes sleeps: sleeps and IMUnit events/schedules can co-
exist in the same test, and developers just need to make
sleeps long enough to account for the IMUnit schedule en-
forcement. While every sleep-based test is trivially an IMU -
nit test, we are interested only in those tests where IMUnit
allows removing sleeps altogether.
We were able to remove sleeps from 198 tests, in fact all
sleeps from all but 4 tests. While the current version of
IMUnit is highly expressive, we have to point out that we
reﬁned the IMUnit language based on the experience with
migrating the sleep-based tests. When we encountered a
case that could not be expressed in IMUnit, we considered
how frequent the case is, and how much IMUnit would need
to change to support it. For example, blocking events are
very frequent, and supporting them required a minimal syn-
tactic extension (adding events with square brackets) to th e
initial version of our language. However, some cases would
require bigger changes but are not frequent enough to jus-
tify them. The primary example is events in a loop. IMUnit
currently does not support the occurrence of an event more
than once in a trace. We did ﬁnd 4 tests that would require
multiple event occurrences, but changing the language to
support them (e.g., adding event counters or loop indices to
events) would add a layer of complexity that is not justiﬁed
by the small number of cases. However, as we apply IMUnitSubject Tests Events Orderings
Collections [ 4] 18 51 32
JBoss-Cache [ 18] 27 105 47
Lucene [ 6] 2 3 4
Mina [7] 1 2 1
Pool [5] 2 8 3
Sysunit [ 11] 9 33 34
JSR-166 TCK [ 17]139 577 277
∑ 198 779 398
Table 1: Subject Programs Statistics
to more projects, and gain more experience, we expect that
the language could grow in the future.
6.2 Inference ofEvents andSchedules
To measure the eﬀectiveness of our migration tool in infer-
ring events/schedules, we calculated precision and recall of
automatically inferred events/schedules with respect to t he
manually written events/schedules (i.e., the manual trans -
lations from sleep-based schedules). Calculating precisi on
andrecall requires comparingtheautomatically inferred a nd
manually written events/schedules. For event inference, t he
input is a sleep-based test, and the output is a set of events.
Our current comparison uses only the source-code location
(line number) of the static events and not their name. For
schedule inference, the input is a sleep-based test with man-
ually written (not automatically inferred) events , and the
output is a schedule. Our comparison considers all order-
ings from the automatically inferred and manually written
schedules; two orderings match only if they have exactly the
sameboth before and after events (including their name and
type that can be basic or block). We performed the com-
parisons for all but 14 (discussed below) of our 198 tests.
Table2shows for each project precision and recall values,
averaged over the tests from that project.
Columns two and three show the results for event infer-
ence. In most cases, precision and recall are fairly high.
We inspected the cases with lower precision and identiﬁed
two causes for it. The ﬁrst cause is due to our evaluation
setupandnot thealgorithm itself. Namely, our currentcom-
parison requires the exact match of source-code locations. If
the locations diﬀer, the inferred event counts as a false neg a-
tive, evenifit was onlyafewlines from themanuallywritten
event, and even if those locations are equivalent with respe ct
to the code. In the future, we plan to improve the setup by
analyzing the code around the automatically inferred and
manually written events to determine if their locations are
equivalent. The second reason is that some tests use sleeps
that are not relevant for the thread schedule (e.g., JBoss-
Cache has such sleeps in the helper threads shared among
tests, and Lucene has similar sleeps while interacting with
the I/O library). These extra sleeps mislead our inference,
which assumes that every sleep is relevant for the schedule
and infers events for every sleep.
Columns four and ﬁve show the results for schedule infer-
ence. The results are even more impressive than for event
inference, with precision and recall of over 75% in all cases .
We identiﬁed two causes for misses. The ﬁrst cause is that
some threads can be independent. The algorithm always
forms edges from all threads to the thread that invokes
sleep method, but this should not be done for independent
threads. In the future, we plan to consider an abstraction
similar to regions (Figure 4) as a mechanism to detect inde-FSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 2011SubjectInferring Events Inferring Schedules
Precision Recall Precision Recall
Collections 0.75 0.82 0.96 0.97
JBoss-Cache 0.83 0.86 0.87 0.96
Lucene 0.75 1.00 1.00 0.75
Mina 0.22 1.00 1.00 1.00
Pool 0.90 1.00 1.00 1.00
Sysunit 0.76 0.87 0.89 0.89
JSR-166 TCK 0.67 0.74 0.98 0.98
Overall 0.75 0.79 0.96 0.94
Table 2: Precision and Recall for Inference
Subject Original CRTRLC
Collections 33 000
JBoss-Cache 39 230
Lucene 5011
Mina 1000
Pool 3000
Sysunit 39 050
JSR-166 TCK 306 0301
Table 3: Numbers of Removed Orderings
pendent threads. The second cause is the same as for event
inference, namely unnecessary sleeps.
A known issue in information retrieval is that some re-
sult sets may be empty, which corresponds to inﬁnite pre-
cision and zero recall. For 14 of 198 tests, our inference
techniques returned empty sets of events/schedules becaus e
these tests do not use sleeps to control schedules. Instead,
these tests use while (condition) { Thread.sleep/yield } or
wait/notifyorCountDownLatch and other concurrent con-
structs to control schedules. We excluded these 14 tests
from the evaluation of our inference techniques.
Our inference algorithms use confidenceThreshold to se-
lect some of the events/schedules, with the default value of
0.5 (for Table 2). We performed a set of experiments to
evaluate how sensitive our inference is to the value of con-
fidenceThreshold . We found that the results are quite sta-
ble. For example, for schedule inference, when changing the
value from 0.5 to 0.1, only for Lucene the precision drops
from 1 to 0.75. When changing the value from 0.5 to 0.9,
only for JBoss-Cache the precision and recall drop from 0.87
and 0.96 to 0.86 and 0.93, respectively. For all other cases,
everything else is inferred exactly the same for the values
0.1 and 0.9 as for the default value 0.5.
The other input to our inference algorithms is the set of
logs obtained from passing runs of the legacy tests. By de-
fault, we collect 5 passing logs for each test (for Table 2).
Diﬀerent runs of the legacy test can produce diﬀerent logs
that can in turn result in diﬀerent sets of events/schedules
being inferred. Therefore, depending on the number of logs,
inferred events/schedules could diﬀer. So we evaluated how
sensitive our inference is to the number of logs. We found
that the logs are quite stable, and almost identical results
were obtained for 1, 5, and 10 logs. For instance, going from
5 to 10 logs only the recall for JBoss-Cache drops from 0.96
to 0.94, and everything else remains the same.
Lastly, our schedule-inference algorithm runs a minimiza-
tion phase after processing all the logs. Table 3summarizes
the results of this phase. It tabulates, for each project, th e
number of schedule orderings originally inferred before mi n-
imization (Original) and the numbers of orderings removed
by cycles removal (CR), by transitive reduction (TR), andSubjectOriginal IMUnit [s] Speedup
[s] DDD DDE DDD DDE
Collections 4.96 1.06 1.67 4.68 2.97
JBoss-Cache 65.58 31.25 31.76 2.10 2.06
Lucene 11.02 3.57 6.12 3.09 1.80
Mina 0.26 0.17 0.20 1.53 1.30
Pool 1.43 1.04 1.04 1.38 1.38
Sysunit 17.67 0.35 0.4550.49 39.27
JSR-166 TCK 15.20 9.56 9.56 1.59 1.59
GeometricMean 3.39 2.76
Table 4: Test execution time. DDD - deadlock de-
tection disabled; DDE - deadlock detection enabled
due to low conﬁdence (LC). As it can be seen, the mini-
mization phase does not remove many orderings. However,
it is important to remove the orderings it does remove. For
example, without removing the cycle for JBoss-Cache, not
only would inference have a lower precision but it would also
produce a schedule that is unrealizable.
6.3 Performance
Table4shows the execution times of the 198 original,
sleep-based tests and the corresponding IMUnit tests (for
IMUnit,withdeadlockdetectionbothdisabledandenabled) .
We ran the experiments on an Intel i7 2.67GHz laptop with
4GB memory, using Sun JVM 1.6.0 06. Our goal for IMU-
nit is to improve readability, modularity, and reliability of
multithreaded unit tests, and we did not expect IMUnit ex-
ecution to be faster than sleep-based execution. In fact, on e
could even expect IMUnit to be slower because of the addi-
tional code introduced by the instrumentation and the cost
of controlling schedules. It came as a surprise that IMUnit
is faster than sleep-based tests, on average 3.39x. Even wit h
deadlock detection enabled, IMUnit was on average 2.76x
faster. This result is with the sleep durations that the orig -
inal tests had in the code.
We also compared the runningtime of IMUnit with Multi-
threadedTCon acommon subsetof JSR-166TCK tests that
theMultithreadedTCauthorstranslatedfrom sleep-basedt o
tick-based [ 25]. For these 129 tests, MultithreadedTC was
1.36x faster than IMUnit. Although MultithreadedTC is
somewhat faster, it has a much higher migration cost, and
in our view, produces test code that is harder to understand
and modify than the IMUnit test code. Moreover, we were
surprised to notice that running MultithreadedTC on these
tests, translatedbytheMultithreadedTCauthors, canresu lt
in some failures (albeit with a low probability), which mean s
that these MultithreadedTC tests can be unreliable and lead
to false positives in test runs.
7. RELATED WORK
Three areas of work are related to IMUnit: (1) unit test-
ing of multithreaded code, (2) enforcement of schedules,
and (3) automated inference of speciﬁcations. We brieﬂy
discuss each of them. (1) ConAn [ 22,23] and Multithre-
adedTC [ 26] introduce unit testing frameworks that allow
developers to specify schedules to be used during the exe-
cution of multithreaded unit tests. However, the schedules
in both frameworks are speciﬁed relative to a global clock
(real time for ConAn and logic time for MultithreadedTC),
which makes it diﬃcult to reason about the schedules. Also,
neither framework supports automated migration of sleep-FSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 2011based tests. ConcJUnit [ 27] extends JUnit to propagate ex-
ceptions raised by child threads up to the main thread and
also checks whether all child threads have ﬁnished at the
end of a test method. ThreadControl [ 13] proposes a tool
to ensure that assertions are performed without interferen ce
from other threads. (2) There has been some previous work
on using formally speciﬁed sequencing constraints to verif y
multithreaded programs [ 28]. The speciﬁcations are over
sync events with LTL-like constraints, and the veriﬁcation
ensures that the implementation is faithful to the speciﬁca -
tion. In contrast, IMUnit schedule speciﬁcations are used
to enforce ordering between user-speciﬁed events while the
system is tested. Carver and Tai [ 9] use deterministic replay
for concurrent programs. LEAP [ 14] is a more recent sys-
tem usingasimilar record-and-replayapproach toreproduc e
bugs. In comparison, our enforcement and checking mecha-
nism targets ensuringtheuser-speciﬁed schedulerather th an
replaying a previously observed execution. (3) Work on au-
tomated mining of speciﬁcations for programs [ 2,3,8,21] is
related to our automated inference of events and schedules.
However, most existing work focuses on mining API usage
patterns/rules in a single threaded scenario, while our tec h-
niques mine the intention of sleep-based tests i.e. interes ting
events and event orderings across multiple threads.
8. CONCLUSIONS
Current approaches for unit testing of multithreaded code
have issues with readability, modularity, reliability, an d/or
migration cost. We presentedIMUnit, anovelapproachthat
addresses these issues. IMUnit includes a new language that
makes tests more readable and modular as it allows explic-
itly specifying schedules on the events during test executi on.
We described inference techniques and a tool that can help
in migrating sleep-based tests to IMUnit. We also described
a tool that can reliably execute the speciﬁed schedule to
avoid false positives/negatives. The promising results wi th
IMUnit encourage us to further explore this approach, e.g.,
for automatic generation of multithreaded tests (both test
code and schedules) only from the code under test, or for
regression testing of code with IMUnit schedules [ 16].
Acknowledgements
We would like to thank Feng Chen, Steven Lauterburg and
Traian ¸ Serb˘ anu¸ t˘ a for initial discussion on this work. A lso,
we would like to thank the participants of the IWMSE 2010
workshop for useful feedback. This work is partially sup-
portedbytheNationalScienceFoundationunderGrantNos.
CCF-1012759, CNS-0958199, CCF-0916893, CCF-0746856,
and CNS-0720512, by Intel and Microsoft via the Universal
Parallel Computing Research Center (UPCRC), by NASA
contract NNL08AA23C, by an NSA grant, by a UIUC Cam-
pus Research Board Award, and by a Samsung SAIT grant.
9. REFERENCES
[1] A. V. Aho, M. R. Garey, and J. D. Ullman. The
transitive reduction of a directed graph. SIAM
Journal on Computing , 1972.
[2] R. Alur, P. Cern´ y, M. Parthasarathy, and W. Nam.
Synthesis of interface speciﬁcations for Java classes. In
POPL, 2005.
[3] G. Ammons, R. Bod´ ık, and J. R. Larus. Mining
speciﬁcations. In POPL, 2002.[4] Apache Software Foundation. Apache Commons
Collections.
http://commons.apache.org/collections/ .
[5] Apache Software Foundation. Apache Commons Pool.
http://commons.apache.org/pool/ .
[6] Apache Software Foundation. Apache Lucene.
http://lucene.apache.org/ .
[7] Apache Software Foundation. Apache MINA.
http://mina.apache.org/ .
[8] J. Burnim and K. Sen. DETERMIN: Inferring likely
deterministic speciﬁcations of multithreaded
programs. In ICSE, 2010.
[9] R. H. Carver and K. Tai. Replay and testing for
concurrent programs. IEEE Software , 1991.
[10] F. Chen and G. Ro¸ su. Mop: An eﬃcient and generic
runtime veriﬁcation framework. In OOPSLA , 2007.
[11] Codehaus. Sysunit.
http://docs.codehaus.org/display/SYSUNIT/Home .
[12] S. Cotton. graphlib.
http://www-verimag.imag.fr/~cotton/ .
[13] A. Dantas, F. V. Brasileiro, and W. Cirne. Improving
automated testing of multi-threaded software. In
ICST, 2008.
[14] J. Huang, P. Liu, and C. Zhang. LEAP: Lightweight
deterministic multi-processor replay of concurrent
Java programs. In FSE, 2010.
[15] V. Jagannath, M. Gligoric, D. Jin, G. Rosu, and
D. Marinov. IMUnit: Improved multithreaded unit
testing (position statement). In IWMSE, 2010.
[16] V. Jagannath, Q. Luo, and D. Marinov. Change-aware
preemption prioritization. In ISSTA, 2011.
[17] Java Community Process. JSR 166: Concurrency
utilities.
http://g.oswego.edu/dl/concurrency-interest/ .
[18] JBoss Community. JBoss Cache.
http://www.jboss.org/jbosscache .
[19] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten,
J. Palm, and W. G. Griswold. An overview of
AspectJ. In ECOOP, 2001.
[20] Lassi Project. Sleep testcase.
http://tinyurl.com/4hk9zdr .
[21] C. Lee, F. Chen, and G. Ro¸ su. Mining parametric
speciﬁcations. In ICSE, 2011.
[22] B. Long, D. Hoﬀman, and P. A. Strooper. A
concurrency test tool for Java monitors. In ASE, 2001.
[23] B. Long, D. Hoﬀman, and P. A. Strooper. Tool
support for testing concurrent Java components. IEEE
TSE, 2003.
[24] P. O. Meredith, D. Jin, D. Griﬃth, F. Chen, and
G. Ro¸ su. An overview of the MOP runtime
veriﬁcation framework. Springer STTT , 2011.
[25] W. Pugh and N. Ayewah. MultithreadedTC - A
framework for testing concurrent Java applications.
http://code.google.com/p/multithreadedtc/ .
[26] W. Pugh and N. Ayewah. Unit testing concurrent
software. In ASE, 2007.
[27] M. Ricken and R. Cartwright. ConcJUnit: Unit
testing for concurrent programs. In PPPJ, 2009.
[28] K. Tai and R. H. Carver. Use of sequencing
constraints for specifying, testing, and debugging
concurrent programs. In ICPADS , 1994.FSE'11, ACM, pp 223-233. 2011
FSE'11, ACM, pp 223-233. 2011