Crossing the Gap from Imperative to Functional
Programming through Refactoring
Alex Gyori
University of Illinois, USA
gyori@illinois.eduLyle Franklin
Ball State University, USA
ljfranklin@bsu.eduDanny Dig
Oregon State University, USA
digd@eecs.oregonstate.edu
Jan Lahoda
Oracle, Czech Republic
jan.lahoda@oracle.com
ABSTRACT
Java 8 introduces two functional features: lambda expres-
sions and functional operations like maporfilter that ap-
ply a lambda expression over the elements of a Collection .
Refactoring existing code to use these new features enables
explicit but unobtrusive parallelism and makes the code
more succinct. However, refactoring is tedious: it requires
changing many lines of code. It is also error-prone: the
programmer must reason about the control-, data-ow, and
side-eects. Fortunately, refactorings can be automated.
We designed and implemented LambdaFicator , a tool which
automates two refactorings. The rst refactoring converts
anonymous inner classes to lambda expressions. The second
refactoring converts forloops that iterate over Collection s
to functional operations that use lambda expressions. Using
9 open-source projects, we have applied these two refactor-
ings 1263 and 1709 times, respectively. The results show
that LambdaFicator is useful: (i) it is widely applicable,
(ii) it reduces the code bloat, (iii) it increases programmer
productivity, and (iv) it is accurate.
Categories and Subject Descriptors: D.2.7 [Software
Engineering]: Distribution, Maintenance, and Enhancement;
D.2.3 [Software Engineering]: Coding Tools and Techniques
General Terms: Refactoring
Keywords: Java 8, Lambda Expressions, Imperative Pro-
gramming, Functional Programming
1. INTRODUCTION
A lambda expression (also called an anonymous function)
is a function without a name identier. For example,
(int x, int y) -> x + y is a lambda expression that takes
two integer args and returns their sum. Lambda expressions
can be conveniently passed as parameters or can be returned
from functions, and are the hallmark of functional languages.
Some object-oriented languages such as Smalltalk, Scala,
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
ESEC/FSE â€™13, August 18-26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08 ...$15.00.JavaScript, and Ruby supported lambda expressions from
the rst release. Others, like C# (v 3.0), C++ (v 11) were
retrotted with lambda expressions. Java 8 (to be released
in 2014) is the latest mainstream language to retrot lambda
expressions [6].
The driving motivation for retrotting lambdas in main-
stream imperative languages is to make it easier to write par-
allel code. The hardware industry has shifted to multicore
processing on all fronts: phones, tablets, laptops, desktops,
etc. The software industry trend is to hide the complexity
of writing parallel code behind parallel libraries. For exam-
ple, the C# TPL [8] and PLINQ [3] libraries, or the C++
TBB [2] library rely heavily on lambda expressions to en-
capsulate functions that are passed to library APIs to be
executed in parallel.
Enabled by lambda expressions, the upcoming Java 8 col-
lections [7] provide internal iterators [11] that take a lambda
expression as an argument. For example, filter takes a
predicate expression and removes elements of a collection
based on the predicate, mapmaps the elements of a collection
into another collection, forEach executes a block of code over
each element, etc. The internal iterators enable library de-
velopers to optimize performance, for example by providing
parallel implementation, short-circuiting, or lazy evaluation.
Until now, Java did not support lambda expressions, but
instead emulated their behavior with anonymous inner classes
(from here on referred as AIC). An AIC typically encodes
just a function. The Java class library denes several inter-
faces that have just one method. These are called functional
interfaces and are mostly instantiated as AIC. Classic exam-
ples are Runnable { whose runmethod encapsulates work to
be executed inside a Thread , and Comparator { whose compare
method imposes a total order on a collection.
Refactoring existing Java code to use lambda expressions
brings several benets. First, the refactoring makes the code
more succinct and readable when introducing explicit but
unobtrusive parallelism. The parallel code below:
myCollection.parallelStream().map(e -> e.length())
would have taken 25 lines of code had we used the classic
Thread and Runnable idioms (see example in Fig. 1).
Even when not using parallelism, the programmer can
write succinct expressions when using lambdas. Previously,
using the old AIC, the programmer had to write ve lines
of code to encapsulate a single statement.
Second, the refactored code makes the intent of the loop
more explicit. Suppose we wanted to iterate over a collection
ofblocks , and color all blue blocks in red. Compared to theold style of external iterators (e.g., with a forstatement),
the refactored loop is:
blocks.stream().filter(b -> b.getColor() == BLUE)
.forEach(b -> { b.setColor(RED);})
This style encourages chaining the operations in a pipeline
fashion, thus there is no need to store intermediate results in
their own collections. Many programmers prefer this idiom,
as witnessed by its popularity in Scala [9], FluentIterable [1]
in Guava Google Libraries, or Microsoft PLINQ library [19].
Third, elements may be computed lazily: if we mapa col-
lection of a million elements, but only iterate over the re-
sults later, the mapping will happen only when the results
are needed.
To get all the benets of lambda expressions and internal
iterators, the Java programmer must refactor (i) AIC into
lambda expressions and (ii) forloops into internal iterators.
However, these refactorings are tedious . Java projects are
riddled with many anonymous classes and external iterators.
For example, ANTLRWorks, a medium-sized open-source
project (97K non-blank, non-comment source lines { SLOC)
contains 151 AICs and 589 external iterators. Refactoring
ANTLRWorks by hand requires changing 513 SLOC for the
rst refactoring, and 2293 SLOC for the second refactoring.
Moreover, these changes are non-trivial. When convert-
ingAIC to lambda expressions, the programmer must rst
account for the dierent scoping rules between AIC and
lambda expressions. These dierences could introduce sub-
tle bugs. For example, this orsuper are relative to the inner
class where they are used, whereas in lambda expressions
they are relative to the enclosing class. Similarly, local vari-
ables declared in the AIC are allowed to shadow variables
from the enclosing class, whereas the same variables in the
lambda expression will conict with variables from the en-
closing class. Second, converting AIC to lambda could make
the resulting type ambiguous, thus it requires inferring the
type of the lambda.
When converting forloops to internal iterators there are
several challenges. First, there are many ways to split loop
statements into pipelined operations. Ideally the program-
mer would choose the most ne-grained to enable precise
control of parallelism and make the intent of statements
more explicit. Second, the programmer must reason about
the control ow statements like break ,continue ,return and
choose the appropriate operations. Third, the programmer
must account for dierent scoping rules between the original
forand the lambdas: a variable declared in a loop statement
is available to subsequent loop statements, whereas a vari-
able declared in one lambda expression is now local to that
lambda. This requires identifying the variables that need
to be passed through the pipeline. Fourth, the programmer
must verify there are no side eects on local variables de-
ned outside of the lambda. Fifth, the programmer must
reason about the nature (e.g., eager vs. lazy) of operations
in order to preserve the semantics of the original for.
To solve these challenges, we designed, implemented, and
evaluated LambdaFicator , the rst refactoring tool to auto-
mate the task of retrotting functional features into imper-
ative code. LambdaFicator currently supports two refactor-
ings. The rst refactoring, AnonymousToLambda , replaces
AIC with the equivalent lambda expression. The second
refactoring, ForLoopToFunctional , replaces forloops with
their equivalent chained operations.
This paper makes the following contributions:Problem: to the best of our knowledge, this is the rst
paper to describe the novel problem of converting imperative
code to a functional avor using lambdas.
Algorithms: we designed the analysis and transformation
algorithms to address the challenges for two refactorings
that convert AIC into lambda expressions and forloops into
functional operations. These algorithms account for dier-
ent scoping rules between the old and the new languages
constructs and convert imperative in-place mutations into
functional computations that produce new values.
Implementation: we are the rst to implement these refac-
torings and make them available as an extension to a widely
used development environment. We are shipping both refac-
toring with the ocial release of the NetBeans IDE.
Evaluation: we evaluated our implementations by run-
ning the two refactorings on 9 open-source projects (total-
ing almost 1M SLOC), invoking AnonymousToLambda 1263
times, and ForLoopToFunctional 1709 times. The results
show that the refactorings are widely applicable : the rst
refactoring successfully converted 55% of AIC and the sec-
ond refactoring converted 46% of forloops. Second, the
refactorings are valuable : the rst refactoring reduces the
code size by 2213 SLOC, while the second refactoring infers
2681 operators and 1709 chains thus making the intent of the
loop explicit. Third, LambdaFicator saves the programmer
from manually changing 3707 SLOC for the rst refactor-
ing, and 12313 SLOC for the second refactoring. Fourth,
when executed in batch mode on the whole projects, the
AnonymousToLambda refactoring has perfect accuracy. For
ForLoopToFunctional , the tool infers the most ne-grained
operations more than 90% of the time.
LambdaFicator has been successfully evaluated by the ES-
EC/FSE artifact evaluation committee and found to exceed
expectations. LambdaFicator , along with experimental data
and a demo, is available at:
http://refactoring.info/tools/LambdaFicator
http://www.youtube.com/watch?v=EIyAflgHVpU
2. MOTIV ATING EXAMPLES
We rst illustrate the motivation behind introducing lambda
expressions for parallelism. Fig. 1(a) shows a simple sequen-
tial loop from the ANTLRWorks project. The loop iterates
over ElementRule objects and resets each object. The pro-
grammer decides to execute this loop in parallel.
Fig 1(b) shows how the programmer would traditionally
refactor the original loop. She rst decides the amount of
parallelism (e.g., 4 parallel threads). Then she creates two
loops: the rst loop splits the work between the 4 paral-
lel threads by allocating a quarter of the iterations to each
worker thread. She encapsulates the parallel computation
inside an anonymous instance of Runnable . Then she starts
the threads. The second loop waits for all the worker threads
to nish their work. The programmer could have also ex-
pressed the parallel computation by subclassing Thread , but
in this case the code bloat would be even more severe.
Besides code bloat, there are several other issues with this
parallel implementation. First, the amount of parallelism is
hardcoded, so if she runs the code on a machine with 8
hardware threads, the code will utilize only 4. Second, just
because she split the iterations equally among the worker
threads, it does not mean that the running time of the 4
worker threads is equal. For example, suppose that the rules
visited by the rst worker thread have a much richer hier-p r i v a t e void r e s e t R u l e s ( ) f
f o r ( ElementRule r : p r o p e r t i e s . getRules ( ) ) f
r . resetHierarchy ( ) ;
g
g
(a) A sequential loop
p r i v a t e void r e s e t R u l e s ( ) f
i n t n = 4 ; // amount of p a r a l l e l i s m
Thread [ ] threads = new Thread [ n ] ;
f i n a l List <ElementRule >r u l e s =
p r o p e r t i e s . getRules ( ) ;
i n t s i z e = r u l e s . s i z e ( ) ;
f o r ( i n t i = 0 ; i <n ; i++)f
f i n a l i n t from = i s i z e / n ;
f i n a l i n t to = ( i + 1) s i z e / n ;
threads [ i ] = new Thread (new Runnable ( ) f
@Override
public void run ( ) f
f o r ( i n t j = from ; j <to ; j++)f
r u l e s . get ( j ) . resetHierarchy ( ) ;
g
g
g) ;
threads [ i ] . s t a r t ( ) ;
g
f o r ( i n t i = 0 ; i <n ; i++)f
tryf
threads [ i ] . j o i n ( ) ;
gcatch ( InterruptedException ex ) f
// p r i nt e r r o r message
g
g
g
(b) Parallel loop with Runnable and Thread (old style)
p r i v a t e void r e s e t R u l e s ( ) f
p r o p e r t i e s . getRules ( ) . par allelStr eam ( ) .
forEach ( ( ElementRule r )  >r . resetHierarchy ( ) ) ;
g
(c) Parallel loop with functional operations (new style)
Figure 1: Comparison between methods of paral-
lelization in Java.
archy than all other rules, so the rst worker thread will
spend a much longer time computing. Because the work is
not split evenly between the worker threads, the computa-
tion would take longer. This problem is referred in literature
as dynamic load balancing [13].
By taking advantage of the parallel functional operators
introduced in Java 8, the programmer can refactor the se-
quential loop using LambdaFicator . Fig 1(c) shows the nal
code, which is much more succinct than the previous parallel
code, and also benets from automatic dynamic load balanc-
ing. Notice that parallelStream returns a parallel view of the
collection, thus forEach will execute in parallel.
Next, we illustrate the problems and challenges of Anony-
mousToLambda andForLoopToFunctional by showing ex-
amples of refactorings that LambdaFicator performs.
Fig. 2(a) shows a common practice in any Java GUI,
adding a listener to a button. In this example, the developer
used an AIC, avoiding the hassle of creating a separate class
for a simple button action. Although an AIC is an improve-
ment over an external class, the syntax is still unnecessarily
verbose. The programmer must specify the name of the in-
terface, the method signature, and nally the body of the
method. Lambda expressions are a more concise solution.
With lambda expressions, the compiler can infer the type of
the interface as well as the method signature. The program-button . addActionListener (new ActionListener ( ) f
public void actionPerformed ( ActionEvent e ) f
ui . dazzle ( e . g e t M o d i f i e r s ( ) ) ;
g
g) ;
(a) An anonymous inner class
button . addActionListener ( ( ActionEvent e )  >f
ui . dazzle ( e . g e t M o d i f i e r s ( ) ) ;
g) ;
(b) Equivalent lambda expression
Figure 2: Example of AnonymousToLambda refactor-
ing, taken from Lambda Design Specication [6].
mer only has to specify the body of the method. Fig. 2(b)
shows a lambda equivalent to the AIC in Fig 2(a).
While Fig. 2 shows the most basic case, LambdaFicator
must analyze the code deeper to handle several special cases.
Fig. 3, adapted from the Apache Tomcat project, shows an
example where the basic conversion would introduce a com-
pilation error. The doAction method is overloaded and can
accept two dierent interfaces, both of which dene a single
method run() . A naive conversion results in an ambiguous
type for the lambda expression at the call site on line 1,
due to the method overloading. LambdaFicator adds a type
cast, disambiguating the type of the lambda expression.
This example also illustrates that LambdaFicator can make
the resulting lambda expression even more concise. If the
body of the lambda expression contains a single return state-
ment, LambdaFicator removes the return statement. These
special cases require additional analysis and would require
special attention to refactor manually. We discuss additional
special cases in Section 3.
Next we illustrate three examples of the ForLoopToFunc-
tional refactoring in Fig. 4. The rst example shows a loop
that iterates over GrammarEngine objects. The loop checks
whether importedEngines contains an element with a given
name. The loop lters out objects with a null name and
checks if the name equals the argument of the method for
each non- null name. Our refactored code makes the in-
tent explicit: it shows a non- null lter and returns true if
any element's name matches the grammarName . This example
illustrates how LambdaFicator chains operations together,
while expressing the semantics of each portion of the loop
explicitly. To perform this refactoring manually, a program-
mer would have to determine that the ifstatement followed
by a continue behaves like a non- null lter, and the return
true inside the ifstatement represents an anyMatch .
The second example also illustrates chaining operations
together, this time to compute map-reduce . In this example,
the loop iterates over ElementRule objects and sums up the
number of errors for each object that has errors. In order
for the programmer to infer this chaining manually, she has
to notice that the compound assignment represents a map-
reduce operation, which may not be immediately obvious.
In this transformation we used method references, a new
feature in Java 8, to refer to the sumoperation on Integer .
The third example illustrates additional challenges of chain-
ing operations. This loop iterates over Entry objects, and
performs several checks before it adds an object to a collec-
tion. In this example the programmer would need to rea-
son about the ow of data between statements to determine1 String sep = doAction (new PrivilegedAction ( ) f
2 public String run ( ) f
3 return System . getProperty ( " f i l e . separator " ) ;
4g
5g) ;
6
7 String doAction ( PrivilegedAction action ) f. . .g
8 String doAction ( ExceptionAction action ) f. . .g
(a) An AIC1 String sep = doAction ( ( PrivilegedAction )( ) >
2 System . getProperty ( " f i l e . separator ")
3 ) ;
4
5
6
7 String doAction ( PrivilegedAction action ) f. . .g
8 String doAction ( ExceptionAction action ) f. . .g
(b) Lambda conversion requiring a type cast
Figure 3: Example of ambiguous lambda expression due to method overloading. LambdaFicator adds a type
cast to disambiguate the type of the lambda expression on line 1. In addition, LambdaFicator discarded the
{}and return tokens to make the lambda expression more concise.
whether operations can be chained. At rst glance, this
loop appears to be a chain of filter ,map,filter ,forEach .
However, the second filter operation lters out ClassLoader
objects but the last statement needs a reference to the entry
object; this would not be available from this filter , there-
fore, these two operations cannot be chained. Identifying
when it is possible to chain operations is non trivial.
3. AnonymousToLambda REFACTORING
This section presents the AnonymousToLambda refactor-
ing. We explain the tool's workow, how lambda expressions
are implemented in Java 8, the preconditions that determine
when a conversion can take place, and special cases that dif-
fer from the basic conversion.
3.1 Workï¬‚ow
The tool provides two main workow options, a \Quick
Hint" option and a batch option.
The quick hint option scans the le that is open in the ed-
itor in real-time. If LambdaFicator nds a valid conversion,
it underlines the code and displays a hint in the sidebar indi-
cating this AIC can be converted into a lambda expression.
If the programmer clicks the hint indicator, LambdaFicator
applies the refactoring. This option allows the programmer
to refactor without deviating from her normal workow.
The batch option allows the programmer to invoke the
refactoring automatically by selecting any le, folder, or
project open in the IDE. LambdaFicator can automatically
apply the refactoring on all les or optionally generate a pre-
view which lists the valid conversions and provides ne-grain
control over which conversions should take place. With the
batch option, LambdaFicator can discover and apply hun-
dreds of refactorings in a matter of seconds.
3.2 Lambda Expression Implementation
In order to illustrate how LambdaFicator refactors AIC
to lambda expressions, we rst describe how lambda ex-
pressions are implemented in Java 8 and how they dier
from lambda expressions in other programming languages.
Many languages, Python for example, allow lambda expres-
sions to be dened as follows: sum = lambda x, y: x + y .
This expression creates a function sumwhich takes the ar-
guments xand yand returns the result of x + y . Most type
systems, including Python and C#, denote lambda expres-
sions with a special Func type. While this implementation is
highly exible, the designers of the Java language decided it
would introduce unneeded complexity to the Java type sys-
tem [6]. As an alternative, the designers chose to represent
lambda expressions as an instance of an interface deninga single method, i.e., a functional interface. A lambda ex-
pression in Java can be dened as follows: BinaryOperator
sum = (x,y) -> x + y , where BinaryOperator is a functional
interface dening a single method op. This function could
be invoked by calling sum.op(2, 3) . This representation of
lambda expressions is not as exible or concise as the func-
tional equivalent, but it ts well with the Java type system.
3.3 Preconditions
Although lambda expressions are intended as a more con-
cise alternative to AIC, they are not a complete replacement.
There are several preconditions that LambdaFicator checks
before refactoring an AIC into a lambda expression. These
preconditions are inherent to how lambda expressions are
implemented in Java, not limitations of our tool.
(P1) AIC must instantiate from an interface. Instances of
abstract or concrete classes cannot be converted to lambda
expressions.
(P2) AIC must have no elds, and declare only one method.
A lambda expression represents a single anonymous func-
tion; therefore, an AIC with multiple methods can not be
converted to a single lambda expression.
(P3) AIC must not have references to this orsuper . In
a lambda expression, this and super are lexically scoped,
meaning they are interpreted just as they would be in the
enclosing environment, e.g., as if they appeared in the state-
ment before the lambda expression [6]. However, in an AIC
they refer to the inner class itself.
(P4) AIC must not declare a recursive method. In order to
perform the recursive call, we must obtain a reference to the
anonymous function. While LambdaFicator could perform
this refactoring, this could introduce unneeded complexity
into the code and harm understandability.
3.4 Special Cases
After checking the preconditions, LambdaFicator further
analyses the code to properly refactor several special cases:
(S1) Normally the body of a lambda expression is a block
containing several statements. However, if the block con-
sists of just a single return statement, the block and return
keyword can be omitted. In these cases, LambdaFicator will
remove the {}and return tokens. Fig. 3 shows an example.
This change allows the lambda to become even more concise.
(S2) In most cases, the compiler can infer the type of the
lambda expression from the surrounding context. But there
are several cases which require LambdaFicator to add a cast
in order for the type to be inferred. If the original AIC is
being assigned to a reference of its supertype (e.g., a par-
ent interface or type Object ),LambdaFicator adds a castc l a s s GrammarEngineImpl implements GrammarEngine f
. . .
boolean isEngineExisting ( String grammarName) f
f o r ( GrammarEngine e : importedEngines ) f
i f ( e . getGrammarName ( ) == n u l l ) continue ;
(1) i f ( e . getGrammarName ( ) . equals (grammarName ) )
return true ;
g
return f a l s e ;
g
g
c l a s s EditorGutterColumnManager f
. . .
i n t getNumberOfErrors () f
i n t count = 0 ;
f o r ( ElementRule r u l e : getRules ( ) ) f
(2) i f ( r u l e . hasErrors ( ) )
count+=r u l e . getErrors ( ) . s i z e ( ) ;
g
return count ;
g
g
c l a s s StandardHost f
. . .
List<String >findReloadedContextMemoryLeaks () f
List<String >r e s u l t = new ArrayList <String >();
f o r (Map. Entry <ClassLoader , String >entry :
childClassLoaders . entrySet ( ) )
i f ( i s V a l i d ( entry )) f
(3) ClassLoader c l = entry . getKey ( ) ;
i f ( ! ( ( WebappClassLoader ) c l ) . i s S t a r t ( ) )
r e s u l t . add ( entry . getValue ( ) ) ;
g
. . .
g
g
(a)1 c l a s s GrammarEngineImpl implements GrammarEngine f
2 . . .
3 boolean isEngineExisting ( String grammarName) f
4
5 return importedEngines . stream ( )
6 . f i l t e r ( e  >e . getGrammarName ( ) != n u l l )
7 . anyMatch ( e  >
8 e . getGrammarName ( ) . equals (grammarName ) ) ;
9
10g
11g
12 c l a s s EditorGutterColumnManager f
13 . . .
14 i n t getNumberOfErrors () f
15
16 return getRules ( ) . stream ( )
17 . f i l t e r ( r u l e  >r u l e . hasErrors ( ) )
18 . map( r u l e  >r u l e . getErrors ( ) . s i z e ( ) )
19 . reduce (0 , I n t e g e r : : plus ) ;
20
21g
22g
23 c l a s s StandardHost f
24 . . .
25 List <String >findReloadedContextMemoryLeaks () f
26 List <String >r e s u l t = new ArrayList <String >();
27 childClassLoaders . entrySet ( ) . stream ( )
28 . f i l t e r ( entry  >i s V a l i d ( entry ) )
29 . forEach ( entry  >f
30 ClassLoader c l = entry . getKey ( ) ;
31 i f ( ! ( ( WebappClassLoader ) c l ) . i s S t a r t ( ) )
32 r e s u l t . add ( entry . getValue ( ) ) ; g) ;
33
34 . . .
35g
36g
(b)
Figure 4: Example of ForLoopToFunctional refactoring. In column (a) you can nd the original version of the
program and in column (b) the refactored one. The rst two examples are extracted from ANTLRWorks and
the last one is adapted from Apache Tomcat
to help the compiler determine which interface the lambda
expression actually represents.
(S3) Similarly, if an AIC appears as an argument in an
invocation of an overloaded method, the resulting lambda
expression could be ambiguous. Consider the example in
Fig. 3. Without a cast indicating the proper interface, the
compiler has no way to determine which interface the lambda
expression represents. LambdaFicator detects such cases
and adds a cast to the original AIC, disambiguating the
resulting code.
(S4) Finally, special attention must be paid to variable
shadowing. Variable shadowing occurs when a variable de-
clared in the method body or parameters of an AIC has the
same name as a variable declared in the enclosing scope. In
anAIC, the inner local variable declaration simply hides,
or shadows, the outer variable. However, a lambda expres-
sion is not allowed to shadow a variable that is declared in
the enclosing scope. In order to prevent this, LambdaFica-
torgenerates a unique variable name to disambiguate the
variables inside the lambda that shadow outer variables.
4. ForLoopToFunctional REFACTORING
Next we present the ForLoopToFunctional refactoring.
First we introduce the functional operations from Java 8
that we are currently supporting. Then we introduce the
set of preconditions that ensure the refactoring is safe. Last
we present an algorithm that infers the operator chaining
and ensures the chaining is correct.Stream<R> map(Function<? super T, ? extends R>
mapper)
Stream<T> filter(Predicate<? super T> predicate)
T reduce(T identity, BinaryOperator<T> reducer)
void forEach(Consumer<? super T> consumer)
boolean anyMatch(Predicate<? super T> predicate)
boolean noneMatch(Predicate<? super T> predicate);
Figure 5: Method signatures of Java 8 operations.
4.1 New operations in Java 8
Java 8 introduces interface Stream<T> [7]. The methods
introduced in it are similar in form and semantics to func-
tional programming-style list operations. LambdaFicator
currently supports map,filter ,reduce ,forEach ,anyMatch and
noneMatch . We will refer to these methods as operations. We
show the method signatures of these operations in Fig. 5.
There are some fundamental semantic dierences between
operations. The rst two operations, mapand filter , are lazy
operations , i.e., they get executed only when their result is
needed. The filter operation returns a new Stream<T> con-
taining only the elements that satisfy the Predicate . The
mapoperation also returns a new Stream where each elementis mapped from the original Stream . The last four opera-
tions are eager operations , i.e., they execute when called.
The anyMatch and noneMatch operations use short-circuiting
to stop processing once they can determine the nal result.
For example, anyMatch will examine elements on Stream<T>
only until it nds one for which Predicate istrue.
4.2 Preconditions
Although many enhanced forloops can be converted to
the new functional-style operations, these operations are not
complete replacements. Lambda bodies cannot contain ref-
erences to local variables that are not nal or eectively-
nal. A variable is eectively nal if its initial value is never
changed. Therefore, loops that reference non-eectively nal
variables generally cannot be converted to operations using
lambda expressions. The same holds for loops containing
branching statements, such as return ,break , and continue .
However, LambdaFicator takes advantage of the properties
ofanyMatch and noneMatch to refactor some loops contain-
ing return statements, as shown in example 2 in Fig. 4.
LambdaFicator also restructures the body of the loop to
eliminate continue statements in a preprocessing step.
The following preconditions are due to inherent dierences
between loops and operations, not limitations of our tool.
LambdaFicator checks these preconditions before applying
theForLoopToFunctional refactoring:
(P1) The enhanced forloop should be iterating over an
instance of java.util.Collection , rather than an array , in
order to be able to obtain a stream .
(P2) The body of the initial forloop does not throw checked
exceptions. The lambda expression signature used by the
operations does not have a throws clause; therefore, these
loops cannot be refactored.
(P3) The body of the initial forloop does not have more
than one reference to local non-eectively-nal variables de-
ned outside the loop. Loops having only one outside refer-
ence can be refactored if the side-eect can be externalized
to a reduce operation, according to the heuristic in Tab. 1.
(P4) The body of the initial forloop does not contain any
break statements. The semantic of break is inherent to a loop
and cannot be handled by chaining operations together.
(P5) The body of the initial forloop does not contain more
than one return statement. LambdaFicator can deal with
loops with only one return statement as long as they return
aboolean literal and LambdaFicator can infer that they can
be refactored to an anyMatch ornoneMatch operation.
(P6) The body of the initial forloop does not contain any
labeled continue statement. This would introduce a goto
point which cannot be handled by chaining operations.
4.3 Algorithm
When performing the ForLoopToFunctional refactoring,
LambdaFicator needs to consider a set of opposing con-
straints. First, LambdaFicator must determine what opera-
tion each statement in the forloop represents. This involves
reasoning about statements that branch the control ow and
introduce side eects on local variables.
LambdaFicator also has to consider several dierences
between the original loop and the new operations. A lo-
cal variable declared in the original loop is available to all
subsequent statements. However, variables declared in a
lambda expression are now local to that lambda. LambdaFi-
cator has to build operations in a pipeline fashion such thatit maintains access to needed references. In some cases,
LambdaFicator must merge operations to ensure the vari-
able references are preserved. This is due to the constraint
that operations can return only one value.
On the other hand, there are several ways of chaining oper-
ations when refactoring a loop. LambdaFicator chooses the
most ne-grained operations in order to make the semantic
of each portion of code as explicit as possible. This gives
the programmer ner control to specify for each operation
whether it should execute sequentially or in parallel .
Finally, forloops are inherently eager constructs; the refac-
tored code has to preserve the semantics of the initial code,
therefore it has to get executed eagerly. LambdaFicator
must ensure any lazy operations get executed by requiring
that the last operation in the chain be an eager operation ;
this will force the lazy operations to execute as needed, i.e.,
just before the eager operation.
Below is an overview of the chaining inference algorithm:
Step 1: Break code into potential operations.
Step 2: Annotate each potential operation with vari-
able availability information.
Step 3: Merge operations in order to maintain access
to needed references.
Step 4: Chain the operations.
In step 1, the algorithm marks each statement as a prospec-
tiveoperation. Prospective denotes that this is not the nal
operation, since some operations need to be merged later to
meet variable availability constraints. By default, it marks
all statements (but ifstatements) as mapoperations. For
ifstatements that have no else branch and no statements
after them, the algorithm marks them as filter operations.
Finally, the algorithm marks the last statement as a prospec-
tive eager operation.
In step 2, the algorithm annotates each prospective oper-
ation with variable availability information. We introduce
the notions of Available Variables and Needed Variables of
aProspective Operation .
Definition 1.The set of available variables of a Prospec-
tive Operation ,AVPO, is:
AVPO=F[LPO[fLMethnLLoopgWhere:
Fis the set of all elds declared in the current class or
inherited from superclasses and all visible elds from
the imported classes.
LPOis the set of local variables declared in the Prospec-
tive Operation
LMeth is the set of all local variables of the current
method
LLoop is the set of local variables declared within the
loop.
Definition 2.The set of needed variables of a Prospec-
tive Operation ,NVPO, is: NVPO=UPOnAVPO
Here UPOis the set of all variables used in the Prospective
Operation .AVPOis dened above.
In step 3 the algorithm uses the sets generated in step
2 to determine if operations can be chained or need to be
merged. To do so, it iterates the prospective operationsbottom up. To determine if two operations, OandO0can be
chained ( O.O0), the algorithm checks whether the variable
needed in O0can be provided by the previous operation O,
as expressed:
Proposition 1. Prospective Operation Ocan be chained
withO0(O.O0) ijNVO0j= 1andNVO0(AVO[NVO)
If the algorithm cannot chain two operations, it merges all
previously built operations into a single operation to ensure
variable availability. When merging operations OandO0
intoO00, the algorithm computes the availability sets as:
AVO00=AVO[AVO0 NVO00=fNVO[NVO0gnAVO00
In step 4 LambdaFicator determines the correct eager op-
eration . Afterwards it builds the chain from end to start by
prepending the operations.
Finally, LambdaFicator prepends the expression that re-
turns the Stream to the chain. If the last operation is a
reduce ,anyMatch , or noneMatch ,LambdaFicator might need
to assign the result to a variable or return it directly.
Next, we illustrate the algorithm by applying it to ex-
ample 3 from Fig. 4. LambdaFicator rst checks that all
the preconditions are met. No Exception is thrown from the
loop, and there are no return ,break , orcontinue statements.
LambdaFicator nds a reference to result but it is able to
determine that the variable is only initialized; therefore, it
iseectively nal and usable from a lambda expression.
The chaining algorithm begins by breaking the list of orig-
inal statements into Prospective Operations . It does this by
iterating over the list of statements and checking if each
statement conforms to the restrictions of a given operation.
It marks the rst statement as a Prospective Filter since it
is an ifwith no else branch. It marks the second state-
ment as a Prospective Map since it is not an ifstatement.
It marks the third statement as Prospective Filter , and the
last statement automatically becomes Prospective Eager .
Next, the algorithm computes the two sets of available and
needed variables for each Prospective Operation and anno-
tates each Prospective Operation with this information.
The algorithm iterates on the four Prospective Operations
identied in the rst step. It starts iterating from bottom
up, in reversed control ow order. LambdaFicator nds that
the last operation cannot be chained with the previous; this
is because the last operation uses an entry and the prospec-
tive lter passes down a ClassLoader object. Therefore, it
merges them into a new operation and recomputes the vari-
able availability sets. In the next iteration, it nds that the
current operation, obtained through merging, needs more
than one variable from the upstream operation, i.e., cland
entry , requiring LambdaFicator to merge the two Prospec-
tive Operations . In iteration three, LambdaFicator nds
that the Prospective Operations can be chained; therefore,
it does not merge the operations.
In the last step, the algorithm takes the last Prospective
Operation and, using the heuristics in Tab. 1, determines
that the last operation is a forEach . Because the next block
is aProspective Filter ,LambdaFicator determines that the
rst operation is a filter operation.
Note: LambdaFicator does not split synchronized blocks
and try-catch blocks between multiple operations in order
to avoid introducing races or changing semantics. This be-
haviour is omitted during the presentation of the algorithm,
butLambdaFicator ensures the whole synchronized block or
try-catch block is not split across operations.Table 1 Heuristics to infer the last operation in the chain
Operator Heuristic
reduce The Prospective Operation contains one refer-
ence to a non-nal local variable dened outside
the loop and the Prospective Operation con-
tains only one control ow path in it and it
contains a write through a compound assign-
ment to that local variable or a unary postx
or prex increment/decrement. A compound
assignment can be +=, -=, *=, /=, %=, j=,
&=,=,=.
anyMatch The Prospective Operation has only one state-
ment, which is a return true .
noneMatch The Prospective Operation has only one state-
ment, which is a return false .
forEach The Prospective Operation does not have any
reference to non-eectively-nal local variables
dened outside the loop and no return state-
ments.
5. EV ALUATION
Research Questions . To determine if LambdaFicator is
useful, we answer the following research questions:
Q1. Applicability: How applicable are the refactorings?
Q2. Value: Do the refactorings improve code quality?
Q3. Eort: How much programmer eort is saved by
LambdaFicator when refactoring?
Q4. Accuracy: How accurate is LambdaFicator when
performing the refactoring in batch mode?
Q5. Safety: IsLambdaFicator safe?
5.1 Experimental Setup
In order to empirically evaluate the usefulness of LambdaFi-
cator , we ran it on 9 widely used open-source projects. We
applied AnonymousToLambda refactoring 1263 times, and
ForLoopToFunctional 1709 times. These case studies give
more condence that the proposed algorithms and imple-
mentations generalize to real-world situations.
The left-hand side of Fig. 6 shows the size of each project
in terms of non-empty non-comment source lines of code
(generated using David A. Wheeler's SLOCCount [5]).
For each project, we applied the AnonymousToLambda
refactoring to all AIC andForLoopToFunctional refactor-
ing to all enhanced-for loops (the enhanced-for syntax was
introduced by Java 5). We used the batch execution mode
ofLambdaFicator .
We recorded several metrics for each project. To measure
the applicability, we count how many code fragments met
the refactoring preconditions and thus can be refactored by
LambdaFicator . We also report the number of times each
precondition fails.
To measure the value of AnonymousToLambda refactoring
on the code quality, we report the reduction in lines of code.
However, simply comparing reduced SLOC could produce
misleading results: some programmers use dierent format-
ting options (e.g., curly braces on new lines) or using name
identiers of dierent length. To eliminate these eects, wealso calculated the percentage decrease in the number of
Abstract Syntax Tree (AST) nodes:
nodesInAIC nodesInResultingLambda
nodesInAIC100
The value of ForLoopToFunctional refactoring on code
quality can be best gauged if we compared our refactored
code with the code refactored to use Threads and Runnable .
However, in the absence of a refactoring that converts se-
quential loops to parallel loops with Thread s, we could not
measure this. By comparing Fig. 1(b) and Fig. 1(c), it is
obvious that our refactoring signicantly reduces the code
size and makes the code more readable. Instead, we report
how many operations were inferred from the original loops.
We also report usage of individual operations and of chained
operations, along with the average length of chains.
To measure the eort that a programmer would spend
to refactor the project manually, we report the number of
les that are modied by the refactoring. We also report
the number of modied SLOC, as counted by the standard
di tool from Unix (we congured the tool to ignore white
spaces), and the number of special cases that require extra
attention. These numbers estimate the programmer eort
that is saved when refactoring with LambdaFicator .
To measure the accuracy of LambdaFicator we will use
standard metrics from information retrieval, such as precision
and recall . In our case, precision measures how many of
the refactorings performed with LambdaFicator match the
best, most ne-grained refactorings that an expert can ap-
ply. Recall measures how many of the possible refactorings
LambdaFicator successfully performed. Since our corpus
is large, we sampled 10% of the forloops in the original
code. To create the ground truth set, we carefully ana-
lyzed for each input construct whether the refactoring can
be applied. Thus, we created two sets: ShouldApply man,
and ShouldNotApply manwhich contain tuples of the form
hin;outi, where inrepresents the input code, and outrepre-
sents the expected refactored code. Then we ran LambdaFi-
cator on the sampled inputs and created two sets: Applied tool
and NotApplied toolwhich also contains tuples of the same
form. Note that in ShouldNotApply manand NotApplied tool
the tuples are of the form hin;ini. We dene the Precise
transformations set as:
Precise =ShouldApply man\Applied tool,
and the Imprecise transformations set as:
Imprecise =fhin;outi j h in;outi2Applied tool;
9out0:out0! =out;hin;out0i2ShouldApply mang,
and the missed transformations set:
Missed =ShouldApply mannApplied tool
We dene precision and recall using set cardinality:
Precision =jPrecisej
jPrecisej+jImprecisej(1)
Recall =jPrecisej
jPrecisej+jMissedj(2)
To answer the safety question, we ran extensive test suites
(4360 tests) before and after all refactorings that we applied
on our corpus. We used projects that had extensive tests1to
help us conrm that the refactorings did not break the sys-
tems. The refactorings did not cause any new failures. We
1jEdit does not contain JUnit tests, and for Hadoop/Tomcat
none of the tests run under Java 8also carefully inspected 10% of all refactored elements, and
found that all refactorings we sampled preserved semantics.
5.2 Results
5.2.1 AnonymousToLambda Refactoring
Figure 6 tabulates results for the AnonymousToLambda .
Applicability: Column 3 shows that Java projects use
AIC extensively. 55% of all AIC met the refactoring pre-
conditions. AIC that were not converted failed a precondi-
tion, shown in columns P1-P4. The most commonly failed
preconditions were not instantiating from an interface (37%
ofAIC) and declaring multiple methods or elds (18% of
AIC). Notice that the percent of AIC that could be con-
verted in each project had a high variability, with a stan-
dard deviation of 23.6%. Projects like ANTLRWorks (78%
converted) and Apache Ivy (82% converted) heavily uti-
lized functional interfaces, while others like JUnit (13% con-
verted) and Hadoop (26% converted) did not. This shows
that lambda expressions do not provide a complete replace-
ment for AIC, but still have a high level of applicability.
Value: The data shows that our AnonymousToLambda
refactoring produces more concise code. The SLOC Red.
column shows the reduction in source lines of code after the
refactoring. In total, the AnonymousToLambda refactoring
reduced SLOC by 2213 lines, or 3.19 lines per refactoring.
The AST Red. column shows that the refactoring reduces
AST nodes by 52.8% on average. The highest reductions
per refactoring were obtained in the Hadoop project. We
examined this project and found that many refactored AIC
contained one method with a single return statement that
was signicantly compacted after the refactoring.
Eort: A total of 274 les were modied by applying
the refactoring, an average of 30.4 les per project (see
Files Mod. column). Notice that the refactorings were
not strongly clustered, with an average of just 2.5 refac-
torings per le. Had the programmer refactored manually,
she would have had to jump across many les.
In total, the refactoring modied 3707 SLOC, with an
average of 411.9 SLOC per project (see SLOC Mod. col-
umn). Notice that many of these changes are non-trivial.
Columns S1-S4 show special cases, such as disambiguating
shadowed variables or inferring the types for lambda expres-
sions, which require special attention from the programmer.
These special cases represent 29% of all refactorings.
By contrast, the automated AnonymousToLambda refac-
toring takes an average of just 11.3 seconds per project.
These results show that LambdaFicator can save a lot of
programmer eort.
Accuracy: By manually checking 10% of the AIC we found
that LambdaFicator transformed all the AIC in a precise
manner. We also found that LambdaFicator didn't miss
any refactoring. The precission and the recall were 100%
for the AnonymousToLambda refactoring.
5.2.2 ForLoopToFunctional Refactoring
Figure 7 shows the results for the ForLoopToFunctional
refactoring. We omitted the results for the projects that did
not have any enhanced forloops.
Applicability: On average, LambdaFicator successfully
refactored 46.02% of the enhanced forloops present in our
code corpus. The precondition that was not met most of-
ten (41% of the time) was P1. This is due to the fact thatApplicability Value Eort
Project SLOC Tests #AIC Conv. Conv.
[%]P1 P2 P3 P4 S1 S2 S3 S4 SLOC
Red.AST
Red.Files
Mod.SLOC
Mod.Time
[s]
ANTLR+Works v1.5.1 97795 674 151 118 78% 27 14 4 0 2 8 0 0 243 52.6% 41 513 9
Ant v1.8.4 129053 1637 104 38 37% 50 22 0 0 14 0 1 1 125 52.3% 21 203 15
Ivy v2.3.0 68193 944 107 88 82% 11 8 2 0 10 1 0 5 203 48.4% 27 387 9
Tomcat v7.0.29 221321 - 153 87 57% 53 32 1 0 29 3 57 0 368 52.4% 37 584 17
FindBugs v2.0.2 121988 163 338 174 51% 124 90 0 0 18 0 1 0 507 44.6% 53 853 17
FitNesse v20121220 63188 250 102 36 35% 61 23 0 0 11 0 0 18 99 45.8% 19 179 8
Hadoop v0.20.3 307016 - 31 8 26% 23 5 0 0 7 0 2 0 40 66.2% 8 60 8
jEdit v5 114899 0 201 134 67% 59 16 2 0 2 4 0 0 593 53.4% 61 873 13
JUnit v4.11 10443 692 76 10 13% 63 23 0 0 7 0 0 1 35 59.5% 7 55 6
Total 1133896 4360 1263 693 55% 471 233 9 0 100 16 61 25 2213 52.8% 274 3707 102
Figure 6: Lambda Conversion Results. Failed Preconditions - P1: Not an interface, P2: Has multiple methods
or has eld, P3: Has reference to 'this' or 'super', P4: Has recursive call. Special Cases - S1: Block and
return were omitted, S2: Has shadowed variable, S3: Has ambiguous method overload, S4: Has assignment
to supertype. AST Red. - Average percent decrease in AST nodes per conversion.
Applicability Value Eort
Project #for loops %Refactored P1 P2 P3 P4 P5 P6 #forEach
#anyMatch
#noneMatch
#reduce
#map
#filter
#Singleton #Chains Avg chain length #Files Mod. #SLOC Mod. Time [s]
ANTLR 589 60.10% 78 15 102 44 56 18 322 17 4 10 117 93 216 138 2.51 140 2293 16
FitNesse 242 48.34% 79 28 22 1 25 0 98 5 10 4 35 17 83 34 2.52 83 3336 8
Hadoop 1772 28.04% 800 600 476 130 77 27 453 9 4 30 198 65 330 167 2.56 196 2654 36
Tomcat 425 44.70% 149 42 88 29 45 3 173 1 15 1 151 22 129 61 3.83 83 1283 16
jEdit 190 32.10% 82 10 51 13 22 6 61 0 0 0 23 14 37 24 2.54 33 401 7
FindBugs 1075 40.09% 359 131 226 79 114 32 402 14 3 12 140 82 295 136 2.63 182 2346 16
jUnit 109 54.12% 27 17 9 1 9 0 48 6 3 2 12 5 48 11 2.54 32 277 4
Total 4402 46.02% 1574 843 974 297 348 86 1557 52 39 59 676 298 1138 571 2.72 717 12313 97
Figure 7: ForLoopToFunctional conversion results. Failed Preconditions: P1: Not iterating over Collection , P2:
Throwing exception, P3: References to outer non-nal variables, P4: Contains break, P5: Contains return P6:
Contains labeled continue #Singleton shows the number of refactorings formed that have only one operator
#Chains shows the number of refactorings composed of more than one operator.
the stream method is available in Collection and not in ar-
ray. The second most frequent failed precondition was P3.
It checks for outer non-eectively-nal local variables refer-
enced from within the loop. This result makes sense: code
written in an imperative style would inevitably have side ef-
fects incompatible with the functional style. LambdaFicator
still managed to refactor over 46% of the loops.
Value: The data shows the most common operation is
forEach . This makes sense since this operation has the most
relaxed preconditions. However, operations other than forE-
achrepresent 42% of all operations. These operations have
descriptive names which convey intent more explicitly than
the original code. Additionally, 33% of the operations were
chained, with an average chain length of 2.72. These convey
intent with a ner granularity than in the original code.
Eort: The data shows that on average per project the
developer would need to edit 102 les and change 1759 lines.
We nd that the refactoring are spread across les, with a
rate of 2.3 loops refactored per le. The analysis is non-
trivial. For example, column P3 shows that the program-
mer would have had to nd 974 references to non-eectively
nal variables and determine if they can be converted to a re-
ducer. The programmer would have to reason about how to
chain lazy operators with eager ones and make values avail-
able in a pipeline fashion 33% of the time. LambdaFicatoris fast. Even on the largest project, with over 300K lines of
code, LambdaFicator can determine in half a minute if the
refactorings are safe and apply them on the whole project.
Accuracy: When inspecting 10% of the loops LambdaFi-
cator has refactored, we found that it had a precision of
0.9. The cases when the refactoring is not precise enough
are due to the fact that tool always tries to build the most
ne grained chain. The inspection showed that in 10% of
the cases a professional might chain operations in a dierent
way. We didn't nd any refactoring that changed semantics
- only refactorings that a human might do dierently (e.g.,
merge two subsequent maps). By considering also the loops
that were not transformed by LambdaFicator we found that
the recall of ForLoopToFunctional is 0.92. The misses are
either due to operations that could be used { like minand
max(and are trivial extensions to LambdaFicator ), or the re-
strictiveness of the reduce heuristic which can be improved.
Overall, we found that most of the time LambdaFicator in-
fers the most precise chain a human could infer.
5.3 Threats to Validity
Construct Validity: Can we measure development eort
by counting size and clustering of changes? Ideally, we
would have observed developers while they refactor. How-
ever, given the cutting edge nature of lambda expressionsin Java, we could not nd such developers. Thus, we chose
to use indirect metrics. Notice that refactoring changes are
non-trivial, and require reasoning about preconditions (see
Sec. 3.3, 4.2). The number of les changed is relevant be-
cause it shows refactorings are widespread, so a developer
would spend time searching for refactoring opportunities.
Internal Validity: How did we mitigate bias during man-
ual inspection? We randomly sampled from the set of for
loops and AICs in each project. Before looking at the results
from LambdaFicator , we classied the sampled exemplars as
refactorable or unrefactorable, and we manually performed
the refactorings, thus creating the ground truth. The au-
thors are expert users of Java lambda expressions.
External Validity: Do our results generalize? We choose
a diverse corpus of 9 widely used open source projects to-
taling over 1 million SLOC. They are developed by very
dierent entities, by large organizations or researchers, and
covering domains such as GUIs, compute-intensive servers,
IDEs, testing tools, etc.
Reliability: Is our evaluation reliable? The corpus is avail-
able on our webpage. LambdaFicator is open-source:
http://refactoring.info/tools/LambdaFicator/ .
6. DISCUSSION
With respect to the type for the arguments of the lambda
expression, LambdaFicator has two modes of operation: it
can make the types of the arguments explicit, or it can omit
them since they can be inferred by the compiler. While
omitting the types makes the code more succinct, there is
value in making the types explicit. Pankratius et al. [21] nd
that explicit type declarations results in code that is more
readable and maintainable.
Our ForLoopToFunctional refactoring takes as input an
enhanced-for loop. We have developed a refactoring (that
ships with the ocial release of the Eclipse IDE [4]) to con-
vert old style forloops into enhanced-for . This refactoring
is an enabler for ForLoopToFunctional refactoring.
One could ask whether it is protable to convert Java se-
quential loops to the functional form that can execute in
parallel. In our previous work [10], we have shown that
dynamically-balanced loop parallelism (similar with the one
supported by Java 8 collections) produces close to linear
speedup all the way up to 24 cores. The ocial perfor-
mance tests accompanying the Java 8 collections also show
solid speedups up to 20x on 32-way parallelism. From the
code produced by the ForLoopToFunctional refactoring,
one simply has to add the parallelStream to enable paral-
lel execution. To determine whether it is safe to run the
loop iterations in parallel, we refer the reader to our static
data-race detector [24] specialized for Java loops.
7. RELATED WORK
Several empirical studies describe the advantages of using
functional features in imperative programming languages.
Okur and Dig [19] found that functional operators provided
in .NET, equivalent to those being introduced in Java 8, are
widely used when writing parallel applications. LambdaFi-
cator meets this need by transforming serial, imperative
constructs into functional constructs, which are enablers for
parallelism. Pankratius et al. [21] show that programmers
employ a mix of functional and imperative styles when writ-
ing parallel applications.Ericksen [12] reports on Scala's mix of functional/imper-
ative style used in large commercial applications like Twit-
ter. Hundt [14] compared C++/Java/Go/Scala implemen-
tations using Scala's equivalent map, filter, forEach oper-
ations. He reports that Scala's concise notation and pow-
erful language features allowed for the least complex code.
LambdaFicator enables developers to use these powerful fea-
tures. Oliveira and Cook [20] present methods and advan-
tages of using a functional style of programming and ways
of combining it with the object-oriented style in order to
reduce abstraction overload.
Prokopec et al. [23] show that higher-order functions can
simplify the programming interface of data-ow abstractions
in the context of parallel Collection s. Odersky [18] shows
how Scala's collections framework, which has the equivalent
functional operations coming in Java 8, simplies the use
of parallelism when iterating over Colection s. Prokopec et
al. [22] present and evaluate a framework to build parallel
collections (similar with Java 8) and report good speedups.
LambdaFicator enables Java programmers to benet from
all the advantages reported in these studies.
Recently, there is a surge of interest [15{17,25] in support-
ing refactorings in functional languages. However, LambdaFi-
cator is the rst refactoring tool that helps programmers
retrot functional features into an imperative program.
8. CONCLUSIONS
This paper presents the analysis, design, implementation,
and evaluation of two refactorings that enable the Java pro-
grammer to retrot existing imperative code with two func-
tional features: lambda expressions and functional opera-
tions. Our empirical data shows that AIC and forloops
compatible with functional style are pervasive. Thus, Java
programmers have ample opportunities to use functional
language features.
There exists an interdependence between language fea-
tures, adoption of these features in practice, and tools. On
one hand, tools do not automate features that are rarely used
in practice. On the other hand, language features are not
used in practice if they do not have tool automation. Once
we break the chicken-and-egg stalemate, tools and adoption
are in a chain reaction with a positive feedback.
The concomitant release of lambda expressions in Java
8 and our release of LambdaFicator may be the rst time
when language features and refactoring tools are released
together. This could be the trigger for the chain reaction
that will lead to a wide adoption of functional/imperative
hybrid, thus making the programmer more productive.
9. ACKNOWLEDGMENTS
Alex Gyori and Lyle Franklin conducted this research while
being undergrad summer interns at the Information Trust
Institute at UIUC, under the supervision of Danny Dig. The
authors would like to thank Marius Minea, Darko Marinov,
Milos Gligoric, Stas Negara, Mihai Codoban, Caius Brinde-
scu, Yu Lin, Krzysztof Zienkiewicz, Nick Chen, Qingzhou
Lou, and the anonymous reviewers for valuable feedback on
earlier drafts of this paper. This research is partly funded
through NSF CCF-1213091 and CCF-1219027 grants, a gift
grant from Intel, and the Intel-Illinois Center for Parallelism
at UIUC. The Center is sponsored by the Intel Corporation.10. REFERENCES
[1] FluentIterable. http://docs.guava-libraries.
googlecode.com/git/javadoc/com/google/common/
collect/FluentIterable.html .
[2] Intel Thread Building Blocks For Open Source.
http://threadingbuildingblocks.org/ .
[3] Parallel LINQ. http://msdn.microsoft.com/en-us/
library/dd460688.aspx .
[4] Quick-assist to convert for to enhanced-for.
http://archive.eclipse.org/eclipse/downloads/
drops/R-3.1-200506271435/eclipse-news-all.
html#part2 .
[5] SLOCCount. http://www.dwheeler.com/sloccount/ .
[6] State of the lambda. http://cr.openjdk.java.net/
~briangoetz/lambda/lambda-state-4.html .
[7] State of the lambda: Collections edition.
http://cr.openjdk.java.net/~briangoetz/lambda/
collections-overview.html .
[8] Task Parallel Library. http://msdn.microsoft.com/
en-us/library/dd537609.aspx .
[9] The Scala Programming Language.
http://www.scala-lang.org/ .
[10] R. L. Bocchino, Jr., V. S. Adve, D. Dig, S. V. Adve,
S. Heumann, R. Komuravelli, J. Overbey, P. Simmons,
H. Sung, and M. Vakilian. A type and eect system
for deterministic parallel Java. In Proceedings of the
24th ACM SIGPLAN Conference on Object Oriented
Programming Systems Languages and Applications ,
OOPSLA '09, pages 97{116, New York, NY, USA,
2009. ACM.
[11] T. P. Brian Goetz. Java concurrency in practice .
Addison-Wesley, 2006.
[12] M. Eriksen. Scaling Scala at Twitter. In ACM
SIGPLAN Commercial Users of Functional
Programming , CUFP '10, pages 8:1{8:1, New York,
NY, USA, 2010. ACM.
[13] E. Gamma, R. Helm, R. Johnson, and J. Vlissides.
Design Patterns: Elements of Reusable
Object-Oriented Software . Addison-Wesley, 2004.
[14] R. Hundt. Loop Recognition in C++/Java/Go/Scala.
InProceedings of Scala Days , 2011.
[15] D. Y. Lee. A case study on refactoring in Haskell
programs. In Proceedings of the 33rd International
Conference on Software Engineering , ICSE '11, pages
1164{1166, New York, NY, USA, 2011. ACM.[16] H. Li. Refactoring Haskell Programs . PhD thesis,
University of Kent, 2006.
[17] H. Li and S. Thompson. Comparative Study of
Refactoring Haskell and Erlang Programs. In Sixth
IEEE International Workshop on Source Code
Analysis and Manipulation, 2006. SCAM '06. , pages
197{206, 2006.
[18] M. Odersky. Future-proong collections: From
mutable to persistent to parallel. In Proceedings of the
20th International Conference on Compiler
Construction , volume 6601 of Lecture Notes in
Computer Science . Springer Berlin Heidelberg, 2011.
[19] S. Okur and D. Dig. How do developers use parallel
libraries? In Proceedings of the ACM SIGSOFT 20th
International Symposium on the Foundations of
Software Engineering , FSE '12, pages 54:1{54:11, New
York, NY, USA, 2012. ACM.
[20] B. Oliveira and W. Cook. Extensibility for the masses.
InProceedings of the 26th European Conference on
Object-Oriented Programming , volume 7313 of Lecture
Notes in Computer Science , pages 2{27. Springer
Berlin Heidelberg, 2012.
[21] V. Pankratius, F. Schmidt, and G. Garret on.
Combining functional and imperative programming
for multicore software: an empirical study evaluating
Scala and Java. In Proceedings of the 2012
International Conference on Software Engineering ,
ICSE 2012, pages 123{133, Piscataway, NJ, USA,
2012. IEEE Press.
[22] A. Prokopec, P. Bagwell, T. Rompf, and M. Odersky.
A generic parallel collection framework. In Euro-Par
2011 Parallel Processing , volume 6853 of Lecture
Notes in Computer Science , pages 136 { 147. Springer
Berlin Heidelberg, 2011.
[23] A. Prokopec, H. Miller, T. Schlatter, P. Haller, and
M. Odersky. FlowPools: A Lock-Free Deterministic
Concurrent Dataow Abstraction. In 25th
International Workshop on Languages and Compilers
for Parallel Computing , pages 158{173, 2012.
[24] C. Radoi and D. Dig. Practical Static Race Detection
for Java Parallel Loops. In Proceedings of the
International Symposium on Software Testing and
Analysis , ISSTA'13. To Appear, 2013.
[25] S. Thompson. Refactoring functional programs. In
Advanced Functional Programming , volume 3622 of
Lecture Notes in Computer Science , pages 331{357.
Springer Berlin Heidelberg, 2005.