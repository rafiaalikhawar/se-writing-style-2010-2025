DETERMIN: Inferring Likely Deterministic SpeciÔ¨Åcations
of Multithreaded Programs
Jacob Burnim
EECS Department
UC Berkeley, USA
jburnim@cs.berkeley.eduKoushik Sen
EECS Department
UC Berkeley, USA
ksen@cs.berkeley.edu
ABSTRACT
The trend towards multicore processors and graphic processing
units is increasing the need for software that can take advantage of
parallelism. Writing correct parallel programs using threads, how-
ever, has proven to be quite challenging due to nondeterminism .
The threads of a parallel application may be interleaved nondeter-
ministically during execution, which can lead to nondeterministic
results‚Äîsome interleavings may produce the correct result while
others may not. We have previously proposed an assertion frame-
work for specifying that regions of a parallel program behave de-
terministically despite nondeterministic thread interleaving. The
framework allows programmers to write assertions involving pairs
of program states arising from different parallel schedules.
We propose an algorithm to dynamically infer likely determin-
istic speciÔ¨Åcations for parallel programs given a set of inputs and
schedules. We have implemented our speciÔ¨Åcation inference algo-
rithm for Java and have applied it to a number of previously exam-
ined Java benchmarks. We were able to automatically infer speciÔ¨Å-
cations largely equivalent to or stronger than our manual assertions
from our previous work.
We believe that the inference of deterministic speciÔ¨Åcations can
aid in understanding and documenting the deterministic behavior
of parallel programs. Moreover, an unexpected deterministic spec-
iÔ¨Åcation can indicate to a programmer the presence of erroneous or
unintended behavior.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program VeriÔ¨Åcation;
D.2.5 [ Software Engineering ]: Testing and Debugging; F.3.1
[Logics and Meanings of Programs ]: Specifying and Verifying
and Reasoning about Programs
General Terms
Reliability, VeriÔ¨Åcation, Documentation
Keywords
determinism, speciÔ¨Åcation inference, parallel programs
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô10, May 2-8 2010, Cape Town, South Africa
Copyright 2010 ACM 978-1-60558-719-6/10/05 ...$10.00.1. INTRODUCTION
With the growing prevalence of multicore microprocessors and
graphic processing units (GPUs), software engineers are increas-
ingly required to write parallel programs. Unfortunately, parallel
programs have proven to be much more difÔ¨Åcult to write and debug
than sequential software. A key culprit in this difÔ¨Åculty is that par-
allel programs can show different behaviors depending on how the
executions of their parallel threads interleave. The fact that execu-
tions of parallel threads can arbitrarily interleave with each other is
called internal nondeterminism orscheduler nondeterminism .
Internal nondeterminism enables multiple threads to run simulta-
neously, which is essential to harness the power of multicore chips.
However, internal nondeterminism in parallel programs could also
result in nondeterministic outputs. Most of the sequential programs
that we write are deterministic ‚Äîthey produce the same output on
the same input. Therefore, in order to make parallel programs easy
to write, test, and debug, we need to make them behave like sequen-
tial programs, i.e. we need to make parallel programs deterministic.
The most widespread method for writing parallel programs,
threads, requires programmers to ensure determinism. Ensuring
deterministic behavior in such programs is generally very challeng-
ing. Thus, a variety of tools and techniques have been proposed to
help ensure that multithreaded programs exhibit their intended de-
terminism. These tools attempt to automatically Ô¨Ånd sources of
nondeterminism likely to be harmful (i.e. to lead to nondetermin-
istic output) such as data races [25] and high-level race conditions.
However, the absence of data races does not always guarantee de-
terministic behavior [5, 16, 13]. On the other hand, the presence of
data races may not lead to unintended nondeterministic behavior,
and may aid in achieving high performance [6].
We have argued previously [8] that programmers should have a
way to directly and easily specify that a parallel software appli-
cation behaves deterministically. We proposed [8] a scheme for
asserting that a block of parallel code exhibits the intended, user-
speciÔ¨Åed semantic determinism . Formally, our framework allowed
a programmer to give a speciÔ¨Åcation for a block Cof parallel code
as:
deterministic assume (Pre (s0;s0
0)) {
C
}assert (Post (s;s0));
This speciÔ¨Åcation asserts the following: Suppose Cis executed
twice with potentially different schedules, once from initial state
s0and once from s0
0and yielding Ô¨Ånal states sands0, respectively.
Then, if the user-speciÔ¨Åed precondition Pre holds overs0ands0
0,
thensands0must satisfy the user-speciÔ¨Åed postcondition Post .
We argued [8] that such assertions allow a programmer to specify
the correctness of the use of parallelism in an application indepen-
dently of the functional correctness. That is, one can specify thatdifferent executions of a parallel program on the same input can-
not erroneously produce non-equivalent outputs due to scheduling
nondeterminism. This can be accomplished without having to spec-
ify anything about the correctness of individual outputs in terms
of their corresponding inputs. Our experiments [8] showed that if
the deterministic speciÔ¨Åcation of a parallel program is provided, we
can distinguish true races from benign ones in the program and Ô¨Ånd
bugs in parallel programs that arise due to internal nondeterminism.
In this paper, we propose to automatically infer likely determin-
istic speciÔ¨Åcations for parallel programs. SpeciÔ¨Åcally, given a set
of test inputs and thread schedules, for each procedure Pof a par-
allel program, we infer a deterministic speciÔ¨Åcation for the body of
a procedureP:
voidP() {
deterministic assume (Pre (s0;s0
0)) {
... body of P...
}assert (Post (s;s0));
}
A key challenge in inferring likely deterministic speciÔ¨Åcation of
a parallel program is that there could be several speciÔ¨Åcations for
the program; however, not all of the speciÔ¨Åcations are interesting.
For example, the following deterministic speciÔ¨Åcation holds for any
parallel program, where Pre is any predicate.
voidP() {
deterministic assume (Pre (s0;s0
0)) {
... body of P...
}assert (true);
}
To address the problem of inferring ‚Äúinteresting‚Äù deterministic
speciÔ¨Åcations, we argue that a (Pre, Post) pair is ‚Äúinteresting‚Äù
if the following two conditions hold.
1.Pre is a weakest liberal precondition for Post andPost is
a strongest liberal postcondition for Pre, and
2.Post is the strongest liberal postcondition for any possible
Pre, which we show to be unique.
We give an algorithm, D ETERMIN , to compute one such ‚Äúinterest-
ing‚Äù deterministic speciÔ¨Åcation from a set of executions observed
on a given set of inputs and schedules. We formally prove that if
the set of given inputs and schedules is the set of all inputs and
schedules, then we infer an actual ‚Äúinteresting‚Äù deterministic spec-
iÔ¨Åcation of the program.
We have implemented D ETERMIN for Java and have applied it
to a number of previously examined Java benchmarks. We were
able to infer speciÔ¨Åcations largely equivalent to or stronger than
our manual assertions from [8].
We believe that the inference of deterministic speciÔ¨Åcations can
aid in program understanding and documentation of deterministic
behavior of parallel programs. SpeciÔ¨Åcally, a correct inferred speci-
Ô¨Åcation documents for programmers the deterministic aspect of the
parallel behavior of an application. Moreover, an unexpected de-
terministic speciÔ¨Åcation can indicate to a programmer the presence
of buggy or otherwise unintended behavior. For example, consider
a speciÔ¨Åcation indicating a critical component of the program out-
put is notdeterministic; or consider a speciÔ¨Åcation indicating that a
program‚Äôs determinism hinges on some believed-to-be insigniÔ¨Åcant
portion of the input.
Related Work
There is a rich literature on invariant generation [12, 15, 4, 32, 30,
33, 3, 24, 28, 9]. Daikon [12] automatically infers likely programinvariants using statistical inference from a program‚Äôs execution
traces. Csallner et al. [9] propose an approach, called DySy, that
combines symbolic execution with dynamic testing to infer pre-
conditions and postconditions for program methods. Hangal and
Lam [18] propose DIDUCE, which uses online analysis to discover
simple invariants over the values of program variables. Deryaft [24]
is a tool that specializes in generating constraints of complex data
structures. Logozzo [22] proposed a static approach that derives in-
variants for a class as a solution of a set of equations derived from
the program source. Houdini [15] is an annotation assistant for ES-
C/Java [14]. It generates a large number of candidate invariants and
repeatedly invokes the ESC/Java checker to remove unprovable an-
notations, until no more annotations are refuted. The problem of
program invariant generation is related to the problem of automatic
mining of temporal speciÔ¨Åcations of programs. Previous work [4,
32, 30, 33, 3, 1, 17] have approached this problem using both dy-
namic and static analysis techniques. The above mentioned tech-
niques mostly focuses on generation of traditional speciÔ¨Åcations.
Our approach is the Ô¨Årst one to infer likely deterministic speciÔ¨Å-
cations of parallel programs. Unlike traditional speciÔ¨Åcations, our
inferred speciÔ¨Åcations relate two program states coming from dif-
ferent executions.
A number of ongoing research efforts aim to make parallel pro-
grams deterministic by construction [29, 23, 19, 2, 21, 7]. But
such efforts face two key challenges. First, new languages see slow
adoption and often remain speciÔ¨Åc to limited domains. Second,
new paradigms often include restrictions, such as hard-to-use type
systems, that can hinder general purpose programming.
Sadowski, et al., [27] propose a strict notion of determinism
where they require the Ô¨Ånal output to be bitwise equal; therefore,
their notion could not support semantic determinism. Kendo [26]
proposes deterministic thread scheduling for race free programs.
DMP [10] proposes hardware support for deterministic parallel ex-
ecution.
2. BACKGROUND
In this section, we review the key features of our previously pro-
posed deterministic speciÔ¨Åcations [8], quoting liberally from [8].
A block of parallel code is said to be deterministic if, given any
particular initial state, all executions of the code from the initial
state produce the exact same Ô¨Ånal state. In our proposed speciÔ¨Å-
cation framework, the programmer can specify that they expect a
block of parallel code, say P, to be deterministic with the following
construct:
deterministic {
P
}
Semantic Determinism.
We observed [8] that the above deterministic speciÔ¨Åcation is of-
ten too conservative. For example, consider the following example,
where A,B, andCare Ô¨Çoating-point matrices:
deterministic {
C = parallel_matrix_multiply_float(A, B);
}
Floating-point addition and multiplication being non-associative
due to rounding error, it may be unavoidable that the entries of
matrix Cwill differ slightly depending on the thread schedule.
In order to tolerate such differences, we relaxed the deterministic
speciÔ¨Åcation:
deterministic {
C = parallel_matrix_multiply_float(A, B);
}assert (|C - C‚Äô| < 10 6);This assertion speciÔ¨Åes that, for any two matrices CandC‚Äôre-
sulting from the execution of the matrix multiply from same initial
state, the entries of CandC‚Äômust differ by only a small quantity
(i.e.10 6).
Note that the above speciÔ¨Åcation contains a predicate over two
states‚Äîeach from a different parallel execution of deterministic
block. We call such a predicate a bridge predicate , and an assertion
using a bridge predicate a bridge assertion . Bridge assertions are
different from traditional assertions in that they allow one to write a
property over two program states coming from different executions
whereas traditional assertions only allow us to write a property over
a single program state.
This relaxed notion of determinism is useful in many contexts.
Consider the following example which adds in parallel two items
to a synchronized set represented internally as a red-black tree:
Set set = new SynchronizedTreeSet();
deterministic {
cobegin set.add(3); set.add(5); coend
}assert (set.equals(set‚Äô));
Here a strict deterministic assertion would be too conservative.
The structure of the resulting tree, and its layout in memory, will
likely differ depending on which element is inserted Ô¨Årst, and thus
the different executions can yield different program states.
But we can use a bridge predicate to assert that, no matter what
schedule is taken, the resulting set is semantically equal. That is,
for objects setandset‚Äôcomputed by two different schedules, the
equals method must return true because the sets must logically
contain the same elements. We call this semantic determinism .
Preconditions for Determinism.
So far we have described the following construct:
deterministic {
P
}assert (Post);
where Post is a predicate over two program states in different
executions resulting from different thread schedules. That is, if s
ands0are two states resulting from any two executions of Pfrom
the same initial state, then Post (s;s0)holds.
The above construct could be rewritten in the following way:
deterministic assume (s0==s0
0) {
P
}assert (Post);
That is, if any two executions of Pstart from initial states s0and
s0
0, respectively, and if sands0are the resultant Ô¨Ånal states, then
s0==s0
0implies that Post (s;s0)holds. The above rewritten
speciÔ¨Åcation suggests that we can further relax the requirement of
s0==s0
0by replacing it with a bridge predicate Pre(s0;s0
0). For
example:
deterministic assume (set.equals(set‚Äô)) {
cobegin set.add(3); set.add(5); coend
}assert (set.equals(set‚Äô));
The above speciÔ¨Åcation states that if any two executions start
from sets containing the same elements, then after the execution
of the code, the resulting sets after the two executions must still
contain exactly the same elements.
DeÔ¨Ånition of Deterministic SpeciÔ¨Åcation.
In summary, we previously proposed [8] the following construct
for the speciÔ¨Åcation of deterministic behavior.deterministic assume (Pre) {
P
}assert (Post);
It states that for any two program states s0ands0
0, if
Pre(s0;s0
0)holds
an execution of Pfroms0terminates and results in state s
an execution of Pfroms0
0terminates and results in state s0
thenPost (s;s0)must hold.
More formally, let P(s0;)denote the resulting program state if
we run procedure Pon initial state s0and with thread schedule .
Then, the above deterministic speciÔ¨Åcation states that:
8s0;s0
0;;0:Pre(s0;s0
0) =)Post (P(s0;);P(s0
0;0))
We abbreviate this condition by:
Pre =)PPost
Note that, technically, only certain thread schedules are possible
for each initial program state. That is, schedules should not be
universally quantiÔ¨Åed, but must come from the set (s0)of thread
schedules for procedure Prealizable from program state s0. And
functionP(s0;)is deÔ¨Åned only for 2(s0). For simplicity,
however, we omit any further references to (s0).
Note also that, for certain initial states s0and thread schedules
, procedurePmay not terminate. In this case, function P(s0;)
is not deÔ¨Åned, as there is no resulting program state. We implicitly
quantify over only terminating executions. Thus, our deterministic
speciÔ¨Åcations are partial .
The advantage of our deterministic speciÔ¨Åcations is that they
provide a way to specify the correctness of just the use of paral-
lelism in a program, independent of the program‚Äôs full functional
correctness. In many situations, writing a full speciÔ¨Åcation of func-
tional correctness is difÔ¨Åcult and time consuming. But, a simple
deterministic speciÔ¨Åcation enables us to use automated technique
to check for parallelism bugs, such as harmful data races causing
semantically nondeterministic behavior.
3. OVERVIEW OF DETERMIN
In this section, we give an informal overview of our algorithm
for dynamically inferring likely deterministic speciÔ¨Åcations. Con-
sider a procedure, bestTree , which, given a collection of DNA
sequences, computes in parallel a most likely phylogenetic tree1:
void bestTree(int N, int[][] dna,
int &score, int[] &tree)
{
// Parallel branch-and-bound search
// (with N threads) for an optimal
// tree given DNA sequences.
...
}
Given two runs of this procedure on identical DNA sequence
data, we would expect to get identical Ô¨Ånal likelihood scores. Be-
cause the procedure is a parallel branch-and-bound search, we can-
not expect two different runs to necessarily compute the same phy-
logenetic tree‚Äîfor the input data, there may be multiple trees with
the same best score. Thus, we might manually specify the deter-
ministic behavior of procedure bestTree as:
1A tree showing suspected evolutionary relationships‚Äîi.e. shared
common ancestry‚Äîamong a group of species or individuals.void bestTree(int N, int[][] dna,
int &score, int[] &tree)
{
deterministic assume (dna == dna‚Äô) {
...
} assert (score == score‚Äô);
}
Data Collection.
To infer a deterministic speciÔ¨Åcation for procedure bestTree ,
we must Ô¨Årst collect some sample of representative executions.
Suppose the programmers who wrote the code have also con-
structed two DNA sequence data sets, D1andD2, which they use
for testing. (In the absence of hand-constructed test inputs, we
could potentially use random or symbolic test generation to con-
struct test cases.) Then, suppose we execute the procedure, perhaps
as part of some existing application or test, twice on each input:
N= 10;dna=D17 ! score = 140;tree=t1
N= 10;dna=D17 ! score = 140;tree=t2
N= 10;dna=D27 ! score = 175;tree=t3
N= 10;dna=D27 ! score = 175;tree=t4
SpeciÔ¨Åcation Inference.
In theory, there are inÔ¨Ånitely many possible bridge predicates
relating pairs of inputs (N;dna);(N0;dna0)or pairs of outputs
(score;tree);(score0;tree0). But we care only about a very re-
stricted subset of these bridge predicates: predicates that compare
only individual components across pairs of inputs or outputs, and
that compare those components only for certain types of equality
or approximate equality.
For example, for procedure bestTree , we are interested only
in four bridge predicates as preconditions:
true; N =N0;dna=dna0; N =N0^dna=dna0
and four bridge predicates as postconditions:
true;score =score0;tree=tree0;score =score0^tree=tree0
More generally, by focusing on equality between components
of input and output states, we only have to consider Ô¨Ånitely-many
possible deterministic speciÔ¨Åcations. (Although the number of pos-
sible speciÔ¨Åcations is still exponential in the number of input and
output variables.)
Thus, we can think of the deterministic speciÔ¨Åcation inference
problem as having two parts. First, we should determine which of
these possible deterministic speciÔ¨Åcations is consistent with our ob-
served executions. Second, we must decide which of the consistent
speciÔ¨Åcations to select as the Ô¨Ånal inferred speciÔ¨Åcation.
There are six possible deterministic speciÔ¨Åcations consistent
with the four above observed executions. Four of these speciÔ¨Å-
cations are of the form Pre =)bTtrue‚Äîthat is, each of the four
possible preconditions paired with the trivial postcondition. The
other two possible deterministic speciÔ¨Åcations are:
(dna=dna) =)bT(score =score0) (1)
(N=N0^dna=dna) =)bT(score =score0) (2)
In selecting one of these six potential deterministic speciÔ¨Åca-
tions, we are guided by two principles: (1) First, we should select
a speciÔ¨Åcation with as strong of a postcondition as possible. Some
parts of a procedures output may be scheduler-dependent and non-
deterministic, but we would ideally like a speciÔ¨Åcation that cap-
tures all parts of the output that are deterministic. (2) Second, for agiven postcondition, we should select as weak of a precondition as
possible.
For our running example, two of the possible speciÔ¨Åcations (i.e.
speciÔ¨Åcations (1) and (2) shown above) have the strongest con-
sistent postcondition score =score0. (Of course, no consistent
postconditions contain tree=tree0because we observed execu-
tions with identical inputs but different Ô¨Ånal values of tree.) Se-
lecting the weaker of the two possible consistent preconditions for
score =score0gives us the deterministic speciÔ¨Åcation:
(dna=dna) =)bT(score =score0)
For this example, the inferred deterministic speciÔ¨Åcation is ex-
actly the one we would have manually written. In general, how-
ever, there is always the danger that we will infer a postcondition
that is too strong because we have observed no executions showing
the nondeterminism of some output. Similarly, we may infer a pre-
condition that is too weak because we have observed no executions
showing that the deterministic behavior depends on a particular in-
put. In the end, we must rely on having a sufÔ¨Åciently representative
set of test inputs and running on sufÔ¨Åciently-many possible thread
schedules to defend against inferring inaccurate deterministic spec-
iÔ¨Åcations.
4. INFERRING DETERMINISTIC SPECS
In this section, we formally describe the problem of inferring
deterministic speciÔ¨Åcations. Let Pbe a procedure that executes
atomically and with internal parallelism. A procedure Pin a given
program is atomic [16] if, no other component of the program that
can run in parallel with Pcan interfere with the execution of P.
We say that procedure Phasinternal parallelism if, whenPis
executed,Pperforms a computation in parallel and Preturns only
after all parallel work has completed. For example, Pmay spawn
several threads, but must join all of the threads before returning.
For the body of a procedure P, we want to infer a deterministic
speciÔ¨Åcation of the form:
voidP() {
deterministic assume (Pre (s0;s0
0)) {
... body of P...
}assert (Post (s;s0));
}
4.1 Deterministic SpeciÔ¨Åcation Model
In theory, the pre- and postconditions in a deterministic speciÔ¨Å-
cation can be arbitrary bridge predicates. We restrict our attention,
however, to a speciÔ¨Åc class of bridge predicates: conjunctions of
semantic equality predicates.
We treat programs as having a Ô¨Ånite set Mof disjoint memory
locationsfm1;:::;m kg. Then, a program state sis a mapping
from these global variables mito valuess(mi)from setVof pos-
sible program values.
We further suppose that we have a Ô¨Ånite set EQof semantic
equality predicates on program values. We require these predicates
to be reÔ¨Çexive and symmetric relations on program values, and that
this set include the strict equality predicate v=v0. (In our im-
plementation, for example, we also include a approximate numeric
equalityjv v0jand semantic object equality v:equals (v0).)
Then, we consider the class of bridge predicates characterized by
subsets ofMEQ. For someXMEQ, we deÔ¨Åne a bridge
predicate'Xby:
'X(s;s0) =^
(m;eq)2Xeq
s(m); s0(m)That is, for each pair of memory location mand equality predicate
eqwe compare the value of mfrom statessands0using eq. The
bridge predicate is the conjunction of all such equality predicates.
We justify this restriction by noting that this class of bridge pred-
icates sufÔ¨Åced to manually specify the natural deterministic behav-
ior of the benchmarks examined in our previous work [8].
An advantage of this restriction is that there exist only Ô¨Ånitely
many bridge predicates‚Äîone for each of the 2jMjjEQjsubsets of
MEQ. Thus, there are only 22jMjjEQjpossible deterministic
speciÔ¨Åcations, consisting of one pre- and one postcondition, for a
procedureP.
4.2 SpeciÔ¨Åcation Inference Problem
As described above, every pair of subsets of MEQdeÔ¨Ånes
a possible deterministic speciÔ¨Åcation. For a given procedure P,
many of these possible speciÔ¨Åcations may be true. That is, there
may be many pre;postMEQfor which'pre=)P'post.
Here we formally describe which of these true speciÔ¨Åcations,
for a procedure P, we believe is the most natural and interesting
choice. In short, we should infer speciÔ¨Åcations 'pre=)P'post
only where'postis the strongest liberal postcondition of'preand
'preis aweakest liberal precondition of'post. Further, of such spec-
iÔ¨Åcations, we should return one with the unique, strongest possible
postcondition 'post. (We will show that such a unique, strongest
postcondition must exist.)
Lattice Structure of Deterministic SpeciÔ¨Åcations.
The subsets of MEQnaturally form a complete lattice under
the orderingand with join[.
This induces a complete lattice on bridge predicates 'X, with:
'Xv'Y()XY ; ' Xu'Y='X[Y
Note that the lattice on predicates is reversed‚Äî larger sets yield
smaller predicates, and the meet of two predicates is the joinof the
corresponding sets. This lattice has least and greatest elements:
?='MEQ=8(m;eq)2MEQ:eq(s(m);s0(m))
>='; =true
Note that, because every element of EQis reÔ¨Çexive and sym-
metric, every predicate 'Xis reÔ¨Çexive and symmetric on program
states. In particular, ?(s;s)for any state s.
We now state several simple but important properties of these
lattices and their relation to the validity of deterministic speciÔ¨Åca-
tions.
PROPOSITION 1.The lattice operations uandvon bridge
predicates are exactly logical conjunction and implication:
'X^'Y ='Xu'Y( ='X[Y)
'X=)'Y()'Xv'Y( =XY)
PROPOSITION 2.Relation =)Pdistributes over the meet ( u)
operation on bridge predicates, and the join operation on subsets
ofMEQ, in the sense that:
'X)P'Y^'X)P'Y0()'X)P('Yu'Y0)
or, equivalently:
'X)P'Y^'X)P'Y0()'X)P'Y[Y0
PROPOSITION 3.Relation =)Pis monotone in its second ar-
gument and anti-monotone in its Ô¨Årst argument with respect to the
lattice on bridge predicates:
'X=)'X0; 'Y=)'Y0
=) ('X0)P'Y=)'X)P'Y0)In light of Proposition 3, we will say that a deterministic spec-
iÔ¨Åcation ('X;'Y)isstronger ormore strict than another spec-
iÔ¨Åcation ('X0;'Y0)‚Äîdenoted ('X;'Y)v('X0;'Y0)‚Äîwhen
'X0=)'Xand'Y=)'Y0.
Strongest Liberal Postcondition.
For any precondition 'prefor a procedure P, we can deÔ¨Åne the
strongest liberal postcondition SLPP('pre)of'preas the least'post
such that'pre=)P'post. We show below that there is always a
unique SLPP('pre).
PROPOSITION 4.Let'prebe a precondition for procedure P.
SLPP('pre) =l
f'postj'pre=)P'postg
PROOF . First, note that 'pre=)P>so the meet in the propo-
sition is over a non-empty set. Let 'slpdenote the meet over all
postconditions that follow from 'pre.
Then,'pre=)P'slp, because =)Pdistributes overu.
Further,'slpis clearly the least 'postsuch that'pre=)P'post,
because it is the meet of all such postconditions.
COROLLARY 5.Operator SLPPis monotone. That is, if
'X=)'Y, then SLPP('X) =)SLPP('Y).
PROOF . Suppose'X=)'Y.
Because'Y=)PSLPP('Y)and by the anti-monotonicity
of=)P, we have 'X=)PSLPP('Y). Therefore, be-
cause SLPP('X)is the strongest postcondition of 'X, we have
SLPP('X) =)SLPP('Y).
By the monotonicity SLPP, the strongest postcondition that
holds forPunder any possible precondition, is SLPP(?). Note
that, equivalently, this unique strongest postcondition is the meet
over all true postconditions:
l
f'postj9'pre:'pre=)P'postg
Thus, in particular, postcondition SLPP(?)is the conjunction of
the most individual equality predicates of any true postcondition.
Weakest Liberal Precondition.
We can similarly deÔ¨Åne the weakest liberal precondition of a
postcondition 'post. However, because we restrict our precondi-
tions and postconditions to be conjunctions of equality predicates
on individual memory locations, there may not be a unique weak-
est (or largest) precondition for a 'post. Thus, we must deÔ¨Åne
WLPP('post)to be the set of all weakest liberal preconditions:
DEFINITION 6.'pre2WLPP('post)‚Äîi.e. is a weakest liberal
precondition of 'post‚Äîif and only if both:
1.'pre=)P'post, and
2. If there exists a '0such that'0=)P'postand'pre=)
'0, then'0='pre.
Inferred SpeciÔ¨Åcation.
With these formal deÔ¨Ånitions, we can say that the deterministic
speciÔ¨Åcation inference problem for a procedure Pis to compute,
or to approximate as closely as possible, a deterministic speciÔ¨Å-
cation'pre=)P'postwhere'post=SLPP(?)is the unique
strongest possible postcondition for any precondition and where
'preis a weakest liberal precondition of 'post.Algorithm 1 Infer a likely deterministic speciÔ¨Åcation given a set R
of executions of procedure P.
1:Post R SLPP;R(?)
2:PreR WLPP;R(Post R)
3:return (PreR;Post R)
5. DETERMIN ALGORITHM
In the previous section, we have deÔ¨Åned the set of strongest true
deterministic speciÔ¨Åcations for a given procedure P. When infer-
ring a deterministic speciÔ¨Åcation from a limited number of exe-
cutions of a procedure P, however, we can only approximate the
procedure‚Äôs true speciÔ¨Åcation.
Suppose we have a Ô¨Ånite set Rof observed executions
f(s1;1;t1);:::; (sn;n;tn)gof procedure P, where each tiis
the stateP(si;i)resulting from executing Pfrom initial state si
on thread schedule i. A deterministic speciÔ¨Åcation (Pre;Post )
is satisÔ¨Åed for the observed executions R, which we abbreviate
Pre=)P;RPost , when:
81i;jn:Pre(si;sj) =)Post (ti;tj)
Note that this deÔ¨Ånition is identical to that of =)P, except that
we only universally quantify over the observed inputs and thread
schedules. We can similarly deÔ¨Åne the strongest liberal postcon-
ditionSLP P;Rand weakest liberal preconditions WLP P;Rover
observed executions R.
Our overall inference algorithm is presented in Algorithm 1.
Given a set of executions Rof a procedure P, we will infer a likely
deterministic speciÔ¨Åcation (PreR;Post R).
The algorithm consists of two stages. First, we infer Post R
by computing SLPP;R(?), the strongest liberal postcondition,
given executions RofP, of precondition ?. Recall that
this is the strongest possible postcondition, given executions R,
for any precondition. Second, we infer PreRby computing
WLPP;R(Post R), a weakest liberal precondition, given executions
RofP, of postcondition Post R.
5.1 Computing the Strongest Postcondition
Algorithm 2 computes the strongest liberal postcondition, given
executionsR, of some'pre. The algorithm iterates over every pair
of executions (si;i;ti);(sj;j;tj)that satisfy'pre. For each
such pair, it computes the set of all individual equality predicates
that hold on the resulting program states. The algorithm accumu-
lates into post the intersection of all these sets. Thus, at the end
of the algorithm, 'postis the conjunction of all equality predicates
that hold for pairs of post-states resulting from pre-states matching
'pre. That is,'postis the strongest liberal postcondition of 'prefor
the observed executions R.
Checking the condition at line 3 and computing the set and the
intersection in line 4 can all be done in O(jMjjEQj)time. Thus,
the whole SLP computation requires O(jMjjEQjjRj2)time.
5.2 Computing a Weakest Precondition
Algorithm 3 computes a weakest liberal precondition, given ex-
ecutionsR, for some'post. The algorithm begins with 'pre=?=
'MEQ, and then greedily weakens 'preuntil it can be made no
weaker while remaining a precondition for 'poston the observed ex-
ecutionsR. Lines 3-5 check if the current 'precan be safely weak-
ened by removing the conjunct eq(s(m);s0(m))from'pre(s;s0).
It is sufÔ¨Åcient to consider each (m;eq)only once during the
computation. Suppose it was not possible to weaken some pre1
by removing (m;eq), but it was possible to weaken a later
pre2by removing the same (m;eq). Because pre2comes later,Algorithm 2 Compute SLPP;R('pre)
1:post MEQ
2:for all (si;i;ti);(sj;j;tj)2RRdo
3: if'pre(si;sj)then
4: post post\f(m;eq)jeq(ti(m);tj(m))g
5: end if
6:end for
7:return'post
Algorithm 3 Compute a WLPP;R('post)
Require:?=)P;R'post
1:pre MEQ
2:for all (m;eq)2MEQdo
3: if'pre f(m;eq)g=)R;P'postthen
4: pre pre f(m;eq)g
5: end if
6:end for
7:return'pre
pre1pre2and thus (pre1 f(m;eq)g)(pre2 f(m;eq)g)
But, then if 'pre2 f(m;eq)g=)P;R'post, we must also have
'pre1 f(m;eq)g=)P;R'post, which is a contradiction.
Note that, depending on the order in which the algorithm con-
siders the elements of MEQ, it can return any of the possible
weakest preconditions of 'postunder the observed executions.
Checking the condition at line 3 requires O(jMjjEQjjRj2)
time, to determine that 'pre f(m;eq)g=)'poston every pair
of observed executions. Thus, the entire computation of a PreR
requiresO(jMj2jEQj2jRj2)time.
5.3 Correctness
We now formally state several important properties of our deter-
ministic speciÔ¨Åcation inference algorithm. To conserve space, we
omit the proofs of these statements‚Äîthe proofs can be found in the
accompanying technical report.
Most importantly, we show in Proposition 7 that the D ETERMIN
algorithm is correct. That is, for any inferred deterministic speciÔ¨Å-
cation (PreR;Post R)for executions Rof procedure P:
1.PreRis a weakest liberal precondition for Post Rand
Post Ris a strongest liberal postcondition for PreR, given
the executions in R.
2.Post Ris the unique strongest liberal postcondition for any
possible precondition given the executions in R.
We further show (Corollary 9) that an inferred postcondition
Post Rwill always be stronger than the strongest true postcon-
dition SLPP(?). And the more executions Rwe observe, the
weaker‚Äîi.e. closer to the true strongest postcondition‚Äîour in-
ferred postcondition will be (Proposition 8).
Example 10 shows that we cannot make analogous guarantee for
our inferred precondition PreR. Rather, we can only guarantee
that additional executions will only strengthen the inferred precon-
dition as long as they do not weaken the postcondition Post R
(Propositions 11 and 12). And, if Post Ris the true strongest
postcondition for any precondition and for all executions, then
as we observe additional executions our stronger and stronger in-
ferred PreRwill approach a true weakest precondition for Post R
(Corollaries 13 and 14).
PROPOSITION 7.Let(PreR;Post R)be the speciÔ¨Åcation in-
ferred for executions RofP. Then, PreR2WLPP;R(Post R)
andPost R=SLPP;R(PreR).Further, for any 'pre=)P;R'post, we have Post R=)'post.
PROPOSITION 8.LetPost RandPost R0be the inferred post-
conditions for RR0. Then, Post R=)Post R0.
COROLLARY 9.LetPost Rbe the inferred postconditions for
observed executions R. Then, Post R=)SLPP(?). That is,
Post Ris stronger than the strongest true postcondition.
EXAMPLE 10.Consider the following contrived procedure op-
erating on two global variables xandy:
example() {
<x = x + 1> || <y = 0> || <y = y + 1>;
}
Procedure example runs three atomic statements in parallel:
an increment of x, an assignment of yto zero, and an increment of
y. Suppose we observe the executions:
x= 0; y= 07 !x= 1; y= 0
x= 0; y= 17 !x= 1; y= 1
x= 1; y= 17 !x= 2; y= 0
Then, we will infer the speciÔ¨Åcation precondition x=x0^y=y0
and postcondition x=x0^y=y0.
But, suppose we observe the additional execution:
x= 0; y= 07 !x= 1; y= 1
Then we will see that y=y0cannot be guaranteed, and we will
infer the true speciÔ¨Åcation x=x0=)examplex=x0, which has
a weaker precondition.
PROPOSITION 11.LetPost be the inferred postcondition for
bothRandR0, withRR0. Further, let PreRbe an inferred
precondition under R. Then, there is no strictly weaker inferred
precondition Pre0
R.
PROPOSITION 12.LetPost be the inferred postcondition for
bothRandR0, withRR0. Further, let PreR0be an
inferred precondition under R0. Then, there is a PreRfrom
WLPP;R(Post )‚Äîi.e. a possible inferred precondition for observed
executionsR‚Äî such that PreR0=)PreR.
COROLLARY 13.Let the postcondition inferred for executions
RbePost =SLPP(?). Further, let PreRbe an inferred pre-
condition under R. Then, there are no true preconditions of Post ,
i.e. elements of WLPP(Post ), strictly weaker than PreR.
COROLLARY 14.Let the postcondition inferred for executions
RbePost =SLPP(?). Further, let Pre be a true precondition
forPost . Then, there is a PreRfromWLPP;R(Post )‚Äîi.e. a
possible inferred precondition under observed executions R‚Äî such
thatPre =)PreR.
5.4 A More Conservative Precondition
Our algorithm for computing a precondition from
WLPP;R(Post R)Ô¨Ånds a weakest liberal precondition PreRsuch
that no pair of executions from RfalsiÔ¨Åes PreR=)PPost R.
When only a small number of executions or procedure inputs are
examined, such a precondition may be too weak.
For example, consider a procedure Pwhose input consists of
ten integers x0;:::;x 9and whose output is the sum sum of the
integers. Suppose we observe executions Rof this method from
only two distinct initial states‚Äîone where x0==x9= 0
and one where x0==x9= 1 . Then, the deterministic
speciÔ¨Åcation x3=x0
3=)P;Rsum=sum0is consistent with the
data. That is, we observe no pair of executions that falsiÔ¨Åes thatAlgorithm 4 Compute a WLOP P;R('post)
Require:?=)P;R'post
1: // Find the occurring preconditions.
2:occurs ;
3:for all (si;i;ti);(sj;j;tj)2RRdo
4: if'post(ti;tj)then
5: pre f(m;eq)jeq(si(m);sj(m))g
6: occurs occurs[fpreg
7: end if
8:end for
9: // Select a weakest occurring precondition.
10:for all pre2occurs do
11: if:9pre02occurs:pre0prethen
12: return'pre
13: end if
14:end for
x3=x0
3is a necessary precondition for determinism‚Äîi.e. a pair
in whichx3=x0
3, but because some other input is not equal, the
Ô¨Ånal sums are not equal.
To combat such an inadequate test set, rather than report any
weakest liberal precondition consistent with out observed execu-
tions, we can report a weakest occurring liberal precondition .
DEFINITION 15.We say that precondition 'preoccurs in a set
Rof observed executions iff there is a pair (si;i;ti);(sj;j;tj)
fromR, withi6=j, such that 'preis the strongest bridge
predicate satisÔ¨Åed by siandsj. That is, pre is the set
f(m;eq)jeq(si(m);sj(m))g.
We deÔ¨Åne the set WLOP P;R('post)of weakest liberal occurring
preconditions for Pof'postunder observed executions Rby:
DEFINITION 16.'pre2WLOP P;R('post)iff:
1.'pre=)P;R'post,
2.'preoccurs inR, and
3. If'0
preoccurs inR,'0
pre=)P;R'post, and'pre=)'0
pre,
then'0
pre='pre.
Algorithm 4 computes an element of WLOP P;Rfor a postcondi-
tion. We can compute an occurring weakest precondition PreRby
applying Algorithm 4 to Post R.
Note that, unlike with a WLP, observing additional executions
may strengthen or weaken WLOP P;R(Post R), even if Post Rdoes
not change. This is because additional observations can now pro-
vide a weaker occurring precondition, in addition to falsifying a
previous weakest precondition. However, in the limit of observing
all possible executions of P, there is clearly no difference between
WLOP P;R(Post R)andWLPP;R(Post R).
6. EV ALUATION
In this section, we describe our efforts to experimentally evaluate
the effectiveness of our algorithm for inferring likely deterministic
speciÔ¨Åcations. We aim to show that, given a small number of rep-
resentative executions, our algorithm can infer correct and useful
deterministic speciÔ¨Åcations. That is, that our inferred speciÔ¨Åca-
tions capture the intended natural deterministic behavior of parallel
programs.
To evaluate these claims, we implemented our speciÔ¨Åcation in-
ference algorithm D ETERMIN for Java applications and applied
DETERMIN to the benchmarks to which we previously had man-
ually added deterministic speciÔ¨Åcations in [8]. We then compared
the quality and accuracy of the inferred and manual speciÔ¨Åcations.6.1 Benchmarks
We evaluate D ETERMIN on the benchmarks previously exam-
ined in [8]. These benchmarks are primarily from the Java Grande
Forum (JGF) benchmark suite [11] and the Parallel Java (PJ) li-
brary [20]. The names and sizes of the benchmarks are given
in Table 1. Benchmark tsp is a parallel Traveling Salesman
branch-and-bound search [31]. The JGF benchmarks include
Ô¨Åve parallel computation kernels‚Äîfor successive order-relaxation
(sor), sparse matrix-vector multiplication ( sparsematmult ),
computing the coefÔ¨Åcients of a Fourier series ( series ), encryp-
tion and decryption ( crypt ), and LU factorization ( lufact )‚Äî
as well as a parallel molecular dynamic simulator ( moldyn ),
ray tracer ( raytracer ), and Monte Carlo stock price simu-
lator ( montecarlo ). The Parallel Java (PJ) benchmarks in-
clude an app for computing a Monte Carlo approximation of 
(pi3), an app for cryptographic cracking a cryptographic key
(keysearch3 ), an app for parallel rendering of a Mandelbrot Set
image ( mandelbrot ), and a parallel branch-and-bound search
for an optimal phylogenetic tree ( phylogenetic ). These bench-
marks range from a few hundred to a few thousand lines of code,
with the PJ benchmarks relying on an additional roughly 15,000
lines of library code from the Parallel Java Library for threading,
synchronization, and other functionality.
In [8], we added a single deterministic speciÔ¨Åcation block to each
benchmark, around the benchmark‚Äôs entire parallel computation.
6.2 Methodology
In order to apply the D ETERMIN algorithm to these benchmarks,
we need: (1) to decide for which regions in each benchmark to in-
fer deterministic speciÔ¨Åcations, (2) to select a set of representative
executionsRof these regions as inputs to D ETERMIN , (3) to deÔ¨Åne
the sets of memory locations Mandsemantic equality predicates
EQfor the benchmarks.
Regions for Deterministic SpeciÔ¨Åcation Inference.
In this work, we have proposed inferring deterministic speciÔ¨Åca-
tions for procedures‚Äîeither for all procedures detected to have in-
ternal parallelism or for some set of user speciÔ¨Åed procedures. Our
manual deterministic speciÔ¨Åcations in [8], however, were written
not at procedure boundaries, but around certain hand-chosen syn-
tactic blocks of code containing internal parallelism. (Each such
block is atomic because it is the only region in its benchmark that
performs a parallel computation.) Thus, to enable a fair and di-
rect comparison, we use D ETERMIN to infer deterministic precon-
ditions and postconditions at the beginning and end of the single
deterministic block manually identiÔ¨Åed in [8]. That is, in each rep-
resentative execution we record the program state at the beginning
and end of the manually identiÔ¨Åed deterministic block.
Representative Executions.
We similarly ran each PJ benchmark and tsp twenty times‚Äîten
on each of of two selected inputs, half with Ô¨Åve threads and half
with ten threads. Benchmark tsp, all of the JGF benchmarks, and
many of the PJ benchmarks come with test inputs. When available,
we used two of these test inputs. Otherwise, we constructed inputs
by hand.
The representative executions were run under the Sun JDK 6 on
an eight-core Intel Xeon 2GHz Linux system.
Note that, due to the small number of test inputs, we com-
pute the more conservative weakest liberal occurring precondition
(WLOP), described in Algorithm 4, for our inferred postcondition,
rather than a weakest liberal precondition (WLP).Memory Locations and Equality Predicates.
For the Java program states recorded during the representative
executions, we generate a set Mof memory locations by enu-
merating all paths of Ô¨Åeld dereferences, up to some Ô¨Åxed length,
through the programs‚Äô memory graphs starting at the local vari-
ables and static classes. (For example, n,this:results:bestScore ,
orAppClass:N_THREADS .) For completeness, we considered all
paths of length up to 8, yielding from roughly 20 to 150 memory
locations for each benchmark.
We use several equality predicates to compare these memory lo-
cations: Primitive types are compared using strict equality or ap-
proximate equality (equal to within 10 10) for Ô¨Çoating-point val-
ues. Objects are compared using their equals ()methods. Object
arrays, Lists, and Iterables can be compared element-by-element or
compared as sets of elements.
6.3 Implementation
To capture and record program states at desired points in our
benchmarks, the data collection component of our implementation
uses the Java ReÔ¨Çection API to traverse and serialize a running pro-
gram‚Äôs memory graph. We manually instrumented the local vari-
ables in scope at the open and close of each deterministic block.
The speciÔ¨Åcation inference portion of our implementation takes
a set of these serialized and pre- and post-states as input and out-
puts an inferred deterministic strongest liberal postcondition and
weakest liberal occurring precondition. Both components together
are implemented in roughly 1000 lines of Java code.
Heuristics.
The above approach generates a large number of memory loca-
tions and equality predicates, leading to deterministic speciÔ¨Åcations
with too many conjuncts in their preconditions and postconditions.
We employ several heuristics to decrease the size and increase the
relevancy of our deterministic speciÔ¨Åcations:
First, we remove from the inferred postconditions any locations
not modiÔ¨Åed in at least one execution by the region of code un-
der examination. Without this heuristic, the strongest postcondition
(and thus also the precondition) for a region will contain a conjunct
v=v0for each variable vnot modiÔ¨Åed by the region. While such
an added conjunct is correct‚Äîwe can guarantee the determinism
of variables that are not modiÔ¨Åed‚Äîit is generally not relevant to
computation being performed. On each of our benchmarks, this
heuristic removes roughly from 10 to 60 conjuncts.
Second, we remove from the inferred precondition and postcon-
dition any conjuncts that are satisÔ¨Åed by every pair of observed
program executions. These locations tend to be global constants,
such as hard-coded parameters and Class objects. As above, pred-
icates involving such constants are typically not relevant. On each
our benchmarks, this heuristic can remove as many as 75 conjuncts
from the precondition or postcondition.
Third, we eliminate redundant conjuncts. For example, if a pre-
condition contains the conjunct o:equals (o)for an arrayo, then we
will not include the redundant, weaker conjunct o:f:equals (o:f0).
Or if our postcondition contains conjunct x=x0, we will not add
the redundant conjunct jx x0j 10 10. On each our bench-
marks, this heuristic removes only a handful of conjuncts from the
Ô¨Ånal preconditions and postconditions.
6.4 Results
The results of our experimental evaluation are shown in Ta-
ble 1. We will argue the these results provide evidence for our
claims that D ETERMIN can automatically infer deterministic spec-
iÔ¨Åcations that are both accurate and useful.BenchmarkApproximate
Lines of Code (App
+ Library)Precondition Postcondition
# Manual # Inferred As Strong # Manual # Inferred As Strong
Conjuncts Conjuncts As Manual? Conjuncts Conjuncts As Manual?
JGFsor 300 3 2 No 1 7 Yes
sparsematmult 700 4 4 No 1 2 Yes
series 800 1 3 Yes 1 1 Yes
crypt 1100 1 5 Yes 2 2 Yes
moldyn 1300 2 14 Yes 3 7 Yes
lufact 1500 4 9 Yes 3 3 No
raytracer 1900 2 3 Yes 1 1 Yes
montecarlo 3600 1 2 Yes 1 1 Yes
PJpi3 150 + 15,000 2 3 Yes 1 1 Yes
keysearch3 200 + 15,000 3 5 Yes 1 3 Yes
mandelbrot 250 + 15,000 7 11 Yes 1 5 Yes
phylogeny 4400 + 15,000 3 5 Yes 2 11 Yes
tsp 700 1 3 Yes 1 2 Yes
Table 1: Results of our experimental evaluation of D ETERMIN . For each benchmark, we report the approximate size of the bench-
mark and the number of conjunctions in the manual deterministic precondition and postcondition added to the benchmark in [8].
We also report the number of conjuncts in the strongest liberal postcondition (SLP) and weakest liberal occurring precondition
(WLOP) of the deterministic speciÔ¨Åcation inferred by D ETERMIN for each benchmark. Further, we indicate whether each inferred
precondition and postcondition is at least as strict as its corresponding hand-speciÔ¨Åed condition.
Accuracy: Postconditions.
For every benchmark but lufact , our automatically inferred
postcondition was at least as strong as the corresponding manually-
speciÔ¨Åed postcondition from [8]. Further, the inferred postcondi-
tion for lufact is actually more accurate than our manual one.
When writing the manual speciÔ¨Åcation for lufact in [8], we
wrote postcondition a=a0^ipvt=ipvt0^x=x0. But, in fact,
thelufact routine writes no output into variable x. The relevant
output‚Äîthe solution to the linear system being solved‚Äîis written
to variableb. The correct postcondition, inferred by D ETERMIN , is
a=a0^ipvt=ipvt0^b=b0
Of the other benchmarks, for all but three of them ( sor,
moldyn , andtsp), the inferred postcondition is equivalent to the
manual one. Although the inferred postconditions contain more
conjuncts, these postconditions hold for the same pairs of execu-
tions. For example, the manual postcondition for mandelbrot is
simply matrix =matrix0. That is, the resulting image, stored as
a matrix of hues, is deterministic. The inferred postcondition also
contains image:myWidth =image:myWidth0. But this Ô¨Åeld always
holds the width of matrix , and thus this conjunct does not strictly
strengthen the postcondition.
Further, for benchmarks sor andmoldyn , the inferred post-
conditions are still correct and are only slightly stronger than the
previous manual ones. Both benchmarks retain various intermedi-
ate results past the end of their computations. Roughly speaking,
our manual assertions for these benchmarks specify that the Ô¨Ånal
answer is independent of the number of threads used, while the in-
ferred speciÔ¨Åcations capture that these intermediate results are also
deterministic for any Ô¨Åxed number of threads.
Accuracy: Preconditions.
For all but two benchmarks ( sor andsparsematmult ), our
inferred preconditions are also as strong as our previous [8] manual
deterministic speciÔ¨Åcations. Further, these inferred preconditions,
except for moldyn ‚Äôs and keysearch3 ‚Äôs, are equivalent to the
manual ones although they contain more conjuncts.
The inferred precondition for moldyn contains nthreads =
nthreads0, making it stronger than in our manual speciÔ¨Åcation.
The stronger precondition for keysearch3 actually highlights
an error in the manual speciÔ¨Åcation from [8]. One of the inputs
(partialkey ) to the main computation is missing from the manual
precondition. But the conjunct partialkey =partialkey0correctly
appear in the inferred precondition.Limitations.
For the sor benchmark, our inferred precondition is missing two
input parameters on which the deterministic behavior depends. D E-
TERMIN fails to include these two parameters because they each
take on the same value in all of JGF test inputs for sor. Thus, D E-
TERMIN sees no evidence that these parameters are important for
determinism and removes them via our second heuristic. This ex-
ample shows the need for a sufÔ¨Åciently diverse set of test inputs and
executions in order to infer accurate deterministic speciÔ¨Åcations.
Similarly, the postcondition for tsp is incorrectly too strong, re-
quiring that two runs on the same input return the same tour. In fact,
two such runs could return different tours with the same minimal
cost, but our particular test inputs appear to have unique solutions.
Discussion.
For nearly all of our benchmarks, D ETERMIN infers determinis-
tic preconditions and postconditions equivalent to, slightly stronger
than, or more accurate than those in our previous, manual speciÔ¨Å-
cations. Thus, we argue that D ETERMIN can capture the intended
and natural deterministic behavior of parallel programs.
Further, although our automatically inferred speciÔ¨Åcations are
somewhat larger than the manual ones from [8], the total number
of inferred conjuncts remains quite small. In particular, we be-
lieve that pre- and postconditions with 5 to 15 conjuncts are small
enough to be fairly easily understood by a programmer. Thus, we
argue that such inferred speciÔ¨Åcations can help document the de-
terministic behavior of a routine or application for a programmer.
For example, the inferred speciÔ¨Åcation for lufact corrected our
misunderstanding of the benchmark‚Äôs behavior.
Further, we argue that such automatically-inferred deterministic
speciÔ¨Åcations can be useful in discovering parallelism bugs through
anomaly detection. That is, from observing ‚Äúnormal‚Äù program ex-
ecutions, D ETERMIN infers a speciÔ¨Åcation of the typical, expected
deterministic behavior of a program. Then, if more in-depth testing
Ô¨Ånds executions that are anomalous‚Äîi.e. that violate the inferred
speciÔ¨Åcation‚Äîthen those executions may exhibit bugs.
In [8], we combined deterministic speciÔ¨Åcations with a parallel
software testing tool in order to distinguish benign from harmful
races in these benchmarks. The speciÔ¨Åcations inferred by D ETER -
MIN in this work are sufÔ¨Åciently similar to those manual speciÔ¨Åca-
tions to serve the same purpose. In particular, these speciÔ¨Åcations
would allow us to distinguish the harmful data race that exists in
theraytracer benchmark from the other benign races.7. ACKNOWLEDGMENTS
We would like to thank Chang-Seo Park and our anonymous re-
viewers for their valuable comments. This work supported in part
by Microsoft (Award #024263) and Intel (Award #024894) fund-
ing and by matching funding by U.C. Discovery (Award #DIG07-
10227), by Sun Microsystems and by matching funding from UC
MICRO (Award #08-113), by NSF Grants CNS-0720906 and CCF-
0747390, and by a DoD NDSEG Graduate Fellowship.
8. REFERENCES
[1] M. Acharya, T. Xie, J. Pei, and J. Xu. Mining API patterns as
partial orders from source code: from usage scenarios to
speciÔ¨Åcations. In 6th joint meeting of the European Software
Engineering Conference and the ACM SIGSOFT symposium
on the Foundations of Software Engineering . ACM, 2007.
[2] G. Agha. Actors: A Model of Concurrent Computation . MIT
Press, 1986.
[3] R. Alur, P. Cerny, G. Gupta, P. Madhusudan, W. Nam, and
A. Srivastava. Synthesis of Interface SpeciÔ¨Åcations for Java
Classes. In Proceedings of POPL‚Äô05 (32nd ACM Symposium
on Principles of Programming Languages) , 2005.
[4] G. Ammons, R. Bodik, and J. R. Larus. Mining
speciÔ¨Åcations. In ACM SIGPLAN-SIGACT symposium on
Principles of Programming Languages (POPL) , 2002.
[5] C. Artho, K. Havelund, and A. Biere. High-level data races.
Software Testing VeriÔ¨Åcation and Reliability , 13(4):207‚Äì227,
2003.
[6] G. Barnes. A method for implementing lock-free shared-data
structures. In ACM Symposium on Parallel Algorithms and
Architectures , pages 261‚Äì270, 1993.
[7] R. Bocchino, V . Adve, S. Adve, and M. Snir. Parallel
programming must be deterministic by default. In USENIX
Workship on Hot Topics in Parallelism (HOTPAR) , 2009.
[8] J. Burnim and K. Sen. Asserting and checking determinism
for multithreaded programs. In 7th Joint Meeting of the
European Software Engineering Conference and the ACM
SIGSOFT Symposium on the Foundations of Software
Engineering . ACM, 2009.
[9] C. Csallner, N. Tillmann, and Y . Smaragdakis. DySy:
Dynamic symbolic execution for invariant inference. In 30th
ACM/IEEE International Conference on Software
Engineering (ICSE) , 2008.
[10] J. Devietti, B. Lucia, L. Ceze, and M. Oskin. DMP:
deterministic shared memory multiprocessing. In ACM
conference on Architectural Support for Programming
Languages and Operating Systems (ASPLOS) , 2009.
[11] Edinburgh Parallel Computing Centre. Java Grande Forum
benchmark suite.
www2.epcc.ed.ac.uk/computing/research_
activities/java_grande/index_1.html .
[12] M. D. Ernst, A. Czeisler, W. G. Griswold, and D. Notkin.
Quickly detecting relevant program invariants. In
Proceedings of the 22nd International Conference on
Software Engineering , pages 449‚Äì458, June 2000.
[13] C. Flanagan and S. N. Freund. Atomizer: a dynamic
atomicity checker for multithreaded programs. In 31st ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages (POPL) , pages 256‚Äì267, 2004.
[14] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B.
Saxe, and R. Stata. Extended static checking for Java. In
ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI) , 2002.[15] C. Flanagan and R. M. Leino. Houdini, an annotation
assistant for ESC/Java. In Proceedings of the International
Symposium of Formal Methods Europe (FME) , 2001.
[16] C. Flanagan and S. Qadeer. Types for atomicity. In ACM
SIGPLAN international workshop on Types in Languages
Design and Implementation (TLDI) , 2003.
[17] C. Goues and W. Weimer. SpeciÔ¨Åcation mining with few
false positives. In International Conference on Tools and
Algorithms for the Construction and Analysis of Systems
(TACAS) , 2009.
[18] S. Hangal and M. S. Lam. Tracking down software bugs
using automatic anomaly detection. In Proceedings of the
International Conference on Software Engineering , 2002.
[19] W. M. Johnston, J. R. P. Hanna, and R. J. Millar. Advances in
dataÔ¨Çow programming languages. ACM Comput. Surv. ,
36(1):1‚Äì34, 2004.
[20] A. Kaminsky. Parallel Java: A UniÔ¨Åed API for Shared
Memory and Cluster Parallel Programming in 100% Java. In
21st IEEE International Parallel and Distributed Processing
Symposium (IPDPS 2007) , March 2007.
[21] E. A. Lee. The problem with threads. Computer ,
39(5):33‚Äì42, May 2006.
[22] F. Logozzo. Automatic inference of class invariants. In
Proceedings of the 5th International Conference on
VeriÔ¨Åcation, Model Checking and Abstract Interpretation
(VMCAI ‚Äô04) , January 2004.
[23] H. Loidl, F. Rubio, N. Scaife, K. Hammond, S. Horiguchi,
U. Klusik, R. Loogen, G. Michaelson, R. Pena, S. Priebe,
et al. Comparing parallel functional languages:
Programming and performance. Higher-Order and Symbolic
Computation , 16(3):203‚Äì251, 2003.
[24] M. Z. Malik, A. Pervaiz, , and S. Khurshid. Generating
representation invariants of structurally complex data. In
TACAS , pages 34‚Äì49, 2007.
[25] R. Netzer and B. Miller. Detecting data races in parallel
program executions. In Advances in Languages and
Compilers for Parallel Computing . MIT Press, 1990.
[26] M. Olszewski, J. Ansel, and S. Amarasinghe. Kendo:
EfÔ¨Åcient deterministic multithreading in software. In The
International Conference on Architectural Support for
Programming Languages and Operating Systems , Mar 2009.
[27] C. Sadowski, S. Freund, and C. Flanagan. SingleTrack: A
Dynamic Determinism Checker for Multithreaded Programs.
InEuropean Symposium on Programming (ESOP) , 2009.
[28] M. Taghdiri and D. Jackson. Inferring speciÔ¨Åcations to detect
errors in code. Automated Software Engg. , 14(1):87‚Äì121,
2007.
[29] W. Thies, M. Karczmarek, and S. Amarasinghe. StreamIt: A
language for streaming applications. Lecture Notes in
Computer Science , pages 179‚Äì196, 2002.
[30] N. Tillmann, F. Chen, and W. Schulte. Discovering likely
method speciÔ¨Åcations. In ICFEM , pages 717‚Äì736, 2006.
[31] C. von Praun and T. R. Gross. Object race detection. In ACM
SIGPLAN conference on Object Oriented Programming,
Systems, Languages, and Applications (OOPSLA) , 2001.
[32] J. Whaley, M. C. Martin, and M. S. Lam. Automatic
Extraction of Object-Oriented Component Interfaces. In
Proceedings of ACM SIGSOFT ISSTA‚Äô02 (International
Symposium on Software Testing and Analysis) , 2002.
[33] J. Yang and D. Evans. Dynamically inferring temporal
properties. In PASTE ‚Äô04 , pages 23‚Äì28. ACM, 2004.