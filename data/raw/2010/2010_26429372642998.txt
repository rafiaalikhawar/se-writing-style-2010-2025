AssertionGuidedAbstraction:ACooperativeOptimization
forDynamicPartialOrderReduction
MarkusKusano
E
CEDepartment
VirginiaTech
Blacksburg,VA24061,USA
mukusano@vt.eduChaoWang
ECEDepartment
VirginiaTech
Blacksburg,VA24061,USA
chaowang@vt.edu
ABSTRACT
We propose a new method for reducing the interleavingspace dur-
ing stateless model checking of multithreaded C/C++ programs.
The problem is challenging because of the exponential growth of
possible interleavings between threads. We have developed a new
method, called assertion guided abstraction , whichleverages both
static and dynamic program analyses in a cooperative framework
toreducetheinterleavingspace. Unlikeexistingmethods thatcon-
sider all interleavings of all conﬂicting memory accesses in a pro-
gram, our new method relies on a new notion of predicate depen-
dencebased on which we can soundly abstract the interleaving
space to only those conﬂicting memory accesses that may cause
assertionviolationsand/ordeadlocks. Ourexperimentalevaluation
of assertion guided abstraction on open source benchmarks shows
that it is capable of achieving a signiﬁcant reduction, thereby al-
lowing for the veriﬁcation of programs that were previously too
complexforexistingalgorithmstohandle.
CategoriesandSubjectDescriptors
F.3.1 [LogicsandMeaningsofPrograms ]: Specifying and Veri-
fying and Reasoning about Programs; D.2.4 [ SoftwareEngineer-
ing]: Software/ProgramVeriﬁcation
GeneralTerms
Algorithm,Veriﬁcation,Reliability
Keywords
Statelessmodel checking, partialorder reduction, predicate depen-
dence,assertionguidedabstraction,cooperativeanalysis.
1. INTRODUCTION
Analyzing the behavior of a multithreaded program remains a
difﬁculttaskdespitethe largebodyof existingworkonbothstatic
and dynamic program analysis techniques. The main reason is
that the number of thread interleavings is often exponential in the
program size, which means that the naive approach of explicitly
checking allpossibleinterleavingsispracticallyinfeasible. Dueto
this well-known interleaving explosion problem, existing methods
Permission to make digital or hard copies of all or part of this work for personal or
classroomuse is grantedwithout fee provided thatcopiesare notmade ordistributed
forproﬁtorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s)mustbehonored. Abstractingwithcreditispermitted. Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeciﬁcpermission
and/orafee. Requestpermissionsfrompermissions@acm.org.
ASE’14,September15-19,2014,Vasteras,Sweden.
Copyrightisheldbytheowner/author(s). PublicationrightslicensedtoACM.
ACM978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2642998.based on static analysis often lack accuracyas a result of having
to track all possible executions of the program simultaneously. In
contrast,dynamicanalysismethodscanbemadesigniﬁcantlymore
accurate since they only have to focus on a single execution trace
atatime. However,withoutaglobalviewoftheprogrambehavior,
dynamic analysis methods oftenlack foresight. Forexample, ady-
namicanalysismayhavedifﬁcultycomputingevensimplefactsof
theprogramsuchascontrolanddatadependencies.
We present in this paper a new cooperative analysis framework
for multithreaded programs to allow static and dynamic analysis
methods to share information between each other withthe goal of
increasing the accuracy and speed of the analysis as compared to
usingeachmethodalone. Speciﬁcally,weshowthatthenewstatic–
dynamic analysis framework can be leveraged to efﬁciently check
embedded assertions in a multithreaded program. In this particu-
larapplication,thestaticanalysisisacontrolanddatadependency
analysis, and the dynamic analysis is a stateless model checking
procedureaugmentedwithpartialorderreduction. Weshalldemon-
strate through experiments that the use of both static and dynamic
analysesinourcooperativeframeworkcansigniﬁcantlyoutperform
eachindividualmethod.
From a static analysis standpoint, assertions in a multithreaded
programcanbecheckedwithaconcurrentdataﬂowanalysis. How-
ever, carrying out a precise whole-program static analysis that is
capableofresolvingallembeddedassertionsischallenginginprac-
tice, due to complex language constructs such as loops, recursive
functioncalls,andheapallocateddatastructures. Fromadynamic
analysis standpoint, assertions can be checked byusing a stateless
modelchecker[15]thatsystematicallyexecutestheprogramunder
all possible thread schedules. However, in the presence of inter-
leaving explosion ,dynamicanalysisaloneisnotsufﬁcientforsolv-
ing the problem. Our new cooperative static–dynamic approach,
in contrast, reduces the veriﬁcation problem into two signiﬁcantly
simplersubproblems: ﬁrststaticallycomputingtheapproximatede-
pendence between statements and then dynamically pruning away
theredundant interleavingsbasedontheprecomputeddependence.
Toward this end, we introduce the new notion of predicate de-
pendenceoverconcurrent operations. Dependence isalwaysatthe
heart of static and dynamic analysis methods for concurrent pro-
grams. Forexample,dynamic partialorderreduction(DPOR[13])
relies on conﬂict dependence . Two operations are conﬂict depen-
dentiftheyarefromdifferentthreads,accessthesamememorylo-
cation,andatleastoneofthemisawriteoperation. DPORgroups
execution traces into various equivalence classes and then picks a
representative fromeach equivalence class tocheck. Accordingto
the trace theory by Mazurkiewicz [26], which is the foundation of
partial order reduction methods, two traces are equivalent if they
can be transformed into each other by repeatedly swapping the
adjacent, independent transitions. For example, a read of shared
variablexinif(x)and a write in x:=1would be considered
175
#define NUM_THREADS 12
#define SIZE 128
#define MAX 4
inttable[SIZE];
int*thread_routine( int*arg) {
inttid = (( int*)arg);
intm = 0, w, h;
while(1) {
if(m < MAX){
w = (++m) *11 + tid;
}else{
thread_exit(0);
}
h = (w*7) % SIZE;
if(h < 0) {
assert(0);
}
while(cas(table, h, 0, w) == 0) {
h = (h+1) % SIZE;
}
}
}
intmain() {
for(inti = 0; i < NUM_THREADS; ++i)
thread_create(thread_routine(i));
...
}
Figure 1. Example from SV-COMP 2014 ( IndexerSafe )
where multiple threads share a hash table. The assertion checks
if a thread reads past the array bound. casis an atomic compare-
and-swapwhichmodiﬁesthestateofthetableatthepassedindex.
as conﬂict-dependent, whereas if(x)andy:=1wouldnot since
theyaccessdifferentmemorylocations.
However, the deﬁnition of conﬂict dependence is overly restric-
tiveinmanycasesanddoesnotallowredundantinterleavingstobe
prunedaway. Forexample,thetwowriteoperationsin x:=10and
x:=10areconﬂict-dependentandyettheirrelativeexecutionorder
isimmaterialforpropertyveriﬁcation. Onecanimagineextending
conﬂict dependence as follows: two conﬂict-dependent operations
are saidtobe view-dependent ifthe twodifferentexecution orders
of them lead to different program states. In other words, x:=10
andx:=10wouldnot be view-dependent but x:=10andx:=20
would be. However, even view dependence would not be able to
pruneawaymanyredundant interleavings.
The most general extension along this direction is predicate de-
pendence. For example, assume that the only place where the val-
ues writtento xareusedsubsequently intheprogram istocontrol
the branching condition in if(x>5) . In this case, it is actually
immaterialwhetherweexecute x:=10beforeorafter x:=20,be-
cause both (10>5) and (20>5) are true. For the purpose of check-
ingreachabilityproperties inamultithreadedprogram, allwecare
aboutiswhethertherelativeexecutionoftwooperationsaffectsthe
reachabilityofabadstate,e.g.,astatewhereanassertionfails.
Consider the example inFigure 1, which is a variant of the run-
ning example used to illustrate the DPOR algorithm in [13]. The
program has a set of threads concurrently accessing data items in
a shared hash table. The assertion in this program checks if the
generated hash table key in each thread is out-of-bounds of the ar-
ray. Whenthenumberofthreadsisbelow12,allpossibleinterleav-
ingsoftheprogramsbelongtothesameequivalenceclass,meaning
that only one representative needs to be checked. However, when
thenumber ofthreadsreaches orgoesbeyond12, accordingtothe
classicpartialorderreductionmethods, thenumber ofequivalence
classes goes up exponentially, which quickly makes existing dy-
namicanalysismethodsintractable.
Figure2shows theperformance oftheDPORalgorithmaswell
as our new method (Pred-DPOR). The x-axis is the number of
threads in the test program, and the y-axis is the execution time.
Although DPOR performs well when the number of threads is be-
low12,itsuffersfromtheinterleavingexplosionwhenthenumber11 12 13 14 15100102
NumberofThreadsRuntime(s)DPOR
Pred-DPOR
Figure 2. Comparing baseline DPOR with our new Pred-DPOR
methodon IndexerSafe withdifferentnumberofthreads.
of threads is above 12. However, our observation is that, for the
purpose of checking assertions in the program, there is no need
to explore the exponentially many thread interleavings. Since the
hashkey,h,reliesonwandm,noneofwhichareinterferedbyother
threads, the assertion cannot be violated due to thread scheduling.
Whereatraditionaldynamic analysis methodwouldhavetocheck
all possible thread interleavings of the program, withthe help ofa
conservative static analysis, we can tell after onerun that this pro-
gramneverviolatestheassertionsduetothreadscheduling.
WehaveimplementedournewmethodsbyleveragingtheLLVM
platform to implement the new static analysis and a modiﬁed ver-
sion ofInspect[42] to implement the new dynamic analysis. Fig-
ure 3 shows the overall ﬂow of our method, which takes a multi-
threaded C/C++ program as input and determines if there are as-
sertion violations or deadlocks. First, we parse the input program
and instrument it to add logging/control capabilities for dynamic
analysis. Then, we perform a conservative static analysis in sub-
procedure named Dependence Calculate to compute the predicate
dependencyrelationsbetweenpotentiallyconcurrentoperations. In
the subsequent dynamic analysis, which extends the DPORalgo-
rithm,weleveragetheprecomputeddependency relationstoprune
awayredundantthreadinterleavings.
C/C++
ProgramLLVM InstrumentDependence
Calculate
Program
InputInst. BinaryDependence
Relations
DPOR
AssertionGuidedAbstraction+DPOR
Figure3. Overallﬂowofournewmethod.
W
e have evaluated our new method on a set of open source
benchmarks and benchmarks from SV-COMP 2014. Our experi-
ments show that the cooperative analysis framework can greatly
reduce the search efforts by focusing on the subset of the conﬂict-
dependent operations that actually affect the validity of the prop-
erties at hand. In fact, our results show that, when compared to
the default DPOR algorithm, our new method can quickly verify
the assertionproperties of manyprograms that were previously in-
tractable.
Insummary,thispapermakesthefollowingcontributions:
•We introduce the new notion of predicate dependence and
propose a new static analysis method for computing the de-
pendence conservatively.
•Weproposeanewcooperativestatic–dynamicanalysisframe-
work that leverages the new dependency relation to reduce
theinterleavingspaceatruntime.
176•We also propose twonew optimizations for the DPOR algo-
rithmtofurtherimprovetheperformance.
•Weimplementthenewmethodsanddemonstratetheireffec-
tivenessthroughexperimentsusingopensourcebenchmarks.
The remainder of this paper is organized as follows. We will
establish notationinSection2before introducing predicate depen-
dence in Section 3. We will present our new cooperative static–
dynamic analysis framework in Section 4, and the two additional
optimizationsforDPORinSection5. Ourexperimentalresultswill
bepresentedinSection6. WewillreviewrelatedworkinSection7,
andﬁnally,giveourconclusions inSection8.
2. PRELIMINARIES
Thissectionprovidesthebackgroundinformationonexistingdy-
namicanalysismethodsformultithreadedprograms.
2.1 ConcurrentSystem
A concurrent system is composed of a ﬁnite number of threads
andaﬁnitesetof communicationobjects . Individually,eachthread
executesasequence ofoperationsofasequentialprogram. During
dynamicanalysis,operationsoncommunicationobjectsareconsid-
eredvisiblewhereas all other operations are considered invisible–
they are not monitored during the program execution. We also as-
sume that each visible operation is atomic, i.e., it can be executed
on one communication object at a time without interference from
the other threads. An operation is blockingif it cannot currently
be executed. For example, a thread waitingfor a mutex locktobe
releasedbyanotherthreadissaidtobeblocked.
Aglobal state is reached whenever the next operation for each
thread is a visible operation. We assume that there exists at least
one visibleoperation for eachthreadandthat there isa unique ini-
tialstates0. Atransitionfromonestatetoanotheristheexecution
o
f a visible operation followed by any ﬁnite number of invisible
operations by the same thread, ending just before another visible
operation. The state space of a concurrent program is simply all
the global states reachable from s0and all the transitions between
t
hese states. Following the notation used by Godefroid [15], we
combine local(invisible)operationswiththeprevious visibleoper-
ation into one transition. Therefore, the state space is reduced by
avoiding unnecessary interleavings of local operations. From here
on,wewillusetheterm statetomeanglobalstate.
Formally, a concurrent system can be modeled as a transition
systemAG= (S ,∆,s0)w hereSisthesetofstatesforthesystem,
∆⊆S×Sisthetransitionrelation ,ands0istheinitialstate. Let
Tb
ethesetofalltransitionsforthesystem,and T∗bethesetofall
ﬁ
nite words (allsequences of transitions) that can be created from
T. We use st− →s′to mean that executing t∈ Tfromsleads to
states′. Weuse sw=⇒s′tomeanthatexecutingtheﬁnitesequence
o
f transitions w∈ T∗leads from st os′. A state s′is said to be
r
eachablefromsifthereexistssome wsuchthat sw=⇒s′.
A
transition is disabledin the state sif its visible operation is
blocking,implyingthatthetransitioncannotcurrentlybeexecuted.
Ifatransitionisnotdisabled,itis enabledins. Twotransitionsare
co-enabled ifthereexistssomestatewheretheyarebothenabled.
2.2 StatelessModelChecking
The state space of a concurrent system can be fully explored
byusinga stateless model checking [15] procedure, whichsystem-
atically executes the program under all possible thread schedules.
Different from the classic model checkers [7] which are typically
stateful, here the search is carried out without explicitly storing
any system state. Instead, a system state is uniquely identiﬁed by
the sequence of transitions executed, starting from the initial state
s0. Inother words, insteadofexploring thereachable statesof the
system, the procedure systematically explores the set of executiontraces. When dealing with full-ﬂedged programming languages
such as C/C++/Java, where the system state consists of values for
all memory locations that can be accessed by a thread, stateless
modelcheckingisafarmorepracticalmethod.
Toexhaustivelyexploretheinterleavingspace,wemustcheckat
least one representative thread interleaving from each equivalence
classofinterleavings,alsocalledtheMazurkiewicztrace[26]. This
canberegardedasthetheoreticalfoundationofpartial-orderreduc-
tion (POR). More formally, Mazurkiewicz traces [26], in the con-
text of concurrent systems, are deﬁned as equivalence classes of
sequences of transitions. Let D ⊆ T × T be a valid dependency
relation between transitions. Two sequences of transitions over T
are equivalent if the two traces can be obtained from each other
bysuccessivelyexchanging adjacentindependent transitions. Con-
sider two transitions tandt′. Ifta nd t′are independent, then the
s
equencescontaining tt′andt′t, respectively,areinthesameequiv-
alence class. Thisimpliesthat theconcurrent program willendup
inthesamestateregardlessoftheexecutionorderof tandt′.
C
omputing the equivalence classes rests on the concept of a de-
pendency relation. In classic POR methods such as DPOR, the
dependency relationistypicallydeﬁnedwithrespecttotheconcur-
rentsystemitself,withoutconsideringthepropertiestobechecked.
Godefroid [15] formalizes the general requirement for a relation
overconcurrentoperationstobeadependency relationasfollows:
Deﬁnition 1. LetTbethesetoftransitionsand D ⊆ T ×T be
abinary,reﬂexive,andsymmetricrelation. Disavaliddependency
relationforthesystemiffforall t1t2∈ T,(t1,t2)/ne}ationslash∈ D(t1andt2
areindependent) impliesthatthetwofollowingpropertiesh oldfor
allstatessinthestatespace AGofthesystem:
1
. ift1isenabledin sa ndst1−→s′,thent2isenabledin si fft2
is enabled in s′(independent transitions can neither disable
n
orenableeachother),and
2. ift1andt2are enabled in ss uch thatst1t2==⇒s′andst2t1==⇒
s′′,thens′mustbethesameas s′′(commutativityofenabled
i
ndependent transitions).
A stricter deﬁnition of the dependency relation would result in
fewer equivalence classes, which in turn corresponds to fewer ex-
ecutions to be explored. However, accurately computing the de-
pendencecanbedifﬁcult;theDPORalgorithmuses conﬂict depen-
dencemainlybecauseitiseasytocompute.
A subset Tof the transitions enabled at a state sis said to be
persistent insif each transition not in Tdoes not interact with
T. It has been proved [15] that exploring only transitions in the
persistentsetofeachstateguaranteesdetectionofalldeadlockand
assertionviolations. Belowisaformaldeﬁnitionofpersistentsets.
Deﬁnition 2. AsetToftransitionsenabledinastate sispersis-
tentinsiffforallnonemptysequencesoftransitions
s=s1t1−→s2t2−→s3...tn−1−−− →sntn−→sn+ 1
fromsi n AGandincludingonlytransitions ti/ne}ationslash∈T,1≤i≤n,tn
isindependent withalltransitionsinT.
2
.3 DynamicPartialOrderReduction
Early partial order reduction algorithms (such as in [15]) stati-
callycomputedthepersistentset,butlimitationssuchasimprecise
pointer alias information often caused the persistent set to over-
approximate dependence of transitions, causing equivalent traces
tobeexplored. Dynamicpartialorderreduction[13]addressedthis
issue by focusing on one execution trace at a time, where precise
aliasinformationcanbeobtained,andbycomputingthenecessary
transitionstoexploredynamicallyusing backtrack sets .
177Algorithm1showsthepseudocodeoftheDPORalgorithm. The
algorithm performs a depth-ﬁrst search through the state space of
AGstarting with the initial state s0. The stack represents a ﬁnite
t
ransition sequence S∈ T∗,t1t2...tn, from the states s1...sn
such that s1t1−→s2t2−→...tn−→sn+ 1. Here,d om (S)means
the set{1,...,n},pre(S,i)fori∈dom(S)refers to the state
si,l ast(S)refers tosn+ 1,n ext(s,p)is the unique transition to
be executed by process pin states, andproc(t)is the thread that
executedthetransition t. Ahappens-before relationonasequence
S,i→Sp, fori∈dom(S)and process pis a relationindicating
causalitybetweenthetransitionexecutedat iandp.
Each state shas a backtrack set, denoted backtrack (s). The
backtrack set of a state srepresents the set of processes at swith
enabledtransitionsthatstillneedtobeexploredfrom s.
TheDPORalgorithmstartsbycalling Explore()withanempty
stack. The stackrepresents the set of transitions executed toreach
last(S)(Line 2). Line 4examines the next transitionof each pro-
cess from s(next(s,p)). The algorithm then examines Sto ﬁnd
thelasttransition(ifitexists)thatis
1. dependent with next(s,p),
2. maybeco-enabledwith next(s,p),and
3.i/ne}ationslash→Sp.
S
tep 1 uses the conﬂict dependency relation. Upon ﬁnding a con-
ﬂicting transition iinS, a backtrack point is inserted in the state
pre(S,i). Which process to add into the backtrack set is deter-
mined on Line 5. Here, the algorithm attempts to ﬁnd the set E
ofenabledprocessesin pre(S,i)thathappen-before next(s,p)in
thecurrentsequence. Thehappens-before relationsigniﬁescausal-
ity; executing a transition of a process in Ewill cause the transi-
tionnext(s,p)to be executed. If such a causality relationship is
not found ( Eis empty), then the algorithm over-approximates by
addingalltheenabledtransitionsin pre(S,i)tothebacktrackset.
Overall,thegoalofLines5–10istoﬁrstidentifytwodependent
transitionsinthecurrentsequenceandtheninsertabacktrackpoint
to potentially reverse the order of execution of the dependent tran-
sitions in a future execution. The algorithm, on Lines 13 through
20,continuesthedepth-ﬁrstsearchbyexploringeachnon-explored
transition from a state’s backtrack set. The authors of [13] proved
that the backtrack sets explore a set of transitions from each state
swhichispersistent in s. Asaresult,theyareabletoleverage the
theoremsfrom[15]toensurethatDPORwillﬁndalldeadlockand
assertionviolationsinanacyclicconcurrentprogram.
However,neitherDPORnoranyotherexistingPORmethodcon-
sidered the properties to be checked while computing the depen-
dency relation. We shall show in the next section that, by taking
the properties into consideration, we can often obtain a more re-
ﬁneddependencyrelation,whichleadstoadrasticreductioninthe
numberofequivalence classes.
3. ASSERTIONGUIDEDABSTRACTION
Inthis section, we introduce the new notion of predicate depen-
denceto soundly reduce the number of thread interleavings. We
refertothismethodas assertion guided abstraction .
3.1 PredicateDependencyRelation
We modify the general requirement for a relation over concur-
rent operations to be a valid dependency relation by considering
the inﬂuence on the outcome of assertion checking. The new re-
quirement,ascomparedtoDeﬁnition1,isgivenasfollows:
Deﬁnition 3. LetTbethesetoftransitionsand D ⊆ T ×T be
abinary,reﬂexive,andsymmetricrelation. Disavaliddependency
relationforthesystemiffforall t1t2∈ T,(t1,t2)/ne}ationslash∈ D(t1andt2
areindependent) impliesthatthetwofollowingpropertiesh oldfor
allstatessinthestatespace AGofthesystem:if(cond)
x = 1;x = 7;
x = 5;
y = x + 2;
Figure4. Examplesforcontrol(left)anddatadependency(right).
1. ift1isenabledin sa ndst1−→s′,thent2isenabledin si fft2
is enabled in s′(independent transitions can neither disable
n
orenableeachother),and
2. ift1andt2are enabled in ss uch thatst1t2==⇒s′andst2t1==⇒
s′′,thens′canleadtoabadstateiff s′′canleadtothesame
b
ad state (commutativity of enabled independent transitions
ispredicatedonpropertychecking).
Inotherwords,twotransitions t1andt2arep redicate-dependent
if and only if the relative execution order of t1andt2can affect
w
hetheranerrorstateisreachedornot. Otherwise,theyareconsid-
eredtobe predicate-independent . Anerrorstateisanystatewhere
apropertyisviolated. Wefocusontwotypeoferrorsinthiswork:
assertionviolationsanddeadlocks.
Deﬁnition 3 induces an abstraction of the system’s interleaving
spacetoignoreoperationsthatareconﬂict-dependentandyetunre-
latedtothevalidityoftheproperties. Alternatively,theabstraction
is transforming the original program into a simpler program, con-
tainingonly those program statements thatcan cause anerror. We
calltheseprogramstatements essential statements .
Inthenextsubsection,weexplainthatbyusingpredicatedepen-
dencetoreplaceconﬂictdependenceinDPORwecanobtainanew
dynamicanalysismethodthatismoreefﬁcientandatthesametime
guarantees that no error states are missed. Here, the error state is
a state where the assertion fails or a deadlock occurs. The essen-
tial statements are all the statements whichcould affect assert and
lock/unlock calls. Throughout this section, we shall focus our dis-
cussion on dealing with a single assertion statement. The case for
multipleassertionsand/orlockcallswillbesimilar.
3.2 CorrectnessoftheReduction
First,weintroducetheconceptofcontrolanddatadependencies.
Figure 4 (left) shows an example of the control dependency. The
statement on Line 1 determines if the statement on Line 2 is exe-
cuted. In other words, Line 2 is control dependent on Line 1. In
general, a statement bis said to be control dependent on another
statement aif and only if there exists a path from atobsuch that
every statement c/ne}ationslash=ainthe path is post-dominated by bandais
notpost-dominatedby b.
Figure 4 (right) shows an example of a data dependency. The
value ofyon Line 2 is dependent on the value of xon Line 1. A
statement ais said to be data dependent on another statement bif
and only if both statements access the same memory location and
at least one of them stores into it, and there is a feasible run-time
executionpathfrom atob.
Furthermore, the order in which statements are executed deter-
mines their dependency relation. For example, Line 3 of Figure 4
(right)isdata dependent onLine 2but notLine 1. Thisisbecause
the write onLine 2to xoverwrites the writeon Line1. The same
idea applies if all three lines of Figure 4 (right) were executed by
three different threads. Line 3 would be dependent on either Line
1 or Line 2 depending on the thread scheduling. We will use this
conceptofchangesindependencies toproveourmethodissound.
To prove that predicate dependence based reduction is correct,
weuseTheorem2.2from[25]asalemma,whichstates:
LEMMA1.Anyreordering transformationthatpreservesevery
dependence inaprogram preserves themeaning ofthat program.
178Algorithm1 Classicdynamicpartialorderreductionalgorithm.
Initially: Explore(∅ )
1:procedure EXPLORE(S)
2:s←last(S)
3:forallprocesses pdo
4:if∃i=max({i∈dom(S)|Siisdependent andmaybeco-enabledwith n ext(s,p)andi/\e}atio\slash→Sp} )then
5: E←{q∈enabled(pre(S,i))|q=p∨∃j∈dom(S) :j > i∧q=proc(Sj)∧j→Sp}
6
: ifE/\e}atio\slash=∅then
7: addany q∈Etobacktrack (pre(S,i))
8: else
9: addallq∈enabled(pre(S,i))tobacktrack (pre(S,i))
10: endif
11:endif
12:endfor
13:if∃p∈enabled(s)then
14: backtrack (s)←{p}
15: done←∅
16:while∃p∈(backtrack (s)\done)do
17: addptodone
18: Explore (S.next(s,p))
19:endwhile
20:endif
21:endprocedure
The proof for Lemma 1 in[25] was based on the fact that a sin-
glestatement will produce a different result if and only if its de-
pendencies change. Thus, if every statement has its dependencies
preserved,theprogramwillnotproduceadifferentresult.
Deﬁnitions such as conﬂict dependence use Lemma 1 to test
all possible outcomes of the program caused by concurrent non-
determinism. Each reordering performed by conﬂict dependence
is a change in the dependencies of the program. However, this is
oftenunnecessarilystrong. Wearenotinterestedinhowreordering
affectstheentireprogrambutonlyessentialstatements. Wepresent
thisideainthefollowingcorollary:
COROLLARY 1.Any reordering transformation that preserves
every dependence of astatement willnot affect the outcome of that
statement.
Using Corollary 1, we can prove that using predicate dependence
in DPOR to replace the conﬂict dependence will result in a sound
reduction,whichisstatedformallyasfollows:
THEOREM 1.Predicate dependence, as deﬁned inDeﬁnition3,
willnot cause any error state tobe missed.
PROOF. First, two transitions, t1andt2, affect the reachability
o
f an error state only if they are control or data dependent with
theessentialstatements(e.g.,assertions,lock/unlockcalls). Ifthey
areneithercontrolnordatadependentwithanyessentialstatement,
thenbasedonthedeﬁnitionsofcontrol/datadependenceandessen-
tialstatements,theycannotaffectthereachabilityoftheerrorstate.
Now we prove the theorem by contradiction. Assume that t1
andt2are not predicate dependent, but one of their two execution
o
rderscanresultinanerrorstate serrbeingmissed.
•S
ince one of the two execution orders leads to serrbeing
m
issed, by Corollary 1 this means that the order of t1and
t2does not preserve the dependencies of the essential state-
m
ents.
•However, ifthe dependencies of the essential statements are
not preserved, thenby deﬁnition, t1andt2are predicate de-
p
endent,whichcontradictsourassumption(thattheyarenot
predicatedependent).
Therefore,ourassumptionisnotcorrect;thetheoremisproved.However, there is difﬁculty inusing Theorem 1 during a purely
dynamicanalysis,becausecheckingwhether t1andt2arecontrol/-
d
ata dependent atruntimeis notaneasytask. Although intheory,
we could have pre-computed the control/data dependency relation
between all pairs of potentially concurrent operations in a purely
static manner before starting the dynamic analysis, it would be
computationallyexpensive,andatthesametime,difﬁculttoobtain
accurate results due to the limitations in a static inter-procedural,
inter-thread, dependency analysis. Instead, we propose a new co-
operative static–dynamic framework. Theideaistoget thebestof
bothworlds,sincestaticanalysisisabletogetanapproximationof
theentireprogram whiledynamic analysis isable toprovideinfor-
mationonaliasingandfeasibleexecutions.
4. THECOOPERATIVEANALYSIS
Inthissection,weprovideanoverviewofournewmethodshown
in Algorithm 2. The input is the program under test ( P) together
with data input ( I). Subprocedure Instrument adds monitoring and
controlcapabilitiestotheprogramtoprepare itfordynamic analy-
sis. Subprocedure IfConvertconvertsallassertionstatementsofthe
formassert(c) intoif(!c) ERROR . Subprocedure Depen-
denceCalculate analyzes the program and returns the dependency
relationships. Subprocedure execrunstheprogram-under-testwith
our scheduler. Subprocedure Exploretakes the dependency rela-
tionsandperformsanexplorationoftheinterleavingspace.
Algorithm2 Highleveloverviewofournewanalysismethod.
1:P←programundertest
2:I←programinputs
3:P←Instrument (P)
4:P←IfConvert (P)
5:dep←DependenceCalculate (P)
6:exec(P,I)
7:Explore (∅,dep) ⊲Algorithm4
The bulk of the static analysis takes place in DependenceCal-
culate. This procedure collects all the interprocedural control and
data dependencies of each statement of interest (e.g., assert, lock-
/unlockcalls)whileignoringaliasing. Wewillexplainhowwedeal
withaliasing insubsection 4.2. The process of collecting interpro-
179cedural control and data dependencies is the generation of the in-
terprocedural slice of each statement. Wewill explainour method
for computing the interprocedural slice in subsection 4.1. For a
more comprehensive description of existing methods for creating
theinterproceduralslice,pleasereferto[21]and[41].
4.1 ControlandDataDependencyAnalysis
In our cooperative framework, we divide our approach to inter-
threadcontrolanddatadependencyanalysisintothreesteps:
1. intraproceduralcontrolanddatadependency computations,
2. interproceduralcontrolanddatadependency computations,
3. inter-threadaliascomputations.
Steps 1 and 2 are purely static and they are carried out only once,
beforethedynamicanalysisprocedurestarts,whereasStep3isdy-
namic – the alias information is updated incrementally while the
DPORalgorithmisrunning.
Thestaticanalysismethods usedinthisapplicationarerequired
to be over-approximated. That is, as long as the execution order
oftwoconcurrent operations t1andt2maya ffecttheproperty, the
staticanalysismethodmustensurethat t1andt2aredependent.
O
urmethodusesanintermediateprogramrepresentationknown
as theprogram dependence graph (PDG) [12]. For a given proce-
dure, a PDG explicitly provides both the control and data depen-
dencies. The transitive closure of control dependences is the con-
trol dependence graph; a node in the control dependence graph is
a statement and an edge from node xto nodeyindicates that yis
control dependent on x. The data dependence graph can be cre-
ated similarly. Whencombined for a single procedure, the control
and data dependence graphs are the twosubgraphs of the program
dependence graph[12].
Thesystemdependence graph[21]isaninterproceduralversion
of the program dependence graph. It consists of the program de-
pendence graphs for each procedure as wellas additional edges to
include (1) direct dependencies between call siteand calledproce-
dure, and (2) transitive dependencies due to calls. As an example,
consider the program in Figure 5 (top) and its system dependence
graph (bottom). Controldependencies betweenstatements arerep-
resented as edges witha diamond head, edges withan arrow head
are data dependencies, and dashed edges are dependencies due to
functioncallsandparameterpassing.
Theparameterinputsoffunction addarerepresentedinthenodes
ainandbinand the output inthe node aout. To handle parameter
p
assing, twoadditional nodes in mainare added ( ain=s umand
bin=i) and connected to the addprocedure. These extra nodes
can be thought of as stack frames to handle pass-by-value seman-
tics. Theprogramdependencegraphof mainandaddarethenodes
reachablefromthenodes Entermain andEnteraddexcludingfunc-
tioncallsandparameterpassing(dashededges).
For a given node s(statement) inthe system dependence graph,
an interprocedural sliceis the graph containing all nodes that can
reachs. Theusefulnessofasliceon sisthatitcontains allpossible
statementsthatcouldinﬂuence s(Corollary1).
4.2 ComputingAliasInformationontheFly
ForlanguagessuchasC/C++,aliasingbecomesanissueforcre-
ating slices. Consider a slice Son program statement signoring
aliasing.Scontainsonlythestatementswhichcoulddirectlyaffect
either the execution of s(control dependencies) or the value used
bys(datadependencies). Inthepresence ofaliasing, Salsoneeds
tocontainanyotherstatement intheprogram whichcould aliasto
anystatementalreadyin S. Theseareadditionaldatadependencies
causedbyaliasing. Together,theyrepresentthecomplete setofall
statementsthatcouldinﬂuence s.
To see the effects of aliasing, consider the example program in
Figure 6. A thread is accessing the ﬁrst six elements of a shared
arrayof12elements. Similarly, maintakesanindexasinputfrom1intadd(inta, b) {
2returna + b;
3}
4intmain() {
5intsum = 0, i = 1;
6sum = add(sum, i);
7if(sum!=1) assert(0);
8}sum=0 i=1
sum=add out
assert(0)ain=sum bin=i
if(sum/ne}ationslash=1)addout=a+ba=ain b=bin
Figure5. Aprogram (top)anditssystemdependence graph(bot-
tom). Diamondheadededgesarecontroldependencieswhilearrow
headed edges are data dependencies. Dashed lines represent func-
tioncallsandparameterpassing.
1intarray[12];
2voidthread1() {
3for(inti = 0; i < 6; ++i) {
4 array[i] = array[i] + 1;
5}
6}
7intmain(intargc,char*argv[]) {
8intidx = atoi(argv[1]) % 12;
9thread_create(thread1);
10 array[idx] = array[idx] + 1;
11}
Figure6. Aexampleprogramshowingtheeffectsofaliasing.
the user (Line 8) and increments the array at that index. Aliasing
couldoccurbetweenthetwoaccessestothearray(Lines4and10).
The situation is complicated because the array index accessed by
mainis based on user input; a conservative static analysis would
assume that the user could pass anything. Thus, the statements on
Line4and10wouldalways alias. Wewillshow inthissubsection
howourcooperativestatic–dynamicapproachavoidsthisproblem.
The program representation shared between the static and dy-
namic analysis frameworks are program statement IDs. Speciﬁ-
cally, each statement in a program is given a unique integer ID.
Intuitively, this provides a method of communication between the
twoframeworks. Inourcooperative analysismethod,theoutputof
the static analysis is a set of program statement IDs representing
the slice on each erroneous statement ignoring aliasing. The goal
ofourdynamic analysisistoextendthesliceswithinter-threadde-
pendency information. Dynamic partial order reduction (DPOR)
ﬁtsthistaskperfectly;thegoalofDPORistodynamicallyenumer-
ateallrelevanttracesofaconcurrentprogram.
Thestatic analysis ismade simpler since itnolonger has torea-
son about complex thread interactions (such as mutex locks) or
inter-thread aliasing. Also, the issue of calculating dependencies
becomes not only simple for a dynamic analysis but it is also ac-
curate;itisguaranteedthatanypossibledependencies observedby
the dynamic analysis are ones which could possibly occur in the
program(therearenofalsepositives).
DPORgenerates a set of sequences of program transitions each
corresponding to an execution of the program. The entire set of
sequences producedbyDPORcontainsatleastonesequencefrom
each equivalence class. The transitions are dynamic instances of
eachprogramstatement. Duetotheirdynamicnature,thesequences
of transitions contain the memory address used in every memory
1801inta;
2voidthread1( void) {
3a = 0;
4}
5voidthread2( void) {
6a = 1;
7if(a != 1)
8 assert(0);
9}
Figure7. Exampletoshowstatic–dynamicslicecreation.
readandwrite;inthecontext ofstaticanalysis,thismeansthatwe
havecompletealiasinformationfortheentiresequence.
Algorithm3showsthepseudocodefor UpdateSlice ,whichtakes
asinputatransitionsequence(ρ )generatedfromDPORandasetof
statements on a slice Sli. It updates Slito contain the inter-thread
dependencies observed in ρ. The for-loop on Lines 5–11 checks
eachpairoftransitionsaccessingthesameobjectin ρtoseeifthey
should be added to the slice. We use obj(t)to represent the object
accessedby t,Sli.contains(t) toreturntrueifthestatementexecuted
by transition tis on the slice and Sli.insert(t) inserts the statement
executedby ttotheslice. Notethat ⊕denotesXOR.
Statementsshouldbeaddedtothesliceifoneofthestatementsis
alreadyonthesliceandtheyareaccessingthesameobject. Thisis
thesituationwhenastatementontheslicealiasestoonenotonthe
slice. Theentireprocedure isaﬁxpointcomputationuntiltheslice
is no longer updated. The ﬁxpoint isrequired because whenever a
transition tis added to the slice all the statements not on the slice
whicharedependent with talsoneedtobeadded.
Algorithm3 Proceduretoupdatetheslice Sliwiththedependence
informationobservedinthesequenceoftransitions ρ.
1:procedure UPDATESLICE(ρ,Sli)
2:SliceUpdated←true
3:whileSliceUpdated do
4: SliceUpdated←false
5:forallt1,t2∈ρs uchthat obj(t1) =o bj(t2)d o
6: ifSli.contains (t1)⊕S li.contains (t2)t hen
7: SliceUpdated←true
8: Sli.insert (t1)
9
: Sli.insert (t2)
1
0: endif
11:endfor
12:endwhile
13:endprocedure
Thecombinationofdynamicallycalculatedinter-threadaliasing
usingUpdateSlice and statically calculated control and data de-
pendenciescompletestheslicingalgorithm. Inthenextsection,we
show how this algorithm is combined with DPOR to implement
predicate dependence. Note that intra-thread aliasing is handled
staticallyduringthecontrolanddatadependencyphase.
Example. Consider the multithreaded program in Figure 7, where
two threads access a shared variable a. Assume that the line num-
ber of each statement represents the statement ID. First,we gener-
ate the slice on the assertion ignoring aliasing. The slice contains
Lines8(theassertionitself),7(acontroldependency)and6(adata
dependency). Notice that the sliceis missinga crucialcomponent,
thealiasedwriteto abytheﬁrstthreadonLine3.
DPORgenerates threesequences oftransitionsforthisexample.
Theyare: S1= 6,7,3,S2= 6,3,7,8a ndS3= 3,6,7. Next,we
runUpdateSlice oneachsequence;theresultsaresummarizedfor
S1in Table 1. The table shows how the slice is updated for each
p
airexaminedin S1(i.e.,thetableistheﬁrstiterationofthewhile-Sequence Pair Slice SliceUpdated?
Initially: {8,7,6}
S1 (3,6) {8,7,6,3} true
S1 (3,7) {8,7,6,3} true
S1 (6,7) {8,7,6,3} true
Table1. Exampleofrunning UpdateSlice (Algorithm3)onase-
quenceoftransitionsgeneratedbyDPORfromtheprograminFig-
ure 7. Theprocedure continues torunontheremaining sequences
butnomodiﬁcationsaremadetotheslice
loop in Algorithm 3). Column 3 is the value of SliceUpdated in
the ﬁxpoint computation for S1. While examining S1, the slice is
u
pdated;Column4staystrueuntilaftertheﬁrstiterationoftheﬁx-
pointcomputation. Duringthenextiterationon S1,noupdatesare
m
ade to the slice. Examining the remaining two sequences shows
thattheﬁnalslicecontains {8,7,6,3};theupdateto abyThread
1isnowincluded.
4.3 DPORbasedonPredicateDependence
Now, we explain how DPOR (Algorithm 1) can be modiﬁed to
includepredicatedependence. Theonlyadditionalinputisasetof
program statements onthe slice (ignoring aliasing) of everyessen-
tialstatement. Weincorporatethe UpdateSlice algorithmtodynam-
icallycalculatealiasingfromtheprevioussubsection.
The major change to Algorithm 1 is that backtrack set is com-
puted at the end of each execution. This is required because we
need to examine the entire sequence of transitions of anexecution
inordertodynamicallyupdatethestatementscontainedintheslice.
Algorithm 4 introduces an additional notation to describe a se-
quence of transitions Sand a state s. Here,predom(S,s)is the
setfrom{1,...,n}wherenisthenumber oftransitionsthathave
occurred before the state s. This the same as dom(S)ifSonly
containedthesequences oftransitionsleadingupto s.
Lines 13–24 implement updating the backtrack set (similar to
Lines3–11inAlgorithm1)aftertheentireexecutioniscompleted.
Line 12 is the ﬁxpoint computation, Algorithm 3, to dynamically
expand the slice to include alias information from the current se-
quence. The dependency relation (Line 15) is from Deﬁnition 3.
Other than these modiﬁcations, Algorithm 4 is the same as Algo-
rithm1.
5. OPTIMIZINGPREDICATEDDPOR
In this section, we introduce two new optimizations in DPOR.
One optimization, called critical section peeking, is applicable to
all properties, whereas the other optimization, called write–write
pruning,isapplicabletocheckingassertions.
5.1 CriticalSectionPeeking
Deﬁnitionssuchaspredicatedependenceandconﬂictdependence
consider mutex lock calls to be dependent if they are locking the
same mutex and never consider the items in the critical section
of the mutex. However, they can be unnecessarily inefﬁcient in
manycases. Asmotivation,considertheprograminFigure8. Two
threadsareincrementingvaluesinanarrayof16integers. Thread1
isincrementingitems0–7andthread2isincrementingitems8–15.
AstandardDPORimplementationrequires12,870runstotestthis
program even though the two threads will never access the same
memory location. In contrast, our new automated optimizations
canreducethetheexplorationdowntoonerun.
We deﬁne critical section peeking as follows. Let m1andm2
be two mutex lock calls and c s1andc s 2be the statements in the
c
riticalsectionsprotectedby m1andm2,respectively. Twomutex
l
ockcallsaredependent iffcondition1istrueandeithercondition
2orcondition3istrue:
1. Thetwolockcallsaretothesamemutex
181Algorithm4 Predicateddynamicpartialorderreductionalgorithm.
1:Slices←sliceofeveryessential statement,ignoring aliasing
Initially: Explore(∅ ,Slices)
2:procedure EXPLORE(S,Slices)
3:s←last(S)
4:if∃p∈enabled(s)then
5: backtrack (s)←{p}
6: done←∅
7:while∃p∈(backtrack (s)\done)do
8: addptodone
9: Explore (S.next(s,p),Slices)
10:endwhile
11:endif
12:UpdateSlice (S,Slices ) ⊲Algorithm3
13:forallStates s′inSd o
14:forallprocessespdo
15: if∃i=max({i∈predom(S,s′)|Siispredicatedependent andmaybeco-enabledwith n ext(sp)andi/\e}atio\slash→Sp} )then
16: E←{q∈enabled(pre(S,i))|q=p∨∃j∈predom(S,S′) :j > i∧q=proc(Sj)∧j→Sp}
1
7: ifE/\e}atio\slash=∅then
18: addany q∈Etobacktrack (pre(S,i))
19: else
20: addallq∈enabled(pre(S,i))tobacktrack (pre(S,i))
21: endif
22: endif
23:endfor
24:endfor
25:endprocedure
mutex array_lock;
intarray[16];
voidthread_1() {
for(inti = 0; i < 8; ++i) {
lock(array_lock);
array[i] = array[i] + 1;
unlock(array_lock);
}
}
voidthread_2() {
for(inti = 8; i < 16; ++i) {
lock(array_lock);
array[i] = array[i] + 1;
unlock(array_lock);
}
}
Figure 8. A motivating example for critical section peeking. A
single mutex protects an entire array. This causes a DPOR algo-
rithmtotestallorderings of arrayaccesses even iftwothreads are
accessingdifferentitemsofthearray.
2.∃s∈ {cs1∪c s2} |si snotamemoryaccessingtransition
3.∃s1∈c s1| ∃s2∈c s2|s1isdependentwith s2
In DPOR, when two mutex lock calls are reordered the effec-
t
iveresultisthat allofthetransitionsinthecriticalsectionsarere-
ordered. In essence, critical section peeking only reorders critical
sectionswhenitisnecessary. Item2preventsdeadlocksfrombeing
missed;twocriticalsectionscontainingadditionalmutexlockcalls
could, when called in a certain order, result in a deadlock even if
they are not dependent on each other. Item 3 results in the signiﬁ-
cant reduction for programs such as in Figure 8; the mutexes only
need to reordered if they are protecting memory accesses which
could interfere with each other. When using critical section peek-
ing,noneofthemutexlockcallsinFigure8willbedependent;this
results in only onerun of DPOR to be required. Critical section
peeking is implemented dynamically by examining the statements
inthecriticalsectionoftwolockcallstothesamemutexusingthe
dependence rulesdeﬁnedpreviously.5.2 Write–WritePruning
There are three combinations of shared memory access events
betweentwothreads: read–read,read–write,andwrite–write. Two
read accesses, even from two different threads, can never affect
eachother regardless of theirorder of execution. Thus, inthis sec-
tion, we focus on read–write and write–write, and show how sup-
plementalinformationcangeneratefewerMazurkiewicztraces.
inta = 0;
voidt1_main(){
a = 7;
a = 6;
}
voidt2_main() {
a = 0;
a = 1;
}
intmain(intargc,char*argv[]) {
thread_create(t1_main);
thread_create(t2_main);
thread_join(t1_main);
thread_join(t2_main);
assert(a != 7);
return0;
}
Figure9. Aread–(write–write)conﬂictbetweenthreethreads.
We divide write–write conﬂicts into two new categories: write–
writeandread–(write–write)conﬂicts.
THEOREM 2.If two writes to the same shared variable, x, by
differentthreads, t1andt2,are adjacentinatrace,thenregardless
o
f the order of the writes to xbyt1andt2, no assertion violations
l
ocal tot1andt2willbe missed.
T
hekeyrestrictiontoTheorem2isthatassertionsinsidethetwo
threadsareneverviolated. Theremaybeassertionsinotherthreads
thatcouldbeviolatedduetotheorderofwritesbythetwothreads.
This can be thought of as a read–(write–write) dependency; the
182order of two writes affects the value read by another thread. In
DPOR,thiscanonlyhappenwhenthereisathirdthread, t3,which
r
eadsthesamelocationinmemoryasiswrittentoby t1andt2,and
t3may not be co-enabled with t1andt2while they are writing to
x.
Weformalizethisconceptinthefollowingtheorem.
THEOREM 3.If two different threads, t1andt2, are executing
a
sequence of operations, S1andS2respectively, both including
s
omenumberofwritestothesamesharedmemorylocation, x,then
the order of execution of t1andt2writing to xw ill only affect
assertion violations if bothof the following hold:
1. there exists a shared memory read of xby a distinct third
threadt3which cannot be co-enabled with either t1ort2
duringS1orS2,
2
. thewriteto xinS1byt1isthelastwriteto xb yt1beforet3
is enabled, and
3
. thewriteto xinS2byt2isthelastwriteto xb yt2beforet3
is enabled.
T
he case when t3can be co-enabled during either S1orS2, vi-
o
lating condition one of Theorem 3, changes the problem from a
read–(write–write) conﬂict to simply a read–write conﬂict. Con-
sider the example of a write–write conﬂict between two threads
and a single assertion check in Figure 9. Furthermore, maincre-
ates and joins the two threads. The key insight is that maincan
never be co-enabled with any of the writes. This situation is cap-
tured by Theorem 3; the read by mainwill only be able to read
the last value writtenby each thread (either 6or 1). DPOR would
require6runsbutinrealityonly2runsarenecessary.
6. EXPERIMENTALRESULTS
We have implemented our new method in a tool called Käse
based on the LLVM platform for static analysis and code instru-
mentation and on a modiﬁed version of Inspect[42] for system-
atic exploration of a concurrent program. Our tool runs both with
andwithouttheproposedoptimizationsandcanhandleunmodiﬁed
C/C++codeusingPThreads. WeusetheDPORimplementationin
Inspectasabaselineforcomparison.
Ourexperimentsweredesignedtoanswerthefollowingresearch
questions: (1) How effective is our new method? In practice, is it
able to show signiﬁcant improvement over DPOR? (2) How scal-
ableisournewmethod? Canithandlerealisticprograms?
We evaluated our tool on 46benchmarks from twogroups. The
ﬁrst group are a set of small programs from the Software Veriﬁ-
cation Competition (SV-COMP) [34] as well as two of our own
synthetic examples. The second group is a set of real-world open
sourceprograms: nbds[28]isaCimplementationofseveralnon-
blocking data structures. nedmalloc [29] is a thread-caching
mallocimplementation. pfscanisaparalleldirectoryﬁlescanner.
Whenpossible,weusedtestsandinputsprovidedbytheauthors.
Figures 10 and 11 summarize the results of all our tests. The
graphsshowacomparisonofourmethodsversusDPORintermsof
numberofrunsandruntimerequiredtotestaprogramrespectively.
Figure 10 shows that our method is always capable of testing a
program in the same number of runs as DPOR and in some cases
canoffer signiﬁcantreduction. Figure 11shows similarresultsfor
theruntime. Inmostcases,ourtoolincursaminimaloverheadand
canresultsinsigniﬁcantreductioninruntime. Thecaseswherethe
runtimewassigniﬁcantlyhigheroccurredwhenareductioninruns
occurredbutthestaticanalysistooklongerthanthesavingincurred
duringdynamicanalysis.
Table2showsthe statisticsfromtestswhere areductioninruns
occurred. Column 1shows the name of each benchmark. Column
2 shows the number of lines of code in the benchmark. Column 3
showsthenumberofassertionsinthebenchmark. Column4shows
the maximum number of threads in the benchmark. Columns 5–7100102104100102104
DPORPred-DPOR
Figure 10. Results: comparing the number of runs of predicated
DPORandbaselineDPORon46benchmarkexamples.
10−210110410−2101104
DPORPred-DPOR
Figure 11. Results: comparing the execution time of predicated
DPORandbaselineDPORon46benchmarkexamples.
show the time required to test the program for DPOR, predicate
dependence, andpredicate dependence withoptimizations, respec-
tively. Similarly, columns 8–10 show the number of runs for each
method. Weallottedamaximumoftwohoursforeachtest;an ✗in
columns 5–10 indicates that the method exceeded two hours. All
testswererunonamachinewitha2.60GHzIntelCorei5-3230M
processorwith8GBRAManda64-bitLinuxOS.
First, the results show that our method is more efﬁcient than
DPOR.Ontheﬁrstsetofbenchmarks,bothDPORandourmethod
can complete and the difference in runtime is small. However, on
largeprograms,suchas nbds,pfscanandnedmalloc ,DPOR
couldnotﬁnishwhereasourmethodwasabletoﬁnishinareason-
ableamountoftime. Forsomeexperiments,ournewoptimizations
wererequiredtohavegoodperformance, sincetheprograms make
heavyuseofmutexes.
Second, as a measure of the scalability of our method, we con-
ductedtestsontwoparameterizedprograms: IndexerSafe and
nbds-hashtable .IndexerSafe isanimplementationofFig-
ure1. Wevariedthenumberofthreadsfrom11to15;theresultsare
summarized in Figure 2. The number of runs required for DPOR
grows exponentially with the number of threads while optimized
predicate dependence stays at a constant one run. Critical section
peeking was required for this benchmark since the compare-and-
swap operations were implemented using mutex locks. The pro-
gramnbds-hashtable was parameterized by the number of
compare-and-swap operations used by two threads. We varied the
number of operations from four to eight. The results are summa-
rized in Figure 12. Predicate dependence both takes a lower num-
berofrunsandhasslowergrowthwhencomparedtoDPOR.Once
8operationsareperformed,DPORexceedsthetwohourtimelimit
while predicate dependence is able to ﬁnish in just over two min-
utes. Experiments where predicated DPOR ﬁnishes inone runare
possible because our method concludes that the property does not
dependonconcurrentnon-determinism.
183Table2. ExperimentalresultsforasubsetofthetestprogramstoillustratetheimpactofpredicatedDPORandthetwooptimizations. LOC
is the number of lines of code. Assertis the number of assertions in the ﬁle. Threadis the maximum number of threads running in the
program. Resultsare givenfor different levelsof optimization: DPORisthe original DPORimplementation. Pred-DPORis thepredicated
DPOR. Pred-DPOR-opt is the predicated DPOR with optimizations. For the Pred-DPOR columns, the time includes the static analysis
requiredtocreatetheslice. Themaximumtestingtimewastwohours;testsexceedingthistimearemarkedwithan ✗.
Time(s) Runs
Name LOC Assert Thread DPOR Pred-DPOR Pred-DPOR-opt DPOR Pred-DPOR Pred-DPOR-opt
AccountBad 60 1 4 0.05 0.06 0.05 4 4 3
BluetoothBad 88 1 2 0.19 0.11 0.11 23 9 9
ReadReadWrite 50 1 3 0.07 0.04 0.03 7 3 3
ReadWriteLock 55 1 5 22.03 0.49 0.41 1983 28 28
Stateful 54 1 3 0.02 0.03 0.02 6 6 2
IndexerSafe12 92 1 12 0.57 0.69 0.15 8 8 1
IndexerSafe13 92 1 13 4.64 5.28 0.17 64 64 1
IndexerSafe14 92 1 14 36.03 43.07 0.22 512 512 1
IndexerSafe15 92 1 15 282.06 357.24 0.43 4096 4096 1
nbds-list 1887 1 3 ✗ 0.16 0.19 ✗ 1 1
nbds-hashtable4 2375 24 3 37.11 25.04 25.02 641 36 36
nbds-hashtable5 2375 24 3 68.05 25.35 25.30 999 36 36
nbds-hashtable6 2375 24 3 1082.00 38.76 37.74 16441 216 216
nbds-hashtable7 2375 24 3 1828.59 74.32 73.08 25623 216 216
nbds-hashtable8 2375 24 3 ✗ 140.28 138.04 ✗ 1296 1296
nbds-hashw01 2322 1 3 39.36 45.50 46.69 641 601 601
nbds-hashw02 2322 1 3 1173.25 1199.29 1211.83 16441 14425 14425
nbds-hashw03 2234 1 3 942.99 8.29 7.66 14923 36 36
nbds-skiplistU1 1942 16 3 1.05 3.13 3.14 35 30 30
nbds-skiplistU2 1942 16 3 43.67 49.13 49.40 1057 913 913
nbds-skiplist 1994 1 4 ✗ 0.21 0.21 ✗ 1 1
nedmalloc 6303 9 5 ✗ 9.148 9.138 ✗ 1 1
pfscan 934 1 3 ✗ ✗ 61.24 ✗ ✗ 1666
4 5 6 7102103104
NumberofConcurrentOperationsRunsDPOR
Pred-DPOR
Figure12. Thenumber ofrunsversus thenumber ofCASopera-
tionsperthreadintestprogramnbds-hashtable.
7. RELATEDWORK
There is a large body of work in the model checking literature
onsoundlyreducingthestatespaceofaconcurrentsystem,includ-
ing persistent sets [16], stubborn sets [36], ample sets [32], sleep
sets[14,17],wakeuptrees[1],symmetry[43],andpropertydriven
pruning[39,37]. TherearealsoPORmethodsforSAT/SMTbased
bounded modelchecking[40,23,3]. However,theydonotexploit
the synergy between static and dynamic analysis in a cooperative
framework. Godefroid and Pirottin [16] introduced additional de-
pendence relationscomparedtoconﬂictdependence toreﬁningop-
erationsforvariablesofcertaintypes. Also,theyintroducetheidea
of conditional dependencies which are valid only at speciﬁcstates
inaconcurrent programasopposedtoallstates. However,theydo
notperformpropertydrivenreduction.
Coverage guided approaches to reducing the interleaving space
consider the space fully explored when a certain coverage condi-
tionismet. Thesemethodsincludepreemptionbounds[8,27],fair
bounds [8],delaybounding[11],HaPSet[38],variablebounds[5],
and thread bounds [5]. For example, a preemption bound of n
means that all sequences of transitions at which no more than n
preemptive context switches occur will be explored. The goal of
thesemethodsisnotveriﬁcationbutacceleratedbugdetection. Our
method of assertion guided abstraction can work along side cover-
agemetricstopotentiallyprovidefurtherreduction.There are non-systematic techniques for testing concurrent pro-
grams as well. Recent empirical studies of these algorithms can
be found in [35, 20, 19]. For example, ConTest [10] inserts de-
laysatsynchronizationpointstoattempttoincreasecontentionand
forcedeadlocksduringtesting. Twostageanalysissystemssuchas
CTrigger [31], CalFuzzer [22], PENELOPE [33], and Maple [44]
operate by ﬁrst statically or dynamically analyzing a program to
identify potentially buggy interleavings. Then, the tools take con-
trol of the scheduler and attempt to force the buggy interleavings.
While these methods scale well, our approach differs in that we
guaranteenottoproduce anyfalsenegatives.
There is a large body of work on dynamic slicing [2], which
use a similar method of examining dynamic sequences of transi-
tions for a given program input to build dependence information.
However, their focus was primarily on slices of single executions.
Ourworkexpands ontheirstohandle concurrentnon-determinism
across multiple executions. Zhang et al.[45] expand on the early
work to create more precise and efﬁcient dynamic slicing algo-
rithms. Additional work [4, 6, 9, 24, 30, 18] has been done to
limit the number of dynamic instrumentation points to reduce the
overhead of dynamic slicing. They are orthogonal to the method
proposedinthispaper.
8. CONCLUSIONS
We have presented a new cooperative static–dynamic analysis
methodforreducingtheinterleavingspaceofmultithreadedC/C++
programs. Wehave alsopresentedtwooptimizationsforDPORto
providefurtherreduction. Wehaveimplementedournewmethods
andevaluatedthemonopensourcebenchmarks. Ourexperimental
evaluationshowsthattheproposedmethodscanresultinsigniﬁcant
speedupoverDPORalone. Forfuturework,weplantoincreasethe
accuracyandefﬁciencyofourstaticanalysismethod.
9. ACKNOWLEDGMENT
ThisworkwasprimarilysupportedbytheNSFundergrantCCF-
1149454 (Markus Kusano). Partial support was provided by the
ONRundergrantN00014-13-1-0527 (ChaoWang).
18410. REFERENCES
[1] P.A.Abdulla,S.Aronis,B.Jonsson,andK.F.Sagonas.
Optimaldynamicpartialorderreduction.In ACM
SIGACT-SIGPLANSymposium on Principlesof
Programming Languages,pages373–384, 2014.
[2] H.AgrawalandJ.R.Horgan.Dynamicprogramslicing.In
ACMSIGPLANConference onProgramming Language
Design and Implementation ,pages246–256, 1990.
[3] J.Alglave,D.Kroening,andM.Tautschnig.Partialorders
forefﬁcientboundedmodelcheckingofconcurrent software.
InInternational Conference on Computer AidedVeriﬁcation ,
pages141–157, 2013.
[4] T.BallandJ.R.Larus.Optimallyproﬁlingandtracing
programs. ACMTrans.Program. Lang. Syst. ,
16(4):1319–1360, July1994.
[5] S.Bindal,S.Bansal,andA.Lal.Variableandthread
boundingforsystematictestingofmultithreadedprograms.
InInternational Symposium on Software Testing and
Analysis,pages145–155, 2013.
[6] J.-D.Choi,B.P.Miller,andR.H.B.Netzer.Techniquesfor
debuggingparallelprogramswithﬂowbackanalysis. ACM
Trans. Program.Lang. Syst. ,13(4):491–530, Oct.1991.
[7] E.M.Clarke,Jr.,O.Grumberg,andD.A.Peled. Model
Checking.MITPress,Cambridge,MA,USA,1999.
[8] K.E.Coons,M.Musuvathi,andK.S.McKinley.Bounded
partial-orderreduction.In ACMSIGPLANConference on
Object Oriented Programming, Systems, Languages, and
Applications ,pages833–848,2013.
[9] E.Duesterwald,R.Gupta,andM.Soffa.Distributedslicing
andpartialre-executionfordistributedprograms.In
Languages and Compilers for Parallel Computing ,pages
497–511.ACM,1993.
[10] O.Edelstein,E.Farchi,Y.Nir,G.Ratsaby,andS.Ur.
Multithreadedjavaprogramtestgeneration. IBMSyst. J. ,
41(1):111–125, Jan.2002.
[11] M.Emmi,S.Qadeer,andZ.Rakamaric.Delay-bounded
scheduling.In ACMSIGACT-SIGPLANSymposium on
Principles of ProgrammingLanguages , pages411–422,
2011.
[12] J.Ferrante,K.J.Ottenstein,andJ.D.Warren.Theprogram
dependence graphanditsuseinoptimization. ACM Trans.
Program. Lang. Syst. ,9(3):319–349, July1987.
[13] C.FlanaganandP.Godefroid.Dynamicpartial-order
reductionformodelcheckingsoftware.In ACM
SIGACT-SIGPLANSymposium on Principlesof
Programming Languages,pages110–121, 2005.
[14] P.Godefroid.Usingpartialorderstoimproveautomatic
veriﬁcationmethods.In International Conference on
Computer AidedVeriﬁcation ,pages176–185, 1991.
[15] P.Godefroid.Modelcheckingforprogramminglanguages
usingverisoft.In ACMSIGACT-SIGPLANSymposium on
Principles of ProgrammingLanguages , pages174–186,
1997.
[16] P.GodefroidandD.Pirottin.Reﬁningdependencies
improvespartial-orderveriﬁcationmethods(extended
abstract).In International Conference on Computer Aided
Veriﬁcation ,pages438–449, 1993.
[17] P.GodefroidandP.Wolper.Usingpartialordersforthe
efﬁcientveriﬁcationofdeadlockfreedomandsafety
properties.In International Conference onComputer Aided
Veriﬁcation ,pages332–342, 1992.
[18] R.Gupta,M.L.Soffa,andJ.Howard.Hybridslicing:
Integratingdynamicinformationwithstaticanalysis. ACM
Trans. Softw.Eng. Methodol. ,6(4):370–397, Oct.1997.[19] S.Hong,J.Ahn,S.Park,M.Kim,andM.J.Harrold.Testing
concurrentprogramstoachievehighsynchronization
coverage.In International Symposium onSoftware Testing
and Analysis ,pages210–220, 2012.
[20] S.Hong,M.Staats,J.Ahn,M.Kim,andG.Rothermel.The
impactofconcurrentcoveragemetricsontesting
effectiveness.In IEEEInternational Conference on Software
Testing, Veriﬁcationand Validation ,pages232–241, 2013.
[21] S.Horwitz,T.Reps,andD.Binkley.Interproceduralslicing
usingdependence graphs.In ACM SIGPLANConference on
ProgrammingLanguage Design and Implementation ,pages
35–46,1988.
[22] P.Joshi,M.Naik,C.-S.Park,andK.Sen.CalFuzzer: An
extensibleactivetestingframeworkforconcurrentprograms.
InInternational Conference on Computer AidedVeriﬁcation ,
pages675–681, 2009.
[23] V.Kahlon,C.Wang,andA.Gupta.Monotonicpartialorder
reduction: Anoptimalsymbolicpartialorderreduction
technique.In International Conference on Computer Aided
Veriﬁcation ,pages398–413, 2009.
[24] M.Kamkar,P.Fritzson,andN.Shahmehri.Threeapproaches
tointerproceduraldynamicslicing. Microprocessing and
Microprogramming ,38(1):625–636, 1993.
[25] K.KennedyandJ.R.Allen. Optimizing Compilers for
Modern Architectures: ADependence-based Approach .
MorganKaufmannPublishersInc.,SanFrancisco,CA,USA,
2002.
[26] A.Mazurkiewicz.Tracetheory.In Advances inPetri Nets
1986, Part IIon PetriNets: Applications and Relationships
toOther Models of Concurrency , pages279–324, NewYork,
NY,USA,1987.Springer-VerlagNewYork,Inc.
[27] M.MusuvathiandS.Qadeer.Iterativecontextboundingfor
systematictestingofmultithreadedprograms.In ACM
SIGPLANConference onProgramming Language Design
and Implementation ,pages446–455, 2007.
[28] Non-blockingdatastructures.URL:
https://code.google.com/p/nbds/.
[29] Thread-cachingmallocimplementation.URL:
http://www.nedprod.com/programs/portable/nedmalloc/.
[30] R.H.B.NetzerandM.H.Weaver.Optimaltracingand
incrementalreexecutionfordebugginglong-running
programs.In ACM SIGPLANConference onProgramming
Language Designand Implementation ,pages313–325, 1994.
[31] S.Park,S.Lu,andY.Zhou.CTrigger: Exposingatomicity
violationbugsfromtheirhidingplaces.In International
Conference onArchitectural Support for Programming
Languages and Operating Systems,pages25–36,2009.
[32] D.Peled.Combiningpartialorderreductionswithon-the-ﬂy
model-checking. In International Conference onComputer
AidedVeriﬁcation ,pages377–390, 1994.
[33] F.Sorrentino,A.Farzan,andP.Madhusudan. PENELOPE:
weavingthreadstoexposeatomicityviolations.In ACM
SIGSOFTSymposium on Foundations of Software
Engineering ,pages37–46,2010.
[34] 2013softwareveriﬁcationcompetition.URL:
http://sv-comp.sosy-lab.org/2013/.
[35] P.Thomson,A.F.Donaldson, andA.Betts.Concurrency
testingusingschedule bounding: Anempiricalstudy.In
ACM SIGPLANSymposium on Principlesand Practice of
ParallelProgramming ,pages15–28,2014.
[36] A.Valmari.Stubbornsetsforreducedstatespacegeneration.
InInternational Conference on Applications and Theory of
PetriNets,pages491–515, 1991.
[37] C.Wang,S.Chaudhuri,A.Gupta,andY.Yang.Symbolic
pruningofconcurrentprogramexecutions.In ACM
185SIGSOFT Symposium onFoundations of Software
Engineering ,pages23–32, 2009.
[38] C.Wang,M.Said,andA.Gupta.Coverageguided
systematicconcurrencytesting.In International Conference
on Software Engineering ,pages221–230, 2011.
[39] C.Wang,Y.Yang,A.Gupta,andG.Gopalakrishnan.
Dynamicmodelcheckingwithpropertydrivenpruningto
detectraceconditions.In International Symposium on
AutomatedTechnology for Veriﬁcationand Analysis ,pages
126–140,2008.
[40] C.Wang,Z.Yang,V.Kahlon,andA.Gupta.Peepholepartial
orderreduction.In International Conference on Tools and
Algorithmsfor Construction and Analysis of Systems ,pages
382–396, 2008.
[41] M.Weiser.Programslicing.In International Conference on
Software Engineering ,pages439–449, 1981.
[42] Y.Yang,X.Chen,G.Gopalakrishnan, andR.M.Kirby.
Efﬁcientstatefuldynamicpartialorderreduction.InInternational SPINworkshop on Model Checking Software ,
pages288–305, 2008.
[43] Y.Yang,X.Chen,G.Gopalakrishnan, andC.Wang.
Automaticdiscoveryoftransitionsymmetryinmultithreaded
programsusingdynamicanalysis.In International SPIN
workshop on Model Checking Software ,pages279–295,
2009.LNCS5578.
[44] J.Yu,S.Narayanasamy,C.Pereira,andG.Pokam.Maple: A
coverage-driventestingtoolformultithreadedprograms.In
ACM SIGPLANConference on Object Oriented
Programming, Systems, Languages, and Applications ,pages
485–502, 2012.
[45] X.Zhang,R.Gupta,andY.Zhang.Precisedynamicslicing
algorithms.In International Conference on Software
Engineering ,pages319–329, May2003.
186