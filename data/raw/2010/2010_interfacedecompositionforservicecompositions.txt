Interface Decomposition for Service Compositions
Domenico BianculliDimitra Giannakopoulou Corina S. P ÀòasÀòareanu
Faculty of Informatics NASA Ames Research Center and
University of Lugano Carnegie Mellon Silicon Valley
Lugano, Switzerland Moffett Field, CA, USA
domenico.bianculli@usi.ch {dimitra.giannakopoulou,corina.s.pasareanu}@nasa.gov
ABSTRACT
Service-based applications can be realized by composing ex-
isting services into new, added-value composite services. The
external services with which a service composition interacts
are usually known by means of their syntactical interface.
However, an interface providing more information, such as
a behavioral specication, could be more useful to a ser-
vice integrator for assessing that a certain external service
can contribute to fulll the functional requirements of the
composite application.
Given the requirements specication of a composite ser-
vice, we present a technique for obtaining the behavioral
interfaces | in the form of labeled transition systems | of
the external services, by decomposing the global interface
specication that characterizes the environment of the ser-
vice composition. The generated interfaces guarantee that
the service composition fullls its requirements during the
execution. Our approach has been implemented in the LTSA
tool and has been applied to two case studies.
Categories and Subject Descriptors
D.2.1 [ Software Engineering ]: Requirements/Specica-
tions; D.2.4 [ Software Engineering ]: Software/Program
Verication; F.3.1 [ Logics and meanings of programs ]:
Specication techniques; H.3.5 [ Information storage and
retrieval ]: Online Information Services| Web-based services
General Terms
Verication
Keywords
Behavioral interface, interface decomposition, services, ser-
vice compositions
This work was carried out while the author was an intern at
Mission Critical Technologies, Inc., on site at NASA Ames
Research Center.
Copyright 2011 Association for Computing Machinery. ACM acknowl-
edges that this contribution was authored or co-authored by a contractor or
afÔ¨Åliate of the U.S. Government. As such, the Government retains a nonex-
clusive, royalty-free right to publish or reproduce this article, or to allow
others to do so, for Government purposes only.
ICSE ‚Äô11, May 21‚Äì28, 2011, Waikiki, Honolulu, HI, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00.1. INTRODUCTION
Service-oriented computing is a paradigm that promotes
the construction of software applications by means of ba-
sic components called services , which make available a spe-
cic functionality through a set of operations accessible over
a network infrastructure. Software engineers use composi-
tion mechanisms such as BPEL orchestrations [23] to as-
semble complex, added-value services, called service compo-
sitions , out of existing services, possibly oered by third-
party providers and thus called external orpartner services .
In previous work, some of the authors emphasized the
need for achieving continuous lifelong verication for this
new class of software, which belongs to the realm of open-
world software [2]. They proposed a methodology [5] provid-
ing an integrated approach for design-time and run-time ver-
ication with an assume-guarantee avor, and they showed
how to realize continuous lifelong verication by adopting a
verication-oriented life cycle [4].
At the basis of these proposals there is the denition of
a set of correctness properties that the service composition
should manifest. These properties usually depend on a cer-
tain behavior or on some quality of service attributes of
the external services with which the composite service in-
teracts. The aforementioned work made the working as-
sumption that behavioral descriptions were available for the
external services interacting with a composite service. These
descriptions were then used as assumptions for performing
the assume-guarantee style model checking of the service
composition behavior, and as models to synthesize run-time
monitors.
However, in the dynamic and evolvable settings that char-
acterize open-world software, it is unrealistic to assume the
availability of the interface descriptions of third-party ser-
vices. In general, service providers make available to ser-
vice integrators only the syntactical interface of the services
they provide. It is then clear that an automated technique
for deriving, from the requirements specication of a com-
posite service, the required interface of its partner services,
could improve the process followed by service integrators to
assemble service compositions.
In this paper, we focus on the automatic generation of the
behavioral interfaces of the partner services, by decompos-
ingthe requirements specication of a service composition.
Our technique generates behavioral interfaces that consti-
tute required specications for the partner services; these
specications guarantee that the composite service will fulll
its required safety properties at run time, while it interacts
with the external services. Since we assume that the behav-ioral descriptions of external services are not available, our
technique is based on the purely syntactical knowledge of
their interfaces. In particular, the specic contributions of
the paper are: i) the formulation of the interface decomposi-
tion problem for service compositions; ii) a sound, heuristic-
based technique for decomposing the global interface speci-
cation of the environment into the behavioral interfaces |
in the form of labeled transition systems (LTSs) | of the
individual partner services; iii) the implementation of this
technique in the LTSA tool [21] and its application to two
case studies.
Once the behavioral specications of the external services
have been inferred, they can serve multiple purposes. For
example, they can be used with (semi-)automatic compo-
sition mechanisms, for selecting the services that fulll in
the best way the functional requirements of the composite
service. Moreover, they can become clauses of the service
level agreements (SLAs) negotiated with service providers.
Furthermore, they can be translated into veriable run-time
assertions, which can be monitored while the system is op-
erating, to check if the external services behave as expected,
i.e., to check if the service providers meet the obligations
they signed in the SLAs.
The rest of this paper is structured as follows. Section 2
provides background material on LTSs. Section 3 introduces
the running example used to show how our approach works.
Section 4 presents our formal models for service composi-
tions and their interface specication. Section 5 presents the
interface decomposition problem, illustrates our technique to
solve it, and shows its correctness. Section 6 discusses the
application of our approach to two case studies. Section 7
reviews the related work and Section 8 concludes the paper,
outlining future research directions.
2. PRELIMINARIES
We use labeled transition systems (LTSs) to model the
behavior of service compositions, the global specications of
the environment with which a composite service interacts,
and the behavioral interfaces of the individual services. In
the rest of this section, we formally dene LTSs and the
operations that can be performed over them.
Labeled Transition Systems
LetActbe the universal set of observable actions and let
denote an internal action that cannot be observed by the
environment of a component. Let denote a special er-
ror state , which models safety violations in the associated
transition system. A Labeled Transition System Mis a
4-tuplehQ;A;;q 0iwhereQis a nite non-empty set of
states;A=M[fg;withMActis the actions al-
phabet;QAQis a transition relation; q02Q
is the initial state. Moreover, let  denote a special LTS,
 =hfg;Act;?;i.
An LTSM=hQ;A;;q 0iisnon-deterministic if it con-
tains-transitions or if 9(q;a;q0);(q;a;q00)2such that
q06=q00. Otherwise, Misdeterministic .
An LTS is complete if in each state a transition is de-
ned upon each action of the alphabet; more formally, M=
hQ;M[fg;;q 0iis complete iff8q2Q;8a2M;9q02
Qj(q;a;q0)2. If an LTS Mis not complete, it can
be completed with a sink state and the transitions lead-
ing to it; the resulting LTS is denoted as ^M. Formally,
given an LTS M=hQ;M[fg;;q 0i, its complete-by-construction variant is ^M=hQ[f^qg;^M[fg;0;q0i, where
^M=M;0=[f(^q;a;^q)ja2Mg[f (q;a;^q)ja2
M^:9q02Qj(q;a;q0)2g.
For an LTS M=hQ;A;;q 0i, there is a pathfrom state
qto stateq0, withq;q02Q, if there exists a set of states
fq1;:::;qngQand a sequence of actions ha1;:::;an 1i,
with eachai2A, such thatq=q1^q0=qn^8i;1in 
1;(qi;ai;qi+1)2. The sequence of actions ha1;:::;an 1i,
where the-transitions are ignored, is called the trace de-
ned by the path . A trace of an LTS Mis a trace
dened by a path that originates in the initial state; i.e.,
it is a nite sequence of observable actions that label the
transitions that Mcan perform starting at its initial state.
The set of traces of Mis denoted as Tr(M). For an LTS
M,errTr (M)Tr(M) is the set of traces ft2Tr(M)j
9a pathfromq0toandtis dened by g;errTr (M) is
called the set of error traces ofM. Furthermore, given a
tracetand a setA Act, the expression ( tA) denotes
the trace obtained from tby removing all occurrences of
actionsa62A; \" is the restriction operator for traces.
In some cases, it might be useful to explicitly indicate that
an LTS has the error state , reachable from the initial state.
For an LTS M=hQ;A;;q 0i, we use the notation Miff
2Qand errTr (M)6=?. This notation can be combined
with the one denoting the completion-by-construction, as in
^M, to identify an LTS that is complete and that contains
the error state (reachable from the initial state).
Operators
LetM=hQ;A;;q 0iandM0=hQ0;A0;0;q0
0i, withq0
06=.
Mtransits intoM0with action a, denotedMa !M0, if
(q0;a;q0
0)2, withQ=Q0;A=A0;=0. Moreover,
we say that Mtransits into  with action a,Ma !, if
(q0;a;)2.
The interface operator"is used to make unobservable
some actions of an LTS. Given an LTS M=hQ;A;;q 0i
and a set of observable actions A Act,M"Ais dened
as follows. If M= ;M"A= . ForM6= ;M"A=
hQ;(M\A)[fg;q0;0i, where0is described by the rules
shown in Fig. 1a. The semantics of this operator ensures
that errTr (M)6=?ifferrTr (M"A)6=?.
Two LTSs can be combined by means of the parallel com-
position \k" operator, which is commutative and associa-
tive. Given two LTSs M1=
Q1;A1;1;q1
0
andM2=
Q2;A2;2;q2
0
, the parallel composition M1kM2is dened
as follows. If either M1=  orM2= , thenM1kM2= .
Otherwise, M1kM2is an LTS M=hQ;A;;q 0iwhere
Q=Q1Q2;q0= (q1
0;q2
0);A=A1[A2andis described by
the rules shown in Fig. 1b. The traces of a parallel composi-
tion are dened as follows: Tr(M1kM2) =ftj(tM 1)2
Tr(M1)^(tM 2)2Tr(M2)^t2(M 1[M 2)g. As
for error traces, a parallel composition has an error trace if
at least one of its components has an error trace. In sym-
bols: errTr (M1kM2) =ft2Tr(M1kM2)j(tM 1)2
errTr (M1)_(tM 2)2errTr (M2)g.
Safety Properties
A safety property can be specied as a deterministic LTS
that contains no state. The set of traces Tr(P) of a
propertyPdenes the set of acceptable behaviors over P.
An LTSMsatisesP, denoted as Mj=PiffTr(M"
P)Tr(P). For a property LTS Pwe can dene theMa !M0;a2A
M"Aa !M0"AMa !M0;a62A
M"A !M0"A
(a) Rules for the interface operator
M1a !M0
1
M1kM2a !M0
1kM2M2a !M0
2
M1kM2a !M1kM0
2
a62M 2 a62M 1
M1a !M0
1;M 2a !M0
2
M1kM2a !M0
1kM0
2
a2(M 1\M 2)
(b) Rules for the parallel composition operator
Figure 1: Rules for the LTS operators
error LTSPerras follows: given P=hQ;P;;q 0i,Perr=
hQ[fg;P err;0;q0i, wherePerr=P,0=[f(q;a; )j
(q;a)2QP^:9q02Qj(q;a;q0)2g. Note that the
error LTS is complete by construction1.
LetMbe an LTS such that errTr (M) =?. We detect
possible violations of a property Pby the component Mby
computing MkPerr. As shown in [8], the execution of M
leads to a violation of a property PifferrTr (MkPerr)6=?,
i.e., iff thestate is reachable in MkPerr.
3. EXAMPLE
Our running example is a simplied version of the Car
Rental Agency one presented in [5]; we call it Simple Car
Rental (SCR) . The example illustrates a service composi-
tion that is run at a car rental oce branch. The composite
service interacts with a Car Broker (CB) service, which con-
trols the operations of the branch; with a User Interaction
(UI) service, through which customers can make car rental
requests; with a Car Information (CI) service, which main-
tains a database of cars availability and allocates cars to
customers; with a Car Parking Sensor (CPS) service, which
exposes as a service the sensor that senses cars as they are
driven in or out of the parking lot of the branch. The work-
ow of the composite service is sketched in Fig. 2 using the
notation presented in [5]: boxes with a right arrow corre-
spond to onMessage events, while the ones with two opposite
arrows indicate an invoke activity.
The SCR service starts when it receives the startRental
message from the CBservice. It then enters an innite loop;
at each iteration it can receive one of the following messages:
findCar . A customer requests to rent a car; the SCR
service checks the availability of a car by invoking the
lookupCar operation on the CIservice. The lookup-
Caroperation returns its result | which can be either
a negative answer or an identier corresponding to the
digital key to access the car | in the result variable,
which is then passed as parameter to the findCarCB
operation, a callback invoked on the UIservice.
carEnter and carExit . These two messages are sent
out by the CPS service when a car enters (respectively,
1Since an error LTS models a safety property violation, it is
customary not to include self-loops for , which are implied.
onMessageonMessageonMessageonMessage
CarInformationService
Car Parking SensorService
CarBrokerService
UserInteractionServicestartRental
markCarAvailablemarkCarUnavailablestopRentallookupCarÔ¨ÅndCarstopRentalcarEntercarExit
Ô¨ÅndCarCBFigure 2: The Simple Car Rental example
exits) the parking lot. The process reacts to this in-
formation by updating the cars database, invoking, re-
spectively, the markAvailable and markUnavailable
operations on the CIservice.
stopRental . The CBservice stops the operations of
the branch, terminating also the composite service.
To keep the example compact, we assume that a single car
is available in the branch, and that the CIservice is accessed
only by the SCR service instance running in the branch.
The correct execution of the SCR service depends on the
functionalities provided by the CIandCPS services. There-
fore, in the next two sections we show the application of our
interface decomposition technique to derive the behavioral
interfaces of these two services.
4. SERVICE COMPOSITION AND GLOBAL
INTERFACE SPECIFICATION MODELS
In this section we present the formal model of service com-
positions and describe how we can infer the global interface
specication of the environment (i.e., the set of partner ser-
vices) with which a composite service interacts. We refer
the reader to Fig. 3, for mapping symbols onto components.
4.1 Service Composition
A service composition Cinteracts with a set of external
services denoted as E=fE1;:::;Eng. Each service Ei2
Emakes available a set of operations Oi=foi
1;:::;oi
mg,
which constitute its syntactical interface. We assume that
8i;j;1in;i<jn;Oi\Oj=?, since each operation
can be unambiguously identied by its name combined with
the name of the service it belongs to (e.g., by means of the
interface andservice elements of a WSDL 2.0 description).
We assume that service compositions are implemented as
BPEL processes, which can be formalized in terms of la-
beled transition systems as shown in [11], with tools such
as WS-Engineer [10]. For a service C, letMCbe the corre-
sponding LTS.
The safety requirements on the behavior of the composite
serviceC, when it interacts with the external services E,
can be modeled by a property LTS P. This LTS can be
synthesized, for example, from a specication in a temporal
logic formalism such as LTL or Fluent LTL [13]. Note that
the property Pimplicitly denes the unwanted behaviors,
by means of the corresponding error LTS Perr.Modeling the Running Example
In the example, we are interested in the environment consti-
tuted by the services CIandCPS, so we have E=fCI;CPSg,
OCI=fmarkAvailable ,markUnavailable ,lookupCargand
OCPS=fcarEnter ,carExitg.
In the rest of this paper, we use the FSP textual no-
tation [21] to compactly represent LTS models. In FSP,
identiers beginning with a lowercase letter denote actions
while identiers beginning with an uppercase letter denote
processes (states in the underlying LTS); the symbol \ ->"
denotes the action prex operator, while the vertical bar
\|" denotes the choice operator. The following code snippet
corresponds to the LTS model of the SCR service:
range KEY = 0..1 //(0 means car not available)
SCR = (startRental -> Main),
Main = (findCar -> lookupCar[result:KEY]
-> findCarCB[result] -> Main
| carExit -> markUnavailable -> Main
| carEnter -> markAvailable -> Main
| stopRental -> END).
Note that each operation invoked on the SCR service and
on its partner services is modeled as an action. Moreover,
since the variable result ranges over the domain KEY, the
lookupCar action is internally represented as lookupCar[0]
and lookupCar[1] ; the same applies to findCarCB .
Service Behavior
The expected behavior of the SCR service is expressed by
the following requirement: \If the car enters the parking lot,
and it does not exit until a customer requests it for renting,
then this request should not return a negative answer."
This requirement can be formalized in Fluent LTL as the for-
mula G(CarIn) ), where CarIn is a uent that changes
value when the car is in the parking lot, and it is dened as
CarIn =hcarEnter;carExitiinitially False ; is the auxil-
iary formula findCar)(:findCarCB[0] WfindCarCB[1] ).
Here Gand Ware, respectively, the LTL temporal opera-
tors \globally" and \weak until". This Fluent LTL formula
represents a safety property and thus can be translated au-
tomatically [13] into an (error) LTS model, whose textual
description is shown below:
Perr = Q0,
Q0 = ({carExit, findCar, findCarCB[0..1]} -> Q0
|carEnter -> Q1),
Q1 = (carExit -> Q0
|{carEnter, findCarCB[0..1]} -> Q1
|findCar -> Q2),
Q2 = (findCarCB[0] -> ERROR
|findCarCB[1] -> Q1
|{carEnter, findCar} -> Q2
|carExit -> Q3),
Q3 = (findCarCB[0] -> ERROR
|findCarCB[1] -> Q1
|carEnter -> Q2
|{carExit, findCar} -> Q3).
4.2 Global Interface SpeciÔ¨Åcation
In this work, we want to characterize the global expec-
tations from Ein order for Cto fulll its requirement P;
i.e., we want to infer the global interface specication of the
environment Ewith which Cinteracts. By following the
technique introduced in [14] and summarized below, we can
ÀÜIœÄoperationo11operationo1ioperationo1moperationoi1operationoiioperationoimoperationon1operationonioperationonmserviceEnserviceEiserviceE1¬∑¬∑¬∑¬∑¬∑¬∑O1OiOnbaPerrq0q1ÀÜI1œÄÀÜIiœÄÀÜInœÄ¬∑¬∑¬∑¬∑¬∑¬∑decompositionE
MCcompositeserviceCpropertyPFigure 3: Notation and general model of the service
interface decomposition problem
determine the global interface specication by computing
the LTS ^I, with ^I=BuildInterface ((MckPerr);O),
whereO=SjEj
i=1Oi.
The pseudo-code of function BuildInterface is shown
in Fig. 4. The function receives as rst parameter an LTS
model ; the actual parameter that is passed ( MckPerr) con-
tains all the traces that violate the property P. The actual
value of the second parameter actions , is the set of all the
operations provided by the external services and is used on
line 2 as an operand of the interface operator, to get the LTS
named geninterface . This LTS is further processed with
a special determinization step (line 3), provided internally
by LTSA. This determinization step performs -elimination
and subset construction but, unlike standard automata the-
ory algorithms, it handles in a special way the state. Since
during the subset construction the states of the determin-
istic LTS correspond to set of states of the original, non-
deterministic LTS, if any of the states in the set is , then
the entire set becomes a state in the deterministic LTS.
This means that a trace that non-deterministically may or
may not lead to the error state has to be considered an er-
ror trace. In practical terms, it means that performing a
certain sequence of actions on the external services does not
guarantee that the service composition will not reach an er-
ror state. Subsequently, the LTS geninterface is completed
(line 4) with a sink state and the transitions leading to it, by
invoking an auxiliary function. The missing transitions in
the original LTS represent behaviors of the external services
that are never exercised by the service composition; with
the completion, they are made sink behaviors and thus no
restriction is imposed on them.
1:function BuildInterface (model ,actions )
2:geninterface model"actions
3:Determinize (geninterface )
4:CompleteWithSinkState (geninterface )
5:return geninterface
Figure 4: Pseudo-code of the BuildInterface func-
tionThe notation used for the resulting LTS, ^I, denotes that
it contains the error state (deriving from the error LTS Perr)
and that it has been completed with a sink state. Hereafter,
we use the notation ^Ito refer to the variant of ^Ithat does
not contain the error state, without the transitions leading
to it. In symbols, given ^I=hQ[fg;^I;;q 0i,^I=
hQ;^I;0;q0i, where^I=^I,0=nf(q;a; )ja2^Ig.
Application to the Running Example
The rst parameter passed to the BuildInterface function
is(SCR || Perr) . As for the second parameter, the list of
actions passed to the function is composed by markAvail-
able,markUnavailable ,lookupCar[0] and lookupCar[1]
(from CI), and by carEnter and carExit (from CPS). The
resulting interface ^Iis dened as follows:
Ipi = Q0,
Q0 = (lookupCar[0..1] -> Q0
|carExit -> Q1
|carEnter -> Q2
|{markUnavailable,
markAvailable} -> SINK),
Q1 = (markUnavailable -> Q0
|{carExit, carEnter, markAvailable,
lookupCar[KEY]} -> SINK),
Q2 = (markAvailable -> Q3
|{carExit, carEnter, markUnavailable,
lookupCar[KEY]} -> SINK),
Q3 = (lookupCar[0] -> ERROR
|carExit -> Q1
|carEnter -> Q2
|lookupCar[1] -> Q3
|{markUnavailable,
markAvailable} -> SINK),
SINK = ({carExit, carEnter,
markUnavailable, markAvailable,
lookupCar[KEY]} -> SINK).
5. DECOMPOSING INTERFACE SPECIFI-
CATIONS
The method described in Section 4.2 computes the global
interface specication of a service composition, i.e., the be-
havior that its partner services, considered as a whole , should
manifest in order for the composite service to fulll its re-
quirements specication. However, this \centralized" solu-
tion is not realistic for the domain of service-based appli-
cations, since each service is operated independently by its
own provider, and has no knowledge of the other services
with which its client service (i.e., a composite service) inter-
acts. Therefore, we argue it is necessary to dene a more
\distributed" approach, which generates the individual be-
havioral interfaces for the partner services.
To this end, we dene the interface decomposition prob-
lem as follows (refer to Fig. 3 for mapping symbols onto
components): given a service composition C, which inter-
acts with a set of external services E=fE1;:::;Engwhose
behavior, as a whole, is represented by I, we decompose I
into interface specications for the individual partner ser-
vices, denoted as Ii;1ijEj.
The individual interface specications obtained by means
of the interface decomposition technique should guarantee
that the composite service fullls its requirement specica-
tion. This correctness requirement can be formally stated
asfjEj
i=1Ii
kMcj=P.In the rest of this section, we illustrate our technique
for decomposing interface specications and show its ap-
plication to the running example. We rst present a ba-
sic approach to the problem and observe that it generates
over-constraining interfaces. Subsequently, we propose our
heuristic-based technique, which generates less constraining,
but still correct behavioral interfaces. We conclude by dis-
cussing some approaches for the validation of the decompo-
sition technique, as well as its shortcomings.
5.1 Basic Decomposition Approach
A rst approach to the problem of interface decomposition
can be based on the intuition that each external service can
contribute to the global interface specication only through
the operations that it provides. Formally, this means the
interface specication ^Iiof an external service Eican be
computed as ^Ii=BuildInterface (^I;Oi).
Note that ^Iicontains the error state; as done for the case
of the global interface specication, we use the notation ^Ii
to refer to the variant of ^Iithat contains neither the error
state nor the transitions leading to it.
However, simple experimentation with this technique re-
veals that such an approach generates interfaces that are
too restrictive. For example, its application to the running
example generates the following interface specications.
For the CIservice, we restrict the global interface spec-
ication over the alphabet fmarkUnavailable ,markAvail-
able,lookupCar[0] ,lookupCar[1]g. The resulting LTS is:
CI = Q0,
Q0 = ({lookupCar[0..1], markUnavailable} -> Q0
|markAvailable -> Q1),
Q1 = (lookupCar[0] -> ERROR
|markUnavailable -> Q0
|{lookupCar[1], markAvailable} -> Q1).
It states that after a markAvailable operation, when the
computation is in state Q1, the lookupCar operation will re-
turn successfully (i.e., a value dierent from 0). Essentially,
state Q1denotes the fact that the car is in the parking lot.
As for the CPS service, the global interface specication
is restricted over the alphabet fcarEnter ,carExitg. The
resulting LTS is:
CPS = Q0,
Q0 = (carEnter -> ERROR
|carExit -> Q0).
This interface is too restrictive, since it disallows a car from
ever entering the parking lot. Furthermore, considering that
according to the denition of the uent CarIn in Section 3,
the car is initially out of the parking, this interface in prac-
tice blocks any behavior from the car.
In fact, we can make a stronger observation about the
individual interfaces built in this way:
Proposition 1.Let^Ii=BuildInterface (^I;Oi), and
^I0
i=BuildInterface ((MCkPerr);Oi). Then ^Iiand^I0
i
are isomorphic.
Proof. By construction, function BuildInterface gen-
erates a canonical deterministic LTS whose error traces are
equal to the error traces of its rst argument projected
to the alphabet represented by its second argument [14].
Since ^I=BuildInterface ((MCkPerr);O), it followsthat errTr (^I) =errTr ((MCkPerr)"O). In a similar way,
errTr (^Ii) = errTr (^I"Oi). From these two statements,
we derive that errTr (^Ii) =errTr (((MCkPerr)"O)"Oi).
SinceOiO, we conclude that errTr (^Ii) =errTr ((MCk
Perr)"Oi). Additionally, ^I0
i=BuildInterface ((MCk
Perr);Oi) implies that errTr (^I0
i) = errTr ((MCkPerr)"
Oi). Since the error traces of ^Iiand^I0
iare equal, we con-
clude that the canonical representations ^Iiand ^I0
i, gen-
erated by function BuildInterface , are isomorphic, and
therefore so are ^Iiand^Ii0.
As a result, each interface that we compute in this fashion
is sucient by itself, to guarantee the global property on the
system, meaning that 8i;(^IikMc)j=P, which implies thatfjEj
i=1^Ii
kMcj=P.
However, imposing such interfaces would be overly con-
straining. Moreover, a solution that assigns the entire re-
sponsibility for achieving the global property to every single
service is not desirable. Ideally, we would like a solution
that distributes the responsibility to the partner services in
a way that allows as much participation from each service as
possible in the behavior of the service composition. To this
end, in the next section we propose a heuristic that avoids
to unnecessarily constrain the interface of partner services
that cannot lead to error behaviors of the system.
5.2 Heuristic-based Decomposition Technique
The heuristic we propose to use is based on inspecting the
actions that label the transitions that lead to the error state
in the global interface specication. It may be the case that
none of these actions corresponds to one of the operations
provided by the partner service (hereafter referred to as Ei)
for which we want to compute the behavioral interface. This
means that service Eiwill never cause an error behavior
in the system constituted by the composite service and its
partner services. In this case, the behavioral interface of
Eican be obtained by decomposing a simplied model of
the global interface specication, which does not include the
error behaviors that are not directly ascribable to Ei.
More formally, for a service Eiwith actions Oi, given a
global interface specication ^I=hQ;I;;q oi, the heuris-
tic builds an auxiliary global interface specication, denoted
withIheu(i). This heuristic-based, auxiliary global interface
specication is computed as Iheu(i) =hQ;I;0;qoi, where
0=nf(q;a; )ja62Oig. The denition of 0shows that
the heuristic removes the transitions to the error state la-
beled with actions (operations) not provided by Ei. Note
that as a result of removing such transitions, Iheu(i) may
not be complete; note also the error state may be removed
in case the error transitions were ascribable only to the other
services dierent from Ei. The interface specication of the
serviceEi, denoted with ^Ii, can then be computed as ^Ii=
BuildInterface (Iheu(i);Oi).
Correctness
Before showing that this technique is a correct solution of the
interface decomposition problem, we introduce and prove
some helper propositions.
Proposition 2.Given ^Iand ^Iidened as above, the
relation errTr (fjEj
i=1^Ii)errTr (^I)holds.Proof. The proof is by contradiction. Suppose there is a
tracet, such thatt2errTr (^I) and thatt62errTr (fjEj
i=1^Ii).
Letabe the last action in t, and (q;a;q0) the corresponding
transition that leads to the error state in ^I. Since there
must exist a ksuch thata2Ok, we know that transition
(q;a;q0) will not be removed from Iheu(k). From the se-
mantics of the interface operator, we can then conclude that
(tOk)2errTr (^Ik). Since for all i,^Iiis complete, we
also know that t2Tr(fjEj
i=1^Ii). But since tleads to the
error state with at least one component of this, we conclude
thatt2errTr (fjEj
i=1^Ii), which is a contradiction.
Proposition 3.Given ^Iand^Iidened as above, the re-
lation Tr (fjEj
i=1^Ii)Tr(^I)holds.
Proof. Consider the set Oof all the operations made
available by the external services; let Orepresent its Kleene
closure. Similarly, let Oibe the Kleene closure of the
set of operations provided by an individual external ser-
viceEi. By construction, ^Iis obtained from ^Iby re-
moving the error state and the transitions leading to it.
Hence, since no trace of the ^Iinterface leads to the er-
ror state, we know that Tr(^I) =OnerrTr (^I); similarly,
8i;1ijEj;Tr(^Ii) =OinerrTr (^Ii). Moreover, we
know that a composite process has an error trace, if at least
one of its constituent processes has an error trace. In sym-
bols:
errTr (fjEj
i=1^Ii) =n
t2Tr(fjEj
i=1^Ii)j(tO1)2errTr (^I1)
_(tO2)2errTr (^I2)__ (tOjEj)2errTr (^IjEj)o
.
Hence:
OnerrTr (fjEj
i=1^Ii) =n
t2Tr(fjEj
i=1^Ii)j
(tO1)62errTr (^I1)^^ (tOjEj)62errTr (^IjEj)o
=n
t2Tr(fjEj
i=1^Ii)j(tO1)2
O1nerrTr (^I1)
^^ (tOjEj)2
OjEjnerrTr (^IjEj)o
=n
t2Tr(fjEj
i=1^Ii)j(tO1)2Tr(^I1)
^ (tOjEj)2Tr(^IjEj)o
=Tr(fjEj
i=1^Ii).
Since errTr (fjEj
i=1^Ii)errTr (^I) holds from Proposition 2,
OnerrTr (fjEj
i=1^Ii)OnerrTr (^I) also holds.
Hence Tr(fjEj
i=1^Ii)Tr(^I).
We can now show the correctness of our heuristic-based
decomposition technique, by stating and proving the follow-
ing proposition.
Proposition 4 (Correctness). Given the model of a
service composition MCand the specication of its desired
behaviorPwhen interacting with a set of external services
E, the interfaces of the individual external services ^Ii;1
ijEj, when computed applying the aforementioned heuris-
tic, satisfy the following relation:fjEj
i=1^Ii
kMcj=P.
Proof. From [14], we know ^IkMcj=P. Further-
more, from Proposition 3,fjEj
i=1^Ii
j=^I. It follows that
fjEj
i=1^Ii
kMcj=P.Application to the Running Example
By analyzing the global interface specication Ipishowed in
Section 4.2, we notice that the error state can be reached by
executing, in state Q3, the transition labeled with lookup-
Car[0] , which is an operation provided by the CIservice.
The heuristic described above can then be applied to com-
pute the interface for the CPS service.
We rst create a rened model of the global interface, by
removing the transitions that lead to the error state and
that are not labeled with actions belonging to the alphabet
of the CPS service:
Ipi_cps = Q0,
Q0 = (lookupCar[0..1] -> Q0
|carExit -> Q1
|carEnter -> Q2
|{markUnavailable,
markAvailable} -> SINK),
Q1 = (markUnavailable -> Q0
|{carExit, carEnter, markAvailable,
lookupCar[KEY]} -> SINK),
Q2 = (markAvailable -> Q3
|{carExit, carEnter, markUnavailable,
lookupCar[KEY]} -> SINK),
Q3 = (carExit -> Q1
|carEnter -> Q2
|lookupCar[1] -> Q3
|{markUnavailable,
markAvailable} -> SINK),
SINK = ({carExit, carEnter,
markUnavailable, markAvailable,
lookupCar[KEY]} -> SINK).
Next, the global interface specication is restricted over the
alphabetfcarEnter ,carExitg; the resulting LTS is:
CPS = Q0,
Q0 = ({carEnter, carExit} -> Q0).
As expected, this new interface, obtained for the CPS ser-
vice with the application of the heuristic, allows for more
behaviors than the one computed with the basic technique.
More specically, in this case the interface represents the
universal interface of service CPS, i.e., the interface that al-
lows any of its operations. Since the error behaviors of the
system are prevented by the interface of the other service
(CI), there is no need to constrain the interface of CPS.
As for the interface specication of service CI, the appli-
cation of the heuristic does not aect its generation, i.e., it
coincides with the one shown in Section 5.1.
5.3 Discussion
Validation of the Generated Interfaces
Although the denition of the interface decomposition prob-
lem includes a correctness requirement, which guarantees
that the generated interfaces will not lead the system into
the error state, this is not enough to characterize the quality
of the generated interfaces. Ideally, they should be validated
by using some kind of oracle, such as descriptions of good
and bad behaviors, usually dened by domain experts or
encoded in a certain model.
For example, assuming the availability of the implementa-
tion of a partner service Ei, we could check if Eij=^Ii, where
^Iiis derived from ^Ii, which is the interface specication
computed for Ei. This check can be performed with a modelchecker, such as JavaPathFinder [16] for Java-based imple-
mentations, or WS-Engineer [10] for services implemented
in BPEL. However, this approach may rarely be feasible in
the realm of services, since usually the implementations of
the external services are not publicly available. Violations
identied during such checks may signify either that a part-
ner service is not appropriate for the desired composition, or
that the interface generated may need to be rened. A do-
main expert would therefore need to inspect violations and
decide on a course of action.
Domain expertise can also be used to validate directly the
generated interfaces, to assess if they are either too strict
or too weak, by analyzing the allowed (or disallowed) be-
haviors. In this sense, in Section 5.1 we used our domain
knowledge to (informally) claim that the interface generated
for the CPS service was too restrictive.
Specic to the interface decomposition problem is to check
if some behaviors, originally allowed by the global interface
specication, are lost by the decomposition process. The
lost behaviors can be discovered by checking the following
relation: Tr(^I)Tr(fjEj
i=1^Ii). This check can be performed
with a model checker, such as LTSA. We expect this relation
to not always hold, since some behaviors will be lost, as said
above. However, when the check does not hold, the user can
iteratively inspect each counterexample, to discriminate if it
represents a sink behavior, which cannot be realized in the
actual system and thus can be ignored, or if it is actually a
missing behavior, which can then be added to the interface
specication, which is thus rened.
Limitations of the Heuristic
In our running example, the interfaces we obtained for the
partner services were satisfactory; however our experimen-
tation has shown that this may not always be the case.
For example, consider an environment consisting of two
services,E1andE2, withE1providing operation c, andE2
providing operations aand b. Assume the following LTS
model represents the global interface:
S0 = (c -> S0 | b -> S1 | a -> S2),
S1 = (a -> S0 | b -> S1 | c -> S1),
S2 = (c -> ERROR | b -> S0 | a -> S2).
By decomposing this interface to compute ^I1and ^I2, we no-
tice that our heuristic blocks E1completely (no operation
can be performed on it), while generates the universal inter-
face forE2.
More generally, our heuristic may block some good behav-
iors of the individual services, which instead could be safely
allowed. This may happen because an operation of a ser-
vice that directly leads to the error state, which is the one
considered by our heuristic, may be actually triggered by
an operation of another service. In the example above, the
transition c -> ERROR is actually performed only after the
transition a -> S2 occurs; another heuristic could then al-
lowE1to perform c, while the interface of E2could mandate
the execution of band ain this order.
6. EV ALUATION
The interface specications decomposition technique has
been implemented in the LTSA tool; here we report about
the evaluation of our approach on two case studies. Each
case study consisted of a service composition in the formof a BPEL process, of the syntactical interfaces (WSDL de-
scription) of the partner services of the composition, and of
an informal description of the requirements that the compo-
sition had to fulll.
The BPEL processes have been translated into the input
format of the LTSA tool by means of WS-Engineer; the re-
quirements have been rst formalized in a temporal logic
and then translated into an LTS description. The exper-
iments have been executed on a computer running Apple
Mac OS X 10.6.4 with a 2 :16 GHz Intel Core 2 Duo proces-
sor and 2 GiB of memory.
6.1 Car Rental (full version)
This case study is the full-edged version of the exam-
ple described in Section 3, with which it also shares the
same requirements specication. The main dierence lies
in a ne-grained description of the BPEL process, which
leads to more rened, and sometimes verbose, interface de-
scriptions. For example, the two single transitions lookup-
Car[0..1] that in the running example correspond to in-
voking the lookupCar operation of the CIservice and re-
ceiving, as output parameter, either 0 or 1, are expanded in
a sequence of four operations: hcr_ci_invoke_lookupcar ,
cr_ci_receive_lookupcar ,cr_ckr.condition.read.false ,
cr_ckr.condition.read.true i.
If we consider this kind of expansion, we easily conclude
that the interfaces generated are equivalent to, but bigger |
in term of size of the model | than the ones built obtained
for the running example. For example, the interface of the
CIservice is the following:
CIS = Q0,
Q0 = (cr_ci_invoke_markcarunavailable -> Q0
|cr_ci_invoke_lookupcar -> Q2
|cr_ci_invoke_markcaravailable -> Q3),
Q2 = (cr_ci_receive_lookupcar -> Q4),
Q3 = (cr_ci_invoke_markcarunavailable -> Q0
|cr_ci_invoke_markcaravailable -> Q3
|cr_ci_invoke_lookupcar -> Q5),
Q4 = (cr_ckr.condition.read.{false, true} -> Q0),
Q5 = (cr_ci_receive_lookupcar -> Q6),
Q6 = (cr_ckr.condition.read.false -> ERROR
|cr_ckr.condition.read.true -> Q3).
The interface of the CPS service, as before, remains the
universal interface.
In this example, the LTS model of the service composition
contains 16 states and 20 transitions; the global interface
specication contains 9 states and 22 transitions, and was
built in 70 ms; the interface specications of the services CI
and CPS were built, respectively in 90 ms and 75 ms.
Validation against Original SpeciÔ¨Åcations
The original example denition [5] contained a set of logi-
cal specications of the behavior expected from the external
services, manually written by the authors of the paper. We
consider these specications as a possible oracle for evaluat-
ing how well our technique performs and thus we compared
these specications with the ones generated by the tool.
The specication of the CIservice was \If the car is marked
as available in the CI Service, and the car is not marked as
unavailable until a lookupCar operation is invoked, then the
lookupCar operation should return successfully" . It is clear
that this behavior is captured by the interface specication
generated for the CIservice.For the CPS service, the specication was \between two
events signaling that the car exits the parking lot, an event
signaling the entrance for the same car must occur" ; basi-
cally it states the two events\car enter"and\car exit"should
alternate. The interface specication obtained for this ser-
vice, however, is the universal interface. In our opinion, this
result is still correct, even if less useful, because the CPS
service cannot be responsible for violations of the expected
requirement.
In LTSA we have also implemented the possibility to search
for and analyze lost behaviors, by checking Tr(^I)Tr(fjEj
i=1^Ii).
This check failed, revealing one lost behavior whose trace is:
cr_ci_invoke_markcaravailable, cr_ci_invoke_lookupcar,
cr_ci_receive_lookupcar,c r_ckr.condition.read.false.
This trace can be interpreted as \if the car is marked as
available in the parking lot, then a request for the car will re-
turn a negative result" , which is an incorrect behavior. Note
that this behavior is disallowed by the structure of the com-
posite service, since cr_ci_invoke_markcaravailable will
never be executed as the rst action. Therefore we can safely
state that this behavior has been added to the global inter-
face specication through the completion with the sink state;
it will never occur in the real system. This is the reason for
which it is also missing from the interfaces derived for the
partner services.
6.2 Order Booking
This case study has been taken from the sample processes
distributed with the Oracle SOA Suite 10gR3. It consists of
a process that is started when a customer places an order
from a client web application. The process rst inserts the
order information in a database through the ERPService ,
then it retrieves customer information by invoking the Cus-
tomerService . The process checks the customer's credit card
by invoking the CreditService and then determines if the or-
der requires manual approval by invoking the DecisionSer-
vice (DS) , which applies some business rules that take into
account the status (platinum or not) of the customer. For
orders that require manual approval, the process invokes the
requiresApproval operation on the Manager Web service.
When an order is approved, the process requests, in parallel,
quotes from the suppliers, SelectManufacturer and Rapid-
Service , and then selects the supplier that responded with
the lower quote. Afterwards, a shipping method is chosen by
checking the amount of the order. After updating the order
status on the database through the ERPService , the project
sends a conrmation email to the customer, by invoking the
EmailService , and then terminates.
A possible requirement specications for this composite
service is: \if a platinum customer places an order, it must
be automatically approved; otherwise it must be approved
manually" . This specication indirectly requires a certain
behavior of the DSservice, which we picked as the service
for which to compute the interface specication.
We translated this specication into a property LTS and
then applied the interface decomposition method based on
the heuristic, to obtain the interface for the DSservice.
We omit its textual representation for space reasons but,
in essence, it states that \if a platinum customer places an
order, then the return value will not be manual approval ,
and equivalently, if a non-platinum customer places an or-
der, then the return value will not be automatic approval ".This specication matches the one informally described in
the documentation of the example.
Since we were not interested in getting an individual inter-
face specication for each of the other partner services, we
generated an interface for them when considered as a whole
and, as expected, we obtained the universal interface.
The LTS model of the composite service contains 80 states
and 93 transitions; the global interface specication contains
29 states and 63 transitions, and was built in 76 ms; the in-
terface specication of the DSservice contains 6 states and
12 transitions, and was built in 82 ms. The interface for
the rest of the components contains only one state, allowing
all possible behaviors (i.e., it encodes the universal environ-
ment). A search for lost behaviors reveals two behaviors,
which a manual inspection shows to be sink.
7. RELATED WORK
This work is closely related to the problem of synthesiz-
ing individual service behaviors from a choreography speci-
cation, such as conversation protocols [12], WS-CDL mod-
els [24], and collaboration diagrams [25]. These works dene
aprojection operation that derives the implementations of
the participating peers by ltering the global specication on
the actions alphabet of each peer, which is similar in spirit to
the basic decomposition approach described in Section 5.1;
additionally, in [25], extra communication actions among the
generated peers are added in case some behaviors may not
be realizable in a distributed fashion. The dierence with
our work lies in the point of view adopted: the aforemen-
tioned works consider a superset of the possible behaviors
and narrow it down to achieve the exact behavior dictated
by the choreography specication. In our work, we view
the global interface as the maximum behavior that could be
allowed for the composition based on a property, and we
generate a subset of the possible behaviors. Our process is
driven by the error behaviors that have to be blocked; error
traces guide us in the heuristic to assign to partner services
the responsibility of blocking those behaviors.
Still related to the synthesis problem, reference [19] shows,
in the context of verication of choreographies expressed
in BPEL4CHOR, how a single participant of a choreogra-
phy can be synthesized starting from the description of the
choreography and from the BPEL models of the other par-
ticipants. Besides the limitation of synthesizing at most one
participant, this work makes the assumption that the BPEL
models of the other participants are available; this assump-
tion is unrealistic in the context of open-world services.
The problem of generating the interface of the environ-
ment of a system, given a property it should satisfy, has
been originally dealt with in [14], in the context of model
checking. However, the approach generates only the global
interface, not the interfaces of the individual components of
the system. Other work [7] describes a compositional reason-
ing approach for the verication of middleware-based soft-
ware architecture descriptions. Given a graphical scenario of
the architecture of a generic application in terms of Message
Sequence Charts (MSCs), the approach tries to verify the
global property by verifying local properties of the architec-
tural components. This last step requires to decompose the
global property into local properties; the decomposition is
based on the analysis of the structure of the MSCs, which
is similar to our heuristic that considers the structure of the
global interface specication.The use of a description of the system requirements to
generate behavioral models of the system components is
also common in the context of behavioral model synthe-
sis. One approach [9] proposes to inductively synthesize the
LTS models of each system component from a set of end-
users scenarios, both positive and negative, in the form of
MSCs. The approach operates at the stage of requirements,
where users can interactively rene the scenario-based de-
scription by answering questions; in our work, we assume
the requirements are xed and thus rely on the accuracy
of the specication to get expressive interfaces. The ap-
proach presented in [1] derives operational requirements (in
the form of pre- and trigger-conditions) from goal models,
using a combination of model checking, inductive learning
and manual elaboration of scenarios; however, the approach
does not support learning the operational requirements for
an individual component of a system. In [17], behavioral
models, in the form of Modal Transition Systems, are gen-
erated at the component level from a set of scenarios and
property specications. The algorithm assumes that domain
variables are used for dening the pre- and post-conditions
of component operations; however, for service components,
pre- and post-conditions are usually not available. Another
technique [26] constructs behavioral models (in the form of
Modal Transition Systems) from both safety properties and
scenario-based specications; however, the models generated
are at the system level, not at the component level.
While the main motivation behind this work is to decom-
pose a global specication of a system to obtain the individ-
ual specications of the system components, which would
otherwise be unknown, other approaches perform decompo-
sition of a global specication either to reduce the size of the
model to verify | as in [18, 6], with the application of slic-
ing | or to support compositional verication for systems
that are not structured into parallel components [22].
Inferring the specications of components is also a goal
shared with program specication miners, such as Adabu [27]
and GK-tail [20]. These approaches usually perform static
analysis, code instrumentation and analysis of the execution
traces to derive the usage patterns of components and thus
need to access the code of the components for which you
want to discover the specication. This latter step is not
feasible in the domain of service-oriented computing. In the
context of Web services, the Strawberry approach [3] derives
the behavioral model of a service by analyzing its syntacti-
cal interface and applying a combination of graph synthesis,
heuristics and testing. However, all these approaches con-
sider the behavior of a single service (component) in isola-
tion, while we are interested in discovering the behavioral
interfaces of components that guarantee the requirements of
the composite application.
The work in [15] presents a generic theoretical assume-
guarantee framework for adaptable systems that guarantees
that adaptation-related changes do not aect the global in-
variant of the system. It assumes the availability of existing
techniques to perform assumptions generation and system
and property decomposition. The last one is a direction
toward which this work can contribute.
8. CONCLUSION AND FUTURE WORK
The correct behavior of a service composition, with re-
spect to its requirements specication, depends on a certain,
expected behavior of its partner services. However, most ofthe times the behavioral descriptions of the partner services
are unknown. In this paper, we have presented our novel
technique to automatically generating the behavioral inter-
faces of the partner services of a service composition, by
decomposing the requirements specication of the compos-
ite services. We have formalized this problem, proposed a
heuristic-based technique to solve it, implemented this tech-
nique in the LTSA tool and applied it to two case studies.
We plan to further develop and improve the technique
presented in this paper. First, we will consider alternative
heuristics, to address the limitations of the current one. For
example, we want to assess precisely to which extent a part-
ner service contributes to fulll (or not) the global require-
ments. This is particularly important in the case in which
multiple partner services have operations that could possi-
bly lead to the error state. Secondly, we will support the
renement of the generated specications, by extending the
analysis of the counterexamples to lter missing behaviors
(for example, by performing behavior realizability analysis
as suggested in [25]). Last, we will add support for timed
property specications.
Acknowledgments
This work has been partially supported by the Swiss NSF
projects no. 125337-CLAVOS and no. 125604; by the EU
under the grant agreement no. EU-FP7-215483-S-Cube and
the IDEAS-ERC grant agreement no. 227977-SMScom. The
authors wish to thank Howard Foster for his promptly sup-
port with the WS-Engineer tool; Ivo Krka for his comments
on an earlier version of the paper.
9. REFERENCES
[1] D. Alrajeh, J. Kramer, A. Russo, and S. Uchitel.
Learning operational requirements from goal models.
InProc. of ICSE'09 , pages 265{275. IEEE, 2009.
[2] L. Baresi, E. Di Nitto, and C. Ghezzi. Towards
Open-World Software: Issues and Challenges. IEEE
Computer , 39:36{43, 2006.
[3] A. Bertolino, P. Inverardi, P. Pelliccione, and
M. Tivoli. Automatic synthesis of behavior protocols
for composable Web-services. In Proc. of
ESEC/FSE '09 , pages 141{150. ACM, 2009.
[4] D. Bianculli, C. Ghezzi, and C. Pautasso. Embedding
continuous lifelong verication in service life cycles. In
Proc. of PESOS 2009 , pages 99{102. IEEE, 2009.
[5] D. Bianculli, C. Ghezzi, P. Spoletini, L. Baresi, and
S. Guinea. A guided tour through SAVVY-WS: a
methodology for specifying and validating Web service
compositions. In Advances in Software Engineering ,
volume 5316 of LNCS , pages 131{160. Springer, 2008.
[6] I. Br uckner. Slicing concurrent real-time system
specications for verication. In Proc. of IFM 2007 ,
volume 4591 of LNCS , pages 54{74. Springer, 2007.
[7] M. Caporuscio, P. Inverardi, and P. Pelliccione.
Compositional verication of middleware-based
software architecture descriptions. In Proc. of
ICSE'04 , pages 221{230. IEEE, 2004.
[8] S. C. Cheung and J. Kramer. Checking safety
properties using compositional reachability analysis.
ACM Trans. Softw. Eng. Methodol. , 8(1):49{78, 1999.
[9] C. Damas, B. Lambeau, P. Dupont, and A. van
Lamsweerde. Generating annotated behavior modelsfrom end-user scenarios. IEEE Trans. Softw. Eng. ,
31(12):1056{1073, 2005.
[10] H. Foster. WS-Engineer 2008: A service architecture,
behaviour and deployment verication platform. In
Proc. of ICSOC 2008 , volume 5364 of LNCS , pages
728{729. Springer, 2008.
[11] H. Foster, S. Uchitel, J. Magee, and J. Kramer.
Model-based verication of Web service compositions.
InProc. of ASE 2003 , pages 152{163. IEEE, 2003.
[12] X. Fu, T. Bultan, and J. Su. Conversation protocols: a
formalism for specication and verication of reactive
electronic services. Theor. Comput. Sci. ,
328(1-2):19{37, 2004.
[13] D. Giannakopoulou and J. Magee. Fluent model
checking for event-based systems. In Proc. of
ESEC/FSE-11 , pages 257{266. ACM, 2003.
[14] D. Giannakopoulou, C. P as areanu, and H. Barringer.
Assumption generation for software component
verication. In Proc. of ASE 2002 , pages 3{12, 2002.
[15] P. Inverardi, P. Pelliccione, and M. Tivoli. Towards an
assume-guarantee theory for adaptable systems. In
Proc. of SEAMS 2009 , pages 106{115. IEEE, 2009.
[16] JavaPathFinder.
http://babelfish.arc.nasa.gov/trac/jpf .
[17] I. Krka, Y. Brun, G. Edwards, and N. Medvidovi c.
Synthesizing partial component-level behavior models
from system specications. In Proc. of ESEC/FSE'09 ,
pages 305{314. ACM, 2009.
[18] S. Labbe, J.-P. Gallois, and M. Pouzet. Slicing
communicating automata specications for ecient
model reduction. In Proc. of ASWEC'07 , pages
191{200. IEEE, 2007.
[19] N. Lohmann, O. Kopp, F. Leymann, and W. Reisig.
Analyzing BPEL4Chor: Verication and participant
synthesis. In Proc. of WS-FM 2007 , volume 4937 of
LNCS , pages 46{60. Springer, 2008.
[20] D. Lorenzoli, L. Mariani, and M. Pezz e. Automatic
generation of software behavioral models. In Proc. of
ICSE'08 , pages 501{510. ACM, 2008.
[21] J. Magee and J. Kramer. Concurrency: State Models
And Java Programs . John Wiley & Sons, 2006.
[22] B. Metzler, H. Wehrheim, and D. Wonisch.
Decomposition for compositional verication. In Proc.
of ICFEM'08 , volume 5256 of LNCS , pages 105{125.
Springer, 2008.
[23] OASIS. Web Service Business Process Execution
Language Version 2.0 Specication, 2007.
[24] Z. Qiu, X. Zhao, C. Cai, and H. Yang. Towards the
theoretical foundation of choreography. In Proc. of
WWW 2007 , pages 973{982. ACM, 2007.
[25] G. Sala un and T. Bultan. Realizability of
choreographies using process algebra encodings. In
Proc. of IFM 2009 , volume 5423 of LNCS , pages
167{182. Springer, 2009.
[26] S. Uchitel, G. Brunet, and M. Chechik. Synthesis of
partial behavior models from properties and scenarios.
IEEE Trans. Softw. Eng. , 35(3):384{406, 2009.
[27] A. W. Valentin Dallmeier, Christian Lindig and
A. Zeller. Mining object behavior with ADABU. In
Proc. of WODA 2006 , pages 17{24. ACM, 2006.