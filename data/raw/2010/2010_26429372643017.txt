Static, Lightweight Includes Resolution for PHP
Mark Hills1
1East Carolina University
Greenville, NC, USAPaul Klint2and Jurgen J. Vinju2,3
2Centrum Wiskunde & Informatica, Amsterdam,
The Netherlands
3INRIA Lille Nord Europe, Lille, France
ABSTRACT
Dynamic languages include a number of features that are
challenging to model properly in static analysis tools. In
PHP, one of these features is the include expression, where
an arbitrary expression provides the path of the ﬁle to include
at runtime. In this paper we present two complementary
analyses for statically resolving PHP includes, one that works
at the level of individual PHP ﬁles, and one targeting PHP
programs possibly consisting of multiple scripts. To evaluatethe eﬀectiveness of these analyses we have applied the ﬁrst to
a corpus of 20 open-source systems, totaling more than 4.5
million lines of PHP, and the second to a number of programs
from a subset of these systems. Our results show that, inmany cases, includes can be resolved to a speciﬁc ﬁle or asmall subset of possible ﬁles, enabling better IDE features
and more advanced program analysis tools for PHP.
Categories and Subject Descriptors
F.3.2 [ Logics and Meanings of Programs ]: Semantics
of Programming Languages— Program Analysis ;D . 3 . 3[ Pro-
gramming Languages ]: Language Constructs and Fea-
tures
General Terms
Languages, Measurement, Experimentation
Keywords
Static analysis; dynamic language features; PHP
1. INTRODUCTION
PHP, invented by Rasmus Lerdorf in 1994, is an imperative,
object-oriented language focused on server-side application
development. It is now one of the most popular languages,
as of July 2014 ranking 7th on the TIOBE programming
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributedfor proﬁt or commercial advantage and that copies bear this notice and the full cita-tion on the ﬁrst page. Copyrights for components of this work owned by others thanACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-publish, to post on servers or to redistribute to lists, requires prior speciﬁc permissionand/or a fee. Request permissions from permissions@acm.org.ASE’14, September 15-19, 2014, V asteras, Sweden.
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00.http://dx.doi.org/10.1145/2642937.2643017.community index,1used by82.2percent of all websites whose
server-side language can be determined,2and ranking as the
4th most popular language on GitHub by repositories created
in 2013.3PHP is dynamically typed, with a single-inheritance
class model (including interfaces) and a number of standard
built-intypes(e.g., strings, integers, ﬂoats). Typecorrectness
is judged based on duck typing , allowing values to be used
whenever they can behave like values of the expected type.
For instance, adding the strings "3"and"4"yields the
number 7, while concatenating the numbers 3and4yields
the string "34". Along with dynamic types, PHP includes
a number of dynamic language features also found in other
dynamic languages such as Ruby and Python, including an
evalexpression to run dynamically-built code and special
methods (referred to as magic methods ) that handle accesses
ofobjectﬁeldsandusesofmethodsthatareeithernotdeﬁned
or not visible.
Although the popularity of PHP should have resulted in
a plethora of powerful development tools, so far this has
not been the case. We believe this is because the samedynamic features that make PHP so ﬂexible also make it
challenging for static analysis. This hinders the creation of
the static analyses needed as the foundation on which these
programmer tools are built, and also causes challenges for
static analysis tools used for tasks such as security analysis,
a topic we touch on brieﬂy in Section 6.
In this paper, we focus on one speciﬁc dynamic feature: the
PHP ﬁle inclusion mechanism. In PHP, like in many other dy-namic languages, ﬁle inclusion is performed dynamically—the
ﬁle to be included is speciﬁed using an arbitrary expression
which, at runtime, evaluates to a ﬁle path. The ﬁle at this
path is then loaded, with some parts of the ﬁle brought in as
top-level deﬁnitions (e.g., classes and functions) and other
parts inserted directly at the point of the call and executed.
This provides an obvious challenge for static analysis—it may
not be possible to even determine the source code that needsto be analyzed until runtime. Precise resolution of includes isa prerequisite for any form of static analysis or IDE support.
Is it really the case, though, that these dynamic includes
are truly dynamic, or is it possible to resolve many of them
statically? In prior work [6], we showed that the latter is
1http://www.tiobe.com/index.php/content/
paperinfo/tpci/index.html
2http://w3techs.com/technologies/details/
pl-php/all/all
3The query for this is based on http://adambard.com/
blog/top-github-languages-for-2013-so-far/ ,
but including the entire year.
503
Find Include 
FilePath starts with 
directory characters?
File MissingFile FoundLookup File 
Using Directory 
InfoFile found using 
include path?File found using 
including script path?File found using 
current working 
directory?
File located?No
Yes
Yes
NoYes Yes YesNo No
No
Figure 1: The PHP File Inclusion Process.
actually the case: many apparently dynamic includes are
in practice static. String building expressions used in these
includes are not often used in a truly dynamic fashion, where
the ﬁle that is included depends on a dynamic value. Instead
they are used for the mundane task of navigating the local
ﬁle system towards a single ﬁle, taking advantage of system
wide constants and functions for string concatenation and
directory navigation.
The main contributions presented in this paper are as
follows. First, taking advantage of the ﬁndings of our prior
work, we have developed two includes resolution algorithms.
The ﬁrst analysis, dubbed FLRES,l o o k sa tas p e c i ﬁ cP H Pﬁ l e
in isolation, quickly determining which ﬁles could be includedby each
include expression in that ﬁle. This analysis works
with any PHP ﬁle in the system, and is intended to provide
information for more precise analysis as well as supportfor IDEs. The second analysis, dubbed PGRES, looks at a
speciﬁc PHP program—a page loaded from a server, or a
command-line program—and attempts to resolve all includes
for this program, even those that are loaded transitively by
already included ﬁles. This analysis is more precise, since
the context of the initial include expression is sometimes
required for correct resolution, and also models the possibilitythat the ﬁle cannot be determined statically, such as in cases
where includes are used to load plugins. Determining the
actual ﬁle or ﬁles that can be included at runtime allowsstatic analysis tools to get access to more of the programsource that will be executed, opening up possibilities formore powerful analysis techniques to be applied [17] and
enabling more powerful developer tools, including tools for
ﬁnding errors, performing code refactoring, detecting security
violations, and supporting standard IDE services such as
“Jump to deﬁnition”.
Second, to ensure these algorithms work in practice, we
have validated them empirically. FLREShas been validated
againstacorpusof20open-sourcesystems, madeupof32,682source ﬁles and 4,593,476 lines of code, while PGREShas been
validated against a number of programs from these systems.
This corpus includes a number of the most used PHP systems,
including well-known systems such as WordPress, Joomla,
and MediaWiki as well as frameworks such as Symfony.
The rest of the paper is organized as follows. In Sec-
tion 2, we discuss PHP includes in more depth, describ-ing the method used by PHP to resolve includes at run-time, showing examples of both static and dynamic in-cludes, and describing which cases we focus on in this pa-per. Following this, in Section 3 we present FLRES, with
PGRESpresented in Section 4. To show that the analy-
ses work in practice, Section 5 evaluates the eﬀectivenessof these algorithms using the corpus mentioned above. Fi-nally, Section 6 describes related work, and Section 7 con-cludes. All software used in this paper, including the cor-pus used for the validation, is available for download at
https://github.com/cwi-swat/php-analysis .
2. OVERVIEW
Here we explain how includes work in PHP, the technical
context of our work, and the necessity of creating two distinct
algorithms for resolving includes.
2.1 PHP Include Semantics
In PHP, include expressions are used to include the
contents of one ﬁle into another at runtime. We list here what
the PHP interpreter normally does dynamically, and what
our two algorithms approximate statically in a conservative
fashion. The include expressiontakesa single operand; this
o p e r a n di se x p e c t e dt oe v a l u a t et oas t r i n gc o n t a i n i n gt h eﬁ l e
name, possibly including some information about the path
to the ﬁle. This operand can either be given statically ,a sa
string literal, or dynamically , using an arbitrary expression
that yields a string.
Once the operand is evaluated, the include mechanism
associates the string result (referred to below just as the ﬁle
name, although it may include path information as well) to an
actual ﬁle (referred to here as the target ﬁle ), present either
in the system or in installed libraries. This ﬁle resolutionis normally done by the PHP interpreter according to the
dynamic process depicted in Figure 1. If the ﬁle name starts
with“directory characters”, e.g., \,/,.,o r.., the target
ﬁle is looked up using this directory information. File namesbeginning with
\or/are absolute paths, looked up from the
root (of the site for websites, or the ﬁle system for command-
line tools), while names beginning with .or..are relative
paths, looked up starting in the directory containing the
script currently being executed.
Otherwise, the target ﬁle is computed using the following
process. First, the ﬁle name is looked up starting from each
directory given as part of the include path. The lookup
5041// 1. /includes/normal/Utf8Test.php, line 30
2require_once ’UtfNormalDefines.php’;
3
4// 2. /includes/UserMailer.php, line 240
5require_once( ’Mail.php’ );
67
// 3. /maintenance/showStats.php, line 31
8require_once( dirname(__FILE__) . ’/Maintenance.php’);
9
10// 4. /tests/jasmine/spec_makers/makeJqueryMsgSpec.php,
11// lines 17 and 19
12$maintenanceDir = dirname(dirname(dirname(dirname(
13 dirname(__FILE__))))).’/maintenance’;
14require( "$maintenanceDir/Maintenance.php" );
1516
// 5. From /includes/Skin.php, lines 151 to 154
17$deps = "{$wgStyleDirectory}/{$skinName}.deps.php";
18if(file_exists($deps)) { include_once($deps); }
Figure 2: Includes in MediaWiki 1.19.1.
stops when the target ﬁle is found, even if other, later entries
in the include path have not been tried. The include path
can hold either absolute or relative paths—although it isdiscouraged, the current directory
.is often given in the
include path. Next, the current working directory, which
may be diﬀerent from the directory containing the executing
script, is checked for the ﬁle. Finally, an attempt is made to
ﬁnd the target ﬁle by looking it up in the directory containing
the executing script. If the ﬁle is not found in any of these
locations, or if the lookup based on absolute or relative paths
discussed above fails to ﬁnd the ﬁle, the process ends in the
“ﬁle missing”node, meaning the include cannot be performed.
In summary, the semantics of dynamic includes are aﬀected
by the given ﬁle name, the include path, and the locationand working directory of the script, and the ﬁle system is
searched in a well-deﬁned order for the ﬁle being included.
When the include expression is evaluated, any functions,
classes, interfaces, and traits in the target ﬁle are included
into the current global scope. The other contents of the
included ﬁle are executed as part of evaluating the expression,
and inherit the current execution environment, meaning
they run as if they were inserted at the spot of the original
include .Areturn statement evaluated in the included
code will immediately return back to the point of the original
include expression, skipping the rest of the code that would
normally be evaluated. The value of an include expression
isFALSEin case of failure, and either 1 or the explicitly
returned value in the case of success.
Iftheﬁletobeincludeddoesnotexist, astandard include
expression will issue a warning, while a variant, require ,
will produce a fatal error. If the ﬁle to be included has
already been included, it will be included again unless the
oncevariants— include_once andrequire_once —are
used. These variants ensure that the contents of a ﬁle areincluded at most once. In the remainder of this paper wedo not bother to distinguish between these variants sincethey do not inﬂuence the operation of the two resolution
algorithms.
Several example include expressions from MediaWiki
1.19.1 are shown in Figure 2. In the ﬁrst example, the in-
cluded ﬁle, UtfNormalDefines.php , is given statically,
and is found in the same directory as the ﬁle with the
include expression, Utf8Test.php . Since no path in-
formation is given, this ﬁle will be found by looking in the
include path (if one is given) and then in the directory of the
including script, by which point it will deﬁnitely be found.
In the second example, the included ﬁle, Mail.php ,i sa l s ogiven statically. However, Mail.php is not part of Media-
Wiki, but is instead part of the PEAR Mail package, and is
found by looking on the include path.
We classify the remaining three examples, and others like
them, as dynamic includes. In the third example, __FILE__
is a so-called“magic constant”; __FILE__ evaluates to the
full path, including ﬁle name, of the ﬁle which uses it.
dirname is a standard library function which returns the
parent directory of a ﬁle. Taken together, this will evaluate tothe absolute path of the
/maintenance directory, with the
string concatenation operation (i.e., the dot operation) then
adding the ﬁle Maintenance.php to the end of the path.
The fourth example provides an alternate way of looking up
the same ﬁle: the starting directory is more deeply nested,
so more calls to dirname are used, with the result assigned
to variable $maintenanceDir . This is then used inside a
string built using string interpolation (the variable is replaced
by its value) and the name of the Maintenance.php ﬁle.
Finally, in the ﬁfth example, the location of the ﬁle is built asa string expression with two variables, one for the MediaWiki
style directory and one for the name of the“skin”used to
customize site appearance. The resulting ﬁle path is saved
into a variable; this variable is checked to see if the ﬁle existsand, if so, the ﬁle is included. Of these three dynamic include
examples, we are currently able to resolve the ﬁrst two to
unique target ﬁles using the techniques described below. The
last is truly dynamic, and cannot be resolved to a singleﬁle—the best that can be done is to partially resolve it to
those ﬁles ending in deps.php.
2.2 The PHP AiR framework
To statically resolve such dynamic includes we analyze
PHP using Rascal as part of our ongoing work on PHP AiR,
a framework for PHP Analysis in Rascal [5]. Rascal [10] is
a meta-programming language for source code analysis and
transformation that uses a familiar Java-like syntax and is
based on immutable data (trees, relations, sets), term rewrit-ing, and relational calculus primitives. All analysis performedin this paper was performed using Rascal code, ensuring that
the results are reproducible and checkable. We also used
Rascal, and its string templating and IO facilities, to gener-
ate the LATEX for the tables in this paper that document the
corpus and the analysis results. All code is available online
athttps://github.com/cwi-swat/php-analysis.
We are parsing PHP scripts using our fork4of an open-
source PHP parser5, which itself is based on the grammar
used inside the Zend Engine, the scripting engine for PHP.
This parser generates ASTs as terms formed over Rascal’s
algebraic datatypes.
2.3 The Need for Two Algorithms
In this paper we present two includes resolution algorithms,
one for individual ﬁles and one for programs. The ﬁrst,FLRES, for individual ﬁles, computes ﬁles that could be
included directly by a given ﬁle, ignoring the contextof the
include —the directory of the original script being executed,
the current working directory, or the include path, all of
which may not be known when looking at the ﬁle in isolation.
The second, PGRES, for programs, is “context-sensitive”,
considering all this information in order to more precisely
resolve the includes in the original ﬁle as well as those brought
4https://github.com/cwi-swat/PHP-Parser
5https://github.com/nikic/PHP-Parser/
505Input :sys, a PHP system, a mapping from ﬁle locations to abstract syntax trees
Input :toResolve , a location indicating the AST in systo be analyzed
Input :baseLoc, a location indicating the root of system sys
Input :libs, a set of locations of known library includes used by sys
Output :Arelation res, from the location of each include expression to the location(s) of possibly included ﬁles
1iinfo←include info cache for sys
2ast←the AST for ﬁle toResolve insys
3includes ←a set containing each include expression in ast
4foreach i∈includes do
5 i←normalizeExpr (replaceConstants (i,iinfo))
6 iloc←the location of i
7 ip←the operand used in iindicating the ﬁle to include
8 ifip is a literal string starting with / then
9 ifsys contains a ﬁle at baseloc + ip then
10 addiloc×(baseloc+ip)t o res
11 remove ifrom include,c o n t i n u ew i t hn e x ti
12 end
13 end
14 foreach ﬁle freturned by matchIncludes (sys, i,baseLoc,libs) do
15 addiloc×(baseloc+ip)t o res
16 end
17end
Algorithm 1: PHP File-Level Includes Resolution Analysis (FLRES).
in as part of the includes process. Since this information is
based on the program ﬁle being run, PGRESis not designed
to be applied to PHP ﬁles that cannot be directly executed.
Figure 3 illustrates one typical scenario where this dis-
tinction is critical. Here, two ﬁles, /A.php (for brevity,
just Abelow) and /admin/B.php (B), both include ﬁle
/includes/C.php (C).Cincludes ﬁle D.php(D), but
does not provide any path information. When looking at C
in isolation— without knowing it is being included by another
ﬁle—the analysis should indicate that either the ﬁle /D.php
(D1) or the ﬁle /admin/D.php (D2) could be loaded by the
include . Note that here this is not an over-approximation,
as each ﬁle could be loaded by this include expression.
The program-level analysis, PGRES, will instead look indi-
vidually at both Aand B, two programs—scripts that can
be invoked directly—and will determine which ﬁles could be
included when either is executed. When Cis included in A,
t h ec o d ec o n t a i n e di nC will be executed in the context of
A.W h e nt h e include expression that includes Dis exe-
cuted, this means it will not run in the context of C—in the
/includes directory—but will instead run in the context of
A.S i n c e D1is in the same directory as Ait will be included
(following the solid line), and the ambiguity over which ver-
sion of Dto include disappears. The same happens with
B—when Cis included, the code in Cruns in the context of
B,w i t h D2found in the same directory as B(the dashed
line), again making the ﬁle to be selected unambiguous.
The ﬁle-level includes analysis, FLRES,i sd e s c r i b e dn e x t
in Section 3. The program-level includes analysis, PGRES,i s
described later in Section 4.
3. FILE-LEVEL INCLUDES RESOLUTION
The FLRESalgorithm (see Algorithm 1) takes as input
a representation of the PHP system under analysis ( sys);
the location of the PHP ﬁle to analyze ( toResolve ); the root
location of the system under analysis ( baseLoc); and in libs
/A.php
...
include '/includes/C.php';...
/admin/B.php
...
include '/includes/C.php';.../includes/C.php
...
include 'D.php';.../D.php
/admin/D.php
Figure 3: An Ambiguous File-Level Include.
the locations of all standard libraries used by sys.T h e sys
representation is a map from ﬁle names to ASTs for each ﬁle
(see Section 2). We need to assume that libsis a correct and
complete list of library dependencies; libscan be empty if
the system does not use any external libraries (those that
come with PHP, such as the standard MySQL libraries, do
not need to be explicitly included to use). iinfois a cache,
similar to that maintained by IDEs, containing information
about the system under analysis, such as the locations ofdeﬁned constants. Currently extracted using Rascal, we
plan to integrate this with Eclipse to allow it to be updated
incrementally as ﬁles are edited.
The algorithm collects all instances of include expressions
in the AST for a script. It then performs two main steps to
ﬁnd the ﬁles that could be included by each. First, the call
toreplaceConstants replaces each constant in the include
expression by the value of the constant, under the conditions
that the constant is deﬁned using a literal value, or an ex-pression that can statically be converted to a literal value,
and that all deﬁnitions of the constant in sysare identical.
Second, the call to normalizeExpr performs a number of
simpliﬁcations, including simulating the eﬀects of common
functions for working with strings and directory names, re-
placing magic constants with their values (shown in Table 1),
and converting concatenations of string literals into a single
literal. This simpliﬁcation process continues until no more
506Constant Name Replacement Value
FILE Absolute path including ﬁle name
DIR Absolute path, without ﬁle name
CLASS Name of the enclosing class
METHOD Name of the enclosing method
FUNCTION Name of the enclosing function
NAMESPACE Name of the enclosing namespace
TRAIT Name of the enclosing trait
Table 1: Magic Constants in PHP.
changes to the expression being simpliﬁed are found. A com-
mon example of how magic constants are used in include
expressions in combination with builtin functions is shown
in Figure 2 in the third example, where __FILE__ is used
in conjunction with the dirname function. This algebraic
simpliﬁcation process is run repeatedly to take advantage of
new opportunities for replacements, until no more constant
expressions can be collapsed into literal expressions.
At this point, if the expression indicating what to include
(given as ip) is a literal string starting with /(or\), an
attempt is made to ﬁnd the ﬁle in sysby adding ipto the
end of baseloc. If this ﬁle is found, we consider the include to
be resolved and add this mapping to res, which is a relation
from include locations to the locations of the ﬁles that could
be included at each location. We also skip the rest of this
i t e r a t i o no ft h el o o p .I fip is not a literal string starting with
/, or if the ﬁle lookup failed, FLRESinstead attempts to use
matching against the literal suﬃx of ip. Only this suﬃx is
used in this match because expressions in the include could
modify the path in unexpected ways (e.g., navigating to a
parent directory). All ﬁles in sysand in libsthat match are
returned. In some cases—where ipis an arbitrary expression,
or ends in an arbitrary expression—this could be all the ﬁles
in both. A pair, consisting of the location of i(given as iloc)
end each returned ﬁle f, is then added into res.
In summary, FLRESis a fast, lightweight algorithm that
is based on straightforward algebraic simpliﬁcation and con-
stant propagation. In Section 5 we will evaluate how accu-
rately it performs on real PHP systems.
Soundness: FLRESprovides a sound over-approximation
of the ﬁles that could be included by each include expression
in a ﬁle under two conditions. The ﬁrst condition is that theﬁles given in
sysandlibsare actually all the ﬁles that could
be included. If, for some reason, additional libraries are being
used but are not included in libs, these ﬁles will be missed.
Files included using evalare also not detected (although
we are unaware of any code in the corpus that actually
does this). The second condition is that the constants used
in an include expression are actually visible at that pointin the code. For instance, when given an include path like
ROOT . ’myfile.php’ , if there is a unique constant ROOT
deﬁned as ’/base/’ FLRESa s s u m e st h i sc o n s t a n ti sb e i n g
used. However, if a constant is not visible, the name of the
constant is instead treated as a string literal, meaning the
above should attempt to include ﬁle ROOTmyfile.php .W e
are unaware of any cases where this speciﬁc scenario occurs
in practice (it is more likely that the include would just fail),
but it is a theoretical possibility.4. PROGRAM-LEVEL RESOLUTION
The PGRESalgorithm (see Algorithm 2) receives six inputs.
The ﬁrst four are the same inputs given to FLRES.T h e
ﬁfth parameter, ipath, represents the include path for PHP,
and is given as a list of locations. To remain sound, thealgorithm makes few assumptions about the include path;
PGRESassumes that the given include path is accurate, but
additional entries may be present if language features that
can alter the include path are reachable, something checked
in the body of the algorithm. The sixth argument, ﬂres,i s
the output of FLRES, which serves as a starting point for
PGRES. Part of this information is the include expression,
with the replaceConstants andnormalizeExpr steps
already applied, meaning that this does not need to be done
again here. The iinfoon line 1 is the same cached system
information used in FLRES.
On line 2, the initial include graph, igraphis constructed.
Starting from toResolve , and using the already-computed
information from FLRESinﬂres, a node is created for each
reachable script in sysand library in libs.As i n g l ee d g ei s
created for each include , with a single source node (the
script containing the include ) and a set of possible targets.
On line 3, setsIPis computed. This set contains the
locationsofallreachablescriptsthatmaysetthePHPinclude
path or the PHP working directory at runtime. The include
path can be changed by calling the set_include_path
function or the ini_set function (although, for caveats, see
the discussion of soundness below) and supplying the newinclude path. In both cases, the include path is changed
for the remainder of the script. In the case of ini_set ,t o
maintain soundness, we assume the call couldset the include
path unless a string literal is used to name a diﬀerent setting.
The working directory is modiﬁed by calling chdir. Once
this is done, line 4 then annotates all the nodes of the include
graph with information on the related script, speciﬁcally
which constants it deﬁnes and whether it sets the include
path or changes the working directory (i.e., is in setsIP).
After this, the loop on lines 5 through 18 continues while
the edge set of the include graph changes. In the ﬁrst step,
on line 6, the include expressions on each edge are simpliﬁed
according to what is currently known about the includes
relation. This is similar to the simpliﬁcation steps described
forFLRES, but also takes advantage of information about
which constant deﬁnitions are actually reachable. The same
constant can be given diﬀerent values in diﬀerent scripts,
which does occur in practice, but it may be the case that
only one deﬁnition of the constant is actually reachable.
This allows additional constant replacements beyond what
is possible in FLRESfor the situations when the constants
are not unique throughout the entire system.
The inner loop, on lines 7 through 17, then iterates over
each edge ewhich does not already have a unique target ﬁle,
with the goal of updating the target node sets to account for
any new information. If the ﬁle name given as an operand to
theinclude expression (assigned to ip)i sal i t e r a ls t r i n g ,
calculateLoc is called to compute the actual include ﬁle
represented by the location.
calculateLoc identiﬁestheﬁletobeincludedbywalking
at r e em o d e lo ft h eﬁ l e si n sys, following the procedure laid
out in Figure 1. This also provides an increase in precision
over FLRES, since, unlike FLRES,PGRESknows the include
path and the directory of the executing script. Before thecall to
calculateLoc ,changesIP is ﬁrst set to true if a
507Input :sys, a PHP system, a mapping from ﬁle locations to abstract syntax trees
Input :toResolve , a location indicating the AST in systo be analyzed
Input :baseLoc, a location indicating the root of system sys
Input :libs, a set of locations of known library includes used by sys
Input :ipath, the include path, a list of locations
Input :ﬂres, ﬁle-level resolve information from FLRES
Output :Arelation res, from the location of each include expression to the location(s) of possibly included ﬁles
1iinfo←include info cache for sys
2igraph←build initial include graph based on FLRESresults
3setsIP←reachable scripts that set the include path or change the working directory
4igraph←annotateNodes (iinfo,setsIP)
5while the set of edges in the include graph changes do
6 igraph←simplifyEdges (igraph,iinfo)
7 fore a non-unique edge do
8 i←the include expression for edge e
9 ip←the operand used in iindicating the ﬁle to include
10 ifip is a literal string then
11 changesIP ←a ﬁle that sets the include path or changes the working directory is reachable
12 e←calculateLoc (toResolve ,baseLoc,ipath,changesIP )
13 end
14 foreach ﬁle freturned by matchIncludes (sys, i,baseLoc,libs) do
15 addiloc×(baseloc+ip)t o res
16 end
17 end
18end
19res←the relation, from include expressions to ﬁles, induced by igraph
Algorithm 2: PHP Program-Level Includes Resolution Analysis (PGRES).
script that sets the include path or changes the working
directory is reachable in the include graph. If changesIP is
true, it will“short circuit”the process shown in Figure 1—
since it then may be the case that any directory is on the
include path, or any directory is the current directory, if no
directory characters are found at the start of the ﬁle name
calculateLoc will fail, leaving the information about the
target ﬁles for this include unchanged.
If, after this, edge ecan still point to multiple nodes, the
same matching process used in FLRESis used here as well.
This is repeated since, as the number of reachable constants
decreases, more constant replacements may become available;
this allows the ﬁle names used in the matching process to
improve, making the match more precise over time.
On line 19, once no more changes occur in the include
graph, the result, res, is computed as the relation, from
include expressions to included ﬁles, induced by igraph.
Soundness: PGRESprovides a sound over-approximation
of the ﬁles that could be included by each include expression
in a program under several common conditions. The ﬁrst
two are identical to those for FLRES, and are discussed in
Section 3. Additionally, PGRESalso assumes that the include
path and the working directory are not changed in obfuscated
ways, e.g., by invoking ini_set using a variable function or
inside eval. If this is done, it could cause the wrong ﬁle to
be found during the lookup process in calculateLoc .W e
believe this would be highly unusual, though, and are not
aware of any real PHP code that actually does this. PGRES
does not attempt to use the values of variables, making
the algorithm less precise in some cases but also protecting
against soundness concerns related to the interaction of PHPvariables with various reﬂective features and library functions
that can be used to indirectly modify their values.
5. EV ALUATION
In this section we present the results of our evaluation of
the two includes resolution algorithms—FLRES andPGRES—
described, respectively, in Sections 3 and 4. First, we describethe systems used in the evaluation. Then, the two algorithmsare evaluated separately. First FLRES, the ﬁle level resolution
algorithm, is evaluated on the entire corpus to measure its
capability of resolving includes to small sets of possible PHP
ﬁles. Then we evaluate the improvement of PGRESover
FLRESby applying it to a subset of the corpus focusing
just on actual PHP programs—scripts that can be executed
directly from a web server or the command line.
5.1 Corpus
As part of our prior work on PHP [6], we assembled a
corpus of 19 large open-source PHP systems, basing ourchoice on popularity rankings provided by Ohloh
6, a site
that tracks open-source projects. We have since extended
this with an additional system—Magento, a popular online
retail system—and updated all systems in the corpus to morerecent versions if available. The chosen systems are shown in
Table 2. Systems were generally selected just based on the
O h l o hr a n k i n g ,a l t h o u g hi ns o m ec a s e sw es k i p p e ds y s t e m s
if we already had several, more popular systems of the same
type in the corpus. We used popularity, instead of actual
number of downloads or installed sites, since we have no way
to accurately compute these ﬁgures. In total, the corpusconsists of 32,682 PHP source ﬁles with 4,593,476 lines of
6http://www.ohloh.net/tags/php
508System Version PHP Release Date File Count SLOC Description
CakePHP 2.4.4 5.2.8 12/24/13 661 148,335 Application Framework
CodeIgniter 2.1.4 5.1.6 7/8/13 147 24,382 Application Framework
Doctrine ORM 2.3.3 5.3.3 5/11/13 609 49,126 Object-Relational Mapping
Drupal 7.24 5.2.5 11/20/13 274 89,266 CMS
Gallery 3.0.9 5.2.3 6/28/13 505 39,087 Photo Management
Joomla 3.2.1 5.3.1 12/18/13 2,117 221,208 CMS
Kohana 3.3.1 5.3.3 9/1/13 468 29,257 Application Framework
Magento 1.8.1.0 5.2.13 12/12/13 8,086 632,924 Online Retail
MediaWiki 1.22.0 5.3.2 12/6/13 1,869 1,037,124 Wiki
Moodle 2.6 5.3.3 11/18/13 6,553 852,075 Online Learning
osCommerce 2.3.3.4 4.0.0 9/26/13 569 46,804 Online Retail
PEAR 1.9.4 4.4.0 7/7/11 74 31,257 Component Framework
phpBB 3.0.12 4.3.3 9/28/13 270 149,361 Bulletin Board
phpMyAdmin 4.1.3 5.3.0 12/31/13 455 138,842 Database Administration
SilverStripe 3.1.2 5.3.2 10/22/13 572 92,216 CMS
Smarty 3.1.16 5.2.0 12/17/13 126 15,904 Template Engine
Squirrel Mail 1.4.22 4.1.0 7/12/11 276 36,082 Webmail
Symfony 2.4.0 5.3.3 12/3/13 4,023 253,536 Application Framework
WordPress 3.8.1 5.2.4 1/23/14 482 132,877 Blog
The Zend Framework 1.12.3 5.2.11 3/13/13 4,546 573,813 Application Framework
The PHP versions listed above in column PHP are the minimum required versions. The File Count includes ﬁles with a .php
or an .inc extension. In total there are 20 systems consisting of 32,682 ﬁles with 4,593,476 total lines of source.
T a b l e2 :T h eP H PC o r p u s .
PHP source (counted using the cloc7tool). The systems in
this corpus were used during development of the includes
resolution analysis, both as a test-bed, to check the results of
the analysis, and as a source of usage patterns that a realistic
analysis would need to handle.
5.2 Evaluating FLRES
FLRESis evaluated here based on the following questions:
(a)“How many includes in real PHP code can be resolved to
a small set of target ﬁles?”, (b)“How small are these sets?”
and (c)“How fast does the analysis usually run?”. Smaller
target ﬁle sets mean the algorithm is more precise, while a
faster run time means it is suitable for use in an IDE.
In terms of recall and precision, we know the algorithm
to have 100% recall since it is sound under assumptionsthat hold within the corpus. Precision could be deﬁned
per resolved include as 1 /numberOfPossibleFiles , under the
assumption that only one speciﬁc ﬁle would be included at
run-time. However, such assumption is not reasonable since
some includes could indeed be designed to resolve to several
ﬁles. We therefore simply report the number of computed
candidates for each include.
5.2.1 Method
To evaluate the eﬀectiveness of the FLRESalgorithm, we
have applied it to all the PHP ﬁles in the corpus shown in
Table 2, using a Rascal script to run the analysis and allow
for reproducibility. We use Rascal to gather the information
seen in Table 3. All include expressions are matched just
by matching any include expression node in the AST, while
7http://cloc.sourceforge.netdynamic includes are deﬁned, for matching purposes, as any
include expression with an operand other than a string literal
(strings built using interpolation appear as so-called encapsed
strings instead of string literals).
Per PHP system in the corpus, we measure how many
include statements there are, how many of those have paths
built dynamically at runtime, which of the includes we can
resolve to a single unique ﬁle, to how many candidates aninclude points after resolution, and how many can not beresolved at all. A strong reduction of provided includes
(especially dynamic includes) to unique ﬁles, or at least a low
amount of left-over candidates, indicates success. Contrary, ifFLRESwould not work, this method would show insigniﬁcant
amounts of resolved includes or high average left-over non-
determinism. Intuitively, we expected the larger part of
includes to be resolved by FLRES, i.e. >80%.
5.2.2 Threats to V alidity
We note the following threats to validity in our evaluation
ofFLRES:
1.We focused mainly on large, well-maintained software
systems. It may be the case that these systems aremore careful and consistent in how they use includesthan other systems. However, we do not believe that
this is an issue: uses of dynamic includes vary widely inthe systems we have looked at, and the corpus contains
software from many diﬀerent application domains.
2.We do not try to account for cases where part of one
system is used in another, which could skew our results.
This happens in Magento , for instance, which uses part
509System Includes Results
Total Static Dynamic Unique Missing Any Other Average
CakePHP 125 4 121 55 3 22 45 4.87
CodeIgniter 69 0 69 25 13 27 4 11.00
DoctrineORM 74 2 72 55 1 18 0 0.00
Drupal 173 1 172 132 5 33 3 3.67
Gallery 47 5 42 29 2 14 2 2.50
Joomla 444 4 440 228 10 162 44 10.84
Kohana 51 4 47 6 1 41 3 2.00
Magento 193 129 64 123 2 48 20 2.60
MediaWiki 514 43 471 480 7 25 2 10.50
Moodle 8,619 3,438 5,181 6,798 114 237 1,470 138.27
osCommerce 705 149 556 90 1 41 573 2.60
PEAR 211 200 11 147 0 11 53 2.00
phpBB 415 0 415 0 0 415 0 0.00
phpMyAdmin 887 731 156 842 3 34 8 46.88
SilverStripe 554 482 72 521 8 23 2 5.00
Smarty 37 2 35 27 0 10 0 0.00
SquirrelMail 427 4 423 412 5 9 1 17.00
Symfony 246 5 241 157 16 64 9 2.33
WordPress 656 3 653 609 10 28 9 5.78
ZendFramework 13,772 13,354 418 13,523 42 67 140 2.19
TOTAL 28,219 18,560 9,659 24,259 243 1,329 2,388 86.46
Table 3: Results of Running FLRES on the Corpus.
of the Zend Framework libraries, and in Gallery ,
which uses part of Kohana. Although this could mean
we are counting the same resolved cases multiple times,
it could also mean we have the same unresolved cases
appearinginmultiplelocations. Wehavenotattempted
to determine which versions of these libraries appear
embedded in other projects, or whether the included
code is the original code or has been modiﬁed.
3.If a system violates the soundness assumptions given inSection 3 FLRESwould return incorrect results. We be-
lieve this is unlikely: it should be possible to determine
which external libraries are used by a system, and we
have not seen the situation we described with deﬁned
c o n s t a n t si na n yo ft h ec o d ew eh a v ee x a m i n e d .
5.2.3 Results for FLRES
Table 3 shows the result of running FLRESon the corpus
shown in Table 2. The ﬁrst column shows the name of
the system. The second, third, and fourth columns provide
information about the includes in this system: Totalgives the
total number of include expressions, Staticgives the number
of these includes where the ﬁle to include is given as a string
literal, and Dynamic gives the number of includes that use
expressions other than a string literal to specify the included
ﬁle. This is a good proxy for which includes could include
multiple ﬁles, but not perfect: Figure 3 illustrated that ﬁle
paths given as string literals may refer to multiple ﬁles.
The ﬁve columns under Resultsthen show the actual results
of the analysis. Uniqueshows the total number of includes
that can be assigned a single possible target ﬁle by FLRES.Missingthen shows the number of includes with no possible
target ﬁle. While in some cases this appears to be an error
in the code, in many the missing includes are surrounded
by a check to see if the ﬁle is present, and appear to be for
included ﬁles which are part of optional extensions to thesystem. Column Anyillustrates the other extreme, cases
where the include could refer to 90 percent or more of the
ﬁles in the system. Otherthen shows includes between these
two extremes—includes that could refer to more than one
ﬁle, but are speciﬁc enough to not refer to at least 90 percent
of the ﬁles. Finally, the Averagecolumn indicates how many
ﬁles, on average, each of these Otherincludes could actually
refer to. For instance, for CakePHP, each of the includes
classiﬁed as Othercould refer to roughly 5 (4.87) ﬁles.
Figure 4 shows an overview of the running times per ﬁle
for all ﬁles in the corpus. The plot shows that although there
exist some outliers above 5 seconds (the largest outlier, at
138 seconds, is not included in this plot), and quite a few
outliers that may take up to half a second, FLRESis able to
analyze most of the ﬁles within 5 to 50 milliseconds, with a
median of just over 5.
5.2.4 Analysis
In many of the systems the number of unique includes
is quite high, while the average number of possible ﬁles for
those includes in the Othercategory are much lower than
the total number of ﬁles in the system, with many systems
having a range from roughly 2 (Kohana, Pear, the Zend
Framework, Symfony) up to around 5. As indicated above,
performance is also good. While we are investigating the
510                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  5 50 500 5000 50000time (ms), log scale
Figure 4: Boxplot Detailing Run-time in ms of
FLRES for All Files in the Corpus.
outliers to further improve performance, most ﬁles can be
a n a l y z e di n5t o5 0m s .
There are several reasons that an include may not evaluate
to a Uniqueinclude, or may even evaluate to Any.F i r s t ,
as was shown in Figure 3, in some cases the ﬁle possibly
included by the given include expression isn’t unique, at least
when the context isn’t known. Second, in some cases the
include relies on a constant which is given diﬀerent values in
diﬀerent ﬁles. The analysis then has to take account of the
inclusion relation between ﬁles to ensure the correct constantis used. The PGRESalgorithm takes account of both of these
limitations in FLRES, allowing it to improve the precision of
the analysis and give fewer possible ﬁles per include. Third,
in some cases a stronger analysis, such as a string analysis,
is needed. This is the case in phpBB, which uses variablesin every include expression. Finally, some of the includes
are speciﬁcally designed to support plugin architectures, anduse very general include expressions to facilitate this. It may
be possible for the user to annotate the expression somehow
to provide additional information, but in general it is not
possible for any static analysis to determine the possible ﬁles
to be included in this scenario.
5.3 Evaluating PGRES
PGRESis evaluated focusing on the following question: (a)
“How much improvement does the algorithm produce in the
size of the sets of candidates over FLRES?”. Again, smaller
candidate sets indicate a more precise algorithm, and can
also improve the precision of other analyses using the results
ofPGRES. The deﬁnitions of recall and precision used here
are the same as for FLRES, given above.
5.3.1 Method
T h em e t h odu s e dt oe v a l u a t ePGRES is similar to that used
forFLRES, except for the choice of ﬁles to analyze. Since
PGRESis targeted at PHP programs, only ﬁles that could
be directly invoked have been chosen. We have limited our
eﬀorts to programs from the following systems: osCommerce,
WordPress, MediaWiki, phpMyAdmin, and CakePHP.
5.3.2 Threats to validity
Our evaluation of PGREShas the same threats to va-
lidity as FLRES, described above, but with the soundness
assumptions for PGRESdescribed in Section 4. Most of thesesoundness assumptions (e.g., setting the include path inside
eval) are very unlikely—in this case, evalis very rarely
used, and we have not seen this scenario in real code.
A threat unique to PGRESis that it may be the case
that what we identify as a program is actually not, but is
instead an include used in other ﬁles. Identifying which ﬁles
can be directly invoked, versus which can be included in
other ﬁles, is not trivial—the most obvious solution, to use
ﬁles that cannot be included by other ﬁles, would assumethe analysis we are implementing. Instead, this requires a
deep knowledge of each individual system, one of the reasons
we have restricted the number of systems evaluated using
PGRES.I nt h ec a s ew h e r ew eh a v ei n a d v e r t e n t l ys e l e c t e da n
include ﬁle, PGRESmay resolve includes incorrectly, either
missing target ﬁles that should be present or giving incorrect
target ﬁles. Since PGRESuses the results from FLRESas a
starting point, PGRESwill never return a set of candidates
larger than FLRES. When applying PGRESas a ﬁrst analysis
step enabling another (e.g., static taint analysis) the program
ﬁles should be identiﬁed in advance.
5.3.3 Results
PGRESwas executed on a total of 408 programs: 137 from
MediaWiki, 91 from WordPress, 90 from phpMyAdmin, 88
from osCommerce, and 2 from CakePHP (which is a frame-
work, but includes a small sample application). PGRESwas
not able to improve upon the results of FLRESfor either
MediaWiki or WordPress, but improvements were seen with
the other three applications. The numbers below are com-
puted by looking at all includes identiﬁed as being reachablebyPGRESfor a speciﬁc program, then, for each include, com-
puting the number of candidates returned by both FLRES
and PGRES.PGRESis more precise in those cases where
more include expressions have smaller candidate sets.
•In the case of phpMyAdmin, summing across all pro-
grams analyzed, PGRESwas able to reduce the total
number of includes categorized as Anyfrom 188 to 89.
PGRESwas also able to reduce the number with a can-
didate set of 4 from 178 to 89, and of 2 from 267 to
178, while increasing the number with a unique match
from 73,425 to 73,692.
•InthecaseofCakePHP,acrossthe2programsanalyzed,PGRESwas able to reduce the total number of includes
with a candidate set of 6 from 20 to 0, of 4 from 2 to
0, and of 2 from 10 to 6, while increasing the number
with a unique match from 108 to 134.
•In the case of osCommerce, summing across all pro-grams analyzed, PGRESwas able to reduce the total
number of includes with a candidate set of 10 from
1232 to 0; of 9 from 704 to 0; of 8 from 176 to 0; of 7
from 88 to 0; of 6 from 1496 to 88; of 5 from 616 to
88; of 4 from 440 to 264; of 3 from 1848 to 88; and of 2
from 42,944 to 8,100. The number of includes with a
unique match went from 7,832 to 48,748.
Themedianexecutiontimeof PGRESoverthe408analyzed
programs was 17.483 seconds and the average was 20 .962
seconds, with some programs analyzed almost immediately
and one taking 52.209 seconds.
5115.3.4 Analysis
The results of the analysis show that PGRESis quite eﬀec-
tive speciﬁcally in those cases where contextual information
about the script is important, especially when the directory
of the including script or the values of reachable (versus
globally uniquely deﬁned) constants determine which ﬁlescan be imported. In situations where this is not the case,
PGRESdoes not improve on the results computed by FLRES.
In both MediaWiki and WordPress, the includes that cannot
be further resolved are generally to support system exten-sions (e.g., the ﬁnal example in Figure 2, which supportsinstallable“skins”that can be selected by the user as partof his/her preferences), with ﬁle names given in terms ofglobal variables, method parameters, method results, and
object ﬁelds, based on data from the site conﬁguration or the
database. In some cases a stronger analysis might be able
to further reduce the target ﬁle sets, but one lesson learned
from this evaluation is that the chance of success may below—other than in the case of phpBB, where an analysis
focused on the values ﬂowing into variables may help, many
of the unresolved cases seem to be truly dynamic. Since
PGRESis slower than FLRES, it is not suitable for interactive
use, e.g., in an IDE. Instead, it would be applied as part of
other program analysis tools which require higher accuracy.
6. RELATED WORK
The inability to resolve includes has been a challenge for
creating realistic PHP analysis tools. For instance, Huang etal’s WebSSARI system [7] does not handle dynamic includes
at all, leading to a need to manually“resolve”the includes
and manually merge the included code. Jovanovic et al.’s
Pixy [9, 8] is able to resolve some dynamic includes, but this
resolution mechanism oﬀers limited support for newer PHP
features and appears to fail in practice [2].
In their work on ﬁnding interference issues between plugins
in PHP applications such as WordPress, Eshkevari et al. [3]
deﬁned a symbolic includes resolution algorithm similar to
ourFLRESalgorithm, withsupportformatchingpathsuﬃxes
and simulating the eﬀect of common operations. While
FLRESsupports additional PHP operations, it appears that
their algorithm could easily be extended to do so.
Nguyen et al. [12], in their work on PhpSync, used sym-
bolic execution to identify the program points in PHP scripts
responsible for generating speciﬁc HTML fragments. They
representedstringvaluesusinga D-model, ahierarchical, sym-
bolic representation of the possible string values generated
by PHP scripts and language constructs. To symbolicallyexecute
include expressions, they used the value of the
D-model representing the ﬁlename to determine which ﬁle
should actually be executed. While this supports expressions
built using string operations, the results of library functions,
o f t e nu s e di n include expressions, are left unresolved as
symbolic strings.
Wassermann et al. [15, 16], extending earlier work by Mi-
namide [11], model string values and string operations inPHP programs using context-free grammars and languagetransducers, respectively. Although their analysis was fo-
cused on preventing injection attacks and cross-site scripting
vulnerabilities, they also used their string analysis to resolve
dynamic includes, including using a path matching technique
which seems similar to ours. Since this is done as part of a
more complex analysis, the overall execution time is muchhigher: the runtime for the two largest systems in their eval-
uation (132,850 lines of code in one case, 169,232 in another)
is more than 3 hours.
Biggar [1], in his work on the phccompiler, looked at a
large corpus of 581 PHP code packages downloaded fromSourceForge, totaling 42, 523 ﬁles with 8, 130,837 lines of
code (including blank lines and comments). He found fewer
dynamic includes in his dataset than we have in ours—only
15% of the includes in his corpus are dynamic. This may be
just a diﬀerence of classiﬁcation—we consider any include
to be dynamic that has a non-literal operand, while Biggar
also considers include expressions built using string literals,
concatenation, and constants to be static (we do not forthe reason mentioned above—constant deﬁnitions are not
globally unique through the entire system). Zhao et al. [17],
in their work on the Facebook HipHop compiler, instead
impose a requirement that all includes are statically known
at compile time, eliminating many of the legitimate uses
we have found for this technique (for instance, to support
installable plugins). The algorithm presented here would
loosen this requirement to allow includes that are static in
practice, while still allowing the ﬂexibility of building the ﬁlename to be included using common string-building operations
and reachable constant deﬁnitions.
Looking at other dynamic scripting languages with similar
features, Richards et al. [14] used trace analysis to examine
how the dynamic features of JavaScript are used in prac-
tice, speciﬁcally investigating whether the scenarios assumed
by static analysis tools (e.g., limited use of eval, limited
deletion of ﬁelds, use of functions that matches the provided
function signatures) are accurate. In a more focused study
over a larger corpus, Richards et al. [13] analyzed runtimetraces to ﬁnd uses of
eval, categorizing these uses into a
number of patterns. This is also the case with the work of
Furr et al. [4], who used proﬁling of dynamic Ruby features
to determine how these features are used in practice and to
replace uses of these features with uses of equivalent static
features.
7. CONCLUSIONS
PHP’s include expressions are an example of a dynamic
feature that has traditionally made static analysis of PHP
challenging. Inthisworkwepresentedtwoalgorithms, FLRES
andPGRES, for resolving include expressions at the level of
individual ﬁles and PHP programs, respectively. Evaluating
FLRESover a corpus of more than 4.5 million lines of PHP
code and more than 32,000 ﬁles, we showed that FLRESis
eﬀective at producing small sets of candidate ﬁles for many
include expressions, and generally runs fast enough to be
used in PHP IDEs.
PGRES, evaluated over more than 400 PHP programs—
scripts designed to be executed directly—shows signiﬁcant
improvements on the results of FLRESin some cases, with
little to no improvement in others. PGREScan be applied
when accuracy is more important than eﬃciency, for example
when analyzing the security of PHP programs.
In future work we plan to make use of both algorithms
in our ongoing work on the PHP AiR framework for PHP
program analysis. Finally, we plan to continue ongoing work
on integrating PHP analysis with the Eclipse IDE, with the
goal of providing IDE-based support for developers to assist
in developing, understanding, and refactoring large PHP
code bases.
5128. REFERENCES
[1] P. Biggar. Design and Implementation of an
Ahead-of-Time Compiler for PHP. PhD thesis, Trinity
College Dublin, April 2010.
[2] N. L. de Poel. Automated Security Review of PHP
Web Applications with Static Code Analysis. Master’s
thesis, University of Groningen, 2010.
[3] L. M. Eshkevari, G. Antoniol, J. R. Cordy, and M. D.
Penta. Identifying and Locating Interference Issues in
PHP Applications: The Case of WordPress. In
Proceedings of ICPC 2014 , pages 157–167. ACM, 2014.
[4] M. Furr, J. hoon (David) An, and J. S. Foster.
Proﬁle-Guided Static Typing for Dynamic ScriptingLanguages. In Proceedings of OOPSLA 2009 , pages
283–300. ACM, 2009.
[5] M. Hills and P. Klint. PHP AiR: Analyzing PHP
Systems with Rascal. In Proceedings of CSMR-WCRE
2014, pages 454–457. IEEE, 2014.
[6]
M. Hills, P. Klint, and J. J. Vinju. An Empirical Study
of PHP Feature Usage: A Static Analysis Perspective.InProceedings of ISSTA 2013 , pages 325–335. ACM,
2013.
[7] Y.-W. Huang, F. Yu, C. Hang, C.-H. Tsai, D.-T. Lee,
and S.-Y. Kuo. Securing Web Application Code by
Static Analysis and Runtime Protection. In Proceedings
of WWW 2004, pages 40–52. ACM, 2004.
[8] N. Jovanovic, C. Kruegel, and E. Kirda. Precise Alias
Analysis for Static Detection of Web ApplicationVulnerabilities. In Proceedings of PLAS 2006 ,p a g e s
27–36. ACM, 2006.
[9] N. Jovanovic, C. Kr ¨ugel, and E. Kirda. Pixy: A Static
Analysis Tool for Detecting Web ApplicationVulnerabilities (Short Paper). In IEEE Symposium on
Security and Privacy, pages 258–263. IEEE, 2006.[10] P. Klint, T. van der Storm, and J. J. Vinju. RASCAL:
A Domain Speciﬁc Language for Source Code Analysis
and Manipulation. In Proceedings of SCAM 2009 , pages
168–177. IEEE, 2009.
[11] Y. Minamide. Static Approximation of Dynamically
Generated Web Pages. In Proceedings of WWW 2005 ,
pages 432–441. ACM, 2005.
[12]H .V .N g u y e n ,H .A .N g u y e n ,T .T .N g u y e n ,a n dT .N .
Nguyen. Auto-Locating and Fix-Propagating forHTML Validation Errors to PHP Server-side Code. In
Proceedings of ASE 2011 , pages 13–22. IEEE, 2011.
[13] G. Richards, C. Hammer, B. Burg, and J. Vitek. The
Eval That Men Do - A Large-Scale Study of the Use of
Eval in JavaScript Applications. In Proceedings of
ECOOP 2011, volume 6813 of LNCS, pages 52–78.
Springer, 2011.
[14] G. Richards, S. Lebresne, B. Burg, and J. Vitek. An
Analysis of the Dynamic Behavior of JavaScript
Programs. In Proceedings of PLDI 2010 , pages 1–12.
ACM, 2010.
[15]G. Wassermann and Z. Su. Sound and Precise Analysis
of Web Applications for Injection Vulnerabilities. In
Proceedings of PLDI 2007 , pages 32–41. ACM, 2007.
[16] G. Wassermann and Z. Su. Static Detection of
Cross-Site Scripting Vulnerabilities. In Proceedings of
ICSE 2008 , pages 171–180. ACM, 2008.
[17] H. Zhao, I. Proctor, M. Yang, X. Qi, M. Williams,
Q. Gao, G. Ottoni, A. Paroski, S. MacVicar, J. Evans,
a n dS .T u .T h eH i p H o pC o m p i l e rf o rP H P .I n
Proceedings of OOPSLA 2012 , pages 575–586. ACM,
2012
.
513