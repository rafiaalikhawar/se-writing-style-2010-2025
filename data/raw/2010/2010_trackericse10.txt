Effective Interprocedural Resource Leak Detection
Emina Torlak Satish Chandra
IBM T.J. Watson Research Center, USA
{etorlak,satishchandra}@us.ibm.com
ABSTRACT
Garbage collection relieves programmers from the burden of
explicit memory management. However, explicit manage-
ment is still required for nite system resources , such as I/O
streams, fonts, and database connections. Failure to release
unneeded system resources results in resource leaks , which
can lead to performance degradation and system crashes.
In this paper, we present a new tool, Tracker , that per-
forms static analysis to nd resource leaks in Java programs.
Tracker is an industrial-strength tool that is usable in an
interactive setting: it works on millions of lines of code in
a matter of minutes and it has a low false positive rate.
We describe the design, implementation and evaluation of
Tracker , focusing on the features that make the tool scal-
able and its output actionable by the user.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veri-
cation; D.2.5 [ Software Engineering ]: Testing and De-
bugging
General Terms
Algorithms, Reliability, Verication
Keywords
resource leaks, alias analysis, inter-procedural analysis
1. INTRODUCTION
While garbage collection frees the programmer from the
responsibility of memory management, it does not help with
the management of nite system resources , such as sockets
or database connections. When a program written in a Java-
like language acquires an instance of a nite system resource,
it must release that instance by explicitly calling a dispose
or close method. Letting the last handle to an unreleased
resource go out of scope leaks the resource: the runtime sys-
tem gradually depletes the nite supply of system resources,
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô10, May 2-8 2010, Cape Town, South Africa
Copyright 2010 ACM 978-1-60558-719-6/10/05 ...$10.00.1public void test(File le, String enc) throws IOExceptionf
2 PrintWriter out = null;
3 tryf
4 tryf
5 out = new PrintWriter(
6 new OutputStreamWriter(
7 new FileOutputStream(le), enc));
8gcatch (UnsupportedEncodingException ue) f
9 out = new PrintWriter( new FileWriter(le));
10g
11 out.append('c');
12gcatch (IOException e)f
13gnallyf
14 if(out != null)f
15 out.close();
16g
17g
18g
Figure 1: Code example adapted from ant.
leading to performance degradation and system crashes. En-
suring that resources are always released, however, is tricky
and error-prone.
As an example, consider the Java program in Fig. 1. The
allocation of a FileOutputStream on line 7 acquires a stream,
which is a system resource that needs to be released by call-
ingclose() on the stream handle. The acquired stream ob-
ject then passes into the constructor of OutputStreamWriter ,
which remembers it in a private eld. The OutputStream -
Writer object, in turn, passes into the constructor of Print -
Writer . In the nally block, the programmer calls close()
on the PrintWriter object. This close() method calls close()
on the \nested" OutputStreamWriter object, which in turn
calls close() on the nested FileOutputStream object. By using
nally , it would appear that the program closes the stream,
even in the event of an exception.
However, a potential resource leak lurks in this code. The
constructor of OutputStreamWriter might throw an excep-
tion: notice that the programmer anticipates the possibil-
ity that an UnsupportedEncodingException may occur. If it
does, the assignment to the variable outon line 5 will not
execute, and consequently the stream allocated on line 7 is
never closed.
Resource management bugs are common in Java code for a
number of reasons. First, a programmer might omit a call to
close() due to confusion over the role of the garbage collector.
Second, even a careful programmer can easily fail to release
all resources along all possible exceptional paths, as illus-
trated in Fig. 1. Finally, a programmer needs to understandall relevant API contracts. In the example above, the pro-
grammer correctly reasoned that closing the PrintWriter in-
stance closes the nested resources through cascading close()
calls. But cascading close is not universal across all APIs,
and a programmer could easily make incorrect assumptions.
Contributions. In this paper we describe the design, im-
plementation and evaluation of a static analysis tool, called
Tracker , for resource leak detection in Java programs. Our
contribution is in overcoming the engineering challenges to
building a useful, scalable leak detection tool. By useful ,
we mean that the reports produced by the tool must be ac-
tionable by a user, as opposed to merely comprehensive. By
scalable , we mean that the tool must be able to handle real-
world Java applications consisting of tens of thousands of
classes.
Some of the challenges that we address are common to all
static analysis tools and include the following:
Scalable inter-procedural analysis. Inter-procedural
reasoning about aliases is crucial to building a useful re-
source leak detection tool. Given the program in Fig. 1,
for example, the tool needs to reason that the instance of
FileOutputStream released in OutputStreamWriter 'sclose()
method is in fact the same instance that was attached to the
OutputStreamWriter object when the latter was constructed.
The need for such reasoning can make it dicult to han-
dle applications with tens of thousands of classes, as pro-
grams of this size are not amenable to precise whole-program
alias analysis. Tracker side-steps the general alias analysis
problem by tracking pertinent aliasing information using ac-
cess paths [19] in the context of an ecient inter-procedural
data-ow analysis [21]. We observe, empirically, that sur-
prisingly sparse tracked aliasing information can accord high
precision.
False positives. False positives are inevitable in any tool
that guarantees soundness. However, if a bug-nding tool
produces too many false positives, the average user will sim-
ply ignore its results. Building a bug-nding tool as opposed
to a verication tool (whose goal is to determine whether or
not the code is free from a certain class of errors) opens
up the possibility|and creates an expectation|of prioritiz-
ing reports that are likelier than others to be true positives.
Tracker oers such prioritization by keeping a record of
whether a bug was witnessed along some path, or whether
it was assumed due to the limitations of the analysis. We
show, empirically, that bugs arising from analysis limitations
are much more likely to be false positives.
We also tackle issues that are specic to the problem of
resource management:
Nested resources. It is not enough to track just sys-
tem resources, because the corrective action that a user
needs to take may be to call a close method on an object
that nests a resource instance. Suppose that in the above
example, the constructor of OutputStreamWriter could not
throw an exception, but instead, the programmer forgot to
call out.close() . Even though the leaked system resource
would still be the FileOutputStream , a user may justiably
expect a tool to report that the PrintWriter referenced by
outshould be closed rather than the nameless instance of
FileOutputStream .Tracker oers reports that make proper
remedial action more apparent.
Exceptional ows. As shown in the example in Fig. 1,
as well as by others previously [24], programmers often makemistakes in using try-catch -nally blocks. A resource leakage
tool therefore needs to pay special attention to bugs lurk-
ing there. Reporting leaks due to all possible runtime errors
would overwhelm the user with uninteresting results, but we
must deal with those exceptions that the programmer ex-
pects to occur. For instance, a programmer would typically
ignore a leak report based on an OutOfMemoryError , because
most programs are not expected to deal with such abnormal
conditions. Instead, we present a belief-based [14] heuristic
that suppresses reports due to exceptional ow unless the
analysis nds plausible evidence to justify the report.
Summary of Results. We evaluated tracker on a suite of
5 large open-source applications, ranging in size from 6,900
to 69,000 classes. All benchmarks were analyzed in a mat-
ter of minutes, with our tool identifying resource leaks at
an actionable (true positive) rate of 84 to 100 percent. The
engineering techniques that we describe here are crucial for
actionability of the output produced by tracker : our ex-
ception ltering mechanism, for example, reduces the false
positive rate by roughly 2 :5. In comparison to findbugs ,
tracker found 5 times more true positives. Our tool has
been used internally by IBM developers, who applied it on
real code and xed most of the leaks it reported. A version
oftracker ships in Rational Software Analyzer version 7.1
as a part of its Java static analysis suite.
Outline. The remainder of this paper is organized as fol-
lows. Section 2 presents the core resource tracking algorithm
oftracker . Section 3 presents enhancements germane to
producing useful reports for such a tool. Section 4 presents
selected implementation details, especially how we construct
the call graph. Section 5 presents a detailed empirical eval-
uation. Section 6 reviews related work, and Section 7 con-
cludes the paper.
2. CORE ALGORITHM FOR RESOURCE
TRACKING
In this section, we rst give a quick overview of how the
basic analysis works as applied to Fig. 1. Subsequently, we
give formal details of the core intra-procedural and inter-
procedural resource tracking algorithms.
2.1 Overview
The analysis takes as input a control-ow graph (CFG)
and a specication of procedures that acquire and release
system resources. Figure 2 shows the relevant parts of the
CFG for Fig. 1, along with the CFGs of some of the called
methods. We introduced temporary variables t1and t2
when constructing the CFG (a). The example's specication
declares that the constructor for FileOutputStream allocates
a resource, and the corresponding close() releases it.
The goal of the analysis is to establish that the alloca-
tion of a resource on line 7 is followed by its release on all
possible execution paths to exit; when this property does
not hold, there is a potential leak. Tracker symbolically
tracks each resource through paths in the CFG until either
a) it is released, or b) it becomes unreachable without being
released, and thus leaks. Consider the program path 7-6-
5-11-14-15, starting with the resource allocation on line 7.
The next two lines require inter-procedural tracking due to
constructor calls. The constructor on line 6 stores its argu-(a) CFG of testout = nullt1 = new FileOutputStream(file)t2 = new OutputStreamWriter(t1, enc)out = new PrintWriter(t2)catch UnsupportedEncodingExceptionout = ...out.append()out != nullout.close()exitentry2
...765
11
141598OOMOOMOOMUEE
IOE(c) CFG of PrintWriter.<init>(w)this.b = wexitentry(b) CFG of OutputStreamWriter.<init>(os)this.a = osexitentry
(e) CFG of OutputStreamWriter.close()this.a.close()exitentry(d) CFG of PrintWriter.close()this.b.close()exitentryFigure 2: Control-ow graph of the procedure shown in Fig. 1. Numbers to the left are line numbers. Dashed
edges represent exceptional ow labeled by the type of exception they carry, e.g.,OOM =OutOfMemoryError .
Dotted edges represent inter-procedural control transfers.
ment into an instance eld a. Our analysis concludes that
after line 6, both expressions t2.aand t1point to the tracked
resource. The constructor on line 5 stores its argument into
an instance eld b. Our analysis, likewise, concludes that
after line 5, the expression out.b.a also refers to the tracked
resource.
The call out.close() on line 15 transitively calls close() on
expressions out.b and out.b.a (notice that thisin CFGs (d)
and (e) would be bound appropriately), the last one releas-
ing the tracked resource as it is equal to t1. At this point, the
resource referred to by the expressions t1,t2.a, and out.b.a
is released, and is therefore no longer tracked.
To be eective, the algorithm needs to be able to prove
that this.ain CFG (e) is equal to t1assigned in CFG (a).
This requires precise inter-procedural must-alias reasoning.
Tracker performs ecient must-alias reasoning using selec-
tive equality predicates, without relying on whole-program
alias analysis as was done in prior work ( e.g., [9]) on types-
tate analysis and resource leakage analysis.1
1In modern OO languages, construction of a call graph itself is
a whole-program analysis; we describe our computation of call
graph briey in Sec. 4.Consider now the exceptional path 7-6-8-9-11-14-15-exit.
On line 15, the expression outrefers to the object allocated
on line 9, and it is not equal tot1, the resource allocated on
line 7. At the exit of the procedure, the expression t1still
points to the unreleased resource from line 7, and no other
expressions may point to that resource. Since t1goes out of
scope at the procedure exit, we conclude that the resource
allocated on line 7 is unreachable, unreleased, and leaks.
What about the path 7-6-5-11-14-exit, where the branch
on line 14 is not taken? If the analysis can prove that the
false outcome is not possible, the path is infeasible; other-
wise, the analysis must report a leak. Tracker avoids this
false positive. What about the path 7-6-14-exit, in which
anOutOfMemoryError occurs on line 6? The resource can
leak along that path. However, at the user's discretion,
Tracker can suppress problems along exceptional ows as-
sociated with fatal exceptions.
2.2 Intra-procedural analysis
We describe our analysis on a control-ow graph contain-
ing the following kinds of abstract statements: entry ,exit,
p = acquire R ,release R q ,branch c L ,p = new T,p = q.f ,IntraproceduralResourceAnalysis (CFG;Specication )
1 type Fact:SSAVariableResourceTypeState
2 var D:Statement!2Fact
3fors2Statement do
4 D(s) ;
5fors2Statement do
6 ifsisp = acquire R
7 a= initialState( p)
88t2succ(s):D(t) D(t)[fhp; R; aig
9while changes in Ddo
10 s pick from Statement
11hp; R; ai pick from D(s)
12 case sisrelease R q
13 if:isMustAlias( p,q,a)
148t2succ(s) :D(t) D(t)[fhp; R; aig
15 case sisbranch c L
16 ifisConsistent( c,a)
17 u=trueSucc (s) :D(u) D(u)[fhp; R; aig
18 ifisConsistent(:c,a)
19 u=falseSucc (s) :D(u) D(u)[fhp; R; aig
20 case sisexit
21 ifisUnreachable( a,p)
22 report pas leaking
23 other
24 a0 : : :
258t2succ(s) :D(t) D(t)[fhp; R; a0ig
Figure 3: Intra-procedural leak algorithm.
p.f = q ,p = q , and invoke . For clarity, we assume that we
have rewritten method calls that allocate and release re-
sources abstractly as acquire and release statements. For
example, p = new FileOutputStream(le) is represented as:
p = acquire FileOutputStream
invoke p. <init>(le)
The statement p.close() is represented as:
release FileOutputStream p
invoke p.close()
We assume that each local variable has a single static assign-
ment (SSA) [8]. The abstract statement p = q is included to
describe the treatment of -nodes introduced in SSA conver-
sion, as well as to model transmission of values from actuals
to formals in a procedure call. The branch statement has a
conditional expression cand a jump target L.
Generic Data-Ô¨Çow Analysis. Figure 3 shows a generic re-
source tracking analysis. The algorithm performs iterative
data-ow over a powerset lattice of facts of the kind Fact,
as dened on line 1. A Fact is a 3-tuple that consists of
anSSAVariable , which is an SSA value number; a Resource-
Type, which is the kind of the tracked resource; and a State ,
which represents a nite amount of auxiliary information
used to resolve queries the algorithm will make. A concrete
description of State will be given shortly, but for now as-
sume that it contains predicates over local variables. The
algorithm makes use of the following auxiliary functions:
1. initialState( p:SSAVariable ) creates an element of State
based on the given SSA variable.
2. isMustAlias( p:SSAVariable ; q:SSAVariable ; a:
State ) evaluates to true if, given the information in a,p
equalsq. If this check fails, the analysis cannot assume
that the variable on which release is called strongly [5]closes a resource referred by p. A conservative answer
to this query is false.
3. isConsistent( condition :Expression;a:State ) is true
ifcondition , which is a conditional expression ( Expres-
sion), does not contradict the information in a. This
function is used to prune infeasible paths. A conserva-
tive answer to this query is true.
4. isUnreachable( a:State;p:SSAVariable ) returns true
if the resource referenced by pmay no longer be ac-
cessible by any live name, as per information in a. At
the exit of a procedure, local variables are assumed
to become dead, unless otherwise preserved in a. A
conservative answer to this query is true.
Lines 5-8 seed the analysis with initial facts that correspond
to resource allocation. The algorithm then propagates these
facts through program statements, creating new facts along
the way. Lines 24-25 show the eects of pointer statements,
such as p.f = q , on State ; we describe these eects shortly.
The algorithm converges because no fact is deleted from the
mapD, and because each component of Fact is nite.
DeÔ¨Åning State. Tracker implements State as a set of
must-access-paths to a tracked resource [13, 15]. A must-
access-path is an expression comprised of a variable followed
by a (possibly empty) sequence of eld names, such that the
value of the expression refers to the resource. For example,
out.b.a is a must-access-path. Figure 4 shows how a set of
must-access-paths, named inis transformed by individual
program statements. As is customary in ow analysis, gen
refers to the new must-access-paths added to the set, and
killrefers to the must-access-paths removed from the set.
(We remind the reader that State , here represented by set of
must-access-paths, is only one component of the data ow
domain Fact.) In the table of transformations, alias( ,p)
checks ifpmay be an alias of expression , based on an
inexpensive type match.
Because State is nite, each time the transformation of
must-access-paths set is computed, we must limit the size of
the resulting set using a function lter. It is necessary to do
so for two reasons: (a) in the presence of loops (or recursion),
it is possible for access paths to grow indenitely, and (b)
even loop free code might inate the sets to needlessly large
sizes, compromising eciency. The function lter(a : State )
empties the set if either any access path in it is longer than
a preset limit (\depth"), or the number of access paths in it
has exceeded a preset limit (\breadth"). We did not nd it
useful to trim the set to size instead of emptying it.
Given this implementation of State , the auxiliary func-
tions mentioned above are dened as follows. initialState( p)
produces a singleton set fpg. isMustAlias( p;q;a ) checks ifq
is in the must-access-path set a. isConsistent( condition;a)
can be resolved for (only) certain kinds of queries. If acon-
tainsv:, whereis a possibly empty list of elds, then
we know that vcannot be null. Therefore, a condition is of
the formv=null orv6=null can be decided exactly. If a
contains both vandw, then we can infer v=w. Finally,
isUnreachable( a;p) is true ifais empty.
Example 1. Consider the code fragment shown below. We
show the facts accumulated by our analysis after each state-
ment to the right.statement out= lter(( in kill)[gen)
p = q.f gen=fp:jq:f:2ing
kill= startsWith( p;in)
p.f = q gen=fp:f:jq:2ing
kill= startsWith( p:f;in)
[aliasMatches( p;f; in)
p = new T kill= startsWith( p;in)
p = acquire R kill= startsWith( p;in)
p = q gen=fp:jq:2ing
kill= startsWith( p:f;in)
startsWith( p;in)fp:jp:2ing
aliasMatches( p;f; in)f:fj:f2in^alias(;p)g
Figure 4: Flow functions for access path sets. is a
possible empty sequence of eld names.
p = acquire R hp;R;fpgi
q.f = p hp;R;fp;q:fgi
r = q.f hp;R;fr;p;q:fgi
branch (r == null) L1 T:none , F:hp;R;fr;p;q:fgi
release r none
L1: none
At the branch statement, isConsistent check tells us that
only the fall-through successor is feasible: r, being a must-
alias to a resource, cannot be a null pointer. At the release
statement, the call to isMustAlias( p,r,fr;p;q:fg) succeeds.
Consequently, no fact makes it to L1.
Had we used an imprecise and conservative isConsistent,
we would have obtained the fact hp;R;fr;p;q:fgiafter L1.
Local variables would then be dropped from the state, giving
the facthp;R;fgiat the exit. This fact would satisfy the
query isUnreachable( fg,p), resulting in a false positive.
If we had ltered the State on line 3 for a breadth limit
of 2, we would have conservatively decided that the release
onrmay not release the resource acquired on line 1: that
is, isMustAlias( r,p,fg) would be false. Again, this would
have resulted in a false positive.
Example 2. Consider the leaky code fragment shown be-
low. It allocates a resource in a loop, but frees only the
last allocated instance. The branch after L1 has a non-
determnistic condition for which the analysis must answer
isConsistent true for both outcomes.
p1=null
L1 hp3;R;fp3gi,hp3;R;fp2gi
p2=(p1,p3)hp3;R;fp2;p3gi,hp3;R;fgi
branchL2
p3= acquire Rhp3;R;fp3gi,hp3;R;fp2gi
branch true L1
L2 hp3;R;fp2;p3gi,hp3;R;fgi
release p 2 hp3;R;fgi
This fragment also illustrates the treatment of nodes.
Consider the path taken through the loop two times and
then exiting to L2. The initialization generates hp3;R;fp3gi
after the acquire . The generated fact ows to L1, where
thegenerateshp3;R;fp2;p3gi, using the eect of p2=p3.
This, in turn, ows out to L2, where it is removed by release .
Next time in the loop body, the acquire statement kills the
occurrence of p3infp2;p3g, generating the fact hp3;R;fp2gi.
Going around the back edge again, this last fact is trans-formed by the statement tohp3;R;fgi. When the trans-
formed fact ows out to L2, it cannot be removed by release .
The test isUnreachable( fg,p3) passes, and we report a leak.
Alternative deÔ¨Ånitions of state. It is worth reiterating the
role of State : it keeps track of interesting information re-
lated to a specic resource allocation. We have presented
a specic embodiment of State . One may decide to imple-
ment the analysis described here using a richer State at ad-
ditional run-time cost: for example, it could track even more
predicates to enable more precision in call resolution or in
branching. We have not found a compelling need to enrich
State . Going in the other direction, since there are conser-
vative ways of answering the queries we make on State , it
is also possible to have a trivial embodiment of it, at the
expense of precision. A third alternative is to decouple the
State from a specic Fact, and answer the auxiliary predi-
cates based on globally computed information. For exam-
ple, one might compute a precise ow- and context-sensitive
points-to analysis [25] to answer the queries. We decided
against this approach since it has proven dicult to scale
such analyses to the sizes of applications we wish to handle.
2.3 Inter-procedural analysis
The algorithm presented in Figure 3 generalizes easily to
the inter-procedural case. As is fairly standard, we assume
there is an inter-procedural calledge from a call statement
to each of the possible callees (a static call graph can in-
dicate multiple possible callees), and there is a return edge
from the exit of a callee to each of the call statements that
could have invoked it. For an example, see Fig. 2 where we
show call and return edges using dotted lines. A call edge
is accompanied by the assignment of formal parameters to
values of the corresponding actuals, and likewise, a return
edge is accompanied by the assignment of the return value
(if any) to the left-hand-side (if any) of the call statement.
We implement inter-procedural analysis over this structure
using the IFDS framework [21].
Relevant Callees. Our algorithm implements the following
performance optimization when it encounters a call state-
ment. For a facthp;R; aithat reaches the call instruction, it
determines whether the callee method is relevant . A method
is relevant to a fact if it (or any of its transitive callees)
contains a statement that may alter the fact's State . The
algorithm uses an inexpensive and conservative side-eect
computation to determine relevance. If a callee is relevant
to a fact, the fact is propagated into the callee. Here, formal
parameters of the callee are assigned corresponding values
from the actuals using the transformation for a copy state-
ment ( p=q). If the callee is not relevant, the fact is propa-
gated only to the successors of the call statement, bypassing
the call. This optimization is fruitful, because in practice
a lot of methods are auxiliary in nature, and it is waste-
ful to drag facts along the CFGs of those methods. Any
exceptions that can be thrown inside the bypassed callees,
and that are not caught locally, are reected in our IR as
exceptional ow edges emanating from the call instruction
in the caller's CFG. Thus soundness is not sacriced when
bypassing callees.
Namespace Management. Because SSA variables, as used
in Sec. 2.2, are only unique within a single procedure, weneed to protect caller value numbers from getting mixed up
with callee value numbers. Details of this are routine and
are omitted.
2.4 Soundness
Given a sound call graph, Tracker is sound in that it
does not miss true positives. We note, however, that com-
puting a sound call graph for partial programs, or in the
presence of reection, is non-trivial. We describe our best-
eort call graph construction briey in Sec. 4.
We also note that we are analyzing open programs: e.g.,
a library without client code. In such programs, a resource
occasionally escapes to the unknown caller either as a re-
turn value, or as a eld of some longer lived object. We
do not call such situations leaks, assuming optimisitically
that the (missing) client would release the escaped resources.
We could easily implement a pessimistic version of the algo-
rithm, but we nd the optimisitic assumption more useful.
Our claim to soundness is modulo this assumption.
3. COMPUTING ACTIONABLE REPORTS
This work focuses on producing error reports that are
actionable, rather than merely comprehensive. We discuss
three ways in which we enhance actionability. First, we pri-
oritize reports based on the structure of access paths sets,
so that likely true positives are ranked higher. Second, we
cluster reports that arise from leakage of the same under-
lying resource. Third, we suppress reports that arise from
exception ows that are deemed unlikely or uninteresting to
the programmer.
3.1 Prioritization
As discussed in Sec. 2.2, our analysis works by tracking
sets of must-access paths to unreleased resources and report-
ing a leak if a tracked set becomes empty. An access path
set may become empty in one of two ways: (1) every handle
in the set is rooted at a local variable that is going out of
scope, or (2) the size of the set, or the length of one the
handles, is about to exceed a preset limit. In the rst case,
the generated leak report is based on a leakage witness|
a path through the program's supergraph along which the
given resource is not released. These are called witnessed
reports . In the second case, the analysis is unable to nd a
witness with the given limits on fact size, so the resulting
leak report is called an assumed report .
Witnessed and assumed reports obtained by progressively
relaxing the limits on the size of tracked facts have two key
properties, which our implementation exploits to generate
low cost, high quality results. First, for a given limit don the
length of tracked paths and a limit bon the size of tracked
sets, witnessed reports Whd;biare signicantly more likely to
be true positives than the assumed reports Ahd;bi(Sec. 5.1).
We therefore prioritize tracker 's output so that the reports
inWhd;biare ranked higher than those in Ahd;bi. Second, for
a pair of limitshd;biandhd0;b0i, wheredd0andbb0,
Whd;biW hd0;b0iandAhd;bi[Whd;biAhd0;b0i[Whd0;b0i.
That is, the analysis generates more witnessed reports and
rules out more false positives when tracking richer facts,
which is a straightforward consequence of our denition of
a leak. An empirical corollary to this is that the quality
of the reports plateaus quickly, so that Whd;bicaptures the
majority of true positives for a small dandb. As a result, the
default conguration for our tool is d= 3 andb= 5, which1public Integer getFirst(File in) throws IOExceptionf
2 FileInputStream s = new FileInputStream(in);
3 Integer ret = null;
4 tryf
5 intval = s.read();
6 ret = new Integer(val);
7gcatch (IOException e)fg
8 s.close();
9 return ret;
10g
Figure 5: Ignoring fatal exceptions
yields nearly as high a proportion of witnessed (and, hence,
highly ranked) true positives as would a slower conguration
that uses larger limits.
3.2 Exception Flow
Many resource leaks found in real programs occur along
exceptional paths. The program in Fig. 1, for example, may
leak the le output stream if the constructor of the stream
writer throws an UnsupportedEncodingException . But not all
exceptional paths are interesting or likely to be exercised,
and a leakage analysis that processes all exceptional edges
would generate a large number of reports with little practical
value (Sec. 5.2).
To illustrate, consider the program in Fig. 5. The pro-
gram is, for all practical purposes, free of leaks. It closes
the allocated le input stream along all normal paths, and
any IOException that may be thrown by the call to read()
is caught and ignored. Nonetheless, an analysis that pro-
cesses allexceptional edges would generate a leak report for
this program because s.close() would not be executed if the
allocation of the Integer object on line 6 failed due to an
OutOfMemoryError . Such a report is not very useful, how-
ever. Most programs are not expected to recover from an
OutOfMemoryError , and once the program fails, all system
resources are automatically released.
Our analysis processes exceptional edges selectively. In
particular, we only process the edges associated with rele-
vant exception types. The denition of what is relevant is
customizable, but is guided by a belief-based heuristic [14]
that considers an exception irrelevant unless there is evi-
dence to the contrary. In our implementation, relevant ex-
ception types for a method minclude all types Esuch that:
(1)mexplicitly throws an instance of Evia a throw state-
ment; (2)mexplicitly catches an instance of Ein a catch
block; or (3) Eappears in the throws clause ofm's signa-
ture. The set of relevant exception types for a program is
simply the union of the relevant exception types for each of
the methods in its call graph.
3.3 Nested Resources
It is commonplace in Java to have classes that encapsu-
late or wrap a resource in one of their elds. In PrintWriter
and OutputStreamWriter , both of which we used in Fig. 1,
the contract says that the output stream passed as an argu-
ment to the constructor is closed when close() is called on
the encapsulating instance. The following code snippet is
therefore free of leaks even though fos.close() is not called
directly:FileOutputStream fos = new FileOutputStream(le);
OutputStreamWriter osw = new OutputStreamWriter(fos);
...
osw.close();
Unlike leaks of system resources, wrapper leaks are often
benign. If a wrapper is encapsulating a memory resource,
such as as a ByteArrayOutputStream , then a failure to close
the wrapper is uninteresting, as it will be handled by the
garbage collector. The same is true if a wrapper encapsu-
lates a system resource that is released independently, as
shown below:
FileOutputStream fos = new FileOutputStream(le);
OutputStreamWriter osw = new OutputStreamWriter(fos, enc);
...
fos.close();
But not all wrapper leaks are uninteresting. If a wrapped
system resource is leaking, and the handle to the resource is
inaccessible (as in Fig. 1), then only way to actually x the
underlying leak is by releasing the wrapper. We therefore
report leaks on wrappers which encapsulate leaking system
resources. Since these reports are not independent, we clus-
terthem so that all wrapper leaks pertaining to the same
underlying resource are in the same cluster. For example,
the leaks on the FileOutputStream ,OutputStreamWriter and
PrintWriter resources in Fig. 1 form a single report cluster.
We cluster reports by post-processing the output of the
standard inter-procedural algorithm. Initially, wrapper types
seed the analysis just like real resources. Once the analysis
terminates, potentially leaking instances are organized into a
forest of directed acyclic graphs. The roots of these graphs
represent real resources, and edges lead from wrapped to
wrapper instances. An edge is created between instances p
andqifq:fis a must alias of p, andfis a eld that holds
a wrapped object. The determination of which elds hold
nested resources is a matter or specication. Each discon-
nected portion of this forerst is presented as a cluster.
4. IMPLEMENTATION
We implemented the techniques presented here in a tool
called tracker , which is based on the wala [1] program
analysis framework. tracker analysis is performed in three
stages. First, the tool computes the call graph of the pro-
gram to be analyzed. Because many of the standard call
graph construction algorithms ( e.g., 0-CFA) neither scale to
large applications nor work well for partial programs, we
base our call graphs directly on the program's class hierar-
chy, using type information to determine targets of virtual
dispatches. For eciency, the computed call graph includes
only a necessary subset of the program's methods. In par-
ticular, a given method mis included only if it contains
a resource allocation instruction or it transitively calls a
method that contains such an instruction. Each included
method must also be reachable from a public entry point
(i.e., a public method of a public class). After it has con-
structed the call graph, tracker performs the core resource
tracking analysis (Sec. 2), which generates a set of witnessed
and assumed leak reports (Sec. 3.1). The nal stage of the
analysis involves clustering and ltering (Sec. 3.3) of these
reports for improved actionability.5. EMPIRICAL EVALUATION
To evaluate tracker , we conducted a series of exper-
iments on the ve open source programs listed in Table 1.
These include a build tool ( Ant 1.7), an image manipulation
toolkit ( Batik 1.6), a reporting system for web applications
(BIRT 2.5), a peer-to-peer bit torrent client ( Frostwire
4.17), and a web server ( Tomcat 6.0). The table shows the
size of each benchmark, given as the number of classes and
methods. Also shown are the number of resource allocation
sites in each program and the size of its call graph. The
latter is measured by the number of included methods, the
number of classes containing those methods, and the time
taken to compute the graph.
We conducted four experiments on the candidate pro-
grams. The rst three experiments were designed to eval-
uate the eectiveness of our ranking heuristic, exception-
ltering mechanism and clustering techniques. The fourth
compares tracker tofindbugs [4]. Unless stated other-
wise, tracker was congured to lter exceptions, cluster all
reports, lter non-actionable wrapper reports, and to track
at most 10 access path of length 10 or less per resource.
Tracking facts larger than h10;10idid not change the out-
put of the tool for any of the subject programs. We refer to
this conguration of the tool as the baseline conguration or
base . Report counts shown in the tables and graphs refer
to the number of report clusters, unless otherwise specied.
The same set of resource acquire-release specications was
used for each experiment: the stream resources in the java.io
package and the database resources in the java.sql package.
All experiments were performed on 2.4 GHz Intel Core Duo
machine with 4 GB of memory.
Program Size# ResourcesCall Graph SizeclassesmethodssystemwrapperclassesmethodssecAnt 1.76,95263,0331482421,4407,99018Batik 1.611,18797,04847972,38110,36524Birt 2.569,293572,7442003059,90053,802304Frostwire 4.1716,279127,3631202043,67619,85664Tomcat 6.09,981102,2201241672,27313,48730
Table 1: Benchmark statistics.
5.1 Report Prioritization and Actionability
Goals and methods. To assess the eectiveness of our
ranking heuristic, we congured the base tracker with ve
dierent limits on the size of tracked facts and used it to
compute ve corresponding sets of reports for each bench-
mark. The ve limits include the base limit h10;10iand
four stricter limits: h1;3i,h3;3i,h3;5i, andh5;5i. We man-
ually classied the base report sets into true positives (TP)
and false positives (FP). This classication was then used
to automatically classify the remaining report sets, taking
advantage of the fact that tracker 's output is sound (so
it always includes all true positives) and monotonic (so it
includes fewer false positives as limits on fact size are in-
creased).
Results. The results are presented in Fig. 6. We show
one chart per benchmark, each with one bar per report set.
The height of a bar indicates the total number of reports
in the given report set. The height of the shaded regions
within a bar indicates the number of witnessed true posi-tives (black), assumed true positives (white pattern on black
background), witnessed false positives (white), and assumed
false positives (black pattern on white background). For ex-
ample, theh3;5ireport set for Ant includes a total of 95
reports, which consist of 54 true positives (47 witnessed and
7 assumed) and 41 false positives (9 witnessed and 32 as-
sumed). The graph on the bottom right shows the time,
in seconds, taken to compute each report set after the call
graph has been constructed.
Discussion. The data shown in Fig. 6 reveals three key
trends. First, due to the soundness and monotonicity of
tracker , the total number of true positives for each bench-
mark remains constant and the number of false positives de-
creases monotonically as limits on fact size are relaxed. In
practice, this means that the user of the tool can easily con-
trol the trade-o between resource consumption and report
quality. Second, for most limits on fact size, true positives
comprise a much higher proportion of witnessed reports than
of assumed reports:jWhd;bi\TPj
Whd;bijAhd;bi\TPj
Ahd;bi. In other
words, witnessed reports, which are ranked as \high prior-
ity" by tracker , have a higher probability of being true
positives than the lower ranked assumed reports. Third, the
number of witnessed true positives obtained with the de-
fault limit ofh3;5ion fact size captures the majority of the
witnessed true positives obtained with more generous lim-
its. The tool's default conguration therefore oers a good
trade-o between performance and quality for a wide range
of applications.
5.2 Exception Flow Filtering
Goals and methods. To evaluate the eect of exception
ltering on report quality, we applied two congurations of
tracker to all ve benchmarks: the baseline conguration
that lters exceptional edges as described in Sec. 3.2 and
a variant conguration that processes all edges indiscrimi-
nately. Reports generated by the variant but not the base-
line were manually classied into true and false positives.
Results. Table 2 summarizes our ndings. For each
benchmark, we show the total number of new true and false
positives, as well as the fraction of the new results with re-
spect to the baseline output. For example, applying the
variant conguration of tracker toAnt yielded 44 new
reports, only two of which were true positives. This com-
prises four percent of the true positives found by the baseline
conguration.
Discussion. Overall, we found that exception ltering
signicantly improves the quality of tracker 's results. Dis-
abling the lter introduced a large percentage of false posi-
tives and only a negligible fraction of true positives in all but
one benchmark, where it had no eect. Most of the addi-
tional false positives were due to low-likelihood exceptional
edges within try catch nally blocks. The additional true
positives were all due to exceptions that our lter deems
irrelevant but that we thought likely to occur in practice.
5.3 Report Clustering and Wrappers
Goals and methods. To measure the eects of report
clustering and of distinguishing between system resources
and wrappers, we compared the output of our baseline con-
guration to that of the all-real conguration. The lat-
ter, unlike base , treats wrappers as real system resources.
The comparison of the two congurations involved simply
counting the number of report clusters and the number of
0255075100125
!1, 3"!3, 3"!3, 5"!5, 5"!10, 10"Tomcat 6.00255075100125
!1, 3"!3, 3"!3, 5"!5, 5"!10, 10"Frostwire 4.17
04080120160200
!1, 3"!3, 3"!3, 5"!5, 5"!10, 10"Birt 2.501020304050
!1, 3"!3, 3"!3, 5"!5, 5"!10, 10"Batik 1.6
0306090120150
!1, 3"!3, 3"!3, 5"!5, 5"!10, 10"Ant 1.7
W tpA tpW fpA fp015304560
!1, 3"!3, 3"!3, 5"!5, 5"!10, 10"Analysis time (sec) vs. fact size
antbatikbirtfrostwiretomcatFigure 6: Performance and quality of reports for a
sampling of fact sizes.
individual reports in each result set. We did not classify
the leaks reported by all-real but not by base , since we
consider all reports on wrappers that do not (transitively)
wrap a real resource to be non-actionable.
Results. Figure 7 presents the results. The chart shows
the number of clusters and the number of individual reports,
both base andall-real , for each benchmark. For exam-
ple,base generated a total of 151 individual reports for Ant,
which were grouped in 83 clusters. The all-real congu-
ration, on the other hand, produced 238 individual reports
and 148 clusters.
Discussion. Comparing the output of base andall-
real , we nd that, on average, all-real generates twice as
many reports and clusters as base . None of the additional
reports are, in our view, actionable. We therefore believe
that a practical resource leakage analysis must distinguish
between system resources and wrappers. For both base and
all-real , clustering decreases the number of distinct leaks
that the user needs to examine by 15 to 45 percent. In our
experience, clustering was particularly helpful for triaging
complex inter-procedural leaks that involve a single system
resource and several dierent wrappers.TPFPTP / base TPFP / base FPAnt 1.72420.041.45Batik 1.6000.000.00Birt 2.51110.010.50Frostwire 4.172230.032.56Tomcat 6.01190.011.58Table 2: Eects of exception ow ltering.
075150225300375450
Ant 1.7Batik 1.6Birt 2.5Frostwire 4.17Tomcat 6.0base clustersbase reportsall-real clustersall-real reports
Figure 7: Eects of report clustering on the output
of the base and all-real congurations of the analysis.
5.4 Comparison with Related Techniques
Goals, methods and results. To evaluate tracker
against an existing, widely-used tool, we applied findbugs
to our ve subject programs, classied the output into true
and false positives, and then compared the resulting clas-
sied reports to those of tracker base . The results are
presented in Table 3. For each benchmark and each class
of leaks, we show the number of reports that were found by
both tools, as well as the reports found by only one of the
tools. For example, in ant,tracker found 46 true positives
not found by findbugs , while all 8 true positives reported
byfindbugs were also reported by tracker .
Discussion. Overall, tracker found signicantly more
true positives than findbugs . We believe this is because
findbugs relies on heuristics to report only the most com-
pelling defects that it could reason about intra-procedurally.
findbugs reported fewer false positives, but the great ma-
jority of tracker 's false positives were the low-ranked as-
sumed reports. The few true positives that were detected
byfindbugs but not by our tool were all due to engineering
choices rather than fundamental limitations. For example,
theFrostwire true positives missed by tracker are lo-
cated in classes that were not analyzed because of the way
we determine the scope of a program's class hierarchy.
6. RELATED WORK
Our work has targeted problems relating to leaks of sys-
tem resources such as sockets and le descriptors. Much re-
lated work targets memory leaks, either with explicit mem-
ory management ( e.g.,malloc /free) or garbage collection.
Whether considering memory leaks or system resource leaks,
a static analysis must reason about a liveness property for
True PositivesFalse PositivesFBTRBOTHFBTRBOTHAnt 1.704684290Batik 1.6126111852Birt 2.5897538166Frostwire 4.173615190Tomcat 6.0263114120Table 3: Comparison of tracker and ndbugs.
objects in certain states, in the presence of potentially com-
plex aliasing.
Much previous work has considered type systems for region-
based memory management ( e.g., [23]), whereby a type sys-
tem prevents memory leaks and enables an implementation
of ecient storage reclamation. Alternatively, approaches
based on escape analysis ( e.g., [25]) typically employ sophis-
ticated, modular alias analysis to identify potential sources
of leaks. Other relevant tools with analysis for object live-
ness and memory leaks include Free-Me [16], Clouseau [17],
and Uno [20].
Qualitatively, bug-nding for system resource leaks has a
dierent avor from addressing general memory leaks. First,
system resource management usually involves a small sub-
set of a large program, whereas nearly every operation in
an object-oriented language involves dynamically allocated
memory. Second, in a bug-nding tool, it is reasonable to
suppress ndings to avoid false positives, whereas many ap-
plications in system memory management need conservative
analysis.
6.1 Analysis Tools
Weimer and Necula [24] studied system resource leak prob-
lems in Java programs due to incorrect exception handling.
This work presents a simple path-sensitive intraprocedural
static analysis to nd resource leak bugs. Weimer and Nec-
ula's analysis is unsound; nevertheless, they report that the
analysis still nds hundreds of problems with open-source
Java programs. In contrast to our work, Weimer and Nec-
ula's analysis does not consider aliasing, inter-procedural
paths, or nested resources.
Static analysis of resource leaks relies on analysis of a dy-
namic location liveness property as dened by Shaham et
al.[22]. Shaham et al. presented a conservative static anal-
ysis based on canonical abstraction to verify safety of syn-
thesized free operations for dynamically allocated objects.
A similar analysis could be used to insert dispose oper-
ations to prevent resource leaks. Charem and Rugina [7]
describe a similar approach with a less expensive analysis.
The CLOSER [12] performs a modular, ow-sensitive anal-
ysis to determine \live" system resources at each program
point. In contrast to these approaches, tracker neither
proposes nor checks safety of remediation at particular pro-
gram points, and it relies on signicantly less expensive alias
abstractions.
Our analysis tracks a heap abstraction based on k-limited
access-paths using ow-sensitive, context-sensitive interpro-
cedural analysis. Access path alias analysis has been used
in many previous works, including [19, 11, 5, 15].
Tools based dynamic instrumentation can detect resource
leaks, by checking that the appropriate disposal methods are
called when an object is reclaimed. The QVM [3] takes thisapproach, engineering a virtual machine where the garbage
collector cooperates to allow dynamic instrumentation to
detect object reclamation events. On the other hand, ap-
proaches based on bytecode instrumentation or aspects ( e.g.,
[2, 6]) better suit safety properties than these liveness prop-
erties, without cooperation from the garbage collector to
detect object death.
6.2 Languages and Type Systems
Java's nalizers provide a language construct designed to
help the programmer free resources. Section 6 of [24] reviews
problems with destructors and nalizers in practice. Java's
nalizers are particularly problematic for dealing with nite
resources, since the garbage collector provides no guarantees
for timely nalizer execution.
Many languages provide constructs to associate a resource
with a lexical scope, and ensure that the resource is closed
when the scope nishes. For example, C# provides a using
statement to guarantee timely disposal of resources at the
end of a lexical scope [18]. In our experience, many of the
resource leaks tracker found in Java code could be elimi-
nated if a similar lexical construct were available. However,
these solutions do not apply to code that caches resource
pointers in a heap, untied to a convenient lexical scope.
Weimer and Necula [24] propose a language construct for
Java called compensation stacks . A compensation stack as-
sociates each logical resource allocation with a scope, and
guarantees that a clean-up action (a closure) executes when
the program exits the scope. The scope can be tied to a lex-
ical boundary such as a method, or manipulated as a rst-
class object, to support more general control structures.
The Vault programming language [10] provides a type sys-
tem which can rule out certain types of resource leaks. The
Vault type system allows the programmer to specify func-
tion postconditions that ensure functions cannot allocate
and leak resources.
7. CONCLUSION AND FUTURE WORK
We presented a static analysis tool that reports resource
leakage defects in Java applications. There are many en-
gineering challenges in building such a tool, including the
generic problems of scalability and precision, as well as the
specic problems of dealing with exceptions and wrappers.
Our contribution is in overcoming these challenges, using a
blend of existing and new techniques. An empirical evalu-
ation of the tool showed its overall eectiveness, as well as
the importance of the techniques we discussed in the paper.
Several directions for future work have presented them-
selves. One is the problem of discovering specications auto-
matically, especially with regards to identifying which pairs
of types are related by a wrapper-wrappee relationship. An-
other promising direction is to extend the leak detection al-
gorithm to automatically suggest code refactorings.
Acknowledgement. We are indebted to Stephen Fink for
providing valuable comments on the paper as well as for
helping us with the findbugs experiments.
8. REFERENCES
[1] T. J. Watson Libraries for Analysis.
http://wala.sourceforge.net/ .[2] C. Allan, P. Avgustinov, A. S. Christensen, L. Hendren,
S. Kuzins, O. Lhot ak, O. de Moor, D. Sereni,
G. Sittampalam, and J. Tibble. Adding trace matching
with free variables to AspectJ. In OOPSLA '05 , 2005.
[3] M. Arnold, M. Vechev, and E. Yahav. QVM: an ecient
runtime for detecting defects in deployed systems. In
OOPSLA '08 , pages 143{162, 2008.
[4] N. Ayewah, D. Hovemeyer, J. D. Morgenthaler, J. Penix,
and W. Pugh. Using static analysis to nd bugs. IEEE
Software , 25(5):22{29, 2008.
[5] D. R. Chase, M. Wegman, and F. K. Zadeck. Analysis of
pointers and structures. In PLDI '90 , pages 296{310, 1990.
[6] F. Chen and G. Ro su. Mop: an ecient and generic
runtime verication framework. In OOPSLA '07 , 2007.
[7] S. Cherem and R. Rugina. Region analysis and
transformation for Java programs. In ISMM '04 , pages
85{96, 2004.
[8] R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and
F. K. Zadeck. Eciently computing static single
assignment form and the control dependence graph. ACM
Trans. Program. Lang. Syst. , 13(4):451{490, 1991.
[9] M. Das, S. Lerner, and M. Seigle. Esp: Path-sensitive
program verication in polynomial time. In PLDI , pages
57{68, 2002.
[10] R. DeLine and M. F ahndrich. Enforcing high-level protocols
in low-level software. In PLDI '01 , pages 59{69, 2001.
[11] A. Deutsch. Interprocedural may-alias analysis for pointers:
beyond k-limiting. In PLDI '94 , pages 230{241, 1994.
[12] I. Dillig, T. Dillig, E. Yahav, and S. Chandra. The
CLOSER: automating resource management in Java. In
ISMM '08 , pages 1{10, 2008.
[13] N. Dor, S. Adams, M. Das, and Z. Yang. Software
validation via scalable path-sensitive value ow analysis. In
ISSTA '04 , pages 12{22, 2004.
[14] D. Engler, D. Y. Chen, S. Hallem, A. Chou, and B. Chelf.
Bugs as deviant behavior: a general approach to inferring
errors in systems code. SIGOPS Oper. Syst. Rev. ,
35(5):57{72, 2001.
[15] S. J. Fink, E. Yahav, N. Dor, G. Ramalingam, and E. Geay.
Eective typestate verication in the presence of aliasing.
InISSTA , pages 133{144, 2006.
[16] S. Z. Guyer, K. S. McKinley, and D. Frampton. Free-me: a
static analysis for automatic individual object reclamation.
InPLDI '06 , pages 364{375, 2006.
[17] D. L. Heine and M. S. Lam. A practical ow-sensitive and
context-sensitive C and C++ memory leak detector. In
PLDI '03 , pages 168{181, 2003.
[18] A. Hejlsberg, P. Golde, and S. Wiltamuth. C# Language
Specication . Addison Wesley, Oct. 2003.
[19] N. D. Jones and S. S. Muchnick. Flow analysis and
optimization of Lisp-like structures . Prentice-Hall, 1981.
[20] K.-K. Ma and J. S. Foster. Inferring aliasing and
encapsulation properties for Java. SIGPLAN Not. ,
42(10):423{440, 2007.
[21] T. Reps, S. Horwitz, and M. Sagiv. Precise interprocedural
dataow analysis via graph reachability. In POPL , 1995.
[22] R. Shaham, E. Yahav, E. K. Kolodner, and M. Sagiv.
Establishing local temporal heap safety properties with
applications to compile-time memory management. Sci.
Comput. Program. , 58(1-2):264{289, 2005.
[23] M. Tofte and J.-P. Talpin. Implementation of the typed
call-by-value Lambda-calculus using a stack of regions. In
POPL '94 , pages 188{201, 1994.
[24] W. Weimer and G. C. Necula. Finding and preventing
run-time error handling mistakes. SIGPLAN Not. ,
39(10):419{431, 2004.
[25] J. Whaley and M. Rinard. Compositional pointer and
escape analysis for Java programs. SIGPLAN Not. ,
34(10):187{206, 1999.