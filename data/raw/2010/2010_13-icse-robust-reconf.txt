Robust ReconÔ¨Ågurations of Component Assemblies
Fabienne Boyer
LIG
Universit ¬¥e Joseph Fourier
Grenoble, France
Fabienne.Boyer@imag.frOlivier Gruber
LIG
Universit ¬¥e Joseph Fourier
Grenoble, France
Olivier.Gruber@imag.frDamien Pous
CNRS
Grenoble, France
Damien.Pous@ens-lyon.fr
Abstract ‚ÄîIn this paper, we propose a reconÔ¨Åguration protocol
that can handle any number of failures during a reconÔ¨Åguration,
always producing an architecturally-consistent assembly of com-
ponents that can be safely introspected and further reconÔ¨Ågured.
Our protocol is based on the concept of Incrementally Consistent
Sequences (ICS), ensuring that any reconÔ¨Åguration incrementally
respects the reconÔ¨Åguration contract given to component devel-
opers: reconÔ¨Åguration grammar and architectural invariants. We
also propose two recovery policies, one rolls back the failed
reconÔ¨Åguration and the other rolls it forward, both going as
far as possible, failure permitting. We speciÔ¨Åed and proved the
reconÔ¨Åguration contract, the protocol, and recovery policies in
Coq.
Index Terms ‚ÄîDynamic reconÔ¨Åguration, Component models,
Robustness
I. I NTRODUCTION
A current trend in dynamically reconÔ¨Ågurable systems is the
use of a model-driven approach to govern the evolution and
maintenance of component assemblies [3][5][11][20]. In this
approach, an administrator (or an autonomic tool) is provided
with a component-based model of the software architecture
of the complex system he manages. As needed, he can
introspect that model to analyze the current architecture and
shape a desired software architecture. Given as input these
two architectures, a reconÔ¨Åguration protocol is responsible for
driving the effective evolution of the managed system from its
current architecture towards the desired target architecture.
Traditionally, a reconÔ¨Åguration protocol is based on an
architectural diff that compares the current and target architec-
tures, producing a set of elementary reconÔ¨Åguration operations
to apply on software components [21][3][13][15][23]. Through
this apply process, the reconÔ¨Åguration protocol evolves the
component assembly from its current architecture towards the
desired one, one reconÔ¨Åguration operation at a time. In [21],
the authors discuss the crucial role of this protocol: a safe
ordering of reconÔ¨Åguration operations.
A safe ordering must respect the reconÔ¨Åguration contract
under which components have been programmed. This con-
tract classically deÔ¨Ånes a reconÔ¨Åguration grammar specifying
legal sequences of reconÔ¨Åguration operations per component.
With this knowledge, developers design each component as
a Ô¨Ånite state machine that reacts to the reconÔ¨Åguration op-
erations issued by the reconÔ¨Åguration protocol. As brieÔ¨Çy
described in [21], the traditionally-accepted ordering is the onederived from the reconÔ¨Åguration protocol originally introduced
in [17].
We argue that this traditional ordering suffers from two main
limitations today. Firstly, component models have evolved
since then, introducing different semantics on component
dependencies, optional and mandatory [8][9][10][25], which
controls if components are started or stopped. This evolution
of the component paradigm induces an evolution of the pro-
gramming contract given to component developers, extending
the reconÔ¨Åguration grammar and introducing architectural in-
variants. While we suspect that the impacts on the ordering
of reconÔ¨Åguration operations has been considered by modern
component-based systems, to the best of our knowledge, these
impacts have never been discussed in any published materials.
Secondly, the traditional ordering does not support failures
occurring at reconÔ¨Åguration time. A component may indeed
fail to successfully apply a reconÔ¨Åguration operation. To face
this limitation, [13][14][19] advocate a rollback strategy based
on inverse operations. However, this approach only tolerates
a single failure since the rollback only succeeds if all inverse
operations succeed. Given that inverse operations are regular
reconÔ¨Åguration operations, there is no guarantee that they will
succeed. In case an inverse operation fails, the rollback must
be interrupted, leaving human administrators or autonomic
managers with the difÔ¨Åcult task of introspecting and repairing
a partially rollbacked and potentially inconsistent assembly.
The contributions of our work are the following. First, we
propose the Ô¨Årst reconÔ¨Åguration protocol that orders recon-
Ô¨Åguration operations such as to respect the reconÔ¨Åguration
contract given to component developers, fulling specifying
both the reconÔ¨Åguration grammar and the architectural invari-
ants that must be respected. Second, our protocol is robust,
respecting the reconÔ¨Åguration contract even in the case of
multiple failures occurring during a reconÔ¨Åguration. Third, we
formalized the complete protocol and proved it using the Coq
proof assistant [4], providing one of the strongest degree of
guarantee currently available with formal methods.
The core principle behind our solution is that the reconÔ¨Ågu-
ration protocol always evolves the component assembly from
one consistent architecture to another consistent architecture,
only through a path of architecturally consistent architectures.
This approach permits to manage failures as regular reconÔ¨Åg-
urations: when a component fails to execute a requested oper-
ation, our protocol stops, marks the component as failed, andthen propagates the effects of that failure throughout the com-
ponent assembly. Since this propagation is a reconÔ¨Åguration, it
may induce further failures that are processed identically. Once
the impacts of all failures have been propagated, the managed
system is architecturally consistent, which means that it can be
safely introspected and further reconÔ¨Ågured. Importantly, this
means that an administrator or an autonomic tool can safely
introspect this architecture and decide how to best repair the
occurred failures.
The remaining of the paper is structured as follows. Sec-
tion II discusses component models. In Sections III and IV, we
detail our reconÔ¨Åguration protocol in the absence of failures,
while Section V is devoted to the robust version of the
protocol. Section VI evaluates the proposed protocol. Finally
we discuss related works in Section VII and we conclude in
Section VIII.
II. C OMPONENT MODEL
This section brieÔ¨Çy recalls the growing consensus amongst
component models [8][9][10][25] regarding the concept of a
component, its lifecycle, and its dependencies, as well as the
reconÔ¨Ågurability of a component assembly.
A component is a software entity that deÔ¨Ånes a set of exports
and imports. Exports describe services that the component
is willing to provide while imports describe services that it
requires to function properly. Hence, a component assembly
can be shaped by wiring imports to exports. Imports are
given either a mandatory or optional semantics; while optional
imports may be wired or unwired at any time during the
lifetime of a component, mandatory imports should be wired
before a component is started. In other words, to be fully
functional, a component must have all its mandatory imports
wired to exports.
The main reconÔ¨Åguration operations that are provided are
the following.
ReconÔ¨Åguration operations
CONSTRUCT /DESTRUCT components
WIRE /UNWIRE components
START /STOP components
Each component implements all these reconÔ¨Åguration op-
erations in a component-speciÔ¨Åc manner but following a
reconÔ¨Åguration contract including a reconÔ¨Åguration grammar
andarchitectural invariants . The reconÔ¨Åguration grammar, as
depicted in Figure 1, speciÔ¨Åes in which order and in which
conditions a reconÔ¨Åguration operation may be invoked. This
grammar relies on three main lifecycle states for a component:
STOPPED ,STARTED , and FAILED . When Ô¨Årst constructed,
a component is in the STOPPED state, meaning it is not
functional yet. A component may reach the STARTED state
once it is resolved, i.e., once all its mandatory imports are
wired. A component may fail at any time, reaching the FAILED
state. Once failed, a component may be removed from the
assembly.
Architectural invariants , deÔ¨Åned below, constrain the ar-
chitecture of a component assembly that corresponds to the
    STOPPED STARTED
constructstopstartwire/unwire
optional
destructwire/unwire 
mandatory/
optionalFAILEDfail
failFig. 1. ReconÔ¨Åguration grammar
description of which component compose the assembly, what
are their lifecycle states and how they are wired together. More
preciselly, architectural invariants correlate the components
lifecycle with the semantics of their imports (optional vs
mandatory). These invariants deÔ¨Åne an architecturally consis-
tent assembly of components, meaning an assembly that can
be safely introspected and reconÔ¨Ågured by an administrator
or an autonomic tool. They are not to be confused with
higher-level invariants that capture application-speciÔ¨Åc and
domain-speciÔ¨Åc knowledge. For instance, application-speciÔ¨Åc
invariants might state that an application only works if all
components are started, or that certain components may be
stopped and the application is still operational. Hence, an
architecturally-consistent assembly might not be functional
from an overall application perspective, but it is reconÔ¨Ågurable
in order to re-establish a functional assembly.
DeÔ¨Ånition 1. Architectural invariants
(I1)All started components have all their mandatory imports
wired.
(I2)All started components are wired only to started compo-
nents.
(I3)There are no wires to/from failed or destructed compo-
nents
(I4)There are no cycles through mandatory imports1.
The reconÔ¨Åguration grammar along with the architectural
invariants deÔ¨Åne the reconÔ¨Åguration contract that enables com-
ponent developers to approach the design of a component as a
Finite State Machine. For instance, once started, a component
has the guarantee that all its mandatory imports have been
wired. Reversely, any component will be stopped before its
mandatory imports are unwired. This contract is therefore the
cornerstone of component design, helping developers to master
the difÔ¨Åcult challenge of designing components that can be
dynamically reconÔ¨Ågured.
Notation
In the sequel, we use letters c; dto range over components,
andv; w to range over wires. A wire wlinks an import i
of a component cto an export eof another component c0;
we denote the source (c)byw:src and the destination (c0)
byw:dst . We also use letter oto range over reconÔ¨Åguration
operations , which we separate into down operations: stop(c),
1This is a widely-accepted limitation amongst component mod-
els [8][9][10][25].Current architecture Target architecture
Prepare
Commit
Managed SystemReconfigured
Managed SystemFig. 2. ReconÔ¨Åguration session
unwire (w),destruct (c),fail(c), and up operations :
construct (c),wire(i; e),start (c).
III. R ECONFIGURATION CHALLENGE
A reconÔ¨Åguration protocol [3][13][15][21][23] reconÔ¨Ågures
a component assembly according to a desired target archi-
tecture (speciÔ¨Åying which components should compose the
system, what are their lifecycle states, and how they should be
wired together according to Section II). Each reconÔ¨Åguration is
organized as a session with two phases, as depicted in Figure 2.
In the prepare phase, a working copy of the current architec-
ture can be freely reshaped to deÔ¨Åne the target architecture2.
Then, during the commit phase, the reconÔ¨Åguration protocol
evolves the managed system towards the target architecture by
applying reconÔ¨Åguration operations.
The challenge of a reconÔ¨Åguration protocol consists in Ô¨Ånd-
ing a correct sequence of reconÔ¨Åguration operations. Indeed,
a naive approach consisting in computing an architectural
diff [17][21] and directly applying the corresponding recon-
Ô¨Åguration operations may violate the reconÔ¨Åguration contract.
A very simple example illustrates this.
Let‚Äôs suppose that we have a simple assembly with three
started components c,c1, and c2, with a mandatory wire w
from ctoc1. Let‚Äôs further suppose that the administrator
gives a target architecture where the three components are also
started, but where wnow points to c2. The diff will produce
only two operations: unwire (w)andwire(c; c2). While the
architecture is consistent before and after the reconÔ¨Åguration,
it goes through an inconsistent state: as soon as we apply the
unwire operation, we violate invariant (I1)since we have a
started component (c)with an unwired mandatory import.
In order to always respect the reconÔ¨Åguration contract,
the managed system should always be reconÔ¨Ågured through
incrementally consistent sequences:
DeÔ¨Ånition 2. Given an architecture A, an incrementally
consistent sequence (ICS) is a sequence o1; : : : ; o nof re-
conÔ¨Åguration operations such that:
2Note that the target architecture may also be selected from a version space
or generated through model-driven generative approaches.unwired (w))
ifmandatory( w)stopped (w:src )
unwire( w)
stopped (c))
for all wsuch that w:dst =c
ifmandatory( w)stopped (w.src)
else unwired( w)
stop(c)
destructed (c))
for all wsuch that w:src =corw:dst =c
unwired (w)
destruct( c)
Fig. 3. Propagation rules
1)for all i2[0; n], the architecture Aiobtained by
successively applying the iÔ¨Årst operations o1; : : : ; o ito
Ais consistent (DeÔ¨Ånition 1);
2)for all i2[1; n], the operation oiis allowed in the
stateAiby the reconÔ¨Åguration grammar (Figure 1).
Intuitively, a sequence is incrementally consistent if it can
be applied incrementally to a system without ever violating
the reconÔ¨Åguration contract: architectural invariants (DeÔ¨Åni-
tion 1) and reconÔ¨Åguration grammar (Figure 1). Note that
incrementally consistent sequences can be composed to build
larger sequences that remain incrementally consistent. The
next section details how our reconÔ¨Åguration protocol computes
and applies incrementally consistent sequences (ICSs).
IV. R ECONFIGURATION PROTOCOL
When a reconÔ¨Åguration session commits, using the current
and target architectures as inputs, the reconÔ¨Åguration protocol
computes and applies an ICS that evolves the managed system
into the target architecture. To compute such an ICS, two
phases are necessary.
The Ô¨Årst phase focuses on down operations, computing a
Ô¨Årst architectural diff between the current and target archi-
tectures, called the Apply Down Set (ADS) (see Listing 1).
The ADS only contains down reconÔ¨Åguration operations and
may be incomplete, as explained earlier. Hence, rather than
considering the ADS as a set of reconÔ¨Åguration operations
that should be applied, the ADS is considered as a set of
reconÔ¨Åguration goals that should be reached. For instance,
if we have an operation unwire (w)in the ADS, we will
consider that we have a goal unwired (w). Similarly, if we
have an operation stop(c), we will consider that we have a
goalstopped (c).
The difference between a reconÔ¨Åguration operation and its
corresponding reconÔ¨Åguration goal is that a reconÔ¨Åguration
operation is a standalone operation whereas a goal may require
other goals to be reached in order to preserve the architectural
invariants. For instance, in the previous example, the goal
unwired (w)requires the goal stopped (w:src )to be reached
to preserve the invariant (I1).
Our protocol uses the propagation rules given in Figure 3
to saturate the ADS with the missing reconÔ¨Åguration opera-optional unwire
        stop
mandatory unwire
destruct/faild o w
n  p h ase
u p p ha se
constructmandatory wireoptional wire
startFig. 4. Ordering to obtain an ICS
tions, producing the Saturated Apply Down Set (SADS). The
Ô¨Årst rule translates an unwired goal into the corresponding
unwire operation but also generates a stopped goal if the
wire to be removed is mandatory‚Äîthus enforcing the invari-
ant(I1). The second rule translates a stopped goal on a
component cinto the corresponding stop operation but also
generates additional goals to preserve the invariant (I2). The
third rule translates a destructed goal into the corresponding
destruct operation but also generates unwired goals for
all wires connected to or from the destructed component‚Äî
thus preserving the invariant (I3). Note that this propagation
always terminates; the only case where the algorithm could
loop is when trying to stop a component belonging to a
cycle of mandatory wires, which is precisely forbidden by the
invariant (I4).
Then our protocol obtains a Ô¨Årst ICS by ordering the
operations in the SADS such as to respect the reconÔ¨Åguration
grammar, as depicted in Figure 4. Furthermore, the stop
operations are also ordered as to respect the invariant (I2).
Applying this ICS on the managed system ends the Ô¨Årst down
phase of the commit. Note that to apply an ICS on the managed
system, the necessary quiescence must be established at the
level of the component runtime [17].
The second phase of the commit is concerned with up
operations. To obtain the Apply Up Set (AUS), it is necessary
to process an up diff between the current architecture that
has just evolved through down operations, and the unchanged
target architecture. Note that this up diff may only be com-
puted after the down diff has been computed and saturated ,
as the saturation may forces additionnal down operations to
be processed, which will require a larger set of up operations
to reach the target architecture.
The AUS obtained from the up diff is saturated by deÔ¨Ånition
since architectural invariants do not require any propagation
regarding up operations. This AUS needs to be ordered into
an ICS, using the ordering algorithm (Figure 4). Furthermore,
as it was the case for stop operations, start operations are also
ordered as to respect invariant (I2). Applying this ICS ends
the second up phase of the commit.
Putting it all together, the two phases of the commit
are summarized below, explaining the algorithm given in
Listing 1:
1)Down Phase. Our protocol Ô¨Årst computes the ADS by
processing a diff between the current ( AC) and target
(AT) architectures, saturates the ADS into the SADS,commit (AC,AT)f
// ReconÔ¨Ågure the architecture ( AC) of the managed system
// to match the target architecture ( AT)
assert (consistent( AC) && consistent( AT));
ADS, AUS: sets of reconÔ¨Åguration goals
SADS, SAUS: sets of reconÔ¨Åguration operations
ICS: sequence of reconÔ¨Åguration operations
// down phase
ADS = diff down (AC,AT);
SADS = propagate (AC, ADS); // see propagation rules
ICS = order (AC,SADS); // see Figure 4
A0
C=apply (AC,ICS);
// up phase
AUS = diff up(A0
C,AT);
ICS = order (AT,AUS); // see Figure 4
A00
C=apply (A0
C,ICS);
assert (isomorph( A00
C,AT));
return (A00
C);
g
Listing 1. Commit algorithm
orders the SADS into an ICS, and Ô¨Ånally applies that
ICS on the managed system, which evolves it to a new
current architecture A0
C.
2)Up Phase. Our protocol computes the AUS by process-
ing a diff between A0
CandAT, orders this AUS into an
ICS, and applies this ICS on the managed system with
the architecture A0
C, which evolves it to a new current
architecture A00
C.
At the end of the commit, the architecture of the managed
system ( A00
C) is isomorphic to the desired target architecture
(AT), and the system has been reconÔ¨Ågured through two ICS.
We conclude this section with an illustrative example.
Consider the managed system with the current architecture
ACfrom Figure 5, with four started components d,c,c1,
andc2, mandatory wires wfrom dtocandw1from c
toc1, and an optional wire vfrom c1toc(invariant (I4)
holds since it concerns only mandatory wires). Take ATas
target architecture, where the wire w1is now replaced by a
mandatory wire w2from ctoc2.
ACdw//c
w166c1vvv
c2ATdw//c
w2 ))c1vvv
c2
A0
Cdw//c c1
c2
Fig. 5. Example of a reconÔ¨Åguration sessionThe Apply Down Set returned by the Ô¨Årst
architectural diff is just the singleton funwired (w1)g.
By the above propagation rules, we get the
following saturated set of down operations:
SADS =funwire (w1); unwire (w); stop (c); stop (d)g.
This set is ordered into the following ICS:
ICS =unwire (v); stop (d); stop (c); unwire (w1). Note
that the component dhas to be stopped Ô¨Årst because of its
mandatory dependency on c. By applying this sequence on
the managed system, we get an architecture A0
Cwhere c; d
are stopped, and wis the only wire (see Figure 5). We can
Ô¨Ånally engage in the up phase.
The second architectural diff between A0
CandATgives
the set: AUS =fwire(w2); wire (v); start (c); start (d)g,
which is ordered as follows into the following ICS: ICS =
wire(w2); start (c); start (d); wire (v). As expected, applying
this ICS on A0
Cresults in a managed system which is isomor-
phic to AT.
V. R OBUST PROTOCOL
During the commit phase of a reconÔ¨Åguration session, fail-
ures may occur since reconÔ¨Åguration operations are invoked
on components and components may fail executing these
reconÔ¨Åguration operations. We assume that a reconÔ¨Åguration
operation that fails when invoked on a component c only
impacted that component c. This section discusses how our
protocol recovers from such failures.
When a reconÔ¨Åguration operation fails, the reconÔ¨Åguration
protocol suspends the on-going reconÔ¨Åguration and starts a
recovery process. This recovery process must not only mark
the component that just failed as FAILED , but it must also
propagate the impacts of that failure throughout the managed
system.
robust commit (AC,AT)f
// ReconÔ¨Ågure the architecture ( AC) of the managed system
// to match the target architecture ( AT)
assert (consistent( AC) && consistent( AT));
[A0
C,FailedComp] = commit (AC,AT);
if(FailedComp == null)return [A0
C,;];
else return recover current (A0
C,fFailedCompg);
g
recover current (AC,FailedSet)f
// account for failed components in the managed system
SADS = propagate (AC, FailedSet);
ICS = order (AC,SADS);
[A0
C,FailedComp] = apply (AC,ICS);
if(FailedComp == null)
return [A0
C,FailedSet];
else
return recover current (A0
C,FailedSet[fFailedCompg);
g
Listing 2. Robust commit algorithm
The corresponding robust commit algorithm, given in List-
ing 2, wraps the regular commit (AC,AT)algorithm givenearlier in Listing 1. When a failure occurs, the regular commit
suspends itself and returns the identiÔ¨Åcation of the component
that just failed. The robust commit enters its recovery process
(recover current ), starting with a ( FailedSet ) that only contains
the component that just failed. It computes a saturated ADS
(SADS) for accounting this failure in the managed system,
using the three previous propagation rules (Figure 3) and the
following one for failed goals:
failed (c))
for all wsuch that w:src =corw:dst =c
unwired (w)
fail(c)
This SADS is then ordered into an ICS by ordering the
operations as depicted in Figure 4. Overall, this ICS prop-
agates the impacts of the failure throughout the managed
system and terminates by marking the component as FAILED .
Since applying this ICS invokes reconÔ¨Åguration operations
on components, cascading failures may occur. Handling and
recovering such failures is no special case. The on-going
recovery suspends itself, the component that just failed is
added to the set of failed components, and a new recovery is
attempted. This Ô¨Åxpoint always terminates since the number
of components that may fail is Ô¨Ånite. When this recovery
eventually completes, the managed system is architecturally
consistent.
From the perspective of the managed system, the entire
recovery phase appears as a sequence of ICSs, all interrupted
by new failures but for the last one that manages to complete
the recovery of a consistent assembly.
VI. E VALUATION
We evaluated our reconÔ¨Åguration protocol along three main
aspects. First, we validated that our protocol always behaves
as expected. Second, we evaluated the usability of our ICS-
based approach to support advanced recovery policies. Third,
we evaluated the scalability of our protocol.
A. Proving the Protocol
To validate that our protocol always does what it is supposed
to do, we formalized and proved the entire protocol using
the Coq proof assistant [4]. Coq is an interactive theorem
prover , in the sense that it can be used to certify mathematical
proofs, using an interactive process where the user progres-
sively writes the proof with the help of the assistant. Unlike
automatic theorem provers or testing-based approaches, the
user has to provide a complete proof, a complex task that
makes it possible to consider arbitrarily complex problems,
providing one of the strongest degree of guarantee currently
available with formal methods. In particular, we proved that all
our algorithms behave correctly in all possible cases, including
the ones that could not be tested due to material restrictions
(memory or time).
The Coq development consists of about 2000 lines of Coq
code that can be browsed online [1]. Given two Ô¨Ånite sets of
Components andImports , an architecture is modeled by a
record:Record arch :=f
status :Component!Status ;
wires :ComponentImports!option Component
g
where status is a function indicating whether a given com-
ponent is started, stopped, or failed, and wires is a function
describing how the imports of a component are wired to
other components. ReconÔ¨Åguration operations are represented
using an union type op, and we deÔ¨Åne the meaning of
these operations using a function apply :archop!arch .
Accordingly, we model the propagation algorithm as a function
propagate :archop!list op , and the architectural diff
algorithm as a function of type archarch!list op . Using
these functions together with auxiliary functions for sorting
lists of operations, we deÔ¨Åne a commit function, that takes a
current architecture and a target architecture and produces a
list of reconÔ¨Åguration operations to be applied.
To model failures, we assume an arbitrary function:
eapply :
archoplist Component !arch +Component
which applies a given operation to an architecture (knowing
that the components given by list Component are failed)
and can either return the new architecture, if the operation
could successfully be applied, or return a newly failed com-
ponent. We then deÔ¨Åne the robust_commit function as a
Ô¨Åxpoint which uses the above eapply function to simulate an
execution where an arbitrary number of failures may occur.
While we could state the various properties that should
be ensured by the protocol using only 14 theorems, 153
intermediate lemmas were required to prove them. Among the
high-level theorems, we proved that:
1) the commit algorithm always produces ICS, which
means by deÔ¨Ånition of an ICS that the architectural
invariants and the reconÔ¨Åguration grammar are never
violated;
2) without failures, the commit algorithm always evolves
the source architecture to the target architecture;
3) the robust-commit algorithm properly acknowledges
failed components, whatever the number of failures;
4) all algorithms terminate.
Among the auxiliary lemmas, we had to prove that: 1. the
propagation algorithm produces saturated sets of reconÔ¨Ågu-
ration operations; 2. the above saturated sets can always be
ordered into an ICS; 3. the architecture reached after the down
phase makes it possible to reach the target architecture using
up operations only; 4. the diff algorithms are complete.
B. Leveraging our Protocol
We leverage our protocol to design two recovery policies‚Äî
Roll-Forward Policy (RFP) and Roll-Backward Policy (RBP),
see Listing 3‚Äîthat both exploit the incremental consistency
of our approach. In case of failures, the RFP policy is an
automated attempt to pursue the reconÔ¨Åguration as far as
possible towards the desired target, failure permitting. From
our previous work on repair management [24], it appearedthat doing as much as possible of the originally intended
reconÔ¨Åguration may help the administrator to analyze and
understand the failure and its impacts. Conversely, the RBP
policy is an automated attempt to rollback the reconÔ¨Åguration
session as much as possible, failure permitting as well.
// Policies for reconÔ¨Åguring the architecture ( AC) of the
// managed system
RFP commit (AC,AT)f// Roll-Forward Policy
[A0
C,FailedSet] = robust commit (AC,AT);
if(FailedSet ==;)return A0
C;
A0
T=recover target (AT,FailedSet); // recover reachability
return RFP commit (A0
C,T‚Äô);
g
RBP commit (AC,AT)f// Roll-Backward Policy
[A0
C,FailedSet] = robust commit (AC,AT);
if(FailedSet ==;)return A0
C;
A0
T=recover target (AC,FailedSet); // recover reachability
return RFP commit (A0
C,AI);
g
recover target (AT,FailedSet)f
// account for failed components in target arch. ( AT)
SDAS = propagate (AT, FailedSet)
ICS = order (AT,SADS);
[A0
T,] =apply (AT,ICS); // cannot fail
return A0
T;
g
Listing 3. Roll-Forward and Roll-Backward commit algorithms
In fact, these two policies differ in their choice of the target
architecture after a failure. For the Roll-Forward policy, we
keep the original target architecture ( ATin the RFP commit
algorithm). For the Roll-Backward policy, we toss away the
original target architecture and replace it with the initial
architecture AIthat the managed system had before it was
reconÔ¨Ågured.
Whichever is the new target architecture, it must be revised
to incorporate the failures that occurred. This is performed
by the ( recover target ) algorithm given in Listing 3. Please
note that, since the target architecture is purely abstract,
reconÔ¨Åguring it cannot induce cascading failures. With a target
architecture that is now reachable, our protocol can resume
its normal processing, pushing towards the chosen target
architecture, either roll-backing or roll-forwarding.
Notice that the Roll-Forward algorithm is a Ô¨Åxpoint, pushing
towards the chosen target as far as possible. Note also that
the Roll-Backward algorithm switches to the Roll-Forward
algorithm upon the occurrence of the Ô¨Årst failure. The rationale
is that, despite new failures, the commit should keep pushing
towards the initial architecture of the system.
C. Case Study
In this section, we illustrate the use of our protocol to man-
age a Web application server whose architecture is depicted
in Figure 6(a). In the Ô¨Ågure, A1andA2represent an HTTP
Daemon, T1andT2represent a Servlet Engine, and DB 1(a) Target architecture (b) Deployment result with 
     one failureA1 T1 DB1
A2 T2A1 T1
A2 T2(stopped) (failed)
(started) (started)(started)(started)
(started) (started)(started) (started)DB1Fig. 6. Typical clustered Web architecture
represents a database server. All imports in the architecture
are mandatory.
1) Deployment Scenario: The Ô¨Årst management task is the
initial deployment of the Web server. The administrator starts
with an initial current architecture that is empty and shapes
the desired target architecture depicted in Figure 6(a). When
the administrator commits the session, the reconÔ¨Åguration will
result in the deployment of the overall system. The down phase
of our protocol computes an empty Apply Down Set since the
current architecture of the managed system is empty. The up
phase of our protocol (see Listing 1) computes the following
Apply Up Set:
Apply Up Set / commit algorithm
construct: T1,T2,DB 1
wire: ( T1,DB 1), (T2,DB 1)
start: T1,T2,DB 1
construct: A1,A2
wire: ( A1,T1), (A2,T2)
start: A1,A2
Our protocol then orders this Apply Up Set into the follow-
ing ICS:
ICS / commit algorithm
construct: A1,A2,T1,T2,DB 1
wire: ( A1,T1), (A2,T2), (T1,DB 1), (T2,DB 1)
start: DB 1,T1,T2,A1,A2
Without failures, the apply of this ICS results in the
deployment of the desired clustered Web server. Let‚Äôs now
force a failure to occur upon wiring Tomcat to the database
system (e.g., wire( T1,DB 1)). The administrator may choose to
suspend the reconÔ¨Åguration session, knowing that the resulting
system is consistent and reconÔ¨Ågurable. In this particular
instance, the administrator would probably prefer to use the
Roll-Forward Policy (RFP commit algorithm in Listing 3)
because isolated failures during a deployment usually do not
justify to rollback the entire deployment.
The Roll-Forward policy executes the recover current algo-
rithm (Listing 2) that accounts for the failure of the Tomcat
instance T1and produces the following ICS: fail( T1). Indeed,
propagating the failure of T1has no effects since no compo-
nents were wired to T1at the time it failed.
Effective Architecture Target ArchitectureA1 T1
A2 T2A1 T1 DB1
A2 T2DB1
DB2Fig. 7. Target architecture with two databases
Then the Roll-Forward policy executes the recover target
algorithm (Listing 3) that accounts for the failure of T1in the
target architecture. T1is marked as failed, which propagates in
isolating T1(failed propagation rule). Removing mandatory
wires to T1propagates into stopping components depending
on these wires ( unwired propagation rule). Ultimately,
this produces the following ICS: stop( A1), unwire( A1,T1),
fail(T1), leading to the target architecture that is depicted in
Figure 6(b).
Committing this recovered target architecture allows to get
a managed system that is running despite a partial failure
during its deployment. Moreover, it is consistent and thus
ready to be reconÔ¨Ågured again.
2) Sizing Scenario: We consider adding a new database
server ( DB 2) and balancing the Tomcat servers over the
two database servers, as depicted in Figure 7. Being given
the current and target architectures of Figure 7, our protocol
computes the following Apply Down Set and Apply Up Set:
Apply Down Set
- unwire: ( T2,DB 1)Apply Up Set
- construct: DB 2
- start: DB 2
- wire: ( T2,DB 2)
Then, through propagation and ordering, our protocol gen-
erates the ICS given below which is a longer ICS because
theunwire( T2,DB 1)propagates a stop operation on both the
Tomcat and Apache components. They are also longer because
of the larger up set to reach the target architecture. Indeed,
since the protocol just stopped a Tomcat and an Apache that
are not stopped in the target architecture, the diff for the up
phase will produce the extra start operations needed.
Down ICS
- stop: A2,T2
- unwire: ( T2,DB 1)Up ICS
- construct: DB 2
- wire: ( T2,DB 2)
- start: DB 2,T2,A2
Without failure, the reconÔ¨Åguration achieves sizing up the
clustered Web server. Let‚Äôs now force a Ô¨Årst failure that occurs
on the start on DB 2. The recover current algorithm computes
the following ICS: unwire( T2,DB 2), fail( DB 2).Effective Architecture
(before DB 2's failure)Recovered Effective 
ArchitectureA1 T1
A2 T2A1 T1 DB1
A2 T2DB1
DB2 DB2
(stopped) (stopped) (stopped) (stopped)(started) (started) (started) (started) (started) (started)
(failed) (failed)Fig. 8. DB2‚Äôs failure during reconÔ¨Åguration
Initial Target Architecture Recovered Target ArchitectureA1 T1
A2 T2DB1 A1 T1
A2 T2
(stopped) (failed)(started) (started) (started) (started) (started) (started)
(started) (started)DB1
Fig. 9. Roll-Backward policy on DB2‚Äôs failure
This ICS would recover a consistent architecture if applied
entirely on the managed system. However, we will interrupt it,
considering the case of a cascading failure when attempting
tounwire the Tomcat instance T2. The Ô¨Åxpoint on the re-
cover current generates a new ICS: unwire( A2,T2), fail( T2),
fail(DB 2). This time, we will consider that the apply of this
ICS succeeds, meaning that the unwire on the Apache instance
A2succeeds and the recovery completes with a Ô¨Ånal fail set
offT2,DB 2g.
The Figure 8 shows the architecture of the managed system
before the Ô¨Årst failure (occurring on the start of DB 2) and after
the recovery process. Notice the post-recovery architecture is
architecturally consistent; the administrator can therefore in-
trospect the architecture, discover and understand the failures,
Ô¨Åx the reasons for the failures, if any, and ultimately issue one
or more reconÔ¨Ågurations to reach an acceptable conÔ¨Åguration
of the overall system.
D. Protocol Scalability
In this section, we wish to discuss the scalability of our
protocol in terms of the number of reconÔ¨Åguration operations
it issues.
Without considering failures, our protocol issues a number
of reconÔ¨Åguration operations that is solely governed by the
complexity of the current and target architectures and their
relative distance. Given a current architecture ACand a target
architecture AT, the largest possible reconÔ¨Åguration is to
destroy entirely ACand thereby entirely construct AT. In this
worst case scenario, our protocol issues a maximum number
of operations that is less or equal than Ndestruct +Nconstruct
where Ndestruct is the number of operations needed to entirely
destruct ACandNconstruct is the number of operations needed
to entirely construct AT.More precisely, given an architecture with Ccomponent
andWwires, the Ndestruct andNconstruct numbers must
be smaller that 2C+W. Indeed, regarding Ndestruct , each
component may at most be STOPPED and DESTRUCTED ,
while each wire may at most be UNWIRED . Regarding
Nconstruct , each component may at most be CONSTRUCTED
and STARTED , while each wire may at most be WIRED .
Notice that the saturation of the Apply Down Set, which is
a Ô¨Åxpoint, does not change the evaluation of this maximum
number of operations. Indeed, at the most, this saturation
may only add one unwire operation per wire and one stop
operation per component, operations that are already included
inNdestruct .
When considering failures, our protocol goes through a
recovery Ô¨Åxpoint that propagates the impacts of failures
throughout the current architecture. In the worst case, all
components will incrementally fail, in which case, the recovery
propagation will issue at most one unwire operation per wire
and one stop and fail operations per component. Consequently,
given an architecture AwithCcomponent and Wwires, we
can deÔ¨Åne Nrecover (A)as equal to 2C+W. However, since
failures may occur at any time, we need to consider the number
Nrecover that is equal to the maximum of the Nrecover (A)for
all architectures the managed system is going through from
ACtoAT.
Hence, even when considering failures, our protocol issues
less operations than Ndestruct +Nconstruct +Nrecover , a
number of operations that is still linear with the complexity
ofACandATarchitectures and their relative distance. In the
use-case given in Section VI-C1, Ndestruct is null as the initial
system is empty and Nconstruct is equal to 14 (5 CONSTRUCT ,
4WIRE , and 5 START ) and Npropagate is also equal to 14 (4
UNWIRE , 5STOP , and 5 FAIL ).
VII. R ELATED WORK
Many component models deÔ¨Åne a component lifecycle with
two states (started and stopped) controlled by the mandatory
and optional semantics of wires [8][9][10][25]. They provide
reconÔ¨Åguration operations that add/remove components and
wires between components. However, these operations are in-
voked individually, with an immediate effect on the component
assembly. This means that anyone reconÔ¨Åguring a component
assembly must take care of the following complex and error-
prone tasks. First, (s)he must apply reconÔ¨Åguration operations
in the correct order. For instance, only start a component after
it has all its mandatory imports wired). Second, (s)he must
manually propagate the collateral effects of each reconÔ¨Ågu-
ration operation, such as stopping a client component before
stopping a server one). With a model-driven reconÔ¨Åguration
approach, one simply shapes the target architecture, leaving
these tasks to the reconÔ¨Åguration protocol.
Regarding approches that advocate model-driven reconÔ¨Ågu-
rations [14][13][15][19][21][27], the focus is mainly on on
the capture of application-speciÔ¨Åc architectural constraints,
mostly through the use of architectural styles [16][26]. Com-
plementary to the architectural constraints that we considerin this paper, application-speciÔ¨Åc constraints do not require
to be incrementally preserved during a reconÔ¨Åguration, they
only need to be preserved by the target architecture. In other
words, application-speciÔ¨Åc constraints intend to shape func-
tional architectures while architectural constraints guarantee
reconÔ¨Ågurable architectures.
Most of the above frameworks did not publish any de-
tails on their reconÔ¨Åguration protocol, with the noticeable
exception of [21]. Their protocol orders reconÔ¨Åguration opera-
tions following [17], only considering optional wires between
components‚Äîa choice that is consistent with their underlying
component platform [22]. Regarding failures, only a few
frameworks [13][14][19] published about fault-tolerance, all
advocating a rollback strategy based on the use of inverse
reconÔ¨Åguration operations; a design that only supports a single
failure per reconÔ¨Åguration.
[2] discusses failures occurring during recovery and states
that it is a hard challenge for autonomic systems. However,
the paper only presents early ideas, suggesting that component
dependencies can be used to plan the propagation of the
impacts of failures throughout a component assembly. The
paper also suggests that recovery should be structured as
a Ô¨Åxpoint, but does not give any details. In particular, no
algorithms are described.
The RAPIDware project [28] is another component frame-
work that shares similarities with our proposal. It proposes
a formal model [18] to verify that during and after recon-
Ô¨Ågurations, the system remains in correct states in terms of
architectural and behavioral invariants. As [19], it proposes
a reconÔ¨Åguration process that handles failures that appear at
commit time through inverse operations.
Finally, in a prior work [7], we related our veriÔ¨Åcation
experience of an earlier version of the reconÔ¨Åguration pro-
tocol. The focus of the paper was the formal veriÔ¨Åcation
of our protocol using the CADP toolbox [12], only brieÔ¨Çy
introducing our protocol as an example of a veriÔ¨Åcation
process of interest to the community of formal methods. The
paper only sketched our protocol, including the notion of ICS
and its associated ordering algorithm (depicted in Fig 4). In
contrast, the presented paper discusses the complete protocol
at length, including its detailed design and detailed algorithms.
In particular, we acknowledge for the Ô¨Årst time the novel
ordering of operations based on four steps: architectural diff,
saturate, order, and apply. Moreover, this paper also reports on
proving the protocol rather than verifying it, providing on-line
the complete speciÔ¨Åcation in Coq. Finally, this paper includes
an evaluation of the protocol.
VIII. C ONCLUSION
This paper summarized the growing consensus of mod-
ern component models and the corresponding reconÔ¨Åguration
contract: reconÔ¨Åguration grammar and architectural invariants.
It proposed a reconÔ¨Åguration protocol based on the concept
of Incrementally Consistent Sequences (ICS), ensuring that
any reconÔ¨Åguration incrementally respects this reconÔ¨Åguration
contract. The proposed protocol resists any number of failuresduring the reconÔ¨Åguration, always producing an architecturally
consistent assembly of components that can be safely intro-
spected and further reconÔ¨Ågured. In that regards, we proposed
two advanced recovery policies, the Roll-Backward policy
that rolls back a failed reconÔ¨Åguration and the Roll-Forward
policy that pushes towards the desired target architecture, both
policies going as far as possible, failure permitting. We fully
speciÔ¨Åed our protocol and proved it correct using the Coq
proof assistant and we evaluated its complexity (linear with
respect to the complexity of the desired reconÔ¨Åguration).
ACKNOWLEDGEMENTS
The work described in this paper was partially supported
by FSN project OpenCloudWare.
REFERENCES
[1] Coq formalisation and certiÔ¨Åcation of the presented reconÔ¨Åguration
algorithms,http://sardes.inrialpes.fr/ pous/rrca/.
[2] N. Arshad, D. Heimbigner, and A. L. Wolf. Dealing with failures during
failure recovery of distributed systems. SIGSOFT Softw. Eng. Notes ,
30:1‚Äì6, May 2005.
[3] N. Bencomo, P. Grace, C. A. Flores-Cort ¬¥es, D. Hughes, and G. S.
Blair. Genie: supporting the model driven development of reÔ¨Çective,
component-based adaptive systems. In Proc. ICSE‚Äô08 , 2008.
[4] Y . Bertot and P. Cast ¬¥eran. Interactive Theorem Proving and Program
Development. Coq‚ÄôArt: The Calculus of Inductive Constructions . Texts
in Theoretical Computer Science. Springer, 2004.
[5] G. S. Blair, N. Bencomo, and R. B. France. Models@run.time. IEEE
Computer , 42(10):22‚Äì27, 2009.
[6] Sara Bouchenak, Fabienne Boyer, Benoit Claudel, Noel De Palma,
Olivier Gruber, and Sylvain Sicard. From autonomic to self-self
behaviors: The jade experience. TAAS , 6(4):28, 2011.
[7] F. Boyer, O. Gruber, and G. Salaun. Specifying and Verifying a Robust
ReconÔ¨Åguration Protocol with LOTOS NT/CADP. In 17th Int. Symp.
on Formal Methods (FM‚Äô11) , 2011.
[8] E. Bruneton, T. Coupaye, M. Leclercq, V . Qu ¬¥ema, and J.B. Stefani. The
Fractal Component Model and its Support in Java. Software ‚Äì Practice
and Experience (SP&E) , 36(11-12):1257‚Äì1284, September 2006.
[9] G. Coulson, G.S. Blair, M. Clarke, and N. Parlavantzas. The design
of a conÔ¨Ågurable and reconÔ¨Ågurable middleware platform. Distributed
Computing , 15(2):109‚Äì126, 2002.
[10] C. EscofÔ¨Åer, R. S. Hall, and P. Lalanda. ipojo: an extensible service-
oriented component framework. In IEEE Int. Conf. on Services Com-
puting (SCC 2007) , 2007.
[11] J. Floch, S. Hallsteinsen, E. Stav, F. Eliassen, K. Lund, and E. Gjorven.
Using architecture models for runtime adaptability. Software, IEEE ,
23(2):62 ‚Äì 70, march-april 2006.
[12] H. Garavel, R. Mateescu, F. Lang, and W. Serwe. CADP 2006: A
Toolbox for the Construction and Analysis of Distributed Processes. In
Proc. CAV‚Äô07 , pages 158‚Äì162. Springer, 2007.
[13] J. C. Georgas, A. van der Hoek, and R. N. Taylor. Architectural runtime
conÔ¨Åguration management in support of dependable self-adaptive soft-
ware. In Workshop on Architecting Dependable Systems , WADS ‚Äô05,
2005.
[14] A. Gomes, Tadeu A., T. Batista, A. Joolia, and G. Coulson. Architecting
dependable systems iv. chapter Architecting dynamic reconÔ¨Åguration in
dependable systems, pages 237‚Äì261. Springer-Verlag, Berlin, Heidel-
berg, 2007.
[15] A. Joolia, T. Batista, G. Coulson, A. Tadeu, and A. Gomes. A.t.a.:
Mapping adl speciÔ¨Åcations to an efÔ¨Åcient and reconÔ¨Ågurable runtime
component platform. In IEEE/IFIP Conference on Software Architecture
(WICSA‚Äô05) , 2005.
[16] J. S. Kim and D. Garlan. Analyzing architectural styles. J. of Systems
and Software , 83(7):1216‚Äì1235, 2010.
[17] J. Kramer and J. Magee. The evolving philosophers problem: Dynamic
change management. IEEE Trans. Software Eng. , 16(11):1293‚Äì1306,
1990.
[18] S. S. Kulkarni and K. N. Biyani. Correctness of component-based
adaptation. In 7th Int. Symp. on Component-Based Software Engineering
(CBSE‚Äô04) , 2004.[19] M. L ¬¥eger, T. Ledoux, and T. Coupaye. Reliable dynamic reconÔ¨Ågurations
in a reÔ¨Çective component model. In 13th Int. Symp. on Component-
Based Software Engineering (CBSE‚Äô10) .
[20] B. Morin, O. Barais, J-M J ¬¥ez¬¥equel, F Fleurey, and A Solberg. Models
at Runtime to Support Dynamic Adaptation. IEEE COMPUTER , pages
46‚Äì53, 2009.
[21] B. Morin, O. Barais, G. Nain, and J.-M. Jezequel. Taming dynamically
adaptive systems using models and aspects. In Proc. ICSE‚Äô09 , 2009.
[22] OSGi. OSGi service platform, release 4.1, OSGi Comittee,
http://www.osgi.org, 2008.
[23] R. Roshandel, A. Van Der Hoek, M. Mikic-Rakic, and N. Medvidovic.
Mae ‚Äì a system model and environment for managing architectural
evolution. ACM TRANS. SOFTW. ENG. METH. , 13(2):240‚Äì276, 2004.[24] S. Sicard, F. Boyer, and N. De Palma. Using components for
architecture-based management: the self-repair case. In Proc. ICSE‚Äô08 ,
2008.
[25] Spring. The Spring Framework, http://www.springframework.org, 2006.
[26] R. N. Taylor, N. Medvidovic, and P. Oreizy. Architectural styles
for runtime software adaptation. In IEEE/IFIP Conf. on Software
Architecture (WICSA‚Äô09) , pages 171‚Äì180, 2009.
[27] G. Waignier, P. Sriplakich, A.-F. Le Meur, and L. Duchien. A model-
based framework for statically and dynamically checking component
interactions. In Proc. MODELS‚Äô08 , volume 5301, pages 371‚Äì385.
Springer, 2008.
[28] J. Zhang and B. H. C. Cheng. Model-based development of dynamically
adaptive software. In Proc. ICSE‚Äô06 , pages 371‚Äì380, New York, NY ,
USA, 2006. ACM.