See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/221560595
Boosting the performance of ﬂow-sensitive points-to analysis using value ﬂow
Conf erence Paper  · Sept ember 2011
DOI: 10.1145/2025113.2025160  · Sour ce: DBLP
CITATIONS
92READS
542
3 author s, including:
Lian Li
Instit ute of Computing T echnolog y Chinese Ac ademy of Scienc es
54 PUBLICA TIONS    849 CITATIONS    
SEE PROFILE
Cristina Cif uent es
Oracle Corpor ation
91 PUBLICA TIONS    2,191  CITATIONS    
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y Cristina Cif uent es on 30 July 2014.
The user has r equest ed enhanc ement of the do wnlo aded file.Boosting thePerformance of Flow-sensitivePoints-to
Analysisusing Value Flow
LianLi Cristina Cifuentes NathanKeynes
OracleLabs
Brisbane, Australia
{lian.li,cristina.cifuentes,nathan.keynes}@oracle.c om
ABSTRACT
Points-to analysis is a fundamental static analysis technique
which computes the set of memory objects that a pointer
may point to. Many diﬀerent applications, such as security-
related program analyses, bug checking, and analyses of
multi-threaded programs, require precise points-to informa-
tion to be eﬀective. Recent work has focused on improving
the precision of points-to analysis through ﬂow-sensitivity
and great progress has been made. However, even with all
recent progress, ﬂow-sensitive points-to analysis can still be
much slower than a ﬂow-insensitive analysis.
In this paper, we propose a novel method that simpliﬁes
ﬂow-sensitive points-to analysis to a general graph reachabil-
ity problem in a value ﬂow graph. The value ﬂow graph sum-
marizes dependencies between pointer variables, including
those memory dependencies via pointer dereferences. The
points-to set for each pointer variable can then be computed
as the set of memory objects that can reach it in the graph.
We develop an algorithm to build the value ﬂow graph ef-
ﬁciently by examining the pointed-to-by set of a memory
object, i.e., the set of pointers that point to an object. The
pointed-to-by information of memory objects is very use-
ful for applications such as escape analysis, and information
ﬂow analysis.
Our approach is intuitive, easy to implement and very
eﬃcient. The implementation is around 2000 lines of code
and it is more eﬃcient than existing ﬂow-sensitive points-to
analyses. The runtime is comparable with the state-of-the-
art ﬂow-insensitive points-to analysis.
Categories andSubjectDescriptors
F3.2 [LOGICS AND MEANINGS OF PROGRAMS ]:
Semantics of Programming Languages–Program analysis
GeneralTerms
Precision, Eﬃciency
1. INTRODUCTION
Permission to make digital or hard copies of all or part of this w ork for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage and th at copies
bearthisnoticeandthefullcitationontheﬁrstpage. Tocop yotherwise, to
republish,topostonserversortoredistributetolists,re quirespriorspeciﬁc
permission and/orafee.
ESEC/FSE'11, September5–9, 2011,Szeged, Hungary.
Copyright2011ACM 978-1-4503-0443-6/11/09...$10.00.Points-to analysis is a fundamental static analysis tech-
nique which computes the set of memory objects (abstract
locations) that a pointer variable may point to. The points-
to information is often represented in the form of points-to
sets [1] or points-to graphs [5] and such information is a
prerequisite for many important problems, including secu-
rity analysis [13], bug checking [26], hardware synthesis [39],
and the analysis of multi-threaded programs [30]. The ef-
fectiveness and eﬃciency of such techniques depend heavily
on the precision of the pointer information provided.
Recent researches have focused on improving the precision
of points-to analysis through ﬂow-sensitivity . Compared to
ﬂow-insensitive approaches, ﬂow-sensitive points-to analyses
respect the execution order of program statements and com-
pute diﬀerent points-to graphs at diﬀerent program points.
Flow-sensitive points-to analysis has been shown to be ben-
eﬁcial for the above important problems. However, tradi-
tionally ﬂow-sensitive analysis [21], based on the iterative
data-ﬂow analysis framework, is too costly to be applied.
It is not scalable because of the high cost of conservatively
propagating and computing large amounts of pointer infor-
mation along the control ﬂow graph (CFG) of a program.
Recent research eﬀorts on ﬂow-sensitive points-to analy-
sis [18, 19, 37] hence have emphasized in avoiding the prop-
agation and computation of unnecessary pointer informa-
tion to improve performance. One of the key insights is to
employ the static single assignment (SSA) [10] representa-
tion, which enables sparse analysis and propagates pointer
information from the deﬁnition of a variable directly to its
corresponding uses (i.e., following the def-use chain), thus
avoiding over-conservatively propagation of pointer informa-
tion. Based on this observation, previous work has success-
fully sped up ﬂow-sensitive points-to analysis by more than
100X [18, 19, 37]. However, even with this improvement,
ﬂow-sensitive points-to analysis can still be much slower
compared to its ﬂow-insensitive counterpart [19]. We evalu-
ated the state-of-the-art ﬂow-sensitive points-to analysis [18]
in our experiments: for the three benchmarks that it can
run to completion, it is on average 7 ×slower than a ﬂow-
insensitive one.
In this paper, we introduce a novel method for ﬂow-sensitive
points-to analysis based on value ﬂow. Our approach is
intuitive, easy to implement and very eﬃcient. The im-
plementation is around 2000 lines of code and it is much
more eﬃcient than existing ﬂow-sensitive points-to analy-
ses. The runtime is comparable with the state-of-the-art
ﬂow-insensitive points-to analysis algorithm [16].
We achieve the large performance improvement by sim-plifying ﬂow-sensitive points-to analysis to a general graph
reachability problem in a value ﬂow graph. The value ﬂow
graph (VFG) monitors how memory objects ﬂowto pointer
variables. Variable ais said to ﬂowto variable bifais
assigned to bdirectly (via assign statements b = a ) or in-
directly (via pointer dereferences), represented as an edge
a→bin the graph. Both direct and indirect ﬂows are rep-
resented in the graph. In the VFG, for each pointer variable,
its points-to set is the set of memory objects that can reach
it. Similarly, the set of nodes that are reachable from a
memory object node is the set of pointers that can point to
it, denoted as the pointed-to-by set of the memory object.
Property 1.Variable acan ﬂow to variable bindirectly
via pointer dereferences, only if ais stored to a memory
object ﬁrst and bis loaded from the same memory object
afterwards.
Property 1 highlights the key observation of our approach.
Based on this property, we can build the value ﬂow graph
with indirect ﬂows eﬃciently by computing and examining
the pointed-to-by set for each memory object: a stored value
can ﬂow to a loaded value only if both targets point to
the same memory object, i.e., both targets are from the
same pointed-to-by set of a memory object. Note that the
pointed-to-by information for memory objects is also very
useful for many applications, such as escape analysis and
information ﬂow analysis. With the value ﬂow graph repre-
sentation, we avoid propagating large points-to information
along the CFG node or def-use chains as in most existing
ﬂow-sensitive points-to analyses and signiﬁcantly improve
the performance.
Our analysis is ﬂow sensitive and so is the value ﬂow
graph. Diﬀerent deﬁnitions of the same variable in the orig-
inal program are represented as distinct nodes in the graph
(as in SSA). The execution order of statements is also re-
spected when computing direct and indirect value ﬂows.
We have developed an eﬃcient value-ﬂow based ﬂow sen-
sitive points-to analysis algorithm and implemented it in
LLVM [27]. Experimental results against several large appli-
cations, including the OpenSolarisTMOperating system and
Networking (ON) consolidation with over 8 millions of lines
of code (LOC), show that the analysis is as precise as ex-
isting ﬂow-sensitive analyses for the benchmarks we stud-
ied, and that it is signiﬁcantly more eﬃcient than previous
work [18]: the runtime is comparable with the state-of-the-
art ﬂow-insensitive points-to analysis. To summarize, our
contributions are as follows:
•We propose a novel method for ﬂow-sensitive points-to
analysis based on value ﬂow. Our approach not only
computes the standard points-to information, it also
computes the pointed-to-by information for each mem-
ory object. In this work, we focus on ﬂow-sensitivity
only and we do not distinguish diﬀerent calling con-
texts at diﬀerent call sites (i.e., it is context-insensitive).
However, the proposed method can be naturally ex-
tended to be context-sensitive.
•We highlight the major challenges in our approach
and develop an eﬃcient algorithm to build the ﬂow-
sensitive value ﬂow graph, with both direct and indi-
rect value ﬂows of a program. The algorithm can be
easily implemented and adopted in modern compilers.The value ﬂow graph built by our analysis can be used
in many value-ﬂow based applications, including com-
piler optimizations [4], error detection [7] and software
validation [11].
•We implement our algorithm in LLVM and demon-
strate that it is signiﬁcantly more eﬃcient than previ-
ous approaches. The performance is comparable with
the state-of-the-art ﬂow-insensitive points-to analysis
algorithm [16].
The rest of the paper is organized as follows: Section 2
reviews related work. Section 3 introduces ﬂow-sensitive
pointer analysis in general and explains how it is optimized
in SSA. We describe our proposed approach in Section 4
and highlight the major challenges. Section 5 introduces an
eﬃcient implementation in detail. We evaluate our imple-
mentation using several large applications in Section 6 and
Section 7 concludes this paper.
2. RELATEDWORK
Points-to analysis is a fundamental static analysis that has
been studied extensively in the past [33, 1, 5, 12, 15]. Most
existing work focuses on improving the precision of points-
to analysis by being context-sensitive [6, 28, 40, 24, 35, 31],
while ﬂow-sensitivity was previous considered not to be as
important [22]. Its importance is only recognized recently
and great progress has been made, including [18, 19, 37, 25]
and some references therein.
In [22], Hind and Pioli formalized ﬂow-sensitive points-to
analysis using a classic iterative dataﬂow analysis frame-
work. They eliminated unnecessary propagation and com-
putation of pointer information by using a sparse evaluation
graph [8], a graph derived from the CFG with only nodes
manipulating pointer information. With this optimization,
they were able to scale ﬂow-sensitive points-to analysis to
applications with tens of thousands of LOC. The idea of
using a sparse graph is also adopted and applied in [18].
Goyal [14] optimized the formulation of Hind and Pioli us-
ing a ﬁne-grained work-list. The optimized formulation runs
in asymptotically cubic time and cubic space in the worst
case. A similar algorithm with the same complexity is de-
signed and implemented by Staiger-St ¨ohr in [32]. In [25],
Lhot´ ak et al. applied an eﬀective tradeoﬀ that focuses ﬂow
sensitivity only on pointers with strong updates. The tech-
nique is eﬃcient like ﬂow-insensitive analysis, and almost as
precise as a fully ﬂow-sensitive analysis.
A number of papers [5, 20, 34, 18, 19, 37] try to optimize
ﬂow-sensitive points-to analysis by employing the SSA repre-
sentation, which enables eﬃcient sparse analysis and avoids
unnecessary propagation of pointer information along the
CFG. Hasti and Horwitz [20] propose a scheme that ﬁrstly
uses a ﬂow-insensitive analysis to gather pointer informa-
tion, then the program is transformed into SSA with the
provided pointer information and fed back into the analysis
to improve precision. This process can be iteratively applied
until convergence. In [5] and [34], the authors implement a
similar idea to dynamically transform the program into SSA
during the course of the ﬂow-sensitive pointer analysis. How-
ever, it was in 2009 that Hardekopf and Calvin [18] success-
fully applied ﬂow-sensitive points-to analysis to large bench-
marks with hundreds of thousands of LOC for the ﬁrst time.
They made the observation that many program variables aremain() {
1 char A[ . . .], B[. . .];
2 char *a, *b, **t1, **t2;
3 t1=&a;
4 t2=&b;
5 a=&A;
6 b=&B;
7 if ( . . .)
8 *a=’A’;
9 else {
10 swap(t1, t2);
11 *a=’B’;
12 }
13 *a = ’?’;
}
void swap (void *p, void *q) {
14 void tmp = *p;
15 *p = *q;
16 *q = tmp;
}
(a) An exampleA = alloc_A;
B = alloc_B;
t1 = alloc_a;
t2 = alloc_b;
store t1, A;
store t2, B;
... 
bb1bb0
a1 = load t1;
store a1,'A';bb2
swap(t1, t2);
a2 = load t1;
store a2,'B';void main() 
s1 = load p;
s2 = load q;
store p, s2;
store q, s1;void swap(void *p, void *q)
bb4a3 = load t1;
store a3,'?';bb3
(b) The SSA representationpts(t1), pts(p) {alloca}
pts(t2), pts(q) {allocb}
pts(a1) {allocA, alloc B}
pts(a2) {allocA, alloc B}
pts(a3) {allocA, alloc B}
pts(s1) {allocA, alloc B}
pts(s2) {allocA, alloc B}
(c) The ﬂow-insensitive points-to set
pts(t1), pts(p) {alloca}
pts(t2), pts(q) {allocb}
pts(a1) {allocA}
pts(a2) {allocB}
pts(a3) {allocA, alloc B}
pts(s1) {allocA}
pts(s2) {allocB}
(d) The ﬂow-sensitive points-to set
Figure 1: An example.
never referenced by pointers, and thus can be represented in
SSA without any pointer information. Hence sparse analysis
can be applied to these SSA variables, and the sparse evalu-
ation graph can be largely reduced by removing nodes with
only SSA pointer variables. This optimization can greatly
improve the scalability and performance of ﬂow-sensitive
points-to analysis. Later in his thesis [19], Hardekopf pro-
posed a more eﬃcient algorithm which enables full sparse
analysis by using an auxiliary ﬂow-insensitive analysis to
represent all program variables in SSA [9]. This approach
is further extended in [37], where the authors partition the
program variables into diﬀerent points-to levels using a ﬂow-
insensitive analysis. Pointer information is enforced to ﬂow
uni-directionally from the higher level to the lower level.
The analysis is then eﬃciently implemented by processing
variables level by level, from the highest to the lowest where
the analyzed results of higher level variables can be used
in building the SSA representation of variables in the lower
level. This level-by-level idea is also adopted in [23, 38, 19].
Our approach diﬀers from all these in that we enable eﬃcient
sparse analysis by building a ﬂow-sensitive value ﬂow graph,
and we avoid propagation of pointer information by making
use of the pointed-to-by information of memory objects, in-
stead of relying on the points-to information of pointers.
Optimizations that can be applied, but not restricted to
ﬂow-sensitive points-to analysis include [2, 40, 23, 13]. The
authors in [2] and [40] propose an eﬃcient representation of
points-to relation using Binary Decision Diagrams (BDDs).
Kahlon [23] bootstraps the more precise and costly ﬂow-
sensitive pointer analysis by using cheaper and less precise
analyses to partition programs into small sections that can
be analyzed independently. Fink et al [13] use a technique
that applies more precise pointer analyses only to portions
of the program which requires that level of precision. These
optimizations can be applied in our approach to further im-
prove performance.
Value ﬂow analysis computes which program variable holds
which value of interest and it has been studied in many dif-
ferent areas, including compiler optimizations [4, 3], error
detection [7], software validation [11], and symbolic eval-
uation [29]. Existing value ﬂow analyses rely on externalpoints-to analysis to handle memory dependencies with aliases.
In this paper, we present a new ﬂow-sensitive points-to anal-
ysis using value ﬂow. Our results can be used in existing
value ﬂow analyses to make them more eﬀective.
3. BACKGROUND
In this section, we give a brief introduction to the SSA
representation as our implementation is based on SSA and it
motivates most of recent researches on ﬂow-sensitive points-
to analysis [18, 19, 37]. Note that our method itself does
not rely on SSA. We also introduce ﬂow-sensitive points-to
analysis in general using the example in Figure 1(a).
In Figure 1(a), initially we have t1points to a,t2points to
b,apoints to array A, andbpoints to array B. The function
swap takes two input pointers and swaps the values they
point to. As a result, after swapping the two pointers t1
andt2at line 10, variable apoints to array Bat line 11.
3.1 The SSArepresentation
The CFG and the SSA representation of the example is
given in Figure 1(b). In SSA, all variables are deﬁned ex-
actly once and diﬀerent deﬁnitions for the same variable in
the original program are represented as distinct variables.
If a variable is deﬁned along two diﬀerent paths then at
the join point in the CFG where the two paths merge, a
φinstruction is introduced to represent the combination of
these deﬁnitions. SSA enables sparse analysis and its bene-
ﬁts are widely acknowledged: dataﬂow analysis can be more
eﬃciently computed by following the def-use chain of each
variable, avoiding propagation of unnecessary information
in the CFG.
As variables can be deﬁned indirectly through pointers
(e.g., in Figure 1(a), *p=*q at line 15), pointer information
is required to build the SSA representation for a given pro-
gram. This is also the major challenge of employing SSA
for points-to analysis. To overcome this issue, in practice,
modern compilers such as GCC and LLVM [27] use partial
SSAform, where only these variables whose addresses are
never taken are represented in SSA. Without loss of gener-
ality, variables which might be referenced via pointers (e.g.,
aandbin the example) are memory objects represented byallocinstructions and they are accessed via loadandstore
instructions. Each load instruction (e.g., a1=load,t1 inbb1)
deﬁnes a distinct variable.
As in Figure 1, there are four memory objects representing
the four address-taken variables a,b,AandBin the original
program. All memory objects are accessed via load and store
instructions. References to address-taken variable aat line
8 and 11 in Figure 1(a) are represented as two distinct load
instructions in bb1andbb2(Figure 1(b)), respectively.
3.2 Flow-Sensitive Points-to Analysis
Traditional ﬂow-sensitive points-to analysis [21] is based
on the classic iterative dataﬂow analysis framework. Con-
ceptually, the analysis is applied to every node in the CFG
of a program. Each CFG node kis associated with a transfer
function that computes its outgoing points-to graph OUT k
from its input points-to graph INk. The transfer function
is summarized as:
INk=[
x∈pred(k)OUT x
OUT k=GEN k∪(INk−KILL k)(1)
where GEN kandKILL krepresent the set of pointer infor-
mation generated by the node and killed by the node, re-
spectively. The analysis iteratively computes the above two
functions for all nodes in the CFG until convergence. As
required by the iterative dataﬂow analysis framework, a lat-
tice of points-to graphs is deﬁned by introducing a partial
order on the points-to graphs (according to set relations).
The meet and join operators of points-to graphs are thus
deﬁned based on set union operations.
Compared to the ﬂow-insensitive approach, the precision
of points-to analysis is greatly improved in two ways:
•Points-to information generated in node kis consid-
ered in node ponly if pis reachable from kin the
CFG. Thus the execution order of program statements
is respected.
•Unnecessary points-to information is removed by the
KILL set. When we are certain that the left-hand side
of an assignment deﬁnitely points to a single memory
location v, the points-to relations v→xprior to the
assignment can be replaced with a new set of points-
to relations. This is referred to as strong update . Ac-
cordingly, if the left-hand side cannot be determined
to point to a single memory location, the conservative
weak update rule is applied. The KILL set is set to ∅
and all existing points-to relations are preserved.
Figure 1(c) and Figure 1(d) compare the points-to sets
for all pointer variables when ﬂow-sensitivity is or not con-
sidered. As shown in the graph, ﬂow-sensitive analysis is
more precise. With ﬂow-sensitivity, we can conclude that a1
only points to allocA, while a ﬂow-insensitive analysis will
assume it can point to both allocAandallocB.
Since it is in general not possible to determine where vari-
ables are deﬁned or used without pointer information, the
analysis must conservatively propagate the pointer informa-
tion generated at each node to all its successors. As a result,
large points-to sets are involved in the two ﬂow functions in
Equation 1, making the analysis both time-consuming and
memory-consuming. Many research eﬀorts hence have fo-
cused on reducing the propagation and computation of un-
necessary pointer information. One of the most eﬀectiveways [18, 19, 37] is to employ the SSA representation as
discussed in detail in Section 2.
4. THEMETHODOLOGY
In this work, we propose a new method for ﬂow-sensitive
points-to analysis. The method is sound and as precise as
the traditional ﬂow-sensitive points-to analysis [21] intro-
duced above. Our approach enables eﬃcient sparse analysis
by computing the def-use information for all pointer vari-
ables, summarized as a value ﬂow graph (VFG). Nodes in
the VFG represent memory objects and pointer variables,
and edges represent value ﬂows between them. For ﬂow-
sensitive points-to analysis, the graph also needs to be ﬂow-
sensitive: diﬀerent deﬁnitions to the same variable in the
original program are represented as distinct nodes in the
graph, and a deﬁnition can ﬂow to a use only if the deﬁni-
tion can reach the use in the CFG without being killed by
another deﬁnition.
Flow-sensitive points-to analysis is then formulated as a
general graph reachability problem in the VFG: the points-
to set of each pointer variable is the set of memory objects
that can reach it, and the pointed-to-by set of each memory
object is the set of nodes that are reachable from the memory
object.
4.1 Value FlowGraph
Instruction Type Value ﬂow
a = alloc oBaseDirectalloco→a
a = b Assign b→a
store x, b StoreIndirect∃alloco|alloco→x∧
a = load y Load alloco→y=⇒b→a
Table 1: Value ﬂow rules.
Table 1 summarizes the value ﬂow rules, where allocode-
notes a memory object. In our representation (Section 3.1),
memory objects are accessed via load and store instructions,
and they are represented in the VFG as source nodes with-
out incoming edges.
Following previous work [1], it suﬃces to analyze the four
types of instructions listed in the table. Nested pointer
dereferences are eliminated by introducing auxiliary vari-
ables. Data aggregates such as arrays and structs are re-
garded as monolithic objects, heap objects are modeled by
representing the allocation site pby an instruction of the
formx=alloc p. Branches are uninterpreted and treated as
non-deterministic. Call instructions are translated to a set of
base or assign instructions between function arguments and
parameters as explained in Section 5.2. Function pointers
are analyzed by regarding functions as a special object.
Figure 2 shows the VFG for the example in Figure 1.
Each store or load instruction is represented as a node in the
VFG (annotated with the instruction) if it stores or loads a
pointer. For a store node, there is a direct ﬂow edge from the
stored pointer to it, e.g., A→(store t1, A ) in Figure 2. Indi-
rect ﬂows are those from store to load nodes as highlighted
in dashed lines. According to Table 1, we have ( store t1, A )
→(s1 = load p ) as both t1andprefer to the same memory
object alloca.
The indirect ﬂow rule in Table 1 highlights our observa-
tion (Property 1). It suggests that we can build the VFG
eﬃciently by examining the pointed-to-by set for each mem-t1alloc_Aalloc_B alloc_a
pstore t1, A
store q, s1store t2, B
store p, s2AB t2alloc_b
q
a1 = load t1
s1 =load p s2 = load q 
a2 = load t1a3 = load t1
Figure 2: VFG for the example in Figure 1. Memory
objects are represented as ovals and pointer variables as
circles. Solid lines represent direct ﬂows and indirect
value ﬂows are highlighted in dashed lines.
ory object: a store node can ﬂow to a load node only if both
targets refer to the same memory object, i.e., both targets
are from the same pointed-to-by set of a memory object.
The pointed-to-by set of a memory object can be computed
with standard graphical traversal algorithms on the VFG,
then the VFG is updated by computing indirect value ﬂows
of the memory object, i.e., introducing indirect ﬂows be-
tween those stores and loads that refer to it. In the end,
the analysis terminates at a ﬁxed point where the VFG is
complete and no more direct or indirect value ﬂows can be
introduced. The points-to set for each pointer variable, and
the pointed-to-by set for each memory object, are thus com-
puted.
4.2 Flow-sensitivity
For ﬂow-sensitive analysis, the VFG needs to be ﬂow-
sensitive: we need to respect the execution order of pro-
gram instructions in computing value ﬂows. Direct value
ﬂows via base and assign instructions can be represented in
SSA with common practices ﬁrst then trivially processed.
Indirect value ﬂows from store to load instructions cannot
be directly represented in SSA. We not only need to check
whether they refer to the same memory object or not, also
we need to check whether the store can reach the load in the
CFG or not. This becomes even more challenging with the
strong update rule, where a store instruction can be killed
by another store instruction and the killed store cannot ﬂow
further to a load. The key challenge is discussed in Sec-
tion 4.3.
In our method, the strong update rule is deﬁned as:
Definition 1.For scalar memory object allocowith a
single memory location, the instruction (store X, ...) will kill
all previous store instructions to the object if the referring
pointer variable Xonly points to alloco.
For the example in Figure 1(b), the instruction (store p, s2)
inbb3will kill all previous store instructions to alloca, e.g.,
(store t1, A) inbb0, asponly points to the scalar object
alloca.
Hence ﬂow-sensitivity can be achieved in computing indi-
rect ﬂows by ensuring that a store can ﬂow to a load only
if it can reach the load in the CFG without being killed.
Compared to existing points-to analysis algorithms, we do
not rely on the points-to information of pointer variables to
handle indirect references with pointers. As a result, our
approach does not need to propagate points-to informationalong the CFG or def-use chains, where large points-to set
often need to be propagated and expensive set operations
are involved. This optimization is very eﬀective in improv-
ing the performance as shown in our experimental results in
Section 6.
4.3 The Challenge
The challenge lies in how to precisely and eﬃciently com-
pute indirect ﬂows of a memory object. Since the VFG
is dynamically updated during the analysis, the computed
pointed-to-by information and points-to information may
not be complete. As a result, indirect value ﬂows may be
incorrectly computed based on the incomplete information,
leading to both ineﬃciency and imprecision.
Imprecision can happen due to missed strong updates.
During the analysis, the VFG is updated by introducing in-
direct value ﬂows from store to load instructions that refer
to a same memory object. With incomplete pointed-to-by
information of the memory object, some store instructions
may not be considered in computing its indirect ﬂows since
we do not know yet they actually refer to it. If these missed
store instructions happen to be strong updates, unnecessary
value ﬂows will be introduced into the VFG, making the
analysis imprecise. For the example in Figure 1, if we are
not aware that palso refers to alloca, the store instruc-
tion (store p, s2 ) in function swapwill not be considered in
computing the indirect ﬂows of alloca. As a result, we will
falsely conclude that ( store t1, A ) inbb0can ﬂow to ( a2 =
load t1 ) inbb2since both refer to the same pointer variable,
although it will be killed by the call to function swap.
On the other hand, incompleteness can happen due to
false strong updates. Some strong updates may be incor-
rectly applied where weak updates should be used instead.
With incomplete points-to information, we may falsely as-
sume that a store only refers to one memory object and
kills all other stores to that object, resulting in incomplete
results.
While the incompleteness problem can be handled by up-
dating and recomputing the indirect ﬂows of the memory
object a store refers to when it is no longer a strong up-
date (when it can also refer to another memory object), the
imprecision problem is much more diﬃcult to address. The
solution as employed in most previous works is to conserva-
tively assume that a store instruction can kill all other stores
(no matter which objects they refer to) when it refers to a
pointer with unknown points-to information. However, this
may result in recomputing the indirect ﬂows for all memory
objects when the points-to set of the referring pointer gets
updated, which could be very ineﬃcient. We need to avoid
unnecessary and frequent re-computation of indirect ﬂows
in order to eﬃciently solve the problem.
4.4 EscapeOrder
In this section, we introduce an eﬃcient optimization tech-
nique to avoid unnecessary re-computation of indirect ﬂows.
The idea is to compute the indirect ﬂows of a memory object
only if its pointed-to-by set is complete. This is achieved by
following an escape order in computing indirect ﬂows. We
prove that precision can be guaranteed if the escape order is
enforced. Furthermore, we show that in practice there typi-
cally exists an escape order for scalar memory objects with
strong updates and the analysis is precise if their indirect
ﬂows are computed in escape order.We introduce a partial order relation, the escape order ,
between memory objects.
Definition 2.For two objects allocAandallocB,al-
locBescapes to allocAif there exists an instruction (store
X, Y) such that allocA→XandallocB→Y, denoted as
allocAallocB.
The escape order states whether an memory object can es-
cape to another or not. In another word, it indicates whether
we could access a memory object by dereferencing another
memory object or not. Since memory objects are accessed
via load and store instructions, a memory object can escape
to another only via store instructions. For our example in
Figure 1, we have {alloca, alloc b}{allocA,alloc B}. By
deﬁnition, the escape order is transitive and antisymmet-
ric. Two memory objects are said to be in a cyclic escaping
relation if they escape to each other.
Observation 1.Scalar memory objects with strong up-
dates often are not in a cyclic escaping relation.
The above observation is often enforced by static type check-
ing rules. In programming languages such as C, one can
write arbitrary type castings that may violate the property.
However, we have studied several very large open source ap-
plications, including OpenSolaris with more than 8M LOC,
and have not found a violation of this observation.
Theorem 1.We can guarantee precision if the indirect
ﬂows for all scalar memory objects with strong updates are
computed in escape order.
Proof. Imprecision can only occur if some strong up-
dates are not considered in computing the indirect ﬂows of
a memory object. For scalar memory object allocA, letSbe
the set of objects such that {∀alloco∈ S|allocoallocA}.
The indirect ﬂows of allocAare computed only if the in-
direct ﬂows for all objects in Sare computed. Thus the
pointed-to-by set for allocAis completely computed since
allocAcan be referenced only via direct ﬂows and indirect
ﬂows of memory objects in S. Hence all strong updates will
be considered in computing the indirect ﬂows of allocA, and
the analysis is precise.
In our implementation, the escape order is computed ac-
cording to existing pointed-to-by and points-to information
during the analysis. As discussed in Section 4.3, the com-
puted order may not be the exact order due to the incom-
plete pointer information. If we are not certain whether the
exact escape order can be enforced or not, we can always
guarantee precision by conservatively assuming that a store
referring to a pointer with unknown points-to set will kill all
other store instructions. However, this turns to be unneces-
sary for the benchmarks we studied.
5. ANIMPLEMENTATION
In this section, we present an algorithm to build the ﬂow-
sensitive value ﬂow graph very eﬃciently. Our algorithm is
able to detect the situations when imprecision might happen,
i.e., when indirect ﬂows of scalar memory objects with strong
updates are not computed in escaping order. For all the
benchmarks we have evaluated (Table 3), no such situation
is detected.VFG Value ﬂow graph <N, E>
allocoMemory Objectpted(alloco)
esp(alloco)
P Pointer node pts(P)
Table 2: Notations used in the algorithm.
Table 2 highlights the notations used throughout our al-
gorithm. The value ﬂow graph VFG includes nodes for both
memory objects and pointer variables, with memory objects
being source nodes without incoming edges. For a memory
object alloco, we use pted(alloco) and esp(alloco) to de-
note the set of pointers point to it and the set of memory
objects it escapes to, respectively. The set pts(P) represents
the set of memory objects pointed to by pointer P.
In this section, we ﬁrst show how to compute the pointed-
to-by set of a memory object by traversing the VFG and how
to eﬃciently compute indirect ﬂows using a sparse reacha-
bility analysis. Then in Section 5.3, we explain how the
escape order is enforced and how the VFG is updated by
introducing indirect ﬂows of memory objects.
5.1 ComputePointed-to-by Set
Algorithm 1 Traverse the value ﬂow graph
1:procedure ComputePtedSet (alloco)
2: LetPbe the set of nodes reachable from allocoin VFG
3:foreach node PinPdo
4: pted(alloco) :=pted(alloco)∪ {P}
5: pts(P) :=pts(P)∪ {alloco}
6:end for
7:end procedure
8:procedure ComputeEspSet (alloco)
9:foreach node Pinpted(alloco)do
10: ifPa store instruction then
11: LetP′be the pointer Prefers to
12: ifptsTo (P′) =∅then
13: esp(alloco) :={All memory objects }
14: else
15: esp(alloco) :=esp(alloco)∪pts(P′)
16: end if
17: end if
18: end for
19:end procedure
As shown in Algorithm 1, the pointed-to-by set of object
allocois computed by traversing the VFG from its repre-
sentative source node. During the traversal, each visited
pointer node Pis added to pted(alloco), and its points-to
setpts(P) is updated by including the object alloco.
The set of objects allocoescapes to, esp(alloco), is com-
puted in ComputeEspSet . When a pointer Pinpted(alloco)
represents a store instruction, allocoescapes to the pointer
Prefers to. The set esp(alloco) is updated accordingly
(lines 10 - 17). Note that when the set of memory objects
thatPrefers to is not computed (line 12), esp(alloco) is set
to include all memory objects, suggesting that its indirect
ﬂows is not ready to be computed.
5.2 ComputeIndirectFlows
The procedure ComputeIndirectFlow in Algorithm 2
outlines how to compute indirect ﬂows of a memory object.
It is also the key of our approach. The indirect ﬂows of a
memory object is computed by examining the set of storeand load instructions that refer to it, and checking whether
a store can reach a load or not.
The set of store and load instructions referring to a same
memory object can be trivially computed based on its pointed-
to-by set. To check whether a store can ﬂow to a load in-
struction or not, the procedure PreprocessGlobalFlow
is ﬁrstly invoked to handle inter-procedural indirect ﬂows.
Then a sparse reachability analysis is applied to every func-
tion where the object is referenced to compute its local ﬂows.
Algorithm 2 Compute Indirect Flows
1:procedure ComputeIndirectFlow (alloco)
2: PreprocessGlobalFlow (alloco)
3:foreach function fwhere allocois referenced do
4: ComputeLocalFlow (f, alloc o)
5:end for
6:end procedure
7:procedure PreprocessGlobalFlow (alloco)
8:foreach inter-procedural ﬂow arg→paraofallocodo
9: Letcbe the callsite
10: Letfbe the callee function
11: Introducing the following four instructions

ref.arg = load arg before callsite c
store para, ref.arg at the entry of function f
ref.para = load para at the exit of function f
store arg, ref.para after callsite c
12: end for
13:end procedure
14:procedure ComputeLocalFlow (f, alloc o)
15: LetSbe the set of store instructions in frefer to alloco
16: LetIDF((S) be the iterated dominance frontier of S
17: Build the simpliﬁed CFG Goffas follows
G:={S ∪IDF(S)}
add edge S1→S2toGif
S2is the dominance frontier of S1or
S1is the most immediate dominator of S2inG
18: Solve the following dataﬂow equation in G
INk=[
x∈pred(k)OUT x
OUT k=(
GEN k strong update
GEN k∪INkotherwise(2)
where GEN kis the store instruction in k
19: LetLbe the set of load instructions in frefer to alloco
20: foreach load instruction LinLdo
21: LetSbe the most immediate dominator of LinG
22: OUT Sis the set of store instructions that can reach L
23: end for
24:end procedure
5.2.1 Inter-proceduralIndirectFlows
As shown in PreprocessGlobalFlow , inter-procedural
indirect ﬂows are modeled as value ﬂows between auxiliary
variables introduced for objects passed into a function by
reference. Global variables are handled by creating a local
copy at each function where it is used then processed in the
same fashion. The idea is to translate passing by reference
intopassing by value . For every inter-procedural value ﬂow
arg→para, we introduce two variables ref.arg andref.para
to represent dereferences of argandpara, respectively. The
value ﬂows between ref.arg andref.para are enabled by the
four instructions introduced as highlighted at line 11. As a
result, inter-procedural indirect ﬂows of allocoare modeled
as value ﬂows between the introduced variables.The value ﬂow edge (ref.arg=load arg) →(store para, ref.arg)
models all indirect ﬂows of allocofrom callsite cinto func-
tionf. A store instruction Sin the caller function can
ﬂow to a load Linfif 1) Scan reach the callsite, i.e.,
S→(ref.arg=load arg ), and 2) Lis reachable from the en-
try of f, i.e., (store para, ref.arg) →L. Similarly, indirect
ﬂows returning from the callee function fto its caller func-
tion via dereferences of allocoare enabled by the ﬂow edge
(ref.para=load para )→(store arg, ref.para) .
A = alloc_A;
B = alloc_B;
t1 = alloc_a;
t2 = alloc_b;
store t1, A;
store t2, B;
... 
bb1bb0
a1 = load t1;
store a1,'A';bb2
swap(t1, t2);
a2 = load t1;
store a2,'B';void main() 
s1 = load p;
s2 = load q;
store p, s2;
store q, s1;void swap(void *p, void *q)
bb4a3 = load t1;
store a3,'?';bb3ref.t1 = load t1
store t1, ref.p
store p, ref.t1
ref.p = load p ref.t2 = load t2
store t2, ref.q
store q, ref.t2
ref.q = load q 
(a) CFGalloc_Aalloc_B
store t1, A; store t2, B;
store p, s2AB
store p, ref.t1
store q, s1
store t2, ref.qstore q, ref.t2
store t1, ref.p;swap(p,q)ref.t1 = load t1ref.t2=load t2
ref.q = load q s1 = load p s2 = load p 
ref.p = load p a1 = load t1
a3 = load t1a2 = load t1
(b) VFG
Figure 3: CFG and VFG of the example in Figure 1
after introducing auxiliary variables for inter-procedur al
indirect value ﬂows.
In our example (Figure 1), object allocaandallocbare
passed into function swapat the callsite in bb2via pointer
t1andt2, respectively. There are two inter-procedural value
ﬂow edges: t1→p, and t2→q. As a result, eight instruc-
tions (four for each) are introduced as highlighted in Fig-
ure 3(a). The corresponding VFG is given in Figure 3(b).
For simplicity, only the value ﬂows of allocAandallocB
are presented. The VFG in function swapis highlighted in
the box. It is connected with the VFG in the caller function
mainvia the introduced auxiliary variables.
5.2.2 LocalIndirectFlows
Local indirect ﬂows of object allocoare computed by ap-
plying a sparse reachability analysis ( ComputeLocalFlow )
in every function where it is referenced. It can be proved
that a store can reach a load in the CFG only if the load
is dominated by the store or one of its iterated dominance
frontiers. Hence the analysis ﬁrst builds a sparse graph Gin-
cluding only store instructions referring to allocoand their
iterated dominance frontiers (lines 15 - 17). The dataﬂow
equation 2 is then eﬃciently solved in the sparse graph to
compute the reachable store set (i.e., the set of store in-
structions that can reach an instruction) for G(line 18).
The reachable store set of a load instruction is computed by
ﬁnding its most immediate dominator in G(lines 19 - 23).
Since the simpliﬁed graph Gis very sparse and the reachable
store set that we try to compute is in general very small with
only local store instructions referring to alloco, the analysis
is very eﬃcient.
Figure 4(a) gives the simpliﬁed CFG Gwhen computingstore t1, Abb0
bb2void main()
bb3store t1, ref.p
(a) Simpliﬁed CFGstore t1, A; bb0
bb2void main()
bb3bb1store t1, ref.p
a1 = load t1
a2 = load t1
a3 = load t1
(b) Indirect ﬂows
Figure 4: Compute local indirect ﬂows of allocain func-
tionmain.
the local indirect ﬂows of allocain function main. There
are two store instructions referring to alloco,(store t1, A)
inbb0and(store t1, ref.p) inbb2. The later is introduced
inPreprocessGlobalFlow for inter-procedural indirect
ﬂows of alloco. The two store instructions and their iterated
dominance frontier bb3are included in G.
The local indirect ﬂows of allocaare given in Figure 4(b).
As the only dominator in G, the store in bb0(store t1, A )
ﬂows to the load ( a1=load t1 ) inbb1. The store instruction
(store t1, ref.p) inbb2kills all its previous stores and only it
can reach the load (a2=load t1) in the same block. The most
immediate dominator of (a3 = load t1) in the simpliﬁed CFG
isbb3. Hence its reachable store set is OUT bb3, including
both store instructions in bb0andbb2.
5.3 PutItTogether
Algorithm 3 presents the top level algorithm. The VFG is
initialized with direct value ﬂows only, then is dynamically
updated by introducing indirect ﬂows until a ﬁxed point.
To follow the escape order in computing indirect ﬂows, we
maintain three mutually exclusive lists for all memory ob-
jects: processedList for those whose indirect ﬂows already
computed, updateList for those whose pointed-to-by set and
indirect ﬂows are to be computed, and waitList for those
whose indirect ﬂows are not ready to be computed. Initially,
all memory objects are in updateList and the other two lists
are set to ∅.
In lines 4 - 6, the pointed-to-by set for each memory ob-
ject, and the points-to set for each pointer variable are com-
puted in the function call to ComputePtedSet . Lines 7 -
9 address the incompleteness problem and the set of objects
that an object escapes to is calculated in lines 10 - 12. The
indirect ﬂows of a memory object will not be computed if it
escapes to another object whose indirect ﬂows are not com-
puted yet. It will be put into waitList instead (lines 17 -
19). Otherwise, the procedure UpdateVFG is called at line
22 to compute its indirect ﬂows and update the VFG. Lines
25 - 30 handles the situation when no further updates can be
made (due to cyclic escaping relations). The indirect ﬂows
of all non-scalar memory objects will be computed, and the
VFG is updated accordingly. This guarantees termination if
Observation 1 holds. In case when it does not hold, we can
select to compute the indirect ﬂows of a scalar object. But
it never happens in our experiments.
InUpdateVFG , the VFG is updated by including indi-
rect ﬂows of alloco(line 37). As a result, the pointed-to-by
sets of those memory objects that ﬂow to the source of theAlgorithm 3 Flow-sensitive Points-to Analysis using Value
Flow Graph
processedList :=∅
waitList :=∅
updateList :={All memory objects }
1:procedure ComputePointsToVFG
2: Initialize V FG with direct value ﬂows only
3:while updateList /\e}atio\slash=∅ ∨waitList /\e}atio\slash=∅do
4: forevery object allocoinupdateList do
5: ComputePtedSet (alloco)
6: end for
7: forany pointer Pthat is no longer strong update do
8: Move pts(P) to updateList
9: end for
10: forevery object allocoinupdateList do
11: ComputeEspSet (alloco)
12: end for
13: updated :=false
14: toUpdateList :=∅
15: forevery object allocoinupdateList do
16: updateList :=updateList \ {alloco}
17: ifesp(alloco)∩{updateList ∪waitList } /\e}atio\slash=∅then
18: waitList :=waitList ∪ {alloco}
19: else
20: updated :=true
21: Move allocotoprocessedList
22: UpdateVFG (alloco,toUpdateList )
23: end if
24: end for
25: ifupdated =falsethen
26: forevery non-scalar object allocoinwaitList do
27: updateList :=updateList ∪ {alloco}
28: UpdateVFG (alloco,toUpdateList )
29: end for
30: end if
31: Move toUpdateList toupdateList
32: end while
33:end procedure
34:procedure UpdateVFG (alloco,toUpdateList )
35: ComputeIndirectFlow (alloco)
36: foreach indirect ﬂow S→Lofallocodo
37: ifS→L /∈VFGthen
38: AddS→Lto VFG
39: toUpdateList :=toUpdateList ∪pts(S)
40: end if
41: end for
42:end procedure
newly introduced indirect ﬂows need to be updated (line
38). Note that if escape order is enforced, no processed ob-
ject needs to be updated. In our experiments, scalar objects
with strong updates are never updated once their indirect
ﬂows are computed. Hence our algorithm is precise for the
benchmarks we studied. In the end, the algorithm termi-
nates when all memory objects are in processedList and no
more indirect ﬂows can be introduced.
For our example, we have {alloca, alloc b}{allocA,
allocB}. The indirect ﬂows of allocaandallocbare com-
puted ﬁrst and the VFG is updated as shown in Figure 3
(b). Then the pointed-to-by set of allocAandallocBare
updated. In the end, the points-to set is computed as in
Figure 1 (d).
6. EXPERIMENTALRESULTS
We implemented our value-ﬂow based ﬂow-sensitive points-
to analysis (VF-PA) in LLVM [27] and evaluated its eﬃ-
ciency using the six benchmarks in Table 3. The results
reported use the LLVM intermediate representation (bit-
code ﬁles) as the starting point. The runtime includes theIPA SS-PA VF-PA
Benchmark Time Mem Time Mem Time Mem
(min:sec) (min:sec) (min:sec)
sendmail 8.12.3 0:57 228 MB 2:15 292MB 1:09 881 MB
httpd 2.0.63 0:32 428 MB 8:24 487MB 0:18 655 MB
400.perlbench 0:40 637 MB - - 6:48 10 GB
403.gcc 7:31 2590 MB 22:15 1466 MB 3:05 8147 MB
MySQL 4.1.22 36:40 4003 MB - - 61:30 4525 MB
OpenSolaris ON b93 232:23 6672 MB - - 76:27 14 GB
Table 4: Performance: runtime and memory consumption for the insensitive analysis (IPA), the semi-sparse ﬂow-
sensitive points-to analysis (SS-PA), and our value-ﬂow bas ed ﬂow-sensitive analysis (VF-PA).
Initial VFG Final VFG
Benchmarks #Objs#Nodes #Edges #Nodes#Edges
Total Direct Indirect
sendmail 8.12.3 1418 54211 48988 154291 233723 138712 95011
httpd 2.0.63 3727 96221 80921 96677 82919 81231 1688
400.perlbench 2150 164122 137889 2092368 2681002 1864585 816417
403.gcc 5229 563528 516215 1506878 1845397 1369374 476023
MySQL 4.1.22 8324 263393 217865 482363 191856971 390728 191466243
OpenSolaris ON b93 5931 275135 241251 2590295 2633313 2171245 462068
Table 5: Statistics of the VFG at the beginning and end of the analysis .
BenchmarkNC-LOC (lines of code) Bitcode
C C++ Total ﬁles
sendmail 8.12.3 84.2K 0 84.2k 8.9MB
httpd 2.0.63 174.8K 0174.8k 9.1MB
400.perlbench 126.3K 0126.3K 11.9MB
403.gcc 236.3K 0236.3K 39.4MB
MySQLTM4.1.22 473.4K 413.3K 886.7K 69.0MB
OpenSolaris ON b93 8.5M 87K 8.6M 1.44GB
Table 3: Summary of the benchmark data.
time in loading the bitcode ﬁles to memory, building the
intermediate representation, as well as the time in perform-
ing our analysis. Several large applications in diﬀerent ar-
eas are selected in our evaluation: sendmail andhttpd are
two popular applications used in previous points-to analysis
work [37, 23]. 400.perlbench and403.gcc are two large bench-
marks from CPU2006. MySQL is a popular open source
database and OpenSolaris is a general-purpose operating sys-
tem. For each benchmark, we list its version or build num-
ber, the number of non-commented lines of C/C++ code
(NC-LOC) generated by the SLOCCount [36] tool, and the
size of the bitcode ﬁles generated by the LLVM frontend.
We compare our analysis with two diﬀerent points-to anal-
ysis algorithms: the semi-sparse ﬂow-sensitive (SS-PA) points-
to analysis [19] and the insensitive points-to analysis (IPA)
in LLVM. SS-PA is one of the latest ﬂow-sensitive points-to
analysis techniques. IPA is an Anderson-style analysis with
several recent optimization techniques [16, 17] implemented
and it is regarded as the state-of-the-art insensitive points-
to analysis implementation. SS-PA represents points-to sets
using BDDs, while in both VF-PA and IPA, pointer infor-
mation is represented using sparse bitmaps. Table 4 summa-
rizes the runtime and memory usage for the six benchmarks
on an AMD Opteron 2.9GHz processor with 16G of memory.
The implementation of SS-PA is downloaded from the
website of its developer. It cannot pass the three bench-
marks 400.perlbench ,MySQL , and OpenSolaris due to asser-
tion failure. For the other three benchmarks, our analysis is28X faster in httpd, 7X faster in 403.gcc and twice as fast in
sendmail .
As shown in the table, our approach also outperforms the
insensitive analysis (IPA) in httpd,403.gcc , andOpenSolaris .
The runtime is similar for both analyses in sendmail . The
biggest performance improvement is in OpenSolaris , where
we achieve more than three times speedup. The large per-
formance improvements come from the following three facts:
1) we do not propagate large points-to information in the
VFG, 2) ﬂow-sensitivity can be cheaply achieved by solving
the simple ﬂow equation 2 in the sparse graph, and 3) we
avoid frequent re-computation of indirect ﬂows by following
the escape order. For example, in 403.gcc , we have to com-
pute the indirect ﬂows of all non-scalar memory objects only
once (lines 23 - 28 in Algorithm 3). Note that when recom-
puting the indirect ﬂows of an object, only its local ﬂows in
those functions where the set of instructions dereferencing
it have changed need to be recomputed.
On the other hand, we observe some slowdowns in MySQL
and400.perlbench . The worst case is 400.perlbench , in which
we are almost an order of magnitude slower than IPA. The
reason is that there are many global variables in this bench-
mark. In our approach, these global variables are cloned in
every function where they are used when computing their
indirect ﬂows (Section 5.2.1). As a result, a large number of
local copies are introduced as shown in Table 5: the number
of nodes in the ﬁnal VFG is much larger than in the initial
VFG. A manual spot inspection suggests that most of those
copies are not necessary. Hence there is scope for further
optimizations of our approach.
The introduced auxiliary variables for inter-procedural in-
direct ﬂows is also one of the reasons why VF-PA consumes
more memory than IPA for all benchmarks. The other rea-
son is that we need to represent each store instruction as
a distinct node in the VFG for the sake of ﬂow-sensitivity.
Hence our approach consumes more memory although it is
more precise and the points-to set sizes are smaller. One
eﬀective way to optimize the memory footprint would be
to use BDDs to represent pointer information. As shownin the table, SS-PA consumes much less memory with the
BDD representation.
Table 5 compares the initial VFG with the ﬁnal VFG. For
each benchmark, we list the number of memory objects, as
well as the number of nodes and edges of the initial and
ﬁnal VFGs. OpenSolaris andsendmail are built into multiple
modules and for the two benchmarks, we show the largest
VFG in the table. The initial VFG has only direct ﬂow
edges. In the ﬁnal VFG, the number of both indirect and
direct ﬂow edges, as well as the total number of edges are
presented.
As shown in Table 5, the ﬁnal VFG is much larger than
the initial VFG. For 400.perlbench , there are 12 times more
nodes and almost 20 times more edges in the ﬁnal VFG.
Most of these extra nodes are introduced local copies of
global variables. The benchmark httpd has the smallest
number of nodes and edges in the ﬁnal VFG, and it can
be analyzed very eﬃciently as shown in Table 4. On the
other hand, the benchmark MySQL has the largest number
of indirect ﬂow edges due to its C++ code, and it takes a
long time for both IPA and VF-PA to analyze.
7. CONCLUSION ANDFUTUREWORK
In this paper, we presented a new method that applies
value ﬂow analysis to compute ﬂow-sensitive pointer infor-
mation. The method is intuitive and can be easily adopted
in modern compilers. We demonstrated the eﬃciency of our
approach by showing that the performance is comparable
with the state-of-the-art ﬂow-insensitive points-to analysis
implementation.
Our future work includes optimizing the memory con-
sumption of our approach by using BDDs and extending the
analysis to be context-sensitive. We are also looking into ap-
plying our analysis together with other value ﬂow analyses
to make them more eﬀective.
References
[1] L. O. Andersen. Program Analysis and Specialization for the
C Programming Language . PhD thesis, DIKU, University of
Copenhagen, Fall 1994.
[2] M. Berndl, O. Lhot´ ak, F. Qian, L. Hendren, and N. Uma-
nee. Points-to analysis using bdds. In Proceedings of the
ACM SIGPLAN 2003 conference on Programming language
design and implementation , PLDI ’03, pages 103–114, New
York, NY, USA, 2003. ACM.
[3] R. Bodik. Path-sensitive, value-ﬂow optimizations of pro-
grams. PhD thesis, Pittsburgh, PA, USA, 1999.
[4] R. Bodik and S. Anik. Path-sensitive value-ﬂow analysis.
InProceedings of the 25th ACM SIGPLAN-SIGACT sym-
posium on Principles of programming languages , POPL ’98,
pages 237–251, New York, NY, USA, 1998. ACM.
[5] D. R. Chase, M. Wegman, and F. K. Zadeck. Analysis of
pointers and structures. In Proceedings of the ACM SIG-
PLAN 1990 conference on Programming language design
and implementation , PLDI ’90, pages 296–310, New York,
NY, USA, 1990. ACM.
[6] R. Chatterjee, B. G. Ryder, and W. A. Landi. Rele-
vant context inference. In Proceedings of the 26th ACM
SIGPLAN-SIGACT symposium on Principles of program-
ming languages , POPL ’99, pages 133–146, New York, NY,
USA, 1999. ACM.[7] S. Cherem, L. Princehouse, and R. Rugina. Practical mem-
ory leak detection using guarded value-ﬂow analysis. In Pro-
ceedings of the 2007 ACM SIGPLAN conference on Pro-
gramming language design and implementation , PLDI ’07,
pages 480–491, New York, NY, USA, 2007. ACM.
[8] J.-D. Choi, R. Cytron, and J. Ferrante. Automatic constr uc-
tion of sparse data ﬂow evaluation graphs. In Proceedings
of the 18th ACM SIGPLAN-SIGACT symposium on Prin-
ciples of programming languages , POPL ’91, pages 55–66,
New York, NY, USA, 1991. ACM.
[9] F. C. Chow, S. Chan, S.-M. Liu, R. Lo, and M. Streich.
Eﬀective representation of aliases and indirect memory op-
erations in ssa form. In Proceedings of the 6th International
Conference on Compiler Construction , pages 253–267, Lon-
don, UK, 1996. Springer-Verlag.
[10] R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and
F. K. Zadeck. Eﬃciently computing static single assignment
form and the control dependence graph. ACM Transac-
tions on Programming Languages and Systems , 13(4):451–
490, October 1991.
[11] N. Dor, S. Adams, M. Das, and Z. Yang. Software validation
via scalable path-sensitive value ﬂow analysis. In Proceedings
of the 2004 ACM SIGSOFT international symposium on
Software testing and analysis , ISSTA ’04, pages 12–22, New
York, NY, USA, 2004. ACM.
[12] M. F ¨ahndrich, J. S. Foster, Z. Su, and A. Aiken. Partial
online cycle elimination in inclusion constraint graphs. I n
Proceedings of the ACM SIGPLAN 1998 conference on Pro-
gramming language design and implementation , PLDI ’98,
pages 85–96, New York, NY, USA, 1998. ACM.
[13] S. J. Fink, E. Yahav, N. Dor, G. Ramalingam, and E. Geay.
Eﬀective typestate veriﬁcation in the presence of aliasing.
ACM Trans. Softw. Eng. Methodol. , 17:9:1–9:34, May 2008.
[14] D. Goyal. Transformational derivation of an improved a lias
analysis algorithm. Higher Order Symbol. Comput. , 18:15–
49, June 2005.
[15] B. Hackett and A. Aiken. How is aliasing used in systems
software? In Proceedings of the 14th ACM SIGSOFT inter-
national symposium on Foundations of software engineering ,
SIGSOFT ’06/FSE-14, pages 69–80, New York, NY, USA,
2006. ACM.
[16] B. Hardekopf and C. Lin. The ant and the grasshopper: fast
and accurate pointer analysis for millions of lines of code. In
Proceedings of the 2007 ACM SIGPLAN conference on Pro-
gramming language design and implementation , PLDI ’07,
pages 290–299, New York, NY, USA, 2007. ACM.
[17] B. Hardekopf and C. Lin. Exploiting pointer and location
equivalence to optimize pointer analysis. In In International
Static Analysis Symposium (SAS) , pages 265–280, 2007.
[18] B. Hardekopf and C. Lin. Semi-sparse ﬂow-sensitive point er
analysis. In Proceedings of the 36th annual ACM SIGPLAN-
SIGACT symposium on Principles of programming lan-
guages , POPL ’09, pages 226–238, New York, NY, USA,
2009. ACM.
[19] B. C. Hardekopf. Pointer analysis: building a foundation for
eﬀective program analysis . PhD thesis, Austin, TX, USA,
2009.
[20] R. Hasti and S. Horwitz. Using static single assignment form
to improve ﬂow-insensitive pointer analysis. In Proceedings
of the ACM SIGPLAN 1998 conference on Programming
language design and implementation , PLDI ’98, pages 97–
105, New York, NY, USA, 1998. ACM.[21] M. Hind, M. Burke, P. Carini, and J.-D. Choi. Interproce-
dural pointer alias analysis. ACM Trans. Program. Lang.
Syst., 21:848–894, July 1999.
[22] M. Hind and A. Pioli. Assessing the eﬀects of ﬂow-sensitiv ity
on pointer alias analyses. In Proceedings of the 5th Interna-
tional Symposium on Static Analysis , SAS ’98, pages 57–81,
London, UK, 1998. Springer-Verlag.
[23] V. Kahlon. Bootstrapping: a technique for scalable ﬂow an d
context-sensitive pointer alias analysis. In Proceedings of the
2008 ACM SIGPLAN conference on Programming language
design and implementation , PLDI ’08, pages 249–259, New
York, NY, USA, 2008. ACM.
[24] C. Lattner, A. Lenharth, and V. Adve. Making context-
sensitive points-to analysis with heap cloning practical f or
the real world. In Proceedings of the 2007 ACM SIGPLAN
conference on Programming language design and implemen-
tation , PLDI ’07, pages 278–289, New York, NY, USA, 2007.
ACM.
[25] O. Lhot´ ak and K.-C. A. Chung. Points-to analysis with e f-
ﬁcient strong updates. In Proceedings of the 38th annual
ACM SIGPLAN-SIGACT symposium on Principles of pro-
gramming languages , POPL ’11, pages 3–16, New York, NY,
USA, 2011. ACM.
[26] L. Li, C. Cifuentes, and N. Keynes. Practical and eﬀectiv e
symbolic analysis for buﬀer overﬂow detection. In Proceed-
ings of the eighteenth ACM SIGSOFT international sym-
posium on Foundations of software engineering , FSE ’10,
pages 317–326, New York, NY, USA, 2010. ACM.
[27] LLVM. Low Level Virtual Machine. http://www.llvm.org ,
detail on website.
[28] E. M. Nystrom, H.-S. Kim, and W. mei W. Hwu. Bottom-
up and top-down context-sensitive summary-based pointer
analysis. In SAS’04 , pages 165–180, 2004.
[29] J. H. Reif and H. R. Lewis. Symbolic evaluation and the
global value graph. In Proceedings of the 4th ACM SIGACT-
SIGPLAN symposium on Principles of programming lan-
guages , POPL ’77, pages 104–118, New York, NY, USA,
1977. ACM.
[30] A. Salcianu and M. Rinard. Pointer and escape analysis
for multithreaded programs. In Proceedings of the eighth
ACM SIGPLAN symposium on Principles and practices of
parallel programming , PPoPP ’01, pages 12–23, New York,
NY, USA, 2001. ACM.
[31] M. Sridharan and R. Bod´ ık. Reﬁnement-based context-
sensitive points-to analysis for java. In Proceedings of the
2006 ACM SIGPLAN conference on Programming language
design and implementation , PLDI ’06, pages 387–400, New
York, NY, USA, 2006. ACM.
[32] S. Staiger-St ¨ohr. Implementing sparse ﬂow-sensitive ander-
sen analysis. Technical report, Universit ˜Ad’t Stuttgart, 2009.
[33] B. Steensgaard. Points-to analysis in almost linear tim e. In
Proceedings of the 23rd ACM SIGPLAN-SIGACT sympo-
sium on Principles of programming languages , POPL ’96,
pages 32–41, New York, NY, USA, 1996. ACM.
[34] T. B. Tok, S. Z. Guyer, and C. Lin. Eﬃcient ﬂow-sensitive in-
terprocedural data-ﬂow analysis in the presence of pointers .
InIn 15th International Conference on Compiler Construc-
tion, pages 17–31. Springer, 2006.
[35] J. Whaley and M. S. Lam. Cloning-based context-sensiti ve
pointer alias analysis using binary decision diagrams. In Pro-
ceedings of the ACM SIGPLAN 2004 conference on Pro-
gramming language design and implementation , PLDI ’04,
pages 131–144, New York, NY, USA, 2004. ACM.[36] D. A. Wheeler. SLOC Count User Guide. http://www.
dwheeler.com/sloccount/ . Last accessed: 16 March 2009.
[37] H. Yu, J. Xue, W. Huo, X. Feng, and Z. Zhang. Level by
level: making ﬂow- and context-sensitive pointer analysis
scalable for millions of lines of code. In Proceedings of the
8th annual IEEE/ACM international symposium on Code
generation and optimization , CGO ’10, pages 218–229, New
York, NY, USA, 2010. ACM.
[38] B. Zheng and P. chung Yew. A hierarchical approach to
context-sensitive interprocedural alias analysis, 1999.
[39] J. Zhu. Towards scalable ﬂow and context sensitive pointe r
analysis. In Proceedings of the 42nd annual Design Automa-
tion Conference , DAC ’05, pages 831–836, New York, NY,
USA, 2005. ACM.
[40] J. Zhu and S. Calman. Symbolic pointer analysis revisite d. In
Proceedings of the ACM SIGPLAN 2004 conference on Pro-
gramming language design and implementation , PLDI ’04,
pages 145–157, New York, NY, USA, 2004. ACM.
View publication stats