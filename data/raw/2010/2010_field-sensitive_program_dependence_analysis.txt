See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/221560230
Field-sensitive program dependence analysis
Conf erence Paper  · No vember 2010
DOI: 10.1145/1882291.1882334  · Sour ce: DBLP
CITATIONS
13READS
185
5 author s, including:
Shay Litv ak
Tel Aviv Univ ersity
3 PUBLICA TIONS    32 CITATIONS    
SEE PROFILE
Rastislav Bodik
Univ ersity of W ashingt on
148 PUBLICA TIONS    10,539  CITATIONS    
SEE PROFILE
Noam Rine tzky
Tel Aviv Univ ersity
66 PUBLICA TIONS    1,666  CITATIONS    
SEE PROFILE
Mooly Sagiv
Tel Aviv Univ ersity
290 PUBLICA TIONS    9,463  CITATIONS    
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y Mooly Sagiv  on 28 May 2014.
The user has r equest ed enhanc ement of the do wnlo aded file.Field-SensitiveProgram Dependence Analysis
Shay Litvak
Tel AvivUniversity &PanayaInc.
shay.litvak@cs.tau.ac.ilNurit Dor
PanayaInc.
nurit@panayainc.comRastislav Bodik
UniversityofCalifornia, Berkeley
bodik@cs.berkeley.edu
Noam Rinetzky
QueenMary Universityof London
maon@dcs.qmul.ac.ukMooly Sagiv
Tel AvivUniversity
msagiv@tau.ac.il
ABSTRACT
Statement sttransitively depends on statement stseedif the execu-
tion ofstseedmay affect the execution of st. Computing transitive
programdependencesisafundamentaloperationinmanyauto matic
softwareanalysistools. Existingtoolsﬁnditchallenging tocompute
transitive dependences for programs manipulating large ag gregate
structure variables, and their limitations adversely affe ct analysis
of certain important classes of software systems, e.g., lar ge-scale
enterprise resource planning (ERP)systems.
Thispaperpresentsanefﬁcientconservativeinterprocedu ralstatic
analysis algorithm for computing ﬁeld-sensitivetransiti ve program
dependences inthe presence of large aggregate structure va riables.
Our key insight is that program dependences coming from oper a-
tionsonwholesubstructurescanbeprecisely(i.e.,ﬁeld-s ensitively)
represented atthe granularityofsubstructures insteadof individual
ﬁelds. Technically,weadapttheintervaldomaintoconcise lyrecord
dependences between multiplepairsofﬁeldsofaggregatestructure
variables byexploiting the ﬁelds’spatial arrangement.
Weprovethatouralgorithmisaspreciseasanyalgorithmwhich
worksatthegranularityofindividualﬁelds,themost-prec iseknown
approach for this problem. Our empirical study, in which we a na-
lyzed industrial ERPprograms with over 100,000 lines of code in
average, shows signiﬁcant improvements inboththerunning times
andmemoryconsumptionoverexistingapproaches: Thebasel ineis
anefﬁcientﬁeld-insensitive whole-structure thatincursa62%false
errorrate. An atomization -basedalgorithm,whichdisassembleev-
ery aggregate structure variable into the collection of its individual
ﬁelds, can remove all these false errors at the cost of doubli ng the
average analysis time, from 30 to 60 minutes. In contrast, ou r new
precise algorithm removes all false errors by increasing th e time
only to 35 minutes. In terms of memory consumption, our algo-
rithm increases the footprint by less than 10%, compared to 5 0%
overhead of the atomizingalgorithm.
CategoriesandSubjectDescriptors: D.2.4[SOFTWAREENGI-
NEERING]:Software/ProgramVeriﬁcation
General Terms: Veriﬁcation
Keywords: ADAS, Aggregate structure variables, ERP, Field-
sensitivity, Transitive program dependences
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and thefull citation on the ﬁrstpage. Tocop y otherwise, to
republish, topostonserversortoredistribute tolists,re quires priorspeciﬁc
permission and/or afee.
FSE-18,November 7–11, 2010, Santa Fe,New Mexico, USA.
Copyright 2010 ACM 978-1-60558-791-2/10/11 ...$10.00.1. INTRODUCTION
Astatement sthasanimmediateprogramdependence onastate-
mentstseedif the content of a memory location assigned by stseed
affects either the value computed by stor whether stis executed
at all. A statement sthas atransitive program dependence on a
statement stseedifstandstseedare in the transitive closure of the
immediateprogramdependencerelation. Computingtransit ivepro-
gram dependences is a fundamental operation in many softwar e
understanding and manipulation tools. These tools provide valu-
able mechanized support for the practicing software engine er. For
example, transitiveprogram dependences are usedintools f or pro-
gram maintenance [7, 8], debugging [18], testing [4, 3], sem antic
differencing [11], slicing[32, 14], reuse [22], and mergin g[13].
The problem of computing transitive program dependences ha s
been extensively studied. Most of the advances in the efﬁcie ncy
and precision of the analysis come from improving the analys is’
contextsensitivity ,i.e.,itstreatmentofprocedurecalls(see,e.g.,[27,
28]) and object-ﬁeld sensitivity , i.e., its treatment of dynamically
dispatched methods in object-oriented programs (see, e.g. , [29]).
Incontrast,theproblemofimprovingtheanalysis’ ﬁeld-sensitivity ,
i.e., its treatment of large aggregate structure variables1has not
received much attention. This is rather unfortunate becaus e, as we
have found in our extensive empirical study, imprecise or co stly
handlingofﬁeldsinaggregatestructurevariablesmayhave adverse
effect on the quality of the analysis’ results and its applic ability
to certain classes of important software systems, e.g., lar ge-scale
enterprise resource planning ( ERP)systems.
Therearetwoknownapproaches forcomputing programdepen-
dences for programs manipulating large aggregate structur e vari-
ables. The whole structure (WS) approach [23, 19, 20] treats the
whole structure as a single variable of a primitive type. Int uitively,
it handles a read statement from a ﬁeld fof a structure variable v
as if it may read from any of the ﬁelds of v, and a write statement
toaﬁeldfofvasifitmaywritetoanyﬁeldof v. Theatomization
(ATOM) approach [26, 21] reduces the ﬁeld-sensitive dependence
problemintoadependenceproblemforprogramswithoutaggr egate
structures by disassembling aggregate structures to their primitive
components. Unfortunately, in our experimental study, in w hich
we analyzed industrial ERPprograms with over 100,000 lines of
code inaverage, we found the WSapproach to be efﬁcient but im-
precise and the ATOMapproach tobe precise but inefﬁcient. (See
Sections 2and 8.)
In this paper we present ADAS, an interprocedural static anal-
ysis algorithm for computing ﬁeld-sensitive transitive pr ogram de-
pendences in the presence of large aggregate structure vari ables.
(ADASstands for Aggregate Dependence via Arrangement Seg-
1Byalargeaggregatestructurevariable ,wemeanarecordvariable
whichcontains dozens, or even hundreds, of ﬁelds.ments.) In our experiments, we found that ADAShas comparable
costtothe WSapproach. In[17],weprovethat ADASprovidesthe
same precisionas the ATOMapproach.
Ourkeyinsightisthatprogramdependencescomingfromoper a-
tionsonwholesubstructurescanbeprecisely(i.e.,ﬁeld-s ensitively)
represented atthe granularityofsubstructures insteadof individual
ﬁelds. The key reason for the efﬁciency of ADASis the use of an
interval-like abstract domainwhichallows toaccuratelyr ecordde-
pendences between multiple pairs of (adjacent) ﬁelds in a co ncise
manner.
ADASworksintwostages. Intheﬁrststage,itcomputesa range-
labeledprogramdependence graph . Aprogramdependence graph
(PDG)is a graph whose nodes are the program statements and its
edges represent immediate program dependences. In existin g de-
pendence analyses,aprogram dependence representinga dataﬂow
fromst1tost2,meansthatthevalueofthevariabledeﬁnedinstate-
mentst1,denotedby def(st1),maybeusedinstatement st2. The
labels usedby ADASallow toreﬁne this information by recording
on every edge the ﬁelds of variable def(st1)whichget deﬁned in
st1and may be used in st2. In the second stage, ADASutilizes
the range labels toperform an efﬁcient and precise computat ion of
transitive program dependences over the range-labeled PDG.
Example 1.1. Fig. 1(a) shows a program which is comprised
onlyofasequenceofassignments.2Theanalysisgoalistocompute
the transitive dependences on the variable deﬁned in a speci ﬁed
seed statement , which in this example is variable seeddeﬁned in
statement l1. In this example, ADASaccurately infers that ﬁeld
b.gmay (only)depend onﬁeldseed .fandthatﬁeld b.fmay(only)
depend onﬁeld seed .g.
Fig. 1(b) shows the range-labeled PDGof the program. We de-
notetheedgeemanatingfrom,e.g.,node l1(representingstatement
l1:seed:=exp ) and entering node l2(representing statement
l2:a := seed ), byl1→l2. The range-label of edge l1→l2
is/hatwideseed, which indicates that the whole value of variable seedis
deﬁned in statement l1andgets used in statement l2. We refer to
assignment statements inwhichwhole aggregate structures are as-
signed as Big L-value operations. For example, statements l1and
l2are BigL-value operations.
The range-label of the edge l2→l3is/hatwidera.f, whichindicates that
only thef-ﬁeld ofais used instatement l3. Note that a.fis apart
of variable awhose entire value gets deﬁned instatement l2.
Therange-labeloftheedge l3→l5is/hatwidei,whichindicatesthatthe
entire value ofvariable iisdeﬁned instatement l3andgets usedin
statement l5. (Inthis example iisan integer variable, ingeneral, i
may be anaggregate structure variable withdozens of ﬁelds. )
ADASuses the range-labels to accurately and efﬁciently com-
putetransitiveprogramdependences. Forexample,thedepe ndence
/an}bracketle{t/hatwideseed,/hatwideseed/an}bracketri}htatl2is “generated” by the distinguished seed state-
ment. Its propagation over the edge l2→l3transforms it into
/an}bracketle{t/hatwidera.f,/hatwiderseed.f/an}bracketri}ht, indicating that the ﬁeld a.f, which is used in l3,
may (only) depend on ﬁeld seed .f. The latter dependence, when
propagated over edge l3→l5, gets transformed into dependence
/an}bracketle{t/hatwidei,/hatwiderseed.f/an}bracketri}ht,indicatingthatthe value ofvariable iatl5depends on
seed.fwhich allows ADASto infer that b.gmay (only) depended
on seed.f.
Weexperimentallyevaluatedthe ADASalgorithmbycomparing
its precision and cost with those of the known algorithms in t he
2We discuss the treatment of control-ﬂow statements, multip le as-
signments tothe same variable, destructive updates, and pr ocedure
invocations inthe followingsections.context of an important software engineering application: helping
ERPengineers understand the impact of a change in the system’s
conﬁguration database.3We analyzed a variety of industrial ERP
programs withover a 100,000 line of code inaverage. Our expe ri-
ments show that in practice ADASprovides the same precision as
the most-precise known algorithm for this problem, with ave rage
improvement of the running time by 43% and of the memory con-
sumption by 31%. These improvements enabled us to effective ly
analyzeprogramsthatcouldnothavebeenanalyzeusingthek nown
approaches. (SeeSection8.3).
MainResults. Themaincontributionsofthispapercanbesumma-
rizedas follows:
•Wepresent ADAS,anovelalgorithmforcomputingprogram
dependences inthe presence of large structure variables.
•Weprovethat ADASisasprecise asanyalgorithm basedon
the atomizationapproach in[17].
•We implemented ADASinsidePanayaIA , an industrial im-
pact analysis tool [6, 24], and successfully applied it to re al-
lifeERPprograms of over a millionlines of code.
•Ourextensiveexperimentalevaluation,doneinthecontext of
an important engineering application, shows that in practice
ADAScompares favorablywithexisting approaches.
We note that while ADASis evaluated in the context of ERP
systems, thealgorithm itselfisof generic nature andis ofv alue for
analyzing any program which uses aggregate structure varia bles.
(See Section9).
Outline.Therestofthepaperisorganizedasfollows. Section2de-
scribes related work. Section 3 describes standard notions pertain-
ingtoreachingdeﬁnitionanalysisandprogramdependenceg raphs.
Section 4 states the ﬁeld-sensitive dependence analysis re search
problem. Section5describesournovelrange-basedreachin gdeﬁni-
tion analysis. Sections 6 and 7 describe, respectively, the intrapro-
cedural and interprocedural aspects of ADAS. Section 8 describe
our experimental evaluation and Section9concludes.
Wenote thatSections4-7arewrittenatamoreformallevelth an
the other sections, and can be skipped on ﬁrst read. Also, due to
spacereasons,proofsandseveraltechnicaldetailshavebe enomitted
from the paper andappear in[17].
2. RELATED WORK
Techniquesforhandlingaggregatestructureshavebeensug gested
in the context of program dependence analysis (see, e.g., [1 2, 14,
15]) as well as in the context of pointer analysis (see, e.g., [33,
10, 25]). Traditionally, these techniques have mainly focu sed on
analyzingpointer-basedmanipulationofaggregatestruct uresinre-
cursivedatastructureand/orbyrecursiveprocedures. For example,
an efﬁcient analysis which computes data ﬂow dependences in the
presence of heap pointers and recursive data structure is pr esented
3ERPsystems are dominant in the world of business applications.
Theyaretypicallycomprisedofhundredsorthousandsofpro grams,
whereeachprogrammaycontainoveramillionlinesofcode. O neof
thekeyreasonsforthesuccessof ERPsystemsistheirmodularde-
sign: Everybusinesscanaddandcustomizepre-manufacture dcode
modules to meet its particular needs by, what amounts to, loa ding
conﬁguration attributes into in-memory large aggregate st ructure
variables. These variables have an immense effect on the way that
thesystemoperates. Foradditionaldiscussionon ERPsystems,see
Section8.1.struct T1{
int f
int g
}
T1a, b
T1d, seed, exp
inti,j
l1: seed:= exp
l2: a :=seed
l3: i:= a.f
l4: j:= a.g
l5: b.g:= i
l6: b.f :=j
l7: d:= b/d23/d22 /d21/d20
/d16/d17 /d18/d19 l1: seed:= exp
/hatwideseed/d15/d15/d23/d22 /d21/d20/d16/d17 /d18/d19 l2: a := seed
/hatwidesta.f/d15/d15
/hatwidesta.g
/d119/d119{/an}bracketle{t/hatwideseed,/hatwideseed/an}bracketri}ht}
/d23/d22 /d21/d20/d16/d17 /d18/d19 l3: i:= a.f
/hatwidei
/d39/d39{/an}bracketle{t/hatwidera.f,/hatwiderseed.f/an}bracketri}ht}
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l4: j:= a.g
/hatwidej
/d119/d119{/an}bracketle{t/hatwidera.g,/hatwiderseed.g/an}bracketri}ht}
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l5: b.g:= i
/hatwiderb.g
/d39/d39{/an}bracketle{t/hatwidei,/hatwiderseed.f/an}bracketri}ht}
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l6: b.f := j
/hatwidestb.f/d15/d15{/an}bracketle{t/hatwidej,/hatwiderseed.g/an}bracketri}ht}
/d23/d22 /d21/d20/d16/d17 /d18/d19 l7: d:= b {/an}bracketle{t/hatwiderb.f,/hatwiderseed.g/an}bracketri}ht,/an}bracketle{t/hatwiderb.g,/hatwiderseed.f/an}bracketri}ht}int a_f, a_g
int b_f, b_g
int d_f, d_g
int seed_f, seed_g
int exp_f, exp_g
int i,j
l1.1: seed_f := exp_f
l1.2: seed_g := exp_g
l2.1: a_f := seed_f
l2.2: a_g :=seed_g
l3: i:= a_f
l4: j:= a_g
l5: b_g :=i
l6: b_f := j
l7.1: d_f :=b_f
l7.2: d_g := b_g/d23/d22 /d21/d20
/d16/d17 /d18/d19 l1.1: seed_f :=exp_f
/d42/d42/d23/d22 /d21/d20
/d16/d17 /d18/d19 l1.2: seed_g :=exp_g
/d116/d116/d23/d22 /d21/d20/d16/d17 /d18/d19 l2.1: a_f :=seed_f
/d43/d43/d23/d22 /d21/d20
/d16/d17 /d18/d19 l2.2: a_g :=seed_g
/d115/d115/d23/d22 /d21/d20/d16/d17 /d18/d19 l3: i :=a_f
/d41/d41/d23/d22 /d21/d20
/d16/d17 /d18/d19 l4: j:= a_g
/d117/d117/d23/d22 /d21/d20
/d16/d17 /d18/d19 l5: b_g :=i
/d41/d41/d23/d22 /d21/d20
/d16/d17 /d18/d19 l6: b_f := j
/d15/d15/d23/d22 /d21/d20/d16/d17 /d18/d19 l7.1: d_f := b_f
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l7.2: d_g:= b_g
(a) (b) (c) (d)
Figure 1: (a) a program manipulating ﬁelds, (b) its range-la beled PDG annotated with the dependences computed by the ADAS
algorithm at every statement, (c) theatomized version of th e program, and(d)thePDG of theatomized program
in [12]. Efﬁcient analysis algorithms for handling procedu res, es-
pecially recursive ones, are presented in works using the System
Dependence Graph [14,15].
The twoknown approaches forhandling (large)aggregate str uc-
ture variables in the area of program dependence analysis ar e the
whole structure (WS) approach [23, 19, 20], and the atomization
(ATOM)approach[21,26],whichhavebeendescribedinSection1.
Thetwoapproachesrepresentdifferenttradeoffsbetweene fﬁciency
and precision. The ﬁrst one is efﬁcient but not ﬁeld sensitiv e. The
second one has opposite properties.
Example 2.1. Recallthat ADASsuccessfullyinfersthatat l7in
Fig.1ﬁeld b.gmay(only) depend onﬁeldseed .fandthatﬁeld b.f
may (only) depend onﬁeld seed .g.
Incontrast,anyalgorithmbasedonthewholestructureappr oach
would fail to infer such accurate information. Speciﬁcally , such
an algorithm can manage to compute that at l7variable bmay
depend on seed. However, the ﬁeld dependence is not known.
Thus, the results of a WS-based algorithm would indicate a false
may dependence of, e.g., b.gonseed.g.
Theatomizationapproachcomputes informationatthesamea c-
curacy levelas ADAS.Itdoes soby transformingthe original pro-
gramintotheone showninFig.1(c)andthenperformingstand ard
dependenceanalysisonthe PDGofthetransformedprogram,shown
in Fig. 1(d). Note that, in particular, every big L-value ope ration
(see Example 1.1)inwhich kprimitiveﬁelds are assigned istrans-
formed into kindividual ﬁelds assignment operations.
AsshowninExample 2.1,bothapproaches havedrawbacks: the
whole structure approach can yield superﬂuous dependences when
manipulating structure ﬁelds, while atomization approach may be
too expensive on programs with large structures (due to the l arge
increase inthe totalnumber of variables andstatements).
In our case study, different approaches for computing progr am
dependence are evaluated by integrating different analyse s in an
industrial impact analysis tool. We applied the tool to larg e-scale
ERPprograms. Theseprogramsmakeextensiveuseoflargeaggre-gate structure variables. We found that, for the programs th at we
analyzed, using the known approaches isimpractical.
We note that [26] suggests an interesting optimization for t he
atomization approach. The main idea is to use a ﬂow-insensit ive
analysis that determines which ﬁelds need to be atomized. In our
experimental evaluation, we have tested the applicability of this
suggestion in the context of ERPsystems. Our evaluation of this
suggestion,describedinSection8.4,showsthatthisoptim izationis
not effective for large-scale ERPprograms.
3. PRELIMINARIES
In this section, we describe the standard notions of reachin g
deﬁnitions, program dependence graphs, and system depende nce
graphs.
Reaching deﬁnition is an iterative analysis over the contro l-ﬂow
graph (CFG) of the program that tracks the possible last deﬁnition
point for each variable that may arise at execution of a progr am
label. The analysis starts withan empty set of reaching deﬁn itions
andtrackstheeffectofstatementsonthesetofreachingdeﬁ nitions.
Essentially,theeffectofastatement stonasetofreachingdeﬁnition
is to remove some reaching deﬁnitions that are no longer true and
togenerate new ones (see,e.g., [2]).
A statement stusesresp.deﬁnesanaccess path if the latter de-
notesanl-valuewhichisreadresp. writtenby st. Thisinformation
is extractedfrom the result of the reaching deﬁnitionanaly sis.
A basic representation of data ﬂow dependency is def-use
chains [23]. A def-use edge between statement st1andst2rep-
resents that during execution of st1some access-path is assigned
whichmay be (partially)used inthe execution of st2.
Theprogram dependence graph (PDG) represents the data and
control dependences ofa(single) procedure [30]. The nodes ofthe
graph are the statements. There are two types of edges: data a nd
control. Data dependence edges are the def-use edges comput ed
from a reaching deﬁnition analysis. Control dependence edg es are
computed by post-domination on the control ﬂow graph. Fig. 2
contains an example of a PDG (ignore for now the labels on the
edges) in which control edges are pictured as dotted edges. W eassume, without lose of generality that all control stateme nts are
represented as a guarded statements p?st′wherest′is executed
only when pis evaluated to true. A control dependency between
st1and (thenecessarily guarded command) st2represents that st1
is acondition over a variable cwhichisthe guardof st2. Consider
the guardedcommand statementin l10ofthe example. InthePDG
this statementissplitintotwonodes: one forthe predicate p(node
l10.1) and one for the guarded statement itself i:=q(nodel10.2).
Theoutgoingedgeof l10.1inthePDGisacontroldependenceedge.
Asystemdependencegraph (SDG)representstheimmediatepro-
gram dependence of a program containing procedures. The SDG
of a program is comprised the PDGs of its procedures. The PDGs
are connected together by call edges (which represent proce dure
calls) and by parameter-in and parameter-out edges (which r epre-
sentparameterpassingandreturnvalues). The SDGrepresentation
is oftenused ininter-procedural dependence analysis [14, 15].
4. PROBLEM DEFINITION
Thegoalofthisworkistoﬁndinapreciseandefﬁcientmanner the
ﬁeld sensitive transitive dependences in the presence of aggregate
structures with Big L-value operations. (Recall that Big L-value
operations are assignments towhole (sub)structures.)
Traditionally,givenacontrolﬂowgraphofaprogram,anode nis
ﬂowdependent onanode mifthereexistsapathinthecontrolﬂow
inwhichthe value assigned in misdirectlyusedat n. Similarly, n
istransitively dependent onmif there exists a path in the control
ﬂow graph inwhichthe value assigned in misindirectlyused at n
(ofcoursethisisanoverapproximationsincenotallCFGpat hsare
feasible).
Weextend thetraditional deﬁnitionto ﬁeldsensitive ﬂow depen-
dentas follows: an access path, say x.f, used at node nisﬁeld
sensitive ﬂow dependent on an access path s.gassigned at node m
ifthereexistsapathinthecontrolﬂowinwhichthevalue ass igned
inmtos.gisdirectlyusedasthevalueof x.fatn. Thus,thetradi-
tionalﬂow-dependentrelationisbetweenstatementswhile theﬁeld
sensitive ﬂow dependent relation is between pairs of access -path
and statement.
Thereareseveralfactorsthatcomplicatethisdeﬁnitionin reallife
programming languages: pointers and dynamic allocations ( e.g.,
[12]) , Big L-Values, and procedures (e.g., [14]). We deﬁne Field
Sensitive Transitive Dependence as a transitive dependence which
handles precisely aggregate structures and Big L-values (w ithout
pointers). NoticethatBigL-valuesmaketheproblemmoreco mplex
becauseﬂowdependencesbetweenstatementsarenottransit ive,i.e.,
it may be that mis directly ﬂow dependent on nandnis directly
ﬂowdependenton pandyetmisnottransitivelyﬂowdependenton
p. For example, statement l8in Fig. 2 is ﬂow dependent on l7(the
use ofd.g1isﬂow dependent onthe deﬁnitionof d),andl7is ﬂow
dependenton l6(theuseof c,inparticularof c.g2,isﬂowdependent
ofthedeﬁnitionof c.g2),yettheirtransitiveclosureyieldsaspurious
dependence of d.g1inl8onthe deﬁnition of tinl5.
5. RANGE-BASED REPRESENTATIONS
In this section, we describe our range-based reaching deﬁni tion
analysis. We say that a rangeof a variable is a contiguous part of
the memory allocated to the variable. A range denoted by v[i,j]
represents the memory area of vthat starts with the i-th byte and
ends with including the j-th byte. A single range of an alloca ted
aggregatecanbeusedtorepresentallﬁeldsthatareallocat edwithin
this range. For ease of presentation, we use the notion /hatwidevto denote
thewhole rangeofavariable vand/hatwiderv.ftodenotetherange aligned
withthefﬁeldofv. Arangeneedsnottobealignedwiththeﬁeldsof an aggregate structure. For example consider the variabl esdof
typeT1deﬁnedinFig.2andassumeeachﬁeldis4byteslong. Th e
rangesd[0,3]representstheﬁeld f1ofsd. Weassumethefactthat
an aggregate structure contains an ordered set of ﬁelds and e very
ﬁeldhasastartandendoffset,thustherange sd[0,7]representsthe
ﬁeldsf1,f2. We deﬁne a meet operation between ranges which
provides the maximal range that isinbothranges as follows:
v[x,y]∩v[x′,y′] =/braceleftbigg
v[max(x,x′),min(y,y′)]x≤y′∧x′≤y
∅ y < x′∨y′< x
Where∅denotesthatthereisnooverlappingbetweenthetworanges.
Forexample, /hatwidersd.f1∩/hatwidersd.f2 =∅. Asweshallsee,thisoperationis
usedinﬁlteringspuriousdependence. Notethatthemeetope ration
is deﬁnedfor ranges of the same variable.
Giventhenotionofranges wefurthersimplifytheprograms a nd
assume that statements are over ranges:
•assignments are inthe form v[x,y] =u[x′,y′],
•expressions evaluation (computation assignments) are in t he
formv[x,y] =exp(u1[x1,y1],...,un[xn,yn],
•guarded statements p?st′,and
•gotostatements.
Wedenoteby Vthesetofvariablesintheprogramandby LABEL
the set of statements.
5.1 Range-Based Dependency
A dependence d=/an}bracketle{tv[x,y],seed[x′,y′],l,vd/an}bracketri}htimplies that the
(partial) value of vis transitively dependent on the (partial) value
ofseedwhich was assigned at line l. The dependence is a value
dependence ifvdistrueanda computationaldependence otherwise.
Value dependence means that the value assigned to the range
seed[x′,y′]is read from range v[x,y]. Note that if the variable
vandseedare aggregate of the same type and the ranges are the
same, i.e., x′=xandy′=y, and the range spans more than
one ﬁeld, f1,...fnthen it implies that v.fiis value dependent on
seed.fi. Notethatifaggregatevariableshavehundredsofﬁeldsand
ifmostdependencies arecontiguous (ashappens whenbigL-v alue
operations areused)thenthisrepresentationismuchmoree fﬁcient
thana naive representation based onindividual ﬁelds.
A computational dependence comes either from a control de-
pendence, indicating that the value of seedwas (transitively) used
as a control predicate for the (transitively) use of the valu e ofv,
or from cases where the value of seedwas (transitively) used at a
computational expression which vis dependent on. In contrast to
value dependences, computational dependences do notimply that
ifseed[x′,y′]includes ﬁelds f1,...fnandv[x,y]includes ﬁelds
g1,...gmthen every ﬁeld v.giis dependent on every ﬁeld v.fjfor
j= 1,...n.
5.2 RangeLabeled PDG
We adjust the PDG to record ﬁned-grained reaching deﬁnition .
Usingarangebasedreachingdeﬁnitionanalysis,labelsare addedto
def-useedgesthatrepresenttherangethatisactuallyinus e. Thisen-
ables handling ofdestructive updates (i.e.,partialkilla ssignments)
accurately. For example, in Fig. 2 the two edges from l2tol4are
marked withtherange ofﬁeld a.f1anda.f3because ofstatement
l3that killsa.f2.
RangebasedReachingDeﬁnition. Weenhancethestandardreach-
ing deﬁnitions to track reaching deﬁnitions of ranges. The d o-
main for the analysis is Σ =RANGE →2LABELwhere
RANGE =V ×INT×INT. The join operator is a set union
andthemaintransferfunctionispresentedinTable1andexp lained
below. Thegoalistotrackaggregatevariablesasawholestr ucture
and split into ranges only when needed. Handling assignment s tostructT1{
intf1
intf2
T2f3
}
structT2{
intg1
intg2
}
T1exp,sd,a,b
T2c,d,i,j,k,q
intkill,e,t
boolean p
l1: sd:= exp
l2: a :=sd
l3: a.f2:=kill
l4: b:=a
l5: t:= b.f1
l6: c.g2:= t
l7: d:=c
l8: e :=d.g1
l9: p:=(d.g2 <> empty)
l10: p? i:= q
l11: t :=i.g1
l12: j.g2:= t
l13: k:= j/d23/d22 /d21/d20
/d16/d17 /d18/d19 l1: sd:=exp
/hatwidersd/d15/d15/d23/d22 /d21/d20/d16/d17 /d18/d19 l2: a := sd
/hatwidea.f1
/d117/d117/hatwidea.f3
/d41/d41{/an}bracketle{t/hatwidesd,/hatwidesd,true/an}bracketri}ht}
/d23/d22 /d21/d20/d16/d17 /d18/d19 l3: a.f2:= kill
/hatwidea.f2/d15/d15∅
/d23/d22/d21/d20/d16/d17/d18/d19l4: b:= a
/hatwideb.f1/d15/d15{/an}bracketle{t/hatwidea.f1,/hatwidersd.f1,true/an}bracketri}ht,/an}bracketle{t/hatwidea.f3,/hatwidersd.f3,true/an}bracketri}ht}
/d23/d22 /d21/d20/d16/d17 /d18/d19 l5: t :=b.f1
/hatwidet/d15/d15{/an}bracketle{t/hatwideb.f1,/hatwidersd.f1,true/an}bracketri}ht}
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l6: c.g2:=t
/hatwidec.g2/d15/d15{/an}bracketle{t/hatwidet,/hatwidersd.f1,true/an}bracketri}ht}
/d23/d22/d21/d20/d16/d17/d18/d19l7: d:= c
/hatwided.g1/d15/d15
/hatwided.g2
/d118/d118{/an}bracketle{t/hatwidec.g2,/hatwidersd.f1,true/an}bracketri}ht}
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l8: e := d.g1 ∅
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l9: p:= (d.g2<> empty)
/hatwidep/d15/d15{/an}bracketle{t/hatwided.g2,/hatwidersd.f1,true/an}bracketri}ht}
/d23/d22/d21/d20
/d16/d17/d18/d19l10.1: p?
/d115/d115{/an}bracketle{t/hatwidep,/hatwidersd.f1,false/an}bracketri}ht}
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l10.2: i :=q
/hatwidei.g1/d15/d15{/an}bracketle{t/hatwideq,/hatwidersd.f1,false/an}bracketri}ht}
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l11: t:= i.g1
/hatwidet/d15/d15{/an}bracketle{t/hatwidei.g1,/hatwidersd.f1,false/an}bracketri}ht}
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l12: j.g2:=t
/hatwidej.g2/d15/d15{/an}bracketle{t/hatwidet,/hatwidersd.f1,false/an}bracketri}ht}
/d23/d22 /d21/d20
/d16/d17 /d18/d19 l13: k:= j {/an}bracketle{t/hatwidej.g2,/hatwidersd.f1,false/an}bracketri}ht}
Figure 2: ADASalgorithm run example on PDG. The state next to each statemen t is a result of processing the incoming edges.
Guardedcommands weresplitinorder toaccommodate control dependenceedges.
a whole variable vis rather straightforward. Reaching deﬁnitions
on any range of vare “killed” and a new reaching deﬁnition for v
is created. For example, the processing of statement l2creates the
reaching deﬁnition {a/mapsto→ {l2}}.
Handling assignments to ﬁelds requires some ﬁnesse as the de f-
inition of v.fpartially kills a prior deﬁnition to v. Assignments
to a whole variable deﬁne the whole structure and thus do not
create a “partial kill”. In the example, statement l2deﬁnes the
whole structure aand the statement in l3deﬁnes only a.f2, par-
tially killing the previous deﬁnition to a. However, the previ-
ous reaching deﬁnition for ranges of the aggregate variable that
were not killed are still valid and a new reaching deﬁnition o nly
to the range that was reassigned is generated. To accommo-
date this case, previous reaching deﬁnition of ranges that o ver-
laps with the assigned range are removed. Instead, up to thre e
new ranges are generated, as deﬁned in Table 1. In our example ,
the processing ofstatement l3yields thefollowingreaching deﬁni-tion:a[0,end(f1)]/mapsto→ {l2},a[start(f2),end(f2)]/mapsto→ {l3}, and
a[start(f3),end(a)]/mapsto→ {l2}.
Constructingthe PDG. The reaching deﬁnition analysis computes
a set of possible reaching deﬁnition points for ranges at eac h state-
ment. Giventhisinformation,therange-labeledPDGiscons tructed.
Foreachstatement, l2andforeachrangeinthereachingdeﬁnition,
v[x,y]/mapsto→ {l1}, that is (partially) used at the statement, an edge
froml1tol2isconstructed. Thelabelisthemeetbetweentherange
in the reaching deﬁnition and the range used in the statement : As-
sume the used range in statement l2isv[x′,y′]and the reaching
deﬁnitionisforrange v[x,y]thenthelabelis v[x,y]∩v[x′,y′]. If
the meet operation is ∅then no edge is added as statement l2does
not use the reaching deﬁnition of v[x,y]. Control edges are added
totherange-labeled PDGasinthetraditionalPDG,without l abels.Statement Transfer function
(a)l:v[x,y] :=... σ[t[i,j]/mapsto→σ(t[i,j])|t/ne}ationslash=v∨(t=v∧(v[i,j]∩v[x,y] =∅))]∪
{v[x,y]/mapsto→ {l}}∪
{v[a,x−1]/mapsto→l′|∀a,b:σ(v[a,b])/mapsto→l′∧(v[a,b]∩v[x,y]/ne}ationslash=∅)∧a < x}∪
{v[y+1,b]/mapsto→l′|∀a,b:σ(v[a,b])/mapsto→l′∧(v[a,b]∩v[x,y]/ne}ationslash=∅)∧y < b}
(b)l:v[0,end(v)] :=... σ[t[i,j]/mapsto→σ(t[i,j])|t/ne}ationslash=v]∪{v[0,end(v)]/mapsto→ {l}}
Table 1: (a) The transfer function of the range reaching deﬁn ition analysis where σ∈Σis the current state. (b) For clarity, a
simpliﬁedversion for awhole variable assignment ispresen tedalthoughitis handledas anyrange assignment.
6. INTRAPROCEDURALANALYSIS
ThePDGcontainsimmediatedependences andatransitivefunc-
tion is needed to compute transitive ﬂow dependences. Howev er,
unlike the atomization approach or the whole structure appr oach
where the transitive relation is simple, for the interval-b ased anal-
ysis we need to handle cases where the reaching deﬁnition is o n a
Big L-value. Consider the example of Fig. 2, when computing t he
transitive ﬂow dependences from statement l1and from statement
l2tol4, the additional reaching deﬁnition of a.f2is taken into ac-
count. Clearly, the transitivity of these two reaching deﬁn ition is
validfora.f1butinvalidfor a.f2. As weshallsee, whiletracking
the transitive dependence, we keep track of the current rang e that
isofinterest. Inaddition, thetransitivecomputationnee ds toavoid
superﬂuous dependence. For example, consider the dependen ces
betweenl6tol7andl7tol8. Theanalysisneedstoinferthatthereis
nodependencebetween l6andl8. Thisisfurthercomplicatedwhen
nested ﬁelds aretaken intoaccount.
Our Approach. TheADASalgorithm is a chaotic iteration algo-
rithm over therange-labeled PDG.Thedomain isthe setof all sets
of dependences
2/angbracketleftRANGE ×RANGE ×LABLES ×BOOL /angbracketright
whereRANGE =V ×INT×INTis the set of all ranges.
A tuple/an}bracketle{tv[x,y],s[x′,y′],l,vd/an}bracketri}htcorresponds to a dependence as
deﬁned in Section 5.1: it implies that range [x,y]of variable vis
transitively dependent on the values assigned to range [x′,y′]of
theseedvariable satlinel. Furthermore,thedependence isavalue
dependenceif vdistrueandacomputationaldependenceotherwise.
A dependence on v[x,y]computed in a state for a statement l′
implies that the statement l′uses a range of the variable v, say
v[xu,yu]. However the dependent range can be a subrange of the
used range, i.e., xu≤x≤y≤yu. In the rest of the paper, we
assume,withoutloseofgenerality,thatthealgorithmtrac ksasingle
seedvariable assignedatasingleseedstatement andomitth e label
member of the tuple.
The join operator is the set union operator. The algorithm
starts with a seed statement and a dependency on the seed rang e
/an}bracketle{tsd[x,y],sd[x,y],true/an}bracketri}htand computes the transitive dependency
of the seed. The analysis computes for each statement, st, a set of
ﬁeld sensitive dependencies on the used ranges of st. The prop-
agation of dependencies takes into account the source and ta rget
statements and the type and label of the edge. Table 2 formali zes
the transfer functions. A data ﬂow edge between st1andst2is
handled intwosteps (Step1and 2Table2) as follows:
•Step 1 computes the dependence on the deﬁned range (left-
hand side) of statement st1. At this step, assignments that
are “copy” statements are treated differently than computa -
tional statements, as the ﬁrst preserve the data ﬂow and the
second does not. Conditional statements do not change thedependence. At this step we take into account cases where
the dependence is on a subpart of the used range and adjust
the dependence tothe subpart of the deﬁnedrange.
•Step2 ﬁlters and adjusts the computed dependence from the
ﬁrststepaccording tothe edge bytakingintoaccount the la-
bel on the edge: A dependence /an}bracketle{tv[x,y],seed[x′,y′],vd/an}bracketri}htis
ﬁltered if there is no overlap between the dependent range
andthelabel ontheedge. Ifitisnotﬁltered,thenthedepen-
dent range is reﬁned according to the label. In addition, if
the dependence processed isa data-ﬂow one ( vdistrue), the
dependence range of the seedis reﬁnedas well.
Controledgesdonothavealabelandthereforeneverﬁlterde pen-
dences. Because control edges always come from a condition e x-
pression, the analysis yields a computational dependences for each
used range in the target statement to reﬂect that the depende ncy is
not a data ﬂow one.
The example in Fig. 2 shows the computed dependencies on the
variablesdassigned at statement l1. We now further explain the
key issues inthe analysis.
HandlingDataEdgesonDataDependences. Theﬁrststepofhan-
dlingdata edges isgenerating the dependence onthedeﬁned r ange
ofthesourcestatement. Forexample,theﬁrststepinthepro cessing
ofdependence /an}bracketle{t/hatwidesd,/hatwidesd,true/an}bracketri}htontheedgelabeled /hatwidea.f1forml2tol4
treatsstatement l2asanassignment a[0,end(a)] :=sd[0,end(sd)]
andgeneratesthesamedependenceonthevariable a,/an}bracketle{t/hatwidea,/hatwidesd,true/an}bracketri}ht.
The second step reﬁnes the dependence according to the label .
In this case the label v[xl,yl]isa[0,3]and the dependent range
v[x,y]isa[0,end(a)]. Because the dependence is a data ﬂow one
(vd=true) and the meet between a[0,end(a)]anda[0,3]is not∅
then the processing is according to the second case in Step 2 i n
Table 2. The computation of the dependent range is evaluated as
a[0,3]∩a[0,end(a)] =a[0,3]. The seed range is also reﬁned
according to sd[xs,ys−(y−yl)] =sd[0,3] =/hatwidersd.f1. Thus, the
second stepyields the dependence /an}bracketle{t/hatwidea.f1,/hatwidersd.f1,true/an}bracketri}ht.
In cases where the deﬁned range is a subrange of a variable, th e
ﬁrst step performs an adjustment of the dependent range. For ex-
ample, consider the processing of dependence /an}bracketle{t/hatwidet,/hatwidersd.f1,true/an}bracketri}hton
the edge from l6tol7. The statement in l6is treated as an assign-
mentc[4,7] :=t[0,3]and the processed dependence in explicit
range format is /an}bracketle{tt[0,3],sd[0,3],true/an}bracketri}ht. According tothe ﬁrst case
in Step 1 in Table 2, the used range u[xu,yu]ist[0,3], the de-
ﬁned range v[xd,yd]isc[4,7], and the dependent range t[x,y]is
t[0,3]. Thegenerateddependence is /an}bracketle{tc[4,7],sd[0,3],true/an}bracketri}htwhich
is represented as /an}bracketle{t/hatwidec.g2,/hatwidersd.f1,true/an}bracketri}ht.
Handling Partial Kill. Consider transition l2tol4which includes
theprocessingoftwoedgesdue tothedestructive update in l3. For
each outgoing edge from l2new dependences are computed for l4
as described above in the processing of data edges. The resul t isTransfer Functions
Case NewDependence
Data
EdgeStep1st1inthe form v[xd,yd] =u[xu,yu] /an}bracketle{tv[xd+(x−xu),yd−(yu−y)],seed[xs,ys],vd/an}bracketri}ht
st1inthe form v[xd,yd] =exp(u1[x1,y1],...,un[xn,yn])/an}bracketle{tv[xd,yd],seed[xs,ys],false/an}bracketri}ht
Step2v[x,y]∩v[xl,yl] =∅ ∅
v[x,y]∩v[xl,yl]/ne}ationslash=∅∧vd=true /an}bracketle{tv[x,y]∩v[xl,yl],seed[x′,y′],true/an}bracketri}htwhere
x′=/braceleftBigg
xs x≥xl
xs+(xl−x)x < x l
y′=/braceleftBigg
ys y≤yl
ys−(y−yl)y > yl
v[x,y]∩v[xl,yl]/ne}ationslash=∅∧vd=false /an}bracketle{tv[x,y]∩v[xl,yl],seed[xs,ys],vd/an}bracketri}ht
Control Edge {/an}bracketle{tui[xi,yi],seed[xs,ys],false/an}bracketri}ht|i= 1,..,n}
Table 2: Transfer functions of the ADASalgorithm for a dependence d=/an}bracketle{tt[x,y],seed[xs,ys],vd/an}bracketri}htfor an edge between st1andst2.
For dataﬂowedge,weassumethattheedge islabeled v[xl,yl],thatv[xd,yd]isthedeﬁnedrangeof statement st1,andthat v[xu,yu]
is the used range in statement st2. Note that step 2 processes the (intermediate) dependence c omputed by the previous step and
speciﬁcallythehandleddependencyinon v[x,y]. Notethatintheﬁrstcase ofstep1, xu≤x≤y≤yualways hold. Notethatinthis
case itholdsthat yu−xu=yd−xdandthus yd−(yu−y) =xd+(x−xu)+(y−x). Alsonotethatinthesecondcaseofstep2,if
v[x′′,y′′] =v[x,y]∩v[xl,yl]thenx′=xs+x′′−xandy′=xs+(y′′−x′′). Forcontrolﬂowedges,weassumethatasetofranges
u1[x1,y1],...,un[xn,yn]are usedinstatement st2.
joinedtoasinglesetofdependences. Duetothelabelsonthe edges
thatrepresent theexactusedrange ofareachingdeﬁnition, thefact
thata.f2is partial killed is accommodates into the results of the
analysis without speciﬁc handling.
FilteringUnusedIntervals. The processing of the edge from l4to
l5on the dependence /an}bracketle{t/hatwidea.f3,/hatwidersd.f3,true/an}bracketri}htleads to a “dead end” as
the dependent range after the ﬁrst step is /hatwideb.f3and the use label is
/hatwideb.f1. Clearly, these two ranges are disjoint, /hatwideb.f3∩/hatwideb.f1 =∅and
thus the second step ﬁlters out this dependence, according t o the
ﬁrstcase inStep2inTable 2.
Handling Big L-value Assignments. The ﬁrst step of processing
theedgefrom l6tol7yieldsadependencyon /hatwidec.g2. Thisdataenables
us to ﬁlter out the spurious dependency when processing the e dge
from the Big L-value assignment at l7tol8, despite the obvious
immediate dependency between l7andl8.
HandlingComputational Assignments. The assignment to pinl9
is of a computational form. In this case, according to the sec ond
caseinStep1,thewholedeﬁnedrangeiscomputational depen dent
on the seed, i.e., the generated dependence is with vd=false.
Additional propagation of this dependence are all computat ional
ones.
HandlingnonValueDependences. Processingoftheedgelabeled
/hatwidei.g1betweenl10.2andl11is ona computational dependence. Step
1yieldsadependence onthewholevariable i. However,according
to the third case in step 2, since the dependence is computati onal,
only thedependent range isreﬁnedaccording tothelabel, yi elding
a dependency on /hatwidei.g1.
7. INTERPROCEDURALANALYSIS
ADASsummarizesproceduresasadependencerelationbetween
the values of the formal arguments at the entry to the procedu re
(formals in ) and the value of the returnarguments at the procedure
exit(formalsout ). Globalvariablesaretreatedasadditionalformalargumentsandreturnarguments. Thustherelationbetweenf ormals
inand formals out computed for every procedure alsoaccount s for
the procedure’s effect on global variables.
Informally, the interprocedural dependence analysis can b e de-
scribed as a two phase process: The ﬁrst phase summarizes eve ry
procedure by computing a transitive dependence relation be tween
a procedure’s formals-in and formals-out. The second phase com-
putes the ﬁeld sensitive dependences across procedures usi ng pro-
cedure’s summaries to account for the effect of procedure ca lls.
Recursiveproceduresarehandledbyrepeatingthetwosteps untila
ﬁxedpoint is reached.
Technically,ourimplementationisbasedonexistingsumma ryal-
gorithm[14]. Theﬁrststepcomputesintra-proceduraldepe ndences
between formal-intoformal-out inthe form
d=/an}bracketle{t[fout[x,y],fin[x′,y′],st1,vd/an}bracketri}ht
wherest1deﬁnes the variable fin. Given a dependence at a re-
turnstatement,a dependencestatement ,whichareusedtorepresent
procedures’ summaries, ds(d)is constructed as follows:
ds(d) =/braceleftbigg
fout[x,y] :=fin[x′,y′] ifvd=true
fout[x,y] :=exp(fin[x′,y′])ifvd=false
Thesecondstepisaniterativeprocessinwhichdependences tate-
ments of callees are used at call sites to compute the depende nce
statementsofthecaller. Thisisprocesseduntilnomoredep endence
statements are computed.
We note that a similar modiﬁcation can be applied on a more
efﬁcientsummary algorithm [15],thus improvingthe runnin g time
of the inter-procedural ﬁeld sensitive dependences analysis. We
consider such achange as part offuture work.
8. EXPERIMENTAL EVALUATION
This section presents a case study in which we evaluated ADAS
in the context of an important software engineering applica tion:customization-change impact analysis for conﬁguration ma nage-
ment ofERPsystems. Our empirical study was performed by in-
tegrating ADASinPanayaIA [6], an industrial-strength analysis
tool for computing the impact of customization changes for ERP
systems made by SAP[1], a leading ERPsoftware vendor and
written in ABAP, a proprietary language developed by SAPsince
the 1970s [16]. We begin by providing a short background rega rd-
ing analyzing ERPsystems, and then we describe our evaluation
methodology, and present our experimental evaluation of ADAS.
We note that while ADASis evaluated in the context of ERP
systems, the algorithm itselfis ofgeneric nature and isofv alue for
analyzing anyprogram whichuseslargeaggregate structure s. (See
Section9).
8.1 Analyzing ERP Systems
AnERPsystemintegratesinformationtechnologywithcorebusi-
ness processes andisintended tomanage allthe information needs
and business procedures of an (often geographically scatte red) or-
ganization. (See,e.g.,[31]). An ERPsystemistypicallycomprised
of hundreds or thousands of programs. Each program represen ts a
business process (e.g., human resources, warehouse manage ment,
project management, ﬁnancials, client relation managemen t, etc.),
and maycontain over a millionlinesof code.
ERPsystemshavebecomedominantintoday’sworldofbusiness
applications. One of the key reasons for the popularity of ER P
systems in the world of business is their modular design: Eve ry
businesscanaddandcustomizemodulestomeetitsparticula rneeds.
Ontheﬂipside,theﬂexibilityofERPsystemsmakestheirana lysis
a very challenging problem, as we discuss below.
Technically,thecustomizationofanERPsystemisdonebyst or-
ingconﬁguration tables at the system’s database and reading the
conﬁgurationattributesatruntimeintoin-memoryaggrega tesstruc-
tures,whichmaybeofsigniﬁcantsize. (Itisnotunusualtha tasingle
structurecontainshundredsofﬁelds). Theaggregatestruc turesstor-
ing the conﬁguration attributes have an immense effect on th e way
that thesystem operates. Inpractice, whenever aprofessio nal ERP
engineerwantstomodifythesystembehavior,sheupdatesap roper
conﬁguration attribute inthe system’s database.
A common programming practice in ERPsystems is to fetch
attributes pertaining to a whole structure from the databas e. These
attributes can affect the execution of multiple programs. I t is the
task of the analysis todetermine which of the ﬁelds are neede d for
thecurrentlyanalyzedprogram. Thus,anefﬁcientandpreci seway
forhandlinglargeaggregatestructurevariablesisrequir edtoobtain
a useful customization-changes impact analysis.
Due to the large code base of SAP and the sharing of libraries
between programs, we follow a modular approach. First, each
compilation-unit is analyzed separately without prior kno wledge
aboutdifferentinvocationofthecompilationunitandwith outtaking
into account the code of external libraries invocations. Ne xt, each
programisanalyzedbyinter-proceduralanalysesofthecom pilation
units that are part of this program. See [6] for more elaborat ion on
the implementation of PanayaIA .
8.2 EvaluationMethodology
Theexperimentspresentedinthissectionareonaselectedb ench-
markof12programswhichvaryinsize,complexity,andassoc iated
SAPcomponents. Timeis measured inminutes. Experiments per-
formed on a computer grid comprised of ﬁve Intel servers. Eac h
server has two Dual Intel Xeon 5355 processors and 16GB mem-
ory running Windows XP operating system (64-bit) with Java 5 .0.
In our experiments we study the differences in the quality of the
results and the cost of the analysis of three transitive depe ndencesProgram KLOC ATOM WS ADAS
#Pairs #Pairs FP#Pairs FP
SAPMF02B 3 4 525% 40%
SAPF110V 8 318500% 30%
SAPMV10A 23 512140% 50%
SAPMA01B 42 40120200% 400%
SAPMM07R 65 36 72100% 360%
SDBILLDL 115 23 46100% 22-4%
SAPLAMDP 178 168 30883% 1754%
SAPMV60A 333 275 49279% 273-1%
SAPMV50A 212 374 69786% 3914%
SAPLAIST 211 138 26491% 1444%
SAPMF02D 226 837105426% 8370%
SAPMM06B 419 -560 -456 -
Average 129 173 28162% 1751%
Table 3: The number of customization (table, column) pairs
thatimpactthebenchmarkprogramandFP,theamountoffalse
positives. The number of lines of code (LOCs) is in thousands .
Negative percentages are due to implementation issues of th e
PanayaIA tool,whichareunrelatedto ADAS.(SeeSection8.3).
algorithms: 1. ATOM: An algorithm based on the atomization ap-
proach,2. WS:analgorithmbasedonthewholestructureapproach,
and 3.ADAS.
Note that all three algorithms compute the transitive inter -
proceduraldependencesovertheSystemDependenceGraph( SDG)
usingproceduralsummarydependences. Wefocusontwocompa r-
ison criteria : the accuracy of the dependences in terms of nu mber
of false-positive (spurious dependences) and the scalabil ity of the
analysis approach in terms of time and memory. The results of the
atomization approach (ATOM) served as the most precise resu lts
and wecompared the other twoalgorithms’ results toit.
8.3 Experimental Results
Table 3 compares the accuracy of the dependences for the thre e
algorithms. Foreachprogramthetablecontainsthenumbero fcus-
tomization(table,column)pairsthathaveanimpactonthep rogram
accordingtoeachalgorithm. Column2liststhesizeofthepr ogram,
inthousands-of-lines ofcode. Column3contains the ATOMalgo-
rithm results which also serves as a reference for the other t wo
algorithms. Columns 4-5 contains the WS algorithm results a nd
the percentage of the false positives of the results compere d to the
base results. The results of the ADASalgorithm are speciﬁed in
columns 6-7.
FortheWSalgorithm,thepercentageofthefalsepositivesisrel-
ativelyhigh—anaverageof62%,andapeakof500%foraspeciﬁ c
program. For the ADASalgorithm, there is low false positive per-
centage ofonly1%onaverage. Theoretically, ADAShasthesame
precision as the WSalgorithm. Practically, there is a difference
in the precision because the implementation of the PanayaIA tool
usessomeheuristicsthroughtheanalysisthatconsideramo ngother
things thesize oftheprogram, whichisquite differentbetw eenthe
original program and the atomizedprogram.4
Facingthehighnumberof ERPprogramsthatneedtobeanalyzed
and the signiﬁcant size of the programs, the ability to scale the
algorithms has beena key element inthe success of the tool.
Table 4 lists a comparison of the three algorithms according to
theexecution timeof theanalysisforeachprogram. Asbefor e,the
4In some cases the atomized program has 4 times more statement s
thenthe original program.Program Atom WS ADAS
Time Time Imp. Time Imp.
SAPMF02B 0.59 0.57-3% 0.7630%
SAPF110V 1.43 2.2456% 1.26-12%
SAPMV10A 3.99 4.6316% 3.23-19%
SAPMA01B 11.20 12.68 13%10.65 -5%
SAPMM07R 10.11 9.27-8% 8.24-18%
SDBILLDL 24.97 20.88-16% 21.41-14%
SAPLAMDP 40.86 30.79-25% 35.81-12%
SAPMV60A 359.31 99.23-72%125.25 -65%
SAPMV50A 43.42 32.53-25% 31.56-27%
SAPLAIST 59.13 41.39-30% 51.08-14%
SAPMF02D 123.00 56.64-54% 96.71-21%
SAPMM06B -110.10 -151.74 -
Average 61.64 28.26-54% 35.09-43%
Table4: Elapsedtimeinminutesandtheperformanceimprove -
ment (Imp.). Negative percentages are due to implementatio n
issuesofthe PanayaIA tool,whichareunrelatedto ADAS.(See
Section8.3).
ATOM algorithm results serve as the base for the WS and ADAS
algorithms. We canseethat the WSalgorithm has alarge decrease
of the execution time of 54% on average with a peak of 72% on
a speciﬁc program. Interestingly, ADASis not far behind with a
decrease of 43% on average with a peak of 65%. This is without
taking intoconsideration thetime savedfor theanalysis do ne prior
to the actual computation of the transitive dependences (bu ilding
the CFG, constant propagation, etc). Although the WSalgorithm
performs fewer actions on each step than the ADASalgorithm (as
itdoesnotneedtocalculateandcompareﬁeldsensitiveprop erties),
due to its over approximated nature, it performs more steps t han
theADASalgorithm. Overall, the improvements of both ADAS
andWSalgorithmsinexecutiontimeisquitehigh,aroundthe50%.
Whereasthe WSalgorithmincludesahighportionoffalse-positives
62%,theADASalgorithmachievesthisperformanceboostwithout
hurting the accuracy of the dependences computation.
Table 5 lists the memory usage of the three algorithms for eac h
benchmark program. As expected the less precise WS algorith m
(columns3-4)hasa35%lowermemoryconsumptionthanthebas e
result of the ATOMalgorithm (column 2). Columns 5-6 contains
the results of the ADASalgorithm. We can see that the ADAS
algorithm was able to decrease the memory consumption by 31%
on average. ADASsuccessfully analyzed the largest program with
amemoryusage of5.7GBwhilethe ATOMalgorithmhasfailedto
analyze the program withinthe available heapsize (15GB).
8.4 Evaluating a More Efﬁcient Atomization
We also studied if a more efﬁcient atomization algorithm in t he
style of [26], which have shown great improvement for Cobol p ro-
grams,canreducetheperformancepenaltyoftheATOMalgori thm
in our case of ERP programs. The main idea of the optimization
suggestedin[26]istoperformtheatomizationonlyforthos estruc-
ture ﬁelds that actually used/refered in the program explic itly and
not according tothetype information. Although, inworst ca se this
approach may result in full atomization, in some cases the at om-
ization can involve only a small portion of the structure ﬁel ds. In
ordertodoso,aﬂow-insensitivealgorithmisusedtogroups tructure
ﬁelds to equivalence classes. Two structure ﬁelds are in the same
equivalence classifthereisadirectorindirectassignmen tbetweenProg ATOM WS ADAS
Mem MemImp.MemImp.
SAPMF02B 405397-2% 401-1%
SAPF110V 414397-4% 401-3%
SAPMV10A 644494-23% 522-19%
SAPMA01B 1,284 867-32% 985-23%
SAPMM07R 1,3991,069-24% 998-29%
SDBILLDL 2,5241,574-38%1,747-31%
SAPLAMDP 2,4801,770-29%1,884-24%
SAPMV60A 8,0235,044-37%5,058-37%
SAPMV50A 5,5383,305-40%3,556-36%
SAPLAIST 3,0511,993-35%2,313-24%
SAPMF02D 5,3933,345-38%3,532-35%
SAPMM06B -4,831 -5,755 -
Average 2,5961,688-35%1,783-31%
Table 5: The average memory usage (in MB) and the perfor-
mance improvement. Negative percentages are due to imple-
mentation issues of the PanayaIA tool, which are unrelated to
ADAS.(See Section8.3).
them. These ﬁelds are considered from the same type (for type in-
ference)andaredisassembled(foratomization)ifatleast oneofthe
ﬁelds isexplicitlyused.
ForERPprograms,wedeterminethatduetothealgorithm’sﬂow-
insensitive nature and the vast use of large structure varia bles, the
resulting equivalence classes are large and the number of un used
structureﬁeldsisquitelow,whichinduce atomizationofla rgepor-
tion of the structure ﬁelds (i.e the optimization unable to i mprove
performance): Table 6 contains the total number of structur e ﬁelds
(column 2) and the number of unused structure ﬁelds (column 3 )
and its ratio (column 4) for each program in our benchmark. We
canseethatonaverageapproximately20%oftheﬁeldsareunu sed,
i.e. the atomization needs to include most of the structure ﬁ eld
(over80%). Therefore,weconcludethat(inthecontextofou rcase
study) this approach does not provide a good optimization to the
full atomizationapproach.
9. CONCLUSIONSANDFURTHERWORK
Inthispaper,wepresent ADAS,astaticanalysisalgorithmwhich
conservatively computes transitive ﬁeld-sensitive progr am depen-
dences. The algorithm provides a specialized efﬁcient and p recise
handlingofprograms withlargeaggregatestructure variab les,e.g.,
large-scale ERPprograms, by performing an interprocedural anal-
ysis over a novel form of representing reaching deﬁnitions u sing
ranges.
We provide a detailed comparison between ADASand the two
known approaches for this problem: the whole structure (WS) ap-
proach andthe atomization (ATOM)approach. Weshow that,the-
oretically,ouralgorithmismoreprecisethanthe WSapproach and
aspreciseasthe ATOMalgorithm,themost-preciseknownsolution
for this problem [17].
Practically,ourempiricalresultsshowthat ADAShascomparable
performanceintimeandmemoryofthe(lessprecise) WSalgorithm
whileprovidingthesamequalityofresultsasthe ATOMalgorithm.
Indeed,using ADASwesuccessfullyanalyzedlarge ERPprograms
thatwecouldnotanalyzewiththe ATOMalgorithmusingthe(rather
vast) computational resources that we have. In a way, we can s ay
thatADASenjoys the beneﬁtsof bothknownapproaches anddoes
not suffers from their weaknesses.Program #Fields #Unused Fields % of unused
SAPMF02B 555 288 52%
SAPF110V 2,208 228 10%
SAPMV10A 9,029 1,024 11%
SAPMA01B 29,986 17,398 58%
SAPMM07R 22,600 4,491 20%
SDBILLDL 53,925 11,380 21%
SAPLAMDP 42,445 6,418 15%
SAPMV60A 69,399 16,711 24%
SAPMV50A 69,672 11,909 17%
SAPLAIST 59,936 21,151 35%
SAPMF02D 32,706 2,406 7%
SAPMM06B 82,490 11,355 14%
Average 39,579 8,730 22%
Table 6: Results of a study on the number and percentage of
unusedstructureﬁelds.
ADAShelps solving an important software engineering prob-
lem: automatically inferring the impact of customization- changes
onERPsystems. It shows that it is possible to overcome a major
challenge forprogram analysistools: providingascalable andpre-
ciseenoughanalysisforindustriallarge-scalesystems. W eattribute
thesuccessof ADAStothejudiciouschoiceoftheabstractdomain
which it employs. A choice which was guided by the characteri s-
tic of the class of programs of interest and the opportunitie s for an
efﬁcient implementation.
In this work, we concentrate on analyzing programs that mani p-
ulate large aggregate structure variables, and provided an efﬁcient
and precise solution for the problem of computing ﬁeld-sens itive
program dependences for this class of programs. Further wor kcan
explore the possibilities that lie in combining our approac h with
dependence analyses that specialized in other programming fea-
tures. Speciﬁcally, pointer manipulation of recursive dat a struc-
ture: A quite precise computation of immediate dependences for
programs manipulatingpointersandrecursivedatastructu reispre-
sented in [12]. Unfortunately, their approach may compute f alse
transitive dependences when facing Big L-value assignment s (as-
signment operations that deﬁne the value of whole structure s). We
hope that combining our techniques with theirs will allow to accu-
ratelycomputetransitiveprogramdependencesforpointer programs
which use BigL-value assignments.
Another area that canbe addressed isthe computation of depe n-
dences betweenarrayelements. Wecanthinkofanarrayasala rge
structure variables where indices are used to name subcompo nents
instead of ﬁelds. The challenging aspect of this extension i s that
array-copy operations are not as easily detectable from the syntax
oftheprogram: InsteadofusingBigL-valuesoperationstop erform
acopythecontentsaggregatestructurelocations,ascommo nlydone
instructure-manipulatingprograms,array-copyoperatio nsareusu-
ally implemented using a loop. Thus, the analysis would need to
track the index, which we believe can be done by integrating t ech-
niques developed for array-manipulating programs [9, 5].
10. REFERENCES
[1] http://www.sap.com/.
[2] A.V. Aho,M. S.Lam,R.Sethi, and J.D.Ullman. Compilers:
Principles, Techniques, and Tools . Addison Wesley,2 edition, 2006.
[3] S.Bates and S.Horwitz. Incremental program testing usi ng program
dependence graphs. In Symp. on Principles ofProg. Lang. ,1993.[4] D.Binkley. Using semantic differencing to reduce the co stof
regression testing. In Conf. on Soft. Maintenance , 1992.
[5] I.Dilling, T.Dilling, and A.Aiken. Fluid updates: Beyo nd strong vs.
weak updates. In European Symposium on Programming , 2010.
[6] N.Dor, T.Lev-Ami, S.Litvak, M.Sagiv, and D.Weiss.
Customization change impact analysis for ERPprofessional s via
program slicing. In Int. Symp. on Soft. Testing and Analysis , 2008.
[7] K.Gallagher. Using program slicing in software maintenance . PhD
thesis, Comp. Sci. Dept., Univ. of Maryland, Baltimore Camp us,
1990. Tech. Rep. CS-90-05.
[8] K.Gallagher and J.Lyle. Using program slicing in softwa re
maintenance. IEEETrans. on Soft. Eng. ,1991.
[9] D.Gopan, T.Reps, and M.Sagiv. Aframework for numeric an alysis
of array operations. In Symp. on Principles of Prog.Lang. ACM,
2005.
[10] M.Hind. Pointer analysis: HavenÃt wesolved this probl em yet. In
Work. on Prog.Analysis for Soft. Tools and Eng. ,2001.
[11] S.Horwitz. Identifying thesemantic and textual diffe rences between
two versions of a program. In Conf. on Prog.Lang. Design and
Impl.,1990.
[12] S.Horwitz, P.Pfeiffer, and T.W.Reps. Dependence anal ysis for
pointer variables. In PLDI,1989.
[13] S.Horwitz, J.Prins, and T.Reps. Integrating non-inte rfering
versions of programs. Trans.on Prog.Lang. and Syst. , 1989.
[14] S.Horwitz, T.Reps, and D. Binkley. Interprocedural sl icing using
dependence graphs. Trans. on Prog.Lang. and Syst. , 1990.
[15] S.Horwitz, T.Reps, M.Sagiv, and G.Rosay. Speeding up s licing. In
Symp. on the Foundations of Soft. Eng. ,1994.
[16] H.Keller and S.Kruger. ABAPObjects: Introduction to
Programming SAPApplications . Addison-Wesley, 2002.
[17] S.Litvak. Field sensitive program dependeces for larg e scale
systems,2009. http://www.cs.tau.ac.il/ ∼shaylitv/.
[18] J.Lyle and M.Weiser. Experiments on slicing-based deb ugging
tools. InConf. on Empirical Studies of Programming , June1986.
[19] J.R.Lyle. Evaluating variations on program slicing for debugging .
PhD thesis, University ofMaryland, 1984.
[20] S.Muchnick. Advanced Compiler Design and Implementation ,
chapter 8.12.Morgan Kaufmann, 1997.
[21] S.Muchnick. Advanced Compiler Design and Implementation ,
chapter 12.2.Morgan Kaufmann, 1997.
[22] J.Ning, A.Engberts, and W.Kozaczynski. Automated sup portfor
legacy code understanding. Commun. ACM , 1994.
[23] K.J.Ottenstein and L.M.Ottenstein. Theprogram depen dence
graph in asoftware development environment. In Symp. on Practical
Soft. Development Environments , 1984.
[24] Panaya Inc. http://www.panayainc.com. 2009.
[25] D.J.Pearce, P.H.J.Kelly, and C.Hankin. Efﬁcient ﬁeld -sensitive
pointer analysis for c. In Work. on Prog.Analysis for Soft. Tools and
Eng.,2004.
[26] G.Ramalingam, J.Field, and F.Tip.Aggregate structur e
identiﬁcation and its application to program analysis. In Symp. on
Principles ofProg.Lang. , 1999.
[27] T.Reps, S.Horwitz, and M. Sagiv. Precise interprocedu ral dataﬂow
analysis viagraph reachability. In Symp. on Principles of Prog.
Lang.,pages 49–61. ACM, 1995.
[28] M.Sagiv, T.Reps, and S.Horwitz. Precise interprocedu ral dataﬂow
analysis with applications to constant propagation. Theoretical
Computer Science , 167:131–170, 1996.
[29] M.Sridharan, S.J.Fink, and R. Bodik. Thin slicing. In Conf. on
Prog.Lang. Design and Impl. , pages 112–122. ACM, 2007.
[30] F.Tip.Asurvey of program slicing techniques. Journal of
programming languages , 3:121–189, 1995.
[31] B.Wagner and E.Monk. Enterprise ResourcePlanning . Course
Technology Press, Boston, MA,United States, 2008.
[32] M.D.Weiser. Programslices: formal, psychological, and practical
investigations ofan automatic program abstraction method . PhD
thesis, Ann Arbor, MI,USA,1979.
[33] S.H.Yong, S.Horwitz, and T.Reps. Pointer analysis for programs
with structures and casting. In Conf. on Prog.Lang. Design and
Impl.,1999.
View publication stats