Checking Conformance ofa Producer and a Consumer∗
EvanDriscoll, AmandaBurton,andThomasReps
Computer Sciences Department, University of Wisconsin –Mad ison
{driscoll,burtona,reps}@wisc.edu
ABSTRACT
This paper addresses the problem of identifying incom-
patibilities between two programs that operate in a pro-
ducer/consumer relationship. It describes the techniques
that are incorporated in a tool called PCCA(Producer-
Consumer Conformance Analyzer), which attempts to (i)
determine whether the consumer is prepared to accept all
messages that the producer can emit, or (ii) ﬁnd a counter-
example: a message that the producer can emit and the
consumer considers ill-formed.
Categories andSubjectDescriptors
D.2.12 [Software Engineering ]: Interoperability
GeneralTerms
Algorithms, Reliability
Keywords
producer-consumer compatibility, language containment,
visibly pushdown automata
1. INTRODUCTION
Complex systems today are made up of many commu-
nicating components. For instance, a modern fuel-injected
engine has a number of sensors that send their current mea-
surementstotheengine-controlunit, whichdecideswhatth e
optimum fuel-air mixture should be. It emits messages to
other components, such as the fuel pumps and fuel injectors,
to carry out its decisions.
∗Supported by NSF under grants CCF-0540955, CCF-0810053, CC F-
0904371, and CCF-0701957; by ONR under grants N00014- {09-1-
0510, 10-M-0251 }, by ARL under grant W911NF-09-1-0413; and by
AFRL under grants FA9550-09-1-0279 and FA8650-10-C-7088. Any
opinions, ﬁndings, and conclusions or recommendations exp ressed in
this material are those of the author(s) and do not necessari ly reﬂect
the views of the sponsoring agencies.
Permission to make digital or hard copies of all or part of this w ork for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage and th at copies
bearthisnoticeandthefullcitationontheﬁrstpage. Tocop yotherwise, to
republish,topostonserversortoredistributetolists,re quirespriorspeciﬁc
permission and/orafee.
ESEC/FSE'11, September5–9, 2011,Szeged, Hungary.
Copyright2011ACM 978-1-4503-0443-6/11/09...$10.00.In such systems, it is vitally important to ensure that the
messages that one component sends to another are under-
stood by the receiving component, otherwise runtime errors
will occur. Send/receive incompatibilities can drive up th e
cost of developing a system because diﬀerent components of
asystemareoftendevelopedbydiﬀerentdevelopmentteams
or diﬀerent subcontractors, and thus compatibility proble ms
may not be detected until integration time. (The cost of ﬁx-
ing errors found late in the development process is usually
much higher than that of errors found earlier.)
Consider an example system made up of the producer and
consumer shown in Figs. 1 and 2, respectively. The producer
is a program that monitors a sensor, and periodically sends
a “packet” of data to the consumer.1The system uses an
abbreviated protocol: if the sensor data has not changed
since the last message, then only the Boolean literal false
is sent. Line 2 in Fig. 1 makes this decision.
As presented, these components are correct: both“speak”
the same protocol. However, consider a buggy version of the
consumer that does not account for the possibility that the
producer sends an abbreviated message, and always expects
the full packet. This code is shown in Fig. 3.
To ﬁnd this bug, can we reason about the languages over
which each component operates? In the consumer, we know
that theupdateReading function always reads a doubleand
then abool. Furthermore, each time through the loop in the
buggy version of main, the consumer reads a boolthen the
double–boolsequence from updateReading . Thus we can
determine that the input language of the buggy consumer,
expressed as a regular expression over types that the con-
sumer reads, is (bool double bool)+ . Similarly, we can de-
termine that the output language of the producer, expressed
as a regular expression, is (bool | bool double bool)+ .
From these two language descriptions we can see that one
of the components is buggy: the string bool bool , is in the
producer’s language but not in the consumer’s. This dispar-
ity suggests that some execution of the producer could out-
put two Boolean values, but noexecution of the consumer
would expect to read that message.
A similar analysis suggests that Fig. 2’s consumer is cor-
rect. The language it expects is (bool (double bool)?)+ ,
which is equivalent to what we inferred for the producer.
Wedescribeatechniquefordeterminingwhethertwocom-
ponents are compatible, which proceeds along lines similar
to this example: we infer a model of the output language
of the producer, infer a model of the input language of the
1We use packetto refer to the data that the components
communicate each time through their“loop”.1 sendReading(Sensor* device, int prev)
2 if device→setting == prev then
3 writeBool( false);
4 else
5 writeBool( true);
6 writeDouble( device→setting);
7 writeBool( device→valid);
8 loop(Sensor* device, int prev)
9...// update device with new readings
10sendReading( device, prev );
11 if ...then
12 loop(device, device →setting);
13 main()
14Sensordevice;
15loop(&device, -1 );
Figure 1: Example producer
1 updateReading(int* setting, bool* valid)
2*setting = readDouble() ;
3*valid = readBool() ;
4 main()
5 int setting;
6 bool valid;
7 while ...do
8 if readBool() then
9 updateReading (&setting, &valid);
10 ...// do something with current readings
Figure 2: Example consumer
consumer, and determine whether the two descriptions are
compatible. However, we also investigate using a richer fam -
ily of languages than just regular languages for the format
descriptions, and thus the check of whether the models are
compatible is more than straight language-containment.
This paper addresses the following problem: Given two
programs that operate in a producer/consumer relationship ,
(i) determine whether the consumer is prepared to accept all
messages that the producer can emit, or (ii) ﬁnd a counter-
example: a message that the producer can emit but the
consumer considers ill-formed.
We have implemented our technique in a tool called PCCA
(forProducer-Consumer Conformance Analyzer). Given
the two source programs, along with information about
which functions perform I/O (see §4.1),PCCAinfers a de-
scription of the language that the producer generates and
a description of the language that the consumer expects,
and (roughly speaking) determines whether the former is a
subset of the latter.
PCCAstarts out by creating an automaton Pthat models
the producer, which accepts an over-approximation of the
language that the producer emits. We have two versions of
PCCA: one creates a pushdown automaton (PDA) and the
other creates a standard ﬁnite automaton (FA). Similarly,
PCCAproduces an automaton Cfor the consumer, which
accepts an over-approximation of the language that the
consumer expects. Our goal becomes determining whether
L(P)⊆L(C). For the FA version, we do this directly. For
the PDA version, this question is undecidable with a direct1 main()
2 while ...do
3 readBool() ;
4 updateReading (&setting, &valid);
5 ...// do something with current readings
Figure 3: Example buggy consumer.
(updateReading is the same as in Fig. 2.)
approach; thus we actually use a restricted form of PDAs
calledvisibly pushdown automata [3, 2] (VPAs) to model the
components’ behaviors. While less powerful than full PDAs,
VPAs provide enough power to recognize important classes
of non-regular languages, such as balanced parentheses.
Unlike PDAs, the restrictions on VPAs allow them to re-
tain closure under complementation and intersection, and
thus language containment is decidable. However, when us-
ing VPAs we must make internal calls and returns explicit in
thewordsofthelanguagesthat PCCAinfersfromthecompo-
nents. If PCCAwere to check containment of these languages
directly, we would be requiring that the two components
have the same internal call/return structure, which is un-
desirable. To compensate, PCCA“enriches” the consumer’s
VPAC—and hence its language L(C)—so that diﬀerences
in the call/return structures of the producer and the con-
sumer do not preclude answering the language-containment
question. (This step is explained in more detail in §3.2.)
To test language containment, PCCAperforms a set-
diﬀerence operation to compute L(P)/integerdivideL(C) (for the FA
version) or L(P)/integerdivideL(Enrich( C)) (for the VPA version) by
complementingtherighthandautomatonintersectingthere -
sult with P. Finally, it tests whether the language of the
VPA produced by the intersection is empty. If so, then the
subset holds, and PCCAreports the components are compat-
ible; if not, then there is a counter-example in the diﬀerence
andPCCAreports the components are incompatible.
The techniques used in PCCAare“transport-agnostic”as
long as the producer and the consumer use a stream-like in-
terface to communicate. That is, PCCAcan analyze a pair
of programs—or even the sameprogram playing the roles of
both producer and consumer—that share ﬁles, send infor-
mation over sockets, or use standard I/O.
Because it is necessary to approximate each component’s
language, the technique we have developed has some limi-
tations. Both approximations are over-approximations: i.e. ,
the producer’s model may say that the producer can emit
a string that can never actually be emitted by the pro-
ducer, and similarly for the consumer. Consequently, the
compatibility-checking technique can have both false pos-
itives and false negatives, which puts PCCAamong other
bug-hunting approaches, such as work developed by Engler
et al. [16, 22] as well as many other authors.
Our contributions can be summarized as follows:
•We describe our approach to format inference, inspired
by Lim et al. [23], and its application to component
compatibility.
•The model of the program can be described using a
context-free language, but testing language contain-
ment for CFLs is not decidable. We describe how to
side-step this problem by using VPAs, making the in-
ternalcallsandreturnsofthecomponentsexplicit, and
performing our Enrich operation.M: main entry L: loop entry sendentry
sendexit loopexit mainexit/an}bracketle{t,↓M /an}bracketle{t,↓L bool
double
bool /an}bracketri}ht,↑L /an}bracketri}ht,↑M/an}bracketle{t,↓L /an}bracketri}ht,↑L
/an}bracketri}ht,↑L
/an}bracketri}ht,↑L/an}bracketri}ht,↑M
Figure 4: The producer’s VPA. To reduce clutter, all
transitions to the implicit “stuck state” are omitted
and sendReading is abbreviated as send.
•We compare the results of a VPA-based model to those
obtained by using ordinary ﬁnite automata.
•We describe a new algorithm for determining the emp-
tyness of a VPA, which builds on existing work related
to pushdown systems.
•We implemented our techniques in a tool called PCCA,
and demonstrate its utility on several examples.
Organization. The remainder of the paper is organized as
follows: §2 discusses our goals and the methods we use to
achieve them. §3 discusses the indiv steps that that make
up our technique when PCCAis operating using VPAs. §4
describes the prototype implementation. §5 presents exper-
imental results. §6 discusses related work. §7 has a brief
discussion of future work.
2. OVERVIEW
Wenowgiveadescriptionofourtechnique, framedaround
how it operates on the example considered in the Introduc-
tion. We ﬁrst consider the producer and the correct version
of the consumer, as presented in Figs. 1 and 2, respectively.
(Ex. 2.3 covers the buggy version of the consumer.)
From the standpoint of checking that the producer and
consumer are compatible, even this simpliﬁed example has
a number of challenging features. In particular,
1. The producer’s loopprocedure uses recursion in-
stead of iteration. In contrast, the consumer is more
straightforward: it reads values in a loop.
2. The calls to the write functions in the producer and
the read functions in the consumer are organized dif-
ferently. The producer calls all the write_* functions
from the same procedure, while the consumer reads
the second two ﬁelds ( double bool ) in a diﬀerent pro-
cedure from the one in which it reads the ﬁrst ( bool).
PCCAis provided the information that the read_*and
write_* functions are“special”(in that they perform I/O);
in§4.1, we discuss how this information can be supplied.
As mentioned earlier, PCCAis able to use two diﬀerent
formalisms to model the components: visibly pushdown au-
tomata (VPA) and standard ﬁnite automata (FA).
2.1 Visibly PushdownAutomata
From each component we infer a visibly pushdown au-
tomaton when operating in that mode. VPAs [3] are a re-M: main entry M: main exit
updateReading exit updateReading entrybool
/an}bracketle{t,↓M
double bool/an}bracketri}ht,↑Mbool
Figure 5: The consumer’s VPA.
striction of ordinary pushdown automata, and can be used
in program analysis to capture the matched call and return
structure of execution traces through multi-procedure pro-
grams. In essense, each alphabet symbol describes whether
a VPA is allowed to push or pop a symbol from its stack. We
formally deﬁne VPAs in §3.1, but for purposes of this section
it suﬃces to know that, even though they share some power
with general PDAs, determining language containment of
two VPAs remains decidable, in contrast to PDAs.
In our application, the alphabet consists of the types that
are emitted by the producer and read by the consumer, as
well as distinguished call and return symbols /an}bracketle{tand/an}bracketri}ht.
For expository purposes, we talk about the producer au-
tomaton“emitting”strings. Neither FAs nor VPAs actually
emit anything (except a yes/no answer); what we mean is
that a given string is accepted by the producer’s automaton.
However, if a string is accepted by the producer’s automa-
ton, that means it could be emitted by the producer pro-
gram, and it is often convenient to think of the automata as
being the components themselves, rather than models.
2.2 InferringThe I/OFormat
The ﬁrst step in the process is to infer an automaton that
approximates the language of each component. In the case
of the producer, we wish to infer the language of all possible
outputs; in the case of the consumer, we wish to infer the
language of all expected inputs.
The idea behind our technique is to create automata that
mimic the control-ﬂow behavior of the source programs.
Eachautomatonthat PCCAgenerateshasthesamelanguage
as one created by transliterating the program’s interproce -
dural control-ﬂow graph (ICFG) in the following manner:
1. There is one state ˜ cfor each ICFG node c.
2. If a call site ccan call an I/O function that outputs
or expects a value of type τ, we add a transition on τ
from ˜cto its corresponding return node. In the VPA
model, this transition does not modify the stack.
3. If a call site ccan call a non-I/O function fwith entry
nodefeand exit node fx, we add one transition from
˜cto˜feand a second transition from ˜fxto the corre-
sponding return site. In the FA model, both transi-
tions are εtransitions. In the VPA model, the ﬁrst
transition is on the symbol /an}bracketle{tand pushes ˜ conto the
VPA’s stack, and the second transition is on the sym-
bol/an}bracketri}htunder the condition that ˜ cis at the top of the
stack (which is then popped).
4. AllothertransitionsintheICFGbecome ε-transitions.
In the VPA version, these do not modify the stack.
5. The entry node of main becomes the start state, and
the exit node becomes the sole accepting state.
However, if we used this naive translation, the result-ing automata would be extremely large, which would cause
problems during the determinization phase of PCCA.2
Instead of treating the ICFG as a whole, PCCAproceeds
procedure-by-procedurethrough the program. For each pro-
cedure, it looks at the intraprocedural CFG and carries out
the above translation, except that step 3 is replaced by the
following:
•If a call site ccan call a non-I/O function f, we add an
internal transition from ˜ cto the corresponding return,
labeled with a generated symbol call_f.
(Also, the VPA’s starting and accepting states are the entry
and exit nodes of that procedure.)
Even in the VPA version, because each procedure’s au-
tomation has no transitions that modify the stack (stack
operations only happen on a call or return), it can be in-
terpreted as a standard ﬁnite-state machine. We do this,
and use the standard algorithms to determinize and min-
imize each procedure’s machine. ( PCCA’s implementation
uses the OpenFST library for this purpose [1].) The eﬃ-
ciency upshot is that this technique turns what would be a
multiplicative factor into an additive one, thus dramatica lly
reducing the time spent in determinization.
Once we have the collection of minimized automata, we
combine all the automata into one and“restore”the call and
return transitions. We replace each transition that moves
from state ctorwhen reading a symbol call_fwith a pair
of transitions that match those in the original step 3:
•We add a transition from ctof’s entry point. In the
FA version, this is an εtransition; in the VPA version,
it is on the symbol /an}bracketle{tand pushes conto the stack.
•Weaddatransitionfromtheexitpointof ftor. Inthe
FA version, this is an εtransition; in the VPA version,
it is on the symbol /an}bracketri}htand requires that cappears at the
top of the stack (which is then popped).
Finally, we have to perform one more determinization step
in case connecting the procedures adds nondeterminism.
This translation essentially abstracts the program to its
controlﬂow only: data is not considered. One could envision
a higher-ﬁdelity translation that weaves selected data ele -
ments (or abstractions of data elements) into the automata
we infer, but of course there is a trade-oﬀ between precision
and automaton size.
Figs. 4 and 5 show the VPAs that are inferred from the
codeinFigs.1and2, respectively. (Toreduceclutter, Figs .4
and 5 have ε-transitions collapsed, which removes 7 states
and a comparablenumber of transitionsin each automaton.)
Call-transitions have labels of the form“ /an}bracketle{t,↓X”, where Xis
the state at the source of the transition, and ↓Xmeans that
Xis pushed onto the call stack. Return-transitions have
labels of the form “ /an}bracketri}ht,↑X”, which means that the machine
can make the transition only if state Xis on the top of the
stack; in so doing, it pops X. The FA version is similar,
except that all call and return transitions are replaced with
εtransitions.
KnowledgeaboutI/Ofunctions. PCCAneeds information
aboutwhatfunctioncallscanperformI/O.Thereareanum-
ber of ways the user can provide such information (see §4.1).
One important point is that there needs to be agreement
between the producer and consumer regarding what types
2As shown in §5, determinization dominates execution time.are used. The ﬁrst, and easiest, issue related to this point i s
that the names of the types must agree.
The second issue is that the granularity of the I/O func-
tion speciﬁcations must agree. Consider our example. As
written, both the producer and consumer have I/O oper-
ations expressed in terms of their constituent C types. It
would also be possible to have the producer and consumer
store values in a two-element structure SensorData , and do
a “bulk read/write” with fread()/fwrite() to operate on
the struct as a whole. In such a case, it would be reasonable
to say that the type of that I/O operation was SensorData .
However, the two approaches cannot be mixed: the con-
sumer and producer need to agree on the granularity.
Remark . The need for agreement between the producer
and consumer on the granularity of types is not a fundamen-
tal limitation: it would be possible to have the user specify
thatSensorData is a{double,bool}struct at either the
format-inference stage or after the VPAs are constructed,
and it should even be possible to extract this information
from struct deﬁnitions in the code. We have not investi-
gated these avenues at this point; however, with the current
implementation the user has the ability to specify, for ex-
ample, that a particular call to fread/fwriteoperates on a
doubleand then a bool.2
2.3 Enrichingthe Consumer’sVPA
This section applies to the VPA version of PCCAonly;§3.2
describes the operation formally.
It would be too restrictive to demand that the producer
and consumer perform calls and returns at corresponding
moments during their executions. The VPAs that we infer
from the producer and consumer follow the same call/return
behavior as the original programs; thus the strings in the
languages of the producer and consumer models contain in-
ternal call and return symbols that are not actually present
in the messages between components. Checking contain-
ment of the languages of the inferred models would require
that the components agree in this respect.
Our running example illustrates the issue. Each“packet”
consists of a Boolean, optionally followed by a double and a
Boolean. The producer sends the entire packet within one
function ( sendReading ), but the consumer reads the ﬁrst
Boolean, and then calls another function ( updateReading )
to read the remaining values of the packet.
The consequence of the producer and consumer having
diﬀerent calling structure is that the substrings that cor-
respond to the same packet are diﬀerent in the producer’s
language and the consumer’s language.
Example 2.1 Consider the string bool double bool , emit-
ted by Fig. 1’s code when the producer performs just one
iteration—hence the string contains just a single packet. F or
the producer’s VPA (Fig. 4), the string would be /an}bracketle{t /an}bracketle{tbool
double bool /an}bracketri}ht /an}bracketri}ht, while for the consumer’s VPA (Fig. 5),
the corresponding string would be bool/an}bracketle{tdouble bool /an}bracketri}ht.
These strings have /an}bracketle{tand/an}bracketri}htin diﬀerent locations. 2
To accommodate the diﬀerent nesting structures, we“en-
rich”the consumer’s VPA so that it can use nondeterminism
to guess when the producer makes an internal call or return
and insert the corresponding symbol into its own strings.
Example 2.2 For the example discussed in Ex. 2.1, the lan-
guageoftheconsumer’senrichedVPAcontainsnotjust bool/an}bracketle{tdouble bool /an}bracketri}htbut also /an}bracketle{t /an}bracketle{tbool double bool /an}bracketri}ht /an}bracketri}ht. The
latter string is in the languages of both the producer’s VPA
and the consumer’s enriched VPA. 2
After enrichment, a counterexample to the language con-
tainment (and an indication of incompatibility) is a string
that the producer’s NWA can emit where it is impossible
to add and/or remove balanced parentheses and arrive at a
string that the consumer’s NWA accepts.
Example 2.3 For the buggy consumer in Fig. 3, the origi-
nal language contains strings such as bool/an}bracketle{tdouble bool /an}bracketri}ht,
but not, for instance bool bool (which is in the producer’s
VPA’s language). Denote by Cethe VPA inferred for the
buggy consumer. No matter how you add parentheses to
bool bool , you will not arrive at a string in the language
of Enrich( Ce); this will be a counterexample to language
containment. 2
If an analyst knows that both components use the same
call/returnstructure, he can omit the enrichmentstep to ob -
tain a more precise comparison of the two languages. With-
out the approximation caused by Enrich, a“compatible”re-
sult is more credible; however, if there is uncertainty in th e
call/return assumption, an“incompatible”result is less c red-
ible.
2.4 Language Containment
Once we have the producer automaton Pand the con-
sumer automaton C′(for the VPA version, C′is the en-
riched consumer automaton), determining the set diﬀerence ,
and thus containment, of their languages is straightforwar d:
L(P)/integerdivideL(C′) =∅iﬀL(P)∩L(C′) =∅. Both FAs and
VPAs are closed under all of these operations, so all that is
necessary is to take C′, complement it, intersect it with P,
and test the resulting VPA for emptiness. §3 discusses this
step in greater detail for VPAs.
2.5 Helping PCCAImproveits Results
We now return to the running example to illustrate how
the programmer could improve the results of the analysis.
We start by describinga bug that PCCAwould not be able to
ﬁnd, and then explain how to modify the code—but without
changing the actual protocol—so that the bug isfound.
Suppose that the speciﬁcation of the protocol changed
during development: the ﬁnal boolﬁeld was not originally
needed, but was added later. Suppose that the implemen-
tation of the producer waschanged to emit this ﬁeld, but
the consumer was not updated. (In other words, line 7 in
Fig. 1 was added at the time the speciﬁcation changed. The
consumer shouldhave been changed to add line 3 in Fig. 2,
but that line was erroneously omitted.)
This situation would almost certainly signify a bug, but
it would notbe detected by our tool. The reason is that
there is no association between the function call on lines 3
and 5 in the producer, which writes the ﬁrst boolin each
packet, and line 8 in the consumer, which reads it. Instead,
the consumer could“use”the call on readBool on line 8 to
consume the ﬁnal ﬁeld of the previous packet, then not call
updateReading during that iteration.
We can modify the source code of the producer and con-
sumer to make it possible for our technique to detect the
previous bug. The problem that our technique has with
detecting this bug is that what the producer and consumerthoughtwerepacketsgotoutofsync. Byinsertinga“phony”
I/O call at the start or end of each loop (e.g., in the el-
lipsis on line 9 of the producer and between lines 8 and 9
in the consumer), we can make the packet divisions visi-
ble toPCCA, allowing it to check that the producer’s and
consumer’s packets cannot get out of sync.
The phony calls would have a type that does not appear
in the packet itself; in our experiments we have called it SEP.
The key point to realize is that this“type”does not have to
have any material presence in any of the communications,
and in fact the function that performs the phony I/O can
be completely empty.
This idea can be generalized to“hijack”the compatibility
algorithm to ensure that eventsthat should occur during
the execution of the producer and consumer occur in the
proper order. From this point of view, a write operation is
essentially an event, during which the fact that the program
communicates is only incidental.
3. FORMALIZATION OF VPA-BASED
CONTAINMENT CHECKING
ThissectiondiscussesthedetailsofhowPCCAdetermines
whethertheproducer’slanguageis asubsetofthe(enriched )
consumer’s when using visibly pushdown automata (VPAs).
Using VPAs provides a potential beneﬁt over FAs (see §3.3)
butintroducesanumberofcomplicationstotheprocessthat
are not present with standard ﬁnite automata.
3.1 VisiblyPushdownAutomata
Definition 3.1 ([3]) A VPA is a pushdown automaton
(PDA) that operates on a tagged alphabet and whose stack
accesses are restricted by the current symbol. A tagged
alphabet ˜Σ is a partition of a normal alphabet into dis-
joint subsets Σ, Σ c, and Σ r. In our application, Σ c={/an}bracketle{t},
Σr={/an}bracketri}ht}, and Σ is the set of types on which the program
being analyzed operates. (In program analysis, pairs of sym-
bols in Σ cand Σ rare often used to model program calls and
returns; they can also be used to represent other matched
entities such as opening and closing XML tags.)
Avisibly pushdown automaton Vis a 6-tuple
(Q,˜Σ,Γ⊥,δ,q0,F) where Qis the set of states, ˜Σ is a
tagged alphabet, Γ ⊥is the stack alphabet (with ⊥, a spe-
cial bottom-of-stack symbol, and Γ = Γ ⊥/integerdivide{⊥}),q0∈Qis
the initial state, and F⊆Qis the set of ﬁnal states. The
transition relation, δ, is the union of three components:
•δi⊆(Q×Σ)×Q
•δc⊆(Q×Σc)×(Q×Γ)
•δr⊆(Q×Σr×Γ⊥)×Q
A VPAMreads its input and makes transitions on each
symbol as follows. If the current symbol is σ, the current
state isq, andγis at the top of the stack, then:
•Ifσ∈Σ, then Mselects a transition (( q,σ),q′) from
δiand changes its control state to q′.
•Ifσ∈Σc,Mselects a transition (( q,σ),(q′,γ′)) from
δc, pushes γ′onto its stack, and changes to state q′.
•Ifσ∈Σr,Mselects a transition (( q,σ,γ),q′) fromδr,
popsγfrom its stack, and changes to state q′.
The VPA accepts its input if there is a run that ends in a
ﬁnal state f∈F.
The behavior above can be expressed as limiting the op-
eration of a standard PDA in the following way: when read-
ingσ∈Σ, the VPA cannot access the stack; when readingσc∈Σc, the VPA must push exactly one symbol; and when
readingσr∈Σr, the VPA must pop exactly one symbol. In
this way, the VPA’s stack accesses are visible in each input.
We refer to the σ∈Σ asinternal symbols, the σc∈Σc
(and the positions in a string at which they appear) as calls,
andσr∈Σr(and their positions) as returns .2
We take Γ = Qand construct VPAs that, when in state
qwith a call as the current symbol, push qonto the stack.3
We also allow internal ε-transitions in the natural way.
3.2 Enrichment
As discussed at a high level in §2.3, it is unreasonable
to demand that the producer and consumer have the same
call/return structure, so we introduce an “enriching” oper -
ation, denoted by Enrich, that when applied to the con-
sumer’s VPA will relax the requirement. Enrich creates new
transitions in the consumer’s VPA that allow it to make
arbitrary calls and returns. In essence, this allows the con -
sumer’s VPA to emulate the call/returnstructureof the pro-
ducer’s VPA. Enrich is deﬁned as follows:
Definition 3.2 Given VPA A= (Q,Σ,q0,δ,F), augment δ
with the following transitions:
1. For every state p, introduce a call transition δc(p,/an}bracketle{t,p).
2. For every pair of states ( p,q), introduce a return tran-
sitionδr(p,q,/an}bracketri}ht,p).
3. For every call transition δc(p,/an}bracketle{t,q) in the original VPA,
introduce a ε-transition δi(p,ε,q).
4. For every return transition δr(p,p′,/an}bracketri}ht,q) in the original
VPA, introduce a ε-transition δi(p,ε,q).2
Items 1 and 2 allow the consumer’s enriched VPA to per-
form extra call or return moves to emulate the producer
VPA, while items 3 and 4 allow the consumer’s enriched
VPA to omit calls or returns, in case the producer has fewer.
Example 3.3 The example discussed in Exs. 2.1 and 2.2
requires all four steps: to match the producer, the consumer
needs to add two calls to the beginning of the input string,
add two matching returns to the end of the input string, and
remove the“extra”call between the ﬁrst“bool”and“double”
and its corresponding return. 2
While in theory it is possibleeither to enrich the consumer
to match the producer or enrich the producer to match the
consumer, in practice only the former is reasonable. The
goal of the containment check is to determine the emptiness
L(P)/integerdivideL(C). Enriching a VPA enlarges its language, so
this operation adds some error Eto one of the operands,
resulting in either ( L(P)∪E)/integerdivideL(C) orL(P)/integerdivide(L(C)∪
E). Unfortunately, the error introduced by enriching the
producer’s VPA invariably leads to false positives: for the
consumer to accept everything that the enriched producer
emits, the consumer would have to accept every possible call
structure of every string the producer emits.
3.3 Beneﬁtsof UsingVPAs
There are several kinds of automata that we could have
chosen. For instance, the FA version of PCCAmodels each
3Following [3], this restriction is called a “weakly-
hierarchical VPA”, and does not reduce the expressiveness.1 outputInt()
2writeInt() ;
3 producerMain()
4 if ...then
5 outputInt() ;
6 else
7 writeChar() ;outputInt() ;writeChar() ;
8 inputInt1()
9readInt() ;
10 inputInt2()
11readInt() ;
12 consumerMain()
13 if ...then
14 inputInt1() ;
15 else
16 readChar() ;inputInt2() ;readChar() ;
Figure 6: Components that illustrate the beneﬁts
of VPAs
program as a single ﬁnite automaton. This approach re-
moves the need for the enrich operation because calls and
returns are not represented explicitly in the languages.
The trade-oﬀs between VPAS and FAs mirror trade-oﬀs
that one can make in traditional interprocedural dataﬂow
analysis. The simplest way of performing such analysis is to
build the ICFG and run the analysis as if call and return
edges were just normal intraprocedural control-ﬂow edges.
However, that approach loses precision because of suprious
data ﬂows from one call site c1, into the called function f,
and then out the return edge to a diﬀerent call site c2. A
similarkindofimprecisioncanaﬀecttheFAversionof PCCA.
For instance, Fig. 6 shows a producer and consumer for
which FAs and VPAs produce diﬀerent results. Due to space
constraints we omit diagrams of the inferred automata. The
FA version of PCCAinfersint | char int char for the lan-
guage of the consumer, but int | char int | int char |
char int char for the producer. The producer’s language
contains two words that are not in the language of the con-
sumer, thus the FA version of PCCAreports that the com-
ponents are incompatible.
One way of getting around this problem is to perform
function inlining: each call site cgets its own copy of the
procedure f, which is only called from cand only returns
toc. This eliminates the suprious control ﬂows, but at the
cost of a potentially exponentially larger model. It would be
possible to do exactly the same thing in our domain: create
a single FSM, but inline procedures.
A more sophisticated mechanism for eliminating these
spurious ﬂows uses context-free-language reachability tec h-
niques [31]. This marks each call/return edge pair with a
distinct set of matched parentheses; possible executions of
the program correspond only to strings with matched paren-
theses. Thedataﬂowproblemcanbeformulatedsothatonly
ﬂows along such well-matched paths are considered. Our use
of VPAs closely mirrors this approach for the producer.4
4CFL-reachability distinguishes acceptable return edges
from unacceptable ones by whether the brackets match; our
VPAs distinguish them by whether the corresponding call
site is on the VPA’s stack.The code in Fig. 6 beneﬁts from this increase in precision.
The VPA’s constraints on the return transitions from the
exit node of outputInt to each of the two return sites re-
stricts the data ﬂow, thus the producer’s language is inferr ed
to be/an}bracketle{tint/an}bracketri}ht |char/an}bracketle{tint/an}bracketri}htchar. The VPA version of PCCA
reports that the two components are compatible.
Unfortunately, this beneﬁt only applies to the producer’s
model: the enrich operation we do to the consumer essen-
tially makes a regular approximation out of the original. We
have not investigated applying the ideas of inlining to obtai n
increased precision, although we think it would be possible .
In other words, using VPAs to model the components pro-
vides a way to obtain a context-sensitive analysis in one of
the components without the exponential blowup of inlining.
3.4 ComplementandIntersection
As mentioned in §2.4, determining the set diﬀerence of the
producer VPA and the enriched consumer VPA, is straight-
forward: L(P)/integerdivideL(Enrich( C)) =∅iﬀL(P)∩L(Enrich( C)) =
∅, and VPAs support all of the required operations.
3.5 CheckingEmptiness
Although other algorithms are known even for general
PDAs, for completeness we describe a new algorithm that
we devised, which harnesses previously known operations
for answering reachability queries on pushdown systems
(PDSs). Our approach is purely automata-theoretic, and
does not translate the VPA language to a context-free gram-
mar. We can use the witness tracing [32] feature supported
by the PDS reachability operation ( post∗) to trace non-
emptiness answers back to a string that is in the producer’s
VPA’s language but not in the consumer’s; such a string
suggests a potential bug in one of the components.
To describe the algorithm, it is necessary to review some
known results about PDSs [5, 14].
Definition 3.4 Apushdown system (PDS) is a three-
tupleP= (P,Γ,∆), where Pis a ﬁnite set of control
locations , Γ is a ﬁnite set of stack symbols , and ∆ ⊆
P×Γ×P×Γ∗is a ﬁnite set of rules. Aconﬁguration
ofPis a pair /an}bracketle{tp,u/an}bracketri}htwherep∈Pandu∈Γ∗. A rule r∈∆
is written as /an}bracketle{tp,γ/an}bracketri}ht֒/→ an}bracketle{tp′,u/an}bracketri}ht, wherep,p′∈P,γ∈Γ, and
u∈Γ∗. The rules deﬁne a transition relations ⇒on con-
ﬁgurations of Pas follows: If r=/an}bracketle{tp,γ/an}bracketri}ht֒/→ an}bracketle{tp′,u′/an}bracketri}ht, then
/an}bracketle{tp,γu/an}bracketri}ht ⇒ /an}bracketle{tp′,u′u/an}bracketri}htfor allu∈Γ∗.2
Because the number of conﬁgurations of a PDS is un-
bounded, it is useful to use ﬁnite automata to describe cer-
tain inﬁnite sets of conﬁgurations.
Definition 3.5 Aconﬁguration automaton that deﬁnes
a language of conﬁgurations of PDS P= (P,Γ,∆) is a ﬁnite-
state automaton C= (S,Γ,→,P,F), where Sis a ﬁnite set
of states, CusesP’s set of stack symbols Γ as its alphabet,
→⊆S×Γ×Sis the transition relation, the set of initial
states consists of P’s set of control locations P(which must
be a subset of S), andF⊆Sis the set of ﬁnal states. We
say that a conﬁguration /an}bracketle{tp,u/an}bracketri}htisaccepted by conﬁguration
automaton CifCcan accept u(in the ordinary sense from
the theory of ﬁnite-state automata) when it is started in the
statep; that is, pu−→∗s, where s∈F. A set of conﬁgura-
tions is said to be regular if some conﬁguration automaton
accepts it. 2Let⇒∗denote the reﬂexive transitive closure of ⇒. For
a set of conﬁgurations C,pre∗
P(C)def={c′| ∃c∈C:c′⇒∗c}
andpost∗
P(C)def={c′| ∃c∈C:c⇒∗c′}—i.e., backward
and forward reachability, respectively, with respect to tr an-
sition relation ⇒. When Cis a regular language of conﬁg-
urations, automata for the conﬁguration languages pre∗
P(C)
andpost∗
P(C) can be constructed by algorithms that run in
time polynomial in the size of P[5, 14].
Given a VPA A, the ﬁrst step of checking whether L(A) =
∅is to convert Ato a PDS PA.
Definition 3.6 Given VPA A= (Q,˜Σ,Q,δ,q 0,F), we de-
ﬁne PDS PA= ({s},Q,∆), where each transition of Ais
converted to one or two rules in ∆, as follows:
•For each transition (( q,σ),q′)∈δ, ∆ has a rule
/an}bracketle{ts,q/an}bracketri}ht֒/→ an}bracketle{ts,q′/an}bracketri}ht.
•For each transition (( q,σc),(q′,γ))∈δ, ∆ has a rule
/an}bracketle{ts,q/an}bracketri}ht֒/→ an}bracketle{ts,q′q/an}bracketri}ht. (This pushes q′onto the stack, the
top of which is currently q.)
•For each transition (( q,γ,σ r),q′)∈δ, ∆ has two rules,
/an}bracketle{ts,q/an}bracketri}ht֒/→ an}bracketle{tsx,ε/an}bracketri}htand/an}bracketle{tsx,γ/an}bracketri}ht֒/→ an}bracketle{ts,q′/an}bracketri}ht. (Conceptually
this can be thought of as a single transition /an}bracketle{ts,qγ/an}bracketri}ht֒→
/an}bracketle{ts,q′/an}bracketri}htof a preﬁx rewriting system [8].)
One can interpret this conversion as simply moving the in-
formation in the VPA’s ﬁnite control into the top symbol of
the stack. 2
In our application, the initial state of the producer’s VPA
ismainentry, and the only ﬁnal state is mainexit. Assum-
ing that mainis never invoked recursively, we only consider
perfectly-matched strings (those with balanced calls and re -
turns) and whether the set of perfectly-matched strings is
empty. To test this condition, we create trivial conﬁguratio n
automata for the languages of initial-state and ﬁnal-state
conﬁgurations (where the machine has an empty stack)
L(InitialConﬁgurations) = {/an}bracketle{ts,q0/an}bracketri}ht}
={/an}bracketle{ts,mainentry/an}bracketri}ht}
L(FinalConﬁgurations) = {/an}bracketle{ts,f/an}bracketri}ht |f∈F}
={/an}bracketle{ts,mainexit/an}bracketri}ht}
We can check whether the set of perfectly-matched strings
is empty by answering the question of whether there
is a path in the transition relation ⇒from a conﬁg-
uration in L(InitialConﬁgurations) to a conﬁguration in
L(FinalConﬁgurations). One way to answer this question
is to check whether the language of the ﬁnite-state automa-
ton constructed as follows is empty:
FinalConﬁgurations ∩post∗
PA(InitialConﬁgurations) .(1)
(This reduces the question of VPA emptiness to emptiness
of the language of an ordinary FA.)
Remark . The more general question of VPA emptiness
when non-perfectly-matched strings are of interest can also
be addressed using Eqn. (1): one merely has to use more
elaborate languages of initial and ﬁnal conﬁgurations. 2
4. IMPLEMENTATION
This section describes a prototype implementation of the
ideaspresentedin §2and§3inatoolcalled PCCA(Producer-
Consumer Conformance Analyzer).
PCCAhastwophases: inferenceandcompatibility. During
the inference phase, PCCAuses CodeSurfer/C [10] to per-form pointer analysis and build an interprocedural control-
ﬂow graph (ICFG) and call graph for each component. It
traverses the ICFG to create a list of all call sites that (di-
rectly) call an I/O function (see §4.1), then traverses the call
graph to determine which procedures to prune (see §4.2). It
then traverses the ICFG again to create the automaton for
each procedure as described in §2.2, minimizes each of them,
and combines them into our model of the program.
During the compatibility phase, PCCAreads the automa-
ton produced for each component and proceeds with the
compatibility check according to PCCA’s mode. For the
VPA-mode, PCCAactually uses a formalism called Nested-
Word Automata(NWAs) instead of VPAs, buteach is essen-
tially an alternative expression of the other [3]. We use an
extension to the WALi library that implements NWAs [6].
4.1 Seedingthe Systemwith I/O Functions
PCCArequires information about (i) what function calls
of the producer can perform output, and (ii) what function
callsoftheconsumercanperforminput. Thereareanumber
of ways such information can be supplied to PCCA:
1. TheusercanprovidealistofI/Ofunctions(e.g. read-
Boolean,writeInt , as in the example) and their asso-
ciated types. For calls to standard functions such as
puts,PCCAis already equipped with such mappings.
2. For calls to printf- orscanf-style procedures, if the
format string is a constantin the code, PCCAwill parse
the string to determine the types being operated on.
The implementation is ﬂexible enough so that the
producer or consumer can contain user-deﬁned proce-
dures with printf/scanf-like format-strings, provided
that the format-string syntax is either the same as
what is used by printfor what is used by scanf.
PCCAjust needs to know the name of the procedure
and which formal parameter holds the format string.
3. If all else fails, the user can supply comments that
annotate procedure-call sites to specify that a partic-
ular call site performs either input or output. The
annotation includes the type that is operated on. This
method also allows the user to selectively choose only
some call sites to a particular procedure.
4. Finally, the list of procedure-call sites that the tool
should consider to be I/O functions is explicitly mate-
rialized in a text ﬁle, so the user can add, remove, or
change call sites in that list, or even generate it by dif-
ferent means. (In fact, in the current version of PCCA,
the techniques described in items 1 and 2 are imple-
mented by one program, and the technique described
in item 3 is implemented by a second program.)
4.2 RemovingIrrelevantProcedures
To reduce the size of the inferred VPA, PCCAprunes pro-
cedures that cannot possibly participate in I/O operations .
If there is no path from the entry of procedure Pto the exit
of procedure Palong which an I/O procedure is invoked, P
can be discounted entirely. One of the ﬁrst steps of PCCAis
to traverse the call graph generated by CodeSurfer, deter-
mine which procedures can transitively call an I/O function ,
and ignore all others. As illustrated in columns 3 and 4 of
Fig. 7 (see §5), the eﬀect of pruning is substantial, reducing
the number of procedures by as much as 90%.5. EXPERIMENTS
To test the capabilities of PCCA, we ran it on a small cor-
pus of examples (whose characteristics are listed in columns
2 and 3 of Fig. 7). The experiments were run on a sys-
tem with dual quad-core, 2.27GHz Xeon E5520s processors;
however, PCCAis entirely single-threaded. The system has
12 GB of memory, and runs Red Hat Enterprise Linux 5.
The experiments were designed to test whether PCCA
would detect bugs in producer-consumer pairs that were
buggy, correctly identify (presumably) correct code as hav-
ing the language-containment property, and scale to realis -
tic programs. We also compared the results between the FA
and VPA-based modes of operation to determine whether
the potential beneﬁts discussed in §3.3 arose.
Each example consisted of a pair of programs—a producer
and a consumer. In several cases, we used the program as
both the producer and the consumer, which makes sense for
programs that read and write the same format.
The examples are as follows:5
•ex-prod/ex-consmake up our running example (stubs
for the I/O functions are included in the count),
•ex-prod/ex-cons-ﬁg3 usesthebuggyversionofthecon-
sumer presented in Fig. 3,
•ex-prod- §2.5/ex-cons-§2.5are buggy versions of the
running example, modiﬁed as described at the end of
§2.5 with the separator to mark the packets,
•gzipandbzip2are the common Unix compres-
sion/decompression utilities,
•gzip-ﬁxed uses a modiﬁed version of gzip(discussed
below) to eliminate an erroneous report,
•png2ico is an image-conversion program, which we
compare to a hand-written speciﬁcation.
Reported times are the median of 5 runs. The num-
bers for the FA version use NWAs with no call or return
transitions. This gives an apples-to-apples comparison wi th
NWAs, but is slower than an alternative implementation
that converts each NWA to an OpenFST acceptor, deter-
minizes with OpenFST, and converts back. All times are
less than 1 sec. with the latter approach. There isan in-
trinsic cost to using an NWA representation, but we feel
that most of the diﬀerence between our FA numbers and
OpenFST’s indicates room for improving the WALi imple-
mentation. (That would improve the NWA version as well.)
We also performed an informal experiment using the VPA
versionwithoutEnrich(asmentionedattheendof §2.3). We
tested programs that read and write trees in inﬁx and pre-
ﬁx notation. Both the standard VPA version of PCCAand
the no-Enrich version reported that the inﬁx components
are compatible with each other, that the preﬁx components
are compatible with each other, and that each is incompat-
ible with the other. As discussed in §2.3, the compatibility
results are more credible for the no-Enrich version; the in-
compatibilityresultsaremorecredibleforthestandardVP A
version.
Omitting the Enrich step also dramatically decreased de-
terminization time; even the gzip-ﬁx-cons could be deter-
minized in less than one second. Thus, it might be beneﬁcial
to try to combine enrichment and determinization.
Two of the tests, gzipandpng2ico, required relatively
minor modiﬁcations. gzipuses input and output operations
5Our experiments can be found at http://www.cs.wisc.
edu/wpis/examples/pcca/#Funcs InferVPA version (sec.) FA version (sec.)
Test LOC Orig. Pruned |Q|#I/O aut.¬C Total OK? ¬C Total OK?
ex-prod 43 11 3 9 4 2.120.35 4.90 Y 0.10 4.76 Y
ex-cons 26 7 2 5 3 2.24
ex-prod 43 11 3 9 4 2.120.16 4.49 N 0.10 4.61 N
ex-cons-ﬁg3 25 7 2 5 3 2.09
ex-prod- §2.5 43 11 3 10 5 2.290.70 4.87 N 0.10 5.09 N
ex-cons-§2.5 25 7 2 5 3 2.40
gzip-prod 4396 100 17 51 25 26.3123 177 N* 101 157 N*
gzip-cons 4396 100 24 71 50 27.8
gzip-prod 4396 100 17 51 25 26.3583 646 Y 102 156 Y
gzip-ﬁx-cons 4389 100 24 73 51 27.8
bzip2-prod 5772 121 15 32 8 26.347.7 102 Y 47.1 101 Y
bzip2-cons 5772 121 13 29 10 27.4
png2ico-prod 806 39 1 22 29 9.4814.4 33.1 Y 0.16 10.1 Y
ico-spec-cons n/a n/a n/a 26 28 n/a
Figure 7: The experiments. “LOC” is lines of code, “orig.” is the number of functions in the program,
“pruned”is that number after pruning. |Q|is the number of states in the inferred automaton (equal betw een
the two variants). “# I/O” is the (static) number of calls to I /O functions. “Infer aut.” is the time (sec.) to
produce the automata for every procedure in the program. (Th e output of this step is used for both the VPA
and FA versions.) For both the VPA and FA version, ¬C is the time (sec.) to determinize and complement the
automaton. (Determinizing each procedure’s FA is not inclu ded in this time, but takes a negligible amount
of time in all experiments.) “Total” is the end-to-end time f or analysis, including the inference step. “OK?”
reports the output of PCCA.
muchlikethoseinourrunningexample, exceptimplemented
as macros. Because PCCAuses the control-ﬂow graph gen-
erated by CodeSurfer/C, these macros are not visible, so
we replaced the macro deﬁnitions with functions. In ad-
dition,gzipcalls the function that actually performs the
compression or decompression through a function pointer.
CodeSurfer/C performs points-to analysis, but PCCAdoes
not yet take such indirect calls into account; thus we mod-
iﬁed the source to call the function directly. (This is not a
fundamental limitation of our technique, though imprecise
pointer analysis could lead to further imprecision.) A ﬁnal
modiﬁcation that applies in a similar manner to both gzip
andpng2ico will be described in their respective sections.
As shown in Fig. 7, PCCAreports that some commonly-
used programs operate in a correct manner with regard to
their I/O behavior, regardless of the automaton model used.
PCCAalso detects synthetic programming errors in small
examples, as shown by the second pair of examples.
As can be seen in the results, the potential VPA beneﬁts
did not appear to aﬀect the results of the analysis. ( PCCA
does report diﬀerent results for the example in §3.3, but
we do not include that experiment in Fig. 7.) This result
surprised us, and in the future we plan to look at additional
examples to see whether any of them beneﬁt from VPAs.
gzip.The analysis of gzipreported a erroneous bug in the
distributed version; we examine the issues more closely here .
Forgzip, the actual compressed data appears as just a se-
quenceofbytes, sothecompatibilitycheckessentiallyistes t-
ing the compatibility of the code that reads and writes the
header and footer. Fig. 8 describes the header format of a
gzipﬁle. The code that writes this header (in zip.c) corre-
sponds very closely to the header format:
put_byte(GZIP_MAGIC[0]); /* magic header */
put_byte(GZIP_MAGIC[1]);
put_byte(DEFLATED); /* compression method */...
put_byte(flags); /* general flags */
put_long(time_stamp);
...
put_byte((uch)deflate_flags); /* extra flags */
put_byte(OS_CODE);
For this code, PCCAinfers the format speciﬁed in Fig. 8.
However, the code that readsthe header is reported to
be incompatible; this is a false positive. Unlike the output
functions, input is always done one byte at a time:
stamp = (ulg)get_byte();
stamp |= ((ulg)get_byte()) << 8;
stamp |= ((ulg)get_byte()) << 16;
stamp |= ((ulg)get_byte()) << 24;
Because the consumer reads the time_stamp ﬁeld as four
bytes instead of one long, it appears incompatible. This is
similar to the issue of granularity of types discussed in §2.2.
To address this, we replaced this code (and similar code
that reads longﬁelds in the footer) with a new get_long
function. This function can be implemented in terms of
four bytewise reads; as long as PCCAis told that get_long
performsI/O, PCCAwillrecognizethecallasreadinga long.
(In addition to helping PCCA, we feel that the modiﬁed code
is cleaner: by having the code for reading and writing a
longin one place, it is easier for the programmer to see that
those functions agree, for instance by reading and writing
the bytes in the same order. It should even be possible to
use our techniques to perform this check as well, by giving
diﬀerent types to each byte in the long.)
Aftermakingthischange, PCCAreportsthattheprograms
are compatible. It is unclear why there is such a dramatic
diﬀerence between the time it takes to determinize each ver-
sion of the consumer in the VPA version. The input VPAs
are of almost identical size and makeup, but it appears that
the extra longalphabet symbol in the revised version causesID1 ID2 CM FLG MTIME XFL OS ...
ID1, ID2 Fixed constants; gzip’s“magic number”
CM Compression algorithm
FLG Flags, as a bitmap
MTIME The modiﬁcation time of the original ﬁle
XFL Compression-method-speciﬁc ﬂags
OS ID of the OS where the ﬁle was compressed
Figure 8: The speciﬁcation of gzip’s header format.
Each ﬁeld is 1 byte except for MTIME, which is 4.
the determinized VPA to be much bigger (176 states vs. 27).
(Note that neither of these automata are minimal; it could
be that the extra size in the revised version could be reduced
to be more in line with the original version.) The sizes of
the two automata in the FA version are much closer.
png2ico. Forpng2ico, we demonstrate a slightly diﬀerent
application of our techniques. Instead of comparing a pro-
ducer to a consumer, we compare a producer to a manually-
crafted speciﬁcation acting as the consumer. This checks
that the producer emits only messages that are allowed by
the speciﬁcation. In the case of png2ico, we see that the
program indeed appears to conform to the speciﬁcation.
We manually crafted an automaton that describes the for-
mat of an icon ﬁle [18] and used that as the consumer. For
the ICO format, this was reasonably straightforward and
took less than two hours. The automaton allows PCCAto
check header information, similar to gzipbut with a much
richer format. An icon ﬁle can hold several diﬀerent images.
In addition to a global header (that mainly says how many
images there are), there is a directory that gives the oﬀset
and other information about each image and a header for
the image data itself. We can check all of this, leaving only
the raw image data itself appearing as a“meaningless”byte
stream. (We cannot check that the image headers actually
appear at the correct oﬀsets, however.)
While most of the output from png2ico is done through
the functions WriteByte ,WriteWord , andWriteDWord , there
are three places where a raw write is done using fwrite.
Two of these locations write a sequence of raw bytes of an
image to the ﬁle. We could reasonably infer just byte*for
those calls (similar to how the actual compressed data comes
across in gzip), however we decided to put in a bit of extra
eﬀort to obtain higher conﬁdence in the result. The two
fwritecalls correspond to the “xor mask” and “and mask”
of the bitmap. We manually speciﬁed that the ﬁrst fwrite
call outputs “xor mask” bytes and the second call outputs
“and mask” bytes, and required that each bitmap in the
icon ﬁle contains a sequence of“xor mask”bytes followed by
a sequence of“and mask”bytes. However, there is one call
toWriteByte amongst those writing the“xor mask”, so we
had to manually change the type of that call to match that
of the preceding fwrite. (We repeated the experiment but
just used byte*, andPCCAstill reported compatibility.)
The third call to fwriteis used instead of a sequence of
fourWriteByte calls; the reason the author choose this is
not clear. We replaced this fwritewith the four individual
WriteByte calls. In the future we hope to implement theability to automatically break apart a write such as this, to
make such manual intervention unnecessary.
We only report the results for the version with speciﬁc
types. The other variants we tried did not have much eﬀect.
6. RELATEDWORK
Inferring Input or Output Formats of Programs.
PCCA’s format-inference techniques, as well as the problem
in general, was inspired by the File Format Extractor tool
(FFE) by Lim et al. [23]. FFE infers output models of x86
executables using a weighted pushdown system. We skip
the WPDS step, performing the procedure discussed in §2.2
instead. The minimization we perform on each procedure’s
model gets us the beneﬁts intended by FFE’s use of WPDSs,
and produces far smaller automata.
Inferring input formats of executables has received much
attention lately, particularly in the context of protocol re -
verse engineering for network security [7, 12, 34, 24, 25].
However, most of this work involves the use of dynamic-
analysis techniques.
Komondoor and Ramalingam developed methods to re-
cover an object-oriented data model from a program written
in weakly-typed languages, such as Cobol [21]. It is capa-
ble of recovering information about the record structure of
entities that occur in a ﬁle, as well as information about
subtyping relationships between such entities.
Checking Compatibility/Conformance. Rajamani and
Rehof [30] developed a way to check that an implementation
modelIextractedfromamessage-passingprogramconforms
to a speciﬁcation S. Their goal was to support modular rea-
soning; they established that if Iconforms to SandPis
any environment in which PandScannot starve waiting to
send or receive messages, then PandIalso cannot starve.
A related question is checking conformance of software
components as software evolves and components are re-
placed or upgraded. Clarke et al. [9] survey several ap-
proaches that have been devised to answer the question,
including interface automata, behavioral subtyping [26],
input/output-based compatibility of upgrades [27], and
model checking.
There have also been many papers on session types, start-
ing with [17, 15, 29]. In some sense, this body of work has
the same goal that we have—helping to ensure that diﬀer-
ent components communicate properly—but their approach
is far diﬀerent. Session types, at a high level, convey much
the same information as our inferred languages. (For in-
stance, in the syntax of [17],“ ↑int; (↑char &↑double)”is
the type of a componentthat emits an intfollowed by either
acharordouble.) Some recent work, e.g. [19], is integrating
session types into common programming languages.
In most of this literature, session types need to be incor-
porated into the language being used to write the compo-
nents, which means they cannot be applied to legacy soft-
ware without rewriting it. In contrast to these papers, our
work analyzes existing C/C++ code for compatibility by in-
ferring the format. In return for this re-engineering, sess ion
types support richer interactions than we currently do; most
notably, it can specify bidirectional communications.
Recently there have been advances in inferring session
types, which is much closer to our goal. Mezzina [28] andCollingbourne and Kelly [11] each developed such an algo-
rithm. Collingbourne’s is particularly related, as they im -
plemented their technique in a source-to-source translator
for C++. However, neither paper really gives enough infor-
mation on how it performs in practice to compare to PCCA.
In a similar vein – and actually of equivalent power –
are channel contracts from the Singularity OS [13]. Chan-
nel contracts specify a protocol between two endpoints as
a state machine, where each state speciﬁes messages that
each endpoint can send or receive. F ¨ahndrich et al. describe
an analysis that veriﬁes certain memory-safety properties in
programs that use channel contracts. More recent work has
analyzed channel contracts with respect to deadlocks [33]
and developed formal type theories for channels [4].
7. FUTUREWORK
Wehaveanumberofextensionstothebasicideadescribed
in this paper in mind; we describe two of them here. The
discussionin this paperis framed from thepointof view that
the VPA alphabet consists of the actual programming lan-
guage types used by the programs. However, our approach
is more ﬂexible. It is possible to have even ﬁner-granularity
types. To do this, we would use types that do not corre-
spond to those in C. For instance, it would be possible to
have anint_ascii symbol for an integer expressed in ASCII
digits (e.g., the three-byte sequence“255”) and int_bin for
an integer in binary (e.g., the four bytes 0x000000FF). ( §2.5
described how a particular way of using a phony I/O call to
helpPCCAdetect bugs; this idea expands that technique.)
It should also be possible to extend our work to include in-
formation about the valuesthat are read or written—for
instance, to specify that write_int outputs a “4” or that
write_int outputs a value in the range “[4,7]” (and simi-
larly for the input operations of the consumer). This would
require a change to the compatibility portion as well.
Second,therearesomeengineeringtasksthatshouldmake
it easier to get more helpful results. For example, we can im-
plement the technique mentioned in the remark at the end
of§2.2, where we make it possible to break apart automat-
ically a structure or array type into its component ﬁelds.
This would allow the producer and consumer to use data
structures that are organized diﬀerently from one another
but have the same semantic meaning, and would avoid the
most invasive changes we had to make in our experiments.
8. REFERENCES
[1] C. Allauzen, M. Riley, J. Schalkwyk, W. Skut, and
M. Mohri. OpenFst: A general and eﬃcient weighted
ﬁnite-state transducer library. In CIAA, 2007.
[2] R. Alur and P. Madhusudan. Visibly pushdown languages.
InSTOC, 2004.
[3] R. Alur and P. Madhusudan. Adding nesting structure to
words.J. ACM , 56(3), 2009.
[4] V. Bono, C. Messa, and L. Padovani. Typing copyless
message passing. In ESOP, 2011.
[5] A. Bouajjani, J. Esparza, and O. Maler. Reachability
analysis of pushdown automata: Application to model
checking. In CONCUR , 1997.
[6] A. Burton, A. Thakur, E. Driscoll, , and T. Reps. WALi:
Nested-word automata. TR-1675, Comp. Sci. Dept., Univ.
of Wisconsin, Madison, WI, July 2010.
[7] J. Caballero and D. Song. Polyglot: Automatic extraction
of protocol format using dynamic binary analysis. In CCS,
2007.[8] D. Caucal. On the regular structure of preﬁx rewriting. In
CAAP, 1990.
[9] E. Clarke, N. Sharygina, and N. Sinha. Program
compatibility approaches. In FMCO, 2005.
[10] CodeSurfer system.
www.grammatech.com/products/codesurfer.
[11] P. Collingbourne and P. Kelly. Inference of session types
from control ﬂow. ENTCS, 238(6), 2010.
[12] W. Cui, M. Peinado, K. Chen, H. Wang, and L. Irun-Briz.
Tupni: Automatic reverse engineering of input formats. In
CCS, 2008.
[13] M. F ¨ahndrich, M. Aiken, C. Hawblitzel, O. Hodson,
G. Hunt, J. R. Larus, and S. Levi. Language support for
fast and reliable message-based communication in
Singularity OS. In EuroSys . 2006.
[14] A. Finkel, B.Willems, and P. Wolper. A direct symbolic
approach to model checking pushdown systems. ENTCS, 9,
1997.
[15] S. Gay, V. Vasconcelos, and A. Ravara. Session types for
inter-process communication. TR-2003-133, Dept. of
Computing Sci., Univ. of Glasgow, March 2003.
[16] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A system and
language for building system-speciﬁc, static analyses. In
PLDI, 2002.
[17] K. Honda. Types for dyadic interaction. In CONCUR . 1993.
[18] J. Hornick. Icons. http:
//msdn.microsoft.com/en-us/library/ms997538.aspx .
[19] R. Hu, D. Kouzapas, O. Pernet, N. Yoshida, and K. Honda.
Type-safe eventful sessions in java. In ECOOP . 2010.
[20] N. Kidd, A. Lal, and T. Reps. WALi: The Weighted
Automaton Library, 2007.
www.cs.wisc.edu/wpis/wpds/download.php.
[21] R. Komondoor and G. Ramalingam. Recovering data
models via guarded dependences. In WCRE, 2007.
[22] T. Kremenek, P. Twohey, G. Back, A. Ng, and D. Engler.
From uncertainty to belief: inferring the speciﬁcation
within. In OSDI, 2006.
[23] J. Lim, T. Reps, and B. Liblit. Extracting output formats
from executables. In WCRE, 2006.
[24] Z. Lin, X. Jiang, D. Xu, and X. Zhang. Automatic protocol
format reverse engineering through context-aware
monitored execution. In NDSS, 2008.
[25] Z. Lin and X. Zhang. Deriving input syntactic structure
from execution. In FSE, 2008.
[26] B. Liskov and J. Wing. Behavioral subtyping using
invariants and constraints. In H. Bowman and J. Derrick,
editors, Formal Methods for Distributed Processing: An
Object Oriented Approach . Cambridge Univ. Press, 2001.
[27] S. McCamant and M. Ernst. Early identiﬁcation of
incompatibilities in multicomponent upgrades. In ECOOP ,
2004.
[28] L. Mezzina. How to infer ﬁnite session types in a calculus of
services and sessions. In D. Lea and G. Zavattaro, editors,
Coordination Models and Languages . 2008.
[29] O. Nierstrasz and M. Papathomas. Viewing object as
patterns of communicating agents. In OOPSLA , 1990.
[30] S. Rajamani and J. Rehof. Conformance checking for
models of asynchronous message passing software. In CAV,
2002.
[31] T. Reps, S. Horwitz, and M. Sagiv. Precise interprocedural
dataﬂow analysis via graph reachability. In POPL, 1995.
[32] S. Schwoon. Model-Checking Pushdown Systems . PhD
thesis, TUM, Munich, Germany, July 2002.
[33] Z. Stengel and T. Bultan. Analyzing Singluarity channel
contracts. In ISSTA. 2009.
[34] G. Wondracek, P. Comparetti, C. Kruegel, and E. Kirda.
Automatic network protocol analysis. In NDSS, 2008.