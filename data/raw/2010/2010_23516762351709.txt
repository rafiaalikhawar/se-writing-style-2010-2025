Supporting Automated Software Re -engineering Using  
Re-aspects  
  
Mohamed Almorsy, John Grundy , and Amani S. Ibrahim  
Centre for Computing & Engineering Software Systems  
Swinburne University of Technology  
Melbourne, Australia  
[malmorsy ,jgrundy , aibrahim ]@swin.edu.au  
 
 
ABSTRACT  
System maintenance , including omitting  an existing system feature 
e.g. buggy or vulnerable code, or modifying existing features, e.g. 
replacing them, is still very challenging. To address this problem 
we introduce the “re-aspect” (re -engineering aspect) , inspired  from 
traditional AOP . A re-aspect captures  system modification details 
including signatures of entities to be updated; actions to apply 
including remove, modify, replace, or inject new code ; and code to 
apply . Re-aspect s locate  entities to update, entities that will be 
impacted by the given update, and finally propagate changes on the 
system source code . We have applied our re-aspects technique to 
the security re -engineering problem and evaluated it on a set of 
open source .NET application s to demonstrate its usefulness . 
 
Categories and Subject Descriptors  
D.2.7 [Distribution, Maintenance, and Enhancement ]: 
Restructuring, reverse engineering, and reengineerin g 
General Terms  
Algorithms, Design, Languages  
Keywords  
System Reengineering; Software Evolution; Change Impact 
Analys is; Re-Aspects  
1. INTRODUCTION  
Software systems are usually exposed to extensive change and 
evolution after deployment. These maintenance activities represent 
up to 80% of the total system cost and effort [7]. This usually 
requires capturing new features/modi fications, locating system 
entities that must  be modified, locating system entities that are 
impacted by this modification and should  be modified, and 
propagating the required modification to the whole system.  
Existing system maintenance approaches are mostly limited to 
change impact analysis [2; 5], where we identify entities that will 
be impacted by a given system modification to a specific system 
entity . These efforts assume that entities to modify are known and 
just look for entities impacted by this modification. Moreover, they 
focus on changes on class and method level rather than a block -of-
code. They assume  a set of predefine d system modifications . The 
problem of c apturing and locating specific system entities to 
change has been addressed by other system reengineering efforts:  
concept location , design patterns [1], and code evolution [4]. 
 
 
 
 
 
 
 
  
However, t hese efforts are limited in their expressiveness , 
formality,  and identification precision, as most of them targeted to 
help program understanding rather than supporting actual program 
modification.  Propagating change modification s on the target 
system has often  been realized using AOP techniques to support 
software  maintenance [6], re-engineering , and refacto ring [3].  
We introduce the concept of re-engineering aspects, or “re -aspects” 
for short, as a novel , integrated and systematic solution to the 
system re -engineering and maintenance problem. A re -aspect 
capture s signature of system  entities that need to be modified to 
effect a given change request, actions required (add new code, 
remove existing code, modify code, or replace code) , and code to 
apply on the located matching entities. Then we automatically 
analyse the system source co de, locate entities that match the 
specified signature s, conduct detailed impact analysis  to identify 
the impacted entities , and propagate the change required  on source 
code. Re -aspect signature may be class, method, or even code 
blocks . We introduce two n ovel signature  specification designators 
to captur e formal and flexible semantic and syntactic signature s. 
 
bool updateCustomerBalance (string  custID, decimal nBalance) {  
if(!AuthenitcateUser( username, password)) return  false ; 
if(!AuthorzUser(username, "up dateCustBalance")) return false;  
LogTrx(username, dateTime.Now, "updateCustomerBalance");  
Customer customer = Customers.getCustomerByID(custID);  
customer.Balance = nBalance;  
Customers.SaveChanges();  
LogTrx(username, dateTime.Now, "updateCustBalance  done"); } 
 
if( Request.Cookies["Loggedin"] != true ) {  
       if(  !AuthenticateUser(Request.Params["username"], 
Request.Params["password"] ) );  
    throw  new  Exception("Invalid user"); } 
DoAdministration();  
 
 
if( !AuthenticateUser( Request.Params["username"],  
                                          Request.Params["password"] ) )  
throw  new  Exception("Invalid user");  
if( !AuthorizeUser( Thread.CurrentPrincipal,  
                    (new StakeFrame()).GetMethod().Name,  
                    (new StakeFrame()).GetMethod(). GetParameters()  )  )    
         throw  new  Exception("User is not auhorized");  
updateCustomerBalance(Request.QueryString["cID"], nBalance);  
Figure 1. Possible system changes - motivating examples  
2. RE-ASPECTS  
Once a new change request (CR) is received, a change request 
management process is initiated. This process is conducted to 
figure out, and document, the expected impacts on system entities . 
First , it starts with an impact analysis  task. The output of it is 
maintained in a “change set”. Each item in the change set may be 
removed, modified, replaced , or new code injected . Next, a deeper  B A 
C Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00
230
analysis is then conducted to identify the “impact set” which 
includes items that will be impacted by change s in the “change 
set”. Finally , system developers propagate  the specified system 
modification s on the system entities. This  might  require modifying 
code  developed in different programming languages  and different 
syntactical format (variable name, conditions’ order or format).  
2.1 Re-aspects Motivation  
Figure  1 show s different code snippets, from an internally 
developed ERP application called Galactic, vulnerable to different 
security issues  including: (A) built-in security functions  that need 
to be disabled ; (B) code vulnerable to authentication bypass attack ; 
and (C) code vulnerable to improper authorization attack . In this 
figure  we also show some possible mitigations (system 
modifications) to address these  vulnerabilities  (the code with gr ey 
shading ) i.e. the required re -engineering of the original code to 
address  the identified security vulnerabilities found .  
 
2.2 Re-aspect s Syntax  
A re-aspect  specifies a single system modification to be applied on 
the target code base. A re -aspect has a signature , an advice  and an 
action . A re-aspect  signature  defines footprint of a target system 
entity that should be deleted/modified/replaced or into which new 
code is ins erted – this m ay be a line of code , a method, or a class.  
A re-aspect  instance  is a matched system entity that matches a 
given re -aspect signature. Each  re-aspect instance maintains their 
specific context information.  A re-aspect  action  specifies what to 
do on the re-aspect’s instances . An action may be applied on re -
aspect level (i.e. on all re -aspect instances) or on specific  instances.   
A re-aspect impact set  represents system entities that will be 
impacted by a given system modification.  
 
 
Re-aspectDef   
Signature         
OtherSig n          
SigType            
Action        
Action Type     
Action Cond    
Impact_Aspect  ::= s:{Sign } a:{Action} d:{Advice} i:{Impact _aspect}  
::= st:Sign Type se: {Signature Expr} ; OtherSig n 
::= NULL | Sign  
::= code -snippet  |  OCL-expression  
::= at:Action Type ac: {Action Condition}  
::= Delete | Modify | Replace | Inject  
::= OCL -expression; Action Cond | NULL  
::= NULL | Re -aspectDef | Impact_Aspect    
Figure 2. Re-aspect syntax  
Figure 2 shows our re-aspect definition  syntax . Every re -aspect has 
a signature, action, advice , and may have an impact re -aspect . The 
signature specifies  the signature type and the signature expression.  
This can be  a collection of composite signatures.  Re-aspect action 
specif ies action type and condi tions, if any. The advice specifies 
code to replace or inject or the code used to modify existing code. 
The impact re -aspect specif ies what to do with o ther system 
entities  impacted by this system modification . 
  
We have four possible re-engineering “ re-aspects ” types:  adding 
re-aspect: this equates to  a conventional AOP code injection 
aspect. Code to be injected is specified in a separate advice that is 
weaved with the target system at a given re -aspect instance. It can 
add any static structure (new m ethod, field, and lines -of-code ) to 
system  entities . An anti-aspect  has only signature and no advices . 
The identified code blocks - re-aspect instances - are removed from 
the target system . A replacing re -aspect  is a combination of 
deletion and adding -aspect. It includes signature of code to be 
remove d and an advice to be injected . Finally, a modifying re -
aspect  is the most complicated re -aspect. It makes use of the 
identified re -aspect instance code to allow the aspect developer to 
specify selective deletion, reordering, or addition of new nodes 
into the identified code instance. For example, the problem in Fig .  1-B (Authentication bypass) could  be mitigated using a modifying 
re-aspect  advice, as shown in Figure 3 . It receives a re-aspect 
instance (an AST node ) as input parameter. At weaving time , we 
call the modifying aspect script on each identified instance. T he 
returned, modified AST is used to replace the original sub -tree.  
 
void authenticationByPassMitigationAdvice(INode aspectInstance) {  
    INode node = aspectInstance;  
    if (    (node as IfElseStatemenet) != null 
     && ((IfElseStmt) node). Condition.Contains("loggedin") == true ) ) { 
          aspectInstance = ((IfElseStatement)node).TrueStatement[0];  
     … 
Figure 3. A sample of a modifying re -aspect advice  
2.3 Re-aspect Signature Designators  
Supporting system reengineering requires a powerful signature 
specification approach. Our r e-aspect concept  is supported with a 
hybrid approach that delivers flexible syntactical code signature as 
well as OCL -semantic signature specification  designators . 
 
1 
2 
3 
4 
5 
6 
7 
8 
9 //update namespace or class with specific name  if any  
namespace DummyNamespace {  
    class DummyClass {  
       // update method modifier, return type or  
       // name for specific method signatures  
       public void  DummyMethod() {  
            // update method body in case of code block re -aspect  
             DummyStatement;  
             if (DummyCondition) {   } 
Figure 4. Code snippet re -aspect template  
Code Snippet Signature Designator:  using  this designator , 
developers can specify a flexible code snippet as the aspect 
signature. Figure 4 shows the template of syntacti cal code snippet 
as a signature . Developers use this template to write code parts 
they are interested in . The flexibility comes when specifying  
signatures to be matched with code blocks inside methods’ body. 
A developer can specify the code block they are interested to 
locate . If the developer does not know the details of the code 
block, they can use  the dummy  keyword . This indicates that all 
statements in the method body will not be considered until a match 
between the target method statements and the next statement in the 
given signature  is found in the method body.  
The syntactical code snippet approach is similar to regular 
expressions in the ir expressiveness . Our code snippets  have an 
edge in the ir matching approach. Regular expressions depend on 
lexical pattern matching that suffers from lexical problems such as 
new lines, tabs, brackets, etc . As our  code snippe t matching is done 
on Abstract Syntax Tree s this avoids such lexical problems  and can 
even  match code snippets from different programming languages.  
 
Semantic OCL -based Signature Designator:  to support more 
formal semantic re -aspect signatures we use the Object Constraint 
Language (OCL)  as a signature definition lang uage. This is more  
formal, familiar , and extensible. To enrich OCL with object -
oriented programs semantics , we have developed a system -
description class diagram, shown in Figure 5. This shows  every 
entity existing in any give n object oriented system including 
component, class, instance, method, inputs, sources, if statements, 
loops , etc. Moreover, it helps in validating OCL constraints and 
can be easily extended to capture more abstract system entities and 
relations such as se curity APIs, system models (feature, 
architecture, deployment, design, and testing…). Figure 6 shows 
examples of OCL -based re -aspect’s signature : (A) get all public 
methods whose classes implement a specific system feature; (B) 
get all methods t hat call a security function .  
 231 
Figure 5. The system class diagram used in re -aspects OCL -based signatures
Figure 6. Sample OCL re -aspect signatures  
Set SigAST = Call Generate signature AST  
Set StartNode = codeAST.CurrentNode  
CheckNodes:   //Recursively traverse the source code AST  
IF code -AST.CurrNode = NULL THEN        Exit 
Dummy = True  
IF SigAST.CurrentNode.Contains("dummy")      ==  True  
        DummyStatement = True  
END  IF 
IF (codeAST.CurrNode.Type == SigAST.CurrNode.Type)   
OR (Dummy  = True   AND  codeAST.Curr Node  = SigAST.NextNode) THEN  
BEGIN  
    Result = Call CompareNodes(codeAST.CurrNode, SigAST.CurrNode)  
    IF Result = True  THEN   //Nodes are equal  
    BEGIN  
        Set codeAST.CurrNode = codeAST.NextNode  
        Set SigAST.CurrNode = SigAST.NextNode  
     END  IF 
     ELSE  IF Result = False  THEN      BEGIN  
            Set StartNode = StartNode.NextNode  
            Set codeAST.CurrNode = StartNode.NextNode  
            Set sigAST.CurrNode = SigAST.Root  
    END  IF 
    GOTO  CheckNodes  
END  IF 
ELSE  
BEGIN  
    Set codeAST.CurrNode = codeAST.NextNode  
  StartNode = codeAST.CurrNode  
    GOTO  CheckNodes  
END  IF 
Figure 7 . Syntactical code snippet matching algorithm  
SigClass = Call ParseOCL_GenerateC#(OCLSig)  
SigInstance = Call CreateInstance(SigClass, entity)  
Foreach  entity in SystemModel DO 
        IF entity.Type == SigClass.ContextType THEN  
        BEGIN  
              Var Output = SigInstance.InvariantName_Test(entity)  
              MatchesList = Output.ToList()  
       END  IF  
Figure 8. Semantic OCL signatures matching algorithm  2.4 Locating Re -aspect Instances  
Give n a re -aspect signature, to locate the possible re -aspect 
instances in a target application code base, we first parse the input 
code and build an abstract syntax tree (AST) representation. This 
step helps avoiding spacing, comments, brackets and parentheses  
ambiguities. Moreover, it helps avoid syntax details relevant to 
different programming languages. Given the source code AST and 
re-aspects’ signatures, the re -aspect locator traverses the AST 
looking for matches using one of two matching algorithms. The 
selection of matching algorithm depends on the given re -aspect 
signature type. If code snippet then algorithm 1, else algorithm 2.  
Algorithm 1 , Figure 7 : the aspect locator traverses the input 
source code AST and the given re -aspect code snippet AST 
looking  for matches. The matching takes into consideration the 
node hierarchy in both the signature and the system code. It treats  
the dummy  constructs as  “do not care ” node s in the AST .  
Algorithm 2 , Figure 8 : is based on compiling and validating the 
given OCL signature using an OCL parser against the system 
meta -model from  Figure  5. Then we generate a visitor  class from 
the given re -aspect OCL signature. The visitor class implements 
handler methods for every node type specified in the OCL 
signature. If a v isited node has a handler, this handler is called – 
e.g. a vis itor for example (B) Figure 5 , will have handlers for 
method  definition  and invocation expression nodes. In the 
invocation expression the visitor will have a condition to check if 
the invoked me thod is marked as a security function, then add s this 
method to the returned list of methods.  
 
 
A Context  Method inv GetImpactedMethodsforModifiedMethod:  
  self.Statements ->contains(S | S.StatementType = ‘MethodCall’  
  AND S.MethodName = ‘ModifiedMethod ’) 
B Context  Method inv GetImpactedMethodsforClass:  
  self. Statements ->contains( S | S.StatementType = ‘NewObj’    
  AND S.ClassType = ‘ModifiedClass’)  
Figure 9 . Samples of impact analysis OCL -signatures  
2.5 Change Impact Analysis  
In AOP the code to be injected is encapsulated in an advice 
separate from the target cut-point itself. Thus no impact analysis is 
required. However, with  reengineering aspects  we have more 
complicated scenario s where we cut different code parts that have 
similar signature but different structure and format,  are from 
different places  (may have different impact sets) , and may be 
added  or modified code. Thus any given system modification 
requires a detailed impact analysis to identify other system entities 
that shoul d be updated  as a part of given modification.  A   Context  Method inv PublicMethods:  
self.IsPublic  = true AND self.Class.ImplementsFeature = 
“CustMgmt ” 
B Context  Method inv MethodsWithSecurityFns:  
self.stmts ->contains(stmt: MethodCall  | stmt. IsSecurityFn = true)  232 
Table 1. Results of validating re -aspects to locate and propagate given signatures  
Benchmark  KLOC  Files        Classes  Authen. Bypass  Improper Authoriz.  Security Disabling  
C O A M C O A M C O A M 
Galactic  16.2 99 101 3 3 3 3 4 7 9 7 3 3 3 3 
SplendidCRM  245 816 6177  - 8 8 8 2 3 3 3 13 13 13 13 
KOOBOO  112 1178  7851  - - - - 6 9 13 8 11 11 11 11 
NopCommerce  442 3781  5127  - - - - 0 1 3 2 10 10 10 10 
BugTracer  10 19 298 - - - - 0 1 2 2 7 7 7 7 
 C: using code snippet,                       O: using OCL,                          A: actual instances,                           M: Successfully Modified  
 
For each re -aspect instance, we compute a change impact set  based 
on the re -aspect instance type (class, method, property, field, line -
of-code). A given system modification will have either  local 
impact or global impact based on re-aspect instance , as follows:  
Lines-of-code : Has a local impact  – i.e. no other system entities 
will be impacted, thus the change impact set is empty.  
Method: Has a global impact . To compute the impact set, we 
locate methods  and properties  that contain  call statement to th e 
modified method . Figure 9 -A shows sample OC L expression to 
locate methods that contain invocation to the modified method.  
Class: Has a global impact . The change impact set  contains  all 
methods  that have identifier s of this class  (Figure 9 -B); properties  
of this type or have identifier of this type;  fields  of this class type;  
and classes  that have this class  as base class.  
Property:  Has a global impact . To compute the change impact set, 
we locate all methods  that have this property in an y expression 
statement – e.g. assignment, call, if condition, lo op statements.  
The change impact sets ’ entities  are located using pre -specified 
OCL expressions (Figure 9) , configured according to re -aspect 
instance type and name . This avoids  building Dependenc y Graph s 
(usually adopted by existing  approaches and time consuming).  
 
Figure 10. Re-aspects l ocal impact analysis   
2.6 Change Propagation  
The propagation of a given system modification (re -aspect) is 
straight forward. It depends on the re -aspect type (action) either to 
insert, delete, replace, or modify code of the  located re -aspect 
instance . All re -aspect instances are updated in the code AST and 
then code is regenerate d with the final updates.  For entities in the 
change impact set of each re -aspect instance (identified in the 
previous step), we apply the impact re-aspect  included in the re -
aspect definition , as shown in Figure  2. 
Confirming that changes caused by a re -aspect didn’t cause any 
other problem is an extremely hard problem that requires a deep 
understanding of the logic behind the code block. Here we f ocus 
on confirming that the added, removed, replaced, or modified code 
does not break the data flow or the control flow of the method, as 
shown in Figure 10. Control flow analysis (CFA) is used to  
confirm that the modification does not lead to unreachable code 
(case 4). Data flow analysis (DFA) confirm s that the required data 
for the modified block are available from previous blocks and that 
next blocks still have required data items (cases 1, 2, 3 ). 3. EVALUATION   
We evaluated  the capabilities of re -aspects in locat ing and 
propagating  a variety of system  modifications . Table  1 
summarizes the results of using re-aspects to locate  matches of a 
given re -aspects’ signatures using our benchmark applications with 
a set of three system modifications  (from  Figure 1)  and 
propagating  given changes on the identified matches. We use 
precision  and recall  metrics to assess our approach  effectiveness . 
From our experiments, the precision of the co de-snippet approach 
is (90%), while its recall is (70%). The precision of the OCL -based 
approach is (93%) while the recall rate is (87%). The precision of 
the change propagation module is 88%.  
4. SUMMARY  
We described  a novel solution  - the “re-aspect”  - to the system 
maintenance problem. A re -aspect capture s details of system 
modifications including signatures of entities  that need to be 
modified; actions to apply on located matches possibly take away 
(de-weaved) , replace, modify or new code inserted; an d code to 
update these entities . A key strength of our re -aspects comes from 
the signature speci fication designators. Re -aspect  support s two 
signature specification approaches: code snippet templates, and 
OCL -based signatures. Re -aspects ease and automate the 
reengineering process starting with locating system entities to be 
modified, change impact analysis , and finally propagating updates 
on located entities.  We have validated our approach effectiveness 
in locating entities to be modified and propagating c hanges using  a 
set of open source  .NET benchmark applications.  
5. ACKNOWLEDGEMENTS  
The authors are grateful to Swinburne University of Technology 
and the FRST  SPPI project for support for this research.  
6. REFERENCES  
[1] BERNARDI, M.L. and DI LUCCA, G.A., Model -driven 
detection of Design Patterns. In Proc. of ICSM 2010 , 1-5. 
[2] LEHNERT, S., 2011. A Taxonomy for Software Change 
Impact Analysis. In 12th IWPSE ,  Hungary.  
[3] MONTEIRO,  P. and FERNANDES, M., 2008. An illustrat ive 
example of refactoring object -oriented code with aspect -
oriented mechanisms. Softw. Pract. Exper. 38 , 4, 361 -396. 
[4] NEAMTIU, I., FOSTER, J.S., and HICKS, M., 2005. 
Understanding source code evolution using abstract syntax 
tree matching. In 2005 Int. workshop on Mining software 
repositories , Missouri, 1 -5. 
[5] PETRENKO, M. and RAJLICH, V., 2009. Variable 
granularity for improving precision of impact analysis. In  
IEEE 17th Int. Conf. on Prog . Comprehension , 10-19. 
[6] PREVITALI, C. and GROSS, R., 2011. Aspect -based 
dynamic software updating: a model and its empirical 
evaluation. In Proc. 10th AOSD , Brazil, 105 -116.  
[7] THUMMALAPENTA, S., et al, 2010. An empirical study on  
maintenance of source code clones. Emp. S/W Eng.15,1, 1 -34. 
 
B1
A(Remove)
B3Data = {}DFA: Removing A, B3 impacted?1
Data ={B1}
Data={B1+B2}
A
B3Data = {}3
Data = {B1}
Data = {B1+A}
{B1+A`+B3 } B1
A`
Data= {B1+A`}B1
A(Inject)
B3Data = {}DFA: Adding A, B1 sufficient? 2
Data ={B1}
{B1+A+B3 } 
B1
A(Control Block)
B24
B3??????
???CFA: After update, B3 is reachable ? DFA: Modify A=>A`, B1& B3 Ok?233