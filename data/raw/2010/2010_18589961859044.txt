Eliminating Navigation Errors in Web Applications via
Model Checking and Runtime Enforcement of Navigation
State Machines
Sylvain Hallé∗
Université du Québec à Chicoutimi, Canada
shalle@acm.orgTaylor Ettema, Chris Bunch and
Tevﬁk Bultan†
University of California, Santa Barbara, USA
{tettema,cgb,bultan}@cs.ucsb.edu
ABSTRACT
The enforcement of navigation constraints in web applica-
tions is challenging and error prone due to the unrestricted
useofnavigationfunctionsinwebbrowsers. Thisoftenleads
to navigation errors, producing cryptic messages and expos-
inginformationthatcanbeexploitedbymalicioususers. We
propose a runtime enforcement mechanism that restricts the
control ﬂow of a web application to a state machine model
speciﬁed by the developer, and use model checking to verify
temporal properties on these state machines. Our exper-
iments, performed on three real-world applications, show
that 1) our runtime enforcement mechanism incurs negli-
gible overhead under normal circumstances, and can even
reduce server processing time in handling unexpected re-
quests; 2) by combining runtime enforcement with model
checking, navigation correctness can be eﬃciently guaran-
teed in large web applications.
Categories and Subject Descriptors
D.2.2 [Software Engineering ]: Design Tools and Tech-
niques; D.2.4 [ Software Engineering ]: Software/Program
Veriﬁcation; H.3.5[ Information Storage and Retrieval ]:
Online Information Services— web-based services
General Terms
Theory, veriﬁcation
Keywords
Navigation, web applications, model checking
∗This work was done when Sylvain Hall´ e was at the Univer-
sity of California, Santa Barbara.
†This work is supported by NSF grants CCF-0916112 and
CCF-0716095.
Permission to make digital or hard copies of all or part of this w ork for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage and th at copies
bear this notice and the full citation on the ﬁrst page. To cop y otherwise, to
republish, to post on servers or to redistribute to lists, re quires prior speciﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00./c129}HTTP OK
/c50HTTP GET/POST
/c50Action
executionBootstrap
script
Persistent□session
storageDatabase
/c130
/c131action
session□IDrequest
parameters
session
variables/c132/c133
/c134
Figure 1: Processing of an HTTP request in an
MVC web application.
1. INTRODUCTION
Browser functionalities such as bookmarks and the“back”
button allow users to request pages from web applications
in unpredictable ways. When incorrectly handled, an un-
expected request from the user can execute an unintended
action, produce a cryptic and confusing error message, or
even expose details about the application that can be ex-
ploited for malicious purposes. In fact, our experiments on
real-worldwebapplicationsdemonstratethatmorethanhal f
of unexpected navigation sequences are not properly caught
and processed by web applications. The enforcement of nav-
igation constraints is therefore a critical issue in web app li-
cation development.
An increasing number of web applications are being de-
velopedusingtheModel-View-Controller(MVC)designpat-
tern through frameworks like Zend, Ruby on Rails and Co-
deIgniter. MVC pattern facilitates the separation of contr ol
ﬂow logic (controllers), business logic and data (model) an d
user interface logic (view). As a consequence, MVC web
applications break the concrete link between a URI and a
speciﬁc resource residing on the server. All incoming re-
quests are rather directed to a single“bootstrap”script tha t
parses and evaluates them, and then determines the actions
to execute (see Figure 1).
By clicking on a link in a page, or by typing a URL in
the browser’s location bar, a user actually requests a new
page on the application server through an HTTP GET or
POST request (Figure 1, label (1)). This request is relayed
to the application’s “bootstrap” script. Based on the re-
quested URL, the script extracts the name of the actionto
beexecutedandany request parameters carriedintheHTTP
request (2); if one of these parameters is an identiﬁer called
a session cookie, the script also fetches from the server’s
235
persistent storage an additional set of session variables and
their values (3). All this data is then used to execute the
action proper (4); this may include back-end database read
and write access. Finally, the application returns an outpu t
pagebacktothebrowserastheHTTPresponsetotheinitial
request (5), and possibly modiﬁes the session information in
the server’s persistent storage (6).
By navigating through an MVC web application, a user
produces a sequence of triplets /angbracketleftaction, request parameters,
session variables /angbracketright, with each such triplet representing the
information related to one “button click” on the browser.
We call such a sequence a navigation trace .
In a standard desktop application, not all sequences of ac-
tions are considered valid. For example, it is nonsensical to
call the “save” command if no document has been opened
beforehand. Well-designed products prevent such odd se-
quences by disabling or hiding from the user interface any
menu items or buttons which do not make sense in the cur-
rent state of the application.
In web applications, however, this is far more diﬃcult to
achieve. Even when the pages returned by an application af-
ter each request only provide links to valid actions from the
current state, the browser itself provides many ways of by-
passing these measures through the use of the back button,
bookmarks, multiple windows, and the location bar where
arbitrary URLs can be typed. None of these GUI elements
can be reliably disabled, controlled or even hidden by a web
application. The task is made even more diﬃcult by the
HTTP protocol, which is by design stateless and treats re-
quests independently of each other.
In an MVC application, the handling of navigation con-
straints should clearly be the responsibility of the contro ller.
However, MVC-based applications do not fully exploit this
feature. In particular, they do not support the enforcement
of constraints across multiple controllers and actions, an d
they do not provide a mechanism to store the navigation
history that is necessary to enforce these navigation con-
straints. The developer therefore becomes responsible of
writing customized mechanisms for these two features, a te-
dious and cumbersome task.
In this paper, we propose a solution to this problem with
a runtime enforcement mechanism that restricts the con-
trol ﬂow of a web application to a navigation state machine
model speciﬁed by the developer by exploiting the existing
structure of the MVC pattern. We then use model checking
to verify temporal properties of the navigation state ma-
chine itself. We implemented our approach by developing 1)
a navigation state machine language for speciﬁcation of nav-
igation constraints; 2) a plugin for MVC-style PHP applica-
tions that enforces the navigation state machine constraint s
at runtime; 3) a translator that generates SMV models from
navigation state machines for model checking.
Our experiments show that the runtime enforcement plu-
gin incurs negligible overhead under normal circumstances ,
and can even reduce server processing time when handling
unexpected requests by avoiding the generation of error
pages. Moreover, with our runtime enforcement mechanism,
the veriﬁcation of temporal properties about navigation can
be done eﬃciently using model checking, even on web appli-
cations containing more than 400,000 lines of code.
2. NA VIGATION ERRORS
Although stateful web applications should keep track ofApplication Modules Controllers Actions KLOC
Digitalus 2 14 60 401
BambooInvoice 1 9 26 159
Capstone 3 12 33 41
Table 1: Number of modules, controllers, actions
and thousands of lines of PHP code for each of the
three applications studied in this paper.
Figure 2: Output of Error 1 in Digitalus.
navigation traces and validate each request based on that
history, most of them do it partially, if at all. Therefore, i t is
generallyeasyforausertoproducenon-compliantsequences
of actions that are improperly handled by a web application.
To illustrate this point, we studied three real-world appli -
cations (see Table 1): Digitalus11.8, an open-source con-
tent management system (CMS) written using the PHP
Zend framework; BambooInvoice20.8.9, an invoice manage-
ment system for small businesses written using the PHP
CodeIgniter framework; Capstone Manager, a project man-
agement system used at UCSB written using the PHP Zend
framework. Below, we describe examples where these appli-
cations erroneously handle non-compliant navigation trace s,
producing what we call navigation errors , classiﬁed accord-
ing to the method by which they are created.
Basic Errors. Thisﬁrstcategorycorrespondstoerrorsthat
can be reproduced by simply using the application’s navi-
gation links, and possibly the web browser’s back button
and bookmark functionality. A ﬁrst example, taken from
Digitalus, involves the following sequence of steps:
Error 1 (Delete yourself). 1) Login as any user,
say Bob, with superadmin status. 2) Click on the“Site”tab.
3) In the“Admin Users”sidebar, click on Bob to get to the
user edit page. 4) Click on“Delete”in the top-right corner.
5) Bob is deleted from the user list; yet, you are still logged
in as Bob. 6) Click on the browser’s back button; this will
take you back to the “Edit” page for Bob, which no longer
exists. The resulting page is shown in Figure 2.
This navigation error has two consequences: First, the
user interface is disrupted with PHP error messages; in par-
1http://www.digitaluscms.com
2http://bambooinvoice.org
236Figure 3: Output of Error 3 in Digitalus.
ticular, the messages show the absolute location of Apache’ s
root directory on the web server. This can be used, e.g.
to deduce that the server is a Windows XP machine run-
ning under the user “Sylvain” oﬀ local drive “D”. Most im-
portantly, since the deleted user is the one that is actually
logged in, the application should immediately log out and
redirect to the login page. Instead, the deleted user is stil l
logged in and has access to all administrative functions. A
similar error also exists in BambooInvoice.
A second example, taken from the BambooInvoice appli-
cation, involves the browser’s bookmarking functionality:
Error 2 (Edit a deleted invoice). 1) Login to the
system. 2) Go to the invoice list and click on an invoice to
get to the edit page. 3) Bookmark this page. 4) Go back
to the invoice list by pressing the browser’s“Back”button.
5) Click on“Delete invoice”. 6) Invoke the bookmark. This
summons a page with PHP errors similar to Figure 2.
Multi-window Errors. As in the previous category, these
errors can be reproduced solely by using the application’s
and web browser’s buttons; however, they require two dif-
ferent browser windows. For example, in Digitalus:
Error 3 (Update a deleted page). 1) Login in as
an administrator and go to the “Pages” tab. 2) Select any
page and right-click on the link for this page in the“Pages”
tab at the right; choose“Open the link in a new tab”. 3) In
the ﬁrst window, left-click on the link for this page. There
are now two tabs containing the edit form for the same page.
4) In the ﬁrst tab, click on“Delete”. 5) Go to the second tab,
click on“Update”. The resulting page is shown in Figure 3.
This navigation error involves even further disruption of
the user interface. This time, the basic page template does
not load at all, and the user is presented with the white page
that PHP generates in case of a fatal error. Similar errors
can be created with BambooInvoice when trying, in a ﬁrst
window, to create an invoice for a user that was previously
deleted in a second window.
Direct URL Errors. This type of errors are caused by
typing a URL in the web browser’s location bar from the
“wrong”context. For example, in Digitalus:Error 4 (No user logged). Reproduce all the
steps for Error 1. Then try to return to the login page
by typing admin in the browser’s URL bar. This summons
a PHP white“Fatal error”page similar to Figure 3.
Error 5 (Forbidden pages). In Digitalus, typing
any of the URLs mentioned in Figure 6 either causes a page
with PHP warnings (similar to Figure 2), or a white page
with PHP fatal errors (similar to Figure 3).
This time, the problem lies in the fact that the application
assumes that these pages are called from a previous page
that gives values to some mandatory request parameters.
Calling the page outside that context creates errors.
All in all, we found 11 diﬀerent ways to cause warnings
and fatal errors.
Navigation Constraints. The previous examples show se-
quences of actions where the web application fails to realize
that an action has been called in the wrong context. Most of
the navigation errors presented above could be prevented by
simply keeping track of the last triplet /angbracketleftaction, request pa-
rameters, session variables /angbracketright, and by granting or blocking the
execution of the requested action according to that triplet.
For example, Navigation Error 1 can be prevented by
a) checking that the session ID is diﬀerent from the user
ID in the delete request or b) otherwise, only allowing ad-
min/auth/logout as the next page; this also takes care of
Navigation Error 4. Navigation Error 2 can be prevented
by making sure that the“edit”action is only accessed if the
last action is“view”, with both actions having the same“id”
parameter. Navigation Error 3 can be prevented by making
sure that the“page delete”action is only accessed if the pre -
viouspageis“pageedit”. Finally, thesolutionforNavigatio n
Error 5 is similar for each page mentioned; for example, the
problem for admin/page/edit can be solved by accessing it
only from admin/page/new or admin/page/index.
Inthefollowingsections, weformallydescribetheproblem
of navigation errors in web applications, and introduce a
mechanism to enforce navigation constraints like the ones
above in web applications.
3. A FORMAL MODEL
We formalize the global behavior of an MVC web applica-
tion (which we will simply refer as an application)as follow s:
•Mis a set of data model states, where the data model
can include any stateful representation of application
data, such as a database,
•Vis a set of session variables , i.e., data stored on the
server on a per-client basis,
•Iis a set of sessions used by the server to associate
clients with session variables,
•Ais a set of actions, i.e., the program segments that
are invoked based on the HTTP requests sent by the
user,
•Pis a set of request parameters , i.e., input data from
the user received as part of the HTTP requests via
GET or POST.
237To simplify our presentation we will denote the set of values
a session variable or a request parameter can take as D.
Thestateof an applicationis uniquely deﬁned by the com-
bination of a model state and the valuations of the session
variables for each session. The requestsfrom the user, on the
other hand, are used to uniquely identify a transition from
one state of the web application to another state. Each re-
quest consists of an action and a set of request parameters.
Definition 1.An application is a tuple A=/angbracketleftQ,B,∆/angbracketright
where:
•Q⊆M×D|I|×|V|is the set of states. Given a state
q∈Q, we useq(i,v)to denote the value of session
variablev∈Vfor session i∈Iin stateq, andq(i)
to denote the vector /vector v∈D|V|containing values of all
session variables for session iin stateq.
•B⊆Qis the set of initial(or begin) states, where for
allq∈Bandi∈I q(i) =⊥|V|(⊥denotes null).
•∆ :Q×A×D|P|×I→Qis thetransition function .
The function ∆satisﬁes the following two constraints:
1. Ifq/prime= ∆(q,a,/vector p,i), then for any session j∈I,j/negationslash=
i⇒q/prime(j) =q(j).
2. Ifq/prime= ∆(q,/epsilon1,⊥|P|,⊥), thenq/prime(i) =q(i)for any ses-
sioni∈I.
In an application, each session can only change its own
session variables, as speciﬁed by the ﬁrst constraint on the
transition function ∆. The second constraint states that th e
/epsilon1-transition does not change any session variable and only
accounts for changes in the data model state, independent of
any session activity. We use the /epsilon1-transition to represent the
fact that a web application can update the data model state
(e.g. the back-end database) without receiving a request
from the user.
Starting from an initial state q0∈B, a succession
of tuples (q0,/epsilon1,⊥|P|,⊥),(q1,a1,/vector p1,i1),(q2,a2,/vector p2,i2),...is
called a global trace of Aif, for every k≥0:qk+1=
∆(qk,ak, /vector pk,ik). Each element represents the current appli-
cation state, the previous action and the request parameters,
and the session for which the previous action was executed.
Since there is no previous action in the initial state we use
the/epsilon1-transition as default in the ﬁrst tuple of the trace.
Our deﬁnition of a global trace implies that the actions
are executed atomically. This is not true in a real web appli-
cation. Two actions from diﬀerent sessions can be executing
at the same time. However, the interleaved trace semantics
we deﬁned above is equivalent to such an execution for the
following reasons: 1) Session variables are disjoint and ea ch
session only modiﬁes its own session variables; 2) Although
the model is shared among the sessions, it is typically man-
aged through a database, and conﬂicts and race conditions
are resolved through the use of database transactions.
3.1 A Simple Example
We deﬁne a simple web application (based on
the account management in Digitalus) to demonstrate
our formal model. The set of actions is A=
{index,open,delete,edit,create}, wherethe indexaction
returns a page that lists the available account managementoptions,openreturns a page for editing, deleting or creating
an account, and the remaining actions are self-explanatory.
There is a single request parameter P={rid}denoting
theidentityoftheaccountthattheuserwantstoexecutethe
action on, and there is a single session variable V={sid}
denoting the identity of the current user. The domain for
these variables is D={u,v,⊥}denoting two user accounts
and the null value. Typically, the data model would store
detailed information about the user accounts and the edit
action would require extra request parameters to update an
account which are ignored in this simple example.
The set of sessions is I={1,2,⊥}(where⊥does not cor-
respondtoanactualsession). Givenastate qofthisapplica-
tion,q(1,sid) identiﬁes the user who initiated the session 1
(which would be set using a login action that is not modeled
here). A transition q/prime= ∆(q,edit,u,2) corresponds to the
accountubeing edited by the user who initiated the session
2. Another transition q/prime= ∆(q,delete,v,1) corresponds to
the account vbeing deleted by the user who initiated the
session 1. Note that, in this transition we would probably
wantq(1,sid)/negationslash=vso that the user does not self-delete.
In this paper, we focus on navigation constraints that re-
strict the possible traces of individual sessions, such as:
•Theedit,deleteandcreateactions can only be ex-
ecuted immediately after an openaction.
•For theopen,delete, andeditactions to be executed,
theridparameter has to be non-null.
•Theridparameter and the sidvariable cannot be
equal when deleteaction is executed.
3.2 Session Traces
To express navigation constraints, we need to deﬁne ses-
sion traces that only track the actions, request parameters
and session variables of individual sessions. To do this, we
deﬁne a function πthat projects a global trace to an individ-
ual session by removing all the session variables and actions
of other sessions.
Definition 2.Letσ= (q0,/epsilon1,⊥|P|,⊥),(q1,a1,/vector p1,i1),
(q2,a2,/vector p2,i2), ...be a global execution trace of an ap-
plication A, andi∈Ibe a session of A. Letσ/prime=
(q0,/epsilon1,⊥|P|,⊥),(q/prime
1,a/prime
1,/vector p1/prime,i/prime
1),(q/prime
2,a/prime
2,/vector p2/prime,i/prime
2),...be the sub-
sequence of the trace σobtained by deleting all tuples
(qk,ak, /vector pk,ik)fromσwhereik/negationslash=iandk >0. Thenavi-
gation trace for session iinσ, denoted as π(σ,i), is the fol-
lowing sequence obtained from σ/prime:π(σ,i) = (q0(i),/epsilon1,⊥|P|),
(q/prime
1(i),a/prime
1,/vector p1/prime),(q/prime
2(i),a/prime
2,/vector p2/prime), ....
Note that given an execution trace σof a web application,
the session trace π(σ,i) lists only the actions executed by
sessioniand the request parameters for those actions, and
it only keeps track of the session variables of session i. We
deﬁne a navigation constraint as a constraint that can be
speciﬁed using the information available in a session trace .
This deﬁnition has several beneﬁts. First, it clearly sep-
arates constraints on the data model from the navigation
logic. Second, this separation enables us to enforce naviga-
tion constraints independently on each session without any
interference from other sessions and without querying the
state of the data model. Third, since all the session trace
information is visible to the bootstrap script (as shown in
Figure 1), we are able to develop a runtime enforcement
238open
index
edit delete createuser
site r.id &
s.id/c185 /c94
/c185r.id &
r.id = r.id’
r.id/c185 /c94
r.id/c185 /c94 r.id/c185 /c94r.id/c185 /c94
r.id/c185 /c94
Figure 4: A portion of the navigation state machine
for the Digitalus system.
mechanism that does not require us to change any part of
the application for navigation constraint enforcement.
4. NA VIGATION STATE MACHINES
All solutions to navigation errors discussed in Section 2
have one point in common: they can be represented by a
ﬁnite state machine which takes into account the last exe-
cuted action, the session variables and the request param-
eters. Unfortunately, analogous to the stateless nature of
HTTP, MVC-based web application frameworks lack mech-
anisms for tracking state. Each request is routed completely
independently of history, based purely on the content of the
current request. Thus, while the MVC framework vastly im-
proves web application organization and control ﬂow man-
agement, it is left to the developer to implement any statefu l
behavior that may be desired. In this section, we introduce
a speciﬁcation mechanism for characterizing stateful navi-
gation behavior.
Anavigation state machine (NSM) speciﬁes the allowable
execution orderings for actions. Its states correspond to ac -
tions, and a transition from one state to another state in-
dicates that the action in the target state can be executed
immediately after the execution of the action of the source
state (this relation need not be deterministic). Addition-
ally, the transitions contain guard expressions that specif y
the pre and post-conditions for execution of an action on the
session variables and request parameters.
Definition 3.Anavigationstatemachine (NSM)Nis a
tuple/angbracketleftS,s0,δ/angbracketrightwhere:S⊆D|V|×A×D|P|is the set of states,
s0= (⊥|V|,⊥,⊥|P|)is the initial state, δ:S×A×D|P|→2S
is the transition relation.
A state of a navigation state machine stores the last ac-
tion performed in a session and the request parameters for
that action, as well as the values of the session variables re -
sulting from that last action. Given the last action, request
parameters for that action and the current values of the ses-
sion variables, the transition relation of the NSM identiﬁe s
which actions and request parameters can come next in the
session trace, and how session variables can change by exe-
cuting those actions.
Figure 4 shows an NSM for the account management
example we discussed above. It contains additional high-
level constructs that ease the representation of NSMs and
makes them less verbose. First, states are hierarchical: Ea ch
“super-state”corresponds to a module of the application an d
each atomic state represents the last action that was exe-
cuted. For example, if the NSM is in state open, then this
means that the openaction of the usermodule was the last
action executed by this session. This way, one can use anarrow from the userbox to the indexstate to represent a
group of transitions, one from each action in usertoin-
dex. Similarly, a single openstate can be used to represent
all combinations of session variables and request parameter s
for that action. The same goes for other actions.
The transitions specify pre-conditions on the previous re-
quest parameters ( rid/prime), the current session variables ( sid)
and the current request parameters ( rid). For example, the
arrow from state opento state deleteis associated with
the pre-condition rid=rid/prime∧rid/negationslash=⊥∧rid/negationslash=sidwhich
means that, if the last action executed was open, then the
deleteaction can be executed as long as the current request
parameter ridis equal to the previous request parameter
rid/prime, the current request parameter ridis not null, and the
current request parameter ridand the current session vari-
ablesidare not the same. Although not shown in the ﬁg-
ure, constraints on how session variables are updated can be
speciﬁed by writing post-conditions on the current and next
session variables and current and previous request parame-
ters. We assume that if there is no post-condition speciﬁed,
then the session variables do not change their values.
Apart from this syntactical sugar, the semantics of the
state machine shown in Figure 4 precisely matches the for-
mal model we deﬁned above. Note that this state machine
enforces all the navigation constraints we identiﬁed for thi s
application.
4.1 Navigation Conformance
A navigation state machine (NSM) recognizes the session
traces that are compliant to the expected use of the web
application.
Definition 4.Letσ= (⊥|V|,/epsilon1,⊥|P|),(/vector v1,a1,/vector p1),
(/vector v2,a2,/vector p2), ...be a session trace and let N=/angbracketleftS,s0,δ/angbracketrightbe a
navigation state machine. We say that Nacceptsσif and
only if(/vector v1,/epsilon1,⊥|P|)∈δ((⊥|V|,⊥,⊥|P|),a1,/vector p1), and for all
k>0,(/vectorvk+1,ak, /vector pk)∈δ((/vector vk,ak−1, /vectorpk−1),ak, /vector pk).
Basedontheabovedeﬁnition, wecandeﬁnewhatitmeans
for a web application to conform to the navigation con-
straints speciﬁed as a navigation state machine.
Definition 5.Given an application Aand a navigation
state machine N, we say that Aconforms to N, if and only
if all the session traces generated by Aare accepted by N.
5. RUNTIME ENFORCEMENT
Note that at any point during the execution of the web ap-
plication, if an action and a set of request parameters are re-
quested by the user that causes a session trace to be rejected
by the navigation state machine, then the web application
should not execute that action. All the errors we discussed
in Section 2 are caused by execution of actions that violate
the navigation constraints. If we can ﬁnd a mechanism that
guarantees that such actions are not executed by the web
application, then we can eliminate navigation errors.
5.1 The NSM Plugin
We achieve this by implementing a navigation state ma-
chine (NSM) plugin, which takes an NSM speciﬁcation as
input and enforces the navigation constraints speciﬁed by
the input NSM during the execution of the web application.
We developed a simple XML based language for speciﬁca-
tionofNSMs. TheNSMpluginisbasicallyaninterpreterfor
239this language. A state is deﬁned as a Module/Controller/-
Action tuple. Given the hierarchical relationship between
modules, controllers, and actions, it is also possible to sp ec-
ify a class of states as a Module/Controller tuple (contains
a set of states, one for each action present in the speciﬁed
controller), or even just a Module (contains a set of states,
one for each action present in each controller present in the
speciﬁed module).
The plugin has 1,100 lines of PHP code, which adds less
than 3% to the source code size in the smallest application
we tested. It operatesproactively. As each requestis routed ,
a decision is made as to whether or not the next state re-
quested by the client is an acceptable transition from the
previously visited state. In the event the request is prohib-
ited, the current action is re-executed, eﬀectively produci ng
a “page refresh”. In the particular case where the current
action is undeﬁned (which can only happen at the very be-
ginning of a transaction), or when a page reload is ﬂagged in
the speciﬁcation as not appropriate (such as when the last
action executes a cash transfer), the initial state of the NSM
is loaded.
Once the requested action has executed, control returns to
the NSM plugin, in order to verify that the action has con-
formed to the speciﬁcation. The plugin compares a snapshot
of the session variables taken before the execution of the ac-
tion with the values of the session variables after the actio n
has executed, and ensures that: The action has modiﬁed
only the variables it is allowed to modify, according to the
speciﬁcation, the variables have been updated to a “valid”
value (a value identiﬁed in the speciﬁcation), and the post-
condition of the action has been established. If the executed
actionisapagerefreshcausedbyanavigationerrorthatwas
blocked, this second pass into the NSM plugin is skipped.
5.2 Compliant Web Applications
The NSM plugin enables us to convert a web application
to acompliant application that does not allow navigation
errors. This is achieved simply by inserting the NSM plugin
rightbeforetheapplication’scontrollerappliesitsnavig ation
logic. For the Zend framework, the NSM plugin is registered
with the application’s front controller by a single line of c ode
in theBootstrap.php ﬁle. For the CodeIgniter framework,
the plugin invocation is added just before the point where
actions are called in the“bootstrap”ﬁle CodeIgniter.php .
Below, we formalize the semantics of a compliant web ap-
plication that has been extended with the NSM plugin. In
order for the plugin to remember the state of the applica-
tion, an additional session variable is stored for each sess ion,
keeping track of the last state of the NSM in that session.
Definition 6.LetA=/angbracketleftQ,B,∆/angbracketrightbe an application and
N=/angbracketleftS,s0,δ/angbracketrightbe a navigation state machine. The compliant
application AN=/angbracketleftQ/prime,B/prime,∆/prime/angbracketrightis an application where: Q/prime⊆
Q×S|I|,B/prime=B×s|I|
0, and(q/prime,/vectors/prime) = ∆/prime((q,/vector s),a,/vector p,i)if and
only ifq/prime= ∆(q,a,/vector p,i),s/prime
i∈δ(si,a,/vector p)ands/prime
j=sjfor each
j∈Iandj/negationslash=iwheresiandsjdenote the i’th andj’th
elements of the vector /vector s, respectively.
A compliant application restricts the navigation behavior
so that each session trace conforms to the navigation state
machine A. We formalize this property as follows:
Theorem 1.Given a web application Aand a navigation
state machine N, the compliant application ANconforms to
the navigation state machine N.6. MODEL CHECKING AN NSM
By automatically analyzing an NSM using model check-
ing, we can iteratively reﬁne its speciﬁcation and discover
and ﬁx potentially critical errors in navigation constraint s
beforetheymanifestthemselvesatruntime. Withoutaspec-
iﬁcation mechanism like navigation state machines it would
be extremely diﬃcult to automatically analyze navigation
constraints of a web application at the implementation leve l,
since navigation errors may only manifest themselves after
a series of client-server interactions and they may be hard
to detect.
6.1 ACTL Model Checking
Navigation constraints can be expressed in terms of the
actions, session variables and request parameters used by
the application. To this end, we employ the universal frag-
ment of CTL, called ACTL. The ground terms of an ACTL
formula are deﬁned as follows: if x,yare session variables
or request parameters ( x,y∈P∪V) andais an action
(a∈A), thenx=yandx/negationslash=y,aand¬aare ground terms.
ACTL formulæ are then built from ground terms using the
standard Boolean connectives ∨and∧and the CTL tem-
poral operators AX(in the next state of every trace), AG
(in every state of every trace), AF(in some state of every
trace) and AU(A(ϕUψ) holds when, for every trace, ϕis
true untilψis true).
Intuitively, the satisfaction of a ground ACTL formula
depends on the lastaction taken and the request parame-
ters for that action, and the current values of the session
variables. An ACTL formula ϕis satisﬁed by an NSM A,
denoted as A |=ϕ, if for every initial state sofAwe have
s|=ϕ. Since the session projection is also a form of NSM,
the same semantics applies to it as well. Given an NSM, our
plugin produces an SMV model that is sent to the NuSMV
model checker [6].
To relate the veriﬁcation results obtained by analyzing a
NSM to the application extended by that NSM, we need to
deﬁne a projection from an application to a session.
Definition 7.LetA=/angbracketleftQ,B,∆/angbracketrightbe an application
whereQ⊆M×D|V|×|I|, and leti∈Ibe a session. The
projection of Ato sessioniis an NSM, i.e., Π(A,i) =N=
/angbracketleftS,s0,δ/angbracketrightwhere
•S⊆D|V|×A×D|P|is the set of states.
•s0= (⊥|V|,⊥,⊥|P|)is the initial state.
•δ:S×A×D|P|→2Sis the transition relation where
(/vectorv/prime,a/prime,/vectorp/prime)∈δ((/vector v,a,/vector p),a/prime,/vectorp/prime)if and only if there exist
q,q/prime∈Qsuch thatq/prime= ∆(q,a/prime,/vectorp/prime,i)andq/prime(i) =/vectorv/prime
andq(i) =/vector v.
The projection of an application Ato sessioniis the NSM
that recognizes exactly the set of navigation traces for ses-
sioniinA.
Theorem 2.LetAbe an MVC application, and i∈Ibe
some session. A navigation trace σis a trace of Π(A,i)if
and only if there exists a trace σ/primeofAsuch thatπ(σ/prime,i) =σ.
The following theorem shows that for a compliant appli-
cationAN, the navigation projections for each session are
guaranteed to satisfy ϕ, provided that the NSM Nsatisﬁes
it.
240Digitalus BambooInvoice Capstone
States 66,400 181,600 306
BDD nodes 3,157 2,457 1,654
Memory 4.44 MB 4.42 MB 4.38 MB
Model building 0.4 s 0.4 s 0.1 s
Table 2: Summary of model checking results.
Theorem 3.LetAbe an application, Nbe an NSM and
ϕbe an ACTL formula. If N |=ϕ, then for every session
i∈I,Π(AN,i)|=ϕ.
Proof. Suppose the contrary; that is, N |=ϕ, but there
exists some session isuch that Π( AN,i)/negationslash|=ϕ. Sinceϕis in
the universal fragment of CTL, this entails that there exists
a trace of Π( AN,i) which is a counter-example of ϕ. But
by Theorem 1, we know that every trace of Π( AN,i) is a
trace ofN, hence there is also a counter-example of ϕinN,
a contradiction.
This theorem has an important consequence. Although
navigation state machines provide a mechanism for speciﬁ-
cation and veriﬁcation of navigation constraints, any con-
clusions drawn from such a veriﬁcation eﬀort are valid only
if we can guarantee that a web application conforms to a
given navigation state machine speciﬁcation. By the pre-
vious result, the seemingly daunting task of guaranteeing
conformance to a speciﬁc navigation model across an entire
application becomes a manageable task for web applications
built based on the MVC architecture. In other words, the
veriﬁcation results we obtain by model checking a naviga-
tion state machine are guaranteed to hold for a compliant
web application that uses that navigation state machine.
6.2 Sample Navigation Properties in ACTL
Equipped with this theorem, it is now possible to perform
formal veriﬁcation of some navigation properties in the web
applications we studied. The plugin we developed automat-
ically translates an NSM into an input ﬁle to the NuSMV
model checker. The results are summarized in Table 2.
As one can see from these ﬁgures, buildingand loadingthe
model from each NSM is a trivial task, and takes NuSMV
less than a second for all three applications. Indeed, none
of the NSMs generated SMV models of more than 200,000
states and used more than a few megabytes of memory to
be processed.
We identiﬁed several generic navigation properties that
can be used for many applications. We regard these proper-
ties as good indicators of the correct navigation design of an
application; consequently, a routine check of the following
ACTL formulas could be used to identify potential naviga-
tion issues if they are violated.
1) An“index”action must be eventually executed:
AF(action = index)
The “index” actions are generally intended as the starting
point; consequently if an “index” action is never executed
this hints at a navigation problem.
2) Once you login, the only way to go back to the login
page is by traversing the logout page:
AG(controller = login →
¬A(controller = login Ucontroller = logout))Application States Transitions Variables
Digitalus 32 48 7
BambooInvoice 63 80 8
Capstone 8 16 1
Table 3: Size of navigation state machines for each
application
This property summarizes the expected behavior of a login
system; we have seen that it is false both in the plain Dig-
italus and BambooInvoice applications. However, the NSM
of both applications satisﬁes this property; by the previous
theorem, the compliant extensions of Digitalus and Bam-
booInvoice satisfy it as well.
3)Eachcontroller chasthe“index”actionasitsonlyentry
point from other controllers:
AG(controller /negationslash=c→
AX(controller /negationslash=c∨action = index))
This property is similar in spirit to some form of visibility
mechanism: clearly, two controllers do not implement sep-
arate functionalities if they refer to pages other than thei r
respective entry points. The property is false in Digitalus ,
both with and without the NSM plugin. Indeed, the action
admin/site/index calls admin/user/open; this is expected
by the application and must be allowed by the NSM. The
property is also false in BambooInvoice, where the“clients ”
controller calls non-index actions in the“clientcontacts ”con-
troller, and the“invoices”controller calls non-index act ions
in the“clients”controller.
Due to the small size of the models (at least according
to model checking standards), veriﬁcation times for these
properties are negligible. NuSMV’s internal timefunction
returned an elapsed time of 0 seconds for all properties we
tested. This is due to session modularity, and should be
contrasted with the expected model of the application, if all
sessions had to be considered.
7. EMPIRICAL EV ALUATION
For each of the three applications described in Section 2,
we deﬁned a navigation state machine. This NSM was cre-
ated manually, in parallel to an exploration of the possi-
ble navigation paths in the application. Guards were later
added to the transitions, when request parameters or ses-
sion variables were required to execute a particular action.
Statistics about these state machines are summarized in Ta-
ble 3. Equipped with these NSMs, we evaluated the perfor-
mance of the NSM plugin on the resulting extended MVC
applications.
Building the NSM for each application took roughly 4
hours; this approximation is generous, as it also includes
the time required to carefully write down sample navigation
errors for the purpose of this paper, as well as the capture of
screenshots for each step of these errors. Yet, in general, w e
believe that the speciﬁcation of an NSM, which should be
done along with the development of the application, should
not be too daunting. Following a natural design principle,
each module should be self-contained and implement a unit
functionality; hence, it should have an“index”-like action a s
its only entry point from the other modules (this is one of
the properties we checked in Section 6.2). In doing so, cross -
module dependencies are limited; what remains to specify is
241the behavior of each module separately, which consist each
of only half a dozen actions and transitions in our examples.
Case in point, lots of errors in the web applications we stud-
ied are caused by cross-module dependencies for pages other
than the“main”module page.
7.1 Error Prevention
A ﬁrst, qualitative component of evaluation is the plugin’s
capability to prevent navigation errors, and in particular t he
ones described in Section 2. Therefore, our ﬁrst experiment
was to reproduce the sequences of actions for navigation
errors Error 1-5 while the NSM plugin is in action, and to
compare the pages received with the original application’s
response. We observed that all ﬁve navigation error types
were caught by the plugin; on the last step of each sequence,
instead of returning an error page (or error messages within
a page), the NSM plugin prevents the faulty action from
being executed and simply recalls the last valid page.
This readily presents advantages in terms of user expe-
rience (by allowing a graceful handling of all navigation
errors) and security (by preventing implementation detail s
from leaking through uncaught error messages). However,
the NSM plugin does not merely catch and hide error mes-
sages once they are triggered; it actually prevents them by
diverting the control ﬂow before anything happens. Hence,
in the case of Navigation Error 1, the“user-delete”action’s
side eﬀect (removing a user from the database) is avoided
instead of coped with after the fact.
Apart from these qualitative considerations, we were also
interested in estimating the proportion of navigation error s
that each application would let through, were it not for the
presence of the plugin. As we have seen, without a naviga-
tion state machine, it is possible to jump from any action to
any other. If we denote by N(s,k−1) the number of valid
traces of length k−1 ending in state s, then the number of
traces of length k, which are valid for the ﬁrst k−1 actions
and which violate the NSM at the k-th is given by:
Nv(k) =/summationdisplay
s∈SN(s,k−1)·|{s/prime∈S:s/negationslash→s/prime}|
i.e. we extend each valid trace of length k−1 ending in sby
one of the actions s/primethat are not adjacent to sin the NSM,
giving us a“bad”trace of length k.
However, in some occasions, violating the NSM has no
undesirable side eﬀects; this is the case for all actions who se
incoming transitions are not guarded. However, the actions
thathaveguards, ifcalledfromthewrongpreviouspage, will
havetheirpreconditionviolated; theresultsofsuchviolati on
have been shown in Section 2. Let Sgbe the set of such
“guarded”actions in the NSM. The number of traces which
violate a guard at the k-th step is given by:
Ng(k) =/summationdisplay
s∈SN(s,k−1)·|Sg∩{s/prime∈S:s/negationslash→s/prime}|
i.e. we restrict ourselves to non-adjacent actions that are
guarded. Therefore, the proportion of“bad”traces of lengt h
kwhich actually cause errors is given by Ng(k)/Nv(k). This
ratio represents the proportion of traces for which a naviga-
tion constraint is assumed, but not checked, by the appli-
cation. We computed this ratio for increasing values of k,
using both the NSM for the Digitalus CMS and for Bam-
booInvoice.Application No Plugin With Plugin
Digitalus 11 12
BambooInvoice 183 199
Capstone 90 122
Figure 5: Server processing time, in milliseconds,
for NSM-compliant actions, both with and without
the NSM plugin.
The resulting curve converges to a stable value after k
reaches 5, which is approximately the depth of the applica-
tion’s state machine in both cases. With Digitalus, when
a user (or an automated web crawler) invokes the “wrong”
action from its current point in the application, there is ap -
proximately a 52% chance that this error will not be caught
by the application and create a page containing PHP errors
or warnings, as shown in Figures 2-3. With BambooInvoice,
this chance is 64%. Alternately, this indicates that in both
applications, the majority of the pages blocked by the NSM
plugin would actually cause errors without the plugin.
One can also consider the number of traces that the NSM
prevents, but which would not have caused an error in the
original application. While the number of errors caught by
the NSM gives us information about the application’s suc-
cess (or lack thereof) at enforcing its own navigation logic,
the converse only gives us information about how conserva-
tive is a particular instance of NSM for that application. Fo r
this reason, we did not compute this measurement.
7.2 Impact on Processing Time
We then measured the incurred costs of using the NSM
plugin on all three applications. In a ﬁrst time, a validse-
quenceofoperations, producingnoerrorsandvisitingallthe
actions (including create/delete operations), was manual ly
executed on each application. The application was instru-
mented to record and write to a ﬁle the start and end time of
each PHP processing request. The same sequence was then
re-executed, this time with the NSM plugin registered and
running. The average processing time per request in each
application is shown in Figure 5; the times were measured
on an AMD 1.4 GHz Windows XP machine, using 768 MB
of RAM and running Apache 2 and PHP 5.1.
While this ﬁgure shows that the NSM plugin does induce
processing overhead, during normal use of an application,
this overhead is negligible: 2% in the case of Digitalus, and
9% in the case of BambooInvoice. In absolute numbers, this
amounts to at most 20 milliseconds per request in the worst
case. Moreover, in its present version, the plugin has to
load and parse the state machine’s XML ﬁle on each page
request; therefore, these ﬁgures should be seen as an upper
bound as they could easily be improved.
In addition to processing overhead in valid requests, we
studied the performance consequences of error processing.
To this end, we selected actions in each application and
called them out of context to deliberately violate the NSM
speciﬁcation. We retained the situations where the applica -
tion produced uncaught errors: errors where the applicatio n
is still able to load part of the page, or which display only
PHP errors of the class “warning” or “notice”, as in Figure
2, and errors where the application crashes and the error
page is produced by PHP itself; this is generally the case for
“fatal errors”, as in Figure 3.
For each action, we calculated its processing time (in-
242Page No Plugin With Plugin
admin/media/create-folder 28 26
admin/media/upload 18 32
admin/user/edit 22 32
admin/user/open 14 24
invoices/newinvoice 938 574
(a) Warnings
Page No Plugin With Plugin
admin/page/edit 416 32
admin/media/delete-folder/folder 424 36
admin/user/delete 434 22
invoices/view 564 594
(b) Errors
Figure 6: Server processing time, in milliseconds, for
pages that produce PHP warnings and fatal errors,
both with and without the NSM plugin.
cluding the PHP error handling), repeating the operation
5 times and taking the average of those measurements. We
then proceeded to the same invocation, this time with the
NSM plugin enabled. In that situation, no PHP error is
produced, and the application simply reloads the last valid
page. Sample processing times for various warnings and er-
rors are shown in Figure 6.
While in some cases the NSM plugin induces the same
overhead as before, surprisingly, in some cases the running
time with the plugin is lowerthan without the plugin. In
these situations, it takes more time for PHP to execute the
script and generate the warnings, than it takes to simply
run the NSM plugin, determine that the requested action
violates the state machine, and reload the last valid page.
This phenomenon is even more marked in the case of fatal
errors, where the action does not execute at all and PHP
simply returns a white page with an error message. In the
case of Digitalus, running the NSM plugin is more than ten
times faster than letting the application provoke a fatal er -
ror.
Therefore, although the plugin induces a slight overhead
over the normal use of an application, its capability to catc h
navigation errors can actually save server processing time.
8. RELATED WORK
The problem of navigation inconsistencies in web applica-
tions has been described in earlier work by Licata et al. [17] ,
where it has been shown that multiple browser windows can
lead the user of a popular travel reservation site to purchas e
the wrong ﬂight. To alleviate the problem, the authors sug-
gest the development of a new programming language based
on Scheme, in which such navigation inconsistencies reduce
to type checking errors [16]. In contrast, the approach pre-
sented in this paper neither warrants the introduction of a
new programminglanguage, nor does it require any substan-
tial modiﬁcation to an existing application. Moreover, sinc e
NSMs are based on statecharts, a common speciﬁcation for-
malism that is part of UML, we believe that their adoption
will not require a signiﬁcant learning eﬀort.
Modeling web applications as state machines was sug-
gested a decade ago [20], and has already been used to au-
tomatically generate test sequences [21] and perform some
form of model checking [19]. The veriﬁcation of standard,
non-MVCweb applications, has also been attemptednumer-ous times in recent years [8–10,14,18]. There has also been
work on speciﬁcation of interfaces between two components
as state machines [3,7]. However, the usefulness of these
works is mitigated by one key limitation: one cannot as-
sume that the navigation ﬂow intended by the programmer
is the only possible path of execution in the implementation.
Indeed, as much as formal, ﬁnite state models are used for
testing and veriﬁcation, none of the previous works actually
use this model to enforceproper navigation sequences on a
running application, as the NSM plugin allows.
Guha et al. [11] statically analyze an Ajax application
on the client side and extract a control-ﬂow graph from
its source code. A monitor then enforces, on the server
side, that the requests received follow the extracted client
model. This approach cannot be used to prevent naviga-
tion errors, since the speciﬁcation is based on the client’s
code, which may not correspond to what the server expects.
Han and Hofmeister [13] deﬁne a formal navigation model
for web applications based on statecharts. However, the
model does not include request parameters such as HTTP
GET or POST ﬁelds; consequently, most navigation con-
straints presented in our work can not be handled. This
remark also applies to the Dialog Flow Notation [5]. The
Spring Framework3allows the deﬁnition of a state machine
called “web ﬂow”; however the ﬂow’s identiﬁer is passed as
a parameter in the URL for each action, which makes the
application vulnerable to sequences involving bookmarks, as
in Navigation Error 2. Book et al [4] present a formal model
for specifying input validation rules for web applications a nd
present a framework where an implementation can be gener-
atedfromtheformalspeciﬁcation. Incontrast, ourapproac h
combines the constraints on sequencing of user actions with
constraints on input data. Moreover, our approach can be
integratedinexistingapplicationsanddoesnotrequireuser s
to adopt a new framework for developing web applications.
Finally, none of the above approaches combine model check-
ing with runtime enforcement or provide an empirical anal-
ysis of the overhead incurred by runtime enforcement.
The enforcement of NSMs on a web application can also
be viewed as a form of runtime monitoring of linear tempo-
ral logic properties [2]. Such a monitor has been developed
for Ajax web applications communicating with web services
through SOAP [12]. Its working principle is similar to the
NSM plugin, but on the client side instead of the server side;
therefore, it does not have access to session variables like
the NSM plugin. Moreover, the use of LTL as a speciﬁca-
tion language can make the speciﬁcation of some navigation
constraints problematic, as LTL is too weak to encode a
ﬁnite-state machine. It also raises the issue of model check-
ingACTLproperties, asinSection6.1, overasystemdeﬁned
by a conjunction of LTLformulas.
Finally, the use of the MVC design pattern to central-
ize navigation decisions bears some similarity to aspect-
oriented programming (AOP). The NSM plugin, registered
intheMVCapplication, actsasa“pointcut”thatistriggere d
whenever a new page is requested; the advice associated
with that pointcut is used to enforce the navigation state
machine. In that respect, the NSM plugin could also nicely
ﬁt into an aspect-oriented web application framework [15].
3http://springsource.org/webﬂow
2439. CONCLUSION
We have shown that web applications mishandle unex-
pected navigation sequences caused by the uncontrolled use
of a web browser’s navigation functionalities. In particula r,
we calculated that more than half of all possible unexpected
navigation sequences are improperly handled in three real-
world applications we studied.
We showed that the navigation state machines presented
in this paper can help relieve these problems by restricting
the control-ﬂow of an application to sequences intended by
the developer. Our main conclusion is that the beneﬁts of
the extra layer of veriﬁcation largely outweigh its overhead .
This is particularly true if some unexpected user requests
produce PHP error pages. In this case, in addition to pro-
ducing a cryptic message possibly revealing implementation
details, processing the error can incur a CPU overhead of as
much as 10 times the time required to check the error and
redirect to a correct page.
As future work, we plan to investigate automatic extrac-
tion of navigation state machine skeletons, either through
automated crawling or by analyzing the source code. In ad-
dition, the implementation of the plugin as a reverse proxy
directly in the HTTP server could detach its application
from any language or MVC platform.
10. REFERENCES
[1]19th IEEE International Conference on Automated
Software Engineering (ASE 2004), 20-25 September
2004, Linz, Austria . IEEE Computer Society, 2004.
[2] D. A. Basin, F. Klaedtke, S. M ¨uller, and
B. Pﬁtzmann. Runtime monitoring of metric
ﬁrst-order temporal properties. In R. Hariharan,
M. Mukund, and V. Vinay, editors, FSTTCS ,
volume 2 of LIPIcs, pages 49–60. Schloss Dagstuhl -
Leibniz-Zentrum fuer Informatik, 2008.
[3] A. Betin-Can and T. Bultan. Veriﬁable web services
with hierarchical interfaces. In Proceedings of the
IEEE International Conference on Web Services
(ICWS 2005 , pages 85–94, 2005.
[4] M. Book, T. Br ¨uckmann, V. Gruhn, and M. H ¨ulder.
Speciﬁcation and control of interface responses to user
input in rich internet applications. In Proceedings of
the 24th IEEE/ACM International Conference on
Automated Software Engineering (ASE 2009) , pages
321–331, 2009.
[5] M. Book and V. Gruhn. Modeling web-based dialog
ﬂows for automatic dialog control. In ASE[1], pages
100–109.
[6] A. Cimatti, E. M. Clarke, E. Giunchiglia,
F. Giunchiglia, M. Pistore, M. Roveri, R. Sebastiani,
and A. Tacchella. NuSMV 2: An opensource tool for
symbolic model checking. In E. Brinksma and K. G.
Larsen, editors, CAV, volume 2404 of Lecture Notes in
Computer Science , pages 359–364. Springer, 2002.
[7] L. de Alfaro and T. A. Henzinger. Interface automata.
InProceedings 9th Annual Symposium on Foundations
of Software Engineering , pages 109–120, 2001.[8] L. Desmet, P. Verbaeten, W. Joosen, and F. Piessens.
Provable protection against web application
vulnerabilities related to session data dependencies.
IEEE Trans. Software Eng. , 34(1):50–64, 2008.
[9] A. Deutsch, L. Sui, V. Vianu, and D. Zhou. A system
for speciﬁcation and veriﬁcation of interactive,
data-driven web applications. In S. Chaudhuri,
V. Hristidis, and N. Polyzotis, editors, SIGMOD
Conference , pages 772–774. ACM, 2006.
[10] F. M. Donini, M. Mongiello, M. Ruta, and R. Totaro.
A model checking-based method for verifying web
application design. Electr. Notes Theor. Comput. Sci. ,
151(2):19–32, 2006.
[11] A. Guha, S. Krishnamurthi, and T. Jim. Using static
analysis for Ajax intrusion detection. In J. Quemada,
G. Le´ on, Y. S. Maarek, and W. Nejdl, editors, WWW,
pages 561–570. ACM, 2009.
[12] S. Hall´ e and R. Villemaire. Browser-based
enforcement of interface contracts in web applications
with BeepBeep. In A. Bouajjani and O. Maler,
editors,CAV, volume 5643 of Lecture Notes in
Computer Science , pages 648–653. Springer, 2009.
[13] M. Han and C. Hofmeister. Relating navigation and
request routing models in web applications. In
G. Engels, B. Opdyke, D. C. Schmidt, and F. Weil,
editors,MoDELS , volume 4735 of Lecture Notes in
Computer Science , pages 346–359. Springer, 2007.
[14] M. Haydar. Formal framework for automated analysis
and veriﬁcation of web-based applications. In ASE[1],
pages 410–413.
[15] K. Hokamura, N. Ubayashi, S. Nakajima, and A. Iwai.
Aspect-oriented programming for web controller layer.
InAPSEC, pages 529–536. IEEE Computer Society,
2008.
[16] S. Krishnamurthi, R. B. Findler, P. Graunke, and
M. Felleisen. Modeling Web Interactions and Errors ,
pages 255–275. Springer, 2006.
[17] D. R. Licata and S. Krishnamurthi. Verifying
interactive web programs. In ASE[1], pages 164–173.
[18] H. Miao and H. Zeng. Model checking-based
veriﬁcation of web application. In ICECCS , pages
47–55. IEEE Computer Society, 2007.
[19] E. D. Sciascio, F. M. Donini, M. Mongiello, R. Totaro,
and D. Castelluccia. Design veriﬁcation of web
applications using symbolic model checking. In
D. Lowe and M. Gaedke, editors, ICWE, volume 3579
ofLecture Notes in Computer Science , pages 69–74.
Springer, 2005.
[20] P. D. Stotts, R. Furuta, and C. R. Cabarrus.
Hyperdocuments as automata: Veriﬁcation of
trace-based browsing properties by model checking.
ACM Trans. Inf. Syst. , 16(1):1–30, 1998.
[21] S. Yuen, K. Kato, D. Kato, and K. Agusa. Web
automata: A behavioral model of web applications
based on the MVC model. Information and Media
Technologies , 1(1):66–79, 2006.
244