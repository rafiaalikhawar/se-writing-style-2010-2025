Discriminating InÔ¨Çuences among Instructions in a
Dynamic Slice
Vijay Krishna Palepu and James A. Jones
University of California, Irvine
{vpalepu, jajones}@uci.edu
ABSTRACT
Dynamic slicing is an analysis that operates on program ex-
ecution models ( e.g., dynamic dependence graphs) to sup-
port the interpreation of program-execution traces. Given
an execution event of interest ( i.e.,the slicing criterion), it
solves for all instruction-execution events that either aect
orare aected by that slicing criterion, and thereby reduces
the search space to nd inuences within execution traces.
Unfortunately, the resulting dynamic slices are still often
prohibitively large for many uses. Despite this reduction
search space, the dynamic slices are often still prohibitively
large for many uses, and moreover, are provided without
guidance of which and to what degree those inuences are
exerted. In this work, we present a novel approach to quan-
tify the relevance of each instruction-execution event within
a dynamic slice by its degree of relative inuence on the
slicing criterion. As such, we augment the dynamic slice
with dynamic-relevance measures for each event in the slice,
which can be used to guide and prioritize inspection of the
events in the slice. We conducted an experiment that evalu-
ates the ability of existing dynamic slicing and our approach,
using dynamic relevance, to correctly identify sources of ex-
ecution inuence and state propagation. The results of the
experiment show that inspections that were guided by tra-
ditional dynamic slicing to nd the root cause for a failure
reduced the search space by, on average, 61.3%. Further,
inspections guided with the assistance of the new dynamic
relevance reduced the search space by 96.2%.
Categories and Subject Descriptors
D.2.5 [ Software Engineering ]: Testing and Debugging
Keywords
Program Analysis, Dependence Analysis, Dynamic Slicing
1. INTRODUCTION
Dynamic slicing is a well known technique that is used for
describing program behavior and for several software com-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ASE‚Äô14, September 15-19, 2014, Vasteras, Sweden.
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2642962 .prehension and maintenance tasks. In use, its user ( e.g.,
a developer or another automated analysis technique) ex-
presses an interest in an execution event, which is referred to
as the slicing criterion. The dynamic-slicing approach then
computes the set of all instruction-execution events1that
inuence (or are inuenced by) the slicing criterion. The re-
sult of the analysis is a dynamic slice , and is comprised of a
undierentiated set of either static instructions or dynamic
instruction-execution events that are inuential for the slic-
ing criterion. Such dynamic slices could support develop-
ment tasks such as debugging ( e.g., [6, 23]), for which the
criterion may represent an observed error state at a break-
point, or change-impact analysis ( e.g., [16]), for which the
criterion may represent points in an execution that new logic
may be introduced.
Despite its importance and widespread use in software en-
gineering tools and techniques, there exists a general consen-
sus that dynamic slices are often intractable for programmer
inspection and navigation due to their size and complexity.
As examples, LaToza and Myers [10] note that developers
comprehend program behavior by navigating dependence re-
lations within a dynamic slice that can often be prohibitively
challenging, and Zhang et al. [23] found backward dynamic
slices as large as 49% of the program execution trace and for-
ward dynamic slices as large as 63% of the traces. Moreover,
such resulting dynamic slices are typically presented an un-
ordered sets of instruction instances, without any auxiliary
information that may assist the developer or client analysis
in their interpretation. And, although some existing work
has been applied to \pruning" dynamic slices to further re-
duce their size [20, 22], the result is still a set of instances
without information to help assess the relative inuence of
each such instruction instance on the criterion.
Given the fundamental diculties of size and complex-
ity in inspecting dynamic slices to understand program be-
havior, in this work we propose a mechanism that is able
to dierentiate the degree of inuence between instruction-
execution events. As a result, slicing users can perform
prioritized inspections of the slice to more quickly identify
most-relevant events, and as such, further reduce the search
for inuences. We also conducted an experiment to deter-
mine the degree to which the additional relevance informa-
tion can further support dynamic-slice interpretation and
1Aninstruction-execution event is a specic instance of an
execution of an instruction within a single execution of the
program. For example, an instruction may be executed
many times during an execution | each such instruction
execution constitutes an instruction-execution event. We
also refer to these as instruction instances .
37
search reduction. Our results found that although dynamic
slicing was eective in reducing the search for a debugging
task (on average, reducing the cost by 61.3% from the orig-
inal execution), using the additional relevance information
to augment the dynamic slice substantially further reduced
the search (on average, reducing the cost by 96.2%, or an
additional cost savings of 34.9%).
The main contributions of this work are:
A new measure, that we are calling dynamic relevance ,
that represents the degree to which an instruction's
execution distinctively inuences the slicing criterion.
A novel, augmented model of a dynamic slice that en-
codes a degree of inuence on the dynamic-substantially
further slicing criterion, i.e., our dynamic relevance
measure, for each instruction-execution event in the
dynamic slice. These measures may provide valuable
information to direct users and client analyses toward
instruction-execution events that strongly aect the
state at the slicing criterion.
An experimental design that evaluates the ability of
dynamic slicing to narrow the search space for root-
cause program-state infection, and further, the poten-
tial additional benet of augmenting the dynamic slic-
ing result with dynamic relevance measures.
2. APPROACH
In this section, we describe the dynamic-relevance mea-
sure and the approach to generate it. The rst three steps
are shared with traditional dynamic slicing. First, we instru-
ment a program to record an execution trace that captures
all instruction-execution instances, along with their reads
and writes to memory. Then, using control-dependence and
data-dependence analyses, we compute the dynamic depen-
dence graph for the execution trace. Next, we perform a
traversal of the graph while tracking memory objects and
their denitions and uses. Finally, we perform an analysis
to determine the degree to which each instruction instance
in the dynamic slice is relevant to the slicing criterion.
Motivating Example. In Figure 1 we present a simple
program that simulates three temperature readings from a
thermometer sensor that gives one erroneous reading. The
program reads the sensor the values, records them, sorts
them, and computes the mean temperature of the lowest of
one, two, and three readings.
We created and use this simple example program to demon-
strate the process and goals of the dynamic relevance mea-
sure to augment dynamic slicing. Although the program is
simple and the program-model depictions are merely rep-
resentative, we nevertheless implemented the example pro-
gram, monitored its execution to gather its execution trace,
computed its dynamic dependence graph and dynamic slice,
and calculated the dynamic relevance values for each instruc-
tion instance. Despite the need to abstract the full trace,
graph, slice, and relevance to t in this paper, we provide
the actual artifacts of these analyses online.2
As shown in the top part of Figure 1, we start with ana-
lyzing the most basic model of program behavior i.e.,, the
source code of the software program. The actual source code
for this example is compose of 74 lines of code (some of which
2http://www.ics.uci.edu/~vpalepu/ase14/approachExample
m1:  void main() {m2:    addTemperatureAndSort(-100);m3:    addTemperatureAndSort(-420);m4:    addTemperatureAndSort(27);m5:    printAverageOfBottomTemps(3);m6:    printAverageOfBottomTemps(2);m7:    printAverageOfBottomTemps(1);m8:  }a1:  void addTemperatureAndSort(int temp) {a2:    size = size + 1;a3:    int i = size - 1;a4:    if (i < size) {a5:      temps[i] = temp;a6:    } a7:    while(i > 0) {a8:      if(temps[i-1] > temp) {a9:        temps[i] = temps[i-1];a10:      i = i - 1;a11:    } else {a12:      break;a13:    }a14:  }a15:  temps[i] = temp;a16: }g1:  global size = 0;g2:  global int[10] temps;   p1:  void printAverageOfBottomTemps(int n) {p2:    int sum = 0;p3:    int i = n-1;p4:    for(; i >= 0;) {p5:      sum = sum + temps[i];p6:      i = i - 1;p7:    }p8:    print (Ô¨Çoat)sum/(Ô¨Çoat)n;p9:  }SOURCE CODE
g1m2a2a3a4a5a15m3p2p8p5m4m5m6EXECUTION TRACEDYNAMIC DEPENDENCE GRAPHg1m2a2a3a4a5a15m3p2p8p5m4m5m6DYNAMIC SLICEg1m4a2a3a4a5a15p8m5RELEVANCE-AUGMENTEDDYNAMIC SLICEg1m4a2a3a4a5a15p8m5Figure 1: Models of program behavior at each step.
are condensed in the gure). The source code is processed
into an instrumented executable binary that is able to pro-
duce execution traces for the software program's execution.
The compiled bytecode les contain 22 executable bytecode
instructions.
As depicted in Figure 1, execution traces represent a long
sequence of instruction-execution instances (represented by
nodes in the gure), i.e.,each distinct runtime execution of
each static instruction from the program, and each static
instruction may be executed multiple times throughout the
execution. In our example, the execution trace contained
224 instruction-execution instances.
We then analyze the execution trace to deduce depen-
dence relations between the instruction-execution instances
for both control-dependence and data-dependence. The re-
sult of this analysis is a dynamic dependence graph, as shown
in Figure 1, with directed edges between dierent instruc-
tion instances, depicted as nodes. The dynamic dependence
graph contains an equal number of nodes as the execution
trace | for our example program, this was 224 nodes that
represent instruction-execution instances.
In order to nd the root-cause of an anomalous output, we
compute the backward dynamic slice of that anomalous out-
put. In our example, the anomalous output is represented
as a higher-than-usual three-day average, and the root cause
is the erroneous thermometer sensor reading. As such, we
use the anomalous print instruction instance as the criteria
to prune the dynamic dependence graph by performing dy-
namic slicing. As highlighted in Figure 1, the dynamic slice
is smaller, now containing 80 instruction instances (from the
original 224 in the trace).
To further dierentiate the instruction-execution events
within the dynamic slice, we then augment its constituent
instruction-execution instances with relevance measures with
regard to the anomalous print instruction instance as the
slicing criteria. Such relevance measures provide a nuanced
view of the dynamic slice, drawing attention to those in-
struction instances, over others, with high relevance to the
anomalous print instruction instance, potentially leading to
the reading of the anomalous temperature without investi-
gating each of the 80 undierentiated instruction instances
38in the dynamic slice. Figure 1 depicts instruction-execution
instances with a higher relevance measures with darker nodes,
while those with lower relevance measure are indicated with
lighter nodes. When considering all instruction-execution
instances in the dynamic slice ( i.e., 80 nodes) the actual
root-cause thermometer-sensor reading is ranked at posi-
tion 25 out of all instruction-execution instances. The other
highly ranked instruction-execution instances are also tran-
sitive dependencies that strongly and distinctively inuence
the anomalous output, which may also lead to the root
cause. Furthermore, when searching among all thermometer
readings, the erroneous reading is ranked at the #1 position,
and thus the dynamic-relevance measure is able to help pin-
point the root-cause infection.
Computing Dynamic Relevance.
The computation of dynamic relevance between instruc-
tion instances relies on the observation that some instruction
instances inuence fewer instruction instances than others.
Consider the instruction instances si,tjandvkfor the static
instructions s,tandv, respectively. The instruction instance
sithat exclusively inuences the instruction instance tj, is
likely to be more relevant to tj, than an instruction instance
vkthat inuences multiple instruction instances; only one of
which is tj. In other words we posit that, the instance si,
is relevant to tj, because the sole reason for the execution,
si, ofsis to inuence the forthcoming execution, tj, of the
instruction t.
We extend this notion of relevance to instructions in-
stances that are related by direct as well as transitive dy-
namic inuences as follows. Consider the instruction in-
stances siandtj, such that sitransitively inuences tj. We
say that siis highly relevant to tjifsidistinctively inu-
ences (directly or transitively) those instruction instances on
which tjis dependent.
The following steps elucidate the computation of the dy-
namic relevance of an instruction instance sifor another
instruction instance tj, where tjis an instruction instance
of interest, and together tjandsiare part of the dynamic
dependence graph G.
Step 1. We obtain the instructions that directly or transi-
tively inuence tj. A backward dynamic slice with tj
as the slicing criterion, i.e.,Sbak(G; tj) will constitute
the instructions that inuence tj.
Step 2. We obtain all instruction instances that siinu-
ences. The forward dynamic slice with sias the slicing
criterion, i.e.,Sfwd(G; si), will constitute the instruc-
tions that siinuences.
Step 3. To compute the relevance of sitotj, we compare
the number of instruction instances in Sfwd(G; si) (for-
ward slice from si) that are also present in Sbak(G; tj)
(backward slice from tj), to the total number of in-
struction instances that are present in Sfwd(G; si) (for-
ward slice from si).
We denote the relevance of instruction instance sifor
another instruction instance tjasDynRel (si; tj).
DynRel (si; tj) =jSbak(G;tj)\Sfwd(G;si)j
jSfwd(G;si)j, where,
tjis the instruction instance of interest ( i.e.,the slicing
criterion);siis an instruction instance that has a dynamic inuence
ontj(i.e.,siis included in the backward dynamic slice
oftj);
DynRel (si; tj) is the measure of relevance of sifortj;
Sbak(G; tj) is the backward slice from tj;
Sfwd(G; si) is the forward slice from si;
jS bak(G; tj)\Sfwd(G; si)jis the number of instruction in-
stances common to both Sbak(G; tj) andSfwd(G; si); and
jS fwd(G; si)jis the number of instruction instances in
Sfwd(G; si)
If, however, the instruction instance si, whose dynamic
relevance measure is being computed, is not a part of the
backward dynamic slice with tjas the slicing criteria, the
dynamic relevance measure of siis set to 0. In contrast,
instruction instances that do not inuence (directly or tran-
sitively) any other instruction instance that has no inuence
on the slicing criteria would have a dynamic relevance mea-
sure of 1.0, with regard to the slicing criteria.
In summation, such a formulation of dynamic relevance,
as stated above, penalizes the dynamic relevance measure
for an instruction instance if the instruction instance were
to directly or transitively inuence any instruction instance
that has no forward inuence on the slicing criteria. In ef-
fect, for an instruction instance si, a increasing number of
instruction instances that are inuenced by siand have no
inuence on the slicing criteria, will decrease the dynamic
relevance measure of siwith regard to the slicing criteria.
3. EVALUATION
We evaluated the degree to which the dynamic-relevance
measure can assist in distinguishing relevant execution events.
As such, we conducted a controlled experiment on a set of
executions for which program state was infected early in
an execution, and the rst external manifestation of failure
(i.e., the output instruction-execution event that rst re-
vealed the infection) is selected as the slicing criterion. We
then compare the search reduction that is provided by tra-
ditional dynamic slicing with that aorded by our dynamic-
relevance-augmented dynamic slices by examining the slice
in order of decreasing relevance.
3.1 Experimental Setup
The subject of our experiment was the Java program Nano-
XML ( >7,000 LOCs). The dynamic-slicing and relevance
technique were implemented in Java and analyzed at the
ne-grained bytecode-level.
Because the goal of our experiment is to evaluate the
validity of the relevance measures assigned to instruction-
execution events in a dynamic slice, we established the ground
truth for the targeted root-cause instruction-execution event.
To do this, we introduced a data mutation on a small in-
put element within each large XML input to our subject
program. We then executed the program with this mu-
tated input, which then infected the program state, prop-
agated throughout the execution of the program, and -
nally producing mutated output as a result of the program
state infection and propagation. For each, we captured
the execution trace and recorded the specic instruction-
execution instance in the beginning of the execution that
input the specic mutated elements. We also monitored
the output to determine the rst external symptom of the
39imposed mutation infection | the outputting instruction-
execution instance that was responsible for producing that
symptom was dened as our slicing criterion. As a re-
sult, we establish the evaluation ground truth for which in-
put instruction-execution events are most relevant to the
symptom-producing output instruction-execution event.
3.2 Experimental Variables
We assess eectiveness according to the search-space size
of identifying the source of the program state infection |
in this case, the input read instruction instances responsible
for reading the mutated input elements. In our experiment,
we control for all variables and vary only the technique ( i.e.,
thetreatment or the independent variable) to determine the
search size ( i.e.,the dependent variable) to nd the ground-
truth-established, input instruction-execution instance that
originally infected the program state.
As such, we compare three treatments:
Execution Trace. This treatment serves as a base-
line upon which the others can be compared. For it, we
record the number of input instruction-execution in-
stances throughout each execution, which constitutes
the initial search-space of all inputting instructions and
all their individual execution instances.
Traditional Dynamic Slice. With this treatment,
we determine the extent to which dynamic slicing can
reduce the search space for the input instruction-ex-
ecution instances according to the number of input
instructionexecution events by backward slicing from
the slicing criterion to all transitively reachable input
instances.
Dynamic-Relevance-Augmented Dynamic Slice.
With this treatment, we determine the relative dy-
namic relevance values that we assigned to each input
instruction-execution instance, and assess the degree
to which we eectively distinguish the ground-truth
root-cause instances. For this, we assess the number
of input instruction-execution instances that need to
be inspected in decreasing order of dynamic relevance.
3.3 Experimental Results
We present the experimental results in Table 1 and Fig-
ure 2. Table 1 shows the data for all 20 executions of
NanoXML that were infected with mutations in their in-
puts. Each row in Table 1 presents the information for a
single infected execution of NanoXML. Figure 2 depicts the
mean values of the data for all 20 executions as shown in
last row of Table 1.
For example, for execution-1 there were a total of 2,993
input instruction-execution instances in the entire execution,
out of which only 224 instances ( i.e.,7.48%) were identied
as relevant for inspection after dynamic slicing. Of these,
only 9 input instruction-execution instances ( i.e., 0.30%)
required inspection when inspecting in order of decreasing
dynamic relevance.
In each of the 20 executions, using the additional relevance
measure substantially reduced the search for the infection
source, as against the number of instruction-execution in-
stances that required inspection as a consequence of being
included in the dynamic slice. In the best case of execution-
8, dynamic slicing reduced the instruction-execution instances
for inspection to 62.4% of the total input instances ( i.e.,
from 362 to 226). In addition, after utilizing the relevanceExecution# of input
instruction-
execution
instances
in trace# (and %)
instances to
inspect in
traditional
dynamic slice# (and %)
instances to
inspect in
augmented
dynamic slice
execution-1 2993 224 7.48% 9 0.30%
execution-2 2994 245 8.18% 4 0.13%
execution-3 536 106 19.78% 2 0.37%
execution-4 423 93 21.99% 6 1.42%
execution-5 92 80 86.96% 20 21.74%
execution-6 89 64 71.91% 34 38.20%
execution-7 415 282 67.95% 5 1.20%
execution-8 362 226 62.43% 1 0.28%
execution-9 3075 875 28.46% 11 0.36%
execution-10 2964 390 13.16% 13 0.44%
execution-11 2195 246 11.21% 5 0.23%
execution-12 1482 222 14.98% 5 0.34%
execution-13 1501 116 7.73% 5 0.33%
execution-14 1500 445 29.67% 9 0.60%
execution-15 625 212 33.92% 6 0.96%
execution-16 498 178 35.74% 6 1.20%
execution-17 411 266 64.72% 6 1.46%
execution-18 452 283 62.61% 5 1.11%
execution-19 250 148 59.20% 9 3.60%
execution-20 413 273 66.10% 6 1.45%
(Mean) 1163.5 248.7 38.7% 8.35 3.8%
Table 1: Results for 20 mutated executions of NanoXML
measures, exactly 1 instruction-execution instance required
inspection, i.e.,the relevance measure was able to pinpoint
the input instance most relevant among all 226 input in-
stances that dynamic slicing determined truly aected the
slicing criterion. Even in the worst case of execution-6, dy-
namic slicing reduced the search space of input instruction
instances to 71.9% of the total input instances, leaving 64
instruction instances to inspect; this was further reduced to
38.2% of the total input instances leaving 34 instruction in-
stances requiring inspection, which is a further reduction of
the search by 46.9% from what the dynamic slice provided.
On average, for all 20 executions, dynamic slicing reduced
the search space for the input instruction instances to 38.7%,
thus providing an average cost savings of 61.3%. In addition,
augmenting the dynamic slicing with the relevance measure,
reduced the search for the read instructions, on average, to
3.8% of the total number of input instruction instances in the
execution, thus providing an average cost savings of 96.2%.
3.4 Discussion
Overall, the results of our evaluation suggest that that
augmenting the dynamic slice with relevance measures can
substantially reduce the search for instruction-execution in-
stances and thus lead to potential cost savings. The tradi-
tional dynamic slice was surprisingly eective at reducing
the search space, in terms of the input instruction instances
(61% reduction) that required inspection. However, the dy-
namic relevance information provides even further reduction
in the search (96% reduction) to identify the mutated input-
execution instance.
It was interesting to us the number of input-execution
instances ( i.e., between 64 and 875) that dynamic slicing
determined to be inuencing the infection-revealing output
instruction instance ( i.e., the slicing criterion). To verify
the correctness of our analysis, we performed manual inves-
tigation to determine whether the inclusion of the input in-
struction instances that were reading un-mutated data were
40Execution Trace Dynamic Slice Augmented Dynamic SliceSearch Space:
# of Read Insn. Instances
to inspect0 200 400 600 800 1200
Execution Trace Dynamic Slice Augmented Dynamic SliceSearch Space:
% of Read Insn. Instances
to inspect0 20 40 60 80 100Figure 2: Mean search space to locate the source of program-
state infection. ( N.B., Lower values are better.)
correctly included in the slices. We found that indeed these
reads do inuence the control and data dependencies that
propagate to the propagated and mutated output state. We
found that many of these relationships arise due to the re-
lationships in the structured input ( e.g., hierarchical XML
elements, attributes of elements, and element types that pre-
scribe certain attributes). Moreover, we found that the most
relevant among these according to our dynamic-relevance
measure were those that had the most direct relationships
in the structural input.
Finally, we note threats to the validity of our evaluation
results. Most notably, the results of our evaluation were sub-
ject to the behavior of a single software program and thus
neither conrm nor reject generalizability, warranting fur-
ther inquiry with additional software programs as subjects
for studying program behavior. Also, we evaluated using
one application of dynamic slicing: nding the root-cause
infection in the input space. We think that the dynamic rel-
evance measure can be helpful in distinguishing inuences in
dynamic slices for many other tasks, and those too should
be evaluated in the future.
4. RELATED WORK
Dynamic Slicing & Dependence Analysis. Dynamic
Slicing was rst proposed by Korel and Laski [8], and has in-
spired various bodies of work ranging from ecient computa-
tion of dynamic slices to numerous applications in the eld of
software engineering. One of the earliest such contributions
to dynamic slicing was made by Agrawal and Horgan [1] by
rst proposing and levering the dynamic dependence graph
to compute dynamic slices.
A general description of slicing technology and challenges
can be found in Tip's survey [18], Krinke's thesis [9], and
with a more recent survey by Xu et al. [21]. Works by Bink-leyet al. [3, 4] further provided theoretical frameworks for
distinguishing dierent types of slices.
A noteworthy amount of dynamic slicing research has fo-
cused on pruning, compressing and summarizing dynamic
slices or dynamic dependence graphs upon which the slicing
is performed to aid comprehension ( e.g., [7,11,14,15,19,20,
22]). An underlying motivation for such works has been to
eventually support ecient navigation and inspection of dy-
namic slices both computationally and for manual inspection
by software engineers. Our work is similar to such works as
it motivated by the nal goal of aiding inspection and navi-
gation of dynamic slices for software engineers. However, in
contrast, our technique attempts to achieve improved navi-
gation by deciphering the more important sections in a dy-
namic slice, instead of pruning or summarizing it. Indeed, it
would be interesting to study the eects of summarization
and/or pruning in conjunction with our approach.
Gupta et al. [6] and Zhang et al. [23] employ multiple-
points slicing to minimize the program execution search space
for localizing faults in a software program. This is similar
to our approach as we employ dynamic slices from multiple
points and directions to compute relevance measures. How-
ever, in contrast, our approach does not minimize the dy-
namic slice itself; instead it highlights certain relevant points
in the slice based on the underlying inuences.
Masri and Podgurski [12,13] present a forward computing
approach, called dynamic information ow analysis (DIFA)
to track inuences within instruction instances during a pro-
gram's runtime. They use dynamic dependencies to com-
pute inuence. Further, they measure the strength of in-
formation ows modeled by program dependencies using in-
formation theory and statistical correlation between empiri-
cally observed variable values during software program exe-
cutions. Our model also captures the inuence of instruction
instances on each other and moreover computes a measure
of relevance for such inuences. However, in contrast, our
approach analyzes the underlying inuences and dependen-
cies themselves to arrive at such relevance measures, instead
of using empirically observed values for dierent variables in
a program execution.
Quantied Dependence Models. Recent works have looked
at augmenting runtime information with system and pro-
gram dependence graphs for weighting dierent elements,
i.e.,nodes and edges in such dependence models towards im-
proved applicability for various software engineering tasks.
Baah et al. [2] propose the probabilistic program dependence
graph that composes statistical dependencies deduced from
test runs to nally enable improved fault localization and
comprehension. Santelices et al. [17] propose quantitative
slicing that weights statements in a static forward slice us-
ing dierential executions to improve change impact analy-
sis. Deng and Jones [5] propose the weighted system depen-
dence graph that weights the edges of the system dependence
graph using test execution data to better enable debugging
and program comprehension. Our work is similar to such hy-
brid models of program behavior, as we weight dependencies
between dierent instruction instances to highlight certain
inuences between instruction instances over others. How-
ever, in contrast to such techniques that are based on static
dependence models, our approach models program behavior
based on dynamically observed dependencies; and thus, is
likely to be more precise.
415. CONCLUSION AND FUTURE WORK
In this work, we presented a novel dynamic dependence
and slicing model that incorporates a new measure to quan-
tify dynamic inuence among instruction execution events
within executions traces and dynamic slices. Our augmented
dynamic slice model represents not only the traditional in-
clusion and identication of inuencing instruction instances,
but also includes the dynamic dependence relationships among
them, as well as a newly created measure that quanties
relationships. Our new measure, which we are calling dy-
namic relevance, represents the degree of distinctive inu-
ence among instruction instances, whether through direct
or transitive dependencies.
We conducted evaluations to determine the degree to which
traditional dynamic slicing and our new augmented model
can reduce the search space for a set of debugging tasks.
Our results show strong promise the new augmented model,
and lend condence to the intuitions that gave rise to the
dynamic relevance measure. For our experimental subject
and protocol, search-space costs were reduced to 3.8% of all
read instruction instances within an execution trace, which
bested the search-space reduction of traditional dynamic
slicing (of 38.7%).
Although these results are promising, future work is needed
to further lend condence in these benets and to explore the
full range of benets and limitations of all such approaches.
First, we will perform larger studies on more subject pro-
grams and a variety of software-engineering tasks. Also, we
envision future client analyses that can benet from dynamic
relevance measures, and we also envision user interfaces that
will allow developers to explore and query dynamic slices.
6. ACKNOWLEDGEMENTS
This work is supported by the National Science Founda-
tion under awards CAREER CCF-1350837 and CCF-1116943.
7. REFERENCES
[1] H. Agrawal and J. R. Horgan. Dynamic program
slicing. SIGPLAN Not. , 25(6):246{256, June 1990.
[2] G. Baah, A. Podgurski, and M. Harrold. The
probabilistic program dependence graph and its
application to fault diagnosis. Software Engineering,
IEEE Transactions on , 2010.
[3] D. Binkley, S. Danicic, T. Gyimothy, M. Harman,
A. Kiss, and B. Korel. Minimal slicing and the
relationships between forms of slicing. In Source Code
Analysis and Manipulation, 2005. Fifth IEEE
International Workshop on, pages 45{54, Sept 2005.
[4] D. Binkley, S. Danicic, T. Gyimothy, M. Harman,
A. Kiss, and L. Ouarbya. Formalizing executable
dynamic and forward slicing. In Source Code Analysis
and Manipulation, 2004. Fourth IEEE International
Workshop on, pages 43{52, Sept 2004.
[5] F. Deng and J. A. Jones. Weighted system dependence
graph. In International Conference on Software
Testing, Verication, and Validation , 2012.
[6] N. Gupta, H. He, X. Zhang, and R. Gupta. Locating
faulty code using failure-inducing chops. In
Proceedings of the 20th IEEE/ACM International
Conference on Automated Software Engineering, ASE
'05, pages 263{272, 2005.[7] M. Kamkar, N. Shahmehri, and P. Fritzson.
Interprocedural dynamic slicing. In Programming
Language Implementation and Logic Programming ,
volume 631, pages 370{384. 1992.
[8] B. Korel and J. Laski. Dynamic program slicing. Inf.
Process. Lett. , 29:155{163, October 1988.
[9] J. Krinke. Advanced Slicing of Sequential and
Concurrent Programs . PhD thesis, University of
Passau, 2003.
[10] T. D. LaToza and B. A. Myers. Developers ask
reachability questions. In Software Engineering, 2010
ACM/IEEE 32nd International Conference on ,
volume 1, pages 185{194. IEEE, 2010.
[11] W. Masri, N. Nahas, and A. Podgurski. Memoized
forward computation of dynamic slices. In Proceedings
of International Symposium on Software Reliability
Engineering, pages 23{32, 2006.
[12] W. Masri and A. Podgurski. Algorithms and tool
support for dynamic information ow analysis.
Information and Software Technology , 51(2):385{404,
2009.
[13] W. Masri and A. Podgurski. Measuring the strength
of information ows in programs. ACM Trans. Softw.
Eng. Methodol. , 19(2):5:1{5:33, Oct. 2009.
[14] V. K. Palepu and J. A. Jones. Visualizing constituent
behaviors within executions. In Software Visualization
(VISSOFT), 2013 First IEEE Working Conference
on, pages 1{4. IEEE, 2013.
[15] V. K. Palepu, G. Xu, and J. A. Jones. Improving
eciency of dynamic analysis with dynamic
dependence summaries. In ASE '13 , pages 59{69,
2013.
[16] R. Santelices, M. J. Harrold, and A. Orso. Precisely
detecting runtime change interactions for evolving
software. Software Testing, Verication, and
Validation, 2008 International Conference on ,
0:429{438, 2010.
[17] R. Santelices, Y. Zhang, S. Jiang, H. Cai, and Y.-j.
Zhang. Quantitative program slicing: separating
statements by relevance. In Proceedings of the 2013
International Conference on Software Engineering ,
pages 1269{1272. IEEE Press, 2013.
[18] F. Tip. A survey of program slicing techniques.
Journal of Programming Languages , 3:121{189, 1995.
[19] C. Wang and A. Roychoudhury. Dynamic slicing on
Java bytecode traces. ACM Trans. Prog. Lang. Syst. ,
30(2):1{49, 2008.
[20] T. Wang and A. Roychoudhury. Hierarchical dynamic
slicing. In Proceedings of the 2007 international
symposium on Software testing and analysis , ISSTA
'07, pages 228{238, 2007.
[21] B. Xu, J. Qian, X. Zhang, Z. Wu, and L. Chen. A
brief survey of program slicing. SIGSOFT Softw. Eng.
Notes , pages 1{36, Mar. 2005.
[22] X. Zhang, N. Gupta, and R. Gupta. Pruning dynamic
slices with condence. pages 169{180, 2006.
[23] X. Zhang, N. Gupta, and R. Gupta. Locating faulty
code by multiple points slicing. Softw. Pract. Exper. ,
37(9):935{961, July 2007.
42