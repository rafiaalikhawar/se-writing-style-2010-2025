Finding Incorrect Compositions of Atomicity
PengLiu*
lpxz@ust.hkJulianDolby†
dolby@us.ibm.comCharlesZhang*
charlesz@cse.ust.hk
*HongKongUniversityofScienceandTechnology†IBMThomasJ.WatsonResearchCenter
China UnitedStates
ABSTRACT
In object-oriented code, atomicity is ideally isolated in a li-
brary which encapsulates shared program state and provides
atomic APIs for access. The library provides a convenient
way for programmers to reason about the needed synchro-
nization. However, as the library exports a limited set of
APIs, it cannot satisfy every unplanned atomicity demand;
therefore, clients may have to compose invocations of the
libraryAPIstoobtainnewatomicfunctionality. Thisprocess
is error-prone due to the complexity of reasoning required,
hence tool support for uncovering incorrect compositions
(i.e., atomic compositions that are implemented incorrectly)
would be very helpful. A key diﬃculty is how to determine
the intended atomic compositions, which are rarely docu-
mented. Existing inference techniques cannot be used to
infer the atomic compositions because they cannot recog-
nize the library and the client, which requires understanding
the related program state. Even if extended to support the
library/client, they lead to many false positives or false nega-
tives because they miss the key program logic which reﬂects
programmers’ coding paradigms for atomic compositions.
We deﬁne a new inference technique which identiﬁes in-
tended atomic compositions using two key symptoms based
on program dependence. We then check dynamically whether
these atomic compositions are implemented incorrectly as
non-atomic. Evaluation on thirteen applications shows that
our approach ﬁnds around 50 previously unknown incorrect
compositions. Further study onTomcatshows that almost
half (5 out of 12) of discovered incorrect compositions are
conﬁrmed as bugs by the developers. Given thatTomcat
is heavily used in 250,000 sites includingLinkedin.comand
Ebay.com, we believe ﬁnding multiple new bugs in it auto-
matically with relatively few false positives supports our
heuristics for determining intended atomicity.
CategoriesandSubjectDescriptors
D.2.5 [SoftwareEngineering]: Testing and Debugging
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bearthisnoticeandthe fullcitationontheﬁrstpage. Tocopyotherwise,to
republish,topostonserversortoredistributetolists,requirespriorspeciﬁc
permission and/or a fee.
ESEC/FSE’13, August 18–26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08 ...$15.00.GeneralTerms
Reliability, Experimentation, Measurement
Keywords
Atomic compositions, concurrent programming, program
dependence, static analysis, predictive analysis
1. INTRODUCTION
The diﬃculty of debugging concurrent programs has in-
spired the development of a range of tools, based on concepts
from race conditions to higher-level concepts like atomic-
ity [8]. Atomicity expresses the intuitive idea that shared
state must be accessed by some code without interference.
Ideally, atomicity is isolated in a library which encapsulates
the shared state and provides the atomic APIs for accessing
it without interference. Consider the code snippet (List-
ing 1) from theBayesianapplication [20]: learnerNet is an
instance of the class BayesianNet . The class BayesianNet
and the referenced class Node(not shown) form a library,
which encapsulates the ﬁelds deﬁning the structure of the
Bayesian net. The library also provides two atomic APIs,
hasEdge, which checks atomically the existence of an edge
between two nodes fromIdandtoId, andapplyOp, which
inserts atomically an edge between the nodes.
Listing1. CodesnippetofBayesianapplication
1isTaskValid= true;
if(op==INSERT)
3{
if(learnerNet.hasEdge(fromId, toId))
5 isTaskValid= false;
}
7else{...}
if(isTaskValid)
9learnerNet.applyOp(op, fromId, toId);
Many promising approaches [31, 28, 27] have been pro-
posed recently to test whether the library implements its own
atomic APIs correctly, which have been relatively successful
for two reasons: (1) the code responsible for the atomic ac-
cesses can be easily identiﬁed as the library API methods; (2)
the library typically involves a small code base which can be
tested exhaustively. However, even if the library implements
its atomic APIs correctly, the application may still malfunc-
tion because the client code composes new functionality with
the library APIs that is intended to be atomic, but does so
incorrectly. For example, in Listing 1, two invocations (line
4 and line 9) of library APIs are composed at the client sidePermission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSE’13 , August 18–26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08...$15.00
http://dx.doi.org/10.1145/2491411.2491435
158
to realize new atomic functionality, i.e., to add a given edge
between two nodes only if they are not connected by any
existing edge.
In general, client-side atomic composition commonly ex-
ists because the library designers cannot predict all desired
atomic usages. Unfortunately, client-side atomic composi-
tions may be implemented incorrectly, due to the inherent
diﬃcultiesinreasoningaboutconcurrentbehavior: (1)clients
compose quite often, e.g., 100+ compositions per evaluated
large program (ColumnACin Table 1); (2) the reasoning for
each composition is non-modular, e.g., each studied buggy
composition spans multiple methods. Incorrect compositions,
i.e., atomic compositions that are implemented incorrectly,
commonly lead to unwanted behaviors. For example, in List-
ing 1, if the two invocations are interleaved non-atomically
by an invocation in another thread that inserts an edge be-
tween the two nodes, the connectivity state returned by the
former invocation becomes stale, the latter invocation which
depends on the stale state proceeds to insert another edge.
Consequently, two edges are inserted between the two nodes,
violating the invariant.
We identify the problem of the incorrect client-side compo-
sition and address it automatically in this paper. Based on
the automatic discovery of the library and the client, we infer
the intended client-side atomic composition automatically,
after which we adopt existing atomicity violation detection
analyses [8, 26] to ﬁnd the incorrect implementation of the
atomic composition.
Automatic inference of atomic composition is required to
free programmers from the daunting task of manually speci-
fying 100+ compositions per large program. However, the
inference is challenging. The ﬁrst challenge lies in recognition
ofthelibraryandtheclient, whichisaprerequisiteforatomic
composition inference. Existing inference [18, 22, 40, 4, 17,
34] of atomicity, which reasons about the ﬁeld accesses di-
rectly, cannot recognize the library or the client. Speciﬁcally,
recognition of the library requires understanding what ﬁelds
are related, e.g., some ﬁelds from the class BayesianNet and
the class Nodeare related in describing the structure of the
Bayesian net, therefore, both classes are included in the same
library. Most existing inference techniques [18, 22, 40, 4, 34],
which understand only the single-variable atomicity, would
isolate the ﬁelds in diﬀerent libraries and accordingly miss
the atomicity on the related ﬁelds. Furthermore, recogni-
tion of the irrelevant client-side uses of a library requires
understanding independent portions of the library state, e.g.,
the independence between the ﬁelds describing the structure
of the net and the ﬁelds describing the domain-speciﬁc val-
ues stored in the net. The second challenge posed to the
inference is it needs to achieve high ﬁdelity, i.e., it neither
misses many real atomic compositions nor introduces many
false ones. Existing inference [18, 22, 4, 17, 34] of atomicity,
even if extended to support the library/client, fails to achieve
the high ﬁdelity. Speciﬁcally, the inference techniques [18,
22, 4, 34] identify the atomicity with the dynamic instruc-
tion adjacency or the lexical adjacency, which introduce too
many atomic compositions conservatively; the inference tech-
niques [17] identify the atomicity with the frequency-based
(or statistic-based) symptom, which miss many real atomic
compositions. For example, the atomic composition in our
running example is missed because it appears only once.
We propose a new approach to address these challenges.
First, we identify the library and the client based on thenotion ofatomic set[36, 5], which characterizes a group
of related ﬁelds. As the related ﬁelds are linked by ﬁeld
references and occur in existing atomic regions, we infer
them from existing atomic regions and the ﬁeld reference
logic indicating the relevance. Second, to achieve the high
ﬁdelity, we identify atomic compositions by ﬁnding deﬁnitive
code paradigms for them. According to our study, most
compositions coded as atomic fall into two general cases:
•One invocation leaks the state of the atomic set encap-
sulated by the library and the other invocation uses it,
e.g., the latter invocation in the exemplary atomic com-
position (Listing 1) uses the connectivity state leaked
bytheformerinvocation. Atomicityisrequiredbecause
otherwise the latter invocation would use the stale state
and lead to unwanted behavior, e.g., inserting multiple
edges between two nodes in our running example.
•Instead of depending on the return value of each other,
two invocations are inseparable and complement each
other to fulﬁl a combined atomic functionality, e.g., the
invocationssetCityandsetZipcodeare combined to
achieve the atomic functionalitysetCityAndZipcode.
Both coding paradigms can be captured by the program
dependence logic, and we use them as deﬁnitive symptoms
to identify the atomic compositions.
Once we have identiﬁed the compositions intended to be
atomic, existing atomicity violation detection [26, 13] can
check whether the compositions are actually atomic. We
customize existing predictive analyses [30, 13, 38] to ﬁnd
incorrectly implemented compositions. Predictive analysis
searches for non-atomic interleavings of the atomic composi-
tion by adjusting the scheduling order of events. Specially,
we customize the analysis so that it is aware of the library
APIs involved in the atomic compositions. Since some atomic
compositions reported by the conservative static inference
may be false, our dynamic analysis does runtime checking
to ﬁlter out such false positives. Our dynamic analysis is
optimized for our speciﬁc task: it analyzes at the invocation
levelandanalyzesonlyinvocationsaccessingthesameatomic
set. This reduces the number of events to analyze and re-
ducestheinterleavingspacetoexplorewithoutcompromising
eﬀectiveness.
We implement our approach as a toolICﬁnderand evaluate
it on a set of large scale applications such asTomcat.ICﬁnder
has been successfully evaluated by the ESEC/FSE artifact
evaluation committee and found to meet expectations. Our
results show thatICﬁnderﬁnds around 50 incorrect com-
positions in all applications. Further manual study of our
Tomcatresults shows that ﬁve out of the twelve incorrect
compositions identiﬁed inTomcatare bugs as conﬁrmed by
the developers. Considering thatTomcatis heavily used
in around 250,000 sites [3] including the famous ones [37]
such asLinkedin.comandEbay.com, and the easy bugs have
already been found, we believe ﬁnding newly reported bugs
automatically supports our heuristics for detecting incorrect
compositions. Overall, the static analysis ofICﬁnderﬁnds up
to 391 atomic compositions for a program. More than half
of them appear infrequently and are missed by the previous
statistic-based approach. The eﬃcient dynamic analysis of
ICﬁnderﬁnishes within 1 second.159We make the following contributions in this paper.
1.We identify the problem of incorrect compositions of
atomic library APIs, i.e., the compositions which are
intended as atomic but implemented as non-atomic.
2.We evaluate our approach extensively on a set of large
applicationsandconducttheempiricalstudytoconﬁrm
the severity of incorrect compositions.
3.We propose an automatic approach to ﬁnd incorrect
compositions. Speciﬁcally, we propose high-ﬁdelity in-
ferenceofintendedatomiccompositions, whichrespects
atomicity among related ﬁelds and respects the inher-
ent program logic involved in atomic composition. We
customize existing dynamic analysis to check whether
these atomic compositions are implemented correctly.
2. OVERVIEW
Our approach has four steps: ﬁrst inferring atomic sets of
relatedﬁeldsinagivenapplication, nextﬁndinglibrariesthat
encapsulate them and the clients that use the libraries else-
where in the program, then inferring atomicity requirements
of these uses, and ﬁnally attempting to exhibit executions
that violate these atomicity requirements.
Inferring Atomic Sets. This step determines groups
of related ﬁelds that implement abstractions of atomic sets,
which require atomicity for keeping state consistent. The
atomic setaSetconsists of the related ﬁelds sharing a single
root, each denoted as a reference chain from the root:
{�root, f 1.f2. . . f i.fi+1. . .� |f i+1∈Type(f i)}
While the atomic set abstraction could be declared by pro-
grammers, we infer them automatically. Our static inference
is described in Section 3. Besides, the dynamic checking in
Section 6 prunes the false positives produced by the static
inference.
IdentifyingLibraryandClient. Given an atomic set
aSet, the library consists of the classes encapsulating the
ﬁelds inaSet, which provide the atomic APIs for accessing
the ﬁelds inaSet. The next step is to ﬁnd the client methods
that use the APIs provided by the library to accessaSet.
The details are explained in Section 4. The abstraction of
library and client also provides the intuitive bug reports
based on the high-level view of APIs, as contrasted with the
bug reports based on the low-level view of ﬁeld accesses.
Inferring Atomic Compositions. The uses of the li-
brary in the client methods may or may not form the atomic
composition. Learning from existing atomic compositions,
we ﬁnd they exhibit two common symptoms. We formalize
the symptoms and use them as the deﬁnition for atomic
compositions. The formalization and the inference of atomic
compositions are in Section 5.
Exhibiting Synchronization Errors. The atomicity
requirement of the composition may not be implemented
correctly. The ﬁnal step is the dynamic execution to force
the atomicity violations to manifest themselves. The details
and optimization of the dynamic analysis are explained in
Section 6.
The rest of the paper presents the above steps in details.
In addition, Section 7, Section 8 and Section 9 present the
implementation, evaluation and related work respectively.
Figure1. AtomicsetintheclassLinkedlist
3. INFERENCEOFATOMICSETS
An Atomic Set [36] denotes a set of heap locations that
have some consistency property that is maintained by the
units of workthat operate upon the set. Correctness thus
requires that units of work on a given atomic set operate as
if they are never interleaved at runtime. Note that a unit
of work is subtly diﬀerent from an atomic region, since it
pertains to a speciﬁc subset of state.
Deﬁnition 1(Atomic Set) .In object-oriented programs,
where objects form reference hierarchies via ﬁeld references,
an atomic set is a set of instance ﬁelds, each of which is
reachable from the root object along a ﬁeld chain.
Figure1showsareferencehierarchyrootedata LinkedList
objectlist, where ellipses stand for objects and lines stand
for ﬁeld references. The atomic set consists of the highlighted
instance ﬁelds (grey), list.size ,list.head ,n1.next and
n2.next. Each instance ﬁeld is reachable from the root ob-
jectlistalong one of the following ﬁeld chains: size,head,
head.nextorhead.next.next.
While atomic set was originally presented as a program-
ming model [5], we need to infer it since we are looking for
bugs in existing code. Furthermore, we are looking for incor-
rect usage of libraries that are themselves well synchronized.
Hence, our inference is based on the observation that the re-
lated ﬁelds in the atomic set are accessed in the same existing
synchronized blocks (or methods) and organized by the ﬁeld
reference logic. For each synchronized block (or method), we
deﬁne an atomic set constituted by ﬁelds of the receiver this
object accessed within the block and also any ﬁelds accessed
transitively via the receiver’s ﬁelds. Given all the atomic
sets, we merge atomic sets that share ﬁelds, to conform with
the rule that all atomic sets should be disjoint [5].
Atomicity only applies to shared program state, so we con-
duct the optimization by leaving out all non-shared program
state. Weapplytheoﬀ-the-shelfescapeanalysisimplemented
in theSoot[35] compiler framework to prune the thread-local
objects.
4. IDENTIFICATIONOFCLIENT-SIDEIN-
VOCATIONS
In this section, we identify client-side invocations of li-
brary APIs, which access atomic sets encapsulated by the
libraries. The next section infers whether such invocations
are composed atomically. To identify the invocations, we
ﬁrst determine the library and the client based on the formal
description in Deﬁnition 2.
Deﬁnition 2 (Library Module and Client Module) .A
module is a logic unit, which consists of the classes related to
a speciﬁc property. Two types of modules are of interest. The
library module deﬁnes the atomic set and the client module
uses it. The library module consists of the classes which
declare the ﬁelds in the atomic set and provide atomic APIs
for accessing the ﬁelds. The client module consists of the
class of which the methods invoke the atomic library APIs.
The methods are referred to as client methods accordingly.160Invoke
InvokeModule A Module B
func1func2
func3Figure2. Clientmoduleandlibrarymodule
Figure 2 illustrates the terms: The moduleBis a library
module which provides the atomic APIs, while the moduleA
is a client module, of which the method invokes the APIs in
the moduleB. The modulesAandBare often not the same.
We also consider the degenerated case where the moduleA
and the moduleBare the same because the library may
compose its own atomic APIs.
We derive the library module directly from each atomic set.
Given an atomic setaSet, the classes that declare the ﬁelds
in it form a library module. The client module is identiﬁed
as the class containing the client method. The client method
is further identiﬁed as the method containing the invocations
of the library APIs that access the atomic setaSet.
ALGORITHM1:The function isClient
Input: The methodm, the atomic setaSet
1foreachstmt: m.stmts()do
2 ifstmt.isInvocation()then
3 eﬀects=transitiveSideEﬀects(stmt);
4 ifeﬀects∩aSet�=∅then
5 print: the invocationstmtaccessesaSet,mis
the client method;
6 end
7 end
8end
We traverse all methods in the application, during which
we judge whether each method is a client method following
Algorithm 1. If an invocationstmtin the methodmaccesses
a set of instance ﬁeldseffects, according to the side eﬀect
analysis (line 3), and some of the instance ﬁeldseffects
belong to the atomic setaSet(line 4), according to the result
of the analysis in Section 3, the invocationstmtaccesses the
atomic setaSet.
Speciﬁcally, the side eﬀect analysis computes thetransitive
side eﬀects (line 3), i.e., the ﬁelds accessed in the transitive
callee methods ofstmt. We compute the side eﬀects by
identifying the callee methods in the call graph and resolving
theﬁeldaccessesintra-procedurally. Theresultantsideeﬀects
of each invocation statement are used to judge the accessing
relations with respect to each atomic set.
We are trying to infer the atomic sets and clients in a
program, and we will get a better approximation given better
static analysis. Inevitably, however, static analysis may have
unsoundness: it can miss code when it is invoked dynamically
using reﬂection, and it is an over-apporiximation in general
of the code. Such issues may reduce the eﬀectiveness of ourheuristics, but we show in our results that our static analysis
is good enough to give useful results.
5. AUTOMATICINFERENCEOFATOMIC
COMPOSITIONS
Aftertheinvocationspotentiallyaccessingthesameatomic
set are identiﬁed, we infer whether they form atomic compo-
sitions, using the symptoms capturing the deﬁnitive program
logic for atomic compositions. According to our observations,
compositions of invocations are commonly programmed as
atomic if (1) one invocation uses the result produced by the
other, or (2) the invocations complement each other indis-
pensably, i.e., in the path conditions that one invocation is
executed, the other invocation must be executed. Therefore,
we design two symptoms, namely theUSEsymptom and the
complementationsymptom, to capture the above scenarios re-
spectively, both based on the program dependence. The USE
symptom, described in Property 1, is designed to capture
the former atomic composition scenario.
Property1(USE symptom) .Given two invocations iden-
tiﬁed in the client method, if the program dependence exists
between them, the invocations should be composed atomically.
Figure 2 illustrates the atomic composition scenario. The
invocations (horizontal lines) in the method func1interact
with each other via the program dependence (curve): The
ﬁrst invocation leaks the state encapsulated by the library
and the second invocation depends on the leaked state. The
program dependence link strongly indicates the atomicity of
the composition as the interleavings would make the leaked
state stale and the program dependence incorrect.
The program dependence is a well studied compiler con-
cept [7, 12, 32], which can be immediate program dependence
such as control dependence and data dependence, or the tran-
sitive closure of it. Program dependence is often character-
ized graphically by the program dependence graph [7], where
nodes represent statements, edges represent control/data
dependences and paths represent program dependences.
On the other hand, the invocations in Figure 2 may not
interactwitheachotherbutarestillcomposedasatomic. The
code from theSpecjbbbenchmark in Listing 2 illustrates the
atomic composition scenario of this kind. Two invocations,
which get the xscale and yscale of an image, should be
executed atomically to render a consistent view of the image.
As seen, the USE symptom cannot capture such atomic
composition as no program dependence exists between the
invocations.
Listing2. CodesnippetofSpecjbb
1GraphImage.getXscale();
GraphImage.getYscale();
Such atomic compositions are captured by the comple-
mentation symptom (Property 2), which speciﬁes that the
invocations that are inseparable, i.e., they are executed to-
gether or skipped together in any execution, form a combined
atomic operation.
Property2(Complementation symptom) .Given two in-
vocations identiﬁed in the client method, if the invocations
dominate and post-dominate each other, the invocations are
expected to be composed atomically.161We check whether the client-side invocations form an
atomic composition by checking whether they exhibit ei-
ther of these symptoms. To check the exhibition of the USE
symptom, we examine whether any program dependence
exists between the invocations, i.e., whether any path exists
between the invocation nodes in the program dependence
graph. Checking the path in a graph is a standard reacha-
bility analysis. Practical issues about the dependence graph
are discussed in Section 7. To check for the complementation
symptom, we analyze the dominance and post-dominance
relations between the invocations, which is also the stan-
dard analysis implemented in open source compilers such as
Soot[35] andWala[33].
6. DYNAMICCHECKING
After atomic compositions are inferred, we check whether
their implementations violate atomicity; we adopt existing
atomicity violation detection analyses. We adopt eﬃcient
predictive analysis [30, 13, 38], which achieves reasonably
good coverage of the buggy interleavings. Predictive analy-
sis aims at deriving, from a normal run, a new buggy run
which exhibits non-atomic interleavings. Speciﬁcally, the
predictive analysis ﬁrst monitors a normal run to collect
the trace and then reorders the events (nodes) in the trace,
simulating the rescheduling of the runtime. Finally, the re-
ordered trace is exercised by an execution which enforces the
non-atomic interleavings. To serve our speciﬁc application,
we customize the predictive analysis so that it is aware of
the atomic composition. The analysis also prunes atomic
compositions falsely reported by the static analysis. Pruning
false atomic compositions prevents false alarms, which is
important especially for future work that reuses our atomic
composition inference. In addition, we optimize the analysis
specially for eﬃciency. The details of the dynamic checking
are presented as follows.
Given an atomic composition, our goal is to derive a buggy
run (or trace, we may use the terms interchangeably.) from
the observed normal run. The buggy run is the run violating
atomic-set serializability, a correctness criterion [36] general-
ized to support the atomic set and commonly adopted. A
buggy run can also be deﬁned as the run exhibiting a set
of interleaving patterns, which account for all atomic-set
serializability violations, according to the study of Vaziri et
al. [36]. One exemple bug pattern,W u(l)W u�(l)R u(l), states
that the write by the unit of work1u�to the memory location
linterleaves the write and read by the other unit of worku,
which leads to the inconsistency between the write and the
read inu. To summarize, our goal is to derive the run which
exhibits the interleavings speciﬁed by the buggy pattern.
Figure 3 illustrates the goal: In the derived run, the remote
invocationI3interleavestheatomicsequencefrominvocation
I1 to invocationI2, or equivalently, the remote invocationI3
happens in parallel (denoted by the dotted line) with some
evente middle betweenI1 andI2 thread-locally. Note that
any buggy interleaving can be equivalently expressed by the
happen-in-parallel relation [16].
For this example, we exhibit the buggy interleaving by
simply reorderingI2 andI3. However, in general, it is non-
trivial to exhibit the buggy interleaving, or alternatively,
1Here the unit of work corresponds to the execution instance
of the atomic code such as the atomic composition or the
atomic API.     ACI1
I2
I3T1 T2
Figure3. Derivingthebuggyrun
to enforce the equivalent happen-in-parallel relation. Re-
ordering the events to enforce the happen-in-parallel rela-
tion is subjective to many constraints, e.g., the absence of
synchronizations and the compatibility of path conditions.
Determining whether all the constraints are satisﬁable is
computationally intractable [24]. Therefore, we approximate
the feasibility of the happen-in-parallel relation with a subset
of constraints, as described in Lemma 1.
Lemma 1.Given two eventseande�, they can happen
in parallel⇔they are not synchronized by the same locks
or happened-before relations [15]. Here,ehappened-before
e�if and only if one can reache�fromein the trace by
moving forwards locally or moving along the inter-thread
communications (e.g., start, join, wait/notify operations.).
Given two events from the normal run, if they are not
synchronized, we re-schedule one of the events so that they
happen in parallel. In practice, we simulate the rescheduling
by collecting the trace of the normal run and moving the
event forwards/backwards in the trace. After the adjustment,
we replay[13] the execution according to the new trace. The
replay may fail when the new trace violates the constraints
that we do not model. We simply discard such infeasible
trace.
PruningFalseAtomicCompositions. Duetothecon-
servativeness of the static analysis (Section 3 and Section 4),
two invocations accessing disjoint atomic sets may be de-
termined as accessing the same atomic set statically. We
prune the false atomic compositions in the monitoring run by
checking whether two invocations access the same runtime
atomic set. We identify the runtime atomic sets accessed by
each invocation as follows. First, we construct the runtime
atomic sets by instantiating the root of the static atomic
set as runtime instances, which have the same type as the
root and are shared among threads. Second, we identify the
runtime atomic sets accessed by the invocation based on the
dynamic side eﬀect analysis.
Optimization. Theoptimizationiscarriedoutduringthe
reordering of the trace events (nodes). Previous predictive
analysis explores the reordering of the memory accesses on
the same atomic set. Comparatively, our analysis operates
at the invocation level and explores the reordering of the
related invocations only, i.e., the invocations accessing the
same runtime atomic set. As a result, we reduce the number
of events to reorder and reduce the interleaving space to
explore. Speciﬁcally, we do not explore the interleavings
to the internal of the basic library API methods, i.e., the
methods which do not compose other library APIs, because
they are already well synchronized by the library module.1627. IMPLEMENTATION
ProgramDependenceGraph. We implement the com-
putation of program dependence inSoot[35].Sootalready
provides the implementation for computing the control de-
pendence and the intra-procedural data dependence. We
compute the inter-procedural data dependence as follows:
(1) we add special data dependence edges to express the
inter-procedural argument passing and function return; (2)
we use the side eﬀect analysis to check the data dependence
via the heap access, i.e., the invocationI 2is data dependent
on the invocationI 1ifI1writes to the heap location read by
I2andI 2is reachable fromI 1in the inter-procedural control
ﬂow graph.
Atomicity.Atomicity commonly refers to the criterion
of conﬂict serializability, which speciﬁes that the atomic
code region should not be interleaved by a conﬂicting access.
According to the recent work [28], atomicity may also refer to
the criterion of linearizability [28], which allows the atomic
code region to be interleaved by a conﬂicting access but
requires the atomic region to behave as if in serial settings in
terms of input/response values. In either case, our inference
capturestheintendedatomiccompositioncorrectly. However,
diﬀerent backend dynamic analyses are needed to check the
correctness of the implementation.
For example, the class AtomInteger (Listing 3) from JDK
1.5+ composes the invocations of two atomic APIs getand
compareAndSet to implement the new atomic functionality
getAndIncrement . The atomicity of the composition refers
to the linearizability criterion: the interleavings to the invo-
cations are allowed, which lead to an extra iteration of the
execution; the eventual eﬀect of the code is to increase the
Integer counter by one, the same as in the serial settings.
Our inference identiﬁes the intended atomic composition cor-
rectly, but the backend dynamic analysis would report the
code as non-atomic as it violates the conﬂict serializability.
A dynamic analysis designed to check the linearizability is
needed to report properly for this example.
Listing3. ThegetAndIncrementmethod
for(;;){
2intcurrent = get();
intnext = current + 1;
4if(compareAndSet(current, next))
return current;
6}
...
LimitationofStaticAnalysis. We rely on the static
analyses to infer atomic sets (Section 3) and compute the
side eﬀects of the client-side invocations (Section 4). It is
commonly known that static analyses are potentially un-
sound in the presence of dynamic loading mechanism, such
as reﬂection, because the analyses may not observe code that
will be loaded. Bodden et al. [2] mitigate the problem by
monitoring the executions and recording the code loaded.
Furthermore, if an atomic set is only ever accessed by a
single thread, the compositions of invocations that access it
do not need to be atomic. However, static analyses cannot
always determining whether the atomic set is accessed by
multiple threads concurrently, so the analysis will be con-
servative and likely report such compositions as needing to
be atomic. However, such compositions do not lead to bug
reports byICﬁnder: our dynamic analysis will not be able toexhibit non-atomic interleavings since only a single thread
exists.
Limitation of Dynamic Analysis. We use the pre-
dictive analysis to search for non-atomic interleavings. No
matter how eﬀective the dynamic analysis is, it is not com-
plete in general, i.e., it may not cover all the executions or
all the buggy interleavings. We mitigate the problem by ex-
tensively applying the predictive analysis, aiming at ﬁnding
as many non-atomic interleavings as possible.
8. EVALUATION
In this section, we aim at evaluating the eﬀectiveness of
the inference of atomic compositions, the eﬃciency of the
dynamic checking, the quality of the ﬁnal reports, and the
validity of our high ﬁdelity claim. The evaluation details
are in Section 8.1, Section 8.2, Section 8.3 and Section 8.4
respectively.
We implement our approach as a toolICﬁnder2, and eval-
uate on large scale applications includingOpenjms,Lucene,
Jigsaw,Derby,Tomcat. The benchmarks (shown in Table 1)
that we use are from theStamp[20] suite3, theDacapo[1]
suite or the research work [5, 13] related to the atomicity.
In the applications, the atomicity is required by the threads
that access the shared resources, e.g., the shared physical
connectioninOpenjms. Allstudiesareperformedonax86 64
Dell workstation with 3.0GHz quad-core Intel Xeon X5450
processors based on Core 2 micro-architecture (8 cores total).
The server has 16GB RAM and 6M L2 caches, runs Ubuntu
8.04 with a Linux 2.6.22 kernel, and uses Sun’s 64-Bit 1.6.0
JVM.
8.1 InferenceofAtomicCompositions
We apply the static analysis to infer the atomic compo-
sitions. The static analysis ﬁrst discovers the library mod-
ule, which provides the APIs for accessing the encapsulated
atomic set and the client module, which invokes the library
APIs to access the atomic set. It then ﬁnds the atomic
compositions of the invocations at the client side with two
key symptoms. The analysis is fully automated, without
requiring extra manual speciﬁcations.
In the following, we present the details of the library/-
client modules discovered by our analysis, then we study
the eﬀectiveness of our symptoms in identifying the atomic
compositions.
Table 1 shows the total number of classes in the library
modules and the client modules in ColumnLMand Column
CMrespectively, It also shows the number of atomic compo-
sitions (ColumnAC) identiﬁed byICﬁnderand the number
of the library APIs (ColumnAPI) involved in the atomic
compositions.
According to the table, the atomic compositions, although
occupying a small portion of the code base (around 1% for
large applications), are too manyfor programmers to manage.
For large applications,Lucene,Jigsaw,DerbyandTomcat,
the number of atomic compositions ranges from 121 to 391.
Given so many atomic compositions, manual reasoning of
them is tedious and non-modular, easily leading to incorrect
2It stands for“the ﬁnder of incorrect compositions”, which
is publicly available:http://www.cse.ust.hk/prism/AC.
3AstheoriginalStampbenchmarksarewritteninClanguage,
we use the Java version provided by Demskey et al. http:
//demsky.eecs.uci.edu/software.php.163compositions. The large number of atomic compositions
also necessitate the fully automated dynamic checking (Sec-
tion 8.2).
Table 1. Metrics for static inference and dynamic
checking
Benchmarks LM API CM AC IC time
Vacation 19116014
Labyrinth3D 241508
Bayes 1326112
Cache4j 314391118
Tuplesoup 12111025
Specjbb 36361239
Jspider 2437043
Openjms 8201112615879
Lucene 1591353912142
Jigsaw 3871471212177
Derby 22781912216155
Tomcat 3589423651235
Avrora 2227043
Next, we study the eﬀectiveness of our symptoms by com-
paring with the symptom used by the state of the art ap-
proachMUVI. We ﬁrst brieﬂy explainMUVIand our im-
plementation of it.MUVIoperates at the memory access
level. It ﬁrst learns what memory accesses appear together
frequently and then treats thefrequent togethernessas the
symptom of atomicity. We extend it so that it operates at
the invocation level. We ﬁrst learn what atomic library APIs
are frequently invoked together and then treat the frequent
togetherness as the symptom of the atomic composition, i.e.,
the library APIs frequently invoked together are composed
as atomic.
From the implementation view,MUVIapplies a frequent
itemset mining algorithm FPclose [9]: if two accessesacc 1
andacc 2appear together for more thanminSupporttimes,
and, each timeacc 1is present,acc 2is present in higher
thanminConfidenceprobability. We use the DCI close
algorithm [19], of which the Java implementation is publicly
available4. DCIclose is similar to FPclose, except that it
relies on one threshold,minSupport. In our experiment, we
set theminSupportthreshold as 2, which means the APIs
are frequently invoked together if they are invoked together
in more than 2 methods. Higher threshold is possible, but
“2”is suﬃcient for demonstrating the diﬀerence between our
symptom andMUVI’s symptom, as explained soon. Besides,
MUVIrequires the code distance threshold for determining
the togetherness. As the threshold diﬀers from application
to application, it requires great eﬀorts in the ﬁne tuning,
which limits the practical utility. We simply determine two
invocations are together if they are in the same method.
In Table 2, we show the atomic compositions detected by
MUVIandICﬁnderin ColumnAC MUV I and ColumnAC
respectively. For comparison, we also show the atomic com-
positions found byICﬁnderbut missed byMUVIin Column
Δ, and the atomic compositions found byMUVIbut missed
byICﬁnderin Column Δ�.
According to Column Δ�of Table 2,ICﬁndermisses the
minority (often less than 33%) of the atomic compositions
found byMUVI. For four applications such asSpecjbband
4http://www.philippe-fournier-viger.com/spmfAvrora,ICﬁndermisses none of the atomic compositions found
byMUVI. On the other hand, according to Column Δ,MUVI
misses the vast majority of atomic compositions found by
ICﬁnder, e.g., around 80% of the atomic compositions are
missed for each large application.
We investigate these observations by comparing our two
symptoms separately with theMUVIsymptom. Besides,
we investigate the atomic compositions found byMUVIbut
missed byICﬁnder, as well as the false positives ofICﬁnder.
In the following, we useICﬁnder-USEorICﬁnder-COMPto
refer to theICﬁnderwhich functions with only the USE or
the complementation symptom adopted.
EﬀectivenessoftheUSESymptom. The atomic com-
positions reported byICﬁnder-USEare shown in Column
AC USE. For comparison, we show the atomic compositions
found byICﬁnder-USEbut missed byMUVIin Column Δ USE,
and the atomic compositions found byMUVIbut missed by
ICﬁnder-USEin Column Δ�
USE.
According to Column Δ USE,MUVImisses a lot of atomic
compositions found byICﬁnder-USE, i.e., 50%-100% atomic
compositions are missed. This is due to the natural limit of
the statistic-based approach:MUVIdepends greatly on the
frequency of the composition, however, many compositions
appear only in one method, which gives insuﬃcient support
toMUVI. For example, the bug in Listing 7 is missed by
MUVI. Note, higherminSupportthreshold makesMUVImiss
more atomic compositions.
One interesting observation is thatICﬁnder-USEcan also
identify the atomic compositions involving the exception
handling. Listing 4 shows the multiplex method fromOpen-
jms, which adopts the multiplex of the channels to speed up
the message passing. The former invocation addChannel()
registers the channels in the shared channel pool, an atomic
set encapsulated inside the instance _channels . The latter
invocation disconnect() is invoked in the presence of the
exception to disconnect the subset of channels registered
and connected. The two operations are expected to run
atomically to preserve the consistency of status among the
channels.ICﬁnder-USEidentiﬁes such atomic composition by
identifying the control dependence between the two opera-
tions upon the exceptional control ﬂow graph (the control
ﬂow graph with the exceptional edges modeled).
Listing4. CodesnippetofOpenjms
1multiplex()
{
3try{
...
5 _channels.addChannel(localChannel);
// register
7 ...
}catch(Exception e)
9{ _channels.disconnect(); // shutdown
}
11}
Conversely, as illustrated by Column Δ�
USE,ICﬁnder-USE
misses atomic compositions found byMUVI. One such atomic
composition is already shown in Listing 2.ICﬁnder-USE
misses the atomic compositions mainly because they do not
exhibit the program dependence thatICﬁnder-USErelies on.
ICﬁnder-COMPcomplementsICﬁnder-USEasICﬁnder-COMP
does not require the invocations in the atomic composition
to be linked with the program dependence.164Table2. Atomiccompositions
Benchmarks AC MUV I AC ΔΔ�AC USE ΔUSE Δ�
USE AC COMP ΔCOMP Δ�
COMP
Vacation 101660 5510 11 1 0
Labyrinth3D 3531 113 4 2 1
Bayes 3630 333 3 0 0
Cache4j 63914214 753624 43 8 28
Tuplesoup 61161 204 9 6 2
Specjbb 3630 333 4 1 0
Jspider 9702 552 7 5 0
Openjms 131261185191610 110 102 5
Lucene 245391269123 251228222 156 47 136
Jigsaw 3112110111 827625 43 28 16
Derby 3212211020 716122 53 51 30
Tomcat 21736520456233145129 132 59 144
Avrora 0770 220 7 7 0
ICﬁnder-USEmay lead to false positives. Due to the con-
servativeness of static analysis, the invocations which access
diﬀerent runtime atomic sets may be judged as accessing the
same atomic set. our backend dynamic checking ﬁlters out
those false positives.
Eﬀectiveness of the Complementation Symptom.
ICﬁnder-COMPﬁnds the atomic compositions without re-
quiring the program dependence between the invocations.
ICﬁnder-COMPadopts the complementation symptom, i.e.,
the invocations are inseparable in forming a combined atomic
operation, i.e., theyareexecutedtogetherorskippedtogether
in any execution.
We show the atomic compositions reported byICﬁnder-
COMPinColumnAC COMP , andthecomparisonswithMUVI
in Column Δ COMP and Column Δ�
COMP, in analogy to
Column Δ USEand Column Δ�
USE.
According to Column Δ COMP,MUVIoften misses more
thanhalfoftheatomiccompositionsfoundbyICﬁnder-COMP,
which is also due to the aforementioned limitation of the
statistic-basedapproach. InColumnΔ�
COMP , theﬁveentries
with“0”suggest thatICﬁnder-COMPcan ﬁnd all atomic com-
positions found byMUVIin ﬁve applications. We investigate
the rest applications whereICﬁnder-COMPmisses the atomic
compositions found byMUVI.
On one hand, the vast majority (quantiﬁed in Section 8.4)
of atomic compositions thatICﬁnder-COMPmiss are false
positives produced byMUVI. For the example in Listing 5,
the invocation of library APIs logTransactionState() and
close() do not form the atomic composition. However,
MUVI, which uses the lexical adjacency as the symptom,
reports it.
Listing5. CodesnippetofOpenjms
1logTransactionState()
{
3switch(_state.value)
caseOPENED:
5 {
log.logTransactionState(_state);
7 break;
}
9 ...
caseCLOSED:
11 {
log.close();
13 break;
}15}
Ontheotherhand, someatomiccompositionsthatICﬁnder-
COMPmisses are true positives. Listing 6 shows one such
atomic composition. The invocation of the library API
destroy() is executed only if the application is conﬁgured to
run in the GC_SYNCHRONOUS mode, while the invocation of the
otherlibraryAPI close() isexecutedwithouttherestriction.
In theGC_SYNCHRONOUS mode, the two invocations may be
expected to function atomically, while in other modes, only
the former invocation is executed. As the invocations are
not always executed together,ICﬁnder-COMPmisses the
atomiccomposition. Actually, tobetterexpresstheatomicity
intention, programmers could follow the coding paradigm
in the comment, which treats the invocation of close()
at line 9 and the invocation of destroy() at line 10 as a
combined atomic operation. With such coding paradigm,
ICﬁnder-COMPcan successfully ﬁnd the atomic composition.
Listing6. CodesnippetofOpenjms
1logTransactionState()
{
3log.close();
if(_mode=GC_SYNCHRONOUS)
5{
log.destroy();
7}
// if(_mode=GC_SYNCHRONOUS)
9// { log.close();
// log.destroy();}
11 // else
// log.close();
13}
Finally, the atomic compositions reported byICﬁnder-
COMPmay contain false positives. One common case is,
theinvocationsofAPIs Log.open() andLog.close() always
matcheachother,andthereforearejudgedastheatomiccom-
position. However, they are often executed non-atomically to
allow the interleaving updates to the Loginstance. Another
common case is the invocations of APIs Collection.get()
andCollection.put() . Programmers commonly use the
former invocation to get an item and use the latter to put
the item back after some local updates. If the invocations
complement each other in every execution,ICﬁnder-COMP
identiﬁes the atomic composition of the invocations. How-
ever, theinvocationsmaynotformtheatomiccompositionso165that theCollection instance allows the concurrent get/put
operations for eﬃciency. Such false positives could be easily
pruned based on pattern matching.
8.2 DynamicChecking
Given the inferred atomic compositions, we check dynam-
ically the incorrect compositions, i.e., the implementation
that violates the atomicity of the composition. We run the
dynamic analysis 20 times for each program and report the
total number of incorrect compositions in ColumnIC(Ta-
ble 1). Compared to the atomic compositions (ColumnAC
in Table 2), the incorrect compositions are much fewer, i.e.,
less than 10% of atomic compositions are incorrectly imple-
mented (except in the benchmarks,Bayes,Specjbb,Openjms).
Two reasons account for it: (1) the programmers can well
synchronize the majority of the compositions; (2) due to the
nature limit of the dynamic analysis,ICﬁndercannot cover all
the paths and interleavings, therefore, misses some incorrect
compositions. Our dynamic analysis allows programmers to
focus on the small fraction of incorrect compositions instead
of inspecting the large set of atomic compositions one by
one.
We also evaluate the eﬃciency ofICﬁnderand show the
analysis time (unit: msec) in Columntime(Table 1). The
analysis is very eﬃcient, i.e., it usually ﬁnishes within 1
second, which owes to the optimization (Section 6) designed
for checking atomic compositions.
8.3 CaseStudies
In this section, we evaluate the quality of the ﬁnal reports,
i.e., whether they are helpful to programmers in exposing
bugs. We focus on the large applicationTomcat, which
has an actively maintained mailing list. We conﬁrm the
bugs by either sending the posts or examining existing posts.
Five out of twelve incorrect compositions are conﬁrmed by
developers as bugs. Considering thatTomcatis heavily used
inaround250,000sites[3]includingthefamousones[37]such
asLinkedin.comandEbay.com, we believe ﬁnding the new
bugs (or newly reported bugs) automatically is signiﬁcant.
Tomcatis an open source software implementation of the
Java Servlet technologies. The code in Listing 7 is from
the class JspServletWrapper , which contains a ﬁeld named
_theServlet . The ﬁeld together with the ﬁelds referenced
by it form an atomic set. Accordingly, the library module
includes the classes declaring these ﬁelds in the atomic set,
e.g., theJspServletWrapperclass and other classes.
Two atomic APIs provided by the library module are
invoked: One API getServlet is invoked to update the
ﬁelds in the atomic set to reﬂect the most recent change in
the JSP ﬁle, the other API service is invoked to serve the
incoming request from the JSP ﬁle. The latter invocation
is data dependent on the former one via the heap access:
the invocation of the method service uses the ﬁelds that
are updated by the invocation of the method getServlet .
Therefore, our static analysis identiﬁes that the invocations
form an atomic composition.
Listing7. CodesnippetofTomcat
1service(Request request, Response response
...)
{
3synchronized (this) { getServlet();}
//_theServlet=...
5if(mt_mode) {synchronized (this) {
7 _theServlet.service(request, response)
;
}
9}
}
ICﬁnderthen checks dynamically the implementation and
ﬁnds it can be non-atomically interleaved, which leads to
harmfulbehaviors. Aremoteinvocationinterleavestodestroy
the instance referenced by _theServlet , making the state
read at line 3 unavailable at line 7. As a consequence, line 7
may use a destroyed_theServletinstance to serve.
We report the bug to the developer. The developer con-
ﬁrms it as a real bug and ﬁxes it inTomcat7.0.11 onwards
(since Revision 1078409)5.
Listing8. AnothercodesnippetofTomcat
removeAttribute(name)
2{
found = attributes.containsKey(name);
4if(found) {
...
6 attributes.remove(name);
}
8}
Another conﬁrmedTomcatbug6is shown in Listing 8. The
ConcurrentHashMap instanceattributes and its referenced
ﬁelds form an atomic set. Accordingly, the class Concurren-
tHashMap and the referenced classes form the library module,
which provides two atomic APIs,containsKeyandremove.
The two APIs are invoked at the client method removeAt-
tribute in the client module, i.e., the class Application-
Context. As the latter invocation control depends on the
former one,ICﬁnderidentiﬁes an atomic composition, which
indicates theinvariantthat the remove operation is carried
out only if the entry is present in the map.
By dynamically checking the implementation,ICﬁnder
ﬁnds that the atomic compositions can be interleaved non-
atomically by a remote invocation which removes the entry
forname. The non-atomic interleaving violates the above
invariant as the remove operation is carried out even if the
entry for nameis not present (it is removed by the remote
invocation), which leads to theNullPointerException.
8.4 AssessmentofHigh-ﬁdelityClaim
We claim that our inference of atomic compositions
achieves high ﬁdelity, which means that it has few false
negatives, i.e., it ﬁnds many of the places where atomic
composition is required, while producing few false positives.
While there is no direct way to compare our results with any
notion of absolute truth, we argue below that we use reason-
able approximations of truth. This claim has two aspects,
which we address in turn.
FewFalseNegatives. The ﬁrst interesting question is
whetherICﬁndermisses many real atomic compositions. To
answer this question, we approximate the truth by evaluating
the compositions inferred by all techniques and checking if
ICﬁndermisses real compositions found by other techniques.
5See the discussion in the mailing list: http:
//mail-archives.apache.org/mod_mbox/tomcat-dev/
201103.mbox/thread?2
6Bug53498: https://issues.apache.org/bugzilla/show_
bug.cgi?id=53498166In order to get the maximal set of possible bugs, we here look
at the compositions statically inferred rather than those con-
ﬁrmed by the dynamic analysis, in case the dynamic analysis
fails to expose a real bug. While this does not represent an
absolute truth, it is not clear how to ﬁnd the missing bugs
more comprehensively. Speciﬁcally, we investigate the appli-
cationLucene, whereICﬁndermisses the maximal number
(123) of atomic compositions inferred byMUVI. By man-
ually inspecting the atomic compositions, we ﬁnd almost
all atomic compositions thatICﬁndermisses are spurious.
For example, the invocations of APIs pauseAllThreads and
resumeAllThreads always pair each other and therefore are
judged as an atomic composition byMUVI, but they do
not actually require atomicity. The invocations of APIs un-
deleteAll anddeleteDocument frequently pair each other
in the same method and therefore are judged as an atomic
composition, but they never run in the concurrent settings
(i.e., only a single preparation thread executes them.) and
therefore do not require atomicity. Overall, forLucene, we
did not ﬁnd any genuine bugs thatICﬁndermissed.
FewFalsePositives. The second interesting question is
whether the incorrect compositions found byICﬁnderoften
represent real bugs. Note that our dynamic analysis reports
only the compositions of which the atomicity violations are
exhibited at runtime; the question now is whether the lack of
atomicity leads to a genuine bug. We answer this question by
evaluating which reports can be conﬁrmed as bugs inTomcat.
We chooseTomcatbecause it is heavily used and so ought to
have relatively hard-to-ﬁnd bugs, and because the number of
ﬁndings makes the manual validation practical. Recall from
Table 1 thatICﬁnderﬁnds 12 incorrect compositions. 5 of
these 12 incorrect compositions uncover bugs, as conﬁrmed
byTomcatdevelopers7.
In comparison,MUVIﬁnds 53 incorrect compositions; how-
ever, with the same dynamic analysis asICﬁnder, it uncovers
only 1 conﬁrmed bug. Thus,ICﬁnderhas a much higher rate
of actual bugs: 5/12=41.7% forICﬁnderand 1/53=1.9% for
MUVI. Bug reports accepted by the developers are the closest
we can come to a gold standard of true positives, and, by this
metric, a user of a heavily-used system likeTomcatwould
need to look at fewer than 3 reports to ﬁnd a genuine bug
withICﬁnder.
9. RELATEDWORK
AtomicityIntentionInference. SVD[40] is the ﬁrst
to infer the atomicity intention (or atomic regions). It infers
the atomicity based on the single-variable serializability. Dif-
ferent from it, our work preserves the atomicity on multiple
variables.AVIO[18] andAtomTracker[22] infer the atomic
region as the longest unbreakable sequence in the correct
runs.Kivati[4] applies the data ﬂow analysis to identify
consecutive accesses of a shared variable and treats them as
in atomic regions.TransFinder[34] assumes conservatively all
accesses of a shared variable form the same thread should be
atomic. In addition, it applies the static analysis to remove
the atomic regions which cannot be interleaved. The conser-
vativeness of the static analysis degenerates its usefulness.
MUVI[17] adopts the frequent togetherness as a symptom
to infer the atomic regions. It also supports multi-variable
atomicity.
7http://www.cse.ust.hk/prism/ACAtomicity Violation Detection. Diﬀerent from the
above category of work, atomicity violation detection work
focuses on checking whether the implementation allows non-
atomic interleavings, with the atomicity intention correctly
speciﬁed. As static analyses [6, 23] are incompetent in explor-
ing the possible interleavings, very few static detection work
of atomicity violations exists. A broad spectrum of dynamic
analyses strive to explore the buggy interleavings both eﬀec-
tively and eﬃciently. Model checking [21, 29] systematically
explores the interleavings. However, the exponentially large
space makes it hard to scale to large applications. Active
testing [26, 14] adopts the randomized scheduler to explore
as many diﬀerent interleavings as possible. It needs many
runs to explore the interleaving space eﬀectively, which may
not be eﬃcient. Predictive analyses [30, 13, 38] improve
the eﬃciency by computing the possible buggy interleavings
oﬄine from a set of normal traces.
Atomicity on Multiple Variables. Besides Vaziri et
al. [36], other researchers also observe and utilize the atomic-
ity on multiple correlated variables. In the area of distributed
system, consistency among multiple variables is a commonly-
desired property. Weihl et al. [39] and Herlihy et al. [11]
use the atomic objects to achieve the consistent execution
and recovery. In the software transactional memory research,
DSTM2 [10] and XSTM [25] support the usage of atomic
objects.
10. CONCLUSION
Programmers often need to compose the atomic APIs
to synthesize new atomic functionality. The compositions,
expected to be atomic, may be implemented incorrectly as
non-atomic. We design the static analysis which recognizes
the atomic compositions with the symptoms capturing the
key program logic for them, and customize the predictive
analysistoﬁndtheincorrectcompositions. Ourevaluationon
asetoflargescaleapplicationsshows, thestaticanalysisﬁnds
up to 391 atomic compositions for an application, while half
would be missed by the previous statistic-based approach.
The dynamic analysis runs eﬃciently for up to 1 second.
Overall, our approach ﬁnds around 50 incorrect compositions,
which are previously unknown. Our study onTomcatshows
that ﬁve out of twelve incorrect compositions are conﬁrmed
as bugs by the developers.
11. ACKNOWLEDGMENTS
We thank the anonymous reviewers for their valuable com-
ments and suggestions. We thank the Artifact Evaluation
Committee(AEC)forvalidatingourartifact. Thisresearchis
supported by RGC GRF grant RGC622909 and RGC621912.
12. REFERENCES
[1] S. M. Blackburn and et al. The DaCapo benchmarks:
Java benchmarking development and analysis. In
OOPSLA ’06.
[2] E. Bodden, A. Sewe, J. Sinschek, M. Mezini, and
H. Oueslati. Taming reﬂection: Aiding static analysis
in the presence of reﬂection and custom class loaders.
InICSE ’11.
[3] BuiltWith. Apache Tomcat Coyote Usage Statistics.
http://trends.builtwith.com/Web-Server/
Apache-Tomcat-Coyote, Feb. 2013.167[4] L. Chew and D. Lie. Kivati: fast detection and
prevention of atomicity violations. InEuroSys ’10.
[5] J. Dolby, C. Hammer, D. Marino, F. Tip, M. Vaziri,
and J. Vitek. A data-centric approach to
synchronization.TOPLAS ’12.
[6] D. Engler and K. Ashcraft. Racerx: eﬀective, static
detection of race conditions and deadlocks. InSOSP
’03.
[7] J. Ferrante, K. J. Ottenstein, and J. D. Warren. The
program dependence graph and its use in optimization.
TOPLAS ’1987.
[8] C. Flanagan and S. N. Freund. Atomizer: a dynamic
atomicity checker for multithreaded programs. In
POPL ’04.
[9] G. Grahne and J. Zhu. Eﬃciently using preﬁx-trees in
mining frequent itemsets. InFIMI ’03.
[10] M. Herlihy, V. Luchangco, and M. Moir. A ﬂexible
framework for implementing software transactional
memory. InOOPSLA ’06.
[11] M. Herlihy and J. Wing. Avalon: language support for
reliable distributed systems. InSymposium on
Fault-Tolerant Computer Systems, 1987.
[12] S. Horwitz, T. Reps, and D. Binkley. Interprocedural
slicing using dependence graphs.TOPLAS ’1990.
[13] J. Huang and C. Zhang. Persuasive prediction of
concurrency access anomalies. InISSTA ’11.
[14] Z. Lai, S. C. Cheung, and W. K. Chan. Detecting
atomic-set serializability violations in multithreaded
programs through active randomized testing. InICSE
’10.
[15]L. Lamport. Time, clocks, and the ordering of events in
a distributed system.CACM ’1987.
[16] P. Liu and C. Zhang. Axis: automatically ﬁxing
atomicity violations through solving control constraints.
InICSE ’12.
[17] S. Lu, S. Park, C. Hu, X. Ma, W. Jiang, Z. Li, R. A.
Popa, and Y. Zhou. Muvi: automatically inferring
multi-variable access correlations and detecting related
semantic and concurrency bugs. InSOSP ’07.
[18] S. Lu, J. Tucek, F. Qin, and Y. Zhou. Avio: detecting
atomicity violations via access interleaving invariants.
InASPLOS-XII ’06.
[19] C. Lucchese. Dci closed: A fast and memory eﬃcient
algorithm to mine frequent closed itemsets. InFIMI
’04.
[20]C. C. Minh, J. Chung, C. Kozyrakis, and K. Olukotun.
STAMP: Stanford Transactional Applications for
MultiProcessing. InIEEE International Symposium on
Workload Characterization ’08.
[21] M. Musuvathi, S. Qadeer, and T. Ball. Chess: A
systematic testing tool for concurrent software.[22] A. Muzahid, N. Otsuki, and J. Torrellas. Atomtracker:
A comprehensive approach to atomic region inference
and violation detection. InMICRO ’10.
[23]M. Naik, A. Aiken, and J. Whaley. Eﬀective static race
detection for java. InPLDI ’06.
[24] R. H. Netzer and B. P. Miller. What are race
conditions? - some issues and formalizations.ACM
Letters on Programming Languages and Systems ’1992.
[25] C. No ¨el. Extensible software transactional memory. In
Proceedings of the Third C* Conference on Computer
Science and Software Engineering ’10.
[26] C.-S. Park and K. Sen. Randomized active atomicity
violation detection in concurrent programs. InFSE ’08.
[27]M. Pradel and T. R. Gross. Fully automatic and precise
detection of thread safety violations. InPLDI ’12.
[28] O. Shacham, N. Bronson, A. Aiken, M. Sagiv,
M. Vechev, and E. Yahav. Testing atomicity of
composed concurrent operations. InOOPSLA ’11.
[29]O. Shacham, M. Sagiv, and A. Schuster. Scaling model
checking of dataraces using dynamic information. In
PPoPP ’05.
[30] F. Sorrentino, A. Farzan, and P. Madhusudan.
Penelope: weaving threads to expose atomicity
violations. InFSE ’10.
[31] W. N. Sumner, C. Hammer, and J. Dolby. Marathon:
Detecting atomic-set serializability violations with
conﬂict graphs. InRV ’11.
[32] F. Tip. A survey of program slicing techniques.
JOURNAL OF PROGRAMMING LANGUAGES,
1995.
[33] T.J. Watson Libraries for Analysis.
http://wala.sourceforge.net.
[34]G. Upadhyaya, S. P. Midkiﬀ, and V. S. Pai. Automatic
atomic region identiﬁcation in shared memory spmd
programs. InOOPSLA ’10.
[35] R. Vall´ ee-Rai and et al. Optimizing Java bytecode
using the Soot framework: Is it feasible? InCC ’00.
[36] M. Vaziri, F. Tip, and J. Dolby. Associating
synchronization constraints with data in an
object-oriented language. InPOPL ’06.
[37]W3Techs. Usage Statistics and Market Share of Tomcat
for Websites.http://w3techs.com/technologies/
details/ws-tomcat/all/all, Feb. 2013.
[38]C. Wang and M. Ganai. Predicting concurrency failures
in the generalized execution traces of x86 executables.
InRV ’11.
[39] W. Weihl and B. Liskov. Implementation of resilient,
atomic data types.TOPLAS ’1985.
[40] M. Xu, R. Bod´ ık, and M. D. Hill. A serializability
violation detector for shared-memory server programs.
InPLDI ’05.168