Locating Need-to-Translate Constant Strings in
Web Applications
Xiaoyin Wang1;2, Lu Zhang1;2‚àó, Tao Xie3‚àó, Hong Mei1;2, Jiasu Sun1;2
1Institute of Software, School of Electronics Engineering and Computer Science
2Key Laboratory of High ConÔ¨Ådence Software Technologies, Ministry of Education,
Peking University, Beijing, 100871, China
{wangxy06, zhanglu, meih, sjs}@sei.pku.edu.cn
3Department of Computer Science, North Carolina State University, Raleigh, NC 27695, USA
xie@csc.ncsu.edu
ABSTRACT
Software internationalization aims to make software accessible and
usable by users all over the world. For a Java application that does
not consider internationalization at the beginning of its develop-
ment stage, our previous work proposed an approach to locating
need-to-translate constant strings in the Java code. However, when
being applied on web applications, it can identify only constant
strings that may go to the generated HTML texts, but cannot fur-
ther distinguish constant strings visible at the browser side (need-
to-translate) from other constant strings (not need-to-translate). In
this paper, to address signiÔ¨Åcant challenges in internationalizing
web applications, we propose a novel approach to locating need-to-
translate constant strings in web applications. Among those con-
stant strings that may go to the generated HTML texts, our ap-
proach further distinguishes strings visible at the browser side from
non-visible strings via a novel technique called Ô¨Çag propagation.
We evaluated our approach on three real-world open source PHP-
based web applications (in total near 17 KLOC): Squirrel Mail,
Lime Survey, and Mrbs. The empirical results demonstrate that our
approach accurately distinguishes visible strings from non-visible
strings among all the constant strings that may go to the generated
HTML texts, and is effective for locating need-to-translate constant
strings in web applications.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance and En-
hancement
General Terms
Management, Standardization
Keywords
Software internationalization, Flag propagation, Web application
1. INTRODUCTION
Software applications usually require different local versions for
users from different regions of the world. Researchers and prac-
titioners usually refer to techniques for acquiring and managing
‚àóCorresponding author
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
FSE-18, November 7‚Äì11, 2010, Santa Fe, New Mexico, USA
Copyright 2010 ACM 978-1-60558-791-2/10/11 ...$5.00.local versions of software as software internationalization and lo-
calization. A typical way to perform software internationalization
and localization is to put language-speciÔ¨Åc elements (such as user-
visible constant strings and number/date formats, etc.) to prop-
erty Ô¨Åles (i.e., internationalization), and translate the property Ô¨Åles
without changing the code (i.e., localization). For various reasons,
developers may not internationalize a software application at the
very beginning of the development process, but have to perform
internationalization on an existing version of the software applica-
tion [17]. Therefore, the developers need to locate all the hard-
coded language-speciÔ¨Åc elements and externalize them to property
Ô¨Åles. When locating these language-speciÔ¨Åc elements, the most
time-consuming task is to locate need-to-translate constant strings
due to their large number and scattered distribution in the code.
In our previous work [17], we proposed an approach to locating
need-to-translate constant strings in Java applications. Our previ-
ous approach includes three major steps. First, we locate all of the
library-method invocations that may output a string-type argument
to the Graphical User Interface (GUI). Then, for each string-type
argument that is output to the GUI, we use string analysis [2] to ob-
tain a context-free grammar (CFG), which is built from the Static
Single Assignment (SSA) [3] form of the code. The start non-
terminal of the CFG is the string-type argument, and the language
of the CFG is all the possible values of the string-type argument. Fi-
nally, we add a unique annotation to each terminal (constant string)
in the CFG to indicate its exact location in the code, and propa-
gate the annotations in the CFG based on string-taint analysis [18]
to get the locations of all the constant strings whose values may
be passed to the string-type argument. Therefore, our previous ap-
proach is able to locate all the constant strings whose values may
go to the GUI.
In recent years, web applications are increasingly becoming pop-
ular due to the convenience of Internet access. Challenges in the
development of web applications are attracting more and more at-
tention from various researchers [13, 7, 1]. Web applications espe-
cially require internationalization partly because users from all over
the world can access them after they are put online. When apply-
ing our previous approach on web applications, we face signiÔ¨Åcant
challenges. For a web application, each dynamically generated web
page is actually a text in the HTML format displayed at the browser
side. Thus, our previous approach is able to locate the constant
strings that may go to the browser side for display. However, not all
parts of the HTML text sent to the browser side are visible to users.
In fact, strings output to the GUI in traditional applications (such
as Java GUI applications) are usually plain texts and are directly
displayed on the GUI; but strings output to the browser side in a
web application may contain HTML tags. According to the syntax
of HTML, only some parts of an HTML text are displayed on thescreen. The remaining parts of the HTML text are tags used for
format description and element identiÔ¨Åcation, etc. So, an approach
for web applications needs to further distinguish those user-visible
constant strings from other constant strings in each web page.
Typically, there are two types of user-visible strings in an HTML
text: strings displayed as texts visible on web pages and strings
displayed as labels or default values of input Ô¨Åelds on web pages.
For static web pages, it is easy to identify the user-visible constant
strings with an HTML parser. However, it is challenging to identify
the user-visible constant strings for dynamic web pages. For a dy-
namic web page, user-visible strings appear as constant strings in
the code for generating the dynamic page. Therefore, it is infeasible
to identify them in the code with an HTML parser. Furthermore, in
a typical web application, the set of possible HTML texts generated
by the application can be inÔ¨Ånite. Thus, it is also infeasible to enu-
merate all the possible HTML texts generated by the application
and check them with an HTML parser.
In this paper, to address the signiÔ¨Åcant challenges in internation-
alizing web applications, we propose a new approach to locating
need-to-translate strings in web applications. Our new approach
currently works for only PHP applications, but the idea is general
and it is relatively easy to adapt our approach for other types of
web applications. Our new approach signiÔ¨Åcantly extends and im-
proves our previous approach [17]. Given a dynamic web page, we
use our previous approach to locate constant strings that may go
to the browser side for display. Among these constant strings, we
propose two novel techniques to identify the preceding two types of
user-visible constant strings. The basic idea of the two techniques
is as follows. We add location information (such as whether the
string is inside a tag) to each terminal (constant string) and each
non-terminal. The location information of some constant strings
can be determined based on their values. We further propagate the
location information to all the other terminals and non-terminals,
and use the propagated location information to identify the preced-
ing two types of user-visible constant strings. In this paper, we
refer to the added location information as Ô¨Çags and propagation of
location information as Ô¨Çag propagation.
This paper makes the following main contributions:
A demonstration of signiÔ¨Åcant challenges in automatically
locating need-to-translate constant strings in web applica-
tions;
Novel algorithms for Ô¨Çag propagation to automatically de-
termine whether a constant string in the code can appear in
user-visible parts of the generated HTML texts;
An empirical evaluation of applying our approach on three
real-world open source web applications (in total near 17
KLOC) to evaluate the effectiveness of our approach.
We organize the rest of this paper as follows. Section 2 presents
our motivation using some sample PHP code. Section 3 introduces
some background knowledge. Section 4 presents our approach in
detail. Section 5 presents the implementation of our approach. Sec-
tion 6 reports an empirical evaluation of our approach. Section 7
discusses related issues. Section 8 discusses related work. Sec-
tion 9 concludes the paper with future work.
2. MOTIVATION
In this section, we present four code portions in three real-world
web applications to motivate our approach. The Ô¨Årst code portion
is from ‚Äúquestion.php‚Äù of Lime Survey version 0.971.
...
echo "and pressed ‚Äôrefresh‚Äô on your browser.
In this case, your responses have<br /> nn";
1http://sourceforge.net/projects/limesurvey/.echo "already been saved.";
echo "</font></center><br /><br />";
...
In the preceding code portion, we can see that, to determine that the
constant string "already been saved." can be displayed on the
screen at the browser side, we need to consider its context. In fact,
we can decide that this string is user-visible at the browser side be-
cause the strings before it ( "<br />" ) and after it ( "</font>" )
indicate that it is not inside an HTML tag. That is to say, our ap-
proach needs to check the strings, which may be either constants
or variables, before and after each constant string to determine its
context.
The second code portion is from ‚Äúday.php3‚Äù of Mrbs version
0.62. As described below, it demonstrates some constant strings
that can be determined as not user-visible only through their con-
text.
...
if ($t == $timetohighlight) {
$c = "red";
} else {
$c = "white";
}
...
echo "<td bgcolor=$c>";
...
In the preceding code portion, we can see that the constant strings
"red" and"white" appearing in the code portion are not user-
visible at the browser side because they are inside a tag correspond-
ing to a table column, quoted by "<td" and">", and they indicate
the background color of the table column.
Furthermore, some constant strings that are output to the tag part
of the generated HTML texts are still user-visible at the browser
side. Such constant strings are the value attributes of some input
tags. The following code portion is from ‚Äúcompose.php‚Äù of Squir-
rel Mail version 0.2.13.
...
if (substr(strtolower($reply_subj), 0, 3) != "re:")
$reply_subj = " Re: $reply_subj";
echo " <INPUT TYPE=TEXT NAME=passed_subject
SIZE=60 VALUE= ¬®$reply_subj¬®>";
...
In the preceding code portion, we can see that the italicized con-
stant string (i.e., "Re: " ) becomes the value attribute of an input
tag. According to the HTML syntax, this constant string is dis-
played as the default value of an input text Ô¨Åeld and is thus user-
visible. However, not all the value attributes in all the input tags are
user-visible at the browser side. According to the HTML syntax,
there are 10 types of input tags. Only when the type of an input tag
is ‚Äútext‚Äù, ‚Äúbutton‚Äù, ‚Äúsubmit‚Äù, or ‚Äúreset‚Äù, the value attribute of the
input tag is user-visible at the browser side. For example, the itali-
cized text "Y"in the following code portion (from ‚Äúqanda.php‚Äù of
Lime Survey version 0.97) is not user-visible at the browser side,
because the type of the input tag is ‚Äúcheckbox‚Äù.
...
$answer .= " ntntntntntntntntnt<input class=‚Äôcheckbox‚Äô
type=‚Äôcheckbox‚Äô name=‚Äô$myfname‚Äô value=‚Äô Y‚Äô";
if ($_SESSION[$myfname] == "Y")
$answer .= " checked";
$answer .= " onClick=‚Äôcheckconditions(this.value,
this.name, this.type)‚Äô />$ansrow[‚Äôanswer‚Äô] nn";
...
The preceding four code portions demonstrate that the challenges
for accurately determining whether each constant string in the code
is user-visible at the browser side lie in the need to know which
part of the generated HTML texts each constant string eventually
appears in. To address these challenges, we need to search in the
code to obtain the context of each constant string, and use the con-
text to determine whether the constant string is user-visible.
2http://sourceforge.net/projects/mrbs/. ‚Äú.php3‚Äù is the old extension
for PHP.
3http://sourceforge.net/projects/squirrelmail/.3. BACKGROUND
3.1 String Analysis and String-Taint Analysis
For the ease of understanding our approach presented in Sec-
tion 4, we next introduce string analysis and string-taint analysis.
The general idea of string analysis is as follows. First, the pro-
gram under analysis is transformed to the Static Single Assignment
(SSA) [3] form. Second, string assignments and operations that the
string variable under analysis depends on are abstracted as an ex-
tended Context Free Grammar (CFG) with string operations (i.e.,
library string methods such as String.subString(int,int) in
Java) on the right hand side of productions. Then these string op-
erations are simulated with Ô¨Ånite-state transducers (FSTs) [15]. Fi-
nally, the language of the generated CFG represents all the possible
values of the string variable under analysis.
String-taint analysis is a technique proposed by Wessermann and
Su [18] for tracing possible malicious user inputs to check cross-
site scripting or SQL injection. String-taint analysis is based on
the CFG generated by string analysis. Initially, the terminals cor-
responding to possible malicious user inputs are annotated with a
taint. Then, for each production in the CFG, if there is a terminal or
a non-terminal with a taint on its right hand side, the non-terminal
on the left hand side is also annotated with the taint. Finally, vul-
nerabilities are checked on certain non-terminals with taints.
Our previous work [17] adapts string-taint analysis by adding ex-
act locations in the code as annotations to the constant strings (ter-
minals) that are involved in string analysis and propagating these
annotations in the generated CFG. During the propagation, the an-
notation of the non-terminal at the left hand side of each production
becomes the union of the annotations of all the terminals and non-
terminals at the right hand side and its current annotation. Finally,
the annotation of the start non-terminal indicates the exact locations
of all the constant strings whose values may be passed to the string
variable under analysis (i.e., the start non-terminal in the CFG).
3.2 User-Visible Parts in HTML Texts
We next brieÔ¨Çy summarize which parts of a standard HTML text
are displayed to users at the browser side. There are two types of
user-visible strings in an HTML text. Strings of the Ô¨Årst type are
those that are outside any HTML tags. These strings are displayed
as ordinary texts in web pages. The Ô¨Årst code portion in Section 2
is an example of strings of this type. Strings of the second type
are those that serve as the value attributes of certain types of input
tags4. These strings are displayed as labels or default values of
input Ô¨Åelds corresponding to input tags in the generated HTML
texts. Such types of input tags include ‚Äúbutton‚Äù, ‚Äútext‚Äù, ‚Äúsubmit‚Äù,
and ‚Äúreset‚Äù. However, the value attributes of the other types of
input tags (e.g., ‚Äúradio‚Äù and ‚Äúcheckbox‚Äù) are not user-visible. For a
checkbox, its value attribute actually indicates whether it is checked
in the web page (i.e., ‚ÄúY‚Äù for checked and ‚ÄúN‚Äù for unchecked).
4. APPROACH
In this section, we Ô¨Årst formalize the target problem in Sec-
tion 4.1, and then we present two new techniques to identify the
two types of user-visible constant strings in Sections 4.2 and 4.3,
respectively.
4.1 Problem
According to string analysis, we can represent a dynamic web
page as a CFG denoted as a 4-tuple G=(N; T; S; P )(where Nis
the set of non-terminals, Tis the set of terminals, Sis the start
4Attributes of other tags (e.g., the alt attribute of the image tag) can
also be user-visible. The situation is similar to the value attribute of
the input tag so that they can be addressed by the same approach.non-terminal, and Pis the set of productions). Non-terminals can
be traced to string variables in the code, and terminals can be traced
to constant strings in the code. Based on G,L(G)=f!jS)!g
(where S)!denotes that Scan deduce !) is the set of all pos-
sible HTML texts generated in the dynamic web page. The nature
of deduction in CFGs ensures that any !2L(G)corresponds to
at least a deduction tree. The leaf nodes of the deduction tree are
terminals, and !is the concatenation of the leaf nodes. In this pa-
per, we say that Scan deduce !witht(denoted as St)!, where
t2T), ifS)!andtappears as a leaf node in at least one
deduction tree of !.
Thus, given a dynamic web page, the problem of determining
constant strings that may go to the HTML texts generated in the
dynamic web page can be represented as the calculation of the fol-
lowing set: S1=ftjt2T^ 9!2L(G)(St)!)g. Our previous
approach [17] uses an adapted string-taint analysis to calculate this
set. However, calculating S1is not sufÔ¨Åcient for locating need-to-
translate constant strings in a dynamic web page.
Given !2L(G)andt2T, an HTML parser can determine
whether tappears in a user-visible part of !. In this paper, we de-
note that tappears in a user-visible part of !asV is(!; t). Thus,
the problem of locating need-to-translate constant strings in a dy-
namic web page can be represented as the calculation of the fol-
lowing set: S2=ftjt2T^ 9!2L(G)(St)!^V is(!; t))g.S2
is a subset of S1.
As it is infeasible to enumerate each !2L(G)to check whether
V is(!; t)holds, we need to analyze the productions in Gto iden-
tify user-visible constant strings in T. In our approach, we rep-
resent V is(!; t)as location characteristics of t, and check which
terminals satisfy these location characteristics on the basis of the
productions.
4.2 Locating Outside-Tag Constant Strings
If a constant string contains ‚Äò<‚Äô or ‚Äò>‚Äô, we can use ‚Äò<‚Äô or ‚Äò>‚Äô to
determine which parts of the constant string are outside tags. For
example, we know that, in ‚Äú<abc>def‚Äù, ‚Äúabc‚Äù appears inside a tag
and ‚Äúdef‚Äù appears outside tags. However, if a constant string does
not contain either ‚Äò<‚Äô or ‚Äò>‚Äô, we need to resort to constant strings
that may be concatenated to the constant string in the generated
HTML texts. For example, if we know that ‚Äú<abc>‚Äù may be con-
catenated to ‚Äúdef‚Äù to form a string like ‚Äú<abc>def‚Äù in the generated
HTML texts, we can determine that ‚Äúdef‚Äù is outside tags using the
‚Äò>‚Äô in ‚Äú<abc>‚Äù. In fact, when two strings are concatenated together,
the right-most point of the Ô¨Årst string and the left-most point of the
second string become the same point. Thus, if one such point is
outside tags, the other point is also outside tags. As a result, if we
already know some constant strings are outside or inside tags, we
can also know whether other constant strings are outside or inside
tags by iteratively checking neighboring strings.
Following this idea, this sub-section presents a technique for lo-
cating user-visible constant strings appearing outside tags, consist-
ing of four phases: adding Ô¨Çags to variables5, initializing Ô¨Çags of
variables, propagating Ô¨Çags, and identifying outside-tag constant
strings.
4.2.1 Adding Flags to Variables
For each variable in the CFG, we add two Ô¨Çags: the left Ô¨Çag and
the right Ô¨Çag. The left Ô¨Çag represents whether the left-most point
of the variable is inside an HTML tag and the right Ô¨Çag represents
whether the right-most point of the variable is inside an HTML tag.
5Here we use variables to denote either terminals or non-terminals
for the ease of presentation. Note that a variable in a CFG is differ-
ent from a variable in its corresponding code.4.2.2 Initializing Flags of Variables
We deÔ¨Åne four different values for Ô¨Çags of variables in the CFG:
unknown : denoting that it is not known whether the left-most
point or the right-most point is inside an HTML tag;
inside : denoting that the left-most point or the right-most
point is inside an HTML tag;
outside : denoting that the left-most point or the right-most
point is outside any HTML tag;
conÔ¨Çict : denoting that the left-most point or the right-most
point may be either inside or outside HTML tags.
We initialize the Ô¨Çags of each variable in the CFG as follows.
If the variable is a non-terminal, set both its left Ô¨Çag and right
Ô¨Çag as unknown .
If the variable is a terminal and it contains neither ‚Äò <‚Äô nor
‚Äò>‚Äô, set both its left Ô¨Çag and right Ô¨Çag as unknown .
Otherwise, if the left-most ‚Äò >‚Äô or ‚Äò<‚Äô is actually a ‚Äò <‚Äô, set
the left Ô¨Çag as outside ; otherwise, set the left Ô¨Çag as inside ;
and if the right-most ‚Äò >‚Äô or ‚Äò<‚Äô is actually a ‚Äò <‚Äô, set the right
Ô¨Çag as inside ; otherwise, set the right Ô¨Çag as outside .
4.2.3 Propagating Flags
After initialization, we propagate the Ô¨Çag values between Ô¨Çags
on the basis of productions. Here, the propagation is bidirectional
and the propagation between Ô¨Çag Aand Ô¨Çag Bwill result in set-
ting both AandBwith the same Ô¨Çag value, which we denote as
BiPropagate (A; B ). We repeatedly do the preceding propaga-
tion until the propagation cannot change the value of any Ô¨Çag. The
rules for calculating BiPropagate (A; B )are as follows.
BiPropagate (A; B )=unknown , if values of both AandB
areunknown .
BiPropagate (A; B )=inside , if values of both AandBare
inside , or one value is inside and the other is unknown .
BiPropagate (A; B )=outside , if values of both AandB
areoutside , or one value is outside and the other is unknown .
BiPropagate (A; B )=conÔ¨Çict , if either the value of Aor
the value of BisconÔ¨Çict , or one value is inside and the other
isoutside .
Given a production, we propagate the Ô¨Çags of variables in the pro-
duction with the following rules.
1.If two variables are neighboring at the right hand side of a
production, we perform a propagation between the right Ô¨Çag
of the Ô¨Årst variable and the left Ô¨Çag of the second variable.
2.If a terminal contains neither ‚Äò <‚Äô nor ‚Äò >‚Äô, we perform a prop-
agation between the left Ô¨Çag and right Ô¨Çag of the terminal.
3.We perform a propagation between the right Ô¨Çag of the pro-
duction‚Äôs left-hand-side variable and the right Ô¨Çag of the last
variable in the production‚Äôs right hand side.
4.We perform a propagation between the left Ô¨Çag of the pro-
duction‚Äôs left-hand-side variable and the left Ô¨Çag of the Ô¨Årst
variable in the production‚Äôs right hand side.
4.2.4 Identifying Outside-Tag Constant Strings
After we acquire the Ô¨Ånal values of the left Ô¨Çags and right Ô¨Çags
of all the variables, we consider each terminal (constant string) that
contains at least a ‚Äò<‚Äô or a ‚Äò>‚Äô and that has at least one of its two
Ô¨Çags as outside orconÔ¨Çict to be a possible need-to-translate con-
stant string. Note that, as such a constant string may contain tags,
we need to further check which parts of the string need translation.
A terminal can have its Ô¨Çag value as conÔ¨Çict due to one of the
following three factors. First, the code has some bugs and may
generate incomplete tags (e.g., "<input id= </br>"). Second,Table 1: Flag Initialization
Variable left Ô¨Çag right Ô¨Çag
‚Äú<input ‚Äù outside inside
‚ÄúStudent ID‚Äù unknown unknown
‚Äúname=‚Äù unknown unknown
‚Äústudent‚Äù unknown unknown
‚Äú>‚Äù inside outside
all non-terminals unknown unknown
there exists some imprecision in string analysis. The reason lies in
that string analysis tries to use a CFG to express the possible strings
generated by the code, but the set of possible strings generated by
the PHP code may go beyond the expressiveness power of CFGs
(e.g., PHP code can generate 0n1n2n, which cannot be expressed
exactly by any CFG). Thus string analysis actually approximates
the possible strings generated by PHP code using a CFG that ex-
presses the superset of the possible strings generated by the PHP
code (e.g., using 0‚àó1‚àó2‚àóto approximate 0n1n2n), and may contain
some strings that actually cannot be generated by the PHP code.
Third, the constant string corresponding to the terminal may ap-
pear both inside tags and outside tags. The following code portion
is an example of such a situation.
$abc = "dog";
echo <div id = $abc>$abc</div>
From the above code portion, as constant string ‚Äúdog‚Äù may ap-
pear outside any tag, it should be a need-to-translate constant string.
However, the constant string also appears inside an HTML tag.
For such a case, the developer can refactor the PHP code by split-
ting the variable $abc into two variables; otherwise, translation of
‚Äúdog‚Äù may impact the structure of the generated HTML. As our ap-
proach cannot differentiate which reason causes the conÔ¨Çict value
currently, we consider all terminals (constant strings) with the con-
Ô¨ÇictÔ¨Çag value as need-to-translate to reduce false negatives.
4.2.5 Illustration
To further illustrate the Ô¨Çag-propagation process, we use the fol-
lowing example CFG.
S -> A"<input "BCD (1)
A -> "Student ID" (2)
B -> "name=" (3)
C -> "student" (4)
D -> ">" (5)
In the example productions, non-terminals are represented by capi-
tal alphabets and terminals are surrounded by quotation marks. The
PHP code corresponding to the CFG tries to generate a string of
‚ÄúStudent ID‚Äù followed by an input tag. The initialization of the two
Ô¨Çags of each variable is shown in Table 1.
Assume that we divide Ô¨Çag propagation into a series of iterations,
and in each iteration, from the Ô¨Årst production to the last produc-
tion, we propagate Ô¨Çags for the production by applying the four
rules (described in Section 4.2.3) one by one.
The Ô¨Årst-iteration propagation goes as follows. First, we take the
Ô¨Årst production and perform a propagation with the Ô¨Årst rule be-
tween the right Ô¨Çag of Aand the left Ô¨Çag of "<input " . Since the
left Ô¨Çag of "<input " isoutside , the right Ô¨Çag of Abecomes out-
side. Similarly, the left Ô¨Çag of Bbecomes inside . As there are no
terminals without containing either ‚Äò <‚Äô or ‚Äò>‚Äô, there is no propa-
gation with the second rule for the Ô¨Årst production in this iteration.
The third rule changes nothing, because both the right Ô¨Çag of D
and the right Ô¨Çag of Sareunknown . The fourth rule also changes
nothing, because both the left Ô¨Çag of Aand the left Ô¨Çag of Sare
unknown . Second, we then turn to the second production. As the
right Ô¨Çag of Aisoutside now, the right Ô¨Çag of "Student ID" be-
comes outside using the third rule. As we consider the second rule
before the third rule, we cannot change the left Ô¨Çag of "Student
ID"tooutside in the Ô¨Årst iteration. Third, the left Ô¨Çag of "name="
becomes inside using the fourth rule, since the left Ô¨Çag of Bis in-
side. As we consider the second rule before the fourth rule, wecannot change the right Ô¨Çag of "name=" toinside in the Ô¨Årst itera-
tion. Fourth, we change nothing with the fourth production in the
Ô¨Årst iteration. Finally, the left Ô¨Çag of Dbecomes inside , and the
right Ô¨Çag of Dbecomes outside .
After the Ô¨Årst iteration, the CFG with Ô¨Çag values is as below. For
simplicity, we use (O) to denote outside , (I) to denote inside , (U) to
denote unknown , and (C) to denote conÔ¨Çict .
(U)S(U) -> (U)A(O)(O)"<input "(I)(I)B(U)(U)C(U)(I)D(O) (1)
(U)A(O) -> (U)"Student ID"(O) (2)
(I)B(U) -> (I)"name="(U) (3)
(U)C(U) -> (U)"student"(U) (4)
(I)D(O) -> (I)">"(O) (5)
Then we perform propagation for the second iteration, and the CFG
with Ô¨Çag values is as follow. The Ô¨Çags in the bold font indicate the
changes from the Ô¨Årst iteration.
(U)S( O) -> ( O)A(O)(O)"<input "(I)(I)B( I)(U)C( I)(I)D(O) (1)
(O)A(O) -> ( O)"Student ID"(O) (2)
(I)B( I) -> (I)"name="( I) (3)
(U)C( I) -> (U)"student"( I) (4)
(I)D(O) -> (I)">"(O) (5)
Then after several iterations, the Ô¨Ånal CFG with Ô¨Çag values be-
comes as follow. The Ô¨Çags in the bold font indicate the changes
from the second iteration.
(O)S(O) -> (O)A(O)(O)"<input "(I)(I)B(I)( I)C(I)(I)D(O) (1)
(O)A(O) -> (O)"Student ID"(O) (2)
(I)B(I) -> (I)"name="(I) (3)
(I)C(I) -> ( I)"student"(I) (4)
(I)D(O) -> (I)">"(O) (5)
Finally, from the CFG with Ô¨Çag values, we can distinguish that
the constant string ‚ÄúStudent ID‚Äù in the second production appears
outside tags, since both its left and right Ô¨Çags are outside .
4.3 Locating Need-to-Translate Constant
Strings Inside Input Tags
To check whether a constant string is a need-to-translate constant
string inside an input tag, we need to check whether and where the
constant string may appear in an input tag. To achieve this purpose,
we extend Ô¨Çag propagation described in Section 4.2. In particular,
the technique for locating need-to-translate constant strings inside
input tags consists of four phases. The Ô¨Årst phase is to locate all
the occurrences of ‚Äúinput‚Äù (in the CFG) that correspond to an input
tag. The second phase is to identify the scope of each input tag.
The third phase is to identify the value and the type attributes in
the input-tag scope. The fourth phase is to determine whether a
constant string as a value attribute is need-to-translate according to
the content of its corresponding type attribute.
To simplify the situation, we make an assumption that all the
HTML keywords (e.g., ‚Äúinput‚Äù, ‚Äútype‚Äù, ‚Äúvalue‚Äù, and possible type
values like ‚Äúbutton‚Äù and ‚Äútext‚Äù) in the generated HTML text ap-
pears in the code as a whole. In other words, the keywords are not
split into more than one constant string in the PHP code but there
can be constant strings in which one or more keywords appear as
substrings. Our algorithm described below works only under this
assumption. So the algorithm cannot deal with the code below.
echo <inp
echo ut id="id1">
We expect that this assumption holds in most cases in real PHP
code, because there is no need to use string variables to generate
keywords and few programmers would write such PHP code, which
is quite difÔ¨Åcult to understand and exists with no good reasons.
4.3.1 Locating Input Tags
In this phase, we Ô¨Årst collect a list of candidate input tags by
collecting all the terminals that both have ‚Äúinput‚Äù as a substring and
are decided as inside-tag in identiÔ¨Åcation of outside-tag constant
strings. Some of the collected terminals containing ‚Äúinput‚Äù may
not correspond to an input tag in the generated HTML text, because
‚Äúinput‚Äù in an inside-tag terminal may serve as an attribute of an
HTML tag (e.g., ‚Äúinput‚Äù in <div name=‚Äúinput‚Äù >). Accordingto the HTML syntax, only an ‚Äúinput‚Äù that appears at the beginning
of a tag corresponds to an input tag. In other words, each such
‚Äúinput‚Äù has its nearest previous non-space character as ‚Äò <‚Äô. So
we then check whether the non-space character appearing nearest
before ‚Äúinput‚Äù is a ‚Äò <‚Äô.
In particular, we determine input tags as follows. If the termi-
nal containing an ‚Äúinput‚Äù has a non-space character immediately
before the ‚Äúinput‚Äù and the non-space character is a ‚Äò <‚Äô, then we
know that the ‚Äúinput‚Äù corresponds to an input tag. If the termi-
nal containing an ‚Äúinput‚Äù has a non-space character immediately
before the ‚Äúinput‚Äù but the non-space character is not a ‚Äò <‚Äô, then
we know that the ‚Äúinput‚Äù does not correspond to an input tag. If
the terminal containing such an ‚Äúinput‚Äù has no non-space character
immediately before the ‚Äúinput‚Äù, we put the terminal into an unde-
cided list and use the following Ô¨Çag propagation to further check
terminals in this list.
Similar to the technique described in Section 4.2, we also give
each variable in the CFG two Ô¨Çags: the left Ô¨Çag and the right Ô¨Çag.
This time a Ô¨Çag has only two values: unknown andbefore_input .
The value before_input represents that the corresponding point of
the Ô¨Çag is before a string with ‚Äúinput‚Äù value but after any non-space
character. Then, for each terminal in the undecided list, we set the
value of its left Ô¨Çag as before_input and the value of its right Ô¨Çag as
unknown . For each other terminal, we set the values of both Ô¨Çags as
unknown . After that, we propagate the Ô¨Çag values in the CFG in a
way similar to the Ô¨Çag propagation for locating outside-tag constant
strings in Section 4.2.3 using the following propagation rules.
1.If two variables are neighboring at the right hand side of a
production, we perform a propagation from the left Ô¨Çag of
the second variable to the right Ô¨Çag of the Ô¨Årst variable.
2.If a terminal contains only spaces, we perform a propaga-
tion from the right Ô¨Çag of the terminal to the left Ô¨Çag of the
terminal.
3.We perform a propagation from the right Ô¨Çag of the produc-
tion‚Äôs left-hand-side variable to the right Ô¨Çag of the last vari-
able in the production‚Äôs right hand side.
4.We perform a propagation from the left Ô¨Çag of the Ô¨Årst vari-
able in the production‚Äôs right hand side to the Ô¨Çag of the pro-
duction‚Äôs left-hand-side variable.
Here, the propagation is unidirectional and the direction is back-
ward in possible HTML texts. Therefore, we denote the propaga-
tion from Ô¨Çag Ato Ô¨Çag Bas assigning BackPropagate (A; B )to
Bwithout changing the value of A. We deÔ¨Åne BackPropagate (A; B )
as follows.
BackPropagate (A; B )=unknown , if values of both Aand
Bareunknown .
BackPropagate (A; B )=before_input , if either the value
ofAor the value of Bisbefore_input .
The preceding deÔ¨Ånition of BackPropagate (A; B )ensures that
a Ô¨Çag of value unknown cannot be propagated to a Ô¨Çag of value be-
fore_input . Furthermore, as we are looking for the previous instead
of the following character of a given terminal, the preceding def-
inition of BackPropagate (A; B )ensures that we search in the
correct direction.
Like the bidirectional Ô¨Çag propagation for locating outside-tag
constant strings, the backward propagation ends when no Ô¨Çag value
changes. Then, we check whether there is a terminal whose right
Ô¨Çag has the value of before_input and whose left Ô¨Çag has the value
ofunknown . For such a terminal (denoted as t), if the last non-
space character in tis ‚Äò<‚Äô, we know that it is possible that a ‚Äò <‚Äô
appears as the nearest non-space character before an ‚Äúinput‚Äù in the
undecided list. Thus, we determine the ‚Äúinput‚Äù as an input tag. Oth-
erwise, we Ô¨Ålter out the ‚Äúinput‚Äù. Note that the preceding backwardÔ¨Çag propagation is for checking only one ‚Äúinput‚Äù in the undecided
list, and we use the same way to check every other ‚Äúinput‚Äù in the
undecided list one by one.
Furthermore, it is possible that an ‚Äúinput‚Äù has more than one
possible nearest previous non-space character and not all of them
are ‚Äò<‚Äô. In such situations, the ‚Äúinput‚Äù has other usages than being
a tag mark6. In these situations, our approach may produce some
false positives. The empirical study in Section 6 shows that such
false positives are of only a small number in practice.
4.3.2 Identifying Scopes of Input Tags
In the second phase, we Ô¨Ånd out all the terminals that may ap-
pear inside the scope of each input tag. We start from the input
tags located in the Ô¨Årst phase. For each terminal corresponding to
an input tag, if the terminal contains a ‚Äò >‚Äô following the ‚Äúinput‚Äù,
the scope of the input tag can be easily determined. Otherwise,
if the terminal does not contain such a following ‚Äò >‚Äô, we perform
Ô¨Çag propagation to identify all the terminals that are possibly in the
scope of the input tag.
Here the Ô¨Çag propagation is also unidirectional and the direction
direction is forward. We give each variable a left Ô¨Çag and a right
Ô¨Çag. The value of a Ô¨Çag is unknown orafter_input . The value
after_input represents that the corresponding point of the Ô¨Çag is
after a tag mark ‚Äúinput‚Äù but before a ‚Äò >‚Äô character, which indicates
the end of the input tag. We initialize the right Ô¨Çag of the terminal
asafter_input and all the other Ô¨Çags as unknown .
Like bidirectional and backward propagation, the forward prop-
agation also has four rules.
1.If two variables are neighboring at the right hand side of a
production, we perform a propagation from the right Ô¨Çag of
the Ô¨Årst variable to the left Ô¨Çag of the second variable.
2.If a terminal contains neither ‚Äò <‚Äô nor ‚Äò >‚Äô, we perform a prop-
agation from the left Ô¨Çag of the terminal to the right Ô¨Çag of
the terminal.
3.We perform a propagation from the left Ô¨Çag of the produc-
tion‚Äôs left-hand-side variable to the left Ô¨Çag of the Ô¨Årst vari-
able in the production‚Äôs right hand side.
4.We perform a propagation from the right Ô¨Çag of the last vari-
able in the production‚Äôs right hand side to the right Ô¨Çag of the
production‚Äôs left-hand-side variable.
If we denote the forward propagation from Ô¨Çag Ato Ô¨Çag Bas as-
signing ForPropagate (A; B )toBwithout changing the value of
A, the deÔ¨Ånition of ForPropagate (A; B )is as follows.
ForPropagate (A; B )=unknown , if values of both Aand
Bareunknown .
ForPropagate (A; B )=after_input , if either the value of
Aor the value of Bisafter_input .
The forward propagation ends when no Ô¨Çag value changes. Then,
there are three types of terminals that may contain substrings in
the scope of the input tag: the terminal corresponding to the in-
put tag, terminals whose left Ô¨Çag and right Ô¨Çag both have the value
ofafter_input , and terminals whose left Ô¨Çag has the value of af-
ter_input and whose right Ô¨Çag has the value of unknown . For the
terminal corresponding to the input tag, the characters after the tag
mark ‚Äúinput‚Äù are in the scope of the input tag. For each terminal
whose left Ô¨Çag and right Ô¨Çag both have the value of after_input , all
the characters are in the scope of the input tag. For each terminal
whose left Ô¨Çag has the value of after_input and whose right Ô¨Çag has
the value of unknown , the characters before the Ô¨Årst ‚Äò >‚Äô is in the
scope of the input tag. For the ease of presentation, we also use the
scope of an input tag to denote the characters determined to be in
the scope of the input tag.
6We use ‚Äútag mark‚Äù to denote a constant string corresponding to an
HTML tag, such as the ‚Äúinput‚Äù in ‚Äú <input type=text name=‚Äù.4.3.3 Identifying Value and Type Attributes of Input
Tags
After determining the scope of a given input tag, the third phase
further determines the parts that indicate the value attribute and
type attribute of the input tag in its scope. Here, we need to handle
only each input tag whose scope is not contained as a whole in a
terminal. Otherwise, the type and the value attributes can be eas-
ily acquired. The key technique in this phase is the forward Ô¨Çag
propagation described in Section 4.3.2.
As identifying the type attribute of an input tag is very similar
to identifying the value attribute of an input tag, we present only
the identiÔ¨Åcation of the value attribute of an input tag. Let us con-
sider the HTML syntax about the value attribute of an input tag.
For an input tag, there are two ways to indicate its value attribute.
The Ô¨Årst way is to use a pair of single or double quotations. For
example, an input tag with value ‚Äúabc‚Äù can be deÔ¨Åned as <input
value=‚Äòabc‚Äô >or<input value=‚Äúabc‚Äù >. The second way is
not to use quotations. For example, an input tag with value ‚Äúabc‚Äù
can also be deÔ¨Åned as <input value=abc >.
The identiÔ¨Åcation of the value attribute of an input tag consists
of four steps. First, we locate all the keyword ‚Äúvalue‚Äù in the scope
of the given input tag. Second, for each keyword ‚Äúvalue‚Äù, we Ô¨Ånd
all the possible nearest following non-space characters of ‚Äúvalue‚Äù7.
Third, for each character found in the second step, if the character is
‚Äò=‚Äô, the ‚Äúvalue‚Äù before ‚Äò=‚Äô indicates that the value attribute is after
‚Äò=‚Äô. In this case, we Ô¨Ånd all the possible nearest following non-
space characters of ‚Äò=‚Äô. Then the acquired characters should be
the Ô¨Årst character in the value attribute. Fourth, for each character
acquired in the third step, if the character is a ‚Äò "‚Äô or ‚Äò‚Ä≤‚Äô, we Ô¨Ånd all
the terminals that may appear in the scope after this character and
before another ‚Äò "‚Äô or ‚Äò‚Ä≤‚Äô; otherwise, we Ô¨Ånd all the terminals after
this character and before a space or ‚Äò >‚Äô.
In the identiÔ¨Åcation of the value attribute of an input tag, we
adapt the second propagation rule in forward Ô¨Çag propagation. The
essence of the adaptation is as follows. If we are looking for a char-
acter (denoted as C), we perform a propagation from the left Ô¨Çag
of a terminal to the right Ô¨Çag of the terminal only when the termi-
nal does not contain C. For example, in the second and third steps,
when we are looking for the nearest non-space character following
‚Äúvalue‚Äù or ‚Äò=‚Äô , Cbecomes any non-space character ( /space), and
the second propagation rule allows propagation through terminals
containing only spaces.
4.3.4 Identifying Need-to-Translate Constant Strings
Inside Input Tags
After we acquire the terminals in the type and the value attributes
of an input tag, we determine whether the terminals in the value
attribute is need-to-translate as follows. We check all the terminals
that possibly serve as the type attribute of the input tag. If there
is any keyword (e.g., ‚Äútext‚Äù and ‚Äúbutton‚Äù) indicating that the value
attribute of the input tag is user-visible, we conservatively consider
all those terminals possibly serving as the value attribute as need-
to-translate. Additionally, if an input tag has no type attribute but
only a value attribute, the value attribute of the input tag is need-to-
translate, because according to the HTML syntax, the default type
attribute for an input tag is ‚Äútext‚Äù.
5. IMPLEMENTATION
As our previous approach [17] works for only Java code, our
new approach for PHP applications cannot reuse the implementa-
tion of our previous approach. Therefore, we adapted an existing
7In a generated HTML text, only one value attribute is active; how-
ever, the string forming the value attribute can have multiple ori-
gins. So an input tag may have multiple terminals as its possible
value attributes. The type attribute has the same characteristic.PHP string analyzer called PHPSA [15]. PHPSA builds a CFG
from the PHP code, and the start non-terminal of the built CFG
represents all possible HTML texts generated by the PHP code.
We re-implemented the adapted string-taint analysis [17] on top of
PHPSA. Thus, each time we run the adapted PHPSA, we obtain a
CFG with all terminals and non-terminals annotated with locations
in the code. Since the start non-terminal represents all possible
HTML texts generated by the PHP code, its annotations (location
information) indicate all constant strings in the code that may ap-
pear in the generated HTML texts, and these constant strings form
a list of candidate constant strings.
To identify the need-to-translate constant strings from candidates,
we implemented the techniques introduced in Section 4. Our im-
plementation reads the CFG (with annotations) generated by the
adapted PHPSA, performs the Ô¨Çag-propagation algorithms (in which
our implementation adds and propagates Ô¨Çags for only candidate
constant strings), and acquires a list of user-visible terminals that
may appear in the user-visible parts of the generated HTML texts.
6. EVALUATION
6.1 Research Questions
Our evaluation aims to answer the following research questions:
RQ1 : How effective is our approach for locating need-to-
translate constant strings in web applications?
RQ2 : How effective are our two new techniques for locating
the two types of need-to-translate constant strings in web ap-
plications compared with a related previous approach [17]?
The Ô¨Årst research question is concerned with evaluating our ap-
proach as a whole. The second research question is concerned with
evaluating our two new techniques proposed in this paper.
6.2 Approaches Under Comparison
To answer the two preceding research questions, we compared
the following three approaches in our evaluation. First, we consid-
ered our approach proposed in Section 4. Second, since our ap-
proach extends our previous approach [17], we also considered our
previous approach without extension as a baseline in the evaluation.
Third, as the extension over our previous approach consists of two
techniques, we also considered an approach with only one tech-
nique (i.e., the technique for locating outside-tag constant strings).
For the ease of presentation, we use ‚ÄúBS‚Äù to denote our previous
approach, which serves as the baseline; ‚ÄúBS+O‚Äù to denote the ap-
proach with only the technique for locating outside-tag constant
strings, indicating that this approach is the baseline approach plus
the technique for locating outside-tag constant strings; ‚ÄúAll‚Äù to de-
note our new approach proposed in Section 4, indicating that our
approach is the baseline approach plus the two techniques.
6.3 Subject Programs
We used three real-world open source web applications as sub-
jects: Lime Survey, Squirrel Mail, and Mrbs. All three applications,
which are accessible from SourceForge8, are written in PHP. The
primary reason for choosing these three applications as subjects is
that they belong to different web application domains and they have
different web page structures. Lime Survey, started in March 2003,
is a popular web application to do surveys on the Internet. Squirrel
Mail is a well-known web-based email client started since Novem-
ber 1999. Mrbs is a web-based meeting room reservation system
started since early May 2000. The information of the subjects is
presented in Table 2. For each subject, Columns 1 to 6 show the
name and the version number of the application, the starting month
8http://www.sourceforge.net/of the application, the number of developers involved in the devel-
opment of the application, the number of lines of code (LOC) of the
application, the number of Ô¨Åles of the application, and the number
of constant strings of the application, respectively.
The developers of all the three subjects did not consider inter-
nationalization at the beginning, and they used many hard-coded
constant strings in English in early versions of theses subjects. In
June 2003, the developers of Lime Survey internationalized Lime
Survey and updated the application from Version 0.97 to Version
0.98. The primary aim of the internationalization was to create a
version for Spanish users. In January 2000, the developers of Squir-
rel Mail internationalized Squirrel Mail and updated the application
from Version 0.2.1 to Version 0.3prel. In May 2000, the developers
of Mrbs began to internationalize Mrbs and updated the application
from version 0.6 to 0.7. For all the three subjects, we applied the
three approaches on versions before internationalization.
6.4 Metrics
To evaluate the three approaches, we obtained the exact need-
to-translate constant strings in the three subjects using a proce-
dure similar to the evaluation in our previous work [17]. First,
we deemed constant strings in the version before internationaliza-
tion as need-to-translate constant strings, if the developers exter-
nalized them in the subsequent internationalized version. Second,
as the approaches under comparison did Ô¨Ånd a number of need-to-
translate constant strings that were not externalized in the subse-
quent internationalized version for each subject, we also deemed
as need-to-translate the constant strings that at least one approach
located and we manually veriÔ¨Åed to be need-to-translate.
In particular, when one approach located a constant string not
externalized in the subsequent internationalized version, we fur-
ther checked the versions later than the subsequent international-
ized version. We deemed the constant string as need-to-translate,
if it was externalized in a later version. If not, we manually gen-
erated some input data to execute the subsequent internationalized
version. If we could see the string on some web page and found it
not understandable to a user not familiar with English, we deemed
it as need-to-translate; otherwise, we deemed it as not requiring
translation. The numbers of the need-to-translate constant strings
in the subjects are shown in the last column in Table 2.
All the numbers in our statistics and evaluation are the numbers
of constant string locations in the code rather than constant string
values. For example, constant strings of the same value but ap-
pearing in two different locations in the code are counted as two.
Furthermore, the numbers are for the versions before international-
ization. For example, if three constant strings in the previous ver-
sions are externalized as one string in the internationalized version,
the constant strings are counted as three.
Based on the obtained need-to-translate constant strings, for each
approach and each subject, we calculated the number of constant
strings that need translation but are not located by the approach
(denoted as false negatives), and the number of constant strings
that are located by the approach but actually do not need transla-
tion (denoted as false positives). In the brackets after the numbers
shown in the last two columns of Table 3, the percentages of false
negatives and false positives are presented.
6.5 Results and Analysis
6.5.1 RQ1: Overall Effectiveness
The rows where subject names are marked with ‚ÄúAll‚Äù in Ta-
ble 3 show the results of using our approach on the three subjects.
In the table, we use FN to denote false negatives and FP to de-
note false positives. We use Lime and Squirrel as abbreviations
of Lime Survey and Squirrel Mail, respectively. The ‚ÄúNeed-to-Table 2: Basic information of the subjects
Application Starting #Developers #LOC #Files #Constant #Need-to-Translate (#Not externalized
/Version Month Strings in the subsequent version)
Lime Survey 0.97 March 2003 3 11.3k 25 6493 290(5)
Squirrel Mail 0.2.1 Nov. 1999 1 4.0k 39 2457 184(74)
Mrbs 0.6 May 2000 2 1.4k 19 704 57(20)
Table 3: Results of the three experimented approaches
Subject Need-to- Located FN FP
(Approach) Translate
Lime (ALL) 290 219 89(31%) 18(6%)
Lime (BS+O) 290 198 110(38%) 18(6%)
Lime (BS) 290 599 89(31%) 398(137%)
Squirrel (ALL) 184 192 0(0%) 8(4%)
Squirrel (BS+O) 184 180 12(7%) 8(4%)
Squirrel (BS) 184 718 0(0%) 534(290%)
Mrbs (ALL) 57 42 17(30%) 2(4%)
Mrbs (BS+O) 57 42 17(30%) 2(4%)
Mrbs (BS) 57 140 17(30%) 100(175%)
Translate‚Äù and ‚ÄúLocated‚Äù columns show the number of exact need-
to-translate constant strings and the number of need-to-translate
constant strings located by each approach, respectively. From the
results, we have three main observations.
First, our approach to locating need-to-translate constant strings
in web applications (using both new techniques) is able to locate
most of the need-to-translate strings. In Lime Survey, our approach
locates 201 of 290 exact need-to-translate constant strings. In Squir-
rel Mail, our approach locates all the 184 need-to-translate constant
strings. In Mrbs, our approach locates 40 of 57. All the 89 false
negatives in Lime Survey are due to the analysis inaccuracy of the
PHP string analyzer used in our implementation. In particular, in
Lime Survey, there are constant strings that are compared with the
default values of input tags in the generated web pages that are
fetched by $POST[‚Äòname of the input tag‚Äô] . Since the de-
fault values of the input tags are need-to-translate (when the input
tags are of certain types), the constant strings that are compared
to the default values are also need-to-translate. The PHP string
analyzer used in our implementation cannot catch the assignment
relation between the default value of an input tag and the variable
$POST[‚Äòname of the input tag‚Äô] . Since the CFG itself does
not contain this relation, our approach currently cannot handle this
situation. We believe that our approach should be able to locate
these false negatives if the underlying string analyzer is imple-
mented in a more advanced way. The 17 false negatives in Mrbs
are due to that Mrbs used some static HTML texts together with
PHP code, and our approach cannot locate need-to-translate con-
stant strings in static HTML texts. However, such need-to-translate
constant strings can be easily found using an HTML parser.
Second, for each subject, our approach produces a few false pos-
itives. In Lime Survey, Squirrel Mail, and Mrbs, the numbers of
constant strings that are located by our approach but do not need
translation are 18, 8, and 2, respectively. Compared to the num-
bers of need-to-translate strings in the three subjects, the numbers
of false positives are quite small. One reason for false positives is
our conservative policy on conÔ¨Çict Ô¨Çags. This reason accounts for
12 false positives in Lime Survey and 7 false positives in Squir-
rel Mail. The second reason of false positives is the user-visible
constant strings that cannot be translated. This reason accounts for
1 false positive in Squirrel Mail (which is the trademark ‚ÄúSquir-
rel Mail‚Äù itself), and 6 false positives in Lime Survey, which are
user-visible SQL queries. The third reason is some small PHP
chips inside static HTML texts such as <div name=<?php echo
"div".$i?> > . Since our approach considers only the content in-
side the PHP code, we cannot decide whether "div" is inside a tagor not. We conservatively consider such constant strings as need-
to-translate and result in 2 false positives in Mrbs. In fact, such
false positives can be resolved by parsing the static HTML to add
the context for each portion of PHP code.
Third, for each subject, our approach is able to locate some con-
stant strings that the developers did not externalize in the subse-
quent internationalized version but we veriÔ¨Åed as need-to-translate.
The developers may have either missed them or did not externalize
them at that time due to time or workload limit. In both cases, lo-
cating such strings should be helpful for the developers to obtain a
version with better quality of internationalization earlier. In total,
our approach locates 99 such strings in the three subjects (5 in Lime
Survey, 74 in Squirrel Mail, and 20 in Mrbs shown in the brackets
of the last column of Table 2). Among the 99 strings, 62 (5 in Lime
Survey, 44 in Squirrel Mail, and 13 in Mrbs) were externalized and
translated in a later version and 37 still remained hard-coded in all
the later versions or were removed due to modiÔ¨Åcations other than
internationalization.
One example of not-externalized constant strings is presented in
the following code portion (in ‚Äúsmtp.php‚Äù of Squirrel Mail).
...
switch ($err_num) {
...
case 502:$message = "Command not implemented";
$status = 0;
break;
...
}
...
echo "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;<B>Reason: </B>$message<BR>";
...
This code portion outputs an error message "Command not
implemented" to the generated web page, and then the error mes-
sage is shown on the browser. However, the developer of Squirrel
Mail did not externalize this string until three years later (Jan 2003).
6.5.2 RQ2: Effectiveness of the Two New Techniques
In Table 3, the rows where subject names are marked with ‚ÄúBS‚Äù
show the results of using the baseline approach (i.e., our previous
approach [17]) on the three subjects, and the rows where subject
names are marked with ‚ÄúBS+O‚Äù show the results of using the base-
line approach together with only the Ô¨Årst technique (i.e., locating
outside-tag constant strings). After a close examination of Table 3,
we have the following four main observations concerning the ef-
fectiveness of the two new techniques.
First, when used for locating need-to-translate constant strings in
web applications, our previous approach produces large numbers of
false positives. Typically, the numbers of false positives are much
larger than the numbers of need-to-translate constant strings. For
Squirrel Mail, the number of false positives is almost three times as
large as the number of need-to-translate constant strings. This ob-
servation indicates that, without further distinguishing user-visible
constant strings from non-visible constant strings, our previous ap-
proach is not suitable for web applications.
Second, our Ô¨Årst technique (i.e., locating outside-tag constant
strings) is able to dramatically reduce the false positives. After
comparing the rows where subject names are marked with ‚ÄúBS+O‚Äù
and ‚ÄúBS‚Äù for each subject, we Ô¨Ånd that our Ô¨Årst technique reduces
380 of 398 false positives in Lime Survey, 526 of 534 false posi-
tives in Squirrel Mail, and 98 of 100 false positives in Mrbs, respec-
tively. This observation conÔ¨Årms that our Ô¨Årst technique is highlyeffective in locating need-to-translate constant strings in web ap-
plications. However, our Ô¨Årst technique cannot reduce all the false
positives. We have analyzed the reasons of those false positives in
Section 6.5.1.
Third, our second technique (i.e., locating need-to-translate con-
stant strings inside input tags) is able to locate some need-to-translate
strings without inducing extra false positives. In particular, after
comparing the rows where subject names are marked with ‚ÄúAll‚Äù
and ‚ÄúBS+O‚Äù, we obtain the numbers of new need-to-translate con-
stant strings located by our second technique (i.e., 21 for Lime
Survey, 12 for Squirrel Mail, and 0 for Mrbs). This observation
indicates that our second technique is also effective.
Fourth, the combination of our two new techniques accurately
tackles the challenges that we have faced when adapting our pre-
vious approach for web applications. After comparing the rows
where subject names are marked with ‚ÄúAll‚Äù and ‚ÄúBS‚Äù, we Ô¨Ånd that
none of the false negatives produced by our approach is due to our
two new techniques. That is to say, if we consider the evaluation of
only the two new techniques, the combination of the two techniques
is able to Ô¨Ånd all the need-to-translate constant strings among the
candidate constant strings located by our previous approach with
less than 10% false positives.
6.6 Threats to Validity
In our evaluation, the threats to internal validity mainly lie in the
way we veriÔ¨Åed constant strings not externalized in the subsequent
internationalized version to be need-to-translate strings. Since the
later versions involve various modiÔ¨Åcations for other purposes, it
is error-prone to verify constant strings as need-to-translate in ver-
sions later than the version immediately after internationalization.
Furthermore, the manual veriÔ¨Åcation of constant strings not exter-
nalized in any version as need-to-translate may be prone to acciden-
tal mistakes or personal perspectives to the notion of being ‚Äúneed-
to-translate‚Äù. To reduce these threats, for each subject, we exam-
ined all these strings in the later versions carefully, executed the
internationalized subject to see whether they appear on the browser
and decided whether they are not understandable to a user who is
not familiar with English.
The main threats to external validity lie in that the three subjects
used in our empirical study are all open source web applications in
PHP, and all of them are of moderate sizes (i.e., several thousand
lines of code). Furthermore, to make use of the manually exter-
nalized constant strings as golden results, we use old versions of
applications generated years ago. Therefore, it is possible that the
Ô¨Åndings of our empirical evaluation are speciÔ¨Åc to old versions of
moderate-size open-source web applications, and may not be gen-
eralized to other subjects. To reduce these threats, we plan to apply
our approach to more web applications, especially those that are
commercial, with larger code bases or using new web technologies.
7. DISCUSSION
As discussed in our previous paper [17], the conservative nature
of string analysis may induce imprecision and this imprecision may
impact the empirical results of locating need-to-translate constant
strings in web applications. However, according to our empirical
results reported in this paper, we have not found false positives due
to the preceding weakness of string analysis for locating need-to-
translate constant strings in web applications.
One important situation that our approach currently cannot han-
dle is the case where a web application dynamically generates JavaScript
code, and the generated JavaScript code, when executed by the
browser, outputs some need-to-translate strings to the generated
web page directly or outputs some need-to-translated strings by
calling APIs of JavaScript libraries. For example, our approachcurrently cannot handle Ajax web applications. It is not easy to
locate such need-to-translate strings because we need to analyze
the syntax of the generated JavaScript part without obtaining all
the possible contents of the JavaScript part. Since the JavaScript
syntax is much more complex than HTML, we may need to pro-
pose more complex adaptations to our Ô¨Çag propagation as well as
developing some new techniques to handle dynamically generated
JavaScript code.
8. RELATED WORK
To our knowledge, our work is the Ô¨Årst reported effort directly fo-
cusing on automatically locating need-to-translate constant strings
in web applications. Our previous work [17], which locates need-
to-translate strings in Java code, is the most related work. However,
when used for web applications, our previous work cannot differ-
entiate between constant strings that form HTML tags and constant
strings that are displayed on the screen.
Furthermore, there have been a couple of published books on
how to internationalize a software application [5, 16]. These books
provide guidelines on Ô¨Ånding out need-to-translate constant strings
and externalizing them, but they do not propose any approach to
perform the task automatically. On top of that, some researchers
analyzed the process of internationalization and presented issues to
be considered during the process, including the problem of locat-
ing need-to-translate strings [10, 4, 9]. However, none of them pro-
vided any automatic approach to locating need-to-translate strings.
There are also tools (e.g., GNU gettext9, Java internationaliza-
tion API10) to help developers externalize need-to-translate con-
stant strings after the developers locate them. Other tools like KBa-
bel11help developers edit and manage resource Ô¨Åles (called PO
Ô¨Åles) containing externalized constant strings. These tools cannot
locate need-to-translate constant strings, but can be used together
with our approach to improve the efÔ¨Åciency of internationalization.
String analysis and string-taint analysis are recent improvements
of traditional static data-Ô¨Çow analysis [11]. Christensen et al. [2]
Ô¨Årst proposed string analysis, which is an approach for obtaining
possible values of a string variable. Then string analysis is widely
used in checking dynamically generated SQL queries. Gould et
al. [6] used a string-analysis-based approach to check the correct-
ness of dynamically generated query strings. Halfond and Orso [8]
used string analysis to detect and neutralize SQL injection attacks.
Minamide [15] Ô¨Årst used string analysis on web applications. He
proposed to simulate string operations in the extended CFG with
FSTs, and implemented a string analyzer for PHP code to predict
dynamically generated web pages. Based on Minamide‚Äôs work,
Xie and Aiken [21] proposed a technique on detecting SQL injec-
tion vulnerabilities in scripting languages. Recently, Wassermann
and Su developed string-taint analysis [18] based on Minamide‚Äôs
work and applied this analysis on detecting cross-site scripting vul-
nerabilities [19]. Recently, Wassermann and Su [20] developed an
approach to generating test cases for security vulnerabilities and
Kieyzun et.al. [12] further improved their approach. Compared to
these approaches, we apply string-taint analysis on locating need-
to-translate string candidates, and developed Ô¨Çag-propagation algo-
rithms to Ô¨Ånd need-to-translate strings among the candidates.
Like string-taint anlysis, our Ô¨Çag-propagation algorithms also
propagate information on the CFG generated by string analysis.
However, our Ô¨Çag propagation differs from taint propagation in
three main aspects. First, the purpose of Ô¨Çag propagation is differ-
ent from that of taint propagation. Taint propagation aims to Ô¨Ånd all
9http://www.gnu.org/software/gettext/manual/gettext.html
10http://java.sun.com/docs/books/tutorial/i18n/index.html
11http://kbabel.kde.org/the non-terminals that may contain a taint (i.e., non-terminals that
may deduce to a terminal with taint), while Ô¨Çag propagation aims to
Ô¨Ånd the preceding or following terminals of a given terminal with
some conditions (e.g., the nearest, non-space, before or after certain
character values like ‚Äò >‚Äô). Second, taint propagation requires only
one taint (similar to the Ô¨Çags in Ô¨Çag propagation), which may be of
two or more taint values, while our algorithms require at least two
Ô¨Çags, which represent the left-most point and the right-most point
of a variable. Third, taint propagation has only one propagation
rule to propagate all the taints at the right hand side of a production
to the left hand side of the production, while our algorithms have
four propagation rules to make sure that Ô¨Çags can be propagated
through neighboring variables, variable deductions, and terminals.
Another area related to our approach is machine translation [14].
Machine translation has been used in translating web pages in some
products (e.g., google translation12, babel13). If the technique of
machine translation is advanced enough to accurately translate the
generated web pages in real time, the internationalization and local-
ization of web applications may become unnecessary. However, it
may take a long way to achieve this goal and almost all web appli-
cations are using internationalization and localization now. Addi-
tionally, the technique of machine translation can also be integrated
in our approach to help developers translate the need-to-translate
strings after our approach identiÔ¨Åes them.
9. CONCLUSION AND FUTURE WORK
In this paper, we identify signiÔ¨Åcant challenges in automatically
locating need-to-translate constant strings in web applications. To
address the challenges, we propose two techniques to distinguish
two types of user-visible constant strings among all the constant
strings that may go to the generated HTML texts. We evaluated our
approach on three real-world open source web applications: Lime
Survey, Squirrel Mail, and Mrbs. The empirical results demon-
strate that, as our approach is able to accurately distinguish visible
strings from non-visible strings, our approach is effective for locat-
ing need-to-translate constant strings in web applications.
We plan to extend our approach in three ways. First, to reduce
the previously mentioned threats to the validity of our empirical
evaluation, we plan to conduct experiments on larger and newer
commercial web applications.
Second, we plan to capture the string relations missed by the cur-
rent PHP analyzer and reduce the false negatives in future work. As
stated in Section 6.5, integrating an HTML parser in our approach
enables our approach to handle small pieces of PHP code inside
static HTML texts. Therefore, we plan to integrate such a parser
in our approach in near future. We also plan to integrate dynamic
analysis in our approach to reduce false positives.
Third, our approach currently works only for PHP web applica-
tions. We plan to extend it for web applications written in other lan-
guages (e.g., JSP). Since JSP web applications contain Java code,
we need to integrate our approach with our previous approach for
locating need-to-translate constant strings in Java code.
Acknowledgment
The authors from Peking University are sponsored by the National
Basic Research Program of China (973) No. 2009CB320703, the
High-Tech Research and Development Program of China (863) No.
2007AA010301 and No. 2006AA01Z156, the Science Fund for
Creative Research Groups of China No. 60821003, and the Na-
tional Science Foundation of China No. 90718016. Tao Xie‚Äôs work
is supported in part by NSF grants CNS-0720641, CCF-0725190,
and Army Research OfÔ¨Åce grant W911NF-08-1-0443.
12http://translate.google.com/
13http://babel.yahoo.com/10. REFERENCES
[1]C.-P. Bezemer, A. Mesbah, and A. van Deursen. Automated
security testing of web widget interactions. In ESEC/FSE ,
pages 81‚Äì90, 2009.
[2]A. Christensen, A. M√∏ller, and M. Schwartzbach. Precise
analysis of string expressions. In SAS, pages 1‚Äì18, 2003.
[3]R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and
K. Zadeck. EfÔ¨Åciently computing static single assignment
form and the control dependence graph. ACM Trans. on
Prog. Lang. and Sys. , 13(4):451‚Äì490, October 1991.
[4]V. Dagiene and R. Laucius. Internationalization of open
source software: framework and some issues. In Intl. Conf.
on Info. Tech.: Research and Edu. , pages 204‚Äì207, 2004.
[5]B. Esselink. A Practical Guide to Software Localization: For
Translators, Engineers and Project Managers . John
Benjamins, 2000.
[6]C. Gould, Z. Su, and P. T. Devanbu. Static checking of
dynamically generated queries in database applications. In
ICSE , pages 645‚Äì654, 2004.
[7]W. Halfond and A. Orso. Automated identiÔ¨Åcation of
parameter mismatches in web applications. In FSE, pages
181‚Äì191, 2008.
[8]W. G. J. Halfond and A. Orso. AMNESIA: Analysis and
monitoring for neutralizing SQL-injection attacks. In ASE,
pages 174‚Äì183, 2005.
[9]P. A. V. Hall. Decision Support Systems for Sustainable
Development . Springer US, 2002.
[10] J. Hogan, C. Ho-Stuart, and B. Pham. Key challenges in
software internationalisation. In Australian Computer
Science Workshops Frontiers , pages 187‚Äì194, 2004.
[11] J. Kam and J. Ullman. Global data Ô¨Çow analysis and iterative
algorithms. Journal of the ACM (JACM) , 23(1):158‚Äì171,
January 1976.
[12] A. Kieyzun, P. J. Guo, K. Jayaraman, and M. D. Ernst.
Automatic creation of SQL injection and cross-site scripting
attacks. In ICSE , pages 199‚Äì209, 2009.
[13] A. Koesnandar, S. G. Elbaum, G. Rothermel, L. Hochstein,
C. ScafÔ¨Ådi, and K. T. Stolee. Using assertions to help
end-user programmers create dependable web macros. In
FSE, pages 124‚Äì134, 2008.
[14] A. Lopez. Statistical machine translation. ACM Comput.
Surv. , 40(3):1‚Äì49, 2008.
[15] Y. Minamide. Static approximation of dynamically generated
web pages. In WWW , pages 432‚Äì441, 2005.
[16] E. Uren, R. Howard, and T. Perinotti. Software
Internationalization and Localization: An Introduction . Van
Nostrand Reinhold, 1993.
[17] X. Wang, L. Zhang, T. Xie, H. Mei, and J. Sun. Locating
need-to-translate constant strings for software
internationalization. In ICSE , pages 353‚Äì363, 2009.
[18] G. Wassermann and Z. Su. Sound and precise analysis of
web applications for injection vulnerabilities. In PLDI , pages
32‚Äì41, 2007.
[19] G. Wassermann and Z. Su. Static detection of cross-site
scripting vulnerabilities. In ICSE , pages 171‚Äì180, 2008.
[20] G. Wassermann, D. Yu, A. Chander, D. Dhurjati, H. Inamura,
and Z. Su. Dynamic test input generation for web
applications. In ISSTA , pages 249‚Äì260, 2008.
[21] Y. Xie and A. Aiken. Static detection of security
vulnerabilities in scripting languages. In USENIX Security
Symposium , pages 179‚Äì192, 2006.