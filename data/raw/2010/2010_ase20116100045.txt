Scalable and Precise Symbolic Analysis for
Atomicity Violations
Malay K. Ganai
NEC Labs America, Princeton, USA
malay@nec-labs.com
Abstract—We present a symbolic testing tool BEST for ﬁnd-
ing atomicity violations. We automatically infer and gener ate
potential atomicity properties from an observed run of a mul ti-
threaded program, and use precise modeling and constraint-
based symbolic search to ﬁnd atomicity violating schedules in the
most generalization of the observed run. We focus mainly on t he
tool scalability by devising various simpliﬁcation steps t o reduce
theformula andthe search space byorders-of-magnitude.To that
effect, we also introduce a new notion of atomicity that is us eful
and simple to check. We demonstrate the effectiveness of the
combined techniques on several public C/C++/Java benchmar ks
in ﬁnding known/unknown atomicity bugs.
I. INTRODUCTION
The growth of cheap and ubiquitous multi-processor sys-
tems and concurrent library support are making concurrent
programming very attractive. However, veriﬁcation of mult i-
threaded concurrent systems remains a daunting task espe-
cially due to complex and unexpected interactions between
asynchronous threads.
Concurrencybugsoftenariseduetoatomicityviolation,i. e.,
non-atomic execution of code regions that are intended to be
atomic. Atomicity is a semantic correctness of the concurre nt
programs,and is meant to capturethe programmersintention s.
A recent study [1] of 105 real concurrency bugs depicts
the following distribution: Order violation (22%), Deadlo cks
(30%), and Atomicity violation (45%). On one hand atomicity
violation is one of the most commonly occurring causes for
concurrency related failures, and on the other hand it is one
of the hardest correctness criteria to infer or specify prec isely,
as it requires “guessing” user-intentions.
In this paper, we focus speciﬁcally on ﬁnding and checking
atomicity violation. There have been efforts in the past to
specify atomicity violation conditions concisely, althou gh for
speciﬁc notions of atomicity such as method atomicity [2],
view/conﬂict atomicity [3], atomic-set atomicity [4], [5] ,
commit-atomicity [6], and causal atomicity [7]. In [4] a set of
eleven data-access scenarios (interleavings) (over singl e and
dual variables) have been identiﬁed that completely specif y
atomic-set atomicity violation.
Even with marked atomic boundaries, checking atomicity
violation is a challenging task due to (a) large interleavin g
search space, (b) non-trivial violation condition that may
involve multiple-variable shared accesses and multiple in -
terleavings, and (c) various notions of atomicity. The same
bug study [1] shows that 34% of the examined non-deadlock
concurrency bugs involve multiple variables, and remainin g
66% concurrencybugs involvesingle variable.Although som eefforts [8]–[13] were made, there are still no good tools to
address such multi-variable atomicity bugs.
To expose a concurrency bug, a test case should not only
provideabug-exposinginput,butalsoprovideabug-trigge ring
execution interleaving. Unfortunately, testing a program for
every interleaving on every test input is often practically
impossible. Even for a given concrete trace, there can be
exponentiallymanyalternateinterleavings(i.e.,genera lization)
of the observed events in the trace.
To overcome the issue of exponential interleaving space,
the current testing methodology is focused on exploring a
“meaningful” subset of thread interleaving for a given test
input. Tools such as AtomFuzzer [8], CTrigger [10] attempt
to explore low-probability interleavings using random sle ep
delays. Although that helps reduce the set, the unexplored s et
may still be exponential and may include many errors. To
overcome the issue, tools such as jPredictor [9], HAVE [11],
and PENELOPE [13] predict atomicity violation in a general-
ization of the observedtrace. However,the used generaliza tion
is too restrictive (i.e., may miss errors), predictionis im precise
(i.e., may predict spurious schedules due to data abstracti on),
and search method is enumerative.
To address the above mentioned issues, we propose a tool
BEST (B inary instrumentation-based E rror-directed S ymbolic
Testing) for ﬁnding atomicity violation in the most general-
ization of an observed trace. Speciﬁcally, it
•misses no errors by using a complete generalization,
•reduces spurious schedules using precise modeling of data
and synchronization primitives,
•predictsatomicityviolationbasedon constraint-basedsym-
bolic(non-enumerative) search,
•handles various notions of atomicity,
•infers atomicity properties automatically , and
•dynamically instruments unmodiﬁed binary (of the pro-
gram) for recording events, and does not rely on source
code availability.
BEST Framework: Overview
The main components of the framework, as shown in
Figure 1, are divided in four stages: (I) record trace events
and build a concurrent trace model (CTM), (II) simplify
CTM by reducing transitions and context switches, (III) inf er
and generate atomicity properties, and (IV) ﬁnd atomicity
violation with property-speciﬁc symbolic analysis.978-1-4577-1639-3/11/$26.00 c2011 IEEE ASE 2011, Lawrence, KS, USA123
/g28/g121/g28/g18/g104/g100/g28 /g4/g69/g24
/g90/g28/g18/g75/g90/g24/g17/g104/g47/g62/g24/g18/g75/g69/g18/g104/g90/g90/g28/g69/g100
/g100/g90/g4/g18/g28 /g68/g75/g24/g28/g62 /g894/g18/g100/g68/g895
/g38/g47/g69/g24/g4/g115
/g894/g24/g28/g18/g47/g94/g47/g75/g69 /g87/g90/g75/g18/g28/g24/g104/g90/g28 /g895
/g39/g28/g69/g28/g90/g4/g100/g28 /g4/g115/g3/g94/g18/g44/g28/g24/g104/g62/g28/g94/g28/g69/g18/g75/g24/g28 /g87/g90/g75/g87/g28/g90/g100/g122
/g4/g115/g3/g18/g75/g69/g24/g47/g100/g47/g75/g69/g94
/g28/g69/g18/g75/g24/g28 /g94/g18/g44/g28/g24/g104/g62/g28/g94
/g38/g28/g4/g94/g47/g17/g62/g28 /g1085/g3/g90/g28/g87/g90/g28/g94/g28/g69/g100/g4/g100/g47/g115/g28/g100/g4/g90/g39/g28/g100 /g17/g47/g69/g4/g90/g122 /g920
/g100/g28/g94/g100/g44/g4/g90/g69/g28/g94/g94
/g68/g28/g90/g39/g28
•/g68/g28/g90/g39/g28 /g62/g75/g18/g4/g62 /g100/g90/g4/g69/g94/g47/g100/g47/g75/g69/g94
/g62/g75/g18/g60/g94/g28/g100 /g920/g3/g44/g17/g3 /g4/g69/g4/g62/g122/g94/g47/g94
•/g28/g62/g47/g68/g47/g69/g4/g100/g28 /g47/g69/g38/g28/g4/g94/g47/g17/g62/g28 /g18/g75/g69/g100/g28/g121/g100
/g94/g116/g47/g100/g18/g44/g28/g94
/g87/g75/g90/g3/g4 /g69/g4/g62/g122/g94/g47/g94
•/g28/g62/g47/g68/g47/g69/g4/g100/g28 /g90/g28/g24/g104/g69/g24/g4/g69/g100
/g18/g75/g69/g100/g28/g121/g100 /g94/g116/g47/g100/g18/g44/g28/g94/g47/g69/g38/g28/g90 /g4/g100/g75/g68/g47/g18 /g90/g28/g39/g47/g75/g69/g94
•/g104/g94/g28 /g24/g28/g17/g104/g39 /g47/g69/g38/g75 /g856/g3/g894/g75/g17/g58/g24/g104/g68/g87 /g895
•/g104/g94/g28 /g94/g75/g104/g90/g18/g28 /g882/g62/g47/g69/g28 /g87/g90/g75/g121/g47/g68/g47/g100/g122
/g87/g90/g104/g69/g28 /g4/g100/g75/g68/g47/g18 /g90/g28/g39/g47/g75/g69/g94
•/g90/g28/g68/g75/g115/g28 /g493/g493/g87/g90/g75/g115/g28/g24 /g859/g859/g3/g4/g100/g75/g68/g47/g18
•/g90/g28/g68/g75/g115/g28 /g493/g493/g75/g17/g94/g28/g90/g115/g28/g24 /g859/g859/g3/g69/g75/g69/g882/g4/g100/g75/g68/g47/g18
/g39/g28/g69/g28/g90/g4/g100/g28 /g4/g100/g75/g68/g47/g18/g47/g100/g122 /g87/g90/g75/g87/g28/g90/g100/g47/g28/g94
•/g18/g4/g104/g94/g4/g62 /g4/g100/g75/g68/g47/g18/g47/g100/g122 /g894/g18/g4/g895/g3/g853/g3/g75/g90
•/g18/g4/g104/g94/g4/g62 /g68/g104/g100/g104/g4/g62 /g4/g100/g75/g68/g47/g18/g47/g100/g122 /g894/g18/g68/g4/g895/g94/g28/g62/g28/g18/g100 /g4/g69
/g4/g100/g75/g68/g47/g18/g47/g100/g122 /g87/g90/g75/g87/g28/g90/g100/g122
/g87/g90/g75/g87/g28/g90/g100/g122 /g94/g62/g47/g18/g47/g69/g39
/g68/g28/g90/g39/g28
/g894/g87/g28/g90 /g87/g90/g75/g87/g28/g90/g100/g122 /g895
/g87/g75/g90/g3/g4 /g69/g4/g62/g122/g94/g47/g94
/g894/g87/g28/g90 /g87/g90/g75/g87/g28/g90/g100/g122 /g895
/g94/g100/g4/g39/g28/g47/g47/g855/g3/g94/g47/g68/g87/g62/g47/g38/g122 /g18/g100/g68 /g94/g100/g4/g39/g28/g47/g47/g47/g855/g3/g47/g69/g38/g28/g90/g90/g47/g69/g39 /g4/g100/g75/g68/g47/g18/g47/g100/g122 /g94/g87/g28/g18/g47/g38/g47/g18/g4/g100/g47/g75/g69 /g94/g100/g4/g39/g28/g47/g115/g855/g3/g87 /g90/g75/g87/g28/g90/g100/g122 /g882/g94/g87/g28/g18/g47/g38/g47/g18 /g94/g122/g68/g17/g75/g62/g47/g18 /g4/g69/g4/g62/g122/g94/g47/g94/g87/g90/g75/g87/g28/g90/g100/g122 /g882/g94/g87/g28/g18/g47/g38/g47/g18 /g94/g47/g68/g87/g62/g47/g38/g47/g18/g4/g100/g47/g75/g69 /g28/g69/g18/g75/g24/g28 /g920/g3/g94/g75/g62/g115/g28/g116/g47/g100/g69/g28/g94/g94 /g115/g47/g28/g116/g28/g90 /g894/g44/g100/g68/g62/g895/g94/g100/g4/g39/g28/g47/g855/g3/g100/g90/g4/g18/g28 /g39/g28/g69/g28/g90/g4/g62/g47/g127/g4/g100/g47/g75/g69/g4/g115/g3/g94 /g18/g44/g28/g24/g104/g62/g28/g94/g90/g28/g87/g62/g4/g122/g94/g100/g4/g39/g28/g115/g855/g3/g24 /g28/g17/g104/g39 /g100/g90/g4/g18/g28/g94
Fig. 1. BEST Architecture
Stage I. During an execution of a multi-threaded
program under a test harness, we instrument the binary
dynamically (using PIN [14]) to record various events
such as synchronization, and memory accesses. From these
recorded events, we construct a concurrent trace model
(CTM). Such a model can be viewed as generalizer of the
observed trace. For practical reasons, we do not record
all local accesses such as stack reads/writes. In such cases ,
CTM would bean abstractionof the actualprogramexecution.
Stage II. We perform following steps to simplify CTM. We
ﬁrstidentifylocal(i.e.,unshared)variablesandmergeth elocal
transitions. This step gives a reduction of up to 3X in the
number of transitions.
We use lockset and happen-before(HB) analysis to identify
the lock protected transitions and causal transitions such as
fork/join, and eliminate infeasible context switches. Thi s step
gives a reduction of up to two orders-of-magnitude in the
number of context switches.
We then use a POR analysis [15] to eliminate context
switches corresponding to redundant interleavings (i.e., which
are equivalent [16] to admitted interleavings.) This step g ives
up to three orders-of-magnitude additional reduction in th e
number of context switches over lockset/HB analysis.
Stage III . On a simpliﬁed CTM, we infer atomic regions (that
may involve multiple variable accesses) based on code layou t.
We prune out those regions which are observed to be not
conﬂict-serializable (in the given trace), and those which are
“proved atomic” (using stage II results). From the remainin g
regions, we derive atomicity properties.
We introduce causal mutual atomicity (CMA) which is
found to be more useful (in ﬁnding more violations) and
simpler to check (more scalable) than the other notions such
as causal atomicity (CA) [7].
Stage IV. For each derived atomicity property (CA or CMA),
we ﬁrst carry out property preserving (i.e., sound) slicing of
the CTM (obtained in stage II). This is followed by soundsimpliﬁcation steps such as merging and POR analysis on the
sliced CTM. These steps give additional orders-of-magnitu de
reduction in the number of context switches (more for a CMA
than a CA property).
We devise an algorithm FindAV for ﬁnding and checking
atomicity violation (AV) precisely. For a given atomicity
property, we encode the AV condition along with a symbolic
set of schedules (feasible in the sliced CTM) in a quantiﬁer-
free SMT (Satisﬁability Modulo Theory) decision problem.
We use a soundandcomplete decision procedure to ﬁnd a
feasible schedule violating the atomicity property, i.e., if and
only ifone exists in the sliced CTM w.r.t. the property.
As CTM is abstraction of the actual program execution,
the AV schedules although feasible in CTM may be spurious,
i.e., not replayable. Currently, we suppress reporting suc h
spurious schedules,1although we did not see such a case in
our experimentation (due to precise modeling).
Contributions . Although several runtime tools for predicting
atomicity violation exists, namely, jPredictor [9], HAVE [ 11],
SideTrack [12], CTrigger [10], and PENELOPE [13], our tool
provides a unique combination of the following:
•Generalization : Our scope of generalization is complete.
There is no restriction on admitted schedules such as
nested locking, race-freedom, and matched wait/notify.
•Precision :Ourmodelingofsynchronizationanddatapath
variables is precise. Our symbolic encoding captures all
and only feasible schedules.
•Scalability : Our POR-based simpliﬁcation steps reduces
both the size of decision problems and the search
space by orders-of-magnitude. Our prediction is based
on constraint-based symbolic search, and avoids explicit
enumeration of a prohibitively large set of schedules.
•Flexibility : Our atomicity checking algorithm handles
various notions of atomicity violation.
Evaluation . We evaluate various reduction strategies enabling
1Alternately, one can re-execute the binary with the non-rep layable AV
schedule, build a different CTM, and then apply stages I-IV. We keep these
as a future extension to our work.124the scalability of the symbolic analysis. We also evaluate t he
combined effect of formula size simpliﬁcation, interleavi ng
space reduction, new notion of atomicity, and decision proc e-
dure in ﬁnding atomicity bugs.
II. RELATEDWORK
Runtime concurrency testing techniques can be broadly
classiﬁed into fuzzing-based [8], [10], [18]–[20], and trace-
based predictive analysis [9], [11]–[13], [17], [21].
Fuzzing-based tools such as AtomFuzzer [8] and CTrig-
ger [10] focus on improvingthe interleaving coverageof som e
“meaningful” set. Speciﬁc instances of atomicity (such as [ 4])
are integrated into a test harness as monitors. The goal is
to trigger the bug-monitor by explicitly searching over the
interleaving space, either exhaustively, or using random s leep
delays between atomic accesses and/or synchronization poi nts
that have low probability of being interleaved.
The trace-based predictive analysis tools detect and predi ct
program errors from an observed trace, either using ofﬂine
search [9], [11], [13], [21] or using online analysis [12].
The trace-based predictive tools such as HAVE [11] and
PENELOPE [13] suffer from generating many false warnings
due to abstraction of program data and imprecise handling of
synchronization primitives such as semaphores. Some other
predictive tools such as jPredictor [9], and SideTrack [12] can
miss real violations due to restricted generalization (res tricted
to causal models) of the observed trace. Besides, these anal y-
sis [9], [12] do not produce a concrete execution exhibiting a
violation.
Precise runtime analysis [21], [22] overcome above men-
tioned issues by searching for violations in all feasible in -
terleavings of the observed trace, and thereby, report a tru e
violation if and only if one exists. The main focus is to reduc e
false alarms although at increased complexity. There are tw o
types of precise runtime analysis used for ﬁnding concurren cy
bugs, i.e., exploration-based (non-symbolic) runtime ana lysis
such as dynamic model checking [22], and satisﬁability-bas ed
symbolic analysis [21], [23].
In dynamicmodel checking [6], [24],for a given test input,
systematic exploration of a program under all possible thre ad
interleavings is performed by explicit execution. Althoug h
partial order reduction techniques (POR) [22] reduce the se t
of necessary interleavings to explore, the reduced set ofte n
remains prohibitively large.
Trace-based symbolic approaches such as [21] use SMT-
based encoding and precise modeling of trace events. These
approaches were demonstrated over short traces, not beyond
a few hundred trace events.
We compare our tool vis-a-vis a few representative runtime
tools[9]–[13]foratomicityviolationassummarizedinTab leI.
Outline: The rest of the paper is outlined as follows. In Sec-
tion III, we provide necessary backgroundand used notation s.
In Section IV, we present CTM and trace generalization. We
discuss automatic inference of atomic regions in Section V;
introduce causal mutual atomicity and generation of atomic ity
properties in Section VI; and POR-based simpliﬁcation in
Section VII. We discuss FindAV algorithm in Section VIII;followed by experiments in Section IX, and conclusion in
Section X.
III. BACKGROUND
A multi-threaded concurrent program Pcomprises a set of
Nthreads and a set of shared variables, some of which such
as locks are used for synchronization. Let Mi(1≤i≤N)
denote a thread represented by a control and data ﬂow graph
of the sequential program it executes. For each Mi, letVibe
a set of local variables, Cibe a set of control states, and pci
denote its thread program counter taking values from Ci. Let
Vbe a set of (global) shared variables. Let Sbe the set of
global states of the system, where a state s∈ Sis a valuation
of all local and global variables, and thread program counte rs.
Athreadtransition tisa4-tuple /an}bracketle{tc, g, u, c′/an}bracketri}htthatcorresponds
to a thread Mi, where c, c′∈Cirepresent the control states of
Mi,gis an enabling condition (or guard) deﬁned on Vi∪ V,
anduis a set of update assignments of the form v:=exp
where variable vand variables in expression expbelong to
the set Vi∪ V. Let tid(t)denote the corresponding thread of
the transition t. We assume each transition tis atomic, i.e.,
uninterruptible.
Aschedule of the concurrent program Pis an interleaving
sequence of thread transitions ρ=t1· · ·tk. An event eoccurs
when a unique transition tis ﬁred, which we refer to as the
generator for that event, and denote it as t=gen(P, e). Arun
(or concrete trace) σ=e1· · ·ekof a concurrent program Pis
an ordered sequence of events, where an event eicorresponds
to ﬁring of a unique transition ti=gen(P, ei). Firing of
generator transitions may correspond to instances of the sa me
thread transition when ﬁred in a thread loop. In the sequel, w e
use a thread transition to refer to such an instance.
Given a run σ=e1· · ·ekfor a program Pwe say
eihappens-before ej, denoted as ei≺ejifi < j. Let
t=gen(P, e)andt′=gen(P, e′). We say t≺t′iffe≺e′.
For some σ, ife≺e′andtid(t) =tid(t′), we say e≺poe′
andt≺pot′, i.e., the events and the transitions are in thread
program order . If t≺t′always and tid(t)/ne}ationslash=tid(t′), we
refer to such a relation as must happen-before (or must-HB,
in short), and denote it as t≺HBt′. We observe such must-
HB relation during fork/join. In the sequel, we restrict the use
of must-HB relation to inter-thread events/transitions on ly.
Dependency Relation ( D):Given a set Tof transitions, we
say a pair of transitions (t, t′)∈T×Tis dependent, i.e.
(t, t′)∈ Diff one of the following holds (a) t≺pot′, (b)
t≺HBt′, (c) (t, t′)is conﬂicting, i.e., accesses are on the
sameglobalvariable,andatleast oneofthemisawriteacces s.
If(t, t′)/ne}ationslash∈ D, we say the pair is independent .
Equivalency Relation ( ≃):We say two schedules ρ1=
t1· · ·ti·ti+1· · ·tnandρ2=t1· · ·ti+1·ti· · ·tnare equivalent
if(ti, ti+1)/ne}ationslash∈ D. An equivalence class of schedules can be
obtained by iteratively swapping the consecutive independ ent
transitions in a given schedule. A representative schedule
refers to one of such an equivalence class.
Atransaction is an uninterrupted sequence of transitions of
a particular thread as observed in a system execution.
We saya transaction(ofa thread)is atomicw.r.t.a schedule,
if the corresponding sequence of transitions are executed125TABLE I
COMPARING TOOLS FOR PREDICTING ATOMICITY VIOLATIONS
Features jPredictor [9]HAVE[11] SideTrack [12] CTrigger [10] PENELOPE [13] BEST(this work)
(ICSE’08) (FASE’09) (PADTAD’09) (ASPLOS’09) (FSE’10) (2011)
Language Java Java Java C/C++ Java C/C++/Java
Instrumentation Bytecode Source Bytecode Dynamic binary Bytecode Dynamic binary
Prediction Ofﬂine Ofﬂine Online Online Ofﬂine Ofﬂine
Generalization
scopeWithin causal runs. Beyond unobserved
runs.Within causal runs,
race-free programsLow-probability unex-
plored interleavings.Beyond causal runs
(incomplete).Beyond causal runs
(complete).
Atomicity
property11 access patterns [4]
(single & dual vars)Conﬂict atomicity pattern used is “thread
acquires same lock
twice within a
transaction.”5 access patterns [4]
(single var) with “in-
ferred” low probability
of occurrences.5 access patterns [4]
(single var).Causal& Causalmutual
atomicity (infers atomic
regions automatically).
Schedule gen-
erationAll causal schedules
are explicitly generated
with data abstraction,
and are tested with
monitors.Static summary infor-
mation are used to spec-
ulate executions, which
are analyzed for poten-
tial violation.Runtime information is
used and analyzed for
feasible violation.Random time delays are
inserted to explore low
probability interleaving.Potential violating
schedules are generated
(assuming nested
locking [17]) with data
abstraction.Potential violating
schedules are generated
using a decision
procedure with precise
modeling.
False negative
(miss error
in generaliza-
tion)?Yes. Causal model is
too restrictive.No. Yes. Causal model is
too restrictive.Yes. Search is ad-hoc
and is based on “ran-
dom” delays at chosen
locations.No (assuming matched
wait/notify & nested
locking)No.
False positive
(spurious)
generated?Yes. Due to partial
recording and data
abstraction.Yes. Due to over-
approx. static summary
of schedules.No. No. Yes, due to partial
recording and data
abstraction.Yes, due to partial
recording, but fewer
occurrences due to
precise modeling.
Inherent limi-
tationExplicit enumeration,
data abstractionData abstraction, no
replay-able schedules.Limited generalization,
assumes race-freedom,
no semaphores.Hit-and-trial, not sys-
tematic.Nested locking, no
semaphores, data
abstraction.Size of decision prob-
lem.
uninterrupted in the schedule, i.e., without an interleavi ng
(context-switch) of another thread in-between.
When a transaction is “expected” (speciﬁed explicitly or
inferred implicitly) to be executed by a thread atomically, we
refer to it as an E-transaction. We use “[′′and“]′′to denote
the beginning and ending of an E-transaction. For example,
[ti· · ·tj]denote an E-transaction starting with transition ti
and ending with transition tj, and including all transitions tk’s
such that ti≺potk≺potj.
For a given set of schedules, if a transaction is atomic w.r.t .
all the schedules in the set, we refer to it as an independent
transaction , (denoted as I-transaction) w.r.t. the set.2
Ageneralization of an observed trace is deﬁned as a set of
schedules with the same events as the observed trace but with
relaxed (i.e., re-ordered) inter-thread event order.
IV. CONCURRENT TRACEMODEL
Before we proceed further, we present an example to guide
the rest of our discussion. Consider a run σof statement
sequence s1· · ·s16of a concurrent program P, comprising
interacting threads MaandMbwith local variables aiand
bi, respectively, and shared (global) data variables X, Y, Z,
and synchronization variables S, L 1, L2. This is shown in
Figure 2(a) where threads are synchronized with lock/unlock
andwait/notify . From the run, we obtain a CTM as shown in
Figure 2(b), where a thread transition such as (2a, true, Z :=
Z+ 1,3a)(also represented as 2aZ:=Z+1→ 3a) can be viewed
as a generator of access event RW(Z)corresponding to the
atomic read and write access of the shared variable Z. We
model each synchronizationtransition as indicated in Tabl e II.
2I-transactions correspond to the observation of the system, which may
not correspond to the user intended E-transactions. Note, E-transactions are
atomicity speciﬁcation that we want to validate, whereas I-transactions are
derived from the given system under test, and are used to redu ce the search
space of symbolic analysis.Forwait(S, L 1) statement, we use the semantically equivalent
consecutive transitions wait pre(S, L 1) and wait pst(S, L 1).
A CTM can be viewed as a generalizer of the observed
trace. Alternatively, it is a generator for both the original run
σand all the other runs obtained by interleaving the generato r
transitions t′, t′of the respective events of σprovided t≺pot′
ort≺HBt′. In the sequel, we use the terms CTM, generator
andgeneralizer interchangeably.
TABLE II
MODELING OF SYNCHRONIZATION PRIMITIVES
Sync. Transition
primitives Guard Update
lock(L) L= 0 L:= 1
unlock (L) L= 1 L:= 0
wait pre(S, L) L= 1 L:= 0; S:= 0
wait pst(S, L)L= 0∧S > 0L:= 1; S:=S−1
notify (S) true S:= 1
notifyall (S) true S:=N
sem post(P) true P:=P+ 1
sem wait (P) P > 0 P:=P−1
· · · · · · · · ·
Trace Generalization . The lattice, in Figure 2(c), represents
a complete generalization of the observed trace. Each node i n
the lattice denotes a global control state, shown as a pair of
the thread local control states. An edge denotes a shared eve nt
write/read/both access(es) of global variable, labeled wi th
W(.)/R(.)/RW (.),lock(.)/unlock(.) , andwait/notify . Note,
some interleavings are infeasible due to lock/unlock , which
we crossed out (×)in the ﬁgure.
Although the observed run σdoes not show any violation,
various concurrency related bugs such as deadlock, mismatc h
wait/notify, data races, and atomicity violation can occur in its
generalization. For example, an alternate run σ1≡s6· · ·s8·
s1·s2·s12·s13·s3causes mismatched wait/notify and data
race (and atomicity violation as we see later). Another run126Thread Ma Thread Mb
s1:lock(L2);
s2:a:=++Z;
s3:X:=malloc (a);
s4:lock(L1);
s5:wait (S, L 1);
s6:lock(L1);
s7:notify (S);
s8:unlock (L1);
s9:unlock (L2);
s10:Y:= 0
s11:unlock (L1);
s12:lock(L1);
s13:Y:= &X[Z-1];
s14:lock(L2);
s15:unlock (L2);
s16:unlock (L1);lock(L2)1a
2a
3a
4a
5a1b
2b
3b
4b
5bZ=Z+1
a1=Z
X=malloc(a1)
lock(L1)lock(L1)unlock(L1)lock(L1)
S=1
6a
7a
8aunlock(L1)
S = 0
g: [S>0]
lock(L1)
S = S-1
9a
10aunlock(L2)
Y=0
11a6bb1=Z-1
b2=X
7b
8bY=b1+b2
9block(L2)
10bunlock(L2)
11bunlock(L1)unlock(L1)waitpre waitpst
“atomic”   intendednotify“atomic”   intendedta1
ta2
ta3
ta4tb1
tb2
tb3
tb4
(a) (b) (c)
Fig. 2. (a) Executed statements in a run σ, (b) Concurrent Trace Model (CTM), (c) Lattice representin g generalization of the trace σ
σ2≡s1· · ·s8·s12·s13leads to a deadlockat control state pair
(7a,8b), as shown by the square box in the lattice. (Deadlock
at(5a,8b)can also occur due to a mismatched wait/notify.)
Happen-before causality analysis [9], [12], [13], [23] do
not admit all the feasible schedules in the lattice, and ther e-
fore, leads to an incomplete generalization (i.e., can miss
real errors). The generalized model in [9], [12] admits only
schedules where the inter-thread events have the same causa l
order as in the observed trace, i.e., the same conﬂicting
read/write order. For the runningexample, all but σschedules
are rejected, and therefore, all the errors are missed. The
generalization used in [13], [23], although admits non-cau sal
runs, it rejects schedules with mismatched wait/notify suc h as
σ1. The deadlock at (5a,8b)is also missed.
A caveat in using a complete generalization is inclusion
of infeasible schedules. In our approach, however, we use
precise symbolic encoding that admits all and only schedules
of the generalization that are feasible in the CTM.
Merging and Slicing . If a transitions thas no shared access,
wemergeitwith thefollowingtransitioninthethreadprogr am
order, and rewrite the update expressions. We apply this
transformation recursively to obtain a merged CTM.
Givenaproperty φandaCTM,weobtainasoundslice(i.e.,
property preserving) that includes all the property transitions ,
i.e., transitions relevant to the property, and all the relevant
transitions , i.e., transitions on which the property transitions
depends transitively, as follows:
If a transition tis in the slice, t′is included3in the slice
provided
•t′≺pot, and tis control or data dependent on t′, or
•t′≺HBt(inter-thread happens-before), or
3Weinclude only therelevant guarded and updateexpressions ofatransition
when we say “a transition is included in the slice.”•t′, tare conﬂicting (different thread) transitions, and t
must not happen before t′i.e.,t/ne}ationslash≺HBt′.
These steps are applied recursively, followed by merging of
transitions that have no accesses or have only local accesse s.
Note, the sliced CTM so obtained include non-causal sched-
ules that are rejected by sliced causality [9], [12], [13], [ 23].
V. INFERRING ATOMICREGIONS
As noted previously[1], [20],multiple-variableaccesses are
often intended to be atomic. For example, Cpredicate expres-
sions such as S->T.c != B->T.c ; multiple update assign-
ments such as s->len++; s->buf[s->len]:=b ; and
shared accesses with-in lock/unlock regions involve multi ple-
variable accesses. We inferuser-intended atomic regions (de-
noted as E-transactions) that may involve multiple variable
accesses based on code structure. Each atomic region should
satisfy the following
•there should be at least one shared access on a non-
synchronization variable, and the ﬁrst and/or last shared
accesses should be on non-synchronization variable(s)
•the shared accesses should be within a procedure bound-
ary (may include call-sites or system calls/returns)
•the source lines corresponding to shared accesses should
be less than threshold maxDdistance (code statement
proximity)
•no happen-before transition such as thread creation/join
or wait within the region (notify is allowed)
Fromagivenbinary(assumingadebugversion)onecanuse
a gnu utility such as objdump to obtain a mapping between
processor instruction and corresponding source ﬁle and lin e
information. We use this information to tageach transition
with a tuple /an}bracketle{tfile, line #/an}bracketri}ht. Following the above guidelines,
we then inferatomicregions(i.e., E-transactions)as illustrated
with the following example.127.......
./atom.c:59
pthread_mutex_lock(l2);
.......
8048776:       e8 c1 fd ff ff call   804853c
./atom.c:61
++Z;
804877b:       a1 28 9a 04 08        mov 0x8049a28,% eax
8048780:       83 c0 01              add    $0x1,%e ax
8048783:       a3 28 9a 04 08        mov %eax,0x8049 a28
./atom.c:63
X = (char *)malloc(Z);
8048788:       a1 28 9a 04 08        mov 0x8049a28,% eax
804878d:       89 04 24              mov %eax,(%esp)
8048790:       e8 97 fd ff ff call   804852c
8048795:       a3 2c 9a 04 08        mov %eax,0x8049 a2c
./atom.c:65
pthread_mutex_lock(l1);
80487a1:       e8 96 fd ff ff call   804853c
......./g862/g4/g410/g381/g373/g349/g272/g863 /g349/g374/g410/g286/g374/g282/g286/g282
Fig. 3. Inferring atomicity with objdump using code proximity
Consider an objectdump , shown in Figure 3, for the state-
ments s1· · ·s4of our running example. The transition corre-
sponding to s1, i.e., (2a→3a)is assigned a tag /an}bracketle{tatom.c, 61/an}bracketri}ht.
Similarly, the transitions corresponding to s2, i.e., (3a→4a)
and (4a→5a)are both assigned the tag /an}bracketle{tatom.c, 63/an}bracketri}ht.
Using the above guidelines, we infer that the transitions
corresponding to statements s2ands3are expected to be
atomic. Similarly, we infer that the transitions correspon ding
tos13(ands10) are expected to be atomic. A set of inferred
atomic regions (marked in Figure 2(b)) is given by
E-AT ={tr1/bracehtipdownleft /bracehtipupright/bracehtipupleft /bracehtipdownright
[RW (Z)a· · ·W(X)a],tr2/bracehtipdownleft /bracehtipupright/bracehtipupleft /bracehtipdownright
[R(Z)b· · ·W(Y)b],tr3/bracehtipdownleft/bracehtipupright/bracehtipupleft/bracehtipdownright
[W(Y)a]}
(1)
VI. ATOMICITY SPECIFICATION
We now deﬁne the semantic correctness of a schedule (or
a run) for a given set of E-transactions, denoted as E-AT. A
schedule is serialw.r.t.E-ATif each E-transactionis executed
atomically, i.e., without interruption by other threads.
Two schedules are conﬂict equivalent iff they involve
the same actions of the same transactions and every pair of
conﬂicting actions is ordered the same way. A schedule Sis
conﬂict serializable w.r.t. E-ATifSis conﬂict equivalent to
some serial schedule.
A set E-ATisconﬂict-atomic iff every schedule of E-ATis
conﬂict-serializable w.r.t E-AT. Although conﬂict-atomicityis
very useful, it is often hard to check in practice. A set of E-
ATiscasual-atomic [7]iffeveryscheduleof E-ATisrequired
tobeconﬂict-serializablew.r.t.each E-transaction individually .
A CA property corresponds to each E-transaction in E-AT.
Causal Mutual Atomicity
Causal atomicity violation is simpler [7] to ﬁnd compared
to conﬂict atomicity violation, however, it may miss pair-w ise
atomicity violation as shown in the following example.
Consider a small example as shown in Figure 4. Let the set
E-ATbe{[RW(Z)c·R(Z)c·W(X)c],[R(X)d·R(Z)d]}. A
runρ=RW(Z)c·R(Z)c·R(X)d·R(Z)d·W(X)c, is not
conﬂict-serializable w.r.t. to the set, and thus the set E-ATis
not conﬂict-atomic.
However, one can not say E-ATisnotcausal-atomic, as ρ
is conﬂict-serializable w.r.t. each E-transaction separately. The1d 
2d d1=X 
d2=Z-1
3d 2c 
3c c1=Z 
X=malloc(c 1)
4c 1c 
Z=Z-1
Y=d 1+d 2
4d 
Fig. 4. Threads McandMdwith shared variables X and Z
runρis a serial schedulew.r.t. to [R(X)d·R(Z)d]. Its conﬂict-
equivalent equivalent schedule R(X)d·RW(Z)c·R(Z)c·
W(X)c·R(Z)dis a serial schedulew.r.t. to [RW(Z)c·R(Z)c·
W(X)c].
To detect such non conﬂict-atomicity, and yet keep the vio-
lation check simpler, we introduce a new notion of atomicity .
A set of E-transactions is causal mutually atomic (CMA, in
short) iff for each E-transaction tr, tr′, every trace of E-ATis
conﬂict-equivalent to a trace where onlytrandtr′areboth
needed to be serial w.r.t. each other.
Given a set E-AT, we obtain a set of CMA properties
where each property is a pair of E-transactions such that the
pair (a) corresponds to different threads, and (b) has at lea st
two conﬂicting transitions. For the inferred set E-AT(Eqn 1),
we obtain only one CMA property, represented as {tr1, tr2},
corresponding to the pair tr1, tr2that satisﬁes the above
criteria.
CA vs. CMA Property Checking . Intuitively, checking a
CMA property is simpler compared to a CA property, as
reasoned below: In a CMA property checking, only two
atomic regions need to be included in the property, while in
a CA property checking all the atomic regions (of different
thread)conﬂictingwiththeconcernedatomicregionneedto be
includedin the property.Consequently,a sliced CTM obtain ed
w.r.t. a CA property generally tends to be larger than that
obtained w.r.t. a CMA property; which also makes the CA
checking per property more resource intensive. We conﬁrmed
this observation in our experimental results.4
VII. MAT- BASEDPOR A NALYSIS
We discuss and highlight the important features of MAT-
based POR analysis [15] that we use to simplify the atomicity
checking. Before we proceed, we explain MAT using the
lattice of the running example (Figure 2).
Consider a transaction pair (tam1, tbm1), shown
as the shaded rectangle m1in Figure 5, where
tam1 ≡ lock(L2)a· · ·wait pre,aand tbm1 ≡
lock(L1)b· · ·unlock (L1)bare transactions of threads
MaandMb, respectively. From the control state pair
(1a,1b), the pair (7a,4b)can be reached by one of the
two representative interleavings tam1·tbm1andtbm1·tam1
(highlighted with bold arrows). Such a transaction pair
(tam1, tbm1)isatomic pair-wise as one avoids interleaving
themin-between , and hence, referred as Mutually Atomic
Transaction , MAT for short. Formally, it is deﬁned as follows:
4As one may notice that there can be more CMA properties to chec k
compared to CA properties. One can address this with task par allelization
using distributed resources.128MutuallyAtomicTransactions(MAT) [15]:Two transactions
tr=tf· · ·tlandtr′=t′
f· · ·t′
lcorresponding to thread M
andM′aremutually atomic iff except for the last pair i.e.,
tl, t′
l,allothertransitionpairsinthecorrespondingtransacti ons
are independent. All the interleavings of these transactio ns are
equivalent to interleaving either tr·tr′ortr′·tr, and thus, one
can avoid interleaving them in-between.Note, tr·tr′/ne}ationslash≃tr′·tr.
In a MAT, only the last transition pair have shared accesses
on the same variable, maybe co-enabled, and at least one
of them being write. (Other possible candidates such as
(6a,3b)are not considered as they are unreachable due to
synchronizationsemantics).OtherMATs m2· · ·m6areshown
similarly as shaded rectangle.For MAT m5(andm6) onlyone
interleavingisfeasible(highlightedwithonlyoneboldar row).
The basic idea of MAT-based partial order reduction is to
restrict context switching only between the two transactio ns
of a MAT. A context switch (as indicated with •) can only
occur from the ending of a transaction to the beginning of the
other transaction in the same MAT. Note that there are exactl y
two context switches for any given MAT. For example, for
the MAT m1,tam1·tbm1andtbm1·tam1are the only two
context switches allowed. Such restriction reduce the set o f
necessary thread interleavingsto explore,and at the same t ime
includes any feasible interleaving or its equivalent. (A ge neral
procedure to ﬁnd such a set of context switches for two or
more threads is provided in [15]).
Given a set of reduced context switches, denoted as
CXT CTM, we derive I-transactions as follows: We obtain
a set of I-transactions for each thread Mi, denoted as ATi,
by splitting the sequence of program ordered transitions of
Miinto transactions such that context switches occur at the
begin/end control state of such transactions.
For the running example, we obtain the sets ATaand
ATbas follows: ATa={ta1≡ 1a· · ·3a, ta 2≡
tb1 tb2 tb3 tb4
ta1
ta2
ta3
ta4m1
m3m2m4tbm1tbm2tam2tam1 tam3tbm3m5
m6m3
Fig. 5. MATs: m1· · ·m63a· · ·5a, ta 3≡5a· · ·7a, ta 4≡7a· · ·10a}andATb=
{tb1≡1b· · ·4b, tb 2≡4b· · ·6b, tb 3≡6b· · ·7b, tb 4≡
7b· · ·11b}. These are shown as bold arrows in Figures 2(b),
and 5. A set of I-transactions, I-AT:=/uniontextN
i=1ATi.
VIII. S YMBOLIC ATOMICITY CHECKING
Before we delve into the details, we present the underlying
idea for the symbolic atomicity checking.
Proving Atomicity . Given an E-transaction πwe obtain a
set{π1· · ·πi· · ·π|π|}where πiis an I-transaction, and |π|
is the length of the E-transaction in terms of the number of
I-transactions, so that for each transition t∈π,∃1≤i≤
|π|. t∈πi. We use the MAT analysis to “prove atomicity”
and prune atomic regions accordingly (in stage III), i.e., if
|π|= 1, the atomicity of the E-transaction is guaranteed w.r.t.
the generalized traces.
Example: For the inferred E-AT(Eqn 1), we obtain corre-
sponding I-transactions as follows: For tr1,tr2andtr3we
obtain I-transactionssets {ta1, ta2},{tb2, tb3, tb4},and{ta4}
respectively. Thus, we prove the atomicity of tr3.
From the remaining E-transactions, we derive two CA
properties, namely, CA 1≡ {tr1}andCA 2≡ {tr2}, and one
CMA property, namely, CMA 1≡ {tr1, tr2}. The following
schedules σa−cviolate these atomicity propertiesas indicated.
(Note, σa−care missed by other generalized models [9], [12],
[13], [23].)
σa≡tb1·ta1·tb2·tb3·ta2(violates CA 1,CA 2,CMA 1)
σb≡tb1·tb2·ta1·ta2·tb3·tb4(violates CA 2,CMA 1)
σc≡tb1·tb2·tb3·ta1·ta2(violates CA 2,CMA 1).
In the following, we discuss how we encode the violation
condition of the atomicity properties and ﬁnd the violating
schedules.
EncodingAtomicityViolation .Givenanatomicityproperty prp
as a set of E-transactions, denoted as E-ATprp, a necessary
condition for the atomicity violation, denoted as NAV, is an
existence of a non-serial schedule, i.e.,
NAV :=/logicalordisplay
π∈E-ATprp|π|−1/logicalordisplay
i=1¬NC πi,πi+1 (2)
where NCi,jis Boolean condition when truedenotes I-
transaction iis followed immediately by I-transaction jin
a thread program order. As an example, the NAVcondition
forCMA 1property i.e., {tr1, tr2}is given by
NAV =¬NCta1,ta2∨ ¬NCtb2,tb3∨ ¬NCtb3,tb4(3)
A set of CXT CTMadmits all and only representative
schedules of CTM [15]; however, not all representative
schedules captured are serial w.r.t. to a given set E-AT.
In other words, NAVmay not be sufﬁcient condition for
atomicity violation. For the running example, the schedule
tb1·tb2·tb3·ta1·ta2·tb4is not serial w.r.t. {tr1, tr2}, as
tb3·tb4is interrupted by ta1·ta2. However, it is conﬂict-
serializable as it is conﬂict-equivalent to a serial schedu le
tb1·tb2·tb3·tb4·ta1·ta2w.r.t.{tr1, tr2}.
FindAV. We now present the sound and complete procedure
(algorithm 1) for ﬁnding atomicity violation. It iterative ly129strengthens the NAVcondition by eliminating non-serial
schedules that are conﬂict-equivalentto some serial sched ules.
Given a set E-ATprp(corresponding to an atomic property
prp), we ﬁrst obtain the necessary violation condition NAV
as per Eqn. 2. We then use a symbolic encoding (as discussed
in [15], [25]) to obtain an SMT formula Ωschedthat represents
a set of all and only feasible schedules in CTM.
We then use an SMT-solver to check if Ωsched∧NAV′is
satisﬁable, where NAV′is initialized to NAV. If the check
returns UNSAT, it returns NULLas there is no violation
possible (i.e., property holds). On the other hand, if the
check returns SAT with a schedule ρ, we use a procedure
Is_Serializable to check if ρis conﬂict-serializable. If
the procedurefails, we found a true violation and the schedu le
ρisreturned.Otherwise,weuseaprocedure Blocking_Cls
to generate a blocking clause clsas follows:
cls:=/logicalordisplay
π∈E-ATprp|π|−1/logicalordisplay
i=1NC′
πi,πi+1(4)
NC′
πi,πi+1:= ( ρ(NCπi,πi+1) =true ) ?NCπi,πi+1:
¬Cπi,j∨ · · · ∨ ¬ Ck,πi+1;
where, Cπi,j,· · ·,Ck,πi+1denotes all the intermediate context
switches from πitoπi+1through I-transactions j· · ·k. We
useρ(x)to denote the Boolean satisfying assignment to vari-
ablex, and?:ternary operatorfor the conditional expression.
We use Ci,jto denote a Boolean condition when truedenotes
thatI-transaction icontext switches to I-transaction jof
another thread.
We add this clstoNAV′constraints, and continue with the
SMT_Check . At every step, we prune the set of non-serial
schedules by eliminating conﬂict-serializable schedules .
The algorithm FindAV can be used to check CA
or CMA atomicity violation by plugging the appropriate
Is_Serializable procedure for the corresponding notion
of atomicity.
Special Case . If each E-transaction of E-ATprphas either
all write accesses or all read accesses on a single shared
variable, then one can show that NAVcondition is both
necessary and sufﬁcient condition for atomicity violation . In
such a case, we do not require more than one SMT_check
procedure call.
IX. EXPERIMENT
We have implemented stages I to IV in our tool BEST. We
usegcc/g++/gcj compilers to transform C/C++/Java
programs to x86 binaries. At runtime, we instrument the
application binary and dynamically loadable libraries suc h
aspthread using PIN [14] to record the synchro-
nization events such as wait/notify, lock/unlock, fork/jo in,
semwait/sem post,and heapmemoryaccesses. We use SMT
solver Yices-1.0.28 [26] in our decision procedure. We use
the SMT encoding as described in [15], [25] to obtain a
set of feasible schedules. We experimented on a 64-bit linux
workstation with a 2.4GHz Intel Xeon CPU and 4GB RAM.
Benchmarks . We used 9 multi-threaded publicly available
applications (written in C/C++/Java ) with 1K-33K LOC.
Table III gives a short description of these applications.Algorithm 1 FindAV: Find Atomicity Violation
1:input:Given a set E-ATprp,NAV,Ωsched
2:output: ρ(AV schedule) or NULL(property holds)
3:NAV′:=NAV {Initialize violation constraint }
4:whiletruedo
5: (issat, ρ ):=SMT_Check (Ωsched ∧NAV′)
6:if(issat=true )
7: if (Is_Serializable (ρ) =false)
8: cls:=Blocking_Cls (ρ){as per Eqn 4 }
9: NAV′:=NAV′∧cls
10: else
11: return ρ{Found a violation }
12:else
13: return NULL {Property holds }
14:endif
15:end while
TABLE III
SHORT DESCRIPTION OF THE BENCHMARKS USED IN EXPERIMENTS .
Name (LOC, Lang) Description
account [2]
(145,Java)Handles banking transactions concurrently.
tsp[27] (713,Java)Solves traveling salesman problem using multi-threading.
aget[28] (1.2K, C)A multi-threaded HTTP download accelerator.
fastspy [29] (1.5K, C)A multithreaded network port scanner.
finalsolution [28]
(2K,C++)A distributed multiprotocol multithreaded audit tool.
prozilla [29]
(2.7K,C++)A multithreaded HTTP/FTP downloader with multiple
connections to multiple servers.
axel[28] (3.1K, C)A multithreaded replacement of wget.
bzip2smp [29]
(6.4K,C)A multithreaded parallelizer of BZIP2 for SMP machines.
alsaplayer [29]
(33K,C++)A multithreaded PCM player for unix/linux using ALSA
library.
A. Results of Atomicity Analysis (reported in Table IV)
Trace Information . We ran each application with different
thread settings. The trace information corresponding to ea ch
run are shown in the Columns 2–6 as follows: the number of
threads ( n), the number of events recorded ( #E), the number
of local variables ( #L), the number of global variables ( #G),
and the number of global accesses ( #A).
InferringAtomicitySpeciﬁcation .Foreachrunof thebench-
marks,we inferintendedatomicregions( E-transactions)using
maxD=10. The results of atomicity inference are shown in
Columns 7–10 as follows: the number of atomic regions
inferred ( #IA), the number of atomic regions remained after
removing those that are proved atomic ( #RA 1), the number
of atomic regions remained after removing those that are
observed non conﬂict-serializable ( #RA 2), and the average
number of shared variables per atomic region ( #vavg).
Finding CA Atomicity Violation . We obtain a set of CA
properties each corresponding to a remaining atomic region
(#RA 2). The results of CA atomic checking are shown in
Columns 11–13: the number of CA properties ( #CA), the
number of CA violations found ( #V) or proved ( #P) by
FindAV, and average time taken (in sec) per property ( tavg).
Finding CMA Atomicity Violation . We obtain a set of CMA
propertiesfromremainingatomicregions #RA 2(asdescribed
in Section VI). The results of CMA atomicity checking are
shown in Columns 14–17: the number of CMA properties
(#CMA), number of CMA violations in the observed trace
(#obs), the number of CMA violations found ( #V) or proved130(#P) byFindAV, and the average time taken (in sec) per
property (tavg).
For both CA and CMA atomicity checking, we gave 1 hour
time limit per run. In Column 18, we present the number of
atomicity bugs found.
Discussion . We observe that a signiﬁcant number of atomic
regionsareprovedatomic( = #IA−#RA 1),whileonlyafew
(= #RA 1−#RA 2) are found to be not conﬂict-serializable.
Most atomic regions involve multiple variable accesses. Ti me
per check (i.e. tavg) is mostly around a few seconds. The
number of iterations in FindAV (per property) range from
one to few hundreds, with most checks requiring only one
iteration. CMA checking generally is more robust compared
to CA checking which aborted in aget,finalsolution
andprozilla due to resource limitation.
We foundseveralpreviouslyknown/unknownAV bugs(Bug
list can be found here [30]). All the found AV schedules were
feasible.Althougheachatomicityviolationfoundtobe unique,
multiple violations corresponded to the execution of the sa me
buggysourcelines. We discussthese AVbugsin thefollowing.
Inaget, all the reported violations correspond to two dis-
tinct atomicity bugs. One corresponds to a previously known
bug where a shared variable bwritten is updated and read
non-atomically. The other bug, not reported before, was due
non-atomic update and read of an unprotected variable prev
in a function updateProgressBar .
In the application finalsolution , all the reported
atomicity violations correspond to non-atomic accesses of a
statically deﬁned variable in a function pwdnumdiv , and
which can generate password strings of unintendedlength. W e
found several atomicity bugs in axel, each corresponding
to non-atomic updates of ﬁelds of a structure during set up
of HTTP/FTP connections. We found two atomicity bugs in
prozilla , each corresponding to non-atomic update of a
structureconnection_err . Inaccount , the atomicity
violations correspond to 2 known atomicity bugs.
B. Results of Reductions Steps (reported in Table V)
GlobalReduction .Theproperty-independentreductionsteps
in stage II took on average 1-2 minutes per run, mostly dom-
inated by MAT-based POR analysis. The results of reduction
in the number of context switches are shown in Rows 1-2 as
follows: factor reduction using lockset and HB analysis ( A),
and factor reduction using MAT analysis ( B). Similarly, factor
reduction in the number of transitions using merging ( D) is
shown in Row 7.
Property-speciﬁc Reduction . The factor reduction in the
number of context switches per CMA property using MAT
analysis ( C1) post slicing is shown in Row 3. In Row 4, we
present the total reduction per CMA property, combining the
net effect (product) of A,B, andC1reductions. Similarly,
the factor reduction in the number of transition per CMA
property using merging ( E1) post slicing is shown in Row 8.
In Row 9, we present the total reduction per CMA property,
combining the net effect (product) of D, andE1reductions.
Similar reduction results are presented for CA properties i n
Rows 5, 6, 9, and 11.
Discussion . We observe that the combination of the reduc-
tion steps in stages II and IV help in reducing the contextswitches by a few orders of magnitude. Similarly, these step s
reducethe numberof transitionssigniﬁcantly.We also obse rve
that the reduction in the number of context switches per CMA
property is at least an order of magnitude more compared to
per CA property. Overall, these reductions steps are crucia l in
improving the scalability of the approach.
X. CONCLUSION & FUTUREWORK
We presented a tool for predicting atomicity violation in
the most generalization of the observed trace. The salient
feature of our tool are effective staged simpliﬁcation and
reductionenablingscalable symbolicprediction,automat ically
inferring atomic regions from a concrete execution, using
a more useful and practical notion of atomicity, generating
atomicity violating schedules that exhibit real bugs and sc ope
for task parallelization. We demonstrated the practicalit y and
usefulness of the combined techniques on a set of publicly
available benchmarks in ﬁnding known/unknown bugs.
In conclusion, we believe that such an approach has the
potential to improve the scalability of precise runtime ana lysis
and,therefore,improvesoverallqualityofconcurrencyte sting.
Infuture,wewouldliketoaddsupportforhandlingspurious
schedules, and distribute search for further scalability.
ACKNOWLEDGMENTS
We thank Nipun Arora for helping with PIN-based instru-
mentation, and Chao Wang and Jie Yu for useful feedbacks.
REFERENCES
[1] S. Lu, S. Park, E. Seo, and Y. Zhou. Learning from mistakes :
A comphrensive study on real world concurrency bug characte rstics.
InArchitectural Support for Programming Languages and Opera ting
Systems, 2008.
[2] C. Flanagan and S. Qadeer. A type and effect system for ato micity. In
PLDI, 2003.
[3] L. Wang and S. D. Stoller. Accurate and efﬁcient runtime d etection of
atomicity errors in concurrent programs. In Symposium on Principles
and Practice of Parallel Programming , 2006.
[4] M. Vaziri, F. Tip, and J. Dolby. Associating synchroniza tion constraints
with data in an object-oriented language. In Proc. of POPL , 2006.
[5] C. Hammer, J. Dolby, M. Vaziri, and F. Tip. Dynamic detect ion of
atomic-set-serializability violations. In International Conference on
Software Engineering , 2008.
[6] C. Flanagan. Verifying commit-atomicity using model-c hecking. In
Proc. of SPIN Workshop , 2004.
[7] A. Farzan and P. Madhusudan. Causal Atomicity. In Proc. of CAV ,
2006.
[8] C.-S. Park and K. Sen. Randomized active atomicity viola tion detection
in concurrent programs. In International Symposium on the Foundations
of Software Engineering , 2008.
[9] F. Chen, T. F. Serbanuta, and G. Rosu. jPredictor: A predi ctive
runtime analysis tool for java. In International Conference on Software
Engineering , 2008.
[10] S. Park, S. Lu, and Y. Zhou. CTrigger: exposing atomicit y violation
bugs from their hiding places. In ASPLOS, 2009.
[11] Q. Chen, L. Wang, Z. Yang, and S. Stoller. HAVE: Detectin g atomicity
violations via integrated dynamic and static analysis. In Proc. of FASE ,
2009.
[12] J. Yi, C. Sadowski, and C. Flanagan. SideTrack: General izing dynamic
atomicity analysis. In Proc. of PADTAD , 2009.
[13] F. Sorrentino, A. Farzan, and M. Parthasarathy. PENELO PE: weaving
threads to expose atomicity violations. In International Symposium on
the Foundations of Software Engineering , 2010.
[14] C.-K. Luk, R. S. Cohn, R. Muth, H. Patil, A. Klauser, P. G. Lowney,
S. Wallace, V. J. Reddi, and K. M. Hazelwood. PIN: Building
customized program analysis tools with dynamic instrument ation. In
PLDI, 2005.131TABLE IV
RESULTS OF ATOMICITY ANALYSIS
Application Trace Information Atomicity Inferences Causal Atomic Causal Mutual Atomic #Bugs
(LOC, Lang) n#E#L#G#A #IA #RA1#RA2#vavg #CA #V/#Ptavg #CMA #obs. #V/#Ptavg
47441521822 36 5 52.6 5 0/5 0.2s 5 0 0/5 0.0saccount792322371040 8011 112.8 11 10/1 0.3s 15 010/5 0.1s 2(145,Java)12123932671481 155 21 212.9 21 20/1 0.9s 30 020/10 0.5s
tsp†731K203431K5197 2 2 3 2 0/2 2.5s 1 0 0/1 2s
(713,Java)1234K304734K5765 5 5 3 5 0/5 5.2s 9 0 0/9 2.3s0
38544151844 186113 612.6 61 0/0* -599 040/0* 76saget710058352191 210114 452.6 45 0/0* -429 0133/0* 27s 2(1.2K,C)11112712552453 230110 292.6 29 0/0* -204 0204/0 1.6s
111017751391550 9412 122.1 12 0/12 2.3s 10 00/10 0sfastspy211972852032959 180 22 22 222 0/0* - 20 00/20 0.1s 0(1.5K,C)312912952674329 260 32 32 232 0/0* - 30 00/30 0.2s
finalsolution 5629276689857 331 67 63 163 0/0* -1372 01372/0 0.2s
(2K,C++)67353687811870 392 87 86 186 0/0* -2139 02139/0 0.2s1
prozilla 8894510352379859 649131 129 2.31290/128* 1.3s 65 00/7* 391s
(2.7K,C++)1315K185444516075 1034 251 250 2.22500/249* 0.7s 103 02/4* 3.7s2
31452204351258 127 45 452.3 45 38/7 0.2s 71 067/4 0.1saxel73016244832778 238 82 822.3 8252/23* 13s 117 0105/12 0.1s 10(3.1K,C)1148722841314590 443184 184 2.918481/42* 14s 324 0292/32 0.2s
bzip2smp 42126653482185 240117 117 11117 0/2* 197s 429 00/53* 0.8s
(6.4K,C)82153613482216 240117 117 11117 0/2* 94s 429 00/54* 29s0
alsa
(33K,C++)514K37224117K 77175 17 19 17 0/75 5.8s 84 00/84 4s 0
Notes: n: num. of threads; #E: num. of recorded events (transitions); #L: num. of local vars; #G: num. of global vars;
#A: num. of global accesses; #IA: num. of inferred atomic region; #RA1: num of atomic regions after MAT analysis;
#RA2: num. of atomic regions after pruning observable non conﬂic t-serializable;
#vavg: avg. num. of shared variables per atomic region; #CA: num of CA properties (same as #RA2);#V/#P: num. of atomicity violations/proved found;
#CMA: num. of causal mutual atomic prop.; #obs: num. of violation found in observed trace; *: Timeout;
tavg: avg. time taken (per sec) by FindAV;#Bugs: number of atomicity bugs (require code change); †test ﬁles used are map5 (n=7) tspﬁle6 (n=12)
TABLE V
RESULTS OF REDUCTION STEPS
#Reduction strategy
account
tsp
aget
fastspy
ﬁnalsolution
prozilla
axel
bzip2smp
alsaplayerReduction Range
FACTOR reduction in the number of context switches (Note, mEn ≡m∗10n)
1A. Lockset+HB analysis (global) 3.1502.61.95.31.11.82.21.69.2 1.1x–502.6x
2B. MAT analysis (global) 30.31.1E3 7.570.19.3319.19.69.649 7.5x–1.1E3x
3C1. MAT analysis per CMA property 11.910.4168.814.91E4136.74.2E3125.474.710.4x–10.1E3x
4A * B * C1 . Total red. per CMA property 1.1E32E62.1E35.6E31E57.7E46.9E41.9E33.4E4 1.1E3x–2E6x
5C2. MAT analysis per CA property 6.98.81.113.712.769.82.8E3 537.4 1.1x–2.8E3x
6A * B * C2 . Total red. per CA property 646.71.1E614.75.2E3132.33.9E44.7E475.21.7E4 14.7x–1.1E6x
FACTOR reduction in the number of transitions
7D. Merging (global) 3.31.02 11.11.11.41.11.11.1 1x–3.3x
8E1. Merging per CMA property 1.618.91.63.11.28.410.03.81.8 1.2x–18.9x
9D * E1. Total red. per CMA property 519.31.63.21.311.411.1 41.9 1.3x–19.3x
10E2. Merging per CA property 1.918.91.53.11.2716.1 44.2 1.2x–18.9x
11D * E2. Total red. per CA property 619.31.53.21.29.518.14.24.5 1.2x–19.3x
[15] M. K. Ganai and S. Kundu. Reduction of Veriﬁcation Condi tions for
Concurrent System using Mutually Atomic Transactions. In Proc. of
SPIN Workshop , 2009.
[16] A. Mazurkiewicz. Basic Notions of Trace Theory. In Workshop on
Linear Time, Branching Time and Partial Order in Logics and M odels
for Concurrency , volume 354 of LNCS, pages 285–363. Springer-Verlag,
1988.
[17] A. Farzan, P. Madhusudan, and F. Sorrentino. Meta-anal ysis for
atomicity violations under nested locking. In Proc. of CAV , 2009.
[18] M. Xu, R. Bodik, and M. D. Hill. A serializability violat ion detector
for shared-memory server programs. In PLDI, 2005.
[19] S. Lu, J. Tucekt, F. Qin, and Y. Zhou. AVIO: detecting ato micity
violations via access interleaving invariants. In Architectural Support
for Programming Languages and Operating Systems , 2006.
[20] S. Lu, S. Park, C. Hu, X. Ma, W. Jiang, Z. Li, R. A. Popa, and Y. Zhou.
MUVI: automatically inferring multi-variable access corr elations and
detecting related semantic and concurrency bugs. In Symposium on
Operating Systems Principles , 2007.[21] C. Wang, R. Limaye, M. Ganai, and A. Gupta. Trace-based s ymbolic
analysis for atomicity violations. In Proc. of TACAS , 2010.
[22] C. Flanagan and P. Godefroid. Dynamic partial-order re duction for
model checking software. In Proc. of POPL , 2005.
[23] V. Kahlon and C. Wang. Universal Causality Graph: A Prec ise Happens-
Before Model for Detecting Bugs in Concurrent Programs. In Proc. of
CAV, 2010.
[24] J. Hatcliff, Robby, and M. B. Dwyer. Verifying atomicit y speciﬁcations
for concurrent object-oriented software using model-chec king. InProc.
of VMCAI , 2004.
[25] M. K. Ganai and A. Gupta. Efﬁcient modeling of concurren t systems
in BMC. In Proc. of SPIN Workshop , 2008.
[26] SRI. Yices: An SMT solver. http://fm.csl.sri.com/yices .
[27] C. von Praun and T. R. Gross. Object race detection. In OOPSLA, 2001.
[28] Geeknet Inc. Freshmeat. http://freshmeat.net .
[29] Geeknet Inc. SourceForge. http://sourceforge.net .
[30] M. K. Ganai. Conference Notes. http://www.nec-
labs.com/ ∼malay/notes.htm .132