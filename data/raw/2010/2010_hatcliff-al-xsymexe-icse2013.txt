See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/261120277
Explicating symbolic execution (xSymExe): An evidence-based veriÔ¨Åcation
framework
Conf erence Paper ¬†¬† in¬†¬†Proceedings - Int ernational Conf erence on Softw are Engineering  ¬∑ May 2013
DOI: 10.1109/IC SE.2013.6606568
CITATIONS
7READS
34
4 author s, including:
John Hat cliff
Kansas St ate Univ ersity
214 PUBLICA TIONS ¬†¬†¬†6,620  CITATIONS ¬†¬†¬†
SEE PROFILE
-- Robb y
Kansas St ate Univ ersity
72 PUBLICA TIONS ¬†¬†¬†3,776  CITATIONS ¬†¬†¬†
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y John Hat cliff  on 24 July 2023.
The user has r equest ed enhanc ement of the do wnlo aded file.Explicating Symbolic Execution ( XSYMEXE):
An Evidence-Based VeriÔ¨Åcation Framework
John Hatcliff, Robby, Patrice Chalin, Jason Belt
Department of Computing and Information Sciences, College of Engineering, Kansas State University, USA
{hatcliff,robby,chalin,belt}@k-state.edu
Abstract ‚ÄîPrevious applications of symbolic execution ( SYM-
EXE) have focused on bug-Ô¨Ånding and test-case generation.
However, SYMEXEhas the potential to signiÔ¨Åcantly improve
usability and automation when applied to veriÔ¨Åcation of soft-
ware contracts in safety-critical systems. Due to the lack of
support for processing software contracts and ad hoc approaches
for introducing a variety of over/under-approximations and
optimizations, most SYMEXEimplementations cannot precisely
characterize the veriÔ¨Åcation status of contracts. Moreover, these
tools do not provide explicit justiÔ¨Åcations for their conclusions,
and thus they are not aligned with trends toward evidence-
based veriÔ¨Åcation and certiÔ¨Åcation. We introduce the concept of
explicating symbolic execution (XSYMEXE) that builds on a strong
semantic foundation, supports full veriÔ¨Åcation of rich software
contracts, explicitly tracks where over/under-approximations are
introduced or avoided, precisely characterizes the veriÔ¨Åcation
status of each contractual claim, and associates each claim with
explications for its reported veriÔ¨Åcation status. We report on case
studies in the use of Bakar Kiasan, our open source XSYMEXE
tool for SPARK ADA.
I. I NTRODUCTION
Over the last decade, software engineering and formal
methods research has demonstrated that symbolic execution
(SYMEXE) [1] can be an effective technique for automatically
checking wide-ranging properties of a program‚Äôs behavior with
little or no developer intervention. Previous applications of
SYMEXEhave centered around detection of common faults
(such as null-pointer dereferencing, buffer overÔ¨Çows, array
bounds violations), and test case generation [2]‚Äì[6].
SYMEXEtools aim to provide highly-automated and pre-
cise reasoning about program states by employing a variety
of approximating optimizations. Path sensitive analyses are
guided by heuristics that prune, or cutoff, certain paths. For
example, to reduce the burden on developers, in S YMEXE,
loop invariants are optional; instead, loops are (dynamically
& lazily) unrolled up to a developer-conÔ¨Ågurable bounded
depth. Rather than requiring complex ‚Äúshape properties‚Äù for
data structures [7], [8] to be declared by developers, data
structures are explored up to a bounded size. Finally, rather
than requiring manual steps in a theorem prover, logical
constraints over program variables are solved by decision
procedures (DPs) that may return ‚Äúdon‚Äôt know‚Äù or time-
out after a developer-conÔ¨Ågured time bound. When these
This material is based upon work supported by the National Science
Foundation under Grant # 0644288 and by the US Air Force OfÔ¨Åce of
ScientiÔ¨Åc Research (AFOSR) under contract FA9550-09-1-0138.path cutoff optimizations occur they can cause S YMEXEto
compute an under-approximation of the program‚Äôs behavior;
thus, S YMEXEmay fail to discover faults in a program that
occur beyond path cutoff points. On the other hand, programs
often contain data computations that lie outside the theories
handled by DPs and the typical strategy for dealing with such
cases can cause S YMEXEto introduce an over-approximation
of a portion of the program‚Äôs behavior, thus, it may report
‚Äúfalse alarms‚Äù.
While these approximations are effective for automation,
their impact on the coverage of a program‚Äôs state space and
the reporting of results of property checking cannot be easily
predicted. At a more fundamental level, the unconstrained and
unmonitored use of these optimizations means that developers
cannot trust the tool to yield a deÔ¨Ånitive report of the correct-
ness of assertions or other program properties.
In contrast to the emphasis on bug-Ô¨Ånding for predeÔ¨Åned
properties and faults outlined above, we are interested in the
veriÔ¨Åcation of developer-supplied contracts that specify full
functional correctness. While software contract checking is
useful in many contexts, we are interested primarily in its
application in the development of safety-critical software.
Unfortunately, our experience in several industrial collabo-
rations with companies such as Rockwell Collins, who produce
certiÔ¨Åed safety and security critical software, has shown that
current tools for contract checking place too great a burden
on developers. For example, the S PARK language and tool
framework [9] is one of the premier commercial development
frameworks for high-assurance software. S PARK has been
used to develop a number of safety/security-critical systems.
Even though S PARK and its static analysis components are
beneÔ¨Åcial and easy to use, its contract language is rarely
used due to the burdens the associated tools and methodology
impose on developers. In fact, we are not aware of any
industrial development effort that makes signiÔ¨Åcant use of
the S PARK pre/post-condition notation other than to specify
enough context information for procedures to enable absence
of run-time errors to be proved.
We believe that a more foundational approach to S YMEXE
can signiÔ¨Åcantly improve the usability and effectiveness of
contract checking tools by providing a completely automated
lazy bounded veriÔ¨Åcation technology that scales to very
complex contracts. Our vision is that the highly automated
nature of S YMEXEwould allow developers to apply contractchecking early in the development process with very little
effort. We believe that in many cases, S YMEXEcan provide
complete veriÔ¨Åcation that code conforms to contracts.
In cases where complete veriÔ¨Åcation is not achieved,
bounded S YMEXE-based checking can lead to the detection
and removal of the vast majority of functional Ô¨Çaws in code
and contracts. Moreover, S YMEXEcan provide a variety of
forms of semantic visualizations, test generation, etc., that
can help developers better understand their code, enable more
rapid development of contracts, and provide evidence that
signiÔ¨Åcantly increases conÔ¨Ådence in program correctness.
Our aim is not to replace, e.g., the S PARK Examiner‚Äî
SPARK ‚ÄôsveriÔ¨Åcation condition generation (VCGen)-based
tool‚Äîbut to complement it by offering highly automated
developer-friendly techniques that can be used directly in
the code (specify) / test (check) / debug (understanding
feedback) loop of typical developer workÔ¨Çows. Our vision
includes providing tool reports that clearly distinguish between
contracts that have been proven by S YMEXEfrom those
with remaining proof obligations. Contracts with undischarged
proof obligations would be handed off later in the development
process to veriÔ¨Åcation engineers who apply less automated
tools and proof assistants.
To achieve this vision, we have developed a novel approach
to S YMEXEfor software contract checking. We call this ap-
proach explicating symbolic execution (XSYMEXE) because it
is designed from the ground up to have robust semantic under-
pinnings and to produce explicit explanations and justiÔ¨Åcations
about the veriÔ¨Åcation status of each of developer-supplied
claim in a program. We make the following contributions:
Introduce the concept of XSYMEXEas the foundation of
an evidence-based framework for justifying the veriÔ¨Åca-
tion status of software contracts checked by S YMEXE,
and explain the basic algorithms of XSYMEXEused
to explicitly track when under/over-approximations are
introduced (Sections II-A, III & V).
Provide rigorous mathematical deÔ¨Ånitions for the basic
principles of XSYMEXEincluding notions of soundness
that justify the developer interpretation of veriÔ¨Åcation
results of S YMEXEwhen applied to software contracts
(Sections II-B, III & IV).
Implement XSYMEXEin the open source Bakar Ki-
asan (Kiasan for short) symbolic execution tool for
SPARK ADA.
Summarize the results of publicly available case studies
and related artifacts on applying Kiasan to a variety of
SPARK examples (Section VI).
This work was motivated by collaborations with engineers
at Rockwell Collins and knowledge of how S PARK is being
used in Rockwell Collins‚Äô security critical projects. We are
currently collaborating with AdaCore and Altran Praxis to
integrate this technology into their next version of S PARK .
Although we illustrate our techniques in the context of S PARK ,
we believe that the concepts can easily be adapted to other
tools, working on different languages, such as the Symbolic
Path Finder (SPF) [10] and Klee [6].II. B ACKGROUND
In this paper, we are concerned with XSYMEXEfor contract-
based languages like S PARK ADA. We will use the term claim
to be a contract pre-, or post-condition, or inline assert state-
ments and their specialized forms (such as loop invariants).
A. Evidence-based Verif.: Conventional SYMEXEShortfalls
We carefully illustrate here the ways in which S YMEXE
can lead to uncertainty in the veriÔ¨Åcation status of claims
while pointing out how XSYMEXEcan offer clarity in the
conclusions that can be drawn. Examples are in S PARK and
the essence of the notation is explained as we go along.
Issue: Under-approximation due to bound (or selective
search) cutoffs may mask program faults , one of the more
obvious limitations of bounded S YMEXE, is illustrated in Fig-
ure 1(a) , where an array is used to implement a queue of Size
elements. S PARK ‚Äôs contract notation is fairly conventional and
should be easy to interpret once one knows that occurrences
ofE~ in a post-condition refers to pre-state values of E.
Execution of this procedure will result in an implicit claim
violation due to the array index being out of range in the
expression A(K + 1) at Line 20. The Ada standard mandates
several kinds of implicit claims like these. The source of the
problem is the upper bound of the forloop: it should be
Size - 1 . When a conventional implementation of S YMEXE
is invoked with a loop bound less than Size , then no contract
violation is reported because the last iteration of the loop (in
which Kis equal to Size ) is never reached due to the path
cutoff from the loop bound exhaustion.
Solution: Because XSYMEXEprecisely tracks: (1) when
bound exhaustion leads to path cutoffs, and (2) the implicit
and explicit claims whose checking may be bypassed due to
those particular cutoffs, Kiasan reports that the implicit range
claim at Line 20 is V ERIFIED?. In Kiasan, we consistently
use ‚Äú?‚Äù as an ‚Äúinconclusiveness‚Äù qualiÔ¨Åer, read as ‚Äúmaybe‚Äù.
Kiasan also provides an explication that enumerates all the
program points in which S YMEXEbound exhaustion occurred
which may prevent the full evaluation of the claim.
Issue: Cutoffs in assumption statements , a precondition
in the case illustrated in Figure 1(b) , can lead to over-
approximation and false alarms . The procedure contract is
actually valid, but the over-approximation introduces a false
alarm as we explain next. Consider S YMEXEof this example
with a loop bound of 4 and an array bound of 5. S YMEXE
begins at the precondition. Since the precondition‚Äôs universal
quantiÔ¨Åer is (symbolically) executed as a loop, and since
Size can take on the value 5, its evaluation will lead to
a symbolic state in which A(K) /= EMPTY forK = 1..4 ,
but will leave A(5) unconstrained since the last iteration of
the (quantiÔ¨Åer) loop is cutoff due to loop bound exhaustion.1
SYMEXEcontinues with the evaluation of the procedure body
using (simplifying slightly) a symbolic state built out of the
1Terminating the analysis at cutoff points in assumptions would cause the
subsequent code/claims to be unanalyzed. In contrast, any claim veriÔ¨Åed under
an over-approximating assumption, is satisÔ¨Åed in any concrete execution.(a)VERIFIED?(read inconclusiveness qualiÔ¨Åer ‚Äú?" as ‚Äúmaybe‚Äù; i.e., ‚Äúmaybe
VERIFIED ‚Äù) due to under-approx. caused by bounding. Claim is actually invalid.
subtype Index i sI n t e g e r range 1 . . 5 ;
type V e c t o r i s array ( Index ) ofI n t e g e r ;
EMPTY : c o n s t a n t := 0 ;
5
procedure dequeue (A : in out V e c t o r ;
S i z e : in out I n t e g e r ; R : out I n t e g e r )
  # pre ( f o r a l l K i n I n d e x range Index ‚Äô F i r s t . . S i z e =>
  # ( A (K) /= EMPTY ) ) and
10  # Index ‚Äô F i r s t <= S i z e and S i z e <= Index ‚Äô L a s t ;
  # p o s t ( f o r a l l K i n I n d e x range Index ‚Äô F i r s t . . S i z e =>
  # ( A (K) /= EMPTY ) ) and
  # R = A~( Index ‚Äô F i r s t ) and A ( S i z e ~) = EMPTY and
  # S i z e = S i z e ~  1 and
15  # ( f o r a l l K i n I n d e x range Index ‚Äô F i r s t . . S i z e =>
  # ( A (K) = A~(K + 1 ) ) ) ;
i s begin
R := A( Index ‚Äô F i r s t ) ;
f o r KinIndex range Index ‚Äô F i r s t . . S i z e
20 loop A(K) := A(K + 1) ; end loop ;
A( S i z e ) := EMPTY; S i z e := S i z e  1 ;
end dequeue ;
(b) False alarm: REFUTED?(read ‚Äúmaybe REFUTED ‚Äù) claim, that is actually valid,
due to bound exhaustion in assumption (precondition) causing over-approx.
procedure d e q u e u e _ f i x e d ( . . . )    c o n t r a c t same as dequeue
25i s begin
R := A( Index ‚Äô F i r s t ) ;
f o r KinIndex range Index ‚Äô F i r s t . . S i z e  1
loop A(K) := A(K + 1) ; end loop ;
   r e s t o f body l i k e dequeue
30
(c) False alarm: INDETERMINATE claim, reported (due to unhandled theory
over-approximation) but claim is actually valid.
procedure FAIT ( I , J : I n t e g e r ; R , K, Q : out I n t e g e r )
  # pre I >= 10 and I <= 1 and J >= 1 and J <= 10;
  # p o s t Q >= 99 and Q <= 0 ;
i s begin R := IJ ; K := R + 1 ; Q := K; end FAIT ;35(d)UNCOVERED claim at Line 39 if the loop bound is less than 5.
procedure B (K : I n t e g e r ; R : out I n t e g e r ) i s begin
R := 0 ;
f o r JinI n t e g e r range 1 . . 5 loop R := R + K; end loop ;
  # a s s e r t P1 (K , R ) ;
40end B ;
(e)DEADclaim and code since the product of 2 naturals cannot be negative.
procedure DeadEx ( J , K : N a t u r a l ; R : out I n t e g e r ) i s
begin
R := JK;
45 i f(R < 0) then
  # a s s e r t P2 ( J , K , R ) ;
R := 0 ;
end i f ;
end DeadEx ;
50
(f)FAULTY postcondition as it yields an array index out of bounds violation.
procedure I n s e r t i o n S o r t (A : in out V e c t o r )
  # p o s t f o r a l l K i n I n d e x => ( A (K) <= A (K + 1) ) ;
   d e t a i l s o f body e l i d e d f o r b r e v i t y .
(g)VERIFIED claim (fully veriÔ¨Åed). No bound exhaustion or unhanded theories.
55procedure s h i f t ( n : Index ; A : in out V e c t o r )
  # p o s t f o r a l l K i n I n d e x range 1 . . n  1 =>
  # ( A (K) = A~(K+ 1 ) ) ;
i s begin
f o r KinIndex range Index ‚Äô F i r s t + 1 . . n
60 loop A(K 1) := A(K ) ; end loop ;
end s h i f t ;
(h)REFUTED claim (post-condition).
procedure swap (A : in out V e c t o r ; J , K : inIndex )
  # p o s t A (K) = A~( J ) and A ( J ) = A~(K ) ;
65i sT : I n t e g e r ; begin
T := A(K ) ; A( J ) := A(K ) ; A(K) := T ;
end swap ;
Fig. 1. Examples used to contrast conventional S YMEXEand XSYMEXE(excerpt, e.g., SPARK derive clauses are elided)
state at the cutoff point. Thus, on the fourth evaluation of
Line 28, the unconstrained value of A(5) gets copied into A(4) .
Being unconstrained, this value can be EMPTY and hence,
subsequent evaluation of the post-condition results in a claim
violation because the Ô¨Årst quantiÔ¨Åer‚Äôs body (namely, A(K) /=
EMPTY ) is F ALSE when Kis 4.
Solution: XSYMEXEprecisely tracks when over-approxima-
tion is introduced, during the evaluation of an assume state-
ment (such as a precondition), due to bound cutoffs, Kiasan
qualiÔ¨Åes that the postcondition is R EFUTED?. It justiÔ¨Åes the
‚Äú?‚Äù qualiÔ¨Åcation with an explication consisting of: (1) the
assumption expression context where over-approximation was
introduced, and (2) a counter-example in support of the claim
violation. Of course, due to over-approximation, the counter-
example may not satisfy the (full) precondition.
Issue: False alarm from over-approximation due to unhan-
dled theories is illustrated in Figure 1(c) where the procedure
contract is correct, but (conventional) S YMEXEwould report
a violation of the post-condition (Line 33) as we explain
next. While the precondition sufÔ¨Åciently constrains the values
ofIandJto ensure that Qis in the stated range in the
post-condition, the multiplication I * J at Line 34 introduces
non-linear arithmetic which, at best, is partially handled, and
generally completely unhandled, by many DP. (While integer
non-linear arithmetic is used in this example, there are other
theories that are undecidable/unsupported by even the most
advanced DPs‚Äî e.g., Ô¨Çoating point, unbounded strings.) Acommon S YMEXEstrategy in such situations is to introduce
uninterpreted functions (abstracting away sub-expressions over
unhandled theories) along with basic axioms over them‚Äî e.g.,
for multiplication: a non-negative number multiplied by a non-
negative number yields a non-negative number. This introduces
an over-approximation which, for this example, would lead a
conventional S YMEXEtool to wrongly conclude that the post-
condition can be violated.
Solution: XSYMEXEprecisely tracks over-approximation for
unhandled theories due to the use of uninterpreted functions.
In addition, Kiasan can determine if a claim status depends
on such uninterpreted functions ( e.g., via a form of data
and control dependency analysis [11]) and if it does, Kiasan
reports the status as I NDETERMINATE , indicating that evidence
cannot be generated to refute the claim and that, as opposed
to the example in Figure 1(b), re-running XSYMEXEwith
higher bounds will do nothing to help. In situations where
uninterpreted functions are introduced and a particular claim
violation does not depend on them, then Kiasan can conclude
that the claim is R EFUTED .
Issue: Uncovered claims. Naive approaches to S YMEXE
simply report when a claim is (possibly) violated. In these
approaches, the absence of a claim violation could lead the
developer to incorrectly conclude that a claim can never be
violated. However, it is possible that the bounding strategy
used by S YMEXEhas simply cutoff some paths‚Äîcreating
an under-approximation that misses evaluating the claims.For example, when S YMEXEis applied to the example of
Figure 1(d) with a loop bound of 4, the last iteration of the
loop will never be executed, the path to the claim at Line 39
will be cutoff, and nothing will be reported about this claim.
Solution: Kiasan reports this claim as U NCOVERED , and it
produces explications that includes bound cutoffs that may be
blocking the execution of the claim along with paths from the
bound cutoff points to the uncovered assertion.
Issue: Distinguishing dead from uncovered code/claims.
Some claims lie along paths for which no concrete execution
exists. Even if code coverage is used, conventional S YMEXE
algorithms cannot distinguish between claims and code that
are uncovered due to cutoffs (as in Figure 1(d)) from claims
or code that are semantically unreachable (as in Figure 1(e) ).
Solution: Because XSYMEXEtracks where paths are cutoff
due to bound exhaustion, Kiasan can identify claims and code
that are semantically unreachable from claims and code that
are merely uncovered. (While the example in Figure 1(e)
uses non-linear arithmetic, because of the basic axiom added
on non-negative multiplications mentioned previously, Kiasan
can conclude that the claim and code are dead.) A claim or
code is reported as D EAD if it is uncovered and there are no
bound cutoffs along S YMEXEpaths from which the code in
question is reachable in the procedure control Ô¨Çow graph. Dead
code detection is important for critical embedded systems. In
fact, in some sectors such as avionics, dead code must be
removed to comply with, e.g., DO-178C. Many dead code
detection approaches rely on data Ô¨Çow frameworks or syntactic
detection; our approach is more powerful (potentially detecting
more dead code and generates less number of false alarms)
because it considers infeasible path conditions.
Issue: UndeÔ¨Ånedness (exceptions) during claim evaluation.
Because claims are built from programming language expres-
sions, their evaluation can lead to run-time exceptions. Such
claims are ‚Äúfaulty‚Äù because their evaluation in a particular state
may not return a deÔ¨Ånite truth value. Figure 1(f) illustrates
a faulty contract with a post-condition that will generate a
range check violation at A(K+1) . It is important for developers
to understand when their claims are faulty because no useful
veriÔ¨Åcation conclusions can be drawn from them; eliminating
such exceptions from claims should be one of the Ô¨Årst tasks
in a contract-based quality assurance methodology.
Solution: Because XSYMEXE: (1) decomposes each contract
into primitive claims, and (2) tracks the veriÔ¨Åcation status
of both explicit and implicit claims, Kiasan reports that the
contract of Figure 1(f) is F AULTY . To explain why the contract
is F AULTY , it also provides an explication listing implicit
claims (runtime checks) in the contract, and a counterexample
for such claims that are R EFUTED .
Issue: Is a veriÔ¨Åed claim really veriÔ¨Åed? Conventional S YM-
EXEapplied to Figure 1(g) may report no violations and offer
no clear indication of the actual claim status. Has the post-
condition been exhaustively validated for all possible states?Solution: In analyzing this example, Kiasan relies only on
the manipulation of logic constraints that are (completely)
supported in the theories of the underlying DP and does not
give rise to under-approximations due to bounding as long
as the loop and array bounds are greater than Index‚ÄôLast . If
the latter is not true, then V ERIFIED?is reported, hinting to
the developer that an increase in the loop and array bounds
might enable XSYMEXEto report that the contract has been
unequivocally V ERIFIED , which is the case for this example.
Note that no loop invariant is needed to verify the example.
Issue: Is a refuted claim really refuted? As was alluded to
earlier, a common pitfall of static analyses is that they produce
too many false alarms that negatively impact one‚Äôs ability
to correct true claim violations. Many S YMEXEtools: (1)
introduce over-approximations that can lead to false alarms,
and (2) do not precisely track when such approximations
have been introduced. Thus, they are unable to distinguish
a potential false alarm from an actual claim violation.
Solution: Kiasan does not introduce any over-approximations
when run on the example of Figure 1(h) . Because XSYMEXE
precisely tracks when over-approximations are introduced,
Kiasan is able to report that the claim represented by this
contract can be R EFUTED . Moreover, it yields an explication
in the form of a concrete test case and counter-example:
e.g., a pre-state having J=2,K=1,A(J)=1,A(K) =0 that leads
to violation of the postcondition‚Äîthe bug is that the Ô¨Årst
assignment‚Äôs right-hand side should be A(J).
B.SYMEXE: Basic Formalization
In this section, we present a basic formalization of S YMEXE,
giving enough mathematical machinery to enable us to rigor-
ously explain claim reporting and its associated semantics.
1) Procedures and Commands: Without loss of generality,
we focus our technical deÔ¨Ånitions on procedural units and
execution states for those units that include bindings of the
procedure‚Äôs local variables, parameters, and global variables
that are either read or written by the procedure. We will
assume (unless stated otherwise), that our formal deÔ¨Ånitions
given below apply to the context of a given procedure P.
As is commonly done in works formalizing program cor-
rectness for imperative languages, we assume that our core
command language includes the basic assume andassert
statements which are used, in particular, to encode the pre-
and post-conditions of procedure contracts. Execution of an
assert statement whose expression evaluates to true, has no
effect, otherwise, the procedure‚Äôs execution is said to terminate
inerror . Similarly, execution of an assume statement whose
expression evaluates to true, has no effect, otherwise, the pro-
cedure‚Äôs execution is said to terminate due to infeasibility [12].
For simplicity, procedure contracts are embedded in the pro-
cedure‚Äôs code as assume ( e.g., precondition) and assert ( e.g.,
postcondition) statements via program transformation [13].
2) Concrete and Symbolic Stores: Astore is a Ô¨Ånite partial
function relating variables ( Var) to their values. A concrete
store ,C2Var*ValueC, associates variables to concretevalues ValueC. Since symbolic execution manipulates both
ValueCand symbolic values, we deÔ¨Åne a symbolic store
S2Var*ValueS, where ValueCValueS.
3) Concrete and Symbolic States: Aconcrete state sC=
(l; C)is a pair consisting of a program point (also called
a label)land a concrete store C, where intuitively, C
represents the value of the program variables immediately
before the command at lis executed. We say that sCis a
state forl. Similarly, a symbolic state sS= (l; S; ; g )
is a tuple consisting of: a program point, a symbolic store, a
path condition , consisting of a Ô¨Ånite set of formulae that act
as constraints on symbolic values in the store, and a status
Ô¨Çag used to indicate, among other things, whether a state
is ‚Äúnormal" or ‚Äúpotentially over-approximating‚Äù (explained
further below). We also say that sSis astate forl.
LetC
PandS
Pdenote the concrete and symbolic state sets
of the procedure P, respectively. When referring to state sets
generically, we shall omit the PqualiÔ¨Åer on the name.
4) Concrete Execution: Aconcrete path C=sC
1;sC
2;:::
for procedure Pis a possibly inÔ¨Ånite sequence of one or more
concrete states representing the states generated by executing
commands in Pfrom the initial state sC
1. Similar to [12], we
have each Ô¨Ånite path CforPend in a Ô¨Ånal state sC
nhaving a
special label ln2fNORMAL;ERROR;INFEASIBLEgdenoting
the path termination status. An I NFEASIBLE state results from
an assume statement‚Äôs expression evaluating to false . Assume
statements are used, e.g., to encode preconditions. We let C
P
denote the set of all possible concrete paths in P. The program
pointlinPis said to be reachable iff there exists a path in C
P
containing a state for l; otherwise it is said to be unreachable
ordead .
5) Symbolic Execution: Asymbolic path S=
sS
1;:::; sS
n2S
Pfor procedure Pis a sequence of
one or more symbolic states representing the states generated
by symbolically executing commands in Pfrom the initial
statesS
1. Unlike concrete paths, symbolic paths are not
required to end in a state for one of the special terminal
labels. This models the fact that a symbolic path may be
partial due to a S YMEXEbounds cutoffs ,e.g., array, loop,
or call-chain bounds. For simplicity, we often refer to
user-conÔ¨Ågurable analysis bounds ( e.g., loop bound, bounding
on arrays, timeout) simply as ‚Äúbounding‚Äù. We call a symbolic
path complete iff it ends in a state for one of the special
terminal labels, and it is termed incomplete otherwise.
sS
1ES
>sS
2
sC
1/
EC
>sC
2/
Fig. 2. Commutativity of Con-
crete Execution and S YMEXE6) Soundness: Since we use
SYMEXEfor formal veriÔ¨Åcation as
opposed to just bug Ô¨Ånding, we
deÔ¨Åne a binary simulation rela-
tion (/) [14] relating concrete and
symbolic states such that sC/ sS
whensSover-approximates (ab-
stracts orsimulates )sC. A sym-
bolic state and the concrete states
that it abstracts, always agree on their program point. A
concrete path C=sC
1;sC
2;::: isover-approximated by a
symbolic path S=sS
1;:::; sS
n, on its Ô¨Årst n1states,denotedCn/ S, iffCis at least of length nandsC
i/ sS
i
for all 1in. WhenCandSare both of length nand
Cn/ S, then we simply write C/ S. SYMEXEissound
iff Figure 2 commutes, where a step of concrete/symbolic
execution is denoted by EC,ES, respectively.
III. C LAIMS
We address the checking of developer claims written in a
formal speciÔ¨Åcation language that state desired properties of
programs written in a particular programming language . Sev-
eral approaches have been proposed for interpreting claims. In
themathematical interpretation approach taken in languages
such as the current version of S PARK [9], claims are viewed as
pure logical formula whose evaluation completes in a single
step yielding either true orfalse as a result.
In this work, we adopt the executable interpretation ap-
proach [15] to align with the semantics of speciÔ¨Åcations to
be used in the next generation of S PARK based on Ada 2012.
In the executable approach, claims are decomposed to atomic
boolean expressions in the programming language. Interpret-
ing a claim amounts to executing the boolean expressions
to which it decomposes. Thus, claim evaluation does not in
general proceed in a single atomic step; it may have the
possibility of terminating abnormally due to ill-formed sub-
expressions (array accesses with out-of-bound indices, divide-
by-zero errors, etc.), a.k.a. , undeÔ¨Ånedness [15], as illustrated in
Figure 1(f). In the subsequent subsections, we give a top-down
description of concrete and symbolic evaluation of claims‚Äî
beginning Ô¨Årst with the developer‚Äôs view of claim evaluation
and then drilling down to the details of claim decomposition.
A. Concrete Evaluation of Claims
Because S YMEXEis a path-sensitive analysis, we Ô¨Årst
address the evaluation of a claim at a particular state along
a path and then derive the semantics of a claim by summariz-
ing across all paths. Whenever the command at a program
pointlis a claim in the form of an assert or assume
statement, we use Clto denote the claim at l. We deÔ¨Åne
CHECK CLAIMC(sC;Cl) :BOOL?to be a function, return-
ing either T RUE, FALSE or U NDEFINED , that represents the
concrete evaluation of Clin concrete state sCwhose program
point isl. (SincesCis a state for l, providing Clas a
second argument is unnecessary, but including it provides
uniformity in the arguments of the semantic functions deÔ¨Åned
later.) To build towards the developer‚Äôs intuitive understand-
ing of the meaning of Clacross a set of executions C,
we deÔ¨Åne the concrete collecting summary of Cl, denoted
COLLECT CLAIMC(C;Cl) :P(BOOL?), as the union of all
possible concrete execution results of Clacross all paths in
C.
The concrete interpretation of a claim is the conclusion
that a developer can draw about Clbased on its concrete
behavior across allexecutions in C; INTERP CLAIMC(C;Cl)
is deÔ¨Åned as follows:
(D) D EAD iff C OLLECT CLAIMC(C;Cl) = ;,i.e., Clnever
appears in the paths C(it is unreachable).(V) V ERIFIED iff C OLLECT CLAIMC(C;Cl) =fTRUEg,i.e., Clis
reachable and is T RUE in all states in which it is encountered.
(R) R EFUTED when F ALSE2COLLECT CLAIMC(C;Cl),i.e., Cl
is reachable and is F ALSE on at least one path.
(F) otherwise, when
UNDEFINED 2COLLECT CLAIMC(C;Cl),i.e., Clis reachable
and is U NDEFINED on at least one path.
In those situations above where more than one ‚Äúwhen‚Äù case
holds true then the Ô¨Årst case is chosen.
B. Symbolic Evaluation of Claims
1) Symbolic Claim Check: Let C HECK CLAIMS(sS;Cl) :
BOOL?
?be the result of symbolically evaluating the claim Cl
in the symbolic state sS(for Cl), where B OOL?
?=BOOL?[
fDONTKNOW;FALSE?;UNDEFINED?g. While this function is
generally implemented by a call to a decision procedure (DP),
preprocessing and optimization steps may be applied before
and/or instead of calling the DP. Details will be given in
Section IV, and as will be explained there, D ONTKNOW
represents the situation where the decision procedure itself
returns ‚Äúdon‚Äôt know‚Äù or when a particular theory used in the
primitive assertion is not supported by the decision procedure.
FALSE?and U NDEFINED?, read as ‚Äúmaybe false‚Äù and ‚Äúmaybe
undeÔ¨Åned‚Äù, will be explained in Section III-B3 after the
introduction of some essential terminology.
2)SYMEXEBound Exhaustion and Cutoff Paths: As ex-
plained in Section II, in bounded S YMEXE, some symbolic
paths are terminated prematurely due to bound exhaustion. We
refer to these as cutoff paths , which are instances of incomplete
paths mentioned in Section II-B5. We say that Clisimpacted
by the cutoff path Sof lengthnterminating in a state sS
niff
there exists a concrete path Ccontaining a state sC
ifor Cl,
wherei>n , for which Cn/ S. Intuitively, a claim that is
impacted by a cutoff causes inconclusiveness in the analysis
results due to the cutoff, because there are behaviors that are
not analyzed that might affect the claim‚Äôs status.
The detection of the potential impact of a claim Clby a
cutoff can be seen as a reachability problem since a cutoff
at a program point lncould prevent the Ô¨Çow of control from
continuing to Cl. We deÔ¨Åne a conservative approximation of
cutoff impacts using a Control Flow Graph (CFG) as follows.
LetSbe a cutoff path, then we say that Clispotentially
impacted byS, and write Cl2CUTOFFIMPACTS (S), iff
Clcan be reached from ln(the program point of the Ô¨Ånal
state inS) in the CFG. (A more precise C UTOFFIMPACTS
can be deÔ¨Åned using control and data dependencies instead of
CFG reachability; we opt to use CFG here for simplicity.)
3)SYMEXEBound Exhaustion in Assume Contexts: A
SYMEXEbound exhaustion results in a cutoff in every execu-
tion context except that of an assume statement, in which case
the assume expression evaluation is stopped (and the symbolic
constraints accumulated up until that point are preserved); in
such cases, the Boolean sub-expression is assigned a non-
deterministic value and S YMEXEcontinues to the sibling
Boolean sub-expression of the assume statement, if any (oth-
erwise, S YMEXEcontinues to the next statement). Because
a non-deterministic value is introduced, the symbolic statestatus Ô¨Çag gdescribed in Section II-B is set to indicate
that the state (and all its successors) are potentially over-
approximating. This is how the over-approximation discussed
for the example of Figure 1(b) is tracked. In general, over-
approximation may result in false alarms, but the alternative
is to halt the exploration of the path ‚Äì which would typically
give less feedback to developers about the remaining procedure
code and contract clauses. We can now clarify that the pre-
viously mentioned C HECK CLAIMS(sS;Cl)outputs F ALSE?
and U NDEFINED?represent the situations where the DP yields
FALSE or U NDEFINED (respectively), but that sSis Ô¨Çagged
as potentially over-approximating (due to a bound exhaustion
taking place during the symbolic evaluation of an assume
statement at some point earlier in the path).
4) Collecting Summary: Analogous to the concrete case,
we deÔ¨Åne the symbolic collecting summary of Cl, denoted
COLLECT CLAIMS(S;Cl) :P 
BOOL?
?[fCUTOFFg
, as
the union of: 1) all symbolic execution results of Cl
across all paths in Sas reported by C HECK CLAIMS, and
2)fCUTOFFg, if Clcan be potentially impacted by a cutoff
path in S.
5) Symbolic Interpretation: We now deÔ¨Åne the symbolic
interpretation of Clto represent the conclusions that a devel-
oper can draw about this claim from the results of S YMEXE.
INTERP CLAIMS(S;Cl)is deÔ¨Åned as follows:
(D) D EAD iff C OLLECT CLAIMS(S;Cl) =;.
(V) V ERIFIED iff C OLLECT CLAIMS(S;Cl) =fTRUEg.
(R) R EFUTED when F ALSE2COLLECT CLAIMS(S;Cl).
(F) FAULTY when U NDEFINED 2COLLECT CLAIMS(S;Cl).
(R?) R EFUTED?when F ALSE?2COLLECT CLAIMS(S;Cl).
(F?) FAULTY?when U NDEFINED?2COLLECT CLAIMS(S;Cl).
(U) U NCOVERED iff C OLLECT CLAIMS(S;Cl) =fCUTOFF g.
(V?) V ERIFIED?iff
COLLECT CLAIMS(S;Cl) =fTRUE;CUTOFF g.
(I) INDETERMINATE otherwise.
As before, when more than one ‚Äúwhen‚Äù case occurs in the
interpretation of the above, the Ô¨Årst case is taken as deÔ¨Åning.
IV. P RIMITIVE CLAIMS AND THEIR SEMANTICS
Thus far, we have explained the semantics of claims from a
developer‚Äôs perspective. In this section, we describe how the
concrete and symbolic C HECK CLAIM methods are realized.
A. Primitive Claims and Classical DPs
Programmers have a natural intuitive understanding of the
execution of a claim expression yielding either T RUE, FALSE
or, in situations where execution cannot terminate normally
(e.g., due to an exception) U NDEFINED . This leads to logical
formula over a 3-valued logic [15]. Almost all DPs operate
over theories expressed in classical 2-valued logic. Hence, we
adopt an approach that we developed earlier for use in the
Java Modeling Language [15] and explained next.
Generally speaking, a developer claim C consists of n
primitive claims A i, for 1in. We use the term deÔ¨Åning
primitive claim (A d) to refer to A n(the primitive claim that de-
Ô¨Ånes the logical meaning of the developer claim after all sub-
expressions have been evaluated), and supporting primitive
claims (A s) (e.g., array bounds checks and other range checksrequired by Ada on sub-expressions in the developer claim) to
mean an A i, for1i<n . Due to the lack of space, we omit
the full details of how a composite claim is decomposed into
primitive claims. We do note here that supporting primitive
claims are generated, among other reasons, to encode (2-
valued) conditions whose truth will guarantee that evaluation
of the ‚Äúrest‚Äù of the claim will not result in U NDEFINED ‚Äîe.g.,
a claim expression involving division will have a supporting
primitive claim asserting that the divisor is not zero.
B.CHECK PRIMSand Decision Procedure
The checking of the developer claim via C HECK CLAIMSis
deÔ¨Åned in terms of the more elementary C HECK PRIMS, which
is applied to constituent primitive claims. C HECK PRIMSis
in turn deÔ¨Åned via calls to a decision procedure. We now
explain how C HECK PRIMS(sS;A)can return T RUE, FALSE ,
DONTKNOW , or F ALSE?.
Consider the case where S YMEXEreaches a primitive claim
A on a state sS. In C HECK PRIMS(sS;A), we are interested
in determining validity of A under sS. Typically, this is
implemented as a call to a decision procedure such as a
SatisÔ¨Åability Modulo Theory (SMT) solver like, e.g., Z3 [16]
and Yices [17]. SMT solvers do not directly tell us if an
assertion is valid since they are designed to check satisÔ¨Åability
of a formula instead of the formula‚Äôs validity . We abstract the
means by which we determine validity through satisÔ¨Åability
checkers behind an interface we call DP+, which returns
TRUE, FALSE , DONTKNOW .
We require DP+to be sound; that is, it may at most intro-
duce over-approximation (possibly generating false alarms),
but not under-approximation (which could result in missed
detection of ‚Äúbugs‚Äù). Claim expressions over undecidable
theories are the main reason for over-approximation, and un-
fortunately, most interesting programs deal with theories that
are undecidable ( e.g., non-linear arithmetic and unbounded
string theories). In such cases, a DP+may not be able to
give a deÔ¨Ånite answer; that is, it may give up producing an
answer when it tries to reason about state constraints involving
undecidable theories and hence return D ONTKNOW .
We design our tool to work with multiple SMT solvers,
but this is complicated by the fact that the solvers differ in
their reasoning strengths and/or the theories that they (directly)
support. For example, Yices has no support for non-linear
arithmetic, while Z3 tries its best to conservatively solve
non-linear arithmetic constraints; neither supports theories of
unbounded strings or Ô¨Çoating point numbers. The typical
workaround for constraints involving theories not supported by
the underlying solver is to weaken such constraints by using
uninterpreted functions. While this approach is sound, it leads
to over-approximation.
Thus, to distinguish conclusive results, we design
CHECK PRIMS(sS;A)to return T RUE only if the claim is valid
(provably true), F ALSE only if the claim is invalid (provably
false). C HECK PRIMScan achieve this by a post-processing
step after calls to DP+as follows. Let UT (sS;A)returns
true iffsSor A contain terms from unhandled theories. IfDP+(sS;A) = FALSE , then C HECK PRIMS: returns F ALSE ,
if:UT(sS;A); otherwise, D ONTKNOW . A naive UT can be
deÔ¨Åned as: the path condition in sSand the constraint in A
involves weakening for unhandled theory. If DP+answers
TRUE or D ONTKNOW , the answer is directly returned by
CHECK PRIMSregardless whether the constraint involves un-
handled theory.
Note that this naive UT may sometimes be overly conser-
vative, but can be improved. For example, when using Yices
where non-linear arithmetic is unsupported, one can ‚Äúemulate‚Äù
multiplication by using an uninterpreted function, but with,
e.g., the following sign axiom: multiplication of non-negative
numbers yields a non-negative number. In certain cases where
such axiom applies, DP+can give a deÔ¨Ånite answer. This
can be detected by further queries to the underlying solver.
Moreover, UT can be reÔ¨Åned further by using a cone of
inÔ¨Çuence (data dependence) analysis and control dependence
analysis (See the technical report version of this paper for
more discussion [18].)
In Section III-B3, we described that we may have an over-
approximation while evaluating an assumption. In such case,
if the DP+returns F ALSE , it maybe a false alarm introduced
by the over-approximation. Thus, to distinguish this case with
the case where we can conclusively determine that the as-
sertion is provably invalid, C HECK PRIMSexamines the over-
approximating Ô¨Çag ginsS; it returns F ALSE?whengis set,
which indicates there was an assumption over-approximation
along the path. A test case can be generated to try to convert
FALSE?to F ALSE ; that is, if the test case execution reÔ¨Ånes
the symbolic path (a witness that refutes the claim), then
CHECK PRIMSshould return F ALSE .
Due to the lack of space, we omit the deÔ¨Ånitions of
COLLECT PRIMS(S;Al)and I NTERP PRIMS(S;Al)since
they are quite similar to those for developer claims.
C.CHECK CLAIMS
Finally, we can explain how symbolic claim checking is
deÔ¨Åned in terms of its constituent primitive claims. Thus, for a
claim A, C HECK CLAIMS(sS;C) :BOOL?
?(where B OOL?
?=
BOOL?[fDONTKNOW;FALSE?;UNDEFINED?g) is deÔ¨Åned
in terms of the primitive claims of C and C HECK PRIMS
(whose return values are T RUE, FALSE , D ONTKNOW and
FALSE?) as follows:
UNDEFINED when C HECK PRIMS(sS;As) = FALSE , for any
supporting assertion A s.
UNDEFINED?when C HECK PRIMS(sS;As) = FALSE?, for
any supporting assertion A s.
DONTKNOW when C HECK PRIMS(sS;As) = DONTKNOW ,
for any A s.
The value of C HECK PRIMS(sS;Ad)when
CHECK PRIMS(sS;As) = TRUE for all A s.
Again, when more than one ‚Äúwhen‚Äù case occurs in the
interpretation of the above, the Ô¨Årst case is chosen.
V. C LAIM EXPLICATION
The main goals of XSYMEXEare to be more precise about
the conclusiveness of contract checking results and to pro-
vide informative evidence for each of the results. XSYMEXEexplications are multi-tiered so that developers can see an
initial explication for a developer claim status and then drill
down through multiple levels of abstraction for more details‚Äî
including results of claim checking on individual paths as well
as results for the primitive claims that make up a developer
claim. Explications for both developer and primitive claims are
organized according to the set of status results obtained when
collecting the results of claim evaluation across all paths. For
example, the top-level report may indicate that a developer
claim is R EFUTED in a situation where the claim‚Äôs deÔ¨Åning
primitive claim is F ALSE along some paths and T RUE along
other paths. In this case, explication drill-down yields two
categories of explications (one for the T RUE paths and one
for the F ALSE paths). Drill-down through the T RUE category
produces a collection of concrete and symbolic paths for when
the primitive claim is T RUE (similarly for the F ALSE case).
The table below describes the nature of the explications for
each status category that can be returned by C OLLECT PRIMS.
Collect category Explication
FALSE c/s-counter-examples, program location
TRUE c/s-path
CUTOFF partial c/s-path, cutoff-location, path chop
DONTKNOW s-path, unhandled theory program locations
FALSE?c/s-counter-example, over-approx. location
FALSE : To illustrate an assertion refutation, it is sufÔ¨Åcient to
generate a counter-example demonstrating that the assertion
does not hold under a certain circumstance. It is also helpful
to highlight the assertion‚Äôs source-level program location (re-
gion); this is especially valuable for identifying the source of
undeÔ¨Ånedness of a claim‚Äôs supporting assertion.
TRUE: As an evidence of an assertion veriÔ¨Åcation, it is useful
to generate a (concrete/symbolic) c/s-path (or a test case)
demonstrating that the assertion holds.
CUTOFF : To illustrate an assertion impacted by a cutoff,
we generate a partial c/s-path demonstrating the program
execution leading to the cutoff point; this is coupled with
generating a possible path (chop) description/visualization
illustrating how program control can transfer from the cutoff
program location to the assertion.
DONTKNOW : We can output a symbolic path to illustrate an
assertion whose validity cannot be determined; unfortunately,
due to the unhandled theory issue described in Section IV-B,
it may not always possible to generate a concrete path. Thus,
we can only guarantee to output a symbolic path. Hence, it
is helpful to also highlight program points that give rise to
constraints with unhandled theory.
FALSE?: Recall that F ALSE?can only happen when there is
an assumption over-approximation impacting an assertion that
is refuted (under that over-approximating assumption). Thus,
we can generate c/s-counter-examples illustrating the assertion
refutation. As mentioned previously, the counter-examples
may not fully satisfy the assumption. Thus, it is helpful to
also highlight the program point where the assumption over-
approximation occurred.VI. E VALUATION
To evaluate our approach, we implemented XSYMEXEin
Bakar Kiasan and applied it to an extended set of examples
including the examples of Section II-A, standard sorting
algorithms used for benchmarking, and representatives of
data structures used to maintain data packet Ô¨Åltering and
transformation in embedded security applications. The latter
set is derived from a Rockwell Collins code base and uses
arrays to provide a ‚Äúlinked list‚Äù set implementation (where
links are represented as indices in an auxiliary array) with
more efÔ¨Åcient additions/deletions. These units are relatively
small but generally have rich behavioral contracts since we
focus on compositional veriÔ¨Åcation of strong behavioral prop-
erties instead of (selective-search) whole program bug-Ô¨Ånding.
Note that many programs in safety/security-critical embedded
applications are relatively small in size.
Bakar Kiasan summarizes the developer claim statuses on a
per routine basis, as well as the individual statuses of primitive
and deÔ¨Åning claims in each developer claim. Status tokens,
as described in Section III-B5 (such as D,V,V?,etc.), are
provided along with claim status evidence like so:
Type S Col Explication
INDEX_LOWER@68 V T Paths (0,1,2)
. . . . . . . . . . . .
INDEX_UPPER@68 V T Paths (0,1,2)
POST check@68 R FT Failing Path (0@68), Paths (1,2)
Overall Status: R
The above is a condensed report excerpt for the swap pro-
cedure of Figure 1(h); the report summary style follows that
of S PARK ‚Äôs POGS. The report shows the veriÔ¨Åcation status
ofswap ‚Äôs postcondition (the Overall Status isRindicating that
the claim is refuted), including its supporting primitive claims
(e.g.,INDEX_LOWER ,INDEX_UPPER , which are array range
checks) and its deÔ¨Åning primitive claim ( i.e.,POST ). For each
primitive claim, the Scolumn gives the veriÔ¨Åcation status of
the primitive claim given by I NTERP PRIMS, the Colcolumn
gives the result of C OLLECT PRIMS, and the Explication column
gives links to the evidence that justiÔ¨Åes the status.
As can be observed from the report, there are three distinct
paths that soundly abstract allthe concrete executions of
swap ‚Äôs code/contract. The supporting claims are veriÔ¨Åed for
all executions, but the deÔ¨Åning claim is refuted by Failing Path
0, while the other two interestingly (perhaps unexpectedly)
satisfy the post-condition.
To complement this high-level summary, Bakar Kiasan also
generates detailed HTML reports that include source code
highlighting ( e.g., syntax highlighting, highlighting of prob-
lematic areas as described in Section V), and code coverage.
The HTML report illustrates each path as a test case with
visualization of its pre/post-states. Space constraints prevent
us from illustrating the HTML reports in sufÔ¨Åcient detail;
interested readers can Ô¨Ånd complete evaluation reports for all
our examples online [18].
Figure 3 presents the collective summary (%) of the claim
statuses for all examples mentioned at the start of this section.
This represents data for 31 explicit claims (recall that a(%) D V R F R? F? U V? I
Explicit 3.2 58.1 12.9 3.2 3.2 0.0 3.2 12.9 3.2
Implicit 0.4 89.0 0.3 0.0 0.0 0.0 0.2 9.9 0.2
Total 0.5 88.0 0.7 0.1 0.1 0.0 0.3 10.0 0.3
Fig. 3. Claim Status Distribution
claim, such as a post-condition of Figure 1(a), can consist
of a complex expression spanning several source lines and
calls to helper functions), and 972 implicit claims. For each
claim status, the table gives the percentage of claims that
have that status. Our goal here is not to suggest that the
given distribution is in any way representative of what might
be obtained if a different and larger sample of code was
analyzed. Rather, we believe that our main achievement is
that XSYMEXEisable to generate such results. As stated in
the introduction, our aim in the creation of XSYMEXEis not
to suggest a replacement for, say, VCGen-based veriÔ¨Åcation
technology, but to offer a fully-automated complementary
alternative that we have found most useful during the early
stages of contract and code development in critical systems.
As for the results themselves, to our surprise, the tool
pointed out some dead claims in our S PARK suite despite it
being used and analyzed in previous studies. The number of
VERIFIED claims is high, and the percentage for the other
statuses are low. This is what we would expect because our
SPARK code suite is fairly mature‚Äîthe contracts have been
repeatedly analyzed and (re-)worked. We anticipate that in
practice, developers will more frequently encounter faulty
and refuted claims as they write code/contracts, and they
will want to eliminate those as early as possible during
development ( e.g., analogous to experiences when coding in
a statically-typed language). Once those are addressed, their
veriÔ¨Åcation effort can then focus on the inconclusive statuses
(i.e., UNCOVERED , INDETERMINATE and those qualiÔ¨Åed with
‚Äú?‚Äù), which may require the use of higher-reward, higher-effort
techniques ( e.g., VCGen tools or using proof assistants).
The proportion of claim statuses that are conclusive vs.
those that are not is 4 for explicit claims and 8.5 overall. That
is, on average, our tool is able to report 8.5 conclusive claim
results for every 1 inconclusive one in our sample. While this
is a good ratio for XSYMEXE, more studies are needed to
better appreciate what the proportion may be on a larger and
perhaps evolving code in production.
VII. R ELATED WORK
Early work on the application of S YMEXEto the veriÔ¨Åcation
of safety-critical software is described by Coen-Porisini et
al.[19]. They used S YMEXEto verify properties, expressed in
a specialized Path Description Language (PDL), of functions
written in Safe-C, a very restricted dialect of C. In their
approach, a user must Ô¨Årst use tooling to semi-automatically
create a Ô¨Ånite program Execution Model (EM) which is then
used as input to the PDL Property Checker which in turn
reports the list of EM paths for which given properties hold.
Our work differs Ô¨Årstly in that Kiasan directly processes
SPARK speciÔ¨Åcations expressed as contracts as opposed toseparate properties written in a specialized language. S PARK
contracts are formed from predicates built from standard Ada
expressions. More importantly, Kiasan is fully automatic, and
does not require, e.g., user intervention in the creation of a
Ô¨Ånite model in the presence of while loops as is the case for
the EM generator. Forcing users to create Ô¨Ånite EMs side steps
many of the problems we address in XSYMEXE.
Our work was partly inspired by the S PARK [9] Proof
ObliGation Summariser (POGS) that: (a) summarizes the ver-
iÔ¨Åcation status of veriÔ¨Åcation conditions as they are processed
by different stages in the S PARK tool chain, and (b) uses
SPARK ‚Äôs ZombieScope tool to indicate code regions that are
semantically dead. Our aim was to see how this concept could
be adapted from: (1) the logical interpretation of contracts in
the current version of S PARK to the executable interpretation to
be used in the upcoming version, and (2) VCG ENto S YMEXE
so that developers could proÔ¨Åt from the beneÔ¨Åts of S YM-
EXE. SpeciÔ¨Åcally, in contrast to S PARK ‚Äôs VCG ENapproach,
SYMEXEnaturally generates counter-examples and test cases
as evidence, enables a number of helpful visualizations, and
does not require loop invariants to obtain an initial degree of
contract checking. In addition, S PARK ‚Äôs VCG ENtends to yield
an all-or-nothing approach when verifying contracts. Paths
through a procedure are broken into segments and a VC is
generated for each segment. Unless VCs for all segments are
discharged (or one is observed to be false), nothing meaningful
can be said about the veriÔ¨Åcation status of the contract.
With S YMEXE, a developer‚Äôs knowledge about the veriÔ¨Å-
cation status of a contract is much more continuous: imme-
diate feedback with a degree on inconclusiveness is provided
with low bounds and conclusiveness is increased as bounds
increase. POGS is less discerning. It only characterizes a VC
as discharged or undischarged; it does not distinguish between
an obligation that can be refuted from one whose status is
yet to be determined. Finally, our approach detects both dead
code and dead claims. This is beneÔ¨Åcial for identifying, e.g.,
portions of contracts that are not useful. ZombieScope can
detect dead code (and thus, detecting dead claims that are
inside the dead code regions); however, it does not detect dead
claims outside of code such as pre- and post-conditions as it
uses the logical contract interpretation.
Our discussion above applies, to some extent, to other
VCG ENtechniques such as ESC/Java tool family [20], [21],
Boogie [22], and Why [23]. Similar to S PARK tools, ESC/-
Java2 has dead code detection; however, it does not detect
dead claims. ESC/Java2, Boogie, OpenJML ESC, and Why
do not generate concrete counter-examples to illustrate claim
refutations. Some of these tools do provide counter-examples,
but not in a form that is familiar to developers, i.e., logical
formulae instead of test cases ( e.g., [21]); thus, it does not
scale well (in terms of clarity) to counter-examples involving
complex constraints. Similar to the S PARK Examiner, ESC
tools and Why do not distinguish provable claim refutations
from failed veriÔ¨Åcation attempts.
Some VCG EN-based tools such as Boogie can resort to a
form of eager bounded analysis by loop unrolling (hence, loopinvariants are not required), but, in such cases, it diminishes the
technique to merely bug-Ô¨Ånding. In contrast, XSYMEXEuses
dynamic lazy bounding, thus, XSYMEXEcan achieve veriÔ¨Åca-
tion when it determines all behaviors are within the bounds.
Moreover, we are not aware of their reporting capabilities ( e.g.,
evidence generation and result categorization), especially to
the extent of the work presented here. We believe our work
can be adapted to a bounded VCG EN-based approach as well.
Verifast [7] and jStar [8] are veriÔ¨Åcation tools based on
separation logic for checking claims about heap data. They
use an algorithmic approach to S YMEXEthat differs from that
are used in SPF, Klee, Bakar Kiasan, etc.. Instead of relying
on bounded checking, these tools require loop invariants and
inductive predicates over data structures to create symbolic
summaries of heap shapes. While these tools are beneÔ¨Åcial,
they target a different space, i.e., focusing on full veriÔ¨Åcation
of heap properties and require signiÔ¨Åcantly more annotations
to be added by developers. For counter-example information,
jStar can only generate program locations of interest when it
cannot verify claims. In addition, it does not discern undis-
charged claims (similar to the S PARK Examiner and VCG EN
tools above), and it does not address contract undeÔ¨Ånedness.
We believe bug Ô¨Ånding tools such as SPF [10], Klee [6],
and PeX [4] are useful, especially when applied to code as it
is being developed. However, because of many engineering
compromises such as selective search ( e.g., heuristic-based
symbolic state-space exploration), context bounding ( e.g., test
harness), etc., they do not provide guarantees when there is
no bug detected. Hence, such approaches are not be able to
verify claims or to precisely determine dead claims (or code).
Regardless, we believe our approach can be applied in
such under-/over-approximating settings. For example, in the
context of selective search, which causes some states to not
be explored, the states can be treated as cutoff points. Context
bounding is essentially an ad hoc form of assumption which
may produce under-/over-approximation; it is typically done
for testing certain code behaviors. As the code is geared for
veriÔ¨Åcation, it should be codiÔ¨Åed as a contract.
VIII. C ONCLUSIONS AND FUTURE WORK
We have argued that bounded S YMEXE, as commonly
implemented in the software engineering community, cannot
be applied effectively for veriÔ¨Åcation. Despite the fact that
it: (a) offers various usability advantages, and (b) typically
employs the same underlying decision procedure packages
as veriÔ¨Åcation condition generation (VCGen), the ad hoc
approaches taken in S YMEXEfor introducing optimizations
and over/under-approximations have prevented tools from re-
porting the precise veriÔ¨Åcation status of contract claims‚Äî
causing S YMEXEto take a back seat to other deduction based
techniques like VCGen in the context of veriÔ¨Åcation.
In this work, we have presented a collection of principles
that allow S YMEXEto be used conÔ¨Ådently in development
contexts that require veriÔ¨Åcation as opposed to just bug-
Ô¨Ånding. Furthermore, we have presented an approach by which
information accumulated during S YMEXEcan organized intoexplications that provide evidence-based justiÔ¨Åcations for the
resulting veriÔ¨Åcation status of claims. Although we have
demonstrated our approach in the context of the S PARK
framework, the principles that we have introduced can be
applied by other bounded S YMEXEtools as well.
The foundation presented here enables a number of in-
teresting future directions. For example, making veriÔ¨Åcation
status of claims explicit enables a synergistic combination with
other veriÔ¨Åcation tools ( e.g., VCGen-based tools): programs
are Ô¨Årst submitted to highly-automated XSYMEXEbased tech-
niques, and then only undischarged claims ( i.e., any status but
VERIFIED , REFUTED , DEAD) are handed off to downstream
veriÔ¨Åcation tools that require more manual effort.
REFERENCES
[1] J. C. King, ‚ÄúSymbolic execution and program testing,‚Äù Communications
of the ACM , vol. 19, no. 7, pp. 385‚Äì394, 1976.
[2] S. Khurshid, C. S. P ÀòasÀòareanu, and W. Visser, ‚ÄúGeneralized symbolic
execution for model checking and testing,‚Äù TACAS , pp. 553‚Äì568, 2003.
[3] K. Sen and G. Agha, ‚ÄúCUTE: A concolic unit testing engine for C,‚Äù in
ACM SIGSOFT FSE , 2005, pp. 263‚Äì272.
[4] N. Tillmann and J. de Halleux, ‚ÄúPex‚Äìwhite box test generation for
.NET,‚Äù in TAP, ser. LNCS, vol. 4966. Springer, 2008, pp. 134‚Äì153.
[5] C. Cadar, V . Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler,
‚ÄúExe: Automatically generating inputs of death,‚Äù ACM Trans. Inf. Syst.
Secur. , vol. 12, no. 2, 2008.
[6] C. Cadar, D. Dunbar, and D. Engler, ‚ÄúKlee: Unassisted and automatic
generation of high-coverage tests for complex systems programs,‚Äù in
USENIX OSDI , 2008, pp. 209‚Äì224.
[7] B. Jacobs, J. Smans, and F. Piessens, ‚ÄúA quick tour of the VeriFast
program veriÔ¨Åer,‚Äù in Asian Symposium on Programming Languages and
Systems (APLAS) , ser. LNCS, vol. 6461. Springer, 2010, pp. 304‚Äì311.
[8] D. Naudziuniene, M. Botincan, D. Distefano, M. Dodds, R. Grigore,
and M. J. Parkinson, ‚ÄújStar-Eclipse: an IDE for automated veriÔ¨Åcation
of Java programs,‚Äù in SIGSOFT FSE , 2011, pp. 428‚Äì431.
[9] J. Barnes, High Integrity Software‚Äîthe SPARK Approach to Safety and
Security . Addison-Wesley, 2003.
[10] C. S. Pasareanu and N. Rungta, ‚ÄúSymbolic PathFinder: symbolic exe-
cution of Java bytecode,‚Äù in ASE, 2010, pp. 179‚Äì180.
[11] A. V . Aho, R. Sethi, and J. D. Ullman, Compilers: Principles, Tech-
niques, and Tools . Addison-Wesley, 1986.
[12] M. Barnett and K. R. M. Leino, ‚ÄúWeakest-precondition of unstructured
programs,‚Äù in PASTE , 2005, pp. 82‚Äì87.
[13] J. Belt, J. Hatcliff, Robby, P. Chalin, D. Hardin, and X. Deng, ‚ÄúBakar
kiasan: Flexible contract checking for critical systems using symbolic
execution,‚Äù in NASA Formal Methods , 2011, pp. 58‚Äì72.
[14] D. A. Schmidt, ‚ÄúStructure-preserving binary relations for program
abstraction,‚Äù in The Essence of Computation , 2002, pp. 245‚Äì265.
[15] P. Chalin, ‚ÄúEngineering a sound assertion semantics for the verifying
compiler,‚Äù IEEE Trans. Software Eng. , vol. 36, no. 2, pp. 275‚Äì287, 2010.
[16] L. M. de Moura and N. Bj√∏rner, ‚ÄúZ3: An efÔ¨Åcient SMT solver,‚Äù in
TACAS , ser. LNCS, vol. 4963. Springer, 2008, pp. 337‚Äì340.
[17] B. Dutertre and L. de Moura, ‚ÄúThe Yices SMT solver,‚Äù Tool paper at
http://yices.csl.sri.com/tool-paper.pdf, August 2006.
[18] J. Hatcliff, Robby, P. Chalin, and J. Belt, ‚ÄúExplicating symbolic
execution (xSymExe): An evidence-based veriÔ¨Åcation framework,‚Äù
Kansas State University, Tech. Rep. SAnToS-TR2012-08-01, 2012,
santos.cis.ksu.edu/papers/ICSE13-xSymExe.
[19] A. Coen-Porisini, G. Denaro, C. Ghezzi, and M. Pezz√©, ‚ÄúUsing symbolic
execution for verifying safety-critical systems,‚Äù SIGSOFT Softw. Eng.
Notes , vol. 26, no. 5, pp. 142‚Äì151, Sept. 2001.
[20] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe,
and R. Stata, ‚ÄúExtended static checking for Java,‚Äù in PLDI , 2002, pp.
234‚Äì245.
[21] D. R. Cok, ‚ÄúImproved usability and performance of smt solvers for
debugging speciÔ¨Åcations,‚Äù STTT , vol. 12, no. 6, pp. 467‚Äì481, 2010.
[22] K. Leino, ‚ÄúThis is Boogie 2,‚Äù Manuscript KRML , vol. 178, 2008.
[23] J. C. Filli√¢tre and C. March√©, ‚ÄúThe Why/Krakatoa/Caduceus platform for
deductive program veriÔ¨Åcation,‚Äù in CAV. Springer, 2007, pp. 173‚Äì177.
View publication stats