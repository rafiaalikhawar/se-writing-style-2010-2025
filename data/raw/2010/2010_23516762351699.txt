Runtime Monitoring of Software Energy Hotspots
Adel Noureddine1,2, Aurelien Bourdon1,2, Romain Rouvoy1,2, and Lionel Seinturier1,2,3
1INRIA Lille – Nord Europe, Project-team ADAM, France
2University Lille 1 - LIFL CNRS UMR 8022, France
3Institut Universitaire de France, France
ﬁrstname.lastname@inria.fr
ABSTRACT
GreenIT has emerged as a discipline concerned with the op-
timization of software solutions with regards to their energy
consumption. In this domain, most of the state-of-the-art
solutions concentrate on coarse-grained approaches to mon-
itor the energy consumption of a device or a process. How-
ever, none of the existing solutions addresses in-process en-
ergy monitoring to provide in-depth analysis of a process
energy consumption. In this paper, we therefore report on
a ﬁne-grained runtime energy monitoring framework we de-
veloped to help developers to diagnose energy hotspots with
a better accuracy than the state-of-the-art.
Concretely, our approach adopts a 2-layer architecture in-
cluding OS-level and process-level energy monitoring. OS-
level energy monitoring estimates the energy consumption
of processes according to diﬀerent hardware devices (CPU,
network card). Process-level energy monitoring focuses on
Java-based applications and builds on OS-level energy moni-
toring to provide an estimation of energy consumption at the
granularity of classes and methods. We argue that this per-
method analysis of energy consumption provides better in-
sights to the application in order to identify potential energy
hotspots. In particular, our preliminary validation demon-
strates that we can monitor energy hotspots of Jetty web
servers and monitor their variations under stress scenarios.
Categories and Subject Descriptors
D.2.8 [ Software Engineering ]: Metrics
General Terms
Performance, Measurement, Experimentation
Keywords
Power Model, Power Monitoring, Proﬁling, Bytecode Instru-
mentation
ASE ’12, September 3Ð7, 2012, Essen, Germany1. INTRODUCTION
Energy-aware software solutions are becoming broadly avail-
able, as energy concerns is becoming mainstream. The in-
creasing usage of computers and other electronic devices
(e.g., smartphones, sensors) is continuously impacting our
overall energy consumption. Information and Communica-
tions Techonology (ICT) accounted for 2% of global carbon
emissions in 2007 [5] or 830 MtCO 2e1, and is expected to
grow to 1,430 MtCO 2ein 2020 [14]. ICT also consumed up
to 7% of global power consumption (or 168 Gigawatt, GW)
in 2008 [13]. This number is predicted to grow and double
to 433 GW in 2020 or more than 14.5% of worldwide power
consumption [13]. These values illustrate the opportunities
for eﬃcient ICT solutions to reduce carbon emissions and
energy consumption. Rising energy costs in computers and
mobile devices requires the optimization and the adaptation
of computer systems. In this domain, research in GreenIT
already proposes various approaches aiming at achieving en-
ergy savings in computers and software. However, most of
the state-of-the-art approaches either focus only the hard-
ware [8], or only oﬀer coarse-grained energy estimation feed-
back of software [4, 2].
In this paper, we therefore propose to gather ﬁne-grained ap-
plications’ power feedback information at runtime and with
similar accuracy as hardware monitoring while using only a
software approach. Our approach, called e-Surgeon , con-
sists of a system monitoring library (at the operating system
level), called PowerAPI , and a software monitoring agent,
called Jalen .e-Surgeon estimates the power consumption
of applications’ source code methods, in real-time, based on
raw information collected from hardware devices ( e.g., CPU,
network card) through the operating system (for Power-
API), and from raw information collected from software
(CPU time, bytes transmitted through network) through
bytecode instrumentation (for Jalen ). We use both state-
of-the-art power models and propose new models for esti-
mating the power consumption of software at a ﬁner grain.
As a ﬁrst implementation, we target Java-based applications
and we validate our approach using standard application
servers, such as the Jetty Web Server2. Our preliminary
results demonstrate that we can diagnose power hotspots of
Java-based applications at runtime, oﬀering opportunities
to reduce their power consumption.
1Metric Tonne Carbon Dioxide Equivalent
2http://www.eclipse.org/jettyPermission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00
160
The remainder of this paper is organized as follows. In Sec-
tion 2, we describe our motivations and the main challenges
we tackle. Section 3 describes our approach, the design of
our proposed architecture and our power models. Section 4
details the implementation of our prototype. In Section 5,
we report on the preliminary results we obtained and we
validate them using a stress benchmark for the Jetty Web
Server in Section 6. Related work is discussed in Section 7,
while we conclude in Section 8.
2. MOTIV ATION AND CHALLENGES
2.1 Motivation
Nowadays, power management of software and hardware
is achieved either through runtime coarse-grained monitor-
ing, or through analyzing dump ﬁles of the application’s
resources utilization [8, 12, 7]. Although these approaches
allow power management of software, they do not allow run-
time and ﬁne-grained monitoring of the applications. Fine-
grained monitoring and visualization have many advantages:
i)diagnose at a detailed level the power consumption and
detect power hotspots at the threads and methods level, ii)
provide detailed power information to be used for runtime
power-aware software adaptation, and iii)helps in provid-
ing insights to developers for producing power-eﬃcient code.
The Green Challenge for USI 2010 [1] has identiﬁed that
proﬁling applications to detect CPU hotspots is a winning
strategy for limiting the power consumption of applications.
Therefore, we argue that a ﬁne-grained approach for propos-
ing power-aware information is a keystone for future power-
aware systems and software.
2.2 Challenges
Hardware monitoring is usually achieved through additional
hardware measurement equipments, such as multimeters or
specialized integrated circuits (cf. Section 7). This ap-
proach oﬀers a precise and accurate measurement of the
power consumption of hardware components but at a cost
of an additional investment. However, it can neither moni-
tor the power consumption of software components, nor go
into the details of software classes and methods usages. We
rather believe that a scalable approach can be better ob-
tained through a software-centric approach. Monitoring the
power consumption of software has to yield many challenges
in order to build an accurate software-centric approach. We
outline some of the main diﬃculties that software monitor-
ing has to cope with if accurate monitoring is to be oﬀered:
•Accuracy. The biggest problem that software mon-
itoring tools face is providing accurate estimations of
power consumption based on various collected infor-
mation. Unlike hardware measurement, software ap-
proaches use power models in order to provide an esti-
mation of the power consumption of software compo-
nents. However, these estimations tend to have diﬀer-
ent degrees of accuracy and overhead.
•Overhead. As software approaches monitor the ex-
ecuting software and calculate a power estimation of
their consumption, an overhead is therefore always ob-
served. The latter depends both on the degree of ac-
curacy needed and on the size of the monitoring tooland the monitored application. This leads to a trade-
oﬀ between the accuracy requirements and the cost of
the software monitoring tool.
•Fine-grained. Many of the current approaches (cf.
Section 7) stop their power consumption estimation
at the process level. Some of these approaches provide
limited ﬁne-grained but still raw values (such as execu-
tion time of methods or active time of threads). How-
ever, providing ﬁne-grained estimation of the power
consumption of software components is not as intuitive
as mixing raw values and power models. The question
arises to know which raw values is needed. How can
we collect them? Which power models can we use and
in which context?
•Power Models. Models to estimate the power con-
sumption have already been proposed (cf. Section 7).
However, most of these models are coarse-grained and
hardware related, such as providing general formulae
for power consumption of the hardware components
(e.g., CPU, Network card). Models therefore need to
be optimized for our context of ﬁne-grained power con-
sumption computation.
Laying these challenges, we propose in the next section an
approach named e-Surgeon , for monitoring and proﬁling
applications at runtime.
3. E-SURGEON DESIGN AND APPROACH
In this section, we present our power monitoring approach
called e-Surgeon . We ﬁrst present e-Surgeon general ar-
chitecture, then we describe the power models we integrated.
3.1 Architecture
e-Surgeon architecture is composed from two distinct but
complementary parts: a system-level power monitoring envi-
ronment called PowerAPI ; and a software-level application
proﬁling environment called Jalen . These two parts work
along each other in order to provide accurate runtime energy
information at the application level (threads and methods
levels). Figure 1 depicts the overall architecture of our ap-
proach.
Figure 1: e-Surgeon Reference Architecture.1613.1.1 PowerAPI
PowerAPI architecture is a modular architecture built for
agile software programming. The core of the architecture are
power modules .PowerAPI is developed as separate mod-
ules that can be started or stopped at runtime upon needs. A
set of OS-dependent sensor modules ( e.g.,SCPU,SNetwork )
collect raw information about hardware resource utilization,
either directly from the devices or through the operating sys-
tem. These information are then exposed to another set of
OS-independent formula modules that uses our power mod-
els (cf. Section 3.2) to compute the power consumption of
each hardware component ( e.g.,FCPU,FNetwork ). These
modules also compute the power consumption of running
processes and applications per hardware resource. A local
database (DB in Figure 2) is also used to store static infor-
mation about the hardware resources and used to automat-
ically calibrate PowerAPI depending on the environment.
Finally, all these modules are managed through a life cycle
module. The latter allows to start, stop, add, remove or
modify modules depending on monitoring needs and com-
mands sent by applications.
Figure 2: PowerAPI Reference Architecture.
3.1.2 Jalen
Jalen is a software-level proﬁling architecture. It is respon-
sible for proﬁling running applications and estimating their
energy consumption at a ﬁner grain, i.e., at threads or meth-
ods level. Several proﬁling techniques can be used, such as
bytecode instrumentation or sampling the application. Each
of these methods have beneﬁts and drawbacks. The former
does not modify the code of the application, and provides
an overview of the application’s energy consumption. How-
ever, it is less accurate than code instrumentation. The
latter injects proﬁling code into the application’s code (or
bytecode), therefore allowing the proﬁler to capture all the
necessary events related to energy consumption. On the
other hand, instrumentation adds an overhead for running
the additional code. Our approach, however, does not spec-
ify a single method of proﬁling. We prefer to keep this as
a technical choice during implementation and to use dedi-
cated APIs to communicate with the proﬁler and the low-
level monitoring environment are to be respected.
The proﬁling part introspects the application at runtime,
collecting statistics about its resources utilization. Informa-
tion, such as methods durations, CPU time, or the num-
ber of bytes transferred through the network card, are col-
lected and classiﬁed at a ﬁner grain, e.g., for each method
of the application. Next, a correlation phase takes place to
correlate the application-speciﬁc statistics with the process-
level power information. Details on our power model for
the correlation are presented in Section 3.2. Finally, theper-method or per-thread power consumption information
is displayed to the user and can be exposed as a service (to
be used, for example, in an application’s autonomous adap-
tation cycle).
3.2 Power Models
We propose a comprehensive power model using our pro-
posed formulae as well as formulae taken from the state-of-
the-art. In [12], the energy cost of a software is computed
based on the following formula:
Esoftware =Ecomp +Ecom+Einfra (1)
Where Ecomp is the computational cost ( i.e., CPU process-
ing, memory access, I/O operations), Ecomis the cost of
exchanging data over the network, and Einfra is the addi-
tional cost incurred by the OS and runtime platform ( e.g.,
Java VM).
We base our model on a similar principle, taking into ac-
count the modular aspect of the power calculation ( e.g., the
sum of the power consumption of diﬀerent hardware com-
ponents). Infrastructure power, Einfra , is included in the
computational cost of our power models and in our proto-
type. Power (in watt) is computed as the energy consump-
tion (in joule) per unit of time (one second). From this, we
can abstract our global power formula to the following:
Psoftware =Pcomp +Pcom (2)
At this stage, we deﬁned two models, one for CPU com-
putational costs and one for network communication costs.
Pcomp is therefore equal to the CPU power consumed by
software, and Pcomis equal to the power consumed by the
network card for transmitting software’s data. Next, we
detail the CPU and network power models we use in Pow-
erAPI , and the CPU and network power models we use in
Jalen .
3.2.1 PowerAPI Power Models
CPU Model. The CPU power consumed by a speciﬁc ap-
plication (in our case we use process PIDs ) can be repre-
sented by the following formula:
PPID
CPU(d) =PCPU(d)×UPID
CPU(d) (3)
Where PPID
CPU(d) is the CPU power consumed by the speciﬁc
process PID during a given duration d,PCPU(d) is the over-
all CPU power during dandUPID
CPU(d) represents the process
CPU usage during d. Thus, our approach is to estimate the
power required by the CPU to execute the process PID. This
is achieved by computing the CPU percentage usage of the
PID by the overall CPU power during a given duration d.
Next, we detail our model in order to compute PCPU(d), the
global CPU power, and UPID
CPU(d), the process CPU usage.
Overall CPU power. The overall power consumption for
the majority of modern processors (CMOS3) follows the
standard equation [10]:
Pf,v
CPU =c×f×V2(4)
3Complementary Metal Oxide Semiconductor162Where fis the frequency, Vthe voltage and ca constant
value depending on the hardware materials (such as the ca-
pacitance and the activity factor). Thanks to this relation,
we note that power consumption is not always linearly de-
pendent to the percentage of CPU utilization. This is due
to DVFS ( Dynamic Voltage and Frequency Scaling ) and also
to the fact that power depends on the voltage (and subse-
quently the frequency) of the processor. For example, a pro-
cess at 100% CPU utilization will not necessarily consume
more power than a process running at 50% CPU utilization
but with a higher voltage. Therefore, a simple CPU utiliza-
tion proﬁler is not enough in order to monitor power con-
sumption. Our power model takes into consideration these
aspects of the CPU and allows accurate power consumption
monitoring.
According to formula (4), computing the overall CPU power
for a given time is equal to computing a static part (the con-
stant c) and a dynamic part (the frequency fand its associ-
ated voltage V). For the static part, the cconstant is a set
of data describing the physical CPU ( e.g., capacitance, ac-
tivity factor). Manufacturers may provide this constant, but
in most cases this value is missing. To alleviate this prob-
lem, we use the existing relation between the overall power
of a processor and its Thermal Design Power (TDP) value.
TDP represents the power the cooling system of a computer
is required to dissipate the heat produced by the processor.
Therefore, the overall CPU power can be associated with
the TDP as described in the following formula [11]:
PfTDP,VTDP
CPU/similarequal0.7×TDP (5)
Where fTDP andVTDP represent respectively the frequency
and the voltage of the processor within the TDP state . The
beneﬁt of using this formula is that TDP is a value provided
by most manufacturers. In our architecture, TDP is stored
inPowerAPI ’s local database.
For the dynamic part, the frequency fis associated to a spe-
ciﬁc voltage V. For a given voltage, one or more frequencies
are associated. Thus, lowering the voltage results in chang-
ing frequency. The other way around is also valid, although
in some cases a single voltage can support more than one
frenquency. Frequencies used by a processor are provided
by the operating system APIs, while voltages are given by
manufacturers.
Process CPU usage. In order to compute the CPU usage
for a given process (identiﬁed by its PID), we propose to
calculate the ratio between the CPU time for this PID and
the global CPU time (the time the processor is active for all
processes) during a duration d:
UPID
CPU(d) =tPID
CPU
tCPU(d) (6)
Our approach is inspired by well-known tools such as the
Top linux program4. Thus, the CPU power consumption in
a duration dand for a given frequency f,Pf
comp is equal to :
Pf
comp =0.7×TDP
fTDP×V2
TDP×f×V2×tPID
CPU
tCPU(d) (7)
4http://linux.die.net/man/1/topFinally, the CPU power consumption for a process Pcomp of
formula (2) is equal to the average of the CPU power of each
frequency balanced by the CPU time of all frequencies:
Pcomp =/summationtext
f∈frequenciesPf
comp×tf
CPU/summationtext
f∈frequenciestf
CPU(8)
3.2.2 Network Model
The network power of a process is calculated using a formula
similar to the CPU power formula. We base our model on
available information whether they are collected at runtime
or provided by manufacturers’ documentations. As a ﬁrst
step, we focus on Ethernet network cards. A similar model
using a linear equation can be applied for wireless network
cards [3], but we did not investigate wireless cards yet. We
obtain, from manufacturers’ documentations the power con-
sumed (in watt) for transmitting bytes for a certain duration
(typically one second) according to a given throughput mode
of the network card ( e.g., 1 MB, 10 MB). Our network power
model is therefore deﬁned as:
Powernetwork
process =/summationtext
i∈statesti×Pi×d
ttotal(9)
Where Pstate is the power consumed by the network card in
the state i(provided by manufacturers), dis the duration
of the monitoring cycle, and ttotal is the total time spent in
transmitting data using the network card.
In the next section, we detail the CPU and network power
models in Jalen .
3.3 Jalen Power Models
3.3.1 CPU Model
Using the information collected from proﬁling applications
and the monitored system, we are able to calculate a rea-
sonable estimation of the CPU time per method. And we
use this information to compute the CPU power consumed
per method and thread. As application code is generally
executed inside threads ( i.e., Java), we ﬁrst calculate the
power consumed per thread. For that, we apply the follow-
ing formula:
PowerCPU
thread =TimeCPU
thread×PowerCPU
process
Duration cycle(10)
Where TimeCPU
thread is the CPU time of the thread in the last
monitoring cycle (obtained from the environment, such as
the OS or the JVM), PowerCPU
process is the power consumed
by the application process in the last monitoring cycle (ob-
tained from PowerAPI ), and Duration cycle is the dura-
tion of the monitoring cycle. We then ﬁlter the methods to
get the list of methods running in the last monitoring cycle
(whether they are still running or not). For each thread, we
get the methods that it invoked from the list (a thread usu-
ally has its own execution stack which is made of frames. A
frame represents a method invocation). Furthermore, we es-
timate with a good accuracy the CPU time for each method
using the following formula:
TimeCPU
method =Duration method×TimeCPU
thread/summationtext
m∈MethodsDuration m(11)163Where Duration method is the execution time of the method
in the last monitoring cycle, and/summationtextDuration methods is the
sum of the execution time of all methods in the last moni-
toring cycle.
Finally, we calculate the power consumed per method using
this formula:
PowerCPU
method =TimeCPU
method×PowerCPU
thread
Duration cycle(12)
3.3.2 Network Model
We calculate the network power using the number of bytes
transmitted by the application. We ﬁrst calculate the num-
ber of bytes read/written in the last monitoring cycle. Then,
we collect the network power consumed by the application
process from our system library PowerAPI . The network
power consumed per method is therefore:
PowerNetwork
method =Bytes method×PowerNetwork
process
Bytes process(13)
Where Bytes method is the number of bytes read and written
by the method, PowerNetwork
process is the power consumed by the
application, and Byte process is the number of bytes read and
written by all methods of the application.
The network power consumption per thread is therefore the
sum of the network power of all methods running in the
thread as shown in the following formula:
PowerNetwork
thread =/summationdisplay
PowerNetwork
methods (14)
In the next section, we describe the implementation e-Surgeon
using our power models.
4. IMPLEMENTATION
The implementation of e-Surgeon includes a system level
modular library, PowerAPI , and a Java tool instrumenting
bytecode at runtime, Jalen . CPU and network modules as
well as proﬁling functionalities are provided. The source
code of our e-Surgeon prototype is available at github5.
4.1 PowerAPI
PowerAPI is implemented as a system level modular li-
brary. We implemented so far the CPU and network mod-
ules and power models. Our system-level library aims to
provide power information per PID for each system com-
ponent (CPU, network card, etc.). The library is therefore
based on a modular approach where each system compo-
nent is represented as a power module .Power modules op-
erate independently from each other and are composed by
two sub-modules: formula and sensor . These sub-modules
communicate using the Service-Oriented Architecture (SOA)
paradigm, and are contained in an OSGi6container. In par-
ticular, we use Service Oriented Framework (SOF )7
to implement the various modules of PowerAPI in C++.
The sensor sub-module is responsible for gathering operat-
ing system related information for the module. For example,
it gathers the number of bytes transmitted by the network
5https://github.com/abourdon/e-Surgeon
6formerly Open Service Gateway Initiative
7http://sof.tiddlyspot.comcard, and the time spent by the CPU at each of the proces-
sor frequencies (when DVFS is supported). These data are
basically given by the operating system, giving to the sensor
sub-module of being OS-dependent. In particular, our im-
plementation, based on a GNU/Linux distribution, exploits
system information available in the procfs andsysfs ﬁle sys-
tems [9]. The formula sub-module, on the other hand, is
hardware independent. Indeed, this sub-module is responsi-
ble for estimating the power consumed for each process by
using both information gathered by the sensor sub-module
and information based on hardware characteristics. For in-
stance, in case of CPU energy consumption, our model has
to take into account the frequency and voltage ranges, or
Thermal Dissipation Power. We implemented sensor and
formula sub-modules for the CPU and NIC on a GNU/Linux
operating system. Additionally, our library supports the life-
cycle management of its power modules. The latter can be
started, stopped and their parameters changed at runtime,
using a modules manager . The beneﬁt of this modular ap-
proach is to oﬀer ﬂexibility while monitoring the system and
to control the overhead of the monitoring library.
We provide a modular library where only part of its com-
ponents are platform-dependent. Its modularity allows easy
porting of the library while retaining most of its power mod-
eling code. Although PowerAPI works as a standalone
library, it is used in addition to our application power mon-
itoring component: Jalen .
4.2 Jalen
We also developed a runtime application power monitor-
ing component, called Jalen , as part of the e-Surgeon
architecture. Jalen uses the per-process power information
provided by PowerAPI , and correlates it with information
collected from the application monitoring in order to provide
per-method power information. Jalen is designed as a two-
parts architecture: i)a Java programming language agent
that instruments the bytecode of the application in order to
inject our monitoring code, and ii)a JMX client computing
and correlating the collected data. This client extracts the
per-method power consumption values. Figure 3 overviews
the architecture of Jalen .
Figure 3: The Jalen Architecture.
We use bytecode instrumentation technics8to inject our
monitoring code into the methods of legacy applications. In
order to reduce the overhead introduced by the instrumenta-
tion, we oﬄoad all the computations to a remote JMX client.
Therefore, our Java agent only collects raw values, such as
for the CPU: the start time, end time, running status, exe-
cuting thread identiﬁer and callee method (using a custom
execution stack trace). For the network, we use a delegator
8http://asm.ow2.org164class to route calls from the class SocketImpl9to a cus-
tom implementation. We override the methods getInput-
Stream() and getOutputStream() to monitor the number
of bytes read and written to sockets. This information is
then correlated with the method names invoking the meth-
odsgetInputStream() orgetOutputStream() , in order to
get the number of bytes read/written by method.
All these collected information are then exposed in a MXBean10
interface. In particular, the agent performs calculations in
order to determine the actual duration of the execution of
the method during the last monitoring cycle. This calcula-
tion takes into account all the calls to the methods executed
in a same thread. It also separates the calculations of these
methods by thread. For example, method A()is called twice
from thread X, and three times from thread Y. The calcu-
lations generate two results: one where the duration is the
sum of the two calls in thread X, and the second where the
duration is for the sum of the three calls in thread Y. We do
not merge these numbers because we need to construct the
call tree in order not to take into account the delta duration
of the callee method when its children are being executed.
Our prototype can handle this on a per-thread basis thanks
to this separation.
Then, we build a JMX client that, not only displays the col-
lected information, but also does the computation and cor-
relation in order to determine the CPU and network power
consumed per method in each monitoring cycle. The JMX
client collects information exposed by the agent’s MXBean .
Using power models and metrics correlations (cf. Section 3.2),
we estimate the CPU power and the network power con-
sumed per method.
5. EMPIRICAL V ALIDATION
We validate the accuracy and precision of our e-Surgeon
prototype on a Dell Precision T3400 workstation with an In-
tel Core 2 Quad processor (Q6600), running Ubuntu Linux
11.04 and Java 1.6 We ﬁrst evaluate our PowerAPI library
(cf. Section 5.1), and then evaluate our Jalen Java agent
(cf. Section 5.2). Based on these results, we conduct an
analysis of a stress benchmark on a Jetty Web Server (ver-
sion 8.0.4.v20111024) in Section 6.
5.1 PowerAPI Validation
5.1.1 CPU Power
We ﬁrst assess the accuracy of the results provided by our
system library. We compared the power values provided by
PowerAPI with the actual power consumption of the com-
puter using a powermeter. In our tests we use PowerSpy11,
a bluetooth powermeter. We compare the values of our li-
brary and the powermeter in a stress test on Jetty Web
Server using Apache JMeter12(cf. Figure 5), and using
the Linux stress command13(cf. Figure 4). Note that due
9http://docs.oracle.com/javase/6/docs/api/java/
net/SocketImpl.html
10http://docs.oracle.com/javase/6/docs/api/javax/
management/MXBean.html
11http://www.alciom.com/en/products/powerspy2.html
12http://jmeter.apache.org
13http://linux.die.net/man/1/stressto synchronization time lag between PowerSpy and our li-
brary, values are shifted for a few seconds in the beginning
of the monitoring. These values are normalized in order to
observe trends in the CPU power consumption. We normal-
ize these values by subtracting for each measured value of
the powermeter, the average of the diﬀerences between the
values measured by the powermeter and provided by our li-
brary. The results show minor variations between the values
estimated by our library, and the actual power consumption.
The margin of error is estimated to 0.5% of the normalized
and averaged values in the core stressing scenario. The er-
ror grows to nearly 3% in the Jetty stress test. We use
the Linux Top program to compute the CPU utilization
of monitoring one process by PowerAPI and estimate it
at around 0.1%. Therefore, we can reasonably argue that
using a software-centric approach provides values that are
accurate enough to be used by power management software.
Figure 4: Stressing the processor cores with the
stress command.
Figure 5: Running stress tests on Jetty using JMe-
ter.1655.1.2 Network Power
We run a network stress test using Iperf14and measured the
power consumption of Iperf ’s CPU server on our host con-
ﬁguration. We send two sets of TCP packets of 100MB each
from a distributed client to our host server. We used the de-
fault settings of Iperf , where also its CPU server executes
following a periodically cycle (every second). Our results
show network consumption around 0.017 watt compared to
CPU consumption of Iperf process around 0.9 watt. These
numbers show that, although CPU power is quite low (av-
erage around 0.9 watt) and the network card uses all its
capacity, the consumed network power is largely negligible
compared to the consumed CPU power on our test server.
This observation is in correlation with the literature [11].
Therefore, we mostly outline the results of our CPU exper-
imentation.
Figure 6: CPU and network power consumption in
Iperf stress test.
5.2 Jalen Validation
We calculate the CPU overhead of our Jalen Java agent
using the start time and the time per request of Apache
Tomcat 7.0.22 application server15as a comparison met-
ric. This metric involves many of Tomcat ’s classes and
methods and is provided by default by Tomcat . The av-
erage start time of Tomcat on our host conﬁguration (a
MacBook Pro, mid 2009, and Java 1.6) is around 821.8 ms.
With Jalen Java agent, Tomcat , while having its meth-
ods instrumented, took 1178 ms in average. Therefore, our
agent introduces an overhead of 43.34%.
We also calculate the time per request using ApacheBenh
2.3. On 10,000 requests, the mean time per request is at
20.206 ms with Jalen, in comparison to 12.861 ms without.
The time overhead per request is therefore at 57.11%.
Even though these numbers may appear to be high, they
should compared to the overhead of similar proﬁlers. We
therefore compared our results of Tomcat’s start time with
theJava Interactive Profiler (JIP)16.JIPalso instru-
ments bytecode but does not oﬀer power related information.
With JIP,Tomcat took 1469.6 ms to start, or an overhead
14http://www.manpagez.com/man/1/iperf
15http://tomcat.apache.org
16http://jiprof.sourceforge.netof 78.82%. Thus, Jalen have an overhead 45% lower to sim-
ilar method-level bytecode instrumentation proﬁlers such as
JIP. Figure 7 summarizes these numbers.
Figure 7: Time overhead of Jalen with Tomcat 7
start time.
In the next section, we present and discuss the results of
our approach on monitoring and detecting energy hotspots
of Jetty Web Server.
6. ENERGY HOTSPOTS OF JETTY
The goal of our approach is to detect energy hotspots in ap-
plications. Jetty Web Server is an example of such complex
applications, counting 88,513 source lines of code (SLOC) in
the version we used for our study (version 8.0.4.v20111024).
We run our e-Surgeon prototype (system library and Java
agent plus a JMX client) on an instance of Jetty Web
Server. We use JMeter to stress Jetty server using a
benchmark scenario (stressing the examples provided by de-
fault in Jetty ). We run the experimentation for an average
time of one minute, with 20 threads (users in JMeter ) and
a loop count of 500. The results we gathered are presented
in Figure 8. The graph portrays the top 10 most power-
consuming methods in the X axis (out of 726 instrumented
methods). The right Y axis (thus the bars) represents the
power consumed during our execution in percentage of the
total power consumed. The left Y axis (thus the line) repre-
sents the number of invocations of the method. We run this
experiment several times, and although we had diﬀerence in
the watt power values, we notice that the global and pro-
portional percentage is stable. Note also that the provided
values are an aggregation of the execution of the methods
on all threads.
Figure 8: Cumulated power consumption of Jetty
methods under JMeter stresses (top 10 most power-
consuming methods).166The ﬁrst observation is that the top 10 methods consumes
nearly half of the total power consumed by Jetty during
the stress benchmark (50.99%). More interestingly, we ob-
served that the method org/eclipse/jetty/
io/ByteArrayBuffer.get consumes 14.22% of the total power
by its own, with a similar number of invocations compared
to other methods.
We also analyze the power consumption per method invo-
cation of the top 10 methods. The results are presented in
Figure 9. We observe that org/eclipse/jetty/io/
AbstractBuffer.putIndex has a lower power per invocation
in the top 10 methods. This method consumed 2.89% of to-
tal power during the tests, but was invoked 42293 times.
Thus, this method has a power per invocation of 134.057
microwatts. On the other hand, org/eclipse/jetty/io/
ByteArrayBuffer.get has a power per invocation of 535.237
microwatts with 52159 invocations and 14.22% of global
power consumed.
Figure 9: Power in watt per invocation of the top 10
most power-consuming methods (lower is better).
The results for the most consuming classes (out of 146) are
reported in Figure 10. We note that the 2 aforementioned
classes ( org/eclipse/jetty/io/AbstractBuffer with 39.22%
andorg/eclipse/jetty/io/ByteArrayBuffer with 23.89%)
consume alone more than 60% of the total power (63.11%).
io/AbstractBuffer is an averaged sized class in Jetty of 544
SLOC where only 10 of its methods has been invoked 255,472
times, while the latter is even smaller with 304 SLOC where
26 of its methods have been invoked 606,710 times. These
numbers show a strong relation between the energy con-
sumption of methods and their number of invocation.
These results can be explained by our benchmark stress sce-
nario. The latter stresses Jetty Web Server using HTTP
requests on servlets with simple executed JSP code. There-
fore, the highest power consumption in our tests is concen-
trated on classes which manage reads and writes of HTTP
requests ( e.g.,org/eclipse/jetty/io/AbstractBuffer ,
org/eclipse/jetty/io/ByteArrayBuffer ). This strengthen
our initial validation of the accuracy of e-Surgeon .
We believe that this information can help the developers to
investigate alternative implementations of the class org/
eclipse/jetty/io/ByteArrayBuffer in order to reduce the
power footprint of this method. By keeping track of the
Figure 10: Cumulated power consumption of Jetty
classes under JMeter stresses.
power footprint of classes and methods, we think that devel-
opment tools ( e.g., coding completion systems, documenta-
tion, debuggers, etc.) could be extended to help developers
build greener software.
6.1 Limitations
Our results show that we can identify energy hotspots in ap-
plications, and in Jetty web server in particular. However,
and even though we used a benchmark imitating a real-case
scenario, we are aware that our results should not be gener-
alized without further consideration.
First, our aim was to observe trends in energy consumption
(which is the reason of using percentages when comparing
methods and classes). Raw watt values are less relevant as
direct measurements vary greatly between hardware ( i.e., a
given application consumes diﬀerent amount of energy when
running on two diﬀerent machines, such as a laptop or a
server). Therefore, we argue that our approach is useful in
proﬁling applications in order to ﬁnd the origin of energy
leaks. Developers can then provide hotﬁxes for the applica-
tion in order to reduce its energy footprint.
Second, and in comparison with our ﬁrst point, the over-
head of our prototype is not negligible, thus limiting its us-
age in production (57.11% overhead for Tomcat’s individual
requests (cf. Section 5.2)). Although it is comparable to
similar bytecode proﬁlers, the overhead is penalizing to be
used in production systems ( e.g., Tomcat, Jetty). We also
developed a lightweight version, providing the energy con-
sumption of running threads (but not methods and classes).
This version does not use bytecode instrumentation, there-
fore its overhead is negligible in Jetty and Tomcat and with
a 1.95% increase in time. Note also that the computation of
the energy consumption of methods and threads is realized
in a separate process, and that PowerAPI runs also in a
dedicated process, thus limiting the impact on the execution
of the monitored application. We believe that the overhead
of our power model and architecture is controlled, and can
be considered is acceptable with regards to the beneﬁts of
the computed energy indicators.1676.2 Future Directions
Our study aims at providing a representation of the energy
consumption of CPU- and network- intensive software at
diﬀerent levels of granularity ( e.g., application, source code).
In the future, we plan to extend ou approach to measure
hardware components that contribute to a high percentage
in energy consumption of applications [11], which are, in
addition to the CPU, the memory and the disk.
We are also planning to develop additional sensors for dif-
ferent hardware conﬁgurations and environments because
energy consumption depends on the hardware environment
(e.g., modules compatible with Windows, Mac OS, and dif-
ferent hardware models). Developing sensors and modules
for virtual machines allows our model to reduce its depen-
dency on hardware parameters ( e.g., dealing with the di-
versity of hardware is therefore left to the virtual machine),
and consider energy accounting issues in the context of green
computing environments.
7. RELATED WORK
In this section, we outline the relevant related works to
energy modeling, energy monitoring and metering, power-
related tools at the system level, and application proﬁling
tools, in particular for Java applications.
7.1 Energy Metering and Modeling
Monitoring energy consumption of hardware components
usually requires an hardware investment, like a multimeter
or a specialized integrated circuit. For example in [8], the
energy management and preprocessing capabilities is inte-
grated in a dedicated ASIC ( Application Speciﬁc Integrated
Circuit ). It continuously monitors the energy levels and
performs power scheduling for the platform. However, this
method has the main drawback of being diﬃcult to upgrade
to newer and more precise monitoring and it requires that
the hardware component be built with the dedicated ASIC,
thus making any evolution impossible without replacing the
whole hardware. On the other hand, an external monitor-
ing device provides the same accuracy as ASIC circuits and
does not prohibit energy monitoring evolutions. The previ-
ous monitoring approaches retrieve energy measures about
hardware components only. However, knowing the energy
consumption of software services and components requires
an estimation of that consumption. This estimation is based
on calculation formulae as in [12] and [7].
In [12], the authors propose formulae to compute the energy
cost of a software component as the sum of its computational
and communication energy costs. For a Java application
running in a virtual machine, the authors take into account
the cost of the virtual machine and eventually the cost of the
called OS routines. Our model is based on a similar prin-
ciple, although we abstract the cost of the infrastructure in
our computational costs. However, the authors calculate the
energy cost of components in terms of the cost of its inter-
faces ( i.e., a method in most cases). The latter is calculated
as an estimation of the energy cost of executing Java’s 256
bytes code types, JVM’s native methods, and the cost of
threads synchronization. Our computation model is based
on runtime power consumption. The CPU power consumed
by a method is its percentage share of the power consumed
by the application, calculated using the actual CPU timeand utilization of the method. On the other hand, our net-
work model is similar to theirs, as both are based on the
size of data transmitted (send/receive) during the invoca-
tion of the program. Still, we use runtime-monitored values
to calculate power consumption, while they use estimations
at construction time albeit reﬁned at runtime. In [7], the au-
thors take into account the cost of the wait andidlestates of
the application ( e.g., an application consumes energy when
waiting for a message on the network). We also take these
states into account by only using the actual time spend run-
ning on a resource ( i.e., CPU, network card). In [4], the
authors propose a tool, PowerScope , for proﬁling energy
usages of applications. This tool uses a digital multimeter
to sample the energy consumption and a separate computer
to control the multimeter and to store the collected data.
PowerScope can sample the energy usage by process. This
sampling is more accurate than energy estimation, although
it still needs a hardware investment.
7.2 System Level Tools
pTop [2] is a process-level power proﬁling tool. Similar to
the Linux Top program, the tool provides the power con-
sumption (in Joules) of the running processes. For each
process, it gives the power consumption of the CPU, the
network interface, the computer memory and the hard disk.
The tool consists in a daemon running in the kernel space
and continuously proﬁling resource utilization of each pro-
cess. It obtains these information by accessing the /proc
directory. For the CPU, it also uses TDP provided by con-
structors in the energy consumption calculations. It then
calculates the amount of energy consumed by each appli-
cation in a tinterval of time. It also consists of a display
utility similar to the Linux Top utility.
Our approach is more ﬂexible and ﬁne-grained than pTop .
Not only we oﬀer process-level power information, but we
also go deep into the application in order to proﬁle and re-
port thread and method-level power consumptions. Fur-
thermore, the system level part of e-Surgeon oﬀers better
ﬂexibility and on-demand scaling of the tool. Monitoring
modules can be shutdown or started depending on the con-
text: on limited resources devices, modules, such as the net-
work or hard disk modules, can be shutdown in order to
monitor only the CPU. When more resources become avail-
able, these modules will be re-started. Other situations are
also possible, such as situations where the user is only in-
terested in monitoring the CPU or the network energy con-
sumption. PowerAPI also adapts to its monitored environ-
ment thanks to its auto-calibration process, in particular by
using calibration data stored in its database. Our ﬂexible
and modular approach therefore oﬀers these functionalities,
and extends them to not only OS processes, but also inside
Java-based applications proﬁling.
In addition to pTop , several utilities exist on Linux for re-
source proﬁling. For example, cpufrequtils17, in particu-
larcpufreq-info to get kernel information about the CPU
(i.e., frequency), and cpufreq-set to modify CPU settings
such as the frequency. iostat18that is used to get devices’
17http://kernel.org/pub/linux/utils/kernel/cpufreq/
cpufrequtils.html
18http://linux.die.net/man/1/iostat168and partitions’ input/output (I/O) performance informa-
tion, as well as CPU statistics. Other utilities [6] also exist
with similar functionalities, such as sar,mpstat , or the
system monitoring applications available in Gnome, KDE
or Windows. However, all of these utilities only oﬀer raw
data ( e.g., CPU frequency, utilized memory) and do not of-
fer power information.
7.3 Application Proﬁling Tools
Several open-source or commercial Java proﬁling tools al-
ready propose some statistics of Java applications. Tools,
such as VisualVM19,Java Interactive Profiler (JIP)20,
or the Oktech Profiler21, oﬀer coarse-grained informa-
tion on the application and ﬁne-grained resource utilization
statistics. However, they fail in providing power consump-
tion information of the application at the granularity of
threads or methods. For example, the proﬁler of VisualVM
only provides self wall time ( e.g., time spend between the en-
try and exit of the method) for its instrumented methods.
We rather provide runtime values for the duration of exe-
cution of methods in a monitoring cycle, and give a good
estimation of the CPU time of these methods. These tools
also lack of providing network related information, such as
the number of bytes transmitted by methods and thus the
power consumed.
8. CONCLUSION AND FUTURE WORK
In this paper, we report on the e-Surgeon runtime energy
monitoring solution. It allows to gather and calculate the
power consumption at processes and methods level. Its mod-
ular architecture allows runtime context-based adaptations
of the monitoring environment itself, leveraging performance
and accuracy at the wish of the application or the user. We
also propose power models to calculate the power consump-
tion. Our models use and extend the state-of-the-art models
and formulae, and port them to a ﬁne-grained context. Our
initial results show the potential of our approach for diagnos-
ing, at runtime, power hotspots of Java-based applications.
As for future work, we plan to: i)propose more power mod-
els for other hardware resources (in particular, memory and
disk); ii)as application servers are more and more running
on virtual machines, we plan to implement speciﬁc sensors
to these environments and experiment our model and ap-
proach on them; and iii)usee-Surgeon and power-aware
information to adapt applications at runtime based on power
concerns.
9. ACKNOWLEDGMENTS
This work is partially funded by the French Ministry of
Higher Education and Research, Nord-Pas de Calais Re-
gional Council and FEDER through the Contrat de Projets
Etat Region Campus Intelligence Ambiante (CPER-CIA)
2007-2013.
10. REFERENCES
[1] The Green Challenge for USI 2010. http:
//sites.google.com/a/octo.com/green-challenge .
19http://visualvm.java.net
20http://jiprof.sourceforge.net
21http://code.google.com/p/oktech-profiler[2] T. Do, S. Rawshdeh, and W. Shi. pTop: A
Process-level Power Proﬁling Tool. In HotPower’09:
Proceedings of the 2nd Workshop on Power Aware
Computing and Systems , Big Sky, MT, USA, october
2009.
[3] L. Feeney and M. Nilsson. Investigating the energy
consumption of a wireless network interface in an ad
hoc networking environment. In INFOCOM’01:
Proceesing of the Twentieth Annual Joint Conference
of the IEEE Computer and Communications Societies ,
volume 3, pages 1548–1557, 2001.
[4] J. Flinn and M. Satyanarayanan. PowerScope: A Tool
for Proﬁling the Energy Usage of Mobile Applications.
InWMCSA’99: Proceedings of the Second IEEE
Workshop on Mobile Computer Systems and
Applications , page 2, Washington, DC, USA, 1999.
IEEE Computer Society.
[5] Gartner. Green IT: The New Industry Shockwave. In
Gartner , Presentation at Symposium/ITXPO
Conference, 2007.
[6] V. Gite. How do I Find Out Linux CPU Utilization?
http://www.cyberciti.biz/tips/
how-do-i-find-out-linux-cpu-utilization.html .
[7] A. Kansal and F. Zhao. Fine-grained energy proﬁling
for power-aware application design. SIGMETRICS
Perform. Eval. Rev. , 36(2):26–31, 2008.
[8] D. McIntire, T. Stathopoulos, and W. Kaiser. ETOP:
sensor network application energy proﬁling on the
LEAP2 platform. In IPSN’07: Proceedings of the 6th
international conference on Information processing in
sensor networks , pages 576–577, New York, NY, USA,
2007. ACM.
[9] E. Mouw. Linux kernel procfs guide, June 2001.
[10] J. Pouwelse, K. Langendoen, and H. Sips. Dynamic
voltage scaling on a low-power microprocessor. In
MMSA’00: Proceesings of the 2nd International
Symposium on Mobile Multimedia Systems and
Applications , pages 157–164, Delft, The Netherlands,
2000.
[11] S. Rivoire, M. A. Shah, P. Ranganathan, and
C. Kozyrakis. JouleSort: a balanced energy-eﬃciency
benchmark. In SIGMOD’07: Proceedings of the 2007
ACM SIGMOD international conference on
Management of data , pages 365–376, New York, NY,
USA, 2007. ACM.
[12] C. Seo, S. Malek, and N. Medvidovic. An energy
consumption framework for distributed java-based
systems. In ASE’07: Proceedings of the twenty-second
IEEE/ACM international conference on Automated
software engineering , pages 421–424, New York, NY,
USA, 2007. ACM.
[13] W. Vereecken, W. Van Heddeghem, D. Colle,
M. Pickavet, and P. Demeester. Overall ict footprint
and green communication technologies. In ISCCSP’10:
Proceedings of the 4th International Symposium on
Communications, Control and Signal Processing ,
pages 1 –6, 2010.
[14] M. Webb. SMART 2020: enabling the low carbon
economy in the information age, a report by The
Climate Group on behalf of the Global eSustainability
Initiative (GeSI) . GeSI, 2008.169