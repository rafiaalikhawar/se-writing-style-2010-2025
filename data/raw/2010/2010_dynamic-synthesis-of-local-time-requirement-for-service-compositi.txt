Singapor e Management Univ ersity Singapor e Management Univ ersity 
Institutional K nowledge at Singapor e Management Univ ersity Institutional K nowledge at Singapor e Management Univ ersity 
Resear ch Collection School Of Computing and 
Information Systems School of Computing and Information Systems 
5-2013 
Dynamic synthesis of local time r equir ement for ser vice Dynamic synthesis of local time r equir ement for ser vice 
composition composition 
Tian Huat T AN 
√âtienne ANDR√â 
Jun SUN 
Singapor e Management Univ ersity , junsun@smu.edu.sg 
Yang LIU 
Jin Song DONG 
See next page for additional authors 
Follow this and additional works at: https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch 
 Part of the Softwar e Engineering Commons 
Citation Citation 
TAN, Tian Huat; ANDR√â, √âtienne; SUN, Jun; LIU, Y ang; DONG, Jin Song; and CHEN, Manman. Dynamic 
synthesis of local time r equir ement for ser vice composition. (2013). Proceedings of the 35th International 
Conf erence on Softwar e Engineering (ICSE '13), San F rancisco, Ma y 18-26 . 542-551. 
Available at:Available at:  https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch/4959 
This Conf erence Pr oceeding Ar ticle is br ought t o you for fr ee and open access b y the School of Computing and 
Information Systems at Institutional K nowledge at Singapor e Management Univ ersity . It has been accepted for 
inclusion in Resear ch Collection School Of Computing and Information Systems b y an authoriz ed administr ator of 
Institutional K nowledge at Singapor e Management Univ ersity . For mor e information, please email 
cher ylds@smu.edu.sg . Author Author 
Tian Huat T AN, √âtienne ANDR√â, Jun SUN, Y ang LIU, Jin Song DONG, and Manman CHEN 
This conf erence pr oceeding ar ticle is a vailable at Institutional K nowledge at Singapor e Management Univ ersity: 
https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch/4959 Dynamic Synthesis of Local Time Requirement for
Service Composition
Tian Huat Tan, √âtienne Andr√©y, Jun Sunz, Yang Liux, Jin Song Dong{, Manman Chen{
NUS Graduate School for Integrative Sciences and Engineering, Singapore
tianhuat@comp.nus.edu.sg
yUniversit√© Paris 13, Sorbonne Paris Cit√©, LIPN, CNRS, UMR 7030, F-93430, Villetaneuse, France
Etienne.Andre@lipn.univ-paris13.fr
zSingapore University of Technology and Design, Singapore
sunjun@sutd.edu.sg
xNanyang Technological University, Singapore
yangliu@ntu.edu.sg
{National University of Singapore, Singapore
{dongjs, chenman}@comp.nus.edu.sg
Abstract ‚ÄîService composition makes use of existing service-
based applications as components to achieve a business goal.
In time critical business environments, the response time of a
service is crucial, which is also reÔ¨Çected as a clause in service
level agreements (SLAs) between service providers and service
users. To allow the composite service to fulÔ¨Åll the response time
requirement as promised, it is important to Ô¨Ånd a feasible set of
component services, such that their response time could collec-
tively allow the satisfaction of the response time of the composite
service. In this work, we propose a fully automated approach to
synthesize the response time requirement of component services,
in the form of a constraint on the local response times, that
guarantees the global response time requirement. Our approach
is based on parameter synthesis techniques for real-time systems.
It has been implemented and evaluated with real-world case
studies.
I. I NTRODUCTION
Service-oriented architecture is a paradigm that promotes
the building of software applications by using services as
basic components. Services make their functionalities available
through a set of operations accessible over a network infras-
tructure. To assemble a set of services to achieve a business
goal, service composition such as BPEL (Business Process
Execution Language) Orchestration [1] has been proposed.
The service that is composed by service composition is called
acomposite service, and services that the composite service
makes use of are called component services.
In business where timing is critical, a requirement on
the service response time is often an important clause in
service-level agreements (SLAs), which is the contractual
basis between service consumers and service providers on
the expected quality of service (QoS) level. Henceforth, we
denote the response time requirement of composite services
asglobal time requirement ; and the set of constraints on the
response times of the component services as the local time
requirement . The response time of a composite service is
highly dependent on that of individual component services.
It is therefore important to derive the local time requirementfrom the global time requirement so as to identify component
services which could be used to build the composite service
while satisfying the response time requirement. Consider an
example of a stock indices service, which has an SLA with
the subscribed users, such that the stock indices would be
returned in two seconds upon request. The stock indices
service makes use of three component services, including a
paid service, to request for the stock indices. The stock indices
service provider would be interested to know the local time
requirement of the component services.
BPEL is a service composition language that supports
complex timing constructs and control Ô¨Çow structures such
as concurrency. Such a combination of timing constructs,
concurrent calls to external services, and complex control
structures makes it a challenge to synthesize the local time
requirement.
In this paper, we present a fully automated technique for
the synthesis of the local time requirement in BPEL. The
approach works by performing dynamic analysis on the service
composition, using techniques of parameter synthesis for real-
time systems. For the synthesized local time requirement
to be useful, it needs to be as weak as possible, to avoid
discarding any service candidates that might be part of a
feasible composition. This is particularly important, as often
having a faster service would incur higher cost. To synthesize a
better constraint that allows larger sets of feasible composition,
we provide an extra analysis on the activities, and classify
them as or-activities or and-activities. We then extend labeled
transition systems (LTS) with and-states and or-states, which
we call and/or LTS (AOLTS), for synthesizing the local time
requirement. The approach not only avoids bad scenarios in
the service composition, but also guarantees the fulÔ¨Ållment of
global time requirement.
Our contributions are as follows:
1) Given a composite service, we develop a sound method
for synthesizing the local time requirement in the form
of a set of constraints on the local service response978-1-4673-3076-3/13/$31.00 c2013 IEEE ICSE 2013, San Francisco, CA, USA542times. The approach is implementation independent,
therefore can be applied at the design stage of service
composition.
2) We propose a new kind of labeled transition systems
called AOLTS, that allows us to exploit the hierarchical
structure of composite services for synthesizing a more
relaxed local time requirement, which is yet strong
enough to guarantee the reachability of good scenarios
inanyinstances of the composite services.
3) We develop a fully automated tool to evaluate the
proposed method and apply it to real-world case studies.
The synthesized local time requirement has multiple ad-
vantages. First, it allows the selection of feasible services
from a large pool of services with similar functionalities but
different local response times. Second, the designer can avoid
over approximations on the local response times. An over
approximation may lead the service provider to purchase a
service at a higher cost, while a service at a lower cost with a
slower response time may be sufÔ¨Åcient to guarantee the global
time requirement. Third, the local requirements serve as a
safe guideline when component services are to be replaced
or new services are to be introduced. Last but not least, the
requirement synthesized by our method gives a quantitative
measure of the robustness of the composite services. Indeed, if
the global time requirement is satisÔ¨Åed given a local response
time of 2 seconds, it may not be the case anymore for a value
bigger than, but very close to, 2 seconds (e.g., 2.001 seconds).
The constraint synthesized gives a measure of the upper bound
until which each local response time can vary.
Outline . The rest of this paper is structured as follows.
Section II introduces a timed BPEL running example. Sec-
tion III provides the necessary deÔ¨Ånition for terminologies.
Section IV introduces our approach to dynamically analyze
the BPEL process. Section V presents the synthesis algorithms
and their soundness proofs. Section VI reviews related works.
Section VII discusses the application of our approach on two
case studies. Finally, Section VIII concludes the paper, and
outlines future work.
II. A T IMED BPEL E XAMPLE
BPEL is a standard for implementing composition of exist-
ing Web services by specifying an executable work Ô¨Çow using
predeÔ¨Åned activities. In this work, we assume the composite
service is speciÔ¨Åed using the BPEL language. Basic BPEL
activities that communicate with component Web services
are < receive >, <invoke >, and < reply >, which are used
to receive messages, execute component Web services and
return values respectively. We denote them as communication
activities. The control Ô¨Çow of the service is deÔ¨Åned using
structural activities such as < flow >, <sequence >, <pick >,
<if>, etc. In this section, we illustrate a Stock Market Indices
Service (SMIS) that is used as a running example in this work.Receive User
Sync. Invoke DS
XReply indexes ASync. Invoke FS
OnMessage FS OnAlarm 1 second
XReply indexes ASync. Invoke PS
OnMessage PS OnAlarm 1 second
XReply indexes Reply ‚ÄôFailure‚ÄôIndexes exist Indexes do not exist
Fig. 1. Stock Market Indices Service
A. Stock Market Indices Service
Assume that the SMIS is a paid service and its goal is
to provide updated stock indexes to the subscribed users.
It provides service level agreement (SLA) to the subscribed
users stating that it always responds within two seconds upon
request.
The SMIS has three component Web services: a database
service ( DS), a free news feed service ( FS) and a paid news
feed service ( PS). The strategy of the SMIS is calling the
free service FSbefore calling the paid service PSin order
to minimize the cost. Upon returning the result to the user,
the SMIS would also store the latest results in an external
database service provided by DS(storage of the results is
omitted here). The workÔ¨Çow of the SMIS is sketched in Fig. 1
under the form of a tree. When a request is received from a
subscribed customer ( Receive User ), it would synchronously
invoke (i.e., invoke and wait for reply) the database service
(Sync:Invoke DS ) to request for stock indexes stored in
the last minute. Upon receiving the response from DS, the
process is followed by an < if> branch (denoted by ).
If the indexes are available ( indexes exists ), then they
are returned to the user ( Reply indexes ). Otherwise, FSis
invoked asynchronously (i.e., the system moves on after the
invocation without waiting for the reply). A < pick > construct
(denoted by ) is used here to await incoming response
(<onMessage >) from previous asynchronous invocation and
timeout (< onAlarm >) if necessary. If the response from FS
(OnMessage FS) is received within one second, then the result
is returned to the user ( Reply indexes ). Otherwise, the time-
out occurs ( OnAlarm 1 second ), and SMIS stops waiting for
the result from FSand calls PSinstead ( ASync:Invoke PS).
Similar to FS, the result from PSis returned to user, if the
response from PSis received within one second. Otherwise, it
would notify the user regarding the failure of getting stock
indexes ( Reply ‚ÄòFailure ‚Äô). The state with a X(resp.)
represents the desired (resp. undesired) end state.
The global time requirement for SMIS is that SMIS should
respond within two seconds upon request. It is of particular
interest to know the local time requirements for services PS,543FS, and DS, so as to fulÔ¨Åll the global time requirement. This
information could also help to choose a paid service PSwhich
is both cheap and responding quickly enough.
B. BPEL Notations
To present BPEL syntax succinctly, we deÔ¨Åne a set of BPEL
notations below:
rec(S)and reply(S)are used to denote ‚Äúreceive from‚Äù
and ‚Äúreply to‚Äù a service S;
sInv(S)(resp. aInv(S)) denotes synchronous (resp. asyn-
chronous) invocation of a service S;
PjjjQdenotes the concurrent execution of BPEL
activities PandQ;
PCbBQdenotes conditional activity, where bis a guard
condition. If bis evaluated as true, BPEL activity Pis
executed, otherwise activity Qis executed.
pick(S)P;alrm(a))Q)denotes BPEL < pick > activity,
which either receives the message from service Swithin
aseconds, where a2R0, and subsequently executes
BPEL activity P; or timeouts at aseconds, and sub-
sequently executes BPEL activity Q. If the message is
arrived at exactly aseconds, then PorQexecutes non-
deterministically.
III. F ORMAL MODEL FOR PARAMETRIC ANALYSIS
A composite service Smakes use of a Ô¨Ånite number of
component services to accomplish a task. Let C=fs1;:::; sng
be the set of all component services that are used by S. The
response time of a service s1is reÔ¨Çected on the time that
spends on the communication activities. For example, assume
that the only communication activity that communicates with
component service s1issInv(s1). Upon invoking of service
s1, the construct sInv(s1)waits for the reply. The response
time of component service s1, is equivalent to the waiting
time in sInv(s1), Therefore by analyzing the time spent in
sInv(s1), we can get the response time of component service
s1. Given a composite service S, let ti2R0be the response
time of component service sifori2 f1;:::; ng, and let
Ct=ft1;:::; tngbe a set of component service response
times that fulÔ¨Åll the global time requirement of service S.
Because ti, for i2 f1;:::; ng, is a real number, there are
inÔ¨Ånitely many possible values, even in a bounded interval
(and even if one restricts to rational numbers). A method to
tackle this problem is to reason parametrically , by considering
these response times as unknown constants, or parameters .
Letui2R0be the parametric response time of component
service sifori2f1;:::; ng, and let Cu=fu1;:::; ungbe the
set of component service parametric response times. Using
constraints on Cu, we can represent an inÔ¨Ånite number of pos-
sible response times symbolically. The local time requirement
of composite service Sis speciÔ¨Åed as a constraint over Cu. An
example of local time requirement is (u1<6)_(u2<5).
This local time requirement speciÔ¨Åes that, in order for Sto
satisfy the global time requirement, either service s1needs to
respond within 6 time units, or service s2needs to respond
within 5 time units.We review relevant deÔ¨Ånitions in the following.
A. Clocks, Parameters, and Constraints
Aclock is a variable of type R0. A clock is used to record
the time passage of a communication activity. All clocks are
progressing at the same rate. Xis deÔ¨Åned as a universal set of
clocks. Let X=fx1;:::; xHgX be a Ô¨Ånite set of clocks. A
clock valuation is a function w:X!R0, that assigns a non-
negative real value to each clock. A parameter is an unknown
constant. LetUdenote the universal set of parameters, disjoint
withX. Given a Ô¨Ånite set U=fu1;:::; uMgU , aparameter
valuation is a function :U!R0assigning a non-negative
real value to each parameter. We can identify a valuation 
with the point ((u1);:::; (uM)). Alinear term onX[Uis
an expression of the formP
1iNizi+dwith zi2X[U,
i2R0for1iN, and d2R0. Given XX and
UU, aninequality over XandUisee0with2f<;g,
where eande0are linear terms on X[U. Aconstraint is a
conjunction of inequalities. We denote by CX[Uthe set of all
constraints over XandU. Henceforth, we use w(resp.) to
denote a clock (resp. parameter) valuation.
LetC2C X[U,C[]denote the constraint over Xobtained
by replacing in Ceach u2Uwith(u). Similarly, C[][w]
denotes the constraint obtained by replacing each clock x
inC[]with w(x). We write (w;)j=C, ifC[][w]evaluates
to true. Cisempty , if there does not exist a parameter valuation
, such that j=C; otherwise Cisnon-empty . We deÔ¨Åne
C"=fx+djx2C^d2R0g, as time elapsing
ofC, i.e., the constraint over XandUobtained from Cby
delaying an arbitrary amount of time. Given two constraints
C1;C22C X[U,C1isincluded inC2, denoted by C1C2, if
8w;: (w;)j=C1)(w;)j=C2.
B. Labeled Transition Systems
In this work, the semantics of composite service is captured
using labeled transition systems (LTSs). The behavior of
composite service is affected by the input data. Since the
input data is unpredictable, in order to reason on the general
behavior of composite service, it is useful to obtain a local time
requirement which could guarantee global time requirement
for any input data. For example, given conditional expression
PCbBQ, the execution of activity Por activity Qis based on
the valuation of b; but if we choose to abstract from data, either
PorQwill be executed non-deterministically. A state of the
LTS represents a status of the composite service. Informally,
a concrete state is a state that contains data information, and
the LTS that contains concrete state is denoted as concrete
LTS. An abstract state is a state which abstracts away data
information, and the LTS that contains abstract state is denoted
as abstract LTS. Our dynamic analysis is based on the abstract
LTS. In the following, we provide the formal deÔ¨Ånition of
various terminologies that are used in this work.
DeÔ¨Ånition 1 (Parameterized Composite Service Model): A
composite service model Mis a tuple (Var;V0;U;P0;C0),
where Varis a Ô¨Ånite set of variables, V0is an initial valuation
that maps each variable to its initial value, Uis a Ô¨Ånite set544of parameters, P0is the composite service process, and C0is
the initial constraint.
Given a service model M with a parameter set
U=fu1;:::; umg, and given a parameter valuation
((u1);:::; (uM)),M[]denotes the instantiation ofM
with, viz., the model (Var;V0;U;P0;C), where CisC0^VM
i=1(ui=(ui)). Note thatM[]is a non-parametric service
model.
DeÔ¨Ånition 2 (Concrete Labeled Transition System):
A concrete labeled transition system is a tuple
Lc= (Sc;sc
0;;c), where
Scis a set of concrete states,
sc
02Scis the initial state,
is the universal set of actions,
c:ScScis a transition relation.
Aconcrete state s cis represented as (V;P;C;D), where Vis a
valuation of the variables (i.e., a function that maps a variable
name to its value), Pis a composite service process, Cis a
constraint overCX, and Dis the (real-valued) duration from
the initial state s0to the beginning of the state s.
DeÔ¨Ånition 3 (Abstract Labeled Transition System): Anab-
stract labeled transition system is a tupleL= (S;s0;;),
where
Sis a set of abstract states,
s02Sis the initial state,
is the universal set of actions,
:SSis a transition relation.
Anabstract state s is represented as (P;C;D), where Pis a
composite service process, Cis a constraint over CX[U, and
Dis the (parametric) duration from the initial state s0to the
beginning of the state s(i.e., a linear term on the parameters).
Henceforth, we refer to an abstract state (resp. abstract LTS)
as a state (resp. LTS), as long as it is clear from the context.
The following deÔ¨Ånitions could be easily extended to con-
crete states and concrete LTSs. Given an LTS L= (S;s0;;),
a state s2Sis said to be a terminal state if there does not
exist a state s02Sand an action a2such that (s;a;s0)2;
otherwise, sis said to be a non-terminal state . There is a
runfrom a state sto state s0, where s;s02S, if there exist
a set of statesfs1;:::; sng 2 Sand a sequence of actions
ha1;:::; ani, where ai2, such that s1=s,sn=s0, and
8i2f1;:::; n 1g;(si;ai;si+1)2. Acomplete run is a run
that starts in the initial state s0and ends in a terminal state.
Given a state s2S, we use Enable (s)to denote the set of
states reachable from s; formally, Enable (s) =fs0js02S^
a2^(s;a;s0)2g. Given a state s= (P;C;D), we use
the notation s:Pto denote the component Pofs, and similarly
fors:Cands:D.
GivenM= (Var;U;P0;C0), the global time requirement
forMrequires that, for every state (P;C;D)reachable from
the initial state (P0;C0;0)in the LTS, the constraint DTG
is satisÔ¨Åed, where TG2R0is the global time constraint .
The local time requirement requires that if the response
times of all component services of Msatisfy the local time
constraint C L2C U, then the service SsatisÔ¨Åes the global time
requirement.Act(A(S);x) = A(S)x A1
Act(mpick;x) = mpick x A2
Act(A(S)x0;x) = A(S)x0 A3
Act(mpick x0;x) =mpick x0 A4
Act(PQ;x) = Act(P;x)Act(Q;x)A5
Act(Po
9Q;x) = Act(P;x)o
9Q A6
Fig. 2. Activation Function, where A2frec ;sInv ;aInv ;replyg,2fjjj
;CbBg, and mpick =pick(S)Pt;alrm(a))Pa)
IV. D YNAMIC ANALYSIS WITH LTS
Our approach for synthesizing local time constraint for
component services is based on the dynamic analysis of the
constraint of each state in the LTS of the composite service
M. In this section, we present how we analyze the LTS with
real-time semantics using parametric techniques. In order to
analyze the LTS with real-time semantics, we use clocks to
record the elapsing of time. The clock formalism has been
used to record the time elapsing in several formalisms, in
particular in Timed Automata (TA) [2]. In TAs, the clocks are
deÔ¨Åned during the modeling phase, and once created, are never
discarded. It is known the the state space of the system could
grow exponentially with the number of clocks. An alternative
approach is to create clocks on the Ô¨Çy when necessary, and
have them pruned when no longer needed. This allows smaller
state space compared to the explicit clock approach; we refer
to this second approach as implicit clock approach . We use
the implicit clock approach [3], [4] when analyzing the BPEL
model with LTSs.
A. Clock Activation
Clocks are implicitly associated with timed processes. For
instance, given an action sInv(s), a clock starts ticking once
the process becomes activated. To introduce clocks on the
Ô¨Çy, we deÔ¨Åne an activation function Actin Fig. 2. Given a
process P, we denote by Pxthe corresponding process that has
been associated with clock x. The activation function will be
called when a new state sis reached to assign a new clock for
each newly activated communication activity. Rules A1 and A2
state that a new clock is associated with BPEL communication
activity if it is newly activated. Rules A3 and A4 state that if
a BPEL communication activity has already been assigned a
clock, it will be never reassigned. Rules A5 and A6 state that
function Actis applied recursively for activated child activities
for BPEL structural activities.
B. Idling Function
Given a state s, we deÔ¨Åne function idle to calculate how
long the activity Acan idle in state s. The result is a constraint
over the clocks and the parameters. Rule I1 states the situation
that the communication required to wait for the response of
component services S, and states the value of clock xmust not
be larger than the response time parameter tSof the service.
Rule I2 states that the situation that no waiting is required.
Rules I3 to I5 state that the function idleis applied recursively
for activated child activities of a BPEL structural activity.545idle(A(S)x) = xtS I1
idle(B(S)x) = ( x= 0) I2
idle(PQ) = idle(P)^idle(Q)I3
idle(Po
9Q) = idle(P) I4
idle(mpick x) =xtS^xa I5
Fig. 3. Idling Function, where A2frec ;sInvg,B2faInv ;replyg,2fjjj
;CbBg,mpick =pick(S)Pt;alrm(a))Pa), and tSis the parametric response
time of service S
We deÔ¨Åne an undesired scenario that the user does not want
to end in. In case of the SMIS example, it corresponds to a
situation where both component services FSand PSfail to
response within one second. Given a BPEL service M, in
order to be able to classify the desired and undesired scenarios,
we allow the user to annotate a BPEL activity Aas a bad
activity, denoted by [A]bad. The annotation can be achieved,
for example, by using extension attribute of BPEL activities.
The execution of activity [A]badwill result the LTS of Mto
end in an undesired terminal state, which we denote as a bad
state . The terminal state which is not a bad state is called
agood state . The synthesized local time constraint needs to
guarantee the avoidance of all bad states and the reachability
of at least one good state.
C. State Space Exploration
LetY=hx0;x1;i be a sequence of clocks. Starting
from the initial state s0= (P0;C0;0), we iteratively construct
successor states as follows. Given a state (P;C;D), a clock x
which is not currently associated with Pis picked from Y. The
state (P;C;D)is transformed into (Act(P;x);C^x= 0;D),
i.e., timed processes which just become activated are associ-
ated with xandCis conjuncted with x= 0. Then, a Ô¨Åring
rule is applied to get a target state (P0;C0;D0), such that C0be
satisÔ¨Åable (otherwise, the transition is infeasible). Note that,
for the sake of conciseness, Ô¨Åring rules are not introduced here;
they encode the semantics of BPEL, and are straightforward.
Lastly, clocks which do not appear within P0are pruned
from C0. Observe that one clock is introduced and zero or
more clocks may be pruned during a transition. Actually, a
clock is introduced only if necessary; if the activation function
does not activate any subprocess, this new clock is not created.
D. Application to an Example
Consider composite service M, which is a fraction of the
SMIS of Section II. The LTS of Mis shown in Fig. 4.
At state s0, activation function assigns clock xto record
time elapsing of pick activity mpick and the tuple be-
comes (mpick x;true;0).
From state s0, it could evolve into state s1if the constraint
c1= (x=tPS^idle(mpick x))where idle(mpick x) =
(xtPS^x1), is satisÔ¨Åable. Intuitively, c1
denotes the constraint where tPStime units elapsed since
clock xhas started. In fact, constraint c1is satisÔ¨Åable (for
example with tPS= 0:5andx= 0:5). Therefore, it could
evolve into state s1= (rgood;x=tPS^x1;tPS). Sinces0:(mpick;true;0)
s1:(rgood;tPS1;tPS)
s3:(stop;tPS1;tPS)Xs2:(rbad;tPS1;1)
s4:(stop;tPS1;1)
Fig. 4. LTS of service M, where mpick =pick(PS)rgood,alrm(1))rbad)
;rgood=reply(User);rbad=[reply(User)]bad, and tPSis the parametric response
time of service PS
clock xis not used anymore in s1:Pwhich is rgood, it is
eliminated using variable elimination techniques such as
Fourier-Motzkin [5]. After elimination of clock variable
xand simpliÔ¨Åcation of the expression, state s1becomes
(rgood;tPS1;tPS).
From state s0, it could also evolve into state s2, if
the constraint c2= (x= 1^idle(mpick x)), where
idle(mpick x) = ( xtPS^x1), is satisÔ¨Åable. It
is easy to see that c2is satisÔ¨Åable; we now have state
s2= (rbad;tPS1;1).
From state s1, activation function assigns clock x0for re-
ply activity rgood, and the reply activity becomes (rgood)x0.
It could evolve to state s3, if the constraint c3= (tPS
1^idle((rgood)x0)), where idle((rgood)x0) = ( x0= 0) ,
is satisÔ¨Åable. In fact it is, with the similar reason as
previous cases, and it evolves into terminal state s3=
(stop;tPS1;tPS), where stop is an activity that does
nothing. Since the terminal state is due to a good activity,
s3is considered as a good state, denoted by X.
From state s2, it could also evolve into terminal state
s4= (stop;tPS1;1). Since the terminal state is due to
the bad activity, it is considered as a bad state, denoted
by.
V. C ONSTRAINT SYNTHESIS USING AOLTS
In this section, given a global time constraint TGfor service
S, we present an approach to synthesize local time constraint
CLbased on the LTS. We show that if response times of all
component services of Ssatisfy the local time requirement, the
service Swould end at a good state regardless of the values
input by the user.
A. And-Activity and Or-Activity
To synthesize a better constraint that allows larger sets of
feasible composition, we Ô¨Årst characterize the BPEL structural
activities. We divide the structural activities into and-activities
and or-activities. An and-activity is non-deterministic in the
abstract LTS but deterministic in the concrete LTS; an example
is the < if> activity.
Consider the abstract LTS of a service S =
(Var;V0;U;P0;C0)that has Var =fag,V0=fa7!1g,
U=ftgandP0=ACa= 1BBwhere AandBare BPEL
processes and C0= (true). The global time requirement for
service Srequires that the service must complete within four546S0:(ACa=1BB;true;0)
S1:(A;true;0)
Sn 1:(Stop;t2;t)XS2:(B;true;0)
Sn:(Stop;t3;t)X
Fig. 5. Abstract LTSS0:(fa7!1g;ACa=1BB;true;0)
S1:(fa7!1g;A;true;0)
Sn 1:(fa7!1g;Stop;t2;t)X
Fig. 6. Concrete LTS
seconds. The abstract LTS of service Sis shown in Fig. 5. The
initial state s0has two branches due to the non-determinism
of the abstract LTS for the conditional activity. Assume sn 1
andsnare the (only) two good states that could be reached
from execution of s1and s2respectively. Given constraint
c1= (sn 1:C^sn 1:D4) = t2and constraint
c2= (sn:C^sn:D4) = t3, the result c1_c2(viz.,
t3) will guarantee the reachability of a good state within
four seconds in the abstract LTS. Nevertheless, in the concrete
LTS as shown in Fig. 6, the result would be incorrect, since
for example, t= 3 would not satisfy the constraint of the
(only) good state sn 1in the concrete LTS. The reason is
that the transition caused by the and-activity in the abstract
LTS could be missing in the concrete LTS; therefore we must
conjunct the constraint to guarantee it could reach state sn 1
in the concrete LTS. In our example, the correct local time
requirement would be c1^c2, which is t2. If a structural
activity is not an and-activity, it is classiÔ¨Åed as an or-activity.
The transition caused by an or-activity in the abstract LTS
could not be missing in the concrete LTS. Examples of
or-activities include < flow >, <pick >, and < sequence >.
B. And/Or LTS
Since a BPEL composite service contains a hierarchy
of and-activities and or-activities, we extend the LTS with
And/Or states to facilitate the conjunction and disjunction of
constraints in the hierarchical activities. We denote the LTS
that has been extended with And/Or state as And/Or labeled
transition system (AOLTS) .
DeÔ¨Ånition 4 (And/Or labeled transition system): An
And/Or labeled transition system (AOLTS) is a tuple
LAO= (SAO;s0;;AO)where SAO=S[fand;org,Sis a
set of abstract states, s02Sis the initial state ,is a set
of symbols , andAO:SAOSAOis alabeled transition
relation .
We call a state s2Sa normal state, to differentiate from and-
states and or-states. A non-terminal normal state is said to be
aninter-state . Fig. 7 shows the LTS of a composite service S
that contains an and-activity a1= (i2Cb= 1B[i3]bad)inside
an or-activity a2= (i1jjja1), where ijdenotes sInv(sj), such
thatsjis a component service with parametric response time
tj, for j2f1;2;3g.
The AOLTS of composite service Sis shown in Fig. 8.
Given the global time constraint TG= 3, let ci=si:C^
si:D3, for i2 f4;5;6g, the local time requirement for
composite service s is c4_(c5^c6).S0:(i1jjj(i2Cb=1Bi3);true;0)
S1:(i1;t1t2^t1t3;t1)
S4:(stop;t1t2^t1t3;t1)XS2:(i2;t2t1^t2t3;t2)
S5:(stop;t2t1^t2t3;t2)XS3:(i3;t3t1^t3t2;t3)
S6:(stop;t3t1^t3t2;t3)X
Fig. 7. LTS of composite service S
S0
or
S1
S4and
S2
S5S3
S6
Fig. 8. AOLTS of service SS0
0
or
S1
S4and
S2
S5S0
3
S0
6
Fig. 9. Bad state propagation
C. Bad State Propagation
Consider now we change the deÔ¨Ånition of i3in Fig. 7 as
[sInv(s3)]bad, and we have state s0
0,s0
3ands0
6where state s0
6
is a bad state. Let ci=si:C^si:DTG, for i2f4;5g,
a plausible synthesis solution on the local time requirement
for composite service Swould be (c4_c5)^: s0
6:C. Given
=ft17!2;t27!1;t37!3g, and variable b= 2, this might
be resulting in a situation where no good state is reachable. In
order to avoid this situation, we apply bad state propagation . It
works by propagating the bad status to the parent, as described
below.
If the current state is a terminal bad state, propagate the
bad status to the parent;
If the current state is an or-state sor, and all states in
Enable (sor)have a bad status, then marks sorwith a bad
status, and propagate the bad status to the parent state,
otherwise do nothing;
If the current state is an and-state sand, and if there exists
a state in Enable (sand)that has a bad status, then mark
sandwith a bad status, and propagate the bad status to the
parent state, otherwise do nothing;
If the current state is an inter-state, and if the unique
successor state Succ(s)has a bad status, then mark swith
a bad status, and propagate the bad status to the parent
state, otherwise do nothing.
Consider the example in Fig. 9. The bad state status of s0
6
would propagate up to the and-state. Therefore, the current
constraint is c4^:(s2:C_s0
3:C).
D. The Algorithm for Synthesis of Local Time Requirement
Algorithm 1 presents the main algorithm for synthesizing
the local time constraint. Given a state s,synConsAOLTS (s)
returns a constraint tuple cswhich is a tuple (b;c)where b2B
andc2C U. Given constraint tuple cs, we use cs:First to refer
the Ô¨Årst component of cs, and cs:Second to refer the second
component of cs. In the following, we deÔ¨Åne notions that are
used in Algorithm 1. Given A=fc1;:::; cngC U, we denote547Algorithm 1: Algorithm synConsAOLTS (s)
input : State sof LTS
output : The constraint tuple for LTS that starts at s
1ifs is good state then
2 return (true, s:C^(s:DTG));
3ifs is bad state then
4 Kbad=Kbad^:(s:C);
5 return (false;?);
6CS fsynConsAOLTS (s0)js02Enable (s)g;
7ifs is or-state then
8 iftrue2D(jCSj)then
9 return
(true;Wfc:Secondjc2CS^c:First =trueg);
10 else
11 return (false;?);
12ifs is and-state then
13 iffalse2D(jCSj)then
14 return (false;?);
15 else
16 return (true;Vfcjc2R(jCSj))};
17ifs is inter-state then
18 ifCS[0]:First =true then
19 return (true;CS[0]:Second );
20 else
21 Kbad=Kbad^:(s:C);
22 return (false;?);
Algorithm 2: Algorithm LocalTimeConstraint (s0)
input : Initial state s0
output : The local time constraint CL
1S synConsAOLTS (s0);
2ifS:First=true then
3 return Kbad^S:Second ;
4else
5 return false ;
byVAthe conjunction of constraints in A, i.e., c1^:::^cn.
Similarly, we denote byWAthe disjunction of constraints in
A, i.e., c1_:::_cn.D(jCSj)denotes the set of elements in
the domain of CS; formally,fb:Bj9c2C U;(b;c)2CSg.
R(jCSj)denotes the set of element in the range of CS; formally,
fc:CUj9b2B;(b;c)2CSg. If a set CSis known to contain
exactly an element cs1, we use CS[0]to denote that particular
element cs1.
Furthermore, Kbadis a static variable of type CU, that is used
to collect the negation of the constraint associated to states that
are marked with a bad status (lines 4 and 21). Finally, TGis
the given global time constraint of a service S.S0:(S;true;0)
S1:(rgoodCbBA1;true;DS)
S2:(and)
S3:(A1;true;DS) S4:(rgood;true;DS)
S5:(P1;true;DS) S6:(Stop;true;DS)X
S7:(or)
S8:(A2;FS1;DS+1) S9:(rgood;FS1;DS+FS)
S10:(P2;FS1;DS+1) S11:(Stop;FS1;DS+FS)X
S12:(or)
S13:(rbad;PS1^FS1;DS+2) S14:(rgood;PS1^FS1;DS+1+ PS)
S15:(Stop;PS1^FS1;DS+2) S16:(Stop;PS1^FS1;DS+1+ PS)XsInv DS
and[if]
[else]
AInv FS reply User
OAlrm 1OMsg FS
AInv PS reply User
OAlrm 1OMsg PS
reply Failure reply User
Fig. 10. LTS of the SMIS, where S=(sInv(DS)o
9rgoodCbBA1);
A1=(aInv(FS)o
9P1);P1=(pick(FS)rgood ;alrm(1))A2));A2=(aInv(PS)o
9
P2);P2=(pick(PS)rgood ;alrm(1))rbad));rgood=(reply(User));rbad=
([reply(User)]bad)
In Algorithm 1, lines 5, 11, 14, and 22 are used for the
purpose of bad state propagation as described in Section V-C.
Lines 2, 9, 16, and 19 are used for synthesizing the local
time constraint with conjunction and disjunction operation.
Given a constraint tuple cs=synConsAOLTS (s), if state sis
marked with a bad status during bad state propagation then
cs:First =false , otherwise cs:First =true. Algorithm 2
is the entry algorithm that returns the local time constraint
given initial state s0of a service S. If s0is not marked
with a bad status, then it returns the local time constraint,
otherwise, it returns false, i.e., there is no parameter valuation
for component services that could possibly satisfy the local
time requirement of service S.
E. Application to the Running Example
Fig. 10 shows the AOLTS of the running example intro-
duced in Section II. Algorithm LocalTimeConstraint is used
to synthesize the local time constraint for SMIS based on the
AOLTS. The local time constraint is simpliÔ¨Åed and convert to
disjunctive normal form (DNF) by using Z3 [6], and the local
time constraint of the running example is:
(tFS<1^tDS3^tDS+tFS3)
_(tPS<1^tDS3^tFS1^tDS+tFS3)
_(tPS<1^tDS3^tFS1^tDS+tPS2)
This result, as a whole, provides us useful information
regarding how the component services collectively satisfy
the global time constraint. That is of most importance for
selecting component services. By observing the conjuncts of
DNF, we can extract useful information as well. For example,
(tPS<1^tDS3^tFS1^tDS+tPS2)conveys to
us that, if the free service FStakes more than one second to548response and if the database service DSis fast enough (e.g., it
is a service over local network), then we need a paid service
PSthat responds in less than one second in order for the SMIS
to fulÔ¨Åll the global time constraint.
F . Soundness
In the following, we assume that all loops have a bound
on the number of iterations and the execution time (see Sec-
tion V-G for discussion).
Lemma 1: GivenMbe an abstract service model, the LTS
ofMis acyclic.
Proof: This holds due to the assumption on the loop
activities such that the upper bound on the number of iterations
and the time of execution is known, and there is no recursive
activities in BPEL.
Lemma 2: Lets0;:::; snbe a complete run in LTS, and 
be a parameter valuation, if j=sn:Cthenj=si:C, for all
i2f1;:::; n 1g.
Proof: Since there is only conjunction of new constraints
(refer to Section IV-C) when moving one step to the other.
Therefore si:Csi 1:Cfori2f1;:::; ng, and the result
holds.
Theorem 3 (Soundness of LocalTimeConstraint):
Given serviceM = ( Var;V0;U;P0;C0),K =
LocalTimeConstraint (M). Let Sgood be the collection of
good states in SandSbadbe the collection of all bad states
inS, and. If Kis non-empty,
1) There is at least a good state sg2Sgoodthat is reachable
in any concrete LTS of M[];
2) There is no bad state sb2Sbadthat is reachable in any
concrete LTS ofM[].
Proof: Before bad state propagation, by deÔ¨Ånition, there
will have at least an edge from non-terminal state. We show
that after bad state propagation, all kind of non-terminal states
(and-states, or-states, inter-states) that are not marked with a
bad status will have at least an edge that leads to a good state
in the abstract LTS of M[]. For and-states and inter-states,
if there exists one child that is marked with a bad status, then
the and-states and normal-states should be marked with a bad
status (line 14 and line 22). This means that the and-states
that are not marked with a bad status have all their transitions
preserved in the abstract LTS. Therefore, regardless which
transitions are removed in the concrete LTS, there is at least
one transition left (the concrete LTS will execute at least one
transition). For the or-states, if all the child states are marked
with a bad status, then the or-states will be marked with a
bad status, therefore if they are not marked with a bad status,
they would have at least one transition left in the abstract
state (line 11). Since any concrete LTS does not remove the
transition from an or-state, therefore all transitions of an or-
state remains. By Lemma 1, since the LTS is Ô¨Ånite and acyclic,
it will have at least one of the transitions that ends in the
terminal state. Let state sgbe a good state, and TGbe the
global time constraint, by Lemma 2, j=sg:C^sgTG
implies that j=s0:C, where s0is any non-terminal state
in the complete runs between initial state and good statesg. Therefore item 1 holds. Since the result is of the form
(K1_K2_:::_Kn)^Kbad, this can be rewritten as
((K1^Kbad)_(K2^Kbad)_:::_(Kn^Kbad)). Since Kbad
contains negation of all such reachable bad states, therefore
all the bad-states are non-reachable, and item 2 holds.
G. Discussion
We discuss our method and show its advantages and
limitations in this section.
Termination . Our method is guaranteed to terminate. This is
due to the fact that BPEL composite services do not support
recursion, as well as our assumption on the loop activities
such that the upper bound on the number of iterations and the
time of execution is known. We discuss how to enforce such
assumption if the loop activities exist. For the upper bound
on the number of iterations, it could be either provided by
the user, or it could be inferred by using loop bound analysis
tool, e.g., [7]. For the maximum time of loop executions, this
could in fact be enforced by using proper timeout mechanism
in BPEL.
Time for internal operations . For simplicity, we do not
account for the time taken for the internal operations of the
system. In reality, the time taken by the internal operations
might be signiÔ¨Åcant especially when the process is large. In
order to provide a more accurate synthesis of time constraint,
an additional constraint toverheadb, where toverhead2R0is
a time overhead for an internal operation, and b2R0is a
machine dependent upper bound for toverhead , could be included
for more precise analysis. The method in estimation of bis
not the focus of this work; the interested reader may refer to,
e.g., [8].
Completeness . A limitation of the method is that it is
incomplete, i.e., it does not include all parameter valuations
that could give a solution to the problem of the local time
requirement. The method could also return an empty con-
straint, although there exists parameter valuation that satisÔ¨Åes
the solution. This can be seen as a tradeoff of making the
synthesized local time requirement more general, i.e., to hold
in any composite service instances. Consider the conditional
case AC1=1BB, where activity Ais always executed, but
activity Bis never executed. Since our method is completely
abstracted from data, the constraint of executing activity A,
as well as activity B, are both considered; but, in fact, only
activity Aneeds to be considered, therefore our method has
discarded some feasible parameter valuation in this case. In
practice, such situation could be mitigated by proper program
analysis method.
VI. R ELATED WORK
This work shares common techniques with work for con-
straint synthesis for scheduling problems. The use of models
such as Parametric Timed Automata (PTA) [9] and Parametric
Time Petri Nets (TPNs) [10] for solving such problems has
received recent attention. In particular, in [11], [12], [13],
parametric constraints are inferred, guaranteeing the feasibility549of a schedule using PTAs with stopwatches. In [4], we ex-
tended the ‚Äúinverse method‚Äù (see, e.g., [14]) to the synthesis of
parameters in a parametric, timed extension of CSP. Although
PTAs or TPNs might have been used to encode (part of) BPEL
language, our work is speciÔ¨Åcally adapted and optimized for
synthesizing local timing constraint in the area of service
composition. The quantitative measure of the robustness of
concurrent timed systems has been tackled in different papers
(see [15] for a survey). However, most approaches consider a
single dimension : transitions can usually be taken at most 
(before or after) units of time from their original Ô¨Åring time.
This can be seen as a ‚Äúball‚Äù in jUjdimensions of radius . In
contrast, our approach quantiÔ¨Åes robustness for all parameter
dimensions, in the form of a polyhedron in jUjdimensions.
Our method is related to using LTS for analysis purpose
in Web services. In [16], the author proposes an approach to
obtain behavioral interfaces in the form of LTS of external
services by decomposing the global interface speciÔ¨Åcation.
It also has been used in the model checking the safety and
liveness properties of BPEL services. For example, Foster et
al. [17], [18] transform BPEL process into FSP, subsequently
using a tool named as WS-Engineer for checking safety and
liveness properties. Simmonds et al. [19] proposes a user-
guided recovery framework for Web services based on LTS.
Our work uses LTS in synthesizing local time requirement
dynamically.
Our method is related to the Ô¨Ånding of a suitable quality
of service (QoS) for the system [20]. The authors of [20]
propose two models for the QoS-based service composition
problem [21] model the service composition problem as a
mixed integer linear problem where constraints of global and
local component serviced can be speciÔ¨Åed. The difference
with our work is that, in their work, the local constraint has
been speciÔ¨Åed, whereas for ours, the local constraints is to be
synthesized. An approach of decomposing the global QoS to
local QoS has been proposed in [22]. It uses the mixed integer
programming (MIP) to Ô¨Ånd optimal decomposition of QoS
constraint. However, the approach only concerns for simplistic
sequential composition of Web services method call, without
considering complex control Ô¨Çow and timing requirement.
Our method is related to response time estimation. In [23],
the authors propose to use linear regression method and a
maximum likelihood technique for estimating the service de-
mands of requests based on their response times. [24] has also
discussed the impact of slow services on the overall response
time on a transaction that use several services concurrently.
Our work is focused on decomposing the global requirement
to local requirement, which is orthogonal to these works.
VII. E VALUATION
Here we report about the evaluation of our approach using
two case studies. Each case study consists of a service com-
position in the form of a BPEL process. The experiment data
were obtained on a system using Intel Core I5 2410M CPU
with 4GB RAM.A. Computer Purchasing Services
The goal of the computer purchasing service (CPS) (e.g.,
Dell.com) is to allow a user to purchase the computer system
online using credit cards. CPS makes use of Ô¨Åve component
services, namely Shipper Service (SS), Logistic Service (LS),
Inventory Service (IS), Manufacture Service (MS), and Billing
Service (BS). The global time requirement of the CPS is to
response within three seconds. CPS starts upon receiving the
purchase request from the client with credit card information,
and CPS spawns three workÔ¨Çows (viz., shipping workÔ¨Çow,
inventory workÔ¨Çow, and billing workÔ¨Çow) concurrently. In the
shipping workÔ¨Çow, the shipping service provider is invoked
synchronously for the shipping service on computer systems.
Upon receiving the reply, LS which is a service provided
by internal logistic department is invoked synchronously to
record the shipping schedule. In the manufacture workÔ¨Çow, IS
is invoked synchronously to check for the availability of the
goods. Subsequently, MS is invoked asynchronously to update
the manufacture department regarding the current inventory
stock. In the billing workÔ¨Çow, the billing service which is
offered by third party merchant, is invoked synchronously for
billing the customer with credit card information. The AOLTS
of this system contains 457 states and 6355 transitions. The
time taken for the synthesis with the simpliÔ¨Åcation to DNF
takes 2 seconds. The local time constraint for CPS contains a
disjunction of 12 conjuncts in the DNF, that are given below.
(tSS+tLStIS)^(tIStBS)^(tSS+tLS+tIS+tBS3)
_(tSS+tLStBS)^(tBStIS)^(tSS+tLS+tIS+tBS3)
_(tSS+tLStBS)^(tSStIS)^(tIStSS+tLS)^(tSS+tLS+tIS+tBS3)
_(tSStIS)^(tIStBS)^(tBStSS+tLS)^(tSS+tLS+tIS+tBS3)
_(tSS+tLStIS)^(tSStBS)^(tBStSS+tLS)^(tSS+tLS+tIS+tBS3)
_(tSStBS)^(tBStIS)^(tIStSS+tLS)^(tSS+tLS+tIS+tBS3)
_(tSS+tLStBS)^(tIStSS)^(tSS+tLS+tIS+tBS3)
_(tSStBS)^(tIStBS)^(tBStSS+tLS)^(tSS+tLS+tIS+tBS3)
_(tIStBS)^(tBStSS)^(tSS+tLS+tIS+tBS3)
_(tSS+tLStIS)^(tBStSS)^(tSS+tLS+tIS+tBS3)
_(tSStIS)^(tBStSS)^(tIStSS+tLS)^(tSS+tLS+tIS+tBS3)
_(tIStSS)^(tBStIS)^(tSS+tLS+tIS+tBS3)
Note that tMSdoes not appear in the local time constraint
for CPS. The reason is that MS is invoked asynchronously
without expecting a response; therefore its response time is
irrelevant to the global time requirement of CPS. Given each
service with their maximum response time as a constraint,
e.g., c1=tIS0:2^tLS0:2^tSS0:5^tBS0:5,
and the local time constraint CL, it is useful to know whether
c1is included in CL. This can be checked automatically using
SMT solver such as Z3 [6], and concluded that c1is included
inCL.
B. Travel Booking Service
The goal of a travel booking service (TBS) (such as Book-
ing.com) is to provide a combined Ô¨Çight and hotel booking
service by integrating two independent existing services. TBS
provides an SLA for its subscribed users, saying that it must
respond within three seconds upon request. The travel booking550system has Ô¨Åve component services, user validation service
(VS), Ô¨Çight service (FS), backup Ô¨Çight service (FS bak), hotel
service (HS) and backup hotel service (HS bak). Upon receiving
the request from users, TBS spawns two workÔ¨Çows (viz.,
a Ô¨Çight request workÔ¨Çow, and a hotel request workÔ¨Çow)
concurrently. In Ô¨Çight request workÔ¨Çow, it starts by invoking
FS, which is a service provided by a Ô¨Çight service booking
agent. If service FS does not respond within two seconds, then
FS is abandoned, and another backup Ô¨Çight service FS bakis
invoked. If FS bakreturns within one second, then the workÔ¨Çow
is completed; otherwise it is considered as a failure for the
Ô¨Çight request workÔ¨Çow. The hotel request workÔ¨Çow shares
the same process as the Ô¨Çight request workÔ¨Çow, by replacing
FS with HS and FS bakwith HS bak. The resulting AOLTS has
705 states with 3412 transitions, and it takes 1.5 seconds for
synthesizing the constraints, and simplify the constrains into
DNF. The local time constraint for TBS contains a disjunction
of 12 conjuncts in the DNF, that are shown below.
(tHSbak1)^(tFSbak1)^(tFS1)^(tHS2)^(tFS+tHSbak1)
_(2tHStFS)^(tHSbak1)^(tFSbak1)^(tFS+tHS3)^(tHS2)
_(tHSbak1)^(tFSbak1)^(tHS1)^(tFS2)^(tFSbak +tHS1)
_(tHS2tFS)^(tHSbak1)^(tFSbak1)^(tFS+tHS3)^(tFS2)
_(tHSbak1)^(tFS1)^(tHS2)^(tFS+tHSbak1)
_(tFS2tHS)^(tHSbak1)^(tFS2)^(tFS+tHS3)^(tHS2)
_(tHS2tFS)^(tHSbak1)^(tFS2)^(tFS+tHS3)
_(tFS2tHS)^(tHS2)^(tFSbak1)^(tFS+tHS3)
_(tHS1)^(tFSbak1)^(tFS2)^(tFSbak +tHS1)
_(tHS2tFS)^(tHS2)^(tFSbak1)^(tFS+tHS3)^(tFS2)
_(tFS2tHS)^(tHS2)^(tFS2)^(tFS+tHS3)
_(tHS2tFS)^(tHS2)^(tFS2)^(tFS+tHS3)
Note that the constraint contains inequalities such as
tHS2. This could be counterintuitive, as it asserts the re-
sponse time of hotel service be larger than 2. This inequality is
introduced by, for example, the < pick > activity (refer to state
s4inFig:4). But one should view the local time constraint as
whole, i.e., view it as all possible sets of parameter valuations
that could satisfy the constraint.
VIII. C ONCLUSION AND FUTURE WORK
We have presented a novel technique for synthesizing the
local time requirement for the component services of a com-
posite service S, knowing its global time requirement.
Our approach is based on the dynamic analysis of the
AOLTS of a composite service by making use of parame-
terized timed techniques. The synthesis algorithm conjuncts
and disjuncts the constraint of all good states in the AOLTS
to synthesize a local time constraint for component services.
We have implemented the approach in the PAT tool [25] and
applied it to two case studies.
We plan to further improve and develop the technique
presented in this paper. First, we will consider various heuris-
tics that could be used to reduce the number of states and
transitions. Second, we will investigate the combination of
our approach with other approaches such as the ‚Äúinverse
method‚Äù [4] to evaluate the possibility of synthesizing a betterlocal time requirement. Last, we could extend our current
approach to other domains that share similar problems, for
example sensor networks.
REFERENCES
[1] A. Alves, A. Arkin, S. Askary, C. Barreto, B. Bloch, F. Curbera, M. Ford,
Y . Goland, A. Gu√≠zar, N. Kartha, C. K. Liu, R. Khalaf, D. K√∂nig,
M. Marin, IBM, V . Mehta, S. Thatte, D. van der Rijn, P. Yendluri, and
A. Yiu, Web Services Business Process Execution Language Version,
version 2.0 , April 2007.
[2] R. Alur and D. Dill, ‚ÄúA theory of timed automata,‚Äù Theoretical computer
science , vol. 126, no. 2, pp. 183‚Äì235, 1994.
[3] J. Sun, Y . Liu, J. S. Dong, and X. Zhang, ‚ÄúVerifying stateful timed CSP
using implicit clocks and zone abstraction,‚Äù in ICFEM 2009 . Springer,
2009, pp. 581‚Äì600.
[4] √â. Andr√©, Y . Liu, J. Sun, and J.-S. Dong, ‚ÄúParameter synthesis for
hierarchical concurrent real-time systems,‚Äù in ICECCS 2012 . IEEE
Computer Society, 2012, pp. 253‚Äì262.
[5] A. Schrijver, Theory of linear and integer programming . John Wiley
and Sons, 1986.
[6] L. M. de Moura and N. Bj√∏rner, ‚ÄúZ3: An efÔ¨Åcient SMT solver,‚Äù in
TACAS 2008 , ser. LNCS. Springer, 2008, pp. 337‚Äì340.
[7] A. Ermedahl, C. Sandberg, J. Gustafsson, S. Bygde, and B. Lisper,
‚ÄúLoop bound analysis based on a combination of program slicing,
abstract interpretation, and invariant analysis,‚Äù in WCET 2007 , 2007.
[8] O. Moser, F. Rosenberg, and S. Dustdar, ‚ÄúNon-intrusive monitoring and
service adaptation for WS-BPEL,‚Äù in WWW 2008 , 2008, pp. 815‚Äì824.
[9] R. Alur, T. A. Henzinger, and M. Y . Vardi, ‚ÄúParametric real-time
reasoning,‚Äù in STOC 1993 . ACM, 1993, pp. 592‚Äì601.
[10] L.-M. Traonouez, D. Lime, and O. H. Roux, ‚ÄúParametric model-
checking of stopwatch Petri nets,‚Äù Journal of Universal Computer
Science , vol. 15, no. 17, pp. 3273‚Äì3304, 2009.
[11] A. Cimatti, L. Palopoli, and Y . Ramadian, ‚ÄúSymbolic computation of
schedulability regions using parametric timed automata,‚Äù in RTSS 2008 .
IEEE Computer Society, 2008, pp. 80‚Äì89.
[12] T. T. H. Le, L. Palopoli, R. Passerone, Y . Ramadian, and A. Cimatti,
‚ÄúParametric analysis of distributed Ô¨Årm real-time systems: A case study,‚Äù
inETFA 2010 . IEEE, 2010, pp. 1‚Äì8.
[13] L. Fribourg, D. Lesens, P. Moro, and R. Soulat, ‚ÄúRobustness analysis for
scheduling problems using the inverse method,‚Äù in TIME 2012 . IEEE
Computer Society Press, 2012, pp. 73‚Äì80.
[14] √â. Andr√© and R. Soulat, The Inverse Method . ISTE Ltd and John Wiley
& Sons Inc., 2013.
[15] N. Markey, ‚ÄúRobustness in real-time systems,‚Äù in SIES 2011 . IEEE,
2011, pp. 28‚Äì34.
[16] D. Bianculli, D. Giannakopoulou, and C. S. Pasareanu, ‚ÄúInterface
decomposition for service compositions,‚Äù in ICSE , 2011, pp. 501‚Äì510.
[17] H. Foster, ‚ÄúA Rigorous Approach To Engineering Web Service Compo-
sitions,‚Äù Ph.D. dissertation, Imperial College of London, 2006.
[18] H. Foster, S. Uchitel, J. Magee, and J. Kramer, ‚ÄúLTSA-WS: a tool for
model-based veriÔ¨Åcation of Web service compositions and choreogra-
phy,‚Äù in ICSE 2006 , 2006, pp. 771‚Äì774.
[19] J. Simmonds, S. Ben-David, and M. Chechik, ‚ÄúGuided recovery for Web
service applications,‚Äù in SIGSOFT FSE 2010 , 2010, pp. 247‚Äì256.
[20] T. Yu, Y . Zhang, and K.-J. Lin, ‚ÄúEfÔ¨Åcient algorithms for Web services
selection with end-to-end QoS constraints,‚Äù TWEB , vol. 1, no. 1, 2007.
[21] D. Ardagna and B. Pernici, ‚ÄúGlobal and local QoS guarantee in Web
service selection.‚Äù in Business Process Management Workshops , 2005.
[22] M. Alrifai and T. Risse, ‚ÄúCombining global optimization with local
selection for efÔ¨Åcient qos-aware service composition.‚Äù in WWW 2009 .
ACM, 2009, pp. 881‚Äì890.
[23] S. Kraft, S. Pacheco-Sanchez, G. Casale, and S. Dawson, ‚ÄúEstimating
service resource consumption from response time measurements,‚Äù in
VALUETOOLS , 2009, p. 48.
[24] D. A. Menasc√©, ‚ÄúResponse-time analysis of composite Web services,‚Äù
IEEE Internet Computing , vol. 8, no. 1, pp. 90‚Äì92, 2004.
[25] J. Sun, Y . Liu, J. S. Dong, and J. Pang, ‚ÄúPAT: Towards Ô¨Çexible
veriÔ¨Åcation under fairness,‚Äù ser. Lecture Notes in Computer Science,
vol. 5643. Springer, 2009, pp. 709‚Äì714.551