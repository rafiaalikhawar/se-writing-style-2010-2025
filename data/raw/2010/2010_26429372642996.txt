ValidatingAjax Applications Using a Delay-Based Mutation
Technique
Yuta Maezawa, Kazuki Nishiura, Shinichi Honiden
The University of Tokyo
Tokyo, Japan
{maezawa, k-nishiura, honiden}@nii.ac.jpHironori Washizaki
Waseda University
Tokyo, Japan
washizaki@waseda.jp
ABSTRACT
The challenge of validating Asynchronous JavaScript and
XML (Ajax) applications lies in actual errors exposed in a
user environment. Several studies have proposed eÔ¨Äective
and eÔ¨Écient testing techniques to identify executable faults.
However, the applications might have faults that are not ex-
ecuted during testing, but might cause actual errors in a user
environment. Although we have investigated static methods
for nding \potential faults" that seem to cause actual er-
rors if executed, developers need to conrm whether or not
the potential faults are actually executable. Herein, we pro-
pose a mutation-based testing method implemented in a tool
called JSPreventer. Even if the potential faults are not easily
executable in a given environment, our method mutates the
applications until they are executable using two delay-based
mutation operators to manipulate the timing of the appli-
cations handling interactions. Thus, JSPreventer provides
executable evidences of the not-easily-executable faults for
developers, if it reveals actual errors by testing the mutated
applications. We applied our method to real-world applica-
tions and found actual errors that developers could debug
to improve their reliability. Therefore, JSPreventer can help
developers validate reliable real-world Ajax applications.
Categories and Subject Descriptors
D.2.5 [Software Engineering ]: [Testing and Debugging]
Keywords
Ajax; JavaScript; Web application testing; Software valida-
tion
1. INTRODUCTION
Asynchronous JavaScript and XML (Ajax) [1] make Web
applications responsive [2]. Ajax applications improve us-
ability because they can handle user events on the client
Sh
inichi Honiden and Hironori Washizaki are also aÔ¨Éliated
to National Institute of Informatics, Japan.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for proÔ¨Åt or commercial advantage and that copies bear
this notice and the full citation on the Ô¨Årst page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on servers or to
redistribute to lists, requires prior speciÔ¨Åc permission and/or a fee. Request
permissions from Permissions@acm.org.
ASE‚Äô14 , September 15 - 19 2014, Vasteras, Sweden
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2642996side and asynchronously retrieve data necessary to dynam-
ically update Web page content without page transitions,
and this is crucial to attracting Web users [3]. Moreover,
the number of users exceeded 2.4 billion as of June 2012 [4],
making Ajax applications essential platforms for daily life.
The challenge to validating Ajax applications arises from
their event-driven, asynchronous, and dynamic features. De-
spite concerted eÔ¨Äorts by developers, these features mean
that not all possible behaviors of running applications can
be predicted, and these diÔ¨Écult-to-predict behaviors may
be error-prone. To nd faults in Ajax applications, a state-
based approach may be more eÔ¨Äective than navigation-model-
based, code-coverage, or black-box ones [5]. Several state-of-
the-art studies on state-based testing [6, 7, 8, 9] have eÔ¨Äec-
tively and eÔ¨Éciently found executable faults using the state
space of Ajax applications. However, the applications might
have faults that are not executed during testing if the faults
cause actual errors only when specic conditions are met,
such as unexpected user operations, Web browser behaviors,
and network delays. Since it would be unrealistic to test the
applications under all possible conditions, these faults are
not easily detectable even if developers use the state-of-the-
art testing techniques. Consequently, users might encounter
erroneous behaviors in the applications when a user envi-
ronment meets the specic conditions.
In our previous studies [10, 11], we have investigated static
methods for identifying Ajax application behaviors that seem
to cause errors when specic conditions are met (e.g., un-
able to login using a correct username and password because
of improper use of asynchronous communications). Figure
1 overviews our tool, called JSPreventer , that is based on
our previously proposed tool, called JSVerifier , and these
features are highlighted below.
Implementation We assume that Ajax design patterns [12],
which have been collected from observations in many
real-world Ajax applications, describe of the properties
of the application behaviors expected by developers.
Hence, the implemented Ajax design pattern informa-
tion (IADP info) can be leveraged to verify whether
an Ajax application is running as expected.
Extractor We assume that interactions with Ajax applica-
tions can trigger changes in the application states. In-
teractions correspond to how user events, asynchronous
server responses, and timeouts are handled. Because
the source code contains these events and event han-
dlers, our extraction method [10] statically analyzes
the relationships among interactions via a call graph
and constructs a nite state machine.
491
‚Ä¶ 
‚Ä¶ 
‚Ä¶ ‚Ä¶ 
‚Ä¶ 
‚Ä¶ ‚Ä¶ 
‚Ä¶ 
‚Ä¶ ‚Ä¶ 
‚Ä¶ 
‚Ä¶ 
Faulty Source Code  Faulty Interaction Sequences  Extractor  Verifier  Implementation  
‚Ä¶ 
‚Ä¶ 
‚Ä¶ ‚Ä¶ 
‚Ä¶ 
‚Ä¶ ‚Ä¶ 
‚Ä¶ 
‚Ä¶ ‚Ä¶ 
‚Ä¶ 
‚Ä¶ 
Debugged Source Code  Ajax Design Patterns  
Formulator  
Interaction 
Invariants  IADP Info ‚Ä† 
Finite State Machines  Revealer  
Debugging  Actual Errors  JSPreventer  Test Data/Oracles  
‚Ä¶ 
‚Ä¶ 
‚Ä¶ ‚Ä¶ 
‚Ä¶ 
‚Ä¶ ‚Ä¶ 
‚Ä¶ 
‚Ä¶ ‚Ä¶ 
‚Ä¶ 
‚Ä¶ 
Mutated  Source Code  ‚Ä† Implemented Ajax Design Pattern Information  
JSVerifier  Previous 
Work  Proposed 
Extension  Figu
re 1: Overview of JSPreventer
Formulator and Verier Using the IADP info as a guide,
our verication method [11] instantiates interaction in-
variants, and the applications handle their interactions
in invariant occurrence and order. Whether the ex-
tracted nite state machine satises the interaction
invariants is automatically veried using the NuSMV
model checker1. Finally, JSVerier obtains faulty in-
teraction sequences from counterexamples of the veri-
cation results, e.g., fonload, init(), onclick, callback(),
...g, and reports the presence of\potential faults"that
seem to cause actual errors if executed.
Although we claim that faulty interaction sequences are
associated with potential faults reported by JSVerier, the
following two research questions remain unanswered.
RQ1 Can JSPreventer reveal actual errors caused by po-
tential faults in Ajax applications? This question can
be answered by testing whether actual errors are due
to potential faults. However, the existing testing tech-
niques cannot reveal such errors because the potential
faults might not be easily executable.
RQ2 Can JSPreventer reveal these errors in a feasible amount
of time? Although testing all possible scenarios in ev-
ery environment should reveal all errors, such a method
would be unrealistic.
This paper presents a mutation-based testing method to
answer the above questions.
Revealer JSPreventer gets the faulty interaction sequences
as input from JSVerier and tries to nd executable ev-
idences of the potential faults. However, JSPreventer
may not easily execute Ajax applications on the faulty
interaction sequences because a specied environment
does not meet specic conditions to reveal actual er-
rors due to the potential faults. Therefore, we assume
that an unexpected network latency [13] may make
the potential faults executable. To emulate an un-
expected network latency, we dene synchronous and
asynchronous delay-based mutation operators (Section
3). Although a program mutation technique is basi-
cally used for injecting articial faults [14], we lever-
age the technique to allow JSPreventer to make po-
tential faults executable in the specied environment.
1nus
mv.fbk.euThis is because our mutation operators change non-
functional aspects of Ajax applications, but the ap-
plications can handle specic server responses after a
given delay time has elapsed. We expect that test-
ing the mutated source code with the given test data
and oracles will reveal actual errors. Thus, JSPreven-
ter provides developers with executable evidences of
not-easily-executable faults during testing, i.e., subtle
network delays are required for revealing actual errors.
Debugging Outputs from JSVerier and JSPreventer (i.e.,
an extracted nite state machine, identied faulty in-
teraction sequences, and revealed actual errors) are
used to debug the original source code until JSVerier
does not report any potential faults. JSPreventer can
then be used for validating reliable Ajax applications.
Compared with our previous studies [10, 11], the novelty
of this study lies in revealing actual errors due to poten-
tial faults in Ajax applications. Since Ajax design patterns
aim to improve the usability of Ajax applications, code vi-
olations against the design patterns do not always lead to
actual errors being debugged. Additionally, the faulty inter-
action sequences that are identied are counterexamples in
the extracted nite state machine. Counterexamples in an
abstract model can be spurious; therefore, it is important to
reanalyze them in an actual system [15]. Consequently, we
argue that the novelty of our study is that it helps developers
validate Ajax applications.
Our contributions are:
A mutation-based testing method that reveals actual
errors due to potential faults in Ajax applications.
Denitions of synchronous and asynchronous delay-
based mutation operators.
An implementation of our method in JSPreventer.
Case study experiments on real-world Ajax applica-
tions demonstrating that JSPreventer can reveal ac-
tual errors due to potential faults.
This paper is organized as follows. Section 2 uses an exam-
ple to illustrate the challenge of Ajax application validation.
Section 3 describes our mutation-based testing method, while
Section 4 evaluates our method. Section 5 covers related
work, and Section 6 is the conclusion.
2. MOTIVATING EXAMPLE
To illustrate the aforementioned challenge, we implemented
a simple Ajax application called QAsite2. QAsite is a typical
Q&A website where users can ask and answer each other's
questions, such as in Experts Exchange3and Quora4. In
implementing QAsite, we referred to the User Action ,On-
Demand JavaScript , and Direct Login patterns described
in the Ajax design patterns [12].
Figure 2 briey depicts the source code, while Figure 3
shows screenshots of QAsite, which runs as follows.
2Run
ning examples and analysis results are available from
mzw.jp/yuta/research/ex/QAsite
3www.experts-exchange.com
4www.quora.com
4921<html><head>
2<!   Load e x t e r n a l JavaScript f i l e    >
3<s c
r i p t type="text / j a v a s c r i p t "
4 s r
c ="j s / prototype . j s " ></s c r i p t >
5<s c
r i p t type="text / j a v a s c r i p t " ><!  //
6 .
. . / User Action /
7 w
indow . onload = function ()f
8 $
( "username ") . onfocus = getSeed ;
9 $
( "password ") . onfocus = getSeed ;
10
$ ( " l o g i n ") . o n c l i c k = validateLogin ;
11
$ ( "good ") . onmousedown = onGood ;
12g
13
. . . / Direct Login /
14f
unction getSeed ( ) f
15 i
f( ! loggedIn && ! hasSeed ) f
16 n
ewAjax . Request (LOGIN PR
EFIX, f
17
method : "GET" ,
18
parameters : "task=getseed " ,
19
onSuccess : handleHttpGetSeed g) ;
20 g
21g
22f
unction handleHttpGetSeed ( r e s ) f
23
/Set response to "seed " v a r i a b l e /g
24
. . .
25f
unction validateLogin ( ) f
26 n
ewAjax . Request (LOGIN PR
EFIX,
27
method : "GET" ,
28
parameters : "task=checklogin & . . . " ,
29
onComplete : tryLogin g) ;
30g31function tryLogin ( r e s ) f
32 i f(i s S u c c e s s ( r e s ) ) f
33 //
Create logout anchor
34 //
Disable l o g i n form
35 //
Make answer readable
36 gel
sea l e r t ( " I n v a l i d account ") ;
37g
38 .
. . / On Demand JavaScript /
39fu
nction onGood ( ) f
40 / 
Handle "Good ! " button c l i c k s /g
41 .
. .
42fu
nction tryLogout ( ) f
43 /
/ Disable logout anchor
44 /
/ Enable l o g i n form
45 /
/ Make answer masked
46g
47 /
/  ></s c r i p t >
48</h
ead><body>. . .
49<h1>Q
Asite</h1>. . .
50<h2>Q
uestion </h2>. . .
51<h2>A
nswers </h2>. . .
52<bu
tton id="good" >Good!</button >
53 .
. .
54<di
v id="mask" ></div><!  f o r masking answer    >
55 .
. .
56<h2>L
ogin /out </h2>. . .
57<in
put id="username " type="text " / >
58<in
put id="password " type="password " / >
59<in
put id="l o g i n " type="submit " / >
60 .
..</ body ></html>
Fig
ure 2: Source code of our motivating example: QAsite
Figu
re 3: Screenshots of QAsite
Table 1: Actual errors in the QAsite
FIS
# Ajax
design pattern Brief
explanation of erroneous behavior Act
ual error
1 User Ac
tion QAsi
te might not prevent multiple calls to validateLogin Un
necessary
when
a user unexpectedly double-clicks on the login button. serv
er sessions
2 On-Dem
and QAsi
te can handle onGood before successful login In
valid user
Jav
aScript du
e to a dead link to the mask image le. op
erations
3 Direct
Login QAsi
te can send requests for login attempts without seed data. In
valid login
Then
, a user cannot log in with his or her username and password. at
tempts
493Nameless_55 init 
onload 
onfocus 
handleHttpGetSeed 
validateLogin loggedIn && !hasSeed]
onmouse
downonSuccess 
onmousedown getSeed 
Branch_136 Nameless_55 Nameless_55 Nameless_55 init 
onload 
onfocus 
getSeed 
handleHttpGetSeed handleHttpGetSeed handleHttpGetSeed 
validateLogin validateLogin validateLogin hasSeed ]
onm
dowonSuccess 
onmousedown Branch_136 Branch_136 
handleHttpGetSeed handleHttpGetSeed handleHttpGetSeed 
validateLogin validateLogin loggedIn  && ! hasSeed 
onmouse
down
onmousonmBranch_136 Branch_136 Branch_136 
(F-2) QAsite sends account info. (F-1) Without seed data 
(E) Immediate resp. Faulty interaction sequence #3 
Executed interaction sequence #3 
Fig
ure 4: Finite state machine extracted from QAsite
(i) Page load: Upon a page load, QAsite registers user
event handlers for the login form and the \Good!" but-
ton (lines 7-12). The User Action pattern notes such
implementations so that Ajax applications can handle
user events anytime. Additionally, the QAsite masks
the answers (line 54) to prohibit guest users from view-
ing them. This implementation is similar to the On-
Demand JavaScript pattern, in which QAsite should
handle the click on the \Good!" button after users
login.
(ii) Login: We implemented the login form according to
the Direct Login pattern. When a user sets the cursor
on the input forms (lines 8-9), QAsite determines that
the user intends to log in, and QAsite asynchronously
retrieves seed data from the server (lines 14-23). When
a user clicks on the login button (line 10), QAsite sends
the username and a hash value with the password and
seed data for secure communications to validate the
account on the server side (lines 25-30). After receiving
the validation result (line 29), QAsite creates a logout
widget and disables the login form if the information
is valid (lines 32-35).
(iii) Answer view: While it is creating the logout widget,
QAsite removes the mask (lines 32-35). The user can
then view the answers and click the \Good!" button
(lines 11 and 39-40). When the user logs out, QAsite
disables the logout widget, enables the login form, and
masks the answers again (lines 42-46).
2.1 Results of Our Previous Studies
Although QAsite seems to run as expected, JSVerier pro-
posed in our previous studies [10, 11] reports the presence
of three potential faults, which are listed in Table 1. Herein,
we explain how JSVerier works.
JSVerier statically extracts a nite state machine from
the source code of Ajax applications (Extractor in Figure
1). In our static extraction method, we focus on interactions
with Ajax applications, such as mouse clicks and server re-
sponses, as triggers that can change the application states.
The interactions are implemented at event handlers for user
events or asynchronous communications in the source code;therefore, JSVerier can nd all the interactions in a static
manner. For example, in Figure 2 (line 8), JSVerier nds
that QAsite changes its state when handling the onfocus
event. To construct a nite state machine based on the in-
teractions, JSVerier leverages a call graph that represents
function caller-callee relationships because the interactions
are function callbacks in response to events. Thus, JSVerier
outputs an interaction-based nite state machine containing
application behaviors that are independent of the testing en-
vironment. Figure 4 shows a nite state machine extracted
from QAsite.
Additionally, JSVerier runs the NuSMV model checker
to verify the correctness of the extracted nite state machine
(Verifier in Figure 1). However, the model checker cannot
determine whether or not the behaviors of Ajax applica-
tions are ones developers expect. Fortunately, Ajax design
patterns are based on observations in many real-world Ajax
applications. Therefore, we assume that the design patterns
present the properties of the application behaviors expected
by developers. Hence, we dene invariants to be veried
from the behavior properties relevant to the interactions.
For example, the Direct Login pattern indicates that QA-
site should receive the seed data before sending the account
information.
JSVerier also uses the property pattern mappings5, which
provide template formulas for nite-state verication, to ex-
press invariants in verication formulas. As template param-
eters, JSVerier requires developers of functions or events
where they implement Ajax design patterns (IADP info)
so that it instantiates verication formulas ( Formulator in
Figure 1). As an example of the Direct Login pattern in
QAsite, developers input the handleHttpGetSeed and val-
idateLogin functions (lines 22 and 25 in Figure 2) as the
IADP info. From a counterexample of the verication re-
sults, JSVerier then identies faulty interaction sequence
#3 regardless of whether or not it is executable in a testing
environment (visualized by the bold solid arrow in Figure
4). Thus, JSVerier reports the presence of potential faults
in Ajax applications that seems to cause actual errors if ex-
ecuted.
5pa
tterns.projects.cis.ksu.edu
494Faulty Interaction Sequences (FISs)  
Test data  
Mutated code  Executed Interaction Sequences (EISs)  
FISs = EISs  
End  Revealing errors due to potential faults  
Actual errors  Original code  
Yes  
No  Executing on FISs  (Step 1-a)  
Applying mutation operators  (Step 2)  
Testing mutated code  (Step 3)  Test oracle  FISs = EISs  Yes  
No  Executable 
faults (EFs)  
Executing on FISs  (Step 1-b)  
EISs  
Delay-dependent 
potential faults 
(DdPFs) 
 Branch point 
found?  *-dependent 
potential faults 
(*dPFs) No  Yes  Figu
re 5: JSPreventer workow
2.2 The Challenge
The potential faults reported by JSVerier can be exposed
under a specic set of conditions but have little chance of be-
ing found if the set is unknown. A problem with such faults
is that developers have trouble detecting them during testing
because they cause errors only when complicated conditions
are met [16]. Therefore, our challenge in this study is to
reveal actual errors due to faults in developers' testing envi-
ronments before users encounter erroneous behaviors in the
applications.
As an example of faulty interaction sequence #3, if QA-
site is validated with browsers in a reliable network (e.g.,
with Firefox and Chrome browsers in a local host environ-
ment), it can immediately receive a response to obtain the
seed data [(E) in Figure 4] and cannot run along with faulty
interaction sequence #3. However, an unexpected network
latency that occurs when the seed data is being obtained en-
ables QAsite to send account information without the seed
data [(F-1) and (F-2) in Figure 4], which prevents the user
from logging in with his or her correct username and pass-
word. Despite concerted eÔ¨Äorts by developers, identifying
unexpected conditions, such as specic communication de-
lays in the unpredictable context of a running application,
is still extremely diÔ¨Écult. Consequently, JSPreventer is de-
signed to systematically test whether Ajax applications run
as expected on faulty interaction sequences that might not
be easily executable in the given environments.
3. OUR APPROACH
Figure 5 depicts the three-step process that JSPreven-
ter uses for validating Ajax applications. JSPreventer ini-
tially executes Ajax applications on the faulty interaction
sequences identied by JSVerier (Step 1-a). If the poten-
tial faults associated with these sequences are not easily exe-
cutable, JSPreventer mutates the source code until the Ajax
applications do execute the potential faults (Steps 2 and 1-
b). Then, developers test for the unexpected behavior due to
the potential faults by using the mutated applications (Step
3). Additionally, JSPreventer classies potential faults into
executable, delay-dependent potential, and *-dependent po-
tential faults, which are dened in Section 3.2.1<bu
tton o n c l i c k ="handleClick ( ) " / >
2 . . .
3<s c
r i p t s r c ="handleClick . j s " / >
Figu
re 6: Loading a JavaScript le with improper
timing
3.1 Executing Faulty Interaction Sequences
Because executing Ajax applications results in actual er-
rors if there are any, JSPreventer rst attempts to execute
the applications in accordance with the identied faulty in-
teraction sequences (Step 1-a in Figure 5). Although JSPre-
venter uses the Selenium WebDriver6in order to make its
execution as automated as possible, developers must input
test data that cannot be inferred by any tools, such as a
correct username and password, in order to test a successful
login scenario. JSPreventer executes applications with test
data and obtains the executed interaction sequences from
the execution results. If the executed interaction sequences
and faulty interaction sequences are identical, JSPreventer
determines that potential faults in the applications are exe-
cutable faults against the implemented Ajax design pat-
terns. As previously mentioned, executable faults can be
revealed through state-of-the-art methods.
If the potential faults are not executed, JSPreventer fo-
cuses on the diÔ¨Äerences between the faulty interaction se-
quences and the executed interaction sequences. DiÔ¨Äerences
may occur because Ajax applications cannot handle certain
interactions in faulty interaction sequences. The solid and
dashed arrows in Figure 4 respectively represent faulty inter-
action sequence #3 and its executed interaction sequence.
At the meshed circle in the gure, WebDriver emulates the
onfocus user action, but QAsite actually handles the onSuc-
cess event because of an immediate server response. How-
ever, the ability to manipulate the timing of the applications
handling the interactions allows Ajax applications to run as
faulty interaction sequences. Thus, a mutation technique
can be used to manipulate the timing.
3.2 Applying Mutation Operators
By mutating the source code of the Ajax applications,
JSPreventer enables them to run on faulty interaction se-
quences in a given environment (Step 2 in Figure 5). We
assume that an unexpected network latency might allow
potential faults to be executable and dene the following
delay-based mutation operators.
Synchronous delay: A Web browser parses the HTML
code from top to bottom while loading a Web page.
When the browser nds a script element whose src
attribute has the location of an external JavaScript
le, it begins loading the JavaScript le. Because the
JavaScript code can dynamically manipulate the Web
page content, the browser blocks render the remain-
ing HTML code until the JavaScript le is completely
loaded. Therefore, script elements can be implemented
at the bottom of the HTML code in order to render all
page elements as fast as possible. This is a well-known
way to increase the perceived performance [17].
Loading a JavaScript le at the improper time may
cause an actual error. Figure 6 shows brief code frag-
ments to explain our synchronous delay mutation op-
6do
cs.seleniumhq.org/projects/webdriver
4951 /
/ Original code
2 $. get ( " myscript . php " , // URL
3 fna
me : "Yuta " g, // query s t r i n g
4 fu
nction ( data ) f // c a l l b a c k
5 a l
e r t ( "Response i s " + data ) ;
6 g) ;
7
8 /
/ Mutated code
9ne
wDelayedRequest (3000) . applyFunction (
10 $
. get , // t a r g e t func
11 "
myscript . php " , // URL
12 fna
me : "Yuta " g, // query s t r i n g
13 fu
nction ( data ) f// c a l l b a c k
14 a l
e r t ( "Response i s " + data ) ;
15 g) ;
Figu
re 7: Example of our wrapper function
erator. In this application, developers implement the
handleClick function in the handleClick.js JavaScript
le and set the function as the onclick event handler
of the button element. Following common practice,
the script element is then implemented at the bottom
of the HTML code. However, an unexpected network
latency may delay loading of the JavaScript le. The
application cannot respond to the onclick event oc-
currence because this scenario allows a user to click a
button even though the browser has yet to register the
event handler.
To emulate a JavaScript le loading delay due to an
unexpected network latency, JSPreventer inserts an ar-
ticial script element whose src attribute is located in
our server-side program. This program then sends an
HTTP response with a given delay time, causing a
synchronous delay. This HTTP response consists of
header and body sections in which are set \content-
type: application/javascript" and an empty string, re-
spectively. In this manner, JSPreventer can manip-
ulate the timing of handling interactions relevant to
page loading, such as an onload event.
Asynchronous delay: Although the most signicant fea-
ture of Ajax applications is the asynchronous commu-
nications between the client and server, an unexpected
network latency can signicantly impact this feature.
Unlike a synchronous delay, an unexpected network
latency does not inhibit rendering of Web page con-
tent or handling of user interactions. Consequently,
it is extremely diÔ¨Écult to consider all possible states
where Ajax applications may have to handle a delayed
asynchronous server response.
To emulate a handling delay with an asynchronous
server response, JSPreventer rewrites the correspond-
ing JavaScript code fragment by using our wrap func-
tion, DelayedRequest , as shown in Figure 7. JSPre-
venter nds a target function for an asynchronous server
request in the original code and parses its arguments,
such as URL, query string, and callback function. In-
stead of the original code, JSPreventer inserts an in-
stantiation statement of the DelayedRequest with a
given delay time, e.g., 3000 msec. The DelayedRequest
sends the same asynchronous server request as the orig-
inal one, but does not invoke the callback function even
if a response is immediately received. After the given
delay time has elapsed, the DelayedRequest invokes
the callback function.Our mutation operators do not change the functionalities of
Ajax applications because the applications can still handle
a specic interaction after the given delay has elapsed.
To determine where to apply our mutation operators, JSPre-
venter searches for a branch point between the faulty inter-
action sequences and executed interaction sequences, such as
the meshed circle in Figure 4. The branch point may pre-
vent Ajax applications from running on the faulty interac-
tion sequences. The mutation operators are then applied to
an interaction in the executed interaction sequences at this
point, e.g., the onSuccess event handler. Even if the server
immediately responds, QAsite does not handle the server
response within the delay period. By iterating Steps 1-b
and 2 in Figure 5 until the executed interaction sequences
equal the faulty interaction sequences, JSPreventer arti-
cially sets up conditions in which potential faults can be ex-
posed. Finally, it classies the potential faults that become
executable by applying our mutation operators as delay-
dependent potential faults . Thus, JSPreventer provides
developers with executable evidences of the delay-dependent
potential faults which are not-easily-executable faults be-
cause they are not executed without subtle network delays.
However, not all applications can be mutated to produce
identical executed interaction sequences and faulty interac-
tion sequences. Faulty interaction sequence #2 in Table
1 means that QAsite can call the onGood function without
receiving the server response for login. Although JSPre-
venter injects the same articial delay as in the case of
faulty interaction sequence #3, the \Good!" button can-
not be clicked because the mask works as expected. This
means that JSPreventer cannot make the potential faults
executable. JSPreventer classies these potential faults as
*-dependent potential faults , which might cause actual
errors for reasons other than delayed injection.
3.3 Testing Mutated Code
Because developers implement Ajax design patterns ac-
cording to their intentions, we assume that they can also
implement test oracles to verify whether the patterns are
correctly implemented in Ajax applications or not. With
such test oracles, JSPreventer can determine whether the
mutated code has passed the test (Step 3 in Figure 5). If
the code fails a test, developers can determine the actual
errors from the test results.
JSPreventer outputs actual errors in addition to a nite
state machine and faulty interaction sequences from JSVer-
ier. We assume that these outputs will help developers
debug the original source code because they allow the com-
plex behaviors of Ajax applications to be understood, the
faulty behaviors of a nite state machine to be identied,
and unexpected behaviors due to potential faults to be ob-
served. Thus, developers can use JSPreventer to prevent
actual errors due to potential faults in Ajax applications.
3.4 Use Scenario of JSPreventer
Figure 8 illustrates a JSPreventer use scenario based on
the results of our motivating example, assuming that JSPre-
venter is applicable in the context of iterative and incre-
mental development [18]. In fact, developers often select
a simplied and rapid iteration development life cycle [19].
The scenario in JSPreventer involves ve steps: (i) the im-
plemented Ajax design pattern information (IADP info) is
initially inputted to JSVerier; (ii) JSVerier suggests faulty
496‚Ä¶
Faulty Interaction  Sequence
 (i) Input IAD P Info
(iii) Input test data and oracles
(iv) Observe and debug actual errors
(ii) Notice potential faults
(v) Confirm correctness and reliabilityFig
ure 8: JSPreventer use scenario
interaction sequences in the applications against the IADP
info and reports the presence of potential faults. (iii) Devel-
opers provide test data and oracles to JSPreventer; (iv) to
reveal unexpected runs, JSPreventer mutates and tests the
applications. In this step, if the potential faults become to
be executable with subtle network delays, we assume that
the executable evidences and the revealed actual errors can
be of help in validating and debugging the applications; (v)
through iterative development, highly reliable Ajax applica-
tions can be released.
4. EVALUATION
We conducted case studies and evaluated the usefulness of
JSPreventer by answering the following research questions.
RQ1 Can JSPreventer reveal actual errors caused by po-
tential faults in Ajax applications?
RQ2 Can JSPreventer reveal the errors in a feasible amount
of time?
4.1 Subject Ajax Applications
Table 2 shows the Ajax applications which we used in
our case studies. To nd real-world Ajax applications in
which developers had implemented Ajax design patterns, we
searched by using keywords relevant to Ajax design patterns
with NerdyData7, which provides a search engine for the
source code on websites.
2020m We searched for \login con
troller.js" where James
Dam8implemented the Direct Login pattern9. The
7ner
dydata.com
8Internet Archive: goo.gl/S47AVV
9Ajax Login System Demo: goo.gl/yCcxtNoptical accessory supplier website was found at the top
of the search results.
UCDChina and ESA Additionally, we searched for \on-
blur=checkInput" and \onsubmit=validate", which are
representative of the Live Form pattern. The Live
Form pattern suggests that Ajax applications should
check form data before making a submission. From
the search results, we found Chinese and British com-
panies' portal websites.
4.2 Experimental Setup
Our case study experiments were conducted on a 64-bit
Mac OS X 10.9.2 machine with an Intel Core i5 (2.3GHz)
and 16 GB of memory. First, we saved complete Web pages
of the subjects by using Mozilla Firefox and obtained HTML,
CSS, and JavaScript source code les. Then, we leveraged
Code Beautier10to count lines of these codes, as listed in
Table 2 (HTML, CSS , and JS). The 1K-10K lines of code
range represents medium-largish Ajax applications. Note
that only client-side source code could be obtained; there-
fore, we implemented mock server-side scripts in PHP.
Next, we used JSVerier to extract the nite state ma-
chine from each subject. Table 2 lists the extraction time
(Te) and the numbers of states and transitions of the nite
state machine (#states and #trans: ).
Table 3 lists the interaction invariants used in our case
studies. The interaction invariants to be satised were de-
termined for each subject (Table 4). In the source code of
all the subjects, we found implementations of asynchronous
communications and page load event handlers. Therefore,
10ct
rlq.org/beautifier
497Tabl e 2: Subject Ajax applications
Sub
ject URL HTML CSS JS #states #trans. Te(sec) Tv(sec)
202
0m http://2020m.com 188 420 2468 15 57 9.434 0.344
UCDChina http://ucdchina.com 1978 898 880 32 508 14.166 0.624
ESA http://www.easyservicedapartments.com 4751 964 3523 34 602 17.705 0.657
Tab
le 3: Interaction invariants derived from Ajax design patterns
# Exp
ected application behavior Ajax design pattern Pattern category
1 Han
dling user events during asynchronous communications XMLHttpRequest Call Fundamental Technology
2 Registering user event handlers at page load User Action Fundamental Technology
3 Validating form data before submission Live Form Functionality and Usability
4 Retrieving seed data before login attempt Direct Login Functionality and Usability
5 Disabling login form after successful login Direct Login Functionality and Usability
we
determined that Invariants #1 (XMLHttpRequest Call)
and #2 (User Action) should be satised in all the subjects.
Additionally, considering the search keywords, we also deter-
mined that Invariants #4 and #5 (Direct Login) in 2020m
and Invariant #3 (Live Form) in UCDChina and ESA should
be satised. JSVerier then veried all the invariants for
each subject and reported the verication time (T vin Table
2) and the verication results ( Result vin Table 4).
If the verication result was incorrect, JSPreventer exe-
cuted the classication workow shown in Figure 5. We set
the delay time to be 3 seconds. Additionally, we provided all
the necessary test data and oracles, such as the correct user-
name and password, for successful logins in 2020m. Finally,
JSPreventer classied the potential faults that caused incor-
rect verication results into executable, delay-dependent po-
tential, or *-dependent potential faults. The Result ccolumn
in Table 4 corresponds to these classication results. JSPre-
venter also reported the execution, mutation, and testing
times (T x,Tm, and Tt).
Additionally, we conducted comparative experiments with
Crawljax11, which is a state-of-the-art tool for nding faults
in Ajax applications [6, 8, 20, 9]. The default setting of
Crawljax could not nd any delay-dependent potential faults
in the subjects.
4.3 Results and Discussions
Revealing actual errors due to delay-dependent
potential faults (RQ1): JSPreventer could classify po-
tential faults reported by JSVerier into executable, delay-
dependent potential, and *-dependent potential faults. As
indicated in Table 5, it found actual errors in the subjects.
We reviewed the source code of the subjects and conrmed
that the actual errors could be exposed.
In 2020m, users could not log in even with their correct
username and password because 2020m sent the login re-
quest with the initial value at the declaration statement
of the seed variable. For secure password hashing, 2020m
used the MD5 algorithm to a value obtained by adding
theseed variable to the user password. Although 2020m
should use the seed variable generated at runtime, it hashed
the value with the initial value \0"; hence, 2020m sent the
hashed value using the raw user password. The MD5 Re-
11cra
wljax.comverse Lookup12might allow interceptors to reverse-engineer
the hashed value, obtain the user password, and log in 2020m
illegally. Thus, we could infer a vulnerability to intrusion.
Additionally, JSPreventer revealed that UCDChina sent
an empty text on its search form, despite developers having
incorporated a goSearch function to prevent it. A cause of
this erroneous behavior was that UCDChina could display
the search form before loading the code fragment containing
thegoSearch function. Since the search form is the source
where users enter the search query, developers in this case
had intended to improve the search form. Although they had
expected only valid search queries would be sent from the
search form, the error indicates that UCDChina did not val-
idate the search query at all, and therefore, it possibly sent
every search query. If so, there would be an additional pos-
sibility that a server would receive malicious search queries
(e.g., an SQL code fragment) that might lead to an SQL
injection attack.
JSPreventer could nd an undened addthis_close func-
tion call in ESA by using the synchronous delay operator
upon loading an addthis_widget.js le. The undened
function calls can be fatal errors, which might cause ESA to
crash.
Although Crawljax ran until it completed its exploration
of the state space, it did not reveal the actual errors found by
JSPreventer. These results suggest that JSPreventer reveals
actual errors due to delay-dependent potential faults.
Feasible analysis time (RQ2): For each test subject,
JSPreventer revealed the actual errors within one minute.
Most of the Te,Tx, and Ttvalues were required to initial-
ize parsers and to launch the test browser. Although Tvin-
creased linearly with the size of the extracted nite state ma-
chine, the extracted nite state machines were small enough
to be veried with the NuSMV model checker. Tmwas much
shorter than the other amounts. These results indicate that
JSPreventer is practical.
False positives in *-dependent potential faults: In
our case studies, three potential faults could not be executed
using JSPreventer and the delay-based mutation operators.
As for the potential faults at Invariants #2 and #5 in 2020m,
we observed that Mozilla Firefox prevented 2020m from run-
ning on the identied faulty interaction sequences by making
12se
arch.cpan.org/~blwood/Digest-MD5-Reverse-1.3
498Tab le 4: Classication results of our case studies
Sub
ject Invariant# (Ajax design pattern) Result v Tx(sec) Tm(sec) Tt(sec) Result c+
202
0m 1 (XMLHttpRequest Call) Correct - - - -
2 (User Action) False positive 9.643 0.039 11.868 *dPF
4 (Direct Login) Potential fault 8.147 0.116 8.175 DdPF
5 (Direct Login) False positive 8.553 - - *dPF
UCDCh
ina 1 (XMLHttpRequest Call) Correct - - - -
2 (User Action) Potential fault 11.677 0.183 11.816 DdPF
3 (Live Form) Potential fault 9.692 - - EF
ESA
1 (XMLHttpRequest Call) Correct - - - -
2 (User Action) Potential fault 10.520 0.133 10.335 DdPF
3 (Live Form) False positive 15.307 0.208 14.965 *dPF
+EF, DdPF,
and *dPF in the column of Result crepresent executable, delay-dependent potential, and *-dependent
potential faults, respectively.
Table 5: Actual errors due to delay-dependent potential faults
Sub
ject Brief explanation Inferred vulnerability
202
0m Login failed with correct username and password Intrusion
UCDChina Content search with an empty query SQL injection
ESA Undened function call Application crash
a pro
per rendering block and page transition, respectively.
Since the extracted nite state machine did not contain the
Web browser behavior, we determined that these potential
faults were false positives due to spurious counterexamples.
Additionally, JSPreventer could not make the potential fault
at Invariant #3 in ESA executable. In the source code of
ESA, we found that a conditional branch was implemented
to prevent ESA from executing the potential fault. Analyz-
ing data-dependent impossible behavior is currently beyond
the scope of our research; hence, this result was a false posi-
tive due to our methods. However, this problem can be miti-
gated by using execution results to rene the extracted nite
state machine, i.e., by conducting further dynamic analy-
ses together with JSPreventer. A remaining issue is that
it is unknown whether Ajax applications actually execute
*-dependent potential faults. Therefore, we are interested
in dening additional eÔ¨Äective mutation operators to make
*-dependent potential faults executable.
Applying to generic Ajax applications: We designed
JSPreventer for developers who use Ajax design patterns to
build applications. In actual Ajax application development,
developers have their own design patterns. If there are not
given IADP info for the own design patterns, JSPreventer
cannot determine code locations where our mutation opera-
tors should be applied. To test Ajax applications made with
their own design patterns, developers need to specify the
code locations of synchronous or asynchronous communica-
tions which they suspect as the cause of errors when specic
network delays are present. JSPreventer then mutates the
code fragments at the specied code locations and tries to
reveal the errors.
Debugging potential faults: We assume that the ac-
tual errors revealed by JSPreventer can help developers de-
bug potential faults. However, this debugging task depends
on the skills and experience of the developers. In the future,
we plan to establish a method to support debugging.4.4 Threats to Validity
Internal validity threats: We considered two exter-
nal factors that might aÔ¨Äect results in our case study ex-
periments. The results from 2020m, UCDChina, and ESA
demonstrate the usefulness of JSPreventer because these
real-world applications were obtained via a public search en-
gine provided by NerdyData. However, their actual server-
side scripts were not available; therefore, we implemented
mock server-side scripts in order to run these real-world ap-
plications on our machine. Because the mock server-side
scripts may be a threat to internal validity, we intend to
conduct additional case studies using real-world open-source
Ajax applications.
Additionally, we provided the necessary information to
run the test subjects (e.g., IADP Info, test data, and or-
acles). Although the ability of developers to input correct
information into JSPreventer may aÔ¨Äect the internal valid-
ity, the results of our case studies show that JSPreventer
can reveal actual errors due to potential faults. It should
be noted that the test scenarios involved typical tests, such
as verifying user login success with the correct username
and password. In the future, we intend to use JSPreventer
in actual Ajax application development projects to evalu-
ate whether developers can input correct information into
JSPreventer. We are also interested in combining a search-
based testing technique [21] with JSPreventer in order to
generate test data automatically.
External validity threats: Regarding the generality
of our approach, JSPreventer can only reveal actual errors
due to delay-dependent potential faults. However, potential
faults may depend on other reasons, such as unexpected user
operations and Web browser behaviors. Therefore, we are
going to collect *-dependent potential faults by conducting
additional case studies with JSPreventer and dene eÔ¨Äective
mutation operators for them.
499Alth
ough 2020m, UCDChina, and ESA are practical Ajax
applications, it would be interesting to determine the scala-
bility of JSPreventer by obtaining experimental results using
many real-world Ajax applications.
5. RELATED WORK
In this section, we describe the state-of-the-art studies on
the analysis and testing of Ajax applications.
State-based analysis and testing: Marchetto et al.
introduced the concept of state-based analysis and testing
to Ajax applications [22]. Their tool, ReAjax [23], extracts
nite state machines from the execution results of Ajax ap-
plications. The nite state machines consist of Document
Object Model (DOM)13instances and the eÔ¨Äects of callback
executions as states and transitions. However, ReAjax re-
quires developers to manually execute Ajax applications to
suÔ¨Éciently trace the execution results.
Towards automated execution, Mesbah et al. implemented
Crawljax [24], which can automatically emulate user ac-
tions, i.e., crawling Ajax applications. Crawljax has been
used to detect DOM-related faults [6], to test cross browser
compatibility [8], and to determine whether CSS rules are
unnecessary or not [20]. Additionally, Choudhary et al.
leveraged Crawljax to improve the accuracy of identifying
cross browser issues [9]. Although Crawljax is very useful
for nding executable faults, such crawling approaches can-
not reveal potential faults because they may not be easily
executable in the given environments.
Arzti et al. presented Artemis [7] as a way to improve
code coverage by using the feedback-directed technique [25].
Artemis analyzes historical test execution data and gener-
ates test cases to explore the state space of Ajax applica-
tions. The authors noted that Artemis may help Crawljax
determine what user actions should be emulated. However,
Crawljax and Artemis cannot be combined in a way that
would determine potential faults in Ajax applications.
Hong et al. have a similar concern of nding concurrency
errors due to the improper timing of Ajax applications han-
dling the interactions [26]. Their tool called WAVE is an ex-
tended implementation of the WebKit14browser framework
for managing event invocations on the JavaScript engine.
However, the HTML rendering engine can also aÔ¨Äect event
invocations, such as the rendering block, as we mentioned in
Section 3.2. Since JSPreventer reveals errors due to poten-
tial faults of Ajax applications on standard Web browsers
that users actually use, it can more precisely suggest erro-
neous behavior of the applications to developers.
Static approach: As for static approaches, Guha et
al. proposed a static method to prevent Ajax applications
from handling invalid server requests [27]. Their frame-
work constructs a request graph through control ow anal-
ysis, which represents how Ajax applications handle asyn-
chronous server requests with an invariant order. The re-
quest graph can be used as an oracle to validate runtime
server requests. However, if developers cannot correctly im-
plement Ajax applications, the request graph cannot reject
invalid server requests relevant to potential faults. Thus,
developers debugging the potential faults using JSPreventer
can construct a more proper request graph from the de-
bugged applications.
13www
.w3.org/DOM
14www.webkit.orgZheng et al. also conducted a rules-based static analy-
sis to detect data races due to asynchronous calls (i.e., the
sort of interactions dealt with in this paper) in Ajax applica-
tions [13]. Although they focused on global variables, which
are shared by asynchronous calls, JSPreventer can identify
faulty asynchronous calls without data races by leveraging
the Ajax design patterns as oracles. Additionally, Zheng et
al. were not interested in testing unexpected behaviors in
the applications if a detected data race occurred. Although
they suggested two methods to x data races, we argue that
the actual errors found by JSPreventer can help developers
debug their applications and conrm the correctness of the
codes.
Guarnieri et al. introduced a pure static taint analysis
for JavaScript code in order to identify security vulnera-
bilities such as cross-site scripting and SQL injection [28].
Wei et al. pointed out the dynamic feature of JavaScript;
JavaScript code can dynamically get additional code from
the server at runtime. They proposed a blended taint anal-
ysis of the JavaScript code that can be collected by executing
test cases [29]. Although these analyses can output precise
control ows of only the JavaScript code, JSPreventer ana-
lyzes stateful behaviors in the HTML, CSS, and JavaScript
code of Ajax applications.
Mutation analysis and testing: Mutation analysis is
a fault-based technique to assess the adequacy of test cases
[14, 30]. It seeds articial faults into the program under test
and then measures whether the seeded articial faults can
be detected in the test cases. This technique in its original
form might be applicable to Ajax applications [31, 32]. In
contrast, JSPreventer leverages a deformed mutation analy-
sis technique, wherein seeded articial delays do not act as
faults to be detected but expose existing potential faults in
Ajax applications. Although JSPreventer cannot be used to
assess the adequacy of test cases, it can reveal actual errors
due to potential faults.
6. CONCLUSION
We proposed a support tool, called JSPreventer, for vali-
dating Ajax applications by nding executable evidences of
potential faults that may not be easily executed in the given
development and test environments. We implemented delay-
based mutation operators to articially make the poten-
tial faults executable and reveal actual errors due to delay-
dependent potential faults. Our experimental results show
that JSPreventer reveals actual errors due to delay-dependent
potential faults in real-world Ajax applications in a feasible
amount of time. By debugging the revealed errors, devel-
opers can develop and validate highly reliable Ajax applica-
tions.
Our future research will proceed in three separate direc-
tions. One direction is to develop automated debugging.
Besides establishing a method that eÔ¨Äectively uses solutions
in Ajax design patterns, we plan to combine JSPreventer
with mechanisms for determining actual errors in existing
debugger tools, such as Firebug15. The second direction is
to implement more mutation operators to reveal actual er-
rors due to *-dependent potential faults. The third direction
is to expand the range of case studies on large-scale Ajax ap-
plications in the real world.
15ge
tfirebug.com
5007. REFERENCES
[1] Jesse James Garrett. Ajax: A New Approach to Web
Applications. www.adaptivepath.com/ideas/
ajax-new-approach-web-applications .
[2] Brent Stearn. XULRunner: A New Approach for
Developing Rich Internet Applications. IEEE Internet
Computing, 11(3):67{73, 2007.
[3] Jakob Nielsen and Hoa Loranger. Prioritizing Web
Usability . New Riders Press, Berkeley, CA, 2006.
[4] Internet World Stats. World Internet Usage Statistics
News and World Population Stats.
www.internetworldstats.com/stats.htm .
[5] Alessandro Marchetto, Filippo Ricca, and Paolo
Tonella. A case study-based comparison of web testing
techniques applied to AJAX web applications. Int'l
Journal on Software Tools for Technology Transfer
(STTT) , 10(6):477{492, 2008.
[6] Ali Mesbah and Arie van Deursen. Invariant-based
Automatic Testing of AJAX User Interfaces. In Proc.
Int'l Conf. on Software Engineering (ICSE) , pages
210{220, May 2009.
[7] Shay Artzi, Julian Dolby, Simon Holm Jensen, Anders
Moller, and Frank Tip. A Framework for Automated
Testing of JavaScript Web Applications. In Proc. Int'l
Conf. on Software Engineering (ICSE) , pages
571{580, May 2011.
[8] Ali Mesbah and Mukul R. Prasad. Automated
Cross-Browser Compatibility Testing. In Proc. Int'l
Conf. on Software Engineering (ICSE) , pages
561{570, May 2011.
[9] Shauvik Roy Choudhary, Mukul R. Prasad, and
Alessandro Orso. X-PERT: Accurate Identication of
Cross-Browser Issues in Web Applications. In Proc.
Int'l Conf. on Software Engineering (ICSE) , pages
702{711, May 2013.
[10] Yuta Maezawa, Hironori Washizaki, and Shinichi
Honiden. Extracting Interaction-based Stateful
Behavior in Rich Internet Applications. In Proc.
European Conf. on Software Maintenance and
Reengineering (CSMR) , pages 423{428, March 2012.
[11] Yuta Maezawa, Hironori Washizaki, Yoshinori Tanabe,
and Shinichi Honiden. Automated Verication of
Pattern-based Interaction Invariants in Ajax
Applications. In Proc. Int'l Conf. on Automated
Software Engineering (ASE) , pages 158{168,
November 2013.
[12] Michael MahemoÔ¨Ä. Ajax Design Patterns . O'Reilly
Media, Inc., 2006.
[13] Yunhui Zheng, Tao Bao, and Xiangyu Zhang.
Statically Locating Web Application Bugs Caused by
Asynchronous Calls. In Proc. Int'l World Wide Web
Conf. (WWW) , pages 805{814, April 2011.
[14] R.A. DeMillo, R.J. Lipton, and F.G. Sayward. Hints
on Test Data Selection: Help for the Practicing
Programmer. Computer, 11(4):34 {41, April 1978.
[15] Cong Tian and Zhenhua Duan. Detecting Spurious
Counterexamples EÔ¨Éciently in Abstract Model
Checking. In Proc. Int'l Conf. on Software
Engineering (ICSE) , pages 202{211, May 2013.
[16] Michael Grottke and Kishor S. Trivedi. Fighting Bugs:
Remove, Retry, Replicate, and Rejuvenate. Computer,
40(2):107{109, 2007.[17] Steve Souders. High Performance Web Sites . O'Reilly
Media, Inc., 2007.
[18] C. Larman and V.R. Basili. Iterative and Incremental
Developments: A Brief History. Computer,
36(6):47{56, 2003.
[19] Anthony T. Holdener, III. Ajax: The Denitive Guide .
O'Reilly Media, Inc., 2008.
[20] Ali Mesbah and Shabnam Mirshokraie. Automated
Analysis of CSS Rules to Support Style Maintenance.
InProc. Int'l Conf. on Software Engineering (ICSE),
pages 408{418, May 2012.
[21] Nadia Alshahwan and Mark Harman. Automated Web
Application Testing Using Search Based Software
Engineering. In Proc. Int'l Conf. on Automated
Software Engineering (ASE) , pages 3{12, November
2011.
[22] Alessandro Marchetto, Paolo Tonella, and Filippo
Ricca. State-based Testing of Ajax Web Applications.
InProc. Int'l Conf. on Software Testing, Verication
and Validation (ICST) , pages 121{130, April 2008.
[23] Alessandro Marchetto, Paolo Tonella, and Filippo
Ricca. ReAjax: a reverse engineering tool for Ajax
Web applications. IET Software , 6(1):33{49, 2012.
[24] Ali Mesbah, Engin Bozdag, and Arie van Deursen.
Crawling AJAX by Inferring User Interface State
Changes. In Proc. Int'l Conf. on Web Engineering
(ICWE) , pages 122{134, July 2008.
[25] Carlos Pacheco, Shuvendu K. Lahiri, Michael D.
Ernst, and Thomas Ball. Feedback-Directed Random
Test Generation. In Proc. Int'l Conf. on Software
Engineering (ICSE) , pages 75{84, May 2007.
[26] Shin Hong, Yongbae Park, and Moonzoo Kim.
Detecting Concurrency Errors in Client-side
JavaScript Web Applications. In Proc. Int'l Conf. on
Software Software Testing, Verication and Validation
(ICST) , pages 61{70, March 2014.
[27] Arjun Guha, Shriram Krishnamurthi, and Trevor Jim.
Using Static Analysis for Ajax Intrusion Detection. In
Proc. Int'l World Wide Web Conf. (WWW) , pages
561{570, April 2009.
[28] Salvatore Guarnieri, Macro Pistoia, Omer Tripp,
Julian Dolby, Stephen Teilhet, and Ryan Berg. Saving
the World Wide Web from Vulnerable JavaScript. In
Proc. Int'l Symp. on Software Testing and Analysis
(ISSTA) , pages 177{187, July 2011.
[29] Shiyi Wei and Barbara Ryder. Practical Blended Taint
Analysis for JavaScript. In Proc. Int'l Symp. on
Software Testing and Analysis (ISSTA) , pages
336{346, July 2013.
[30] Yue Jia and Mark Harman. An Analysis and Survey of
the Development of Mutation Testing. IEEE Trans.
on Software Engineering (TSE) , 37(5):649{678,
September 2011.
[31] S. Mirshokraie, A. Mesbah, and K. Pattabiraman.
EÔ¨Écient JavaScript Mutation Testing. In Proc. Int'l
Conf. on Software Testing, Verication and Validation
(ICST) , pages 74{83, March 2013.
[32] Kazuki Nishiura, Yuta Maezawa, Hironori Washizaki,
and Shinichi Honiden. Mutation Analysis for
JavaScript Web Applications Testing. In Proc. Int'l
Conf. on Software Engineering and Knowledge
Engineering (SEKE), pages 159{165, June 2013.
501