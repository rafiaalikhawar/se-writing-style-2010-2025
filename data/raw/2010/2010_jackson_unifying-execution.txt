MIT Open Access Articles
Unifying Execution of Imperative and Declarative Code
The MIT Faculty has made this article openly available. Please share
how this access benefits you. Your story matters.
Citation: Milicevic, Aleksandar et al. ‚ÄúUnifying Execution of Imperative and Declarative Code.‚Äù 
Proceedings of the 33rd International Conference on Software Engineering, ICSE ‚Äô11, May 21‚Äì28, 
2011, Honolulu, Hawaii, USA, ACM Press, 2011. 511. Web.
As Published: http://dx.doi.org/ 10.1145/1985793.1985863
Publisher: Association for Computing Machinery
Persistent URL: http://hdl.handle.net/1721.1/72084
Version: Author's final manuscript: final author's manuscript post peer review, without 
publisher's formatting or copy editing
Terms of use: Creative Commons Attribution-Noncommercial-Share Alike 3.0
Unifying Execution of Imperative and Declarative Code
Aleksandar Milicevic, Derek Rayside, Kuat Y essenov, Daniel Jackson
Computer Science and ArtiÔ¨Åcial Intelligence Laboratory
Massachusetts Institute of Technology
{aleks, drayside, kuat, dnj}@csail.mit.edu
ABSTRACT
We present a unied environment for running declarative
specications in the context of an imperative object-oriented
programming language. Specications are Alloy-like, writ-
ten in rst-order relational logic with transitive closure, and
the imperative language is Java. By being able to mix im-
perative code with executable declarative specications, the
user can easily express constraint problems in place, i.e.,
in terms of the existing data structures and objects on the
heap. After a solution is found, the heap is updated to reect
the solution, so the user can continue to manipulate the pro-
gram heap in the usual imperative way. We show that this
approach is not only convenient, but, for certain problems
can also outperform a standard imperative implementation.
We also present an optimization technique that allowed us
to run our tool on heaps with almost 2000 objects.
Categories and Subject Descriptors
D.2.6 [ Software Engineering ]: Programming Environment;
D.2.1 [ Software Engineering ]: Requirements/Specica-
tions; D.1.2 [ Programming Techniques ]: Automatic Pro-
gramming
General Terms
Design, Languages
Keywords
formal methods, executable specications, declarative pro-
gramming, constraint-based languages
1. INTRODUCTION
Squander is a framework that provides a unied envi-
ronment for writing declarative constraints and imperative
statements in the context of a single program. This is partic-
ularly useful for implementing programs that involve compu-
tations that are relatively easy to specify but hard to solve
algorithmically. In such cases, declarative constraints can
be a natural way to express the core computation, whereas
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô11, May 21‚Äì28, 2011, Honolulu, Hawaii, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00.imperative code is a natural choice for reading the input
parameters, populating the working data structures, setting
up the problem, and presenting the solution back to the
user. The ability to switch smoothly back and forth be-
tween declarative logic and imperative programming makes
it possible to implement this kind of program more elegantly
and with less eort on the programmer's part.
We propose a technology that can execute declarative
specications without requiring the programmer to write a
single line of imperative implementation. The supported
specication language is JFSL [23], an Alloy-like [11] lan-
guage, that supports rst-order relational logic with transi-
tive closure, and standard Java expressions. The expressive
power of JFSL makes it easy to succinctly write complex
relational properties in terms of a program's data structures
and reachable objects on the heap. As we shall show, in
some cases, this form of execution is competitive with hand-
written imperative code; in others, it is not, but there are
still contexts in which it makes sense to trade performance
for other benets [17].
By being able to mix imperative code with executable
declarative specications, the user can easily express con-
straint problems in place, i.e., in terms of the existing data
structures and objects on the heap. The execution engine
runs a solver when a declarative constraint is encountered,
and automatically updates the heap to reect the solution.
Afterwards, the program continues to manipulate the heap
in the usual imperative way. Without such a technology,
the standard approach is to translate the problem into the
language of an external solver with specialized hand-written
code, run the solver, and then translate the solution back
to the native programming language using more specialized
code. This requires more work and is more error prone.
This paper presents the implementation of our frame-
work, discusses the benets of the unied environment, and
shows several illustrative examples in which the direct ex-
ecution of a declarative specication outperforms a hand-
written imperative implementation. The framework is af-
fectionately named Squander , since it squanders computa-
tional resources, running an NP-complete boolean satisa-
bility (SAT) algorithm to execute all programs { including
those that have much lower complexity. It can be freely
obtained from [2].
Contributions of this paper include:
A framework for unied execution of imperative and
declarative code, that combines an existing pre/post/in-
variant annotation language with a single extension
(to 'magically' execute a procedure with a specica-tion but containing no code), and which requires no
preprocessing and no change to the execution environ-
ment beyond inclusion of the Squander library;
A treatment of data abstraction, using serialization
techniques, that allows specications to reference the
state of abstract objects { in particular the collections
of the Java library, as well as user-dened datatypes {
in a representation-independent fashion;
An optimization technique for large object heaps, that
overcomes a key problem in translation to SAT (namely
that the sheer number of potential objects leads, with
a naive encoding, to an array of SAT variables whose
highest index is greater than Java's largest integer);
A series of small examples, illustrating the expressive-
ness of the declarative notation, and its performance
advantages, for some puzzles and graph algorithms;
A case study, in which an existing non-trivial program
(that was previously implemented with a handwritten
encoding) was retrotted with the new framework, as
a test of its application in a slightly larger setting.
2. EXAMPLE ‚Äì SUDOKU SOLVER
As an example, consider a simple Sudoku solver. The
solver is given a partially lled puzzle (Figure 1), and is
expected to ll out the empty cells with integer values so
that the following constraints hold: (1) cell values must be in
f1;2;;ng(wherenis the dimension of the puzzle, n= 9
in this example); (2) all cells within a given row, column, or
sub-grid have distinct values.
Figure 1: A random Sudoku puzzle
s t a t i c c l a s s C e l l fi n t v a l = 0 ; g// 0 means empty
@ I n v a r i a n t ( " a l l v : i n t j
v != 0 = >l o n e t h i s . c e l l s . elems . v a l . v ")
s t a t i c c l a s s CellGroup f
C e l l [ ] c e l l s ;
p u b l i c CellGroup ( i n t n ) ft h i s . c e l l s= new C e l l [ n ] ; g g
p u b l i c c l a s s Sudoku f
CellGroup [ ] rows , c o l s , g r i d s ; i n t n ;
p u b l i c Sudoku ( i n t n ) fi n i t ( n ) ; g
@Ensures ( " a l l c : C e l l jc . val >0 && c . val <=t h i s . n ")
@Modifies ( "C e l l . v a l [ fc : C e l l jc . v a l == 0 g] ")
p u b l i c v o i d s o l v e ( ) fSquander . exe ( t h i s ) ; gg
Listing 1: Sudoku Specication
A suitable Java data model for this problem is given in
Listing 1; ignore the annotations for now. A CellGroup con-
tains an array of Cells with no duplicate values; overlapping
CellGroup s are then dened in the class Sudoku for each row,
column and sub-grid. The init() method (invoked from theSudoku 's constructor) has the task of creating exactly nn
Cell objects,n+n+nCellGroup objects, and properly es-
tablishing the sharing of Cells between CellGroup s.
Now, onto the solving part. The invariant for CellGroup s,
given above, can be expressed in a single line of JFSL (List-
ing 1, @Invariant annotation). It says that for all integer val-
uesvdierent from 0, select all Cell objects from the Cell-
Group.cells eld with the value v(this.cells.elems.value.v ),
and ensure that their count is either 0 or 1 ( lone).
Class invariants assert properties of all members of a class,
but cannot be executed per se . To establish an executable
constraint, we dene a standard Java method and annotate
it with a specication, which includes:
a precondition ( @Requires ), on the state before method
invocation, assumed true if not specied;
a postcondition ( @Ensures ), on the state after the method
has been executed;
a frame condition ( @Modifies ), indicating what parts
of the state the method is allowed to modify.
In this case, the specication for the solve() method sim-
ply says that in the post-state (i.e. after the method has
been executed by Squander ), all cells must be lled out
with non-zero values. The frame condition limits modi-
cations to those Cell.value elds that are currently empty
([{c: Cell | c.value == 0}] ), since we don't want to mod-
ify values given up-front. These constraints, implicitly con-
joined with the class invariant, are sucient to solve the Su-
doku puzzle. The method body is simply a call to a utility
method, namely Squander.exe , which invokes the solver and
attempts to satisfy the specication, by updating the cell
values. Following execution of solve , assuming a solution
is found, the program may proceed to, for example, print
out the solved puzzle, using the usual imperative paradigm.
Otherwise, an exception is thrown to signal that the speci-
cation could not be satised.
3. BACKGROUND
3.1 Kodkod ‚Äì A Solver for Relational Logic
Kodkod [21] is a constraint solver for relational logic. It
takes a relational formula to be solved, along with denitions
of a set of untyped relations, consisting of bounds for each
relation, and a bounded universe of atoms from which the
relations in the solution are populated. It translates the
formula to a boolean satisability problem and applies an
o-the-shelf SAT solver to search for a satisfying solution,
which, if found, is translated back to the relational domain.
Relations in Kodkod are untyped, meaning that every re-
lation can potentially contain any tuple drawn from the -
nite universe. The actual set of tuples that a relation may
contain is dened through Kodkod bounds . Two bounds
need to be specied: lower bound to dene tuples that a re-
lation must contain, and upper bound to dene tuples that
a relation may contain. The size of these bounds is what
primarily inuences the search time { the fewer tuples there
are in the dierence of the upper and the lower bound, the
smaller the search space, the faster the solving.
3.2 JFSL ‚Äì JForge SpeciÔ¨Åcation Language
JFSL [23] is a formal specication language for Java. As
in Alloy, all expressions evaluate to relations. JFSL providescommon relational algebra operators: join ( .), transpose ( ~),
tuple constructor ( ->), transitive closure ( ^), and reexive
transitive closure ( *), as well as set algebra operators: union
(+), dierence ( -), and intersection ( &).
Like in Java, the universe of discourse consists of Java
objects, null, and primitive values. Each type corresponds
to a set of objects of exactly that type (e.g. intis the
set of all primitive integers, while Object is the set of all
instances of class Object , excluding subclasses). Each eld
is treated as a binary relation from its declarer type to its
value type. The value type is represented by a union of the
concrete types that are assignable from the eld's declared
type. An array type T[]is represented with a ternary rela-
tion elems of type T[]->int->(T+Null) . The bracket operator
is conveniently treated as a left join, so a[b] is equivalent to
b.(a.elems) ifais an array or b.a, otherwise. Formulas are
built from expressions using boolean algebra, the cardinality
operator ( #)), set comprehensions (e.g. {x:T | P(x)} ), and
quantications (e.g. all x:T | P(x) ).
JFSL specications are written as Java annotations. Be-
sides the already mentioned @Invariant ,@Requires ,@Ensures ,
and @Modifies clauses, JFSL provides support for specica-
tion elds via the @SpecField annotation. Denition of a
specication eld consists of the type declaration, and op-
tionally an abstraction function, which denes how the eld
value is computed in terms of other elds. For example,
@SpecField("x: one int | x = this.y - this.z") denes a
singleton integer eld x, the value of which must be equal to
the dierence of yand z. Specications elds are inherited
from super-types and sub-types can override the abstraction
function (by simply redening it) { this is particularly useful
for specifying abstract datatypes, such as Java collections.
The frame condition has an important role in precisely
specifying the eects of a method. It takes the form @Modi-
fies("f [s][u]") , with three parts. The rst, and the only
mandatory part, is the name of the modiable eld, f. It is
optionally followed by the instance selector (s) which spec-
ies instances for which the eld may be modied (taken
to be \all" if not specied), and the upper bound (u) of the
modication (taken to be the full extent of the eld's type
if not specied). In the Sudoku example (Listing 1) we used
an instance selector to specify that only the empty cells may
be modied. In Squander , the instance selector provides
the only mean of specifying the modiable instances. If for
some reason we wanted to additionally constrain the values
that may be assigned to the cells, we could either add con-
straints to the @Ensures clause or use the upper bound clause
of the frame condition. The dierence is that the former is
less ecient: the frame condition's upper bound is trans-
lated directly to Kodkod bounds, which shrinks the search
space at the beginning of the search, as opposed to leaving
it large and constraining the search by adding more rules.
4. FROM OBJECTS TO RELATIONS
Squander execution begins when the utility method Squan-
der.exe() is called by the client code, and involves the fol-
lowing steps:
Assembling the relevant constraints, from the anno-
tations comprising the method's specication, as well
as class annotations corresponding to invariants of all
relevant classes (determined by a traversal of the heap
from the receiver object);Construction of relations representing the values of ob-
jects and their elds in the pre-state, and additional
relations for modiable elds to hold their values in
the post-state, along with their Kodkod bounds;
Parsing of the constraints and conversion to a single
relational formula (handed to Kodkod for solving);
If a solution is found, translation of the Kodkod re-
sult objects into updates of the Java heap state, by
modication of the object elds.
4.1 Heap Traversal and Object Serialization
The rst concern for Squander is discovering the reach-
able portion of the heap. The traversal algorithm is a stan-
dard breath-rst algorithm (although depth-rst would suf-
ce too), starting from a given set of root objects (the caller
instance plus method arguments) and repeatedly visiting all
children until all reachable objects have been visited. The
interesting part is how to enumerate children, i.e., how to
serialize a given object into a set of eld values.
Squander provides a generic mechanism that allows for
dierent object serializers based on the object's class. For
example, the default object serializer simply returns values
of an object's elds. This behavior is good in many cases,
including user-dened classes. However, when serializing ab-
stract types { such as an object of type java.util.Set { we
would like to return only the members of the set, excluding
objects that are artifacts of the representation (such as hash
buckets). An abstraction function is needed to separate the
actual content from the internal representation, and this is
exactly what object serializers provide. Similarly, they also
provide concretization functions that are used to restore an
object's state from a given set of abstract values returned
by the solver. Through this mechanism, Squander provides
support for Java collections and Java arrays (more details
in Section 6), and allows users to easily customize behavior
for user-dened abstractions.
4.1.1 Keeping Track of Type Parameters
Java collection classes make extensive use of parametric
types (also called \generics" in Java terminology). This al-
lows the programmer to indicate the type of objects a col-
lection may contain, e.g. a set of nodes ( Set<Node> ) rather
than a set of arbitrary objects ( Set). Unfortunately, though,
since generics were a late addition to Java, they are imple-
mented using type erasure , and the parameter information is
only available at compile time. For ease of use, Squander
is a runtime mechanism that uses the standard JVM, so it
has no access to the compile-time type information.
Knowing the exact types of objects, including type pa-
rameters, is important. One reason is that we don't want to
have to write explicit casts in our specications every time
we refer to an element of a collection (as one must do in
Java when not using generics). Other reasons are mainly
concerned about performance: without knowing the type
parameter, the extent of the elements of a set is the set of
all objects on the heap. If the set is actually a set of integers,
than the actual extent is much smaller, which would result
in a smaller bound if the set was modiable (see Section 4.4),
which may dramatically improve Kodkod's running time.
Java reection does, however, provide static types of elds
and method parameters, which include type parameter in-
formation. Say there is a eld declared as Set<Node> nodes ;
the fact that the eld is a \set of Nodes" can be obtained atruntime. Consequently, if we know that some object objwas
read as a value of the eld nodes , we can conclude that the
type of objis actually Set<Node> . Almost all objects during
the heap traversal are discovered by reading eld values. It is
only the caller instance whose origin is not known; all other
objects are either passed as method parameters or read as
eld values, so complete type information can be obtained
for all objects but the root.
4.2 Reading, Parsing and Type Checking JFSL
When a new class is discovered during heap traversal, its
specication is obtained by reection. The specication of a
class includes class invariants (@Invariant ) and specication
elds (@SpecField ). These can be specied either directly in
the source le using Java annotations or through a special
spec le , which must be found in the classpath and whose
name must correspond to its target class's full name. Next,
text-based specications are parsed and type-checked (e.g.
to make sure that all identiers can be resolved to actual
classes/elds in the program, and that expressions have ex-
pected types, etc.) and eventually translated into relational
expressions. For most of this task, Squander borrows func-
tionality from JForge [23].
4.3 Example of a Translation
To illustrate translation, we'll rst give an example even
simpler than the Sudoku example from Section 2. After-
wards, we'll dene the translation process more formally.
Consider an insertion into a binary search tree. For the
purpose of translation, we don't need to give either the full
specication or the full source code listing, since the struc-
ture of the heap alone is sucient to explain most of the
details. The class BSTcontains a single pointer to the root
node, and the Node class contains pointers to left and right
sub-trees, as well as a single integer value (through the eld
key). The snapshot shown in Figure 2 gives an example of a
heap consisting of a tree t(in the class BST), four node ob-
jects (of which only three are reachable), and four key values.
When a node is inserted, all node pointers may potentially
be modied, so the specication for the insert method de-
clares elds root,left, and right as modiable.
The resulting set of relations is shown in Table 1. Re-
lations in the upper section are unary, given relations, and
represent objects found on the heap. The middle section
contains relations that are also given, because they are used
to either represent unmodiable elds or values in the pre-
state of modiable elds. Finally, the relations in the bottom
section represent the post-state of modiable elds; these
are the relations for which the solver will attempt to nd
appropriate values.
By default, the lower bound is an empty set and the upper
bound is the extent of the eld's type. Note, however, that
Squander also allows the users to tighten these bounds by
specifying the exact objects that are allowed to be modied
(using the instance selector clause of the frame condition, as
dened in Section 3.2). For example, for the relation left,
it is easy to specify in JFSL that the only left pointers that
may be modied are those of nodes whose left pointers are
currently set to null. As previously reported by Samimi et
al. [18], this can lead to a signicant speed-up in certain
cases. To control the scope of the modication more nely,
Squander additionally allows the users to constrain the setof possible values for a eld, by using the upper bound clause
of the frame condition.
BST
Node
Figure 2: A snapshot for the pre-state of t.insert(z)
BST1 :ft1gN3:fn3g BST this:ft1g
N1:fn1gN4:fn4g z:fn4g
N2:fn2gnull:fnullgints:f0;1;5;6g
key:f(n1!5);(n2!0);(n3!6);(n4!1)g
root pre:f(t1!n1)g
leftpre:f(n1!n2);(n2!null);(n3!null);(n4!null)g
right pre:f(n1!n3);(n2!null);(n3!null);(n4!null)g
root:fg;ft1gfn1; n2; n3; n4g
left:fg;fn1; n2; n3; n4gfn1; n2; n3; n4g
right :fg;fn1; n2; n3; n4gfn1; n2; n3; n4g
Table 1: Translation of the heap from Figure 2 to
bounds (a single exact bound or a pair of lower/up-
per bounds)
4.4 DeÔ¨Åning Relations and Bounds
The translation does not use all elds, but rather considers
only relevant elds, i.e. those that are explicitly mentioned
in the specication for the current method. Similarly, not
all reachable objects are needed; only objects reachable by
following the relevant elds are included in the translation.
These objects will be referred to as literals .
First we dene a nite universe consisting of all literals
(and integers) within the bound. For every literal, a unary
relation is created. These relations are constant, i.e. they
are given an exact bound (lower and upper bounds are equal)
of a single unary tuple containing the corresponding literal.
For each Java type, one could either create a relation (with
appropriate bounds so that it contains the known literals),
or one could construct a relational expression denoting the
union of relations corresponding to all instance literals of
that type. In our implementation, we took the former ap-
proach, since it results in more readable expressions (which
helps in debugging) and has no performance impact.
For every eld (including specication elds), a relation
of type fld.declType!fld.type1is created to hold assign-
ments of eld values to objects. If the eld is modiable
(inferred from its mention in a @Modifies clause), an addi-
tional relation is created, with the sux \pre" appended to
denote the pre-state value. Relations for unmodiable elds
are given an exact bound that reects the current state of the
heap. For the modiable relations, the\pre"relation is given
the same exact bound, and the \post" relation is bounded so
that it may contain any tuple permitted by the eld's type.
Local variables, such as this,return , and method arguments
are treated similarly to literals.
Table 2 summarizes how relations and bounds are cre-
ated. Function reltakes a Java element and, depending
on whether the element is modiable, returns either one or
two relations (the \ []" notation means \list of", and Ris
1fld.declType is the declaring class of fldthe constructor for relations, taking a name and a type for
the relation). Function bound takes a Java element and its
corresponding relation, and returns a bound for the rela-
tion. The Bound data type contains both lower and upper
bounds. If only one expression is passed to its constructor
(B), both bounds are set to that value. Helper functions
is_mod ,is_post and fldval are used to check whether a eld
is modiable, to check whether a relation refers to the post-
state, and to return a literal that corresponds to the value
of a given eld of a given literal, respectively.
rel:: Element![Relation]
rel(Literal lit) = [ R(lit.name , lit.type)]
rel(Type t) = [ R(t.name , t)]
rel(Field d) =
ifismod(d)
[R(d.name , d.declType!d.type)] ++
[R(d.name + \pre", d. declType!d.type)]
else
[R(f.name , f.declType!f.type)]
rel(Local var) = [ R(var.name , var.type)]
bound :: Element, Relation !Bound
bound (Literal lit) (Relation r) = B(lit)
bound (Type t) (Relation r) =S
lit<:tB(lit)
bound (Field d) (Relation r) =
ifismod(d)^ispost(r)
B(fg, ext(d. declTyped.type))
else
B(S
lit: Objectlitdval(lit, d))
bound (Return ret) (Relation r) = B(fg, ext(ret. type))
bound (Local var) (Relation r) = B(var)
ext:: [Type]!Expression (helper)
ext[] = fg
ext(t : []) =S
lit<:tlit
ext(t : xs) = exttextxs
Table 2: Translation of dierent Java constructs into
relations (function rel) and bounds (function bound )
4.5 Restoring the Java Heap State
After running Kodkod to search for a solution, the Java
heap state must be updated to reect the outcome of the
search. If Kodkod reports that a solution could not be
found, Squander simply throws an exception, which can
be caught and handled by the client code. If there exist
multiple solutions to the given problem, Kodkod will non-
deterministically return one2. The solution is then restored
to the Java heap by modication of the object elds through
reection. Finally, execution returns to the client code.
The process of restoring the heap is straightforward. Dur-
ing the translation to Kodkod, Squander saves the mapping
from Java objects to Kodkod atoms and from Java elds to
Kodkod relations. Therefore, a Kodkod solution, containing
values of all relations in the form of tuples of atoms, can be
directly mapped back to the values of Java elds.
5. MINIMIZING THE UNIVERSE SIZE
To represent a relation rof arityk, Kodkod allocates a
matrix of size nk, wherenis the number of atoms in the
universe. For performance reasons, Kodkod uses a single
2Kodkod can also enumerate all possible solutions (one at a
time) and that functionality is exported by Squander . This
feature is for example useful for generating test instances
that satisfy a certain property.sequential array indexed by a Java integer, and so the size
of the matrix is limited to the largest integer values in Java
(Integer.MAX_VALUE ). Consequently, if the universe contains
1291 atoms or more, the matrix for a ternary relation would
contain at least 12913cells, which would exceed the size
limit, so the relation could not be represented in Kodkod.
In practice, this can be a problem. Squander makes fre-
quent use of ternary relations (e.g. for representing arrays,
lists and maps), and heaps with more than 1290 objects are
not uncommon for problems that we would like to be able
to solve with Squander , so a simple translation like the one
described in Section 4.4 (which simply creates a new atom
for every object it nds on the heap) is not feasible. As an
illustration, in our case study on a course scheduling applica-
tion for the MIT undergraduate degree program (explained
in Section 8), the heap contains more than 1900 objects.
5.1 ‚ÄúKodkodPart‚Äù Translation
Our KodkodPart translation achieves a universe with fewer
atoms by establishing a mapping from Java objects (also
called literals, as in Section 4.4) to Kodkod atoms that is
not necessarily an injective function. In other words, multi-
ple literals are allowed to map to a single atom, so that there
can be fewer atoms than literals. The key requirement is,
however, that there exists (in the larger context) an inverse
function from atoms back to literals, so that the heap can
be properly restored after a solution has been found. This
inverse function, we will see, can be contructed with the help
of available type information.
Consider the tree insertion example, shown in Figure 2.
DomainsD, literalsL, and assignments of literals to domains
:D!P (L) for this example are summarized in Table 3.
D=fBST;Node;Null;Integerg
L=fbst1; n1; n2; n3; n4; null; 0;1;5;6g
(BST) =fbst1g(Node) =fn1; n2; n3; n4g
(Null) =fnullg(Integer ) =f0;1;5;6g
Table 3: Summary of domains and instances
Recall that eld types are represented as unions of base
types (in this section also called partitions ). For instance,
the type of the eld BST.root isBST!Node[Null, because
values of this eld can be either instances of Node or the
null constant. That means that all objects of class Node
plus the constant null must be mapped to dierent atoms,
so that it is possible to unambiguously restore the value of
the eld root. This is the basic idea behind the KodkodPart
translation: all literals within any given partition must be
mapped to dierent atoms, whereas literals not belonging to
a common partition may share atoms . The inversion func-
tion can then work as follows: for a given atom, rst select
the correct partition based on the type of the eld being re-
stored, then unambiguously select the corresponding literal
from that partition.
To complete the example, the set of all unary types used
in the specication for this example is:
T=fBST;BST[Null;Node;Node[Null;Null;Integerg
This set is discovered simply by keeping track of types of
all relations created for Java elds, and it automatically be-
comes the set of partitions. A valid assignment of atoms to
literals that uses only 5 atoms, as opposed to 10 which is
how many the original translation would use, could be:bst1!a0n1!a0n2!a1n3!a2n4!a3
null!a40!a0 1!a1 5!a2 6!a3
5.2 Partitioning Algorithm
For a given set of base domains D, literalsL, and parti-
tionsT(Tis of typeP(D)), and a given function :D!
P(L) that maps domains to their instance literals, this algo-
rithm produces a set of atoms Aand a function :L!A ,
so that for every partition p, functionreturns dierent
values for all instance literals of p. Formally:
(8p2T)(8l1;l22 (p))l16=l2=)(l1)6=(l2)
where is a function that for a given partition returns a
comprehension of all instance literals of all of its domains:
 :T !P (L); (p) =f(d)jd2pg
Obviously, a simple bijection would satisfy this speci-
cation, but such a solution wouldn't achieve its main goal,
which is to minimize the number of atoms, because the num-
ber of atoms in this case would be exactly the same as the
number of literals. In order to specify solutions that actually
improve performance, we require the algorithm to produce
a result that minimizes the cardinality of A(i.e. the total
number of atoms).
In summary, the algorithm works as follows:
1. Dependencies between domains are computed. A do-
main depends on all domains with which it shares a
partition. Let the function :D!P (D) express this:
(d) =fd1jd16=d^((9p2T)d12p)g
2. The largest partition pmaxis found such that
(69p2T)j (p)j>j (pmax)j
3. For every literal lin (pmax) an atomais created, it
is added to the universe Aand assigned to l, so that
(l) =a. From this point onwards, Ais xed.
4. For every other partition piteratively, for all literals
lp2 (p) that do not already have an atom assigned,
a set of possible atoms Alpis computed and the rst
value from this set is assigned to lp.Alpis obtained
when atoms corresponding to all literals of all depen-
dent domains is subtracted from A.
For a discussion of why it is sucient to simply nd the
largest partition and allocate that many atoms, see [14, x4.2]
A limitation of this technique is that, if the class Object
is used as a eld type, or anywhere in the specication, it
will result in one big partition containing all literals (be-
cause every class is a subclass of Object ), so that the result
is equivalent to the original translation. Similarly, if there
exists a single partition with more than 1290 literals, the
problem will still be unrepresentable.
6. USER-DEFINED ABSTRACTIONS FOR
LIBRARY TYPES
When specifying a program, we would like to be able to
refer to the content of library types, to iterate over the ele-
ments of a Java set, for example. Clearly we do not wish to
expose to the internals of the various Setimplementations,
so we cannot write declarative statements that directly refer
to the elds of HashSet , for example. We also do not wantour specication to depend on a concrete implementation
of these classes. This is a common problem, and Squan-
der provides a generic solution by letting the users write
abstraction and concretization functions for library classes.
The task of supporting an arbitrary third party class con-
sists of (1) writing a .jfspec le with abstract eld deni-
tions, and (2) writing an object serializer , as an implemen-
tation of the IObjSer interface that provides abstraction and
concretization functions for the abstract elds.
The .jfspec les are written in JFSL. They contain ab-
stract elds (the same @SpecField annotation is used) and
invariants ( @Invariant ). Some abstract elds may have only
a type declaration, whereas others may also be given an
abstraction function (written in JFSL), expressed in terms
of the existing elds. The accompanying object serializer
must provide concrete implementations of abstraction and
concretization functions for only those abstract elds not al-
ready having an abstraction function dened in the .jfspec
le. The abstraction function ( absFunc ) takes a concrete ob-
ject and returns values of its abstract elds. The concretiza-
tion function ( concrFunc ) takes a concrete object and a value
of an abstract eld, and is expected to restore that value to
the concrete object, by mutation. The code for serializers is
straightforward and is omitted for lack of space.
Squander provides built-in support for Java collections
and Java arrays through this mechanism.
6.1 SpeciÔ¨Åcation for Java Sets and Maps
The abstract representation of a set is a set of elements,
which is captured in a single SpecField named elts; simi-
larly for maps, a binary relation also named elts is used to
represent the mapping from keys to values (Listing 2). Addi-
tional elds ( size,keys,vals) are dened for convenience; an
abstraction functions is also provided so that the serializer
is not required to implement abstraction and concretization
functions for them. Additionally, an invariant is specied
for maps constrain each key to map to at most one value.
i n t e r f a c e Set<K>f
@SpecField ( " e l t s : s e t K")
@SpecField ( " s i z e : one i n t jt h i s . s i z e= #t h i s . e l t s ") g
i n t e r f a c e Map<K, V>f
@SpecField ( " e l t s : K  >V")
@SpecField ( " s i z e : one i n t jt h i s . s i z e = #t h i s . e l t s ")
@SpecField ( "keys : s e t K jt h i s . keys = t h i s . e l t s . ( V) ")
@SpecField ( "v a l s : s e t V jt h i s . v a l s = t h i s . e l t s [K] ")
@ I n v a r i a n t ( f
" a l l k : K jk i n t h i s . e l t s .V = >one t h i s . e l t s [ k ] " g)g
Listing 2: Specication for Setand Map
6.2 SpeciÔ¨Åcations for Java Lists and Arrays
To capture the abstract representation of a list, we again
declare a single eld, again named elts, but of type int->E
(Listing 3). This time, however, we must include an addi-
tional constraint to ensure that these elds represent a valid
list: there should be exactly one element for every index
from 0 (inclusive) to the size of the list (exclusive), and no
elements at any other index. We write this constraint as an
invariant in the same jfspec le. As before, we dene eld
size to represent the number of elements in the list. Finally,
we dene an extra eld, prev, dening the reverse ordering,
whose use is illustrated in the case study described later.
The abstraction function for this eld makes use of a con-
stant relation, namely DEC, which is built-in to Squanderand evaluates to all pairs fi;i 1g, where both iandi 1
are integers drawn from the nite universe.
Java arrays are likewise supported through this mecha-
nism, and their specication is almost identical to that given
in Listing 3. This mechanism automatically supports multi-
dimensional arrays, because in Java, multi-dimensional ar-
rays are simply arrays of arrays, and our mechanism for
dening specications is inherently compositional.
i n t e r f a c e L i s t<E>f
@SpecField ( " e l t s : i n t  >E ")
@SpecField ( " s i z e : one i n t jt h i s . s i z e = #t h i s . e l t s ")
@SpecField ( "prev : E  >E j
t h i s . prev = (~ t h i s . e l t s ) . DEC . ( t h i s . e l t s ) ")
@ I n v a r i a n t ( " a l l i : i n t j( i>= 0 && i <t h i s . s i z e )
? one t h i s . e l t s [ i ] : no t h i s . e l t s [ i ] ") g
Listing 3: Specication for List
7. EXAMPLES AND EV ALUATION
In this section we demonstrate how our framework is e-
cient enough to be used { at least in some cases { as a pri-
mary implementation mechanism, where, in contrast, pre-
vious uses of solving during execution have focused on spe-
cialized applications (such as redundant computation as a
fallback [18], or for exploring behavior in the early stages of
the development process [17]).
7.1 Solving Hard Problems
If a problem is solvable in polynomial time, a careful man-
ual implementation is likely to outperform a Squander im-
plementation. But if the problem itself is dicult, a solution
withSquander may turn out { due to the eciency of SAT
solvers { to perform better than a hand-written algorithm.
Of course, Squander will not always oer the most e-
cient solution; most of these problems have been well stud-
ied, and highly specialized heuristics have been developed
for solving them. Nevertheless, it is perhaps surprising how
competitive a SAT-based solution is { even including Squan-
der's overhead of encoding and decoding { with many hand-
written solutions. For our comparison, we used standard
textbook solutions to the benchmark problems, which are
typically based on backtracking with pruning. In Tables 4
and 5 we give total running time of our tool ( Squander ),
translation time to Kodkod ( tTransl ), translation time from
Kodkod to CNF ( tKodkod ) and SAT solving time ( tSAT).
7.1.1 ‚ÄúHamiltonian Path‚Äù Algorithm
A Hamiltonian path in a graph is one that visits each node
in the graph exactly once. Listing 4 shows both the data rep-
resentation that we used for graphs and the specication for
this problem. To nd a solution, the framework must create
a fresh array of nodes to hold the result; this is specied
explicitly using the @FreshObjects annotation. The speci-
cation asserts that the returned path contains all nodes in
the graph, and that for every two consecutive nodes in the
path, there exists an edge between them in the graph.
The textbook backtracking algorithm uses an adjacency
matrix to represent a graph. We took this particular imple-
mentation from the web site of the Cornell course on Algo-
rithms and Data Structures [1].
In our experiment, we generated two categories of directed
graphs: (1) graphs without any Hamiltonian paths, and (2)
graphs containing one or more Hamiltonian paths. For eachgraphs size, we ran the experiment on 10 dierent graphs
of that size, measured the execution times, and calculated
the average. All experiments included 2 warmup runs to
neutralize possible eects of class loading, etc.
p u b l i c c l a s s Graph f
p u b l i c s t a t i c c l a s s Node fi n t v a l u e ; g
p u b l i c s t a t i c c l a s s Edge fNode src , d s t ; g
p r i v a t e Set<Node>nodes ; p r i v a t e Set<Edge>edges ;
@Ensures ( f"r e t u r n [ i n t ] i n t h i s . edges . e l t s " ,
"r e t u r n [ i n t ] . ( s r c + d s t ) = t h i s . nodes . e l t s " ,
"r e t u r n . l e n g t h = #t h i s . nodes . e l t s  1 " ,
" a l l i : i n t ji>= 0 && i <r e t u r n . l e n g t h  1 =>
r e t u r n [ i ] . d s t = r e t u r n [ i +1]. s r c " g)
@Modifies ( f"r e t u r n . l e n g t h " , "r e t u r n . elems " g)
@FreshObjects ( c l s = Edge [ ] . c l a s s , num = 1)
p u b l i c Edge [ ] hp ( ) fr e t u r n Squander . exe ( t h i s ) ; gg
Listing 4: Hamiltonian Path specication
The following procedure was used to generate graphs:
1. generate and add nnodes to the graph
2. generate a random permutation of nodes and add edges
between the neighboring nodes in the permutation, in-
cluding the edge between the last and the rst node.
At this point, the graph contains a Hamiltonian cycle.
3. randomly choose a number between 30 and 90 percent
of the maximum number of nodes ( n(n+ 1)) and keep
adding random edges until the number of edges in the
graph is equal to the chosen number.
4. randomly choose a node and remove all its incoming
edges. At this point, the graph still contains at least
one Hamiltonian path, the one that starts from the
node selected in this step.
5. if the goal is to generate graphs with no Hamiltonian
paths, remove all outgoing edges of the node selected
in the previous step.
The results are shown in Table 4. For the manual imple-
mentation, establishing the absence of a Hamiltonian path
is harder than nding one (if it exists), since this requires
exploring all paths from the rst node (i.e. whichever node
it chooses rst). Sometimes, it can happen that the rst
node has no outgoing edges, in which case the manual al-
gorithm terminates instantly, but on average, the problem
becomes hard for a random graph with 15 or more nodes.
In contrast, the boolean solver seems to easily locate the
isolated node, no matter where it is found in the graph, and
can thus prove nonexistence of a Hamiltonian path more
easily. Finding a path when one exists is harder, but on
average, the declarative solution still scales better than the
backtracking algorithm.
7.1.2 The N-Queens Problem
The problem of N-Queens involves placing Nqueens on
anNNchess board so that no queen can take any of
the others. E. W. Dijkstra, in his book on structured pro-
gramming [7], describes a backtracking solution with prun-
ing, which we implemented in Java for the purpose of our
experiment. This algorithm keeps track of rows, columns
and diagonals that have been taken by the queens already
placed on the board, so every time it has to pick a position
for the next queen, it avoids all conicting cells, thus prun-
ing a large portion of the search space. (There is a known
polynomial time algorithm for N-Queens [20], which rst
guesses a solution, and then performs a local search using aGraphs without Hamiltonian paths Graphs with Hamiltonian paths
10 14 15 20 25 30 35 40 10 14 15 20 25 30 35 40
Manual 0.02 96.92 t/o t/o t/o t/o t/o t/o 0.01 50.17 214.96 t/o t/o t/o t/o t/o
Squander 0.19 0.29 0.28 0.37 0.57 1.2 1.8 3.59 0.22 0.45 0.31 0.87 8.76 98.08 t/o t/o
tTransl 0.10 0.10 0.12 0.12 0.11 0.12 0.14 0.20 0.12 0.20 0.15 0.20 0.38 0.83 t/o t/o
tKodkod 0.09 0.18 0.15 0.24 0.43 1.01 1.49 3.07 0.1 0.18 0.12 0.18 0.53 1.05 t/o t/o
tSAT 0.0 0.01 0.01 0.01 0.03 0.07 0.17 0.32 0.0 0.07 0.04 0.49 7.85 96.2 t/o t/o
Table 4: Hamiltonian path execution times
gradient-based heuristic to move certain queens around until
all conicts have been resolved.)
@Requires ( " r e s u l t . l e n g t h == n ")
@Ensures ( f
" a l l k : i n t jk>=0 && k <n =>l o n e ( C e l l @ i ) . k " ,
" a l l k : i n t jk>=0 && k <n =>l o n e ( C e l l @ j ) . k " ,
" a l l q1 : r e s u l t . e l t s jno q2 : r e s u l t . e l t s  q1j" +
" q1 . i = q2 . i j jq1 . i q1 . j = q2 . i q2 . j j j" +
" q1 . j = q2 . j j jq1 . i + q1 . j = q2 . i + q2 . j " g)
@Modifies ( f
"C e l l . i [ ] [ fk : i n t jk>=0 && k <ng] " ,
"C e l l . j [ ] [ fk : i n t jk>=0 && k <ng] " g)
p u b l i c s t a t i c v o i d nqueens ( i n t n , Set <C e l l>r e s u l t )
Listing 5: NQueens Specication
Listing 5 gives the specication for N-Queens. The nqueens
method takes an integer n, and a set already containing ex-
actly n Cell3objects, and is expected to modify the coor-
dinates of the given cells so that they represent a valid po-
sitioning of nqueens.4The frame condition species that
only cell coordinates are modiable. The two bracketed
subexpressions respectively mean that: (1) all Cellinstances
are modiable, (2) the upper bound is f0;;n 1g(val-
ues for cell coordinates). In the post-condition, the third
\all" clause asserts that no two dierent cells (queens) in
the resulting set may be in the same row, column or either
diagonal. The rst two universal quantier clauses are re-
dundant; they state that every row and every column must
contain exactly one Cell object, which follows from the third
constraint. Even though they are not required for correct
execution, redundant constraints often (as here) improve the
performance of the solver. To improve clarity, we could in-
troduce a special annotation, e.g. @AdviceSpec , to hold such
redundant constraints which don't add anything new to the
problem specication, but only help the performance.
n = 16 28 32 34 36 68
Manual 0.01 0.49 15.94 428.94 t/o t/o
Squander 0.64 4.88 10.32 11.58 16.02 269.09
tTransl 0.18 0.57 0.93 1.1 1.34 17.57
tKodkod 0.38 1.45 2.59 3.08 3.54 32.71
tSAT 0.08 2.86 6.8 7.4 11.14 218.81
Table 5: N-Queens execution times (in seconds)
3Cell is a simple wrapper class for iand jcoordinates of
the chess board.
4The reason why this method takes a set of cells (as opposed
to creating a new set with n Cell s in it) is non-essential:
Squander can't arbitrarily create new objects; instead it
requires the user to explicitly pass the number of new objects
via FreshObjects annotations. Unfortunately, annotations
cannot take variables as arguments, only constants.Table 5 shows results for dierent values of n. For smaller
values (up to 28), the (manual) backtracking algorithm per-
forms better (although Squander 's performance is not ter-
rible). For larger values of n,Squander scales considerably
better. It computes a solution for 54 queens in 89 seconds,
whereas the manual algorithm begins to time out (that is,
exceed the ve minute limit we set) at only 34 queens.
8. COURSE SCHEDULER CASE STUDY
As a larger case study, we re-implemented an existing
application { a course scheduler that helps students select
courses to complete graduation requirements. Given a stu-
dent's current standing, it nds a path to graduation that
meets the program requirements for the undergraduate de-
gree in EECS at MIT. The MIT program oers around 300
courses, denes prerequisites for more than 150 courses, and
also species some additional requirements (e.g. manda-
tory courses, selections of multiple options from groups of
courses, etc). The original implementation [24] used the
Kodkod [21] constraint solver directly via its API.
About 1500 lines of code were written to translate the stu-
dent's standing and the set of MIT requirements to relational
constraints, run Kodkod to nd a solution, and nally trans-
late the Kodkod solution back to the original data struc-
tures. It is these lines of code that Squander is intended to
eliminate. Conceptually, the complexity of coming up with
correct specication for the problem remains the same; the
dierence is that the user can now write about 30 lines of
human-readable specications, instead of manually writing
1500 lines of code to walk the heap, construct all the Kod-
kod relations, create all the constraints through the Kodkod
API, and nally restore the solution onto the heap.
The goal of this case study was to assess the usability of
Squander on a real world program, whose core lies in solv-
ing a constraint problem. A key goal was to make minimal
changes to the existing data structures of the original appli-
cation, so that the rest of the application (e.g. GUI, I/O,
etc.) might be reused without modication.
Squander 's built-in abstractions for collection classes,
used extensively in the data model, were essential in reduc-
ing the annotation burden. We had to annotate user-dened
classes with invariants, dene additional specication elds
when necessary, and introduce a single new method ( solve ),
with a specication capturing the course requirements.
A second goal was to show that the framework could scale
to a large heap. The novel translation presented in Section 5
enabled us to handle heaps with almost 2000 objects. The
time it takes Squander to nd a solution for a problem of
this size is less than 5 seconds. The original implementation
still runs faster (it takes about 1 second) but the cost of its
development was much higher.@ I n v a r i a n t ( f
/f o r a l l c o ur se s , p r e r e q s must be taken i n the p r e v i o u s s e m e s t e r s /
" t h i s . prereqUsed . e l t s . e l t s i n ((~ t h i s . s C o u r s e s . e l t s . e l t s ) . ( ^ ( t h i s . s e m e s t e r s . prev ) ) . ( t h i s . s C o u r s e s . e l t s . e l t s ) ) " ,
/i n c l u d e p r e r e q u i s i t e s f o r c o u r s e s /
"( t h i s . s C o u r s e s . v a l s . e l t s & PrereqMap . p r e r e q s . keys ) i n t h i s . prereqUsed . keys " ,
/c o u r s e and s e m e s t e r a t t r i b u t e s match /
" a l l sem : Semester jt h i s . s C o u r s e s . e l t s [ sem ] . e l t s . a t t r i b u t e s . e l t s i n sem . a t t r i b u t e s . e l t s " ,
/don ' t s k i p s e m e s t e r s /
" a l l sem : Semester jsome t h i s . s C o u r s e s . e l t s [ sem ] . e l t s &&
! t h i s . s e m e s t e r s . prev [ sem ] . i s P a s t = >some t h i s . s C o u r s e s . e l t s [ t h i s . s e m e s t e r s . prev [ sem ] ] . e l t s " ,
/don ' t a s s i g n c o u r s e s more than once /
" a l l sem : Semester jno ( t h i s . s C o u r s e s . e l t s [ sem ] . e l t s & t h i s . s C o u r s e s . e l t s [ Semester  sem ] . e l t s ) " ,
/don ' t add " n u l l " /
" n u l l ! i n t h i s . s C o u r s e s . v a l s . e l t s " g)
p u b l i c c l a s s Schedule f
p r i v a t e L i s t<Semester >s e m e s t e r s ;
p r i v a t e Map<Semester , Set <Course > > s C o u r s e s ; p r i v a t e Map<Course , Set <Course > > prereqUsed ; g
p u b l i c c l a s s Problem f
p r i v a t e DegreeProgram dp ; p r i v a t e Schedule s c h e d u l e ; p r i v a t e Set<Requirement >a d d i t i o n a l R e q s ;
@Ensures ( f
" a l l req : t h i s . a d d i t i o n a l R e q s . e l t s + t h i s . dp . g r o u p i n g s . e l t s . groupingReqs . e l t s jreq . cond " ,
" t h i s . dp . rootGrouping . c o u r s e s . e l t s i n t h i s . s c h e d u l e . s C o u r s e s . v a l s . e l t s " g)
@Modifies ( f
/modify "s e m e s t e r to s e t of c o u r s e s " map , but don ' t change the mapping f o r "pa s t " s e m e s t e r s /
" t h i s . s c h e d u l e . s C o u r s e s . v a l s . e l t s [ fs t : j a v a . u t i l . Set <Course >jno sem : Semester j
sem . i s P a s t && ( ( sem  >s t ) i n t h i s . s c h e d u l e . s C o u r s e s . e l t s ) g] " ,
/modify the used p r e r e q u i s i t e s map /
" t h i s . s c h e d u l e . prereqUsed . e l t s [ ] [ ] [ PrereqMap . p r e r e q s . e l t s . e l t s ] " ,
p u b l i c v o i d s o l v e ( ) fSquander . exe ( t h i s ) ; gg
Listing 6: Partial specication for the course scheduler
8.1 SpeciÔ¨Åcation
The total number of lines of specication we wrote for this
case study was less than 30. Here, we illustrate only the most
interesting portion; the rest can be found in [14, ch. 8].
Class Schedule is the primary class. It contains a list
of semesters (given in advance and not to be modied),
and a mapping from semesters to courses ( sCourses ) to be
computed. It may contain some existing assignments (e.g.
courses already taken) which are not to be modied. Course
prerequisites are dened (in disjunctive normal form) as sets
of sets of courses, with an additional eld ( prereqUsed )) hold-
ing the choice of course used to satisfy a course's prerequi-
site. The specication that captures these invariants (and
others) is shown in Listing 6.
The core of the specication for the scheduler is associ-
ated with the method solve() (Listing 6). Aside from ref-
erences to a DegreeProgram and a Schedule , the Problem class
contains a set of additional constraints provided by the stu-
dent, e.g. \don't schedule a course", \schedule a course after
a given semester", etc; departmental requirements are as-
sociated with DegreeProgram . The post-condition says that:
(1) all requirements must hold, and (2) the schedule must
include all courses specied by the department.
To express the rst property, without having to know
about all subclasses of Requirement , we simply dened a
boolean specication eld (named cond) and asserted that it
evaluates to true. Specic classes that implement Require-
mentare expected to override the denition of condto impose
their own constraints. That way, we were able to specify sev-
eral kinds of requirement (e.g. mandatory courses, minimal
number of courses from a certain course group, etc.), but
detailed description is beyond the scope of this paper.
The frame condition for solve requires more than just list-
ing the modiable elds. For example, not only must the
Set<Course>.data eld be modiable (because we are search-ing for suitable values for the Schedule.sCourses map), but
an instance selector must also be provided to specify that
only those sets of courses that are not associated with the
past semesters may be modied. The content of the \used
prerequisites" map ( Map<Course, Set<Course>> ) must also be
modiable, but this time, however, it is essential to tighten
the upper bound for this eld so that its content is a subset
of the constant map of course prerequisites dened by the
department (which has less than 300 entries). Otherwise,
the bound for this eld would have gone up to 90,000 atoms,
since there are 300 distinct courses and 300 distinct sets of
courses on the heap, causing a huge performance setback.
9. RELATED WORK
The idea of executable specications is not a new one.
However, it has been widely assumed that any implemen-
tation would be hopelessly inecient, and thus not feasible
for practical applications. Hoare [10] acknowledges the ben-
ets that such technology would have, but also predicts that
computers would never be powerful enough to carry out any
interesting computation in this way. Hayes and Jones [9] ar-
gue that direct execution of specications would inevitably
lead to a decrease in the expressive power of the specication
language. On the other side, Fuchs [8] claims that declara-
tive specications can be made executable by intuitive (man-
ual) translation to either a functional programming language
(such as ML) or a logic programming language (like Prolog).
In our previous paper [17], we suggested how executing
specications might play a useful role in an agile develop-
ment process [3] (for fast prototyping, test input generation,
creation of mock objects directly from interfaces, etc.), gen-
eralizing an idea that originally appeared in TestEra [13] in
which test cases generated by solving a representation in-
variant were concretized into heap structures. Since then,
we have developed the techniques discussed in this paper,and turned the prototype implementation mentioned in our
previous paper into a robust framework [2].
In the meantime, Samimi et al. implemented a tool [18],
called PBnJ, that takes ideas from our earlier paper, but
applies them in a dierent context: using executable spec-
ications as a fallback mechanism. Like Squander , PBnJ
provides a unied environment for imperative and declara-
tive code but it lacks Squander 's expressive power and the
ability to handle abstract types (and in particular, library
classes). Their spec methods are similar to the spec elds
of [17], but do not accommodate arbitrary declarative for-
mulas { rather, only those for which a straightforward trans-
lation to imperative code exists. As a consequence, spec
methods can express something like \all nodes in a graph",
or \all nodes such that each one of them has some property",
but cannot express \some set of nodes that form a clique".
Another limitation is that spec methods cannot be recursive.
By creating a separate relation for every spec eld, Squan-
dersolves all these problems: whatever abstraction function
is given to a spec eld, it will be translated into a relational
constraint on the corresponding relation, and Kodkod will
nd a suitable value for it. PBnJ comes with custom classes
for sets, lists and maps, but provides no mechanism for the
user to extend the support to other abstract types.
Squander can be considered as an implementation of the
Carroll Morgan's mixed interpreter [16], comprising a com-
bination of conventional imperative statements and declara-
tive specication statements [15]. Wahls et al. are working
on executing JML [5] (a specication language very sim-
ilar to JFSL) by translation to constraint programs and
using backtracking search [6, 12]. Oz also integrates con-
straint programming with high-level programming language
and does so by using constraint propagation and search com-
binators [19]. Yang's LogLog tool [22] employs runtime con-
straint solving to automatically impute values for missing
data based on declarative constraints.
10. CONCLUSIONS AND FUTURE WORK
In this paper, we presented Squander , a framework that
unies both writing and executing imperative and declar-
ative code. With the optimizations described above, and
specication extensions to support data abstraction, we have
shown in this paper (a) that we are now able { for a non-
trivial class of problems { to use the mechanism as a stan-
dard runtime, and (b) that the framework is expressive enough
to specify and completely eliminate the manual encodings
and decodings of a moderately-sized course scheduling ap-
plication we had previously implemented.
In the future, we are hoping to explore a dierent transla-
tion mechanism, that would not only minimize the number
of atoms in the universe, but the number of relations as well.
For many problems, we compared the existing handwritten
translations to Kodkod with those produced by Squander .
In almost all cases, the handwritten translations were more
compact and used fewer relations. This is because object
graphs usually contain many unmodiable \links" that are
only used to navigate from the root objects to the modi-
able portion of the heap. A more clever translation could
short-circuit some of those links, thus reduce the size of the
object graph, and potentially decrease the solving time. We
also plan to compare dierent techniques for solving declar-
ative constraints, e.g. the backtracking ones as in JMLe [12]
or Korat [4], with our current, SAT-solver based one.11. REFERENCES
[1] Hamiltonian Path Algorithm.
http://moodle.cornellcollege.edu/0809/mod/
resource/view.php?id=8993 . CSC213-8 Course.
[2] Squander Home Page.
http://people.csail.mit.edu/aleks/squander .
[3] K. Beck. Extreme Programming Explained . 1999.
[4] C. Boyapati, S. Khurshid, and D. Marinov. Korat:
Automated Testing Based on Java Predicates. In
ISSTA'02 .
[5] L. Burdy, Y. Cheon, D. Cok, M. D. Ernst, J. R.
Kiniry, G. T. Leavens, K. R. M. Leino, and E. Poll.
An Overview of JML Tools and Applications. Software
Tools for Technology Transfer , 7(3):212{232, 2005.
[6] N. Cata no and T. Wahls. Executing JML
specications of Java card applications: a case study.
InSAC'09 , pages 404{408, 2009.
[7] O. J. Dahl, E. Dijkstra, and C. A. R. Hoare, editors.
Structured programming . Academic Press, 1972.
[8] N. E. Fuchs. Specications are (preferably) executable.
Software Engineering Journal , 7(5):323{334, 1992.
[9] I. Hayes and C. B. Jones. Specications are not
(necessarily) executable. Software Engineering
Journal , 4(6):330{338, 1989.
[10] C. A. R. Hoare. An Overview of Some Formal
Methods for Program Design. IEEE Computer ,
20(9):85{91, 1987.
[11] D. Jackson. Software Abstractions: Logic, Language,
and Analysis . MIT Press, Apr. 2006.
[12] B. Krause and T. Wahls. jmle: A tool for executing
JML specications via constraint programming. In
FMICS'06 , Aug. 2006.
[13] D. Marinov and S. Khurshid. TestEra: A Novel
Framework for Automated Testing of Java Programs.
InASE'01 , 2001.
[14] A. Milicevic. Executable Specications for Java
Programs. Master's thesis, MIT, Sept. 2010.
[15] C. Morgan. The Specication Statement. ACM Trans.
Prog. Lang. Syst. , 10(3), 1988.
[16] C. Morgan. Programming from Specications .
Prentice-Hall, 2nd edition, 1998.
[17] D. Rayside, A. Milicevic, K. Yessenov, G. Dennis, and
D. Jackson. Agile specications. In Onward'09 , 2009.
[18] H. Samimi, E. D. Aung, and T. D. Millstein. Falling
Back on Executable Specications. In ECOOP'10 .
[19] C. Schulte, G. Smolka, and J. W urtz. Encapsulated
Search and Constraint Programming in Oz. In PPCP ,
pages 134{150. Springer-Verlag, 1994.
[20] R. Sosic and J. Gu. A polynomial time algorithm for
the N-Queens problem. SIGART B. , 1(3):7{11, 1990.
[21] E. Torlak. A Constraint Solver for Software
Engineering: Finding Models and Cores of Large
Relational Specications . PhD thesis, MIT, 2008.
[22] J. Yang. Specication-Enhanced Execution. Master's
thesis, MIT, May 2010.
[23] K. Yessenov. A Light-weight Specication Language
for Bounded Program Verication. Master's thesis,
MIT, 2009.
[24] V. S. Yeung. Declarative Conguration Applied to
Course Scheduling . Master's thesis, MIT, 2006.