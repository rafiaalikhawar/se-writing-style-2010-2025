Tracking Load-time ConÔ¨Åguration Options
Max Lillack
University of Leipzig, GermanyChristian K√§stner
Carnegie Mellon University, USAEric Bodden
Fraunhofer SIT &
TU Darmstadt, Germany
ABSTRACT
Highly-congurable software systems are pervasive, although
conguration options and their interactions raise complexity
of the program and increase maintenance eort. Especially
load-time conguration options, such as parameters from
command-line options or conguration les, are used with
standard programming constructs such as variables and if
statements intermixed with the program's implementation;
manually tracking conguration options from the time they
are loaded to the point where they may inuence control-
ow decisions is tedious and error prone. We design and
implement Lotrack , an extended static taint analysis to
automatically track conguration options. Lotrack derives
a conguration map that explains for each code fragment un-
der which congurations it may be executed. An evaluation
on Android applications shows that Lotrack yields high
accuracy with reasonable performance. We use Lotrack to
empirically characterize how much of the implementation of
Android apps depends on the platform's conguration op-
tions or interactions of these options.
Categories and Subject Descriptors
K.6.3 [ Software Management ]: Software maintenance
Keywords
Variability mining; Conguration options; Static analysis
1. INTRODUCTION
Software has become increasingly congurable to support
dierent requirements for a wide range of customers and
market segments. Conguration options can be used to
support alternative hardware, cater for backward compat-
ibility, enable extra functionality, add debugging facilities,
and much more. While conguration mechanisms allow end
users to use the software in more contexts, they also raise the
software's complexity for developers, adding more function-
ality that needs to be tested and maintained. Even worse,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ASE‚Äô14, September 15-19, 2014, Vasteras, Sweden.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2643001.conguration options may interact in unanticipated ways
and subtle behavior may hide in specic combinations of
options that are dicult to discover and understand in the
exponentially growing conguration space. Conguration
options raise challenges since they vary and thus complicate
the software's control and data ow. As a result, develop-
ers need to trace conguration options through the software
to identify which code fragments are aected by an option
and where and how options may interact. Overall, making
changes becomes harder because developers need to under-
stand a larger context and may need to retest many cong-
urations.
There are many strategies to implement conguration op-
tions, but particularly common and problematic is to use
load-time parameters (command-line options, conguration
les, registry entries, and so forth): Parameters are loaded
and used as ordinary values within the program at runtime,
and conguration decisions are made through ordinary con-
trol statements (such as ifstatements) within a common im-
plementation. The implementation of conguration options
with plugins or conditional compilation provide some static
traceability of an option's implementation which is miss-
ing in load-time conguration options. Identifying the code
fragments implementing an option requires tedious manual
eort and, as our evaluation conrms, is challenging to get
right even in medium-size software systems.
In this work, we propose Lotrack ,1a tool to statically
track conguration options from the moment they are loaded
in the program to the code that is directly or indirectly af-
fected. Specically, Lotrack aims at identifying all code
that is included if and only if a specic conguration option
or combination of conguration options is selected . The re-
covered traceability can support developers in many main-
tenance tasks [11], but, in the long run, can also be used
as input for further automated tasks, such as removing a
conguration option and its use from the program, translat-
ing load-time into compile-time options, or guaranteeing the
absence of interactions among conguration options. In con-
trast to slicing [32], which determines whether a statement's
execution depends on a given value, Lotrack determines
under which congurations, i.e., a set of selected congura-
tion options, a given statement is executed.
To track conguration options precisely, we exploit the na-
ture of how conguration options are typically implemented.
Although a na ve forward-slicing algorithm can identify all
code potentially aected by a conguration option, directly
or indirectly, in practice, it will frequently return slices that
1https://github.com/MaxLillack/Lotrack
445
are largely overapproximated, due to hard-to-handle pro-
gramming features such as aliasing, loops and recursion. To
increase precision, we exploit the insight that conguration
options are typically used dierently from other values in the
code: Values for conguration options are often passed along
unmodied and are used in simple conditions, making their
tracking comparatively easy and precise. Finally, only few
conguration options are usually used in any given part of a
program. Technically, Lotrack extends a context, ow, ob-
ject and eld-sensitive taint analysis to build a conguration
map describing how code fragments depend on conguration
options.
This paper evaluates Lotrack in the context of Android
applications. Android apps are interesting subjects for study-
ing conguration options, since the Android platform has a
reputation for being diverse and fragmented with many dif-
ferent platform versions and hardware features [18]. Android
apps query a xed set of conguration options given by the
framework to dynamically switch between implementations
or disable functionality if the corresponding feature (e.g.,
Bluetooth support) is not available on a device. In a large
set of Android apps, we track how conguration options are
used and how much code is devoted to implement optional
functionality. We nd that most apps use standard congu-
ration options given by the framework to optionally include
code. We estimate an average of 1% of the apps' source is
executed depending on conguration options.
In summary, this paper presents the following original con-
tributions:
an encoding of the problem of tracking conguration
options as a taint-analysis problem,
a description of how to make use of common charac-
teristics of conguration values in programs to increase
the precision of the analysis,
an implementation based on FlowDroid [3] able to han-
dle Java/Android source code and bytecode, and
an empirical evaluation demonstrating the precision
and recall of our implementation as well as an overview
of conguration option usage based on a sample of 100
open-source Android apps.
2. PROBLEM STATEMENT
Our goal is to trace conguration options to the code frag-
ments implementing them. That is, we want to nd all code
that is executed if and only if a specic conguration con-
straint is satised. For example, in an Android app, we
might want to nd all source code bound to the availabil-
ity of Bluetooth or to functionality only active on devices
running Android 4.4 or higher.
Technically, we seek to establish a conguration map which
maps every code fragment to a conguration constraint de-
scribing in which congurations the code fragment may be
executed in the program, that is, which conguration op-
tions or combinations of options need to be selected or dese-
lected. We describe the conguration constraint as a propo-
sitional formula over (atomic) conguration decisions. A
conguration constraint is a selection for a specic con-
guration option, such as Bluetooth =on(abbreviated to
Bluetooth +for Boolean options) or SDKVersion4:4. If
we only know that a conguration option Ois involved, but
we are unable to gure out more precisely how, we write O?
as conguration constraint. A conguration constraint may
describe many congurations; for example, Bluetooth +^
class=ProxyService={
==static=boolean=N7TIVE_PROXY_SUPPORTE<=
======================3=8uildgVERSIONgS<K_INT=43=kHW
==public=void=onSharedPreference9hanged2;={
====String=ketHostW
====if=2BN7TIVE_PROXY_SUPPORTE<;={
======ketHost=3=getString2Rgstringgpref_proxyhost;W
======ggg
====}
====String=command=3=path=h=u=Chost=uW
====String=result=3=RootToolsgsendShell2command=h=ketHost;W
====ggg
==}
}
class=9onfiguration7ctivity={
==public=void=onHelp2View=view;={
====Intent=intentW====
====if=2ProxyServicegN7TIVE_PROXY_SUPPORTE<;
======intent=3=new=Intent2thisf=Proxy9onfggg;W
====else
======intent=3=new=Intent2Intentg79TION_VIEWf=uri;W
====start7ctivity2intent;W=
==}=
})k
)H
)!
)}
)m
)+
)"
)-
)w
k)
kk
kH
k!
k}
km
k+
k"
k-
kw
H)
Hk
HH
H!
H}S<K0kH
S<K43kH
S<K0kHFigure 1: Example from Adblock Plus app and ex-
pected conguration map
(SDKVersion4:4) describes the set of congurations in
which Bluetooth is enabled and a specic SDK version is
selected. In Figure 1, we illustrate a conguration map for
a simple excerpt from the Adblock Plus2app in which the
conguration constraint for each statement is written to the
left of the line. It is only an excerpt; the whole app uses
the shown eld six times and in four dierent classes. This
shows the scattered nature of the conguration option's im-
plementation.
A conguration map can support developers in perform-
ing maintenance tasks or in reasoning about the implemen-
tation. Developers can look up all code fragments imple-
menting a specic conguration option and can investigate
how two conguration options relate. For instance, in prior
work, we and others have shown how background colors and
views/projections highlighting options can signicantly im-
prove developer productivity, especially if the implementa-
tion of conguration options is scattered throughout multi-
ple locations [4, 10, 15]. A conguration map simplies oth-
erwise potentially daunting tasks, such as removing an ob-
solete option from the code [6], refactoring the scattered im-
plementation of an option into a module [1, 12, 16], changing
the binding time of a conguration option between compile-
time and load-time [24], or determining test-adequacy crite-
ria with conguration coverage [30]. With a precise congu-
ration map, one could even determine that two conguration
options can never interact and thus could establish that one
does not need to test their interactions. For the example
shown in Figure 1, having the conguration map highlights
the scattered implementation fragments implementing the
option's functionality and supports quick navigation.
There are many dierent strategies to implement cong-
uration options [2], some of which allow us to extract a con-
guration map easily. For example, when providing optional
functionality as plug-ins to frameworks such as Eclipse and
Wordpress, one can locate the corresponding implementa-
2https://github.com/adblockplus/adblockplusandroid
446tion in those plug-ins. Similarly, using conditional compi-
lation, for example using the C preprocessor's #ifdef direc-
tives, despite all criticism [9, 28], enables a simple static
localization of all scattered code fragments implementing an
option with a simple search over those directives [2, 6, 27].
3Unfortunately, for load-time conguration options there
is no such simple static extraction, because conguration
happens after compile-time and because a simple syntac-
tic analysis is insucient to distinguish conguration values
from other runtime values.
In this work, we thus design a static analysis that ap-
proximates a conguration map for load-time conguration
options by tracking each conguration option from the point
at which it is loaded to the control-ow decisions that in-
clude or exclude a code fragment depending on the option's
value. In Figure 1, we show an example of the result of our
approach: The Android app loads a conguration option re-
garding the SDK version, assigns it to a eld, and uses it
in other locations in the implementation to decide whether
to execute additional code. The resulting conguration map
identies that the additional code can only be executed in
specic congurations (shown in gray boxes). Note that,
in contrast to slicing [32], our conguration map does not
include statements that compute with conguration values
or values inuenced by them (e.g., Line 22 in our example),
but only code blocks included or excluded by conguration-
related control-ow decisions.
To scope our approach, we make the following assump-
tions:
Conguration options are set at program load time and
do not change during the execution of the program,
hence reading the same conguration value multiple
times will always yield the same result. Yet, the read
conguration value may be assigned to variables and
those variables' values may change during runtime.
The API calls to load conguration values are known
and can be identied syntactically (e.g., the read from
eld SDK_INT in Figure 1); the possible values of con-
guration options are nite and known. How these
options are identied is outside the scope of this pa-
per. Possible strategies include manual identication
by reading source code and documentation or using
existing heuristics and static analysis tools [21].
After being read from the API, conguration values
may be assigned to variables or elds and may be prop-
agated or processed in arbitrary ways in the program.
Conguration options may trigger data dependencies
in other variables and only indirectly inuence control-
ow decisions.
By tracking conguration options in a program, we are
essentially tracking all control and data dependencies of a
value through arbitrary computations. Since such static
computation is undecidable (Rice's theorem), our approach
relies on standard static-analysis techniques, conservatively
abstracting over concrete values, similar to, e.g., program
3Compile-time conguration mechanisms can still trigger
runtime decisions, for example by using a macro with al-
ternative compile-time values to initialize a variable that is
subsequently used in runtime control-ow decisions. Current
techniques do not discover these dependencies crossing bind-
ing times; more advanced static analyses would be required,
similar to what we propose for load-time congurations in
this paper.slicing [32]. In general, one might think that too coarse
abstractions could easily yield useless overapproximations,
where essentially every code fragment is potentially inu-
enced by every conguration option. As we observed in
practice, however, in many programs conguration options
are used in limited ways. In particular, one can tailor static
program analyses because conguration options often ex-
hibit the following common characteristics:
Conguration options often have a small domain, in
many cases they have just two possible values, which
makes it feasible to track concrete values and eciently
reason about expressions over conguration values.
Conguration options are commonly reassigned and
propagated throughout the program, but they are rarely
changed once they are loaded.
Conguration options often occur in control-ow de-
cisions (e.g., ifstatements), but they rarely are in-
volved in more complex computations. For example,
one might compute the sine of a regular input, but
rarely of a conguration option.
The context, ow, object and eld-sensitive taint analysis
underlying Lotrack already allows a precise tracking of
the use of conguration options.
3. APPROACH
The general idea of Lotrack is to use a taint analysis to
track conguration options through the code and identify
when control-ow decisions depend on tainted values. A
taint analysis is a data-ow analysis typically used in secu-
rity research, e.g. to detect information leaks. To this end,
a private value is marked as tainted and all values derived
from this value (directly or indirectly) are tainted as well, al-
lowing one to recognize when tainted private values are used
in contexts where they should not (e.g., sent over a network).
Lotrack uses a taint analysis in a slightly dierent way: It
taints all values resulting from reading a conguration op-
tion or from a computation of a tainted value; when a tainted
value occurs in a control-ow decision, one knows that all de-
pendent code may depend on this conguration option. To
reduce over-approximation and produce an accurate cong-
uration map, Lotrack additionally tracks specic values as
conditional taints for selected conguration options, as we
will explain in Section 3.2.
3.1 Taint Analysis for ConÔ¨Åguration Options
Conceptually, Lotrack performs a taint analysis for each
conguration option. The analysis taints all values read
from conguration options, as identied by a list of the fully
qualied names of methods and elds used to access the con-
guration API. The taint analysis then propagates the taints
inter-procedurally along control-ow edges to all values that
directly or indirectly depend on this value, considering both
control-ow and data-ow dependencies; for example, if the
right-hand side of assignments contains tainted values, their
left-hand side is tainted and is considered to be derived from
the conguration option. When a tainted value is read in
the condition of an ifstatement, one knows that the subse-
quent computations depend on the conguration option. For
example, reading from SDK_INT in Figure 1 causes the cre-
ation of a taint for the eld NATIVE_PROXY_SUPPORTED in its
initialization expression, and due to an indirect information
ow also for intent ; in the two ifstatements, we then see
that the control-ow condition depends on a tainted value.
447¬¨WIFIbooleanwgpsOnw=wLocationManager.isProviderEnabled3GPS4;
booleanwwifiOnw=wSettings.WIFI_ON;
if3fwifiOn4
wwlog3gpsOn4;01
02
03
04Figure 2: Example for access and use of congura-
tion options
To create a conguration map, Lotrack creates taints
for all conguration options and maps each code fragment
whose execution is dependent on a tainted variable to the
conguration options associated with the taint. Intuitively,
every time a tainted value associated with some option oc-
curs in the expression of an ifstatement (or other control-
ow decision), all statements in the then and else branch
depend on the conguration option and thus are associated
with it. Similarly, classes and methods exclusively used in
paths guarded by tainted conditionals are associated with
this conguration option.
A common problem with taint analysis is how to handle
native functions and environment interactions. For a sound
analysis, unless one knows how information ows through
the environment, one has to assume the worst, i.e., that ev-
ery value read from the environment may be tainted, often
leading to massively overapproximated results. In practice,
we allow false negatives and only create taints for results
of native-method calls or environment interactions if they
have been parameterized with a tainted value. For example
in our example in Figure 1 value result is tainted because
it is returned by a call using the tainted parameter ketHost .
This simplication is grounded in the assumption that con-
guration options are mostly used in simple ways so that
false negatives should be rare. In fact, handling of native
functions and environment interactions are customizable to
dierent levels of strictness, and the underlying FlowDroid
tool supports such customizations through its conguration.
3.2 Tracking ConÔ¨Åguration Values
The simple taint-based analysis above creates a map be-
tween code fragments and all involved conguration options.
However, it does not tell howconguration options inuence
the selection of a code fragment. In our example (Figure 1),
we would ideally like to know that Line 7 is only executed
ifSDK INT <12 instead of only knowing that it some-
how depends on SDK INT (i.e., conguration constraint
SDK INT ?). To that end, we extend the taint analysis to
track conguration values instead of only conguration op-
tions.
To track conguration values, Lotrack implements sev-
eral extensions to the taint analysis. In particular, Lotrack
tracks a taint for each possible value of a variable and tracks
a constraint under which conguration this variable has this
value. Second, Lotrack does not propagate all taints di-
rectly, but analyzes, restricts, and merges constraints at
control-ow decisions.
To explain this in more detail, consider a second example
in Figure 2. Here Lotrack does not create a single taint
for eld gpsOn explaining that it depends on conguration
option GPS, but rather two dierent taints: one with the
value gpsOn+under the condition that GPS is selected and
one with the value gpsOn under the condition that GPS
is deselected. The same happens for variable wifiOn and
option WIFI . In the control-ow decision if(!wifiOn) oneknows that the then branch will only be executed if option
WIFI is deselected; which is why the analysis marks the
corresponding control-ow edge with the constraint :WIFI
and propagates all taints along this path only with restricted
constraints; in our case it propagates gpsOn +only under the
condition GPS^:WIFI .
With value tracking, one can directly model constraints
on options with small nite domains. The analysis cre-
ates a taint for every possible value (e.g., true and false for
Booleans and Version 1:2,Version 1:3for versions). For a con-
straint with an unknown value of conguration option Owe
use the notation O?. For example, Version ?indicates that
the code fragment somehow depends on the version cong-
uration option, but allows no statement about the concrete
version number.
The taint information denoted by the variable and the
tracked value together with the constraint constitute a fact.
Generally, facts are simply propagated like taints in a taint
analysis. A fact is no longer propagated, however, if the
corresponding constraint is unsatisable. If a control-ow
decision depends on a tainted value, we derive constraints
for the control-ow branches by evaluating the branching
condition. All facts are propagated along such control-ow
branches with the respective more restrictive constraint (a
conjunction of the fact's previous constraint and the control-
ow branch's constraint). If several facts with the same
taint information reach the same statement, for instance, at
a control-ow merge point, the constraints for these facts
are combined as disjunctions, leading to a less restrictive
constraint. For example, a fact expressing that variable a
has the value trueunder condition DEBUG merged with an-
other fact expressing that the variable has value true under
condition:DEBUG would be merged into a single fact that
the variable has always the value true.
At the x point, the analysis has gathered facts with con-
straints for each reachable statement in the program. To
create the conguration map, Lotrack creates a single con-
straint for each statement. For this, the constraints of all
facts at a statement are disjoint.
3.3 Algorithm
Lotrack works on top of a taint analysis which provides
the functionality of taint creation and propagation as well
as common features of static program analysis like call-graph
creation and alias analysis. Besides a basic overview of the
algorithm for taint analysis, we concentrate on the extension
for the tracking of constraints and refer for a more detailed
description of the basic taint-tracking mechanisms to the
works on FlowDroid [3].
Our value-based taint-tracking algorithm shown in Algo-
rithm 1 requires an inter-procedural control-ow graph and
an initial edge as input. To handle the multiple possible
entry points to mobile apps, the underlying FlowDroid tool
creates an articial main method which calls every possible
entry point. The main method also simulates the initializa-
tion of static class members.
The analysis works on the level of summary edges . An
edge consists of a source and target fact, the source and
target statement, as well as a constraint. In Line 2 of Al-
gorithm 1 the initial edge with constraint true, given by
the control-ow graph, is added to a set of edges to be pro-
cessed. More edges will be created from the algorithm itself
as it traverses the control-ow graph.
448input : inter-procedural control-ow graph (icfg),
initial edge
output : set of facts
1 Function trackTaints
2 edges finitialEdgeg ;
3 result fg ;
4 while edges do
5 edge edges.remove;
6 for successor2icfg.successors(edge) do
7 for fact2successor.facts(edge) do
8 constr cur: edge.constr ;
9 constr fact createConstraint(edge) ;
10 constr new constr cur:^constr fact;
11 if result contains fact then
12 fact.constr fact.constr_constr new;
13 else
14 result.add(new Fact(successor, constr new));
15 end
16 if constr new6=falsethen
17 edges.add(new Edge(successor, fact));
18 end
19 end
20 end
21 end
22 return result;
23 end
Algorithm 1: Taint-tracking algorithm
For each edge, the following basic steps are taken. The
successors of the edge's target statement are determined us-
ing the inter-procedural control-ow graph (Line 6). Using
a normal taint analysis, the possible taints at the succes-
sor are determined based on the current edge (Line 7). At
an API accessing statement, the taint analysis creates new
taints for each possible conguration value (taint creation
is not shown). For each possible taint at the successor, the
constraint required for this taint to be propagated is deter-
mined using Algorithm 2.
Algorithm 2 computes the constraint for the propagation
of a fact along a control-ow edge using the information in
the edge as well as other facts for the same statement. An
API access or a branching statement can lead to the creation
of new constraints, all other cases will return true leaving
constraints of facts, which are propagated along the edge,
unchanged.
At an API access (Lines 25-31) the algorithm creates an
initial edge pointing to the fact representing the accessed
option. The algorithm checks whether value tracking is en-
abled for this conguration option. For value tracking, a
constraint is created with respect to the values of the con-
guration option. At this point, the possible values are al-
ready encoded with possibly multiple fact (one per value),
which are created in the taint analysis (not shown in the al-
gorithms). In case of Boolean variables, the analysis simply
dierentiates between true and false which are mapped to
constraints for this conguration option, for example WIFI
and:WIFI respectively. To track values of other types,
the algorithm models the possible values as dierent con-
guration options e.g., version 1:2,version 1:3,version 2:0. If
value tracking is not possible, it creates the generic con-
straint WIFI ?(Line 30).input : edge (target statement and fact), all facts at
target, mapping API to options
output : constraint for edge
24 Function createConstraint
25 if target is API access and fact is for accessed option
then
26 option target.accessedOption();
27 if option can use value tracking then
28 return OPTION fact:value ;
29 else
30 return OPTION ?;
31 end
32 else if target is ifstatement then
33 result null;
34 for fact2target.facts() do
35 if fact matches ifcondition then
36 if result = null then
37 result false;
38 end
39 result result_fact.cstr ;
40 end
41 end
42 if result6=null and is false branch then
43 result negate(result);
44 end
45 if result = null then
46 result true;
47 end
48 return result;
49 else
50 return true;
51 end
52 end
Algorithm 2: Computation of constraint for edge
At a control-ow decision4(Lines 32-48), a new constraint
is created if the condition of the ifstatement is dependent
on a tainted value. The constraints of all matching facts
are combined as a disjunction to create the most general
constraint for this branching statement (Line 39). A fact
matches a condition, if its variable and value satisfy the
condition. For example, the condition in if(a) is satised
only by the variable aand value true. For operations on
Boolean variables, there is at most one matching fact, but for
other types of variables multiple matching facts are possible.
For a condition like version1:3 and the three possible facts
for option version shown above, the resulting constraint will
beversion 1:3_version 2:0.
The resulting constraint is used for the branch edge and
its negation for the fall-through edge (Line 43). If no fact
matched the condition the algorithm returns true (Line 46)
which indicates that the condition is not dependent on any
conguration option and therefore should not change the
constraint of any facts.
Line 10 in Algorithm 1 combines the resulting constraint
for the edge from Algorithm 2 by conjoining it with the con-
straint propagated to this edge so far (Line 8). For example,
4All programs are analyzed in an intermediate represen-
tation where all kinds of control structures are expressed
through if statements and gotos . Expressions are simplied
to comparing a variable to another variable or constant.
449if a fact has the constraint :Aand the constraint from the
control-ow edge is B, the resulting constraint for the fact
will be:A^B. Facts are not propagated further if the
resulting constraint is unsatisable.
Along dierent paths, dierent facts with the same taint
information (i.e., the same variable and value) can reach the
same statement. In this case, the facts are joined to a single
fact disjoining the individual constraints (Line 12).
The fact with the nal constraint together with the suc-
cessor statement results in a new edge which is added to the
list of edges to be processed. The algorithm nishes once
there are no more edges to process.
In contrast to a regular taint analysis, for value tracking,
the order in which the enlisted edges are processed is impor-
tant. The creation of a new constraint at an ifstatement
requires the information about facts reaching this statement.
Lotrack handles this restriction by ensuring that all open
edges are processed before continuing with the edges for the
ifstatement. A normal statement with a single successor
is handled in the order given the control ow. For calls,
exit statements and statements with multiple successors ( if
statements), we dene merge-point statements to describe
statement that merge the branches of the control-ow graph.
Edges out of these statements will not be processed until all
other edges are processed. For calls and exit statements, we
dene the return sites as merge points. Return sites com-
prise the statement after the call and possible catch state-
ments from exception handling. For statements with multi-
ple successors, we select the post-dominator of the statement
as merge point. This rule ensures, the then branch as well
as a possible elsebranch is covered before continuing.
3.4 Example
To illustrate the approach, we walk through a nontrivial ex-
ample shown in Figure 3. On the left side, we show Java
source code of two simple methods. On the right side, we
show a control-ow graph annotated with information re-
garding the data-ow information being tracked through the
program.
Our analysis uses Jimple, which is an intermediate three-
address code representation created from Java source code
or bytecode. Jimple introduces intermediate variables, par-
titions complex expressions, and performs other simplica-
tions. In our example, Lines 20 - 26 show a Jimple-like
expansion of the Java expression in Line 27. We use this
Jimple-like variant in the control ow on the right side to
explain the analysis of the statement step-by-step. The in-
termediate representation simplies the implementation and
explanation of the approach but does not aect the ability
to handle the full set of Java.
Our analysis proceeds as follows. First, we need the in-
formation which API can be used to retrieve the value of
conguration options and whether value tracking is used.
Table 1 shows the necessary input for our example.
Next, we start the actual taint analysis with the entry
point, in this case, the edge calling method start , from
where we analyze its rst statement, the call to method is-
Config . Before continuing within start , we need to handle
the called method to identify all possibly relevant results.
The rst statement of isConfig is the call to hasA, whose
result represents the conguration option A (see Table 1).
Two data-ow facts are created for variable aand the pos-
sible values ( true orfalse). For each value, a constraint ( ATable 1: Conguration API and value tracking in-
formation for Example (Figure 3)
API Option Value Tracking
com.company.hasA() A [+,-]
com.company.hasB() B [+,-]
com.company.hasC() C [+,-]
com.company.hasD() D N/A
com.company.hasE() E [+,-]
and:Arespectively) is created based on the conguration
option. These constraints are combined with the current
constraint true, hence, Aand:Aare the nal constraints
at this point. Figure 3 shows facts as boxes.
At the following if statement (Line 21), Algorithm 2 is
used to create for both outgoing edges (branch and fall-
through edge) constraints based on the condition (a = true )
and the two facts at this statement. For the sake of simplic-
ity, the resulting constraints ( Afor branch edge and :Afor
fall-through edge) are not shown in the gure. The fact with
value true satises the constraint and is propagated along
the branch edge to Line 22. The fact for the false case is not
propagated along this edge because :A^Ais not satisable.
In Line 22, the call to method hasB() is used to access
the conguration option B. Two new facts for variable notB
are created. In this case, the current constraint is Aand
the newly created facts represent Band:B. The resulting
constraints are A^:B andA^B. Note how, at this crucial
point, the condition value of notB is conditionalized further
by the truth value of a.
At the two possible return points (Lines 24 and 26), the
new fact for the variable zat the call site is derived from
the facts in the called method. At Line 26, for instance, the
constraint for zisfalse is calculated from the three incoming
facts as:A_(A^B)_(A^B), simplied to:A_(A^B).
Back in method start both facts about variable zare
propagated from Line 2 to 3. The ifstatement at Line 3 is
handled the same way as previously described. At Line 5,
the value of zis overwritten by a non-conguration value,
which is why facts about zare not propagated further along.
After the creation of the constraint on option C(Line
7) and its use (Line 8), Line 9 will depend on C. This de-
pendency aects the newly created constraint on option E:
C^Efor the true case and accordingly C^:Eforfalse.
Because start returns no value, the analysis will not propa-
gate any facts beyond the return statement at Line 10. The
only fact at Line 11 has the constraint :C, which is the nal
result for this statement.
The handling of option D is dierent from the previous ex-
ample because value tracking is not used for D. Unlike in the
other cases, there is only one fact created with an undened
value and the opaque constraint D?. Each ifstatement with
a condition dependent on a imprecisely tracked variable will
create the constraint D?for the branching edge and :D?
for the fall-through edge. We can generally not interpret
the constraint:D?and only use it to resolve the constraint
(D?_:D ?=true) even though this equation could be in-
correct.
While constraints on value-tracked variables become more
and more restrictive in case of nested if statements, the con-
straints on Dstay the same. Lines 13 - 15 will both possibly
450public<void<start:A<{
<<boolean<z<=<isConfig:A;
<<if:zA
<<<<method7:A;
<<z<=<false;
<<boolean<e<=<false;
<<boolean<c<=<hasC:A;
<<if:cA
<<<<e<=<hasE:A;
<<<<return;<<<<<<<<
<<int<c<=<hasD:A;<
<<if:c<><7A<
<<<<if:c<<<76A<<
<<<<<<return;<<
<<method8:A;
}
public<boolean<isConfig:A<{<
55<Jimple3like<notation:<<<<<
55<boolean<a<=<hasA:A;
55<if:aA<{
55<<<boolean<notB<=<0hasB:A;
55<<<if:notBA
55<<<<<return<true;
55<}
55<return<false ;
<<return<hasA:A<--<0hasB:A;<<<
}67
68
69
6+
6?
66
67
68
69
76
77
78
79
7+
7?
76
77
78
79
86
87
88
89
8+
8?
86
87
88<z<=<false
e<=<false
c<=<hasC:A
if:cA
e<=<hasE:A
returnc!
C<
c3¬¨C<
c?
¬¨D?<<c!
C<start() isConfig()
A‚àß¬¨B<z!¬¨A ‚à®(A‚àßB)<z3
¬¨A<a3A<a!
<
A‚àßB<notB3
A‚àß¬¨B<notB!
true
false
undefined
A<Variable name 
ConstraintValue
aA‚àß¬¨B<z!¬¨A ‚à®(A‚àßB)<z3
A‚àß¬¨B<a!
A‚àßB<a!A<a!¬¨A<a3
if:notBAA<a!<
<A‚àßBnotB3z<=<isConfig:A68
if:zA 69
method7:A6+
6?
66
67
68
69
76
c<=<hasD:A77
if:c<><7A78
if:c<<<76A79
method8:A7? return 7+a=hasA:A86
if:aA87
notB=0hasB:A88
89
return<true8+return<false86A‚àß¬¨B<notB!
+
-
?C‚àß¬¨E<e3 e!
C‚àßE<
c?
¬¨D?<c?
D?< c?
D?<
c?
D?<Figure 3: Source code and corresponding call-graph annotated with tracked taints
depend on Dbut we can make no assumptions on how they
relate to some form of the conguration option.
The conguration map is created by disjoining the con-
straints of all facts at a statement. For example, the cong-
uration map entry for Line 10 is C_(C^:E )_(C^E) =C.
4. IMPLEMENTATION
We implemented the approach presented in Section 3 in
a tool called Lotrack . The implementation is based on
FlowDroid [3], a tool for taint analysis of Android apps,
which in turn is based on Soot [31] as well as SPLLIFT[7].
Soot is a framework for implementing Java analyses. Input
les, i.e. Java source code or Java or Android bytecode, are
transformed to the intermediate Jimple format. The Jim-
ple format supports analyses by, e.g., transforming complex
expression to a set of simpler expressions and introducing
variables holding provisional results.
The necessary information on relevant API calls and con-
guration options are given in a simple conguration le,
which makes it easy to adapt for most software systems.
We use ordered, reduced Binary Decision Diagrams (BDDs)
for all operations related to constraints. Because of this, our
current implementation is limited to precisely track Boolean
options only. Solving inequality constraints on integer val-
ues, for instance, would require an appropriate constraint
solver.
To make it easier to use the analysis results, Lotrack
displays the extracted constraints within the original Java
code instead of the intermediate Jimple code. The mapping
of Jimple to Java code lines is possible if the compiler isset to include line numbers in the resulting bytecode les,
which is a common debug setting. This enables integrating
Lotrack into IDEs.
The current implementation has limitations which can
both lead to missed constraints as well as an overapprox-
imation of constraints. For instance, dynamic binding of
function calls is currently handled imprecisely. A variability-
aware points-to analysis is needed to overcome this limita-
tion. Overapproximation can also happen due to unknown
implementation of functions (e.g., in native libraries). As we
will show in our evaluation though, Lotrack achieves high
accuracy.
5. EV ALUATION
Toward our goal of providing developers with practical tool
support that can recover a conguration map for a wide
array of maintenance tasks, we have implemented our ap-
proach for Java applications and specically for Android
apps. First, we evaluate the accuracy of our recovered con-
guration maps in terms of precision and recall. Second,
we evaluate the performance of our analysis on a large set
of Android apps. Subsequently, we indirectly demonstrate
usefulness by performing a small empirical study on how
conguration options are used within common Android apps
and how conguration options interact.
Android apps are an interesting subject for tracking con-
guration options, because the Android platform provides
many conguration options, up to the point that the An-
droid platform has gained a reputation for fragmentation
into many dierent hardware and software versions and vari-
451Table 2: Android conguration options (excerpt)
API Conguration Option
android.os.Build$VERSION:int SDK_INT SDK
Configuration.locale LOCALE
Environment.getExternalStorageState() STORAGE
Context.getSystemService("vibrator") VIBRATOR
Context.getSystemService("bluetooth") BLUETOOTH
ants. Android apps use load-time options to determine the
availability of software and hardware functionality at run-
time. Conguration options are accessed through standard
API, which means that we can study many apps with the
same conguration options without the overhead of identify-
ing each system's conguration options separately. Further-
more, there is a large research community that has already
prepared tool chains for analyzing Android apps that we
can build on. Finally, there are a large number of free and
open-source apps available to study.
As conguration options, we selected 50 options from the
Android documentation, including a wide array of dierent
options regarding hardware and software (e.g., availability
of SD card, usable sensors, or framework version). For each
of these options, we identied the API for reading the cong-
uration value. We use precise value tracking for all Boolean
options (13 of all 50 conguration options). In Table 2,
we show an excerpt of the identied options; a full list is
available on the project's web page. Note that the list of
conguration options could be easily changed or extended
for other systems.
5.1 Accuracy
Before we use our tool to study conguration options in
practice, we rst evaluate its accuracy. To obtain an oracle,
we manually created a conguration map for 10 Android
apps. Subsequently, we automatically extracted a congu-
ration map with Lotrack and compared it to the manual
result, yielding measures of precision and recall.
5.1.1 Oracles
We are unaware of any Android apps in which the mapping
from code fragments to conguration constraints has been
explicitly documented so that we could use them as oracle
for our study. Instead, we manually investigated a set of
sample apps to establish ground truth by creating oracles.
As subjects for our evaluation, we randomly selected 10
apps from the FDroid5repository of open-source Android
apps. The selected apps are shown in Table 3, including
some statistics about their size.
To create oracles, we rst documented the process that a
human developer would take to track conguration options
or to create a conguration map. This document includes
the conguration options and corresponding API calls that
should be tracked and a list of possible entry points of the
Android framework.
For every subject app, we asked at least two experts (at
least one author and at least one researcher not involved in
this project) to independently identify and track all cong-
uration options in the Java source code of the app with the
goal of describing all code fragments that are triggered by
5https://f-droid.orgthe conguration options. All experts have multiple years of
experience in Java and the used IDE. The experts discussed
all dierences in their results with the goal of either unani-
mously agreeing on a correct version or clarifying the process
documentation. In fact, we found that the process docu-
mentation was clear enough and that all dierences could
be explained by omissions by one expert, which occurred a
few times in larger applications. In fact, our experience in
creating the oracles anecdotally conrms that creating con-
guration maps is well dened but tedious and error prone
when performed manually. The experts needed up to 30
minutes per app. Using search features of IDEs, the ac-
cess of conguration APIs can be identied easily, but one
quickly loses track of the use of the accessed conguration
values and their extensive impact, e.g., on called methods.
To evaluate accuracy, we compare the conguration map
automatically derived by our tool (from the APK bytecode
le) with the manually derived oracle. We count continuous
lines of Jimple code as basic blocks to prevent a bias towards
uses of conguration options that aect a large number of
lines. We measure recall as blocks of Jimple code that are
correctly mapped to a conguration constraint compared to
blocks of Jimple code that are mapped to some congura-
tion constraint in the oracle. We measure precision as blocks
of Jimple code that are correctly mapped to a conguration
constraint to all blocks of Jimple code that are mapped to
some conguration constraint by our tool. A correct map-
ping requires the exact identication of the aected state-
ments as well as the correct constraint.
5.1.2 Results
In Table 3, we show accuracy of Lotrack 's results: We
reach a precision of 85% and a recall of 83%. There was
no case of incorrectly detected constraints: the constraints
were either correct or missed completely.
In most cases, Lotrack 's result agrees with the oracle. In
19 cases the tool identied constraints for blocks that were
missed by all experts when creating the oracle. Checking
back with our process instructions, we could conrm that the
tool was correct and the experts were wrong. This occurred
especially for exception handling and methods called only
from optional code. We decided to update the oracle with
the tool's results in these cases.
Lotrack missed valid constraint (13 cases) mostly due to
an incomplete call graph. For instance, some callbacks from
the framework were unknown and therefore not handled by
the underlying FlowDroid implementation.
Overapproximation occurred for 11 blocks, where most of
the cases seem to be related to overly approximate points-
to analysis, a well-known problem that all static analyses
share.
452Table 3: Comparison of Lotrack's result and manually created oracles on 10 apps
correct wrong
Name Size (Java LOC) like oracle better than oracle missed overapproximation
Import Contacts 3,570 3 4 0 0
Nectroid 4,724 4 3 0 2
OSChina 23,280 5 4 3 1
Tinfoil for Facebook 1,364 4 2 2 1
AnySoftKeyboard 18,873 2 1 1 0
Mounts2SD 3,618 2 0 1 0
Impeller 7,389 1 0 0 0
KeePass NFC 546 8 0 1 0
Dolphin Emulator 1,812 1 0 1 0
Document Viewer 50,317 15 5 4 7
sum 45 19 13 11
Overall, our results indicate that the analysis is highly
accurate. In a few cases it has even corrected developers
carefully performing the task manually to build the oracle
and overapproximation had only a minor eect.
5.2 Performance
To ensure practicality, we evaluate performance in terms of
analysis time and memory consumption. We report the me-
dian wall-clock time as reported by JUnitBenchmarks6of
ve runs after three discarded warm-up runs, on a Core i7
notebook with 3.3Ghz and 16 GB memory. For memory
consumption, we report the peak memory usage. We auto-
matically performed the analysis on the 10 apps from our
accuracy analysis and 90 additional randomly sampled apps
from the FDroid repository ranging from 17 to 82,000 lines
of Jimple code, listed on the project's web page.
Of the full sample of 100 apps, we were unable to analyze
four apps due to an error reading the Android APK les.
The median time for the analysis is 7.1 seconds; the longest
run-time was 181 seconds. The maximum peak memory us-
age was 2.5 GB.
5.3 ConÔ¨Åguration Options in Android Apps
To exemplify how our analysis can help researchers and
developers understand highly-congurable systems, we per-
formed a small empirical study on congurations in 100 An-
droid apps. We used the same set of subject apps as in our
performance evaluation (excluding the same four apps).
To study the use of conguration options, we execute our
analysis on each app and investigate the conguration map
regarding the following research questions:
1.RQ1: What options are used in practice? To that end,
we observe which conguration options occur in each
app's conguration map.
2.RQ2: How much of the code depends on one or multi-
ple conguration options in practice? Technically, we
use the conguration map to identify which code frag-
ments are mapped to conguration constraints with
one or more conguration options.
3.RQ3: How frequently do conguration options interact
in practice? Technically, we analyze how many code
6http://labs.carrotsearch.com/junit-benchmarks.htmlTable 4: Common conguration options [Top 5]
Option Number of apps using the option
SDK 38
NETWORK 16
STORAGE 12
BLUETOOTH 7
AUDIO 6
Table 5: Distribution of common constraints
Constraint Share
SDK ? 34.4%
NETWORK ? 29.1%
STORAGE ?^SDK ?11.0%
WIFI ? 5.3%
LOCALE ? 4.5%
LOCATION ? 3.1%
Other 12.6%
fragments are mapped to conguration constraints in-
volving more than one option.
Regarding RQ1, the most commonly used conguration
option is SDK, used by 38 apps (Table 4). The option is
used to distinguish between the versions of Android plat-
form. Depending on the version, dierent features of the
framework can be used. Other commonly used options are
Network and Storage options, used by 16 and 12 apps re-
spectively. These options subsume information about avail-
ability and state of network and storage components.
Regarding RQ2, the share of statements (in Jimple no-
tation) with constraints ranges from 0% to 51% with an
median of 0.27%. That is, most apps depend on congu-
ration options, but typically only a small amount of their
implementation is conguration-specic. Only few outliers
contain much conguration-specic code. Large amounts
of conguration-specic code are typically due to classes or
methods being exclusively used in parts of the code guarded
by certain conguration settings. Certain patterns in the
code may lead to an initially surprising high number of state-
ments with constraints, e.g., an early return based on a con-
guration option or the use of exception handling.
453Regarding RQ3, we investigate not only options but spe-
cic constraints to determine to what degree options inter-
act. Table 5 shows the distribution of common constraints as
their share in of all extracted constraints. By far most con-
straints involve only a single option. By far the most state-
ments depend on option SDK without interactions. The
most common interaction involves Storage andSDK. We did
not nd any interactions among Boolean options that would
allow value tracking in our subject systems. Our ndings
that interactions are relatively rare in practice is consistent
with previous results on Java applications [22].
5.4 Threats to Validity
Due to technical limitations of our implementation (see Sec-
tion 4), we only support the use of conguration options
through their normal API though other ways (e.g., using
reection) are possible.
In our evaluation of accuracy, we only used a small sam-
ple to show the correctness of our implementation due to
signicant eort for creating reliable oracles. The results
are consistent, however, giving condence to the accuracy
of our approach on real software systems.
We only looked for conguration options given by the used
framework, whereas more options can be dened by each
app. This could increase the number of statements depend-
ing on conguration options.
6. RELATED WORK
Our approach can be compared to static program slicing [32],
especially forward slicing with the API access as the slicing
criteria. The slice would contain all program statements af-
fected by a conguration options, including all statements
that propagate conguration options. In contrast to slices,
our conguration map only includes statements included or
excluded due to conguration options and control-ow de-
cisions, but not those statements that read, compute with,
or assign conguration-related values. In addition, where
possible, we track option values to report also how a code
fragment depends on a conguration option.
Thin slicing [29] reduces the size of a traditional program
slice by considering only producing statements, reducing ac-
curacy and producing smaller slices. This technique is opti-
mized towards debugging and program understanding tasks,
whereas we select optionally executed statements to support
testing and maintenance of congurable software. Recently,
a combination of thin slicing and bytecode instrumentation
have been used to produce a ranking which conguration
options may most likely inuence a control-ow decision to
assist with conguration errors [33]. This technique helps to
nd relations between concrete program behavior and the
conguration. Lotrack , on the other side, connects infor-
mation about conguration options with the source code.
Ouellet et al. [19] pursued a similar goal of tracking the in-
uence of conguration options with a static analysis. How-
ever, their approach does not track data-ow dependencies
and, thus, cannot identify indirect access of conguration
options.
Reisner et al. [22] used symbolic execution to explore how
conguration options interact in the execution of a set of test
cases. They track conguration options as symbolic values
and found that interactions are relatively rare and restricted
to few options at a time. Their analysis is more accurate
but also much more expensive (several computation-weeksper system), and limited to specic test executions, whereas
we statically analyze all possible executions tracking only
conguration options.
Ribeiro et al. [23] use data-ow analysis to explain how
data ows among code fragments belonging to dierent con-
guration options, to support developers with mechanically
derived documentation, called emergent interfaces. In con-
trast to our work, they know a static conguration map
(from preprocessor usage) and track potential data-ow of
all other variables, whereas our goal is to track load-time
conguration options.
More generally, our goal of nding a conguration map
is related to work on conguration debugging and congu-
ration testing. In conguration debugging, runtime faults
are explained in terms of the current conguration and a
dierent conguration is suggested to users to work around
the problem using various dynamic and static analyses [20].
Conguration testing determines whether conguration op-
tions inuence a test case's execution to determine the small-
est set of congurations that actually needs to be executed [13,
14, 17, 26]. In contrast to conguration debugging and test-
ing, however, we do not reason about runtime behavior be-
yond the inuence of conguration options.
Furthermore, researchers have investigated whether two
patches can interact [8, 25]. Similar to our work they track
the potential inuence of variations (in their case patches,
in ours options) to identify whether multiple changes can in-
teract. After detecting potential interactions they typically
focus testing eorts on those code fragments.
Technically, our value tracking is roughly similar to data-
ow analyses extended with constraint tracking, e.g., used
to build a path-sensitive null-pointer analysis for C which
is unable to handle complex constraints representing inter-
actions [5]. It is inuenced by ideas from variability-aware
analysis/execution for product lines where dierent values
can be tracked under dierent congurations in the same
application [7, 17, 23], but tailored to support load-time
conguration options with small domains.
7. CONCLUSION
We have extended a standard taint analysis to track load-
time conguration options within a program. The analy-
sis produces a conguration map explaining for each code
fragments under which conguration options it may be exe-
cuted. This conguration map can be used for a wide array
of maintenance tasks, such as understanding the impact and
interactions of conguration options. We have implemented
the analysis in our tool Lotrack and demonstrated its use
by studying conguration options in Android apps. Our
evaluation demonstrated a good accuracy (85% recall and
83% precision) as well as a performance good enough for
use on real software systems (7.1 sec on an average app).
Lotrack is not limited to analyzing apps but can be used
for Java applications as well. The general concepts should
extend to most other imperative programming languages.
8. ACKNOWLEDGEMENTS
Lillack's work is by the BMBF grant 01IS12043B, K astner's
work is supported partly by NSF award 1318808, and Bod-
den's work by the BMBF within EC SPRIDE, by the Hes-
sian LOEWE excellence initiative within CASED, and by
the DFG within the project RUNSECURE.
4549. REFERENCES
[1] B. Adams, W. De Meuter, H. Tromp, and A. E.
Hassan. Can we refactor conditional compilation into
aspects? In Proc. Int'l Conf. Aspect-Oriented Software
Development (AOSD) , pages 243{254, New York,
2009. ACM Press.
[2] S. Apel, D. Batory, C. K astner, and G. Saake.
Feature-Oriented Software Product Lines: Concepts
and Implementation . Springer-Verlag,
Berlin/Heidelberg, 2013.
[3] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel,
J. Klein, Y. Le Traon, D. Octeau, and P. McDaniel.
FlowDroid: Precise context, ow, eld,
object-sensitive and lifecycle-aware taint analysis for
Android apps. In Proc. Conf. Programming Language
Design and Implementation (PLDI) , New York, 2014.
ACM Press.
[4] D. L. Atkins, T. Ball, T. L. Graves, and A. Mockus.
Using version control data to evaluate the impact of
software tools: A case study of the Version Editor.
IEEE Trans. Softw. Eng. (TSE) , 28(7):625{637, 2002.
[5] T. Ball and S. K. Rajamani. Bebop: A path-sensitive
interprocedural dataow engine. In Proc. Workshop
on Program Analysis for Software Tools and
Engineering (PASTE) , New York, 2001. ACM Press.
[6] I. Baxter and M. Mehlich. Preprocessor conditional
removal by simple partial evaluation. In Proc. Working
Conf. Reverse Engineering (WCRE), pages 281{290,
Washington, DC, 2001. IEEE Computer Society.
[7] E. Bodden, T. Tol^ edo, M. Ribeiro, C. Brabrand,
P. Borba, and M. Mezini. SPLLIFT: Statically
analyzing software product lines in minutes instead of
years. In Proc. Conf. Programming Language Design
and Implementation (PLDI) , pages 355{364, New
York, 2013. ACM Press.
[8] M. B ohme, B. C. d. S. Oliveira, and A. Roychoudhury.
Regression tests to expose change interaction errors. In
Proc. Europ. Software Engineering Conf./Foundations
of Software Engineering (ESEC/FSE), pages 334{344,
New York, 2013. ACM Press.
[9] J.-M. Favre. Understanding-in-the-large. In Proc. Int'l
Workshop on Program Comprehension , pages 29{38,
Los Alamitos, CA, 1997. IEEE Computer Society.
[10] J. Feigenspan, C. K astner, S. Apel, J. Liebig,
M. Schulze, R. Dachselt, M. Papendieck, T. Leich, and
G. Saake. Do background colors improve program
comprehension in the #ifdef hell? Empirical Software
Engineering, 18(4):699{745, 2013.
[11] D. Jin, X. Qu, M. B. Cohen, and B. Robinson.
Congurations everywhere: Implications for testing
and debugging in practice. In Comp. Int'l Conf.
Software Engineering (ICSE) , pages 215{224, New
York, 2014. ACM Press.
[12] C. K astner, S. Apel, and M. Kuhlemann. A model of
refactoring physically and virtually separated features.
InProc. Int'l Conf. Generative Programming and
Component Engineering (GPCE), pages 157{166, New
York, 2009. ACM Press.
[13] C. H. P. Kim, D. S. Batory, and S. Khurshid. Reducing
combinatorics in testing product lines. In Proc. Int'l
Conf. Aspect-Oriented Software Development (AOSD) ,
pages 57{68, New York, 2011. ACM Press.[14] C. H. P. Kim, D. Marinov, S. Khurshid, D. Batory,
S. Souto, P. Barros, and M. d'Amorim. SPLat:
Lightweight dynamic analysis for reducing
combinatorics in testing congurable systems. In Proc.
Europ. Software Engineering Conf./Foundations of
Software Engineering (ESEC/FSE), pages 257{267,
New York, 2013. ACM Press.
[15] D. Le, E. Walkingshaw, and M. Erwig. #ifdef
conrmed harmful: Promoting understandable
software variation. In Proc. Int'l Symp. Visual
Languages and Human-Centric Computing (VLHCC) ,
pages 143{150, Los Alamitos, CA, 2011. IEEE
Computer Society.
[16] D. Lohmann, F. Scheler, R. Tartler, O. Spinczyk, and
W. Schr oder-Preikschat. A quantitative analysis of
aspects in the eCos kernel. In Proc. Europ. Conf.
Computer Systems (EuroSys) , pages 191{204, New
York, 2006. ACM Press.
[17] H. V. Nguyen, C. K astner, and T. N. Nguyen.
Exploring variability-aware execution for testing
plugin-based web applications. In Proc. Int'l Conf.
Software Engineering (ICSE) , pages 907{918, New
York, 6 2014. ACM Press.
[18] OpenSignal. Android fragmentation visualized.
opensignal.com/reports/fragmentation-2013, 2013.
[19] M. Ouellet, E. Merlo, N. Sozen, and M. Gagnon.
Locating features in dynamically congured avionics
software. In Proc. Int'l Conf. Software Engineering
(ICSE) , pages 1453{1454, Los Alamitos, CA, 2012.
IEEE Computer Society.
[20] A. Rabkin and R. Katz. Precomputing possible
conguration error diagnoses. In Proc. Conf.
Programming Language Design and Implementation
(PLDI) , pages 193{202. IEEE, Los Alamitos, CA,
2011.
[21] A. Rabkin and R. Katz. Static extraction of program
conguration options. In Proc. Int'l Conf. Software
Engineering (ICSE) , pages 131{140, Los Alamitos,
CA, 2011. IEEE Computer Society.
[22] E. Reisner, C. Song, K.-K. Ma, J. S. Foster, and
A. Porter. Using symbolic evaluation to understand
behavior in congurable software systems. In Proc.
Int'l Conf. Software Engineering (ICSE) , pages
445{454, New York, 2010. ACM Press.
[23] M. Ribeiro, P. Borba, and C. K astner. Feature
maintenance with emergent interfaces. In Proc. Int'l
Conf. Software Engineering (ICSE) , pages 989{1000,
New York, 2014. ACM Press.
[24] M. Rosenm uller, N. Siegmund, S. Apel, and G. Saake.
Code generation to support static and dynamic
composition of software product lines. In Proc. Int'l
Conf. Generative Programming and Component
Engineering (GPCE) , pages 3{12, New York, 2008.
ACM Press.
[25] R. Santelices, M. J. Harrold, and A. Orso. Precisely
detecting runtime change interactions for evolving
software. In Proc. Int'l Conf. Software Testing,
Verication, and Validation (ICST) , pages 429{438,
Los Alamitos, CA, 2010. IEEE Computer Society.
[26] J. Shi, M. Cohen, and M. Dwyer. Integration testing
of software product lines using compositional symbolic
execution. In Proc. Int'l Conf. Fundamental
455Approaches to Software Engineering , volume 7212 of
Lecture Notes in Computer Science, pages 270{284,
Berlin/Heidelberg, 2012. Springer-Verlag.
[27] J. Sincero, R. Tartler, D. Lohmann, and
W. Schr oder-Preikschat. Ecient extraction and
analysis of preprocessor-based variability. In Proc.
Int'l Conf. Generative Programming and Component
Engineering (GPCE) , pages 33{42, New York, 2010.
ACM Press.
[28] H. Spencer and G. Collyer. #ifdef considered harmful
or portability experience with C news. In Proc.
USENIX Conf. , pages 185{198, Berkeley, CA, 1992.
USENIX Association.
[29] M. Sridharan, S. J. Fink, and R. Bodik. Thin slicing.
InProc. Int'l Conf. Software Engineering (ICSE) ,
pages 112{122, New York, 2007. ACM.[30] R. Tartler, C. Dietrich, J. Sincero,
W. Schr oder-Preikschat, and D. Lohmann. Static
analysis of variability in system software: The 90,000
#ifdefs issue. In Proc. USENIX Conf. , pages 421{432.
USENIX Association, 2014.
[31] R. Vall ee-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam,
and V. Sundaresan. Soot - a java bytecode
optimization framework. In Proceedings of the 1999
Conference of the Centre for Advanced Studies on
Collaborative Research , CASCON '99, pages 125{135.
IBM Press, 1999.
[32] M. Weiser. Program slicing. IEEE Trans. Softw. Eng.
(TSE) , 10(4):352{357, 1984.
[33] S. Zhang and M. D. Ernst. Which conguration option
should I change? In Proc. Int'l Conf. Software
Engineering (ICSE) , New York, 2014. ACM Press.
456