See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/221553667
Mining API mapping for language migration
Conf erence Paper    in  Proceedings - Int ernational Conf erence on Softw are Engineering  · May 2010
DOI: 10.1145/1806799.1806831  · Sour ce: DBLP
CITATIONS
145READS
330
5 author s, including:
Hao Zhong
Shanghai Jiao T ong Univ ersity
93 PUBLICA TIONS    2,883  CITATIONS    
SEE PROFILE
Tao Xie
Univ ersity of Illinois Urb ana-Champ aign
382 PUBLICA TIONS    17,358  CITATIONS    
SEE PROFILE
Lu Zhang
Peking Univ ersity
230 PUBLICA TIONS    11,502  CITATIONS    
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y Tao Xie  on 01 Dec ember 2014.
The user has r equest ed enhanc ement of the do wnlo aded file.Mining API Mapping for Language Migration
Hao Zhong1;2∗, Suresh Thummalapenta4, Tao Xie4∗, Lu Zhang2;3∗, Qing Wang1
1Laboratory for Internet Software Technologies, Institute of Software, Chinese Academy of Sciences, Beijing, 100190, China
2Key Laboratory of High Conﬁdence Software Technologies (Peking University), Ministry of Education, China
3Institute of Software, School of Electronics Engineering and Computer Science, Peking University, China
4Department of Computer Science, North Carolina State University, Raleigh, NC 27695-8206, USA
zhonghao@itechs.iscas.ac.cn, {sthumma,txie}@ncsu.edu, zhanglu@sei.pku.edu.cn, wq@itechs.iscas.ac.cn
ABSTRACT
To address business requirements and to survive in competing mar-
kets, companies or open source organizations often have to release
different versions of their projects in different languages. Manu-
ally migrating projects from one language to another (such as from
Java to C#) is a tedious and error-prone task. To reduce manual
effort or human errors, tools can be developed for automatic mi-
gration of projects from one language to another. However, these
tools require the knowledge of how Application Programming In-
terfaces (APIs) of one language are mapped to APIs of the other
language, referred to as API mapping relations. In this paper, we
propose a novel approach, called MAM ( Mining APIMapping),
that mines API mapping relations from one language to another us-
ing API client code. MAM accepts a set of projects each with two
versions in two languages and mines API mapping relations be-
tween those two languages based on how APIs are used by the two
versions. These mined API mapping relations assist in migration of
projects from one language to another. We implemented a tool and
conducted two evaluations to show the effectiveness of MAM. The
results show that our tool mines 25,805 unique mapping relations
of APIs between Java and C# with more than 80% accuracy. The
results also show that mined API mapping relations help reduce
54.4% compilation errors and 43.0% defects during migration of
projects with an existing migration tool, called Java2CSharp. The
reduction in compilation errors and defects is due to our new mined
mapping relations that are not available with the existing migration
tool.
Categories and Subject Descriptors
D.2.13 Reusable Software [ Reusable Software ]: Reusable libraries
General Terms
API mapping relation, Language migration
1. INTRODUCTION
To address business requirements and to survive in competing
markets, companies or open source organizations often have to re-
lease different versions of their projects in different languages. For
∗Corresponding authors
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’10, May 2-8 2010, Cape Town, South Africa
Copyright 2010 ACM 978-1-60558-719-6/10/05 ...$10.00.example, many well-known projects such as Lucene1and Word-
Net2provide multiple versions in different languages. For some
open source projects, although their project teams do not ofﬁcially
provide multiple versions, external programmers often create their
versions in different languages. For example, the WordNet team
does not provide a C# version, but Simpson and Crowe developed
a C# version of WordNet.Net3. As described by Jones [7], about
one third of the existing projects have multiple versions in different
languages.
Migrating projects from one language to another language ( e.g.,
from Java to C#) manually is a tedious and error-prone task. In the
literature, there exist approaches [8,18] and tools ( e.g., Java2CSharp4)
that address the problem of language migration partially, since these
approaches and tools expect programmers to describe how Applica-
tion Programming Interfaces (APIs) of one language are mapped to
APIs of another language. Since there are a large number of APIs
provided in different languages, writing mappings manually for all
APIs is tedious and error-prone. As a result, these approaches and
tools support only a subset of APIs for migration. Such a limitation
results in many compilation errors in migrated projects and limits
these approaches’ usage in practice (See Section 5.2 for details).
In this paper, we propose a novel approach, called MAM ( Mining
APIMapping), that automatically mines how APIs of one language
are mapped to APIs of another language. We refer to this mapping
asAPI mapping relations (in short as relations in the rest of the
paper). MAM mines relations based on API usages in client code
rather than based on API implementations for three major reasons.
(1) API libraries often do not come with source ﬁles, especially for
those C# libraries. (2) Relations mined based on API implemen-
tations often have lower conﬁdence than relations mined based on
API usages. The reason is that API implementations have only one
data point for analysis, whereas API usages can have many data
points ( i.e., call sites) for mining. (3) Mapping relations of APIs
are often complex and cannot be mined based on the information
available in the API implementations. First, mapping parameters
of an API method in one language with an API method in the other
language can be complex. For example, consider the following two
API methods in Java and C#:
m1in Java: BigDecimal java.math.BigDecimal.multiply (BigDecimal p1
1)
m2in C#: Decimal System.Decimal.Multiply (Decimal p2
1, Decimal p2
2)
Here, m1has a receiver, say v1
1, of type BigDecimal and has
one parameter p1
1, whereas m2has two parameters p2
1andp2
2. For
these two API methods, v1
1is mapped to p2
1, and p1
1is mapped to
p2
2. Second, an API method of one language can be mapped to more
1http://lucene.apache.org/
2http://wordnet.princeton.edu/
3http://opensource.ebswift.com/WordNet.Net/
4http://j2cstranslator.wiki.sourceforge.netthan one API method in the other language. For example, consider
the following two API methods:
m3in Java: E java.util.LinkedList.removeLast()
m4in C#: void System.Collections.Generic.LinkedList.RemoveLast()
Although the method names of m3andm4are the same, m3in
Java cannot be directly mapped with m4in C#. The reason is that
m3in Java returns the last element removed from the list (repre-
sented as E), whereas m4does not return any element. Therefore,
m3is mapped to two API methods m4andm5(shown below) in
C#. The API method m5returns the last element and should be
invoked before invoking m4.
m5in C#: E System.Collections.Generic.LinkedList.Last()
To deal with the complexity of mining API mapping, we con-
struct a graph, referred to as API transformation graph (ATG), for
aligned methods of the client code in both languages. These ATGs
precisely capture inputs and outputs of API methods, and help mine
complex mapping relations of API methods.
This paper makes the following major contributions:
•The ﬁrst approach, called MAM, that mines API mapping
relations between different languages using API client code.
MAM addresses an important and yet challenging problem
that is not addressed by previous work on language migra-
tion.
•API transformation graphs (ATGs) proposed to capture in-
puts and outputs of API methods, and a technique for build-
ing ATGs and comparing built ATGs for mining API map-
ping relations. Since ATGs describe data dependencies among
inputs and outputs of API methods, MAM is able to mine
complex mapping relations between API methods of the two
languages.
•A tool implemented for MAM and two evaluations on 15
projects that include 18,568 classes and 109,850 methods
with both Java and C# versions. The results show that our
tool mines 25,805 unique mapping relations (with more than
80% accuracy), including 6,695 mapping relations of API
classes with accuracy of 86.7% and 19,110 mapping rela-
tions of API methods with accuracy of 90.0%. The results
also show that the mined relations reduce 54.4% of compi-
lation errors and 43.0% defects during migration of projects
from Java to C# using Java2CSharp, an existing migration
tool.
The rest of this paper is organized as follows. Section 2 presents
deﬁnitions. Section 3 illustrates our approach using an example.
Section 4 presents our approach. Section 5 presents our evalua-
tion results. Section 6 discusses issues of our approach. Section 7
presents related work. Finally, Section 8 concludes.
2. DEFINITIONS
We next present deﬁnitions of terms used in the rest of the paper.
API. An Application Programming Interface (API) [9] is a set of
classes and methods provided by frameworks or libraries.
API library. An API library is a framework or library that pro-
vides reusable API classes and methods.
Client code. Client code is application code that reuses or ex-
tends API classes and methods provided by API libraries.
The deﬁnitions of API library and client code are relative to each
other. For example, Lucene uses classes and methods provided by
J2SE5. Therefore, we consider Lucene as client code and J2SE as
an API library. At the same time, Nutch6uses classes and methods
5http://java.sun.com/j2se/1.5.0/
6http://lucene.apache.org/nutch/provided by Lucene. Therefore, we consider Nutch as client code
and Lucene as an API library. In general, for programmers of client
code, source ﬁles of API libraries may not be available.
Mapping relation. For entities E1(such as API classes and
methods) in a language L1and entities E2in another language L2,
a mapping relation is a triple ⟨E1; E2; b⟩where migrating between
E1andE2maintains the bbehavior. The bbehavior is speciﬁc to
the type of the entities.
Mapping relation of API classes. For data entities whose type
set is C1inL1and data entities whose type set is C2inL2, a map-
ping relation of API classes is a triple ⟨C1; C2; s⟩, where migrating
between C1andC2maintains the sbehavior.
Since we use mapping relations of API classes for migrating data
entities such as variables, parameters, and constants, we require
that two mapped API classes have the same program behavior to
store data, referred to as the sbehavior. For example, the current
time in java.lang.System of Java is stored in System.DateTime
of C#, whereas the environment settings in java.lang.System of
Java is stored in System.Environment of C#. Therefore, the Java
class has a one-to-many mapping relation with two C# classes.
Mapping relation of API methods. For invoked API methods
M1inL1and invoked API methods M2inL2, a mapping relation
of API methods is a triple ⟨M1; M2; t⟩, where migrating between
M1andM2maintains the tbehavior.
Since we use mapping relations of API methods for migrating
API methods that accept inputs to produce desirable outputs, we
require two mapped API methods have the same program behavior
of inputs, outputs, and functionalities. We refer to this behavior
as the tbehavior. For example, Section 1 shows a one-to-many
mapping relation between {m3}of Java and {m4; m5}of C#.
3. EXAMPLE
We next use an example to illustrate challenges in mining API
mapping relations. Figure 1 shows a Java code example and its
migrated C# code. This Java code example accepts a string input
that represents the name of a ﬁle or directory and returns a boolean
value that describes whether the ﬁle or directory exists. To achieve
this functionality, the code example declares a local variable, called
file , of type java.io.File and invokes the exists method.
The method takes the string input and file as its inputs and
produces the desirable boolean value. Here, we consider file (a
receiver) as a special input for the exists method.
To migrate this code example into C#, a language migration
tool needs to know mapping relations of API classes, so that it
can migrate inputs, outputs, and variables into C#. For example,
the migration tool needs to know the mapped API class in C# for
java.io.File to migrate the variable file to C#. In addition,
the migration tool needs to know the mapped API methods, so that
it can add code for invoking proper API methods that take migrated
inputs and variables to produce desirable outputs. For this exam-
ple, the migration tool adds code for invoking the Exists method
and the FullName method to achieve the functionality. Here, we
consider ﬁeld accesses as special types of method invocations.
To mine these mapping relations, MAM uses projects such as
Lucene that have both Java and C# versions. MAM includes three
major steps to mine the preceding two types of mapping relations
of APIs from these projects.
Aligning client code. First, MAM aligns classes and methods
between the two versions of each project. Since two code examples
with the same functionality of two languages may exhibit mapping
relations of APIs, this step aligns classes and methods by their func-
tionalities. To achieve this goal, MAM uses a mapping algorithm
based on similarities in the names of classes and methods deﬁnedJava code :
1 File file = new File("test");
2 Boolean b = file.exists();
Migrated C# code :
3 FileInfo file = new FileInfo("test");
4 Boolean b = System.IO.File.Exists(file.FullName)||
System.IO.Directory.Exists(file.FullName);
Figure 1: Java code and its migrated C# code
IndexFiles.java:
5 public class IndexFiles {
6 static final File INDEX_DIR = new File("index");
7 public static void main(String[] args) {
...
8 if (INDEX_DIR.exists()) {...}
...
9 INDEX_DIR.delete(); } }
IndexFiles.cs:
10 class IndexFiles{
11 internal static readonly System.IO.FileInfo INDEX_DIR
= new System.IO.FileInfo("index");
12 public static void Main(System.String[] args){
...
13 bool tmpBool;
14 if (System.IO.File.Exists(INDEX_DIR.FullName))
15 tmpBool = true;
16 else
17 tmpBool = System.IO.Directory
.Exists(INDEX_DIR.FullName);
... } }
Figure 2: Two versions (Java and C#) of client code
in the two versions of each project.
Aligning client code based on the names of classes and methods
is based on an observation on many existing projects such as rasp7
migrated from one language to another. We observed that while
migrating the rasp project from C# to Java, programmers ﬁrst re-
named source ﬁles from C# to Java and systematically addressed
the compilation errors by replacing C# APIs with Java APIs. Dur-
ing this procedure, the names of classes, methods, ﬁelds of classes,
or local variables in methods often remain the same or similar be-
tween the two versions. Therefore, we use name similarities for
aligning client code of the two versions. For example, MAM aligns
IndexFiles.java with the IndexFiles.cs (shown in Figure 2)
since the names of their classes and methods are similar.
Mining API mapping of classes. Next, MAM mines mapping
relations of API classes by comparing the names of data entities
such as the names of ﬁelds in aligned classes, variables, or parame-
ters in aligned methods. MAM uses name similarities for compar-
ing the names of these entities. For example, MAM identiﬁes the
args parameters in Lines 7 (Java) and 12 (C#) (Figure 2) and maps
the API classes that are the types of the two parameters. Based on
this parameter, MAM maps the API class java.lang.String of
Java to System.String of C#.
Mining API mapping of methods. After mapping API classes
between the two languages, MAM maps API methods. Mapping
API methods is challenging since often an API method of one lan-
guage can be mapped to multiple API methods of the other lan-
guage. Furthermore, mapping relations of API methods should also
describe how parameters and returns are mapped among these API
methods. To address these challenges, MAM constructs a graph,
referred to as API Transformation Graph (ATG), for each aligned
method of the client code in both languages. These ATGs precisely
capture inputs and outputs of API methods, and help mine mapping
relations of API methods. For example, MAM mines a mapping re-
lation from java.io.File.Exists in Java to System.IO.File.
Exists andSystem.IO.Directory.Exists in C#. By a close
look at the API document for these API methods, we can ﬁnd that
the Java method can check whether a ﬁle or directory exists, and
this functionality is fulﬁlled by two C# API methods: System.IO.
7http://sourceforge.net/projects/r-asp/File.Exists for checking whether a ﬁle exists and System.IO.
Directory.Exists for checking whether a directory exists. Sec-
tion 4.2 presents more details on how we mine these mapping rela-
tions of API methods.
4. APPROACH
MAM accepts a set of projects as data sources for mining API
mapping relations between two languages L1andL2. For each
project used as a data source, MAM requires two versions of the
project (one version in L1and the other version in L2). Figure 3
shows the overview of MAM.
4.1 Aligning Client Code
Initially, MAM accepts two versions of a project (one version
inL1and the other version in L2) and aligns classes and methods
deﬁned in the two versions. Aligned classes or methods between
the two versions implement a similar functionality. Since these
two versions implement a similar functionality, APIs used by these
classes or methods could be replaceable.
To align classes and methods deﬁned in the two versions, MAM
uses name similarities between entities (such as class names or
method names) deﬁned by the two versions of the project. In MAM,
we have two different kinds of entity names: entity names deﬁned
by the two versions of the project and entity names of third-party li-
braries used by the two versions of the project. The ﬁrst kind often
comes from the same programmer or the same team, or program-
mers may refer to existing versions when naming entities such as
classes, methods, and variables. Therefore, name similarity of the
ﬁrst kind is often helpful to distinguish functionalities compared to
the second kind. MAM uses the Levenstein measure provided by
SimMetrics8to calculate name similarities.
We next describe how MAM aligns client-code classes (i.e., classes
deﬁned in client code). The ﬁrst step is to ﬁnd candidate class
pairs based on similarities of class names. For two sets of classes
candc′from two versions, MAM returns candidate class pairs M
with name similarity greater than a given threshold, referred to as
SIM_THRESHOLD . Since some projects may have more than one
class with the same or similar name, Mmay contain more than
one pair for a class in a version. To align these classes, MAM uses
package names of these classes to reﬁne Mand returns only one
pair with the maximum similarity for each class. For C#, we refer
to namespace names for package names.
In each aligned class pair, MAM further aligns methods within
the class pair. The alignment algorithm for methods is similar to
the algorithm for classes and also may return more than one candi-
date method pair due to overloading. Here, the algorithm for meth-
ods relies on criteria such as the number of parameters and names
of parameters to reﬁne candidate method pairs. For the example
shown in Section 3, MAM correctly aligns the class IndexFiles
and the method main in Java to the class IndexFiles and the
method Main in C#, respectively, since their names are quite sim-
ilar. Since MAM returns pairs, MAM may sometimes fail to map
some classes or methods (See Section 6 for details).
4.2 Mapping API classes
In the second step, MAM mines mapping relations of API classes.
As mapping relations of API classes are used to migrate variables in
language migration, MAM mines mapping relations of API classes
based on how aligned client code declares variables such as ﬁelds
of aligned classes, and parameters and local variables of aligned
methods. For each aligned class pair ⟨c1; c2⟩, MAM analyzes each
8http://sourceforge.net/projects/simmetrics/2010 /g8822/g88214 
1version /g31
version /g321./g3Client /g3code /g3
alignment class /g3pair /g3and /g3
method /g3pair 
2./g3API/g3class /g3
mapping 
mapping /g3relations /g3 3.APImethod mapping /g3relations /g3
of /g3API/g3methods 
of /g3API/g3classes 3./g3API/g3method /g3
mapping Figure 3: Overview of MAM
ﬁeld pair ⟨f1; f2⟩and considers ⟨f1:type; f 2:type⟩as a relation,
if the similarity between f1:name andf2:name is greater than
SIM_THRESHOLD . Similarly, for each aligned method pair ⟨m1; m2⟩,
MAM analyzes each local variable pair ⟨v1; v2⟩and considers ⟨v1:type;
v2:type⟩as a relation, if the similarity between v1:name andv2:name
is greater than SIM_THRESHOLD . MAM also analyzes each pa-
rameter pair ⟨p1; p2⟩ofm1andm2, and considers ⟨p1:type; p 2:type⟩
as a relation when the similarity between p1:name andp2:name
is greater than SIM_THRESHOLD .
For the example shown in Figure 2, MAM mines the mapping
relation between java.lang.String andSystem.String based
on the mapped parameters of Lines 7 and 12. The mapping rela-
tion of API classes helps migrate the variable declared in Line 1
(Figure 1) to the variable declared in Line 3 (Figure 1).
4.3 Mapping API methods
In the third step, MAM ﬁrst builds a graph for each client code
method, and then compares the two graphs of each pair of client-
code methods for mining mapping relations of API methods.
4.3.1 API Transformation Graph
We propose API Transformation Graphs (ATGs) to capture API
usages of client-code methods. Using ATGs has two main bene-
ﬁts for mining. First, an ATG describes inputs, outputs, and names
of API methods and helps compare API methods from various di-
mensions. Second, an ATG describes data dependencies among
API methods and helps mine mapping relations of multiple API
methods.
An ATG of a client-code method mis a directed graph G⟨Ndata;
Nm; E⟩.Ndata is a set of the ﬁelds Fofm’s declaring class,
local variables Vofm, parameters P1ofm, parameters P2of API
methods invoked by m, and returns Rof all invoked methods. Nm
is a set of all methods (both API methods and client-code methods)
invoked by m.Eis a set of directed edges. An edge d1→d2from
a datum d1∈Ndatato a datum d2∈Ndatadenotes that d2is data-
dependent on d1, referred to as data dependency from d1tod2. In
our representation, a data-dependency edge is shown as a dotted
line. In addition, an edge d1→m1from a datum d1∈Ndata to
a method m1∈Nmdenotes that d1is a parameter or receiver of
m1. Similarly, an edge m1→d1from a method m1∈Nmto a
datum d1∈Ndata denotes that d1is the return of m1.
4.3.2 Building API Transformation Graphs
MAM builds an ATG for each method mdeﬁned in the client
code, called a client-code method. ATG includes information such
as inputs and outputs for each client-code method. In particular, for
each client-code method m, MAM ﬁrst builds subgraphs for its lo-
cal variables, invoked API methods, and ﬁeld accesses. MAM adds
additional edges to the built ATG (and sub-graphs inside the ATG)
and these additional edges represent data dependencies among built
sub-graphs. We use two notations for representing nodes in the
ATG. A rectangle represents a method labeled with the method
name, whereas an ellipse represents a datum such as ﬁelds, local
variables, and parameters. An ellipse is labeled as “ n:t”, where nis the name of the variable, tis its type, and “ null:t ” denotes re-
turn values, which have no names. We use the following rules for
adding nodes and edges to the ATG.
1.For each f∈F∪V∪P1, MAM adds a node to the built ATG.
The reason for considering these variables such as ﬁelds in
the declaring class or local variables in method mused in
client code is that these variables are useful to analyze data
dependencies among API methods. Section 4.3.1 deﬁnes F,
V, and P1.
2.For each API method in the form “ T0T:AM (T1p1; : : : ; T npn)”
invoked by method m, MAM adds a receiver node (of type
T), a return node, and parameter nodes to the built ATG as
shown below. MAM does not add a receiver node for static
API methods. Note that T0∈Randpi∈P2.
2010 /g8821/g88220 
1f.name:f.type 
null:T 0AM p1:T 1…pn:T n receiver: /g3T
0
x.name:x.type y.name:y.type z.name:z.type 
null:T AM x.name:x.type …
x.name:x.type y.name:y.type 
null:T 0 AM x.name:x.type 
p:T AM x.name:x.type 
AM 1x.name:x.type p:T 1 null:T 2
AM 2p:T 2 null:T null:T 0getx receiver:T 1
AM 2p:T 2 null:T 3
AM x.name:x.type receiver:T 
3.For each f∈F∪V, iffis a non-primitive variable of type
T1and a ﬁeld xofT1is accessed as f:x, MAM adds nodes to
the built ATG as shown below. Since Java often uses getters
and setters whereas C# often uses ﬁeld accesses, MAM treats
ﬁeld accesses as special types of method invocations.
2010 /g8821/g88220 
1f.name:f.type 
null:T 0AM p1:T 1…pn:T n receiver: /g3T
0
x.name:x.type y.name:y.type z.name:z.type 
null:T AM x.name:x.type …
x.name:x.type y.name:y.type 
null:T 0 AM x.name:x.type 
p:T AM x.name:x.type 
AM 1x.name:x.type p:T 1 null:T 2
AM 2p:T 2 null:T null:T 0getx receiver:T 1
AM 2p:T 2 null:T 3
AM x.name:x.type receiver:T 
4.For each statement in the form x=y, where x∈F∪V∧y∈
F∪V, MAM adds an edge from ytox. This edge represents
thatxis data-dependent on y.
2010 /g8821/g88220 
1f.name:f.type 
null:T 0AM p1:T 1…pn:T n receiver: /g3T
0
x.name:x.type y.name:y.type z.name:z.type 
null:T AM x.name:x.type …
x.name:x.type y.name:y.type 
null:T 0 AM x.name:x.type 
p:T AM x.name:x.type 
AM 1x.name:x.type p:T 1 null:T 2
AM 2p:T 2 null:T null:T 0getx receiver:T 1
AM 2p:T 2 null:T 3
AM x.name:x.type receiver:T 
5.For each statement in the form x=AM(), where x∈F∪
V, MAM adds an edge from AM toxto indicate that the
return of AM is assigned to x. This edge represents that xis
data-dependent on the return of AM.
2010 /g8821/g88220 
1f.name:f.type 
null:T 0AM p1:T 1…pn:T n receiver: /g3T
0
x.name:x.type y.name:y.type z.name:z.type 
null:T AM x.name:x.type …
x.name:x.type y.name:y.type 
null:T 0 AM x.name:x.type 
p:T AM x.name:x.type 
AM 1x.name:x.type p:T 1 null:T 2
AM 2p:T 2 null:T null:T 0getx receiver:T 1
AM 2p:T 2 null:T 3
AM x.name:x.type receiver:T 
6.For each API method AM(x)invoked by method m, MAM
adds an edge from xto the parameter node of AM. This
edge represents that the parameter of AM is data-dependent
onx.
2010 /g8821/g88220 
1f.name:f.type 
null:T 0AM p1:T 1…pn:T n receiver: /g3T
0
x.name:x.type y.name:y.type z.name:z.type 
null:T AM x.name:x.type …
x.name:x.type y.name:y.type 
null:T 0 AM x.name:x.type 
p:T AM x.name:x.type 
AM 1x.name:x.type p:T 1 null:T 2
AM 2p:T 2 null:T null:T 0getx receiver:T 1
AM 2p:T 2 null:T 3
AM x.name:x.type receiver:T 
7.For each statement in the form m2(m1(x)), MAM adds an
edge from the return node of m1to the parameter node of
m2. This edge represents that the parameter of m2is data-
dependent on the return of m1.
2010 /g8821/g88220 
1f.name:f.type 
null:T 0AM p1:T 1…pn:T n receiver: /g3T
0
x.name:x.type y.name:y.type z.name:z.type 
null:T AM x.name:x.type …
x.name:x.type y.name:y.type 
null:T 0 AM x.name:x.type 
p:T AM x.name:x.type 
AM 1x.name:x.type p:T 1 null:T 2
AM 2p:T 2 null:T null:T 0getx receiver:T 1
AM 2p:T 2 null:T 3
AM x.name:x.type receiver:T 
8.For each statement in the form x:m(), MAM adds an edge
from xtomsince xis the receiver of m. This edge repre-
sents that the receiver of mis data-dependent on x.
2010 /g8821/g88220 
1f.name:f.type 
null:T 0AM p1:T 1…pn:T n receiver: /g3T
0
x.name:x.type y.name:y.type z.name:z.type 
null:T AM x.name:x.type …
x.name:x.type y.name:y.type 
null:T 0 AM x.name:x.type 
p:T AM x.name:x.type 
AM 1x.name:x.type p:T 1 null:T 2
AM 2p:T 2 null:T null:T 0getx receiver:T 1
AM 2p:T 2 null:T 3
AM x.name:x.type receiver:T 
9.For each statement in the form x=y op z op : : : ; op ∈
{+;−;∗; =}, MAM adds edges from y,z, and others to x,
since these variables are connected by binary operations and
the return is assigned to x. The edge denotes the data de-
pendency from y,z, and other variables to x. For simplicity,
MAM ignores opinfo. We discuss this issue in Section 6.2010 /g8822/g88214 
1arg0:System.String “index”:System.String 
“index”:java.lang.String 
Line /g311 Step1 
Step2 
System.IO.FileInfo.getFullName() INDEX_DIR: 
System.IO.FileInfo 
null:System.String null:java.io.File 
j i Fil d l t () arg0:java.lang.String 
receiver /g3:
java.io.File receiver /g3:
java.io.File null: /g3System.IO.FileInfo System.IO.FileInfo.FileInfo() 
java.io.File.File() 
INDEX_DIR:java.io.File 
java io File exists () Line /g36
Line14 Line /g317 System.IO.FileInfo.getFullName() INDEX_DIR: 
System.IO.FileInfo 
null:System.String receiver: 
System.IO.FileInfo receiver: 
System.IO.FileInfo Step2 
System.IO.Directory.Exists() 
null:System.Boolean System.IO.File.Exists() 
(a) (b) null:System.Boolean null:boolean java. io. Fil e. delete() 
null:boolean java .io .File .exists () Line /g38 Line /g39Line /g314 
path:System.String path:System.String 
Step3 
Step3 
Step3 Step4 
Step4 Figure 4: Built ATGs and the main steps of comparing ATGs
2010 /g8821/g88220 
1f.name:f.type 
null:T 0AM p1:T 1…pn:T n receiver: /g3T
0
x.name:x.type y.name:y.type z.name:z.type 
null:T AM x.name:x.type …
x.name:x.type y.name:y.type 
null:T 0 AM x.name:x.type 
p:T AM x.name:x.type 
AM 1x.name:x.type p:T 1 null:T 2
AM 2p:T 2 null:T null:T 0getx receiver:T 1
AM 2p:T 2 null:T 3
AM x.name:x.type receiver:T 
For each client-code method m, MAM applies the preceding
rules for each statement from the beginning to the end of m’s method
body. Within each statement, MAM applies these rules based on
their nesting depth in the abstract syntax tree. For example, for
the statements of the form m2(m1(x)), MAM ﬁrst applies these
rules on m1and then on m2. Our construction is similar to static
slicing [14] with emphasis on API call sites.
Figures 4a and 4b show partial ATGs for the two main methods
ofIndexFiles.cs andIndexFiles.java shown in Figure 2,
respectively. Figure 4 also shows corresponding line numbers of
each sub-graph. MAM applies Rules 2 and 8 for Lines 6 and 9
(Figure 2) to build corresponding sub-graphs in the ATG. MAM
applies Rules 2, 3, and 6 to build corresponding sub-graphs for
Lines 11 and 14 (Figure 2). For simplicity, we do not show the
nodes for the local variable tmpBool in the built ATGs in Figure 4.
4.3.3 Comparing API transformation graphs
The second sub-step compares each pair of built ATGs for min-
ing mapping relations of API methods. Our mapped API methods
should satisfy three criteria. (1) The mapped API methods imple-
ment the same functionality. (2) The mapping relation describes the
relation between parameters and receivers of mapped API methods.
(3) The mapping relation describes the relation between returns of
mapped API methods. The two mapped API methods in two differ-
ent languages satisfying the preceding three criteria are replaceable
in the client code. Therefore, these mapped API methods assist for
migrating client code from one language to another.
Algorithm 1 presents major steps of comparing ATGs for min-
ing mapping relations of API methods. For each pair of aligned
methods mandm′, the findVarPairs function ﬁnds mapped
variables and constants as follows. For two variables vandv′∈
F,V, and P1inmandm′, respectively, findVarPairs maps v
andv′, if the similarity metric value on their names is greater than
SIM_THRESHOLD . For constants in mandm′,findVarPairs
maps those two constants, if they have exactly the same value.
From mapped variables and constants, our algorithm uses the fol-
lowing criteria to ﬁnd mapping relations between the two API meth-
odsjmandsm.
Mapped inputs : The ﬁrst criterion is based on the inputs of jm
andsm. We map jmwithsm, if there is a 1-to-1 mapping between
arg0:System.String “index”:System.String 
“index”:java.lang.String 
Line /g311 Step1 
Step2 
System.IO.FileInfo.getFullName() INDEX_DIR: 
System.IO.FileInfo 
null:System.String null:java.io.File 
j i Fil d l t () arg0:java.lang.String 
receiver /g3:
java.io.File receiver /g3:
java.io.File null: /g3System.IO.FileInfo System.IO.FileInfo.FileInfo() 
java.io.File.File() 
INDEX_DIR:java.io.File 
java io File exists () Line /g36
Line14 Line /g317 System.IO.FileInfo.getFullName() INDEX_DIR: 
System.IO.FileInfo 
null:System.String receiver: 
System.IO.FileInfo receiver: 
System.IO.FileInfo Step2 
System.IO.Directory.Exists() 
null:System.Boolean System.IO.File.Exists() 
(a) (b) null:System.Boolean null:boolean java. io. Fil e. delete() 
null:boolean java .io .File .exists () Line /g38 Line /g39Line /g314 
path:System.String path:System.String 
Step3 
Step3 
Step3 Step4 
Step4 
Figure 4: Built ATGs and the main steps of comparing ATGs 
x.name:x.type y.name:y.type z.name:z.type …
null:T x.name:x.type 
AM 2p:T 2 null:T For each client-code method m, MAM applies the preceding 
rules for each statement from the beginning to the end of m’s method 
body. Within each statement, MAM applies these rules based on 
their nesting depth in the abstract syntax tree. For example, for 
the statements of the form m2(m1(x)) , MAM ﬁrst applies these 
rules on m1and then on m2. Our construction is similar to static 
slicing [14] with emphasis on API call sites. 
Figures 4a and 4b show partial ATGs for the two main methods 
of IndexFiles.cs and IndexFiles.java shown in Figure 2, 
respectively. Figure 4 also shows corresponding line numbers of 
each sub-graph. MAM applies Rules 2 and 8 for Lines 6 and 9 
(Figure 2) to build corresponding sub-graphs in the ATG. MAM 
applies Rules 2, 3, and 6 to build corresponding sub-graphs for 
Lines 11 and 14 (Figure 2). For simplicity, we do not show the 
nodes for the local variable tmpBool in the built ATGs in Figure 4. 
4.3.3 Comparing API transformation graphs 
The second sub-step compares each pair of built ATGs for min- 
ing mapping relations of API methods. Our mapped API methods 
should satisfy three criteria. (1) The mapped API methods imple- 
ment the same functionality. (2) The mapping relation describes the 
relation between parameters and receivers of mapped API methods. 
(3) The mapping relation describes the relation between returns of 
mapped API methods. The two mapped API methods in two differ- 
ent languages satisfying the preceding three criteria are replaceable 
in the client code. Therefore, these mapped API methods assist for 
migrating client code from one language to another. 
Algorithm 1 presents major steps of comparing ATGs for min- 
ing mapping relations of API methods. For each pair of aligned 
methods mand m/prime, the findVarPairs function ﬁnds mapped 
variables and constants as follows. For two variables vand v/prime∈
F,V, and P1in mand m/prime, respectively, findVarPairs maps v
and v/prime, if the similarity metric value on their names is greater than 
SIM_THRESHOLD . For constants in mand m/prime,findVarPairs 
maps those two constants, if they have exactly the same value. 
From mapped variables and constants, our algorithm uses the fol- 
lowing criteria to ﬁnd mapping relations between the two API meth- 
ods jm and sm .
Mapped inputs : The ﬁrst criterion is based on the inputs of jm 
and sm . We map jm with sm , if there is a 1-to-1 mapping between Algorithm 1 : ATG Comparison Algorithm 
Input :Gis the ATG of a client-code method m;G/primeis the ATG of 
m’s aligned method m/prime.
Output :Sis a set of mapping relations for API methods 
begin 
P←findVarPairs (m,m /prime)
for Pair p in P do 
JM←G.nextMethods (p.j )
SM←G/prime.nextMethods (p.s )
∆S=mapping (SM,JM );∆ SM=∅;∆ JM=∅
S=∅;S.addAll (∆ S)
while ∆S/negationslash=∅||∆SM/negationslash=∅||∆JM/negationslash=∅do 
for Method jm in JM do 
if jm.isMapped then 
∆JM=jm.nextMethod () 
JM.delete (jm ); JM.add (∆ JM)
else 
∆JM=merge (jm,jm.nextMethod ()) 
JM.delete (jm ); JM.add (∆ JM)
∆S=mapping (SM,JM ); S.addAll (∆ S)
for Method sm in SM do 
if sm.isMapped then 
∆SM=sm.nextMethod () 
SM.delete (sm ); SM.add (∆ SM)
else 
∆SM=merge (sm,sm.nextMethod ()) 
SM.delete (sm ); SM.add (∆ SM)
∆S=mapping (SM,JM ); S.addAll (∆ S)
end 
inputs of jm and sm . Here, MAM considers both the receiver and 
the parameters as the inputs of an API method. 
Mapped functionalities : The second criterion is based on func- 
tionalities of jm and sm . We consider that jm and sm implement 
the same functionality, if the similarity metric value between the 
name of jm and the name of sm is greater than SIM_THRESHOLD .
Mapped outputs: The third criterion is based on the returns of 
jm and sm . Consider the returns of jm and sm as r1and r2,
respectively. We map jm with sm , if the type of r1is mapped 
with the type of r2in mapping relations of API classes. 
Our algorithm ﬁrst attempts to map the ﬁrst API method jm in 
mwith the ﬁrst API method sm invoked in m/prime. Our algorithm uses inputs of jmandsm. Here, MAM considers both the receiver and
the parameters as the inputs of an API method.
Mapped functionalities : The second criterion is based on func-
tionalities of jmandsm. We consider that jmandsmimplement
the same functionality, if the similarity metric value between the
name of jmand the name of smis greater than SIM_THRESHOLD .
Mapped outputs: The third criterion is based on the returns of
jmandsm. Consider the returns of jmandsmasr1andr2,
respectively. We map jmwith sm, if the type of r1is mapped
with the type of r2in mapping relations of API classes.
Our algorithm ﬁrst attempts to map the ﬁrst API method jmin
mwith the ﬁrst API method sminvoked in m′. Our algorithm uses
thenextMethods function to get these jmandsmAPI methods.
In each iteration, this function merges an API method with its di-rectly next API method to produce a merged API method. If our
algorithm successfully maps jmwithsm, our algorithm moves to
the next available API methods invoked in client-code methods m
andm′. If our algorithm is not able to map jmwithsm, our algo-
rithm merges smandjmwith their next available API methods in
the corresponding ATGs, respectively, and attempts to map merged
API methods. Note that merged API methods are just synthesized
intermediate representations for correlated API methods invoked
in client code, and are used internally by our algorithm to construct
many-to-many mapping relations of API methods. A merged API
method cmis a sequence of API methods Mcombined by inputs
and outputs, so the tbehavior of cmis the combination of M. In
the simplest case, a merged API method could include only one
API method. For L1, consider an API method m1deﬁned in the
class c1and an API method m2deﬁned in c2with the following
signatures:
m1signature: o1c1.m1(inp1
1,inp1
2, ..., inp1
k)
m2signature: o2c2.m2(inp2
1,inp2
2, ..., inp2
l)
Our algorithm merges methods m1andm2to create a new merged
API method mnewif the output o1ofm1is used either as a re-
ceiver or as a parameter for m2(i.e.,o1==c2oro1==inp2
i) in
client code. The signature of the new merged API method mnewis
shown below:
mnew signature: o2mnew(inp1
1,inp1
2, ..., inp1
k,
inp2
1,inp2
2, ..., inp2
l)
For example, our algorithm merges the API methods shown in
Figure 4a to two merged API methods as follows.
cm1:Boolean {FileInfo,getFullName,File.Exist}(String)
cm2:Boolean {FileInfo,getFullName,Directory.Exist}(String)
Similarly, our algorithm merges the API methods shown in Fig-
ure 4b to two merged API methods as follows.
cm3:boolean {File,exist}(String)
cm4:boolean {File,delete}(String)
Our algorithm merges these API methods so that it is able to
mine many-to-many mapping relations of API methods as shown
in Figure 4. After merging API methods, our algorithm uses the
replace function for merging an API method with its next avail-
able API method. For two merged API methods, our algorithm uses
the maximum similarity of method names between jmandsmas a
similarity metric value for mapping their functionalities. With each
iteration, smorjmor the mapping relation (represented as S) in
the algorithm may change. Therefore, we repeat our algorithm till
S,sm, and jmdo not change anymore.
We next explain our algorithm using the illustrative example
shown in Figure 4. The numbers shown in rounded rectangles (such
asStep 1 ) represent the major steps in our algorithm for mining
mapping relations of API methods. We next explain each step in
detail.
Step 1: mapping parameters, ﬁelds, local variables, and con-
stants. Given two ATGs of each method pair ⟨m; m′⟩, this step
maps variables such as parameters, ﬁelds, and local variables by
comparing their names, and maps constants by comparing their val-
ues. As shown in Figure 4, Step 1 maps two constants since both
the constants have the same value “ index ”.
Step 2: mapping inputs of API methods. Step 2 mines mapping
relations of API methods using variable and constant mapping rela-
tions. Initially, this step identiﬁes the ﬁrst API methods in the two
ATGs and tries to map their receiver and parameters of the two API
methods. In our current example, this step maps the constructor
parameter in Line 11 to the constructor parameter in Line 6 since
these parameters are of the mapped types and their associated con-
stants are mapped.
Step 3: mapping outputs of API methods. Step 3 maps returns of
API methods. If MAM is not able to map returns, MAM mergesProject SourceJava version C# version
#C #M #C #M
neodatis SourceForge 1298 9040 464 3983
db4o SourceForge 3047 17449 3051 15430
numerics4j SourceForge 145 973 87 515
fpml SourceForge 143 879 144 1103
PDFClown SourceForge 297 2239 290 1393
OpenFSM SourceForge 35 179 36 140
binaryNotes SourceForge 178 1590 197 1047
lucene Apache 1298 9040 464 3015
logging Apache 196 1572 308 1474
hibernate hibernate 3211 25798 856 2538
rasp SourceForge 320 1819 557 1893
llrp SourceForge 257 3833 222 978
SimMetrics SourceForge 107 581 63 325
aligner SourceForge 41 232 18 50
ﬁt SourceForge 95 461 43 281
Total 11668 75685 6900 34165
Table 1: Subjects
the next API method and then attempts to map returns of merged
API methods. In the example shown in Figure 4, MAM merges
subsequent API methods in the ATG till the Exists API method,
since the returns (shown as Boolean ) can be mapped only after the
Exists API method. Figure 4 shows Step 3 along with the mapped
returns.
Step 4: mapping functionalities. After MAM maps parameters
and returns, this step further maps functionalities of those merged
API methods. Given two merged API methods with mapped pa-
rameters and returns, this step uses the similarity metric value based
on their method names as a criterion for mapping their functionali-
ties. In the preceding example, this step maps the two merged API
methods shown in Figure 4a to the API method of java.io.File.
exists since all three merged API methods include the method
named exists .
After ﬁnding out the mapped pair of API methods as shown in
Figure 4, MAM merges all variables and returns to corresponding
parameters and receivers, and produces the mapping relation of API
methods from java.io.File.Exists in Java to System.IO.
File.Exists andSystem.IO.Directory.Exists in C# (See
Section 5.2 for how mined mapping relations help language migra-
tion).
5. EVALUATIONS
We implemented a tool for MAM and conducted two evaluations
using our tool to show the effectiveness of our approach. In our
evaluations, we address the following two research questions:
1.How effectively can our approach mine various API mapping
relations (Section 5.1)?
2.How much beneﬁt can the mined API mapping relations offer
in aiding language migration (Section 5.2)?
Table 1 shows 15 open source projects with both Java and C#
versions used as subjects in our evaluations. Column “Project” lists
names of subjects. Column “Source” lists sources of these subjects.
These subjects are collected from popular open source hosting sites
such as SourgeForge9, Apache10, and hibernate11. Columns “Java
version” and “C# version” list information for versions in Java and
C#, respectively. In these two columns, sub-columns “ #C” and
“#M” list the number of classes and methods, respectively. As
shown in the table, Java versions are much larger than C# versions
9http://www.sf.net
10http://www.apache.org/
11http://www.hibernate.org/ProjectJava version C# version Aligned
%C %M %C %M #C #M
db4o 87.8% 65.5% 87.6% 74.1% 2674 11433
fpml 93.7% 70.5% 93.5% 56.2% 134 620
PDFClown 86.5% 51.0% 88.6% 82.1% 257 1143
OpenFSM 97.1% 72.1% 94.4% 92.1% 34 129
binaryNotes 98.9% 61.1% 89.3% 92.7% 176 971
neodatis 44.7% 54.8% 100.0% 93.6% 408 3728
numerics4j 57.2% 48.6% 95.4% 89.9% 75 174
lucene 34.9% 26.6% 97.6% 79.8% 453 2406
logging 91.8% 18.1% 58.4% 19.3% 180 285
hibernate 26.4% 1.2% 99.1% 12.6% 848 319
Average 53.2% 30.8% 88.8% 69.2% 524 2121
Table 2: Results of aligning client code
for all subjects. We found two major factors for such a difference.
First, Java versions of some of the projects are more up-to-date.
For example, the latest Java version of numericas4j is 1.3, whereas
the latest C# version is 1.2. Second, for some projects, migration
from Java to C# is still in progress. For example, the website12of
neodatis states that neodatis is a project in Java and is being ported
to C#. This observation further conﬁrms the usefulness of our ap-
proach since our approach aids migrating projects from one lan-
guage to other languages. In total, all these projects include 18,568
classes and 109,850 methods.
We conducted all evaluations on a PC with Intel Qual CPU @
2.83GHz and 1.98G memory running Windows XP. More details of
our evaluation results ( e.g., version numbers of subjects) are avail-
able at http://tinyurl.com/yh98oeo .
5.1 Mining API mapping relations
To investigate the ﬁrst research question, we use the ﬁrst 10
projects listed in Table 1 for mining API mapping relations.
Aligning client code. We ﬁrst present the results of aligning
client code. We use the SIM_THRESHOLD value as 0.6, which is
set based on our initial empirical experience. We choose a relatively
low threshold since it helps our approach to take into account as
much client code as possible.
Table 2 shows our evaluation results. In column “Aligned”, sub-
columns “ # C” and “ # M” list the number of aligned classes and
aligned methods, respectively. For each project of Columns “C#
version” and “Java version”, sub-column “ %C” lists the percent-
age of the aligned classes among total classes of corresponding
versions. Sub-column “ %M” lists the percentage of the aligned
methods among total methods of corresponding versions. Row
“Average” of the two sub-columns lists the percentage of aligned
methods/classes among the total methods/classes as shown in Ta-
ble 1. We ﬁnd that the results of Table 2 fall into three categories.
The ﬁrst category includes db4o ,fpml,PDFClown ,OpenFSM , and
binaryNotes . In this category, our approach achieves relatively
high percentages for both Java and C# versions. For all these ﬁve
projects, “ %M” is relatively smaller than “ %C” because methods
of those unaligned classes cannot be aligned and hence are counted
as unaligned13. The second category includes neodatis ,numerics4j ,
andlucene . In this category, our approach aligns C# versions well
but does not align Java versions so well. We ﬁnd that the migration
ofneodatis andlucene from Java to C# is in progress, and the Java
version of numerics4j is more up to date than its C# version. As
a result, some Java classes or methods do not have corresponding
implementations in C# versions in these projects and hence are not
12http://wiki.neodatis.org/
13Another factor lies in that Java versions usually have many getters
and setters and these getters and setters often do not have corre-
sponding methods in C# versions.ProjectClass Method
Num. Acc. J2SE Num. Acc. J2SE
db4o 3155 83.3% 117 10787 90.0% 297
fpml 199 83.3% 41 508 83.3% 216
PDFClown 539 96.7% 36 514 100.0% 111
OpenFSM 64 86.7% 16 139 73.3% 12
binaryNotes 287 90.0% 31 671 90.0% 55
neodatis 526 96.7% 41 3517 100.0% 539
numerics4j 97 83.3% 2 429 83.3% 29
lucene 718 90.0% 83 2725 90.0% 522
logging 305 73.3% 45 56 90.0% 19
hibernate 1126 66.7% 87 7 13.3% 5
Total 6695 86.7% 344 19110 90.0% 1768
Table 3: Results of mining API mapping relations
aligned. The third category includes logging andhibernate . In this
category, our approach does not align classes and methods of the
two projects well. Although both of the two projects seem to be
migrated from existing Java versions, the programmers of the two
projects often do not refer to names of existing Java versions for
naming entities. For these two projects, the percentages of aligned
classes are relatively high, and the percentages of aligned methods
are relatively low. We ﬁnd that even if our approach aligns a wrong
class pair, our approach does not align methods within the wrong
pair since the method names of a wrong pair are quite different.
These results suggest that we could take method names into ac-
count when aligning classes in future work. For any of these these
projects, our approach does not align all classes or all methods. We
discuss these issues in Section 6.
In summary, as shown by Row “Average”, our approach aligns
classes and methods well on average. The result conﬁrms that many
programmers refer to existing versions of another language to name
entities of a version under development.
Mining API mapping relations. Table 3 shows the results of
mined mapping relations of API classes and methods. Columns
“Class” and “Method” list results of mining mapping relations of
API classes and API methods, respectively. Sub-column “ Num. ”
lists the numbers of mined mapping relations. The numbers of
mined API mapping relations are highly proportional to the sizes of
projects shown in Table 1, except for logging andhibernate . Since
classes and methods of these two projects are not well aligned, our
approach does not mine many API mapping relations from these
two projects. For the remaining projects, our approach mines many
mapping relations of API classes and API methods. Sub-column
“Acc.” lists accuracies of the ﬁrst 30 mined API mapping relations
(i.e., percentages of correct mapping relations). For API mapping
relations mined from each project, we manually inspect the ﬁrst 30
mined API mapping relations by alphabetical order (sorted based
on the names of their corresponding API classes and methods). We
next classify these relations as correct or incorrect based on inspect-
ing API client code and API documents. We ﬁnd that our approach
achieves high accuracies, except for hibernate . Although our ap-
proach does not align logging quite well either, the accuracies of
API mapping relations mined from logging are still relatively high.
To mine API mapping relations of classes, our approach requires
that the names of ﬁelds in aligned classes, variables or parameters
in aligned methods are similar. To mine API mapping relations of
methods, our approach requires that two built ATGs are mapped.
These two requirements are relatively strict. As a result, if the ﬁrst
step does not align client code well, our approach may miss some
API mapping relations but does not introduce many false mapping
relations. In other words, our approach is robust to mine accurate
API mapping relations. Sub-column “ J2SE ” lists the number of
mined API mapping relations between J2SE APIs and .NET frame-PackageClass Method
P R F P R F
java.io 78.6% 73.3% 76.0% 93.1% 66.3% 79.7%
java.lang 82.6% 86.4% 84.5% 93.8% 81.5% 87.6%
java.math 50.0% 50.0% 50.0% 66.7% 66.7% 66.7%
java.net 100.0% 50.0% 75.0% 100.0% 50.0% 75.0%
java.sql 100.0% 66.7% 83.3% 100.0% 66.7% 83.3%
java.text 50.0% 50.0% 50.0% 50.0% 50.0% 50.0%
java.util 56.0% 87.5% 71.8% 65.8% 67.6% 66.7%
junit 100.0% 50.0% 75.0% 92.3% 88.9% 90.6%
orw.w3c 42.9% 75.0% 58.9% 41.2% 77.8% 59.5%
Total 68.8% 77.9% 73.4% 84.6% 73.9% 79.3%
Table 4: Results of comparison with manually written relations
work APIs. We next compare these API mapping relations with
manually written mapping relations.
Row “Total” (in Table 3) lists the total result after we merge all
duplicated mapping relations. In summary, our approach mines a
large number of API mapping relations. These mined API mapping
relations are accurate and associated with various libraries.
Comparing with manually written API mapping relations.
Some migration tools such as Java2CSharp include manually writ-
ten API mapping relations of APIs. For example, one item from
the mapping ﬁles of Java2CSharp is as follows:
package java.math :: System {
class java.math.BigDecimal :: System:Decimal {
method multiply(BigDecimal)
{ pattern = Decimal.Multiply(@0, @1); }
}
}
This item describes the mapping relation between java.math.
BigDecimal of Java and System.Decimal of C#, and also de-
scribes the mapping relation between multiply of Java and Multiply
of C#. For the two API methods, the pattern string describes the
mapping relation of inputs: “ @0” denotes the receiver of the multiply
method, and “ @1” denotes the ﬁrst parameter of the multiply
method. Based on this item, Java2CSharp migrates the following
code snippet from Java to C# as follows:
BigDecimal m = new BigDecimal(1);
BigDecimal n = new BigDecimal(2);
BigDecimal result = m.multiply(n);
->
Decimal m = new Decimal(1);
Decimal n = new Decimal(2);
Decimal result = Decimal.Multiply(m,n);
To compare with manually written mapping ﬁles of Java2CSharp,
we migrate our mined API mapping relations using the following
strategy. First, for each Java class, we migrate its mapping relations
of classes with the highest support values. Here, the support value
of a mapping relation is the frequency that the mapping relation
is mined from the subjects listed in Table 3. Second, for each Java
method, we migrate its mapping relations of methods with the high-
est support values into mapping ﬁles as relations of methods with
pattern strings. For 1-to-1 mapping relations of API methods, this
step is automatic since mined mapping relations describe mapping
relations of corresponding methods and inputs. For a few many-to-
many mapping relations of API methods, this step is manual since
mined mapping relations do not include adequate details.
The mapping ﬁles of Java2CSharp are associated with 13 pack-
ages deﬁned by J2SE and 2 packages deﬁned by JUnit14, and we
treat these mapping ﬁles as a golden standard. We ﬁnd 9 packages
overlapping between the mined mapping ﬁles and the mapping ﬁles
of Java2CSharp. Table 4 shows the comparison results of our mined
API mapping relations within these mapping packages. Columns
“Class” and “Method” list results of comparing API classes and
14http://www.junit.org/ProjectsNo MF MF Ext. MF
E D E D E %E D %D
rasp 973 159 708 123 627 11.4 93 24.4
llrp 2328 122 1540 114 269 82.5 42 63.2
SimM 217 13 12 0 6 50.0 0 0
aligner 368 34 289 0 262 9.3 0 0
ﬁt 177 29 27 0 20 25.9 0 0
Total 4063 491 2576 237 1174 54.4 135 43.0
Table 5: Compilation errors and defects (SimM: SimMetrics)
methods, respectively. Sub-columns “ P”, “R”, and “ F” denote pre-
cision, recall, and F-score. Precision ,Recall , and F-score are de-
ﬁned as follows15:
Precision =true positives
true positives +false positives(1)
Recall =true positives
true positives +false negatives(2)
F−score =2×Precision ×Recall
P recision +Recall(3)
In these preceding formula, true positives represent those API
mapping relations that exist in both the mined API mapping rela-
tions and the golden standard; false positives represent those rela-
tions that exist in the mined API mapping relations but not in the
golden standard; false negatives represent those mapping relations
that exist in the golden standard but not in the mined API map-
ping relations. Row “Total” shows the results when we compare
mapping relations of all the packages listed in Table 4.
From sub-columns “ P” of Table 4, we ﬁnd that our approach
achieves relatively high precisions, but the precisions are lower
than the accuracies shown in Table 3. After inspecting those dif-
ferences, we ﬁnd 25 new correct mapping relations of API classes
from our mined mapping ﬁles. For example, these mined mapping
ﬁles contain a mapping relation between org.w3c.dom.Attr and
System.Xml.XmlAttribute , and the mapping ﬁles of Java2CSharp
do not contain mapping relations for the two API classes. If we
consider these 25 new relations as true positives, the total preci-
sion would be 85.7%. These new mapping relations are useful and
complements the existing mapping ﬁles of the Java2CSharp tool.
From sub-columns “ R” of Table 4, we ﬁnd that our approach
achieves relatively high recalls, but the recalls still have space for
improvements. For example, our approach does not mine the map-
ping relation between java.util.ResourceBundle andSystem.
Resources.ResourceManager as described in the mapping ﬁles
of Java2CSharp. Although this mapping exists in hibernate , our ap-
proach fails to mine the mapping relation since hibernate uses the
two API classes in two classes with quite different names. Our ap-
proach also fails to mine the mapping relations between java.util.
getTime andSystem.DateTime.Ticks correctly, since our ap-
proach cannot infer that 1 millisecond (returned by getTime of
Java) is equal to 1000 ticks (returned by Ticks of C#).
In summary, compared with the mapping ﬁles of Java2CSharp,
our mined mapping ﬁles show reasonably high precisions and re-
calls. The precisions are relatively high since our mined mapping
relations are accurate and include new mapping relations that are
not covered by Java2CSharp. The recalls are also relatively high
since our approach mines many mapping relations although we still
have space for further improvements.
15We ignore those API mapping relations that do not have call sites
in the projects listed in Table 3, since our approach relies on API
call sites to mine mapping relations. By adding more projects using
these APIs to our subjects, our approach can then mine relations of
these APIs.5.2 Aiding Language Migration
To investigate the second research question, we feed the mined
API mapping relations to the Java2CSharp tool and investigate whether
these relations can improve the tool’s effectiveness. We choose this
tool because this tool is a relatively mature project at ILOG16(now
part of IBM) and supports the extension of user-deﬁned mapping
relations of APIs.
We use Java2CSharp to migrate the last ﬁve projects listed in
Table 1 from Java to C#, and Table 5 shows the results. For each
migrated C# project, Column “No MF” lists results without map-
ping ﬁles. Column “MF” lists results with only the mapping ﬁles
of Java2CSharp. Column “Ext. MF” lists results with mapping
ﬁles that combine our mined API mapping relations with the exist-
ing mapping ﬁles of Java2CSharp. Sub-columns “ E” and “ D” list
the number of compilation errors and API related defects found,
respectively. Compilation errors provide an overview for qualities
of migrated projects, but some compilation errors are not related
to APIs. To ﬁnd out the effectiveness of reducing API related de-
fects, we manually inspect some migrated C# ﬁles. In particular,
for each project, we ﬁrst select those overlapping ﬁles between mi-
grated ﬁles and existing C# ﬁles from the C# version of the ﬁve
projects. After that, we manually compare the top ﬁve largest ﬁles
among these overlapping ﬁles with existing C# ﬁles and analyze
those differences for detecting API related defects. For example, a
migrated C# statement of SimMetrics in “No MF” is as follows.
totalDistance = (float)Java.Lang.Math.Sqrt(totalDistance);
This statement contains an API related defect since Java2CSharp
does not migrate the sqrt method of Java to its corresponding API
method of C#. Sub-columns “ %E” and “ %D” list percentages of
improvements over the results of “MF”. On average, mined API
mapping relations help further reduce 54.4% compilation errors
and 43.0% API related defects. Since the ﬁve projects use differ-
ent libraries, compilation errors and defects in migrated projects
are different. In particular, SimMetrics andﬁtuse API classes of
J2SE that are covered by mapping ﬁles. Consequently, the migrated
projects of SimMetrics andﬁthave only a few errors and defects.
The aligner project also mainly uses J2SE, but it uses many API
classes and methods from java.awt for its GUI. The mapping ﬁles
of Java2CSharp do not cover any classes of java.awt , so the mi-
grated project has many compilation errors. Since the existing C#
version of aligner does not have GUI, we do not compare those
defective migrated GUI ﬁles, and we do not ﬁnd any API related
defects in the compared ﬁve ﬁles. The mined ﬁles map java.awt
toSystem.Windows.Forms and thus reduce compilation errors.
However, the result is not signiﬁcant since many classes of the two
packages are still not mapped. For rasp andllrp, they both use
various libraries besides J2SE. Consequently, the migrated projects
have both many errors and API related defects. In particular, llrp
uses log4j17and jdom18, and the mined mapping ﬁles contain map-
ping relations of the two libraries. As a result, the mined API map-
ping relations help reduce compilation errors and API related de-
fects signiﬁcantly. rasp uses some libraries such as Neethi19. Since
the used subjects for mining and thus our mined API mapping re-
lations do not cover these libraries, the migrated project of rasp
contains many compilation errors and API related defects.
In summary, the mined API mapping relations help improve ex-
isting language migration tools such as Java2CSharp. In particular,
the mined API mapping relations help effectively reduce compila-
tion errors and API related defects in the migrated projects.
16http://www.ilog.com/
17http://logging.apache.org/log4j/
18http://www.jdom.org/
19http://ws.apache.org/commons/neethi/5.3 Threats to Validity
The threats to external validity include the representativeness of
the subjects and the used migration tool. Although we applied our
approach on 10 projects for mining API mapping relations and on
additional 5 projects for helping language migration, our approach
is evaluated only on these limited projects. Although Java2CSharp
is the best migration tool within our knowledge, other tools may
perform better than Java2CSharp. This threat could be reduced by
more evaluations on more subjects and more migration tools in fu-
ture work. The threats to internal validity include human factors
for determining correct mined API mapping relations and for de-
termining API related defects in migrated projects. To reduce these
threats, we inspected mined mapping relations and API related de-
fects carefully, and we referred to existing mapping relations and
existing C# ﬁles for determining correct API mapping relations and
API related defects, respectively. The former threat could be fur-
ther reduced by comparing with more existing mapping relations
of APIs as we did for J2SE. The latter threat could be reduced by
running test cases to detect API related defects.
6. DISCUSSION AND FUTURE WORK
We next discuss issues in our approach and describe how we
address these issues in our future work.
Aligning client code. Table 2 shows that our approach could
not align client code in a few cases. The primary reason is that the
functionality associated with a class or a method in one language
version is split among multiple classes or methods in the other lan-
guage version. To address this issue, we plan to align classes and
methods of client code based on their functionalities through devel-
oping or adapting dynamic approaches [6] in future work.
Mining richer API mapping. Table 4 shows that our approach
still has space to improve recalls. Although we use 10 large projects
as subjects, these projects still do not provide sufﬁcient code exam-
ples for mining mapping relations of all APIs in J2SE. Our previous
work [11] shows that it is feasible to use large-scale repositories
available on the web as subjects with the help of code search en-
gines. In future work, we plan to leverage these code search engines
to mine richer API mapping.
Migrating many-to-many mapping relations of API meth-
ods. A mined many-to-many mapping relation of API methods
can have multiple outputs and complex internal data processes. Al-
though our ATGs help identify all API methods, our implementa-
tion is not complete for supporting automatic migration. For ex-
ample, we need to manually add an oroperator for the two out-
puts of the API mapping presented in Section 3 ( i.e., the returns of
System.IO.File.Exists andSystem.IO.Directory.Exists ).
In future work, we plan to enhance our implementation to help au-
tomate migration with many-to-many mapping relations.
Migrating unmapped APIs. Our approach mines API mapping
of methods along with the mappings of their inputs and outputs.
These mappings are useful for migrating API methods of one lan-
guage to another. Sometimes, our approach may not be able to map
inputs and outputs of mapped API methods. If our approach is not
able to map outputs, our approach currently simply ignores those
outputs that are not used in the client code. However, since inputs
cannot be ignored, the migrated code has compilation errors. In
future work, we plan to address this issue by analyzing how two
versions of a project deal with a similar unmapped API problem
for some other code examples.
7. RELATED WORK
Our approach is related to previous work on two areas: language
migration and library migration.Language migration. To reduce manual efforts of language mi-
gration [10], researchers proposed various approaches [4, 8, 15, 16,
18] to automate the process. However, all these approaches focus
on the syntax or structural differences between languages. Deursen
et al. [15] proposed an approach to identify objects in legacy code.
Their approach uses these objects to deal with the differences be-
tween object-oriented and procedural languages. As shown in El-
Ramly et al. [3]’s experience report, existing approaches support
only a subset of APIs for language migration, making the task of
language migration a challenging problem. In contrast to previ-
ous approaches, our approach automatically mines API mapping
between languages to aid language migration, addressing a signif-
icant problem not addressed by the previous approaches and com-
plementing these approaches.
Library migration. With evolution of libraries, some APIs may
become incompatible across library versions. To address this prob-
lem, Henkel and Diwan [5] proposed an approach that captures and
replays API refactoring actions to update the client code. Xing
and Stroulia [17] proposed an approach that recognizes the changes
of APIs by comparing the differences between two versions of li-
braries. Balaban et al. [2] proposed an approach to migrate client
code when mapping relations of libraries are available. In contrast
to these approaches, our approach focuses on mapping relations of
APIs across different languages. In addition, since our approach
uses ATGs to mine API mapping relations, our approach can also
mine mapping relations between API methods with different pa-
rameters or between API methods whose functionalities are split
among several API methods in the other language.
Mining speciﬁcations. Some of our previous approaches [1, 12,
13, 19, 20] focus on mining speciﬁcations. MAM mines API map-
ping relations across different languages for language migration,
whereas the previous approaches mine API properties of a single
language to detect defects or to assist programming.
8. CONCLUSION
Mapping relations of APIs are quite useful for the migration of
projects from one language to another language, and it is difﬁcult
to mine these mapping relations due to various challenges. In this
paper, we propose a novel approach that mines mapping relations
of APIs from existing projects with multiple versions in different
languages. We conducted two evaluations to show the effectiveness
of our approach. The results show that our approach mines many
API mapping relations between Java and C#, and these relations
improve existing language migration tools such as Java2CSharp.
Acknowledgments
Hao Zhong is grateful to his advisor, Prof. Hong Mei, for the in-
sightful advice on research during his PhD program in Peking Uni-
versity. The authors from Chinese Academy of Sciences are spon-
sored by the National Basic Research Program of China (973) No.
2007CB310802, the Hi-Tech Research and Development Plan of
China (863) No. 2007AA010303, and the National Natural Sci-
ence Foundation of China No. 90718042. The authors from NCSU
are supported in part by NSF grant CCF-0725190, NSF grant CCF-
0845272, ARO grant W911NF-08-1-0443, and ARO grant W911NF-
08-1-0105 managed by NCSU Secure Open Systems Initiative (SOSI).
Lu Zhang is sponsored by the National Basic Research Program of
China (973) No. 2009CB320703, the High-Tech Research and De-
velopment Program of China (863) No. 2007AA010301, the Sci-
ence Fund for Creative Research Groups of China No. 60821003,
and the National Science Foundation of China No. 90718016.9. REFERENCES
[1]M. Acharya and T. Xie. Mining API error-handling
speciﬁcations from source code. In Proc. FASE , pages
370–384, 2009.
[2]I. Balaban, F. Tip, and R. Fuhrer. Refactoring support for
class library migration. In Proc. 20th OOPSLA , pages
265–279, 2005.
[3]M. El-Ramly, R. Eltayeb, and H. Alla. An experiment in
automatic conversion of legacy Java programs to C#. In
Proc. AICCSA , pages 1037–1045, 2006.
[4]A. Hassan and R. Holt. A lightweight approach for migrating
Web frameworks. Information and Software Technology ,
47(8):521–532, 2005.
[5]J. Henkel and A. Diwan. CatchUp!: capturing and replaying
refactorings to support API evolution. In Proc. 27th ICSE ,
pages 274–283, 2005.
[6]L. Jiang and Z. Su. Automatic mining of functionally
equivalent code fragments via random testing. In Proc. 18th
ISSTA , pages 81–92, 2009.
[7]T. Jones. Estimating software costs . McGraw-Hill, Inc.
Hightstown, NJ, USA, 1998.
[8]M. Mossienko. Automated COBOL to Java recycling. In
Proc. 7th CSMR , pages 40–50, 2003.
[9]D. Orenstein. QuickStudy: Application Programming
Interface (API). Computerworld , 10, 2000.
[10] H. Samet. Experience with software conversion. Software:
Practice and Experience , 11(10), 1981.
[11] S. Thummalapenta and T. Xie. PARSEWeb: A programmer
assistant for reusing open source code on the web. In Proc.
22nd ASE , pages 204–213, 2007.
[12] S. Thummalapenta and T. Xie. Mining exception-handling
rules as sequence association rules. In Proc. 31th ICSE ,
pages 496–506, May 2009.
[13] S. Thummalapenta, T. Xie, N. Tillmann, P. de Halleux, and
W. Schulte. MSeqGen: Object-oriented unit-test generation
via mining source code. In Proc. 7th ESEC/FSE , pages
193–202, 2009.
[14] F. Tip. A survey of program slicing techniques. Journal of
programming languages , 3(3):121–189, 1995.
[15] A. Van Deursen, T. Kuipers, and A. CWI. Identifying objects
using cluster and concept analysis. In Proc. 21st ICSE , pages
246–255, 1999.
[16] R. Waters. Program translation via abstraction and
reimplementation. IEEE Transactions on Software
Engineering , 14(8):1207–1228, 1988.
[17] Z. Xing and E. Stroulia. API-evolution support with
Diff-CatchUp. IEEE Transactions on Software Engineering ,
33(12):818–836, 2007.
[18] K. Yasumatsu and N. Doi. SPiCE: a system for translating
Smalltalk programs into a C environment. IEEE Transactions
on Software Engineering , 21(11):902–912, 1995.
[19] H. Zhong, T. Xie, L. Zhang, J. Pei, and H. Mei. MAPO:
Mining and recommending API usage patterns. In Proc. the
23rd ECOOP , pages 318–343, 2009.
[20] H. Zhong, L. Zhang, T. Xie, and H. Mei. Inferring resource
speciﬁcations from natural language API documentation. In
Proc. 24th ASE , pages 307–318, November 2009.
View publication stats