Variability Modeling in the Real:
A Perspective from the Operating Systems Domain
Thorsten Berger
University of Leipzig
berger@informatik.uni-leipzig.deSteven She
University of Waterloo
shshe@gsd.uwaterloo.ca
Rafael Lotufo
University of Waterloo
rlotufo@gsd.uwaterloo.caAndrzej W ˛ asowski
IT University of Copenhagen
wasowski@itu.dkKrzysztof Czarnecki
University of Waterloo
kczarnec@gsd.uwaterloo.ca
ABSTRACT
Variability models represent the common and variable fea-
tures of products in a product line. Several variability mod-
eling languages have been proposed in academia and indus-
try; however, little is known about the practical use of such
languages. We study and compare the constructs, seman-
tics, usage and tools of two variability modeling languages,
Kconﬁg and CDL. We provide empirical evidence for the
real-world use of the concepts known from variability mod-
eling research. Since variability models provide basis for
automated tools (feature dependency checkers and product
conﬁgurators), we believe that our ﬁndings will be of interest
to variability modeling language and tool designers.
Categories and Subject Descriptors
D.2.2 [ Software Engineering ]: Design Tools and Tech-
niques; D.2.8 [ Software Engineering ]: Metrics
General Terms
Design, Languages, Measurement
Keywords
Conﬁguration, empirical software engineering, feature mod-
els, product line architectures, variability modeling
1. INTRODUCTION
Variability models represent the common and variable char-
acteristics, or features , of products in a product line. Prod-
uct line developers use them to manage the addition and
evolution of features and their dependencies. Product line
users derive concrete products from variability models. A
range of automated tools support these activities: analyz-
ers verify model consistency or detect dead features[1] and
Permission to make digital or hard copies of all or part of this w ork for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage and th at copies
bear this notice and the full citation on the ﬁrst page. To cop y otherwise, to
republish, to post on servers or to redistribute to lists, re quires prior speciﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00.Debug Level :int Compress DataJournalling Flash File System Misc. Filesystems
Support ZLIB Default Compression
None Size PrioritySupport ZLIB →ZLIB Inﬂate
JFFS2 →CRC∧MTD
0≤Debug Level ≤2
Figure 1: Feature model interpretation of JFFS2
graphical conﬁguration tools ( conﬁgurators for short) sup-
port intelligent choice propagation and model completion[6,
23, 9]. Practical signiﬁcance of variability modeling is re-
ﬂected in the rise of industrial tools such as pure::variants by
Pure Systems GmbH and Gears by Big Lever Software Inc.
Recognizing the interest, the OMG currently seeks proposals
for a Common Variability Language (CVL) standard[14].
Although variability modeling languages have been de-
signed both in academia[10, 5, 3] and industry (pure::var-
iants, Gears), little is known on their practical use. A recent
survey[8] lists many research contributions on feature mod-
els but no empirical studies of industrial practice of feature
modeling. Our work addresses this gap. We study and com-
pare two variability modeling languages and their use: Kcon-
ﬁg [24] and Component Description Language (CDL) [22].
Both were developed as part of open-source operating sys-
tems (OSs). Kconﬁg is used to describe the variability of
the Linux kernel. CDL is part of eCos, a real-time (RT) op-
erating system for embedded devices. Both Linux and eCos
have vast conﬁguration spaces with thousands of features,
which explains their need for variability management.
We compare the constructs, the semantics, and the usage
of Kconﬁg and CDL, while using the well-researched con-
cepts of feature modeling as a reference. Feature models
were originally introduced as part of the Feature-Oriented
Domain Analysis (FODA) [10]. They gained popularity with
product-lines researchers and practitioners alike—mostly due
to the simple and intuitive notation.
Feature models are tree-like menus of conﬁguration op-
tions, or features, with cross-tree constraints among the fea-
tures. Fig.1 presents a sample feature model in the FODA
notation, which illustrates the core concepts shared by many
feature modeling languages. The sample model shows the
73
variability of the Journalling Flash File System —one of the nu-
merous ﬁles systems supported in both Linux and eCos. The
boxes represent features. The hierarchy represents depen-
dencies; for instance, the Default Compression feature allows
a further choice of sub-features that reﬁne it: None,Prior-
ity, or Size. Filled dots mark mandatory features (like De-
bug Level ), which must be selected if the parent is. Hol-
low dots represent optional features, which do not have this
constraint. Further, several features can be related by a
group constraint : the sub-features of Default Compression are
connected by an arc denoting the xorgroup constraint—
exactly one of the three choices has to be selected. Finally,
textual cross-tree constraints are listed to the right.
Our goal is (1)to provide quantitative and qualitative em-
pirical evidence whether the concepts researched in feature
modeling are used in real-world modeling languages and
product lines and, if so, how they are used; (2)to widen the
understanding of the design space for the studied concepts.
We analyzed the two languages andthe models expressed
in them, the Linux kernel model and the eCos model. We
have instrumented the native tools supporting the languages
to build an infrastructure for collecting quantitative data
about the models. Guided by the collected statistics, we
inspected large parts of the models to study actual usage
patterns. In order to also compare the languages directly (as
opposed to via models) we also compared their semantics.
Many semantic diﬀerences turned out to be subtle and not
immediately obvious from the syntax.
With respect to the ﬁrst objective, our study shows that
the core concepts of FODA feature modeling are supported
by both Kconﬁg and CDL and are used in both the Linux
and the eCos models. These include Boolean (optional),
integer and string features, a hierarchy, group constraints,
and cross-tree constraints. Interestingly, both languages and
models use concepts that are beyond FODA and have not
been as widely studied as the core concepts:
•Visibility : Both languages allow controlling the visi-
bility of features in the user interface (UI) of the con-
ﬁguration tool via visibility conditions .
•Computed defaults : They both support computing de-
fault values of features, using values of other features.
•Binding modes : Kconﬁg uses three-valued logics to
specify whether a feature implementation is linked stat-
ically, built for dynamic linking, or absent. FODA uses
much more space, if representing this in Boolean logic.
•Domain-speciﬁc vocabulary : Both languages provide
specialized vocabularies for various kinds of features,
including architectural terms(CDL), such as compo-
nents and interfaces, or terms related to the conﬁgura-
tor UI(Kconﬁg), such as menus. The vocabularies are
speciﬁc to the two projects and likely improve the un-
derstandability of the models within the communities.
For the second objective, the study reveals interesting diﬀer-
ences in how Kconﬁg and CDL provide the above concepts:
•Feature representation : Kconﬁg treats each feature as
a variable, either of Boolean, integer or String type;
CDL, in addition, also supports composite features
that contain both a Boolean component encoding fea-
ture presence and a numeric or string value.
•Feature hierarchy : For both languages the hierarchy
shown to users in a conﬁgurator largely follows the syn-
tactic nesting in the corresponding model; still, both
Figure 2: The eCos Conﬁgtool GUI
languages oﬀer some mechanisms to control the con-
ﬁguration hierarchy separately from syntactic nesting.
•Group constraints : Kconﬁg supports feature grouping
constructs with group cardinalities limited to xor,mu-
tex, andor. CDL is more ﬂexible, allowing integer
intervals as group cardinalities; however, the studied
models only use xor,mutex , and orcardinalities.
In feature modeling (and Kconﬁg), only parents can
impose group constraints on their children; in CDL
features can impose group constraints on any other
features and eCos makes use of it.
•Visibility and computed defaults : Both languages sup-
port two types of conditions on a feature: conditions
deﬁning only conﬁguration dependencies and condi-
tions deﬁning both such dependencies and visibility.
Further, visibility and computed defaults are used to-
gether to provide derived features —automatically com-
puted features, not shown to the user in the UI. De-
rived features are used to simplify constraints or deﬁne
implementation features used in the build system.
•Constraint language : Both languages support arbi-
trary Boolean constraints. Kconﬁg supports also equal-
ity tests on integer and string values. CDL adds vari-
ous arithmetic and string operations, and a few built-in
functions. The models reveal that arithmetic opera-
tions are likely needed for embedded software, as in
eCos; whereas string operations could be dealt with in
the build system outside of the models, as in Linux.
We observed limitations in the conﬁgurators for Kconﬁg and
CDL (see Fig.2 for the UI of the eCos tool). Particularly
the Kconﬁg conﬁgurator lacks reasoning procedures to sup-
port choice propagation. To mitigate this, the Kconﬁg lan-
guage includes an imperative construct for specifying choice
propagation, which delegates this task to model developers;
however, both the Kconﬁg user manual and many devel-
oper comments in the Linux revision history[11] acknowl-
edge that using the construct is very error-prone. The eCos
conﬁgurator is far more intelligent thanks to an inference
engine; however, the engine oﬀers incomplete reasoning and
may propose conﬁguration choices that would not be desir-
able for the user. Interestingly, both conﬁgurators follow a
reconﬁguration paradigm: any conﬁguration task starts with
an initial, possibly default, conﬁguration. However, scalable
reasoning to support conﬂict resolution in reconﬁguration
for rich languages such as Kconﬁg and CDL remains an in-
teresting open problem.
74Kconﬁg and CDL are interesting and highly relevant study
objects. Designed not by researchers, but by developers of
large industrial-strength product lines, they are tailored to
satisfy the needs of these large projects (8M SLOC for Linux
and 0.9M SLOC for eCos). The size of the models (6320
features for Linux and 1244 features for eCos) witnesses the
scalability of the respective modeling approaches.
Since both Linux and eCos are open source, their usage
can be studied openly, and researchers can independently
validate and replicate such studies. Both languages sup-
port quite diﬀerent systems: the kernel of a general purpose
OS (Linux) vs. the entire real-time OS for embedded ap-
plications (eCos). They were developed independently from
each other, and independently from the feature modeling
languages with research origin. Since they share many sim-
ilar concepts, they can conﬁrm the importance of the mod-
eling constructs discussed in the literature.
Although our analysis is limited to variability languages
and models from the OS domain, we believe that other
projects such as RT embedded systems that require static
conﬁguration will likely have similar requirements. Thus,
our ﬁndings are of interest to a growing audience of vari-
ability modeling language and tool designers, especially in
eﬀorts such as the development of OMG’s CVL standard.
2. THE SYSTEMS
The implementation of the Kconﬁg language is distributed
together with the Linux kernel source. Kconﬁg has been
used to specify build-time dependencies of the kernel since
2002. The Linux conﬁgurator reads the Kconﬁg model and
allows the user to select features in a graphical UI closely
resembling the CDL conﬁgurator of Fig.2. It outputs a set
of feature-value mappings that are referenced in Makeﬁles
and in the source code (as preprocessor directives).
The studied version 2.6.32 of the Linux kernel supports
23 hardware architectures. The code base spans 1880 direc-
tories and 701 Kconﬁg ﬁles. Kconﬁg models are distributed
over multiple ﬁles, organized according to the source code hi-
erarchy. Each Kconﬁg speciﬁcation is placed alongside the
related code. An architecture-speciﬁc Kconﬁg ﬁle is used
as a starting point for the speciﬁcation; a simple inclusion
mechanism is used to include other ﬁles.
CDL was designed for the purposes of the conﬁgurable em-
bedded operating system eCos ( ecos.sourceware.org ). Unlike
Kconﬁg, which is a standalone language, CDL is embed-
ded in Tcl, a dynamic and highly extensible scripting lan-
guage. CDL inherits characteristics from Tcl, such as syn-
tactic nesting of blocks, dynamic typing of values, and a rich
set of operators in constraint expressions. CDL’s conﬁgura-
tor (Fig.2) oﬀers an inference engine for conﬂict resolution.
The studied version 3.0 of eCos supports 116 hardware
architectures, called targets , and comprises almost a mil-
lion lines of code. The code base is divided into packages,
each one containing the source code and a set of CDL ﬁles
declaring the conﬁgurability of the package. Each target de-
ﬁnes a set of packages speciﬁc to the architecture. So-called
templates aggregate packages with more cross-architecture
functionality. In the conﬁgurator, a user ﬁrst selects a target
and then one of the templates ; ﬁnally, the user may decide
to load additional packages into the conﬁguration tree.
We scope our analysis to the x86architecture in Linux and
i386PC target with the alltemplate in eCos. We extended theconﬁgurators to export the conﬁguration tree together with
all the information necessary for our analysis.
3. THE LANGUAGES
To compare Kconﬁg and CDL, we reverse-engineered for-
mal semantics speciﬁcation for each of them [18, 2], by an-
alyzing user manuals, testing the tools on examples, and
inspecting tool implementations. This step allowed us to
discover many subtle diﬀerences and connections.
Here we summarize the key similarities and diﬀerences
between the languages using the feature model in Fig.1 as
the running example. Fig.3 shows the same model in Kcon-
ﬁg (to the left) and CDL (to the right). Both snippets are
in fact extracted from the original Linux and eCos models.
They deﬁne the features of the Journalling Flash File Sys-
tem, version 2 ( JFFS2), supported by both OSs. In fact,
eCos’s JFFS2 implementation was ported from Linux. JFFS2
is one of very few of such ports, but it makes an ideal ex-
ample to illustrate the similarities and diﬀerences between
Kconﬁg and CDL. To give a realistic impression of both lan-
guages, we keep the examples close to the originals; in partic-
ular, we retain the original identiﬁers, which diﬀer somewhat
from the names in Fig.1. The few lines introduced purely
for the purpose of the example are underlined; we also left
out unnecessary parts of the corresponding sources. Our dis-
cussion will follow Table 1 as an outline. The table summa-
rizes the similarities and diﬀerences among Kconﬁg, CDL,
and FODA-based feature modeling and provides citations
for concepts that go beyond the original FODA notation.
Features . A feature is a label that can take one or more of
the following roles:
1.User feature : a conﬁguration option that can be set by
the user in a conﬁgurator;
2.Grouping feature : a label grouping a set of other re-
lated features, such as a menu;
3.Implementation feature : a conﬁguration option accessed
by the build system or a generator; and
4.Derived feature : a conﬁguration option automatically
computed via constraints.
Kconﬁg and CDL are domain-speciﬁc languages, providing
specialized keywords for various kinds of features (Tbl.1,
row 1). Feature kinds in Kconﬁg reﬂect their appearance
in the conﬁgurator UI: menus are pure grouping features;
menuconﬁgs are menus that can be enabled and disabled
by clicking; choices are like menus or menuconﬁgs except
that they also impose grouping constraints on their chil-
dren; and conﬁgs are individual options. The menucon-
ﬁgMISC_FILESYSTEMS (Fig.3 Line k-1) corresponds to the
root in Fig.1. It contains the choice ( k-38) corresponding
to the parent feature of the xor-group, Default Compression ,
and eight conﬁgs corresponding to the remaining features of
Fig.1—all enclosed in if(k-4) andendif (k-49).
CDL feature kinds reﬂect types of implementation entities
they map to: packages are top-level containers for features,
mapping to eCos packages. Components are nested features
grouping other features. Options are simple conﬁguration
options (leaves). Several possibly exclusive features can pro-
vide equivalent functionality required elsewhere. Interfaces
are abstractions allowing imposing cardinality constraints
in such cases. Line c-9states that CYGPKG_FS_JFFS2 imple-
ments the interface CYGINT_IO_FILEIO (not shown).
75concept Kconﬁg CDL feature models [10]feature
kindsGrouping menu, menuconﬁg, choice package, component, inte rface feature
Individual conﬁg option featurefeaturerepresentationComposition single value bool. value w/opt. data value bool . value w/opt. attribute
Feature type
Switch bool, tristate bool, booldata (optional)
Data hex, int, string booldata, data integer, string
None (menu) none (mandatory)hierarchySpeciﬁcation syntactic and computed syntactic and reparen ting syntactic
Child-to-parent impl. visibility conﬁguration & visibili ty conﬁguration
Root synthetic synthetic explicitgroup
constraintsMutex [0 ..1] optional Boolean choice interface constraint, int≤1 mutex group [4]
Or [1..∗] mandatory tristate choice interface constraint, int≥1 orgroup [4]
Xor [1 ..1] mandatory Boolean choice interface constraint, int= 1 xorgroup
Interval [ m..n] N/A interface constraint, m≤int≤n [m..n] group [16]feature
constraintsConﬁguration select requires, active if cross-tree constraint
Value restrictions range legalvalues cross-tree constraint
Derived features non-prompt default calculated, interfac e rare [5]
Defaults prompt default default value rare [4]
Visibility conditions prompt condition active if rare [5]
Expression operators &&,||,!,=,!= also inequality, arithm. and str. ops. unspeciﬁed
Binding modes three-value logic N/A rare [4]otherTextual content prompt, help display, description descrip tion
Modularization textual inclusion dynamic loading/unload ing rare [3]
Build symbols one-to-one one-to-many unspeciﬁed
Code mappings no, uses KBuild (m:n) yes (1:n), and build speci ﬁcations N/A
Table 1: Mapping of concepts between Kconﬁg, CDL and feature mod eling
Feature representation . The semantics of a feature model is
a set of conﬁgurations. A conﬁguration speciﬁes the presence
or absence of each feature, and a value for the related integer
or string if the feature is present (when applicable).
Kconﬁg and CDL diﬀer in the ways they represent con-
ﬁgurations (see Tbl.1, row 2). In Kconﬁg, a conﬁguration
assigns a single value to each feature. If Fis the set of all
features in the model, and Val is a set of all possible values,
then a particular conﬁguration σmaps features to values:
σ:F/mapsto→Val and if σ(f) =vthenv∈type-of( f)
Table 1 lists the possible feature types in three categories:
switch ,data, andnone. Switch features appear as a checkbox
in the conﬁgurator. Data features allow the user to input a
value in a text box. Kconﬁg’s menus have no type, which
corresponds to features of type nonein CDL.
The Kconﬁg type boolhas two values,yandn, internally
represented by 2 and 0; 0 denotes feature absence, while 2
means that the feature’s implementation is compiled stati-
cally into the kernel. Tristate resemblesbool, except for
the additionalmvalue, represented internally by1, which de-
notes that the feature should be compiled as a dynamically
loadable module. For example JFFS2_ZLIB (k-32) has type
booland JFFS2_FS (k-6) istristate . Kconﬁg supports two
integer types:int(decimal) andhex(hexadecimal). Both
types also allow an empty value, which is used to encode the
absence of an integer feature. The type string is ambiguous
in this respect: a string feature with the empty value can
be seen as a present feature with that value or an absent
feature; the two cases are indistinguishable.
In CDL, every feature has two values: an enabled state and
adata value . The enabled state is a Boolean and encodes
the presence or absence of the feature; the data value is
dynamically typed and used to store numbers and strings.Thus, a conﬁguration maps features to value pairs:
σ:F/mapsto→ {0,1}×Val and if σ(f)=(e, d) then d∈type-of( f)
CDL refers to the type of a feature as a ﬂavor. The available
ﬂavors map neatly to FODA features as follows:
none /mapsto→Mandatory with no attribute
bool /mapsto→Optional with no attribute
data /mapsto→Mandatory with attribute
booldata /mapsto→Optional with attribute
More precisely, features with the ﬂavors noneanddatacan
be made optional by specifying a conﬁguration constraint
(explained later). Still, an optional feature with ﬂavor none
ordatadiﬀers from its respective boolorbooldata counter-
part: the latter two are shown as user-selectable checkboxes
in the conﬁgurator, whereas the former two have no check-
boxes since their presence is controlled via visibility condi-
tions. Figure 3 includes features assuming numeric values
(CYGOPT_FS_JFFS2_DEBUG ), Bool values ( CYGOPT_JFFS2_-
NAND), or strings ( CYGOPT_FS_JFFS2_COMPRESS_CMODE ).
Hierarchy . Typical modeling languages organize features
into hierarchies (Tbl.1, row3). We distinguish between syn-
tactic and conﬁguration hierarchy. The former is given by
the syntactic nesting of features, such as the nesting of con-
ﬁgs in menus or choices in Kconﬁg, or options and compo-
nents in other components and packages in CDL. The conﬁg-
uration hierarchy is shown to the user in a conﬁgurator (cf.
Fig.2). In the notation of Fig.1, the diagrammatic tree rep-
resents both the intended conﬁguration hierarchy and the
syntactic nesting. In Kconﬁg and CDL the conﬁguration
hierarchy can deviate from the syntactic one.
In Kconﬁg, syntactic nesting within menuconﬁgs and choices
will be reﬂected in the conﬁguration hierarchy; however, con-
ﬁgs can also appear as children of other conﬁgs, even though
76k-1menuconfig MISC_FILESYSTEMS
k-2bool "Miscellaneous filesystems"
k-3
k-4ifMISC_FILESYSTEMS
k-5
k-6config JFFS2_FS
k-7tristate "Journalling Flash File System" ifMTD
k-8select CRC32ifMTD
k-9
k-10
k-11
k-12
k-13config JFFS2_FS_DEBUG
k-14int "JFFS2 Debug level (0=quiet, 2=noisy)"
k-15depends on JFFS2_FS
k-16default0
k-17range02
k-18--- help ---
k-19Debug verbosity of ...
k-20
k-21
k-22config JFFS2_FS_WRITEBUFFER
k-23bool
k-24depends on JFFS2_FS
k-25default HAS_IOMEM
k-26
k-27
k-28config JFFS2_COMPRESS
k-29bool "Advanced compression options for JFFS2"
k-30depends on JFFS2_FS
k-31
k-32config JFFS2_ZLIB
k-33bool "Compress w/zlib..." ifJFFS2_COMPRESS
k-34depends on JFFS2_FS
k-35select ZLIB_INFLATE
k-36defaulty
k-37
k-38choice
k-39prompt"Default compression" ifJFFS2_COMPRESS
k-40default JFFS2_CMODE_PRIORITY
k-41depends on JFFS2_FS
k-42config JFFS2_CMODE_NONE
k-43bool "no compression"
k-44config JFFS2_CMODE_PRIORITY
k-45bool "priority"
k-46config JFFS2_CMODE_SIZE
k-47bool "size (EXPERIMENTAL)"
k-48endchoice
k-49endifc-1cdl_component MISC_FILESYSTEMS {
c-2display"Miscellaneous filesystems"
c-3flavornone
c-4}
c-5
c-6cdl_package CYGPKG_FS_JFFS2 {
c-7display"Journalling Flash File System"
c-8requires CYGPKG_CRC
c-9implements CYGINT_IO_FILEIO
c-10parent MISC_FILESYSTEMS
c-11active_if MTD
c-12
c-13cdl_option CYGOPT_FS_JFFS2_DEBUG {
c-14display "Debug level"
c-15flavor data
c-16default_value 0
c-17legal_values 0 to 2
c-18define CONFIG_JFFS2_FS_DEBUG
c-19description "Debug verbosity of...."
c-20}
c-21
c-22cdl_option CYGOPT_FS_JFFS2_NAND {
c-23flavor bool
c-24define CONFIG_JFFS2_FS_WRITEBUFFER
c-25calculated HAS_IOMEM
c-26}
c-27
c-28cdl_component CYGOPT_FS_JFFS2_COMPRESS {
c-29display "Compress data"
c-30default_value 1
c-31
c-32cdl_option CYGOPT_FS_JFFS2_COMPRESS_ZLIB {
c-33display "Compress data using zlib"
c-34requires CYGPKG_COMPRESS_ZLIB
c-35default_value 1
c-36}
c-37
c-38cdl_option CYGOPT_FS_JFFS2_COMPRESS_CMODE {
c-39display "Set the default compression mode"
c-40flavor data
c-41default_value { "PRIORITY" }
c-42legal_values { "NONE" "PRIORITY" "SIZE" }
c-43}
c-44}
c-45}
c-46
c-47
c-48
c-49
Figure 3: A model excerpt expressed in Kconﬁg (left) and CDL (righ t). Corresponding deﬁnitions are aligned.
they cannot be nested syntactically. For example, a group of
consecutive conﬁgs declaring dependency on the same par-
ent (lines k-13-25), is placed under this parent ( JFFS2_FS ).
In CDL, the conﬁguration hierarchy mostly follows the
syntactic nesting of features unless declared otherwise. Re-
parenting is a mechanism to explicitly specify a parent from
a diﬀerent syntactic scope (see Line c-10). It allows adjust-
ing the developer-oriented structure of the model to make it
more user-oriented before it is shown in the conﬁgurator.
An important property of the conﬁguration hierarchy in
FODA-like languages is that the presence of a child feature
implies the presence of its parent: for each edge from child
cto parent p, we have that σ(c)→σ(p). The conﬁguration
hierarchy in CDL has this property too. In contrast, the
conﬁguration hierarchy in Kconﬁg only enforces the child-
to-parent implications for the visibility conditions. So the
parent of a feature that is visible in the conﬁgurator must be
visible. However, if the parent is not selected, a feature can
still be selected automatically, unlike in other known feature
modeling languages.
Finally, both Kconﬁg and CDL conﬁgurators show a syn-
thetic root —a fresh root node that is not explicitly speciﬁedin the model. This enables working with diagrams that are
forests and not trees like in FODA.
Group constraints . In feature modeling, group constraints
restrict the number of sibling features to be selected if their
parent is selected (Tbl.1, row 4): exactly one child for xor,
at least one for or, and at most one for mutex . Alterna-
tively, the constraint can be given as an interval.
In Kconﬁg, a choice groups a set of features and imposes
a group constraint on them. Choices are either bool or
tristate with a mandatory oroptional modiﬁer ﬂag. If
not speciﬁed otherwise, a choice is bool and mandatory;
thus, the choice in line k-38is anxorgroup. Note that
eCos developers decided to model this group diﬀerently ( c-
38): with adata-ﬂavoured option holding one of three string
values encoding the three compression modes.
CDLinterfaces are a more expressive construct for re-
stricting cardinality of a set of features. The value of an
interface counts the number of its selected implementations
(concrete features). Restricting this value introduces a car-
dinality constraint. In contrast to FODA-like languages,
CDL does not require that all implementing features are
77siblings—the feature activating the group constraint need
not be a parent of the constrained features.
Feature Constraints . CDL and Kconﬁg support three types
of constraints (Tbl.1, row 5): (1) conﬁguration constraints
restrict the legal combinations and values of features; (2) de-
faults provide default values for features, possibly depending
on other features (computed defaults); they can be overrid-
den by the user; (3) visibility conditions control the visibility
of features in the conﬁgurator UI. Features whose visibility
condition is false are not shown or otherwise disabled for user
input. Computed defaults and visibility conditions have not
been widely considered in feature modeling. Unlike conﬁgu-
ration constraints, defaults and visibility conditions have no
direct impact on the conﬁguration semantics. However, they
interact with each other in complex ways that may impact
conﬁguration semantics. We will explain this soon.
A conﬁguration constraint is expressed using select in
Kconﬁg andrequires oractive_if in CDL. For instance,
the constraint Support ZLIB →ZLIB Inﬂate of Fig.1 is expressed
as aselect in line k-35and as arequires inc-34. Both
select andrequires take a condition, say p, and denote
the conﬁguration constraint f→p, where fis the feature in
which they are deﬁned. While pcan only be a feature iden-
tiﬁer forselect (Kconﬁg), it can be an arbitrary Boolean
expression forrequires (CDL), possibly accessing multiple
features via logical, arithmetic, and string operators.
CDL’sactive_if has the same syntactic form and conﬁg-
uration semantics as requires , except that it also enforces
a visibility condition. While the visibility of a child in both
Kconﬁg and CDL is inherited from its parent in the con-
ﬁguration hierarchy, an explicit visibility condition allows
non-parent features to control the visibility, too. For exam-
ple, the visibility of CYGPKG_FS_JFFS2 is controlled by the
parent ( c-10) and another feature, MTD(c-11).
In Kconﬁg, the visibility of a feature is controlled by a
prompt condition. A prompt is a string that follows a type
declaration ( k-7). It is shown to the user when the feature
is visible (the condition is satisﬁed). The condition is spec-
iﬁed after the prompt: here MTDin line k-7. Note that the
select statement in line k-8is also conditioned on the same
condition as the prompt. This pattern of guarding other con-
straints by the prompt condition is frequent in Kconﬁg; thus,
the language provides a syntactic sugar for it. The depends
onstatement adds a condition to the prompt and all other
constraints of a feature. For example, the prompt, default,
and range speciﬁcations of JFFS2_FS_DEBUG are only active
ifJFFS2_FS is selected, as speciﬁed in line k-15. Constraint
expressions in Kconﬁg can use logical operators and equality
tests overbool,tristate , integers and strings.
Range restrictions on integer values are speciﬁed using
range in Kconﬁg andlegal_values in CDL ( k-17,c-17); the
latter can also be used to specify valid string values ( c-42).
Default values are speciﬁed using default in Kconﬁg ( k-16)
anddefault_value in CDL ( c-16). If no default value is
speciﬁed, Kconﬁg assumes 0 for boolandtristate and the
empty string forstring ,int, andhex; in CDL the assumed
defaults for boolean and data values is 0.
In Kconﬁg visibility conditions, defaults, and conﬁgura-
tion constraints interact in intricate ways. If the visibility
condition of a feature is false, its default value speciﬁcation
becomes a conﬁguration constraint because the feature can-
not be accessed by the user to modify the default value. We
refer to such invisible features with calculated values as de-rived features .JFFS_FS_WRITEBUFFER in line k-22is derived
since it has no prompt declared, thus, has a false visibility
condition, but has a default that determines its value. Notice
that this feature was not shown in Fig.1, as FODA notation
does not include syntax for invisible, derived features.
An example of a conditionally derived feature is JFFS2_ZLIB ,
with a stronger visibility condition ( prompt anddepends on )
than its default condition (just depends on ). Thus, when
the feature is not visible, its value is derived using its de-
fault. This happens even if its parent, JFFS2_COMPRESS is
not selected. Consequently, JFFS2_ZLIB does not establish a
child-parent implication, as in feature modeling notations.
CDL clearly separates defaults, which can be overridden
by the user and have no conﬁguration semantics, from de-
rived features, which cannot be changed directly by the user.
Default values are speciﬁed using default_value and only
take eﬀect when the feature is visible. Invisible features can-
not be part of a conﬁguration. Derived features comprise in-
terfaces as well as other feature kinds with the calculated
keyword, which carry an expression that computes their
values (for example line c-25). A feature can either use
default_value orcalculated , but not both. Thus, com-
plex conditionally derived features do not appear in CDL.
A unique feature of Kconﬁg is its ﬁrst-class support for a
three-valued logic. Its main operators are deﬁned as follows:
eval( !e) = 2−eval(e)
eval(e1&&e2) = min(eval( e1),eval(e2))
eval(e1||e2) = max(eval( e1),eval(e2))
The semantics of expressions follows the logic of Kleene,
where modcorresponds to the unknown state. The equality
test is deﬁned only between constants (i.e. tristate ,int,
hexandstring ) and features state. It evaluates to y(2) if
the values match, and to n(0) otherwise.
Textual content . Both Kconﬁg and CDL allow providing
natural language descriptions for features (Tbl.1, row 6):
a short text, called prompt (k-7) anddisplay (c-7), that is
displayed to the user to elicit a conﬁguration decision; and
a longer description, called help(k-19) anddescription (c-
19) that explains the feature in detail.
Modularization . Modularization allows division of speciﬁca-
tions into parts. Kconﬁg and CDL have modularization ca-
pabilities that range from static source inclusion in Kconﬁg
to more complex mechanisms for dynamic loading of pack-
ages during conﬁguration in CDL.
Mapping to code . All conﬁgs and menuconﬁgs in Kconﬁg
correspond directly to symbols controlling the build system,
and to the preprocessor directives of the same name. These
symbols and their values are referenced in presence condi-
tions inside the KBuild system and control the inclusion of
particular source ﬁles from the Linux codebase. Although
these presence conditions can be of any form, they are a
disjunction or conjunction of symbols in most cases.
In CDL, feature names do not always correspond directly
to symbols for the build and the preprocessor. Instead, a
more ﬁne-grained control over symbols is supported, such as
suppressing symbols, deﬁning additional ones, or changing
their formatting. Line c-18shows an example of a feature
deﬁning a build symbol, CONFIG_JFFS2_FS_DEBUG , which
actually appears in the code ported from Linux to eCos.
78Linux #ftrs %ftrs eCos #ftrs %ftrsswitchbool type 2313 37 bool ﬂavor 455 37
tristate type 3692 58 booldata ﬂavor1192 15
6005 95 647 52dataint type 175 2.8
hex type 32 0.5 data ﬂavor 489 39
string type 28 0.4 booldata ﬂavor1192 15
235 3.7 681 55nonemenu 80 1.3 component 108 9
(no type) (ﬂavor none)
Total 6320 100 Total 1244 100
1Repeated as booldata is both switch and data feature type.
Table 2: Representation statistics (cf. Tbl.1 row 2)
Linux #ftrs %ftrs eCos #ftrs %ftrsgroupingmenu 80 1.3 components 265 21
menuconﬁg 175 2.8 packages 56 4.5
255 4 321 26grouping with
constraintsxor 39 0.6 xor 11 0.9
or 3 0.05 or 0 0
mutex 0 0 mutex 1 0.08
42 0.7 12 1
Table 3: Grouping statistics (cf.Tbl.1 row 4)
4. THE MODELS
Let us turn from the languages to their use. We now discuss
themodels of Linux and eCos, expressed in Kconﬁg and
CDL respectively. Again we will use Table 1 as an outline.
Features and grouping . The Linux model has 6320 features;
the eCos model is one ﬁfth of this size. Table 2 shows the
breakdown of features by type. The majority of features
(95%) in the Linux model are bool or tristate, with only 3.7%
having integer or string types. In contrast, more than half of
the features in eCos are data features; this is interesting since
the majority of the examples found in the literature have
few or no such features [19]. Note that we listed booldata
features both as switch and data features to reﬂect their
dual nature; the percentages are given with respect to the
total number of features, which counts them only once. We
established the following reasons for the large percentage of
data features in eCos. First, some feature kinds contain data
values by default, even though they are not intended to be
directly set by the user: interfaces carry the count of the
number of implementing features selected in a conﬁguration
and packages always have the type booldata , with the data
part representing the package version as a string.
There are 130 data or booldata interfaces and 56 booldata
packages in eCos. Further, 24 of dataorbooldata features
represent enumerations, similar to the last option in Fig.3.
Interestingly, they accept 117 legal values in total, which is
the number of additional boolfeatures that we would need
to express these enumerations in Kconﬁg, as shown in Fig.3.
There are also 72 data or booldata features representing
compiler ﬂags, 4 representing linker ﬂags, and 40 holding
names of ﬁles with test code. The remaining 355 data or
booldata features, or 28% of all features, represent diverse
conﬁguration constants such as priorities, buﬀer sizes, and
supported IO ports. Many of these constants are speciﬁcto a RTOS and would either be set dynamically or not be
conﬁgurable in Linux.
As many as a quarter of all eCos features are explicit
grouping features (Table 3), as opposed to Linux’s 4%. This
is unexpected given that the percentages of non-leaf features
in both models are comparable: 16% for Linux and 24% for
eCos (some components in eCos are leaves). The reason is
that Linux also allows nesting of conﬁgs, so conﬁgs can also
take a grouping role. Whereas menus and menuconﬁgs cre-
ate a separate menu structure requiring explicit drill-down
by the user, conﬁg hierarchies are shown by indentation and
are, thus, more lightweight to navigate.
Less than 1% of features in eCos and Linux impose group
constraints on their children. Let us see how group con-
straints are used in practice. The three orgroups in Linux
are motivated by binding time: the orconstraint in the
model allows including multiple alternative features in the
conﬁgured kernel as dynamically loadable modules; only one
of them will be loaded at runtime. The only mutex group
in eCos represents three alternative random number gen-
erators. There are no mutex groups in Linux; a possible
reason is the need to deﬁne a build symbol even when no
group member is selected, cf. JFFS_CMODE_NONE in Fig.3.
Recall that CDL interfaces generalize group cardinality
constraints. This generality is not exploited in practice,
though. We did not ﬁnd a single instance of a group car-
dinality constraint, which is a proper ( m, n)-interval, as op-
posed to intervals with lower bound being 0 or 1 and upper
bound being 1 or *. Moreover, although an interface can
place a group constraint on features that are not siblings, all
interfaces are implemented by sibling features. Still, the in-
terface and the implementing features are usually far apart,
i.e., do not have a common parent and are implemented
across diﬀerent packages. In other words, the group con-
straint is activated (implied) by the parent of the interface,
which is not the parent of the set of constrained features.
This form of a group constraint is more general than what
is found in feature modeling, where the parent of the group
activates the group constraint. Such generalized group con-
straints are used to model the case where a given package
deﬁnes an interface required by its implementation and mul-
tiple other packages provide alternative implementations of
that interface. In total, we had 81 such constraints in eCos.
Hierarchy . Both Linux and eCos have shallow conﬁgura-
tion hierarchies, with an average depth of 4 for Linux and 3
for eCos and maximum depth of 8 and 6 respectively. The
number of features with a given number of children decreases
sharply with the increase of the number of children: the ma-
jority of features are leaves (5316 and 947 respectively); the
second-largest class are single-child parents (452 and 76),
followed by two-child parents (161 and 72). Nevertheless
the maximum number of children (branching) is as much
158 and 29 respectively. This indicates a need to develop
modeling interfaces that support high variation in branch-
ing from very limited to very wide.
Recall that, unlike feature modeling and CDL, Kconﬁg
uses hierarchy to depict a visibility relation instead of a
presence condition, allowing a child feature to be conﬁgured
without its parent. This possibility is indeed exploited in
the Linux model. We veriﬁed with a SAT solver applied to
a derived boolean semantics of the Linux model that 300 fea-
tures do not imply their parents (like JFFS2_ZLIB in Fig.3).
We found 39 (3%) re-parented features in eCos. Most
79Number of referenced featuresNumber of features020040060080010001200
0200400600800
0 5 10 15 20linux ecos
Figure 4: Feature dependencies per feature
re-parentings move packages in the hierarchy; however, 10
options and 2 components were re-parented as well. For ex-
ample, the CYGBLD_GLOBAL_OPTIONS component from CYG-
PKG_HAL_I386_PC package was promoted to the top-level
and, in addition to its syntactic children, two new options
were re-parented under this component. Still, since rela-
tively few features (3% in eCos, 5% in Linux) violate hierar-
chical rules of feature modeling, we observe that practition-
ers ﬁnd hierarchical organization of dependencies natural.
Constraints . The vast majority of features (surprisingly
86% both for Linux and eCos) declare constraints of some
sort (conﬁguration, visibility, or defaults). Fig.4 shows his-
tograms with dependencies per feature, deﬁned as the num-
ber of features referenced in constraints of a given feature. In
Linux, most features refer to 2-4 other features; this range is
much lower in eCos, with typically 1-2 dependencies. Some
features declare a large number of dependencies; the maxi-
mum is 56 in Linux and 21 in eCos.
Table 4 summarizes the use of visibility conditions and
defaults. Both Linux and eCos models use visibility condi-
tions. In Linux, 3% of features have an explicitly speciﬁed
prompt condition (like JFFS2_COMPRESS ), rather than just
viadepends on , and 10% of features in eCos use active_if .
Further, 15% of Linux features specify explicit defaults; eCos
makes heavy use of explicit defaults (69% of features). Only
a small part of features is computed via expressions: 2% for
Linux and 7% for eCos; the remaining defaults are speciﬁed
as literals. Recall that Linux supports conditionally-derived
features, i.e., features that are derived or user-changeable
with a default value, depending on a condition; 3% of Linux
features belong into this category. Finally, 12% (Linux) and
18% (eCos) of features are (unconditionally) derived.
Let us look at some examples of constraints. Linux con-
straints are mostly logical expressions, such as a single fea-
ture or more complex expressions, e.g.,
SMP&& ( X86_32&& ! X86_VOYAGER||X86_64)
Linux constraints often reference integer or string features
using equality tests. In a single case, an integer feature in
Linux uses another feature as a bound in a range constraint.
Many eCos constraints are logical expressions too, but
arithmetic and string operations are not uncommon. For
example,
requires{CYGNUM_FS_FAT_NODE_POOL_SIZE >=
(CYGNUM_FILEIO_NFILE + 2 ) }String concatenation (denoted by “.”) is often used to
produce lists of test or implementation source ﬁles:
calculated{"tests/sprintf1 tests/sprintf2 " .
((FILEIO&&RAM) ? "tests/fileio" : "")}
Other constraints check whether a particular ﬁle name
is included in a list; e.g. requiresis_substr( LIBS, "lib-
target.a") . Such constraints implement code mappings. In
Linux, these are computed in KBuild, outside of the model.
Summary . Let us now summarize the main lessons learnt:
•Core FODA concepts (Tbl.1) are used in both models.
•Boolean features are the basic and most common type;
the constraint language should support arbitrary Bool-
ean constraints, including mutual exclusion.
•Linux uses heavily the three-state logics for controlling
binding mode; more than half features are tristate.
•The languages beneﬁt from being domain-speciﬁc. Do-
main vocabulary increases understandability.
•Integer features are important for embedded systems;
eCos uses arithmetic operators and comparisons.
•Strings are mostly used for ﬁle names; string opera-
tions other than equality tests seem essential if the
build system lacks appropriate support.
•Group constraints dependent on a remote feature im-
prove modularity in the eCos model. Since only basic
cardinalities are used, the interfaces appear overly gen-
eral. It suﬃces to include n-ary xor,orandmutex
operators in the constraint language.
•Separating conﬁguration hierarchy from syntactic hier-
archy helps maintain modularity of the developer view
separately from the user view.
•Like in feature modeling, child-to-parent implications
are enforced in CDL and in most of the Linux model.
•Default values (also computed) are used a lot in prac-
tice, saving the user unnecessary conﬁguration work.
•Visibility control is essential in both models. Two con-
structs are useful: a pure conﬁguration condition (like
requires ) and a combined conﬁguration-and-visibility
condition (likeactive_if ). Conﬁguration indepen-
dent of visibility leads to intricate semantics.
•Derived features are mostly used to perform calcula-
tions that otherwise would be hidden in the build sys-
tem; this way feature dependencies are speciﬁed uni-
formly and explicitly in one model.
5. THE CONFIGURATORS
Kconﬁg and CDL are supported by GUI-based conﬁgu-
rators that both support a conﬁguration process known as
reconﬁguration : The tool is initialized with a conﬁguration
loaded from a ﬁle, or based on default values, which is mod-
iﬁed by the user to reach a desired state. Each of the two
conﬁgurators takes a diﬀerent approach to ensure that the
user reaches a valid conﬁguration. The Kconﬁg conﬁgura-
tor prevents the user from modiﬁcations that violate con-
straints; the eCos conﬁgurator allows such modiﬁcations,
but it detects violations and helps in resolving them.
The Kconﬁg conﬁgurator oﬀers little support for prop-
agating user conﬁguration choices. If the dependencies of
a given feature are not satisﬁed, the tool prohibits select-
ing it. The user has to ﬁnd out which other features need
80Concept Linux eCos
Visibility conditions 200 (3%) 123 (10%)
Explicit defaults 944 (15%) 857 (69%)
Computed (expressions) 104 (2%) 82 (7%)
Literals 632 (10%) 775 (62%)
Conditionally derived 198 (3%) n/a
Unconditionally derived 736 (12%) 218 (18%)
Table 4: Visibility and default statistics
to be reconﬁgured to enable the selection. A rudimentary
propagation support is oﬀered by the select construct; it
enforces a selection of a single feature, when the feature host-
ing the statement is selected. The selection is made without
respecting any constraints. This imperative behaviour can
lead to illegal conﬁgurations and requires Kconﬁg developers
to explicitly specify any transitive dependencies to maintain
consistency. For example, LATENCY_TOP contains selects for
both KALLSYM and KALLSYM_ALL .KALLSYM_ALL depends on
KALLSYM , thus, the sole selection of KALLSYM_ALL would be
suﬃcient if the conﬁgurator used a propagating reasoner. In
fact, the oﬃcial documentation and the Linux kernel com-
mit log contain multiple warnings and complaints about the
error-proneness of using this construct [11]. Still, the Linux
model is full ofselect statements, as this is the only way
to obtain (limited) propagation in the conﬁgurator.
The CDL conﬁgurator is far more intelligent than its Kcon-
ﬁg counterpart. When the user modiﬁes a conﬁguration, the
tool detects all constraint violations and oﬀers the user sup-
port to resolve them via an inference engine.
Every change to the model is wrapped in a transaction
and the conﬁgurator checks for any constraint violation. If
one occurs, the inference engine tries to resolve the conﬂict
by a heuristics-based recursive search algorithm. It builds a
tree of transactions, starting a transaction for each new sub-
conﬂict that arises when testing conﬂict resolutions. The en-
gine estimates the beneﬁt of particular (sub-)conﬂict resolu-
tion, by using the number of required changes and source of
the values being changed, e.g. user, default or inference. If a
sub-resolution is beneﬁcial, it gets committed to the parent
transaction. If one overall solution is found for the top-level
conﬂict, the tool lists necessary changes and requests conﬁr-
mation. Otherwise, the conﬂict requires manual resolution.
We investigated the inference engine’s source code with
respect to correctness andcompleteness . The resolution is
correct , since the proposed resolutions are veriﬁed against
the model constraints. The resolution is incomplete as:
•The inference rules are incomplete. For example, the
engine has rules for handling cardinality constraints on
interfaces of 0 or 1, but not for arbitrary bounds.
•The recursion depth is limited to 3 levels; thus, reason-
ing on transitive requires dependencies is incomplete.
•The engine uses a greedy search, evaluating resolutions
to sub-conﬂicts in separation and pruning all but the
optimal one. This may prune all successful branches.
Although the inference engine is less powerful than general
CSP solvers, it performs very well on the actual eCos model.
The support for mutex andxorgroups is particularly ef-
fective and the resolution of requires dependencies is far
more maintainable than the select statement in Kconﬁg.The main limitation of the CDL conﬁgurator is that if
several resolutions exist, it ﬁnds at most one and possibly
not the desired one. The following comment on the mail-
ing list ( sourceware.org/ml/ecos-discuss/2001-11/msg00161.html )
indicates that developers struggle with this problem:
[...] if CYGPKG_MYPKG_OP1 is active, make sure
that the list of tests for that package is a substring of
CYGDAT_MYPKG_ACTIVE_TESTS . This works 50% of
the time. Problem is the other 50% of the time,
rather than ﬁddling with the substrings, it enables
/ disables my subpackage!
Our ﬁndings underscore the importance of building con-
ﬁgurators based on strong reasoners. Tools employing com-
plete reasoners do exist for package conﬁguration involving
simple use dependencies and version ranges. For example p2
in Eclipse is using a SAT solver. However, scalable reason-
ing to support conﬂict resolution for rich languages such as
Kconﬁg and CDL remains an interesting open problem.
6. THREATS TO V ALIDITY
The main threat to the external validity of our ﬁndings
is that they are based on two languages and two operating
systems only. On the other hand, both are large indepen-
dently developed real-world projects, with diﬀerent objec-
tives: Linux is a general purpose kernel and eCos is an en-
tire specialized RTOS for embedded systems. We believe
that other related domains, especially embedded RT such
as automotive and avionic control software, will share many
characteristics with the studied systems. Further, compar-
ison to other feature modeling languages, shows that both
are representative of the space of feature modeling.
Projects such as Mozilla Firefox or Eclipse IDE are or-
ganized as plug-in architectures, with dynamically loadable
extensions. Such extensions are often listed on marketplace
sites, rather than managed centrally in a closed feature hi-
erarchy. Variability languages for these systems (extension
manifests) only capture use dependencies and required ver-
sion ranges, but no exclusions or other complex constraints.
Our study does not apply to such systems.
We only look at the available artifacts: the languages,
manuals, models, and mailing lists. We have not interviewed
developers and users. We plan to perform such interviews
in future work. We only examined one architecture per OS;
however, both architectures represent large and mature por-
tions of the systems: Linux’s x86architecture covers 61% of
the total of 10415 features and 67% of the total of 8M SLOC;
the eCos’s i386PC covers 44% of the total of 2859 features
and 33% of the total of 0.9M SLOC.
An internal threat is that our statistics are incorrect. To
reduce this risk, we instrumented the native tools to gather
the statistics rather than building our own parsers. We thor-
oughly tested our infrastructure using synthetic test cases
and cross-checked overlapping statistics. We tested our for-
mal semantics speciﬁcation against the native conﬁgurators
and cross-reviewed the speciﬁcations. We used the Boolean
abstraction of the semantics to translate both models into
Boolean formulas and run a SAT solver on them to ﬁnd dead
(always inactive) features. We found 114 dead features in
Linux and 28 in eCos. We manually conﬁrmed that all of
them are indeed dead, either because they depended on fea-
tures from another architecture or they were intentionally
deactivated.
817. RELATED WORK
Semantics of academic variability modeling languages were
studied before[17, 5]. We focus on languages originating
from practice. A survey on the use of feature models [8]
identiﬁed only ﬁve papers reporting practical experience.
References [14,16,17] in[8] are experiences from researchers
applying feature modeling to sample problems from indus-
try. References [31,37] therein are self-reported industry ex-
periences: the ﬁrst on using feature modeling tool prototype
on automotive control software and the second one on man-
aging avionic control software with feature models, but with
few details on the languages and tools used. A notable ex-
ception is the report on the industrial use of Dopler for vari-
ability modeling and product derivation[7]; Sadly, neither
the models nor data are available.
We reported early ﬁndings on the Linux model in a previ-
ous workshop paper [19]; however, the present paper diﬀers
signiﬁcantly. The previous work was to extract a FODA
feature model from Linux and compare it with feature mod-
els from research papers. The present work compares two
languages and models in their full richness (beyond FODA),
including their formal semantics and a diﬀerent set of statis-
tics. The resulting ﬁndings (Sections 2–4) are new. We also
studied the evolution of the Linux model [11], showing that
the number of dependencies has grown proportionally to the
number of features over the last ﬁve years.
Table 1 provides references to research on feature model-
ing concepts. Most of them were present in FODA; however,
computed defaults, visibility conditions, and derived fea-
tures, are marked as rare. State-of-the-art feature modeling
languages such as TVL [3] and pure::variants do not support
them. Computed defaults were proposed by researchers [4],
but not provided by feature modeling languages.
None of the other variability languages supports binding
modes via three-valued logics. Interestingly, Dopler sup-
ports visibility conditions. Although it has been deﬁned as
adecision modeling language [5], it shares many characteris-
tics with feature modeling. The connection between Kcon-
ﬁg and feature modeling was made in[20]. We advance this
work by studying Kconﬁg’s semantics and the Linux model.
Interactive support for resolving variability was ranked
highest in a recent expert survey of requirements for prod-
uct derivation[15]. A variety of reasoners have been used
to create feature model analyzers and conﬁgurators, includ-
ing CSP solvers[23], SAT solvers[21, 13], and BDD pack-
ages[12]. These works tested the reasoners on either small
meaningful models or large automatically generated models;
however, it is not clear how these tools will scale to handle
the Linux and eCos model. This remains future work.
8. CONCLUSION
Our study provides empirical evidence for the use of vari-
ability modeling in real-world large-scale systems. The study
conﬁrms that feature modeling concepts from FODA are
used in practice; however, it shows that more advanced con-
cepts, such as visibility conditions, derived features, and
binding mode are also needed. Our language comparison
showed intricate semantic interactions among the advancedconcepts, deepening our understanding of such languages.
We also identiﬁed signiﬁcant limitations of existing conﬁgur-
ators—a call to arms for future research. We believe our
ﬁndings will be of interest to variability modeling language
and tool designers.
9. REFERENCES
[1] D. Benavides, S. Segura, and A. Ruiz-Cortes. Automated
analysis of feature models 20 years later: a literature revi ew.
Information Systems , 2010.
[2] T. Berger and S. She. Formal semantics of the CDL language .
Technical Note. Available at
www.informatik.uni-leipzig.de/~berger/cdl_semantics .pdf.
[3] Q. Boucher, A. Classen, P. Faber, and P. Heymans. Introdu cing
TVL, a text-based feature modelling language. In VaMoS , 2010.
[4] K. Czarnecki and U. W. Eisenecker. Generative Programming:
Methods, Tools, and Applications . Addison-Wesley, Boston,
MA, 2000.
[5] D. Dhungana, P. Heymans, and R. Rabiser. A formal semanti cs
for decision-oriented variability modeling with DOPLER. In
VaMoS , 2010.
[6] D. Dhungana, R. Rabiser, P. Gr ¨unbacher, and T. Neumayer.
Integrated tool support for software product line engineer ing.
InASE, 2007.
[7] P. Gr ¨unbacher, R. Rabiser, D. Dhungana, and M. Lehofer.
Model-based customization and deployment of Eclipse-based
tools: Industrial experiences. In ASE, 2009.
[8] A. Hubaux, A. Classen, M. Mendon¸ ca, and P. Heymans. A
preliminary review on the application of feature diagrams i n
practice. In VaMoS , 2010.
[9] M. Janota, G. Botterweck, R. Grigore, and J. P. M. Silva. How
to complete an interactive conﬁguration process? In SOFSEM ,
2010.
[10] K. Kang, S. Cohen, J. Hess, W. Nowak, and S. Peterson.
Feature-oriented domain analysis (FODA) feasibility stud y.
Tech.Rep.CMU /SEI-90-TR-21, 1990.
[11] R. Lotufo, S. She, T. Berger, K. Czarnecki, and A. W֒asowski.
Evolution of the Linux kernel variability model. In SPLC , 2010.
[12] M. Mendonca, A. W֒asowski, K. Czarnecki, and D. D. Cowan.
Eﬃcient compilation techniques for large scale feature mode ls.
InGPCE , 2008.
[13] M. Mendon¸ ca, A. W֒asowski, and K. Czarnecki. SAT-based
analysis of feature models is easy. In SPLC , 2009.
[14] Object Management Group. Common variability language
(CVL) RFP. Document ad/2009-12-03 , 2009.
[15] R. Rabiser, P. Gr ¨unbacher, and D. Dhungana. Requirements for
product derivation support: Results
from a systematic literature review and an expert survey.
Information and Software Technology , 52(3), 2010.
[16] M. Riebisch, K. B ¨ollert, D. Streitferdt, and I. Philippow.
Extending feature diagrams with UML multiplicities.
[17] P.-Y. Schobbens, P. Heymans, J.-C. Trigaux, and Y. Bonte mps.
Generic semantics of feature diagrams. Comput. Netw. ,
51(2):456–479, 2007.
[18] S. She and T. Berger. Formal semantics of the Kconﬁg
language. Technical Note. Available at
eng.uwaterloo.ca/~shshe/kconﬁg_semantics.pdf .
[19] S. She, R. Lotufo, T. Berger, A. W֒asowski, and K. Czarnecki.
The variability model of the Linux kernel. In VaMoS , 2010.
[20] J. Sincero and W. Schr ¨oder-Preikschat. The Linux kernel
conﬁgurator as a feature modeling tool. In SPLC-ASPL , 2008.
[21] T. Th ¨um, D. Batory, and C. K ¨astner. Reasoning about edits to
feature models. In ICSE, 2009.
[22] B. Veer and J. Dallaway. The eCos component writer’s guid e.
Seen Mar. 2010 at
ecos.sourceware.org/ecos/docs-latest/cdl-guide/cdl- guide.html .
[23] J. White, D. Schmidt, D. Benavides, P. Trinidad, and
A. Cort´ es. Automated diagnosis of product-line conﬁgurat ion
errors in feature models. In SPLC , 2008.
[24] R. Zippel and contributors. kconﬁg-language.txt . avail-
able in the kernel tree at kernel.org , seen 2009-11/23.
82