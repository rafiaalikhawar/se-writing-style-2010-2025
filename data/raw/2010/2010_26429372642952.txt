Abstraction-aware Verifying Compiler for Yet Another MDD
Naoyasu Ubayashi Di Ai Peiyuan Li Y u Ning Li
Shintaro Hosoai Y asutaka Kamei
Kyushu University
Fukuoka, Japan
ubayashi@acm.org, {aidi@posl.ait, lipeiyuan@posl.ait, liyuning@posl.ait,
hosoai@qito, kamei@ait}.kyushu-u.ac.jp
ABSTRACT
This paper rethinks both modularity and compilation in
the light of abstraction between design and implementation.We propose a new compilation approach called abstraction-
aware verifying compiler , in which abstraction is the target
of compilation. Both a design model and its code are in-putted as the ﬁrst-class software modules to the compiler.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veriﬁ-
cation
Keywords
Architecture; Interface; Abstraction
1. INTRODUCTION
Abstraction has been an important issue in software engi-
neering [5]. This paper rethinks both modularity and com-pilation in the light of abstraction between design and im-plementation. Although it is preferable to ﬁrmly separatedesign from its implementation, this separation is not easybecause an abstraction level—How much should be a designmodel more abstract than its code? —tends to change during
the progress of software development. In general, an impor-tant decision on software architecture is made at the designphase and a decision on the detailed program structure con-cerning API usages, variables, and methods is made at thecoding phase. However, this distinction is relative and vague
in many cases. For example, the importance of some classes
and methods might be recognized at the coding phase even ifthey should be extracted at the design phase, because devel-opers cannot always grasp all of the design concerns. It is notavoidable to ﬂuidly go back and forth between design andimplementation. It is error-prone to manually check whether
or not a design model is a faithful abstraction structure of
its code whenever a design model or code is modiﬁed.
To deal with this problem, we propose a new compila-
tion approach called abstraction-aware verifying compiler ,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provide d that copies are not made or distributed
for proﬁt or commercial advantage and tha t copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permissionand/or a fee. Request permissions from permissions@acm.org.
ASE’14, September 15-19, 2014, V asteras, Sweden.
Copyright 2014 ACM 978-1- 4503-3013-8/14/ 09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2642952.in which abstraction is the target of compilation. This com-
piler receives a design model and its code as an input, ver-
iﬁes whether or not the design model is an abstraction of
the code, and generates the object code. Our compiler isbased on a modularity vision whose concept is “Not only
program code but also a design model is a module” [8]. We
consider that the abstraction level of a design model may ﬂu-idly change as a result of reconsidering the balance betweendesign and its implementation. However, this type of sep-
aration of concerns is not well supported by current MDD
(Model-Driven Development) that takes a transformationapproach such as QVT (Queries/Views/Transformations) or
ATL (ATLAS Transformation Language) to generate code
from a design model. On the other hand, our approach–YetAnother MDD–is a type-based module integration to bridgedesign and code preserving an abstraction level.
This paper is structured as follows. Our modularity vision
is introduced in Section 2. The implementation of our com-
piler is shown in Section 3. An abstraction reﬁnement pro-
cess using this compiler is shown in Section 4. The overviewofiArch, an IDE (Integrated Development Environment) for
supporting our idea, is illustrated in Section 5. Concludingremarks are provided in Section 6.
2. NEW MODULARITY VISION FOR MDD
In this section, we propose a new modularity vision in
which a UML design model such as a class diagram and asequence diagram is regarded as a design module.
2.1 Type-based Traceability
In this paper, we extend Archface [7], an architectural in-
terface mechanism previously proposed by us, to represent
abstraction explicitly. The new Archface can deal with ab-
straction by introducing the notion of architectural pointsshared between design and code. These points termed arch-
points have to be modeled as design points in a UML model
and be implemented as program points in its code. Class
declarations, method deﬁnitions, and events such as mes-
sage send are called design points. Archface can play a role
as a design interface for a design model and as a programinterface for a program. The traceability between design
and code can be veriﬁed by an Archface type system. By
regarding a design model as a module, the type system can
be applied to the model. Design and code are synchronizedwhen both a design model and its code conform to the same
Archface . Abstraction is taken into account in this syn-
chronization, because an abstraction level is determined by
selecting shared architectural points declared in Archface .
557
Table 1: Design Points, Program Points, Archpoints
Diagram Design point Program point Archpoint (Pointcut)
(UML2 metamodel) (Java)
Class diagram Class class a
 class ( class )
(UML) Operation method a
 method ( method )
Property field a
 field ( field )
Sequence diagram Message method call a
 mcall ( call)*
(UML) MessageEnd (sendEvent )
Message method exec a
 mexec ( execution )*
MessageEnd (receiveEvent )
Interaction (control flow) ( cflow )* **
Constraint Target Predicate
Structure inheritance class inherit
association class assoc
membership class, method, field memberof
Behavior sequence message send/receive sequence
call, execution
iteration sequence iteration
branch sequence alt
*) AspectJ pointcut, **) Used with call orexecution pointcut
Table 1 shows the types of design points, program points,
and archpoints. These points can be mapped each other.
The idea of archpoints and their selection originates in AOP(Aspect-Oriented Programming) [4] notions such as join pointsand pointcuts. We focus on archpoints embedded in class
diagrams and sequence diagrams, because structural and be-
havioral aspects of software architecture can be basicallyrepresented using these diagrams.
The followings are the formal deﬁnitions of a design model,
program code, and Archface .
Deﬁnition 1 (Design): A design model is a tuple DM=<D ,D C> ,
where D is a set of partial ordered design points and DC is a
set of constraints among them. The type of a design point is arelated UML metamodel element. A constraint is represented
using predicates shown in Table 1.
Deﬁnition 2 (Code): A program is a tuple PG=<P , P C> ,w h e r e
P is a set of partial ordered program points and PC is a set ofconstraints among them. The type of a program point and a
constraint among these points are shown in Table 1.
Deﬁnition 3 (Archface ):Archface is an interface for enforcing con-
straints on a design model and its program. This interface isa tuple AF=<A , A C> , where A is a set of partial ordered
archpoints and AC is a set of constraints among them. Thetype of an archpoint and a constraint among these points areshown in Table 1.
2.2 Archface, Design and Code Descriptions
We illustrate design and program modules using the Ob-
server pattern as an example. Figure 1 shows the relation
between these modules and Archface .
2.2.1 Archface
Archface , which supports component-and-connector archi-
tecture, consists of two kinds of interface, component and
connector . The former exposes archpoints and the latter
deﬁnes how to coordinate archpoints. Pointcut & advice
in AspectJ is used as a mechanism for exposing archpoints
(pointcut) and coordinating them (advice).
List 1 is a component interface for a subject. Archface
exposes archpoints from ports. Four port declarations (line
02-06) correspond to the traditional interface in which eachmethod declaration can be regarded as exposure of method
execution.T h e notifyObservers port (line 09) exposes an
update call archpoint that has to be called under the con-
trol ﬂow of setState. The operator && is used to symbolize
Logical AND . This archpoint is combined with an update
execution archpoint speciﬁed in a component interface for
observers (List 2, line 02).
[List 1]
01: interface component cSubject {
02: port addObserver(): execution(void addObserver(Observer o));
03: port removeObserver():
04: execution(void removeObserver(Observer o));
05: port getState(): execution(String getState());
06: port setState(): execution(void setState(String));
07: }
㼕㼚㼠㼑㼞㼒㼍㼏㼑㻌㼏㼛㼙㼜㼛㼚㼑㼚㼠㻌㼏㻿㼡㼎㼖㼑㼏㼠㻌㼧
㻌㻌㻌㼜㼛㼞㼠㻌㼍㼐㼐㻻㼎㼟㼑㼞㼢㼑㼞㻔㻕㻦㻌㻌㻌㻌㻌㻌㻌㻌㼑㼤㼑㼏㼡㼠㼕㼛㼚㻔㼢㼛㼕㼐㻌㼍㼐㼐㻻㼎㼟㼑㼞㼢㼑㼞㻔㻻㼎㼟㼑㼞㼢㼑㼞㻌㼛㻕㻕㻧㻌㻌㻌㼜㼛㼞㼠㻌㼞㼑㼙㼛㼢㼑㻻㼎㼟㼑㼞㼢㼑㼞㻔㻕㻦㻌㻌㻌㻌㻌㻌㻌㻌㼑㼤㼑㼏㼡㼠㼕㼛㼚㻔㼢㼛㼕㼐㻌㼞㼑㼙㼛㼢㼑㻻㼎㼟㼑㼞㼢㼑㼞㻔㻻㼎㼟㼑㼞㼢㼑㼞㻌㼛㻕㻕㻧㻌㻌㻌㼜㼛㼞㼠㻌㼓㼑㼠㻿㼠㼍㼠㼑㻔㻕㻦㻌㻌㻌㻌㻌㻌㻌㻌㼑㼤㼑㼏㼡㼠㼕㼛㼚㻔㻿㼠㼞㼕㼚㼓㻌㼓㼑㼠㻿㼠㼍㼠㼑㻔㻕㻕㻧㻌㻌㻌㼜㼛㼞㼠㻌㼟㼑㼠㻿㼠㼍㼠㼑㻔㻕㻦㻌㻌㻌㻌㻌㻌㻌㻌㼑㼤㼑㼏㼡㼠㼕㼛㼚㻔㼢㼛㼕㼐㻌㼟㼑㼠㻿㼠㼍㼠㼑㻔㻿㼠㼞㼕㼚㼓㻕㻕㻧㼩
㼕㼚㼠㼑㼞㼒㼍㼏㼑㻌㼏㼛㼙㼜㼛㼚㼑㼚㼠㻌㼏㻿㼡㼎㼖㼑㼏㼠㻮㼑㼔㼍㼢㼕㼛㼞㻌㼑㼤㼠㼑㼚㼐㼟㻌㼏㻿㼡㼎㼖㼑㼏㼠㻌㼧
㻌㻌㻌㼜㼛㼞㼠㻌㼚㼛㼠㼕㼒㼥㻻㼎㼟㼑㼞㼢㼑㼞㼟㻔㻕㻦㻌㻌㻌㻌㻌㻌㻌㻌㼏㼒㼘㼛㼣㻔㼟㼑㼠㻿㼠㼍㼠㼑㻔㻕㻕㻌㻒㻒㻌㼏㼍㼘㼘㻔㼡㼜㼐㼍㼠㼑㻔㻕㻕㻧㼩㻭㼞㼏㼔㼒㼍㼏㼑㻰㼑㼟㼕㼓㼚㻌㻼㼛㼕㼚㼠
㻭㼞㼏㼔㼜㼛㼕㼚㼠㻯㼛㼚㼟㼠㼞㼍㼕㼚㼠㻌㼍㼙㼛㼚㼓㻌
㼐㼑㼟㼕㼓㼚㻌㼜㼛㼕㼚㼠㼟
㻔㼙㼑㼟㼟㼍㼓㼑㻌㼟㼑㼝㼡㼑㼚㼏㼑㻕
㼜㼡㼎㼘㼕㼏㻌㼏㼘㼍㼟㼟㻌㻿㼡㼎㼖㼑㼏㼠㻌㼧㻌㻌㻌㼜㼞㼕㼢㼍㼠㼑㻌㼂㼑㼏㼠㼛㼞㻌㼛㼎㼟㼑㼞㼢㼑㼞㼟㻌㻩㻌㼚㼑㼣㻌㼂㼑㼏㼠㼛㼞㻔㻕㻧㻌㻌㻌㼜㼞㼕㼢㼍㼠㼑㻌㻿㼠㼞㼕㼚㼓㻌㼟㼠㼍㼠㼑㻌㻩㻌㻎㻎㻧㻌㻌㻌㼜㼡㼎㼘㼕㼏㻌㼢㼛㼕㼐㻌㼍㼐㼐㻻㼎㼟㼑㼞㼢㼑㼞㻔㻻㼎㼟㼑㼞㼢㼑㼞㻌㼛㻕㼧㻌㻌㻌㻌㻌㼛㼎㼟㼑㼞㼢㼑㼞㼟㻚㼍㼐㼐㻔㼛㻕㻧㻌㻌㻌㼩㻌㻌㻌㼜㼡㼎㼘㼕㼏㻌㼢㼛㼕㼐㻌㼞㼑㼙㼛㼢㼑㻻㼎㼟㼑㼞㼢㼑㼞㻔㻻㼎㼟㼑㼞㼢㼑㼞㻌㼛㻕㼧㻌㻌㻌㻌㻌㼛㼎㼟㼑㼞㼢㼑㼞㼟㻚㼞㼑㼙㼛㼢㼑㻔㼛㻕㻧㻌㻌㻌㼩㻌㻌㻌㼜㼡㼎㼘㼕㼏㻌㻿㼠㼞㼕㼚㼓㻌㼓㼑㼠㻿㼠㼍㼠㼑㻔㻕㻌㼧㻌㼞㼑㼠㼡㼞㼚㻌㼟㼠㼍㼠㼑㻧㻌㼩㻌㻌㻌㼜㼡㼎㼘㼕㼏㻌㼢㼛㼕㼐㻌㼟㼑㼠㻿㼠㼍㼠㼑㻔㻿㼠㼞㼕㼚㼓㻌㼟㻕㻌㼧㻌㻌㻌㻌㻌㼟㼠㼍㼠㼑㻌㻩㻌㼟㻧㻌㻌㻌㻌㻌㼒㼛㼞㻌㻔㼕㼚㼠㻌㼕㻌㻩㻌㻜㻧㻌㼕㻌㻨㻌㼛㼎㼟㼑㼞㼢㼑㼞㼟㻚㼟㼕㼦㼑㻔㻕㻧㻌㼕㻗㻗㻕㻌㻌㻌㻌㻌㻌㻌㻔㻔㻻㼎㼟㼑㼞㼢㼑㼞㻕㼛㼎㼟㼑㼞㼢㼑㼞㼟㻚㼓㼑㼠㻔㼕㻕㻕㻚㼡㼜㼐㼍㼠㼑㻔㻕㻧㻌㻌㻌㼩㼩㻼㼞㼛㼓㼞㼍㼙㻌㻹㼛㼐㼡㼘㼑㻌㻔㻶㼍㼢㼍㻌㻯㼘㼍㼟㼟㻕
㻼㼞㼛㼓㼞㼍㼙㻌
㻼㼛㼕㼚㼠㻯㼛㼚㼟㼠㼞㼍㼕㼚㼠㻌㼍㼙㼛㼚㼓㻌
㼜㼞㼛㼓㼞㼍㼙㻌㼜㼛㼕㼚㼠㼟
㻔㼏㼍㼘㼘㼕㼚㼓㻌㼟㼑㼝㼡㼑㼚㼏㼑㻕㻻㼎㼟㼑㼞㼢㼑㼞㻼㼍㼠㼠㼑㼞㼚㻯㻰 㻻㼎㼟㼑㼞㼢㼑㼞㻼㼍㼠㼠㼑㼞㼚㻿㻰㻰㼑㼟㼕㼓㼚㻌㻹㼛㼐㼡㼘㼑㻌㻔㼁㻹㻸㻌㻰㼕㼍㼓㼞㼍㼙㻕
㼀㼥㼜㼑
㻯㼔㼑㼏㼗
㻿㻹㼀㻌㻿㼛㼘㼢㼑㼞
㼀㼥㼜㼑
㻯㼔㼑㼏㼗
㻿㻹㼀㻌㻿㼛㼘㼢㼑㼞
Figure 1: Type-based MDD
08: interface component cSubjectBehavior extends cSubject {
09: port notifyObservers(): cflow(setState()) && call(update());
10: }
[List 2]
01: interface component cObserver {
02: port update(): execution(void update());
03: }
04:
05: interface component cObserverBehavior extends cObserver {
06: port updateState(): cflow(update()) && call(String getState());
07: }
List 3 is a connector interface specifying the coordination
among archpoints exposed from component’s ports. The ex-
ecution of archpoints is coordinated by connects (multiple
indicates the connection is repeatable). In notifyChange,a n
update call archpoint in cSubject is bound to an update
execution archpoint in cObserver.
[List 3]
01: interface connector cObserverPattern(cSubject, cObserver);
02: interface connector cObserverPatternBehavior
03: extends cObserverPattern {04: connects multiple notifyChange
05: (cSubject.notifyObservers, cObserver.update);
06: connects obtainNewState
07: (cObserver.updateState, cSubject.getState);
08: }
09: }
2.2.2 Design and Program Modules
Both design and program modules are same as traditional
UML diagrams and code. However, there is a crucial dif-
ference. An interface, Archface , resides between them and
it makes them software modules. ObserverPatternCD ,a
class diagram, and ObserverPatternSD , a sequence diagram
shown in Figure 1 are design modules faithful to the Arch-
facedeclared in List 1, 2, and 3. A program module is also
558same as a traditional module such as Java class. List 4 and
5 are Java classes implementing the Archface .
[List 4]
01: public class Subject {
02: private Vector observers = new Vector();
03: private String state = "";
04: public void addObserver(Observer o){ observers.add(o); }05: public void removeObserver(Observer o){ observers.remove(o); }
06: public String getState() { return state; }
07: public void setState(String s) {
08: state = s;
09: for (int i=0; i<observers.size(); i++)10: ((Observer)observers.get(i)).update();
11: }
12: }
[List 5]
01: public class Observer {
02: private subject = new Subject();
03: private String state = "";
04: public void update() {
05: state = subject.getState();
06: System.out.println("Update received from Subject,
07: state changed to : " + state);
08: }
09: }
2.3 Module Integration
To integrate design and program modules, each design
module models its Archface and each program module im-
plements the same Archface . The conformance to Archface
can be checked by a type system that takes into account
not only program but also design interfaces. Type checkingin an abstraction-aware compiler is performed by verifying
whether a design point (program point) corresponding to an
archpoint exists in a design module (program module) while
satisfying constraints among design points (program points)(e.g., the order of message sequences speciﬁed by cflow).
The followings are the formal deﬁnitions of Archface check,
traceability between, and abstraction.
Deﬁnition 4 ( Archface Check of Design Model): A design model
conforms to Archface iﬀ 1) ∀a∈A(a set of archpoints),
∃d∈D(a set of design points) s.t. mapT oDesign (a)= d,a
function A→D,a n d mapT oDesign (A)⊆D;2 )∀ac∈AC(a
set of constraints among archpoints), ∃dc∈DC(a set of con-
straints among design points) s.t. mapT oDesign/prime(ac)= dc,a
function AC→DC,a n d mapT oDesign/prime(AC)⊆DC;a n d3 )
the value of the above dcisTrue.
Deﬁnition 5 (Archface Check of Program Code): A program con-
forms to Archface iﬀ 1) ∀a∈A(a set of archpoints), ∃p∈P
(a set of program points) s.t. mapT oCode (a)= p, a function
A→ P,a n d mapT oCode (A)⊆P;2 )∀ac∈AC(a set of
constraints among archpoints), ∃pc∈PC(a set of constraints
among program points) s.t. mapT oCode/prime(ac)= pc, a function
AC→PC,a n d mapT oDesign/prime(AC)⊆PC; and 3) the value
of the above pcisTrue.
Deﬁnition 6 (Traceability): A design model is traceable to its pro-
gram iﬀ both of them conform to the same Archface .
Deﬁnition 7 (Abstraction): A design model dmis an abstraction
of a program pgiﬀ 1) dmis traceable to pgand 2) |D|<|P|.
|D|and|P|are cardinal numbers of the set D and the set
P, respectively.
3. COMPILER CONSTRUCTION
In this section, we show how to implement an abstraction-
aware verifying compiler.
3.1 Overview
Our compiler includes the functions of traditional model
compiler and ordinary compiler (i.e. program compiler).The former translates a design model into program code.The latter translates the program code into executable code.The abstraction-aware verifying compiler can generate notonly skeleton code but also override archpoint-related pro-
gram points to the existing code preserving an abstractionlevel speciﬁed by Archface . We do not have to separate gen-
erated code from non-generated code as in 1.x-way architecture-
implementation mapping [10]. For example, in the caseofsetState in List 4, skeleton code such as for(;;) ob-
server.update() is generated. If a developer reﬁnes the
code as List 4 (line 09-10) using Vector class, the compiler
checks the type of observers and preserves the update call.
Annotation comments for code modiﬁcation are not neededin our approach, although these comments are used to sup-port round-trip engineering in most MDD tools.
Type checking plays a key role in the abstraction-aware
verifying compiler, because a bstraction can be preserved if
a design module models Archface (type checking between a
design model and Archface is passed) and a program mod-
ule implements the same Archface (type checking between
a program module and Archface is passed). In this section,
we focus on the type checking algorithm.
Our type checking algorithm consists of the following phases:
1) translate design modules, program modules, and Archface
into logical formulas; and 2) check whether or not a formulatranslated from a design module satisﬁes a formula trans-lated from Archface (type checking for a design module) and
check whether or not a formula translated from a programmodule satisﬁes Archface (type checking for a program mod-
ule). Compilation is executed correctly if both type-checks
do not generate errors. We use an SMT (Satisﬁability Mod-
ulo Theories) solver, a tool for deciding the satisﬁability of
logical formulas. An SMT solver generalizes SAT (Satisﬁa-bility) by adding equality reasoning, arithmetic, and otherﬁrst-order theories. The expressiveness of SMT is higher
than that of SAT. Yices [9] is used as an SMT solver in
our compiler implementation, because a sequence of arch-
points can be easily encoded using an array. Yices provides
a Scheme-like input language.
3.2 Phase 1: Translation into Logical Formula
We show how to translate design/program modules and
Archface into logical formulas.
3.2.1 Translation of Design Module
From Deﬁnition 1, we can deﬁne a design module as a
tuple of D={d1, ..., d n}and DC={dcond 1(d1, ..., d n), ...,
dcond m(d1, ..., d n)},w h e r e diis a partial ordered design
point and dcond jis a logical expression for specifying a con-
straint among design points. Design is regarded correct ifthe logical formula below is satisﬁed.
DESIGN =dcond
1∧...∧dcond m (1)
Partially ordered design points can be considered as a setof design points sequences—not a single sequence due toiteration or inheritance. A sequence diagram can be rep-resented by a sequence of message send and receive de-
sign points. An inheritance structure of a class diagramcan be also represented by a partial order of class design
points. A part of Observer pattern (notiﬁcation sequence)
can be translated into List 6 (Figure 2). The notation class-
name
messagename
 kindOfDesignPoint is used to represent
each design point. The sequence is a constraint satisﬁed
when the order of design point occurrence is correct1.
1The constraint sequence( d1, ...d n) is the syntactical sugar
oforder( d1,d2)∧...∧order( dn−1,dn). The constraint order
is a predicate for specifying the order. Other constraints
such as iteration can be also deﬁned using order.
559[List 6]
01: Design :=
02: sequence(
03: cSubject_setState_message_receive,04: cSubject_update_message_send,
05: cObserver_update_message_receive,
06: cObserver_getState_message_send,
07: cSubject_getState_message_receive))
[List 7]
01: Program :=
02: sequence(
03: cSubject_setState_execution,
04: iteration(
05: cSubject_size_call,
06: Vector_size_execution,
07: cSubject_get_call,
08: Vector_get_execution,
09: cSubject_update_call,
10: cObserver_update_execution,11: cObserver_getState_call,
12: cSubject_getState_execution,
13: cObserver_println_call,
14: System_out_println_execution))[List 8]
01: ; cSubject
02: sequence(cSubject_addObserver_a_mexec)
03: sequence(cSubject_removeObserver_a_mexec)
04: sequence(cSubject_getState_a_mexec)
05: sequence(cSubject_setState_a_mexec)
06:07: ; cObserver
08: sequence(cObserver_update_a_mexec)
[List 9]
01: ; cSubject
02: sequence(
03: cSubject_setState_a_mexec,
04: cSubject_update_a_mcall)
05:06: ; cObserver
07: sequence(
08: cObserver_update_a_mexec,
09: cObserver_getState_a_mcall)[List 10]
01: ; notifyChange
02: iteration(
03: cSubject_update_a_mcall,
04: cObserver_update_a_mexec)
05:06: ; obtainNewState
07: sequence(08: cObserver_getState_a_mcall,
09: cSubject_getState_a_mexec)
[List 11]
01: Archface :=
02: sequence(
03: cSubject_setState_a_mexec,
04: iteration(
05: cSubject_update_a_mcall,
06: cObserver_update_a_mexec,
07: cObserver_getState_a_mcall,
08: cSubject_getState_a_mexec)
Figure 2: Translation into Logical Formula
[List 12]
01: (define-type count (subrange 0 10)) ; 0<= count <= 10
02: (define i0::count)
03: ...
04: (define i4::count)
05:06: (assert (and
07: ;; mapToCode(Archpoint)
08: (< i0 i1) (< i1 i2) (< i2 i3) (< i3 i4) ; order preservation
09: (= (plist i0) cSubject_setState_execution)10: (= (plist i1) cSubject_update_call)
11: (= (plist i2) cObserver_update_execution)
12: (= (plist i3) cObserver_getState_call)
13: (= (plist i4) cSubject_getState_execution)14: ;; Program
15: (= (plist 0) cSubject_setState_execution)
16: ...
17: (= (plist 10) System_out_println_execution)))
18:
19: (check) ; check the assertion
[List 13]
01: (assert (and
02: (< i j)
03: (= (alist i) cSubject_setState_a_mexec)
04: (= (alist j) cObserver_getState_a_mcall)))
Figure 3: Type Checking with Yices
3.2.2 Translation of Program Module
From Deﬁnition 2, we can deﬁne a program module as a
tuple of P={p1, ..., p n/prime}and PC={pcond 1(p1, ..., p n/prime), ...,
pcond m/prime(p1, ..., p n/prime)},w h e r e piis a partial ordered program
point and pcond jis a logical expression for specifying a con-
straint among program points. An implementation is con-
sistent if the formula below is satisﬁed.
PR O G R A M =pcond 1∧...∧pcond m/prime (2)
The behavioral aspect of List 4 can be translated into List
7 (Figure 2). The notation classname
 kindOfProgramPoint
is used to represent each program point.
3.2.3 Translation of Archface
From Deﬁnition 3, Archface is an interface for enforcing
constraints on a design model and its program. The processof deriving logical expressions for representing constraintsfrom Archface descriptions consists of four steps: 1) transla-
tion of execution pointcut, 2) translation of cflow,3 )t r a n s -
lation of a connector, and 4) synthesis of translated formulas.In step 1, ports with execution pointcut are translated into
List 8 (Figure 2) in which archpoints exposed from ports arepicked up. The ﬁrst target of translation is a port deﬁned byexecution, because an a_mexec archpoint can be a trigger
of architectural behavior. This archpoint is regarded as asequence consisting of a single archpoint. In step 2, a portincluding cflow is translated into List 9. Control ﬂow can
be translated into a sequence of archpoints. In step 3, List10 is obtained from the cObserverPattern connector. If
multiple is speciﬁed in a connect statement, an iteration
predicate is generated. Otherwise, a connect statement is
translated into a sequence predicate. In step 4, List 11 is
obtained by synthesizing List 8, 9, and 10.3.3 Phase 2: Type Checking
From Deﬁnition 4, type checking for a design module
is performed by verifying the satisﬁability of DESIGN ∧
mapT oDesign (Archface ). The mapToDesign maps an arch-
point to its corresponding design point. For example, cOb-
server_update_a_mexec is mapped to cObserver_update_-
message_receive. From Deﬁnition 5, type checking for aprogram module is performed by verifying whether or notPR O G R A M ∧mapT oCode (Archface ) is satisﬁed. The map-
ToCode maps an archpoint to its corresponding program
point. Both type checking algorithms are basically same. Asan example, we show the latter (type check for a programmodule). In case of the Observer pattern, the logical formula
above is encoded to List 12 (Figure 3). The symbol plist,
whose deﬁnition is omitted due to the space limitation, is an
array including all program points. The occurrence order of
mapT oCode (archpoint )s p e c i ﬁ e di n sequence and itera-
tionis encoded in line 08 - 13. The iteration predicate
can be encoded to Yices by expanding the iteration limited
times (one time in List 12). In this case, only the boundedchecking is available. As shown here, predicates represent-
ing architectural constraints can be translated into the Yices
input language. The preservation of order and the preser-
vation of an abstraction level are represented in line 08 andline 09 - 13, respectively, because i0,..., i4are not continuous
numbers. The assertion in List 12 checks whether there is abisimulation relation between an archpoint sequence and a
program point sequence. This assertion is satisﬁed.
From Deﬁnition 6, the traceability between design and
code is bidirectionally maintained by deﬁning a mapping
design points and program points via Archface .W e c a n
preserve an abstraction level by ignoring program pointsthat are not linked to archpoints. The execution order of
560archpoints representing Observer pattern is preserved even
if program points, which do not change the sequence of arch-
points (e.g. size()), are added to the code. There is a
bisimulation relation between design and code in terms ofarchpoints. Using bisimulation to relate a speciﬁcation andan implementation has been around for about 30 years, pi-oneered by Milner, R. and C.A.R.Hoare. The novel point of
our approach is the realization of bisimulation in terms of a
type system based on Archface .
Our compiler supports not only type checking but also
bounded model checking. The temporal formula
cSubject
setState
 a
mexec ⇒♦cObserver
 getState
 a
mcall
can be checked. In this speciﬁcation, ♦(in the future) is an
operator of LTL (Linear Temporal Logic). This LTL formulais automatically generated from Archface and is encoded to
List 13 (Figure 3) in which alist is an array including arch-
points. The correctness of a program can be guaranteed ifits design model and the traceability to the code are veriﬁed.
4. ABSTRACTION REFINEMENT PROCESS
An abstraction-aware verifying compiler supports the preser-
vation of consistency between design and code in terms ofan abstraction level speciﬁed by Archface . However, it is an
open question to explore an appropriate abstraction struc-ture and decide which abstraction level is reasonable. Thisis an essential problem on software abstraction. Althoughwe cannot provide the best solution at this time, we try torelax this problem by giving an iterative abstraction reﬁne-ment process called AGAR (Archface Guided Abstraction
Reﬁnement), metric for measuring an abstraction level, andrefactoring patterns for abstraction reﬁnement.
4.1 AGAR
Figure 4 illustrates AGAR in which an abstraction level is
determined by archpoint selection. The level becomes high
if the number of selected archpoints is few. On the other
hand, an abstraction level becomes low if the number ofselected archpoints is large. By exploring an appropriate setof archpoints, a developer can ﬁnd an appropriate level, theresult of convergence of iterative and agile ﬂuid moving in
which an abstraction level is ﬂuidly changed.
AGAR originates in CEGAR (Counter Example Guided
Abstraction Reﬁnement), an iterative abstraction reﬁnementprocess in model checking. AGAR is a process of iteratively
exploring appropriate abstraction between design and im-plementation. This process consists of three steps: 1) createan initial Archface , design, and code, 2) check the design
traceability and measure an abstraction ratio, and 3) reﬁneabstraction by modifying Archface , design, and code.
We have to modify design or code when traceability is
violated. Assume that Archface description in List 1 (line
09) is below. This speciﬁes that update is not directly called
from setState butnotify has to handle an update process.
[List 14]
port notifyObservers():
cflow(execution(void setState(String))) && call(void notify());
port update():
cflow(execution(void notify())) && call(update());
In this case, type checking between Archface and code de-
tects an error. If List 14 is preferable, a developer has to
change the code (List 4) to conform to the Archface .O t h -
erwise, the violation is resolved if the abstraction level is
changed to high. That is, the violation in Observer pattern㻴㼕㼓㼔㻌
㻭㼎㼟㼠㼞㼍㼏㼠㼕㼛㼚㻸㼛㼣㻌
㻭㼎㼟㼠㼞㼍㼏㼠㼕㼛㼚㻭㼜㼜㼞㼛㼜㼞㼕㼍㼠㼑㻌
㻭㼎㼟㼠㼞㼍㼏㼠㼕㼛㼚
㻴㼕㼓㼔
㻸㼛㼣
㻲㼘㼡㼕㼐㻌
㻹㼛㼢㼕㼚㼓
㻯㼛㼚㼢㼑㼞㼓㼑㼚㼏㼑
㻲㼘㼡㼕㼐㻌
㻹㼛㼢㼕㼚㼓
Figure 4: AGAR Overview
disappears if List 14 is changed to List 1 (line 09). Ab-
straction mismatch—traceability violation between designand code—can be a trigger of reﬁning abstraction: whicharchpoint should be included in Archface or excluded from
Archface to resolve this abstraction mismatch? AGAR is
an abstraction reﬁnement process using abstraction-awaretraceability check and an abstraction ratio. In the case of
an error, its counter example can be provided and the sup-
port tool gives a developer repair choices.
4.2 Metric for Abstraction Level
We propose abstraction ratio ,am e t r i cf o rm e a s u r i n ga n
abstraction level, based on Deﬁnition 7. The value of thismetric is 1 - #ArchPoint / #ProgramPoint.T h e a b s t r a c -
tion ratio of Observer pattern (notiﬁcation sequence) can be
calculated 0.55 (= 1 - 5 / 11) from the number of archpointsand the number of program points (See List 7 and 11). Thevalue 0.55 indicates that Archface in List 1, 2, and 3 is ap-
proximately 50-60% more abstract than the implementationin List 4 and 5. An abstraction ratio helps a developer to
determine which archpoint should be available in a design.
It is preferable to help a developer to decide an appropriate
abstraction ratio.
We do not recommend ”chasing metrics”, because an ade-
quate abstraction ratio changes corresponding to design sit-uations. The determination of abstractions is a core task
required to a developer. However, if an abstraction level con-
verges to a speciﬁc value in the process of AGAR, the value
can be an appropriate abstraction level .F o r m o u r e x p e r i -
ence, the structural aspect of the design tends to convergefast and the behavioral aspect tends to converge slowly.
5. TOOL SUPPORT
The iArch consists of the followings: 1) model & program
editor, 2) Archface generator, 3) abstraction-aware verifying
compiler , and 4) abstraction metrics calculation. Figure 5
is a snapshot of iArch implemented as an Eclipse plug-in.
The left side is a sequence diagram of the Observer pattern
and the right side is an Archface deﬁnition. In iArch,s y n -
tactical sugar is introduced into the original Archface .T h e
structural aspect can be described as Java-like interface andthe behavioral aspect can be speciﬁed using process algebra.
Fixing inter-model inconsistency is an important problem
561䐟hD>ĞĚŝƚŽƌ
䐠WƌŽŐƌĂŵĞĚŝƚŽƌ
䐡ƌĐŚĨĂĐĞ ĞĚŝƚŽƌ
ŚĞĐŬZĞƐƵůƚŽŵƉŝůĞƌĞƌƌŽƌ͊
^ĞƋƵĞŶĐĞĚŝĂŐƌĂŵ
ĚŽĞƐŶ͛ƚŵĂƚĐŚ
ƌĐŚĨĂĐĞďƐƚƌĂĐƚŝŽŶ
DĞĂƐƵƌŵĞŶƚ䐟
䐠䐡
Figure 5: iArch IDE
[3]. Our approach can verify inconsistency not only between
a model and code but also between models by type checking.
6. DISCUSSION AND CONCLUSIONS
Our research motivation is close to [2]. Cassou, D. et
al. explored the design space between abstract and con-crete component interaction speciﬁcations. They introduced
interaction contract that expresses allowed interactions be-
tween components, describing both data and control ﬂow
constraints. They provided an ADL for Sense/Compute/Controlapplications, and describe associated compilation and veri-ﬁcation strategies. Our approach provides a general model
for design traceability, because the model can be applied
to not only Sense/Compute/Control applications but alsoother kinds of system. Aldrich, J. et al. proposed Arch-
Java[1], an extension of Java. ArchJava uniﬁes architecture
and implementation, ensuring that the implementation con-forms to architectural constraints. Although the approach
ofArchJava is similar to our vision, ArchJava does not con-
tain such an idea that a UML model can be regarded as a
module. It is nice to introduce a new language. However,it is important to improve MDD using ordinary UML and
programming languages, because they are familiar to many
developers in industry. Y. Zheng and R. N. Taylor proposed
1.x-way architecture-implementation mapping [10] for deep
separation of generated and non-generated code. We cancorrespond the former and the latter to design concerns and
implementation concerns, respectively. Moreover, this sep-aration of concerns can be regarded abstraction speciﬁca-tion between design and implementation. However, it is not
easy to change the separation of concerns (or abstraction)
between generated and non-generated code. The code gen-eration approach only is insuﬃcient in terms of changingabstraction. Steel, J. and J´ ez´equel, J. M. introduce model
types [6], an application of typing in MDD. Model type, an
extension to object-oriented typing to a model, treats mod-
els as a collection of interconnected objects and can dealwith the relationships deﬁned in MOF (Meta-Object Facil-ity) metamodels. In our approach, an interface is treatedas the exposure of archpoints. A set of design and program
modules implementing the same archpoints belong to the
same type. This idea can generalize the traditional interface
notion and can be accepted in the MDD context.
The contribution of this paper is summarized as follows:
1) the notion of module and interface is introduced to theworld of design modeling ; 2) Archface integrates design in-
terface with program interface ; and 3) our type system can
check the traceability between design and code in terms ofabstraction. This novel idea enables yet another MDD. Ad-
ditional costs are not needed to introduce our approach, be-
cause Archface descriptions can be generated from a UML
model editor and Archface is just an extension of the no-
tion of program interfaces. That is, we can substitute Arch-
facefor traditional program interfaces. Our approach can
integrate research on design modeling with research on pro-
gramming in terms of modularity and type systems.
Acknowledgments
This research is being conducted as a part of the Grant-in-aid
for Scientiﬁc Research (A) 26240007 and Challenging ExploratoryResearch 25540025 by the Ministry of Education, Culture, Sports,Science and Technology, Japan.
7. REFERENCES
[1] Aldrich, J., Chambers, C., and Notkin, D.: ArchJava:
Connecting Software Architecture to Implementation,
InProceedings of the 24th International Conference on
Software Engineering (ICSE 2002) , pp.187-197, 2002.
[2] Cassou, D., Balland, E., Consel, C., and Lawall, J.:
Leveraging Software Architectures to Guide andVerify the Development of Sense/Compute/ControlApplications, In Proceedings of the 33rd International
Conference on Software Engineering (ICSE 2011) ,
pp.431-440, 2011.
[3] Egyed, A., Letier, E., and Finkelstein, A.: Generating
and Evaluating Choices for Fixing Inconsistencies inUML Design Models, In Proceedings of the 23rd
International Conference on Automated Software
Engineering (ASE 2008) , pp.99-108, 2008.
[4] Kiczales, G., Lamping, J., Mendhekar A., Maeda, C.,
Lopes, C., Loingtier, J. and Irwin, J.: Aspect-Oriented
Programming, In Proceeding of European Conference
on Object-Oriented Programming (ECOOP’97) ,
pp.220-242, 1997.
[5] Kramer, J.: Is Abstraction the Key to Computing?
Communications of the ACM, Vol. 50 Issue 4,
pp.36-42, 2007.
[6] Steel, J. and J´ ez´equel, J. M.: Model Typing for
Improving Reuse in Model-Driven Engineering, In
Proceedings 8th International Conference On Model
Driven Engineering Languages And Systems of
(MoDELS 2005) pp.84-96, 2005.
[7] Ubayashi, N., Nomura, J., and Tamai, T.: Archface:
A Contract Place Where Architectural Design and
Code Meet Together, In Proceedings of the 32nd
International Conference on Software Engineering
(ICSE 2010) , pp.75-84, 2010.
[8] Ubayashi, N. and Kamei, Y.: Design Module: A
Modularity Vision Beyond Code —Not Only ProgramCode But Also a Design Model Is a Module—, InProceedings of the 5th International Workshop on
Modelling in Software Engineering (MiSE 2013)
(Workshop at ICSE 2013) , pp.44-50, 2013.
[9] Yices: http://yices.csl.sri.com/
[10] Zheng, Y. and Taylor, R. N.: Enhancing
Architecture-Implementation Conformance with
Change Management and Support for Behavioral
Mapping, In Proceedings of the 34th International
Conference on Software Engineering (ICSE 2012),pp.628-638, 2012.
562