DTAM: Dynamic Taint Analysis of Multi-threaded Programs
for Relevancy
Malay Ganai
NECLabs America
malay@nec-labs.comDongyoon Lee
University ofMichigan
dongyoon@umich.eduAarti Gupta
NECLabs America
agupta@nec-labs.com
Abstract
Testinganddebuggingmulti-threadedprogramsarenotorio uslydif-
ﬁcult due to non-determinism not only in inputs but also in OS
schedules. Inpractice,dynamicanalysisandfailurerepla ysystems
instrument the program to record events of interest in the te st ex-
ecution, e.g., program inputs, accesses to shared objects, synchro-
nization operations, context switches, etc. To reduce the o verhead
ofloggingduringruntime,thesetestinganddebuggingeffo rtshave
proposed tradeoffs for sampling or selective logging, at th e cost of
reducing coverage orperforming more expensive searchofﬂi ne.
We propose to identify a subset of input sources and shared ob -
jects that are, in a sense, relevantfor covering program behavior.
We classify various types of relevancy in terms of how an inpu t
sourceorasharedobjectcanaffectcontrolﬂow(e.g.,acond itional
branch) or dataﬂow (e.g., state of the shared objects) in the pro-
gram. Such relevancy data can be used by testing and debuggin g
methods toreduce theirrecording overhead andtoguide cove rage.
To conduct relevancy analysis, we propose a novel framework
basedond ynamictaintanalysisform ulti-threadedprograms,called
DTAM.Itperformsthread-modular taintanalysisforeachthread in
parallelduringruntime,andthenaggregatesthethread-mo dularre-
sults ofﬂine. This approach has many advantages: (a) it is fa ster
than conducting taint analysis for serialized multi-threa ded exe-
cutions, (b) it can compute results for alternate thread int erleav-
ings by generalizing the observed execution, and (c) it prov ides a
knobtotradeoffprecisionwithcoverage,dependingonhowt hread-
modular results are aggregated to account for alternate int erleav-
ings. WehaveimplementedDTAMandperformedanexperimenta l
evaluationonpubliclyavailablebenchmarksforrelevancy analysis.
Our experiments show that most shared accesses and conditio nal
branches are dependent on some program input sources. Inter est-
ingly in our test runs, on average, only about 25% input sourc es
and 3% shared objects affect other shared accesses through c ondi-
tionalbranches. Thus,itisimportanttoidentifysuchrele vantinput
sources and sharedobjects for testingand debugging.
Categories and SubjectDescriptors
D.2.5[Software Engineering ]: Testingand Debugging
Keywords
Taint Analysis, Relevancy, Generalization
1. Introduction
With the advent of multi-core processors, there is great nee d to
writeparallelprograms totakeadvantage ofparallelcompu ting re-
sources. However, programming, debugging, and testing con cur-
rent programs are notably difﬁcult because of two types of in her-
ent non-determinism in multiprocessor systems: inputs (i. e., user
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and thefull citation on the ﬁrstpage. Tocop y otherwise, to
republish, topostonserversortoredistribute tolists,re quires priorspeciﬁc
permission and/or afee.
SIGSOFT/FSE’12, November 11-16, 2012, Cary, NC,USA
Copyright 2012 ACM 978-1-4503-1614-9/12/11 ...$15.00.and system data from non-deterministic sources) and OS sche d-
ules (i.e.,order of accesses tosharedobjects). Different inputs and
schedules of concurrent threads may affect the shared objec t state
andcontrol-ﬂow of programs. Thisimplies thatprogrammers have
to reason about all possible inputs and schedules to underst and the
behavior of multi-threadedprograms.
Therearemanyexistingeffortsfrombothsoftwareandhardw are
communities to build useful tools that help program develop ers to
address these challenges. For example, deterministic repl ay sys-
tems [29, 1, 19, 40] enable reproducing concurrency bugs suc h as
data races and atomicity violations, and backward time-tra vel de-
bugging. Systematic exploration techniques [11, 23] explo re all
feasible schedules for a given test input. Runtime techniqu es such
as fuzzing-based testing [27, 28] focus onimproving the int erleav-
ing coverage of some “meaningful" set (using random sleep de -
lays), while trace-based analysis [2, 45, 10, 21, 42, 12, 37] focus
ondetectingandpredictingprogram errorsingeneralizati ons ofan
observed schedule using either ofﬂine search [2, 42, 12, 37] or on-
line analysis [45, 10, 21]. These testing and debugging tech niques
instrument the program to record events of interest in the te st exe-
cution, e.g.,inputs,accesses tosharedobjects, synchron ization op-
erations, context switches, etc. The recorded information are then
used for detecting concurrency-related bugs, for predicti ng bugs
in other thread interleavings, for expanding testing cover age over
otherthreadinterleavings,orforreconstructinganobser vedfailure.
To reduce the overhead of recording inputs and events during run-
time, these testing and debugging efforts have proposed tra deoffs
for sampling or selective recording, at the cost of reducing cov-
erage or performing more expensive search ofﬂine to ﬁnd a tra ce
with failure. For example, to reduce the performance overhe ad of
dynamic data-race detection, a sampling-based approach wa s pro-
posed [21] to process a small percentage of shared accesses b ased
on infrequent visits, thereby, avoiding the need to analyze every
shared access executed by the program.
Though many of these previous efforts have addressed the cha l-
lengesinthespaceofpossiblethreadinterleavingsinduce dbyshared
object accesses, the space of program inputs has received li ttle at-
tention. For instance, deterministic replay systems [29, 1 , 19, 40]
record all program inputs, regardless of their effect on pro gram
behavior. Deterministic execution systems [26, 7] and syst ematic
testing tools [23] provide determinism or testing coverage guar-
antee only for a given input. In addition, some concurrency b ug
reproduction tools [43] assume that they can provide the sam e in-
put during analysis. The recording of inputs helps to reduce the
search space, however atthe cost of partialcoverage andinc reased
overhead (performance penalty).
To address these issues, we propose relevancy analysis to id en-
tify a subset of input sources and shared objects that can aff ect an
execution of the multi-threaded program. We classify relev ancy
basedonhowtheseinputsourcesandsharedobjectsaffectth econ-
trolﬂow (branches) ordata ﬂow (accesses of shared objects) inthe
program. Wealsoanalyzehowbranchesorsharedaccessesdep end
oninput sources andshared objects.
Therelevancyanalysisforinputscanbeusedtoreducethesp ace
of inputs considered by other techniques. A possible use-ca se isto perform relevancy analysis on representative test data a s a pre-
processing step before carrying out time-sensitive testin g, debug-
ging, or runtime monitoring to reduce the performance overh ead.
Some examples of potential beneﬁts provided to other techni ques
are: (a) A deterministic replay system need not record some i nput
source if it does not impact program behavior and it can be eas ily
generatedduringreplay. Thus,monitoringandrecordingon lyrele-
vant input sources would reduce the overhead of such systems . (b)
In testing, generating different input stress data only for relevant
input sources would improve the testcoverage effectively.
Similarly,relevancy analysis for shared objects can also p rovide
notable beneﬁts: (a) It can help to classify data races as mal ign
or benign. For example, if a data race is on a shared object tha t
does not have any effect on conditional branches, one may cla s-
sify the race as benign, since it is unlikely to affect the pro gram
path. (b) It can also empower a data race predictor to relax ce r-
tainread-after-writeorderingconstraints during the sea rchfordata
races. Data race predictors such as [2, 37] use a happens-bef ore
analysis, often with a relaxed ordering of lock/unlock as lo ng as
read-after-write (RAW) constraints for shared objects are not vio-
lated. Thisavoidsreportingfalseraces. However,ifashar edobject
does not affect any conditional branch, itmay ignore its ass ociated
RAW constraints during race prediction, thereby ﬁnding mor e po-
tential races. (c) It can also help sampling-based race dete ction
such as [21] tofocus on onlyrelevant shared objects.
To conduct relevancy analysis effectively, we propose a nov el
frameworkbasedond ynamic taintanalysisform ulti-threadedpro-
grams, called DTAM.Taintanalysisisshownuseful inmanyappli-
cations,includingsecurityattackdetectionandpreventi on,information-
ﬂowpolicyenforcement,andsoftwaretestinganddebugging . Static
taint analysis (e.g.,[24, 39]) computes conservatively in formation-
ﬂow within a program, whereas dynamic taint analysis [25, 4, 33,
5, 34, 47] identiﬁes ﬂows that actually occur in one of the ob-
served executions. Static analysis can produce spurious ﬂo ws due
toimprecisioninthetaintpropagation, whiledynamic anal ysiscan
misspotentialﬂowsdue tounobserved program executions. I nthis
work, we focus on dynamic taint analysis, and address its sho rt-
coming initsapplication tomulti-threadedprograms.
The general idea of dynamic taint analysis is as follows: Dur ing
runtime, it tags data from an external input source, propaga tes the
taint tag along data and control ﬂows, and then checks if tagg ed
dataisusedatatargetinstruction/statement(e.g.,targe tlocationof
ajumpinstruction). InourDTAMframework,weuseauniqueid to
tagdatafromeachinputsource andfromeachsharedobject. I nput
data include the return value of system calls and data copied from
kernel to user space (e.g., data read by sys_read()). Our run time
system propagates the tag along both data and control ﬂows (d e-
scribed later). We check the tags on instructions correspon ding to
shared accesses and conditional branches, toidentifyinpu t sources
that are relevant. Although we target instructions corresp onding to
shared accesses and conditional branches, our DTAM framewo rk
is general and one canspecifyany targetlocation(s) of inte rest.
Dynamic taint analysis for sequential programs is straight for-
ward, and efﬁcient implementations have been proposed in pr ior
work [25, 4, 33, 5, 47]. However, dynamic taint analysis for m ulti-
threaded programs on multi-core platforms remains a challe nge.
An implementation needs to carefully handle concurrent acc esses
to shared objects from multiple threads, and guarantee atom icity
of original code and added instrumentation for taint propag ation
and checking. A naive approach would be to serialize the mult i-
threadedexecution,andsimplyapplysequentialdynamicta intanal-
ysis on it. However, this approach would suffer from bad perf or-
mance due to serialization, i.e., loss of parallelism in the applica-
tion, and from low coverage due to consideration of only one s e-
rialized (observed) trace. To address these problems, our g oals in
DTAMaretwofold: (a)support parallelthread-modular tain tanal-ysis atruntime, (b)generalize thread-modular taintanaly sis results
(i.e., to cover alternate OS schedules) in a post-execution (ofﬂine)
stage. Although thread-modular analysis has been exploite d pre-
viously, such as for procedure summarization [32, 36], and m odel
checking [13, 18], its use in dynamic taint analysis has not b een
investigatedso far.
We refer to the approach with serialization execution as DTAM-
serial,andimplementeditwithinour DTAMframework. Itisbuilt
over Dytan [5], a taint analysis generic framework for seque ntial
programs. In addition to DTAM-serial, we also propose two ne w
approaches named DTAM-parallel andDTAM-hybrid . They com-
prise two main stages: (1) an online stage where each thread p er-
forms taint analysis locally, in parallel with other thread s at run-
time, and (2) an ofﬂine stage where the thread-modular resul ts are
aggregated, tocapture taint propagations across threads. Toenable
thread-modular taint analysis in the ﬁrst stage, we treat a s hared
read event by a thread as another type of input and generate a
pseudo taint tag for that event. Furthermore, whenever a thr ead
executes a shared write event, we log the shared object and th e
propagatedtainttags,ifany,forfurtherpropagationduri ngthesec-
ond stage. In the second stage, an ofﬂine merger collects the taint
results for each thread and aggregates them for the multi-th readed
program. It recursively replaces the pseudo taint tags on sh ared
reads withthe taint tags onshared writes(tothe same object ) from
remote threads, until convergence.
There are two advantages of using DTAM-parallel compared to
DTAM-serial. First, it can take advantage of parallelism by per-
forming thread-modular taint analysis. Second, itcan prov ide gen-
eralized results corresponding to many schedules. Note tha t dy-
namic taint analysis on a serialized execution (DTAM-seria l) in-
herently follows the observed schedule, and it may require e xplor-
ing a large number of serialized schedules to get adequate co ver-
age. Ononehand,DTAM-parallelimplicitlycapturestheeff ectsof
many possible schedules when merging the thread-modular re sults
ofﬂine. On the other hand, depending on the precision of the i nter-
thread propagation, there is a tradeoff involved in using th is paral-
lel approach. Inaddition to a one-time additional cost of an ofﬂine
merge stage, DTAM-parallel approach may lead to over-taint ing if
itconservativelypropagatesthetainttagtoallremotethr eadswhen
thereexistsasharedwrite-readpairtothesameobject,eve nthough
such pairingmaynot be feasible due tosynchronization.
To remove the imprecision of this over-approximation, we pr o-
poseDTAM-hybridwhichconsidersmust-happens-beforerel ation-
ships due to synchronization operations. In this approach, we al-
low a taint tag to be propagated from a shared write in one thre ad
to a shared read (on the same object) in another thread, only i f
there isno must-happens-before ordering betweenthe reada ndthe
write. By considering synchronization operations, DTAM-h ybrid
approach enables us to collect generalized results (i.e., n ot limited
totheobservedschedule)incomparisontoDTAM-serial,whi lead-
dressing some over-tainting issues in DTAM-parallel. Whil e these
ideas are similarto techniques for static dataﬂow analysis and pre-
dictive analysis for multi-threaded programs, we use them t o pro-
vide a ﬂexible framework for dynamic taint propagation that can
tradeoff precision and coverage.
The proposed technique DTAM can give both false positives
(i.e.,spurious relevancy duetoofﬂinemerging) andfalsen egatives
(i.e, missing relevancy due to unobserved program paths). H ow-
ever, as mentioned earlier, it can still be useful in many bes t-effort
applications such as debugging, stress testing,runtime mo nitoring,
to reduce logging overhead and improve coverage. To summari ze,
the contributions of thispaper are as follows:
•Wepropose adynamic relevancyanalysis for multi-threaded
programstoidentifyasubsetofinputsourcesandsharedob-
jects thatcan affect shared-object stateor control ﬂowof t heprograms. Relevancy is classiﬁed in terms of their effect on
branches and on shared accesses. Such an analysis can sup-
plement other techniques to provide the following beneﬁts:
reduce recording overhead, improve testing coverage, im-
prove data race prediction, and help classify benign/malig n
data races.
•We present a dynamic taint analysis framework for multi-
threaded programs (DTAM). It uses parallel thread-modular
taint analysis, with an ofﬂine aggregation for propagating
taints across threads. It provides ﬂexibility to tradeoff p re-
cision and coverage, ranging from results over only the ob-
served serialized execution to generalized results over ot her
thread schedules. Although we focus here on its use for per-
forming relevancy analysis, it is a general framework that
can be usedfor other applications of taint analysis for mult i-
threaded programs.
The rest of the paper is organized as follows. We start with ba ck-
groundandnotationinSection2. Section3presentsthemain ideas
in relevancy analysis. Section 4 describes our proposed dyn amic
taint analysis framework, which we use toperform relevancy anal-
ysis,andSection5presentsitsimplementation. Wediscuss anem-
pirical evaluation inSection 6. Finally, we compare our wor k with
other relatedeffortsinSection7and conclude inSection8.
2. Background
A multi-threaded program consists of a set of concurrently e x-
ecuting threads. The threads communicate with shared objec ts,
some of which are used for synchronization such as locks and s ig-
nals. Atrace πofaprogramisatotalorderedsequenceofobserved
events corresponding to various thread operations such as s hared
accesses and external API calls. Eachevent eof the sequence, i.e.,
e∈πis carried out by some thread denoted as tid(e)at a thread
program location loc(e). These events include the following:
•write/read(t,x) : write/readby tona shared object x
•nd(t): a non-deterministic external input API call by t(in-
cluding hardware interfaces, system calls)
•branch(t) : a conditional branch taken by t
•wait/notify(t,s) : wait/notifyby ton a signal s
•fork(t,t’)/thread_start(t’) :tforks a thread t′
•join(t,t’)/thread_end(t’) :twaits until t′ends
Ashared instruction isaloc(e)where a write/read occurs.
Happens-before . Given a trace πof a program, and events
e,e′∈π, we say ehappens-before e′, i.e.,e/precedesequale′, ifeisob-
servedbeforee′inthetrace. Wesay emusthappens-before e′(i.e.,
causally-ordered), denoted as e≺e′, ife/precedesequale′holds and one of
the following holds:
•e,e′belong tothe same thread
•e=notify(t,s)ande′=wait(t′,s),t/ne}ationslash=t′
•e=fork(t,t′)ande′=thread_start(t′),t/ne}ationslash=t′
•e=thread_end(t)ande′=join(t′,t),t/ne}ationslash=t′
• ∃e1∈π.(e≺e1/precedesequale′)or∃e2∈π.(e/precedesequale2≺e′)
A must happens-before relation can be maintained easily us-
ing vector clocks [22, 9]. A vector clock of a thread, denoted as
VC(t), records the clocks of all threads. Whenever a non-locking
synchronization occurs, vector clocks are updated. Each ev ent is
time stamped with a vector clock. (Implementation details o f vec-
tor clocks canbe found [30].)
Effect Chains . We now deﬁne source, sink and conduit in a
multi-threaded program w.r.t. effectchains.
Source: A source is a non-deterministic external input API or a
shared object associated with the event ndorread, respectively.
We refer to the former source as inputand the latter source as
sharedobject . (Inthesequel,weuse inputstodenoteinputsources.)Sink: A sink is a loc(e), where event eis either a read/write
on a shared object, or a branch. We refer to the former sink as
shared access and the lattersinkas branch.
Conduit: A conduit determines propagation of the effect from a
source toa sinkthrough aread-after-writedependency. Ifa neffect
propagates throughawrite,followedbyaread(onthesamesh ared
object), we refer to the conduit, i.e., the pair of events, as shared
accesses. If an effect propagates through a branch, we refer to the
conduit as branch.
LetA,B∈{source,conduit,sink}.
A→B:Aaffects or propagates aneffect to B
A→ ZB:Adoes not affect orpropagate an effect to B.
 ZA→B:Bdoes not get aneffect propagated through A.
An effect propagation chain is shown as: source→{conduit}∗
→sink. For the above chain, we also say that the conduit/sink is
dependent on the source.
3. Relevancy Analysis
Wediscussrelevancyoftwosourcesofnon-determinisminmu lti-
threaded programs, i.e., inputs and shared objects, with re spect
to how they impact other shared accesses and branches (in Sec -
tions 3.1-3.2). Goinginthe other direction(from sinks tos ources),
wealsodiscussthedependencyofsinks(sharedaccessesand branches)
onvarious sources (inSection3.3).
3.1 RelevantInputs(Sources)
Inmulti-threadedprograms,inputscanaffectsharedobjec tstate,
control ﬂow,orboth. Theinputs correspond tohardware inte rfaces
suchasnetwork,disk,userkeyboard,andnon-deterministi csystem
APIsuch as gettimeofday ,sys_read ,rdtscinstructions, etc.
We propose six possible relevancy types for inputs, based on
how they inﬂuence branches or shared accesses: i_irrel,i_¯bs¯b,
i_¯sb¯s,i_sb¯s,i_¯sbs, andi_sbs. These types are described in Ta-
ble 1. The key to understanding the mnemonics for these types is
as follows: istands for inputs, bstands for branches, and sstands
forsharedobjects oraccesses. Here,thepositiveforms ( b,s)mean
that there is inﬂuence, while the negative forms ( ¯b,¯s) mean that
there is no inﬂuence. For example, i_¯bs¯bdenotes that the input
does not inﬂuence any branch, either directly or through a sh ared
access. The type i_irrelis shorthand to denote inputs that do not
inﬂuence any branch or any shared access. The remaining type s
denote cases where an input affects a branch. Among these, we
distinguish cases where the branch is (or is not) affected th rough a
sharedaccess(mnemonically,bisprecededby sor¯s,respectively).
We also distinguish cases where the branch itself affects (o r does
not affect) a shared access (mnemonically, b is followed by sor¯s,
respectively). This leads to four types, denoted mnemonica lly as
i_¯sb¯s,i_sb¯s,i_¯sbs,andi_sbs.
Table 1: Relevancy Types for Inputs
Type Description
i_irrel Affectsneither any branchnor any sharedaccess.
i_¯bs¯bAffectssome sharedaccessbutnot any branch.
i_¯sb¯sAffectssome branchbut not anysharedaccess.
i_sb¯sAffectssomebranch through somesharedaccess,but thebran ch
doesnot affectany sharedaccess.
i_¯sbs Affects some branch not through any shared access, and the
branch affectssomesharedaccess.
i_sbs Affectssomebranchthroughsomesharedaccess,andthebran ch
affectssomeshared access.
These six input types are also shown pictorially in Figure 1( a),
wherethecirclesshowthedifferentdomains(I:Inputs,BR: Branches,
SH:Shared Accesses). Note that I are the sources, and BR and S H
can be either conduits or sinks, and various intersections d enote
howinputsinﬂuencethem. Theinputsthatdonotaffectanysh ared
access and do not affect any branch, denoted by type i_irrel, are
regarded as irrelevant , andthe rest are regardedas relevant.Thegoalofrelevancyanalysisistoidentifyrelevantinput swhich
may affect shared-object state and control ﬂow of multi-thr eaded
programs. Informationabout relevant inputs canhave manyp oten-
tialusesinmonitoringandanalyzingmulti-threadedprogr ams. For
example,deterministicreplaysystems[29,1,19,40]needn otmon-
itor irrelevant inputs for which natural (unlogged) input d uring re-
playcanbeusedsincetheywouldnotaffecttheshared-objec t state
of the program nor the program path (e.g., taken branches). S imi-
larly, deterministic execution systems [26, 7], systemati c schedule
testingtools[23],andconcurrencybugreproductiontools [43]also
canbeaugmentedwithsystemsupportformonitoringonlyrel evant
inputs. Relevant input analysis can also have a signiﬁcant e ffect
on testing, as one need not explore the space of irrelevant in puts.
Given limited testing time, one can selectively alter only r elevant
inputs toprovide improved test coverage.
/g47/g3/g894/g400/g381/g437/g396/g272/g286/g895
/g17/g90/g94/g44
/g349/g890/g271/g400/g271
/g349/g890/g400/g271/g400/g853/g3/g349/g890/g400/g271/g400
/g349/g890/g400/g271/g400
/g349/g890/g400/g271/g400/g349/g890/g349/g396/g396/g286/g367/g94/g3/g894/g400/g381/g437/g396/g272/g286/g895
/g17/g90/g400/g890/g349/g271/g400
/g400/g890/g349/g271/g400/g400/g890/g349/g271/g400/g853
/g400/g890/g349/g271/g400/g400/g890/g349/g396/g396/g286/g367/g94/g44
/g400/g890/g271/g400
/g894/g258/g895 /g894/g271/g895
Figure 1: Relevancy Typesfor (a) Inputs (I), (b) Shared objects (S), b ased
on their effect on branches (BR) and shared accesses (SH).
The relevant input types of interest may vary for different a ppli-
cations. Wehighlight some of the potential uses:
•One may be interested in the subset of inputs which affect
branches only but not any shared object, i.e., those that do
not inﬂuence the interleaving coverage (ordering of shared
accesses). Such inputs, identiﬁed by the type i_¯sb¯s, are in-
cluded inthe intersectionof I andBR.
•Similarly, one may be interested in the subset of inputs that
do not affect branches but only some shared accesses, i.e.,
that do not inﬂuence any program path (but may be just the
outputs). Such inputs, identiﬁed by the type i_¯bs¯b, are in-
cludedintheintersectionofIandSH.Fromthepointofview
of deterministic replay, such inputs mayalso be irrelevant .
•Onemaywanttoobtainasubsetofinputswhichaffectsome
shared accesses that are control-dependent on inputs, i.e. ,
thosethatmayinﬂuencethelocalbranchesbutnotthebranch es
oftheotherthreads. Suchinputs,identiﬁedbythetype i_¯sbs,
are included inthe intersectionof I,BR andSH.
Based on above potential uses, we also identify some useful
groups of relevant types, as shown in Table 2. We discuss the s ig-
niﬁcance of the grouping shortly, but ﬁrst we provide illust rations
of the types of inputs as shown in Table 3. For each type (shown
in Column 1), we show the effect propagation chain in Column 2 .
In Column 3, we use two threads T1 and T2, communicating with
shared objects SandS′, and local objects x,y,z, and highlight
the corresponding input types withcode snippets. Inthe res t of the
columns, we identifythe membership of eachtype inthe group s.
The groups of input types weconsider are as follows:
•I_¯sb: inputsthataffectsomebranchesnotthroughanyshared
access
•I_bs: inputs that affect some shared accesses through some
branches
•I_b: inputs that affect some branches (shared object may or
maynot be a conduit)•I_s: inputs that affect some shared accesses (branch may or
maybe a conduit)
•I_b_s: inputsthataffecteithersomesharedaccessesorsome
branches
Note that both I_bandI_sincludeI_bs, andI_b_ssubsumes all
relevant input types. Our experimental evaluation (descri bed later)
uses these groups.
Table 2: Input Relevancy Groups
Group i_irrel i_¯bs¯bi_¯sb¯si_sb¯si_¯sbsi_sbs
I_¯sb X X
I_bs X X
I_b X X X X
I_s X X X X
I_b_s X X X X X
Table3: Types and Groups of Inputs Relevancy
/g47/g374/g393/g437/g410/g400/g3/g258/g296/g296/g286/g272/g410/g349/g374/g336/g3/g400/g346/g258/g396/g286/g282/g3/g258/g272/g272/g286/g400/g400/g286/g400/g3
/g894/g94/g44/g895/g853/g3/g258/g374/g282/g876/g381/g396/g3/g271/g396/g258/g374/g272/g346/g894/g17/g90/g895/g100/g346/g396/g286/g258/g282/g3/g28/g454/g258/g373/g393/g367/g286/g400
/g894/g454/g853/g455/g853/g460/g855/g367/g381/g272/g258/g367/g854/g3/g94/g853/g94/g859/g855/g3/g400/g346/g258/g396/g286/g282/g895/g47/g374/g393/g437/g410/g3/g90/g286/g367/g286/g448/g258/g374/g272/g455
/g894/g39/g396/g381/g437/g393/g400/g3/g381/g296/g3/g410/g455/g393/g286/g400/g895/g3
/g100/g455/g393/g286/g400 /g28/g296/g296/g286/g272/g410/g18/g346/g258/g349/g374/g400 /g100/g1005/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g100/g1006 /g47/g890/g400/g271 /g47/g890 /g271/g400 /g47/g890/g271 /g47/g890/g400 /g47/g890/g271/g890/g400
/g349/g890/g349/g396/g396/g286/g367 /g47/g1111/g3/g94/g44/g853/g3/g17/g90
/g349/g890/g271/g400/g271 /g47/g1111/g3/g17/g90/g1111/g3/g94/g44/g3/g1111/g3/g17/g90 /g454/g855/g1089/g374/g282/g894/g895/g854
/g94/g855/g1089/g454/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3 /g455/g855/g1089/g94/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g121 /g121
/g349/g890/g400/g271/g400 /g47/g1111/g3/g94/g44/g1111/g3/g17/g90/g3/g1111/g3/g94/g44 /g454/g855/g1089/g374/g282/g894/g895/g854
/g349/g296/g894/g454/g895/g121 /g121 /g121
/g349/g890/g400/g271/g400 /g47/g1111/g3/g94/g44/g1111/g3/g17/g90/g1111/g3/g94/g44 /g454/g855/g1089/g374/g282/g894/g895/g854
/g94/g855/g1089/g3/g454/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g455/g855/g1089/g94/g854
/g349/g296/g894/g455/g895/g898/g460/g855/g1089/g1005/g899/g121 /g121 /g121
/g349/g890/g400/g271/g400 /g47/g1111/g94/g44/g3/g1111/g3/g17/g90/g1111/g3/g94/g44 /g454/g855/g1089/g374/g282/g894/g895/g854
/g349/g296/g894/g454/g895/g898
/g94/g855/g1089/g454/g854/g3/g899/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g455/g855/g1089/g94/g854/g121 /g121 /g121 /g121 /g121
/g349/g890/g400/g271/g400 /g47/g1111/g3/g94/g44/g1111/g3/g17/g90/g3/g1111/g3/g94/g44 /g454/g855/g1089/g374/g282/g894/g895/g854
/g94/g855/g1089/g3/g454/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3
/g94/g859/g855/g1089/g1004/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g455/g855/g1089/g94/g854
/g349/g296/g894/g455/g895/g898/g460/g855/g1089/g94/g859/g899/g121 /g121 /g121 /g121
3.2 RelevantSharedObjects(Sources)
Likeinputs, sharedobjects caninﬂuenceothershared-objectstate,
or control ﬂow, or both.
Table4: Relevancy Types for SharedObjects
Types Description
s_irrel Affectsneither a branchnor another sharedaccess.
s_¯bs Affectssomeshared accessbutnot any branch.
s_¯ib¯sAffectssomebranchwithout propagatingtheeffectof anyin put,
but thebranch doesnot affectany sharedaccess.
s_ib¯sAffects some branch with propagating the effect of some inpu t,
but thebranch doesnot affectany sharedaccess.
s_¯ibs Affectssomebranchwithout propagatingtheeffectof anyin put,
and thebranch affectssomesharedaccess.
s_ibs Affects some branch with propagating the effect of some inpu t,
and thebranch affectssomesharedaccess.
Table 5: SharedObject Relevancy Groups
Group s_irrel s_¯bss_¯ib¯ss_ib¯ss_¯ibss_ibs
S_¯ib X X
S_bs X X
S_b X X X X
S_s X X X
S_b_s X X X X X
We propose six possible relevancy types for shared objects ( as
sources),basedonhow theyinﬂuencebranches orsharedacce sses:
s_irrel,s_¯bs,s_¯ib¯s,s_ib¯s,s_¯ibs,ands_ibs. These aredescribed
in Table 4, and the mnemonics used here are similar to those fo r
inputs (as sources) described earlier. Also, these types ar e shown
pictorially in Figure 1(b). The shared objects that do not af fectTable 6: Types and Groups for SharedObject Relevancy
/g94/g346/g258/g396/g286/g282/g3/g381/g271/g361/g286/g272/g410/g400/g3/g258/g296/g296/g286/g272/g410/g349/g374/g336/g3/g400/g346/g258/g396/g286/g282/g3
/g258/g272/g272/g286/g400/g400/g286/g400/g3/g894/g94/g44/g895/g853/g3/g271/g396/g258/g374/g272/g346/g286/g400 /g894/g17/g90/g895/g100/g346/g396/g286/g258/g282/g3/g28/g454/g258/g373/g393/g367/g286/g400
/g894/g454/g853/g455/g853/g460/g855 /g367/g381/g272/g258/g367/g854/g3/g94/g853/g94/g859/g855/g3/g400/g346/g258/g396/g286/g282/g895/g94/g346/g258/g396/g286/g282 /g75/g271/g361/g286/g272/g410 /g90/g286/g367/g286/g448/g258/g374/g272/g455/g3
/g894/g39/g396/g381/g437/g393/g400 /g381/g296/g3/g410/g455/g393/g286/g400/g895
/g100/g455/g393/g286/g400 /g28/g296/g296/g286/g272/g410/g18/g346/g258/g349/g374/g400 /g100/g1005/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g100/g1006 /g94/g890/g349/g271 /g94/g890/g271/g400 /g94/g890/g271 /g94/g890/g400 /g94/g890/g271/g890/g400
/g400/g890/g349/g396/g396/g286/g367 /g94/g44/g1111/g3/g94/g44/g853/g3/g17/g90
/g400/g890/g271/g400 /g94/g44/g1111/g3/g17/g90/g1111/g3/g94/g44 /g454/g855/g1089/g1006/g854
/g94/g855/g1089/g454/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3 /g455/g855/g1089/g94/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g121 /g121
/g400/g890/g349/g271/g400 /g47/g1111/g3/g94/g44/g1111/g3/g17/g90/g3/g1111/g3/g94/g44 /g454/g855/g1089/g94/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g94/g855/g1089/g1006
/g349/g296/g894/g454/g895/g121 /g121 /g121
/g400/g890/g349/g271/g400 /g47/g1111/g3/g94/g44/g1111/g3/g17/g90/g1111/g3/g94/g44 /g454/g855/g1089/g374/g282/g894/g895/g854
/g94/g855/g1089/g3/g454/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g455/g855/g1089/g94/g854
/g349/g296/g894/g455/g895/g898/g460/g855/g1089/g1005/g899/g121 /g121
/g400/g890/g349/g271/g400 /g47/g1111/g94/g44/g3/g1111/g3/g17/g90/g1111/g3/g94/g44 /g454/g855/g1089/g94/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g94/g855/g1089/g1006/g854
/g349/g296/g894/g454/g895/g898
/g94/g855/g1089/g454/g854/g3/g899/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g121 /g121 /g121 /g121 /g121
/g400/g890/g349/g271/g400 /g47/g1111/g3/g94/g44/g1111/g3/g17/g90/g1111/g3/g94/g44 /g454/g855/g1089/g374/g282/g894/g895/g854
/g94/g855/g1089/g3/g454/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3
/g94/g859/g855/g1089/g1004/g854/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g3/g455/g855/g1089/g94/g854
/g349/g296/g894/g455/g895/g898/g460/g855/g1089/g94/g859/g899/g121 /g121 /g121 /g121
any shared accesses and do not affect any branches, indicate d by
types_irrel, are regarded as irrelevant . The remaining types are
regarded as relevant.
Some potential applications of relevancy analysis for shar ed ob-
jects are as follows:
•One may be interested to know if a shared object can inﬂu-
ence a branch but not another shared access. Such shared
objects, identiﬁable by types s_¯ib¯sands_ib¯s, are included
inthe intersectionof S(source) andBR (sink).
•One may like to know if a shared object can not inﬂuence
any branch. Such shared objects, identiﬁable by type role
s_¯bs, are included in the intersection of S (source) and SH
(sink). For example, if a race is on a shared object that does
nothaveanyeffectoncontrolﬂow,onemayclassifytherace
as benign; otherwise, potentiallymalign.
•Itcanalsoempoweradata-racedetectortorelaxcertainrea d-
after-write ordering constraints while predicting data ra ces.
Data race detectors such as [2, 37] use happens-before anal-
ysis, often with a relaxed ordering of lock/unlock as long as
read-after-write (RAW) constraints are not violated. Such
constraints are enforced to avoid potentially false (infea si-
ble) data races. However, if a shared object does not affect
any branch, it may ignore those constraints during race pre-
dictiontoﬁndmore potential races.
•Asampling-basedracedetectionsuchas[21]canalsobeneﬁt
byfocusingonasmallersetofsharedobjects. (Inour exper-
imental data we found that, on average, about 12% shared
objects affect some branch).
Again,basedonpotentialuses,wehavegroupedthesharedty pes
intothe following ﬁvegroups, alsoshown inTable 5.
•S_¯ib: sharedobjectsthataffectsomebrancheswithoutprop-
agatingthe effect of any input
•S_bs: shared objects that affect some other shared accesses
through some branches
•S_b: shared objects that affect some branches (input can be
a source)
•S_s: shared objects that affect some other shared accesses
(branch canbe aconduit, input can be a source)
•S_b_s: shared objects that affect either some other shared
accesses or some branches
Like types for inputs, we also illustrate the various types f or
shared objects using small examples, as shown inTable6.
3.3 DependenciesofSinks
So far we have addressed relevance of sources (Inputs, Share d
Objects) by following chains of inﬂuence from these sources to
sinks (Branches, Shared Accesses). Going in the other direc tion,/g47
/g17/g90/g94/g44/g3/g894/g400/g349/g374/g364/g895
/g94/g44/g890/g349
/g94/g44/g890/g349/g890/g271
/g94/g44/g890/g271/g94/g44/g890/g374/g381/g282/g286/g393/g47
/g17/g90/g3/g894/g400/g349/g374/g364/g895/g17/g90/g890/g349/g17/g90/g890/g349/g890/g400
/g17/g90/g890/g400
/g17/g90/g890/g374/g381/g282/g286/g393/g94
/g894/g258/g895 /g894/g271/g895
Figure 2: Dependencies of Sinks: (a) Shared accesses (SH), (b) Branch es
(BR)basedontheir dependency oninputs( i)/branches( b)/shared objects( s).
we can also identify dependencies of sinks, i.e. how shared a c-
cesses andbranches depend oninputs/branches/shared obje cts.
We identify four types of shared access dependencies, as sho wn
inFigure 2(a).
•SH_i_b: sharedaccessesthataredependentonsomebranches
andon some inputs
•SH_i: shared accesses depending only on some inputs (not
dependent onany branch)
•SH_b: shared accesses depending only on some branches
(not dependent onany input)
•SH_nodep: shared accesses that depend neither on any in-
put nor on anybranch
Similarly, we identify four types of branches dependencies , as
shown inFigure 2(b).
•BR_i_s: branches that depend on some inputs and some
shared objects
•BR_i: branches depending only onsome inputs
•BR_s: branches depending onlyon some shared objects
•BR_nodep: branches that depend neither on any input nor
onany sharedobject
4. DynamicTaintAnalysisforMulti-threaded
Programs
In this section, we describe how dynamic taint analysis can b e
used for relevancy analysis and describe some challenges in multi-
threaded programs in Section 4.1. Then, we provide our propo sed
dynamictaintanalysisapproachesformulti-threadedprog rams,namely:
DTAM-serial,DTAM-parallel, andDTAM-hybrid.
4.1 TaintAnalysisforRelevancyAnalysis
Therearethreemainstepsintraditionalsequentialdynami ctaint
analysis: (1) tagging, i.e., identifying data from external inputs
and marking them as tainted, (2) propagating the taint tag along
the data and control ﬂow through the program, and (3) checking
whethertainteddataisusedunsafely. Weusethisdynamicta inttag
propagationandcheckscheme toenable relevantanalysis. W ealso
generate a unique taint tag on data from each input and from ea ch
shared object reads, and propagate it along data-ﬂow and con trol-
ﬂow. However,inourrelevancyanalysis,wedonotusetainta naly-
sistofocusonsecuritypolicyordetectsecurityattacks;i nstead,we
perform runtime checks on shared accesses and/or branches. For
example, when a taint tag from input data propagates to a shar ed
access, through a branch or directly, we say that the input af fects
shared-objectstate. Weclassifyitaccordingtoourreleva ncytypes.
Extending a sequential dynamic taint analysis to multi-thr eaded
programs isnon-trivial. Oneneeds toconsider concurrent a ccesses
to a shared object with additional guarantee that a shared in struc-
tionandinstrumentedcodefortaintpropagationareexecut edatom-/g100/g346/g396/g286/g258/g282/g3/g1004 /g100/g346/g396/g286/g258/g282/g3/g1005 /g24/g100/g4/g68/g882/g400/g286/g396/g349/g258/g367
/g18/g258/g400/g286/g3/g1005/g855/g3/g349/g296/g3/g894/g400/g410/g373/g410/g1006/g1095/g400/g410/g373/g410/g1011/g895 /g18/g258/g400/g286/g3/g1006/g855/g3/g349/g296/g3/g894/g400/g410/g373/g410/g1011/g1095/g3/g400/g410/g373/g410/g1006/g895
/g1005/g855 /g454/g855/g1089/g3 /g47/g1004 /g47/g1004/g1111/g454/g1111/g94/g1004/g1111/g455/g1111/g17/g90/g1004/g1111/g94/g1005 /g47/g1004/g1111/g454/g1111/g94/g1004/g854/g94/g1004/g1111/g17/g90/g1004/g1111/g94/g1005/g894 /g437/g374/g282/g286/g396/g3/g410/g258/g349/g374/g410/g895
/g1006/g855 /g94/g1004/g3/g855/g1089/g454 /g1011/g855 /g455/g855/g1089/g3/g94/g1004 /g47/g1005/g1111/g460/g1111/g94/g1004/g1111/g17/g90/g1005/g854/g3/g94/g1005/g1111/g94/g1004/g1111/g17/g90/g1005 /g47/g1005/g1111/g460/g1111/g94/g1004/g1111/g17/g90/g1005/g854/g3/g94/g1005/g1111 /g94/g1004/g1111/g17/g90/g1005
/g1012/g855 /g349/g296/g3/g894/g455/g895/g3/g898/g3/g876/g876/g17/g90/g1004
/g1013/g855 /g94/g1005/g3/g855/g1089/g3/g857/g856 /g24/g100/g4/g68/g882/g393/g258/g396/g258/g367/g367/g286/g367
/g899 /g100/g346/g396/g286/g258/g282/g1004/g855 /g100/g346/g396/g286/g258/g282/g3/g1005/g855
/g1005/g1004/g855 /g69/g381/g410/g349/g296/g455/g894/g895 /g47/g1004/g1111/g454/g1111/g94/g1004 /g94/g1004/g1111/g455/g1111/g17/g90/g1004/g1111/g94/g1005
/g373/g437/g400/g410/g3/g346/g258/g393/g393/g286/g374/g400/g882/g271/g286/g296/g381/g396/g286 /g47/g1005/g1111/g460/g1111/g94/g1004/g1111/g17/g90/g1005/g854/g3/g94/g1005/g1111/g94/g1004/g1111/g17/g90/g1005 /g894 /g381/g448/g286/g396/g3/g410/g258/g349/g374/g410/g349/g374/g336 /g895
/g1007/g855/g3 /g116/g258/g349/g410/g894/g895
/g1008/g855 /g460/g855/g1089/g3 /g47/g1005 /g24/g100/g4/g68/g882/g346/g455/g271/g396/g349/g282
/g1009/g855 /g94/g1004/g3/g855/g1089/g3/g460/g3/g1085/g3/g94/g1005 /g100/g346/g396/g286/g258/g282/g1004/g855 /g100/g346/g396/g286/g258/g282/g1005/g855
/g1010/g855 /g47/g296/g3/g894/g94/g1004/g895/g898/g876/g876/g3/g17/g90/g1005 /g47/g1004/g1111/g454/g1111/g94/g1004 /g94/g1004/g1111/g455/g1111/g17/g90/g1004/g1111/g94/g1005
/g857/g3/g876/g876/g3/g374/g381/g400/g346/g258/g396/g286/g282/g3/g258/g272/g272/g286/g400/g400 /g47/g1005/g1111/g460/g1111/g94/g1004/g1111/g17/g90/g1005/g854/g3/g94/g1005/g1111/g94/g1004/g1111/g17/g90/g1005
/g899
Figure 3: Example of DTAM Analysis. On the left code example, I0 and I1 a re program inputs; x,y, andzare local objects; S0andS1are shared
objects where statements 2 and 7 haveadata-race (i.e.,stat ement 2 can happen before ( /precedesequal)statement 7,or vice-versa); and there exists amust-happe ns-before
order between statements 10 and 3 enforced by Notify() and Wa it(). On the right, we show the results of DTAM-serial, DTAM- parallel, and DTAM-hybrid
approaches. DTAM-serial depends on the serialized schedul e, so it may lead to under-tainting as in case 2. For DTAM-para llel and DTAM-hybrid, the dotted
arrowsrepresenttheresultofofﬂineanalysis. SinceDTAM- paralleldoesnotconsider amust-happens-before ordercon structed bysynchronization operations,
it may result in over-tainting.
ically. In addition to thread-local data and control ﬂow, on e also
need to consider inter-thread ﬂow for taint propagation, where in
a taint tag can propagate from one thread to another through r ead-
after-write(RAW)shared object dependency.
4.2 DTAM-serial
One straightforward solution for multi-threaded programs is to
serializethemulti-threadedexecution,andthenpropagat etainttags
along the serialized schedule while ensuring atomicity bet ween a
sharedinstructionandinstrumentedcode fortaintpropaga tion. We
call this approach DTAM-serial.
In DTAM-serial approach, there exists a single taint map for
shared objects which holds propagated taint tags for each sh ared
object. This map is shared by all threads so that one thread ca n
see the effect of taint propagation by the other. In addition , each
thread has its owntaint mapfor registers whichcontains thr ead lo-
cal context information. Though DTAM-serial is easy to reas on
about and implement, it has two drawbacks. First, it cannot e x-
ploit application-level parallelism and therefore, it is m uch slower
than normal executions even without considering instrumen tation
costs. Second, DTAM-serial is carried out on the observed se rial-
ized schedule, so it may lead to undertainting w.r.t. other possible
interleavings onthe same inputs.
Weillustratetheabove issueinFigure3. Ontheleftcode exa m-
ple, I0 and I1 are program inputs; x,y, andzare local objects; S0
andS1aresharedobjects. Notethatstatements2and7havead ata-
race. On the right, we show the result of DTAM-serial approac h
based on two different schedules. If statement 2 happens-be fore
statement 7 (Case 1), then taint tag for I0 is propagated to y, BR0,
andS1in Thread 1 via read-after-write (RAW) shared accesses of
S0. However, if statement 7 happens before statement 2 (Case 2),
thenthetainttagforI0wouldnotbepropagatedtoThread1. T hus,
serializinganexecution potentially leads toundertainti ng.
4.3 DTAM-parallel
To overcome the two limitations of DTAM-serial, i.e., seria liza-
tionandundertainting,weproposeaparalleldynamictaint analysis
technique, namely DTAM-parallel. Inaddition tothread-lo cal data
and control ﬂows, a taint tag can be propagated from one threa d to
another through write and read accesses to the same shared ob jectin multi-threaded programs (RAW dependency). Therefore, i t is
necessary to deal with this additional inter-thread ﬂow in d ynamic
taint analysis for multi-threaded programs. For each threa d, the
shared writes are the points where a local taint tag can be pot en-
tially propagated to the other threads, and the shared reads are the
ones where a remote taint tagcanbe propagated intoa thread.
Like DTAM-serial, DTAM-parallel marks each input data with
a uniqueinput taint tag. However, in DTAM-parallel, each thread
maintainsitsowntaintmapforsharedobjectsandperformst hread-
modular taint propagation. When a thread performs a shared r ead,
itcreatesaunique pseudotainttag andpropagatesitasiftheshared
read was treated as an external input.During ofﬂine analysi s, this
pseudo taint tag will be replaced by taint tags, which can be p rop-
agatedvia sharedwrites(performed onthesame object) byre mote
threads. To obtain this additional information, when a thre ad per-
forms a shared write, it logs the shared object identiﬁer (su ch as
memory address) and corresponding taint tags. On completio n of
thread-modular taint propagation, an ofﬂine analysis coll ects the
taint results of each thread and aggregates them by replacin g the
pseudo taint tags on shared reads withthe propagated taint t ags on
shared writes(performed onthe same object) byremote threa ds.
There is a performance-precision tradeoff in using the DTAM -
parallel approach. By performing taint analysis for each th read, it
cantake advantage ofparallelism,buttheofﬂinemergingst epmay
lead to over-tainting because it does not consider must-hap pens-
beforerelationduetosynchronizationoperations. Itcons ervatively
propagates the taint tag from one thread to another whenever there
exists asharedwrite-readpairtothesame shared object. Ho wever,
ifthesharedwritehappensafterthesharedread,thetaintt agshould
not propagate from writetoread.
Althoughnotprecise,thisconservativepropagationprovi desgen-
eralization over other interleavings on the same inputs. Th e pro-
posed DTAM-parallel approach implicitly captures the effe cts of
many possible interleavings when merging the thread-modul ar re-
sultsofﬂine;however, thiscomesatthecostofover-tainti ng. Inthe
following section, we discuss our ﬁnal technique, namely DT AM-
hybrid,whichtakesintoaccountthemust-happens-before r elation-
shipenforced by synchronization operations.
Figure 3 shows this tradeoff. In DTAM-parallel, Thread 0 log staint tagI0 and I1 on shared writes (on statements 2and 5, res pec-
tively), and Thread 1 treats the shared read as a pseudo input on
statement 7. This allows two threads to perform thread-modu lar
taint analysis in parallel. Then, the ofﬂine analysis merge s the re-
sults by replacing pseudo taint tags with the propagated inp ut tags
on shared accesses tothe same object, as represented bythe d otted
arrowsintheexample. However,DTAM-paralleldoesnotcons ider
amust-happens-before orderbetweenstatements10and3enf orced
by Notify() and Wait(), thus it could result in over-taintin g, i.e., it
may conclude that I1canalsoaffect y,BR0,and S1.
4.4 DTAM-hybrid
DTAM-hybrid tracks synchronization operations and takes i nto
account the must-happens-before relationship to address t he above
over-taintingproblem. Suchtypes ofsynchronization prev ent local
taint tags from being propagated from a shared write to a shar ed
read, if the shared read must happen before the shared write. We
also record vector clocks for each read and write event, in ad di-
tion to the shared events and tags. Such information is used f or
determining the must-happens-before relationship during aggrega-
tionstep(as discussed inthe next section).
Figure3showsthedifferencebetweenDTAM-parallelandDTA M-
hybrid. DTAM-hybrid is aware of the must-happens-before or der
between Notify() in Thread 1 and Wait() in Thread 0. Therefor e,
during the ofﬂine merge stage, it does not allow taint tag of I 1 in
Thread 0tobe propagated toThread1.
In Table 7, we present the results of taint analysis in identi fy-
ing various relevant inputs and shared objects for the examp le in
Figure 3. Similarly, in Table 8, we present the results of tai nt
analysisinidentifyingvariousdependenciesofsharedacc essesand
branches. Note, all branches and shared access have depende ncies
on inputs and/or sharedobjects.
As one would expect, DTAM-hybrid gives the most precise1re-
sult compared toDTAM-serial andDTAM-parallel.
Table 7: Input and Sharedobject relevancy
input groups sharedobjectsgroups
dtamI_¯sbI_bsI_bI_sI_b_sS_¯ibS_bsS_bS_sS_b_s
serial (1) I0I0,I1I0,I1I0,I1 S0S0,S1S0,S1S0,S1
serial (2) I1I0,I1I0,I1S0 S0,S1S0,S1S0,S1
parallel I0,I1I0,I1I0,I1I0,I1 S0,S1S0,S1S0,S1S0,S1
hybrid I0I0,I1I0,I1I0,I1 S0S0,S1S0,S1S0,S1
Table 8: Sharedaccess andbranch dependency
shared access branch
dtamSH_i_bSH_iSH_bBR_i_sBR_iBR_s
serial(1) S1 S0 BR0,BR1
serial(2) S0S1 BR1 BR0
parallel S1 S0 BR0,BR1
hybrid S1 S0 BR0,BR1
4.5 Aggregationofthread-modularresults
Inthissection,wedescribe howweperformtheofﬂinemergin g.
We ﬁrstintroduce some notation:
•I: a set of allinput tainttags (i.e.,inputs)
•S: a set of allpseudo taint tags (i.e.,sharedobject reads)
•t: aninput or a pseudo taint tag, i.e., t∈I∪S
•t.r: readaccess event corresponding topseudo tainttag t
•t.obj: shared object corresponding topseudo taint tag t
•t.lw: last observed thread local write event to t.obj(t.lw/precedesequal
t.r)
1DTAM-hybridmaystillhaveovertaintingproblemifthecaus al-ordering( ≺)permits
infeasible permutation of trace events. Although one may av oid the problem by using
maximal-causal models[35], one mayincur lowcoverage.•t.gw: last observed global write event to t.obj(t.gw/precedesequalt.r)
•t.A: a set of allshared writeevents byother threads to t.obj
•w.T: a set of taint tags propagated (during thread-modular
taintanalysis) towriteevent w
The goal of aggregation is to obtain a transitive dependency on
inputs taint tags (or pseudo taint tags) for a given set of tai nt tags
propagated at sinks ina thread-modular taint analysis.
For a given relevancy group R(e.g.,I_b,S_b), letR.ddenote a
set of pseudo taint and input taint tags that were relevant fo rRas
obtained from the thread-modular taint analysis.
Wethenobtainasetofallinputtainttagsthatarerelevantf orR,
denoted as R.I,as follows:
R.I=/uniondisplay
t∈R.dt.I (1)
wheret.Iis the set of all input taint tags that can possibly affect t
(computed as described below).
Similarly,weobtainasetofallpseudotainttagsthatarere levant
forR,denoted as R.S, asfollows:
R.S=/uniondisplay
t∈R.dt.S (2)
wheret.Sis the set of all pseudo taint tags that can possibly affect
t.
Wenowdescribe how weobtain t.Iandt.Sforatagt. Lett.W
denoteasetofallwriteaccessesthatcanpossiblyaffectth ereadof
t.obj. In the following, we deﬁne t.Win such a way that we can
uniformly handle DTAM-serial/parallel/hybrid.
t.W=

{t.gw} serial
{t.lw}∪t.A parallel
{t.lw}∪{w|w∈t.A∧(t.r/ne}ationslash≺w)}hybrid(3)
Wethen compute t.Iandt.Srecursively using t.Was follows:
t.I=/braceleftBigg
{t} ift∈I/uniontext
w∈t.W(/uniontext
t′∈w.Tt′.I)ift/ne}ationslash∈I(4)
t.S=/braceleftBigg
{} ift∈I/uniontext
w∈t.W(/uniontext
t′∈w.Tt′.S)ift/ne}ationslash∈I(5)
5. Implementation
In this section, we describe our implementation for relevan cy
analysisbasedondynamictaintanalysis. Weﬁrstdiscussap roﬁle-
based approach to identify shared instructions in Section 5 .1 and
thendiscusstheimplementationofDTAMapproachesinSecti on5.2.
5.1 ProﬁlingSharedInstructions
For a given program, DTAM needs to identify a set of shared
instructions (i.e., program locations of read/write event s) for two
reasons: First, the DTAM approaches proposed in Section 4 re ly
on shared instructions for inter-thread data ﬂow based (RAW de-
pendency) taint propagation. For example, DTAM-serial ens ures
atomicity between shared accesses and instrumented code. F or
DTAM-parallel and DTAM-hybrid, the pseudo taint tags are ge n-
erated at shared read accesses, and the taint tags are logged during
shared write accesses. Second, the relevant analysis perfo rm taint
checks on the shared accesses as we are interested in the inpu ts
and shared objects that can affect the outcome of the shared a c-
cesses. The process of identifying shared instructions can be done
through proﬁling or static analysis. In our implementation , we use/g47/g374/g400/g410/g396/g437/g373/g286/g374/g410/g286/g282
/g17/g349/g374/g258/g396/g455/g3/g28/g454/g286/g272/g437/g410/g349/g381/g374
/g75/g296/g3/g373/g437/g367/g410/g349/g882/g410/g346/g396/g286/g258/g282/g286/g282
/g87/g396/g381/g336/g396/g258/g373/g94/g286/g396/g349/g258/g367/g349/g460/g286/g282/g3
/g100/g258/g349/g374/g410/g3/g258/g374/g258/g367/g455/g400/g349/g400
/g100/g346/g396/g286/g258/g282/g882/g373/g381/g282/g437/g367/g258/g396
/g100/g258/g349/g374/g410/g3/g258/g374/g258/g367/g455/g400/g349/g400
/g100/g349/g373/g286/g882/g400/g410/g258/g373/g393/g286/g282/g3/g400/g455/g374/g272
/g286/g448/g286/g374/g410/g400/g3/g396/g286/g272/g381/g396/g282/g349/g374/g336
/g90/g286/g367/g286/g448/g258/g374/g410/g3/g349/g374/g393/g437/g410/g400/g853/g3/g400/g346/g258/g396/g286/g282/g3/g381/g271/g361/g286/g272/g410/g400
/g24/g286/g393/g286/g374/g282/g286/g374/g410/g3/g271/g396/g258/g374/g272/g346/g286/g400/g853/g3/g400/g346/g258/g396/g286/g282/g3/g258/g272/g272/g286/g400/g400/g286/g400/g100/g346/g396/g286/g258/g282/g882/g373/g381/g282/g437/g367/g258/g396
/g410/g258/g349/g374/g410/g286/g282/g3/g282/g258/g410/g258/g94/g455/g374/g272/g882/g437/g374/g258/g449/g258/g396/g286
/g68/g286/g396/g336/g286
/g94/g455/g374/g272/g882/g258/g449/g258/g396/g286
/g68/g286/g396/g336/g286/g100/g346/g396/g286/g258/g282/g3/g349/g374/g410/g286/g396/g367/g286/g258/g448/g286/g282
/g410/g258/g349/g374/g410/g286/g282/g3/g282/g258/g410/g258
/g75/g374/g367/g349/g374/g286/g3/g894/g396/g437/g374/g410/g349/g373/g286/g895 /g75/g296/g296/g367/g349/g374/g286/g3/g894/g393/g381/g400/g410/g882/g286/g454/g286/g272/g437/g410/g349/g381/g374/g895/g94/g286/g396/g349/g258/g367
/g44/g455/g271/g396/g349/g282/g87/g258/g396/g258/g367/g367/g286/g367/g94/g286/g396/g349/g258/g367/g3/g68/g286/g396/g336/g286
Figure 4: DTAMoverview
a proﬁle-based approach, where we execute the programs mult i-
ple times with representative test data and collect the set o f shared
instructions, along withitstype of operation (writeor rea d).
We used PIN [20], a dynamic binary translation tool to instru -
ment and proﬁle application x86 executables. We maintain me ta-
data for each byte of location address, which represents the access
history of each thread. An instruction is marked sharedif the in-
structionaccessesasharedobjectwhichhasbeenaccessedb yother
threads. Insteadofusinginstructionaddress,wenameeach instruc-
tionthe tuple of loaded image name and offset sothat wecan re fer
to each instructionuniformly for different proﬁled runs (e .g., a dy-
namically linkedlibrarymay be loaded intodifferent addre sses).
5.2 DTAM
WeimplementedtheproposedDTAMapproaches(DTAM-serial,
DTAM-parallel,andDTAM-hybrid)basedonDytan[5]whichpr o-
vides a generic framework for dynamic taint analysis. Dytan sup-
ports dynamic taint analysis for an x86 executable by instru ment-
ing it on-the-ﬂy to produce an instrumented executable, usi ng the
PIN [20] tool. Dytan maintains taint tags for each byte of loc ation
addressandsupportsallocatingvirtuallyanynumberoftai ntmark-
ings,whichallowsustospecifydifferenttaintmarkingfor different
input sources. Dytan also supports both explicit (data-ﬂow based)
and implicit (control-ﬂow based) information ﬂow. For cont rol-
ﬂow basedtaint propagation, Dytanperforms staticanalysi s on the
binary to ﬁnd immediate post-dominator of a conditional bra nch.
Allthestatementsthatbelongtothepathsstartingattheco nditional
branch andending withitsimmediatepostdominator arecons erva-
tively marked as tainted if the conditional branch depends o n the
tainted data. In addition to leveraging the default functio nalities in
Dytan, we extended the framework tosupport DTAMas follows.
First, Dytan was originally developed for supporting seque ntial
programs. For sequential programs, there is no inter-threa d taint
propagation. However, concurrent accesses to shared locat ion lo-
cations and corresponding metadata updates should be caref ully
handled in multi-threaded programs. In DTAM-serial mode, w e
ensure atomicity between shared accesses and taint propaga tion
using locks, as all threads share a single taint map for share d ob-
jects. In DTAM-parallel and DTAM-hybrid, each thread maint ains
its own taint map for shared objects and performs thread-mod ular
taintpropagation. Notethatinter-threadtaintpropagati onsarehan-
dledbytheofﬂinemergestage. Onthethread-modulardata,w ecan
also do a serialized merging (as shown in Eq 3) to obtain DTAM-
serial data. Figure 4 gives an overview of the implementatio ns of
the various DTAMapproaches.
Second, as our goal is to identify relevant inputs, DTAM tain ts
all the program inputs. This is not true for traditional dyna mictaint analysis tools including Dytan, as most of them refer t o some
(not all) inputs that stem from external sources such as netw ork,
disk, user keyboard, etc. to be tainted. (Traditional DTA to ols
were primarily used to track untrusted user input data.) For ex-
ample, DTAM considers the return value of system calls such a s
gettimeofday, rdtsc to be tainted because its value can have
an effect on shared state or control ﬂow of the program. In con -
trast,Dytanclears the taint tagfor the targetregisters.
Third,DTAMsupportsprecisecontrol-ﬂowbasedtaintpropa ga-
tionattheﬂag(bit)granularityofstatusregister(e.g. EF LAGS).In
Dytan, like other registers, taint tags are maintained for t he whole
EFLAGS status register, thus Dytan cannot differentiate th e taint
tag for each ﬂag bit such as CF(carry ﬂag), PF(parity ﬂag), an d
ZF(zeroﬂag). However, most x86 instructions do not affect a ll the
ﬂagsinthestatusregister,soﬂag-sensitivetaintpropaga tionforthe
status register canleadtobetter precision.
6. ExperimentalResults
We now report evaluation of DTAM approaches for relevancy
analysis. We begin with describing our evaluation methodol ogy.
Then, we compare the result of relevancy analysis for differ ent
DTAM approaches. Last, we show the distribution of shared ac -
cessesandbranchesintermsoftheirdependencyoninputs,b ranches,
and sharedobjects.
Experimental Setup . We ran all experiments on a 2.8GHz 2-
core Xeon processor with 4GB of RAM running Linux 2.6.9 ker-
nel. We used two sets of benchmarks. The ﬁrst set consists of
six desktop applications from open source repositories [17 , 16],
namely: aget, pfscan, pnscan, pbzip2, fastspy, and axel. Th e test
setup for each application is as follows: agetdownloads a 47KB
ﬁle inparallel; pfscansearches inparallel for the string“debug” in
a directory with 30KB of sources ﬁles; pnscanscans TCP port in
parallel to ﬁnd running web servers; pbzip2compresses a 0.8KB
log ﬁle in parallel; fastspyscans port 10 to 20 for a given IP ad-
dress; and axeldownloads a 47KB ﬁle. The second set consists of
threerepresentatives ofscientiﬁcapplicationwithdiffe rent charac-
teristicsfromPARSEC-2.1suite[31]2:blackscholes ,canneal, and
streamcluster . Weused simsmall input sets forthe evaluations.
Table 9: Characteristicsof multi-threaded applications.
Apps(LOC, Lang) NEIdynIscSHSONOFF
aget(1.1K, C) 484K3186535K8.5K918
pfscan(1K,C) 347K1974937K8691730
pnscan(1.5K, C) 26K776662K931320.1
pbzip2(5K,C++) 35K252557121K280.05
blackscholes (800, C)32K192396836950.05
canneal (1.7K, C) 37K204434K71750.1
streamcluster (1.2K, C++)520K2K4410K804204
fastspy (1.2K, C) 1273K7405428K7K971
axel(4K,C) 764K15686532K11.5K234
In Table 9, we report the run time characteristics for the tes ts
conducted for the applications listed in Column 1. The numbe r
of threads (N, Column 2) was between 2 to 12, and the number
of observed events was between 2K to 84K (E, Column 3). We
use Idynto denote the number of ndevents (Column 4), ranging
from 192 to 2K. We count each instance of system calls (return
value, datacopiedintouser-levelprocess) andnondetermi nistic in-
structions (e.g., rdtsc) as input source. The static count o f inputs
(Column 5, I sc) is the count of loc(e)whereeisndevent, ranging
from 39 to 66. It is obtained by combining the effect of multip le
dynamic instances (i.e., ndevents). We use SH todenote the num-
ber of read/write events (Column 6), ranging from 68 to 37K.
2Blackscholeshascoarse-graineddata-parallelparalleli zation withlowsharing; Can-
neal has ﬁne-grained unstructured parallelism with high fr equent sharing pattern; and
Streamcluster hasmedium-grained andmedium level ofshari ng characteristics.The number of shared objects (Column 7, S) refers to the disti nct
objects, where each object was accessed by at least two threa ds.
We ran each application 20 times ﬁrst to proﬁle a set of shared
instructions. The online thread-modular taint analysis (C olumn 8,
ON) took between 5 to 32 minutes, about 16 minutes on average
perapplication. Theofﬂineaggregationofthethread-modu lartaint
results (Column 9, OFF) took between a few seconds to 70 min-
utes,15minutesonaverageperapplication. Thesetimes(sh ownin
min.) can be improved further witha better implementation.
ResultsofRelevancyAnalysis . ForcomparingdifferentDTAM
approaches on the same observed trace, we use the same thread -
modular data for aggregation for serial/parallel/hybrid. The left
half of Figure 5 shows the results of relevant input analysis based
on DTAM-hybrid. Results for DTAM-serial and DTAM-parallel
show similartrends,andarenotshown. Eachbarrepresents t hera-
tio of relevant inputs to the total number of inputs (I sc) for a given
relevant input type. For aget, I_¯sbis 9% (=6/65), I_bsis 28%
(=18/65), I_bis 28% (=18/65), I_sis 43% (=28/65) and I_b_sis
43% (=28/65), resp. The average of eachbar isshown rightmos t.
For DTAM-hybrid (and similarly for parallel and serial), on av-
erage,about15%ofinputsarecategorizedintorelevantgro upI_¯sb
that affects branches not through any shared access, about 2 5% of
inputs are categorized into group I_bs(andI_b). The percentage
increases to 40% on average for I_s(andI_b_s) on our bench-
marks. Thisimpliesthatabout15%inputs( I_b_s−I_s)thataffect
shared accesses do not have control over the program paths, a nd
60% inputs are irrelevant. We found that (1) many rdtscinstruc-
tions (e.g.,10/49 inpfscan) are justused forlogging time s tampof
events (e.g., thread creation) and never affect branching, (2) many
return values from system calls (e.g., sys_close ,sys_fstat64 ,
sys_write ,sys_mprotect etc.) are not used, whereas some re-
turnvalue matters (e.g., sys_open ).
Forcomparing different DTAMapproaches, we show results fo r
groupI_bsas shown in the right half of Figure 5. For three ap-
plications(i.e.,aget,fastspy,andaxel)DTAM-parallela ndDTAM-
hybriddemonstratethegeneralizationeffect,resultingi nlargerrel-
evancyratioscomparedtoserial. DTAM-hybridaddressesth eover-
taintingissueinDTAM-parallel,andundertaintingissuei nDTAM-
serial, as observed for agetin particular. We observe that the ratio
of shared objects (S) to that of inputs (I sc) for these three applica-
tions is about 100, while that of the rest is about 10. Such a la rge
ratioindicates more pronounced generalization.
The lefthalf of Figure 6shows the results of relevant shared ob-
ject analysis based on DTAM-hybrid. (Results for DTAM-seri al
and DTAM-parallel are similar, and are not shown.) Each bar r ep-
resents the ratio of relevant shared objects to the total num ber of
shared objects for a given relevant shared type. The average of
each bar is shown rightmost. We observe that relevancy ratio S_¯ib
fortheseapplicationsis0%,i.e., allsharedobjectsthataffectsome
branch also propagate the effect of some input to the branch. Fur-
ther,the relevancy ratioforgroups S_bsandS_bisabout 3% each
on average, indicating that shared objects have very small i mpact
on the control over the program paths. The ratio increases to 13%
onaveragefor S_sandS_b_seach,indicatingthatthe10%shared
objectsthataffectothersharedaccessesdonotcontrolthe program,
andabout87%sharedobjectsareirrelevant. ComparingallD TAM
approaches, hybridgives betterprecision, as observed for axel.
Disclaimer: The relevancy ratios for inputs and shared objects
reﬂect the trends observed on the test runs of the benchmarks used
in our experiments. It may hold for other multi-threaded ben ch-
marks thatwere not used, butmay not holdingeneral.
SinkDependencies. We now evaluate the dependency for sinks
(shared accesses and branches) i.e., (1) how many shared acc esses
depend on inputs and/or branches and (2) how many branches re ly
on inputs and/or shared objects. We chose DTAM-hybrid torep re-
sent the results, as other methods give similarresults.The left half of Figure 7 shows the distribution of dynamic in -
stancesofsharedaccessesthataredependentoninputsand/ orbranches
amongalltestedapplications. Exceptforblackscholes, we observe
that more than 95% of shared accesses turn out to be dependent
upon inputs( SH_iandSH_i_b)atruntime,andmostof themde-
pend onboth inputs and branches.
The right half of Figure 7 shows the distribution of dynamic i n-
stances of branches that are dependent upon inputs and share d ob-
jects. Similartopreviousresult,mostofbranchesdependo ninputs
(BR_i) or bothinputs and shared objects ( BR_i_s).
These results highlight that most shared accesses and branc hes
are dependent on some inputs. This implies that without prop -
erly monitoring such relevant inputs, it is extremely difﬁc ult to re-
construct shared state or control ﬂow of multi-threaded pro grams,
whichjustiﬁes our motivation of relevancy analysis.
7. Related Work
Ourwork isrelatedtodynamic taintanalysis andruntime mul ti-
threaded program monitoring.
Dynamic Taint Analysis. In the last few years, there have been
many proposals tobuildefﬁcientdynamic taintanalysis too lsfrom
both software and hardware communities. Overall, the previ ous
proposalscanbecategorizedintothreeapproachesbasedon under-
lying infrastructure used: dynamic binary translation (DB T) based
approaches [25, 4, 33, 44, 5, 47], whole-system emulation ba sed
approaches [8,46, 15], andhardware-assisted systems [38, 6,41].
Dynamicbinarytranslationhasbeenlargelyusedforimplem ent-
ingdynamic taintanalysis, asitworks easilyonagivenexec utable
binary, and most previous works have focused on reducing per for-
mance overhead of taint propagation and runtime checks for s e-
quential programs with better instrumentation techniques . For ex-
ample, TaintTrace [4], based on DynamoRio, leverages one-t o-one
tablemappingbetweendataandtaintmetadataforfastlooku p, and
also implements a fast switch between original code and inst ru-
mentation using dead register analysis and eﬂag liveness an alysis.
Similarly, LIFT [33], implemented by StarDBT, proposes a co ndi-
tional branching mechanism between a fast path(w/oinstrum enta-
tion) anda slowpath (withinstrumentation) toskipredunda nt run-
time checks. Italsoimplements an efﬁcientinstrumentatio n mech-
anism without stack switches. Recently, TaintEraser [47], based
onPIN,proposestoleverageuser-annotatedfunctionsumma riesto
speed up runtime taint propagation and checks. Even though w e
also use the dynamic binary translation tool PIN, our focus i s not
on improving performance using better instrumentation lik e previ-
ous works. Instead, wefocus onenabling paralleltaintanal ysis for
multi-threadedprograms. AllthepreviousDBT-basedworks either
do not consider multi-threaded programs, or simplyassume s erial-
ized executions (like DTAM-serial). On the other hand, prev ious
whole-system emulation based approaches enable dynamic ta int
analysisformulti-threadedprograms,buttheysufferfrom highper-
formance overhead and require support from operating syste ms or
hardware for practical implementation.
Runtime Monitoring for Parallel Programs. With the advent
ofmulticoreprocessors, runtimesystemsthatexploitextr acoresto
monitor multi-threaded programs have been proposed. Log-B ased
Architecture(LBA)[3]supportsahardwareeventqueuewhic hefﬁ-
cientlycollectsruntimeexecutionevents(e.g. memoryope rations).
The logged information can be dequeued by lifeguards, which run
in parallel with the original program on spare cores and perf orm
runtimechecks. Forexample,Bufferﬂyanalysis[14]hasbee nbuilt
on top of LBA for efﬁcient memory bound analysis and taint ana l-
ysis for multi-threadedprograms.
Respec[19]proposesasoftware-onlysystemthatenablesde cou-
pledruntimechecksofmulti-threadedprogramsbasedonano nline
deterministic replay technique. Respec records non-deter ministic
eventsoftheoriginalprocessandreproduces themforthere playedFigure 5: (L)Ratio of relevant inputs to total inputs (I sc) for DTAM-hybrid; (R) Comparison of serial/parallel/hybr id forI_bs.
Figure 6: (L)Ratio of relevant shared objects to total shared objects (S) for DTAM-hybrid; (R) Comparison of serial/parallel/hy brid forS_bs.
Figure 7: Distribution of dynamic instances of (left) shared accesse s that depend on inputs and/or branches, (right) branches th at depend on inputs and/or
shared objects.
process, which run in parallel on extra cores. As replayed ex e-
cution is guaranteed to be same as the original execution, it al-
lows users to perform heavy-weight runtime checks on replay ed
executions without pausing the original executions. As an e xten-
sion,Doubleplay[40]timeslicesmulti-threadedexecutio nsintoso-
called epochs, and runs each epoch in uniprocessor concurre ntly
withoriginalexecution. Aseachepochisexecutedinunipro cessor,
Doubleplay enables using sequential version of monitoring tools
(suchasboundchecks,taintchecks,etc.) withoutmodiﬁcat ionand
its runtime cost canbe parallelized.
In contrast, our system DTAM monitors each thread indepen-
dently (i.e., performs thread-modular taint analysis) and considers
the effect of shared accesses laterinanofﬂine analysis.8. Conclusions
Wepresentedathread-modular dynamic taintanalysisformu lti-
threaded programs which can provide generalized taint anal ysis
from a single observed execution. We used this analysis to id en-
tify a smaller set of inputs and shared objects in a multi-thr eaded
program. In future work, we plan to evaluate the beneﬁts of re le-
vancy analysis to a replay system for multi-core platforms. Based
on potential uses, we also introduced various relevancy typ es and
groups for inputs and shared objects. Such relevancy analys is can
be used to improve testing, veriﬁcation, debugging, and pro gram
understandingformulti-threadedprogramsduringdevelop ment,or
for failure diagnosis afterdeployment.References
[1] G.Altekar and I.Stoica.ODR:Output-deterministic rep lay
for multicore debugging. In Symposium on Operating
Systems Principles , 2009.
[2] F.Chen, T. F.Serbanuta, andG. Rosu. jPredictor: A
predictive runtime analysis tool for Java. In Proc.of ICSE ,
2008.
[3] S.Chen, M. Kozuch, T. Strigkos,B.Falsaﬁ,P.B.Gibbons,
T. C.Mowry, V. Ramachandran, O.Ruwase, M. Ryan, and
E.Vlachos. Flexible hardware accelerationfor
instruction-grain program monitoring. In Proc.of ISCA ,
2008.
[4] W.Cheng, Q.Zhao, B.Yu,and S.Hiroshige. Tainttrace:
Efﬁcientﬂow tracingwithdynamic binaryrewriting. In
Proc.of ISCC , 2006.
[5] J.Clause,W.Li,andA.Orso.Dytan: ageneric dynamic tai nt
analysis framework. In Proc.of ISSTA , 2007.
[6] M. Dalton, H.Kannan, andC. Kozyrakis. Raksha: a ﬂexible
information ﬂowarchitecture forsoftware security. In Proc.
of ISCA,2007.
[7] J. Devietti,B.Lucia, L.Ceze,and M. Oskin.Dmp:
deterministic shared memorymultiprocessing. In Proc.of
ASPLOS,2009.
[8] M. Egele,C. Kruegel, E.Kirda,H.Yin, andD. Song.
Dynamic spyware analysis. In Proc.of USENIXATC ,2007.
[9] J. Fidge.Timestamps inmessage-passing systems that
preserve the partialordering. In AustralianComputer
Science Conference , 1988.
[10] C.Flanagan andS.N.Freund. FastTrack: Efﬁcient and
precise dynamic race detection. In Proc.of PLDI ,2009.
[11] C.Flanagan andP.Godefroid. Dynamic partial-order
reduction for model checking software. In Proc.of POPL ,
2005.
[12] M. Ganai. Scalable andprecise symbolic analysis for
atomicityviolations. In Proc.of ASE ,2011.
[13] M. K.Ganai and A.Gupta. Efﬁcientmodeling of concurren t
systems inBMC. In Proc.of SPINWorkshop , 2008.
[14] M. L.Goodstein, E. Vlachos, S.Chen, P.B. Gibbons, M. A.
Kozuch, and T.C. Mowry. Butterﬂyanalysis: adapting
dataﬂow analysis todynamic parallelmonitoring. In Proc.of
ASPLOS,2010.
[15] A.Ho, M. Fetterman,C.Clark, A.Warﬁeld,and S.Hand.
Practicaltaint-based protectionusing demand emulation. In
Proc.of EUROSYS ,2006.
[16] G.Inc. Freshmeat. http://freshmeat.net .
[17] G.Inc. SourceForge. http://sourceforge.net .
[18] A.Lal andT. Reps. Reducing concurrent analysis under a
context bound tosequential analysis. In Proc.of CAV ,2008.
[19] D.Lee, B.Wester,K.Veeraraghavan, P.M. Chen, J.Flinn ,
and S.Narayanasamy. Respec: Efﬁcientonline
multiprocessor replayvia speculation and external
determinism. In Proc.of ASPLOS ,2010.
[20] C.-K.Luk, R.Cohn, R.Muth, H.Patil,A.Klauser,
G.Lowney, S.Wallace,V. J.Reddi, andK. Hazelwood. Pin:
buildingcustomized program analysis tools withdynamic
instrumentation. In Proc.of PLDI ,2005.
[21] D.Marino, M. Musuvathi, andS.Narayanasamy. Literace :
effective sampling for lightweight data-race detection. I n
Proc.of PLDI ,2009.
[22] F.Mattern. Virtualtimeand global states of distribut ed
systems. In Workshop onParallel and Distributed
Algorithms, France , 1988.
[23] M.Musuvathi andS.Qadeer. Chess: systematicstress te sting
of concurrent software. In Proc.of LOPSTER ,2007.
[24] A.C. Myers. JFlow: Practicalmostly-static informati onﬂow
control. In Proc.of POPL ,1999.
[25] J. Newsome and D.Song. Dynamic taintanalysis for
automatic detection, analysis, andsignature generation o f
exploits on commodity software. In Proc.of NDSS , 2005.[26] M. Olszewski,J. Ansel, andS.Amarasinghe. Kendo:
efﬁcient deterministicmultithreading insoftware. In Proc.of
ASPLOS,2009.
[27] C.-S.ParkandK. Sen.Randomized active atomicity
violationdetection inconcurrent programs. In Proc. ofFSE ,
2008.
[28] S.Park,S.Lu,and Y. Zhou. CTrigger: exposing atomicit y
violationbugs from theirhiding places. In Proc.of ASPLOS ,
2009.
[29] S.Park,Y. Zhou, W.Xiong, Z.Yin,R. Kaushik, K.H. Lee,
and S.Lu. PRES:Probabilisticreplay withexecution
sketching on multiprocessors. In Symposium on Operating
Systems Principles , 2009.
[30] E.Pozniansky and A.Schuster. MultiRace: Efﬁcient
on-the-ﬂydata race detectioninmultithreaded C++
programs. In Proc. of Concurrency andComputation:
Practice andExperience , 2007.
[31] Princeton. The parsec benchmark suite.
http://parsec.cs.princeton.edu/ .
[32] S.Qadeer, S.K.Rajamani, andJ. Rehof. Summarizing
procedures inconcurrent programs. In Proc.of POPL ,2004.
[33] F.Qin,C. Wang,Z.Li,H.-s.Kim,Y. Zhou, and Y.Wu. Lift:
A low-overhead practical informationﬂow tracking system
for detectingsecurity attacks.In Proc. ofMICRO ,2006.
[34] E.J.Schwartz, T. Avgerinos, andD.Brumley. All youeve r
wanted toknow about dynamic taint analysis and forward
symbolic execution (butmight have been afraidtoask). In
IEEESymposium on Security and Privacy , 2010.
[35] T.F.Serbanuta, F.Chen, andG.Rosu. Maximal causal
models for multithreaded systems. Technical Report
UIUCDCS-R-2008-3017, Universityof Illinoisat
Urbana-Champaign, 2008.
[36] N.Sinha and C.Wang. Stagedconcurrent program analysi s.
InProc.of FSE ,2010.
[37] Y. Smaragdakis, J.M. Evans, C.Sadowski, J.Yi,and
C.Flanagan. Sound predictive race detection inpolynomial
time.InProc.of POPL ,2012.
[38] G.E.Suh, J.W.Lee, D.Zhang, and S.Devadas. Secure
program execution via dynamic informationﬂow tracking. In
Proc.of ASPLOS ,2004.
[39] O.Tripp, M. Pistoia,S.J.Fink,M. Sridharan, and
O.Weisman. TAJ:effective taint analysis of web
applications. In Proc. ofPLDI ,2009.
[40] K.Veeraraghavan, D.Lee, B.Wester,J.Ouyang, P.M. Che n,
J.Flinn, andS.Narayanasamy. DoublePlay: Parallelizing
sequential logging andreplay. In Proc. ofASPLOS ,2011.
[41] G.Venkataramani, I.Doudalis, Y. Solihin,and M. Prvul ovic.
Flexitaint: A programmable accelerator fordynamic taint
propagation. In Proc.of HPCA ,2008.
[42] C.Wang, R.Limaye, M. Ganai,and A.Gupta. Trace-based
symbolic analysis for atomicityviolations. In Proc.of
TACAS,2010.
[43] D.Weeratunge, X.Zhang, and S.Jagannathan. Analyzing
multicore dumps tofacilitateconcurrency bugreproductio n.
InProc.of ASPLOS ,2010.
[44] W.Xu, E.Bhatkar, andR.Sekar. Taint-enhanced policy
enforcement: A practical approach todefeat a wide range of
attacks. In Proc.of USENIXSecurity Symposium , 2006.
[45] J.Yi,C. Sadowski, andC.Flanagan. SideTrack:
Generalizing dynamic atomicityanalysis. In Proc.of
PADTAD,2009.
[46] H.Yin, D.Song, M. Egele,C.Kruegel, and E.Kirda.
Panorama: capturingsystem-wide informationﬂow for
malware detection and analysis. In Proc.of CCS ,2007.
[47] D.Y. Zhu, J.Jung, D.Song, T.Kohno, and D.Wetherall.
Tainteraser: protecting sensitive data leaks using
application-level tainttracking. SIGOPSOper. Syst. Rev. ,
45:142–154, February 2011.