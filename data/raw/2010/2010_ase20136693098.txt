Dangling References in Multi-conﬁguration and
Dynamic PHP-Based Web Applications
Hung Viet Nguyen, Hoan Anh Nguyen, Tung Thanh Nguyen, Anh Tuan Nguyen, and Tien N. Nguyen
Electrical and Computer Engineering Department
Iowa State University, USA
Abstract —PHP is a dynamic language popularly used in Web
development for writing server-side code to dynamically create
multiple versions of client-side pages at run time for different
conﬁgurations. A PHP program contains code to be executed or
produced for multiple conﬁgurations/versions. That dynamism
and multi-conﬁguration nature leads to dangling references . Spe-
ciﬁcally, in the execution for a conﬁguration, a reference to a
variable or a call to a function is dangling if its corresponding
declaration cannot be found. We conducted an exploratory study
to conﬁrm the existence of such dangling reference errors includ-
ing dangling cross-language andembedded references in the client-
side HTML/JavaScript code and in data-accessing SQL code that
are embedded in scattered PHP code. Dangling references have
caused run-time fatal failures and security vulnerabilities.
We developed DRC, a static analysis method to detect such
dangling references. DRC uses symbolic execution to collect PHP
declarations/references and to approximate all versions of the
generated output, and then extracts embedded declarations/ref-
erences. It associates each detected declaration/reference with a
conditional constraint that represents the execution paths (i.e.
conﬁgurations/versions) containing that declaration/reference. It
then validates references against declarations via a novel dangling
reference detection algorithm. Our empirical evaluation shows
that DRC detects dangling references with high accuracy. It re-
vealed 83 yet undiscovered defects caused by dangling references.
Index Terms —Dangling References; Web Code Analysis
I. I NTRODUCTION
To accommodate multiple usage scenarios andconﬁgura-
tions in Web applications, developers often use a dynamic
scripting language to write server-side code to dynamically
produce multiple versions of client-side pages at run time. A
popular Web language is PHP: 54% of all Web-based projects
in Sourceforge [27] use PHP. A PHP server program contains
the code to be executed or created for multiple conﬁgurations,
usage scenarios, or versions. For example, it contains PHP
code to process different accessing scenarios for different types
of users (e.g. regular or admin users) or Web browsers (Internet
Explorer, Mozilla, or Chrome). A PHP program also contains
client-side code in HTML or JavaScript (JS) embedded in
PHP strings for different versions of client pages such as for
different languages. Thus, parts of a PHP server-side program
will be executed for the same conﬁguration, usage scenario,
or version; while other parts might not. Let us call this the
multi-conﬁguration nature of PHP code.
The multi-conﬁguration nature and dynamism in PHP often
cause Web programmers to make errors in dealing with PHP
code corresponding to different conﬁgurations, scenarios, or
versions. One kind of errors that one could encounter happenswhen the usage/reference to a variable corresponding to a
conﬁguration/scenario/version does not have its respective
declaration in the current execution for that conﬁguration. Let
us call them dangling or undeﬁned reference errors (dangling
references for short). The same occurs with PHP function calls
where an invoked function is undeﬁned in the current run.
To investigate this type of dangling reference errors, we
conducted an empirical study in which we manually examined
477 selected revisions of seven PHP-based Web applications.
We found 103 revisions containing the ﬁxes for a total of 163
instances of such dangling references. Interestingly, we found
the defects caused by the dangling references occurring in em-
bedded code written in HTML, JS, and SQL. In a PHP server
program, client-side code in HTML/JS, and data-accessing
code in SQL are often embedded within PHP string literals and
dynamically generated at run time. Those references can also
be dangling, and we call them dangling embedded references .
For example, a PHP function Fis used to generate an HTML
text input as follows: echo “<input name= “userid” >”. That HTML
userid element is referred to by a JS reference via a DOM-
based syntax as in echo “if (document.loginform. userid .value!=...” . In
this case, both declaration and reference are embedded in PHP
strings. At run time, if the PHP function Fis not invoked
and the JS reference is generated, then that JS reference
will be dangling because the userid element does not exist.
Importantly, there are cross-language references, e.g. from JS
to HTML, PHP to HTML, PHP to SQL, etc.
In brief, such dangling references occur at run time in the
following: 1) references to PHP variables or calls to PHP func-
tions that have not been properly deﬁned (i.e. undeﬁned PHP
variables/functions ), 2) embedded references to unavailable
database ﬁelds in the result sets of SQL queries that were not
retrieved, 3) calls in embedded code to JS functions that were
not declared, and 4) references to generated HTML elements
that have not been initialized in the current execution.
We also found that those dangling references have caused
serious run-time failures ranging from warnings, incorrect
behaviors, to security vulnerabilities such as denial of services,
input validation bypass, and fatal crashes. Thus, it is desired to
detect them early. In a traditional, statically typed language,
a reference is dangling if it does not refer to any program
entity in a static scope of a program. It can be detected at
compile time by a compiler. However, PHP’s dynamism makes
it challenging to statically detect such dangling references, i.e.
statically determining if there exists an execution such that978-1-4799-0215-6/13/$31.00 c2013 IEEE ASE 2013, Palo Alto, USA399
a reference does not have its respective declaration, since a
reference might be dangling only in some conﬁguration(s) or
version(s), and might not be so in others. It is also challenging
to statically decide from PHP code which versions a speciﬁc
embedded declaration/reference generates and if a generated
reference has a respective declaration, since a PHP interpreter
does not analyze multiple generated versions of client code.
In this work, we developed D angling R eference C hecker,
DRC, a static analysis method to detect such dangling refer-
ences in dynamic PHP code. DRC ﬁrst parses a PHP program
and recognizes the declarations/references of PHP variables
and functions. Second, it performs symbolic execution [16]
on PHP code, to create a D-model, a tree-based representation
approximating all possible versions of the generated output,
and then analyzes the texts in the D-model with a special-
ized parser to extract embedded references/declarations in
HTML/JS/SQL. It associates each reference/declaration with
a constraint that represents the symbolic execution path of the
conﬁguration/scenario or the version of client code having that
declaration/reference. Finally, our dangling reference detection
algorithm searches for each reference a corresponding decla-
ration with a matched signature (i.e. belonging to the same
entity) and with a consistent constraint (i.e. belonging to the
same execution path for a conﬁguration or a client version). If
no such declaration exists, the reference is seen as dangling.
Our empirical evaluation on several Web applications shows
that DRC achieves an average of 89% recall (up to 100%)
and 71% precision (up to 80%) in detecting PHP and em-
bedded dangling references. Moreover, it revealed 83 not-yet-
discovered faults caused by such dangling references. Our key
contributions in this paper include:
1) An exploratory empirical study and ﬁndings on a type of
errors caused by dangling PHP and embedded references,
2) The new concept of embedded references in Web code,
3) A static analysis tool to detect dangling PHP and em-
bedded references in multi-conﬁguration, dynamic PHP code,
4) An empirical evaluation on several large, real-world Web
applications to show DRC’s correctness and efﬁciency.
II. A NEXPLORATORY STUDY
Aiming to understand the problem of dangling references in
multi-conﬁguration, dynamic PHP code, we conducted an em-
pirical study on seven PHP-based, dynamic Web applications.
Our key research questions in this study include:
1. Do dangling references in PHP and embedded code exist
in dynamic Web applications?
2. What are the causes of such dangling references?
3. What are the types of failures that they cause?
A. Data Collection and Results
We selected as our subject systems seven active PHP-based
Web projects in SourceForge (Table I) with high popularity
rates and long histories. Column Start shows their starting
dates. To identify the candidate revisions (column Cand.Rev )
that potentially contain the ﬁxes for dangling bugs, we wrote
a program to analyze the commit logs of all revisions (up toTABLE I
SUBJECT SYSTEMS AND REPORTED DANGLING REFERENCES
System History Cand. Dangling PHP Embed
Start Rev Rev Ent Ref Ent Ref
BeehiveForum 04/’02 173 16 12 18 6 6
ImpressCMS 12/’07 65 14 15 19 0 0
MRBS 05/’00 26 13 18 29 0 0
PHP-Fusion 03/’08 42 14 15 19 5 7
PhpWiki 06/’00 37 14 13 21 1 1
SquirrelMail 11/’99 47 17 21 23 0 0
TikiWiki 10/’02 87 15 13 17 3 3
All 477 103 107 146 15 17
function createPermissionControls() { ...
    foreach($permissions as $permission) {
        if (  $this->targetObject->isNew()  ) { // COND1
                if (  isset($icmsModuleConfig['def_perm_' ...])  ) { // COND2
                    $groups_value = $icmsModuleConfig['def_perm_' ...];
                }
        } else {
            $groups_value = $this->targetObject->getGroupPerm(...);
        }
        $groups_select = new XoopsFormSelect(...,  $groups_value  , 4, true); ...
    } ...
}$groups_value = false;253
262
263
264
265
266
267
268
269
270
275
277(a) Source file: /class/icmsform/icmsform.php, revision: 4700
Commit log: #1984939: Creating a new CustomTag: Undefined variable: 
groups_value in file /class/icmsform/icmsform.php line 270fix by 
adding
(b) Execution path that leads to the dangling error: COND1=T ® COND2=F
COND2
DECLT
FCOND1
T
DECLF
REFLine 268 Line 265
Line 270Line 264Line 263DANGLING
Fig. 1. PHP Dangling Reference $group value inImpressCMS at line 270
07/1/12), and selected the ones containing the keywords such
as “dangling”, “dangled”, “undeﬁned”, and “undeclared”. To
remove false positives, we then manually investigated all 477
revisions and collected those that actually contained a ﬁx to
at least one dangling reference error (column DanglingRev ).
The last 4 columns show the numbers of cases that occurred
in PHP code ( PHP) and embedded code ( Embed ). For each
type, columns Entand Refdisplay the number of entities (vari-
ables/functions) having dangling references and the number of
the dangling references, respectively. (One entity might have
multiple references to it.) As seen in Table I, 103 revisions
were reported as the ﬁxes for at least one dangling bug. There
were 163 dangling references, with 146 and 17 being PHP and
embedded ones. Let us explain some examples in the projects
to illustrate different types of dangling references.
B. Examples of Dangling PHP and Embedded References
1) PHP Dangling Reference in ImpressCMS Project at Revi-
sion 4700 (Figure 1a): To create permission controls for dif-
ferent user groups, the function createPermissionControls selects400$result = dbquery(
    "SELECT p.forum_id, p.thread_id, p.post_id, …,
        u.user_posts, u.user_groups, u.user_joined
    FROM ".DB_POSTS." p ...
    WHERE p.thread_id='".$_GET['thread_id']."' AND post_hidden='0' ...
);
while ($data = dbarray($result)) { ...
    echo "...<span class='small'>...".$data['user_posts']."</span>...";
    echo … showdate("shortdate", $data['user_joined']) ...;
    if(time() -  $data['user_lastvisit']  < 180) { echo "..."; } else { echo "..."; } …
}197
198
200
203
206
208
212
262
263
264
341Source file: /forum/viewthread.php, revision: 2600
, u.user_lastvisit
fix by 
adding
Commit log: Undefined index user_lastvisitDANGLINGFig. 2. Cross-language, Embedded Dangling Reference to a SQL Entity
a group based on the value of the variable $groups value (line
270). The variable $groups value is deﬁned earlier depending
on several conditions. If the target object is new ( COND1 = true ,
line 263), the value will be retrieved from a conﬁguration array
(lines 264-266), after the existence of the conﬁguration item is
checked at line 264 ( COND2 ). Otherwise, if the group’s value is
already stored in the target object ( COND1 = false ),$groups value
will be assigned with this stored value (line 268).
As illustrated in Figure 1b, there are three possible execution
paths (corresponding to three scenarios/conﬁgurations) that
lead to the use of the variable $groups value at line 270. In one
of those paths ( COND1 = T and COND2 = F ), the variable is not
deﬁned, and the reference to $groups value at line 270 becomes
dangling. The commit log below the code in Figure 1a
conﬁrms this error. In the next revision, the developers ﬁxed
the error by adding a default value assignment for $groups value
after line 262 so that it is deﬁned in all possible execution
paths. (In PHP, a variable is deﬁned when it is ﬁrst assigned
with a value.) It is challenging to statically detect this type
of errors since in general, there might exist many paths with
multiple nested ifstatements, and the declarations/assignments
of variables and references could be far apart in multiple func-
tions. Note that the failure occurred only in the conﬁguration
when COND1 = T and COND2 = F , but did not in others.
2) Embedded Dangling References in PHP-Fusion at Revi-
sion 2600 (Figure 2): Besides dangling PHP references, we
found a new type of dangling references in embedded code .
Figure 2 shows a code snippet for typical operations involved
in a database query that selects a set of data rows from one or
more database tables. First, the SQL query (lines 198-206) is
sent to the database server and the query’s result will be stored
in the PHP variable $result (line 197). Then, each row in the
result data set will be retrieved for processing (line 212). For
a data row $data , the data stored in different columns of the
row (e.g., $data[‘user posts’] on line 262 and $data[‘user joined’]
on line 263) will be displayed. Note that the columns available
for selection are speciﬁed in the SELECT part of the SQL query
(lines 198-200). However, on line 264, there is an access to
the SQL column user lastvisit , which was not selected in the
SQL query; thus, the reference to user lastvisit is dangling. We
call it a dangling embedded reference since the reference to a
$result = dbquery("UPDATE ".DB_SETTINGS."
SET settings_value='".(isnum($_POST['news_thumb_w']) ?
 $_POST['news_thumb_w'] : "100")."' ...
$result = dbquery(... (isnum($_POST['news_thumb_h']) ?
$_POST['news_thumb_h'] : "100") ...); ...
$result = dbquery(... (isnum( $_POST['news_photo_w'] ) ?
$_POST['news_photo_w']  : "400") ...); ...
$result = dbquery(... (isnum( $_POST['news_photo_h'] ) ?
$_POST['news_photo_h']  : "300") ...); ...
...
echo "... <input ... name='news_thumb_w' .../>";
echo "... <input ... name='news_thumb_h' .../>"; ...
echo "... <input ... name='news_thumb_w' .../>";
echo "... <input ... name='news_thumb_h' .../>"; ...46
47
48
49
50
51
52
53
54
106
107
110
111Source file: /administration/settings_news.php, revision: 1650
news_photo_w
fix
news_photo_h
fix
Commit log: Fixed undefined variables due to wrong input names reported by Bruno.DANGLINGFig. 3. Cross-language, Embedded Dangling Reference to HTML
column in the query’s result is embedded within a PHP string
‘user lastvisit’ . This error was ﬁxed by adding user lastvisit to the
list of selected columns (line 200). Generally, it is not trivial
to statically detect dangling embedded references since the
references are embedded in the strings resulted from several
computation operations on scattered PHP strings or variables.
3) Cross-Language, Embedded Dangling Reference in PHP-
Fusion at Revision 1650 (Figure 3): The code on lines 106-111
of Figure 3 will generate different HTML input entities named
news thumb wand new thumb h. These input ﬁelds allow users
to specify the width and height of a photo and its thumbnail.
As a user submits this information, the code on lines 46-54 will
access these values using the PHP special variable $POST and
update the database. However, at revision 1650, due to a copy-
and-paste error, the input names on lines 110 and 111 were
accidentally the same as those on lines 106 and 107. Thus, the
input ﬁelds for the height and width of a photo were missing.
Since the HTML inputs news photo wand news photo hare not
deﬁned, the references to them on lines 51-54 are dangling.
Such references are embedded in PHP strings ( ‘news photo h’
and ‘news photo w’) and refer to entities in a different language
(i.e. HTML inputs). As seen, the developers ﬁxed it by
changing the duplicated names news thumb wand new thumb h
tonews photo wand news photo h.
C. Causes and Effects
To learn more about the causes of those dangling references,
we examined the commit logs and changed code in those cases.
The prominent reasons include:
1. Developers manually renamed the entities and missed
an instance. For example, in the ﬁle start left.php at revision
1875 of Beehive Forum , the variable $thread [‘id’] was renamed
to$thread [‘ID’] . A reference at line 156 was not changed, thus,
became dangling. It was ﬁxed at revision 1876. This suggests
a need for better tool support for Web code refactoring.
2. Developers refactored code. After the code was restruc-
tured and a portion was moved, a variable assignment/declara-
tion is not executed while its reference still is (i.e. making the
declaration and reference belong to two different scenarios).
Thus, that reference becomes dangling.4013. Errors due to copy-and-paste: see the example in Fig-
ure 3. The input names at lines 110-111 were not modiﬁed
consistently, leading to dangling references at lines 51-54. This
calls for a tool to help make consistent changes in cloned code.
4. The execution condition of a reference is not consistent
with that of its declaration: a declaration and its reference are
for different conﬁgurations (Figure 1).
5. Developers used a wrong or mistyped entity.
6. The ‘include’ statement of a ﬁle containing a declaration
was misplaced such that it was not executed, making its refer-
ences dangling. Similar to case 2 except that the declaration of
a function is in a ﬁle and included at a wrong location, making
it belong to a different scenario than that of the function calls.
To learn about the system failures caused by those dangling
references, we examined the logs and the corresponding code.
We found that they have caused run-time failures including:
1. Fatal errors and crashes : There were a total of 35
reported cases in which such dangling references (including
undeﬁned functions) have resulted in fatal errors.
2. Security vulnerabilities : Developers have recorded in the
commit logs that such errors caused failures related to security
such as denial of service (e.g. “...preventing the users accessing
the forum” in Beehive Forum ), and input validation bypass (e.g.
the login scheme in PHPWiki ).
3. Incorrect and unexpected behaviors: In general, the
semantics of the Web program is broken as a reference or
a function call cannot be used properly.
Conclusions. Our results conﬁrmed that PHP and embedded
dangling references (including undeﬁned functions) exist in
PHP Web applications due to several causes, and are a
serious defect leading to run-time failures. To address that,
we introduce DRC, a method to statically detect such dangling
references. Let us ﬁrst explain important concepts in DRC.
III. I MPORTANT CONCEPTS
DRC focuses on speciﬁc types of server-side elements and
client-side elements . The former ones include PHP variables
and functions, SQL ﬁelds and tables. The latter ones include
HTML elements (forms, inputs, URLs, etc.) and JS variables
and functions. An entity is an element with a name or an ID.
Referencing is done via the elements’ names or IDs.
Adeclaration of an entity is the code where the entity is
created/assigned. A reference to an entity is the code where
the entity is referred to. A conﬁguration/scenario is deﬁned
by a set of conditions on the program input. A conﬁguration/s-
cenario has its corresponding execution, which must satisfy its
conditions. It is at run time and it differs from conditional
compilation where a conﬁguration has corresponding static
code produced after pre-processing. A declaration/reference to
a client-side entity (HTML/JS) or to an SQL entity might be
embedded within PHP code. It appears in a certain version
of the output of the PHP program that is produced via
a particular execution of the program. The corresponding
location in PHP code responsible for generating a client-side
declaration/reference or SQL element is called an embedded
declaration/reference . For example, in Figure 3, line 106TABLE II
DECLARATIONS /REFS OF CROSS -LANGUAGE , EMBEDDED ENTITIES
Declaration Reference
Lang. Type Example Lang. Type Example
HTML By name <input name=‘ userid ’>JS By DOM document.
loginform. userid
PHP Pre-deﬁned $REQUEST
var [‘ userid ’]
HTML By ID <div id=‘ myid ’> JS By DOM document.get
ElementById(‘ myid ’)
HTML query <a href=‘index.php? PHP Pre-deﬁned $GET[‘ lang’]
string lang=en’> var
JS Func function validate ()f...gJS Func call <form...onsubmit=
Decl ‘...validate ();’>
SQL Table col SELECT name FROM... PHP By arrays $row[‘ name ’]
creates an HTML text input element named news thumb w.
Line 47 contains a reference to it in $POST[‘news thumb w’].
When an element is referred to without proper declaration,
it is called a dangling reference . An embedded reference Re
(Table II) is said to refer to an embedded declaration Deif
and only if at a particular version of the output of the PHP
program, the reference Rgenerated from Rerefers to the
declaration Dgenerated from De. Similarly, a non-embedded
reference Ris said to refer to an embedded declaration Deif
Rrefers to the declaration Dgenerated from De.
A (path) constraint for a declaration/reference is a set of
conditions on the program state which needs to be satisﬁed
for that entity to be exercised in an execution. Besides the
constraint for an execution corresponding to a conﬁguration/s-
cenario, there is also a constraint for an execution to produce
a version of client-side code. If a declaration/variable is used
in a conﬁguration or used to create a version of client code,
its constraint is the constraint for that conﬁguration/version.
Importantly, we will match the constraints of declarations/ref-
erences to detect dangling references (Section VII).
IV. PHP E NTITY DETECTION AND CONSTRAINTS
Let us present how DRC detects PHP entities (decla-
rations/references). PHP code is symbolically executed via
PhpSync [16] and entities are identiﬁed as follows.
Declarations of PHP entities. According to PHP language
manual [28], a PHP variable is considered as declared when
it is assigned with a value in a program execution such as in
an assignment expression, a parameter of a function call, or
a running variable of a forstatement. For a PHP function, its
declaration is the code location where the function is deﬁned.
References of PHP entities. When a PHP variable appears in
non-declaring locations (e.g., the variable is not assigned with
any value, but its value is accessed for an operation), DRC
considers the variable’s location in the code as the reference
to the corresponding variable. Similarly, an invocation of a
PHP function is considered as a reference to that function.
Constraints of PHP entities. The constraint for a decla-
ration/reference represents the condition which an execution402TABLE III
EXAMPLE OF DRC’ SENTITY TABLE
Name Location Type D/R Constraints
1. createPermiss-icmsform.php@L253 PHP func Decl TRUEionControls
2. $groups value icmsform.php@L265 PHP var Decl COND1 AND COND2
3. $groups value icmsform.php@L268 PHP var Decl NOT COND1
4. $groups value icmsform.php@L270 PHP var Ref TRUE
1 function addInput($name, $type, $value) f
2 return ‘‘ <input name=‘$name’ type=‘$type’ value=‘$value’ / >’’;
3g...
4 $script = ‘ <script type=‘‘ text / javascript ’’ >
5 function validate () f
6 return (document.loginform. userid .value != n’n’);g
7</script >’;
8 echo $script; ...
9 echo ‘ <form name=‘‘loginform’’ action=‘‘VerifyUser.php’’
10 method=‘‘post’’ onsubmit=‘‘return validate () ;’’ >’;
11 $lang = getLanguageOption();
12 if ($lang != ‘de’) f
13 echo ‘User ID: ’ . addInput(‘ userid ’, ‘ text ’, ‘’)
14 .addInput(‘submitBtn’, ‘submit’, ‘VerifyUser’) ;
15gelsef
16 echo ‘Benutzer ID: ’ . addInput(‘ userid ’, ‘ text ’, ‘’)
17 .addInput(‘submitBtn’, ‘submit’, ‘Uberprufen Benutzer’); g...
Fig. 4. Login Page in Two Languages: An Example for Embedded Entities
needs to satisfy for that declaration/reference to be exercised.
That execution is for a speciﬁc conﬁguration/scenario in the
application. DRC uses path constraints in a symbolic execution
to approximate such constraints. During its symbolic execution
phase, it explores different execution paths of the PHP pro-
gram. When a declaration/reference of a PHP entity is found,
DRC associates it with the current path constraints. Figure 1b
illustrates the constraints of the declarations and references of
PHP variable $groups value in Figure 1a. These constraints and
the PHP entities are stored in an Entity Table (Table III). For
example, the constraint for the declaration of the PHP variable
$groups value at line 265 of the ﬁle icmsform.php in Figure 1a
isCOND1 AND COND2 , where COND1 is$this->targetObject-
>isNew() and COND2 isisset($icmsModuleConﬁg[’def perm’]) .
V. E MBEDDED HTML/JS E NTITY DETECTION
DRC also detects HTML/JS entities embedded in PHP
code. DRC performs symbolic execution on PHP code to
approximate all possible output versions of the PHP code by
a single tree and then detects entities on that tree.
A. D-Model Representation of Program Output
During its symbolic execution with PhpSync [16] to detect
PHP entities (Section IV), DRC creates a tree-based repre-
sentation, called D-model , which approximates all possible
textual outputs of a PHP program. Details on PhpSync can
be found in [16]. Let us illustrate the idea via an example.
Figure 4 shows a simple login page that can be displayed
in either English or German. Figure 5 represents the output
of that PHP page by a D-model rooted at a Concat node. That
SELECTCONCAT
<form name=“loginform” … ><html> ...
function validate() {
  return (...userid.value…); 
} ...
User ID:CONCAT</form>
...</html>
<input name=‘ useridCONCAT$lang != ‘de’NOT ($lang != ‘de’)
’ />Benutzer ID:
<input name=‘ userid ’ />
Line 13 Line 16Fig. 5. D-model Representing the Output of Login.php in Figure 4
1//- - - - - - - - Handling Concat nodes - - - - - - - -
2function parse(Concat concat)
3 for each childNode inconcat.ChildNodes
4 parse(childNode)
5//- - - - - - - - Handling Repeat nodes - - - - - - - -
6function parse(Repeat repeat)
7 parse(repeat.ChildNode)
8//- - - - - - - - Handling Literal nodes - - - - - - - -
9function parse(LiteralNode literalNode)
10 tokens = DRCParser.tokenize(literalNode.toString())
11 DRCParser.parseElements(tokens)
12 //- - - - - - - - Handling Select nodes - - - - - - - -
13 function parse(Select select)
14 state = DRCParser.getCurrentLexicalState()
15 parse(select.FirstBranch)
16 DRCParser.restoreLexicalState(state)
17 parse(select.SecondBranch)
Fig. 6. HTML Parsing on D-model
Concat node represents a concatenation of multiple sub-strings,
three of which are concrete string values (represented by string
literal nodes), and one is a string value selected from two
alternatives (represented by the two sub-trees under the Select
node). These two alternatives correspond to the cases where
the language option of the page equals ‘de’(German) or not.
Each subtree represents the concatenation of other sub-strings.
During the symbolic execution, DRC maintains the mapping
between the D-model’s leaf nodes and their PHP locations.
For example, the literal node userid under the ﬁrst Concat node
of the Select node is mapped to the characters on line 13 of
Figure 4. The mapping is used in the entity detection step.
B. HTML Parsing on D-Model
Given a D-model that represents all possible versions of the
client page, DRC analyzes it to identify HTML/JS elements on
the multi-version client page. We design our HTML parser for
D-model with two key differences from a regular parser:
1. A regular HTML parser works on a single version of the
client page at a time. DRC’s HTML parser parses multiple
versions of the client page via a D-model, thus avoiding the
need to generate these pages explicitly.
2. A regular HTML parser takes as input the complete
source code of a client page, whereas DRC’s HTML parser
takes as input a D-model tree and parses fragmented HTML
code contained in the leaf nodes of the tree.403TAG/TEXTATTR_NAME EQUAL QUOTE
ATTR_VAL<{Name}
OpeningTag</{Name}>
ClosingTag
{Name}
AttrName=
“ or ‘
{Value}
AttrVal” or ’{WhiteSpace}
>
{Text}
Text{Name}
AttrName
/>
ClosingTagFig. 7. State Transitions in DRC’s HTML Parser to Detect HTML/JS Entities
Figure 6 shows DRC’s algorithm to parse a D-model. It
traverses the D-model tree in the left-to-right order and handles
different types of D-model nodes as follows.
1. For a Concat node , DRC visits the child nodes of the
Concat node and parses them sequentially (lines 3-4). The
parser uses the ending lexical state after parsing a child node
as the starting lexical state when parsing the next child node.
2. For a Repeat node (which represents a string value that
can be repeated multiple times), its child node is a D-model
representing the repeated output value. For example, the output
of the following code snippet
for ($i = 0; $i <$num breaks; $i++)
echo ‘‘ <br/>”;
is modeled by a Repeat node whose child node is a Literal node
“<br/>”. Aiming to detect embedded entities, DRC only needs
to analyze the child node of a Repeat node once (line 7).
3. For a Literal node , DRC ﬁrst parses the HTML code frag-
ment contained in the Literal node into HTML tokens (line 10).
DRC has the same parsing strategy as a regular HTML parser
for such HTML fragments except for the parsing of HTML
attributes and their values where HTML entities’ names and
IDs can be found. Figure 7 shows the state transitions of an
automaton to recognize HTML attributes and values. The label
of a transition edge contains the input characters (or regular
expressions) in the ﬁrst line, and the recognized HTML token
in the second line (if any). For instance, given an HTML
fragment <input name=‘username’ . . . >, after reading <input,
the parser transitions from the state TAG/TEXT to the state
ATTR NAME , recognizing an OpeningTag token and expecting
the next characters as an AttrName token.
In the second step (line 11, Figure 6), DRC parses those
HTML tokens to identify HTML elements and their attributes’
names and values. For example, after tokenizing the string
<input name=‘username’ . . . >, it recognizes an HTML input el-
ement with an attribute ‘name’ whose value is ‘username’ . If an
attribute value (representing the name of an HTML entity) is
split up and belong to two leaf nodes, DRC maintains the same
state ATTR V AL to parse the next leaf node. It then detects an
attribute value as an entity’s name by combining constituent
substrings in two leaf nodes after encountering the ending
single or double quote in that next leaf node.
4. For Select nodes , DRC does not derive all combinations
of the two branches of all Select nodes, which would face a
combinatorial explosion. Instead, it considers sequential Select
TAG/TEXT<form
ATTR_NAME EQUALname
ATTR_VAL=‘
TAG/TEXTSELECTCONCAT
<form name=‘loginform’ ></form>
<input name=‘userid’ />$lang != ‘de’NOT ($lang != ‘de’)
<input name=‘userid’ />
Line 13
Figure 4ATTR_VALloginform
’ >
TAG/TEXT<input name=‘
ATTR_VALuserid
ATTR_VAL’ />
TAG/TEXT
TAG/TEXT</form>Merge branchesLine 16
Figure 4ATTR_VALuserid
ATTR_VAL TAG/TEXT<input name=‘ ’ />Line 13
Figure 4Line 16
Figure 4(a) D-model of Login.php (simplified)
(b) HTML parsing on D-model
$lang != ‘de’
NOT ($lang != ‘de’)Split branchesFig. 8. Parsing Multiple Output Versions to Detect HTML/JS Entities
nodes as independent and parses each of them individually. For
aSelect node, DRC records the lexical state before parsing
the ﬁrst branch (lines 14-15, Figure 6), and after that it
backtracks to that state to continue parsing the other branch
(lines 16-17). After visiting the two branches of a Select node,
it maintains only one lexical state, which is shared between
them, to continue parsing the next D-model node. The two
lexical states after parsing two branches are usually the same
since the HTML code fragments in the two branches need to
ﬁt with the same HTML code that follows right after them.
Even when the two branches contained HTML elements of
different types (e.g., one branch has an HTML form, and the
other is an HTML table), the two branches would still end with
the same state TAG. Thus, the number of traversed branches is
only linear to the number of Select nodes in the D-model.
Let us illustrate such parsing process via an example. The
D-model in Figure 8a is a simpliﬁed version of the D-
model of Login.php (Figure 5). DRC begins by visiting the
ﬁrst literal node under the Concat node and parses the string
<form name=‘loginform’ >. At this step, it recognizes an HTML
<form>tag element with the name loginform . When parsing the
two branches of the Select node, it ﬁnds two <input>entities
with the same name ‘userid’ . These two HTML input entities
belong to the HTML form entity ‘loginform’ but correspond to
two different versions of the client page. Using the mapping
information stored in the D-model, the two names ‘userid’ of
the entities are then mapped to their corresponding locations
in the server code (lines 13 and 16 of Figure 4a).
C. Extracting Client-Side Entities
During the parsing of the D-model, DRC collects client-side
declarations/references into the Entity Table as follows:
1. Declarations of HTML entities. HTML entity declara-
tions are identiﬁed by the ‘name’ or‘id’attributes of HTML
elements, or can be found in HTML query strings. For404instance, the HTML code <input name=‘userid’... / >speciﬁes a
declaration of an HTML input named ‘userid’ .
2. Declarations and references of JS entities, and JS
references to HTML entities. While parsing HTML code,
DRC extracts any JS code embedded in it. These locations
include HTML <script>tags and HTML event handlers (e.g.
onload ,onclick ). We customized Eclipse’s JS parser to detect
from JS code any declarations/references of JS entities (i.e.
function declarations/calls), or JS references to HTML entities
(via HTML DOM syntax, e.g. document.getElementById ).
Scopes of client-side entities. The client-side entities except
HTML input entities have a global scope since they can be
directly accessed from anywhere in the client- or server-
side code. For an HTML input, its scope is deﬁned by the
HTML form that it belongs to. If two HTML input declarations
with the same name are in different HTML forms/scopes,
they will deﬁne two different entities. Similarly, the JS code
document.form1.userid and document.form2.userid speciﬁes two
references to different HTML input entities with the same name
userid (one belongs to form1 and the other belongs to form2 ).
Constraints of client-side entities. Similar to the path con-
straints of PHP entities, the constraints of HTML/JS entities
are the conditions in the symbolic execution that generate
the entities. For example, the constraint for the userid HTML
input at line 13 of Figure 4 is $lang!=‘de’ . That is, that HTML
input will be generated in a version of client-side code when
the language option is not German. Therefore, for a client-
side declaration/reference, DRC constructs its constraint by
combining (via the AND boolean operator) all the conditions
at the Select nodes in the D-model’s path that leads to the
literal node containing that declaration/reference.
PHP references to HTML entities. PHP references to HTML
entities can be found in pre-deﬁned PHP variables such as
$REQUEST ,$POST , or $GET. For example, $GET[‘userid’] is
a reference to the HTML entity ‘userid’ . For PHP references to
HTML, their scope is global and no constraint is maintained.
VI. E MBEDDED SQL E NTITY DETECTION
A dynamic Web application often contains SQL code em-
bedded within PHP strings and stored in variables. A PHP
program does not produce SQL code to be displayed/run in a
browser. Instead, it forms an SQL query via one or multiple
PHP expressions and string literals and passes it to a database
engine to be executed. The procedure to retrieve and display
data from a database via SQL queries is as follows:
1.Sending an SQL query to a database : To do so, a PHP
function, e.g. mysql query , is executed. To get data from a
database table, the SQL command SELECT is used (e.g. SEL-
ECT column name(s) FROM table name ). The result is a record
setcontaining the table’s data and is stored in a PHP variable.
2.Accessing data records/rows : A PHP function, e.g.
mysql fetch array, is called on the record set to access its
records/rows. Each call returns a single row, which is often
stored in an array. The data in a column of a given row can
D8D7D6D5 D4D3D2 D1
$result = mysql_query("SELECT name FROM products WHERE pid = " . $_GET['pid']);
$product = mysql_fetch_array($result);
$result = mysql_query("SELECT name FROM vendors WHERE vid = " . $_GET['vid']);
$vendor = mysql_fetch_array($result);
echo 'Product Name: ' . $product['name'] 
. 'Vendor Name: ' . $vendor['name'] ;data dep.
1
2
3
4
5Fig. 9. Embedded SQL entities: D1, D4, D7, D8
then be accessed by using the column name as a key of the
corresponding PHP array containing the data row.
Figure 9 illustrates those steps. The PHP code with SQL
queries is aimed to display a product name and a vendor name
given their IDs. In step 1, after the SQL queries are sent to look
up the two database tables products and vendors , the returned
results are stored in the variable $result (lines 1 and 3, res-
pectively). In step 2, the function mysql fetch array is called to
get a row in the returned record set, and the results are stored
in the associative arrays $product and $vendor (lines 2 and 4).
Then, the names of the product and the vendor are printed out
using the keys name of the corresponding arrays (line 5).
In the above process, the ﬁrst step can be viewed as the
declaration of a record set returned from a SQL query, whereas
the second step speciﬁes the references to the data column in
the record set. The deﬁnitions of SQL entities, declarations
and references are based on such a record set as follows.
Deﬁnition 1 (SQL entity) .An SQL entity is a data column in
the record set returned from an SQL SELECT query.
Deﬁnition 2 (SQL entity declaration) .The declaration of an
SQL entity is a column name or an alias column name in the
record set corresponding to the SQL entity.
Deﬁnition 3 (SQL entity reference) .A reference to an SQL
entity is a key in an associative array which speciﬁes a column
name of the record set that is stored in the array.
For example, the identiﬁers name at D1 and D4 in Figure 9
are the declarations of two SQL entities. The array keys name
at D7 and D8 are references to those SQL entities, respectively.
Scopes SQL Entities. It is possible that two SQL references
having the same name could refer to different SQL entities.
For instance, in Figure 9, the two references at D7 and D8 use
the same identiﬁer name but refer to two different entities at
D1 and D4, since they are involved with two different record
sets returned at D2 and D5, respectively. To distinguish such
SQL references, DRC takes into account their program scopes.
Deﬁnition 4 (SQL entity scope) .The scope of an SQL entity,
declaration, or reference is the life time of the corresponding
record set of the SQL entity during the execution.
By this deﬁnition, a newly-created record set deﬁnes new
scopes for one or multiple SQL entities. The SQL declaration
and references of an SQL entity have the same scope deﬁned4051Decls =;// Set of SQL declarations
2Refs =;// Set of SQL references
3function DetectSQLDeclsAndRefs(PHP expression E)
4 switch E
5 caseresult =mysql query (sql):
6 NewDecls = ParseDModel( sql) // Detect SQL decls
7 Decls =Decls [NewDecls // Store detected SQL decls
8 scope =new Scope( idE) // Handle scopes
9 for each Decl inNewDecls
10 Decl .Scope = scope
11 result .Scope = scope
12 caserow =mysql fetch array (result ):
13 row.Scope = result .Scope // Record data dep. via scopes
14 caserow[Ref]:
15 ifrow.Scope is deﬁned
16 Refs =Refs [Ref // Store detected SQL refs
17 Ref.Scope = row.Scope // Handle scopes
18 end
Fig. 10. SQL Declarations/References Detection Algorithm
by the record set of the SQL entity. In that scope, the SQL
declaration has effect and SQL references are valid to refer to
the entity. For example, the declaration at D1 and references
at D2, D3, and D7 belong to the same scope deﬁned for the
data column name of the record set returned by the query
at line 1. DRC will determine that they belong to the same
scope via their data dependencies. Scopes corresponding to
different record sets are different. For example, the SQL
declaration/references at D4, D5, D6, D8 belong to another
scope for the query at line 3. Since the two references at D7
and D8 are in different scopes, they refer to different SQL
entities despite using the same identiﬁer name .
SQL Entity Detection Algorithm. To extract SQL entities
embedded in PHP code, DRC looks for PHP expressions and
variables that access the data retrieved from the database and
analyzes their data dependencies. Figure 10 shows our em-
bedded SQL declaration/reference detection algorithm. DRC
symbolically executes a PHP program and handles specially
for three types of expressions relating to accessing database
data. First, at a PHP mysql query statement (line 5), it computes
the D-model for its SQL query. Then, it uses a simple SQL
parser similar to its HTML parser to identify SQL entity
declarations in the D-model (lines 6-7). These declarations are
the column names found in the SELECT part of an SQL SELECT
query (e.g., SELECT name FROM products ) or alias column names
found in the ASpart (e.g., SELECT product name AS name FROM
products ). Newly-found declarations are associated with the
scope deﬁned by the returned record set (lines 8-11).
Second, as a row in the record set is accessed (via the func-
tions mysql fetch array,mysql fetch row, or mysql fetch assoc ),
DRC records data dependency by assigning the scope of the
returned array with that of the record set (lines 12-13). Third,
for an array access, DRC ﬁrst checks the array’s scope to see
whether it is a record set returned from a database query (line
15). In that case, DRC identiﬁes the key in the array access
as a new SQL reference and associates it with the scope of
the array (lines 16-17). The scopes for those SQL entities are
stored in DRC’s Entity Table . The constraints of SQL entities
are built similarly to those for PHP entities (Section IV).VII. D ANGLING REFERENCE DETECTION ALGORITHM
A. Overview
After collecting all declarations/references and constraints
in the Entity Table , DRC matches each reference against decla-
rations to check if it is dangling.
A reference and a declaration are considered signature-
matched if they have the same signature (consisting of their
name, type, and scope). As seen in Table III, a reference (e.g.
in row 4) might signature-match with multiple declarations
having different constraints (e.g. in rows 2 and 3) because
they appear in different execution paths. To perform matching,
DRC ﬁrst combines all declarations having the same signature
into a single meta-declaration with its constraint being the
union of their constraints. The unioned constraint represents
the program conditions of all possible executions in which
the declaration appears . Thus, the unioned constraint for a
declaration represents the program conditions for all con-
ﬁgurations or all versions of the output client-side code in
which that declaration occurs . For example, DRC combines
the two declarations in rows 2 and 3 in Table III into one meta-
declaration, whose constraint is (COND1 ^COND2) _(:COND1) .
Let us call those meta-declarations as declarations for short.
A reference rand a declaration dare considered constraint-
matched if in any program execution where rappears, dalso
appears. In other words, let C(r)andC(d)be the constraints
ofranddrespectively, then the condition for randdto be
constraint-matched can be expressed as C(r))C(d)(1).
Deﬁnition 5 (Dangling Reference) .If a reference rdoes not
both signature-match and constraint-match with any declara-
tiond, then ris dangling.
There are two cases of dangling reference: either there exists
no declaration dwith the same signature as r; or such a
declaration exists, but condition (1) is not satisﬁed with certain
inputs and program states. That is, in the second case, there
exist some program inputs and states that satisfy C(r)but not
C(d). Equivalently, we have the following dangling condition :
C(r)^ :C(d)
B. Detailed Algorithm
Figure 11 shows our algorithm to detect dangling references.
First, DRC combines all entity declarations with the same
signatures (line 2, Figure 11a). For two declarations having
the same signature, the combination is done by updating one
declaration with their combined (unioned) constraints (line 4
of Figure 11b), and removing the other from the EntityTable
(line 5). After this step, the EntityTable contains the entity
declarations with unique signatures.
Next, DRC searches for dangling references in the Entity
Table . For each reference, it ﬁrst checks if a declaration with
the same signature exists (line 4, Figure 11a). If no such
declaration is found, the reference is detected as dangling (line
8). Otherwise, DRC checks their constraints via the dangling
condition to determine if the reference is dangling (lines 5-6).406(a) Detecting Dangling References
1function DetectDanglingReferences()
2 CombineEntityDeclarations()
3 foreach RefrinEntityTable
4 ifexists Decl dsuch that Sig(d) == Sig( r)
5 ifSatisﬁable (Constraint( r) AND NOT Constraint( d))
6 ReportDangling( r)
7 else
8 ReportDangling( r)
(b) Combining Entity Declarations
1function CombineEntityDeclarations()
2 foreach Decl x inEntityTable
3 foreach Decl y inEntityTable such that Sig(y) == Sig(x)
4 Constraint(x) = Constraint(x) OR Constraint(y)
5 Remove y from EntityTable
Fig. 11. Dangling Reference Detection Algorithm
Finding a solution to the constraint satisfaction problem
(line 5, Figure 11a) is of high complexity as the variables in the
constraints can be PHP numbers, strings, or objects, which can
take on inﬁnite numbers of values. To approximately solve that
constraint satisfaction problem, DRC ﬁrst transforms it into
the boolean satisﬁability problem. That is, it transforms the
constraint expression into a boolean formula with the heuristic
that the predicates are boolean variables whose values are
either true orfalse, and are independent of each other. For
instance, the constraint $lang != ‘de’ ^(:($lang != ‘de’) _$action ==
‘edit’) is transformed into x^(:x_y), assuming that xandyare
independent and atomic boolean variables (‘atomic’ means that
the variable itself is not a boolean formula of other variables).
Thus, the number of possible combinations of values is far
less than that of all arbitrary inputs of the PHP page.
In a PHP Web application, the number of options/conﬁgura-
tions is not high. Therefore, although the number of operands
in the transformed formula might be large, the number of
atomic variables is often small. For example, the expression
x_(:x_y)^(x_:y)has ﬁve operands but only two atomic
variables xandy. In our current implementation, for a small
number of variables, DRC tries different combinations of the
variables’ values to decide if the formula is satisﬁable with a
set of input values. Otherwise, a constraint solver is used.
Let us illustrate our algorithm via Table III. First, DRC
combines all declarations of $groups value (rows 2 and 3), and
their combined constraint is (COND1 ^COND2) _(:COND1) . The
reference $groups value in row 4 (whose constraint is True) is
signature-matched with the newly combined declaration. To
check whether they are also constraint-matched, DRC tests
the satisﬁability of the expression: True^ :(COND1 ^COND2 _
:COND1) , which is translated into True^:(x^y_:x). Since
the expression evaluates to True withx=True andy=False , the
dangling condition holds. Thus, DRC detects that the PHP
reference $groups value in row 4 is dangling in a conﬁguration
with COND1=True and COND2=False .
VIII. E MPIRICAL EVALUATION
Let us present our empirical studies to evaluate DRC’s
accuracy in detecting dangling PHP and embedded references.TABLE IV
DRC’ SDETECTION ACCURACY
System Corr Incor Miss Pre% Rec% New
BeehiveForum 16:22 5:12 4:4 76%:65% 80%:85% 2:2
ImpressCMS 19:25 5:12 2:2 79%:68% 90%:93% 6:8
MRBS 37:50 7:14 3:5 84%:78% 93%:91% 22:26
PHP-Fusion 29:51 9:23 0:0 76%:69% 100%:100% 9:25
PhpWiki 13:24 2:6 4:5 87%:80% 76%:83% 3:7
SquirrelMail 21:26 6:8 4:4 78%:76% 84%:87% 4:7
TikiWiki 16:23 6:16 5:5 73%:59% 76%:82% 5:8
All 151:221 40:91 22:25 79%:71% 86%:89% 51:83
A. Dangling Reference Detection Accuracy
In this experiment, we used the same data as in the study
presented in Section II. During that study, from the commit
logs and source code, three human subjects identiﬁed the
cases of dangling PHP and embedded references reported by
developers in those systems. We used them as the oracle. We
ran DRC on those systems and manually checked the results. If
the detected dangling cases are covered those in the oracle, we
counted them as correct ones. If DRC reported a dangling case
that was not in the oracle, we manually veriﬁed if it is a truly
incorrect case or a newly discovered one (not yet reported).
We then computed precision and recall. Precision is the ratio
between the number of correctly detected cases over the total
number of detected ones. Recall is the ratio between the
number of correctly detected ones over the number of cases.
Table IV shows the results. Columns Corr,Incor, and Miss
show the number of dangling cases that were correctly/incor-
rectly detected, and missed by DRC. Since an entity might
have multiple references, in each table cell, two numbers are
reported: the ﬁrst one is the number of dangling entities and
the second is the number of dangling references. As seen, DRC
is accurate in dangling reference detection with an average of
89% recall (up to 100%) and 71% precision (up to 80%). De-
tection precision for dangling entities is higher. Interestingly,
DRC discovered 83 not-yet reported cases (column New). We
manually veriﬁed them as correct detection cases. DRC is also
efﬁcient. Detection time is typically less than two seconds
per PHP ﬁle. Thus, our solution for matching constraints in
the detection algorithm is practical. DRC’s demonstration and
results are available at [32], [17]. Let us explain a few correctly
detected cases in addition to those in Section II.
1) PHP Dangling References in MRBS at Revision 590
(Figure 12): In addition to detecting the dangling reference
$typematch (not shown) reported in the commit log, DRC also
found three other dangling ones that were not reported at re-
vision 590 : the three references to $From day,$From month , and
$From year on line 368 are dangling since they are initialized
only in the elsebranch of the ifstatement on line 316. As shown
in the ﬁx, this was corrected 210 revisions later by adding
the variables’ initializations before line 316. Thus, DRC could
have helped developers detect those dangling errors early.
2) PHP Dangling Reference in ImpressCMS at Revision
3883 (Figure 13): Since the condition where $cat arris deﬁned407if (isset($areamatch)) { ...
    $areamatch = unslashes($areamatch); ...
} else { …
    $From_day = $day;
    $From_month = $month;
    $From_year = $year; …
} ...
if ( $pview != 1 ) { …
    genDateSelector("From_", $From_day, $From_month, $From_year); ...
}316
320
335
343
344
345
350
361
368
443Source file: /web/report.php, revision: 590
$From_day = get_form_var('From_day', 'int');
$From_month = get_form_var('From_month', 'int');
$From_year = get_form_var('From_year', 'int');fix by adding
(rev800)
Commit log: - fixed bug $typematch, variable undefinedDANGLINGFig. 12. Newly found PHP dangling references in MRBS at revision 590
function createcat($cid = 0) { ...
    if (  $cid  ) { ...
        $cat_arr = $xoopsDB -> fetchArray($xoopsDB -> query($sql)); ...
    } else {
        $groups = true;
    } ...
    if ( $totalcats > 0 ) { ...
        $mytreechose -> makeMySelBox(..., "title",  $cat_arr['pid'] , 1, "pid"); ...
    } ...
}24
48
50
70
71
72
80
83
86
193Source file: /modules/mytube/admin/category.php, revision: 3883
$totalcats > 0 $cid
$totalcats > 0 && $cid
fix
Commit log: Fixed undefined cat_arr and Delete button not working in modifying formDANGLING
Fig. 13. PHP dangling reference $cat arrinImpressCMS at line 83
(line 48) and the condition where $cat arris accessed (line
80) do not match, there exists an execution where the variable
$cat arris undeﬁned (i.e., $cid=F and $totalcats >0). As shown
in the ﬁx, developers added the check on $cidto the condition
at line 80 so that $cat arris guaranteed to have been initialized
whenever it is accessed. DRC was able to detect this case.
Limitations. We analyzed the inaccurate cases and identiﬁed
the following limitations. First, there exist cases where our
symbolic execution could not resolve the name of an included
ﬁle, leading to incorrect identiﬁcation of dangling references.
Second, DRC does not consider the order of declarations and
references, which could potentially cause inaccuracy. Third,
our algorithm to ﬁnd a solution for constraints also causes
inaccuracy. Our symbolic execution to approximate the output
created some missed embedded entities. Finally, DRC cannot
handle the cases of evalto generate a portion of code.
IX. R ELATED WORK
A related work to DRC is TypeChef [29], which has a
variability-aware parser and a method for type checking in C
code containing conditional compilation in #ifdef . The condi-
tional compilation is similar in nature as the conditions in PHP
for multiple conﬁgurations/scenarios, or versions of the client
code. In TypeChef, constraints are associated to code portions,
and the parser derives the combinations for correct parsing.
In comparison, DRC has key differences. First, client code
is dynamically generated, while C code is produced after
the pre-processing of conditional compilation. To address
that, DRC uses symbolic execution. Second, the embeddeddeclarations/references occur only in PHP code. This requires
DRC to have its specialized parsers on D-model to detect
HTML/JS/SQL entities. Finally, the cross-language references
in Web code and especially SQL entities add a new dimension.
Minamide [15]’s string analyzer approximates a PHP page’s
output via a context-free grammar. Wang et al. [22] use a
similar string analyzer to approximate the output and identify
the constant strings visible from a browser for translation.
Wassermann and Su [23] combines tainted information ﬂow
with string analysis to detect cross-site scripting. Those works
do not need to handle the constraints for multiple output
versions and cross-language references as in DRC. Halfond
and Orso [8] introduce a static analysis to identify parameter
mismatches between the interfaces of Web components. They
also build an approximation of all possible generated pages.
Gould et al. [7] propose a static program analysis method to
check the correctness of dynamically generated query strings.
PHP static analysis tools [33] (e.g. PHPLint [34]) detect
only PHP undeﬁned variable errors. They used static scoping,
thus, cannot address dangling at run time in PHP. They
cannot detect dangling references to undeclared entities in
other languages (HTML/JS/SQL) and undeﬁned PHP func-
tions as in DRC. There are also compiling approaches for
PHP (PyPy [30] and HipHop [31]). For JS, Saxena et al. [21]
provides a framework for symbolic execution. Many authors
introduced type inferencing in JS code [1], [9]. Several ap-
proaches were proposed to deal with evalin JS code [18], [10].
Clark and Tratt [5] give a formulation for embedded code.
There exist dynamic approaches for fault localization in a
dynamic Web application. Apollo [2], [3] combines a variation
of Tarantula [12] with the use of dynamic output mapping
for PHP programs in which the PHP echo/print statements are
recorded via an instrumented interpreter and are rated higher in
suspiciousness. Clark et al. [4] propose a variation of Tarantula
to localize faults in an SQL command embedded in JSP code.
There are several approaches for fault localization in tradi-
tional code. Many of them rely on changing program states at
selected points in the execution of a failing test and observing
the states’ differences or correlating them to failure [11], [25],
[6], [14], [19], [26]. Other approaches apply statistical metrics
on program entities based on their coverage in passing/failing
tests to assign suspiciousness scores [12], [13], [20].
X. C ONCLUSIONS
This paper presents an empirical study on dangling PHP and
embedded references, and DRC, a static analysis technique to
detect them. DRC utilizes symbolic execution to produce D-
model tree to approximate all versions of possible generated
output. With a specialized parser for D-model, it extracts
and validates references against declarations via our detection
algorithm. Our evaluation shows that DRC can detect dangling
references with high accuracy. It also revealed several not-yet-
discovered defects caused by dangling references.
ACKNOWLEDGMENTS
This project is funded in part by NSF grants CCF-1018600,
CNS-1223828, CCF-1320578, and CCF-1349153.408REFERENCES
[1] C. Anderson, P. Giannini, and S. Drossopoulou. Towards type inference
for javascript. In Proceedings of the 19th European conference on
Object-Oriented Programming , ECOOP’05, pages 428–452. Springer-
Verlag, 2005.
[2] S. Artzi, J. Dolby, F. Tip, and M. Pistoia. Practical fault localization
for dynamic web applications. In Proceedings of the 32nd ACM/IEEE
International Conference on Software Engineering - Volume 1 , ICSE’10,
pages 265–274. ACM, 2010.
[3] S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. Paradkar, and
M. D. Ernst. Finding Bugs in Web Applications Using Dynamic Test
Generation and Explicit-State Model Checking. IEEE Trans. Softw. Eng. ,
36(4):474–494, July 2010.
[4] S. R. Clark, J. Cobb, G. M. Kapfhammer, J. A. Jones, and M. J.
Harrold. Localizing SQL faults in database applications. In Proceedings
of the 26th IEEE/ACM International Conference on Automated Software
Engineering , ASE ’11, pages 213–222. IEEE Computer Society, 2011.
[5] T. Clark and L. Tratt. Formalizing Homogeneous Language Embeddings.
Electron. Notes Theor. Comput. Sci. , 253(7):75–88, Sept. 2010.
[6] V . Dallmeier, C. Lindig, and A. Zeller. Lightweight defect localization
for java. In Proceedings of the 19th European conference on Object-
Oriented Programming , ECOOP’05, pages 528–550. Springer-Verlag,
2005.
[7] C. Gould, Z. Su, and P. Devanbu. Static Checking of Dynamically
Generated Queries in Database Applications. In Proceedings of the 26th
International Conference on Software Engineering , ICSE’04, pages 645-
654. IEEE CS, 2004.
[8] W. G.J. Halfond and A. Orso. Automated identiﬁcation of parameter
mismatches in web applications. In Proceedings of the 16th ACM SIG-
SOFT International Symposium on Foundations of software engineering ,
FSE’08, pages 181–191, ACM Press. 2008.
[9] P. Heidegger and P. Thiemann. Recency types for analyzing scripting
languages. In Proceedings of the 24th European conference on Object-
oriented programming , ECOOP’10, pages 200–224. Springer-Verlag,
2010.
[10] S. H. Jensen, P. A. Jonsson, and A. Møller. Remedying the eval that men
do. In Proceedings of the 2012 International Symposium on Software
Testing and Analysis , ISSTA 2012, pages 34–44. ACM, 2012.
[11] D. Jeffrey, N. Gupta, and R. Gupta. Fault localization using value
replacement. In Proceedings of the 2008 international symposium on
Software testing and analysis , ISSTA ’08, pages 167–178. ACM, 2008.
[12] J. A. Jones and M. J. Harrold. Empirical evaluation of the tarantula auto-
matic fault-localization technique. In Proceedings of the 20th IEEE/ACM
international Conference on Automated software engineering , ASE ’05,
pages 273–282. ACM, 2005.
[13] B. Liblit, M. Naik, A. X. Zheng, A. Aiken, and M. I. Jordan. Scalable
statistical bug isolation. In Proceedings of the 2005 ACM SIGPLAN con-
ference on Programming language design and implementation , PLDI’05,
pages 15–26. ACM, 2005.
[14] C. Liu, X. Yan, L. Fei, J. Han, and S. P. Midkiff. SOBER: statistical
model-based bug localization. In Proceedings of the 10th European
software engineering conference held jointly with 13th ACM SIG-
SOFT international symposium on Foundations of software engineering ,
ESEC/FSE-13, pages 286–295. ACM, 2005.
[15] Y . Minamide. Static approximation of dynamically generated Web pages.
InProceedings of the 14th international conference on World Wide Web ,
WWW ’05, pages 432–441. ACM, 2005.
[16] H. V . Nguyen, H. A. Nguyen, T. T. Nguyen, and T. N. Nguyen. Auto-
locating and ﬁx-propagating for HTML validation errors to PHP server-
side code. In Proceedings of the 2011 26th IEEE/ACM InternationalConference on Automated Software Engineering , ASE ’11, pages 13–22.
IEEE CS, 2011.
[17] H. V . Nguyen, H. A. Nguyen, T. T. Nguyen, and T. N. Nguyen.
DRC: A Detection Tool for Dangling References in PHP-Based Web
Applications. In ICSE’13 - Demonstration Track . IEEE CS, 2013.
[18] G. Richards, C. Hammer, B. Burg, and J. Vitek. The eval that men
do: A large-scale study of the use of eval in javascript applications.
InProceedings of the 25th European conference on Object-oriented
programming , ECOOP’11, pages 52–78. Springer-Verlag, 2011.
[19] D. Saha, M. G. Nanda, P. Dhoolia, V . K. Nandivada, V . Sinha, and
S. Chandra. Fault localization for data-centric programs. In Proceedings
of the 19th ACM SIGSOFT symposium and the 13th European confer-
ence on Foundations of software engineering , ESEC/FSE ’11, pages
157–167. ACM, 2011.
[20] R. Santelices, J. A. Jones, Y . Yu, and M.-J. Harrold. Lightweight fault-
localization using multiple coverage types. In Proceedings of the 31st
International Conference on Software Engineering , ICSE ’09, pages 56–
66. IEEE Computer Society, 2009.
[21] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song.
A Symbolic Execution Framework for JavaScript. In Proceedings of the
2010 IEEE Symposium on Security and Privacy , SP ’10, pages 513–528.
IEEE Computer Society, 2010.
[22] X. Wang, L. Zhang, T. Xie, H. Mei, and J. Sun. Locating need-to-
translate constant strings in web applications. In Proceedings of the
eighteenth ACM SIGSOFT international symposium on Foundations of
software engineering , FSE ’10, pages 87–96. ACM, 2010.
[23] G. Wassermann and Z. Su. Static detection of cross-site scripting
vulnerabilities. In Proceedings of the 30th international conference on
Software engineering , ICSE ’08, pages 171–180. ACM, 2008.
[24] C. Yilmaz, A. Paradkar, and C. Williams. Time will tell: fault local-
ization using time spectra. In Proceedings of the 30th international
conference on Software engineering , ICSE ’08, pages 81–90. ACM,
2008.
[25] X. Zhang, N. Gupta, and R. Gupta. Locating faults through automated
predicate switching. In Proceedings of the 28th international conference
on Software engineering , ICSE ’06, pages 272–281. ACM, 2006.
[26] X. Zhang and R. Gupta. Cost effective dynamic program slicing. In
Proceedings of the ACM SIGPLAN 2004 conference on Programming
language design and implementation , PLDI ’04, pages 94–106. ACM,
2004.
[27] SourceForge. http://www.sourceforge.net/.
[28] PHP Manual. http://php.net/manual/en/index.php.
[29] C. K ¨astner, P. G. Giarrusso, T. Rendel, S. Erdweg, K. Ostermann,
and T. Berger. Variability-aware parsing in the presence of lexical
macros and conditional compilation. In Proceedings of the 26th Annual
ACM SIGPLAN Conference on Object-Oriented Programming, Systems,
Languages, and Applications , OOPSLA’11, pages 805–824. ACM Press,
2011.
[30] A. Homescu and A. S ¸uhan. HappyJIT: a tracing JIT compiler for PHP.
InProceedings of the 7th symposium on Dynamic languages , DLS ’11,
pages 25–36. ACM, 2011.
[31] H. Zhao, I. Proctor, M. Yang, X. Qi, M. Williams, Q. Gao, G. Ottoni,
A. Paroski, S. MacVicar, J. Evans, and S. Tu. The HipHop compiler for
PHP. In Proceedings of the ACM international conference on Object
oriented programming systems languages and applications , OOPSLA
’12, pages 575–586. ACM, 2012.
[32] DRC Website. http://home.engineering.iastate.edu/~hungnv/Research/DRC.
[33] StackOverﬂow. http://stackoverﬂow.com/questions/4863969/php-source-
code-analyzers.
[34] PHPLint. http://www.icosaedro.it/phplint/.409