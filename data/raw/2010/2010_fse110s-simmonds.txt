Guided Recovery for Web Service Applications
Jocelyn Simmonds, Shoham Ben-David, Marsha Chechik
Department of Computer Science
University of Toronto
Toronto, ON M5S 3G4, Canada
{jsimmond, shoham, chechik}@cs.toronto.edu
ABSTRACT
Web service applications are dynamic, highly distributed,
and loosely coupled orchestrations of services which are no-
toriously dicult to debug. In this paper, we describe a
user-guided recovery framework for web services. When be-
havioural correctness properties (safety and bounded live-
ness) of an application are violated at runtime, we automat-
ically propose and rank recovery plans which users can then
select for execution. For safety violations, such plans es-
sentially involve \going back" { compensating the occurred
actions until an alternative behavior of the application is
possible. For bounded liveness violations, such plans include
both\going back"and\re-planning"{guiding the application
towards a desired behavior. We report on the implementa-
tion and our experience with the recovery system.
Categories and Subject Descriptors
D.2.5 [ Software Engineering ]: Testing and Debugging|
Error handling and recovery
General Terms
Design, Verication
1. INTRODUCTION
Recent years have seen the increased reliance on being
able to conduct business over the Internet. The Service-
Oriented Architecture (SOA) framework is a popular guide-
line for building web-based applications. A SOA-based ap-
plication is an orchestration of services oered by (possibly
third-party) components written in a traditional compiled
language such as Java, or in an XML-centric language such
as BPEL1.
Web services are distributed systems, where partners are
dynamically discovered and are going on- and o-line as the
1http://docs.oasis-open.org/wsbpel/2.0/OS/
wsbpel-v2.0-OS.html
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
FSE-18, November 7‚Äì11, 2010, Santa Fe, New Mexico, USA.
Copyright 2010 ACM 978-1-60558-791-2/10/11 ...$10.00.application runs. Their failures can be caused by bugs in
the service orchestration, e.g., due to faulty logic and bad
data manipulation, or by problems with hardware, network
or system software, or by incorrect invocations of services.
With runtime failures of web services inevitable, infrastruc-
tures for running them typically include the ability to de-
ne faults and compensatory actions for dealing with excep-
tional situations. Specically, the compensation mechanism
is the application-specic way of reversing completed activi-
ties. For example, the compensation for booking a car would
be to cancel the booking.
Existing infrastructures for web services, e.g., the BPEL
engine, include mechanisms for fault denition, for specica-
tion of compensation actions, and for dealing with termina-
tion. When an error is detected at runtime, they typically
try to compensate all completed activities for which com-
pensations are dened, with the default compensation being
the reversal of the most recently completed action. This
approach presents several major problems: (1) The applica-
tion is often allowed to continue running until the fault is
discovered, thus executing and then compensating for a lot
of unnecessary and potentially expensive activities. (2) It
is hard to determine, a priori, the state of the application
after executing compensation mechanisms. (3) There might
be multiple compensations available, based on global infor-
mation (i.e., avoid canceling the ight since it has a dollar
cost associated with it, and try to cancel the hotel instead),
but the automatic application of compensations does not
allow the user of such a system to choose between them.
This paper describes a user-guided recovery framework for
web services, instantiating it on BPEL programs. We con-
centrate on behavioural correctness, and specically, on the
correct interaction between service partners. The overview
of the approach is given in Fig. 1a. Our approach consists of
three phases: Preprocessing, Monitoring and Recovery. It
admits the following user guidance: (I) Application devel-
opers dene a set of behavioral correctness properties that
need to be maintained at runtime, as well as compensation
costs and idempotent service calls (see Sec. 3.2) (II) (Op-
tional) Application users provide criteria for choosing be-
tween possible recovery plans, i.e., based on the plan length,
compensation cost, etc. (III) Application users manually
choose the desired recovery plan among those automatically
computed and ranked by our system.
We consider behavioral correctness properties to be sce-
narios that the system should exhibit and scenarios that the
system should not exhibit. For example, consider a simple
web-based Trip Advisor System (TAS). In a typical scenario,(a)
 (b)
Figure 1: (a) Overview of our approach; (b) a schematic view on plan generation.
a customer either chooses to arrive at her destination via a
rental car (and thus books it), or via an air/ground trans-
portation combination, combining the ight with either a
rental car from the airport or a limo. The requirement of the
system is to make sure the customer has the transportation
needed to get to her destination (this is a desired behaviour)
while keeping the costs down, i.e., she is not allowed by her
company to reserve an expensive ight and a limo (this is a
forbidden behavior). Such desired and forbidden behaviours
can come from use-cases, global invariants, simulation, or
a variety of other sources. They can be expressed in (tem-
poral) logic or in visual notations, such as UML's Sequence
Diagrams [24]. The problem of collecting and expressing
properties has been addressed by many researchers [1,5,15],
and we consider it to be orthogonal to this paper. We also
refer to the specication of negative behaviour as safety
properties, and positive behaviour { as (bounded) liveness
properties . In the interest of space, we further assume that
properties are represented by nite-state monitors.
A description of the desired orchestration and the set of
monitors describing safety and liveness properties are then
passed to the runtime monitoring framework which runs the
monitors in parallel with the application, stopping when one
of the monitors enters its error state. We build on an ear-
lier work of dening and implementing an unintrusive online
framework for runtime monitoring of conversations between
partners [24]. Using high-level properties allows us to detect
the violation, and our event interception mechanism allows
us to stop the application right before the violation occurs,
and enable recovery.
Our main contribution is the development of recovery
plans from runtime errors. Given an application path which
led to a failure and a monitor which detected it, our goal
is to compute a set of suggestions, i.e., plans , for recovering
from these failures. For violations of safety properties, such
plans use compensation actions to allow the application to
\go back" to an earlier state at which an alternative path
that potentially avoids the fault is available. We call such
states \change states"; these include user choices and cer-
tain partner calls. For example, if the TAS system produces
an itinerary that is too expensive, a potential recovery plan
might be to undo the limo reservation (so that the car can
now be booked) or to undo the ight reservation and see if
a cheaper one can be found.
Yet just merely going back is insucient to ensure that
the system can produce a desired behaviour. Thus, in order
to satisfy (bounded) liveness properties, we aim to compute
plans that redirect the application towards executing new
activities, those that lead to goal satisfaction. For example,
if the ight reservation partner fails (and thus the air/ground
combination is not available), the recovery plans would be to
provide transportation to the user's destination (her \goal"
state) either by calling the ight reservation again or by un-
doing the reserved ground transportation from the airport,if any, and try to reserve the rental car from home instead.
The overall recovery planning problem is then stated as fol-
lows:
From the current (error) state in the system, nd
a plan to achieve the goal that goes through a
change state.
This process is shown schematically in Fig. 1b. When there
are multiple recovery plans available, we automatically rank
them based on user preferences (e.g., the shortest, the cheap-
est, the one that involves the minimal compensation, etc.)
and enable the application user to choose among them.
This paper makes the following contributions: (1) We pro-
pose a user-guided framework for recovery from run-time vi-
olations of behavioural properties representing desired and
prohibited conversations between partners in web service ap-
plications. (2) We show the dierence between recovery from
a violation of safety and bounded liveness properties and
propose automated strategies for such recoveries. (3) We
pose recovery problem as a plan generation problem and in
turn reduce it to a SAT instance which allows us to control
the size of the resulting plans and compute multiple plans.
The rest of this paper is organized as follows. We de-
scribe inputs to our system, BPEL models and monitors
representing properties, in Sec. 2. We dene the representa-
tion of BPEL models as Labeled Transition Systems (LTS)
and show how to use these representations for static identi-
cation of change states and goal transitions in Sec. 3. We
briey discuss runtime monitoring in Sec. 4 and describe
our main contribution, recovery for violations of safety and
bounded liveness properties in Secs. 5 and 6 respectively. We
report on our implementation (Sec. 7) and use it to compute
recovery plans for two web service examples (Sec. 8). After
comparing our work with related approaches in Sec. 9, we
conclude in Sec. 10 with a summary of the paper and sug-
gestions for future work.
2. INPUT
Inputs to our system are a BPEL program enriched with
compensation actions and a set of behavioral correctness
properties described by monitors. We describe these below.
2.1 BPEL Programs
BPEL is a standard for implementing orchestrations of
web services (provided by partners) by specifying an ex-
ecutable workow using predened activities. The basic
BPEL activities for interacting with partner web services
are<receive>,<invoke>and<reply>, which are used to
receive messages, execute web services and return values, re-
spectively. The control ow of the application is dened us-
ing structural activities such as <while>,<if>,<sequence>,
<ow>and<pick>.
Fig. 2a shows the BPEL-expressed workow of the Trip
Advisor System ( TAS), introduced in Sec. 1. We use the(a)
(b)
Figure 2: (a) Workow of TAS; (b) Compensation for
booking a ight ( bf).
NetBeans SOA notation2.TASinteracts with four external
services: 1) book a rental car ( bc), 2) book a limo ( bl),
3) book a ight ( bf), and 4) check price of the ight ( cf).
The result of cfis then passed to local services to determine
whether it is expensive ( expF) or cheap ( cheapF ). Service
interactions are preceded by a
 symbol.
The workow begins with <receive>'ing input ( ri), fol-
lowed by<pick>'ing (indicated by
 labeled
 ) either the
car rental ( OnMessage onlyCar ) or the air/ground transporta-
tion combination ( OnMessage carAndFlight ). The latter choice
is modeled using a <ow>(
, labeled
 ) since air ( getFlight )
and ground transportation ( getCar ) can be arranged inde-
pendently, so they are executed in isolation. The air branch
sequentially books a ight, checks if it is expensive and
updates the state of the system accordingly. The ground
branch<pick>'s between booking a rental car and a limo.
The end of the workow is marked by a <reply>activity,
reporting that the destination has been reached ( rd).
Compensation. BPEL's compensation mechanism allows
the denition of the application-specic reversal of com-
pleted activities. For example, the compensation for book-
ing a ight ( bf) is to cancel the booking ( cancelF ); this is
described in BPEL as shown in Fig. 2b.
Compensation handlers (CH) are attached to <scope>
and<invoke>activities (a <scope>activity is used to logi-
cally group activities) and are executed by fault, termination
and compensation via the <compensate >and<compensate-
Scope>activities. The default compensation respects the
forward order of execution of the scopes being compensated:
Ifaandbare two activities, where acompleted
execution before b, then compensate (a;b) is
compensate (b);compensate (a).
Any attempt to compensate a scope for which the CH either
has not been installed, or has been installed and executed,
is treated as executing an empty activity .
2http://www.netbeans.orgWe further extended BPEL to allow users to associate
compensations with dierent costs, e.g., to indicate that
canceling a ight might be signicantly more expensive than
canceling a car. We do this by adding an extra attribute cost
to the denition of <compensationHandler >. For example,
the ight booking compensation dened in Fig. 2b has been
assigned a cost of 9 (out of 10), indicating that this is an
expensive compensation and should be avoided if possible.
2.2 Properties and Monitors
The second input to our system is a set of correctness
properties. As mentioned in Sec. 1, we view the question
of harvesting properties as well as the exact language for
specifying them as orthogonal to our work, and we assume
that properties are expressed as monitors (see Def. 1 be-
low). We dierentiate between monitors representing safety
properties { negative behaviors that should not appear in
the application | and monitors representing liveness prop-
erties { positive behaviors that the system must posses. In
general, liveness properties are violated only by innite be-
haviors and thus are not monitorable [16]. However, BPEL
applications are run-to-completion programs which are ex-
pected to terminate. By the explicit addition of the \termi-
nate" ( TER) event, liveness properties become bounded and
thus are readily monitorable.
For example, the two requirements of the TASsystem
are to make sure that the customer has the transportation
needed to get to her destination (desired behavior), while
keeping the costs down (forbidden behavior). More formally,
they become P1(liveness): \if requested ( ri),TASwill guar-
antee that the transportation booked reaches the customer's
destination ( rd), regardless of the type of transportation cho-
sen", andP2(safety): \the user cannot book both a limou-
sine ( bl) and an expensive ight ( expF)". Property P1is
represented by the monitor A1in Fig. 3a: the property is
satised once the booked transportations reaches the desti-
nation ( rd), and the automaton is in state 4 (colored green
and shaded vertically). If the application terminates before
rd, the monitor moves to the (error) state 3 (colored red and
shaded horizontally).  is the alphabet of the monitor, i.e.,
every event occurring in the application, dened formally in
Sec. 3.1. States 1 and 2 are unshaded and colored yellow to
indicate that P1is neither satised nor violated.
The monitor A2for property P2(see Fig. 3b) goes to the
error state 4 when travel includes booking an expensive ight
and a limo, in any order. All other states are yellow, since
the negative behavior can be detected but its absence cannot
be established. We formalize (colored) monitors below.
Definition 1 (monitor). Amonitor is a 5-tuple A=
(S;;;I;F ), whereSis a set of states, is an alphabet,
SSis a transition relation, and ISandFS
are sets of initial andnal states, respectively.
A statesof a monitor Ais called a sink state if all outgo-
ing transitions from sare self-loops. For example, states 3
and 4 in Fig. 3a and state 4 in Fig. 3b are sinks. We say
thatAaccepts a worda0a1a2:::an 12i there exists
an execution s0a0s1a1s2:::an 1snofAsuch thats02Iand
sn2F. In our case, the accepted words correspond to bad
computations, and the set Fof accepting states represents
error (red) states. A green state is a desired monitor state:
when it is reached, the corresponding property cannot be
violated in the current computation.(a)
 (b)
Figure 3: Monitors: (a) A1, and (b) A2. Red states
are shaded horizontally, green states are shaded ver-
tically, and yellow states are solid.
Definition 2 (Colored Monitor). LetA= (S;;;
I;F)be a monitor, and let KSbe the set of all sinkstates
ofA. Then,8s2Fcolor(s) =red,8s2KnFcolor(s) =
green (all non-accepting sink states), and8s2Sn(F[K)
color(s) =yellow.
Definition 3.Ais a liveness monitor if it includes at
least one green state; otherwise, it is a safety monitor .
We assume that we are given a set SM=fAs
1;:::;As
mgofm
safety monitors and LM=fA`
1;:::;A`
ngofnliveness mon-
itors. As with any other property-based specication, it
is possible that the property list is incomplete (i.e., some
behavioural requirements are not captured) or even incon-
sistent (i.e., satisfying the entire set of requirements is not
possible).
3. PREPROCESSING
Inputs to the preprocessing stage are the BPEL program
B, the set of safety monitors SMand a set of liveness mon-
itors LM. We begin with converting Binto a formal repre-
sentation, L(B), which is a labeled transition system (LTS).
We then enrich it with transitions on compensation actions
to get LC(B)(Sec. 3.1). We formalize change states andgoal
transitions and provide an algorithm for computing these
statically on LC(B) (Sec. 3.2).
3.1 BPEL to LTS
In order to reason about BPEL applications, we need to
represent them formally, so as to make precise the meaning
of \taking a transition", \reading in an event", etc. Several
formalisms for representing BPEL models have been sug-
gested [12, 17, 19]. In this work, we build on Foster's [9]
approach of using an LTS as the underlying formalism.
Definition 4 (Labeled Transition Systems). ALa-
beled Transition System LTS is a quadruple (S;;;I), where
Sis a set of states, is a set of labels, SSis a
transition relation, and ISis a set of initial states.
Eectively, LTSs are state machine models, where transi-
tions are labeled whereas states are not. We often use the
notationsa !s0to stand for ( s;a;s0)2.
[9,10] specify mapping of all BPEL 1.1 activities into LTS.
For example, Fig. 4 shows the translation of the <invoke>
activity bfwhich returns a conrmation number. The activ-
ity is a sequence of two transitions: the actual service invo-
cation ( invoke bf) and its return ( receive bf)3. Conditional
activities like <while>,<if>and<pick>are represented
as states with two outgoing transitions, one for each valu-
ation of the condition. <sequence>and<ow>activities
3Foster's translation uses names to include traceability in-
formation to the BPEL's scopes. We omit these in this paper
for simplicity.
Figure 4: LTS translation of the <invoke>activity
bfand its compensation (bold).
(a)
(b)
(c)
Figure 5: (a) LTS LC(TAS), showing traces t1(dotted)
andt2(dashed); (b) a fragment of L(TAS)A1; (c) a
recovery plan in XML.
result in the sequential and the parallel composition of the
enclosed activities.
The set of labels  of the resulting translation L(B) is
derived from the possible events in the application B: ser-
vice invocations and returns, OnMessage events,<scope>
entries, and condition valuations. It also includes the new
system event TER, modeling termination. The set of states
SinL(B) consists of the states produced by the translation
as well as a new state t. This state is reached from any state
ofSvia a TER event:8s2Snftg;(s;TER;t)2.
In order to capture BPEL's compensation mechanism, we
introduce additional, backwards transitions. For example,
the compensation for bf, specied in Fig. 2b, is captured
by adding the transition 3invoke cancelF ! 1 as shown in Fig. 4.
Taking this transition eectively leaves the application in
a state where bfhas not been executed. We denote by 
an `empty' action, allowing undoing of an action without
requiring an explicit compensation action.
Note that we have made a major assumption that com-
pensation returns the application to one of the states that
has been previously seen. Thus, given a BPEL program B
and its translation to LTS L(B) = (S;;;I), we translate B
with compensation into an LTS LC(B) = (S;[c;[c;I),
where cis the set of compensation actions (including )
andcis the set of compensation transitions.
Fig. 5a shows LC(TAS). To increase legibility, we do not
show the termination state tand transitions to it. Also,we only show one transition for each service invocation, ab-
stracting the return transition and state. In this notation,
the LTS in Fig. 4 has two transitions: 1bf !3 and 3cancelF ! 1.
This allows us to visually combine an action and its com-
pensation into one transition, labeled in the form a=a, where
ais the application activity and  ais its compensation. In
other words, each transition sa=a !tin Fig. 5a represents
two transitions: ( s;a;t )2and (t;a;s)2c.
The<pick>activity (
 labeled
 in Fig. 2a) corresponds
to state 2 of Fig. 5a. The choice between onlyCar andcarAnd 
Flight is represented by two outgoing transitions from this
state: (2;onlyCar;3) and (2;carAndFlight ;6). Since these ac-
tions do not aect the state of the application, they are
compensated by . The<ow>activity (
 labeled
 in
Fig. 2a) results in two branches, depending on the order in
which the air and ground transportation are executed. The
compensation for these events is also .
3.2 Identifying Goal Transitions and Change
States
The second part of the preprocessing phase statically iden-
ties strategic behaviors of the application L(B), aimed to
help nd an ecient recovery plan when a violation is en-
countered (see Sec. 5 and Sec. 6).
3.2.1 Goal Transitions
In order to nd a good recovery plan, we rst need to com-
pute a set of goal transitions , that is, transitions taken by
the application which (immediately) result in satisfaction of
some properties. We compute these on a per-property basis.
Further, recall that only liveness properties can be satised,
which is indicated by the monitor reaching a green state;
safety properties can only be violated. Thus, for each live-
ness monitor A`
i2LM= (Si;;i;Ii;Fi), we are looking for
transitions in L(B) = (S;;;I) corresponding to A`
ienter-
ing its green state(s). To nd those, we compute the cross-
product L(B)A`
i. (s;a;s0)2is agoal transition i9q;q02
Si(s;q)a !(s0;q0)^color (q)6= green^color (q0) = green.
That is,sa !s0corresponds to taking a transition on ainto
a green state of A`
i. The resulting set of goal transitions is
denoted by G(B;A`
i).
For example, consider a fragment of L(TAS)A1shown in
Fig. 5b. The green state of A1is state 4, with transition on rd
leading to it. The only transition in L(TAS)A1satisfying the
above denition is (4 ;2)rd !(5;4), and thus G(TAS;A1) =
f(4;rd;5)g(depicted by tiny-dashed transitions in Fig. 5a).
When computing recovery plans, we need to direct the
application towards taking its goal transitions.
3.2.2 Change States
Given an erroneous run, how far back do we need to com-
pensate before resuming forward computation? If we want
to avoid repeating the same error again, we need the appli-
cation to take an alternative path. States of L(B) that have
actions executing which can potentially produce a branch in
control ow of the application are called change states .
Flow-changing actions are user choices, states modeling
the<ow>activity (since each pass through this state may
produce a dierent interleaving of actions), and those service
calls whose outcomes are not completely determined by their
input parameters but instead depend on the implicit state
\of the world". This characteristics of services is sometimesreferred to as idempotence , since multiple invocations of the
same service yield the same results. Thus, non-idempotent
service calls also identify change states. For example, cheapF
is a call to determine whether a given ight is cheap and, un-
less the specication of what cheap means changes, returns
the same answer for a given ight. On the other hand, bf
books an available ight, and each successive call to this
service can produce dierent results. Non-idempotent ser-
vice calls are identied by the BPEL developer as XML at-
tributes in the BPEL program.
We denote by C(B) the set of all change states in the LTS
of the application B. For example, in the LTS in Fig. 5a,
state 6 corresponds to the <ow>activity and represents
the dierent serialization order of the branches. States 2,
12 and 15 model user choices. Non-idempotent partner calls
arebf,bc,bl, and thus
C(TAS) =f1;2;3;6;7;12;13;15;16;18;23;24g;
identied in Fig. 5a by shading.
A recovery plan should pass through at least one change
state, to allow a change in the execution.
Of course, it is possible that the computed recovery plan
passes through a change state which does not aect its out-
come, i.e., is irrelevant to the encountered error and its x.
We address computation of \relevant" change states in [22].
4. RUNTIME MONITORING
The runtime monitoring phase uses the set of safety ( SM)
and liveness ( LM) monitors to analyze the BPEL program
Bas it runs on a BPEL-specic Application Server.
In [24], we have reported on an implementation of a run-
time monitoring framework within the IBM WebSphere busi-
ness integration products4. The interception mechanism
captures events in  as they pass between the application
server and the program. We use them to update the state of
the monitors and store them as part of the execution trace
T. This process continues until the current event is about
to cause the application termination or entering the error
state of one of the monitors. At this point, we stop the
computation and begin the recovery process.
Formally, for the LTS L(B) = (S;;;I) we build the trace
T=s0a0 !s1a1 !:::an 1 !sn, wheres02Iand8iai2
andsi2S.Tis a successful trace i8Ai2SM[LM,
a0a1:::an 1is rejected by Ai. Thensn=t, the termination
state of the application. Tis afailure (or an error ) trace i
9Ai2SM[LMs.t.a0a1:::an 1is accepted by Ai. Then state
snis called an error state and is denoted by e. Note that e
can be tas well; this occurs when Aiis a liveness monitor
since absence of a desired sequence is determined when the
application terminates.
For example, consider the execution of TASin which the
customer chooses the air/ground option but due to commu-
nication problems with the ight system partner, the invo-
cation of cftimes out and triggers termination of the appli-
cation, leaving monitor A1in its error state 3. This scenario
corresponds to the trace t1depicted by dotted transitions
in Fig. 5a. In another scenario, corresponding to the trace
t2, depicted by dashed transitions in Fig. 5a, the customer
attempts to arrive at her destination via an expensive ight
4http://www-306.ibm.com/software/info1/websphere/
index.jsp?tab=products/businessint(expF) and a limo ( bl). Executing this trace leaves monitor
A2in its error state 4.
Since the application properties are specied separately
from the BPEL program, no code instrumentation is re-
quired in this step, enabling non-intrusive (and scalable)
online monitoring.
5. RECOVERY PLANS FROM SAFETY
PROPERTY VIOLATIONS
Once an error has been detected during runtime monitor-
ing, the goal of the recovery phase is to suggest a number
ofrecovery plans that would lead the application away from
the error.
Definition 5 (Plan). Aplan is a sequence of actions.
ABPEL recovery plan is a sequence of actions consisting of
user interactions, compensations (empty or not) and calls to
service partners.
Recovery plans dier depending on the type of property
that failed. We treat safety properties below, and recovery
from liveness properties is described in Sec. 6.
Computing Plans. The recovery procedure for a safety
property violation receives LC(B) { the LTS of the running
application Bwith compensations (see Sec. 3.1), T{ the
executed trace ending in an error state e(see Sec. 4) and
C(B) { the set of change states (see Sec. 3.2.2).
In order to recover, we need to \undo" a part of the ex-
ecution trace, executing available compensation actions, as
specied by c. We do this until we either reach a state in
C(B) or the initial state of LC(B). Multiple change states
can be encountered along the way, thus leading to the com-
putation of multiple plans.
For example, consider the error trace t2described in Sec. 4
and shown in Fig 5a. f1;2;6;15;16;18gare the change states
seen along t2. This leads to the recovery plans shown in
Fig 6a. We add state names between transitions for clarity
and refer to plans as to mean \recovery to state s". A given
plan can also become a prex for the follow-on one. This is
indicated by using the former's name as part of the denition
of the latter. For example, recovery to state 16 starts with
recovery to state 18 and then includes two more backward
transitions, the last one with a non-empty compensation.
Planr18can avoid the error if, after its application, the user
chooses a cheap ight instead of an expensive one. Executing
planr15gives the user the option of changing the limousine
to a rental car, and plan r2{ the option of changing from an
air/ground combination to just renting a car. Both of these
behaviours do not cause the violation of A2.
Computed plans are then converted to BPEL for presen-
tation to the user. For example, plan r18is shown in Fig 5c.
The chosen plan can then be applied (see Sec. 7), allow-
ing the program to continue its execution from the resulting
change state.
The exact number of plans is determined by the number
of change states encountered along the trace. Since each
new plan includes the previous one, the maximum number
of plans computed by our tool is set by user preferences ei-
ther directly (\compute no more than 3 plans") or indirectly
(\compute plans of up to length 20" or \compute plans while
the overall sum of compensation actions is less than 10").
Discussion. Note that plan r16which cancels the limo,
would lead to rebooking it right away which may still leavethe possibility of booking an expensive ight and violating
the property P2. The reason why this plan might not be
as useful as others is that computation of change states in
Sec. 3.2.2 treats all non-idempotent service calls as the same,
whereas not all might be relevant to the satisfaction of prop-
erties of interest. See [22] for a description of computation
and evaluation of eectiveness of relevant change states.
6. RECOVERY PLANS FROM LIVENESS
PROPERTY VIOLATIONS
Failure of a liveness monitor during execution means that
some required actions have not been seen before the ap-
plication tried to terminate, and the recovery plan should
attempt to perform these actions.
The recovery procedure receives A`{ the monitor that
identied the violation, LC(B) { the LTS of the application,
G(B;A`) { the set of goal transitions corresponding to A`,T
{ the executed trace ending in an error state e, and C(B) {
the set of change states.
A recovery plan eectively\undoes"actions along T, start-
ing with eand ending in a change state (otherwise, the plan
would not be executable!) and then \re-plans" the behavior
to reach the goal (see Fig. 1b for a schematic view of the
overall process). Our solution adapts techniques from the
eld of planning [14], described below.
6.1 Recovery as a planning problem
Aplanning problem is a tripleP= (D;i;G ), whereDis
the domain, iis the initial state, and Gis a set of goal states.
In addition to P, a planner often gets as input k{ the
length of the longest plan to search for, and applies various
search algorithms to nd a plan of actions of length k,
starting from iand ending in one of the states in G. Typi-
cally, the plan is found using heuristics and is not guaranteed
to be the shortest available. If no plan is found, the bound
kcan be increased in order to look for longer plans.
To convert a recovery problem into a planning problem,
we use LC(B) as the domain and eas the initial state. The
third component needed is a set of goal states. Recall that
G(B;A`) is a set of goal transitions . We dene Gs(B;A`) =
fsj9a;s0(s;a;s0)2G(B;A`)g. That is, Gs(B;A`) is a set
ofsources of transitions in G(B;A`). We can now dene the
planning problem
P(B;A`;T) = ( LC(B);e;Gs(B;A`))
Note that when a plan pto a goal state sis computed, we
need to extend it with an additional transition, pa !s0to
account for ( s;a;s0)2G(B;A`). For example, consider the
tracet1of Fig. 5a, described in Sec. 4, in which monitor
A1fails. We dene the planning problem P(TAS;A1;t1) =
(LC(TAS);9;f4g), where 9 is the initial state (see Fig. 5a)
andGs(TAS;A1) =f4g(see Sec. 3.2.1). The resulting plan p
should be expanded to prd !5.
Unfortunately, not every trace returned by solving P(B;
A`;T) is acceptable: the recovery plans for liveness viola-
tions should also go through change states. Thus, we cannot
simply use a planner as a \black box".
Instead, we look at how planners encode the planning
graph and then manipulate the produced encoding directly,
to add additional constraints. Consider the LTS in Fig. 7a,
which is the planning domain, with sas both the initial and
the goal state. The planning graph expanded up to length 3(a)r18= 4 !21 !20 !19cancelF ! 18 r6=r15 !6
r16=r18 !17cancelL ! 16 r2=r6 !2
r15=r16 !15 r1=r2 !1
(b)p0= 9 !8cancelF ! 7 !6 !2onlyCar ! 3bc !4
p1= 9 !8cancelF ! 7bf !8cf !9exptrue ! 10expF !11getCar ! 12car !13bc !4
p2= 9 !8cancelF ! 7bf !8cf !9expfalse ! 14cheapF ! 11getCar ! 12car !13bc !4
p3= 9 !8cancelF ! 7bf !8cf !9expfalse ! 14cheapF ! 11getCar ! 12limo !24bl !4
Figure 6: Recovery plans for TAS: (a) plans for the safety violation of trace t2; (b) plans of length 10for
recovery from the liveness violation of trace t1.
(a)
 (b)
Figure 7: (a) a simple LTS and (b) its encoding as
the planning graph of size 3.
is shown in Fig. 7b and is read as follows: at time 1 we begin
in states1. If actionaoccurs (modeled as a2), then at time
2 we move to state t(modeled as proposition t2becoming
true); otherwise, we remain in state s(i.e., proposition s2
is true). If action boccurs while we are in state t(modeled
asb3), then at time 3 we move to state s. Two plans of
length 2 are extracted from this graph: a2;b3, correspond-
ing to executing arst, followed by b, and \do nothing" { a
planner-specic treatment of a sequence of no-ops.
Several existing planners, such as BlackBox [18], translate
the planning graph into a CNF formula and then use a SAT
solver, such as SAT4J5, to nd a satisfying assignment for
it. Such an assignment, if found, represents a plan. For
example, the CNF encoding of the planning graph in Fig. 7b
is as follows:
flts= (:no-op s2_s1)^(:a2_s1)^(:no-op s3_s2)
^(:b3_t2)^(:s2_no-op s2)^(:t2_a2)
^(:no-op s3_s3)^(:b3_s3)^(s1)^(s3):
Note that it explicitly models pre- and post-conditions of
the execution of actions. Such a formula is passed to a SAT
solver which produces a satisfying assignment s, if one exists.
The desired plan is extracted from sby taking propositions
that correspond to actions and that are assigned positive
values in s. For the above example, these are a2;b3and \do
nothing".
In what follows, we rst discuss how to produce a single re-
covery plan using a SAT-based approach (Sec. 6.2) and then
show how to extend it to produce multiple plans (Sec. 6.3).
6.2 Producing a single recovery plan
LetfPbe the encoding of the planning problem P(B;A`;T)
produced by an existing planner. We augment fPto follow
our \undo until a change state and then redo" approach by
adding conjuncts to fPwith the purpose of restricting its
solutions. For eciency, some additional ltering is done
after all plans have been computed (see Sec. 6.4).
1. We want to make sure a recovery plan visits at least one
of the change states encountered on the execution trace T.
LetS(T) be the set of states on T. We dene C(T) =S(T)\C(B)
to be the change states that appear on Tand denote by
c1;:::;cnthe propositions that correspond to states in C(T).
Ifkis the maximum length of the plan which is being searched
for, propositions cj
1,cj
2, ...,cj
kcorrespond to expansions of
5http://www.sat4j.org/cjto times 1 ... k. For example, consider Fig. 7 again. If
tis a change state and k= 3, then propositions t1;t2;t3in
fltscorrespond to expansions of tto times 1, 2, 3. We dene
c= (c1
1_:::_c1
k_:::_cn
1:::_cn
k), or, in the case of our
example, c= (t1_t2_t3). This formula is true when at
least one of the change states in C(T) is part of the plan.
2. In order to further lead the planner towards the \undo
and then redo" plans, we want to make sure that the only
compensations used in the plan correspond to actions in the
original trace T. More formally, let TCbe the set of com-
pensation actions corresponding to the actions in T, and let
cnTCbe all other compensation actions. Let abe a for-
mula which excludes (timed versions) of actions in cnTC:
i.e., neither of these compensation actions is true at any step
in the plan. For example, for trace t1over the LTS LC(TAS)
(see Fig. 5a), formula awould exclude all compensations
except cancelF and.
We now build a new propositional formula, based on fP:
R0(fP) =fP^c^a
R0(fP) describes the original planning problem for P(B;A`;T),
and in addition requires that at least one of the change states
is visited and no compensation actions for events that did
not occur in Tappear in the plan.
6.3 Producing multiple recovery plans
Let0be the plan produced for R0(fP) (see Sec. 6.2), lead-
ing to a goal state g2Gs(B;A`). To give the user options for
recovery, we want to produce other plans, dierent from 0.
The simplest way to do this is to remove gfrom G(B;A`) and
repeat the process described in Sec. 6.2. The new plan will
necessarily lead to a dierent goal transition and thus will
be dierent from 0. However, this method cannot produce
multiple plans to the same destination.
Instead, we constrain R0(fP) to explicitly rule out 0. For
example, to rule out the plan a;bfor the LTS in Fig. 7a, we
useR0(flts) computed in Sec. 6.2 and modify it as
R1(flts) =R0(flts)^(:a2_:b3)
This guarantees that the plan, if found, is dierent from the
previously found one in at least one action.
We continue this way, restricting Ri(fP) with the set of
previously computed plans to get Ri+1(fP), until the number
of desired plans is reached or until no new plan can be found,
that is, Rj(fP) is not satisable for some j.
We now apply this method to the TASproblem and the
error tracet1shown in Fig. 5a and ending in state 9. Looking
for plans up to length 10, we get plans p0,p1andp2shown
in Fig. 6b. And, as mentioned earlier, each plan is extended
with the last goal transition 4rd !5.
Planp0is the shortest: if unable to obtain a price for the
ight, cancel the ight and reserve the car instead. Plans p1andp2also cancel the ight (since 8 is not a change state
whereas 7 is) and then proceed to re-book it and book the
car, regardless of the ight's cost. Increasing the plan length,
we also get the option of taking the getCar transition out of
state 6, book the car and then the ight.
The produced plans are than ranked based on the length
of the plan and the cost of compensation actions in it. For
example, plan p0is the shortest and the additional compen-
sation, for action carAndFlight , is of zero cost. Thus, it is
ranked the highest. Of course, this plan does not take into
account the time the user will spend driving rather than y-
ing, so she may choose one of the alternative plans instead.
Chosen plans are then converted to BPEL for execution.
The compensation part of the plan is similar to the one
shown in Fig. 5c, and the re-planning part consists of a se-
quence of BPEL <invoke>operations.
6.4 Discussion
Precision. Our treatment of goal transitions eectively
means that we model satisfaction of the required sequence of
actions of a liveness property by executing the last event in
the sequence. Thus, our approach may include some plans
that do not result in the satisfaction of the desired prop-
erty (we did not encounter this problem in the examples
reported in Sec. 8). One way to approach this problem that
we intend to investigate in the future is to dene goal traces ,
based on the computation tree of L(B). While this will lead
to the extra precision in plan generation, we expect to pay
a potentially steep price in performance.
In addition, we can aim to limit the number of recov-
ery plans computed by taking two issues into consideration:
(a) making sure that the plan goes through only \relevant"
change states, i.e., those that aect the computation of the
violating trace, and (b) removing those plans that result in
the violation of one of the safety properties (see [22]).
Controlling unnecessary compensations. Plansp1,p2
andp3seem to be doing an unnecessary compensation: why
cancel a ight and then re-book it if the check ight service
call failed? The reason is that the application developer
identied service call cfas idempotent. That is, she deter-
mined that executing this service again cannot change the
ow of control of the application, and thus further compen-
sations are necessary.
Of course, every service call can fail, and thus none are
truly idempotent. Yet, having too many change states would
undermine the eectiveness of our framework. We believe
that the tradeo we have made in this paper is reasonable
but intend to revisit this issue as we gain more experience
with the approach.
Furthermore, as plan lengths get large, the planner can
generate plans with compensation loops which involve doing
an action and then immediately undoing it. For example,
in recovering from a violation in trace t1in LTS LC(TAS),
shown in Fig. 5a, the plan may include booking a ight and
then canceling it several times (i.e., going between states
7 and 8 of LC(TAS). Clearly, such situations should be
avoided. We could have encoded a corresponding formula
as the SAT problem, conjoining it to R0(fP): \at any point
in the plan, when a non-compensatory action appears, all
follow-on actions should not include compensation". How-
ever, we feel that this modication should make SAT com-
putation signicantly less ecient. Instead, we lter com-puted plans so that the ones with compensation loops are
not presented to the user.
Can generated plans still fail? There are a number of
reasons our plans can fail. The rst one, addressed earlier
in this subsection, are due to the inherent imprecision of our
handling of required event sequences. The second reason is
that any service in the recovery plan can fail; thus, the ap-
plication will be unable to reach its goal, prompting further
planning and recovery. Finally, for recovery of safety prop-
erties, it is possible that all paths from a change state may
still lead the application to an error state. This problem can
probably be addressed using additional static analysis.
7. TOOL SUPPORT
We have implemented the process described in this paper
using a series of publicly available tools and several short
(200-300 lines) new Python or Java scripts. For more infor-
mation, please refer to [23].
The preprocessing phase (see Sec. 3) receives as input a
BPEL program Bin BPEL4WS XML format. We use the
WS-Engineer extension for LTSA [11] to translate Binto an
LTS L(B) and then export it in the Aldebaran format [4],
with an extension :aut. Since WS-Engineer does not sup-
port full handling of BPEL compensations, we built our own
:aut-to-:autPython script ( add comp:py) which uses Band
L(B) to produce LC(B) as described in Sec. 3.1. Traceabil-
ity between the BPEL and the resulting LTS is established
by the WS-Engineer's encoding of BPEL scopes into names
of LTS actions. This traceability allows us to convert com-
puted plans to BPEL.
The safety and liveness monitors are specied in Alde-
baran as well, and we built a script compute cp:pyto com-
pute cross-products and identify change states and goal links
for them, as described in Sec. 3.2.
The monitoring phase is implemented on top of the IBM
WebSphere Process Server. It allows us to intercept events
that pass between the application server and the program.
In this phase we also build the trace, registering the encoun-
tered change states. When recovering for safety properties,
we use these states to compute and rank plans.
In the liveness recovery phase, we rst use our own script
(gen plan prob:py) to translate LC(B) into a planning prob-
lem which starts in the error state eand ends in the source of
one of the goal transitions (see Sec. 6.2). The planning prob-
lem is expressed in STRIPS [8] { an input language to the
planner Blackbox [18] which we use to convert it into a CNF
formula fP(see Sec. 6). Another new script, GenPlans:java,
modies fPto produce alternative plans, calls the satisa-
bility solver SAT4J, extracts plans from the satisfying as-
signments produced by SAT4J, ranks them and converts
them to BPEL4WS XML format for displaying and exe-
cution. SAT4J is an incremental SAT solver, i.e., it saves
results from one search and uses them for the next. For our
method of generating multiple plans (see Sec. 6.3), where
each SAT instance is more restricted than the previous one,
this is particularly useful, leading to ecient analysis.
Dynamic workows [25], implemented in IBM WebSphere
Integration Developer 6.2, allow us to execute the generated
plans at runtime.
8. CASE STUDIES
In this section, we report on our experience applying ourOur approach [6]
App. kvars clauses plans time (s) length plans
FV 15 797 16,198 2 0.042 1
22 1,436 33,954 4 0.743 5
26 1,804 44,262 8 1.144 13
42 3,276 85,494 40 3.128 412
FC 4 42 159 1 0.011 0
6 95 592 2 0.022 2
12 321 3,248 4 0.153 8
16 554 7,393 5 0.274 22
20 856 14,427 13 1.388 484
TAS 6 135 254 1 0.01 - -
8 798 10,355 5 0.13 - -
13 1,398 25,023 13 0.27 - -
Table 1: Plan generation data.
approach to recover from two known vulnerabilities [6] in the
Flickr system. [6] modeled each of the aspects of the system
as a nite-state machine and showed how to use redundan-
cies in the system in order to \work around" these vulnera-
bilities. A much bigger example of the use of our framework
on the Travel Booking System is reported in [21].
8.1 Examples
Flicker visibility. Flickr is a web-based photo-management
application. Photos are initially uploaded as either public ,
family orprivate , and a photo's visibility should be change-
able anytime using the setPerm function. The identied vul-
nerability is \when a photo is initially loaded as private , its
visibility cannot be changed to family at a later date".
We created the Flicker visibility system (FV) by reverse-
engineering the model given in [6] and expressing it in BPEL.
We then expressed its properties \If a user tries to set a
photo's visibility to X, Flickr will guarantee that the photo
will have the visibility X", where X is each of the possible
visibilities as separate liveness automata. An instance with
X=family will \catch" the identied vulnerability in the
case where a photo is initially loaded as private .
The BPEL model FV, described fully in [20], consists of
28 activities (8 with explicit compensations). Two of these,
upload andchange are non-idempotent. Converted to LTS,
the resulting model has 28 states and 37 transitions.
Flicker comments. Flickr lets users comment on uploaded
photos. While any user can add a comment to a public
photo, only authorized users can comment on private and
family photos. The identied vulnerability is \after upload-
ing a photo as public , no comments could be added". Using
the same process as for FV, we created the BPEL model FC
(see [20]), consisting of 16 activities (6 with compensations).
The resulting LTS model has 18 states and 22 transitions.
We expressed FC's property \if a user adds a comment to
apublic photo that has comments enabled, the comment
should be successfully added to the photo's comments" as a
liveness monitor.
8.2 Experience
The number of recovery plans generated for failed traces
of FV and FC is shown in Table 1. For example, for the
plan length up to 26, we have generated 8 plans for FV. The
longest plan was of length 42.
We now look at the eectiveness of the plan generation
process. For FV, one of the plans we generate for k= 22
is \compensate changes in visibility until the photo becomes
private again, set the photo visibility to public and change
visibility to family ", which corresponds to the workaround
plan chosen by [6]. For FC, the plan corresponding to the
chosen workaround is \delete the problematic comment, tog-gle the comments permission and then try to add the com-
ment again", generated when k= 12.
To compare the precision of our approach, i.e., the num-
ber of plans generated, we look at the list of workaround
sequences computed by [6] (see Table 1). The work in [6]
modeled the Flickr behavior directly and the model did not
include BPEL-induced actions such as entering scopes. Fur-
ther, the workaround sequences did not include the \going
back" part { they were plans on how to execute a task start-
ing from the initial state. Thus, the plans we generate are
somewhat longer. For example, the workaround sequences
of length2 correspond to our plans of length k= 15.
With this adjustment, Table 1 shows that we generate sig-
nicantly fewer plans of the corresponding length. We also
generate every plan marked by [6] as desired.
Our experience with the Flickr examples suggests that
combining simple properties with the compensation mecha-
nism is eective for producing recovery plans.
8.3 Scalability
To check whether SAT-solving done as part of the plan-
ning is the bottleneck of our approach, we measured sizes of
SAT problems for FV, FC and our running example, TAS,
listing them in Table 1. For all three systems, the number
of variables and the number of clauses grows linearly with
the length of the plan, as expected, and the running time of
the SAT solver remains in seconds.
While the web applications we have analyzed have been
small (e.g., TAS has 14 activities, and its LTS encoding { 22
states and 27 transitions), our experience suggests that SAT
instances used in plan generation remain small and simple
and scale well as length of the plan grows. Given that mod-
ern SAT solvers can often handle millions of clauses and
given that individual web services are intended to be rela-
tively compact (with tens rather than thousands of partner
calls), we have a good reason to believe that our approach
to plan generation is scalable to realistic systems.
9. RELATED WORK
The main contribution of our work is a recovery frame-
work for web applications via planning. Bertoli et al. [3]
used planning for the synthesis of web service orchestrations .
In contrast, we assume the orchestration is given, and use
planning to help recover when an error is detected.
Several works have suggested \self-healing" mechanisms
for web-service applications. The Dynamo framework [2]
uses annotation rules in BPEL in order to allow recovery
once a fault has been detected. Such rules need to be in-
stalled by the developers before the system can function. In
contrast, our work uses an existing compensation mechanism
and requires no extra eort from developers.
[13] propose a framework for self-healing web services,
where all possible faults and their repair actions are pre-
dened in a special registry. This approach relies on being
able to identify and create recovery from all available faults.
Our approach uses compensations for individual actions and
can dynamically recover from errors as they are detected.
[7] uses fault tolerance patterns to transform the origi-
nal BPEL process into a fault-tolerant one at compile time.
It is done by adding redundant behavior to the application
which may result in a signicantly bigger, and slower, pro-
gram. Our work is non-intrusive and does not slow down
the application if no errors are found.The work of Carzaniga et al. [6] is the closest to ours in
spirit. It exploits redundancy in web applications to nd
workarounds when errors occur, assuming that the appli-
cation is given as a nite-state machine, with an identied
error state as well as the \fallback" state to which the ap-
plication should return. The approach generates all possible
recovery plans, without prioritizing them. In contrast, our
framework not only detects runtime errors but also calcu-
lates goal and change states and in addition automatically
lters out unusable recovery plans (those that do not include
change states) and ranks the remaining ones. See Sec. 8 for
a detailed comparison.
10. CONCLUSION AND FUTURE WORK
In this paper, we have used BPEL's compensation mecha-
nism to dene and implement an online system for suggest-
ing, ranking and executing recovery plans. Our experience
has shown that this approach computes a small number of
highly relevant plans, doing so quickly and eectively.
We have evaluated our approach on relatively small and
simple examples. While we expect web service applications
to be small, it is still important to conduct further case stud-
ies to assess scalability and, more importantly, usability of
our approach. Furthermore, throughout the paper we have
identied several precision issues related to the identica-
tion of goals and change states. We intend to apply static
analysis techniques to help improve it and conduct further
experiments to better understand the tradeos between the
more expensive analyses and the eective computation of
recovery plans. Some preliminary work towards this end is
reported in [22].
Another limitation of our approach is that we model com-
pensations as going back to states visited earlier in the run.
While this model is simple, clean and enables eective anal-
ysis, the compensation mechanism in languages like BPEL
allows the user to execute an arbitrary operation and thus
end up in a principally dierent state. In fact, our approach
will encounter this situation as soon as we start modeling
data in addition to control. For example, if we model the
amount of money the user has as part of the state, then
booking and then canceling a ight brings her to a dierent
state { the one where she has less money and no ight. Thus,
extending our framework to situations where compensation
aects data remains a challenge.
In fact, reasoning about properties which involve the ac-
tual data exchanged by conversation participants may be
challenging from the perspective of expressing the proper-
ties and converting them into monitoring automata as well
as from the scalability perspective (e.g., computing the goal
links, expressing the formal model of BPEL with data as a
state machine, etc.).
Acknowledgements
We thank IBM CAS Toronto (specically, Bill O'Farrell,
Elena Litani and Leho Nigel), members of the IFIP 2.9
WG, and FSE anonymous reviewers for their helpful feed-
back on this work and its presentation. This research has
been funded by NSERC, IBM Toronto, MITACS, and by
the Ontario Post-Doctoral Fellowship program.
11. REFERENCES
[1] M. Autili, P. Inverardi, and P. Pelliccione. A ScenarioBased Notation for Specifying Temporal Properties. In
Proc. of SCESM (at ICSE'06) , 2006.
[2] L. Baresi and S. Guinea. Dynamo and Self-Healing BPEL
Compositions. In Proc. of ICSE'07 (Companion) , pages
69{70, 2007.
[3] P. Bertoli, R. Kazhamiakin, M. Paolucci, M. Pistore,
H. Raik, and M. Wagner. Continuous Orchestration of Web
Services via Planning. In Proc. of ICAPS'09 , 2009.
[4] M. Bozga, J.-C. Fernandez, A. Kerbrat, and L. Mounier.
Protocol Verication with the ALD EBARAN Toolset.
STTT , 1(1-2):166{184, 1997.
[5] T. Bultan. Modeling Interactions of Web Software. In Proc.
of WWV'06 , pages 45{52, 2006.
[6] A. Carzaniga, A. Gorla, and M. Pezze. Healing Web
Applications through Automatic Workarounds. STTT ,
10(6):493{502, 2008.
[7] G. Dobson. Using WS-BPEL to Implement Software Fault
Tolerance for Web Services. In Proc. of EUROMICRO'06 ,
pages 126{133, 2006.
[8] R. Fikes and N. J. Nilsson. STRIPS: A New Approach to
the Application of Theorem Proving to Problem Solving. In
Proc. of IJCAI'71 , pages 608{620, 1971.
[9] H. Foster. A Rigorous Approach to Engineering Web
Service Compositions . PhD thesis, Imperial College, 2006.
[10] H. Foster, W. Emmerich, J. Kramer, J. Magee,
D. Rosenblum, and S. Uchitel. Model Checking Service
Compositions under Resource Constraints. In Proc. of
ESEC-FSE '07 , pages 225{234, 2007.
[11] H. Foster, S. Uchitel, J. Magee, and J. Kramer. LTSA-WS:
a Tool for Model-Based Verication of Web Service
Compositions and Choreography. In Proc. of ICSE'06 ,
pages 771{774, 2006.
[12] X. Fu, T. Bultan, and J. Su. Analysis of Interacting BPEL
Web Services. In Proc. of WWW'04 , pages 621{630, 2004.
[13] M. Fugini and E. Mussi. Recovery of Faulty Web
Applications through Service Discovery. In Proc. of
SMR'06 , 2006.
[14] F. Giunchiglia and P. Traverso. Planning as Model
Checking. In Proc. of ECP'99 , pages 1{20, 1999.
[15] R. Grosu and S. A. Smolka. Safety-Liveness Semantics for
UML 2.0 Sequence Diagrams. In Proc. of ACSD'05 , pages
6{14, 2005.
[16] K. Havelund and G. Rosu. Testing Linear Temporal Logic
Formulae on Finite Execution Traces. Technical report,
2001.
[17] S. Hinz, K. Schmidt, and C. Stahl. Transforming BPEL to
Petri Nets. In Proc. of BPM'05 , volume 3649 of LNCS ,
pages 220{235, 2005.
[18] H. A. Kautz and B. Selman. Unifying SAT-based and
Graph-based Planning. In Proceedings of IJCAI'99 , pages
318{325, 1999.
[19] C. Ouyang, E. Verbeek, W. M. P. van der Aalst, S. Breutel,
M. Dumas, and A. H. M. ter Hofstede. Formal Semantics
and Analysis of Control Flow in WS-BPEL. Sci. Comput.
Program. , 67(2-3):162{198, 2007.
[20] J. Simmonds. Dynamic Analysis of Web Services . PhD
thesis, Department of Computer Science, University of
Toronto, 2010. (in preparation).
[21] J. Simmonds, S. Ben-David, and M. Chechik. Monitoring
and Recovery of Web Service Applications. In Smart
Internet , LNCS, pages 1{35. Springer, 2010. To appear.
[22] J. Simmonds, S. Ben-David, and M. Chechik. Optimizing
Computation of Recovery Plans for BPEL Applications,
2010. Submited.
[23] J. Simmonds and M. Chechik. RuMoR : Monitoring and
Recovery of BPEL Applications. In Proc. of ASE'10 , 2010.
To appear.
[24] J. Simmonds, Y. Gan, M. Chechik, S. Nejati, B. O'Farrell,
E. Litani, and J. Waterhouse. Runtime Monitoring of Web
Service Conversations. IEEE Trans. on Serv. Comp. , 2009.
[25] W. M. P. van der Aalst and M. Weske. Case Handling: a
New Paradigm for Business Process Support. Data Knowl.
Eng., 53(2):129{162, 2005.