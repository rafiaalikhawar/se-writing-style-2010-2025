Program Transformations to Fix C Integers
Zack Coker
Auburn University
zfc0001@tigermail.auburn.edu
Abstract
C makes it easy to misuse integer types; even mature pro-
grams harbor many badly-written integer code. Traditional
approaches at best detect these problems; they cannot guide
developers to write correct code. We describe three program
transformations that ﬁx integer problems—one explicitly in-
troduces casts to disambiguate type mismatch, another adds
runtime checks to arithmetic operations, and the third one
changes the type of a wrongly-declared integer. Together,
these transformations ﬁxed all variants of integer problems
featured in 7,147 programs of NIST’s SAMATE reference
dataset, making the changes automatically on over 15 mil-
lion lines of code. We also applied the transformations au-
tomatically on 5 open source programs. The transformations
made hundreds of changes on over 700,000 lines of code,
but did not break the programs. Being integrated with source
code and development process, these program transforma-
tions can ﬁx integer problems, along with developers’ mis-
conceptions about integer usage.
Our work has been accepted at ICSE 2013 [1]. More
information is available at the project page: http://www.
munawarhafiz.com/research/intproblem/ . One can
try the three program transformations on the web: http:
//www.openrefactory.org/demo.html .
1. Problem and Motivation
Ever since attackers shifted their attention from traditional
buffer overﬂows to other types of attacks, attacks on inte-
ger vulnerabilities have been on the rise, even featuring as
the second most common vulnerability behind buffer over-
ﬂows [2]. Typical programs with reported integer vulnera-
bilities have not been written recently; they, as well as other
mature programs, contain many integer problems , some of
which result in vulnerabilities. The integer model of C is
complex, unintuitive and partly undeﬁned, making it easy
to write code with integer problems. Our results show that
even mature programs contain these problems.
There are four types of integer problems [3] [4]: 1) a
signedness bug occurs when an unsigned type is interpreted
as signed, or vice versa; 2) an arithmetic overﬂow occurs
when integer operations such as addition or multiplication
produce a result that overﬂows the allocated storage; 3) anarithmetic underﬂow occurs when integer operations such
as subtraction and multiplication produce a result that is
smaller than what can be stored; 4) a widthness bug or
atruncation bug is the loss of information when a larger
integer type is assigned to a smaller type, e.g., int to short.
Most of the recent works on integer problems focus on
detecting integer vulnerabilities. These approaches are in-
sufﬁcient in 3 ways. First, they only apply to integer over-
ﬂows. A few tools target integer problems other than over-
ﬂows, but they have problems with performance [5] and
accuracy [4] [6]. Second, these tools are not used because
runtime approaches have performance overhead (as high as
50X slowdown for BRICK [5]). However, the most impor-
tant problem is that these approaches do not help developers
produce better code. It is very easy to write C code with in-
teger problems. Dietz and colleagues [7] reported that unin-
tended integer overﬂows are very common in real programs.
At the moment, these 3 factors are a part of why these tools
are not more widely adopted.
2. Background and Related Work
Research on integer problems primarily focuses on de-
tecting integer overﬂow vulnerabilities either statically or
dynamically. The static analysis approaches target either
source code or binary code. IntScope [8] modiﬁes bina-
ries to an intermediate representation, and then checks for
integer overﬂow combining symbolic execution and taint
analysis. UQBTng [9] also decompiles and then applies
model checking with CBMC [10]. On the other hand, some
approaches examine source code, e.g., Microsoft’s PRE-
fast [11], ARCHERR [12], etc. Ashcraft and colleagues’ [13]
approach uses bounds checking and taint analysis to see if
an untrusted value is used in trusted sinks; bounds checking
is also used by Sarkar and colleagues [14]. However, both
approaches are not applicable to detect all types of integer
problems. Ceesay and colleagues [15] added type qualiﬁers
to detect integer overﬂow problems. Their approach requires
user annotation and only detects integer overﬂow.
Some dynamic analysis tools can detect all types of in-
teger problems, e.g., RICH [4], BRICK [5], and Smart-
Fuzz [6]. RICH [4] instruments programs to detect safe and
unsafe operations based on well-known subtyping theory.
BRICK [5] uses a modiﬁed version of Valgrind [16]. It iseither slow (50X slowdown) or has many false positives.
SmartFuzz [6] is also based on Valgrind, but it uses dy-
namic test generation techniques to generate inputs, leading
to good test coverage. SAGE [17] and IOC [7] are other
dynamic approaches, but they target fewer integer problems.
3. Approach and Uniqueness
3.1 General Approach
We describe a program transformation-based approach that
ﬁxes all types of integer problems in C programs. We in-
troduce three transformations—an A DDINTEGER CAST
(AIC) transformation that explicitly introduces casts to dis-
ambiguate integer usage and ﬁx signedness and widthness
problems, a R EPLACE ARITHMETIC OPERATOR (RAO)
transformation that replaces arithmetic operations with safe
functions to detect overﬂows and underﬂows at runtime,
and a C HANGE INTEGER TYPE (CIT) transformation that
changes types to ﬁx signedness and widthness problems.
They are similar to refactorings [18], but they do not intend
to preserve behavior. They are instead security-oriented pro-
gram transformations [19] [20], that improve the security of
systems by preserving expected behavior but removing in-
teger problems. They transform the integer model of C pro-
grams towards a safe integer model, following CERT [21]
and MISRA C [22] guidelines.
A transformation-based approach has several advan-
tages. First, program transformations remove a frequent and
repetitive task from developers. People are bad at repeti-
tive tasks—computers are better. Second, program trans-
formations making small changes are more likely to be
adopted [23]. Most importantly, the source-level program
transformations would help developers better understand
and be aware of the subtleties of integer problems.
We have implemented the program transformations as
Eclipse plugins. The program transformations are developed
using OpenRefactory/C [24], our infrastructure for develop-
ing program transformations for C. OpenRefactory/C fea-
tures sophisticated analyses needed to support complex pro-
gram transformations.
3.2 Contributions
Our approach makes the following contributions.
•It shows that integer problems in C programs can be pre-
vented with a small number of source-to-source program
transformations (Section 3.4). These program transfor-
mations modify the integer model of a C program to-
wards a safe model. They guide developers by explicitly
revealing mistakes in integer operations (Section 4.4).
•It demonstrates that complex yet accurate source-level C
program transformations can be implemented as part of
the refactoring catalog of popular IDEs.
•It shows that the three program transformations can pre-
vent all types of integer problems (Section 4.1). It alsoevaluates the accuracy of the program transformations by
applying them automatically to make many small mod-
iﬁcations to open source programs, in a way that pro-
duces programs that maintain functionality (Section 4.2)
and have minimal overhead (Section 4.5).
•It presents an empirical study—based on well-known
open source programs—about the types and patterns of
integer problems in source code (Section 4.3).
3.3 Program Transformations in Action
Consider this recent widthness/overﬂow vulnerability [25] in
Ziproxy v.3.0.0 in line 979 of image.c ﬁle.
979raw_size = bmp->width * bmp->height * bmp->bpp;
In line 979, the result of multiplying three signed integers
is stored in rawsize , a long long integer variable. C ﬁrst
performs the integer multiplication in an integer context,
meaning that multiplying any values that produce results
outside of the signed integer range would ﬁrst wrap around;
the wrapped around value would then be cast to long long
int. During the wrap around, information will be lost.
Traditional approaches to detect integer overﬂows would
add runtime checks on the multiplication; our RAO transfor-
mation would similarly replace the multiplication operations
with safe functions that detect overﬂow. However, this solu-
tion is not perfect, since the developer obviously wanted to
use the full range of the long long integer variable to store the
solution. The context of the multiplication should be lifted so
that a multiplication with long long integer values can be al-
lowed. A developer can ﬁrst detect the problem with RAO,
but then apply AIC on rawsize to ﬁx the context.
979raw_size = (long long int) bmp->width * \
980 (long long int) bmp->height * \
981 (long long int) bmp->bpp;
Additionally, a developer can apply RAO on the result, to
remove possibilities of overﬂow. This adds defense in depth.
979raw_size = mulsll((long long int)bmp->width, \
980 mulsll((long long int)bmp->height, \
981 (long long int) bmp->bpp));
3.4 Description of the Three Transformations
3.4.1 A DDINTEGER CAST (AIC)
You have a program in which integer operations have
operands with different types; the end result may contain an
unexpected value.
Add explicit casts for all type mismatches so that they are
visible and properly handled.
Motivation: Signedness and widthness mismatches are
very common (Section 4.3) and may lead to unexpected
results in a program’s behavior. If the types were explicitlymentioned (e.g., MISRA rules 10.1-10.6 [22]), a compiler
can unambiguously enforce the types.
Precondition: A developer selects an integer variable and
invokes the AIC transformation. The variable’s references
are checked to make sure that it is used in an unsafe opera-
tion (e.g., parameter to memcpy function). The precondition
does not guarantee a change. It only means that the situation
needs more in depth investigation.
Mechanism: AIC determines the declared type of a vari-
able, checks all references, determines if the variable is used
in an unsafe context, and explicitly adds casts. The casts are
added to make the types explicit; some of these casts remove
a problem, others illustrate the way types are (mis)used.
Example: Consider this program from NIST’s SAMATE
reference dataset [26].
short data;
...
data = -1;
char dest[100] = "";
if (data < 100) {
...
memcpy(dest, src, data);
A negative number for the variable data wrongly by-
passes the conditional test. memcpy expects an unsigned in-
teger as its third parameter, so the value of data will be
converted to a very large unsigned integer value. This will
overﬂow the buffer dest . AIC ﬁxes this with explicit casts.
short data;
...
data = -1;
char dest[100] = "";
if ((unsigned int) data < 100) {
...
memcpy(dest, src, (unsigned int) data);
Among the two casts introduced, the one in the memcpy
function call makes developers aware of the casts performed
automatically by the weak-typed C system.
3.4.2 R EPLACE ARITHMETIC OPERATOR (RAO)
You have a C program that has a potential integer overﬂow
(or underﬂow) problem originating from an arithmetic
operation.
Replace arithmetic operations with a safe function call
that detects an overﬂow (or underﬂow) and explicitly
handles them.
Motivation: Integer overﬂows and underﬂows are silently
handled in C. It would be advantageous if arithmetic opera-
tions in C could be replaced with safe functions, that explic-
itly notify during an integer overﬂow and allow developers
to write handlers for dealing with the situation.
Precondition: A developer selects an expression contain-
ing an arithmetic operation: a binary operation ( +,−,∗,/),
a unary preﬁx or postﬁx operation ( ++,−−), and an arith-
metic assignment operation ( + =,−=,∗=,/=). The trans-formation checks if the selected expression or the lvalue stor-
ing the result is used in an unsafe context.
Mechanism: The transformation determines if the inte-
ger operation is unsafe and replaces it with functions from
a safe library. Our implementation uses CERT’s IntegerLib
library [21]. The safe functions in the library introduce call-
backs that are explicitly invoked when an overﬂow occurs.
The correct function is determined using operand types,
and integer promotion and arithmetic conversion rules (e.g.,
CERT’s rule INT02-C and INT-32C [21]).
Example: An integer overﬂow vulnerability [27] was
reported in rdesktop version 1.5.0. The problem is an integer
overﬂow in a call to tcprecv function in line 101 inside
isorecvmsgfunction in iso.c ﬁle.
101s = tcp_recv(s, length - 4);
If the length of the message is less than 4, the result of sub-
traction will be negative. Since tcprecv expects an un-
signed integer, the negative value will be converted to a large
positive integer. This overﬂows buffer s. RAO transforms
the program using safe functions from IntegerLib [28]:
101s = tcp_recv(s, ui2us(subui(length , 4)) );
The variable length is unsigned short. Following arithmetic
conversion rules, the subtraction function subtracts between
two unsigned integers, and then a function downcasts to
unsigned short. RAO also adds a header ﬁle (IntegerLib.h)
to the transformed program.
3.4.3 C HANGE INTEGER TYPE (CIT)
You have a program that has signedness and widthness
problems from using variable types in incorrect contexts.
These errors derive from incorrectly declared variables.
Change the declared type of variables so that the uses of
the variable are not conﬂicting with the declaration.
Motivation: We found that it is very common for a C
integer variable to have a declared type that differs from the
underlying types (empirical study in Section 4.3). This can
lead to both signedness and widthness problems. To prevent
these problems, it would be advantageous to change the type
of the variable to its underlying type.
Precondition: A developer selects an integer variable and
invokes the CIT transformation. It checks that a reference to
the variable is used in an unsafe context.
Mechanism: The program transformation determines the
type of the variable, checks if it is used as another type in
important contexts (e.g., when a variable is an lvalue or when
a variable is used in a function call, etc.), and matches the
declared type with the underlying type.
After the change made by CIT, some of the casts already
in the program will be unnecessary, while some casts may
need to be introduced. AIC should follow CIT to clean up
the code.Example: Consider this recent vulnerability in libpng
v1.4.9 [29], in lines 267-290 in pngrutil.c ﬁle. The vari-
ablecopy is declared as a signed integer and then used in
pngmemcpy as an unsigned integer argument.
267int ret, avail;
268...
276avail = png_ptr->zbuf_size-png_ptr->zstream.avail_out ;
277...
285int copy = output_size - count;
286if (avail < copy) copy = avail;
287png_memcpy(output + count, png_ptr->zbuf, copy);
288...
CIT is applied to avail and thencopy , which are used
as an unsigned integer in all important contexts. Their types
are modiﬁed to an unsigned int with avail shown below.
267int ret;
268unsigned int avail;
269...
An AIC transformation may follow CIT to remove casts, or
introduce new casts.
4. Results and Contributions
We ask the following research questions:
A. Are the program transformations effective in securing
systems from the different type of integer vulnerabilities?
B. Does a program transformation-based technique work?
C. How can we understand integer problems better? What
types of integer problems are more common?
D. Are the program transformations useful for developers
and will they help developers write better code?
E. How is performance affected by the transformations?
4.1 Can the transformations secure systems?
Table 1. CWEs that Describe Integer Vulnerabilities
Securing Benchmark Programs. SAMATE is the most
comprehensive benchmark available for integer vulnerabil-
ities in C and C++. Table 1 lists 7 CWEs that describe in-
teger vulnerabilities in the benchmark programs. In total,there were 7,147 C programs with 967 KLOC. We applied
AIC, CIT and RAO transformations to verify that they pre-
vent different types of integer vulnerabilities. The program
transformations preprocessed test programs and ran auto-
matically on the preprocessed versions in order to collect all
deﬁnitions. The last column in Table 1 shows that the trans-
formations ran on more than 15 MLOC.
Programs in SAMATE have a good function and a bad
function. The good function demonstrates normal behavior,
and the bad function demonstrates a vulnerability. AIC and
CIT ﬁxed the problems in bad functions; RAO reported
them during runtime. More details are in our paper [1].
Table 3. Test Programs
Securing Real Programs. We tested the transformations
on 5 open source programs with recently reported integer
vulnerabilities: libpng 1.4.9, Ziproxy 3.0.0, rdesktop 1.5.0,
OpenSSL 0.9.8, and SWFTools 0.9.1. We applied the appro-
priate program transformations to remove the root cause of
the reported vulnerability.
SWFTools 0.9.1 had multiple reported vulnerabilities [30]
in lib/png.c and lib/jpeg.c ﬁles. In line 464 of lib/png.c ﬁle,
the variable lenwas declared an integer and was passed to
malloc. CIT changed the declared type to unsigned integer.
A similar signedness problem was in lib/jpeg.c ﬁle, line 314:
int width = *_width = cinfo.output_width; . CIT
modiﬁed the type to unsigned integer.
OpenSSL 0.9.8 had a widthness vulnerability [31] in
crypto/asn1/a d2ifp.c ﬁle. The variable want in a function
(asn1 d2iread bio) is declared as int, but it is used as un-
signed long int. CIT performs the transformations.
The signedness problem [29] in libpng 1.4.9 is ﬁxed with
a combination of CIT and RAO transformations (Section
3.4.3). The overﬂow vulnerability in rdesktop 1.5.0 [27] is
ﬁxed with RAO transformation (Section 3.4.2). A vulnera-
bility [25] in Ziproxy is ﬁxed by a combination of AIC and
RAO transformations (Section 3.3).
4.2 Does a transformation-based technique work?
Our program transformations modify program behavior to
ﬁx a problem, but should not break normal behavior. We
automatically applied the transformation on all appropriate
targets of 5 open source programs. The transformations were
each applied to more than 700,000 lines of preprocessed
code contained in 4,493 functions in 222 ﬁles (Table 3) and
our results are shown below.
AIC was applied on all local variables, parameters, array
access expressions, and structure element access expressions—Table 2. Running AIC on Test Programs
1,847 total in libpng (Table 2). Of these, 1,262 were con-
sidered unsafe. These passed the preconditions of AIC
(1262/1847, i.e., 68.33%). When the transformation was
applied, 6,978 references of the 1,262 variables were ana-
lyzed. A total of 358 tokens had changes—751 references
were modiﬁed by adding or removing or updating a cast
(10.76% of all references). RAO results are in our paper [1].
Table 4. Running CIT on Test Programs
CIT was applied on all local variables (Table 4). For
libpng, CIT was applied on 531 local integer variables;
453 passed the preconditions. There were 2,404 references
to these unsafe tokens that were checked. In the end, CIT
modiﬁed the declaration of 152 local variables in libpng, i.e.,
28.63% (152/531) of the variables that were checked.
While these transformations were not designed to be ap-
plied automatically in all cases as done here, it shows that
a large number of changes still allow the programs to run
correctly, which we veriﬁed.
4.3 Can we understand the integer problems better?
For space issues, we focus on certain key results from the
empirical study. The most surprising aspect is the number of
integer problems in matured software. For example, Table 4
shows that about 30% of the variables in our test programs
are declared incorrectly. This large number implies that,
in many cases, developers do not understand the contexts
where the variables will be used when declaring the variable,
or that they do not update the declared types.
CIT removes these problems. We investigated all the
changes made by CIT to understand what integer type mis-
takes are more common. Figure 1 shows the distributions. It
shows that the most common problem is declaring a variable
as signed but using it as unsigned. This is perhaps because
developers do not use additional type speciﬁers for signed-
ness when they declare a variable ( int is used in place of
unsigned int ). 0 0.2 0.4 0.6 0.8 1
libpng Ziproxy rdesktop OpenSSL SWFToolsRatio of Types of Change
ProgramsStoUSOnlyUStoSOnlyUcastOnlyDcastOnlyDcast+StoUSDcast+UStoSUcast+StoUSUcast+UStoS
Figure 1. Ratio of Types of Changes Made by CIT
4.4 Are the transformations useful for developers?
A speciﬁed goal of the transformations is to make implicit
integer problems visible so developers can be aware of the
problems and ﬁx them. Each program transformation mod-
iﬁes code in many places to notify developers about integer
problems; not all of them ﬁx an integer vulnerability.
For example, AIC modiﬁed 751 instances in libpng (Ta-
ble 2). 139 (18.5%) of these changes were in an assignment
expression, 212 (28.2%) were in the parameter type or the
return type of a function call expression, 269 (35.8%) were
in a binary expression, and 131 (17.1%) were on another cast
expression. Changes in assignment expressions and changes
in function call expressions are to make developers aware of
integer problems. On the other hand, changes in binary ex-
pressions affect binary comparison expressions only; which
guide developers and ﬁx potential vulnerabilities.
4.5 What is the performance overhead?
Our test results show that AIC actually lowered the runtime
speed of the programs while RAO and CIT both produced a
slight overhead. The ICSE paper [1] has more.
5. Conclusion
It is very easy to write a C program with misused integers.
Our program transformations intend to make integer prob-
lems visible. At the same time, they successfully ﬁx all vari-
ants of integer problems that result in vulnerabilities. Ulti-
mately, these power tools could be a simple and effective
method of guiding towards correct integer code.Acknowledgments
I would like to thank my advisor Dr. Munawar Haﬁz for all
the help he gave me throughout the research project. I would
also like to thank Paul Adamczyk, Farhana Ashraf, Chucky
Ellison, Jeffrey Overbey, and other anonymous reviewers.
This work was supported by the NSF grant CCF-1217271.
References
[1] Z. Coker and M. Haﬁz, “Program transformations to ﬁx C
integers,” in Proceedings of the International Conference on
Software Engineering, ICSE’13 , 2013.
[2] MITRE Corporation, “Vulnerability type distribution in
CVE,” 2007.
[3] blexim, “Basic integer overﬂows,” Phrack , vol. 60, 2002.
[4] D. Brumley, D. X. Song, T. cker Chiueh, R. Johnson, and
H. Lin, “RICH: Automatically protecting against integer-
based vulnerabilities,” in NDSS . The Internet Society, 2007.
[5] P. Chen, Y . Wang, Z. Xin, B. Mao, and L. Xie, “Brick: A
binary tool for run-time detecting and locating integer-based
vulnerability,” in Availability, Reliability and Security, 2009.
ARES ’09. International Conference on , march 2009, pp. 208
–215.
[6] X. L. David Molnar and D. A. Wagner, “Dynamic test gener-
ation to ﬁnd integer bugs in x86 binary Linux programs,” in
Proceedings of the 18th USENIX Security Symposium , 2009.
[7] W. Dietz, P. Li, J. Regehr, and V . S. Adve, “Understanding
integer overﬂow in C/C++,” in ICSE . IEEE, 2012, pp. 760–
770.
[8] T. Wang, T. Wei, Z. Lin, and W. Zou, “Intscope: Automatically
detecting integer overﬂow vulnerability in x86 binary using
symbolic execution,” in NDSS , 2009.
[9] R. Wojtczuk, “UQBTng: A tool capable of automatically ﬁnd-
ing integer overﬂows in Win32 binaries,” in Chaos Communi-
cation Congress , 2005.
[10] E. M. Clarke, D. Kroening, and F. Lerda, “A tool for checking
ANSI-C programs,” in TACAS , ser. Lecture Notes in Com-
puter Science, K. Jensen and A. Podelski, Eds., vol. 2988.
Springer, 2004, pp. 168–176.
[11] Microsoft Corporation, “PREfast analysis tool.”
[12] Chinchani, Iyer, Jayaraman, and Upadhyaya, “ARCHERR:
Runtime environment driven program safety,” in ESORICS:
European Symposium on Research in Computer Security .
LNCS, Springer-Verlag, 2004.
[13] K. Ashcraft and D. Engler, “Using programmer-written com-
piler extensions to catch security holes,” in SP ’02: Proceed-
ings of the 2002 IEEE Symposium on Security and Privacy ,
2002.[14] D. Sarkar, M. Jagannathan, J. Thiagarajan, and R. Venkat-
apathy, “Flow-insensitive static analysis for detecting inte-
ger anomalies in programs,” in SE’07: Proceedings of the
25th conference on IASTED International Multi-Conference .
Anaheim, CA, USA: ACTA Press, 2007.
[15] E. N. Ceesay, J. Zhou, M. Gertz, K. N. Levitt, and M. Bishop,
“Using type qualiﬁers to analyze untrusted integers and de-
tecting security ﬂaws in C programs,” in DIMVA , ser. Lecture
Notes in Computer Science, vol. 4064. Springer, 2006, pp.
1–16.
[16] N. Nethercote and J. Seward, “Valgrind: a framework for
heavyweight dynamic binary instrumentation,” in PLDI ,
J. Ferrante and K. S. McKinley, Eds. ACM, 2007, pp. 89–
100.
[17] P. Godefroid, M. Y . Levin, and D. A. Molnar, “Automated
whitebox fuzz testing,” in NDSS . The Internet Society, 2008.
[18] M. Fowler, Refactoring: Improving The Design of Existing
Code . Addison-Wesley, Jun 1999.
[19] M. Haﬁz, “Security on demand,” Ph.D. dissertation, Univer-
sity of Illinois Urbana-Champaign, 2010.
[20] M. Haﬁz, P. Adamczyk, and R. Johnson, “Systematically
eradicating data injection attacks using security-oriented pro-
gram transformations,” in Proceedings of the International
Symposium on Engineering Secure Software and Systems
(ESSoS-09) , Feb 2009.
[21] R. Seacord, CERT C Secure Coding Standard . Addison-
Wesley, 2008.
[22] MISRA-C: 2004 — Guidelines for the use of the C language
in critical systems , MISRA Consortium, 2004.
[23] M. Vakilian, N. Chen, S. Negara, B. A. Rajkumar, B. P. Bailey,
and R. E. Johnson, “Use, disuse, and misuse of automated
refactorings,” in ICSE . IEEE, 2012, pp. 233–243.
[24] M. Haﬁz and J. Overbey, “OpenRefactory/C: An infrastruc-
ture for developing program transformations for C programs,”
inOOPSLA ’12: Companion to the 27th annual ACM SIG-
PLAN Conference on Object-Oriented Programming, Sys-
tems, Languages, and Applications , 2012.
[25] National Vulnerability Database, “CVE-2010-1513,” 2010.
[26] National Institute of Standards and Technology (NIST), “SA-
MATE - Software Assurance Metrics and Tool Evaluation,”
2012.
[27] National Vulnerability Database, “CVE-2008-1801,” 2008.
[28] CERT, “Integerlib library.”
[29] National Vulnerability Database, “CVE-2011-3026,” 2012.
[30] ——, “CVE-2010-1516,” 2010.
[31] ——, “CVE-2012-2110,” 2012.