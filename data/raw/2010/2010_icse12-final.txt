Generating Range Fixes for Software Conﬁguration
Yingfei Xiong∗, Arnaud Hubaux†, Steven She∗, and Krzysztof Czarnecki∗
∗Generative Software Development Lab, University of Waterl oo, Canada, {yingfei,shshe,kczarnec }@gsd.uwaterloo.ca
†PReCISE Research Centre, University of Namur, Belgium, ahu @info.fundp.ac.be
Abstract —To prevent ill-formed conﬁgurations, highly con-
ﬁgurable software often allows deﬁning constraints over the
available options. As these constraints can be complex, ﬁxing
a conﬁguration that violates one or more constraints can be
challenging. Although several ﬁx-generation approaches exist,
their applicability is limited because (1) they typically generate
only one ﬁx, failing to cover the solution that the user wants;
and (2) they do not fully support non-Boolean constraints,
which contain arithmetic, inequality, and string operators.
This paper proposes a novel concept, range ﬁx , for software
conﬁguration. A range ﬁx speciﬁes the options to change
and the ranges of values for these options. We also design
an algorithm that automatically generates range ﬁxes for a
violated constraint. We have evaluated our approach with three
different strategies for handling constraint interactions, on dat a
from ﬁve open source projects. Our evaluation shows that,
even with the most complex strategy, our approach generates
complete ﬁx lists that are mostly short and concise, in a fraction
of a second.
I. I NTRODUCTION
A growing share of software exposes sophisticated con-
ﬁgurability to handle variations in user and target-platfo rm
requirements. Large enterprise systems, operating system s,
and embedded software need to be tailored to different
user needs, hardware, and other requirements. For example,
Linux kernel can be conﬁgured to run on different hardware
systems, and the user typically selects the CPU architectur e
(e.g., x86 or ARM), the type of ﬁlesystem (e.g., ext4 or
JFS), and the graphics driver (e.g., ATI or NVIDIA).
These conﬁguration options, also known as features, are
usually described with variability modeling languages [1] .
For instance, the Linux kernel uses Kconﬁg, and eCos—an
embedded conﬁgurable operating system—uses CDL [2]. In
academia, a popular variability modeling language is featu re
model [3], which has an expressiveness comparable to that
of Kconﬁg and CDL [4].
Conﬁgurators translate these models into interactive con-
ﬁguration interfaces, such as the one in Figure 1, and assist
users in arriving at a correct and complete conﬁguration.
To do so, conﬁgurators detect possible conﬁguration errors
and report them. A conﬁguration error is a decision that
conﬂicts with some constraints. Satisfying these constrai nts
can be non-trivial. Variability languages often provide ad -
vanced constructs that introduce hidden constraints [2], a nd
constraint rules declared in different places of the variab ility
model may have interactions. The interplay of these factors
often leads to very complex situations.
Figure 1: The eCos Conﬁgurator
Some conﬁguration tools, like those based on Kconﬁg,
implement an error avoidance mechanism that automatically
deactivates an option when a certain constraint is violated .
Inactive options are no longer available to the user unless
the constraint is satisﬁed again. Other conﬁgurators, like the
eCos conﬁgurator for CDL (Figure 1), add an interactive
resolution mechanism on top of the avoidance mechanism.
This approach allows violating some constraints, but pro-
poses a ﬁx for each violated constraint. A ﬁx denotes a set
of changes that would restore the consistency of the current
conﬁguration.
To better understand what challenges are faced by the
users of modern conﬁgurators, we carried out two surveys,
respectively, of Linux and eCos users [5]. Two question-
naires were submitted to forums, mailing lists, and experts
with whom we collaborate. In total, we collected answers
from 97Linux users with up to 20years of experience, and
9eCos users with up to 7years of experience. We present
here the two challenges that stand out most from this study
and that are addressed in this paper:
•Activating inactive features. 20% of the Linux users
report that, when they need to change an inactive
option, they need at least a “few dozen minutes” in
average to ﬁgure out how to activate it. 56% of the
eCos users also consider the activation of an inactive
option to be a problem.
•Fix incompleteness. Existing conﬁgurators generate
only one ﬁx for an error. However, there are often
multiple solutions to resolving an error, and the user
may prefer other solutions. 7out of 9eCos users have
encountered situations where the generated ﬁx is not
useful . That claim is corroborated by Berger et al.
[2] who report that eCos users complain about the
incompleteness of ﬁxes on the eCos mailing list.
Since activating an inactive feature requires satisfying978-1-4673-1067-3/11/$26.00 c2011 IEEE ICSE 2012, Zurich, Switzerland 89an appropriate constraint, activation is inherently the sa me
as resolving a conﬁguration error. As a result, a possible
solution for the above two problems is to generate ﬁxes for
both resolving errors and activating features. The set of ﬁx es
should be complete so that the user can choose the one he
wants.
To achieve this goal, two main challenges need to be
addressed. First, our previous study of eCos models [6]
shows that non-Boolean operators, such as arithmetic, in-
equality, and string operators, are quite common in their
constraints. In fact, the models contain four to six times mo re
Non-Boolean constraints than Boolean ones. Non-Boolean
constraints are challenging since there is often an inﬁnite
number of ways to satisfy them. Computing such inﬁnite
list of ﬁxes is pointless. Thus, a compact and intentional
representation of ﬁxes is needed. Second, many existing
approaches (e.g., [7], [8]) fail to generate a complete list of
ﬁxes because they are built upon constraint solvers, which
returns only one result per call. To get a complete list
of ﬁxes, we need to ﬁnd a new method to interact with
constraint solvers.
This paper proposes a new approach to generating ﬁxes
for software conﬁguration. Our contribution is threefold:
•Range ﬁxes. We propose a novel concept, range ﬁx
(Section II), to address the ﬁrst challenge. Instead of
telling users what concrete changes should be made, a
range ﬁx tells them what options should be changed
and in what range the value of each option can be
chosen. A range ﬁx can represent inﬁnite number of
concrete ﬁxes and still retains the goal of assisting the
user to satisfy constraints. Particularly, we discuss the
desired properties of range ﬁxes, which formalize the
requirements on the ﬁx generation problem. In addition,
we also discuss how constraint interactions should be
handled in our framework (Section IV).
•Fix generation algorithm. We designed an algorithm
that generates range ﬁxes automatically (Section III)
to address the second challenge. Our algorithm builds
upon Reiter’s theory of diagnosis [9], [10] and SMT
solvers [11]. Additionally, our algorithm is designed
for a general representation of constraints and variables,
which makes it potentially useful in other areas.
•Evaluation with eCos. Our algorithm is (1) applied
on eCos CDL (Section V) and (2) evaluated on 117
constraint violations from ﬁve open source projects
using eCos (Section VI). The evaluation compares three
different ﬁx generation strategies. Even with the most
complex propagation strategy, our notion of range
ﬁx leads to mostly simple yet complete sets of ﬁxes
(83% of the ﬁx lists have sizes smaller than 10, where
the size is measured by summing up the number of
variables in all the ﬁxes in the list), and our algorithm
can also generate ﬁxes for models containing hundreds
of options and constraints in an average of 50ms and a
Figure 2: Option “Startup”
maximum of 245ms.
We discuss threats to validity in Section VII and the
related work in Section VIII. We conclude the paper in
Section IX.
II. R ANGE FIXES
Motivating Example We now motivate our work with
a concrete example based on the eCos conﬁgurator [12].
Figure 1 shows a small model for conﬁguring an object pool.
The left panel shows a set of options that can be changed
by the user. The lower-right panel shows the properties of
the currently selected option, deﬁned by the eCos model.
Particularly, the ﬂavor property indicates whether the option
is a Boolean option or a data option. A Boolean option
can be either selected or unselected; a data option can be
assigned an integer or a string value. In Figure 1, “Pre-
Allocation Size” is a data option; “Use Pre-Allocation” is a
Boolean option.
Besides the ﬂavor, each option may also declare con-
straints using requires property or active-if property. When
a requires constraint is violated, an error is reported in th e
upper-right panel. In Figure 1, option “Pre-Allocation Siz e”
declares a requires constraint requiring its value be small er
than or equal to “Object Pool Size”, and an error is reported
because the constraint is violated.
An active-if constraint implements the error avoidance
mechanism. When it is violated, the option is disabled in the
GUI and its value is considered as zero. Figure 2 shows the
properties of the “Startup” option. This option declares th at
at most half of the object pool can be pre-allocated. Since
this constraint is violated, the “Startup” option is disabl ed
and the user cannot change its value.
Fixing a conﬁguration error or activating an option re-
quires satisfying the corresponding constraints. In order to
ﬁx the error on “Pre Allocation Size” in Figure 1, we need to
look up the deﬁnition of “Object Pool Size”. In Figure 3, we
see that “Object Pool Size” declares a calculated property,
meaning that the value of the option is determined by the
declared expression and cannot be modiﬁed by the user. As
a result, the constraint declared on “Pre-Allocation Size” is,
in fact, the following:
Pre_Allocation_Size <=
Buffer_Size *1024 / Object_Size
Furthermore, according to the CDL semantics, when an
option is inactive, the constraints it declares are not con-
sidered by the error checking system. An option is inactive
when its active-if constraint is violated or its parent opti on90Figure 3: Option “Object Pool Size”
is deselected. “Pre-Allocation Size” has a parent, yieldin g
the following complete constraint:
Use_Pre_Allocation -> (Pre_Allocation_Size <=
Buffer_Size *1024 / Object_Size)
By analyzing the constraint, we realize that we may ﬁx
the error by one of the following changes: decreasing “Pre-
Allocation Size”, or increasing “Buffer Size”, or decreasi ng
“Object Size”, or, more simply, disabling the pre-allocati on
function. Now we could choose one of these possibilities
and navigate to the respective option to make the change.
This example shows that there are three sub-tasks for
enabling a constraint. First, the user needs to ﬁgure out the
complete semantic constraint according to the constraint l an-
guage. Since variability languages often have fairly compl ex
semantics on visibility and value control [2], it is very eas y
to overlook some part of the constraint. Second, users need
to analyze the semantic constraint—such as the complete
constraint above—and ﬁgure out how to change the options
to make it satisﬁed. In practice, constraints can be very lar ge.
One semantic constraint we have found in a CDL model
contains 55option references and 35constants, connected
by66logical, arithmetic, and string operators. It is very
difﬁcult to analyze such a large constraint. Thirdly, users
have to navigate to the corresponding options and make the
changes. Real world variability models contain thousands
of options, e.g., one reported eCos model [2] contains 1244
options, which makes navigation very cumbersome [5].
Solution Our approach automatically generates a list of
range ﬁxes to help satisfy a constraint. For the error in
Figure 1, we will generate the following ﬁxes.
•[Use_Pre_Allocation := false]
•[Pre_Allocation_Size: Pre_Allocation_Size <=
8]
•[Buffer_Size: Buffer_Size >= 5]
•[Object_Size: Object_Size <= 409.6]
Each range ﬁx consists of two parts: the option to be
changed and a constraint over the options showing the range
of values. The ﬁrst range ﬁx is also a concrete assignment,
and will be automatically applied when selected. The other
ﬁxes are ranges. If the user selects, for example, the second
ﬁx, the conﬁgurator will highlight option “Pre-Allocation
Size”, prompt the range “ <=8”, and ask the user to select a
value in the range.
Range ﬁxes automate the three sub-tasks mentioned
above. The semantics of CDL constructs is automatically
taken into account and the constraint is automatically ana-lyzed. The navigation is also automatically performed when
applying a ﬁx. The user only has to choose a ﬁx and decide
a value within the range of the ﬁx.
Deﬁnitions Although different variability languages have
different constructs and semantics, existing work [2], [13 ],
[14] shows that all variability models can be converted into
a set of variables (options) and a set of constraints. Our
approach also builds upon this principle.
In essence, a variability language provides a universe
of typed variables Vand a constraint language Φ(V)for
writing quantiﬁer-free predicate logic constraints over V.
Consequently, a constraint violation consists of a tuple
(V, e, c ), where V⊆Vis a set of typed variables; the
current conﬁguration eis a function assigning a type-correct
value to each variable in V; and c∈Φ(V)is a constraint
over Vviolated by e. A ﬁx generation problem for a
violation (V, e, c )is to ﬁnd a set of range ﬁxes to help
users produce a new conﬁguration e′such that cis satisﬁed,
denoted as e′|=c.
Consider the following example of a constraint violation:
V:{m:Bool, a:Int, b:Int}
e:{m=true, a= 6, b= 5}
c: (m→a >10)∧(¬m→b >10)∧(a < b )(1)
All range ﬁxes we have seen so far change only one
variable, but more complex ﬁxes are sometimes inevitable.
For example, we cannot solve violation (1) by changing only
one variable. Several alternative ﬁxes are possible:
•[m:=false , b:b >10]
•[(a, b) :a >10∧a < b ]
The ﬁrst ﬁx contains two parts separated by “,”, each
changing a variable. We call each part a ﬁx unit . The second
ﬁx is more complex. This ﬁx contains only one ﬁx unit, but
the range of this ﬁx unit is deﬁned over two variables. When
the ﬁx is executed, the user has to choose a value for each
variable within the range.
Taking the above forms into consideration, we can deﬁne
a range ﬁx. A range ﬁx rfor a violation (V, e, c )is a set of
ﬁx units. A ﬁx unit can be either an assignment unit or a
range unit . An assignment unit has the form of “ var:=val”
where var∈Vis a variable and valis a value conforming
to the type of var. A range unit has the form of “ U:cstrt ”,
where U⊆Vis a set of variables and cstrt ∈Φ(U)is a
satisﬁable constraint over Uspecifying the new ranges of
the variables. A technical requirement is that the variable s
in ﬁx units should be disjoint, otherwise two different valu es
may be assigned to one variable.
We use r.Vto denote the set of the variables to be changed
in all units. We use r.cto denote the conjunction of the
constraints from all units. The constraint from an assignme nt
unit “ var:=val” isvar=val, and the constraint from a
range unit “ U:cstrt ” iscstrt . For example, let rbe the
range ﬁx [m:=false , b:b >10], then r.v={m, b}and
r.cism=false ∧b >10.91Applying range ﬁx rof violation (V, e, c )toewill
produce a new conﬁguration interactively. We denote all
possible conﬁgurations that can be produced by applying
rtoeasr ⊲ e, where r ⊲ e ={e′|e′|=r.c∧ ∀v∈V(e′(v)/ne}ationslash=
e(v)→v∈r.V)}
Desired Properties A trivial way to generate a ﬁx from a
violation is to produce a range unit where the variables to
change are all variables in the constraint and the range of
these variables is the constraint itself. For example, the ﬁ x
for violation (1) could be [(m, a, b ) : (m→a >10)∧(¬m
→b >10)∧(a < b )]. However, such a ﬁx provides no more
information than the original constraint. In this subsecti on,
we discuss the desired properties of range ﬁxes.
Suppose ris a range ﬁx for a violation (V, e, c ). The
ﬁrst desired property is that a range ﬁx should be correct:
all conﬁgurations that can be produced from the ﬁx must
satisfy the constraint.
Property 1 (Correctness) .∀e′∈(r ⊲ e), e′|=c
Second, correct range ﬁxes over the same set of variables
are often highly overlapping. For example, [m:=false , b:
b > 11]is included in [m:=false , b:b > 10], though
both are correct. To give users more choice, we would like
to present the maximal range of the variables.
Property 2 (Maximality of ranges) .There exists no ﬁx r′
for(V, e, c )such that r′is correct, r′.V=r.Vand(r⊲e)⊂
(r′⊲ e)
Third, even with the above two properties, the number
of possible ﬁxes may still be large. Thus, we further rely
on a heuristic rule to reduce the number of ﬁxes: a ﬁx
should change a minimal set of variables. The reason is that
each value currently assigned to a variable is a conﬁguratio n
decision made by the user, and a ﬁx should not unnecessarily
break user decisions. For example, [m:=false , b:b >10]
is preferable to [m:=false , b:b >10, a:a= 9] because
the latter unnecessarily changes a, which does not contribute
to the satisfaction of the constraints.
Property 3 (Minimality of variables) .There exists no ﬁx r′
for(V, e, c )such that r′is correct and r′.V⊂r.V.
As a heuristic rule, minimality of variables sometimes
excludes possible changes that resolve a violation. For
example, given a constraint i > j and a conﬁguration
{i= 5, j= 10}, we can ﬁnd a possible ﬁx [i:= 6, j:= 5] ,
but this ﬁx is excluded because we can satisfy the constraint
by only changing iorj. As a result, it is important to
evaluate whether the excluded changes are really needed by
users. In our evaluation described in Section VI, the exclud ed
changes are never adopted by the user.
Additionally, after deciding the range over the variables,
we would like to represent the range in the simplest way
possible. Thus, another possible property is that a ﬁx unit
should change as few variables as possible. In other words,no ﬁx unit can be divided into smaller equivalent ﬁx units.
We call this property minimality of (ﬁx) units .
However, satisfying this property is not easy. Since we
treat Φas a general notion, dividing a range unit into mini-
mal units implies to know the dimension of the solution to an
arbitrary system of equations, where no general algorithm i s
known to exist. As a result, we do not treat this property as
a formal requirement that the ﬁx generation algorithm must
satisfy. On the other hand, real world constraints are usual ly
not that complex and effective algorithm can be found. As
our evaluation will show, although our algorithm cannot
absolutely guarantee this property, it effectively satisﬁ es this
property on our data set.
Armed with these properties of range ﬁxes, we can deﬁne
thecompleteness of a list of ﬁxes. Since the same constraint
can be represented in different ways, we need to consider
the semantic equivalence of ﬁxes. Two ﬁxes randr′are
semantically equivalent if(r ⊲ e) = ( r′⊲ e), otherwise they
aresemantically different .
Property 4 (Completeness of ﬁx lists) .Given a constraint
violation (V, e, c ), a list of ﬁxes Lis complete iff
•any two ﬁxes in Lare semantically different,
•each ﬁx in Lsatisﬁes Property 1, 2, and 3,
•and any ﬁx that satisﬁes Property 1, 2 and 3 is
semantically equivalent to a ﬁx in L
Thus, a ﬁx generation problem is to ﬁnd a complete list
of ﬁxes for a given constraint violation (V, e, c ).
III. F IXGENERATION ALGORITHM
In Section II we claimed that a ﬁx should change a
minimal set of variables and have a maximal range. As a
result, our generation algorithm consists of three stages. (i)
We ﬁnd all minimal sets of variables that need to be changed.
For example, in violation (1), a minimal set of variables to
change is D={m, b}. (ii) For each such set of variables,
we replace any unchanged variable in cby its current value,
obtaining a maximal range of the variables. In the example,
we replace aby6and get (m→6>10)∧(¬m→b >
10)∧(6< b). (iii) We simplify the range to get a set of
minimal, or close to minimal, ﬁx units. In the example we
will get [m:=false , b:b >10]. Stage (ii) is trivial and
does not demand further developments. We now concentrate
on stages (i) and (iii).
A. From Constraint and Conﬁguration to Variable Sets
To collect all minimal variable sets, we resort to Reiter’s
theory of diagnosis. Proposed by Reiter [9] and revised by
Greiner et al. [10], this theory deﬁnes the problem of diag-
nosis and gives HS-DAG algorithm for solving the problem.
Fundamentally, Reiter’s theory assumes a constraint set th at
can be split into hard andsoftconstraints. The set of hard
constraints are invariable and assumed satisﬁable. The set of
soft constraints can be altered and also be unsatisﬁable. A92diagnosis is a subset of soft constraints that, when removed
from the set, restores the satisﬁability of the whole set. Th e
problem of diagnosis is to ﬁnd all minimal diagnoses from
a set of hard and soft constraints.
Given the constraint violation (V, e, c ), we convert the
problem of ﬁnding minimal variable sets to the problem of
diagnosis by treating cas a hard constraint and converting
einto soft constraints. For example, violation (1) can be
converted into the following constraint set.
Hard constraint ( c):
[0] (m→a >10)∧(¬m→b >10)∧(a < b )
Soft constraints ( e):
[1]m=true
[2]a= 6
[3]b= 5
To make the whole set satisﬁable, we need to remove at least
constraints {1,3}or constraints {2,3}, which correspond to
two variable sets {m, b}and{a, b}.
To ﬁnd all diagnoses, Reiter’s theory uses an ability of
most SAT/SMT solvers: ﬁnding an unsatisﬁable core. An
unsatisﬁable core is a subset of the soft constraints that is
still unsatisﬁable. For example, two unsatisﬁable cores in
the above constraint are {1,2}and{3}.
If we cancel at least one constraint from each unsatisﬁable
core, we get a diagnosis. The HS-DAG algorithm imple-
ments this idea by building a directed acyclic graph (DAG),
such that each node is labelled either by an unsatisﬁable
core or SAT, and each arc is labelled by a constraint that is
cancelled. The union of the labels on every path from the
root to a SAT node deﬁnes a diagnosis.
Figure 4: HS-
DAGFigure 4 shows an HS-DAG for
the above example. Suppose the con-
straint solver initially returns the un-
satisﬁable core {1,2}, and a root node
is created for this core. Then we build
an arc for each constraint in the core.
In this case, we build two arcs 1and
2. The left arc is 1, so we remove
constraint [1]from the set, and invoke
the constraint solver again. This time
the constraint solver returns {3}. We
remove constraint [3]and now the
constraint set is satisﬁable. We create a node SAT for the
edge. Similarly, we repeat the same steps for all other edges
until all paths reach SAT. Finally, each path from the root to
a leaf is a diagnosis. In this case, we have {1,3}and{2,3}.
This process alone cannot ensure that the generated di-
agnoses are minimal. To ensure it, three additional rules
are applied to the algorithm. The details of these rules
can be found elsewhere [10], and are omitted here due to
space limit. Greiner et al. [10] prove that HS-DAG builds a
complete set of minimal diagnosis after applying the three
rules.B. From Variable Sets to Fixes
Equipped with the minimal variable sets, we can replace
the variables not in these sets with their conﬁguration valu es
inc(stage(ii)). The purpose of Stage (iii) is to divide this
modiﬁed constraint into smaller ﬁx units.
Since the operators in the constraints differ from one
language to another, this task is essentially domain-speci ﬁc.
Nevertheless, since we assume the constraint language is
based on quantiﬁer-free predicate logic, we can perform
some general processing. The basic idea is to convert the
constraint into conjunctive normal form (CNF), and convert
each clause into a ﬁx unit. Yet, we still need to carefully
make sure the ﬁx units are disjoint and are as simple as
possible.
First, if the constraints contain any operators convertibl e
to propositional operators, we convert them into propo-
sitional operators. For example, eCos constraints contain
the conditional operator “?:” such as (m?a:b)>10.
We convert it into propositional operators: (¬m∨a >
10)∧(m∨b >10).
Second, we convert the constraint into CNF. In our
example, with {m, b}, we have (m→6>10)∧(¬m→
b > 10)∧(6< b), which gives three clauses in CNF:
{¬m∨6>10, m∨b >10,6< b}.
Third, we apply the following rules to simplify the CNF
repetitively until we reach a ﬁxed point.
Rule 1 Apply constant folding to all clauses.
Rule 2 If a clause contains only one literal, delete the
negation of this literal from all other clauses.
Rule 3 If a clause C1contains all literals in C2, delete
C1.
Rule 4 If a clause has the form v=cwhere vis a variable
andcis a constant, replace all occurrences of v
with c.
In our example, applying Rule 1 to the above CNF, we
get{¬m, m ∨b > 10,6< b}. Applying Rule 2 to the
above CNF, we get {¬m, b > 10,6< b}. No further rule
can be applied to this CNF.
Fourth, two clauses are merged into one if they share
variables. In the example, we have {¬m, b > 10∧6< b}.
Fifth, we apply domain speciﬁc rules to simplify the
constraints in each clause and to divide the clause into
smaller, disjoint ones. These rules are designed according
to the types of operators used in the constraint language.
In our current implementations of CDL expressions, we use
two types of rules. First, for clauses containing only linea r
equations or inequalities with one variable, we solve these
equations and inequalities as a system. Second, we eliminat e
some obviously eliminable operators, such as replacing a+0
with a. We also apply Rule 1 and Rule 4 shown above during
the process. In the example, the second clause consists of
two linear inequalities, we solve the inequalities, gettin g
{¬m, b > 10}.93Finally, we convert each clause into a ﬁx unit. If the clause
has the form of v,¬v, or v=c, we convert it into an
assignment unit, otherwise we convert it into a range unit.
In the example, we convert ¬minto an assignment unit and
b >10into a range unit and get [m:=false , b:b >10].
Our algorithm ensures the four formal properties. Since
in stage (i) HS-DAG gives us all minimal variable sets,
Property 3 and 4 hold. Since in stage (ii) we get a range
by replacing unchanged variables in the original constrain t,
the range is ensured to be correct and maximal, and thus
Property 1 and 2 hold. Stage (iii) simpliﬁes the range by
equivalence transformations, and thus all properties stil l
hold. Our algorithm does not always ensure minimality
of units because (1) the CNF simpliﬁcation rules in the
third step of stage (iii) are incomplete (but efﬁcient, as ou r
evaluation will show), and (2) we cannot ensure that the
domain-speciﬁc rules in the ﬁfth step are complete.
IV. C ONSTRAINT INTERACTION
So far we have only considered ﬁxes for one constraint.
However, the constraints in variability models are often in ter-
related; satisfying one constraint might violate another. As a
result, we have to consider multi-constraint violation rather
than single-constraint violation. A multi-constraint vio lation
is a tuple (V, e, c, C ), where Vandeare unchanged, c
is the currently violated constraint, and Cis the set of
constraints deﬁned in the model and satisﬁed by e. The
following example shows how a ﬁx satisfying ccan conﬂict
with other constraints in Cthat were previously satisﬁed.
V:{m:Bool, n:Bool, x:Bool, y:Bool, z:Bool}
e:{m/mapsto→true, n/mapsto→false , x/mapsto→false ,
y/mapsto→false , z/mapsto→false}
c:m∧n
C:{c2, c3}where
c2isn→(x∨y)
c3isx→z
(2)
If we generate a ﬁx from (V, e, c ), we obtain r= [n:=
true ]. However, applying this ﬁx will violate c2.
Note that a multi-constraint violation involves only one
violated constraint. If, for example, an eCos conﬁguration
contains multiple errors, we treat each of them as a multi-
constraint violation and ﬁx them one by one.
Existing work has proposed three different strategies to
deal with this problem; each has its own advantages and
disadvantages. We now revisit these three strategies, and
show that they can all be used with range ﬁx generation
by converting a multi-constraint violation into a single-
constraint one. In the evaluation section we will give a
comparison of the three strategies.
Ignorance All constraints in Care simply ignored, and
only ﬁxes for (V, e, c )are generated. This strategy is used
in ﬁx generation approaches considering only one constrain t[15]. This strategy does not solve the constraint interacti on
problem at all. However, it has its merits: ﬁrst, the ﬁxes are
only related to the violated constraint, which makes it easi er
for the user to comprehend the relation between the ﬁxes and
the constraints; second, this strategy does not suffer from the
problems of incomplete ﬁx list and large ﬁx list, unlike the
two others; third, this strategy requires the least computa tion
effort and is the easiest to implement.
Elimination When a ﬁx contains changes that violate
other satisﬁed constraints, these changes are excluded fro m
the range of the ﬁx, i.e., any changes with side effect are
“eliminated”. In the example in violation (2), ﬁx rcontains
only one change and this change violates c2. Thus, ﬁx ris
eliminated. This strategy is proposed by Egyed et al. [16]
and used in their UML ﬁx generation tool.
To apply this strategy to range ﬁx generation, we ﬁrst
ﬁnd a subset of Cthat shares variables with c, then replace
the variables not in cwith their current values in e, and
conjoin this subset of constraints with c. For example, to
apply the elimination strategy to violation (2), we ﬁrst ﬁnd
the constraints sharing variables with c, which includes only
c2, and then replace xandyinc2with their current values,
getting c′
2=n→false ∨false . Then we generate ﬁxes
for(V, e, c ∧c′
2).
Although the elimination strategy prevents the violation
of new constraints, it has two noticeable drawbacks. First,
it excludes many potentially useful solutions. Bringing ne w
errors is often inevitable. Simply excluding the changes wi ll
only provide less help. In our example, we will get an empty
ﬁx set, which does not provide any solution to the current
error. Second, since we need to deal with the conjunction
of several constraints, the resulting constraint is much mo re
complex than the original one. Our evaluation showed that
some conjunctions can contain more than ten constraints.
Nevertheless, compared to the propagation strategy, this
increase in complexity is still small.
Propagation When a ﬁx violates other constraints, we mod-
ify further variables in the violated constraints to keep th ese
constraints satisﬁed. In other words, the ﬁx is “propagated ”
through other constraints. For example, ﬁx rwill violate c2,
so we also modify variables xoryto satisfy c2. Then the
modiﬁcation of xwill violate c3, and we also modify z. In
the end, we get two ﬁxes [n:=true, x:=true, z:=true ]
and[n:=true, y:=true ]. This approach is used in the
eCos conﬁguration tool [12] and the feature model diagnosis
approach proposed by White et al. [8].
To apply this strategy, we ﬁrst perform a static slicing on
Cto get a set of constraints directly or indirectly related to
c. More concretely, we start from a set Dcontaining only
c. If a constraint c′shares any variable with any constraint
inD, we add c′toD. We keep adding constraints until we
reach a ﬁxed point. Then we conjoin all constraints in D,
and generate ﬁxes for the conjunction. For example, if we94Table I: Real World Conﬁguration Files
Architecture Project Options Constraints Changes
virtex4 ReconOS 933 330 49
xilinx ReconOS 765 272 53
ea2468 redboot4lpc 658 96 14
aki3068net Talktic 817 195 3
gps4020 PSAS 535 85 23
arcom-viper libcyt 771 189 26
want to apply the propagation strategy to violation (2), we
start with D={c}, then we add c2because it shares nwith
c, next we add c3because it shares xwith c2. Now we reach
a ﬁxed point. Finally, we generate ﬁxes for (V, e, c ∧c2∧c3).
The propagation strategy ensures that no satisﬁed con-
straint is violated and no ﬁx is eliminated. However, there
are two new problems. First, the performance cost is the
highest among the three strategies. The constraints in real -
world models are highly interrelated. In large models, the
strategy often led to conjunctions of hundreds of constrain ts.
The complexity of analyzing such a large conjunction is sig-
niﬁcantly higher than analyzing a single constraint. Secon d,
since many constraints are considered together, this strat egy
potentially leads to large ﬁxes (i.e., ﬁxes that modify a lar ge
set of variables), and large number of ﬁxes, which are not
easy to read and apply.
V. I MPLEMENTATION
We have implemented a command-line tool, ECC Fixer1,
generating ﬁxes for eCos CDL using the Microsoft Z3
SMT solver [11]. ECC ﬁxer takes a CDL conﬁguration
ﬁle as input, and automatically generates ﬁxes for each
conﬁguration error. Alternatively, ECC ﬁxer also allows th e
user to specify an inactive option to activate.
To implement our algorithm, one important step is to
convert the constraint in the CDL model into the standard
input format of the SMT solver: SMT-LIB [17]. To perform
this task, we carefully studied the formal semantics of CDL
[14], [18] through reverse engineering from its conﬁgurato rs
and documents. However, there are still two problems to deal
with. First, CDL is an untyped language, while SMT-LIB is
a typed language. To convert CDL, we implement a type
inference algorithm to infer the types of the options based
on their uses. When a unique type cannot be inferred or type
conﬂicts occur, we manually decide the feature types.
The second problem is dealing with string constraints.
The satisﬁability problem of string constraints is undecid able
in general [19], and general SMT solvers do not support
string constraints [11]. Yet, string constraints are heavi ly
used in CDL models. Nevertheless, our previous study on
CDL constraints [6] actually shows that the string constrai nts
used in these models employ a set semantics: a string is
considered as a set of substrings separated by spaces, and
string functions are actually set operations. For example,
1Available at: gsd.uwaterloo.ca/eccﬁxerTable II: Constraint violations
Architecture Erros in defaults Errors in changes Activatin g
virtex4 56 5 15
xilinx 48 1 2
ea2468 8 8 1
aki3068net 26 3 0
gps4020 12 10 4
arcom-viper 26 0 0
is_substr is actually a set member test. Based on this
discovery, we encode each string as a bit vector, where each
bit indicates whether a particular substring is presented o r
not. Since in ﬁx generation we will never need to introduce
new substrings, the size of the bit vector is always ﬁnite and
can be determined by collecting all substrings in the model
and the current conﬁguration.
VI. E VALUATION
A. Methodology
To really know whether the approach works in practice,
several research questions further need to be answered by
empirical evaluation:
•RQ1 : How complex are the generated ﬁx lists? Does
minimality of units hold?
•RQ2 : Is Property 3 “minimality of variables” a good
heuristic rule in practice?
•RQ3 : How efﬁcient is our algorithm?
•RQ4 : Does our approach cover more user changes than
existing approaches?
•RQ5 : What are the differences among the three strate-
gies?
The evaluation uses 6 eCos conﬁguration ﬁles from 5
eCos-based open-source projects (Table I). Each ﬁle target s
a different hardware architecture (the ﬁrst column in Ta-
ble I); each architecture uses a different mixture of eCos
packages, yielding variability models with different opti ons
and constraints (columns three and four). The conﬁguration
process for a given model starts from the model’s default
conﬁguration; the last column in Table I speciﬁes the number
of changes made to the default conﬁguration in the project.
The evaluation needs a set of real-world constraint viola-
tions. Interestingly, the default conﬁguration for each mo del
already contains errors —violations of requires constraints.
The ﬁrst column in Table II shows their numbers. The
models share common core packages, causing duplicated
errors. A set of 68 errors remain after removing duplicates.
To retrieve more violations from user changes, we at-
tempted to recover the sequence of user changes from the
revision history of the conﬁguration ﬁles. We assume that
the user starts from the default conﬁguration and solves
errors from defaults by accepting the suggestions from
the eCos conﬁgurator. We recorded this corrected default
conﬁguration as the ﬁrst version. Then we compared each
pair of consecutive revisions to ﬁnd changes to options. Nex t95Number of fixesNumber of violations01020304050
0 1 2 3 4 5 8 9
Figure 5: The number of ﬁxes per violation
we replayed these changes to simulate the real conﬁguration
process. Since we do not know the order of changes within
a revision, we used three orders: a top-down exploration of
the conﬁguration ﬁle, a bottom-up one, and a random one.
The rationale for the ﬁrst two orders is that expert users
sometimes edit the textual conﬁguration ﬁle directly rathe r
than using the graphical conﬁgurator. In this case, they wil l
read the options in the order that they appear in the ﬁle, or
the inverse if they scroll from bottom to top.
We replayed the changes as just explained and collected
(i) errors—violating requires constraints—and (ii) activation
violations . An activation violation occurs when an option
value should be changed, but is currently inactive. The last
two columns in Table II show the numbers of the resulting
violations from changes. After duplicate removal, 27 error s
and 22 activation violations remain; together with the ﬁrst
dataset, we have a total of 117multi-constraint violations.
Finally, we invoked our tool to generate ﬁxes for the
117 violations. For RQ4, we also invoked the built-in ﬁx
generator of the eCos conﬁgurator on the 27 errors from the
user changes. The activation violations were not compared
because they are not supported by the eCos conﬁgurator. The
experiments were executed on computer with Intel Core i5
2.4 GHz CPU and 4 GB memory.
B. Results
We ﬁrst give the results for RQ1-RQ4 using the propaga-
tion strategy. We answer RQ5 by presenting the comparison
of the three strategies last.
RQ1 To answer RQ1, we ﬁrst calculated two basic measures
over the 117 violations: the distribution of the number of
ﬁxes per violation (see Figure 5) and the distribution of the
number of variables changed by each ﬁx (see Figure 6).
From these ﬁgures we see that most ﬁx lists were short
and most ﬁxes changed a small number of variables. More
concretely, 95% of the ﬁx lists contain at most ﬁve ﬁxes and
75% of the ﬁxes change less than ﬁve variables. There was
also an activation violation that did not produce any ﬁx. A
deeper investigation of this violation revealed that the op tion
is not supported by the current hardware architecture, and
cannot be activated without introducing new conﬁguration
errors. The extracted changes actually lead to an unsolved
conﬁguration error in the subsequent version.Number of variables per fixNumber of fixes020406080
1 2 3 4 5 6 7 8 9
Figure 6: The number of variables per ﬁx
Size of fix listNumber of violations010203040
0 1 2 3 4 6 7 8 9 16182338565758
Figure 7: The sizes of ﬁx lists
It is still unclear how the combination of ﬁx number and
ﬁx size affect the size of a ﬁx list, and how the large ﬁxes
and long lists are distributed in the violations. To underst and
this, we measured the size of a ﬁx list. The size of a ﬁx list
is deﬁned as the sum of the number of variables in each ﬁx.
The result is shown in Figure 7. From the ﬁgure we can see
that the propagation strategy did lead to large ﬁx lists. The
largest involves 58 variables, which is not easily readable .
However, the long lists and large ﬁxes tend to appear only
on a relatively few number of violations, and the majority
of the ﬁx lists are still small: 83% of the violations have ﬁx
lists with less than 10 variables.
We also measured the number of variables in each ﬁx
unit to understand how large the ﬁx units are. It turned out
that every ﬁx unit contains only one variable. This shows
that (1) our algorithm effectively satisﬁes the “minimalit y
of units” property on all the violations, and (2) ranges
declared on more than one variable (such as the second ﬁx
for violation (1)) never appeared in the evaluation.
RQ2 To answer RQ2, we evaluated how often the ﬁnal user
changes are covered by our ﬁxes. Given an error or activation
violation, we examined the change history to identify a
subsequent conﬁguration that corrected the problem, and
then we checked if the values in the corrected conﬁguration
fell within one of the ranges proposed by our generated ﬁxes.
Out of all 49 violation from user changes, a total of 47
had corrections in subsequent revisions. The ﬁxes generate d
by our tool covered 46 of these violations (98%). An
investigation into the remaining violation showed that the
erroneous option discussed in RQ1 was responsible for
that discrepancy. Since the propagation strategy ensures t o
introduce no new error, the simulated user change was not
proposed as a ﬁx.96Generation Time (ms)Density of violations0.0000.0050.0100.0150.0200.025
50 100 150 200
Figure 8: Fix generation time
RQ3 For each of the 117 violations, we invoked the ﬁx
generator 100 times, and calculated the average time. The
result is presented as a density graph in Figure 8. Most ﬁxes
were generated within 100 ms. Some ﬁxes required about
200 ms, which is still acceptable for interactive tools.
RQ4 We measured whether the ﬁxes proposed by the eCos
conﬁgurator for the 27 errors cover the user changes in the
same way as in RQ2. There are 26 out of 27 errors that
have subsequent corrections. The eCos conﬁgurator was able
to handle 19of the 26errors, giving a coverage of 73%.
Comparatively, our tool covered all 26errors.
RQ5 As discussed in Section IV, the propagation strategy
potentially produces large ﬁx lists. At this stage, we would
like to know if the other two strategies actually produce
simpler ﬁxes. We compared the size of ﬁx lists generated
by the three strategies in Figure 9. The elimination and
ignorance strategies completely avoided large ﬁx lists, wi th
the largest ﬁx list containing four variables in total. The
elimination strategy changed even fewer variables because
some of the larger ﬁxes were eliminated.
We also compared the generation time of the three strate-
gies. For all violations, the average generation time for
the propagation strategy was 50ms, while the elimination
strategy was 20ms and the ignorance strategy was 17ms.
Since the overall generation time is small, it does not make
a big difference in tooling.
Next, we want to understand to what extent the elimi-
nation strategy affects completeness. In all 117 violation s,
the elimination strategy generated no ﬁx for 17 violations.
This is signiﬁcantly more than ignorance and propagation,
which had zero and one violation with no ﬁx, respectively.
We also measured the coverage of user changes using the
elimination strategy. In the 47 violations, only 27 were
covered, giving a coverage of 57%. This is even lower than
the eCos conﬁgurator, which generates only one ﬁx, showing
that a lot of useful ﬁxes were eliminated by this strategy.
Finally, we want to understand how often the ignorance
strategy brings new errors. We compared the ﬁx list of
the ignorance strategy with the ﬁx list of the elimination
strategy. If a ﬁx does not appear in the list of elimination
strategy, it must bring new errors. As a result, 32% of the
ﬁxes generated by the ignorance strategy brought new errors ,
and those ﬁxes were generated from 44% of the constraintSize of fix listNumber of violations0102030405060
0102030405060
0102030405060
0 1 2 3 4 6 7 8 9 16 18 23 38 56 57 58Elimination Ignorance Propagation
Figure 9: The sizes of ﬁx lists in the three strategies
violations. This shows that the constraints in practice are
usually inter-related and the ignorance strategy potentia lly
causes new errors in many cases.
VII. T HREATS TO VALIDITY
We see two main threats to external validity. First, we
evaluated our approach on only one variability language.
However, Berger et al. [2] study and compare three variabil-
ity languages—CDL, Kconﬁg and feature modeling—and
ﬁnd that CDL has the most complex constructs for declaring
constraints, and constraints in CDL models are signiﬁcantl y
more complex than those in Kconﬁg models. Thus, our result
is probably generalizable to the other two other languages.
The second threat is that our evaluation is a simulation
rather than an actual conﬁguration process. We addressed
this threat by using the models of six architectures and con-
ﬁgurations gathered from ﬁve projects. The conﬁgurations
and changes have a wide range of characteristics as shown
in Tables I and II. However, these changes may not yet be
representative of the problems that real users encountered .
We hope to address this threat by running a user study in
an industry setting in the future.
A threat to internal validity is that our translation of CDL
into logic constraints could be incorrect. To address this
threat, we have developed a formal speciﬁcation of CDL
semantics in functional style [18], in addition to the one
developed by Berger et al. [14]. We have carefully inspected
and compared both against each other and tested them on
examples with respect to the eCos conﬁgurator.
VIII. R ELATED WORK
The idea of automatic ﬁx generation is not new. Nentwich
et al. [15] propose an approach that generates abstract ﬁxes
from ﬁrst-order logic rules. Their ﬁxes are abstract becaus e
they only specify the variables to change and trust the
user to chose a correct value. In contrast, our approach
also gives the range of values for a variable. Furthermore,
their approach only supports “ =” and “ /ne}ationslash=” as predicates
and, thereby, cannot handle models like eCos. Scheffczyk et97al. [20] enhance Nentwich et al.’s approach by generating
concrete ﬁxes. However, this approach requires manually
writing ﬁx generation procedures for each use of a predicate
in every constraint, which is not suitable for variability
models, often containing hundreds of constraints. Egyed et
al. [16] propose to write such procedures for each type of
variable rather than each constraint to reduce the amount
of code written and apply this idea to UML ﬁx generation.
Yet, in variability models, the number of variables is often
larger than the number of constraints. The actual reduction
of code is thus not clear. Jose and Majumdar [7] propose
an approach to localize faults in imperative programs, and,
as an extension to the approach, generate ﬁxes for certain
types of faults using heuristic rules. However, their heuri stic
rules are speciﬁc to imperative programs, and it is not clear
whether they are applicable to software conﬁguration. Also ,
they propose at most one ﬁx each time rather than a complete
list.
Fix generation approaches for variability models also ex-
ist. The eCos conﬁgurator [12] has an internal ﬁx generator,
producing ﬁxes upon request or on-the-ﬂy when the user
makes changes. White et al. [8] propose an approach to gen-
erate ﬁxes that resolve all errors in one step. Compared with
our work, both related approaches produce one concrete ﬁx
rather than a complete list of range ﬁxes. Furthermore, they
have very limited support of non-Boolean constraints. White
et al.’s approach does not handle non-Boolean constraints
at all, while eCos conﬁgurator supports only non-Boolean
constraints in a simple form: v⊕cwhere vis a variable, c
is a constant, and ⊕is an equality or inequality operator.
Another set of approaches maintain the consistency of
a conﬁguration. Valid domains computation [21], [22] is an
approach that propagates decisions automatically. Initia lly all
options are set to an unknown state. When the user assigns a
value to an option, it is recorded as a decision, and all other
options whose values are determined by this decision are
automatically set. In this way, no error can be introduced.
Janota et al. [23] propose an approach to complete a partial
conﬁguration by automatically setting the unknown options
in a safe way. However, both approaches require that the
conﬁguration starts with variables in the unknown state.
Software conﬁguration in real world is often “reconﬁgura-
tion” [2], i.e., the user starts with a default conﬁguration , and
then makes change to it. In reconﬁguration cases, variables
have assigned concrete values rather than the unknown state .
Furthermore, the related approaches are designed for small
ﬁnite domains, and it is not clear whether they are scalable
to large domains such as integers.
Several approaches have been proposed to test and debug
the construction of variability models themselves. Trinid ad
et al. [24] use Reiter’s theory of diagnosis [9] to detect
several types of deﬁciencies in FODA feature models. Wang
et al. [25] automatically ﬁx deﬁciencies based on the priori ty
assigned to constraints. These approaches target the con-struction of variability models and cannot be easily migrat ed
to conﬁguration.
Others automatically ﬁx errors without user intervention.
Demsky and Rinard [26] propose an approach to ﬁx runtime
data structure errors according to the constraint on the dat a
structure. Mani et al. [27] use the hidden constraints in a
transformation program to ﬁx input model faults. Xiong et
al. [28] propose a language to construct an error-ﬁxing pro-
gram consistently and concisely. Compared to our approach,
these approaches also infer ﬁxes from constraints, but they
only need to generate one ﬁx that is automatically applied.
Completeness is not considered by these approaches.
The HS-DAG algorithm is often used in combination with
the QuickXPlain algorithm [29]. The QuickXPlain algo-
rithm computes the preferred explanations and relaxations
for over-constrained problems. This combination has been
successfully applied in recommender systems to ﬁnd the
most representative relaxations of a set of requirements,
i.e., those with highest likelihood of being chosen by the
users [30]–[32]. O’Sullivan et al. [33] propose an alternat ive
algorithm for the same problem. The most representative
relaxations are then used to propose alternative solutions
based on a database of known operational solutions. The
ﬁltering of ﬁxes is a possible extension to our work.
IX. C ONCLUSION AND FUTURE WORK
Range ﬁxes provide alternative solutions to constraint
violations in software conﬁguration. They are correct, min -
imal in the number of variables per ﬁx, maximal in their
ranges, and complete. We also evaluated three different
strategies for handling the interaction of constraints: ig -
norance, elimination, and propagation. No single strategy
is absolutely better than the others, but on our data set,
the propagation strategy provides the most complete ﬁx
lists without introducing new errors, and the ﬁx sizes and
generation times are within acceptable ranges. However, if
more complex situations are encountered, elimination or
ignorance can provide simpler ﬁx lists and faster generatio n
time, at the expense of completeness or the guarantee not to
introduce new errors.
We highlight two future directions. Regarding evaluation,
we still need to evaluate the approach on more languages
and models, and with real world user studies. Regarding
constraint interaction, since no single strategy works bes t
in all aspects, it would be worth exploring new methods to
combine these strategies for better ﬁx lists.
REFERENCES
[1] L. Chen and M. Ali Babar, “A systematic review of evaluation
of variability management approaches in software product
lines,” Information and Software Technology , vol. 53, no. 4,
pp. 344–362, 2011.
[2] T. Berger, S. She, R. Lotufo, A. Wasowski, and K. Czarnecki,
“Variability modeling in the real: a perspective from the
operating systems domain,” in ASE. ACM, 2010, pp. 73–82.98[3] K. Kang, S. Cohen, J. Hess, W. Novak, and A. Peter-
son, “Feature-oriented domain analysis (FODA) feasibility
study,” Carnegie-Mellon Univ, Tech. Rep. CMU/SEI-90-TR-
21, 1990.
[4] S. She, R. Lotufo, T. Berger, A. Wasowski, and K. Czarnecki,
“Reverse engineering feature models,” in ICSE . ACM Press,
2011, pp. 461–470.
[5] A. Hubaux, Y . Xiong, and K. Czarnecki, “A user survey
of conﬁguration challenges in Linux and eCos,” in VaMoS .
ACM press, 2012, pp. 149–155.
[6] L. Passos, M. Novakovic, Y . Xiong, T. Berger, K. Czarnecki,
and A. Wasowski, “A study of non-boolean constraints in
variability models of an embedded operating system,” in
FOSD . ACM, 2011, pp. 2:1–2:8.
[7] M. Jose and R. Majumdar, “Cause clue clauses: error local-
ization using maximum satisﬁability,” in PLDI . ACM, 2011,
pp. 437–446.
[8] J. White, D. C. Schmidt, D. Benavides, P. Trinidad, and
A. Ruiz-Cort ´es, “Automated diagnosis of product-line conﬁg-
uration errors in feature models,” in SPLC . IEEE Computer
Society, 2008, pp. 225–234.
[9] R. Reiter, “A theory of diagnosis from ﬁrst principles,”
Artiﬁcial intelligence , vol. 32, no. 1, pp. 57–95, 1987.
[10] R. Greiner, B. Smith, and R. Wilkerson, “A correction to the
algorithm in Reiter’s theory of diagnosis,” Artiﬁcial Intelli-
gence , vol. 41, no. 1, pp. 79–88, 1989.
[11] L. De Moura and N. Bjørner, “Z3: an efﬁcient SMT solver,”
inTACAS/ETAPS . Springer-Verlag, 2008, pp. 337–340.
[12] B. Veer and J. Dallaway, “The eCos component writer’s
guide,” ecos.sourceware.org/ecos/docs-latest/cdl-guide/
cdl-guide.html, 2001.
[13] K. Czarnecki and A. Wasowski, “Feature diagrams and logics:
There and back again,” in SPLC . IEEE Computer Society,
2007, pp. 23–34.
[14] T. Berger and S. She, “Formal semantics of the CDL
language,” www.informatik.uni-leipzig.de/∼berger/cdl
semantics.pdf, 2010.
[15] C. Nentwich, W. Emmerich, and A. Finkelstein, “Consistency
management with repair actions,” in ICSE . IEEE Computer
Society, 2003, pp. 455–464.
[16] A. Egyed, E. Letier, and A. Finkelstein, “Generating and
evaluating choices for ﬁxing inconsistencies in UML design
models,” in ASE. IEEE Computer Society, 2008, pp. 99–108.
[17] C. Barrett, A. Stump, and C. Tinelli, “The SMT-LIB standard:
Version 2.0,” http://www.smtlib.org/, 2010.
[18] Y . Xiong, “Conﬁgurator semantics of the CDL language,”
Generative Software Development Laboratory, University of
Waterloo, Tech. Rep. GSDLAB-TR 2011-06-05, 2011, http:
//gsd.uwaterloo.ca/GSDLAB-TR2011-06-05.[19] N. Bjørner, N. Tillmann, and A. V oronkov, “Path feasibil-
ity analysis for string-manipulating programs,” in TACAS .
Springer-Verlag, 2009, pp. 307–321.
[20] J. Scheffczyk, P. R ¨odig, U. M. Borghoff, and L. Schmitz,
“Managing inconsistent repositories via prioritized repairs,”
inDocEng . ACM, 2004.
[21] T. Hadzic, S. Subbarayan, R. M. Jensen, H. R. Andersen,
J. Møller, and H. Hulgaard, “Fast backtrack-free product con-
ﬁguration using a precompiled solution space representation,”
inPETO . DTU-tryk, 2004, pp. 131–138.
[22] M. Mendonc ¸a, “Efﬁcient reasoning techniques for large scale
feature models,” Ph.D. dissertation, University of Waterloo,
2009.
[23] M. Janota, G. Botterweck, R. Grigore, and J. Marques-Silva,
“How to complete an interactive conﬁguration process?” in
SOFSEM . Springer-Verlag, 2010, pp. 528–539.
[24] P. Trinidad, D. Benavides, A. Dur ´an, A. Ruiz-Cort ´es, and
M. Toro, “Automated error analysis for the agilization of
feature modeling,” Journal of Systems and Software , vol. 81,
no. 6, pp. 883–896, 2008.
[25] B. Wang, Y . Xiong, Z. Hu, H. Zhao, W. Zhang, and H. Mei,
“A dynamic-priority based approach to ﬁxing inconsistent
feature models,” in MODELS . Springer-Verlag, 2010, pp.
181–195.
[26] B. Demsky and M. Rinard, “Automatic detection and repair
of errors in data structures,” in OOPSLA . ACM, 2003, pp.
78–95.
[27] S. Mani, V . S. Sinha, P. Dhoolia, and S. Sinha, “Automated
support for repairing input-model faults,” in ASE. ACM,
2010, pp. 195–204.
[28] Y . Xiong, Z. Hu, H. Zhao, H. Song, M. Takeichi, and
H. Mei, “Supporting automatic model inconsistency ﬁxing,”
inESEC/FSE . ACM, 2009, pp. 315–324.
[29] U. Junker, “QUICKXPLAIN: preferred explanations and re-
laxations for over-constrained problems,” in AAAI . AAAI
Press, 2004, pp. 167–172.
[30] A. Felfernig, G. Friedrich, D. Jannach, and M. Stumptner,
“Consistency-based diagnosis of conﬁguration knowledge
bases,” Artiﬁcial Intelligence , vol. 152, pp. 213–234, 2004.
[31] D. Jannach and J. Liegl, “Conﬂict-directed relaxation of
constraints in content-based recommender systems,” in Ad-
vances in Applied Artiﬁcial Intelligence . Springer Berlin /
Heidelberg, 2006, vol. 4031, pp. 819–829.
[32] A. Felfernig, G. Friedrich, M. Schubert, M. Mandl, M. Mair-
itsch, and E. Teppan, “Plausible repairs for inconsistent
requirements,” in IJCAI . Morgan Kaufmann Publishers Inc.,
2009, pp. 791–796.
[33] B. O’Sullivan, A. Papadopoulos, B. Faltings, and P. Pu,
“Representative explanations for over-constrained problems,”
inAAAI . AAAI Press, 2007, pp. 323–328.99