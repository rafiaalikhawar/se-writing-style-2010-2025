Formalizing Hardware/Software Interface
SpeciÔ¨Åcations
Juncao Li1, Fei Xie2, Thomas Ball1, Vladimir Levin1, and Con McGarvey1
1Microsoft Corporation, Redmond, WA 98052, USA. Email: {juncaoli, tball, vladlev, conmc }@microsoft.com
2Dept. of Computer Science, Portland State University, Portland, OR 97207, USA. Email: xie@cs.pdx.edu
Abstract ‚ÄîSoftware drivers are usually developed after hard-
ware devices become available. This dependency can induce a
long product cycle. Although co-simulation and co-veriÔ¨Åcation
techniques have been utilized to facilitate the driver develop-
ment, Hardware/Software (HW/SW) interface models, as the
test harnesses, are often challenging to specify. Such interface
models should have formal semantics, be efÔ¨Åcient for testing,
and cover all HW/SW behaviors described by HW/SW interface
protocols. We present an approach to formalizing HW/SW
interface speciÔ¨Åcations, where we propose a semantic model,
relative atomicity, to capture the concurrency model in HW/SW
interfaces; demonstrate our approach via a realistic example;
elaborate on how we have utilized this approach in device/driver
development process; and discuss criteria for evaluating our
formal speciÔ¨Åcations. We have detected Ô¨Åfteen issues in four
English speciÔ¨Åcations. Furthermore, our formal speciÔ¨Åcations are
readily useful as the test harnesses for co-veriÔ¨Åcation, which has
discovered twelve real bugs in Ô¨Åve industrial driver programs.
I. I NTRODUCTION
In modern computer systems such as PC, devices and
drivers are usually manufactured separately, because their
development processes need highly different expertise. Driver
development commonly requires the device‚Äôs presence in order
to exercise the functionalities and test the implementation con-
formance to Hardware/Software (HW/SW) interface protocols.
To alleviate such dependency and shorten the product cycle,
co-simulation and co-veriÔ¨Åcation techniques have been utilized
to facilitate the driver development [1], [2]. One key challenge
is to develop the test harnesses, i.e., HW/SW interface models.
Such models need to be abstract enough to ensure the test
efÔ¨Åciency; however, they also should be accurate to avoid false
positives.
Currently, English is the de facto language for specifying
HW/SW interface protocols. Since many such protocols are
public standards, their English speciÔ¨Åcations need to be self-
explanatory. However, English does not have formal seman-
tics; therefore these speciÔ¨Åcations commonly contain ambigu-
ities and inconsistencies. Figure 1 illustrates an excerpt from
the English document of the Intel 8255x 10/100Mbps Ethernet
Controller SpeciÔ¨Åcation [3]. This excerpt describes how the
shared memory between hardware and software should be
operated by hardware when a CU/RU (Command Unit/Receive
Unit) command is issued from software. There are two issues:
First, the content of Table 15 is inconsistent with its title
(underlined, the RU and CU difference). Second, the CU
HPQ Start command is neither deÔ¨Åned nor mentioned in
any other part of this document. This is quite confusing
Fig. 1. Excerpt from Intel Ethernet Controller document.
when compared to the CU Start command. Such kind of
speciÔ¨Åcation issues pervasively exist (see Section VIII for
details) in various English documents for HW/SW interfaces.
These issues can cause confusion, produce bugs, and lead to
product failures. Therefore, formal HW/SW interface models
are greatly desired to augment English speciÔ¨Åcations.
We characterize the problems in device/driver development
and present a practical approach to formalizing the HW/SW
interface speciÔ¨Åcations, where B ¬®uchi Automata (BA) [4] and
Labeled Pushdown Systems (LPDSs) [5] serve as the founda-
tional formal models for hardware and software respectively.
Our approach has the following contributions:
‚Ä¢Relative atomicity. We propose a semantic model, rela-
tive atomicity, to capture the various atomicity levels in
HW/SW interface designs. Relative atomicity can greatly
simplify the concurrency model for HW/SW interface
speciÔ¨Åcations by excluding infeasible context-switches.
‚Ä¢SpeciÔ¨Åcation of HW/SW interface protocols. We develop
a formal speciÔ¨Åcation approach for HW/SW interface
protocols and demonstrate it via a realistic example. We
design a speciÔ¨Åcation language, modelC, that utilizes the
C semantics with three restrictions to achieve Ô¨Ånite state
and two extensions to support relative atomicity and non-
determinism.
‚Ä¢Protocol coverage. We strictly follow HW/SW inter-
face protocols to specify formal models. Therefore, all
HW/SW behaviors allowed by protocols are captured by
formal models. This is very important to ensure the test
coverage when formal models are used as test harnesses.
‚Ä¢Application and evaluation criteria. We present how our
approach can be applied to the device/driver developmentprocess and discuss four criteria for evaluating our formal
speciÔ¨Åcations. One key idea is the MODEL-DOC ratio
that helps establish a quantitative relation between formal
speciÔ¨Åcations and English speciÔ¨Åcations.
We have formalized four types of HW/SW interfaces, such
as Ethernet controller devices/drivers and USB (Universal
Serial Bus) devices/drivers. We detected Ô¨Åfteen issues in the
English speciÔ¨Åcations. Furthermore, our formal speciÔ¨Åcations
are readily useful as the test harness to verify Ô¨Åve Windows
driver implementations with respect to their device behav-
iors. All the drivers had been well tested. However, our
co-veriÔ¨Åcation tool, CoVer [6], still discovered twelve real
bugs. These speciÔ¨Åcation issues and driver bugs (conÔ¨Årmed
by Windows architects) are previously unknown to either the
hardware or software engineers.
Outline. The rest of this paper is organized as follows.
Section II discusses the related work. Section III introduces
the background of this paper. Section IV summarizes a com-
mon development process for devices/drivers in industrial
settings. Section V presents the speciÔ¨Åcation techniques we
have designed for HW/SW interfaces. Section VI demonstrates
our formal speciÔ¨Åcation approach via a realistic example.
Section VII elaborates on the application of our approach in
the device/driver development process as well as the criteria
that we have proposed for evaluating our formal speciÔ¨Åca-
tions. Section VIII presents the evaluation results. Section IX
concludes and discusses the future work.
II. R ELATED WORK
There has been lots of research on formalizing interface
semantics, such as I/O automata by Lynch, et al. [7], interface
automata by De Alfaro, et al. [8], and !-automata used in
component-based design of embedded systems by Li, et al. [9].
Kroening, et al. [10] have used SystemC [11] to specify
HW/SW interface designs. However, none of the research is
suitable for representing software implementations, since the
stack is not formally modeled. We model the software stack, so
that our speciÔ¨Åcation can closely resemble the implementation
semantics of HW/SW interface. As a signiÔ¨Åcant beneÔ¨Åt, our
formal speciÔ¨Åcations can be used, without any modiÔ¨Åcation, as
the test harness for software (resp. hardware) implementations.
Therefore, many previously unknown driver bugs have been
discovered by our co-veriÔ¨Åcation tool.
Another approach that models HW/SW interface is exempli-
Ô¨Åed by Monniaux [2], where both hardware and software are
speciÔ¨Åed using C programs, formally two Pushdown Systems
(PDSs) [12]. The HW/SW concurrency is modeled by a
straightforward composition of the two PDSs. Representing
hardware also as a PDS is neither necessary nor efÔ¨Åcient,
because hardware designs do not require a stack and veriÔ¨Å-
cation of concurrent PDS, as the product of multiple PDSs,
costs much more efforts than that of a single PDS (veriÔ¨Åcation
of concurrent PDS is undecidable in general) [13]. Monniaux
has applied this approach to verify USB host controller driver
implementations; however, no real bug was found.Kuznetsov, et al. [1] have developed HW/SW interface
models to test Windows drivers via symbolic execution. In
their approach, most hardware design logic is abstracted away
by non-determinism; therefore, the interface models cannot
serve as HW/SW interface speciÔ¨Åcations. Furthermore, false
bugs may be reported due to the over abstraction of the
hardware behaviors.
In practice, Ô¨Ånite state machines, such as !-automata and
BA [4], are common representations for hardware. PDS-
equivalent models [12] are common representations for soft-
ware. For example, COSPAN/FormalCheck [14] uses !-
automata as the formal representation of hardware. The SLAM
engine [15] veriÔ¨Åes C programs for safety properties, where
Boolean program, a PDS-equivalent model, is used as the
software representation. Furthermore, concurrent PDS is a
suitable model for multi-threaded software, since each soft-
ware thread contains a stack that needs to be represented.
Although veriÔ¨Åcation of concurrent PDS is undecidable [13] in
general, decidability can be achieved by bounding the number
of context-switches [16].
III. B ACKGROUND
This section introduces the background of our research.
First, we discuss the formal representations for hardware
and software respectively. Second, we introduce the Windows
driver framework that will be used as examples throughout the
rest of this paper.
A. Formal Representations
B¬®uchi Automaton (BA) as the hardware representation.
ABAB[4] is a tuple (Œ£; Q; ; q 0; F), where Œ£is the input
alphabet, Qis the Ô¨Ånite set of states, ‚äÜ(Q√óŒ£√óQ)is the
set of state transitions, q0‚ààQis the initial state, and F‚äÜQ
is the set of Ô¨Ånal states. Baccepts an inÔ¨Ånite input string iff (if
and only if) it has a run over the string that visits at least one
of the Ô¨Ånal states inÔ¨Ånitely often. We use q‚Üíq‚Ä≤to denote a
BA transition from state qtoq‚Ä≤with the input symbol .
Labeled Pushdown System (LPDS) as the software repre-
sentation. AnLPDS P[5], is a tuple (I; G; Œì;‚àÜ;‚ü®g0; !0‚ü©),
where Iis the input alphabet, Gis a Ô¨Ånite set of global states,
Œìis a Ô¨Ånite stack alphabet, ‚àÜ‚äÜ(G√óŒì)√óI√ó(G√óŒì‚àó)
is a Ô¨Ånite set of LPDS rules, and ‚ü®g0; !0‚ü© ‚ààG√óŒì‚àóis the
initial conÔ¨Åguration. LPDS extends PDS in such a way that
an LPDS can take input. A conÔ¨Åguration of Pis a pair ‚ü®g; !‚ü©
representing a software state, where g‚ààGis a global state
andw‚ààŒì‚àóis a stack content. An LPDS rule is written as
‚ü®g; ‚ü©,‚Üí ‚ü®g‚Ä≤; w‚ü©, where ‚ààI,((g; ); ;(g‚Ä≤; w))‚àà‚àÜ, and
‚ü®g; ‚ü©is referred to as the head of this rule.
Concurrent Labeled Pushdown System (CLPDS). A
CLPDS CP, as the product of multiple LPDS, is a tuple
(I; G; Œì;‚àÜ0; : : : ; ‚àÜN;‚ü®g0; !0; : : : ; ! 0‚ü©), where N > 0. A
CLPDS CPis different from an LPDS Pin the sense that CP
has more than one stack. For each stack, there is a set of LPDS
rules ‚àÜi, where 0‚â§i‚â§N. A CLPDS rule has the form of
‚ü®g; 0; : : : ;  i; : : : ;  n;‚ü©,‚ÜíCP‚ü®g‚Ä≤; 0; : : : ; ! i; : : : ;  n‚ü©, where
‚ü®g; i‚ü©,‚Üí ‚ü®g‚Ä≤; !i‚ü© ‚àà ‚àÜi. There is only one stack content
2updated in a CLPDS transition. We refer to the LPDS rule
that is selected to be executed in a CLPDS rule as the active
LPDS rule. CLPDS can represent multi-threaded software.
Synchronizing BA and LPDS (resp. CLPDS). We demon-
strate how to combine the execution of BA Band LPDS P
(reps. CLPDS CP). Since a CLPDS rule actually depends
on its active LPDS rule, we only need to study how to
combine BA transitions and LPDS rules. We deÔ¨Åne (1) the
input alphabet of Bas the power set of the set of atomic
propositions that may hold on a conÔ¨Åguration of P; (2) the
input alphabet of Pas the power set of the set of atomic
propositions that may hold on a state of B; and (3) two labeling
functions as follows:
‚Ä¢LP2B: (G√óŒì)‚ÜíŒ£, which associates the head of an
LPDS rule with the set of propositions that hold on it.
‚Ä¢LB2P:Q‚ÜíI, which associates a state of Bwith the
set of propositions that hold on it.
Given a BA transition t=q‚Üíq‚Ä≤‚ààand an LPDS rule r=
‚ü®g; ‚ü©,‚Üí ‚ü®g‚Ä≤; !‚ü© ‚àà‚àÜ, they enable each other iff ‚äÜLB2P(q)
and‚äÜLP2B(‚ü®g; ‚ü©). Furthermore, let rbe the active LPDS
rule of a CLPDS rule r‚Ä≤, we also say that tandr‚Ä≤enable each
other.
B. Windows Driver Framework
Drivers check device status or send commands to devices
by reading or writing device registers, and receive notiÔ¨Åcation
of state changes from devices through interrupts. In Win-
dows [17], devices and drivers are organized through stacks as
illustrated in Figure 2. Each layer of a driver stack services a
Function driver (e.g., mouse, network card)
Bus driver (e.g., PCI, USB)
Intermediate software layers
Software
Hardware
Bus device (e.g., PCI, USB)
Function device (e.g., mouse, network card)DDI (Device Driver Interface) ISR (Interrupt Service Routine)
Interrupt
InterruptSignal
SignalIntermediate hardware layers
Interrupt SignalDDI ISRDDI ISR
Fig. 2. A generic view of Windows device and driver stacks.
layer of the corresponding device stack. Different layers of a
driver stack usually have different I/O interfaces. For example,
USB drivers use Device Driver Interface (DDI) functions such
asWdfUsbRetrieveConfigDescriptor to read USB
device registers; PCI drivers read device registers using DDI
functions such as READ_REGISTER_UCHAR .
One common method to classify device (resp. driver) layers
is by deciding whether devices of a layer interconnect other
devices. If yes, this type of devices are referred to as bus
devices, e.g., PCI (Peripheral Component Interconnect) bus;otherwise, this type of devices are referred to as function
devices, e.g., a network adapter card connected to the PCI bus.
We usually refer to function devices (resp. function drivers)
directly as devices (resp. drivers). For example, a PCI function
device is referred to as a PCI device.
IV. C OMMON DEVELOPMENT PROCESS OF
DEVICES /DRIVERS
As illustrated in Figure 3, we have observed a common
development process for device/driver frameworks in industrial
settings, where a device/driver framework (e.g., USB) refers to
a type of HW/SW interface as well as the devices and drivers
that both utilize this interface. The development process has
three stages:
Design
HW/SW interface
protocolDraft
specificationManual proof
readingIssues detected
Published English
specificationPassed
Develop devices
or driversDevices or
drivers
Failed
In-house testing
Passed
Released products
Conformance testing Certification:
PassedDesign
Stage
Development
Stage
Post-release
StageEnglish
Ship the productFailed
Fig. 3. Development process of device/driver frameworks.
Design stage. Usually, a device/driver framework is initially
designed by a group of hardware and software companies
together. The HW/SW interface protocol is described in a
draft English speciÔ¨Åcation which is shared between these
participant companies for revision. Engineers from these com-
panies proof-read the English speciÔ¨Åcation and try to identify
potential problems in the HW/SW interface design.
Development stage. The English speciÔ¨Åcation is made public
after it has been agreed upon by the participant companies.
The companies will start to develop their own hardware
(resp. software) products for this device/driver framework
based on the English speciÔ¨Åcation. During this stage, other
companies, who have not participated in the design stage,
may also develop their own hardware (resp. software) products
that are compliant with this device/driver framework. How
well a product complies with the HW/SW interface protocol
highly depends on the development engineers‚Äô interpretations
of the English speciÔ¨Åcation. In order to further ensure the
HW/SW interface compliance, a product also needs to be
tested according to the English speciÔ¨Åcation. Because test
3engineers from different companies may have their own inter-
pretations of the speciÔ¨Åcation, the test cases vary; thus the test
coverage of different products can be signiÔ¨Åcantly different,
so is the products‚Äô quality in terms of the HW/SW interface
compatibilities. Figure 4 illustrates such an example, which
contains two excerpts respectively from a Linux driver and
a Windows driver for the same hardware device, the Intel
8255x 10/100Mbps Ethernet controller. The two C functions
respectively illustrated in Figure 4(a) and Figure 4(b) have the
same functionality which is to issue a software command to
the device; however the implementations are different. Before
issuing a new command, the Linux driver always waits until
the command register becomes free (this rule is indicated by
the English speciÔ¨Åcation); however the Windows driver does
not wait before issuing any new command unless the parameter
WaitForScb is set to be true, which is due to some kind of
performance optimization. Obviously, the Windows driver is
more efÔ¨Åcient, because it tries to avoid unnecessary checks on
hardware registers. On the other hand, it is also more challeng-
ing to maintain the driver‚Äôs correctness, because the driver de-
veloper must guarantee that when D100IssueScbCommand
is called with WaitForScb being FALSE , the command
register should always be free.
int e100 exec cmd( nic *nic, u8 cmd, dma addr t dma addr ) {
int err = 0;
. . .
spin lock irqsave( . . . );
/* Previous command is accepted when SCB clears */
for (i = 0; i <E100 WAIT SCB TIMEOUT; i++) {
/* If last command has been completed */
if (likely(!ioread8( &nic->csr->scb.cmd lo))) break;
cpu relax();
if (unlikely(i >E100 WAIT SCB FAST)) udelay(5);
}
/* If last command timeout */
if (unlikely(i == E100 WAIT SCB TIMEOUT)) {
err = -EAGAIN;
goto err unlock;
}
/* Issue a new command */
if (unlikely(cmd != cuc resume))
iowrite32(dma addr, &nic->csr->scb.gen ptr);
iowrite8(cmd, &nic->csr->scb.cmd lo);
errunlock: spin unlock irqrestore( . . . );
return err;
}
(a) Linux driver code excerpt.
NTSTATUS D100IssueScbCommand( PFDO DATA FdoData,
PUCHAR ScbCommandLow, BOOLEAN WaitForScb ) {
// Wait for the last command to complete?
if ( WaitForScb == TRUE ) {
if ( !WaitScb(FdoData) ) // Wait for the command register to become free
return (STATUS DEVICE DATA ERROR); // If last command timeout
}
// Issue a new command
WRITE REGISTER UCHAR (
((PUCHAR)(FdoData ->CSRAddress) + SCB COMMAND LOW BYTE),
ScbCommandLow );
return (STATUS SUCCESS);
}
(b) Windows driver code excerpt.
Fig. 4. Excerpts from the Linux and Windows drivers for the Intel 8255x
10/100Mbps Ethernet controller.Post-release stage. After a product passes in-house testing, the
company may choose to ship this product to market directly or
send it to a third-party organization for conformance testing.
Conformance testing decides whether a hardware (resp. soft-
ware) product complies with the HW/SW interface protocol.
Test cases are developed by engineers from the third-party
organization based on the English speciÔ¨Åcation. The product
passes the certiÔ¨Åcation if all the test cases succeed.
During the development process, it is desired that a formal
HW/SW interface model is present. This can help validate
the HW/SW interface design, convey the HW/SW interface
protocol precisely, and provide a uniform test harness for
devices/drivers.
V. S PECIFICATION TECHNIQUES FOR HW/SW
INTERFACES
In this section, we Ô¨Årst discuss the types of concurrency
related to HW/SW interfaces. Then, we present our approach
that utilizes Transaction Level Modeling (TLM) [11] to ab-
stract away hardware implementation details. Furthermore,
we propose a semantic model, relative atomicity, to simplify
the complexities of HW/SW interface speciÔ¨Åcations. We also
elaborate on how we utilize the concept of non-determinism in
our approach. At last, we present our speciÔ¨Åcation language,
modelC.
A. Concurrency in a HW/SW System
There are three types of concurrency related to HW/SW in-
terfaces: (1) hardware concurrency; (2) software concurrency;
and (3) HW/SW concurrency. They should be represented at
a proper level of details in HW/SW interface speciÔ¨Åcation.
Hardware concurrency. Hardware is concurrent in nature and
hardware concurrency exists in various levels of design ab-
stractions. From the view point of software, there are two types
of hardware concurrency: (1) concurrency between hardware
modules; and (2) concurrent assignments to hardware registers.
For example, an Intel Ethernet Controller [3] has modules
such as command unit, receiving unit, interrupt management,
etc. Although these modules are fully concurrent, they may
not be driven by the same clock signal; therefore, they are
asynchronous. Each module can be further divided into smaller
modules or directly implemented [18]. When a module is
directly implemented, its operation consists of a sequence
of steps that are driven by a clock signal. The states of
the module are maintained by hardware registers which are
updated simultaneously upon clock cycles. How the registers
should be updated each clock cycle depends on the registers‚Äô
states before the clock cycle and the transition rules speciÔ¨Åed
by the hardware design.
Software concurrency. Drivers are usually designed multi-
threaded. For example, multiple threads can run concurrently
to service different requests such as interrupts from hardware
and I/O requests from user applications. From the view
point of hardware, there are two types of software concur-
rency: (1) multiple threads concurrently operate hardware,
e.g., read/write hardware interface registers; and (2) an ISR
4is invoked to service a hardware interrupt, so the current-
executing thread will be preempted [17]. Conceptually, we
can understand each thread as an LPDS. The threads together
can be represented as a product of the LPDSs, i.e., a CLPDS
model. Since the veriÔ¨Åcation of CLPDS requires a lot more
efforts than that of LPDS [13], it is desired that software
behaviors are modeled using a single LPDS as much as
possible. As we shall demonstrate later, the second type of
software concurrency can be represented as a single LPDS
following the semantic model of relative atomicity.
HW/SW concurrency. A device and its driver run asyn-
chronously and only transition synchronously when they inter-
act through their interface. The HW/SW concurrency describes
two situations: (1) most of the time, software and hardware
transition asynchronously, so their states do not affect each
other; and (2) when hardware and software interact with each
other, their synchronous transition will be decided by the states
of both hardware and software.
B. Transaction Level Modeling of Hardware
We use BA as the formal representation of hardware, where
hardware behaviors are represented as BA transitions. We
utilize the idea of TLM to specify such BA transitions. TLM
is a common approach to hardware speciÔ¨Åcation, where the
design logic is speciÔ¨Åed by transaction functions while the
implementation details such as clock signals are abstracted
away.
Hardware transaction. Since our goal is to specify HW/SW
interface protocols, the design logic rather than the imple-
mentation details is relevant. Thus, the clock-driven semantic
feature of hardware implementations is unnecessary to be
preserved in our speciÔ¨Åcation. For example, a data-transfer
command is usually processed in multiple clock cycles; how-
ever it is only necessary to describe this command as one
hardware state transition from the view point of software.
We deÔ¨Åne a hardware transaction to represent a hardware
state transition (i.e., a BA transition) in an arbitrarily long
but Ô¨Ånite sequence of clock cycles. Hardware transactions
are atomic to software. The concept of hardware transaction
preserves hardware design logic that is visible to software, but
hides details that are only necessary for synthesizable Register
Transfer Level (RTL) designs [18].
Hardware transaction function. Consider a hardware trans-
action as a BA transition, we deÔ¨Åne a hardware transaction
function as a C function that describes a set of BA transitions
labeled by the same input symbol. Let the current-states and
next-states of a transaction function be ‚äÜQrepresenting
the hardware states when entering the function and ‚Ä≤‚äÜQ
representing the hardware states when exiting the function
respectively, a transaction function is formally denoted as
F:Q√ó√óQ, where ‚ààŒ£. Any terminating C function can
be treated as a transaction function. In order to differentiate
the deÔ¨Ånition of hardware transaction functions from normal
C functions, we use the keyword __atomic to indicate the
type of transaction functions (see Figure 6 for example).C. Relative Atomicity
Concurrent threads usually have different execution pri-
orities. Since higher-priority threads preempt lower-priority
threads, they should be considered atomic to the lower-priority
threads. Relative atomicity captures this semantic feature by
stating that a higher-priority thread is relatively atomic to a
lower-priority thread. In HW/SW interface designs, relative
atomicity captures two ideas: (1) hardware transactions are
atomic from the view point of software; and (2) ISRs for
hardware interrupts are atomic to other lower-priority software
routines [17] (see Figure 10 for example). Any software
concurrency that follows the relative atomicity model can
be represented by a single LPDS. Otherwise, a CLPDS is
necessary. Relative atomicity is a very important semantic
concept to help reduce the complexities in HW/SW interface
speciÔ¨Åcation, co-simulation, and co-veriÔ¨Åcation.
D. Using Non-determinism
We utilize non-determinism mainly in two ways: (1) updat-
ing the state variables, which contributes to the dataÔ¨Çow of the
speciÔ¨Åcation; (2) deciding the conditions of branches or loops,
which contributes to the control-Ô¨Çow of the speciÔ¨Åcation.
For both ways, the use of non-determinism abstracts away
unnecessary details. For example, one important utilization
of non-determinism in our approach is how we model the
hardware concurrency.
Non-deterministic interleaving. Hardware is concurrent in
nature. For example, a network card processes software com-
mand and receives data concurrently. To specify this kind
of hardware concurrency, we design an approach called non-
deterministic interleaving which has three steps: (1) identify
the concurrent modules (e.g., command unit, receive unit, etc.)
of the target hardware device; (2) specify the modules using
separate C functions which we refer to as module functions;
and (3) non-deterministically invoke these module functions in
a hardware transaction function. When the transaction function
is executed multiple times, these module functions are exe-
cuted in a non-deterministic sequence. From the view point of
software, the effect of hardware concurrency is modeled by the
set of hardware states after non-deterministic many executions
of the hardware transaction function. (see Section VI-B for
examples.)
E. The modelC Language
We design a speciÔ¨Åcation language, modelC, to support both
the software speciÔ¨Åcation and the hardware TLM speciÔ¨Åcation.
modelC uses C semantics with two extensions to support non-
determinism and relative atomicity. In modelC, (1) numbers
are treated as bounded integers, so hardware registers can be
properly modeled; (2) unbounded recursion is not allowed; and
(3) dynamic memory allocation is not allowed. It is important
to note that modelC is simply a C language with these exten-
sions and restrictions. Other languages such as SystemC can
also be adapted to support the formal speciÔ¨Åcation following
our approach.
5VI. S PECIFYING HW/SW I NTERFACE PROTOCOLS
We demonstrate how we formally specify the HW/SW
interface protocols through an example, the PIO-24 digital
I/O device/driver interface [19]. One important rule for our
speciÔ¨Åcation is to capture all possible HW/SW behaviors that
are allowed by interface protocols. As illustrated in Figure 5,
our formal speciÔ¨Åcation has: a HW/SW interface, a hardware
model, and a software model.
Software
ModelHardware
ModelHW/SWInterfaceOutput2PortA(...)Software routines:
......Output2PortB(...)
Isr( )HW transaction
function:
atRun_DIO( )
RunIsr()From hardware to software:WRITE_REGISTER_UCHAR(...)From software to hardware
=> atWritePortA(...)
=> atWritePortB(...)......
Œ£={ {wr_a}, {rd_a},  
{wr_b}, {no_evt}, ... }
={ {intr}, {no_intr}, ... } I
Fig. 5. Formal speciÔ¨Åcation framework.
The hardware states are speciÔ¨Åed using global variables; the
software states are speciÔ¨Åed using both the global variables and
stack contents of modelC programs; the hardware behaviors
are speciÔ¨Åed using hardware transaction functions such as
atRun_DIO andatWritePortA ; the software behaviors
are speciÔ¨Åed using C functions such as Output2PortA and
Isr. Conceptually, we can consider a hardware transaction
function as a set of BA transitions labeled by the same input
symbol from Œ£; and an atomic software statement as a set
of LPDS rules labeled by the same input symbol from I. The
input alphabet Œ£of BA Bis the power set of the set of atomic
propositions induced by software interface events and the input
alphabet Iof LPDS Pis the power set of the set of atomic
propositions induced by hardware interface events, where a
hardware (resp. software) interface event is triggered at a
hardware (resp. software) state. The labeling function LB2P
(resp. LP2B) maps hardware (resp. software) states to input
symbols in I(resp. Œ£). For B, there are input symbols such as
{wr_a},{rd_a},{no_evt } ‚ààŒ£, where the propositional
variables wr_a andrd_a represent the software interface
events when software writes/reads the hardware register of
Port A; and the propositional variable no_evt represents that
there is no software interface event. On the other direction, for
P, there are input symbols such as {intr},{no_intr } ‚ààI,
where the propositional variable intr represents the hardware
interface event, i.e., an interrupt; and the propositional variable
no_intr represents that there is no hardware interface event,
i.e., no interrupt.
A. Specifying HW/SW Interface
The HW/SW interface, as the abstraction of the HW/SW
stack layers between the target device and driver (see Fig-
ure 2), propagates hardware (resp. software) interface events to
software (resp. hardware). A hardware interface event happenswhen hardware updates the software interface states, and vice
versa. For example, when a device raises an interrupt, the
HW/SW interface will call the corresponding ISR. On the
other hand, when a driver writes to a hardware interface
register, the HW/SW interface will update the related hard-
ware registers accordingly. In general, the HW/SW interface
describes the synchronous transitions of hardware and software
when an interface event happens.
// hardware transaction function labeled by the input symbol
//fwr_a g 2
__atomic VOID atWritePortA ( UCHAR ucRegData ) f
// If Port A is conÔ¨Ågured as an ‚Äúinput‚Äù port
if ( g DIORegs.CW.CWD4 == 1 ) f
// Write to the output register instead of the port
gDIOState.OutputRegA.ucValue = ucRegData;
gelse f// Otherwise, conÔ¨Ågured as an ‚Äúoutput‚Äù port
// Update both the port and the output register
gDIORegs.A.ucValue = ucRegData;
gDIOState.OutputRegA.ucValue = ucRegData;
g
g
Fig. 6. An implementation of a hardware transaction function responding to
a software interface event.
Figure 6 illustrates an example of a hardware transaction
function in response to a software register write operation.
This transaction function describes a set of hardware state
transitions (i.e., BA transitions) when software writes to
the hardware register of Port A. All these BA transitions
are labeled by the same symbol, {wr_a} ‚àà Œ£. Figure 7
illustrates how function calls to a DDI write-register func-
tion are related to hardware transaction functions such as
atWritePortA . Conceptually, the software interface event
happens, i.e., wr_a is evaluated as true, when entry stack
symbol of atWritePortA is reached.
VOID WRITE REGISTER UCHAR
( PUCHAR pRegister, UCHAR ucRegData ) f
switch ( pRegister ) f
case REG PORTA: atWritePortA(ucRegData); return;
case REG PORTB: atWritePortB(ucRegData); return;
. . .
case REG CONFIG: atWriteConÔ¨Åg(ucRegData); return;
case REG STATUS: atWriteStatus(ucRegData); return;
default: abort ‚ÄúRegister address error.‚Äù; return;
g
g
Fig. 7. Relating register write function calls to hardware transaction
functions.
If hardware raises an interrupt, ISR should be executed
to service this interrupt. The HW/SW interface simulates
this process as illustrated in Figure 8. The global variable
IsrRunning represents software interface states and the
global variable InterruptPending represents hardware
interface states. The function RunIsr has three steps, (1)
check/prepare the precondition before invoking ISR; (2) invoke
6VOID RunIsr () f
atomic f// Make sure only one ISR is invoked
if ((IsrRunning == TRUE) jj(InterruptPending == FALSE))
return;
IsrRunning = TRUE;
g
DioIsr(); // Invoke ISR
atomic fIsrRunning = FALSE; InterruptPending = FALSE; g
g
Fig. 8. Interrupt monitoring function.
ISR; and (3) set both the hardware and software to proper sta-
tus after ISR. The __atomic blocks are used to indicate that
the Ô¨Årst and third steps describe synchronous state transitions
of both hardware and software.
Conceptually, when hardware (formally, BA) raises
an interrupt by setting the interrupt pending status,
InterruptPending , to be true, the propositional variable,
intr , will also become true. As for software, the context-
switch to ISR is modeled as a function call, following the
idea of relative atomicity. The corresponding LPDS rules for
such function calls are labeled by {intr} ‚àà I; therefore,
these LPDS rules are enabled when the interrupt is raised.
B. Specifying Hardware Model
The hardware model describes the desired hardware be-
haviors when hardware works asynchronously with software
to realize system functionalities. For example, when there is
an input to Port A, the hardware model decides whether an
interrupt should be raised based on both the current hardware
state and the input value.
Conceptually, the behavior of the hardware model is rep-
resented as a set of BA transitions labeled by the symbol
{no_evt }, i.e., when there is no software interface event.
Figure 9 illustrates an example of a transaction function,
atRun_DIO , that models the set of BA transitions for the
PIO-24 device when this device executes asynchronously with
the driver. During each execution of the transaction function,
// hardware transaction function labeled by the input symbol
//fno_evt g 2
__atomic VOID atRun DIO () f
switch ( choice() ) f // non-deterministic choices
case 0: RunPorts(); break; // Port I/O Management
case 1: RunInterrupt(); break; // Interrupt Management
. . .
g
g
Fig. 9. The transaction function for the hardware model of PIO-24 digital
I/O card.
one module function is non-deterministically selected; thus
only one module is exercised with its related state variables
updated. The concurrency between the modules is simulated
by the non-deterministic interleaving between the module
functions when the transaction function is executed multiple
times.C. Specifying Software Model
The software model describes desired operation sequences
for software to control hardware. It is straightforward to
specify software behaviors using modelC, because modelC
is designed based on the C semantics. In English docu-
ments, speciÔ¨Åcations about software are usually categorized
by functionalities. For every functionality, a piece of English-
based pseudo-code is provided to describe the desired software
operations. We use a C function to replace each of the pseudo-
code pieces. The left side of Figure 10 illustrates an example of
VOID Output2PortA ( UCHAR ucRegData ) {
‚áê=
// Write to Port A
WRITE REGISTER UCHAR(REG PORTA,
ucRegData);
‚áê=
// If Port A is conÔ¨Ågured as ‚Äúinput‚Äù, set it as ‚Äúoutput‚Äù
if ( g SWState.CW.CWD4 == 1) {
‚áê=
// Software must maintain the I/O status of all ports
gSWState.CW.CWD4 == 0;
‚áê=
WRITE REGISTER UCHAR(REG CONFIG,
gSWState.CW.WholeByte);
‚áê=
}
}8
>>>>>>>>>>>>>>>>>><
>>>>>>>>>>>>>>>>>>:while( choice() )
{
atRun DIO();
RunIsr();
}
Fig. 10. Left side: a C function about how to output to Port A; right
side: execution of the hardware transaction function and ISR interleaved with
software statements, following the idea of relative atomicity.
such a C function for the PIO-24 driver model. This function
describes the desired software operations for outputting a byte
to Port A, where each atomic software statement1is considered
as a set of LPDS rules labeled by {no_intr } ‚àà I. The
right side of Figure 10 demonstrates interleaved executions of
device with respect to driver, following the idea of relative
atomicity. The hardware transaction function atRun_DIO
(see Figure 9) describes BA transitions labeled by {no_evt }
‚ààŒ£, and the function RunIsr (see Figure 8) invokes an ISR
according to the interrupt pending status.
In implementation, all the C functions of a software model
can be realized in several concurrent driver threads (the
number of threads and how the functions should be combined
into the threads highly depend on implementation details).
When the executions of concurrent driver threads cannot be
captured by relative atomicity, we need to utilize CLPDS, the
product of LPDS, as the formal representation of the driver.
D. Summary
Generalization. We have demonstrated how we specify
HW/SW interface protocols via an example. Our approach is
also applicable to other HW/SW interfaces in devices/drivers
and microcode/Ô¨Årmware, because (1) TLM is already widely
used in hardware development; (2) In HW/SW interface de-
signs, it is de facto to have different execution priorities for
1For readability, we assume that such statements are atomic from the view
point of hardware.
7concurrent components such as software threads and hardware
transactions; (3) BA and LPDS (resp. CLPDS) are suitable
formal representations for hardware and software respectively,
because they closely resemble the hardware and software
semantics.
Liveness constraints. We abstract away some implementation
details using non-determinism, which may cause speciÔ¨Åcation
imprecisions, e.g., introducing loops that are not in the original
design. These loops can be excluded by liveness constraints.
One way to introduce liveness constraints is via Linear Tem-
poral Logic (LTL) assertions. In automata-theoretic approach,
such LTL assertions can be represented as a B ¬®uchi automaton
and then used to constrain the behavior of the target model
during veriÔ¨Åcation [20].
VII. A PPLICATIONS AND EVALUATION CRITERIA
A. Applications
We employ formal models to describe the HW/SW inter-
face protocols in the device/driver development process. our
approach improves the development process in the following
four aspects (refer to Figure 3):
‚Ä¢In the design stage, automatic veriÔ¨Åcation tools are ap-
plied to check the correctness of formal models that
describe the HW/SW interface protocols.
‚Ä¢During the development stage, formal models are referred
to alongside the English speciÔ¨Åcations; therefore, it is
easier for both development engineers and test engineers
to have precise understanding about how hardware and
software should interact following the HW/SW interface
protocols.
‚Ä¢During in-house testing, formal models can be utilized
by validation techniques such as co-veriÔ¨Åcation [6], [20]
and co-simulation [1], [21]. There are three beneÔ¨Åts:
reduce the duplicate efforts in developing test harnesses;
provides a uniform and systematic platform for valida-
tion; and improve the test coverage, since it is hard to
manipulate real hardware devices to exhibit all possible
interface behaviors (e.g., failures) in testing.
‚Ä¢In conformance testing, formal models can serve as the
golden models. First, equivalence checking/testing [22],
[23] can be used to check if a hardware (resp. software)
product complies with the hardware (resp. software)
formal model. Second, a hardware (resp. software) formal
model can be used as the test harness of the software
(resp. hardware) products.
Among these advantages, the ability to provide a uniform
and systematic platform for validation is very important. In
traditional testing, because devices and drivers are manufac-
tured separately, some failures due to interface incompatibility
only occur when a speciÔ¨Åc version of device is combined
with a speciÔ¨Åc version of driver. It is hard to pinpoint the
responsibility for such failures, because both the device and
the driver are black boxes (or at least one of them is). Using
formal speciÔ¨Åcations as the uniform validation platform will
greatly relieve this problem.B. Evaluation Criteria
We discuss four criteria to help evaluate our approach:
Correctness assurance. Since formal models have accurate
semantics, automatic tools can be applied to validate their
correctness. For example, the C compiler alone can detect a
large amount of speciÔ¨Åcation inconsistencies; we have also
used CoVer to verify the correctness of formal models (see
Section VIII).
Manual effort. The manual effort required in the speciÔ¨Åcation
of a formal model mainly depends on the complexity of
the HW/SW interface protocol and the experience of the
speciÔ¨Åcation engineer. In general, the complexity of a HW/SW
interface protocol can be approximately quantiÔ¨Åed by the size
of its English document; and the experience of speciÔ¨Åcation
engineers can be quantiÔ¨Åed by their experience in hardware
and software development. More quantiÔ¨Åcation is discussed in
Section VIII.
False positives. Formal models are speciÔ¨Åed using techniques
such as non-determinism that may lead to over abstraction.
This is one root cause of false positives in co-simulation and
co-veriÔ¨Åcation. We implement our formal models based on
HW/SW interface protocols; therefore, any over abstraction
with respect to the protocols should be considered as an error
to be reÔ¨Åned.
Comparison with the English speciÔ¨Åcation. It is important
to compare formal models with their English speciÔ¨Åcations.
Different English speciÔ¨Åcations may describe HW/SW inter-
face protocols in different levels of details. However enough
details must be included when specifying a formal model in
our approach. For example, an English speciÔ¨Åcation may omit
the input restrictions on a device‚Äôs I/O port; however this detail
must be speciÔ¨Åed explicitly in the formal model, i.e., if the
device‚Äôs input is not speciÔ¨Åed in the English speciÔ¨Åcation, non-
deterministic values should be given as the input in the formal
model.
We deÔ¨Åne a concept, model-document ratio, to help analyze
the relation between a formal model and its English speciÔ¨Åca-
tion2. Given that the formal model has LFMlines of modelC
code and the English document has Pdocpages of speciÔ¨Åcation
about the HW/SW interface protocol, we deÔ¨Åne the model-
document ratio as:
DeÔ¨Ånition 1: MODEL-DOC =LFM
Pdoc
When the MODEL-DOC ratio is high, we know that the
HW/SW interface protocol is loosely described by the English
speciÔ¨Åcation, so the deviations of HW/SW interface behaviors
in various products are usually very high. When the MODEL-
DOC ratio is low, we know that the English speciÔ¨Åcation is
elaborate.
VIII. E VALUATION
As discussed in Section IV, development processes of
device/driver frameworks have three stages: design, develop-
2We target standard speciÔ¨Åcations which commonly use structured English.
8ment, and certiÔ¨Åcation. We have applied our approach to the
Ô¨Årst two stages.
First, for the design stage, we have applied our approach to
the next generation of a pervasively used industrial standard.
Our approach has led to the detection of Ô¨Åve issues in the draft
English HW/SW interface document. One of the issues is a
spec-inconsistency in an algorithm pseudo-code that describes
the hardware-side interface protocol. This Ô¨Ånding has triggered
a discussion between two companies who participated in the
design of this HW/SW interface protocol. Our formal model
has 4781 lines of modelC code that covers about 277 pages
of the English document. Therefore, the MODEL-DOC ratio
is 17.26, which indicates that the draft English document is
considerably elaborate compared with the other case studies
(see below). Using the formal model as the test harness, our
co-veriÔ¨Åcation tool, CoVer, has discovered two real bugs in a
prototype Windows driver for this device/driver framework.
Second, for the development stage, we have applied our ap-
proach to three long-existing device/driver frameworks: (1) the
Sealevel PIO-24 digital I/O device/driver framework (a.k.a.,
PIO-24) [19], (2) the Intel 8255x 10/100Mbps Ethernet con-
troller device/driver framework (a.k.a., Ethernet controller) [3],
and (3) the USB 2.0 device/driver framework [24]. Our for-
malization process has led to the detection of ten issues in
the English documents. Furthermore, CoVer has been applied
to co-verify four fully functional Windows device drivers
developed for the device/driver frameworks: one PIO-24 driver
from Open Systems Resources (OSR); one Ethernet card driver
and two USB device drivers, all from Microsoft. CoVer has
discovered ten real bugs. All of these bugs, which could
cause serious system failures including data loss, interrupt
storm, device hang, etc., are previously unknown to the driver
developers.
We use two sets of tables to present the evaluation of our
formalization process. Table I illustrates the overall statistics
about the formalization for the PIO-24 device/driver frame-
work. The statistics are gathered before and after the for-
TABLE I
FORMALIZATION OF THE PIO-24 DEVICE /DRIVER FRAMEWORK .
Gathered before the formalization process
HW/SW interface doc. (document) size 20 pages
The portion of the doc. for the HW/SW interface protocol 10 pages
The portion of the doc. that cannot be modeled 10 pages
SpeciÔ¨Åcation engineer‚Äôs experience in driver development 2 years
SpeciÔ¨Åcation engineer‚Äôs experience in hardware design 1 years
SpeciÔ¨Åcation engineer‚Äôs experience in formal veriÔ¨Åcation 3 years
SpeciÔ¨Åcation engineer estimated manual effort 7 person-day
Gathered after the formalization process
The actual manual effort 3 person-day
SpeciÔ¨Åcation issues found in the English document 2 issues
Size of modelC code in formal model 695 lines
Size of comments in formal model 537 lines
MODEL-DOC ratio as 695/10
(lines of modelC code)/(pages of the modeled doc.) = 69.5
malization respectively. We require the speciÔ¨Åcation engineer
to give an estimation of the manual effort necessary for
formalization, so we can compare how well English documents
with different complexities can be handled by an engineer.We also present the speciÔ¨Åcation engineer‚Äôs experiences in
three areas that may affect the result of the formalization.
We have discovered two speciÔ¨Åcation issues in the English
document for PIO-24: one spec-inconsistency and one spec-
incompleteness3. Take the spec-incompleteness issue as an
example, the document does not mention the default value
of the interrupt pending register (which is usually disabled
by default in many English documents for HW/SW interface
speciÔ¨Åcations); therefore, we assign non-deterministic initial-
ization values to this register in our formal speciÔ¨Åcation. Co-
incidentally, the Windows driver of this device does not clear
the interrupt pending register during the driver initialization.
This uninitialized register affects the driver‚Äôs interrupt handling
process, which can lead to data loss.
Table II illustrates the detailed statistics about the formal
model for the PIO-24 HW/SW interface protocol. The formal
model, as implemented in 5 Ô¨Åles, has 537 lines of comments
and 695 lines of modelC code. This corresponds to 10 pages
of the English document. In the form of comments, we have
added references that point to the corresponding document
positions; therefore the formal model can be related back to the
original document. The Ô¨Åle ‚ÄúGlobal ‚àº.c‚Äù deÔ¨Ånes all the global
variables that represent hardware and software states; thus we
are not able to determine the exact number of corresponding
pages in the document.
TABLE II
FORMAL MODEL OF THE PIO-24 DEVICE /DRIVER FRAMEWORK . (C OM.:
COMMENTS , DOC.:DOCUMENT )
# of lines Doc.
File name Com. Code pages Description
DIODefs.h 63 151 2 Data structures
DIO.c 210 192 2 Hardware transaction function,
software-side protocol
Global ‚àº.c 18 13 N/A Global variables for both
hardware and software models
DIORegs.c 146 270 3 Registers, HW/SW interface events
Environ ‚àº.c 100 69 3 Simulate inputs to Port A, B, and C
The statistics of formalizing the Ethernet controller de-
vice/driver framework are presented in Table III and Table IV
respectively. Compared to the English document of the PIO-
24 device/driver framework, the English document of Ethernet
controller is more elaborate. This can be inferred from the
major difference between their MODEL-DOC ratios, where
theMODEL-DOC ratio of PIO-24 is much higher. During
our formalization process, we have discovered six issues in
the Ethernet controller English document. One example of
these issues is already illustrated in Figure 1. Consider this
document has been published for seven years and revised three
times, we were surprised.
We do not present the statistics tables for USB 2.0 de-
vice/driver framework due to the page limitation. The formal
model has 2164 lines of modelC code, which corresponds to
60 pages of the USB 2.0 document [24] and 70 pages (by
3Spec-inconsistency: multiple places of an English document are partially
contradictory to each other; Spec-incompleteness: the information provided
by an English document is not enough to guide the implementation.
9TABLE III
FORMALIZATION OF THE ETHERNET CONTROLLER DEVICE /DRIVER
FRAMEWORK .
Gathered before the formalization process
HW/SW interface doc. (document) size 175 pages
The portion of the doc. for the HW/SW interface protocol 136 pages
The portion of the doc. that cannot be modeled 39 pages
SpeciÔ¨Åcation engineer‚Äôs experience in driver development 2 years
SpeciÔ¨Åcation engineer‚Äôs experience in hardware design 1 years
SpeciÔ¨Åcation engineer‚Äôs experience in formal veriÔ¨Åcation 3 years
SpeciÔ¨Åcation engineer estimated manual effort 14 person-day
Gathered after the formalization process
The actual manual effort 21 person-day
SpeciÔ¨Åcation issues found in the English document 6 issues
Size of modelC code in formal model 2166 lines
Size of comments in formal model 1395 lines
MODEL-DOC ratio as 2166/136
(lines of modelC code)/(pages of the modeled doc.) = 15.92
TABLE IV
FORMAL MODEL OF THE ETHERNET CONTROLLER DEVICE /DRIVER
FRAMEWORK . (C OM.:COMMENTS , DOC.:DOCUMENT )
# of lines Doc.
File name Com. Code pages Description
E100Defs.h 200 748 14 Data structures
E100.c 182 197 24 Hardware transaction function,
software-side protocol
Global ‚àº.c 20 13 N/A Global variables for both
hardware and software models
E100Regs.c 173 492 35 Registers, HW/SW interface events
Port.c 170 151 5 Handle software commands to
PORT interface registers
CmdUnit.c 410 329 26 Process the Command Unit (CU)
RcvUnit.c 133 134 25 Process the Receive Unit (RU)
Environ ‚àº.c 107 102 7 Simulate the inputs to the device
estimation) of the Microsoft online document [25]. Therefore,
theMODEL-DOC ratio is 16.6. We have discovered two spec-
incompleteness problems in the Microsoft online document.
Windows provides a set of program interfaces for operating
USB devices. However, some programming rules are not spec-
iÔ¨Åed, which has confused driver developers. CoVer discovered
such programming problems in the driver code, e.g., redundant
function calls to stop a USB device. In total, there are three
bugs discovered by CoVer in two USB device drivers.
In conclusion, we discovered Ô¨Åfteen speciÔ¨Åcation issues
and twelve real driver bugs4in our evaluation. All these
speciÔ¨Åcation issues and driver bugs are conÔ¨Årmed serious
by Windows architects. It is important to note that these
issues/bugs have survived from rigorous industrial testing and
code review by thousands of driver developers5. Therefore,
our approach is effective to further improve the qualities of
devices/drivers.
IX. C ONCLUSION AND FUTURE WORK
We have presented an approach to formalizing HW/SW
interface speciÔ¨Åcations, where we proposed a semantic model,
4All the bugs involve interactions between drivers and devices, e.g., when a
driver does not initialize its device correctly, when a driver causes an out-of-
synchronization with its device, or when a driver improperly handles interrupts
so that device data gets corrupted. More details about CoVer and the driver
bugs are discussed in [5].
5There are four open source drivers from OSR and Microsoft Windows
Driver Kit.relative atomicity, to capture the concurrency model in
HW/SW interface speciÔ¨Åcations; demonstrated our formal
speciÔ¨Åcation approach through realistic device/driver exam-
ples; elaborated on how we have utilized this approach
in device/driver development process; and discussed criteria
for evaluating our formal speciÔ¨Åcations. The evaluation has
demonstrated the effectiveness of our approach. Since the
HW/SW interface protocols are described in formal semantics,
we are able to discover speciÔ¨Åcation issues early in the
system design stage, and furthermore apply automatic tools to
analyze the interface designs and implementations throughout
the whole product development cycle. For the next step, we
will present our experience on co-simulation and conformance
testing in our speciÔ¨Åcation framework.
Acknowledgement. This research received Ô¨Ånancial support
from National Science Foundation of the United States (Grant
#: 0916968).
REFERENCES
[1]V. Kuznetsov, V. Chipounov, and G. Candea, ‚ÄúTesting closed-source
binary device drivers with DDT,‚Äù in USENIX Annual Technical Confer-
ence, 2010.
[2]D. Monniaux, ‚ÄúVeriÔ¨Åcation of device drivers and intelligent controllers:
a case study,‚Äù in Proc. of EMSOFT , 2007.
[3]Intel, Intel 8255x 10/100 Mbps Ethernet Controller Family ‚Äì Open
Source Software Developer Manual, version 1.3 , 2006.
[4]R. P. Kurshan, Computer-Aided VeriÔ¨Åcation of Coordinating Processes:
The Automata-Theoretic Approach . Princeton University Press, 1994.
[5]J. Li, ‚ÄúAn Automata-Theoretic Approach to Hardware/Software Co-
veriÔ¨Åcation,‚Äù Ph.D. dissertation, Portland State University, 2010.
[6]J. Li, F. Xie, T. Ball, and V. Levin, ‚ÄúEfÔ¨Åcient Reachability Analysis
of B¬®uchi Pushdown Systems for Hardware/Software Co-veriÔ¨Åcation,‚Äù in
Proc. of CAV , 2010.
[7]N. A. Lynch and M. R. Tuttle, ‚ÄúHierarchical correctness proofs for
distributed algorithms,‚Äù in Proc. of PODC , 1987.
[8]L. de Alfaro and T. A. Henzinger, ‚ÄúInterface automata,‚Äù in Proc. of
ESEC/FSE , 2001.
[9]J. Li, N. T. Pilkington, F. Xie, and Q. Liu, ‚ÄúEmbedded architecture
description language,‚Äù JSS, vol. 83, no. 2, 2010.
[10] D. Kroening and N. Sharygina, ‚ÄúFormal veriÔ¨Åcation of systemc by
automatic hardware/software partitioning,‚Äù in Proc. of MEMOCODE ,
2005.
[11] OSCI, ‚ÄúSystemC,‚Äù in www.systemc.org , 2010.
[12] S. Schwoon, ‚ÄúModel-checking pushdown systems,‚Äù Ph.D. dissertation,
2002.
[13] G. Ramalingam, ‚ÄúContext-sensitive synchronization-sensitive analysis is
undecidable,‚Äù ACM TOPLAS , 2000.
[14] R. Hardin, Z. HarEl, and R. Kurshan, ‚ÄúCOSPAN,‚Äù in Proc. of CAV ,
1996.
[15] T. Ball, E. Bounimova, B. Cook, V. Levin, J. Lichtenberg, C. McGarvey,
B. Ondrusek, S. K. Rajamani, and A. Ustuner, ‚ÄúThorough static analysis
of device drivers,‚Äù in Proc. of EuroSys , 2006.
[16] S. Qadeer and J. Rehof, ‚ÄúContext-bounded model checking of concurrent
software,‚Äù in Proc. of TACAS , 2005.
[17] D. A. Solomon, Inside Windows NT , 2nd ed. Microsoft Press, 1998.
[18] IEEE, IEEE Standard for Verilog (IEEE Std 1364-2005) . IEEE, 2005.
[19] Sealevel, PIO-24.LPCI User Manual , 2006.
[20] J. Li, F. Xie, T. Ball, and V. Levin, ‚ÄúModel checking b ¬®uchi pushdown
systems,‚Äù in Proc. of FASE , 2011.
[21] Microsoft, ‚ÄúDevice simulation framework,‚Äù in MSDN , 2010.
[22] C. Pixley, ‚ÄúIntroduction to a computational theory and implementation
of sequential hardware equivalence,‚Äù in Proc. of CAV , 1990.
[23] S. Verdoolaege, G. Janssens, and M. Bruynooghe, ‚ÄúEquivalence check-
ing of static afÔ¨Åne programs using widening to handle recurrences,‚Äù in
Proc. of CAV , 2009.
[24] Intel, Universal Serial Bus SpeciÔ¨Åcation, Revision 2.0 , 2000.
[25] Microsoft, ‚ÄúFramework usb reference,‚Äù in MSDN , 2010.
10