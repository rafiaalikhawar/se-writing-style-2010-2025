Axis: Automatically Fixing Atomicity Violations through Solving Control
Constraints
Peng Liu Charles Zhang
Department of Computer Science and Engineering
The Hong Kong University of Science and Technology
{lpxz, charlesz }@cse.ust.hk
Abstract —Atomicity, a general correctness criterion in con-
currency programs, is often violated in real-world applications.The violations are difﬁcult for developers to ﬁx, making
automatic bug ﬁxing techniques attractive. The state of the art
approach aims at automating the manual ﬁxing process butcannot provide any theoretical reasoning and guarantees. We
provide an automatic approach that applies well-studied dis-
crete control theory to guarantee deadlocks are not introduced
and maximal preservation of the concurrency of the original
code. Under the hood, we reduce the problem of violation ﬁxingto a constraint solving problem using the Petri net model. Our
evaluation on 13 subjects shows that the slowdown incurred
by our patches is only 40% of that of the state of the art.With the deadlock-free guarantee, our patches incur moderate
overhead (around 10%), which is a worthwhile cost for safety.
I. I NTRODUCTION
For concurrent programs using shared memory, atomicity
is a widely used correctness criterion. It requires an exe-cution of one thread, which involves one or more sharedmemory locations, not be interrupted by other threads. Inthe mainstream programming practice, atomicity is enforced
by locks, which is notoriously difﬁcult to be programmed
correctly. Although the violations of atomicity can be de-tected effectively ( [6], [12], [13], [25], [28], [32]), tremen-dous difﬁculties still exist in ﬁxing them properly by theprogrammers, who can easily introduce new bugs such as
deadlocks or unintentional performance penalties. Studies ([1], [10], [27]) show that it often takes more than one month
to ﬁx a concurrency bug and nearly 70% of the patches arestill buggy in their ﬁrst release.
One of the primary reasons for this difﬁculty, as observed
by many researchers ( [18], [30], [36]), is that writing syn-
chronization code that is both safe and performant requires
the intricate non-modular reasoning about the semantics ofthe program. The desired rigorous inter-procedural reasoningof these types of global properties is usually the strength
of the compiler-based techniques. Therefore, the research
of lock allocation ( [11], [15], [21]) aims at replacing themanual reasoning by automatically assigning the locking op-erations based on atomicity speciﬁcations. These approachescan in general guarantee the freedom of deadlocks but oftenresult in the unsatisfactory performance ( [11], [15]), due to
the general conservativeness of static analysis techniques,such as the thread-escape analysis [8], the array indexanalysis [29], the shape analysis [14], and many others.
We believe that, for a carefully engineered concurrent sys-
tem, the programmer, who really understands its semantics,
is more likely to produce the high quality synchronization
code that has good performance as a result of the highdegree of concurrency. This is simply because performancecan be easily measured in concrete test runs, whereas safetyis difﬁcult to verify due to the scheduling non-determinism.An effective way of curing atomicity violations is to max-
imally respect the programmers’ designs of lock placementand assist them in avoiding hazardous situations such as
inconsistent operations and deadlocks.
One recent work, AFix [18], is the state of the art research
in this direction. The primary goal of AFix is to automate the
manual bug ﬁxing process for programmers and strengthen
it with the static analysis techniques such as the path
analysis, the reduction of subsumed bugs, and the merging ofoverlapping bugs. However, limited by the inherent nature ofmanual reasoning, approaches such as AFix essentially lack
a uniﬁed theoretical foundation to globally reason about bug
ﬁxes together with the existing lock design. Consequently,no guarantees are provided with respect to either the safety
or the performance of the patched program. Our evaluationofAFix on large real systems also shows that the AFix
sometimes incurs the degraded performance and, worse,frequent deadlocks.
Different from AFix , we propose a fully automatic bug
ﬁxing technique that is systematic, rigorous, and providingboth safety and performance guarantees. For the end user,our technique exhibits two distinctive and highly usefulproperties. First, our technique can simultaneously reasonand ﬁx any number of correlated atomicity violations involv-
ing an arbitrary number of variables. Second, we guaranteethat the ﬁx not only is deadlock-free but also incurs the
minimal interference to the degree of concurrency of the
original code.
Our technique achieves these properties by modeling the
concurrent properties of a program as Petri nets [22] and978-1-4673-1067-3/12/$31.00 c2012 IEEE ICSE 2012, Zurich, Switzerland 299using a branch of control theory called the Supervision
Based on Place Invariants ( SBPI ) [17] as our theoretical
foundation. We use novel methods to reduce the problem ofﬁxing atomic violations to solving a set of control constraints
on Petri nets. By solving the constraints with an SBPI
constraint solver, we compute the locking additives to theoriginal program, which prohibit the illegal interleavingsof threads. The SBPI theory guarantees that the solution
satisﬁes the constraints, i.e., preventing the violations from
happening. It also guarantees that the solution incurs theminimal interference
1to the degree of concurrency of the
program, hence, maximally respects the programmer’s orig-inal design. We extend the earlier application ( [33], [34])ofSBPI on the deadlock avoidance and guarantee that, if
the original program is deadlock-free, our solution does notcause the patched program to deadlock.
We implemented our approach as a tool, Axis , and evalu-
ated it against AFix , the state of the art automatic approach
for ﬁxing atomicity violations, using 13 subjects includingthree large scale real world programs. Our evaluation showsthat, for these large scale subjects, our patched version
outperforms the AFix solution by 6% to 9%; the overhead
of our patched version is much smaller than (only 40%of) the overhead of the AFix solution. Considering the
subjects are well engineered and AFix is efﬁcient, such
improvement is signiﬁcant. Equally important, our patchedprogram scales well when the thread number increases. Be-sides, our patched version with the deadlock-free guaranteenever incurs deadlocks in our experiments while incurring amoderate (average 10%) overhead.
We make a signiﬁcant contribution to the automatic ﬁxing
of atomicity violations, which includes the following:
1) We propose an automatic approach to ﬁx the atomicity
violations, which guarantees the minimal interferenceto the concurrency degree of the program, and no
introduction of deadlocks.
2) We reduce the ﬁxing of atomicity violations to solving
the control constraints, which brings multiple compu-tational advantages.
3) We propose a new Petri net modeling which combines
the dynamic calling context information and the staticprogram code. The modeling is scalable, complete, andprecise for the violation ﬁxing.
The rest of the paper is organized as follows. We ﬁrst
brieﬂy describe the overview of our approach in Section II.Then, we present our approach in Section III. Section IVand Section V state the implementation and evaluation,respectively.
1The guarantee is referred to as the maximal permissiveness of concur-
rency degree in the control theory, we may use the two terms interchange-ably.(a) (b) (c) (d)
Figure 1: Basic Petri subnets. (a) Branch. (b) Loop. (c) Start and Join.
(d) Lock.
II. O VERVIEW
We present our technique in a nutshell by giving a primer
on the Petri net modeling of program control ﬂows ﬁrst,followed by high level steps of our technique.
Petri Net Primer. Petri net [22] is a compact repre-
sentation of state machines that avoids the state explosionproblem. A comprehensive overview of Petri net models
and their applications is given by Murata [22] and we
brieﬂy outline the Petri net models of the basic controlﬂow constructs including branch, loop, fork, join , and lock ,
as illustrated in Figure 1. Petri net is a bipartite directedgraph, which contains two types of nodes, places (circles)and transitions (horizontal bars), connected by the arcs.Each place may contain tokens (black dots), each of whichmarks the current position of the execution ﬂow of a thread.Each transition can be triggered independently of each other.When being triggered, the transition removes the tokensfrom each of its input places and replenishes tokens to eachof its output places. Each arc is associated with a weight, i.e.,a number that determines the number of tokens to removeor to replenish. If any input place does not contain sufﬁcienttokens, the transition is not triggered.
Petri net models program statements (or basic blocks) as
places and the control ﬂow as the transitions . For instance,
in Figure 1(a), the branch is modeled using a single tokenin place p
1that ﬂows to either p2orp3through a simple
transition (one source and one target), t1ort2.A si n
Figure 1(c), the start operation is represented by the split
transition (one source and two targets), t1, removing the
token in p1and simultaneously replenishing tokens to p2and
p3. Locks are modeled using two tokens, one representing
the program ﬂow and the other the availability of the lock,as illustrated in Figure 1(d). The merging transition (twosources and one target), t
1, says both tokens need to be
available to enable the triggering of the transition, and thetriggering of t
1removes the tokens, simulating the lock
operation. The splitting transition t2returns the token back
toL, simulating the unlock operation.
Our Technique. We use a slightly simpliﬁed ver-
sion of the well-know atomicity violation from theStringBuffer class in JDK 1.4 to highlight the essential
steps of our technique. The interleaving sequence and the3001public class StringBufferTest {
2 public static StringBuffer s1,s2=null;
3 static Thread th1=new Thread(){
4 public void run(){ // inlined s1.append(s2):
5 synchronized (s1){
6 intlen = s2.length();
7     // s2 is cleared by the thread t28 s2.getChars(0, len, s1.value, s1.count);
9                     }
10 }11     };12 static Thread th2=new Thread(){
13 public void run(){
14 s2.delete(0, s2.length());
15             }
16 };17 …18 th1 .start(); th2.start();
19 th1.join(); th2.join();
(a) (b) (c)1public class StringBufferTest {
2 public static StringBuffer s1,s2=null;
3 static Thread th1=new Thread(){
4 public void run(){ // inlined s1.append(s2):
5 synchronized (s1){
6 lockM.lock();
7 intlen = s2.length();
8 s2.getChars(0, len, s1.value, s1.count);
9 lockM.unlock();
10                  }
11 }
12    };
13 static Thread th2=new Thread(){
14 public void run(){
15 lockM.lock();
16 s2.delete(0, s2.length());
17 lockM.unlock();
18             }
19      };
20 }
(d)
Figure 2: (a) The original code. (b) The Petri net model with offending places shaded. (c) The augmented Petri net. (d) The patched code.
offending statements are indicated by the arrows in Figure 2.
Given a violation report containing the offending programstatements, such as line 6, 8, and 14 in our example, we ﬁrstconstruct a Petri net model for this program, illustrated inFigure 2(b). We next encode this Petri net and the offendingplaces (statements) as a set of control constraints , which can
be mathematically solved to yield an augmented Petri net asshown in Figure 2(c). Our technique guarantees that, if thenew lock Mand the arcs (dashed lines) are added, the new
program has the following properties: 1. the violation will nolonger happen ( correctness ); 2. there is no deadlock between
the new lock Mand the existing lock L(deadlock-freeness );
3. the new lock is used only when the interleavings of thethreads trigger the speciﬁc bug ( maximal permissiveness ).
The augmented Petri net in Figure 2(c) corresponds to thepatched code in Figure 2(d).
The key to achieve these salient properties is to model the
absence condition of each atomicity violation as a controlconstraint and to satisfy the constraint by augmenting thePetri net with new lock places and new arcs. For instance,the absence condition of the exemplary violation is, line 14
cannot interleave between line 6 and line 8, which is equiv-
alent to two control constraints : 1. places p
7andp3cannot
simultaneously contain tokens; 2. places p7andp4cannot
simultaneously contain tokens. Then, we express these con-straints in succinct linear inequalities (Section III-B), and usethe SBPI constraint solver to compute an augmentation to
the Petri net, to guarantee that all constraints are satisﬁed. Inaddition, we extend the siphon analysis of Wang et al. [34]to eliminate any possible deadlocks introduced by the aug-mentation. Treating atomicity violations with a constraintsolving system has many computational advantages over
existing approaches. The solver considers all correlated bugs
and produces the optimum ( maximal permissive ) solutions,
rather than simply relying on merging heuristics. The solvercomputes automatically, without any ad hoc treatments forloops or branches, the lock placement that guarantees tobe free of bad lock practices. In addition, the mathematic
form of the constraints allows further algebraic optimizationssuch as the rank reduction. We now describe our constraintsolving approach in detail.
III. F
IXING ATOMICITY VIOLA TIONS WITH CONTROL
CONSTRAINTS
In this section, we ﬁrst explain how the Petri net models
and control constraints are constructed. We then explain howthey are solved by the SBPI constraint solver to generate
patches for ﬁxing the violations. At last, we show the generalapplicability of our approach, the deadlock-free guarantee,and the guarantee of lock placement.
A. On-Demand Petri Net Construction
Our technique takes as input the reports of violations,
including both single-variable and multi-variable violations.
For the ease of technical discussion, we primarily discussthe single-variable violations and brieﬂy outline later in thepaper how multi-variables are treated.
The quality of the bug reports greatly affects the quality
of bug ﬁxes in general. Although our technique can be
applied to statically detected violations, our current focusis to deal with dynamically discovered bugs with both theoffending statements and their calling contexts available.Most dynamic bug detection tools ( [16], [26]) can pro-
vide this information easily. Each single variable atomicity
violation can be characterized by three statements, s
α,sβ
andsγ, where sαandsβare executed by the same thread
andsγis a remote statement. Given the calling contexts of
these statements, the context-sensitive Petri net can easily beconstructed starting from the entry point of the thread, byconstructing the subnets intra-procedurally and by linkingthe subnets at the call sites inter-procedurally. If the threadis created in a loop or by a recursive call, we clone the Petrinet starting from the thread entry point to represent twothreads. Note two threads are sufﬁcient to express atomicityviolations [19].301B. Control Constraints
Constructing the control constraints on the Petri net is a
key step in ﬁxing the violations bugs. However, the con-struction is not straightforward because atomicity bugs arecharacterized by their dynamic behaviors, whereas control
constraints express the structural information of Petri nets,
which is static by nature. Our transformation method isbased on the following observation. For a violation, ( s
α,
sβ,sγ), to occur at runtime, there must exist a statement
inclusively between sαandsβthat is executed concurrently
with sγ. This is an equivalent condition of the atomicity vio-
lation [28]. We deﬁne this observation formally as Lemma 1.
Lemma 1: Three statements, sα,sβand sγ, form an
atomicity violation ( sα,sβ,sγ) at runtime ⇔∃ statement
sθ∈between (sα,sβ),sθis executed at the same time as
sγ.
Here, between (sα,sβ)returns a set, denoted as the bset
(short for between set), of statements that may be executedbetween s
αandsβlocally by the same thread. One way to
compute it is to collect the statements on every path froms
αtosβ, which can be implemented efﬁciently using the
standard forward data-ﬂow analysis2.
Mapping to the Petri net, Lemma 1 is reiterated as
Lemma 2.
Lemma 2: Three statements, sα,sβand sγ, form an
atomicity violation ( sα,sβ,sγ) at runtime. ⇔in the Petri
net, where pα,pβandpγmodel the statements sα,sβ, and
sγ, respectively, ∃place p∈between (pα,pβ),pis reached
at the same time as pγby the execution ﬂow of two threads,
or in the Petri net langu age, two tokens are simultaneously
inpandpγ.
To succinctly describe the tokens in the places, we in-
troduce the marking vector u, where each entry, u(p),
represents the number of tokens of a place, p.
The bset of two places can be computed similar to the
bset of two statements. It does not include the transitions
or the lock places which do not model “statements”. InFigure 2, the bset of places p
3andp4is{p3,p4}. Us-
ing the bset , the runtime occurrence of the violation is
equivalently described on the Petri net as: ∃p∈{p3,p4},
u(p)+u(p7)=2 . The sum never exceeds 2 because each
place contains at most one token representing the executionﬂow of its own thread. Remember that we make clones forthe same statements under different thread contexts
The counterposition of Lemma 2 also holds, as shown in
Lemma 3.
Lemma 3: ∀place p∈between( p
α,pβ),u(p)+u(pγ)≤
1⇔the atomicity violation does not occur at runtime.
2Interested readers may refer to our technique report for the implemen-
tation details. http://www.cse.ust.hk/prism/axis/TR.pdfLemma 3 naturally provides the solution for constructing
the control constraints. For our running example in Figure 2,the control constraints are shown in Equation 1.
/braceleftbigg
u(p
3)+u(p7)≤1
u(p4)+u(p7)≤1(1)
Asp3andp4are places of the same thread, at any time,
the token representing the execution ﬂow of the thread can atmost stay in one of them. Therefore, we have an intra-threadconstraint: u(p
3)+u(p4)≤1. Combining the constraints in
Equation 1 and the intra-thread constraint, it is not hard to
obtain an equivalent but more succinct constraint, u(p7)+
u(p3)+u(p4)≤1.
We formally generalize the succinct representation of the
constraint in Lemma 4.
Lemma 4: Suppose between (pα,pβ) consists of places
pα,pθ, ..., pβ. They form an implicit intra-thread constraint
(Equation 2a) as well as the control constraints with aremote place p
γ(Equation 2b to Equation 2e).
u(pα)+u(pθ)+···+u(pβ)≤1 (2a)
u(pγ)+u(pα)≤1 (2b)
u(pγ)+u(pθ)≤1 (2c)
... (2d)
u(pγ)+u(pβ)≤1 (2e)
then, we have an equivalent but more succinct constraint,
i.e., control constraint:
u(pγ)+u(pα)+u(pθ)+···+u(pβ)≤1. (3)
Proof 1: The proposition Equation 3 →Equation 2 holds
as each place contains non-negative number of tokens.The proposition Equation 2 →Equation 3 also holds. Sup-
pose between (p
α,pβ) contains kplaces, then we apply the
following linear transformations to get Equation 3. MultiplyEquation 2a by (k-1), we get Equation 4.
(k−1)(u(p
α)+u(pθ)+···+u(pβ))≤(k−1) (4)
Add Equation 4 with Equation 2b, Equation 2c, ..., Equa-
tion 2e, we get Equation 5.
k(u(pγ)+u(pα)+u(pθ)+···+u(pβ))≤2k−1(5)
Divide Equation 5 by k, we get Equation 6.
(u(pγ)+u(pα)+u(pθ)+···+u(pβ))≤2−1/k (6)
As each place contains integer tokens, we further get Equa-
tion 3.
Deﬁnition 1 (Danger stripe): Given a violation and its
succinct constraint in Equation 3, the places appearing inthe equation form a danger stripe for the violation. With
the assistance of an indicator vector lindicating each place’s302presence or absence in the danger stripe with 1or0,
Equation 3 can be expressed in a vector form: lu≤13.
Redundant Constraints. A constraint is redundant if it
is subsumed by other constraints. Taking the constraint inEquation 1 for example, the constraint u(p
7)+u(p3)≤1
is subsumed by u(p7)+ u(p3)+ u(p4)≤1.A st h e
SBPI solver works on independent constraints, we conduct
a preprocessing step to remove the redundant constraints.In particular, we remove the constraint if the set of placesappearing in the constraint are covered by the set of placesin another constraint. Note that such reduction is essentiallya more natural and rigorous form of the heuristic-basedredundancy removal method used by AFix .
C. Solving the Control Constraints
Given the constraint in the form of lu≤1, our solution
is to generate an augmentation to the Petri net to force it to
avoid violation executions, using the Supervision Based onPlace Invariants (SBPI) theory. The solution augments theoriginal Petri net with new places and new arcs to guaranteethat this constraint is always satisﬁed in the augmented net.Before describing the SBPI technique, we ﬁrst introduce the
mathematical model of both the Petri net and its dynamicoperations.
Deﬁnition 2: A Petri net is a bipartite directed graph,
denoted by a tuple /angbracketleftP, T, A, W, u
0/angbracketright.Pis the set of places
andTthe set of transitions. A⊆(P×T)∪(T×P)is the
set of arcs. W:A×Nis a weight function which returns a
natural number for each arc. u0:P×Nis a function which
returns the number of tokens initially hosted in a given place.
The Petri net used in our technique is a special type of
Petri net called the pure Petri net4, where tokens cannot
directly ﬂow back to the source place (no self-loop). Besides,the weight of each of its arcs is 1, and each place canhave at most 1 token. The movement of tokens in Petri netis characterized by a 2-dimensional incidence matrix D.
Each cell D
ijis either 0 (not connected), 1 (incoming), or
-1(outgoing), representing the direction of the transition tj
with respect to the place pi.
We state the SBPI as follows.
Theorem 1 (SBPI Theorem): If lu0≤b, then we can
guarantee that the constraint lu≤bholds for any possible
marking uby adding a new place M. The newly added Mis
characterized by its initial marking u0
Mand its row vector
DMin the incidence matrix D, which should satisfy the
following condition:
u0
M+lu0=b (7)
and
DM+lD=0 (8)
3lis a row vector, uis a column vector.
4A standard Petri net result states that any Petri net can be reduced to
pure Petri nets [22].The added place enforces the maximal permissiveness in the
sense that it preserves as many executions as possible whileprohibiting only the violation-inducing executions.
We interpret Theorem 1 intuitively as follows. The con-
straint that the number of tokens in the danger stripe cannot
exceed a bound balways holds if, in the augmented Petri net,
the total number of tokens initially in both the danger stripeandM(newly added place) is b, deﬁned by Equation 7, and
the net change of the number of tokens in the danger stripeandM is always 0, deﬁned by Equation 8. Based on the
two equations, we can easily compute the initial marking ofthe new place as: b−lu
0and the new arcs, as well as their
directions, DM=−lD.
Let us apply the SBPI technique to ﬁx the atomicity
violation in the running example, of which the incidencematrix is
D=⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝t
1t2t3t4t5t6t7
p1−1 000000
p2 1−1 00000
p3 01 −10 0 0 0
p4 001 −1 000
p5 0001 −10 0
p6 0000100
p7 000001 −1
p8 10000 −10
p9 0000 −10 1
L 0−1 01000⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠
The initial marking is u
0=[ 1000000001 ]T(the
places are ordered as p1,p2, ...p9,L.). The constraint is
u(p3)+u(p4)+u(p7)≤1. In other words, the indicator
vector lis[ 0011001000 ] andb=1 . Applying the SBPI
constraint solver, the transition vector of the new place M,
DM,i s−lD=[ 0−1010−11 ] with the initial marking
u0
Masb−lu0=1 . The new place, M, and its connecting
arcs, as indicated by DM, is shown in Figure 2(c).
As shown in Figure 2(c), the new place, M, has two
outgoing arcs to t2andt6, and two incoming arcs from
t4andt7. The behavior of place Mis identical to a lock,
as explained in Section II. The arc connecting place M
to transition t2essentially says, a lock operation should
be added to the transition t2, i.e., the control ﬂow edge
represented by t2in the CFG. We show how to achieve
this in the program code in Section IV.
D. Multi-variable Atomicity Violation
So far our discussion is focused on atomicity violations
involving a single shared variable. Our approach can benaturally applied to ﬁx multi-variable atomicity violations,or the so-called atomic-set (ASET) violations [30]. Vizari
et al. [30] exhaustively enumerate 11 thread interleavingpatterns as the equivalent conditions of ASET violations. Forexample, the pattern W
1
xW2
yW1
yW2
xdescribes a violating
interleaving, where the ﬁrst and the third write belong to3031
32
41
32
2
43
(a) (b)
Figure 3: (a) Multiple-variable atomicity violation, the dotted lines depict
the forming interleavings of the violation. (b) The deadlocks may be
introduced.
a unit of work in one thread and the second and the fourth
belong to the other. As shown in Figure 3(a), the interleavingis equivalent to the co-occurrence of the interleavings shownin the two squares. Following the process described above,we can construct two constraints, u(s1)+u(s2)+u(s3)≤1
andu(s2)+ u(s3)+ u(s4)≤1and add both of them to the
constraint solver. Our technique treats ASET violations in auniform manner with the same guarantees. Comparatively,it is non-trivial to adapt AFix [18] to ﬁx ASET violations
because the approach is designed speciﬁcally for single-variable atomicity violations.
E. Deadlock-Free Guarantee
Our approach ﬁxes the violations one by one to achieve
the ﬁne-granularity concurrency control for each bug. How-ever, due to the interplay between the overlapping bugs,deadlocks may be introduced. For example in Figure 3(b),there are two bugs, each involving variables xand y,
respectively. The computed controllers lxandly(appearing
in the comments) may form the cyclic lock acquisitionorders, i.e., deadlocks. The work of Wang et al. [34] is usedas a postprocessing step to ﬁx deadlocks. We extend the
deadlock avoidance to guarantee that our approach does not
introduce new deadlocks to the program. In particular, weonly ﬁx those deadlocks introduced by our added locks or, inthe Petri net language, we only handle the siphons involvingthe newly added lock places
5.
F . Guarantee of Lock Placement
Our approach guarantees that the lock placement is free
of bad lock practices. In this section, we show the guarantee
with respect to both the intra-procedural and inter-proceduralconstructs.
Lock Placement when Branches or Loops are Present.
Our approach generates only the matched lock–unlock op-erations. It never generates bad lock practices such as dou-ble locking, double unlocking, missed locking, and missedunlocking. It is well known [18] that the careless manual
5More details and formal proof are in our technique report.http://www.
cse.ust.hk/prism/axis/TR.pdfﬁxing easily leads to bad lock practices such as the double
locking. Surprisingly, our approach avoids bad lock practices
without any special treatments. The key insight is that, the
SBPI theory guarantees that the places in a danger stripe
together with the added supervisory place always containan invariant number of tokens in total
6. In the case that the
bad lock practices are present, e.g., missed unlocking, theexecution along a certain path may cause inconsistencies inthe total tokens in both the danger stripe and the supervisoryplace. The formal proof and a concrete example is shownin our technique report
7.
Lock Placement when sαand sβare in Different
Functions. (Remember that sα,sβ,sγform a violation.)
When sαandsβare in different functions, the SBPI solver
may also place the lock acquisition and the lock release indifferent functions. Such a placement can cause errors if,for example, the method containing the lock release getsinvoked under a different calling context where no locksare acquired. To prevent such errors, we place a restrictionon the statements s
αandsβthat they must be enclosed in
the same method. In the case that they are not in the samemethod, we preprocess the violations to make sure s
αandsβ
are mapped to the call sites in their lowest common ancestor
(LCA) method.
G. Discussion of Limitations
A major threat to the validity of our high performance
claim is that we use the degree of concurrency as the domi-nant factor for the performance measurement. We minimizethe number of locking operations only under the condition
that the maximal concurrency degree is achieved. In fact,
researchers ( [11], [15]) often consider the number of lockingoperations as an equally important factor of the performance.The concurrency degree may be sacriﬁced sometimes forreducing the number of locking operations. Our techniquehas the consequence that, the locks we introduce may bein the hot loops, leading to many the locking operations.We downplay the importance of locking frequency fortwo reasons. First, due to the JVM optimization [4]
8, the
uncontended locking operations are extremely fast, and theircost is negligible if no hot loops are present. Second, ourempirical experience shows that atomicity violations rarelyhappen in the hot loops perhaps because the high frequencyof execution can easily expose the bugs. Nevertheless, asa mitigation measure, we conduct the cycle detection toinform the developers that some locks are placed in loopsor recursions.
Our input violation bugs are detected by Pecan [16],
which may contain benign violations that, according toChew et al. [7], do not affect the correctness of the program
6Actually, this is the reason why the technique is called SBPI , and the
reason why the constraint can be satisﬁed.
7http://www.cse.ust.hk/prism/axis/TR.pdf
8http://blogs.oracle.com/dagastine/304or even required in some cases. Since Pecan does not clas-
sify benign violations, ﬁxing them may incur unnecessaryoverhead. However, we think this is related to the quality ofthe bug reports and does not undermine our contribution.
IV . I
MPLEMENTA TION
We implement our approach as a tool, Axis9, on top of the
Soot framework. Axis contains four components: the Petri
net builder, the constraint constructor, the constraint solver,and the patcher.
The construction of Petri nets is based on the depth-
ﬁrst traversal of the call graph and the intra-proceduralcontrol ﬂow graphs. We construct Petri nets by substituting
each node-edge-node structure with the place-arc-transition-arc-place structure. For methods invoked under differentcontexts, we clone the Petri nets of these methods to getcontext sensitivity. If threads are created in recursions or
loops, we further clone the Petri subnet rooted at the run
method. The constraint construction is built on top of theforward data ﬂow analysis in Soot .
Our patcher works directly on the bytecode instead of the
source code. The implementation of the patcher is full ofchallenges. We highlight important ones as follows.
Patching Locks. The instrumentator adds the locking op-
erations, i.e., the monitorenter and monitorexit instructions,
to the program according to the result of the solver. Thepatched lock is created as a static variable of the class thatcontains the program entry point ( main method). Since this
class is usually loaded ﬁrst, we ensure the lock variables arealways properly initialized before being used.
Exception Handling. Exceptions may be thrown between
a pair of added locking operations, which make the executionskip the monitorexit instruction. To make sure that our
patcher works in such case, we add an exception handlerdirectly after the monitorexit , which captures the exceptions
thrown between the monitorenter and the monitorexit state-
ments and also from our injected exception handlers.
Control Flow Interception. As shown in Section III-C,
our solution is in the form of places connecting to thetransitions. From the view of CFG, we need to inject thelock orunlock operations to the control ﬂow edges modeled
by the transitions. However, the control ﬂow edges are notexplicitly represented in the code. Given a control ﬂow edgeE(from mton), where we want to inject the unlocking
operation, naively injecting monitorexit just before the target
statement nis problematic because other edges with nas the
target are also affected. We explicitly represent the controlﬂow edges in the code and isolate the effect of monitorexit
to the control ﬂow edges as follows. Given the edge E,w e
change it to m
jumpto→ nopjumpto→ n. In this way, the nop ,
having a single parent and single child, explicitly representsthe ﬂow edge. Then, injecting the monitorexit to just before
9We make it publicly accessible: http://www.cse.ust.hk/prism/axisor after nop (but not across the jumping statement) will not
affect other control ﬂow edges.
V. E V ALUA TION
In this section, we aim at answering the following
research questions.
1) Does our approach automatically ﬁx the atomicity
violations?
2) How does our approach affect the concurrency degree
of the original program as compared to the state of theart approach?
3) Does our approach introduce new deadlocks to the
original program?
To answer these questions, we implemented our approach
as a tool, Axis , and used it to ﬁx the atomicity violations
found in a set of popularly used subjects ( [16], [25]), aslisted in Table I. The subjects contain three large scaleprograms, Openjms ,Derby , and Jigsaw , which are, re-
spectively, the open source implementation of JMS speciﬁca-tion
10,Apache ’s database management system, and W3C ’s
web server platform. Table I shows, in column two andthree, the number of application methods ( #Method ) and
the number of statements ( #Stmt )
11. We collect the bugs
using the violation detection tool, Pecan . All studies are
performed on a x86 64 Dell workstation with 3.0GHz quad-
core Intel Xeon X5450 processors based on Core 2 micro-architecture (8 cores total). The server has 16GB RAM and6M L2 caches, runs Ubuntu 8.04 with a Linux 2.6.22 kernel,and uses Sun’s 64-Bit 1.6.0 JVM. For each program, we run20 runs to collect the data.
The ﬁrst question can be answered easily by measuring
the effectiveness of Axis . We run the violation detection tool,
Pecan , upon the patched versions of the subjects with the
same program input. Pecan detected no further violations for
any of the 13 subjects. We report our investigation of theremaining two questions as follows.
A. The Study of the Bug Fixing Process
In this section, we study various important characteristics
of the bug ﬁxing process of Axis itself. In Table I, we ﬁrst
report, for each subject, the space and time usage of Axis in
terms of the number of bugs ﬁxed ( #bug ), the size of the
constructed Petri net ( size ), the time of ﬁxing the violations
(T
av), and the time of ﬁxing the deadlocks ( Tdl). We show
the time of the call graph construction ( Tcg) as the reference.
The data show that the constructed Petri nets, despite
being context-sensitive, contain a small number of nodescompared to the total number of program statements. Thelargest number of nodes in our evaluation ( Jigsaw ) is around
25K, which can easily ﬁt into the memory of a desktop ma-chine. The time for ﬁxing the violations is almost negligible,
10http://java.net/projects/jms-spec/pages/Home
11We conduct the analysis on the Soot’s jimple IR. Hereafter, the
statement means the Jimple IR.305 postAttributeChangeEvent() {
1 ...2 if (( attrListener 
!= null ) ) {
3     AttributeChangedEvent evt = 
4 new AttributeChangedEvent(getResource(),5 attributes
[idx],
6   newvalue);
7 fireAttributeChangeEvent (evt);
8}9   }
(a)
 postAttributeChangeEvent() {
         l1.lock();
if (( attrListener != null ) ) {
                  l2.lock();
AttributeChangedEvent evt = 
new AttributeChangedEvent(getResource(),
attributes [idx],
  newvalue);
                 l2.unlock();
fireAttributeChangeEvent (evt);
}
          l1.unlock();    }
(b)
 postAttributeChangeEvent() {
          l.lock();
if (( attrListener != null ) ) {
AttributeChangedEvent evt = 
new AttributeChangedEvent(getResource(),
attributes [idx],
  newvalue);
fireAttributeChangeEvent (evt);
}
  l.unlock();
    }
(c)
Figure 4: The ﬁxing of the violations in Jigsaw . (a) The violation. (b)
The ﬁxing of our approach. (c) The ﬁxing of AFix approach.
less than 1 second in all subjects. The deadlock avoidance
analysis also scales well with respect to the program size,taking 30 seconds in the worst case.
The two columns under the category of Locks reports the
number of locks introduced by Axis and AFix , respectively.
For the three large subjects, to ﬁx the same number ofbugs, AFix on average generates 70% fewer locks compared
toAxis . This is because, its heuristics-based merging step
cannot precisely reason about the interplay between theoverlapping bugs and conservatively protects several unre-
lated bugs with the same lock. This directly translates tothe coarse-granularity concurrency control and the longerblocking time on the locks. We use a real example in the
subject Jigsaw to further clarify this point.
Figure 4(a) is a simpliﬁed code snippet from Jigsaw that
shows the interplay between two atomicity violations. Inthe ﬁrst bug, local statements line 2 and line 7 accessingthe variable attrListerner , are interleaved by a remote
statement (not shown), s
γ, that also accesses this variable.
In the second bug, line 5 is the remote statement, accessingthe variable attributes , that interleaves with a pair of local
statements (not shown), s
/prime
αands/prime
β, that access the same
variable. Note that the two local statements in the secondbug can be executed in parallel with the statement, line 7, inthe ﬁrst bug because they modify unrelated program states.As shown in Figure 4(c), AFix merges the two violations as
one and protects them with a common lock. As the result,line 7, a long computation, and the sequence between s
/prime
α
ands/prime
βcannot be executed concurrently. Our ﬁx, as shown
in Figure 4(b), generates two locks, one for each bug. Line 7
can be allowed to execute because s/prime
αands/prime
βnow acquire a
different lock. Our approach, without any fear of deadlocks,makes use of nested locking to reduce the lock contention.
B. Performance of the Patched Code
In this study, we assess the performance impact of the
generated patches. For each subject, we compare the per-formance of four versions, the original version ( Orig ), the
version generated by AFix , the patched versions by our
technique with Axis (Axis-DA ) and Axis with the deadlock
avoidance disabled ( Axis-noDA ). Since the original AFix
tool was developed for C programs, we have reimplementedits algorithm faithfully and released our implementation forfurther scrutiny
12. Our performance study consists of two
experiments: the ﬁrst studies the computational throughputof patched versions compared to the original, the secondstudies the scalability of the throughput with an increasingnumber of threads.
In the performance category of Table I, we show the
performance measurements of the subjects with the number
of threads ﬁxed at eight, which is the number of cores onour test platform. The ﬁrst seven subjects use few synchro-nization operations and have no more than three violations toﬁx. For this reason, the patches generated by Axis-noDA and
AFix are almost identical. The performance of each version
is, therefore, more or less the same with minor ﬂuctuationsdue to the thread scheduling. For subjects Cache4j ,Hedc
and Specjbb , The Axis-DA version, however, introduces a
higher overhead of 20% ,5% and4%. This overhead is the
cost of deadlock-freeness through the use of additional locks.
The result for the three large subjects shows the superior-
ity of Axis . For the subject OpenJMS , the patched version
with no deadlock avoidance ( Axis-noDA performs almost
as well as the original version, which contains violations.And, it outperforms the AFix version by 8%. With the
deadlock-free guarantee, our Axis-DA version is 4% slower
than the AFix version, which does not provide a deadlock-
free guarantee. For the subject Jigsaw , we are unable to
obtain the stable throughput data for Axis-noDA and AFix
12AFix Java implementation. URL: http://www.cse.ust.hk/prism/axis306Table I: The metrics of the ﬁxing process and the performance of the patched programs. In the performance column, we use millisecond (ms) as the
unit. One exceptional case is Specjbb , where we use its own speciﬁc unit to measure the performance, bops (business operations per second). Higher
performance corresponds to higher bops value.
ProgramProgram properties Metrics of the ﬁxing Locks Performance
#Method #Stmt #bug size Tcg(sec)Tav(ms)Tdl(ms)Axis AFix Orig Axis -noDA Axis -DAAF ix
MergeSort 59 695 1 494 49.6 9 29 1 1 20 21 20 20
StringBuffer 39 361 1 148 51.2 9 16 1 1 10 10 11 11
ArrayList 24 221 2 328 31.7 3 24 2 2 13 15 15 14
LinkedList 43 347 2 336 31.9 3 32 2 2 10 11 13 11
HashSet 10 78 3 264 31.3 2 11 2 2 23 28 28 29
T reeSet 17 115 2 432 33.4 2 24 1 1 25 27 27 25
RayT racer 59 695 2 378 33.2 18 22 2 1 17 19 20 21
Cache4j 197 2948 2 352 50 121 362 2 2 35 36 42 37
Hedc 136 1187 3 386 59 113 384 2 2 5441 5513 5720 5533
SpecJBB 757 21244 31 450 61 134 371 2 2 80337 78078 75263 77970
OpenJMS 19476 302004 296 17972 128 574 1835 87 28 5415 5501 6193 5936
Jigsaw 11227 222118 754 25570 65.5 577 32492 50 10 960 - 1135 -
Derby 20964 321142 330 16529 79.4 603 24034 74 13 503 520 557 548
because the patched versions easily lead to deadlock with
eight threads running. This case shows the importance ofthe deadlock avoidance in the patch. For the subject Derby ,
theAxis-noDA version is 6% faster than the AFix version.
The Axis-DA version, with deadlock-free guarantee, incurs
only 2% higher overhead compared to the AFix version. In
general, the overhead incurred by the Axis-noDA version is
around 40% of the overhead of the AFix version.
In Figure 5, we show a study of the scalability of the
patched code by both our technique and AFix with respect
to the increasing number of threads, using the large scalesubjects OpenJMS, JigSaw and Derby . For the subject
OpenJMS , when the thread number is larger than 4, the
Axis-noDA version outperforms the AFix version by around
9%. The Axis-DA version incurs 3% (2 threads) to 20% (12
threads) overhead. Compared to the AFix version, it is 1%
(4 threads) to 6% (12 threads) slower, but it guarantees thedeadlock-freeness. For the subject Jigsaw , both the Axis-
noDA and AFix versions easily lead to deadlocks. The Axis-
DA version incurs a slowdown of 9% (4 threads) to 24%
(2 threads). For the subject Derby , the Axis-noDA version
outperforms the AFix version by around 6% when the thread
number increases to 8. The Axis-DA version, incurring 6%
(2 threads) to 11% (12 threads) overhead, is slightly slowerthan the AFix version by 2% on average. As seen, our
technique exhibits a better performance than AFix as the
thread number increases. An explanation for the observationis our approach leads to fewer contentions of the same locksand allows higher concurrency degree.
One interesting observation from Figure 5 is that, when
the thread number is 1, the performance of all versions is
similar. Such an observation illustrates that the added lock-ing operations are often not in the hot loops, and introducenegligible overhead, if we do not consider blocking time,as compared to the original version. This conﬁrms with ourassumption that the locking frequency is not a key factor
that inﬂuences the performance of our subjects.
To conclude, our Axis-noDA outperforms AFix approach
by 6% to 9% in the realistic applications. For conservativelyguaranteeing deadlock-freeness, our Axis version often in-
curs a moderate (average 10%) overhead.
C. Safety of the Generated Code
In this study, we aim to assess if our patches introduce
deadlocks in the subjects. We could use existing deadlockdetecting techniques to quantify this property. However, wefound that simply by sampling the runs for a ﬁxed numberof times is already sufﬁcient to reveal interesting insights.We run each patched program 20 times and observe whetherdeadlocks happen without any interference to the schedulingmechanism.
As shown in Table II, the deadlocks can easily happen
with even 20 uncontrolled runs. For Openjms , each of the
version with the Axis-noDA patch and the version with the
AFix patch gets 2 deadlocks when the thread number reaches
8. When the thread number reaches 12, more deadlocks (7
and 5) incur in these two versions. For Jigsaw , the two
patched versions of Jigsaw always get deadlocks at runtime
when there are multiple threads. For Derby , when the thread
number reaches 12, the patched versions by Axis-noDA
and AFix incur 11 deadlocks and 7 deadlocks, respectively.
Comparatively, we observe no deadlocks for the patchedversion by Axis-DA . This observation shows the deadlock
is a serious problem to treat while ﬁxing of violations. It isworthwhile to pay a higher cost in the Axis-DA patches to
avoid them.
VI. R
ELA TED WORK
Lock allocation ( [11], [15], [21]) is akin to the automatic
ﬁxing of violations. Its goal is to infer the synchronizationconstructs to guarantee the speciﬁed atomicity properties307(a)
 (b)
 (c)
Figure 5: (a) Openjms. (b) Jigsaw. (c) Derby.
Table II: The ﬁxing process of Axis-noDA and AFix introduce deadlocks.
For a subject, we show the deadlocks for both its Axis-noDA version and
AFix version.
Patched Program T=2T=4T=8T=1 2
OpenjmsAxis-noDA 0 0 2 7
AFix 0 0 2 5
JigsawAxis-noDA 20 20 20 20
AFix 20 20 20 20
DerbyAxis-noDA 0 0 0 11
AFix 0 0 0 7
and the high performance. Recent lock allocation work (
[14], [29]) makes use of the shape properties to generatethe ﬁne-granularity locks, so that multiple operations cansimultaneously access different parts of a data structure.
Automatically inferring the atomicity property, i.e., the
atomic region, is orthogonal to our approach. V echev et
al. [31] propose an assertion-directed approach to iterativelyenlarge the atomic region until the assertion is satisﬁed.Besides, trace analysis ( [23], [35]) can also be used toextract the atomicity property from the correct runs.
Self-healing approach [5], [7] detects the faults or er-
rors at runtime and generates dynamic patches so that theexecutions recover from the anomalies. However, it lacks
the comprehensive off-line analysis required to generatehigh-quality patches. Lucia et al. [20] propose a speciﬁc
architectural support for dynamically avoiding atomicityviolations.
Deterministic execution system [3] or deterministic lan-
guage support [2] guarantees deterministic behaviors of theprogram by construction. They still face many challenges
such as high runtime overhead or extra manual annotations.
An alternative approach, checking the determinism throughthe testing [24], complements our approach as it can be usedto ﬁlter out the benign violations.
Petri net is widely applied to various software engi-
neering tasks, e.g., analyzing the performance of softwaresystem [9], modeling the protocol of software systems [37],
modeling the concurrency programs ( [12], [34]).
VII. C
ONCLUSIONS
We have presented an automatic approach to ﬁx atomicity
violations through solving the SBPI control constraints,
using the SBPI control theory as the theoretical foundation.
Given the bug reports of dynamically detected violations, ourtechnique models the offending program statements and theircalling contexts using Petri nets. The violations themselvesare transformed to a set of linear inequalities with respectto the Petri net structures, which we call control constraints.We then use the SBPI constraint solver to generate an
augmented Petri net that: 1. maximally respects the degreeof concurrency in the original design; 2. guarantees not tointroduce new deadlocks. We implemented our techniqueas a tool, Axis , and evaluated it against a set of popular
concurrent programs. The evaluation shows Axis is both
more scalable and effective when compared to the relatedwork.
A
CKNOWLEDGMENTS
We ﬁrst thank Yin Wang and Terence Kelly from HP
Labs for their patient guidance throughout this work. We
also thank the anonymous reviewers for their constructive
feedback. This research is supported by RGC GRF grant622208 and 622909 and by the HKUST RFID ResearchCenter.
R
EFERENCES
[1] A time to patch ii: Mozilla. http://voices.washingtonpost.com/
securityﬁx/2006/02/a time topatch iimozilla.html.
[2] Sarita V . Adve, Stephen Heumann, Rakesh Komuravelli,
Jeffrey Overbey, Patrick Simmons, Hyojin Sung, and Mohsen
V akilian. A type and effect system for deterministic parallel
java. In OOPSLA , 2009.308[3] Amittai Aviram, Shu-Chun Weng, Sen Hu, and Bryan Ford.
Efﬁcient system-enforced deterministic parallelism. In OSDI ,
2010.
[4] David F. Bacon, Ravi Konuru, Chet Murthy, and Mauricio
Serrano. Thin locks: featherweight synchronization for java.
InPLDI , 1998.
[5] Luciano Baresi and Sam Guinea. Self-supervising bpel
processes. IEEE Trans. Software Eng. , 37(2), 2011.
[6] Reimer Behrends, R. E. K. Stirewalt, and Laura K. Dillon.
Avoiding serialization vulnerabilities through the use of syn-chronization contracts. In Austrian Computer Society , 2004.
[7] Lee Chew and David Lie. Kivati: fast detection and prevention
of atomicity violations. In EuroSys , 2010.
[8] Jong-Deok Choi, Manish Gupta, Mauricio Serrano, Vu-
granam C. Sreedhar, and Sam Midkiff. Escape analysis for
java. In OOPSLA , OOPSLA ’99, 1999.
[9] Vittorio Cortellessa, Antinisca Di Marco, and Paola Inverardi.
Model-Based Software Performance Analysis . Springer, 2011.
[10] Crispin Cowan, Heather Hinton, Calton Pu, and Jonathan
Walpole. The cracker patch choice: An analysis of post hoc
security techniques1. Information Systems Security , 2000.
[11] Michael Emmi, Jeffrey S. Fischer, Ranjit Jhala, and Rupak
Majumdar. Lock allocation. In POPL , 2007.
[12] Azadeh Farzan and P . Madhusudan. Causal atomicity. In
CA V , 2006.
[13] Cormac Flanagan and Stephen N. Freund. Atomizer: a
dynamic atomicity checker for multithreaded programs. In
POPL , 2004.
[14] G. Golan-Gueta, N. Bronson, A. Aiken, G. Ramalingam,
M. Sagiv, and E. Y ahav. Automatic ﬁne-grain locking using
shape properties. In OOPSLA , 2011.
[15] Richard L. Halpert, Christopher J. F. Pickett, and Clark
V erbrugge. Component-based lock allocation. In PACT , 2007.
[16] Jeff Huang and Charles Zhang. Persuasive prediction of
concurrency access anomalies. In ISSTA , 2011.
[17] M. V . Iordache and P . J. Antsaklis. Supervision based on
place invariants: A survey. Discrete Event Dynamic Systems ,
16:451–492, December 2006.
[18] Guoliang Jin, Linhai Song, Wei Zhang, Shan Lu, and Ben
Liblit. Automated atomicity-violation ﬁxing. In PLDI , 2011.
[19] Shan Lu, Soyeon Park, Eunsoo Seo, and Y uanyuan Zhou.
Learning from mistakes: a comprehensive study on real world
concurrency bug characteristics. In ASPLOS , 2008.
[20] Brandon Lucia, Joseph Devietti, Luis Ceze, and Karin Strauss.
Atom-aid: Detecting and surviving atomicity violations. IEEE
Micro , 29, 2009.[21] Bill McCloskey, Feng Zhou, David Gay, and Eric Brewer.
Autolocker: synchronization inference for atomic sections. InPOPL , 2006.
[22] T. Murata. Petri nets: Properties, analysis and applications.
Proceedings of the IEEE , 77(4):541 –580, apr 1989.
[23] Abdullah Muzahid, Norimasa Otsuki, and Josep Torrellas.
Atomtracker: A comprehensive approach to atomic region
inference and violation detection. In MICRO , 2010.
[24] Adrian Nistor, Darko Marinov, and Josep Torrellas. In-
stantcheck: Checking the determinism of parallel programsusing on-the-ﬂy incremental hashing. In MICRO , 2010.
[25] Chang-Seo Park and Koushik Sen. Randomized active atom-
icity violation detection in concurrent programs. In FSE ,
2008.
[26] Soyeon Park, Shan Lu, and Y uanyuan Zhou. Ctrigger:
exposing atomicity violation bugs from their hiding places.InASPLOS
, 2009.
[27] Eric Rescorla. Security holes... Who cares? In SSYM’03:
Proceedings of the 12th Conference on USENIX Security Sym-
posium , pages 75–90, Berkeley, CA, USA, 2003. USENIX
Association.
[28] Francesco Sorrentino, Azadeh Farzan, and P . Madhusudan.
Penelope: weaving threads to expose atomicity violations. InFSE , 2010.
[29] Gautam Upadhyaya, Samuel P . Midkiff, and Vijay S. Pai.
Using data structure knowledge for efﬁcient lock generation
and strong atomicity. In PPoPP , 2010.
[30] Mandana V aziri, Frank Tip, and Julian Dolby. Associating
synchronization constraints with data in an object-orientedlanguage. In POPL , 2006.
[31] Martin V echev, Eran Y ahav, and Greta Y orsh. Abstraction-
guided synthesis of synchronization. In POPL , 2010.
[32] Willem Visser, Klaus Havelund, Guillaume P . Brat, and
Seungjoon Park. Model checking programs. In ASE , 2000.
[33] Yin Wang, Terence Kelly, Manjunath Kudlur, St ´ephane Lafor-
tune, and Scott A. Mahlke. Gadara: Dynamic deadlock
avoidance for multithreaded programs. In OSDI , 2008.
[34] Yin Wang, St ´ephane Lafortune, Terence Kelly, Manjunath
Kudlur, and Scott Mahlke. The theory of deadlock avoidancevia discrete control. In POPL , 2009.
[35] D. Weeratunge, X. Zhang, and S. Jagannathan. Accentuat-
ing the positive: Atomicity inference and enforcement using
correct executions. In OOPSLA , 2011.
[36] Charles Zhang. Flexsync: An aspect-oriented approach to java
synchronization. In ICSE , 2009.
[37] Ji Zhang and Betty H. C. Cheng. Model-based development
of dynamically adaptive software. In ICSE , 2006.309