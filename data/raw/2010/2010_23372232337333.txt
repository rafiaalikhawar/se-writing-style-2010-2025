Behavioral Validation of JFSL Speciﬁcations through Model Synthesis
Carlo Ghezzi∗
∗Politecnico di Milano, DeepSE Group, DEI
p.za L. Da Vinci, 32 – 20133 Milano (MI), Italy
{ghezzi,mocci}@elet.polimi.itAndrea Mocci∗†
†Massachusetts Institute of Technology, CSAIL
32 Vassar St. – 02139 Cambridge, MA (USA)
am@csail.mit.edu
Abstract —Contracts are a popular declarative speciﬁcation
technique to describe the behavior of stateful components
in terms of pre/post conditions and invariants. Since each
operation is speciﬁed separately in terms of an abstract
implementation, it may be hard to understand and validate
the resulting component behavior from contracts in terms
of method interactions. In particular, properties expressed
through algebraic axioms, which specify the effect of sequences
of operations, require complex theorem proving techniques to
be validated. In this paper, we propose an automatic small-
scope based approach to synthesize incomplete behavioral
abstractions for contracts expressed in the J FSL notation.
The proposed abstraction technique enables the possibility to
check that the contract behavior is coherent with behavioral
properties expressed as axioms of an algebraic speciﬁcations.
We assess the applicability of our approach by showing how
the synthesis methodology can be applied to some classes of
contract-based artifacts like speciﬁcations of data abstractions
and requirement engineering models.
Keywords -contracts; speciﬁcations; model synthesis; behav-
ioral validation
I. I NTRODUCTION AND MOTIVATIONS
Abstraction is a fundamental conceptual tool in software
design [1]: it is a many-to-one mapping activity that sep-
arates, at a given level of analysis, relevant aspects from
the irrelevant ones. In particular, abstraction by speciﬁcation
[2] decouples the description of the behavior of a software
artifact – the speciﬁcation – from the details concerning its
implementations.
Declarative speciﬁcations are a popular approach to de-
scribing software behavior through properties formally ex-
pressed in logic. For example, J ML[3] is a declarative speci-
ﬁcation language for J AVA classes based on ﬁrst-order logic.
A more recent one, the JF ORGE Speciﬁcation Language
(JFSL)[4], [5], is based on relational logic. Both are based
on the concepts of pre-,post-conditions andinvariants .
Pre- and post-conditions are very suitable for the speciﬁ-
cation of procedural abstractions , such as array sorting. A
pre-condition states the conditions on which the procedural
abstraction is deﬁned. A post-condition describes a condition
that is guaranteed after the execution of the procedure if
the precondition holds before the invocation. A pre/post-
condition pair constitutes a contract for the procedural
abstraction. Pre- and post-conditions can be also used to
specify data abstractions , that is, components that hide the@SpecField (elems :seqObject, size :int)
@Invariant (this.size≥0∧this.size≤#this.elems )
public class Stack
@Requires (len > 0)
@Ensures (this.size = 0∧#this.elems =len)
@Throws (Exception :len < = 0)
public Stack (intlen){...}
@Requires (this.size < #this.elems )
@Ensures (this.size = @old(this.size ) + 1∧
this.elems = @old(this.elems ) + +(@ old(this.size )→i))
@Modiﬁes (this.elems, this.size )
@Throws (Exception :this.size≥#this.elems )
public void push(Object i ){...}
@Requires (this.size > 0)
@Ensures (this.size = @old(this.size )−1)
@Modiﬁes (this.size ) @Throws (Exception :this.size = 0)
public void pop(){...}
@Requires (this.size > 0) @Returns (this.elems [this.size−1])
@Throws (Exception :this.size = 0)
@Pure public Object top (){...}
@Requires (true) @Returns (this.size )
@Pure public int size(){...}
@Requires (true) @Returns (#this.elems )
@Pure public int len(){...}
Figure 1. A J FSLspeciﬁcation for a Stack of Object
internal state, which is only visible through the invocation of
methods . In a contract-based speciﬁcation of a data abstrac-
tions, every method is seen as a procedural abstraction and
speciﬁed through pre- and post-conditions. However, since
data abstractions are stateful components, contracts must
take into account how the internal state affects the behavior
of methods. The common solution is to represent the state by
using an abstract model composed of mathematical entities,
like sets or sequences. Furthermore, invariants are used to
deﬁne the constraints on the abstract model that deﬁne legal
data abstractions. For a given data abstraction, its contract is
the set of invariants and methods pre- and post-conditions.
Figure 1 shows a contract speciﬁcation for a bounded stack
of elements written in the J FSL notation, represented as a
sequence of elements and an integer value representing the
stack size.
Contract-based speciﬁcations are easy to produce because
they use mathematical entities that are similar to pro-
gramming entities, like variables and arrays. Unfortunately,
however, they are hard to validate in terms of the prescribed
effects of operation interactions. The mutual relations among
methods are hard to understand: in particular, how they affect
each other, the order in which they must be executed and the
data they return. For example, given the contract in Figure 1,978-1-4673-1067-3/12/$31.00 c2012 IEEE ICSE 2012, Zurich, Switzerland 936
Stack
size()=0
top()/squigglerightException
len()=2
Stack(2)Stack
size()=1
top()=a
len()=2Stack
size()=1
top()=b
len()=2
Stack
size()=2
top()=b
len()=2Stack
size()=2
top()=a
len()=2Stack
size()=2
top()=b
len()=2
Stack
size()=2
top()=a
len()=2pop()push(a),
push(b)push(a),
push(b)
push(a),
push(b)push(a),
push(b)push(a)push(b)push(a) pop()pop()
pop()push(b)push(b)push(a)
pop()pop()pop()
Figure 2. A B EMof Stack. Quote marks are omitted from String literals.
it is not straightforward to prove that after a push invocation
it is always possible to invoke pop. Moreover, it is even
harder to validate the contract against its main behavioral
property, that is, the expected LIFO behavior. This property
can be easily represented in an equational style, for example
by using an axiom of an algebraic speciﬁcation stating that
for every possible non-full stack sand every possible object
to be inserted, invoking popMafterpush M(both denoting
the modiﬁer behavior of respective methods) produces a
stack which is equivalent to s:
∀s:Stack,e :Object|popM(push M(s,e)) = (A1)
ifsizeO(s)<len O(s)thenselsepopM(s)
In (A1) observe that since a method may modify the internal
state (i.e., be a modiﬁer , likepush ) and/or return a value
(i.e., be an observer , likesize), we use subscripts Mand
Oto indicate the kind of behavior.
A difﬁculty here is that the semantics of the =operator
in axioms like (A1) makes it hard to perform behavioral
validation. In fact, equality refers to the abstract state
deﬁned by the data abstraction, not to the abstract im-
plementation used in the contract, for which the property
does nothold. For example, popM(push M(Stack (2),“a”))
andpopM(push M(Stack (2),“b”))represent the same ab-
stract stack (the empty one), but the states of the abstract
implementation after the invocations are different, respec-
tively/angbracketleftelems = [“a”,null ],size = 0/angbracketrightand/angbracketleftelems =
[“b”,null ],size = 0/angbracketright.
In this paper, we propose a technique to enable validation
of behavioral properties like the ones in Axiom (A1) for
contracts expressed in the J FSL notation. The level of
abstraction we adopt is the one induced from behavioral
equivalence [6]. Intuitively, behavioral equivalence abstracts
two possible legal states c1andc2to the same abstract state
if their externally observable behavior is equivalent, that is,no sequence of methods, ending with an observer, returns
a different value if it is invoked starting from c1or from
c2. Considering the previous stack example, all states where
size = 0 andelems contains any tuple of objects would
be behaviorally equivalent, and would represent the abstract
notion of an empty stack.
The behavioral equivalence deﬁnition given above does
not provide an efﬁcient constructive method to check al-
gebraic axioms against declarative speciﬁcations. To check
equivalence of two states, one should in fact enumerate
all possible sequences of operations explicitly, and thus
all reachable abstract states, which is unfeasible. In a
previous work [7], we proposed a method to check alge-
braic axioms against a particular class of behavior models,
called behavioral equivalence models ( BEMs), whose states
exactly represent behaviorally equivalent classes of states.
The approach we propose here builds on our past work and
validates a contract by ﬁrst synthesizing a B EMand then
validating it against the algebraic axioms.
Figure 2 shows a B EMfor the S TACK contract. In a
BEM, every state is labeled with observer return values
and transitions represent method invocations with concrete
values for parameters. The level of abstraction of this model
is exactly the one needed to check Axiom (A1). In fact, by
interpreting axiom equality as behavioral equivalence, we
can check if the sequence of push andpopin the B EMis a
loop. However, B EMs are not complete: they describe – in
a precise way – a subset of all the possible behaviors of the
component. This is a common trade-off: we lose the ability
to model every possible behavior of the component, in favor
of an adequate level of precision that enables behavioral
analysis, such as the check of Axiom (A1).
In this paper, we leverage our knowledge about B EM
synthesis for black box components through dynamic anal-
ysis [8], B EMvalidation [7], the theory of hidden algebraic
speciﬁcations [6], and the analysis within small scopes [9]
to show how B EMs can be synthesized via static analysis
on J FSL speciﬁcations, and how these models can be used
for automatic behavioral validation. In particular, we show
how to extract synthetic but precise models of contracts
expressed with the J FSL notation, and how these models
can be automatically checked against behavioral properties
expressed by algebraic axioms.
The paper is structured as follows. Section II illustrates
background concepts, that is, J FSL contracts, and outlines
the hidden algebraic approach for the speciﬁcation of data
abstractions, whose theoretical results are the basis for our
synthesis approach. Section III illustrates the behavioral
abstraction technique and the construction of B EMs, while
Section IV brieﬂy illustrates the B EMvalidation approach
we proposed in [7]. Section V outlines related work and
identiﬁes approaches that can be used together with the
proposed one. As an assessment of the presented method,
Section VI shows how it can be used to validate contracts937that specify data structures and requirement artifacts. Finally,
in Section VII, we present the conclusions and future work.
II. B ACKGROUND CONCEPTS
This section introduces the background concepts used
within the proposed validation approach. We start by de-
scribing the J FSLlanguage, then we formally introduce some
concepts borrowed from the hidden approach to algebraic
speciﬁcations, and ﬁnally we describe and formalize B EMs.
A. JFSL Contracts
The JF ORGE speciﬁcation language ( JFSL)[4] can be
viewed as an application of A LLOY ’s relational logic to
specify J AVA programs by means of contracts. J FSL is the
notation we use for our contract abstraction approach. We
assume the reader to be familiar with the basic concepts
of relational logic and the A LLOY language [9]. In the
following, we will focus on the most important aspects of
JFSLand the related A LLOY analysis.
Since they are both based on ﬁrst-order logic with rela-
tional operators, J FSL and A LLOY are inherently undecid-
able [9]. The typical kind of analysis supported by both
approaches is incomplete, but leverages the small scope
hypothesis to justify its practical validity. Essentially, they
both support instance ﬁnding . This analysis consists of
either checking the consistency of the declared facts, or
checking them against an external assertion, by looking
for a refutation against a ﬁnite set of possible assignments
to variables, which constitute the scope of the analysis.
If a particular assignment is found, it is reported as a
counterexample ; obviously, if the counterexample is not
found within the given scope, one cannot be sure that the
assertion also holds outside the considered scope. The small
scope hypothesis [9] provides a practical justiﬁcation that
notﬁnding a counterexample inside an analysis scope gives
some relevant conﬁdence on the validity of the checked
assertion in the whole state space. Essentially, the hypothesis
states that most bugs have small counterexamples ; that is, if
the checked assertion is invalid, it is very likely that it has
a small counterexample, namely a counterexample that can
be found in a small scope.
The J FSLspeciﬁcation approach is reminiscent of E IFFEL
contracts [10] and the J MLlanguage [3]. It provides a set
of J AVA annotations that decorate class and method decla-
rations. The two main class annotations are the following:
(i)@SpecField : declares a speciﬁcation ﬁeld, that is, a
ﬁeld modeling the state of the data abstraction;
(ii)@Invariant an expression that declares which speci-
ﬁcation ﬁeld values are legal for the data abstraction.
Essentially, a speciﬁcation ﬁeld can be of any type supported
by A LLOY , like integer, tuple or sequence of objects. For
each method, the speciﬁcation can be provided with the
following annotations:(i)@Requires and@Ensures , that specify the method
pre and post-condition, respectively;
(ii)@Modiﬁes , which speciﬁes the method frame condi-
tions, that is, it contains a list of speciﬁcation ﬁelds that
can be modiﬁed by the method, and @Pure , which
declares that the method has no side effects;
(iii)@Throws , which declares exceptional results; its ar-
gument format is ExceptionName :cond , where
cond is the condition on which the exception is thrown.
For exceptional behaviors we assume that the values
of speciﬁcation ﬁelds are not changed;
(iv)@Returns , which declares the return value; the argu-
ment describes the value to be returned.
If a method modiﬁes a ﬁeld x, the post-condition can refer
to its value in the prestate with the @old(x)notation.
Expressions contain the special this variable, which refers
to the instance on which the method is called. The behavior
speciﬁed by the @Returns clause imposes that a special
variable, called return , is bounded to the speciﬁed expres-
sion. Similarly, a special variable throw models the possible
thrown exception, as speciﬁed by the @Throws clause.
B. Hidden Algebraic Signatures
We now introduce the essential concepts of the hidden
algebraic approach to software speciﬁcation, upon which we
base our method to synthesize B EMs from J FSL contracts.
In the ﬁeld of algebraic speciﬁcations, a data abstraction is a
mathematical entity that corresponds to an algebra (i.e., one
or more sets closed under a set of operations). The syntactic
part of the data abstraction is deﬁned by an algebraic
signature , which deﬁnes the domain and codomains of the
operations. A data abstraction is used to deﬁne a new data
type that represents the component to be speciﬁed. In this
context, there is a very important distinction between the
kind of data to be deﬁned, and the data used to communicate
with the component’s clients. Usually, the communication
from the component to its clients occurs through operations
that return data values, whose semantics is shared between
the client and the component. Following the hidden alge-
braic approach [6] for software speciﬁcation, data types used
for interaction are called visible data types .
We assume the reader to be familiar with basic algebraic
notions like sorted set ,signature ,term, and algebra [11]. Let
∆be the set of visible data types, where Vis a set of sorts
deﬁning the types. A hidden signature over ∆deﬁninghis a
pairΣ∆,h=/angbracketlefth,Φ/angbracketrightwherehis the hidden type deﬁned by the
signature, and Φis a set of functional symbols, describing
the signatures of operations. Each functional symbol φ∈Φ
identiﬁes an operation of the data abstraction; each operation
has a domain and a range . In this paper, we consider a
particular class of signatures, the linear signatures , that can
be easily used as signatures for state machines. Within this
class, the set of operations can be split in three different
disjoint sets, that is, Φ =K∪Γ∪Ω, whereKis the set938ofconstructors ,Γis the set of modiﬁers andΩis the set of
observers . An operation is a constructor when the range is
h; moreover, we restrict the signature to contain exactly one
constructor. Another requirement is that only the ﬁrst type
in the domain of observers and modiﬁers is h; all the other
types are the parameters of the operation. This constraint
explicitly excludes operations that have has a parameter.
We deﬁne a modiﬁer as an operation where the range is
h, and an observer as an operation where the range is in
∆. When an operation plays both the role of an observer
and a modiﬁer, we consider those behaviors as two different
functional symbols in Φ. Moreover, we model exceptions as
special values of the range of observers.
Given a hidden signature Σ∆,h, acontext is a term with
a single occurrence of a variable, usually called z, in place
of an argument that would be of type h, and whose last
operation is an observer. For example, given the signature of
Stack as speciﬁed in Figure 1, pop(push (Stack (3),“a”))
is a term while top(pop(z))is a context. Behavioral equiv-
alence can be deﬁned using contexts as follows. Given a
hidden signature ΣH, and a hidden algebra Aover Σ∆,h,
then the behavioral equivalence on A, denoted asb≡, is
deﬁned as: (i) the identity on visible data types, that is,
ab≡biffa=bwhena,bare of a sort vinV; (ii)ab≡b
iffAc(a) =Ac(b)for all contexts c, whena,bare of type
H, whereAcis a function interpreting the context cas an
operation on the algebra A.
A relationb/similarequalis a hidden congruence on Aif it is a
congruence with respect to the operations on Σ∆,hand it is
identity on the visible data types. An important theoretical
result presented in [6] is that if two possible states aandb
are such that ab/similarequalbunder some hidden congruenceb/similarequal, then
they are behaviorally equivalent; that is, ab≡b. Moreover,
if we construct a relationo=such thatao=biff observer
return values are equal if invoked for aandb, ando=is
a congruence on modiﬁers, thus we have the guarantee that
o==b≡. The problem is that ofteno=is not a congruence with
respect to modiﬁers; that is, for a modiﬁer m, it could be
thatao=b∧(m(a)/negationslasho=m(b)). For example, by invoking
pop on two states of Stack that expose the same values
for the observers, size andtop, we could reveal part of the
state which was hidden. Thus,o=must be reﬁned to include
context observations that discriminate the behavior; that is,
a set of additional experiments, used just for the behavioral
abstraction, that eventually will constitute a congruence.
The framework of hidden algebra is inherently incom-
plete [12]. Derivingb≡in the general case is very hard, and
requires theorem proving techniques whose automation is
difﬁcult. However, since in our case the hidden structure is
speciﬁed in relational logics, and the typical analysis of this
kind of structures is instance ﬁnding , which is incomplete
but decidable, we can resort to a ﬁnite scope analysis to
derive a behavioral equivalence relationb≡. To perform suchContract
Scope
Build State
Signature
b/similarequal=o=Isb/similarequala
congruence?Isclikely
iterable?Build
iterated
context
abstractionReﬁneb/similarequal
b≡=b/similarequalBuild B EMNo,
context cNo
Yes
Yes
Figure 3. Outline of the Synthesis Algorithm
analysis, we formulate the congruence relation synthesis
as an A LLOY problem. This is possible, and reasonable,
because J FSLand A LLOY share the same relational seman-
tics. In Section III we discuss how the congruence relation
relation can be built by analyzing the contract by analyzing
speciﬁc A LLOY problems built from the contract.
III. BEM S YNTHESIS FROM CONTRACTS
Given the theoretical premises illustrated in previous sec-
tion, our research problem has two sources of undecidability:
(i) relational logic as supported by J FSL is in general
undecidable, and (ii) the framework of hidden algebra, that
is, algebras where equivalence is behavioral equivalence, is
incomplete. To overcome this issue, we propose an approach
that can be classiﬁed as a kind of bounded analysis , that
is, an analysis which focuses on a speciﬁc ﬁnite, small
scope thus making the analysis decidable. The small scope
hypothesis [9], if taken as an assumption, gives a reasonable
justiﬁcation to perform a bounded analysis. In our case, we
interpret it as follows:
(i) if an algebraic axiom is not valid in a contract, a
counterexample can be found within a small scope;
(ii) it is thus safe to focus on a small scope to derive
a behavioral congruence modulo scope , synthesize a
BEM, and check it against an algebraic axiom; if no
counterexample is found, then the axiom is likely to
be valid.
We do not discuss how to choose the scope for our approach
mainly for space reasons and also because it has already
been widely discussed in the literature. In fact, we adopt the
same guidelines given for A LLOY [9] and J FSL[4], [13].
We can now introduce our algorithm to synthesize a B EM
from a contract speciﬁcation expressed in the J FSLnotation.
Figure 3 illustrates the synthesis algorithm.
First, an input to the algorithm is the scope of the analysis.
Similar to instance ﬁnding approaches like A LLOY , we
require the user to specify (i) the set of possible values for
method parameters; (ii) a bound for integers, which speciﬁes
the maximum number of bits to represent them (iii) the
maximum length of sequences. Second, the signature of
the data abstraction deﬁned by the contract is derived from
method signatures as follows:939(i) every pure observer is an operation in Ω;
(ii) every method with void return type and no exceptional
behavior is an operation in Γ;
(iii) every method with a non-void return type or a possible
exceptional behavior is modeled by two symbols, an
observer in Ωand a modiﬁer in Γ.
As for (iii), the observer behavior can be extracted from
the modiﬁer behavior by ignoring the effects on speciﬁcation
ﬁelds (i.e., the @Ensures clause) and considering just
the@Returns and/or @Throws clauses of the method
speciﬁcation. The rationale behind the choice of extracting
an observer behavior from an exceptional void method is
that this information is something the client could externally
observe. Moreover, consistently with J FSL semantics, we
consider operations to be total: a violation of speciﬁed
preconditions is usually modeled as a particular exceptional
result, called ClientFailure [4]. When a method is speciﬁed,
it is usually meant to terminate; possible nonterminating
computations can be accommodated by partial methods.
We can now describe how to compute a behavioral con-
gruenceb/similarequalstarting fromo=, that is, the equality on observers
(see Figure 3). Our algorithm computes a candidate con-
gruenceb/similarequalstarting from the observer equalityo=, and then
reﬁnes it incrementally by computing particular contexts and
imposing their equality until a congruence is found. In the
end, the resulting congruence is used to build a B EM.
Since we propose a bounded analysis, from now on
the derived relations must be intended modulo scope . For
example, behavioral equivalence modulo scopeb≡S, denotes
behavioral equivalence when method parameters belong to
the scope, and when contexts are limited to a certain length.
The relationship betweenb≡andb≡Sdepends on the signif-
icance of the scope. Letb≡Sbe deﬁned over the possible
abstract states constructible with the given scope [Ah]S.
Ideally, we want that ∀a,b∈[Ah]S:ab≡Sb⇒ab≡b,
that is, for every possible context c– even outside the scope
–∀a,b∈[Ah]S:ab≡Sb⇒A c(a) =Ac(b). However,
such check can be performed only with theorem proving. In
the following, we will intend each relation to be implicitly
modulo scope.
Hereafter, we brieﬂy describe how we model a possible
state as an A LLOY signature. In the following, we illustrate
how the congruence check is performed as an A LLOY
problem and how the candidate relation is reﬁned through
the steps of the algorithm.
A. Alloy State Signature
Starting from the contract and the scope, the algorithm
ﬁrst builds the basic A LLOY state signature modeling the
behavior of contract speciﬁcation ﬁelds and observers. An
abstract signature State is created, whose ﬁelds are the
speciﬁcation ﬁelds of the contract to be analyzed. The
contract invariant is added as a fact to the State signatureby substituting the variable this with a fresh variable, and
by universally quantifying it for every possible State .
A similar approach is performed for observer symbols
inΩ. Each observer return value and thrown value by
an associated exception can be represented as an observer
ﬁeld ofState signature, and the respective values are
bound as speciﬁed by the observer postconditions. For
example, for the topobserver of Stack , we introduce two
observer ﬁelds, toprandtopt. Thetop postcondition
is translated as a fact for State by (i) quantifying this
for allState (ii) substituting return andthrow variables
asthis.toprandthis.topt. For example, the top ob-
server postcondition is translated as the following fact:
facttopO{allthis :State|(this.size > 0⇒
this.topr=this.elems [this.size ])∧(this.size = 0⇒
this.toptinException )}.
Additional facts keep normal and exceptional behaviors
mutually disjoint: if the precondition for normal behavior is
true, then the throws ﬁeld is constrained to null, and vice-
versa, if the precondition for exceptional behavior is true,
thenreturn is constrained to null.
B. Congruence Synthesis
The ﬁrst step of our algorithm initializes the candidate
congruenceb/similarequalto observer equality relationo=. We formulate
the check for a congruence as a sequence of A LLOY prob-
lems. Suppose a,bare two contract states such that ab/similarequalb,
whereb/similarequalis the candidate congruence to be checked. Then,
for every possible context obs(mod(z)), we need to check
thatobs(mod(a))b/similarequalobs(mod(b)): if it is true, thanb/similarequalis a
behavioral congruence. Please note that method parameters
in context must be bound to actual values. Thus, in the
following, when we refer to obsandmod components of
a context of type obs(mod(z)), we refer to instantiated
observers and modiﬁers. Let us consider the check for
the congruence ofb/similarequalwith respect to a context of type
obs(mod(z)). To perform the congruence check, we ﬁrst
deﬁne two abstract signatures, PreState andPostState ,
which extend the State signature and model the contract
state before and after the application of mod . Then, we
deﬁne two singleton signatures for pre-states, Pre1and
Pre2, extendingPreState and two singleton signatures for
post-states,Post 1andPost 2, extendingPostState .Post 1
models the state of the contract after the application of mod
toPre1, andPost 2models the state of the contract after
the application of mod toPre2.
To check if the candidate relationb/similarequalis a congruence, we
check that the following A LLOY problem is unsatisﬁable:
(i) we assert observer equality as a fact that for every
observer ﬁeld obs;
(ii) we impose the postconditions of mod to hold inPost 1
andPost 2, by substituting pre-state ( @old) variables
appropriately to refer to Pre1andPre2;940(iii) we produce frame conditions to bind speciﬁcation
ﬁelds that cannot be modiﬁed;
(iv) we assert Post 1.obs/negationslash=Post 2.obs.
Example 1: Let us consider the context top(pop(z))for
theStack contract. The postcondition of pop is translated
to the following fact, binding Post 1objects:
factpost1Conds{allp:Pre1,q:Post 1|(p.size>
0⇒q.size =p.size−1)}.
The frame condition as speciﬁed by the @Modiﬁes
clause is instead translated to the following fact:
factpost1FC{allp:Pre1,q:Post 1|(p.size >
0⇒q.elems =p.elems )∧(p.size = 0⇒q.size =
p.size∧q.elems =p.elems )}.
If the above A LLOY problem is unsatisﬁable for every
possible context of type obs(mod(z)), thenb/similarequalis a congru-
ence; thus, we can start building the B EM(Section III-C).
Otherwise, the context for which the problem is satisﬁable
can be used to reﬁneb/similarequalto a more precise relation. Hereafter,
we discuss exactly how to perform such reﬁnement.
1) Identifying Distinguishing Contexts: If the problem
above is satisﬁable, that is, we ﬁnd an instance such that
Post 1.obs/negationslash=Post 2.obs, then we say that the context
obs(mod(z))is a distinguishing context , since it reveals a
part of the contract state that is not directly exposed by
the observers. For example, if in the ﬁrst stepo=is not
a congruence, from the results of the congruence check
we obtain a set of distinguishing contexts that are the
new basis to build the candidate behavioral congruence
b/similarequal. Every distinguishing context is then abstracted as a
new context abstraction as follows. Given a distinguishing
contextobs(mod(z)), the following ﬁelds are added to
State : (i) a ﬁeld of type State , calledmodreachable ;
(ii) a ﬁeld of type univ , calledobsmodabstr . Please
note that univ denotes the universal set. The ﬁrst ﬁeld
is a relation to another State which is bound to mod
postconditions; this bound is realized by adding adequate
facts, as illustrated in Example 1 above. Thus, the resulting
values ofobs’s return value and throw ﬁelds are then bound
toobsmodabstr : ifobs’s behavior is exceptional, then
s.obsmodabstr =s.modreachable.obs t, otherwise we
imposes.obsmodabstr =s.modreachable.obs r. With
this technique, we have added a new ﬁctitious observer
which corresponds to a part of the contract state which was
hidden. The new observer, called context abstraction , is then
used to reﬁne the candidate congruenceb/similarequal.
Example 2: Consider the context top(pop(z))for the
Stack contract; the corresponding context abstraction
is built by adding two ﬁelds, toppopabstr and
popreachable . Four new singleton signatures, Pre1pop,
Pre2pop,Post 1pop, andPost 2popmodel the state reached
withpop for the pre- and post-states. With an ap-
propriate fact, we impose the correct values for the
popreachable ﬁeld, that is: Pre1.popreachable =Pre1pop,noPre1pop.popreachable . Similar facts are
generated for Pre2andPre2pop. The following fact ex-
presses thepoppostcondition:
factpre1Reachable{alls:State|(s.size > 0⇒
s.popreachable.size =s.size−1)}. Similar facts impose
the frame condition for pop. Finally, we impose the value
fortoppopabstr with the following fact:
factpre1Reachable{alls:State|s.toppopabstr =
ifs.popreachable.top tinException then
s.popreachable.top telses.popreachable.top r}.
For each new context abstraction added, the congruence
check is repeated. In this case, the only difference is that
it might happen that a new distinguishing context is found
from a modiﬁer and an introduced context abstraction. For
example, considering the Stack contract,toppopabstr
after apopis a new distinguishing context, because a further
popmight expose another part of the state which was hidden.
If the modiﬁer is shared between the new distinguishing
context and the context abstraction, then it is very likely that
there actually exists a sequence of distinguishing contexts,
that is, an iterated context of the form obs(mod+(z)), that
we treat as a particular case. In the case of Stack , an iterated
context istop(pop+(z)).
2) Iterated Context Abstraction: Iterated contexts corre-
spond to unbounded but ﬁnite sequences of modiﬁer applica-
tions ending with an observer. The corresponding abstraction
we would like to build is the sequence of possible return
and throw values: in other words, the context abstraction
for an iterated context is a sequence of values. Within a
small scope, the possible length of a sequence is bounded,
and thus the iterated context will have a maximum bound
of the number of modiﬁer applications. Consider an iterated
contextobs(mod+(z)). The iterated context abstraction is
built by introducing the following ﬁelds to State :
(i)obsmoditstep, of type int;
(ii)obsmoditreachable , of typeState , representing
the state after the application of mod ;
(iii)obsmoditabstr , of type seq univ , representing
the iterated context abstraction.
The difference is that the number of reachable states, in
this case, is bound to the maximum length of sequences as
speciﬁed in the small scope. We impose mod postconditions
for all the reachable states, and we impose that for the
last state there is no reachable further state. The step ﬁeld
starts from−1and it is incremented in every reachable
state; it is used then to bind the observer return and throw
values to the right element in the iterated context abstraction
sequence. In fact, the ﬁrst state obtained by traversing the
obsmoditreachable will have step equal to 0, and with
a proper predicate we can bind obsmoditabstr [0]to the
values ofobsin the reachable state. The following fact builds
the iterated context abstraction:
alls, r :State|rins.∗obsmoditreachable⇒941s.obsmoditabstr [r.step ] =ifr.obstinException
thenr.obstelser.obsr.
The above fact takes, for a given state s, every state
rwhich is reachable by a sequence of mod applications,
that is, a state rwhich belongs to the reﬂexive transitive
closure of the obsmoditreachable relation. Thus, it
imposes that the value of the iterative context abstraction
at positionr.step is equal to the value of obsreturn value
(or thrown exception). In most cases of data abstractions, the
iterated context abstraction is sufﬁcient to build an adequate
behavioral congruenceb/similarequal. In the case of Stack , the iterative
context abstraction built from top(pop+(z))corresponds to a
sequence of values that can be extracted with popoperations
ending with top. If the sequence is greater or equal to
the maximum length of elems in the contract, then this
abstraction is a behavioral congruence.
C.BEMConstruction
Once we have built the behavioral equivalence relationb≡
by performing analysis within a small scope, the relation
can be used to build a B EM. A B EMis essentially a ﬁnite
state machine where each transition is labeled with modiﬁer
invocations, each state is identiﬁed by observer return values
and the context abstractions built in the previous steps,
and the constructor determines the initial state. The model
is ﬁnite state because we constrain the speciﬁcation in a
limited scope. The scope of a B EMis deﬁned by ﬁxing
a ﬁnite set of values for method parameters, that is, by
deﬁning the so-called instance pools to deﬁne every possible
object belonging to the visible data types. The other scope
limitation is determined by limiting the maximum number
of states of the B EM. Considering the B EMin Figure 2,
the scope is deﬁned by using the strings “a” and“b” as
two possible Object values. The limitation on the possible
number of states is implicitly deﬁned by the ﬁnite scope of
the relational analysis, as in A LLOY . In fact, by deﬁning a
maximum length of sequences and possible elements in sets,
the possible number of states will be ﬁnite.
Starting from the constructor, we can compute the unique
state of the B EMby identifying it with the value of ob-
server and context abstractions. In fact, the values of the
abstractions correspond to a single state in the B EMwhich
represents classes of behaviorally equivalent states. The
construction algorithm computes the value of the abstraction
assuming that the invariant and the postcondition of the
constructor hold. Thus, it takes a generic state and imposes
the value of abstraction as obtained by the constructor
postcondition. For each modiﬁer, it considers the reached
state by imposing its postcondition, and retrieves the new
abstraction; in this way, it is possible to add transitions to
the B EM. Since the scope is ﬁnite, the algorithm terminates
with a B EMwhich precisely describe the behavior of the
data abstraction in the speciﬁed small scope.IV. B EMVALIDATION
In this section, we provide a brief and intuitive description
of the foundations of the validation approach we proposed
in [7]. The aim of that method is to validate an algebraic
speciﬁcation against a B EM. In the context of this paper, it
can be used to validate a contract against a behavioral prop-
erty expressed as an algebraic axiom through the synthesized
behavior model. The foundations of the validation approach
rely on a consideration we discussed in [7], that is, the fact
that a B EMis apartial algebra of a hidden signature Σ∆,h.
By interpreting a B EMas an algebra of a hidden signature
Σ∆,h, we have a formal framework to compare it against
an axiom of an algebraic speciﬁcation deﬁned over the
same signature. Intuitively, axioms become properties of the
transition function of the B EM. Consider the simple B EM
on Figure 2, and consider a simpliﬁed version of axiom A1,
that is,∀s∈Stack,e∈Object|popM(push M(s,e)) =s,
that does not take into account the fact that the stack is
bounded. As in the B EM, the set{“a”,“b”}is the instance
pool for the push method. With such instance pools and
the given interpretation, the axiom becomes: ∀s∈Q,e∈
IP(push ) :δ(δ(s,push (e)),pop()) =s, whereIPis a
function mapping an operation to its instance pool in the
BEM,δis the transition function of the B EMandQis its
set of states. Since IP(push )is ﬁnite, the axiom can be
instantiated for every visible sort:
∀s∈Q,δ(δ(s,push (“a”)),pop()) =s∧
δ(δ(s,push (“b”)),pop()) =s
The only quantiﬁed values in this case can be elements
of the speciﬁed sort, that is, states of the B EM; thus, the
axiom can be easily checked by considering every possible
state of the B EM. However, since the B EMis ﬁnite, the
transition function δmight be partial, and thus most of the
axioms could have counterexamples just because the model
is ﬁnite. Instead, we would like to verify that in all the cases
on whichδis deﬁned, the axioms hold. For example, the
axiom above cannot hold in any ﬁnite B EMof S TACK , since
there does not exist a ﬁnite B EMwhere thepush operation
is deﬁned in every state. Thus, our problem reduces to
verifying the axioms in all the valuations of the variables for
which the transition function δis deﬁned, and we consider
the axiom holding precisely in these cases. Further details
on the problem of validity and how this is checked can be
found in [7], where we show how the problem of checking
algebraic axioms within the B EMcan be reduced to a model
checking problem.
V. D ISCUSSION AND RELATED WORK
The work presented in this paper describes a model
synthesis technique that can be used to automatically val-
idate contracts of stateful components. Such artifacts are
usually hard to validate because the number of states of942@SpecField (elems :seq Object , wp:int, rp:int)
@Invariant (this.rp≥0∧this.rp < #this.elems∧this.wp≥0∧this.wp < #this.elems∧#this.elems > 3)
public class CBuffer
@Requires (len > 3) @Ensures (#this.elems =len∧this.rp =len−1∧this.wp = 0)@ Throws (Exception :len≤3)
public CBuffer (intlen);
@Requires (this.wp < this.rp −1∨(this.wp = #this.elems−1∧this.rp > 0)∨(this.wp < #this.elems−1∧this.rp < this.wp ))
@Ensures (this.wp = (@old(this.wp ) + 1)%# this.elems )∧(this.elems = @old(this.elems ) + +@ old(this.wp )→i)
@Modiﬁes (this.elems, this.wp )
public void write (Object i);
@Requires ((this.rp < this.wp −1)∨(this.rp = #this.elems−1∧this.wp > 0)∨(this.rp < #this.elems−1∧this.wp < this.rp ))
@Ensures (this.rp = (@old(this.rp ) + 1)%# this.elems ) @Return (this.elems [(@old(this.rp ) + 1)%# this.elems ]) @Modiﬁes (this.rp )
public Object read();
@Requires (true) @Returns (this.len )
public int len();
Figure 4. A JF ORGE contract for a Circular Buffer
such component is, in general case, inﬁnite. The typical
solution of this problem is to derive a ﬁnite state model that
enables the validation. In principle, there are two mainstream
approaches to derive such models:
Analysis of a Sound Abstraction: a sound abstraction in-
cludes all the possible behaviors of the artifact to be
analyzed, but it may also include spurious behaviors
introduced by the ﬁnite state abstraction;
Small Scope Analysis: under the small scope hypothesis,
one can reduce the possible states to analyze and derive
– within the given scope – a model that precisely
represents the artifact’s behavior.
Both the approaches have their own advantages and
disadvantages, and they are based on two different assump-
tions. For example, the C ONTRACTOR approach presented
in [14] derives a sound abstraction for contracts expressed
in ﬁrst-order logic. The implicit assumption in this case is
that the spurious behaviors introduced by the abstraction
technique (and the incompleteness of the supported logic)
do not invalidate the property to be checked. If a given
property is validated, C ONTRACTOR ensures that the artifact
exhibits that property. Instead, if a counterexample is found,
inspection is needed to check if the counterexample is really
part of the artifact behavior or it is caused by the abstraction
mechanism. Counterexample-based abstraction and reﬁne-
ment ( CEGAR )[15] approaches provide a technique to reﬁne
the abstraction in case of property violation. Abstractions
can be used for many validation activities, such as testing.
Such use of abstractions is for example discussed in [16];
instead of using enabledness, the authors use boolean queries
that split the contract state space. A similar approach used
for testing is presented in [17]; in this case, the state space
is abstracted by considering a partitioning derived from
predicates on observer return values, and transitions are built
through dynamic analysis by using an initial test suite, so
the ﬁnite state extracted machine is not a sound abstraction.
The small scope analysis approach takes a different stand
point [9]. The hypothesis upon which it is based states that
most bugs have small counterexamples ; that is, if the artifact
violates a given property, this is very likely to be found
within a small scope. Thus, an exhaustive analysis can focuspushpush
poppoppushpush, pop
poppush
pop
Figure 5. A F SCA for the Stack contract
on a small scope and if no counterexample is found it is very
unlikely that the artifact violates the property. In this case,
if the property is not violated we have only gained some
conﬁdence that the property holds, but if the counterexample
is found we are sure that indeed the artifact is ﬂawed. Our
approach focuses on this kind of analysis.
An important kind of small scope analysis of contract
based artifacts can be performed by using D YNALLOY [18].
However, it cannot be used to verify that a contract exhibits
complex properties as method interactions speciﬁable with
algebraic axioms with the hidden semantics. As far as we
know, our approach is the ﬁrst towards this direction. A
related ﬁnite scope analysis of requirement artifact contracts
has been presented in [19], mainly used for simulation of
operational models of requirements. However, the analysis is
not exhaustive, so it is not properly a small scope analysis as
deﬁned in [9]. Several methods involve the use of contracts
for testing; between the ones leveraging the small scope
hypothesis, the T ESTERA[20] approach uses A LLOY as a
language to specify test correctness properties.
In the end, we identify C ONTRACTOR [14] as the most
similar approach and as a source of contract examples that
can be used to assess the validity of our technique.
CONTRACTOR synthesizes ﬁnite state contract abstrac-
tions (F SCAs) using an SMT solver. The abstraction pro-
vided by this approach collapses contract states into abstract
states when the same set of operations are enabled; that is,
their preconditions are satisﬁable. Instead, transitions model
how the enabled operations change after the postcondition of
the transition is guaranteed. Figure 5 shows the abstraction
produced by the approach in the case of the stack contract.
The abstraction approach is conservative (i.e., it is guar-
anteed to include all the possible behaviors of the contract),943CBuffer
write()/squigglerightException
read()/squigglerightException
len()=5
CBuffer(5)read()
CBuffer
read()=a
len()=5CBuffer
read()=b
len()=5
CBuffer
read()=a
len()=5CBuffer
read()=a
len()=5CBuffer
read()=b
len()=5
CBuffer
read()=b
len()=5write(a)
write(a)
read()write(b)write(b)
write(a)write(b)read()
read()
read()read()read()
Figure 6. A B EMof CBuffer. Quote marks are omitted from String literals.
but the extracted models describe also many other possible
behaviors that actually are not described by the contract.
For example, the F SCA for the stack contract – as shown
in Figure 5 – cannot be used to validate Axiom (A1). This
is mainly due to the fact that models are built for manual
validation, thus their conciseness and relative simplicity are
fundamental for manual tractability. From this abstraction,
it is possible to check simple behavioral properties, such as
the fact that the container can be full, but no hint is given
about the precise LIFO behavior of push andpop. While
being conservative, F SCAs lack the necessary precision to
validate contracts against algebraic axioms.
Given the considerations above, we view C ONTRACTOR
as a complementary rather than competitive approach, since
the kind of analysis (sound abstraction vs. small scope), its
assumptions, and the use of models (manual vs. automatic
validation) are completely different.
VI. M ETHODOLOGY ASSESSMENT
In this section, we provide an assessment of the proposed
validation methodology. We explicitly refer to the same
set of examples used in [14] and we show what kind of
additional validation can be performed with B EMs.
To illustrate the practical use of the approach and validate
it, we introduce two signiﬁcant examples: a data abstraction,
the circular buffer (Section VI-A), and a contract specifying
a requirement artifact, an ATM Model taken from [21]
(Section VI-B). The two examples are also used in [14];
for space reasons, we cannot add further examples in this
paper. Additional material and experiments can be found in
the project’s web page [22].
A. Circular Buffer
A relatively complex example, taken from [14], is given
in Figure 4. In this case the contract, which speciﬁes a
circular buffer, is close to a concrete implementation ofwritewrite
readreadwritewrite
readread, writewrite, read
read
Figure 7. A F SCA for CBuffer.
the data abstraction (in fact, even the name refers more to
the implementation technique, a circular buffer, than to the
data abstraction it represents). This example has been used
as a motivating example to show the need of abstractions
from contracts in [14]. In this case, it would be reasonable
to validate the complex speciﬁcation against the expected
FIFO behavior it should have; in fact, the circular buffer
is essentially a limited-size queue. In other words, this
behavioral property can be represented by this axiom:
∀b:CBuffer,e :int|read M(write M(b,e)) = (A2)
ifb=CBuffer (lenO(b))thenb
else ifwrite O(b,e)/negationslash/squigglerightException
thenwrite M(read M(b),e)elseread M(b)
Figure 6 shows a B EMthat can be synthesized with our
approach by selecting a length of 5for the circular buffer and
{“a”,“b”}as contained elements. This conﬁguration is the
minimal one that shows F IFObehavior, because (i) read()
always returns the ﬁrst element inserted by a write , and
(ii) transitions labeled with read() show a behavior coherent
with Axiom (A2), in particular by considering the two states
of size 2on the lower part of the B EM.
A further kind of validation is possible by comparing the
FSCA with the B EMfor the data abstraction. While the F IFO
behavior is not veriﬁable with the F SCA, the F SCA admits
some unusual behavior that is not present in the B EM, and
that corresponds to a wrong speciﬁcation of the invariant in
theCBuffer contract as shown in Figure 4. In fact, by
inspecting the F SCA on Figure 7, the contract abstraction
admits the possibility that after a successful read operation,
the data abstraction reaches a state where it is not possible to
invoke write . In principle, with the only inspection of F SCA,
it is possible to manually identify this issue, not to derive
any possible likely cause. Instead, by comparing the F SCA
with the B EM, it is possible to automatically ﬁnd that the
behavior described above is not present in the B EM.
This absence could be due to two factors: either the scope
of the B EMis not sufﬁcient to show the issue, or — since
the scope is signiﬁcant assuming the small scope hypothesis
— the wrong behavior is not reachable, that is, there does
not exist any sequence of operations in the data abstraction
that exhibits the wrong behavior. In fact, the wrong behavior
shown by the F SCA is due to a relaxed invariant, which
does not include the condition wp/negationslash=rp. However, given the944State
canceledMsg ()
dispMainScr ()
ejCard ()
enterPwd (¯p)
insCard (¯c)
reqPwd ()
reqTakeCard ()
takeCard ()
S1 =f =t/squigglerightE — — =t=f/squigglerightE
S2 =f =t/squigglerightE/squigglerightE — =f =f/squigglerightE
S3 =t=f —/squigglerightE/squigglerightE =f =f/squigglerightE
S4 =f =f/squigglerightE/squigglerightE — =f =f —
S5 =t=f —/squigglerightE/squigglerightE =f =t —
S6 =t=f — —/squigglerightE =t=f/squigglerightE
S7 =f =f/squigglerightE — — =t =t —
S8 =t=f — —/squigglerightE =t =t —
(a) State LabelingS1
Atm()S2
S6S3S4
S7 S8S5
insCard(¯c)insCard(¯c)insCard (¯c)ejCard ()
insCard (¯c)ejCard ()enterPwd (¯p)
enterPwd (¯p)
enterPwd (¯p)
enterPwd (¯p) ejCard()
ejCard()
takeCard ()takeCard ()takeCard ()takeCard ()
(b) Transition Function
Figure 8. A B EMof the A TMModel. t, fdenote true andfalse constants, while Edenotes Exception .
initial state prescribed by the constructor and any possible
sequence of operations as speciﬁed by the contracts of read
andwrite , this situation cannot be reached.
B. ATM Model
As a second example, we consider the validation of
a requirement engineering artifact speciﬁed by a contract
based on pre-, post-conditions and invariants. The example
is taken from [21], and it discusses the protocol of a single-
user interaction with an automatic teller machine (A TM). For
space reasons, we cannot include the whole contract; the
reader can ﬁnd it in [22]. Figure 8 shows the B EMfor the
ATMmodel. The model describes single-user interaction, so
there is no interest in using instance pools for insCard and
enterPwd operations with size greater than 1, since all the
operations would be independent of the parameter values.
Complex properties can be correctly veriﬁed in the B EM;
for example, it is possible to invoke some pair of operations
in any order:
∀a:Atm,c :Card,p :Pwd|
insCard M(enterPwd M(a,p),c) =
ifenterPwd O(a,p)/negationslash/squigglerightException
thenenterPwd M(insCard M(a,c),p)
∀a:Atm,p :Pwd|ejCard M(enterPwd M(a,p)) =
ifenterPwd O(a,p)/negationslash/squigglerightException
thenenterPwd M(ejCard M(a),p)
Another important axiom, that is not veriﬁed in the B EM,
prescribes the fact that from every state, if it is possible to
take the card, this action resets the A TMto the initial state:
∀a:Atm|takeCard M(a) = (A3)
iftakeCard O(a)/negationslash=Exception thenAtm()
As in [14], we can identify that there are two possible states
reached from a takeCard operation; this is due to a wrong
post-condition of takeCard , which does not reset the value
of a contract ﬁeld, passwordGiven , that models the fact that
the client has previously entered the password. A hint onthis problem can be for example obtained by checking a
property involving the reqPwd observer, which models the
fact that the A TMis requesting the password:
∀a:Atm|reqPwd O(takeCard M(a)) =true (A4)
Since the axiom above is falsiﬁed, because reqPwd (S2) =
false , one could inspect the post-condition of reqPwd :
@Requires (true ) @Returns (passwordGiven =false )
@Pure public boolean reqPwd ();
This inspection together with A4 is an hint on a problem
with the update of the passwordGiven contract variable.
VII. C ONCLUSIONS AND FUTURE WORK
In this paper, we presented a small scope static analysis
of contracts that produces operational models based on the
concept of behavioral equivalence. The technique enables
the validation of complex properties about method interac-
tions that can be expressed as algebraic axioms.
The approach has been evaluated on a set of pre- and post-
condition based contracts, describing relatively complex data
abstractions and requirement artifacts. We illustrated how
model synthesis can be used to enable automatic check of
behavioral properties. In this paper, we contrasted the kind
of models extracted with a small scope analysis with the
ones built via a sound abstraction as a F SCA. We believe
that integrating these different kind of analysis can provide
more insightful results that can be used for both manual and
automatic validation; this integration is left as a future work.
We also illustrated how it is possible to manually identify
in the contract which is the cause of a property violation
expressed through a counterexample. Another useful impor-
tant future work involves the automatic or semi-automatic
identiﬁcation of these causes, for example by exploiting
unsatisﬁability cores.
ACKNOWLEDGMENTS
This research has been partially funded by the European
Commission, Programme IDEAS-ERC, Project 227977-
SMScom.945REFERENCES
[1] B. Liskov, “OOPSLA keynote: Turing Award Lecture
(reprise), The power of Abstraction,” in OOPSLA ’09 . New
York, NY , USA: ACM, 2009.
[2] J. V . Guttag and B. Liskov, Program Development in
Java: Abstraction, Speciﬁcation and Object-Oriented Design .
Addison-Wesley, 2001.
[3] G. T. Leavens, A. L. Baker, and C. Ruby, “JML: A no-
tation for detailed design,” in Behavioral Speciﬁcations of
Businesses and Systems . Kluwer, 1999, pp. 175–188.
[4] K. Yessenov, “A light-weight speciﬁcation language for
bounded program veriﬁcation,” Master’s thesis, MIT, May
2009, advised by Daniel Jackson.
[5] G. Dennis, “A relational framework for bounded program ver-
iﬁcation,” Ph.D. dissertation, MIT, 2009, advised by Daniel
Jackson.
[6] J. Goguen and G. Malcolm, “A hidden agenda,” Theoretical
Computer Science , vol. 245, no. 1, pp. 55 – 101, 2000.
[Online]. Available: http://www.sciencedirect.com/science/
article/pii/S0304397599002753
[7] C. Ghezzi, A. Mocci, and G. Salvaneschi, “Automatic
cross validation of multiple speciﬁcations: A case study,”
inFundamental Approaches to Software Engineering ,
ser. Lecture Notes in Computer Science, D. Rosenblum
and G. Taentzer, Eds., vol. 6013. Springer Berlin
/ Heidelberg, 2010, pp. 233–247. [Online]. Available:
http://dx.doi.org/10.1007/978-3-642-12029-9 17
[8] C. Ghezzi, A. Mocci, and M. Monga, “Synthesizing
intensional behavior models by graph transformation,” in
Proceedings of the 31st International Conference on Software
Engineering , ser. ICSE ’09. Washington, DC, USA: IEEE
Computer Society, 2009, pp. 430–440. [Online]. Available:
http://dx.doi.org/10.1109/ICSE.2009.5070542
[9] D. Jackson, Software Abstractions:Logic,Language,and Anal-
ysis. MIT Press, 2012.
[10] B. Meyer, “Design by Contract: The Eiffel Method.” in
Int. Conf. on Technology of Object-Oriented Languages and
Systems , 1998.
[11] D. Sannella and A. Tarlecki, Foundations of Algebraic Spec-
iﬁcation and Formal Software Development , ser. EATCS
Monographs on theoretical computer science. Springer,
2012.
[12] S. R. Buss and G. Rosu, “Incompleteness of behavioral
logics,” Electronic Notes in Theoretical Computer
Science , vol. 33, no. 0, pp. 61 – 79, 2000.
[Online]. Available: http://www.sciencedirect.com/science/
article/pii/S157106610580756X[13] A. Milicevic, D. Rayside, K. Yessenov, and D. Jackson,
“Unifying execution of imperative and declarative code,”
inProceedings of the 33rd International Conference on
Software Engineering , ser. ICSE ’11. New York, NY ,
USA: ACM, 2011, pp. 511–520. [Online]. Available:
http://doi.acm.org/10.1145/1985793.1985863
[14] G. de Caso, V . Braberman, D. Garbervetsky, and S. Uchitel,
“Automated abstractions for contract validation,” Software
Engineering, IEEE Transactions on , vol. 38, no. 1, pp. 141
–162, jan.-feb. 2012.
[15] E. Clarke, O. Grumberg, S. Jha, Y . Lu, and H. Veith,
“Counterexample-guided abstraction reﬁnement for symbolic
model checking,” J. ACM , vol. 50, pp. 752–794, September
2003. [Online]. Available: http://doi.acm.org/10.1145/876638.
876643
[16] L. L. Liu, B. Meyer, and B. Schoeller, “Using contracts
and boolean queries to improve the quality of automatic test
generation,” in Proceedings of the 1st international confer-
ence on Tests and proofs , ser. TAP’07. Berlin, Heidelberg:
Springer-Verlag, 2007, pp. 114–130. [Online]. Available:
http://portal.acm.org/citation.cfm?id=1776119.1776126
[17] T. Xie, E. Martin, and H. Yuan, “Automatic extraction
of abstract-object-state machines from unit-test executions,”
inProceedings of the 28th international conference on
Software engineering , ser. ICSE ’06. New York, NY ,
USA: ACM, 2006, pp. 835–838. [Online]. Available:
http://doi.acm.org/10.1145/1134285.1134427
[18] M. F. Frias, J. P. Galeotti, C. G. L ´opez Pombo, and
N. M. Aguirre, “Dynalloy: upgrading alloy with actions,”
inProceedings of the 27th international conference on
Software engineering , ser. ICSE ’05. New York, NY ,
USA: ACM, 2005, pp. 442–451. [Online]. Available:
http://doi.acm.org/10.1145/1062455.1062535
[19] H. T. Van, A. v. Lamsweerde, P. Massonet, and C. Ponsard,
“Goal-oriented requirements animation,” in Proceedings
of the Requirements Engineering Conference, 12th IEEE
International . Washington, DC, USA: IEEE Computer
Society, 2004, pp. 218–228. [Online]. Available: http:
//portal.acm.org/citation.cfm?id=1018443.1022109
[20] D. Marinov and S. Khurshid, “Testera: a novel framework
for automated testing of java programs,” in Proceedings of
the 16th International Conference on Automated Software
Engineering, 2001 (ASE 2001) , nov. 2001, pp. 22 – 31.
[21] J. Whittle and J. Schumann, “Generating statechart designs
from scenarios,” in Proceedings of the 22nd international
conference on Software engineering , ser. ICSE ’00. New
York, NY , USA: ACM, 2000, pp. 314–323. [Online].
Available: http://doi.acm.org/10.1145/337180.337217
[22] “Spy Contract Website,” http://people.csail.mit.edu/am/spy-
jfsl/, 2011.946