A Program Differencing Algorithm for Verilog HDL
Adam Duley
Intel Corporation
Austin, TX 78746 USA
adam.r.duley@intel.comChris Spandikow
IBM Corporation
Austin, TX 78758 USA
spandiko@us.ibm.comMiryung Kim
The University of Texas at
Austin
Austin, TX 78712 USA
miryung@ece.utexas.edu
ABSTRACT
During code review tasks, comparing two versions of a hard-
ware design description using existing program diﬀerenc-
ing tools such as diﬀis inherently limited because exist-
ing program diﬀerencing tools implicitly assume sequential
execution semantics, while hardware description languages
are designed to model concurrent computation. We de-
signed a position-independent diﬀerencing algorithm to ro-
bustly handle language constructs whose relative orderings
do not matter. This paper presents Vdiﬀ , an instantiation
of this position-independent diﬀerencing algorithm for Ver-
ilog HDL. To help programmers reason about the diﬀerences
at a high-level, Vdiﬀ outputs syntactic diﬀerences in terms
of Verilog-speciﬁc change types. We evaluated Vdiﬀ on two
open source hardware design projects. The evaluation re-
sult shows that Vdiﬀ is very accurate, with overall 96.8%
precision and 97.3% recall when using manually classiﬁed
diﬀerences as a basis of comparison.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance,
and Enhancement— restructuring, reverse engineering, and
reengineering
General Terms
Algorithms, Measurement, Experimentation
Keywords
Program diﬀerencing, change types, empirical study, hard-
ware description languages, Verilog
1. INTRODUCTION
Hardware description languages (HDLs) are pervasively
used by engineers to abstractly deﬁne hardware circuitry.
Verilog, one of the most widely used HDLs, uses a C-like syn-
tax to describe massively concurrent tasks—Verilog state-
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ... $5.00.ments can represent parallel execution threads, propaga-
tion of signals, and variable dependency [28]. Hardware
projects are in a constant state of change during the de-
velopment process due to new feature requests, bug ﬁxes,
and demands to meet power reduction and performance re-
quirements. During code review tasks, hardware engineers
predominantly rely on diﬀwhich computes line-level diﬀer-
ences per ﬁle based on a textual representation of a program.
Using existing program diﬀerencing tools for Verilog pro-
grams has several limitations. First, line-based diﬀerencing
tools for Verilog programs report many false positive diﬀer-
ences because the longest common sequence algorithm [16]
maps code in order and thus is too sensitive for languages
that model concurrent computation. This is not only the
problem with line-based diﬀerencing tools; abstract syntax
tree-based diﬀerencing algorithms such as Cdiﬀ [32] often
match nodes in the same level in order, making it unsuit-
able for programming languages where concurrent execution
is common. Second, unlike Java methods or C functions,
processes such as always blocks (i.e., event handlers) do not
have unique labels. Thus, existing diﬀerencing algorithms
such as UMLdiﬀ [31] cannot accurately handle position-
independent language constructs, when they do not have
unique labels that produce one-to-one matching based on
name similarity. Third, while Verilog programs frequently
use Boolean expressions to deﬁne circuitry, existing algo-
rithms do not perform equivalence between these Boolean
expressions, despite the availability of a mature technology
to solve a Boolean formula satisﬁability problem.
To overcome these limitations, we have developed Vdiﬀ
that uses an intimate knowledge of Verilog syntax and se-
mantics. Our diﬀerencing algorithm takes two versions of
a Verilog design ﬁle and ﬁrst extracts abstract syntax trees
(ASTs). Traversing the trees top-down, at each level, it uses
the longest common sequence algorithm to align nodes by
the same label and uses a weighted bipartite graph match-
ing algorithm to ﬁnd out-of-order matching between simi-
lar subtrees to handle position-independent language con-
structs. To complement syntactic diﬀerencing, we use an
oﬀ-the-shelf SAT solver to compare two Boolean expressions
in the process interface description (i.e., the sensitivity list of
Verilog’s always block). Furthermore, to help programmers
better understand AST matching results, it outputs diﬀer-
ences in terms of Verilog-speciﬁc change types (see Section
4.2 for a detail description on change-types). Vdiﬀ is instan-
tiated as an Eclipse plug-in and available for download.1
We applied Vdiﬀ to two open source project histories and
1http://users.ece.utexas.edu/˜miryung/software/Vdiﬀ.htmlcompared its accuracy with manually labeled diﬀerences.
We also compared our algorithm with three existing AST
matching algorithms, measured the types of changes com-
mon in Verilog, and assessed the impact of using similar-
ity thresholds in matching AST nodes. In summary, Vdiﬀ
makes the following contributions:
•Vdiﬀ uses a position-independent diﬀerencing algorithm
to robustly handle language constructs whose relative
orderings do not matter such as statements with con-
current execution semantics.
•Vdiﬀ produces accurate diﬀerencing results with 96.8%
precision and 97.3% recall when using manually clas-
siﬁed diﬀerences as a basis of evaluation.
•Vdiﬀ outputs syntactic diﬀerencing results in terms
of Verilog-speciﬁc change types to help programmers
better understand the diﬀerences.
Vdiﬀ has several implications for the software engineering
research community. First, the hardware design industry is
facing challenges in evolving existing design artifacts, just
as the software industry is facing the problems of evolv-
ing software. Yet, support for evolving hardware designs
is very limited compared to evolving software. Our goal
is to develop a foundation for reasoning about diﬀerences
in hardware design descriptions to enable various hardware
evolution research, such as regression analysis of hardware
designs, change impact analysis, etc. Second, the algorithm
in Vdiﬀ could be applied to any language that provides
ordering-independent language constructs.
The rest of this paper is organized as follows. Section 2
presents a motivating example for Verilog-speciﬁc program
diﬀerencing. Section 3 discusses related work. Section 4
presents our algorithm and Section 5 describes our evalua-
tion methods and results. Section 6 discusses Vdiﬀ’s limi-
tations and threats to validity. Section 7 concludes with a
discussion of future work.
2. MOTIVATING EXAMPLE
Verilog is a hardware description language, in which state-
ments and structures map directly to hardware circuitry and
its behavior. Because gates operate concurrently [15], Ver-
ilog models concurrency explicitly by providing language
constructs such as always blocks, continuous assignments
(assign ), or non-blocking assignments ( <=).
To illustrate the key features of Verilog, Figure 1 provides
a simple example extracted from the uart rﬁfo.v ﬁle in the
OpenCores Uart 16550 project. This code is a simple im-
plementation of a FIFO queue in Verilog. The key items to
note in this example are the module, the always blocks, the
continuous assignments ( assign ), and the non-blocking as-
signments. The module uart rfifo() ’sinput and output
declarations deﬁne which inputs are required for the module
and which output signals it produces. Registers and wires
(regand wire) can be considered to be ﬁeld declarations in
the module.
Functional speciﬁcations can be written either as an ini-
tialization block ( initial ), a procedure block ( always ), or
continuous assignments ( assign ). Always blocks are pro-
cess deﬁnitions that are re-evaluated when speciﬁed event
conditions become true. For example, always @(posedge
clk or posedge wb rsti)is evaluated when either the clkorwbrstisignal transitions from 0 to 1 due to posedge .
Verilog provides two diﬀerent types of assignments, = and
<=. The blocking assignment ( =) is similar to an assignment
statement in C with sequential execution semantics, while
the non-blocking assignment ( <=) denotes a non-blocking
operation that executes simultaneously. In Verilog, non-
blocking assignments are generally more common than block-
ing assignments. Thus, inside the ﬁrst always block, the
registers top,bottom , and count are all set to 0 simulta-
neously, unlike C. In other words, the order in which top,
bottom , and count are declared does not matter as long as
they are in the same control hierarchy. An ideal program dif-
ferencing tool for Verilog must not detect such reordering of
non-blocking statements, as it does not change the execution
semantics. Similarly, the order of the always blocks does
not matter because all always blocks are executed simul-
taneously. Likewise, all continuous assignments ( assign )
in a module operate concurrently. To draw an analogy be-
tween C-like languages and Verilog, one may claim that each
always block is treated like a function. This idea, however,
falls short since multiple blocks can be triggered by the same
event list, meaning that one cannot assume that each always
block has a unique label.
Figure 1 contrasts what a human would consider to be dif-
ferences and line-level diﬀerences computed by diﬀ: added
lines are marked in red text with +, and deleted lines are
marked in blue text with -. In this code example, the
always blocks are reordered, the two non-blocking state-
ments are reordered, and the arguments in the ﬁrst always
block’s sensitivity list are reordered. A human will recog-
nize that, despite textual diﬀerences, there are no semantic
diﬀerences between the two versions. However, diﬀwill re-
port several false positives: (1) addition and deletion of the
second always block, (2) additions and deletions of two non-
blocking assignments, and (3) addition and deletion of the
second always block’s sensitivity list. Furthermore, as diﬀ
cannot recognize Verilog syntax, it will report diﬀerences
that do not respect the boundaries of each always block.
The following list summarizes the unique characteristics
of Verilog from a program diﬀerencing perspective.
•Verilog models concurrent executions by using con-
structs such as non-blocking assignments, processes,
and continuous assignments. Thus, ordering-sensitive
diﬀerencing algorithms designed for sequential execu-
tion semantics will report many false positive diﬀer-
ences.
•In Verilog, processes do not necessarily have unique
labels, even though it is thought to be a bad practice
to use the same name for multiple processes. Thus,
diﬀerencing algorithms cannot rely on mapping code
elements solely based on name similarity.
•Frequent usage of Boolean expressions in Verilog pro-
vides an opportunity to leverage a SAT solver to com-
pare process interface descriptions (i.e., sensitivity lists).
3. RELATED WORK
Matching corresponding code elements between two pro-
gram versions is a fundamental building block for version
merging, regression testing selection and prioritization, and
proﬁle propagation. Existing diﬀerencing techniques often
match code elements at a particular granularity based on‘include "uart_defines.v"
module uart_rfifo (clk, wb_rst_i, data_in,
push, pop, data_out, overrun);
input clk;
output [fifo_width-1:0] data_out;
reg [fifo_counter_w-1:0] count;
wire [fifo_pointer_w-1:0] top_plus_1 = top + 1’b1;
...
always @(posedge clk or posedge wb_rst_i)
begin
top <= #1 0;
bottom <= #1 0;
count <= #1 0;
fifo[1] <= #1 0;
- fifo[2] <= #1 0;
...
end // always
- always @(posedge clk or posedge wb_rst_i)
- begin
- if (wb_rst_i)
- overrun <= #1 1’b0;
- else
- if (fifo_reset | reset_status)
- overrun <= #1 1’b0;
- else
- if(push & ~pop & (count==fifo_depth))
- overrun <= #1 1’b1;
- end // always
assign data_out = fifo[bottom];
endmodule‘include "uart_defines.v"
module uart_rfifo (clk, wb_rst_i, data_in,
push, pop, data_out, overrun);
input clk;
output [fifo_width-1:0] data_out;
reg [fifo_counter_w-1:0] count;
wire [fifo_pointer_w-1:0] top_plus_1 = top + 1’b1;
...
always @(posedge clk or posedge wb_rst_i)
+ begin
+ if (wb_rst_i)
+ overrun <= #1 1’b0;
+ else
+ if (fifo_reset | reset_status)
+ overrun <= #1 1’b0;
+ else
+ if(push & ~pop & (count==fifo_depth))
+ overrun <= #1 1’b1;
+ end // always
+ always @(posedge wb_rst_i or posedge clk)
begin
top <= #1 0;
bottom <= #1 0;
count <= #1 0;
+ fifo[2] <= #1 0;
fifo[1] <= #1 0;
...
end // always
assign data_out = fifo[bottom];
endmodule
Figure 1: Line-level diﬀresults and expected diﬀerences between two versions of a Verilog program
Figure 2: Vdiﬀ’s output in Eclipse IDEcloseness in name and structure, such as: (1) lines and to-
kens [16, 23, 10], (2) abstract syntax tree nodes [12, 14, 19,
22, 32], (3) control ﬂow graph nodes [8], etc. In the con-
text of hardware development with HDLs, the state-of-the-
practice in comparing two versions of Verilog program is to
use GNU diﬀ[18] or a graphic front end to diﬀ, which pro-
vides a side-by-side visualization that highlights deleted or
added lines with diﬀerent colors and provides navigation ca-
pability to review particular diﬀerences [1]. These line-based
diﬀerencing tools use the longest common subsequence al-
gorithm that aligns program lines in sequence [16].
For software version merging, Yang [32] developed an AST
diﬀerencing algorithm. Given a pair of functions ( fT, fR),
the algorithm creates two abstract syntax trees TandRand
attempts to match the two tree roots. Once the two roots
match, the algorithm aligns T’s subtrees t1, t2, ..., t iandR’s
subtrees r1, r2, ...r jusing the LCS algorithm and maps sub-
trees recursively. This type of tree matching respects the
parent-child relationship as well as the order between sib-
ling nodes, but is very sensitive to changes in nested blocks
and control structures because tree roots must be matched
for every level. For dynamic software updating, Neamtiu
et al. [19] built an AST-based algorithm that tracks sim-
ple changes to variables, types, and functions. Neamtiu’s
algorithm assumes that function names are relatively sta-
ble over time. It traverses two ASTs in parallel, matches
the ASTs of functions with the same name, and incremen-
tally adds one-to-one mappings, as long as the ASTs have
the same shape. In contrast to Yang’s algorithm, it can-
not compare structurally diﬀerent ASTs. Cottrell et al.’s
Breakaway [12] automatically identiﬁes detailed structural
correspondences between two abstract syntax trees to help
programmers generalize two pieces of similar code. Its two-
pass greedy algorithm is applied to ordered child list prop-
erties (e.g., statements in a block), and then to unordered
nodes (e.g., method declarations).
Change Distiller [14] takes two abstract syntax trees as
input and computes basic tree edit operations such as in-
sert, delete, move orupdate of tree nodes. It uses bi-gram
string similarity to match source code statements such as
method invocations, and subtree similarity to match source
code structures such as if-statements. After identifying tree
edit operations, Change Distiller maps each tree-edit to an
atomic AST-level change-type such as parameter ordering
change . Vdiﬀ uses an approach similar to Change Distiller,
in that we identify similar subtrees by computing similarity
measures and ﬁnd the best matching among similar sub-
trees by selecting matches with the highest similarity one
at a time. In addition, we also report AST-level matching
results in terms of Verilog speciﬁc change-types. Ragha-
van et al.’s Dex [22] compares two ordered ASTs using both
top-down matching and bottom-up matching. This algo-
rithm gives preferences to AST node matches in the same
level that do not results in moving or reordering nodes. Dex
deﬁnes edit cost using ﬁxed numbers instead of similarity
between AST node labels.
The main diﬀerence between our AST comparison algo-
rithm and existing AST matching algorithms is that our al-
gorithm identiﬁes syntactic diﬀerences robustly, even when
multiple AST nodes have similar labels and when they are
reordered.
In addition to these, several diﬀerencing algorithms com-
pare model elements [31, 20, 26]. For example, UMLdiﬀ [31]matches methods and classes between two program versions
based on their name. However, these techniques assume
that no code elements share the same name in a program
and thus use name similarity to produce one-to-one code
element matches. Our algorithm diﬀers from these by not
relying on one-to-one matching based on name similarity.
As diﬀerent language semantics lead to diﬀerent program
diﬀerencing requirements, some have developed a general,
meta-model based, conﬁgurable program diﬀerencing frame-
work [25, 3]. For example, SiDiﬀ [25, 29] allows tool de-
velopers to conﬁgure various matching algorithms such as
identity-based matching, structure-based matching, and signature-
based matching by deﬁning how diﬀerent types of elements
need to be compared and by deﬁning the weights for com-
puting an overall similarity measure.
Sudakrishnan et al. [27] studied the types of bugs that
occur in Verilog and compared those ﬁndings to a similar
study in Java. They presented a categorization of change-
types that caused bugs and how often they occurred, and
found that the most common bug pattern was changes to
assignment statements and if-statements. In our work, we
extended Sudakrishnan’s change-types by adding 25 change-
types to comprehensively describe code changes in two open
source Verilog projects that we studied. While Sudakrish-
nan’s change-type analysis is largely manual, our program
diﬀerencing tool automatically identiﬁes change-type level
diﬀerences between two program versions.
4. APPROACH
Vdiﬀ accepts two versions of a Verilog design ﬁle and out-
puts syntactic diﬀerences in terms of Verilog-speciﬁc change
types. It uses a hybrid program diﬀerencing approach that
performs a syntactic comparison of two abstract syntax trees
while checking semantic equivalence in limited cases using an
oﬀ-the-shelf SAT solver. Section 4.1 discusses our abstract
syntax tree matching algorithm that accounts for concur-
rent execution semantics such as non-blocking assignments.
Section 4.2 presents Verilog-speciﬁc change types, which are
designed to help programmers better understand AST-level
matching results. This section also describes when and how
our algorithm performs a semantic comparison using a SAT
solver. Section 4.3 describes our Vdiﬀ Eclipse plug-in.
4.1 Position-Independent Abstract Syntax Tree
Differencing
Our algorithm shown in Algorithm 1 takes as input the
old and new versions of a Verilog module and two thresh-
olds used for determining text similarity. For each Verilog
module, it extracts an abstract syntax tree using the Ver-
ilog syntax parser module provided by the VEditor plug-
in [2]. Then it marks AST nodes that correspond to non-
blocking assignments, continuous assignments, and always
blocks. Marking these nodes allows for the matching algo-
rithm to carefully handle semantically equivalent reordering
of such nodes. The resulting abstract syntax tree allows
certain concurrent nodes to be arranged in any sequence
inside a module. Figure 3 shows an example AST, where
unordered children are marked with a dotted edge.
Once the trees, LandR, are built for each ﬁle, FoandFn,
they are compared hierarchically from the top down using
compareTrees() . The initial comparison is done by aligning
nodes in the same level by the same labels, using the longest
common subsequence algorithm [16]. Any unmatched nodeinRis added to ADD , and any unmatched node in Lis
added to DEL . The step is recursively applied to all children
of the matching nodes.
Algorithm 1 : Position-Independent AST Matching
Input :Fo,Fn/*old and new versions */
ths,thl/*similarity thresholds for short text and
long text */
Output :ADD /*a set of nodes added to Fn */
DEL /*a set of nodes deleted from F */
MAP /*a set of mapped node pairs */
L:=createAST (Fo),R:=createAST (Fn)
ADD :=∅,DEL :=∅,MAP :=∅,Candidate :=∅
compareTrees (L,R,MAP ,ADD ,DEL )
findCandidate (ADD ,DEL ,Candidate ,thl,ths)
repeat
/*Identify a weighted bipartite matching by
selecting a candidate match with the highest
likeness value and updating ADD and DEL
accordingly */
Candidate = sort( Candidate )
foreach p∈Candidate do
ifp.a∈ADD andp.d∈DEL then
MAP :=MAP ∪ {(p.a, p.d) }
compareTrees (p.a, p.d, M’, A’, D’)
ADD :=ADD -{p.a},DEL :=DEL -{p.d}
removeMatches( Candidate , p) /*remove
candidate matches that include p.aor
p.d */
end
ADD :=ADD ∪A’,DEL :=DEL ∪D’,MAP :=
MAP ∪M’
end
findCandidate (ADD ,DEL ,Candidate ,thl,ths)
until Candidate /negationslash=∅;
interpret (MAP ,ADD ,DEL )
Function compareTrees( L, R, M, D, A )
/*align Land R’s subtrees using the longest common
subsequence algorithm based on their labels */
MAP :=alignLCS (L’s ﬁrst level subtrees, R’s ﬁrst level
subtrees)
foreach l∈L’s ﬁrst-level subtrees do
ifl/∈MAP .Left then DEL :=DEL ∪ {l}
end
foreach r∈R’s ﬁrst-level subtrees do
ifr/∈MAP .Right then ADD :=ADD ∪ {r}
end
foreach (l,r) ∈MAP do
compareTree (l, r, MAP ,DEL ,ADD );
end
Once the initial ADD andDEL have been populated, the
algorithm then tries to match nodes from ADD andDEL
using a greedy version of a weighted bipartite graph match-
ing algorithm. First, for each pair in the Cartesian product
ofADD andDEL , we compute the pair’s weight using the
text similarity algorithm in UMLdiﬀ [31], which computes
how many common adjacent character pairs are contained
in two compared strings. The weight calculation is based on
the full content of the node’s subtree. For example, when
considering an always block node, the text of its block dec-
laration and its body is used. If the similarity value is above
a required threshold and the nodes are of the same syntactic
type, such as an always block mapping to an always block,
we add the pair to the set of potential matches, Candidate .Function findCandidate( A, D, Candidate, thl,ths)
foreach a∈ADD do
foreach d∈DEL do
likeness := textSimilarity (a,d)
if((a.text.length >128 or d.text.length >128) and
likeness > th l) or (a.text.length <128 and
d.text.length <128 and likeness > th s)then
Candidate :=Candidate ∪ { (a,d,likeness) }
end
end
end
When computing text similarities, we use two diﬀerent
thresholds. For text that is less then 128 characters a lower
threshold thsis used, because small changes have a relatively
larger eﬀect on the similarity calculation. While most single
line statements are kept under 128 characters, process blocks
tend to be multi-line statements, requiring a larger threshold
value to ensure a quality match.
Once all pairs in {ADD ×DEL }have been evaluated, the
potential match set Candidate is sorted in descending order
based on the pair’s text similarity. Then we use a greedy
algorithm to select a subset of Candidate . In each iteration,
we take the highest weighted pair and add it to the set of
matched nodes, MAP , and update Candidate by removing
all candidate matches that include either the selected pair’s
left or right hand side. The children of the matched pair are
recursively compared to ﬁnd any more additions, deletions,
or matches. At the end of the iterations, ADD ,DEL , and
Candidate are updated to account for newly matched nodes.
This iteration continues until no new candidate matches are
found. For each pair, ( a, d) inMAP , if the full text of a
matches the full text of dexactly, they share the same par-
ent, and their execution orders do not matter (i.e., always ,
initial ,generate ,assign , and <=), then the pair is re-
moved from MAP and marked as unchanged.
4.2 Change-Types for Verilog
In order to provide diﬀerencing results at a higher ab-
straction level than simply listing ADD ,DEL , and MAP ,
we output syntactic diﬀerences in terms of change types.
This classiﬁcation can potentially help users understand the
diﬀerences quickly by providing a set of categories that the
hardware designer can easily identify with. Furthermore,
change classiﬁcation can enable quantitative and qualitative
assessments of frequent change types in Verilog by providing
a detailed uniform description of code changes.
The initial set of change types are motivated from Su-
dakrishnan’s change types [27]. By manually inspecting all
versions of OpenCores project Uart16550 and the DRAM
Memory Controller of the RAMP project (see Section 5), we
created a new change type if the change did not ﬁt within
the classiﬁcation list. The resulting list of change types is
shown in Table 1.
Each of the major categories in the list has to do with a
speciﬁc syntactic element in Verilog. For example, IFdeals
with ifstatement; MDand MIdeal with module declara-
tions and instantiations respectively; ASG focuses on assign-
ment statements; ALfocuses on always blocks, etc. Figure
5 shows an example of IFCCand IFRMV changes.
As a part of a post processing step, where Vdiﬀ interprets
the matching results between two abstract syntax trees asTable 1: Change Types for Verilog Programs
Syntactic Pattern Description
Element
Always ALADD Always block added
ALRMV Always block removed
ALSE Changes in the sensitivity list
Assignment ASG ADD Continuous assignment added
Statement ASG CE Continuous assignment changed
ASG RMV Continuous assignment removed
Blocking BADD Blocking assignment added
Assignment BCE Blocking assignment changed
BRMV Blocking assignment removed
Non-Blocking NBADD Non-blocking assignment added
Assignment NBCE Non-blocking assignment changed
NBRMV Non-blocking assignment removed
If Statement IFABR Addition of else branch
IFAPC Addition of if branch
IFCC Change of if condition expr
IFRBR Removal of else branch
IFRMV Removal of if branch
Switch SWABRP Changes to switch hierarchy
Statement SWCADD Addition of a case branch
SWCRMV Removal of a case branch
SWCHG Changes to condition
Module MDCHG Changes in port type/width
Declaration MDDNP Diﬀerent number of ports
Module MIADD Module instantiation added
Instantiation MIRMV Module instantiation removed
MIDCP Diﬀerent ports values
MIDNP Diﬀerent number of ports
MIDTYP Diﬀerent types
Initialization INIT ADD Initial block added
INIT RMV Initial block removed
Parameter PARAM ADD Parameter added
PARAM CHG Parameter changed
PARAM RMV Parameter removed
Register RGADD Register added
RGCHG Register changed
RGRMV Register removed
Wire WRADD Wire added
WRCHG Wire changed
WRRMV Wire removed
Pre-processor Pattern Description
Directives
Deﬁne DEFINE ADD DEFINE added
DEFINE CHG DEFINE changed
DEFINE RMV DEFINE removed
Ifdef IFDEF ADD IFDEF added
IFDEF CHG IFDEF changed
IFDEF RMV IFDEF removed
Include INC ADD Include added
INC RMV Include removed
Generate GEN ADD Generate block added
GEN RMV Generate block removed
GEN CHG Generate block changed
Others
NC Formatting Changes
Figure 3: AST of uart rﬁfo.v from Figure 1Verilog-speciﬁc change types, it reﬁnes the results in limited
cases by extracting Boolean expressions from AST nodes
and checking their equivalence using a SAT solver. We used
the SAT4J public java library, which takes Boolean formula
in a conjunctive normal form (CNF) and proves whether
there exists a set of inputs that can satisfy the formula [6].
This is similar to Person et al.’s diﬀerential symbolic exe-
cution technique [21] in that syntactic diﬀerencing is com-
plemented by using a decision procedure for checking se-
mantic equivalence. While Person et al.’s technique com-
putes symbolic summaries at a method (or block) and check
equivalence between two methods, Vdiﬀ checks equivalence
between sensitivity lists (i.e., Verilog’s process interface de-
scriptions written in Boolean logic) and does not perform
extensive symbolic execution like Person et al.’s technique.
For example, the ﬁrst always block sensitivity list in Fig-
ure 1 was reordered between versions. From a syntactic
point of view, there has been a deﬁnite change to the sensi-
tivity list; however, the change has no eﬀect on the operation
of the always block because the modiﬁed list is equivalent
to the original list for every possible set of input signals. We
currently focus on checking changes to an always block sen-
sitivity list ( ALSE) to see if the original and modiﬁed lists
areBoolean equivalent . In the future version of Vdiﬀ, we
plan to extend our SAT solver-based semantic comparison
to include Boolean expressions in blocking and non-blocking
assignments, continuous assignments, and IF conditions.
4.3 Vdiff Eclipse Plug-In
We implemented our diﬀerencing algorithm as an Eclipse
plug-in. The plug-in is available for download. Vdiﬀ plug-
in compares program revisions retrieved from a Subversion
repository using the Subclipse interface [7]. Figure 2 shows
the screen snapshot of our Vdiﬀ plug-in. Its tree view vi-
sualizes AST matching results hierarchically; its text view
presents textual diﬀerences between two program versions
using the Eclipse compare plug-in and its console outputs
change-type level diﬀerences with a pointer to word level
diﬀerences. For example, changes to the sensitivity list are
identiﬁed as textual diﬀerences in the side-by-side view, but
they are reported as ALSE: sensitivity list changes . As re-
ordering input signals in the sensitivity list does not lead to
any semantic diﬀerences, the change is marked as Boolean
equivalent .
5. EVALUATION
Our evaluation addresses the following research questions:
•RQ1: What is the overall accuracy of Vdiﬀ in comput-
ing change-type level diﬀerences?
•RQ2: How does Vdiﬀ’s AST matching algorithm com-
pare to existing AST matching algorithms?
•RQ3: What is the impact of using similarity thresholds
in matching AST nodes?
Subject Programs. To evaluate Vdiﬀ, we acquired data
from two Verilog projects: UART16550 [4] and GateLib’s
DRAM controller project [5]. The UART16550 project con-
tains the design for the core logic of a serial communication
chip, which provides communication capabilities with a mo-
dem or other external devices. We also analyzed the RAMP
project’s GateLib DRAM controller. RAMP is an infras-
tructure used to build simulators using FPGAs. To be ableTable 2: Subject Programs
UART16550 GateLib
LOC 2095 3616 286 1843
# Files 8 12 1 5
# Check-ins 56 49
Avg. Modiﬁed Lines 42.12 27.98
Avg. Modiﬁed Files 1.92 1.35
to access memory uniformly independent of a chosen plat-
form, GateLib’s DRAM controller provides an abstract in-
terface which includes a standard DRAM interface, arbiter,
asynchronous adapter and remote memory access.
To evaluate the accuracy of Vdiﬀ output, we created an
evaluation data set through manual inspection. We exam-
ined the individual svn diﬀ ’s outputs and manually classiﬁed
them into change-types. Vdiﬀ ran on the same version his-
tories and produced change-type level diﬀerences. Running
Vdiﬀ took 0.080 second per revision on average (in compar-
ison to 0.059 second on average when running GNU diﬀ) on
Intel Core 2 Duo Thinkpad 2 GHz with 1.96 GB of RAM
running Windows XP. Vdiﬀ’s output was then compared to
the manually created evaluation data set.
5.1 Precision and Recall
Suppose that Vis a set of change-type level diﬀerences
identiﬁed by Vdiﬀ, and Eis a set of manually identiﬁed
change-type level diﬀerences. Precision and recall are de-
ﬁned as follows:
Precision : the percentage of Vdiﬀ’s change-type level
diﬀerences that are correct,|V∩E|
|V|
Recall : the percentage of correct change-type level dif-
ferences that Vdiﬀ ﬁnds,|V∩E|
|E|.
Figure 4 shows the results on UART16550 project’s 56
check-ins and GateLib project’s 49 check-ins. Each row re-
ports the number of revisions per ﬁle, the size of an evalu-
ation data set (i.e., manually inspected change-types |E|),
the number of change-type level diﬀerences reported by Vd-
iﬀ (|V|), the number of correct diﬀerences reported by Vdiﬀ
(|V∩E|), and precision and recall per ﬁle. Our evaluation
shows that Vdiﬀ is extremely accurate for most modules—its
precision and recall are 97.5% and 97.7% on UART16550
and 96.2% and 96.9% on GateLib’s DRAM controller.
The inability to match nodes due to low text similarity
led to false positives (incorrect diﬀerences found by Vdiﬀ,
V−E) and false negatives (correct diﬀerences that Vdiﬀ
could not ﬁnd, E−V). Figure 5 shows an example of
both false positives and false negatives. In this example,
three changes were made: (1) an extra condition ( rstate
== sr idle) was added before setting counter b(IFCC), (2)
the condition for decrementing count bwas modiﬁed by re-
moving counter b != 8’hff (IFCC), and (3) the else block
with the rxlsrmask condition was removed ( IFRBR). Since
the text similarity algorithm used by Vdiﬀ considers the ﬁrst
IF condition diﬀerent enough from its original, the change is
actually classiﬁed as a removal of an IF statement ( IFRMV)
with an addition of a new IF statement ( IFAPC). Thus, Vdiﬀ
reports two incorrect change-type level diﬀerences ( IFRMV,
IFAPC) and misses three expected diﬀerences as a result
(IFCC, IF CC, IF RBR).
To understand the types of changes common in Verilog, we
plotted the distribution of identiﬁed change-types in Figure
6. The two projects we analyzed had very diﬀerent charac-teristics: UART16550 had a signiﬁcant number of core logic
changes during its development, whereas GateLib’s DRAM
project evolved its abstract interface while hiding the actual
implementation of the platform-speciﬁc DRAM implemen-
tation. In the UART16550 design, changes were frequently
made to non-blocking assignments, registers, and always
blocks. GateLib project had many changes to generate
blocks and parameters. Ubiquitous changes observed across
both projects were wire additions, changes to module in-
stantiation ports, and changes to assignments.
We hypothesize that by producing accurate syntactic dif-
ferences in terms of change-types, Verilog developers can
better understand diﬀerences at a high level of abstraction.
We demonstrated Vdiﬀ to an engineer with 14 years of ex-
perience in Verilog. The designer told us, “I can see a use
for [the change-types] right away. It would be great for team
leads because they could look at this log of changes and under-
stand what has changed between versions without having to
look at the ﬁles [textual diﬀerences].” We plan to study how
engineers use Vdiﬀ on their codebase, measure its accuracy
with respect to the diﬀerences expected by the engineers,
and improve Vdiﬀ’s algorithm based on their suggestions.
5.2 Comparison of AST Matching Algorithms
To assess the eﬀectiveness of our weighted bipartite graph
matching algorithm in matching AST nodes in the same
level, we constructed two alternative algorithms by borrow-
ing ideas from existing AST matching algorithms [12, 19].
1.Exact Matching: This is the most na¨ ıve version of AST
matching algorithm that ﬁnds corresponding nodes in
the same level using the exact same label. It has the
same eﬀect of using Neamtiu et al.’s AST matching
algorithm [19] that traverses two trees in parallel and
matches corresponding nodes by the same label in the
same syntactic position in the trees.
2.In-Order Matching: This algorithm ﬁnds correspond-
ing nodes in the same level in order—it starts by exam-
ining each node in the left tree in order and searching a
node in the right tree with the highest similarity. This
algorithm has the same eﬀect of using the Cottrell et
al.’s AST matching algorithm [12], which determines
ordered correspondences between two sets of descen-
dant nodes by considering nodes in the left tree in turn
and ﬁnding the best corresponding node in the right
tree using a linear search.
3.Greedy Weighted Bipartite Matching: Our algorithm
ﬁnds corresponding nodes in the same level using a
weighted bipartite graph matching algorithm [11].
Table 3 shows the comparison of the precision and recall
of in-order matching algorithms (column 1 and column2)
with our weighted bipartite matching, which relaxes the con-
straint of linear search to prevent early selection of a match
that leads sub-optimal matching (column 3). As shown in
Table 3, our algorithm improved the precision by 41.4% and
the recall by 29.8% compared to the baseline (column 1)
and improved the precision by 6.6% and the recall by 5.9%
compared to an in-order matching based on similar labels
(column 2). This evaluation of 1097 diﬀerences from 210
ﬁle revisions in two real world projects shows that the or-
dering of code actually matters in practice when it comes to
computing diﬀerences between program versions.File Revisions LOC Evaluation Vdiﬀ |V∩E|Precision Recall
(min:max) |E| |V| |V∩E|/|V||V∩E|/|E|
raminfr.v 3 95:111 3 3 3 100% 100%
timescale.v 3 3:64 3 3 3 100% 100%
uart debug if.v 6 98:126 9 9 9 100% 100%
uart deﬁnes.v 10 177:247 25 25 25 100% 100%
uart receiver.v 25 341:482 94 103 92 89.3% 97.9%
uart regs.v 35 531:893 282 276 272 98.6% 96.5%
uart rﬁfo.v 5 267:320 37 37 37 100% 100%
uart sync ﬂops.v 2 122:122 2 2 2 100% 100%
uart tﬁfo.v 3 227:243 3 3 3 100% 100%
uart top.v 11 170:340 38 38 38 100% 100%
uart transmitter.v 13 288:351 39 39 39 100% 100%
uart wb.v 25 125:317 65 63 63 100% 96.9%
Total (UART) 141 600 601 586 97.5% 97.7%
DRAM.v 14 286:297 22 23 21 91.3% 95.5%
DRAMArbiter.v 15 286:429 214 224 214 95.5% 100.0%
DRAMArbiterInner.v 5 392:396 5 5 4 80.0% 80.0%
DRAMExaminer.v 29 180:450 249 244 238 97.5% 95.6%
DRAMRouter.v 6 397:397 7 6 5 83.3% 71.4%
Total (GateLib) 69 497 502 482 96.2% 96.9%
Total 210 1097 1103 1068 96.8% 97.3%
Figure 4: Precision and recall of Vdiﬀ on subject programs ( ths=0.65and thl=0.80)
Expected diﬀerences Vdiﬀ outputs
old
if (!srx_pad_i) /* IF CC */
counter_b <= #1 8’d191;
else
if (counter_b != 8’b0 && counter_b != 8’hff) /* IF CC */
counter_b <= #1 counter_b - 8’d1;
else if (rx_lsr_mask)
counter_b <= #1 8’hff; /* IF RMV */if (!srx_pad_i) /* IF RBR */
counter_b <= #1 8’d191;
else
if (counter_b != 8’b0 && counter_b != 8’hff)
counter_b <= #1 counter_b - 8’d1;
else if (rx_lsr_mask)
counter_b <= #1 8’hff;
new
if (!srx_pad_i || rstate == sr_idle) /* IF CC */
counter_b <= #1 8’d191;
else
if (counter_b != 8’b0) /* IF CC*/
counter_b <= #1 counter_b - 8’d1;if (!srx_pad_i || rstate == sr_idle) /* IF APC */
counter_b <= #1 8’d191;
else
if (counter_b != 8’b0)
counter_b <= #1 counter_b - 8’d1;
Figure 5: Vdiﬀ reported IFAPCand IFRMV when two IFCCs and one IFRBR were expected. Code with red
shade represents removal, code with gray shade represents modiﬁcation, and code with blue shade represents
addition.
0 10 20 30 40 50 60 70 80 AL_ADD AL_RMV AL_SE ASG_ADD ASG_CE ASG_RMV B_ADD B_CE B_RMV NB_ADD NB_CE NB_RMV IF_ABR IF_APC IF_CC IF_RBR IF_RMV SW_ABRP SW_CADD SW_CHG SW_CRMV MD_CHG MD_DNP MI_ADD MI_RMV MI_DCP MI_DNP MI_DTYP INIT_ADD INIT_RMV PARAM_ADD PARAM_CHG PARAM_RMV RG_ADD RG_CHG RG_RMV WR_ADD WR_CHG WR_RMV DEFINE_ADD DEFINE_CHG DEFINE_RMV IFDEF_ADD IFDEF_CHG IFDEF_RMV INC_ADD INC_RMV GEN_ADD GEN_CHG GEN_RMV NC Dram Uart 
Figure 6: Frequency of change-typesTable 3: Comparison between diﬀerent algorithms
for matching sibling nodes
Average Label In-Order Weighted
Matching Matching Bipartite
Precision 56.1% 90.9% 97.5%
Recall 67.9% 91.8% 97.7%
In addition, we also compared Vdiﬀ with the EMF con-
ﬁgurable program diﬀerencing framework [3] by adapting it
to work for Verilog. We mapped (1) modules in Verilog to
classes, (2) always blocks and continuous assignments to
operations, (3) wires, registers, and ports to ﬁelds, (4) and
module instantiations to reference pointers in an EMF ecore
model. On the same UART data set, the EMF Compare
tool reported the 47.04% recall with the 80.84% precision
because the EMF ecore modeling language could not model
the implementation of always blocks including blocking and
non-blocking statements.
5.3 Impact of Similarity Thresholds
Our algorithm uses ths(threshold for short text) and thl
(threshold for long text) to determine the similarity between
two AST subtrees. If the similarity is above an input thresh-
old, then the diﬀerence will be classiﬁed as change; other-
wise, they are considered an ADD or a DELETE. We as-
sessed the impact of these similarity thresholds by incre-
menting thsby 0.05, from 0.5 to 0.95, while setting thlto
its default value 0.80. We also incremented thlby 0.05,
from 0.5 to 0.95, while setting thsto 0.65. Figures 7 and 8
show the resulting accuracy of varying these thresholds on
theuart receiver.v ﬁle during its entire revision history.
The F-measure is also plotted to reason about precision and
recall together:2×Precision ×Recall
(Precision +Recall ).
Precision and recall generally increase as thsincreases due
to more strict matching requirements. If thsis too low, unre-
lated nodes are incorrectly matched and reported as changes
instead of additions and deletions, adversely aﬀecting accu-
racy. However, when thsreaches around 0.95, its precision
and recall decrease as the threshold requirement becomes
too strict, and many unmatched nodes are considered ad-
ditions and deletions instead of expected changes. The F-
measure reaches the maximum when thsis 0.65. Varying thl
follows a similar trend for similar reasons. However, match-
ing large blocks requires a more strict threshold for correct
matching to occur as illustrated by the increase in precision
from 0.60 to 0.90. The F-measure reaches the maximum
when thlis around 0.8 and 0.85.
6. DISCUSSION
This section discusses our Vdiﬀ algorithms’ limitations,
threats to validity, and extensions necessary for applying
Vdiﬀ to other hardware description languages.
Limitations. Though we use two diﬀerent thresholds, our
algorithm is still sensitive to subtle changes to variable names
or IF-conditions and requires careful tuning of similarity
thresholds. Further investigation of diﬀerent name similar-
ity measures such as n-gram based matching [13] is required.
Renaming wires, registers and modules often causes cascad-
ing false positives and false negatives by incorrectly match-
ing AST nodes at a top-level. Renaming detection tech-
niques [30, 17] could be used to overcome this limitation.
The current algorithm cannot recover from mismatches at atop level as it matches parent nodes before matching their
descendants. The equivalence check using a SAT solver is
currently limited to only sensitivity lists, and we plan to
extend this check to all types of boolean expressions. VEd-
itor struggled with parsing pre-processor directives; conse-
quently, we worked around IFDEFs by creating a version
where the IF branch is true and another version where the
ELSE branch is true. We ﬁrst computed diﬀerences for
these two versions separately and later merged the results
to help programmers understand syntactic diﬀerences un-
der two possible circumstances. Our results on precision,
recall and frequent change-types are limited to UART and
GateLib and do not necessarily generalize to other projects.
In addition, the construction and manual identiﬁcation of
change-types are subject to experimenter bias as they are
done by the ﬁrst two authors of this paper, who have nine
and six years of hardware design experience in industry re-
spectively.
Application of Vdiﬀ to Other HDLs. While Verilog is
the most widely used HDL, two other HDLs are also preva-
lently used: SystemVerilog and VHDL. SystemVerilog [24]
extends the Verilog-2005 standard to include several fea-
tures commonly found in modern object oriented program-
ming languages: multi-dimensional arrays, enum data types,
struct ,union , strings, classes with inheritance, assertions,
and synchronization primitives. Many of these features in
SystemVerilog cannot be directly mapped to hardware cir-
cuitry but could be used for veriﬁcation and simulation.
VHDL [9] was initially developed in the 1980s, around the
same time Verilog was created, and it has features similar
to Ada. Vdiﬀ could be easily extended to other HDLs by
plugging in a diﬀerent parser and handling new change types
such as changes to struct orenum in SystemVerilog.
7. CONCLUSION
Most program diﬀerencing algorithms implicitly assume
sequential ordering between code elements or assume that
code elements can be matched based on their unique names
regardless of their positions, such as reordered Java meth-
ods. This limitation leads to poor accuracy when these tech-
niques are applied to languages such as Verilog, where it is
common to use non-blocking statements and there is a lack
of unique identiﬁers for process blocks. This paper presented
a position-independent AST matching algorithm that is ro-
bust to reordering of code elements even when their labels
are not unique. Based on this algorithm, we developed Vd-
iﬀ, a program diﬀerencing tool for Verilog. Our evaluation
shows that Vdiﬀ is accurate with a precision of 96.8% and
a recall of 97.3% when using manually classiﬁed diﬀerences
as a basis of evaluation.
Acknowledgment
We thank Greg Gibeling and Derek Chiou for providing ac-
cesses to the RAMP repository and Adnan Aziz and anony-
mous reviewers for their detailed comments on our draft.
8. REFERENCES
[1]http://sourceforge.net/projects/tkdiﬀ.
[2]http://veditor.wiki.sourceforge.net.
[3]Eclipse EMF Compare Project description .
[4]Opencore . http://opencores.org.0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 
0.5 0.55 0.6 0.65 0.7 0.75 0.8 0.85 0.9 0.95 th_s Precision Recall F measure  Figure 7: Precision and recall when varying thswhile
keeping thlat0.80
0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 
0.5 0.55 0.6 0.65 0.7 0.75 0.8 0.85 0.9 0.95 th_l Precision Recall F measure  Figure 8: Precision and recall when varying thlwhile
keeping thsat0.65
[5]Ramp . http://ramp.eecs.berkeley.edu.
[6]Sat4J . http://www.sat4j.org/.
[7]Subclipse . http://subclipse.tigris.org.
[8]T. Apiwattanapong, A. Orso, and M. J. Harrold. A
diﬀerencing algorithm for object-oriented programs. In
ASE ’04 , pages 2–13, Washington, DC, USA, 2004.
IEEE Computer Society.
[9]P. J. Ashenden. Vhdl-200x: The next revision. IEEE
Design and Test of Computers , 20(3):112–113, 2003.
[10]G. Canfora, L. Cerulo, and M. D. Penta. Tracking
your changes: A language-independent approach.
IEEE Software , 26:50–57, 2009.
[11]T. H. Cormen, C. E. Leiserson, and R. L. Rivest.
Introduction to Algorithms . McGraw-Hill
Science/Engineering/Math, 2001.
[12]R. Cottrell, J. J. C. Chang, R. J. Walker, and
J. Denzinger. Determining detailed structural
correspondence for generalization tasks. In ESEC-FSE
’07, pages 165–174, New York, NY, USA, 2007. ACM.
[13]L. R. Dice. Measures of the amount of ecologic
association between species. Ecology , 26(3):297–302,
1945.
[14]B. Fluri, M. W¨ ursch, M. Pinzger, and H. C. Gall.
Change distilling—tree diﬀerencing for ﬁne-grained
source code change extraction. IEEE Transactions on
Software Engineering , 33(11):18, November 2007.
[15]V. Gupta and V. Pratt. Gates accept concurrent
behavior. Foundations of Computer Science, Annual
IEEE Symposium on , 0:62–71, 1993.
[16]J. W. Hunt and T. G. Szymanski. A fast algorithm for
computing longest common subsequences.
Communications of the ACM , 20(5):350–353, 1977.
[17]G. Malpohl, J. J. Hunt, and W. F. Tichy. Renaming
detection. Automated Software Engineering ,
10(2):183–202, 2000.
[18]E. W. Myers. An o(nd) diﬀerence algorithm and its
variations. Algorithmica , 1:251–266, 1986.
[19]I. Neamtiu, J. S. Foster, and M. Hicks. Understanding
source code evolution using abstract syntax tree
matching. In MSR’05 , pages 2–6, 2005.
[20]D. Ohst, M. Welle, and U. Kelter. Diﬀerence tools for
analysis and design documents. In ICSM ’03 , page 13,
Washington, DC, USA, 2003. IEEE Computer Society.
[21]S. Person, M. B. Dwyer, S. Elbaum, and C. S.
Pˇ asˇ areanu. Diﬀerential symbolic execution. In
SIGSOFT ’08/FSE-16 , pages 226–237, New York,
NY, USA, 2008. ACM. diﬀerential symbolic execution.[22]S. Raghavan, R. Rohana, D. Leon, A. Podgurski, and
V. Augustine. Dex: A semantic-graph diﬀerencing tool
for studying changes in large code bases. In ICSM ’04 ,
pages 188–197, Washington, DC, USA, 2004. IEEE
Computer Society.
[23]S. P. Reiss. Tracking source locations. In ICSE ’08 ,
pages 11–20, New York, NY, USA, 2008. ACM.
[24]D. I. Rich. The evolution of systemverilog. IEEE
Design and Test of Computers , 20(4):82–84, 2003.
[25]M. Schmidt and T. Gloetzner. Constructing diﬀerence
tools for models using the sidiﬀ framework. In ICSE
Companion ’08 , pages 947–948, New York, NY, USA,
2008. ACM.
[26]M. Soto and J. M¨ unch. Process model diﬀerence
analysis for supporting process evolution. Lecture
Notes in Computer Science, Springer Berlin , Volume
4257/2006:123–134, 2006.
[27]S. Sudakrishnan, J. Madhavan, E. J. Whitehead, Jr.,
and J. Renau. Understanding bug ﬁx patterns in
verilog. In MSR ’08 , pages 39–42, New York, NY,
USA, 2008. ACM.
[28]D. Thomas and P. Moorby. The Verilog Hardware
Description Language . Kluwer Academic Publishers,
2002.
[29]C. Treude, S. Berlik, S. Wenzel, and U. Kelter.
Diﬀerence computation of large models. In ESEC-FSE
’07: Proceedings of the the 6th joint meeting of the
European software engineering conference and the
ACM SIGSOFT symposium on The foundations of
software engineering , pages 295–304, New York, NY,
USA, 2007. ACM.
[30]P. Weißgerber and S. Diehl. Identifying refactorings
from source-code changes. In ASE ’06 , pages 231–240,
Washington, DC, USA, 2006. IEEE Computer Society.
[31]Z. Xing and E. Stroulia. Umldiﬀ: an algorithm for
object-oriented design diﬀerencing. In ASE ’05 , pages
54–65, New York, NY, USA, 2005. ACM.
[32]W. Yang. Identifying syntactic diﬀerences between
two programs. Software – Practice & Experience ,
21(7):739–755, 1991.