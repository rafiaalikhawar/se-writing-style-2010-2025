Representation Dependence Testing using
Program Inversion
Aditya Kanade
Indian Institute ofScience
kanade@csa.iisc.ernet.inRajeev Alur
Universityof Pennsylvania
alur@cis.upenn.eduSriram Rajamani G.Ramalingam
MicrosoftResearchIndia
{sriram,grama}@microsoft.com
ABSTRACT
The deﬁnition of a data structure may permit many diﬀer-
ent concrete representations of the same logical content. A
(client) program that accepts such a data structure as input
is said to have a representation dependence if its behavior
diﬀers for logically equivalent input values. In this paper ,
we present a methodology and tool for automated testing
of clients of a data structure for representation dependenc e.
In the proposed methodology, the developer expresses the
logical equivalence by writing a normalization program f
that maps each concrete representation to a canonical one.
Our solution relies on automatically synthesizing the one-
to-many inverse function of f: given an input value x, we
can generate multiple test inputs logically equivalent to xby
executing the inverse with the canonical value f(x) as input
repeatedly. We present an inversion algorithm for restrict ed
classes of normalization programs including programs map-
ping arrays to arrays in a typical iterative manner. We
present a prototype implementation of the algorithm, and
demonstrate how our methodology reveals bugs due to repre-
sentation dependence in open source software such as Open
Oﬃce and Picasa using the widely used image format Tiff.
Tiffis a challenging case study for our approach.
Categories andSubject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veriﬁ-
cation; D.2.5 [ Software Engineering ]: Testing and De-
bugging; F.3.1 [ Logics and Meanings of Programs ]:
Specifying and Verifying and Reasoning about Programs
General Terms
Experimentation, Reliability, Veriﬁcation
Keywords
Data Structures, Program Inversion, Testing
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and thefull citation on the ﬁrstpage. Tocop y otherwise, to
republish, topostonserversortoredistribute tolists,re quires priorspeciﬁc
permission and/or afee.
FSE-18,November 7–11, 2010, Santa Fe,New Mexico, USA.
Copyright 2010 ACM 978-1-60558-791-2/10/11 ...$5.00.1. INTRODUCTION
In this paper, we address data representation dependence ,
a class of bugs that is a common source of incompatibility
between programs. We describe a new testing technique
that we call representation fuzzing to identify such bugs.
Data Representation Dependence. Consider a pro-
gram (the producer) that produces some data that is con-
sumed by another program (the client). When the client
program works correctly with one version of the producer,
but fails to do so with a latter version of the producer, we
have a version compatibility problem.
Data deﬁnition is often a key to interoperability between
programs. By “data deﬁnition”, we mean a deﬁnition of
the structure of data interchanged between programs and
its semantics ( i.e., the data value a particular data instance
represents). Such a deﬁnition essentially acts as the contr act
between a producer and client of data.
Such deﬁnitions often permit diﬀerent representations of
the same data value. A new version of a producer program
may exploit the ﬂexibility in the data deﬁnition contract
to produce output that looks structurally diﬀerent from the
output of an earlier version of the producer, yet semantical ly
represents the same value. A correct client is expected to
work with the output of both versions of the producer.
Unfortunately, an implementation of a client may make
assumptions about the data deﬁnition based on the observed
output of a particular version of the producer program rathe r
than use an independently speciﬁed data deﬁnition. As a re-
sult, it may fail to work correctly when the implementation
of the producer evolves. We refer to such a client as having
a data representation dependence . Using examples of clients
using Windows data structures and clients using the widely
used image format Tiff, we argue that such dependence is
indeed an indicator of bugs in practice.
Representation Fuzzing. In this paper, we propose an
eﬀective novel technique for testing a client program Cfor
representation dependence bugs. Given a test case (concret e
input)x, we ﬁrst (automatically) produce other test cases
zthat are logically equivalent to x. We then test the pro-
gramCwith these diﬀerent, but equivalent, inputs. If the
program exhibits diﬀerent behaviors for diﬀerent, but equi v-
alent, inputs, we have a representation dependence bug. Dif -
fering behaviors could take the form of successful completi on
in one case and a failure ( e.g., null pointer dereference) in the
other, or diﬀerent (inequivalent) outputs in the two cases.
This technique, which we call representation fuzzing , works
by essentially ﬁnding alternative representations of a test
casewithout altering its semantics . In our methodology, thedeveloper (of the data deﬁnition) speciﬁes the equivalence
relation on data representations by providing a normaliza-
tionprogram (the semantics function) fthat maps repre-
sentations to the values they denote. In particular, f(x) can
be viewed as the canonical representation of x. Finding al-
ternative representations of xessentially requires identifying
other representations zsuch thatf(z) =f(x).
Program Inversion. Representation fuzzing is essen-
tially a constraint solving problem: given fandxwe want
to determine zsuch thatf(z) =f(x). Our approach is to
decompose this problem into two parts. First, given f, we
automatically synthesize a program f′that represents the
inverse off. The inverse will typically be a one-to-many
function realized via non-determinism. For every yand for
everyzthatf′returns onyas its input, f(z) =ymust hold.
This is the correctness criterion for the inversion problem .
Second, given x, we repeatedly apply f′tof(x) to produce
diﬀerentzthat are logically equivalent to x.
This staged approach lets us do expensive (symbolic) con-
straint solving once (oﬄine) during the program inversion
phase, when possible. However, some of the constraint solv-
ing may be hard if we treat y=f(x) symbolically as an
unknown but may be easier if the value of yis known. In
such cases, we embed these constraints in the synthesized
inverse program so that they are solved dynamically (when
f′is applied to a given value of y).
The key technical challenge we address in the paper is
that of synthesizing the inverse function. In the simple cas e
of straight-line code computing outputs ( y1,· · ·,ym) from
inputs (x1,· · ·,xn), we generate the inversion code by sym-
bolically solving a collection of equations for ( x1,· · ·,xn). In
the general case, conditionals, loops, and arrays complica te
inversion. One of the essential ideas we exploit for inversi on
in the general case is to synthesize an inverse program that
has a control-ﬂow structure isomorphic to the original pro-
gram, using local inversion (via symbolic equation solving )
to invert loop-free code fragments.
TIFF Case Study. Tiffis a widely used image format
that permits multiple representations of the same image and
is known to raise compatibility issues among programs. For
instance, a Tiffimage consists of an orientation ﬂag which
determines whether the scanlines of the image bitmap are
stored from left-to-right or right-to-left and top-to-bot tom
or bottom-to-top. Thus, there are multiple equivalent rep-
resentations of a Tiffimage. We use Tiffas a case study
for representation dependence testing.
Figure 1 summarizes our methodology for testing a client
programCfor representation dependence with Tiffimages
as an example. The normalization program fconverts a
Tiff representation to a canonical bitmap representation.
Our algorithm automatically synthesizes f′, the inverse of
f. We then take a TiffﬁleTiff1 and compute a bitmap
Bm=f(Tiff1). Applying f′toBmproduces an alternative
Tiffrepresentation Tiff2 of the same image as the bitmap
Bm. We runCon both Tiff1 and Tiff2 and report any
diﬀerence in the behavior (or output) of Cas a data repre-
sentation dependence. The non-determinism in f′(e.g., the
choice of orientation ) means that diﬀerent runs of f′can
produce diﬀerent outputs. Thus, repeating the above pro-
cedure multiple times increases the eﬀectiveness of testin g
even when we use the same input Tiff1.
The normalization program fforTiffconsists of several
programming constructs like conditionals, nested loops, u n-Programf
InvertProgramf Bitmap Tiff1 ClientC
Invert
Inverse offTiff2 ClientCEquiv?Bug
OkayNo
Yes
Figure 1: Automated Testing for Representation
Dependence (of Clients of TIFF Images)
bounded arrays, and indirection in array indexing and is a
challenging case study for inversion. We cover strip-based
Tiffimages with ﬂexibility in the choice of orientation, rows
per strip, and physical layout of strips. We test ﬁve popu-
larTiffclients, namely, Open Oﬃce, KView, GIMP, Fast-
Stone, and Picasa with the following conclusions:
•Even if the number of rows per strip is varied, all
clients process the image correctly for all test cases.
•If orientation is varied then Open Oﬃce and GIMP
display images incorrectly with no warning to the user.
•If logically adjacent strips are reordered physically in
conjunction with change in orientation then Picasa dis-
plays images incorrectly with no warning to the user.
2. PROPOSED METHODOLOGY
We now formulate the problem concretely with an exam-
ple of representation dependence and by specifying syntax
and semantics of normalization programs and their inverses .
In a programming language like C, the concrete represen-
tation of data can be given as a struct declaration. As an ex-
ample, consider the following simpliﬁed version of datatyp e
ddsurfacedesc in the Windows DirectDraw API:
typedef struct ddsurfacedesc{ 1
dword height, width, pitch; 2
lpvoid surface; 3
}ddsurfacedesc ; 4
A datadof type ddsurfacedesc contains two dimensional
pixel datad.surface. We assume that a pixel is stored as a
single byte. The number of rows and columns of the pixel
data are given by d.height and d.width. The ﬁeld d.pitch
gives the number of bytes between a pixel and the pixel
immediately below it. A program can append slack bytes
to each row of the pixel data for internal use. The value of
(d.pitch −d.width) is intended to indicate how many slack
bytes are used by a program. In practice, slack bytes may
not be used by a producer program P.
Consider the following client program Cwhich uses data d
of type ddsurfacedesc as input and reads the c’th column
ofd.surface into an array col.
fori := 1 tod.height do 1
col[i] :=d.surface[d.width∗i + c]; 2
end3
It works correctly on data generated by P. However, if P
is changed independently to use slack bytes then it reads
the pixels incorrectly. In other words, Cmakes a stronger
assumption on the datatype (pitch = width) than the spec-
iﬁcation allows (pitch ≥width) and it fails if pitch >width./a\}bracketle{tprogram/a\}bracketri}ht::=/a\}bracketle{tstmt/a\}bracketri}ht+
/a\}bracketle{tstmt/a\}bracketri}ht ::=/a\}bracketle{tsmpl-stmt/a\}bracketri}ht|/a\}bracketle{tcond-stmt/a\}bracketri}ht|/a\}bracketle{tloop-stmt/a\}bracketri}ht
/a\}bracketle{tsmpl-stmt/a\}bracketri}ht::=/a\}bracketle{toutvar/a\}bracketri}ht:=/a\}bracketle{texp/a\}bracketri}ht|assume(/a\}bracketle{tpred/a\}bracketri}ht)
/a\}bracketle{tcond-stmt/a\}bracketri}ht::=if(/a\}bracketle{tpred/a\}bracketri}ht)then/a\}bracketle{tstmt/a\}bracketri}ht+else/a\}bracketle{tstmt/a\}bracketri}ht+end
/a\}bracketle{tloop-stmt/a\}bracketri}ht::=fori := 1 to n do/a\}bracketle{tbody/a\}bracketri}htend
/a\}bracketle{tbody/a\}bracketri}ht ::=/a\}bracketle{tsmpl-stmt/a\}bracketri}ht+|/a\}bracketle{tloop-stmt/a\}bracketri}ht
/a\}bracketle{tinvar/a\}bracketri}ht ::=x|x1|...|x2[/a\}bracketle{tind-exp/a\}bracketri}ht]+|...|m|n
/a\}bracketle{toutvar/a\}bracketri}ht ::=y|y1|...|y2[/a\}bracketle{tind-exp/a\}bracketri}ht]+|...
/a\}bracketle{tindvar/a\}bracketri}ht ::=i|j|k
/a\}bracketle{tind-exp/a\}bracketri}ht::=/a\}bracketle{texp/a\}bracketri}ht|/a\}bracketle{tscalar-invar/a\}bracketri}ht∗/a\}bracketle{texp/a\}bracketri}ht|x[/a\}bracketle{texp/a\}bracketri}ht]
| ±/a\}bracketle{t ind-exp/a\}bracketri}ht±/a\}bracketle{tind-exp/a\}bracketri}ht
Figure 2: The Syntax of Normalization Programs
This example of representation dependence is motivated by
a real bug involving a client of ddsurfacedesc described in
theWindows application compatibility bug database (cf. [4]).
In order to detect representation dependence of clients of a
datatypeT, we need a formal speciﬁcation of the equivalence
relation ≈overT. If a client program Cproduces diﬀerent
behaviors or outputs on data dandd′of typeTsuch that
d≈d′then the client has representation dependence onT.
Forddsurfacedesc ,d≈d′iﬀ
•d.width =d′.width,d.height =d′.height, and
•d.surface[d.pitch∗i+j] =d′.surface[d′.pitch∗i+j] for
alli,jsuch that 1 ≤i≤d.width and 1 ≤j≤d.height.
Given a data d, the goal of representation fuzzing is to
automatically generate d′such thatd′≈dand test a client
with bothd′andd. Writing logical speciﬁcations like this
may be impractical for the developers. Further, analyzing
complex logical speciﬁcations seems diﬃcult. Instead, we
propose that the developer writes a normalization program
fto capture the canonical representation of a datatype T.
This is a reasonably straight-forward task. We deﬁne d′≈d
iﬀf(d′) =f(d). We then show how to use program analysis
to synthesize an inverse f′and obtain d′by applying f′to
the canonical representation f(d).
NormalizationPrograms. Consider a datatype nform with
the ﬁelds height, width, and a two dimensional array data
as the canonical representation of ddsurfacedesc . The nor-
malization program is given below.
/* Input : d, Output : n*/
n.height :=d.height;n.width :=d.width; 1
fori := 1 tod.height do 2
forj := 1 tod.width do 3
n.data[i][j] := d.surface[d.pitch∗i + j]; 4
end5
end6
Figure 2 gives the syntax of normalization programs. The
input and output variables are indicated by letters xandy
respectively and for simplicity, are considered to be integ er
valued. Program expressions /a\}bracketle{texp/a\}bracketri}htand predicates /a\}bracketle{tpred/a\}bracketri}ht
are aﬃne. Loop counters and bounds are named i,j,k and
m,netc. A loop counter is initialized to 1 and incremented
by 1 in each iteration until the upper bound is reached. The
loops are required to be perfectly nested, that is, all assig n-
ment and assume statements are part of the innermost loop
body which can only be straight-line code. An array index
expression can be an aﬃne expression. To handle the Tiff
case study, we address two special cases of non-linear indexexpressions: a scalar input variable to be a coeﬃcient of an
aﬃne expression and a single level of indirection through
another array. The index expressions of an input array can
diﬀer only in constant terms. The RHS of an assignment
to an index variable (local variable) icontains only iand
constants. We assume that an output variable yis assigned
exactly once in the program and is not used before it is de-
ﬁned. This also applies to every output array location y[ℓ].
This assumption is met in the Tiffcase study. Though sim-
ilar to some constraints we check algorithmically for inver -
sion, presently, we verify this assumption manually. Some o f
the syntactic extensions are not mentioned for brevity e.g.,
boolean connectives are allowed in predicates.
While the program semantics are as usual, we assume in-
vertibility of assignment statements: An assignment state -
menty:=eisinvertible with respect to every variable x
appearing in eif the equality relation y=ecan be rewrit-
ten to a logically equivalent relation x=e′. Since we assume
that an output variable yis assigned exactly once and is not
used before it is assigned, ydoes not appear in e. The vari-
ables ofe′can only be from ( V(e)∪ {y})\ {x}whereV(e)
is the set of input variables appearing in e.
Inverse Programs. An inverse of the normalization pro-
gram of ddsurfacedesc is given below.
/* Input:n, Output:d*/
ensure(d.pitch :d.pitch≥n.width); 1
d.height :=n.height;d.width :=n.width; 2
fori := 1 tod.height do 3
forj := 1 tod.width do 4
d.surface[d.pitch∗i + j] :=n.data[i][j]; 5
end6
end7
The inverse program non-deterministically assigns a value
tod.pitch such that d.pitch ≥n.width. The values of height
and width ﬁelds of dandnare same. The control ﬂow of the
loop in the inverse program is same as that of the normal-
ization program. It however copies n.data tod.surface. The
conditiond.pitch ≥n.width =d.width (Line 1) ensures that
every element of d.surface is assigned at most once within
the loop. Thus, if an output dof the inverse program on n
is given as the input to the normalization program, we get
back the same canonical representation n. Suppose the in-
verse chooses d.pitch =d.width+1. Since d.pitch>d.width,
there are slack bytes but they are not required to be initial-
ized by the inverse. Alternatively, we can think of the slack
bytes being assigned random values. If a client program
uses them in a computation that aﬀects its output then it
has representation dependence on ddsurfacedesc .
In addition to the statements in Figure 2, an inverse pro-
gram may consist of the following kinds of statements:
/a\}bracketle{tensr-stmt /a\}bracketri}ht::= ensure( /a\}bracketle{toutvar /a\}bracketri}ht+:/a\}bracketle{tensr-pred /a\}bracketri}ht)
/a\}bracketle{trand-assgn /a\}bracketri}ht::=x:=∗
where ensure() is a call to a constraint solver which solves
the constraints that are postponed to the run-time. It ﬁnds
a satisfying assignment to the list of output variables (of t he
inverse program) for a given predicate. The run-time values
of the input variables (of the inverse program) are substi-
tuted in the predicates. We discuss the syntax of /a\}bracketle{tensr-pred /a\}bracketri}ht
later on. The assignment x:=∗assigns an arbitrary value to
x. It is used when xis unconstrained in the inverse program.Algorithm 1 : Inversion of Programs
Routine :Invert(f)
Input : A program fin the language of Figure 2
Output : A program f′that is semantic inverse of f
U←X;D←∅;P←∅;σ={x/mapsto→⊥|x∈X} 1
LetAdenote (U,D,P,σ ) 2
(A,f′)←InvertSequence (A,f) 3
f′←EmitPRemaining (A,f′) 4
return EmitEnsure (f′) 5
A program f′is asound inverse of a program fif for ev-
eryyand for every zthatf′returns onyas its input, f(z)
=yholds. An inverse program may also consist of assume
statements. The presence of non-deterministic choices by e n-
sure() and random assignments may invalidate assumptions
during run-time. A program f′isfailure-free if no assume
statement fails during any of its executions. While our in-
version algorithm always synthesizes a failure-free sound in-
verse, it computes under-approximations of the inverse fun c-
tion offand hence is an incomplete synthesis procedure.
3. PROGRAMINVERSION
Automatically synthesizing program inverses is a challeng -
ing task. In this section, we present an algorithm which
works by inverting program statements locally , that is, with-
out modifying the control ﬂow of the input program except
for some reordering of statements. While allowing arbitrar y
statement and control ﬂow changes may seem more powerful,
we demonstrate that our algorithm is simple yet eﬀective in
inverting a large class of normalization programs, includi ng
iterative programs with arrays.
3.1 Loop-freeProgramswithScalarVariables
We ﬁrst illustrate various observations and techniques tha t
we use in inversion of loop-free programs with scalar vari-
ables using examples. Consider the following program.
y1:=x1; 1
y2:=x1+x2; 2x1:=y1; 1
x2:=y2−x1; 2
(Input program) (Inverse program)
(Example 1)
To synthesize an inverse of the input program, we need to
compute the input variables x1andx2in terms of the output
variablesy1andy2. The ﬁrst statement gives an equality
relationy1=x1. We treat the output variables as symbolic
constants. Thus, x1is uniquely deﬁned by y1and we clas-
sifyx1asdetermined . The statement is locally inverted to
x1:=y1bringing the determined variable on the LHS. This
statement is logically equivalent to the original statemen t
and is the ﬁrst statement of the inverse program. The RHS
of the second statement in the input program involves vari-
ablesx1andx2. However, x1is already determined in the
preﬁx of the program. Therefore, x2is uniquely deﬁned in
terms ofy2(an output variable) and x1(a pre- determined
variable) and is also classiﬁed as determined . The statement
is inverted locally as shown above.
If there are multiple variables on the RHS of an assign-
ment statement that are not determined then one of them
can be deﬁned in terms of the others. Consider the following
variation of Example 1 with statements reordered.Algorithm 2 : Inversion of Statement Sequences
Routine :InvertSequence (A,f)
Input :A= (U,D,P,σ ) and a statement sequence f
Output : Updated tuple Aand inverse f′off
f′←[ ] 1
whilef/\e}atio\slash= [ ]do 2
s←Car(f) 3
switchsdo 4
casey:=e(A,s′)←InvertAssign (A,s) 5
caseassume(p) (A,s′)←InvertAssume (A,s) 6
case if (p)thens1elses2end 7
(A,s′)←InvertConditional (A,s) 8
case fori:= 1tondobodyend 9
(A,s′)←InvertLoop (A,s) 10
end11
f′←Append (f′,s′) 12
f←Cdr(f) 13
end14
return (A,f′) 15
y2:=x1+x2; 1
y1:=x1; 2
skip;3skip;1
x2:=y2−y1; 2
x1:=y2−x2; 3
(Example 2)
At the ﬁrst statement (of the input program), both x1
andx2are not determined . Say, we deﬁne x1in terms of
y2andx2. However, as x2is not determined ,x1is also not
determined . We instead classify it as a partially determined
variable and generate a skip statement in the inverse pro-
gram. We then eliminate the occurrences of x1in the suﬃx
of the input program until x2isdetermined or we encounter
program exit. We discuss the latter case in the sequel. In
the second statement, we substitute y2−x2forx1. The re-
sulting statement is inverted locally, since x2isdetermined
in terms of y1andy2. All the input variables, namely x2, in
the expression y2−x2to whichx1is bound are now deter-
mined . Hence, we emit x1:=y2−x2in the inverse program.
If an input variable xis not known to be a function of
other variables at a statement of the input program then
the variable is classiﬁed as undetermined at the statement.
LetXbe the set of input variables of the input program.
At every statement, the inversion algorithm computes a par-
tition (U,D,P ) ofXwhereU,D, andPare respectively un-
determined ,determined , andpartially determined variables.
The analysis also computes a binding function σ:X→Exp
that maps the input variables to program expressions de-
noted byExp. If a variable xispartially determined then
σ(x) is a program expression which evaluates to the same
value asx. Otherwise, xis bound to a special expression ⊥.
Algorithm 1 inverts program statements locally by comput-
ing the partition and the binding function.
StatementSequences. The function InvertSequence (Algo-
rithm 2) inverts a given sequence fof program statements.
The inversion is achieved through a single forward pass over
f. Each statement type is treated separately. The tuple Ais
also reﬁned by the statement speciﬁc inversion algorithms.
Assignment Statements. Given an assignment statement
s≡y:=e, the function InvertAssign (Algorithm 3) substi-
tutes all occurrences of the partially determined variables in
eby their binding expressions (Line 2). Let Q=U∩V(e)
whereV(e) denotes the set of variables occurring in e. IfAlgorithm 3 : Inversion of Assignment Statements
Routine :InvertAssign (A,s)
Lets≡y:=e 1
foreachx∈Pdoe←subst(e,x,σ (x)) 2
switchU∩V(e)do 3
case∅s′←assume(y=e) 4
case{x} 5
s′←x:=LocalInvert (s,x) 6
(A,s′′)←MarkDEmitD (A,{x}) 7
s′←Append (s′,s′′) 8
otherwise9
s′←[ ] 10
x←Select(U∩V(e));e′←LocalInvert (s,x) 11
U←U\{x};P←P∪{x};σ←σ[x/mapsto→e′] 12
end13
end14
return (A,s′) 15
Q=∅then all variables in eare already determined and
assigned in the inverse of the preﬁx of the program ending
at the current statement. Nevertheless, their values shoul d
conform with the equality y=e. This constraint is embed-
ded in the inverse program as an assume statement.
If only one variable of e, sayx, isundetermined thensis
inverted to x:=e′. Given an assignment statement y:=e
and a variable xappearing in e,LocalInvert returns an ex-
pressione′such thatx=e′is logically equivalent to y=e.
LocalInvert works by algebraic rewriting of an assignment
such asy:=a∗x+btox:= (y−b)/aassuming that every
operator (such as + and ∗) has an inverse (such as −and/).
The variable xis removed from Uand added to Dby the
function MarkDEmitD (Algorithm 4). Given a set W⊆U
of variables, MarkDEmitD marks them as determined . If all
variables occurring in the binding expression σ(x) of a par-
tially determined variablexare now determined thenxis
alsodetermined (Line 5). The function MarkDEmitD emits
the assignment statement x:=σ(x). This process is re-
peated until no partially determined variable can be marked
asdetermined . The bindings carried by σ, discharged as
assignment statements by MarkDEmitD , cause statement re-
ordering as discussed Example 2.
If more than one undetermined variables occur in ethen
one of them, say x, is marked as partially determined and
bound to the expression LocalInvert (s,x) (Lines 11-12).
AssumeStatements. Given an assume statement assume( p),
the function InvertAssume (Algorithm 5) substitutes all oc-
currences of partially determined variables in pby their bind-
ing expressions. All variables in U∩V(p) are marked as
determined . As explained later, we ensure that, these vari-
ables take values that conform to pat the current statement.
Some variable bindings may be discharged by MarkDEmitD .
Finally, the statement assume( p) is generated.
Conditional Statements. Given a conditional statement
s≡if(p)thenf1elsef2end, the function InvertConditional
(Algorithm 6) processes psimilar to the predicate of an as-
sume statement and inverts the branches f1andf2individ-
ually. LetAi= (Ui,Di,Pi,σi),i∈ {1,2}. IfP1=P2and
σ1=σ2thenJoin(A1,A2) = (U1∩U2,D1∪D2,P1,σ1).
A variablex∈D\D1=U1∩D2is marked as determined
by the join operation but is undetermined inf1. To force the
determined status, a random assignment x:=∗is appendedAlgorithm 4 : Transitively Mark Partially Determined
Variables as Determined and Emit Assignment Stmts.
Routine :MarkDEmitD (A,W)
s′←[ ];U←U\W;D←D∪W 1
repeat2
B←P 3
foreachx∈Pdo 4
ifV(σ(x))⊆Dthen 5
s′←Append (s′,x:=σ(x)) 6
P←P\{x};D←D∪{x};σ←σ[x/mapsto→⊥] 7
end8
untilB=P 9
return (A,s′) 10
to the inverse of f1(Line 8). Similarly, for f2. This ensures
that the future uses of xcan be resolved to be determined ,
unconditionally, enabling local inversion. The condition al
statement for the inverse is then formed by composing the
inverses of the branches. If P1/\e}atio\slash=P2orσ1/\e}atio\slash=σ2then one of
the branches is eliminated1(Lines 14-17).
In the following program, the variables x2andx3arede-
termined in the if-branch and the else-branch respectively.
skip;1
ifx1>0theny1:=x2; 2
elsey1:=x3;end 3
y2:=x3+x4; 4
y3:=x2; 5ensure(x1,x2:ϕ(x1,x2)); 1
ifx1>0thenx2:=y1;x3:=∗; 2
elsex3:=y1;x2:=∗;end 3
x4:=y2−x3; 4
assume(y3=x2); 5
(Example 3)
We insert random assignments x3:=∗andx2:=∗in
the if-branch and the else-branch respectively to force bot h
x2andx3to be determined along both the branches. We
discuss the predicate ϕ(x1,x2) later.
Program Exit. Oncefis processed completely, the func-
tionEmitPRemaining appends random assignments to the
undetermined variables used in the binding expressions to
f′. For eachx∈P,x:=σ(x) is then emitted.
EnsuringFailure-freeExecution. The inversion algorithm
may generate random assignments to variables while pro-
cessing conditional statements (Algorithm 6, Lines 8-9). F ur-
ther, new assume statements may be added to the inverse
program if all variables on the RHS of an assignment state-
ment are already determined (Algorithm 3, Line 4).
Consider Example 3 again. If x2gets assigned a value
/\e}atio\slash=y3in the else-branch then the assume statement in the
inverse program fails. To avoid such failures, the function
EmitEnsure (Algorithm 1, Line 10) performs the following
operations: (1) it computes the weakest precondition wpof
assume statements, (2) emits an ensure statement at the
program entry to satisfy the precondition, and (3) removes
random assignments that may violate assume statements.
Given the antecedant Hoare triple of a wprule in the in-
verse program f′,EmitEnsure generates the consequent triple
to obtain a transformed version of the inverse program.
1It is possible to combine inequal sets of partially determined
variables ( e.g., by unifying their binding expressions) but,
for simplicity, we restrict it to the present form.Algorithm 5 : Inversion of Assume Statements
Routine :InvertAssume (A,s)
Lets≡assume(p) 1
foreachx∈Pdop←subst(p,x,σ (x)) 2
(A,s′)←MarkDEmitD (A,U∩V(p)) 3
return (A,Append (s′,s)) 4
{ψ}x:=e{ϕ}
{ψ∧subst(ϕ,x,e )}x:=e{ϕ}e/\e}atio\slash=∗{ψ}assume(p){ϕ}
{ψ∧ϕ∧p}assume(p){ϕ}
{ψ}x:=∗{ϕ}
{ψ∧ϕ}x:=∗{ϕ}x/\e}atio\slash∈V(ϕ){ψ}x:=∗{ϕ}
{ψ∧ϕ}skip{ϕ}x∈V(ϕ)
{ψ}s≡if(p)thenf1thenf2end{ϕ}
{ψ∧((p∧wp(ϕ,f1))∨(¬p∧wp(ϕ,f2)))}s{ϕ}
f′
ensure (wp(true,f′));f′
The rule involving x:=∗and a postcondition ϕwhere
x∈V(ϕ) eliminates the random assignment to xas it may
violate the postcondition ϕ. Instead,xis assigned a value
that satisﬁes ϕby the ensure() statement at the program
entry. The assignment x2:=∗in Example 3 is eliminated
by this. The last rule emits the ensure statement. The pred-
icateϕ(x1,x2) in Example 3 is generated using these rules:
ϕ(x1,x2)≡(x1>0∧y3=y1)∨(x1≤0∧y3=x2). The
ensure() statement is a call to a constraint solver to ﬁnd
satisfying assignments to x1andx2subject to the predi-
cateϕ(x1,x2) where the run-time values of y1andy3are
substituted. We discuss the constraint solver in Section 4.
Correctness. Each statement of the input program is con-
verted to a logically equivalent statement in synthesis of a n
inverse while maintaining the control ﬂow of the inverse pro -
gram. Given values of the output variables y, an input vari-
ablexis assigned exactly once in the inverse program. This
guarantees that the value of xconforms with all its prior
relations with y. A subsequent statement sof the input
program involving xis also mapped to a logically equivalent
statements′in the inverse program. It can be either an
assignment to another variable x′or an assume statement.
Further, the constraint to the ensure() statement guarante es
that no assume statement fails during run-time. The inverse
however many not be complete , in a sense, that given yit
may not produce all x’s such that y=f(x). This is because
of handling of conditionals when partially determined vari-
ables along the two branches do not match and limitations
of the constraint solver used in ensure() statements.
3.2 Iterative ProgramswithArrays
We now extend the inversion algorithm to iterative pro-
grams with arrays. We use the following adaptation of Ex-
ample 1 to illustrate the basic ideas behind loop inversion.
fori:= 1 to 10 do 1
y1[i] :=x1[i]; 2
y2[i] :=x1[i] +x2[i]; 3
end4fori= 1 to 10 do 1
x1[i] :=y1[i]; 2
x2[i] :=y2[i]−x1[i]; 3
end4
(Example 4)
Algorithm 7 performs inversion of a loop s. It copies
the loop-structure ℓ′of the loop sto the inverse program
(Lines 1, 9) but inverts the statements within the loop bodyAlgorithm 6 : Inversion of Conditional Statements
Routine :InvertConditional (A,s)
Lets≡if(p)thenf1elsef2end 1
foreachx∈Pdop←subst(p,x,σ (x)) 2
(A,s′)←MarkDEmitD (A,U∩V(p)) 3
(A1,f′
1)←InvertSequence (A,f1) 4
(A2,f′
2)←InvertSequence (A,f2) 5
ifP1=P2∧σ1=σ2then 6
A←Join(A1,A2) 7
foreachx∈D\D1dof′
1←Append (f′
1,x:=∗) 8
foreachx∈D\D2dof′
2←Append (f′
2,x:=∗) 9
s′←Append (s′,if(p)thenf′
1elsef′
2end) 10
(A,s′′)←MarkDEmitD (A,∅) 11
s′←Append (s′,s′′) 12
else13
A←Select(A1,A2) 14
ifA=A1then 15
s′←Append (s′,if(p)thenf′
1elseassume(false); end) 16
elses′←Append (s′,if(p)then assume(false); elsef′
2end) 17
end18
return (A,s′) 19
locally as we did for loop-free programs (Line 5). We now
describe the extensions required to do this. In the sequel,
the term reference denotes either a scalar variable such as i
or an indexed array variable such as x1[i].
Consider an assignment statement y[e0] :=x1[e1]+x2[e2].
A reference such as x1[e1] orx2[e2] is atop-level reference .
These are given by the function TopLevelRefs . We can rewrite
the assignment statement to express any top-level referenc e
as a function of other top-level references and the LHS, due
to the invertibility assumption (Section 2). The top-level ref-
erences play a role analogous to (scalar) variables in our or ig-
inal algorithm. A reference occurring inside an array index
expression (such as e0,e1,e2) is a nested reference . These
are given by the function NestedRefs . They are treated dif-
ferently. In particular, they must be determined before we
can process this assignment statement. Hence, we (conser-
vatively) mark the nested references as being determined .
SymbolicPartitionRepresentation. We extend our scheme
for partitioning a statically ﬁxed number of (scalar) varia bles
into (U,D,P ) to similarly partition a statically unbounded
number of (array) locations. The current iteration of a sim-
ple loop is represented symbolically by its counter i. The
status of locations that become determined orpartially de-
termined in the current iteration is maintained just as in the
case of loop-free code. In Example 4, the set of locations de-
termined in the current iteration after the ﬁrst and second
statement are {x1[i]}and{x1[i],x2[i]}respectively.
We utilize a symbolic representation to describe the set
Dof array locations that were determined in iterations of
the loop preceding the current iteration (as a function of
the iteration index). In the above example, the symbolic
representation of Dtakes the form {x1[i′],x2[i′]|1≤i′≤
10∧i′<i}, which describes the set of determined locations
at the beginning of iteration i. In general, the symbolic
representation is of the form {S|Q}whereSis a set of
symbolic input array locations with index expressions over
some free variables e.g.,i, andQis a constraint over these
free variables. Qis of the form Bi∧L, whereBiis the
predicate (1 ≤i′≤ni) withnias the upper bound of i, and
Lis the predicate i′< i. This can be extended to nested
loops using the lexicographical order over iteration vecto rs.Algorithm 7 : Inversion of Loops
Routine :InvertLoop (A,s)
ℓ′←GetLoopStructure (s) 1
b←GetBody (s) 2
U←U∪TopLevelRefs (s)∪NestedRefs (s) 3
D←D∪{S|Q} 4
(A,b′)←InvertSequence (A,b) 5
b′←EmitPRemaining (A,b′) 6
ϕ′←NonAliasConstr (b′)∧LoopBoundConstr (b′) 7
s′←assume(ϕ′) 8
s′←Append (s′,InsertBody (ℓ′,b′)) 9
return (A,s′) 10
Sis a list of all array references that become determined
in a particular iteration i′. To simplify construction of S, we
conservatively treat every location referenced in a given i ter-
ation as determined at the end of that iteration. This reﬂects
in the initialization of the set Din Line 4. Consequently, we
do not carry partially determined variables across loop itera-
tions. We therefore emit assignments to partially determined
variables at the end of the loop body (Line 6).
Generalized Assignment Inversion. Algorithm 8 shows
how an assignment statement is processed during inversion
of a loop body. If it is an assignment to a local variable, say
k, then the RHS ekhas onlykas a variable (Section 2). We
simply copy the statement to the inverse program (Line 1).
Otherwise, we do substitutions for partially determined
references in e, as before, but substitutions are restricted to
top-level references (Line 4). Next, we mark nested refer-
ences as determined (Lines 5-7). Assume that we want to
inverty[e0] :=x[e1] intox[e1] :=y[e0]. Clearly, we want ev-
ery nested reference roccurring in e0ande1to be assigned a
value before this inverted statement executes in the invers e
program. Marking rasdetermined at this point captures
this requirement. They are assigned values by the ensure()
statement by solving constraints generated by the inversio n
algorithm over them as discussed shortly.
We then identify the top-level references that are undeter-
mined (Lines 8-15). Unlike in the earlier algorithm, we may
not be able to precisely categorize the status of a reference
r. In this case, we determine the condition ψunder which r
isundetermined (as explained soon) and accumulate the set
of such constraints and treat ras being undetermined .
We identify the status of a reference r, by checking whether
rbecame determined either earlier in the current iteration or
in some previous iteration. The latter condition is checked
asr∈ {S|Q}. We treat rasundetermined only if we can
establish that r’s status is undetermined inevery iteration.
Otherwise, we treat it as being determined . This computes
a loop-invariant partition of the top-level references and en-
ables us to invert the loop body locally (Lines 16-18).
Consider the following example.
fori:= 1 to 10 do 1
y[i] :=x[i] +x[i+ 3]; 2
end3x:= *;1
fori:= 1 to 10 do 2
x[i+ 3] :=y[i]−x[i]; 3
end4
(Example 5)
The set of locations determined in iterations preceding it-
erationiis given by {S|Q}, whereQ= (1≤i′≤10)∧(i′<
i), andS={x[i′],x[i′+ 3]}. Now, consider the statementAlgorithm 8 : Generalized Inversion of Assignments
Routine :InvertAssign (A,s)
ifs≡k:=ekfor a local variable kthens′←s 1
else2
s′←[ ]; Lets≡y:=e 3
foreachr∈TopLevelRefs (e)doe←subst(e,r,σ(r)) 4
foreachr∈U∩(NestedRefs (y)∪NestedRefs (e))do 5
(A,s′)←MarkDEmitD (A,{r}) 6
end7
UV←∅ 8
foreachr∈TopLevelRefs (e)do 9
switch CheckIfUndetermined (r)do 10
casetrue:UV←UV∪{r} 11
casefalse: skip 12
caseCondψ:AddConstraint (ψ);UV←UV∪{r} 13
end 14
end15
switchUVdo 16
/* Similar to Algorithm 3, Lines 3-14 */
end17
end18
return (A,s′) 19
y[i] :=x[i] +x[i+ 3]. Intuitively, x[i] has already been ref-
erenced in iteration i−3 using the reference x[i+ 3] (for
i >3). More precisely, since x[i]∈ {S|Q},x[i] is marked
asdetermined . Sincex[i+ 3]/\e}atio\slash∈ {S|Q},x[i+ 3] is marked
asundetermined . The statement is then inverted as shown.
The function CheckIfUndetermined decides the status of a
reference unambiguously as “true” or “false” for aﬃne array
index expressions. Given a reference x[e], it checks whether
x[e] isdetermined in the current iteration or x[e]∈ {S|Q}
which amounts to ∃i′,i·(1≤i≤ni)∧Q∧(W
x[e′]∈Se=e′)
and is solved as an integer linear program.
In inversion of iterative programs with arrays, we, by de-
fault, initialize array locations. We use x:=∗as a short-
hand for assignment of random values to all locations of
arrayx. In Example 5, x[1],x[2], andx[3] take random val-
ues assigned to them by x:=∗whereasx[4],...,x [13] are
assigned to by the inverse program subsequently. Similar
to the case of loop-free code, the wpcomputation ensures
failure-free execution in presence of random assignments.
Exploiting Dynamic Constraint Solving. We now illus-
trate how we handle references with an ambiguous status by
collecting constraints that are solved at run-time when the
inverse program executes. Consider the following example.
fori:= 1 to 8 do 1
y[i] :=x2[x1[i]]; 2
end3ensure(x1:∀i·ϕ(i)); 1
fori:= 1 to 8 do 2
x2[x1[i]] :=y[i]; 3
end4
(Example 6)
The setDofdetermined locations of x2at the beginning of
iterationiis given by {x2[x1[i′]]|(1≤i′≤8)∧(i′< i)}.
When processing the assignment y[i] :=x2[x1[i]], in Line 10,
the algorithm tries to determine whether location x2[x1[i]]
is in the set of locations D. Unlike earlier examples, the an-
swer in this case depends on the values assigned to x1. The
function CheckIfUndetermined symbolically simpliﬁes nega-
tion of the above membership test and returns the condition
ψ(i) =∀i′·((1≤i′≤8)∧(i′<i))⇒(x1[i′]/\e}atio\slash=x1[i]).
The function AddConstraint in Line 13 collects the set of
all such constraints ψ(i) generated during the processing ofthe loop body for each array reference separately. Once we
ﬁnish processing the loop body, we lift the constraint ψ(i)
(on a single iteration i) into a constraint on all iterations
by quantifying over all possible values of i. In the example
above, we have ∀i·ϕ(i) =∀i·(1≤i≤8)⇒ψ(i). We
call these constraints non-aliasing constraints . The function
NonAliasConstr inserts them as an assume statement preced-
ing the loop (Algorithm 7, Line 7). This allows us to con-
sider the reference x2[x1[i]] asundetermined , and invert the
assignment statement. The constraint is then propagated
backwards to form a part of the ensure() statement.
The non-aliasing constraints are universally quantiﬁed co n-
straints involving integer arithmetic and arrays due to ind i-
rection in array indexing similar to the example above. Giv-
ing a formal characterization of such constraints is beyond
the scope of this paper. We however introduce them here
since we encouter them in the Tiffcase study. In Section 4,
we discuss our speciﬁc implementation to solve them.
Loop-boundConstraints. Our algorithm inverts the loop
body locally, keeping the loop-structure the same. However ,
the loop bounds may be input (resp. output) variables of
the input (resp. inverse) program. An inverse is sound if
it accesses exactly those locations of an output array ythat
are assigned to by the input program. To ensure this, we
require the user to specify the size of an output array. The
speciﬁcation is a dependent type signature as the array size
depends on values of the input variables used as bounds of
the loops indexing over the array. We provide a function
sum(p,q) to indicate array sizes. sum(p,q) is summation of
p,qtimes. The arguments to sumcan be input variables
including array subscripts. Consider the following progra m.
Input : intn,m,x [sum(n,m)];
Output : intn′,m′,y[sum(n,m)];
k:= 1;1
fori:= 1 tondo 2
forj:= 1 tomdo 3
y[k] =x[m∗(i−1) +j];k:=k+ 1; 4
end5
end6
n′:=n;m′:=m;/* instrumentation */ 7
Consider the variable nthat appears in the dependent
type signature. Its run-time value is captured as an addi-
tional output variable n′by instrumenting the input pro-
gram. Since we are interested in equality of array sizes, we
emit what we call as loop-bound constraints in the inverse
program (Algorithm 7, Line 7). The loop-bound constraint
for the above program is sum(n,m) =sum(n′,m′). Note
thatnandmare the variables here, whereas, n′andm′take
the values generated by the input program. In inversion, the
instrumentation code in the input program is ignored and
these constraints are solved by the ensure() statement.
Correctness. The algorithm ensures that the control ﬂow
of the inverse program f′is isomorphic to that of the in-
put program f. Further, the conditional statements, loop-
structures, and assignments to local variables match synta c-
tically. Let x[n] be the output of f′on inputy′[m′]. Iff′
takes a path pin the execution then fwhen executed on x[n]
also takes the same path. Let y[m] be the output of fon
x[n]. The loop-bound constraint guarantees that m′=m.
We restrict the discussion to array locations only and ar-
gue thaty[k] =y′[k], for allk, such that 1 ≤k≤m. Forstrip 2
strip 1x1[2]
x1[1]x2[2]
x2[1]
(a) Stripsx3[l][w]
strip 1
strip 2w
l
(b) Pixelsy[l][w]strip 2
strip 1
(c) Pixelsy[l][w]
Figure 3: Essentials of Strip-based TIFF Images
simplicity, let there be only one syntactic assignment to yin
fof the form y[e1] :=x[e2] and the corresponding inverse
statement be x[e2] :=y[e1]. Lete1be function of a local
variablehande2be function of a loop counter i. Due to
the control ﬂow matching described above, whenever itakes
the same value in both the programs, the corresponding in-
stances ofhalso take the same value. This implies that
whenevere2evaluates to a value, say k′, in either program,
e1evaluates to the same value, say k, in both the programs.
We have assumed that fassigns to an array location y[k]
exactly once (Section 2) and the inversion algorithm guaran -
tees thatx[k′] is assigned exactly once. Thus, x[k′] =y′[k]
andy[k] =x[k′]. Further, as discussed in Section 3.1, the
ensure() statement guarantees failure-free execution.
Theorem 1.A programf′synthesized by Algorithm 1 is
a sound inverse of the input program fand is failure-free.
4. EXPERIMENTAL RESULTS
We demonstrate eﬀectiveness of our testing methodology
(Figure 1) on ﬁve popular Tiffimage [5] clients. One can
ﬁnd a large number of online discussions ( e.g., [1, 2, 3])
about a client’s dependence on speciﬁc encoding styles used
in common Tiff producers. Due to these reasons, Tiff
which stands for“Tagged Image File Format”is also jokingly
called “Thousands of Incompatible File Formats” [27], but
in fact, the problem is representation dependence of client s.
The speciﬁcation clearly states: “Where there are options,
TIFF writers can use whichever they want. Baseline TIFF
readers must be able to handle all of them.” (Section 7, [5]).
4.1 NormalizationofTIFF Images
We restrict our attention to strip-based grayscale images
without compression. We cover the ﬂexibility in the choice
of orientation, rows per strip, and layout of strips. We be-
lieve that several other variations ( e.g., tile-based, colored,
etc.) and equivalences ( e.g., byte and ﬁll ordering, planar
conﬁguration, etc.) can be analyzed with our technique.
However, compression seems beyond the scope of our current
algorithm. Without loss of generality, we take the followin g
deﬁnition of the Tiff data structure. We use the LibTiﬀ
library [21] to read and write a Tiffﬁle.
typedef struct tiﬀ{ 1
intorientation,n,w,r ; 2
intx1[N],x2[N],x3[N][N]; 3
}tiﬀ; 4inty[N][N]; 1
(a)Tiffdata structure (b) Canonical representation
The canonical representation of a tiﬀdata consists of a
2D bitmap y[N][N] whereNis the array size. As shown in
Figure 3(a), x1[i] gives the oﬀset of the i’th strip,x2[i] givesInput : intn,w,r,x 1[n],x2[n],x3[sum(n,x2[i])][w];
Output : intn′,w′,x′
2[n′],y[sum(n,x2[i])][w];
switchorientation do 1
case1/*left-to-right, top-to-bottom */ 2
m:= 1; 3
fori:=1 tondo 4
forj:=1 tox2[i]do 5
fork:=1 towdo 6
assume((i<n⇒x2[i] =r)∧(x2[n]≤r)); 7
y[m][k] :=x3[x1[i] +j][k]; 8
end 9
m:=m+ 1; 10
end 11
x′
2[i] :=x2[i];/* instrumentation */ 12
end 13
n′:=n;w′:=w;/* instrumentation */ 14
case2/*right-to-left, top-to-bottom */ 15
... y[m][k] :=x3[x1[i] +j][w−k]... 16
case... 17
end18
Figure 4: Normalization Program for TIFF Images
the number of rows in the i’th strip, and x3[x1[i]+j][k] gives
the pixel at the j’th row and k’th column of the i’th strip.
The actual number of strips is n. Generating the canonical
representation involves reading strips from 1 to n. The ori-
entation ﬂag indicates whether the pixel data is stored from
left-to-right or right-to-left and top-to-bottom or botto m-
to-top. Figures 3(b)-(c) indicate canonical representati on
of atiﬀdata for left-to-right top-to-bottom and right-to-
left bottom-to-top orientations respectively. We indicat e the
width and the length of an image by wandℓrespectively. ℓ
is not required to be part of the tiﬀdata structure. The nor-
malization program for tiﬀis given in Figure 4. For brevity,
we use the switch-case construct and do not give code for
all 8 possible orientations which diﬀer only in the innermos t
assignment statement. We also directly refer to elements of
thetiﬀdata structure instead of the usual struct notation.
The number of rows of all strips (except possibly the last)
should be equal to a rows per strip ﬁeld ras indicated by the
assume statement within the loop. It is possible to simplify
the deﬁnition of tiﬀto remove array x2and instead use
a scalar variable to indicate x2[n]. This however does not
make much diﬀerence to the overall eﬀectiveness of inversio n
and testing. Note that the dependent type signature and
instrumentation are used to specify loop-bound constraint s.
4.2 Implementation and Results
Our prototype implementation inverts the normalization
program and generates the following constraint for Case 1
(Figure 4) . The constraints for other cases are similar and
solved by ensure() when the inverse program is executed.
sum(n,x2[i]) =sum(n′,x′
2[i])∧w=w′(1)
∧(∀i·1≤i<n ⇒x2[i] =r)∧(x2[n]≤r) (2)
∧(∀i,j,k,i′,j′,k′·(i′,j′,k′)≺(i,j,k) (3)
⇒(x1[i] +j/\e}atio\slash=x1[i′] +j′)∨(k/\e}atio\slash=k′)) (4)
The constraints (1) are the loop-bound constraints. The
constraint (2) corresponds to the assume statements in the
input program. The constraint (3)–(4) is the non-aliasing
constraint. The relation ≺is the lexicographic ordering.
We solve these (quantiﬁed) constraints through heuristic i n-Application Orientation Rows per strip Layout
FastStone 3.6 ✓ ✓ ✓
KView 3.5.4 ✓ ✓ ✓
GIMP 2.2.13 ✗ ✓ ✓
Open Oﬃce 2.0.4 ✗ ✓ ✓
Picasa 3.6 ✗ ✓ ✗
Figure 5: Test Results for TIFF Clients
stantiation (cf. [14, 17]). We instantiate all non-constan t
quantiﬁer bounds and a suﬃcient number of variables in a
non-linear constraint until it becomes linear. In particu-
lar, we instantiate nby considering three cases: n < n′,
n=n′, andn> n′. The non-aliasing inequality constraint
is strengthened to the following strict ordering constrain ts:
∀i·(x1[i]+x2[i]≤x1[i+1])∨∀i·(x1[i+1]+x2[i+1]≤x1[i])
where 1 ≤i< n. After instantiating nto, sayκ, the loop-
bound constraint sum(n,x2[i]) =sum(n′,x′
2[i]) is expanded
tox2[1]+...+x2[κ] =x′
2[1]+...+x′
2[n′]. Recall that x′
2and
n′have pre-deﬁned values at run-time. Similarly, the univer-
sal quantiﬁcation is compiled into a ﬁnite conjunction with
the array subscript i(the quantiﬁed variable) ranging from 1
toκ−1. The resulting constraint is solved using Yices [16].
Typically, an SMT solver, including Yices, returns the same
solution every time for a constraint. To generate multiple
test cases, we solve the constraints multiple times by incre -
mentally adding a constraint to avoid the previous satisfyi ng
assignment. One of the satisfying assignments is then picke d
at random. The inverse program then executes determinis-
tically and copies the pixel data appropriately.
We take a Tiffﬁle displayed correctly by all the clients
and generate equivalent Tiffimages automatically. Despite
the heuristic as well as logical simpliﬁcation of the con-
straints and incompleteness in inversion and constraint so lv-
ing, we were able to ﬁnd several representation dependence
bugs. Figure 5 aggregates the results along various unde-
termined ﬁelds of tifffor a test run involving 40 images
generated from a single image. Layout indicates whether
the logically adjacent strips can be physically rearranged .
A✓indicates that the application passed all test cases and
✗means it failed for at least one. The success of a test
is determined by whether the client is able to display the
image correctly. Picasa 3.6 fails for combinations of orien -
tation and layout changes and without code inspection, we
cannot isolate the problem to one of the ﬁelds. We therefore
conservatively mark its dependence on both.
The automated inversion oﬀers several advantages over
manually written equivalence-preserving transformation s:
•While an (equivalence-preserving) transformation for
changing orientation is easy to write manually, other
variations require constraint solving. Our inversion al-
gorithm derives the desired constraints automatically.
•Intuitively, to produce equivalent Tiff images, it is
necessary to implicitly go through the canonical repre-
sentation. For instance, to redistribute the strips, one
has to ﬁrst construct the bitmap. Thus, the notions
of canonical representation and normalization program
are arguably central to this kind of testing.
•Since we can generate a large number of tests automat-
ically, the “no representation dependence” conclusions
(✓above) are more plausible.5. RELATED WORK
For an abstract datatype, representation exposure is said
to occur when an internal implementation of an aggregate
object is accessible for modiﬁcation outside the aggregate [12,
20]. Ownership type systems [13, 9, 6], and types for refer-
ence immutability [7] have been designed to prevent this.
But these systems still allow the inner workings of the ab-
stract datatype to be seen by its users. This phenomenon is
called observational exposure [10]. Our work can be viewed
as checking both kinds of exposures using testing. We check
if a client makes stronger logical assumptions on the rep-
resentation of data than those allowed by the speciﬁcation.
We are unaware of any type system that can perform the
equivalent of what we are doing.
Grammar-based testing [22, 26] is used for testing func-
tionality of grammar-driven software by enumerating test
data from a grammar deﬁnition. In our work, the explo-
ration of the syntactic space of data is driven by data equiv-
alence speciﬁcation in terms of normalization programs. Ko -
rat [8] systematically enumerates data instances from a dat a
structure invariant speciﬁed as a Java predicate. Test case
generation for representation dependence is a technically dif-
ferent problem. Given a test suite, metamorphic testing [11 ,
18, 23] generates new test cases to test a program using
known relations, called metamorphic relations, between in -
puts and outputs of the program. In contrast, our test gen-
eration is based on algorithmic inversion of normalization
programs with a more speciﬁc testing objective.
Dijkstra [15] observed that program inversion can be seen
as running a program backwards to map output to input.
Ross [24] encodes relational semantics of programs and uses
logic programming to compute inverses. Our approach uses
a forward reasoning and inverts program statements locally .
We can eﬀectively deal with imperative programs involv-
ing conditionals, loops, and arrays. Relational calculus h as
been used to derive program inverses, mainly of functional
programs [19, 25]. The derivations are typically deductive
whereas we give an algorithmic solution for inversion.
6. CONCLUSIONS
Representation dependence is a frequent problem in prac-
tice. Given a normalization program as a mapping from
a data instance to its canonical representation, we invert
it algorithmically to automate generation of test cases for
detecting representation dependence. We have tested Tiff
clients eﬀectively with this approach.
The technique of local inversion and deferring of staticall y
unsolvable constraints to run-time make the diﬃcult prob-
lem of program inversion practically solvable for an intere st-
ing class of programs including a class of iterative program s
with arrays. However, our approach has several limitations ,
namely, imprecise join operation and syntactic restrictio ns
on input programs outlined in Section 2. Program inversion
thus still remains an open problem at large. Automated
testing and analysis for representation dependence appear s
to be a challenging yet fruitful task ahead.
7. REFERENCES
[1] http://mail.python.org/pipermail/image-sig/1999-
may/000730.html.
[2] http://www.asmail.be/msg0055369928.html.
[3] http://www.zan1011.com/tiﬀ.htm.[4] www.gamedev.net/reference/articles/article538.as p.
[5] Adobe Dev. Assoc. TIFF Revision 6.0, June 1992.
[6] A. Banerjee and D. Naumann. Ownership conﬁnement
ensures representation independence for
object-oriented programs. J. ACM , 52:894–960, 2005.
[7] A. Birka and M. D. Ernst. A practical type system
and language for reference immutability. In OOPSLA ,
pages 35–49, 2004.
[8] C. Boyapati, S. Khurshid, and D. Marinov. Korat:
automated testing based on java predicates. In ISSTA ,
pages 123–133, 2002.
[9] C. Boyapati, B. Liskov, and L. Shrira. Ownership
types for object encapsulation. In POPL , pages
213–223, 2003.
[10] J. Boyland. Why we should not add readonly to Java
(yet). J. of Object Tech. , 5(5):5–29, June 2006.
[11] T. Y. Chen, S. C. Cheung, and S. M. Yiu.
Metamorphic testing: a new approach for generating
next test cases. Technical report, Hong Kong
University of Science and Technology, 1998.
[12] D. G. Clarke, J. Noble, and J. Potter. Overcoming
representation exposure. In Proc. of the Work. on
Object-Oriented Tech. , pages 149–151, 1999.
[13] D. G. Clarke, J. Potter, and J. Noble. Ownership
types for ﬂexible alias protection. In OOPSLA , pages
48–64, 1998.
[14] D. Detlefs, G. Nelson, and J. B. Saxe. Simplify: a
theorem prover for program checking. J. ACM ,
52(3):365–473, 2005.
[15] E. W. Dijkstra. Program inversion. In Program
Construction , volume 69 of LNCS , pages 54–57, 1978.
[16] B. Dutertre and L. De Moura. The Yices SMT solver.
Technical report, SRI, 2006.
[17] Y. Ge, C. W. Barrett, and C. Tinelli. Solving
quantiﬁed veriﬁcation conditions using satisﬁability
modulo theories. Ann. Math. Artif. Intell. ,
55(1-2):101–122, 2009.
[18] A. Gotlieb and B. Botella. Automated metamorphic
testing. In COMPSAC , page 34, 2003.
[19] D. Gries and J. L. van de Snepscheut. Inorder traversal
of a binary tree and its inversion. Formal Development
of Programs and Proofs , pages 37–42, 1990.
[20] J. Hogg, D. Lea, A. Wills, D. deChampeaux, and
R. Holt. The Geneva convention on the treatment of
object aliasing. OOPS Mess. , 3(2):11–16, 1992.
[21] http://www.libtiﬀ.org.
[22] P. M. Maurer. Generating test data with enhanced
context-free grammars. IEEE Soft. , 7(4):50–55, 1990.
[23] C. Murphy, K. Shen, and G. Kaiser. Automatic
system testing of programs without test oracles. In
ISSTA , pages 189–200, 2009.
[24] B. J. Ross. Running programs backwards: The logical
inversion of imperative computation. Formal Asp.
Comput. , 9(3):331–348, 1997.
[25] B. Schoenmakers. Inorder traversal of a binary heap
and its inversion in optimal time and space. In MPC,
volume 669 of LNCS , pages 291–301, 1992.
[26] M. Sutton, A. Greene, and P. Amini. Fuzzing: Brute
force vulnerability testing . Addison-Wesley, 2007.
[27] M. Trauth. MATLAB Recipes For Earth Sciences .
Springer, 2006.