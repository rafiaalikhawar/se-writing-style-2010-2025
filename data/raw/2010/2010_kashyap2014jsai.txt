JSAI: A Static Analysis Platform for JavaScript
Vineeth KashyapyKyle DeweyyEthan A. Kuefnery
John WagneryKevin GibbonsyJohn Sarracino?
Ben Wiedermann?Ben Hardekopfy
yUniversity of California Santa Barbara, USA?Harvey Mudd College, USA
ABSTRACT
JavaScript is used everywhere from the browser to the server,
including desktops and mobile devices. However, the cur-
rent state of the art in JavaScript static analysis lags far be-
hind that of other languages such as C and Java. Our goal
is to help remedy this lack. We describe JSAI, a formally
specied, robust abstract interpreter for JavaScript. JSAI
uses novel abstract domains to compute a reduced prod-
uct of type inference, pointer analysis, control-ow analysis,
string analysis, and integer and boolean constant propaga-
tion. Part of JSAI's novelty is user-congurable analysis sen-
sitivity, i.e., context-, path-, and heap-sensitivity. JSAI is
designed to be provably sound with respect to a specic con-
crete semantics for JavaScript, which has been extensively
tested against a commercial JavaScript implementation.
We provide a comprehensive evaluation of JSAI's perfor-
mance and precision using an extensive benchmark suite,
including real-world JavaScript applications, machine gener-
ated JavaScript code via Emscripten, and browser addons.
We use JSAI's congurability to evaluate a large number
of analysis sensitivities (some well-known, some novel) and
observe some surprising results that go against common wis-
dom. These results highlight the usefulness of a congurable
analysis platform such as JSAI.
Categories and Subject Descriptors
F.3.2 [ Semantics of Programming Languages ]: Pro-
gram analysis
General Terms
Languages, Algorithms, Verication
Keywords
JavaScript Analysis, Abstract Interpretation
1. INTRODUCTION
JavaScript is pervasive. While it began as a client-side
webpage scripting language, JavaScript has grown hugely in
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
FSE ‚Äô14, November 16‚Äì22, 2014, Hong Kong, China
Copyright 2014 ACM 978-1-4503-3056-5/14/11 ...$15.00.scope and popularity and is used to extend the functional-
ity of web browsers via browser addons, to develop desktop
applications (e.g., for Windows 8 [1]) and server-side appli-
cations (e.g., using Node.js [2]), and to develop mobile phone
applications (e.g., for Firefox OS [3]). JavaScript's growing
prominence means that secure, correct, maintainable, and
fast JavaScript code is becoming ever more critical. Static
analysis traditionally plays a large role in providing these
characteristics: it can be used for security auditing, error-
checking, debugging, optimization, program understanding,
refactoring, and more. However, JavaScript's inherently dy-
namic nature and many unintuitive quirks cause great di-
culty for static analysis.
Our goal is to overcome these diculties and provide a
formally specied, well-tested static analysis platform for
JavaScript, immediately useful for many client analyses such
as those listed above. In fact, we have used JSAI in previous
work to build a security auditing tool for browser addons [35]
and to experiment with strategies to improve analysis preci-
sion [36]. We have also used JSAI to build a static program
slicing [48] client and to build a novel abstract slicing [49]
client. These are only a few examples of JSAI's usefulness.
Several important characteristics distinguish JSAI from
existing JavaScript static analyses (which are discussed fur-
ther in Section 2):
JSAI is formally specied. We base our analysis on
formally specied concrete andabstract JavaScript se-
mantics. The two semantics are connected using ab-
stract interpretation; we have soundness proof sketches
for our most novel and interesting abstract analysis
domain. JSAI handles JavaScript as specied by the
ECMA 3 standard [22] (sans eval and family), and
various language extensions such as Typed Arrays [4].
JSAI's concrete semantics have been extensively tested
against an existing commercial JavaScript engine, and
the JSAI abstract semantics have been extensively tested
against the concrete semantics for soundness.
JSAI's analysis sensitivity (i.e., path-, context-, and
heap-sensitivity) are user-congurable independently
from the rest of the analysis. This means that JSAI al-
lows arbitrary sensitivities as dened by the user rather
than only allowing a small set of baked-in choices, and
that the sensitivity can be set independently from the
rest of the analysis or any client analyses.
JSAI's contributions include complete formalisms for con-
crete and abstract semantics for JavaScript along with im-
plementations of concrete and abstract interpreters basedon these semantics. While concrete semantics for JavaScript
have been proposed before, ours is the rst designed specif-
ically for abstract interpretation. Our abstract semantics is
the rst formal abstract semantics for JavaScript in the liter-
ature. The abstract interpreter implementation is the rst
available static analyzer for JavaScript that provides easy
congurability as a design goal. All these contributions are
available freely for download as supplementary materials1.
JSAI provides a solid foundation on which to build multiple
client analyses for JavaScript. The specic contributions of
this paper are:
The design of a JavaScript intermediate language and
concrete semantics intended specically for abstract
interpretation (Section 3.1).
The design of an abstract semantics that enables con-
gurable, sound abstract interpretation for JavaScript
(Section 3.2). This abstract semantics represents a
reduced product of type inference, pointer analysis,
control-ow analysis, string analysis, and number and
boolean constant propagation.
Novel abstract string and object domains for JavaScript
analysis (Section 3.3).
A discussion of JSAI's congurable analysis sensitivity,
including two novel context sensitivities for JavaScript
(Section 4).
An evaluation of JSAI's performance and precision on
the most comprehensive suite of benchmarks for Java-
Script static analysis that we are aware of, includ-
ing browser addons, machine-generated programs via
Emscripten [5], and open-source JavaScript programs
(Section 5). We showcase JSAI's congurability by
evaluating a large number of context-sensitivities, and
point out novel insights from the results.
We preface these contributions with a discussion of related
work (Section 2) and conclude with plans for future work
(Section 6).
2. RELATED WORK
In this section we discuss existing static analyses and hy-
brid static/dynamic analyses for JavaScript and discuss pre-
vious eorts to formally specify JavaScript semantics.
JavaScript Analyses. The current state-of-the-art static
analyses for JavaScript usually take one of two approaches:
(1)an unsound2dataow analysis-based approach using
baked-in abstractions and analysis sensitivities [17, 26, 31],
or(2)a formally-specied type system requiring annota-
tions to existing code, proven sound with respect to a specic
JavaScript formal semantics but restricted to a small subset
of the full JavaScript language [45, 30, 19, 28]. No existing
JavaScript analyses are formally specied, implemented us-
ing an executable abstract semantics, tested against a formal
concrete semantics, or target congurable sensitivity.
1http://www.cs.ucsb.edu/~pllab , under Downloads .
2Most examples of this approach are intentionally unsound
as a design decision, in order to handle the many dicul-
ties raised by JavaScript analysis. Unsound analysis can be
useful in some circumstances, but for many purposes (e.g.,
security auditing) soundness is a key requirement.The closest related work to JSAI is the JavaScript static
analyzer TAJS by Jensen et al [32, 33, 34]. While TAJS is
intended to be a sound analysis of the entire JavaScript lan-
guage (sans dynamic code injection), it does not possess any
of the characteristics of JSAI described in Section 1. The
TAJS analysis is not formally specied and the TAJS papers
have insucient information to reproduce the analysis; also
the analysis implementation is not well documented, mak-
ing it dicult to build client analyses or modify the main
TAJS analysis. In the process of formally specifying JSAI,
we uncovered several previously unknown soundness bugs
in TAJS that were conrmed by the TAJS authors. This
serves to highlight the importance and usefulness of formal
specication.
Various previous works [15, 45, 31, 39, 25, 44, 24] pro-
pose dierent subsets of the JavaScript language and pro-
vide analyses for that subset. These analyses range from
type inference, to pointer analysis, to numeric range and
kind analysis. None of these handle the full complexities of
JavaScript. Several intentionally unsound analyses [40, 17,
6, 47, 23] have been proposed, while other works [31, 26] take
a best-eort approach to soundness, without any assurance
that the analysis is actually sound. None of these eorts
attempt to formally specify the analysis they implement.
Several type systems [45, 30, 28, 19] have been proposed
to retrot JavaScript (or subsets thereof) with static types.
Guha et. al. [28] propose a novel combination of type sys-
tems and ow analysis. Chugh et. al. [19] propose a ow-
sensitive renement type system designed to allow typing of
common JavaScript idioms. These type systems require pro-
grammer annotations and cannot be used as-is on real-world
JavaScript programs.
Combinations of static analysis with dynamic checks [25,
20] have also been proposed. These systems statically ana-
lyze a subset of JavaScript under certain assumptions and
use runtime checks to enforce these assumptions. Sch afer
et al. [42] use a dynamic analysis to determine information
that can be leveraged to scale static analysis for JavaScript.
These ideas are complementary to and can supplement our
purely static techniques.
JavaScript Formalisms. None of the previous work on
static analysis of JavaScript have formally specied the anal-
ysis. However, there has been previous work on providing
JavaScript with a formal concrete semantics. Maeis et.
al [41] give a structural smallstep operational semantics di-
rectly to the full JavaScript language (omitting a few con-
structs). Lee et. al [38] propose SAFE, a semantic frame-
work that provides structural bigstep operational semantics
to JavaScript, based directly on the ECMAScript specica-
tion. Due to their size and complexity, neither of these se-
mantic formulations are suitable for direct translation into
an abstract interpreter.
Guha et. al [27] propose a core calculus approach to pro-
vide semantics to JavaScript|they provide a desugarer from
JavaScript to a core calculus called JS, which has a small-
step structural operational semantics. Their intention was
to provide a minimal core calculus that would ease proving
soundness for type systems, thus placing all the complexity
in the desugarer. However, their core calculus is too low-
level to perform a precise and scalable static analysis (for
example, some of the semantic structure that is critical for
a precise analysis is lost, and their desugaring causes a largecode bloat|more than 200 on average). We also use the
core calculus approach; however, our own intermediate lan-
guage, called notJS, is designed to be in a sweet-spot that
favors static analysis (for example, the code bloat due to
our translation is between 6  8on average). In addition,
we use an abstract machine-based semantics rather than a
structural semantics, which (as described later) is the prime
enabler for congurable analysis sensitivity.
Congurable Sensitivity. Bravenboer and Smaragdakis
introduce the DOOP framework [18] that performs ow-
insensitive points-to analysis for Java programs using a declar-
ative specication in Datalog. Several context-sensitive ver-
sions [43, 37] of the points-to analysis are expressible in this
framework as modular variations of a common code base.
Their framework would require signicant changes to en-
able ow-sensitive analysis (especially for a language like
JavaScript, which requires an extensive analysis to com-
pute a sound SSA form) like ours, and they cannot express
arbitrary analysis sensitivities (including path sensitivities)
modularly the way that JSAI can.
3. JSAI DESIGN
We break our discussion of the JSAI design into three
main components: (1)the design of an intermediate repre-
sentation (IR) for JavaScript programs, called notJS, along
with its concrete semantics; (2)the design of an abstract se-
mantics for notJS that yields the reduced product of a num-
ber of essential sub-analyses and also enables congurable
analysis; and (3)the design of novel abstract domains for
JavaScript analysis. We conclude with a discussion of vari-
ous options for handling dynamic code injection.
The intent of this section is to discuss the design decisions
that went into JSAI, rather than giving a comprehensive de-
scription of the various formalisms (e.g., the translation from
JavaScript to notJS, the concrete semantics of notJS, and
the abstract semantics of notJS). All of these formalisms,
along with their implementations, are available in the sup-
plementary materials.
3.1 Designing the notJS IR
JavaScript's many idiosyncrasies and quirky behaviors mo-
tivate the use of formal specications for both the concrete
JavaScript semantics and our abstract analysis semantics.
Our approach is to dene an intermediate language called
notJS, along with a formally-specied translation from Java-
Script to notJS. We then give notJS a formal concrete se-
mantics upon which we base our abstract interpreter.3
Figure 1 shows the abstract syntax of notJS, which was
carefully designed with the ultimate goal of making abstract
interpretation simple, precise, and ecient. The IR contains
literal expressions for numeric, boolean values and for undef
and null. Object values are expressed with the newcon-
struct, and function values are expressed with the newfun
construct. The IR directly supports exceptions via throw
and try-catch-n ; it supports other non-local control ow
(e.g., JavaScript's return ,break , and continue ) via the jump
construct. The IR supports two forms of loops: while and
for. The forconstruct corresponds to JavaScript's reective
for..in statement, which allows the programmer to iterate
3Guha et al [27] use a similar approach, but our IR design
and formal semantics are quite dierent. See Section 2 for
a discussion of the dierences between our two approaches.over the elds of an object. A method takes exactly two
arguments: self and args, referring to the this object and
arguments object; all variants of JavaScript method calls can
be translated to this form. The toobj,tobool ,tostr,tonum and
isprim constructs are the explicit analogues of JavaScript's
implicit conversions. JavaScript's builtin objects (e.g,. Math)
and methods (e.g., isNaN ) are properties of the global object
that is constructed prior to a program's execution, thus they
are not a part of the IR syntax.
n2Numb2Bool str2String x2Variable`2Label
s2Stmt ::=~sijife s1s2jwhile e sjx:=eje1:e2:=e3
jx:=e1(e2;e3)jx:=toobjejx:=dele1:e2
jx:=newfunmnjx:=newe1(e2)jthrow e
jtry-catch-n s1xs2s3j`sjjump`ejforxes
e2Exp::=njbjstrjundefjnulljxjmje1e2j e
d2Decl ::=decl    !xi=eiins
m2Meth ::= ( self;args))dj(self;args))s
2BinOp ::= +j   j  j  j %j< <j> >j> > >j<
jj &j0j0jYjandjorj+ +jj
jjj:jinstanceofjin
2UnOp ::=  j j : j typeofjisprimjtobool
jtostrjtonum
Figure 1: The abstract syntax of notJS provides canonical con-
structs that simplify JavaScript's behavior. The vector notation
represents (by abuse of notation) an ordered sequence of unspec-
ied length n, whereiranges from 0 to n 1.
Note that our intermediate language is notbased on a
control-ow graph but rather on an abstract syntax tree
(AST), further distinguishing it from existing JavaScript
analyses. JavaScript's higher-order functions, implicit ex-
ceptions, and implicit type conversions (that can execute
arbitrary user-dened code) make a program's control-ow
extremely dicult to precisely characterize without exten-
sive analysis of the very kind we are using the intermedi-
ate language to carry out. Other JavaScript analyses that
do use a ow-graph approach start by approximating the
control-ow and then ll in more control-ow information
in an ad-hoc manner as the analysis progresses; this leads
to both imprecision and unsoundness (for example, one of
the soundness bugs we discovered in TAJS was directly due
to this issue). JSAI uses the smallstep abstract machine se-
mantics to determine control-ow during the analysis itself
in a sound manner.
An important design decision we made is to carefully sep-
arate the language into pure expressions ( e2Exp) that
are guaranteed to terminate without throwing an exception,
and impure statements ( s2Stmt ) that do not have these
guarantees. This decision directly impacts the formal se-
mantics and implementation of notJS by reducing the size
of the formal semantics4and the corresponding code to one-
third of the previous size compared to a version without
this separation, and vastly simplifying them. This is the
rst IR for JavaScript we are aware of that makes this de-
sign choice|it is a more radical choice than might rst be
apparent, because JavaScript's implicit conversions make it
4Specically, the number of semantic continuations and
transition rules.dicult to enforce this separation without careful thought.
Other design decisions of note include making JavaScript's
implicit conversions (which are complex and dicult to rea-
son about, involving multiple steps and alternatives depend-
ing on the current state of the program) explicit in notJS
(the constructs toobj,isprim ,tobool ,tostr,tonum are used for
this); leaving certain JavaScript constructs unlowered to al-
low for a more precise abstract semantics (e.g., the for..in
loop, which we leave mostly intact as forxes); and simpli-
fying method calls to make the implicit this parameter and
arguments object explicit; this is often, but not always, the
address of a method's receiver object, and its value can be
non-intuitive, while arguments provides a form of reection
providing access to a method's arguments.
Given the notJS abstract syntax, we need to design a for-
mal concrete semantics that (together with the translation
to notJS) captures JavaScript behavior. We have two main
criteria: (1)the semantics should be specied in a man-
ner that can be directly converted into an implementation,
allowing us to test its behavior against actual JavaScript
implementations; (2)looking ahead to the abstract version
of the semantics (which denes our analysis), the seman-
tics should be specied in a manner that allows for cong-
urable sensitivity. These requirements lead us to specify the
notJS semantics as an abstract machine-based smallstep op-
erational semantics. One can think of this semantics as an
innite state transition system, wherein we formally dene
a notion of state and a set of transition rules that connect
states. The semantics is implemented by turning the state
denition into a data structure (e.g., a Scala class) and the
transition rules into functions that transform a given state
into the next state. The concrete interpreter starts with an
initial state (containing the start of the program and all of
the builtin JavaScript methods and objects), and continually
computes the next state until the program nishes.
We omit further details of the concrete semantics for space
and because they have much in common with the abstract
semantics described in the next section. The main dierence
between the two is that the abstract state employs sets in
places where the concrete state employs singletons, and the
abstract transition rules are nondeterministic whereas the
concrete rules are deterministic. Both of these dierences
are because the abstract semantics over-approximates the
concrete semantics.
Testing the Semantics. We tested the translation to
notJS, the notJS semantics, and implementations thereof
by comparing the resulting program execution behavior with
that of a commercial JavaScript engine, SpiderMonkey [7].
We rst manually constructed a test suite of over 243 pro-
grams that were either hand-crafted to exercise various parts
of the semantics, or taken from existing JavaScript programs
used to test commercial JavaScript implementations. We
then added over one million randomly generated JavaScript
programs to the test suite. We ran all of the programs in
the test suite on SpiderMonkey and on our concrete inter-
preter, and we veried that they produce identical output.
Because the ECMA specication is informal we can never
completely guarantee that the notJS semantics is equivalent
to the spec, but we can do as well as other JavaScript imple-
mentations, which also use testing to establish conformance
with the ECMA specication.
3.2 Designing the Abstract SemanticsThe JavaScript static analysis is dened as an abstract
semantics for notJS that over-approximates the notJS con-
crete semantics. The analysis is implemented by computing
the set of all abstract states reachable from a given initial
state by following the abstract transition rules. The analysis
contains some special machinery that provides congurable
sensitivity. We illustrate our approach via a worklist algo-
rithm that ties these concepts together:
Algorithm 1 The JSAI worklist algorithm
1: put the initial abstract state ^ &0on the worklist
2: initialize map partition :Trace!State]to empty
3:repeat
4: remove an abstract state ^ &from the worklist
5: for all abstract states ^ &0innext_states (^&)do
6: ifpartition does not contain trace (^&0)then
7: partition (trace (^&0)) = ^&0
8: put ^ &0on worklist
9: else
10: ^ &old=partition (trace (^&0))
11: ^ &new= ^&oldt^&0
12: if^&new6= ^&oldthen
13: partition (trace (^&0)) = ^&new
14: put ^ &newon worklist
15: end if
16: end if
17: end for
18:until worklist is empty
The static analysis performed by this worklist algorithm is
determined by the denitions of the abstract semantic states
^&2State], the abstract transition rules5next_states2
State]!P(State]), and the knob that congures the anal-
ysis sensitivity trace (^&).
Abstract Semantic Domains. Figure 2 shows our def-
inition of an abstract state for notJS. An abstract state ^ &
consists of a term that is either a notJS statement or an
abstract value that is the result of evaluating a statement;
anenvironment that maps variables to (sets of) addresses; a
store mapping addresses to either abstract values, abstract
objects, or sets of continuations (to enforce computability for
abstract semantics that use semantic continuations, as per
Van Horn and Might [46]); and nally a continuation stack
that represents the remaining computations to perform|
one can think of this component as analogous to a runtime
stack that remembers computations that should completed
once the current computation is nished.
Abstract values are either exception/jump values ( EValue],
JValue]), used to handle non-local control-ow, or base val-
ues ( BValue]), used to represent JavaScript values. Base
values are a tuple of abstract numbers, booleans, strings,
addresses, null, and undened; each of these components
is a lattice. Base values are dened as tuples because the
analysis over-approximates the concrete semantics, and thus
cannot constrain values to be only a single type at a time.
These value tuples yield a type inference analysis: any com-
ponent of this tuple that is a lattice ?represents a type that
this value cannot contain. Base values do not include func-
tion closures, because functions in JavaScript are actually
5Omitted for space; available in supplementary materials.^n2Num]cstr2String]^a2Address]^2UnOp]^2BinOp]
^&2State]=Term]Env]Store]Kont]
^t2Term]=Decl +Stmt +Value]
^2Env]=Variable!P(Address])
^2Store]=Address]!(BValue]+Object]+P(Kont]))
cbv2BValue]=Num]P(Bool)String]P(Address])
P(fnullg)P(fundefg)
^o2Object]= (String]!BValue])P(String )
(String!(BValue]+Class +P(Closure])))
c2Class =ffunction;array;string;boolean;number;date;
error;regexp;arguments;object;:::g
cclo2Closure]=Env]Meth
cev2EValue]::=excbv
bjv2JValue]::=jmp`cbv
^v2Value]=BValue]+EValue]+JValue]
^2Kont]::=\haltKj[seqK~si^j\whileK e s^jdlblK`^
jdforK !cstrix s^j[retK x^^ctorj[retK x^^call
j[tryK x s s^j\catchK s^jdnK ^v^j\addrK ^a
Figure 2: Abstract semantic domains for notJS.
objects. Instead, we dene a class of abstract objects that
correspond to functions and that contain a set of closures
that are used when that object is called as a function. We
describe our novel abstract object domain in more detail in
Section 3.3.
Each component of the tuple also represents an individual
analysis: the abstract number domain determines a num-
ber analysis, the abstract string domain determines a string
analysis, the abstract addresses domain determines a pointer
analysis, etc. Composing the individual analyses represented
by the components of the value tuple is not a trivial task;
a simple cartesian product of these domains (which corre-
sponds to running each analysis independently, without us-
ing information from the other analyses) would be imprecise
to the point of being useless. Instead, we specify a reduced
product [21] of the individual analyses, which means that
we dene the semantics so that each individual domain can
take advantage of the other domains' information to improve
their results. The abstract number and string domains are
intentionally unspecied in the semantics; they are cong-
urable. We discuss our specic implementations of the ab-
stract string domain in Section 3.3.
Together, all of these abstract domains dene a set of
simultaneous analyses: control-ow analysis (for each call-
site, which methods may be called), pointer analysis (for
each object reference, which objects may be accessed), type
inference (for each value, can it be a number, a boolean,
a string, null,undef , or a particular class of object), and
extended versions of boolean, number, and string constant
propagation (for each boolean, number and string value, is
it a known constant value). These analyses combine to give
detailed control- and data-ow information forming a fun-
damental analysis that can be used by many possible clients
(e.g., error detection, program slicing, secure information
ow, etc).Current State ^ & Next State ^ &0
1hs::~ si;^;^;^i h s;^;^;[seqK~ si^i
2hcbv;^;^;[seqKs::~ si^i hs;^;^;[seqK~ si^i
3hcbv;^;^;[seqK^i hcbv;^;^;^i
4hifes1s2;^;^;^i hs1;^;^;^iiftrue2^b(JeK)
5hifes1s2;^;^;^i hs2;^;^;^iiffalse2^b(JeK)
Figure 3: A small subset of the abstract semantics rules for JSAI.
Each smallstep rule describes a transition relation from one ab-
stract state &to the next state ^ &0. The phrase ^b(JeK) means to
evaluate expression eto an abstract base value, then project out
its boolean component.
Abstract Transition Rules. Figure 3 describes a small
subset of the abstract transition rules to give their avor. To
compute next_states (^&), the components of ^ &are matched
against the premises of the rules to nd which rule(s) are
relevant; that rule then describes the next state (if multiple
rules apply, then there will be multiple next states). The
rules 1;2 and 3 deal with sequences of statements. Rule 1
says that if the state's term is a sequence, then pick the rst
statement in the sequence to be the next state's term; then
take the rest of the sequence and put it in a seqK continua-
tion for the next state, pushing it on top of the continuation
stack. Rule 2 says that if the state's term is a base value
(and hence we have completed the evaluation of a state-
ment), take the next statement from the seqK continuation
and make it the term for the next state. Rule 3 says that if
there are no more statements in the sequence, pop the seqK
continuation o of the continuation stack. The rules 4 and 5
deal with conditionals. Rule 4 says that if the guard expres-
sion evaluates to an abstract value that over-approximates
true, make the truebranch statement the term for the next
state; rule 5 is similar except it takes the false branch. Note
that these rules are nondeterministic, in that the same state
can match both rules.
Congurable Sensitivity. To enable congurable sensi-
tivity, we build on the insights of Hardekopf et al [29]. We
extend the abstract state to include an additional compo-
nent from a Trace abstract domain. The worklist algorithm
uses the trace function to map each abstract state to its
trace, and joins together all reachable abstract states that
map to the same trace (see lines 10{11 of Algorithm 1). The
denition of Trace is left to the analysis designer; dierent
denitions yield dierent sensitivities. For example, sup-
pose Trace is dened as the set of program points, and an
individual state's trace is the current program point. Then
our worklist algorithm computes a ow-sensitive, context-
insensitive analysis: all states at the same program point are
joined together, yielding one state per program point. Sup-
pose we redene Trace to be sequences of program points,
and an individual state's trace to be the last kcall-sites.
Then our worklist algorithm computes a ow-sensitive, k-
CFA context-sensitive analysis. Arbitrary sensitivities (in-
cluding path-sensitivity and property simulation) can be de-
ned in this manner solely by redening Trace , without
aecting the worklist algorithm or the abstract transition
rules. We explore a number of possibilities in Section 5.
3.3 Novel Abstract Domains
JSAI allows congurable abstract number and string do->
SNotSpl SNotNum
SNum SNotNumNorSpl SSpl
"1""2" "foo" "bar" "valueOf"
?
Figure 4: Our default string abstract domain, further explained
in Section 3.3.
mains, but we also provide default domains based on our
experience with JavaScript analysis. We motivate and de-
scribe our default abstract string domain here. We also de-
scribe our novel abstract object domain, which is an integral
part of the JSAI abstract semantics.
Abstract Strings. Our initial abstract string domain String]
was an extended string constant domain. The elements were
either constant strings, or strings that are denitely num-
bers, or strings that are denitely not numbers, or >(a
completely unknown string). This string domain is simi-
lar to the one used by TAJS [33], and it is motivated by
the precision gained while analyzing arrays: arrays are just
objects where array indices are represented with numeric
string properties such as "0","1", etc, but they also have
non-numeric properties like "length" . However, this initial
string domain was inadequate.
In particular, we discovered a need to express that a string
isnotcontained within a given hard-coded set of strings.
Consider the property lookup x := obj[y] , where yis a vari-
able that resolves to an unknown string. Because the string
is unknown, the analysis is forced to assign to xnot only
the lattice join of all values contained in obj, but also the
lattice join of all the values contained in all prototypes of
obj, due to the rules of prototype-based inheritance. Almost
all object prototype chains terminate in one of the builtin
objects contained in the global object ( Object.prototype ,
Array.prototype , etc); these builtin objects contain the builtin
values and methods. Thus, all of these builtin values and
methods are returned for any object property access based
on an unknown string, polluting the analysis. One possible
way to mitigate this problem is to use an expensive domain
that can express arbitrary complements (i.e., express that
a string is notcontained in some arbitrary set of strings).
Instead, we extend the string domain to separate out special
strings ( valueOf ,toString etc, xed ahead of time) from the
rest; these special strings are drawn from property names
of builtin values and methods. We can thus express that a
string has an unknown value that is notone of the special
values. This is a practical solution that improves precision
at minimal cost.
The new abstract string domain depicted in Figure 4 (that
separates unknown strings into numeric, non-numeric and
special strings) was simple to implement due to JSAI's con-
gurable architecture; it did not require changes to any other
parts of the implementation despite the pervasive use of
strings in all aspects of JavaScript semantics.
Abstract Objects. We highlight the abstract domain Object]
given in Figure 2 as a novel contribution. Previous JavaScriptanalyses model abstract objects as a tuple containing (1)a
map from property names to values; and (2)a list of de-
nitely present properties (necessary because property names
are just strings, and objects can be modied using unknown
strings as property names). However, according to the ECMA
standard objects can be of dierent classes , such as func-
tions, arrays, dates, regexps, etc. While these are all objects
and share many similarities, there are semantic dierences
between objects of dierent classes. For example, the length
property of array objects has semantic signicance: assign-
ing a value to length can implicitly add or delete properties
to the array object, and certain values cannot be assigned to
length without raising a runtime exception. Non-array ob-
jects can also have a length eld, but assigning to that eld
will have no other eect. The object's class dictates the
semantics of property enumerate, update, and delete oper-
ations on an object. Thus, the analysis must track what
classes an abstract object may belong to in order to accu-
rately model these semantic dierences. If abstract objects
can belong to arbitrary sets of classes, this tracking and
modeling becomes complex, error-prone, and inecient.
Our innovation is to add a map as the third component
of abstract objects that contains class-specic values. This
component also records which class an abstract object be-
longs to. Finally, the semantics is designed so that any given
abstract object must belong to exactly one class. This is en-
forced by assigning abstract addresses to objects based not
just on their static allocation site and context, but also on
the constructor used to create the object (which determines
its class). The resulting abstract semantics is much simpler,
more ecient, and precise.
4. SHOWCASING CONFIGURABILITY
Analysis sensitivity (path-, context-, and heap-sensitivity)
hsa a signicant impact on the usefulness and practicality of
the analysis. The sensitivity represents a tradeo between
precision and performance: the more sensitive the analysis
is the more precise it can be, but also the more costly it can
be. The \sweet-spot" in this tradeo varies from analysis
to analysis and from program to program. JSAI allows the
user to easily specify dierent sensitivities in a modular way,
separately from the rest of the analysis.
A particularly important dimension of sensitivity is context-
sensitivity : how the (potentially innite) possible method
call instances are partitioned and merged into a nite num-
ber of abstract instances. The current state of the art for
JavaScript static analysis has explored only a few possible
context-sensitivity strategies, all of which are baked into the
analysis and dicult to change, with no real basis for choos-
ing these over other possible strategies.
We take advantage of JSAI's congurability to dene and
evaluate a much larger selection of context-sensitivities than
has ever been evaluated before in a single paper. Because
of JSAI's design, specifying each sensitivity takes only 5{20
lines of code; previous analysis implementations would have
to hard-code each sensitivity from scratch. The JSAI anal-
ysis designer species a sensitivity by instantiating a par-
ticular instance of Trace ; all abstract states with the same
trace will be merged together. For context-sensitivity, we
dene Trace to include some notion of the calling context,
so that states in the same context are merged while states
in dierent contexts are kept separate.
We implement six main context-sensitivity strategies, eachparameterized in various ways, yielding a total of 56 dif-
ferent forms of context-sensitivity. All of our sensitivities
are ow-sensitive (JavaScript's dynamic nature means that
ow-insensitive analyses tend to have terrible precision). We
empirically evaluate all of these strategies in Section 5; here
we dene the six main strategies. Four of the six strate-
gies are known in the literature, while two are novel to this
paper. The novel strategies are based on two hypotheses
about context denitions that might provide a good balance
between precision and performance. Our empirical evalua-
tion demonstrates that these hypotheses are false, i.e., they
do not provide any substantial benet. We include them
here not as examples of good sensitivities to use, but rather
to demonstrate that JSAI makes it easy to formulate and
test hypotheses about analysis strategies|each novel strat-
egy took only 15{20 minutes to implement. The strategies
we dened are as follows, where the rst four are known and
the last two are novel:
Context-insensitive. All calls to a given method are merged.
We dene the context component of Trace to be a unit value,
so that all contexts are the same.
Stack-CFA. Contexts are distinguished by the list of call-
sites on the call-stack. This strategy is k-limited to ensure
there are only a nite number of possible contexts. We dene
theTrace component to contain the top kcall-sites.
Acyclic-CFA. Contexts are distinguished the same as Stack-
CFA, but instead of k-limiting we collapse recursive call cy-
cles. We dene Trace to contain all call-sites on the call-
stack, except that cycles are collapsed.
Object-sensitive. Contexts are distinguished by a list
of addresses corresponding to the chain of receiver objects
(corresponding to full-object-sensitivity in Smaragdakis et
al. [43]). We dene Trace to contain this information ( k-
limited to ensure nite contexts).
Signature-CFA. Type information is important for dy-
namically typed languages, so intuitively it seems that type
information would make good contexts. We hypothesize
that dening Trace to record the types of a call's arguments
would be a good context-sensitivity, so that all k-limited call
paths with the same types of arguments would be merged.
Mixed-CFA. Object-sensitivity uses the address of the re-
ceiver object. However, in JavaScript the receiver object
is often the global object created at the beginning of the
program execution. Intuitively, it seems this would mean
that object sensitivity might merge many calls that should
be kept separate. We hypothesized that it might be bene-
cial to dene Trace as a modied object-sensitive strategy|
when object-sensitivity would use the address of the global
object, this strategy uses the current call-site instead.
5. EVALUATION
In this section we evaluate JSAI's precision and perfor-
mance for a range of context-sensitivities as described in
Section 4, for a total of 56 distinct sensitivities. We run each
sensitivity on 28 benchmarks collected from four dierent
application domains and analyze the results, yielding sur-
prising observations about context-sensitivity and JavaScript.
We also briey evaluate JSAI as compared to TAJS [33], the
most comparable existing JavaScript analysis.5.1 Implementation and Methodology
We implement JSAI using Scala version 2.10. We pro-
vide a model for the DOM, event handling loop (handled
as non-deterministic execution of event-handling functions),
and other native APIs used in our benchmarks. The baseline
analysis sensitivity we evaluate is fs(ow-sensitive, context-
insensitive); all of the other evaluated sensitivities are more
precise than fs. The other sensitivities are: k.h-stack ,h-acyclic ,
k.h-obj,k.h-sig, andk.h-mixed , wherekis the context depth
fork-limiting and his the heap-sensitivity (i.e., the context
depth used to distinguish abstract addresses). The parame-
terskandhvary from 1 to 5 and hk.
We use a comprehensive benchmark suite to evaluate the
sensitivities. Most prior work on JavaScript static analysis
has been evaluated only on the standard SunSpider [8] and
V8 [9] benchmarks, with a few micro-benchmarks thrown
in. We evaluate JSAI on these standard benchmarks, but
we also include real-world representatives from a diverse set
of JavaScript application domains. We choose seven rep-
resentative programs from each domain, for a total of 28
programs. We partition the programs into four categories,
described below. For each category, we provide the mean
size of the benchmarks in the suite (expressed as number
of AST nodes generated by the Rhino parser [10]) and the
mean translator blowup (i.e., the factor by which the num-
ber of AST nodes increases when translating from JavaScript
to notJS). The benchmark names are shown in the graphs
presented below; the benchmark suite is included in the sup-
plementary material.
The benchmark categories are: standard : seven of the
largest, most complex benchmarks from SunSpider [8] and
V8 [9] ( mean size: 2858 nodes; mean blowup: 8 );addon :
seven Firefox browser addons selected from the ocial Mozilla
addon repository [11] ( mean size: 2597 nodes; mean blowup:
6);generated : seven programs from the Emscripten LLVM
test suite, which translates LLVM bitcode to JavaScript [5]
(mean size: 38211 nodes; mean blowup: 7 ); and nally
opensrc : seven real-world JavaScript programs taken from
open source JavaScript frameworks and their test suites [12,
13] ( mean size: 8784 nodes; mean blowup: 6.4 ).
Our goal is to evaluate the precision and performance of
JSAI instantiated with several forms of context sensitiv-
ity. However, the dierent sensitivities yield diering sets
of function contexts and abstract addresses, making a fair
comparison dicult. Therefore, rather than statistical mea-
surements (such as address-set size or closure-set size), we
choose a client-based precision metric based on a error re-
porting client. This metric is a proxy for the precision of
the analysis.
Our precision metric reports the number of static program
locations (i.e., AST nodes) that might throw exceptions,
based on the analysis' ability to precisely track types. Java-
Script throws a TypeError exception when a program at-
tempts to call a non-function or when a program tries to ac-
cess, update, or delete a property of nullorundef . JavaScript
throws a RangeError exception when a program attempts to
update the length property of an array to contain a value
that is not an unsigned 32-bit integer. Fewer errors indicate
a more precise analysis.
The performance metric we use is execution time of the
analysis. To gather data on execution time, we run each
experimental conguration 11 times, discard the rst result,
then report the median of the remaining 10 trials. We set atime limit of 30 minutes for each run, reporting a timeout
if execution time exceeds that threshold. We run all ex-
periments on Amazon Web Services [14] (AWS), using M1
XLarge instances; each experiment is run on an indepen-
dent AWS instance. These instances have 15GB memory
and 8 ECUs, where each ECU is equivalent CPU capacity
of a 1.0-1.2 GHz 2007 Opteron or 2007 Xeon processor.
We run all 56 analyses on each of the 28 benchmarks, for
a total of 1,568 trials (multiplied by an additional 10 execu-
tions for each analysis/benchmark pair for the timing data).
For reasons of space, we present only highlights of these re-
sults. In some cases, we present illustrative examples; the
omitted results show similar behavior. In other cases, we
deliberately cherry-pick, to highlight contrasts. We are ex-
plicit about our approach in each case.
(a) addon benchmarkstryagainodesk_job_wat‚Ä¶less_spam_ple‚Ä¶live_pagerankcoffee_pods_d‚Ä¶chesspinpoints(b) generated benchmarksfastallubenchmarkfourinarowahasgefahashtestfannkuch(c) opensrc benchmarksrsalinq_aggregateaeslinq_enumerablelinq_functionallinq_actionlinq_dictionary(d) standard benchmarkscrypto-sha1richardssplay3d-cubeaccess-nbody3d-raytracecryptobench 1.0-stack 5.4-stack 4-acyclic 1.0-obj 5.4-obj 1.0-sig 5.4-sig 1.0-mixed 5.4-mixed fs
Figure 6: A heat map to showcase the performance characteris-
tics of dierent sensitivities across the benchmark categories. The
above gure is a two-dimensional map of blocks; rows correspond
to benchmarks, and columns correspond to analysis run with a
particular sensitivity. The color in a block indicates a sensitiv-
ities' relative performance on the corresponding benchmark, as
compared to fastest sensitivity on that benchmark. Darker col-
ors represent better performance. Completely blackened blocks
indicate that the corresponding sensitivity has the fastest anal-
ysis time on that benchmark, while completely whitened blocks
indicate that the corresponding sensitivity does not time out, but
has a relative slowdown of at least 2 . The remaining colors are
of evenly decreasing contrast from black to white, representing a
slowdown between 1 to 2. The red grid pattern on a block
indicates a timeout.
5.2 Observations
For each main sensitivity strategy, we present the datafor two trials: the least precise sensitivity in that strategy,
and the most precise sensitivity in that strategy. This set of
analyses is: fs,1.0-stack ,5.4-stack ,4-acyclic ,1.0-obj ,5.4-obj ,
1.0-sig ,5.4-sig ,1.0-mixed ,5.4-mixed .
Figures 5 and 6 contain performance results, and Figure 7
contains the precision results. The results are partitioned by
benchmark category to show the eect of each analysis sen-
sitivity on benchmarks in that category. The performance
graphs in Figure 5 plot the median execution time in mil-
liseconds, on a log scale, giving a sense of actual time taken
by the various sensitivity strategies. Lower bars are better;
timeouts extend above the top of the graph.
We provide an alternate visualization of the performance
data through Figure 6 to easily depict how the sensitivities
perform relative to each other. Figure 6 is heat map that lays
out blocks in two dimensions|rows represent benchmarks
and columns represent analyses with dierent sensitivities.
Each block represents relative performance as a color: darker
blocks correspond to faster execution time of a sensitivity
compared to other sensitivities on the same benchmark. A
completely blackened block corresponds to the fastest sensi-
tivity on that benchmark, a whitened block corresponds to
a sensitivity that has 2slowdown relative to the fastest
sensitivity, and the remaining colors evenly correspond to
slowdowns in between. Blocks with the red grid pattern in-
dicate a timeout. A visual cue is that columns with darker
blocks correspond to better-performing sensitivities, and a
row with blocks that have very similar colors indicates a
benchmark on which performance is unaected by varying
sensitivities.
Figure 7 provides a similar heat map (with similar visual
cues) for visualizing relative precisions of various sensitiv-
ity strategies on our benchmarks. The nal column in this
heat map provides the number of errors reported by the fs
strategy on a particular benchmark, while the rest of the
columns provide the percentage reduction (relative to fs) in
the number of reported errors due to a corresponding sensi-
tivity strategy. The various blocks (except the ones in the
nal column) are color coded in addition to providing per-
centage reduction numbers: darker is better precision (that
is, more reduction in number of reported errors). Timeouts
are indicated using a red grid pattern.
Breaking the Glass Ceiling. One startling observation
is that highly sensitive variants (i.e., sensitivity strategies
with highkandhparameters) can be far better than their
less-sensitive counterparts, providing improved precision at
a much cheaper cost (see Figure 8). For example, on linq_ -
dictionary ,5.4-stack is the most precise andmost ecient
analysis. By contrast, the 3.2-stack analysis yields the same
result at a three-fold increase in cost, while the 1.0-stack
analysis is even more expensive and less precise. We see
similar behavior for the sgefa benchmark, where 5.4-stack is
an order of magnitude faster than 1.0-stack and delivers the
same results. This behavior violates the common wisdom
that values of kandhabove 1 or 2 are intractably expensive.
This behavior is certainly not universal,6but it is intrigu-
ing. Analysis designers often try to scale up their context-
sensitivity (in terms of kandh) linearly, and they stop when
it becomes intractable. However, our experiments suggest
that pushing past this local barrier may yield much better
6For example, linq_aggregate times out on all analyses with
k>1.1.0 stack5.4 stack4. acyclic1.0 obj5.4 obj1.0 sig5.4 sig1.0 mixed5.4 mixedfs
1,00010,000100,0001,000,000
crypto-sha1richardssplay3d-cubeaccess-nbody3d-raytracecryptobench
1,00010,000
tryagainodesk_job_wat...less_spam_ple...live_pagerankcoffee_pods_d...chesspinpointsExecution Time (ms)(a)addon benchmarks
1,00010,000100,0001,000,000
fastallubenchmarkfourinarowahasgefahashtestfannkuchExecution Time (ms) (b) generated benchmarks
1001,00010,000100,0001,000,000
rsalinq_aggregateaeslinq_enumerablelinq_functionallinq_actionlinq_dictionaryExecution Time (ms)
(c)opensrc benchmarks
1,00010,000100,0001,000,000
crypto-sha1richardssplay3d-cubeaccess-nbody3d-raytracecryptobenchExecution Time (ms) (d) standard benchmarks
Figure 5: Performance characteristics of dierent sensitivities across the benchmark categories. The x-axis gives the benchmark names.
The y-axis (log scale) gives for each benchmark, the time taken by the analysis (in milliseconds) when run under 10 dierent sensitivities.
Lower bars mean better performance. Timeout (30 minutes) bars are ush with the top of the graph.
results.
Callstring vs Object Sensitivity. In general, we nd
that callstring-based sensitivity (i.e., k.h-stack andh-acyclic )
is more precise than object sensitivity (i.e., k.h-obj). This re-
sult is unintuitive, since JavaScript heavily relies on objects
and object sensitivity was specically designed for object-
oriented languages such as Java. Throughout the bench-
marks, the most precise and ecient analyses are the ones
that employ stack-based k-CFA. Part of the reason for this
trend is that 25% of the benchmarks are machine-generated
JavaScript versions of procedural code, whose structure yields
more benets to callstring-based context-sensitivity. Even
among the handwritten open-source benchmarks, however,
this trend holds. For example, several forms of callstring sen-
sitivity are more ecient and provide more precise results for
the open-source benchmarks than object-sensitivity, which
often times out.
Benets of Context Sensitivity. When it comes to pure
precision, we nd that more context sensitivity sometimes
increases precision and sometimes has no eect. The open-
source benchmarks demonstrate quite a bit of variance for
the precision metric. A context-sensitive analysis almost al-
ways nds fewer errors (i.e., fewer false positives) than a
context-insensitive analysis, and increasing the sensitivity
in a particular family leads to precision gains. For example,
5.4-stack gives the most precise error report for linq_enumerable ,
and it is an order of magnitude more precise than a context-
insensitive analysis. On the other hand, the addon domain
has very little variance for the precision metric, which is
perhaps due to shorter call sequence lengths in this domain.
In such domains, it might be wise to focus on performance,
rather than increasing precision.Summary. Perhaps the most sweeping claim we can make
from the data is that there is no clear winner across all
benchmarks, in terms of JavaScript context-sensitivity. This
state of aairs is not a surprise: the application domains
for JavaScript are so rich and varied that nding a silver
bullet for precision and performance is unlikely. However,
it is likely that|within an application domain, e.g., auto-
matically generated JavaScript code|one form of context-
sensitivity could emerge a clear winner. The benet of JSAI
is that it is easy to experiment with the control ow sen-
sitivity of an analysis. The base analysis has already been
specied, the analysis designer need only instantiate and
evaluate multiple instances of the analysis in a modular way
to tune analysis-sensitivity, without having to worry about
the analysis soundness.
5.3 Discussion: JSAI vs.TAJS
Jensen et al.'s Type Analysis for JavaScript [33, 34] (TAJS)
stands as the only published static analysis for JavaScript
whose intention is to soundly analyze the entire JavaScript
language. JSAI has several features that TAJS does not,
including congurable sensitivity, a formalized abstract se-
mantics, and novel abstract domains, but TAJS is a valuable
contribution that has been put to good use. An interesting
question is how JSAI compares to TAJS in terms of precision
and performance.
The TAJS implementation (in Java) has matured over a
period of ve years, it has been heavily optimized, and it is
publicly available. Ideally, we could directly compare TAJS
to JSAI with respect to precision and performance, but they
are dissimilar enough that they are eectively noncompara-
ble. For one, TAJS has known soundness bugs that can
articially decrease its set of reported type errors. Also,(a) addon benchmarkstryagain0%0%0%0%0%0%0%0%0%16odesk_job_wat‚Ä¶0%0%0%0%0%0%0%0%0%18less_spam_ple‚Ä¶77%77%77%13%13%0%65%16%16%62live_pagerank15%15%15%0%0%0%0%15%15%13coffee_pods_d‚Ä¶0%0%0%0%0%0%0%0%0%5chess17%17%17%8%8%0%8%8%8%24pinpoints2%2%2%0%0%0%0%4%4%54(b) generated benchmarksfasta92%94%94%17%17%0%17%92%92%36llubenchmark99%99%99%0%0%21%99%99%287fourinarow88%92%92%0%0%0%0%88%88%24aha67%70%70%0%0%7%7%67%67%27sgefa99%99%99%0%0%21%99%99%287hashtest91%94%94%17%17%0%17%91%91%35fannkuch91%94%94%18%18%0%18%91%91%33(c) opensrc benchmarksrsa29%32%32%0%0%0%6%9%9%34linq_aggregate88%1%2%267aes0%0%0%0%0%0%0%0%0%4linq_enumerable95%99%99%2%2%7%88%0%374linq_functional73%89%1%12%0%0%335linq_action92%93%96%9%10%66%75%90%90%169linq_dictionary81%85%84%1%3%1%5%73%73%376(d) standard benchmarkscrypto-sha10%0%0%0%0%0%0%0%0%0richards0%26%26%2%2%0%0%12%12%42splay0%0%0%0%0%0%0%0%0%303d-cube8%8%8%0%0%0%4%8%8%53access-nbody0%0%0%0%0%0%0%0%0%63d-raytrace29%29%29%6%6%0%8%27%27%48cryptobench27%76%76%6%14%21%63%10%28%329 1.0-stack 5.4-stack 4-acyclic 1.0-obj 5.4-obj 1.0-sig 5.4-sig 1.0-mixed 5.4-mixedfsFigure 7: A heat map to showcase the precision characteristics
(based on number of reported runtime errors) of dierent sensitiv-
ities across the benchmark categories. The above gure is a two-
dimensional map of blocks; rows correspond to benchmarks, and
columns corresponds to analysis run with a particular sensitiv-
ity. The rightmost column corresponds to the context insensitive
analysis fs, and the blocks in this column give the number of errors
reported by the analysis under fs(which is an upper bound on
the number of errors reported across any sensitivity). The color
(which ranges evenly from black to white) in the remaining blocks
indicate the percentage reduction in number of errors reported by
the analysis under the corresponding sensitivity, compared to fs
on the same benchmark. Darker colors represent more reduction
in errors reported, and hence better precision. In addition to the
colors, the percentage reduction in errors is also given inside the
blocks (higher percentage reduction indicates better precision).
The red grid pattern on a block indicates a timeout.
VWDFN
VWDFN
 REM
REM
IV
Figure 8: Precision vs.performance of various sensitivities, on
theopensrc linq_dictionary benchmark. Interestingly, 5.4-stack
(the most sensitive Stack-CFA analysis) is not only tractable, it
exhibits the best performance and the best precision.TAJS does not implement some of the APIs required by
our benchmark suite, and so it can only run on a subset
of the benchmarks. On the ip side, TAJS is more ma-
ture than JSAI, it has a more precise implementation of the
core JavaScript APIs, and it contains a number of precision
and performance optimizations (e.g., the recency heap ab-
straction [16] and lazy propagation [34]) that JSAI does not
currently implement.
Nevertheless, we can perform a qualitative\ballpark"com-
parison, to demonstrate that JSAI is roughly comparable
in terms of precision and performance. For the subset of
our benchmarks on which both JSAI and TAJS execute, we
catalogue the number of errors that each tool reports and
record the time it took for each tool to do so. We nd that
JSAI analysis time is 0.3 to 1.8that of TAJS. In terms
of precision, JSAI reports from nine fewer type errors to
104 more type errors, compared to TAJS. Many of the extra
type errors that JSAI reports are RangeErrors, which TAJS
does not report due to one of the unsoundness bugs we un-
covered. Excluding RangeErrors, JSAI reports at most 20
more errors than TAJS in the worst case.
6. CONCLUSION
We have described the design of JSAI, a congurable,
sound, and ecient abstract interpreter for JavaScript. JSAI's
design is novel in a number of respects which make it stand
out from all previous JavaScript analyzers. We have pro-
vided a comprehensive evaluation that demonstrates JSAI's
usefulness. The JSAI implementation and formalisms are
freely available as a supplement, and we believe that JSAI
will provide a useful platform for people building JavaScript
analyses.
Acknowledgements. This work was supported by NSF
CCF-1319060 and CCF-1117165.
7. REFERENCES
[1]http://www.drdobbs.com/windows/
microsofts-javascript-move/240012790 .
[2]http://nodejs.org/ .
[3]http://www.mozilla.org/en-US/firefox/os/ .
[4]http://www.khronos.org/registry/typedarray/
specs/latest/ .
[5]http://www.emscripten.org/ .
[6]http://doctorjs.org/ .
[7]https://developer.mozilla.org/en-US/docs/
SpiderMonkey .
[8]http:
//www.webkit.org/perf/sunspider/sunspider.html .
[9]http://v8.googlecode.com/svn/data/benchmarks/
v7/run.html .
[10] https://developer.mozilla.org/en-US/docs/Rhino .
[11] https://addons.mozilla.org/en-US/firefox/ .
[12] http://linqjs.codeplex.com/ .
[13] http://www.defensivejs.com/ .
[14] http://aws.amazon.com/ .
[15] C. Anderson, P. Giannini, and S. Drossopoulou.
Towards type inference for javascript. In European
conference on Object-oriented programming , 2005.[16] G. Balakrishnan and T. Reps. Recency-abstraction for
heap-allocated storage. In International conference on
Static Analysis , 2006.
[17] S. Bandhakavi, N. Tiku, W. Pittman, S. T. King,
P. Madhusudan, and M. Winslett. Vetting browser
extensions for security vulnerabilities with vex.
Commun. ACM , 54(9), Sept. 2011.
[18] M. Bravenboer and Y. Smaragdakis. Strictly
declarative specication of sophisticated points-to
analyses. In ACM International Conference on Object
Oriented Programming Systems Languages and
Applications . ACM, 2009.
[19] R. Chugh, D. Herman, and R. Jhala. Dependent types
for javascript. In International Conference on Object
Oriented Programming Systems Languages and
Applications , 2012.
[20] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner.
Staged information ow for javascript. In ACM
SIGPLAN Conference on Programming Languages
Design and Implementation , 2009.
[21] P. Cousot and R. Cousot. Systematic design of
program analysis frameworks. In ACM Symposium on
Principles of Programming Languages , 1979.
[22] ECMA. ECMA-262: ECMAScript Language
Specication . Third edition, Dec. 1999.
[23] A. Feldthaus, M. Sch afer, M. Sridharan, J. Dolby, and
F. Tip. Ecient construction of approximate call
graphs for javascript ide services. In International
Conference on Software Engineering . IEEE Press,
2013.
[24] P. A. Gardner, S. Maeis, and G. D. Smith. Towards a
program logic for javascript. In ACM Symposium on
Principles of programming languages , 2012.
[25] S. Guarnieri and B. Livshits. Gatekeeper: mostly
static enforcement of security and reliability policies
for javascript code. In Conference on USENIX
security symposium , 2009.
[26] A. Guha, S. Krishnamurthi, and T. Jim. Using static
analysis for Ajax intrusion detection. In World Wide
Web Conference , 2009.
[27] A. Guha, C. Saftoiu, and S. Krishnamurthi. The
essence of javascript. In European conference on
Object-oriented programming , 2010.
[28] A. Guha, C. Saftoiu, and S. Krishnamurthi. Typing
local control and state using ow analysis. In
European conference on Programming languages and
systems , 2011.
[29] B. Hardekopf, B. Wiedermann, B. Churchill, and
V. Kashyap. Widening for control-ow. In
International Conference on Verication, Model
Checking, and Abstract Interpretation , 2014.
[30] P. Heidegger and P. Thiemann. Recency types for
analyzing scripting languages. European conference on
Object-oriented programming , 2010.
[31] D. Jang and K.-M. Choe. Points-to analysis for
javascript. In Symposium on Applied Computing , 2009.
[32] S. H. Jensen, P. A. Jonsson, and A. Mller.
Remedying the Eval that Men Do. In International
Symposium on Software Testing and Analysis , 2012.
[33] S. H. Jensen, A. Mller, and P. Thiemann. Type
Analysis for Javascript. In International Symposium
on Static Analysis , 2009.[34] S. H. Jensen, A. Mller, and P. Thiemann.
Interprocedural Analysis with Lazy Propagation. In
International Symposium on Static Analysis , 2010.
[35] V. Kashyap and B. Hardekopf. Security signature
inference for javascript-based browser addons. In
Symposium on Code Generation and Optimization ,
2014.
[36] V. Kashyap, J. Sarracino, J. Wagner, B. Wiedermann,
and B. Hardekopf. Type renement for static analysis
of javascript. In Symposium on Dynamic Languages ,
2013.
[37] G. Kastrinis and Y. Smaragdakis. Hybrid
context-sensitivity for points-to analysis. In ACM
SIGPLAN Conference on Programming Languages
Design and Implementation . ACM, 2013.
[38] H. Lee, S. Won, J. Jin, J. Cho, and S. Ryu. Safe:
Formal specication and implementation of a scalable
analysis framework for ecmascript. In International
Workshop on Foundations of Object-Oriented
Languages , 2012.
[39] F. Logozzo and H. Venter. Rata: Rapid Atomic Type
Analysis by Abstract Interpretation { Application to
Javascript Optimization. In Joint European
Conference on Theory and Practice of Software,
International Conference on Compiler Construction ,
2010.
[40] M. Madsen, B. Livshits, and M. Fanning. Practical
static analysis of JavaScript applications in the
presence of frameworks and libraries. In ACM
Symposium on the Foundations of Software
Engineering , Aug. 2013.
[41] S. Maeis, J. C. Mitchell, and A. Taly. An operational
semantics for javascript. In Asian Symposium on
Programming Languages and Systems , 2008.
[42] M. Sch afer, M. Sridharan, J. Dolby, and F. Tip.
Dynamic determinacy analysis. In ACM SIGPLAN
Conference on Programming Languages Design and
Implementation . ACM, 2013.
[43] Y. Smaragdakis, M. Bravenboer, and O. Lhot ak. Pick
your contexts well: understanding object-sensitivity.
InACM Symposium on Principles of programming
languages , 2011.
[44] A. Taly, U. Erlingsson, J. C. Mitchell, M. S. Miller,
and J. Nagra. Automated analysis of security-critical
javascript apis. In IEEE Symposium on Security and
Privacy , 2011.
[45] P. Thiemann. Towards a Type System for Analyzing
Javascript Programs. In European Conference on
Programming Languages and Systems , 2005.
[46] D. Van Horn and M. Might. Abstracting abstract
machines. In International Conference on Functional
Programming , 2010.
[47] D. Vardoulakis. CFA2: Pushdown Flow Analysis for
Higher-Order Languages . PhD thesis, Northeastern
University, 2012.
[48] M. Weiser. Program slicing. In International
Conference on Software Engineering . IEEE Press,
1981.
[49] D. Zanardini. The semantics of abstract program
slicing. In IEEE International Working Conference on
Source Code Analysis and Manipulation , 2008.