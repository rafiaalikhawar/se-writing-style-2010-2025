On the Congruence of Modularity and Code Coupling
Fabian Beck Stephan Diehl
Computer Science
University of Trier, Germany
{beckf,diehl}@uni-trier.de
ABSTRACT
Software systems are modularized to make their inherent
complexity manageable. While there exists a set of well-known principles that may guide software engineers to de-sign themodulesofasoftware system, wedonotknowwhich
principles are followed in practice. In a study based on 16
open source projects, we look at diﬀerent kinds of couplingconcepts between source code entities, including structuraldependencies,fan-outsimilarity, evolutionarycoupling, codeownership, code clones, and semantic similarity. The con-
gruence between these coupling concepts and the modular-
ization of the system hints at the modularity principles usedinpractice. Furthermore,theresultsprovideinsightson howto support developers to modularize software systems.
Categories and Subject Descriptors
D.2.8 [ Software Engineering ]: Metrics— Software science
General Terms
Design, Experimentation, Measurement
1. INTRODUCTION
Applying the age-old warfare strategy of divide and con-
querto a software system, its complexity can be managed
by modularizing it into smaller parts. Every non-trivial soft-
ware system is modularized on diﬀerent levels of abstraction
and employingdiﬀerent techniques. For instance, classes en-
close related functionalities, packages summarize classes intosubsystems, components provide reusable units of sourcecode, or aspects represent cross-cutting features.
When modularization came up, Parnas [19] introduced
the concept of information hiding, which became a funda-
mental paradigm for designing software systems. Shortly
thereafter, Stevens et al. [23] proposed the principle of lowcoupling and high cohesion: While modules should only beloosely coupled, the elements of a module are supposed tobe highly cohesive. Moreover, Conway [11] observed that
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted w ithout fee provided that copies are
not made or distributed for proﬁt or c ommercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, torepublish, to post on servers or to redist ribute to lists, requires prior speciﬁc
permission and/or a fee.ESEC/FSE’11, September 5–9, 2011, Szeged, Hungary.
Copyright 2011 ACM 978-1- 4503-0443-6/11/ 09 ...$10.00.modularity of a product is connected with the structure of
the organization that designs the product. These principlesand theories put forward diﬀerent criteria to modularize asystem. But we do not know which design principles are
really used in practice.
In this paper we want to approach this question and val-
idate known design principles by looking at the diﬀerenttypes of relationships that connect the entities of a softwaresystem. These relationships, which we call code couplings ,
may explain the design decisions that constitute the modu-
larization of a system. In particular, we will compare a setof diﬀerent code coupling concepts to the package structures
of Java systems. This comparison will be based on a metric
that measures the congruence between coupling and mod-ularity. We will show that diﬀerent principles impact thestudied software systems, but none of them dominates themodular structures.
In the rest of this paper, we ﬁrst brieﬂy review diﬀerent
principles on modularizing software systems as well as dif-ferent code coupling concepts (Section 2). Then, we presentour study analyzing the relationship between the couplingconcepts and the modularization of the systems (Section 3):We contrast the information contained in the coupling con-
cepts (Section 3.1). Based on a measure of congruence be-
tween the coupling concepts and modularity, we comparethe coupling types to ﬁnd out which concepts impact themodularization most (Section 3.2). By classifying the mod-ules of the systems, we furthermore derive coupling patternsfor diﬀerent module types (Section 3.3). While the discus-
sion shows some limitations of the study, it also raises possi-
ble implications of the results for designing and maintainingsoftware systems (Section 4). Finally, we present relatedresearch (Section 5) and conclude the paper (Section 6).
2. MODULARITY AND COUPLING
“For human beings, the only way to manage
a complex system or solve a problem is to breakit up.”[3]
Modularizing a system to manage its complexity is not
unique to software engineering, but is part of every engi-neering or design process. Baldwin and Clark [3] summa-rize this idea in an interdisciplinary theory on modularity.They argue that a well-modularized system or design allowsconcurrently working on diﬀerent parts in parallel, makes alarger complexity manageable, and hides uncertainties into
modules.
3542.1 Modularity Principles
In software engineering, diﬀerent design principles were
proposed on how to create a good modular structure of soft-
ware systems. We will brieﬂy outline these principles in the
following.
2.1.1 Low Coupling and High Cohesion (P1)
Stevenset al. propose tofocus on thedata communication
dependencies of a program [23]. The target characteristic of
good modularization isthat theelementsof each singlemod-ule are highly cohesive (i.e., connected by many dependen-cies), while elements belonging to diﬀerent modules shouldbelow coupled(i.e., connectedbyfew dependencies)—short,low coupling and high cohesion. Thisprinciplemightbecon-
sidered as the default approach when analyzing or retrieving
the modularization of a software system.
2.1.2 Information Hiding (P2)
Parnas introduced the principle of information hiding [18,
19]—hiding design decisions inside modules. Slim interfaces
should represent thefacade of themodule. The design startswith identifyinga set of importantdesign decisions thatmaychange during development. Each of these decisions shouldbe encapsulated in an independent module. As a result ofthis process, changes in the software system should be lim-
ited within the boundaries of a module. Information hiding
later on became one of the main principles of the objectoriented paradigm [16].
2.1.3 Conway’s Law (P3)
Conway formulated a general law on the congruence be-
tween organizations and the productsthey design [11]: “[...]
organizations which design systems [...] are constrainedto produce designs which are copies of the communicationstructures of these organizations.”
Conway’s law does not directly state guidelines to modu-
larize a software system. Nevertheless, it implies the princi-
plethat thedesign of asystem, andhenceitsmodularizationas a part of the design, should match the structure of theorganization. Otherwise, the intended design would conﬂictwith the social preconditions and may not be enforceable inpractice.
2.1.4 Others (P4)
Besides these three often cited principles, there are other
explicit modularity principles or principles that at least im-pact modularity.
a) Martin [15] introduced three package design principles:
thereuse-release equivalence principle,the common-reuse
principle ,a n dt h e common-closure principle . These prin-
ciples propose that the package reﬂects the granule of
reuse, release, and change.
b) Architectural styles like client-server orpipes-and-ﬁlters
provide a tight framework for modularization; layeredarchitecturesimposerules onthestructuraldependenciesof the modules.
c) Theideaofseparatingconcerns, whichledtothedevelop-
ment of aspect-oriented programming [25], could governthe modular structure of a software system in form of
non-cross-cutting concerns.d) Domain knowledge is one of the key strategies to identify
classes in object-oriented analysis [16].
In summary, various principlesexist on how to modularize
software systems. They focuson diﬀerentaspectsof software
engineering: While the principle of low coupling and highcohesion looks at the source code, information hiding andConway’s law take the development process into account.In turn, others reﬂect the domain the software is part of
(identiﬁcation of classes) or consider the ecosystem around
the software (common-reuse principle). It is reasonable toassume that these principles are not independent but inter-act with each other. A consistent theory or framework toformally summarize or compare these principles, however,does not exist.
2.2 Code Coupling Concepts
Ifapplied, modularity principles, as thosediscussedabove,
leave traces in the structure and evolution of a software sys-
tem. Since modularizing a system means grouping its ele-ments based on their connecting properties, the principles
are closely related to the relationships of code entities. We
will use the general term coupling to refer to such a rela-
tionship. While the frequently used term dependency im-
plies a cause and eﬀect of the connecting property, the termcoupling is not necessarily directed and is neutral with re-
spect to causality. Please note, that code coupling has here
a diﬀerent meaning than the term coupling as used in the
principle of low coupling and high cohesion ( P1): While, in
the principle, it only denotes cross-module relationships, wewill use the term in general for relationships.
In this study, we focus on object-oriented software sys-
tems, namely, systems mainly written in Java. Suchsystems
are modularized into packages that themselves may include
further packages. These hierarchically organized packagesform a mid-level of abstraction and will be considered asthe modularization of a system in this study.
Classes and interfaces are the basic elements of a pack-
age. As a matter of simpliﬁcation, we will use the term
classinterchangeable for classes and interfaces . Together
with a coupling concept, the classes form a graph data struc-
ture. The package modularization deﬁnes a hierarchy on theclasses. Formally, this data structure can be described asaﬁ v e - t u p e l G=(C,P,E,I,μ )—called a directed weighted
compound graph —where Cis the set of classes, Pis the
set of packages, E⊂C×C is the set of directed couplings,
I⊂(C∪P)×(C∪P) contains the inclusion edges of the
package hierarchy, and μ:E→R
+
0is the coupling weight
function. Furthermore, ((C∪ P),I)f o r m sat r e ew i t hl e a v e s
Cand inner vertices P.
Quite a number of diﬀerent coupling concepts have been
proposed in software engineering literature. In the follow-
ing we will introduce the set of coupling concepts that wewill analyze in our study. We will also discuss possible rela-tionships between the coupling concepts and the modularityprinciples as conjectures.
2.2.1 Structural Dependencies (SD)
A method calls another method, a class extends another
class, or a class aggregates objects of another class—all this
creates a direct dependency between two classes. Thesestatic structural code dependenciesare most frequently used
when analyzing or leveraging code coupling.
355In our study we distinguish the following three types of
structural dependencies.
SD.Inh Two classes are coupled (directed) if one class extends the
other class. If coupled, the coupling weight is 1.
SD.Agg Two classes are coupled (directed) if one class aggregates
another by having class variables using the other class. The cou-
pling weight is the number of class variables relying on the otherclass.
SD.Use Two classes are coupled (directed) if one class uses the
other class in a method as a local variable, a method parameter, or
by calling a method of the other cla ss. The coupling weight is the
number of methods using the other class.
Weusethetool DependencyFinder toretrieve these struc-
tural dependencies from compiled Java bytecode.
Conjecture: Structuraldependenciesareastraightforward
approach to measure the data communication for the prin-
ciple of low coupling and high cohesion ( P1). Introduced
prior to object-oriented design, it is, however, not clear howto rate the diﬀerent types of the object-oriented structural
dependencies when applying the principle.
2.2.2 Fan-Out Similarity (FO)
Structural dependencies might not only directly couple
two code entities but also indirectly : Two entities connected
to the same set of other entities might indicate a similar
purpose or functionality of these two entities. We refer tothese indirect structural couplings as fan-out similarity .
A feature vector describes the fan-out for each class. Each
feature representsthe numberof direct structural dependen-cies (SD) to a particular class. If two vectors of two classesare similar, the classes reference similar other classes. Toquantify the similarity, we employ the cosine similarity mea-sure, whichcomputestheanglebetweenthevectorsbutdoes
not take their lengths into account [24].
We again distinguish three types of structural informa-
tion. Orthogonally, external fan-out similarity (abbreviated
E), which is based on references to external libraries, con-
trasts internal fan-out similarity (abbreviated I), which only
considers the dependencies between the classes of the sys-
tem.
FO.InhE, FO.IhnI Two classes are coupled (undirected) if they
extend the same class or implement a similar set of interfaces. The
coupling weight is the cosine similarity of the inheritance feature
vectors.
FO.AggE, FO.AggI Two classes are coupled (undirected) if they
aggregate a similar set of classes. The coupling weight is the cosine
similarity of the aggregation feature vectors.
FO.UseE, FO.UseI Two classes are coupled (undirected) if they
use a similar set of classes. The coupling weight is the cosine simi-larity of the usage feature vectors.
Conjecture: Rather than optimizing coupling and cohe-
sion (P1), grouping together similar classes with respect to
fan-out similarity aligns the structural dependencies of the
grouped classes. High similarity regarding external fan-out
shows the common use of the same external functionality,which might hint at being covered by the same concern(P4c)—cross-cutting concerns have been detected based on
this idea [8].
Ifwe assume that aclassof thesystem reﬂectsadesign de-
cision, then, depending on the same class means dependingon that design decision. Following the principle of informa-tion hiding ( P2), the two elements depending on the same
internal class should be placed into the same module to hide
the design decision. Hence, similar internal fan-out similar-ity could be an indicator for information hiding as Schwanke
argues [22].2.2.3 Evolutionary Coupling (EC)
If two classes are frequently changed together during de-
velopment, this reveals an implicit dependency. Since thisinformation stems from the evolution of the software, we
call the coupling concept evolutionary coupling ,w h i c hi s
also known as co-change coupling orlogical coupling .
We measure evolutionary coupling in terms of two estab-
lished measures, support andconﬁdence . The support value
of a coupling counts how often the two coupled software ar-
tifacts were changed together. Additionally, the conﬁdence
value of a coupling normalizes the support by thetotal num-ber of changes of one of the artifacts. While support is a
symmetric metric, conﬁdence is not because of its asym-
metric normalization (see [4] for details). Support and con-
ﬁdence produce two coupling variants that relate the same
classes but diﬀer concerning their weights.
EC.Sup Two classes are coupled (undir ected) if they were changed
together during development. The coupling weight reﬂects the
number of common changes ( support ).
EC.Conf Two classes are coupled (directed) if they were changed
together during development. The coupling weight reﬂects thenumber of common changes relative to the number of changes ofthe ﬁrst compared class ( conﬁdence ).
WeusetheapproachbyZimmermannandWeißgerber[28]
to extract the evolutionary class dependency graphs from
the version archives. As common when mining software
repositories, we omit large transactions (transactions includ-
ing more than 25 classes) to reduce noise.
Conjecture: Information hiding ( P2) argues that hiding
design decisions increases the changeability of a system be-
cause changing a design decision causes only local changes
in one module [19]. Hence, information hiding should rather
lead to local changes, which result in local evolutionary cou-pling. Conversely, if the changes are local, this could alsohave other reasons, for instance, a strict module ownershippolicy, where each package has an owner who is responsiblefor it.
2.2.4 Code Clones (CC)
Code clones are fragments of code that are equivalent or
similar. They introduce another concept of coupling: For
example, changing a cloned code fragment often requires tochange the other fragments of the clone group, too.
Comparing two classes, we take their overlap in terms of
cloned code into account to get a similarity measure. Livieryet al. [14] introduced a coverage metric for this purpose. Weemploy this metric in a slightly adapted version:
μ
cc(c1,c2)=/bardblcc(c1,c2)/bardbl
/bardblc1/bardbl+/bardblc2/bardbl
where/bardblc/bardblis the size of class cmeasured in number of to-
kens and cc(c1,c2) denotes the set of code fragments covered
by common clones between classes c1andc2.
We use the code clone detection API JCCD[5] and apply
two conﬁgurations: The ﬁrst one detects Type I clones—exact matches of code fragments ignoring code layout andcomments. The second one detects Type II clones—codefragments that are equivalent when generalizing from identi-
ﬁer names and also ignoring code layout and comments [20].
CC.I Two classes are coupled (undirected) if they share Type I
clones . The coupling weight is the clone coverage µcc
CC.II Two classes are coupled (undirected) if they share Type II
clones . The coupling weight is the clone coverage µcc
356Conjecture: It may sound strange that the badsmell of
duplicatedcodeshouldindicatea gooddesignprinciple. But
code clones are often introduced for good reasons, for ex-
ample, performance improvement, forking, generative pro-gramming, or reducing dependencies [20]. Depending onthe purpose, code clones may disguise other couplings. Forinstance, copied code could replace an inheritance connec-
tion (SD.Inh) or a method call that would otherwise lead to
a usage dependency ( SD.Use) or a similar fan-out ( FO).
2.2.5 Code Ownership (CO)
The main author of a code entity is the expert to be con-
tacted when there is a problem or question concerning this
code. If two code entities have the same author or authors,t h e yc o u l db ec o v e r e db yt h es a m ee x p e r t i s e .
To compare classes based on their owner, we list the devel-
opers who have ever changed a particular class and trans-
form this list into a binary vector. In a more elaborate
approach, we proportionally quantify the code ownership:For each class, the number of changes made by a particu-lar author is divided by the total number of changes. Bothmetrics producecouplings relating the same classes but withdiﬀerent weights.
CO.Bin Two classes are coupled (undirected) if they share com-
mon authors. The coupling weight is the cosine similarity of the
binary ownership vectors.
CO.Prop Two classes are coupled (undirected) if they share com-
mon authors. The coupling weight is the cosine similarity of the
proportional ownership vectors.
Conjecture: Bowman and Holt [7] argue that, if two code
entities have a common author, communication between the
developers of two entities is likely. Hence, code ownershipsimilarity is a way to map parts of the communication struc-
tureofthedevelopmentteamintothesourcecode. Referring
to Conway’s Law ( P3), the design of the system is said to
follow this communication structure.
2.2.6 Semantic Similarity (SS)
Interpreting the source code of classes as plain text doc-
uments, the classes are coupled, like text documents, by
their common vocabulary. In this case, the vocabulary con-sists of the identiﬁers used in the code and the words inthe comments. Standard information retrieval methods for
semantically relating documents can be applied.
Each class is described as a bag of words which is trans-
formed into a vector where each dimension counts the num-
ber of occurrences of a particular term. To counterbalancethe importance of frequently occurring terms across docu-
ments, we apply the tf-idfmeasure. Furthermore, we use
latent semantic indexing (LSI) to consider related terms as
a concept and to reduce noise.
SS.Tﬁdf Two classes are coupled (undirected) if they share a sim-
ilar vocabulary. The coupling weight is the cosine similarity of the
tf-idf document vectors.
SS.LSI Two classes are coupled (undirected) if they share a similar
vocabulary. The coupling weight is the cosine similarity of the LSI
document vectors.
In particular, we implemented an approach very similar
to the one used by Kuhn et al. to cluster source code docu-
ments [13]: From the source code of a class including com-ments, we excluded the license text and, much more impor-tant in our scenario, the package name and the names ofits ancestor packages. The preprocessing splits camel-casewords into their components, removes meaningless words
basedonJavakeywordsandalistofEnglishstopwords, andnormalizes the words by reducing them to their stem basedon the Porteralgorithm. The resulting document vector is
balanced by applying tf-idf, and ﬁnally transformed into an
LSImodel with 30 dimensions. WeappliedthePythonAPIs
stemming andgensimto implement the process.
Conjecture: Among the presented coupling concepts, the
domain knowledge incorporated in the package design ( P4d)
might be best reﬂected in the vocabulary used in the source
code text. The terms describing a domain concept shouldalso appear in the code as identiﬁer names or in comments.The problem, however, could be that, besides these domain-related terms, many other circumstances inﬂuence the vo-cabulary, like reference to other code entities, information
on the author, applied design patterns that bring in a cer-
tain terminology, etc.
3. STUDY
Based on the source code and its accompanying informa-
tion, it is hard to directly conclude what principles were
used to design the modular structure of a software system.
Hence, we abstract the software project by reducing it to a
set of diﬀerent coupling concepts between the classes of thesystem. Analyzing the coupling concepts and their impacton modularity builds the foundation for indirectly drawingconclusions on principles applied. In particular, we want toempirically answer three questions:
•How do the diﬀerent coupling concepts relate to each
other? (Section 3.1)
•What is the impact of each coupling concept on the
modularization? (Section 3.2)
•Aretherespeciﬁcdiﬀerencesinthisimpactfordiﬀerent
package types? (Section 3.3)
The study examines the modularity of 16 open source
software projects—Table 1 provides a complete list. Eachof these projects is mainly written in Java and hosted atsourceforge.net . We selected a broad spectrum of applica-
tion types, varying from small to mid-size projects. Thenumber of packages that directly contain classes shows thesize of the hierarchy, the number of classes provides an es-timate of the size of the project. CVSorSVNrepositories
provide data about the development history of the projects.
For the studied projects, the available development activ-
ity spans 10 months to up to 9 years or 126 to up to 4602
check-in transactions (only counting the transactions whererelevant Java classes were checked in) involving up to 23 de-velopers. To extract the coupling information, we mirroredthe repositories and downloaded a compiled version of the
software in form of a jarﬁle. The structural dependencies
(SD) as well as the fan-out references ( FO) were derived
from the jarﬁle. By the date of release, we determined the
corresponding version of the Java source code. This ver-
sion is used to retrieve the code clone information ( CC)a n d
the semantic similarity ( SS). Finally, the extraction of evo-
lutionary coupling ( EC) and code ownership coupling ( CC)
requiredtoprocess thewhole repository from theﬁrst check-in up to the version corresponding to the selected release.We used the released jarﬁle as a reference to determine the
set of classes considered for analysis (excluding containedthird-party libraries). Other classes possibly contained in
the repository like test classes, experimental functionality,
357Table 1: Properties of the sample of software projects and their repositories.
Project Description Version #Pack. #Classes Repos. Time frame #Trans. #Dev.
Checkstyle coding conventions 5.1 21 261 SVN 2001-06-22 – 2010-02-16 1335 6
Cobertura
 test coverage
 1.9.4.1
 19
 99
 SVN
 2005-02-12 – 2010-03-03
 226
 6
CruiseControl continuous integration 2.8.4 27 295 SVN 2001-03-26 – 2010-09-16 1615 10
iText
 PDF library
 5.0.5
 24
 402
 SVN
 2007-12-20 – 2010-11-02
 817
 7
JabRef BibTeX management 2.6 37 499 SVN 2003-10-16 – 2010-04-14 1348 23
JEdit
 text editor
 4.3.2
 28
 488
 SVN
 2001-09-03 – 2010-05-09
 2927
 23
JFreeChart chart library 1.0.13 37 587 SVN 2007-06-19 – 2009-04-20 551 2
JFtp
 FTP client
 1.0
 7
 78
 CVS
 2002-02-06 – 2003-03-23
 155
 5
JHotDraw GUI framework 7.6 65 679 SVN 2006-11-22 – 2011-01-09 302 2
JUnit
 regression testing
 4.5
 23
 119
 CVS
 2007-12-07 – 2008-08-08
 126
 2
LWJGL gaming library 2.7.1 27 564 SVN 2002-08-09 – 2011-02-10 1557 11
PMD
 code problems
 4.2
 47
 565
 SVN
 2002-06-24 – 2008-03-26
 2041
 18
Stripes web framework 1.5.5 19 238 SVN 2005-09-07 – 2011-01-04 812 7
SweetHome3D
 interior design
 3.1
 8
 167
 CVS
 2006-04-11 – 2011-02-13
 1807
 1
TV-Browser program guide 2.7.6 62 485 SVN 2003-04-25 – 2010-12-19 4602 12
Wicket
 web framework
 1.2.2
 86
 622
 SVN
 2004-12-21 – 2006-08-27
 3456
 12
SD
Inh0.012 0.009 0.0014 0.0041 0.015 0.0045 0.0047 0.058 0.053 0.071 0.022 0.024 0.0048 0.011 0.12 0.094
0.012SD
Agg0.31 0.0018 0.015 0.028 0.0007 0.0065 0.011 0.056 0.04 0.022 0.025 0.0019 0.0027 0.052 0.039
0.009 0.31SD
Use0.00024 0.022 0.013 5.6e−05 0.014 0.017 0.043 0.019 0.0066 0.0073 0.0009 0.0007 0.034 0.025
0.0014 0.0018 0.00024FO
InhE0.044 0.064 0.11 0.073 0.0029 0.052 0.061 0.14 0.14 0.097 0.15 0.17 0.13
0.0041 0.015 0.022 0.044FO
AggE0.30 0.047 0.15 0.092 0.095 0.059 0.063 0.057 0.032 0.15 0.13 0.12
0.015 0.028 0.013 0.064 0.30FO
UseE0.15 0.07 0.17 0.13 0.13 0.10 0.10 0.11 0.18 0.22 0.21
0.0045 0.0007 5.6e−05 0.11 0.047 0.15FO
InhI0.13 0.30 0.085 0.12 0.042 0.044 0.18 0.21 0.25 0.24
0.0047 0.0065 0.014 0.073 0.15 0.07 0.13FO
AggI0.23 0.064 0.045 0.09 0.077 0.0021 0.032 0.13 0.13
0.058 0.011 0.017 0.0029 0.092 0.17 0.30 0.23FO
UseI0.093 0.084 0.071 0.067 0.17 0.19 0.29 0.31
0.053 0.056 0.043 0.052 0.095 0.13 0.085 0.064 0.093EC
Sup0.42 0.15 0.17 0.015 0.049 0.23 0.19
0.071 0.04 0.019 0.061 0.059 0.13 0.12 0.045 0.084 0.42EC
Conf0.19 0.20 0.043 0.068 0.28 0.22
0.022 0.022 0.0066 0.14 0.063 0.10 0.042 0.09 0.071 0.15 0.19CO
Bin0.93 0.0097 0.069 0.14 0.13
0.024 0.025 0.0073 0.14 0.057 0.10 0.044 0.077 0.067 0.17 0.20 0.93CO
Prop0.0084 0.065 0.15 0.14
0.0048 0.0019 0.0009 0.097 0.032 0.11 0.18 0.0021 0.17 0.015 0.043 0.0097 0.0084CC
I0.82 0.32 0.24
0.011 0.0027 0.0007 0.15 0.15 0.18 0.21 0.032 0.19 0.049 0.068 0.069 0.065 0.82CC
II0.33 0.26
0.12 0.052 0.034 0.17 0.13 0.22 0.25 0.13 0.29 0.23 0.28 0.14 0.15 0.32 0.33SS
Tfidf0.83
0.094 0.039 0.025 0.13 0.12 0.21 0.24 0.13 0.31 0.19 0.22 0.13 0.14 0.24 0.26 0.83SS
LSI
Figure 1: Correlation between coupling graphs.
or unused legacy code are skipped. For simpliﬁcation, we
ignored anonymous and inner classes by considering themjust as parts of the containing class.
3.1 Dimensions of Coupling
The ﬁrst part of our analysis will compare the diﬀer-
ent coupling concepts themselves, yet ignoring the modularstructure of the system. We may consider each concept asone dimension to describe a software system. If two con-cepts share some information, these dimensions would not
be orthogonal, but correlated.
3.1.1 Method
For a project, each coupling concept provides a graph on
the same set of classes. To compare the concepts, we de-
scribeeach conceptasavector. Adimensionof suchavectorrepresents a pair of classes; its value reﬂects the weight of
the edge between the two classes or is zero if there is no edgefor thiscombination. Hence, a project consisting of nclasses
is described as an n
2-dimensional vector for each coupling
concept. Concatenating theses vectors for all projects, we
get a summarized vector /vector vcodescribing the coupling concept
co. To equally weigh each project, we align the number of
dimensions by randomly sampling 20,000 dimensions (with
repetition) for each project. Finally, the Pearson correlationof two vectors /vector v
co1and/vector vco2provides a measure of similarity
for two concepts co1andco2.
3.1.2 Results
Wecomputed thepairwise correlation for all combinations
of coupling concepts and visualize the resulting correlation
matrix in Figure 1. High values indicate a strong (positive)
correlation between two coupling concepts, which means, iftwo classes are coupled by the ﬁrst concept, it is likely thatthey are also coupled by the second concept and vice versa.
The ﬁrst, quite surprising observation is that the matrix
is sparsely ﬁlled with high correlations—only few combina-
tions of concepts near the diagonal are strongly correlated.These strong relationships can be identiﬁed as similaritiesbetween metrics measuring variants of the same concept,for instance, the two code ownership metrics CO.Bin and
CO.Prop . But it is not always true that variants of the
same concept provide similar data as the inheritance depen-
dencies show: SD.Inhis only weakly correlated to the other
variantsofthestructuraldependencies. Suchastatistical in-dependence advocates to consider inheritance dependenciesas an independent concept.
Oﬀ the diagonal, we mostly observe very weak correla-
tions, which indicatesthat thecouplingconceptsindeedpro-vide diﬀerent coupling information. Though based on thesame underlying information, structural dependencies arenot considerably correlated with fan-out similarity. Ana-lyzing the few somewhat stronger cross-concept correlations(0.10 – 0.35), we observe some interesting relationships:
•Ownership couplings ( CO) correlate with evolutionary
couplings ( EC). An explanation is that both are based
on the check-in information. Two ﬁles can only becoupled by evolution if theyshare at least onecommonauthor.
•Coupling by code clones ( CC) shares some informa-
tion with internal and external inheritance and us-
358age fan-out ( FO.InhE ,FO.UseE ,FO.InhI,FO.UseI )
but clearly less with aggregation fan-out ( FO.AggE ,
FO.AggI ). The relationship to inheritance could be
caused by code that implements or overrides the same
methods in the same or similar way in two siblingclasses of the inheritance hierarchy. Furthermore, thereferences used in code clones are necessarily equal and
lead to a certain usage similarity, but do not directly
imply similar aggregation.
•Semantic similarity ( SS) is linked to most other cou-
pling metrics, only structural aggregation and usagedependencies form an exception ( SD.Agg,SD.Use).
Since this similarity is based on the raw source codetext, it partly aggregates other source code based cou-
pling concepts ( SD,FO,CC). Often the name of the
author is also mentioned in the source code, which ex-
plains the correlation to code ownership ( CO). For the
correlation to evolutionary coupling ( EC), we could
not ﬁnd an evident explanation.
In summary, the correlation matrix shows that the diﬀerent
coupling concepts are quite independent and thus each rep-resents diﬀerent coupling information. The correlations be-tween metrics for variants of the same concept conﬁrm thegrouping of the metrics—except inheritance dependencies,they should not be equated with other structural dependen-
cies.
3.2 Coupling-Modularity Congruence
The central part of this study is to relate the diﬀerent
coupling concepts to themodularity of thesoftware systems.
Thus, wehavetoﬁndameasure ofthecongruencebetween acoupling concept and the modularization. This comes downto the problem of how to relate a graph structure (the cou-
pling graph) and a hierarchy (the modularization).
3.2.1 Method
Usually, the extent to which the structure of a system
matches its call graph is measured by coupling and cohesion
as proposed by the modularity principle of low coupling andhigh cohesion ( P1). Since we capture each concept as a
graphG=(C,P,E,I,μ ) (Section 2.2), we are able to apply
the same approach to measuring the congruence betweencoupling and modularity for all coupling concepts. Hence, inthe following, coupling and cohesion are general properties
independent of a coupling concept and do not extend theterms used in the modularity principle of low coupling andhigh cohesion.
An edge connecting two classes of the same package con-
tributes to the cohesion of the package and moreover to thecohesion of the whole system. Just as well, an edge con-necting two classes of diﬀerent packages contributes to thecoupling. This model, however, disregards the hierarchicalstructure of the packages. A more elaborate model also con-
siders thedistanceof two packages in thehierarchy. Now, an
edgeepartly accounts to coupling and cohesion depending
on the distance it spans.
cohesion (e)=weight(e)
distance( e)
coupling (e)=weight−cohesion (e)The distance function distance (e) counts the number of
intermediatenodesontheshortest paththroughthepackagehierarchy that connects the source and target of an edge e.
Thus, the distance is 1 if the source and target class are
in the same package, 2 if, for instance, the source is in asub-package of the package of the target, etc. The sum ofcohesion and coupling always is equal the weight of the edge.
Toexpresscouplingand cohesion for a set of classes C⊆C
(e.g., a package or the whole system), we sum up the re-
spective cohesion and coupling values for all outgoing edgesout(C) and incoming edges in(C) of the classes in the set.
cohesion (C)=/summationdisplay
e∈out(C)cohesion (e)+/summationdisplay
e∈in(C)cohesion (e)
coupling (C)=/summationdisplay
e∈out(C)coupling (e)+/summationdisplay
e∈in(C)coupling (e)
Finally, the cohesion in relation to the coupling expresses
thecongruenceof thecoupling graph andthemodularstruc-
ture of the system for a set of classes C, which we denote as
coupling-modularity congruence (short, congruence ).
congruence (C)=cohesion (C)
cohesion (C)+coupling (C)
High congruence values indicate high consistency between
coupling and modularity. If the coupling graph is totally in-
dependentof themodularity thecongruence, however, is notzero but larger because ∀e∈E:cohesion (e)>0. Hence,
we have to compute the congruence of such a graph for ev-ery project to get a project-speciﬁc baseline of the congru-
ence metric. To this end, we take the complete graph which
fulﬁlls the independence of the coupling structure and themodularity—every other graph fulﬁlling the independencecondition is just a modularity-independent random sampleof the complete graph.
The congruence metric measures the quality of the cou-
pling information with respect to modularity in the graphbut not the richness or density of this information. This isintended because we do not want to mix quality and density.Nevertheless, we need a further metric to also measure thedensity of the congruence information.
The congruence density is high for a set of classes Cif
the congruence information is good for each class of the
set. Hence, we take the average of this class-speciﬁc con-gruence to get a density measure, which we denote as av-
erage class coupling-modularity congruence (short, average
congruence ).
congruence
avg(C)=1
|C|/summationdisplay
c∈Ccongruence ({c})
When there is no information available for a class c,h e n c e
out({c})=in({c})=∅, the function congruence ({c})i s
undeﬁned because cohesion ({c})a n dcoupling ({c}) are un-
deﬁned. In that case, we consider instead the respective
baseline value for {c}to deﬁne the average.
3.2.2 Results
Toanalyzetherelationship betweencouplingconceptsand
modularity, wecomputethecongruenceand averagecongru-
ence for all combinations of projects and coupling concepts,
359SD.Inh
SD.Agg
SD.Use
FO.InhE
FO.AggE
FO.UseE
FO.InhI
FO.AggI
FO.UseI
EC.Sup
EC.Conf
CO.Bin
CO.Prop
CC.I
CC.II
SS.Tfidf
SS.LSI
baseline0.00.20.40.60.81.0coupling−modularity congruence
SD.Inh
SD.Agg
SD.Use
FO.InhE
FO.AggE
FO.UseE
FO.InhI
FO.AggI
FO.UseI
EC.Sup
EC.Conf
CO.Bin
CO.Prop
CC.I
CC.II
SS.Tfidf
SS.LSI
baseline0.00.20.40.60.81.0average class coupling−modularity congruence
Figure 2: Coupling-modularity congruence and av erage class coupling-modularity congruence.
in each case considering all classes of the project. Summa-
rized by concept, the result hence is a distribution of con-gruence values. We present these distributions as box plotdiagrams inFigure2—onediagram forcongruence, theother
for the average congruence. Such box plot diagrams sketch
a distribution by plotting its main characteristic values: themedian (horizontal line), the two mid-quartiles (ﬁlled box),and the outliers (dashed lines and circles).
The results of structural dependencies ( SD)s h o wh i g h
coupling-modularity congruencevaluesclearly exceedingthe
baseline congruence. Hence, structural dependencies seem
to preferably link classes of the same or neighboring pack-ages. Among the three variants, the inheritance dependen-cies ( SD.Inh) provide the best results. Taking also the infor-
mation density into account, the average congruence values
of structural dependencies are also among the overall best
results. The usage dependencies gain against the aggrega-tion dependencies.
For the fan-out similarity ( FO), we observe large diﬀer-
ences between external and internal fan-out. While the in-
ternal fan-out provides good congruence values, only the in-
heritance variant of the external fan-out ( FO.InhE )i sa b l e
to compete. External aggregation ( FO.AggE ) and usage
fan-out ( FO.UseE ) do not seem to be a relevant criterion
for modularity because they do not notably top the baseline
values. The overall best congruence is reached by taking theinternal inheritance fan-out ( FO.InhI) into account. This
fan-out similarity is also among the best average congruence
values. Similar to the structural dependencies, again the us-ageinformation ( FO.UseI )gainswithrespecttodensityand,
together with the inheritance information ( FO.InhI), shows
competitive results for internal fan-out.
Evolutionary coupling ( EC) is also congruent to the mod-
ularity of the systems—the congruence metric shows about
equally high values as for structural aggregation and usagedependencies( SD.Agg,SD.Use). Thediﬀerencebetweenthe
two variants of the concept of evolutionary coupling is small
but consistently better for the conﬁdence metric ( EC.Conf )
than for the support metric ( EC.Sup). Relating the com-
mon number of changes to the number of total changes asit is done in the conﬁdence metric here shows a positiveeﬀect. With respect to density, the results for both evolu-tionary coupling metrics are very good—the median even isthe highest compared to all other concepts.
Codeownershipsimilarity( CO)doesnotimpactmodular-
ity as clearly as most other analyzed coupling concepts. The
congruence and average congruence only slightly exceed thebaseline. This is, by the way, no problem of granularity—ignoring the lowest levels of packages, the congruence doesnot improve with respect to the baseline.
Instances of the same Type I clone can be often found
in the same package as indicated by the high congruencevalues for this metric ( CC.I). This is not true to the same
extent for the more lax Type II clones ( CC.II). Surprisingly,
the density of Type I clones is high enough to also provide
good average congruence values. Here, the inherently denser
Type II clone information shows at least medium results.
Finally, the semantic similarity ( SS) turns out to only be
a second class factor for modularity. Though the congru-ence and average congruence clearly rise above the baseline,they cannot compete with the high values of other concepts.
Notably, the more elaborate LSIvariant of the semantic
similarity ( SS.LSI) consistently falls below the simpler tf-
idfvariant ( SS.Tﬁdf ). The negative impact of loosing some
information by dimension reduction seems to outweigh the
positive eﬀect of noise reduction.
In general, we got the best coupling-modularity congru-
ence for structural dependencies( SD), internal fan-out simi-
larity ( FO.*I), evolutionary coupling ( EC), and Type I code
clones ( CC.I). Among the structural information, inheri-
tance information outperforms for structural dependencies
as
well as for fan-out similarity especially with respect to
quality. Sinceinheritance is nearly uncorrelated to the other
structural information (Section 3.1), we observe here diﬀer-
ent highly congruent independent coupling concepts.
3.3 Module Type Congruence
The third and last part of the study investigates whether
there are individual diﬀerences in the coupling-modularity
congruence between diﬀerent types of modules. A variation
360SD.Inh
SD.Agg
SD.Use
FO.InhE
FO.AggE
FO.UseE
FO.InhI
FO.AggI
FO.UseI
EC.Sup
EC.Conf
CO.Bin
CO.Prop
CC.I
CC.II
SS.Tfidf
SS.LSI
baseline0.00.20.40.60.81.0core (11)coupling−modularity congruence
SD.Inh
SD.Agg
SD.Use
FO.InhE
FO.AggE
FO.UseE
FO.InhI
FO.AggI
FO.UseI
EC.Sup
EC.Conf
CO.Bin
CO.Prop
CC.I
CC.II
SS.Tfidf
SS.LSI
baseline0.00.20.40.60.81.0text (10)coupling−modularity congruence
SD.Inh
SD.Agg
SD.Use
FO.InhE
FO.AggE
FO.UseE
FO.InhI
FO.AggI
FO.UseI
EC.Sup
EC.Conf
CO.Bin
CO.Prop
CC.I
CC.II
SS.Tfidf
SS.LSI
baseline0.00.20.40.60.81.0io (7)coupling−modularity congruenceSD.Inh
SD.Agg
SD.Use
FO.InhE
FO.AggE
FO.UseE
FO.InhI
FO.AggI
FO.UseI
EC.Sup
EC.Conf
CO.Bin
CO.Prop
CC.I
CC.II
SS.Tfidf
SS.LSI
baseline0.00.20.40.60.81.0gui (6)coupling−modularity congruence
SD.Inh
SD.Agg
SD.Use
FO.InhE
FO.AggE
FO.UseE
FO.InhI
FO.AggI
FO.UseI
EC.Sup
EC.Conf
CO.Bin
CO.Prop
CC.I
CC.II
SS.Tfidf
SS.LSI
baseline0.00.20.40.60.81.0util (6)coupling−modularity congruence
SD.Inh
SD.Agg
SD.Use
FO.InhE
FO.AggE
FO.UseE
FO.InhI
FO.AggI
FO.UseI
EC.Sup
EC.Conf
CO.Bin
CO.Prop
CC.I
CC.II
SS.Tfidf
SS.LSI
baseline0.00.20.40.60.81.0data (4)coupling−modularity congruence
Figure 3: Coupling-modularity congruence for the most frequently occurring package types.
Table 2: Package types.
Type Description
core implements the core functionality
data encapsulates data and manages data structures
event handles temporal events, actions, messages or exceptions
graphics draws 2D or 3D graphics
gui creates and controls the graphical user interface
io reads or writes data from/to a device
text parses, transforms, or creates textual data
util provides supporting functionality
could indicate that diﬀerent design principles are used in
diﬀerent contexts.
3.3.1 Method
The ﬁrst step towards such a module type congruence is
to manually classify the packages of the software systemsinto distinctive types. We identiﬁed a set of package typesthat repeatedly appear in the projects (Table 2) and appliedthis classiﬁcation to the main packages of the 16 softwareprojects—sub-packages of the classiﬁed ones are assumedto belong to the same type. Some packages could not be
unambiguously assigned to a type, but they can be safely
omitted because the following analysis process does not relyon a complete classiﬁcation.
For each project, we evaluate congruence (C
t)w h e r eCtis
the set of classes included in a package assigned to type tto
get a congruence value speciﬁc for a package type. We sum-
marize each package type by considering all projects that at
least contain 6 classes of this type.
3.3.2 Results
We present the results of this analysis by showing box
plots of the six most frequently found package types (Fig-ure 3). Each box plot depicts one type, the value in paren-theses refers to the number of projects this type was de-tected in. The interpretation of the congruence values againdepends on the baseline, and thus, the diagrams cannot becompared without considering the slightly diﬀerent baseline
values.
Thebox plotdiagrams roughly showsimilar patternscom-
pared to each other. This pattern reﬂects most of the ob-
servations we already described in the previous part of thestudy (Section 3.2). Hence, these general results virtuallysustain for the diﬀerent package types. Even utility pack-
ages, which are said to follow diﬀerent laws than other pack-
ages [26], show this pattern together with considerably highcongruence values. Nevertheless, there are small diﬀerencesbetween the package types:
•Packages of type ioand guiare exceptionally congru-
ent with respect to the internal inheritance fan-out
similarity ( FO.InhI). Together with a high congruence
value for SD.Inhthiscould hintataspecial signiﬁcance
of inheritance in these packages.
•Overall the corepackages show somewhat lower con-
gruence values compared to the baseline. Here, factorsthat could not be grasped by the selection of coupling
concepts might impact their design.
•Fortextpackages, some metrics particularly exceed
the baseline, including structural dependencies ( SD),
internal fan-out similarity ( FO.*I), and evolutionary
coupling ( EC). This type of package seems to be par-
ticularly related to these coupling concepts.
4. DISCUSSION
So far, we have analyzed the results of the study with re-
spect to the congruence of the coupling concepts and mod-
361ularity. To ﬁnally get back to the modularity principles in-
troduced in Section 2.1, we will next discuss the limitations
of the results and interpret the results with respect to theseprinciples. Beyond that, we will provide an outlook on howthe results could be directly leveraged in applications re-garding modularity.
4.1 Threats to Validity
The generalizability of the results is limited by the re-
stricted set of software projects as well as by other design
decisions of the study. The 16 software projects are opensource systems written in Java and consist of up to 86 pack-ages and up to 679 classes. Closed source projects mightlead to diﬀerent results especially with respect to evolution-
ary and code ownership couplings because they might fol-
low a fundamentally diﬀerent development process. Largeropen-source projects may as well be organized diﬀerently.Furthermore, the results cannot be directly transferred tonon-object-oriented systems because, there, concepts like in-heritance do not exist.
We looked at modularity at a mid-level of abstraction and
equate modulewith package. Hence, our results only apply
to this level. For example, grouping methods into classescould follow totally diﬀerent standards.
Though we covered many important coupling concepts,
we did not exhaustively include all established concepts, for
instance, dynamic dependencies or coupling by bug reports.
Furthermore, the applied metrics are only heuristics to mea-sure the respective concept. Although we tried to use estab-lished metrics, there could exist more appropriate metrics.Analogously, the introducedcongruence metric might be un-suitable.
4.2 Modularity Principles
We must beware of over-interpreting the results with re-
spect to modularity principles because we can only conjec-ture about the relationship of the principles to the couplingconcepts. A high congruence for a particular concept mightbe caused by the application of a modularity principle, but
could alsobetheconsequenceofanother, unknownproperty.
Furthermore, low congruence values do not necessarily indi-cate the absence of a particular modularity principle, butcould also stem from weaknesses in measuring the princi-ple by this concept. Nevertheless, the following implicationscan be considered as circumstantial evidence on the practi-
cal relevance of modularity principles and might be used as
hypotheses for future research.
The high congruence values for structural dependencies
(SD) suggest that the principle of low coupling and high co-
hesion ( P1) is used to modularize software systems in prac-
tice as one of the dominating principles. The particularlyhigh congruence values for inheritance ( SD.Inh) together
with its independence of the other structural dependencies(Section 3.1) highlights the role of inheritance. It appears tobe the prevailing structural dependency type to implementthe principle.
Also Information hiding ( P2) seems to play a major role
in the analyzed projects as the high congruence values forinternal fan-out similarity ( FO) and evolutionary coupling
(EC) suggest. Again inheritance ( FO.InhI) is outstanding
as it provides the overall best coupling-modularity congru-ence result and might also be a distinguished aspect in the
application of information hiding.Code ownership ( CO) does not play an important role
in the package design of the investigated projects. A likely
conclusion is that the impact of Conway’s Law ( P3)i ss m a l l
in contrast to other principles.
The external fan-out similarity ( FO.*E), which we as-
sume to be related to the separation of concerns ( P4c), no-
tably impacts modularity only with respect to inheritance
(FO.InhE ). The low result matches the observation that of-
ten concerns cross-cut the hierarchical structure of the sys-
tem [25]. It would be interesting to also take aspects intoaccount and compare the congruence of aspect-oriented andnon-aspect-oriented systems with respect to external fan-out.
The role of domain knowledge ( P4d) is hard to judge from
the results of our study. The semantic similarity ( SS)p r o -
videsmediumcongruence. Ontheonehand,we mayassumethat domain knowledge is irrelevant and the medium con-gruence is just a result of the correlation to other high con-gruent coupling concepts (Section 3.1). On the other hand,
we may assume that domain knowledge is a driving factor,
but it is not appropriately reﬂected in the applied metric.
Finally, code clones ( CO) clearly relate to the modular
structure of the systems and are frequent enough to also
provide medium data density (average congruence). Hence,they may signiﬁcantly impact modularity principles, but we
do not know their relation to the principles because code
clones could hide diﬀerent types of code coupling.
Concerning the module-type-speciﬁc properties, we were
surprisedbythestablecongruencepatternsthatweobserved
for diﬀerent types (Section 3.3). This is an indicator, that
the the same modularity principles or guidelines are applied
regardless of the package type.
4.3 Modularity Applications
Many tasks and problems in software engineering are re-
lated to modularity. First of all, ﬁnding a good modular-
ization is a major part of designing a software system. Theinitial modularization might degenerate during the develop-ment process or could prove to be ﬂawed so that a later re-modularization wouldbenecessary. Ingeneral, documentingthemodularization is helpful for navigating and understand-
ing the code.
Tools based on code couplings might support the devel-
oper in these modularity-related applications. Such tools,
however, often considered coupling a one-dimensional con-cept, for instance, equating coupling with structural depen-dencies. In contrast, our results clearly show that coupling
consists of several dimensions (Section 3.1), many of them
impacting the modularity (Section 3.2). Exploiting combi-nations of coupling concepts could improve modularity toolslike tools for software clustering, aspect mining, or compo-nent extraction. For instance, in the domain of software
clustering, combining a few data sources has been already
successfully applied [2, 4, 6]. Moreover, it is to assume thatother applications of coupling data besides modularity areneither dominated by one coupling concept and could alsoproﬁt from integrating diﬀerent coupling concepts.
In detail, this study contains some ﬁndings that might be
ofparticularinterestfor designingautomaticmodularization
tools:
•It seems to be useful to discriminate structural depen-
dencies ( SD) further. At least inheritance ( SD.Inh)
should be considered as an independent concept be-
362cause otherwise aggregation and usage dependencies
might weaken the high impact of the inheritance de-
pendencies.
•Including the highly congruent and dense Type I cloneinformation ( CO.I) is likely to have a positive eﬀect
because clones may disguise parts of the relevant cou-
pling information.
•Using fan-out information ( FO), it could be beneﬁcial
to discern external and internal fan-out because of its
clearly diﬀerent congruence to modularity that we ob-served in this study.
The conjectured relationships between the code coupling
concepts and the modularity principles provide the oppor-
tunity to check whether the development team follows a cer-
tain principle. This could be a useful instrument for moni-
toring the development process. The congruence results ofour study provide a reference of how modularity relates tocoupling concepts in other projects.
We did not observe large diﬀerences for the coupling-
modularitycongruencebetweendiﬀerentpackagetypes(Sec-
tion 3.3). This supports the decision of many existing au-tomatic modularization approaches to handle all types ofmodules alike.
5. RELATED WORK
Abreu and Goul˜ ao [1] present an approach to ﬁnd out
whether coupling and cohesion are the driving forces forthe modularity of a software system. They optimized themodularization with respect to this principle. The result-ing modularization signiﬁcantly exceeded the metric valueof the original modularization. The authors conclude that
“the ideal of minimal coupling and maximal cohesion [. . . ]
does not match practitioners’ reality at least in what con-
cerns the modularity of object-oriented systems. ” Based on
our new results, we can qualify this statement further: Cou-
pling and cohesion still seem to be an important factors formodularity, but there appear to be other about equally im-
portant ones.
Sarkar et al. [21] discuss diﬀerent principles used in mod-
ule design, namely, similarity of purpose ,published API ,
compilability ,extendibility ,testability ,acyclic dependen-
cies,a n d module size .T h e y p r o p o s e a s e t o f m e t r i c s t o
quantify to what extent a modular structure follows theseprinciples. The results of their case study validate the met-
rics with respect to measure modularity improvements. Theapplied metricsthoroughly investigate diﬀerentkindsof cou-plings based on structuraldependencies. By concludingthata single metric is not suﬃcient to estimate the quality of a
modularization, they back our result that code coupling is a
multi-dimensional construct. In contrast to our work, theyfocus on creating modularity quality metrics but do not aimat comparing diﬀerent coupling concepts.
Evaluating diﬀerent code coupling concepts to automat-
ically retrieve the modular structure of a system by clus-
tering, Beck and Diehl [4] compared structural dependen-
cies and evolutionary couplings. They retrieved better re-sults for structural dependencies because of a higher datadensity. Combining structural dependencies and evolution-ary couplings improved the clustering result. Andritsos andTzerpos [2] added meta information like developer, direc-
tory, number of lines of code, and the time stamp of the ﬁleto structuraldependenciesand were also able to improvethequality of the clustered modularization. Wierda et al. [27]
showed how combining structural dependencies from mul-tiple versions can be used to improve the clustering result.Bittencourt et al. [6] enhance the assignment of new classesto modules by enqueing semantic similarity and structuraldependencies in the assignment process. These diﬀerent
improvements in automatically modularizing software sys-
tems by integrating diﬀerent coupling concepts already ex-ploit the multi-dimensionality of code couplings. Our studypredicts that more rigorously integrating coupling conceptscould lead to further improvements.
Comparisons between coupling concepts have been con-
ducted not only to explain or construct modules. For in-
stance, Cataldo etal.[9]foundthathighcongruencebetweencode couplings and the communication between developersleads to better productivity—for structural dependencies aswell as for evolutionary couplings. In a further study [10],they focus on the impact of diﬀerent coupling types on fail-
ures and conclude that evolutionary and work-related cou-
plings have a higher impact on failures than structural de-pendencies.
The introduced congruence metric is similar to some met-
rics applied in software clustering. If we assume the pack-age structure to be ﬂat instead of hierarchical, our metric
is closely related to the clustering factor metric used in the
software clustering tool Bunch [17], to the score of a cluster
deﬁned for the EVMmetric [12], or to the intra modular
coupling density [1].
6. CONCLUSION
This work is a ﬁrst step towards understanding, based on
conjectured relationships to code couplings, how modularity
principles are used in practice. We compared a broad spec-trum of coupling concepts on a substantial set of softwareprojects. The introduced measure of congruence connectscode coupling and modularity while also taking the hierar-
chical structure of the modularization into account. The
results of the study provide hints how modularity principlesare applied in object-oriented open source software systemstoday. These ﬁndings could be used as hypotheses for futureresearch. The study furthermore yields recommendations toenhance existing modularization approaches and tools.
Overall, we observed that none of the principles is ex-
clusively dominating the modularity of the studied systems.Among the coupling concepts, a similar internal inheritancefan-out, in other words, the sibling relation in the internalinheritance hierarchy has the highest impact on modularity.
Acknowledgment
We like to thank Benjamin Biegel, ArturLipinski, and Alex-ander Voskoboinik, who helped us retrieve the various kindsof coupling data.
7. REFERENCES
[ 1 ]F .B .A b r e ua n dM .G o u l ˜ ao. Coupling and Cohesion
as Modularization Drivers: Are We BeingOver-Persuaded? In CSMR ’01: Proceedings of the
Fifth European Conference on Software Maintenanceand Reengineering , pages 47–57. IEEE Computer
Society, 2001.
363[2] P. Andritsos and V. Tzerpos. Information-Theoretic
Software Clustering. IEEE Transactions on Software
Engineering , 31(2):150–165, 2005.
[ 3 ]C .Y .B a l d w i na n dK .B .C l a r k . Design Rules, Vol. 1:
The Power of Modularity . The MIT Press, 1st edition,
Mar. 2000.
[4] F. Beck and S. Diehl. Evaluating the Impact of
Software Evolution on Software Clustering. In WCRE
’10: Proceedings of the 17th Working Conference on
Reverse Engineering, pages 99–108. IEEE Computer
Society, 2010.
[5] B. Biegel and S. Diehl. Highly Conﬁgurable and
Extensible Code Clone Detection. In WCRE’10:
Proceedings of the 17th Working Conference on
Reverse Engineering, pages 237–241. IEEE Computer
Society, 2010.
[6] R. A. Bittencourt, G. J. S. Santos, D. D. S. Guerrero,
and G. C. Murphy. Improving Automated Mapping in
Reﬂexion Models using Information Retrieval
Techniques. In WCRE’10: Proceedings of the 17th
Working Conference on Reverse Engineering, pages163–172. IEEE Computer Society, 2010.
[7] I. T. Bowman and R. C. Holt. Software Architecture
Recovery Using Conway’s Law. In CASCON ’98:
Proceedings of the 1998 Conference of the Centre for
Advanced Studies on Collaborative Research , pages 6+.
IBM Press, 1998.
[8] S. Breu and T. Zimmermann. Mining Aspects from
Version History. In ASE ’06: Proceedings of the 21st
IEEE/ACM International Conference on Automated
Software Engineering, pages 221–230. IEEE Computer
Society, 2006.
[ 9 ]M .C a t a l d o ,J .D .H e r b s l e b ,a n dK .M .C a r l e y .
Socio-Technical Congruence: a Framework for
Assessing the Impact of Technical and Work
Dependencies on Software Development Productivity.
InESEM ’08: Proceedings of the Second ACM-IEEE
International Symposium on Empirical Software
Engineering and Measurement , pages 2–11. ACM,
2008.
[10] M. Cataldo, A. Mockus, J. A. Roberts, and J. D.
Herbsleb. Software Dependencies, Work Dependencies,
and Their Impact on Failures. IEEE Transactions on
Software Engineering, 35(6):864–878, Nov. 2009.
[11] M. Conway. How do Committees Invent? Datamation
Journal, pages 28–31, 1968.
[12] M. Harman, S. Swift, and K. Mahdavi. An Empirical
Study of the Robustness of two Module Clustering
Fitness Functions. In GECCO ’05: Proceedings of the
2005 Conference on Genetic and Evolutionary
Computation , pages 1029–1036. ACM Press, 2005.
[13] A. Kuhn, S. Ducasse, and T. Girba. Enriching Reverse
Engineering with Semantic Clustering. In WCRE ’05:
Proceedings of the 12th Working Conference onReverse Engineering, pages 133–142. IEEE Computer
Society, 2005.
[14] S. Livieri, Y. Higo, M. Matsushita, and K. Inoue.
Very-Large Scale Code Clone Analysis andVisualization of Open Source Programs UsingDistributed CCFinder: D-CCFinder. In ICSE ’07:
Proceedings of the 29th International Conference onSoftware Engineering, pages 106–115. IEEE Computer
Society, 2007.
[15] R. C. Martin. Agile Software Development, Principles,
Patterns, and Practices. Prentice Hall, 1st edition,
Oct. 2002.
[16] B. Meyer. Object-Oriented Software Construction, 1st
editon. Prentice-Hall, 1988.
[17] B. S. Mitchell and S. Mancoridis. On the Evaluation
of the Bunch Search-Based Software Modularization
Algorithm. Soft Computing , 12(1):77–93, Aug. 2007.
[18] D. L. Parnas. Information Distribution Aspects of
Design Methodology. In IFIP Congress (1) , pages
339–344, 1971.
[19] D. L. Parnas. On the Criteria to be Used in
Decomp
osing Systems into Modules. Communications
of the ACM , 15(12):1053–1058, Dec. 1972.
[20] C. K. Roy and J. R. Cordy. A Survey on Software
Clone Detection Research. Technical report, Queen’s
University at Kingston, Ontario, Canada, 2007.
[21] S. Sarkar, G. M. Rama, and A. C. Kak. API-Based
and Information-Theoretic Metrics for Measuring theQuality of Software Modularization. IEEE
Transactions on Software Engineering , 33(1):14–32,
2007.
[22] R. W. Schwanke. An Intelligent Tool for
Re-Engineering Software Modularity. In ICSE ’91:
Proceedings of the 13th International Conference onSoftware Engineering, pages 83–92. IEEE Computer
Society, 1991.
[23] W. P. Stevens, G. J. Myers, and L. L. Constantine.
Structured Design. IBM Systems Journal,
13(2):115–139, 1974.
[24] P.-N. Tan, M. Steinbach, and V. Kumar. Introduction
to Data Mining . Addison Wesley, May 2005.
[ 2 5 ]P .T a r r ,H .O s s h e r ,W .H a r r i s o n ,a n dS .M .S u t t o n .N
Degrees of Separation: Multi-Dimensional Separation
of Concerns. In ICSE ’99: Proceedings of the 21st
International Conference on Software Engineering ,
pages 107–119. ACM, 1999.
[26] Z. Wen and V. Tzerpos. Software Clustering based on
Omnipresent Object Detection. In IWPC ’05:
Proceedings of the 13th International Workshop onProgram Comprehension, pages 269–278, Washington,
DC, USA, 2005. IEEE Computer Society.
[27] A. Wierda, E. Dortmans, and L. L. Somers. Using
Version Information in Architectural Clustering - ACase Study. In CSMR ’06: Proceedings of the
Conference on Software Maintenance and
Reengineering , pages 214–228. IEEE Computer
Society, 2006.
[28] T. Zimmermann and P. Weißgerber. Preprocessing
CVS Data For Fine-Grained Analysis. In MSR ’04:
Proceedings of the 1st International Workshop on
Mining Software Repositories , pages 2–6. IEEE
Computer Society, 2004.
364