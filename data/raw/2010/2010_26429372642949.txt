Pattern-based Auto-completion of UML Modeling Activities
Tobias Kuschke
Technische Universit√§t Ilmenau
Software Systems/Process Informatics Group
Ilmenau, Germany
tobias.kuschke@tu-ilmenau.dePatrick M√§der
Technische Universit√§t Ilmenau
Software Systems/Process Informatics Group
Ilmenau, Germany
patrick.maeder@tu-ilmenau.de
ABSTRACT
Auto-completion of textual inputs when using IDEs bene-
ts software development experts and novices. Researchers
demonstrated that auto-completion is benecial for graph-
ical modeling tasks as well. However, supporting software
development by auto-completing UML modeling activities
remains largely unexplored by research and unsupported by
modeling tools. By matching editing operations to activity
patterns, partly performed modeling activities can be rec-
ognized and automatically completed. This paper proposes
an approach that computes auto-completions for partly per-
formed modeling activities while a developer is creating or
evolving UML models. Selected auto-completions can be
previewed and adjusted before being executed. We claim,
that this approach can improve developers' modeling e-
ciency. Therefore, we assessed our approach based on a
catalog of common modeling activities for structural UML
models and found that eort for conducting dened model-
ing activities can be reduced signicantly.
Categories and Subject Descriptors
D.2.2 [ Software Engineering ]: Design Tools and Tech-
niques| Object Oriented Design Methods
Keywords
Auto-completion; Modeling Activity; Complex Event Pro-
cessing; Pattern Matching
1. INTRODUCTION
Automating tasks of a software engineering process is a
state-of-the-art way to increase the quality of a software
product and the eciency of its development. Software de-
velopment experts and novices benet from auto-completing
textual inputs when using IDEs [4]. Researchers demon-
strated that auto-completion is benecial for graphical mod-
eling tasks as well [13, 3, 11, 7]. However, supporting soft-
ware development by auto-completing UML modeling activi-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from Permissions@acm.org.
ASE‚Äô14, September 15-19, 2014, Vasteras, Sweden
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00
http://dx.doi.org/10.1145/2642937.2642949.ties remains largely unexplored by research and unsupported
by modeling tools. Though, there are plenty of opportuni-
ties for supporting recurring activities during model-driven
architecture and design. For example, Arlow and Neustadt
[2] describe typical activities that have to be carried out
when rening an initial UML analysis model into a design
model for a system. Furthermore, well-known design pat-
terns proposed by Gamma et al. [5] are often implemented
to improve the structure of a software system and can as
well be applied on a class model perspective of a system.
In previous work, we showed that partly performed mod-
eling activities can be recognized and suggested for auto-
completion while a developer is creating or evolving UML
models [8]. The proposed technology captures editing oper-
ations within a modeling environment and matches them to
predened activity patterns. The approach utilizes a mod-
ern event-processing engine for recognizing modeling activi-
ties and for ranking suggestions by relevance according to
a developers' modeling progress. In this paper, we pro-
pose a new approach that complements our previous work
by computing and executing auto-completions of modeling
activities that a user selects from the list of activities sug-
gested by the precursor technology. When developing this
new approach, we did not only want to complete an activity
in terms of missing actions, but we also wanted a user to
be able to preview and adjust the selected auto-completion.
We claim that auto-completions should be visualized within
a developers' model to allow a preview before their exe-
cution. Moreover, auto-completions should be adjustable
by the user, requiring to recompute completion actions and
their interdependencies instantaneously after each modica-
tion. Therefore, we developed an approach that computes
auto-completions based on activity patterns, enables their
preview and adjustment, and executes them within the mod-
eling environment.
2. RELATED WORK
Forster et al. [4] proposed WitchDoctor for detecting and
completing source code refactorings while observing devel-
opers writing source code. Their approach matches edit-
ing operations of the code to a list of refactorings with ev-
ery keystroke of a developer. Upon a match, the complete
refactoring is being calculated and displayed as gray-colored
suggestion within the editor. Similar to our approach, the
authors compute completions based-on predened patterns
and visualize them within the working environment. How-
ever, the approach cannot be directly adapted for auto-
completing modeling activities, especially regarding the ad-
551
justment of completing actions. Mazanaek et al. [11] studied
auto-completions for model and diagram editors. Based on
graph grammars, their approach calculates all possible com-
pletions for incomplete model graphs. Although, the ap-
proach recommends correct structural completions for the
current graph state, it does not support the completion of
complex modeling activities within structural UML mod-
els. As such activities contain specic conditions regarding
structural aspects and object property values it would be a
dicult task to express them by a general graph grammar.
Furthermore, it is impracticable to calculate and present all
completions for a complex structural UML model. Sen et al.
[13] propose a similar approach. The system is also triggered
by the user and presents recommendations in graphical form.
It is mainly designed to support small modeling languages
and computes its results within seconds up to minutes. The
approach shows similar limitations as the previous. Wieloch
et al. [15] demonstrate an approach that uses previously
modeled process fragments for completing business process
models. The system analyzes context and annotations of a
process task in order to suggest appropriate process frag-
ments from a repository. Task and completion strategy
have to be selected by the user to trigger the suggestion.
Arendt et al. [1] presented Henshin, a powerful transfor-
mation language and tool set for direct model modications
called in-place transformations. It uses transformation rules
and provides functionality for pattern replacements, e.g., for
automatically applying software design patterns. However,
these approaches are not designed to analyze the modeling
progress and to present suggestions automatically. Hornung
[6] and Koschmider [7] investigated the recommendation-
based support of business process modeling. Similar to the
previous approach, their goal was nding process parts in
a repository of business process models. They also propose
a recommendation approach that supports the user during
modeling. The authors presented an extensive experiment
to evaluate the usefulness of the proposed recommender sys-
tems. Nevertheless, their approaches do not support the
recognition of partly performed activities and the computa-
tions of appropriate auto-completion actions. Furthermore,
there are approaches [12, 14] that deal with user assistance in
keeping models consistent and well-formed. Similarly, these
approaches also calculate editing operations that are pre-
sented to the user. In contrast to our work, the focus of
those works is changing a model in a minimal way in order
to x local inconsistencies rather than predicting a user's
intent in performing complex modeling activities. Summa-
rizing, we found that prior approaches for auto-completing
activities within graphical modeling environments are not
able to do so continuously while a user is conducting an ac-
tivity as they require a distinct precondition of the model
on which the auto-completion is applied.
3. MODELING ACTIVITIES
Our approach focuses on auto-completing structural UML
modeling activities. We dene such an activity as a recurring
set of editing operations Ltcarried out on a model in order
to add, to remove, or to replace model elements (e.g., with
the goal of adding a software design pattern). An editing
operation oconsists of an edit type fadd, delete, modify g
and an element state sdescribing element properties after
adding or modifying it and respectively before deleting it.We previously identied and iteratively evolved a compre-
hensive set of such modeling activities [8, 9, 10]. Examples
of these activities are "replacing an association by an inter-
face realization", "extracting an attribute into a class", or
"replacing an association class". In addition, we considered
a number of well-known software design patterns described
by Gamma et al. [5] comprising a list of 26 meaningful mod-
eling activities. In order to make those activities applicable
for recommendation and auto-completion, we dened them
in a catalog of activity patterns.
ImageViewer
ImageImageViewer
ImageNewClass
ImageProxy<<Interface >>
Image<<use>>
o4
Addo1
Deleteo6
Addo8
Addo5
Add
o2
Addo7
Add
o3
ModifyViewer Viewer
c1
c3
c2
Figure 1: Modeling activity example: Replacing As-
sociation by Proxy. The initial model state is given
on the left, while required editing operations to es-
tablish the nal state are shown on the right.
Throughout the paper we are using an example of a mod-
eling activity for explaining the proposed auto-completion
concepts. This modeling activity refers to the addition of
the proxy design pattern into an existing software model.
On the left-hand side of Figure 1 an initial model struc-
ture is shown on which the Proxy design pattern could be
applied. The right-hand side of Figure 1 shows exemplar-
ily one sequence of the editing operations o1too8required
to instantiate the proxy design pattern on the preexisting
model.
4. AUTO-COMPLETION OF ACTIVITIES
In this paper, we propose a new approach that computes
auto-completions of UML modeling activities. Furthermore,
it allows a user to preview and to adjust a selected com-
pletion graphically before nally executing the completion.
Our approach is based on the recognition of modeling ac-
tivities and the computation of relevant recommendations,
which we demonstrated in our previous work [8]. This ap-
proach operates on a set of predened activity patterns. For
auto-completion, these patterns are enriched with additional
information supporting the computation of completion ac-
tions. Figure 2 depicts the integration and the interplay of
recommendation approach (gray) and auto-completion ap-
proach (white). Step A.1 toStep A.3 in the gure are ex-
ecuted on every new editing operation of a user. In Step
A.1editing operations are matched to activity patterns and
partly performed activities are recognized. In Step A.3 fur-
ther information in a matched activity pattern is then used
to compute automatically executable completion actions.
These actions can replace the remaining editing operations
of a user's partly performed modeling activity. Step B.1 and
Step B.2 are triggered once a user selects an auto-completion
of a modeling activity. A user can preview and adjust the
computed completion actions before they are eventually ex-
ecuted. The following subsections explain this process in
detail.
552Editing
OperationPreview andAdjust
Completion ActionsExecute
Completion Actions
Complete
Model
StuctureRecognize
Modelling ActivitiesFilter andRank
Modelling Activities
Partly
Performed
ActivitiesActivity
Completion
Completion
ActionsCompute
Completion Actions
Ranked
ActivitiesAdjusts
Executes
PerformsSelects Step A.1
Step A.3Step A.2
Step B.2 Step B.1
Activity Auto -Completion Activity Recommendation
B
AFigure 2: Overview of the proposed approach. The gray parts represent our previous work while the white
parts have been added for the auto-completion approach.
4.1 Step A.3: Compute Completion Actions
A modeling activity tis specied as a set of editing oper-
ations Lt=fo1; :::; o ngthat need to be performed in order
to execute the activity. The goal of an activity could be
replacing elements in a given model structure, introducing
new structure in a model, or removing existing structure
from a model. The example activity "replacing association
by proxy" (see Figure 1) comprises eight editing operations:
tproxy ! Lt=fo1; o2; o3; o4; o5; o6; o7; o8g (1)
The recognition of partly performed modeling activities
requires to detect a valid subset Ltwithin an arbitrary se-
quence of performed editing operations. Invalid subsets of
Ltare sequences of editing operations that cannot be carried
out in the modeling environment, e.g., adding the connec-
torsfo6; o7; o8gwithout adding the target element ( o5) (see
Figure 1). These subsets are omitted during the recognition.
To enable the recognition we express a modeling activity t
in the form of activity patterns. An activity pattern pspec-
ies a valid subset LpofLt. In order to tolerate modeling
variances when recognizing a modeling activity, each valid
subset of editing operations has to be dened in a corre-
sponding activity pattern.
To auto-complete a recognized, partly performed mod-
eling activity, a set of completion actions Lais computed
that compensates remaining manual editing operations not
inLp. A completion action contains all required information
necessary to automatically execute the otherwise manually
performed editing operation within the modeling environ-
ment. The function automate :ox !axmaps a remaining
editing operation oxto a corresponding completion action
automate( ox). For each editing operation oof a modeling
activity tthat is not matched by an activity pattern p, there
exists a corresponding completion action ato complete t:
9a8o( a2La^o2Lt^o =2Lp^a=automate (o) ) (2)
A completion action ais composed of an action type fadd,
delete, modifygand a set of information that describes the
corresponding model element. This set comprises assign-
ments of a value vto an element property:
[ElementProperty ] = [v] (3)
Possible element properties and their allowed values are spec-
ied by the meta-model of the supported modeling notation.
For our work this is the UML meta-model. In accordance
with the meta-model, vcan specify a static value or a list
of alternative static values that a developer can choose from
before executing an auto-completion. For example, comple-
tion action a4in Figure 3 species a connector of type "asso-
ciation" or "aggregation". In addition, also dynamic valuescan be assigned which refer to element properties provided
by matched editing operations. In this case, vspecies a
reference to a binding variable:
[v] = [BindingV ariable]:[ElementProperty ] (4)
Completion action a3 in Figure 3 species the modica-
tion of the element that has been added by editing operation
o2, i.e., the element ID used to automatically execute the
modication is retrieved from the element state of o2. Ad-
ditionally, such dynamic values can be combined with static
values. The name of the modied element in a3will be re-
trieved from preexisting element c2and then concatenated
with the string "Proxy".
$a3 :actiontype =‚Äòmodify‚Äò
id =$o2.id
name =$c2.name +‚ÄòProxy‚Äò
$a4 :actiontype =‚Äòadd‚Äò
type =‚Äòassociation‚Äò ,‚Äòaggregation‚Äò
source =$o2.id
target =$c2.id
target.navigability =‚Äònavigable‚Äò
Figure 3: Denition of completion actions that re-
place the editing operation o3and o4from the ex-
ample activity in Section 3.
Every new editing operation of a user that contributes
to a partly performed modeling activity, i.e., every change
ofLp, triggers an automatic update of the corresponding
completion actions in La.
4.2 Step B.1: Preview and Adjust Completion
Actions
Our approach comprises a graphical user interface for the
preview and adjustment of completion actions. The inter-
face is triggered when a developer selects a recommended
auto-completion. The following requirements specify the
functions provided by the user interface:
R-1 A preview of the auto-completion's result shall be given
to visualize the surrounding model structure and to
clarify all automatic completion actions.
R-2 A user shall be able to adjust completion actions.
R-3 Upon user adjustments, the auto-completion shall be
automatically updated.
R-4 The user shall be able to undo previous adjustments.
In the following paragraphs we discuss the developed func-
tionality in detail.
553Preview Completion Actions.
We propose to visualize completion actions within the di-
agram that was altered by the user ( R-1). Therefore we
create temporary model elements and arrange them in com-
bination with existing elements as dened in an activity pat-
tern. We clarify completion actions by adding colors and
symbols ( add!green plusjdelete!red crossjmodify
!yellow pencil). Figure 4 shows the developed user in-
terface of our prototype system and the auto-completion of
our example activity after the user has performed editing
operation o2ando4.
We prevent the user from directly editing the presented
model structure on the diagram, as she or he could continue
working without executing the auto-completion. Instead,
we show a textual representation of each completion action
underneath the diagram and allow adjustments there (R-
2). As modications to one completion action can impact
others, we restrict them to one edited completion action
at a time and update the entire auto-completion after each
adjustment ( R-3) in order to avoid conicts.
a1
Delete
a6
Adda3
Modifya7
Adda5
Adda8
Add
Figure 4: Graphical user interface for previewing
and adjusting completion actions.
Adjust Completion Actions.
We analyzed possible adjustments to completion actions
and classied them into six categories ( R-2). The proposed
user interface supports those six adjustment types:
A-1 Adjust element property values. A developer can ad-
just element properties specied by a completion ac-
tion. For example, the name "ImageProxy" of a3could
be modied.
A-2 Set unspecied element property values. The interface
should also support the cases that an element property
of a completion action cannot be derived from matched
editing operations. It is then left empty. The execution
of a selected auto-completion is prevented until the
developer adds the required information.A-3 Choose the value of an element property from a set
of options. A developer can switch between dierent
value options if they are specied by a completion ac-
tion. In Figure 3 action a4species two value options
for the type of the added connector.
A-4 Redirect a connector. The developer can choose a dif-
ferent source or target element for a connector if the
completeness of the recognized model activity does not
dene the connector ends clearly. For example, if the
association between "Image" and "ImageProxy" would
not have been added already (a 4is needed) the pre-
existing elements c1andc2(see Figure 1) would not
clearly dene which of the classes represents the sub-
ject and which the client. The source element of the
realization in a6could then be switched between c1
andc2. A change requires to update a8accordingly.
A-5 Choose a dierent model element to be replaced. If a
modeling activity describes the replacement of a model
element it can be the case that this model element can-
not be determined clearly. The user interface should
oer to switch between dierent options. For example,
if the class "Image" would be connected to a dierent
model element by another association it could not be
determined which association has to be deleted in a1.
Switching between both association require to update
the entire auto-completion accordingly.
A-6 Choose an existing element instead of creating a new
one. A completion action for creating a new element
can be replaced by selecting an already existing model
element. For example, the developer could decide to
select an existing interface instead of executing com-
pletion action a5. Therefore a model browser is pro-
vided that allows to select an appropriate model ele-
ment.
Undo Completion Action Adjustments.
The developer shall be able to undo adjustments of com-
pletion actions ( R-4). This functionality is also important
if the modication impacts other completion actions so that
the original intent of the modeling activity may be impacted.
The developer in our illustrating example (see Figure 4)
could decide to reuse an existing interface instead of adding
a new one ( a5) and applies adjustment type A-6. If the
selected interface has been created for a dierent purpose
the adjustment should be undone. To enable an appro-
priate mechanism, our approach caches states of an auto-
completion, i.e., each set of completion actions. This allows
to go back to previous auto-completion states sequentially
(undo ) and also to go forward again ( redo).
4.3 Step B.2: Execute Completion Actions
Once, a user accepts the previewed and and potentially
adjusted completion actions, they are executed on the model.
This requires to remote control the modeling environment
via an API. We use similar functionality to create the tempo-
rary model elements for visualization of an auto-completion.
In order to ensure the correct recognition of following mod-
eling activities, we generate an event for each executed com-
pletion action in the same way as a manual performed edit-
ing operation would have triggered.
5545. PRELIMINARY EVALUATION
The main goal of our approach is the reduction of man-
ual user actions during modeling in order to save modeling
eort. Therefore, we derived the following research ques-
tion: Can the automated completion of a partly performed
modeling activity reduce a user's modeling eort by avoiding
manual actions? We evaluated our approach in a prelimi-
nary experiment, which aims to answer this question.
5.1 Experimental Setup
We implemented a prototype of our approach as plug-in
for the commercial modeling environment Sparx Enterprise
Architect. The prototype integrates the Red Hat Drools 5.5
rule engine. We performed the experiments on a system
with an Intel i7 2.7GHz processor, 4GB RAM, and a 64-bit
Microsoft Windows 7.
Our experiment utilized the catalog of activity patterns
introduced in Section 3. Each activity pattern species a
set of editing operations to be performed. In order to assess
the modeling eort caused by dierent modeling activities,
we rst identied types of user actions within Enterprise
Architect that are needed to perform the editing operations
comprising our activity patterns. We identied six distinct
types of user actions (see Table 1). In order to be able to
aggregate and to compare the eort of these dierent user
action types, we asked ten colleagues independently to rate
the eort for each action type in relation to a single mouse
click. The third column of Table 1 presents that mean eort
ratio for each user action type.
Table 1: Relevant user action types and their esti-
mated eort in relation to a single mouse click
User action Acronym Eort Ratio
Mouse Click LC 1
Mouse Double Click DC 1.5
Mouse Right Click RC 1
Mouse Drag MD 2
Key Stroke KS 1
Navigate Menu NM 1
Secondly, we categorized all editing operations specied in
the pattern catalog concerning their required user actions.
Therefore, we searched for the shortest possible set of user
actions to perform each editing operation within Enterprise
Architect. We found 13 types of editing operations regarding
their required user action types. Table 2 lists the derived
types of editing operations on the left, the numbers of user
actions per type if conducted manually in the middle and
the aggregated eort on the right.
5.2 Experiment: Reduction of User Actions
In the experiment we evaluated the approachs' capability
to reduce the eort required for user actions when auto-
completing a modeling activity. Therefore we derived two
measures. For each activity pattern specied in the activity
catalog and for each of their possible completion states: (I)
we calculated the manual eort that would be necessary to
complete the activity, and (II) we calculated the remaining
manual eort by using the proposed auto-completion func-
tionality. Eort was measured in terms of user action types
(see Table 1).
To determine the eort for manually completing an activ-
ity, we analyzed the activity pattern and categorized eachTable 2: Eort estimation for editing operation
types
Editing Operation Necessary User Actions Total
Category LCDCRCMDKSNM Eort fx
x1Add Element 2 2
x2Add Connector 1 1 3
x3Add Package 4 4
x4Add Attribute or
Method3 1 4
x5Delete Element or
Package2 2
x6Delete Connector 2 1 3
x7Delete Association
Class (+ x6)1 1
x8Delete Attribute
or Method3 1 4
x9Rename Element 1 1.5
x10Rename Package 1 1 2
x11Set Navigability 1 1 1 3
x12Set Multiplicity 1 1 1 3
x13Change Connector
End1 2
editing operation according to Table 2. Based on the num-
bers of categorized editing operations, we calculated the to-
tal eort for the remaining editing operations to complete
the corresponding activity. We repeated this procedure for
all 185 activity patterns describing the 26 activities in all
their completion states.
To illustrate the eort determination process, we exem-
plarily show its calculation for our example "Replacing Asso-
ciation by Proxy". Equation (5) shows all editing operations
to be performed for this activity (see Figure 1). Equation
(6) lists the corresponding editing operation categories (see
Table 2) in the same order. Equation (7) calculates the total
eort for performing the entire activity manually by adding
up all single category rates fx:
Ltproxy =fo1; o2; o3; o4; o5; o6; o7; o8g (5)
Lxproxy =fx4; x1; x7; x2; x1; x2; x2; x2g (6)
fpproxy = 1fx4+ 2fx1+ 1fx5+ 4fx2(7)
= 20
To determine the eort for an assisted activity completion
two user action are to be considered. For selecting an auto-
completion from the recommendation list a double click DC
is needed while the execution of previewed completion ac-
tions is triggered by a single click LC. Accordingly, the eort
for using our auto-completing functionality fais calculated
to 2.5.
Finally, we computed the dierence between both eort
values fpk; k2f1; ::; 185g andfafor all possible comple-
tion states of the dened activity patterns. We aggregated
these values by the number of remaining editing operations
across all activity patterns. Figure 5 plots the average ef-
fort reduction in relation to the number of remaining edit-
ing operations when using the auto-completing functionality.
The gure shows that the approach is on average benecial
even with only a single remaining editing operation left to
complete an activity. A reduction greater than 50% can be
reached when having two ore more editing operations left.
All outliers are above the average and refer to even larger
reductions.
555123456 70 5 10 15 20
Remaining  Editing Ope rationsReduction of Ma nual Eff ortn=60 n=54 n=33 n=20 n=12 n=7 n=3Figure 5: User action reduction in relation to the
number of remaining editing operations for comple-
tion.
6. DISCUSSION AND FUTURE WORK
We proposed an approach intended to reduce user actions
required for completing a partly performed modeling activ-
ity. In an experiment we evaluated the approach for that
capability. We found that the approach can in fact reduce
the number of required user actions from 10% to 86% de-
pending on the completeness of an activity. That means that
the proposed approach can substantially reduce the required
user actions and thereby a user's modeling eort. This re-
sult emphasizes the importance of presenting high quality
activity recommendations to the user. In order to retrieve
the maximum benet of the approach, a user must be able to
select an auto-completion recommendation at the beginning
of a modeling activity (low completeness).
The experiment may contain threads to validity. We com-
puted the result by using the modeling tool Sparx Enterprise
Architect. Although we searched for the shortest possible
sequences of user actions to perform each editing operation
within Enterprise Architect, we may have missed certain
exotic possibilities. Moreover, the eort estimation for user
actions (see Table 1) may not be fully generalizable. This
thread is partly mitigated as we utilized the same estima-
tions to assess remaining manual eort for activity com-
pletion as we used to assess the eort for using our auto-
completion. The presented result may have further been
inuenced by the type of modeling environment that was
used. A future task will be to adapt the approach to other
modeling environments and to replicate the study in order
to gain more generalizable results.
Our experiment shows that the proposed approach is ca-
pable of signicantly reducing manual modeling eort. How-
ever, we would like to point out that this result can only be
regarded as a rst step to evaluated the usefulness of our
approach. Demonstrating its overall usefulness, will require
to consider users' eort for inspecting activity recommenda-
tions and selecting a desired auto-completion and to evaluate
the usability of the proposed graphical user interface. We
are currently preparing a substantial study that also con-
tains controlled user experiments in order to demonstrate
the usefulness of auto-completing modeling activities. Fur-
thermore, we want to investigate the impact of user expe-
rience on the benet of the approach and study whether
the approach can also improve the correctness of performed
modeling activities. Another subject of study will be thescalability of the approach for large models and heavy edit-
ing operation load.
Acknowledgment
We are funded by the German Ministry of Education and
Research (BMBF): grant 16V0116.
7. REFERENCES
[1] T. Arendt, E. Biermann, S. Jurack, C. Krause, and
G. Taentzer. Henshin: Advanced concepts and tools
for in-place emf model transformations. In MoDELS,
pages 121{135, 2010.
[2] J. Arlow and I. Neustadt. UML and the unied
process: practical object-oriented analysis and design .
Number ISBN 0-321-32127-8. Addison-Wesley, 2006.
[3] M. Born, C. Brelage, I. Markovic, D. Pfeier, and
I. Weber. Auto-completion for executable business
process models. In Business Process Management
Workshops , pages 510{515. Springer Heidelberg, 2009.
[4] S. R. Foster, W. G. Griswold, and S. Lerner.
Witchdoctor: Ide support for real-time
auto-completion of refactorings. In International
Conference on Software Engineering (ICSE), pages
222{232, USA, 2012. IEEE Press.
[5] E. Gamma, R. Helm, R. Johnson, and J. Vlissides.
Design Patterns: Elements of Reusable Object-oriented
Software. Addison-Wesley, USA, 1995.
[6] T. Hornung, A. Koschmider, and G. Lausen.
Recommendation based process modeling support:
Method and user experience. In Conceptual Modeling -
ER 2008 , pages 265{278. Springer Heidelberg, 2008.
[7] A. Koschmider, T. Hornung, and A. Oberweis.
Recommendation-based editor for business process
modeling. Data & Knowledge Engineering, 70(6):483 {
503, 2011.
[8] T. Kuschke, P. M ader, and P. Rempel. Recommending
auto-completions for software modeling activities. In
MoDELS, pages 170{186. Springer Heidelberg, 2013.
[9] P. M ader. Rule-based maintenance of
post-requirements traceability . MV Verlag, 2010.
[10] P. M ader and O. Gotel. Towards automated
traceability maintenance. Journal of Systems and
Software, 85(10):2205 { 2227, 2012.
[11] S. Mazanek and M. Minas. Business process models as
a showcase for syntax-based assistance in diagram
editors. In MoDELS, pages 322{336. Springer
Heidelberg, 2009.
[12] A. Reder and A. Egyed. Computing repair trees for
resolving inconsistencies in design models. In
International Conference on Automated Software
Engineering, pages 220{229, USA, 2012. ACM.
[13] S. Sen, B. Baudry, and H. Vangheluwe. Towards
domain-specic model editors with automatic model
completion. Simulation , 86(2):109{126, 2010.
[14] F. Steimann and B. Ulke. Generic model assist. In
MoDELS, pages 18{34. Springer Heidelberg, 2013.
[15] K. Wieloch, A. Filipowska, and M. Kaczmarek.
Autocompletion for business process modelling. In
Business Information Systems Workshops , pages
30{40. Springer Heidelberg, 2011.
556