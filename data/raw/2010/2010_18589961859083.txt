Test Generation to Expose Changes in Evolving Programs
Dawei Qi, Abhik Roychoudhury , Zhenkai Liang
National University of Singapore
{dawei,abhik,liangzk}@comp.nus.edu.sg
ABSTRACT
Software constantly undergoes changes throughout its life cycle,
and thereby it evolves. As changes are introduced into a code base,we need to make sure that the effect of the changes is thoroughly
tested. For this purpose, it is important to generate test cases that
can stress the effect of a given change. In this paper, we propose anautomatic test generation solution to this problem. Given a changec, we use dynamic symbolic execution to generate a test input t,
which stresses the change. This is done by ensuring (i) the change
cis executed by t, and (ii) the effect of cis observable in the output
produced by the test t. To construct a change-reaching input, our
technique uses distance in control-dependency graph to guide path
exploration towards the change. Then, our technique identiﬁes the
common programming patterns that may prevent a given change
from affecting the program’s output. For each of these patterns
we propose methods to tune the change-reaching input into an in-put that reaches the change and propagates the effect of the changeto the output. Our experimental results show that our test genera-
tion technique is effective in generating change-exposing inputs for
real-world programs.
Categories and Subject Descriptors
D.2.5 [ Software Engineering ]: Testing and Debugging— Testing
tools, Symbolic execution
General Terms
Experimentation, Reliability
Keywords
Software Evolution, Test Generation, Symbolic Execution
1. INTRODUCTION
Regression testing is one of the most commonly known software
engineering activities for developing reliable software. In simple
terms, it stresses “program changes” as a program evolves from one
version to another, checking whether new functionality introduced
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00.by the changes is correct and whether the changes result in errors in
existing functionality. Often, regression testing involves re-testingusing a new test-suite containing both existing test cases and newtest cases as the program evolves.
For re-testing with existing test cases, because the test-suite of
a program is often huge, it is inefﬁcient to test the changed pro-
gram with all existing test cases. Most of the past research efforts
in regression testing focus on this inefﬁciency issue and provide so-lutions via test selection [2,12] (selecting a subset of the tests to be
run) or test prioritization [4, 15] (changing the order in which a set
of given tests is run).
However, the evolution of a program often involves addition of
new functionality, and thus the test-suite should also evolve withthe evolution of the program. In this aspect, the key challenge is
to generate test cases related to the changes. Recent work [13, 16,
19] has studied test-suite augmentation for evolving software. Themain task in test-suite augmentation is to ﬁnd new test cases thatstress the program changes and affect the program output. Suppose
a program P(with a test-suite T) evolves to a program P
/prime, i.e.,
Pischanged to produce P/prime. A test-suite augmentation method
should generate test cases that make the effect of the changes vis-
ible in terms of observable program output. If these test cases do
not appear in the existing test-suite T, we add them to T.
Let us now examine an intuitive way of generating test cases
for stressing program changes. Consider an output variable outin
programs PandP/prime, and let the inputs of PandP/primebein1,in2,
..., andink. By performing a strongest post-condition computa-
tion (using symbolic execution) on program P, we represent the
output variable outinPas a formula ϕ(in1,i n 2,...,i n k). Simi-
larly, by performing a strongest post-condition computation on pro-
gramP/prime, we represent the variable outinP/primeas another formula
ϕ/prime(in1,i n 2,...,i n k). We can then solve
ϕ(in1,i n 2,...,i n k)/negationslash=ϕ/prime(in1,i n 2,...,i n k)
and the solutions are test cases (assignments of values to inputsin
1,i n 2,...,i n k) that make the output values different in the two
programs.
Although the above approach is straightforward, it does not scale.
Since we need to perform static symbolic execution on the program
(rather than dynamic symbolic execution on an execution path ofthe program), it is difﬁcult for the approach to scale up to large real-world programs. In this paper, we develop a scalable approach fortest-suite augmentation. Our approach builds on the execute-infect-
propagate (PIE) paradigm [18]: the new tests should (i) execute the
program changes, (ii) infect the program state, and (iii) propagatethe infection to the output.
From a high level, our approach works in two steps. The ﬁrst
step is to generate an input satisfying the execute property in the
397
1intx; /∗Input v ariable ∗/
2inty;
3into; /∗Output variable ∗/
4
5 input(x);
6
7if(x>0){
8y = 3 ; //change : y = 2;
9 if(x−y>0)
10 o = y ;
11 else
12 o = 0;
13}else
14 o = −1;
15
16 if(x>20)
17 o = 10;
18
19 output(o) ;
(a) Example ProgramENTRY
EXIT1475
8
10 12
19179
16
(b) Control Flow GraphENTRY
EXIT
147 5
8
10 1219
17 916
(c) Control Dependence Graph
Figure 1: A motivating example to illustrate our approach.
PIE paradigm. Given a change c(in source code from one program
version to another), we ﬁnd a path that reaches cin the control ﬂow
graph. We then perform symbolic execution along the path to ﬁnd
an input tthat makes the program execute the path leading to c.
The second step of our approach aims to generate test cases thatsatisfy the infect and propagate properties, in addition to the ex-
ecute property. Since any infection in program states is reﬂected
as different variable values (after the change) in the two programversions, we observe that state infection and propagation may be
avoided if (i) variables affected (directly/indirectly) by a programchange are deﬁned but not used, or (ii) the uses of affected vari-
able cannot propagate the change effect forward (by affecting other
variables). If an assignment of some affected variable vis not used
in the execution of test t, we ﬁnd a new test t
/prime(aided by symbolic
execution along a path) that can execute the uses of v. If the use of
variable vdoes not propagate the change effect forward, we ﬁnd a
new test t/primethat can propagate the effect in v.
The preceding describes our method in a nutshell. The key to
the method’s efﬁciency lies in our strategy in avoiding symbolic
execution on programs. Our approach performs every symbolic ex-
ecution along a program path. Note that symbolic execution along
a program path has additional overhead in enumerating and search-ing for the “right” path. We use various analysis methods to guideus to the “right” path. When trying to execute the change, the short-
est path in the control dependency graph guides us to efﬁciently lo-
cate and construct a path to the change. When trying to propagatethe change effect, we identify the reasons for which the propaga-tion terminates, and propagate the change effect to program outputwhile detecting branch correlations on-the-ﬂy (which allows us to
avoid infeasible program paths).
Performing symbolic execution along a path also helps us avoid
the memory alias problem: since the symbolic execution is along a
program path, all memory references are disambiguated.
In our experiments, we tried our test-case generation approach
on two programs: tcas , a small program with multiple versions
(each encoding a different change) from the SIR repository [3]andlibPNG , a large-scale library for manipulating PNG images
(27977 lines of code). For both the subject programs, our methodsuccessfully generated test cases that stress the changes (by produc-ing different program outputs) for almost all the program versions.
2. MOTIV ATING EXAMPLE
In this section, we motivate the problem of test case generation
in evolving programs with an example.
Figure 1 shows an example of evolving programs. In the example
program shown in Figure 1(a), the variable xis the input variable
and the variable ois the output variable. The change is at line 8,
where the assignment of variable yis changed from 3to2.W en o w
need to synthesize a test case that stresses this change. Figure 1(b)
and Figure 1(c) show the control-ﬂow graph (CFG) and control-
dependency graph (CDG) of the example program, respectively, in
which the changed statement is marked in dark color.
In order to test the change, we need test cases that can drive the
program to the changed statement in P/prime, and can result in an output
ofP/primedifferent from that of P.
Reaching the change.
Suppose we have the following test case for the original program
P:x=- 1 . The execution trace of the test case x=- 1 in the changed
program is { 5, 7, 13, 14, 16, 19 }, which does not cover the change
at line 8. Note that there are two branches in the trace, namely line 7
and line 16. If we execute these branches differently, we may drive
P/primeto reach the change. However, some of the branches, such as
line 16, do not help to reach the change. We use the CDG to identify
such branches. From the CDG in ﬁgure 1(c), we can see that node7 can determine whether the change (node 8) is executed, while
node 16 cannot. So we want to execute branch 7 differently. This
analysis (for ﬁnding which branch to evaluate differently) can beautomated via traversal of the CDG. In this example, we constructthe formula (x>0)by ﬂipping the evaluation of the branch in line
7. Solving this formula x>0, we get an input, say x=1 , that
stresses the change.
Affecting program output.
Using the new input x=1 to test both program versions, we get
the same program output 0. Even though the change is executed,
its effect is not propagated into the program output. We can see that
398propagation of the change effect ( y=2 ) stops at the branch in line
9 — this branch is evaluated to false in both the program versions
forx=1 . To propagate the effect of the program change past this
branch, we need the branch to be evaluated differently in PandP/prime,
which is expressed in the following symbolic formula.
(x>0)∧(x−2>0)∧¬(x−3>0)
Anxsatisfying this formula will execute the change, andevaluate
the branch in line 9 differently in the two program versions. This
gives us the answer x=3 . Executing PandP/primeusing the input x
=3, we ﬁnd that the program output is different in both program
versions. Thus, we have generated a test case which executes the
change, and propagates its effect to the program output.
3. OUR APPROACH
Our goal is to generate test cases that make the effect of software
changes observable through difference in program outputs. A testcase for regression testing should drive the changed program to ex-ecute the changes, and the program states affected by the changesshould result in difference in program outputs.
To meet the above requirements, our approach uses symbolic
execution on program traces to guide the exploration of program
paths. The exploration in our approach is guided by the execute-infect-propagate philosophy (execute the change, infect program
state and propagate the infection to output), instead of program path
coverage. Our approach is divided into two steps. First, given a pro-gram change, we use symbolic execution to ﬁnd the constraints onprogram input variables that need be satisﬁed to execute the change.Second, given the constraints (and sample test inputs) generated in
the ﬁrst step, we tune the sample test inputs into test cases that not
only execute the change but also propagate the effect of the changeto the program output.
We now explain these two steps in Section 3.1 and Section 3.2,
respectively.
3.1 Driving the program to reach the changes
Our approach iteratively constructs the change-reaching test in-
puts using symbolic execution. In each iteration, a new test input
is generated to drive the program execution closer to the targeted
change. This process continues until we get a test input that exe-cutes the given program change.
The basic intuition of this step is as follows. We run the test-
suiteT
Pof the old program Pon the changed program P/prime.I fa n y
testt∈TPexecutes the changed statement stmt in the changed
program P/prime, we return t. Otherwise, we collect the path condition
ofP/primewhen it processes tand manipulate the path condition to gen-
erate a new input that “advances” the execution in P/primetowards the
changed statement stmt .
Assume the path corresponding the test input tisπ, which does
not reach the changed statement stmt , andπ’s path condition is
ψ1∧ψ2∧...ψ m. We look for inputs that can make P/primedeviate
fromπto reach stmt . The deviation can be made at any of the
branches along π. If an input makes P/primedeviate from πat thek-th
branch, it must satisfy the following condition:
ψ1∧...∧ψk−1∧¬ψk
That is, the new input satisﬁes the ﬁrst k−1branching conditions
ofπ, but does not satisfy the k-th branching condition. If it is
satisﬁable1, we can generate an input tisatisfying the formula. The
new input tileads to a different path, which can potentially make
P/primereach the target.
1Note that this formula may be unsatisﬁable.Algorithm 1 Reaching the change
1:Input:
2:PP/prime: original and modiﬁed program
3:Tp: The existing test-suite for P
4:Output:
5:tnew: A test case that reaches the difference between PandP/prime
6:unexpanded =∅
7:S=∅
8:stmt=...// this is the changed statement
9:CDG p/prime=computeCDG (P/prime)
10:Gstmt=computeDistGraph (CDG P/prime, stmt )
11:
12: // step1: run the existing test-suite
13: for all t∈Tpdo
14: ret=Execute (P/prime,t)
15: ifret/negationslash=null then
16: return ret
17: end if
18: end for
19: // step2: construct new test case
20: while unexpanded /negationslash=∅and not timeout do
21: select ϕ∈unexpanded with minimum distance
22: remove ϕfromunexpanded
23: let ϕ=(ψ1∧ψ2∧...∧ψk−1∧ψk)
24: construct θ=(ψ1∧ψ2∧...∧ψk−1∧¬ψk)
25: solve θ
26: ifθis satisﬁable then
27: let tθbe an input that satisﬁes θ
28: ret=Execute (P/prime,tθ)
29: ifret/negationslash=null then
30: return ret
31: end if
32: end if
33: end while
34: return null
35:
36: procedure Execute (P/prime,t)
37: execute P/primewith input t
38: let f=(ψ1∧ψ2∧...∧ψm)be the path condition
39: for all if r o m1t om do
40: ϕidef=ψ1∧...ψ i∧ψi+1
41: ifdist(ψi+1)=0 then
42: return t
43: end if
44: ifdist(ψi+1)/negationslash=∞andϕi/∈Sthen
45: S/uniontext=ϕi
46: unexpanded/uniontext=ϕi
47: end if
48: end for
49: return null
50: end procedure
399PartialPath
Condition (PPC)
arecomputed
ft h t hOneroundofdeviations fromPPC
IftheydonotreachchangedstmtfromthesepathsͲdeviatefurtherfromthesedeviations. 
Change
Path for t TChange
Nopathtochange…..
PathfortTP
Figure 2: Summary of Algorithm 1
One of the major challenges faced by this intuitive solution is
to handle the large number of branching conditions. The intuitive
solution cannot handle large-scale software with limited time and
computing resources. To address this problem, we observe that
the negation of certain branching conditions cannot help to reachthe change. For example, in our motivating example described inSection 2 (illustrated in Figure 1), negating the branch condition
at line 16 will not help to drive the execution closer to the change.
Therefore, we need to measure whether the negation of a branchcondition can drive the execution in P
/primecloser to the change. In our
approach, the measure of closeness or proximity of a path π(w.r.t.
the change stmt ) is given by the length of the chain of control
dependencies that need to be traversed from πin order to reach the
change stmt .
In this step, we are working with program paths that have not yet
reached the change stmt . The path conditions of such paths are
referred to as partial path conditions (abbreviated as PPC) in our
terminology. The term “partial” speciﬁcally emphasizes that thechange has not yet been reached. Also, note that the path conditionof any program path πis a quantiﬁer-free ﬁrst order logic formula
satisﬁed by all test inputs that drive P
/primeto execute along π. The no-
tion of partial path conditions is central to our approach. Since we
are trying to construct a feasible program path ( i.e., exercised by at
least one program input) in the changed program P/primethat terminates
at the given change stmt , our method works by constructing a path
that gets “closer” to the change. These partial path conditions arethen explored to see whether they can reach the changed statementstmt , otherwise we explore further deviations from these partial
path conditions of t
iin a similar way ( i.e., by negating the last
branch condition). This, in essence, is the heart of our algorithm
for reaching the changed statement.
Algorithm 1 captures the core method for generating a change-
reaching test case. The inputs to the algorithm are: the old program
P, the changed program P/prime, and the test-suite TPfor program P.
There is a single change between the programs PandP/prime, that is,
PandP/primediffer via a unit change statement stmt . The output of
the algorithm is a test input tnewthat executes this changed state-
mentstmt . The elements in set Sandunexpanded are PPCs
(partial path conditions). Set Sis used to maintain all the PPCs we
have seen to avoid redundancy. Set unexpanded contains all the
PPCs that have not been tried out. In the algorithm, the CDG ofP
/primeis ﬁrst computed, then the distance from each node to stmt
is computed from the CDG of P/prime. This is shown by the func-
tiondist in the algorithm. Thus, let bbe a program branch inthe changed program P/primewhose condition is ψ. Then dist(ψ)is
the shortest path from bto the changed statement in the static inter-
procedural control dependency graph of P/prime. The distance for a PPC
ϕi(ϕi=ψ1∧...ψ i∧ψi+1) is the same as the distance of the last
branch condition in ϕi, that is, dist(ϕi)=dist(ψi+1).
The algorithm ﬁrst looks for a change-reaching test case in the
existing test-suite T. If no existing test case can reach the target,
our algorithm iteratively constructs such a test case in the second
step. In each iteration of the second step, we choose a PPC that is
closest to the target from the PPCs that have not been tried out. Bydeviating at the last branch of the path, we get closer to the targetin each iteration.
From the description of Algorithm 1, we see that it is similar to
the generational search strategy used in SAGE [7]. In SAGE, givena path πfor a test, new paths are explored by negating each branch
inπ, similar to our algorithm. The main difference between our
method and SAGE is in the way that we choose the branches to
negate. Given a set of partial path conditions (obtained from the
path condition ψ
1∧...∧ψmof a program path)
{ψ1∧...∧ψi∧ψi+1|0≤i<m }
we use the distance between ψkand the changed statement stmt
to prioritize the selection of the branch condition to negate. The
distance between ψkandstmt is deﬁned as the weighted shortest
path from the program branch contributing to ψkto the changed
statement stmt in the static inter-procedural control dependency
graph of the changed program P/prime. If the k-th branch condition has
the smallest distance from stmt , it will be negated ﬁrst.
3.2 Propagating the effect of a change to pro-
gram outputs
Executing the changed statement is not sufﬁcient for reﬂecting
the change in the output. A change should ﬁrst affect some pro-gram states, and the effect of the change should be seen from the
output (via propagation of the affected states). In reality, a program
can have a large number of paths. Therefore, any propagation tech-nique is either path insensitive and hence imprecise, or path sensi-tive but not scalable to large programs. In this section, we proposea practical technique for propagating the effect of the change in an
iterative way.
Assumptions. Before we describe our method for propagating
effects of the program change to output, we make some assump-
tions about the programs we work with.
•Assumption 1 : A variable deﬁned in a program must be used
somewhere in the program.
If we have a program that does not satisfy this assumption,
we can use def-use analysis to eliminate all the variables that
are never used. Since we only eliminate the variables that are
deﬁned but never used, this transformation will not change
the program behavior.
•Assumption 2 : All statements are reachable.
If there are unreachable statements, we can eliminate these
statements without affecting the program behavior.
Why a change may not propagate to output. To build a
method that propagates the effect of a change to output, we investi-
gate common reasons for which propagation failed to reach the out-
put. We use PandP/primeto denote the original program and changed
program respectively. The execution trace of input tin program
400Pis denoted as trace(P,t). For a variable deﬁnition statement
instance s/prime, we say the deﬁned variable is “ affected ” when it has
different value than the value deﬁned in s. Statements sands/prime
are aligned statements in trace(P,t)andtrace(P/prime,t)respectively.
Note that the effect of a change could have propagated to certain
distance before the propagation stops. So we do not need to startthe propagation from the change each time, we only need to in-
tervene when the effect stops propagating in the execution. The
change cannot affect the output when none of the affected variablescan affect the output. Suppose an affected variable vis deﬁned in
s
/primeintrace(P/prime,t), the reasons that the different value in vstops
propagating, may now be enumerated as follows.
•The uses of vare never executed before vis redeﬁned in
trace(P/prime,t). As an example, consider the program in our
example.
y=2 ;/ *originall yy=3 ; */
i f( x>0 ) {o=y ; }e l s e{o=0 ; }
Here, the changed statement affects the deﬁnition of y.H o w -
ever, in the execution trace for the input x=0 (and thus
x>0is false), the use of this deﬁnition is never executed.
The output variable ois not affected by the change.
•Uses of vare executed before vis redeﬁned in trace(P/prime,t),
but the use cannot result in other affected variable. As an
example, consider the following program. Let xbe the input,
andobe the output of this program fragment.
y=2 ;/ *originall yy=3 ; */
i f( x-y>0 ) {o=y ; } e l s e{o=0 ; }
Here yis the variable whose deﬁnition is affected by the
change. The use of the deﬁnition is also executed in the form
of the condition (x-y > 0) . However, for input x=0,i t
does not make a difference in the control ﬂow and the subse-
quently calculated output value for o.
Propagating changes to the output. We handle the two rea-
sons for which the effect of a change may not propagate to the pro-
gram output as follows. If the uses of the affected variables are not
executed in an execution trace π, we drive the program execution
towards the use statements. This is achieved via a method similar to
Algorithm 1, where we set the use statements as the target, instead
of the changed statement.
In the second case, the uses of the affected variables are executed
in the trace but no program variables are affected by the use. Sup-
pose the affected variable vis deﬁned in statement instance s/prime, and
vis subsequently used in statement instance m/prime. Obviously, m/prime
was not able to propagate the effect of vforward. According to the
type of m/prime, we use the following steps to propagate the effect in v.
•Ifm/primeis a variable deﬁnition statement, we compute the so-
called “ transfer condition ” [11] (Deﬁnition 1 below) of the
statement. Intuitively, the transfer condition of an expres-
sion is the condition under which the value of the expressionwill be different if one of its operands is different. Given the
transfer condition, we use it in symbolic execution to com-pute a test input which propagates the effect of the change,
while following the same path.
D
EFINITION 1( T RANSFER CONDITION ).The transfer
condition for exp=oprand 1op oprand 2with respect to
oprand 1is the condition under which exp has different value
ifoprand 1has different value.For example the transfer condition of x+y istruesince if
either operand is different, the sum is different. On the other
hand, the transfer condition of x*yisy/negationslash=0 for a change
inx.
•Ifm/primeis an branch and vis used as the condition in m/prime,w e
compute the condition which makes mandm/primeto be eval-
uated differently in the two programs PandP/primein order to
produce different outputs in PandP/prime(mandm/primeare aligned
statements in trace(P,t)andtrace(P/prime,t)). We use sym-
bolic execution to ﬁnd an input that reaches min programs
Pandm/primeinP/primeand then evaluates mandm/primedifferently in
the two programs.
Algorithm for Propagating Change. The algorithm for prop-
agating change effects is shown in Algorithm 2. The algorithm iter-
atively calls procedure Propagate to construct a new input that can
propagate the change effect forward. The procedure Propagate ﬁrst
executes PandP/primeusing the input t. Then it analyzes the execution
traces of PandP/prime. An important concept here is the change effect
propagation tree (CEPT) calculated by CPTree at line 11.
DEFINITION 2( C HANGE EFFECT PROPAGATION TREE ).Given
a unit change, a CEPT CT is deﬁned as follows. The nodes of a
CEPT are statement instances in the changed program P/prime. There is
an edge from α/primetoβ/primeinCT if and only if (i) β/primeis dependent on α/prime
(either control dependence or data dependence) (ii) the operands
ofβ/primehave different values than those of β, where βis the corre-
sponding statement of β/primeinP. Each leaf node in the CEPT is a
place where the change effect propagation terminates.
Note that the CEPT deﬁned above is a polytree [8]. A polytree is
a restricted DAG (Directed Acyclic Graph). While a DAG allows
multiple undirected paths between two nodes as long as they do notform directed cycle, a polytree allows at most one undirected pathbetween any two nodes. Compared to nodes in a tree, a node in apolytree can have more than one parent node, which represents thatmore than one operand in a statement are affected by the change.
Identifying terminating locations of effect propagation.
The CEPT is computed by dynamic forward slicing. During slic-
ing, our approach compares the operand values of corresponding
statement instances in both programs to determine whether the change
effect has stopped propagating. If the operand values of a statementinstance s
/primeinP/primeare the same as those of the corresponding state-
ment instance sinP,s/primewill not be included in the propagation
tree, because it will not cause differences in the output. In otherwords, the change effect does not propagate to s
/prime.
When comparing the operand values of corresponding statement
instances in both PandP/prime,i fs/primeofP/primehas no corresponding state-
ment instance in P, the operands for s/primeare treated as different from
those in P. To compare the operand values, we use trace alignment
to ﬁnd the corresponding statement instance s(in execution trace
ofP)o fs/prime(in execution trace of P/prime), which is the align(P,P/prime,t)
function in Algorithm 2. For simplicity, we use sat(ϕ)to represent
an input instance that satisﬁes ϕ.
Propagating change effects further . According to the type
of the leaf nodes in the change effect propagation tree, we use dif-ferent methods to drive the propagation of the change effect for-ward. If an affected variable is deﬁned but never used, the proce-
dure PropNouse is called. In this procedure, we ﬁrst use def-use
analysis to identify all the use locations of the deﬁned variable, and
use our Algorithm 1 to reach at least one of these locations.
401If an affected variable is used but does not propagate the effect
forward, according to the type of the use statement s/prime, two dif-
ferent procedures are used for propagation. If the statement s/primeis
a variable-deﬁnition statement and the deﬁned variable is used, it
can only become leaf node (of CEPT) when the transfer conditionis not satisﬁed. Procedure PropTransfer is invoked in this case.
In this procedure, we ﬁrst use symbolic execution to compute the
transfer condition TC. Then we get a new input that satisﬁes TC
by solving the formula f
/prime∧TCwhere f/primeis the partial path con-
dition up to s/prime. If an affected variable is used as the condition in
a branch, it becomes a leaf node when the branch is evaluated the
same in both versions. In this case, we use PropCjmp to execute
the branch differently in two versions. If the procedure Propagate
cannot generate a change stressing test input by analyzing the new
program version, we apply Propagate to the old program version.
4. IMPLEMENTATION
We implemented our approach on the x86 platform based on the
BitBlaze [14] binary analysis framework. We show the compo-
nent view of our implementation in Figure 3, where the compo-
nents used in our solution are shown as boxes, and the data used
by the components are shown as italic labels of edges. Some of theimportant intermediate data are shown in ovals.
SMT formula solving is used extensively throughout our ap-
proach. We used the Boolector SMT solver [1] for all our formulasolving tasks.
4.1 Architecture of our implementation
Reaching changes.
The top portion of Figure 3 illustrates the implementation of the
ﬁrst step of our approach: ﬁnding inputs to reach the change. Our
approach ﬁrst computes the static control-ﬂow dependency graph
(CDG): it uses the ERESI tool [5] to generate the static CFG, andthen uses our module CDG builder to compute the inter-procedural
CDG and distance graph from the static CFG. The distance from a
nodevto the target is deﬁned as the shortest path from vtotarget
in weighted CDG. In a weighted CDG, auxiliary edges (such asfunction call to the start of the called function) are associated withweight 0. All other edges have weight of 1. We use Dijkstra’salgorithm to compute the distance of all nodes (to the change) using
one pass of the algorithm.
Next, our approach iteratively constructs an input to reach the
change. Given the binary P
/primeand a test case t, our approach gener-
ates an execution trace of P/primeusing BitBlaze’s TEMU component.
TEMU is a whole-system emulator based on QEMU [10]. It emu-
lates a PC system, which runs operating systems such as Windows
and Linux. TEMU supports logging instructions executed in theemulated PC and tracking instruction operands that are dependent
on program inputs (tainted operands) using taint analysis. Next,
our approach uses BitBlaze’s analysis component, VINE, to gener-
ate the path condition of the execution trace. The path condition is
represented by VINE’s intermediate language.
With the CDG and path condition, our approach uses our change-
reaching input generation module to select a branching condition
to negate based on the distance to the change statement in the CDG.It then generates a new input that drives P
/primeto execute closer to the
change. If P/primereaches the change using the new input, our approach
continues to the next step. Otherwise, the above process is repeated
using the new input until it generates an input that leads P/primeto exe-
cute the changed statement.Algorithm 2 Propagate the change effect
1:Input:
2:t: a change reaching input
3:PP/prime: original and modiﬁed program
4:Output:
5:tnew: a input that have different output in PandP/prime
6:procedure Propagate (P,P/prime,t)
7: align(P,P/prime,t)
8: let stmt be the difference between PandP/prime
9: execute tinP/primeandPto get the execution traces
10: T=CPTree (stmt, P/prime,P,t)
11: for all leaf node s/primeinCT do
12: ifs/primeis a variable deﬁnition statement then
13: ifvariable deﬁned by s/primeis not used in t’s trace then
14: ret=PropNouse (s/prime)
15: else
16: ret=PropTransfer (s/prime)
17: end if
18: else
19: ret=PropCjmp (s/prime)
20: end if
21: ifret/negationslash=null then
22: return ret
23: end if
24: end for
25: return null
26: end procedure
27: procedure PropNouse (s/prime)
28: U=useSet (s/prime)// All ﬁrstuses of the deﬁnition of s/prime
29: for all u∈Udo
30: execute Algorithm 1 using uas the target
31: let retbe the return value from Algorithm 1
32: ifret/negationslash=null then
33: return ret
34: end if
35: end for
36: return null
37: end procedure
38: procedure PropTransfer (s/prime)
39: compute the transfer condition TCfors/prime
40: let the partial path condition up to s/primebef/prime
41: iff/prime∧TCis satisﬁable then
42: return sat(f/prime∧TC)
43: else
44: return null
45: end if
46: end procedure
47: procedure PropCjmp (s/prime)
48: let sbe the corresponding statement instance for s/primein P
49: let the partial path condition up to s/primefortinP/primebef/prime=
ψ/prime
1∧...ψ/prime
i/prime∧ψ/prime
i/prime+1, the path condition up to sfortinPbe
f=ψ1∧...ψ i∧ψi+1
50: let ϕ=f∧ψ/prime
1∧...ψ/prime
i/prime∧¬ψ/prime
i/prime+1
51: let ϕ/prime=f/prime∧ψ1∧...ψ i∧¬ψi+1
52: ifϕis satisﬁable then
53: return sat(ϕ)
54: else if ϕ/primeis satisﬁable then
55: return sat(ϕ/prime)
56: else
57: return null
58: end if
59: end procedure
402TEMU VINEERESIChange−Reaching
Input Generation
Change−propagatinginputnew input
new inputpath
conditionReaching
Changes
ChangesPropagatingtraces
tracesBuilderCDG
CFG
CDG
CEPTbinary of P, P’
GenerationCEPT
Input Generationwith distanceCDG
Figure 3: Component view of our approach (CEPT = Change Effect Propagation Tree, CDG = Control Dependency Graph).
Propagating effects of changes.
The bottom portion of Figure 3 illustrates the implementation of
the second step of our approach: ﬁnding inputs to propagate the ef-
fects of the change to the program output. If the input generated inthe previous step (the input that reaches and executes the change)
cannot affect the output, our approach uses it to generate an ex-
ecution trace of P
/primeand compute the path condition. Then, our
approach generates the Change Effect Propagation Tree or CEPT
(refer Def. 2) to decide how to further propagate the change effect
towards the output.
As described in our algorithm 2, trace alignment is needed to
compute the CEPT. Our approach views each trace as an instruction
sequence, and aligns the traces of PandP/primeusing minimum edit-
ing distance. From the alignment result, we compare the operand
values of P/primewith the corresponding instructions in P, which is re-
quired by our approach to decide whether a node is a leaf node in
computing CEPT. For def-use analysis, we implemented a simpledef-use analysis module without pointer aliasing support.
With the above information, our approach constructs the CEPT
by performing forward slicing on the x86 instruction trace. Each in-
struction is treated as a statement in the slice. One of the practicalchallenges is caused by memory and register allocation in differ-ent program traces. The memory addresses of the same variable
in two binary versions are often allocated differently by compiler
or loader. Therefore, when such addresses become the instructionoperands, the aligned instructions will have different operand val-ues. For example, mov EAX, [EBX] will have different EBX
value if the variable pointed to by the EBX is allocated at different
addresses in the traces of PandP
/prime. However, the difference in
memory address does not imply a different program state, which is
deﬁned by the contents of variables, instead of addresses of vari-ables. Similar issue happens with the stack registers ESP and EBP.
To address this problem, our approach does not treat difference in
memory address operands and stack register operands as differentprogram states.
4.2 SMT solving optimizations
We note that in Algorithm 1 (for constructing an input which
reaches the change), many of the formulae ψ1∧...∧ψk−1∧¬ψk
constructed for reaching the changed statement may be unsatisﬁ-
able. For example, when there is no dynamic data dependence
chain between ψkand input variables (along the path which resultsin the partial path condition ψ1∧...∧ψk−1∧ψk), the formula
ψ1∧...∧ψk−1∧¬ψkis unsatisﬁable. Naturally there is no point
in submitting such formulae to the SMT solver. In this way, we
reduce a signiﬁcant amount of SMT queries, which leads to morethan 90% reduction of SMT solving queries in our experiments.
4.3 Handling branch correlations
Most of the SMT formulae used in our algorithms are based on
path condition. We noticed some branches along the path could becorrelated. Suppose the branch we are trying to negate is b
β, there
is an earlier branch bαthat is correlated with bβ. This correlation
could make the constructed formula unsatisﬁable. We handle thecommon cases of “immediate conﬂicts" between (branch, branch)and (assignment, branch) pairs as follows.
1.if(x>2){ ... // x is not modified here}
if(x<0){ //target }
Given a trace for say x= =3 which evaluates the ﬁrst branch
to true and the second branch to false, suppose we want to
ﬂip the evaluation of the second branch statement to reachthe target. However evaluating x>2 to true and then x
<0 to true constitutes an infeasible path in the control ﬂow
graph.
Solution: When we solve formula θ=(ψ
1∧ψ2∧...∧¬ψk),
if the branch corresponding to ψkisbk, we perform a back-
ward slicing on the trace from bk. All the branch conditions
that are not in the slice are removed from the path condition
θ. In this way, we keep all the branches that are relevant for
reaching bk, and we also keep all the statements that are used
for computing the branch condition.
2.if(x>0) {y=1 ;} else {y=0 ;}
if(y){ //target }
For the input x=0, we can see yis set to 0 from the exe-
cution trace. To reach the target, we need to negate the ﬁrst
branch that the deﬁnition of yis dependent on.
Solution: If we ﬁnd a branch condition ψkis not “tainted”
(dependent on the input via a chain of data dependencies),
we cannot directly negate this branch. Suppose the last deﬁ-nition of ψ
k’s variables in the trace is def, we use backward
slicing to ﬁnd all tainted branches that def is dependent on.
403By negating one of these branches, we may evaluate ψkdif-
ferently.
5. EV ALUATION
To examine the efﬁcacy of our approach, we evaluated our ap-
proach using two real-world programs. In this section, we report
our empirical evaluation results.
5.1 Experience with tcas
The ﬁrst program we used to evaluate our approach was tcas
from the SIR repository [3]. Tcas is an aircraft collision avoid-
ance system. It has an original version (the golden program) and
41 changed versions with seeded bugs, exactly one line of a change
for each bug. The tcas program from SIR reads inputs from com-
mand line, we modiﬁed the program to read inputs from a ﬁle. To
stress our test generation method fully, we took an initial test-suitewith only one randomly generated test case in this case study. Then
we apply Algorithm 1 on this test-suite to generate test cases reach-
ing the change.
Our technique uses 80 runs to reach all the 41 changes, about
two runs to reach one change on average. Out of the 41versions, in
8versions, the inputs generated by Algorithm 1 already produced
different program outputs; thus change effect propagation is not
needed in these cases. These inputs are returned by our approachas the test cases to augment the test-suite.
The remaining 33 buggy versions of tcas needs to go through
change effect propagation (as shown in Algorithm 2), to generatetest cases. Our approach successfully generated test cases that showdifferent program outputs (w.r.t the original tcas program) in 31
out of the 33 program versions. In the remaining two program ver-sions, because of incorrect program alignment at line 7 of algorithm
2, the CEPT was not computed correctly. The node where change
effect propagation terminates was not identiﬁed as a leaf node inthe incorrect CEPT.
Now we discuss two cases where change effect propagation are
needed in tcas . Through these examples, we show that how our
techniques propagate the change effect forward towards the output.
Affected variable deﬁned but not used.. Figure 4 shows
an example in version 3 of tcas , in which the change effect can-
not propagate because the affected variable intent _not_known
is deﬁned but not used. Note that in the example code, one line
of source code is treated as multiple instructions in our technique.In the example, because the operator is changed from && to||,
the variable intent _not_known is evaluated to different values in
two different versions in execution. However, because the value of
tcas_equipped is false, the variable intent _not_known is never
used after its deﬁnition (note that a &&is deﬁned using short circuit
evaluation, that is, if the ﬁrst operand is false, the second operand
is not used). To propagate the effect of the change, we employ our
algorithm 1 to reach the statements where intent _not_known is
used. Algorithm 1 negated the value of tcas_equipped to execute
the condition test on intent _not_known .
Propagation stops because of branches.. From our expe-
rience in the experiments, it is very common that the propagation
terminates because of a branch is evaluated similarly in both ver-
sions. Figure 5 shows the case in version 13 of tcas . The value
compared with Own _Tracked _Alt_Rate is changed from 600 to
700. Only when Own _Tracked _Alt_Rate is in(600,700], the
effect of the change propagates. Through symbolic execution, our
technique found a value 604 for Own _Tracked _Alt_Rate such//original version
intent_not_known = Two_of_Three_Reports_Valid
&& Other_RAC == NO_INTENT;
alt_sep = UNRESOLVED;
if (enabled && ((tcas_equipped
&& intent_not_known) || !tcas_equipped))
//changed version
intent_not_known = Two_of_Three_Reports_Valid
|| Other_RAC == NO_INTENT; / *logic change */
alt_sep = UNRESOLVED;
if (enabled && ((tcas_equipped
&& intent_not_known) || !tcas_equipped))
Figure 4: Variable intent _not_known deﬁned but not used
//orginal version
enabled = High_Confidence
&&(Own_Tracked_Alt_Rate <= 600)&&(Cur_Vertical_Sep > MAXALTDIFF);
//changed version
enabled = High_Confidence
&&(Own_Tracked_Alt_Rate <= 700)
&&(Cur_Vertical_Sep > MAXALTDIFF);
Figure 5: Propagation stops because of branches
that variable enabled is evaluated to different values in two ver-
sions.
Comparison with [16].. We compare our results with [16] —
the only work that generates test cases to stress program changes.
Other research efforts on this topic, such as [13], generate criteria
for propagating effects of changes, but they do not generate test
cases to reach andstress a program change. Therefore, we cannot
compare our experimental results directly with those of [13].
In [16], they build their work based on PIE model. They provide
heuristics to avoid exploring paths that (i) cannot lead to execution
of the change (ii) cannot lead to state infection (iii) cannot lead to
affected state propagation .
To compare with [16], we used the result from ﬁrst 11 changed
versions of the tcas program, the same versions used in the evalu-
ation of [16]. For each version, our technique started with a randomgenerated input, and interactively generated new inputs to reach the
change. The technique in [16] used 95 runs in total to reach all the11 changes. In contrast, our technique used only 32 runs to reach
all the 11 changes. Note that we compare the number of runs for
reaching the change, not the number of runs for propagating thechange effect to the output. This is because, [16] does not reportthe number of runs for propagating the effect of the change to theoutput. Our technique can generate change-reaching inputs with
much fewer runs, because the path exploration in our technique is
guided by a target. We use the notion of distance in the control de-pendency graph to prioritize exploring shorter paths to the change.
In addition to the number of runs reported above, our technique
also made less number of calls to the SMT solver. We used datatainting method to identify branches that cannot be executed differ-ently, as is described in Section 4.2. In our experiments, we foundthat this optimization led to signiﬁcant reduction in the number ofcalls to the SMT solver. More than 90% branch conditions are not
tainted, and thus can be eliminated, in both of our case studies.
5.2 Experience with libPNG
In our second case study, we studied the changes between two
versions of the libPNG program. LibPNG is a open-source li-
404//original version
png_byte red_high =
(trans_value->red > 8) & 0xff;
//changed version
png_byte red_high =
(trans_value->red » 8) & 0xff;
Figure 6: An example change from libPNG
brary for manipulating PNG image ﬁles. It supports almost all the
features of PNG ﬁle format. We used two consecutive versionsfromlibPNG , v1.2.20 and v1.2.21. Each version has a large code
base, running into around 28000 lines of code.
We ﬁrst remove all the obvious syntactic changes that do not af-
fect the semantics of the program. After removing these changes,we are left with 10 changes. Each of these 10 changes are in-
dependent. Therefore, we can construct intermediate versions of
libPNG by applying the 10 changes to version v1.2.20 one by
one. We use c
ito denote change iand use v0tov10to denote the
intermediate versions (Version v0is v1.2.20 and v10is v1.2.21).
Version viis obtained by applying cion Version vi−1. Because the
changes are not correlated, if a change cican affect the output in
vi−1andvi, it can also affect the output in v1.2.20 and v1.2.21.
Instead of randomly generating test inputs, we used the Png-
Suite [17] as the test-suite for evaluating Algorithm 1 on libPNG .
PngSuite is a large collection of PNG ﬁles to test PNG applica-tions. The creator of PngSuite aims to represent all the PNG for-mats when the suite was created in 1998. Because libPNG has
been evolving with the evolution of PNG speciﬁcation, some newfeatures in libPNG cannot be fully tested by PngSuite any more.
This is the exact situation where test-suite augmentation is neededdue to program evolution.
LibPNG comes with a test driver to show how the library should
be used. We modiﬁed the test driver to make the changes statically
reachable. We tried to make the changes to the test driver minimal.
Eight out of all ten changes were reached by existing test cases
in the PngSuite. For the remaining two changes, our algorithm was
able to construct new PNG ﬁles that can drive the execution to thechanges. A PNG ﬁle consists of multiple chunks with different in-
formation. Each chunk contains chunk type, chunk length, check-
sum, and the chunk data. Most functions in libPNG are chunk-
speciﬁc. For example, a function for handling chunk of type iTXt
is only called when there is a chunk of type iTXt in the input PNG
ﬁle. These two changes appeared in functions that handle the iTXt
chunk type. Since iTXt only appears in v1.2 of PNG speciﬁcation,
which was released in 1999, no PNG ﬁles in PngSuite (created in1998) were able to test these two changes. Our algorithm automat-ically generated test inputs of the iTXt type.
After ﬁnishing Algorithm 1 for all the ten changes, we got ten
change-reaching inputs (one for each change). Each of these ten in-puts can only guarantee the corresponding change being executed,but they may not necessarily affect the program output. In fact, we
found that out of the ten change-reaching inputs, seven affect the
program output (that is, the output is different for these inputs inthe two program versions), and the remaining three do not. Amongthese seven changes, six changes are bug ﬁxes, and the other is acontent change in the output message. We show one example of
a bug ﬁx in Figure 6. In the example, the bit-wise right shift op-
erator /greatermuchwas mistyped as greater than operator >in the buggy
version (original version). With the bug ﬁx, the variable red_high
had different values in two versions. This variable was later used to
compute a PNG ﬁle as the program output. The output was alreadydifferent because of this change, so change effect propagation was
not needed in this case.
Three out of the ten change reaching test inputs needed to go
through change effect propagation (Algorithm 2 in our approach).By employing Algorithm 2, we succeeded in altering two of thesethree change-reaching inputs, to produce test inputs which executethe change, andpropagate its effect to the program output. In other
words, we constructed a PNG ﬁle which executes the change and
manifests its effect by producing different outputs in the two ver-
sions of libPNG .
For the last program change, we did not succeed in generating
a change-stressing input. The change-effect propagation stopped
at a conditional jump in this case. The formula constructed was
not satisﬁable because of branch correlation. The heuristics pro-
posed by us to handle branch correlation (see Section 4.3) did notallow us to construct a satisﬁable formula in this case. This isbecause, our heuristics handle “immediate" (branch, branch) and
(assignment, branch) conﬂicts. It does not handle “transitive con-
ﬂicts" where the branch correlation cannot be explained by a pair
of assignments/branches. For example consider the code fragment
x=1 ;y=x ;i f( y>2 ) Here the direction of evalua-
tion of y>2 is ﬁxed by the past two assignments, but there does
not exist any pair of statements which can explain the infeasibility
of the sequence of statements being executed for any input.
In summary, there are ten changes in our experiment with libPNG ,
our technique succeeded for nine of them. In the ﬁrst step of our
technique, we successfully get ten change-reaching inputs for all
the changes. Eight of these ten inputs are from existing test-suite,
the other two inputs are generated by our Algorithm 1. In the sec-ond step of our technique, our Algorithm 2 modiﬁes the resultsfrom the ﬁrst step to get inputs that have different output because
of the changes. The second step succeeded on nine changes and
failed on only one change.
6. RELATED WORK
To test evolving programs, there have been several research ef-
forts under the banner of “regression testing.” Even though re-
gression testing in general refers to any testing process intended to
detect software regressions (where a program’s functionality stopsworking after some change), often regression testing amounts to
re-testing of tests from an existing test-suite. In the past, there have
been several research directions that go beyond re-testing all of the
tests of an existing test-suite. One stream of work has espoused test
selection [2, 12] — selecting a subset of tests from existing test-suite for running on the modiﬁed program. Another stream of workproposes test prioritization [4, 15] — ordering tests in an existing
test-suite to better meet testing objectives of the changed program.
Recent research projects [13, 16, 19] have proposed test-suite
augmentation — developing new tests to stress the effect of the
program changes, and these are the works that are closest to our
method. We now compare our work with these methods.
The technique in [13] focuses on generating criteria for test-suite
augmentation. Their technique starts from the change and guaran-
tees the change effect is propagated up to certain distance. Ourtechnique differs from [13] in several aspects. The work of [13]
can either be used to select test cases from a large test pool or can
be used as the criteria to drive test generation techniques. In con-trast, our technique generates test cases, and the test cases gener-
ated by our technique are guaranteed to satisfy the criteria of [13].
The technique of [13] performs static symbolic execution (on a pro-
gram), whereas we perform symbolic execution on a dynamic exe-cution trace. Generally the scalability of static symbolic executionis always an issue, and for this reason we believe [13] restricts the
405use of symbolic execution to certain length of dependencies. Our
technique is not restricted by the length of dependence chains, and
we can handle change effect propagation to any length.
Overall, the work of [13] requires an input which reaches the
change, but how such an input is obtained is not considered in their
paper. Automatically constructing a change-reaching input is difﬁ-cult for large programs with huge number of control ﬂow paths. In
our work, we construct an input that reaches the change andpropa-
gates its effect to the output, whereas the method of [13] starts from
the change itself (how to reach the change is not studied).
White-box concolic testing techniques from Directed Automated
Random Testing or DART ( e.g., see [6]) can be used to generate test
cases using symbolic execution. The original works on DART fo-cused on test generation to systematically explore program paths.
There was no study on generating tests to stress program changes.However, recently some test generation methods [16,19] for evolv-
ing programs have been proposed, which are based on DART. The
technique in [16] integrates heuristics to avoid paths that cannotlead to a change and paths that cannot propagate the change-effect.Since they do not consider the distance to the program change,
if there are multiple paths leading to the change (as is often the
case), their technique would randomly choose one, whereas ourtechnique would prioritize shorter paths. For change effect prop-agation, the work of [16] only provides heuristics to avoid tryingout paths which are unlikely to propagate effects of changes. In
contrast, we use dynamic symbolic execution to guarantee the ad-
vancement in propagation of change effect.
The work in [19] identiﬁes “dangerous edges” affected by the
change in control ﬂow graph. Subsequently, heuristics (built on top
of symbolic execution using DART) are used to stress these edges.
However, after the dangerous edges are identiﬁed, the entire anal-ysis is carried out in the changed program. It is important to notethat any test generation that analyzes only one program version isunlikely to ﬁnd the test cases to stress changes. As an example we
can consider the two versions of Figure 1 as an example. Consider
the test-suite {x = 0, x = 1, x = 4, x = 100} . These tests stress the
set of all feasible control ﬂow paths in the changed program of Fig-ure 1. Thus, it even achieves path coverage! Whatever dangerous
edges are identiﬁed, clearly they will be stressed by the tests in this
test-suite. However, this test-suite still does not contain the onlytest input x=3 that will stress the program change in this example.
In contrast, our technique automatically constructs the input x=3 ,
which behaves differently in these two versions.
Finally, differential symbolic execution (DSE) [9] uses static sym-
bolic execution to characterize the effect of changes. Thus theyform a summary of changes across program versions. The sum-maries are achieved by abstracting large same portions between the
original version and the changed version to reduce cost and im-
prove efﬁciency. Such a technique, while useful for change com-prehension, cannot be directly used for test-suite augmentation. Ifwe employ the technique for test-suite augmentation we need toemploy symbolic execution of programs for large code-bases (the
similar portions across program versions can be abstracted in a
summary, but it is not clear how to avoid symbolic execution ofthis common code-base while generating new tests).
7. DISCUSSION
In this paper, we present a test-suite augmentation method which
stresses program changes. To stress a change cin a program, our
technique automatically generates a new test case tthat gives dif-
ferent outputs in two versions. Our technique works mainly in two
steps. In the ﬁrst step, we use distance in Control Dependency
Graph to guide our path exploration towards the change. After achange-reaching input is constructed, our technique use change ef-
fect propagation tree to identify why a change cannot affect output,
and then propagate its effect accordingly.
In the case of correct refactorings, we expect the technique to
not generate any new inputs. Since such a change does not result in
different program state, our test-suite augmentation method indeeddoes not generate any change-stressing inputs in such a case.
We have implemented our technique in a toolset based on Bit-
Blaze [14]. To test the efﬁcacy of our technique, we performed twocase studies on tcas andlibPNG . For almost all the changes we
studied, our tool was able to generate a new test case that stressesthe change and causes difference in program outputs. Comparedwith existing test-suite augmentation techniques, our technique is
more goal-directed since we: (i) employ metrics like distance in
the control dependency graph to reach the change quickly (this en-ables us to ﬁnd a short program path to the change), and (ii) employheuristics to handle correlated branches while propagating the ef-
fect of program change to output (this enables us to avoid searching
through many infeasible program paths).
In terms of future work, we can extend our method to handle
test programs which stress multiple changes. If the changes areindependent (as was the case in our experiments with libPNG ),
the method proposed in this paper can handle multiple changes.However, for inter-dependent program changes (such as when thevariable sets affected by two changes have a non-empty intersec-tion), our method needs to be further augmented. This remains an
important avenue of future work.
Acknowledgments. This work was partially supported by a De-
fence Innovative Research Programme (DIRP) grant (R-252-000-
393-422) from Defence Research and Technology Ofﬁce (DRTech).
8. REFERENCES
[1] R. Brummayer and A. Biere. Boolector: An efﬁcient smt solver for bit-vectors
and arrays. In TACAS , 2009.
[2] Y . Chen, D. Rosenblum, and K. V o. Testtube: a system for selective regression
testing. In ICSE , 1994.
[3] H. Do, S. Elbaum, and G. Rothermel. Supporting controlled experimentation
with testing techniques: An infrastructure and its potential impact. Empirical
Software Engineering , 10(4), 2005.
[4] S. Elbaum, A. Malishevsky, and G. Rothermel. Prioritizing test cases for
regression testing. In ISSTA , 2000.
[5] ERESI. http://www.eresi-project.org/, 2009.
[6] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed automated random
testing. In PLDI , 2005.
[7] P. Godefroid, M. Levin, and D. Molnar. Automated whitebox fuzz testing. In
NDSS , 2008.
[8] J. Pearl. Probabilistic reasoning in intelligent systems: networks of plausible
inference . Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1988.
[9] S. Person, M. B. Dwyer, S. Elbaum, and C. S. P ˇasˇareanu. Differential symbolic
execution. In FSE, 2008.
[10] QEMU. QEMU emulator. http://www.qemu.org , 2009.
[11] D. Richardson and M. Thompson. The relay model of error detection and its
application. In Workshop on Software Testing, V eriﬁcation, and Analysis , 1988.
[12] G. Rothermel and M. J. Harrold. A safe efﬁcient regression test selection
technique. TOSEM , 6(2), 1997.
[13] R. Santelices, P. K. Chittimalli, T. Apiwattanapong, A. Orso, and M. J. Harrold.
Test-suite augmentation for evolving software. In ASE, 2008.
[14] D. Song et al. BitBlaze: A new approach to computer securityvia binary
analysis. In ICISS, Keynote paper , 2008.
[15] A. Srivastava and J. Thiagarajan. Effectively prioritizing tests in a development
environment. In ISSTA , 2002.
[16] K. Taneja, T. Xie, N. Tillmann, J. de Halleux, and W. Schulte. Guided path
exploration for regression test generation. In ICSE, New Ideas and Emerging
Results , 2009.
[17] W. van Schaik. Pngsuite. http://www.schaik.com/pngsuite/, December 1998.
[18] J. M. V oas. PIE: a dynamic failure-based technique. IEEE TSE , 18(8):717–727,
Aug. 1992.
[19] Z. Xu and G. Rothermel. Directed test suite augmentation. In APSEC , 2009.
406