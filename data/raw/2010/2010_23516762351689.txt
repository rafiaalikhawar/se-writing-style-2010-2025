User-Aware Privacy Control via Extended
Static-Information-Flow Analysis
Xusheng Xiao1∗Nikolai Tillmann2Manuel Fahndrich2
Jonathan de Halleux2Michal Moskal2
1Dept. of Computer Science, North Carolina State University, Raleigh, NC, USA
2Microsoft Research, One Microsoft Way, Redmond, WA, USA
1xxiao2@ncsu.edu,2{nikolait, maf, jhalleux, micmo}@microsoft.com
ABSTRACT
Applications in mobile-marketplaces may leak private user infor-
mation without notiﬁcation. Existing mobile platforms provide lit-
tle information on how applications use private user data, making
it difﬁcult for experts to validate applications and for users to grant
applications access to their private data. We propose a user-aware
privacy control approach, which reveals how private information is
used inside applications. We compute static information ﬂows and
classify them as safe/unsafe based on a tamper analysis that tracks
whether private data is obscured before escaping through output
channels. This ﬂow information enables platforms to provide de-
fault settings that expose private data only for safe ﬂows, thereby
preserving privacy and minimizing decisions required from users.
We built our approach into TouchDevelop, an application-creation
environment that allows users to write scripts on mobile devices
and install scripts published by other users. We evaluate our ap-
proach by studying 546 scripts published by 194 users.
Categories and Subject Descriptors
D.2.4 [ Software Veriﬁcation ]: Validation; K.4 [ Computers and
Society ]: Privacy
General Terms
Human Factors, Security, Veriﬁcation
Keywords
Mobile Application, Privacy Control, Information Flow Analysis
1. INTRODUCTION
Modern mobile-device platforms like iOS, Android, and Win-
dows Phone provide a central place, called app stores or market-
places, for ﬁnding and downloading third-party applications. A
common problem faced by these mobile-device platforms is that
the published applications in the marketplace may leak private user
information through output channels. Many of these applications
∗Worked on this project as a Microsoft Research intern.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE ’12, September 3-7, 2012, Essen, Germany
Copyright 12 ACM 978-1-4503-1204-2/12/09 ...$15.00.
Figure 1: Information ﬂow view of a sample script
access mobile-device resources, such as pictures and GPS that may
contain and expose private information, and share them using re-
mote cloud services or web services without notifying users [1].
To mitigate these problems, privacy control mechanisms em-
ployed by mobile-device platforms include two major parts: (1)
manual app validation by experts: experts employed by an app
store manually exercise the functionality provided by an app and
observe its behaviors for validation; (2) access-control granting by
users: app stores ask for permissions before users can install ap-
plications (Android and Windows Phone), or an app requests per-
missions before it can access users’ private information (iOS). The
manual validation process is costly and delays publishing of apps.
It is also incomplete, since it cannot examine every execution path
to detect violations of privacy policies [2]. Access-control granting
provides information about what private information these appli-
cations may access, rather than how these applications use private
information, causing users to make uninformed decisions on how
to control their privacy. These privacy control mechanism lead to a
situation where users simply install applications without question-
ing the requested permissions, even if the applications may silently
leak private information [1, 3, 4].
To improve the privacy control mechanism of these mobile plat-
forms, we provide a user-aware privacy control approach that re-
duces efforts for app validation and access-granting by computing
information ﬂows and classifying information ﬂows as safe/unsafe.
Our approach automatically computes information ﬂows of pri-
vate information via static analysis and visualizes the ﬂows, as
shown in Figure 1. We use the term Source to refer to an origin
of private information and Sink to refer to a point where informa-
tion may leak from an app. The example in Figure 1 shows that the
app uses 5 capabilities ( Camera ,Location ,Pictures ,Media , and
Sharing ). Among these, the ﬁrst 3 are sources, and the last two
are sinks. Among the 6 possible ﬂows (3 sources to 2 sinks), our
analysis shows that the Location ﬂows to the Sharing sink, and
thatCamera andLocation ﬂow to the Media sink.Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00
80
Given the computed information ﬂows, our approach employs
the mechanism of user-driven access control [5]. When the appli-
cation is executed for the ﬁrst time, our approach allows users to
choose among realinformation, anonymized information, or abort
execution, as shown in Figure 2 (the abort option is not yet imple-
mented in TouchDevelop). These settings provide ﬂexible choices
for users: (1) using anonymized information (e.g., a ﬁxed picture or
a ﬁxed geolocation), users can experiment with applications before
granting access to real information; (2) aborting an execution pre-
vents unintended access to a resource and is helpful for diagnosis.
To assist experts and users in better understanding how apps han-
dle private information and improve privacy control, our approach
further classiﬁes information ﬂows based on a tamper analysis. We
deﬁne a policy to classify information ﬂows as safe or unsafe: an in-
formation ﬂow is safe if only untampered private information ﬂows
to a vetted sink. A vetted sink is a sink that presents an explicit
dialog requesting the user’s permissions before the information be-
ing shown escapes. In Myer’s terminology [6], this dialog corre-
sponds to a declassify step and tampered data has low integrity.
For example, in TouchDevelop [7], the sharing of a picture taken
directly from the camera shows a dialog for users to review the
picture before it leaks from the device. Such information ﬂows
do not leak private information without notifying users and should
be safe. However, a malicious app could encode the user’s phone
number into the color intensity of some pixels inside a picture to be
shared. The information ﬂow will reveal that private information
from the camera andcontact sources ﬂow to the share sink, but a
user may be hard pressed to recognize any changed pixels in the
picture being posted. Our analysis detects such obscure ﬂow by
observing whether the information is tampered with before reach-
ing the sinks. Based on the safe/unsafe classiﬁcation of ﬂows, our
policy is to use real information for sources only appearing in safe
ﬂows, and anonymized information for all other sources.
Our user-aware privacy control approach strives for a balance
between security and user involvement. By employing user-driven
access control, our approach ensures that apps gain permissions
from users for private information accessed by apps. To avoid over-
whelming the users with access granting—which may annoy users
and cause users to blindly grant every permission—our approach
does not ask users to grant access to private information accessed
by an app but not ﬂowing to sinks. Furthermore, our technique
provides default settings that are safe to run a script without further
user decisions, thereby reducing risk and user burden.
We built a prototype of our privacy control into TouchDevelop,
a novel mobile platform that enables users to write apps directly
using touch screens. In TouchDevelop, apps are written using a
scripting language that is expressive enough to create applications
or games, utilizing most features of mobile devices [8]. We call
apps written in TouchDevelop “scripts”. Users can publish their
scripts in a “script bazaar”, where other users can install and run
them on their own devices. TouchDevelop is thus similar to other
mobile-device platforms, except that we use no manual validation,
only automatic information ﬂow analysis. Our approach works well
with the TouchDevelop platform for several reasons: (1) all code is
made available through the script bazaar as source; (2) the expres-
siveness of the language enables apps to be created in fewer lines,
allowing efﬁcient static analysis on whole scripts; (3) the language
does not allow reﬂection, eval, or native calls to platform APIs,
making code analysis easier [9].
This paper makes the following contributions:
•We propose a user-aware privacy control approach, which
reveals information ﬂows and their classiﬁcation to users to
assist app validation and user-driven access control. Our ap-
Figure 2: Grant access to private information
proach is a ﬁrst step towards improving privacy control on
mobile devices via automatic analysis.
•We present an extended static analysis to compute informa-
tion ﬂows and check tamper information for classifying in-
formation ﬂows as safe/unsafe ﬂows.
•The automatic computation and classiﬁcation of information
ﬂows and resuling safe default settings enable our script bazaar
to operate without any manual script validation .
•We built a prototype of our privacy control into TouchDe-
velop, both for analyzing published scripts, and to present
user privacy settings to the user based on our analysis and
policy.
•We studied 546 scripts published by 194 users to evaluate the
effectiveness and performance of our information ﬂow anal-
ysis. The results show that among the 546 scripts, 172 use
a private source, but only 78 scripts (14.29%) ﬂow private
information to a sink. Among these 78 scripts, our approach
classiﬁes 24 as safe, reducing the need to make access grant-
ing choices to a mere 10.1% (54) of all scripts. Alternatively,
users need to grant access to only 63 sources (41.4%) among
152 sources appearing in scripts together with sinks.
2. TouchDevelop LANGUAGE
TouchDevelop allows users to create applications using an im-
perative and statically typed language [8]. A TouchDevelop script
consists of a number of actions (procedures) and global variables.
The body of actions consists of: (1) expressions that either up-
date local or global variables (assignments), invoke another ac-
tion, or invoke a predeﬁned property; (2) conditional statements
if−then−else, (3) loop statements, for,while , and foreach , that it-
eratively execute a block of statements. The global variables are
statically typed and their current value is persisted and accessible
across multiple script invocations.
As a statically typed language, TouchDevelop deﬁnes a number
of data types (e.g., Number orString fors, orPicture forpin
Figure 3). Each data type provides a number of properties (e.g.,
p→share ). For the sake of the simplicity, the language does not
provide features that allow users to deﬁne new types or properties.
2.1 Classiﬁed Information Flow
In this section, we illustrate several examples to show how scripts
written in TouchDevelop may leak private information (referred to
asclassiﬁed information ). Figure 3 shows an example of how clas-
siﬁed information ﬂows among values, such as Number andString .
At line 4, variable locbecomes classiﬁed since it contains the ge-
olocation information obtained via the GPS. Here, we refer to the811action foo() : Nothing {
2 vars := "unclassiﬁed";
3 varp := media→create picture();
4 varloc := senses→current location; // classiﬁed
5 s := loc→describe(); // classiﬁed
6 p→draw text(s); // p’s mutable state is classiﬁed
7 p→share("facebook");
8}
Figure 3: Example of classiﬁed information ﬂow
1action foo(msg : Message , msgs: MessageCollection , i:
Number ) :Nothing {
2 varpic := senses→take camera picture;
3 pic→share(’facebook’,’share a pic’);
4 vars := currLoc(); // classiﬁed
5 msgs→add(msg);
6 msg→set message(s); // classiﬁed
7 varmsg2 := msgs→at(i); // classiﬁed via reference −type
ﬂow
8 msg2→share(’facebook’);
9 vary :=false ;
10 ifs→contains(’Seattle’) then {
11 y :=true; // classiﬁed via implicit ﬂow
12 }
13}
14
15action currLoc() returns r : String {
16 varl := senses→current location; // classiﬁed
17 r := locations→describe location(l); // classiﬁed
18}
Figure 4: Implicit and reference-type information ﬂow
property senses→current location as a Source of geolocation in-
formation. At line 5, the location is transformed into a string and
assigned to s, thereby making sclassiﬁed. At line 6, the location
string sis rendered as text into the picture p, causing pto be classi-
ﬁed. At line 7, the share action of pleaks the classiﬁed information
of the user’s geolocation to facebook. Here we refer to the property
share as a Sink. One thing to note is that if line 5 were moved to
after line 6, then pwould not be classiﬁed. The later update of s
would not affect p.
Now let’s look at another example shown in Figure 4. At line
5, the message msg is added to the message collection msgs . The
message collection msgs keeps a reference to msg, which means
that msg can be accessed from msgs at a later time. At line 6,
msg becomes classiﬁed, which causes msgs to be classiﬁed indi-
rectly. At line 7, msg2 , the i-th message in msgs , may contain the
information of msg or other messages. Thus, msg2 should also be
considered as classiﬁed. We refer to this type of information ﬂow
as reference-type ﬂow, since it occurs through objects such as mes-
sage collections that contain references to other objects.
Another type of information ﬂow that can potentially leak private
information is implicit ﬂow [10,11]. Implicit ﬂow arises from con-
ditional control structures such as ifstatements where the condition
depends on classiﬁed information. The statements in the branches
of the conditional statement can leak the outcome of the condition,
which allows later code to determine the classiﬁed information in-
directly. Consider the example of implicit ﬂow shown in Figure
4. The classiﬁed local sis used at the ifstatement at line 10. By
observing the values of y, users can guess whether the geolocation
information stored in scontains the substring Seattle . Thus, to track
implicit information ﬂows, we need to consider yas classiﬁed.
3. CAPABILITY IDENTIFICATION
The application capabilities tell users what kinds of mobile-device
resources (such as personally-sensitive information and wirelessTable 1: Capabilities provided by the TouchDevelop APIs
Capability Description
SourceCamera Takes a picture through the camera.
Location Gets the geo location, possibly using GPS.
Picture Accesses the picture libraries.
Music Accesses the music library.
Microphone Accesses the microphone.
Contacts Accesses emails or phone numbers of con-
tacts.
SinkContacts Saves an email or phone number of a contact
to the device.
Media Saves pictures to the phone.
Sharing Share information through social services,
email or short messages.
Web Accesses the web, downloading or upload-
ing data.
network) an application uses, which is useful information for users
to decide whether to install the application. These resources can
be classiﬁed as sources (such as camera or geolocation) and sinks
(such as web or facebook sharing). To use these resources, ap-
plication developers need to use the APIs provided by the device-
speciﬁc development environment, also called software develop-
ment kit (SDK). Table 1 shows the kinds of sources and sinks pro-
vided by the TouchDevelop APIs. Among these sinks, the sink
Sharing prompts users with the sharing information, which makes
it a vetted sink. For the other three kinds of sinks, only the sink
Web is considered as an unvetted sink. The reason is that the pic-
tures from the sink Picture and emails or phone numbers from the
sink Contacts are all considered as sensitive private information,
and if these kinds of private information would ﬂow to Web, our
approach would identify the ﬂow as an unsafe ﬂow.
Automated Capability Identiﬁcation. To provide the ac-
curate and complete information of what resources are accessed
by applications, our approach provides a static analysis that scans
through the application script to automatically identify application
capabilities. We have manually annotated all TouchDevelop APIs
with source and sink information. We use a ﬁxpoint algorithm to
compute the capabilities used by each action of a script. For each
action in a script, our approach parses the action into an abstract
syntax tree (AST), and automatically scans each statement node in
the AST to identify what sources and sinks are used. If a statement
in an actiona1is a call to another action a2, our approach adds the
sources and sinks of a2toa1. A ﬁxpoint is reached if the computed
sources and sinks for each action do not change. Since applica-
tion developers in TouchDevelop can only use the APIs provided
by the device-speciﬁc SDK for accessing mobile-device resources,
our analysis results are guaranteed to be accurate and complete.
4. INFORMATION FLOW ANALYSIS
In this section, we ﬁrst present an overview of our static informa-
tion ﬂow analysis, and then follow it up with full technical details.
4.1 Overview
Our approach statically computes information ﬂows using ab-
stract interpretation [12]. Our approach maintains the abstract state
of the script and updates the state according to the simulated ex-
ecution of a statement. The state maps local variables to sets of
sources. In addition it maps a single mutable location for each kind1
to a set of sources. Finally, the state maps sinks to sources ﬂowing
to that sink. Sinks can be thought of as additional mutable loca-
tions that accumulate what ﬂows into them. Information ﬂow from
1Data types in TouchDevelop are called kinds.82a sources1to a sinks2arises whenever source s1appears in the
abstract state of sink s2. The sources in our maps are represented
as a set of value elements consisting of constant sources and in-
put parameter names. Input parameter names are used to represent
symbolic information that allows us to determine where parameters
ﬂow.
Implicit Flows. In order to handle implicit ﬂow arising from
control ﬂow statements that branch on classiﬁed information, we
use an additional special local variable named pc. The pcvariable
is assigned (augmented) with source information at conditionals at
the entry of both branches. At each basic block, the pcis deﬁned
by the value of pcat the immediate dominator block instead of all
predecessor blocks as is the case for normal locals.
Inter-Procedural Analysis. Our approach uses a ﬁx-point al-
gorithm to iteratively compute the summaries of basic blocks in an
action and then uses these summaries to compute summaries of ac-
tions. At call-sites, summaries are instantiated with concrete values
for symbolic parameter names, thereby computing the effect of the
call without re-analysis of the action. This approach also handles
recursive actions.
Mutable and Immutable Values. We map the TouchDevelop
concepts to a simpler model for information ﬂow analysis. We can
think of each kind of value as having two separate parts: 1) an
immutable part , and 2) a mutable part . Many types of values have
only an immutable part and no mutable parts, e.g., Number ,String ,
andGeoLocation . Other types of values have both immutable parts
and mutable parts. E.g., Picture has an immutable part that is as-
sociated with whether the picture is valid (i.e., whether the pointer
is null). The mutable part of a picture consists of the actual pixel
colors at each coordinate of the picture.
We track information ﬂow separately for the mutable and im-
mutable parts of values. The immutable part of an object is copied
whenever a value is assigned from one local to another, passed as
parameter, returned from a method, stored or loaded from a global
variable. The immutable part of a value is tracked precisely at
each program point and assignments are strong assignments that
replaces the original values.
The mutable part of an object is affected only by pre-deﬁned
property invocations (i.e., primitive methods). We track the muta-
ble part of values using an abstraction where we have a single mu-
table location per kind. Every value of that type shares that same
mutable location in the analysis. All updates to the mutable part
are weak updates, meaning they are accumulated.
Primitive properties are annotated with information that indi-
cates from which parameters (and thus which kinds) the mutable
state is read, and also what mutable parts are written (parameters
and return values).
Embedded References. Because values may have embedded
references to other values that could be mutable, we also keep track
of such embedded references using directed edges from one muta-
ble location to another. The model currently does not accommodate
references from immutable parts to mutable parts, but we have not
found a need for that. Establishing a reference from one value to
another implies a write to the mutable state of the ﬁrst.
Globals. To simplify the description in the remainder of the pa-
per, we eliminate global variables from the model. Global vari-
ables are treated as extra parameters and return values from eachaction. One can easily transform a program with globals to a pro-
gram without globals by adding all globals used in an action (and
actions called) as extra parameters, and all globals modiﬁed by an
action as extra return values. As a result, inside an action, access-
ing a global is no different than accessing a local variable. We will
thus no longer explicitly talk about global variables henceforth.
Parameters. Parameters of an action are treated as ordinary lo-
cals inside an action. They are pre-initialized by the action invoca-
tion, but otherwise act no differently than normal local variables.
Results. Result variables are treated as ordinary locals inside an
action. Upon return, their immutable parts (values) are copied to
the caller’s locals that receive the results of the invocation.
4.2 Simpliﬁed Language
We assume that our input program consists of a number of ac-
tions, where each action has any number of parameters and any
number of results. The body of an action consists of a control ﬂow
graph of basic blocks, with a distinguished entry block and a dis-
tinguished exit block. Conditionals branching on condition care
transformed into non-deterministic branches to the then andelse
blocks, where the target blocks are augmented with a ﬁrst instruc-
tion of the form assume(c) andassume( notc).
The instructions inside a block have the following forms:
Instruction ::=x:=y|r:=p(x1..xn)
|r1..rn:=a(x1..xm)|assume (x)|assume (¬x)
An instruction is either a simple assignment from one local to an-
other, a primitive property invocation of parameters x1..xnbind-
ing the result to a variable r, an action invocation with parame-
tersx1..xmbinding the results of the action to r1..rn, or a spe-
cialassume statement arising from conditional branches. We as-
sume that primitive operations always return a value, even if it is
theNothing value.
4.3 Summaries of Basic Blocks and Actions
We separate the state into three parts: 1) local variable infor-
mation, 2) pc information for implicit ﬂow, and 3) mutable state
information. The ﬁrst two are program point speciﬁc, but the mu-
table state is not. The mutable state consists of one classiﬁcation
per kind, and a set of edges between kinds representing possible
references from the mutable state of objects of one kind to objects
of another kind.
Atom ::=Sources (i)|Parameter (i)|PCin
Classiﬁcation ::=Set of Atom
LocalMap ::=Block→Local→Classiﬁcation
SinkMap ::=Block→Sink(i)→Classiﬁcation
PCMap ::=Block→Classiﬁcation
MutableState ::=Kinds (i)→Classiﬁcation
References ::=Set of (Kinds (i)×Kinds (i))
The ﬁxpoint computation computes the following data structures:
Lpre,Lpost:LocalMap
PCpre,PC post:PCMap
Spre,Spost:SinkMap
Mpre,Mpost:Block→MutableState
Rpre,Rpost:Block→References83Lprecontains the local information on entry to a particular block,
whereasLpost contains the corresponding information at exit of
the block, and similarly for PCpreandPCpost. The sink maps
SpreandSpost contain the classiﬁcation of the predeﬁned sinks
on entry and exit of blocks. MpreandMpost contain the mutable
state classiﬁcation and RpreandRpostcontain the reference links
between mutable states.
4.3.1 Block Summary
We initialize Lprefor entry blocks of actions to map each pa-
rameter local ito the singleton{Parameter (i)}and to the empty
set for all other locals. Similarly, we initialize PCprefor entry
blocks to the singleton {PCin}which allows computing symbolic
summaries of actions that can be applied in contexts where the PC
is classiﬁed differently. The sink map Sprefor the entry block is
empty. These maps will not change during the global ﬁx point of
the analysis.
The information for RpreandMprefor the entry block keep
track under which assumptions the action has been analyzed. It is
initially empty, but may grow as the action is invoked in a con-
text with larger MorR, causing the blocks of the action to be
re-analyzed.
For non-entry blocks, the starting state is deﬁned as follows:
Lpre(b) =/unionsqdisplay
b/primeinpred (b)Lpost(b/prime)
Spre(b) =/unionsqdisplay
b/primeinpred (b)Spost(b/prime)
Mpre(b) =/unionsqdisplay
b/primeinpred (b)Mpost(b/prime)
Rpre(b) =/uniondisplay
b/primeinpred (b)Rpost(b/prime)
PCpre(b) =PCpost(dom(b))
The locals on entry to a block are simply the union of the post local
state of all predecessor blocks, where union is deﬁned point-wise
on the map (similarly for the sinks, mutable state, and reference
links). For the PC classiﬁcation is obtained by the post PC classiﬁ-
cation of the immediate dominator of block b.
4.3.2 Action Summary
We assume each action has a single exit block. The summary of
an action is simply the post state of the exit block of the action. For
each action, we keep track of the initial MandRunder which it
was analyzed in the information for its entry block. If we see a call
to the action with a larger MorR, we update that information for
the entry block and propagate the changes through the blocks of the
action. For example, the summary of action fooin Figure 4 is:
State ={
L={s→{Location},pic→{Camera},
y→{Location},msg→{Location},
msg2→{Location}},
S={Sharing→{Camera}},
PC={},
M={Picture→{Camera},
Message→{Location}}
R={<MessageCollection ,Message>}}
Here the state of locals Lshows that the local scontains the
geolocation data, piccontains the camera data, ycontains geoloca-tion data due to the implicit ﬂow from stoy, and the local msg
gets geolocation data from sat line 5. The state of mutable loca-
tionsMshows that the mutable state of Picture contains the cam-
era data and the mutable state of Message contains the geoloca-
tion data. The state of references Rcontains a pair showing that
MessageCollection is linked to Message . Due to this link, msg2
reads the mutable data of msgs and is considered to contain the
geolocation data. The state of sinks Sshows that the sharing sink
contains camera data. The set PC is empty, since the pc does not
carry the camera data after the if−then−else block.
4.4 Classiﬁed Information Propagation
In this section, we describe how APIs are annotated and how
information ﬂow is tracked at the instruction level.
4.4.1 Property Annotations
We assume that every primitive property pis annotated with a
setReadsMutable pconsisting of the parameter indices of param-
eters whose mutable state is read by p. Similarly, the set Writes-
Mutable pconsists of the indices of parameters whose mutable state
is written by p. Additionally, we use index 0 in WritesMutable pto
indicate whether the mutable state of the result depends on the clas-
siﬁcation of the inputs to property p. By default, we assume that all
immutable parts of all parameters are read by a property and that all
read parts ﬂow into the result’s immutable part. Additionally, the
setEmbedsLinks pcontains the set of edges between kinds repre-
senting possible references established by invoking property p.
A set Sources pindicates which predeﬁned sources ﬂow into the
result value when invoking property p. Finally, Sinks pcontains the
set of sinks to which information ﬂows on invoking p.
4.4.2 Statement-Based Propagation
The following rules show the propagation of the state for each
kind of instruction. We assume L,PC,MandRare the initial
states, andL/prime,PC/prime,M/primeandR/primeare the post states.
Casex:=y.
L/prime=L[x/mapsto→L(y)∪PC]
PC/prime=PC
M/prime=M
R/prime=R
S/prime=S
Note how the PC classiﬁcation ﬂows into the new classiﬁcation of
x. This is needed to keep track of implicit ﬂow.
Caser:=p(x1..xn).First we compute the input classiﬁcation,
which consists of the classiﬁcation of all input parameters, the clas-
siﬁcation of all kinds for which there is a parameter annotated with
ReadsMutable .
Common =PC∪Sources p∪/uniondisplay
iL(xi)
∪/uniondisplay
j∈ReadsMutable pCl(M,R,kind (xj))
The helper function Cl(M,R,i )computes the union of the classi-
ﬁcation of all kinds jreachable from ivia edges in R. Note that
Reach (R,i,i )is true for all R.
Cl(M,R,i ) ={M(j)|Reach (R,i,j )}84With this information, we update the result and the mutable state.
L/prime=L[r/mapsto→Common ]
PC/prime=PC
M/prime(i) =

M(i)∪Common if∃j∈WritesMutable p
andReach (R,kind (xj),i)
M(i) otherwise
R/prime=R∪EmbedsLinks p
S/prime(i) =/braceleftbigg
S(i)∪Common ifi∈Sinks p
S(i) otherwise
Case assume (x)orassume (notx ).
L/prime=L
PC/prime=PC∪L(x)
M/prime=M
R/prime=R
S/prime=S
Assume statements cause the PC classiﬁcation to be augmented
with the classiﬁcation of the condition.
Caser1..rn=a(x1..xm).First, we update Mpre(entry a)to
M/unionsqMpre(entry a)andRpre(entry a)toR/unionsqRpre(entry a). If
necessary, propagate changes through blocks of a. We use the state
at the exit block of aas the summary of ato be applied at the
current invocation. Since the summary contains some symbolic
information for parameter classiﬁcation and pc classiﬁcation, we
ﬁrst instantiate the exit block information with the invocation site
information. Let σbe the substitution
σ= [PCin/mapsto→PC, Parameter (i)/mapsto→L(xi)]
Now we compute instantiated versions of the exit block summaries:
Ls=σ(Lpost(exit a))
Ms=σ(Mpost(exit a))
Rs=σ(Rpost(exit a))
Ss=σ(Spost(exit a))
Note that no PC information ﬂows out of the action. Let r/prime
1..r/prime
nbe
the result locals in action a. The ﬁnal states after the invocation of
actionais then:
L/prime=L[ri/mapsto→Ls(r/prime
i)]
PC/prime=PC
M/prime=M/unionsqMs
R/prime=R∪Rs
S/prime=S/unionsqSs
5. TAMPERED INFORMATION
The source to sink information ﬂow we compute so far may not
be enough to make good policy decisions about which scripts are
good and which scripts are bad. For example, a script taking a
picture with the camera and then posting it to facebook may be a
reasonable script, especially since posting to facebook will prompt
the user and display the text and picture that will be posted. The
user thus has a way to vetthe information being posted.
However, a malicious script could try to encode the user’s phone
number into the color intensity of some pixels in the posted picture.From an information ﬂow perspective, we would simply see that
sources Camera andContacts ﬂow to Sharing . Users looking
at the picture being posted will likely not notice changed pixels
containing the hidden phone number.
Can we distinguish somehow between these two cases? Our at-
tempt to do so is based on the following assumption: for sinks that
prompt the user to review the information (e.g., emails, sms, phone
calls, facebook posts), we want to distinguish if the information
being posted is recognizable by the user as containing sensitive in-
formation or not. In the case where pixels in the picture taken by
the camera are modiﬁed based on classiﬁed contact information,
we want to consider the information in the picture as tampered and
thus apply a harsher policy than if the information is not tampered
with.
In order to track tampering, we introduce an operator Tamper
that can be applied to the existing sources.
Atom ::=Sources (i)|Parameter (i)
|PCin|Tamper (Atom )
Note that the set of atoms is not unbounded, as this is not a free al-
gebra. Indeed, Tamper (Tamper (s)) = Tamper (s)for alls. Ad-
ditionally, we annotate all properties pwith a single bit Tampersp,
indicating whether any input classiﬁcations are transformed into
tampered output classiﬁcations for the result and writes to the mu-
table store.
The rule for handling the ﬂow at property invocations then needs
to be modiﬁed insofar as the classiﬁcation Common now becomes:
InFlow =PC∪/uniondisplay
iL(xi)
∪/uniondisplay
j∈ReadsMutable pCl(M,R,kind (xj))
Common =Sources p∪/braceleftbiggInFlow if¬Tampersp
Tamper (InFlow )ifTampersp
Applying Tamper to an entire classiﬁcation, just means applying
the operator pointwise to the set elements.
6. USER-A WARE PRIV ACY CONTROL
By applying the static analysis, we compute information ﬂows
on a per action and per script basis and show summaries of which
sources ﬂow to which sinks in each action and in the script as a
whole. As an example, Figure 1 shows the summary of the script
named location and maps , which can send a text message contain-
ing the user’s current location or take a picture with the user’s cur-
rent location embedded in it and save the picture into the media
storage library of the mobile device. This ﬂow summary shows the
information ﬂows of the application: by looking at the information
ﬂows at install time, users can understand what private information
the application uses and where this private information may escape
to. To minimize the efforts of experts in validating applications and
users in granting accesses to sources, we further deﬁne a policy that
classiﬁes ﬂows into safe and unsafe ﬂows.
Classiﬁcation of Safe and Unsafe Flows. Our policy is
based on the assumption described in Section 5: we consider a ﬂow
as a safe ﬂow if it is an untampered ﬂow to a vetted sink . Recall
that a vetted sink results in an explicit dialog at runtime, present-
ing the particular information ﬂowing to the sink and requesting
permissions from the user before the information escapes from the
mobile-device. For example, a post to facebook would prompt the85Figure 5: Sizes of 546 published scripts in TouchDevelop
user to review the information before the actual sharing happens.
Our approach considers all other ﬂows as unsafe, including untam-
pered ﬂows to unvetted sinks ( Web ) and all tampered ﬂows. We
may evolve the policy of what constitutes a safe ﬂow based on user
feedback, and update the policy when more sources and sinks are
added into the system.
Granting Accesses. When running the script for the ﬁrst time,
the user is presented with all sources appearing in unsafe ﬂows
along with a radio button group for each source that allows the
user to choose among anonymized orreal information (Figure 2).
Anonymized information means that the runtime provides the script
with anonymized information (a ﬁxed picture or a ﬁxed geolocation
etc.), real information means the script gets access to the real infor-
mation on the users’ device, and abort execution means that the run-
time stops the execution at the access point. By using anonymized
information, a user can safely experiment with an application to
determine if it does something useful prior to even considering
whether to allow access to real information.
Default Settings. To keep users safe and minimize efforts in
granting access, our approach provides default settings. We guar-
antee that running a script with the default settings does not leak
private information, except through vetted sinks where the user is
presented untampered information to review. Sources appearing in
no ﬂows use real information and are not shown. For sources that
appear only in safe ﬂows, the default setting is to use real informa-
tion; for other sources appearing in ﬂows, the default setting is to
use anonymized information.
7. EV ALUATION
This section presents experiments we conducted to evaluate the
effectiveness of our extended static information ﬂow analysis. We
chose TouchDevelop as a platform for our evaluations due to two
major reasons: (1) source code availability : the source code of a
script is made available as part of the publishing process; (2) sim-
plicity : the expressiveness of the TouchDevelop languages enables
applications to be created in much fewer lines, reducing the com-
plexity of static analysis; the TouchDevelop language does not al-
low reﬂection or native calls to platform APIs, enabling complete
annotation of the APIs with source, sink, and ﬂow information;
TouchDevelop only allows importing of external scripts through
the script bazaar and does not allow generating code at runtime.
7.1 Subjects and Evaluation Setup
We integrated our static information ﬂow analysis into the server
part of the TouchDevelop environment. Every submitted script is
analyzed automatically and the resulting ﬂow information informs
the privacy settings when users install scripts. To conduct the ex-
periments, we collected 546 scripts (all publications prior to OctTable 2: Information ﬂow summary of 546 published scripts
#Total#Cap (242)#Flow/wSource /wSink /wBoth
546 172 159 89 78
6th, 2011) published by 194 TouchDevelop users, excluding scripts
published by ourselves. Figure 5 shows the number of scripts in
different ranges of lines of code (LOC)2and the average LOCs
in these ranges. Among these scripts, 395 (72.34%) scripts have
LOCs ranging from 0-80, and the scripts Termini 3 Final3andTer-
mini 3 Beta 1.44) have the maximum LOCs of 738. The major
reason why these scripts are of relatively small size is that the ex-
pressiveness of the TouchDevelop language enables users to create
applications using fewer lines of code than using traditional pro-
gramming languages for mobile devices. For example, the script
Termini Include Edition 1.0.25published by the user Pouya Ani-
mation6creates a UNIX emulator (Terminal) for TouchDevelop in
just 407 LOC.
7.2 Information Flow Evaluations
To show the effectiveness of our information ﬂow analysis, we
posed the following three research questions about the 546 subject
scripts:
RQ1 : What is the advantage of using information ﬂow from sources
to sinks to classify scripts, as opposed to the mere presence
of both sources and sink (capability usage)?
RQ2 : How many more scripts can we classify as safe using our
tamper analysis, thus eliminating the need to ask users to
grant access?
RQ3 : How many more sources can we classify as safe using our
tamper analysis, further reducing the number of sources that
require users’ decisions?
7.2.1 RQ1: Information Flow Summary
To address RQ1, we compare the number of scripts that are clas-
siﬁed as information-leaking using information ﬂows with the num-
ber of scripts that are classiﬁed as information-leaking using ca-
pabilities. Table 2 shows the information ﬂow summary of the
published scripts. Column “# Total” shows the total number of
scripts. Column “# Cap” shows the number of scripts that either
have at least one source or one sink. Column “/w Source” shows
the number of scripts that have at least one source. Column “/w
Sink” shows the number of scripts that have at least one sink. Col-
umn “/w Both” shows the number of scripts that have both sources
and sinks. Column “# Flow” shows the number of scripts that have
computed information ﬂows.
The results show that in 546 published scripts, 242 (44.32%) ei-
ther have sources (access private information) or have sinks (can
leak information from the script). To form an information ﬂow, a
script must have at least one source and one sink. As shown in Ta-
ble 2, 457 (83.70%, #Total - #Both) scripts have either no sources or
no sinks, which can be classiﬁed as non-information-leaking by ei-
ther using information ﬂow or capabilities usage. For the remaining
89 scripts that have both sources and sinks, our information ﬂow
2Meta data and comment statements are excluded for LOC compu-
tation.
3http://touchdevelop.com/pycw
4http://touchdevelop.com/xwgl
5http://touchdevelop.com/hllw
6https://www.touchdevelop.com/ntqe86Table 3: Information ﬂow vs. source-sink pairs
Contacts Media Sharing Web Any
Camera 0 / 0 22 / 22 11 / 21 0 / 30 33 / 36
Contacts 1 / 3 0 / 11 30 / 39 0 / 19 30 / 41
Location 0 / 0 6 / 10 12 / 12 27 / 29 30 / 34
Microph. 0 / 0 0 / 2 1 / 1 0 / 3 1 / 6
Music 0 / 0 0 / 1 1 / 1 0 / 1 1 / 3
Picture 0 / 0 18 / 29 2 / 15 14 / 21 24 / 32
Any 1 / 3 29 / 39 44 / 48 40 / 51 78 / 89
Table 4: Safe/Unsafe ﬂow summary of 78 ﬂow scripts
#Safe#Unsafe (54)#Both #Mix# Unvetted #Tampered
45 40 47 21 0
analysis detects that 11 scripts have no information ﬂows. Thus,
using potential ﬂow (presence of both source and sink), reduces
prompting by 48.26% (from 172 to 89) over the traditional capa-
bility approach (presence of sources). Using actual information
ﬂows, as computed by our analysis, further reduces prompting by
12.36% (from 89 to 78).
Table 3 shows the information ﬂow summary of the published
scripts based on source-sink pairs. Each column represents a kind
of sink and each row represents a kind of source. The ﬁrst number
in each table cell is the number of scripts for which our analysis de-
termines information ﬂow from the given source to the given sink,
whereas the second number in each cell is simply the number of
scripts that use the corresponding source and sink. The two num-
bers presented in each table cell compare our approach of comput-
ing actual information ﬂow, to a naïve capability analysis that sim-
ply presumes an information ﬂow for each used source-sink pair.
For example, the cell for Camera andWeb shows that a naïve
capability approach would classify 30 scripts as having informa-
tion ﬂow from the camera to the web, whereas our information ﬂow
analysis proves that none of these scripts actually leak camera in-
formation to the web, completely removing the concerns of leaking
pictures taken from the camera through the web.
Similarly, the naïve capability approach would consider 19 scripts
to leak contact information through the web, while our analysis
shows that none of these scripts would do that.
These results show that information ﬂow analysis effectively com-
putes a much ﬁner granularity of the potential ﬂows between sources
and sinks used in a script.
7.2.2 RQ2: Safe Scripts
To address RQ2, we apply our static analysis on the 78 subject
scripts that have information ﬂows, referred to as ﬂow scripts , and
measure the number of ﬂow scripts that have safe ﬂows. We as-
sume only sink Web is an unvetted sink, while all others are vetted
sinks. Table 4 shows the safe/unsafe ﬂow summary of the 78 scripts
that have information ﬂows. Column “# Safe” shows the number
of scripts that have safe ﬂows. Column “# Unvetted” shows the
number of scripts that have information ﬂows from sources into
unvetted sinks. Column “# Tampered” shows the number of scripts
that have tampered information ﬂows. Column “# Both” shows the
number of scripts that have both safe and unsafe ﬂows. Column “#
Mix” shows the number of scripts that have both safe and unsafe
ﬂows from a common source ( mix scripts ).
The results show that 45 (57.69%) ﬂow scripts have safe ﬂows
and 54 (69.23%) ﬂow scripts have unsafe ﬂows. Among these 54
unsafe ﬂow scripts, 40 ﬂow scripts have ﬂows from sources into
unvetted sinks and 47 have tampered information ﬂows. Based on
this safe/unsafe ﬂow summary, we know that 24 (#Safe −#Both), or
30.77% of ﬂow scripts have only safe ﬂows. For these 24 scripts,Table 5: Categorization of sources
Naïve Flow SafeUnsafe due to
Unvet. Tamp. Both
Camera 36 33 24 0 9 0
Contacts 41 30 25 0 5 0
Location 34 30 0 27 26 23
Microph. 6 1 1 0 0 0
Music 3 1 0 0 1 0
Picture 32 24 6 14 15 11
Total 152 119 56 41 56 34
users are perfectly safe to use the scripts granting full access to
private information without prompting or reduced functionality.
Among the 21 ﬂow scripts that have both safe and unsafe ﬂows,
none are mix scripts. In all the TouchDevelop scripts, only 2 ﬂow
scripts published by ourselves have both safe and unsafe ﬂows from
a common source to sinks. Our current access granting allows users
to grant access based on sources only, instead of ﬂows. Users can-
not choose real information for one ﬂow and anonymized informa-
tion for another ﬂow from the same source. As we only found 2
scripts where this limitation matters, it seems to be a good trade-off
that avoids giving users too much choice.
7.2.3 RQ3: Safe Sources
To address RQ3, we look at how many times a user would have
to change the default setting for a source if she were to give full
access to all scripts. Table 5 shows the total number of times a
source appears in a given context. Column “Naïve” shows the num-
ber of scripts that use this source and any sink. Column “Flow”
shows the number of scripts that have information ﬂows from this
source to any sinks. Column “Safe” shows the number of scripts
for which this source is safe. The last three columns explain why
some ﬂows are unsafe. Column “Unvetted” shows the number of
scripts where information ﬂows from this source to unvetted sinks.
Column “Tamper” shows the number of scripts where information
from this source is tampered before it reaches a sink. Column
“Both” shows the number of scripts that have common sources in
Columns “Unvetted” and “Tamper”.
Among 33 scripts that have source Camera appearing in ﬂows,
24 scripts (72.73%) have source Camera as a safe source and 9
scripts (27.27%) have source Camera in tampered ﬂows. Sim-
ilarly, 25 scripts (83.33%) have safe sources of Contacts , leav-
ing only 5 scripts having source Contacts appearing in tampered
ﬂows.
In summary, our analysis detects that 47.06% (56) of 119 sources
are safe sources. These safe sources are allowed to use real infor-
mation directly based on our default settings, eliminating the need
for access granting. Among the remaining 63 unsafe sources (#
Unvetted + # Tamper - # Both), 7 (#Unvetted - #Both) are solely
due to ﬂow to unvetted sinks, and the remaining 56 sources appear
in tampered information ﬂows. These results show that using the
naïve classiﬁcation, a user would have to make 152 changes to set-
tings to use real data in all scripts. Using information ﬂow alone,
this number is reduced to 119 changes. Using tamper analysis and
vetted sinks in addition to information ﬂow, our approach reduces
the burden to 63 changes to settings, an overall reduction of 58.6%.
8. DISCUSSION AND FUTURE WORK
In this section, we discuss generalizations and limitations of our
approach.
Generalization to Other Mobile-Device Platforms. To
generalize our approach to other mobile-device platforms, such as87Windows Phone, Android, and iOS, several points need to be ad-
dressed: 1) these platforms provide a much larger API surface than
TouchDevelop and annotating these APIs with source, sink, and
ﬂow information is a major effort, 2) the languages used (Java, C#,
or assembly code) provide more ways to obscure ﬂow than in our
scripting language, in particular through indirect calls, or via reﬂec-
tion. The static analysis would have to be extended to account for
these [13,14]. 3) Indirect ﬂow through mutable storage will require
a ﬁner grained heap model than we currently employ (one abstract
location per data kind). The static analysis might need to be com-
plemented with dynamic analysis [1, 15] to address this issue.
Limitations of Static Information Flow Analysis. Due
to the way our approach handles implicit ﬂows, our approach may
produce false positives as described by Kang et al.’s work [16].
However, our evaluation results show that even with these potential
false positives, our approach still achieves a signiﬁcant reduction in
access granting for users. To improve our approach when migrating
to other mobile-device platforms, our approach can be combined
with DTA++ techniques [16].
Another type of implicit ﬂow, covert channels [17], may cause
false negatives of our approach. For example, a script can store
a classiﬁed picture into the media library, and then later share it
through facebook via a different application. Our ﬂow analysis
would indicate that a picture is stored into the media library (and
the user has to agree with that ﬂow), but our approach does not con-
template what could happen to the picture in the library after that.
To address such issues, the operating system would have to provide
dynamic taint tracking [1], since such ﬂows involve more than one
application or even OS built-in functionality.
9. RELATED WORK
In this section, we compare our work with other related approaches.
User-Aware Application Capabilities. Mobile-device plat-
forms like Android and social-network platforms like Facebook use
manifests to show application capabilities and request permissions
at install time. Other mobile-device platforms like iOS and research
approaches like TaintDroid [1] report application capabilities the
ﬁrst time applications try to access a resource. The capabilities
shown in the manifests are either claimed by developers [18] or
only present part of the requested application capabilities. Felt
et al. [14] proposes an approach that uses static analysis to map
API calls used by applications to permissions, which is similar to
our approach. However, they adapt automated testing methodology
to test the applications and identify APIs that require permissions,
while our approach annotates the APIs with permissions and uses
static checking.
Information Flow Analysis. Xie and Aiken [19] present an
approach that statically computes summaries of blocks and pro-
cedures of PHP and detects security vulnerabilities at the block
level, intraprocedural level, and interprocedural level. Their ap-
proach does not handle reference-type ﬂows shown in Figure 4,
and would lose track of ﬂows after built-in procedure calls (e.g.,
senses→take camera picture ) that cannot be analyzed by their ap-
proach. To address these problems, our approach uses mutable
locations to simplify analysis of reference-type ﬂows and tracks
untampered- and tampered-classiﬁed information for classifying
safe and unsafe ﬂows.
The closest work related to ours is PiOS [20], which studies
private information leakage in actual iOS binaries. The PiOS ap-proach statically computes data ﬂow along control ﬂow paths from
sources to sinks to determine if there exists a user prompt along that
path. PiOS emits warnings if such a ﬂow is found without a user
prompt. For the purposes of safe-guarding users of the TouchDe-
velop bazaar, the PiOS approach is insufﬁcient because: 1) the
PiOS analysis is not conservative, it misses ﬂows that are too long
or use indirect ﬂow, 2) the prompts PiOS identiﬁes may be unre-
lated, show nothing of the leaked information, or show tampered
information. PiOS also does not use the static information to con-
trol user prompting and privacy settings as our approach does.
Language-based information ﬂow [21] allows developers to an-
notate variables with security attributes. These attributes can be
used by compilers to enforce information ﬂow controls. For ex-
ample, Slam [22] shows that information ﬂow labels can be ap-
plied to a simple language with reference types and Jif [23, 24]
extends Java language with statically-checked information ﬂow an-
notation. Laminar [25] allows developers to specify security re-
gions and provide information ﬂow controls on both language and
JVM/OS levels. Although these language-extending approaches
are effectively in guaranteeing information ﬂow controls, they im-
pose additional burdens on developers when writing applications,
which is undesirable for writing scripts on mobile devices in the
context of TouchDevelop, especially for beginners.
Dynamic taint analysis [1, 15] has been applied to track infor-
mation ﬂows on both mobile platforms like Android and desktop
platform like Windows. These approaches track tainted data during
runtime, providing accurate runtime information about leaks. How-
ever, to reduce runtime overhead, these approaches usually ignore
implicit ﬂows raised by control structures. Moreover, dynamically
executing all execution paths of these applications to detect poten-
tial information leaks is impractical. These limitations make these
approaches inappropriate for computing information ﬂows for all
submitted applications.
Access Granting. Mobile-device platforms like Android and
social-network platforms like Facebook use manifests to request
permissions at install time. Once permissions are given by users,
the permissions cannot be changed. iOS and Windows User Ac-
count Control [26] prompts a dialog to request permissions from
users when applications try to access a resource or make security
or privacy-related system-level changes. Instead of only showing
information about the access to resources, our approach presents
information ﬂows to describe what applications may do with pri-
vate user information. Our access granting also provides a way for
users to try out applications before using private information, and
these settings can be changed at will.
Zhu et al. propose an approach that uses dynamic taint analysis
to track user data as it ﬂows through applications [15]. Their ap-
proach allows users to choose among logging the action, blocking
the system call, or randomize the tainted data. Chen ea al. also
propose an approach that shadows data that the user wants to keep
private and blocks network transmissions that contain data the user
made available to the application for on-device use only [27]. Our
anonymized/real/abort setting is inspired by their approach, but we
use static information ﬂow analysis extended with tampered infor-
mation to classify ﬂows as safe/unsafe ﬂows and provide default
access settings, rather than runtime information.
Automated Security Validation of Mobile Apps. Gilbert
et al. present a vision of making mobile apps more secure via au-
tomated validation [2]. They propose using commodity cloud in-
frastructure to emulate smartphones and run the submitted apps to
dynamically track information ﬂows and actions. Based on the in-88formation ﬂow and action tracking, they propose to automatically
detect malicious behavior and misuse of sensitive data via further
analysis of dependency graphs [28] or natural language processing.
Such an approach is akin to automated testing and suffers from the
same problems, namely coverage. It is difﬁcult to drive applica-
tions automatically into exercising all data and control paths. Thus,
in the end, such an approach only gives a partial view of the behav-
ior and does not safe-guard users.
10. CONCLUSION
We presented a user-aware privacy control approach based on
static information ﬂow analysis extended with tamper analysis. We
compute information ﬂows from private sources to sinks and clas-
sify them as safe/unsafe ﬂows. We conducted evaluations on 546
scripts published in TouchDevelop to study the effectiveness of our
static information ﬂow analysis. The results show that our approach
computes useful information ﬂows and can be used to automat-
ically provide default privacy settings for each script that keeps
users safe without any user intervention, thereby obviating the need
for manual script validation.
Our approach is the ﬁrst step towards employing a better privacy
control mechanism in mobile-device platforms based on automatic
validation of applications in the marketplace and user-driven access
control.
11. REFERENCES
[1] William Enck, Peter Gilbert, Byung-Gon Chun, Landon P.
Cox, Jaeyeon Jung, Patrick McDaniel, and Anmol N. Sheth.
TaintDroid: An Information-Flow Tracking System for
Realtime Privacy Monitoring on Smartphones. In Proc.
OSDI , pages 1–6, 2010.
[2] Peter Gilbert, Byung-Gon Chun, Landon P. Cox, and Jaeyeon
Jung. Vision: Automated Security Validation of Mobile Apps
At App Markets. In Proc. MCS , pages 21–26, 2011.
[3] Adrienne Porter Felt, Kate Greenwood, and David Wagner.
The Effectiveness of Application Permissions. In USENIX
Conference on Web Application Development (WebApps) ,
2011.
[4] T. Vidas, N. Christin, and L. Cranor. Curbing Android
Permission Creep. In Proc. W2SP , Oakland, CA, May 2011.
[5] Franziska Roesner. User-Driven Access Control: A New
Model for Granting Permissions in Modern Operating
Systems. Qualifying Examination Project, University of
Washington , June 2011.
[6] Aslan Askarov and Andrew Myers. A semantic framework
for declassiﬁcation and endorsement. In Programming
Languages and Systems , volume 6012 of LNCS , pages
64–84. Springer, 2010.
[7] TouchDevelop. http://research.microsoft.com/TouchDevelop.
[8] Nikolai Tillmann, Michal Moskal, and Jonathan de Halleux.
TouchDevelop - Programming Cloud-Connected Mobile
Devices via Touchscreen. Microsoft Technical Report
MSR-TR-2011-49 , 2011.
[9] Fraser Howard. Malware with your mocha: Obfuscation and
anti-emulation tricks inmalicious JavaScript, September
2011. http://www.sophos.com/security/technical-
papers/malware_with_your_mocha.pdf.
[10] Dorothy E. Denning. A Lattice Model of Secure Information
Flow. Commun. ACM , pages 236–243, 1976.[11] Dorothy E. Denning and Peter J. Denning. Certiﬁcation of
Programs for Secure Information Flow. Communications of
The ACM , pages 504–513, 1977.
[12] P. Cousot and R. Cousot. Abstract interpretation: a uniﬁed
lattice model for static analysis of programs by construction
or approximation of ﬁxpoints. In POPL , pages 238–252,
1977.
[13] William Enck, Damien Octeau, Patrick McDaniel, and
Swarat Chaudhuri. A study of android application security.
InProc. of USENIX Security Symposium , 2011.
[14] Adrienne Porter Felt, Erika Chin, Steve Hanna, Dawn Song,
and David Wagner. Android Permissions Demystiﬁed. In
Proc. CCS , 2011.
[15] David (Yu) Zhu, Jaeyeon Jung, Dawn Song, Tadayoshi
Kohno, and David Wetherall. TaintEraser: Protecting
Sensitive Data Leaks Using Application-Level Taint
Tracking. SIGOPS Oper. Syst. Rev. , pages 142–154, 2011.
[16] Min Gyung Kang, Stephen McCamant, Pongsin Poosankam,
and Dawn Song. DTA++: Dynamic taint analysis with
targeted control-ﬂow propagation. In Proc. of NDSS , San
Diego, CA, February 2011.
[17] Shiuh-Pyng Shieh and Virgil D. Gligor. Auditing the use of
covert storage channels in secure systems. In IEEE
Symposium on Security and Privacy , pages 285–295, 1990.
[18] J H Saltzer and M D Schroeder. The Protection of
Information in Computer Systems. Proceedings of the IEEE ,
pages 1278–1308, 1975.
[19] Yichen Xie and Alex Aiken. Static Detection of Security
Vulnerabilities in Scripting Languages. In Proceedings of the
15th conference on USENIX Security Symposium , 2006.
[20] Manuel Egele, Christopher Kruegel, Engin Kirda, and
Giovanni Vigna. PiOS : Detecting privacy leaks in iOS
applications. In Proc. NDSS’11 , 2011.
[21] Andrei Sabelfeld and Andrew C. Myers. Language-Based
Information-Flow Security. IEEE Journal on Selected Areas
in Communications , 2002.
[22] Nevin Heintze and Jon G. Riecke. The SLam Calculus:
Programming with Secrecy And Integrity. In Proc. POPL ,
pages 365–377, 1998.
[23] Andrew C. Myers and Barbara Liskov. Protecting Privacy
using The Decentralized Label Model. ACM Transactions on
Software Engineering and Methodology , 2000.
[24] Andrew C. Myers. JFlow: Practical Mostly-Static
Information Flow Control. In Proc. POPL , pages 228–241,
1999.
[25] Indrajit Roy, Donald E. Porter, Michael D. Bond, Kathryn S.
Mckinley, and Emmett Witchel. Laminar: Practical
Fine-grained Decentralized Information Flow Control. In
Proc. PLDI , pages 63–74, 2009.
[26] MICROSOFT. What is User Account Control?, 2011.
http://windows.microsoft.com/en-US/windows-vista/What-
is-User-Account-Control.
[27] Yan Chen, George Danezis, and Vitaly Shmatikov, editors.
Proc. CCS . ACM, 2011.
[28] Jeanne Ferrante and Karl J. Ottenstein. The Program
Dependence Graph And Its Use in Optimization. ACM
Transactions on Programming Languages and Systems ,
9:319–349, 1987.89