Combining Functional and Imperative Programming for Multicore Software:
An Empirical Study Evaluating Scala and Java
Victor Pankratius
Karlsruhe Institute of Technology
76131 Karlsruhe, Germany
www.victorpankratius.com
pankratius@acm.orgFelix Schmidt, Gilda Garret ¬¥on
Oracle Labs
Oracle Corporation
Redwood Shores, CA, USA
ffelix.schmidt,gilda.garreton g@oracle.com
Abstract ‚ÄîRecent multi-paradigm programming languages
combine functional and imperative programming styles to
make software development easier. Given today‚Äôs proliferation
of multicore processors, parallel programmers are supposed
to beneÔ¨Åt from this combination, as many difÔ¨Åcult problems
can be expressed more easily in a functional style while
others match an imperative style. Due to a lack of empirical
evidence from controlled studies, however, important software
engineering questions are largely unanswered. Our paper is the
Ô¨Årst to provide thorough empirical results by using Scala and
Java as a vehicle in a controlled comparative study on multicore
software development. Scala combines functional and imper-
ative programming while Java focuses on imperative shared-
memory programming. We study thirteen programmers who
worked on three projects, including an industrial application,
in both Scala and Java. In addition to the resulting 39 Scala
programs and 39 Java programs, we obtain data from an
industry software engineer who worked on the same project
in Scala. We analyze key issues such as effort, code, language
usage, performance, and programmer satisfaction. Contrary
to popular belief, the functional style does not lead to bad
performance. Average Scala run-times are comparable to Java,
lowest run-times are sometimes better, but Java scales better
on parallel hardware. We conÔ¨Årm with statistical signiÔ¨Åcance
Scala‚Äôs claim that Scala code is more compact than Java code,
but clearly refute other claims of Scala on lower programming
effort and lower debugging effort. Our study also provides
explanations for these observations and shows directions on
how to improve multi-paradigm languages in the future.
I. I NTRODUCTION
Multi-paradigm programming languages conjecture that
no single paradigm is suited to solve all possible problems
in practice. In particular, recent proposals [1], [2], [3]
fueled the development of languages that unify the best of
functional programming and imperative programming. This
direction is motivated by the need to produce more reliable
software despite the growing complexity that programmers
face in today‚Äôs environments. Programming languages thus
aim to offer a better cognitive match between their con-
structs and the problems that developers need to solve,
while mapping constructs more effectively to computational
resources. Their major goals are to increase productivity,ensure quality, and take advantage of more sophisticated
performance optimizations available in modern hardware.
The proliferation of multicore processors has created
additional pressure to improve parallel programming. Mul-
ticore is here to stay because of stagnating clock rates and
saturated power budgets [4]. Standard desktop PCs are truly
parallel machines with 4-core or 8-core processors, while
servers have processors with 12, 32, or more general-purpose
cores. Embedded devices and mobile phones are becoming
parallel machines, too. Programmers now need to deal with
the additional complexity of parallel programming or miss
opportunities for performance on modern hardware.
Advocates of the functional style [5] argue that it is less
error-prone and more productive, compared to an imperative
style, so it should be used to make parallel programming
easier. Advocates of imperative style, by contrast, favor more
control to achieve better performance [5]. Earlier empirical
studies set up to assess these tradeoffs typically assumed a
context that differs from the one today; for example, some
assume that programmers have to use one style exclusively,
others focus on sequential programs, and still others look at
highly speciÔ¨Åc parallel constructs in imperative languages
[6], [7], [8], [10], [11], [12], [13], [14].
Today, languages such as Scala [1] and C# [2] allow
the combination of functional and imperative programming
in the same language, so developers don‚Äôt need to make
an exclusive choice. However, new problems arise as it is
largely unclear how programmers apply mixed program-
ming styles in larger projects. We lack empirical evidence
from controlled studies to quantify the software engineering
beneÔ¨Åts, to identify potential problems, to evaluate which
language features are most promising to extend, and how to
build tools. As Scala compiles to Java bytecode, program
performance can now easily be compared on the same pro-
gramming task and multicore environment while measuring
relevant software engineering metrics in both languages;
such comparisons were difÔ¨Åcult to set up in the past.
To our knowledge, this is the Ô¨Årst paper to answer key
questions in a multicore context with Scala and Java, such
as: Who needs more effort? Who has the Ô¨Årst parallelprogram? Whose code is more compact? How are functional
and imperative styles used? Who has the best performance?
How satisÔ¨Åed are programmers? We analyze the status quo
by studying 13 subjects, each of whom wrote 3 programs
in each of Scala and Java, resulting in 39 Scala programs
and 39 Java programs. The main object of study is the
parallelization of real-world VLSI CAD tool used in chip
design. Our study is based on a counterbalanced within-
subjects design [15], but also applies case study and inter-
view techniques [16], [17] to generate insights that explain
phenomena observed in the aggregated statistics. In addition,
an Oracle software engineer worked on the same project in
Scala and provided reference data. The measured effects are
strong and conÔ¨Årm with statistical signiÔ¨Åcance that Scala
code is more compact than Java code. Our data, however,
clearly refutes other claims of Scala on lower project effort
and testing and debugging effort. The lessons learned for the
improvement of Scala and Java are nevertheless invaluable
and show that multi-paradigm languages are worth pursuing.
The paper is organized as follows. Section II outlines mul-
ticore programming in Scala versus Java. Section III presents
claims from the literature that form the hypotheses on how
Scala‚Äôs approach aims to improve Java imperative parallel
programming. Section IV details our study design. Sections
V‚ÄìXI elaborate critical questions addressed in this study,
such as effort, parallelization progress, code compactness,
programming style, performance, and programmer feedback.
Section XII discusses threats to validity. Section XIII con-
trasts related work. Section XIV provides a conclusion.
II. M ULTICORE PROGRAMMING IN SCALA VS . JAVA
Scala [1] (scalable language) is a statically typed, multi-
paradigm language that compiles to bytecode on the regular
Java virtual machine. A complete overview of Scala is
beyond the scope of this paper. We therefore outline in
this section some key principles to set the discussion in this
paper. To facilitate reading, key principles are described by
example. For further details we refer to [1], [18], [19].
A. Parallel Programming Example
Consider the well-known producer-consumer pattern [20]
that is frequently used in pipelined computations [21]. List-
ing 1 shows what programmers would typically have to do
in Java: create a shared queue, create threads that access the
queue, synchronize accesses to the queue, and use wait and
notify signals to let waiting producers or consumers know
about an empty or full queue. Advanced programmers who
aim to achieve better performance would also explicitly use
locks instead of synchronized blocks.
Queue<Item>sharedQueue = . . . ;
/ / Thread 1: consumer t h r e a d
synchronized ( sharedQueue ) f
while ( sharedQueue . s i z e ( ) == 0) fsharedQueue . w a i t ( ) ; g
Item it em = sharedQueue . g e t ( ) ;
/ / h a n d l e i t e m
g/ / Thread 2: p r o d u c e r t h r e a d
f o r ( . . . ) fItem it em = c r e a t e I t e m ( ) ; / / c o n t i n u o u s l y c r e a t e i t e m s
synchronized ( sharedQueue ) f
sharedQueue . p u t ( ite m ) ; sharedQueue . n o t i f y A l l ( ) ;
gg
Listing 1. Producer-Consumer Pattern in Java
c as e c l a s s Item ( . . . )
/ / A c t o r 1: consumer a c t o r
v a l consumer = a c t o r fr e a c t f
c as e Item ( . . . ) = >/ / h a n d l e i t e m
gg
/ / A c t o r 2: p r o d u c e r a c t o r
v a l p r o d u c e r = a c t o r ff o r ( . . . ) f
v a l it em = c r e a t e I t e m ( ) / / c o n t i n u o u s l y produce i t e m s
consumer ! i tem / / send i t e m t o consumer
gg
Listing 2. Producer-Consumer Pattern in Scala
In Scala, there are concurrent actors whose communica-
tion is based on message passing. Each actor implements
send and receive operations. In Listing 2, the case class
construct allows automatic matches of received items
based on their type and values. Scala‚Äôs actor model is
implemented on top of Java‚Äôs shared memory model. Scala
therefore exposes programmers to different concurrent ab-
stractions, but eventually the compiler translates them into
Java bytecode.
B. Functional and Imperative Programming Example
Scala integrates functional programming with object-
oriented imperative programming. It supports higher-order
functions, currying, algebraic data types, and native support
of sequences, such as lists or sets. For example, everything
is an object, and even ‚Äú 1+2‚Äù would be treated as two Int
objects 1and2, where the addition is a call to a method of
object 1named ‚Äú +‚Äù. As another example, consider the ex-
pression [1]: numbersList.filter((x:Int) => x>0)
The expression uses the function (x:Int) with the body
x>0 to obtain all number objects of numbersList that are
greater than zero, taking advantage of the filter method
that is provided for all collection object types. Note that
it is not necessary to write a for loop that iterates over
all objects to check each one for the desired property.
Native frameworks provide frequently used data structures
as mutable or immutable types. In addition, Scala offers
automatic type inference, which aims to make coding faster.
Programmers can choose to program in Scala in an
imperative style, e.g., by using explicit object deÔ¨Ånitions,
while loops, shared state, and reusing Java code from ex-
isting packages, such as the java.util.concurrent package. In
addition to Java, Scala provides traits to enhance inheritance
expressiveness [1].
Today, companies such as Twitter [22] employ Scala.
Scala‚Äôs unique features promise to make parallel software
development easier. As Scala‚Äôs usage continues to increase,
programming effort and other aspects deserve a thorough
empirical analysis such as the one in this paper.III. H YPOTHESES ON SCALA IN THE LITERATURE
Scala‚Äôs combination of functional and imperative pro-
gramming is claimed to have advantages in comparison
to Java [1], [18], [19], but there is little evidence from
controlled studies. We summarize important propositions as
a motivation for a more thorough empirical examination.
Effort. ‚ÄúScala‚Äôs functional programming constructs make
it easy to build interesting things quickly from simple parts‚Äù
[1, p. 3]. ‚ÄúScala is easy to get into‚Äù [1, p. 3]. The language
constructs help programmers get started quickly [1, p. 5].
The combination of functional and object-oriented constructs
have ‚Äúcomplementary strengths‚Äù which lead to ‚Äúa legible and
concise programming style‚Äù [1, p. 3]. Programmers require
less effort for reading and understanding Scala programs
[1, p. 13]. For parallel programs, programmers tend to Ô¨Ånd
Scala‚Äôs shared-nothing message passing model ‚Äúmuch easier
to reason about‚Äù than Java‚Äôs shared-memory model with
locks [1, p. 584].
Code Compactness. ‚ÄúScala programs tend to be short‚Äù;
in conservative cases ‚Äúa typical Scala program should have
about half the number of lines of the same program written
in Java‚Äù [1, p. 13]. In extreme cases Scala programs may
have one tenth of the lines of code (LOC) of corresponding
Java program [1, p. 13]. Scala programs are more concise
due to type inference [1, p. 17], optional semicolons. [1,
p. 14], control abstractions that avoid duplication [1, p.16].
High-level data structures can be queried through predicates
[1, p. 15]. ‚ÄúScala‚Äôs syntax avoids some of the boilerplate
that burdens Java programs‚Äù [1, p. 14].
Parallel Programming. Actors are easier to work with
than Java‚Äôs native style with locks [1, p. 583]. Java‚Äôs
concurrency support is sufÔ¨Åcient, but ‚ÄúdifÔ¨Åcult to get right
in practice as programs get larger and more complex‚Äù [1, p.
583].
Debugging. Scala is less error prone than Java, as Scala
programs with fewer lines of code are assumed to have fewer
possibilities for defects [1, p. 13‚Äì14]. Actors help avoid
deadlocks and race conditions [1, p. 584, 616].
IV. D ESIGN OF THE EMPIRICAL STUDY
To validate the aforementioned claims on the status quo of
both languages, we study thirteen subjects who work indi-
vidually on two Scala and two Java projects during a training
phase and afterwards on the actual object of study, which
consists of one Scala project and one Java project extending
a real-world application. All projects require subjects to
create bug-free and well-performing parallel applications.
Additional data is provided by an Oracle software engineer
that agreed to work on the same project in Scala.
A. Preparations
Subjects. The subjects are thirteen Master‚Äôs students close
to their graduation who are on average in their fourth
year of Computer Science studies. Subjects in the studyhad appropriate previous knowledge from courses in soft-
ware engineering (e.g., programming languages, patterns,
development environments) and parallel programming (e.g.,
programming with shared-memory and message-passing).
Subjects reported an average of four years of Java experience
and no Scala experience. They knew the Eclipse and Net-
beans development environments. For comparison purposes,
a software engineer at Oracle agreed to work on the Scala
project and provide his results. He was familiar with the
algorithms relevant for our projects as well as with Scala
programming.
Feasibility Study. Prior to the study, we conducted a
feasibility study to ensure that the assignments have a
solution, i.e., there are working parallelization strategies
that are feasible to complete in the given period of time.
In addition, the same Oracle software engineer created a
parallel Scala program based on our project requirements.
B. A Two-Phase Approach
The approach applied in this study consists of two phases
where the subjects were asked to program in Java and Scala.
Phase One: Training . Initially, all subjects received
the same training in programming with Java and Scala,
which took four weeks. The Java training covered paral-
lel programming with shared-memory. The Scala training
included functional programming and parallel programing
with actors ([1], [18], [19] were required reading). In
addition, everyone was trained and tested on how to use
Eclipse and the Netbeans development environment, how
to debug, and how to conduct performance analyses for
parallel programs. Every subject successfully delivered a
working parallel implementation of the Dining Philosophers
problem [23] and mergesort [24] algorithm both in Java
and Scala (i.e., we obtained 13*2=26 Java programs and
26 Scala programs). The delivered code was used to assess
how subjects understood and employed the programming
concepts of Java and Scala. In this phase, we also measured
the level of proÔ¨Åciency; a Java pretest classiÔ¨Åed 7 subjects
as experts and 6 as beginners. A Scala pretest classiÔ¨Åed 7
subjects as experts, and 6 as beginners. At the end of phase
one, everyone passed and was ready to work on a larger
project.
Phase Two: Industry Project . This phase focuses on the
actual object of study, which is how programmers use Scala
and Java in a larger and more complex parallel application.
We employ a counterbalanced within-subjects design in
which 6 randomly chosen subjects are tasked to complete
a four-week project in Java Ô¨Årst, whereas the other 7 have
to do it in Scala (phase 2a). In another four weeks, the
subjects have to deliver another parallel program on the same
speciÔ¨Åcation, but this time the 7 subjects who started with
Scala switch to Java and vice-versa (phase 2b). This design
was chosen as resources were available only for one complexproject. Subjects were unaware and were initially told that
they will work on two different projects. Counterbalancing is
frequently employed to offset learning and ordering effects
when aggregating results [15], [25], [26]. For our study,
learning effects are discussed in Section XII.
Competition. A competition was set up among the Java
teams and Scala teams in both phases 2a and 2b, with
the goal of achieving the best-performing parallel program
for the given speciÔ¨Åcation, input benchmark, and multicore
machine. The competition not only motivated subjects to
achieve their best individual result, but also reduced the
incentive to collaborate (which was not allowed anyway).
We also disallowed direct code reuse from the previous
project and allowed using just the standard libraries and
parallel constructs that come with Scala and Java (e.g.,
java.util.concurrent ).
Project Description. The requirements for the project
were designed in collaboration with Oracle as an industrial
partner. This setup provides a realistic and representative
object of study that goes beyond a toy program.
In particular, the Electric VLSI Design System [27]
developed at Oracle Labs was used. Electric is an Open
Source VLSI CAD application for the custom VLSI designs
completely written in Java. Among all possible CAD tools
available in Electric, the analysis tool known as DRC (De-
sign Rules Checker) was chosen as a performance-critical
parallelizable task. A design rule speciÔ¨Åes certain geometric
and connectivity restrictions to ensure sufÔ¨Åcient margins
to account for variability in the fabrication process. Basic
design rules range from one layer, e.g., width, area or
spacing, to multiple layer rules, such as enclosure. Due to
time constraints and the complexity of dealing with all DRC
rules involved in modern technologies, subjects were asked
to parallelize the minimum area checking algorithm. This
algorithm ensures that manufacturers do not print circuits
in resolutions that are too small for a given technology and
minimum rules might need to be satisÔ¨Åed for each layer of
a chip. To facilitate the study, Electric developers offered
standardized APIs for Java and Scala to create extensions
for the DRC tool already available in Electric.
General literature on design rules checking (e.g., [28])
was handed out to subjects already in the Ô¨Årst week of the
study, to give subjects enough time to familiarize themselves
with the problem. At the start of phase 2, subjects were
handed out a 17 page document with more precise project
and algorithm speciÔ¨Åcations. This was accompanied by a
tutorial that described the problem, examples, APIs, coding
guidelines, and instructions about data structures to use. Ev-
eryone received support to set up his working environment,
understand boilerplate code, and compile project dummies.
Questions were answered by instructors and Oracle employ-
ees. No one had problems understanding the assignment or
working in the programming environment.The compulsory project speciÔ¨Åcations channel potential
solutions into a certain range, as assessed in our feasibility
study. They ensure that the submitted programs and results
do not differ because subjects employ widely diversiÔ¨Åed
algorithmic strategies and data structures. In principle, our
algorithm uses a list of bit sets to merge adjacent boundaries
of polygons of a metal layer and to ensure that the areas of
all Ô¨Çattened polygons satisfy the minimum area rule.
C. Sources of Evidence and Evaluation
Sources of Evidence . Throughout the study, we collect
evidence from several sources: (1) Weekly code submissions.
(2) Weekly semi-structured interviews with every subject.
(3) Student diaries and Ô¨Ånal project reports (delivered after
the study). (4) Time report sheets on a daily basis on
which students tracked the hours spent on various software
engineering task categories (e.g., design, implementation,
testing). The sheets were cross-checked with our interviews
and code inspections for validity. (5) Questionnaires after
the completion of each programming project (phase 1, 2a,
2b) captured feedback.
Evaluation . We employ statistics, case study techniques,
survey techniques, and interview techniques [15], [16], [17],
[25], [26] to extract the lessons learned from this study.
For presentation, we aggregate most of the quantitative data
into box-and-whiskers plots: lower and upper box bound-
aries denote lower and upper quartiles of data (visualizing
variability), a horizontal line within the box marks the
median, whiskers mark 1.5 times the interquartile range
on both box ends, and data exceeding the whisker range
is marked as outliers (depicted as circles). To gain further
support beyond what is visible in the plots, we also apply
where possible Wilcoxon‚Äôs rank sum test [29] paired on
subject results. Informally speaking, this non-parametric test
evaluates whether two populations differ with statistical
signiÔ¨Åcance (see [29] for details). We also apply other tests
for cross-checks (non-parametric and parametric, if data
distributions allow it), but typically omit their presentation
to avoid overload. The obtained p-values appear in the
respective graphs. Low p-values mean that there is a low
probability that the observed differences are accidental. As
in other similar studies (e.g., [6]) we interpret p0:05
as a strong indication for a difference, which degrades as
p increases; p > 0:1is the threshold where the difference
becomes insigniÔ¨Åcant.
V. W HONEEDS MORE EFFORT ?
Our data reveals that completing the DRC project in Scala
requires more effort than in Java. As an overview, Figure 1
shows the person hours required for the Scala and Java
projects sorted for each language in descending order.
Figure 2 illustrates the aggregated statistics. The median
effort is 56 hours for Scala and 43 hours for Java (13 hours
difference). The mean effort is 72 hours for Scala and 521 2 3 4 5 6 7 8 9 10 11 12 13
RankingProject Person Hours
0 20 40 60 80 100 120 140Scala Java 126131
111
90105
80101
7085
6783
5356
4356
4054
3851
2946
1634
1627
6Figure 1. Effort required to complete the project in Scala and in Java,
sorted for each language in descending order.
hours for Java, which means that on average it takes 20 hours
(38%) longer to complete the Scala project. The populations
differ signiÔ¨Åcantly with p= 0:059.
Scala Java20 40 60 80 100 120Project Person Hours(a) Effort
p‚àívalue = 0.059
20 40 60 80 100 1200.0 0.2 0.4 0.6 0.8 1.0
Project Person Hours(b) Cumulative Distribution Function
JavaScala
Figure 2. Aggregated effort statistics show a signiÔ¨Åcant difference between
Scala and Java.
As the data collection assigns person hours to particular
categories, we are able to provide additional details in
Figure 3, which shows how much of the implementation time
subjects spent working mostly on sequential code or parallel
code. In Figure 3(a), the median time for parallel coding
in Scala is 14 hours (mean 18 hours) and 11 hours in Java
(mean 12 hours), and there is weak statistical support for the
difference with p= 0:08. For time spent on sequential code
in Figure 3(b), the median in Scala is 8 hours (mean 8 hours)
and 4 hours in Java (mean 6 hours), however, the difference
is insigniÔ¨Åcant ( p= 0:45). The most signiÔ¨Åcant difference
is due to testing and debugging effort in Figure 3(c): the
median in Scala is 20 hours (mean 23 hours), the median
in Java is 10 hours (mean 14 hours), a clear difference
supported by p= 0:041.
Scala Java0 10 20 30 40(a) Impl. Parallel CodeProject Person Hoursp‚àívalue = 0.084
Scala Java0 5 10 15 20(b) Impl. Sequential CodeProject Person Hoursp‚àívalue = 0.455
Scala Java10 20 30 40(c) Testing and DebuggingProject Person Hoursp‚àívalue = 0.041Figure 3. Effort for all parallel projects split up into implementing
sequential code, parallel code, and testing and debugging.
As a comparison, the Oracle software engineer needed
about 18 hours to create a sequential Scala program on
the same speciÔ¨Åcation. He required about 72 hours (which
happens to be the mean effort of our Scala subjects) for a
parallel version; out of this time, he spent 10 hours on testing
and debugging (13 hours less than our subjects‚Äô mean).
Programmer skills (as determined in our pretest, see
Section IV-B) inÔ¨Çuence how each subject ranks in terms of
effort, but the aggregated statistics balance out this effect be-
cause there are roughly equally many experts and beginners
in both Scala and Java. We conducted a multivariate analysis
of variance (MANOV A [30]) that analyzes the impact of
Java and Scala skills (beginner/expert) on the Java and Scala
effort of each subject (the analysis was applicable in our case
because the Box-test on equality of covariance matrices was
insigniÔ¨Åcant [30]). Results show that expert skills lead to
lower effort in comparison to beginners (p=0.05 for Java
expertise and p=0.02 for Scala expertise). The analysis on
how skills affect parallel implementation time also reveals
a combined inÔ¨Çuence, i.e., that the interaction of Java skills
and Scala skills together affects the parallel implementation
time ( p= 0:08). By contrast, it is remarkable to observe that
Java and Scala skills do not have a signiÔ¨Åcant inÔ¨Çuence on
testing and debugging time ( p > 0:1), which suggests that
this big difference has nothing to do with skills.
Explanations for the difference in testing and debugging
effort come from our interviews and code inspections. One
of the main reasons why such effort is higher in Scala
is because type system features that actually aim to make
programming more productive turn out to make debugging
more difÔ¨Åcult. In particular, subjects complained that the
automated type inference required them to spend more time
to understand which actual type each object has when errors
are encountered, and they were unsatisÔ¨Åed with tool support
on this issue. In addition, automatic object creation and
copying was another feature that required more time to track
errors and optimize performance.VI. W HOHAS THE FIRST PARALLEL PROGRAM ?
Java programmers were the Ô¨Årst to have a working parallel
program. As a measurement of parallelization progress, we
tracked the week when each subject had the Ô¨Årst working
parallel program, based on code inspections and interviews.
Figure 4 illustrates that all subjects submitted a parallel
version by the deadline of the project. In the week before the
deadline, an equal number of nine parallel Scala and Java
programs (69%) worked.
Week 1 Week 2 Week 3 Week 4 Week 5#subjects
0 2 4 6 8 10 12Scala Java
01
03
269 913 13
13 13
Figure 4. Number of subjects who had a working parallel program in
a particular project week (week 5 represents submitted programs after the
4-week deadline).
The chart also reveals, however, that no programmer had a
working parallel Scala program until the third project week,
even though roughly a third of parallel Java programs were
already working in the second week. Interview data suggests
that subjects needed time to Ô¨Ågure out how to exactly take
advantage of the functional style in their particular program.
The results also match the effort observations in Section V.
As soon the problems were overcome, increases in working
parallel Scala programs were much steeper than for Java.
This observation suggests that Scala is powerful because
everyone was still able to make the deadline, but it takes
time to understand how to exploit its power.
VII. W HOSE CODE ISMORE COMPACT ?
One of Scala‚Äôs claims is that a Scala program needs fewer
lines of code compared to a similar Java program. Our results
support this claim in our DRC project context.
Figure 5 summarizes the lines of code (LOC) of all Scala
and Java programs as well as their number of characters,
excluding comments and blank lines. Scala has 533 median
LOC (mean 536) and Java 547 median LOC (mean 632),
but the overall box and whiskers of Scala tend towards lower
values. Also, no Scala program is longer than 730 LOC. The
paired Wilcoxon rank sum test on each subject‚Äôs solution
shows support ( p= 0:078) that Scala code is more compact.
Quantitative claims of the literature [1], however, seem
overgeneralized and are not supported. In this experiment,
Scala programs do not have 50% fewer lines of code
compared with their Java counterparts. Figure 5 refutes thisclaim, revealing only a median difference of 14 LOC (2.6%)
and mean difference of 96 LOC (15.2%). Also, the claim
that in extreme cases Scala has 10 times less code than Java
does not hold for our application. The difference between
extremes is 1086 LOC in Java versus 284 LOC in Scala,
which is just 3.8 times less.
An additional analysis on the number of characters shows
similar trends that Scala programs are more compact than
Java programs, but the statistical support is weaker ( p=
0:094). However, the medians of Scala and Java programs
are farther apart for characters than for lines of code.
A Ô¨Ånal comparison baseline is a sequential and a parallel
Scala program that were developed under the same spec-
iÔ¨Åcations by an Oracle software engineer. His sequential
program has 185 LOC and 3756 characters. His parallel
program has 472 LOC (only 11% less than our subject‚Äôs
median LOC), which shows that his program is comparable
to our subject‚Äôs programs. However, his program has 10,186
characters (25% less than our best subject) showing that even
more compactness is possible in Scala.
VIII. H OWAREFUNCTIONAL AND IMPERATIVE
STYLES USED?
In a multi-paradigm language like Scala, a question of
interest is how subjects actually employ the functional style
and imperative style in practice. We answer this question by
analyzing the code of each subject‚Äôs Scala project. We also
provide a comparison with the parallel projects delivered
during the training phase (parallel mergesort and parallel
dining philosophers).
In particular, we start by classifying key language con-
structs as belonging to either a typical imperative style or a
functional style, as suggested in the common Scala literature
[1]. For example, var,object ,array ,while ,for,
abstract ,import java , etc. indicate an imperative
style. By contrast, constructs such as val,list ,map,
filter ,flatmap ,foreach ,::: (list concatenation),
::(list cons operator) indicate a functional style. We
count the occurrences of all such constructs in each project
and calculate the percentage of how many belong to the
imperative class and how many belong to the functional
class. Figure 6 summarizes the results of this analysis for
each subject in the study.
In the DRC project code, Figure 6(a) shows that 8 subjects
use more than 50% imperative style (right half of the
diagram) and 5 use more than 50% functional style. At
the extremes, one subject uses 98% imperative style and
one subject 78% functional style. The project outcomes are
roughly similar for the projects of the training phase. For
parallel mergesort in Figure 6(b), 5 subjects use more than
50% imperative style. At the extremes, one program uses
88% imperative style and one with 89% functional style.
Using functional style in this context is natural because of
the algorithm design. For the dining philosophers in FigureScala Java400 600 800 1000LOC(a) Lines of Code
p‚àívalue = 0.078
400 600 800 10000.0 0.2 0.4 0.6 0.8 1.0
LOC(b) Cumulative Distribution Function
JavaScala
Scala Java20000 30000 40000 50000 60000#Characters(c) Number of Characters
p‚àívalue = 0.094
20000 40000 600000.0 0.2 0.4 0.6 0.8 1.0
#Characters(d) Cumulative Distribution Function
JavaScalaFigure 5. Code compactness analysis of Scala versus Java.
020406080100(a) Parallel DRC Projectdata[, index]
Subj09Subj05Subj13Subj08Subj11Subj04Subj07Subj06Subj02Subj10Subj12Subj01Subj03020406080100(b) Parallel Mergesortdata[, index]
Subj04Subj06Subj05Subj07Subj02Subj11Subj09Subj08Subj01Subj13Subj03Subj12Subj10020406080100(c) Dining Philosophersdata[, index]
Subj09Subj11Subj02Subj13Subj06Subj12Subj04Subj10Subj01Subj08Subj05Subj07Subj03%Imperative %Functional
Figure 6. Percentage of functional and imperative programming styles
used by each subject in Scala.
6(c), 8 subjects use more than 50% imperative style. At the
extremes, one program uses 94% imperative style and one
73% functional style.
By contrast, the sequential DRC project program created
by the Oracle software engineer uses 49% imperative style
and 51% functional style. His parallel version shifts towards
40% imperative style and 60% functional style.
As a cross-validation, another Oracle software engineer
familiar with Scala inspected each program in the DRC
project and counted how many methods employ a functional
style or an imperative style, classifying them based on
his impression and experience. The resulting functional/im-
perative percentages are similar to those of our construct
counting method in Figure 6(a). The median divergence
is 20%, which is not surprising due to the more coarse-
granular and subjective counting. As both approaches show
a similar trend, we stick in the following discussion to the
more objective construct counting approach.
It is insightful to note that many subjects use functional
and imperative style in a quite balanced way. However,
certain individuals heavily prefer either the functional or
imperative style. This preference can be observed quite
consistently for both the training projects and the parallel
DRC project. However, no subject entirely rejects eitherstyle. The data shows that functional programming is indeed
useful for realistic parallel programming projects.
IX. W HOHAS THE BESTPERFORMANCE ?
In this study, sequentially executed Scala programs are
faster than their Java counterparts. In the parallel case,
however, Java programs have better scalability with higher
speedups. The top run-times are similar for both languages.
A. Setup
All DRC project programs are evaluated on a repre-
sentative real chip layout that has been successfully taped
out in the past. The input Ô¨Åle has 2;260;627 rectangles
that are distributed over 74;137 subcells with a maximum
hierarchy depth of 14. The bounding box of the entire chip
is166;946208;594units. We ensured that every program
worked correctly on this input (programmers were given
the opportunity to Ô¨Åx problems after the deadline, which
caused just minimal code changes). All applications are
benchmarked on the following machines:
4-core machine : Intel Xeon X5677. This machine has a
single-chip architecture with 4 cores, 2 hardware threads per
core, 48 GB RAM, and runs RedHat Enterprise Linux 6.0.
32-core machine : Sun SPARC T3-4. This machine has a 4-
chip NUMA architecture with 8 cores per chip and 8 hardware
threads per core, 256 GB RAM, and runs Solaris 10.
The Scala projects are compiled with Scala 2.8.1 and the
Java projects with Java 7. Compiling all Scala projects takes
8 times longer than compiling all Java projects (e.g., on the
4-core machine it took 85 seconds for Scala and 11 seconds
for Java).
B. Measurements
All developers made the number of parallel threads con-
Ô¨Ågurable from the command line. Figures 7(a)‚Äì(d) sum-
marize execution times and speedups with respect to the
execution with one thread on each machine. All parallel
Java and Scala programs are executed with 1, 2, 4, 8, 16,S.1
J.1
S.2
J.2
S.4
J.4
S.8
J.8
S.16
J.16
S.32
J.320100200300400500(a) Runtime: Intel Xeon, 4 cores
Language.#ThreadsRuntime (sec)
S.2
J.2
S.4
J.4
S.8
J.8
S.16
J.16
S.32
J.32123456(c) Speedup: Intel Xeon, 4 cores
Language.#ThreadsSpeedup over serial
S.1
J.1
S.2
J.2
S.4
J.4
S.8
J.8
S.16
J.16
S.32
J.32
S.64
J.64
S.128
J.1280100020003000(b) Runtime: SPARC T3, 32 cores
Language.#ThreadsRuntime (sec)11196S.2
J.2
S.4
J.4
S.8
J.8
S.16
J.16
S.32
J.32
S.64
J.64
S.128
J.1280510152025(d) Speedup: SPARC T3, 32 cores
Language.#ThreadsSpeedup over serialFigure 7. Performance overview of all Scala and Java project programs for a varying number of threads.
32 threads to test scalability. On the 32-core machine we
added 64 and 128 threads because the hardware offers more
parallelism. To avoid bias, each performance data point is
an average of 10 runs on each conÔ¨Åguration (we remark
that the input size is large enough so speedups do not come
from data that remains in the cache between runs). Each box
plot summarizes 13 performance data points (one for every
subject) for each thread conÔ¨Åguration and language.
C. Results
The measurements in Figures 7(a) and (b) reveal that the
Scala programs executed with one thread are typically faster
than the Java programs (median difference is 82 sec on the 4-
core machine and 190 sec on the 32-core machine). Our con-
trolled experiments carried our after the study have identiÔ¨Åed
the stack implementation in Java ( java.util.stack ) as a
major cause for performance problems that did not exist in
Scala. With increased thread count, however, Java programs
exhibit better scalability and higher median speedups than
the Scala programs.
On the 4-core machine, Figure 7(a) shows that the best
Scala runtime is 7 sec at 4 threads (subject 4, cf. Fig. 6 ). The
best Java runtime is 4 sec at 8 threads (subject 6). However,
the median runtime over all thread counts is 83 sec for Scalaand 98 sec for Java, which shows that the ‚Äúaverage‚Äù Scala
program is faster than the ‚Äúaverage‚Äù Java program.
On the 32-core machine, Figure 7(b) shows that the best
achieved Scala runtime is 34 sec at 64 threads (subject 4).
The best Java runtime is close with 37 sec at 128 threads
(subject 11). The median runtime is 466 sec for Scala and
576 sec for Java, again with Scala being faster.
By contrast, the Oracle software engineer achieved with
his parallel Scala program the following results: Best time
on the 4-core machine was 7 sec at 8 threads (speedup
3.6). Best time on the 32-core machine was 32 sec at 64
threads (speedup 11.3). These numbers match very well the
performance of the top subjects in our study.
D. Does Functional Programming Harm Performance?
The top 3 performers on the 4-core machine (subjects 4,
11, and 6) used 47%, 55%, 38% functional style in their
programs. On the 32-core machine, the top 3 performers
(subjects 4, 11, and 5) used 47%, 55%, 64% functional
style. Subject 3 who used 2% functional style (i.e., 98%
imperative style), which was the least functional style of
all Scala programs, ranked among the worst 3 performers
(along with subjects 3, 8, and 13) on both machines.
These empirical results contradict popular belief that a
functional programming style harms performance. At thesame time they provide support for the promise of multi-
paradigm languages by showing that it is possible to do
automated performance tuning under the hood. The results
also show the need for a combination of functional style and
imperative style, as no top performer used functional style
exclusively. Our data thus solidiÔ¨Åes the ground for language
designers, compiler writers, and tool developers to direct
more effort into multi-paradigm parallel languages.
X. P ROGRAMMER SURVEY FEEDBACK
Programmer feedback collected at the end of the study
provides additional explanations for the observations made
so far. The majority of the questions had a Ô¨Åve-level Likert
scale [15] (ranging from ‚Äústrongly disagree to strongly
agree‚Äù). Due to space limitations in this paper, we provide
a summarized interpretation and mention the percentage
of subjects in favor or against a statement (aggregating
‚Äúagree‚Äù and ‚Äústrongly agree‚Äù as ‚Äúagree‚Äù, and ‚Äúdisagree‚Äù and
‚Äústrongly disagree‚Äù as ‚Äúdisagree‚Äù).
Scala type system. Letting the compiler implicitly derive
the types of variables can become a problem during debug-
ging. While 46% of the subjects agreed that this feature was
helpful when writing code, 85% of the subjects agreed that
it leads to programming errors.
Learning and code understanding. Programmers found
Java programs easier to understand than Scala programs
(77% say understanding Java programs is easy, compared
to 46% for Scala). Java syntax was perceived to be easier
than Scala (92% agree that Java syntax is simple, 62% agree
that Scala syntax is simple). Only 30% say that adapting to
Scala‚Äôs programming model was easy, compared to 100%
for Java. Concerning parallelism, there is an opposite per-
ception: 46% agree that using Java parallel constructs is
easy, compared to 92% who say that using Scala parallel
constructs is easy. Also, 62% say that Scala parallel construct
usage was easy to remember, while 54% say that Java paral-
lel construct usage was easy to remember. These responses
suggest that Scala in general is not perceived to be easier
than Java, but that the subjects felt like there are advantages
for the understanding of parallel programs.
Tool support. Tool support for Scala needs further
improvements. Just one subject said that tool support for
Scala is good, compared to 77% for Java. Only 30% of
subjects are satisÔ¨Åed with Scala IDE support, compared to
69% for Java.
Satisfaction. The answers show that most programmers
have a positive attitude towards Scala and Java. 54% of the
subjects agree that it is a pleasure to use Scala, compared to
69% for Java. There are 77% who say they will use Scala
again, and 92% said they will use Java again. Concerning the
programming style, 30% agree that functional programming
is frustrating, while 46% disagree.
Perceived productivity. Programmers feel productive in
both languages, but complain about the Scala documenta-tion. 92% of subjects feel productive in Scala, compared
to 100% in Java. Only one programmer, however, agrees
that the available Scala documentation is good, compared to
100% for Java.
Parallelism. Scala parallel programming with actors is
perceived to be easier than shared-memory programming
in Java, which is supported by 38% of programmers in
Scala versus 23% in Java. However, most programmers said
they tried to postpone parallelization work in both languages
(77% in Scala versus 69% in Java). Programmers also seem
to have more problems in Scala because 85% say they were
afraid of breaking a working program by using additional
Scala parallel constructs, compared to 69% for Java.
Errors. Race conditions are ranked the most important
encountered error in both Scala and Java. In addition,
debugging a multi-paradigm language such as Scala seems
to be a major problem. Just 23% of programmers say that
debugging Scala programs is easy, compared to 77% for
Java. Consequently, we need better techniques and tools.
Composition. To handle complex programs, 69% of
subjects say that Scala programs are easy to compose from
simpler parts, compared to 54% for Java. Scala obviously
offered advantages to handle data structures, as 46% of pro-
grammers agree that applying operations on data structures
was more Ô¨Çexible in Scala, compared to 15% in Java.
XI. C ODE INSPECTION AND INTERVIEW INSIGHTS
Code inspections and interviews are valuable sources of
evidence that we explore to improve our understanding of
Scala and Java usage in the context of multicore program-
ming. Due to space limitations, we present an excerpt of
results that we consider most relevant.
Performance. Bad Scala performance was often related
to immutable data structures, which were typically used
by subjects to achieve thread-safety [31]. For example,
some subjects with bad performance overlooked that update
operations implicitly triggered object copy operations that
could be expensive for data structures with many objects.
Errors. Race conditions were the major cause for delays
in progress for both Scala and Java. Typically there was one
major defect that cost subjects most of their debugging time.
For example, one subject reported that it took him 16 hours
to Ô¨Ånd a race condition involving access to a Scala collection
that concatenated two immutable data structures, but only
one hour to Ô¨Åx it. Another Scala programmer spent 20% of
his project time on debugging to track a race condition that
broke a fork-join parallelization pattern.
In Java, some subjects overlooked that concurrent reading
operations on shared state required synchronization, assum-
ing that only writing needed protection. Others accidentally
used multiple lock objects where they should have used
just one lock. Moreover, others used Ô¨Çawed double-checked
locking patterns [32]. Even though the training phase ad-
dressed these problems and all subjects were able to avoidthem on smaller tests, it appears that programmers need to
rely on tool support for more complex projects in practice.
Functional style and type system issues. The functional
code of some subjects was difÔ¨Åcult to understand because
they used functions with side effects that were not obvious.
Implicit type conversions were powerful in saving code,
but turned out to make code understanding more difÔ¨Åcult
and add errors. When reviewing their own code, subjects
reported that they had to spend a lot of time understanding
return types of functions, especially for larger functions.
XII. T HREATS TO VALIDITY
Every empirical study, including this one, has limitations.
To construct internal validity, we have carefully chosen our
application to be representative, but results may differ for
other applications and hardware. Based on our feasibility
studies and experience, we are conÔ¨Ådent, however, that most
of the issues and problems encountered in this study will
also be encountered in similar parallel applications. The
effects we measured became already statistically apparent
for the number of subjects participating in our study, though
it is possible that other subjects will obtain different results.
The skill levels measured in our own pre-tests revealed a
balanced number of experts and beginners. Our study design
aimed to reduce bias by using randomized assignment of
subjects to projects, training everyone in the same way, and
using counterbalancing to cancel out ordering and learning
effects. Learning effects are roughly similar in both groups:
In the DRC project, difference of median effort of the Scala-
second projects is about 35% less than Scala-Ô¨Årst; for Java-
second, it is about 44% less than Java-Ô¨Årst. We used several
sources of evidence to reduce other bias. All data, including
effort, surveys, and interviews, were reported individually at
regular intervals. We cross-checked all data for plausibility
and compared student reports with the delivered code, and
interview statements. Student statements were honest and
matched the overall proÔ¨Åles and their history.
To validate our comparisons and create external validity,
an Oracle software engineer agreed to work on the same
project in Scala. As discussed throughout the paper, the
results show that our data is within similar ranges as for
an industry professional.
XIII. R ELATED WORK
Functional and imperative languages have a long tradition.
An individual comparison is beyond the scope of this paper,
so we refer to [5] for a survey in the context of concurrency.
Loop recognition in Java and Scala has been compared
in [9]. Empirical studies in multicore software engineering,
however, are scarce. Recent studies compare Transactional
Memory and locks [10], Pthreads and OpenMP [11], [12],
as well as MPI and OpenMP [13]. Empirical studies directly
comparing functional versus imperative programming on
today‚Äôs multicore platforms have received little attentionso far. The study of [8] on SML versus C++ done 15
years ago was not conducted with a multi-paradigm lan-
guage on multicore and unfortunately had implementations
that were difÔ¨Åcult to compare; however, that study reports
similar results to ours that subjects need more effort to
test functional code as opposed to imperative code. An
experience report on using the OCaml functional object-
oriented language on a server application has been published
by [7], but it is not a controlled study with several subjects.
The study of [33] focuses on type systems and Ô¨Ånds a null
result for the use of static type systems on development
time. An experience report on how Scala has been used at
Twitter appeared in [22]. Other studies such as [14] focus on
the high performance computing domain where application
requirements largely differ. Yet other studies such as [34]
analyze the impact of team-level metrics on product-level
software metrics. The work of [6] compares programming
languages based on a sequential application with respect to
general metrics like performance or lines of code.
XIV. C ONCLUSION
Multicore hardware is ubiquitous, and software engineer-
ing has to catch up. Multi-paradigm languages such as Scala
promise to alleviate the tough parallel programming prob-
lems that developers are facing today, by combining func-
tional and imperative programming style. Our data reinforces
that this direction deserves more investigation. Results show
that Scala code is indeed more compact than Java code. Scala
application performance is also comparable to Java. Results
contradict popular belief that a functional programming style
harms performance. The top performers wrote about half
their programs in a functional style and the other half in an
imperative style. However, the results also show the need for
a combination of functional style and imperative style, as no
top performer used functional style exclusively. With respect
to effort, this study refutes the claim that Scala programs are
faster to develop: in comparison to Java, Scala requires more
effort, and especially more testing and debugging effort.
Scala programmers also lagged behind Java programmers to
obtain the Ô¨Årst working parallel applications. Programmer
feedback in this study does not show that Scala programs
are easier to understand than Java programs, but we track
the reasons down to the more complex type system. The
type system aims to speed up coding and make programs
more compact, but signiÔ¨Åcantly complicates the reading and
debugging process. We need to address these issues better in
the future to make programming in the multicore era easier.
ACKNOWLEDGEMENTS
We thank Jochen Huck for organizational support during the
study. At Oracle Labs, we thank Victor Luchangco, Mark Moir,
David Chase, Steven Rubin, and Guy Steele for excellent feedback
on earlier drafts of this paper, as well as Dmitry Nadezhin for
providing us with the Minimum Area API in Electric and his Scala
implementation that served as a comparison baseline.REFERENCES
[1] M. Odersky, L. Spoon, and B. Venners, Programming in
Scala , 1st ed. Artima, 2007.
[2]C# Language SpeciÔ¨Åcation v. 3.0 . Microsoft Corporation,
2007.
[3] K. Davis and J. Striegnitz, ‚ÄúMultiparadigm Programming
in Object-Oriented Languages: Current Research,‚Äù in Proc.
ECOOP 2007 LNCS 4906 . Springer, 2008.
[4] S. H. Fuller and L. I. Millett, ‚ÄúComputing Performance: Game
Over or Next Level?‚Äù IEEE Computer , vol. 44, no. 1, 2011.
[5] D. B. Skillicorn and D. Talia, ‚ÄúModels and Languages for
Parallel Computation,‚Äù ACM Comput. Surv. , vol. 30, pp. 123‚Äì
169, June 1998.
[6] L. Prechelt, ‚ÄúAn Empirical Comparison of Seven Program-
ming Languages,‚Äù Computer , vol. 33, no. 10, pp. 23 ‚Äì29, oct
2000.
[7] D. Scott, R. Sharp, T. Gazagnaire, and A. Madhavapeddy,
‚ÄúUsing Functional Programming within an Industrial. Product
Group: Perspectives and Perceptions,‚Äù in Proc. ACM ICFP ,
2010, pp. 87‚Äì92.
[8] R. Harrison, L. Smaraweera, M. Dobie, and P. Lewis, ‚ÄúCom-
paring Programming Paradigms: An Evaluation of Functional
and Object-Oriented Programs,‚Äù Softw. Eng. Journal , vol. 11,
no. 4, pp. 247 ‚Äì254, jul 1996.
[9] L. Hundt, ‚ÄúLoop Recognition in C++/Java/Go/Scala,‚Äù Proc.
Scala Days , 2011.
[10] V . Pankratius and A.-R. Adl-Tabatabai, ‚ÄúA Study of Transac-
tional Memory vs. Locks in Practice,‚Äù in Proc. ACM SPAA ,
2011, pp. 43‚Äì52.
[11] V . Pankratius, A. Jannesari, and W. F. Tichy, ‚ÄúParallelizing
BZip2. A Case Study in Multicore Software Engineering,‚Äù
IEEE Softw. , vol. 26, pp. 70‚Äì77, November 2009.
[12] V . Pankratius, C. Schaefer, A. Jannesari, and W. F. Tichy,
‚ÄúSoftware Engineering for Multicore Systems ‚Äì An Experi-
ence Report,‚Äù in Proc. ACM IWMSE , 2008, pp. 53‚Äì60.
[13] L. Hochstein, J. Carver, F. Shull, S. Asgari, and V . Basili,
‚ÄúParallel Programmer Productivity: A Case Study of Novice
Parallel Programmers,‚Äù in Proc. ACM SC , 2005.
[14] V . Basili, J. Carver, D. Cruzes, L. Hochstein, J. Hollingsworth,
F. Shull, and M. Zelkowitz, ‚ÄúUnderstanding the High-
Performance-Computing Community: A Software Engineer‚Äôs
Perspective,‚Äù Software, IEEE , vol. 25, no. 4, pp. 29 ‚Äì36, july-
aug. 2008.
[15] L. B. Christensen, Experimental Methodology , 10th ed. Al-
lyn & Bacon, 2006.[16] P. Runeson and M. H ¬®ost, ‚ÄúGuidelines for Conducting and
Reporting Case Study Research in Software Engineering,‚Äù
Emp. Softw. Eng. , vol. 14, no. 2, pp. 131‚Äì164, 2009.
[17] R. K. Yin, Case Study Research: Design and Methods , 3rd ed.
Sage Publications, Inc, 2002.
[18] M. Odersky et al. , ‚ÄúAn Overview of the Scala Program-
ming Language (second edition),‚Äù EPFL, Tech. Rep. LAMP-
REPORT-2006-001, 2006.
[19] M. Schinz and P. Haller, ‚ÄúA Scala Tutorial for Java program-
mers,‚Äù www.scala-lang.org, November 9 2010.
[20] M. Herlihy and N. Shavit, The Art of Multiprocessor Pro-
gramming . Morgan Kaufmann, 2008.
[21] T. G. Mattson, B. A. Sanders, and B. L. Massingill, Patterns
for Parallel Programming . Addison-Wesley, 2004.
[22] M. Eriksen, ‚ÄúScaling Scala at Twitter,‚Äù in Proc. ACM CUFP ,
2010, pp. 8:1‚Äì8:1.
[23] C. A. R. Hoare, Communicating Sequential Processes . Pren-
tice Hall, 2004.
[24] B. Wilkinson and M. Allen, Parallel Programming . Prentice
Hall, 2004.
[25] N. Juristo and A. M. Moreno, Basics of Software Engineering
Experimentation . Kluwer, 2001.
[26] F. Shull, J. Singer, and D. I. Sjoberg, Eds., Guide to Advanced
Empirical Software Engineering . Springer, 2008.
[27] ‚ÄúElectric,‚Äù http://www.staticfreesoft.com/index.html, 2011.
[28] G. E. Bier and A. R. Pleszkun, ‚ÄúAn Algorithm for Design
Rule Checking on a Multiprocessor,‚Äù in Proc. AC DAC , 1985.
[29] M. Hollander and D. A. Wolfe, Nonparametric Statistical
Methods . Wiley, 2nd 1999.
[30] ‚ÄúIBM SPSS Statistics Version 19,‚Äù
http://www.ibm.com/software/analytics/spss/, 2010.
[31] J. Bloch, Effective Java - Programming Language Guide .
Addison Wesley, 2001, pp. 50‚Äì56.
[32] D. Bacon et al. , ‚ÄúThe ‚ÄúDouble-Checked Locking is
Broken‚Äù Declaration,‚Äù http://www.cs.umd.edu/ pugh/java/
memoryModel/DoubleCheckedLocking.html, Sep 2011.
[33] S. Hanenberg, ‚ÄúAn Experiment About Static and Dy-
namic Type Systems. Doubts About the Positive Impact of
Static Type Systems on Development Time,‚Äù in Proc. ACM
OOPSLA , 2010.
[34] A. Meneely, P. Rotella, and L. Williams, ‚ÄúDoes Adding
Manpower Also Affect Quality? An Empirical, Longitudinal
Analysis,‚Äù in Proc. ACM SIGSOFT/FSE , 2011.