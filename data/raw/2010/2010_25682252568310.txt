Self-Adaptation through Incremental Generative Model
Transformations at Runtime
Bihuan Chen*y, Xin Peng*y, Yijun Yuz, Bashar Nuseibehzx, and Wenyun Zhao*y
*School of Computer Science, Fudan University, China
yShanghai Key Laboratory of Data Science, Fudan University, China
zDepartment of Computing and Communications, The Open University, UK
xLero-The Irish Software Engineering Research Centre, University of Limerick, Ireland
{bhchen, pengxin, wyzhao}@fudan.edu.cn, {y.yu, b.nuseibeh}@open.ac.uk
ABSTRACT
A self-adaptive system uses runtime models to adapt its ar-
chitecture to the changing requirements and contexts. How-
ever, there is no one-to-one mapping between the require-
ments in the problem space and the architectural elements
in the solution space. Instead, one rened requirement may
crosscut multiple architectural elements, and its realization
involves complex behavioral or structural interactions mani-
fested as architectural design decisions. In this paper we pro-
pose to combine two kinds of self-adaptations: requirements-
driven self-adaptation, which captures requirements as goal
models to reason about the best plan within the problem
space, and architecture-based self-adaptation, which cap-
tures architectural design decisions as decision trees to search
for the best design for the desired requirements within the
contextualized solution space. Following these adaptations,
component-based architecture models are recongured using
incremental and generative model transformations. Com-
pared with requirements-driven or architecture-based ap-
proaches, the case study using an online shopping bench-
mark shows promise that our approach can further improve
the eectiveness of adaptation (e.g. system throughput in
this case study) and oer more adaptation exibility.
Categories and Subject Descriptors
D.2.10 [ Software Engineering ]: Design| Methodologies ;
D.2 [Software Engineering ]: Requirements/Specications;
D.2 [Software Engineering ]: Software Architectures
General Terms
Design, Management
Keywords
Self-adaptive system, runtime model, requirements, archi-
tecture, design decisions, model transformation
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
ICSE â€™14, May 31 - June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05 ...$15.00.1. INTRODUCTION
In software engineering, requirements analysis seeks to
\solve the right problem"while design space exploration seeks
to \solve the problem right" [46]. Both activities tradition-
ally happen at development time. After a software product
is deployed, changes to the problem or to the solution re-
quire a time-consuming, at best iterative, development ac-
tivity [34]. Increasingly, however, software systems are re-
quired to respond quickly to changing environments and re-
quirements by dynamically adapting their architectures to
their perception of customers' satisfaction.
Model-based approaches have been proposed as one way
to achieve runtime self-adaptation [20]. Instead of relying
on low-level and error-prone scripts for every possible adap-
tation, with models at runtime, a system can query, ana-
lyze and manipulate them to realize dynamic adaptations [7,
31]. Specically, requirements models (e.g., [18, 6]) and ar-
chitecture models (e.g., [22, 19]) have been used for self-
adaptation. However, some problems still remain.
Requirements-driven approaches assume that requirements
elements (e.g., goals) can be simply and directly mapped
to architectural elements (e.g., components), and thus ne-
glect the complexity of architectural design. Architecture-
based approaches, on the other hand, assume that require-
ments are well-understood at design time and unchanged at
runtime, and thus are unable to support dynamic adapta-
tions to changing requirements. In any case, both these two
kinds of self-adaptation approaches have a role to play and
should be combined. In the prior attempts to combine them
(e.g., [43, 45]) following Kramer and Magee's reference archi-
tecture [28], architectural elements are regarded as a collec-
tion of interfaces to functional requirements, hence lacking
consideration of more complex architectural concerns.
A software architecture is not just a collection of func-
tionalities but also a collection of design decisions concern-
ing how those functionalities are structured and interacting
with each other [25]. In that sense, architectural adapta-
tions must also reect the adaptations of design decisions.
Manifest as the adapted design decisions, architectural adap-
tations may crosscut simultaneously multiple parts of a sys-
tem; for instance, adding a logger function before any access
to condential information for better security. Architectural
adaptations may also involve restructuring of existing func-
tionalities to change the runtime structures or behaviors [35];
for instance, changing the structure of collaborating compo-
nents from sequential to parallel for better performance.Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full citation
on the ï¬rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSEâ€™14 , May 31 â€“ June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568310
676
In this paper, we propose a new model-based self-adaptation
approach that combines requirements and architectural adap-
tations and supports complex architectural adaptations us-
ing model transformation techniques. We assume that re-
quirements are available at runtime as goal models, archi-
tectural design decisions are available at runtime as design
decisions models expressed as decision trees, and these mod-
els are consistent with each other.
Our approach periodically searches for a better architec-
tural design solution using the design decisions model. If
no solution exists given the constraints of current require-
ments and contexts, goal-oriented requirements reasoning
is conducted to nd a better goal specication within the
constraints of quality expectations, and then the related
design decisions are reconsidered to nd a design solution
reecting the adapted goal specication. In either case, ar-
chitectural adaptations are achieved by executing the auto-
matically generated model transformation scripts in QVT-R
(Query/View/Transformation-Relations) [4] that incremen-
tally transform the current runtime architecture model into
an adapted one. Given the adapted architecture model, the
actual system recongurations can be delegated to any exist-
ing architecture-based management middleware (e.g., [40]).
We conducted a case study using an online shopping bench-
mark to evaluate the proposed approach. The results show
promise that our approach can further improve the eec-
tiveness of adaptation (e.g. system throughput in this case
study) and oer more adaptation exibility than requirements-
driven or architecture-based self-adaptation approaches.
The rest of this paper is structured as follows. Section 2
motivates our work through a running example. Section 3 in-
troduces some preliminaries required before Section 4 presents
our proposed approach. Section 5 evaluates our proposal.
Section 6 introduces and compares some related work be-
fore Section 7 draws our conclusions.
2. A MOTIVATING EXAMPLE
An online shopping company has a business department in
charge of marketing strategies and a technical department in
charge of development and maintenance of the IT systems.
Suppose a sales promotion is launched for celebrating the
New Year. It is anticipated that the system may suer per-
formance degradation due to the payload of a large number
of concurrent requests. Without adaptation to the increased
load, the response time and failure rate of order processing
could increase, resulting in customer dissatisfaction.
Now consider the following two adaptation scenarios.
Scenario A : Jack, the chief architect of the technical de-
partment, is notied of the problem and nds out that the
bottleneck lies in the order verication process, which has
been implemented by several components including order
information checking, credit checking and fraud checking.
After reconsidering the design decisions of the current ar-
chitecture, Jack decides to adapt the interaction structure
of the order checking components from sequential to paral-
lel processing for a better performance. This architectural
adaptation resolves the problem and the whole adaptation
process is made transparent to the business department.
Scenario B : Jack is notied and reconsiders the design
decisions but cannot nd any architectural design alterna-
tive to alleviate the problem. He raises the problem as an
issue to Bob, the manager of the business department. After
reconsidering the business decisions that led to the currentrequirements specication, Bob decides to adapt the order
verication process to involve only order information and
credit checking, and skip fraud checking, even though he is
aware of the potential loss due to higher risks. This business
adaptation may help accelerate the order processing process
at the cost of a higher risk of malicious orders. Following this
business requirement change, Jack can adapt the technical
architecture accordingly. To this end, Jack rst identies the
components that are inuenced by this requirement change,
and then removes the components that were introduced for
the eliminated functionalities. Since the implementation of
a requirement may be scattered across dierent parts of the
architecture, such architectural adaptations often crosscut
multiple architectural elements.
The above analogy of the business and technical depart-
ments helps explain the following two observations. First,
runtime adaptations often involve both requirements and ar-
chitectural decisions where dierent concerns (e.g., business
versus technical) require dierent knowledge (e.g., require-
ments versus architectural design). Second, mappings from
requirements to architecture are non-trivial, which involves
complex traceability from requirements to architectural ele-
ments and architects' knowledge about design decisions.
Model-based self-adaptation can thus be regarded as an
automation of these adaptation processes at runtime, based
on the runtime representations of requirements and archi-
tectural design knowledge.
3. PRELIMINARIES
This section briey introduces the preliminaries, i.e. goal-
oriented requirements and architectural design decisions.
3.1 Goal-Oriented Requirements
In goal-oriented requirements analysis, typically functional
requirements are modelled as hard goals , and quality require-
ments are modelled as softgoals [33]. A preference is speci-
ed for each softgoal to indicate its relative importance [30].
Goals can be rened into subgoals through AND/OR de-
composition links until the leaves of the decomposition hier-
archy as tasks that can be accomplished by either software
or human agents. To satisfy an AND/OR-decomposed goal,
all/at least one of its subgoals must be satised. Further-
more, goals can relate to each other through the weighted
contribution links w+ and w where the normalized weight
wis in the range of [0 ;1] [24]. A + or sign indicates re-
spectively that the satisfaction of the source goal contributes
tow-level satisfaction or denial of the target goal.
The top part of Figure 1 presents the requirements goal
model of a simplied online shopping system as a graph. The
system is used as a running example throughout the paper.
In this graph, hard goals, softgoals and tasks are syntacti-
cally shaped as rounded rectangles, clouds and hexagons,
respectively. The semantics of the model are illustrated
as follows. The goal Order be strictly verified is sat-
ised if all of its AND-decomposed subgoals Check info ,
Check credit and Check fraud are satised. The goal Or-
der be verified can be satised by any one of the two
OR-decomposed subgoals Order be simply verified and
Order be strictly verified .
3.2 Architectural Design Decisions
Architectural design decisions manifest themselves in the
system's architecture for assuring the satisfaction of the sys-677Productsbesold
Orderbe
verifiedAND
AND
t7Check
infoORAND
Orderbestrictly
verifiedt6Pay
order
0.9+0.8-Orderbe
checkedout
ANDProductbe
chosen
t1Search
productt4Add
tocart
t2Viewin
multimediaANDANDAND
t5Place
orderAND
ANDSecurity
behigh
t9Check
fraudAND
Risk
belowCostbe
lowAND
AND
t0Log
0.9+0.5+
0.6-0.8-
Performance
behigh
LoggingOrder
verification
Sequential ParallelPayment
protocol
Synchro
nousAsynch
ronousPartialFullCheck
responsebe
quick
0.6+0.5-0.5-
0.7+0.8-
0.6+ 0.8+0.6-Orderbesimply
verified
t8Check
creditOR
ANDAND
0.8-0.9+
StrictStrict
verification
SimpleSimple
verificationPayment
responsebe
quickResources
below
[requestCurrency>90]MM
Viewing
MMTextualDetailsbe
viewed
t3View
intextOROR
Textual
ViewingUsability
begoodBrowse
responsebe
quick0.8+0.7-
0.7-0.7+ANDFigure 1: Requirements goal model and design decisions of a simplied online shopping system
AdaptedGoal
SpecificationAdaptationRequest
[QualityExpectations]
ModelTransformation
ScriptsRequirements
GoalModelRequirements
AdaptationManager
RequirementsLayer
ArchitectureLayer
Design
DecisionsModelDesignDecisions
AdaptationManager
Architecture
TransformerTransformation
GeneratorAdaptedDesign
Solution
Running
SystemRuntimeArchitecture
ModeliRuntimeArchitecture
Modeli+1CurrentModel AdaptedModel
Execution
EngineAnalyzer
EngineAdaptationRequest
[QualityExpectations,
ContextValues]
Runtime
DataReconfigurationsPlanner
Figure 2: Overview of our approach.
tem's quality and business requirements [14]. Every decision
has one issue describing the problem and some options de-
scribing the alternative solutions. Each option has some
applicable contexts that have to be met for the option to be
considered, some pros and cons for the quality requirements
to record its impact on them, and some architectural modi-
cations to realize the solution in the architecture [25]. For
instance, to realize order payment in online shopping, dif-
ferent message protocols such as asynchronous protocol or
synchronous protocol can be used. The former has a quicker
response but needs more resources than the latter. However,
due to its complexity, asynchronous protocol is considered
only when the message concurrency is high.
4. OUR APPROACH
After an overview of our approach (Figure 2), this sec-
tion introduces the adaptations of requirements and design
decisions, and the generated architecture transformations.
4.1 The Overall Framework
Following the MAPE-K (Monitor, Analyze, Plan, Execute-
Knowledge) control loop [26], our framework consists of an
Analyzer Engine , aPlanner and an Execution Engine . Thiscontrol loop is periodically executed. Specically, the An-
alyzer Engine aggregates quality values and context values
based on the collected data during runtime monitoring. Us-
ing the aggregated and expected quality values, it tunes
the expectations of quality requirements through a feedback
controller proposed in our earlier work [36]. Expectations 2
[-1, 1] are used to indicate the expected satisfaction levels
of quality requirements, which are dierent under dierent
situations and thus need to be tuned. The expected qual-
ity values can be specied in advance or updated at runtime
(e.g., by taking the average of the last nmonitored samples).
The Design Decisions Adaptation Manager searches for
the optimal design solution as a set of design options that
best satisfy a given set of requirements and contexts using
the design decisions model. If such a solution can be found,
theTransformation Generator generates the model trans-
formation scripts in QVT-R that incrementally transform
the current runtime architecture model into an adapted one
through the Architecture Transformer . On the other hand,
if such a solution cannot be found, the Requirements Adap-
tation Manager is responsible for selecting the optimal goal
specication as a set of tasks that best meet the quality ex-
pectations. No adaptation will be performed when no such
goal specication can be found.
The Execution Engine recongures the running system ac-
cording to the dierences between the architecture models
before and after adaptations. These system recongurations
are currently supported by reective component models such
as Fractal [8] and OpenCOM [15], service-oriented adapta-
tion techniques such as AO4BPEL [9] and VxBPEL [27], or
architecture-based management middleware [40].
The steps of the self-adaptation are illustrated as follows.
1.Analyzer Engine periodically tunes quality expectations
and aggregates context values, and then raises an adap-
tation request to Design Decisions Adaptation Manager ;
2.Design Decisions Adaptation Manager tries to nd an op-
timal design solution based on the design decisions model;
3. If a solution can be found, Transformation Generator
generates the model transformation scripts, and Archi-
tecture Transformer incrementally executes them on the
current architecture model;
4. If no solution can be found, an adaptation request is
raised to Requirements Adaptation Manager , and then678it tries to nd an optimal goal specication based on the
goal model;
5. If a specication can be found, Design Decisions Adap-
tation Manager nds an optimal design solution that re-
ects the changed requirements, and triggers Step 3;
6. If no specication can be found, no adaptation is needed,
which means that the current goal specication and de-
sign solution are already optimal;
7.Execution Engine recongures the running system based
on the dierences between the current and adapted ar-
chitecture models.
Depending on the dierent possible outcomes, there can be
three adaptation loops 1-2-3-7, 1-2-4-5-7, and 1-2-4-6, cor-
responding to successful architectural adaptation, success-
ful requirements adaptation, and no adaptation respectively.
Although it is also possible to directly raise an adaptation
request to Requirements Adaptation Manager , i.e. 1-4-5-7,
which could have bypassed the architectural adaptation in
step 2, we do not choose that path because most of ne-
grained adaptations could already be handled transparently
to the xed requirements through architectural adaptation.
To apply our approach, application-specic Analyzer En-
gine and Execution Engine are plugged in respectively to
obtain quality values and context values, and to achieve ac-
tual system recongurations. As an input, three application-
specic models; i.e., a goal model, a design decisions model
and an initial architecture model, are required.
4.2 Requirements Adaptations
We use requirements goal models as the business abstrac-
tion of a running system. Goal models capture the space of
alternative specications (i.e. a set of leaf-level tasks) satis-
fying high-level goals in the form of OR-decompositions. For
instance, there are 4 possible goal specications for satisfy-
ingProducts be sold in Figure 1. Further, each goal spec-
ication is often better in satisfying certain quality require-
ments but worse in satisfying some others. For instance, one
possible goal specication GSis [t0; t1; t2; t4; t5; t6; t7; t8; t9]
in Figure 1, and it is better in Usability be good (+0.91)
and Risk be low (+0.9) but worse in Browse response be
quick ( 0.8) and Check response be quick ( 0.8).
The Requirements Adaptation Manager focuses on business-
driven decisions, and receives an adaptation request only if
no design solution can be found. If requested, it will per-
form a goal reasoning process, which takes as input the goal
model and the tuned quality expectations, and nds among
all the possible goal specications the optimal one that best
satises the quality expectations.
Traditionally the optimal goal specication is the one with
the highest weighted sum of the satisfaction levels of all soft-
goals [47]. This strategy tries to achieve the overall quality
satisfaction as high as possible. As a result, some poorly-
satised softgoals will be hidden under the well-satised
ones, and it is unknown if these hidden softgoals meet their
expectations. Therefore, here we adopt another strategy,
which tries to meet as many softgoals' expectations as pos-
sible. In detail, we compute for each softgoal a satisfaction
delta, which is the dierence between its satisfaction level
and its expectation. A positive/negative satisfaction delta
means a softgoal does/does not meet its expectation. Then
1+/ indicates the negative/positive satisfaction level cal-
culated by label propagation algorithms [24]
Design
IssueDesign
Option1..*
1
Architectural
ModificationIntention Softgoal
11..*
Dependency
LinkImpact
LinkMotivation
Link1..**
0..* 0..*Hard
GoalTask
Interference
Link0..*0..*
Context10..** *Figure 3: Metamodel of design decisions.
we compute for each goal specication a weighted sum of the
negative satisfaction deltas (i.e. NScore ) and a weighted
sum of the positive satisfaction deltas (i.e. PScore ). Fi-
nally, the goal specication with the highest NScore is the
optimal one that best satises the expectations; if multiple
goal specications have the same highest NScore , one of
them that has the highest PScore is the optimal one.
For instance, if the expectations for Browse response be
quick ,Usability be good ,Check response be quick and
Risk be low are respectively 0.2, +0.6, 0.2 and +0.6,
their satisfaction deltas with goal specication GSare re-
spectively ( 0.8) ( 0.2) = 0.6, (+0.9) (+0.6) = 0.3,
( 0.8) ( 0.2) = 0.6 and (+0.9) (+0.6) = 0.3. If the
preferences for all softgoals are specied to 5, NScore is 5
( 0.6) + 5( 0.6) = 6.0, and PScore is 50.3 +
50.3 = 3.0. Given these quality preferences and expec-
tations, GSis actually the optimal goal specication, which
congures the OR-decomposed goals (i.e. business-driven
decisions) Details be viewed and Order be verified to
View in multimedia and Order be strictly verified .
In general, of course, our approach is independent of the
choice of such strategies. Specic strategies can be inte-
grated according to specic adaptation objectives.
4.3 Design Decisions Adaptations
We introduce an architectural design decisions model to
capture system architectural design and its candidate solu-
tions. Figure 3 shows the metamodel of architectural design
decisions we adopted. For a design decision, a design issue
is related to certain requirements ( intentions , which can be
hard goals, softgoals or tasks [48]) through motivation links
to indicate its motivation (i.e. to solve what problem or to
meet what requirements), and has multiple design options
for solving the problem or meeting the requirements. Multi-
ple design issues can be motivated by multiple requirements.
In addition, a design option has some applicable contexts for
the option to be considered, contributes to certain quality
requirements ( softgoals ) positively or negatively by impact
links, and has some architectural modications to realize at
the architectural level.
The bottom part of Figure 1 shows the design decisions
of the simplied online shopping system. Design issues and
options are visually shaped as octagons and ellipses respec-
tively. The issue Logging (i.e. what interactions should be
logged) is to meet task Log. Its option Full (i.e. log all
interactions) has a higher positive impact to softgoal Secu-
rity be high but also a higher negative impact to softgoal
Performance be high than option Partial (i.e. only log
database interactions). The issue Payment protocol is to
meet task Pay order . Its options Synchronous and Asyn-679Order
verification
Sequential ParallelTextual
viewing
Textual FullMM
viewing
MMLogging
PartialAsynchr
onousPayment
protocol
Synchro
nous
Strict
verification S
StrictSSimple
verification S
SimpleSStrict
verification P
StrictPSimple
verification P
SimpleP[requestCurrency>90]Figure 4: Design decisions model of the simplied
online shopping system.
chronous have reverse impacts to softgoals Resources be
lowand Payment response be quick . The applicable con-
text of option Asynchronous is when the request currency
is larger than 90. The issue Order verification (i.e. what
structure can be used to perform order information check-
ing, customer credit checking and fraud checking) is to meet
goal Order be verified . Its options Sequential and Par-
allel have reverse impacts to softgoals Cost be low and
Check response be quick .
Furthermore, design decisions are often intertwined and
crosscutting with each other [25] with respect to the decision-
making process and architectural modication process. To
model such relationships, we introduce dependency and in-
terference links to relate design issues and options. Depen-
dency links indicate that only if a set of design decisions
are made together can the structure or behavior of certain
part of a system be determined. For instance, issues Order
verification ,Simple verification and Strict verifi-
cation have to work together to determine the behavior
and structure of order verication. Interference links ex-
press the interferences among dierent design options when
performing their architectural modications, which will be
introduced in Section 4.4.2.
To represent such intertwined design decisions and facili-
tate their decision-making process, we model them in deci-
sion trees. Figure 4 gives the design decisions model of the
simplied online shopping system with each decision tree
representing a set of intertwined design decisions. Subscripts
are used to dierentiate the design options with the same
name but dierent architectural modications under dier-
ent decision-making process. For instance, following the dif-
ferent options of Order verification , options Strict Sor
Strict Pwill result in architectural modications that re-
spectively structure the checking components to sequential
or parallel processing. For clarity, we only show the de-
pendency links (lines with an arrow) in Figure 4, and omit
the motivation and contribution links that are shown in Fig-
ure 1. For the pairs of issues Textual viewing andMM view-
ing, and Simple verification and Strict verification ,
only one of them will be considered in the decision-making
process because they are exclusive to each other from the
requirements perspective. Hence, Figure 4 shows the deci-
sion trees reecting the goal specication GSby indicating
the decisions that should not be considered by dashed lines.
Through motivation and impact links, the gap between re-
quirements and architectural designs are narrowed. On the
one hand, following motivation links, requirements changes
Architecture
Model
ElementElement
TypeConnector
TypeComponent
Type
Component Connector
Parameter InterfaceProvided
InterfaceRequired
InterfaceStructure
Link1..*
1..**
* 1 1
* 1..*
1 1Figure 5: Metamodel of component-based architec-
ture model.
(i.e. a new goal specication) will inuence the set of de-
sign decisions that need consideration. For instance, if goal
Details be viewed is recongured from View in text to
View in multimedia , issue Textual viewing will not be
considered while issue MM viewing should be considered.
On the other hand, using impact links sourced from design
options to quality requirements, tuned quality expectations
and monitored context values, the Design Decisions Adap-
tation Manager nds among all design solutions the optimal
one, i.e. a set of design options that meet their applica-
ble contexts and have the highest NScore as introduced in
Section 4.2. For instance, given the goal specication GS, if
expectations for Performance be high ,Security be high ,
Resources be low ,Payment response be quick ,Cost be
lowand Check response be quick are respectively +0.6,
 0.2, +0.6, 0.2, +0.6 and 0.2, preferences for them are
all specied to 5, and option Asynchronous does not satisfy
its applicable context, then the optimal design solution DS
is [Partial ,Synchronous ,MM,Sequential ,Strict S] with
NScore being 10.5 and PScore being 3.5.
4.4 Architecture Transformations
To realize the changes of design solutions into the architec-
ture, we propose a set of primitive adaptation operations to
express the architectural modication of each design option,
and then introduce the incremental and generative model
transformations to execute the architectural modications.
4.4.1 Expressing Architectural Adaptations
We use component-based architecture models as the de-
sign abstraction of the running system. Figure 5 gives the
metamodel of architecture model we adopted. Components
(i.e. computational elements and data stores) and connec-
tors(i.e. interactions between components) are respectively
instances of component andconnector types that express the
common behaviors. They have provided interfaces to specify
the services they oer, and/or required interfaces to specify
the services they need, and can have parameters to express
their changeable characteristics. A linkis a connection from
a required interface to a provided interface. In addition, this
metamodel could be extended to include application-specic
properties for components and connectors.
Figure 6 shows the component-based architecture model
of the simplied online shopping system manifesting the de-
sign solution DS. Components, connectors, provided and re-
quired interfaces are visually shaped as rectangles, rounded
rectangles, solid and hollow circles respectively. Compo-
nents Logger are only connected to database-related com-
ponents Product and Order . Products details are viewed in
multimedia mode through connector getProdDetMM . Order
payment is realized using synchronous protocol. Order veri-680ckInfoffckInfogetCart
ListgetCart
ListsetPaidsetPaidplaceOr
derplaceOr
deraddProd
ToCartaddProd
ToCartgetProd
DetMMgetProd
DetMMgetProd
ListgetProd
ListpayOrd
erSynpayOrd
erSynsearchP
rodsearchP
rodMain
Product CartSearch
Order
Credit
checkFraud
checkSyn
payment
Info
checkckCreditckCredit ckFraudckFraudLoggerloglog Logger oglogFigure 6: Architecture model of the simplied online
shopping system.
cation is performed in sequential structure. And we extend
components by including the property dbRelated to indicate
whether or not a component is database-related.
Based on this metamodel, we propose a set of primitive
adaptation operations to express the architectural modica-
tion of each design option. These primitive adaptation oper-
ations are parsed to generate model transformation scripts
as will be shown in Section 4.4.2. These operations include
create (component | connector) id name type ...
(interface id name type )+
(parameter id name type value )*
(when (component | connector) condition )?
create link id name interface interface
(when (component | connector) condition )?
remove (component | connector | link)
when condition
tune parameter value when condition
with +,*and ?respectively indicate there is one or more,
zero or more, and zero or one of the preceding element.
For component/connector creation, default properties (e.g.,
id), extended properties (e.g., dbRelated ), its provided or re-
quired interfaces , and its parameters should be specied. For
link creation, properties such as id,name ,required interface
and provided interface should be specied. These creation
operations can also specify a crosscutting object (either com-
ponent or connector ) and a crosscutting condition to indicate
that these operations are performed for every component or
connector that satises the condition.
Removal operations should specify the satisfying condition
of the to-be-removed component(s)/connector(s)/link(s). Pa-
rameter tuning operation should specied the new value and
the satisfying condition of the to-be-tuned parameter(s).
The condition can be expressed by operators such as =,<>,
>,<,>=and<=on the properties of components, connectors,
links or parameters. Besides, composite conditions are also
supported by using andand or.
With these operations, complex architectural adaptations
can be expressed by combinations. We associate each design
option with adaptation and revocation architectural modi-
cations. The former indicates the modication (e.g., create
a component) when the option is selected and the latter in-
dicates the modication (e.g., remove a component) when
the option is deselected.
For instance, the adaptation architectural modication for
design option Full is shown as follows. For every componentthat is neither a logger nor a database-related component,
it rst creates a logger component, a logger connector and
two links to connect them.
create component logComp logComp logCompT false
interface logIntfL logIntf provided
when component type <>`logCompT' anddbRelated = false
create connector logConn logConn logConnT
interface logIntf R logIntf required
interface logIntf P logIntf provided
when component type <>`logCompT' anddbRelated = false
create link logLinkS logLinkS null logIntf P
when component type <>`logCompT' anddbRelated = false
create link logLinkT logLinkT logIntf R logIntfL
when component type <>`logCompT' anddbRelated = false
The property required interface of the rst link is set to
null, which should be the crosscut components' required in-
terface for logging. However, we cannot specify them here
because there are multiple crosscut components. To solve
this problem, we assume that one link's required and pro-
vided interfaces have the same interface name so that the Ar-
chitecture Transformer will nd this interface in the crosscut
components according to the interface name when perform-
ing model transformations.
Besides, its corresponding revocation architectural modi-
cation is shown as follows. It removes the previously created
components and connectors. The previously created links
will be automatically removed because their referenced in-
terfaces are removed with the components and connectors.
remove component when name =`logComp'
remove connector when name =`logConn'
4.4.2 Executing Architectural Adaptations
The architectural modications of design options may af-
fect the same part of the architecture and thus produce inter-
ferences. For instance, if option Full has been realized in the
architecture, and there happens a switch from option Syn-
chronous to option Asynchronous , the newly created com-
ponent Asyn payment will not be linked to a logger connec-
tor because option Asynchronous is not aware of the archi-
tectural modication of option Full and vice versa. To com-
pensate such interferences, the revocation and adaptation
architectural modication of Full should be re-performed
sequentially. Therefore, we introduce interference links to
indicate such a relationship in order to facilitate the transfor-
mation process. In the online shopping system, there exist
interference links sourced from Synchronous ,Asynchronous ,
Strict andSimple toFull. These interference links can be
manually constructed at design time by architects.
To ensure consistency, save eorts and reduce errors, we
use model transformations to automate the modications of
architecture models. Besides, we use QVT-R as the language
for model transformations since it is expressive enough, it is
a standard dened by Object Management Group (OMG),
and it is the most widely used declarative language to spec-
ify the relation between two models. Furthermore, we use
mediniQVT [2] to execute model transformations because it
implements OMG's QVT-R standard.
Specically, the Transformation Generator is implemented
by using the Java template engine FreeMarker [1]. It takes
as input a new design solution and returns a set of ordered
QVT-R scripts. The generator rst makes a copy of the681top relation  M2M {
  varId, varName : String;
  enforce domain  source sM : am::ArchitectureModel {
    id = varId, name = varName
  };
  enforce domain  target tM : am::ArchitectureModel {
    id = varId, name = varName
    ...
    -- template of creating links
    <#if linkList?? && linkList?size != 0>
    <#list linkList as link>
    ,structure = ${"tLink" + link_index} : am::Link {
      parent = tM, id = '${link.id}', name = '${link.name}',
      interface1 = ${"tIntf1" + link_index} : am::RequiredInterface {
        id='${link.interface1.id}' },
      interface2 = ${"tIntf2" + link_index} : am::ProvidedInterface {
        id='${link.interface2.id}' }
    }
    </#list>
    </#if>
    ...
  };
}
top relation  M2M {
  varId, varName : String;
  enforce domain  source sM : am::ArchitectureModel {
    id = varId, name = varName
  };
  enforce domain  target tM : am::ArchitectureModel {
    id = varId, name = varName
    ...
    ,structure = tLink0 : am::Link {
      parent = tM, id = 'payAsynLinkT', name = 'payAsynLinkT',
      interface1 = tIntf10 : am::RequiredInterface {
        id = 'payAsynIntf_R' },
      interface2 = tIntf20 : am::ProvidedInterface {
        id = 'payAsynIntfA' }
    }
    ...
  };
}(a)
(b)Figure 7: A relation in QVT-R: (a) a template of
creating links, (b) a script of create a link.
old/new design solution, and avoids redundant architectural
modications by removing their same design options satis-
fying condition Cthat the design option is not the target
of an interference link, or is the target of an interference
link but its source is not in the design solution. This condi-
tion is to avoid the negative eect of interference on model
transformations. Then it has an iterative step to parse the
revocation/adaptation architectural modication of design
options, satisfying C, in the old/new design solution to gen-
erate a QVT-R script based on a template and remove corre-
sponding design options until all design options are removed.
Finally, it saves the new design solution to the old one.
For instance, DS1 and DS2 are respectively the old and
new design solutions. First, the options with a strike-through
line are the same options and thus are removed. Then, the
options with a straight underline are the rst set of options
satisfying c. Finally, the options with a wave underline are
the second set of options satisfying c. Therefore, two QVT-
R scripts are generated. Figure 7 (a) shows a template of
creating links in a relation that copies the idandname of an
architecture model, and Figure 7 (b) gives part of the rst
generated script that adds a link between a connector and
a component for asynchronous payment.
DS1 [::::Full,Synchronous ,Textual ,Sequential ,Strict S]
DS2 [::::Full,Asynchronous ,MM,Sequential ,Simple S]
The Architecture Transformer is implemented by using
the model transformation tool mediniQVT [2]. It takes as
input the generated QVT-R scripts and the current architec-
ture model, and returns an adapted architecture model. The
scripts are executed incrementally in the order as they are
generated: the rst script is executed on the given architec-
ture model, and then the following scripts are executed on
the transformed architecture model of the previous script.
vrfOffrde
rParvrfOrde
rPargetCart
ListgetCart
ListsetPaidsetPaidplaceOr
derplaceOr
deraddProd
ToCartaddProd
ToCartgetProd
DetTgetProd
DetTgetProd
ListgetProd
ListpayOrd
erAsynpayOrd
erAsynsearchP
rodsearchP
rodMain
Product CartSearch
OrderAsyn
payment
Credit
checkInfo
checkLoggerloglog Logger loglogFigure 8: Architecture model after adaptation (the
dashed rectangles indicate the modications).
For instance, Figure 8 shows the architecture model after
performing the 1-2-4-5-7 adaptation loop on Figure 6. The
requirements adaptations include switching from multime-
dia mode and strict verication to textual mode and sim-
ple verication, and the architectural adaptations include
changing synchronous payment and sequential verication
to asynchronous payment and parallel verication.
5. CASE STUDY
To evaluate the proposed approach, we conducted a case
study to answer the following two questions:
Q1: Can improvements be achieved by combining re-
quirements and architectural adaptations? (Section 5.2)
Q2: Can the approach scale with the growth of re-
quirements and architecture models? (Section 5.3)
5.1 Experimental Setup
Stress testing tool JMeter was used to simulate concurrent
accesses and Badboy was used to record the test plan. The
experiments were conducted on a ThinkPad E430c laptop
with Intel Core i3 2.40 GHz processor and 4GB RAM.
The experiments were conducted on the online shopping
benchmark, which is implemented in Java. Its requirements
and architectural design decisions are illustrated in Figure 1
and Figure 4. The preferences for the softgoals in Figure 1
were all specied to 5, and the initial expectations for soft-
goals Security be high ,Performance be high ,Usability
be good ,Browse response be quick ,Cost be low ,Risk
be low ,Check response be quick ,Resources be low and
Payment response be quick were respectively set to +0.6,
 0.2, +0.6, 0.2, +0.6, +0.6,  0.2, +0.6 and 0.2, and
such tradeos have to be made because soft goals often can-
not be all fully satised. The system was initially congured
to the design solution [Full ,Synchronous ,MM,Sequential ,
Strict S]that best satises these quality expectations.
The system workload varied in the experiments as fol-
lows to simulate dynamic environments. The workload rst
increased from zero users to 100 concurrent users in 10 min-
utes, i.e. adding a user every 6 seconds; then held for 4 min-
utes; nally decreased back to zero users in 10 minutes, i.e.
removing a user every 6 seconds. The adaptation interval
was set to one minute; i.e., the adaptation mechanism was
periodically performed every one minute, which is enough
for the adaptation process in this case study. For other ap-
plications, the interval should be accordingly specied.
In the experiments, the quality values such as performance
(i.e. the time taken to process a request), browse response,682020 40 60 80 100 120 140 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Throughput (#/min) 
Time (min) Static 
Req 
Arch 
ReqArch Full Û€ Partial Partial Û€ Full Sequential Û€ Parallel   MM Û€ Textual 
Strict Û€ Simple 
Synchronous Û€  
Asynchronsous Asynchronous Û€  
Synchronsous Textual Û€ MM 
  Simple Û€ Strict 
Strict Û€ Simple 
Simple Û€ Strict 
Parallel Û€ Sequential 
Full Û€ Partial Partial Û€ Full Sequential Û€ Parallel 
Synchronous Û€  
Asynchronsous Asynchronous Û€  
Synchronsous Parallel Û€ Sequential 
Simple Û€ Strict   MM Û€ Textual 
Strict Û€ Simple Textual Û€ MM Figure 9: The adaptation process of the approaches with self-adaptation.
payment response, check response, and cost (i.e. the money
paid to verify an order) were obtained by system log analysis,
and resources (i.e. the memory consumed to complete an
order payment) were measured by memory analysis.
However, to measure security, risk and usability, it often
involves complex security analysis, risk analysis and cus-
tomer feedback analysis. To simulate such real-life analysis,
for simplicity, here we assumed that security was a random
value between 88% and 92% with full logging and between
83% and 87% with partial logging since full logging can of-
ten achieve a higher security than partial logging. Similarly,
risk was a random value between 9% and 13% with strict
verication and between 14% and 18% with simple veri-
cation; and usability was a random value between 89% and
93% with multimedia mode and between 84% and 88% with
textual mode. Such ranges of values were specied by the
domain experts according to their experience.
For each of the following four approaches, we conducted
the experiments using the same experimental settings.
Static : the approach without self-adaptation
Req: the requirements-driven self-adaptation approach
Arch : the architecture-based self-adaptation approach
ReqArch : the proposed self-adaptation approach
Specically, Req only involves the proposed requirements
adaptations and architectural adaptations are simply mapped
to architectural elements. Arch assumes a static goal spec-
ication and only involves the proposed architectural adap-
tations.
5.2 Effectiveness Evaluation (Q1)
To compare the eectiveness of dierent approaches, we
measured the system throughput (i.e. the successfully n-
ished orders in one minute), which is the key performance
indicator of this application. The higher the overall through-
put, the more eective the adaptation is considered to be.
Figure 9 shows the adaptation process of the self-adapta-
tion approaches ( Req,Arch andReqArch ) to visually il-
lustrate the dierences of our approach from requirements-
driven and architecture-based approaches. In Figure 9, the
Xaxis denotes time intervals of one minute and the Yaxis
denotes system throughput in each time interval. The adap-
tations generated by each approach are respectively marked
on the curves.
ForStatic , it can be observed that the system suered a
throughput loss when the workload increased to 60 concur-
rent users at time 6, and continuously had a low throughputuntil the workload decreased to 30 concurrent users at time
22. This is because the system suered performance degra-
dation due to the increasing workload.
ForReq, the system also suered a throughput loss at
time 6 when check response and browse response were very
slow. Unlike Static ,Req increased the expectations of
check response and browse response, and thus recongur-
ing the system from multimedia mode and strict order veri-
cation to textual mode and simple order verication for a
better response. As a result, Req achieved a higher through-
put than Static at the following time, but risk and usability
were low achieving and their expectations were increased.
When the workload decreased to 80 concurrent users, check
response and browse response got better and their expec-
tations were decreased. As a result, Req recongured the
system to strict order verication and multimedia mode at
time 17 and 18.
ForArch , the system suered a performance degradation
at time 4, which was not handled in the case of Req since
the solution was out of the business-level adaptation space.
ButArch recongured the system from full logging to par-
tial logging for a better performance at the price of security.
After a time interval, Arch recongured the system back to
full logging because security was now more expected than
performance. At time 6, check response was very slow, and
Arch increased its expectation, and thus reconguring the
system from sequential verication to parallel verication.
At time 10, the applicable context of asynchronous payment
was satised and the expectation of payment response was
increased, and thus Arch recongured the system to asyn-
chronous payment. When the workload decreased, Arch
recongured the system back to synchronous payment and
sequential verication at time 16 and 18. It can be seen
thatArch achieved a higher throughput than Static but a
lower throughput than Req from time 8, which means that
in this case the solutions in the design-level adaptation space
is less eective in terms of throughput than the ones in the
business-level adaptation space.
ForReqArch , when design-level adaptation is not enough,
business-level adaptation is involved; e.g., at time 7, 18, 19
and 20. As a result, as visually shown in Figure 9 and nu-
merically shown in Figure 10, ReqArch achieved the high-
est maximum and average throughput. This shows that by
combining requirements and architectural adaptations, our
approach is promising to oer more adaptation exibility
and further improve the eectiveness of adaptation.683Table 1: Average results of the four approaches in terms of quality values.
App. Sec. (%) Per. (ms) Usa. (%) bRe. (ms) Risk (%) Cost ($) cRe. (ms) Reso. (B) pRe. (ms)
Static 89.99 1451.92 91.01 3721.98 11.02 0.34 4473.24 449.98 3797.45
Req 90.03 915.13 88.50 1877.36 13.29 0.32 2657.14 450.06 2036.87
Arch 89.78 888.28 90.98 2052.48 10.98 0.34 2919.15 462.44 2282.54
ReqArch 89.81 682.46 88.73 1477.01 13.49 0.32 2103.00 462.49 1466.79
Static Req Arch ReqArch 
Max 89 96 110 115 
Min 8 7 7 8
Avg 51 65 62 72 020 40 60 80 100 120 Throughput (#/min) 
Figure 10: Throughput of the four approaches.
In addition, Table 1 reports the average results of quality
values per interval of the four approaches. Columns 2{10
respectively list the results of security, performance, usabil-
ity, browse response, risk, cost, check response, resources
and payment response. It can be observed that, compared
with the other three approaches, our approach was better in
performance-related quality dimensions but worse in others.
In other words, with the changing workload, our approach
can achieve a better performance, which is always expected
under high workload to improve throughput, with the ac-
ceptable sacrice of other quality dimensions.
In summary, the observations from Table 1 and Figure 9
and 10 answer Q1positively that our approach is promising
to further improve the eectiveness of adaptation in terms of
system throughput in this case study and oer more adap-
tation exibility than requirements-driven or architecture-
based self-adaptation approaches with acceptable sacrice
of less expected quality dimensions.
5.3 Performance Evaluation (Q2)
The performance of our approach is determined by Re-
quirements Adaptation Manager ,Design Decisions Adapta-
tion Manager ,Transformation Generator and Architecture
Transformer , whose time complexities are respectively ex-
ponential time with the size of OR-decomposed goals, ex-
ponential time with the size of design decisions, linear time
with the size of primitive adaptation operations and linear
time with the size of architecture model.
We conducted a set of experiments to evaluate the perfor-
mance of our approach. Table 2 reports the experiment re-
sults. The rst, third, fth and seventh columns respectively
list the size of OR-decomposed goals, design decisions, prim-
itive adaptation operations and architecture model. And the
other columns list the performance in milliseconds.
The Requirements Adaptation Manager takes around 1.1
seconds on the goal model with 18 OR-decomposed goals
(with 46656 goal specications), which is feasible in our ap-
proach, and returns an\out of memory"error when the num-
ber of OR-decomposed goals climbs to 24 (with 1679616 goal
specications). The Design Decisions Adaptation Manager
takes around 3.7 seconds on the design decisions model withTable 2: Performance of our approach.
RAM DDAM TG AT
OR(#) P.(ms) DD(#) P.(ms) Op.(#) P.(ms) AM(#) P.(ms)
3 1 5 1 200 79 150 163
6 2 7 15 400 92 300 224
9 24 9 31 600 105 450 315
12 78 11 78 800 114 600 400
15 203 13 202 1000 120 750 600
18 1108 15 577 1200 125 900 702
21 22480 17 3620 1400 131 1050 977
24 out 19 out 1600 136 1200 1249
17 design decisions (with 131072 design solutions), which is
feasible in our approach, and returns an \out of memory" er-
ror with 19 design decisions (with 524388 design solutions).
The Transformation Generator takes less than 0.2 seconds
with 1600 primitive adaptation operations, and the Architec-
ture Transformer takes around 1.3 seconds with 1200 archi-
tectural elements. The above analysis answers Q2positively
that our approach scales well with the growth of models and
can be applied to real-life medium-sized software systems.
6. RELATED WORK
Instead of enumerating the related work in the area of
self-adaptive systems, we refer readers to [12] and [29] for an
introduction to the state-of-the-art. Here we only discuss the
most related studies in three areas: requirements-driven self-
adaptation, architecture-based self-adaptation, and earlier
work that combines them.
6.1 Requirements-Driven Self-Adaptation
Approaches have been proposed to use requirements mod-
els as the knowledge for self-adaptation. Dalpiaz et al. [16]
propose a conceptual architecture that provides systems with
self-reconguration capabilities. Wang et al. [47] propose a
requirements monitoring and diagnosing framework to pro-
vide systems with self-repairing capabilities. Elkhodary et
al. [18] propose a feature-oriented self-adaptation framework
FUSION that can learn the impact of adaptation decisions.
Baresi et al. [6] present FLAGS to facilitate requirements-
driven adaptations. Peng et al. [36] propose a requirements-
driven self-tuning approach through dynamic quality trade-
o and value-based feedback loop. Chen et al. [10, 11] pro-
pose requirements-driven approaches for survivability assur-
ance of Web systems and optimization of composite services.
Fu et al. [21] propose a stateful requirements monitoring
approach for self-repairing socio-technical systems. Salehie
et al. [38] propose a requirements-driven approach to sup-
port adaptive security for protecting variable assets. Souza
et al. [41] propose evolution requirements to dene possible
changes to the requirements, which can be integrated into
our approach to provide richer requirements adaptations.
These approaches assume requirements (e.g., goals or fea-
tures) can be mapped to architectural elements directly (e.g.,
components or services) and thus largely neglect the com-684plexity and details in architectural design. In contrast, our
approach introduces a design decisions model as intermedi-
ary and uses incremental and generative model transforma-
tions to implement more complex architectural adaptations.
6.2 Architecture-Based Self-Adaptation
Oreizy et al. [35] introduce the concept of architecture-
based runtime software adaptation and evolution manage-
ment. Garlan et al. [22] propose an architecture-based self-
adaptation framework Rainbow, which provides a reusable
infrastructure customizable for specic systems. Rainbow
executes system-specic adaptation strategies written in Stitch
language [13] after a violation of the invariant imposed by
the architecture model. Floch et al. [19] propose a mobility-
and adaptation-enabling middleware MADAM, which ex-
ploits architecture models for runtime adaptation of mobile
computing applications. Georgas and Taylor [23] propose
a policy-based approach to architectural adaptation man-
agement and establish the feasibility to apply the approach
to robotic architectures. Morin et al. [32] propose to use
model-level aspects to encapsulate variants and manage dy-
namic variability, and weave the corresponding aspects of
a selection of variants into a base model to produce a new
architecture model.
These approaches assume that requirements of self-adaptive
systems are well-understood at design time and unchanged
at runtime, thus are unable to support architectural adap-
tations resulting from requirements changes. Furthermore,
most of these approaches support simple architectural adap-
tations such as adding, removing or replacing components
but cannot support complex architectural adaptations such
as crosscutting adaptations and restructuring architectural
elements. The exceptions are Oreizy et al.'s restructur-
ing [35], Garlan et al.'s strategy writing [22], and Morin et
al.'s aspect weaving [32], however, these changes rely mostly
on human experts. Compared with them, our approach
further supports complex architectural adaptations such as
crosscutting and restructuring ones using model transforma-
tion techniques.
6.3 Combining Requirements and Architectural
Evolution or Adaptation
Nuseibeh [34] proposes to weave requirements and archi-
tectures for incremental software development and speedy
delivery. Sawyer et al. [39] call for combining requirements
and architectures at runtime for self-adaptive systems. Since
then, several advances have been made in this direction.
Kramer and Magee propose to combine requirements and
architectures for self-management, and propose a three-layer
reference model [28]: a goal management layer for delibera-
tive planning, a change management layer for reactive plan
execution, and a component control layer for application-
specic adaptation actions. As an instantiation, Sykes et
al. use a planning-as-model-checking technique to generate
plans [42], construct component congurations according to
the planned actions and the interface dependencies among
components [43], and choose the best one by utility func-
tions on quality properties [44]. Their approach constructs
a component conguration based on the functionality depen-
dencies, thus regarding the architectures as a set of function-
alities, neglecting the complexity of architectural design.
Tajalli et al. [45] propose a plan-based layered architec-
ture for software model-driven adaptation PLASMA, whichutilizes an architecture description language and a planning-
as-model-checking technique to enable dynamic re-planning.
It supports architectural adaptations resulting from require-
ments changes that are provided by architects at runtime.
Alferez et al. [5] propose a model-based framework that
supports the dynamic evolution of context-aware systems to
deal with unexpected context events. It uses goal and fea-
ture models to respectively represent the alternative space of
requirements and architectures. However, it also focuses on
the functionalities of the systems, and assumes each feature
can be directly mapped to an architectural element, thus
neglecting the complexity of architectural design.
Pimentel et al. [37] propose the STREAM-A approach, a
systematic process to generate architectural design models
from requirements models for adaptive systems using model
transformations. Their focus is on the design-time develop-
ment of adaptive-systems, whilst our approach focuses on
the runtime self-adaptation.
In brief, the main dierences of our approach from these
approaches are that it further treats architectures as a set of
design decisions concerning how the functionalities are struc-
tured and interact with each other, it supports both require-
ments and architectural planning, and it addresses crosscut-
ting and restructuring adaptations using model transforma-
tion techniques.
7. CONCLUSIONS AND FUTURE WORK
In this paper, we proposed a model-based self-adaptation
approach that combines requirements and architectural adap-
tations. It uses architectural design decisions models to con-
sider not only the functionalities of architectures but also
their structures and behaviors. In addition, it treats require-
ments and architectural adaptations in a layered manner and
supports crosscutting and restructuring architectural adap-
tations using incremental and generative model transforma-
tions. Our case study using an online shopping benchmark
shows promise that our approach can further improve the ef-
fectiveness of model-based self-adaptation approaches (e.g.
system throughput in this case study) and oer more adap-
tation exibility.
Currently our approach does not support adaptations re-
sulting from unanticipated changes; e.g., adding a new goal
or a new design option. A possible remedy is to provide ex-
plicit management interfaces for the administrators to up-
date relevant models at runtime. In addition, the interfer-
ence links in the design decisions model are created manu-
ally, which could be dicult to understand and maintain for
large systems. It is our future work to automate the creation
of these links. We also plan to extend our approach by sup-
porting widely-used architecture description languages (e.g.,
xADL 2.0 [17]) and supporting more model transformation
tools (e.g., MMT [3]), integrate it with architecture-based
management middleware (e.g., SM@RT [40]), and apply our
approach to more software systems to further evaluate its
eectiveness.
8. ACKNOWLEDGMENT
This work is supported by National Natural Science Foun-
dation of China under Grant No. 61361120097, National
High Technology Development 863 Program of China under
Grant No. 2013AA01A605, ERC Advanced Grant 291652 -
ASAP, and Science Foundation Ireland Grant 10/CE/I1855.6859. REFERENCES
[1] FreeMarker. http://freemarker.org/.
[2] mediniQVT. http://projects.ikv.de/qvt/wiki.
[3] MMT. http://wiki.eclipse.org/Model toModel -
Transformation -MMT.
[4] Meta Object Facility (MOF) 2.0
Query/View/Transformation Specication, v1.0, 2008.
http://www.omg.org/spec/QVT/1.0/PDF/.
[5] G. H. Alf erez and V. Pelechano. Dynamic evolution of
context-aware systems with models at runtime. In
MoDELS , pages 70{86, 2012.
[6] L. Baresi, L. Pasquale, and P. Spoletini. Fuzzy goals
for requirements-driven adaptation. In RE, pages
125{134, 2010.
[7] G. S. Blair, N. Bencomo, and R. B. France.
Models@run.time. Computer , 42(10):22{27, 2009.
[8] E. Bruneton, T. Coupaye, M. Leclercq, V. Qu ema,
and J.-B. Stefani. The FRACTAL component model
and its support in Java: Experiences with
auto-adaptive and recongurable systems. Softw.
Pract. Exper. , 36(11-12):1257{1284, 2006.
[9] A. Char and M. Mezini. AO4BPEL: An
aspect-oriented extension to BPEL. World Wide Web ,
10(3):309{344, 2007.
[10] B. Chen, X. Peng, Y. Yu, and W. Zhao. Are your sites
down? Requirements-driven self-tuning for the
survivability of Web systems. In RE, pages 219{228,
2011.
[11] B. Chen, X. Peng, Y. Yu, and W. Zhao.
Requirements-driven self-optimization of composite
services using feedback control. IEEE Trans. Services
Computing , 2014. Accepted.
[12] B. H. Cheng, R. Lemos, H. Giese, and et al. Software
engineering for self-adaptive systems: A research
roadmap. In Software Engineering for Self-Adaptive
Systems , pages 1{26. Springer-Verlag, 2009.
[13] S.-W. Cheng and D. Garlan. Stitch: A language for
architecture-based self-adaptation. J. Syst. Softw. ,
85(12):2860{2875, 2012.
[14] P. Clements, F. Bachmann, L. Bass, D. Garlan,
J. Ivers, R. Little, R. Nord, and J. Staord.
Documenting Software Architectures: Views and
Beyond . Addison-Wesley, 2002.
[15] G. Coulson, G. Blair, P. Grace, F. Taiani, A. Joolia,
K. Lee, J. Ueyama, and T. Sivaharan. A generic
component model for building systems software. ACM
Trans. Comput. Syst. , 26(1):1:1{1:42, 2008.
[16] F. Dalpiaz, P. Giorgini, and J. Mylopoulos. An
architecture for requirements-driven
self-reconguration. In CAiSE , pages 246{260, 2009.
[17] E. Dashofy, A. van der Hoek, and R. Taylor. A
highly-extensible, xml-based architecture description
language. In WICSA , pages 103{112, 2001.
[18] A. Elkhodary, N. Esfahani, and S. Malek. FUSION: A
framework for engineering self-tuning self-adaptive
software systems. In FSE, pages 7{16, 2010.
[19] J. Floch, S. Hallsteinsen, E. Stav, F. Eliassen,
K. Lund, and E. Gjorven. Using architecture models
for runtime adaptability. IEEE Softw. , 23(2):62{70,
2006.
[20] R. France and B. Rumpe. Model-driven developmentof complex software: A research roadmap. In FOSE ,
pages 37{54, 2007.
[21] L. Fu, X. Peng, Y. Yu, J. Mylopoulos, and W. Zhao.
Stateful requirements monitoring for self-repairing
socio-technical systems. In RE, pages 121{130, 2012.
[22] D. Garlan, S.-W. Cheng, A.-C. Huang, B. Schmerl,
and P. Steenkiste. Rainbow: Architecture-based
self-adaptation with reusable infrastructure.
Computer , 37(10):46{54, 2004.
[23] J. C. Georgas and R. N. Taylor. Policy-based
self-adaptive architectures: a feasibility study in the
robotics domain. In SEAMS , pages 105{112, 2008.
[24] P. Giorgini, J. Mylopoulos, E. Nicchiarelli, and
R. Sebastiani. Reasoning with goal models. In ER,
pages 167{181, 2002.
[25] A. Jansen and J. Bosch. Software architecture as a set
of architectural design decisions. In WICSA , pages
109{120, 2005.
[26] J. O. Kephart and D. M. Chess. The vision of
autonomic computing. Computer , 36(1):41{50, 2003.
[27] M. Koning, C.-a. Sun, M. Sinnema, and P. Avgeriou.
VxBPEL: Supporting variability for web services in
BPEL. Inf. Softw. Technol. , 51(2):258{269, 2009.
[28] J. Kramer and J. Magee. Self-managed systems: An
architectural challenge. In FOSE , pages 259{268, 2007.
[29] R. Lemos, H. Giese, H. M uller, and et al. Software
engineering for self-adaptive systems: A second
research roadmap. In Software Engineering for
Self-Adaptive Systems . Schloss Dagstuhl, 2011.
[30] S. Liaskos, S. A. McIlraith, S. Sohrabi, and
J. Mylopoulos. Integrating preferences into goal
models for requirements engineering. In RE, pages
135{144, 2010.
[31] B. Morin, O. Barais, J.-M. Jezequel, F. Fleurey, and
A. Solberg. Models@run.time to support dynamic
adaptation. Computer , 42(10):44{51, 2009.
[32] B. Morin, O. Barais, G. Nain, and J.-M. Jezequel.
Taming dynamically adaptive systems using models
and aspects. In ICSE , pages 122{132, 2009.
[33] J. Mylopoulos, L. Chung, and B. Nixon. Representing
and using nonfunctional requirements: A
process-oriented approach. IEEE Trans. Softw. Eng. ,
18(6):483{497, 1992.
[34] B. Nuseibeh. Weaving together requirements and
architectures. Computer , 34(3):115{117, 2001.
[35] P. Oreizy, N. Medvidovic, and R. N. Taylor.
Architecture-based runtime software evolution. In
ICSE , pages 177{186, 1998.
[36] X. Peng, B. Chen, Y. Yu, and W. Zhao. Self-tuning of
software systems through dynamic quality tradeo
and value-based feedback control loop. J. Syst. Softw. ,
85(12):2707{2719, 2012.
[37] J. Pimentel, M. Lucena, J. Castro, C. Silva, E. Santos,
and F. Alencar. Deriving software architectural
models from requirements models for adaptive
systems: the stream-a approach. Requirements Eng. ,
17(4):259{281, 2012.
[38] M. Salehie, L. Pasquale, I. Omoronyia, R. Ali, and
B. Nuseibeh. Requirements-driven adaptive security:
Protecting variable assets at runtime. In RE, pages
111{120, 2012.686[39] P. Sawyer, N. Bencomo, J. Whittle, E. Letier, and
A. Finkelstein. Requirements-aware systems: A
research agenda for RE for self-adaptive systems. In
RE, pages 95{103, 2010.
[40] H. Song, G. Huang, F. Chauvel, Y. Xiong, Z. Hu,
Y. Sun, and H. Mei. Supporting runtime software
architecture: A bidirectional-transformation-based
approach. J. Syst. Softw. , 84(5):711{723, 2011.
[41] V. Souza, A. Lapouchnian, K. Angelopoulos, and
J. Mylopoulos. Requirements-driven software
evolution. Comput. Sci. Res. Dev. , 28(4):311{329,
2013.
[42] D. Sykes, W. Heaven, J. Magee, and J. Kramer.
Plan-directed architectural change for autonomous
systems. In SAVCBS , pages 15{21, 2007.
[43] D. Sykes, W. Heaven, J. Magee, and J. Kramer. From
goals to components: A combined approach to
self-management. In SEAMS , pages 1{8, 2008.[44] D. Sykes, W. Heaven, J. Magee, and J. Kramer.
Exploiting non-functional preferences in architectural
adaptation for self-managed systems. In SAC, pages
431{438, 2010.
[45] H. Tajalli, J. Garcia, G. Edwards, and N. Medvidovic.
PLASMA: A plan-based layered architecture for
software model-driven adaptation. In ASE, pages
467{476, 2010.
[46] H. van Vliet. Software Engineering: Principles and
Practice . Wiley, third edition, 2008.
[47] Y. Wang and J. Mylopoulos. Self-repair through
reconguration: A requirements engineering approach.
InASE, pages 257{268, 2009.
[48] E. S. K. Yu. Towards modeling and reasoning support
for early-phase requirements engineering. In RE, pages
226{235, 1997.687