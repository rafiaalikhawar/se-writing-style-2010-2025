Detecting and Characterizing Semantic 
Inconsistencies in Ported Code 
Baishakhi Ray, Miryung Kim Suzette Person Neha Rungta 
The University of Texas at Austin 
Austin, USA 
rayb@utexas.edu, miryung@ece.utexas.edu NASA Langley Research Center NASA Ames Research Center 
Hampton, USA Mountain View. USA 
suzette. person @nasa.gov neha.s.rungla@nasa.gov 
Abstract-Adding similar reatures and bug fixes often requires 
porting program patches from reference implementati ons and 
adallting them 10 target implementations. Porting errors may 
result from faulty adaptation s or inconsistent updates. This paper 
investigates (I) the tYllCS of porting errors found in tlraetiec, 
and (2) how to detect and characteri:.r.c potential porting errors. 
Analyzin g \"crsion histories, we define live categories of porting 
errors, including inrorrecl conlrol-and data-flow, code redun­
dancy, incllnsistent identifier renaming s, etc. I.el'eraging this 
categllri:r.atilln , we design a static cllntrol-and data-dependent-e 
analysis technique , SPA, to deled lind chHracterize porting 
inconsistencies. Our evaluation on code from lour open-suurce 
projects shows thai SPA can dell-oct porting incunsistencies with 
65% to 73o/~ precision and 90% recall, and identify inconsistency 
types with 58% to 63% precision and 92% to 100% recall. In a 
romparison with two cxisting crror detcction tools, SPA improves 
precision by 14 to 17 IICrttntag e IJOints. 
I. INTRODUCTION 
Developers often port code fmm one implementation to 
another in order to implement similar features or bug fixes. 
A recent case study of OpenBSD, NctBSD, and FrecBSD 
found that J J % to 16% codc changcs arc ported from pecr 
projects 118]. Also, when libraries and frameworks evolve their 
APls, client applications make similar updates to usc the new 
APls correctly [3J. In a large code base, typically 10% to 
30% of the code is considered as code clones 111), which 
often require similar updates during software evolution 113]. 
When porting changes from one implementation to another, 
developers generally need to adapt the ported changes to fit 
the new context. The code in the reference often serves as 
a template that is pasted into the target implementation, and 
thcn latcr adaptcd [121. 
The process of adapting a change to fit another context 
can be error-prone, often resulting in porting errors. Chou 
et al. report that a significant JXlrtion of operating system 
bugs comes from ported edits r4]. In a case study of clone 
related bugs, Juergens et al. discover that ,. nearly every 
second, unintenlional inconsiste nt chanRe .~ to clones lead 10 
a fault" 11Of. Li et al. idcntify errors in Linux and FrecBSD 
resulting from dcvelopers forgctting to renamc idcntificrs aftcr 
porting code 115]. Jiang et a!. 19J present evidence of porting 
errors when similar code appears in different contexts. Porting 
errors can also happen when developers evolve JXlrted code 
differently [6), 110). 
Whcn dcvelopers port codc from a referencc to a target con­
tcxt, thcy usually expect thc portcd eodc to behavc similarly. Existing tool support for detecting semantic inconsistencies in 
ported code is limited. For example, Li et a!. and Juergens 
et al. find inconsistent clones using a lexical clone detection 
analysis (10), [15]. Jiang et al. and Gabel et al. report clone 
related bugs by comparing the syntax tree structures for two 
clones [6], [9]. Such syntactic and lexical analyses are not 
sufficient to detect the semantic inconsistencies arising fmm 
updates to the ported code in different contexts. 
The goal of this work is to assist developers in porting 
edit~ from one contcxt to another, by dctccting semantic 
inconsistencies that may indicate a porting crror. As a first 
step towards this goal, we study the extent and ehardcteristics 
of porting errors that occur in pmctiee to better understand 
the types of porting errors and their fixes. In our study, 
we work backwards by first mining the version histories of 
Linux and FreeBSD to detect commit messages containing 
porting error related keywords. We then analyze three types 
of souree code commits-fix-inducing, error-inducing, and 
reference-and their corresponding patches. A patch is the set 
of program statements that are added, deleled, or modified in 
a program vcrsion with respect to its previous version. Notc 
thai modified statcment" can also be represcnted as dcleted 
statements in the old version and added statements in the 
new version. We usc Sliverski et al.'s fix-inducing change 
identification method (21) to identify the patch that originally 
introduced the porting error. We then use Repertoire [18] to 
find a reference patch that served as the template for the error­
inducing patch. Through manual investigation of the reference 
patch, the error-inducing patch, and the fix patch, we find that 
many of the porting errors result from incorrect adaptation of 
the ported code, including inconsistent identifier renamings, 
diffcrent control-and data-flow contcxt" in thc reference and 
targct implementations, and codc redundan cy. 
Lcvemging this characterization of porting errors, we design 
and implement SPA, an algorithm to detect and characterize 
porting inconsistencies. SPA detects semantic inconsistencies 
that arise due to the interactions between program statements 
in the ported code and program statements surroundin g the 
ported code. SPA takes two code patches as input: a reference 
patch (Refold and Ref"cw) and a target patch (farold and 
Tarn"",). SPA analyzes the reference and target patches to 
identify the ported code, and then uses static control-and data­
dependcnce analyses to identify the impact of thc portcd codc 
on thc reference and targct contcxt~. Finally, SPA compares thc impact of the portcd cooe on thc refcrencc and targct scmantics 
to detcct and charactcrize porting inconsistencics. 
To evaluate the accuracy of SPA, we perfonn an empirical 
evaluation on four large open-source codebases: FreeBSD, 
Linux, Eclipse COT, and Mozilla, and compare the result.;; with 
two stale-of-the-art tools, DejaVu [6] and Jiang el al.'s elone 
related bug dctection tool [9[. Thc result.;; of our study show 
that SPA idcntifics scmantic porting inconsistcncies with 65% 
to 73% precision and 90% recall and idcntifics inconsistcncy 
types with 58% to 63% precision and 92% to 100% recall. SPA 
outperforms two relatcd error detcction tools with a precision 
improvement of 14 to 17 percentage points. 
We make the following contribulions: 
• We conduct a comprehe nsive study of the extent and 
characteristics of porting errors reported for real-world 
systems. We identify categories of common porting errors 
related to inconsistent control flow, inconsistent data flow, 
inconsistent identifier renaming, and code redundancy. 
• Leveraging information about commonly found porting 
errors, we design and implement a novel algorithm , SPA, 
to dctect potential porting crrors based on inconsistent 
semantics of ported cooe betwecn the reference and target 
context.;;. 
• We conduct an cmpirieal cvaluation of SPA'S ability to 
detect and characterize porting inconsistencies in four 
large open-source eodebases. 
The rest of the paper is organized as follows. Section 11 
discusses an empirical study of porting errors in Linux and 
FreeBSD. Section III discusses SPA'S methooolo gy for de­
tecting and characterizing porting inconsistencies. Section IV 
presents an empirical cvaluation of SPA'S capability to detect 
and characterize porting inconsistencies. Section V discusses 
related work. Finally, Section VI summarizes our work and 
directions for future work. 
II. AN EMPIRtCAL STUDY OF PORTING ERRORS 
We conduct an empirical study of porting errors documented 
in real world projects to better understand the extent and 
characteris tics of poning errors found in practice. In this study, 
we focus on porting errors thai arise when porting a patch to 
a similar, hut nOI identical, context within the same project. 
We first identify porting errors that are reported and fixed by 
developers using the version histories from two large, open­
souree projeet~. We then manually analyze these errors to 
undersrnnd the characteristics of the errors as well as the 
fixes. Most of the errors found in the artifacts used in our 
study can largely be characterized into five categories. In the 
remainder of this section, we present the study setup, results, 
and a description of the five categories of porting errors. We 
first define several key terms used in this work. 
Definition 2.1: A program plJtch, 1):= l::.(lJl' "'2)' is the 
set of syntactic program differences betwecn two program 
versions, "1 and 11-2, where cach clement in the set is an atomic 
program statement that correspon ds to an edit operation, e.g., 
insert. delete, move, and update. Definition 2.2: Ported code is a pair of atomic program 
statements Sr and Sl in patches Pr and PI respectively, such 
that s,. and St are syntactically similar and arc also edited 
similarly. 
Definition 2.3: Context of ported code is the set of program 
statements in a method that are not part of the ported code. 
A. Study Method 
We mine the commit logs and analyze version histories for 
Linux and FreeBSD. Table I shows the size of the two projects 
in KLOC, the evolution period under study, and the number 
of unique developers who made commit.;; during that period. 
Developers often document fixes to porting errors in com­
mit messages. To detect how many hug fixes are related to 
porting, we find commit logs that contain at least one porting 
related keyword: copy, cut, paste, or porting, and at 
least one error related keyword: error, bug, mistake, 
fix, or defect. A sample commit message in FreeBSD 
is "Fix cut&paste bug which would result in 
a panic " The corresponding code patch fixes the port­
ing error. 
To understand the nature of porting errors, we work back­
wards from a porting error fix by extracting three patches: 
(a) the fix patch, PI' where the porting error is fixed, (b) the 
target patch, Pt, where the porting error is introduced into the 
codebase, and (c) the reference patch, Pr, which contains edits 
that serve as the template for the ported code. A fix patch PI is 
the program paleh associated with the mined commit message. 
For example, the fix patch corresponding to the commit 
message shown above, is represented by the colored lines in 
the IR-I example in Table II. From the program locations 
edited in PI, we use cvs annotate or git blame, to 
identify the target patch, PL, which introduced the porting error. 
This process is similar to how Sliwerski et al. [21J identify 
a fix-inducing patch. We then use the REPERTOtRE tool to 
identify a set of candidate reference patches that may serve as 
the template for the target patch PI [19]. The reference patch, 
by definition , has a commit date prior to the revision date of 
a larget palch; hence, we consider patches available until the 
target patch date as candidate reference patches. Finally, we 
select the reference patch, Pr, through a manual inspection of 
the possible candidates. For example, in the IR-I example in 
Table 11 where the developer forgot to update an identifier bp 
to rabp after porting code fragments from the reference patch, 
we expect the reference patch to eonrnin the unaltered eooe 
fragment related to bp. When multiple patches contain s imilar 
unaltered code fragments, we select a patch with the maximum 
number of similar lines. 
B. Poning Errors Characterization 
In our study we were able to identify 113 and 182 porting 
errors documented in FreeBSD and Linux version histories 
over the course of 18 years and 3 years respectively. Based 
on the porting errors analyzed in our study, we were able to 
classify the errors into five different categories. We usc the codc snippets in Table II to discuss each of the categories of 
porting errors beluw. 
TABLE I 
STUOY SUlllliCTS 
KLOC de\'cJopers years 
Linux 14.998 
FIT"<'B.<;D 4.479 6,839 
4Il5 3 
18 
ICF: Inconsistent Control Flow. Many porting errurs arisc 
from edits that arc ported tu a different control flow context 
and are not adapted correctly with respect 10 the context. In 
the ICF example shown in Table IT, there is an extra for 
loop, highlighted in gray, in the reference context. Thus, 
the continue statement in the reference code is iOlended to 
match the inner for loop. [n the target cOOlext, however, 
there is only one for loop. Thus, the continue statement 
(marked in red) unintentionally matches the wrong for loop. 
Thc corresponding fix patch removcs thc continue state­
ment in the target context to fix the error. 
IR: Incollsistcnt Rcnamin g. Developers often forget to adapt 
variable, type, and constant names according to the target 
contcxt and these inconsistent renamings lead to porting errors. 
This type uf porting error is further split into two sub­
catcgories: 
IR·I: Inconsistem renamings of identifier .~. Dcvelopers re­
name some occurrcm;cs of an idcntificr i, but forgct to update 
all occurrcm;cs uf the identifier i cunsistently. For example, 
pointer bp is updated to pointer rabp three times, missing 
the instanccs marked in red in the lR-l example in Table n. 
IR·2: Inconsistent renamings of related identifiers. Develop­
ers consistently rename an identifier, but forget to update all 
related identifiers. In the IR-2 example in Table n, all instances 
of the OFDM related macro TWL_F'IR5T_OF'DM_RATE are 
updated to the CCK related macro IWL_FJRST_CCK­
_RATE. However, the variable ofdm and the related macro 
lowest-present_ofdm are not updated to cck and the 
related macro lowest-present_cck. The corresponding 
fix patch replaccs the token ofdm with the token cck to fix 
this error. 
IDF: Inconsistent Data Flow. This inconsistency occurs when 
developers mistakenly inscrt code to a diffcrent data initializa­
tion cuntext. Ln the lDF example in Table U, the first argument 
of the strcmp method optarg is initialized dilTercntly in the 
reference and target edits. optarg is an environment variable 
initialized by the getopt : call that parscs the command 
line argument s and stores the next argument to optarg. 
Hence, the function call get opt and thc use of variable 
optarg should occur as a pair. [n the reference context, 
optarg is used after get opt : and thus is initialized 
properly. In the target context, however, there is no call to 
get opt '. Thus, optarg is not initialized properly. 
RDN: Redundant operation s. Developers may inadvertently 
introduce redundant operation s when they port code to the 
wrong place, e.g., whcre it already performs the samc opem­
tion, or thcy may not update ported ediL" correctly to ensure , 
Linu. 
rig. I. Rcla!ionship bc!wccn differcm !ypcs of poning errors 
there are no redundant computation s in the target context. 
In the RON example in Tahle II, a ecxle fragment related 
to memcpy was ported to the samc function body twice under 
the same scope in FreeBSD. The corresponding patch removes 
memcpy and the buffer initialization statements to correct 
the redundant opemtions. 
OTH: Others. Other porting errors we identified include 
incorrect formattin g, c.g., indcntation, that docs not match with 
the rest of the target cooe structure, or unadapted eommenL" 
that do not describe the target code currectly. For example, 
in FrceBSD rile src/sys/geom!strip e!g_stripe h, 
version 1.3, a commcnt related to "Concat Name" was 
updated not to "Stripe Name". 
C. Distribution of Porting Errors in FreeBSD and Linux 
TABLE III 
D!STRIBUTION OF PORTING ERRORS 
tCt' ,. lin' RON 01'1\ Total 
Linux 23 74 26 47 25 182 
t2.64% 40.66% 14.29% 25.82% 13.74% 
FIftB. <;D 9 54 32 '4 28 113 
7.96% 47.78% 28.31% 12.39% 24.78% 
By manually inspecting the sets of reference patch. Pn 
target patch, Pt, porting error fix patch, PI. associated commit 
messages, and bug description s, we eategori7.e the porting 
errors into the five categories described above. Table III shows 
a distribution of the 113 cases of FreeBSD and 182 cases of 
Linux across the five categorics of porting errors. Thc results 
show that a majority of porting errors are due to incunsistent 
renaming of identifiers (lR}-47. 78% and 40.66% in FrecBSD 
and Linux respectively. The errors related to control (ICF) and 
data (lDF) flow inconsistency make up more than 25% of the 
total porting errors. The rest of the errors are either due to 
redundant operations (RON)- 12.39% and 25.82%, or wrong 
indentation and commcnts (aTH}-24 .78% and 13.74% in 
FreeBSD and Unux respectively. 
The error catcgories are not mutually exclusive. For exam­
ple. an inconsistent renaming error (IR) may also cause an 
inconsistent data initia1i7Ation crror (lDF)-I7.7% and 1.6% 
of the porting errors in FreeBSD and Linux respectively are 
both types IR and lDF. An inconsistent data initialization error 
(JDF) may also generate redundant operations (RDN}- I.8% 
in FrecBSD and 2.7% in Linux. Somctimes, an inconsistent 
control flow (ICF) may also initialize thc data erroneous ly TABl.E II 
EXAMI'LES OF l'<lIlTING EIIIIOIiS OF lJtFl'EIiENT TYl'ES 
ICF : Ineon,btent Contml Fk,w 
FreeBSb commit: s ~cl sysl kernl sched_ 4bsd 
Log: Fix a copy-paste bug in NON-KSE c""",, 
Reference File: s~c/sys/ke~n/3ched_4bsd c 
FORF..ACII _KSEGRP _IN_PROC p, ):g: I c, vendon 1,90, Author. david):u, Date: 2CXWll/14 
• • • aw,,):e ~ 0; 
if ):c->ke_eptick~ _ 01 
continue; 
if FSHIFT >_ eCPU_SHIFT] 
ke->ke...J'clcpu +-real"lathz lOCI 
ke->ke_cplick": « , Target File: src/sys/kern/sched _4bsd c 
FOREACILTHRF.AD _IN_PROC p, to: 
awake _ 0; 
if kc->k,,_cptie):" _L 0' 
ee1'ltch" ,el 
if ,'SHIn >-CC[,U~HH -TI t 
ke->kc...J>clcpu +­
fixPl_ll 
I real"lalhz leOI 
ke->I<e_cplich: « 
IR-I. Inmn ~istent renaminJ:s uf identifiers 
FrecBSD commit: src/sys/kern/vfs_bio c, version 1.351, Author. phi:, Date: 2003-01-05 
Log: Fix eut&pasle bug which would result in a panic because buffer was being biodooo'ed mulliple limes. 
Reference File: scc/sys/kern/vfs_bio c ~e t File: src/sys/kern/vfs~io c · " ,,' 
• op ->o_jocl'><l -B'O--'-\!'JIO; 
• op ->b_f.l" g~ ,--II_I NII"'~; 
• " vp->v_type --IIOiR: + lt vp->v_lype --VCHHi 
• IIOP_SPF.CSTRATEGY ~. " • else 
• IIOP _STRATF.GY ~. " ]; + VOI'_SI'ECSTHATEGY vp, bp rabpl; 
+ ehe 
+ IIOP _STIlAT!::GY vp, by> rabp: ; 
lR-2. Incoru;islent renaming5 of related identifiers 
Linux colllmit: 5cddOb946a0afebld0364a3654328b046tb8 18a2, Author: Emmanuel Grumbac h. Dale: 2013-11-20 
Log: rix a copy paste error in iwLealc_basie_Tates whieh leads to a wrong calculation of CCK basic Tales. 
Reference rile: /wi I""l"s~ / iwlwifi Idvml cxon, c Thl")!;ct File: /wi I""l()~~ / iwlwi fi/dvml rxon c 
+~f rWI._RATE_24IoLINDEX < !o'"c"Lprc"cnt_ otdlll 
+ ofdlll _ IWL_RATF._24IoLMASK » IWL_FIRST_ 
O~ TE; it IWL.ftATE.-lIIoLINDEX < low""l ...J.>resenl_~ cl<1 
t>fdfttccl< IWL.ftATE_llI\...HASK » IWLJ'IHS T_ ~ T~; 
UW: Inronsistcnt [)ata ~,u ... 
FreeBSb commit: s ~cl sbi n/gpt/qpL c, ven;ion I. Iii, AUioor. marcel, Dme: 2006-07-07 
l.og: Fix eut-n-pa.'te bug: compare argument s against known alia",., not the global optarg. 
Reference Pile: src/sh.in/qpL/gpt c Targel Pile: src/sbi n/qpl/gp t c 
... ~in lnt; argc, chllr '.HgV I p"r~c _uuid o:o",t chllr '", "nid_t '"nidl I 
whlle ch -gctopt .HgC, argv, 
""lteh ch: t 
ell,e '0' : I --1: 
~f ,trcmp optarg, "'pace": _ 01 t 
opt • FS_OPTSP ACE; 
I ,wHch •.• : 
ell,e 'c' 
if strcmp ~ " ·.,ti'l _ CI 
uuid_t efi • GPT_ENT_TYPE_EFl; 
I I 
RDN: Redundant operations 
Linux mmmit 19c2fdhab l r1854f2bfcc 7Sc326dOf453 7ec2a7e, Author. John W. Linville, Dale: 2011-04-29 
Log: Looks lii:e a copy-n-paste error, idenlical lines are a few li""s below the o""s removed, . 
Reference File: s ICcl sys Idev Imxgel i i_mxge c Target File: srcl sys/dev Imxgel if.Jflxge c 
mcmset ~t"f_tl v, CxOC, ,izeof ,truet; 
mwifiex_ie_typc~ _t~f_time' tamp: : ; 
me11lCpy .buffer, 't5f~tlv , '~zeof t,f_tlv header: I; 
.ouffer , •• izeof tBf_tlv headerl; 
memcpy .bufCer . 't"f_val, .Heof l~[_val: I; 
.uuffer +-s1zeot tsf vall; (IDf')-----(1.9 % in f'rccBSD and 1.6% in Linux. Figure I shows 
the distribution of the five porting error types in FreeBSD and 
Linux. 
D. Threats to Validity 
Construct Validity. We rely on the method of mining for 
porting error related keywords in the commit messages . It is 
possihle that developers may not document porting errors in 
commit messages when fixing porting errors. 
Infernal Validity. We assume that porting mistakes happen due 
to poor adaptation , which may not be always true. The five 
types of common porting crrors are derived from the analyzed 
data and thus are subject to the experimenter 's interpretation 
or categorization bias. 
External validity. We study porting errors in FrccBSD and 
Linux. Both of these projects are written in C. Thus our 
categorization of porting errors may be biased towards C 
language features. Also, we study porting bugs within a 
project boundary. Our observations may differ for cross-system 
porting errors. Though our results may not generalize to other 
systems, we believe our study of two long-surviving, large 
scale operating systems provides meaningful insights. 
Ill. SPA ApPROACH 
This section presents a semantic porting analysis algorithm, 
SPA. It detects and categorizes inconsistencies in sequential 
program-flow and incorrect identifier renaming within the 
scope of a single method. Our key intuition is that semantic 
inconsistencies in porting arise due to the interactions between 
ported code and the impacted context, when the contexL" differ 
between the reference and the target implementation s. 
A. Overview 
An overview of the SPA process is shown in Figure 2. 
To detect potential semantic inconsistencies, SPA takes as 
input a reference patch that specifics the syntactic difference s 
between Refold and Refncw and a target patch that specifies 
the syntactic differences between Tarmd and Tarncw. We 
first extract the set of edit operations , such as insertion and 
deletion of program statemenL", from the target (J~ar) and 
reference (Erer) patches. In step 2 of Figure 2, we estimate 
which of the edit operations correspond to the set of program 
statements that arc ported from Rcf"ew to Tar"ew. The AST 
nodes corresponding to the ported statemcnts arc storcd in 
the ported node pairs (PNP) set. We then compute the 
statements impacted by the ported Slatements in the reference 
(Ire( ) and the larget (Ilar) in step 3. We use standard control 
and data dependence analyses to compute the impact of the 
ported statements on the other statements (the context). In 
step 4, the infonnation computed in the previous steps is used 
to detect and categori7.c the potential porting inconsistencie s 
according to the types presented in Section Ill. Finally, the 
inconsistencies are reported in step 5. 
IType afH (unadapted indentalion or oommenls) is not included in tile 
scope of our diaglKlsi., as this requires textual or t~xical analysis arKl does nol. 
involv~ Ihe semanli"" of code f .... gmen t~. Wc illuslrate the SPA approach with an example shown in 
Table IV. The cxample is an adapted vcrsion of code fragmcnts 
from FreeBSD. The codc is portcd from a reference method, 
freebsd4 _getfsstat, to a target method, osfl_get­
fsstat. Lines marked with "+" are the ported code. The 
reference and target contexts are syntactically different. In 
os fl_get fs s tat, the ported lines T ~ and 11 a appear after 
two if statemenL" at lines T 4 and T E. No such if statements 
are present in freebsd4 _getfsstat. Also, the variable 
buf is initialized at line Tl2. Thus, Tl3 is in a different 
data initialization context in the target than iL" corresponding 
line RE in the reference. 
The program statements that are changed between the old 
and new versions arc highlighted in gray and the ported ediL" 
are marked with "+" in Table IV. Ported ediL" IS, TI0 and 
Tl~ in Tarnew correspond to R4, RS and RE in Ref"ew 
respectively. The ported edits in Tar,,~w arc control-dependent 
on T4 and data-dependent on Tl, T2 and T12. Also T11, 
T14, and T1S are data-dependent on the ported edits TIC 
and Tl3. All of these statements are treated as impacted 
statements. Similarly , RI, R2, and R8 are marked as impacted 
statements in Refncw. Next, we present the details of how 
impacted ported nodes are generated. 
B. Identify the Impact of the Ported Code 
We present the thrce main steps to identify the porting con­
lext that may impact or may be impacted by the portcd codc. 
Thc inputs to SPA are two patches specifying thc syntactic 
difference s between Refold and Ref"cw and between Tarold 
and Tarnew: Plar:= Ll.(Tarold, Tar"cw) and Pre! := .d(Refold, 
Ref""w). 
Step I. Identify Edits in the Reference and Target: SPA 
computes the syntactic edit operations (insert, delete, move, 
or uptlate) required on the abstract syntax trees (ASTs) to 
transfonn Refold to Ref .. cw and Tarold to Tarnew [5]. This 
algorithm is inspired by Meng et aJ.'s edit script generation 
and extends its implementation r 161, r 171. For the code shown 
in Table IV, three edit (jfL~ert) operations are identified in the 
reference patch, and five edit operations are identified in the 
target patch. SPA uses the edit operations to generate the edited 
nodes Er,,! and Eta,., corresponding to Ref""", and Tar""", 
respectively. An edited node cp is an AST node corresponding 
10 an edited srntement in a program patch p. The sourcc lines 
corresponding to the edited nodes are highlighted using a gray 
background in Table IV. 
Step 2. Identify Ported Nodes: SPA delermincs the cor­
respondcnce of statements in the ported code between thc 
reference and the target. It is possible that when a developer 
adapts ported code from one context to another, she may also 
insert or delete additionaJ code; hence, there may be edited 
nodes that do not correspond to ported code. A ported node 
pair is a pair of AST nodes (r, l), where r E Ere! and 
t E Blar, and rand t have a unique correspondence with 
each other. This unique correspondence is detennined by a 
function clone that takes two arbitrary AST nodes as input 
and outpuL" truc if the AST node types are identical and their ReI ... , Reletence Ed~ ~ = (~"") ~ Node. C .. ~o! on<! ~ ~ "" I '" II POOOO N<>do I 'I ' 1111 D.,. Dependent "" ~ I''''''' .... ...,t Nod .. = ;:-c -~ ~ •• • ~ 11C ... ,iC.,) II mIl! II , ~ T",9'" Ed<' 11,.,,1,.,) . III 1 J:l, " I ~ II , , , II I "-~ ''-' == 
Fig. 2. SPA Workflow 
TARl.E IV 
EXAM I'Ll! AI>OI"rEIl ANII SIMI'LlI'IEI) I-'(JIIT1N(J EXAMPLE TAKEN I'IIOM FlllmB SD 
Refnow 
Rl in" fr"cbBd4_'1ctf"~t"t ~nt tlagB, int bufd.e 
o'tatf~ 05b: I 
~lat[s bue -null; 
lnt error -0; 
R4 + ~"t count -but,he I ost"tf, sizeot i; 
R5 ~nt 5i,,, _ count . ,tatt, 5i,cof I; 
Rt error copyou t o,b, but, ,i.e:; 
" '" "' return .,,'ror; Tl int oBfl_gctf"Btat int fla'l" , in" bufd.e, 
o,fbt"tf, o,b: I 
su,tf9 bur -null. 
lnt error -C, 
it tla'l" __ GF.TFSS TATI 
T5 return 0; 
TE if fla'l' __ WAIT: 
T7 flags -MNT_WAll'; 
" T9 + ~nt count -out,;' " I ~ ,n:'tatf' 
sizeof .. 
JUG int ,i.e count. ,tatf, ,i.eot " 
jUl 1£ she> 0: 
jll2 but -new ~tatl " I; 
ill 3 onor copront o~b, buf, <i.e:; n. 
m n. error copyout o,b, buf, ,ize:; 
nturn errori 
Ediloo lin~s in a new v'."niion w.r.l. the old v~ni ion are pres"nl~d in dart back)''lUund. Th" portallin"s begin with +. The mlli""s are inoon,isl"n( sla!t!ment, 
delecloo by St'A. 
labels are also similar above a certain threshold based on bi­
gram similarity (20). A bi-gram similarity detects the ratio of 
the total number of hi-grams common between two strings 
to the average number of bi-grams representing the strings. 
Thc output rangcs from 0 to 1. A high valuc indicates that 
strings are either identical or very similar i.e., whcn developers 
rename identifiers lifter porting. We sct thc similarity threshold 
to a high value of 0.8 to ensure that the matehed hlbels are 
very similar 10 each other, indicating truly ported nodes. OUf 
definition of ported node pair is very restrictive to reduce 
false posilives in the later sleps; we only consider one-to-one 
correspondence s between a reference and a target node, and 
ignore node pairs with one-to-many correspondence s. 
PNP = {(T, t)IT e Eref f\ t E E,ar f\ clone(T, t)} (I) 
PNP is a sct of ported node pairs where each pair (r, t) e 
PNP represents a node ported from a reference patch to a tar­
get patch as defined in Equalion I. Each node in the pair (T, t) 
is referred to as a ported node. For example. the nodes corre­
sponding to statements R5 and T lain Table IV have the same 
AST node type (declaration ) and label (si2e= count 
+ statfs si2e :), hence done(RS,TJO) is true and 
(R5,Tl C) is a ported lWde pair. However, no AST nodes in 
Ere! are syntactically similar to the AST node corresponding 
to statement TIl in Btar. Therefore, Tll is nO! a member 
of any portcd node pairs. All of the statements identified with 
"+" in Table IV have corresponding AST nodes in PNP. Step 3. Identify Impacted Nodes: Next, SPA identifies the 
AST nodes in Refnow and Tarncw that are either impacted by 
or impact the semantics of the ported nodes. The impacted 
nodes include all of the ported nodes, and the subset of 
the contcxt nodes that may affect the porting semantics or 
may be affected by the ported nodes. SPA identifies the 
impacted nodes using slatic intra-procedural dala-~md control­
dependence analyses 122J with respect 10 the ported nodes. 
This step bears resemblance 10 how Sydil idenlifies the eonlexl 
of edit operations using control and data analysis [16]. 
Data Dependence . Statement 82 is datu dependent on 81, if 
8( defines a variable tl and 82 uses v, such that there exists 
a path from 81 to 82 along which 1J is not killed (redefined) . 
(ontrol Dependenc e. Statement 82 is cofllrol dependent on 
81. if execution of 82 depends on the decision made at 81. 
Definition 3.1: A program dependence graph, P DC 
(ON,OE), is a set of vertices ON representing program 
statements, and a set of edges, J) B !;;; 0 N x ON, representing 
the control and dUla dependencies between statemenL~. 
A control dependenc e graph (COO) is a sub-graph of a 
PDG, where the edges represent control dependencies belween 
vertices (program locations), whereas a data dependence graph 
(DOG) is a sub-graph of the POG where the edges represent 
data dependenc ies between vertices. 
In SPA, we construct the POO vertiees using AST nodes, 
each of which represents an atomic program statement, and the 
edges correspond to the control and data dependences between 
statemenL". The impacted nodes in Ref""", and Tar"".v are derived from thcir respectivc program dcpendenee graphs, 
PDGref and PDGtar. Given a set of vcrtices mapping to 
ported nodcs Vp !: Rcf"ew and the PIX:i for Rcf"cw, we 
generate the impacted nodes Irc,. The impacted nodes map 
to vertices in the PDG reachable from Vp along the control 
and dala dependence edges. Similarly , we find Itar from Vp \; 
Tarncw. The vertices corresponding to statements Tt: and Tl 
in Table IV are not control or data dependent on ported code, 
hence they are not in the impact set. 
C. Detect and Categorize Porting Inconsistencies 
SPA catcgorizes porting inconsistencics according to the 
types prcsented in Scction 11, using portcd node pairs, PN P, 
impacted nodes, l,,~, and liar, and thc data-and eontrol­
dcpendence information computed in the previous steps. 
ICF: Inconsistent Control Flow. To detect ICF inconsis­
tencies, SPA performs the following steps: 
• Given a pair of ported nodes, (T, f), we construct isomor­
phic sub-graphs starting from r in CDGrer and from t in 
C DGtar. A pair of vertices (1Jr, VI)' where 1Jr E C DGrel 
and Vt E C DGtar, is isomorphic if (i) the vertex labels 
have identical AST types and similar syntactic structures 
(e.g., nodcs 'a = a + b' and 'x = y + z' have same AST 
type and syntactic structure), and (ii) the vcrtices have the 
same relative position with respect to the ported nodes. 
We extend Komondoor ct al.'s progmm slicing based 
clone detection algorithm 1141 to construct the isomorphic 
sub-graphs. 
• Detect inconsistent nodes in the context with respect to 
(T, t) and add them to the respective inconsistent sets, 
JCre! and JCtar. A node in lrp./ (Itar) is inconsistent if 
it is reachable from r (t) in CDGrel (CDGlar), but it 
is not contained in the respective isomorphic subgraph. 
The nodes corresponding to statements R4 and '1'9 in Ta­
ble IV are a ported node pair. R4 is not control dependent 
on any node within the method body, while 'Hl is control 
dependent on 1'4 along the true control edge. '1'4 is then added 
to JCtar, as it is reachable frum purted node T9 although it 
docs not have a corresponding nodc in thc refcrence. 
IR: Inconsistent Renaming. To detect this inconsistency, 
we first construct the isomorphic sub-graphs on CDGre! and 
C DGtar with respect to the ported node pairs, as described 
earlier. For each isomorphic node pair in COGr", and COGtar, 
we extract the corresponding identifiers, i.e., variables, types, 
and method names, and align them based on their syntactic 
similarity. For example, given two isomorphic nodes with 
labels' a = b + c' and 'x = y + z', variable a is aligned with 
x, variable b is aligned with y, and variable c is aligned with 
z. We rank each identifier mapping with a confidence value 
based on the number of limes the mapping is encountered. 
Using these alignments, we generate two identifier maps: 
(a) IdMuPrc/' a map from each reference identifier to its 
corresponding target identifiers, and (b) JdMaptar, a map 
from each target identifier to its correspondi ng reference 
identifiers. If a one-to-many or a many-to--onc relation is 
found in the maps, then an IR inconsistency is detected. Wc consider identifier mappings with the lowest (or, all when 
there is a tic) confidence valucs as the incorrect mappings, 
and characterize the vcrtiees in the isomorphic sub-graphs 
corresponding to the incorrect mappings as inconsistent. 
Table V shows an example of J dM aPre, generated 
from Table IV. SPA generates a map entry (os£1 statfs 
-ostatfs ) from the method signatures and (as f1 statfs 
-osflst atfs) from the isomorphic nodes R4 and '1'9. 
Sinec the reference variable as f 1 stat f s maps to two target 
variables, osflstatfs and ostatfs, an lR inconsistcncy 
is detccted. 
TABLE V 
IDIlNT II~IlR MAPPING FROM TABLE tV 
Nod.. Idenlif .. r 
(RI.T1) 
(R4.T9) 
Sometime s developer s forget to update reluted identijierl', 
as shown in the IR-2 example in Table II. To detect this 
inconsistency , we carry out a similar process at the granularity 
of tokens a" opposed to identifiers after sepamting identifier 
names using sepamtors '-', ,_., or a eamel case convention. 
For cxample, OFDM is mapped to CCK once, while ofdm is 
mapped to ofdm twice. 
IDF: Inconsistent Data Flow. lOF inconsistency detection 
is similar to our ICF diagnosis but uses data dependence 
graphs (DOG) instead of COGs. 
In Table IV, R€ and Tl~ are Sll.ltem enl~ corresponding 
to 11 ported node pair. In the reference implemcntation, RE 
is data dependent on R2 for the definition of variable but. 
However, statement 113 in the target implementation is data 
dependent on the definition of buf at T2 and 112. Although 
R2 and T2 are isomorphic, the dependence on T12 creates an 
additional data dependence in the target implementatio n that 
is not present in the reference implementation. Therefore, the 
node corresponding to T12 is added to ICtar. 
Similarly, R5 and TIC arc statements corrcsponding to a 
ported node pair, and both define variable s i l:' e. However, in 
the reference implementation, si2e is used at statement RE, 
while in the target implementation, s i l:' e is used at statements 
TIl, T13, and T14. Although RE and T13 are isomorphic , 
TIl and Tl 4 create additional data dependen ces in the 
target implementation that are not present in the reference 
implementation . Therefore, the nodes corresponding to TIl 
and T 14 arc added to IClnr. 
RON: Redundant operation s. To detect redundant ported 
code. SPA checks for pairs of vertices in CDGtar that have 
identical labels and types and that are control dependent on 
the same impacted vertex. Note that we only look for an RON 
inconsistency in Tarncw. In Table VI, statements Tl3 and Tl4 
in the target implementation have identical syntax, and both 
are control dependent on the impacted statement T 4. Thus, 
SPA characterizes the nodes corresponding to statements T13 
and T 14 a" redundant. Table VI shows the nodes that are inconsistent with respect 
to the ported code in Table IV. along with their corresponding 
inconsistency types. 
TABU! Vt 
CIIAItACT1!1t!7,.ATlON 01' PoRTI",(ll"'CON SISTU"'C!l>S I'" TAIH.IlIV ,-­(00') 
InctlIIMOICftI !denI, Rcnami"l 
(IR) 
1"ICOIWo0000000l v.I' "OOCI 
(LDI'l 
lUdundaru roooet 
(RDN) 
f). Implementation TII.Tl2.Tl4 
TIJ.Tl4 
SPA is implemented using several existing tool chains. First. 
we extend LASE 1171 and Sydit (16), which extract edit scripts 
to automate systematic program changes. SPA also extends the 
control and data dependence analysis of Sydit to identify the 
impact of ported nodes in the reference and target programs 
respectively. The dependency analysis uses cry.fta/121, a static 
analysis framework to amllyzc Java source code. 
I V. EXPERIMENTAL RESULTS 
In this section, we present an empirical evaluation of 
SPA'S ability 10 detect and diagnose porting inconsistencies 
in FrecBSD, Unux, Eclipse COT. and Mozilla. We compare 
the aceuracy of the results computed by SPA with the results 
computed by two state-of-the-art lools. Jiang et al.'s clone 
related error detection tool 19) and DejaVu (6). Jiang et al. 
model the context of ported code in tenns of their immediate 
preceding lines, even if the context does nOl have any control 
or data dependence on ported code. Though DejaVu eXlends 
Jiang el al. by refining clone detection results to detemline 
ported code, it still suffers from the same limitation as Jiang 
et al., lL~ Ihe context is identified based on physical location 
proximity not on control and datn now dependences with the 
ported code. 
We also compute SPA'S accuracy to characterize potential 
inconsistencies based on Ule categories defined in Section U. 
To this end we investigate two research questions: 
• RQI. Can SPA aceumtcly detect porting inconsistencies? 
• RQ2. Can SPA uceumtcly categorize differcnt types of 
porting inconsisteneics? 
A. Srudy Subjects 
To evaluate SPA, we use porting cxample.<; from four dif­
ferent projects: FrecBSD, Linux. Eclipse COT, and Mozilla. 
Execpt for MozilJa, the reference and target patches for eaeh 
artifact are computed using REPERTOIRE (18). From these. we 
randomly select (a) 20 examples [rom FreeBSD. (b) 10 exam­
ples from Linux, (c) 60 examples from Eclipse CDT that are 
ported from COT versions CDT_2_0 to CDT_8_1 _1, and (d) 
42 Mozilla examples from the annotated data set of copy-pasle 
errors provided by Gabel ct al. 161. The FreeBSD and Unux 
artifacts are from the data sel" used in Section II. To retrieve 
a large number of porting instances, we choose CDT_2_C 
and CDT_E_l_ l versions which are 98 months apart. The Mozilla examples were obtained from DcjaVu's annotated data 
setl, because Dcjavu is not an open-souree tool. Ln the Morilla 
examples, we treat an entire progr.un as a progmm patch 
whose old version is empty, because SPA works on program 
patches as opposed to entire programs. We use a combination 
of commit logs and manual inspection to annOlate the types of 
potential porting errors in selected target patches of the subject 
artifacts. 
The current version of SPA analyzes only Java souree code, 
so we convert the C and C++ porting examples from Linux, 
FreeBSD and M07.illa examples using a free ac++ 10 Java 
code converter (II. 
B. Study Methodology 
We measure SI'A'S cupability to detect and categorize port­
ing errors in terms of precision and recall. For each error 
type c defined in Section II, suppose that S is the set of 
examples where a porting inconsistcney is detected by SPA and 
it~ error type is reported by SPA to be c. Suppose that A is the 
set of examples where a porting inconsistency is manually 
detennincd to be of type c. Then thc precision and recall 
of SPA in categorizing JXIrting inconsistencies are defined as 
follows: 
Precbiion. the perecntage of porting ineonsislencie."IAf Iff! 
e found by SPA that are also known to be type e i.e., ~ 
Recall. the pereentage of the Icnown inconsistencies of trre 
('" which are also found to be type e by SPA, i.e., IAI~IS 
To evaluate the accur.tcy of SPA'S error detcetion capability, 
we calculate precision and recall without considering individ­
ual error types. 
C. Study Res/l/u and Discussions 
RQ I. Can SI'A accurately detect porting inconsistencies? 
We compare SPA'S ability to detect porting inconsistencies 
with liang et al.'s clone related bug detection algorithm 19P 
and DejaVu [6J. Tuble VO sununarizes the comparison of SPA 
with Jiang et at using the Eclipse COT artifact and with 
DejaVu on the Mozilla examples. The first row represents the 
number of potential porting errors, regardless of error type, 
that were detected by the respective tools. We also report the 
number of false positivc.<;, false negatives, precision, and recall 
of the error detcetion capability of each tool. The re.<;ults of our 
study show that SI'A improves the error detection capabilitic.~ 
considembly over Jiang el at SPA improve.<; the precision from 
48% to 65%. and marginally improves the recall from 87% to 
90%. 
Out of the 42 randomly selected examples from the DejaVu 
annotated MoziJla dma sel, our manual inspection shows that 
only 25 of them eont:lin true porting inconsistencies. Thus, 
DcjaVu's precision is 59.52%. For the same data sct, SPA 
reports inconsistencies for 34 examples. Thus, SPA'S precision 
lhllp:Jlwwwcsif. C$.LiCdaviS.edul-gabcVresearchidejavu _mozilla.zip 
)Jiang et al.·s clune okleelor Deckard and the associated clune bug okteelor 
were duwnload.: t.I from hl1ps:llgilhub.cumlskyhcwerlDechrd. in detecting errors on the Mozilla data set is 73.53% as 
shown in Table vn. Because this data set docs nut cuntain 
any examples where DcjaVu fails to report an inconsistency, 
we are unable to assess the number of faJse negatives for 
either DejaVu or SPA. Furthennore, because our comparison 
is limited to the data set where DejaVu already found porting 
inconsistencies, the precision of SPA could be lower if the 
comparison was done on a different data set. 
We find that SPA reduces false positives over Jiang et al.'s 
tool and OejaVu in 14 and 8 cases respectively. For example, 
consider a case when a variable is initialized differently in the 
referenec and targct contcxts. Later, both the referenec and 
the target contexts reinitialize the variable in the same manncr 
before using it in the ported code. In this case, SPA correctly 
does not report any inconsistency unlike other tools, because 
there is no data now between the inconsistent initialization 
and the ported code. 
The cases where all three tools incorrectly detect inconsis­
tencies include porting code from a while comext to a for 
context, porting code from an if context to a switch-case 
context, ctc. 
TABLE VII 
INCONSISTENCY DETECTION RESULTS FOR ECLIPSE eDT AND MOZILLA 
Eclipse CDT Mo~illa 
SPA Jia"I('s TIKlt SPA IkjaVu 
Detected 43 56 34 42 
Fatse Positive IS 29 9 17 
False Negative 3 4 
Precision 65.11% 411.21% 73.53%· 59.52%· 
Recall 90.32% IIHJ9% 
0100 companson IS done on 100 dala sct whCi'C OCJaVu already rcpot1ed 
porting errors. 
RQ2. Can SPA accurately categorize difTCr£nt typcs of 
purting inconsistcncies? 
Table VlII shows the precision and recall for SPA III 
categorizing potential porting errors in FreeBSO and Linux 
for the error types JCF, IR-I, lR-2, IDF, and RON. SPA 
has precision ranging from 50% for ICF to 100% for RDN. 
The recall for SPA ranges from 62.5% for RDN to 100% for 
ICF and IDF w.r.1. the porting errors reported in the version 
histories (see 2nd row in Table VIlI). Version history based 
evaluation is often conservat ive in the sense that when there is 
TAIlLE VIII 
INCONSISTENC Y ClIIIRIlCTEIlIZIlTlON IIE.~UI.T.~ ON FltmlHSD liND LlNUX 
ICY fR-t fR-l lOY RDN 
Sf"1I Detected 10 8 6 9 , 
!'rom commit logs , , 5 6 , 
Precision SO% 111.5% 66.66% 66.66% 100% 
Recall 100% 81.5% 80% 100% 62.5% 
Manually annotated , , , 8 8 
Precision '''' 111.5% 66.66% 111.5% 100% 
Recall 100% 111.5% 80% 100% 62.5% no mention of porting errors in the commit messages, it docs 
not necessarily imply thc absenec of porting ineonsistencics. 
To uvereome this limitation, we cumpare SPA results against 
the type and location of inconsistencies that were identified 
by manual inspection of individual patches. The comparison 
against this annotated set is shown in Rows 5-7 in Table VIII. 
Table IX summarizes the number of porting inconsistencies 
for each error type, and the precision and recall based on the 
manually identified error types for Eclipse COT and Mozilla 
data sets. In Eclipse COT, SPA detects and characterizes 62 
porting inconsistencies -77% arc lCF, 16% are JR-I, J2% arc 
IR-2, and 40% are IDP. In Mozilla, SPA detects 54 instances 
of porting incunsistencies, of which 28%, 22%, 7%, and 43% 
arc of type JCF, IR-I, fR-2, and IDF respectively. No RON 
inconsistency is reported in these two data sets. On average, 
SPA achieves 58% precision and 92% recall in Eclipse COT, 
and 63% precision and 100% recall in MoziUa data set. 
In detecting ICF inconsistencies, SPA may report false 
posilives when, for example, code is ported from a for 
block to an equivalent while block, because these two loops 
have different syntaxes. SPA may gencrale a false positive of 
type JR-I when the relative ordering of program variables is 
changed, but the semantics remain unchanged, e.g., a statemcnt 
x = x+y in the reference implementation is modified to x = y+x 
in thc target. When characterizing fR-2 inconsistencics, SPA 
may report false positives when, for instance, the names cannot 
be tokenized properly due to inconsistent naming conventions. 
For example, if a ported node pair contains the variables 
fooBar and foobar, SPA correctly splits the first one into 
faa and Bar but does not split foobar. Thus, SPA misaligns 
the tokens. In the case of IOF inconsistencies, SPA may report 
a false positive when, for example, a variable is declared 
and defined in a single program statement in the reference , 
but the declamtion and definition arc separate statements in 
the target. Here, SPA reports an inconsistency because the 
AST node types are different (declaration versus assignment). 
With respect to false negatives, SPA is not able to detect 
redundancie s that require a deeper semantic analysis, such as 
redundant locking calls in a concurrency construct. 
In spite of these limitation s, there are some suc­
cess stories. A bug was fixed in FreeBSD souree file: 
src/sys/dev/rn xge/if_rnxge c, version 1.27, with a 
commit message: ,. Fix an mhuf leak caused hy a Cul&pasle 
hug where the small ring s mhuf~ were never freed. hw the 
hig ring was freed twice". A buffer rx_big was mistakenly 
freed twice. SPA detects this bug successfully and categorizes 
it as an RON bug, which is also confinmxl by the dcvelopers 
and took 26 releases and 432 days to detect and fix. Jiang et 
aI's tool is not able to detect this bug since it does not handle 
redundancy. 
Another identifier renaming bug was fixed in Linux 
at commit id 2b9460. Code was ported from method 
rnlx4_ib-post _send to rnlx4_ib-post _recv, but 
variable send_cq was never updated to recv_cq. This bug 
caused a queue overflow in the infiniband driver module 
(a high-speed network driver) and took 974 days to fix. SPA TABLE [X 
SPA INCONSISTENCY DIAGNOSIS RESULTS 
Eclipse CI>T 
ICF IR-I IR-2 lDF 
SI'A Detedoo 3.> (53%) 7 (11%) 5 (8%) 17 (27%) 
Annotated 23 7 4 , 
Fa[se Positive 12 2 2 12 
False Negative 2 2 I 0 
Prcdsion 63.63% 7[.43% 60% 29.41% 
Recall 91.30% 71.43% 75% 100% -, .. oo' 
successfully detected this error. Olher tools were unable to 
detecl this error because they do not check whether related 
variables were updated eonsistenlly (lR-2). 
V. RELATED WORK 
Juergens ct al. 110J conduct an empirical study on the 
impact of inconsistent clones in a code base. They detect 
inconsistent clones using a suffix-tree based, lex.icaJ clone 
deteclion algorithm. Their interviews with developers confino 
that inconsislencies in the found clones are indeed bugs and 
report that ,. nearly every second, unintentional incon.~istent 
chanKes to clone.~ lead to a fault." 
Chou et al. show that porting is an important source of 
bugs in operating systems [4]. In 65% of the ported code, at 
least one identifier is renamed, and in 27% cases at least one 
statement is inserted, modified, or deleted 1151. An incolTect 
adaptation of ported code often leads to porting errors 19]. This 
observation is aligned with our findings-where we find 113 
and 182 porting crrors by mining FrecBSO and Linux. version 
histories respectively. 
Using CP-Miner, a mining based clone delection tool, Li et 
a!. find 28 and 23 elTors in Linux and FreeBSD respectively, 
which developers created by forgetting to rename identifiers 
consistently after copy and paste 1151. Jablonski et al. 171 
detect similar errors by tmcking eopy-paste cooc within an 
Eclipse IDE and by comparing the corresponding AST rep­
rescnrntions. Though the rcsults of these studies are aligned 
with our findings of IR inconsistencies, we observe that such 
inconsistent renaming is a special case of a more general cate­
gory of porting inconsislencies-forgetting to adapt identifiers 
according to the target contexi (IR-l and IR-2). 
SPA detccts a broader scope of inconsistcnt rcnamings by 
tokenizing function names, file names, and identifier names us­
ing a camel case naming convention and mapping correspond­
ing IOkens. Our algorithm detects an inconsistency when a 
loken in one context maps to multiple lokens in the other con­
text. For example, when code is ported from Export ~ ava 
to Import ~ava, SPA checks whether all names related 
to export are updated to import . 
Jiang el al. show that an inconsistem context can also 
cause porting errors [9]. However, their definition of context is 
limited to the innennosl comrol How construct surroundin g the 
cloned code. They identify syntactic clones using AST level 
similarity 18], and then detect inconsistencies by comparing 
the contexts. While their diagnosis partially overlaps with our Mozina 
Total ICF IR-I IR-2 IDF Total 
62 15(28%) 12 (22%) 4 (7%) 23 (43%) " 39 13 6 2 13 34 
26 2 6 2 10 20 
3 0 0 0 0 0 
58.06% 86.66% 50.0% 51\0% 56.52% 62.96% 
92.31% I_ 
100% 100% 100% 100% 
1l1C<""'o;tcncy 
categori7.ation of porting errors (ICF and IR-I), they do not 
report renaming errors on groups of identifiers (IR-2), data 
flow inconsistencies (IDF), or redundant opemtion s (RON). 
Also, their error detection analysis is purely syntactic, and 
thus suffers from a higher rate of false positivcs than our 
semantic, control- and data-flow based approach. SPA reports 
17 percentage point better precision and 3 percentage point 
more recall in detecting porting inconsistencies than Jiang et 
al. on the Eclipse COT data set. 
Deja Vu extends the work by Jiang et a!. by using severaJ 
filtering heurislics, such as assessing textual similarity and 
pruning non-cloned contexts, to improve its precision [6]. 
As shown in our evaluation, SPA'S error detection still out­
performs DejaVu with 14 percemage point better precision. 
Also, DejaVu does nOI report potential error types, while SPA 
automatically chamcterizes the detected inconsistencies to hclp 
developers detect porting errors. 
VI. CONCLUSION 
When porting code from one contexi to another, the se­
mantics of the ported code often change due to differences 
in the surroundin g comexts. Developers may overlook such 
subtle differences, inadvertently creating a porting error. By 
analyzing the version histories for Linux and FrccBSD, wc 
identify five common categories of porting errors, and then usc 
this categorization to design SPA, a novcl algorithm to detect 
and characterize semantic inconsistencies in ported cooe. Our 
evaluation of SPA on seveml large open-source code bases 
shows that SPA can detect porting inconsistencies with high 
precision and recall, and it outperfonns the precision of two 
state-of-the-art techniques with 14 to 17 percentage point. 
As part of our future work, we plan to investigate methods 
for further reducing false positives, such as comparing the 
dynamic program behaviors of ported code. Based on the 
observation that not all inconsistencies lead to an error, we 
also plan to investigate heuristics to rank the inconsistencies 
based on their error potemial. Finally, we plan to integrate SPA 
with an integmted devclopment environment so that developers 
can detect porting inconsistencies during the porting process. 
ACKNOW LEDGMENT 
We thank Na Meng for the discussions that inspired the 
design of the SPA algorithm and for her help in reusing the 
implementation of Sydit and LASE. This work was supported 
in part by the National Science Foundation under gmnts CCF-
1149391, CCF-1117902, SHF-09 J08 1 8, and CNS-1239498. ReFEREN CES 
III c++ 10 java converler: hup:lfwww.tll ngiblewftwaresolutions.oom. 
121 Crystal a stalic analysis framewort for edocalioo and resean:h: 
hup:Jfoode.google.comIplcrystlilsaf/. 
131 R. AI-Ekram. C. Kaps.er. R. Holt. and M. Godfrey. Cloning by accidenl: 
an empirical study of source cock cloning "'-"'US'! !IOI'tware "Y"1em<. In 
£mpiricuJ S"/"'·a~ EII~int:t:rintl , 2005 .• page 10 !'P., nov. 2005. 
14] A. Chou. J. Yang. 8. Chelf. S. Hallem. and D. Engler. An empirical 
... udy of operuling systems mur.!. In Proct!edinxs ofrM eiXlu""",II AeM 
rymposium ( .... OpullIinX syslem.< principles. SOSP ·01. pages 73--88, 
New York, NY, USA. 2001. ACM. 
lSI B. F1uri, M. Wijrsch. M. Pinzger. aoo H. C. Gall. Change distilling­
Iree differencing for fine-grained source code change extraction. IEEE 
TrnlUllCliQIIS (}11 Sofl"'Wll Enginuring, 33(11): 18. November 2007. 
161 M. Gabel, J. Yang, Y. Yu. M. GoIdszmidl, and Z. Suo Scalable 
and sySlemalic detcclion or buggy inconsistenc ies in source code, In 
Proct!edings Q/ille AeM i"'ertWliQlla/ ron/ul!nCt! Qn Objecl Qrie",ed 
programming sySlem$ /(lI1gU(lgU and appficaliQtlS. OOPSLA ·10. pages 
175-190. New York. NY. USA, 2010. ACM. 
171 P. Jablonski and f). I~ou. Cren: a 1001 for loading copy-and-pa<le code 
clones aoo renaming i<lenlifiers consi.,lently in the i<le. In I'm<:udin g .• 
of Ille 2007 OOI'SIA "·""bll",,, on ee/ip .• e lechlU)logy eXdUlnge, eclirse 
·07, pages 16-20. Nt."W York. NY. USA. 2007. ACM. 
181 L. Jiang. G. Misherghi. Z. Suo ~nd S. Glondu. Deckard: Scalahle and 
accurate tree-hased tJclC(.1ion of code clOIle.'. In f'rocudings oflM 29111 
i",enwlimwl evnlelV!nctI , .... !iv11W<l1V! Engineering. ICSE '07. pages 96-
lOS. Washington, DC, USA. 2007. IEEE COl11puk. T Socicly. 
191 L Jiang, Z. Su, and E. Chiu. Contellt-bascd delcelion of clone-related 
bugs. In E.S£C·FS£ '07; Procudingt of liu! lite 6111 joinl muling of 
1M &ropron !iv1''''U1V! Enginuring Con/t!fI!nct! <!lid 1M ACM SIGSOfT 
symposium Oft Tht! /~lif)IIJ/ of so{t"~If"t! enginuring, pages S5--64. 
New York, NY. USA. 2007. ACM. 
1101 E. Juergens. F. Ikissenboe.::k, U. Ilummel, and S. Wagner. Do rode 
clonc:s maller" In Proc""di"IJ1 of tilt! 31.11 IniertUllWNU Cotr/t!fI!tlCe 
0fI Soft""D1'"t! Engillt!t!ring. IC.<;E ·09, pages 485----495, Washington, OC, 
USA, 2009. IEEE Compukr Society. 
III I T. Kamiya, S. Kusumoto. and K. I"""",. CCFinder: A mullilinguislic 
token-h;a.'<Cd cock clone <lelCCtion syskm for louge scale soun:e cock. 
11::1:;1:; 1"ratUUCf;/?IU I .... Sn/IW<lf"t! EIIgin""ring. 28(7):654----670. 2002. 
1121 M. Kim. 1_ Bergman, T. Lau. and D. Notkin. An etlmogoaphic 
study .. f cupy and pa.~tt progr.mming Jlf".K.1K:e. in <><>pl. In ISES£ 
(#: Proceedinll' 0/ tile 2OfJ.I InlenwlilltUll S)'mposiwn QII Empirical Sn{/W(lF't! £J!gillt!t!r1ng, pages 83-92. W .... hin),'Ioo, DC, USA, 2004. [EEE 
Compute.- Society. 
r 131 M. Kim, V. Sa:caw_t D. NOlkin. and G. Murphy. An empirical study 
of code clone genealogies . In ESEClFSE·I1; Proc""dings 01 1M 
IOtil £uropt!lllf Sofj"~""t! Enginet!ring Con{tffl!fIU Mid joinl/)' "'ilh 13111 
ACM SIGSOfT Inlef1WliOtWI Symposium on fOutrtkuioru 01 Sofj,,-aF't! 
Engi"""rin g. pages 187-196, New York.. NY, USA. 2005. ACM. 
r 141 R. Komondoor and S. lforwib" ~ Semantics_preserving procedure ClIIIl1C­
lioo. In 1'01'1. 00: Proc""dingl of 1M 271h ACM SIGPI..AN-SIGACT" 
Sympos,·"m on Pri...:;ples of Programming lAnguages. pages IS5-I69, 
New York. NY. USA. 2(J(J(). ACM Press. 
]lSI 7~ Li. S. Lu. S. Myagmar. and Y. 71tou. Cp-miDeIC a tool for linding 
copy-paste aoo related hugs in """oating 5}'!'tem cock. In Pm<:eedings 
"I lire 6/11 ron/eF't!nCl! IHI Symposium Oft O~arling Syslem.J iHsign of: 
lmp/e_nl/l/;()tI -.."Iu_ 6. 05DI"04. pagel! 20----20. Berkeley, CA, USA, 
2004. USENIX As.wc;alioo. 
[161 N. Meng, M. Kim, and K. S. McKinley. Systematic editing: generating 
progrom transfonnations from an example. [n Procuding s 0/ lire 
32nd ACM SIGPU,N clJII/ullnctf UIl Progrumming language design ,urd 
imp/emt!nll lliUll. ['LDI '11, pages 329--342, New York. NY, USA, 2011. 
ACM. 
1171 N. Meng. M. Kim, and K. S. McKinley. Lase: localing and applyitlg 
syslematic edit~ by learning ff'Q1II e~alllp ies. In Procuding s ollhe 2013 
In/Un/llioMI CQIIle""nu on SoII"11F't! F",ginuring, ICSE ·13, pages 
502-SII, I'iscalaway. NJ. USA. 2013. IEEE Press. 
1181 8. Kay aoo M. Kim. A ca.o;c study ofcn>:S.~-.ystelll porting in forked 
projects. In I'roc~ t!dingJ "'( rile ACM SlGSOJ<T 20lh IntertUllimwl 
Sytnllllsium ",n 1M fOundalions of So(nmF't! En1l.illt!ering. FSE ·12, pag"" 
53:1-53:11. New Yon:. NY, USA. 2012. ACM. 
1191 B. Ray, C. Wiley. and M. Kim. Reper1uire: A cros.'<-sys tem porting 
analy$i$ 1001 for forked software projects. In FSE-20: ACM SIGSOfT 
1M 20tll IntertUll;DMJ Symposium /?II the I'oundLilinns nf Sofr-.."D~ 
Eng;lIt!tfring. ACM. 2012, to appear. 
1201 Ii M. Kiseman and A. R. Han ...... A conleJ<tuai poslp"-,ccssing symm 
for error com:clion u.~ing binary n·gr.uns. 1£££ ·Ira..... CompUl., 
23(S):4l!O--493, May 1974. 
121] J. Sliwer.<ki, T. Zimmennatln. and A. Zeller. When do changes induce 
lil<Cs? In J'roc""dinIlJ of tlte 2005 international worlcslwp on Mining 
W/I""Df"t! rrposi/()rit!S, MSR ·M. pages I-S, New York, NY. USA. 2OOS. 
ACM. 
1221 M. Weiser. I'rogr.utl slicing. In Pwcudinp o/IM 5111 inlt!nwlional CtJII­
/e~nCt! Oft Sn/I""/lF't! engintuing, ICSE '81. pages 43~9, Piscataway. 
NJ, USA, 1981. IEEE Press. 