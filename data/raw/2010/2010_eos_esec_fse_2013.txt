Identifying Message Flow in
Distributed Event-Based Systems
Joshua Garcia, Daniel Popescu, Gholamreza SaÔ¨Å,
William G.J. Halfond, and Nenad Medvidovic
Computer Science Department
University of Southern California
Los Angeles, CA, USA
{joshuaga,dpopescu,gsaÔ¨Å,halfond,neno}@usc.edu
ABSTRACT
Distributed event-based (DEB) systems contain highly-decoupled
components that interact by exchanging messages. This enables
Ô¨Çexible system composition and adaptation, but also makes DEB
systems difÔ¨Åcult to maintain. Most existing program analysis tech-
niques to support maintenance are not well suited to DEB systems,
while those that are tend to suffer from inaccuracy or make assump-
tions that limit their applicability. This paper presents Eos, a static
analysis technique that identiÔ¨Åes message information useful for
maintaining a DEB system, namely, message types and message
Ô¨Çow within a system. Eos has been evaluated on six off-the-shelf
DEB systems spanning Ô¨Åve different middleware platforms, and has
exhibited excellent accuracy and efÔ¨Åciency. Furthermore, a case
study involving a range of maintenance activities undertaken on
three existing DEB systems shows that, on average, Eos enables an
engineer to identify the scope and impact of required changes more
accurately than existing alternatives.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance, and
Enhancement; D.2.11 [ Software Architectures ]: Patterns
General Terms
Design, Experimentation
Keywords
distributed event-based systems, message Ô¨Çow, maintenance
1. INTRODUCTION
Distributed event-based (DEB) systems, developed using message-
oriented middleware (MOM) platforms, have become widespread.
In 2005, the market size for MOM licenses was about $1 billion [15];
by the end of the decade, the market for all middleware licenses was
Current afÔ¨Åliation: Google Inc, 340 Main St, Los Angeles, CA
90291, USA, popescu@google.com
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ESEC/FSE ‚Äô13, August 18-26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08 ...$15.00.nearly $20 billion, with MOM among the fastest growing middle-
ware platform types [11, 12]. One of the reasons for DEB systems‚Äô
popularity is that they are highly decoupled, which facilitates the
development of scalable, concurrent, and heterogeneous distributed
applications [17, 39, 22, 16]. To achieve this low coupling, the
components of a DEB system implicitly invoke other components
by publishing messages that a connector [40] routes to the correct
recipients; in turn, the recipient components may consume these
messages and perform some functionality in response.
Although implicit invocation provides many beneÔ¨Åts, it renders
themaintenance of DEB systems labor-intensive and error-prone
[24]. A major reason for this is that implicit invocation makes it dif-
Ô¨Åcult to determine the types of messages passed within a system and
where those messages will Ô¨Çow at runtime. In particular, two types
of programming practices lead to this difÔ¨Åculty: high-branching
invocation statements and ambiguous interfaces. A high-branching
invocation statement is a type of statement that may have multiple
targets at runtime. Such statements often stem from mechanisms
used to implement implicit invocations, such as callback functions
and reÔ¨Çection [24]. Prior work has demonstrated that identifying
the targets of high-branching invocation statements through manual
inspection is challenging [24], while existing automated program
analysis techniques are unable to compute that information accu-
rately [31]. This makes it difÔ¨Åcult for maintainers to determine the
impact of a change, identify dependencies between components,
and localize faults.
For DEB system maintenance, it is often necessary to know which
messages can be consumed by a component. However, components
in MOM-based DEB systems often rely on ambiguous interfaces .
An ambiguous interface accepts a single, abstract message type
and requires that a component internally Ô¨Ålter and dispatch each
message based on the message‚Äôs attributes [19]. This complicates
maintenance because examining the entry point of a message does
not reveal explicit type information about the message ‚Äî only that
the generic message type is consumed. Instead, the maintainer
must infer this information by other means, such as examining the
operations performed on a consumed message.
Researchers have recognized the need for automated support
of DEB system maintenance. However, existing techniques have
limitations that affect their accuracy and/or applicability to MOM
systems. For example, a suite of analysis techniques has focused on
improving the performance of DEB systems [23]. However, these
techniques rely on a set of added, specialized programming language
features [18] and do not handle the ambiguous interfaces prevalent
in MOM-based systems. Another technique, LSME [30], uses
developer-provided regular expressions to identify message types.
However, this technique neither identiÔ¨Åes the speciÔ¨Åc attributes thatPermission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSE‚Äô13 , August 18‚Äì26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08...$15.00
http://dx.doi.org/10.1145/2491411.2491462
367deÔ¨Åne a message type nor computes how messages may Ô¨Çow within
a component. Our prior work, Helios [32], is a semi-automated
technique that improves on LSME by using developer-provided
annotations to identify message Ô¨Çow within a component. Like
LSME, however, Helios is unable to identify the attributes that
uniquely identify each message type.
To address the limitations of existing approaches, we have de-
veloped a new technique, Eos, that automatically identiÔ¨Åes a DEB
system‚Äôs message properties, speciÔ¨Åcally, the system‚Äôs message
types and message Ô¨Çow. The key insight underlying our work is
that these message properties can be identiÔ¨Åed by analyzing a DEB
system‚Äôs implementation and aggregating ‚Äúmessage-revealing‚Äù in-
formation deÔ¨Åned by statements along different possible execution
paths. Our approach leverages this insight to fully automate the iden-
tiÔ¨Åcation of message information via a static program analysis. Our
evaluation of Eos on six existing DEB systems shows that our tech-
nique is both accurate and fast. Eos averaged over 90% precision
and recall of the subject systems‚Äô message types and dependencies,
and could analyze each system in about a minute. Furthermore, a
case study involving a range of maintenance activities undertaken
on three existing DEB systems shows that, on average, Eos enables
an engineer to identify the scope and impact of required changes
more accurately than existing alternatives.
The remainder of the paper is organized as follows. Section 2
discusses how modern DEB systems are typically implemented and
existing challenges for identifying message Ô¨Çow in DEB systems.
Section 3 describes how Eos addresses these challenges. Section 4
presents our evaluation results. Section 5 overviews the relevant
related work. Section 6 presents our conclusions.
2. BACKGROUND AND MOTIV ATION
A distributed event based (DEB) system consists of components
that send and receive messages in response to events that occur in
the system [29]. Components in DEB systems communicate via
two types of message interfaces: the message source is the interface
that publishes a message, while the message sink is the interface
that consumes a message. To publish a message, a DEB component
passes an instance of the MOM‚Äôs message type to a message source;
and to consume a message, the component provides a method whose
input parameter is the MOM‚Äôs message type. The speciÔ¨Åc API
a component must implement or use for the sinks and sources is
typically deÔ¨Åned by the underlying MOM platform‚Äôs abstract base
component class. Similarly, the message types either implement or
extend the MOM platform‚Äôs base message type.
Figure 1 shows the partial implementation in Java of two sim-
ple DEB components, an adder (lines 1-26) and a printer (lines
28-31). Both extend the MOM‚Äôs abstract base component class
Component and provide an implementation of the message sink in-
terface, consume . The parameter to consume is of type Message ,
which is the MOM‚Äôs base message type. Component DEBAdder re-
ceives a message at line 4, checks whether its name attribute is ‚Äúadd",
and, if so, calls the addmethod to perform the addition. The result
of the addition is published by calling the pubmethod, which wraps
a call to the MOM‚Äôs message source interface, publish .DEBAdder
can also receive messages whose name attribute is ‚ÄúresultRequest",
for which it creates and then publishes an instance of the MOM‚Äôs
base message type that contains the previously calculated sum value
(‚ÄúlastResult"). The DEBPrinter component consumes messages
whose name attribute is ‚ÄúlastResult".
There are three different mechanisms for deÔ¨Åning message types
in modern DEB systems: attribute-based, nominal, and subject-
based [29]. Attribute-based message types, which are deÔ¨Åned as sets
of named attributes, are used in Figure 1. By convention, a message1public class DEBAdder extends Component{
2 private BigInteger sum = null ;
3 private String sumStr = "sum";
4 public void consume(Message m) {
5 String nameAttr = (String)m.getAttr("name");
6 if("add".equals(nameAttr))
7 { Message sumMsg = this .add(m);
8 this .pub(sumMsg); }
9 else if ("resultRequest".equals(nameAttr))
10 {if(sum != null )
11 { Message m2 = new Message();
12 m2.setAttribute("name", "lastResult");
13 m2.setAttribute(sumStr, sum);
14 this .pub(m2); }}}
15
16 private Message add(Message m3){
17 Integer n1 = m3.getAttr("num1");
18 Integer n2 = m3.getAttr("num2");
19 sum = n1 + n2;
20 Message m4 = new Message();
21 m4.setAttribute("name", "currentSum");
22 m4.setAttribute(sumStr, sum);
23 return m4;}
24
25 private pub(Message m){
26 publish(m);}
27
28public class DEBPrinter extends Component{
29 public void consume(Message m){
30 String nameAttr = m.getAttr("name");
31 if("lastResult".equals(nameAttr){...}}}
Figure 1: The DEBAdder andDEBPrinter components
type has a special attribute that names the message, which we refer
to as the ‚Äúname‚Äù attribute. Nominal message types are explicitly
declared in the underlying programming language‚Äôs type system.
For example, a class called Addthat inherits from the class Message
would be a nominal message type. In subject-based message typing,
each message type is deÔ¨Åned via a pre-determined string subject
Ô¨Åeld. An example is a message with a ‚Äúsubject‚Äù Ô¨Åeld whose value is
‚Äú/Message/Add‚Äù. Both nominal and subject-based message types can
be represented as attribute-based types: for subject-based messages,
a corresponding attribute-based type has an attribute to represent
the subject Ô¨Åeld; for nominal types, a corresponding attribute-based
message type has an attribute to represent the programming lan-
guage class of the nominal type. Therefore, for simplicity of the
explanation, we restrict our discussion in the rest of this paper to
attribute-based messages. However, it is important to note that our
technique is not limited to attribute-based messages. In fact, two
of the MOM platforms used in our evaluation (Section 4) support
nominal message typing.
The message types in a given DEB system can be divided into
published message types (PMTs), which are the types sent via a
message source interface, and consumed message types (CMTs),
which are the types received via a message sink interface. An exam-
ple PMT published at line 8 is tsum f(‚Äúname ‚Äù;‚ÄúcurrentSum ‚Äù);
(‚Äúsum‚Äù;e)g; an example CMT of DEBAdder is tadd f(‚Äúname ‚Äù;
‚Äúadd‚Äù);(‚Äúnum1‚Äù;e);(‚Äúnum2‚Äù;e)g. Note that edenotes an unknown
value. A message type, such as tlast=f(‚Äúname ‚Äù;‚ÄúlastResult ‚Äù);
(‚Äúsum‚Äù;e)g, can be both a PMT and a CMT since it is published by
DEBAdder at line 14 and consumed by DEBPrinter at line 31.
There are two types of relationships between PMTs and CMTs:
anintra-Ô¨Çow dependency represents a relationship where a PMT
may be published by a given component as the result of the compo-
nent‚Äôs consumption of a CMT; an inter-Ô¨Çow dependency represents
a relationship where a PMT may be published by one component
and then consumed by another component. In DEBAdder, an intra-368Ô¨Çow dependency exists between taddandtsumsince the consumption
oftaddleads to the publication of tsumat line 8. An inter-Ô¨Çow de-
pendency exists between DEBAdder and DEBPrinter since tlast,
published at line 14, can be consumed at line 31 of Figure 1.
As mentioned in Section 1, identifying the types and Ô¨Çow of
messages is difÔ¨Åcult due to the use of ambiguous interfaces and
implicit invocation [24]. Ambiguous interfaces in DEB systems
make it difÔ¨Åcult to identify the message types that can be published
or consumed at a given source or sink. For example, consider
the two message interfaces shown in Figure 1, consume(Message
m)andpublish(Message m) . These interfaces only indicate that
the consumed and published types are of the base type Message .
However, from our inspection of the code, we know that the types
are actually taddandtlast. Similarly, implicit invocation makes it
difÔ¨Åcult to identify message Ô¨Çow. For example, without knowing
the message types present at lines 26 and 29 of Figure 1, it would
be challenging for a software maintainer to determine whether there
exists an inter-Ô¨Çow dependency among these statements, as there is
no explicit deÔ¨Ånition of the relationship in the code.
Simple and straightforward solutions are unlikely to remedy
this problem or would result in crude estimates of the correct re-
lationships. For example, a naive solution for identifying mes-
sage types would be to convert them all to nominal types (e.g.,
consume(AddMsg m) andpublish(LastResult m) ). This would
allow one to subsequently leverage explicit subtyping relationships
among the resulting nominal types. However, even if a MOM plat-
form were to provide such interfaces, the underlying programming
languages would still be unable to support dynamic dispatch of
appropriate messages to these more speciÔ¨Åc interfaces [14]. Sim-
ilarly, one can simply assume that all message sources could be
connected to all message sinks, but this would result in signiÔ¨Åcant
over-approximation of the message Ô¨Çows.
A key insight underlying our approach is that message types and
their relationships can be identiÔ¨Åed through systematic analysis
of a DEB system‚Äôs components. By focusing on certain kinds of
statements, which we call message revealing statements, we are able
to identify useful information about the message attributes that make
up a message type. By themselves, these statements do not give us a
complete picture; but by combining and aggregating the information
along control-Ô¨Çow paths that originate from message sources or
terminate at message sinks, we can identify message types. For
example, consider the CMT taddat line 6. Here we can see that
along the path where the condition at line 6 is true, a message object
originating from the message sink is assumed to have an attribute
‚Äúname‚Äù with the value ‚Äúadd‚Äù, and then also the attributes ‚Äúnum1‚Äù and
‚Äúnum2,‚Äù which are accessed at lines 17-18. Similarly, consider the
PMT tlast, created at line 11. Along a path containing lines 11-14,
the message object published at line 14 is created at line 11 and has
two attributes, ‚Äúname" and ‚Äúsum", added on lines 12-13 before it is
published. Identifying these message types also allows us to identify
Ô¨Çows and relationships among the statements that deÔ¨Åne a message
type. In Section 3, we describe how we formalize this intuition to
create an automated analysis that is able to detect message types
and Ô¨Çows in a DEB system.
3. DEB SYSTEM ANALYSIS IN EOS
Eos is a static analysis technique for identifying (1) attribute-
based message types and (2) message Ô¨Çow in DEB systems. The
input to Eos is the implementation of the DEB system and a speciÔ¨Å-
cation of the underlying MOM‚Äôs API. This speciÔ¨Åcation comprises
the generic message class; methods that access and modify a mes-
sage or its attributes; and, for MOMs that support attribute-based
message types, the name of the special attribute that denotes a mes-sage name. From our experience, all major MOM frameworks
provide APIs for this functionality and the speciÔ¨Åcation needs to
only be performed once per MOM API. The output of Eos is the
DEB system‚Äôs Message Flow Graph (MFG), which shows the sys-
tem‚Äôs message types and the relationships between those types. The
MFG is a directed graph (C;P;E), where Cis the set of consumed
message types (CMTs), Pis the set of published message types
(PMTs), and Eis the set of directed edges representing intra-Ô¨Çow
(CP)dependencies and inter-Ô¨Çow (PC)dependencies.
Eos consists of two core analyses, Ô¨ÅndCMT , which computes
CMTs and Ô¨ÅndPMT , which computes PMTs. Both analyses are
deÔ¨Åned as summary-based iterative data-Ô¨Çow analyses that prop-
agate message-Ô¨Çow information extracted from different types of
message revealing statements. The analyses assume that aliases can
be resolved precisely. Each analysis propagates the message-Ô¨Çow
information using four data-Ô¨Çow sets [5] for each statement sin
a system‚Äôs implementation: in[s]contains information that Ô¨Çows
along a program path to s;gen[s]contains information that is gener-
ated at s;kill[s]stores information that is no longer valid because of
information generated at s; and out[s]stores information that Ô¨Çows
tos‚Äôs successors. All four data-Ô¨Çow sets are initially empty. As
detailed in Sections 3.1 and 3.2, the analyses update the data-Ô¨Çow
sets for each statement in a method until a Ô¨Åxed point is reached.
Both Ô¨ÅndCMT andÔ¨ÅndPMT compute a summary of each method
in a DEB component. The method summary describes the message-
Ô¨Çow information that can be inferred from a method. Method sum-
maries make Eos‚Äôs analyses inter-procedural, thus allowing an entire
DEB application to be analyzed. Methods are analyzed in reverse
topological order with respect to the DEB component‚Äôs call graph
so that a given method‚Äôs summary is computed before any methods
that call it are analyzed. Cycles in the call graph (e.g., from recur-
sion) are handled in the standard manner, by treating the involved
methods as one ‚Äúsuper method.‚Äù
In both analyses, Eos must calculate the names of attributes and
the value of the special message-name attribute. To do this, Eos
uses string constant propagation, which provides a precise solution
since, by convention, DEB systems use constant strings to deÔ¨Åne
these values. Eos does not calculate the value of other attributes,
and we use eto denote these unknown values. Eos stores attribute
information in two sets, Attr andTypeHier .Attr is a set of pairs
(t;(name ;value)), where tis a message type and (name ;value)is
the name and value of one of t‚Äôs attributes. TypeHier is a set of
message type pairs, (t;t0), where t0extends tby including all of t‚Äôs
attributes and a new attribute name-value pair.
Next, we deÔ¨Åne the analysis for identifying CMTs (Section 3.1)
and describe the key steps of the analogous analysis for identifying
PMTs (Section 3.2). We then discuss how the CMTs and PMTs are
used to identify message-Ô¨Çow dependencies (Section 3.3).
3.1 Identifying Consumed Message Types
The Ô¨ÅndCMT analysis is shown as Algorithm 1 and computes
the information needed to identify a DEB component‚Äôs CMTs. The
input to Ô¨ÅndCMT is a single method of a DEB component and its out-
puts are the Attr,TypeHier , and insets. To compute CMTs, Ô¨ÅndCMT
identiÔ¨Åes and tracks three types of Consumed Message Revealing
(CMR) statements ‚Äî CMR-entry, CMR-attr, and CMR-invoke. To-
gether, these statements identify the message types entering methods
and the attributes that could be contained in those message types.
Eos uses the information extracted from these statements to identify
the attributes of each CMT.
CMR-entry statements are points at which messages enter a
method. Ô¨ÅndCMT creates a reference-type pair to track each mes-
sage that originates from a CMR-entry. A reference-type pair is an369Algorithm 1: Ô¨ÅndCMT
Input :meth2Methods
Output :Attr ;TypeHier ;in
1gen[entry] =f(p;tentry)jp2P^typeOf (p) =Messageg
2workList fentry of method methg
3repeat
4s Ô¨Årst statement of workList
5match sdo
6 case ‚Äúif(rv:equals (rattrVal))f: : :g‚Äù
7 foreach (r;attrName )2getAttrInfo (rattrVal)do
8 handleCMRAttr (s;r;attrName ;rv)
9 case ‚ÄúrattrVal=r:getAttribute (attrName );‚Äù
10 handleCMRAttr (s;r;attrName ;e)
11 case ‚Äúif(r:hasAttribute (attrName ))f: : :g‚Äù
12 handleCMRAttr (s;r;attrName ;e)
13 case ‚Äúr=f(A);‚Äù
14 updateSets (gen[s];Attr ;TypeHier ;
A;summary (f))
15 kill[s] f(r;ti)j(r;ti)2in[s]^i2Stmtsg
16 case ‚Äúri=rj;‚Äù
17 gen[s] f(ri;tk)j(rj;tk)2in[s]^k2Stmtsg
18 kill[s] f(ri;tk)j(ri;tk)2in[s]^k2Stmtsg
19 case ‚Äúreturn ri;‚Äù
20 kill[s] f(r;tj)j(r;tj)2in[s]^r6=ri^j2Stmtsg
21 out[s] (in[s]nkill[s])[gen[s]
22 foreach s02succ(s)doin[s0] in[s0][out[s]
23 foreach s02succf(s)doin[s0] in[s0][in[s]
24 workList workList[fs0j(s02
succ(s)[succf(s))^changed (in[s0])g
25until workList =/0
Procedure 1: handleCMRAttr(s, r, attrName, val)
Input :s2Stmts ;r;attrName ;val
1TypeHier TypeHier[f(ti;ts)j(r;ti)2in[s]^i2Stmtsg
2Attr Attr[f(ts;(attrName ;val))j(ti;ts)2TypeHier^i2Stmtsg
3gen[s] f(r;ts)j(r;ti)2in[s]^i2Stmtsg
4kill[s] f(r;ti)j(r;ti)2in[s]^i2Stmtsg
ordered pair (r;ti)where ris a reference to a message object and
tirepresents the message type assigned to that object. We use the
subscript ito denote the line number at which the message type t
originated. All four data-Ô¨Çow sets ( in,out,gen, and kill) propagate
reference-type pairs. At line 1 of Algorithm 1, Ô¨ÅndCMT creates a
reference-type pair (p;tentry)for each parameter pof type Message
in method meth ‚Äôs parameters P. These reference-type pairs are
added to gen[entry]so that they will be propagated to other CMR
statements. For example, for the method entry at line 4 of Figure 1,
gen[entry] =f(m;t4)g.
CMR-attr statements perform operations on an attribute of a
message object. Ô¨ÅndCMT can identify attribute information by
correlating these operations with the statement‚Äôs reaching reference-
type pairs, i.e., reference-type pairs that Ô¨Çow into the statement via
itsinset. There are three variants of CMR-attr statements: (1) if
statements that check whether an attribute has a particular value, (2)
statements that retrieve an attribute from a message object, and (3)
ifstatements that check whether a message object has an attribute.
The Ô¨Årst CMR-attr variant, handled at line 6 of Algorithm 1,
allows Ô¨ÅndCMT to infer the value of an attribute, the name of that
attribute, and the message type to which that attribute belongs. The
Ô¨Årst CMR-attr variant checks if an attribute, referenced by rattrVal ,
has a predetermined value, referenced by rv. An example of this
variant appears at line 6 of Figure 1, where the predetermined value
‚Äúadd" is compared to the value of the attribute reference nameAttr .
From this CMR-attr variant, Ô¨ÅndCMT can infer that the value of the
attribute referenced by nameAttr is equal to ‚Äúadd" along one pathoriginating from the CMR-attr statement and is not equal to ‚Äúadd"
along the other path.
Handling the Ô¨Årst variant of CMR-attr statements involves three
steps: (1) identify the name and value of the attribute correspond-
ing to rattrVal as well as the reference to the attribute‚Äôs containing
message object, (2) create a new message type from the identiÔ¨Åed
attribute information, and (3) propagate different information along
the two branches originating from the CMR-attr statement. In the
Ô¨Årst step, Ô¨ÅndCMT looks for deÔ¨Ånitions of rattrVal by traversing
all of its deÔ¨Ånition-use chains. SpeciÔ¨Åcally, getAttrInfo traverses
each deÔ¨Ånition-use chain of rattrVal until it reaches a call of the
form r:getAttribute (attrName ), at which point it adds a pair (r;
attrName )to its result set. This internal logic of getAttrInfo is
straightforward and is thus elided from Algorithm 1. For the exam-
ple at line 6 of Figure 1, the call to getAttrInfo (nameAttr )returns
(m;‚Äúname ‚Äù).
The second step begins once getAttrInfo has identiÔ¨Åed all deÔ¨Åni-
tions of rattrVal .Ô¨ÅndCMT iterates over getAttrInfo ‚Äôs result set and
calls handleCMRAttr (Procedure 1), which creates new message
types from the identiÔ¨Åed attribute information. For the example
at line 6 of Figure 1, Ô¨ÅndCMT calls handleCMRAttr with ( 6;m;
‚Äúname ‚Äù;‚Äúadd‚Äù). The in[6] set contains (m;t5)as the sole reaching
reference-type pair. handleCMRAttr creates a new message type t6
from t5and records this by adding (t5;t6)toTypeHier .handleCM-
RAttr also updates Attrwith(t6;(‚Äúname ‚Äù;‚Äúadd‚Äù)to match the newly
created type with the identiÔ¨Åed attribute information. Finally, han-
dleCMRAttr creates a new reference-type pair (m;t6), adds (m;t6)to
gen[6], and adds (m;t5)tokill[6].
In the third step, Ô¨ÅndCMT uses branch-sensitive transfer func-
tions [8, 9] to propagate the new reference-type pairs along one
branch of the CMR-attr statement but not along the other branch.
At line 22 of Algorithm 1, Ô¨ÅndCMT propagates the newly gener-
ated reference-type pairs to the inset of the CMR-attr‚Äôs successor
statement on the true branch. So at line 6 of Figure 1, Ô¨ÅndCMT
propagates (m;t6)along the true branch to in[7]. At line 23 of Algo-
rithm 1, Ô¨ÅndCMT propagates the CMR-attr statement‚Äôs unmodiÔ¨Åed
reaching reference-type pairs to the inset of its successor on the
false branch. So at line 6 of Figure 1, Ô¨ÅndCMT propagates (m;t5)
along the false branch to in[9].
The second variant of CMR-attr, identiÔ¨Åed at line 9 of Algorithm
1, allows Ô¨ÅndCMT to infer the name of an attribute and the message
type to which that attribute belongs. SpeciÔ¨Åcally, this CMR-attr
variant retrieves the attribute‚Äôs name, attrName , from the message
object referred to by r.Ô¨ÅndCMT can infer that all message types
paired with rin the CMR-attr statement‚Äôs reaching reference-type
pairs are expected to contain the retrieved attribute, attrName . As in
the previous variant, Ô¨ÅndCMT calls handleCMRAttr ; however, no
attribute value information is provided in this case and the unknown
value, e, is passed to handleCMRAttr instead. Since this variant of
CMR-attr is not contained within an ifstatement, all of the new
reference-type pairs are propagated to the inset of s‚Äôs successor by
line 22 of Algorithm 1 ( succf(s)is undeÔ¨Åned for non-branching
statements).
To illustrate, consider the CMR-attr statement at line 5 of Figure 1.
To analyze the statement, Ô¨ÅndCMT calls handleCMRAttr with the
arguments (5;m;‚Äúname ‚Äù;e). The sole reaching reference-type pair
for line 5 is (m;t4), sohandleCMRAttr adds(t4;t5)toTypeHier . The
Attr set is updated with (t5;(‚Äúname ‚Äù;e)). Finally, gen[5]is set to
f(m;t5)gandkill[5]is set tof(m;t4)g. The transfer function at line
22 of Algorithm 1 propagates (m;t5)toin[6].
The third variant of CMR-attr, handled at line 11 of Algorithm 1,
accounts for ifstatements that check whether a message object re-
ferred to by rhas an attribute named attrName . From this CMR-attr370statement, Ô¨ÅndCMT can infer that, along one path originating from
the statement, all message types associated with rin the reaching
reference-type pairs contain this attribute and, along the other path,
they do not. Ô¨ÅndCMT handles this CMR-attr statement by (1) cre-
ating, for each reaching reference-type pair that contains r, a new
message type that includes the attribute (as is done with the second
CMR-attr variant), and (2) propagating branch-sensitive information
(as is done with the Ô¨Årst variant).
CMR-invoke statements, handled at line 13 of Algorithm 1, are
invocations of DEB component methods. At the point of each CMR-
invoke, Ô¨ÅndCMT incorporates information from the summary of
the invocation‚Äôs target method. A method‚Äôs summary comprises
the contents of the Attr,TypeHier , and outsets of the method‚Äôs
exit point. If any of these sets include message types deÔ¨Åned by the
method‚Äôs formal parameters, then that means the CMR statements in
the method operate on the arguments provided by the CMR-invoke.
To account for the actions within the target method, updateSets
substitutes the message types of the CMR-invokes‚Äôs arguments for
the message types deÔ¨Åned by the corresponding formal parameters
in the summary. The target method‚Äôs summary is then used to
update the Attr,TypeHier , and gensets of the statement containing
the CMR-invoke.
To illustrate, consider the CMR-invoke statement at line 7 of
Figure 1. The summary of the invoked method add, whose imple-
mentation starts on line 16 of Figure 1, is: Attr f(t17;(‚Äúnum1‚Äù;
e));(t18;(‚Äúnum2‚Äù;e))g;TypeHier f(t16;t17);(t17;t18)g; and
out[add exit] /0.t16is highlighted because it is the message type
referred to by add‚Äôs formal parameter m3, and will be substituted
with a message type from an argument at a call site. In this case,
the argument provided by the CMR-invoke, m, has a message type
oft6, which will be substituted for t16.updateSets performs this
substitution, sets gen[7]toout[add exit], and adds the summary‚Äôs Attr
andTypeHier sets to the corresponding sets in Ô¨ÅndCMT .
The last two case blocks in Algorithm 1 handle assignment and
return statements. Line 16 handles assignment statements by up-
dating the statement‚Äôs genandkillsets so that message reference
ripoints to all the message types pointed to by rjand the reaching
reference-type pairs involving riare no longer propagated. Line 19
of Algorithm 1 handles return statements by updating the killset of
the statement so that only the reaching reference-type pairs refer-
enced by riare allowed to propagate beyond the return statement.
Ô¨ÅndCMT analyzes each method in the DEB component once
and the analysis of each method terminates when the worklist is
empty. Since Ô¨ÅndCMT only adds items to the worklist when an
inset changes, termination occurs when all insets have reached a
Ô¨Åxed point. The insets will reach a Ô¨Åxed point because there is a
Ô¨Ånite upper bound on each inset‚Äîthe set of all reference-type pairs
deÔ¨Åned in the method‚Äîand each iteration of the algorithm causes
theinset to monotonically grow with new reference-type pairs. In
general, iterative data Ô¨Çow analysis is O(n2), but with the optimal
statement traversal it can be O(cn)where cis the maximum loop
nesting depth in the method‚Äôs control Ô¨Çow graph. The DU chains
used by getAttrInfo can be pre-computed for each method in O(n2)
using standard reaching deÔ¨Ånition [5].
After Ô¨ÅndCMT analyzes all methods of a DEB component, Eos
identiÔ¨Åes the attributes of each CMT by using the information con-
tained in the AttrandTypeHier sets. By deÔ¨Ånition, a CMT originates
from a message sink interface. Therefore, Eos identiÔ¨Åes the mes-
sage type tsinkdeÔ¨Åned at the message sink, extracts each sequence
of pairs in TypeHier that extend tsink, and Ô¨Ånds their correspond-
ing attributes in Attr. For example, consider the type t18. The
set of pairs in TypeHier that extends t18isf(t4;t5);(t5;t6);(t6;t17);
(t17;t18)g, where t4=tsink. For these message types, the relevantAlgorithm 2: Ô¨ÅndPMT
Input :meth2Methods ;Attr ;TypeHier ;inc
Output :Attr ;PubTypes ;TypeHier
1workList fentry of method methg
2gen[entry] =f(p;tentry)jp2P^typeOf (p) =Messageg
3repeat
4s Ô¨Årst statement of workList
5in[s] =S
p2pred(s)out[p]
6match sdo
7 case ‚Äúr=createMessage ();‚Äù
8 gen[s] f(r;ts)g
9 kill[s] f(r;ti)j(r;ti)2in[s]^i2Stmtsg
10 case ‚Äúr :setAttribute (attrName ;val);‚Äù
11 TypeHier TypeHier[f(ts;ti)ji2Stmts^(r;
ti)2inc[s][in[s]g
12 Attr Attr[f(ts;(attrName ;val))j(ts;ti)2TypeHierg
13 gen[s] f(r;ts)j(r;ti)2in[s][inc[s]^i2Stmtsg
14 kill[s] f(r;ti)j(r;ti)2in[s][inc[s]^i2Stmtsg
15 case ‚Äúpublish (r);‚Äù
16 PubTypes PubTypes[f(ti;s)ji2Stmts^(r;
ti)2in[s][inc[s]g
17 case ‚Äúr=f(A);‚Äù
18 updateSets (gen[s];Attr ;TypeHier ;PubTypes ;A;
summary (f))
19 kill[s] f(r;ti)j(r;ti)2in[s]^i2Stmtsg
20 case ‚Äúri=rj;‚Äù
21 gen[s] f(ri;tk)j(rj;tk)2in[s]^k2Stmtsg
22 kill[s] f(ri;tk)j(ri;tk)2in[s]^k2Stmtsg
23 case ‚Äúreturn ri;‚Äù
24 kill[s] f(rj;ti)j(rj;ti)2in[s]^ri6=rj^i2Stmtsg
25
26 out[s] (in[s]nkill[s])[gen[s]
27 workList workList[fs0js02succ(s)^changed (out[s])g
28until workList =/0
set of pairs in Attrisf(t5;(‚Äúname ‚Äù;e));(t6;(‚Äúname ‚Äù;‚Äúadd‚Äù));(t17;
(‚Äúnum1‚Äù;e));(t18;(‚Äúnum2‚Äù;e))g.t4has no attributes. Thus, the
attributes of t18extracted by Eos are f(‚Äúname ‚Äù;‚Äúadd‚Äù);(‚Äúnum1‚Äù;
e);(‚Äúnum2‚Äù;e)g. Note that, for a given type t0created from t, the
value of each attribute of t0(e.g., (‚Äúname ‚Äù;‚Äúadd‚Äù)) takes precedence
over prior values of the same attribute (in this case, (‚Äúname ‚Äù;e)).
3.2 Identifying Published Message Types
The Ô¨ÅndPMT analysis is shown in Algorithm 2 and computes
the information needed to identify a DEB component‚Äôs PMTs. The
algorithm takes as its input a single method of a DEB component
and the Attr,TypeHier , and insets computed by Ô¨ÅndCMT ; for clarity,
in this section we denote the latter as inc.Ô¨ÅndPMT utilizes the inc
set in addition to its own inset since a CMT can be published after
it is consumed. The outputs of Ô¨ÅndPMT are updated versions of the
AttrandTypeHier sets and a new set called PubTypes .PubTypes is
a set of pairs (ti;l), where tiis a PMT that originated on line iof the
program, while ldenotes the line where the type is published.
To compute PMTs, Ô¨ÅndPMT identiÔ¨Åes and tracks four types
ofPublished Message Revealing (PMR) statements : PMR-create,
PMR-attr, PMR-publish, and PMR-invoke. Together, these state-
ments identify the message types created in methods, the attributes
that could be contained in those message types, and which of these
types are published. In the remainder of this section, we elaborate
on the four types of PMR statements.
PMR-create statements initialize a reference to an object of type
Message . There are two variants of PMR-create : statements that
explicitly create a new instance of Message via a method (e.g.,
newinstructions or factory methods), and statements that implicitly
create such instances via the list of formal parameters to a method.371An example of the Ô¨Årst PMR-create variant is shown on line 20 of
Figure 1. The addmethod‚Äôs declaration on line 16 of Figure 1 is
an example of the second PMR-create variant. Algorithm 2 tracks
references to message objects identiÔ¨Åed at PMR-create statements to
determine when new attributes are added to the message objects via
PMR-attr statements or when they are published via PMR-publish
statements. The two variants are handled at lines 7 and 2 of Ô¨ÅndPMT ,
respectively.
APMR-attr statement adds an attribute to a message object and
is handled at lines 10‚Äì14 of Algorithm 2. These statements are
analogous to CMR-attr statements, and allow Ô¨ÅndPMT to infer the
set of attributes that are added to a message type by extending
each of the PMR-attr‚Äôs reaching reference-type pairs with the newly
identiÔ¨Åed attribute. To illustrate, consider the PMR-attr statement
at line 21 of Figure 1. At that line, Ô¨ÅndPMT determines that any
messages type referred to by message object m4has the attribute
(‚Äúname ‚Äù;‚ÄúcurrentSum ‚Äù).
PMR-publish statements allow Ô¨ÅndPMT to infer which message
types are actually published. PMR-publish statements are han-
dled at line 15 of Ô¨ÅndPMT . All message types in the PMR-publish
statement‚Äôs reaching reference-type pairs that correspond to the pub-
lished reference ( r) are PMTs. These PMTs are added to the the
PubTypes set. For example, line 26 of Figure 1 is a PMR-publish
statement. Ô¨ÅndPMT determines that any message types referenced
bymare PMTs and are added to the PubTypes set.
PMR-invoke statements, handled at line 17 of Ô¨ÅndPMT , are invo-
cations of DEB component methods. These are handled in a similar
way to CMR-invoke statements. The only difference is that the
method summaries also include the PubTypes set, which is handled
in the same way as the Attr,TypeHier , and outsets.
To illustrate, consider the PMR-invoke statement at line 7 of
Figure 1. The summary of method addallows Ô¨ÅndPMT to infer
that the message type referred to by sumMsg at line 7 of Figure
1 has the attributes (‚Äúname ‚Äù;‚ÄúcurrentSum ‚Äù)and(‚Äúsum‚Äù;e). Line
8 of Figure 1 shows a PMR-invoke statement where the message
types in the summary depend on the arguments at the call site of
an invoked method. This statement calls the method pub, whose
summary indicates that message types referred to by mare PMTs.
updateSets identiÔ¨Åes sumMsg as the argument corresponding to the
formal parameter mofpuband adds any message types referred to
bysumMsg to the PubTypes set, which indicates that those types are
PMTs.
The last two case blocks in Algorithm 2 handle assignment and
return statements in the same way as Ô¨ÅndCMT . Line 20 ensures that
reference-type pairs are propagated properly when references are
copied. Line 23 ensures that only the reaching reference-type pairs
relevant to the returned reference Ô¨Çow out of it.
The runtime and termination conditions of Ô¨ÅndPMT are analogous
toÔ¨ÅndCMT . After Ô¨ÅndPMT completes the processing of all methods
of a DEB component, the PubTypes set contains reference-type
pairs that can be used to compute the PMTs. This is done using the
attribute information from the AttrandTypeHier sets in the same
manner as described in Section 3.1.
3.3 Identifying Message Dependencies
Eos identiÔ¨Åes intra-Ô¨Çow dependencies by combining the con-
sumed and published message type information for a DEB compo-
nent. An intra-Ô¨Çow dependency exists when a message type may
be published by a given component as a result of having consumed
another type. More precisely, when a set of CMTs, TC, Ô¨Çows into a
PMR-publish statement that publishes the set of message types TP,
then the intra-Ô¨Çow dependencies for that PMR-publish statement
comprise all edges in the set TCTP. The identiÔ¨Åcation process forTCandTPis as follows. For each PMR-publish statement at line l
of the DEB system‚Äôs implementation, Eos identiÔ¨Åes all of the pairs
(ti;l)inPubTypes . The set of all message types tipublished at lis
TP. Eos then examines the inc[l]set for the statement at lto identify
all message types TCthat Ô¨Çow into the corresponding statement as
part of its reaching reference-type pairs.
To illustrate, consider the PMR-publish at line 8 of Figure 1,
which publishes message type t22. The inc[22]set has the reference-
type pair (m3;t18), which indicates that t18Ô¨Çows to the statement
where t22is published. Therefore, Eos creates the intra-Ô¨Çow depen-
dency (t18;t22). Other intra-Ô¨Çow dependencies for the DEBAdder
component in Figure 1 are computed in an analogous manner. The
resulting dependency chains allow Eos to transitively establish the
dependency between (m;t4)and(m;t25), i.e., to relate the message
referenced by mthat is consumed at DEBAdder‚Äôs sink on line 4
with the message referenced by mthat is published by DEBAdder‚Äôs
source on line 26.
Eos creates inter-Ô¨Çow dependencies by matching PMTs of a com-
ponent with CMTs of another component. For a given PMT p
and CMT c, an inter-Ô¨Çow dependency from ptocis created iff
attrib (p)attrib (c), where attrib is a function that returns the set
of attribute names of a message type as well as the value of the
special message-name attribute. This relationship ensures that a
component will not attempt to access attributes that are not present
in a message it receives [39]. Eos computes the inter-Ô¨Çow dependen-
cies by comparing all published and consumed messages to deter-
mine whether this relationship holds. For the example in Figure 1,
the only inter-Ô¨Çow dependency is (t13;t31), where t13=f(‚Äúname ‚Äù;
‚ÄúlastResult ‚Äù);(‚Äúsum‚Äù;e)gandt31=f(‚Äúname ‚Äù;‚ÄúlastResult ‚Äù)g.
Note that Eos considers only the names, and not the types, of the
published ( p) and consumed ( c) messages‚Äô attributes. An obvious
alternative is to consider the attributes‚Äô types as well: an attribute
that has been set in a component that publishes pcan only be prop-
erly processed by a component that consumes cif the attribute‚Äôs
type in p(e.g,. integer) is the same as or a subtype of the attribute‚Äôs
type in c(e.g., Ô¨Çoat). This alternative is more conservative and
avoids recording potentially spurious dependencies in the case of
attributes that have identical names but unrelated types. Eos can be
extended to provide this additional attribute-type analysis. However,
we opted for the name-only alternative, because it can aid developers
in system veriÔ¨Åcation: if Eos does not record dependencies between
components that are intended to interact but whose corresponding
attributes have unintentionally been assigned different types, devel-
opers will not be alerted that such dependencies, in fact, exist and
will have to localize any resulting runtime errors using some other
means.
4. EV ALUATION
In this section we present the results of an empirical evalua-
tion of Eos. In the evaluation we measure the accuracy of Eos in
determining message properties , i.e., CMTs, PMTs, and message
dependencies; its usefulness for change impact analysis , a common
software maintenance task; and its execution time . SpeciÔ¨Åcally, we
investigate the following three research questions:
RQ1 : How accurate is Eos in identifying the message proper-
ties of MOM-based systems?
RQ2 : Does Eos improve the effectiveness of change impact
analysis as compared to other approaches?
RQ3 : What is Eos‚Äôs execution time?
4.1 Subject Systems and Implementation
Table 1 provides an overview of our six subject systems, Ô¨Åve of
which have been described or used in prior publications [26, 25, 28,372Table 1: DEB Systems Used in the Evaluation
App Name App Type SLOC Comps Msg Type MOM
KLAX Arcade Game 4.5K 14 attr-based c2.fw [26]
DRADEL Architectural
Analysis10.8K 8 attr-based c2.fw [26]
ERS Emergency
Response7.1K 11 attr-based Prism-MW
[25]
Stoxx Stock Ticker
NotiÔ¨Åcation6.2K 4 nominal REBECA
[28, 29]
jms2009-PS JMS Bench-
mark18.6K 4 attr-based JMS [37,
36]
Spark [4] Chat Client 85K 59 nominal Smack [3]
29, 37, 36, 40]. Column App Type notes the application domain;
SLOC shows the source-lines-of-code; Comps shows the number
of DEB components in each system; Msg Type indicates whether a
system relies on nominal, subject-based, or attribute-based message
types; and MOM speciÔ¨Åes each system‚Äôs underlying MOM platform.
All of the subject systems are written in Java and together make use
of Ô¨Åve different MOM platforms. The application domains span
gaming, distributed systems, Ô¨Ånancial information systems, supply
management, chat clients, and enterprise systems.
The Eos algorithms are implemented in Java and Scala. The
implementations leverage the Soot [42] program analysis library
to generate call graphs and control-Ô¨Çow graphs. We use Soot‚Äôs
built-in class-hierarchy analysis (CHA) to resolve aliases. The
Eos implementation is available online [1]. The evaluation was
performed on a system running Windows 7 Professional with a
quad-core i7 2.80GHz processor and 8GB of memory.
4.2 RQ1: Accuracy of Eos
To address the Ô¨Årst research question, we determined the accuracy
of the set of message properties identiÔ¨Åed by Eos. We omit inter-Ô¨Çow
dependencies since they are directly dependent on the accuracy of
the other identiÔ¨Åed message properties. The results of Eos‚Äôs analysis
were compared against the ‚Äúground truth‚Äù results to calculate Eos‚Äôs
precision and recall. We did not compare against LSME because
it is unable to report message types of attribute-based systems or
identify intra-Ô¨Çow dependencies for any MOM-based systems.
To determine the ‚Äúground truth‚Äù for the subject systems, three
graduate students manually analyzed the source code of each subject
system and identiÔ¨Åed all message types and intra-Ô¨Çow dependencies.
The results of this manual inspection are available in [1]. In order to
perform the requisite comparisons, we deÔ¨Åned two notions of equal-
ity, one for message types and another for intra-Ô¨Çow dependencies.
For the purpose of our evaluation, a message type extracted by
Eos, tEos, can be classiÔ¨Åed as matching or spurious. tEosis match-
ing if and only if there exists a message type in the ground truth,
tgt, where attrib (tEos) =attrib (tgt).tEosis spurious if it does not
match any tgt. All tgtfor which there is no matching tEosare clas-
siÔ¨Åed as missing. Similarly, an intra-Ô¨Çow dependency extracted by
Eos,(tEosSrc ;tEosTgt ), matches a ground truth intra-Ô¨Çow dependency,
(tgtSrc ;tgtTgt), if and only if attrib (tEosSrc ) =attrib (tgtSrc)
^attrib (tEosTgt ) =attrib (tgtTgt). Any intra-Ô¨Çow dependency ex-
tracted by Eos that does not match a ground truth intra-Ô¨Çow de-
pendency is considered spurious. Any ground truth intra-Ô¨Çow de-
pendency that is not matched by a dependency extracted by Eos is
considered missing.
Note that these deÔ¨Ånitions cause certain errors in the analysis
to count twice against Eos‚Äôs accuracy. For example, if a message
type in the ground truth is tgt1=f(‚Äúname" ;‚Äún"),(‚Äúa1" ;e),(‚Äúa2" ;
e)g, but Eos only extracts the message type tEos1=f(‚Äúname" ;‚Äún"),(‚Äúa1" ;e)g, we count tEos1as a spurious message type; furthermore,
if no other message type extracted by Eos matches tgt1,tgt1counts
as missing.
Table 2 shows the precision ( PR) and recall ( RE) results exhibited
by Eos for each subject system‚Äôs CMTs, PMTs, and intra-Ô¨Çow
dependencies. The table also depicts how many message types and
intra-Ô¨Çow dependencies extracted by Eos were considered matching
(true-positive, TP), spurious (false-positive, FP), and missing (false-
negative, FN). The results reported in Table 2 were manually veriÔ¨Åed
by the authors.
Overall, the results indicate that Eos is highly accurate. For two of
the subject systems‚ÄîStoxx and Spark‚Äîthe precision and recall are
100% across all message properties. For two subjects‚ÄîDRADEL
and ERS‚Äîthe results are almost perfect, varying between 95%
and 100% across all message properties. For the remaining two
systems‚ÄîKLAX and jms2009-PS‚Äîthe precision and recall are
somewhat lower: they vary from 73% to 100% across the different
message properties. Next, we discuss the reasons why Eos did not
perform as well on these systems.
There are three reasons for the decrease in Eos‚Äôs precision on
several of the subjects. First, Eos‚Äôs string constant propagation is
deÔ¨Åned as a conservative analysis that propagates constants across
all paths in the component regardless of whether they are feasible.
This means that the identiÔ¨Åcation of a string variable‚Äôs values is
safe, but could include ‚Äúextra‚Äù values that Ô¨Çow to it over infeasible
paths. A path-sensitive string propagation could resolve this issue,
but would require an expensive per-path analysis, which could affect
the scalability of our approach.
Second, some KLAX components contain a Mapobject that stores
all attributes of a message in a single variable. Whenever one of
these components publishes a message, it does not add individ-
ual attributes (e.g., via m.setAttribute(attrName) ); instead, it
adds all attributes to the message at once (e.g., via m.setAllAt-
tributes(Map) ). This feature appears to have been introduced
as a programming shortcut targeted speciÔ¨Åcally at KLAX because
some of its components must share copies of large data structures.
DRADEL, the other application implemented on the same MOM
platform (c2.fw [26]), does not use this feature and its results were
not affected by the feature.
Third, some attributes are conditionally added or extracted from
a message. A small number of instances of these ‚Äúconditional
attributes‚Äù appeared in the two c2.fw applications, DRADEL and
KLAX. Eos can be extended to handle such conditional statements.
However, this could impact Eos‚Äôs scalability because, as the number
of variables in a condition increases linearly, the combination of
values those variables can take increases exponentially.
There are two reasons for the decrease in Eos‚Äôs recall for several
of the subjects. First, similar to the case discussed above, Eos misses
some CMTs in those KLAX components that return all message
attributes in a single Mapobject. Second, two KLAX components
also extract attributes from a Mapobject‚Äôs clone. Since Eos does
not track Ô¨Çow within container classes, such as Mapobjects, it does
not extract CMTs for these two components. This situation also
occurred in jms2009-PS. These resulting missing message types led
to missing intra-Ô¨Çow dependencies.
4.3 RQ2: Effectiveness for Maintenance
In the second research question, we address the effectiveness
of Eos for improving software maintenance. To measure this, we
incorporated Eos into a common software maintenance technique,
change impact analysis, and compared the accuracy of the impact
analysis against two baselines, one representing a ‚Äúna√Øve‚Äù approach
and the second built around LSME. A change impact analysis iden-373Table 2: Results for Message Types, Intra-Ô¨Çow Dependencies, and Execution Time
Consumed Message Types Published Message Types Intra-Ô¨Çow Dependencies Time (ms)
Systems TP FP FN PR RE TP FP FN PR RE TP FP FN PR RE C S
KLAX 68 8 7 89.47% 90.67% 71 17 15 80.68% 82.56% 95 35 18 73.08% 84.07% 12 168
DRADEL 54 0 0 100.00% 100.00% 71 0 1 100.00% 98.61% 116 2 0 98.31% 100.00% 87 696
ERS 71 4 0 94.67% 100.00% 57 0 0 100.00% 100.00% 86 4 0 95.56% 100.00% 33 363
Stoxx 36 0 0 100.00% 100.00% 33 0 0 100.00% 100.00% 42 0 0 100.00% 100.00% 36 144
jms2009-PS 20 2 0 90.91% 100.00% 31 0 2 100.00% 93.94% 31 2 2 93.94% 93.94% 44 176
Spark 22 0 0 100.00% 100.00% 19 0 0 100.00% 100.00% 29 0 0 100.00% 100.00% 30 1770
tiÔ¨Åes the set of entities in a system‚Äôs implementation (typically
statements) that can be affected by a speciÔ¨Åc change made to the
implementation [6, 13]. Change impact analysis is widely used in
tasks such as regression testing and bug Ô¨Åxing. In our case study,
we focused on impact analysis because the use of implicit invoca-
tion and ambiguous interfaces in DEB systems makes it difÔ¨Åcult
to determine the scope and impact of changes made during main-
tenance [19]. All three techniques‚Äîbased on Eos, LSME, and the
na√Øve approach‚Äîwere used to identify the change impact sets for a
group of common DEB system maintenance tasks. The impact sets
were compared against each task‚Äôs ‚Äúground truth,‚Äù to compute each
approach‚Äôs precision and recall.
4.3.1 Case Study Setup
For the case study, we created a representative set of mainte-
nance tasks for three systems: KLAX, jms2009-PS, and Stoxx. We
selected these systems because they provide coverage for both mes-
sage types encountered in our subject systems (attribute-based and
nominal), and span three different underlying MOM platforms. Fur-
thermore, Eos‚Äôs analysis of the three systems exhibited different
accuracy, from Stoxx‚Äôs perfect precision and recall to varying in-
accuracies in the cases of KLAX and jms2009-PS (recall Section
4.2). The tasks represent different kinds of maintenance operations,
such as removing or changing (1) program statements, (2) message
dependencies, and (3) message types. To compute the ‚Äúground truth‚Äù
impact sets, two graduate students analyzed the systems‚Äô source
code and documentation to determine the exact set of message de-
pendencies and statements that would be affected by each of the
maintenance tasks.
As mentioned above, we implemented three versions of the im-
pact analysis, the Ô¨Årst based on Eos, the second on LSME, and the
third on a na√Øve approach. For all three, we tried to emulate the
typical operations a developer might perform in using the message
properties identiÔ¨Åed by the approaches. The Eos and LSME ap-
proaches each identify two impact sets, the Ô¨Årst comprising message
types and dependencies, and the second comprising program state-
ments. The na√Øve approach only computes an impact set of program
statements.
The general approach of the Eos-based impact analysis is to
Ô¨Årst generate the MFG by running Eos on a subject system. Then
keywords and text strings from the maintenance task are used to
identify an initial impact set of message types in the MFG. For
example, a maintenance task for jms2009-PS includes a description
involving the removal of ‚Äúgolden tickets‚Äù from the system. Thus, we
searched for the keyword ‚Äúgolden‚Äù over the MFG produced by Eos
and identiÔ¨Åed a message type, tgold, with an attribute ‚ÄúgoldenTicket‚Äù.
Using this message type and its containing component as a starting
point, we then performed a reachability analysis on the MFG to
identify all dependent message types and intra-Ô¨Çow dependencies,
and also computed the program statements that corresponded to
them.The LSME approach is similar, but we make one addition to the
technique to compensate for the fact that LSME does not identify
intra-Ô¨Çow dependencies: we assume that there is an intra-Ô¨Çow de-
pendency from each CMT to each PMT that is identiÔ¨Åed by LSME.
This addition allows the approach to build an MFG that can be used
for impact analysis. Without this addition, it would not have been
possible to use LSME for impact analysis.
The na√Øve approach uses keywords from the description of a main-
tenance task to identify program statements that may be modiÔ¨Åed
to complete the task. For example, if a maintenance task descrip-
tion includes the clause ‚Äúincrease the amount by which the score
increments,‚Äù then any program statements that contain text matching
the keywords ‚Äúincrease,‚Äù ‚Äúamount,‚Äù ‚Äúscore,‚Äù or ‚Äúincrement‚Äù may
be included as part of the impact set. Since it is not possible to
use this information to build an MFG, deÔ¨Åne message types, or
identify dependencies, we could only use statement-based impact
sets generated by the na√Øve approach.
4.3.2 Discussion of Results
The results of the case study are shown in Figures 2 (message-
level) and 3 (statement-level). Each of the maintenance tasks is iden-
tiÔ¨Åed along the xaxis (A VG depicts the average), while the yaxis
shows the precision and recall achieved by the three approaches in
comparison to the ground truth. As noted above, the na√Øve approach
does not compute impact sets based on message dependencies, so
Figure 2 omits this approach. Also, for maintenance tasks involving
KLAX and jms2009-PS, the LSME-based approach could not cal-
culate a meaningful impact set. The reason for this is that LSME is
unable to identify the attributes of a message in an attribute-based
system. Therefore, we could only apply LSME on Stoxx, which
uses nominal message types.
For precision, the Ô¨Ågures show that the Eos-based approach sig-
niÔ¨Åcantly outperforms the LSME-based approach and the na√Øve
approach. At the message-level (Figure 2), the Eos-based approach
achieved an average precision of 34% as opposed to 11% for LSME.
As mentioned above, for six of the tasks involving attribute-based
messages, LSME‚Äôs precision was zero. At the statement-level (Fig-
ure 3), Eos achieved an average precision of 52% as opposed to
19% for LSME and 16% for the na√Øve approach. Eos‚Äôs precision is
superior to the na√Øve approach for all tasks, except for klax1, which
we explain below.
For recall, the Ô¨Ågures show that, on average, Eos again signiÔ¨Å-
cantly outperforms LSME and and the na√Øve approach. For message-
level impact sets, Eos achieved an average recall of 78% as opposed
to LSME‚Äôs 31%. For statement-level impact sets, Eos achieved
an average recall of 88% as opposed to 26% for LSME, and 32%
for the na√Øve approach. Note that, for the tasks for which LSME
was able to provide an impact set, its recall was identical to the
Eos-based approach. Although this seems positive for LSME, the
primary reason behind this is that we assumed an intra-Ô¨Çow depen-
dency between each pair of CMTs and PMTs identiÔ¨Åed by LSME3740.00%
10.00%
20.00%
30.00%
40.00%
50.00%
60.00%
70.00%
80.00%
90.00%
100.00%
klax1
klax2
klax3
jms1
jms2
jms3
stoxx1
stoxx2
stoxx3
AVG
EosnPrecision
LSMEnPrecision
0.00%
10.00%
20.00%
30.00%
40.00%
50.00%
60.00%
70.00%
80.00%
90.00%
100.00%
klax1
klax2
klax3
jms1
jms2
jms3
stoxx1
stoxx2
stoxx3
AVG
EosMRecall
LSMEMRecallFigure 2: Impact Analysis Results for Messages
(see Section 4.3.1); LSME is unable to identify these intra-Ô¨Çow
dependencies on its own.
Our results show that Eos obtains higher precision and recall than
the other approaches. For the software maintainer, this is a notable
beneÔ¨Åt. By utilizing Eos for impact analysis, it is almost always pos-
sible to signiÔ¨Åcantly reduce the number of spurious statements and
message properties that must be inspected after a change. Addition-
ally, the Eos-based approach ensures that a maintainer will be able
to Ô¨Ånd at least those impacted statements that the other approaches
can Ô¨Ånd. Overall, these results provide a strong indication that Eos
can be used to increase the effectiveness of a common software
maintenance technique.
The lone exception in our case study to the improved precision
results is klax1, where Eos has slightly lower precision (16.67%)
than the na√Øve approach (17.14%). This occurs because our Eos-
based impact analysis Ô¨Ånds all types transitively dependent on the
initially identiÔ¨Åed impact set. In the case of this task, the additional
dependencies do not need to be modiÔ¨Åed. SpeciÔ¨Åcally, klax1 only
requires modiÔ¨Åcations to dependencies within two components:
StatusComponent and StatusArtist. However, traversing the relevant
dependencies involving StatusComponent and StatusArtist in the
MFG returns dependencies on the TileArtist, TileRectArtist, and
LetterTileArtist components. By chance, the keywords used in the
na√Øve approach do not match any text in the code of those three
components, so the na√Øve approach does not return any results from
them.
This is an instance of a larger issue. Namely, the precision of
both the Eos-based and LSME-based approaches is lower overall
than would be achieved with more sophisticated impact analysis
techniques. Our impact analysis approach is somewhat simplistic
and uses reachability analysis to return all possible dependencies in
the MFG. Similarly, in some cases recall could be improved by a
more rigorous way of identifying the initial impact set, as a keyword
search may not identify all the components needed to obtain an
accurate impact set. For example, in the case of klax2, the keyword
‚Äúpause‚Äù in the description of the maintenance task indicated a mod-
0.00√Ø
10.00√Ø
20.00√Ø
30.00√Ø
40.00√Ø
50.00√Ø
60.00√Ø
70.00√Ø
80.00√Ø
90.00√Ø
100.00√Ø
klax1
klax2
klax3
jms1
jms2
jms3
stoxx1
stoxx2
stoxx3
AVG
EosnPrecision
LSMEnPrecision
Na√ØvenPrecision
0.00%
10.00%
20.00%
30.00%
40.00%
50.00%
60.00%
70.00%
80.00%
90.00%
100.00%
klax1
klax2
klax3
jms1
jms2
jms3
stoxx1
stoxx2
stoxx3
AVG
EosMRecall
LSMEMRecall
Na√ØveMRecallFigure 3: Impact Analysis Results for Program Statements
iÔ¨Åcation to the game‚Äôs pausing functionality. However, searching
for this keyword did not return any relevant message types because
the relevant functionality is in a component called Clock and in-
volves the words ‚Äúsuspend‚Äù and ‚Äúclock‚Äù rather than ‚Äúpause.‚Äù A
more sophisticated impact analysis could mitigate this issue, but the
development of such a technique is beyond the scope of this paper
and will be addressed in future work.
4.4 RQ3 - Execution Time
To address the third research question, we measured the execution
time of Eos. In our study we recorded the time needed to analyze
each component of each system, and also the time needed to analyze
the entire system. The results of this study are shown in the two
right-most columns of Table 2. For each subject system, the table
shows the average analysis time per component (C) and the total
analysis for the entire system (S). All time measurements are shown
in milliseconds. We excluded from both of these measurements the
time used by Soot to generate the call graphs and control Ô¨Çow graphs.
On average, the Soot analysis took about 65 seconds per system.
As Table 2 shows, Eos took from 144ms to 1,770ms to analyze the
systems, with an average of 550ms. If we include the Soot analysis
time, then, on average, Eos took less than 66 seconds to analyze
each system. Given this average running time, we conclude that the
execution time of Eos is reasonable and the analysis is sufÔ¨Åciently
fast to be used in practice.
5. RELATED WORK
Eos and the Message Flow Graphs (MFGs) it produces are sim-
ilar to certain code-based dependency analysis techniques and the
dependence graphs they produce. In particular, they both allow
the navigation of dependencies between software entities. Program
slicing [43] techniques compute sets of program statements that are
related through control or data dependencies [10, 41, 44]. These
techniques tend not to scale because they produce output that is
too large to be used for other analyses, such as impact analysis.
Furthermore, such techniques are unable to recover precise message375dependencies from DEB systems. In particular, they do not provide
a mechanism to capture the notions of message types, sources, and
sinks.
On the other end of the abstraction spectrum is the research on
analyzing event-based modeling approaches. Stafford and Wolf [38]
developed a dependence analysis technique for Rapide, a modeling
language that allows one to specify and simulate the behavior of an
event-based system. This approach accounts for inter- and intra-Ô¨Çow
dependencies. Baresi et al. [7] embed publish-subscribe constructs
into Bogor [35], an extensible model checker, to allow for auto-
matic veriÔ¨Åcation of pub-sub architectures while coping with the
problem of state-space explosion. Neither of these two approaches
provides a mapping of the model to an implementation. Zhao in-
troduced slicing for the software architecture modeling language
Wright [45]. This technique is of limited use for DEB systems since
Wright explicitly captures several relationships between event-based
components that a programming language such as Java does not.
Millett and Teitelbaum introduced slicing of Promela models [27].
However, it is unclear how Promela‚Äôs channels could be mapped
to DEB systems that do not use channels, such as those of most
existing MOM systems [29].
Halfond and Orso presented an approach that statically recovers
implicit input interfaces of web applications and then groups the
identiÔ¨Åed inputs that could be part of the same interface by analyzing
data-Ô¨Çow paths [20]. [21] extends this work by recovering indirect
interface invocations. While instructive, this approach cannot be
used for recovering the invoked interfaces of a DEB system because
DEB components neither encode invocations into one data object
nor return their invoked interfaces to a speciÔ¨Åc client.
Purandare et al. [33] developed a program analysis technique
that determines the conditions under which a component publishes
a message. The technique is targeted at the Robotics Operating
System (ROS) [2], which provides MOM-based publish-subscribe
functionality. The technique reports the conditions under which a
message source interface is called, which methods may transitively
invoke that interface, and the speciÔ¨Åc topic to which a component
may publish a message. However, unlike Eos, this technique does
not determine the attributes that constitute a message, distinguish
between CMTs and PMTs, or determine which messages may be
published due to the consumption of another message.
Jayaram and Eugster developed three static analysis techniques
targeted at improving the performance of DEB systems [23] imple-
mented in EventJava [18]. EventJava is an extension to Java that
provides support for event-based interaction. A system written in
EventJava does not deal with the problem of ambiguous interfaces:
the event (i.e., message) types in EventJava are explicitly deÔ¨Åned
via special ‚Äúevent methods‚Äù, where the attributes of an event are
speciÔ¨Åed as method arguments. While useful for constructing DEB
applications, such capabilities are not typically found in existing
MOMs. The proposed event causality analysis in [23] is a combina-
tion of static and dynamic analysis that relies on the event methods
and EventJava‚Äôs runtime framework to obtain dependencies between
events. While a potentially useful complement to the analysis pro-
vided by Eos, adopting the static portion of EventJava‚Äôs analysis
in our approach would require that we overcome two difÔ¨Åculties.
First, programmers would have to indicate which event types need
to be causally ordered to ensure safety. Second, programmers need
to explicitly indicate causally-independent events to avoid a high-
overhead pessimistic analysis.
Lexical source model extraction ( LSME ) is an approach for ex-tracting information from source code [30]. Of particular relevance
is a case study in which LSME was used to extract inter-Ô¨Çow de-
pendencies from the message-oriented Field programming environ-
ment [34]. However, LSME was unable to ensure that its results
included all message sources and sinks. Additionally, LSME did
not analyze intra-Ô¨Çow dependencies, forcing an engineer to assume
that, within a component, each published message depends on each
consumed message. Our analysis of LSME in the context of our pre-
vious work [32] quantiÔ¨Åed these shortcomings in terms of LSME‚Äôs
decreased precision and recall when applied to Ô¨Åve DEB systems
used in our evaluation in Section 4.
Our previous work, Helios [32], directly inspired the work in this
paper. Helios also computes message-Ô¨Çow dependencies of DEB
components. Our quantitative evaluation demonstrated that such an
approach can exhibit very good precision and recall. However, He-
lios supports only DEB applications that use nominal message types,
i.e., message types that are explicitly deÔ¨Åned in the underlying pro-
gramming language. Furthermore, Helios mandates that dispatching
of messages be localized within the method that implements the
message sink (e.g., the consume method in Figure 1). While these
two constraints simpliÔ¨Åed the analysis Helios had to perform as com-
pared to Eos, they also restricted Helios‚Äôs applicability to a small
class of existing DEB systems, and in some cases required partial
re-implementation of such systems [32] to Ô¨Åt Helios‚Äôs assumptions.
6. CONCLUSION
The rich body of work targeted at analyzing the dependencies in
traditional software systems provides little beneÔ¨Åt when applied to
DEB systems. The rare techniques that are directly applicable to
DEB systems are either (1) generic tools whose accuracy is inade-
quate or (2) specialized approaches that make signiÔ¨Åcant limiting
assumptions. Eos has been developed to eliminate both of these
shortcomings. Its analysis algorithms directly capture the character-
istics of modern DEB systems and their underlying MOM platforms.
This is reÔ¨Çected in the empirical data: in our evaluations, Eos ex-
hibited an average precision and recall higher than 90%, while in a
large number of cases it achieved perfect scores. Additionally, Eos‚Äôs
runtime performance gives us conÔ¨Ådence that it is likely to scale to
very large DEB systems. Finally, a preliminary case study suggests
that Eos can be used effectively in aiding change impact analysis, a
common software maintenance activity.
There are a number of avenues of future work. We have already
begun pursuing some (e.g., assessing the suitability of Eos for sys-
tem maintenance). Several additional issues were highlighted by
our evaluation results. Some of them (e.g., conditional attributes)
were due to less common ways of message storage, access, retrieval,
and propagation, which we had not considered. Others (e.g., path-
insensitive string propagation) were a result of a deliberate design
choice. In either case, enhancements to Eos to address these issues
will require a careful analysis of trade-offs between the cost in ana-
lytic complexity and runtime performance vs. the beneÔ¨Åt in added
precision and recall.
7. ACKNOWLEDGMENTS
The authors wish to thank Kihoon Jeoung for his assistance with
the analysis of the Spark system. This work has been supported by
the National Science Foundation under award numbers 1117593,
1218115, and 1321141.3768. REFERENCES
[1] mfa:start [USC Softarch Wiki]. http:
//softarch.usc.edu/wiki/doku.php?id=mfa:start ,
2012.
[2] Documentation - ROS Wiki, 2013.
[3] Ignite Realtime: Smack API, 2013.
[4] Ignite Realtime: Spark IM Client, 2013.
[5] A. Aho et al. Compilers, Principles, Techniques, and Tools .
Addison-Wesley, 1986.
[6] R. Arnold and S. Bohner. Impact Analysis - Towards a
Framework for Comparison. In the International Conference
on Software Maintenance , 1993.
[7] L. Baresi et al. On Accurate Automatic VeriÔ¨Åcation of
Publish-Subscribe Architectures. In ICSE , 2007.
[8] K. Bierhoff. API Protocol Compliance in Object-Oriented
Software . PhD thesis, School of Computer Science, Carnegie
Mellon University, 2009.
[9] K. Bierhoff and J. Aldrich. PLURAL: Checking Protocol
Compliance Under Aliasing. In ICSE Companion , 2008.
[10] D. Binkley and M. Harman. A Survey of Empirical Results on
Program Slicing. Advances in Computers: Advances in
Software Engineering , 2004.
[11] F. Biscotti et al. Market Share: AIM and Portal Software,
Worldwide, 2009. Gartner Market Research Report , April
2010.
[12] F. Biscotti and A. Raina. Market Share Analysis: Application
Infrastructure and Middleware Software, Worldwide, 2011.
Gartner Market Research Report , April 2012.
[13] S. Bohner and R. Arnold. Software Change Impact Analysis .
Wiley-IEEE Computer Society Pr, 1996.
[14] C. Clifton et al. MultiJava: Design Rationale, Compiler
Implementation, and Applications. ACM Transactions on
Programming Languages and Systems (TOPLAS) , 2006.
[15] J. Correira and F. Biscotti. Market Share: AIM and Portal
Software, Worldwide, 2005. Gartner Market Research Report ,
2006.
[16] G. Cugola et al. The JEDI Event-Based Infrastructure and Its
Application to the Development of the OPSS WFMS. IEEE
TSE, 2001.
[17] P. Eugster et al. The Many Faces of Publish/Subscribe. ACM
Computing Surveys (CSUR) , 2003.
[18] P. Eugster and K. Jayaram. EventJava: An Extension of Java
for Event Correlation. In European Conference on
Object-Oriented Programming . Springer, 2009.
[19] J. Garcia et al. Toward a Catalogue of Architectural Bad
Smells. In International Conference on Quality of Software
Architectures , 2009.
[20] W. Halfond and A. Orso. Improving Test Case Generation for
Web Applications Using Automated Interface Discovery. In
ESEC/FSE , 2007.
[21] W. Halfond and A. Orso. Automated IdentiÔ¨Åcation of
Parameter Mismatches in Web Applications. In FSE, 2008.
[22] M. Hauswirth and M. Jazayeri. A Component and
Communication Model for Push Systems. In ESEC/FSE .
Springer, 1999.
[23] K. Jayaram and P. Eugster. Program Analysis for Event-Based
Distributed Systems. In International Conference onDistributed Event-based Systems , 2011.
[24] T. D. LaToza and B. A. Myers. Developers Ask Reachability
Questions. In ICSE , 2010.
[25] S. Malek et al. A Style-Aware Architectural Middleware for
Resource-Constrained, Distributed Systems. IEEE TSE , 2005.
[26] N. Medvidovic et al. The Role of Middleware in
Architecture-Based Software Development. Int. J. of Softw.
Eng. and Knowl. Eng. , 2003.
[27] L. Millett and T. Teitelbaum. Issues in Slicing PROMELA and
Its Applications to Model Checking, Protocol Understanding,
and Simulation. International Journal on Software Tools for
Technology Transfer , 2000.
[28] G. M√ºhl. Large-Scale Content-Based Publish/Subscribe
Systems . PhD thesis, Darmstadt University of Technology,
2002.
[29] G. M√ºhl et al. Distributed Event-Based Systems .
Springer-Verlag New York, Inc., 2006.
[30] G. C. Murphy and D. Notkin. Lightweight Lexical Source
Model Extraction. ACM TOSEM , 1996.
[31] D. Popescu. Dependence Analysis for Distributed
Event-Based Systems . PhD thesis, University of Southern
California, 2012.
[32] D. Popescu et al. Impact Analysis for Distributed Event-Based
Systems. In International Conference on Distributed
Event-Based Systems , 2012.
[33] R. Purandare et al. Extracting Conditional Component
Dependence for Distributed Robotic Systems. In the
IEEE/RSJ International Conference on Intelligent Robots and
Systems (IROS) , 2012.
[34] S. Reiss. Connecting Tools Using Message Passing in the
Field Environment. IEEE Software , 1990.
[35] Robby et al. Bogor: An Extensible and Highly-Modular
Software Model Checking Framework. In ESEC/FSE , 2003.
[36] K. Sachs et al. Performance Evaluation of Message-Oriented
Middleware Using the SPECjms2007 Benchmark.
Performance Evaluation , 2009.
[37] K. Sachs et al. Benchmarking Publish/Subscribe-Based
Messaging Systems. In Proc. BenchmarX , 2010.
[38] J. Stafford and A. Wolf. Architecture-Level Dependence
Analysis for Software Systems. Int. J. of Softw. Eng. and
Knowl. Eng. , 2001.
[39] R. Taylor et al. A Component- and Message-Based
Architectural Style for GUI Software. IEEE TSE , 1996.
[40] R. Taylor et al. Software Architecture: Foundations, Theory,
and Practice . John Wiley & Sons, 2008.
[41] F. Tip. A Survey of Program Slicing Techniques. Journal of
Programming Languages , 1995.
[42] R. Vall√©e-Rai et al. Soot - a Java Bytecode Optimization
Framework. In Conference of the Centre for Advanced Studies
on Collaborative research , 1999.
[43] M. Weiser. Program slicing. In ICSE , 1981.
[44] B. Xu et al. A Brief Survey of Program Slicing. ACM
SIGSOFT Software Engineering Notes , 2005.
[45] J. Zhao et al. Change Impact Analysis to Support
Architectural Evolution. J. Software Maintenance and
Evolution Research and Practice , 2002.377