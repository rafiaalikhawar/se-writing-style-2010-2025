Minimal Strongly UnsatisÔ¨Åable Subsets of
Reactive System SpeciÔ¨Åcations
Shigeki Hagihara
Dept. of Computer Science
Tokyo Inst. of Technology
hagihara@fmx.cs.
titech.ac.jpNaoki Egawa
R&D Division, Sony
Computer Entertainment Inc.
negawa@rd.scei.
sony.co.jpMasaya Shimakawa
Dept. of Computer Science
Tokyo Inst. of Technology
masaya@fmx.cs.
titech.ac.jpNaoki Y onezaki
Dept. of Computer Science
Tokyo Inst. of Technology
yonezaki@cs.
titech.ac.jp
ABSTRACT
Verifying realizability in the specication phase is expected
to reduce the development costs of safety-critical reactive
systems. If a specication is not realizable, we must correct
the specication. However, it is not always obvious what
part of a specication should be modied. In this paper,
we propose a method for obtaining the location of aws.
Rather than realizability, we use strong satisability, due to
the fact that many practical unrealizable specications are
also strongly unsatisable. Using strong satisability, the
process of analyzing realizability becomes less complex. We
dene minimal strongly unsatisable subsets (MSUSs) to lo-
cate aws, and construct a procedure to compute them. We
also show correctness properties of our method, and clarify
the time complexity of our method. Furthermore, we im-
plement the procedure, and conrm that MSUSs are com-
putable for specications of reactive systems at non-trivial
scales.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veri-
cation| Formal methods ; F.3.1 [ Logics and meanings of
programs ]: Specifying and Verifying and Reasoning about
Programs| Specication techniques
General Terms
Verication; Reliability; Algorithms
Keywords
Reactive systems; Specications; Realizability; Strong satis-
ability; Flaw-location analysis; LTL; B uchi automata; Min-
imal unsatisable subsets
1. INTRODUCTION
Reactive systems are widespread, and include systems that
control elevators, vending machines, nuclear power plants,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ASE‚Äô14, September 15-19, 2014, Vasteras, Sweden.
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2642968 .and air traÔ¨Éc. Reactive systems respond to requests from
the environment at an appropriate time. When designing a
system of this kind, requirements are analyzed and then de-
scribed as a specication for the system. If the specication
has a aw, such as inappropriate case splitting, the system
may display unintended behavior. Indeed, many fatal acci-
dents in safety critical reactive systems have occurred due
to the rise of such unexpected situations. Therefore, it is
important to ensure that specications do not possess such
aws.
More precisely, a reactive system specication must have
a model that can respond to any possible set of requests at
an appropriate time. This property is called realizability,
and was proposed in [1, 11]. Flaws in specications can be
classied as follows.
Case 1: Specications are realizable but involve aws.
There are critical situations that were not considered
during the design and testing phases, and thus the speci-
cations do not dene behavior for those situations.
The intent of a given specication is incorrect and does
not lead to the expected outcome.
Case 2: The specications are not realizable.
A specication cannot achieve realizability because its
intent is not expressed correctly.
A specication cannot achieve realizability due to unin-
tended conicts between parts of the specication.
In this paper, we consider the type of aws in Case 2. If
a specication is found to possess such aws, they must be
located and eliminated. If it is possible to locate the aws,
it should be straightforward for system designers to correct
them.
Here we propose a method for locating aws in a specica-
tion. Rather than realizability, we use strong satisability,
which is a necessary precondition for realizability. Many
practical unrealizable specications are also strongly unsat-
isable, and strong satisability may lead to less complex
analysis than realizability. We dene minimal strongly un-
satisable subsets as an indication of the location of aws,
and detail a procedure to compute them. A minimal strongly
unsatisable subset represents a minimal part that is not
strongly satisable in the specication. In this procedure,
we take a specication and an input event sequence from an
environment as inputs, and then compute all of the minimal
strongly unsatisable subsets by analyzing a graph repre-
senting behavior for the input event sequences on the !-
automaton representing the specication. We show correct-
ness properties of our method: soundness, and completeness,
and clarify the time complexity of our method. Furthermore,
629
we
report an implementation of the procedure, and conrm
that minimal strongly unsatisable subsets are computable
for the specications of reactive systems at non-trivial scales.
2. SPECIFICATIONS OF REACTIVE SYS-
TEMS AND THEIR PROPERTIES
2.1 Reactive systems
A reactive system responds to requests from an environ-
ment with appropriate timing.
Definition 1 (Reactive system). A reactive system
RS is a tuple ‚ü®X; Y; r ‚ü©, where Xis a set of events caused by
an environment, Yis a set of events caused by the system,
andr: (2X)+7!2Yis a reaction function.
We call events caused by the environment `environmental
events,' and events caused by the system `system events.'
The set (2X)+is the set of all nite sequences of sets of en-
vironmental events. A reaction function rrelates sequences
of sets of past environmental events with the set of current
system events.
2.2 Language for reactive system speciÔ¨Åcations
The timing of environmental and system events is an es-
sential element of reactive systems. In this paper, we use
linear temporal logic (LTL) to describe the specications of
reactive systems. In LTL, in addition to the operators ^,_,
!,:,‚ä§and?, we can use the temporal operators ‚ÉùandU.
The notation ‚Éùfstates ` fholds at the next time,' whereas
fUg represents ` falways holds until gholds.' The notations
fRg,3f, and2fare abbreviations for :(:fU :g),‚ä§Uf,
and:3:f respectively. We treat environmental events and
system events as atomic propositions.
Behavior is an innite sequence of sets of events. j=f
represents that satises f, which is dened as usual.
2.3 Properties of reactive system speciÔ¨Åcations
When developing reactive system specications, it is im-
portant to satisfy realizability. Realizability requires that
there exists a reactive system such that for any environ-
mental events of any timing, the reactive system produces
system events such that the specication holds.
Definition 2 (Realizability). A specication œÜis re-
alizable if 9RS8~a(behave RS(~a)j=œÜ)holds, where ~ais an
innite sequence of sets of environmental events, i.e., ~a2
(2X)!. behave RS(~a)is the innite behavior by RS for ~a,
and is dened as follows. If ~a=a0a1: : :, behave RS(~a) =
(a0[b0)(a1[b1): : : ;where biis a set of system events caused
by RS, i.e., bi=r(a0: : : a i), and [is the union operator of
two sets.
The following property is a necessary condition for realiz-
ability [10].
Definition 3 (Strong satisfiability). A specication
œÜis strongly satisable if 8~a9~b(‚ü®~a;~b‚ü© j=œÜ)holds, where ~bis
an innite sequence of sets of system events, i.e., ~b2(2Y)!.
If~a=a0a1: : :and~b=b0b1: : :, then ‚ü®~a;~b‚ü©is dened as
‚ü®~a;~b‚ü©= (a0[b0)(a1[b1): : :.
Intuitively, strong satisability is the property that, if an
innite sequence of future environmental events is known,then the system can determine an innite sequence of sets
of system events.
Strong satisability is a necessary condition for realizabil-
ity, i.e., all realizable specications are strongly satisable.
However, many practical strongly satisable specications
are also realizable. Strong satisability requires a less com-
plex analysis compared to realizability. Checking for strong
satisability is EXPSPACE-complete [13], whereas checking
realizability is 2EXPTIME-complete [12].
If a specication is not strongly satisable, then there ex-
ists a counterexample that is evidence for unsatisability of
the specication.
Definition 4 (Counterexample). LetœÜbe a speci-
cation that is not strongly satisable, that is, œÜsatises
9~a8~b(‚ü®~a;~b‚ü© Ã∏j=œÜ). Then, a counterexample is ~a, which satis-
es8~b(‚ü®~a;~b‚ü© Ã∏j=œÜ).
Example 1.Let us consider the following reactive system
specication œÜ:‚àß
1i3œÜi,œÜ1:2(x1!3y); œÜ2:2(x2!
:y); œÜ3:2((x3^y)!(yUx 2));where x1,x2, and x3are
environmental events, and yis a system event. Each of
œÜ1; œÜ2; œÜ3is strongly satisable individually; however, œÜis
not strongly satisable, because there is no response that sat-
ises œÜfor the environmental behavior where x2continues
to occur after x1occurs. Formally, this is because for ~a
=fx2gfx2; x3g(fx1; x2gfx 2; x3g)!,9~b(‚ü®~a;~b‚ü© j=œÜ)does not
hold. ~ais a counterexample that shows unsatisability of œÜ.
3. MINIMAL STRONGLY UNSATISFIABLE
SUBSETS
In this section, we dene minimal strongly unsatisable
subsets (MSUSs), and propose a procedure to compute them.
3.1 Minimal Strongly UnsatisÔ¨Åable Subsets
Intuitively, an MSUS represents a minimal part of a spec-
ication that is not strongly satisable.
Definition 5 ( strongly unsatisfiable subset, MSUS) .
LetœÜ:‚àß
i2IœÜibe a strongly unsatisable specication, and
let~abe a counterexample, i.e., an innite sequence of sets
of environmental events that satisfy 8~b(‚ü®~a;~b‚ü© Ã∏j=œÜ). If a set
of indices I‚Ä≤Isatises 8~b(‚ü®~a;~b‚ü© Ã∏j=‚àß
i2I‚Ä≤œÜi), we say I‚Ä≤is
a strongly unsatisable subset in œÜfor~a. If I‚Ä≤is minimal,
we say I‚Ä≤is a minimal strongly unsatisable subset (MSUS)
inœÜfor~a.
Example 2.Let us consider œÜin Example 1. The strongly
unsatisable subsets for the counterexample ~a=fx2gfx2; x3g
(fx1; x2gfx2; x3g)!aref1;2gandf1;2;3g. MSUS is f1;2g.
Any other set of indices Jsatises 9~b(‚ü®~a;~b‚ü© j=‚àß
i2JœÜi).
This is because‚àß
i2JœÜiholds by considering ~bwhere ykeeps
on occurring for J=f1;3g, and by considering ~bwhere :y
keeps on occurring for J=f2;3g. This means that the colli-
sion of subspecications œÜ1andœÜ2results in œÜbeing strongly
unsatisable.
3.2 Preliminary to procedure deÔ¨Ånition
Buchi Automata. Our method of computing all of the
MSUSs uses !-automata, which accepts only the same set of
behavior as that which satises a specication. In this paper,
we use B uchi automata and generalized B uchi automata, of
which the edges are labeled by Boolean formulae as follows.
630Defini
tion 6 (B uchi automata). LetPbe a set of
propositions, i.e., environmental or system events. A B uchi
automaton on an alphabet 2Pis dened by A=‚ü®Q; q 0; ; F‚ü©,
where Qis a nite set of states, q0is an initial state, 
QB(P)Qis a transition relation, FQis a set of nal
states, and B(P)is a set of Boolean formulae that consist
of propositions in Pand connectives :;_;^. A run of A
on an !-word =[0][1] : : :is an innite sequence =
[0][1]: : :of states, where [0] = q0and([i]; bi; [i+ 1])2
and[i]j=bifor some bifor all i0. If In ()\FÃ∏=‚àÖ
holds, a run is said to be successful, where In ()is a set of
states that occur innitely often in . If there is a successful
run of Aon, we say that Aaccepts . A set of !-words
that are accepted by Ais called the language accepted by A,
which is represented by L(A).
Definition 7 (Generalized B uchi Automata).
A generalized B uchi automaton on an alphabet 2Pis de-
ned by A=‚ü®Q;; ; I; F‚ü©, where Q,,, and Iare de-
ned as above for a B uchi automaton. F=fF1; : : : ; F ng
is a set of sets of nal states, and satises FiQ. If 8i(
Inf()\FiÃ∏=‚àÖ)holds, a run is said to be successful. If
there is a successful run of Aon, we say that Aaccepts .
Translation to B uchi automata from LTL formulae.
There are numerous ways to translate an LTL formula into a
Buchi automaton that accepts exactly the same set of behav-
iors satisfying the formula. Formally, translation methods
convert an LTL formula œÜto a B uchi automaton Awhich
satisfy L(A) = fjj=œÜg. Improvements to this proce-
dure have been reported [3], and graphical tools to construct
and manipulate automata have also been reported [14]. We
obtain a B uchi automaton for a specication using the meth-
ods introduced above.
Product of automata. In our procedure, we compute a
product of B uchi automata, dened as follows.
Definition 8 (Product of automata 
).LetA1; :::;
Anwith Ai=‚ü®Qi; q0i; i; Fi‚ü©be Buchi automata. The prod-
uct of A1; :::; A nis the generalized B uchi automaton 
1inAi
=‚ü®Q; q 0; ;F‚ü©dened as follows. Q=Q1: : :Qn,q0=
(q01; : : : ; q 0n),=f((q1; : : : ; q n); b1^: : :^bn;(q‚Ä≤
1; : : : ; q‚Ä≤
n))j
81in(qi; bi; q‚Ä≤
i)2ig,F=fF‚Ä≤
1; : : : ; F‚Ä≤
ng, where F‚Ä≤
i=
f(q1; : : : ; q n)jqi2Fi^ 8jÃ∏=i(qj2Qj)g.
Remark 1.LetAœÜibe a B uchi automaton that satises
L(A œÜi) =fjj=œÜig. Then, L(
 1inAœÜi) =fjj=
œÜ1^: : :^œÜngholds.
3.3 Procedure for computing MSUSs
In this section, we propose a method for computing all of
the MSUSs in œÜ:‚àß
1inœÜi.
The procedure takes as inputs (1) B uchi automata A1; : : : ;
Anthat satisfy L(A i) =fjj=œÜig, and (2) a counterex-
ample ~ a, i.e., an innite sequence of sets of environmental
events that satises 8~b(‚ü®~a;~b‚ü© Ã∏j=œÜ), and outputs the set of all
of the MSUSs for ~ ainœÜ. We assume that each Aiis total,
which means that for any state in Ai, any set of events, there
is a transition from that state based on that set of events.
Any B uchi automata can be converted into total automata
without changing the accepted languages. We also assume
that ~ais given by  a1a2!, which is a concatenation of a nite
sequence  a1of environmental events and an innite iteration
of a nite sequence  a2of environmental events.Input: A= (Q;
q0;;F);~a=
a1a2!
Output: Run Graph G= (V; E)
V:=f(q0;~a)g,V‚Ä≤:=‚àÖ,E:=‚àÖ,E‚Ä≤:=‚àÖ
while VÃ∏=V‚Ä≤_EÃ∏=E‚Ä≤do
V‚Ä≤:=V,E‚Ä≤:=E
for each (q;~z)2Vdo
for each (q; b; q‚Ä≤)2suc
h that head (~z)j=bdo
V:=V[f(q‚Ä≤; tail (~z))g,E:=E[f((q;~z);(q‚Ä≤; tail (~z)))g
end for
end for
end while
return (V; E )
(Here head andtailare functions that return the rst element
and the remaining elements, respectively.)
Figure 1: Algorithm for constructing a run graph.
STEP 1 We construct 
1inAifrom A1; : : : ; A n. The
resulting automaton is A=‚ü®Q; q 0; ;F‚ü©
STEP 2 We obtain a B uchi automaton A=‚ü®Q; q 0;;F
‚ü©
by restricting Ato only environmental events, where =
f(q;
E(b); q‚Ä≤)j(q; b; q‚Ä≤)2g,E(b) =‚à®
b,is a substitu-
tion that substitutes ‚ä§or?for all of the system events in
b. Intuitively, E(b) denotes the quantied Boolean formula
9y1: : :9ynb, ify1; : : : ; y nare system events that appear in
b. Note that all of the labels in Aare
Boolean formulae that
consist of only environmental events. This manipulation of
automata is known as projection.
STEP 3 We construct a run graph G=‚ü®V; E‚ü©from Aand
~a=
a1a2!using the algorithm shown in Fig. 1. Grepresents
the set of runs of Aon ~a
. Each node of Gis a tuple, the
rst element is a state in A, an
d the second element is a
remaining part of ~ athat has not yet been processed.
Remark 2.L(A) = f~aj
9~b(‚ü®~a;~b‚ü© j=œÜ)g holds by the
denition of . A
path of the rst element of Gcoincides
with a run of Aon~a.
STEP 4 W
e compute the maximal strongly connected com-
ponents (SCCs) in G. Let SCbe the resulting set of SCCs.
STEP 5 For each sc2SC, we obtain Isc, which is the
set of indices of automata that do not include nal states:
Isc=fkj fqkj((q1; : : : ; q n);~a‚Ä≤)2scg \Fk=‚àÖg, where
((q1; : : : ; q n);~a‚Ä≤) is a node included in sc. (q 1; : : : ; q n) is a
state in Aand
is represented by a tuple of states of A1; : : : ; A n.
STEP 6 We consider the set Iof sets Iof indices that
satisfy 8sc2SC(I\IscÃ∏=‚àÖ), and output the set IMSUS  I,
which consists of all of the minimal sets in I.
3.4 Example application
We apply the procedure to the specication œÜand the
counterexample ~ ashown in Example 1. B uchi automata
A1; A2; A3forœÜ1; œÜ2; œÜ3are obtained in advance as shown in
Fig. 2(left). The states with the symbol ‚ñ∑are initial states,
and those with the double circle are nal states. The labels
with edges are transition conditions, represented by Boolean
formulae obtained by connecting literals horizontally with ^
and vertically with _. First, in STEP 1, we obtain A, which
is the product of A1,A2, and A3, and in STEP 2, we obtain
Aby
considering only environmental events, as shown in
Fig. 2(center). Each number in tuples of states in Acorre-
sp
onds to the indices of states in A1; A2; A3. Next, in STEP
631Truex2y~x3y~yx2TrueTrues0s1s2
Figur
e 2: The automata of sub-specication A1; A2; A3, the automaton A, and
the run graph G.
3, we obtain the run graph G, shown in Fig. 2(right). Each
path of Gcoincides with a run of Aon
~a. Although each
node in Gis a tuple, in Fig. 2(right), we show only the rst
element (i.e., a state in A) of
the tuple, and arrange nodes
with the same second elements in the same row. In STEP
4, we compute the SCCs and obtain SC=fsc1;sc2;sc3;
sc4ginG, shown in Fig. 2(right). In STEP 5, we obtain the
set of indices of automata that do not include nal states
in the SCCs. Because each nal state of A1; A2; A3iss0,
if 0 is included in the tuple of states, the nal state of the
corresponding automaton is included in the SCC. For in-
stance, the nal states 0 of A2andA3are included in sc1;
however, the nal states 0 of A1are not included in sc1.
We conclude that Isc1=f1g. Similarly, we conclude that
Isc2=f2g; I sc3=f2;3g; I sc4=f1;3g. Finally, in STEP
6, we compute I, which satises 8sc2SC(I\IscÃ∏=‚àÖ).
In this case, f1;2gandf1;2;3gsatisfy this condition, i.e.,
I=ff1;2g;f1;2;3gg. We obtain all of the minimal sets
fromI. Hence, in this case, we obtain IMSUS =ff1;2gg,
which is the same result as that given in Example 2.
4. CORRECTNESS AND COMPLEXITY
In this section, we show correctness properties of our pro-
cedure, i.e., soundness, and completeness. We also clarify
the complexity of the procedure.
Theorem 1 (Soundness, Completeness). LetœÜ:‚àß
1inœÜibe a specication, A1; : : : ; A nbe Buchi automata
that satisfy L(A i) =fjj=œÜig,~abe a counterexample,
i.e., an innite sequence of sets of environmental events that
satisfy 8~b(‚ü®~a;~b‚ü© Ã∏j=œÜ). IfIMSUS is a set of sets of indices
that is the result of applying the procedure to A1; : : : ; A nand
~a, then (I2 IMSUS ,Iis a MSUS in œÜfor~a)holds.
This theorem can be proved by using Lemma 1. We omit
the proof. Lemma 1 represents that the result of projecting

1inAibyIca
n be considered as 
i2IAiwhi
ch was not
constructed in the procedure.
Lemma 1.proj(Run(
1inAi; )
; I) =Run(
i2IAi; )
ho
lds, where Run (A;~a)is the set of runs of Aon~a, proj (Run (

1inAi;~a); I)is
the set of runs obtained by projecting
(q1; : : : ; q n)into (qi1; : : : ; q im), where I=fi1; : : : ; i mg, and(q1; : : : ; q n)is a tuple of states that appears in runs of

1inAion~a.
This
lemma obviously holds because the following (I)(II)(III)
can be proved. For proving (III), we use totality of Ai. We
omit these proofs.
(I)Run(A;~a) =‚à™
~bR
un(A;‚ü®~a;~b‚ü©),
(II)proj(Run(
0<inAi;~a); I)
=‚à™
~bpr
oj(Run(
0<inAi;‚ü®~a;~b‚ü©); I),
(III) proj(Run(
0<inAi; ); I) =Run(
i2IAi; ).
We can clarify the time complexity of our procedure by
estimating computation time for each step of our procedure.
Theorem 2 (Time complexity). LetœÜ:‚àß
1inœÜi
be a specication, and let ~a= a1( a2)!be a counterexample.
We can translate œÜ1; : : : ; œÜ ninto a B uchi automaton A1; : : : ;
An, apply the procedure to A1; : : : ; A nand~a, and compute
the set of MSUSs in time 2O(jœÜj+log(j a1j+ja2j)+log n)+ 2O(2n).
5. APPLICABILITY
Our method is useful for correcting strongly unsatisable
reactive system specications, as demonstrated by the fol-
lowing example of a control system for a door. The initial
specication is as follows.
0. A door has three buttons: an open button, a close but-
ton, and an open-extension button.
1. If the open button is pushed, the door eventually opens.
2. While the close button is pressed, the door remains shut.
3. While the door is open, if the open-extension button
is pushed, the door remains open until the close button is
pushed.
The event `the open (or close or open-extension) button is
pushed,' is an environmental event. We use x1(x2,x3) to
describe this event. The event `the door is open (closed)'
is a system event. We use y(:y) to describe this. This
initial specication is represented by 2(x1!3y)^2(x 2!
:y)^2((x3^y)!(yUx 2)) in LTL, which is identical to œÜ
in Example 1. Because this specication is strongly unsat-
isable, as stated in Example 1, it is necessary to identify
a aw that causes strong unsatisability and correct this
specication. To correct this specication, we use MSUSs
in the specication. Strong satisability can be checked for
using the method described in [6], and if a specication is
632no
t strongly satisable, a counterexample of the form  aa‚Ä≤!
can be obtained. In this case, we suppose that the coun-
terexample ~ ashown in Example 1 is obtained. The set of
MSUSs ff1;2ggis obtained by applying the procedure to œÜ
and ~a, as stated in Sect. 3.4. This states that, to make ~ anot
be a counterexample, it is not necessary to modify œÜ3(3 in
the specication), but it is necessary to modify œÜ1orœÜ2(1
or 2 in the specication). Several modications are possible;
for example, 2 in the initial specication may be weakened
to 2', i.e.,
2'. If the close button is pushed, the door eventually closes.
The modied specication is represented by 2(x1!3y)^
2(x 2!3:y)^2((x3^y)!(yUx 2)). For ~ a, there is an
innite sequence of sets of system events that satises this
modied specication. That is, following this modication,
~ais no longer a counterexample. In this case, because only
one MSUS f1;2gwas obtained by the procedure, only one
modication was required. In general, multiple MSUSs may
be obtained. In such cases, multiple modications may be
required to account for all of the MSUSs.
Furthermore, one counterexample does not always corre-
spond to all of the aws that give rise to strong unsatisabil-
ity of the specication. Although modication succeeded in
making ~ ano longer a counterexample, aws causing strong
unsatisability of the specication may remain. In such
cases, we can obtain strongly satisable specications by
iterating the following processes: (1) we determine whether
strong satisability of the specication exists, and if not, we
obtain a counterexample; (2) we compute the MSUSs; and
(3) we correct the specication accordingly.
6. IMPLEMENTATION AND EVALUATION
6.1 Implementation
We implemented the procedure using Python 2.7. The in-
puts were a collection of B uchi automata representing speci-
cations, and a counterexample. We used the tools GOAL[14]
and LTL3BA[3] to translate the specication into B uchi au-
tomata.
6.2 Evaluation
We evaluated our implementation on a machine with a
Core i7-3820 processor running at 3.60 GHz, with 32 GB
of memory, and which was running the Ubuntu Linux oper-
ating system. We apply this implementation to a practical
specication at a non-trivial scale. We consider the speci-
cation of an m-oor elevator system described in [2], shown
in Fig. 3. The specication has m+ 2 environmental events,
2m+ 4 system events, and 12m + 8 temporal formulae. The
specication consists of (a) a specication for each oor,
divided into functional requirements and non-functional re-
quirements; (b) a specication for a door of the lift; and (c)
a specication of the physical constraints. This specica-
tion is not strongly satisable, because if the button at a
given oor is held (i.e., pushed continuously), the lift will
stay at that oor and will not move to other oors. In this
experiment, we use the counterexample representing the be-
havior that both buttons at the rst and second oors are
pushed continuously. We consider the following two kinds
of partitions of specications: A. (a1), : : :,(am),(b),(c), and
B. (a1f),(a1n), : : :,(amf),(a mn),(b),(c), where (a i) represents
the specication for the i-th oor, (a if) and (a in) repre-
sent the functional and non-functional requirements, respec-tively, for the i-th oor specication. We show the results
in Table 1. The execution time includes the time to trans-
late the subspecications in LTL into B uchi automata. If
the execution does not terminate within 1800 seconds, we
show the notation `t/o.' After partitioning the specication
into 14 subspecications (the bottommost case in Table 1),
it failed to compute MSUSs within 1800 seconds, and the
run graph was not constructed. Because we used a naive
transformation algorithm and naive data structures to rep-
resent the run graph, the memory space for the run graph
was large. Except for this case, in spite of the naive imple-
mentation, we obtained the intended results in a reasonable
period of time. This indicates that the aw did not appear
in non-functional requirements, and appeared only in the
functional requirements for the rst and second oors, and
the physical constraints. Hence, our method is useful not
only for locating the aws, but also for classifying subspec-
ications, including functional/non-functional requirements
and physical requirements. We conrmed that the set of
MSUSs can be computed from a practical specication at
non-trivial scale in a reasonable amount of time, and found
that the MSUS is useful for locating aws in practical spec-
ications.
m partition the set
of MSUSs time[s]
3 A ff(a1),(a2),(
c)gg 0.26
B ff(a1f),(a2f
),(c)gg 1.18
4 A ff(a1),(a2),(
c)gg 1.77
B ff(a1f),(a2f
),(c)gg 27.99
5 A ff(a1),(a2),(
c)gg 19.48
B ff(a1f),(a2f
),(c)gg 853.65
6 A ff(a1),(a2),(
c)gg 232.95
B t/o t/o
Ta
ble 1: Results for application to specication of
m-oor elevator system.
7. RELATED WORK
Methods for computing locations of aws in unrealizable
specications has been proposed in [4, 7]. Although in these
methods they treat realizability, they restricted specication
language to GR(1) which is a subset of LTL. In contrast to
their works, we treat strong satisability instead of real-
izability, however, targets of our method are specications
written in full-LTL, and can be expanded to !-regular lan-
guages easily.
Methods for computing minimal unsatisable subsets
(MUSs) from unsatisable Boolean formulae are typically
derived from research on satisability solvers, or SAT-solvers.
In [9], procedures for computing all of the MUSs were pro-
posed.
Methods for deriving causes (rather than the locations)
of aws in reactive system specications have been reported
[5, 8]. These methods derive constraints of the behavior of
an environment implicitly imposed by unrealizable specica-
tions. Because the implicit constraints provide hints to the
cause of aws in specications, these constraints are helpful
to correct the aws.
8. CONCLUSION
We have described a method for computing MSUSs, using
a counterexample, of a reactive system specication written
633Ev
ents:
Environmental events:
lbtn i(i= 1::m), //Request button at ith oor is pushed.
obtn , //Open button in the lift is pushed.
cbtn //Close button in the lift is pushed.System events:
li(i= 1::m), //The lift is located at ith oor.
ri(i= 1::m), //The lift is requested to go to ith oor.
opn, //The door is open.
mov, //The lift can move.
to, //The time-limit that the door can open has past.
oreq //The door is requested to open.
Specications:
(a) a specication for each oor
(af) functional requirements
//If a request button is pushed, the lift even-
tually go there.‚àß
1im2(lbtn i!3li^riW(li^ri)),
//If the lift reaches the requested oor, the
door open.‚àß
1im2(li^ri!opn^liWmov),
(an) non-functional requirements
//Until request button is pushed, lift is not
requested to go there.‚àß
1im2(li^mov!(:ri)Wlbtn i),
//If the lift is not requested at a oor, the
door will not open there.‚àß
1im2(li^ :ri! :opn ),(c) a specication of the physical con-
straints
//The lift is located at some oor.
2(‚à®
1imli)^2(‚àß
1im(li!‚àß
j=1::m;i Ã∏=j:lj)),
//The lift must pass oors on the way to the
destination. ( m3)
2(‚àß
1im 2
3jm;i j 2(li^rj!‚àß
i+2 kj(:lk)U(:lk^lk 1))),
2(‚àß
1im 2
3jm;i j 2(lj^ri!‚àß
i+2kj(:lk)U(:lk^lk+1))),
//A relation between the door open/close and
the lift movable/unmovable
2(opn !(:mov )W(:opn )),
2(:opn !movWopn),(b) a specication for a door of the
lift
//The time-limit that the door open is set.
2(opn!3to),
//If open button is pushed, the door is re-
quested to open.
2(obtn^ :to!oreq),
//When the time that door can open passed,
the door closes.
2(to! :opn),
//If close button is pushed, the door closes.
2(cbtn^ :oreq! :opn ),
//If the door is requested to open and the lift
is not movable, the door opens.
2(oreq^ :mov !opn)
(Remark: In the specications, we use the
weak until operator fWg , which is an abbre-
viation for gR(g_f).)
Figure 3: Sample Specications of m-oor elevator systems in [2].
in LTL which is not strongly satisable. Flaws can be lo-
cated and corrected by modifying the parts of the specica-
tion indicated by the MSUSs. Because our method is based
on strong satisability instead of realizability, it is possible
to locate aws in a specication eÔ¨Éciently. We proved cor-
rectness of our procedure, i.e., soundness and completeness,
to ensure that all MSUSs are computed correctly. We also
showed the time complexity of our procedure. Furthermore,
we implemented the procedure, and conrmed that the set
of MSUSs can be computed from a specication at a non-
trivial scale in a reasonable amount of time.
STEP 6 simply translates minimal correction subsets
(MCSs) into MUSs. In [9], several eÔ¨Écient translation algo-
rithms are described. We expect that these algorithms can
improve the eÔ¨Éciency of our method. We believe that our
method has many potential practical applications for the
analysis of safety-critical systems.
9. ACKNOWLEDGMENTS
This work was supported by JSPS KAKENHI Grant Num-
ber 24500032.
10. REFERENCES
[1] M. Abadi, L. Lamport, and P. Wolper. Realizable and
unrealizable specications of reactive systems. In
ICALP89 , vol. 372 of LNCS, pages 1{17. 1989.
[2] T. Aoshima and N. Yonezaki. Verication of reactive
system specication with outer event conditional
formula. In International Symposium on Principles of
Software Evolution (ISPSE2000) , pages 195{199, 2000.
[3] T. Babiak, M. Kret nsk y, V. Reh ak, and J. Strejcek.
LTL to B uchi automata translation: Fast and more
deterministic. In TACAS2012 , vol. 7214 of LNCS ,
pages 95{109, 2012.
[4] A. Cimatti, M. Roveri, V. Schuppan, and
A. Tchaltsev. Diagnostic information for realizability.
InVMCAI2008 , vol. 4905 of LNCS , pages 52{67. 2008.[5] S. Hagihara, Y. Kitamura, M. Shimakawa, and
N. Yonezaki. Extracting environmental constraints to
make reactive system specications realizable. In 16th
Asia-Pacic Software Engineering Conference ,
APSEC '09, pages 61{68, 2009.
[6] S. Hagihara and N. Yonezaki. Completeness of
verication methods for approaching to realizable
reactive specications. In AWCVS'06 , vol. 348 of
UNU-IIST Technical Report , pages 242{257, 2006.
[7] R. Konighofer, G. HoÔ¨Äerek, and R. Bloem. Debugging
formal specications using simple counterstrategies. In
FMCAD2009 , pages 152{159, 2009.
[8] W. Li, L. Dworkin, and S. A. Seshia. Mining
assumptions for synthesis. In MEMOCODE , pages
43{50, 2011.
[9] M. H. LiÔ¨Éton and K. A. Sakallah. Algorithms for
computing minimal unsatisable subsets of
constraints. Journal of Automated Reasoning ,
40(1):1{33, 2008.
[10] R. Mori and N. Yonezaki. Several realizability
concepts in reactive objects. In Information Modeling
and Knowledge Bases , 1993.
[11] A. Pnueli and R. Rosner. On the synthesis of a
reactive module. In POPL89 , pages 179{190, 1989.
[12] R. Rosner. Modular Synthesis of Reactive Systems .
PhD thesis, Weizmann Institute of Science, 1992.
[13] M. Shimakawa, S. Hagihara, and N. Yonezaki.
Complexity of strong satisability problems for
reactive system specications. IEICE Transactions on
Information and Systems , E96-D(10):2187{2193, 2013.
[14] Y.-K. Tsay, Y.-F. Chen, M.-H. Tsai, K.-N. Wu, and
W.-C. Chan. GOAL: A graphical tool for manipulating
Buchi automata and temporal formulae. In
TACAS2007 , vol. 4424 of LNCS , pages 466{471. 2007.
634