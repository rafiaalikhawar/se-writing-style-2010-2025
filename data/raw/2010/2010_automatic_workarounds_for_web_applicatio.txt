Automatic Workarounds for Web Applications
Antonio Carzaniga, Alessandra Gorla, Nicolò Perino, and Mauro Pezzè∗
Faculty of Informatics
University of Lugano
Lugano, Switzerland
{antonio.carzaniga|alessandra.gorla|nicolo.perino|mauro.pezze}@usi.ch
ABSTRACT
We present a technique that ﬁnds and executes workarounds
for faulty Web applications automatically and at runtime.
Automatic workarounds exploit the inherent redundancy of
Web applications, whereby a functionality of the application
can be obtained through diﬀerent sequences of invocations
of Web APIs. In general, runtime workarounds are applied
in response to a failure, and require that the application re-
main in a consistent state before and after the execution of
a workaround. Therefore, they are ideally suited for inter-
active Web applications, since those allow the user to act
as a failure detector with minimal eﬀort, and also either
use read-only state or manage their state through a trans-
actional data store. In this paper we focus on faults found
in the access libraries of widely used Web applications such
as Google Maps. We start by classifying a number of re-
ported faults of the Google Maps and YouTube APIs that
have known workarounds. From those we derive a number of
general and API-speciﬁc program-rewriting rules, which we
thenapplytootherfaultsforwhichnoworkaroundisknown.
Our experiments show that workarounds can be readily de-
ployed within Web applications, through a simple client-side
plug-in, and that program-rewriting rules derived from ele-
mentary properties of a common library can be eﬀective in
ﬁnding valid and previously unknown workarounds.
Categories and Subject Descriptors
D.2.5 [Software Engineering ]: Testing and Debugging—
Error handling and recovery
General Terms
Reliability, Design
Keywords
Automatic Workarounds, Web Applications, Web API
∗Mauro Pezz` e is also with the University of Milano-Bicocca.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
FSE-18, November 7–11, 2010, Santa Fe, New Mexico, USA.
Copyright 2010 ACM 978-1-60558-791-2/10/11 ...$10.00.1. INTRODUCTION
Application programming interfaces (APIs) for popular
Web applications like Google Maps and Facebook increase
the popularity of such applications, but also introduce new
problems in assessing the quality of the applications. In
fact, third-party developers can use Web APIs in many dif-
ferent ways and for various purposes, and applications can
be accessed by many users through diﬀerent combinations
of browsers, operating systems, and connection speeds. This
leads to a combinatorialexplosion of use cases, and therefore
a growing number of potential incompatibilities that can be
diﬃcult to test with classic approaches, especially within
tight schedules and constrained budgets.
Furthermore, failures caused by faults in common APIs
can aﬀect a large number of users, and ﬁxing such faults re-
quires a time consuming collaboration between third-party
developers and API developers. In order to overcome these
open problems in the absence of permanent ﬁxes, users and
developers often resort to workarounds. However, although
many such workarounds are found and documented in on-
line support groups, their descriptions are informal, and
their application is carried out on a case-by-case basis and
often with non-trivial ad-hoc procedures.
In this paper we propose a technique to ﬁnd and execute
workarounds automatically and at runtime in response to
failures caused by faults in the libraries that the application
depends on. Automatic workarounds do not ﬁx the faults in
the API code, but rather provide a temporary solution that
masks the eﬀects of the faults on applications.
We start from the supposition that libraries are often in-
trinsically redundant, in the sense that they provide several
diﬀerent ways to achieve the same results, and that this re-
dundancy can lead to eﬀective workarounds. For example,
changing an item in a shopping list, may be equivalent to
deleting the item and then addinga new one. So, to avoid a
failing edit operation, one could replace that edit operation
with a suitable sequence of delete and add operations. This
assumption, that large software systems contain signiﬁcant
portions of functionally equivalent code, is supported by ev-
idence from a recent study on redundant code in the Linux
Kernel [13], and is also conﬁrmed by our study of Web APIs
that we report in this paper.
Based on this intrinsic redundancy, we propose a tech-
nique to build and execute, at runtime and in response to a
failure, alternative sequences of operations whose intended
behavior is equivalent to that of the failing sequence. We
denote such sequences as equivalent sequences .W et h e nc a l l
237workarounds those equivalent sequences that execute suc-
cessfully, thereby avoiding the failure.
In order to deploy automatic workarounds eﬀectively, we
need to solve four main problems. First, we need to detect
failures and check for the validity of workarounds. Second,
we must be able to execute equivalent sequences repeatedly
without compromising the state of the application and with-
out suﬀering from potential side-eﬀects of the previous fail-
ing execution. Third, we need to represent the redundancy
of APIs so as to be able to generate equivalent sequences at
run time. Fourth, we need to ﬁnd valid workarounds out of
potentially many equivalent sequences.
We assume that we can dismiss the second problem (re-
peated executions) in the case of Web applications because
those are typically designed to avoid potential side-eﬀects
caused by repeated executions. (We brieﬂy revisit this as-
sumption in Section 4.5.) We can therefore execute a worka-
round by simply re-executing the client-side code of the page
that manifests the failure (after applying the workaround).
The remaining problems are the focus of this paper. For
the ﬁrst problem (detecting failures and verifying the va-
lidity of deployed workarounds) our general approach is to
rely on the interactive nature of Web applications, and in
practice to assume that users can easily detect a failure and
explicitly request a workaround, for example by pressing a
special“Fix-it!”button on their browser. For example, if an
application that uses the Google Maps API does not dis-
play a map as expected, the user can, with minimal eﬀort,
detect the failure and push the“Fix-it!” button. Similarly,
users can reject the execution of an equivalent sequence, or
implicitly validate it as a workaround by proceeding with
their interactive session. As we rely on users to ﬁnd work-
arounds, we must also take special care not to annoy and
ultimately alienate them with too many repeated attempts.
We address this problem by developing an automatic oracle
that can conservatively detect, and therefore discard, some
ineﬀective equivalent sequences.
As for the third and fourth problems (modeling and ex-
ploiting redundancy to ﬁnd valid workarounds) we continue
toexploreandevolveourideasonautomaticworkarounds[7,
6]. In particular, in our earlier work, we propose to derive
workarounds from a formal model of the application (e.g.,
a ﬁnite-state machine or an algebraic speciﬁcation). How-
ever, that initial approach requires that the speciﬁcation be
complete in the sense that the exact state of the application
must be identiﬁable from every sequence of API calls. In-
stead, here we develop a more practical notion of automatic
workaround that requires only a much simpler, possibly par-
tial, and therefore more general application model, in which
we construct equivalent sequences from explicitly given se-
quencesthatareknowntobefunctionallynulloridenticalto
others. This paper presents a concrete instantiation of this
new approach in the case of Web applications, and speciﬁ-
cally makes the following novel contributions:
•We propose an application-independent notation to
represent classes of equivalent sequences. This nota-
tion consists of source-code rewriting rules that, ap-
plied to a JavaScript program, produce an equivalent
but possibly failure-free program.
•We propose and evaluate a general architecture, im-
plementable within a Web proxy or a browser plug-in,
for the generation, prioritization, and deployment ofworkarounds for Web applications at runtime. This
architecture includes an automated oracle that greatly
reduces the need for user intervention.
•We present the study of some popular Web APIs to-
gether with several of their failure reports. This study
leads to two contributions: (1) We present a set of con-
crete, API-speciﬁcrulesthatgeneratevalid, knownbut
also previously unknown workarounds for each API;
(2) We derive a taxonomy of abstract, generic rules
that are relatively simple but surprisingly eﬀective.
The remainder of the paper is structured as follows. In
Section 2 we present some examples that show how to ex-
ploit the implicit redundancy of Web applications to derive
workarounds. In Section 3 we introduce a framework and
a concrete architecture to support automatic workarounds
for Web applications. In Section 4 we present experimental
data obtained with applications that use the Google Maps
and YouTube APIs, and that show the eﬀectiveness of the
approach proposed in this paper. In Section 5 we discuss re-
lated work, highlighting the salient diﬀerences and the nov-
elty of our proposal. We then conclude in Section 6 with a
summary of our results and some ideas for future research.
2. MOTIV ATING EXAMPLES
We illustrate the notion of workaround, and speciﬁcally
the nature of failures and workaroundsin the context of Web
applications, using two examples of failures aﬀecting two
widely used Web APIs. The two examples we present here
are typical of a large number of problems that we observed
in our survey of bug repositories, discussion forums, and
interest groups related to popular Web APIs. We report
more extensively on the results of our survey in Section 4.
Flickr, Photo visibility. Flickr is a popular photo-sharing
application. The Flickr API allows users to upload and pub-
lish photos on the Web. Flickr associates photos with a vis-
ibility tag that controls access to photos on the Web, which
can bepublic,family,o rprivate. The Flickr API includes a
methodsetPerms() that allows users to change the visibility
of their photos. A message posted by a user on the Flickr
forum in March 2007 reported a failure of setPerms() :t h e
method failed to change the access status of a photo from
privatetofamilyfor photos that were originally uploaded as
private.1The problem persisted for some time in Flickr, and
was originally avoided with a simple workaround posted on
the forum: to change the visibility of a photo from private
tofamily, ﬁrst change from privatetopublicand then from
publictofamily. This fault has since been ﬁxed.
Facebook, Dialog windows. The popular social network-
ing system Facebook exposes an API for Web applications.
The Facebook API consists of a JavaScript library that,
among other things, allows applications to create and con-
trol graphical elements. Report n. 2385 in the Facebook bug
repository describes a problem with the setStyle() method of
the Facebook API, which is intended to set the width and
height of a graphical element. The method works well when
one of the two dimensions is set individually, but fails when
used to set both dimensions at the same time.2The report
1http://www.ﬂickr.com/help/forum/36212 ,—/46985
2http://bugs.developers.facebook.com/show bug.cgi?id=2385
238was ﬁled in June 2008 by a developer who also suggested a
workaround in which one can set width and height with two
separate setStyle() calls. As of the time of this writing (June
2010) this fault is still unresolved.3
Theexamplesaboveshowthatsomefaultsmaysurvivefor
a long time. In this paper we do not intend to investigate
the software maintenance processes for Web applications,
and we realize that those are complex processes aﬀected
by human factors and driven by technical as well as non-
technical objectives. Nevertheless, we observe that those
kinds of failures have to go through two maintenance steps:
they are initially reported, either indirectly by application
users (ﬁrst case) or more directly by application developers
(second case) but can be corrected only by the developers of
the Web API, who may not be aware of the actual impact
of the fault, and in any case may have other priorities.
The two cases also exemplify two diﬀerent types of worka-
rounds. In the ﬁrst case, it is very likely that the setPerms()
method of the Flickr API be exposed directly to users, al-
lowing them to control access to their photos. Therefore,
not only users can more easily notice the failure and report
it with an accurate diagnosis, but they can also directly ap-
ply the proposed workaround. This is most probably not the
case for the setStyle() method of the Facebook API, which is
typically used by applications but not exposed to users. So,
in this latter case, users may or may not detect the failure,
but would certainly not be able to use the proposed worka-
round. In fact, the failure report explicitly characterizes it
as a“workaround for developers.”
3. AUTOMATIC WORKAROUNDS
We now describe the architecture of a system for the de-
ployment of automatic workarounds. This description refers
to a concrete implementation in the form of a browser ex-
tension, although the same architecture can also be imple-
mentedasaWebproxy. Thebrowserextensionmediatesthe
interaction between, on the one hand, one or more servers
that produce the HTML pages and the code associated with
a Web application, and on the other hand, the browser com-
ponentsthatexecutethecode, renderthepages,andmanage
the interaction with the user. At a high level, the browser
extension deploys a workaround by modifying the code of
the pages (i.e., the application) rendered to the user.
Figure 1 shows the high-level architecture of the browser
extension as well as the general process by which the ex-
tension deploys automatic workarounds. This process un-
folds in the following steps. The interaction starts with a
user requesting a speciﬁc page or application (step 1). The
browser issues the requests for all the objects (data and
code) that compose the page to the origin server (step 2).
The browser extension then examines the objects returned
by the server (step 3) to decide whether to enable the ser-
vices of its automatic-workaround module. In particular,
the browser extension looks for references to the API of
known third-party Web applications for which the extension
may be able to generate workarounds. If such references are
found (step 4) then the browser extension activates a failure-
reporting button on the toolbar (step 5). The user then dis-
plays the page and executes the JavaScript code that comes
3The fault is actually classiﬁed as“unconﬁrmed.” However,
we were able to replicate the fault, and are not aware of any
permanent ﬁx.with it, which might in turn retrieve and execute additional
code fragments from the API of other common Web appli-
cations. In the absence of failures, or more precisely in the
absence of any perceived failure, the user continues to inter-
act with the application, and the browser extension acts as
a transparent layer.
In the presence of a perceived failure, the user invokes the
browser extension using the failure-reporting button (step 6
inFigure1)whichactivatestheautomatic-workaroundmod-
ule in the browser extension (AW); the AW module then
examines the JavaScript code of the page in question, iden-
tiﬁes a candidate equivalent sequence (step 7), applies it to a
copy of the page, and passes the result to the automated or-
acle for validation (step 8). If the oracle approves the page,
then the extension applies the same equivalent sequence to
the original page (step 9) and presents the result to the user
(step 10). If the equivalent sequence fails to resolve the
problem, either because it is immediately rejected by the
oracle (step 8) or because the user reports another failure,
then the extension reiterates the same process (steps 7–10)
until it has exhausted its repository of equivalent sequences.
Equivalent sequences are produced by code-rewriting rules
as described in Section 3.2; the selection of a likely worka-
round (step 7) is guided by a prioritization scheme described
in Section 3.3; the oracle is described in Section 3.4.
The repository of equivalent sequences (i.e., rules), which
are API-speciﬁc, is populated oﬀ-line by API developers or
users. It is also conceivable that the repository be automati-
cally updated as new workarounds become available, or even
that the extension would consult external repositories in the
attempt to ﬁnd a valid workaround. However, we do not ex-
plore such technical solutions here, and instead focus on the
speciﬁc nature and form of equivalent sequences. In partic-
ular, we continue in two directions. First, in Section 3.1 we
describe some general classes of equivalent sequences and of-
fer some guidelines to derive equivalent sequences from API
speciﬁcations, language features, and programming experi-
ence. Second, in Section 3.2 we present a practical, perhaps
simple-minded, but nevertheless eﬀective way of expressing
equivalent sequences as code-rewriting rules.
3.1 General Classes of Equivalent Sequences
We propose three general classes of equivalent sequences
that are applicable to all APIs, namely functionally null ,in-
variantandalternative operations. More precisely, these are
classes of methods or entire code fragments that can be used
to obtain concrete equivalent sequences. Here we formulate
these classes intuitively, since indeed they can be derived
from common sense and programming experience. However,
later we also show that they can be derived experimentally
by analyzing the fault repositories of such popular Web ap-
plications as Yahoo! Maps, Microsoft Maps, Facebook, Pi-
casa, Flickr, YouTube and OpenOﬃce (see Section 4.1).
Functionally null operations are operations with no func-
tional eﬀects. This is the case, for instance, of operations
thataﬀectonlytimingorscheduling. Asaconcreteexample,
the JavaScript setTimeout statement is a functionally null
operation that often leads to eﬀective workarounds. Func-
tionally null operations can aﬀect the order of execution of
some operations, and therefore can solve failures that derive
from concurrency problems such as race conditions or miss-
ing barriers. Functionally null operations are easily identiﬁ-
able, often do not depend on the particular API in use, and
239server
API1- request URL 2- forward request
6- FAILURE!3- original page5- original page
10- page with workaround
AW4- enable failure report system
AW module Rewriting
rulesJS 
execution
9- apply approved transformation
7- select rule
automatic
oracleAW browser extension
8- apply rule and evaluate effectiveness 
Figure 1: A Framework for Automatic Workarounds
can be simply inserted in the application code to produce
equivalent sequences.
Invariant operations are typically pairs of operations in
which the second one reverses the eﬀects of the ﬁrst. Longer
and more complex combinations of operations are also pos-
sible, as long as the overall eﬀect of the combination is null.
Examples of invariant sequences are addandremovemeth-
ods for containers, or zoom-in andzoom-out for graphical
elements. Some operations within an invariant sequence
may reset the state of the application, and therefore solve
initialization problems, as illustrated by the Flickr exam-
ple reported in Section 2. Like functionally null operations,
invariant operations may also aﬀect the scheduling of con-
current operations, and thereby solve concurrency problems.
InvariantoperationsareAPI-speciﬁcbutarestilleasilyiden-
tiﬁable, and can also be simply inserted in the application
code to generate alternative sequences.
Alternative operations are sets of operations that produce
the same results as other (diﬀerent) sets of operations. A
simple example is the workaround for the failure of the set-
Style()operationoftheFacebookAPIdescribedinSection2.
In that case, one call of the setStyle() method can be re-
placed with two calls of the same method (and vice-versa).
Another example can be found in the Flickr API, where an
application can associate a set of tags to a photo either with
as i n g l esetTagsoperation for all tags, or with repeated ad-
dTagsoperations, eachaddinganindividualtag. Alternative
operations tend to engage more redundant code in the API,
and therefore are generally more likely to lead to eﬀective
workarounds. Alternative operations are API-speciﬁc and
can be identiﬁed by gaining a basic understanding of the
semantics of the API. Alternative operations can generate
equivalent sequences by substitution.
3.2 Program-Rewriting Rules
We propose to create equivalent sequences by applying
program-rewritingrules. Wenowdeﬁnetheserewritingrules
in detail. The syntax is as follows:
/angbracketleftRule/angbracketright ::=/angbracketleftType/angbracketright/angbracketleftScope/angbracketright:/angbracketleftSubstitution /angbracketright
/angbracketleftType/angbracketright ::=null|invariant |alternative
/angbracketleftScope/angbracketright ::=ANY|ALL|/angbracketleftnumber/angbracketright
/angbracketleftSubstitution /angbracketright::= (/angbracketleftpattern/angbracketright→/angbracketleftreplacement /angbracketright)+
Thus, a rewriting rule is deﬁned by three elements: an in-
dicator of the type of rule, an indication of the scope of
the rule, and a substitution expression. The type classiﬁesthe rule within one of the three categories presented in Sec-
tion 3.1. Thus, the type can be null,invariant,o ralternative .
The scope determines wherethe substitution expression is
to be applied within the program code. If the scope is ANY
then the substitution is applicable to any one of the occur-
rences of the substitution pattern; if the scope is ALLthen
the rule must be applied to all occurrences of the substi-
tution pattern; if the scope is a number nthen the rule is
applied to the n-th occurrence of the substitution pattern.
The substitution expression, which is the central compo-
nent of the rule, is deﬁned by one or more pairs of pattern
and replacement text. In our implementation, we deﬁne
each pair with a regular-expressionlanguage that is common
to many text processing tools.4However, for simplicity of
exposition, here we illustrate our examples with a slightly
diﬀerent notation in which we identify subexpressions as a
sort of variables. These variables are assigned by the pattern
expression, and then expanded in the replacement text. We
denote such variables with a dollar sign followed by a capital
letter (e.g., ‘ $X’). For simplicity, we omit the actual deﬁni-
tion of the subexpression corresponding to a variable, which
can be intuitively deduced from the context. The seman-
tics of a substitution with two or more pattern–replacement
pairs is that allpairs must be applied. Depending on the
scope, they must all be applied one time (scope ANY), for
every respective occurrence (scope ALL), and for the respec-
tiven-th occurrence (scope n).
As an example, consider the following rule:
alternative ALL:
$X.setStyle(width:$Y,height:$Z)
→$X.setStyle(width:$Y); $X.setStyle(height:$Z)
This rule refers to the example of the Facebook API given in
Section2, andindicatestheequivalencebetweenacalltothe
setStyle() method with two parameters, and two consecutive
calls to the same method, each with one of the two param-
eters. So, for example, this rule would transform the code
w.setStyle(width:10, height:20); into the equivalent sequence
w.setStyle(width:10); w.setStyle(height:20); .
Considernowaslightlymorecomplicatedrulethatalludes
to the Flickr permission problem described in Section 2:
invariant ANY:
getInfo()
→if(isPrivate()) {setPerms(public); setPerms(private); }
getInfo()
4See the POSIX.2 Regular Expression Notation.
240This rule represents an equivalent sequence generated by
an invariant operation. In particular, setPerms(public); set-
Perms(private) isaninvariantsequenceifthephotoisalready
classiﬁed as private. Therefore, the rewriting rule preﬁxes
the sequence with the appropriate runtime check. Notice
also that, even though such an invariant operation could be
inserted everywhere in the program, the rule speciﬁes a pat-
tern that limits the insertion of the invariant to a call to the
getInfo() method (in particular right before such a call).
3.3 A Priority Scheme for Rewriting Rules
A short application program with only a few rewriting
rules can give rise to many equivalent sequences, among
which the browser extension must select the ones to try as
workarounds. However, since equivalent sequences are sub-
mitted to, and implicitly validated by users, and since users
are likely to tolerate only a few repeated failures, it is cru-
cial that equivalent sequences be prioritized so as to increase
thechancesofﬁndingavalidworkaroundwithintheﬁrstfew
selected equivalent sequences. In this section we describe a
simple priority scheme intended for this purpose.
The scheme assigns a priority value to each rewriting rule.
A priority value consists of a pair ( success-rate ,success),
wheresuccess-rate is the ratio between the number of times
theequivalentsequencehasbeenusedsuccessfullyasawork-
around, and the number of times it has been used; and suc-
cessis the total number of times the rule has successfully
generated a workaround. The priority values of two rules
are compared by ﬁrst comparing their success-rate and then
success. In other words, priority p1=(r1,s1) is greater than
priority p2=(r2,s2)i fr1>r2or ifr1=r2ands1>s2.
If a rule was never used as a workaround, both success-rate
andsuccessare deﬁned to be 1.
When we have two or more rules with the same priority,
whichhappenscertainlywiththeﬁrstfailure, weapplyalter-
native rules ﬁrst, then invariant rules, and ﬁnally null rules.
We prefer alternative operations over invariant or null op-
erations because those replace code in the failing sequence,
and therefore are more likely to avoid faults. We then prefer
invariant operations to null operations because the former
are API-speciﬁc and therefore are more likely to mask faults
in the API.
Intheprocessofselectingequivalentsequences,unsuccess-
ful sequences are counted to determine the priority of the
corresponding rule, but are not considered a second time.
Also, each one of the equivalent sequences generated by a
rule with scope ANYis considered with the priority of that
rule, and in the order of occurrence of the substitution pat-
tern in the program.5
In summary, in the absence of any recorded workaround,
we start from alternative operations, then continue with in-
variant and null operations. In the presence of recorded
workarounds, we try those in order of success rate and,
among the ones with the same success rate, in order of the
absolute number of successes. This priority scheme is rather
simple, but still quite eﬀective in practice (see Section 4).
3.4 Automatic Oracle
An ideal prioritization scheme would rank the rewriting
rules such that, if a rule exists that would produce a valid
5The natural ordering was chosen for its simplicity. In the
future we plan to study other orders.workaround, then that rule should be selected ﬁrst. How-
ever, that is not always the case, especially at the beginning,
when little or no information is available on the eﬀectiveness
of the various rules. To cope with such cases, and in general
to further reduce the reliance on users to act as oracles, we
add anautomatic oracle to the browser extension.
The role of the automatic oracle is to reject equivalent se-
quences that have absolutely no visible eﬀect on the failing
page. More speciﬁcally, when the extension is invoked for
the ﬁrst time, the oracle is given the HTML and JavaScript
code of the original (failing) page as well as the new page
containing the selected equivalent sequence. In addition, the
oracle is given the recording of the observable events of the
failed execution. Then, the oracle executes the new appli-
cation code and compares the resulting page with the page
recordedfromthefailingexecution. Ifthetwopagesshowno
structural diﬀerence—that is, if their DOM representations
are identical—then the oracle rejects the proposed equiva-
lent sequence. Otherwise, if the two pages diﬀer even min-
imally, the oracle accepts the proposed equivalent sequence
and shows it to the user as a likely valid solution, and then it
is up to the user to conﬁrm the validity of the workaround.
Notice that valid workarounds would change the observable
behavior of the page, and consequently its structure. In
other words, the oracle acts conservatively by accepting any
change as a potentially valid workaround.
Every rejection by the oracle is interpreted as a rejection
bytheuserforthepurposeofadjustingthestatisticsandpri-
orities associated with rules. For every subsequent rejection
by the user, the oracle adds the new failing page to the set of
the failing pages it compares with every subsequent candi-
date workaround. Thus, each equivalent sequence supplied
by the AW module is compared with all the pages previously
ﬂagged by the user, and the oracle rejects all equivalent se-
quences that are identical to any one of the failing pages.
4. EXPERIMENTAL EV ALUATION
Wearticulateourevaluationaroundthefollowingresearch
questions:
Q1Canworkaroundscopewith failuresof Web applications
eﬀectively?
Q2Can workarounds be generated automatically?
Q3Can our proposed method generate valid workarounds?
The ﬁrst question (Q1) explores the possibility of using
workarounds to handle failures in Web applications, and
their eﬀectiveness. In other words, we ask whether work-
arounds even existand whether they can be used with Web
applications. A positive answer to this ﬁrst basic question
then leads directly to the second question (Q2), which asks
whether it is possible to generate workarounds automatically
or whether that is an inherently creative activity that should
be left to human designers. Finally, the third question (Q3)
evaluates the ability of the speciﬁc technique proposed in
this paper to generate and deploy valid workarounds.
Our general method of evaluation uses a two-pronged ex-
perimental approach. To provide an answer to Q1 and in
part to Q2, and also to gain a better understanding of typi-
cal failures in Web applications, we surveyed the fault repos-
itories and other on-line forums dedicated to popular Web
APIs. Then, to provide a constructive answer to Q2 as well
241as a direct answer to Q3, we implemented and tested a pro-
totype of the architecture described in Section 3. This pro-
totype, called RAW[5], is a Firefox browser plug-in, and
contains a database of rewriting rules for the Google Maps
and YouTube APIs. We now brieﬂy outline both the survey
method and the prototype implementation, and then turn
to the speciﬁc results we obtained pertaining directly to the
three research questions, examining each question in turns.
4.1 Survey of Failure Reports
For our survey of failures in Web applications we pro-
ceeded as follows. We ﬁrst identiﬁed a number of sources
of failure reports. In some cases (e.g., Google Maps and
YouTube player) these were oﬃcial and specialized bug-
tracking systems. In other cases (e.g., Yahoo! Maps, Mi-
crosoft Maps, Flickr, Picasa) we could only rely on on-line
discussion forums. Of all the oﬃcial and unoﬃcial reports,
we selected those that we thought might reveal useful infor-
mation on workarounds, using simple textual searches. We
then examined all the failure reports that even superﬁcially
indicated the possibility of a workaround to exclude irrele-
vant ones and to precisely identify failures and workarounds
for the relevant ones.
In some cases, we were fortunate enough to be able to
replicate failures and workarounds. We could do that with
the Google Maps library, since Google used to export the
complete version history of their Web APIs. Unfortunately,
recently Google removed many program versions from its
publicly available history, so we were unable to complete all
the experiments we had planned. In particular, we could
not repeat all our initial experiments with the automated
oracle, which we introduced only recently. In another case
(YouTube) we could only replicate the failures that have not
been ﬁxed.
These cases, where we could replicate failures and worka-
rounds, are particularly important because they oﬀer direct
evidence and also because they provide concrete case studies
for the evaluation of our prototype. We report extensively
on these cases in the following sections. In all other cases,
we could only rely on the more or less formal description
of the failure. Nevertheless, all the failure reports we ana-
lyzed were useful in characterizing failures and typical work-
arounds, and are the basis for the taxonomy of workarounds
synthesized in Section 3.1.
4.2 Workarounds for Web Applications
Our study of several repositories and forums dedicated to
open as well as ﬁxed faults in popular Web APIs indicates
that workarounds exist in signiﬁcant numbers and are often
eﬀective at avoiding or mitigating the eﬀects of faults for
Web applications.
APIreported
faultsanalyzed
faultsactual
workarounds
Google Maps 411 63 43 (10%)
YouTube 21 21 9 (42%)
Table 1: Faults and workarounds for Google Maps
and YouTube
The high-level results of our survey for Google Maps and
YouTube are summarized in Table 1. We studied the Google
Maps API bug tracker in July 2009 and we found a total of411 faults (excluding invalid bug reports). We selected the
entries potentially related to workarounds by matching the
keyword “workaround” in the bug report descriptions and
we obtained 63 entries. We then focused on these entries,
ignoring other possible workarounds not marked explicitly
as such. Upon further examination, we found 43 proper
workarounds (the word “workaround” occurs in comments
such as“Does anybody know a workarounds for this issue?”
that do not report any valid workaround). In total, this
amounts to about 10% of the reported faults. This result
indicates that workarounds can successfully address a good
amount of API runtime issues. We should note that the
10% prevalence of workarounds for the Google Maps API
is a conservative estimate, since we analyzed only 63 out of
411 reports.
To get additional information on the eﬀectiveness of work-
arounds for ﬁxing Web APIs, we considered the bug tracker
of the YouTube chromeless player, which included 21 known
issues at the time of the investigation. Given the modest
size of the repository, we analyzed all issues without resort-
ingtoanypre-ﬁltering. Outofthe21reports, weidentiﬁed9
workarounds, corresponding to about 42% of all issues. This
second result conﬁrms that workarounds can eﬀectively ad-
dress many runtime issues. These results have been further
conﬁrmed by the sampling of the bug repositories of other
popular Web APIs.
The data collected so far cannot be generalized to conclu-
sive quantitative results, but they nonetheless indicate that
it is often possible to overcome Web APIs issues by means
of appropriate workarounds.
4.3 Automatic Generation of Workarounds
Having observed that some failures of Web APIs can be
ﬁxed with workarounds, we want to show that at least some
of these workarounds can be generated automatically from a
set of reasonable and reasonably general rules. To that end,
wefurtheranalyzedthe52workaroundsthatwefoundinthe
bug-tracking repositories of Google Maps and YouTube (43
and 9, respectively). In particular, we tried to distinguish
between ad-hoc, hardly generalizable workarounds or work-
arounds that are simply not deployable at runtime, from
more general workarounds that are amenable to a runtime
deployment.
To illustrate the notion of an ad-hoc workaround, consider
issue n. 40 from the bug-tracking system of Google Maps.
The report states the following:
Some previously working KML ﬁles are now re-
porting errors when entered in Google Maps ...
The team conﬁrms this is due to problems with
Google fetching servers right now. Moving the
ﬁle to a new location is a possible temporary
workaround.6
The KML ﬁles mentioned in the report are ﬁles that the
application must make available to the Google Maps system
by posting them onto an accessible Web server. However,
due to some problem with its internal servers, the Google
MapssystemcouldnotaccesstheKMLﬁles, therebycausing
an API and application failure. The proposed workaround
amounts to posting the KML ﬁles on a diﬀerent server that
the Google servers could access correctly.
6http://code.google.com/p/gmaps-api-issues/issues/detail?id=40
242This report oﬀers a good example of a workaround that is
not amenable to automatic generalization and deployment.
This is the case for a number of reasons. First, the worka-
round is tied to an internal functionality of the Google Maps
application. Second, the workaround has almost nothing to
do with the code of the application, and in any case can not
be implemented by changing the application code. Third,
the solution involves components that are most likely out-
side of the control of the client application or anything in
between the client application and the application server.
Fourth, the report indicates that the problem exists “right
now,” and therefore might be due to a temporary glitch,
which is unlikely to generalize to a diﬀerent context at a
diﬀerent time.
By contrast, consider the workaround proposed for issue
n. 61 from the same Google Maps bug tracker. The report
reads as follows:
Many times the map comes up grey ... a slight
setTimeout before the setCenter ... might work.
... if you change the zoom level manually ... af-
ter themap is fullyloaded, it will load theimages
perfectly. So, what I did was add a“load”event
... and had it bump the zoom level by one and
then back to its original position after a really
short delay.7
This report contains an example of two workarounds that
are easy to generalizeand deployat runtime: add a setTime-
outandadd a zoom-in-zoom-out sequence , which are good
examples of null and invariant operations, respectively, as
deﬁned in Section 3.1.
APIanalyzed
workaroundsreusable
workarounds
Google Maps 43 14 (32%)
YouTube 9 5 (55%)
Table 2: Amount of reusable workarounds
Table 2 summarizes the results of this analysis: 32% of
the known workarounds found in the Google Maps reposi-
tory and 55% of the YouTube ones follow general patterns,
can be coded and reused, and therefore are good candidates
for automatic generation. This analysis provides encourag-
ing although perhaps still preliminary evidence that worka-
rounds can be generated at runtime from general rules.
4.4 Effectiveness of Automatic Workarounds
To investigate the eﬀectiveness of the approach proposed
inthispaper, weperformedvariousexperimentswithGoogle
Maps and YouTube.
We ﬁrst populated the repository of rewriting rules with
two sets of rules, one for each of the two selected APIs.
We generated these rules by studying the APIs of the two
libraries and by instantiating the three classes of rules intro-
duced in Section 3.1. In total, we wrote 40 rules for Google
Maps and 38 rules for YouTube, a subset of which are listed
in Table 3, with labels G1–G14 and Y1–Y6 for Google Maps
and YouTube, respectively.
We started with the 14 problems that had known worka-
rounds for Google Maps, and veriﬁed that RAW (our pro-
totype) can automatically generate a workaround for all of
7http://code.google.com/p/gmaps-api-issues/issues/detail?id=61them with the current set of rules. We then added 24 prob-
lems selected among the ones that were reported without
known workarounds and that could be reproduced with a
version of the API available in the Google Maps version his-
tory. We then replicated each of the 38 cases with RAW,
following the chronological order given by their issue num-
ber, initializing RAW with the same priority /angbracketleft1,1/angbracketrightfor all the
rules. In a ﬁrst run of these experiments, we used a proto-
typeimplementationofRAWthatdidnotincludetheoracle.
We then repeated the experiments with the latest prototype
implementation of RAW that includes the oracle. However,
unfortunately, during this second set of experiments, some
versions of the Google Maps API were unavailable, so that
we could only reproduce 24 of the original 38 failures.
We then turned to the 21 faults reported in the YouTube
failure repository. Unfortunately, YouTube does not provide
access to the version history of their API, so we could not
reproduce any failure that was later ﬁxed. Nevertheless, we
ﬁrst applied the rules manually (i.e., oﬀ-line) to the 21 fail-
ures, and veriﬁed that we could generate valid workarounds
for the ﬁve problems reported with known workarounds. We
also found a workaround for an open problem, to which we
could then apply RAW, including its oracle.
Table 4 reports the results of the experiments just de-
scribed. The ﬁrst column ( issue) indicates the issue num-
ber in the failure repositories. The following set of columns
(workaround ) reports the results of using RAW to generate
workarounds. Speciﬁcally, nonem e a n st h a tR A Wc o u l dn o t
generate any valid workaround; knownm e a n st h a tR A Wa u -
tomaticallygeneratedaworkaroundthatwasalreadyknown;
andnewmeans that RAW generated a new workaround for
an open problem. The fact that RAW can not only generate
all known workarounds, but also many additional worka-
rounds for open problems, provides an aﬃrmative answer to
our third research question (Q3) and conﬁrms our general
research hypothesis.
Therulecolumn indicates the rule that generated the
valid workaround (ﬁnd the corresponding rule in Table 3).
The experiment shows that workarounds are generated from
diﬀerent rules and that some rules can generate more than
one workaround. The set of experiments is not large enough
to generalize on the eﬀectiveness of some rules over others,
but we notice that generic rules such as timeout-insertion
seem to be more eﬀective than other, more speciﬁc rules.
The last two columns ( attempts ) are intended to measure
the eﬀectiveness of the priority scheme and the oracle. In
particular, both columns indicate the number of user inter-
ventions required to either identify a valid workaround or
to conclude that RAW could not generate any such worka-
round. The two columns labeled no oracle andoraclereport
the number of necessary interventions when RAW functions
without or with its automatic oracle, respectively. (Unfor-
tunately, we could not reproduce all the failures for the ora-
cleexperiments, so that column is incomplete.) The general
conclusion we draw from these experiments is that the prior-
ity mechanism is quite eﬀective in ﬁnding valid workarounds
butcanalsoannoytheuser, withnumbersofiterationsrang-
ing between 1 and 15. On the other hand, the oracle seems
very eﬀective in improving the situation by discarding many
invalid attempts and letting the users focus on few relevant
cases. The oracle prunes the set of candidate workarounds
and identiﬁes the correct workaround in the ﬁrst attempt in
16 out of 25 cases. It also always succeeds within the third
243Google Maps
G1null ALL: $X.openInfoWindowHtml($Y); →setTimeout(“$X.openInfoWindowHtml($Y)”, 1000);
G2alternative ALL: $X.addOverlay($Y); →$X.addOverlay($Y); $Y.show();
$X.removeOverlay($Y); →$Y.hide();
G3alternative ALL: $X.hide(); →$X.remove();
G4null ANY: $X.setCenter($Y); →setTimeout(“$X.setCenter($Y)”, 1000);
G5invariant ALL: $X.show(); →$X.show(); $X.show();
G6alternative ALL: $X.setCenter($Y); $X.setMapType($Z); →$X.setCenter($Y, $Z);
G7alternative ALL: $X.disableEditing(); →setTimeout(“$X.disableEditing()”, 200);
GDraggableObject.setDraggableCursor(“default”);
G8alternative ALL: $X.enableDrawing($Y); →var l=$X.getVertexCount(); var v=$X.getVertex(l-1); $X.deleteVertex(l-1);
$X.insertVertex(l-1,v); $X.enableDrawing($Y);
G9alternative ALL: $X.getInfoWindow().reset($Y); →$X.getInfoWindow().reset($Y, $X.getInfoWindow().getTabs(),
new GSize(0,0));
G10null ALL: $X.getVertexCount($Y); →setTimeout(“$X.getVertexCount($Y)”, 1000);
$K.getBounds($Z); →setTimeout(“$K.getBounds($Z)”, 1000);
G11alternative ALL: $X.bindInfoWindowHtml($Y); →GEvent.addListener($X,“click”, function()$X.openInfoWindowHtml($Y));
G12alternative ALL: var $X = new GDraggableObject($Y); -.setDraggableCursor($K); -.setDraggingCursor($Z); →
var $X = new GDraggableObject($Y, draggableCursor:$K, draggingCursor:$Z);
G13alternative ALL: GEvent.addDomListener($X),“click”, function() {$Y};→$X.onclick = function() {$Y}
G14null ALL: GEvent.trigger($X); →setTimeout(“GEvent.trigger($X)”, 1000);
YouTube
Y1alternative ANY: $X.seekTo($Y); →$X.loadVideoUrl($X.getVideoUrl(),$Y);
Y2alternative ALL: $X.setSize($Y,$Z); →$X.width=$Y; $X.height=$Z;
Y3alternative ALL: $X.seekTo($Y); →$X.cueVideoByUrl($X.getVideoUrl(),$Y);
Y4invariant ALL: $X.stopVideo(); →$X.pauseVideo(); $X.stopVideo();
Y5alternative ALL: $X.setSize($Y,$Z) →$X.width=$Y; $X.height=$Z;
Y6invariant ANY: $X.stop() →$X.stop(); $X.stop();
Table 3: Some Rewriting Rules for the Google Maps and YouTube APIs
attempt, either producing a valid workaround or signaling
that such a workaround could not be found.
4.5 Limitations and Threats to Validity
The technique presented in this paper is limited primarily
by the assumed nature of failures in Web applications. We
assume that failures are visible to the user, and furthermore
that the relevant application state consists of the structure
(DOM) of the application pages plus possibly server-side
data. Although this is consistent with the recommended ar-
chitecture and the general nature of Web applications, mod-
ern Web applications rely increasingly on client-side compu-
tations and state that do not aﬀect the structure of the ap-
plication pages. As future work, we plan to explore methods
to fully address failures of this kind of applications.
The experiments reported in this section provide encour-
aging results, but are not yet complete. We now discuss the
main threats to the validity of the experiments, and discuss
how we mitigated their eﬀects. The main threats to valid-
ity are related to the amount of data collected, and to the
number of Web APIs studied so far.
The data reported in the experiments are limited. We re-
portexperimentswithatotalof78rules(40forGoogleMaps
and 38 for You Tube) and 44 issues (14 faults with known
workaround plus 24 additional faults for Google Maps, and 5
with known workaround plus 1 without for YouTube). The
quantitativedatacannotbegeneralizedwithconﬁdence, but
the qualitative results are extremely encouraging. We lim-
ited our experiments on issues reported in public bug repos-
itories of popular applications. This choice allows us to rely
on the results qualitatively already with the available data,
and quantitatively when we will have more data points. The
limited amount of data is due to the diﬃculty of ﬁnding
reproducible failures. Many of the issues reported in bug
repositories are published with a solution, and most applica-tions do not support access to previous versions with faults.
Google Maps is a partial exception. This is why most data
reported here come from Google Maps.
The results are obtained only on two Web APIs, which
may not represent well the wider domain of Web APIs. We
investigatedseveral APIs, buthere we reportonlyon Google
Maps and YouTube, which we could study systematically.
The data obtained on other applications conﬁrm the results
reported in this paper. The chosen applications are two of
the most popular applications, and even though they may
not represent all Web APIs, they certainly represent a rele-
vant subset, thus even if the results would not generalize to
all APIs, they apply to a relevant set of applications.
The lack of a speciﬁc user study is another threat to the
validityofourexperimentalevaluation. Wehypothesizethat
users would be able to correctly detect failures and identify
valid workarounds, but we did not conﬁrm these hypotheses
with an appropriate experiment.
5. RELATED WORK
Avoiding failures by automatically preventing or recover-
ing from the occurrence of faults is the main goal of fault
tolerant systems, and more recently of autonomic and self-
healing systems. Recent work has taken inspiration from
classic fault tolerant and modern self-healing techniques for
the automatic recovery from failures of Web applications.
In this section, we brieﬂy survey the approaches related to
our work, highlighting similarities and diﬀerences, and also
pointing to the underlying classic methods.
Closely related to our research is the Browser JavaScript
plug-in for the Operabrowser that automatically applies
some ﬁxes to solve well known problems of interactions be-
tween Web applications and the browser. This plug-in im-
plements a given set of ﬁxes that are automatically deployed
when the user is visiting a web page that is incompatible
244issue workaround rule attempts
noneknown new no oracle oracle
Google Maps
15 /check – 10 2
29 /checkG12 1 –
33 /check G1 6 1
49 /check G2 2 1
61 /check G4 9 –
193 /check – 13 3
240 /check – 10 2
271 /check G5 2 –
315 /check G6 1 1
338 /checkG2 3 1
456 /checkG4 1 –
519 /check G4 1 –
542 /checkG10 4 –
585 /checkG2 4 –
588 /check G4 2 –
597 /check G7 1 –
715 /check – 10 1
754 /checkG2 13 2
737 /check G4 3 –
823 /check – 10 2
826 /check – 15 3
833 /check G4 2 –
881 /check G14 2 1
945 /check G2 3 –
1020 /checkG4 1 –
1101 /checkG10 1 1
1118 /checkG11 1 1
1200 /check – 14 3
1205 /check – 14 2
1206 /check – 8 1
1209 /checkG2 2 –
1234 /check G2 2 1
1264 /checkG3 3 2
1300 /checkG3 2 1
1305 /check G8 1 1
1511 /checkG13 1 1
1578 /checkG2 3 1
1802 /checkG9 1 1
YouTube
522 /check Y1 6 -
981 /check Y2 8 -
1030 /check Y3 8 -
1076 /check Y4 8 -
1180 /check Y5 1 -
1320 /checkY6 8 1
Table 4: Google Maps API and YouTube API issues
with the browser.8Diﬀerently from this plug-in, we propose
ageneralmechanismtoderiveandexecuteworkaroundsthat
can be automatically deployed in the presence of unexpected
failures. Still, the Opera plug-in conﬁrms both the indus-
trial interest and the applicability of the methods and ideas
proposed in this paper.
Classic approaches to tolerate faults rely on redundancy
and design diversity, that is, the use of independently de-
signed software components to reduce correlated faults. Re-
dundancy and design diversity are exploited, for example,
in N-version programming [2], in recovery blocks [19] and
in self-checking programming [14]. The increased reliability
gained with design diversity comes with high development
costs. Conversely, the method proposed here relies on the
intrinsic redundancy of many Web APIs, and therefore does
not incur additional development costs. Also, the program-
8http://www.opera.com/docs/browserjsrewriting rules, which express the intrinsic redundancy of
the Web APIs, can be provided incrementally and on de-
mand. We can for example assume a beta-testing period
during which failures and workarounds are reported to Web
applicationsandAPIsdesigners,whocanthenincrementally
populate the repository of program-rewriting rules.
Both Baresi et al. and Modaﬀeri et al. propose “rule en-
gines” that rely on registries to cope with failures [3, 15].
Similar to exception handlers, registries are provided by de-
velopers at design time, and contain lists of failures with
corresponding recovery actions to be executed at run time.
This method requires designers to predict failures and re-
covery actions at design time, and it can hardly deal with
unexpected runtime failures. Contrariwise, our approach re-
lies on a set of program-rewriting rules that can be adapted
to cope with unexpected runtime failures and can be added
incrementally without requiring expensive redeployment.
Denaro et al. propose wrappers to automatically adapt
Web services and overcome interface incompatibilities [10],
thus extending the work on wrappers that are classically
applied to mitigate the problems that may derive from in-
tegrating software components [17, 8]. As for rule engines,
wrappers have to be provided at design time, and thus have
limited success with unexpected failures.
Micro-reboot, checkpoint and recovery, and software re-
juvenation address non-deterministic failures by rebooting
the components that caused the failure (micro-reboot), by
rolling back to the latest consistent state and re-executing
the failing operations (checkpoint and recovery), and by
regularly restarting the system to prevent failures due to
software age (rejuvenation) [4, 11, 12]. Similar to these
approaches, Qin et al. propose the Rx method that par-
tially re-executes the failing program under modiﬁed en-
vironment conditions [18]. All these techniques deal with
non-deterministic failures and incompatibilities with the en-
vironment that are mostly outside the scope of this paper.
Wewouldliketoconcludethissectionbymentioningafew
approaches that attempt to automatically ﬁx faults at run-
time with diﬀerent strategies. Weimer et al. and Arcuri et
al. investigated genetic programming as a way to automati-
cally ﬁx software faults [20, 1]. Both approaches assume the
availability of a set of test cases to be used as oracles. When
the software system fails, the runtime framework automati-
cally generates a population of variants of the original faulty
program that are subsequently evolved through test-based
selection. These approaches are designed to work oﬄine,
since the evolution of the population and the execution of
the test suite are time consuming activities. Dallmeier et
al. proposed a technique that can generate fault ﬁxes by
comparing the models inferred from correct and failing exe-
cutions [9]. Similarly to the approach proposed by Dallmeier
et al., ClearView relies on dynamically inferred properties of
correct executions to detect and automatically ﬁx incorrect
behavior due to malicious attacks [16]. Although this ap-
proach could be extended to functional faults, so far it has
been proposed only to address security issues.
6. CONCLUSIONS
With this paper we develop the idea of automatic work-
arounds for Web applications. A workaround either avoids
or masks a failure in an application. Workarounds are typ-
ically suggested by developers or users, and deployed stati-
cally through an ad-hoc process. We propose a systematic
245method to generate and deploy workarounds dynamically,
at runtime, in the particular and increasingly important do-
main of Web applications. We detail this architecture to-
gether with a method to generate workarounds using code-
rewriting rules. In our experimental evaluation, we test the
validity of the notion of automatic workaround as well as
the eﬀectiveness of the proposed architecture. Our experi-
mental evaluation examines several common Web APIs, and
focuses on two (Google Maps and YouTube) that are proba-
bly the most widely used ones. The results of this evaluation
are very encouraging, and lead us to believe that automatic
workarounds can be very eﬀective with Web applications.
Thenotionofautomaticworkaroundaswellasthespeciﬁc
methods developed in this paper can and should be explored
further. First, we would like to widen the scope of our ex-
periments to more applications and APIs. Part of this eﬀort
will require the development of our browser extension pro-
totype beyond its initial capabilities. Furthermore, a serious
experimental evaluation would beneﬁt greatly from a more
direct access to the version history and the knowledge avail-
able from internal issue-tracking systems or even directly
from developers.
Beyond improving the speciﬁc techniques and strengthen-
ing the experimental evaluation, this work raises more gen-
eral and exciting research questions. One of these is moti-
vated by the wide-scale and social nature of Web applica-
tion themselves: it is only natural to see the formulation and
deployment of workarounds as yet another Web application.
Therefore, it is natural to study how automatic workarounds
could be developed, enhanced, and shared more eﬀectively.
Acknowledgments
This work was supported in part by the Swiss National Sci-
ence Foundation, with projects n. 200021-116287(“Perseos”)
and n. 200020-124918 (“WASH”).
7. REFERENCES
[1] A. Arcuri and X. Yao. A novel co-evolutionary
approach to automatic software bug ﬁxing. In
Proceeding of IEEE Congress on Evolutionary
Computation , pages 162–168, 2008.
[2] A. Avizienis. The N-version approach to fault-tolerant
software. IEEE Transactions on Software Engineering ,
11(12):1491–1501, 1985.
[3] L. Baresi, S. Guinea, and L. Pasquale. Self-healing
BPEL processes with Dynamo and the JBoss rule
engine. In Proceedings of the International Workshop
on Engineering of Software Services for Pervasive
Environments , pages 11–20, 2007.
[4] G. Candea, E. Kiciman, S. Zhang, P. Keyani, and
A. Fox. JAGR: An autonomous self-recovering
application server. In Active Middleware Services ,
pages 168–178. IEEE Computer Society, 2003.
[5] A. Carzaniga, A. Gorla, N. Perino, and M. Pezz` e.
RAW: Runitime automatic workarounds. In
Proceedings of the 32nd International Conference on
Software Engineering , pages 321–322. ACM, 2010.
[6] A. Carzaniga, A. Gorla, and M. Pezz` e. Healing Web
applications through automatic workarounds.
International Journal on Software Tools for
Technology Transfer , 10(6):493–502, December 2008.
[7] A. Carzaniga, A. Gorla, and M. Pezz` e. Self-healing bymeans of automatic workarounds. In Proceedings of
the 2008 International Workshop on Software
Engineering for Adaptive and Self-Managing Systems ,
pages 17–24, 2008.
[8] H. Chang, L. Mariani, and M. Pezz` e. In-ﬁeld healing
of integration problems with COTS components. In
Proceeding of the 31st International Conference on
Software Engineering , pages 166–176, 2009.
[9] V. Dallmeier, A. Zeller, and B. Meyer. Generating
ﬁxes from object behavior anomalies. In Proceedings of
the 24th IEEE/ACM International Conference on
Automated Software Engineering , pages 550–554.
IEEE Computer Society, 2009.
[10] G. Denaro, M. Pezz` e, and D. Tosi. Ensuring
interoperable service-oriented systems through
engineered self-healing. In Proceedings of the 7th joint
meeting of the European Software Engineering
Conference and the ACM SIGSOFT Symposium on
the Foundations of Software Engineering , pages
253–262. ACM, 2009.
[11] M. Elnozahy, L. Alvisi, Y. min Wang, and D. B.
Johnson. A survey of rollback-recovery protocols in
message-passing systems. ACM Computing Surveys ,
34(3):375–408, 2002.
[12] S. Garg, Y. Huang, C. Kintala, and K. S. Trivedi.
Minimizing completion time of a program by
checkpointing and rejuvenation. SIGMETRICS
Performance Evaluation Review , 24(1):252–261, 1996.
[13] L. Jiang and Z. Su. Automatic mining of functionally
equivalent code fragments via random testing. In
Proceedings of the 18th International Symposium on
Software Testing and Analysis , pages 81–92, 2009.
[14] J.-C. Laprie, C. B´ eounes, and K. Kanoun. Deﬁnition
and analysis of hardware- and software-fault-tolerant
architectures. Computer , 23(7):39–51, 1990.
[15] S. Modaﬀeri, E. Mussi, and B. Pernici. SH-BPEL: a
self-healing plug-in for WS-BPEL engines. In
Proceedings of the 1st workshop on Middleware for
Service Oriented Computing , pages 48–53, 2006.
[16] J. H. Perkins, S. Kim, S. Larsen, S. Amarasinghe,
J. Bachrach, M. Carbin, C. Pacheco, F. Sherwood,
S. Sidiroglou, G. Sullivan, W.-F. Wong, Y. Zibin,
M. D. Ernst, and M. Rinard. Automatically patching
errors in deployed software. In Proceedings of the 22nd
symposium on Operating systems principles , pages
87–102, 2009.
[17] P. Popov, S. Riddle, A. Romanovsky, and L. Strigini.
On systematic design of protectors for employing OTS
items. In Proceedings of the 27th Euromicro
Conference , pages 22–29, 2001.
[18] F. Qin, J. Tucek, Y. Zhou, and J. Sundaresan. Rx:
Treating bugs as allergies—a safe method to survive
software failures. ACM Transactions on Computer
Systems, 25(3):7, 2007.
[19] B. Randell. System structure for software fault
tolerance. In Proceedings of the International
Conference on Reliable Software , pages 437–449, 1975.
[20] W. Weimer, T. V. Nguyen, C. Le Goues, and
S. Forrest. Automatically ﬁnding patches using genetic
programming. In Proceeding of the 31st International
Conference on Software Engineering , pages 364–374,
2009.
246