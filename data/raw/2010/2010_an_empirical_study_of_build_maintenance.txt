See	discussions,	stats,	and	author	profiles	for	thi s	publication	at:	 https://www.researchgate.net/publication/221555430
An	empirical	study	of	build	maintenance	effort
Conference	Paper 		in		Proceedings	-	International	Conference	on	Software	 Engineering	·	January	2011
DOI:	10.1145/1985793.1985813	·	Source:	DBLP
CITATIONS
40READS
74
5	authors ,	including:
Bram	Adams
Polytechnique	Montréal
149	PUBLICATIONS 			1,519	CITATIONS 			
SEE	PROFILE
Thanh	H.	D.	Nguyen
Queen's	University
15	PUBLICATIONS 			401	CITATIONS 			
SEE	PROFILE
Yasutaka	Kamei
Kyushu	University
86	PUBLICATIONS 			551	CITATIONS 			
SEE	PROFILE
Ahmed	E.	Hassan
Queen's	University
274	PUBLICATIONS 			4,161	CITATIONS 			
SEE	PROFILE
All	content	following	this	page	was	uploaded	by	 Ahmed	E.	Hassan 	on	10	April	2014.
The	user	has	requested	enhancement	of	the	downloade d	file.	All	in-text	references	 underlined	in	blue 	are	added	to	the	original	document
and	are	linked	to	publications	on	ResearchGate,	let ting	you	access	and	read	them	immediately.An Empirical Study of Build Maintenance Effort
Shane McIntosh, Bram Adams, Thanh H. D. Nguyen,
Y asutaka Kamei, and Ahmed E. Hassan
Software Analysis and Intelligence Lab (SAIL)
School of Computing, Queen’s University, Canada
{mcintosh, bram, thanhnguyen, kamei, ahmed}@cs.queensu.ca
ABSTRACT
The build system of a software project is responsible for
transforming source code and other development artifacts
into executable programs and deliverables. Similar to source
code, buildsystemspeciﬁcationsrequiremaintenancetocope
with newly implemented features, changes to imported Ap-
plication Program Interfaces (APIs), and source code re-
structuring. In this paper, we mine the version histories
of one proprietary and nine open source projects of di ﬀerent
sizes and domain to analyze the overhead that build mainte-
nance imposes on developers. We split our analysis into two
dimensions: (1) Build Coupling, i.e., how frequently source
code changes require build changes, and (2) Build Owner-
ship, i.e., the proportion of developers responsible for build
maintenance. Our results indicate that, despite the di ﬀer-
ence in scale, the build system churn rate is comparable to
that of the source code, and build changes induce more rel-
ative churn on the build system than source code changes
induce on the source code. Furthermore, build maintenance
yields up to a 27% overhead on source code development
and a 44% overhead on test development. Up to 79% of
source code developers and 89% of test code developers are
signiﬁcantly impacted by build maintenance, yet investment
in build experts can reduce the proportion of impacted de-
velopers to 22% of source code developers and 24% of test
code developers.
Categories and Subject Descriptors
D.2.6[Software Engineering ]: Programmingenvironments—
Programmer workbench ; D.2.9 [ Software Engineering ]:
Management— Productivity, Programming teams, Software
conﬁguration management
General Terms
Management, Measurement
Keywords
Empirical software engineering, build systems, mining soft-
ware repositories
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’11, May 21–28, 2011, Honolulu, Hawaii, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00.1. INTRODUCTION
The build system of a software project is the infrastruc-
ture that translates source code, libraries, and data ﬁles into
a set of deliverables (e.g., executables and documentation)
that are ready for distribution to customers. This trans-
formation into deliverables may involve thousands of build
commands that must be executed in a speciﬁc order to en-
sure the validity of the end product.
The build system is at the heart of the software devel-
opment ecosystem. First, developers need to run the build
system dozens of times per day to test the impact that their
code changes have on the software product. Second, the
build system is responsible for co-ordinating the execution
of unit tests, for example to only run the most critical tests
foragivensourcecodechangeinsteadoftheentiretestsuite.
Third, the complex task of packaging a software product for
release is typically automated by the build system, ensuring
that the correct versions of software components, required
libraries, documentation, and data ﬁles are included in the
release. Fourth, the practice of continuous integration, i.e.,
regularly downloading the latest source code changes onto
a dedicated server to validate that all unit and integration
tests still pass, would be impossible without a robust build
system that co-ordinates deliverable construction, test suite
execution, and test report generation.
Despite the critical role of the build system, build main-
tenance e ﬀort and its overhead on developers is still largely
undocumented. Of course, every seasoned programmer has
build system horror stories, ranging from cryptic build er-
ror messages to subtle inconsistencies in build deliverables.
Prior research on a number of small software projects esti-
mates that build maintenance imposes a 12% overhead on
the development process [13], distracting developers from
their main tasks. Other researchers studied the build sys-
tem of the Linux kernel, and found that the Linux build
engineers have spent a considerable amount of time to make
their build system as simple as possible for developers, at
the expense of a very complex and hard to maintain core
of build system machinery [2]. Recently, large software sys-
tems such as MySQL [9], Second Life [14], and KDE [22],
havemigratedfromolderbuildsystemtechnologieslike make
to newer build technologies like cmaketo reduce the impact
that tedious build maintenance has on the productivity of
developers.
To provide project managers and developers with tangible
measurements of the overhead of build maintenance, this
paper performs a detailed empirical study of ten large, long-
lived C and Java projects, including one proprietary Javasystem. We study the logical coupling [8] between source
code and build system changes across individual revisions
as well as across groups of revisions that resolve a work item
(e.g., an enhancement or a bug ﬁx). We ﬁnd that: (1) the
buildsystemaccountsforarelativelysmallproportionofthe
ﬁles in a project (9% median), yet has a comparable churn
rate to the source code, suggesting that build systems are
continually evolving and are likely to have defects [20], and
(2) up to 27% of the work items involving production code
changes (i.e., changes to system functionality), and 44% of
the work items involving test code changes (i.e., changes to
the automated tests and the test automation framework)
require build maintenance.
The take-home message of this paper is that managers
for C projects should explicitly account for up to 27% of
the work items involving production code changes to re-
quire build maintenance. Managers for Java projects can
expect that 4–16% of the work items involving production
code changes to require build maintenance. The analyzed
projects adopt one of two build ownership styles to cope
with build maintenance: (1) most build changes are per-
formed by a small team of buildexperts, or (2) buildchanges
are dispersed amongst the development team.
The main contributions of this paper are empirical studies
in ten large, long-lived software systems to analyze:
1. The size and churn rate of the build system.
2. The coupling between production and test code with
the build system at the revision and work item levels.
3. Build ownership distribution across developers.
Paper Organization – Section 2 motivates our study
of build maintenance, followed by a preliminary analysis of
build maintenance in Section 3. Section 4 studies the logi-
cal coupling of production and test code changes with build
changes, while Section 5 studies how projects distribute the
build maintenance work. The threats to the validity of our
work are presented in Section 6. Section 7 surveys related
work. Finally, Section 8 presents the conclusions.
2. THE CRITICAL ROLE OF THE BUILD
The build system plays an important role in software de-
velopment, since most stakeholders in the software develop-
ment process interact with it [24].
First oﬀ, developers use a build system on a daily basis
to test a software system after adding a new feature or ﬁx-
ing a bug. To minimize the time spent waiting while the
build executes, build systems typically provide incremental
build modes. Still, the interaction between build systems
and developers is a major source of frustration. To illus-
trate this frustration, we analyzed the bug repositories of
Mozilla, ArgoUML, and Eclipse. For example, Mozilla de-
fect 351377 [17] describes a case where one Mozilla developer
had removed an obsolete part of the build code and tested
his changes locally without any issue. However, when an-
other developer merged the build changes with his working
copy, he could no longer run the build because of subtle
diﬀerences between his build environment and the ﬁrst de-
veloper’s one. The second developer (and conceivably many
others) could no longer build or test changes locally until
this build issue was resolved.A second important interaction of the build system is with
the Continuous Integration (CI) server [26]. This server reg-
ularly downloads the latest source code changes to run all
automated unit and integration tests, with the aim of iden-
tifying defects in new source code as soon as possible. To
accomplish this, CI servers execute project builds that ﬁrst
construct the deliverables, then run the automated tests,
and ﬁnally generate extensive test reports. Again, many
problems can appear during this interaction with the build
system. For example, build number 175 on the ArgoUML
CI server failed to complete [23]. Developer time and e ﬀort
was then invested to determine which change was respon-
sible for the build failure, and what corrective action was
needed. It took the developers two days to determine the
root cause of the build failure. This investigation diverted
developer attention away from the core tasks of ﬁxing bugs
and adding new features.
A third important interaction of the build system is with
software release management [7]. The build system is re-
sponsible for bundling software deliverables into an instal-
lable package. All necessary components of the product
should be bundled together, i.e., the correct versions of re-
quired libraries, data ﬁles, product documentation, and con-
structed deliverables. Since the released package is the ﬁ-
nal product of software development, any build error propa-
gates directly to the customer. For example, in Firefox 3.0,
issue 417037 [29] prevented users in a networked environ-
ment from accessing web pages via the address and search
bars, the core feature of any web browser. Users in this
networked environment could not use the Firefox 3.0 prod-
uct until the release of the ﬁrst service pack, i.e., 3.0.1, four
months later. It turned out that a change to the Firefox
build system caused executables to link against an incorrect
version of the SQLite library, leading to inconsistencies in
the Firefox 3.0 package.
Since build systems play a critical role in software de-
velopment, build systems are typically hard to debug and
understand [3, 30], and build system problems can have a
majorimpact, evenontheenduser, itisimportanttounder-
stand how build systems are maintained in practice. Similar
to Kumfert et al.[13], we assume that build maintenance is
not accounted for in a project’s budget (it is a hidden cost),
hence we consider any development activity requiring build
changes as overhead on development progress. Empirically
measuring this overhead is the goal of this paper.
3. PRELIMINARY ANALYSIS
In prior work, we showed that build systems evolve in size
and complexity, and that there is a correlation between the
sizeandcomplexityofthesourceandbuildﬁles[2,16]. How-
ever, this prior analysis was performed on releases, not on
revisions in code repositories, and we did not distinguish be-
tween test and production code. Hence, although we showed
a correlation, it is not certain that individual developer ac-
tions in between releases, such as adding a ﬁle or restructur-
ing a method, are directly coupled to build changes.
To address this gap, we perform a revision-level analysis
focused on the following three Preliminary Questions (PQs):
PQ1) How many ﬁles does a typical build system consist of?
We want to study the size of a typical build system
to better understand the magnitude of build mainte-
nance.Table 1: Listing of the studied projects. Asterisks (*) denote pr eviously used build technologies.
ArgoUML Hibernate Eclipse Jazz GCC Git Linux Mozilla PLplot PostgreSQL
Timespan ’98-’09 ’01-’07 ’01-’10 ’07-’08 ’88-’05 ’05-’09 ’0 5-’10 ’98-’10 ’92-’09 ’96-’09
Program lang Java Java Java Java C C C C C C
Build techs. Make* ANT* PDE Build PDE Build Autotools Make Make Mak e Make* Autotools
ANT Maven Autoconf KConﬁg Autoconf Autotools*
CMake
# Build Files614 211 483 5,967 1,719 43 3,726 10,709 652 771(BF)
# Prod Files 7,116 9,272 2,391 45,275 14,181 743 42,912 43,95 2 659 2,683
# Test Files 891 7,426 1,211 14,738 21,109 824 340 30,835 791 1, 377
Total (TS) 8,007 16,698 3,602 60,013 35,290 1,567 43,252 74,78 7 1,450 4,060
BF
BF+TS7% 1% 12% 10% 5% 3% 8% 12% 31% 16%
Table 2: File type classiﬁcation examples.
Build Production Test
Build code Production code Unit tests
(Makeﬁle*, conﬁgure*) (*.c*, *.h*, *.java) (*.c*, *.h*, *.java )
PQ2) How much does a typical build system churn?
Churn measures the rate of change in source code.
Priorstudieshavefoundthatfrequentlychangingsource
code, i.e., code with high churn, has a higher defect
density [20] and causes more post-release defects [21].
We want to measure churn in the build system to
gain insight into how susceptible the build system is
to defects.
PQ3) How large are typical build system changes?
There is no prior work that quantiﬁes the size of typ-
ical build system changes. Large changes imply that
considerable e ﬀort is put into build maintenance.
3.1 Studied Projects
Tocombatpotentialbiasinour results, we conduct alarge
scale study of projects of di ﬀerent sizes and domain, im-
plemented with di ﬀerent programming languages and build
technologies, prescribingtoproprietaryandopensourcepro-
cesses. Table 1 gives an overview of the studied projects.
ArgoUML is a computer-aided software engineering tool
for producing Uniﬁed Modelling Language (UML) diagrams.
Hibernate is an object-to-relational mapping framework for
Java programs, of which we examined the “core” subpro-
ject. Eclipse is an open source Integrated Development En-
vironment (IDE), of which we studied the“core”subsystem.
JazzTM1is a proprietary next-generation IDE developed
by IBM. The GNU Compiler Collection (GCC) is a popu-
lar source code compiler with front-ends for many program-
minglanguages. GitisaDistributedVersionControlSystem
(DVCS). Linux is an operating system kernel. Mozilla is a
suite of internet tools, including (amongst others) the Fire-
fox web browser. PLPlot is a plotting library with bindings
for many popular programming languages. PostgreSQL is
an object-relational database system.
3.2 Approach
Figure 1 shows an overview of our approach.
1http://www.jazz.net . IBM and Jazz are trademarks of
IBM Corporation in the US, other countries, or both.Data preprocessing –AfterdownloadingtheVCSrepos-
itories of the ten studied projects, we extract the list of all
revisions that have been committed by developers through-
out the analyzed timespan, as well as the list of all ﬁles
that ever existed. We wrote a dedicated shell script for this
extraction.
File type classiﬁcation – We classify each unique ﬁle
that ever existed in the analyzed timespan as either build,
production, or test code. Those ﬁles that do not ﬁt in any
category are marked as “other”. Table 2 provides example
classiﬁcations for some types of ﬁles. To facilitate future
studies, we have put the resulting classiﬁcations online [1].
The classiﬁcation process was semi-automated. Most ﬁles
could be classiﬁed using ﬁle type naming conventions, e.g.,
Makefile s were marked as build ﬁles. However, patterns
such as“.java”and“.xml”were ambiguous, since some .java
ﬁles are production code while others are test code. After
initial ﬁltering of unambiguous ﬁle types, the remaining ﬁles
had to be classiﬁed manually. For example, of the 49,364
ﬁles in Linux, approximately 40,000 could be classiﬁed au-
tomatically. The remaining 9,000 or so ﬁles had to be tagged
manually based on our inspection of the ﬁles and prior ex-
perience with build systems [2, 3, 16].
The GCC, Git, Mozilla, PLplot, and PostgreSQL projects
make use of the GNU Autotools and CMake build abstrac-
tion languages. These languages allow developers to imple-
ment build logic for many di ﬀerent platforms using an ab-
stract representation of the build process. A build code gen-
eratorproducesthenecessaryplatform-speciﬁcbuildcodeat
build-time. For these case studies, we focus our analysis on
revisionstotheGNUAutotoolsandCMakeabstractionﬁles,
not to the generated Makefile s andconfigure scripts, since
thegeneratedﬁlesarerarelyrecordedintheVCS.Intherare
cases that generated ﬁles are (accidentally) recorded in the
VCS, they introduce noise in our data. This noise turns out
to be limited in practice.
Work item aggregation – By examining the messages
of each revision, we were able to group revisions according
to the Issue Tracking System (ITS) work item ID that they
collectively resolve. Work item aggregation is performed to
provideacoarsergranularityofanalysisrepresentingasingle
unit of development work instead of single revisions.
Item/Revision classiﬁcation – Equipped with the list
of classiﬁed ﬁles, the VCS revisions and work items can be
classiﬁed. Unlike the ﬁle type classiﬁcation, a revision or
work item can ﬁt into many categories. For example, if a re-!"#$%&'()
$%&'(*
+++
$%&'(,!"#$%&'($)*#'))"+$,
-.$()/0$1")"23)
#-.
/'01
2&34'5%0%67()
4'5%0%67(*
+++
4'5%0%67(,0$1")"23)*#'))"+$,
!"#$)
#-./'01
2&3$%&'(/89'
"&:00%;.:1%67
<1'=>4'5%0%67
"&:00%;.:1%67?:1:
@-'9-6.'00%7A<?)BBB)
<?)BBB*
+++
<?(,4256%-.$()
C6-D(<1'=
EAA-'A:1%67
Figure 1: Overview of our approach to study build maintenance e ﬀort.
vision or work item modiﬁes both build and production ﬁles,
it is marked as both a build and production code modifying
revision or work item.
PQ1 – The build system accounts for 9% of the
maintained ﬁles
Table1showsthatthebuildsystemaccountsfor1-31%ofall
maintained ﬁles that ever existed in the analyzed timespan,
with a median of 9%. These low values indicate that in
most cases (PLplot being the exception), the build system
is dwarfed by the other development artifacts.
Hibernate-core(1%)andPLplot(31%)areanomalies. Be-
ing entirely composed of a single library, the Hibernate-core
project has little build code (211 ﬁles), which explains the
low 1%. On the other hand, the PLplot project has the
most inﬂated build ﬁle percentage (31%). While the PLplot
project is rather small, it provides bindings to many pro-
gramminglanguages. Eachbindinghasitsownbuildcompo-
nent, increasing the build system size. The problem is com-
pounded by two build technology migrations that PLPlot
has undergone. The migrations reimplemented build code
frommakeinto GNU Autotools, and later from GNU Auto-
tools into CMake.
PQ2 – Normalized churn rates of build and source
code ﬁles are comparable
To study the churn rate in the build system, we compare
it against that of the source code. To account for the dis-
crepancy in size between source and build ﬁles (PQ1), we
measure the churn rate in the source code and build sys-
tem using normalized churn . First, we count the number of
source ﬁles and the number of build ﬁles that were changed
in each month-long development period. Then, we divide
each count by the total number of source ﬁles or the total
number of build ﬁles that existed in that period. We repeat
this process for each month. We chose a month-long period
rather than shorter periods, such as a day or a week, be-
cause the latter two are typically too short for a signiﬁcant
amount of development to occur.
Figure 2 plots the distribution of the monthly normalized
churn using a beanplot. Beanplots are boxplots in which the
vertical curves summarize and compare the distributions of
diﬀerent data sets [10], which in our case correspond to the
normalized churn of build and source code in month-long
development periods. The horizontal black lines indicate the
median of the normalized change for each project’s source
(black) and build ﬁles (grey).
In most of the studied projects, the median of the monthly
normalizedchangeforthesourceandbuildﬁlesarerelatively
close to each other, only di ﬀering by at most 7% (GCC).Hibernate-core is the only project with a median value of
the normalized churn for the build ﬁles greater than that of
the source ﬁles. The Hibernate-core project had only 1-7
build ﬁles during the ﬁrst 12 months of development, and
easily reached 100% normalized churn, skewing the median.
The comparable churn in the source and build ﬁles is
concerning, since prior research on source code has shown
that frequently churning modules contain more defects than
slowly changing ones [20]. Build maintainers must be very
diligent to ensure that the build system does not become
defect-prone, since a defect-ridden build system may: (1)
slow development progress due to suboptimal build rou-
tines [18], and (2) fail to produce correct deliverables, grind-
ing development progress to a halt [11, 23].
PQ3 – Build changes induce more relative churn
than source code changes do
Table 3 shows the median of the number of Lines added and
deleted Per Revision (LPR) in nine of the studied projects.
Jazz data was unavailable for analysis because we do not
have access to the actual source code. We also normalize
the median LPR by the number of build and source ﬁles
respectively, yielding the Lines added and deleted per Re-
vision and File (LPRF). Since the LPRF values are quite
small, we report them as a percentage, i.e., multiply by 100.
Most source code changes add 8–17 lines and delete 4–9
lines(median). Thecorrespondingnumbersforbuildchanges
are 2–6 lines and 1–5 lines. Thus, the size of a typical
build change is about 1/4–1/2 of the size of a typical source
change. However, the LPRF values show that build changes
induce more relative churn on the build system than source
code changes induce on the source code. PLplot presents the
only exception, since the LPRF for added lines is smaller for
the build system than for the source code. This is due to
the inﬂated size of the PLplot build system, since it endured
two build technology migrations (see PQ1).
3.3 Discussion
We ﬁnd that the build system is relatively small in size,
being composed of 9% (median) of the ﬁles in the studied
projects (PQ1). However, it churns frequently, at rates sim-
ilar to the source code, suggesting that an overhead is im-
posed upon developers (PQ2). Build maintenance changes
typically add 2–6 and delete 1–5 lines, and generate more
relative churn for the build system than the source code
changes generate for the source code (PQ3).
To analyze whether these revision-level build changes are
burdensome on developers, we now investigate how tightly
coupled developer changes to production and test code are
to build changes. We focus our study of build maintenance!"! !"# !"$ !"% !"& '"!
()*+,-. /012)3452 67809:2 ;4<< =>> =05 .03?@ -+<0884 A.98+5 A+:5*)2BC.
A)+D275:E+)F480<2GH>I?)3
Figure 2: Distribution of monthly churn in source (black) an d build (grey) ﬁles.
Table 3: Median LPR (#) and LPRF (%) for all projects except Jazz.
ArgoUML Hibernate Eclipse GCC Git Linux Mozilla PLplot PostgreSQL
+ - + - + - + - + - + - + - + - + -BldLPR 2 2 4 2 3 2 6 5 2 1 2 2 4 3 5 4 4 3
LPRF 0.33 0.33 1.90 0.95 0.62 0.41 0.35 0.29 4.65 2.32 0.05 0.0 5 0.04 0.03 0.77 0.61 0.52 0.39ProdLPR 15 9 17 9 10 5 8 5 8 4 9 6 11 6 14 7 15 9
LPRF 0.19 0.11 0.10 0.05 0.28 0.14 0.02 0.01 0.51 0.26 0.02 0.0 1 0.01 0.01 0.97 0.48 0.37 0.22
overhead on the following two Research Questions (RQs):
RQ1) How tight is the coupling between source code and
build system? (Section 4)
Kumfert et al.estimate that developers spend 12%
of their time keeping the build system in sync with
the source code, rather than ﬁxing bugs and adding
new features [13]. These results are mainly based on
a survey asking developers about their overall build
maintenance investment. We are interested in rigor-
ouslyvalidatingtheseﬁndingswiththeactualchanges
developers make.
RQ2) How is build ownership distributed amongst develop-
ers?(Section 5)
Since build ﬁles churn frequently, projects such as
Linux [2] and Perl [30] designate members of the de-
velopment team as build experts. To study the dif-
ferent ways in which projects allocate personnel to
build maintenance, we want to see how many devel-
opers have to change the build.
4. BUILD COUPLING (RQ1)
In this section, we measure how tight the coupling is be-
tween the build ﬁles and production or test ﬁles.
4.1 Approach
We adopt association rules to measure the relationships
between production, test, and build ﬁles. An association
rule is a statistical description of co-occurring elements in
a dataset [4]. For example, Amazon.com recommends addi-
tional purchases to a customer by mining association rules
from their database of prior customer purchases. In our
case, we do not mine new association rules, but rather we
evaluate the following speciﬁc associations:
Prod⇒Bldmeasures the implication that a production
code change will be accompanied by a build change in theTable 4: Association rule interest metrics.
Metric Calculation
Support(A)#class A revisions
#total revisions
Conf(A⇒B)Support (A,B)
Support (A)
Conv(A ⇒B)Support (A)×Support (¬B)
Support (A,¬B)
same revision or work item. Similarly, Test⇒Bldmea-
sures the implication that a test code change will be accom-
panied by a build change in the same revision or work item.
Bld⇒Prodmeasurestheimplicationthatabuildchange
will be accompanied by a production code change in the
same revision or work item. Intuitively, we expect this im-
plication to be strong, since our prior work [16] showed that
the majority of build maintenance is the result of production
code changes. Hence, we expect that build changes should
be grouped with the source code changes that initiated it.
Similarly, Bld⇒Testmeasurestheimplicationthatabuild
change will require an accompanying test code change.
We evaluate the association rules above using the“inter-
est” metrics in Table 4. Support(X) is deﬁned as the pro-
portion of revisions or work items that contain X [4]. The
coupling or conﬁdence metric Conf(X ⇒Y) measures the
strength of the implication that a change to Y will occur
within the same revision or work item as a change to X [4].
Gallet al.useanidenticalmetrictomeasurelogicalcoupling
between source code ﬁles [8]. Note that conﬁdence measures
are asymmetrical, i.e., Conf(X ⇒Y)/negationslash= Conf(Y ⇒X).
We use a χ2goodness-of-ﬁt test [27] to validate the statis-
tical signiﬁcance of the coupling between changes to X and
Y. If the χ2statistic is greater than 3.84 ( α= 0.05), the
relationship is statistically signiﬁcant. Otherwise, the ob-
served relationship is due to chance. We report the p-value
of theχ2test, rather than the χ2statistic. The χ2statistic
is symmetrical.Table 5: Revision-level interest metric values for production, test , and build code.
ArgoUML Hibernate Eclipse Jazz GCC Git Linux Mozilla PLplot Pos tgreSQL
SupportProd 0.62 0.62 0.68 0.69 0.56 0.61 0.87 0.70 0.39 0.55
Test 0.06 0.32 0.23 0.18 0.13 0.11 0.01 0.08 0.19 0.10
Bld 0.07 0.08 0.08 0.09 0.15 0.07 0.10 0.16 0.36 0.16
Prod, Bld 0.01 0.03 0.02 0.03 0.04 0.03 0.06 0.06 0.03 0.05
Test, Bld <0.01 0.02 0.01 0.01 0.01 <0.01<0.01 0.01 0.03 0.02
ConfProd⇒Bld 0.02 0.05 0.03 0.04 0.07 0.04 0.06 0.08 0.08 0.10
Bld⇒Prod 0.16 0.36 0.28 0.28 0.27 0.41 0.56 0.35 0.09 0.34
Test⇒Bld 0.05 0.05 0.03 0.07 0.07 0.04 0.13 0.16 0.17 0.19
Bld⇒Test 0.04 0.20 0.09 0.13 0.06 0.07 0.01 0.08 0.09 0.11
ConvProd⇒Bld 0.95 0.96 0.95 0.94 0.92 0.98 0.96 0.91 0.69 0.93
Bld⇒Prod 0.45 0.59 0.44 0.43 0.60 0.66 0.30 0.46 0.67 0.68
Test⇒Bld 0.98 0.97 0.95 0.97 0.91 0.97 1.04 1.00 0.77 1.03
Bld⇒Test 1.02 0.91 1.34 0.94 0.96 0.96 1.01 1.02 0.97 1.05
χ2(p-value)Prod, Bld <0.01 <0.01 <0.01<0.01<0.01<0.01<0.01 <0.01 <0.01 <0.01
Test, Bld 0.06 <0.01 <0.01<0.01<0.01<0.01<0.01 0.93 <0.01 <0.01
!""#$
%&'#$
(&)*+,*
$"-+./'*#&$
01 02 03 04 05!"#$%
&#$'(
)#*'+,-%"./#-0
&#$'(
Figure 3: An example scenario.
Finally, the conviction metric Conv(X ⇒Y) measures the
departure of Conf(X ⇒Y) from independence [6]. Convic-
tion values less than one indicate that X is negatively cor-
related with Y, i.e., Conf(X ⇒¬Y)>Conf(X⇒Y) [12].
Conviction values greater than one indicate that X is posi-
tively correlated with Y, i.e., Conf(X ⇒Y)>Conf(X⇒¬
Y). Throughout this study, we use conviction to evaluate
whether the statistically signiﬁcant logical coupling relation-
ships between X and Y (indicated by χ2) are positively or
negatively correlated.
WeusetheexampleinFigure3toillustratetheconﬁdence
and conviction metrics. A series of ﬁve revisions appear on
the Time axis and a series of four ﬁles (two production and
two build ﬁles) appear on the Y-axis. Of the four production
ﬁle revisions, two have build ﬁle changes as well (R3 and
R4), thus the Conf(Prod ⇒Bld) is 0.5. The Conf(Bld ⇒
Prod) is 0.67, since two of the three build revisions have a
production ﬁle change. We cannot calculate the χ2value for
this example, since the test was intended for a larger sample
size. However, suppose that the p-value for the production-
build relationship is smaller than 0.05. This would indicate
that the low coupling and conviction of Prod ⇒Bld would
be statistically signiﬁcant, i.e., not just an artifact of noise.
The Conv(Prod ⇒Bld) of 0.8 (based on a more complex
calculation) indicates that Prod ⇒¬Bld is a stronger rule
than Prod ⇒Bld, i.e., production code changes are typically
not accompanied by build changes.
4.2 Revision-level Results
In this section, we measure the revision-level coupling be-
tween build and production or test ﬁles.
Low revision-level coupling from the production or
test code to the build system : Theχ2statisticinTable5
shows that the coupling values from production to build ﬁles
are statistically signiﬁcant. However, the conﬁdence valuesin Table 5 indicate that the coupling from production to
build ﬁles ranges between 2-10%, i.e., no project reaches
Kumfert et al.’s estimate of 12% [13]. The median value of
our study is 5.5%, less than half of the 12% estimate.
The reason for the low coupling is that a revision rarely
includes both production and build ﬁle changes, as indicated
by the low Support(Prod, Bld) values. The low Conv(Prod
⇒Bld) values indicate that Prod ⇒¬Bld is a stronger rule
than Prod ⇒Bld. Especially in PLplot, the Conv(Prod ⇒
Bld) and Conv(Test ⇒Bld) values indicate that production
and test revisions are more likely not to include build ﬁle
changesthanviceversa. Thisisbecauseofthetwomigration
eﬀorts that generated many build-only changes in PLplot.
There is low revision-level coupling from production
and test code to the build system.
Low revision-level coupling from the build system
to the production or test code : The statistically signiﬁ-
cant conﬁdence values in Table 5 indicate that the build sys-
tem is coupled more to the source code than vice versa. Yet,
the Conv(Bld ⇒Prod) values are all much less than 1 (0.43–
0.68), indicating that it is still not likely that build revisions
contain changes to the source code. This ﬁnding is counter-
intuitive, since we would expect that most build changes
would be accompanied by production code changes [16].
In PLplot, the conﬁdence values are low due to one slow
migration period, where a new build system was imple-
mented while the existing build system was slowly phased
out. Many of the build migration changes were committed
in revisions that were not related to any source code, which
aﬀects the conﬁdence values.
While the coupling from the build system to the pro-
duction and test code is higher than in the other di-
rection, it is still rather low.
4.3 Work Item Results
The conﬁdence values that we have observed at the re-
vision level suggest that there is less coupling between the
production or test ﬁles and the build system than we had
anticipated based on Kumfert et al.’s estimation [13]. How-
ever, our results agree with an earlier study of KDE that
found that build revisions are often dominated by the build
and do not co-change with other entities [28].
We conjecture that the low observed coupling is due to de-Table 6: Overview of work item data.
Eclipse Jazz Mozilla
Revisions 6,391 36,557 210,400
Revs with Work Items 4,092 22,485 79,242
% Revs with Work Items 64% 62% 38%
Work Items 2,452 11,611 55,199
Table 7: Work item interest metrics.
Eclipse Jazz Mozilla
SupportProd 0.87 0.85 0.83
Test 0.31 0.24 0.17
Bld 0.17 0.05 0.26
Prod, Bld 0.14 0.04 0.22
Test, Bld 0.06 0.02 0.08
ConfProd⇒Bld 0.16 0.04 0.27
Bld⇒Prod 0.82 0.72 0.86
Test⇒Bld 0.20 0.08 0.44
Bld⇒Test 0.36 0.36 0.29
ConvProd⇒Bld 0.99 0.99 1.01
Bld⇒Prod 0.74 0.52 1.15
Test⇒Bld 1.03 1.03 1.31
Bld⇒Test 1.07 1.19 1.16
χ2(p-value)Prod, Bld 0.02<0.01<0.01
Test, Bld 0.16<0.01<0.01
veloper commit behaviour. For example, while some devel-
opers commit related build and source code changes under
one revision, others may commit build changes in separate
revisions from source code changes, which introduces noise
in the revision-level data. To address this, we should group
all revisions that collectively resolve an ITS work item. By
investigating the relationship between source and build ﬁles
at the work item level, we aim to reduce the noise caused by
inconsistent developer commit behaviour.
Our work item analysis is limited to the three projects in
Table 6. The lack of availability of high quality work item
linkage in VCS data is a known problem [5, 25]. With this
in mind, a three project study is actually quite unique. Fur-
thermore, Table 6 shows that a large portion of the VCS re-
visionsofEclipse-core(64%), Jazz(62%), andMozilla(38%)
could be linked to ITS work item IDs.
Production code work items are more tightly cou-
pled to the build system in Mozilla than in the Eclipse-
based projects : The Conf(Prod ⇒Bld) and Conf(Test ⇒
Bld) values in Table 7 show that there is considerable cou-
pling from the production and test code to the build system
in Mozilla (27% and 44%). These numbers indicate that
production code and build system consistency requires con-
siderable developer participation, i.e., roughly one in every
four work items requires build maintenance.
However, in Eclipse-core, the coupling is reduced to 16%
and in Jazz the observed coupling is a mere 4%. Eclipse-
core and Jazz both leverage the automated Eclipse Plugin
Development Environment (PDE) build technology. Each
Eclipse subsystem contains a “build.properties” ﬁle, which
lists the high-level build system conﬁguration. The PDE
build parses these property ﬁles to either: (1) generate ANT
scripts to perform the build appropriately, or (2) use anTable 8: Build ownership interest metrics.
Jazz Git Linux
All 156 795 6,502
SupportProd 0.81 0.85 0.97
Test 0.36 0.22 0.02
Bld 0.73 0.22 0.26
Prod, Bld 0.63 0.19 0.24
Test, Bld 0.32 0.05 0.01
ConfProd⇒Bld0.79 0.22 0.25
Bld⇒Prod0.87 0.85 0.93
Test⇒Bld0.89 0.24 0.58
Bld⇒Test0.44 0.23 0.06
ConvProd⇒Bld1.26 1.00 0.99
Bld⇒Prod1.46 0.98 0.48
Test⇒Bld2.51 1.02 1.76
Bld⇒Test1.14 1.02 1.03
χ2(p-value)Prod, Bld 0.02 1.00 <0.01
Test, Bld 0.01 0.95 <0.01
appropriate Eclipse plugin to perform the compilation and
packaging. Since the developer must only maintain the high-
levelbuild.propertiesﬁle(viatheIDE),thedailybuildmain-
tenance overhead is reduced.
The Mozilla Conv(Test ⇒Bld) value indicates that the
logical coupling between test and build code of 44% is very
strong, while the Conv(Test ⇒Bld) values for Eclipse-core
and Jazz are weaker. Note that the test and build code
p-value for Eclipse-core is not statistically signiﬁcant ( α=
0.5).
We ﬁnd that there is a substantial coupling between pro-
duction and test code with the build system in the Mozilla
project. We observe a 19% increase in Conf(Prod ⇒Bld)
and a 28% increase in Conf(Test ⇒Bld) over the revision-
level analysis. We observe similar increases in Eclipse-core
of 13% and 17% respectively. There was little change in
the observed coupling for Jazz. We conjecture that the dif-
ferences between Mozilla and Eclipse-core/Jazz are due to
programmingandprojectmanagementdi ﬀerences, butmore
elaborate studies are needed to validate this conjecture.
The maintenance of the build system impacts both
production and test development in Mozilla. The
Eclipse and Jazz build code is automatically gener-
ated and edited via the IDE, resulting in reduced build
system maintenance and coupling to the source code.
5. BUILD OWNERSHIP (RQ2)
Our study of Build Coupling reveals that Mozilla devel-
opers will have to perform build changes for roughly one in
every four work items they are tasked with. However, we did
not consider build ownership, i.e., which developers actually
make those changes to the build system. Prior work reports
that projects like the Perl interpreter [30] and the Linux
kernel [2] dedicate a team of experts to build maintenance
tasks. In those cases, although build coupling seems high,
the work is delegated to build experts, such that developers
will rarely need to perform the build maintenance.
We study the relationship between production, test, and
builddevelopersbyevaluatingtheassociationsbetweenthemTable 9: Number and percentage of developers re-
sponsible for 80% of the ﬁle changes to production,
test, and build ﬁles.
Jazz Git Linux
Prod41 (26%) 57 (7%) 523 (8%)
Test58 (37%) 95 (12%) 484 (7%)
Build53 (34%) 44 (5%) 365 (5%)
with the Support, Conﬁdence, χ2, and Conviction“interest”
metrics introduced for RQ1.
5.1 Approach
We ﬁrst need to label authors as build, test, or source
code developers. An author may hold one or more labels.
We assume that developers who produce at least one source
code revision are source code developers, since source code
development is the main focus of a development team. How-
ever, we only label authors as build developers if their per-
sonal source-build coupling is greater than or equal to the
project’s source-build coupling. Similarly, we only label au-
thors as test developers if their personal source-test coupling
is greater than or equal to the project’s source-test coupling.
We choose such a deﬁnition to identify those developers re-
sponsible for a signiﬁcant portion of build system (and test)
development, excluding accidental contributors.
Our study is limited to projects that record correct au-
thor names. A common practice in open source develop-
ment is to restrict VCS write access to only the core devel-
opers [5]. Many authors send patches, i.e., ﬁles containing
their changes, to the core developers for review. After en-
gaging in a review process, the core developer will write the
changes to the VCS. Only the Git, Linux, and Jazz projects
retain the name of the original author of the patch (instead
of the core developer), so our analysis is limited to these
three projects.
5.2 Results
We use Table 8 to illustrate two build ownership styles
that projects adopt for maintaining the build system.
Concentrated and dispersed build ownership : We
observe two styles of build ownership: (1) a concentrated
style, where most of the build maintenance is performed by
a small team of build engineers, and (2) a dispersed style
where most developers contribute code to the build system.
Style (1) was observed in the Linux and Git projects, while
style (2) was observed in Jazz.
The Conf(Prod ⇒Bld) values of Git (22%) and Linux
(25%) in Table 8 show that the majority of source code
contributors in these two projects do not have to change
the build system frequently, although the χ2statistic indi-
cates that the Git coupling is not statistically signiﬁcant. In
Jazz, the build system rarely changes, but the few changes
that happen are made by most production and test develop-
ers. Jazz’s Support(Bld) value in Table 7 indeed shows that
only 5% of all work items require build changes, however,
the Conf(Prod ⇒Bld) values in Table 8 show that 79% of
production code developers make a considerable number of
changes to the build. In other words, although 79% of pro-
duction code developers need to change the build, they do
not need to do this often, i.e., the overhead of build mainte-
nance on developers is limited.
Table 9 shows that to make 80% of all build changes,a smaller proportion of developers are needed in Git (5%)
and Linux (5%) than in Jazz (34%). This indicates that
buildexpertiseisconcentratedintheGitandLinuxprojects,
whereas it is dispersed among developers in the Jazz project.
Comparing the numbers to those of the production and test
code, we see that the build consistently has the lowest pro-
portion of developers that contribute 80% of the changes in
the two open source projects (5%).
Since most of the build changes in Linux and Git are made
by a core team of build experts, contributors are saved the
hassle of build maintenance. In 2001, the Linux project in
particular invested time and e ﬀort into reducing the impact
that the build system had on contributors [2]. Our ﬁnd-
ings suggest that they were successful in concentrating build
maintenance onto a core team of build experts.
While we do not have the data to speculate about which
style performs best universally, one could conjecture that
build ownership style (1) is more suitable for open source
teams. Open source development depends on casual de-
veloper contributions. Casual developers will have a hard
enough time learning the intricacies of foreign source code
without having to struggle with the build system. Thus,
oﬄoading build maintenance onto a team of core engineers
seems advisable. However, with limited resources, a build
maintenance team can become a bottleneck for developers.
Thestudied projects adopt either a concentrated
(Linux and Git), or dispersed (Jazz) build ownership
style to cope with the build maintenance overhead.
Most test developers have to make build changes :
The Conf(Test ⇒Bld) values in Table 8 reveal that 89%
of Jazz test developers, 58% of Linux test developers, and
24% of Git test developers make a considerable number of
changes to the build code. This indicates that the build
system maintenance is impacting most of the test developers
in Jazz and Linux. The corresponding χ2and conviction
values for Jazz and Linux show that these percentages are
statistically signiﬁcant and the rule is positively correlated.
Project managers should keep this in mind when performing
test development planning and budget estimations.
6. THREATS TO V ALIDITY
Construct validity : Our mapping of revisions to work
items is based on project-speciﬁc heuristics. In addition,
developers may have omitted or mistyped the work item
IDs in revision comments [5, 25].
Internal Validity : We conjecture that by measuring the
interestingness of the associations between production, test,
and build ﬁles, we have measured the degree to which these
entities co-evolve. It is possible that the phenomena that
we observe are purely coincidental. However, the reported
χ2and conviction values at the work item level suggest that
these relationships are more than coincidental.
We assume that developers commit all related changes
under the same revision or work item. We observed cases
where developers mistakenly committed an incomplete revi-
sion and followed up later with a correction in a new revi-
sion. Such missteps introduce noise in our revision data. To
combat this, we analyze the data at the work item level.
External Validity : We have only studied a limited num-
ber of projects and as such, our results may not generalize to
all projects. However, we studied a wide variety of projectsofdiﬀerentsizesanddomain, prescribingtobothproprietary
and open source processes.
Unfortunately, no Microsoft .NET systems were available
forstudy. Many.NETapplicationsuseMSBuild[19], abuild
technologywheretargetsandtasksaredescribedusingXML
(similar to ANT [16]). Hence, we are inclined to believe that
MSBuild and ANT scripts would evolve similarly, but have
no data to support this. In future work, we plan to validate
this inclination empirically.
Reliability Validity : The replicability of our case stud-
ies is threatened by the subjectivity of our ﬁle classiﬁcation
approach. Some ﬁles that were not automatically classiﬁed
based on ﬁle extension had to be classiﬁed manually, and as
such were subject to the authors’ opinion. To classify ﬁles
that may have ﬁt in more than one category, the authors’
best judgement was used based on our prior experience with
build systems [2, 3, 16]. To facilitate future studies, we have
put the resulting classiﬁcations online [1].
7. RELATED WORK
In this section, we survey the related work in the ﬁelds of
build system maintenance and logical coupling.
Kumfert et al.argue that the need to keep the build sys-
tem in sync with the source code generates an implicit de-
velopment overhead [13]. In Kumfert et al.’s survey, devel-
opers claim that 0-35.71% of their development time is spent
maintaining the build system. Kumfert et al.validate one
survey entry reporting a 20% overhead of the build by clas-
sifying each ﬁle as build- or source-related, and counting the
number of revisions modifying each. We adopt a similar ﬁle
classiﬁcation and revision categorization approach, but use
association rules and study to ten projects of varying size,
implementation language, and domain. We also perform a
work item analysis and study build ownership styles.
Robleset al.argue that software artifacts other than
source code are often disregarded in software engineering
research [28]. In a case study of KDE, they found that
in revisions that contain build changes, build ﬁles are of-
ten the predominant ﬁle type, i.e., 50% or more of the ﬁles
in the revision are build ﬁles, and many build revisions do
not contain source code changes at all. Build ﬁles in KDE
are tightly coupled to each other and weakly coupled to the
source ﬁles. Similarly, in our study we found that there is
low revision-level coupling from production and test code to
the build system. However, when we lifted our analysis up
to the work item level, we observed considerable coupling
from production to build ﬁles and from test to build ﬁles.
In prior work, we studied the evolution of ANT build sys-
tems for four open source Java projects [16]. We found that
both the complexity of the ANT scripts and the dynamic be-
haviour of the build system evolve. Furthermore, the build
complexity co-evolves with the source code at the release
level, complementing Adams et al.’s ﬁndings in the Linux
kernel [2]. This paper measures the build maintenance over-
head on the actual software development process.
Gallet al.studylogicalcouplingbetweenmodulesinprod-
uct releases by measuring co-change between software mod-
ules [8]. We apply a similar technique, but rather than
studying the coupling between modules, we study the logi-
cal coupling between production, test, and build ﬁles at the
revision and work item level.
Zaidman et al.analyze the change history, growth history,
and test quality evolution views of two open source systemsto study the co-evolution of production and test code [31].
Our paper quantitatively studies the co-evolution of produc-
tion code with the build system as well as the coupling of
test code with the build system.
Lubsenet al.quantitatively study the co-evolution of pro-
duction and test ﬁles by mining association rules from VCS
revisions [15]. They group these rules into production and
test code co-change classes and study the distribution of the
rules. We adopt a similar approach, but rather than mining
for low-level association rules, we extract support for speciﬁc
association rules between production, test, and build ﬁles.
We also ﬁnd that work items (rather than revisions) are a
more suitable level of granularity for identifying co-changing
software entities.
8. CONCLUSIONS
This paper analyzes the coupling between the source code
and build system changes in ten software projects, to mea-
sure the overhead of build maintenance on developers.
Our build coupling analysis shows that 4–16% of source
code work items in the analyzed Java projects and 27% of
source code work items in the analyzed C project require
an accompanying build change. Furthermore, 8–20% of test
code work items in the analyzed Java projects and 44% of
test code work items in the analyzed C project require an
accompanying build change. Project managers should ex-
plicitly account for build maintenance of this magnitude in
their project plans and budgets. Furthermore, future co-
evolution studies should consider analysis at the work item
level, as we feel it more accurately represents the unit of
development work.
Our analysis also shows that the normalized churn rates
of the build system and source code are comparable. More-
over, build changes induce more relative churn on the build
system than source code changes induce on the source code,
which means that the build system may be susceptible to
defects [20, 21].
Weobservethattheanalyzedprojectshavetwobuildown-
ership styles for coping with churn in the build system: (1) a
small team of build experts handle most of the maintenance,
or (2) maintenance is dispersed amongst most developers.
In the three studied projects, the actual overhead of build
maintenance for individual developers is limited. In future
work, we plan to investigate the advantages and disadvan-
tages of these two (and other) build ownership styles.
The analysis presented in this paper is primarily quan-
titative. However, our analysis framework can be used by
future build system studies to: (1) compare the maintenance
overhead of build tools and guide build tool improvements,
and (2) identify which build ownership style performs best.
References
[1] Classiﬁed ﬁles. http://sailhome.cs.queensu.
ca/~shane/Shane_McIntosh/Publications_files/
classified_files.tar.bz2 .
[2] B. Adams, K. De Schutter, H. Tromp, and W. De
Meuter. The evolution of the linux build system. Elec-
tronic Communications of the ECEASST , 8, 2008.
[3] B. Adams, K. De Schutter, H. Tromp, and W. Meuter.
Design Recovery and Maintenance of Build Systems. InProc. of the 23rd Int’l Conf. on Software Maintenance
(ICSM), pages 114–123, 2007.
[4] R. Agrawal, T. Imielinski, and A. Swami. Mining Asso-
ciation Rules between Sets of Items in Large Databases.
ACM SIGMOD Records , 22(2):207–216, 1993.
[5] C. Bird, A. Bachmann, E. Aune, J. Du ﬀy, A. Bernstein,
V. Filkov, and P. Devanbu. Fair and Balanced? Bias in
Bug-Fix Datasets. In Proc. of the 7th European Soft-
ware Eng. Conf/Sym. on the Foundations of Software
Eng. (ESEC/FSE) , pages 121–130, 2009.
[6] S. Brin, R. Motwani, J. D. Ullman, and S. Tsur. Dy-
namic Itemset Counting and Implication Rules for Mar-
ket Basket Data. In Proc. of the 1997 ACM SIGMOD
Int’l Conf. on Management Of Data , pages 255–264.
ACM, 1997.
[7] E. Dolstra, E. Visser, and M. de Jonge. Imposing a
Memory Management Discipline on Software Deploy-
ment. In Proc. of the 26th Int’l Conf. on Software
Engineering (ICSE) , pages 583–592. IEEE Computer
Society, 2004.
[8] H.Gall, K.Hajek, andM.Jazayeri. DetectionofLogical
CouplingBasedonProduct Release History. In Proc. of
the 14th Int’l Conf. on Software Maintenance (ICSM) ,
pages 190–198. IEEE Computer Society, 1998.
[9] L. Grimmer. Building MySQL Server with CMake
on Linux/Unix. http://www.lenzg.net/archives/
291-Building-MySQL-Server-with-CMake-on-LinuxUnix.
html, 2010. Last viewed: 08-Feb-2011.
[10] P. Kampstra. Beanplot: A boxplot alternative for vi-
sual comparison of distributions. Journal of Statistical
Software, Code Snippets , 28(1):1–9, 2008.
[11] KDE developer: “mosfet”. Autoconf/Automake
errors in kdelibs. http://lists.kde.org/?l=
kde-core-devel&m=95953244511288&w=4 . Last
viewed: 08-Feb-2011.
[12] K. S. Krishna, P. R. Krishna, and S. K. De. Discover-
ing fuzzy association rules with interest and conviction
measures. In R. Khosla, R. J. Howlett, and L. C. Jain,
editors, Knowledge-Based Intelligent Information and
Engineering Systems , volume 3684 of Lecture Notes in
Computer Science , pages 101–107. 2005.
[13] G. Kumfert and T. Epperly. Software in the DOE:
The Hidden Overhead of “The Build”. Technical Re-
port UCRL-ID-147343, Lawrence Livermore National
Laboratory, CA, USA, February 2002.
[14] Linden Labs. CMake. http://wiki.secondlife.com/
wiki/CMake . Last viewed: 08-Feb-2011.
[15] Z. Lubsen, A. Zaidman, and M. Pinzger. Using Associ-
ation Rules to Study the Co-evolution of Production &
Test Code. In Proc. of the 6th Working Conf. on Min-
ing Software Repositories (MSR) , pages 151–154. IEEE
Computer Society, 2009.
[16] S. McIntosh, B. Adams, and A. E. Hassan. The Evolu-
tion of ANT Build Systems. In Proc. of the 7th working
conf. on Mining Software Repositories (MSR) , pages
42–51. IEEE Computer Society, 2010.[17] A. Miller. js/Makeﬁle.in gone but still in allmake-
ﬁles.sh. https://bugzilla.mozilla.org/show_bug.
cgi?id=351377 . Last viewed: 08-Feb-2011.
[18] P. Miller. Recursive Make Considered Harmful. In Aus-
tralian Unix User Group Newsletter , volume 19, pages
14–25, 1998.
[19] MSDN. The Microsoft Build Engine (MSBuild).
http://msdn.microsoft.com/en-us/library/
dd393574.aspx . Last viewed: 06-Feb-2011.
[20] N. Nagappan and T. Ball. Use of Relative Code Churn
Measures to Predict System Defect Density. In Proc.
of the 27th Int’l Conf. on Software Engineering (ICSE) ,
pages 284–292. ACM, 2005.
[21] N. Nagappan and T. Ball. Using Software Dependen-
cies and Churn Metrics to Predict Field Failures: An
Empirical Case Study. In Proc. of the 1st Int’l Symp.
on Empirical Software Engineering and Measurement
(ESEM),pages364–373.IEEEComputerSociety, 2007.
[22] A. Neundorf. Why the KDE project switched to CMake
– and how (continued). http://lwn.net/Articles/
188693/. Last viewed: 08-Feb-2011.
[23] T. Neustupny. Build failed in Hudson, what to do?
http://argouml.tigris.org/ds/viewMessage.do?
dsForumId=450&dsMessageId=2618367 . Last viewed:
08-Feb-2011.
[24] G. V. Neville-Neal. Kode Vicious: System Changes and
SideEﬀects.Communications of the ACM ,52(4):25–26,
April 2009.
[25] T. H. D. Nguyen, B. Adams, and A. E. Hassan. A case
study of bias in bug-ﬁx datasets. In Proc. of the 17th
Working Conf. on Reverse Engineering (WCRE) ,pages
259–268, 2010.
[26] G. Niemeyer and J. Poteet. Extreme Programming with
Ant: Building and Deploying Java Applications with
JSP, EJB, XSLT, XDoclet, and JUnit . Sams, 1st edi-
tion, 2003.
[27] J. A. Rice. Mathematical Statistics and Data Analysis .
Duxbury press, 1995.
[28] G. Robles, J. M. Gonzalez-Barahona, and J. J. Merelo.
Beyond Source Code: The Importance of Other Arti-
facts in Software Development (A Case Study). Journal
of Systems and Software (JSS) , 79(9):1233–1248, 2006.
[29] T. Steiner. mozStorage chokes on databases over
AFP. https://bugzilla.mozilla.org/show_bug.
cgi?id=417037 . Last viewed: 08-Feb-2011.
[30] Q. Tu and M. Godfrey. The build-time software archi-
tecture view. In Proc. of IEEE Int’l Conf. on Software
Maintenance (ICSM) , pages 398–407. IEEE Computer
Society, 2002.
[31] A. Zaidman, B. V. Rompaey, S. Demeyer, and A. van
Deursen. Mining Software Repositories to Study Co-
Evolution of Production & Test Code. In Proc. of the
1st Int’l Conf. on Software Testing, Veriﬁcation, and
Validation (ICST) , pages 220–229. IEEE Computer So-
ciety, 2008.
View publication statsView publication stats