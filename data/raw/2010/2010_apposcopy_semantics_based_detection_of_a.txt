Apposcopy: Semantics-Based Detection of Android
Malware through Static Analysis∗
Yu Feng
University of Texas at Austin, USA
yufeng@cs.utexas.eduSaswat Anand
Stanford University, USA
saswat@cs.stanford.eduIsil Dillig
University of Texas at Austin, USA
isil@cs.utexas.edu
Alex Aiken
Stanford University, USA
aiken@cs.stanford.edu
ABSTRACT
We present Apposcopy, a new semantics-based approach for
identifying a prevalent class of Android malware that steals
privateuserinformation. Apposcopyincorporates(i)ahigh-
level language for specifying signatures that describe seman-
tic characteristics of malware families and (ii) a static anal-
ysis for deciding if a given application matches a malware
signature. The signature matching algorithm of Apposcopy
uses a combination of static taint analysis and a new form of
program representation called Inter-Component Call Graph
to eﬃciently detect Android applications that have certain
control- and data-ﬂow properties. We have evaluated Ap-
poscopy on a corpus of real-world Android applications and
show that it can eﬀectively and reliably pinpoint malicious
applications that belong to certain malware families.
Categories and Subject Descriptors
D.4.6 [Software Engineering ]: Security and Protection
General Terms
Security, Veriﬁcation
Keywords
Android, Inter-component Call Graph, Taint Analysis
1. INTRODUCTION
As the most popular mobile operating system, the An-
droid platform is a growing target for mobile malware [4].
Today, many of the malicious applications that aﬄict An-
droid users exploit the private and monetized information
∗This work was sponsored by the Air Force Research Labo-
ratory, under agreement number FA8750-12-2-0020
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
FSE ’14, November 16–22, 2014, Hong Kong, China
Copyright 2014 ACM 978-1-4503-3056-5/14/11 ...$15.00.stored in a user’s smartphone. According to a recent re-
port [3], nearly half of Android malware are multi-functional
Trojans that steal personal data stored on the user’s phone.
In response to the rapid dissemination of Android mal-
ware, there is a real need for tools that can automatically
detectmaliciousapplicationsthatstealprivateuserinforma -
tion. Two prevalent approaches for detecting such Android
malware are taint analyzers andsignature-based detectors :
Taint analyses , such as [17, 21], are capable of exposing
applications that leak private user information. Unfortu-
nately, since many benign apps also need access to sensitive
data to perform their advertised functionality, not every app
that leaks user information can be classiﬁed as malware. For
instance, an email client application will necessarily “lea k”
email addresses of the user’s contacts in order to perform its
functionality. Thus, taintanalysescannotautomaticallyd is-
tinguish benign apps from malware, and a security auditor
must invest signiﬁcant eﬀort in order to determine whether
a given information ﬂow constitutes malicious behavior.
Signature-based malware detectors , includingcommer-
cial virus scanners, classify a program as malware if it con-
tains a sequence of instructions that is matched by a regu-
lar expression. As shown in a recent study, malware detec-
tors that are based on syntactic low-level signatures can be
easily circumvented using simple program obfuscations [34].
Hence, thesemalwaresignaturesmustbefrequentlyupdated
as new variants of the same malware family emerge.
In this paper, we present Apposcopy, a new semantics-
based approach for detecting Android malware that steal
private user information. Drawing insights from the re-
spective advantages of pattern-based malware detectors and
taintanalyzers, Apposcopyincorporates(i)ahigh-levelspec -
iﬁcation language for describing semantic characteristics of
Android malware families, and (ii) a powerful static analysis
for deciding if a given application matches the signature of a
malware family. The semantic, high-level nature of the sig-
nature speciﬁcation language allows analysts to specify key
characteristics of malware families without relying on the
occurrence of speciﬁc instruction or byte sequences, making
Apposcopy more resistant to low-level code transformations.
The signature-based speciﬁcation language provided by
Apposcopy allows specifying two types of semantic proper-
ties —control-ﬂow and data-ﬂow—of Android applications.
An example of a control-ﬂow property is that the malware
contains a broadcast receiver which launches a service upon
the completion of some system event. An example of a data
ﬂow property is that the malware reads some private dataof the device and sends it through a designated sink(e.g.,
Internet, SMS message, etc.).
To match the signatures speciﬁed in this language, Ap-
poscopy’s static analysis relies on two key ingredients. First ,
we construct a new high-level representation of Android
applications called the inter-component callgraph (ICCG) ,
which is used to decide whether an Android application
matches the control ﬂow properties speciﬁed in the signa-
ture. Second, Apposcopy incorporates a static taint anal-
ysis which is used for deciding whether a given application
matches a speciﬁed data-ﬂow property.
We have evaluated Apposcopy on a corpus of real-world
Android applications and show that it can eﬀectively and re-
liably pinpoint malicious applications –including obfusca ted
ones– that belong to certain malware families. Despite the
theoretical undecidability of the semantic signature match-
ing problem, Apposcopy yields both few false positives and
few false negatives on current Android applications.
2. MOTIV ATING EXAMPLE
In this section, we illustrate our approach using a sim-
pliﬁed version of the GoldDream malware family. As de-
scribed in Jiang’s security report [27], the key characteristic
of members of this family is that they register a receiver
for certain system events such as SMS messages or outgoing
phone calls. When these events trigger the execution of code
in the receiver, the malware then starts a background ser-
viceforsendingprivateuserinformation, suchasthephone’s
unique IMEI number and subscriber id, to a remote server.
2.1 GoldDream Signature in Apposcopy
To detect a sample of GoldDream malware, an analyst
ﬁrstwritesasignatureofthismalwarefamilyinourDatalog-
based language. In this case, the behavior of GoldDream is
captured by the speciﬁcation in Figure 2. Here, lines 1-2
introduce a new user-deﬁned predicate GDEvent(x) which
describes the events that the GoldDream malware listens for.
In this case, GDEvent(x) evaluates to true when xis either
SMS_RECEIVED orNEW_OUTGOING_CALL but to false otherwise.
Using this predicate, lines 3-7 describe the signature of
the GoldDream malware family. In this case, the signature
uses three kinds of predicates provided by Apposcopy:
Component type predicates , suchasreceiver(r) and
service(s) , specify that randsareBroadcastReceiver
andService components in the Android framework.
Control-ﬂow predicates: An example of a control ﬂow
predicate is icc, which describes inter-component communi-
cation in Android. In our example, icc(SYSTEM, r, e, _)
expresses that the Android system invokes component r
when system event ehappens, and icc*(r, s) means that
component rtransitively invokes component s.
Data-ﬂow predicates , suchasflow(x, so, y, si) , ex-
press that the application contains a ﬂow from source soin
component xto a sink siin component y. Hence, lines 6-7
state that component ssends the device and subscriber id
of the phone over the Internet.
Therefore, according to the signature(simpliﬁed version)
inFigure2, anapplication AbelongstotheGoldDreammal-
ware family if (i) Acontains a broadcast receiver that lis-
tens for system events SMS_RECEIVED orNEW_OUTGOING_CALL
(lines 3, 4), and (ii) this broadcast receiver starts a service
which then leaks the device id and subscriber id over the
Internet (lines 5-7).1. GDEvent(SMS_RECEIVED).
2. GDEvent(NEW_OUTGOING_CALL).
3. GoldDream :- receiver(r),
4. icc(SYSTEM, r, e, _), GDEvent(e),
5. service(s), icc*(r, s),
6. flow(s, DeviceId, s, Internet),
7. flow(s, SubscriberId, s, Internet).
Figure 2: GoldDream signature (simpliﬁed)
2.2 GoldDream Malware Detection
Given an Android application Aand malware signature
S, Apposcopy performs static analysis to decide if app A
matches signature S. Apposcopy’s static analysis has two
important ingredients: (i) construction of the ICCG , which
determines the truth values of control-ﬂow predicates used
in the signature, and (ii) static taint analysis , which is used
to decide the truth values of data-ﬂow predicates.
Figure 1 shows a partial ICCG for an instance of the Gold-
Dream malware family. Nodes in the ICCG correspond to
components, and node labels denote component names. The
shapes of the nodes indicate component types: Rectangles
denote broadcast receivers, ellipses indicate activities, an d
polygons are services. An ICCG edge from one node Ato
another node Bmeans that component Astarts component
B, for example, by calling the startActivity method of the
Android SDK. The edges in the ICCG may also be labeled
with additional information, such as system events.
GoingbacktothespeciﬁcationfromSection2.1, theICCG
shown in Figure 1 matches the sub-query
receiver (r),icc(SYSTEM,r,e,),GDEvent(e),
service(s),icc∗(r,s)
because (i) there exists a node in the ICCG representing
a receiver component (namely, zjReceiver ), (ii) there is
an edge from the node representing the Android system
tozjReceiver labeled with SMS_RECEIVED , (iii)zjReceiver
hasanoutgoingedgetoaservicecomponentcalled zjService .
Next, to decide data-ﬂow queries, Apposcopy performs
taint analysis tracking ﬂows from sourcestosinks. Here,
sources represent sensitive data, such as the phone’s device
id, and sinks represent operations that may leak data, such
as sending text messages. For our example application, the
taint analysis yields the following result:
com.sjgo.client.zjService:
$getSimSerialNumber -> !INTERNET
$getDeviceId -> !INTERNET
$getSubscriberId -> !INTERNET
$getDeviceId -> !sendTextMessage
$getSubscriberId -> !sendTextMessage
cxboy.android.game.fiveInk.FiveLink:
$ID -> !INTERNET
$MODEL -> !INTERNET
net.youmi.android.AdActivity:
$getDeviceId -> !WebView
$ExternalStorage -> !WebView
Here, Apposcopy has identiﬁed source-sink ﬂows in three
components, zjService ,FiveLink , andAdActivity . For
example, the ﬁrst three lines under zjService indicate that
it sends the phone’s serial number, device id, and subscriber
id over the Internet. Recall that the GoldDream malware
signature includes the data-ﬂow query:
flow(s, DeviceId, s, Internet),
flow(s, SubscriberId, s, Internet)
wheresis a service. Since the taint analysis reveals that
zjService leaks the device and subscriber id to the Internet,
this query evaluates to true, and Apposcopy concludes this
application is GoldDream malware. Observe that, althoughFigure 1: Partial ICCG for an instance of the GoldDream malwa re family
Table 1: A partial list of ICC-related APIs.
ActivitystartActivity(Intent)
startActivityForResult(Intent,int)
startActivityIfNeeded(Intent,int)
startNextMatchingActivity(Intent)
ServicestartService(Intent)
bindService(Intent)
BroadcastReceiversendBroadcast(Intent)
sendBroadcast(Intent,String)
sendOrderedBroadcast(Intent,String)
there are other source-sink ﬂows in this example (such as
fromDeviceId toWebView inAdActivity ), these other ﬂows
do not necessarily correspond to malicious behavior.
3. MALWARE SPEC LANGUAGE
ThissectiondescribesApposcopy’smalwaresignaturelan-
guage, which is a Datalog program augmented with built-
in predicates. For each malware family, the user deﬁnes a
unique predicate that serves as the signature for this mal-
ware family. The user may also deﬁne additional helper
predicates used in the signature. In what follows, we ﬁrst
give some background on Datalog, and then describe the the
syntax and semantics of Apposcopy’s built-in predicates.
3.1 Datalog Preliminaries
A Datalog program consists of a set of rulesand a set of
facts. Facts simply declare predicates that evaluate to true.
For example, parent("Bill", "Mary") states that Bill is a
parentofMary. EachDatalogruleisaHornclausedeﬁninga
predicate as a conjunction of other predicates. For example,
the rule:
ancestor(x, y) :- parent(x, z), ancestor(z, y).
says that ancestor(x, y) is true if both parent(x, z) and
ancestor(z, y) are true. In addition to variables, predi-
cates can also contain constants, which are surrounded by
double quotes, or“don’t cares”, denoted by underscores.
Datalog predicates naturally represent relations. Speciﬁ-
cally, if tuple ( x,y,z) is in relation A, this means the predi-
cateA(x,y,z) is true. In what follows, we write the type of
a relation R⊆X×Y×...as (s1:X,s2:Y,...), where s1,
s2,...are descriptive texts for the corresponding domains.
3.2 Apposcopy’s Built-in Predicates
We now describe the syntax and semantics of the four
classes of built-in predicates provided by Apposcopy.
3.2.1 Component Type Predicates
Component type predicates in Apposcopy represent the
diﬀerentkindsofcomponentsprovidedbytheAndroidframe-Table 2: A partial list of life-cycle APIs.
ActivityonCreate(Bundle) ,onRestart() ,
onStart() ,onResume() ,
onPause() ,onStop() ,onDestroy()
ServiceonCreate() ,onBind(Intent) ,
onStartCommand(Intent, int, int) ,
onDestroy()
BroadcastReceiver onReceive(Context, Intent)
work. An Android application consists of four kinds of com-
ponents, Activity,Service,BroadcastReceiver , andContent-
Provider . Activity components form the basis of the user
interface, and each window of the application is typically
controlled by an activity. Service components run in the
background and remain active even if windows are switched.
BroadcastReceivercomponentsreactasynchronouslytomes-
sagesfromotherapplications. Finally, ContentProvidercom-
ponents store data relevant to the application, usually in a
database, and allow sharing data across applications.
Corresponding to each of these Android components, Ap-
poscopy provides pre-deﬁned predicates called service(C) ,
activity(C) ,receiver(C) ,andcontentprovider(C) which
representthetypeofcomponent C.Forexample, activity(C)
is true ifCis anActivity . Each of these four predicates cor-
respond to relations of type ( comp:C) where domain Cis
the set of all components in the application.
3.2.2 Predicate icc
A key idea behind inter-component communication (ICC)
in Android is that of Intents, which are messages passed
between components. Intents are used to start Activities;
start, stop, and bind Services; and broadcast information to
Broadcast Receivers. Table 1 shows a list of Android APIs
that are used in ICC. We refer to those methods, all of which
take Intent objects as arguments, as ICC method s. We use
the term ICC site to represent a statement that invokes one
of the ICC methods listed in Table 1. When component a
initiates ICC with component b, the Android system will
eventually call life-cycle methods associated with compo-
nentb. The life-cycle methods are shown in Table 2.
WhileanIntentobjectpassedtoICCmethodscancontain
many diﬀerent types of information, Apposcopy’s signature
language takes into account only two kinds: action and data.
Actionis a string that represents the type of action that the
receivingcomponentneedstoperform, and dataspeciﬁesthe
type of data that the component needs to operate on. For
example, a component for editing images will receive intents
with corresponding action EDITand data type image/*.
Apposcopy’s iccpredicaterepresentsinter-componentcom-
munication in Android and corresponds to a relation of type
(source:C,target :C,action :A,data:D) where domain1. public class MainAct extends Activity {
2. protected void onCreate(Bundle b) {
3. foo();
4. bar();
5. }
6. void foo() {
7. Intent i = new Intent();
8. i.setAction(android.intent.action.SEND);
9. i.setType("text/plain");
10. startActivity(i);
11. }
12. void bar() {
13. Intent n = new Intent();
14. n.setClass(MsgAct.class);
15. startActivity(n);
16. }
17. }
18. public class MsgAct extends Activity { ... }
Figure 3: ICC example.
<activity android:name="MsgAct">
<intent-filter
<action name="android.intent.action.SEND" />
<data mimeType="text/plain" />
</intent-filter>
</activity>
Figure 4: A snippet of AndroidManifest.xml
Cis the set of all components in the application, and A
andDare the sets of all Action and Data values deﬁned by
the Android system. Since not all intents are required to
have action and data values, domains AandDalso include
a special element ⊥, which indicates no value. Intuitively,
if predicate icc(p,q,a,d) is true, this means that compo-
nentppasses an intent to qthrough invocation of an ICC
method, and aanddrepresent the action and data strings
of the intent. To formally state the semantics of the icc
predicate, we ﬁrst deﬁne targets of ICC sites:
Definition 3.1.Thetarget of an ICC site ,m(i,...), is
the set of components that will receive the intent stored in
variableiin some execution of the application.
Definition 3.2.We write m1❀m2iﬀ method m1di-
rectly calls m2in some execution of the program. We deﬁne
❀⋆to be the reﬂexive transitive closure of ❀.
In other words, m1❀⋆ m2ifm1transitively calls m2. We
now deﬁne the semantics of the iccpredicate as follows:
Definition 3.3.The predicate icc(p,q,a,d) is true iﬀ
(i)m1is a life-cycle method deﬁned in component p, (ii)
m1❀⋆ m2, (iii)m2contains an ICC site whose target is
component q, and (iv) the action and data values of the in-
tent areaandd, respectively.
Example 1.Consider the code in Figure 3, which deﬁnes
two activities, MainActandMsgAct. TheonCreate life-cycle
method of MainActcallsfoowhich initiates ICC at line 10
by calling startActivity with intent i. The action associ-
ated with intent iisSENDand the data type is text/plain .
According to the manifest in Figure 4, MsgActdeclares an
intent ﬁlter forSENDactions on data type text/plain , mean-
ing that msgActis a target of the ICC site at line 10. Hence,
predicate icc(MainAct, MsgAct, SEND, text/plain) is true.
We now deﬁne the predicate icc*(p, q) , which is true if
component pcan transitively launch component q:
Definition 3.4.Leticc_direct(p,q) be a binary predi-
cate which is true iﬀ icc(p, q, _, _) is true. The predicate
icc*is the reﬂexive transitive closure of icc_direct .Table 3: A non-exhaustive list of Android methods
that are candidates of abuse
Operation & Description
<BroadcastReceiver: void abortBroadcast()>
Block current broadcaster.
<Runtime: Process exec(java.lang.String)>
Execute a command.
<System: void loadLibrary(java.lang.String)>
Perform native call.
<PackageManager: List getInstalledPackages()>
Get all application packages.
<DexClassLoader: void <init>(...,ClassLoader)>
Load classes from .jar and .apk ﬁles.
Our malware signature language includes the predicate
icc*because it allows writing signatures that are resilient to
high-level control ﬂow obfuscation. In particular, if the sig-
nature contains the predicate icc*(p, q) , adding or delet-
ingdummycomponentsforthepurposesofdetectionevasion
will not aﬀect the truth value of this predicate.
3.2.3 Predicate calls
Apposcopy provides another control-ﬂow predicate, called
calls, representing a relation of type ( comp:C,callee :
M) where domains CandMrepresent the set of all com-
ponents and methods in the program respectively. Intu-
itively,calls(c,m) is true if method mis called by compo-
nentc. Moreprecisely, calls(c, m) istrueiﬀ nisalife-cycle
method deﬁned in component candn❀⋆m.
Thecallspredicate is useful for deﬁning malware signa-
tures because it can be used to check if a component calls
Android API methods that can be abused by malware. Ta-
ble 3.2.4 lists a few of such dangerous methods.
3.2.4 Predicate flows
Apposcopy provides a data-ﬂow predicate flowsused for
querying whether an app leaks sensitive data. More speciﬁ-
cally, taint ﬂow is deﬁned in terms of sources and sinks.
Definition 3.5.Asource (resp. sink) is a labeled (i.e.,
annotated) program variable that is either a method param-
eter or method return value. The corresponding method is
referred to as the source method (resp. sink method) .
An example of a source is the return value of method
getDeviceId , which yields the phone’s unique device id. An
exampleofasinkisthethirdparameterof sendTextMessage ,
which corresponds to the text to be sent through SMS.
Source and sink annotations are discussed in Section 4.3.1,
and Table 3.2.4 shows a partial list of source and sink meth-
ods.
Theflowpredicaterepresentsarelationoftype( srcComp :
C,src: SRC,sinkComp :C,sink: SINK) where domain C
is the set of components, and SRC and SINK are the sets of
allsourcesandsinksintheprogram. Todeﬁnethesemantics
of theflowpredicate, we ﬁrst deﬁne taint ﬂow :
Definition 3.6.Ataint ﬂow ( so,si)represents that a
source labeled socan ﬂow to a sink labeled sithrough a series
of assignments or matching loads and stores.
Definition 3.7.The predicate flow(p,so,q,si) is true
iﬀ (i)mandnare the source and sink methods corresponding
to source soand sink si, (ii)calls(p, m) andcalls(q,n)
are both true, and (iii) there exists a taint ﬂow (so,si).
Example 2.Consider the code in Figure 5, where the
return value of getDeviceId is a source labeled $getDeviceId ,Table 4: Examples of APIs with source and sink annotations
Sources Sinks
<TelephonyManager: String getDeviceId()> <SmsManager: void sendTextMessage(...)>
<TelephonyManager: String getSimSerialNumber()> <SmsManager: void sendMultiparTextMessage(...)>
<TelephoneyManager: String getSubscriberId()> <SmsManager: void sendDataMessage(...)>
<TelephoneyManager: String getVoiceMailNumber()> <DataOutputStream: write(...)>
<TelephoneyManager: String getSimOperator()> <DatagramSocket: void send(...)>
<Location: double getLatitude()> <AbstractHttpClient: HttpResponse execute(...)>
<Location: double getLongitude()> <Ndef: void writeNdefMessage(...)>
public class ListDevice extends Activity {
protected void onCreate(Bundle bd) {
1. Device n,m;
2. ...
3. String x = "deviceId=";
4. String y = TelephonyManager.getDeviceId();
5. String z = x.concat(y);
6. m.f = z;
7. n = m;
8. String v = n.f;
9. smsManager.sendTextMessage("3452",null,v,null,nul l);
}
}Figure 5: Example illustrating data ﬂow
and the third parameter of sendTextMessage is a sink labeled
!sendTextMessage . This application exhibits a taint ﬂow from
$getDeviceId to!sendTextMessage because variable yholding
the return value of getDeviceId can ﬂow to variable vdue
to the chain of assignments, loads, and stores performed in
lines 5-8. Hence, the following predicate evaluates to true :
flow(ListDevice,$getDeviceId,ListDevice,!sendTextMe ssage)
4. STATIC ANALYSES
This section describes Apposcopy’s static analyses for de-
ciding whether an application matches a malware signature.
The main idea is to compute an over-approximation of the
icc,calls, andflowrelations.
4.1 Pointer Analysis & Callgraph Contruction
In order to build the inter-component callgraph and track
information ﬂow, Apposcopy starts by performing a pointer
analysis, which computes the set of abstract heap objects
that each variable may point to. In the remainder of the
paper, we use the notation v ֒→oto denote that variable
vmay point to an abstract heap object represented by oin
some execution of the program.
Since the precision of the underlying pointer analysis is
critical for detecting malware with few false alarms, we use
a ﬁeld- and context-sensitive Andersen-style pointer analy -
sis[7]. Forcontext-sensitivity, weuseahybridapproachthat
combines call-site sensitivity [30] and object-sensitivit y [31].
In particular, our approach is similar to the technique de-
scribed in [28] and uses call-site sensitivity for static meth od
calls and object-sensitivity for virtual method calls.
Another key ingredient of our malware detection algo-
rithm is callgraph construction, which is used for resolving
the targets of virtual method calls. Since callgraph precision
has signiﬁcant impact on the precision of the ICCG, Ap-
poscopy computes the callgraph on-the-ﬂy, simultaneously
reﬁning the targets of virtual method calls and points-to sets
until a ﬁxed point is reached. The set of edges in the result-
ing callgraph represent the relation ❀from Deﬁnition 3.2.
An edge in the callgraph from method m1to method m2
corresponds to m1❀m2. Similarly, m1❀⋆ m2represents
that there exists a path in the callgraph from m1tom2.Table 5: API for setting Intent attributes
TargetsetComponent(ComponentName) ,
setClassName(Context, String) ,
setClassName(String, String) ,
setClass(Context, Class)
Action setAction(String)
Data typesetType(String) ,setData(URI) ,
setDataAndType(URI,String)
4.2 Inter-component Control-ﬂow Analysis
We now describe the construction of the inter-component
call graph (ICCG), which is used for deciding ICC queries.
Definition 4.1.An ICCG for a program Pis a graph
(N,E)such that nodes Nare the set of components in P,
and edges Edeﬁne a relation E⊆(N×A×D×N)whereA
andDare the domain of all actions and data types deﬁned
by the Android system augmented with the element ⊥.
In other words, ICCG is a directed graph where nodes are
components in an application, and edges are labeled with
actions and data types. The special element ⊥indicates
that the intent deﬁning the ICC does not have action or
data type information associated with it. Given a callgraph
andtheresultsofthepointeranalysis, Apposcopyconstructs
the ICCG by performing two key steps that we explain next.
4.2.1 Data Flow Analysis for Intents
The ﬁrst step of ICCG construction is a data ﬂow analysis
to track the information stored in Intent objects. Speciﬁ-
cally, we track three kinds of information about intents:
•Target: In the Android framework, a component can
specify the target of an Intent (and, hence, the ICC)
by calling the methods shown in the ﬁrst row of Ta-
ble 5. Such intents whose targets have been explicitly
speciﬁed are called explicit intents .
•Action: A component can specify the action that the
ICC target needs to perform by calling the methods
shown in the second row of Table 5.
•Data type: An application can specify the data type
that the recipient component needs to operate on by
calling the methods shown in the last row of Table 5.
Whenacomponentdoesnotspecifythetargetofanintent
explicitly, the Android system resolves the recipient com-
ponents of the ICC based on intent ﬁlters declared in the
manifest ﬁle. An intent ﬁlter speciﬁes the kinds of actions
that a component will respond to. For instance, consider the
AndroidManifest.xml ﬁle from Figure 4. Here, MsgActde-
clares that it responds to intents whose corresponding action
and data type are SENDandtext/plain respectively.
In order to build the ICCG, Apposcopy ﬁrst performs a
forward interprocedural dataﬂow analysis, called the intent
analysis, which overapproximates the target, action, andmustalias(y,x)
Γ⊢newval(y,x,s) : [yt/mapsto→ {s}]
mayalias(y,x),¬mustalias(y,x)
Γ⊢newval(y,x,s) : [yt/mapsto→(Γ(y)∪{s})]
¬mayalias(y,x)
Γ⊢newval(y,x,s) : [yt/mapsto→Γ(y)]
Γ⊢newval(xi,x,s) : Γi(xi∈dom(Γ))
Γ⊢x.setComponent (s) :/uniontext
iΓi
Figure 6: Transfer function for setComponent
data type associated with each intent object. Speciﬁcally,
for each variable iof typeIntent, our analysis tracks three
variables it,ia, andidwhose domains are sets of compo-
nents, actions, and data types respectively. We initialize
the dataﬂow value for each variable to be {⊥}and deﬁne
the join operator as set union.
Table 5 shows the set of Android API methods for setting
attributes of Intent objects. Since other methods do not
change attributes of intents, the transfer function for any
statement not included in Table 5 is the identity function.
Figure 6 shows the transfer function for setComponent in
the form of inference rules. Since transformers for the other
statements from Table 5 are very similar, we only focus on
setComponent as a representative. In Figure 6, environment
Γ denotes data ﬂow facts for targets of intent variables as a
mapping from each variable to its corresponding dataﬂow
value. Now, consider the statement x.setComponent(s)
wherexis a variable of type Intent and sis a string speci-
fying the target component. If another variable yis an alias
ofx, then the target of ywill also be aﬀected by this state-
ment. Hence, our transfer function must update the data
ﬂow values of all variables that are aliases of x. Now, there
are three cases to consider. If xandyare guaranteed to
be aliases, as in the ﬁrst rule of Figure 6, then we can kill
its old value and update its new value to {s}(i.e., a strong
update). In the second rule, if ymayaliasx, theny’s tar-
get could either remain unchanged or become s; hence, we
only perform a weak update. Finally, if yandxdo not
alias, then y’s target deﬁnitely remains unchanged and its
existing dataﬂow values are preserved. The mayaliasand
mustaliasrelations used in Figure 6 are deﬁned according
to Figure 7. In the deﬁnition of the mustaliasrelation, γ(o)
represents the set of concrete memory locations represented
by abstract memory location o.
Based on the results of this data ﬂow analysis, we can now
determine whether an intent is explicit or implicit. Specif-
ically, if Γ( xt) does not contain ⊥, the target of the in-
tent must have been explicitly speciﬁed. Hence, we write
explicit(x) if⊥ /ne}ationslash∈Γ(xt). Otherwise, xmaybe an implicit
intent, denoted implicit(x).
Example 3.Consider again the code from Figure 3. Here,
for Intent ideclared at line 7, we have Γ(it) ={⊥},Γ(ia) =
{action.SEND},Γ(id) ={text/plain}For the intent nat
line 13, our analysis computes Γ(nt) ={MsgAct},Γ(na) =
{⊥},Γ(nd) ={⊥}. Since⊥ /ne}ationslash∈Γ(nt), we conclude explicit(n).
On the other hand, iis identiﬁed to be implicit.
4.2.2 ICCG Construction
We now describe ICCG construction using the results of
the intent analysis. In what follows, we write iccsite(m,i)
to denote that method mcontains an ICC site with intent
i, and we write P❀⋆ mto indicate that component Phasx ֒→o, y ֒→o
mayalias(x,y)x ֒→o,¬∃o′.x ֒→o′
y ֒→o,¬∃o′.y ֒→o′
|γ(o)|= 1
mustalias(x,y)mustalias(x,x)
Figure 7: May and must aliasing relations
iccsite(m,i),explicit(i), P❀⋆ m
Q∈Γ(it),A∈Γ(ia),D∈Γ(id)
(P,Q,A,D )∈E(Explicit)
iccsite(m,i),implicit(i), P❀⋆ m
A∈Γ(ia),D∈Γ(id)
intentﬁlter(Q,A,D)
(P,Q,A,D )∈E(Implicit)
Figure 8: ICCG construction rules
a life-cycle method m′andm′❀⋆ mFinally, the predicate
intentﬁlter(P,A,D) means that component Pdeclares an
intent ﬁlter with action Aand data type D. This informa-
tion is extracted from the application’s manifest ﬁle.
Figure8showstheICCGconstructionrules. Theﬁrstrule
(Explicit) considers ICC sites in method mwhere intent i
has its target component explicitly speciﬁed (i.e., Q∈Γ(it)
andQ/ne}ationslash=⊥). In this case, if method mis reachable from
component P, we add an edge from component PtoQin
the ICCG. Furthermore, if A∈Γ(ia) andD∈Γ(id), the
edge from PtoQhas action label Aand data type label D.
The second rule in Figure 8 applies to ICC sites where
intentimay be implicit. If A∈Γ(ia) andD∈Γ(id),
we need to determine all components Qthat declare intent
ﬁlters with action Aand data type D. Hence, we add an
edge from component PtoQifintentﬁlter(Q,A,D) is true.
Example 4.Consider again the code from Figure 3 and
the data-ﬂow facts Γcomputed in Example 3. Using the Im-
plicit rule for the ICC site in method foowith intent i, we
infer the edge (MainAct,MsgAct,action.SEND,text/plain).
Using the Explicit rule for ICC site in method barwith in-
tentn, we add the edge (MainAct,MsgAct,⊥,⊥).
4.3 Taint Analysis
We now describe Apposcopy’s taint analysis for answering
data-ﬂow queries. We ﬁrst discuss how we annotate sources
and sinks and then describe our taint propagation rules.
4.3.1 Annotations
Apposcopyprovidesthreetypesofannotationscalled source,
sink, andtransfer annotations. Source annotations are used
to mark Android framework methods that read sensitive
data, and sink annotations indicate methods that leak data
outside of the device. In contrast, transfer annotations are
used for describing taint ﬂow through Android SDK meth-
ods. In our approach, transfer annotations are necessary
because Apposcopy analyzes the source code of Android ap-
plications, but notthe underlying implementation of the
Android platform. Hence, we have manually written an-
notations for Android SDK methods that propagate taint
between parameters and return values.
Example 5.Figure 9 shows representative examples of
source, sink, and transfer annotations. All three kinds of
speciﬁcations are written using the @Flowannotation, and
sources and sinks are indicated by the special preﬁxes $and!
respectively. In Figure 9, the annotation at line 2 is a sourc e
annotation, indicating that getDeviceId ’s return value is a
taint source. The sink annotation at line 8 indicates that1. //Source annotation in android.telephony.TelephonyMa nager
2. @Flow(from="$getDeviceId",to="@return")
3. String getDeviceId(){ ... }
7. //Sink annotation in android.telephony.SmsManager
8. @Flow(from="text",to="!sendTextMessage")
9. void sendTextMessage(...,String text,...){ ... }
10. //Transfer annotation in java.lang.String
11. @Flow(from="this",to="@return")
12. @Flow(from="s",to="@return")
13. String concat(String s){ ... }
Figure 9: Source, Sink and Transfer annotations.
sendTextMessage is a sink for its formal parameter text.
Lines 11-12 correspond to transfer annotations for the An-
droid library method concatwhich is not analyzed by Ap-
poscopy. According to line 11, if the thisparameter of
concatis tainted, then its return value is also tainted. Sim-
ilarly, the annotation at line 12 states that if parameter sof
concatis tainted, then so is the return value.
We emphasize that the source, sink, and transfer anno-
tations are notwritten by individual users of Apposcopy,
which already comes with a set of built-in annotations that
we have written. Apposcopy uses the same pre-deﬁned an-
notations for analyzing every Android application.
4.3.2 Static Taint Analysis
We describe Apposcopy’s taint analysis using the infer-
ence rules shown in Figure 10, which deﬁne two predicates
tainted(o,l) andflow(so,si). The predicate taintedrepre-
sents a relation ( O: AbstractObj , L: SourceLabel) where
domainOis the set of all abstract heap objects and Lis the
set of all source labels, such as $getDeviceId . Iftainted(o,l)
is true, this means that any concrete heap objected repre-
sented by omay be tainted with l. The predicate ﬂow(so,si)
representsarelationoftype( L: SourceLabel , L: SinkLabel).
Ifﬂow(so,si) is true, this means that source somay reach
sinksi. Hence, the ﬂowpredicateisastaticover-approximation
of the taint ﬂow relation introduced in Deﬁnition 3.6.
All of the rules in Figure 10 use the notation mito denote
thei’th parameter of method m. For uniformity of presen-
tation, we represent the thispointer as m0and the return
value as mn+1wherenis the number of arguments of m.
The ﬁrst rule labeled Source in Figure 10 describes taint
introduction. In this rule, we use the notation src(mi,l) to
denotethatthe i’thparameterof misannotatedwithsource
labellas described in Section 4.3.1. Hence, if variable mi
may point to heap object oandmiis annotated as source l,
then heap object oalso becomes tainted with label l.
The second rule called Transfer performs taint propaga-
tion. Here, the predicate transfer(mi,mj) corresponds to
the transfer annotations from Section 4.3.1 and indicates
there is a ﬂow from the i’th to the j’th parameter of An-
droid SDK method m. According to this rule, if (i) mican
ﬂow tomj, (ii)miandmjmay point to heap objects o1and
o2respectively, and (iii) o1is tainted with label l, theno2
also becomes tainted with label l.
ThethirdrulelabeledSinkdeﬁnesthe ﬂowpredicateusing
thetaintedpredicate. Here, the notation sink(mi,si) means
that the i’th parameter of miis passed to some sink labeled
si. Hence, according to this rule, if miis passed to sink si,
andmimay point to a heap object othat is tainted with
labelso, then there may be a ﬂow from source soto sinksi.
The taint analysis of Apposcopy consists of applying the
rules from Figure 10 until a ﬁxed-point is reached. Observesrc(mi,l), mi֒→o
tainted(o,l)(Source)
tainted(o1,l), mi֒→o1, mj֒→o2
transfer(mi,mj)
tainted(o2,l)(Transfer)
tainted(o,so),mi֒→o,sink(mi,si)
ﬂow(so,si)(Sink)
Figure 10: Rules describing the taint analysis.
that the rules from Figure 10 do not describe transformers
for individual instructions such as stores because we use the
points-to facts computed by a whole-program pointer anal-
ysis. That is, if any variable vin the program may ﬂow to
mithrough a chain of heap reads and writes, we will have
mi֒→ovwhereovis the location pointed to by v.1
Example 6.Consider the code in Figure 5 and annota-
tions in Figure 9. Say x,y,zpoint to heap objects o1,o2,o3
respectively. Since src(getDeviceIdreturn,$getDeviceId )and
y ֒→o2, the Source rule infers tainted(o2,$getDeviceId ).
transfer (concat 1,concat return)denotes a transfer annotation
at line 5 where concat 1֒→o2,concat return֒→o3; thus, the
Transfer rule infers tainted(o3,$getDeviceId ). Finally, con-
sider the call to method sendTextMessage which has a sink an-
notation sink(sendTextMessage3,!getDeviceId ). Since the ar-
gumentvandzare aliases, we have sendTextMessage3֒→o3.
Hence, we deduce flow($getDeviceId ,!sendTextMessage ).
5. IMPLEMENTATION & EV ALUATION
Our implementation consists of about 30,000 lines of Java
and uses several publicly-available software such as Soot [35]
and bddbddb [36]. Soot is used to convert Android’s .apk
ﬁles toJimple, a higher-level intermediate representation.
A pre-processing step processes Jimple instructions to ex-
tract various types of program facts, and our static analyses
are speciﬁed as Datalog programs. The bddbddb system
takes as input the Datalog speciﬁcation of a static analysis
and extracted program facts and outputs the results of the
analysis. Apposcopy’s static analyses use manually-writte n
models of the Android framework; currently, we have models
for about 1,100 classes that are relevant for our analyses.
To evaluate the eﬀectiveness and accuracy of Apposcopy,
we performed four sets of experiments, including evaluation
on (i) known malware, (ii) Google Play apps, (iii) obfuscated
malware. In addition, (iv) we also compare Apposcopy with
another research tool called Kirin for Android malware de-
tection. The remainder of this section describes the details
and results of our evaluations.
5.1 Evaluation on Known Malware
In our ﬁrst experiment, we evaluate the eﬀectiveness of
Apposcopy on 1027 malware instances from the Android
Malware Genome project [1], which contains real malware
collected from various sources, including Chinese and Rus-
sian third-party app markets. All of these malicious appli-
cations belong to known malware families, such as Droid-
KungFu, Geinimi, and GoldDream. To perform this ex-
periment, we manually wrote speciﬁcations for the malware
families included in the Android Malware Genome Project.
For this purpose, we ﬁrst read the relevant reports where
available and inspected a small number (1-5) of instances
1For simplicity of presentation, we assume every variable is
a pointer to a heap object.Table 6: Examples of Apposcopy’s signatures.
Malware family Signature
ADRD ADRD :- receiver(r), icc(SYSTEM, r, BOOT_COMPLETED, _),re ceiver(s), service(t),icc*(r,s), icc*(s,t), icc*(t,s),
flow(t, DeviceId, t, ENC), flow(t, SubscriberId, t, ENC), f low(t, ENC, t, Internet).
BeanBot BeanBot :- receiver(r), service(s), service(t), service( q), icc(SYSTEM, r, PHONE_STATE, _),
calls(r, abortBroadcast), icc*(r, s), icc*(s, t), icc*(s, q), flow(s, DeviceId, s, Internet),
flow(s, Line1Number, s, Internet), flow(s, SimSerialNumb er, s, Internet).
CoinPirate CoinPirate :- receiver(r), receiver(t), icc(SYSTEM, r, SM S_SENT, _), icc(SYSTEM, r, SMS_RECEIVED, _), service(s),
calls(r, abortBroadcast), calls(s, sendTextMessage), ic c*(r, s), icc*(s, t), flow(s, DeviceId, s, Internet),
flow(s, SubscriberId, s, Internet), flow(s, Model, s, Inte rnet), flow(s, SDK, s, Internet).
for each malware family. Table 6 shows signatures that we
wrote for some of these malware families.
Table 7 presents the results of this experiment. The ﬁrst
column indicates the malware family, and the second col-
umn shows the number of analyzed instances of that mal-
ware family. The next two columns show the number of false
negatives (FN) and false positives (FP) respectively. In this
context, a false negative arises if an application Abelongs
to a certain malware family Fbut Apposcopy cannot detect
thatAis an instance of F. Conversely, a false positive arises
if an application Adoes not belong to malware family Fbut
Apposcopy erroneously reports that it does. The ﬁnal col-
umn of Table 7 reports Apposcopy’s overall accuracy, which
is calculated as the number of correctly classiﬁed instances
divided by the total number of samples.
As shown in the last row of Table 7, the overall accuracy
of Apposcopy over all malware instances that we analyzed
is 90.0%. That is, it can correctly classify approximately 9
out of 10 malware instances accurately.
However, looking at the results more closely, we see that
Apposcopy performs quite poorly on the BaseBridge mal-
ware family. Speciﬁcally, among the 121 samples that we
analyzed, Apposcopy only classiﬁes 46 of these application s
as instances of BaseBridge. Upon further inspection of this
family, we found that many of the BaseBridge instances dy-
namically load the code that performs malicious function-
ality. Such behavior can inherently not be detected using
static analysis and causes Apposcopy to yield many false
negatives. Observe that, if we exclude BaseBridge from our
samples, the overall accuracy of Apposcopy rises to 96.9%.
FortheothermalwarefamiliesforwhichApposcopyyields
false negatives, there are several contributing factors. First,
since we have written the speciﬁcations by inspecting only a
small number of samples, our signatures may not adequately
capture the essential characteristics of allinstances of that
family. Second, the malware family may have some key fea-
ture that is not expressible in our malware speciﬁcation lan-
guage. For example, if a given malware performs malicious
functionality without leaking sensitive data, Apposcopy wi ll
be unable to detect it. A third contributing factor for false
negatives is due to missing models. Speciﬁcally, while our
static analysis is sound, we do not analyze the underlying
codeoftheAndroidsystem, butinsteadrelyon method stubs
that capture the relevant behavior of the Android SDK. If
these applications call SDK methods for which we have not
provided stubs, Apposcopy may yield false negatives.
Based on the data from Table 7, we observe that Ap-
poscopy reports very few false positives. Among the 1027
malware samples, Apposcopy reports two instances of the
Geinimi family as instances of both Geinimi as well as the
DroidKungFu family. This corresponds to an overall false
positive ratio of less than 0.2%, indicating that Apposcopy’ s
staticanalysisispreciseenoughtoaccuratelyanswercontro l-
and data-ﬂow queries about Android applications.Table 7: Evaluation of Apposcopy on malware from
the Android Malware Genome project.
Malware Family #Samples FNFPAccuracy
DroidKungFu 444 15096.6%
AnserverBot 184 2098.9%
BaseBridge 121 75038.0%
Geinimi 68 2297.1%
DroidDreamLight 46 00100.0%
GoldDream 46 1097.8%
Pjapps 43 7083.7%
ADRD 22 00100.0%
jSMSHider 16 00100.0%
DroidDream 14 1092.9%
Bgserv 9 00100.0%
BeanBot 8 00100.0%
GingerMaster 4 00100.0%
CoinPirate 1 00100.0%
DroidCoupon 1 00100.0%
Total 1027 103290.0%
Finally, we remark that Apposcopy’s analysis time on
these malicious applications is moderate, with an average
of 275 seconds per analyzed application containing 18,200
lines of Dalvik bytecode on average.
5.2 Evaluation on Google Play Apps
In a second experiment, we evaluate Apposcopy on thou-
sands of apps from Google Play. Since these applications are
available through the oﬃcial Android market rather than
less reliable third-party app markets, we would expect a
large majority of these applications to be benign. Hence,
by running Apposcopy on Google Play apps, we can assess
whether our high-level signatures adequately diﬀerentiate
benign applications from real malware.
In our experiment, among the 11,215 apps analyzed by
Apposcopy, only16ofthemwerereportedasmalware. Specif-
ically, Apposcopy reported two applications to be instances
of DroidDreamLight, one to be an instance of DroidDream
and another one to be an instance of Pjapps. The remaining
12 applications were categorized as DroidKungFu. To de-
cide whether these 16 apps are indeed malware, we uploaded
them to VirusTotal [5] for analyzing suspicious applications .
VirusTotal is a service that runs multiple anti-virus tools on
the uploaded application and shows their aggregate results.
Based on the results provided by VirusTotal, the majority
of anti-virus tools agree with Apposcopy’s classiﬁcation for
13 of the 16 reported malware. For the remaining three
applications, the majority of the tools classify them as ma-
licious adware while Apposcopy classiﬁes them as instances
of DroidKungFu. This experiment conﬁrms our claim that
Apposcopy does not generate a lot of false alarms and that
our malware signatures can distinguish benign applications
from real malware.
Similar to the experiments from Section 5.1, Apposcopy
takes an average of 346 seconds to analyze a Google Play
application with 26,786 lines of Dalvik bytecode on average.5.3 Evaluation on Obfuscated Apps
To substantiate our claim that Apposcopy is resilient to
code transformations, we compare the detection rate of Ap-
poscopy with other anti-virus tools on obfuscated versions of
known malware. For this experiment, we obfuscated exist-
ing malware using the ProGuard tool [2], which is commonly
used by malware writers to evade detection. In addition,
since the databases of some of the anti-virus tools include
signatures of malware samples obfuscated by ProGuard, we
also applied three additional obfuscations that are not per-
formed by ProGuard: First, our obfuscator changes the
names of components, classes, methods, and ﬁelds. Second,
all invocations to methods of android.* classes are redi-
rected through proxy methods. Third, our obfuscator also
performs string encryption, including encryption of compo-
nent names as well as action and data type values of intents.
Table 8 shows the results of our third experiment on ob-
fuscated malware. Each row in this table corresponds to an
application that is an instance of a known malware family
(and whose unobfuscated version can be identiﬁed as mal-
ware by all tools considered in our evaluation). Each column
in the table corresponds to a leading anti-virus tool, namely,
AVG, Symantec, ESET, Dr. Web, Kaspersky, Trend Micro,
and McAfee. A check ( ✓) indicates that the tool is able to
detect the obfuscated version of the program as malware,
and a cross ( ✗) means that the tool is unable to classify
the obfuscated version as malicious. As Table 8 shows, Ap-
poscopy is resistant to these obfuscations for all malware
that we considered. In contrast, none of the other tools can
successfully classify all of the obfuscated apps as malware.
5.4 Comparison with Kirin
InadditiontocomparingApposcopywithcommercialanti-
virus tools, we also compared Apposcopy against Kirin [19],
which is the onlypublicly available research tool for An-
droid malware detection. As explained in Section 6, Kirin is
a signature-based malware detector that classiﬁes an app as
malware if it uses a dangerous combination of permissions
speciﬁed by the malware signature. On the set of malicious
apps considered in Section 5.1, Kirin reports only 532 apps
out of 1,027 malicious apps to be malware. This corresponds
toafalsenegativerateof48%, whichisquitehighcompared
to the 10% false negative rate of Apposcopy. On the other
hand, for the set of applications taken from Google Play and
considered in Section 5.2, Kirin reports 8% of these apps to
be malware, while Apposcopy classiﬁes only 0.14% of these
apps as malicious. We manually inspected 20 out of the
886 apps classiﬁed as malware by the Kirin tool and also
compared with the results of VirusTotal. Our evaluation re-
vealed that the overwhelming majority of the apps classiﬁed
as malware by Kirin are false positives. Hence, our experi-
ments demonstrate that Apposcopy outperforms Kirin both
in terms of false positives as well as false negatives.
6. RELATED WORK
Taint analysis. Bothdynamic andstatictaint anal-
yses have been proposed for tracking information-ﬂow in
mobile applications. For example, TaintDroid [17] and Vet-
Droid [37] are dynamic taint analyses that track information
ﬂowbyinstrumentingtheDalvikVM,andexamplesofstatic
taint analyses include [20, 21, 23, 16]. While Apposcopy
employs static taint analysis as one of its components, we
observe that not every application that leaks sensitive datais malicious — in fact, many benign apps transmit sensi-
tive data for performing their required functionality. Thus,
taint analyses on their own are not suﬃcient for automat-
ically diﬀerentiating malicious apps from benign apps, and
we propose to combine taint analysis with high-level mal-
ware signatures to eﬀectively identify malicious code.
Signature-based malware detection. Many techniques
for identifying existing malware are signature-based, mean-
ing that they look for patterns identifying a certain malware
family. In its simplest form, these patterns are sequences
of bytes or instructions [25]. Since such syntactic patterns
can be defeated by semantics-preserving transformations,
previous work has considered semantics-aware malware de-
tection [13]. Similar to [13], Apposcopy detects malware
based on their semantic rather than syntactic characteris-
tics. However, our signatures are much higher-level com-
pared to the templatized instruction sequences used in [13]
and allow directly specifying control- and data-ﬂow proper-
ties of Android applications. Furthermore, the underlying
signature matching techniques are also very diﬀerent.
A popular signature-based malware detection technique
for Android is the Kirin tool [19]. The malware signatures
in Kirin specify dangerous combinations of Android permis-
sions, and Kirin decides if an application matches a signa-
ture by analyzing its manifest ﬁle. As demonstrated in our
experimental evaluation, Kirin yields many more false posi-
tives and false negatives compared to Apposcopy.
Another related approach is the behavioral detection tech-
nique described in [9]. In that approach, one speciﬁes com-
mon malware behavior using temporal logic formulas. How-
ever, a key diﬀerence between Apposcopy and behavioral
detection is that our techniques are purely static, while [9]
requires monitoring behavior of the application at run-time.
The DroidRanger tool [40] uses permission-based behav-
ioral footprint to detect instances of known malware fam-
ilies. Behavioral footprints include characteristic malware
features, such as listening to certain system events, calling
suspicious APIs, and containing hard-coded strings. While
these behavioral footprints can be viewed as high-level mal-
ware signatures, they diﬀer from those of Apposcopy in sev-
eral ways: Behavioral footprints neither refer to information
ﬂow properties of an application nor do they express control
ﬂow dependencies between diﬀerent components. Further-
more, behavioral footprints include hard-coded string val-
ues, which are easy to obfuscate by malware writers.
Zero-day malware detection. A known limitation of
signature-based approaches, including Apposcopy, is that
they can only detect instances of known malware families.
In contrast, zero-day malware detectors try to uncover un-
known malware families. For example, RiskRanker [24] per-
forms several risk analyses to rank Android applications as
high-, medium-, or low-risk. These risk analyses include
techniquestoidentifysuspiciouscodethatexploitsplatform-
level vulnerabilities or sends private data without being trig-
gered by user events. In addition to identifying instances
of known malware, DroidRanger [40] also tries to uncover
zero-day malware by performing heuristic-based ﬁltering to
identify certain“inherently suspicious”behaviors.
Many recent malware detectors, such as [8, 22, 10, 33, 6],
use machine learning to detect zero-day malware. For ex-
ample, Drebin [8] performs light-weight static analysis to ex-
tract features, such as permissions and API calls, and trainsTable 8: Comparison between Apposcopy and other tools on obf uscated malware.
Family AVG Symantec ESET Dr. Web Kaspersky Trend Micro McAfee Apposcopy
DroidKungFu ✗ ✗ ✓ ✗ ✓ ✗ ✗ ✓
Geinimi ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓
DroidDreamLight ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓
GoldDream ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✓
DroidDream ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓
BeanBot ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓
GingerMaster ✗ ✗ ✓ ✓ ✓ ✓ ✓ ✓
Pjapps ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓
Bgserv ✓ ✗ ✗ ✗ ✓ ✗ ✗ ✓
CoinPirate ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓
jSMSHider ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓
AnserverBot ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✓
DroidCoupon ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓
ADRD ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓
Success rate 28.6% 14.3% 42.9% 35.7% 57.1% 35.7% 28.6% 100.0%
an SVM to ﬁnd a hyperplane separating benign apps from
malware. The DroidAPIMiner tool [6] also considers API
features and uses machine learning to automatically classify
an application as malicious or benign. While learning-based
approaches are powerful for detecting unknown malware,
their precision relies on representative training sets.
We believe all of these zero-day malware detection tech-
niques are complementary to Apposcopy: While Apposcopy
can identify instances of known malware families with few
false alarms, zero-day malware detectors can help uncover
new malware families, albeit at the cost of more false posi-
tives or more involvement from a security auditor.
Static analysis for malware detection. Static anal-
ysis and model checking have been used to detect security
vulnerabilities for a long time. In the context of mobile
malware, the SAAF tool [26] uses program slicing to iden-
tify suspicious method arguments, such as certain URLs or
phone numbers. The work described in [18] performs vari-
ous static analyses, including taint analysis, to better un der-
stand smartphone application security in over 1,000 popular
Android apps. One of the interesting conclusions from this
study is that, while many apps misuse privacy-sensitive in-
formation, few of these apps can be classiﬁed as malware.
The Pegasus system [11] focuses on malware that can be
identiﬁedbytheorderinwhichcertainpermissionsandAPIs
are used. The user writes speciﬁcations of expected app be-
havior using temporal logic formulas, and Pegasus model
checks these speciﬁcations against an abstraction called th e
permission event graph (PEG) . Pegasus diﬀers from our ap-
proach in that (i) it targets a diﬀerent class of malware, and
(ii)PEGabstractstherelationshipbetweentheAndroidsys-
tem and the application, while ICCG abstracts the relation-
ship between diﬀerent components in the application.
Some recent papers address the detection of re-packaged
apps which often inject adware or malicious features into
legitimate apps [39, 38, 15, 14]. While some repackaged
apps may contain malware, these techniques mainly focus
on clone rather than malware detection.
Analysis of ICC. ComDroid [12] analyzes ICC of An-
droid apps to expose security vulnerabilities, such as intent
spooﬁng or unauthorized intent receipt. CHEX [29] per-
forms static analysis to identify app entry points and uses
this information to detect component hijacking vulnerabil-
ities. In contrast to Apposcopy, ComDroid and CHEX are
meant to be used by developers to identify security vulner-
abilities in their own applications.Epicc [32] also addresses ICC in Android and proposes a
static analysis for inferring ICC speciﬁcations . These speciﬁ-
cationsincludeICCentryandexitpoints, informationabout
the action, data and category components of intents used for
ICC, as well as Intent key/value types. While our ICCG en-
codes similar information to the speciﬁcations inferred by
Epicc, we show that the ICCG is a useful abstraction for
specifying and identifying Android malware.
7. LIMITATIONS
Likeanysignature-basedsolution, Apposcopyisnotinvin-
cible; it is very hard to design any signature-based scheme
that cannot be defeated by a suitably designed automatic
obfuscator. Inparticular, similartoanystaticanalysisbased
system, Apposcopy may be defeated by obfuscation tech-
niques such as dynamic code loading and use of reﬂection
in combination with obfuscation of method or class names.
However, such attempts to escape detection are likely to be
deemed suspicious and may invite further scrutiny.
Second, since Apposcopy performs deep static analysis
to uncover semantic properties of an app, it may be un-
ﬁt for scenarios that require instant detection of malware.
However, smartphoneappsaregenerallydistributedthrough
centralized app stores, which enables deployment of Ap-
poscopy to scan apps as they are submitted to the app store.
8. CONCLUSION AND FUTURE WORK
We presented Apposcopy, a static analysis approach for
detecting malware in the mobile apps ecosystem. Malware
that belong to one family share a common set of charac-
teristic behaviors, which an auditor can encode through Ap-
poscopy’sDatalog-basedmalwarespeciﬁcationlanguage. Ap-
poscopy performs deep static analysis to extract data-ﬂow
and control-ﬂow properties of Android applications and uses
these results to identify whether a given application belongs
to a known malware family. Our experiments indicate that
Apposcopy can detect malware with high accuracy and that
its signatures are resilient to various program obfuscations.
There are several opportunities for future work. We will
develop techniques to improve the eﬃciency and precision
of Apposcopy’s static analyses. We also plan to develop
techniques to automatically de-obfuscate apps to enhance
Apposcopy’s resilience to some types of obfuscations (see
Section 7). Finally, we plan to develop techniques to auto-
maticallylearnmalwaresignaturesfromasetofappslabeled
with their corresponding malware family (or as benign).9. REFERENCES
[1] Android malware genome project.
http://www.malgenomeproject.org/ .
[2] ProGuard. http://proguard.sourceforge.net/ .
[3] Q2 IT evolution threat report.
http://www.securelist.com/en/analysis/
204792299/IT_Threat_Evolution_Q2_2013 .
[4] US homeland security report.
http://info.publicintelligence.net/
DHS-FBI-AndroidThreats.pdf .
[5] VirusTotal. https://www.virustotal.com/en/ .
[6] Y. Aafer, W. Du, and H. Yin. DroidAPIMiner:
Mining API-level features for robust malware
detection in Android. In SecureComm , 2013.
[7] L. O. Andersen. Program analysis and specialization
for the C programming language . PhD thesis,
University of Cophenhagen, 1994.
[8] D. Arp, M. Spreitzenbarth, M. H ¨ubner, H. Gascon,
K. Rieck, and C. Siemens. Drebin: Eﬀective and
explainable detection of android malware in your
pocket. 2014.
[9] A. Bose, X. Hu, K. G. Shin, and T. Park. Behavioral
detection of malware on mobile handsets. In MobiSys,
pages 225–238, 2008.
[10] S. Chakradeo, B. Reaves, P. Traynor, and W. Enck.
Mast: triage for market-scale mobile malware analysis.
InWISEC, pages 13–24, 2013.
[11] K. Z. Chen, N. M. Johnson, V. D’Silva, S. Dai,
K. MacNamara, T. Magrino, E. X. Wu, M. Rinard,
and D. X. Song. Contextual policy enforcement in
Android applications with permission event graphs. In
NDSS, 2013.
[12] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner.
Analyzing inter-application communication in
Android. In MobiSys, pages 239–252, 2011.
[13] M. Christodorescu, S. Jha, S. A. Seshia, D. X. Song,
and R. E. Bryant. Semantics-aware malware detection.
InSecurity and Privacy , pages 32–46, 2005.
[14] J. Crussell, C. Gibler, and H. Chen. Attack of the
clones: Detecting cloned applications on Android
markets. In ESORICS , pages 37–54. 2012.
[15] J. Crussell, C. Gibler, and H. Chen. Scalable
semantics-based detection of similar Android
applications. In ESORICS , 2013.
[16] M. Egele, C. Kruegel, E. Kirda, and G. Vigna. Pios:
Detecting privacy leaks in ios applications. In NDSS,
2011.
[17] W. Enck, P. Gilbert, B. gon Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. Sheth. TaintDroid: An
information-ﬂow tracking system for realtime privacy
monitoring on smartphones. In OSDI, pages 393–407,
2010.
[18] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri.
A study of android application security. In USENIX
Security Symposium , 2011.
[19] W. Enck, M. Ongtang, and P. D. McDaniel. On
lightweight mobile phone application certiﬁcation. In
ACM Conference on Computer and Communications
Security, pages 235–245, 2009.
[20] C. Fritz, S. Arzt, S. Rasthofer, E. Bodden, A. Bartel,
J. Klein, Y. le Traon, D. Octeau, and P. McDaniel.Highly precise taint analysis for android application.
Technical report, EC SPRIDE Technical Report, 2013.
[21] A. P. Fuchs, A. Chaudhuri, and J. S. Foster.
SCanDroid: Automated Security Certiﬁcation of
Android Applications. Technical Report CS-TR-4991,
Department of Computer Science, University of
Maryland, College Park, November 2009.
[22] H. Gascon, F. Yamaguchi, D. Arp, and K. Rieck.
Structural detection of android malware using
embedded call graphs. In AISec, pages 45–54, 2013.
[23] C. Gibler, J. Crussell, J. Erickson, and H. Chen.
AndroidLeaks: Automatically detecting potential
privacy leaks in Android applications on a large scale.
InTRUST, pages 291–307, 2012.
[24] M. C. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang.
RiskRanker: scalable and accurate zero-day Android
malware detection. In MobiSys, pages 281–294, 2012.
[25] K. Griﬃn, S. Schneider, X. Hu, and T. cker Chiueh.
Automatic generation of string signatures for malware
detection. In RAID, pages 101–120, 2009.
[26] J. Hoﬀmann, M. Ussath, T. Holz, and
M. Spreitzenbarth. Slicing droids: program slicing for
smali code. In SAC, pages 1844–1851, 2013.
[27] X. Jiang. Security alert: New Android malware –
GoldDream – found in alternative app markets. http:
//www.csc.ncsu.edu/faculty/jiang/GoldDream/ ,
2011.
[28] G. Kastrinis and Y. Smaragdakis. Hybrid
context-sensitivity for points-to analysis. In PLDI,
pages 423–434, 2013.
[29] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. Chex:
statically vetting android apps for component
hijacking vulnerabilities. In ACM Conference on
Computer and Communications Security , pages
229–240, 2012.
[30] M. Might, Y. Smaragdakis, and D. V. Horn. Resolving
and exploiting the k-cfa paradox: illuminating
functional vs. object-oriented program analysis. In
PLDI, pages 305–315, 2010.
[31] A. Milanova, A. Rountev, and B. G. Ryder.
Parameterized object sensitivity for points-to analysis
for Java. TOSEM, 14(1):1–41, 2005.
[32] D. Octeau, P. McDaniel, S. Jha, A. Bartel, ,
E. Bodden, J. Klein, and Y. L. Traon. Eﬀective
inter-component communication mapping in Android
with Epicc: An essential step towards holistic security
analysis. In USENIX Security Symposium , 2013.
[33] H. Peng, C. S. Gates, B. P. Sarma, N. Li, Y. Qi,
R. Potharaju, C. Nita-Rotaru, and I. Molloy. Using
probabilistic generative models for ranking risks of
android apps. In ACM Conference on Computer and
Communications Security , pages 241–252, 2012.
[34] V. Rastogi, Y. Chen, and X. Jiang. DroidChameleon:
evaluating Android anti-malware against
transformation attacks. In ASIACCS , pages 329–334.
ACM, 2013.
[35] R. Vall´ ee-Rai, P. Co, E. Gagnon, L. J. Hendren,
P. Lam, and V. Sundaresan. Soot - a Java bytecode
optimization framework. In CASCON , page 13, 1999.
[36] J. Whaley, D. Avots, M. Carbin, and M. S. Lam.
Using datalog with binary decision diagrams for
program analysis. In APLAS, pages 97–118, 2005.[37] Y. Zhang, M. Yang, B. Xu, Z. Yang, G. Gu, P. Ning,
X. S. Wang, and B. Zang. Vetting undesirable
behaviors in android apps with permission use
analysis. In ACM Conference on Computer and
Communications Security , pages 611–622, 2013.
[38] W. Zhou, Y. Zhou, M. C. Grace, X. Jiang, and S. Zou.
Fast, scalable detection of“piggybacked”mobile
applications. In CODASPY , pages 185–196, 2013.[39] W. Zhou, Y. Zhou, X. Jiang, and P. Ning. Detecting
repackaged smartphone applications in third-party
Android marketplaces. In CODASPY , pages 317–326,
2012.
[40] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, you,
get oﬀ of my market: Detecting malicious apps in
oﬃcial and alternative android markets. In NDSS,
2012.