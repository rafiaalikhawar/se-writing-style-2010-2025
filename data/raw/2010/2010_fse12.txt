Retargeting Android Applications to Java Bytecode
Damien Octeau
Department of Computer
Science and Engineering
Pennsylvania State University
octeau@cse.psu.eduSomesh Jha
Computer Sciences
Department
University of Wisconsin
jha@cs.wisc.eduPatrick McDaniel
Department of Computer
Science and Engineering
Pennsylvania State University
mcdaniel@cse.psu.edu
ABSTRACT
The Android OS has emerged as the leading platform for Smart-
Phone applications. However, because Android applications are
compiled from Java source into platform-speciÔ¨Åc Dalvik bytecode,
existing program analysis tools cannot be used to evaluate their
behavior. This paper develops and evaluates algorithms for retar-
geting Android applications received from markets to Java class
Ô¨Åles. The resulting Dare tool uses a new intermediate representa-
tion to enable fast and accurate retargeting. Dare further applies
strong constraint solving to infer typing information and translates
the 257 DVM opcodes using only 9 translation rules. It also han-
dles cases where the input Dalvik bytecode is unveriÔ¨Åable. We
evaluate Dare on 1,100 of the top applications found in the free
section of the Android market and successfully retarget 99.99% of
the 262,110 associated classes. Further, whereas existing tools can
only fully retarget about half of these applications, Dare can re-
cover over 99% of them. In this way, we open the door to users,
developers and markets to use the vast array of program analysis
tools to ensure the correct operation of Android applications.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance, and
Enhancement‚Äî Restructuring, reverse engineering, and reengineer-
ing
Keywords
Android, Dalvik bytecode, Dalvik retargeting
1. INTRODUCTION
Android now hosts more smartphones worldwide than any other
mobile platform, and its market share is increasing quickly [11,
18]. The corresponding markets are delivering an astonishing ar-
ray of applications ‚Äì as of March 2012, the number of applications
available from the Android Market alone doubled to 400,000 in just
eight months [3]. However, existing markets provide little mean-
ingful security or privacy guarantees because market providers have
neither the tools nor the resources to perform detailed analysis of
submitted applications [22]. Thus, users fall victim to bad applica-
tions with moderate to devastating results [4, 8, 13, 17].
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
SIGSOFT‚Äô12/FSE-20, November 11‚Äì16, 2012, Cary, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1614-9/12/11 ...$15.00.At the time of registration, Android developers submit an ‚Äúappli-
cation package‚Äù containing the program bytecode, resources and an
XML manifest to the market. The submitted applications are ini-
tially developed in Java, but compiled by the developer into Dalvik
bytecode [12]. Android runs each application on the phone in its
own instance of the Dalvik virtual machine (DVM). The DVM
has some major differences with traditional JVM. For example,
the DVM is a register-based architecture and has ambiguous reg-
ister typing (see Section 2). These different bytecode and program
structures make it impossible to leverage existing Java tools such
as Soot [37] or WALA [15] for program analysis of Android appli-
cations. Thus, in the absence of usable analysis tools, markets can
do little to vet applications.
In this paper, we develop and evaluate algorithms for retargetting
Dalvik to Java bytecode. The resulting tool is called Dare (DAlvik
REtargeting)1.Dare was motivated by our past analysis of a large
corpus of applications found in the Android market. In this study,
we used a rudimentary retargeting tool to perform a study of secu-
rity properties of Android applications [9]. The output of that re-
targeting tool was input to Dava [24]‚Äìa Java decompiler integrated
with the Soot toolkit [37]‚Äìand the resulting source code analyzed
using Fortify SCA [14]. We found that the ad hoc methods used
for retargeting were often unreliable or failed outright. These fail-
ures limited the visibility of the code (and thus the coverage of
the analysis), and prevented conclusive results. More speciÔ¨Åcally,
while we were often able to retarget and eventually decompile por-
tions of the application code, about half the applications had classes
which were unrecoverable, which made program analysis of com-
plete applications impossible. Further, the ad hoc tool was targeting
decompilers and its success rate was measured in terms of decom-
pilation success. For Dare , we do not target a speciÔ¨Åc tool but in-
stead seek to produce veriÔ¨Åable Java bytecode, which ensures that
it is accepted by analysis tools.
By providing the Java bytecode of Android applications via Dare ,
we provide a path for users, developers, application market providers
(such as Amazon) to perform analysis on Android applications.
The following sections detail the structure of Dare . Principally,
we focus on solutions that address the key challenges of retargeting
Dalvik bytecode. Our paper makes the following contributions:
We introduce the Tyde intermediate representation for struc-
tured semantic mapping between the VMs. All 257 Dalvik in-
structions are translated using only 9 translation rules.
Because sound bytecode typing is necessary for veriÔ¨Åability,
we use a strong constraint-based type inference algorithm.
We introduce code transformations to Ô¨Åx unveriÔ¨Åable input byte-
code. In addition to making the code veriÔ¨Åable, these transfor-
mations accurately mirror VM runtime behavior.
1Source code and documentation for Dare are available at [32].We evaluate our algorithms on a sample of 1,100 applications.
We successfully retarget 99.99% of the 262,110 classes. Fur-
ther, while previous tools were able to completely recover less
than 60% of the applications in the corpus, we recover over
99%. Retargeting is efÔ¨Åcient, taking less than 20 minutes for
the entire sample. Finally, our experiments reveal that over 20%
of applications in the sample have unveriÔ¨Åable Dalvik bytecode
in at least one class.
The remainder of this paper explores the algorithms and struc-
ture of Dare . The next two sections provide background on the
retargeting challenges and outline the Dare retargeting process.
Next, we describe how DVM bytecode is translated into the Tyde
intermediate representation (Sections 4 and 5) and then converted
to Java bytecode (Section 6). Next, we show the causes of unver-
iÔ¨Åability in Dalvik bytecode and how to reliably retarget unveriÔ¨Å-
able bytecode (Section 7). We then present the empirical study of
Dare (Section 8), show related work (Section 9) and conclude.
2. RETARGETING CHALLENGES
Android applications are developed in Java and compiled into
JVM class Ô¨Åles. Then, the various class Ô¨Åles comprising the ap-
plication are retargeted to the DVM and coalesced into a single
.dex Ô¨Åle. Thus, Java bytecode is an intermediate representation
for DVM bytecode. Dare reverses the lossy JVM to DVM byte-
code compilation to allow subsequent program analysis, e.g., [9].
In order to make sure that the bytecode we generate can be used
by existing analysis tools, we aim to generate veriÔ¨Åable bytecode.
Since not all code that is loaded by a VM necessarily comes from
a trusted compiler, the veriÔ¨Åcation process ensures that code can
be safely executed. The Java veriÔ¨Åcation process is precisely de-
scribed in the JVM speciÔ¨Åcation [21, ¬ß4.9]. The Dalvik veriÔ¨Åcation
process is mostly deÔ¨Åned in the Dalvik source code documenta-
tion [12] (we inferred part of it directly from the source code). The
JVM and DVM veriÔ¨Åers both check for similar static constraints
(i.e., answering the question: ‚Äúis the Ô¨Åle well-formed?‚Äù) and struc-
tural constraints (i.e., relationships between instructions). They
also both implement a similar type inference algorithm, which con-
sists in symbolically executing instructions one by one to infer the
inÔ¨Çuence that each instruction has on the types of the local variables
(Java) or registers (Dalvik). This algorithm follows all possible ex-
ecution paths and iterates as long as new type information is found
for a variable or a register. This part of the veriÔ¨Åcation process
ensures that the bytecode is type safe.
The differences between the JVM and DVM make the retargeting
process difÔ¨Åcult. To aid the following discussions, we give some
background on the main retargeting challenges.
Instruction Set - Dalvik instructions are vastly different from Java
instructions. DVM bytecode has 257 different instructions and 3
pseudo-instructions. Dalvik instructions are two to ten bytes long,
and pseudo-instructions have a variable length. The DVM has sub-
stantially more instruction formats (over 20) than the JVM.
Pseudo-instructions are used to store extra information related
to other instructions (and thus are never executed). SpeciÔ¨Åcally,
the Dalvik switch instructions ( packed-switch andsparse-
switch ) store an offset to a pseudo-instruction. The data describ-
ing the switch statement (case values and targets) is stored in a
pseudo-instruction placed at the end of the bytecode block. The
fill-array-data instruction Ô¨Ålls an array of primitive ele-
ments with values stored in a pseudo-instruction.
The DVM is register-based, whereas the JVM is stack-based.
Thus, the DVM uses registers to manage local variables rather than
pushing them onto a stack. For example, in Dalvik, add-int
‚ä§
‚ä•zerofloatdoublelongObjectbooleanarraysother refs32-bit64-bitbyteshortintcharFigure 1: Dalvik Type Lattice
v1;v2;v3adds the contents of registers v2andv3and stores the
result tov1. In contrast, Java bytecode would Ô¨Årst push the integer
variables onto the stack with iload 2 and iload 3, perform the
addition with iadd and store the result using istore 1.
It is challenging and potentially cumbersome to Ô¨Ånd a semantic
mapping for all 257 instructions. To allow structured mapping be-
tween the VMs, we introduce the Tyde intermediate representation
(IR) in Section 4 . The generation of Java bytecode from Tyde is
shown in Section 6 . In particular, we show how to make the transi-
tion from register-based bytecode to stack-based bytecode.
Exceptions - There is a signiÔ¨Åcant difference in the type inference
algorithm used by the veriÔ¨Åers, related to how they handle excep-
tions. During the path-sensitive type veriÔ¨Åcation process, the Java
veriÔ¨Åer considers that any instruction in a try block may throw an
exception. In reality, not all instructions in each try block are able
to throw exceptions. Therefore, the Java veriÔ¨Åer considers some
unfeasible execution paths. On the other hand, the Dalvik veriÔ¨Åer
does not consider these unfeasible paths. Occasionally, an unfea-
sible path leads from a register assignment to a register use with
an incompatible type (e.g., an int register assignment reaches a use
with Ô¨Çoat type). It is not an issue in the DVM, since the spurious
execution path is not considered by the veriÔ¨Åer. However, since the
Java veriÔ¨Åer follows the unfeasible path during type inference, it
leads to unveriÔ¨Åable Java bytecode if nothing is done to remove it.
We explain how we deal with this issue in Section 5.1 .
Bytecode Type System - DVM typing is very different than that
of JVM bytecode. The primary differences include:
Primitive Assignments - Dalvik primitive constant assignments
specify only the width of the constant (32 or 64 bits). Thus, no
distinction is made between int and Ô¨Çoat or between long and
double. In contrast, primitive constants in Java are fully typed.
Array Load/Store Instructions - The DVM has common array-
speciÔ¨Åc load and store instructions for int and Ô¨Çoat arrays ( aget
andaput ) and for long and double arrays ( aget-wide and
aput-wide ). Here again, this introduces type ambiguity.
Object References - Java bytecode uses the null reference
type to track and detect undeÔ¨Åned object references. Conversely,
Dalvik uses an integer constant with value 0 to represent both
the number zero and the null reference. Adding to this am-
biguity, a comparison between two integers uses the same in-
structions as a comparison between object references.
Figure 1 shows the lattice of types in the Dalvik architecture.
It depicts subtyping relations between types. We have collapsed
array and other reference types. The zero, 32-bit and 64-bit types
are not valid Java types. While our previous tool, ded [29, 31],
managed to generate valid types in most cases using a simple typeTyde IR GenerationBytecode Generation.dex ParsingCFG ConstructionType InferenceTyde to Jasmin TranslationJava Bytecode GenerationPre-Processing.class Ô¨Åles.dex Ô¨Åle(Android App)Figure 2: VeriÔ¨Åable Dalvik Bytecode Retargeting Overview
inference algorithm, a more sophisticated algorithm must be used
to systematically generate type-safe Java bytecode. We describe the
constraint-based algorithm we use for retargeting in Section 5.2 .
UnveriÔ¨Åable Dalvik Bytecode - Occasionally, part of the Dalvik
bytecode of applications found in the markets is unveriÔ¨Åable. As
the DVM and JVM veriÔ¨Åcation processes are similar, retargeting
unveriÔ¨Åable Dalvik bytecode usually leads to unveriÔ¨Åable Java byte-
code. Our goal is to generate veriÔ¨Åable bytecode on any input,
therefore properly dealing with unveriÔ¨Åable input code is an im-
portant challenge. We address it in Section 7 .
3. RETARGETING VERIFIABLE DALVIK
BYTECODE: OVERVIEW
Figure 2 describes the Dare retargeting process for veriÔ¨Åable
Dalvik bytecode. We address the issue of unveriÔ¨Åable Dalvik byte-
code in Section 7. The application bytecode is initially translated
into the Tyde intermediate representation (IR) in three steps: a) the
.dex Ô¨Åle is parsed and code structures, methods and the global
constant pool are interpreted and annotated, b) a control Ô¨Çow graph
is generated and c) register types used in ambiguous instructions
are inferred. The Java bytecode is thereafter generated from this IR
in three phases: d) a pre-processing step generates labels and maps
registers to local variables, e) the IR is translated to Jasmin [23]
code, andf) the Jasmin tool generates the Ô¨Ånal .class Ô¨Åles.
To illustrate, Figure 3(a) shows the source code for a hypotheti-
cal method m2and Figure 3(b) shows Java bytecode generated by
the Java compiler. The iload_1 instruction loads local variable
1 (variable ain the source) onto the stack. The next instruction
compares its value to 0. If it is not 0, then dconst_1 loads double
value 1.0 onto the stack and dreturn returns it. Otherwise, ifeq
branches to offset 6. ldc2_w loads a constant with value 2.5 from
the constant pool; the constant is then returned with dreturn .
Figure 3(c) shows the Dalvik bytecode for m2.if-eqz com-
pares the value of register v3to 0. If it is not 0, then a 64-bit
constant is assigned to register v0withconst-wide/high16
and returned with return-wide . Ifv3is 0, then the instruction
at offset 5 is executed and assigns a different 64-bit constant to v0.
Next, goto transfers control to offset 4. The 64-bit constants are
detected as long by default by the disassembler we used (dexdump),
which is why they appear as long (instead of double) in Figure 3(c).
Figures 3(d), 3(e) and 3(f) show the stages of retargeting. The
Tyde representation of m2is generated by mapping the Dalvik struc-
tures and generated control Ô¨Çow graph into the IR and performing
type inference on the ambiguous register references. Once in Tyde,
all registers are fully typed in accordance with the Java type system.
Figure 3(f) shows the retargeted Java bytecode after remapping and
Jasmin assembly. This bytecode is functionally equivalent to thepublic double m2(int a)
{
if (a != 0)
return 1.0;
else
return 2.5;
}
(a) Source Codepublic double m2(int);
0: iload_1
1: ifeq 6
4: dconst_1
5: dreturn
6: ldc2_w #double 2.5d
9: dreturn
(b) Original Java Bytecode
public double m2(int);
0: if-eqz v3, 5 // +5
2: const-wide/high16 v0, #long 4607182...
4: return-wide v0
5: const-wide/high16 v0, #long 4612811...
7: goto 4 // -3(c) Dalvik Bytecode
STARTEND0 if-eqz2 const-wide/high165 const-wide/high167 goto4 return-widefalsetrue
(d) Control Flow Graph
public double m2(int);
0: if-eqz (3, int, s), 5
2: const-wide/high16 (0, double, d) #double 1.0
4: return-wide (0, double, s)
5: const-wide/high16 (0, double, d) #double 2.5
7: goto 4
(e) Tyde Representation - s(resp.d) indicates a source (resp.
destination) register.
public double m2(int); 8: dload_2
0: iload_1 9: dreturn
1: ifeq 10 10: ldc2_w #double 2.5d
4: ldc2_w #double 1.0d 13: dstore_2
7: dstore_2 14: goto 8
(f) Retargeted Java Bytecode
Figure 3: Stages of Retargeting for Method m2
one in Figure 3(b), albeit longer. That is mostly due to the presence
of spurious store/load instructions. However, we are not concerned
with optimality but only with semantic equivalence. Tools such as
Soot [37] can optimize the resulting bytecode if necessary.
4. THE TYDE REPRESENTATION
The DVM recognizes 257 different instructions. A na√Øve ap-
proach to converting Dalvik bytecode to Java bytecode would be to
have 257 translation rules, which is very cumbersome. Moreover,
analyzing the equivalence of the semantics of the translation rules
would be very time consuming. The na√Øve approach would also
make the implementation error-prone and hard to maintain.
In this section we describe a typed IR called Tyde (for Typed
dex) whose main purpose is to enable easy translation of Dalvik
bytecode to Java bytecode. As described in Section 6, translating
the Tyde IR to Java bytecode is done with only 9 translation rules
for all 257 Dalvik opcodes. The corresponding semantic mapping
is much easier to analyze than 257 translation rules. Moreover, this
approach also leads to a cleaner and maintainable implementation.
The insight behind Tyde is that, by typing all instruction argu-
ments, load/store operations can be translated independently of op-
codes. For instance, let us consider instructions add-intv0,v1,
v2(integer addition) and add-float v3,v4,v5(Ô¨Çoat addition).
By typing all registers and specifying if they are source or desti-
nation, we can use a single translation rule for both instructions:
Ô¨Årst translate all source register loads, then translate the opcode
and Ô¨Ånally translate the destination register store. If we did not de-
termine the type information about the registers, retargeting those
instructions would require two different translation rules.
Another advantage of Tyde is that Dalvik pseudo-instructions
(such as packed-switch-payload ) are not used, which leadspublic double m3(int a) {
switch (a) { case 0: return 1.0;
case 1: return 2.5;
default: return 4.0; }}
(a) Source Code
public double m3(int);
0: packed-switch v3, 12 // +12
3: const-wide/high16 v0, #long 4616189...
5: return-wide v0
6: const-wide/high16 v0, #long 4607182...
8: goto 5 // -3
9: const-wide/high16 v0, #long 4612811...
11: goto 5 // -6
12: packed-switch-payload
entries: 2 - first key: 0 - targets: 6, 9
(b) Dalvik Bytecode
public double m3(int);
0: packed-switch (3, int, s)
first key: 0 - targets: 6, 9 - default: 3
3: const-wide/high16 (0, double, d), #double 4.0
5: return-wide (0, double, s)
6: const-wide/high16 (0, double, d), #double 1.0
8: goto 5 // -3
9: const-wide/high16 (0, double, d), #double 2.5
11: goto 5 // -6
(c) Tyde Representation
Figure 4: Method m3
‚ä§
‚ä•nullfloatdoublelongObjectbooleanarraysother refsbyteshortintchar
Figure 5: Tyde Type Lattice
to a more compact representation. Let us consider method m3,
whose source code is presented in Figure 4(a). Figure 4(b) shows
the corresponding Dalvik bytecode. It uses a packed-switch-
payload pseudo-instruction which contains data about the switch
statement at offset 0 (note that the default case is implicit). More-
over, in the Dalvik bytecode the registers used as arguments are not
typed. Figure 4(c) shows the Tyde IR for m3. In the Tyde represen-
tation, the packed-switch instruction has all the necessary data
(with an explicit default case) and no pseudo-instruction is used.
4.1 SpeciÔ¨Åcation
Figure 5 presents the type lattice used by the Tyde IR. All types
on this lattice are valid Java types. In Tyde, we introduce the notion
of typed registers. It adds two elements to Dalvik registers: a type 
and information about whether the register is a source or destination
register (represented by terminals sandd).
The notion of typed value is used for all source or destination
operands. Typed source values can either be typed source registers
or integer literals. Typed destination values are deÔ¨Åned as typed
destination registers, por2p.p(resp.2p) represents the case
where a single-word (resp. double-word) return value is ignored
after a method invocation. This is summarized in Figure 6, in which
is any type from the lattice in Figure 5.
Tyde only deÔ¨Ånes proper instructions, i.e., no pseudo-instructions
are used. Also, instead of constant pool indices and most inline nu-
meric literals, Tyde directly uses Java constants. Note that while
several constant types are used, we use a generic constant CforRegister Indices r::=0|1|2|. . .
Typed Source Registers s::= (r;;s)
Typed Dest. Registers d::= (r;;d)
Typed Registers ::=s|d
Integer Literals li::=0|1|2|. . .|-1|-2|. . .
Typed Source Values vs::=s|li
Typed Destination Values vd::=d|p|2p
Figure 6: Tyde Typed Registers and Values
Dalvik
Name Syntax Instructions
TuoOuo,[vd],fvsg,[C] 222
TaoOao,[vd],fvsg,[C] 12
TubOub,fsg2
0,ptrT 11
TabOab,fsg2
1,ptrT 4
TnoOno,d,s 2
TfnaOfna,d,fsg, 3
Tfad fill-array-data ,s,fCg 1
Tps packed-switch ,s,l,ptrT,fptrTg 1
Tss sparse-switch ,s,flgm,ptrT,fptrTgm 1
Table 1: SimpliÔ¨Åed Syntax of Tyde Instructions.
ease of exposition. Finally, Tyde does not use offsets to refer to
other instructions to represent branches. Instead, Tyde instructions
use pointers to other instructions, represented as ptrT.
Table 1 shows the syntax of Tyde instructions. There are 9 for-
mats, each of which is later translated to Java using a single rule
(see Section 6).fAgb
aindicates that symbol Ais repeated between
aandbtimes. We notefAga=fAga
aand[A] =fAg1
0. Finally,
fAgindicates that Ais repeated zero or more times.
Tuorepresents instructions which have zero or one typed des-
tination value vd, zero or more source values vs, and zero or one
Java constant C. Finally, their opcode has an unambiguous se-
mantic equivalent in the JVM. Examples include a vast majority of
unary and binary operators and method invocations. Taois almost
the same format: the only difference is that the corresponding Java
opcode is ambiguous. For example, return-wide is included
in that format because it can be used to return a long ( lreturn
in Java) or a double ( dreturn in Java). Opcode set Ouois par-
tially shown in the Ô¨Årst column of Table 3(a); the complete lists for
Ouoand other partially deÔ¨Åned sets are available in our technical
report [30]. SetOaois partially shown in Table 3(b) (Ô¨Årst column).
Tubrepresents branching instructions whose opcode have an un-
ambiguous semantically equivalent Java opcode. In addition to an
opcode, they are composed of zero, one or two typed source reg-
isterssand a pointer to a target Tyde instruction ptrT.Tabis
similar: the two differences are the number of source registers and
the fact that the corresponding Java opcode is ambiguous. Sets Oub
andOabare partially shown in Tables 4(a) and 4(b) (Ô¨Årst column).
Tnorepresents the not-int andnot-long unary operators
deÔ¨Åned in the DVM, which do not have a trivial semantically equiv-
alent opcode in the JVM. Set Onois {not-int ,not-long }.
Tfna instructions are the filled-new-array instructions.
They are used to create a new array and Ô¨Åll it with the contents
of registers. In addition to their opcode, they are composed of a
destination register d, an arbitrary number of sources registers s
and a type. SetOfnais {filled-new-array ,filled-
new-array/range ,filled-new-array/jumbo }.Tfad
instructions are fill-array-data instructions (presented in
Section 2). In addition to their opcode and a typed source regis-
ters, they have an arbitrary number of Java constants.
Tpsare the packed-switch instructions. They are composed
of apacked-switch opcode, a typed source register s, an inte-
ger literalli(switch lowest case value) and a strictly positive num-
ber of pointers to Tyde instructions ptrT(switch targets, including
the default case handler). Tssare the sparse-switch instruc-(1) .dex Parsing(2) CFG ConstructionInstruction Parsing
(3) Type InferencePseudo-Instruction InliningBasic CFG ConstructionExceptional Edges RemovalType Constraint GenerationType Constraint SolutionFigure 7: Tyde IR Construction Overview
tions. They are composed of a sparse-switch opcode, a typed
source register s,minteger literals li(switch case values) and
m+1pointers to Tyde instructions ptrT(switch targets, including
the default case handler), for some integer m.
Note that with this representation, not all instructions correspond
to valid instructions. For example, with an add-int instruction
inTuo, there would only be two source values, even though the
format accepts an arbitrary number of source values. The third
column of Table 1 indicates how many types of Dalvik instructions
are mapped to each Tyde instruction format.
5. FROM DALVIK BYTECODE TO TYDE
As depicted in Figure 7, Tyde IR is generated in three steps. The
Ô¨Årst step consists of parsing the .dex Ô¨Åle, which involves parsing
data related to classes and methods (e.g., access Ô¨Çags and names),
as well as Ô¨Åelds and method instructions. In the next step, a Control
Flow Graph (CFG) is constructed. In the Ô¨Ånal step, a type inferenc-
ing algorithm infers types of registers that are ambiguous.
Parsing - Since parsing class and method data and Ô¨Åelds is straight-
forward, we focus our description on instruction parsing. While
parsing instructions, type information for registers is determined.
For example, the types of several unary and binary operators can
be known from their opcode, e.g., an add-long instruction takes
two long integers as sources and a long integer as destination. Also,
during this parsing step, for every instruction which uses a constant
pool reference, a new Java constant is generated on the Ô¨Çy. The
only exception is when the instruction is an ambiguous numeric
constant assignment. In that case, type information is needed be-
fore the constant can be created. The parsing step also removes
pseudo-instructions. As mentioned before, Dalvik bytecode uses
pseudo-instructions to store complementary data about a proper in-
struction. In the parsing step, we simply store the contents of each
pseudo-instruction in the proper instruction which refers to it and
eliminate the pseudo-instruction.
5.1 Building a CFG
In the second step, we build a CFG from the Dalvik bytecode.
Techniques used for constructing CFGs are quite standard, so we
focus on details that are speciÔ¨Åc to our system. As required by the
Tyde IR, relative offsets in branching instructions are converted to
pointers. Also, exception tables are used to generate CFG edges.
When an instruction Iis protected by a try block, we add a CFG
edge from its predecessors to the appropriate exception handlers.
Standard CFG construction often also includes edges from Ito
exception handlers if Ihas side effects. This is done in order to
account for the case in which the side effects are committed be-
fore the exception is thrown. For our purposes, we do not include
these edges. They are not included by the Dalvik or Java veriÔ¨Åers:even though Imight commit side effects before throwing an excep-
tion, the type state will not be changed. This entire process is quite
straightforward, since all relative offsets are statically known.
5.1.1 Removing Unfeasible Exceptional CFG Edges
As we previously described, DVM and JVM veriÔ¨Åers differ in
the way they handle CFG edges related to exceptions: while the
Java veriÔ¨Åer considers that all instructions inside a try block may
throw an exception, the Dalvik veriÔ¨Åer only considers edges for in-
structions which might actually throw an exception. For our CFG
construction, we adopt the Dalvik approach. In order to gener-
ate veriÔ¨Åable Java bytecode, we also modify the exception tables
(which describe try/catch/finally blocks) to only include
instructions which might throw an exception in try blocks. We
now explain why these modiÔ¨Åcation do not modify the semantics
of the program.
The Java platform has two types of exceptions [21, ¬ß2.16]. Syn-
chronous exceptions occur as a result of the execution of a particu-
lar instruction. For example, if an integer division instruction has a
divisor with value 0, it will throw an ArithmeticException
when it is executed. On the other hand, asynchronous exceptions
can happen at any point in the execution of a method. Asynchronous
exceptions only have two possible causes. First, an asynchronous
exception can be thrown when the deprecated Thread.stop()
method is called (the thread on which it is called will immediately
throw an exception). The only other case where an asynchronous
exception can be thrown is when an internal error in the virtual
machine implementation occurs.
Removing CFG edges for instructions which cannot throw syn-
chronous exceptions does not violate synchronous exception han-
dling semantics; as we know which instructions can throw syn-
chronous exceptions, we just have to make sure to leave them in
theirtry blocks. Asynchronous exceptions may seem less trivial,
since they might in theory be thrown by any instruction. How-
ever, exceptions cannot be thrown asynchronously in the DVM (in
particular, Thread.stop() is not supported). That is the rea-
son why the Dalvik veriÔ¨Åer only considers synchronous exceptions
in its CFG construction. Therefore, removing CFG edges corre-
sponding to asynchronous exception handling does not modify the
semantics of the program.
5.2 Type Inference
The problem we are trying to solve is the following: given a
method with typing following the lattice on Figure 1, Ô¨Ånd a typing
which is valid with respect to the lattice on Figure 5.
We defer formal proofs to future work, but the type inference al-
gorithm we present below was able to Ô¨Ånd a valid Java typing for
all 1.6 million retargeted methods from our sample. There are sev-
eral reasons why our algorithm works well in practice. The type
system enforced by the Dalvik veriÔ¨Åer is quite similar to the type
system enforced by the Java veriÔ¨Åer. For example, consider a reg-
ister assignment which might be for a Ô¨Çoat or an int. If it is used as
a Ô¨Çoat, it cannot be subsequently used as an int on the same branch.
However, the Dalvik veriÔ¨Åer does not back-propagate unambigu-
ous use type information to ambiguous assignments. Therefore, if
an ambiguous assignment (e.g., 32-bit constant) reaches two uses
with incompatible types through two different branches (e.g., int
on one branch and Ô¨Çoat on another branch), the code could still
be Dalvik-veriÔ¨Åable even though it does not have a valid Java typ-
ing. However, we did not Ô¨Ånd any occurrence of this, most likely
because Dalvik code is compiled from Java code and the analy-
sis required to merge registers with different types but identical bit
patterns would be costly and provide very minimal gain.Type inference for Dalvik bytecode uses the following approach:
First we generate constraints on types based on deÔ¨Ånitions and uses.
These constraints are then solved to infer unknown types. Note that
our goal is not to determine types for all variables, unlike previous
work [5]. In particular, with the exception of array types we do not
need to know precise types for references.
In this section, c(vi;Ij)andv(vi;Ij)denotes the type of reg-
isterviat instruction Ij. We usecto denote a type constant and
vto denote a type variable.
5.2.1 Constraint Generation
Constraints are generated by traversing the CFG starting at am-
biguous register deÔ¨Ånitions (respectively uses), looking for uses
(respectively assignments) of the same register. For example, let
us consider method m2, deÔ¨Åned in Figure 3. Its CFG is shown
in Figure 3(d). Method m2generates the following constraints:
v(v0;I2)double,v(v0;I5)double, and intv(v3;I0). It
has two ambiguous deÔ¨Ånitions (the two const-wide/high16
instructions) and one ambiguous use (the if-eqz instruction).
The Ô¨Årst two constraints are generated because ambiguous deÔ¨Åni-
tions reach instruction return-wide , whose type is known from
the method signature. The last constraint (on instruction I0) is
given by the method signature, according to which register v3is
assigned an integer argument before method execution starts.
The constraints related to variable deÔ¨Ånitions and uses induce
inequality constraints. Instructions dealing with arrays introduce
another kind of constraint on their operands. For example, con-
sider instruction agetv0;v1;v2, which loads element at index v2
from the array referenced by v1intov0. If it is determined that the
array referenced by v1is an array of integers, then v0is an integer.
Eventually, we obtain four types of constraints: type (1) cv,
type (2)vc, type (3)v1v2and type (4) v1= [v2
(where [v2means ‚Äúarray of v2‚Äù).
5.2.2 Constraint Solution
Solving these constraints is performed in three phases. Through-
out these three phases, whenever a type variable involved in a type
(4) constraint is determined, the other side of the type (4) equality
is also determined (or checked if it is already known).
Phase 1 - First, we use Algorithm D by Rehof and Mogensen [36]
to Ô¨Ånd the least solution to type (1) and (3) constraints. The Rehof-
Mogensen (RM) algorithm Ô¨Ånds the least solution . The RM-
algorithm also checks that the solution satisÔ¨Åes type (2) con-
straints. For the constraint system shown earlier, the RM-algorithm
Ô¨Ånds the solution v(v3;I0) = int. However, we still need to Ô¨Ånd
values forv(v0;I2)andv(v0;I5), which is handled in phase 2.
Phase 2 - After Ô¨Ånishing phase 1, there are variables whose type
is?(unknown). We need to infer the types of these variables. In
our example, after phase 1 v(v0;I2)andv(v0;I5)are?. Phase
2 Ô¨Ånds the types of these variables. Assume that type variable
vhas value?after phase 1, but has the following constraints
of type (2): vc1;vc2;;vck. Then we set
v=c1^c2^^ck(that is, the greatest common subtype
ofc1;c2;;ck). This ensures that all type (2) inequalities in-
volvingvare satisÔ¨Åed. For our example, this yields the following
types:v(v0;I2) = double andv(v0;I5) = double. In general,
this process may determine the type of the left-hand side of some
type (3) inequalities. In order to solve these constraints properly,
we run the algorithm by Rehof and Mogensen again.
Phase 3 - After phase 1 and 2 there are some types that are still
undetermined (e.g., ambiguous assignment reaching only an am-
biguous use, which is not itself reached by any unambiguous as-
signment). In that case, we set these types to safe default types. InTyped Value Java Instruction
li sipushli
(r;i;s) iloadm(r)
(r;Ô¨Çoat;s)Ô¨Çoadm(r)
(r;long;s)lloadm(r)
(r;double;s)dloadm(r)
(r;r;s) aloadm(r)Typed Value Java Instruction
p pop
2p pop2
(r;i;d) istorem(r)
(r;Ô¨Çoat;d)fstorem(r)
(r;long;d)lstorem(r)
(r;double;d)dstorem(r)
(r;r;d) astorem(r)
Table 2: Opcode Map fdsfor Typed Values.
Section 2, we explained that all instructions with ambiguous typing
have a limited set of types that they can possibly take. For exam-
ple, a const-wide instruction can only take types long or double.
After this, all variable types are safe Java types.
6. GENERATING JA V A BYTECODE
A Dalvik code in Tyde IR is translated into Java bytecode in three
steps. In the Ô¨Årst step, registers are mapped to Java local variables
and labels are generated to support control-Ô¨Çow instructions. In
the second step, instructions in Tyde IR are converted to Jasmin
instructions (Jasmin is a Java bytecode assembler). The third step is
to use Jasmin to generate Java .class bytecode. We will provide
a brief description of the Ô¨Årst two steps.
6.1 First Step (Pre-Processing)
Register Mapping - Tyde is a register-based representation, there-
fore we need to map every register to a Java local variable. A regis-
ter mapmis a function that maps a Tyde IR register to a Java local
variable. In the JVM, the Ô¨Årst local variable indices are reserved for
thethis reference (for non-static methods) and the method argu-
ments [21, ¬ß3.6.1]. In the DVM, these variables use the last register
indices, so our register map has to respect this constraint.
Label Generation - In Java bytecode, branching instructions in-
clude relative offsets to their targets. Also, exceptions tables de-
scribe the boundaries of try/catch/finally blocks using ab-
solute offsets. However, Jasmin uses labels for these, which is why
we need to generate labels before we can generate Jasmin code.
We deÔ¨Ånebsuch that, for any pointer ptrTto a Tyde instruction,
b(ptrT)is the label of the instruction corresponding to ptrT.
6.2 Second Step (Translating Instructions)
In order to map a Tyde method to a Java method, we introduce
helper functions. The general idea is that each Tyde instruction for-
mat is mapped to Java instructions using a single pattern. In this
section, we use the symbol Jto represent the ‚Äúnull‚Äù Java instruc-
tion (which in case of Jasmin is the empty string).
Typed Values - In Table 2, we deÔ¨Åne a function fdswhich maps
typed values to Java instructions. For this deÔ¨Ånition, we use the
register map m.iis any single-word integer type (boolean, char,
byte, short or int) and ris any reference (array or non-array) type.
Essentiallyfds(v)corresponds to the Java instruction to load or
store the Tyde typed value v. These Java instructions can be di-
vided into two categories: a)pushing values onto the operand stack
before an operation is applied to them ( load instructions), and b)
popping values resulting from an operation from the stack, either
to store them in a local variable ( store instructions) or to balance
the stack if a method‚Äôs return value is discarded ( pop instructions).
Since these values are typed and their register use (source or desti-
nation) is known, they can be translated independently from other
parts of the Tyde instruction, i.e., knowing the Dalvik opcode is not
necessary. One of the advantages of having types on sources and
destinations in Tyde is that Java instructions to load/store/pop typed
values can be generated independently of the instruction opcode.Tyde Opcode Java Opcode
nop nop
moveJ
const-wide/16 ldc2_w
monitor-exit monitorexit
(a)fuo(partial deÔ¨Ånition)Tyde Op. Tyde Type Java Op.
returni ireturn
Ô¨Çoat freturn
const/4,i, Ô¨Çoat ldc
constr aconst_null
(b)fao(partial deÔ¨Ånition)
Table 3: Opcode Maps fuoandfaofor SetsOuoandOao.
Tyde Op. Java Op.
goto goto
if-lt if-icmplt
if-ge if-icmpge
if-ltz iÔ¨Çt
(a)fub(partial deÔ¨Ånition)Tyde Op. Tyde Type Java Op.
if-eqi if_icmpeq
r if_acmpeq
if-nei if_icmpne
r if_acmpne
(a)fab(partial deÔ¨Ånition)
Table 4: Opcode Maps fubandfabfor SetsOubandOab.
Constants - We usefCto represent the translation of a constant
pool reference. If we were generating binary bytecode, it would
simply be the index of the constant in the constant pool. Since we
generate instructions for Jasmin, it is a textual description of the
constant (e.g., value for an integer constant). If there is no constant,
fCsimply returns an empty string.
Opcodes - In general, unambiguous opcodes in Tyde IR have a cor-
responding opcode in Jasmin. For ambiguous opcodes, the types of
the operands in Tyde IR are used to determine the corresponding
opcode in Jasmin. In Table 3(a), we deÔ¨Åne a function fuowhich
maps unambiguous Tyde operators to semantically equivalent Java
opcodes. A vast majority of Dalvik opcodes (222 out of 257) are in
this classOuo. Their semantic mapping to a Java opcode is trivial
and the equivalent Java opcode can be known by only knowing the
Dalvik opcode. Table 3 only shows a subset of the mappings. The
complete deÔ¨Ånition is available in the technical report [30], along
with complete deÔ¨Ånitions of other partially deÔ¨Åned functions. In
Table 3(b), we deÔ¨Åne a function faowhich maps ambiguous op-
codes and Tyde types to Java opcodes. pis any primitive type,
i.e.i, Ô¨Çoat, long or double. In these cases, one Dalvik opcode
maps to several Java opcodes and thus an argument type is needed
to disambiguate the mapping.
In Table 4(a), we deÔ¨Åne a function fubwhich maps unambigu-
ous branching opcodes to semantically equivalent Java opcodes.
As withfuo, this mapping is trivial and the equivalent Java op-
code is completely determined by the Dalvik opcode. Table 4(b)
deÔ¨Ånes a function fabwhich maps ambiguous branching opcodes
and Tyde types to Java opcodes. As with Oao, one Dalvik opcode
maps to several Java opcodes and an argument type is needed to
disambiguate the mapping.
Instructions - Using the register map mand the various functions
deÔ¨Åned earlier, we can describe the translation for each of the Tyde
instruction classes shown earlier. This translation is shown in Ta-
ble 5. In addition to the functions deÔ¨Åned earlier, our translation
also uses function fxastore for mapping store instructions deÔ¨Åned
in Table 6. Due to space restrictions, we will only describe transla-
tion rules for a few interesting Tyde instructions.
not InstructionsTno- The Dalvik and Tyde instruction sets in-
clude not instructions for integers. While there is no trivial se-
mantic equivalent in the Java instruction set, we can use a combi-
nation of Java instructions and take advantage of the equivalence
of bitwise binary operators. Given an integer i, we deÔ¨Åne 1jijthe
integer whose bit pattern is all ones with the same width as i(32
or 64 bits). If the NOT (resp. XOR) bitwise operator is repre-
sented as:(resp.), then we have:i= 1jiji. Therefore, a
valid Java instruction pattern consists in pushing constant 1jijonto
the stack (with ldc orldc2_w depending on integer width). Af-Tyde Type Java Opcode
[boolean, [byte bastore
[char castore
[short sastore
[int iastore
[Ô¨Çoat fastore
[r aastore
Table 6: Map fxastore .
ter pushingionto the stack, the ixor (orlxor ) opcode should
be applied. Finally, the result should be popped from the stack.
This pattern deÔ¨Ånes map jnoin Table 5. For this function, we use
functionfnodeÔ¨Åned overOnosuch thatfno(not-int ) =ixor
andfno(not-long ) = lxor . We also deÔ¨Ånejonoj= 32 if
ono=not-int andjonoj= 64 ifono=not-long .
filled-new-array InstructionsTfna- Dalvik and Tyde byte-
code have instructions which create a new array and Ô¨Åll it with the
contents of registers given as arguments. While Java does not have
a direct equivalent, a semantically equivalent sequence of Java in-
structions is as follows. First, a newarray (primitive type) or
anewarray (reference type) instruction will create a new array
with the appropriate type and return a reference to the array on
the stack. To Ô¨Åll the array with the proper values, we use a se-
quence of the following pattern: i)adup instruction duplicates
the array reference on the stack, then ii)the proper array index
l2Liis pushed onto the stack, next iii)the array element value
is pushed onto the stack, then d)an appropriate xastore instruc-
tion pops the duplicated reference, the index and the element and
performs the array storage. Finally, an astore instruction stores
the array reference to a local variable. This patterns deÔ¨Ånes map
jfnain Table 5. For this function, we use function ffnasuch that
ffna(p) =newarray andffna(r) =anewarray .
packed-switch InstructionsTps- The semantic equivalent of
a Tyde packed-switch instruction is a Jasmin tableswitch
instruction. The arguments of a Tyde packed-switch are a
typed source register (integer used to switch), a literal correspond-
ing to the lowest case value, a pointer to the default case handler
and a set of pointers to case handlers. The corresponding Jasmin
instruction is similar, except that it uses labels instead of pointers.
Example - Let us consider method m2introduced in Figure 3(a).
Figure 3(e) shows its Tyde representation. For ease of exposition,
we assume that the label of each instruction is simply its original
offset and the register mapping mis such thatm(0) = 2 ,m(1) =
3,m(2) = 0 andm(3) = 1 . The Ô¨Årst Tyde instruction has format
Tab(see Table 5). Using the notation from Table 5, oabisif-eqz ,
0
s= (3;int;s),1
sis empty and ptrTis a pointer to instruction
at offset 5.fds(3;int;s) =iloadm(3) = iload 1is the Ô¨Årst
Java instruction. Then we have fds(1
s) =J,fab(oab;int) =
ifeq andb(ptrT) = 5 (note that the 5 value is just a label and not
the offset in the Ô¨Ånal Java bytecode). The second Java instruction
isifeq , label 5. The remaining Tyde instructions are translated in
a similar manner to obtain the bytecode shown on Figure 3(f).
7. UNVERIFIABLE DALVIK BYTECODE
In the previous sections, we have described how to generate ver-
iÔ¨Åable Java bytecode from veriÔ¨Åable Dalvik bytecode. As we ex-
plore below, some bytecode from real-world applications is not
Dalvik-veriÔ¨Åable. In this section, we show the errors we encoun-
tered with real bytecode. We also show how we modiÔ¨Åed our re-
targeting process to handle bytecode that is not Dalvik-veriÔ¨Åable in
order to generate veriÔ¨Åable Java bytecode.Tyde Tyde Equivalent Java
Instruction Set Instruction Instructions
Tuo tuo= (ouo;vd;v0
s;v1
s;;vk
s;C) juo(tuo) =fds(v0
s)jjfds(v1
s)jjjjfds(vk
s)jj(fuo(ouo);fC(C))jjfds(vd)
Tao tao= (oao;vd;v0
s;v1
s;;vk
s;C) jao(tao) =fds(v0
s)jjfds(v1
s)jjjjfds(vk
s)jj(fao(oao;);fC(C))jjfds(vd)
Tub tub= (oub;0
s;1
s;ptrT) jub(tub) =fds(0
s)jjfds(1
s)jj(fub(oub);b(ptrT))
Tab tab= (oab;0
s;1
s;ptrT) jab(tab) =fds(0
s)jjfds(1
s)jj(fab(oab;);b(ptrT))
Tno tno= (ono;d;s) jno(tno) = ( ldc/ldc2_w;fC(1jonoj))jjfds(s)jjfno(ono)jjfds(d)
Tfna tfna= (ofna;d;0
s;1
s;;;k
s;)jfna(tfna) = (ffna();)jjdupjjfds(0)jjfds(0
s)jjfxastore ()jjdupjjfds(1)
jjfds(1
s)jjfxastore ()jjjj dupjjfds(k)jjfds(k
s)jjfxastore ()jjfds(d)
Tfad tfad= (Ô¨Åll-array-data ;s;C0;C1;;Ck)jfad(tfad) =fds(s)jjfds(0)jj(ldc/ldc2_w;fC(C0))jjfxastore ((s))
jjfds(s)jjfds(1)jj(ldc/ldc2_w;fC(C1))jjfxastore ((s))jjjjfds(s)
jjfds(k)jj(ldc/ldc2_w;fC(Ck))jjfxastore ((s))
Tps tps= (packed-switch ;s;l;ptrdefault
T;ptr0
T;
ptr1
T;;ptrk
T)jps(tps) = fds(s)jj(tableswitch;l;b(ptrdefault
T);b(ptr0
T);
b(ptr1
T);;b(ptrk
T))
Tss tss = ( sparse-switch ;s;l1;l2;;lk;
ptrdefault
T;ptr1
T;ptr2
T;;ptrk
T)jss(tss) = fds(s)jj(lookupswitch ;b(ptrdefault
T);l1;b(ptr1
T);
l2;b(ptr2
T);;lk;b(ptrk
T))
Table 5: Tyde Maps.
7.1 Observed Errors
Improper references - The main source of unveriÔ¨Åable bytecode
is the presence of bad method, Ô¨Åeld, interface or class references.
Two different cases were encountered:
References to classes which are not available within the appli-
cation or in the core Android classes. A special case is when
the superclass of a class is missing; then the class is trivially
unveriÔ¨Åable and is not even linked by the DVM.
References to methods or Ô¨Åelds which are non-existent or not
accessible (e.g., private member).
There are two reasons for these missing references. The Ô¨Årst
reason is that applications commonly use private Android APIs.
The Android platform includes public APIs which are documented
and always backward compatible (an application using only pub-
lic APIs will still work after an OS update). Android also includes
private APIs which are meant for internal use by OS components.
Unlike public APIs, private ones are not ofÔ¨Åcially documented and
backward compatibility is not guaranteed. Using them is strongly
discouraged, as a simple OS update may break an application mak-
ing calls to private APIs. In our experiments, we checked veriÔ¨Å-
ability using recent Android core classes whereas the application
sample was about a year older. Doing so allowed us to point out
potential problems applications could have after an OS update.
The second reason is that, as we pointed out in previous work [9],
developers often include entire libraries to be able to use some
classes from these libraries. Parts of the included libraries some-
times make calls to other libraries, which are not themselves in-
cluded with the Android application. In practice, it is not an issue,
as long as these parts of the included library are not used anywhere
in the application. However, the unused part of the library code
making these calls will not be veriÔ¨Åable.
Typing and other issues - The second source of unveriÔ¨Åability for
Dalvik bytecode is the presence of invalid typing. Other issues are
a marginal cause of veriÔ¨Åcation problems. These can have a very
wide variety of causes (e.g., malformed class or member identiÔ¨Åer,
illegal access Ô¨Çag, etc.). More analysis is needed to understand how
these problems can make their way to released Dalvik bytecode.
7.2 Handling UnveriÔ¨Åable Dalvik Bytecode
In this section, we describe our approach to handle unveriÔ¨Åable
Dalvik bytecode in an application using Dalvik pre-veriÔ¨Åcation.
First, we verify the application using the Dalvik veriÔ¨Åer which is
part of the Android OS. We modiÔ¨Åed it in order to make it generate
a detailed report describing all veriÔ¨Åability issues with the applica-
tion. For each problem in the application, the report describes theclass name, the method name and signature, the problematic code
offset and the type of veriÔ¨Åcation error.
Then, the report is input into Dare with the application package.
TheDare parsing step (see Section 5) is modiÔ¨Åed as follows:
1. If the entire class could not be linked by the veriÔ¨Åer (e.g., be-
cause its superclass is missing), then skip the entire class. None
of the code of the class will be retargeted. At runtime, the class
would also be missing, so not retargeting it does not change the
semantics of the program.
2. If a method is entirely unveriÔ¨Åable because of a serious issue
(e.g., typing issue), then the parsing step replaces the method
with code that throws a VerifyError . All other veriÔ¨Åable
methods in the class will be retargeted without modiÔ¨Åcation.
3. If a method is unveriÔ¨Åable because of a less serious issue (e.g.,
missing class reference), then only replace the faulty code lo-
cation with code that throws an appropriate error (for example,
NoClassDefFoundError ). That is exactly the behavior of
the Dalvik VM at runtime: the faulty code locations are also
rewritten during the veriÔ¨Åcation process. An interesting case is
when we encounter a reference to a class that was ignored in
Step 1. The reference is then replaced with code throwing a
NoClassDefFoundError , which is the runtime behavior.
These code transformations serve two important purposes:
They mirror the runtime behavior of the program and therefore
do not cause any loss of semantics.
They make the entire program Dalvik-veriÔ¨Åable.
In order to account for some subtle differences between the Java
and Dalvik veriÔ¨Åers, we also had to consider two cases where a
method was Dalvik-veriÔ¨Åable but it was not Java-veriÔ¨Åable after
retargeting. The Ô¨Årst difference involves aget-object instruc-
tions, which are used to access a component in an array of refer-
ences. If it is used with an array reference which is known to always
be null at veriÔ¨Åcation time, then the veriÔ¨Åer sets the array compo-
nent to be null as well. But as we described above, in Dalvik, null
and int/Ô¨Çoat with value 0 are the same type. Thus, if the register
is subsequently used as an int or a Ô¨Çoat, the code will be Dalvik-
veriÔ¨Åable, but no valid Java typing will exist for it. In order to Ô¨Åx
this, we replace the aget-object instruction with code throwing
aNullPointerException . This mirrors the runtime behavior
of the program and also allows us to Ô¨Ånd a Java typing (since the
null register will no longer be used as an int or a Ô¨Çoat).
Second, when a Ô¨Åeld with reference type is accessed in the Dalvik
architecture, the method accessing it can still be veriÔ¨Åable even if
the Ô¨Åeld type cannot be resolved (the type of the register storing
the Ô¨Åeld is set to java.lang.Object ). The method is veriÔ¨Å-
able only if the register is subsequently used in trivial ways. OnBad Ref. Missing Ref. Typing Issue Other Issue
Apps 93 168 73 13
Code Locations 1,335 6,413 488 54
Table 7: VeriÔ¨Åcation results for partially veriÔ¨Åable classes
the other hand, the Java veriÔ¨Åer will reject a method if a Ô¨Åeld refer-
ence type cannot be resolved. In order to make the retargeted code
veriÔ¨Åable, we had Dare automatically generate class stubs for the
unresolvable Ô¨Åeld types. Since those Ô¨Åelds are only used in trivial
ways, these stub classes do not need to contain any Ô¨Åeld or method.
8. EV ALUATION
8.1 Dalvik Bytecode VeriÔ¨Åcation
In this section, we describe the Dalvik veriÔ¨Åcation issues we
found in a sample of 1,100 applications. We use the 50 most pop-
ular applications in the 22 application categories as of September
1, 20102. The 1,100 applications contained 262,110 classes. We
used the Dalvik veriÔ¨Åer and the core Android classes included in
Android version 4.0.3.0.2.0.1.0.
A surprising result of our Dalvik veriÔ¨Åcation experiments is that
247 applications contained unveriÔ¨Åable code. 181 applications con-
tained at least one class which could not be linked by the Dalvik
VM (e.g., because of a missing superclass), totalling 905 trivially
unveriÔ¨Åable classes. 214 applications had at least one unveriÔ¨Åable
code location in non-trivially unveriÔ¨Åable classes. Table 7 presents
the results of the Dalvik veriÔ¨Åcation process for the classes which
were not completely Dalvik-unveriÔ¨Åable. For each issue, we show
the number of faulty code locations and the number of applications
with at least one bad location. Occasionally, several locations in a
single method can be unveriÔ¨Åable.
The Ô¨Årst column shows the number of bad references, i.e. refer-
ences to an inaccessible (e.g., private) or nonexistent class member.
It is unlikely for an application to make a bad reference to its own
code, so these are most likely references to private Android APIs
which were modiÔ¨Åed after the application was developed. The sec-
ond column shows the number of references to a missing class.
These are caused by unlinkable application classes and by (sup-
posedly unused) code in included libraries making references to
other libraries which are not included with the application. Finally,
we show the number of typing and other issues, which account for
6.46% of all unveriÔ¨Åable code.
8.2 Retargeting
The empirical evaluation described in this section attempts to an-
swer two central questions: 1) are the computational costs of retar-
geting feasible in practice? and 2) can Dare successfully retarget
market applications? The answers to these questions will deter-
mine the degree to which this is a useful tool for extracting code
for further analysis. Highlights of the study include:
After some additional code optimizations in some isolated cases,
the output of Dare is veriÔ¨Åable for all methods for 99.64% of
the applications in the corpus, and over 99.999% of methods
overall. This is a substantial increase over existing tools.
Dare can, on average, retarget each class in 4.20 msec, and
was able to retarget the entire corpus of 1,100 applications con-
taining over 260,000 classes in less than 20 min.
The complete processing of all applications including Dalvik
pre-veriÔ¨Åcation (modiÔ¨Åed Dalvik veriÔ¨Åer), retargeting ( Dare )
and assembly (Jasmin) took less than 70 compute-minutes.
We compare Dare against dex2jar [1], the most popular tool
for retargeting Dalvik bytecode to Java. We do not report bytecode
2Experiments run on a smaller sample from March 2012 show
near-identical results.Removed ModiÔ¨Åed Unverif. Unverif. VeriÔ¨Åable
Total Code Code Classes Code Code (%)
Apps 1,100 181 214 7 3 99.09%
Classes 262,110 905 3,354 14 4 99.99%
Methods 1,620,813 9,658 6,858 100 4 99.99%
Table 8: Dare retargeting success rates
veriÔ¨Åcation results for our previous tool: ded [29, 31] was built for
the purpose of decompilation and did not include all information
that is required for a veriÔ¨Åable class Ô¨Åle, for example the maximum
stack size for each method (which was set to a default value of
0). As a consequence, while the output of ded can typically be
processed by decompilers and accurately captures the semantics of
the original program, it is generally trivially unveriÔ¨Åable.
We evaluate Dare on two keys metrics: performance and retar-
geting success rate. We retargeted the entire corpus of applications
described in the previous section.We used the latest version of Jas-
min (2.4.0) for Java bytecode assembly.
Performance - The total processing time was 4,198 seconds, with
Dalvik pre-veriÔ¨Åcation consuming 229 seconds (5.45%), Dare 1,101
seconds (26.23%) and Jasmin 2,868 seconds (68.32%). Dare pro-
cessing was dominated by the Ô¨Åle output operations. They are per-
formed at the same time as the translation of Tyde to Jasmin. To-
gether they take 85% of the total processing time. The type infer-
ence algorithm accounts for 5% of the total processing time. Other
parts of the retargeting process take less than 5% each. Retargeting
is efÔ¨Åcient and can be a fast Ô¨Årst step before application analysis.
Retargeting - The success metrics reported below measure the
ability of Dare to generate valid bytecode. A method is said to
be successfully retargeted when Dare generates bytecode that is
veriÔ¨Åable (and thereafter is ready for inspection and analysis by
existing tools). A class is said to be successfully retargeted if all
the methods it contains are successfully retargeted. Finally, an ap-
plication is said to be successfully retargeted if all classes within
the application are retargeted. For the Java bytecode veriÔ¨Åcation
experiments, we used the Oracle Labs Maxine VM veriÔ¨Åer [33].
Table 8 shows the resuts of the Dare retargeting. The Ô¨Årst col-
umn shows the total number of classes and non-abstract methods
in our sample. The second column shows how many classes were
safely removed using the Dalvik veriÔ¨Åcation reports as described
in Section 7 (the application count is the number of apps in which
at least one class was removed). The next column presents the
number of classes and methods which were modiÔ¨Åed following the
Dalvik veriÔ¨Åcation reports. The next column shows the number of
retargeted classes which were completely unveriÔ¨Åable (the appli-
cation count is the number of apps in which at least one class was
completely unveriÔ¨Åable). For each of these classes, the issue was
caused by a single method which had a code size over the maxi-
mum allowed size of 65536 bytes. We were able to Ô¨Åx 13 of these
14 issues by running the Soot optimizations on these classes. Only
one of these 14 failures could not be Ô¨Åxed: the bytecode optimiza-
tions did not sufÔ¨Åciently reduce the code size. After optimization,
only one of the 100 methods was not veriÔ¨Åable.
The next column shows the number of methods which had an
issue that did not cause Maxine to reject the entire class but only
a single method. One of these failures was caused by a reference
to one of the classes which was not veriÔ¨Åable because of code size,
as described above. It was Ô¨Åxed after the code optimizations re-
duced the code size and made the referenced class veriÔ¨Åable. The
other 3 failures were related to a pathological difference between
the Dalvik and Java veriÔ¨Åers. In the case of Java, when a method
in a class Ctries to access a protected method from a superclass
Dwhich is in a different package, it can only do so if the instance
on which the method invocation occurs is an instance of a subclassCompletely Unverif. VeriÔ¨Åable
Total Unverif. Classes Code Code (%)
Apps 1,100 422 206 59.64%
Classes 262,110 1,405 776 99.17%
Methods 1,620,813 25,972 1272 98.32%
Table 9: dex2jar retargeting success rates
ofC. The Dalvik veriÔ¨Åer, however, does not enforce this rule and
only checks that Cis a subclass of D. As a consequence, the Dalvik
veriÔ¨Åcation step accepted the 3 methods, which were subsequently
rejected by the Java veriÔ¨Åer after retargeting. Since a Java compiler
would not generate code with this issue, the issue is most likely due
to a private API method which was public when the applications
were created and was later changed to be protected (all 3 failures
occurred in a wrapper for the same Android API class and involve
a call to the same protected method).
The Ô¨Ånal column shows the overall success rates as a percentage
of the retargeted code. While we do not implement a solution for
the 4 failures which did not have a trivial Ô¨Åx, we do not consider
them to be signiÔ¨Åcant. They only represent less than 0.00025% of
the methods in our sample. Moreover, we were able to check that
the issues with the code in these 4 methods do not necessarily pre-
vent them from being processed by analysis tools: all 4 were suc-
cessfully optimized by Soot. Typing problems, on the other hand,
would prevent any serious analysis. No type issue was found by the
Java veriÔ¨Åer, which strongly validates our type inference algorithm.
Table 9 shows the retargeting results using the latest version
ofdex2jar (0.0.9.8), currently the most widely used retargeting
tool. There are two main reasons why dex2jar performs less well
at the retargeting experiments than Dare . First, it does not handle
unveriÔ¨Åable Dalvik bytecode: the result of retargeting unveriÔ¨Åable
Dalvik bytecode is unveriÔ¨Åable Java bytecode. The second reason
is that, similarly to ded,dex2jar aims to be used for decompi-
lation and typically decompilers can decompile unveriÔ¨Åable code
if the cause for unveriÔ¨Åability is not too serious. VeriÔ¨Åability is
a stronger criterion for success and ensures that the application is
processed by analysis tools (and not only decompilers). In the case
ofdex2jar , a number of classes are completely unveriÔ¨Åable for
trivial reasons (e.g., illegal member access Ô¨Çags). In addition, sev-
eral methods are unveriÔ¨Åable for various reasons ranging from bad
references to illegal typing. As a result, even though the class and
method retargeting success rates are high (respectively over 99%
and over 98%), less than 60% of applications are completely veri-
Ô¨Åable. It is a serious obstacle to whole-program analysis.
9. RELATED WORK
Java decompilers have been around for almost as long as the lan-
guage itself. Krakatoa [34] was introduced in 1997 and Mocha [38]
shortly thereafter. These earlier tools failed on a number of com-
mon bytecode structures. Dava [25, 24, 28] signiÔ¨Åcantly improved
the state of the art in Java decompilation in 2001. Dava is built upon
the Soot framework [37]. Other tools such as Jad [2] and JD [7] are
available but their algorithms are not published. Decompilation of
other languages such as C/C++ [6] differs vastly from the chal-
lenges that we face in Dare , in that the residual information in the
executable code is substantially lower than DVM or JVM bytecode.
Retargeting Dalvik bytecode is closely related to the Java de-
compilation. In both cases variable types need to be inferred from
bytecode and the instructions interpreted and translated into the tar-
geted language (in this case Java bytecode). A major difference
is that decompiling Java bytecode requires recovering control Ô¨Çow
statements from bytecode. In the case of Dava, this is done by mak-
ing transformations to the abstract syntax tree of individual meth-
ods. An alternate approach recognizes bytecode patterns generatedby known compilers. However, Dare avoids these complexities by
mirroring the original Dalvik control Ô¨Çow statements directly.
Type inference in Java has been widely studied [10, 19, 5]. Con-
ceptually, these systems generate and solve constraints on types. A
solution for the constraints is found using a variety of algorithms:
graph heuristics [10], solving assignment constraints before use
constraints [5] or introducing new types [19]. These approaches
achieve different guarantees, e.g., optimal typing [5] or polynomial
time solution [10]. Our algorithm is similar to the Ô¨Årst steps of
the one in [19], in the sense that we generate constraints and then
useallof them to Ô¨Ånd a typing. A fundamental difference between
these algorithms and ours is that we only infer a subset of all types.
In particular, we do not seek to determine all reference types. This
makes our problem simpler, as we do not have to deal with some of
the more complex issues the other algorithms solve, such as typing
in the presence of multiple interface inheritance. For instance, the
subtype completion of [19] or the variable splitting of [10] are not
necessary in our case. The constraint-solving algorithm we use for
type inference has been used by other authors [27, 16].
The idea of having a rich intermediate language (with types or
semantics) is not new. For example, Lim and Reps [20] developed
a language called TSL for describing the semantics of an instruc-
tion set, along with a run-time system to support the static analysis
of executables written in that instruction set. A language similar to
TSL called-RTL was developed by Ramsey and Davidson [35].
Typed Assembly Language (TAL) extends traditional untyped as-
sembly languages with typing annotations, memory management
primitives, and a sound set of typing rules. These typing rules
guarantee the memory safety, control Ô¨Çow safety, and type safety
of TAL programs [26]. The goal of the Tyde IR was to support
compact retargetting rules, and so the types in Tyde IR are geared
towards reducing the number of translation rules.
10. CONCLUSION
We have presented algorithms to retarget Android applications
to Java bytecode. The retargeting is done in two steps. First, the
Dalvik application package is converted to the Tyde intermediate
representation. The Tyde IR is then translated to Java bytecode and
structured into discrete class Ô¨Åles. The associated Dare tool em-
ploys strong type inference algorithms and translates the complex
Tyde IR to Java bytecode using only nine translation rules. Further,
Dare can output veriÔ¨Åable Java bytecode even when the input is
Dalvik-unveriÔ¨Åable.
Dare represents a substantial step forward in the quality retar-
geting of Android applications. We evaluated Dare against the
state of the art Dalvik retargeting tools over a corpus of 1,100 ap-
plications. These experiments show that Dare retargeted over 99%
of these applications ‚Äì a 40% increase over the next best tool. By
recovering application class Ô¨Åles, Dare enables the use of existing
Java frameworks and tools for Android application analysis, and
enables future studies of smartphone applications.
11. ACKNOWLEDGEMENTS
We would like to thank Matt Fredrikson, Stephen McLaughlin
and Dinghao Wu for editorial comments during the writing of this
paper. We also thank Drew Davidson for editorial comments and
for testing the released version of Dare. This material is based
upon work supported by the National Science Foundation Grants
No. CNS-0905447, CNS-1064944 and CNS-0643907. Any opin-
ions, Ô¨Åndings, and conclusions or recommendations expressed in
this material are those of the authors and do not necessarily reÔ¨Çect
the views of the National Science Foundation.12. REFERENCES
[1] dex2jar. https://code.google.com/p/dex2jar/ .
[2] Jad java decompiler download mirror.
http://http://www.varaneckas.com/jad .
[3] Android apps on the Android market, March 15, 2012.
http://www.appbrain.com/stats/number-of-
android-apps , 2012.
[4] I. Asrar. Android.counterclank found in ofÔ¨Åcial android
market. http://www.symantec.com/connect/
blogs/androidcounterclank-found-
official-android-market/ .
[5] B. Bellamy, P. Avgustinov, O. de Moor, and D. Sereni.
EfÔ¨Åcient local type inference. In Proceedings of the 23rd
ACM SIGPLAN conference on Object-oriented programming
systems languages and applications , pages 475‚Äì492, 2008.
[6] C. Cifuentes. Interprocedural data Ô¨Çow decompilation.
Journal of Programming Languages , 4:77‚Äì99, 1996.
[7] E. Dupuy. Jd java decompiler.
http://java.decompiler.free.fr/ .
[8] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. N. Sheth. Taintdroid: an
information-Ô¨Çow tracking system for realtime privacy
monitoring on smartphones. In Proc. of the 9th USENIX
conf. on OS design and implementation , 2010.
[9] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri. A study
of android application security. In Proceedings of the 20th
USENIX conference on Security , pages 21‚Äì21, 2011.
[10] E. Gagnon, L. J. Hendren, and G. Marceau. EfÔ¨Åcient
inference of static types for java bytecode. In SAS‚Äô00 , pages
199‚Äì219, 2000.
[11] Gartner. Gartner says android to command nearly half of
worldwide smartphone operating system market by year-end
2012. http://www.gartner.com/it/page.jsp?
id=1622614 , April 2011.
[12] Google. Dalvik vm: Code and documentation.
http://code.google.com/p/dalvik/ .
[13] J. Hamada. New android threat gives phone a root canal.
http://www.symantec.com/connect/blogs/
new-android-threat-gives-phone-root-
canal , March 2011.
[14] HP-Fortify. Source Code Analyzer (SCA).
https://www.fortify.com/products/hpfssc/
source-code-analyzer.html .
[15] IBM. Wala: T.J. watson libraries for analysis.
http://wala.sourceforge.net/wiki/index.
php/Main_Page , October 2011.
[16] R. T. Johnson. Verifying Security Properties using
Type-QualiÔ¨Åer Inference . PhD thesis, EECS Department,
University of California, Berkeley, Jan 2007.
[17] Kaspersky Lab. First SMS Trojan detected for smartphones
running Android. http://www.kaspersky.com/
about/news/virus/2010/First_SMS_Trojan_
detected_for_smartphones_running_Android ,
Aug. 2010.
[18] D. Kellogg. In U.S. Market, New Smartphone Buyers
Increasingly Embracing Android. http://blog.
nielsen.com/nielsenwire/online_mobile/
in-u-s-market-new-smartphone-buyers-
increasingly-embracing-android/ , Sep. 2011.
[19] T. B. Knoblock and J. Rehof. Type elaboration and subtype
completion for java bytecode. ACM Trans. Program. Lang.Syst., 23:243‚Äì272, March 2001.
[20] J. Lim and T. Reps. A system for generating static analyzers
for machine instructions. In Proc. International Conference
on Compiler Construction (CC) , 2008.
[21] T. Lindholm and F. Yellin. Java Virtual Machine
SpeciÔ¨Åcation . Addison-Wesley Longman Publishing Co.,
Inc., Boston, MA, USA, 2nd edition, 1999.
[22] P. McDaniel and W. Enck. Not So Great Expectations: Why
Application Markets Haven‚Äôt Failed Security. IEEE Security
& Privacy Magazine , 8(5):76‚Äì78, September/October 2010.
[23] J. Meyer, D. Reynaud, and I. Kharon. Jasmin home page.
http://jasmin.sourceforge.net/ , 2004.
[24] J. Miecznikowski and L. Hendren. Decompiling java using
staged encapsulation. In WCRE ‚Äô01: Proc. of the 8th Working
Conf. on Reverse Engineering . IEEE Computer Society.
[25] J. Miecznikowski and L. J. Hendren. Decompiling java
bytecode: Problems, traps and pitfalls. In CC ‚Äô02: Proc. of
the 11th International Conference on Compiler Construction ,
pages 111‚Äì127, London, UK, 2002. Springer-Verlag.
[26] G. Morrisett, D. Walker, K. Crary, and N. Glew. From
system f to typed assembly language. In The Twenty-Fifth
ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , 1998.
[27] A. C. Myers. JÔ¨Çow: practical mostly-static information Ô¨Çow
control. In Proc. of the 26th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages , 1999.
[28] N. A. Naeem and L. Hendren. Programmer-friendly
decompiled java. In ICPC ‚Äô06: Proceedings of the 14th IEEE
International Conference on Program Comprehension , pages
327‚Äì336. IEEE Computer Society, 2006.
[29] D. Octeau, W. Enck, and P. McDaniel. The ded Decompiler.
Technical Report NAS-TR-0140-2010, Network and
Security Research Center, Department of Computer Science
and Engineering, Pennsylvania State University, University
Park, PA, USA, Sep. 2010.
[30] D. Octeau, S. Jha, and P. McDaniel. Retargeting Android
Applications to Java Bytecode. Technical Report
NAS-TR-0150-2011, NSRC, Dept. of CSE, Pennsylvania
State University, Sep. 2011.
[31] D. Octeau, P. McDaniel, and W. Enck. ded: Decompiling
Android Applications.
http://siis.cse.psu.edu/ded/ , 2011.
[32] D. Octeau, P. McDaniel, and S. Jha. Dare: Dalvik retargeting.
http://siis.cse.psu.edu/dare/ , 2012.
[33] Oracle. Maxine vm. https://wikis.oracle.com/
display/MaxineVM/Home , 2004.
[34] T. A. Proebsting and S. A. Watterson. Krakatoa:
Decompilation in java (does bytecode reveal source?). In 3rd
USENIX Conference on Object-Oriented Technologies and
Systems , 1997.
[35] N. Ramsey and J. Davidson. Specifying instruction
semantics using ‚ÄìRTL. Unpublished manuscript, 1999.
[36] J. Rehof and T. A. Mogensen. Tractable constraints in Ô¨Ånite
semilattices. In Science of Computer Programming , pages
285‚Äì300. Springer-Verlag, 1996.
[37] R. Vallee-Rai, E. Gagnon, L. Hendren, P. Lam, P. Pominville,
and V . Sundaresan. Optimizing java bytecode using the soot
framework: Is it feasible? In International Conference on
Compiler Construction, LNCS 1781 , pages 18‚Äì34, 2000.
[38] H. van Vliet. Mocha, the java decompiler. http://www.
brouhaha.com/~eric/software/mocha/ , 2001.