Angels and Monsters: An Empirical Investigation of
Potential Test Effectiveness and EfÔ¨Åciency Improvement
from Strongly Subsuming Higher Order Mutation
Mark Harman and Yue Jia
CREST, University College London, UKPedro Reales Mateo and Macario Polo
Univ. of Castilla-La Mancha, Spain
ABSTRACT
We study the simultaneous test eectiveness and eciency
improvement achievable by Strongly Subsuming Higher Or-
der Mutants (SSHOMs), constructed from 15,792 rst order
mutants in four Java programs. Using SSHOMs in place
of the rst order mutants they subsume yielded a 35%-45%
reduction in the number of mutants required, while simulta-
neously improving test eciency by 15% and eectiveness by
between 5.6% and 12%. Trivial rst order faults often com-
bine to form exceptionally non-trivial higher order faults;
apparently innocuous angels can combine to breed monsters.
Nevertheless, these same monsters can be recruited to im-
prove automated test eectiveness and eciency.
1. INTRODUCTION
Mutation testing seeds faults into the program under test
to create `mutants' [7, 23]. These mutants can be classi-
ed as being either First Order Mutants (FOMs) or Higher
Order Mutants (HOMs). FOMs seed only a single fault,
while HOMs are a generalizaion in which at least one fault
is seeded. The space of higher order mutants is exponential,
but search techniques have proved able to nd many inter-
esting HOMs, thereby avoiding the need for (an infeasible)
full enumeration of the HOM space [20, 22].
There is empirical evidence that HOMs may also reduce
the proportion of mutants that are equivalent to the original
program from which they are constructed [26, 40]. It has
also been shown that HOMs have the potential to reduce
test eort [20, 22, 33, 41]. Higher order mutation has been
applied to model based testing [4] and concurrency testing
[31] as well as code-level mutation (as studied in this paper).
A more detailed introduction to the higher order mutation
paradigm can be found elsewhere [15].
Strongly Subsuming Higher Order Mutants (SSHOMs)
are a particularly important subclass of HOMs that are only
killed by a subset of the intersection of test cases that kill
each of the rst order mutants from which they are con-
structed [22].
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ASE‚Äô14, September 15-19, 2014, Vasteras, Sweden.
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2643008.By construction, an SSHOM is at least as good (and pos-
sibly superior to) any of its constituent FOMs, in the sense
that a test case that kills it will be guaranteed to kill all
FOMs (but not vice versa, whence the moniker `strongly
subsuming').
Although SSHOMs are theoretically at least as good as the
FOMs they subsume, there has been no previous empirical
investigation of this eect. Therefore, we have no data in
the literature that reports the expected reduction in test
eort than can be achieved (if any). Furthermore, though
the use of SSHOMs cannot, by construction, reduce test
eectiveness, we have no data on whether any improvement
in test eectiveness can be achieved.
Most test optimization techniques (for example regression
test selection and minimization [43, 50] and selective muta-
tion [23, 37]) involve an inherent trade-o between eec-
tiveness and eciency. Test improvement approaches either
make testing more eective at the expense of some (hope-
fully acceptable) reduction in its eciency or they make
testing more ecient with a concomitant reduction in ef-
fectiveness. The use of SSHOMs in place of FOMs oers
a more attractive possibility: maybe we can simultaneously
improve both eectiveness and eciency. Adoption of the
approach will therefore not require any trade os between
the competing objectives of eciency and eectiveness.
More precisely, we distinguish two distinct reasons why
an SSHOM study may be of interest to mutation testers,
depending upon whether or not the test process has a fully
automated oracle available:
Fully Automated: The entire mutation testing process
is automated, including checking whether a test output is
correct (the so-called `oracle' problem [9, 17, 46]).
Partially Automated : Mutant generation and execution
are automated, but the determination of whether the out-
put is correct is not fully automated. There is no fully au-
tomated test oracle and so some of the burden of the oracle
problem falls on the shoulders of the test engineer or other
humans involved in the test process.
In the rst of these two scenarios, full automation means
that the number of mutants required will have a strong im-
pact on the overall testing time. Therefore, in this fully
automated scenario, both reductions in the numbers of mu-
tants required andreductions in the number of test cases
required will be of interest. In the second of the two scenar-
ios, the test eort will be likely dominated by the human
eort required to provide an oracle, so reductions the num-
ber of test cases to be examined will outweigh the value of
any reductions in the numbers of mutants required.
397
In this paper we study the reduction in both the number
of mutants and the number of test cases that result from
the replacement of FOMs with the SSHOMs that subsume
them. All current techniques for nding HOMs (including
that used in this paper to nd SSHOMs) require all FOMs
to be executed as part of the HOM construction process.
Therefore, any reduction in the number of mutants will only
be of interest if we can nd ways of statically predicting the
FOMs that are more likely to combine to form SSHOMs.
However, in the second scenario, where test eort is dom-
inated by the oracle cost, any reduction in the number of
tests required (while maintaining or improving test eec-
tiveness) will be valuable to the tester (even using currently
available techniques to construct HOMs).
We asses the eciency and eectiveness of SSHOM-based
testing, but we also want to understand the properties of
subsumed FOMs: if subsumed FOMs are very hard to kill
(they are `monsters'), then we might expect SSHOMs con-
structed from them to also be monsters; from monsters shall
we expect to construct monsters. By contrast, if we nd
that subsumed FOMs are easy to kill on average (they are
`angels'), then the SSHOM construction process transforms
angels into monsters: it builds (hard-to-kill) monster faults
from (easy-to-kill) angelic faults. Our ndings concern the
eects of using the set of Strongly Subsuming Higher Order
Mutants (which we denote SSHOMs) in place of the set of
rst order mutants they subsume (which we denote FOMs).
The primary contributions are:
Mutant Minimization: SSHOMs reduce the number of
mutants to be considered by 35%. This rises to 45% if
SSHOMs is minimized using greedy test suite minimization
to produce a reduced set, SSHOMsRed.
Eciency improvement: SSHOMs reduce test eort by
14% (15% for SSHOMsRed).
Eectiveness improvement: SSHOMs increase test ef-
fectiveness by 5.6% to 12.0% (similarly for SSHOMsRed).
Monsters from angels : SSHOMs are `monster' faults that
are exceptionally hard to detect, yet are constructed entirely
from `angel' faults that are easy to detect.
Unsubsumed coverage : SSHOMs subsume 45% - 75% of
all FOMs. We therefore need to nd techniques that increase
SSHOM coverage (or to use hybrid FOM/SSHOM testing).
2. SEARCHING FOR SSHOMS
A Strongly Subsuming Higher Order Mutant (SSHOM) is
dened as follows. Let Kill(S ) return the set of test cases
which kill all mutants in the set S. The higher order mutant
H, constructed from a set of rst order mutants F1;:::;F n,
is an SSHOM[20] i
Kill(H)\
iKill(Fi)and Kill (H)6=;
Figure 1 depicts this denition of SSHOM in a Venn dia-
gram. The test set denoted Tmkills the higher order mutant,
H, while the test sets denoted Tikill rst order mutants Fi.
IfHis an SSHOM then Tmmust be a non-empty subset of
the intersection of Ti.
Our four subjects are Monopoly [32] and Chess [33] (two
board games), and Validator and Clifrom the Apache project.
They range in size from 1,190 Lines of Code (LoC) to 6,359
LoC (see Table 2). We use the Java mutation testing tool,
Bacterio [32] and its set of Java mutants.
T1T2TnTmFigure 1: Generalized nthorder SSHOM scenario
Table 1: Quantitative information about Subject Systems
Subject #Tests Statement First order
System coverage mutation score
Monopoly 213 98.8% 83.8%
Chess 593 99.6% 88.6%
Validator 415 80.0% 73.6%
Cli 187 95.7% 77.6%
All 4 applications come with good quality test suites dis-
tributed with the applications and designed by third party
testers (not the experimenters). We use these tests in our
empirical study, because they are considered to be complete
and adequate by their developers. Quantitative informa-
tion concerning the test suites are summarised in Table 1.
In the rest of this study we focus on the mutants that are
killed by the test suites. Manual inspection of samples of the
remaining unkilled mutants indicated that many are equiva-
lent. In order to ensure high quality test data, we manually
added test cases to the test suites provided, where we found
unkilled yet non-equivalent mutants. However, as with all
studies of equivalent mutants, we cannot be sure that we
have detected all equivalent mutants, even if we were to
manually inspect every one (which is seldom practical [49]).
Finding SSHOMs among the space of all higher order mu-
tants requires a computational search process, such as those
associated with the widely-studied area known as `Search
Based Software Engineering' (SBSE) [10, 16]. This is be-
cause the space of higher order mutants is exponentially
large innfornthorder mutants. We use a simple ge-
netic algorithm to search for SSHOMs among the HOMs
constructed within each of the methods of the program. It is
recommended [18] that authors of SBSE work dene clearly
the representation and tness function used in the search
process. We dene these two key `SBSE ingredients' in the
remainder of this section, along with the search operators
we use and our termination procedure.
Representation : We represent a higher order mutant as
a vector of pairs of integers. The length of the vector is
the number of rst order mutants that combine to form the
HOM represented. Each vector element indexes the loca-
tion of a rst order mutant and the type of mutation to
be applied. A single point crossover is applied to generate
`ospring'. It rst chooses a cut point. Two higher order
mutant `parents' are then split at the cut point and the
resulting four fragments are recombined to create two new
`children' in the standard manner for single point crossover
[12]. Figure 2 illustrates this process.
Crossover can produce mutants that are not higher order,
either because of repetition of a lower order mutants or be-
cause of repeated mutation at the same location. We avoid
repetition of lower order mutants, but make no attempt to
control for same-location mutations.
398M1M3M5M7M8
M3
M4
M6
M9M1M3M5M7M8
M3
M4
M6
M9Cutting point
ParentsOffspringsFigure 2: Crossover operator used in our search
M1M2M5M8
M8M1M2
M3Genetic Mutation 1M1M2M5M8
M8M1M2Genetic Mutation 2
M5M1M2M5M8
M8M1M2
M4Genetic Mutation 3
M5
Figure 3: Genetic mutation operators used in our search
Such same-location mutants will not have increased tness
and, therefore, the genetic algorithm will not favour their
selection. The genetic algorithm uses three genetic muta-
tion operators, illustarted in Figure 3. The rst operator
randomly selects a FOM and replaces it with another FOM.
The second operator randomly removes a selected FOM and
the third operator adds a new randomly selected FOM to
the current HOM.
Fitness function: Our tness function simply seeks to re-
duce the number of tests that kill all FOMs, while increasing
the number that kill the HOM: the tness of an SSHOM,
HfF1;:::;Fng, with respect to a test suite Tis dened as
jTj   j Kill(H fF1;:::;Fng)j+jnT
i=1Kill(F i)j.
This function targets subsuming HOMs, but there is noth-
ing in the computation that specically favours strongly sub-
suming HOMs. In so doing, we are thus sampling (ran-
domly) from the space of subsuming higher order mutants
to nd a set that is strongly subsuming. Because we do
not aggressively seek strong subsumption, our results can
be thought of as a lower bound on technical improvements
that can be achieved using strongly subsuming HOMs. Our
goal is not to introduce a new mutation testing technique.
Rather, we seek to identify a set of SSHOMs so that we can
empirically study them, thereby providing results against
which future work on SSHOMs can compare.
Future work may focuses on carefully designed tness func-
tions that target strongly subsuming higher-order mutants
with particular behaviour and properties. Indeed, such work
is on-going. For example, recent work [39] has introduced a
tness function that targets strongly subsuming HOMs that
test untested behaviour (that which is not tested by any of
the constituent FOMs).
We used a `reset' feature as a termination condition and
also to avoid the search becoming unnecessarily trapped in
local optima. Reset simply restarts the search with a new
randomly generated population when the variance in tness
observed has fallen below 10% of its starting variance. The
overall search terminates when no new SSHOMs are found
after three restarts have been applied.3. EMPIRICAL STUDY PROCEDURE
This section explains our research questions, motivating
why we ask them, how they relate to one another and the
experimental and inferential statistical procedures used to
answer them.
We search for a set of SSHOMs for each of the four pro-
grams using the generic algorithms described in the previous
section (Section 2). From the set SSHOMs, we construct a
set SSHOMsRed using greedy minimization [42, 50]. This
algorithm iteratively removes mutants from SSHOM, while
there remain mutants that can be removed without aecting
the set of FOMs subsumed.
We start by establishing a baseline set of data on the num-
bers of mutants and test cases involved in our study. Such
baseline data can be useful, for example, in replication stud-
ies that involve dierent subjects and for which the sets of
mutants and test cases may therefore dier. In particular,
we are interested to establish baseline data for the sizes of
the SSHOM and SSHOMsRed sets, since these are compar-
atively less well studied than rst order mutants (the FOM
set).
RQ1: Baseline Data : We decompose RQ1 into two sub
research questions, one concerning baseline data on mutants
and the other concerning baseline data on test suites.
RQ1.1: Baseline Data on Mutants : What are the num-
bers of FOMs, SSHOMs SSHOMsRed and the percentage of
FOMs subsumed by the SSHOMs?
Once the SSHOMs were found, mutation adequate tests
suites were constructed for each of the three sets of mutants:
FOMs, SSHOMs and SSHOMsRed. The test suite construc-
tion process consisted of random selection from the pool of
test cases provided with each of the four programs under
study. By using tests from a third party, we remove one
source of potential bias (selection of test cases by the exper-
imenters). We also hope that the use of real-world test suites
may make it more likely that our results will be realistic and,
thereby more relevant to real-world testers.
To select, from this pool, a test suite to kill mutants in the
setS, test cases were repeatedly randomly chosen until all
mutants inSwere killed. This process was repeated 30 times
to cater for the stochastic nature of the selection process.
RQ1.2: Baseline Data on Test Suites: What are the
average sizes of mutation adequate test suites (and the stan-
dard deviation) over the thirty tests suites selected to kill all
mutants in the three classes of mutant for each of the four
programs?
RQ1.1 and RQ1.2 also allow us to assess the degree of test
eort reduction (in terms of the numbers of mutants and test
cases required) that can be achieved using SSHOMs in place
of the FOMs that they subsume. Having established baseline
data for mutants and test cases, we move to the two research
questions at the heart of our technical investigation.
That is, how much harder to kill are strongly subsuming
higher order mutants (RQ2) and how much more eective
are the test suites constructed from them (RQ3)?
RQ2: Higher order potency : How much harder to kill
are mutants in SSHOM (and SSHOMsRed) than those in
FOM?
Note that SSHOMs are theoretically at least as hard to kill
as the FOMs from which they are constructed, by denition.
Therefore, we need not ask whether SSHOMs areharder to
kill; we know they are at least as hard to kill.
399In our study, we seek to measure the signicance (or other-
wise) and size of this eect. In order visualize the dierence
in killability of FOMs and SSHOMs (and SSHOMsRed) we
draw a graph we term the `kill-growth' graph. We consider
two types of kill growth graph. A Proportional Kill Growth
(PKG) graph and an Absolute Kill Growth (AKG) graph.
For a given test suite order TOand set of mutants M, the
kill growth graph shows the growth in the absolute number
(AKG) or proportion (PKG) of mutants from Mkilled by
TO.
A point in the PKG graph at ( x;y) signies that after x%
of the tests in TOhave been executed, the proportion of
mutants from Mkilled isy. A point in the AKG graph at
(x;y) signies that after x% of the tests in TOhave been
executed, the number of mutants from Mkilled isy. It is
reasonable to use a PKG graph when the mutant sets are
the same size. However, for dierently sized sets of mutants,
the AKG graph should also be reported, because it reects
the growth in the numbers of faults found.
We have 3 sets of 30 test suites (one set for each of the
three classes of mutant). We combine all these sets of test
suites into a single set of 90 test suites for this visualization.
In so-doing we seek to visualise the typical expected average
kill growth trends for each of the three classes of mutants,
averaged over 90 trials. We have no information about the
specic order in which a tester might execute test cases.
Therefore, we report the average mutation score observed
over all 90 test suites in the (arbitrary) order in which they
are selected by the random test selection algorithm.
To assess the statistical signicance of the dierence be-
tween rst order mutants and higher order mutants, we used
a Wilcoxon Signed-Rank test with the widely-adopted `stan-
dard' 95% signicance level ( = 0.05). This level is re-
duced to 0.0167, using the Bonferroni correction to cater
for the fact that we perform three Wilcoxon tests (0.0167 =
0.05/3). The Bonferroni correction is known to be a conser-
vative correction. It risks Type II errors (incorrectly accept-
ing the null hypothesis) in order to reduce the risk of Type I
errors (incorrectly rejecting the null hypothesis). Therefore,
should we nd that our results force us to reject the null
hypothesis after this correction (i.e., there is no possibility
of Type II error), then we can be condent that our results
are strongly signicant.
Knowing how much harder SSHOMs are to kill (compared
to FOMs) is interesting to mutation testing researchers, but
for testing practitioners the important question is
\How much more eective is SSHOM testing?"
This question is addressed by RQ3:
RQ3: Higher order test eectiveness : How much more
eective are test suites constructed from SSHOMs compared
to those constructed from FOMs?
We plot PKG graphs for each of the three types of test
suite: those selected to kill each of the three types of mu-
tants (FOMs, SSHOMs and SSHOMsRed). Since each test
suite is selected to kill a particular class of mutants, S, there
is a natural order in which to execute the test suites (un-
like the union of all test cases used in answering RQ2): we
order the test cases in each test suite using the so-called `ad-
ditional greedy' algorithm [51]. This chooses the next test
to be executed as that which kills the greatest number of
remaining unkilled mutants in the set S.This greedy ordering ensures that we consider test cases
in the order that respects the `design' of the test suite; tests
selected to kill FOMs, for example, are ordered so that they
favour early achievement of 100% FOM coverage. In total,
we have selected 30 dierent test suites for each of the three
classes of mutants (FOMs, SSHOMs and SSHOMsRed), so
we now have a total of 90 ordered test suites with which to
experiment.
Since we have unpaired data, we use the Kruskal-Wallis
test to analyse the variance of the three sets of data obtained
from the test suites selected to kill each of the three kinds of
mutants. The Kruskal-Wallis test is an unpaired and non-
parametric test that determines whether a set of samples
originate from the same distribution according to the vari-
ance of their ranks. We augment the Kruskal-Wallis test
with a post-hoc pairwise comparison of the dierent classes
of test (selected for FOMs, SSHOMs and SSHOMsRed) us-
ing Dunn's test [44].
We use Dunn's test because we have not only unpaired
samples from populations of unknown distribution (therefore
suggesting the use of a non-parametric test), but also sam-
ples of uneven sizes, which means that Wilcoxon's unpaired
non-parametric test is not directly applicable). Dunn's test
also includes a generalised version of the Bonferroni correc-
tion for multiple tests. Therefore, it the Pvalues we report
are adjusted to take account of the number of statistical
signicance tests we perform.
Having explored whether SSHOMs can improve testing
by replacing subsumed FOMs, we wish to study whether
there is anything more interesting about subsumed FOMs
compared to the unsubsumed FOMs:
RQ4: Characteristics of Subsumed FOMs : What are
the dierences between subsumed and unsubsumed FOMs?
We decompose RQ2 into three subquestions as follows:
RQ4.1: Subsumed FOM killability : What is the killa-
bility of subsumed FOMs compared to the remaining FOMs?
To answer RQ4.1 we compare the two box plots con-
structed from the set of killability values (proportion of all
test cases that kill a mutant) for subsumed and unsubsumed
FOMs. However, a mutant may fail to be killed by a test
case because the test case fails to cover the mutant. Mutants
that reside in branches that are seldom executed will thus
naturally tend to appear `harder to kill' simply because they
are harder to reach (it will be harder to execute the mutated
code). Such reduced killability due to reduced executability
is a property of the program under test, rather than any
characteristic of the mutants that reside in it.
Therefore, in order to provide an assessment of mutant
killability that takes account of reachability, we complement
the answer to RQ4.1 with a repeated experiment in which
only test cases that execute the mutant (covering test cases)
are counted in determining a mutant's killability:
RQ4.2: Subsumed FOM killability by Covering Tests :
What is the killability of subsumed FOMs compared to the
remaining FOMs when restricted to covering tests?
To answer RQ4.2 we compare the two box plots con-
structed from the set of killability values for subsumed and
unsubsumed FOMs using only test cases that cover the mu-
tants. Finally, we examine the distribution of subsumed
FOMs over all FOMs:
RQ4.3: Subsumed FOM distribution : How do the sub-
sumed FOMs distribute over all mutants in the process of
mutation testing?
400Table 2: Number of SSHOMs found
Subject LoC FOMs SS SSHOMs Subsumed
HOMs Red FOMs
Monopoly 1,190 1,283 166 119 218; 18%
Chess 2,376 7,204 664 634 1,168; 16%
Validator 6,359 5,604 501 377 674; 12%
Cli 2,001 1,701 159 121 220; 13%
Total 15,792 1,490 1,251 2,280; 14%
Reduction | 35% 45% 0%
Table 3: Number of Tests derived
Subject Mean number of tests for
Systems FOMs SSHOMs SSHOMsRed
Monopoly Mean 29 27 28
Std. dev. 3.9 3.1 2.7
Chess Mean 190 158 157
Std. dev. 6.7 4.8 3.8
Validator Mean 73 65 64
Std. dev. 4.3 3.6 2.8
Cli Mean 32 28 27
Std. dev. 2.9 2.7 2.8
Total (averaged) tests 324 278 276
Reduction in tests needed 0 14% 15%
We plot a Proportional Kill Growth (PKG) graph for all
mutants and study the distribution of subsumed FOMs on
this graph. This allows us to see how subsumed mutants
distribute over the PKG. For example, we can see whether
subsumed mutants tend to be killed earlier, later or evenly in
the overall mutation testing process. Finally, for complete-
ness, we ask how many of the unsubsumed FOMs would
have been killed using the test suites selected to kill sub-
sumed FOMs and their SSHOMs:
RQ4.4: Unsumbsumed coverage : How many unsub-
sumed FOMs do subsumed FOMs and their SSHOMs kill?
4. RESULTS
This section presents the results that answer the four re-
search questions set out in the previous section (Section 3).
RQ1.1: Baseline Data on Mutants
Table 2 provides baseline data. It shows the numbers of
FOMs generated from each of the four programs and the
numbers of SSHOMs generated from the FOMs using the
search process dened in Section 2. The table also gives the
sizes of the reduced set SSHOMsRed produced by minimiza-
tion. In the nal column, the table reports the number of
FOMs (and the percentages of all FOMs this denotes) that
are subsumed by the SSHOM set.
As we can see from Table 2, 14% of the rst order mu-
tants are subsumed by SSHOMs. Also, these data allow us
to quantify the degree of saving possible using subsuming
higher order mutants. Over all programs, we found that the
saving achievable using SSHOMs over the FOMs they sub-
sume is 35%, increasing to 45% if we use the reduced set
SSHOMsRed.
RQ1.2: Baseline Data on Test Suites
Table 3 shows the mean number and the standard devia-
tion of the number of test cases selected for each of the four
programs and for each of the three classes of mutant.
Table 3 shows that the number of test cases selected to
achieve 100% FOM adequacy is larger than the number re-
quired to achieve 100% SSHOM adequacy, on average.This suggests that SSHOMs can potentially reduce the
number of tests required without losing test eectiveness. It
is also noticeable that the number of tests derived from the
complete set of SSHOMs and the reduced set (SSHOMsRed)
are almost identical (each diering by at most one test case,
on average, which is well within a single standard deviation).
This is to be expected, since the reduction the minimiza-
tion algorithm is designed to reduce the number of mu-
tants without aecting the eectiveness of the mutant set.
We should, therefore, expect a similar number of test cases
would be required to kill the minimized set of strongly sub-
suming higher order mutants as are required to kill the unre-
duced set.
For the test engineer's point of view, it is interesting to
note that using tests selected to kill strongly subsuming
HOMs results in a 14%-15% reduction in the number of test
cases that need to be selected. In cases where there is no
automated oracle, and the test engineer must play this role,
this may be a welcome reduction in test eort, especially
if it is accompanied by an increase in test eectiveness (a
question explored in RQ3).
RQ2: Higher Order Mutant Potency
The AKG and PKG graphs for each of the three classes
of mutants are depicted in Figure 4. In both AKG and
PKG graphs, the average value of all ninety executions was
calculated at each point. The AKG graphs show the num-
ber of mutants killed as more test cases are executed, while
the PKG graph shows the proportion of all mutants in the
class (FOM, SSHOM or SSHOMsRed) that are killed. The
dashed line (representing the mutation score obtained with
FOMs) is always above other lines, which indicates FOMs
are killed faster than SSHOMs independently of the test
cases used.
From Table 2 we know that the average saving in num-
bers of mutants needed, when SSHOMs are used in place of
the FOMs is 35% (for SSHOMs), rising to 45% for the re-
duced set of SSHOMs. However, though fewer SSHOMs are
needed, they are also harder to kill. These growth graphs,
provide a visualization this reduced killability.
As can be seen from Figure 4, FOMs are killed at a greater
rate than SSHOMs in absolute terms. There are also pro-
portionately more FOMs killed than SSHOMs at every stage
of the test process until the very nal stages of testing, when
almost all test cases have been executed. As a result, we can
be reasonably sure that, were testing to cease at any stage,
a greater number and proportion of FOMs would be killed
than SSHOMs.
To examine the observation in more detail, statistical anal-
yses were carried out as explained in Section 3. Table 4
shows the results of a (paired) Wilcoxon signed-rank test.
In Table 4, the pvalues obtained are all lower than 0.00049,
indicating strong signicance at the 0.05 level (after account-
ing for multiple testing with the Bonferroni correction).
Each statistical test involves 90 sets of paired data points.
There is one set of paired points for each set of test data.
Each paired data element is the mutation score reached by
the two mutation techniques being compared, after the same
number of test cases has been executed.
To interpret the Cohen's deect size measurement we
use a standard range of eect sizes from `small' to `large'
[5]. The eect size is `medium' between FOMs and both
SSHOMs and the reduced set SSHOMsRed.
401 0 50 100 150 200 250
 0  5  10  15  20  25  30  35Number of killed mutants
TestsMean FOMs
Mean SSHOMs
Mean SSHOMsRed
 0 250 500 750 1000 1250
 0  50  100  150  200Number of killed mutants
TestsMean FOMs
Mean SSHOMs
Mean SSHOMsRedMonopoly Chess
 0 150 300 450 600 750
 0  10  20  30  40  50  60  70  80Number of killed mutants
TestsMean FOMs
Mean SSHOMs
Mean SSHOMsRed
 0 50 100 150 200 250
 0  5  10  15  20  25  30  35  40Number of killed mutants
TestsMean FOMs
Mean SSHOMs
Mean SSHOMsRed
Validator Cli
Absolute Kill Growth (AKG) graphs
 0 0.2 0.4 0.6 0.8 1
 0  5  10  15  20  25  30  35Mutation score
TestsMean FOMs
Mean SSHOMs
Mean SSHOMsRed
 0 0.2 0.4 0.6 0.8 1
 0  50  100  150  200Mutation score
TestsMean FOMs
Mean SSHOMs
Mean SSHOMsRed
Monopoly Chess
 0 0.2 0.4 0.6 0.8 1
 0  10  20  30  40  50  60  70  80Mutation score
TestsMean FOMs
Mean SSHOMs
Mean SSHOMsRed
 0 0.2 0.4 0.6 0.8 1
 0  5  10  15  20  25  30  35  40Mutation score
TestsMean FOMs
Mean SSHOMs
Mean SSHOMsRed
Validator Cli
Proportional Kill Growth (PKG) graphs
Figure 4: The Potency of Strongly Subsuming Higher Order Mutants: Absolute/Proportional Kill Growth
(fA/PgKG) graphs showing the fabsolute/proportional gnumbers of mutants killed by all test cases for each of the three
classes of mutants: First Order Mutants (FOMs), Strongly Subsuming Higher Order Mutants (SSHOMs) and Reduced
SSHOMs (SSHOMsRed). The graphs reveal that the rate at which SSHOMs are killed is much lower than for FOMs in both
absolute terms and also proportionally (relative to the numbers of mutants in each class). We also observe a noticeable further
saving in the absolute numbers of mutants using the reduced set of SSHOMs for three out of the four programs studied.
402Table 4: Wilcoxon Signed-Rank test results
Comparing
FOMs
with
SSHOMsComparing
FOMs with
SSHOMsRedComparing
SSHOMs with
SSHOMsRed
Z -134.477 -139.946 -97.386
Sig. 0.000 0.000 0.000
Eect Size 0.586 0.610 0.424
The reduction in mutants achieved by mimimizing the
SSHOMs set to SSHOMsRed is also signicant and the ef-
fect, though not as large as the eect size for FOMs, is still
appreciable. In this case, the eect size is typically regarded
as between `small' and `medium'. We conclude that using
strongly subsuming HOMs in place of the FOMs they sub-
sume signicantly reduces the number of mutants required
and that this is a statistically medium sized eect.
RQ3: Higher order test eectiveness
From RQ2 we know how much harder it is to kill higher
order mutants compared to rst order mutants. Further-
more, from RQ1, we know that the test suites selected to
kill SSHOMs contain 15% fewer tests than those selected
to kill FOMs (yet they kill all FOMs and SSHOMs). This
is interesting to a mutation tester, but for a software en-
gineer, interested in testing in general, the more important
question will be whether the test suites selected to achieve
coverage of higher order mutants are, in some sense `better',
not merely smaller, than those test suites selected for the
more traditional, rst order, mutation criteria.
As with all testing techniques, the determination of which
technique is better can vary depending on context. However,
in mutation testing there is a way to order two test suites,
AandBaccording to their mutation score on some set of
mutantsM. Suppose test suite TSSHOM is selected to kill
mutants in SSHOM and test suite TFOM is selected to kill
mutants from the set FOM , then we can compare each test
suite to see how good the suite is at killing mutants used to
select the other kind of mutants. However, the test suites
may have dierent size, so a direct comparison of scores is
not appropriate. Rather, we compare the growth in mutant
scores as we order the test cases, as before, thereby catering
for diering sizes of test suite.
Figure 5 shows the results of comparing the mutation score
achieved by the tests selected to kill the mutants in FOMs,
SSHOMs, SSHOMsRed.
As we can see from this gure, for all four subjects, the
results show that, though test suites derived from SSHOMs
contain fewer test cases, they nevertheless, achieve both
higher mutation score overall and, more importantly, do so
faster then test suites derived from FOMs.
We also observe, in all cases, that the test suites selected to
kill FOMs fail to reach 100% mutant score. This is because
there are HOMs SSHOMs that are not killed by anyof the
test cases select to kill FOMs: over all thirty test suites
selected to kill all FOMs, 2.2, 7.3, 5 and 1.7 of the HOMs
remain unkilled, on average, for the programs Monopoly,
Chess, Validator and Cli respectively.
This provides additional evidence that conrms the ob-
servation that test suites selected to kill FOMs are inferior
to test suites selected to kill SSHOMs. It also reveals that,
for all programs studied, some of the SSHOMs are, indeed,
very `stubborn'; hard to kill yet not equivalent [49].Table 5: Kruskal-Wallis test results
Test set selected Mean
to kill N rank
FOMs 29205 383872= 117:872
SSHOMs 24990 40258
SSHOMsRed 24879 40164 p<0.000
Total 79074
Table 6: Dunn's method results
Kind of mutants from Z Sig. Adj. Eect
which tests are selected Sig. Size
FOMs{SSHOMs -9.513 0.000 0.000 0.041
FOMs{SSHOMsRed -9.026 0.000 0.000 0.039
SSHOMs{SSHOMsRed 0.458 0.647 1.000 0.002
Table 5 presents the results of the Kruskal-Wallis test. In
this tableNis the total number of test executions (tests 
mutants) required to achieve 100% mutation score for each
of the three criteria (over thirty repeated samples of test
cases). Since these test suites are unpaired, their sizes dif-
fer; more test cases were executed according to the FOM
criteria. The result (Sig. <0.000) indicates a strongly signi-
cant dierence exists between the three test suite executions;
they are very unlikely to be sampled from the same popula-
tion distribution.
The Kruskal-Wallis test was run to determine whether
there were signicant dierences between tests generated
from the set of FOMs, SSHOMs and SSHOMsRed. Pair-
wise comparisons were performed using Dunn's method (as
explained in Section 3). This post-hoc analysis, the results
of which are shown in Table 6, reveals statistically signi-
cant dierences in mutation score between the tests selected
to kill FOMs and those selected to kill SSHOMs (p = 0:000)
and also between the tests selected to kill FOMs and those
selected to kill SSHOMsRed ( p= 0:000).
However there was no statistical dierence between the
tests selected to kill SSHOMs and those selected to kill
SSHOMsRed (p = 0:647). The eect size between the FOM
tests and the SSHOM tests and FOM tests and the SSHOM-
sRed tests was assessed as `small' according to the Cohen's
dmeasurement.
We conclude that a small, but signicant, reduction in the
numbers of test cases required for mutation adequacy can be
obtained using strongly subsuming higher order mutants in
place of the rst order mutants that they cover. Further-
more, though we found in RQ2 that minimization had a
signicant eect on the numbers of mutants in the SSHOM
sets, it has no signicant eect on the number of test cases
required to achieve mutation adequacy.
Overall, we nd a 5.6% average improvement in test eec-
tiveness using tests selected to kill SSHOMs in place of test
selected to kill FOMs. That is, it requires 5.6% fewer tests
on average to kill all mutants (FOMs and HOMs) using tests
selected to kill the SSHOMs compared to those selected to
kill the FOMs.
This gure might downplay the potential improvement in
test eectiveness, because it is computed as an average over
all points in the test process, thereby including cases such
as those near the `end' of the process, when almost all tests
have been executed in any case.
If we consider, instead, the maximum eectiveness im-
provement achieved over the test process, this gives a con-
trasting upper bound on the eectiveness improvement that
can be expected.
403 0.2 0.4 0.6 0.8 1
 0  5  10  15  20  25  30  35Mutation score
TestsMean Tests FOMs
Mean Tests SSHOMs
Mean Tests SSHOMsRed
 0 0.2 0.4 0.6 0.8 1
 0  50  100  150  200Mutation score
TestsMean Tests FOMs
Mean Tests SSHOMs
Mean Tests SSHOMsRedMonopoly Chess
 0 0.2 0.4 0.6 0.8 1
 0  10  20  30  40  50  60  70  80Mutation score
TestsMean Tests FOMs
Mean Tests SSHOMs
Mean Tests SSHOMsRed
 0 0.2 0.4 0.6 0.8 1
 0  5  10  15  20  25  30  35  40Mutation score
TestsMean Tests FOMs
Mean Tests SSHOMs
Mean Tests SSHOMsRed
Validator Cli
Figure 5: The Quality of Tests Selected to Kill Strongly Subsuming Higher Order Mutants : The four gures
show, for each program studied, the growth in mutants killed, over all mutants (subsumed FOMs and the HOMs that strongly
subsume them) for each of the three kinds of test suite. The graphs visualise the increased test quality (in terms of mutant
score) for test suites selected to kill strongly subsuming mutants.
The maximum saving achieved using tests selected to kill
SSHOMs was 6.6%, 12.4%, 11.3% and 5.5% for the programs
Monopoly, Chess, Validator and Cli respectively. These im-
provements in eectiveness are obtained while simultane-
ously reducing the number of test cases required by 14%
and the number of mutants by 35%.
We also found that mimization of SSHOM test suites has
only a very small impact on eectiveness. Though, as re-
ported in RQ2, minimization of the set SSHOMs to SSHOM-
sRed, improves the reduction in mutants from 35% to 45%,
it also decreases the improvement in test eectiveness that
can be achieved by a (small) amount.
That is, though we found an average improvement in ef-
fectiveness of 5.6% with SSHOM, this was reduced (by only
0.2%) to 5.4% when using SSHOMsRed. Similarly, we found
(only) a 0.5% reduction in the maximum eectiveness im-
provement (overall all four programs). This is to be ex-
pected, since minimization seeks to remove only `redundant'
test cases [50].
RQ4: Characteristics of Subsumed FOMs
RQs 1, 2 and 3 show that subsumed FOMs can be com-
bined to make SSHOMs that reduce test eort by approxi-
mately 14%-15% while simultaneously improving test eec-
tiveness by 5.6%-12%. We next investigate whether there
are any special properties of the subsumed FOMs we have
been able to nd compared to the unsubsumed FOMs.
RQ4.1: Subsumed FOM killability
Figure 6 shows the killability of subsumed and unsub-
sumed mutant sets for each of the four programs studied.
 0 0.1 0.2 0.3 0.4 0.5
Monopoly-US Monopoly-S Chess-US Chess-S Validator-US Validator-S Cli-US Cli-S FOM killabilty (All tests)Figure 6: Killability distributions for subsumed({S) and un-
subsumed ({US) mutants over all test cases
As can be seen, the mutants of programs Chess and Val-
idator are noticeably harder to kill (in general) than those
of the other two programs. The average killability of the
subsumed FOMs appears to be similar (or higher) than that
of the unsubsumed FOMs in all cases. In all cases except
Chess, this dierence is statistically signicant (according
to a Wilcoxon test) but the eect size is small in all cases
(Cohen'sdis 0.120, 0.210 and 0.117 for Monopoly, Validator
and Cli respectively).
RQ4.2: Subsumed FOM killability by Covering Tests
Figure 7 shows the killability of subsumed and unsub-
sumed mutant sets for each of the four programs studied,
where killability is restricted to test cases the cover the mu-
tant in question. That is, a mutant is only deemed to be
unkilled when a test case reaches (and therefore executes) it
but fails to kill it. This factors out the eects of programs
that contain branches that are hard to reach.
404 0 0.2 0.4 0.6 0.8 1
Monopoly-US Monopoly-S Chess-US Chess-S Validator-US Validator-S Cli-US Cli-S FOM killabilty (Covered tests)Figure 7: Killability distributions for subsumed({S) and un-
subsumed ({US) mutants with tests that reach (cover) them
Table 7: Unsubsumed FOMs Killed by test selected to kill
subsumed FOMs and their SSHOMs
Subject Tests to kill %age unsubsumed FOMs killed
Chess FOMs 61
SSHOMs 60
SSHOMsRed 60
Cli FOMs 56
SSHOMs 56
SSHOMsRed 55
Monopoly FOMs 64
SSHOMs 64
SSHOMsRed 64
Validator FOMs 35
SSHOMs 34
SSHOMsRed 34
In this case, comparing Figures 6 and 7 we can see immedi-
ately that the apparent reduced killability of the mutants for
programs Chess and Validator was largely a product of these
programs containing mutants that are seldom executed. As
can be seen, for two programs (Monopoly and Chess), sub-
sumed mutants are, on average, a little easier to kill by tests
that execute them, while in the other two cases (Validator
and Cli), the subsumed mutants are a little harder to Kill.
The dierences are statistically signicant (according to the
Wilcoxon test), but, once again, the eect size is small ac-
cording to Cohen's dmeasure (0.154, 0.053, 0.210 and 0.055
for Monopoly, Chess, validator and Cli, respectively).
RQ4.3: Subsumed FOM distribution over all FOMs
The Proportional Kill Growth (PKG) graphs for all mu-
tants are depicted in Figure 8. The PKG graphs are drawn
as a faint solid line on which we superimpose an indication
(with short lines and whiskers) of the proportion of sub-
sumed FOMs that are killed. The PKG graphs are averaged
over all test suites and so the locations of the whisker plots
give an indication of the expected proportion of subsumed
FOMs that would be killed as testing progresses. As can be
seen, there are dierent subsumed FOM distribution pat-
terns for each of the programs, but overall Subsumed FOMs
are certainly no harder to kill than that other FOMs.
RQ4.4: Unsumbsumed coverage : How many unsub-
sumed FOMs do subsumed FOMs and their SSHOMs kill?
Table 7 shows the percentage of unsubsumed FOMs killed
by tests selected to kill each of subsumed FOMs, SSHOMs
and the reduced set of SSHOMs. As can be seen, even
though subsumed FOMs are only 15% of all mutants, the
test suites that kill them can kill 34% to 60% of the unsub-
sumed FOMs (45% to 75% of all FOMs).
Overall, in answer to RQ4, we nd that in all programs,
a large number of subsumed FOMs are easy to kill. From
a software engineer's point of view they are `angel' faults;
easy to detect.
 0 0.2 0.4 0.6 0.8 1
 0  10  20  30  40  50  60  70  80Monopoly
 0 0.2 0.4 0.6 0.8 1
 0  50  100  150  200  250  300  350  400  450
Chess
 0 0.2 0.4 0.6 0.8 1
 0  20  40  60  80  100  120  140
Validator
 0 0.2 0.4 0.6 0.8 1
 0  10  20  30  40  50  60
Cli
Figure 8: Distributions of killed subsumed FOMs over all
FOMs killed as testing progresses
However, we also found that there exist higher order com-
binations of these angels that are, from a software engineer's
point of view, `monsters': the entire test suite cannot detect
them. Nevertheless, scary though they may rst appear, we
also know (from the answers to RQs 1, 2 and 3) that we can
exploit these monsters to help simultaneously improve test
eort and eectiveness.
5. THREATS TO VALIDITY AND FUTURE
WORK
Our study has the typical threats to validity that impinge
on research investigations reporting on a set of studied pro-
grams; we cannot be sure that our results will generalise
to wider classes of programs and our results are obviously
specic to Java programs. We sought to take care of con-
struct threats that may otherwise have emerged due to mul-
tiple inferential statistical testing and uncertainties about
the distributions from which we sampled. However, another
important potential threat arises because of the need to use
`hand constructed' test suites.
405We wanted the pool of test cases from which we selected
test cases to be both realistic and to exhibit high coverage
so that we would not observe spurious eects that might
have otherwise arisen by limiting our study to only those
mutants that can be easily killed. Though there have been
advances on automated test case generation, tools remain
unable to achieve high coverage in all cases [28]. Therefore,
we used the human-designed test suites (that are provided
with the four programs we studied). More work is require to
assess the impact of SSHOM-testing on, for example, tests
constructed by automated test generation tools or those that
are considered to be of poor quality or low coverage by their
developers.
Our results are primarily of interest to mutation testing
researchers and designers of mutation testing systems1. For
example, if further research can identify procedures that nd
more SSHOMs and, thereby, subsume a larger set of FOMs,
then the eectiveness and eciency improvements we report
would have a signicant impact, reducing the oracle cost and
increasing test eectiveness. Future work may also consider
whether static analyses can be adapted to predict the com-
binations of FOMs that would likely lead to SSHOMs. If
so, then the 45% reduction in the numbers of mutants re-
quired would have a signicant eect on the cost of mutation
testing (even when oracle testing can be fully automated).
6. RELATED WORK
Mutation testing has been used to assess test quality for a
wide range of systems [3, 47, 48], to compare test adequacy
criteria [2, 11, 35, 34], and to generate tests [9, 14] (and test
oracle [9, 13, 46]). It has also be used to guide test genera-
tion and selection using non-mutation based techniques [8,
19, 52]. There are several publicly available tools for mu-
tation testing [6, 21, 45, 30] and mutation faults have been
demonstrated to be reasonable simulations of real faults [1,
25]. A recent comprehensive survey of mutation testing is
provided by Jia and Harman [23].
There has recent interest in mutant subsumption as a
means of improving mutation eectiveness by removing sub-
sumed mutants from consideration for rst order mutation
testing [24, 27]. The idea of subsuming higher order muta-
tion was rst proposed by Jia and Harman [20, 22]. They in-
troduced the concept of subsuming and strongly subsuming
HOMs and suggested to combine higher order mutants and
non-trivial rst order mutants together for mutation test-
ing. The present paper is the st to report results strongly
subsuming mutants and their relationship to the rst order
mutants they subsume.
Interest in the higher order mutation testing paradigm has
grown in recent years, with many results [4, 26, 31, 33, 38,
40, 41]. We summarise these results and their relationship
to our work in the remainder of this section.
Polo et al. [41] investigated second order mutants. They
proposed dierent algorithms to combine rst order mutants
to generate second order mutants. By applying the second
order mutants, test eort was reduced by 50%, without great
loss of test eectiveness. However, Polo et al. did not use
search based optimization and so they were limited to small
number of lower order mutants.
1All results can be found at the paper's companion website:
http://www0.cs.ucl.ac.uk/staff/Y.Jia/projects/ase14/Mateo et al. [33] extended this work with additional
combination strategies for second order mutants. Neither
of these papers used strong subsumption, so they achieve
greater eciency improvements than those reported in the
present paper, but with a (small) decrease in eectiveness
rather than a (small) increase in eectiveness.
Jia and Harman [20] and Omar et al. [38] studied the
way in which a HOM could combine FOMs in subtle ways.
While Jia and Harman generated subtle HOMs for the C
language, Omar et al. extended this to Java and AspectJ.
Fault subtlety comes from the way in which the HOM's con-
stituent FOMs are mutually partially masking. Langdon et
al. [29] found HOMs using a grammar-based, bi-objective,
strongly typed genetic programming system. Their two ob-
jectives are killability and diversity, which found realistic
HOMs that are harder to kill than any of the FOMs in four
C subject systems. However, they neither investigated nor
reported on strong subsumption.
Higher order mutation may also reduce the eects of the
equivalent mutant problem [49], in which a mutant is syn-
tactically dierent yet semantically identical to the original
program from which it is constructed. Outt [36] was the
rst to suggest that HOMs might be less likely to be equiva-
lent than FOMs. This observation was also conrmed in the
subsequent work of Papadakis and Malevris on second order
mutation [40]. More recently, Kintis et al. also showed that
impact analysis (with second order mutants) can be used
to detect rst order equivalent mutants [26]. In the present
paper, we are concerned only with non-equivalent mutants,
since we wish to study strongly subsuming higher order mu-
tants and the rst order mutants that they subsume.
7. CONCLUSIONS AND FUTURE WORK
This paper studied the SSHOMs found in four real world
Java systems. We found that, using SSHOMs in place of
the FOMs they subsume results in a requirement for many
fewer mutants (up to 45% fewer) and that test eciency can
be improved by approximately 14%, while test eectiveness
is simultaneously improved by between 5.6% and 12%.
We also found that SSHOMs can be exceptionally hard
to detect. These SSHOMs are `monster faults' that remain
undetected by the entire test suite selected to kill all FOMs,
yet their constituent FOMs are `angelic faults' that are easy
to kill and therefore oer little resistance to testing. Nev-
ertheless, despite their potency, the SSHOMs we found do
still need to be combined with some (unsubsumed) FOMs
in order to achieve full mutation adequacy.
Our tness function merely samples strongly subsuming
HOMS from a set of subsuming HOMs. We do not specif-
ically search for strong subsumption, merely subsumption,
so our results form a lower bound on the improvement in
eectiveness and eciency that might accrue from strong
subsumption.
Though we have demonstrated that monster faults can be
constructed from angelic faults, we have surely not found
the best construction algorithm. We hope and believe that
future work will see the benets of HOMs migrating from
research to practice with wider incorporation of higher order
mutation in testing tools. We also expect future research will
nd better targeted tness functions that seek out various
forms of strong subsumption.
4068. REFERENCES
[1] J. H. Andrews, L. C. Briand, and Y. Labiche. Is
Mutation an Appropriate Tool for Testing
Experiments? In Proceedings of the 27th International
Conference on Software Engineering (ICSE'05), pages
402 { 411, St Louis, Missouri, 15-21 May 2005.
[2] J. H. Andrews, L. C. Briand, Y. Labiche, and A. S.
Namin. Using Mutation Analysis for Assessing and
Comparing Testing Coverage Criteria. IEEE
Transactions on Software Engineering, 32(8):608{624,
August 2006.
[3] A. Bartel, B. Baudry, F. Munoz, J. Klein, T. Mouelhi,
and Y. L. Traon. Model driven mutation applied to
adaptive systems testing. In Mutation Testing
Workshop , pages 408{413, 2011.
[4] F. Belli, N. G uler, A. Hollmann, G. Suna, and
E. Yoldoz. Model-Based Higher-Order Mutation
Analysis. In Advances in Software Engineering,
volume 117 of Communications in Computer and
Information Science , pages 164{173. Springer Berlin
Heidelberg, 2010.
[5] J. Cohen. Statistical Power Analysis for the
Behavioral Sciences (second ed.) . Lawrence Erlbaum
Associates, New Jersey, 1988.
[6] M. E. Delamaro, J. C. Maldonado, and A. Vincenzi.
Proteum/IM 2.0: An Integrated Mutation Testing
Environment. In Proceedings of the 1st Workshop on
Mutation Analysis (MUTATION'00) , pages 91{101,
San Jose, California, 6-7 October 2001. published in
book form, as Mutation Testing for the New Century.
[7] R. A. DeMillo, R. J. Lipton, and F. G. Sayward. Hints
on test data selection: Help for the practical
programmer. IEEE Computer , 11:31{41, 1978.
[8] G. Fraser and F. Wotawa. Using model-checkers for
mutation-based test-case generation, coverage analysis
and specication analysis. In International Conference
on Software Engineering Advances (ICSEA 2006) ,
pages 1{16, 2006.
[9] G. Fraser and A. Zeller. Mutation-driven generation of
unit tests and oracles. In International Symposium on
Software Testing and Analysis (ISSTA 2010) , pages
147{158, Trento, Italy, 2010. ACM.
[10] F. G. Freitas and J. T. Souza. Ten years of search
based software engineering: A bibliometric analysis. In
3rdInternational Symposium on Search based Software
Engineering (SSBSE 2011) , pages 18{32, 10th - 12th
September 2011.
[11] M. Gligoric, A. Groce, C. Zhang, R. Sharma, M. A.
Alipour, and D. Marinov. Comparing non-adequate
test suites using coverage criteria. In M. Pezz e and
M. Harman, editors, International Symposium on
Software Testing and Analysis (ISSTA 2013) , pages
302{313, Lugano, Switzerland, 2013. ACM.
[12] D. E. Goldberg. Genetic Algorithms in Search,
Optimization & Machine Learning . Addison-Wesley,
Reading, MA, 1989.
[13] B. J. M. Gr un, D. Schuler, and A. Zeller. The Impact
of Equivalent Mutants. In Proceedings of the 4th
International Workshop on Mutation Analysis
(MUTATION'09) , pages 192{199, Denver, Colorado,
1-4 April 2009. IEEE Computer Society. published
with Proceedings of the 2nd International Conferenceon Software Testing, Verication, and Validation
Workshops .
[14] M. Harman, Y. Jia, and B. Langdon. Strong higher
order mutation-based test data generation. In 8th
European Software Engineering Conference and the
ACM SIGSOFT Symposium on the Foundations of
Software Engineering (ESEC/FSE '11) , pages
212{222, New York, NY, USA, September 5th - 9th
2011. ACM.
[15] M. Harman, Y. Jia, and W. B. Langdon. A manifesto
for higher order mutation testing. In 5thInternational
Workshop on Mutation Analysis (Mutation 2010) ,
Paris, France, April 2010.
[16] M. Harman, A. Mansouri, and Y. Zhang. Search based
software engineering: Trends, techniques and
applications. ACM Computing Surveys ,
45(1):11:1{11:61, November 2012.
[17] M. Harman, P. McMinn, M. Shahbaz, and S. Yoo. A
comprehensive survey of trends in oracles for software
testing. Technical Report Research Memoranda
CS-13-01, Department of Computer Science,
University of Sheeld, 2013.
[18] M. Harman, P. McMinn, J. Souza, and S. Yoo. Search
based software engineering: Techniques, taxonomy,
tutorial. In B. Meyer and M. Nordio, editors,
Empirical software engineering and verication:
LASER 2009-2010 , pages 1{59. Springer, 2012. LNCS
7007.
[19] S.-S. Hou, L. Zhang, T. Xie, H. Mei, and J.-S. Sun.
Applying Interface-Contract Mutation in Regression
Testing of Component-Based Software. In Proceedings
of the 23rd International Conference on Software
Maintenance (ICSM'07) , pages 174{183, Paris,
France, 2-5 October 2007.
[20] Y. Jia and M. Harman. Constructing Subtle Faults
Using Higher Order Mutation Testing. In Proceedings
of the 8th International Working Conference on
Source Code Analysis and Manipulation (SCAM'08) ,
pages 249{258, Beijing, China, 28-29 September 2008.
[21] Y. Jia and M. Harman. Milu: A customizable,
runtime-optimized higher order mutation testing tool
for the full C language. In 3rdTesting Academia and
Industry Conference - Practice and Research
Techniques (TAIC PART'08) , pages 94{98, Windsor,
UK, August 2008.
[22] Y. Jia and M. Harman. Higher Order Mutation
Testing. Journal of Information and Software
Technology , 51(10):1379{1393, October 2009.
[23] Y. Jia and M. Harman. An Analysis and Survey of the
Development of Mutation Testing. IEEE Transactions
of Software Engineering, 37(5):649{678, 2011.
[24] R. Just, M. D. Ernst, and G. Fraser. Ecient
mutation analysis by propagating and partitioning
infected execution states. In International Symposium
on Software Testing and Analysis (ISSTA 2014) , San
Jose, CA, USA, 2014. To appear.
[25] R. Just, D. Jalali, L. Inozemtseva, M. D. Ernst,
R. Holmes, and G. Fraser. Are mutants a valid
substitute for real faults in software testing? Technical
Report UW-CSE-14-02-02, University of Washington,
2014.
407[26] M. Kintis, M. Papadakis, and N. Malevris. Isolating
rst order equivalent mutants via second order
mutation. In Proceedings of the 2012 IEEE Fifth
International Conference on Software Testing,
Verication and Validation , ICST '12, pages 701{710,
Washington, DC, USA, 2012. IEEE Computer Society.
[27] B. Kurtz, P. Ammann, M. E. Delamaro, J. Outt, and
L. Deng. Mutant subsumption graphs. In 10th
Mutation Testing Workshop (Mutation 2014),
Cleveland Ohio, USA, March 2014. To appear.
[28] K. Lakhotia, P. McMinn, and M. Harman. Automated
test data generation for coverage: Haven't we solved
this problem yet? In 4thTesting Academia and
Industry Conference | Practice And Research
Techniques (TAIC PART'09) , pages 95{104, Windsor,
UK, 4th{6th September 2009.
[29] W. B. Langdon, M. Harman, and Y. Jia. Ecient
multi objective higher order mutation testing with
genetic programming. Journal of Systems and
Software , 83(12):2416{2430, 2010.
[30] Y.-S. Ma, A. J. Outt, and Y.-R. Kwon. MuJava: a
Mutation System for Java. In Proceedings of the 28th
international Conference on Software Engineering
(ICSE '06) , pages 827{830, Shanghai, China, 20-28
May 2006.
[31] P. Madiraju and A. S. Namin. ParaMu - A Partial
and Higher-Order Mutation Tool with Concurrency
Operators. In Proceedings of the 6th International
Workshop on Mutation Analysis (Mutation 2011) ,
Berlin, Germany, March 2011.
[32] P. R. Mateo and M. P. Usaola. Mutant execution cost
reduction: Through music (mutant schema improved
with extra code). In Proceedings of the 7th Workshop
on Mutation Analysis (MUTATION'12) , pages
664{672, Los Alamitos, CA, USA, 2012. IEEE
Computer Society.
[33] R. P. Mateo, P. U. Macario, F. Alem an, and J. Luis.
Validating second-order mutation at system level.
IEEE Transactions of Software Engineering , 39(4):570
{ 587, April 2013.
[34] A. S. Namin and J. H. Andrews. The Inuence of Size
and Coverage on Test Suite Eectiveness. In
Proceedings of the18th International Symposium on
Software Testing and Analysis (ISSTA'09) , pages
57{68, Chicago, Illinois, USA, 19-23 July 2009.
[35] A. S. Namin, J. H. Andrews, and D. J. Murdoch.
Sucient Mutation Operators for Measuring Test
Eectiveness. In Proceedings of the 30th International
Conference on Software Engineering (ICSE'08), pages
351{360, Leipzig, Germany, 10-18 May 2008.
[36] A. J. Outt. Investigations of the Software Testing
Coupling Eect. ACM Transactions on Software
Engineering and Methodology , 1(1):5{20, January
1992.
[37] A. J. Outt, G. Rothermel, and C. Zapf. An
experimental evaluation of selective mutation. In 15th
International Conference on Software Engineering
(ICSE 1993) , pages 100{107. IEEE Computer Society
Press, Apr. 1993.
[38] E. Omar, S. Ghosh, and D. Whitley. Constructing
subtle higher order mutants for Javer and AspectJ
programs. In International Symposium on SoftwareReliability Engineering (ISSRE'13) , pages 340{349.
IEEE, 2013.
[39] E. Omar, S. Ghosh, and D. Whitley. Comparing search
techniques for nding subtle higher order mutants. In
Conference on Genetic and Evolutionary Computation
(GECCO 2014) , pages 1271{1278. ACM, 2014.
[40] M. Papadakis and N. Malevris. An Empirical
Evaluation of the First and Second Order Mutation
Testing Strategies. In 5thMutation Testing Workshop
(Mutation'10) , Paris, France, 2010.
[41] M. Polo, M. Piattini, and I. Garcia-Rodriguez.
Decreasing the Cost of Mutation Testing with
Second-Order Mutants. Software Testing, Verication
and Reliability , 19(2):111 { 131, June 2008.
[42] G. Rothermel, M. Harrold, J. Ronne, and C. Hong.
Empirical studies of test suite reduction. Software
Testing, Verication, and Reliability , 4(2):219{249,
December 2002.
[43] G. Rothermel and M. J. Harrold. Analyzing regression
test selection techniques. IEEE Transactions on
Software Engineering, 22(8):529{551, Aug. 1996.
[44] N. J. Salkind. Encyclopedia of Measurement and
Statistics . Sage publications, Inc., California, USA,
2007.
[45] D. Schuler and A. Zeller. Javalanche: ecient
mutation testing for java. In 7thjoint meeting of the
European Software Engineering Conference and the
ACM SIGSOFT International Symposium on
Foundations of Software Engineering (ESEC/FSE
2009) , pages 297{298, 2009.
[46] M. Staats, G. Gay, and M. P. E. Heimdahl. Automated
oracle creation support, or: How I learned to stop
worrying about fault propagation and love mutation
testing. In 34thInternational Conference on Software
Engineering (ICSE 2012) , pages 870{880, 2012.
[47] J. Tuya, M. J. S. Cabal, and C. de la Riva. Mutating
Database Queries. Information and Software
Technology , 49(4):398{417, April 2007.
[48] R. H. Untch, A. J. Outt, and M. J. Harrold.
Mutation Analysis Using Mutant Schemata. In
Proceedings of the International Symposium on
Software Testing and Analysis (ISSTA'93) , pages
139{148, Cambridge, Massachusetts, 1993.
[49] X. Yao, M. Harman, and Y. Jia. A study of equivalent
and stubborn mutation operators using human
analysis of equivalence. In 36thInternational
Conference on Software Engineering (ICSE 2014),
pages 919{930, Hyderabad, India, June 2014.
[50] S. Yoo and M. Harman. Regression testing
minimisation, selection and prioritisation: A survey.
Journal of Software Testing, Verication and
Reliability , 22(2):67{120, 2012.
[51] L. Zhang, D. Hao, L. Zhang, G. Rothermel, and
H. Mei. Bridging the gap between the total and
additional test-case prioritization strategies. In 35th
International Conference on Software Engineering
(ICSE 2013) , pages 192{201, San Francisco, CA, USA,
May 2013.
[52] L. Zhang, D. Marinov, L. Zhang, and S. Khurshid.
Regression mutation testing. In International
Symposium on Software Testing and Analysis, (ISSTA
2012) , pages 331{341, 2012.
408