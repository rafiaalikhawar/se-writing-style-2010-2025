Lexical Statistical Machine Translation
for Language Migration
Anh Tuan Nguyen
anhnt@iastate.eduTung Thanh Nguyen
tung@iastate.eduTien N. Nguyen
tien@iastate.edu
Electrical and Computer Engineering Department
Iowa State University
Ames, IA 50011, USA
ABSTRACT
Prior research has shown that source code also exhibits nat-
uralness, i.e. it is written by humans and is likely to be
repetitive. The researchers also showed that the n-gram lan-
guage model is useful in predicting the next token in a source
le given a large corpus of existing source code. In this pa-
per, we investigate how well statistical machine translation
(SMT) models for natural languages could help in migrat-
ing source code from one programming language to another.
We treat source code as a sequence of lexical tokens and
apply a phrase-based SMT model on the lexemes of those
tokens. Our empirical evaluation on migrating two Java
projects into C# showed that lexical, phrase-based SMT
could achieve high lexical translation accuracy ( BLEU from
81.3-82.6%). Users would have to manually edit only 11.9-
15.8% of the total number of tokens in the resulting code to
correct it. However, a high percentage of total translation
methods (49.5-58.6%) is syntactically incorrect. Therefore,
our result calls for a more program-oriented SMT model that
is capable of better integrating the syntactic and semantic
information of a program to support language migration.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance,
and Enhancement
General Terms
Algorithms, Documentation, Experimentation, Measurement
Keywords
Language Migration, Statistical Machine Translation
1. INTRODUCTION
Nowadays, the same software could appear in multiple
platforms and environments. For example, with the fast
growing market of mobile devices, a software product needs
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ESEC/FSE ‚Äô13, August 18‚Äì26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08 ...$15.00.to be migrated from one programming language in a plat-
form to another. Companies and organizations often orig-
inally developed software in a language and then migrated
it to another to address their business needs. Manually mi-
grating projects between languages is time-consuming and
error-prone [16]. Existing (semi-)automatic language migra-
tion approaches [6, 15] are based on predened translation
rules for the constructs and APIs between two languages.
Those methods expect users to manually specify such rules ,
which is also a tedious and error-prone task. Since there are
a large number of mappings such as those among APIs pro-
vided in dierent languages, manual rule denition is time-
consuming, insucient, and not scalable.
Aiming to reduce such manual eort, we have investigated
statistical machine translation (SMT) approaches. SMT is a
machine translation paradigm where translations are gener-
ated on the basis of statistical models whose parameters are
derived from the analysis of a corpus in two corresponding
languages [4, 7]. The motivation for our approach of using
SMT is the naturalness of source code [5]. Hindle et al. [5]
have shown that source code also exhibits naturalness as in a
document written in a natural language, i.e., source code is
written by humans and is likely to be repetitive. The authors
also showed that the n-gram language model is useful in pre-
dicting the next token in a source le given a large corpus
of existing source code. With the repetitiveness in source
code, we expect that natural language processing methods
such as SMT could be applicable to language migration.
In this paper, we focus on how well SMT could translate
source code. More specically, in this work, we studied the
method-to-method migration from Java to C#. We treat
source code as a sequence of lexical tokens. A method is
considered as a sentence, and each code token as a word. To
extract the tokens, the lexers for Java or C# are applied on
each method. Only the lexemes of code tokens are used. We
then applied a phrase-based SMT model, named Phrasal [1],
on the lexemes of those tokens to migrate two open-source
Java projects. We call this approach lexical , phrase-based
SMT ( lpSMT for short). Our results show that lpSMT
achieves high lexical translation accuracy in language migra-
tion for source code . It achieves BLEU values [7] (a metrics on
accuracy of phrase-to-phrase translation) from 81.3-82.6%
and token editing distance ratios from 11.9-15.8%. That is,
users would have to edit 11.9-15.8% of the total number of
tokens in the resulting code to make it correct. However,
despite high translation accuracy, a high percentage (49.5-
58.6%) of all translation methods is syntactically incorrect,
resulting many parsing errors. Examining the results, wePermission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSE‚Äô13 , August 18‚Äì26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08...$15.00
http://dx.doi.org/10.1145/2491411.2494584
651
Table 1: Subject Systems
Project Java C# M.Meth
Ver File Meth Ver File Meth
db4o [3] 7.2 2,640 20,868 7.2 2,072 14,669 9,126
Lucene [8] 2.4.0 958 8,992 2.4.0 628 5,598 4,027
found that the key reason is lpSMT operating only at the
lexical level. Therefore, our result calls for a more program-
oriented SMT model that is capable of better integrating the
syntactic and semantic information of a program to support
language migration. The contributions of this paper include
1.A lexical SMT-based language migration approach
from Java to C#, and
2.An empirical evaluation on the applicability of SMT in
language migration for source code.
Section 2 discusses related work. Our study on applying
SMT to source code is in Section 3. We conclude by analyz-
ing the results and discussing our future work on integrating
syntactic and semantic information to the SMT process.
2. RELATED WORK
Java2CSharp [6] is a tool that translates a Java program
to C#. It relies on the set of rules between the syntactic
units in two languages. In comparison, its approach is de-
terministic, while ours is statistical learning-based. lpSMT
does not require the pre-dened translation rules. However,
it requires a training data of the systems and their translated
versions. In brief, lpSMT model statistically and implicitly
learns the translation \rules" and leverages them and a lan-
guage model to migrate the code without requiring manual
denition of rules as in rule-based translators [6]. Zhong et
al.[16] mine API mapping rules for language migration by
relying on textually similar names and similar calling struc-
tures among APIs in two languages. Yasumatsu and Doi
[15]'s tool automatically translates Smalltalk code to C by
creating runtime replacement classes implementing the same
functionality of Smalltalk classes that are inherently part
of its execution model. In Waters' [13] paradigm, a source
program is rst analyzed to obtain a programming language-
independent procedure and then re-implemented in the tar-
get language. Mossienko [10] performs source translation
from Cobol to Java via syntactic rule-based approach.
As software is ported to use a new library, developers have
to migrate their code to use the new one. Several approaches
have been proposed to mine the migration rules in API li-
braries/frameworks [2, 9, 11, 14].
3. LEXICAL, PHRASE-BASED SMT
In this work, we focus on migrating Java code to C#.
This section presents our study on applying the phrase-based
SMT model in translating source code from Java to C#.
3.1 Data Collection and Settings
We collected two open-source subject systems which were
originally developed for Java and ported to C# (Table 1).
They are well-established systems with long developing his-
tories and both of their Java and C# versions have been in
use. These two projects, db4o and Lucene , have also been
used in prior research in mining language migration rules by
Zhong et al. [16]. Columns Java.Ver and C#.Ver show the
corresponding versions in two languages. We conrmed thecorresponding versions by reading the associated documen-
tation and code. Columns Fileand Meth show the numbers
of les and methods in each revision for each language.
We chose to evaluate the translation at the method level,
i.e. from methods to methods. We did not choose a ner-
grained level (e.g. statements) since it would be less prac-
tical and more time-consuming to build the training data
for statement-to-statement translation. Moreover, to trans-
late a Java class to C#, one would translate its method and
eld declarations to the corresponding ones. Importantly,
to build the training data for the corresponding methods in
two versions, we were able to use a semi-automatic approach
that is time ecient as our subject projects are large.
To do that, we built a simple semi-automatic tool to search
for the similar class names and method signatures in the
similar directory structure in two versions for Java and C#.
The reason is that in those projects, most of the names of
the corresponding packages, classes, methods, and method
signatures in both versions are similar. In addition, because
the corresponding versions of a project include also dierent
supporting libraries and utility methods in two languages,
and/or contain little extra or less functionality, there are
methods in both Java and C# versions that do not have the
corresponding ones. Thus, we manually veried to ensure
that the method pairs are in fact the corresponding ones.
Incorrect pairs were discarded. We also veried the code in
the packages that were not aligned by the tool. The correct
mappings among them were kept. Many packages for delet-
ed/added functionality were easily identied and discarded.
Column M.Meth shows the number of aligned methods be-
tween the two versions for each subject project.
3.2 Training/Translating with lpSMT
For each project, the aligned method pairs between Java
and C# versions were used for training and translating with
lpSMT model. We applied ten-fold cross validation by divid-
ing all aligned methods into ten folds with equal numbers of
methods. For each fold used for testing, we used other nine
folds for training. We used Phrasal [1], a well-known lexi-
cal, phrase-based SMT tool. Its theoretical foundation was
presented in [7]. The basic linguistic units in Phrasal are sen-
tences, each of which consists of words separated from one
another by whitespaces. In our experiment, each method is
considered as a sentence, and each code token as a word. To
separate tokens from one another, we ran the lexers for Java
and C# on the methods. Whitespaces within string literals
were replaced by special characters.
In training, Phrasal takes as input the set of aligned meth-
ods in two languages, in which each method is lexically
analyzed into a sequence of lexical tokens. The output of
the training phase includes the model's parameters and the
mappings between the phrases in Java and C#. In trans-
lating/testing, Phrasal takes each method in the testing set
and produces the translation version in C#. Default setting
in Phrasal was used [1]. The resulting methods were then
compared against the corresponding methods in the oracle.
3.3 Quality Metrics
We used dierent metrics to evaluate translation quality:
1.BLEU . This is a popular metrics in SMT that measures
translation quality by the accuracy of translating n-grams
ton-grams with various values of n(phrases to phrases):652Table 2: Accuracy of lexical, phrase-based SMT
Project Tokens BLEU EDR SCR
db4o 374,034 82.6% 11.9% 50.5%
Lucene 258,580 81.3% 15.8% 41.4%
BLEU =BP:e1
n(logP1+:::+logPn)[12]
where BPis the brevity penalty value , which equals to 1 if
the total length (i.e. the number of words) of the resulting
sentences is longer than that of the reference sentences (i.e.
the correct sentences in the oracle). Otherwise, it equals to
the ratio between those two lengths. Piis the metrics for
the overlapping between the bag of i-grams (repeating items
are allowed) appearing in the resulting sentences and that
ofi-grams appearing in the reference sentences. Specically,
ifSi
refandSi
trans are the bags of i-grams appearing in the
reference code and in the translation code respectively, Pi=
jSi
ref\Si
trans j/jSi
trans j. The value of BLEU is between 0-1.
The higher it is, the higher the translation quality.
Since Pirepresents the accuracy in translating phrases
with iconsecutive words, the higher the value of iis used,
the better BLEU measures translation quality. For example,
assume that a translation Trhas a high P1value but a low P2.
That is, Trhas high word-to-word accuracy but low accuracy
in translating 2-grams to 2-grams (e.g. the word order might
not be respected in the result). Thus, using both P1andP2
will measure Trbetter than using only P1. If translation sen-
tences are shorter, BPis smaller and BLEU is smaller. If they
are too long and more incorrect words occur, Pivalues are
smaller, thus, BLEU is smaller. Pis are computed for i=1-4.
2.Token edit distance ratio ( EDR). This metrics mea-
sures eort that a user must edit in term of the code tokens
that need to be deleted/added in order to transform the re-
sulting code into the correct one. It is computed as: EDR
=P
methodsEditDistance (sR;sT)P
methodslength (sT), where EditDistance (sR; sT)
is the editing distance between each pair of the reference
method sRand the translation method sT; and the denom-
inator is the total length of all translation sentences.
3.Syntactic correctness ratio ( SCR). Syntactic cor-
rectness of translation code is measured by the ratio between
the number of translation methods that are parsable by a
standard C# parser over the total translation methods.
For each fold in ten-fold cross validation, we recorded
those metrics and calculated the average values in ten folds.
3.4 Results
Table 2 shows translation accuracy of the lpSMT model.
As seen, the model achieves a high BLEU value (81.3-82.6%),
i.e. it has high lexical phrase-to-phrase translation accuracy.
It achieves EDRfrom 11.9-15.8%. That is, a user would need
to edit about 11.9-15.8% of the total number of tokens in the
translation code to correct it. This result shows that statisti-
cal machine translation can be applied to language migration
in source code with high lexical translation accuracy . How-
ever, the number of syntactically incorrect methods is high.
49.5-58.6% of translation methods need syntactic correction.
3.5 Case Studies and Analysis
Let us present a few case studies and the key limitations
of the lpSMT model as being applied to the code lexemes.1// Java code: NativeClassFactory.java
2public Class forName(String className) throws
ClassNotFoundException;
3
4// C# code: INativeClassFactory.cs
5public Type ForName(string className);
6
7// Translated by lpSMT:
8public Type ForName (string className) TypeLoadException;
Figure 1: Method Declaration with Exception Declaration
1// Java code: ClientQueryResult.java
2public ClientQueryResult(Transaction ta, intinitialSize) f
3super (ta, initialSize);
4g
5
6// C# code: ClientQueryResult.cs
7public ClientQueryResult(Transaction ta, intinitialSize) : base(ta
, initialSize) fg
8
9// Translated by lpSMT:
10public ClientQueryResult(Transaction ta, intinitialSize) : base(ta
f, initialSize) ; g
Figure 2: Call to Parent Class' Constructor super(...)
Example 1. A Method Declaration with an Excep-
tion Declaration. Figure 1 shows an example in db4o
project as the lpSMT model translates a method declaration
with an exception declaration in the Java le NativeClassFac-
tory.java . The method forName is specied to receive a class
name as a String variable and returns the reference to that
class. If that reference does not exist, it will cause a ClassNot-
FoundException . This exception handling behavior is declared
in Java by the exception declaration in the signature of the
method as in throws ClassNotFoundException (line 2). In C#,
an exception declaration in the signature of the method is
not supported. Instead, a specic throw statement is de-
clared inside the method's body. Thus, in the correctly mi-
grated version of this method, the exception declaration is
removed from the method signature (line 5). As the lpSMT
model translates this method, it removed the keyword throws
since it has seen in the training data such removal of that
keyword. However, it still translates the term ClassNotFound-
Exception into TypeLoadException in C#. Thus, lpSMT in this
case created a syntactically incorrect method declaration.
In brief, lpSMT can statistically learn the\rule"to remove
the lexeme throws , however, it is unable to learn the \rule" to
remove the entire syntactic unit of an exception declaration
(throws ClassNotFoundException ) in the method declaration.
Example 2. Call to Parent Class' Constructor super(...).
Figure 2 shows another example as the lpSMT model trans-
lates a call to the constructor of a parent class via super (lines
2-4). In Java, a call to super is made inside the method's
body. In contrast, in C#, a call to the constructor is made
viabaseand occurs in the method signature, i.e. prior to the
method's body as in base(ta,initialSize) (line 7). However, in
the translation version, this call was broken into two pieces:
one in the method signature 'base(ta' and one in the method
body ', initialSize);' (line 10). Thus, the translation code is
syntactically incorrect. In this case, lpSMT translated based
on the lexemes of tokens in the method signature and the
body, however, does not consider the entire syntactic unit of
a constructor call to the parent class in super for translation.6531// Java code: FormatMigrationTestCaseBase.java
2private void createDatabase(String le) f
3 if(File4.exists(le)) f
4 File4.delete(le);
5 g...
6g
7// C# code: FormatMigrationTestCaseBase.cs
8private void CreateDatabase(string le) f
9 if(System.IO.File.Exists(le)) f
10 File4.Delete(le);
11 g...
12g
13// Translated by lpSMT:
14private void CreateDatabase(string le) f
15 if(System.IO.File.Exists(le) f
16 File4.Delete(le);
17 g...
18g
Figure 3: Missing Tokens due to Limited Phrases' Sizes
Example 3. Long Phrases. Figure 3 shows a case that
the result has a missing close parenthesis at the end of the
condition of the ifstatement (line 15). The reason for such
syntactic error is the limited sizes of the phrases in an SMT
model. Expanding the maximum sizes of the phrases would
x the problem, however, might cause a performance issue.
3.6 Discussions on Future Work
This result shows that statistical machine translation is a
promising approach and could be applied well to language
migration in source code. Just considering source code as a
sequence of lexical tokens, lpSMT could achieve good lexical
translation accuracy and a small token edit distance ratio.
However, the code resulting from running an SMT model on
lexical code tokens is still far from perfect.
1. Almost half of the resulting methods have syntactic
errors. Thus, we need a method to integrate the syntac-
tic information from the languages into the translation pro-
cess. Unlike a natural language, a programming language
has well-dened syntactic rules and unambiguous semantics.
The grammar rules of two programming languages could be
used to direct the translation process. Syntactic units could
be translated and played the roles of the placeholders for a
later migration process for the tokens within each of them.
2. No semantic information on source code is currently
taken into account in lpSMT. It uses only the lexemes from
code tokens. Our future direction will be to use program
analysis to extract the semantic information of program ele-
ments such as their types, roles, etc. Such information could
help the model better align the code within each placeholder.
3. We are also investigating an approach that statistically
aligns tree-based structures among the source and the target
les in two languages. Current SMT approach focuses on the
alignment of the phrases in natural language documents.
4. Post-processing could be applied to correct the result-
ing code as well. Such a process could use program analysis
techniques to make sure the migrated code correct. Test
cases could also be used to validate the resulting code.
Our future work includes the aforementioned directions to
improve SMT to produce higher quality translation code.
4. CONCLUSIONS
In this paper, we investigate how well statistical machine
translation (SMT) could help in language migration. Ourstudy shows that applying phrase-based SMT on code lex-
emes can achieve high lexical translation accuracy. However,
a high percentage of translation methods is syntactically
incorrect. Therefore, our result calls for a more program-
oriented SMT model that better integrates the syntactic and
semantic information of a program to support language mi-
gration. We also discussed several directions for such an
integration that we will investigate in our future work.
5. ACKNOWLEDGMENTS
This project is funded in part by US National Science
Foundation (NSF) CCF-1018600 and CNS-1223828 grants.
6. REFERENCES
[1] D. Cer, M. Galley, D. Jurafsky, and C. D. Manning.
Phrasal: A statistical machine translation toolkit for
exploring new model features. In Proceedings of the
NAACL HLT 2010 Demonstration Session , pages
9{12, 2010. Association for Computational Linguistics.
[2] B. Dagenais and M. P. Robillard. Recommending
adaptive changes for framework evolution. In ICSE'08:
Proceedings of the 30th International Conference on
Software Engineering , pages 481{490. ACM, 2008.
[3] db4o. http://sourceforge.net/projects/db4o/.
[4] Google Translate. http://translate.google.com/.
[5] A. Hindle, E. T. Barr, Z. Su, M. Gabel, and
P. Devanbu. On the naturalness of software. In
Proceedings of International Conference on Software
Engineering , ICSE'12, pp. 837{847. IEEE Press, 2012.
[6] Java2CSharp.
http://j2cstranslator.wiki.sourceforge.net/.
[7] P. Koehn. Statistical Machine Translation . The
Cambridge Press, 2010.
[8] Lucene. http://lucene.apache.org/.
[9] S. Meng, X. Wang, L. Zhang, and H. Mei. A
history-based matching approach to identication of
framework evolution. In ICSE'12, pp. 353{363. IEEE.
[10] M. Mossienko. Automated Cobol to Java recycling. In
Proceedings of European Conference on Software
Maintenance and Reengineering , CSMR'03. IEEE.
[11] M. Nita and D. Notkin. Using twinning to adapt
programs to alternative APIs. In Proceedings of
ACM/IEEE International Conference on Software
Engineering , ICSE '10, pages 205{214. ACM, 2010.
[12] K. Papineni, S. Roukos, T. Ward, and W.-J. Zhu.
BLEU: a method for automatic evaluation of machine
translation. In Proceedings of the 40th Annual Meeting
on Association for Computational Linguistics ,
ACL'02, pages 311{318. 2002.
[13] R. C. Waters. Program translation via abstraction and
reimplementation. IEEE Trans. Softw. Eng. ,
14(8):1207{1228, Aug. 1988.
[14] W. Wu, Y.-G. Gu eh eneuc, G. Antoniol, and M. Kim.
AURA: a hybrid approach to identify framework
evolution. In ICSE '10, pages 325{334. ACM, 2010.
[15] K. Yasumatsu and N. Doi. Spice: A system for
translating Smalltalk programs into a C environment.
IEEE Trans. Softw. Eng. , 21(11):902{912, Nov. 1995.
[16] H. Zhong, S. Thummalapenta, T. Xie, L. Zhang, and
Q. Wang. Mining API mapping for language
migration. In ICSE'10, pages 195{204. ACM, 2010.654