Imperative versus Declarative Collection Processing: An RCT on
the Understandability of Traditional Loops versus the Stream
API in Java
Nils Mehlhorn
Independent Consultant, Essen
mail@nils-mehlhorn.deStefan Hanenberg
Paluno - The Ruhr Institute for Software Technology,
University of Duisburgâ€“Essen, Germany
stefan.hanenberg@uni-due.de
ABSTRACT
Java introduced in version 8 with the Stream API means to operate
on collections using lambda expressions. Since then, this API is an
alternative way to handle collections in a more declarative manner
instead of the traditional, imperative style using loops. However,
whethertheStreamAPIisbeneficialincomparisontoloopsinterms
of usability is unclear. The present paper introduces a randomized
controltrial(RCT)ontheunderstandabilityofcollectionoperations
performedon20participantswiththedependentvariablesresponsetimeandcorrectness.Astasks,subjectshadtodeterminetheresultsforcollectionoperations(eitherdefinedwiththeStreamAPIorwith
loops). The results indicate that the Stream API has a significant
(p<.001) and large ( ðœ‚2ð‘=.695;ð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘šâˆ¼178%) positive effect on the
responsetimes.Furthermore,theusageoftheStreamAPIcaused
significantlylesserrors.Andfinally,theparticipantsperceivedtheirspeedwiththe StreamAPIhighercomparedtotheloop-basedcode
and the participants considered the code based on the Stream API
asmorereadable.Hence,whileexistingstudiesfoundanegative
effect of declarative constructs (in terms of lambda expressions) on
the usability of a main stream programming language, the present
study found the opposite: the present study gives evidence thatdeclarative code on collections using the Stream API based onlambda expressions has a large, positive effect in comparison to
traditional loops.
KEYWORDS
Programming Languages, Lambda Expressions, Declarative, Imper-
ative, Java, Streams
ACM Reference Format:
Nils Mehlhorn and Stefan Hanenberg. 2022. Imperative versus Declarative
Collection Processing: An RCT on the Understandability of Traditional
Loops versus the Stream API in Java. In 44th International Conference on
Software Engineering (ICSE â€™22), May 21â€“29, 2022, Pittsburgh, PA, USA. ACM,
New York, NY, USA, 12 pages. https://doi.org/10.1145/3510003.3519016
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.35190161 INTRODUCTION
In programming, the use of collections, i.e. lists or sets of values
(or objects) is quite essential. However, different kinds of program-
ming languages provide different means to operate on collections.
In imperative programming languages, there are typically loop
constructs thatpermit (incombination withadditional operators)
toiterateoveracollectioninorderto,forexample,selectcertain
elementsortomapthecollectiontosomeothervalues.Atypical
exampleofsuchanapproachisthefor-loopthatcomesindifferent
styles and syntaxes and that can be found in almost all imperative
programming languages from BASIC over C up to Java. Declara-
tive programming languages, on the other hand, typically follow a
differentapproachwheretheiterationoveracollectionishidden
by someabstraction that receivesa condition that needs tohold on
the results. In functional programming languages, such conditions
are typically given using lambda expressions.1
While rather imperative programming languages such as
Smalltalk supported lambda expressions right from the beginning,
popularlanguagessuchasJavaorC++supportedlambdaexpres-
sions relatively late. In the case of Java, the alternative to the tradi-
tionalloopsappearedwithJava8in20132wherelambdaexpres-
sions were introduced in addition to the Stream API that made use
of lambda expressions.3
Figure1illustratestwoalternativestofilterobjectsfromacollec-
tionusingeitherloopsortheStreamAPI.Theloopimplementation
requiresfirstadefinitionoftheresultcollection.Then,theinput
collection is iterated and for each element it is checked (via an
if-statement) whether the age is 21 or higher. If this is the case, the
objectisaddedtotheresultcollection.Forthestreamimplemen-
tation, a stream has to be received from the collection by callingthe method
stream() . Then, the filter method is invoked with a
lambdaexpression(representingthebooleanexpressionthathas
to match each element of the result). Finally, the result is collected
(in the example into a list).
In Java, the stream code is quite verbose because of the addi-
tional stream() andcollect() invokations which is the result of
a strict distinction between the Collection API and the Stream API.
Inotherlanguagessuchas,forexample,Smalltalk(thatprovides
1The theoretical background for functional programming is the lambda calculus that
has lambda expressions as one of the core language features (see for example [ 31]
forageneralintroductionintothelambdacalculusanditsapplicationformodeling
programming languages).
2The language specification was published in 2014 [16].
3Technically,StreamAPIdoesnotnecessarilyrequiretheapplicationoflambdaex-
pressions, i.e. it is also possible to use inner classes. However, it seems quite common
not to use inner classes for in the Stream API and use lambda expressions instead.
11572022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Nils Mehlhorn and Stefan Hanenberg
methodscomparableto filter() inJava)theresultingcodewould
be slightly shorter, because the two mentioned method calls are
not necessary.
Collection<Person> persons = ...
Collection<Person> a dults = ...;
// (a) Traditional filter o peration using loops
for(Person person: persons)
if(person.age() >=21)
adults.add( person);
// (b) Filtering a collection using the Stream API
adults = persons.stream()
.filter(p âˆ’>p.age()>=21)
.collect(Collectors.toList ());
Figure1:FilteringobjectsfromacollectioninJavausing(a)
loops and (b) the Stream API.
IfwecomparethecodeusingloopsandtheStreamAPIinFigure
1,thereisnolargerdifferenceintermsoflinesofcode(weomitted
thebracketsintheloopversionwhichwouldmakethecodeslightly
longer). But the more complex operations on collections are, the
longerseemstobetheloopcodeincomparisontoStreamAPIcode.
Although the usage of the Stream API has some other technical
implications (such as a probably easier way to do iterations inparallel), both ways to write the code coexist. And it is unclear
what way is preferable.
A first experiment that appeared in ICSE 2016 suggested that
lambda expressions for iterating collections in C++ have problems
when developers (novices or junior developers) need to write them
while for senior developers at least no benefit was detected [ 37].
However,thestudydidnottakeintoaccountthatlambdaexpres-
sions â€“ once they have been finished â€“ have a potential positive
effect on the understandability of the code.
The present paper studies the possible effect of declarative con-
structsfromadifferentangle:insteadofwritingexpressions,par-
ticipantsreadcodethatoperatedonacollection(eitherusingloops
orusingtheStreamAPI)andthendecided,whattheresultofthe
codeis.Arandomizedcontroltrialthatreliedonthemeasurements
of 20 volunteers revealed with strong evidence (p<.001) a large,positive effect of the use of the Stream API (
ðœ‚2ð‘=.695): It took the
subjects on average 78% longer to solve the tasks using loops incomparison to the Stream API, but the experiment also revealedthat the difference between loops and the Stream API depends
on the kinds of collectionoperations. An additional questionnaire
given to the participants revealed that participants perceived their
ownspeedin understanding the code using the Stream API higher
than their speed with code using loops. This indicates that thepositive effect ofthe StreamAPI isnot onlyan effectthatcan beseen in a larger study, but an effect that developers can perceive
via self-observations.2 BACKGROUND
Conceptually, lambda expressions are anonymous functions (i.e.
functionswithoutaname)thatcanbepassedasparameters,storedintovariablesorsimplyinvoked.Lambdaexpressionsare(andwere)anessentialandcommonlanguageconstructinfunctionalprogram-minglanguagessincedecades(seeforexample[
1,4])andevensome
non-functionalprogramminglanguagessuchastheobject-oriented
language Smalltalk [ 15] had lambda expressions right from start.
But a number of main stream programming languages often didnot have lambda expressions in their initial designs. We alreadymentionedthatJavareceivedlambdaexpressionsabout20yearsafterthereleaseofitsfirstversion.Otherlanguagesevolvedinasimilar way. For example, Python was originally released underthe version 0.9 [
38] but the introduction of lambda expressions
appearedoneversionlater(inversion1).C++introducedlambda
expressionsinversion11[ 35],C#introducedlambdaexpressions
in version 3 [8], PHP received them in version 5.3, etc.
But although the concept of lambda expressions exists in dif-
ferentlanguagesforyears,therearestillanumberofdifferences
between them. Examples of these differences are syntactical differ-
enceseither betweenlanguages oreven specialsyntaxconstructs
withinalanguageaswell.Additionally,lambdaexpressionsdiffer
oftenwithrespecttotheirfunctionality(accesstovariablesinouter
scope, non-local returns4, etc.).
Stream<Person> s ...
s.filter(p âˆ’> p.age()>=21);
s.filter(p âˆ’>{return p.age()>=21;});
s. filter ((Person p) âˆ’> p.age()>=21);
s. filter ((Person p) âˆ’>{return p.age()>=21;});
Figure 2: Syntactical differences of equivalent lambda ex-pressions in Java.
InJava,alambdaexpressionmightormightnothavetypedecla-
rations in its parameter list and the body might or might not have
curly brackets. If there are no curly brackets, the body of a lambda
expressionsconsistsofasingleexpressionwhichalsorepresents
the return value. In case a parameter list does not contain type
declarations, Java infers the types, etc. I.e., a developer is typically
free to decide whether or not he declares the types for parameters
in a lambda expression. Figure 2 illustrates four equivalent lambda
expressions passed to a streamâ€™s filter method â€“ and there are stud-
iesthatindicatethatthedifferentsyntacticrepresentationshave
an effect on readability (see for example [18]).
InJavaâ€™sStreamAPIlambdaexpressionsplayanessentialrole
andanumberofmethodsinstreamsrequirelambdaexpressionsto
be passed.5We mentioned in the introduction already the method
filter() thatrequiresa lambdaexpressionthatreturnsa boolean
value in order to determine whether or not one object should
be selected from a list. Comparable methods are anyMatch() or
allMatch() thatreturnabooleanvalueifforany(orall)element(s)
4See for example [7, pp. 39] for a general explanation of local and non-local returns.
5Technically, this is not 100% correct, because the Stream API can be used with or-
dinary objects or anonymous inner classes as well. However, even Javaâ€™s standard
documentation on the Stream API proposes the use of lambda expressions.
1158
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. Imperative versus Declarative Collection Processing: An RCT on the Understandability of Traditional Loops versus the Stream API in Java ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
inthecollectionthe passedlambdaexpressionreturnstrue.Inad-
dition to that, the Stream API has methods for creating maps or
groups or to convert a stream into a collection.
Figure 3 illustrates a more complex example that illustrates the
moredeclarativenatureoftheStreamAPIincomparisontothetra-
ditionalloops.Intheexample,acollectionofobjectsistransformed
intoamapconsistingofanintegerkeythatistheageofaperson
fromthecollectionandalistofallpersonsofthatage.Usingthe
Stream API one declares with a lambda expression the grouping
criterion( p->p.age() )whichdefinesthekeysinthemap.Another
lambdaexpressiondescribeswhatelementsshouldbestoredinthelist.Thesamefigurealsocontainsanimperativeimplementationofthecodewherefirsttheresultmapiscreatedandtheneachelement
in the original collection is iterated. By using a conditional, the list
objectsarestoredintothemapandfinallyapersonobjectisstored
in the list. Although both ways result into a comparable result, the
difference instyle seems obvious.Still, the question iswhether one
way should be preferred over the other.6
Map<Integer , List<Person>> m;
// Map construction using the Stream API
m = personCollection.stream(). collect(
Collectors .groupingBy(p âˆ’>p.age() ,
Collectors .mapping(p âˆ’>p ,
Collectors.toList ())));
// Map construction using loops
m=newHashMap<Int eger , List<Person>>();
for(Person p : personCollection) {
if(!m.containsKey(p.age()))
m.put(p.age() , newVector<Person >());
m.get(p.age ()).add(p);
}
Figure3:MapconstructionfromalistusingtheStreamAPIor using loops.
Additional to the evolution of programming languages there
were other movements towards a more declarative style using
lambda expressions. For example, the IDE IntelliJ visualized Javaâ€™s
anonymousinnerclassesalreadyin2009aslambdaexpressions.I.e.
althoughtheunderlyingsourcecodedidnotcontainsuchexpres-
sions,IntelliJâ€™smotivationwastoimprovethereadabilityofcode
(under the assumption that lambda expressions can be easier read
than anonymous inner classes).7
However, despite of the wide adoption of lambda expressions
inprogramminglanguagesoverthelastdecadeandtheresulting
more declarative means to write programs (in originally ratherimperative languages), there is little empirical evidence on thebenefits of using such constructs (despite the fact that there are
indicatorsthatthemorefunctionalstyleisincreasinglyaccepted
6Infact,theresultisnotidentical,becausetheiterativestyledefinesahashmapanda
vectorofpersonswhiletheconcreteimplementationusedforthemapsandthelist
are hidden inside the abstraction of the Stream API.
7https://blog.jetbrains.com/idea/2009/03/closure-folding-in-intellij-idea-9-maia/by developers, see for example thestudy by Mazinanian et al. [ 24]).
At least one controlled experiment on lambda expressions seemed
to suggest the opposite [37].
3 EXPERIMENT
Thegoalofthepresentworkistostudywhetheramoredeclara-
tive way of operating on collections using the Stream API has any
influenceontheunderstandability.Ourintentionwastodefinea
randomized control trial where participants needed to understand
operationsoncollectionsthatwereeitherdescribedusingthetra-
ditional imperative style using loops or the rather declarative style
using the Stream API with lambda expressions.
3.1 Initial Considerations
Beforedesigninganexperimentanumberofconcernsneedtobe
taken into account.
Within-subjectdesigns : One generalconcern is, whether the
experiment should have within-subject variables, i.e. the gen-eral question is whether the experiment should be designed as
acrossoverstudy(see[ 34]forageneralintroductionintocrossover
trials). One reason to apply crossover trials is to overcome to a
certainextentthesoâ€“called10xproblem(see[ 25])whichdescribes
in general for programming related tasks that one can assume ahigh deviation between participants.
8The analysis of a within-
subjectdesignpermitstomeasuredifferenceswithinasubject.This
potentially compensates the effect of large deviations between sub-
jectswhichisprobablythereasonwhyalargenumberofstudies
insoftwareengineeringarecrossovertrials.9However,crossover
designsrequiretotakepossiblecarryovereffects(respectivelyperi-odiceffects)intoaccount(see[
23,p.1984])suchaslearningeffects,
fatigueeffect,etc.Andthereisthenecessitytocheckintheanalysis
whether the carryover effects actually occured (see for example
[40] among many others).
Deviation in the non-iterating code : The obvious way to
studydifferencesinunderstandabilityistogiveparticipantscode
withonetreatmentandcodewithadifferenttreatmentandthen
ask questions about it. The potential problem is the complexity of
the code that is not in the focus of the present study. Such com-plexity could be caused by the code that defines and initializes
thecollections.Ifsuchcodeistoocomplex,thereisthepotential
problemthatitisthemaincausefordeviationinthemeasurements
(andnotthedifferenttreatments)whichpotentiallyhidestheeffect
that should be studied: Such code needs to be read and understood
beforeactuallyreadingandunderstandingthecodethatoperates
on the collections. Hence, we think there is a need to represent the
code that is not in the focus of the study in a more easy way.
Complexity of iterating code : Obviously, there are infinite
possible ways to do operations on a collection. A simple code is
afilteroperationwhereforexampleobjectsfromacollectionare
selected because one instance variable of the object corresponds to
a certain literal (e.g., person.age=42 ). From our perspective, more
complexoperations aregrouping ormapping operations(suchas
8The evidence that participants differ by factor 10 is quite low (see [ 5, pp. 36]). Hence,
10x should be rather understood as a methaphore that the deviation can be high.
9Vegas et al. analyzed studies in software engineering and found that more than1
3of
of the analyzed studies were crossover trials [39, p. 123].
1159
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Nils Mehlhorn and Stefan Hanenberg
Table 1: Experiment source code (Tasks1â€“5 )
Task Stream API Loop
1 Map<String, Long> f(Collection<String> words) {
return words.stream().collect(
groupingBy(String::toLowerCase, counting())
);
}Map<String, Long> f(Collection<String> words) {
Map<String, Long> groups = new HashMap<>();
for(String word: words) {
String lowercase = word.toLowerCase();Long count = groups.getOrDefault(lowercase, 0L);
groups.put(lowercase, count + 1);
}
return groups;
}
2 List<Employee> f(List<Long> ids, List<Employee> employees) {
return employees.stream()
.filter(employee -> ids.contains(employee.getId()))
.collect(toList());
}List<Employee> f(List<Long> isa, List<Employee> employees) {
List<Employee> l = new ArrayList<>();for (Employee employee : employees) {
if(ids.contains(employee.getId())) {
l.add(employee);
}
return l;
}
3 boolean f(Collection<Result> results) {
return results.stream().allMatch(
r -> r.getPoints()>50
);
}boolean f(Collection<Result> results) {
for (Result r : results) {
if(r.getPoints() <= 50) {
return false;
}
}return true;
}
4 Map<Author, Book> f(Collection<Book> books) {
return books.stream().collect(
toMap( Book::getAuthor,
book -> book,maxBy(comparing(Book::getSales)
)
);
}Map<Author, Book> f(Collection<Book> books) {
Map<Author, Book> groups = new HashMap<>();for(Book book : books) {
Book otherBook = groups.get(book.getAuthor());if(otherBook == null || book.getSales()> otherBook.getSales()) {
groups.put(book.getAuthor(), book);
}
}return groups;
}
5 List<Double> f(Collection<BankAccount> accounts, double rate) {
return accounts.stream()
.filter(account -> !account.isFree()
&& account.getBalance() <= 0)
.map(account -> {
double result = account.getBalance();if(!account.isFixed()) {
double finalRate = account.isPremium() ? rate*2:rate;result *= finalRate; } return result;
}
)
.collect(toList());
}List<Double> f(Collection<BankAccount> accounts, double rate) {
List<Double> results = new ArrayList<>();for (BankAccount account : accounts) {
double balance = account.getBalance();if(account.isFree() || balance > 0) {
continue;
}double result = balance;
if(!account.isFixed()) {
double finalRate = account.isPremium() ? rate*2:rate;result *= finalRate;
}results.add(result);
}return results;
}
the one given in Figure 3) and they probably have an effect on the
potential differences. Hence, we see the need to study different
kinds of operations on collections.
Deviationintheiteratingcode: Weneedtotakeintoaccount
thatespeciallyfortheloopsthereisnotoneuniquewaytowritedownacollectionoperation.IfweuseagainFigure3asanexam-
ple, itis possible to defineadditional local variables (thatstore for
example the result of the expression person.age() ). Additionally,
oneneedstotakeintoaccountthatthenamingofsuchvariables
1160
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. Imperative versus Declarative Collection Processing: An RCT on the Understandability of Traditional Loops versus the Stream API in Java ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 2: Experiment source code (Tasks6â€“7 )
Task Stream API Loop
6 Map<String, Integer> f(List<Product> products) {
return products.stream().collect(
toMap(Product::getDepartment,
Product::getPrice,
minBy(Integer::compareTo)
)
);
}Map<String, Integer> f(List<Product> products) {
Map<String, List<Product> >groups = new HashMap<>();for (Product p : products) {
String department = p.getDepartment();if(groups.containsKey(department)) {
groups.get(department).add(p);
}else {
List<Product> group = new ArrayList<>();group.add(p);groups.put(department, group);
}
}Map<String, Integer> computed = new HashMap<>();
for (Map.Entry<String, List<Product> > group : groups.entrySet()) {
Integer c = null;List<Product> departmentProducts = group.getValue();for (Product product : departmentProducts) {
if(c == null || product.getPrice() < c) {
c = product.getPrice();
}
}
computed.put(group.getKey(), c);
}
return computed;
}
7 boolean f(Collection<Artwork> artworks, int discount) {
return artworks.stream()
.anyMatch(a -> a.getPrice() - discount < 5000);
}boolean f(Collection<Artwork> artworks, int discount) {
for (Artwork a : artworks) {
if (a.getPrice() - discount < 5000) {
return true;
}
}
return false;
}
has an effect on the understandability of the resulting code.10Our
conclusion on this is that the loop code should be plausible where
local variables should be used whenever the corresponding expres-
sionsaretoocomplex.Furthermore,variablenamesshouldbeused
that express best the content of these variables without actually
announcing the semantics of the whole operation.
Deviation in lambda expressions : As states in Section 2,
lambda expressions in Java can be written in different ways and
it is not clear whether the different styles have an effect on the
understandability. While it would be in principle possible to study
the effect of different lambda styles as well, we believe that it is
quitecommonintheStreamAPItouselambdaexpressionswithoutdeclaredtypesandmainlywithonesingleexpressionintheirbody
whenever possible.
3.2 Tasks
Altogether, seven tasks were used in the experiment (see Table 1
and Table 2). Taking the initial considerations into account, we
10For example, the studies by Binkley et al. [ 3] or by Hofmeister et al. [ 19] showed
that the style as well as the length of identifiers has an effect on readabilty.decided to give subjects code that consists of one single method
whereallobjectsrequiredbyacollectionoperationarepassedto.
While one initial consideration was to give meaningful names, this
should not be the case of this single method: if the semantics of
themethodisalreadydescribedinthemethodâ€™sname,participants
would probably guess from the name the semantics of the code. As
a consequence, we always gave the method the name f. But fâ€™s
parameternamesaremeaningful,i.e.theirnamesindicatewhatthe
contentofthevariablesis.Forthelocalvariableswithintheloop
code, we used meaningful names as all.
Forexample,thecodeforTask1(withthenotmeaningulmethod
name f) receives a collection of words as input (the parameter has
the meaningful name words) and returns a map that contains how
oftenaword(inlowercase)occuredinthecollection.Intheloop
codewedecidedtogivethelocalvariablefortheresultobjectthe
(meaningful)name groupsandwedecidedtostorethelowercase
representationofawordaswellasthecounterincorresponding
local variables (with meaningful names).
Inordertorepresentdifferentkindsofcomplexities,weselected
code snippets based on our personal perception.
1161
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Nils Mehlhorn and Stefan Hanenberg
Figure 4: Application used for the data selection (task 6 with technique loop).
â€¢Simple (Task 3, 7): Weusedtwosimpletaskswhereonly
one conditions needed to be checked (either whether the
condition holds for one or for all elements). In both cases,the loop contained a condition with a return statement as
wellasanadditionalreturnstatementaftertheloopwhile
for the Stream API just the corresponding methods were
invoked.Forthesimpletasks,wedidnotexpectanypositive
effect of the Stream API and possibly even a negative effect:
the loop code looks from our perspective quite trivial.
â€¢Medium(Task1,2,4,6) : We considered tasks with group-
ing criteria as medium. We think that especially for loops
the code is no longer that trivial to understand, because one
has to handle the definition of subgroups and the assign-ment of elements to that group. Task 4 and 6 are from our
perspectivespecialcases.Intask4,theloopcodedefinesthe
subgroups and the mapping (the maximum) in one step. We
were not sure whether it is easier for developers to define
themappinginaseparateloop.Hence,Task4and6differ
mainly in the loop code where the mapping occurs either in
one single loop (Task 4) or in two loops (Task 6). For both
cases, the Stream API code is comparable.
â€¢Complex (Task5) : From our perspective a task is complex
if the filter citerion and the mapping criterion cannot besimply defined by referring to an attribute. Task 5 is fromour perspective such a task that contains a more complex
definition of the mapping criterion: even in the Stream API
the lambda expression passed to the mapcontains an addi-
tionalcondition.Intheloopimplementation,theloopâ€™sbody
is from our perspective more complex due to the additional
conditional.
Notethatthepreviousclassificationisbasedonourpersonalpercep-tionandonlyusedforexplainingthedifferentkindsoftasks.Hence,
wedonotusethis(fromourperspective)ratherweakclassification
as an independent variable in the experiment.
Becauseoftheinitialconsiderations(seeSection3.1)wedecided
togivesubjectsamoregraphicalrepresentationoftheinputvari-
ablesforthecode.Figure4illustratestheapplicationweusedintheexperiment(intheexampleforTask6inthelooprepresentation).11
In the center of the screen the code isshown whose result it to be
determined.Onthelefthandside,theinputdataisgiven,ontheright hand side the possible output is given. The input is a table
wherethetableâ€™snamematchestheparameternameofthemethod.
Additionally, the tableâ€™s column names represent the instance vari-
ables of the corresponding object. For example, the code in Figure
4usesacollectionofproductswhereeachproducthastheinstance
variables name, department, and price.
3.3 Experiment Design and Layout
The experiment was designed as a crossover design where each
participant was tested under all treatments. We divided the partici-pants into two groups (A and B). Both groups received the tasks in
identicalorder(Task1â€“7,then,again,Task1â€“7)butwithalternating
techniques(loopsvs.StreamAPI).ForgroupA,Task1wasgiven
inthelooprepresentation,Task2intheStreamAPIrepresentation,
Task 3 in the loop representation, etc. Group B started with the
StreamAPI.Afterfinishingtheseventasks,thetaskswereagain
given,thistimewiththeothertechnique(i.e.,groupAreceivedtask
1withtheStreamAPI,Task2withtheloop,etc.)andwithdifferent
inputs.Theparticipantswerenotinformedabouttheexperiment
design, i.e. the participants just knew that 14 tasks had to be done.
Foreachtask,theparticipantswereaskedtoratetheirsubjective
impressions from the task with respect to three criteria (each rated
on a 10 point Likert scale, 1=lowest; 10=highest): overall perfor-
mance (i.e. how good a participant from his perspective performed
the task), speed (i.e. how fast he was able to solve the task), and
readability (how well from the participantsâ€™s perspective the code
reflected its intention)12.
The experiment studies the following hypotheses:
(1)H0ð‘¡ð‘’ð‘â„Žð‘›ð‘–ð‘žð‘¢ð‘’:There is no difference in time for answering
what the results of a loop-based or Stream API-based source
code are.
11https://github.com/nilsmehlhorn/loop-stream-rct/releases
12Actually, the participants were asked to judge the code with respect to aesthetics
insteadofreadability.Weusethetermreadabilityhereinsteadtomaketheterminology
more clear.
1162
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. Imperative versus Declarative Collection Processing: An RCT on the Understandability of Traditional Loops versus the Stream API in Java ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
(2)H0ð‘ð‘œð‘Ÿð‘Ÿð‘’ð‘ð‘¡ð‘›ð‘’ð‘ ð‘  :There is no difference in the correctness of
the given responses for a loop-based or Stream API-based
source code.
(3)H0ð‘ð‘’ð‘Ÿð‘ð‘’ð‘ð‘¡ð‘–ð‘œð‘› :There is no difference in the participantâ€™s
perception(overallperformance ,speed,and readability)of
source code based on loops or the Stream API.
Each hypothesis comes with three different response variables:
(1)Responsetime(ratioscale) :Thetimeittookaparticipant
to answer a question.
(2)Correctness (true/false) : Whether or not a response
matched the actual result of the code.
(3)Perception(ordinalscale,1â€“10) :Theparticipantâ€™spercep-
tion of each task with respect t o overall performance, speed,
and asthetics.
The independent variables in the experiment were:
(1)Task: The concrete code given to the subjects (Task1â€“7 ) .
(2)Technique :Thetechniqueinwhichthecodewaswritten
(loop or Stream API).
Whilethevariabletimeandcorrectnessarefromourperspective
the important response variables, the participantâ€™s perception is
interestingwithrespecttowhetherthepotentialoutcomesofthe
experiment were also perceived by the participants.
Thetimemeasurementstartedrightfromthemomentwhena
taskwasshown.Theparticipanthadtochose0â€“nelementsfrom
the output table and then had to click on the submit button. The
applicationstopped thetime(andassigns thecorrespondingtime
to the task) and asked the participant to fill out a questionnaire for
the current task. After finishing the questionnaire, the participant
explicitely needed to start the next task.
3.4 Execution
Weselected20volunteers(10masterstudentsand10profession-
als) and measuredeach one in an individualsession. Based on our
subjective impression, 20 participants would be already enough
todetectaneffect.Theparticipantswerechosenbasedonpurpo-
sivesampling[ 30]inthefollowingway13:Theauthorscontacted
professional developers and asked them whether they are familiar
with the Stream API and whether they are willing to participate.
Once10developerswerefoundwerepeatedthesameprocessfor
master students.
Despitethefactthatallvolunteersstatedthattheywerefamiliar
with the Stream API, we still gave each one a short introduction
into the iteration of collections using loops and the Stream API
andemphasizedespeciallyfortheStreamAPIspecificoperations
to ensure similar levels of knowledge among participants. This
short refreshment training took about 15 minutes depending on
aparticipantâ€™spriorknowledgeanddependingonaparticipantâ€™s
specific questions.
Once the participant started with the experiment, all 14 tasks
weredoneoneafteranotherbuttheparticipantwaspermittedto
take a break between two tasks.
13Purposive sampling is a non-probability sampling technique that is quite often
appliedinsoftwareengineering.ThestudybyBaltesandRalph[ 2]revealedthatabout
70% of empirical studies in software engineering use purposive sampling.4 RESULTS
4.1 Response Times
ThedatawasanalyzedusinganANOVAwithrepeatedmeasure-
ments on the dependent variable time and the within-subject vari-
ablestask(1â€“7),andtechnique(loop,StreamAPI)andthebetween-
subject variable group (A, B).14Table 3 contains a more detailed
description of the statistical results.
The variable group is not significant (p=.440) and there is no
interactionbetweengroupandtask(p=.176)andgroupandtech-
nique (p=.746). Hence, we found no indicator for carryover effects
which indicates that the counterbalanced design worked out.
Both main effects (technique and task) are significant (both
p<.001) with relatively large effect sizes (both ðœ‚2ð‘>=.695). But it
turns out that there is a significant interaction effect between both
variables (p<.001, ðœ‚2ð‘=.160).
Figure5illustratestheinteractionbetweentechniqueandtask
(includingthe95%confidenceintervals).Thefiguresuggeststhat
the differences between loop and Stream API depend on the tasks:
whileforthreetasks(2,3,and7)thedifferencesarerathersmall,
the difference is rather large for Task 1, Task 4, and Task 6.
WeneedtokeepinmindthatTask6playedaspecialrole.We
introduceditinadditiontoTask4becausewewerenotsurewhether
themappingintheimperativestylecouldbeeasierunderstoodif
two loops are used. Taking the difference between Task 4 and 6 in
the imperative style into account, we can exclude this possibility.
Pairwise comparisons15of loops and the Stream API per task
show for all tasks a positive effect of the Stream API16which is
alsoillustrated inthe interactiondiagram: foreachtask themean
for the Stream API is lower than the mean for the loop. Looking
at the ratios of means, we see that they vary from 123% (Task 2)up to 282% (Task 6). I.e. the usage of loops required at least 23%more time and at most 182%. Due to the interaction it is valid to
saythatapositiveeffectoftheStreamAPIexistsindependentofthetask,buthowlargethedifferenceintimeactuallyisdepends
on the tasks.
WeshouldtakeintoaccountthatweintroducedTask6underthe
assumptionthatusingtwoloopsforagroupingcriterionmighthelpunderstandingtheiterativecode.Andthistaskrevealedthehighest
difference between the StreamAPI and the loop. Including Task 6
theratioð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘šis178%,i.e.thelooprequired78%moretimeto
understand.IfweexcludeTask6,wereceiveð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘š=114ð‘ 
74ð‘ =154%
(while all other results are comparable except the effect size for
T*TAwhichiswithoutTask6higherwith ðœ‚2ð‘=.239).Hence,even
if we remove one disputable task, the loop variant still required
54% moretime to understand. Andwe think itis noteworthy that
even thevery simplytasks 3and 7 showeda positiveeffect ofthe
StreamAPIalthoughweconsidereditaspossiblethattheStream
API could have a negative effect.
Consequently, we reject H0 ð‘¡ð‘’ð‘â„Žð‘›ð‘–ð‘žð‘¢ð‘’.
14All following analyses were done using SPSS v27.
15Since the the tasks were significantly different (p ð‘Žð‘™ð‘”ð‘œð‘Ÿð‘–ð‘¡â„Žð‘š <.001), we intention-
ally did here a pairwise t-test without a correcting the p-value (using, for example
Bonferroni).
16For task 5 and 7 the difference is only significant for an alpha level of .1, not for an
alpha level of .05.
1163
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Nils Mehlhorn and Stefan Hanenberg
Table3:ANOVAon20subjectsontheresponsevariabletime.WereporttheinteractionT*TAviapairwiset-testsforeachtask
(such as Î”1for the comparison between loop and Stream API for Task 1) instead of the values for all treatment combinations.
M, CI95%and SD are rounded to full seconds.
dfFp ðœ‚2ð‘Treatement NC I 95% M SD Ratios
Technique (T) 1 40.977 <.001 .695 loop140 107; 167 137 118 ð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘š=137
77=178%Stream API 140 64; 82 77 56
Task (TA) 3.406 50.813 <.001 .738 omitted
Group 1 .440 .516 .024 omitted due to insignificant results
T*T A 6 8.020 <.001 .160 Î”ð‘šð‘’ð‘‘ð‘–ð‘¢ð‘š
120 30;116 (p=.002) 73 91ð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘š=179
105=170%
Î”ð‘šð‘’ð‘‘ð‘–ð‘¢ð‘š
220 3; 22 (p=.008) 13 20ð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘š=70
57=123%
Î”ð‘ ð‘–ð‘šð‘ð‘™ð‘’
320 3;16 (p=.009) 10 15ð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘š=41
32=128%
Î”ð‘šð‘’ð‘‘ð‘–ð‘¢ð‘š
420 26; 14 (p=.006) 82 129ð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘š=194
112=173%
Î”ð‘ð‘œð‘šð‘ð‘™ð‘’ð‘¥
520 -4; 95 (p=.067) 46 106ð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘š=151
106=142%
Î”ð‘šð‘’ð‘‘ð‘–ð‘¢ð‘š
620 132; 223 (p=.000) 18 97ð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘š=276
98=282%
Î”ð‘ ð‘–ð‘šð‘ð‘™ð‘’
720 -1; 24 (p=.070) 12 27ð‘€ð‘™ð‘œð‘œð‘
ð‘€ð‘ ð‘¡ð‘Ÿð‘’ð‘Žð‘š=46
34=132%
Figure 5: Interaction Task*Technique on response times
In order to check, whether the subjectâ€™s background (master
student versus professional)potentially influenced the results,we
repeat the previous ANOVA with background as an additional de-
pendentvariableâ€“beingawarethatthisreducesthesamplesizefor each treatment combination (which potentially leads to thesituation that variables that were previously significant are nowinsignificant). Actually it turned out that background had a posi-
tiveeffectandstudentswereonaverage.91seconds(respectively
14%) slower than professionals (p<.001, ðœ‚2ð‘=.053, M ð‘ ð‘¡ð‘¢ð‘‘ð‘’ð‘›ð‘¡ =7.238,
Mð‘ð‘Ÿð‘œð‘“ ð‘’ð‘ ð‘ ð‘–ð‘œð‘›ð‘Žð‘™ =6.330,ð‘€ð‘ ð‘¡ð‘¢ð‘‘ð‘’ð‘›ð‘¡
ð‘€ð‘ð‘Ÿð‘œð‘“ ð‘’ð‘ ð‘ ð‘–ð‘œð‘›ð‘Žð‘™=1.14). And while the variable
technique is still significant (p=.012, ðœ‚2ð‘=.030), the interaction be-
tween technique and task is no longer significant (p=.101, ðœ‚2ð‘=.049).
However, from our perspective the latter result is rather the effect
of the previously mentioned reduced sample size per treatment
combinationinsteadofanindidatorthattheresultdoesnotdepend
on the tasks.4.2 Correctness
Becauseofthedifferentnatureoftheresponsevariablecorrectness
(whichsimplystateswhetherornotaresultwascorrect),wecannot
run an ANOVA. Instead, we run a ðœ’2-test first on the variables
correctness and technique in order to check whether (independent
of the tasks) the correctness of responses differed between the
techniques.
Altogether, the participants gave 40 incorrect answers
(loops=30/Stream API=10), which is a statistically significant result
(ðœ’2(1, N=280)=11.667, p=.001).
Taking the results of the previous section into account, it seems
reasonable to run the test for each task in separation. However,
only for Tasks 5 and 6 the differences were significant: 11 incorrect
answersweregivenforTask5(10/1; ðœ’2(1,N=40)=10.157,p=.001),
10 incorrect answers were given for Task 6 (8/2; ðœ’2(1, N=40)=4.800,
p=.028).TheonlytaskwherethenumberofincorrectanswersusingtheStreamAPIincomparisontoloopswashigherwasTask1(2/4),
butthedifferencewasnotsignificant(p=.376).Forallothertasks,
thenumberofincorrectresponseswerehigherforloopsthanfor
the Stream API. Again, removing Task 6 from the analysis leads to
the same results. Hence, we reject hypothesis H0 ð‘ð‘œð‘Ÿð‘Ÿð‘’ð‘ð‘¡ð‘›ð‘’ð‘ ð‘  .
4.3 Subjective Ratings
In order to analyze the subjective ratings17we run again a re-
peated measures ANOVA, this time with the dependent variableratingandthewithin-subjectvariablestask,techniqueandques-
tion.18Likewise to the time analysis, all independent variables are
significant (p<.001) with different effect sizes ( ðœ‚2ð‘(ð‘¡ð‘Žð‘ ð‘˜)=.606;
ðœ‚2ð‘(ð‘¡ð‘’ð‘â„Žð‘›ð‘–ð‘žð‘¢ð‘’ )=.779;ðœ‚2ð‘(ð‘žð‘¢ð‘’ð‘ ð‘¡ð‘–ð‘œð‘›)=.231).Additionally,allcom-
binationsoftheindependentvariablesarestatisticallysignificant
(p<=.001).
17Because of a technical error, the subjective ratingsof 3 subjects were not recorded.
Hence, the following analysis is based on the data of 17 subjects.
18Because of space limitations we do not provide the complete data of the ANOVA
here and report instead only the most essential results.
1164
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. Imperative versus Declarative Collection Processing: An RCT on the Understandability of Traditional Loops versus the Stream API in Java ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Figure 6: Interaction Question * Technique on ratings
Figure 6 illustrates the interaction diagram for ques-
tion*technique. It shows, that participants always rated the
Stream API higher than the loops and the largest difference
betweenbothtechniquesexistsforreadability.Consequently,we
reject hypothesis H0 ð‘ð‘’ð‘Ÿð‘ð‘’ð‘ð‘¡ð‘–ð‘œð‘› .
Wethinkthatthesecondandthethirdquestionplaythemostim-
portant roles, because the question on the speed indicates whether
subjects were able to perceive the difference in time we detected
insection4.1andreadabilitycoulddirectintothesamedirection
(althoughtheratingcriterionislessprecise).Figure7illustratesthe
interactionbetween thespeed ratingsandthetasks.Foralltasks
the means for the Stream API are higher than for the loops. We do
notshowtheinteraction diagramforthequestiononreadability
which looks similar to the interaction diagram of the speed ratings.
Figure 7: Interaction Task * T echniqueon speedratings
Because of the similarities betw een speed ratings and time mea-
surements it is plausible to run a multiple linear regression on the
variables speed rating and technique to explain the response times.Theresultingregressionequationissignificant(F(3,234)=85.900,
p<.001)withR 2=.524.Inotherwords,thedifferencesintimewere
not onlymeasured andmeasurable,they werealso perceptible by
theparticipants.Repeatingthesameforthequestiononreadabil-
ityresultsâ€“forunderstandablereasonsâ€“inaweakermodel(F(3,
234)=34.688, p<.001) with R 2=.308: the readability perception says
less about the understandability (in terms of times) than thespeed
perception.Inotherwords:whetherornotsomeoneconsiderssomepieceofcodemorereadableisratheraweakindicatorforthecodeâ€™s
understandability.
5 THREATS TO VALIDITY
Experiments should document their potential threats to validity
(see for example [ 41]) and we see the following threats worth con-
sidering.
Code representation : The code given to the participants is
obviously a threat and the code could be written in a different way.
For the Stream API anonymous inner classes could have been used
insteadoflambdaexpressions,thedifferentexpressionscouldbe
storedinlocalvariables,etc.Somethingsimilarcouldbedonefor
the loops. In all cases, the corresponding names could more clearly
express what they stand for. To a certain extent, a variable thatexpresses too precisely its meaning could be problematic for theexperiment,becauseparticipantscouldjustrelyonthenamesin
the code instead of the semantics.
Chosentasks: We think that there are much more complicated
meanstospecifyoperationsoncollectionsâ€“andtheyhaveprobably
an impact on the difference between the Stream API and loops.
Wethinkthatthedifferencesbecomelargerifmultiplegrouping
operations are applied, but the present study cannot give evidence
for this statement.
Trainingphase/selectionofparticipants :Thesubjectswere
chosen using purposive sampling, which might or might not influ-
encetheresults.However,potentialparticipantswereaskedupfront
whether they are familiar with the Stream API in Java. Actually,
wethinkthatjustaskingpeoplewhetherornottheyarefamiliar
withacertaintecniqueispotentiallyproblematic,becauseâ€œbeing
familiar withsome techniqueâ€could meandifferent thingsto par-
ticipants. We also think that the short refreshment into the Stream
API respectively into the iteration of collections has a potential
effect onthe resultsâ€“ butwe cannotestimate,how largethis effect
is (or whether it existed in the present study at all).
Measurements and measurement technique : The experi-
ment used a graphical representation for the input and output
ofeachtaskâ€“anditusedthemomentwhentheparticipantpressedthesubmitbuttonforthetimemeasurement.Therepresentationof
the input data was chosen to ease the reading of the code. If this
assumptionholds,itmeansthatinapracticalsettingthedifferences
betweenthe loopandStreamAPI wouldbeprobablyless because
thereadingoftheadditionalcodewouldcauseadditionaldeviation.
Next, the answers were given by clicking on the appropriate lines.
Inprincipleonecanarguethatitwouldhavebeenabettermeasure-
menttostopthetimerecordingwhenthefirstmousebuttonwas
pressed.Butinpreliminaryexperimentswemadetheexperience
that people do not start to choose answers when they know the
wholeanswertoaquestion.Fromthatperspective,wethinkthat
1165
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Nils Mehlhorn and Stefan Hanenberg
the chosen measurement technique is appropriate although it still
contains some additional time for navigating with the mouse, etc.
6 RELATED WORK
Althoughthediscussionswhetherornotfunctionallanguagesin
generalorfunctionallanguageconstructsarehelpfulinadditionto
imperativelanguageconstructarevividsincedecades(seeforexam-
ple [6, Chapter 4]19,[21,32] among many others) and while there
are approaches avaible to translate imperative code into a more
functional style (see for example [ 9,13,17,36]), there is not much
evidenceonthepossibleeffectsoftheusabilityoffunctionallan-
guageconstructsingeneral,thecombinationoffunctionallanguage
constructs into other kinds of language or, even more particular,
theintroductionoflambdaexpressionsintotodayâ€™smainstream
languages. On the other hand, the technical implications of for
examplelambdaexpressionsincomparisontoexistingconstructs
are often studied (see for example [28]).
Uesbeck et al. [ 37] provided a controlled experiment on lambda
expressionsforreplacingwhileloopswithlambdaexpressions in
C++. In the study, three tasks were designed and applied to 54 par-
ticipants (from freshmen to junior up to senior developers) who
needed to write corresponding algorithms. The response variables
in theexperiment were correctness,time, and number ofcompila-
tionerrors.Theindependentvariablesweretechnique(lambdaver-susloop)andtheparticipantsâ€™experiencelevel.Thestudyrevealedapositiveeffectofloopsincomparisontolambdaexpressionsonall
responsevariables:programmersusinglambdaswereonaverage
about50%slowerandthesuccessrateofloopswashigher.Theonly
noteworthy exception were experienceddevelopers for whom no
differences between lambda expressions and loops were detected.
One controlled experiment that compared a declarative style
with a more traditional style (although not explicitly related to
loops) was performed by Salvaneschi et al. [ 33] where reactive
programming(whichis amoredeclarativestyleofprogramming,
see[10])wascomparedtotheapplicationoftheobserverdesign
pattern [14]. 127 participants read the code of 10 code snippets
andansweredquestionsaboutthem.Theresponsevariableswere
reaction time and correctness. It turned out that reactive code took
lesstimeandincreasedthecorrectnessoftheanswers.Additionally,theparticipantsexpressedtheirperceptionofthetwoprogramming
stylesandthereseemtobesomeagreementthattheparticipants
considered reactive code as more desirable and more readable.
Pankratius et al. studied the possible impact of a rather func-
tionalstyleincomparisontoaratherimperativestyleformulticore
programming[ 29].Thirteenprogrammersgenerated39Javaand
39 Scala programs. While the main focus of the study is on the
technicalaspectsoftheprograms,programmerswerealsoasked
abouttheirperceptionoftheprograms.Thedevelopersperceived
the Java programs more often readable than the Scale programs.
Additionally,while allprogrammersconsidered theJavaprogram-
ming model as easy, this statement was only received from 30% of
the developers for Scala.
Other studies based on the analysis of code repositories also
givefirstindicationsforacomparisonofdeclarativeandimpera-
tive programming languages. For example, the study by Nanz et
19Anenglishtranslationisavailableunderhttps://caml.inria.fr/pub/docs/oreilly-book/al.[26]comparesdifferentlanguagesfromdifferentperspectives,
mainlybasedontheirtechnicalcharacteristics(runtime,memory
consumption, etc). However, the study also contains statements
abouterrorsfoundintheprojectsandoneofthefindingswas,that
Java programs were moreerror prone than for example programs
written in the functional language Haskell. A comparable study by
Ray et al. [32] on a larger sample came to opposite results.
A study that focused on Java was performed by Lucas et al. [ 22]
who compared the usage and usability of lambda expressions in
comparison to anonymous inner classes. The authors evaluatedcode snippets before and after the introduction of lambdas andasked 28 developers about the acceptance of lambda expressions
whereabout50%consideredtheintroductionoflambdaexpressions
asanimprovementofJava.Whiletheapplicationofreadabilityandunderstandabilitymetricsdidnotfindsignificantdifferences,devel-opersperceivedsomecodemigrationstowardslambdaexpressions
negatively, especially when for-loops were replaced.
Another study that focused on the acceptance of lambda expres-
sions in Java was performed by Mazinanian et al. [ 24] who investi-
gated the use of lambda expressions in open-source projects. They
analyzedhowtheprojectsevolvedandappliedstaticsourcecode
analyses while also interviewing 98 developers in these projects.
Halfoftheanalyzedprojectsshowedasignificantincreaseinadop-
tion while core developers introduced more often lambdas than
othersperLOC.Furthermore,lambdaexpressionsweremostlyusedasareplacementforanonymousinnerclasseswheredeveloperper-
ceived a better readability of lambda expressions over anonymous
inner classes.
AnotheranalysisoflambdaexpressionswasperformedbyNiele-
bocketal.[ 27]whoexamined2923open-sourceprojectswrittenin
C#, C++, and Java with regard to the use of lambda expressions in
concurrentcode.Theirfindingsdidnotshowthatlambdaexpres-
sionsareappliedmorefrequentlyinconcurrentcontextsthanin
general,rathertheopposite.Additionally,theyinvestigatedother
use cases for lambda expressions and found them to be used above
averageinuser-interfaceandtestingcodeaswellasimplementa-
tions of generic algorithms such as sorting.
Weranastudyonthereadabilityonlambdaexpressionsincom-
parisontoanonymousinnerclassesbefore[ 18].Actually,thatstudy
wasmotivatedbythefactthatitwasuncleartouswhetherlambda
expressionsshouldbeusedinthepresentstudy,i.e.whetherlambda
expressions should be used with or without type annotations, or
whether traditional Java constructs such as ordinary objects, re-
spectivelyanonymousinnerclassesshouldbeused.Intheprevious
studyitturnedoutthatlambdaexpressionswithouttypeannota-
tions improved the readability up to 35%. Consequently, we feltconvinced that the proposal found in Oracleâ€™s Stream API docu-
mentation, where lambda expressions were used as parameters for
the Stream API, was better suited than using any other alternative.
7 DISCUSSION AND CONCLUSION
Thepresentworkwasmotivatedbythetendencyofmainstream
(imperative)programminglanguagestointegratedeclarativemeans
vialambdaexpressionsinconjunctionwithcorrespondingAPIsthat
permittheabilitytooperateoncollectionsinamoredeclarativewayinsteadofthetraditionalwayusingloops(inconjunctionwithlocal
1166
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. Imperative versus Declarative Collection Processing: An RCT on the Understandability of Traditional Loops versus the Stream API in Java ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
variables,conditions,etc.).Moreprecisely,wewereinterestedin
whethertheapplicationoftheStreamAPI(whichmakesuseofthe
ratherdeclarativelambdaexpressions)inJavahadameasureable
effect on the understandability of operations on collections.
Thecontrolledexperimenton20participantsand7tasks(where
participantshadtodeterminetheresultofcode)revealedthatover-
all the Stream API improved the understandability (in terms of
responsetimes):loopsrequired78%moretime(evenifweremoved
a debatable task, the effect was still 54%). On an individual basis,
onlyfortwotasksthedifferencewerenotsignificantonanalpha
levelof.05 (buton analpha level of.1)which leadsus tothegener-
alizationthatforalltasksapositiveeffectoftheStreamAPIwas
measured.Itisnoteworthythattheparticipants(whoconsidered
theStreamAPIcodemorereadablethantheloopcode)wereable
toperceivethedifferencesintime.Buttheuserperceptionalsosaid
that the readability perception might be only a weak indicator for
the understandability.
What makes this result interesting is that a different experiment
intheliteraturealreadystudiedtheeffectoflambdaexpressionsoncollectionsandfoundarathernegativeeffectwhenparticipantshad
towritecode[ 37].There,onlyseniordevelopershadnonegative
effect of the more declarative style. Hence, the present experiment
castsanewlightonthediscussionaboutwhetherornotfunctional
languageconstructsmightbebeneficialinimperativelanguages.It might be the case that the application of lambda expressions
mightbeharderthanthetraditionalapplicationofloops(argument
writability), but that the resulting code with lambda expressions
is more understandable (argument understandability / readability).
Consequently,thequestionofwhetherornotfunctionalconstructs
are helpful in imperative languages could maybe not be simply
answeredbyaâ€œyesâ€orâ€œnotâ€.Itmightbethecase,thatitisbeneficial
forreadingandunderstandingcode,buttheoppositeforwriting
code (but one should keep in mind that IDE support might help in
thelattercase).Inadditiontothattheexperimentrevealedthatthedifferencebetweentheunderstandabilityofbothstylesdependson
theconcretecodesnippetsunderinvestigation:insomecasesthe
benefit in understanding might be just 20%in time, in othercases
much more (up to 78%, respectivelyâ€“ ignoring a disputable task â€“
54% more).
However, we should not overgeneralize the results with respect
tothe imperativeversus functionallanguagediscussion. Actually,
theintroductionoflambdaexpressionsintoanimperativelanguageisjustonewaytoconsideramoredeclarativestyle.Otherlanguages
suchasSQLaredeclarativeaswell,althoughtheirlanguagecon-structsarequitedifferentfromlambdaexpressions.Additionally,
oneshould keepin mindthat thesyntax oflambdaexpressions is
quite differentbetweenlanguages: although C++,Java, and Python
are objectâ€“oriented languages where loops and method calls are
syntacticallyquitesimilar,theirnotationsorlambdaexpressions
arequitedifferent.Itispossiblethattheresultsofthepresentpaper
depend much on the chosen lambda syntax in Java (taking into
account that already the different notations of lambda notations in
Java have a measurable effect [18]).
Under theassumption thatlanguage designers considerunder-
standabilityofcodeasvaluableoneneedstoaskwhycurrentmain
stream languages evolved in a way as they did. Because the us-
ageofamoredeclarativestyleinratherimperativeprogramminglanguagesisfarfrombeingnew.Forexample,theCollectionAPI
intheprogramminglanguageSmalltalk â€“alanguagethatwasde-
signedmorethan40yearsagoâ€“alreadycontainedmethodsthat
received lambdaexpressions asparameters: theAPI hasa number
of parallels to the Stream API we find today in Java. From that per-
spective,itmakessensetosuggestthatlanguagedesignersandAPI
designersshouldapplyusabilitystudies rightfromthebeginning
of the language design or API design process. Because such studies
couldinfluencetheperspectiveoflanguageandAPIdesignerson
the usability of certain language constructs or APIs.
In addition to that, we think that it is desirable to study in more
detailtheroleoftypeinferenceintheStreamAPI.Wethinkthat
onereasontheStreamAPIcodeismoreunderstandableisthequite
simplesyntaxoflambdaexpressionsinJavawherenoteventype
declarations are required. Although we are aware that there are
studies in the literature that found a rather positive effect of static
types(seeforexample[ 11,12,20,32]),westillthinkthattherather
compactsyntaxoflambdaexpressionsinJavawithouttypedeclara-tions(butstillstaticallytyped)ishelpful(whichrequiresadditionalstudies),respectively,therearealreadysomeinitialstudiesavailable
that give evidence that code without type annotations is helpful
[18].
And finally, the present study might be used to think about
whetherteachingofmainstreamlanguagecouldbeimprovedby
focussing more on lambda expressions for iterations instead of
traditional loops. But especially in that case, it is desirable to have
more empirical data on the learnability of lambda expressions.
In general, the present study could be considered as a contribu-
tion to the ongoing discussion about functional versus imperative
programming languages and it could be used as an argument for a
ratherfunctionalstyle.However,wethinkthatthepresentstudy
should be handled with care with respect to such an argument.Because on the one hand the focus of the present study was juston operations on collections and on the other hand it would be
desirabletohavealargerbasisofempiricalfactsforthatdiscussion.
REFERENCES
[1]Harold Abelson, Gerald Jay Sussman, and Julie Sussman. Structure and Interpre-
tation of Computer Programs. MIT Press, Cambridge, MA, USA, 1985.
[2]Sebastian Baltesand Paul Ralph. Sampling insoftware engineering research:A
critical review and guidelines. CoRR, abs/2002.07764, 2020.
[3]Dave W. Binkley, Marcia Davis, Dawn J. Lawrie, Jonathan I. Maletic, Christo-
pher Morrell, and Bonita Sharif. The impact of identifier style on effort and
comprehension. Empir. Softw. Eng., 18(2):219â€“276, 2013.
[4]Richard Bird and Philip Wadler. An Introduction to Functional Programming.
Prentice Hall International (UK) Ltd., GBR, 1988.
[5] L. Bossavit. The Leprechauns of Software Engineering. Laurent Bossavit, 2015.
[6]E. Chailloux, B. Pagano, and P. Manoury. DÃ©veloppement dâ€™applications avec
Objective Caml. Oâ€™Reilly, 2000.
[7]Craig Chambers. Object-oriented multi-methods in cecil. In Ole Lehrmann
Madsen,editor, ECOOPâ€™92EuropeanConferenceonObject-OrientedProgramming,
pages 33â€“56, Berlin, Heidelberg, 1992. Springer Berlin Heidelberg.
[8] Microsoft Cooperation. C# Language Specification Version 3.0. 2007.
[9]R. Dantas, A. Carvalho, D. MarcÃƒlio, L. Fantin, U. Silva, W. Lucas, and
R. BonifÃƒÂ¡cio. Reconciling the past and the present: An empirical study on
the application of source code transformations to automatically rejuvenate java
programs. In 2018 IEEE 25th International Conference on Software Analysis, Evolu-
tion and Reengineering (SANER), pages 497â€“501, 2018.
[10]ConalElliottandPaulHudak. Functionalreactiveanimation. In Proceedingsof
theSecondACMSIGPLANInternationalConferenceonFunctionalProgramming,
ICFPâ€™97,pages263â€“273,NewYork,NY,USA,1997.AssociationforComputing
Machinery.
[11]StefanEndrikat,StefanHanenberg,RomainRobbes,andAndreasStefik. Howdo
api documentation and static typing affect api usability? In Proceedings of the
1167
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Nils Mehlhorn and Stefan Hanenberg
36th International Conference on Software Engineering, ICSE 2014, pages 632â€“642,
New York, NY, USA, 2014. ACM.
[12]LarsFischerand StefanHanenberg. An empiricalinvestigationoftheeffectsof
typesystemsandcodecompletiononapiusabilityusingtypescriptandjavascript
in ms visual studio. SIGPLAN Not., 51(2):154â€“167, oct 2015.
[13]Lyle Franklin, Alex Gyori, Jan Lahoda, and Danny Dig. Lambdaficator: From
imperativetofunctionalprogrammingthroughautomatedrefactoring. In 2013
35thInternationalConferenceonSoftwareEngineering(ICSE),pages1287â€“1290.
IEEE, 2013.
[14]Erich Gamma, Richard Helm, and Ralph E. Johnson. Design Patterns. Elements of
ReusableObject-OrientedSoftware. Addison-WesleyLongman,Amsterdam,1st
ed., reprint. edition, 1994.
[15]Adele Goldberg and David Robson. Smalltalk-80: The Language and Its Imple-
mentation. Addison-Wesley Longman Publishing Co., Inc., USA, 1983.
[16]James Gosling, Bill Joy, Guy L. Steele, Gilad Bracha, and Alex Buckley. The
Java Language Specification, Java SE 8 Edition. Addison-Wesley Professional, 1st
edition, 2014.
[17]AlexGyori,LyleFranklin,DannyDig,andJanLahoda. Crossingthegapfrom
imperative tofunctional programming throughrefactoring. InBertrand Meyer,
Luciano Baresi, and Mira Mezini, editors, Joint Meeting of the European Software
Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of
Software Engineering, ESEC/FSEâ€™13, Saint Petersburg, Russian Federation, August
18-26, 2013, pages 543â€“553. ACM, 2013.
[18]Stefan Hanenberg and Nils Mehlhorn. Two n-of-1 self-trials on readability
differences between anonymous inner classes (aics) and lambda expressions (les)
on java code snippets. Empirical Software Engineering, 27(2):33, Dec 2021.
[19]JohannesC.Hofmeister,JanetSiegmund,andDanielV.Holt. Shorteridentifier
names take longer to comprehend. Empir. Softw. Eng., 24(1):417â€“443, 2019.
[20]MichaelHoppeandStefanHanenberg. Dodevelopersbenefitfromgenerictypes?
anempirical comparisonofgenericand rawtypesin java. In Proceedingsof the
2013 ACM SIGPLAN International Conference on Object Oriented Programming
Systems Languages and Applications, OOPSLA â€™13, pages 457â€“474, New York, NY,
USA, 2013. Association for Computing Machinery.
[21]ShriramKrishnamurthiandKathiFisler. Programmingparadigmsandbeyond
(chapter13). InS.A.FincherandA.V.Robins,editors, TheCambridgeHandbook
ofComputingEducationResearch,pages377â€“413.CambridgeUniversityPress,
2019.
[22]WalterLucas,RodrigoBonifÃ¡cio,EdnaDiasCanedo,DiegoMarcÃ­lio,andFernanda
Lima. Does the introduction of lambda expressions improve the comprehension
of java programs? In Proceedings of the XXXIII Brazilian Symposium on Software
Engineering,SBES2019,pages187â€“196,NewYork,NY,USA,2019.Association
for Computing Machinery.
[23]LechMadeyskiandBarbaraA.Kitchenham. Effectsizesandtheirvariancefor
AB/BA crossover design studies. Empir. Softw. Eng., 23(4):1982â€“2017, 2018.
[24]Davood Mazinanian, Ameya Ketkar, Nikolaos Tsantalis, and Danny Dig. Un-
derstanding the use of lambda expressions in java. Proc. ACM Program. Lang.,
1(OOPSLA):85:1â€“85:31, 2017.[25]SteveMcConnell. Whatdoes10xmean?measuringvariationsinprogrammer
productivity. InAndy Oram and GregWilson, editors, Making Software -What
Really Works, and Why We Believe It, Theory in practice, pages 567â€“574. Oâ€™Reilly,
2011.
[26]SebastianNanzandCarloA.Furia. Acomparativestudyofprogramminglan-
guages in rosetta code. In Proceedings of the 37th International Conference on
Software Engineering - Volume 1, ICSE â€™15, pages 778â€“788. IEEE Press, 2015.
[27]Sebastian Nielebock, Robert HeumÃƒÅ’ller, and Frank Ortmeier. Programmers
do not favor lambda expressions for concurrent object-oriented code. Empirical
Software Engineering, 24(1):103â€“138, 2019.
[28]F. Ortin, P. Conde, D. Fernandez-Lanvin, and R. Izquierdo. The runtime per-formanceofinvokedynamic:Anevaluationwithajavalibrary. IEEESoftware,
31(4):82â€“90, 2014.
[29]Victor Pankratius, Felix Schmidt, and Gilda Garreton. Combining functional and
imperative programming for multicore software: An empirical study evaluating
scala and java. Proceedings - International Conference on Software Engineering,
pages 123â€“133, 06 2012.
[30]M.Q. Patton. Qualitative Research & Evaluation Methods: Integrating Theory and
Practice. SAGE Publications, 2014.
[31]Benjamin C. Pierce. Types and Programming Languages . The MIT Press, 1st
edition, 2002.
[32]BaishakhiRay,DarylPosnett,PremkumarDevanbu,andVladimirFilkov. Alarge-
scale study of programming languages and code quality in github. Commun.
ACM, 60(10):91â€“100, September 2017.
[33]GuidoSalvaneschi,SebastianProksch,SvenAmann,SarahNadi,andMiraMezini.
On the positive effect of reactive programming on software comprehension: An
empirical study. IEEE Transactions on Software Engineering, 43(12):1125â€“1143,
2017.
[34]S.S.Senn. Cross-overTrialsinClinicalResearch. StatisticsinPractice.Wiley,2002.
[35]BjarneStroustrup. TheC++ProgrammingLanguage.Addison-WesleyProfessional,
4th edition, 2013.
[36]NikolaosTsantalis,DavoodMazinanian,andShahriarRostami. Clonerefactoring
withlambdaexpressions. In Proceedingsofthe39thInternationalConferenceon
Software Engineering, ICSE â€™17, pages 60â€“70. IEEE Press, 2017.
[37]Phillip Merlin Uesbeck, Andreas Stefik, Stefan Hanenberg, Jan Pedersen, and
PatrickDaleiden. Anempiricalstudyontheimpactofc++lambdasandprogram-
merexperience. In Proceedingsofthe38thInternationalConferenceonSoftware
Engineering, ICSE 2016, Austin, TX, USA, May 14-22, 2016, pages 760â€“771, 2016.
[38]Guido Van Rossum. Documentation of the Python Programming Language 0.9.
1991.
[39]S. Vegas, C. Apa, and N. Juristo. Crossover designs in software engineeringexperiments: Benefits and perils. IEEE Transactions on Software Engineering,
42(2):120â€“135, 2016.
[40]StefanWellekandMariaBlettner. Ontheproperuseofthecrossoverdesignin
clinicaltrialspart18ofaseriesonevaluationofscientificpublications. Deutsches
Ã„rzteblatt international, 109:276â€“81, 04 2012.
[41]C.Wohlin,P.Runeson,M.HÃ¶st,M.C.Ohlsson,B.Regnell,andA.WesslÃ©n. Experi-
mentationinSoftwareEngineering. ComputerScience.SpringerBerlinHeidelberg,
2012.
1168
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:21:07 UTC from IEEE Xplore.  Restrictions apply. 