Static Stack-Preserving Intra-Procedural Slicing of WebAssembly
Binaries
Quentin Sti√©venart
Vrije Universiteit Brussel
Brussels, Belgium
quentin.stievenart@vub.beDavid W. Binkley
Loyola University Maryland
Baltimore, MD, USA
binkley@cs.loyola.eduCoen De Roover
Vrije Universiteit Brussel
Brussels, Belgium
coen.de.roover@vub.be
ABSTRACT
TherecentlyintroducedWebAssemblystandardaimstobeaportable
compilation target, enabling the cross-platform distribution of pro-
gramswritteninavarietyoflanguages.Weproposeanapproach
tosliceWebAssembly programs in order to enable applications
inreverseengineering,codecomprehension,andsecurityamong
others.Givenaprogramandalocationinthatprogram,programslicingproducesaminimalversionoftheprogramthatpreserves
the behavior at the given location. Specifically, our approach isa static, intra-procedural, backward slicing approach that takesinto account WebAssembly-specific dependences to identify theinstructions of the slice. To do so it must correctly overcome the
considerablechallengesofperformingdependenceanalysisatthebi-narylevel.Furthermore,fortheslicetobeexecutable,theapproach
needs to ensure that the stack behavior of its output complies with
WebAssembly‚Äôsvalidationrequirements.Weimplementedandeval-
uated our approach on a suite of 8386 real-world WebAssembly
binaries, finding that the average size of the 495204868 slices com-
puted is 53% of the original code, an improvement over the 60%
attainedbyrelatedworkslicingARMbinaries.Togainamorequal-
itativeunderstandingoftheslicesproducedbyourapproach,we
compared them to 1956 source-level slices of benchmark C pro-
grams. This inspection helps to illustrate the slicer‚Äôs strengths and
to uncover potential future improvements.
KEYWORDS
Static program slicing, WebAssembly, Binary analysis
ACM Reference Format:
Quentin Sti√©venart, David W. Binkley, and Coen De Roover. 2022. Static
Stack-Preserving Intra-Procedural Slicing of WebAssembly Binaries. In
44thInternationalConferenceonSoftwareEngineering(ICSE‚Äô22),May21‚Äì
29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3510003.3510070
1 INTRODUCTION
The recent inclusion of WebAssembly binaries in web applications
posesnewchallengeswithrespecttotheirsecurity,comprehension,
and reverse engineering.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510070WebAssembly [ 25]‚Äúis a binary instruction format for a stack-
based virtual machine ‚Äù[65] designed as a compilation target for
high-level languages. The specification of its core has been a W3C
standardsinceDecember2019[ 49].WebAssemblywasdesignedfor
thepurposeofembeddingbinariesinwebapplicationsinaportable
manner, thereby enabling intensive computations on the web. A
2021 empirical study by Hilbig et al. [ 30] found use cases on the
web as diverse as game engines, natural language processing, and
mediaplayers.Thankstoitsabilitytoincorporateruntimefunctions
exportedbythehostenvironment,WebAssemblyhasalsofound
usagebeyondwebapplications,broadeningthevalueofanalysesfor
WebAssembly.Examplesincludedesktopapplications[ 63],smart
contracts [19], IoT back ends [27], and embedded software [52].
Programslicing[ 12,66]isaprogramdecompositiontechnique
that, based on a specific program point called the slicing crite-
rion, identifies a subprogram of the code relevant to the slicingcriterion. Program slicing has numerous applications, in debug-
ging[32,37,67],programcomprehension[ 11,16,31,36,59],soft-
ware maintenance [ 23,26], re-engineering [ 14], refactoring [ 20],
testing[4,28,29],reverseengineering[ 2,3],tierlessormulti-tier
programming [45, 46], and vulnerability detection [50].
Assuch,therearenumerousinvaluableapplicationsofslicingfor
WebAssembly binaries. Slicing, for example, can provide a building
blockfor reverseengineering andfor toolssuchas binarytransla-
tors, profilers, and debuggers [ 14]. In terms of security, slicing can
help with the inspection of WebAssembly binaries encountered in
thewildwherethesourcecodeisunavailable.Suchoftentedious
andtimeconsumingmanualinspectionsaimtounderstandthecode
wellenoughtoascertainthatitisfreefrommaliciousintent.Binary
slicing can also serve applications such as constructing abstract
program models for WCET estimation [41].
Programslicingapproachescanbecategorizedalongmultipledi-
mensions[ 51].Staticapproachescomputeaslicethatpreservesthe
behaviorforallpossibleprograminputs,while dynamicapproaches
consider only a subset of the inputs. Executable slicing approaches
produceaprogramthatcanbeexecuted,whileapproachescomput-
ing a dependence closure slice do not.Intra-procedural approaches
compute a slice that preserves the behavior of a given function,
whileinter-procedural approaches preserve the behavior of the
entireprogramacrossfunctioncalls.Finally,programslicingcan
identify the portion of the program that either affects the slicing
criterion (backward slicing )o ri sa ff ec t edb yi t( forward slicing ).
This paper presents the first static intra-procedural backward
slicing approach for WebAssembly that is capable of producingexecutable slices. Our approach relies on control and data depen-
dencies to identify the set of instructions that are part of a slice,given a specific instruction as the slicing criterion. This requires
WebAssembly-specificdatadependenciesandcontroldependencies,
20312022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Quentin Sti√©venart, David W. Binkley, and Coen De Roover
whichweidentifyanddescribeindetail.Furthermore,itrequires
satisfying the WebAssembly validation requirement : WebAssembly
programsmustadheretoaparticularstackdisciplineinordertobe
executable.Correctlyremovinginstructionsthatarenotpartofthe
slice(i.e.,thatdonothaveanyeffectontheslicingcriterion)may
violate this property. Thus the slicer must identify places where
the closure slice may leave the stack in an undesirable state and
then compensate by including additional instructions to satisfy the
validation requirement.
This paper makes the following contributions:
(1)Wedescribethefirststaticintra-proceduralbackwardslicing
approachforWebAssembly.Thefirsttwophasesofthisthree-
phasealgorithmcomputea closureslice ofaWebAssembly
binary.
(2)Toproducean executable slice,ouralgorithm‚Äôsthirdphase
implements a stack-preserving approach to produce a valid
executable WebAssembly program from the closure slice.
(3)Usinganimplementationofourthree-phasealgorithm,we
empiricallyevaluateourapproachquantitativelyonareal-
worlddatasetof8386WebAssemblyprogramsscrapedby
Hilbig et al. [ 30], from which we compute 495204868 slices,
andqualitativelybycomparingslicesproducedbyourim-
plementation against slices produced by CodeSurfer [ 58]o n
a set of 49 C programs compiled to WebAssembly.1
2 BACKGROUND: A BRIEF TOUR OF
WEBASSEMBLY
WebAssembly is a stack-based assembly language. For the sake
of simplicity, we describe our approach using a minimal version
ofWebAssemblycalledMiniWasm,introducedbySti√©venartand
De Roover [ 54]. MiniWasm retains the defining features of Web-
Assembly, including structured control flow, the most essential
assembly instructions, direct function calls, indirect function calls
throughfunctiontables,unaryandbinaryoperations,and32-bit
integers.Ourimplementationactuallysupportsalargersubsetof
WebAssembly as demonstrated by our consideration of real-world
programs in our empirical evaluation, where we are able to slice99.991% of 495248788 potential slicing criteria. We describe our
implementation and its limitations in further detail in Section 4.1.
2.1 The MiniWasm Language
Figure 1 depicts the syntax of MiniWasm. A moduleconsists of
a sequence of type declarations ( type‚àó), a sequence of function
declarations ( func‚àó), and a table ( table) that identifies the targets of
indirect function calls. As this work presents an intra-procedural
slicingapproach,wefocusonfunctiondeclarations.Amoredetailed
explanation of MiniWasm and its formal semantics is given by
Sti√©venart and De Roover [54].
Afunctionisdeclaredwithatypeindex tidx,whichcorresponds
to the type declaration at that index in the sequence of type decla-
rations.Functions firstdeclarethe typesoftheir localvariables.Pa-
rameters and local variables are anonymous and accessed through
anindex.Forexample,afunctionwithoneformalparameter and
1Our implementation is available publicly at https://github.com/acieroid/wassail/tree/
icse2022, and a full replication package is available at https://zenodo.org/record/
5821007.module::=(moduletype‚àófunc‚àótable)
type::=(type (func ft))
bt,ft::=ùë°‚àó‚Üíùë°‚àó
t::=i32
func::=(func (type tidx))
|(func (type tidx) (local ùë°‚àó)instr‚àó)
table::=(tableùëõ‚àó)
instr::=data|control
data::=drop|ùë°.constùëõ|ùë°.binop|ùë°.unop
|local.getùëõ|local.setùëõ
|global.get ùëõ|global.set ùëõ
|ùë°.load|ùë°.store
control::=blockbt instr‚àóend|loopbt instr‚àóend
|ifbtinstr‚àóelseinstr‚àóend
|callftùëõ|call_indirect ft|br_ifùëô
ùëõ,ùëô,tidx::=a number
Figure 1: Syntax of MiniWasm
two local variables accesses the formal parameter at index 0 and
thelocalvariablesatindices1and2.Theremainderofafunction
declaration is the sequence of instructions that form the function‚Äôs
body.
Broadly speaking, there are two kinds of instructions. Control
instructions (e.g., loopand call)structuretheprogram‚Äôscontrol
flow, while data instructions manipulate the stack ( drop,const),
locals ( local.get and local.set ), and globals ( global.get
and global.set ). Operations (binop andunop) are left unspec-
ifiedastheirconcreteinstantiationisinconsequentialtoprogram
slicing. Blocks ( block), loops ( loop), and function calls ( call,
call_indirect )areannotatedwiththeirtypes(respectively, bt
andft). Blocks act as delimiters inside functions for identifying
jumptargets.Loopsarebasicallyblockswhosesemanticscapture
the iterating behavior. We include an ifinstruction in MiniWasm
that was previously treated as syntactic sugar [ 54]. It is a condi-
tional that encloses one consequent branch and one alternative
branch.
2.2 The SCAM Mug in MiniWasm
ToillustrateprogramminginWebAssembly,weconsiderthe‚ÄúSCAM
Mug‚Äù [61] C program, which is heavily used in the slicing litera-
ture.Theprogram,whichfeaturedonthesouvenirmuggivento
attendees at the first SCAM workshop, is designed to challenge
staticanalysistools,especiallythosemakinguseoftransitivede-
pendence analysis. For example, the minimal slice at the end of the
codetakenwithrespecttothevariable xdoesnotincludeLine8
despite the transitive dependence. The code features the following
main function in C where all called functions are side-effect free:
2032
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Stack-Preserving Intra-Procedural Slicing of WebAssembly Binaries ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
1int main() {
2 int i=0 ;
3 int x=0 ;
4 int c=0 ;
5 while (p(i)) {
6 if(q(c)) {
7 x=f ( ) ;
8 c=g ( ) ;
9 }
10 i = h(i);
11 }
12 }
The equivalent function in MiniWasm is given below, with func-
tionsp,q,f,g,andhassignedtheindices0,1,2,3,and4respectively:
1(func (type 0) ;; int main()
2 (local i32 i32 i32 );; declare i, x, c
3 local.get 0 ;; push local i
4 calli32‚Üíi32 0 ;; p(i)
5 if
6 loop
7 local.get 2 ;; push local c
8 calli32‚Üíi32 1 ;; q(c)
9 if
10 call 2‚Üíi32 ;; f()
11 local.set 1 ;; x = result of f()
12 call 3‚Üíi32 ;; g()
13 local.set 2 ;; c = result of g()
14 end
15 local.get 0
16 call 4i32‚Üíi32 ;; h(i)
17 local.set 0 ;; i = result of h(i)
18 local.get 0
19 call 0i32‚Üíi32 ;; p(i)
20 br_if 0 ;;loop if stack top
21 end ;; is true
22 end)
OnLine2,thefunctiondeclarestheequivalentoflocalvariables
i(withindex0), x(index1),and c(index2).Alllocalvariablesare
initialized to zero in WebAssembly. Line 3 retrieves and pushes
the value of the first local variable on the stack. The next line calls
function 0, which expects its single argument to be on the top
of the stack (in this case local 0). The if-instruction on Line 5
checks whether the top of the stack (the function‚Äôs return value)is
true(differs from 0) and if so executes its thenbranch, which
capturesthebodyoftheloop.Anoptional elsebranchisunnecessary
here.Thisinstructionshouldnotbeconfusedwith br_if n,which
breaks nnested blocks if the value on the top of the stack is true.
The loopinstructiononLine6denotesthestartofaloop.When
execution encounters a breakit re-executes the loop from the start.
InWebAssembly,the‚Äúbreaking‚Äùofaloopbehaveslikea continue
statementinC.Intheexample, br_if 0startsthenextiteration
ifthevalueonthetopofthestackis true.The‚Äú 0‚Äùsignifieswhich
loop, in this case the immediately enclosing loop (Line 6). If no
breaks areencountered, executioncontinues withthe instruction
that follows the loop‚Äôs matching endkeyword. Thus Lines 5, 6,
and 20 combine to implement the whileloop of the C program.
The bodyof the loop callsfunction 1 with localvariable 2 ( q(c))
on Line 8. If the result of this call is non-zero, it calls function 2 ( f)
andassignstheresulttolocalvariable1( x)onLine11,anddoesthe
samewithfunction3( g)andlocalvariable2( c).Finally,nearthe
end of the loop body on Line 17, local variable 0 ( i) is assigned the
result of function 4 ( h(i)). Finally, the br_ifinstruction on Line 20checkstheloopcondition(thevalueonthetopofthestack),and
jumps back to the beginning of the loop if the value is non-zero.
2.3 WebAssembly Validation Requirement
WebAssemblyprogramshavetobe wellformed,accordingtoSec-
tion 3 of the WebAssembly standard [ 49]. Of particular interest for
program slicing is that the body of a function has to be well typed.
Eachinstructionhasaspecific stacktype ùë°‚àó
1‚Üíùë°‚àó
2,whereùë°‚àó
1isthe
expectedsequenceoftypesforthevaluesontopofthestackbeforethe execution of the instruction, and
ùë°‚àó
2is the sequence of types for
the values on top of the stack after its execution. For example, the
i32.const 0 instructionhastype‚Äú ‚Üíi32‚Äù,meaningthatitdoes
not need anything from the stack and pushes one value of type
i32. Typing extends to sequences of instructions, e.g., the sequence
local.get 0 ,local.get 1 ,i32.const 1 ,i32.addhas type
‚Äú‚Üíi32 i32‚Äù.
ThefollowingexampleillustratestheimpactthatslicingWeb-
Assembly code can have on this validation requirement.
1(func (type 1)
2 local.get 0 ;; push f irst parameter
3 if
4 local.get 0 ;; push fi rst parameter
5 local.get 1 ;; push s econd parameter
6 i32.add ;; slicing criterion
7 call 0i32‚Üíi32
8 drop
9 end)
Thisfunctiontakestwoparameters(assumingthattype1is‚Äú i32,i32
‚Üí‚Äù).Itfirstpushesthefirstparameteronthestack(Line2),and,if
that parameteris non-zero, executesthe body ofthe ifstatement
(Line3).Thiswillpushbothparametersonthestack(Lines4and
5), sum them (Line 6), and then call function 0, before droppingthe return value of the call from the stack. This leaves the stack
emptyattheendofthefunction‚Äôsexecution.Ifthevalueofthefirstparameterwaszero,theifbodyisnotexecuted,buttheconditionisstillremovedfromthestack,henceinbothcasesthestackisempty
at the end of the function‚Äôs execution.
Considertheintra-proceduralclosureslicetakenwithrespectto
the instruction i32.add. This instruction requires that two values
are available on the stack. Through use-definition chains that can
becomputedstatically,weknowthatthefirstvalueiscomputedby the instruction
local.get 1 on Line 5, while the second is
computed by the instruction local.get 0 on Line 4. These are
thedata dependencies of the i32.addinstruction. The execution
of the i32.addinstruction depends on whether the ifstatement
executesits thenbranch.Therefore,Line3isa controldependency
andneedstobeincludedintheslicetoo.Finally,the ifinstruction
has a data dependency on Line 2 as the value pushed is used as
the condition. As a result, we obtain the following closure slice: it
containsalltheinstructionsrelevanttotheevaluationoftheslicing
criterion.
2033
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Quentin Sti√©venart, David W. Binkley, and Coen De Roover
1(func (type 1)
2 local.get 0
3 if
4 local.get 0
5 local.get 1
6 i32.add
7 end)
However,thisclosureslicedoesnotrepresentavalidWebAssembly
program as it leaves one value on the stack in the ifstatement.
Any attempttoexecute sucha programwill leadto anerror from
the WebAssembly validator. Phase three of our algorithm includes
adropinstruction after Line 6 to effectively clean up the stack.
3 THE WEBASSEMBLY SLICING ALGORITHM
Ouralgorithmconsistsofthreephases:adata-gatheringphasethat
computes the dependencies of each instruction in a function, a
slicingphasethatidentifiestheWebAssemblyinstructionsofthe
closureslice,andareconstructionphasethatincludesadditional
instructionstomaintainthestackdisciplineandthusensurethat
the slice is a valid executable WebAssembly function. This section
details each of the three phases.
3.1 Data-Gathering Phase
The data-gathering phase computes the following elements.
Stack Layout. For WebAssembly programs, the layout of the
stack can be computed statically for any instruction, including
loops.Astackspecificationanalysis[ 54]computestheimpactof
everyinstructiononthestackandassignsnamestoeachelementin
theresultingstacklayout.Toillustrate,thefollowingcodehasbeenannotatedwiththeresultsofthestackspecificationanalysiswhere,
for example, [i0]denotes a stack that contains a single element,
denoted by the opaque identifier i0.
1local.get 0 ;; [i0]
2i32.const 2 ;; [i1, i0]
3i32.add ;; [i2]
4call 1i32‚Üí ;; []
Use-DefinitionChains. Inordertoidentifydatadependences[ 43],
uses of each element on the stack are linked to their respective
definitions through use-definition chains [ 33]. For example, in the
previous code listing the instruction i32.addusesi1andi0and
definesi2.Use-definitionchainsmaptheuseof i1toitsdefinition
by the instruction i32.const 2 and the use of i0to its definition
by the instruction local.get 0 . Here a use, denoted use, is a pair
consisting of the name of an element on the stack (e.g., i0), and
the occurrence of an instruction (e.g., the position of a specific
i32.constinstruction in the binary). We denote the set of uses
of instruction instrasuses(instr)and the set of instructions that
contain the definitions corresponding to a use as defs(use).
Memory Dependences. Identifying data dependences through
use-definition chains alone does not suffice for slicing as therecan be indirect data dependences that arise through the use of
WebAssembly‚Äôslinearmemory,whichmodelstheprogramheap.
For example, the i32.loadinstruction in the following code is
data-dependentonthe i32.storeinstruction:aslicethatincludes
the load instruction but not the corresponding store instruction
would not preserve the semantics.1i32.const 1024 ;; stack: [1024]
2i32.const 0 ;; stack: [1024, 0]
3i32.store ;; stack: [], stores 0 at 1024
4i32.const 1024 ;; stack: [1024]
5i32.load ;; stack: [0], loads 0 from 1024
Modelingmemorydependenciespreciselyrequiressomeformof
alias analysis. To date no alias analysis algorithm has been devised
forWebAssembly.Thusweresorttoasoundover-approximation:
allloadinstructions are marked as potentially data-dependent on
every store that may be executed before the loadinstruction (i.e.,
for which there exists a path in the CFG from the storeto the
load).Asimilarover-approximationisusedforthememorydepen-
denciesof callinstructions.Indeed,asthefollowingcodecould
representthecallofafunctionwithapointerasargument,anypre-cedingmodificationtoanypointerneedstobeincludedintheslice.
1i32.const 1024 ;; 1024 could be a pointer
2call 1
callinstructionsarethereforetreatedasboth loadinstructions
(memory can be read during a function call) and storeinstruc-
tions (memory can be written during a function call). Both over-approximations could be rendered more precise with additional
informationfromasoundaliasanalysis.Wedenotetheinstructions
that are memory dependencies of an instruction instras the set
memoryDeps (instr).
global.set Instructions. InWebAssembly,globalvariablescan
be used to share data across function calls. For example, when
producingWebAssembly,currentC compilersuseglobal variable
0 as the address in the linear memory where the stack pointerresides [
38]. Incrementing or decrementing the value of global 0
is used to grow or shrink the stack. Although there might be no
explicit dependence on global variable 0, it is important to include
anyinstructionthatmodifiesitintheslice.InthecaseofCprogramscompiledtoWebAssembly,thisensuresthatfunctioncallspreserve
the same call-stack semantics. For the same reason, and becauseour approach is intra-procedural and thus cannot know which
global variables are required across function calls, all global.set
instructionsarecollectedandconsideredpartoftheslice.Thisover-approximationisindependentoftheslicingcriterion.Thisisagaina
conservative over-approximation: in practice, not all global.set
instructionsarerelevantfortheslicingcriterion.Wedenotetheset
of all global.set instructions as globalSetInstrs .
Control Dependences. In addition to data dependences, slices
needtoaccountforcontroldependencesastheycapturewhether
aninstructionis executedornot.Consider thefollowingexample,
where the value of local variable 0 is initially set to 0, and then set
to 1 if the value of local 1 is true (i.e., any non-zero value).
2034
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Stack-Preserving Intra-Procedural Slicing of WebAssembly Binaries ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
1i32.const 0
2local.set 0 ;; local 0 = 0
3local.get 1
4if
5 i32.const 1
6 local.set 0 ;; local 0 = 1
7end
8;; value of local 0 depends on
9;; the value of local 1
10 local.get 0
Here,theinstruction local.set 0 inthebodyofthe ifiscontrol-
dependentonLine4,whichisdata-dependentontheinstruction
local.get 1 .Hence,boththe ifand local.get 1 instructions
willneedtobeincludedinanyslicethatincludestheinstruction
local.set 0 onLine6.Werelyontheso-called‚Äúexactalgorithm‚Äù
byFerranteetal.[ 21]tocomputecontroldependences.Wewrite
controlDeps (ùëè)={ùëé}when Instruction ùëèis control-dependent on
Instruction ùëé,orinotherwords,whenthereisacontrol-dependence
fromùëétoùëè. Hence, controlDeps (instr)maps an instruction to the
instructions on which it depends on due to control dependences.
3.2 Slicing Phase
Our algorithm for identifying the instructions that makeup the
closure slice is inspired by traditional approaches to slicing [ 67]
wheretheslicingcriterion,datadependences,andcontroldepen-
dences are used to transitively add instructions to the slice. We
include Agrawal‚Äôs additions for structured control flow [ 1], which
arerequiredtoproperlysupportWebAssembly‚Äôsstructuredjump
instructions (e.g., br). Note that unlike most slicing approaches
where the slicing criterion includes a program location and one
ormorevariablesofinterest,weonlyrequireaprogramlocation,
given as an instruction, as the slicing criterion. The variables of
interest are implicitly determined by the instruction.
InordertosupportWebAssembly ,however,tw odomain-specific
extensionsareneeded.First,becausewedonothaveinter-procedural
information, global.set instructionsareconsideredpartofthe
sliceasexplainedpreviously.Second,withoutprecisealiasingin-
formation any write to the memory potentially influences any sub-
sequentreadfromthememory,thusmemorydependencescome
into play as soon as any read is included in the slice.
Ourslicingalgorithm,givenasAlgorithm1,worksasfollows.
The slice starts empty (Line 1) and the initial worklist contains the
instructionthatistheslicingcriterionaswellasall global.set
instructionsfoundinthefunctionbeingsliced(Line2).Thealgo-
rithmthenproceedsasatypicalworklistalgorithm.Instructions
instrin the worklist that are already part of the slice are ignored
(Line 6). Other instructions are added to the slice (Line 7) and their
dependencies are added to the worklist:
‚Ä¢use-definition chains are followed to find data dependences:
foreachuseofavalueonthestack(Line8),theinstructions
that define that value are added to the worklist (Line 9),
‚Ä¢thecontroldependenciesofthecurrentinstructionareadded
to the worklist (Line 10),
‚Ä¢the memory dependencies of the current instruction are
added to the worklist (Line 11).
Once the worklist is exhausted, the resulting slice is augmented
accordingtoAgrawal‚Äôstechnique,specificallythe conservativealgo-
rithmgiven in Fig. 13 of their paper [ 1], where the brinstructions(as unconditional jumps in WebAssembly) are treated as gotostate-
ments. For each instruction in the slice, all brinstructions that
are control-dependent on the instruction are added to the slice
(Line16).Theslicingalgorithmreturnsthesliceaugmentedwith
these additions (Line 17).
slice(slicing criterion c, set of global.setinstructions
globalSetInstrs , set of brinstructions brInstrs, use of stack
locations uses, use-definition chains defs, control dependences
controlDeps , memory dependences memoryDeps )
1letslice‚Üê{ };
2letworkList‚Üê{ùëê}‚à™globalSetInstrs ;
3whileworkList‚â†{}do
4letinstr‚ààworkList;
5workList‚ÜêworkList\{instr};
6 ifinstr‚àâslicethen
7 slice‚Üêslice‚à™{instr};
8 foruse‚ààuses(instr) do
9 worklist‚Üêworklist‚à™defs(use);
10 worklist‚Üêworklist‚à™controlDeps (instr);
11 worklist‚Üêworklist‚à™memoryDeps (instr);
12letsliceExtension ‚Üê{ }
13forinstr‚ààbrInstrs do
14 forinstr‚Äô‚ààslicedo
15 ifinstr‚Äô‚ààcontrolDeps (instr) then
16 sliceExtension ‚ÜêsliceExtension ‚à™{instr};
17returnslice‚à™sliceExtension;
Algorithm 1: Slicing Algorithm
3.3 Reconstruction Phase
The closure slice computed by the previous phase may not form
avalidWebAssemblyfunction.Toillustratewhyandtoshowthe
reconstruction‚Äôs impact both before and after an instruction of the
slice,we usethefollowing codefragment.Thefragment hastype
‚Äú‚Üí‚Äù(i.e.,itdoesnotconsumeanythingfromthestacknorproduce
anything onto the stack). Its constituent instructions have been
annotated with their own types:
1local.get 0 ;;‚Üíi32
2i32.const 2 ;;‚Üíi32
3i32.add ;;i32,i32‚Üíi32
4calli32‚Üí ;;i32‚Üí
Suppose this fragment is sliced with respect to Line 2. The instruc-
tion i32.const 2 forms a closure slice on its own because it is
not influenced by any other instruction in the fragment. However,
this slice has type ‚Äú ‚Üíi32‚Äù, while the type of the original fragment
is‚Äú‚Üí‚Äù.AsthefragmentmayresideinaWebAssemblyconstruct,
suchasablockorafunction,thatexpectsaspecifictype,replacing
the fragment by its slice will result in an invalid WebAssembly
program.
Toovercomethisissue,reconstructionaugmentstheclosureslice
withsyntheticinstructionsthatpreservetheoriginalstacklayout
and thereby render the slice valid and executable. Adding these
synthetic instructions is safe, because they have no side effects on
theprogrambehaviorregardingtheslicingcriterion.Thesequence
of synthetic instructions that is introduced must have the same
2035
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Quentin Sti√©venart, David W. Binkley, and Coen De Roover
typeasthesequenceofinstructionsitreplaces.Thefragmentbelow
illustrates the rewriting. It includes type summaries in place of the
instructionsthatarenotpartoftheslice.Notehowthetypesofthe
final two instructions ( i32.addand calli32‚Üí) have been merged
into a single type summary that has the same effect on the stack.
1?? ;;‚Üíi32
2i32.const 2 ;;‚Üíi32
3?? ;;i32,i32‚Üí
Thegoalofthereconstructionphaseistoaddsyntheticinstructions
thathavethedesiredtypesummary.Ourreconstructionphaseuses
i32.constwhen a summary pushes an i32value on the stack and
dropto remove a value from the stack. This process results in
the following reconstructed slice, which is of the same type as the
original fragment.
1i32.const 0 ;;‚Üíi32
2i32.const 2 ;;‚Üíi32
3drop ;;i32‚Üí
4drop ;;i32‚Üí
While the reconstructed slice has the same type as the original
fragment,itisnotminimal: i32.const 2; drop isshorterandan
equallyvalidslice.Wehaveoptedtonotattemptaglobalminimum
butratheronethatislocaltoeachsummary(e.g., drop; drop is
theminimalsetofinstructionswiththetype‚Äú i32,i32‚Üí‚Äùthatcan
be inserted in place of the second summary, ‚Äú ??;;i32,i32‚Üí‚Äù).
This design choice has the advantage of only requiring a single
linear traversal of the fragment‚Äôs instructions.
Algorithm2depictsthereconstructionalgorithm.Weusethe ¬∑
operator to concatenate sequences: [1,2]¬∑[3]is[1,2,3], and over-
loadittoinsertanelementbetweentwosequences: [1,2]¬∑3¬∑[4]is
[1,2,3,4].Auxiliaryfunction isInSliceidentifiestheinstructionsthat
arepartoftheclosuresliceaccordingtoAlgorithm1.Auxiliaryfunc-
tionreplacereturnsasequenceofsynthetic i32.constand dropin-
structionssuchthatthetypeoftheentiresequenceisthesameasthe
instructions being substituted. For example, replace(i32.const 1 ;
i32.const 2 ;i32.add) returns i32.const 0 , because both se-
quences of instructions push a single value onto the stack.
Function validSlicereturns a type-valid WebAssembly slice for a
given sequence of instructions. To produce an executable slice it
is initially called with the body of the sliced function‚Äîfrom which
the result is built up recursively. Instructions that are part of the
closureslicewillbeincludedintheresulttogetherwithsynthetic
instructionsthatreplaceinstructionsthatarenotpartoftheslice
whilepreservingtheirsummarytype. Thealgorithmmaintainsin
itssecondargumentasequence, removed,ofinstructionsthatare
not part of the closure slice and thus will be replaced by synthetic
instructions.
If there are no instructions to process (Line 1), meaning that the
lastinstructionofasequencehasbeenprocessed,anyremaining
instructionsin removedarereplacedbyatype-equivalentsequence
of synthetic instructions (Line 2). For instructions that contain
sequencesofinstructions( block,loop),thecorrespondingbody
isfirstprocessedrecursively(Line7).Iftherearenoinstructions
to keep inthe body, the instructionitself is added tothe sequence
ofinstructionstoremove(Line9).Otherwise,itsbodyisreplaced
with the sliced body (Line 11) and the subsequent instructions are
processed (Line 12). The process for an ifinstruction is similar
(Line13)exceptthatbothbranchesneedtobeprocessedandtheinstructioncanberemovedonlyifbothbranchesbecomeempty
(Line 16).
For all other instructions, if the instruction is part of the closure
slice(Line21),thepreviousinstructionsthathavebeenremoved
arefirstreplacedbytheirequivalentsyntheticinstructions,then
theinstructionisaddedtotheresultbeforetheresultsofprocessing
the subsequent instructions (Line 22). Otherwise, if the instruction
is not part of the slice (Line 23), it is appended to removed(Line 24)
and a recursive call is made on the remaining instructions. As a
result, one obtains a valid, executable, WebAssembly program that
is a superset of the closure slice that preserves the behavior of the
slicing criterion and is thus executable.
isInSlice (instruction instr)
checks whether instris part of the slice;
replace (sequence of instructions instrs)
returna sequence of dummy instructions that has the same
type asinstrs;
validSlice (sequence of instructions instrs,
sequence of instructions removed)
1ifinstrs=/angbracketleft/angbracketrightthen
2 returnreplace (removed);
3else
4letinstr‚Üêhead(ùëñùëõùë†ùë°ùëüùë†);
5letinstrs‚Üêtail(ùëñùëõùë†ùë°ùëüùë†);
6 ifinstr is a blockorloopinstruction then
7 letbody‚ÜêvalidSlice (instr.body,/angbracketleft/angbracketright);
8 ifbody=/angbracketleft/angbracketrightthen
9 returnvalidSlice (instrs,removed¬∑instr);
10 else
11 letinstr‚Äô‚Üêinstrwith its body set to body;
12 return
replace (removed) ¬∑instr‚Äô¬∑validSlice (instrs,/angbracketleft/angbracketright);
13 else ifinstr is an ifinstruction then
14 letthen‚ÜêvalidSlice (instr.then,/angbracketleft/angbracketright);
15 letelse‚ÜêvalidSlice (instr.else,/angbracketleft/angbracketright);
16 ifthen=else=/angbracketleft/angbracketrightthen
17 returnvalidSlice (instrs,removed¬∑instr);
18 else
19 letinstr‚Äô‚Üêinstrwith its branches set to then
andelse;
20 return
replace (removed) ¬∑instr‚Äô¬∑validSlice (instrs,/angbracketleft/angbracketright);
21 else ifisInSlice (instr) then
22 return
replace (removed) ¬∑instr¬∑validSlice (instrs,/angbracketleft/angbracketright);
23 else
24 returnvalidSlice (instrs,removed¬∑instr);
Algorithm 2: Slice Reconstruction Algorithm
4 EVALUATION
Weevaluateourapproachthroughthefollowingresearchquestions.
RQ1:Howdoesstaticstack-preservingslicingbehaveonclassical
slicingexamples? Theliteratureonprogramslicinghasproduced
2036
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Stack-Preserving Intra-Procedural Slicing of WebAssembly Binaries ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
several challenging examples which have each been studied exten-
sively. We manually translate these examples to WebAssembly and
inspect the output of our slicer for each.
RQ2:Whatisthesizeofclosureslicesbuiltbyourslicingphase?
WeapplyourapproachtothedatasetcollectedbyHilbigetal.[ 30],
which consists of real-world occurrences of WebAssembly from
the web. We use each instruction of each function in the dataset
asaslicingcriteriontowhichweapplyAlgorithm1.Wepresent
descriptive statistics about the size of the resulting closure slices.
RQ3: By how much do slices need to grow in order to render them
executable? RelyingonthesamedatasetasusedinRQ2,wemeasure
theincreaseinslicesizeaftertheclosureslicehasbeenrendered
executable.
RQ4: How much time is needed by each phase in order to compute
an executable slice? We measure the time needed by each phase
when computing an executable slice.
RQ5: How does static stack-preserving slicing of WebAssembly
binaries compare to slicing the original source code directly, beforeits compilation to WebAssembly? In cases where the source code
ofaWebAssemblyprogramisavailable,itmightbepreferableto
slice the source code instead of the binary. We compare the results
of our approach to the static slices of C programs computed by
CodeSurfer [58].
WeconductedourevaluationonamachinewithanAMDRyzen
Threadripper 3990X 64-Core CPU (2.9 GHz) with HyperThreading
and256GiBofRAM,running128slicingjobsinparallel(oneper
logicalcore).Beforedetailingtheresearchmethodandresultsfor
eachoftheseresearchquestions,webrieflydescribeourimplemen-
tation.
4.1 Implementation
Weimplementedtheapproachdescribedinthispaperontopofthe
Wassail framework [ 55], using OCaml version 4.12.0. Its loader
for WebAssembly binaries is based on the implementation that ac-
companiestheofficialWebAssemblystandard.Ourimplementation
first conducts the data-gathering phase described in Section 3.1.
Next,itidentifiestheinstructionsoftheclosuresliceusingAlgo-
rithm 1, before rendering the slice executable using Algorithm 2.
OurimplementationsupportsmostoftheWebAssembly1.0core
specification [49], but has the following limitations:
‚Ä¢The br_table instruction is only supported when all its
targetsexpectthesamestacklayout.Thisisalimitationof
the stack specification analysis.
‚Ä¢CodethatliesinaCFGnodethatisdisconnectedfromthe
CFGentrynodecannot be used astheslicing criterion be-
causeourimplementationofuse-definitionchainsrequiresa
path from the entry node of the CFG to the slicing criterion.
Theselimitationsbothconcernthedata-gatheringphase,andwe
leaveovercomingthemforfuturework.Inourevaluationwitha
real-worlddataset,weencounteredtheselimitationsin0.009%of
the slices, where 28% of the non-supported slices are caused by
unsupported uses of the br_table instruction, and 72% by discon-
nected code.4.2 RQ1: Behavior on Classical Examples
Wefirstperformaqualitativeevaluationofourslicingapproachon
examplesthathavebeenstudiedintheslicingliterature,namelythe SCAM Mug example [
61], the Montr√©al Boat example [ 15],
WordCount[ 23],andAgrawal‚Äôscontrolexamples[ 1].Wemanu-
allyencodedeachprogramtoWebAssembly,beforeapplyingour
approach.Allsourceprogramsandthecomputedslicesareavailable
in our replication package.
OurfirstexampleistheSCAMMugexamplepresentedinSec-
tion 2 using Line 11, local.set 1 , as the slicing criterion. Key
to understanding the challenge in this example is to realize thatthe value assigned to
cdoes noteffect the value of xat Line 11.
Thus a minimal slice would exclude Lines 12 and 13. However, the
expectedbehaviorofaslicerbasedontransitivedependenceisto
includethese lines[ 8].Our slicercorrectly producestheexpected
slice including these lines.
The Montr√©al Boat example [ 15] poses a similar dependence
challenge. Being based on dependence closure our approach is
unableto teaseapart the dependences.However,itdoes correctly
produce the expected, non-minimal, slice.
TheWordCountexample,introducedbyGallagherandLyle[ 23],
uses five different slicing criteria (e.g., a slice that computes justthe number of lines in the input). After translating this exampleto WebAssembly, we produced the five corresponding slices andmanually compared each to the expected result provided by Gal-
lagherandLyle,translatedtoWebAssembly.Ineachcaseourslicer
produces the desired minimal slice.
The examples of Agrawal [ 1] demonstrate the need to treat un-
conditional jumps when slicing programs that use gotostatements.
WetranslatedtheexamplesfromFigures3and5oftheirpaperto
WebAssembly, along with the expected slices. Our slicer correctly
includes the necessary unconditional jumps ( brinstructions). It
doesincludemoreinstructionsthanthetranslationofAgrawal‚Äôs
slices. This is due to the fact that purity assumptions that are made
inAgrawal‚Äôsslicesregardingsomecalledfunctionsarenotmade
by our slicer. However, our slicer produces correct slices.
RQ1: While our approach shares the limitations of other static
slicersonexamplessuchastheSCAMMugandtheMontr√©al
Boat examples, it performs well on the more straightforwardexamples. It is exact when computing the Word Count slices,andtheslicesforeachofAgrawal‚Äôsexamplesmerelyincludeunwanted call instructions due to our over-approximation of
memory dependences.
4.3 RQ2: Closure Slice Size
Hilbigetal.[ 30]gatheredadatasetof8461uniqueWebAssembly
programs.Weusethisdatasetinourevaluationafterfilteringout
the 75 programs that could not be loaded. For each of the 1788688
functions in the remaining programs, we use each instruction as a
slicingcriterionyielding495204868slices.Thisisakintorelated
work[9]whichusedeachSDGvertexasaslicingcriterion.Weuse
a timeout of 4 hours per program.
The dataset, our implementation and evaluation scripts, and
thedataresultingfromourevaluationforRQ2,RQ3,andRQ4are
available in our replication package.
2037
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Quentin Sti√©venart, David W. Binkley, and Coen De Roover
The size of the initial functions and their closure slices are sum-
marized in Figure 2. The mean size of the slices produced by Algo-
rithm1is ùúá=52%oftheoriginalfunctionsize.Thisismorethan
the 27-30% averages obtained by the C slicing techniques surveyed
byBinkleyandHarman[ 10].Therearetwopotentialreasonsfor
this. First, WebAssembly, being lower level than C, provides fewer
semanticcuestotheslicer.Second,ourover-approximationsregard-
ingthememoryand global.setinstructionscanincreaseslicesize.
However our 52% is lower than the 60% average slice size reported
byKissetal.whenslicingARMbinaries[ 34,35].Inthiscasethe
likely cause is WebAssembly‚Äôs use of structured control flow.
RQ2: Our slicing algorithm (Algorithm 1) computes slices that
areonaverage52%ofthesizeoftheoriginalprogram,whichis
lowerthanrelatedworkonbinaryslicing,butlargerthanthe
results of source code slicers.
Figure 2: Sizes of the slices on a real-world dataset.
4.4 RQ3: Executable Slice Size
WenowturntotheimpactofAlgorithm2,whichproducesvalid,
executable slices from the closure slices studied by RQ2. As shown
in Figure 2 the size of the slices increases from 52% to 53%. As
evidencedbytheoutliersinthelowergraph,someexecutableslices
arelargerthan theoriginalprogram.Thisphenomenonislimited
toahandfuloftheslices(intotal,itaffectsonly0.08%oftheslices),
where an average of 2.2 instructions are included per slice.
We manually investigated a statistically relevant sample (384
slices2) of these cases to identify underlying causes. The most com-
mon cause, impacting 98% of the manually investigated slices, is
when an instruction that removes two or more values from the
stack that is not part of the closure slice gets replaced by two or
more dropinstructions, resulting in a positive net change to the
numberofinstructions.Forexample,removinga calltoafunc-
tionwith20argumentsreplacesthe callinstructionwith20 drop
instructions, thereby increasing the slice size by 19 instructions.
2Based on a population size of 380364, with a confidence level of 95% and a margin of
error of 5%.Three instructions remove two or more values from the stack in
WebAssembly: select,whichpopsthreevaluesandpushesone,
store, which pops two values, and call, which pops as many
values as there are arguments to the function call. In the worst
case, a function had 32 callinstructions to a 12-argument func-
tion,resultingin352 dropinstructionsbeingadded.Inourmanual
investigation, we encountered 1881 instances of this pattern due
tocallorcall_indirect instructions, 20 due to storeinstruc-
tions,and9dueto selectinstructions.Theonlyothercausewe
encountered for an increase in the size of the executable slice is
duetotypeconversions:forexample,the i32.wrap_i64 instruc-
tion converts an i64into ani32in a single instruction, while our
slicer replaces it by two instructions: drop; i32.const 0 .W e
encountered this pattern only six times.
RQ3:Algorithm2,reconstruction,hasasmallimpact onslice
size, which goes from an average of 52% to 53%.
4.5 RQ4: Time to Produce Executable Slices
We measured the time it takes for each phase in order to compute
each slice and summarize the results in Figure 3.
Figure 3: Slicing time.
The mean time for the entire slicing process (the data-gathering
phase followed by Algorithms 1 and 2) is ùúá=4094ms. Only 14%
oftheslicestakemorethanasecondtocompute.Lookingatthe
breakdown between the different phases, we observe that the time
toproduceasliceisdominatedbythedata-gatheringphase,taking
3964ms on average and at most 3 hours and 42 minutes, while
Algorithm1takes104msonaverage,andatmost44minutesand
14 seconds, and Algorithm 2 takes 25 ms on average, and at most 3
hours and 22 minutes.
Investigating the data-gathering phase in more detail, we ob-
serve that the time is dominated by the computation of the data
dependences ( ùúá=1672ms), the memory dependences ( ùúá=360ms)
andthestackspecificationanalysis( ùúá=1811ms),whilethetime
required for the CFG construction ( ùúá=107ms), the computation
of the control dependences ( ùúá=13ms), and listing the globals ( ùúá=
247 ¬µs) remains small.
2038
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Stack-Preserving Intra-Procedural Slicing of WebAssembly Binaries ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Regarding the outliers, we observe that they concern slices of
functionsofthousandsofinstructions.Insomecases,thecompu-
tationofthedatadependenciestakesmostofthetime.However,
whenmanyinstructionsareremoved,thereconstructionalgorithm
may take the majority of the time. For example, the longest run-
ning time for the reconstruction algorithm is on a function that is
reduced from 11k instructions to only 8.
RQ4:It takes on average 4094ms to compute an executable
slice.Thistimeisdominatedbythedata-gatheringphaseanditscomputationofthedataandmemorydependencesinparticular.
The time required to reconstruct an executable slice (25 ms on
average) is only a fraction of the time required to construct the
closure slice (104ms on average).
4.6 RQ5: Comparison to Slicing C Programs
Whenavailable,itcanbebeneficialtoslicethesourcecodedirectly
rather than its WebAssembly counterpart. Furthermore, manualcomparison of source slices compiled to WebAssembly with our
WebAssembly slices enables characterizing the impact of the over-
approximations used by our slicer. To investigate, we selected a set
of 49 C programs originating from multiple sources. These include
programs from the slicing literature, programs used to compare
andevaluate WCETanalysis tools[ 40],and programsdesigned to
benchmark language implementations [22].
Eachprogramwasfirstnormalizedbyprettyprintingitusing
thepycparser Pythonlibrary.Afternormalizationtheseprograms
rangefrom16to2988sourcelinesofcode(SLOC),withanaverage
of 207 SLOC, according to the tool sloccount. For each statement
in these programs that modifies a scalar variable, we produced a
variantoftheprogramthatincludesa printfstatementthatprints
the value of the variable, which is used as the slicing criterion.
We sliced each variant with CodeSurfer [ 58] and with our ap-
proach, as follows:
‚Ä¢We used CodeSurfer to produce a static closure slice of each
Cprogram.BecauseCodeSurferdoesnotproduceexecutable
slices,weapplyquasi-staticexecutableslicing(QSES)[ 53],
which uses observation-based slicing (ORBS) to augment
a CodeSurfer slice with the statements needed to make itexecutable[
5].Thisresultsincompilableslices.Eachslice
was then compiled to WebAssembly.
‚Ä¢WealsocompiledeachvariantdirectlytoWebAssembly,and
applied our approach using the instruction corresponding
to the added printfstatement as the slicing criterion.
In both cases, the C programs were compiled to WebAssemblyusing Clang 12.0.1 with the
-O2 -fno-inline-functions -lm
-Wl,‚Äìdemangle -Wl,‚Äìexport-all flags. We remove slices that
encountered one of the limitations described in Section 4.1, as
well as those whose CodeSurfer slices produce WebAssembly that
cannot be loaded by our implementation. In the end, we obtain
1956 pairs of slices to compare.
We manually investigated a statistically relevant sample of 95
slices3thatincludedtwoslicesfromeachprogram(exceptforthree
3Basedonapopulationsizeof1956,withaconfidencelevelof95%andamarginof
error of 10%.programsthatonlyhadoneslice)inordertounderstandanydif-
ferences. As described below, we identified three main root causes
forthedifferencesininstructionsbetweeneachpairofslices.All
oftheslicesaswellasthedetailsofourmanualinvestigationare
included in our evaluation package.
Memory Over-Approximation. The majority of the differences
are due to our over-approximation of the memory dependences.
As soon as the slice includes a callor a loadinstruction, our
approach will include in the slice all storeand callinstructions
that may be previously executed according to the CFG. In orderto encode the slicing criterion for CodeSurfer, a call to the
printf
function is added to the code. This means that all slices for thisRQ include a function call, and as a result our approach always
includesmemorydependenciesintheslice.Weencounteredthis
pattern in 52% of the investigated slices.
CompilerOptimizations. TheslicesproducedbyCodeSurfersome-
timesbenefitfromadditionalcompileroptimization.Weencoun-
tered various patterns related to this root cause. These differences
canrendertheCodeSurferslicesquitedifferent,andreconstructing
thecorrespondencewiththeoriginalprogramcanrequiresignifi-
cantmentaleffort.Inthesecases,preservingthecorrespondence
between its slices and the input program is a desirable property of
our approach.
The CodeSurfer slice sometimes produces fewer instructions to
manipulate memory. For example, the following code shows the
slice produced by our approach on the left, and the slice produced
byCodeSurferontheright.The offsetoptionofa storeinstruction
enables writing at a specific offset from the target address of the
storeoperation.Ourapproachpreservestheoffsetofthe storein-
struction from the original program, while CodeSurfer can remove
it.Thisresultsin2superfluousinstructionsinourslice,forpassingthewrittenaddressasargumenttothefunctioncallonthelastline.
1local.get 0 local.get 0
2i32.const 2000 i32.const 2000
3i32.store offset=16 i32.store
4... ...
5local.get 0 local.get 0
6i32.const 16
7i32.add
8call 1 call 1
Anotherinstanceofthispatternisthatthecontrol-flowstruc-
ture of the program may be simplified, but our approach does not
applysuchrewritings.Hereisanexcerptofadifferencebetween
a slice produced by our slicer (left), which preservers the origi-
nal control-flow structure, and the corresponding CodeSurfer slice
(right), which has two fewer instructions ( blockand br1).
1block
2 local.get 0 local.get 0
3 i32.const 1 i32.const 1
4 i32.lt_s i32.ge_s
5 if if
6 br1
7 end
8 loop loop
9 ... ...
10 end end
11 end ;; block end ;; if
2039
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Quentin Sti√©venart, David W. Binkley, and Coen De Roover
In some cases, Clang inlines loops in the WebAssembly code,
resultinginanincreaseinsizefortheCodeSurferslices.Othercases
fallingunderthisrootcauseincludetheuseoffewerlocalvariables
by CodeSurfer when, for example, multiple local variables always
havethesamevalueintheslice,thereversingofaloopiterationorder when it is beneficial for code size, or changing the type ofa function when its return value is not needed, thereby avoidingextra instructions to return a value. We have observed this root
cause in 54% of the manually investigated slices.
Inter-procedural vs. intra-procedural. CodeSurfer‚Äôs computation
of inter-procedural slices has the impact that, when ùëìis recursive
CodeSurfer includes code reached both directly (in the ‚Äúcurrent‚Äù
invocationof ùëì)andindirectlyviarecursivecallsto ùëì.Forexample,
ifùëì‚Äôs return value is used in a control-flow decision upon which
the slicing criteria is itself dependent, CodeSurfer will preservethe computation of
ùëì‚Äôs return value. In contrast, our approach
never includes instructions required solely to support recursive
calls.Thisisarootcausethatweencounteredin20%ofthemanually
investigated slices.
RQ5: When the C source code of an application is available,
compilingaCslicetoWebAssemblymayproducesmallerslices.
Themaincausesofthisarethememoryover-approximations
madebyourslicerandtheextraoptimizationsenabledwhen
compiling the simpler code of the slice. On the other hand, due
tocompileroptimizations,CslicescompiledtoWebAssembly
may differ significantly from the corresponding portions of the
directlyslicedWebAssemblycode.Thiscanhamperprogram
comprehension of the resulting slices.
4.7 Discussion
The results of our investigation indicate that slicing WebAssembly
programsdirectlycangreatlyreducetheirsize,facilitatingappli-
cationssuchasreverseengineeringandprogramcomprehension.
Moreover, obtaining an executable slice only requires a small in-
crease in slice size, and can be done quite quickly.
Weidentifytwomainpossibleimprovements.First,regarding
slice size, having alias information would eliminate superfluous
instructionsthatarecurrentlyincludedduetoourmemoryover-
approximation. Second, regarding slice time, effort should be spent
on optimizing the data-gathering phase, in particular the computa-
tion of the data dependences.
Finally,weobservethatwhentheCsourcecodeofanapplica-
tion is available, even though the slice sizes may increase, it canbe beneficial in terms of program comprehension to slice at the
WebAssembly level directly.
4.8 Threats to Validity
Toconcludeourevaluation,weidentifythreatstovalidityaccording
totheclassificationofWohlinetal.[ 68].Athreattointernalvalidity
comesfromourevaluationsetuponthereal-worlddataset.Forsome
of the 8386 programs it is infeasible to compute all of the slices;
thus,werelyonatimeoutof4hoursperprogramandlettheslicer
computeasmanyslicesaspossibleinthattime.Wewereableto
compute 495204868 in total, and the evaluation ran to completion
without timeout on 83% of the programs.Our implementation has limitations that we described in Sec-
tion 4.1, which form a threat to construct validity. However, we do
not expect to observe a different outcome in our results if these
limitations are lifted, as we do not expect instructions within these
disconnected sections or accessible from a br_table instruction to
be too different from other instructions in the code.
A threat to external validity is that among the 8386 programs
usedinourevaluationofRQ2andRQ3,therecanbeduplicatefunc-
tions across different binaries, which we have not filtered out and
couldthereforehavebeenslicedmultipletimes.Thisismitigated
by the high number of functions sliced in total, which limits the
potential impact of this threat on the results.
Our dataset for RQ5 is composed of 49 C programs that we
manually gathered. Being less varied than the first dataset of 8,386
programs,itformsathreattotheexternalvalidityforRQ5.However,
weensured thediversity ofthis datasetby gatheringit from three
different sources.
5 RELATED WORK
WebAssembly. Therehasbeeninterestfromtheresearchcommu-
nityinWebAssemblyonaspectssuchassecurity[ 24,38,42,56,57],
extensions to the language [ 17,47], tooling [ 48], and optimiza-
tions [13]. In terms of program analysis, Lehmann and Pradel in-
troduced a framework for dynamic analysis of WebAssembly [ 39],
Wattetal.afirst-orderprogramlogictoverifyWebAssemblypro-
grams [64], and Sti√©venart and De Roover a static information
flow analysis [ 54] based upon a static analysis framework for Web-
Assembly [ 55]. Our approach is entirely static and is based on that
same framework.
Per√©nyiandMidtgaardperformedproperty-basedtestingofWeb-
Assembly runtimes [ 44]. The shrinking phase of their approach
also faces the problem that the generated program needs to passthe validation requirement, which is solved through a different
rewriting phase.
Binary Slicing. Static slicing has been applied to binary executa-
bles with a focus on register-based assembly languages whereas
WebAssembly itself is stack based. Cifuentes and Fraboulet [ 14]
perform intra-procedural static slicing on an assembly language
close to x86. They argue that using basic blocks as the node granu-
larity is more appropriate for binary executables, as the number of
instructions can be large. Unfortunately, this approach is evaluated
on a single example. Our approach in contrast operates on individ-
ualinstructions,anditsevaluationonreal-worlddatademonstratesthe feasibility of slicing at this level. Like ours, their approach does
not include any alias analysis.
Inter-procedural static slicing for binaries has been achieved by
Kiss et al. [ 35] and was later extended to include dynamic informa-
tion during slicing [ 34]. Special care is needed to handle indirect
functioncalls,whichisnotnecessaryforanintra-proceduralap-proach. Similarly, the tool presented by Mangean et al. performs
inter-procedural static slicing [ 41]. Ward et al. combined dynamic
andstaticslicingforanalyzingbinaries,throughconditionedslic-
ing[62],withthegoalofanalyzingandmigratingassemblersys-
tems.Adynamicsliceisfirstcomputed,beforebeingaugmented
with information from a transformation-based static slice.
2040
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. Static Stack-Preserving Intra-Procedural Slicing of WebAssembly Binaries ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
In terms of slicing stack-based assembly languages, there has
beenrelated workon slicingJVMbytecode.Umemorietal.present
a static approach which requires the presence of the Java source
codealongsidetheJVMbytecode[ 60],whileourapproachdoesnot
rely on the presence of the source code. Castaldo D‚ÄôUrsi et al. slice
JVM bytecode after converting it to Jimple code, which eliminates
theneedtodealwithstack-basedbytecode[ 18].Currently,there
exists no equivalent to Jimple for WebAssembly, and our approach
therefore directly handles the stack-based nature of WebAssembly.
ZhaopresentsadependenceanalysisforJavabytecode,withslicing
asoneofitsapplication[ 69].However,thehandlingofinstructions
that manipulate the value stack is omitted from their description.
Language-Independent Slicing. Binkley et al. present ORBS, a
language-independent slicing approach that observes the program
output in order to build an executable slice [ 5], which works at the
line level [ 6,7]. We rely on the QSES extension of ORBS [ 53]t or e -
constructexecutableCslicesfromCodeSurferforourfifthresearch
question. ORBS could in theory be applied to WebAssembly pro-
grams directly, on the condition that the program is instrumented
to capture the slicing criterion as part of the program‚Äôs output. We
leave a comparison with the resulting dynamic slices for future
work.
6 CONCLUSION
We introduced the first static intra-procedural backward slicing
approachforWebAssemblybinaries.Thisthree-phasedapproach
consists of a data-gathering phase, which computes all the nec-essary information for slicing, a slicing phase, which constructsa closure slice that contains all instructions needed to preservethe behavior of the slicing criterion, and a reconstruction phase,
which produces an executable slice from the closure slice. This last
phaseisneededbecauseWebAssemblyprogramshavetoadhereto
a validity requirement to be executable.
We evaluated our approach on a real-world dataset of 8386
programs. We observed that our approach results in executableslices that are on average of 53% of the original function. The
time needed to compute these slices averages 4094ms where most
of that time is spent on the data-gathering phase, in particularin the computation of data dependences. Through a qualitative
comparisonoftheslicesproducedbyourapproachwithexecutableCslicescompiledtoWebAssembly,wefindthatincorporatingsome
form ofalias analysis inthe slicingprocess should notablyreducethe average slice size.
This work forms an important stepping stone towards binary
analysis applications such as reverse engineering and program
comprehension.
REFERENCES
[1]Agrawal, H.: On slicing programs with jump statements. In: Sarkar, V., Ryder,
B.G., Soffa, M.L. (eds.) Proceedings of the ACM SIGPLAN‚Äô94 Conference on
Programming Language Design and Implementation (PLDI). pp. 302‚Äì312. ACM
(1994), https://doi.org/10.1145/178243.178456
[2]Akgul,T.,III,V.J.M.,Pande,S.:Afastassemblylevelreverseexecutionmethod
via dynamic slicing. In: 26th International Conference on Software Engineering
(ICSE 2004). pp. 522‚Äì531 (2004)
[3]Beck, J., Eichmann, D.: Program and interface slicing for reverse engine ering. In:
15th International Conference on Software Engineering. pp. 509‚Äì518 (1993)
[4]Binkley,D.W.:Theapplicationofprogramslicingtoregressiontesting.Inf.Softw.
Technol. 40(11-12), 583‚Äì594 (1998)[5]Binkley, D.W., Gold, N., Harman, M., Islam, S.S., Krinke, J., Yoo, S.: ORBS:language-independent program slicing. In: Cheung, S., Orso, A., Storey, M.D.
(eds.) Proceedings of the 22nd ACM SIGSOFT International Symposium on
Foundations of Software Engineering, (FSE-22). pp. 109‚Äì120. ACM (2014), https:
//doi.org/10.1145/2635868.2635893
[6]Binkley, D.W., Gold, N., Islam, S.S., Krinke, J., Yoo, S.: Tree-oriented vs. line-
oriented observation-based slicing. In: 17th IEEE International Working Confer-
enceonSourceCodeAnalysisandManipulation,SCAM2017.pp.21‚Äì30.IEEE
Computer Society (2017), https://doi.org/10.1109/SCAM.2017.11
[7]Binkley, D.W., Gold, N., Islam, S.S., Krinke, J., Yoo, S.: A comparison of tree- and
line-orientedobservationalslicing.Empir.Softw.Eng. 24(5),3077‚Äì3113(2019),
https://doi.org/10.1007/s10664-018-9675-9
[8]Binkley,D.W.,Gold,N.E.,Harman,M.,Islam,S.S.,Krinke,J.,Yoo,S.:ORBSand
thelimitsofstaticslicing.In:Godfrey,M.W.,Lo,D.,Khomh,F.(eds.)15thIEEE
International WorkingConference on SourceCode Analysisand Manipulation,
SCAM 2015. pp. 1‚Äì10. IEEE Computer Society (2015), https://doi.org/10.1109/
SCAM.2015.7335396
[9]Binkley,D.W.,Harman,M.:Alarge-scaleempiricalstudyofforwardandbackward
static slice size and context sensitivity. In: 19th International Conference onSoftwareMaintenance(ICSM2003).pp.44‚Äì53.IEEEComputerSociety(2003),
https://doi.org/10.1109/ICSM.2003.1235405
[10]Binkley,D.W.,Harman,M.:Asurveyofempiricalresultsonprogramslicing.Adv.
Comput. 62, 105‚Äì178 (2004), https://doi.org/10.1016/S0065-2458(03)62003-6
[11]Binkley, D.W., Raszewski, L.R., Smith, C., Harman, M.: An empirical study of
amorphousslicingasaprogramcomprehensionsupporttool.In:8thInternational
Workshop on Program Comprehension (IWPC 2000). pp. 161‚Äì170 (2000)
[12]Binkley, D.W., Harman, M.: A survey of empirical results on program slicing.
Advances in Computers 62, 105‚Äì178 (2004)
[13]Cabrera-Arteaga,J.,Donde,S.,Gu,J.,Floros,O.,Satabin,L.,Baudry,B.,Monperrus,
M.: Superoptimization of WebAssembly bytecode. In: Aguiar, A., Chiba, S., Boix,
E.G. (eds.) Programming‚Äô20: 4th International Conference on the Art, Science,and Engineering of Programming. pp. 36‚Äì40. ACM (2020), https://doi.org/10.
1145/3397537.3397567
[14]Cifuentes, C., Fraboulet, A.: Intraprocedural static slicing of binary executables.
In:1997InternationalConferenceonSoftwareMaintenance(ICSM‚Äô97).p.188.
IEEE Computer Society (1997), https://doi.org/10.1109/ICSM.1997.624245
[15]Danicic,S.,Howroyd,J.:Montr√©alboatexample.In:SourceCodeAnalysisand
Manipulation (SCAM 2002) conference resources website (2002)
[16]De Lucia, A., Fasolino, A.R., Munro, M.: Understanding function behaviours
through program slicing. In: 4ùë°‚ÑéIntl. Workshop on Program Comprehension
(1996)
[17]Disselkoen, C., Renner, J., Watt, C., Garfinkel, T., Levy, A., Stefan, D.: Position
paper: Progressive memorysafety for WebAssembly. In:Proceedings of the 8th
International Workshop on Hardware and Architectural Support for Security
and Privacy, HASP@ISCA 2019. pp. 4:1‚Äì4:8 (2019)
[18] D‚ÄôUrsi, A.C.,Cavallaro, L.,Monga,M.: Onbytecode slicingandaspectj interfer-
ences.In:Harrison,W.(ed.)Proceedingsofthe6thWorkshoponFoundations
of Aspect-Oriented Languages, FOAL 2007. ACM International Conference Pro-
ceeding Series, vol. 268, pp. 35‚Äì43. ACM (2007), https://doi.org/10.1145/1233833.
1233839
[19]Ellul, J., Pace, G.J.: Alkylvm: A virtual machine for smart contract blockchain
connected internet of things. In: 2018 9th IFIP International Conference on New
Technologies, Mobility and Security (NTMS). pp. 1‚Äì4. IEEE (2018)
[20]Ettinger, R., Verbaere, M.: Untangling: a slice extractionrefactoring. In: Proc. of
the 3rd Intl. Conf. on Aspect-Oriented Software Development (AOSD) (2004)
[21]Ferrante,J.,Ottenstein,K.J.,Warren,J.D.:Theprogramdependencegraphand
itsuseinoptimization.ACMTrans.Program.Lang.Syst. 9(3),319‚Äì349(1987),
https://doi.org/10.1145/24039.24041
[22]Fulgham, B., Gouy, I.: The computer language benchmarks game. https://
benchmarksgame-team.pages.debian.net/benchmarksgame/
[23]Gallagher, K.B., Lyle, J.R.: Using program slicing in software maintenance. IEEE
Trans. Software Eng. 17(8), 751‚Äì761 (1991), https://doi.org/10.1109/32.83912
[24]Goltzsche, D., Nieke, M., Knauth, T., Kapitza, R.: AccTEE: A WebAssembly-based
two-waysandboxfortrustedresourceaccounting.In:Proceedingsofthe20th
International Middleware Conference, Middleware 2019. pp. 123‚Äì135 (2019)
[25]Haas,A.,Rossberg,A.,Schuff,D.L.,Titzer,B.L.,Holman,M.,Gohman,D.,Wagner,
L., Zakai, A.,Bastien, J.F.: Bringing the webuptospeedwith WebAssembly. In:
Proceedings of the 38th ACM SIGPLAN Conference on Programming Language
Design and Implementation, PLDI 2017. pp. 185‚Äì200 (2017)
[26]Hajnal, √Å., Forg√°cs, I.: A demand-driven approach to slicing legacy COBOL
systems. Journal of Software: Evolution and Process 24(1) (2011)
[27]Hall,A., Ramachandran,U.: Anexecution modelfor serverlessfunctions atthe
edge. In: Proceedings of the International Conference on Internet of Things
Design and Implementation, IoTDI 2019. pp. 225‚Äì236 (2019)
[28]Harman,M.,Danicic,S.:Usingprogramslicingtosimplifytesting.Softw.Test.
Verification Reliab. 5(3), 143‚Äì162 (1995)
2041
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Quentin Sti√©venart, David W. Binkley, and Coen De Roover
[29]Hierons, R.M., Harman, M., Fox, C., Ouarbya, L., Daoudi, M.: Conditioned slicing
supportspartitiontesting.SoftwareTesting,VerificationandReliability 12(2002)
[30]Hilbig, A., Lehmann, D., Pradel, M.: An empirical study of real-world Web-
Assembly binaries: Security, languages, use cases. In: Leskovec, J., Grobelnik,
M.,Najork,M., Tang,J.,Zia,L.(eds.)WWW‚Äô21: TheWebConference2021. pp.
2696‚Äì2708. ACM / IW3C2 (2021), https://doi.org/10.1145/3442381.3450138
[31]Hosnieh, E., Haga, H.: A novel approach to program comprehension process
using slicing techniques. J. Comput. 11(5), 353‚Äì364 (2016)
[32]Kamkar, M., Shahmehri, N., Fritzson, P.: Bug localization by algorithmic de-bugging and program slicing. In: 2nd International Workshop Programming
LanguageImplementationandLogicProgramming,PLILP‚Äô90.vol.456,pp.60‚Äì74
(1990)
[33]Kennedy,K.:Use-definitionchainswithapplications.Comput.Lang. 3(3),163‚Äì179
(1978), https://doi.org/10.1016/0096-0551(78)90009-7
[34]Kiss, √Å., J√°sz, J., Gyim√≥thy, T.: Using dynamic information in the interprocedural
staticslicingofbinaryexecutables.Softw.Qual.J. 13(3),227‚Äì245(2005),https:
//doi.org/10.1007/s11219-005-1751-x
[35]Kiss,√Å.,J√°sz,J.,Lehotai,G.,Gyim√≥thy,T.:Interproceduralstaticslicingofbinary
executables. In: 3rd IEEE International Workshop on Source Code Analysis and
Manipulation (SCAM 2003). p. 118. IEEE Computer Society (2003), https://doi.
org/10.1109/SCAM.2003.1238038
[36]Korel, B., Rilling, J.: Dynamic program slicing in understanding of program
execution.In:Proc.ofthe 5ùë°‚ÑéIntl.WorkshoponProgramComprehension(IWPC)
(1997)
[37]Kusumoto,S.,Nishimatsu,A.,Nishie,K.,Inoue,K.:Experimentalevaluationof
program slicing for fault localization. Empirical Software Engineering 7(2002)
[38]Lehmann, D., Kinder, J., Pradel, M.: Everything old is new again: Binary security
ofWebAssembly.In:29thUSENIXSecuritySymposium,USENIXSecurity2020
(2020)
[39]Lehmann, D., Pradel, M.: Wasabi: A framework for dynamically analyzing Web-
Assembly. In: Proceedings of the Twenty-Fourth International Conference on
Architectural Supportfor ProgrammingLanguages andOperating Systems,ASP-
LOS 2019. pp. 1045‚Äì1058 (2019)
[40]M√§lardalenWCETresearchgroup:M√§lardalenWCETresearchgroup‚Äôsbench-
marks. https://www.mrtc.mdh.se/projects/wcet/benchmarks.html
[41]Mangean, A., B√©chennec, J., Briday, M., Faucou, S.: BEST: a binary executable
slicingtool.In:Schoeberl,M.(ed.)16thInternationalWorkshoponWorst-Case
Execution Time Analysis, WCET 2016. OASICS, vol. 55, pp. 7:1‚Äì7:10. Schloss
Dagstuhl-Leibniz-Zentrumf√ºrInformatik(2016),https://doi.org/10.4230/OASIcs.
WCET.2016.7
[42]M√©n√©trey, J., Pasin, M., Felber, P., Schiavoni, V.: Twine: An embedded trusted
runtime for WebAssembly. In: 37th IEEE International Conference on Data Engi-
neering,ICDE2021.pp.205‚Äì216.IEEE(2021),https://doi.org/10.1109/ICDE51399.
2021.00025
[43]Ottenstein, K.J., Ottenstein, L.M.: The program dependence graph in a software
developmentenvironment.In:ACMSIGSOFT/SIGPLANSoftwareEngineering
SymposiumonPracticalSoftwareDevelopmentEnvironments.pp.177‚Äì184(1984)
[44]Per√©nyi, √Å., Midtgaard, J.: Stack-driven program generation of WebAssembly.
In:d.S.Oliveira,B.C.(ed.)ProgrammingLanguagesandSystems-18thAsian
Symposium, APLAS 2020. Lecture Notes in Computer Science, vol. 12470, pp.
209‚Äì230. Springer (2020), https://doi.org/10.1007/978-3-030-64437-6_11
[45]Philips, L., De Koster, J., De Meuter, W., De Roover, C.: Search-based tier assign-
mentforoptimisingofflineavailabilityinmulti-tierwebapplications.TheArt,
Science, and Engineering of Programming 2(2) (2018)
[46]Philips,L.,DeRoover,C.,Van Cutsem,T.,DeMeuter,W.:Towardstierlessweb
developmentwithouttierlesslanguages.In:ACMInternationalSymposiumon
New Ideas, New Paradigms, and Reflections on Programming and Software
(SPLASH/OnWard!14) (2014)
[47]Pinckney, D., Guha, A., Brun, Y.: Wasm/k: delimited continuations for Web-
Assembly. In: Flat, M. (ed.) DLS 2020: Proceedings of the 16th ACM SIGPLAN
International Symposium on Dynamic Languages. pp. 16‚Äì28. ACM (2020),
https://doi.org/10.1145/3426422.3426978
[48]Romano,A.,Wang,W.:WasmView:visualtestingforWebAssemblyapplications.
In: Rothermel, G., Bae, D. (eds.) ICSE ‚Äô20: 42nd International Conference on
SoftwareEngineering,CompanionVolume.pp.13‚Äì16.ACM(2020),https://doi.
org/10.1145/3377812.3382155
[49]Rossberg, A.: WebAssembly Core Specification. Tech. rep., W3C (2019), https:
//www.w3.org/TR/wasm-core-1/
[50]Salimi,S.,Ebrahimzadeh,M.,Kharrazi,M.:Improvingreal-worldvulnerability
characterization with vulnerable slices. In: 16thACM International Conference
onPredictiveModelsandDataAnalyticsinSoftwareEngineering(PROMISE).
pp. 11‚Äì20 (2020)
[51]Silva, J.: A vocabulary of program slicing-based techniques. ACM Comput. Surv.
44(3) (Jun 2012)
[52]Singh, R.G., Scholliers, C.: WARDuino: a dynamic WebAssembly virtual machine
forprogrammingmicrocontrollers.In:Proceedingsofthe16thACMSIGPLANInternationalConferenceonManagedProgrammingLanguagesandRuntimes,MPLR 2019. pp. 27‚Äì36 (2019)
[53]Sti√©venart, Q., Binkley, D.W., De Roover, C.: QSES: quasi-static executable slices.
In:21stIEEEInternationalWorkingConferenceonSourceCodeAnalysisand
Manipulation, SCAM 2021. pp. 209‚Äì213. IEEE (2021), https://doi.org/10.1109/
SCAM52516.2021.00033
[54]Sti√©venart, Q., De Roover, C.: Compositional information flow analysis for
WebAssembly programs. In: 20th IEEE International Working Conference on
Source Code Analysis and Manipulation, SCAM 2020. pp. 13‚Äì24. IEEE (2020),
https://doi.org/10.1109/SCAM51674.2020.00007
[55]Sti√©venart, Q., De Roover, C.: Wassail: a WebAssembly static analysis library. In:
Fifth International Workshop on Programming Technology for the Future Web
(2021)
[56]Sti√©venart, Q., De Roover, C., Ghafari, M.: The securityrisk of lacking compiler
protection in WebAssembly. In: 21st IEEE International Conference on Software
Quality, Reliability, and Security. IEEE (2021)
[57]Sti√©venart,Q.,DeRoover,C.,Ghafari,M.:Securityrisksofportingcprogramsto
WebAssembly.In:The37th ACM/SIGAPPSymposiumOn AppliedComputing.
ACM (2022)
[58] Teitelbaum, T.: Codesurfer. ACM SIGSOFT Softw. Eng. Notes 25(1), 99 (2000)
[59]Tonella,P.:Usingaconceptlatticeofdecompositionslicesforprogramunder-
standing and impact analysis. IEEE Transactions on Software Engineering 29(6)
(2003)
[60]Umemori, F., Konda, K., Yokomori, R., Inoue, K.: Design and implementationof bytecode-based Java slicing system. In: 3rd IEEE International Workshopon Source Code Analysis and Manipulation (SCAM 2003). pp. 108‚Äì117. IEEE
Computer Society (2003), https://doi.org/10.1109/SCAM.2003.1238037
[61]Ward, M.P.: Slicing the SCAM mug: A case study in semantic slicing. In: 3rd
IEEEInternationalWorkshoponSourceCodeAnalysisandManipulation(SCAM
2003).pp.88‚Äì97.IEEEComputerSociety(2003),https://doi.org/10.1109/SCAM.
2003.1238035
[62]Ward, M.P., Zedan, H.: Combining dynamic and static slicing for analysing
assembler. Sci. Comput. Program. 75(3), 134‚Äì175 (2010)
[63]Wasmer:TheleadingWebAssemblyruntimesupportingwasiandemscripten.
https://github.com/wasmerio/wasmer
[64]Watt, C., Maksimovic, P., Krishnaswami, N.R., Gardner, P.: A program logicfor first-order encapsulated WebAssembly. In: 33rd European Conference on
Object-Oriented Programming, ECOOP 2019. pp. 9:1‚Äì9:30 (2019)
[65] WebAssembly. https://webassembly.org/[66]
Weiser, M.: Program slicing. In: 5th International Conference on Software Engi-
neering. pp. 439‚Äì449 (1981)
[67]Weiser,M.:Programslicing.In:Jeffrey,S.,Stucki,L.G.(eds.)Proceedingsofthe5th
International Conference on Software Engineering. pp. 439‚Äì449. IEEE Computer
Society (1981), http://dl.acm.org/citation.cfm?id=802557
[68]Wohlin, C., Runeson, P., H√∂st, M., Ohlsson, M.C., Regnell, B.: Experimentation in
Software Engineering. Springer (2012), https://doi.org/10.1007/978-3-642-29044-
2
[69]Zhao, J.: Dependence analysis of Java bytecode. In: 24th International Computer
Software and Applications Conference (COMPSAC 2000). pp. 486‚Äì491. IEEE
Computer Society (2000), https://doi.org/10.1109/CMPSAC.2000.884771
2042
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. 