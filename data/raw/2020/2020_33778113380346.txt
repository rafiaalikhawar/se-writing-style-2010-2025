Conquering the Extensional Scalability Problem for Value-Flow
Analysis Frameworks
Qingkai Shi
The Hong Kong University of Science and Technology
Hong Kong, China
qshiaa@cse.ust.hkRongxin Wu
XiamenUniversity
Xiamen,China
wurongxin@xmu.edu.cn
Gang Fan
The Hong Kong University of Science and Technology
Hong Kong, China
gfan@cse.ust.hkCharles Zhang
The HongKong University of Science and Technology
Hong Kong, China
charlesz@cse.ust.hk
ABSTRACT
Modern static analyzersoften need to simultaneouslycheck a few
dozenorevenhundredsofvalue-flowproperties,causingserious
scalabilityissueswhenhighprecisionisrequired.Amajorfactor
to this deficiency, as we observe, is that the core static analysis en-
gineisobliviousofthemutualsynergyamongthepropertiesbeing
checked,thusinevitablylosingmanyoptimizationopportunities.
Ourworkistoleveragetheinter-propertyawarenessandtocapture
redundanciesandinconsistencieswhenmanypropertiesareconsid-
eredatthesametime.Wehaveevaluatedourapproachbycheckingtwentyvalue-flowpropertiesinstandardbenchmarkprogramsand
ten real-world software systems. The results demonstrate that our
approachismorethan8 ×fasterthanexistingonesbutconsumes
only 1/7 of the memory. Such substantial improvement in analysis
efficiency is not achieved by sacrificing the effectiveness: at the
time of writing, thirty-nine bugs found by our approach have been
fixed by developers and four of them have been assigned CVE IDs
due to their security impact.
CCSCONCEPTS
•Software and its engineering →Software verification and
validation.
KEYWORDS
Staticbugfinding,demand-drivenanalysis,compositionalprogram
analysis,value-flow analysis.
ACM Reference Format:
Qingkai Shi, Rongxin Wu, Gang Fan, and Charles Zhang. 2020. Conquering
theExtensionalScalabilityProblemforValue-FlowAnalysisFrameworks.
In42nd International Conference on Software Engineering (ICSE ’20), May
23–29,2020,Seoul,RepublicofKorea. ACM,NewYork,NY,USA, 12pages.
https://doi.org/10.1145/3377811.3380346
Permissionto make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE’20,May23–29,2020,Seoul, Republic of Korea
© 2020Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.33803461 INTRODUCTION
Value-flow analysis [ 12,30,38,41], which tracks how values are
stored and loaded in a program, underpins the inspection of a
very broad category of software properties, such as memory safety
(e.g., null dereference, double free, etc.), resource usage (e.g., mem-
ory leak, file usage, etc.), and security properties (e.g., the use of
tainted data). In addition, there are a large and growing number
of domain-specific value-flow properties. For instance, mobile soft-
ware requires that the personal information cannot be passed to
an untrusted code [ 2], and, in web applications, tainted database
queries are not allowed to be executed [ 43].Fortify,1a commercial
staticcodeanalyzer,checksnearlytenthousandvalue-flowprop-
ertiesfromhundredsofuniquecategories.Value-flowproperties
exhibit a very high degree of versatility, which poses great chal-
lenges to the effectiveness of general-purpose program analyzers.
Facedwithsuchamassivenumberofpropertiesandtheneedof
extension,existingapproaches,suchas Fortify, CSA,2andInfer,3
provide a customizable framework together with a set of property
interfaces that enable the quick customization for new properties.
Forinstance, CSAusesasymbolic-executionenginesuchthat,at
every statement, it invokes the callback functions registered forthe properties. These callback functions are overwritten by the
property-checker writers to collect the symbolic-execution results,
suchas thesymbolic memoryand thepath conditions,so thatwe
canjudgethepresence ofany propertyviolationat thestatement.
Despite the existence of many CSA-like frameworks, when high
precision like path-sensitivity is required, existing static analyzers
still cannot scale well with respect to a large number of properties
to check, which we refer to as the extensional scalability issue . For
example,ourevaluationshowsthat CSAcannotpath-sensitively
check twenty properties for many programs in ten hours. Pin-
point[38],anotherrecentanalyzer,exhausted256GBofmemory
for onlyeightproperties.
We observe that a major factor for the extensional scalability
issue is that, in the conventional extension mechanisms, such asthat of CSA, the core static analysis engine is oblivious to the
properties being checked. Although the property obliviousness
givesthemaximumflexibilityandextensibilitytotheframework,
1FortifyStaticAnalyzer: https://microfocus.com/products/static-code-analysis-sast/.
2ClangStaticAnalyzer: https://clang-analyzer.llvm.org/ .
3InferStaticAnalyzer: http://fbinfer.com/.
*&&&"$.OE*OUFSOBUJPOBM$POGFSFODFPO4PGUXBSF&OHJOFFSJOH	*$4&
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea Qingkai Shi, Rongxin Wu, Gang Fan, and Charles Zhang
italsopreventsthecoreenginefromutilizingtheproperty-specific
analysis results for optimization. This scalability issue is slightly
alleviated by a class of approaches that are property-aware anddemand-driven[
5,25,28].Thesetechniquesarescalablewithre-
spect to a small number of properties because the core engine can
skipcertainprogramstatementsbyunderstandingwhatstatements
arerelevantorirrelevanttotheproperties.However,intheseap-
proaches,thesemanticsofpropertiesarealsoopaquetoeachother.
Asaresult,whenthenumberofpropertiesgrowsverylarge,the
performanceofthedemand-drivenapproacheswillquicklydete-
riorate because property-irrelevant program statements becomefewer and fewer, such as in the case of Pinpoint. To the best of
ourknowledge,thenumberofliteraturespecificallyaddressingthe
extensional scalability issue is very limited. Readers can refer to
Section7fora detailed discussion.
In this work, we advocate an inter-property-aware design to re-
laxtheproperty-propertyandtheproperty-engineopaquenessso
that the core static analysis engine can exploit the mutual synergy
among different properties for optimization. To check a value-flow
property,insteadofconformingtoconventionalcallbackinterfaces,
property-checkerwritersofourframeworkneedtoexplicitlyde-
clareasimplepropertyspecification,whichpicksoutsourceand
sink values, respectively, as well as the predicate over these values
forthesatisfactionoftheproperty.Forinstance,foranulldeference
property,our propertymodel onlyrequires thechecker writersto
indicate where a null pointer may be created and where the nulldereference may happen using pattern expressions, as well as a
simplepredicatethatconstrainsthepropagationofthenullpointer.
Surprisingly, given a set of properties specified in our property
model,ourstaticanalyzercanautomaticallyunderstandtheover-
laps and inconsistencies of the properties to check. Based on theunderstanding, before analyzing a program, we can make dedi-
cated analysis plans so that, at runtime, the analyzer can share the
analysis results on path-reachability and path-feasibility among
differentpropertiesforoptimization.Theoptimizationallowsusto
significantlyreduceredundantgraphtraversalsandunnecessary
invocationsoftheSMTsolver,twocriticalperformancebottlenecksofconventionalapproaches.WeprovidesomeexamplesinSection 2
to illustrate our approach.
We have implemented our approach, named Catapult, which
is a new demand-driven and compositional static analyzer with
theprecisionofpath-sensitivity.Likeaconventionalcompositional
analysis [ 45], our implementation allows us to concurrently ana-
lyzefunctionsthatdonothavecallingrelations.In Catapult,w e
have included all C/C++ value-flow properties that CSAchecks by
default. In the evaluation, we compared Catapult to three state-of-
the-artbug-findingtools, Pinpoint, CSA,and Infer,usingastandard
benchmark and ten popular industrial-sized software systems. The
experimental results demonstrate that Catapult is more than 8×
faster than Pinpoint but consumes only 1/7 of the memory. It is as
efficientas CSAandInferintermsofbothtimeandmemorycost
butismuchmoreprecise.Suchpromisingscalabilityof Catapult
isnotachievedbysacrificingthecapabilityofbugfinding.Inour
experiments, although the benchmark software systems have been
checkedbynumerousfreeandcommercialtools, Catapult isstill(a) path overlappingcheck for
free-global-pointer
bugscheck for
memory-leak
bugsa=malloc()
c=(a, b)
*c=1b
X// global pointer // heap pointer
(b) path contradictiona=malloc()
b=a
free(b) *b=1check for
memory-leak
bugscheck for
null-dereference
bugsX
a≠0 a=0// heap pointer or null
Figure 1: Path overlapping and contradiction among differ-entproperties. Each edge represents a value flow.
able to detect many previously-unknown bugs, in which thirty-
ninehavebeenfixedbythedevelopersandfourhavebeenassigned
CVEIDs. In summary, we make the following contributions:
•An inter-property-aware design for checking value-flow
properties, which mitigates the extensional scalability issue.
•A series of cross-property optimization rules that can be
made useof for general value-flow analysis frameworks.
•A detailed implementation and a systematic evaluation that
demonstratesourhighscalability, precision, and recall.
2 OVERVIEW
The key factor that allows us to conquer the extensional scalability
problem is the exploitation of the mutual synergy among different
properties. In this section, we first use two simple examples to
illustrate this mutual synergy and then provide a running example
used in the whole paper.
2.1 MutualSynergy
Weobservethatthemutualsynergyamongdifferentpropertiesare
primarily in the forms of path overlapping and path contradiction.
In Figure 1a, to check the memory-leak bug, we need to track
valueflows fromthenewly-created heappointer atocheck ifthe
pointer will be freed.4To check the free-global-pointer bug, we
track value flows from the global variable bto check if it will be
freed.5Asillustratedinthefigure,thevalue-flowpathstosearch
forthesetwobugsoverlapfromthevertex c=ϕ(a,b)tothevertex
*c=1.Beingawareoftheoverlap,whentraversingthegraphfrom
the vertex a=malloc() for the memory-leak bug, we record that the
vertexc=ϕ(a,b)cannot reach any “free” operation. Therefore, when
checking the free-global-pointer bug, we can use this recorded
informationto immediatelystopthegraph traversalatthe vertex
c=ϕ(a,b), thereby avoiding redundant graph traversals.
InFigure 1b,tocheckthememory-leakbug,wetrackvalueflows
from the newly-created pointer ato where it is freed. To check the
null-dereference bug, considering that the function mallocmay
returnanullpointerwhenthememoryallocationfails,wetrack
thevalueflowsfromthesamepointer atowhereitisdereferenced.
The two properties have an inconsistent constraint: the former
requiresa/nequal0foratobeavalidheappointerwhilethelatterrequires
4In the paper, we say a pointer pis “freed” if it is used in the function call free(p).W e
willdetailhow to use the value-flow information to check bugs later.
5Freeing a pointer pointing to non-heap memory (e.g., memory allocated by global
variables)is buggy. See details in https://cwe.mitre.org/data/definitions/590.html.
Conquering the Extensional Scalability Problem for Value-Flow Analysis Frameworks ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
property 
specificationsgraph traversal 
plan
optimization 
plan bug reports engine of graph 
traversalplan makercore engine
key novelty: a plan maker is inserted in a conventional design
Figure 2: The workflow of our approach.
1.char* g = "";
2.voidmain() {
3. char* a;
4. if(1) {
5. p = malloc(…); a = p; // heap pointer or null
6. } else {
7. a = g; // nonheappointer
8. }
9. if(2) { b = a; free(b); }
10.
11. if(3) { c = a; *c = 1; }
12.
13. if(4) { d = a; free(d); }
14. }dp
a
free(d)g// nonheap pointer // may be null
free(b)b
*c = 1c1
423 1
Figure 3: An example to illustrate our method.
a=0 forato be a null pointer. Being aware of this inconsistency,
whentraversingthegraphforcheckingthenull-dereferencebug,
we check and record if the path condition γof the path from the
vertexa=malloc() tothevertex b=aconflictswiththenullpointer
condition a=0. If the path condition γis satisfiable but conflicts
with the null pointer condition a=0, i.e., the conjunction γ∧a=0i s
unsatisfiable, we can conclude that the conjunction γ∧a/nequal0 must
besatisfiablewithoutanexpensiveconstraint-solvingprocedure
whencheckingthe memory-leakbug.
2.2 A Running Example
Figure3shows a running example using the value-flow graph
wherewecheckthenull-deferenceandthefree-global-pointerbugs
followingtheworkflowillustratedinFigure 2.Givenaprogram,we
firstfollowthe previous work[ 12,38,42] tobuild thevalue-flow
graph in order to check the two properties with the precision of
path-sensitivity. Here, path-sensitivity means that when searching
pathsonthevalue-flowgraph,weinvokeanSMTsolvertosolve
path conditions and other property-specific constraints to prune
infeasiblepaths.
The Property Specifications. The users of our framework
need to declaratively specify the value-flow properties, which con-
sists of the simple descriptions of the sources, the sinks, and the
predicates for triggering the bug. For instance, the specifications of
the aforementioned two properties are describedby the following
two quadruples, respectively:
propnull-deref := (v=malloc (_);_=∗v,∗v=_;v=0;never )
propfree-glob-ptr := (glob;free (v);true; never )
Separated by the semicolons, the first and second components
denote the descriptors of the source and the sink, respectively,
specified using pattern expressions to represent the values used ordefinedinsomeprogramstatements.The“don’t-care”valuesare
written as underscores. In the running example, the source values
of the properties null-deref andfree-glob-ptr are the return pointer
ofthefunction mallocandtheglobalpointer g,respectively.The
sink value of the property null-deref is the dereferenced value cat
the statement *c=1. The sink values of the property free-glob-ptr
are the freed values at the statements free(b)andfree(d).
The third component is a property-specific constraint, repre-
senting the triggering condition of the bug. In our example, theconstraint of the property null-deref is
v=0, meaning that the
value on a value-flow path should be a null pointer. The constraint
of the property free-glob-ptr istrue, meaning that the value on a
value-flow path is unconstrained.
Thebuilt-inpredicate“never”meansthatvalue-flowpathsbe-
tween the specified sources and sinks should never be feasible.
Otherwise, a bug exists.
The Core Static Analysis Engine. Given these declarative
specifications, our core engine automatically makes analysis plans
before the analysis begins, including both the graph traversal plan
and the optimization plan. In the example, we make the following
optimizationplans:(1)checkingtheproperty free-glob-ptr before
theproperty null-deref ;(2)whentraversingthegraphfortheprop-
ertyfree-glob-ptr,werecordtheverticesthatcannotreachanysink
vertex of the property null-deref. The graph traversal plan in the
exampleistrivial,whichistoperformadepth-firstsearchonthe
value-flow graph from every source vertex of the two properties.
InFigure 3,whentraversingthevalue-flowgraphfromtheglobal
pointergto check the property free-glob-ptr, the core engine visits
allverticesexceptthevertex ptolookfor“free”operations.Accord-
ing to the optimization plan, during the graph traversal, we record
that the vertices banddcannotreach any dereference operation.
To check the property null-deref, we traverse the value-flow
graphfromthevertex p.Whenvisitingthevertex bandthevertex d,
since the previously-recorded information tells us that they cannot
reachanysinkvertices,weprunethesubsequentpathsfromthe
two vertices.
It is noteworthy that if we check the property null-deref before
the property free-glob-ptr, we only can prune one path from the
vertexcfor the property free-glob-ptr based on the results of the
property null-deref (see Section 4.2.1). We will further explain the
rationaleof our analysis plans in the following sections.
3 VALUE-FLOW PROPERTIES
Thissectionprovidesaspecificationmodelforvalue-flowproperties
with the following two motivations. First, we observe that many
property-specific constraints play a significant role in performance
optimization. The specific constraints of one property can be used
tooptimizecheckingofnotjustthepropertyitself,butalsoofother
properties being checked together.
Second, despite many studies on value-flow analysis [ 12,30,38,
41,42], we still have a lack of general and extensible specification
models that can maximize the opportunities of sharing analysis
results across the processes of checking different properties. Some
oftheexistingstudiesonlyfocusoncheckingaspecificproperty
(e.g., memory leak [ 42]), while others adopt different specifications
to check the same value-flow property (e.g., double free [12, 38]).
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea Qingkai Shi, Rongxin Wu, Gang Fan, and Charles Zhang
Table 1: Pattern expressions used in the specification.
p::= ::patterns
|p1,p2,··· ::patternlist
|v0=sig (v1,v2,··· ) ::call
|v0=∗v1 ::load
|∗v0=v1 ::store
|v0=v1 ::assign
|glob ::globals
v::= ::symbol
|sig ::characterstring
|_ : :uninterested value
Examples:
v=malloc (_) ret values of any state-
mentcalling malloc;
_=send (_,v,_,_) the 2ndarg of any sta-
tementcalling send;
_=∗v dereferenced values at
every load statement;
Preliminaries. In a similar style to existing approaches [ 29,38,
42], we assume that the code of a program is in static single assign-
ment(SSA)form,whereeveryvariablehasonlyonedefinition[ 17].
Also,wesaythevalueofavariable aflowstoavariable b(orbis
data-dependent on a)i fais assigned to bdirectly (via assignments,
suchasb=a)orindirectly(viapointerdereferences,suchas *p=a;
q=p;b=*q ).Thus,avalue-flowgraphcanbedefinedasadirected
graphwherethe vertices are valuesin the program andthe edges
represent the value-flow relations. A path is called value-flow path
if it is a path on the value-flow graph.
Property Specification. As defined below, we model a value-
flow property as an aggregation of value-flow paths.
Definition 3.1 (Value-Flow Property). A value-flow property, x,i s
a quadruple: propx:= (src;sink; psc;agg ), where
•srcandsinkaretwopatternexpressions(Table 1)thatspecify
the sources and the sinks of the value-flow paths to track.
•pscis a first-order logic formula, representing the property-
specificconstraintthateveryvalueonthevalue-flowpath
needs to satisfy.
•agg∈{never,never-sim ,must,···}is an extensible predi-
catethatdetermineshowtoaggregatevalue-flowpathsto
check the specified property.
In practice, we can use the quadruple to specify a wide range of
value-flow properties. As discussed below, we put the properties
intothreecategories,whicharecheckedbyaggregatingasingle,
two, or more value-flow paths, respectively.
Single-PathProperties. We can check many program proper-
tiesusingasinglevalue-flowpath,suchastheproperties, null-deref
andfree-glob-ptr, defined in Section 2.2, as well as a broad range
oftaintissuesthatpropagateataintedobjecttoaprogrampoint
consumingtheobject [21].
Double-Path Properties. A wide range of bugs happen in a
programexecutionbecausetwoprogramstatements(e.g.,twostate-
ments calling the function free) consecutively operate on the same
value (e.g., a heap pointer). Typical examples include the use-after-
free bug, a general form of the double-free bug, as well as the onesthatoperate on expired resources such as a closed file descriptor
oraclosednetworksocket.Wecheckthemusingtwovalue-flow
paths from the same source value. As an example, the specification
for checking the double-free bugs can be specified as
propdouble-free := (v=malloc (_);free (v);v/nequal0;never-sim )
In the specification, the property-specific constraint v/nequal0r e -
quirestheinitialvalue(orequivalently,allvalues)onthevalue-flow
pathis a valid heap pointer. This is because v=0 means the func-
tionmallocfailstoallocatememoryandreturnsanullpointer.In
this case, the “free” operation is harmless. The aggregate predicate
“never-sim”meansthattwovalue-flowpathsfromthesamepointer
should never occur simultaneously. In other words, there is no
control-flow path that goes through two different “free” operations
on the same heap pointer. Otherwise, a double-free bug exists.
InFigure 3,forthetwovalue-flowpathsfromthevertex ptothe
two“free”operations,wecanchecktheconstraint (γ1∧γ2)∧(γ1∧
γ4)∧(p/nequal0)tofinddouble-freebugs.Here, (γ1∧γ2)and (γ1∧γ4)
are the path conditions of the two paths, respectively.
All-Path Properties. Many bugs happen because we do not
properlyhandleavalueinallprogrampaths.Forinstance,amemory-
leak bug happens if there exists a feasible program path where we
do not free a heap pointer. Other typical examples include many
types of resource leaks such as the file descriptor leak and the
socket leak. We check them by aggregating all value-flow paths
fromthesamesourcevalue.Asanexample,wewritethefollowing
specification for checking memory leaks:
propmem-leak := (v=malloc (_);free (v);v/nequal0;must )
Compared to the property double-free, the only difference in the
specification is the aggregate predicate. The aggregate predicate
“must”meansthatthevalue-flowpathfromaheappointermustbe
abletoreacha“free”operation.Otherwise,amemoryleakexists
in the program.
In Figure 3, for the value-flow paths from the vertex pto the
two“free”operations,wecancheckthedisjunctionoftheirpath
conditions, i.e.,¬((γ1∧γ2)∨(γ1∧γ4))∧γ1∧(p/nequal0),todetermine
ifamemoryleakexists.Here, (γ1∧γ2)and (γ1∧γ4)arethepath
conditions of these two paths, respectively. The additional γ1is the
conditionon which the heap pointer is created.
4 INTER-PROPERTY-AWARE ANALYSIS
Givenanumberofvalue-flowpropertiesspecifiedasthequadru-
ples (src;sink;psc;agg ),ourinter-property-awarestaticanalyzer
searchesthevalue-flowpathsandchecksbugsbasedonthepath
conditions,theproperty-specificconstraint psc,andthepredicate
agg.Inthispaper,weconcentrateonhowtoexploitthemutualsyn-
ergyarisingfromtheinteractionsofdifferentpropertiestoimprove
the searchingefficiencyof value-flow paths.
4.1 A Naïve Static Analyzer
Formultiplevalue-flowproperties,anaïvestaticanalyzerchecks
them independently in a demand-driven manner. As illustratedby Algorithm 1, for each value-flow property, the static analyzer
traverses the value-flow graph from each of the source vertices. At
eachstepof the graph traversal, we check if the property-specific
Conquering the Extensional Scalability Problem for Value-Flow Analysis Frameworks ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
Input: thevalue-flow graph of a progam to check
Input: a set of value-flow properties to checkOutput: pathsbetween sources and sinks for each propertyforeachproperty in the input property set do
foreachsourcevin its source set do
whilevisitv/primein the depth-first search from vdo
ifpsccannotbe satisfied then
stopthe search from v/prime;
end
end
end
end
Algorithm1: Thenaïve static analyzer.
constraint pscis satisfiable with respect to the current path condi-
tion. If it is not satisfiable, we can stop the graph traversal alongthe current path. This path-pruning process is illustrated in theshaded part of Algorithm 1, which is a critical factor to improve
the performance.
Thekey optimizationopportunitiescome fromtheobservation
thatthepropertiestocheckusuallyintroduceoverlapsandincon-
sistencies during the graph traversal, which cannot be exploited if
they are independently checked as in the naïve approach.
4.2 Optimized Intra-procedural Analysis
As summarized in Table 2, given the property specifications, our
inter-property-awarestaticanalysisenginecarriesouttwotypes
of optimizations when traversing the value-flow graph: the first
aiming at pruning paths and the second focusing on sharing paths
when multiple properties are being checked. Each row of the table
is a rule describing the specific precondition, the corresponding
optimization, as well as its benefit. For the clarity of the discussion,
weexplaintherulesinthecontextofprocessingasingle-procedure
program, followed by the discussion on the inter-procedural analy-
sis in the next subsection.
4.2.1 Optimization Plan. Given the property specifications, we
adoptRules1–4i nT able2to facilitate the path pruning.
Ordering the Properties (Rule 1). Given a set of properties
with different source values, we need to determine the order inwhich they are checked. While we leave the finding of the per-
fectorderthatguaranteestheoptimaloptimizationtoourfuture
work,weobservethatarandomordercansignificantlyaffectthe
effectiveness of the path pruning and must be circumvented.
Let us consider the example in Figure 3again. In Section 2.2,w e
have explained that if the property free-glob-ptr is checked before
theproperty null-deref,wecanprunethetwopathsfromthevertex
band the vertex dwhen checking the latter. However, if we flip
the checking order, only one path from the vertex ccan be pruned.
This is because, when checking the property null-deref, the core
enginerecordsthatthevertex ccannotreachanysinksspecified
by the property free-glob-ptr.
Intuitively,whatcausesthefluctuationinthenumberofprunable
pathsisthatthenumberofthe“free”operationsismorethanthe
dereferenceoperationsinthevalue-flowgraph.Thatis,themoresink vertices we have in the value-flowgraph, the fewer paths we
canprunefortheproperty.Inspiredbythisintuition,theorderof
checking the properties is arranged according to the number of
sinkvertices.Thatis,themoresinkverticesapropertyhasinthe
value-flow graph, the earlier we check this property.
Recording Sink-Reachability (Rule 2). Given a set of prop-
erties{prop1,prop2,···}, when checking the property propiby
traversing the value-flow graph, we record if each visited vertexmay reach a sink vertex of the property
propj(j/nequali). With the
recorded information, when checking the property propj(j/nequali)
andvisitingavertexthatcannotreachanyofitssinks,weprune
the pathsfrom the vertex. Section 2.2illustratesthemethod.
RecordingtheCheckingResultsofProperty-SpecificCon-
straints(Rules3&4). Givenasetofproperties {prop1,prop2,···},
when we check the property propiby traversing the value-flow
graph, we record the path segments, i.e., a set of edges, that con-
flict with the property-specific constraint pscjof the property
propj(j/nequali).Whencheckingtheproperty propj(j/nequali),weprune
the pathsthat includethe pathsegments.
Let us consider the running example in Figure 3again. When
traversingthegraphfromthevertex gtochecktheproperty free-
glob-ptr,thecoreenginerecordsthattheconditionoftheedgefrom
thevertex atothevertex c,i.e.,a/nequal0,conflictswiththeproperty-
specificconstraintoftheproperty null-deref, i.e.,a=0.Withthis
information, when checking the property null-deref, we can prune
the subsequentpath after the vertex c.
Thankstotheadvancesintheareaofclauselearning[ 6],weare
able to efficiently compute some reusable facts when using SMT
solvers to check path conditions and property-specific constraints.
Specifically,wecomputetworeusablefactswhenaproperty-specific
constraint psciconflictswith the current pathcondition pc.
When pc∧psciis unsatisfiable, we record the unsatisfiable
core[22],whichisasetofBooleanpredicatesinthepathcondition
pc,e.g.,{γ1,γ2,···}, such that γ1∧γ2∧···∧ psci=false. Since
the pathcondition pcis theconjunction of theedge constraint on
the value-flow path, each predicate γicorresponds to the condition
of an edge ϵion the value-flow graph. Thus, we can record an
edgesetE={ϵ1,ϵ2,···},whichconflictswiththeproperty-specific
constraint psci. Whenchecking theother propertywith the same
property-specific constraint, if a value-flow path contains these
recorded edges, we can prune the remaining paths.
In addition to the unsatisfiable cores, we also can record the
interpolation constraints [ 14], which are even reusable for prop-
erties with a different property-specific constraint. In the above
example, assume that the property-specific constraint psciisa=0
and the predicate set {γ1,γ2,···}is{a+b>3,b<0}. In the con-
straint solving phase, an SMT solver can refute the satisfiability of
(a+b>3)∧(b<0)∧(a=0)by finding an interpolant γ/primesuch
that (a+b>3)∧(b<0)⇒γ/primebutγ/prime⇒¬ (a=0).Intheexample,
theinterpolant γ/primeisa>3,whichprovidesadetailedexplanation
why theγset conflicts with the property-specific constraint a=0.
In addition, the interpolant also indicates that the γset conflicts
withmany otherconstraints suchas a<0anda<3.Thus, given
apropertywhosespecificconstraintconflictswiththeinterpola-
tion constraint, it is sufficient to conclude that any value-flow path
passingthrough the edge set Ecan be pruned.
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea Qingkai Shi, Rongxin Wu, Gang Fan, and Charles Zhang
Table 2: Rules of making analysis plans for a pair of properties.
OptimizationPlans
propx:= (src1;sink1;psc1;agg1)andpropy:= (src2;sink2;psc2;agg2),src1/nequalsrc2
IDRuleName Precondition Plan Benefit
1property ordering #sink1>#sink2 checkxbeforey more chances to prune paths
2
result recordingcheckxbeforey record vertices that cannot reach sink2prune pathsat a vertex
3 checkxbeforey,psc1=psc2record unsat cores that conflict with psc2prune pathsif going through
4 checkxbeforey,psc1/nequalpsc2record interpolants that conflict with psc2a set of edges
GraphTraversal Plans
propx:= (src1;sink1;psc1;agg1)andpropy:= (src2;sink2;psc2;agg2),src1=src2
IDRuleName Precondition Plan Benefit
5traversal merging - search from src1for both properties sharingpath conditions
6
psc-check orderingpsc1∧psc2=psc1 check psc1first if satisfiable, so is psc2
7 psc1∧psc2/nequalfalse check psc1∧psc2if satisfiable, both psc1and
psc2can be satisfied
8 psc1∧psc2=false check any, e.g.,psc1, firstif unsatisfiable, psc2can be
satisfied
dp
a
free(d)g// a heap pointer
// or a null pointer
free(b)b
print(*c)c{mem-leak, null-deref}
{mem-leak, null-deref}
{mem-leak, null-deref}
{mem-leak}psc: a≠0    psc: a=0
{mem-leak, null-deref}
{null-deref}
Figure 4: Merging the graph traversal.
4.2.2 Graph Traversal Plan. The graph traversal plan is to provide
strategiesof sharing paths among different properties.
MergingtheGraphTraversal(Rule5). Weobservethatmany
properties actually share the same or a part of source vertices and
eventhesamesinkvertices.Ifthecoreenginecheckseachproperty
one by one, it will repetitively traverse the graph from the same
sourcevertexfordifferentproperties.Therefore,ourgraphtraversal
plan mergesthe pathsearchingprocesses for different properties.
As an example, in Figure 3, since the vertex pmay represent
either a heap pointer or a null pointer, checking both the property
null-deref andtheproperty mem-leak needstotraverse thegraph
from the vertex p. Figure4illustrates how the merged traversal is
performed. That is, we maintain a property set during the graph
traversal to record what properties the current path contributes
to. Whenever visiting a vertex, we check if a property needs to be
removed from the property set. For instance, at the vertex d,w e
may remove the property null-deref from the property set if we
candeterminethevertex dcannotreachanyofitssinks.Whenthe
propertysetbecomesempty,thegraphtraversalstopsimmediately.Ordering the Checks of Property-Specific Constraints
(Rules 6 – 8). Sincethegraphtraversalsaremergedfordifferent
properties,atavertex, e.g.,ainFigure 4,wehavetocheckmultiple
property-specific constraints, e.g.,a/nequal0 for the property mem-leak
anda=0fortheproperty null-deref,withrespecttothepathcondi-
tion.Inausualmanner,wehavetoinvokeanexpensiveSMTsolver
tocheckeachproperty-specificconstraint,significantlyaffecting
theanalysisperformancewhentherearemanypropertiestocheck.
We mitigate this issue by utilizing various relations between the
property-specific constraints, so that we can reuse SMT-solving
results and reduce the invocations of the SMT solver.
Given two property-specific constraints, psc1andpsc2, we con-
sider all three possible relations between them: psc1∧psc2=psc1,
psc1∧psc2/nequalfalse, and psc1∧psc2=false. Since the property-
specific constraints are often simple, these relations are easy to
compute.Theserelationsmakeitpossibletocheckboth psc1and
psc2by invoking an SMT solver only once.
Thefirstrelation, psc1∧psc2=psc1,impliesthatanysolution
of the constraint psc1also satisfies the constraint psc2. In this case,
we first check if the constraint psc1conflicts with the current path
condition pcbysolvingtheconjunction, pc∧psc1.Ifitissatisfiable,
we can conclude that the conjunction, pc∧psc2, is also satisfiable.
Thesecondrelation, psc1∧psc2/nequalfalse,impliesthatthereexists
asolutionthatsatisfyingboththeconstraint psc1andtheconstraint
psc2. In this case, we first check the conjunction, pc∧psc1∧psc2.
Ifitissatisfiable,wecanconcludethatbothoftheconstraints, psc1
andpsc2, are satisfiable with respect to the path condition.
The third relation, psc1∧psc2=false, implies that there does
notexistanysolutionthatsatisfiesboththeconstraint psc1andthe
constraint psc2. In this case, we check any of the constraints, psc1
andpsc2, first. If the current path is feasible but the conjunction
pc∧psc1isnotsatisfiable,wecanconcludethattheconjunction
pc∧psc2can be satisfied without invoking SMT solvers.
Conquering the Extensional Scalability Problem for Value-Flow Analysis Frameworks ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
4.3 Modular Inter-procedural Analysis
Scalableprogram analyses need to exploit the modular structure
of a program. They build function summaries, which are reused at
differentcallingcontexts[ 16,45].In Catapult,wecanseamlessly
extendouroptimizedintra-proceduralanalysistomodularinter-
proceduralanalysisbyexploringthelocalvalue-flowgraphofeach
function and then stitching the local paths together to generate
complete value-flow paths. In what follows, we explain our design
of the function summaries.
In our analysis, for each function, we build three kinds of value-
flow paths as the function summaries. They are defined below and,
inalongerversionofthispaper[ 37],weformallyprovethesound-
ness of generating these function summaries. Intuitively, these
summariesdescribehow functionboundaries, i.e., formalparame-
ters and return values, partition a complete value-flow path. Using
the property double-free as an example, a complete value-flow path
fromthevertex ptothevertex free(b)inFigure 5ispartitionedtoa
sub-pathfromthevertex ptothevertex ret pbytheboundaryof
thefunction xmalloc.Thissub-pathisanoutputsummaryofthe
functionxmallocas defined below.
Definition 4.1 (Transfer Summary). A transfer summary of a
function fisavalue-flowpathfromoneofitsformalparameters
to one of its return values.
Definition4.2(InputSummary). Aninputsummaryofafunction
fisavalue-flowpathfromoneofitsformalparameterstoasink
value in the function for in the callees of the function f.
Definition 4.3 (Output Summary). An output summary of a func-
tionfis a value-flow path from a source value to a return value of
the function. The source value is in the function for in the callees
of the function f.
After generating the function summaries, to avoid separately
storing them for different properties, each function summary is
labeledwithabitvectortorecordwhatpropertiesitisbuiltfor.As-
sume that we need to check there properties, i.e.,null-deref, double-
free, andmem-leak, in Figure 5. We assign three bit vectors, 0 b001,
0b010, and 0 b100, to the three properties as their identities, respec-
tively.Asexplainedbefore,allthreepropertiesregardthevertex pas
thesource.Thesinkverticesforcheckingtheproperties double-free
andmem-leak are the vertices free(b)andfree(u). There are no sink
verticesfortheproperty null-deref.AccordingtoDefinitions 4.1–4.3,
we generate the following function summaries:
Function Summary Path Label Type
xmalloc ( p,ret p)0 b111 output
xfree(u,ret u)0 b111 transfer
(u,free(u)) 0 b110 input
The summary ( p,ret p) is labeled with 0 b111 because all three
properties regard pas the source. The summary ( u,ret u) is also
labeledwith0 b111becausethepathdoesnotcontainanyproperty-
specificverticesand,thus,maybeusedtocheckallthreeproperties.
The summary ( u,free(u)) is only labeled with 0 b110 because we do
not regard the vertex free(u) as a sink of the property null-deref.void* xmalloc() {
void* p = malloc(…);
return p;
}
void* xfree( void* u) {
free(u);
return u;
}
void main() {
void* a = xmalloc();
void* b = xfree(a);
if(…) free(b);
return ;
}p
ret p
ret ua
u
free(u)
b
free(b)xmalloc
xfree
Figure5:Anexampletoshowtheinter-proceduralanalysis.
When analyzing the main function, we concatenate its intra-
procedural paths with summaries from its callees to generate a
complete path. For example, a concatenation is illustrated below
anditsresultislabeledby0 b110,meaningthattheresultingpath
onlyworksfortheproperty double-free andtheproperty mem-leak.
(p,retp)0b111◦(a)◦(u,free (u))0b110
= (p,retp,a,u,free (u))0b111&0b110
= (p,retp,a,u,free (u))0b110
We observe that using value-flow paths as function summaries
has a significant advantage for checking multiple properties. That
is,sincevalueflowisacommonprogramrelations,itcanbereusedacrossdifferentproperties.Thisisdifferentfromexistingapproaches
thatutilizestatemachinetomodelpropertiesandgeneratestate-
specific function summaries [ 18,25]. Since different properties
usually have different states, compared to our value-flow-based
functionsummaries,suchstate-specificfunctionsummarieshave
fewer opportunities to be reused across properties.
5 IMPLEMENTATION
In this section, we present the implementation details as well as
the properties to check in our framework.
Path-sensitivity. We have implemented our approach as a pro-
totypetoolcalled Catapult ontopof Pinpoint[38].Giventhesource
code of a program, we first compile it to LLVM bitcode,6on which
ouranalysisisperformed.Toachievepath-sensitivity,webuilda
path-sensitivevalue-flowgraphandcomputepathconditionsfol-
lowingthemethodof Pinpoint.Thepathconditionsinouranalysis
are first-order logic formulae over bit vectors. A program variable
is modeled as a bit vector, of which the length is the bit width (e.g.,
32) of the variable’s type (e.g., int). The path conditions are solved
by Z3 [19], a state-of-the-art SMT solver, to determine the path
feasibility.
Propertiestocheck. Catapult currentlysupportstwentyC/C++
properties,brieflyintroducedinTable 3,definedby CSA.7These
6LLVM:https://llvm.org/.
7More details of the properties can be found on https://clang-analyzer.llvm.org/ .
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea Qingkai Shi, Rongxin Wu, Gang Fan, and Charles Zhang
Table 3: Properties to check in Catapult.
ID Property Name Brief Description
1 core.CallAndMessage Check for uninitialized arguments and null function pointers
2 core.DivideByZero Check for division by zero
3 core.NonNullParamChecker Check for null passed to function parameters marked with nonnull
4 core.NullDereference Check for null pointer dereference
5 core.StackAddressEscape Check that addresses of stack memory do not escape the function
6 core.UndefinedBinaryOperatorResult Check for the undefined results of binary operations
7 core.VLASize (Variable-Length Array) Check for declaration of VLA of undefined or zero size
8 core.uninitialized.ArraySubscript Check for uninitialized values used as array subscripts
9 core.uninitialized.Assign Check for assigning uninitialized values
10 core.uninitialized.Branch Check for uninitialized values used as branch conditions
11 core.uninitialized.CapturedBlockVariable Check for blocks that capture uninitialized values
12 core.uninitialized.UndefReturn Check for uninitialized values being returned to callers
13 cplusplus.NewDelete Check for C++ use-after-free
14 cplusplus.NewDeleteLeaks Check for C++ memory leaks
15 unix.Malloc Check for C memory leaks, double-free, and use-after-free
16 unix.MismatchedDeallocator Check for mismatched deallocators, e.g., new and free()
17 unix.cstring.NullArg Check for null pointers being passed to C string functions like strlen
18 alpha.core.CallAndMessageUnInitRefArg Check for uninitialized function arguments
19 alpha.unix.SimpleStream Check for misuses of C stream APIs, e.g., an opened file is not closed
20 alpha.unix.Stream Check stream handling functions, e.g., using a null file handle in fseek
propertiesincludeall CSA’sdefaultC/C++value-flowproperties.
All other default C/C++ properties in CSAbut not in Catapult are
simpleonesthatdonotrequireapath-sensitiveanalysis.Forexam-
ple, the property security.insecureAPI.bcopy requires CSAreport a
warning whenever a program statement calling the function bcopy
is found.
Parallelization. Ouranalysisisperformedinabottom-upman-
ner, in which a function is always analyzed before its callers. After
afunctionisanalyzed,itsfunctionbehaviorissummarizedasfunc-
tion summaries, which can be reused at different call sites. Thus,
itiseasytoruninparallelbyanalyzingfunctionswithoutcaller-
calleerelationsindependently[ 45].Ourspecialdesignforchecking
multiple properties together does not prevent the analysis from
this parallelizationstrategy.
Soundness. Weimplement Catapult inasoundymanner[ 31].
Thismeansthattheimplementationsoundlyhandlesmostlanguage
featuresand,meanwhile,includessomewell-knownunsoundde-
sign decisions as previous works [ 4,12,38,42,45]. For example,
in our implementation, virtual functions are resolved by classic
class hierarchy analysis [ 20]. However, we do not handle C style
functionpointers,inlineassembly,andlibraryfunctions.Wealso
followthecommonpracticetoassumedistinctfunctionparametersdonotaliaswitheachother[
30]andunrolleachcycletwiceonthe
callgraphandthecontrol flowgraph. Theseunsound choices sig-
nificantlyimprovethescalabilitybuthavelimitednegativeimpacts
on the bug-finding capability.
6 EVALUATION
Todemonstratethescalabilityofourapproach,wecomparedthe
time and the memory cost of Catapult to three existing industrial-
strength static analyzers. We also investigated the capability of
finding real bugs inorder to show that the increased scalabilityis
not at the cost of sacrificing the bug-finding capability.Table 4: Subjects for evaluation.
ID Program Size (KLoC) ID Program Size (KLoC)
1 mcf 2 13 shadowsocks 32
2 bzip2 3 14 webassembly 75
3 gzip 6 15 transmission 88
4 parser 8 16 redis 101
5 vpr 11 17 imagemagick 358
6 crafty 13 18 python 434
7 twolf 18 19 glusterfs 481
8 eon 22 20 icu 537
9 gap 36 21 openssl 791
10 vortex 49 22 mysql 2,030
11 perlbmk 73
12 gcc 135 Total 5,303
Baselineapproaches. We first compared Catapult toPinpoint,
amostrecentvalue-flowanalyzerwiththeprecisionofinter-proce-dural path-sensitivity [
38]. In addition, we also compared Catapult
totwowidely-usedopen-sourcebugfindingtools, CSAandInfer.
All these tools in our evaluation were configured to use fifteen
threadsto take advantage of parallelization.
We also tried to compare Catapult to other static bug detection
toolssuchas Saturn[45],Calysto[4],Semmle[3],Fortify,and Kloc-
work.8However,theyareeitherunavailableornotrunnableonthe
experimental environmentwe areable toset up.The open-source
static analyzer, FindBugs,9was not included in our experiments
because it only works for Java while we focus on the analysis ofC/C++ programs. We did not compare Catapult toTricoder[
36],
the static analysis platform from Google. This is because it uses
CSAas the C/C++ analyzer, which is included in our experiments.
8Klocwork: https://www.roguewave.com/products-services/klocwork/.
9FindbugsStaticAnalyzer: http://findbugs.sourceforge.net/ .
Conquering the Extensional Scalability Problem for Value-Flow Analysis Frameworks ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
Subjectsforevaluation. Toavoidpossiblebiasesonthebench-
mark programs, we included the standard and widely-used bench-
marks,SPECCINT200010(ID=1∼12inTable 4),inourevaluation.
Meanwhile, to demonstrate the efficiency and effectiveness of Cat-
apulton real-world projects, we also included ten industrial-sized
open-source C/C++ projects (ID = 13 ∼22 in Table 4), of which the
size rangesfrom a few thousand to two million lines of code.
Environment. Allexperimentswereperformedonaserverwith
eighty“Intel(R)Xeon(R)CPUE5-2698v4@2.20GHz”processors
and 256GBof memory running Ubuntu-16.04.
6.1 Comparingto Static Value-Flow Analyzer
We first compared Catapult toPinpoint, the state-of-the-art value-
flowanalyzer.Toquantifytheeffectofthegraphtraversalplanand
the optimizationplan separately, we alsoconfigured Catapult∗to
only containthe graphtraversal plan.
Inthisexperiment,weperformedthewholeprogramanalysis
by linking all compilation units of a project into a single file for
the static analyzers to perform the cross-file analysis. Before the
analysis,both Pinpoint andCatapult needtobuildthevalue-flow
graph as the program intermediate representation. Since Catapult
is built on top of Pinpoint, the pre-processing time and the size
ofvalue-flowgrapharethesameforbothtools,whicharealmost
lineartothesizeofaprogram[ 38].Typically,forMySQL,aprogram
with about two million lines of code, it takes twenty minutes to
build a value-flow graph with seventy million nodes and ninety
millionedges.
Efficiency. The time and memory cost of checking each bench-
mark program is shown in Figure 6a. Owing to the inter-property-
awareness, Catapult is about 8×faster than Pinpoint and takes
only 1/7of thememory on average.Typically, Catapult can finish
checkingMySQLin5hours,whichisalignedwiththeindustrial
requirement of finishing an analysis in 5 to 10 hours [7, 32].
When the optimization plan is disabled, Catapult∗is about 3.5×
fasterthan Pinpointandtakes1/5ofthememoryonaverage.Com-
paredtotheresultof Catapult,itimpliesthatthegraphtraversal
plan and the optimization plan contribute to 40% and 60% of the
time cost reduction, respectively. Meanwhile, they contribute to
70% and 30% of the memory cost reduction, respectively. As a sum-
mary,thetwoplanscontributesimilartothetimecostreduction,
and the graph traversal plan is more important for the memory
cost reduction because it allows us to avoid duplicate data storage
by sharing analysis results across different properties.
Using the largestsubject,MySQL,as anexample, Figure 6b illus-
tratesthegrowthcurvesofboththetimeandthememoryoverhead
whentheproperties in Table 3areadded into the coreengine one
by one. Figure 6b shows that, in terms of both time and memory
overhead, Catapult grows much slower than Pinpoint and, thus,
scalesup quite gracefully.
It is noteworthy that, except for the feature of inter-property-
awareness, Catapult follows the same method of Pinpoint to build
value-flowgraphandperformpath-sensitiveanalysis.Thus,they
have the similar performance to check a single property. Catapult
performsbetterthan Pinpoint onlywhenmultiplepropertiesare
checked together.
10SPECCINT2000benchmarks: https://www.spec.org/cpu2000/CINT2000/.Effectiveness. Since both Catapult andPinpoint check pro-
grams with the precision of inter-procedural path-sensitivity, as
shown in the left part of Table 5, they produce a similar number of
bug reports (# Rep) and false positives (# FP) for all the real-world
programs except for the programs that Pinpoint fails to analyze
due to the out-of-memory exception.
6.2 Comparingto Other Static Analyzers
Tobetterunderstandtheperformanceof Catapult incomparison
to other types of property-unaware static analyzers, we also ran
Catapult against two prominent and mature static analyzers, CSA
(based on symbolic execution) and Infer(based on abductive in-
ference).Notethat Inferdoesnotclassifythepropertiestocheck
as Table3buttargets at a similar range of properties, suchas null
dereference, memory leak, and others.
In our experiment, CSAwas run withtwo different configura-
tions: one is its default configuration where a fast but imprecise
range-basedsolverisemployedtosolvepathconditions,andthe
other uses Z3 [ 19], a full-featured SMT solver, to solve path condi-
tions. To ease the explanation, we denote CSAin the two config-
urations as CSA(Default) and CSA(Z3), respectively. Since CSA
separatelyanalyzeseachsourcefileand Inferonlyhaslimitedca-
pability of detecting cross-file bugs, for a fair comparison, all tools
intheexperimentswereconfiguredtochecksourcefilesseparately,and the timelimit for analyzing eachfile is set to 60 minutes. Since
a single source file is usually small, we did not encounter memory
issuesintheexperimentbutmissedalotofcross-filebugsasdis-
cussedlater.Also,sincewebuildvalue-flowgraphsseparatelyfor
eachfileanddo notneed totrackcross-filevalueflows, thetime
costofbuildingvalue-flowgraphsisalmostnegligible.Typically,
forMySQL,ittakesaboutfiveminutestobuildvalue-flowgraphs
for all of its source code. This time cost is included in the results
discussed below.
Note that we did not change other default configurations of
CSAandInfer. This is because the default configuration is usually
the best in practice. Modifying their default configuration may
introduce more biases.
Efficiency(Catapult vs.CSA(Z3)).Whenboth Catapult and
CSAemployZ3tosolvepathconditions,theyhavesimilarpreci-
sion (i.e., full path-sensitivity) in theory. However, as illustratedin Figure 6c,Catapult is much faster than CSAand consumes a
similar amount ofmemory for all of thesubjects. For example, for
MySQL,ittakesabout36hoursfor CSAtofinishtheanalysiswhile
Catapult takesonlyhalfanhour,consumingasimilaramountof
memory.Onaverage, Catapult is68×fasterthan CSAatthecost
ofonly2×morememoryspace.Bothanalysescanfinishin12GB
of memory, available in common personal computers.
Efficiency (Catapult vs.CSA(Default) and Infer).As illus-
trated in Figure 6c, compared to both Inferand the default version
ofCSA, Catapult consumes a similar, sometimes a little higher,
amount of time and memory. For instance, for MySQL, the largest
subjectprogram,allthreetoolsfinishtheanalysisin40minutesand
consume about 10GB of memory. With similar efficiency, Catapult,
as a fully path-sensitive analysis, is much more precise than theother two. The lower precision of CSAandInferleads to many
false positives as discussed below.
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea Qingkai Shi, Rongxin Wu, Gang Fan, and Charles Zhang
123456789 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 2 0 2 1 2 236hrTime
log scale
Subjects ordered by size0.5hr> 35hr
≈ 0.8hr
024681012
1 2 3 4 5 6 7 8 9 1 01 11 21 31 41 51 61 71 81 92 02 12 2Memory
GB
Subjects ordered by sizeTime
minutes
CheckersMemory out
020040060080010001200
123456789 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 2 0Memory outMemory
GB
Checkers050100150200250300
123456789 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 2 0Memory out
050100150200250300
123456789 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 2 0 2 1 2 2Memory
GB
Subjects ordered by sizeNot finish due to memory out020040060080010001200
123456789 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 2 0 2 1 2 2Subjects ordered by sizeNot finish due to memory outTime
minutes
(a)                                                                                         (b)                              (c)catapult
infercsa (z3)
csa (default)pinpoint
catapultpinpoint
catapult catapult* catapult*
Figure6:(a)Comparing Catapult toPinpoint.(b)Thegrowthcurvesofthetimeoverheadandthememoryoverhead.(c)Com-
paring Catapult toCSAandInfer.
Table 5: Effectiveness (Catapult vs.Pinpoint, CSA, and Infer).
ProgramCatapult Pinpoint
# Rep # FP # Rep # FP
shadowsocks 90 90
webassembly 10 2 10 2
transmission 24 2 24 2
redis 39 5 39 5
imagemagick 26 8 --
python 48 7 48 7
glusterfs 59 22 59 22
icu 161 31 --
openssl 48 15 --
mysql 245 88 --
%F P 26.9% 20.1%ProgramCatapult CSA(Z3) CSA(Default) Infer†
# Rep # FP # Rep # FP # Rep # FP # Rep # FP
shadowsocks 82 24 22 25 23 15 13
webassembly 40 10 62 12 12
transmission 31 10 17 12 26 21 167* 82
redis 19 6 15 7 32 20 16 7
imagemagick 24 7 34 21 78 61 34 18
python 37 7 62 40 149* 77 82 63
glusterfs 28 5 00 268* 82 --
icu 55 11 94 67 206* 69 248* 71
openssl 39 19 44 26 44 26 211* 85
mysql 59 20 271* 59 1001* 79 258* 80
%F P 28.6% 64.9% 75.7% 78.6%
* We inspected one hundred randomly-sampled bug reports.
†We fail to run the tool on glusterfs.
Effectiveness. In addition to the efficiency, we also investigate
the bug-finding capability of the tools. The right part of Table 5
presents the results. Since we only perform file-level analysis in
this experiment, the bugs reported by Catapult is much fewer than
thoseintheleftpartofTable 5.Becauseoftheprohibitivecostof
manually inspecting all of the bug reports, we randomly sampled a
hundred reports for the projects that have more than one hundred
reports. Our observation shows that, on average, the false positive
rateof Catapult ismuchlowerthanboth CSAandInfer.Intermsof
recall, Catapult reportsmoretruepositives,whichcoverallthose
reportedby CSAandInfer. CSAandInfermissmanybugsdueto
the trade-offs they make in exchange for efficiency. For example,
CSAoften stops itsanalysis on a path after it finds the first bug.
Together with the results on efficiency, we can conclude that
Catapult ismuchmorescalablethan CSAandInferbecausethey
havesimilartimeandmemoryoverheadbut Catapult ismuchmore
precise and able to detect more bugs.6.3 Detected Real Bugs
We note that the real-world software used in our evaluation is
frequentlyscannedbycommercialtoolssuchas Coverity SAVE11
and, thus, is expected to have very high quality. Nevertheless, due
tothehighefficiency,precision,andrecall, Catapult stillcandetect
manydeeply-hiddensoftwarebugsthatexistingstaticanalyzers,
suchas Pinpoint, CSA, and Infer, cannot detect.
At the time of writing, thirty-nine previously-unknown bugs
have been confirmed and fixed by the software developers, in-
cludingseventeennullpointerdereferences,tenuse-after-freeor
double-free bugs, eleven resource leaks, and one stack-address-
escape bug. Four of them even have been assigned CVE IDs due to
theirsignificantsecurityimpact.Wehavemadeanonlinelistfor
all bugsassigned CVE IDs or fixed by their original developers.12
11Coverity Scan: https://scan.coverity.com/projects/.
12Detected real bugs: https://qingkaishi.github.io/catapult.html .
Conquering the Extensional Scalability Problem for Value-Flow Analysis Frameworks ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
ResampleFilter **AcquireResampleFilterThreadSet(...) {
…
if(…)
return ((ResampleFilter **) NULL);
…
}
Image *DistortImage(...) { // >1, 000 lines of code
…resample_filter=AcquireResampleFilterThreadSet(...);
…
switch (method) {
caseAffineDistortion:
ScaleFilter(resample_filter[id], ...)
…
}
…
}Location: MagickCore/resample-private.h
Location: MagickCore/distort.cA null pointer is returned if 
some condition is satisfied.
Get the null pointer from the callee function.
The null pointer is dereferenced after a long propagation
Figure 7: A null-dereference bug in ImageMagick.
Asanexample,Figure 7presentsanull-deferencebugdetectedby
Catapult in ImageMagick, which is a software suite for processing
images. This bug is of high complexity, as it occurs in a function of
morethan 1,000linesofcode andthecontrolflow involvedinthe
bug spansacross56 functions over 9 files.
Since both CSAandInfermake many unsound trade-offs to
achievescalability,neitherofthemdetectsthisbug. Pinpoint also
cannotdetectthebugbecauseitisnotmemory-efficientandhasto
give up its analysis after the memory is exhausted.
7 RELATED WORK
To the best of our knowledge, a very limited number of existing
staticanalyseshavestudiedhowtostaticallycheckmultiplepro-
grampropertiesatonce,despitethattheproblemisveryimportant
atanindustrialsetting.Goldbergetal .[26]makeunsoundassump-
tions and intentionally stop the analysis on a path after finding the
first bug. Apparently, the approach will miss many bugs, which
violates our design goal. Different from our approach that reduces
unnecessary program exploration via cross-property optimization,
MordanandMutilin [33]studiedhowtodistributecomputingre-
sources,sothattheresourcesarenotexhaustedbyafewproperties.
Cabodi and Nocco [9]studied the problem of checking multiple
propertiesinthecontextofhardwaremodelchecking.Theirmethod
has a similar spirit to our approach as it also tries to exploit the
mutual synergy among different properties. However, it works in adifferentmannerspeciallydesignedforhardware.Inordertoavoid
state-spaceexplosioncausedbylargesetsofproperties,someotherapproachesstudiedhowtodecomposeasetofpropertiesintosmall
groups[1,10].Owingtothedecomposition,wecannotsharethe
analysis results across different groups. There are also some static
analyzerssuchas Semmle[3]and DOOP[8]thattakeadvantage
of datalog engines for multi-query optimization. However, they
are usually not path-sensitive and their optimization methods are
closely related to the sophisticated datalog specifications. In this
paper, we focus on value-flow queries that can be simply specified
as a quadruple and, thus, cannot benefit from the datalog engines.CSAandInfercurrentlyaretwoofthemostfamousopen-source
static analyzers with industrial strength. CSAis a symbolic-execu-
tion-based, exhaustive, and whole-program static analyzer. As a
symbolicexecution,itsuffersfromthepath-explosionproblem[ 27].
To be scalable, it has to make unsound assumptions as in the afore-
mentioned related work [ 26], limit its capability of detecting cross-
file bugs, and give up full path-sensitivity by default. Inferis an
abstract-interpretation-based, exhaustive, and compositional static
analyzer.Tobescalable,italsomakesmanytrade-offs:givingup
path-sensitivity and discarding sophisticated pointer analysis in
most cases. Similarly, Tricoder, the analyzer in Google, only works
intra-procedurally in order to analyze large code base [35, 36].
In the past decades, researchers have proposed many general
techniques that can check different program properties but do not
consider how to efficiently check them together [ 4,5,11,13,15,23,
24,34,38,41,45].Thus, westudy differentproblems. Inaddition,
there are also many techniques tailored only for a special program
property, including null dereference [ 30], use after free [ 46], mem-
ory leak [ 12,25,42,44], and buffer overflow [ 28], to name a few.
Since we focus on the extensional scalability issue for multiple
properties, our approach is different from them.
Value-flow properties checked in our static analyzer are also
related to well-known type-state properties [ 39,40]. Generally, we
canregardavalue-flowpropertyasatype-statepropertywithat
most two states. Nevertheless, value-flow properties have covered
a wide range of program issues. Thus, a scalable value-flow ana-
lyzerisreallynecessaryandusefulinpractice.Modelingaprogram
issueas avalue-flow property has many advantages.For instance,
Cherem et al .[12]pointed out that we can utilize the sparseness
ofvalue-flowgraphtoavoidtrackingunnecessaryvaluepropaga-
tion in a control flow graph, thereby achieving better performance
and outputtingmore concise issuereports. In thispaper, we also
demonstratethatusingthevalue-flow-basedmodelenablesusto
mitigatethe extensional scalability issue.
8 CONCLUSION
We have presented Catapult, a scalable approach to checking mul-
tiple value-flow properties together. The critical factor that makes
ourtechniquefastistoexploitthemutualsynergyamongtheprop-ertiestocheck.Sincethenumberofprogrampropertiestocheckisquicklyincreasingnowadays,webelievethatitwillbeanimportant
research direction to study how to scale up static program analysis
for simultaneouslychecking multipleproperties.
ACKNOWLEDGMENTS
The authors would like to thank the anonymous reviewers and Dr.
Yepang Liu for their insightful comments. This work is partially
funded by an MSRA grant, as well as Hong Kong GRF16230716,
GRF16206517,ITS/215/16FP,andITS/440/18FPgrants.RongxinWu
is partially supported by the NSFC Project No. 61902329 and is the
correspondingauthor.
REFERENCES
[1]SvenApel,DirkBeyer,VitalyMordan,VadimMutilin,andAndreasStahlbauer.
2016. On-the-fly decomposition of specifications in software model checking. In
Proceedingsofthe201624thACMSIGSOFTInternationalSymposiumonFounda-
tionsof Software Engineering. ACM, 349–361.
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea Qingkai Shi, Rongxin Wu, Gang Fan, and Charles Zhang
[2]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysisforandroidapps.In Proceedingsofthe35thACMSIGPLANConferenceon
Programming Language Design and Implementation (PLDI ’14). ACM, 259–269.
[3]PavelAvgustinov,OegedeMoor,MichaelPeytonJones,andMaxSchäfer.2016.
QL: Object-oriented Queries on Relational Data. In 30th European Conference on
Object-Oriented Programming (ECOOP ’16). Schloss Dagstuhl–Leibniz-Zentrum
fuerInformatik,2:1–2:25.
[4]Domagoj Babic and Alan J. Hu. 2008. Calysto: Scalable and precise extended
staticchecking.In Proceedingsofthe30thInternationalConferenceonSoftware
Engineering (ICSE’08). IEEE, 211–220.
[5]ThomasBallandSriramK.Rajamani.2002. TheSLAMproject:Debuggingsystem
software via static analysis. In Proceedings of the 29th ACM SIGPLAN-SIGACT
Symposiumon Principles of Programming Languages (POPL ’02). ACM, 1–3.
[6]PaulBeanie,HenryKautz,andAshishSabharwal.2003. Understandingthepower
of clause learning. In Proceedings of the 18th International Joint Conference on
Artificial Intelligence (IJCAI ’03) . Morgan Kaufmann Publishers Inc., 1194–1201.
[7]AlBessey,KenBlock,BenChelf,AndyChou,BryanFulton,SethHallem,CharlesHenri-Gros,AsyaKamsky,ScottMcPeak,andDawsonEngler.2010. Afewbillion
lines of code later: using static analysis to find bugs in the real world. Commun.
ACM53,2 (2010), 66–75.
[8]Martin Bravenboer and Yannis Smaragdakis. 2009. Strictly declarative specifica-
tionofsophisticatedpoints-toanalyses.In Proceedingsofthe24thACMSIGPLAN
Conference on Object Oriented Programming Systems Languages and Applications
(OOPSLA ’09). ACM, 243–262.
[9]GianpieroCabodiandSergioNocco.2011. Optimizedmodelcheckingofmultiple
properties. In 2011 Design, Automation, and Test in Europe Conference (DATE ’11) .
IEEE,1–4.
[10]P Camurati, C Loiacono, P Pasini, D Patti, and S Quer. 2014. To split or to group:from divide-and-conquer to sub-task sharing in verifying multiple properties. In
InternationalWorkshoponDesignandImplementationofFormalToolsandSystems
(DIFTS),Lausanne, Switzerland . Springer, 313–325.
[11]SagarChaki,EdmundMClarke,AlexGroce,SomeshJha,andHelmutVeith.2004.ModularverificationofsoftwarecomponentsinC. IEEETransactionsonSoftware
Engineering 30,6 (2004), 388–402.
[12]SigmundCherem,LonniePrincehouse,andRaduRugina.2007. Practicalmemory
leak detection using guarded value-flow analysis. In Proceedings of the 28th ACM
SIGPLANConferenceonProgrammingLanguageDesignandImplementation(PLDI
’07). ACM, 480–491.
[13]Chia Yuan Cho, Vijay D’Silva, and Dawn Song. 2013. BLITZ: Compositionalbounded model checking for real-world programs. In Proceedings of the 28th
IEEE/ACM International Conference on Automated Software Engineering (ASE ’13).
IEEE,136–146.
[14]Alessandro Cimatti, Alberto Griggio, and Roberto Sebastiani. 2010. Efficient gen-
eration of Craig interpolants in satisfiability modulo theories. ACM Transactions
on Computational Logic (TOCL) 12,1 (2010), 7.
[15]EdmundClarke,DanielKroening,andKarenYorav.2003. Behavioralconsistency
of C and Verilog programs using bounded model checking. In Proceedings of the
40thannualDesignAutomation Conference. ACM, 368–371.
[16]Patrick Cousot and Radhia Cousot. 2002. Modular static program analysis. In
InternationalConferenceon Compiler Construction (CC ’02). Springer, 159–179.
[17]RonCytron,JeanneFerrante,BarryKRosen,MarkNWegman,andFKenneth
Zadeck.1991. Efficientlycomputingstaticsingleassignmentformandthecontrol
dependencegraph. ACMTransactionsonProgrammingLanguagesandSystems
(TOPLAS) 13,4 (1991), 451–490.
[18]ManuvirDas,Sorin Lerner, and Mark Seigle. 2002. ESP: Path-sensitive program
verificationinpolynomialtime.In ProceedingsoftheACMSIGPLAN2002Con-
ferenceonProgrammingLanguageDesignandImplementation (PLDI’02).ACM,
57–68.
[19]LeonardoDeMouraandNikolajBjørner.2008. Z3:AnefficientSMTsolver.In
InternationalconferenceonToolsandAlgorithmsfortheConstructionandAnalysis
of Systems. Springer, 337–340.
[20]JeffreyDean,DavidGrove,andCraigChambers.1995. Optimizationofobject-
oriented programsusing static classhierarchy analysis.In European Conference
on Object-Oriented Programming. Springer, 77–101.
[21]Dorothy E. Denning. 1976. A lattice model of secure information flow. Commun.
ACM19,5 (1976), 236–243.
[22]Nachum Dershowitz, Ziyad Hanna, and Alexander Nadel. 2006. A scalable
algorithmforminimalunsatisfiablecoreextraction.In TheoryandApplications
of Satisfiability Testing (SAT ’06). Springer, 36–41.
[23]IsilDillig,ThomasDillig,andAlexAiken.2008. Sound,completeandscalable
path-sensitiveanalysis. In Proceedingsof the29thACM SIGPLANConferenceon
Programming Language Design and Implementation (PLDI ’08). ACM, 270–280.
[24]IsilDillig,ThomasDillig,AlexAiken,andMoolySagiv.2011. Preciseandcompact
modular proceduresummaries for heapmanipulating programs. In Proceedings
of the 32nd ACM SIGPLAN Conference on Programming Language Design andImplementation (PLDI’11). ACM, 567–577.
[25]GangFan,RongxinWu,QingkaiShi,XiaoXiao,JinguoZhou,andCharlesZhang.
2019. Smoke: scalable path-sensitive memory leak detection for millions of lines
of code. In Proceedings of the 41st ACM/IEEE International Conference on Software
Engineering (ICSE’19). IEEE, 72–82.
[26]EugeneGoldberg,MatthiasGüdemann,DanielKroening,andRajdeepMukherjee.
2018. Efficient verification of multi-property designs (The benefit of wrong
assumptions).In 2018Design,Automation,andTestinEuropeConference (DATE
’18). IEEE, 43–48.
[27]JamesCKing.1976. Symbolicexecutionandprogramtesting. Commun.ACM
19,7 (1976), 385–394.
[28]Wei Le and Mary Lou Soffa. 2008. Marple: a demand-driven path-sensitive
bufferoverflowdetector.In Proceedingsofthe16thACMSIGSOFTInternational
Symposium on Foundations of software engineering. ACM, 272–282.
[29]Lian Li, Cristina Cifuentes, and Nathan Keynes. 2011. Boosting the Performance
of Flow-sensitive Points-to Analysis Using Value Flow. In Proceedings of the 19th
ACMSIGSOFTSymposiumandthe13thEuropeanConferenceonFoundationsof
Software Engineering (ESEC/FSE ’11). ACM, 343–353.
[30]Benjamin Livshits and Monica S Lam. 2003. Tracking pointers with path and
context sensitivity for bug detection in C programs. In Proceedings of the 9th
EuropeanSoftwareEngineeringConferenceHeldJointlywith11thACMSIGSOFT
International Symposium on Foundations of Software Engineering (ESEC/FSE ’11).
ACM, 317–326.
[31]BenjaminLivshits,ManuSridharan,YannisSmaragdakis,OndřejLhoták,JNelson
Amaral, Bor-Yuh Evan Chang, Samuel Z Guyer, Uday P Khedker, Anders Møller,
andDimitriosVardoulakis.2015. Indefenseofsoundiness:amanifesto. Commun.
ACM58,2 (2015), 44–46.
[32]Scott McPeak, Charles-Henri Gros, and Murali Krishna Ramanathan. 2013. Scal-
able and incremental software bug detection. In Proceedings of the 2013 9th Joint
Meetingon Foundationsof SoftwareEngineering (ESEC/FSE’13).ACM, 554–564.
[33]VitalyOMordanandVadimSMutilin.2016. Checkingseveralrequirementsat
onceby CEGAR. Programming and Computer Software 42,4 (2016), 225–238.
[34]ThomasReps,SusanHorwitz,andMoolySagiv.1995. Preciseinterprocedural
dataflowanalysisviagraphreachability.In Proceedingsofthe22ndACMSIGPLAN-
SIGACTSymposiumonPrinciplesofProgrammingLanguages (POPL’95).ACM,
49–61.
[35]CaitlinSadowski,EdwardAftandilian,AlexEagle,LiamMiller-Cushon,andCiera
Jaspan. 2018. Lessons from building static analysis tools at Google. Commun.
ACM61,4 (2018), 58–66.
[36]CaitlinSadowski,Jeffrey Van Gogh, Ciera Jaspan, Emma Söderberg, and Collin
Winter. 2015. Tricorder: Building a program analysis ecosystem. In Proceedings
of the 37th International Conference on Software Engineering (ICSE ’15). IEEE,
598–608.
[37]Qingkai Shi, Rongxin Wu, Gang Fan, and Charles Zhang. 2019. Conquering the
Extensional Scalability Problem for Value-Flow Analysis Frameworks. arXiv
preprint arXiv:1912.06878 (2019).
[38]QingkaiShi,XiaoXiao,RongxinWu,JinguoZhou,GangFan,andCharlesZhang.
2018. Pinpoint: Fast and precise sparse value flow analysis for million lines
of code. In Proceedings of the 39th ACM SIGPLAN Conference on Programming
LanguageDesignandImplementation (PLDI’18) . ACM, 693–706.
[39]RobertE.Strom.1983. MechanismsforCompile-timeEnforcementofSecurity.
InProceedings of the 10th ACM SIGACT-SIGPLAN Symposium on Principles of
Programming Languages (POPL ’83). ACM, 276–284.
[40]RobertEStromandShaulaYemini.1986. Typestate:Aprogramminglanguage
conceptforenhancingsoftwarereliability. IEEETransactionsonSoftwareEngi-
neeringSE-12,1 (1986), 157–171.
[41]Yulei Sui and Jingling Xue. 2016. SVF: Interprocedural static value-flow analysis
in LLVM. In International Conference on Compiler Construction (CC ’16). ACM,
265–266.
[42]Yulei Sui, Ding Ye, and Jingling Xue. 2014. Detecting memory leaks statically
withfull-sparsevalue-flowanalysis. IEEETransactionsonSoftwareEngineering
40,2 (2014), 107–122.
[43]Omer Tripp, Marco Pistoia, Patrick Cousot, Radhia Cousot, and Salvatore
Guarnieri. 2013. Andromeda: Accurate and scalable security analysis of web
applications. In International Conference on Fundamental Approaches to Software
Engineering. Springer, 210–225.
[44]Yichen Xie and Alex Aiken. 2005. Context- and path-sensitive memory leak
detection.In Proceedingsofthe10thEuropeanSoftwareEngineeringConference
Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of
Software Engineering (ESEC/FSE ’05). ACM, 115–125.
[45]Yichen Xie and Alex Aiken. 2005. Scalable error detection using Boolean satisfia-bility. InProceedings of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages (POPL ’05). ACM, 351–363.
[46]Hua Yan, Yulei Sui, Shiping Chen, and Jingling Xue. 2018. Spatio-temporal
context reduction: a pointer-analysis-based static approach for detecting use-after-free vulnerabilities. In 2018 IEEE/ACM 40th International Conference on
Software Engineering (ICSE ’18). IEEE, 327–337.
