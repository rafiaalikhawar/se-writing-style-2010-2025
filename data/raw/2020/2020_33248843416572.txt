Zeror: Speed Up Fuzzing with Coverage-sensitive Tracing and
Scheduling
Chijin Zhou
KLISS, BNRist, School of Software
Tsinghua University
Beijing, China
zcj18@mails.tsinghua.edu.cnMingzhe Wang
KLISS, BNRist, School of Software
Tsinghua University
Beijing, China
wmzhere@gmail.comJie Liang
KLISS, BNRist, School of Software
Tsinghua University
Beijing, China
liangjie.mailbox.cn@gmail.com
Zhe Liu
Computer Science and Technology
NUAA
Nanjing, China
zhe.liu@nuaa.edu.cnYu Jiangâˆ—
KLISS, BNRist, School of Software
Tsinghua University
Beijing, China
jiangyu198964@126.com
ABSTRACT
Coverage-guidedfuzzingis oneofthemost popularsoftwaretest-
ing techniques for vulnerability detection. While effective, current
fuzzingmethodssufferfromsignificantperformancepenaltydue
toinstrumentationoverhead,whichlimitsitspracticaluse.Existing
solutions improve the fuzzing speed by de creasing instrumenta-
tion overheads but sacrificing coverage accuracy, which results in
unstable performance of vulnerability detection.
Inthispaper,weproposeacoverage-sensitivetracingandsched-
uling framework Zerorthat can improve the performance of ex-
isting fuzzers, especially in their speedand vulnerability detection.
The Zeroris mainly made up of two parts: (1) a self-modifying
tracing mechanism to provide a zero-overhead instrumentation for
moreeffectivecoveragecollection,and(2)areal-timescheduling
mechanism to support adaptive switch between the zero-overhead
instrumentedbinaryandthefullyinstrumentedbinaryforbetter
vulnerabilitydetection.Inthisway, Zerorisabletodecreasecol-
lectionoverheadand preserve fine-grainedcoverageforguidance.
Forevaluation,weimplementaprototypeof Zerorandevaluate
it on Google fuzzer-test-suite, which consists of 24 widely-used
applications. The results show that Zerorperforms better than ex-
istingfuzzingspeed-upframeworkssuchasUntracerandINSTRIM,improvestheexecutions peedofthe state-of-the-artfuzzerssuchas
AFLandMOPTby159.80%,helpsthemachievebettercoverage(av-
eragely 10.14% for AFL, 6.91% for MOPT) and detect vulnerabilities
faster (averagely 29.00% for AFL, 46.99% for MOPT).
CCS CONCEPTS
â€¢Security and privacy â†’Software security engineering.
âˆ—Yu Jiang is the corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™20, September 21â€“25, 2020, VirtualEvent, Australia
Â© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416572KEYWORDS
Coverage-guided Fuzzing, Coverage-Sensitive Tracing, Scheduling
ACM Reference Format:
Chijin Zhou,Mingzhe Wang, JieLiang, Zhe Liu,and YuJiang. 2020. Zeror:
Speed Up Fuzzing with Coverage-sensitive Tracing and Scheduling. In 35th
IEEE/ACM International Conference on Automated SoftwareEngineering (ASE
â€™20),September21â€“25,2020,VirtualEvent,Australia. ACM,NewYork,NY,
USA, 13 pages. https://doi.org/10.1145/3324884.3416572
1 INTRODUCTION
Coverage-guidedfuzzingis oneofthemost popularsoftwaretest-
ingtechniquesforbugdetection.Inthepastfewyears,ithasgained
significanttractioninacademicresearchaswellasinindustryprac-
tice. Most notably, Googleâ€™s OSS-Fuzz [ 18] adopts American Fuzzy
Lop(AFL) [ 25],honggfuzz [ 21]and libFuzzer[ 34]to continuously
test open source applications. Over 16,000 bugs in 250 open source
projects are discovered by OSS-Fuzz.
A coverage-guided fuzzer feeds a program with random test
cases, collects coverage-increasing test cases (such test cases are
called interesting seeds), and generates new test cases by mutating
thoseseeds.Thekeygoalofcoverage-guidedfuzzersistomaximizecoverageandexploredeeperpathsasfastaspossible.Manyfuzzingoptimizationshavebeenproposedtomaximizecoverage,including
the ones that improve seed selection strategy [ 5,14,41,42]o r
mutation strategy [ 6,28,29,36], the ones that integrate multiple
fuzzingoptimizations[ 9,30,32],andtheonesthatleveragetaint
analysis [ 2,7,8,41], symbolic execution [ 40,46,49,52,53], human
knowledge [ 1,45,54], or machine learning [ 10,16,44] to assist
fuzzing.
Whilethoseaboveoptimizationsgreatlyimproveperformance,
especiallyincoverageimprovements,theydonottakefuzzingover-
headintoconsideration,whichmayhinderthemfromachievingbetter scalability. For example, the overhead caused by coveragecollection is costly. We conduct experiments on AFL using real-
world programs of Google fuzzer-test-suite [17] to investigate the
overhead of collecting coverage. To our surprise, AFL spends an
average of 71.85% and up to 98.5% of its runtime to trace coverage.
Somerelatedworkstrytodecreaseoverheadsfrominstrumenta-
tion. INSTRIM [ 22] reduces instrumentation cost by instrumenting
8582020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
apartofbasicblocksandreconstructingcoverageinformation.Un-
tracer [39] avoids tracing coverage of non-coverage-increasing test
casesbyremovingvisitedinstrumentationpoints.Theycaneffec-
tivelydecreaseoverheadbutcannotpreservefine-grainedcoverage
guidance, which limits their vulnerability detection.
Tospeedupfuzzing andfurtherimprovevulnerabilitydiscovery,
the main challenge is to keep a good balance between instrumenta-tionoverheadsandthegranularityofthecollectedcoverage.Those
existing overhead reduction methodologies decrease the overhead
with sacrificing coverage accuracy. For example, our experiments
demonstratethatcomparedwithAFL, althoughimproves thespeed
by 155.75%, Untracer decreases coverage by 8.31%, which resultsin an unstable ability of vulnerability discovery. Therefore, it is
noteasytokeepagoodbalancebetweenoverheadreductionand
coverage accuracy.
Inthispaper,weproposeacoverage-sensitivetracingandsched-
uling framework Zeror, whichaims at increasingfuzzing speed
withdiversely-instrumentedbinaries.Themainideaisswitching
toaself-modifyingbasedzero-overhead-instrumentedbinaryfor
fuzzing when the normal instrumented binary fails to make better
progress. Zerorismainlymadeupoftwoparts:(1)Aself-modifying
tracing mechanism to provide a zero-overhead instrumentation for
coveragecollection.Theself-modifyingtracingmechanismreduces
the coverage collection overhead by restricting coverage tracing
toonlycoverage-increasingtestcases.(2)Areal-timescheduling
mechanism to support adaptive switch between the zero-overhead
instrumented binary and the fully instrumented binary. To choose
the optimal binary, it estimates the probabilities of discoveringinteresting seeds for each binary by Bayesian inference. Instead
ofdoingatradeoffbetween fuzzingspeed andcoverageaccuracy
within a single binary, the scheduler helps fuzzers achieve both by
taking advantages of diversely-instrumented binaries.
Weimplementedtheprototypeof Zerorandappliedittosev-
eral state-of-the-art fuzzers, including AFL [ 25] and MOPT [ 36].
We evaluated them on Google fuzzer-test-suite, which consists
of24widely-usedreal-worldapplications.Theevaluationresults
demonstratethat Zerorperformsbetterthanexistingfuzzingspeed
up frameworks such as Untracer and INSTRIM. Compared withUntracer, it covers 20.84% more branches with almost the sameexecution time. Compared with INSTRIM, it covers 6.82% more
brancheswith50.72%lessexecutiontime.Itimprovestheexecution
speed oforiginal AFL instrumentation, which is also adopted in
MOPT, by 159.80%, helps them achieve better coverage (averagely
10.14%forAFL,6.91%forMOPT)andexposurevulnerabilitiesfaster
(averagely 29.00% for AFL, 46.99% for MOPT).
In summary, this paper makes following contributions:
â€¢Weproposeacoverage-sensitivetracingandschedulingframe-
work, which integrates diversely-instrumented binaries and sup-
ports adaptive switch between them, to speed up fuzzing as well
as maintain the vulnerability detection ability.
â€¢Weproposeaself-modifyingtracingmechanismtoreducecov-
eragecollectionoverhead.Byusingthismechanism,fuzzerswill
be sensitive to edge-level coverage granularity and only trace
coverage of coverage-increasing test cases.â€¢We propose a real-time scheduling mechanism, which is able to
dynamically choose a proper instrumented binary for fuzzing
executiontoachieveb othspeed and accuracy.
â€¢Weimplementedtheprototypeof Zeror,whichcouldbeapplied
to most of the state-of-the-art fuzzers such as AFL and MOPT.
The results show that Zerorcould help boost executionspeed
and discover vulnerabilities faster than the existing speed-up
framework such as Untracer and INSTRIM.
Thispaperisorganizedasfollows:Section2introducestheback-
ground of coverage-guided fuzzing and coverage tracing. Section 3
illustrates the motivation of this work through an empirical study
onefficienciesofdifferentcoveragecollectionmethods.Section4
elaborates the idea and design of Zeror. Section 5 presents the im-
plementation and evaluation. Section 6 shows some related works
and the main differences, and we get the conclusion in Section 7.
2 BACKGROUND
2.1 Coverage-guided Fuzzing
Coverage-guided fuzzing is currently one of the most effective
andefficientvulnerabilitydiscoverysolution.Itaimstoautomati-
cally generate proof of concept (PoC) exploits by maximizing code
coverage. AFL [ 25], libFuzzer [ 34] and honggfuzz [ 21] are some
well-recognized coverage-guided fuzzers.
Figure1showsthegeneralworkflowofacoverage-guidedfuzzer.
Givenatargetprogramandinitialinputs,fuzzingworksasfollows:
(1)compiletargetprogramintotargetbinary,wherecoveragein-
strumentationareinjected;(2)executethebinaryandspawntarget
process;(3)queueinitialinputsintoseedsgenerator;(4)generate
testcasesasinput;(5)tracecoveragetoevaluatethetestcase;(6)
save the test case to corpus if there is coverage growth (i.e. the
test case is interesting), and goto step 4. During the fuzzing exe-cution loop, performance is highly impacted by execution speed
duringruntime.Fuzzerâ€™sruntimeconsistsoftwoparts,coverage
tracing and fuzzerâ€™s internal logic (including child process estab-
lishment, seed selection and mutation, coverage comparison, etc.).
A simple-but-practical optimization for fuzzerâ€™s internal logic isAFL persistent mode, where a long-live process can be reused to
try out multiple test cases, eliminating the need for repeated fork()
calls and the associated OS overhead [26].
2.2 Coverage Tracing
Coverage-guided fuzzers utilize coverage information to guide
fuzzing.Theytrackcoverageofeachexecution,comparethecover-agewithpreservedcoverage,andcheckwhethercurrenttestcaseiscoverage-increasing. The most common approach to gain coverage
information for fuzzing is instrumentation, which is taken vari-
ouslybydifferentfuzzers.ForOSkernelfuzzing,Syzkaller[ 47]and
kAFL[43]instrumenttargetkernelbyhardware-assistedmecha-
nisms(e.g.IntelPT[ 23]).Forblackbox(source-unavailable)applica-
tionsfuzzing,VUzzer[ 41]usesPIN[ 35]todynamicallyinstrument
black-box binaries. For whitebox (source-available) applicationsfuzzing, libFuzzer and honggfuzz use SanitizerCoverage [
19] in-
strumentation method provided by Clang compiler, and AFL im-
plements instrumentation by hardcoding basic-block keys into the
assembly file of target programs.
859source code
instrumentation
fuzzing 
report
seeds 
generatorinitial 
seeds
Fuzzer
Target Processinputfeedback
binary
coverage 
tracer
feedback
Figure 1: The general workflow of coverage-guided fuzzing
YRLGIRRLQWD
^
LID
D 
`
(a) codeLID
D 
UHWXUQ
(b) basic-block levelLID
D 
UHWXUQ
(c) edge level
Figure 2: Different coverage granularities provided by Sani-
tizerCoverage. Basic-block level focuses on the coverage ofeach node, while edge level focuses on the coverage of theedge. Furthermore, an empty â€œdummyâ€ block is inserted todenote a critical edge between two basic blocks.
Different instrumentation mechanisms provide different cov-
erage granularities. SanitizerCoverage and AFL instrumentation
method are two most widely-used coverage instrumentation mech-
anisms.SanitizerCoverageoffersbasic-blocklevelandedgelevel
instrumentation. Figure2 illustratesthe mechanismsin a briefex-
ample. Basic blocks are the nodes of programâ€™s control-flow graph,
denoting a piece of straight line code (i.e. there is no jump in orout of the middle of a block). SanitizerCoverage extracts control-
flow graph of target program and instruments each basic block in
LLVMIRwhenthebasic-blocklevelinstrumentationisactivated.
To enhance instrumentation from basic-block level to edge level,
SanitizerCoverageaddsâ€œdummyâ€blockstodenotecriticaledges,
which is neither the only edge leaving its source block, nor the
only edge entering its destination block. Unlike SanitizerCover-age, AFL instrumentation method tracks edge coverage directly.It assigns random keys to target programâ€™s basic blocks during
staticinstrumentation,dynamicallycalculatesedgekeysthrough
previousbasic-block keys and currentbasic-block keys, and tracks
edgecountersina64Khashtablebyedgekeys[ 14,25].AFLisalso
compatible with SanitizerCoverage [26].3 MOTIVATIONS
Different coverage collection mechanisms trace different cover-age granularities. The more accurate information gains through
tracing coverage, the more overheads fuzzing faces. However, it is
unclearhow granularityrelates totracingcoverage andoverhead.
Anintuitiveimpressionisthat,fuzzersguidedbydifferentcover-
agegranularitieshavedifferentstrengthswhenfuzzingdifferent
target programs. To verify our hypothesis, we conducted a prelim-
inary experiment on different coverage granularities to evaluateeach granularityâ€™s efficiency. Three different coverage collection
instrumentation mechanisms are chosen in our experiment:
â€¢AFL (edge) : the fuzzer is AFL and target programs are instru-
mented by original AFLâ€™s edge level instrumentation.
â€¢AFL (basic-block) : the fuzzer is AFL and target programs are
instrumentedbySanitizerCoverage,usingbasic-blocklevelin-
strumentation.
â€¢AFL(coarse-basic-block) :thefuzzerisAFLandthetargetpro-
grams are instrumented by Untracer [ 39], which decreases time
onhandlingdiscardedtestcasesbutonlyobtainscoarsebasic-
block level coverage without accumulating hit count.
WerunabovethreemechanismsonGooglefuzzer-test-suite[ 17]
for6hoursandselectpartialresultsforpreliminaryillustration(allexperiment settings are in line with Section 5.1). From the result of
Figure 3 and Table 1, we have the following observations:
Observation1:tracingaccuratecoverageiscostly .Asillus-
trated in Section 2.1, coverage tracing and internal logic execution
aretwoconstituentpartoffuzzerâ€™sruntime.WerecordAFLinternal
logic execution time during each iteration, and calculate edge level
coveragetracingtimebycomparingeachtestcaseâ€™sexecutiontimeininstrumentedversionandnon-instrumentedversion.AsFigure3shows,timespentintracingcoverageaccountsforaveragely71.85%ofAFLâ€™swholeruntime.Theratioisevenupto98.5%whenfuzzing
openssl-1.0.1f.
Figure 3: Percentage of internal logic execution time andedge level coverage tracing time in AFL.
Observation2:theefficiencyofeachcoveragegranularity
varies with target programs
. We record the time spent in trig-
geringknownvulnerabilitiesforeachmechanism,andtheresult
is shown in Table 1. Due to the limitation of Dyninst [ 13], Un-
tracer is incompatible with some projects (denote as N/A). From
Table 1, we can see that: AFL (edge) exposes known vulnerabilities
860faster than others on openssl-1.0.1f andopenssl-1.0.2d ; AFL
(coarse-basic-block) exposes known vulnerabilities faster than oth-
erson guetzli.AFL(basic-block)exposesknownvulnerabilities
faster than others on lcms, pcre2.
Table1:Timetakentotriggerknownbugsforfuzzersguided
by different coverage granularities. âˆdenotes the fuzzer
cannotexposeknownbugsin6hours.N/Adenotescompat-
ibility issues of Untracer on specific programs.
ProjectAverage Reaching Time (seconds)
AFL AFL AFL+Untracer
(edge) (basic-block) (coarse-basic-block)
c-ares 55 842
guetzli âˆâˆ 16257
json 5 6 5
lcms 20679 4084 11827
openssl-1.0.1f 19 31 N/A
openssl-1.0.2d 8716 10407 N/A
pcre2 822 413 6095
Focus of this Paper : From the observation 1, we find that trac-
ing coverage is costly. In search for coverage-increasing test cases,
fuzzingisbasedongeneticalgorithm,whichmakesitseffectiveness
highly impacted by execution speed. Thus, we focus on improving
fuzzing efficiency by reducing the coverage collection overhead.
Weproposeanovelself-modifyingtracingmechanismtoeliminate
needlesscoveragecollection.Besides,inspiredbytheobservation
2, instead of doing a tradeoff betw eenfuzzingspeed and coverage
accuracy, we propose a scheduling scheme, which helps fuzzers
achieve both goals by integrating diversely-instrumented binaries.
4 ZEROR DESIGN
Figure 4 depicts the basic work flow and main components of
Zeror.Differentfromtraditionalcoverage-guidedfuzzing, Zeror
will choose a proper binary as fuzzing target (i.e. the running pro-
gramforfuzzing)amongdiversely-instrumentedbinaries. Zeror
consists of two main components : coverage tracer andbinary-
switchingscheduler.(1) Coveragetracer collectscoverageinforma-
tionfromfuzzingtarget,storesseedsintocorpusiftheseedsareinteresting and sends statistical data to binary-switching sched-
uler. It will self-adjust when fuzzing target changes: when fuzzing
AFL-instrumentedbinaries, coveragetracer willreadcoveragefrom
edge-counters hash table; when fuzzing the binaries instrumented
byself-modifyingtracing, coveragetracer willmonitorthestatus
of child process and modify the instructions of child process. (2)
Binary-switchingscheduler recordsthestatisticaldatafrom cover-
age tracer, estimates efficiency of each instrumented binary based
on the statistical data and choose the optimal binary as fuzzing
target when time to switch binary. Specially, we leverage empirical
Bayesian method to estimate efficiency in a cost-effective way and
adoptexponentialsmoothingtosmooththetime-varyingefficiency.source code
diversely-
insturmented 
binaries
multiple 
instrumentations
fuzzing 
report
binary-
switching 
scheduler
coverage 
tracer
seeds 
generatorinitial 
seeds
Fuzzer
Target Processmodify feedback input
switchfeedback update
Figure 4: Overview of Zeror, which mainly includes the
self-modifying tracing mechanism implemented with mul-
tiple instrumentation and coverage tracer, and the real-time scheduling mechanism implemented with the binary-switching scheduler. Multiple instrumentation means theself-modifying tracing based instrumentation and the fullinstrumentation of the integrated original fuzzer.
4.1 Self-modifying Tracing
Asaforementioned,coverage-guidedfuzzingspendsthemajority
of its runtime in collecting coverage. It is intuitive that restrict-ing coverage tracing to only coverage-increasing test cases will
significantlyreducetheoverhead.However,howtosensecoverage-
increasing seeds and ignore discarded test cases is still an open
problem.Differentwithstaticbinaryrewritingtechniqueusedin
Untracer [ 39], which is coverage-inaccurate, time-consuming and
not scalable on many complex programs, our solution, namelyself-modifying tracing, adopts self-modifying code technique toaddress the problem. With the assistance of self-modifying trac-
ing,fuzzerscould(1)dynamicallyremovevisitedinstrumentation
pointsduringfuzzingprocess;(2)sensefine-grainedcoverage;(3)
barely introduce new overhead.
Self-modifyingcode(SMC)referstothecodethatcanmodifyits
own instructions during the execution of the program. It is widely
used in many of software systems to support runtime code gen-
eration[27,37]andoptimization[ 3],minimizethecodesize[ 11],
andreinforcedynamiccodeencryptionandobfuscation[ 24].There
are several advantages in SMC, such as fast paths establishment,
repetitiveconditionalbranchesreductionandalgorithmicefficiencyimprovement.ToapplySMCtocoveragetracing,weneedtoobtain
theaddressesofinstrumentationpointsatcompilationstage,and
self-modifyingtheaddressesatruntimestage.Astep-by-stepex-
ample is shown in Figure 5 to elaborate how our solution performs
self-modifying tracing with compilation stage and runtime stage.
Atcompilationstage ,weneedtogenerateazero-overheadbi-
nary and obtain the addresses of instrumentation points. However,
861Address Binariy Codes Assembly
0x2b1980 55 push   %rbp
0x2b1981 48 89 e5 mov    %rsp,%rbp
0x2b1984 b8 01 00 00 00 mov    $0x1,%eax0x2b1989 39 f7 cmp    %esi,%edi0x2b198b 7f 0c jg     2b19990x2b198d b8 02 00 00 00 mov    $0x2,%eax
0x2b1992 7c 05 jl     2b19990x2b1994 b8 03 00 00 00 mov    $0x3,%eax
0x2b1999 5d                  pop    %rbp
0x2b199a c3                     retqAddress Binariy Codes Assembly
0x2b1980 cc int3 ...
0x2b1981 48 89 e5 mov    %rsp,%rbp
0x2b1984 b8 01 00 00 00 mov    $0x1,%eax0x2b1989 39 f7 cmp    %esi,%edi0x2b198b 7f 0c jg     2b19990x2b198d cc 02 00 00 00 int3 ...
0x2b1992 7c 05 jl     2b19990x2b1994 cc 03 00 00 00 int3 ...
0x2b1999 cc                  int3 ...
0x2b199a c3                     retqAddress Binariy Codes Assembly
0x2b1980 55 push   %rbp
0x2b1981 48 89 e5 mov    %rsp,%rbp
0x2b1984 b8 01 00 00 00 mov    $0x1,%eax0x2b1989 39 f7 cmp    %esi,%edi0x2b198b 7f 0c jg     2b19990x2b198d cc 02 00 00 00 int3 ...
0x2b1992 7c 05 jl     2b19990x2b1994 cc 03 00 00 00 int3 ...
0x2b1999 cc                  int3 ...
0x2b199a c3                     retqLQWIRRLQWDLQWE
^
LID!E
UHWXUQ
HOVHLIDE
UHWXUQ
HOVHUHWXUQ
`%eaxÂ <-Â Â 1
ifÂ (aÂ >Â b)
%eaxÂ <-Â Â 2
ifÂ (aÂ >Â b)
%eaxÂ <-Â Â 3
return7UXH
7UXH)DOVH
)DOVH&RPSLODWLRQ6WDJH
 5XQWLPH6WDJH
([HFXWHELQDU\DQG
LQMHFWEUHDNSRLQWV5HFRYHUELQDU\FRGHZKHQWULJJHULQWHUUXSW
 &RQVWUXFW&)* *HQHUDWHELQDU\ILOHDQGUHFRUGWDUJHWDGGUHVVHVâ‘ â‘¡ â‘¢ â‘£
Figure5:Astep-by-stepdemonstrationofself-modifyingtracing.Iteliminatesneedlessoverheadspentintracingcoverageof
non-coverage-increasingtestcaseswithtwostages.Itfirstinstrumentstargetprograms,obtainsaddressesofinstrumentationpointsandgeneratesanon-instrumentedexecutablebinaryfileatcompilationstage.Then,itdoesfuzztestingonthebinary,detects whether instrumentation points are triggered and removes visited instrumentation points at runtime stage. (The seg-ments in blue rectangles is the text segments of the programâ€™s memory layout, the addresses of instrumentation points arehighlighted in blue, the modified instructions are highlighted in red, the recovered instructions are highlighted in orange.)
therearetwochallengestobeaddressed:(1) Howtoinjectinstrumen-
tation points into target program? Blackbox instrumentation will
obtainredundantandless-accuratecoverageinformation,whichim-pairfuzzingperformance.Whileinstrumentingprogramsinawhite-
boxwaylikeAFLinstrumentation[ 25]orSanitizerCoverage[ 19]
will introduce costly overhead. Besides, using self-modifying code
basedonAFLinstrumentationalsoobtainscoarse-grainedcoverage
because AFL only injects instrumentation points into basic blocks.
Thus,aninstrumentationapproachwhichobtainsfine-grainedcov-
erageandintroduceslessoverheadisdemanded.(2) Howtotrack
theaddresses ofinstrumentationpoints? Compilerswill deactivate
somecodeoptimizationsassoonasanyaddressofbasicblockisobtained, and the un-optimized binary will be executed at a lowspeed. Thus, we need t o track the addresses of instrumentation
points in a proper way.
Togenerateazero-overheadbinaryandtracktheaddressesof
instrumentationpoints,itworksasfollowstocompileaprogram
from source code to object file:
â€¢Inject instrumentation points. Before the compiler starts perform-
ing platform-independent code optimizations, we construct con-
trolflowgraphandinjectaninstrumentationpoint,i.e.a CALL
instruction to invoke callback function, at the start of each basic
block. Note that, similar with SanitizerCoverage, the instrumen-
tation could be enhanced from basic-block level to edge level by
adding "dummy" blocks to denote critical edges as Section 2.2 il-
lustrates.Instrumentingbeforecodeoptimizationsallowscontrolflowgraphtopreservesemanticsofsourcecodesothatcoverage
information is collected accurately.
â€¢Record&Clear.Werecordthecorrespondingbasicblocksymbols
ofinjected CALLinstructionsanderasealltheinjected CALLin-
structions after compiler finishes platform-independent code op-
timizations at intermediate representation (IR) level. In this way,
the generated IR could be non-instrumented while the recordedbasicblocksymbolsinheritthefine-grainedcoverageinforma-
tion from instrumentation points.
â€¢Emitaddresses.Weobtainaddressesofinstrumentationpoints
through the recorded basic block symbols, allocate a memory in
thegeneratedobjectfileandemittheaddressesintothememoryaftercompilerfinishesplatform-dependentcodeoptimizationsat
machine-specificintermediate representation (MIR)level.Note
that, the addresses are a series of offsets in object file and willbe relocated to absolute addresses when a linker generates ex-ecutable binary. In this way, the addresses of instrumentation
points are written in generated binary and could be accessed to
perform self-modify tracing during runtime.
Inthetextsegmentsafterstep2ofFigure5,wehighlightfour
addresses( 0x2b1980 ,0x2b198d ,0x2b1994 and0x2b1999 )inblue
todenotetheaddressesofinstrumentationpoints.Forsimplicity,weonlyshowbasic-blocklevelinstrumentation;however,oursolution
enhancesinstrumentationfrombasic-blockleveltoedgelevelby
adding â€œdummyâ€ blocks to denote critical edges. After compilation
stage,azero-overheadbinaryisgeneratedandpreparedforfuzzing.
Atruntimestage ,thecoveragetracerof Zerorwillexecutethe
zero-overheadbinary,injectbreakpointsintoitandperformfuzzingonthistarget.Algorithm1detailstheactionsofthecoveragetracer.
First, as presented in lines 2-8, the fuzzer executes the binary, re-
ceivestheaddressesofinstrumentationpoints,andreplacesoriginalinstructionswith
0xcc.Thecorrespondingdemonstrationisshown
in step 3 in Figure 5, the binary codes of instrumentation points
are replaced with 0xcc(we highlight the instructions in red). Once
the process executes 0xcc, it will trigger SIGTRAPinterrupt, and
wait for parent process to resume it. After the injection, the fuzzer
performsfuzzingonthechildprocess,andmonitorsthestatusof
it. Once receiving SIGTRAP from child process, the fuzzer stores
current input as interesting seed for further mutation, recovers the
instruction that belongs to the address, and resumes child process,
862as presented in lines 11-18. The corresponding demonstration is
shown in step 4 in Figure 5.
Algorithm 1: Action of self-modifying coverage tracer
Input :the target binary ğ‘
Executorğ¸ğ‘¥ğ‘’ğ‘
/* A map to store (address, instruction) pairs */
1ğ‘ğ‘‘ğ‘‘ğ‘Ÿ.initial()
2ğ¸ğ‘¥ğ‘’ğ‘.run(ğ‘)
3ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘ = receiveInstrumentedAddrs()
4ğ‘¢ğ‘›ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘‘ğ´ğ‘‘ğ‘‘ğ‘Ÿğ‘  =ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘ 
/* Inject breakpoints into child process */
5foreachğ‘ğ‘‘ğ‘‘ğ‘Ÿinğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘ do
6ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘Ÿ= readInstrFromAddr( ğ‘ğ‘‘ğ‘‘ğ‘Ÿ)
7ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘€ğ‘ğ‘ .insert(ğ‘ğ‘‘ğ‘‘ğ‘Ÿ,ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘Ÿ)
8writeInstrIntoAddr(0 ğ‘¥ğ‘ğ‘,ğ‘ğ‘‘ğ‘‘ğ‘Ÿ)
9end
10async event loop
11ifreceive SIGTRAP from child process then
12 readSeedAndStore()
/* Recover the instruction */
13 ğ‘ğ‘‘ğ‘‘ğ‘Ÿ= readRip()
14 ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘Ÿ=ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘€ğ‘ğ‘ .get(ğ‘ğ‘‘ğ‘‘ğ‘Ÿ)
15 writeInstrIntoAddr( ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘Ÿ,ğ‘ğ‘‘ğ‘‘ğ‘Ÿ)
16 ğ‘¢ğ‘›ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘‘ğ´ğ‘‘ğ‘‘ğ‘Ÿğ‘  =ğ‘¢ğ‘›ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘‘ğ´ğ‘‘ğ‘‘ğ‘Ÿğ‘  âˆ’{ğ‘ğ‘‘ğ‘‘ğ‘Ÿ}
17 ğ¸ğ‘¥ğ‘’ğ‘.resume()
18end
19end
Withintheself-modifyingtracing,wemaintainasetofinstru-
mentation points which have never been visited ( unvisitedAddrs
in Algorithm 1) during fuzzing process. The set will tend to be
anemptysetasthefuzzerexplorestargetprogramâ€™sstatesmore
deeply. Once a instrumentation point is visited, it will be removed
and never be collected again. Besides, the self-modifying tracingdoes not introduce new overhead during fuzzing process. There-
fore,alongwiththefuzzingprocess,itcantheoreticallyeliminate
coverage collection overhead almost down to zero.
4.2 Binary-switching Scheduling
Section3revealsthattheefficiencyofeachcoveragegranularity
varieswithtargetprograms.Inspiredbythis,webelievethatswitch-
ing among diversely-instrumented binaries during fuzzing process
will improve fuzzing performance. However, estimating efficien-
cies of diversely-instrumented binaries is challenging, because: (1)
program-dependentefficiency :theefficiencyofeachbinaryvaries
with target programs, thus we cannot share one static set of pa-
rameters configuration among different programs; (2) time-varying
efficiency : even for testing one target program, the efficiency of
eachcoveragegranularitychangesovertimeasthefuzzerexplores
target programâ€™s states more deeply; (3) cost-effective solution : the
solution should be cost-effective and less-frequent due to the high
throughput of fuzzing.We propose a real-time scheduling mechanism to address above
problems. In short, it adaptively switches fuzzing binary amongdiversely-instrumented binaries at set intervals. During fuzzingprocess, it collects statistical data (i.e. the number of interestingseeds, the number of executions and the time spent on fuzzing),
dynamically monitors the number of interesting seeds each binary
coulddiscover,andchooseanoptimalbinaryasfuzzingtargetwhen
theswitchtimeisup.WeleverageempiricalBayesianmethodtoestimateefficiencyinacost-effectivewayandadoptexponential
smoothing to smooth the time-varying efficiency.
Estimateefficiency .Tosimplifythetime-varyingproblem,we
discretize continuous time into time periods and assume efficiency
is invariant at each time period. For a binary, the efficiency at time
periodğ‘¡is defined as
ğ‘’ğ‘¡=ğ¼ğ‘¡
ğ‘‡ğ‘¡
=ğ¼ğ‘¡
ğ‘€ğ‘¡âˆ—ğ‘€ğ‘¡
ğ‘‡ğ‘¡=ğ‘Ÿğ‘¡âˆ—ğ‘ (1)
whereğ¼ğ‘¡denotesthenumberofdiscoveredinterestingseedsduring
the timeperiod ğ‘¡,ğ‘‡ğ‘¡denotes thetime spent onfuzzing during the
timeperiod ğ‘¡,ğ‘€ğ‘¡denotesthenumberofexecutionsduringthetime
periodğ‘¡,ğ‘Ÿğ‘¡denotes the quotient of ğ¼ğ‘¡andğ‘€ğ‘¡(namely, interesting-
testcasesrate, ITR),andğ‘ denotesexecutionspeedwhichcanbe
seen as a constant with respect to binary. Given a binaryâ€™s statisti-
caldata[ğ¼1,ğ¼2,Â·Â·Â·,ğ¼ğ‘¡],[ğ‘‡1,ğ‘‡2,Â·Â·Â·,ğ‘‡ğ‘¡]and[ğ‘€1,ğ‘€2,Â·Â·Â·,ğ‘€ğ‘¡]before
currenttimeperiod ğ‘¡,weaimtoestimateITRs Ë†ğ‘Ÿğ‘¡,andfurthercal-
culate the estimation of efficiency Ë†ğ‘’ğ‘¡of the binary at current time
periodğ‘¡through equation (1).
WithempiricalBayesianmethods,theintegralsoverconditional
probability distributions are substituted by the empirical statistics
in the observed data, which allows us to estimate the posteriorprobabilities, e.g. a binaryâ€™s ITRs, by leveraging the information
fromitsstatisticaldata.Foreachbinary,thereisanunderlyingprob-
abilitydistributionofITR,andateachtimeperiod ğ‘¡,thebinaryâ€™s
ITRğ‘Ÿğ‘¡could beregarded as a outcome ofthe distribution. We use
Betadistributiontoparameterizethegenerativeprocess,definedas
ğµğ‘’ğ‘¡ğ‘(ğ›¼,ğ›½). Besides, obviously, for each binary at time period ğ‘¡, the
numberofinterestingseeds ğ¼ğ‘¡obeystheBinomialdistributionwith
parameters ğ‘€ğ‘¡andğ‘Ÿğ‘¡.Thus,wehaveaBeta-Binomialcompound
distributionforthestatisticaldata.Thegenerativeprocessofour
Bayesian model is described as follows:
â€¢Sampleğ‘Ÿâˆ¼ğµğ‘’ğ‘¡ğ‘(ğ›¼,ğ›½),ğ‘(ğ‘Ÿ|ğ›¼,ğ›½)âˆÎ“(ğ›¼+ğ›½)
Î“(ğ›¼)Î“(ğ›½)ğ‘Ÿğ›¼âˆ’1(1âˆ’ğ‘Ÿ)ğ›½âˆ’1
â€¢Sampleğ¼âˆ¼ğµğ‘–ğ‘›ğ‘œğ‘šğ‘–ğ‘ğ‘™ (ğ‘€,ğ‘Ÿ),ğ‘(ğ¼|ğ‘€,ğ‘Ÿ)âˆğ‘Ÿğ¼(1âˆ’ğ‘Ÿ)ğ‘€âˆ’ğ¼
where Î“is Gamma function. Therefore, the likelihood over all
number of interesting seeds is:
ğ¿=ğ‘(ğ¼1,ğ¼2,Â·Â·Â·,ğ¼ğ‘¡|ğ‘€1,ğ‘€2,Â·Â·Â·,ğ‘€ğ‘¡,ğ›¼,ğ›½)
=ğ‘¡/productdisplay.1
ğ‘–=1âˆ«
ğ‘Ÿğ‘–ğ‘(ğ¼ğ‘–|ğ‘€ğ‘–,ğ‘Ÿğ‘–)ğ‘(ğ‘Ÿğ‘–|ğ›¼,ğ›½)ğ‘‘ğ‘Ÿğ‘–
âˆğ‘¡/productdisplay.1
ğ‘–=1âˆ«
ğ‘Ÿğ‘–Î“(ğ›¼+ğ›½)
Î“(ğ›¼)Î“(ğ›½)ğ‘Ÿğ¼ğ‘–
ğ‘–(1âˆ’ğ‘Ÿğ‘–)ğ‘€ğ‘–âˆ’ğ¼ğ‘–ğ‘Ÿğ›¼âˆ’1
ğ‘–(1âˆ’ğ‘Ÿğ‘–)ğ›½âˆ’1ğ‘‘ğ‘Ÿğ‘–
=ğ‘¡/productdisplay.1
ğ‘–=1Î“(ğ›¼+ğ›½)
Î“(ğ‘€ğ‘–+ğ›¼+ğ›½)Î“(ğ¼ğ‘–+ğ›¼)
Î“(ğ›¼)Î“(ğ‘€ğ‘–âˆ’ğ¼ğ‘–+ğ›½)
Î“(ğ›½)(2)
863Then,themaximumlikelihoodcanbecalculatedthroughthefix-
point iteration (FPI) [38, 50]:
ğ›¼ğ‘¥+1=ğ›¼ğ‘¥/summationtext.1ğ‘¡
ğ‘–=1[Î¨(ğ¼ğ‘–+ğ›¼ğ‘¥)âˆ’Î¨(ğ›¼ğ‘¥)]
/summationtext.1ğ‘¡
ğ‘–=1[Î¨(ğ‘€ğ‘–+ğ›¼ğ‘¥+ğ›½ğ‘¥)âˆ’Î¨(ğ›¼ğ‘¥+ğ›½ğ‘¥)]
ğ›½ğ‘¥+1=ğ›½ğ‘¥/summationtext.1ğ‘¡
ğ‘–=1[Î¨(ğ‘€ğ‘–âˆ’ğ¼ğ‘–+ğ›½ğ‘¥)âˆ’Î¨(ğ›½ğ‘¥)]
/summationtext.1ğ‘¡
ğ‘–=1[Î¨(ğ‘€ğ‘–+ğ›¼ğ‘¥+ğ›½ğ‘¥)âˆ’Î¨(ğ›¼ğ‘¥+ğ›½ğ‘¥)](3)
where Î¨(ğ‘¥)isthedigammafunction,andcanbequicklycalculated
through Bernardoâ€™s algorithm [4].
With equation (3), theË†ğ›¼andË†ğ›½could be iteratively estimated,
furthermore, the posterior estimation of current time periodâ€™s ITR
could be calculated as Ë†ğ‘Ÿğ‘¡=ğ¼ğ‘¡+Ë†ğ›¼
ğ‘€ğ‘¡+Ë†ğ›¼+Ë†ğ›½. To accelerate the convergence
speed of the iteration method, we use method of moments [ 20]
to calculate the initial values Ë†ğ›¼0andË†ğ›½0. Besides, to smooth time-
varying observed data, we leverage exponential smoothing [ 15]t o
calculate the smoothed number of interesting seeds:
ğ¼ğ‘–=/braceleftbiggğ¼/prime
ğ‘–ğ‘–=1
ğ›¾ğ¼/prime
ğ‘–+(1âˆ’ğ›¾)ğ¼ğ‘–âˆ’1ğ‘–>1(4)
whereğ¼/prime
ğ‘–is the observed number of interesting seeds, ğ¼ğ‘–is the
smoothednumberofinterestingseedswhichisusedinequation (3),
ğ›¾âˆˆ(0,1)is the smoothing factor. As time passes the smoothed
ğ¼ğ‘–becomes the exponentially decreasing weighted average of its
past observations, in this way, we can capture time relationship
between ITRs.
OncetheposteriorestimationofITR Ë†ğ‘Ÿğ‘¡ofthebinaryisestimated,
the estimation of efficiency Ë†ğ‘’ğ‘¡could be calculated through equa-
tion(1). Thus, at current time period ğ‘¡, we can estimate efficiencies
of every diversely-instrumented binaries [ğ‘’1
ğ‘¡,ğ‘’2
ğ‘¡,Â·Â·Â·,ğ‘’ğ‘˜
ğ‘¡], and form
a probability distribution by normalizing these efficiencies:
ğ‘(ğ‘‹=ğ‘–)=ğ‘’ğ‘–
ğ‘¡/summationtext.1ğ‘˜
ğ‘—=1ğ‘’ğ‘—
ğ‘¡(5)
whereğ‘’ğ‘—
ğ‘¡denotes the efficiency of binary ğ‘—. When the time to
switch, we can select the target binary for fuzzing according to the
probability distribution.
Switch among binaries . Based on the efficiency estimation,
we can implement the binary-switching scheduler, as detailed in
Algorithm2.First,aspresentedinlines1-3,theschedulerrandomly
choosesseveral(inlinewiththeconfigurations)binariesandper-
forms fuzzing on these binaries through executor. For each binary,
theexecutorwill forkachildprocesstotestthem,whichissimi-
lartoAFLâ€™sforkserver[ 26].Then,theschedulerasynchronously
listensevents fromexecutorand timer.Executor willperiodically
reportstatistics(numberofexecutions,numberofinterestingseeds,
timespentonfuzzingduringthetimeperiod),andschedulerwill
record these statistics when receive them from executor as pre-
sented in lines 5-8. As presented in lines 10-18, when it is timeto switch binary, the executor will stop its child processes, and
then,theschedulerwillcalculatetheposteriorestimationofeach
binaryâ€™s ITR and choose optimal binaries for fuzzing according to
theprobabilitydistributionofequation (5).Notethat,thescheduler
supports not only running in single mode (i.e. single-core fuzzing)
butalso runninginparallelmode (i.e.multi-coresfuzzing), which
is more common in real industrial practice [31, 33].Algorithm 2: Action of binary-switching scheduler
Input :List of diversely-instrumented binaries ğµ
Executorğ¸ğ‘¥ğ‘’ğ‘
Configurations ğ¶
1ğ‘ ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘Ÿ .initial(ğµ)
2ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡ğ‘ =ğ‘ ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘Ÿ .chooseRandom( ğ¶.numCores)
3ğ¸ğ‘¥ğ‘’ğ‘.run(ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡ğ‘ );
4async event loop
5ifreceive statistics from executor then
6ğ‘ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘¦,ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘ ğ‘¡ğ‘–ğ‘ğ‘  =ğ¸ğ‘¥ğ‘’ğ‘.read()
7ğ‘ ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘Ÿ .record(ğ‘ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘¦,ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘ ğ‘¡ğ‘–ğ‘ğ‘  )
8end
9iftime to switch binary then
10 ğ¸ğ‘¥ğ‘’ğ‘.stop()
11 foreachğ‘inğµdo
/* calculate the posterior estimation
of the binaryâ€™s ITR */
12 ğ›¼0,ğ›½0=ğ‘ ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘Ÿ .calByMoment( ğ‘)
13 ğ›¼,ğ›½=ğ‘ ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘Ÿ .calByFPI( ğ‘,ğ›¼0,ğ›½0)
14 ğ‘Ÿ= betaExpectation( ğ›¼,ğ›½)
15 ğ‘ ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘Ÿ .update(ğ‘,ğ‘Ÿ)
16 end
17 ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡ğ‘ =ğ‘ ğ‘â„ğ‘’ğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘Ÿ .chooseOptimal( ğ¶.numCores)
18 ğ¸ğ‘¥ğ‘’ğ‘.run(ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡ğ‘ );
19end
20end
5 EVALUATION
Weimplementedtheframework Zeror.Theinstrumentationmech-
anisminself-modifyingtracingisimplementedonthetopofLLVM
10.0.0 [48]. TheRecord&Clear procedure is implemented in the ini-
tialization of llvm::MachineModuleInfo and theEmit addresses
procedure is implemented in the EmitBasicBlockStart method
ofllvm::AsmPrinter . We create a global variable to record the
mappingofMBBSymbol( MCSymbol* type)andMBBid( uint32_t
type). The runtime logic of monitoring status of process and mod-
ifying instructions of memory in self-modifying tracing is based
onptrace.Forscalability,theschedulercomponentcontainsthe
self-modifyingbasedzero-overheadbinaryandtheoriginalfully
instrumented binary of the integrated fuzzers such as AFL and
MOPT. The interval of switching binaries and reporting statistical
dataaresetto600sand60srespectively,whichbarelyintroduces
new overhead and brings best performance after multiple attempts
withdifferentvalues.InspiredbytheAFLpersistentmode[ 26],our
frameworksetsupathreadwhichrunsa ptracetasktomonitor
thestatus ofchild process.Once thechild processtriggersa crash
orexceedstimeoutlimit,thethreadwillterminateandre-spawn
the child process.
We evaluated Zerorin three aspects. First, we applied Zeror
to AFL and compared the performance with two state-of-the-art
fuzzingspeed up frameworks, Untracer [ 39] and INSTRIM [ 22], to
assess the efficiency. Then, we generalized Zerorto MOPT [ 36], a
864Table 2: Fuzzing performances of differ entAFL-basedfuzzing-speed-upmethods.
Projectaverage execution time for each test case ( ğœ‡ğ‘ ) number of covered branches
AFL AFL+INSTRIM AFL+Untracer AFL+Zeror AFL AFL+INSTRIM AFL+Untracer AFL+Zeror
boringssl 96.69 69.68 N/A 33.05 2661 2694 N/A 2549
c-ares 43.34 25.42 13.95 16.32 57 57 55 57
freetype2 44.68 25.17 25.13 20.33 8255 9268 7007 10059
guetzli 99.92 67.98 45.80 41.00 4757 4845 4748 4987
harfbuzz 149.82 80.36 66.06 55.73 8148 8048 7195 9168
json 145.82 100.03 64.33 98.39 1315 1333 1152 1346
lcms 97.71 70.92 44.18 63.96 2115 2244 1436 2077
libarchive 193.44 112.50 112.90 112.72 1208 1119 1082 1618
libjpeg 1469.47 668.96 261.30 337.36 2364 2564 2399 2857
libpng 15.34 5.48 5.27 7.54 1092 1096 1029 1140
libssh 638.00 340.52 309.62 309.29 867 867 867 867
libxml2 268.07 135.05 N/A 88.13 4063 4318 N/A 4745
llvm-libcxxabi 137.61 81.61 43.75 42.04 6488 6005 6000 7012
openssl-1.0.1f 3418.66 1998.27 N/A 1948.43 4748 6745 N/A 7372
openssl-1.0.2d 161.09 92.48 N/A 63.23 1825 1828 N/A 1769
openssl-1.1.0c 210.70 89.74 N/A 50.60 1712 1711 N/A 1658
openthread 145.51 91.17 64.80 85.16 3561 3537 3279 3591
pcre2 199.12 102.21 53.86 49.11 6890 6888 6597 6890
proj4 23.22 14.24 8.47 7.86 2541 2584 2347 3886
re2 640.24 391.97 260.19 235.40 4608 4647 4533 4725
sqlite 221.18 160.84 136.01 141.40 1892 1997 1986 1972
vorbis 96.14 58.08 36.45 25.48 2035 2152 1817 2079
woff2 31.55 20.12 11.80 8.67 2119 2152 1453 2157
wpantund 1921.02 2019.62 1544.89 1789.23 7959 7892 7802 8781
Zerorimprovement +159.80% +50.70% -0.46% +10.14% +6.82% +20.84%
Table 3: Time to expose known bugs, âˆdenotes the fuzzer
cannot expose the known bugs in 6 hours and the projects
whosebugscannotbetriggeredbyanyfuzzerareremoved.
Project AFL AFL+INSTRIM AFL+Untracer AFL+Zeror
c-ares 8 26 842 8
guetzli âˆâˆ 16257 6001
json 55 5 5
lcms 20679 âˆ 11827 10953
llvm-libcxxabi 788 2197 2347 709
openssl-1.0.1f 19 19 âˆ 21
openssl-1.0.2d 8716 6877 âˆ 6013
pcre2 822 1375 6095 439
re2 âˆâˆ âˆ 8194
woff2 3565 1535 âˆ 3260
state-of-the-artfuzzer,tostudythescalability.Finally,weevaluated
the effectiveness of each component of Zeror.
5.1 Experiment Settings
Torevealthepracticalperformanceof Zeror,theevaluationwas
conductedonfuzzer-test-suite[ 17],awidely-usedbenchmarkfrom
Google.Thistestsuiteconsistsof24popularreal-worldapplications
which have interesting known vulnerabilities, hard-to-find code
paths, orother challengesfor bugfinding tools. The initialseeds
were collected from the built-in test suite and each source code
inside the test suite was compiled with -O2flag. To reduce the
side effect caused by AFLâ€™s file I/O overhead [ 51], all fuzzers were
running in tmpfs. All experiments were performed on a 64-bit
machinewith40cores(Intel(R)Xeon(R)Gold6148CPU@2.40GHz),
128 GiB of RAM and Linux 5.5.13. Due to the random effects in
fuzzing,weconductedeachexperimentsforsixhoursandrepeated
it ten times. And we reported average performance.
Intermsofmetrics,weevaluatetheperformanceoffuzzersin
three aspects, namely execution time, branch coverage and timeto expose known bugs. The execution time is the average time the
LLVMFuzzerTestOneInput function consumed. Different fuzzers
areguidedbydifferentcoveragegranularity,forfaircomparison,
wecollecttheirgeneratedseeds,feedtheseedstooriginalAFLand
gather the number of covered branches through AFL BITMAP. The
time to expose known bugs is the time consumed by the fuzzer to
trigger the first crash.
5.2 Efficiency of Zeror
We applied Zerorto AFL (namely AFL+Zeror) by switching be-
tween AFL-instrumented binary and self-modifying tracing instru-
mented binary based on binary-switching scheduler. We evaluated
it on all the 24 programs of Google fuzzer-test-suite and compared
it with two state-of-the-art fuzzing speed-up techniques, INSTRIM
and Untracer. Specifically, for the baseline AFL, the version usedis 2.52b and the compilation tool chain is
afl-clang-fast [26],
whichisthemostefficientinstrumentationmethodthatAFLpro-
vide; for INSTRIM, we activate INSTRIM-APPROX mode, which
shows best performance in their evaluations [22].
TheresultsarepresentedinTable2andTable3.The2-5columns
of Table2 show theaverage execution timeper testcase and the
Zerorimprovementinthelastrowreferstotheexecutionspeed
increase. The 6-9 columns of Table 2 show the number of branches
covered by each fuzzer and the Zerorimprovement in the last
row refers to branch increase. Table 3 shows the time taken by
each fuzzerto exposeknownbugs, theprojects whosebugs cannot
be triggered by all the fuzzers in 6 hours are removed from the
table.Notethat,duetothelimitationofDyninst[ 13],Untraceris
incompatiblewithsomeprojects(including boringssl ,libxml2,
openssl-1.0.1f ,boringssl-1.0.2d andopenssl-1.1.0c ), we
denote the corresponding table cell as N/A. From the two tables,
we can deduct the following conclusions:
865â€¢ZerorincreasestheexecutionspeedofAFL.InTable2,theav-
erage execution time of AFL+Zeror is less than AFL for every
benchmarkprojects.Specificallyfor libjpeg,theaverageexe-
cutiontimeofAFLandAFL+Zerorare1469.47 ğœ‡ğ‘ and337.36 ğœ‡ğ‘ 
respectively, which indicates that Zerorincreases the execu-
tion speed of AFL by 335.58%. Averagely, Zerorincreases the
executionspeed of AFL by 159.80%.
â€¢ZerorhelpsAFLcovermorebranches.InTable2,AFL+Zerorout-
performs AFL on 17 out of 24 projects. Specially, AFL+Zeror im-
provesthenumberofcoveredbranchesby55.27%on openssl-1.
0.1fand33.94%on libarchive .Averagely,AFL+Zerorincreases
the number of covered branches of AFL by 10.14%.
â€¢ZerorhelpsAFLexposebugsfaster.InTable3,AFL+Zerorex-
posesknownbugsfasterthanoriginalAFLon8outof10projects.
Specially, AFL+Zeror is 1.87x faster than AFL in term of trigger-
ing the bug in pcre2, and exposes the bugs of re2andguetzli,
which cannot be exposed by original AFL in 6 hours.
â€¢Zerorshows better performances compared with other fuzzing
speed-up techniques. Compared with INSTRIM, Zeroris av-
eragely 50.70% faster for each execution, covers 6.82% morebranches and spends less time on bugs exposure. Compared
with Untracer,
Zerorcovers 20.84% more branches averagely
and spends less time on bugs exposure. Because of the real-time
scheduling, Zerorisaveragely0.46%slowerthanUntracer,which
is almost negligible.
Figure 6: The number of covered branches over time whenfuzzing harfbuzz. The x-axis is on a logarithmic scale.
Case study
. Figure 6 visualizes the real-time change of covered
brancheson harfbuzz whendifferentfuzzingspeed-upmethods
areappliedonAFL.WecanobservethatAFL+Zerorcoversmore
branches than all the other methods most of the time. Specifically,
AFL+Zerortakes211secondstoachievealmostthesamenumberof
covered branches as AFL and INSTRIM take 214seconds. Untracer
coverslessbranchesmostofthetimecomparedwithothermethods,
even compared to the original AFL. As demonstrated in Table 2,
Untraceristhefastestfortestcaseexecution,butwhenitdeletes
almost all the instrumentation points, it will also lose the fine-grained coverage information such as hit count of branches forfuzzingguidance,and willgreatly reducethe numberofcovered
branches.INSTRIMmakesAFLfaster,butnotasfastasUntracerand
Zeror,anditreconstructsthecoverageinformationforguidance
with instrumenting a part of basic blocks, to partially maintain the
ability to cover more branches.Fromtheabovestatistics,itisreasonabletodrawtheconclusion
that:withtheaidof Zeror,fuzzersareabletogainhigherspeedup,
covers more branches, and exposes bugs faster. In addition, Zeror
showsbetterperformanceofcoverageincreaseandvulnerability
discoverycomparedwithotherfuzzingspeed-uptechniques.
5.3 Scalability of Zeror
In addition to AFL, we also generalize our experiments to another
state-of-the-artfuzzer,MOPT[ 36],tostudythescalabilityof Zeror.
MOPTisafuzzerthatimprovesfuzzingperformancebyoptimizing
the efficiency of mutation strategy. We applied Zerorto MOPT
(namely MOPT+Zeror) in the same way as AFL+Zeror and eval-
uated it on all the 24 programs of Google fuzzer-test-suite. The
resultsareshowninFigure7andTable4.FromFigure7wecanob-
serve that MOPT+Zeror improves the number of covered branchesin 17 out of 24 projects and averagely increases the number of cov-
ered branches by 6.91% compared with the original MOPT. Specifi-
cally, MOPT+Zeror improves the number by 64.95% on proj4and
40.45%on libarchive .Table4showsthetimetakenbyMOPTand
MOPT+Zeror to expose known bugs, those projects whose bugs
cannot be triggered by them in 6 hours are removed from the table.
From Table 4 we can observe that with the aid of Zeror, MOPT
exposes known bugs faster. Specially , Zeror improv esthe speedof
bug exposure by 2.39x on llvm-libcxxabi, 2.01x on pcre2.
Figure 7: Relative covered branches improvement ofMOPT+Zeror compared with MOPT.
Table4:Timetoexposeknownbugs,andtheprojectswhose
bugs cannot be triggered by them in 6 hours are removed.
Project MOPT MOPT+Zeror
c-ares 88
json 55
llvm-libcxxabi 1818 761
openssl-1.0.1f 31 21
openssl-1.0.2d 1633 1320
pcre2 1944 968
woff2 3767 3196
Insummary, Zerorisapplicabletootherfuzzingoptimizations
like MOPT, and more importantly, Zerorcan further improve
fuzzing vulnerability discovery performance on top of them. Al-though we only use MOPT for illustration in the experiment, it
866can be easily applied to other fuzzers such as AFLFast [ 5] and
FairFuzz [28].
5.4 Evaluation of Individual Components
Zerorconsists of two main mechanisms: self-modifying tracing
and real-time scheduling. To analyze the effects of each individual
mechanism, we configure two variants of our framework:
â€¢Zeror-representsthefuzzerwhichadoptsAFLasseedsgenerator
and only integrates self-modifying tracing mechanism.
â€¢ZerorrepresentsthefuzzerwhichadoptsAFLasseedsgenerator.
Besides,itintegratesself-modifyingtracingandAFLâ€™sinstrumen-
tation to collect coverage, and dynamically switches between
thetwoinstrumentedbinariesduringfuzzingprocessbasedon
real-time scheduling mechanism.
Evaluation of self-modifying tracing . Since Untracer [ 39]
shares the similar idea with our self-modifying tracing compo-
nent, we evaluate our tracing by comparison with Untracer, us-ing 19 projects of fuzzer-test-suite (Untracer is incompatible tothe rest 5 projects). For speed improvement, both methods elimi-
natethecoverage-collectingtimeofnon-coverage-increasingtest
cases by erasing visited instrumentation points, but with differ-ent approaches. Figure 8a shows that, when considering erasinginstrumentationpoints,self-modifyingtracingsavesmuchmore
time than Untracer on the average time consumed. Averagely, self-
modifyingtracingis13.74xfasterthanUntracerwhenerasingin-
strumentation points. The saved coverage tracing time can be used
for efficient binary-switch scheduling. Additionally, self-modifying
tracingisedge-awarewhileUntracerisbasic-block-aware.Figure8bshowstherelativecoveredbranchesimprovementofself-modifying
tracing,fromwhichwecanconcludethatself-modifyingtracing
mechanismhelpsfuzzercovermorebranchescomparedwithUn-
tracer. Specifically, self-modifying tracing improves the branchcoverage by 56.92% on
proj4, 48.43% on libarchive , 43.80% on
lcms, 42.90% on freetype2.
Evaluation of real-time scheduling . Our scheduling mech-
anism integrates two binaries: the zero-overhead binary instru-mented by self-modifying tracing and the original binary instru-mented by the integrated fuzzer, and then dynamically switches
between them. To study the effectiveness of the scheduler, we com-
pareZerorwithZeror-and AFL. The overall result is consistent
toTable2, andforpagelimitation,weonlyvisualize2projectsto
demonstratethecoverageincreaseprocessofdifferentconfigura-
tions in Figure 9. Both Zeror-andZerorcover more branches than
AFL,and Zeroroutperforms Zeror-.Thevisualizationindicatesthat
integrating twodifferent instrumentedbinaries withthe real-time
scheduling helps fuzzers achieve better performance.
5.5 Discussion
Although binary-switching scheduler is able to integrate multi-
plediversely-instrumentedbinaries,weapplied Zerortofuzzers
byswitching onlybetweenoriginal instrumentedbinaryand self-
modifying tracing instrumented binary in our evaluation, which
couldnotfullyexcavate Zerorâ€™spotentiality,butalreadydemon-
strates the effectiveness of tracing and scheduling. Furthermore,
evenwiththeschedulingoftwobinaries,itimprovesbothspeed(a) Average time taken for different methods to erase instrumen-
tation points (lower is better).
(b) Relative covered branches improvement of Zeror- compared
with Untracer.
Figure 8: Comparison between Zeror- and Untracer.
(a) libjpeg (b) harfbuzz
Figure9:Branchescoveredovertimewithdifferentconfigu-rations. The x-axis is on a logarithmic scale.
and coverage. Recently, Dinesh [ 12] proposed a novel approach of
instrumentation, we plan to integrate it in the future.
(a) Number of covered branches
over time.(b) Chosen probabilities of dif-
ferent binaries over time.
Figure 10: Case study on sqlite of AFL-Zeror.
867Anotherpotentialconcerniswhethertheschedulingmechanism
canhelpfuzzershiftintoproperbinary.Figure10isthereal-time
visualizationofcoveredbranchesandthechosenprobabilitiesof
diversely-instrumented binaries when AFL+Zeror is applied to test
sqlite.Wecanobservethatthechosenprobabilityofthebinary
instrumented by AFL is in decline when the number of covered
branchesreachestheplateauatthetimeof30min-60min,and Zeror
hashighprobabilitytoshiftintothefasterbinary(instrumentedby
self-modifying tracing) when the AFL-instrumented binary cannot
makeanyprocess.Theobservationindicatesthatthescheduling
scheme do help fuzzer properly choose binary for execution. How-
ever, the scheduling scheme only collects execution statistical data,
whichmaynotbesufficientenoughtofullydisplayitsefficiency.
It could be further improved by gaining more information from
data-flow analysis and control-flow analysis.
6 RELATED WORKS
Optimize fuzzing strategies . Existing optimizations of fuzzing
resideindifferentstages.Forthepreparationstage,CollAFL[ 14]
provides a solution to collect coverage feedback without bitmap
collision,DeepFuzzer[ 32]leveragessymbolicexecutiontogener-
ate qualified initial seeds. For the seed selection stage, AFLFast [ 5]
givesmoremutationtimestovaluableseedswhichexerciselow-
frequency paths, Cerebro [ 29] prioritizes seeds in corpus on the
basis of static analysis and dynamic scoring. For the seed mutation
stage, FairFuzz [ 28] mutates input seeds in a restricted way so that
theyaremorelikelytostillexploretherarestbranch,MOPT[ 36]
findstheoptimalselectionprobabilitydistributionofoperatorswith
respect to fuzzing effectiveness. Specially, a number of seed muta-
tionoptimizationsleveragetaint analysissuchasREDQUEEN[ 2],
Angora[7]andMatryoshka[ 8].REDQUEEN[ 2]usesalightweight
input-to-state correspondence mechanisms as an alternative todata-flow analysis, Angora [
7] adopts byte-level taint analysis
andagradient-descentalgorithmforconstraintpenetration,Ma-tryoshka [
8] identifies nesting conditional statements by control
flow and taint flow and proposed three strategies for mutating the
input to solve path constraints.
Boostfuzzingspeed .Xuetal.[51]designthreenewoperating
primitives to solve the performance bottlenecks of parallel fuzzing
on multi-core machines. INSTRIM [ 22] reduces instrumentation
cost by selectively instrumenting a part of basic blocks and re-constructing coverage information. Untracer [
39] avoids tracing
coverageofnon-coverage-increasingtestcasesbyremovingvisited
instrumentation points.
Main differences . Optimizations of fuzzing strategies are or-
thogonalto Zeror,andmostofthemcouldalsobenefitfrom Zeror.
For example, the experiment results show that, with the aid of
Zeror,MOPTachievesbetterperformanceofcoverageexploration
and vulnerability discovery. Different from INSTRIM and Untracer,
our study aims to boost fuzzing speedwhilepr eserve fine-grained
coverage collection. Although Untracer has a similar idea withour self-modifying tracing component, rather than static binary
rewriting, our tracing relies on self-modifying code to erase visited
instrumentation points, which barely introduces new overheads
andprovidesmorefine-grainedcoveragecollection.Withthenovel
binary-switching scheduler, more improvements can be achieved.7 CONCLUSION
In thispaper, we propose acoverage-sensitive fuzzing framework
Zeror, which integrates diversely-instrumented binaries toboost
fuzzing speed and further improve the vulnerability discovery.
Zeroris mainly made up of two parts: (1) a self-modifying tracing
mechanism to provide a zero-overhead instrumentation for cover-
age collection; and (2) a real-time scheduling mechanism to select
theproperinstrumentedbinaryforfuzzingonthebasisofempirical
Bayesian inference. In the experiments of fuzzing projects from
Googlefuzzer-test-suite,resultsshowthatwiththeaidof Zeror,
fuzzers are able to gainhigher speedup, cover more branches, and
more importantly, expose bugs faster than the existing speed-up
techniques. It can be applied to most of the existing fuzzers. In our
future work, we plan to complement Zerorwith other orthogonal
fuzzing optimizations.
8 ACKNOWLEDGEMENT
ThisresearchissponsoredinpartbyNationalKeyResearchandDe-
velopmentProject(GrantNo.2019YFB1706200),theNSFCProgram
(No.U1911401,61802223),theHuawei-TsinghuaTrustworthyRe-
search Project (No. 20192000794), and the Equipment Pre-research
Project (No. 61400010107).
REFERENCES
[1]CorneliusAschermann,SergejSchumilo,AliAbbasi,andThorstenHolz.2020.
IJON: Exploring Deep State Spaces via Fuzzing. In 2020 IEEE Symposium on
Security and Privacy (SP). IEEE, 1597â€“1612.
[2]Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik, and
Thorsten Holz. 2019. REDQUEEN: Fuzzing with Input-to-State Correspondence.
In26th Annual Network and Distributed System Security Symposium, NDSS 2019,
San Diego, California, USA, February 24-27, 2019. https://www.ndss-symposium.
org/ndss-paper/redqueen-fuzzing-with-input-to-state-correspondence/
[3]Vasanth Bala, Evelyn Duesterwald, and Sanjeev Banerjia. 2000. Dynamo: a
transparent dynamic optimization system. In Proceedings of the 2000 ACM
SIGPLAN Conference on Programming Language Design and Implementation
(PLDI), Vancouver, Britith Columbia, Canada, June 18-21, 2000. 1â€“12. https:
//doi.org/10.1145/349299.349303
[4]Jose MBernardo.1976. Algorithm AS103: Psi (digamma) function. Journal of
the Royal Statistical Society. Series C (Applied Statistics) 25, 3 (1976), 315â€“317.
[5]Marcel BÃ¶hme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
basedGreyboxFuzzingasMarkovChain.In Proceedingsofthe2016ACMSIGSAC
ConferenceonComputerandCommunicationsSecurity,Vienna,Austria,October
24-28, 2016. 1032â€“1043. https://doi.org/10.1145/2976749.2978428
[6]Sang Kil Cha, Maverick Woo, and David Brumley. 2015. Program-AdaptiveMutational Fuzzing. In 2015 IEEE Symposium on Security and Privacy, SP 2015,
San Jose, CA, USA, May 17-21, 2015. 725â€“741. https://doi.org/10.1109/SP.2015.50
[7]PengChenandHaoChen.2018.Angora:EfficientFuzzingbyPrincipledSearch.In2018IEEESymposiumonSecurityandPrivacy,SP2018,Proceedings,21-23May2018,
San Francisco, California, USA. 711â€“725. https://doi.org/10.1109/SP.2018.00046
[8]Peng Chen, Jianzhong Liu, and Hao Chen. 2019. Matryoshka: Fuzzing Deeply
NestedBranches.In Proceedingsofthe2019ACMSIGSACConferenceonComputer
and Communications Security, CCS 2019, London, UK, November 11-15, 2019. 499â€“
513. https://doi.org/10.1145/3319535.3363225
[9]YuanliangChen,YuJiang,FuchenMa,JieLiang,MingzheWang,ChijinZhou,Xun
Jiao, and Zhuo Su. 2019. EnFuzz: Ensemble Fuzzing with Seed Synchronization
amongDiverseFuzzers.In 28thUSENIXSecuritySymposium,USENIXSecurity
2019, Santa Clara, CA, USA, August 14-16, 2019. 1967â€“1983. https://www.usenix.
org/conference/usenixsecurity19/presentation/chen-yuanliang
[10]Yuqi Chen, Christopher M. Poskitt, Jun Sun, Sridhar Adepu, and Fan Zhang.2019. Learning-Guided Network Fuzzing for Testing Cyber-Physical SystemDefences. In 34th IEEE/ACM International Conference on Automated Software
Engineering,ASE2019,SanDiego,CA,USA,November11-15,2019.962â€“973. https:
//doi.org/10.1109/ASE.2019.00093
[11]SaumyaK.DebrayandWilliamS.Evans.2002. Profile-GuidedCodeCompression.
InProceedingsofthe2002ACMSIGPLAN ConferenceonProgrammingLanguage
Design and Implementation (PLDI), Berlin, Germany, June 17-19, 2002. 95â€“105.
https://doi.org/10.1145/512529.512542
868[12]Sushant Dinesh. 2019. RetroWrite: Statically Instrumenting COTS Binaries for
FuzzingandSanitization. Ph.D.Dissertation.PurdueUniversityGraduateSchool.
[13]FoRTE-Research. 2020. Illegal pointer to buffer in Dyninst. https://github.com/
FoRTE-Research/UnTracer-AFL/issues/5
[14]ShuitaoGan,ChaoZhang,XiaojunQin,XuwenTu,KangLi,ZhongyuPei,and
Zuoning Chen. 2018. CollAFL: Path Sensitive Fuzzing. In 2018 IEEE Symposium
on Security and Privacy, SP 2018, Proceedings, 21-23 May 2018, San Francisco,
California, USA. 679â€“696. https://doi.org/10.1109/SP.2018.00040
[15]EveretteS Gardner Jr.1985. Exponential smoothing:The stateof theart. Journal
of forecasting 4, 1 (1985), 1â€“28.
[16]PatriceGodefroid,HilaPeleg,andRishabhSingh.2017. Learn&Fuzz:machine
learning for input fuzzing. In Proceedings of the 32nd IEEE/ACM International
ConferenceonAutomatedSoftwareEngineering,ASE2017,Urbana,IL,USA,October
30 - November 03, 2017. 50â€“59. https://doi.org/10.1109/ASE.2017.8115618
[17]Google.2020. Googlefuzzer-test-suite. https://github.com/google/fuzzer-test-
suite
[18]Google. 2020. OSS-Fuzz - continuous fuzzing of open source software. https:
//google.github.io/oss-fuzz/
[19]Google. 2020. SanitizerCoverage. https://clang.llvm.org/docs/SanitizerCoverage.
html
[20]Lars Peter Hansen. 1982. Large sample properties of generalized method of
moments estimators. Econometrica: Journal of the Econometric Society (1982),
1029â€“1054.
[21]honggfuzz@googlegroups.com.2020. hongfuzz-securityorientedfuzzer with
powerful analysis options. http://honggfuzz.com
[22]Chin-ChiaHsu,Che-YuWu,Hsu-ChunHsiao,andShih-KunHuang.2018.Instrim:
Lightweight instrumentation for coverage-guided fuzzing. In Symposium on
Network andDistributed SystemSecurity(NDSS), Workshop onBinaryAnalysis
Research.
[23]Intel. 2017. IntelProcessor TraceTools. https://software.intel.com/en-us/node/
721535
[24]YuichiroKanzaki,AkitoMonden,Masahide Nakamura,andKen-ichiMatsumoto.
2003. ExploitingSelf-ModificationMechanismforProgramProtection.In 27th
InternationalComputerSoftwareandApplicationsConference(COMPSAC2003):
DesignandAssessmentofTrustworthySoftware-BasedSystems,3-6November2003,Dallas,TX,USA,Proceedings.170. https://doi.org/10.1109/CMPSAC.2003.1245338
[25] lcamtuf. 2017. American Fuzzy Lop (AFL). http://lcamtuf.coredump.cx/afl/[26]
lcamtuf. 2017. Fast LLVM-based instrumentation for afl-fuzz. https://github.
com/google/AFL/blob/master/llvm_mode/README.llvm
[27]PeterLeeandMarkLeone.1996. OptimizingMLwithRun-TimeCodeGeneration.
InProceedings of the ACM SIGPLANâ€™96 Conference on Programming Language
DesignandImplementation(PLDI),Philadephia,Pennsylvania,USA,May21-24,
1996. 137â€“148. https://doi.org/10.1145/231379.231407
[28]Caroline Lemieux and Koushik Sen. 2018. FairFuzz: a targeted mutation strategy
forincreasinggreyboxfuzztestingcoverage.In Proceedingsofthe33rdACM/IEEE
InternationalConferenceonAutomatedSoftwareEngineering,ASE2018,Montpellier,
France, September 3-7, 2018. 475â€“485. https://doi.org/10.1145/3238147.3238176
[29]YuekangLi,YinxingXue,HongxuChen,XiuhengWu,CenZhang,XiaofeiXie,
HaijunWang,andYangLiu.2019. Cerebro:context-awareadaptivefuzzingfor
effectivevulnerabilitydetection.In Proceedingsofthe201927thACMJointMeeting
on European Software Engineering Conference and Symposium on the Foundations
of Software Engineering. 533â€“544. https://doi.org/10.1145/3338906.3338975
[30]JieLiang,YuanliangChen,MingzheWang,YuJiang,ZijiangYang,ChengnianSun,
Xun Jiao, and Jiaguang Sun. 2019. Engineering a Better Fuzzer with Synergically
Integrated Optimizations. In 30th IEEE International Symposium on Software
ReliabilityEngineering,ISSRE2019,Berlin,Germany,October28-31,2019.82â€“92.
https://doi.org/10.1109/ISSRE.2019.00018
[31]Jie Liang, Yu Jiang, Yuanliang Chen, Mingzhe Wang, Chijin Zhou, and Jiaguang
Sun. 2018. PAFL: extend fuzzing optimizations of single mode to industrial
parallelmode.In Proceedingsofthe2018ACMJointMeetingonEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering,ESEC/SIGSOFTFSE2018,LakeBuenaVista,FL,USA,November04-09,2018.809â€“814.
https://doi.org/10.1145/3236024.3275525
[32]Jie Liang, Yu Jiang, Mingzhe Wang, Xun Jiao, Yuanliang Chen, Houbing Song,
and Kim-Kwang RaymondChoo. 2019. DeepFuzzer:Accelerated Deep Greybox
Fuzzing. IEEE Transactions on Dependable and Secure Computing (2019).
[33]JieLiang,MingzheWang,YuanliangChen,YuJiang,andRenweiZhang.2018.
Fuzz testing in practice: Obstacles and solutions. In 25th International Conference
onSoftwareAnalysis,EvolutionandReengineering,SANER2018,Campobasso,Italy,March 20-23, 2018, Rocco Oliveto, Massimiliano Di Penta, and David C. Shepherd
(Eds.). IEEE Computer Society, 562â€“566. https://doi.org/10.1109/SANER.2018.
8330260
[34]libfuzzer@googlegroups.com. 2020. libFuzzer â€“ a library for coverage-guided
fuzz testing. https://llvm.org/docs/LibFuzzer.html
[35]Chi-Keung Luk, Robert S. Cohn, Robert Muth, Harish Patil, Artur Klauser, P. Ge-
offrey Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim M. Hazelwood.
2005. Pin: building customized program analysis tools with dynamic instrumen-
tation. In Proceedings of the ACM SIGPLAN 2005 Conference on ProgrammingLanguageDesignandImplementation,Chicago,IL,USA,June12-15,2005.190â€“200.
https://doi.org/10.1145/1065010.1065034
[36]ChenyangLyu,ShoulingJi,ChaoZhang,YuweiLi,Wei-HanLee,YuSong,and
RaheemBeyah.2019. MOPT:OptimizedMutationSchedulingforFuzzers.In 28th
USENIXSecuritySymposium,USENIXSecurity2019,SantaClara,CA,USA,August
14-16,2019.1949â€“1966. https://www.usenix.org/conference/usenixsecurity19/
presentation/lyu
[37]HenryMassalin.1993. Synthesis:Anefficientimplementationoffundamental
operating system services. (1993).
[38] Thomas Minka. 2000. Estimating a Dirichlet distribution.[39]
Stefan Nagy and Matthew Hicks. 2019. Full-Speed Fuzzing: Reducing Fuzzing
OverheadthroughCoverage-GuidedTracing.In 2019IEEESymposiumonSecurity
andPrivacy,SP2019,SanFrancisco,CA,USA,May19-23,2019 .787â€“802. https:
//doi.org/10.1109/SP.2019.00069
[40]Awanish Pandey, Phani Raj Goutham Kotcharlakota, and Subhajit Roy. 2019.
Deferred concretization in symbolic execution via fuzzing. In Proceedings of the
28th ACM SIGSOFT International Symposium on Software Testing and Analysis,ISSTA 2019, Beijing, China, July 15-19, 2019. 228â€“238. https://doi.org/10.1145/
3293882.3330554
[41]Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuf-frida, and Herbert Bos. 2017. VUzzer: Application-aware EvolutionaryFuzzing. In 24th Annual Network and Distributed System Security Sym-
posium, NDSS 2017, San Diego, California, USA, February 26 - March 1,2017. https://www.ndss-symposium.org/ndss2017/ndss-2017-programme/
vuzzer-application-aware-evolutionary-fuzzing/
[42]Alexandre Rebert, Sang Kil Cha, Thanassis Avgerinos, Jonathan Foote, David
Warren,GustavoGrieco,andDavidBrumley.2014. OptimizingSeedSelection
for Fuzzing. In Proceedings of the 23rd USENIX Security Symposium, San Diego,
CA, USA, August 20-22, 2014. 861â€“875. https://www.usenix.org/conference/
usenixsecurity14/technical-sessions/presentation/rebert
[43]Sergej Schumilo, Cornelius Aschermann, Robert Gawlik, Sebastian Schinzel,and Thorsten Holz. 2017. kAFL: Hardware-Assisted Feedback Fuzzing for OS
Kernels.In 26thUSENIXSecuritySymposium,USENIXSecurity2017,Vancouver,
BC,Canada,August16-18,2017 .167â€“182. https://www.usenix.org/conference/
usenixsecurity17/technical-sessions/presentation/schumilo
[44]DongdongShe,KexinPei,DaveEpstein,JunfengYang,BaishakhiRay,andSuman
Jana.2019. NEUZZ:EfficientFuzzingwithNeuralProgramSmoothing.In 2019
IEEESymposiumonSecurityandPrivacy,SP2019,SanFrancisco,CA,USA,May
19-23, 2019. 803â€“817. https://doi.org/10.1109/SP.2019.00052
[45]YanShoshitaishvili,MichaelWeissbacher,LukasDresel,ChristopherSalls,Ruoyu
Wang, Christopher Kruegel, and Giovanni Vigna. 2017. Rise of the HaCRS:
Augmenting Autonomous Cyber Reasoning Systems with Human Assistance. In
Proceedingsofthe2017ACMSIGSACConferenceonComputerandCommunications
Security, CCS2017, Dallas,TX, USA,October30 -November 03,2017,Bhavani M.
Thuraisingham,DavidEvans,TalMalkin,andDongyanXu(Eds.).ACM,347â€“362.
https://doi.org/10.1145/3133956.3134105
[46]Nick Stephens, John Grosen, Christopher Salls, Andrew Dutcher, Ruoyu
Wang, Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Gio-
vanni Vigna. 2016. Driller: Augmenting Fuzzing Through Selective Sym-
bolic Execution. In 23rd Annual Network and Distributed System Secu-
rity Symposium, NDSS 2016, San Diego, California, USA, February 21-24,
2016. http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2017/09/
driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf
[47]syzkaller@googlegroups.com.2020.syzkallerâ€“anunsupervisedcoverage-guided
kernel fuzzer. https://github.com/google/syzkaller
[48] LLVM team. 2020. The LLVM Compiler Infrastructure. https://llvm.org/[49]
MingzheWang,JieLiang,YuanliangChen,YuJiang,XunJiao,HanLiu,XibinZhao, and Jiaguang Sun. 2018. SAFL: increasing and accelerating testingcoverage with symbolic execution and guided fuzzing. In Proceedings of the
40th International Conference on Software Engineering: Companion Proceeed-ings, ICSE 2018, Gothenburg, Sweden, May 27 - June 03, 2018, Michel Chau-dron, Ivica Crnkovic, Marsha Chechik, and Mark Harman (Eds.). ACM, 61â€“64.
https://doi.org/10.1145/3183440.3183494
[50]XueruiWang, WeiLi,YingCui, RuofeiZhang,andJianchangMao. 2011. Click-
throughrateestimationforrareeventsinonlineadvertising.In Onlinemultimedia
advertising: Techniques and technologies. IGI Global, 1â€“12.
[51]Wen Xu, Sanidhya Kashyap, Changwoo Min, and Taesoo Kim. 2017. Designing
New Operating Primitives to Improve Fuzzing Performance. In Proceedings of
the 2017 ACM SIGSAC Conference on Computer and Communications Security,CCS 2017, Dallas, TX, USA, October 30 - November 03, 2017. 2313â€“2328. https:
//doi.org/10.1145/3133956.3134046
[52]InsuYun,SanghoLee,MengXu,YeongjinJang,andTaesooKim.2018. QSYM
: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing. In 27th
USENIX Security Symposium, USENIX Security 2018, Baltimore, MD, USA, August
15-17, 2018. 745â€“761. https://www.usenix.org/conference/usenixsecurity18/
presentation/yun
[53]Lei Zhao, Yue Duan, Heng Yin, and Jifeng Xuan. 2019. Send Hard-est Problems My Way: Probabilistic Path Prioritization for Hybrid
869Fuzzing. In 26th Annual Network and Distributed System Security Sym-
posium, NDSS 2019, San Diego, California, USA, February 24-27, 2019.
https://www.ndss-symposium.org/ndss-paper/send-hardest-problems-
my-way-probabilistic-path-prioritization-for-hybrid-fuzzing/[54]ChijinZhou,MingzheWang,JieLiang,ZheLiu,ChengnianSun,andYuJiang.
2019. VisFuzz: Understanding and Intervening Fuzzing with Interactive Vi-
sualization.In 34thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering,ASE2019,SanDiego,CA,USA,November11-15,2019.IEEE,1078â€“1081.
https://doi.org/10.1109/ASE.2019.00106
870