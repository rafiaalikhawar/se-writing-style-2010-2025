From Leaks toFixes:Automated RepairsforResource Leak
Warnings
AkshayUtture
University ofCalifornia,LosAngeles
USA
akshayutture@ucla.eduJens Palsberg
University ofCalifornia,LosAngeles
USA
palsberg@ucla.edu
ABSTRACT
Resourceleaksareacommonandelusivesourceofbugsthatcanre-
sultin crashes andsecurity vulnerabilities. The mosteﬀective tech-
niquetoidentifysuchleaksduringdevelopmentisstaticanalysis.
However, empirical studies show that in addition to leak warnings,
developers often need help in the form of automated ﬁx sugges-
tions to correctly repair such leaks. The only existing tool that can
suggestresource-leakﬁxesisthegeneral-purposetoolFootpatch.
Footpatch, however, performs poorly at this task; it generates ﬁxes
for only 6% ofthe leaks,outofwhich only 27%are correct.
In this paper, we introduce RLFixer, a specialized repair tool
that generates high-quality ﬁxes for resource leaks identiﬁed by
anyresource-leakdetector.AmajorchallengeforRLFixeristhat
themostgeneralversionoftheresource-leakrepairproblemisat
least as hard as compile-time object deallocation, a well-known
hardproblemforcompilers.RLFixertacklesthisissuebyseparating
the resource-leaks that are infeasible for a compile-time tool to ﬁx
from those that are feasible to ﬁx. RLFixer achieves this separation
by using a new data-ﬂow analysis of resource objects to classify
howtheyescapethecontextoftheirmethods.Thesameanalysis
also enables RLFixer to generate correct repairs for the feasible-
to-ﬁx leaks. RLFixer is demand-driven and hence only analyzes
statements relevanttothe leak,thereby keepingoverheadlow.
WeevaluatedRLFixerbyapplyingittowarningsgeneratedby
ﬁvepopularJavaresource-leakdetectors.Weshowthat,onaverage,
RLFixergeneratesrepairsfor66%oftheirwarnings,outofwhich
95%are correct.Ithas an averagerepairtime of14 seconds.
CCSCONCEPTS
•Software and its engineering →Automated static analysis ;
Software maintenance tools .
KEYWORDS
Static Analysis,ResourceLeaks, AutomatedRepair
ACM Reference Format:
Akshay Utture and Jens Palsberg. 2023. From Leaks to Fixes: Automated
RepairsforResourceLeakWarnings.In Proceedingsofthe31stACMJoint
European Software Engineering Conference and Symposium on the Foun-
dations of Software Engineering (ESEC/FSE ’23), December 3–9, 2023, San
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby theowner/author(s).
ACM ISBN 979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.3616267Francisco, CA, USA. ACM, New York, NY, USA, 13pages.https://doi.org/10.
1145/3611643.3616267
1 INTRODUCTION
Motivation. Mostprogramsuse resourcessuchas ﬁles, sockets
and database connections. Resource leaks are a common bug intro-
ducedunintentionallybyprogrammers,whichcanresultinsecurity
vulnerabilities[ 6]andseverefailures[ 24].Resourceleaksareelu-
sive because they only cause crashes when many resources leak
andtheOSrunsoutofthatresource-type;thistypicallydoesnot
happen during testing. An eﬀective approach for identifying these
resource leaks during development is static analysis [ 32]. Today,
developers can choose from several open-source static-analysis
tools that perform resource-leak detection [ 1,3,5,14,32], many of
which provideaccuratewarnings.
Whilestaticanalyzerscandetectresource-leaks,usersalsoneed
tool-support to ﬁx these errors. For example, Christakis and Bird’s
empiricalstudy[ 19]showsthatalackofsuggestedﬁxesisoneofthe
toppainpointsreportedbystaticanalysisusers.Otherdeveloper
studies[20,31,53]alsoreportverysimilarﬁndings.Hence,what
we needis atooltoﬁxresource-leaks.
Existingrepairtools. Sincetherearecurrentlynospecializedtools
for resource-leak ﬁxing, one could try using general-purpose repair
tools[8,15,28,29,33–35,39,40,45,46,49,51,62,65,67], which
workonawidevarietyoferrors.Thesetoolsgeneratecandidate
patches using a variety of techniques, but they all validate a patch
by checking if it passes the previously failing test case. Resource
leaks,however, do not show up during tests,and hence cannot be
ﬁxedbysuchtools.Footpatch[ 61],oneoftheonlygeneral-purpose
toolsthatdoesnotrelyontests,isthecurrentbesttoolforﬁxing
resourceleaks.However,itsuﬀersfrom low-qualityﬁxesfor Java
resource-leaks; it suggests ﬁxes for only 6% of the leaks, out of
which only 27%are correct.
Achieving a perfect ﬁxable-rate (percentage of warnings for
whichaﬁxwassuggested)and ﬁx-correctness (percentageofcor-
rect ﬁxes out of the suggested ﬁxes) for Java resource-leaks is a
loftygoal.Theproblemisatleastashardascompile-timeobject
deallocation[ 17,26](i.e.replacingJava’sruntimegarbagecollec-
torwithstaticdeallocation),aknownhardproblemforcompilers.
Furthermore,inthisrepairproblem,somecornercasesinvolving
loopsoraliasingalsoreducetoundecidableproblems.Hence,there
willalwaysbesomeresource-leaksthatareinfeasibletoﬁxfora
compile time-tool. However, we show that by separating the leaks
that are infeasible to ﬁx from those that are feasible to ﬁx, it is pos-
sibletohavebetterrepairabilitythanFootpatchinbothﬁxable-rate
andﬁx-correctness.
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
159
ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Akshay U/t_ture andJens Palsberg
Resource
Leak
detectorParse
warningsResource
Escape
AnalysisApply
repair
template
34% of warningswarningsProgram
sourceRLFixer
66% fixable
rate, 95% fix
correctnessFixesInfeasible-to-fix
leaksResource
Alias
Identification
Figure 1:Overview oftheRLFixerworkﬂow
Our Approach. In this paper, we introduce RLFixer, a specialized
repairtoolforresourceleaksthatgenerateshigh-qualityﬁxes.Fig. 1
gives anoverview ofitsworkﬂow.The warningscomputed byan
existing black-box resource-leak detector are ﬁrst parsed to extract
the location where the resource was created. Next, the resource
alias identiﬁcation step identiﬁes pairs of resource objects that use
the same underlying system resource. The third step tracks the
data-ﬂow of theresource object using a new demand-driven static
analysiscalleda resourceescapeanalysis .Thisanalysisservestwo
purposes: it identiﬁes leaks that are infeasible to ﬁx, and it helps
pick the correct repair-template for the feasible-to-ﬁx ones. Finally,
using repairstemplate,the last stagegeneratesthe correctﬁx.
Inadditiontogeneratingcorrectﬁxes,wedesigned RLFixerto
be fast because it will typically accompany static analysis warn-
ings in IDEs, which are time sensitive environments. RLFixer’s
demand-drivendesign enablesitto analyzeonlythose statements
relevanttotheresourceleak.Ittakes,onaverage,only1seconds
perprogram,excludingthe13secondsforsettingupthecall-graph,
class-hierarchy,etc.
Weevaluated RLFixerbyapplyingittothewarningsfromﬁve
popular Java resource-leak detectors: Infer [ 14], PMD [1], Checker-
Framework [ 32] , Codeguru [ 5], and Spotbugs [ 3], each of which is
run onprograms from the NJR-1 dataset [ 58].
Our Contributions. We begin with an example of RLFixer ﬁxing
aresourceleak(Section 2), andthen we detailour contributions:
•We introduce a newstaticanalysis, resource escapeanalysis ,
whichhelpsidentifyleaksthatareinfeasibletoﬁx,aswell
as pick the repairtemplate for feasible ones (Section 3).
•We designandimplement RLFixer,aspecializedrepair tool
for resource-leaks that is based on the resource escape analy-
sis, and can repair leaks from multiple leak detectors (Sec-
tion4).
•Weshow,experimentally,that RLFixergenerateshigh-quality
ﬁxes withlowoverheadfor ﬁve popularJava resource-leak
detectors. Out of 2205 resource leaks detected in NJR-1, it
generates,onaverage,ﬁxesfor66%oftheleaks,outofwhich
anestimated95%arecorrect(Section 6).RLFixeroutperforms
the Footpatch baseline, which generates ﬁxes for only 6% of
the leaks,outofwhichonly 27%are correct.1voidfoo ( File a) throws IOException {
2 FileReader fr = null;
+try{
3 fr = newFileReader (a) ;
4 bar ( fr ) ;
5intdata = fr . read () ;
+ }finally {
+try{
+ fr . close () ;
+ }catch( Exception e) {
+ e . printStackTrace () ;
+ }
+ }
6 }
7voidbar ( FileReader f ) {
8 BufferedReader r = null;
9try{
10 r = newBufferedReader ( f ) ;
11 System . out . println ( r . readline () ) ;
12 } catch( IOException e) {}
13 }
Figure 2:Example ofaresource leak ﬁxed by RLFixer
Weendwithadiscussionofrelatedwork(Section 7)andourcon-
clusion (Section 8).
2 EXAMPLES
Thissectionshowstwosimpliﬁedexamplesofhowtheﬁveresource
leak detectors report leaks, and how RLFixergoes about repairing
them. It highlights the need for suggesting ﬁxes for resource-leaks,
as well as someofthe challenges ingeneratingacorrectﬁx.
Fig.2shows asimpliﬁed Javacode snippet from one of the NJR
benchmarks. It has two methods, each with one resource object.
First,letuslookatthemethod foo.foocreatesa FileReader re-
source (line 3), which gets passed in to the barmethod (line 4).
Notethat foocontinuesusingthe FileReader online5afterthe
barfunctionreturns.The foomethodalsodeclaresthatitpoten-
tially throws an IOException . This declaration is required by the
Java-compiler’s type and eﬀect system when a resource’s potential
exception is not handled in a try-catch block. The lines highlighted
ingreenconstitutetheﬁxsuggestedby RLFixer;theyhavenotbeen
addedto the code yet.
Next,let’sfocusonthemethod bar.Itcreatesa BufferedReader
resource object with the FileReader parameter fas an argument
(line10).Here,the BufferedReader isawrapperresourcethatpro-
videsbuﬀeringfunctionalityforthe FileReaderf .Hencewesay
that the resource variables fandrareresource aliases . This means
thateventhoughtheypointtodiﬀerentresourceobjects( fpointsto
aFileReader andrpoints to a BufferedReader ),the underlying
systemresourcepointedtobythoseobjectsisthesame.Thisim-
plies that closing one resource object closes all its resource aliases.
Inthiscase,neitherthe BufferedReader northeFileReader have
been closed,andhence we getaresourceleak.
Wenowrunﬁveresource-leakdetectors(Infer,PMD,Checker-
Framework, Codeguru, and Spotbugs) on this code, and Table 1
showsthe outputgivenby each.PMD and Infer identify a resource
leakfor the BufferedReader , whereasChecker-Frameworkidenti-
ﬁes a resource-leak for the FileReader . Codeguru and Spotbugs
160From Leaks to Fixes: AutomatedRepairs forResource LeakWarnings ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Table1:Outputsfortheﬁveresource-leakdetectors,when
given thecodesnippet fromFig. 2
Tool Output
Infer Resource of type BuﬀeredReader at line 10is
not releasedafter line 11
PMD EnsurethatresourceslikethisBuﬀeredReader
objectare closedafter use (line 8)
Checker-
Framework@MustCall method close may not have been
invokedon‘fr’orany ofits aliases(line 3)
Codeguru N/A(Resourceleakmissed)
Spotbugs N/A(Resourceleakmissed)
do not report any resource leak. Even after getting one of these
warning messages, a developer is still several steps away from a
correctﬁx.
Wealsorunthebaselinerepairtool,Footpatch,onthisﬁle-handle
leak.FootpatchistightlyintegratedwithInfer,andreliesonInfer’s
warning output for identifying ﬁx locations. Footpatch ﬁrst gen-
eratescandidatepatchesbysearchingthecode-baseforprogram
fragmentsthatcloseaﬁle,andthenvalidatesthepatchesbycheck-
ingifInferstopsreportingtheleak.Inthiscase,Footpatchisunable
to generate any patch candidates for the warning. Furthermore,
evenifFootpatchdidhypotheticallyﬁndapatch,itwouldapplythe
patchatthelocationin Infer’s warning(after line 11). Closing the
BufferedReader after line 11, or anywhere in function bar, will
mean that the ﬁle pointed to by its resource-alias FileReader will
be closed before it isread on line 5. Thisﬁx is dangerous since it
introduces anewuse-after-closeerror.
Finally,letusexaminehow RLFixerdealswiththeresourceleak,
assuming the warning came from Infer (i.e. for line 10).RLFixer
startsoﬀbyperforminga resourcealiasidentiﬁcation forthenew
BufferedReader object(line 10).Thisanalysisrevealsthat fisa
resource-alias. Next, RLFixerperforms a resource escape analysis , a
static analysis that computes how the BufferedReader and any of
its aliases escapes the method. The two ways the resource escapes
thebarmethod are via the readline method call (line 11) and
viatheparameter f. Whena resource escapesviaa parameter,we
cannotclosetheresourceinthecurrentmethod,sincetheresource
is still accessible after the method returns. Instead, we examine the
callerinstructiononline 4,whichisinthemethod foo.Carryingout
theresource escape analysis forfrinfooshows that it only escapes
via method calls, and hence can be closed in the method fooitself.
RLFixerthen picks the correct repair-template, and it suggests the
ﬁxhighlightedingreeninFig. 2.Therepair-codecorrectlyﬁxesthe
leakwithoutintroducingnewerrorsormodifyingthesemantics
of the original program. RLFixercomputes the same ﬁx for the
warnings given byPMD andChecker-Framework.
A Resource Leak that is Infeasible to fix. Fig.3shows an example of
aresourceleakthatmaybeinfeasibletoﬁxatcompiletime. RLFixer,
during its resource escape analysis , tracks the FileWriter resource
(line4) through the call to the method store, and identiﬁes that it
isassignedtheﬁeld fwonline9.Sincethisﬁeldisaccessibleaslong
asitsparent /u1D434objectisalive,wecanonlysafelyclosethisresource
whenthe /u1D434objectisgettingdeallocated.Thismakestheproblemat1classA{
2 FileWriter fw;
3voidcreate ( File b) throws IOException {
4 FileWriter f = newFileWriter (b) ;
5 store ( f ) ;
6 }
7
8voidstore ( FileWriter a) {
9 fw = a ; /∗Resource escapes to a field ∗/
10 }
11 }
Figure 3:Example ofaresource leak that is infeasible to ﬁx
least as hard as compile-time object deallocation [ 17,26], a known
hard problem for compilers. Prior research has only managed to
statically deallocate some objects in the program [ 26], and the
hardness of this problem is the reason why Java uses a runtime
garbagecollector.Thisisjustoneoftheinfeasiblecasesforresource-
leakrepair; we discuss the full listof casesinSection 3.
There will always be resource-leaks that are too hard to ﬁx
statically. RLFixeraims to identify and separate out the hard-to-ﬁx
leaks like the one in Fig. 3, while correctly ﬁxing the rest of the
resource-leaks,like the one inFig. 2.
3 APPROACH
This section gives an overview of RLFixer’s approach to ﬁxing
resource-leaks. Fig. 1shows the four main components of RLFixer:
the warning parser, the resource alias identiﬁcation, the resource
escape analysis , and the application of repair templates; we now
discuss eachoftheseindetail.
3.1 WarningParser
Theﬁrstcomponentparsestheresource-leakdetector’swarning
and extracts the source ﬁle and line number where the leaked
resource was created. Each resource-leak detector needs a separate
parser because each tool uses a diﬀerent output format, but this
componentissimpleandsmall.Onaverage,ittakesonly15lines
ofPythoncode per newtool.
3.2 ResourceAliasIdentiﬁcation
Thesecondstepfor RLFixerisidentifyingresourcealiasesforthe
leakedresourceobjects.Thisisanimportantstepbecauseamajority
ofresourceusageinJavainvolvesresourcealiasing.Wehavealready
seen anexampleof resource aliasing inFig. 2, where the FileReader
andBuﬀeredReader objectspointed to thesameOS resource.Prior
research [ 32,57] has studied resource-aliasing from the point of
view of pruning false-positive resource-leak warnings. Here, we
studyresource-aliasingfromthepointofviewofgeneratingcorrect
repairs. Below is the resource-aliasing deﬁnition that RLFixeruses.
(1)Variables /u1D465and/u1D466.altare resource-aliases if /u1D465is a wrapper for /u1D466.alt,
or/u1D466.altisawrapper for /u1D465.
(2)Resource /u1D44Aconstructed with the constructor /u1D436/u1D44Ais a wrap-
per for resource /u1D445if:
(a)/u1D445ispassedas aparameterto /u1D436/u1D44A,and
(b)/u1D445isamust-alias of aﬁeld of /u1D44Aat the end of /u1D436/u1D44A,and
161ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Akshay U/t_ture andJens Palsberg
1classWrapperType{
2private ResourceType out ;
3public WrapperType( ResourceType w) {
4 out = w;
5 }
6public close () {
7 out . close () ;
8 }
9 }
10 . .
11 {
12 /∗Resource −leak reported here ∗/
13 x = newResourceType ( "a . txt " ) ;
14 y = newWrapperType(x) ;
15 }
Figure4:ResourceAliasIdentiﬁcation:checkingiftheWrap-
perType objectisawrapperfortheResourceType object
(c)The must-alias ﬁeld always gets closed in the close()
functionof /u1D44A
(3) Allpointer aliasesare treatedas resource-aliases.
This deﬁnition also serves as a speciﬁcation for a static analysis,
whichRLFixerimplementstoidentifyresourcealiaspairs.Letus
use the example from Fig. 4to check if the variables /u1D465and/u1D466.altare
resource-aliases. The resource leak warning is reported for the
ResourceType object on line 13. TheResourceType cannot be a
wrapper for any other object because its constructor only takes
a string input, and this will never satisfy condition (2a). So let
us check the 3 conditions for the WrapperType to be a wrapper
fortheResourceType .Weﬁrstperformadef-useanalysis[ 52]of
/u1D465, which identiﬁes all uses of /u1D465. Since/u1D465is used as a parameter
in the constructor for the WrapperType (line14), condition (2a)
is satisﬁed. Next, for condition (2b), we check the WrapperType
constructor and its callees for an assignment of its parameter /u1D464
(or one of its aliases) to a ﬁeld of the WrapperType . In this case we
have such an assignment (line 4) for the ﬁeld, /u1D45C/u1D462/u1D461; the condition is
satisﬁed. Analyzing the closefunction reveals that the resource
fromtheﬁeld /u1D45C/u1D462/u1D461getsclosedinit(line 7),andthissatisﬁescondition
(2c).Thus, allthreeconditionsare satisﬁed;the WrapperType and
ResourceType are resource-aliases. The ﬁnal part of the deﬁnition
saysthatallpointer-aliasesareresource-aliases.Pointer-aliasescan
be foundusing atypicaldemand-driven pointer analysis[ 56].
Wenowknowhowtoidentify pairsofresource-aliases,butwe
alsoneedtoconsiderresource-objectsthatarelinkedbymultiple
layers of resource-wrapping. This is quite common in Java pro-
grams; a resource can be wrapped in up to four or ﬁve layers of
resource wrappers. We identify this linking by computing a transi-
tive closure over the resource-aliasing relationship.
3.3 ResourceEscapeAnalysis
The third component, the resource escape analysis , computes all
the types of program constructs that the resource can escape to.
This analysis is used by RLFixerfor two purposes: it helps separate
out the infeasible-to-ﬁx leaks, and it helps compute repairs for the
feasible-to-ﬁx leaks.
Theresourceescapeanalysis iscarriedoutontheWALAIR[ 2]
because it is easier to write a data-ﬂow analysis on WALA IR thanProgram :: (C, C, . . . C)
C :: <cname> Ext ImpDS { fields :{ f ; . . f ;} methods :{M, . . ,M}}
M :: <mname>( /u1D4491,.. ,/u1D449/u1D45B) { instructions :{ I ; . . I ; } }
I :: ArrayStore | FieldWrite | Assgn | PhiStmt |
ReturnStmt | Invoke | FieldRead | ConditionalBranch
| NewStmt | ArrayLoad
ArrayStore :: /u1D449/u1D44E/u1D45F/u1D45F[/u1D449/u1D456/u1D451/u1D465] =/u1D449/u1D45Fℎ/u1D460
FieldWrite :: /u1D449/u1D459ℎ/u1D460. f =/u1D449/u1D45Fℎ/u1D460
Assgn :: /u1D449/u1D459ℎ/u1D460=/u1D449/u1D45Fℎ/u1D460
PhiStmt :: /u1D449/u1D459ℎ/u1D460= phi (/u1D4491,.. ,/u1D449/u1D45B)
ReturnStmt :: return V
Invoke :: /u1D449/u1D459ℎ/u1D460=/u1D449/u1D45Fℎ/u1D460.<mname>( /u1D4491,.. ,/u1D449/u1D45B)
FieldRead :: /u1D449/u1D459ℎ/u1D460=/u1D449/u1D45Fℎ/u1D460. f
ConditionalBranch :: if/u1D449/u1D44F/u1D45C/u1D45C/u1D459goto <instr −index>
NewStmt :: /u1D449/u1D459ℎ/u1D460= new <cname>
ArrayLoad :: /u1D449/u1D459ℎ/u1D460=/u1D449/u1D44E/u1D45F/u1D45F[/u1D449/u1D456/u1D451/u1D465]
V :: <var −name>
Ext :: extends <cname> | ' '
ImpDS :: implements <data −structure −interface > | ' '
Figure 5:Simpliﬁed grammarforthe WALA IR
Table 2:The ﬁve escape mechanisms foraresource object
Escape type Resource hasthisescape type if it:
Field-Escape aliaseswithan instanceﬁeld orstaticﬁeld
Data-Structure-
Escapealiaseswithanelementinanarrayordata-
structure.
Return-Escape gets returned by the method it is created in.
Parameter-
Escapealiases with a formal parameter of the
methoditiscreatedin
Invoke-Escape is passed as an argument to an invoke state-
ment(i.e.methodcall)
onJavasourcecode.WALAisthestaticanalysisframeworkused
byRLFixer,andthe WALAIR isvery close to Java bytecode.
Fig.5givesasimpliﬁedgrammaroftheWALAIR.Mostofthe
grammar terms are common to most intermediate representations.
ThePhiStmt is a specialinstruction inall SSA-based IRs to merge
valuesfromasource-variablethatappearsontwodiﬀerentcontrol-
ﬂowpaths.The ImpDSnon-terminalspeciﬁesiftheclassimplements
any of the data-structure interfaces (such as Map, Collections, etc.).
The list of instructions in the grammar show that there are ﬁve
programconstructstowhicharesourcecanescapefromitsmethod:
aﬁeld,adata-structure(anarrayoradata-structureclass),areturn
variable,aparameter,oran invoke(i.e.method-call).
We deﬁne ﬁve escape types corresponding to these ﬁve con-
structs:Field-Escape,Data-Structure-Escape,Return-Escape,Parameter-
Escape, Invoke-Escape . Table2describes what each escape type
means.Aresourcecanhavemultipleescapetypes.Byenumerating
through the instruction types in Fig. 5, we can see that the ﬁve
escape types exhaustively cover all the ways a resource can escape
the methoditiscreatedin.
Fig.6gives pseudo-code for the analysis. It is designed to be
demand-driven, and its output is the set of possible escape types
for the resource. The analysis procedure, whose name is shortened
torea,takestwoarguments:theresourcevariablewhoseescape
mechanisms need to be analyzed, and the method it is declared in.
162From Leaks to Fixes: AutomatedRepairs forResource LeakWarnings ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
1:procedure rea(/u1D45F/u1D452/u1D460/u1D45C/u1D462/u1D45F/u1D450/u1D452/u1D449/u1D44E/u1D45F/u1D456/u1D44E/u1D44F/u1D459/u1D452 ,/u1D45A/u1D452/u1D461ℎ/u1D45C/u1D451)
2:/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 =∅
3:forI ingetUses( /u1D45F/u1D452/u1D460/u1D45C/u1D462/u1D45F/u1D450/u1D452/u1D449/u1D44E/u1D45F/u1D456/u1D44E/u1D44F/u1D459/u1D452 )do
4: switchI.instructionType do
5: caseArrayStore:
6: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ∋Data-Structure
7: caseFieldWrite:
8: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ∋Field
9: caseAssgn:
10: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ⊇rea(Assgn. /u1D449/u1D459ℎ/u1D460,/u1D45A/u1D452/u1D461ℎ/u1D45C/u1D451)
11: casePhiStmt:
12: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ⊇rea(PhiStmt. /u1D449/u1D459ℎ/u1D460,/u1D45A/u1D452/u1D461ℎ/u1D45C/u1D451)
13: caseReturnStmt:
14: if/u1D45A/u1D452/u1D461ℎ/u1D45C/u1D451==originalWarningMethod then
15: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ∋Return
16: end if
17: for/u1D450/u1D44E/u1D459/u1D459/u1D452/u1D45Fincallers( /u1D45A/u1D452/u1D461ℎ/u1D45C/u1D451)do
18: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ⊇rea(/u1D450/u1D44E/u1D459/u1D459/u1D452/u1D45F./u1D449/u1D459ℎ/u1D460,/u1D450/u1D44E/u1D459/u1D459/u1D452/u1D45F.method)
19: end for
20: caseInvoke:
21: forM ininvoke.targets do
22: ifM.isDataStructureMethod() then
23: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ∋Data-Structure
24: else
25: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ∋Invoke
26: /u1D45D=M.matchingParam( /u1D45F/u1D452/u1D460/u1D45C/u1D462/u1D45F/u1D450/u1D452/u1D449/u1D44E/u1D45F/u1D456/u1D44E/u1D44F/u1D459/u1D452 )
27: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ⊇rea(p,M)
28: end if
29: end for
30: caseFieldRead: donothing
31: caseConditionalBranch:do nothing
32: caseNewStmt: donothing
33: caseArrayLoad: donothing
34:end for
35:ifisParameter( /u1D45F/u1D452/u1D460/u1D45C/u1D462/u1D45F/u1D450/u1D452/u1D449/u1D44E/u1D45F/u1D456/u1D44E/u1D44F/u1D459/u1D452 )then
36: if/u1D45A/u1D452/u1D461ℎ/u1D45C/u1D451==originalWarningMethod then
37: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ∋Parameter
38: end if
39: for/u1D450/u1D44E/u1D459/u1D459/u1D452/u1D45Fincallers( /u1D45A/u1D452/u1D461ℎ/u1D45C/u1D451)do
40: /u1D45D=/u1D450/u1D44E/u1D459/u1D459/u1D452/u1D45F.matchingArgument( /u1D45F/u1D452/u1D460/u1D45C/u1D462/u1D45F/u1D450/u1D452/u1D449/u1D44E/u1D45F/u1D456/u1D44E/u1D44F/u1D459/u1D452 )
41: /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ⊇rea(p,/u1D450/u1D44E/u1D459/u1D459/u1D452/u1D45F.method)
42: end for
43:end if
44:return/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460
45:end procedure
Figure 6: Resource Escape Analysis (Name shortened to /u1D45F/u1D452/u1D44E)
/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460,thesetofescapetypes,isinitializedtotheemptysetin
thebeginning.Thebulkofthemethodisaforloopovertheuses
ofthe resourcevariable.
Foreachuse, RLFixerperformsacaseanalysisbasedonthetype
oftheuseinstruction(line 4).Thepossibleuseinstructionscome
from the grammar in Fig. 5. If theuse-instructionisan ArrayStore ,it follows that the resource object aliases with an array element,
andaccordingtoTable 2,thisimpliesa Data-StructureEscape ;we
addthisto /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460.Similarly,a FieldWrite impliesa FieldEscape .
AnAssgnorPhiStmtrequiresustorecursivelytracktheassigned
variable; hence we call reaon it. Being used in a ReturnStmt in
the warning’s original method implies that Returnshould be in
/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460. Additionally, since we need to track the returned vari-
able inallcallers,we addtheescape types ofthecallers’ call-sites
to/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 .Iftheuse-instructionisan Invoke(i.e.methodcall),we
splititintotwosub-cases.Ifthemethodbelongstoadata-structure
class,weadd Data-Structure to/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460.Ifnot,weadd Invoketo
/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460,andtracktheescapetypesinthemethodcallbyrecur-
sively calling reaon the matching argument in the invoke targets.
Wedonotneedtodoanythingforthelastfourinstructiontypes.
AFieldRead doesnotpropagateanyescapeinformationfromthe
resource variable because only the ﬁeld is read. ConditionalBranch ,
NewStmt, andArrayLoad do not even support the use of a resource
variable.
In addition to checking for the uses of the resource variable, we
also need to check if it escapes to a parameter (line 35). If so, we
addParameter to/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460.Additionally,werecursivelytrackthe
escapetypesinthecallermethods,bycalling reaontheresource
variable’smatching argument inthe caller methods(line 41).
Finally,theanalysisreturns /u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 ,theaggregatesetofescape
typesfor/u1D45F/u1D452/u1D460/u1D45C/u1D462/u1D45F/u1D450/u1D452/u1D449/u1D44E/u1D45F/u1D456/u1D44E/u1D44F/u1D459/u1D452 .Sinceresourcealiasespointtothesame
underlyingresource,anescapetypeforonealiasappliestoallother
aliases.Hence,theresourceescapeanalysismustberepeatedforall
resource-aliases of /u1D45F/u1D452/u1D460/u1D45C/u1D462/u1D45F/u1D450/u1D452/u1D449/u1D44E/u1D45F/u1D456/u1D44E/u1D44F/u1D459/u1D452 , and their escape types added
to/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460.
3.4 ApplyingRepair Templates
Theﬁnalstepfor RLFixerisgeneratingrepaircode.Therepaircode
has the following speciﬁcation: it should close the leak after the
lastuseoftheresource,withoutintroducingnewerrors(suchas
anewleak,ause-after-closeerror,oranullpointerexception)or
modifyingthe semantics of the originalprogram.
RLFixeruses the decision tree from Fig. 7to pick the correct
repair strategy. If a resource escapes to a ﬁeld or data-structure,
RLFixermarksitas infeasible toﬁx.Ifthe resource does not escape
toaﬁeldordata-structure,butdoesescapetoareturnorparameter,
RLFixercreatesdummyleakwarningsatthecallermethods,and
closes the leak there. If it does not have any of these four escape
types, we can close the resource in the same method as it was
created.Basedonhowtheresourceisused,wethenapplyoneof
three repair templates. Since the decision tree covers all the ﬁve
escapetypes,itexhaustivelycoversallthewaysasingleresource
can leak.Letusnowexamine eachdecision-tree node indetail.
Field-Escape. Resourceswitha FieldEscape areinfeasibletoﬁx.
Closing a resource that escapes to an instance ﬁeld, like in the
example from Fig. 3, is at least as hard as compile-time object
deallocation. Closing a resource that escapes to a static ﬁeld is not
possiblebecuasestaticﬁeldsarealivethroughouttheprogram’slife.
Furthermore,incaseswherewedon’thaveaccesstoallthecodeat
compile time (such as when designing a library), it is impossible to
staticallyevenidentifyallusesofaﬁeld;inthiscase,a Field-Escape
willnever be safe to close.
163ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Akshay U/t_ture andJens Palsberg
Resource is defined in a try-catch
block, and all its uses (and aliases)
are contained in the same block
Resource has a post-dominatorIf the resource is not defined in a try-
catch blockParamter ∈ escTypesReturn  ∈ escTypesData-Structure  ∈ escTypes OR
Field  ∈ escTypes
No
No
No
No
NoInfeasible to FixYes
YesCreate dummy
warning at the callers'
returned variables
[Resource either has an Invoke escape or no
escape. It can be closed in this method itself.] 
[Resource (or alias) uses are partly inside a
try-catch block and partly outside]
Yes
NoInfeasible to FixCreate dummy
warning at the callers'
argumentYes
Apply the 'Throws
Template'
Apply the 'Contained
Try-Catch Template'
Apply the 'Escaped
Try-Catch Template'Yes
Yes
Figure7:Decision-treedepictinghowRLFixerdecideswhich
leaksareinfeasibletoﬁx,andpicksthecorrectrepairtem-
plate to apply.
Data-Structure-Escape. FixingData-Structure-Escapes ishardbe-
causeitiswell-knownthatunbounded datastructures suchasar-
rays are hard to accurately model using static analysis [ 25]. Hence,
staticanalysistoolsmodeldatastructuresusing over-approximation .
Inthecaseofanarray,theover-approximationistoassumethat
areadorwriteto the arraycould aﬀectany possible index. Such
anover-approximationissafeforresource-leakdetectionbecause
it will never miss out on a leak that occurs in a possible execution.
However,itisunsafeforourrepairproblembecauseclosingare-
sourcefromanarrayrequiresus toknowtheexactindexthatthe
resource is at. A similar argument applies to other data-structures.
Hence,RLFixerdoes not generateany repairsfor this case.
Return Escape. At the/u1D445/u1D452/u1D461/u1D462/u1D45F/u1D45B∈/u1D452/u1D460/u1D450/u1D447/u1D466.alt/u1D45D/u1D452/u1D460 node of the decision
tree,wealreadyknowthattheresourcedoesnotescapetoaﬁeldor
data-structure.Iftheresourcedoes escape viaa Return,wecreate
one dummy warningfor each caller at the returnedvariable.For
example, in the snippet ( Resource r = getRes() ), a resource
objectgets returnedbythe getResmethod and henceisstill alive
after the getResmethod returns. Consequently, we cannot close
the resource inside the getResmethod. Instead, we create dummy
leak warning at the returned variable ( rin this case). We then
recursivelyapply RLFixertothedummywarning(s),andsuggest
theirrepairsas aﬁxfor the originalwarning.Parameter Escape. TheParameter Escape case is similar to the
ReturnEscape case,wherewecreateadummywarningatthecaller
methods.Theonlydiﬀerenceisthatthedummywarningiscreated
at the corresponding argument of the paramter in the caller. We
alreadysawthisstrategybeingappliedtotheexampleinFig. 2.The
resourceleakwasreportedatthenewBuﬀeredReaderinthe bar
method of Fig. 2(line10). The Buﬀered Reader resource escapes to
theparameterviaitsresourcealias( FileReaderf ).Hence,wecreate
adummywarningfortheargument fratthemethodcallto barin
thecallermethod foo(line4).Wethenrecursivelyapply RLFixer
on the dummy warning(s), and suggest their repairs as a ﬁx for the
originalwarning.
Invoke Escapeand Non-escape. At thedecision treenode where
wehaveneithera Data-Structure ,Field,ReturnorParameter escape,
we are left with resource-leaks that eitherhave an Invoke Escape or
noescapetypes.Inthesetwocases,theresourceisnotusedafter
themethodcompletes,andhenceshouldclosedinthesamemethod.
Basedonwhethertheresourceisdeﬁnedinsideatry-catchblock
ornot,wedeﬁnethreerepairtemplates:the ThrowsTemplate ,the
ContainedTry-CatchTemplate ,andtheEscapedTry-CatchTemplate .
Fig.8illustrates these templates. The lines highlighted in green
give the ﬁxsuggestedby RLFixer.
TheThrowsTemplate (seeFig.8a)applieswhentheresourceis
not created or used within a try-block. The repaired code places
allthe resource(andalias)useswithina try-ﬁnally block.The try
block starts at the ﬁrst line where the resource is used. The ﬁnally
block starts afterthe last line where the resource is used,but with
adjustmentstomatchthescopeofthenewlyaddedtry-block.Note
that the new close statement is placed within its own try-catch
block to handle any exception (related to resource access, null-
pointers,etc.)itmaythrow,therebyavoidingmodifyingthecontrol
ﬂow of the original program. Modifying the control ﬂow of the
originalprogrammodiﬁesitssemantics, andthisgoesagainstour
repairspeciﬁcation.Wewillseethesamepatternwiththenexttwo
templates.
TheContained Try-Catch Template (see Fig.8b) is applied when
the resource creation and all its uses (and resource aliases) are
contained within a tryblock. In this case, the correct repair is to
attachacorresponding ﬁnallyblockthatclosestheresource.Ifa
ﬁnallyblockisalreadypresent, RLFixeraddstheclosestatementto
theexistingﬁnallyblock.The ﬁnallyblockinJavaalwaysexecutes
afterthetry-catch block,evenifthe tryblockhasareturnstatement
oranexception.Hence,withthisﬁx,theresourceisclosedonall
program paths,includingones involving an exception.
TheEscaped Try-Catch Template (see Fig.8c) applies when re-
sourcecreationandusestatements(andresourcealiases)arepartly
insideatryblockandpartlyoutside.Forexample,theuseonline 5
isinside,whereastheoneonline 8isoutside.Here, RLFixerﬁrst
placesallstatementsthatareoutsidea tryblock(e.g.line 8)inanew
try-catch block; this prevents control from escaping the method
barbefore the resource can be closed. Note that RLFixerre-throws
the exception in the ﬁx code to preserve control-ﬂow to any ex-
ception handler in the caller method of bar. Finally, the resource
needstobeclosedatitsearliest post-dominator .Apost-dominator
foraresourceisaninstructioninthemethodthatappearsonevery
control-ﬂow path from a resource use to the end of the method. In
164From Leaks to Fixes: AutomatedRepairs forResource LeakWarnings ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
1voidfoo ()throws Exception {
2 Resource r = null;
+try{
3 r = newResource ( . . ) ;
4 r . useResource () ;
+ }finally {
+try{ r . close () ; }
+catch( Exception e) {
+ e . printStackTrace () ;
+ }
+ }
5 }
(a)Throws Template1 Resource r = null;
2try{
3 r = newResource ( . . ) ;
4 r . useResource () ;
5 }catch( IOException e) {
6 e . printStackTrace () ;
7 }
+finally {
+try{ r . close () ; }
+catch( Exception e) {
+ e . printStackTrace () ;
+ }
+ }
8/∗No Resource use after this ∗/
(b) ContainedTry-catch Template1voidbar ()throws Exception {
2 Resource r = null;
3try{
4 r = newResource ( . . ) ;
5 r . useResource () ;
6 } catch( Exception e) {}
7/∗Some code in between ∗/
+try{
8 r . useResource () ;
+ }catch( Exception e) {
+try{ r . close () ; }
+catch( Exception f ) {}
+throwe ;
+ }
9/∗Some code in between ∗/
10/∗No Resource use after this ∗/
+try{
+ r . close () ;
+ }catch( Exception E) {
+ e . printStackTrace () ;
+ }
11 }
(c) EscapedTry-Catch Template
Figure 8: RLFixer’s Repair Templates
Fig.8c, assuming the earliest post-dominator for the resource is
online10,RLFixerclosestheresourceatthispoint.Iftheearliest
post-dominatorisinsideatry-catchblock,theclosestatementgoes
insideaﬁnallyblock.Choosingtheearliestpost-dominatorforclos-
ing theresource is always safe,but incorner cases with a method
havingmultipleexitpoints,aresourcemayhavenopost-dominator;
RLFixerdoes not suggestany ﬁxinthis corner case.
We avoid Java’s try-with-resources statement because it only
appliestoresourcesthatimplementthe AutoCloseable interface.
Additionally,itsupressesexceptionsinthetry-withstatementin
some cases, thereby modifying the control ﬂow. Futhermore, it
cannot handle the resource usage pattern from the Escaped Try-
Catch Template.
3.5 LoopsandExistingCloseStatements
There are two more details we need to handle in the repair code:
loopsandexisting close statements.
Dealing with Loops. We can divide the resource-leaks in loops
into two sub-cases. The ﬁrst, more common sub-case, occurs when
the resource is created during a loop iteration and is never used
aftertheendofthatiteration. RLFixerdealswiththissub-caseby
extractingthe loop-bodyand computingthe ﬁxon thisloop-body
asitwouldforanyloop-freeresourceleak.Fortheveryraresub-
case where a resource created in a loop stays alive beyond the end
of a loop iteration, RLFixerdoes not suggest a ﬁx; this sub-case
gives an undecidable problem.1
DeletingExistingCloseStatements. Inadditiontoaddingrepair
code,RLFixeralso needs to remove unnecessary closestatements
added by the programmer to avoid a double close. We design each
ofourrepair-templatestorequireasingleclosestatement;hence,
1Fixing the leak in this rare sub-case requires us to identify the last loop iteration (to
closethe leak), whichis a known hard problem for compilers.RLFixerdeletesanyexistingclosestatementsthatwereaddedby
the programmer. For example, in Fig. 8b, if the programmer had
inserted a close statement inside the tryblock after line 4,RLFixer
would need to delete it (in addition to generating new repair code).
4 IMPLEMENTATION
Thissectiondiscussestheimplementationdetailsfor RLFixer.RL-
Fixeris primarily implemented in the WALA static analysis frame-
workforJavabytecode[ 2].Wewrote RLFixer’s analysesonWALA’s
IR instead of Java’s source AST because the IR has simpler control
ﬂow,fewerinstructiontypes,andisalreadyinSSAform.Further-
more, WALA automatically sets up the core information needed
by any static analysis, such as computing the class-hierarchy, call-
graph (using the 0-CFA algorithm) and basic-blocks. The Repair-
Template stage of RLFixeradditionallyuses JavaParser [ 4] to scan
the Java sourceASTs for scopingandlinenumber information.
Theresource-escapeanalysis,call-graph,andresource-aliasanal-
ysisalluseacontext-insensitiveanalysis.Context-sensitivityisnot
needed because we know of no way to represent context in repair
code. Our analyses automatically get partial ﬂow-sensitivity be-
cause of the WALA IR’s SSA form. Field-sensitivity is redundant
becauseallresourcesaliasingﬁeldsbecome FieldEscapes anddonot
getﬁxed.Reﬂectionsupportcantriviallybeaddedbyturningon
WALA’sreﬂectionanalysis,butweskipthisoption;itonlybeneﬁts
a tiny fraction of repairs, while increasing call-graph computation
timebymanyfold.Inourexperiments,outofthe150resource-leaks
that were manually examined,none were aﬀectedbyreﬂection.
TheoutputformatofthetoolismuchlikethatinFig. 2,andcan
easilybeincorporatedintoanIDEorexistingstaticanalysistool.
Note that RLFixerdoes not automatically adjust variable scopes in
its generatedﬁx;itisupto the programmer to correctthis.
165ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Akshay U/t_ture andJens Palsberg
Resource-leak warnings reported050010001500
Infer PMD CF Codeguru Spotbugs
Figure9:Warningsreportedbytheﬁveresource-leakanalyz-
ers whenapplied to theNJRdataset.
5 DATASET
WeusetheNJR-1dataset(availablehere[ 58]),asourbenchmark-set.
Itconsistsofadiversesetof293Java-8programsfromGitHub,and
hasbeenusedinseveralrecentstaticanalysispaperssuchas[ 36,
59,60].Itiswell-suitedtoevaluate RLFixerbecauseithasseveral
resourceleaks,andrunsoﬀ-the-shelfwithseveralexistingresource-
leak detectors and Java analysis tools like WALA and JavaParser.
Weleaveout6ofthe293NJR-1benchmarks;Footpatchrunsout
ofmemoryforthreebenchmarks,andthreearemissingalibrary
class. This leaves uswith287benchmarks for our experiments.
We run ﬁve popular Java resource-leak detectorsonthis dataset:
Infer [14], PMD [1], Checker-Framework [ 32] (shortened to CF),
Codeguru[ 5],andSpotbugs[ 3].Thewarningsgivenbythesetools
arethenfedto RLFixer.Weranallthetoolswiththeirdefaultop-
tions, and after post-processing the warnings to ﬁlter out duplicate
warnings,etc.,wegotatotalof2205uniqueresource-leaks.During
theduplicateﬁltering,iftherearetwowarningsforaresource-alias
pair(i.e.samerootcause),onegetsremoved.Fig. 9liststhenumber
of warnings given by each tool after duplicate ﬁltering. CF gets
the most resource-leaks, probably because of its commitment to
soundness (i.e. catching as many possible leaks). Spotbugs gets the
fewestresource-leaks, probablybecause soundness wastraded oﬀ
for speed. Similarly, the other tools diﬀer in their set of reported
leaksbecause ofdiﬀerentdesigndecisions.
Table3reportssomestatisticsaboutthefrequencyofresource
leaks in the NJR dataset. 207 out of 287 programs have at least one
leak.Bytakingaunionoftheresourceleaksbytheﬁvetools,we
get an estimated total of 2205 unique resource leak warnings. This
averagesto8resourceleaksperprogram.Giventhattheaverage
number of lines of application code in the NJR dataset is almost
10k, we can expect one resource leak in every 1300 lines of code.
Thus, resource leaks are prevalent in the dataset; developers need
bettertool-support for ﬁxing theseleaks.
6 EXPERIMENTALRESULTS
In this section, wediscuss our experimental results which answer
the following fourresearchquestions:
(1)RQ1:Howmanywarnings can RLFixersuggestﬁxes for?
(2)RQ2:HowmanyofRLFixer’s suggestedﬁxes are correct?
(3)RQ3:Howdoes RLFixercompare to Footpatch?Table 3: Statistics about the frequency of resource leaks in
theNJRdataset
Tool Output
Total number ofprograms: 287
Programs withat leastone resourceleak: 207
Estimatednumberofuniqueresourceleaks(across
the ﬁve tools)2205
Linesofapplicationcode per benchmark 9911
(4)RQ4:Howlongdoes RLFixertake to generaterepairs?
Thefourquestionsareansweredbythefollowingfourclaims,
whichareinturnvalidatedinthenextfoursubsections(allnumbers
are averagesacrossthe ﬁve resourceleakdetectors).
(1)RLFixersuggestsﬁxesfor66%oftheresource-leakwarnings.
(2) 95%ofthe ﬁxes suggestedbyRLFixerare correct.
(3) RLﬁxerproduces higher quality ﬁxes thanFootpatch.
(4)RLFixertakes,onaverage,1secondsperprogram,excluding
the 13-secondWALAsetuptime.
The experiments were carried out on a machine with 24 Intel(R)
Xeon(R)Silver4116CPUcoresat2.10GHzand188GBRAM.For
the JVM, the default heap size of 32GB, and default stack size of
1MB,wasused.
6.1 RQ1: Fixable Rate
Fixable Rate is the percentage of warnings for which a ﬁx was
suggested.Itisdeﬁnedas:
Fixable Rate =#warnings for whichaﬁxwassuggested
total #warnings
Fig.10givesasplitupoftheﬁxableandunﬁxableresource-leaks
forRLFixeron each of the ﬁve tools. On average, RLFixergets a
66%ﬁxablerate,withPMDgettingthehighestﬁxable-rate(75%).
The unﬁxable resource-leaks are further split based on the reason
they are not ﬁxed: From the graph, we see that the main reason
for unﬁxed leaks are Field Escapes (20%). CF gets a lower ﬁxable-
rate than theothertools because ofa large percentage ofits leaks
beingFieldEscapes .Asmallercontributortounﬁxedleaksare Data-
Structure Escapes (9%). Some 1% of resource leaks escape to both, a
data-structureandaﬁeld.Wereporttheseasdata-structureescapes
tosimplifythegraph.Thelast5%ofleaksarenotﬁxed(inredcolor)
because,asdiscussedinSection 3.4,therearecornercasesforsome
templates that result inundecidable problems.
6.2 RQ2: Fix Correctness
Another important metric is Fix Correctness , the percentage of cor-
rectﬁxes outofthe suggestedﬁxes. Itisdeﬁnedas:
FixCorrectness =#warnings withacorrectﬁxsuggestion
#warnings withaﬁxsuggestion
We picked asampleof150ﬁxes (30 perresource-leakdetector)
suggested by RLFixerto estimate the ﬁx-correctness. We re-ran
the resource-leak detector on the ﬁxed code to ensure that the
old leaks disappeared. For 2 ﬁxes, the old leaks remained, and
166From Leaks to Fixes: AutomatedRepairs forResource LeakWarnings ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Percentage of Resource-Leaks (%)Infer
PMD
CF
Codeguru
Spotbugs
Average
0 25 50 75 100
Fixable rate Unfixed because of Data-Structure Escape
Unfixed because of Field Escape Unfixed for other reasons
Figure 10: Fixable-rate for RLFixer for each resource-leak
detector,along with reasons fortheunﬁxed leaks.
these were marked as incorrect. For the remaining ﬁxes, we had
5 volunteer programmersclassify theﬁxes ascorrect or incorrect.
Thevolunteers,noneofwhomareauthors,arecomputer-science
graduate students who are familiar with Java and resource leaks.
The volunteers classify diﬀerent subsets of the ﬁxes, but each ﬁx is
classiﬁedbyatleast3volunteers.Eachvolunteerusesthefollowing
criteria to evaluate correctness, and a ﬁx is considered incorrect
even if one ofthesecriteriaisnot met.
(1) The ﬁxrepairsthe leak.
(2) The ﬁxdoes not introduce anull-pointer error.
(3)The ﬁx does not introduce a use-after-close error (e.g. ﬁle
written after being closed).
(4) The ﬁxdoes not introduce adoubleclose.
(5) The ﬁxdoes not modify the behaviorofthe program.
Finally,wecomputedtheﬁx-correctnessbytakinganaverage
over the scores of the volunteers. The inter-rater agreement, calcu-
latedusingKrippendorﬀ’sAlpha,is0.86.Thescoresforeachtool
areshowninFig. 11.Onaverage, RLFixer’s ﬁx-correctnessis95%,
with Infer and Codeguru getting near perfect ﬁxes. Given that less
than one in twenty ﬁxes by RLFixerare incorrect, we can put high
conﬁdence inits generatedrepairs.
Examining the small fraction of incorrect ﬁxes shows that there
aretwomajorroadblocksto RLFixerreachingperfectﬁx-correctness.
The ﬁrst is that the deﬁnition for resource-alias analysis works well
inmostcases,butitdoesnotexhaustivelycaptureallthewaysthat
twoJavaobjectscansharearesource.Missedresource-aliasesin
turn giveincorrect ﬁxes.Designingaperfect resource-aliasanal-
ysisishard.Thesecondroadblockisthat RLFixer’s templatesare
designedtoﬁxindividualresource-leaks,andhencedonotwork
perfectly when multiple resource-leaks occur in the same code
block.
Another correctness issue that most repair-tools need to deal
withisfalse-positivewarnings,andwhetheronesuggestsrepairs
forthesefalsewarnings;this,however,doesnotseemtobeanissue
in practice for RLFixer. To get a measure of false-positive warn-
ings, we asked the volunteers to also examine the same 150 repairs
and decide whether the original leak-detector warning was a false
positive. All ﬁve resource-leak detectors gave zero false-positive
Percentage of Correct Fixes (%)0255075100
Infer PMDCF
Codeguru SpotbugsAverageFigure 11: Percentage of correct ﬁxes by RLFixer (i.e. ﬁx-
correctness)fortheﬁve resource-leak detectors
warningsfortheleaksﬁxedby RLFixer.Thislowfalse-positiverate
is expected, since these are all mature tools that have been heavily
engineered to weed out false-positive warnings. Note that there
could still be false-positive warnings among the infeasible-to-ﬁx
leaks,but this doesn’taﬀect RLFixer.
6.3 RQ3: Comparisonwith Footpatch
Table4summarizesthecomparisonbetweenFootpatchand RLFixer.
WeonlyusetheInferwarningsforthecomparisonbecauseFoot-
patch is tightly integrated with Infer; it cannot be used with other
resource-leakdetectors.Wesplittheresultsintotwoparts:theﬁrst
part (columns 2 and 3) shows the results on the warnings from the
NJRbenchmarks,and thesecond part (columns 4and 5)gives the
results onthe apktoolbenchmarkfrom the Footpatch paper [ 61].
FortheNJRbenchmarks,Infergenerates730warnings,forwhich
Footpatchgenerates46ﬁxes,givingusa6%ﬁxable-rate.Theﬁxable-
rateforRLFixer(65%)onNJRisthesameastheInferentryinFig. 10.
For the NJR ﬁx-correctness, we chose a random sample of 30 ﬁxes
for each tool, and evaluated for correctness using the criteria from
Section6.2. Out of the sample of 30 Footpatch ﬁxes, 8 were correct,
givinga27%ﬁx-correctness. RLFixer’s ﬁx-correctness(99%)isthe
sameastheentryforInferinFig. 11.Thus,ontheNJRbenchmarks
RLFixer performs signiﬁcantly better on both, ﬁxable-rate and ﬁx-
correctness.
Forapktool, the only benchmark from the Footpatch paper [ 61]
with Java resource leaks, Infer gives 19 warnings. Out of these 6
are duplicates and we remove them. For the remaining 13 warn-
ings,Footpatchattemptsaﬁxfor1warning(ﬁxable-rate8%),and
RLFixerattemptsaﬁxfor12warnings(ﬁxable-rateof92%).Both
toolsproduceonlycorrectﬁxesforthisbenchmark(ﬁx-correctness
100%).
Thelargegapinﬁx-qualitybetweenFootpatchand RLFixeris
expected;Footpatchisamoregeneralpurposetoolthatworkswith
multiple kinds of errors, as well as on both C and Java. RLFixer, on
the other hand, is specialized for resource-leaks in Java, and hence
isableto vastlyoutperform Footpatch onthis task.
167ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Akshay U/t_ture andJens Palsberg
Table 4: Comparing the repair quality of RLFixer and the
FootpatchbaselinewhenﬁxingtheInferwarnings.Weshow
theresults separately fortheNJRbenchmarks and apktool.
NJRbenchmarks apktool
Tool Fixable
RateFix Cor-
rectnessFixable
RateFix Cor-
rectness
Footpatch 6% 27% 8% 100%
RLFixer 65% 99% 92% 100%
Table5:SplitupofthetimetakenperprogrambyRLFixer
andtheresource-leak detectors
Tool Leakdetector Overallﬁxtime
time(s) WALAsetup
time(s)RLFixer
time(s)
Infer 42 13 1
PMD 6 12 1
Spotbugs 13 13 1
CF 63 12 1
Average 31 13 1
6.4 RQ4: Repair Time
Table5showsthetimetakenperprogramby RLFixerandfourof
theresource-leakdetectors.WedonotreportthetimeforCodeguru
becauseitisonlyaccessibleviaawebservice.Onaverage,resource-
leak detection takes 31 seconds per program, but this varies widely
acrossthefourdetectors.PMDandSpotbugsareveryfast,whereas
InferandCFtakemuchlonger.Theoverallrepairtimeis14seconds
perprogram.Amajorityofthistime(13seconds)istakenbythe
WALA setup, whereas RLFixer, as described in Section 3, takes just
1 second per program because of its demand-driven design. Its ﬁx
time per leak is even lesser. The WALA setup includes tasks like
constructingtheclass-hierarchy,call-graph,basic-blocks, etc.,but
amajority ofthe time istaken for call-graphconstruction.
Call-graph construction is unavoidable for any inter-procedural
analysis, but we could eliminate this component by integrating
RLFixerwithaWALAbasedresource-leakdetector.Since RLFixer
is implemented in the WALA framework, such a design allows
RLFixertoreusetheWALAsetupinformationfromtheresource-
leakdetectorphase.Thiscouldbringthetotalﬁxtimedowntojust
1second.
A direct comparison of repair times with Footpatch is not mean-
ingfulbecause Footpatch suggestsvery fewﬁxes, anditishardto
factor out the time taken by unsuccessful ﬁx attempts and ﬁxes
for other kinds of bugs. However, results from the Footpatch paper
show that it takes several minutes per Java program, which is at
least an order of magnitude larger than RLFixer. There are two
reasonswhy RLFixerisfaster:itisdemand-driven,andunlikeother
Footpatch,itdoesnotneedtoperformasearchoverpossiblerepair
codes; itconstructsﬁxes from repairtemplates.
6.5 Threatsto Validity
Theﬁrstthreattovalidityisthatthehumanvolunteerswhopar-
ticipated in the experiment presented in Section 6.2could makemistakes in their evaluation of the ﬁxes. We mitigate this threat by
averaging scores over multiple volunteers and and a large number
of leaks (150 in total) from diﬀerent tools. Furthermore, we also
re-rantheresource-leakdetectorsontheﬁxedcodetoconﬁrmthat
the resource-leakwarning disappeared.
ThesecondthreatisthatourevaluationwascarriedoutonJava-
8 programs from the NJR-1 dataset. The assumption is that our
results willgeneralize to otherJava benchmarks.
The third threat is the applicability of RLFixer’s approach to
other langauges and platforms, since RLFixer’s design and our
experiments only focusonJava code.
7 RELATED WORK
Theresearchdirectionclosesttothisworkisautomatedprogram
repair,andonecansplitthiscategoryintogeneral-purpose,special-
purpose,andlinter-basedrepairtools.Moredistantlyrelatedare
escapeanalysisandrepairingAndroidresourceleaks.Wediscuss
eachoftheseinturn.
General-purposerepairtools. General-purposerepairtoolsaim
to ﬁx a wide-variety of program errors. Most of these tools are
test-basedtechniques,andcanbesplitintothreeparadigms.The
ﬁrst paradigm, generate-and-validate [ 28,33,45,46,62], generates
candidate patches by searching through existing patches and code.
The second is the deep-learning based paradigm [ 22,29,39,40,
65,67]thatusesdeep-learningtoﬁndpatches,oftenbyapplying
NeuralMachineTranslationmodelsfromNLP.Thethirdsemantics-
based paradigm [ 8,34,35,49,51] generates patches by casting the
repairproblem asa constraint satisfactionproblem. Ultimately, all
three paradigms validate each patch by checking if it passes the
previously failing test case.These paradigmscannotbe appliedto
resource-leaksbecause resource-leaksdo not cause test-failures.
Footpatch [ 61] is the only general-purpose tool which can be
appliedtoresource-leaksbecauseitreliesontheInferstaticanal-
ysis tool instead of tests to verify the ﬁx. It generates patches by
searching thesame code-base for program fragments that address
thegiven bugclass. Itis semi-specialized toheap errors including
null-pointer errors, resource leaks, etc. However, Footpatch has
three shortcomings, compared to RLFixer. Firstly,RLFixerhas an
order-of-magnitude better ﬁxable-rate and ﬁx-correctness (see Sec-
tion6.3). Footpatch pays for its generality with a lower ﬁx quality.
Secondly, RLFixer’s repairtemplates, bydesign, donot modify the
semanticsoftheprogramorintroduceanynewerrors.Ontheother
hand, Footpatch’s notion of correctness is limited to re-running
Infertoensuretheleakdisappreas.Thisdoesnotensurethatthe
semantics of the program are unmodiﬁed and no new errors are
introduced. Thirdly, RLFixeris also much faster; it takes seconds
instead ofminutesorhours.
Special-purpose repair tools. Special-purpose repair tools, as op-
posed to general-purpose tools, focus on repairing a single kind
of error; this enables them to produce much higher quality ﬁxes.
Most of these tools report ﬁxable-rates of 40-70% and a high ﬁx-
correctness, which is very similar to what we see with RLFixer,
and this is usuallysigniﬁcantly higher than what general-purpose
tools can achieve. The kind of errors tackled by special-purpose
toolsincludenull-pointererrors[ 38,66],integeroverﬂows[ 16,50],
168From Leaks to Fixes: AutomatedRepairs forResource LeakWarnings ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
buﬀeroverﬂows[ 55],concurrencyerrors[ 7,30,41],performance
bugs[54], andmemory leaks[ 23,27,37].
Among theexisting special-purpose repairtools,memory-leak
ﬁxing [23,27,37] is the closest to RLFixerbecause it has a simi-
larspeciﬁcation: repairthe leakwithoutmodifying the program’s
semantics.However,thesetoolsfocusonCprograms,andmemory-
leaks present diﬀerentchallenges than resource-leaks. Forexam-
ple, features such as Java’s exception mechanism, its reliance on
try-catchblocksforresourcehandling,resourcealiasing,andthe
presenceofclassﬁeldsaresomechallengesinJavaresource-leak
ﬁxing that donot appear when dealingwithmemory leaksinC.
Unlike all these specialized repair tools, RLFixerfocuses on
resource-leaks, a problem that has not been tackled by any spe-
cialized tool before.Additionally, RLFixer’s demand-drivendesign
makes it signiﬁcantly faster than most special-purpose tools. Most
othertoolsusetime-budgetsofafewminutesormoreperprogram,
whereasRLFixerﬁnishesin1second,plusthe13secondsittakes
for WALAto setupthe call-graph, etc.
Linter-basedrepairtools. Lintersscancodeforstyleorcoding-
conventionviolationsusingpatternmatchingontheAST(Abstract
Syntax Tree). Linter-based repair tools [ 11,21,47,48] use a simi-
larASTpattern-matchingapproachtoapplyrepairsforalinter’s
warnings.Thesetoolsvaryinthecoding-conventionstheytarget,
andintheirmethodoflearningrepairpatterns.Phoenix[ 11]mines
patches from a corpus of GitHub programs, and uses it to learn
generalizedrepairstrategiesthatarerepresentedasexecutablepro-
grams in a domain speciﬁc language (DSL). Styler [ 47] similarly
learnsﬁxpatternsforcode-formattingviolationsfromacorpus,but
it learns using an LSTM neural network. Getaﬁx [ 9] applies a hier-
archical clustering algorithm to eﬀectively summarize ﬁx patterns,
andthenusesanovelrankingtechniquebasedonpasthumanﬁxes
topickthemostplausibleﬁx.TFix[ 12]formulatesthelinter-repair
problemasatext-to-textpredictiontaskandthenusesapre-trained
text-to-text Transformer model to generate ﬁxes. SpongeBugs [ 48]
and Sorald [ 21] create manually deﬁnedﬁx templates for a handful
oflinter violations.
The errors targetted by linter-based repair tools are often lo-
calandcanberepresentedusingASTpatterns.Hence,unlike RL-
Fixer, their techniques will not work for a more complex bug such
asresource-leakswhichrequiresdata-ﬂowtrackingandaninter-
proceduralanalysis.
Escape analysis. Escape analysis[ 18,63] isaresearch direction
that sounds similar to our resource escape analysis from Section 3.3,
but ithas verydiﬀerent designs and goals. Escape analysis charac-
terizeshowobjectsallocatedinoneregionoftheprogramescapeto
codeoutsidethisregion.Itcareslessaboutthekindofprogramcon-
struct(suchasanarrayorﬁeld)itescapesto.Ontheotherhand,our
resource escape analysis computes the kinds of program constructs
(suchasaﬁeldorparameter)thataresourcealiaseswith,andhasno
conceptofregions.Hence,thetwoanalysesenduphavingdiﬀerent
abstract domains,constraints,anddesigndecisions.
Repairing Android Resource Leaks. Android Resource Leaks are
leaksinvolvingevent-drivencontrolﬂowfromAndroidevents,and
arediﬀerentfromtheJavaresourceleaksdiscussedinthispaper,
whichinvolvesequentialcontrolﬂow.Letustakeacloserlookathowthesetwokindsofleaksdiﬀertounderstandwhytheyneed
diﬀerent kinds of repair tools. An Android application is an event-
driven system with event-handlers responding to a sequence of
events such as user-interaction or the application life-cycle events.
For example, Android deﬁnes the event handlers onPause and
onDestroy for when the user pauses and closes an application,
respectively. AndroidResourceLeak detectors[ 44,64]modelthese
eventsequencesandﬁndonesthatcanleaksomeAndroidresource.
Forexample,ifaresourceisnotclosedinthe onPauseoronDestroy
eventhandlers,wemaygetan AndroidResourceLeak .Liuet.al[ 43]
prepareadatabaseofsuch AndroidResourceLeaks .AndroidResource
Leakrepairtoolssuchas[ 10,13,42]thensuggestthecorrectevent-
handler to close the resource in. Hence, all these leak detection
and repair tools for Android Resource Leaks focus exclusively on
Android’s event-driven control ﬂow. On the other hand, tools such
asRLFixerandFootpatch[ 61]focusonJavaresourceleaksresulting
from thecontrol-ﬂowinsequentialJavacode.Thus,they solve a
completely diﬀerent problem than Android Resource Leak repair
tools.
8 CONCLUSION
Resource leaks are an important bug type that need better tool-
supportforautomatedﬁxsuggestions.Inthispaper,weintroduced
RLFixer,theﬁrstspecializedrepairtoolforresourceleaks.Wehigh-
lighted several challenges for the resource leak problem, including
identifyingresource-leaksthatareinfeasibletosolve,identifying
resourcealiases,andconstructingﬁxesthatdonotmodifythese-
manticsoftheexistingprogram.Wethendiscussedhow RLFixer
tackles these challenges using a new demand-driven static analysis
calledresourceescapeanalysis .Finally,weexperimentallyshowed
thatRLFixerrepairsamajorityofresource-leaksinourbenchmarks
withnear perfectcorrectness andvery lowrepairtime.
Therearetwointerestingfuturedirectionsthatweforsee.The
ﬁrstistoinvestigateifthereareanyspecialcasesofﬁeldordata-
structure escapes that are feasible to ﬁx. The second is applying
RLFixer’s templates and resource alias analysis to other object
oriented languages like Python or C#, which have a similar try-
catch-ﬁnallyexception handling style.
9 DATA AVAILABILITYAND EXPERIMENT
REPLICATION
The dataset used for this paper, NJR-1, is publicly available at
thefollowinglink:( https://doi.org/10.5281/zenodo.3897691 ).The
anonymizedartifactforthepaper,includingthesourcecode,experi-
mentalresults,anddetaileddocumentation,arepubliclyavailableat
thefollowingrepository:( https://doi.org/10.5281/zenodo.7592371 ).
TheartifactalsoincludesaVMimagethatcomeswithpre-installed
dependencies, and can be used toquickly reproduce the resultsof
the paper byrunning afewsimplescripts.
ACKNOWLEDGMENTS
This work was supported by the U.S. NSF Award 1823360, and the
ONRAwardN00014-18-1-2037.WealsothanktheFSE’23review-
ersandMichaelAbir fortheirconstructivecommentsthathelped
improve the paper.
169ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Akshay U/t_ture andJens Palsberg
REFERENCES
[1] 2002. PMDSource CodeAnalyzer. https://pmd.github.io .
[2]2015. IBM, “T.J. Watson Libraries for Analysis (WALA),”. http://wala.sourceforge.
net.
[3] 2017. SpotBugsStatic Analysis Tool. https://spotbugs.github.io .
[4] 2019. JavaParser. https://javaparser.org .
[5] 2020. AmazonCodeguru Reviewer. https://aws.amazon.com/codeguru/ .
[6]2022. CommonWeaknessEnumeration(CWE-400). https://cwe.mitre.org/data/
deﬁnitions/400.html .
[7]Christoﬀer Quist Adamsen, Anders Møller, Rezwana Karim, Manu Sridharan,
FrankTip,andKoushikSen.2017. RepairingEventRaceErrorsbyControlling
Nondeterminism. In Proceedings of the 39th International Conference on Software
Engineering (BuenosAires,Argentina) (ICSE’17) .IEEEPress,289–299. https:
//doi.org/10.1109/ICSE.2017.34
[8]Afsoon Afzal, Manish Motwani, Kathryn T. Stolee, Yuriy Brun, and Claire
Le Goues. 2021. SOSRepair: Expressive Semantic Search for Real-World Pro-
gram Repair. IEEE Transactions on Software Engineering 47, 10 (2021), 2162–2181.
https://doi.org/10.1109/TSE.2019.2944914
[9]JohannesBader,AndrewScott,MichaelPradel,andSatishChandra.2019. Getaﬁx:
LearningtoFixBugsAutomatically. Proc.ACMProgram.Lang. 3,OOPSLA,Article
159(oct 2019),27pages. https://doi.org/10.1145/3360585
[10]AbhijeetBanerjee,LeeKeeChong,ClémentBallabriga,andAbhikRoychoudhury.
2018. EnergyPatch:RepairingResourceLeakstoImproveEnergy-Eﬃciencyof
AndroidApps. IEEETransactions onSoftwareEngineering 44,5 (2018),470–490.
https://doi.org/10.1109/TSE.2017.2689012
[11]RohanBavishi,HiroakiYoshida,andMukulR.Prasad.2019. Phoenix:Automated
Data-DrivenSynthesisofRepairsforStaticAnalysisViolations.In Proceedingsof
the201927thACMJointMeetingonEuropeanSoftwareEngineeringConference
and Symposium on the Foundations of Software Engineering (Tallinn, Estonia)
(ESEC/FSE 2019) . Association for Computing Machinery, New York, NY, USA,
613–624. https://doi.org/10.1145/3338906.3338952
[12]Berkay Berabi, Jingxuan He, Veselin Raychev, and Martin Vechev. 2021. TFix:
Learning to Fix Coding Errors with a Text-to-Text Transformer. In Proceedings of
the38thInternationalConferenceonMachineLearning (ProceedingsofMachine
LearningResearch,Vol.139) ,MarinaMeilaandTongZhang(Eds.).PMLR,780–791.
https://proceedings.mlr.press/v139/berabi21a.html
[13]BhargavNagarajaBhattandCarloA.Furia.2022. AutomatedRepairofResource
Leaks in Android Applications. J. Syst. Softw. 192, C (oct 2022), 19 pages. https:
//doi.org/10.1016/j.jss.2022.111417
[14]Cristiano Calcagno, Dino Distefano, Jeremy Dubreil, Dominik Gabi, Pieter
Hooimeijer, Martino Luca, Peter O’Hearn, Irene Papakonstantinou, Jim Pur-
brick,andDulmaRodriguez.2015. MovingFastwithSoftwareVeriﬁcation.In
NASA Formal Methods , Klaus Havelund, Gerard Holzmann, and Rajeev Joshi
(Eds.).SpringerInternational Publishing,Cham,3–11.
[15]LingchaoChen,YichengOuyang,andLingmingZhang.2021.FastandPreciseOn-
the-Fly Patch Validation for All. In 2021 IEEE/ACM 43rd International Conference
onSoftwareEngineering(ICSE) .1123–1134. https://doi.org/10.1109/ICSE43902.
2021.00104
[16]Xi Cheng, Min Zhou, Xiaoyu Song, Ming Gu, and Jiaguang Sun. 2017. IntPTI:
Automatic Integer Error Repair with Proper-Type Inference. In Proceedings of
the 32nd IEEE/ACM International Conference on Automated Software Engineering
(Urbana-Champaign,IL, USA) (ASE ’17). IEEE Press,996–1001.
[17]Sigmund Cherem and Radu Rugina. 2007. Uniqueness Inference for Compile-
TimeObjectDeallocation.In Proceedingsofthe6thInternationalSymposiumon
MemoryManagement (Montreal,Quebec,Canada) (ISMM’07) .Associationfor
ComputingMachinery,NewYork,NY,USA,117–128. https://doi.org/10.1145/
1296907.1296923
[18]Jong-DeokChoi,ManishGupta,MauricioSerrano,VugranamC.Sreedhar,and
Sam Midkiﬀ. 1999. Escape Analysis for Java. In Proceedings of the 14th ACM
SIGPLAN Conference onObject-OrientedProgramming, Systems,Languages, and
Applications (Denver, Colorado,USA) (OOPSLA ’99) . Association for Computing
Machinery, NewYork, NY, USA,1–19. https://doi.org/10.1145/320384.320386
[19]Maria Christakis and Christian Bird. 2016. What Developers Want and Need
from Program Analysis: An Empirical Study. In Proceedings of the 31st IEEE/ACM
InternationalConferenceonAutomatedSoftwareEngineering (Singapore,Singa-
pore)(ASE 2016) . Association for Computing Machinery, New York, NY, USA,
332–343. https://doi.org/10.1145/2970276.2970347
[20]LisaNguyenQuangDo,JamesR.Wright,andKarimAli.2022. WhyDoSoftware
DevelopersUseStaticAnalysisTools?AUser-CenteredStudyofDeveloperNeeds
andMotivations. IEEETransactionsonSoftwareEngineering 48,3(2022),835–847.
https://doi.org/10.1109/TSE.2020.3004525
[21]KhashayarEtemadiSomeoliayi,NicolasYvesMauriceHarrand,SimonLarsén,
Haris Adzemovic, Henry Luong Phu, Ashutosh Verma, Fernanda Madeiral, Dou-
glasWikstrom,andMartinMonperrus.2022.Sorald:AutomaticPatchSuggestions
forSonarQubeStaticAnalysisViolations. IEEETransactionsonDependableand
SecureComputing (2022), 1–1. https://doi.org/10.1109/TDSC.2022.3167316
[22]MichaelFu,ChakkritTantithamthavorn,TrungLe,VanNguyen,andDinhPhung.
2022. VulRepair:AT5-BasedAutomatedSoftwareVulnerabilityRepair.In Pro-
ceedings of the 30th ACM Joint European Software Engineering Conference andSymposium on the Foundations of Software Engineering (Singapore, Singapore)
(ESEC/FSE 2022) . Association for Computing Machinery, New York, NY, USA,
935–947. https://doi.org/10.1145/3540250.3549098
[23]QingGao,YingfeiXiong,YaqingMi,LuZhang,WeikunYang,ZhaopingZhou,
Bing Xie, and Hong Mei. 2015. Safe Memory-Leak Fixing for C Programs. In
Proceedings of the 37th International Conference on Software Engineering - Volume
1(Florence, Italy) (ICSE’15) . IEEE Press,459–470.
[24]Mohammadreza Ghanavati, Diego Costa, Janos Seboek, David Lo, and Artur
Andrzejak. 2020. Memory and Resource Leak Defects and Their Repairs in Java
Projects. Empirical Softw. Engg. 25, 1 (jan 2020), 678–718. https://doi.org/10.
1007/s10664-019-09731-8
[25]Denis Gopan, Thomas Reps, and Mooly Sagiv. 2005. A Framework for Numeric
Analysis of Array Operations. In Proceedings of the 32nd ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages (Long Beach, California,
USA)(POPL ’05) . Association for Computing Machinery, New York, NY, USA,
338–350. https://doi.org/10.1145/1040305.1040333
[26]Samuel Z. Guyer, Kathryn S. McKinley, and Daniel Frampton. 2006. Free-Me: A
StaticAnalysisforAutomaticIndividualObjectReclamation.In Proceedingsofthe
27thACMSIGPLANConferenceonProgrammingLanguageDesignandImplementa-
tion(Ottawa,Ontario,Canada) (PLDI’06) .AssociationforComputingMachinery,
NewYork, NY, USA,364–375. https://doi.org/10.1145/1133981.1134024
[27]Seongjoon Hong, Junhee Lee, Jeongsoo Lee, and Hakjoo Oh. 2020. SAVER:
Scalable, Precise, and Safe Memory-Error Repair. In Proceedings of the ACM/IEEE
42nd International Conference on Software Engineering (Seoul, South Korea) (ICSE
’20).AssociationforComputingMachinery,NewYork,NY,USA,271–283. https:
//doi.org/10.1145/3377811.3380323
[28]Jiajun Jiang, Yingfei Xiong, Hongyu Zhang, Qing Gao, and Xiangqun Chen.
2018. Shaping Program Repair Space with Existing Patches and Similar Code.
InProceedings of the 27th ACM SIGSOFT International Symposium on Software
Testing and Analysis (Amsterdam, Netherlands) (ISSTA 2018) . Association for
ComputingMachinery,NewYork,NY,USA,298–309. https://doi.org/10.1145/
3213846.3213871
[29]Nan Jiang, Thibaud Lutellier, and Lin Tan. 2021. CURE: Code-Aware Neural
MachineTranslationforAutomaticProgramRepair.In Proceedingsofthe43rd
International Conference on Software Engineering (Madrid, Spain) (ICSE ’21) . IEEE
Press,1161–1173. https://doi.org/10.1109/ICSE43902.2021.00107
[30]Guoliang Jin, Linhai Song, Wei Zhang, Shan Lu, and Ben Liblit. 2011. Automated
Atomicity-Violation Fixing. In Proceedings of the 32nd ACM SIGPLAN Conference
onProgrammingLanguageDesignandImplementation (SanJose,California,USA)
(PLDI ’11) . Association for Computing Machinery, New York, NY, USA, 389–400.
https://doi.org/10.1145/1993498.1993544
[31]Brittany Johnson, Yoonki Song, Emerson Murphy-Hill, and Robert Bowdidge.
2013. WhyDon’tSoftwareDevelopersUseStaticAnalysisToolstoFindBugs?.
InProceedings of the 2013 International Conference on SoftwareEngineering (San
Francisco, CA, USA) (ICSE’13) . IEEE Press,672–681.
[32]Martin Kellogg, Narges Shadab, Manu Sridharan, and Michael D. Ernst. 2021.
LightweightandModularResourceLeakVeriﬁcation.In Proceedingsofthe29th
ACM Joint Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering (Athens, Greece) (ESEC/FSE 2021) .
Association for Computing Machinery, New York, NY, USA, 181–192. https:
//doi.org/10.1145/3468264.3468576
[33]Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Automatic
PatchGenerationLearnedfromHuman-WrittenPatches.In Proceedingsofthe
2013InternationalConferenceonSoftwareEngineering (SanFrancisco,CA,USA)
(ICSE’13) . IEEE Press,802–811.
[34]Xuan-Bach D. Le, Duc-Hiep Chu, David Lo, Claire Le Goues, and Willem Visser.
2017. JFIX:Semantics-BasedRepairofJavaProgramsviaSymbolicPathFinder.
InProceedings of the 26th ACM SIGSOFT International Symposium on Software
Testing and Analysis (Santa Barbara, CA, USA) (ISSTA 2017) . Association for
ComputingMachinery,NewYork,NY,USA,376–379. https://doi.org/10.1145/
3092703.3098225
[35]Xuan-Bach D. Le, Duc-Hiep Chu, David Lo, Claire Le Goues, and Willem Visser.
2017. S3: Syntax- and Semantic-Guided Repair Synthesis via Programming
by Examples. In Proceedings of the 2017 11th Joint Meeting on Foundations of
Software Engineering (Paderborn, Germany) (ESEC/FSE 2017) . Association for
ComputingMachinery,NewYork,NY,USA,593–604. https://doi.org/10.1145/
3106237.3106309
[36]Thanh Le-Cong, Hong Jin Kang, Truong Giang Nguyen, Stefanus Agus Hary-
ono,DavidLo,Xuan-BachD.Le,andQuyetThangHuynh.2022. AutoPruner:
Transformer-Based Call Graph Pruning. In Proceedings of the 30th ACM Joint
European Software Engineering Conference and Symposium on the Foundations
of Software Engineering (Singapore, Singapore) (ESEC/FSE 2022) . Association for
ComputingMachinery,NewYork,NY,USA,520–532. https://doi.org/10.1145/
3540250.3549175
[37]Junhee Lee, Seongjoon Hong, and Hakjoo Oh. 2018. MemFix: Static Analysis-
BasedRepairofMemoryDeallocationErrorsforC.In Proceedingsofthe201826th
ACM Joint Meeting on European Software Engineering Conference and Symposium
170From Leaks to Fixes: AutomatedRepairs forResource LeakWarnings ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
ontheFoundationsofSoftwareEngineering (LakeBuenaVista,FL,USA) (ESEC/FSE
2018).AssociationforComputingMachinery,NewYork,NY,USA,95–106. https:
//doi.org/10.1145/3236024.3236079
[38]Junhee Lee, Seongjoon Hong, and Hakjoo Oh. 2022. NPEX: Repairing Java
Null Pointer Exceptions without Tests. In Proceedings of the 44th International
Conference on Software Engineering (Pittsburgh, Pennsylvania) (ICSE ’22) . As-
sociation for Computing Machinery, New York, NY, USA, 1532–1544. https:
//doi.org/10.1145/3510003.3510186
[39]Yi Li, Shaohua Wang, and Tien N. Nguyen. 2020. DLFix: Context-Based Code
TransformationLearningforAutomatedProgramRepair.In Proceedingsofthe
ACM/IEEE42ndInternationalConferenceonSoftwareEngineering (Seoul,South
Korea)(ICSE’20) .AssociationforComputingMachinery,NewYork,NY,USA,
602–614. https://doi.org/10.1145/3377811.3380345
[40]YiLi,ShaohuaWang,andTienN.Nguyen.2022. DEAR:ANovelDeepLearning-
Based Approach for Automated Program Repair. In Proceedings of the 44th
International Conference on Software Engineering (Pittsburgh, Pennsylvania)
(ICSE’22) . Association for ComputingMachinery, NewYork, NY, USA, 511–523.
https://doi.org/10.1145/3510003.3510177
[41]Haopeng Liu, Yuxi Chen, and Shan Lu. 2016. Understanding and Generating
HighQualityPatchesforConcurrencyBugs.In Proceedingsofthe201624thACM
SIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering (Seattle,
WA,USA) (FSE2016) .AssociationforComputingMachinery,NewYork,NY,USA,
715–726. https://doi.org/10.1145/2950290.2950309
[42] Jierui Liu,Tianyong Wu, Jun Yan, and JianZhang.2016. Fixing Resource Leaks
inAndroidAppswithLight-WeightStaticAnalysisandLow-OverheadInstru-
mentation. In 2016 IEEE 27th International Symposium on Software Reliability
Engineering (ISSRE) . 342–352. https://doi.org/10.1109/ISSRE.2016.15
[43]YepangLiu,JueWang,LiliWei,ChangXu,Shing-ChiCheung,TianyongWu,Jun
Yan,andJianZhang.2019. DroidLeaks:acomprehensivedatabaseofresource
leaks in Android apps. Empirical Software Engineering 24 (12 2019), 1–49. https:
//doi.org/10.1007/s10664-019-09715-8
[44]YepangLiu,ChangXu,Shing-ChiCheung,andValerioTerragni.2016. Under-
standingandDetectingWakeLockMisusesforAndroidApplications.In Proceed-
ingsofthe201624thACMSIGSOFTInternationalSymposiumonFoundationsofSoft-
ware Engineering (Seattle, WA, USA) (FSE 2016) . Association for Computing Ma-
chinery, New York, NY, USA, 396–409. https://doi.org/10.1145/2950290.2950297
[45]FanLong and Martin Rinard.2015. StagedProgram Repair with Condition Syn-
thesis.In Proceedingsofthe201510thJointMeetingonFoundationsofSoftware
Engineering (Bergamo, Italy) (ESEC/FSE 2015) . Association for Computing Ma-
chinery, New York, NY, USA, 166–178. https://doi.org/10.1145/2786805.2786811
[46]Fan Long and Martin Rinard. 2016. Automatic Patch Generation by Learning
Correct Code. SIGPLANNot. 51,1 (jan 2016),298–312. https://doi.org/10.1145/
2914770.2837617
[47]BenjaminLoriot,FernandaMadeiral, andMartin Monperrus.2022. Styler: Learn-
ingFormattingConventionstoRepairCheckstyleViolations. EmpiricalSoftw.
Engg.27,6 (nov2022),36pages. https://doi.org/10.1007/s10664-021-10107-0
[48]Diego Marcilio, Carlo A. Furia, Rodrigo Bonifácio, and Gustavo Pinto. 2020.
SpongeBugs: Automatically generating ﬁx suggestions in response to static
code analysis warnings. Journal of Systems and Software 168 (2020), 110671.
https://doi.org/10.1016/j.jss.2020.110671
[49]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scalable
MultilineProgramPatchSynthesisviaSymbolicAnalysis.In Proceedingsofthe
38thInternationalConferenceonSoftwareEngineering (Austin,Texas) (ICSE’16) .
Association for Computing Machinery, New York, NY, USA, 691–701. https:
//doi.org/10.1145/2884781.2884807
[50]PaulMuntean,MartinMonperrus,HaoSun,JensGrossklags,andClaudiaEckert.
2021. IntRepair: Informed Repairing of Integer Overﬂows. IEEE Transactions on
Software Engineering 47, 10 (2021), 2225–2241. https://doi.org/10.1109/TSE.2019.
2946148
[51]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra.2013. SemFix:Programrepairviasemanticanalysis.In 201335thInternational
Conference on Software Engineering (ICSE) . 772–781. https://doi.org/10.1109/
ICSE.2013.6606623
[52]H.D. Pande, W.A. Landi, and B.G. Ryder. 1994. Interprocedural def-use associ-
ations for C systems with single level pointers. IEEE Transactions on Software
Engineering 20,5 (1994), 385–403. https://doi.org/10.1109/32.286418
[53]CaitlinSadowski,EdwardAftandilian,AlexEagle,LiamMiller-Cushon,andCiera
Jaspan.2018. LessonsfromBuildingStaticAnalysisToolsatGoogle. Commun.ACM61,4 (mar2018),58–66. https://doi.org/10.1145/3188720
[54]Marija Selakovic and Michael Pradel. 2015. Poster: Automatically Fixing Real-
WorldJavaScriptPerformanceBugs.In 2015IEEE/ACM37thIEEEInternational
Conference on Software Engineering , Vol. 2. 811–812. https://doi.org/10.1109/
ICSE.2015.260
[55]AlexShaw,DustenDoggett,andMunawarHaﬁz.2014. AutomaticallyFixingC
BuﬀerOverﬂowsUsingProgramTransformations.In Proceedingsofthe201444th
AnnualIEEE/IFIPInternationalConferenceonDependableSystemsandNetworks
(DSN ’14) . IEEE ComputerSociety, USA, 124–135. https://doi.org/10.1109/DSN.
2014.25
[56]Manu Sridharan, Denis Gopan, Lexin Shan, and Rastislav Bodík. 2005. Demand-
DrivenPoints-toAnalysisforJava.In Proceedingsofthe20thAnnualACMSIG-
PLANConference on Object-OrientedProgramming,Systems,Languages, and Ap-
plications (SanDiego,CA,USA) (OOPSLA’05) .AssociationforComputingMa-
chinery, NewYork, NY, USA,59–76. https://doi.org/10.1145/1094811.1094817
[57]Emina Torlak and Satish Chandra. 2010. Eﬀective Interprocedural Resource
Leak Detection. In Proceedings of the 32nd ACM/IEEE International Conference on
SoftwareEngineering-Volume1 (CapeTown,SouthAfrica) (ICSE’10) .Association
for Computing Machinery, New York, NY, USA, 535–544. https://doi.org/10.
1145/1806799.1806876
[58]Akshay Utture, Christian Gram Kalhauge, Shuyang Liu, and Jens Palsberg. 2020.
NJR-1Dataset .https://doi.org/10.5281/zenodo.4839913
[59]Akshay Utture, Shuyang Liu, Christian Gram Kalhauge, and Jens Palsberg. 2022.
StrikingaBalance:PruningFalse-PositivesfromStaticCallGraphs.In Proceed-
ings of the 44th International Conference on Software Engineering (Pittsburgh,
Pennsylvania) (ICSE’22) . Association for ComputingMachinery, NewYork, NY,
USA,2043–2055. https://doi.org/10.1145/3510003.3510166
[60]Akshay Utture and Jens Palsberg. 2022. Fast and Precise Application Code
AnalysisUsingaPartialLibrary.In Proceedingsofthe44thInternationalConference
on Software Engineering (Pittsburgh, Pennsylvania) (ICSE ’22) . Association for
ComputingMachinery,NewYork,NY,USA,934–945. https://doi.org/10.1145/
3510003.3510046
[61]RijnardvanTonderandClaireLeGoues.2018. StaticAutomatedProgramRepair
forHeapProperties.In Proceedingsofthe40thInternationalConferenceonSoftware
Engineering (Gothenburg, Sweden) (ICSE ’18) . Associationfor ComputingMa-
chinery, New York, NY, USA, 151–162. https://doi.org/10.1145/3180155.3180250
[62]WestleyWeimer,ThanhVuNguyen,ClaireLeGoues,andStephanieForrest.2009.
Automatically ﬁnding patches using genetic programming. In 2009 IEEE 31st
International Conference on Software Engineering . 364–374. https://doi.org/10.
1109/ICSE.2009.5070536
[63]John Whaley and Martin Rinard. 1999. Compositional Pointer and Escape Anal-
ysis for Java Programs. In Proceedings of the 14th ACM SIGPLAN Conference
on Object-Oriented Programming, Systems, Languages, and Applications (Denver,
Colorado, USA) (OOPSLA ’99) . Association for Computing Machinery, New York,
NY, USA,187–206. https://doi.org/10.1145/320384.320400
[64]Tianyong Wu, Jierui Liu, Zhenbo Xu, Chaorong Guo, Yanli Zhang, Jun Yan, and
Jian Zhang. 2016. Light-Weight, Inter-Procedural and Callback-Aware Resource
Leak Detection for Android Apps. IEEE Transactions on Software Engineering 42,
11(2016), 1054–1076. https://doi.org/10.1109/TSE.2016.2547385
[65]Chunqiu Steven Xia and LingmingZhang. 2022. Less Training, More Repairing
Please: Revisiting Automated Program Repair via Zero-Shot Learning. In Pro-
ceedings of the 30th ACM Joint European Software Engineering Conference and
Symposium on the Foundations of Software Engineering (Singapore, Singapore)
(ESEC/FSE 2022) . Association for Computing Machinery, New York, NY, USA,
959–971. https://doi.org/10.1145/3540250.3549101
[66]Xuezheng Xu, Yulei Sui, Hua Yan, and Jingling Xue. 2019. VFix: Value-Flow-
Guided Precise Program Repair for Null Pointer Dereferences. In Proceedings
ofthe41stInternationalConferenceonSoftwareEngineering (Montreal,Quebec,
Canada)(ICSE’19) .IEEEPress,512–523. https://doi.org/10.1109/ICSE.2019.00063
[67]He Ye, Matias Martinez, and Martin Monperrus. 2022. Neural Program Re-
pair with Execution-Based Backpropagation. In Proceedings of the 44th Inter-
national Conference on Software Engineering (Pittsburgh, Pennsylvania) (ICSE
’22). Association for Computing Machinery, New York, NY, USA, 1506–1518.
https://doi.org/10.1145/3510003.3510222
Received 2023-02-02; accepted 2023-07-27
171