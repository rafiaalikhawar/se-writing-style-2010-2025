Finding Broken LinuxConfiguration Specifications
byStatically Analyzing the KconfigLanguage
Jeho Ohâˆ—
Universityof Texasat Austin
Austin, TX, USA
jeho.oh@utexas.eduNecip FazÄ±lYÄ±ldÄ±ranâˆ—
Universityof CentralFlorida
Orlando, FL, USA
yildiran@knights.ucf.edu
JulianBraha
Universityof Central Florida
Orlando, FL, USA
julianbraha@knights.ucf.eduPaul Gazzillo
Universityof CentralFlorida
Orlando, FL, USA
paul.gazzillo@ucf.edu
ABSTRACT
Highly-configurablesoftwareunderpinsmuchofourcomputing
infrastructure.Itenablesextensivereuse,butopensthedoortobro-
kenconfigurationspecifications.Theconfigurationspecification
language, Kconfig, is designed to prevent invalid configurations
of the Linux kernel from being built. However, the astronomical
sizeoftheconfigurationspaceforLinuxmakesfindingspecifica-
tion bugs difficult by hand or with random testing. In this paper,
weintroduceasoftwaremodelcheckingframeworkforbuilding
Kconfig static analysis tools. We develop a formal semantics of
theKconfiglanguageandimplementthesemanticsinasymbolic
evaluator called kclause that models Kconfig behavior as logi-
cal formulas. We then design and implement a bug finder, called
kismet, that takes kclause models and leverages automated theo-
remprovingtofindunmetdependencybugs. kismetisevaluated
for its precision, performance, and impacton kernel development
for a recent version of Linux, which has over 140,000 lines of Kcon-
fig across 28 architecture-specific specifications. Our evaluation
finds781bugs(151whenconsideringsharingamongKconfigspeci-
fications)with100%precision,spendingbetween37and90minutes
for eachKconfig specification, althoughit missessome bugs due to
underapproximation.Comparedtorandomtesting, kismetfinds
substantially more true positive bugsinafractionofthe time.
CCS CONCEPTS
Â·Softwareanditsengineering â†’Softwareconfigurationman-
agementandversioncontrolsystems ;Automatedstaticanal-
ysis;Software testinganddebugging .
KEYWORDS
software configuration, Kconfig, formal verification, static analysis
âˆ—Co-firstauthors.
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™21, August 23Å›28,2021, Athens,Greece
Â©2021 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-8562-6/21/08...$15.00
https://doi.org/10.1145/3468264.3468578ACMReference Format:
JehoOh,NecipFazÄ±lYÄ±ldÄ±ran,JulianBraha,andPaulGazzillo.2021.Find-
ing Broken Linux Configuration Specifications by Statically Analyzing the
Kconfig Language. In Proceedings of the 29th ACM Joint European Software
Engineering Conference and Symposium on the Foundations of Software Engi-
neering (ESEC/FSE â€™21), August 23Å›28, 2021, Athens, Greece. ACM, New York,
NY, USA, 13pages.https://doi.org/10.1145/3468264.3468578
1 INTRODUCTION
Highly-configurablesoftware productlines underpin much ofour
computing infrastructure, because configurability enables reuse
without having to reprogram the software for new devices or
applications. The Linux kernel is one such example of highly-
configurable software that is used in billions of computing devices.
Withover15,000configurationoptionscontrollingeverythingfrom
drivers, architecture, memory management, and more, there are
over215,000combinations,ifonlyconsideringBooleanoptions.This
extremeconfigurabilitymakesitswidespreadusepossible,butalso
opens the door to invalid configurations, which produce broken
variations ofthe software.
To mitigate the chance of misconfiguration, developers provide
configurationspecifications ,whichdefinetheintendedcombinations
ofconfiguration options. Thesespecificationsmay be as simpleas
a text file describing configuration instructions, or as sophisticated
asamachine-readablespecificationenforcedatbuildtime.These
specifications, if only implicitly, define a software product lineâ€™s
featuremodel ,i.e.,thelegalconfigurationsofthesoftware.InLinux
and other systems software, such as BusyBox and coreboot, devel-
opersusetheKconfiglanguagetospecifyconfigurationoptions,as
well as theirdependencies.
While Linux is effectively a software product line, its specifi-
cation language, Kconfig, is unlike typical feature modeling lan-
guages [47]. Kconfig has complex semantics and additional lan-
guage features, such as invisible variables, automated option selec-
tion,anduser-interfacesupport.Withover140,000linesofKconfig
specifications in the Linux kernel, its complex behavior makes
maintenance challenging. One example is the common pitfall high-
lighted in Kconfigâ€™s manual [ 28], theunmet dependency bug . These
bugs lead to illegal configurations when developers unwittingly
mixconflictingconstructsindependencyspecifications.Withthou-
sands of potentially vulnerable constructs and an ever-changing
893
ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece JehoOh,Necip FazÄ±l YÄ±ldÄ±ran,Julian Braha, andPaulGazzillo
specification, finding such bugs by hand is a practically impossible
task.
ExistingworkontheanalysisofKconfigisfocusedonextracting
a feature model, rather than checking for Kconfig bugs. Having
aLinuxfeaturemodelhasbeenusefulforapplicationsoutsideof
Kconfig,includingmeasuringfeaturemodelhierarchies[ 10,44,45],
supportingvariability-awareanalysisofC[ 11,18,20,24,26,27,31,
51,56,58],anddeadcodeelimination[ 52,53].However,thesetools
makeassumptionsaboutKconfigsemanticsthat,whileappropriate
fortheirrespectiveapplications,makethemlessamenabletobug
finding. For instance, KconfigReader explicitly omits modeling the
language semantics that lead to unmet dependencies, leaving a
checker as a separate problem [ 25,30]. The other tools do the
sameandhavelesssupportforKconfigsemantics,omittingsome
partsoftheLinux featuremodelaltogether[ 16,45].Moreover, by
focusingonfeaturemodeling,priortoolsbakeindecisionsabout
theanalysisdomain,i.e.,afeaturemodel,whichlimitsthefeasibility
of repurposing the work for Kconfig bug finding and other source
level tools.
Inthispaper,weintroduceasoftwaremodelcheckingframework
for building Kconfig static analysis tools. Inspired by model check-
ingframeworksforprogramcode[ 1],webaseourstaticanalysison
ournewly-developedformalsemanticsoftheKconfiglanguageand
leverage automated theorem proving to model Kconfig behavior
andfindbugs.OfexistingdescriptionsofKconfigsemantics,allbut
one are either informal or example-based [ 15,16] which, having
no formalization, are not amenable to automated reasoning. The
one prior formal semantics uses an idealized Kconfig syntax rather
thanKconfigâ€™sactualgrammar,ismissinglanguagebehavior(in-
cluding that leading to unmet dependencies), and uses an abstract
domaindesignedforfeaturemodeling[ 43].Incontrast,wedevelop
a formal semantics of the concrete behavior of Kconfig when it
checks a configuration fileâ€™s validity. We define our semantics over
the syntax derived from Kconfigâ€™s actual implementation, which
contains a bisongrammarspecification.
This approach to Kconfig semantics has three key benefits over
prior efforts. First, it is formal, making it possible to use automated
reasoningtools.Second,itisconcrete,whichdecouplesthedescrip-
tion of Kconfig semantics from any particular analysis objective.
This leaves decisions about how to abstract Kconfig behavior to
specific applications and should reduce future effort to design new
Kconfig analyses. Third, it simplifies modeling Kconfig since, as
we show, we can methodically derive an abstraction of Kconfig
behaviorfrom this concrete semantics.
Todemonstratetheutilityofourapproach,wedesignandimple-
mentananalysisthatfindstheunmetdependencybugshighlighted
inKconfigâ€™s manualandis, toour knowledge, thefirststatic anal-
ysis for finding such bugs. We first define the bug as a formal
propertyintermsofthesemantics,thenshow howacheckercan
bemethodicallyderivedfromthesemantics.Weunderapproximate
non-Boolean options and use aggressive optimization to yield a
bug-finder that isboth fast and very precise. Moreover, itcan also
automatically localize and generate test cases for the unmet depen-
dency bugs it finds. The trade-off is decreased recall due to false
negatives,althoughweshowthatthesearelesscommonduetothe
rarity ofnon-Boolean options.Weimplementthebug-finderandevaluateitonarecentversion
of the Linux kernel source, which contains over 140,000 lines of
Kconfigdescribing28architecture-specificKconfigspecifications.
Our results show that our bug finding is both precise and fast.
The bug-finder finds 781 alarms (151 when considering sharing
amongKconfigspecifications)overallLinuxkernelarchitecturesâ€™
Kconfig specifications, all of which are verified true positives, for a
precisionof100%.Whilesuchprecisionmightbeunusuallyhigh
foraprogramminglanguageanalyzer,theKconfiglanguagehasno
iteration or recursion that would require overapproximation. With
ouroptimizations,ourbugfindertakesanaverageof40minutes
for one Kconfig specification, checking over 10,000constructs.
While we are still in the process of reporting all bugs found
by our tool, Linux maintainers have so far already confirmed 38
ofourreportsandcommitted15ofourpatchesintothemainline
Linux kernel repository,demonstratingthe utility ofourtooling.
Committingpatchesisamanualprocess,requiringdiscussionwith
kernel maintainers, so investigating, reporting, and submitting
patchesfor the alarms isongoing.
Since, to our knowledge, no other static bug finder for unmet
dependencies exists, we compare to Kconfigâ€™s built-in randconfig
tool,thede factostandardrandomconfiguration testingtoolused
byLinuxmaintainersandtheIntel0-daytestservice[ 5].Giventhe
sameamountoftimetofindbugs, randconfig yieldsonly98alarms
comparedtoourtoolâ€™s781.Evenlettingrandomtestingrunforover
fourdaysforeachKconfigspecification,135xlongerthanourtoolâ€™s
totaltime,the testingapproach stillonlyfinds 175bugs,farfewer
than our tool. The random testing approach did find eight bugs
missedbyourtool,reflectingthetradeoffinperformancegained
by underapproximation. Even with this limitation, ourtoolfinds
manymorebugswhiletakingfarlesstime,ausefulcomplementto
testing.
In summary,this paper makes the following contributions:
â€¢A formal semantics of Kconfigâ€™s concrete behavior (Sec-
tion3).
â€¢Anefficientdesignofabug-finderandlocalizerforunmet
dependency bugs(Section 4).
â€¢An implementation of the bug finder, along with reusable
componentsfor creating Kconfig analyzers (Section 5).
â€¢An experimental evaluation of the bug finderâ€™s precision,
performance,andimpact (Section 6).
2 OVERVIEW
In this section we introduce the Kconfig language, illustrate an
unmet dependency bug, and summarize how our formal semantics
enables the designofastaticanalysisto find such bugs.
2.1 Introductionto theKconfigLanguage
Figure1isasimplifiedsnippetofKconfigfromLinuxv5.4.4.Con-
figurationoptionsaredefinedwiththe configconstruct(lines 1,
7,and12).Insideeach configdeclarationisablockofconstructs
thatdefinetheoptionâ€™stype(e.g.Boolean),constraintsonitsuse,
andtextusedbyKconfig to populate auserinterface.
Lines2,8,and13arethetypedeclarations.A booloption(line 8)
hastwopossiblesettings, yorn.ymeansthefeatureisonandcom-
piled into the kernel, and nmeans the feature is off and omitted
894Finding Broken LinuxConfigurationSpecificationsby StaticallyAnalyzingthe Kconfig Language ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
1configTOUCHSCREEN_ADC
2 tristate
3 prompt"Generic ADC based touchscreen"
4 depends on IIO && INPUT_TOUCHSCREEN
5 selectIIO_BUFFER_CB
6
7configIIO_BUFFER
8 bool
9 prompt"Enable buffer support within IIO"
10 depends on IIO
11
12configIIO_BUFFER_CB
13 tristate
14 prompt"IIO callback buffer"
15 depends on IIO && IIO_BUFFER
Figure 1: An example Kconfig specification that allows an
unmet dependency violation and leads to a build error.
Adapted from Linux source: drivers/input/touchscreen/K-
config,drivers/iio/Kconfig,anddrivers/iio/buffer/Kconfig.
fromthekernel.A tristate option(lines 2and13)addsanaddi-
tionalsetting, m.mislikeyexceptthatthebuildsystemcompiles
a loadable kernel module instead of linking to the main kernel
binary [28].
tristate andboolarethemostcommonconfigurationoptions,
representingmore than95% of options inthe Linux Kconfigspeci-
fications.Theotherpossibletypesare stringforstrings, intfor
decimal integers,and hexfor hexadecimal numbers.
Constraints on options are defined using depends on (lines4,
10, and15) andselect(line5), but the Kconfig language prohibits
circular dependencies. depends on defines a direct dependency ,
whichprovidesrequirementsthatshouldholdbeforetheoptioncan
beenabled.ThedependencyisexpressedwithaBooleanexpression
ofotheroptions.Forinstance,line 4meansthat TOUCHSCREEN_ADC
may not be enabled unless IIO && INPUT_TOUCHSCREEN is true,
i.e.,when both IIOandINPUT_TOUCHSCREEN are alsoenabled.
Areversedependency ,givenbythe selectconstruct,invertsthe
dependencyrelationshipbyforcingthetargetoftheselecttobeen-
abled. For instance, line 5means that whenever TOUCHSCREEN_ADC
is enabled, IIO_BUFFER_CB is forced to be enabled. A reverse de-
pendencycanonlyenableanotheroption,notdisableit,andonly
applies to boolortristate options.Kconfig permits reverse de-
pendencies to override direct dependencies , which can lead to unmet
dependency bugs.
Optionswithapromptare visibleoptionsthatausermayenable.
Thepromptconstruct defines the prompt string for use in a user
interface(lines 3,9,and14).Non-visibleoptions,i.e.,thosewithno
promptconstruct, canonlybe set by a selectconstruct ortakea
specification-defineddefaultvalue(notshowninthisexample).The
visibility of an option affects the behavior of a configconstruct in
subtle ways, which we describe in the formal semantics of Kconfig.AnUnmetDependencyBugintheWild. Figure1hasanunmetde-
pendencybugfoundbyourautomatedanalysis.Allthreeofthecon-
figurationoptionsdefinedinthisexample controlspecificCcom-
pilationunitsthatareonlybuiltintothekernelwhentheoptionsare
enabled.IIO_BUFFER_CB controlsindustrialio-buffer-cb.o and
IIO_BUFFER controlindustrialio-buffer.o .
industrialio-buffer-cb.o calls functions that are defined in
industrialio-buffer.o , so the former cannot be built without
thelatter,otherwisetherewouldbeabuilderror.Thedevelopers
capture this build dependency with a direct dependency in the
definitionofthe IIO_BUFFER_CB option(line 15).Thisconstraint,
by itself, would prevent a user from giving a configuration that
leads to the builderror.
Theselect IIO_BUFFER_CB constructonline 5,however,can
overridethisdirectdependencyundercertainconditions.Specifi-
cally, if auser (oranother select)enables TOUCHSCREEN_ADC , the
selectautomaticallyforce-enables IIO_BUFFER_CB .Kconfigper-
mitssuchaconfigurationtoproceedtobuild,albeitwithawarning.
Still, the build will fail, and the userwill have to manually correct
theirconfigurationfile inorder to avoid the unmet dependency.
WhiletheKconfigdocumentationwarnsof selectâ€™spitfallsand
recommends not using it to override dependencies, it is difficult
tocheckbyhandwhetheranyofits17,000+useshaveanunmet
dependency bug.
2.2 AnUnmetDependenciesBug Finder
We create a formal model of the unmet dependency bug according
tothesemanticsofKconfig.First,wemodelthespaceofvalidKcon-
fig configurations in formal logic automatically with our symbolic
evaluator kclause. Next,kismetgenerates verification conditions
to prove the absence of an unmet dependency for each select
construct in the Kconfig specification. Not all reverse dependen-
cies can cause unmet dependencies, so kismetneeds to consider
constraints from all configuration options to rule out infeasible
ones. The resulting verification conditions are discharged to the
Z3SMTsolver[ 13]. When anunmet dependencycannotbe ruled
out,kismetraises an alarm. It then switches to test case genera-
tion, converting any counterexamples to Linux configuration files.
kismetuses these tests on Kconfig and the build system to expose
real bugs.
Toseehow kclause modelsdependencies,takeFigure 1â€™sdefini-
tionofTOUCHSCREEN_ADC (line1).Sinceithasnoreversedependen-
cies, it can only be enabled when its direct dependencies hold, i.e.,
enabling TOUCHSCREEN_ADC impliesIIOandINPUT_TOUCHSCREEN
are alsoboth enabled:
TOUCHSCREEN_ADC â†’IIOâˆ§INPUT_TOUCHSCREEN
When an option has reverse dependencies, its direct dependencies
do not have to hold if its reverse dependencies already do. For
instance,enabling IIO_BUFFER_CB (line12)impliesthatitsdirect
orreversedependencies hold:
IIO_BUFFER_CB â†’(IIOâˆ§IIO_BUFFER
âˆ¨TOUCHSCREEN_ADC )
Anunmetdependencyhappenswhenanoptionâ€™sreversedepen-
dencies hold but its direct dependencies do not. For instance, an
unmetdependencyhappenswhen TOUCHSCREEN_ADC force-enables
895ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece JehoOh,Necip FazÄ±l YÄ±ldÄ±ran,Julian Braha, andPaulGazzillo
kconfig ::=statement +
statement ::=config|choice
config::=configsymbol type constrnts select *
choice::=choicetype constrnts config +endchoice
type::=bool|tristate
constrnts ::=prompt depends +default+
prompt ::=promptwordifexpr
default ::=default valifexpr
depends ::=depends on expr
select::=selectsymbolifexpr
expr::=expr&&expr|expr||expr|!expr|symbol
val::=y|n
Figure 2:Formalsyntaxofacore fragment ofKconfig.
IIO_BUFFER_CB even though IIO_BUFFER_CB â€™s direct dependen-
cies are infeasible. This unmet dependency can be formalized as
follows:
TOUCHSCREEN_ADC âˆ§ (IIOâˆ§INPUT_TOUCHSCREEN )
âˆ§IIO_BUFFER_CB âˆ§ Â¬(IIOâˆ§IIO_BUFFER )
kismettriestoprovethe negationofthiscondition,sinceitverifies
theabsenceofunmetdependencies.Iftheprooffails, kismetraises
an alarm andswitchesto test casegeneration.
3 THE SEMANTICS OFKCONFIG
TheKconfiglanguageisadeclarativeconfigurationspecification
language.At its core,Kconfig takes aconfigurationfile,which is
a mapping from configuration options to their concrete values,
and determines whether the configuration file is valid according
to the developerâ€™s specifications. Developers use Kconfig language
constructstodefineconfigurationoptions,declaringtheirnames,
types, and any dependencies they have on other configuration
options. Kconfig also supports user interfaces, and the language
has additional constructs, such as help, to specify text elements of
theinterface.Thesedonotaffectthebuildabilityofconfiguration
filesandactas comments.
We developed this formal semantics by studying the Kconfig
manual,Kconfigâ€™ssourcecode,aswellasinformaldescriptionsand
examplesfrompriorwork[ 15,16].Tocheckthefidelityofthese-
mantics, we used new and existing benchmarks [ 15,16], generated
randomconfigurationfilesfedtoKconfigasinput,andevaluated
thispaperâ€™sbug-finder,whichrequiresacorrectsemanticsforits
analysistobeprecise.Giventhesizeofthesemantics,havingdozens
of rules and still more syntactic sugar rules, we highlight a core
fragment of the language here, and documentthe remaining rules
inan openly-archivedformalsemantics [ 40].
3.1 ConfigurationDeclarations
Figure2shows the syntax of a core fragment of the Kconfig lan-
guage for boolconfiguration options. A kconfigfile contains a list
ofstatement s, which are either a configuration option declaration
orachoiceconstruct.Aconfigurationoption, config,hasatype,con-
straints for direct dependencies, and zero or more selectconstructs
for reversedependencies.Figure3adefines the semantic valuation function Sfor state-
ments.Sfunctions take an immutable configuration file ğœas input
and return whether the configuration is validorinvalid, i.e.,
buildable or not. S1evaluates a Kconfig specificationâ€™s list of state-
mentsbycheckingwhetherallstatementsarevalidaccordingto
the input.
S2is the valuation function for configstatements. The number
of cases reflects the complexities of Kconfigâ€™s validity checking.
The first covers reverse dependencies, using the valuation function
R,whichsearchestheentire kconfigfile.(Inpractice,theKconfig
implementation memoizes reverse dependencies during parsing to
avoidrepeatedlytraversingthesyntaxtree.)Ifareversedependency
holds, that means the option must be enabled, i.e., ğœ(ğ‘ ğ‘¦ğ‘š)=ğ‘¦,
otherwisethe configurationfile does not matchthe specification.
The second case of S2handles a direct dependency when the
reversedependencydoesnothold.Inthiscase,anoptionisvalid
regardlessofitssetting,becauseauserisfreetoenableordisableit.
Thethirdcasecoversnon-visibleconfigurationoptions,whichhave
noprompt, so the optionâ€™s valuemust match the specified default.
The fourth case covers when none of the optionâ€™s dependencies
hold. Lastly,if none of these conditions are met, the configuration
file isnot valid.
Dependenciesfornon-Booleantypes(string,int,andhex)behave
similarlyto boolandtristate,butthereareadditionalconstraints
and expressions such as rangeand inequalities. The full semantics
describes thesedifferences [ 40].
3.2 Reverse Dependencies
Tofindanyreversedependenciesforanoption,Kconfigneedsto
search the entire specification for a selectthat can enable the
option.Thisispartlywhytrackingdownunmetdependenciesis
sodifficult.
Figure3bdefines the valuation function Rfor reverse dependen-
cies.Ittakesboth theconfigurationfile ğœanda symbolname ğ‘ and
returns a Boolean value: trueif that symbol is selected by some
optionor falseifnot.R1â€™sdisjunctionreflectstheneedforonly
oneselectto force-enable an option.
R2checks to see if an option is enabled and its dependencies
aremet,thencalls R3toevaluateanyselectconstructs. R3checks
whether there is a select for the input symbol ğ‘ .R4checks whether
any configurationoptionwithin a choiceblockselectssymbol ğ‘ .
Options other than tristate andboolcannot be the selector
orselectee ofareversedependency.
3.3 ChoiceConstructs
Achoiceconstruct defines a mutually-exclusive set of configu-
rationoptions.Choicesareusefulinconfigurationspecifications,
becauseexpressing themwithBooleanlogic aloneis verbose.Fig-
ure4isan example of a choicefrom the Linux kernel that allows
only one of several compression algorithms for a file system to
be enabled. A choice block starts with a choicekeyword (line 1)
and ends with an endchoice (line10). It contains a list of config-
urationoptionswhich,besidesthemutual-exclusionrule,behave
mostlylikeanyotheroptions,exceptthattheycannothavereverse
dependencies ordefaultvalues.
896Finding Broken LinuxConfigurationSpecificationsby StaticallyAnalyzingthe Kconfig Language ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
(S1) S[[kconfig]]ğœÎ”=/braceleftBigg
valid if/logicalandtext.1
statement ğ‘–âˆˆkconfig(S[[statement ğ‘–]]ğœ=valid)
invalid otherwise
(S2)S[[configğ‘ ğ‘¦ğ‘šboolconstrnts select *]]ğœÎ”=ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£³valid if(ğœ(ğ‘ ğ‘¦ğ‘š)=y) âˆ§R[[kconfig]](ğœ,ğ‘ ğ‘¦ğ‘š)
valid ifE[[depends+]]ğœâˆ§E[[prompt]]ğœâˆ§Â¬R[[kconfig]](ğœ,ğ‘ ğ‘¦ğ‘š)
valid if((ğœ(ğ‘ ğ‘¦ğ‘š)=y) âˆ§E[[default+]]ğœâˆ¨ (ğœ(ğ‘ ğ‘¦ğ‘š)=n) âˆ§Â¬E[[default+]]ğœ)
âˆ§E[[depends+]]ğœâˆ§Â¬E[[prompt]]ğœâˆ§Â¬R[[kconfig]](ğœ,ğ‘ ğ‘¦ğ‘š)
valid if(ğœ(ğ‘ ğ‘¦ğ‘š)=n) âˆ§Â¬E[[depends+]]ğœâˆ§Â¬R[[kconfig]](ğœ,ğ‘ ğ‘¦ğ‘š)
invalid otherwise
(S3)S[[choicebool constrnts config +end]]ğœÎ”=ï£±ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£³valid if(Enabled [[config+]]ğœ=1) âˆ§ (S[[config+]]ğœ=valid)
âˆ§E[[depends+]]ğœâˆ§E[[prompt]]ğœ
valid if(Enabled [[config+]]ğœ=0) âˆ§Â¬(E[[depends+]]ğœâˆ§E[[prompt]]ğœ)
valid if(Enabled [[config+]]ğœ=0) âˆ§/logicalandtext.1
constrnts ğ‘–âˆˆconfig+(Â¬E[[constrnts ğ‘–]]ğœ)
invalid otherwise
(a)Directdependency rules.
(R1) R[[kconfig]](ğœ,ğ‘ )Î”=/logicalordisplay.1
statement ğ‘–âˆˆkconfigR[[statement ğ‘–]](ğœ,ğ‘ )
(R2)R[[configğ‘ ğ‘¦ğ‘šboolconstrnts select *]](ğœ,ğ‘ )Î”=/braceleftBigg
R[[select*]](ğœ,ğ‘ )if(ğœ(ğ‘ ğ‘¦ğ‘š)=y) âˆ§E[[depends+]]ğœ
false otherwise
(R3) R[[selectsymifexpr select *]](ğœ,ğ‘ )Î”=ï£±ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£³true if(sym=ğ‘ ) âˆ§E[[expr]]ğœ
R[[select*]](ğœ,ğ‘ )ifselect*â‰ âˆ…
false otherwise
(R4)R[[choicebool constrnts config +end]](ğœ,ğ‘ )Î”=/braceleftBigg
R[[config+]](ğœ,ğ‘ )ifE[[depends+]]ğœâˆ§E[[prompt]]ğœ
false otherwise
(b) Reversedependency rules.
Î£:Symbolsâ†’ {y,n}
S :Statements â†’ (Î£â†’ {valid,invalid})
R :Statements â†’ (Î£Ã—Symbolsâ†’ {true,false})
E :Constraints â†’ (Î£â†’ {true,false})
(c) Typesfor input( Î£) and thevaluationfunctions.
Enabled [[config+]]ğœÎ”=/summationdisplay.1
symğ‘–âˆˆconfig+
ğœ(symğ‘–)=ğ‘¦(1)
(d)Counting howmany configoptions areenabled.(E1) E[[promptwordifexpr]]ğœÎ”=E[[expr]]ğœ
(E2) E[[depends+]]ğœÎ”=/logicalanddisplay.1
exprğ‘–âˆˆdepends+(E[[exprğ‘–]]ğœ)
(E3)E[[default valifexpr default *]]ğœÎ”=ï£±ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£³val=y ifE[[expr]]ğœ
E[[default*]]ğœifdefault*â‰ âˆ…
false otherwise
(E4) E[[expr1&&expr2]]ğœÎ”=E[[expr1]]ğœâˆ§E[[expr2]]ğœ
(E5) E[[expr1||expr2]]ğœÎ”=E[[expr1]]ğœâˆ¨E[[expr2]]ğœ
(E6) E[[!expr]]ğœÎ”=Â¬E[[expr]]ğœ
(E7) E[[ğ‘ ğ‘¦ğ‘š]]ğœÎ”=(ğœ(ğ‘ ğ‘¦ğ‘š)=ğ‘¦)
(e)Expressionevaluationrules.
Figure 3:Formalsemanticsofacore fragment ofKconfig.
897ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece JehoOh,Necip FazÄ±l YÄ±ldÄ±ran,Julian Braha, andPaulGazzillo
1choice
2prompt"Decompressor parallelisation options"
3depends on SQUASHFS
4configSQUASHFS_DECOMP_SINGLE
5bool"Single threaded compression"
6configSQUASHFS_DECOMP_MULTI
7bool"Use multiple decompressors"
8configSQUASHFS_DECOMP_MULTI_PERCPU
9bool"Use percpu multiple decompressors"
10endchoice
Figure 4:Anexample ofachoiceconstruct.
TheS3functioninFigure 3adescribesthe choiceblockâ€™sseman-
tics. The first case covers the mutual exclusion property, requiring
thatonlyoneoftheconfigurationoptionsisenabled.Thiscondition
alsorecursivelychecksthatallthenested configsâ€™dependencies
are valid.
Choiceconstructsalsohavetheirowndirectdependencies,so
Kconfigpermitsnooptionstobe enabled whenthechoicedepen-
denciesarenotmet.Thesecondcaseof S3coversthissituation.The
third case covers the situation when none of the nested configop-
tionsâ€™dependenciesaremet,inwhichcaseKconfigalsopermitsthe
choicetohavenooptionsenabled. choiceconstructscanalsotake
theoptional keywordtoallowfornooptionstobeenabledevenif
itsdirectdependenciesaremet.Therulesareslightlydifferentfrom
aregularchoice,andwe present theminthe full semantics [ 40].
Thechoicestatement described above has booltype. The only
othertypeachoicecantakeis tristate ,inwhichcaseitsbehavior
isthesameas bool,exceptthatmorethanonechoicemaybeset
tom.
3.4 ConstraintExpressions
Figure3edefinesrulesforevaluatingconstraintexpressions,which
return a Boolean trueorfalse.E1,E2, andE3are theprompt,
depends on ,anddefaultconstructs,respectively.Eachisacarrier
for a logical expression, and it is their interaction with configand
choicethat gives them distinctmeaning. The rest of the rulesare
typicalBoolean operators (E 4Å›E7).
3.5 SyntacticSugar
Kconfighasthreeadditionalstatementsthatcanbedesugaredto
configandchoice:if,menu,andmenuconfig .Unlikethecontrol-
flow construct in programming languages, Kconfigâ€™s ifis just syn-
tactic sugar for adding constraints in bulk to its nested statements.
Themenustatement behaves like an ifblock, but also adds text
tothe userinterface. menuconfig isacombinationof configand
menu. The full semantics [ 40] contains the desugaring rules for
these.
The Kconfig language also has a great deal of flexibility in its
syntax.MostofthebehaviorofaKconfigspecificationisinsensitive
totheorderingofoptionsandconstraints.Therefore,oursyntax
defines ordering on constraints to reduce the number of syntactic
sugars rulesneeded.1configX
2 selectAifğ·ğ‘‹
3ğ¾ğ‘‹// other constraints for X
4
5configA
6 depends on ğ·ğ´
7ğ¾ğ´// other constraints for A
8ğ¾other// constraints from other configuration options
Figure 5:Components ofan unmet dependencycondition.
Kconfighaslimitedmetaprogrammingfacilitiesviapreprocessor
constructs for file inclusion and macro expansion [ 2], which we
do not model. Our implementation runs the preprocessor before
symbolicevaluationtoensurethatallfilesareincludedandmacros
are expanded.
4 DESIGNINGTHE BUG FINDER
Ourbug-finder,called kismetworksbygeneratingaformulafor
eachselectdescribing the configurations under which it triggers
anunmetdependencybug.Thisrequiresbothsyntaxanalysis,to
identifyselectconstructs, as well as semantic analysis, to con-
struct a formal model of the bug automatically. kismetdischarges
the formal conditionstoan SMT solvertocheck satisfiability. The
Kconfig language allows developers to define constraints using
symbolic Boolean formulas. Since our goal is to analyze all solu-
tionstotheseconstraintssimultaneously,theanalysisproblemis
atleastashardasBoolean satisfiabilityingeneral.The mainchal-
lenge to designing kismetis ensuring scalability while preserving
enoughprecisiontoidentifytheexactconstructscausingtheunmet
dependency alarm.
4.1 Identifying Select Constructs
Thefirstchallengefor kismetistoidentify selectconstructsin
the Kconfig specifications. Walking over each configconstruct
syntactically, it records all pairs of options involved in a select
operation. For instance, in Figure 1,kismetidentifies the pair
(TOUCHSCREEN_ADC ,IIO_BUFFER_CB ) which contains the selector
andselectee, respectively. In order to verify whether the select
isfreefromanunmetdependencybug, kismetneedstoaccount
for all of the dependencies that constrain both the selector and the
selectee.
The schematic in Figure 5highlights what conditions kismet
uses from the Kconfig specification to construct a verification con-
dition. The configuration option X(line 1) selects A(line 5) with
theselectconstruct on line 2. The selectconstruct itself is con-
strained by some ifdependency, captured by a logical formula
ğ·ğ‘‹(line2).Additionally, Xhasitsowndependencies ğ¾ğ‘‹control-
ling when it can be enabled (line 3). Aâ€™s direct dependencies are
ğ·ğ´(line 6), while ğ¾ğ´(line 7) represents any promptordefault
constraints. ğ¾otherrepresentstheconstraintsfromallotherconfig-
uration options.
898Finding Broken LinuxConfigurationSpecificationsby StaticallyAnalyzingthe Kconfig Language ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
4.2 Modeling UnmetDependency Bugs
Xâ€™sselectconstructonlycausesanunmetdependencyiftheselect
overrides Aâ€™sdirectdependencies,i.e.,when Aâ€™sdependenciesare
unsatisfied.Ifwejustconsidertheconstraintsoftheselectorand
the selectee,the formula for unmet dependency isas follows:
ğœ™unmet=ğ‘‹âˆ§ğ·ğ‘‹âˆ§ğ¾ğ‘‹ (1)
âˆ§ğ´âˆ§Â¬(ğ·ğ´âˆ§ğ¾ğ´) (2)
ğœ™unmetmeansthefollowing:the selectoroptionXisenabledandits
selectand other constraints ğ·ğ‘‹âˆ§ğ¾ğ‘‹are met (subexpression 1);
andtheselecteeoptionAisenabledwhileitsdependencies ğ·ğ´âˆ§ğ¾ğ´
arenotmet(subexpression 2).
ğœ™unmetis an overapproximation, however, because it only ac-
counts for the constraints from two configuration options, the
selector and selectee. Constraints from other configuration options
(ğ¾other) can make ğœ™unmetunsatisfiable. Without accounting for
those,wecanexpectmorefalsepositivealarms.Aprecisecondi-
tionwouldcontain theseconstraintsas well:
ğœ™unmet (precise) =ğœ™unmetâˆ§ğ¾other
Optimizingthebug-finder. TheLinuxKconfigspecificationhas
thousands of configuration options, so ğœ™unmet (precise) is a substan-
tially more expensive formula to solve; it has the constraints from
thousandsofconfigurationoptionsinsteadofjustthetwoin ğœ™unmet.
To make solving more efficient, we use two techniques. First, if
a selectee option has no direct dependencies, then an unmet de-
pendency bug is not possible. Second, we first check the ğœ™unmet
condition and only check ğœ™unmet (precise) if the first check is satisfi-
able.Thisoptimizationissafe,becauseif ğœ™unmetisunsatisfiable,we
knowthatğœ™unmet (precise) isalsounsatisfiable,i.e. Â¬ğœ™unmetentails
Â¬ğœ™unmet (precise) :
ğœ™unmetâ†’ğœ™unmet tautology
ğœ™unmetâˆ§ğ¾otherâ†’ğœ™unmet strengthening
ğœ™unmet (precise) â†’ğœ™unmet substitution
Â¬ğœ™unmetâ†’ Â¬ğœ™unmet (precise) contrapositive
This simple optimization has a substantial impact on precision and
performance as we showinthe evaluation section.
4.3 Modeling KconfigSemantics
Until now, we have described ğœ™unmetwith placeholders for con-
figuration option constraints. But interpreting these constraints
aslogicalformulasrequiresmodelingKconfigâ€™ssemantics.Inthis
sectionweshowhowwemethodicallyderivethesefromourformal
semantics (Section 3).
Recall that Kconfig takes a configuration file as input and de-
termines its validity according to the specifications.As with prior
Kconfigfeaturemodelingtools,werepresentconfigurationoptions
assymbolicBooleanoptions,collapsing tristate optionâ€™syandm
totrue.Whilethisunderapproximates tristate ,itgreatlyreduces
thespaceofpossibleconfigurations,improvingsolverperformance.
Similarly,weapproximatenon-Booleanswithafiniterangeofop-
tions,asinpriorwork[ 30].Lessthan5%ofoptionsarenon-Boolean
inLinux Kconfig specifications.
To derive the model from Kconfig semantics, recall that our con-
cretesemanticsdescribeseachcaseinwhichaKconfigstatementdescribesavalidconfigurationgivenaninputconfigurationfile.For
eachKconfigsyntacticconstructinthespecificationunderanalysis,
our bug finder automatically constructs a symbolic formula ğœ™ğ‘–cor-
respondingtoitsvaluationfunctionfromthesemanticsinFigure 3.
Theformulaisthedisjunctionofeachconditionleadingtoa valid
result.For instance, a configstatement, definedby semantic rule
S2in Figure 3, has four validcases.kclause constructsğœ™config
as a disjunction of each of these case conditions, where ğ¶is the
symbolic valueofthe option:
ğœ™config=(ğ¶âˆ§ğœ™reverse)
âˆ¨ (ğœ™dependsâˆ§ğœ™promptâˆ§Â¬ğœ™reverse)
âˆ¨ ((ğ¶âˆ§ğœ™defaultâˆ¨Â¬ğ¶âˆ§Â¬ğœ™default)
âˆ§ğœ™dependsâˆ§Â¬ğœ™promptâˆ§Â¬ğœ™reverse)
âˆ¨ (Â¬ğ¶âˆ§Â¬ğœ™dependsâˆ§Â¬ğœ™reverse)
Each of the four disjunctive terms corresponds to each of the four
validconditionsfrom S2.Accessestotheconcreteconfiguration
optionvalue ğœ(ğ‘ ğ‘¦ğ‘š)are replacedwitha symbolicBooleanvalue
ğ¶. Calls to other valuation functions are replaced with the sym-
bolic formulas for that syntax, e.g., ğœ™dependsfor thedepends on
construct.
Fortheconfigurationoption IIO_BUFFER_CB inFigure 1,ğœ™config
isconstructedfrom the following symbolic formulas:
ğ¶=IIO_BUFFER_CB
ğœ™reverse=TOUCHSCREEN_ADC âˆ§IIOâˆ§INPUT_TOUCHSCREEN
ğœ™depends=IIOâˆ§IIO_BUFFER
ğœ™prompt=true
ğœ™default=false
ğœ™reverseandğœ™directare the reverse and direct dependencies re-
spectively. The option is always visible since it has an uncondi-
tionalprompt(ğœ™prompt), and the default value is false since it has
nodefaultspecification ( ğœ™default).
Substitutingthesymbolicformulasinto ğœ™configandsimplifying
the disjunctive terms, we getthe following:
(IIO_BUFFER_CB (3)
âˆ§TOUCHSCREEN_ADC âˆ§IIOâˆ§INPUT_TOUCHSCREEN )
âˆ¨ (IIOâˆ§IIO_BUFFER (4)
âˆ§Â¬(TOUCHSCREEN_ADC âˆ§IIOâˆ§INPUT_TOUCHSCREEN ))
âˆ¨ (false) (5)
âˆ¨ (Â¬IIO_BUFFER_CCB âˆ§Â¬(IIOâˆ§IIO_BUFFER ) (6)
âˆ§Â¬(TOUCHSCREEN_ADC âˆ§IIOâˆ§INPUT_TOUCHSCREEN ))
In summary, this formula means that IIO_BUFFER_CB is legal to
enable if its reverse dependency holds (subexpression 3), is legal
to either enable or disable if its direct dependency holds (subex-
pression4), never takes a default value(subexpression 5), andcan
otherwiseonlybedisabledwhenitsdirectandreversedependencies
do not hold (subexpression 6). The rest of the symbolic evaluatorâ€™s
valuationfunctionsaresimilarlyderivedfromtheformalsemantics
andcan be foundwiththe openly-archivedformalsemantics [ 40].
The benefitofthis approachisthatisremoves guessworkfrom
designing Kconfig analysis tools. Instead, tool writers can rely on a
commonsemanticstomechanicallyderiveananalysisforwhatever
abstraction they would like to use for analysis, tailoring the choice
offormalismforconfigurationoptionsbasedontheirspecificappli-
cation.Wedemonstratejustonepossiblesetofchoicesforderiving
899ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece JehoOh,Necip FazÄ±l YÄ±ldÄ±ran,Julian Braha, andPaulGazzillo
kextract
klocalizerkclause
kismetKconfig files
Desugared Kconfig
Logical models
Bug conditions
Bug alarms and
.config file testsZ3
Figure 6: The components of the infrastructure and how
they worktogetherforunmetdependencybug-finding.
the Kconfig analysis. Moreover, future extensions to Kconfig by
developers can be captured by updates to the semantics, easing
adoption for Kconfig tools that mechanically derive their analyses
from the semantics.
5 IMPLEMENTATION
The analysis framework is implemented in about two thousand
sourcelinesofPython,andaboutonethousandsourcelinesofC.It
consistsoffourcomponents,showninFigure 6.Thekextract tool
wraps the parser from the Linux implementation of Kconfig [ 54]
withaCextensiontodesugartheKconfigspecificationintoadesug-
ared version of the Kconfig language. The kclause tool, written in
Python,readsindesugaredKconfigandconstructslogicalformulas
for each configuration optionsâ€™ constraints, outputting them in the
SMTLIB2 [ 9] format. kismet, also written in Python, finds each
selectconstruct from the kextract output and uses the logical
modelsfrom kclause togeneratetheunmetdependencycondition
foreachconstruct. kismetfinallypassesthisconditioninSMTLIB2
format to the klocalizer tool, which uses the Z3 SMT solver [ 13]
tocheckforthesatisfiabilityofthebugcondition.Forsatisfiable
conditions, klocalizer can also generate solutions to the condi-
tion in the Linux .config file format, which we use to test the
solutionagainsttheactualKconfigimplementation.Allsourcecode
isavailableonlineasfreeandopen-sourcesoftware1aswellasin
an openly-archivedartifact [ 38].
6 EXPERIMENTALEVALUATION
We evaluate our bug finding approach for precision, performance,
andimpact onreal-world code.
1https://github.com/paulgazz/kmax6.1 ExperimentalSetup
We use Kconfigspecifications from a recent version (v5.4.4)of the
Linux kernel source code2as the target of our study. With over
140,000linesofspecificationsandover15,000configurationoptions,
Linux represents, to our knowledge,the largestuserof Kconfig.
TheLinuxkernelnotonlyprovidesalargeKconfigspecification,
but multiple ones as well, due to its support for multiple hardware
platforms. Each of its 28 architecture families3has its own Kconfig
specification, effectively providing 28 separate Kconfig specifica-
tions to use for evaluation. Because of the hardware abstraction
layer,however,thesearchitecturesshareatleastsomeportionof
thecodebaseincommon,andthereforealsosharealargeportion
of their Kconfig specifications; about 100,000 lines, two-thirds, are
architecture-independent. Each architecture has between 10,014
and 12,744 select constructs for a total of 289,202. Deduplicating
these,thereare17,006uniqueselectconstructs,althoughthecon-
straints due to architecture-specific Kconfig files may differ. Due to
thissharing,wenotonlyreportresultsforeacharchitectureâ€™sKcon-
figspecificationsbutalsotheaggregateanddeduplicatedalarms
acrossarchitectures.
All experiments were executed on a server with an AMD EPYC
7401 24-Core Processor with 512GB of RAM running Ubuntu 18.04,
wherewemeasuredperformanceusingtheUNIX timeutility.Since
thismachineallowsforhighparallelism,werantheexperiments
for the 28 architecturesâ€™ Kconfig specifications in parallel on sepa-
rate copies of the Linux kernel source code. Replication scripts are
available withthe sourcecode repository1.
6.2 Data Availability
Allexperimental data are available as archivedopen data [ 39].
6.3 Research Questions
Our evaluation seeksto answer the following research questions:
RQ1(Precision)Howpreciseisouranalysiswhenfinding
unmet dependencies? To measure bug-finding effectiveness, we
runourtoolonall28LinuxKconfigspecificationsandcollectthe
alarmsreported.Wealsoautomaticallyvalidatewhetherthealarms
aretruepositivesbygeneratingandbuildingtestcasesautomati-
cally. We expect that, if our semantics reflect real Kconfig behavior,
that our symbolic model of unmet dependencies and Kconfig be-
haviorshould yieldhigh precision, i.e.,fewfalse positives.
RQ2(Performance)Howfastisbug-finding? Werecordthe
runningtimeofourbug-finderwhenappliedtoall28LinuxKconfig
specifications,i.e.,theexperimentfromRQ1.Wereportthedistribu-
tion of running times per architecture, the aggregate time, as well
as the breakdown between desugaring, generating bug conditions,
andsolving.Weexpectthatourdesignchoicesandoptimization
willyieldafastenoughanalysistomakerunning kismetfeasible
for developers to use regularly.
RQ3 (Impact) How useful are the resulting alarms to de-
velopers? We evaluate the impact of our bug-finding approach
by manually submitting some reports and patches to the kernel
2https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.4.4.tar.xz
3alpha, arc, arm, arm64, c6x, csky, h8300, hexagon, i386, ia64, m68k, microblaze, mips,
nds32,nios2,openrisc,parisc,powerpc,riscv,s390,sh,sh64,sparc,sparc64,um,uni-
core32,x86_64, and xtensa
900Finding Broken LinuxConfigurationSpecificationsby StaticallyAnalyzingthe Kconfig Language ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
Table 1: kismetâ€™s bug-finding results across all 28 architec-
ture Kconfigspecifications.
Percentiles
Metric Max 75th 50th 25th Min
Constructs 12,744 10,386 10,108 10,044 10,014
Alarms raised 53.00 31.25 25.00 22.75 10.00
Precision 100% 100% 100% 100% 100%
maintainers. We expect that, if the resulting alarms are correct
and provide value to the kernel maintainers, they will confirm the
reports andacceptour patches.
RQ4 (Comparison) How does our approach compare to
random configuration testing? To our knowledge, no related
toolforfindingunmetdependenciesinKconfigexists.Toprovide
a baseline time to search for bugs, we use random configuration
testingwithKconfigâ€™sbuilt-in randconfig tool.Wecomparethe
bugs found, given the same amount of time as kismetand also
allowrandconfig generation to run for several days. We expect
that our static approach will perform better, given the enormity of
thesearchspaceofconfigurations,butwealsoexpecttofindnew
bugsmissedby kismetâ€™sunderapproximation ofnon-Booleans.
6.4 RQ1: Precision
Werunkismetoneachofthe28architecturesâ€™Kconfigspecifica-
tions and collect the resulting alarms. kismetreports the pair of
configurationoptionsinvolvedintheunmetdependency,i.e.,the
selectorandtheselectee.Finally,wevalidatewhetherthealarmis
atruepositivebygeneratingatestcase.Thisworksbyquerying
the Z3 SMT solver for a satisfying solution to ğœ™unmet (precise) , the
bugâ€™s logicalformula,then convertingthesolution intotheLinux
.configconfigurationfile format.
Table1summarizes the analysis results of our experiments. The
rows list the number of constructs analyzed, the number of alarms
raisedby kismet,andtheprecision,i.e.,thepercentofallalarms
that are true positives. The columns show the distribution of these
metricsacrossthe28architecturesâ€™Kconfigspecificationsasper-
centiles.kismetchecksbetween10,014and12,744selectconstructs
foreacharchitecture,findingbetween10and53alarmsperKconfig
specification,foratotalof781alarmsover289,202constructs.All
alarmsareconfirmedtobetruepositivesbygeneratingtestcases
that trigger the alarm, for a precision of 100%. While such high
precisionwouldbeunusualforstaticanalysis,thecorefragmentof
Kconfigthatwemodelrequiresno over-approximationthatcould
lead to false positives. Since the ground truth number of bugs in
real-world Linux Kconfig specifications is unknown, we do not
compute recall,but we addressfalse negatives inRQ4.
Although each architecture has its own Kconfig specification,
theyallsharealargecommonsetofKconfigfiles.Theconsequence
isthatfixingabuginonearchitectureâ€™sKconfigspecificationcanfix
itforseveralothers.Deduplicatingthesebugyields151totalalarms
forunique selectconstructsacrossallarchitectures.Insomecases,
the same selectconstruct was a true unmet dependency in oneTable2:kismetâ€™sbug-findingtimeinminutesforall28Kcon-
fig specifications,brokendownby eachphase ofanalysis.
Analysis Time Percentiles(minutes)
Phase Max 75th 50th 25th Min
1.kclause 7.21 5.52 5.35 5.21 5.03
2. Syntaxcheck 0.15 0.12 0.12 0.11 0.11
3.ğœ™unmet 2.35 2.00 1.94 1.88 1.62
4.ğœ™unmet (precise) 79.31 33.79 32.16 31.23 29.08
5. Confirmation 2.01 1.06 0.81 0.72 0.38
TotalTime 90.21 42.12 40.30 39.41 37.13
architectureâ€™sKconfig specificationbutnot others,whichis possi-
blebecauseofarchitecture-specificconstraints.Inthesecases,we
countedthe constructas atrue alarm inthe deduplicatedset.
Summary:ourapproachisprecise,yielding100%precision
on Linuxâ€™s very large, real-world Kconfig specification, and
findsmanynewbugs:781truepositivebugsor151ifwededu-
plicatecommon constructs acrossarchitectures.
6.5 RQ2: Performance
To evaluate performance, we measure kismetâ€™s running time, bro-
ken down by each phase of its analysis. Table 2is the distribution
ofrunningtimesacrosseachofthe28architecture-specificKconfig
specifications.Eachrowisthephaseofanalysis,withthetotaltime
in the last row, while each column is percentiles in the distribution
ofrunning times.
kismettakesbetween37and90minutesononeKconfigspeci-
ficationfile,foratotalof20hoursinall,includingthetimespent
generating atest caseto automatically confirm true positives. We
breakdownthetimingintofivephases:(1) kclauseisthetimespent
modelingKconfigconstructs,whichwe performatthebeginning
ofanalysistocachetheresults.(2) Syntaxcheck includesbothiden-
tifying each select construct and the optimization that rules out
selectees with no dependencies. As discussed in Section 4.2on
optimization,(3) ğœ™unmetisthetimespentcheckingtheimprecise
bug formula, and (4) ğœ™unmet (precise) is the timespent checkingthe
precise bug formula, if the imprecise one does not rule out the bug.
(5)Confirmation is the time spent generating a test case for the
bug and checking it against the actual Kconfig implementation;
this is not part of the static analysis, per se, but it only takes a
comparativelysmall amount of time.
Inmostcases, kismettakeslessthanhourforanarchitecture,
making it fast enough for use on each commit of the Kconfig speci-
fication.Thelargestamountoftimeisspentonthepreciseformula
check,whichshowstheimportanceofouroptimizationinavoiding
making that check. Checking ğœ™unmetis fast: it takes less than an
hourforhundredsofthousandsof selectconstructs,albeitwith
low precision (less than 2%). 85% of the constructs are ruled out,
however,reducing the time neededto solve the precise condition.
Summary: kismetis fast, taking between 37 and 90 min-
utestoanalyzebetween10,014to12,744selectconstructsina
Kconfigspecification,enabling frequentbug finding runs.
901ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece JehoOh,Necip FazÄ±l YÄ±ldÄ±ran,Julian Braha, andPaulGazzillo
6.6 RQ3: Impact
We evaluate the impact of our bug-finder, and the semantics on
which it is based, by reporting alarms to the kernel developers and
submitting patches to the mainline Linux repository, specifically
via the Linux kernel mailing list [ 50] and the kernel.org Bugzilla
website[3].Developerconfirmationofbugsprovidesconfidencein
theutilityofthealarms,beyondprecision.Moreover,acceptance
ofpatchesbyofficialmaintainersreflectsthebeneficialimpactof
the results onthis prevalentandfrequently usedcodebase.
While our bug-finder is fully automated, submitting reports and
patchesisamanualprocess,requiringtimetocreatethemandcom-
municatewithhumanLinuxmaintainers.Moreover,maintainers
mayopttonotpatcheventruealarms,maynotrespondimmedi-
ately,ormayrequestdifferentchangesthanwhatweproposedin
thepatch.SincetheKconfigspecificationgraduallychangesover
time with the rest of the codebase, prior bugs may no longer occur,
duetomanualfixes,removalofoptions,etc.Webelieveitisfeasible
to usekismetincontinuousintegration, butwe leave suchinfras-
tructuredevelopmentasfuturework.Forthesereasons,wehave
not yet submitted all alarms; repairing all is an ongoing process,
andwe report the currentstate ofthe bugrepairsinprogress.
As of writing, we have submitted 38 reports or patches, 19 have
been confirmed with the remainder pending, and 15 of our patches
have already been committed to the Linux kernel codebase. Up-to-
date information about the reporting and patching effort can be
foundinthe sourcecode repository4.
Knowing the effect of unmet dependencies on the kernel is diffi-
culttomeasure.Suchaconfigurationisnotsupposedtobefeasible,
and developers have been so far highly receptive to patches of
unmetdependencybugs.Whilewedonotknowalltheeffectsof
anunmetdependency,onecommonresultisabrokenbuild,e.g.,
Figure1,whichisundesirableforanysoftwareproduct.Wemea-
sured how often a broken build results from the bugs we found
by attempting to build the generated .config fromkismetand
hand-checkingthereasonforthebrokenbuild.Builderrorsaccount
for 68% of all tests. 29% of configuration files trigger build errors
whose root cause is the unmet dependency bug from which the
configurationfilewas generated.27% faildueto bugs other than
the one used to generate the test case. Since a build error halts the
buildprocess,wecannoteasilydeterminewhetherthebuildwould
have encountered an error related to the unmet dependency, so we
conservativelyassumethesearenotcausedbyunmetdependencies.
Summary: The bug finding results have resulted in 38 re-
ports and 15 committed patches to the Linux kernel so far,
with furtherpatchsubmission and discussion ongoing.
6.7 RQ4: Comparison
Whilekismetis100%preciseforitsfragmentoftheKconfigseman-
tics,itsunderapproximationofnon-Booleanleavesitsusceptible
to false negatives. To gather a set of unmet dependency bench-
marksthatincludebugsnotfindableby kismet,weuseabuilt-in
Kconfigutilityforgeneratingrandomconfigurations.Generating
random configurations for over four days for each architecture
inparallel(acombinedtimeofmorethanthreemonths),wegen-
eratedover11,000,000configurationfiles,whichraised2,857,938
4https://github.com/paulgazz/kmax/blob/master/docs/bugs_found.mdTable 3: Percent of the bugs found by kismetcompared to
randconfig givenboththesameamountoftimeasand135x
more timethan kismet.
Percentiles
Tool Max 75th 50th 25th Min
kismet 100.00% 100.00% 100.00% 100.00% 87.10%
randconfig
Sametime 62.86% 12.94% 6.80% 2.68% 0.00%
135x time 77.14% 22.55% 17.42% 10.54% 0.00%
unmet dependency alarms, yielding 175 unique unmet dependency
bugs.Comparingtheseto kismetâ€™sresults, kismetadds614unique
unmet dependencies not foundinthis random testing.
Since no other tools to our knowledge analyze unmet depen-
dencies, we compare the performance of kismetagainst a random
testing approach, to see whether there is a benefit in running time
andbugsfoundtousing kismet.Usingthecombinedsetofbugs
frommonthsof randconfig andkismetâ€™sresults,wecomparethe
percentofbugsfoundgiventhesameamountoftime.Table 3shows
theresultsofthiscomparisonofthepercentageofbugsfoundfrom
the benchmark set. The columns show the distribution of these
percentagesacrossallarchitecturesâ€™Kconfigspecifications. kismet
finds 100% for almost all architectures, reflecting the fact that even
aftermonthsofcomputetime,veryfewadditionalbugswerefound
byrandomtestingcomparedwith kismet.randconfig (rowÅ‚Same
timeÅ¾),giventhesameamountoftimethat kismettook,findson
average only a small fraction of the set of bugs, 6.80%, with a max-
imum of only 62.86%. Even given several days to run (row Å‚135x
timeÅ¾),randconfig still only finds a fraction of the benchmark
bugs. In contrast, there were only eight bugs not found by kismet,
leadingto aworst-case of 87.10%benchmarkcoverageby kismet.
WhileourbenchmarkisnotthegroundtruthofLinuxâ€™scomplete
set of bugs, which is not feasible to find by hand given the months
of compute time to generate configuration files, it provides at least
anestimateoftherelativeperformanceof kismetversusrandom
testing. The results show the large performance benefit of using
kismetcomparedtorandomtesting.Inthesameamountoftime,
kismetfinds many more bugs than random testing, providing a
fast and precise complement to random testing that can be run
regularlyagainst newcommits to the Kconfig specification.
Summary: kismetfinds many more true positives bugs in
far less time than random testing, although there are also
falsenegativesasexpectedbydeliberateunderapproximation.
7 THREATS TO VALIDITY
InternalThreats. Ourformalsemanticsneedstomatchtheactual
behavior of Kconfig, otherwise, any analyses based on it may yield
incorrectresults.WemitigatedthisusingtheKconfigdocumenta-
tion,reviewingitsactualCimplementation,andcollectingaKconfig
testsuite.Moreover,the100%precisionofthebug-finder,validated
withgeneratedtestcasesandsomedeveloperconfirmation,testifies
totheaccuracyofthesemantics. kismetisdeliberatelyunderap-
proximate for non-Boolean options, however, so this part of the
902Finding Broken LinuxConfigurationSpecificationsby StaticallyAnalyzingthe Kconfig Language ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
semanticsisnotsupportedbythebug-findingresults,butbythe
documentation, implementation,andtest suite only.
External Threats. While Kconfig is used by several popular, low-
levelsystemssoftware(BusyBox,coreboot,etc),ourevaluationonly
applies to Linux. Linux, however, is the largest user of Kconfig that
weknowof,andhasmultipleKconfigspecifications.Weevaluate
our bug-finder on one recent version of the Linux source code, but
Kconfigspecificationschangegraduallywitheachkernelversion.
Different versions may yield different numbers of alarms. We leave
a long-term study of Kconfig bugs across versions and projects
as future work. Our bug-finder currently checks for one kind of
bug. The performance of the bug-finder could vary for different
bug types or analysis tasks. Our work is specific to the Kconfig
specification language, so we do not show applicability to other
specificationlanguages.Giventhelargetimeinvestmentincreating
and evaluating accurate formal semantics and a corresponding
analysisinfrastructure,weleavegeneralizingtheapproachtoother
specification languagesas future work.
8 RELATED WORK
ModelingKconfigspecifications. Thereareseveralpriorefforts
that convert Kconfig to logical formulas for various applications.
Zengleretal.andWalchetal.modeledKconfigintheDIMACSSAT
formatwiththegoaloffindingKconfiglanguagemetrics,including
the number of options, types, and mandatory configuration op-
tions [57,61]. She et al describe a formal semantics [ 43] and a tool
called LVAT that converts Kconfig specifications to the DIMACS
SAT solver format [ 10,44,45]. It was designed for collecting sta-
tisticsabouttheKconfiglanguagesuchasthenumberofoptions,
the hierarchy of dependencies, and other metrics [ 10], rather than
for precise formal verification of configuration specifications. Tool
developmentappearstohavestoppedforLVATin2013[ 42].The
undertakerprojecthasatooltoconvertKconfigâ€™s dumpconf output
to the DIMACS SAT format for use in identifying dead code blocks
in unpreprocessed C code [ 4,53]. Thekconfigreader tool con-
vertstheoutputofaKconfigtoolcalled dumpconf ,whichdumps
each configuration optionsâ€™ constraint expressions, into the DI-
MACS SAT solver format [ 25,30]. El-Sharkawy et al., describes
an informalsemantics of Kconfig, provides illustrative examples,
and evaluates the limitations of other tools [ 15]. Fernandez et al.
described informal semantics for Kconfig constructs that they iden-
tified as incorrectly supported in prior conversion tools [ 16]. They
provide a set of example Kconfig constructs that illustrate these
limitations, whichwe haveincorporated into kclauseâ€™stestsuite.
Fernandez et al. also describe a new conversion tool that produces
Binary Decision Diagrams but has not been evaluated on Linux
Kconfig specifications.
Analyses of other configuration languages. Shambaugh et al. [ 41]
performformalverificationofthePuppetdeploymentconfigura-
tionlanguagetodetectnon-deterministicsystemstateupdatesand
other undesirable system configurations. Weiss et al. [ 59] auto-
mate Puppet configuration repair using formal reasoning over a
propositionalmodelofthelanguage.Andersonetal.[ 8]formally
verify the SmartFrog infrastructure deployment language to prove
properties such as termination of compilation, comparing multipleimplementations of SmartFrog compilers. Sotiropulous et al. for-
mallymodeledthesystemcalltraceofthePuppettooltofindfaults
fromorderingviolationsonresourceusage[ 49].HortonandParnin
infer system dependencies fromPython codein order to generate
Docker specification files [ 22]. They also inferred dependencies
from Python code snippets to check if their package dependen-
cies are out of date [ 23]. Bouchet et al. use formal verification to
check for inadvertent public access to Amazon S3 instances [ 12].
Chenygyuanetal.minedfrequentlyuseddependenciesbetween
entitiesfromdeploymentdescriptorsforJava-EE-platform-based
applications to validate if a new deployment descriptor is violating
mineddependencies[ 60].Hanappietal.formallymodeledconfig-
urationscriptsandresourceusagetotestifasystemcanrecover
from failures such as network outages and reach a stable state [ 21].
Studiesonvariabilitybugs. Somepriorworkextractedvariability
information from Makefiles and source code for finding bugs, dead
codeblocks,orinconsistenciesbetweenvariabilityspecificationand
implementation.[ 11,14,19,36,37,48,52].Priorworkalsoanalyzed
bugs or warnings raised from sampled configurations to classify
them and understand how they are introduced [ 33,34]. Similar
analyses were performed on the bugs or vulnerabilities reported in
the bug database or source commits [ 6,7,17,35]. Others studied
configuration sampling algorithms to find more variability bugs
withfewer samples [ 29,32,46,55].
9 CONCLUSION
Wehaveintroducedanewformalsemanticsandmodelchecking
infrastructure for analyzing Kconfig specification files and method-
ically derived a bug-finder, called kismet, for unmet dependencies,
a common pitfall for Kconfig maintainers. Our results show that
our bug-finder is precise, fast, and has resulted in patches to the
mainlineLinuxkernelsourcecodeconfirmedandacceptedbymain-
tainers.Futureworkincludescontinuingtorepairallbugsfoundby
kismet, applying it to ongoing kernel development and other soft-
ware,andapplyingouranalysisframeworktoothermaintenance
challenges.
Wealsoplantoexploreapplyingthesemodelcheckingprinciples
tootherconfigurationspecificationlanguagestofurtherimprove
thestateoflanguagetoolingforsoftwareoperationsatlarge.As
software operations are further automated, the languages used
for configuring, building, and deploying software become an in-
creasingly large component of the source code. These languages
introducenewopportunitiesforlesstraditionalsoftwarevulnerabil-
ities, such as security misconfiguration. As our work demonstrates,
these languages lend themselves to automated analysis, suggest-
ing thefuture benefitsof applyingrigorous designand automated
reasoningto software operations languagesingeneral.
ACKNOWLEDGMENTS
We would like to thank the anonymous referees for their valuable
commentsandhelpfulsuggestions,JuliaLawallforadviceandinput
intothework,andElaineWeyukerforher feedback. Thisworkis
supported by the National Science Foundation under CCF-1941816
andCCF-1840934.
903ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece JehoOh,Necip FazÄ±l YÄ±ldÄ±ran,Julian Braha, andPaulGazzillo
REFERENCES
[1]2008. Boogie:AnIntermediateVerificationLanguage. https://www.microsoft.
com/en-us/research/project/boogie-an-intermediate-verification-language/ .
[2]2020. Kconfig macrolanguage. https://www.kernel.org/doc/html/latest/kbuild/
kconfig-macro-language.html , lastaccessed on11/19/20.
[3]2020. Kernel.org Bugzilla page. https://bugzilla.kernel.org/ , last accessed on
11/19/20.
[4] 2020. Undertaker Project Page. https://vamos.informatik.uni-erlangen.de/trac/
undertaker , lastaccessed on11/19/20.
[5]2021. 0-DayTest Service. https://01.org/lkp/documentation/0-day-test-service .
[6]Iago Abal, Claus Brabrand, and Andrzej Wasowski. 2014. 42 Variability Bugs in
theLinuxKernel:AQualitativeAnalysis.In Proceedingsofthe29thACM/IEEE
International Conference on Automated Software Engineering (Vasteras, Sweden)
(ASE â€™14). Association forComputing Machinery, New York, NY, USA, 421Å›432.
https://doi.org/10.1145/2642937.2642990
[7]IagoAbal, Jean Melo,Åtefan StÄƒnciulescu,Claus Brabrand, MÃ¡rcioRibeiro,and
Andrzej WÄ…sowski. 2018. Variability Bugs in Highly Configurable Systems: A
Qualitative Analysis. ACM Trans. Softw. Eng. Methodol. 26, 3, Article 10 (Jan.
2018),34pages. https://doi.org/10.1145/3149119
[8]Paul Anderson and Herry Herry. 2016. A formal semantics for the SmartFrog
configurationlanguage. JournalofNetworkandSystemsManagement 24,2(2016),
309Å›345. https://doi.org/10.1007/s10922-015-9351-y
[9]Clark Barrett, Aaron Stump, and Cesare Tinelli. 2010. The SMT-LIB Standard:
Version 2.0. In Proceedings of the 8th International Workshop on Satisfiability
Modulo Theories (Edinburgh,UK) , A. Guptaand D. Kroening (Eds.).
[10]ThorstenBerger,StevenShe,RafaelLotufo,AndrzejWasowski,andKrzysztof
Czarnecki.2013. AStudyofVariabilityModelsandLanguagesintheSystems
Software Domain. IEEE Transactions on Software Engineering 39, 12 (2013), 1611Å›
1640.https://doi.org/10.1109/TSE.2013.34
[11]EricBodden, TÃ¡rsisTolÃªdo, MÃ¡rcioRibeiro, Claus Brabrand, PauloBorba, and
Mira Mezini. 2013. SPL<sup>LIFT</sup>: Statically Analyzing Software Product
Lines in Minutes Instead of Years. (2013), 355Å›364. https://doi.org/10.1145/
2491956.2491976
[12]Malik Bouchet, Byron Cook, Bryant Cutler, Anna Druzkina, Andrew Gacek,
Liana Hadarean, Ranjit Jhala, Brad Marshall, Dan Peebles, Neha Rungta, Cole
Schlesinger, Chriss Stephens, Carsten Varming, and Andy Warfield. 2020. Block
PublicAccess:TrustSafetyVerificationofAccessControlPolicies.In Proceedings
of the 28th ACM Joint Meeting on European Software Engineering Conference
and Symposium on the Foundations of Software Engineering (Virtual Event, USA)
(ESEC/FSE 2020) . Association for Computing Machinery, New York, NY, USA,
281Å›291. https://doi.org/10.1145/3368089.3409728
[13]LeonardoDeMouraandNikolajBjÃ¹rner.2008. Z3:AnEfficientSMTSolver.In
ProceedingsoftheTheoryandPracticeofSoftware,14thInternationalConference
onToolsandAlgorithmsfortheConstructionandAnalysisofSystems (Budapest,
Hungary) (TACASâ€™08/ETAPSâ€™08) . Springer-Verlag, Berlin, Heidelberg, 337Å›340.
[14]Christian Dietrich, Reinhard Tartler, Wolfgang SchrÃ¶der-Preikschat, and Daniel
Lohmann.2012. ARobustApproachforVariabilityExtractionfromtheLinux
Build System. In Proceedings of the 16th International Software Product Line Con-
ference-Volume1 (Salvador,Brazil) (SPLCâ€™12) .AssociationforComputingMa-
chinery, NewYork, NY, USA,21Å›30. https://doi.org/10.1145/2362536.2362544
[15]Sascha El-Sharkawy, Adam Krafczyk, and Klaus Schmid. 2015. Analysing the
KconfigSemanticsandItsAnalysisTools.In Proceedingsofthe2015ACMSIGPLAN
InternationalConferenceonGenerativeProgramming:ConceptsandExperiences
(Pittsburgh, PA, USA) (GPCE 2015) . Association for Computing Machinery, New
York, NY, USA,45Å›54. https://doi.org/10.1145/2814204.2814222
[16]DavidFernandez-Amoros,RubenHeradio,ChristophMayr-Dorn,andAlexander
Egyed.2019. AKconfigTranslationtoLogicwithOne-WayValidationSystem.In
Proceedingsofthe23rdInternationalSystemsandSoftwareProductLineConference
-VolumeA (Paris,France) (SPLCâ€™19) .AssociationforComputingMachinery,New
York, NY, USA,303Å›308. https://doi.org/10.1145/3336294.3336313
[17]Gabriel Ferreira, Momin Malik, Christian KÃ¤stner, JÃ¼rgen Pfeffer, and Sven Apel.
2016. Do#IfdefsInfluencetheOccurrenceofVulnerabilities?AnEmpiricalStudy
of the Linux Kernel. In Proceedings of the 20th International Systems and Software
ProductLineConference (Beijing,China) (SPLCâ€™16) .ACM,NewYork,NY,USA,
65Å›73.https://doi.org/10.1145/2934466.2934467
[18]Alejandra Garrido and Ralph Johnson. 2005. Analyzing Multiple Configurations
of a CProgram.In ICSM. 379Å›388.
[19]Paul Gazzillo. 2017. Kmax: Finding All Configurations of Kbuild Makefiles
Statically.In Proceedingsofthe201711thJointMeetingonFoundationsofSoftware
Engineering (Paderborn,Germany) (ESEC/FSE2017) .ACM,New York,NY,USA,
279Å›290. https://doi.org/10.1145/3106237.3106283
[20]Paul Gazzillo and Robert Grimm. 2012. SuperC: Parsing All of C by Taming the
Preprocessor.In Proceedingsofthe33rdACMSIGPLANConferenceonProgramming
LanguageDesignandImplementation (Beijing,China) (PLDIâ€™12) .ACM,NewYork,
NY, USA,323Å›334. https://doi.org/10.1145/2254064.2254103
[21]Oliver Hanappi, Waldemar Hummer, and Schahram Dustdar. 2016. Asserting
ReliableConvergenceforConfigurationManagementScripts.In Proceedingsofthe2016ACMSIGPLANInternationalConferenceonObject-OrientedProgramming,
Systems, Languages, and Applications (Amsterdam, Netherlands) (OOPSLA 2016) .
Association for Computing Machinery, New York, NY, USA, 328Å›343. https:
//doi.org/10.1145/2983990.2984000
[22]Eric Horton and Chris Parnin. 2019. DockerizeMe: Automatic Inference of
EnvironmentDependenciesforPythonCodeSnippets.In 2019IEEE/ACM41st
International Conference on Software Engineering (ICSE) . 328Å›338. https://doi.
org/10.1109/ICSE.2019.00047
[23]Eric Horton and Chris Parnin. 2019. V2: Fast Detection of Configuration Drift in
Python. In 2019 34thIEEE/ACMInternationalConference on AutomatedSoftware
Engineering (ASE) . 477Å›488. https://doi.org/10.1109/ASE.2019.00052
[24]AlexandruFlorinIosif-Lazar,JeanMelo,AleksandarS.Dimovski,ClausBrabrand,
and Andrzej Wasowski. 2017. Effective Analysis of C Programs by Rewriting
Variability. CoRR(2017).
[25]Christian KÃ¤stner. 2020. kconfigreader. https://github.com/ckaestne/
kconfigreader , lastaccessed on11/19/20.
[26]ChristianKÃ¤stner,PaoloG.Giarrusso,TillmannRendel,SebastianErdweg,Klaus
Ostermann,andThorstenBerger.2011. Variability-AwareParsinginthePresence
ofLexicalMacrosandConditionalCompilation.In Proceedingsofthe2011ACMIn-
ternationalConferenceonObjectOrientedProgrammingSystemsLanguagesandAp-
plications (Portland,Oregon,USA) (OOPSLAâ€™11) .AssociationforComputingMa-
chinery, New York, NY, USA, 805Å›824. https://doi.org/10.1145/2048066.2048128
[27]Christian KÃ¤stner, Klaus Ostermann, and Sebastian Erdweg. 2012. A Variability-
Aware Module System. In Proceedings of the ACM International Conference on
ObjectOrientedProgrammingSystemsLanguagesandApplications (Tucson,Ari-
zona, USA) (OOPSLA â€™12) . Association for Computing Machinery, New York, NY,
USA,773Å›792. https://doi.org/10.1145/2384616.2384673
[28]The kernel development community. 2020. Kconfig Language. https:
//www.kernel.org/doc/html/latest/kbuild/kconfig-language.html , last accessed
on11/19/20.
[29]ChangHwanPeterKim,DonS.Batory,andSarfrazKhurshid.2011. Reducing
Combinatorics in Testing Product Lines. In Proceedings of the Tenth International
ConferenceonAspect-OrientedSoftwareDevelopment (PortodeGalinhas,Brazil)
(AOSD â€™11) .Association forComputingMachinery,NewYork,NY, USA,57Å›68.
https://doi.org/10.1145/1960275.1960284
[30]ChristianKÃ¤stner.2017. DifferentialTestingforVariationalAnalyses:Experience
from DevelopingKConfigReader. arXiv: 1706.09357 [cs.SE]
[31]JÃ¶rg Liebig, Alexander von Rhein, Christian KÃ¤stner, Sven Apel, Jens DÃ¶rre, and
Christian Lengauer. 2013. Scalable Analysis of Variable Software. In Proceedings
of the 2013 9th Joint Meeting on Foundations of Software Engineering (Saint Pe-
tersburg,Russia) (ESEC/FSE2013) .AssociationforComputingMachinery,New
York, NY, USA,81Å›91. https://doi.org/10.1145/2491411.2491437
[32]FlÃ¡vio Medeiros, Christian KÃ¤stner, MÃ¡rcio Ribeiro, Rohit Gheyi, and Sven Apel.
2016. A Comparison of 10 Sampling Algorithms for Configurable Systems. In
Proceedings of the 38th International Conference on Software Engineering (Austin,
Texas)(ICSE â€™16) . Association for Computing Machinery, New York, NY, USA,
643Å›654. https://doi.org/10.1145/2884781.2884793
[33]Jean Melo, Elvis Flesborg, Claus Brabrand, and Andrzej Wasowski. 2016. A
QuantitativeAnalysisofVariabilityWarningsinLinux.In ProceedingsoftheTenth
International Workshop on Variability Modelling of Software-intensive Systems
(Salvador,Brazil) (VaMoSâ€™16) .ACM,NewYork,NY,USA,3Å›8. https://doi.org/
10.1145/2866614.2866615
[34]Austin Mordahl, Jeho Oh, Ugur Koc, Shiyi Wei, and Paul Gazzillo. 2019. An
EmpiricalStudyofReal-WorldVariabilityBugsDetectedbyVariability-Oblivious
Tools.In Proceedingsofthe201927thACMJointMeetingonEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering
(Tallinn,Estonia) (ESEC/FSE2019) .AssociationforComputingMachinery,New
York, NY, USA,50Å›61. https://doi.org/10.1145/3338906.3338967
[35]RaphaelMuniz,LarissaBraz,RohitGheyi,WilkersonAndrade,BaldoinoFonseca,
and MÃ¡rcio Ribeiro. 2018. A Qualitative Analysis of Variability Weaknesses
in Configurable Systems with #Ifdefs. In Proceedings of the 12th International
Workshop on Variability Modelling of Software-Intensive Systems (Madrid, Spain)
(VAMOS2018) .ACM,NewYork,NY,USA,51Å›58. https://doi.org/10.1145/3168365.
3168382
[36]SarahNadi,ThorstenBerger,Christian KÃ¤stner, andKrzysztof Czarnecki.2015.
WhereDoConfigurationConstraintsStemFrom?AnExtractionApproachandan
Empirical Study. IEEE Transactions on Software Engineering 41, 8 (2015), 820Å›841.
https://doi.org/10.1109/TSE.2015.2415793
[37]SarahNadiandRicHolt.2012. MiningKbuildtoDetectVariabilityAnomalies
inLinux.In Proceedingsofthe201216thEuropeanConferenceonSoftwareMain-
tenance and Reengineering (CSMR â€™12) . IEEE Computer Society, USA, 107Å›116.
https://doi.org/10.1109/CSMR.2012.21
[38]JehoOh,NecipFazÄ±lYÄ±ldÄ±ran,JulianBraha,andPaulGazzillo.2021. Artifactfrom
"Finding Broken Linux Configuration Specifications by Statically Analyzing the
Kconfig Language" .https://doi.org/10.5281/zenodo.4885001
[39]Jeho Oh, NecipFazÄ±lYÄ±ldÄ±ran, JulianBraha,andPaul Gazzillo.2021. Experimen-
tal data from "Finding Broken Linux Configuration Specifications by Statically
Analyzingthe Kconfig Language" .https://doi.org/10.5281/zenodo.4563310
904Finding Broken LinuxConfigurationSpecificationsby StaticallyAnalyzingthe Kconfig Language ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
[40]Jeho Oh, Necip FazÄ±l YÄ±ldÄ±ran, Julian Braha, and Paul Gazzillo. 2021. Formal
Semantics of Kconfig for "Finding Broken Linux Configuration Specifications
by Statically Analyzing the Kconfig Language". https://doi.org/10.5281/zenodo.
4950763
[41]RianShambaugh,AaronWeiss,andArjunGuha.2016.Rehearsal:AConfiguration
Verification Tool for Puppet. In Proceedings of the 37th ACM SIGPLAN Conference
on Programming Language Design and Implementation (Santa Barbara, CA, USA)
(PLDI â€™16) . Association for Computing Machinery, New York, NY, USA, 416Å›430.
https://doi.org/10.1145/2908080.2908083
[42]Steven She. 2013. LVAT Archive. https://code.google.com/archive/p/linux-
variability-analysis-tools/ , lastaccessed on11/19/20.
[43]StevenSheandThorstenBerger.2010. FormalsemanticsoftheKconfiglanguage.
Technicalnote, UniversityofWaterloo 24(2010).
[44]StevenShe,RafaelLotufo,ThorstenBerger,AndrzejWÄ…sowski,andKrzysztof
Czarnecki. 2011. Reverse Engineering Feature Models. In Proceedings of the 33rd
InternationalConferenceonSoftwareEngineering (Waikiki,Honolulu,HI,USA)
(ICSEâ€™11) . Association for ComputingMachinery, NewYork, NY, USA, 461Å›470.
https://doi.org/10.1145/1985793.1985856
[45]She, Steven. 2013. Feature Model Synthesis . Ph.D. Dissertation. http://hdl.handle.
net/10012/7834
[46]JiangfanShi,MyraB.Cohen,andMatthewB.Dwyer.2012. IntegrationTestingof
Software Product Lines Using Compositional Symbolic Execution. In Proceedings
of the 15th International Conference on Fundamental Approaches to Software Engi-
neering(Tallinn,Estonia) (FASEâ€™12) .Springer-Verlag,Berlin,Heidelberg,270Å›284.
https://doi.org/10.1007/978-3-642-28872-2_19
[47]J.Sincero,H.Schirmeier,W.SchrÃ¶der-Preikschat,andO.Spinczyk.2007. Isthe
linuxkernelasoftwareproductline?.In ProceedingsoftheInternationalWorkshop
onOpenSourceSoftwareandProductLines (Kyoto,Japan) (SPLC-OSSPL) .134Å›140.
[48]Julio Sincero, Reinhard Tartler, Daniel Lohmann, and Wolfgang SchrÃ¶der-
Preikschat. 2010. Efficient Extraction and Analysis of Preprocessor-Based
Variability. In Proceedings of the Ninth International Conference on Genera-
tive Programming and Component Engineering (Eindhoven, The Netherlands)
(GPCEâ€™10) .AssociationforComputingMachinery,NewYork,NY,USA,33Å›42.
https://doi.org/10.1145/1868294.1868300
[49]Thodoris Sotiropoulos, Dimitris Mitropoulos, and Diomidis Spinellis. 2020. Prac-
tical Fault Detection in Puppet Programs. In Proceedings of the ACM/IEEE
42nd International Conference on Software Engineering (Seoul, South Korea)
(ICSE â€™20) . Association for Computing Machinery, New York, NY, USA, 26Å›37.
https://doi.org/10.1145/3377811.3380384
[50]JasperSpaans.2020. LinuxKernelMailingList. https://lkml.org/ ,lastaccessed
on11/19/20.
[51]ReinhardTartler,ChristianDietrich,JulioSincero,WolfgangSchrÃ¶der-Preikschat,
and Daniel Lohmann. 2014. Static Analysis of Variability in System Software:The90,000#ifdefsIssue.In Proceedingsofthe2014USENIXConferenceonUSENIX
Annual Technical Conference (Philadelphia, PA) (USENIX ATCâ€™14) . USENIX Asso-
ciation, USA,421Å›432.
[52]Reinhard Tartler, Daniel Lohmann, Julio Sincero, and Wolfgang SchrÃ¶der-
Preikschat. 2011. Feature Consistency in Compile-Time-Configurable System
Software:FacingtheLinux10,000FeatureProblem.In ProceedingsoftheSixth
ConferenceonComputerSystems (Salzburg,Austria) (EuroSysâ€™11) .Association
for Computing Machinery, New York, NY, USA, 47Å›60. https://doi.org/10.1145/
1966445.1966451
[53]ReinhardTartler,JulioSincero,ChristianDietrich,WolfgangSchrÃ¶der-Preikschat,
andDanielLohmann.2012. Revealingandrepairingconfigurationinconsisten-
ciesinlarge-scalesystemsoftware. InternationalJournalonSoftwareToolsfor
Technology Transfer 14,5 (2012), 531Å›551.
[54]LinuxTovalds.2020. LinuxKconfigSourceCode. https://github.com/torvalds/
linux/tree/master/scripts/kconfig , lastaccessed on11/19/20.
[55]Mahsa Varshosaz, Mustafa Al-Hajjaji, Thomas ThÃ¼m, Tobias Runge, Moham-
mad Reza Mousavi, and Ina Schaefer. 2018. A classification of product sampling
forsoftwareproductlines.In Proceedingsofthe22ndInternationalSystemsand
SoftwareProductLineConference-Volume 1 . 1Å›13.
[56]AlexandervonRhein,JÃ¶rgLiebig,AndreasJanker,ChristianKÃ¤stner,andSven
Apel. 2018. Variability-Aware Static Analysis at Scale: An Empirical Study. ACM
TransactionsonSoftwareEngineeringandMethodology 27,4(2018),ArticleNo.
18.https://doi.org/10.1145/3280986
[57]Martin Walch, Rouven Walter, and Wolfgang KÃ¼chlin. 2015. Formal analysis
of the Linux kernelconfigurationwith SATsolving.In ConfigurationWorkshop .
131Å›138.
[58]Eric Walkingshaw, Christian KÃ¤stner, Martin Erwig, Sven Apel, and Eric Bodden.
2014. Variational Data Structures: Exploring Tradeoffs in Computing with Vari-
ability. In Proceedings of the 2014 ACM International Symposium on New Ideas,
NewParadigms,andReflectionsonProgramming&Software (Portland,Oregon,
USA)(Onward!2014) .AssociationforComputingMachinery,NewYork,NY,USA,
213Å›226. https://doi.org/10.1145/2661136.2661143
[59]Aaron Weiss, Arjun Guha, and Yuriy Brun. 2017. Tortoise: Interactive System
Configuration Repair. In Proceedings of the 32nd IEEE/ACM International Con-
ferenceonAutomatedSoftwareEngineering (Urbana-Champaign,IL,USA) (ASE
2017). IEEE Press,625Å›636.
[60]Chengyuan Wen, Yaxuan Zhang, Xiao He, and Na Meng. 2020. Inferring and
Applying Def-UselikeConfigurationCouplings inDeployment Descriptors.In
Proceedingsofthe35thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (Virtual Event, Australia) (ASE â€™20). Association for Computing Ma-
chinery, New York, NY, USA, 672Å›683. https://doi.org/10.1145/3324884.3416577
[61]Christoph Zengler and Wolfgang KÃ¼chlin. 2010. Encoding the Linux kernel con-
figurationin propositionallogic.In Proceedingsofthe 19thEuropeanConference
onArtificialIntelligence(ECAI2010)WorkshoponConfiguration ,Vol.2010.51Å›56.
905