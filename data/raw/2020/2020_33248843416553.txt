Cross-Contract Static Analysis for Detecting Practical
Reentrancy Vulnerabilities in Smart Contracts
Yinxing Xue
University of Science and Technology
of China
Hefei, China
yxxue@ustc.edu.cnMingliang Ma
University of Science and Technology
of China
Hefei, China
sa517245@mail.ustc.edu.cnYun Lin∗
National University of Singapore
Singapore
dcsliny@nus.edu.sg
Yulei Sui
University of Technology Sydney
Sydney, Austrilia
yulei.sui@uts.edu.auJiaming Ye
University of Science and Technology
of China
Hefei, China
sa517462@mail.ustc.edu.cnTianyong Peng
University of Science and Technology
of China
Hefei, China
sa517270@mail.ustc.edu.cn
ABSTRACT
Reentrancybugs,oneofthemostseverevulnerabilitiesinsmartcon-
tracts, have caused huge financial loss in recent years. Researchers
have proposed many approaches to detecting them. However, em-
pirical studies have shown that these approaches suffer from un-
desirablefalse positivesandfalse negatives,whenthecode under
detectioninvolvestheinteractionbetweenmultiplesmartcontracts.
Inthispaper,weproposeanaccurateandefficientcross-contract
reentrancy detection approach in practice. Rather than design rule-
of-thumbheuristics,weconductalargeempiricalstudyof11714
real-world contracts from Etherscan against three well-known
general-purpose security tools for reentrancy detection. We manu-
allysummarizedthereentrancyscenarioswherethestate-of-the-art
approaches cannot address. Based on the empirical evidence, we
presentClairvoyance,across-functionandcross-contractstatic
analysis to detect reentrancy vulnerabilities in real world with sig-
nificantly higher accuracy. To reduce false negatives, we enable,
for the first time, a cross-contract call chain analysis by tracking
possibly tainted paths. To reduce false positives, we systematically
summarizedfivemajorpathprotectivetechniques(PPTs)tosup-
portfastyetprecisepathfeasibilitychecking.Weimplementedour
approachandcomparedClairvoyancewithfivestate-of-the-art
tools on 17770 real-worlds contracts. The results show that Clair-
voyanceyieldsthebestdetectionaccuracyamongallthefivetools
and also finds 101 unknown reentrancy vulnerabilities.
CCS CONCEPTS
•Securityandprivacy →Distributedsystemssecurity ;•Soft-
ware and its engineering →Software safety.
∗Yun Lin is the corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416553KEYWORDS
reentrancy vulnerabilities, static taint analysis, cross-contract anal-
ysis, smart contracts
ACM Reference Format:
Yinxing Xue, Mingliang Ma, Yun Lin, Yulei Sui, Jiaming Ye, and Tiany-
ong Peng. 2020. Cross-Contract Static Analysis for Detecting Practical
Reentrancy Vulnerabilities in Smart Contracts. In 35th IEEE/ACM Inter-
nationalConferenceonAutomatedSoftwareEngineering(ASE’20),September
21–25,2020,VirtualEvent,Australia. ACM,NewYork,NY,USA,12pages.
https://doi.org/10.1145/3324884.3416553
1 INTRODUCTION
Poweredbytheblockchainplatform,smartcontractsareexecutable
contracts written in the form of computer programs [ 38], which fa-
cilitate,verify,andenforcethetradingtransactionsbetweenbuyers
and sellers in an automatic and transparent way without involving
third parties. On the most popular platform (i.e., Ethereum [ 1]),
contracts are written using Solidity language. Security issues, as
surveyed in [8], are the major concerns of Solidity programs.
Reentrancy,alsoknownasthenotoriousDAOattack[ 16],has
caused a devastating financial loss of around $150 million stolen
Ether (digital currency) for many Ethereum accounts. The vulnera-
bility lies in that the attacker can leverage fallback functionalities
inSoliditytorepetitivelyincurthepaymentuntilexhaustingthe
balance of the victim (an example is shown in Fig. 1). To addressthis issue, existing approaches [
13,24,25,35,48–50] define a va-
rietyofrulestodetectandavoidillegal(orsuspicious)useofthe
fallback function in Solidity program. In this regard, most general-
purposesecurityscanningtools(e.g.,Slither[ 49],Oyente[ 35],
Zeus[25],Mythril[ 13],Manticore[ 48],Contract-Fuzzer[ 24]
and Securify [50]) claim to support reentrancy bug detection.
However,therelacksastudyonhowtheexistinggeneral-purpose
security tools actually perform on large-scale reentrancy detec-tion from real-world contracts. To answer this problem, in thispaper, we initially conduct a large-scale empirical study on us-ing three general-purpose static tools for reentrancy detection
(i.e., Oyente [
35] from CCS’16, Securify [ 50] from CCS’18 and
Slither [ 49] from industry) on 11714 real-world contracts from
Etherscan [2]. The empirical evidence shows that:
10292020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
•Programmers have already invented many programming
paradigms to avoid reentrancy attack. Without being aware
ofthoseparadigms,existingstate-of-the-artsecuritytools
report many false positives (FPs);
•On the other hand, existing tools usually define rules at
intra-procedurallevel,whichincurstheincompletemodel-
ingofprogrampaths,particularlycross-contractandinter-
proceduralcallpathsinSolidityprograms.Italsocausesa
considerable number of false negatives (FNs).
Inthiswork,weformallysummarizethose paradigmstoavoid
reentrancyattackas PathProtectionTechnique (PPT),andproposea
cross-function and cross-contract static analysis approach for reen-
trancybugdetection.Ourapproachmodelsmoresoundinterproce-
dural paths (to reduce FNs) and identifies feasible interprocedural
paths by considering PPTs (to reduce FPs). More specifically, we
first construct a cross-contract interprocedural control flow graph
(XCFG), on which a static taint analysis is performed to identify
potential paths that contain a reentrancy, and then perform a light-
weight symbolic analysis based on PPTs to eliminate infeasible
paths,andfinallyreportreentrancy bugsbasedontherefinedfea-
sible program paths. Based on the technique, we build and publish
ourtoolClairvoyance(avaiableat[ 5]).WecomparedClairvoy-
ancewithfivestate-of-the-arttoolson17770contractsfromGoogle
BigQueryOpenDataset.TheexperimentalresultsshowthatClair-
voyance (1) yields the best detection accuracy among all the tools
and (2) finds 101 unknown reentrancy vulnerabilities.
In summary, this paper makes the following contributions:
•Wepresentalarge-scaleempiricalstudyto(1)evaluatethe
ineffectiveness of three state-of-the-art static tools to detect
reentrancyattackinpractice and(2)understandthepracti-
cal programming paradigm (summarized as PPT) to avoid
reentrancy attack.
•We present a new static reentrancy detection approach to
enable (1) more sound analysis by modeling cross-function
cross-contract behaviors, and (2) more precise analysis by
applying a light-weight symbolic analysis based on PPTs.
•Unlikeexistingstatictools whichyieldabinaryresult(vul-
nerable or not), our approach supports a more accurate bug
reporting method by providing the feasible call chain(s) that
causethereentrancy.Sothe understandability ofdetection
results is improved.
•Wehavecomparedourtool,Clairvoyance,withthethree
state-of-the-art static tools (i.e., Oyente [ 35], Securify [ 50]
andSlither[ 49])andtwodynamictools(i.e.,Mythril[ 13]
andsFuzz[ 21])on17770contractsfromGoogleBigQuery
Open Dataset. The results show that Clairvoyance hassignificantly better accuracy than the compared tools, and
successfully finds 101 unknown reentrancy bugs that are all
missed by the compared tools. Our experimental results are
publicly available at [5].
2 BACKGROUND AND MOTIVATION
In this section, we briefly introduce the fallback mechanism ofSolidity and explain how it can cause reentrancy. Then, we in-
troducethreestate-of-the-artstatictools,includingSlither[ 49],
Securify[ 50],andOyente[ 35],withexamplesoftheFNsandFPs.1contract Partner {
2 mapping (address =>uint256 )public balances;
3 function deposit() {
4balances[msg.sender] += msg. value;
5}
6 function withdraw( uint256 _amount) public {
7 require (balances[msg.sender] >= _amount);
8 require (msg.sender. call.value(_amount)());
9balances[msg.sender] -= _amount;
10}
11}
Figure 1: A simple example for reentrancy vulnerability.
2.1 Fallback Function of Solidity Program
On Ethereum, most smart contracts are implemented in Solidity,
which supports basic structural elements, including contract (simi-
lartoclass inOOP),variable,function, etc.OnceSoliditycontract
is published (e.g., on Ethereum), the program is regarded as a “law”andcannolongerbealtered.Giventhelawproperty,specialmech-
anisms such as fallback function are introduced. From law point
of view, the contract should define its behavior in any case. Hence,
fromtechnicalpointofview,theexecutionoffallbackfunctionis
triggered to handle some exceptional cases such as (1) when its
owningcontractiscalledwithanunknownfunctionname,or(2)
when the contract receives plain Ether (i.e., Ehtereum currency)
withoutdata.Nevertheless,suchamechanismintroducesnotorious
reentrancyvulnerabilities,causingdevastatingeconomicloss[ 6,8].
2.2 Reentrancy Vulnerability
Fig. 1 shows an example of a reentrancy vulnerability. The Partner
contractsupportsothercontractstodepositmoneyto(via deposit()
functionatline3)orwithdrawmoneyfrom(via withdraw() function
at line 6) its account. The other contract account is represented by
balances[msg.sender] field inPartnercontract1.I nt h ewithdraw()
function, Partnercontractfirstcheckswhether balances[msg.sender]
has a sufficient amount (line 7). If so, Partnertransfers to the other
contract (line 8) and updates the balances (line 9).
The root cause lies in that the malicious contract can repet-
itively incur the payment (line 8) without finishing the call tothe method
withdraw() until exhuasting the balance. Assume a
maliciouscontract Malihastwofunctions,onefunction attack()
thatcalls Partner.withdraw() andtheotherfunction(thefallback
function) that calls Partner.withdraw() . The attack happens when
Mali.attack() callswithdraw() function,whichexecutesline8of
Fig.1.Theexecutionof msg.sender.call.value() functionatline
8 will trigger the fallback function of Malicontract. Note that Mali
contractcancraftitsownfallbackfunctiontocall Partner.withdraw()
function for his or her own benefits. Once the fallback functionof
Malicontract is triggered to call Partner.withdraw() function,
the control flow goes back to line 7 and line 8, before balances-
[msg.sender] can be updated at line 9. Such a trick nullifies the
condition check at line 7. By this means, Malican repeatedly with-
draw money from Partnercontract.
2.3 State-of-the-arts and Their Limitations
ExistingstaticsecuritytoolssuchasSlither[ 49],Securify[ 50],
and Oyente [ 35] claim to address this vulnerability. These tools
1In Solidity, each contract has an address. Keyword msg.sender represents the
address of contract interacting with the owner contract.
10301contract Trader {
2TokenSale tokenSale = newTokenSale(); // Internal
Contract defined at line 8 in the same file
3 function combination() {
4tokenSale.buyTokensW ithWei();
5tokenSale.buyTokens(beneficiary);
6}
7}
8contract TokenSale {
9TokenOnSale tokenOnSale; // External Contract
10...
11 function set( address _add) {
12 tokenOnSale = TokenOnSale( _add);
13}
14 function buyTokens( address beneficiary) {
15 if(starAllocationToTokenSale > 0) {
16 tokenOnSale.mint(beneficiary, tokens);
17 }
18}
19 function buyTokensWithWei() onlyTrader {
20 wallet.transfer(weiAmount);
21}
22}
Figure 2: Complicated call graph and control flow graph
crosscontracts—anFNforSlither,OyenteandSecurify.
havetheirself-definedrulesforcheckingvulnerabilitiesinaSolidity
program. For example, according to Slither’s rule, a reentrancy
may happen if it satisfies the following condition:
/parenleftbig
r(varд)∨w(varд)/parenrightbig
/followsexternCall /followsw(varд)⇒reentrancy (1)
In Rule 1, r()andw()denote the read and write operations,
respectively; varдdenotes a certain public variable; /followsdenotes the
executionorderbasedontheprogram’scontrolflow; externCall
denotestheexternalcalltothe payment functionsexcept built-in
functions send()andtransfer() .Thus,therulemeansthatifthere
existsanexternalcalltoapaymentfunctionandthecallisbetweentwowriteoperations tothesamepublicvariable,areentrancymay
happen. In Fig. 1, function withdraw() is identified as a vulnerable
function by this rule. Specifically, (1) a read access to a public state
variable (at line 7), then (2) a call to an external address via the
low-level function call.value() (at line 8), and (3) a write access
tothepublicstatevariable(atline9).OyenteandSecurifyhave
similar static rules to detect the reentrancy in Fig. 1 (see §4).
These simple rules have been proved to be effective in some
cases, but more often, make detection results fall into FPs or FNs.FalseNegative(MissingCompleteCallChain)
: Existing static
tools for smart contracts usually fail to consider cross-function
orcross-contractcallchains,missinganalysisofsomeimportant
yet suspicious program paths. Fig. 2 shows a contract contains a
reentrancy vulnerability that is missed by Slither, Securify, and
Oyente.Fig.3showsitscorrespondingcross-contractCFG(XCFG),
where each rectangle represents a function, each circle represents
a statement denoted by its line number in Fig. 2, and each directed
edgerepresentsthecontrolflow.Moreover,weuseavirtualnode
(denoted by V) in the function of TokenSale.buyTokens() to show
the returned control flow, a grey node to represent payment state-
ment,anddashedrectangletorepresentanunknownfunctionof
an external contract (i.e., TokenOnSale.mint() ).Notably, the dashed
rectangle could call any function as its behavior is unknown.
FromFig.3,wecanseethat,aslongas TokenOnSale contractis
malicious,thereexistsacallchain 4/circlecopyrt→20/circlecopyrt→4/circlecopyrt→5/circlecopyrt→15/circlecopyrt→
16/circlecopyrt→?/circlecopyrt→4/circlecopyrt→..., which allows the attacker to recursively call
wallet.transfer(weiAmount) (line 20). Such attack crosses multiple
Figure3:Cross-functionandCross-contractCFGforFig.2∗.
∗Note: The grey node 20/circlecopyrtdenotes a statement of payment function (reen-
trancy vulnerability requires reentering of a payment function), ?/circlecopyrtdenotes
amaliciousstatementintheexternalunknownfunctionthatmaycallback.
contracts and functions, and does not write any public variable,
which makes it hard to enumerate rules for its detection.
FalsePositive(InaccuratePathFeasibility): Existingstatictools
canhardlyidentifypathfeasibility.Fig.4showsacontractthatis
mistakenly reported as a reentrancy vulnerability by Slither and
Securify as it conforms to their defined rules. Fig. 5 shows its
XCFG. We can see that there exists a reentered call chain 5/circlecopyrt→
7/circlecopyrt→8/circlecopyrt→9/circlecopyrt→?/circlecopyrt→5/circlecopyrt→7/circlecopyrt→..., as the unknown function
ZTHTKN.buyAndSetDivPercentage.value() mayusethefallbackfunc-
tiontocallbackfunction receiveDividends() .However,inpractice,
suchpathinCFGtoexercisethechaincanneverbefeasible.The
reasonisthat 5/circlecopyrt→7/circlecopyrtrequiresreEntered =truewhile?/circlecopyrt→5/circlecopyrt
→7/circlecopyrtrequiresreEntered =false. They are contradictory.
Fig. 4 is a typical example, where a path protective technique
(PPT) is applied as a countermeasure for reentrancy attack. The
logic of the code ensures that the check condition (line 5) can al-
waysprotecttheexecutionofpaymentstatement.Unfortunately,
both Slither and Securify fail to recognize this infeasible path.
Notably, to accurately identify this PPT from code, light-weight sym-
bolicanalysisisrequiredtochecklockingatline8andunlockingat
line10,andsuchanalysiscouldbejustlimitedintheinternalfunction.
ToovercomingFPs/FNsisnon-trivial,whichrequiresaddressing
these challenges:•
Giventhebehaviorofthepossibleexternally-interactingcontract
is unknown, how do we model its unknown call graph?
•Thepathnumberexplodeswhenthefunction/contractnumber
increases,howdoweefficientlyidentifythosesuspiciousreen-
trancy attack paths from a set of Solidity programs?
•Can we conduct the light-weight path feasibility analysis, which
can achieve the efficiency meanwhile not compromising the
soundness/completeness of our approach?
•How can we incorporate Solidity-specific features impacting
control flowgraph likefunction modifier,address binding, etc.?
We propose a scalable static approach that can systematically
compute those suspicious and feasible paths to cause reentrancy
vulnerability with respect to both cross-contract call chains and
10311contract ZethrBankroll is ERC223Receiving {
2ZTHInterface public ZTHTKN;
3bool inter nal reEntered;
4 function receiveDividends() public payable {
5 if(!reEntered) {
6 ...
7 if(ActualBalance > 0.01 ether) {
8 reEntered = true;
9 ZTHTKN.buyAndSetDivPercentage. value(ActualBalance
)(address (0x0), 33, "");
10 reEntered = false;}
11 }
12}
13}
14contract ZTHInterface { // To be inherited for
implementing the function buyAndSetDivPercentage
15 function buyAndSetDivPercentage( address _referredBy,
uint8 _divChoice, string providedUnhashedPass)
public payable returns ( uint);// Declaration
16}
Figure 4: Complicated path constraints due to using an exe-
cution lock reEntered — an FP for Slither and Securify.
ZethrBankroll.receiveDividends()
5
7
8V
ZTHTKN.buyAndSet
DivPercentage()
?9
10
Figure 5: Cross-function and Cross-contract CFG for Fig. 4.
pathfeasibility.Thecross-contractcallchainconstructioncanef-
fectively mitigatethe problem of missingreentrancy control flow.
Identifyinginfeasiblepathsmainlyreliesonpathprotectivetech-
niques(PPTs)toreducetheFPswherereentrancyvulnerabilities
never exist.
3 OVERVIEW
Problem Statement. Weargue thatreentrancyattackcouldhap-
penwhen there exists a feasible program path in cross-contract CFG
(XCFG) of Solidity contracts, which starts from setting an insecure
contract(oraddress)andendswiththepaymentfunctioncall (e.g.,
call().value() ) of that contract (or address).
Assumption&Challenges. Ourapproachfollowstheclose-world
assumptionofanalyzingsmartcontracts.Givenatargetcontract,
our analysis scope includes the source code of all its caller and
calleecontracts.TheSolidityAPIsofaprogramwithoutfunction
bodies (e.g., fallback and low-level built-in functions) are analyzed
based on their side-effect summarization following the standard
approach in static analysis.
Fig. 6 shows an overview of our approach, which takes as input
the source code of Solidity contracts and its caller/callee, and re-
ports call chain(s) with path conditions to explain how a malicious
contractcanconstructareentrancyattacktoexploitthevulnera-
bility.InFig.6,eachrectanglerepresentsanartifact,eachellipse
representsastep(orprocess),eachedgerepresentstheworkflowof
how a step takessome artifacts and outputs some new artifact.In
addition, we highlight the input/output in grey. As shown in Fig. 6,
our approach consists of the following four steps:
Figure 6: System diagram
S1. XCFG Construction: We first construct cross-contract call
graphandCFGamongtheinputsmartcontracts.Inthisstep,
wehandleSolidityspecificfeatures(e.g.,modifier,fallbackfunc-
tion) and collect all call chains starting from public functions.
S2. Static Taint Analysis: Next,weidentifytaintedcontractob-
jectsoraddresses,andtrackhowtheyareusedandpropagated
along the call chain from the XCFG. In this step, we identify
vulnerable call chains from XCFG, which start with a suspi-
cious contract address (or object) and end with the external
function call.
S3. Empirical Study (Summarizing PPTs): In order to mitigate
the FPs of reported paths (abstracted by the vulnerable call
chains), we summarize a set of PPTs for reentrancy attack
through an empirical study, which could be used for checking
the path feasibility in a scalable way.
S4. Path Filtering: ForthesePPTs,wedefinethecorresponding
filtering patterns via program analysis: paths with access con-
trol,pathswithhard-codedaddress,pathswithexecutionlocks,
paths with internal updating before payment, etc. Then, given
thevulnerablecallchainsfromS2andthefilteringpatternsbe-hindPPTsfromS3,wefilteroutinfeasiblepaths,whichcannot
form reentrancy in practice and hence lead to FPs. Finally, the
remaining reachable paths will be the outputting results.
S1 (§5.1) and S2 (§5.2) are designed for mitigating FNs, while S4
(§5.3 and §5.4) is designed for addressing FPs. Next, for readability,
we first explain S3 (§4) — the empirical study for reasons: (1) quan-
titatively analyzing how (in)effective existing static tools on 11714
smartcontractsinthefield;(2)howeffectiveoursummarizedPPTs
are. Then, we proceed to elaborate on each step of our approach.
4 EMPIRICAL STUDY OF TYPICAL FALSE
POSITIVES FOR EXISTING RULES
In our empirical study, Slither [ 20] v0.4.6, Oyente [ 35] v0.2.7
and Securify [ 50] v1.0 run on 11714 frequently-used real-world
contracts from the well-known third-party website Etherscan for
contract indexing and browser [ 2]. For the detection results, we
recruit 4 researchers to spend 2 months in reviewing the results
and summarizing the patterns of FPs for rules in these tools.
4.1 Rules of Existing Tools
In§2.3,thedetectionruleof Slithercheckswhetherthereexistsan
externalcall of money transfer functions (except built-in functions
10321contract CozyTimeAuction {
2 function buyCozy( uint256 _pepeId, uint256 _cozyCand,
address _pepeRec) public payable {
3 require (address (pepeContract) == msg.sender);
4PepeAuction storage auction = auctions[_pepeId];
5totalFee = ... // ignore the details
6auction.seller.transfer(price - totalFee); //transfer
7 if(!pepeContract.cozyTime(auction. pepeId, _ cozyCand,
_pepeRec)) {...} //externa l call
8delete auctions[_pepeId]; // write after call
9}...
10}
Figure 7: A real case of using access control (PPT1) for the
account address — an FP for Slither and Securify.
send(),transfer() )thathappensbetweenwritestoapublicvari-
able.Similarly,accordingto[ 50],wefindthatSecurifyproposes
thecompliancepattern Nowritesafter call topreventreentrancy2.
Hence,thecorrespondingviolationpatternistohavewritesafter
call, as shown by the Rule 2:
externCall /followsw(varд)⇒reentrancy (2)
wherew(varд)means write operation(s) to a public variable and
externCall refers to the external call for money transfer functions.
OyentesupportsthefollowingRule3,accordingto[ 35]:
r(varд)∧(дastrans >2300)∧(vart_a>vard_a)
∧/parenleftbigw(varд)/followsexternCall )/parenrightbig⇒reentrancy(3)
wherer()andw()means read and write operation(s) to a public
variable, дastrans>2300 means the gas for transaction must be
greaterthan2300,thetransferamount vart_amustbegreaterthan
the deposit amount vard_a, and the public variable varдshould
be changed before the external call (denoted by /follows). As Oyente
works on the EVM bytecode instructions, the gas consumption
is estimated on the instructions. Notably, Slither and Securify
considerwritesaftercalls asoneconditionthatformsreentrancy,
but Oyente considers writes before calls as one key condition3.
After we investigate the implementations of these three state-
of-the-arts, we observe that their detection rules are too simple
andcoarse-grained,basicallyignorantofthepossibleprogrammingskillsusedbythedeveloper topreventthereentrancy. Shortly,path
in-feasibility analysis is insufficiently supported by the three staticstate-of-the-arts. Hence, it is expected that these tools will yield
many FPs for real-world contracts.
4.2 PPT1: Access Control Before Payment
Fig.7givesanFPreportedbySlitherandSecurifybasedonits
Rule 1. The code firstly reads the state variable auctions[_pepeId] ;
then calls an external function via pepeContract.cozyTime() ; last,
writes (deleteinstruction belongs to the general write operations)
to the public variable auctions[_pepeId] . However, in reality, reen-
trancy cannot be triggered by external attackers due to the require
checkrequire(address(pepeContract) == msg.sender) atline3in
Fig. 7. Access control usually checks the invoker of the payment
functions—checkingwhethertheidentityof msg.sender satisfies
2In Securify, two types of detected errors are related to reentrancy, i.e., DAOand
DAOConstantGas.Thetwoerrorswillleadtoreentrancy,andtheonlydifferenceis
whether the gas will be recursively used or not (with constant gas).
3We confirm this rule from the implementation of Oyente.1interface HgInterface {
2 function buy( address _add) payab le external returns(
uint256 );
3}
4contract Richer3D {
5...
6 mapping (uint256 =>DataModal.RoundInfo) rID;
7HgInterface constant p3d = HgInterface(0
xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
8 function calculateTarget() public {
9 if(increaseBalance >= targetBalance) {
10 if(increaseBalance > 0)
11 { p3d.buy. value(ethForP3D)(p3dAddress); }
12 }...
13 rID[rNumber].lastTime = _timestamp ;...
14}
15}
Figure 8: A real case of using the constant value (PPT2) forthe contract address — an FP for Oyente and Securify.
1contract RTB2 {
2modifier onlyHuman() {
3 address _addr = msg.sender;
4 uint256 _codeLength;
5assembly {_codeLength := extcodesize(_addr)}
6 require (_codeLength == 0, "sorry humans only" ); _;
7}
8 function buy( uint256 _amt) exter nal onlyHuman payable{
9 require (balances[msg.s ender] >= _amt);
10 require (msg.sender. call.value(_amt)());
11 balances[msg.sender] -= _amt;
12}
13}
Figure9:Arealcaseofusingaself-definedmodifierforpro-tection(PPT3)—anFPforSlither,OyenteandSecurify.
certainconditions(e.g.,insomeauthorizedlist,withagoodreputa-
tion, or having the dealing history). Notably, PPT1 needs to reside
inthe samefunction asexternal calls,otherwise itcan beavoided.
4.3 PPT2: Hard-coding Payment Address
Fig.8showsanFPreportedbyOyenteandSecurify,whichadopts
a hard-coded address to prevent the malicious external attack. Ac-
cording to Rule 3, as this code block has a balance check and alow-level-call for money transfer, it is reported by Oyente as a
reentrancy.Similarly,accordingtoRule2,thereisawriteoperationtothepublicvariable
rID[rNumber].lastTime aftertheexternalcall,
and hence Securify detects it. However, this example cannot be
exploitedbyanyarbitraryexternal address,owingtothe20bytes
hard-codedaddress(i.e., 0xB3...efBe )forcontractobject p3datline
7 in Fig. 8. Hence, PPT2 restricts the external malicious access.
4.4 PPT3: Protection by Self-defined Modifiers
Fig. 9 gives another FP that is reported by the existing tools ig-
noring PPT3. This code block actually considers the security issue
and adds the self-defined modifier onlyHuman() before the poten-
tial vulnerable function buy(). SinceonlyHuman() restricts that the
transactioncanbeonlyconductedbytheaddressof msg.sender via
the usage of keyword extcodesize , which returns 0 if it is called
from the constructor of a contract. In such a way, via PPT3, buy
could not be recursively called by external attackers.
4.5 PPT4: Protection by Execution Locks
Different from the above PPTs relying on access control or re-stricted addresses to prevent external malicious calls, PPT4 pre-
ventstherecursiveentranceofthefunction—eliminatingtheissue
10331contract PvPCrash {
2 function withdraw() gasMin public returns (bool) {
3 address _user = msg.sender;
4 uint256 _userBalance;
5 if(!roundEnded && withdrawBlock[block.number] <=
maxNumBlock) {
6 _userBalance = getBalance(_user);
7 if(_balance > _userBalance) {
8 if(_userBalance > 0) {
9 _user.transfer(_userBalance); //externalCall
10 emit With draw(_user, _userBalance);
11 }
12 return true ;
13 }
14 }
15 return true ;
16}
17}
Figure10:Arealcaseofupdatinginternalstatesbeforepay-
ment (PPT5) — an FP for Oyente.
from root. For instance, in Fig. 4, the internal instance variable
reEntered will be checked at line 5 before processing the business
logicbetweenline8and10.Topreventthereenteringduetocalling
ZTHTKN.buyAndSetDivPercentage.value() ,reEntered willswitchto
true; after the transaction is finished, it will be reverted to false
to allow other transactions. Hence, by virtue of PPT4, this solution
issimilarwithusingmutex,whichpreventsthereentrancyfrom
both the authorized addresses or external malicious addresses.
4.6 PPT5: Internal Updating Before Payment
PPT5isrequiredtofinishallinternalwork(i.e.,stateandbalance
changes)andthencalltheexternalpaymentfunction.Accordingto
the report from ConsenSys [ 15], the recommended pattern is com-
posed of three steps: (1)all the requirechecks are atthe beginning
of function buy_the_tokens ; (2) in the middle are the internal state
changes for bool and numeric variables; (3) at the end is the call of
built-inpaymentfunctions transfer() ofsomeexternal contracts
or addresses. This pattern is also recommended by Solidity official
documentat[ 42],namedas Checks-Effects-Interactionspattern to
prevent reentrancy.For example, for thecode in Fig. 10,it follows
this safe pattern. However, according to Rule 3 for Oyente, this
code block is mistakenly reported as vulnerable.
4.7 FP Statistics of Existing Rules
Finally,weauditalltheresultsofthethreetools,andsummarizethenumber of FPs due to mis-considerations or unsatisfactory supportofthesePPTs.Asaresult,67.5%ofFPsareaccountedforthe5PPTsinSlither,71.4%ofFPsareforPPTsin Oyente,and95.15%ofFPs
are for PPTs in Securify. Hence, we can confirm that the available
statictoolsignoreorunsatisfactorilysupportthesePPTsincode.
Notethatrecallisnotstatisticallyevaluatedinthisempiricalstudy,
as our goal is to understand the reasons behind the FPs of these tools.
Accordingtoourobservation,SecurifyandSlitherhavebetter
recalls than Oyente, as Rule 1 and 2 are more general than Rule 3.
5 APPROACH
In this section, we will detail each step of our approach in Fig. 6,including XCFG construction, static taint analysis, path filtering
based on PPTs, and finally outputting reachable vulnerable paths.Table 1: #FPs due to the inconsideration or unsatisfactory
support of PPTs for different tools in our empirical study.
Slither v0.4.6 Oyente v0.2.7 Securify v1.0
PPT1 7 2 16
PPT2 28 2 51
PPT3 15 3 46
PPT4 4 0 6
PPT5 0 3 38
PPTs/all #FP 67.5% 71.42% 95.15%
5.1 XCFGConstruction&CallChainGathering
XCG and CFG Generation. We first build the cross-contract call
graph(XCG)forSolidityprograms,whicharedirectedgraphswherenodesareSolidityfunctionsandedgesbetweenthemdenotecalling
relations.ThecallgraphofSolidityprogramsisgenerallysimilar
withthatofotherOOPlanguages,exceptthatthefallbackfunctions
and self-defined modifiers need to be considered to add additional
call edges for a more accurate call graph. For each function inside
theXCG,wealsobuilditsCFGadoptedfromSlithIR[ 20]afterthe
abstract syntax tree (AST) parsing.
XCFG Generation. XCFG is a combination of XCG and all the
CFGsoffunctionsofaSolidityprogram(notexplicitlysupported
bySlither).AccordingtotheXCG,wecanconnectalltheCFGs
forallfunctionsandmodifiers,andattainthecorrespondingXCFG.
Let us denote the two parts of a function call cross contracts: a
call-site node ciand a return-site node ri. There is a cross-contract
edgeci→scfrom a call-site node to the start node ( sc) of the
calledcontract c;thereisalsoacorrespondingedge ec→rifora
dedicatedexitnode ec.Forexample,theXCFGisillustratedinFig.3
andFig.5.Differentfromcallchainsstartingfromtheentryof main
function in Java, a call chain can start from any publicfunction
in Solidity and is considered valid if its cross-contract edges are
matched (i.e., each riis matched with the corresponding ci). In our
study, we aim to find vulnerable call chains from XCFG that satisfy
the condition — call chains with a loop due to calling unknown
external functions that may call back to the current callee function.Hence,theproblemcanbereducedtothat—howtofindvulnerable
call chains on the XCFG as complete as possible, a typical graph
traversing problem.
The Collector. We design the call chain collector with the follow-
ingAlgo.1.GiventheXCFGofaSoliditysourcecodefile,theinput
includes the taint input source ISthat is listed in Table 2, the set
of all public functions Fand the set of all call chains CFin the
XCFG. The output yielded by the approach is the set of vulnerable
call chains VC, each of which actually abstracts a possible vulnera-
ble path (VP) that leads to a reentrancy attack at execution time.
Algo. 1 is composed of three steps: (1) identifying the vulnerable
call chains via static taint analysis at line 1 to 8, see §5.2; (2) fil-tering the call chains that are actually non-vulnerable due to the
adoption of PPTs at line 9 to 11, see §5.3; and (3) finally outputting
allremainingvulnerablecallchainsasresultsatline12.Iftheinput
source file(s) have in total nfunctions (the maximum length of a
call chain without loop) and mlines of code (the maximum length
of a path without loop), the time complexity of Algo. 1 is O(nm).
Themosttime-consumingpartisthetwo-levelloopatline1to8.
1034Algorithm 1: CollectingVulCallChain(): traversing the XCFG
and collecting vulnerable call chains
input :IS, all the input source
input :F, all the public functions in XCFG
input :CF, all the call chains in XCFG
output:VC←∅, the set of potentially vulnerable call chains
1foreachcall chainc∈CFdo
2//get the concrete paths for con the XCFG
3Pc←c.дetConcretePaths ()
4foreachpathp∈Pcdo
5 s←дetSource (IS,p)//get input source for p
6 pt←propaдateByRules (p,s)taint propagation
7 ifisSinkOfTainted (pt)is Truethen
8 VC←VC∪{c},break;/ /cis vulnerable
9foreachcall chainc∈VCdo
10ififExistPPT (c)is Truethen
11 //if a filtering pattern in Table 3 is found
VC←VC−{c}//cis non-vulnerable
12returnVC
Table2:Thesourcesandrulesofthestatictaintanalyzerfor
Solidity programs.
IS(1) msg.sender, tx.origin
(2) parameters of public function
Rules(1) data assignment: a(address type) = _address
(2) address binding: object = ContractOfObject(_address)
(3) return value of functions: address/object = functon()
Sinkobject.method(), if object is tainted, then it is tainted
address.call.value(), if address is tainted, then it is tainted
Asnandmare usually not large in real-world contract files, the
overall performance is practically good on real-world contracts.
5.2 Static Taint Analyzer
GiventheconcretepathsrepresentedbycallchainsfromtheXCFG,
we identify vulnerable functions ( VFs) and vulnerable paths ( VPs)
by our static taint analysis as follows:
Target of Static Taint. In this study, vulnerable functions (VFs)
refertothoseunsafefunctionsthataresusceptibletoreentrancy
attack.Vulnerablepaths(VPs)refertotheexecutionpathsallowing
toreadexternalinputparameters Pi(e.g.,externaladdressortrans-
actionamount)andleadtoaVFwithvariablesvaluesdependingon
Pi.Wealsocallthesetofinputsource( IS)ofparametersastainted
data. Thus, we aim to identify the critical VPs that are susceptible
to reentrancy attack on the XCFG of a program via the tainted
data-dependencypathsflowingfromanIStoaVF.However,unlike
thetaintanalysisforJavaorC++programs,weneedtoconsider
the special features of Solidity language.Def andUse Relations.
Wefirstbuildthedatadependencyrela-
tionshipamongthevariablesinSolidityprograms.Therearetwo
types of program points (or nodes on XCFG) on the def-use chain
relations: 1) a usesite that only reads one or multiple variables and
2)adefsitethatatleastwritestoonevariable.Forthe5typesofTable 3: The filtering patterns behind PPT1–PPT5.
PPT Filtering Pattern
PPT1/parenleftbigisAuthorized (msд .sender)∨hasPermit (msд .sender)/parenrightbig
/followsmsд .sender .externalCall
PPT2/parenleftbigvaradd==const∨varobj==Contract(const)/parenrightbig/follows/parenleftbigvaradd.externalCall ∨varobj.externalCall/parenrightbig
PPT3The above two patterns in the self-defined modifiers
of functions that have external payments
PPT4/parenleftbigisChecked (vl)/followsw(vl)/followsexternalCall /followsw/prime(vl)/parenrightbig
∧w(vl)!=w/prime(vl)
PPT5isChecked (Vint)/followsw(Vint)
/follows/parenleftbigvarobj.transfer ()/parenrightbig
variables and 14 types of operations in SlitherIR [ 41], we build the
def-use relations for each of the 14 types of IR operations.StaticTaintRules.
AsshowninTable2,weproposetheISfortaint
analysisandthepropagationrulesthatsuittoSolidityprograms.
TheISfortaintincludestheparametersofpublicfunctionsandthe
twospecialfeaturesofSolidity,namely tx.origin andmsg.sender .
The former refers to the original external address that starts the
whole transaction, while the latter just refers to the external ad-
dress that calls the current contract. All the IS may be tainted with
malicious external addresses, and propagated to the VFs via the
propagationrules. Similarwith otherOOPlanguages, thedata as-
signment operation (Rule 1) and the function return assignment
(Rule3)propagatethetainteddata.Uniquely,inSolidity,theaddress
bindingoperations(creatingacontractobjectfromanaddressin
Rule 2) also propagate. Finally, in the XCFG, a VP is identified if
there is a path satisfying any of the two conditions: (1) if a contract
object is tainted, calling any of its public methods (potentially invok-
ingthefallbackfunction)isvulnerable;(2)ifanaddressvariableis
tainted, calling any of its low-level functions is vulnerable.
Specifically, Rule 1 for program/data assignment involves the
following operations in SlitherIR: assignment, binary, unary, new
operator, push, convert, array initialization, memberforthethree
typesofvariables: StateVariable, LocalVariable andSolidityVariable.
Rule 2 involves the operations of member, convert, assignment,
array initialization and index, as the address binding may refer
to one address or an array of addresses. Last, rule 3 involves the
operations of member, call, returnandassignment.
5.3 Path Filtering based on PPTs
Given the VPs reported by the static taint analyzer, we need to
apply the filters that take into account the PPTs. Behind each PPT,
we define a filtering pattern shown in Table 3.
The filtering pattern for PPT1 is to check whether msg.sender
is within a list of authorized contracts or addresses, or has the
permissiontodothis(e.g., msg.sender==owner )andfinallytheabove
checkisrequiredtobewithinthesamefunctionand before(denoted
by/follows) the external call of the tainted address or contract.
The filtering pattern for PPT2 is to check whether the tainted
address or object has been initialized in declaration or modified
before the external call, with a 20-byte length string constant.
ThepatternforPPT3isactuallyapplyingtheabovetwopatterns
inself-definedmodifiersofthefunctionwiththesuspicioustainted
object or address that has the external call.
1035The patternfor PPT4 is tocheck the existenceof the execution
lock, where vldenotes the boolean variable to be used as the lock
andisChecked (vl)denoteswhether vlischeckedvia require(orif,
assertchecks etc.). w(vl)denotes the firsttime of write operation
tovl,andw/prime(vl)denotesthe secondtimeofwriteoperationto vl.
Hence,w(vl)!=w/prime(vl)meansthatthefirstandthesecondwrite
operation assign the different values to vl.
The pattern for PPT5 is to check the existence of checks-effects-
interactions pattern, where Vintdenotes the set of internal vari-
ables for the current contract, w(Vint)refers to the write opera-
tions toVintfor the internal state or balance changes, and last
varobj.transfer()denotestheexternalcallofthebuild-infunction
transfer() . Notably, even if varobjis tainted, the code is still non-
vulnerable,asthebuilt-infunction transfer()usingafixedamount
of gas and will not repeatedly reenter the payment function.
5.4 Light-weight Symbolic Analysis
TomakethePPT-basedfilteringmoreaccurate,alight-weightsym-
bolic analysis isdeveloped and employed across PPT1-4,assisting
the reentrancy detection. Our light-weight symbolic analysis is
bothintra-proceduralpath-sensitiveandcontext-insensitivetosyn-
thesize a symbolic path from tainted source to the fallback call.
Then we feed the path into Z3 solver to check its feasibility.
Given a user defined threshold h, we abstract the loop analy-
sis by unrolling the loop for hiterations. Moreover, we abstract
eachfunctioncallwithanewvariableofitsreturntype.Inother
words, our result ensures the soundness of a reported infeasible
path. Despite such an abstraction still suffers from FPs in some
cases,itlargelyreducesourrun-timedetectionoverhead,whilestill
allowsustoavoidpotentialFPsinaconsiderableway.Fortheexam-
plein Fig.5,we synthesizeapath “! reEntered ∧ActualBalance >
0.01∧reEntered =true”, which is solved to be infeasible, which
helpsusavoidthefalsealarm.Last,ifthesolverreturns“unknown”
resultforthesynthesizedsymbolicpath,wediscardthepathand
use the result of PPT for detection.
Afterthefilteringisfinished,theremainingreachablecallchains
(or feasible paths) in VCwill be outputted as the detection results.
6 EVALUATION
We have conducted extensive experiments to evaluate the effec-
tiveness of Clairvoyance. Specifically, weattempt to answerthe
following research questions (RQs):RQ1.
HoweffectivearethesummarizedPPTs?Comparedwiththe
three available static tools, how is the precision of Clair-
voyance?
RQ2.How useful is the cross-contract static taint analysis? Com-
pared with the three static and two dynamic tools, how is
the recall of Clairvoyance?
RQ3.HowefficientisClairvoyanceinanalyzingreal-worldSo-
lidity programs?
RQ4.CanClairvoyancediscoverreal-worldunknownreentrancy
vulnerabilities, which can lead to DAO attacks?
6.1 Setup
6.1.1 Baselines. Inevaluation,weusetheirlatestversions,namely
Slither v0.6.4, Oyente v0.2.7 and Securify v1.0. To compare
Clairvoyancewiththedynamictoolsintermsofrecall,wealsoTable 4: The detection accuracy at function level for Clair-
voyance and the other three tools on the 17770 contracts∗.
Sli. v0.6.4 Oye. v0.2.7 Sec. v1.0 C.V.
#N 162 28 608 168
#TP 3 4 3124
#FP 159 24 605 44
∗Note: #N refers to the number of detection results, #TP refers to the
number of true positives, and #FP refers to the number of false positives.
include Mythril v0.21.20 and sFuzz v0.0.1 in the tools pool. As no
multi-threading options are available, only the default settings are
used under the same machine environment.
6.1.2 Dataset for Tool Evaluation. In our evaluation, to fairly com-
pare Clairvoyance with the other tools, we choose the dataset of
17770smartcontracts,whichcomefromGoogleBigQueryOpen
Dataset,adifferentsourceotherthanthe11714contractsusedin
ourempiricalstudy.Inparticular,the11714contractsusedinour
empirical study (see §4) are directly crawled from Ethereum block
chain. In this experiment, we obtained smart contracts by track-
ingtheirdeploymentaddressesfromthepublicGoogleBigQuery
dataset[23].Wedownloaded17770contractsthroughtheEtherscan
API with their deployment addresses.
6.1.3 Experimental Setup. ClairvoyanceisimplementedinPython
on top of the SlitherIR library. During the evaluation, all the exper-
imentsandtoolsareconductedonamachinerunningonUbuntu
18.04, with 8 core 2.10GHz Intel Xeon E5-2620V4 processor, 32 GB
RAM, and 4 TB HDD.
6.1.4 Manual Inspection. To validate the false positives (FPs) or
true positives (TPs) from these results, we hire four experienced
Soliditydeveloperstocheckthedetectionresultstogetherwiththeir
corresponding source code via the aid of the two dynamic tools
(i.e., Mythril and sFuzz) in two months’ time. More specially, we
asked developers to conduct cross-reference to manually evaluate
the results. We divide the developers into two groups (each with
two members). In each group, one developer evaluated the results
and the other was responsible for double checking the results.
6.2 RQ1: Evaluating the Precision
Table4liststhenumbersofdetectionresultsofthefourstatictools,
i.e.,608bySecurify,168byClairvoyance,162bySlitherand28
byOyente.After thevalidation, itisfound thatthough Securify
(i.e.,usingRule2)reportsmorebugs,mostofthemareFPs.Oyente
reportsfewestbugs andislimitedincatchingthe truebugsfound
by other tools dueto its coarse-grained checking rule (i.e., Rule 3).
In comparison, Clairvoyance has the most TPs and the fewest
FPs.
To understand the reasons behind the FPs reported by each
evaluated tool, we first classify the FPs into the five categoriesbased on PPTs. The results in Table 5 show that most of the FPs
reported by the static tools are due to ignorance or limited support
of these PPTs, including 130 of 159 FPs in Slither, 22 of 24 FPs in
Oyente, and 478 of 605 FPs in Securify— most of the FPs are due
to our summarized five PPTs. This confirms that Clairvoyancehas the best support of these PPTs, and hence achieves the best
precision.
1036Table 5: #FPs due to the inconsideration or unsatisfactory
support of PPTs for different tools on the 17770 contracts.
Sli. v0.6.4 Oye. v0.2.7 Sec. v1.0 C.V.
PPT1 33 2 60 9
PPT2 56 4 121 10
PPT3 25 15 193 0
PPT4 9 0 1 0
PPT5 7 1 103 14
Sum 130 22 478 33
Perc. in All FPs 81.76% 91.67% 79.27% 75.00%
1contract Betting {
2 function Betting() public payable { // constructor
3owner = msg.sender;
4betContrInterface = BettingContrInterface(owner);
5}
6 function reward() internal {
7...// calculate house_fee
8 if(total_bettors <= 1) { forceVoidRace(); }
9 else{
10 require (house_fee < address (this).balance);
11 total_reward = total_reward.sub(house_fee);
12 betContrInterface.payHouseFee. value(house_fee)();
13}
14}
Figure11:ArealcaseusingPPT2(thehard-codedaddress)in
constructor at deployment time, an FP for Clairvoyance.
Morespecifically,wesummarizethefollowingobservationsfrom
theFP results:(1) Securifyfailsto considerpermissioncontrols,
hard-codedaddressesandself-definedmodifiers.Italsofalselyre-
ports the write operations after calling built-in functions send()
andtransfer() asvulnerable,causingFPssinceitdoesnotconsider
PPT5. (2)Oyente basically ignoresthe protectionsin self-defined
modifiers and has many FPs mostly because it ignores PPT3. (3)
Among all the FPs of Slither, it generally has a good support for
PPT3 by considering the code of security check in modifiers. How-
ever, it still has many FPs due to lack of any symbolic analysis for
PPT1 (33 cases) and PPT2 (56 cases). Considering a relatively small
numberofcasesinusingexecutionlock(PPT4),Slitherignores
the protection by execution lock(s).FP example of Clairvoyance.
As shown in Table 5, the FPs
of Clairvoyance root in the limited support of PPT1, PPT2 andPPT5. After looking into the code of these FPs, the reason for 9FPs of PPT1 mainly lies in the complicated path conditions (e.g.,
user-defined functions in condition control), which cannot be well-
handledbyourlight-weightsymbolicanalysis—actuallythepathisinfeasibleduetostrictconstraintsintheuser-definedfunctions,butClairvoyancereportsitfeasible.Thereasonsof10FPsofPPT2aretwofold:(1)5FPsareduetothehard-codedaddressinaconstructor
(see Fig. 11), (2) 5 FPs are also due to the complicated condition
solving (e.g., involving string operations) for address constants.
Last,the14FPsofPPT5allbelongtothiskindofcornercases—thestatementsrelevanttoPPT5areallinsideanexternallyunreachable
branch, but Clairvoyance falsely reports them reachable.
InFig.11,weshowanFPexample,whereourfilteringpatternfor
PPT2 failsbecause of the hard-codedaddress in aconstructor.Ac-
cordingtoAlgo.1,webuildandsearchallcallchainsstartingfromapublicfunction— however,theconstructorisnotconsideredasanordi-
narypublicfunctionincallchains,asitisonlyexecutedatthecontractdeploymenttimeandcannotbecalledbyotherinternal/externalfunc-
tions after that. For function reward() in Fig. 11, our taint analyzer
Figure12:TheVenndiagramforillustratingtheoverlappingand unique TPs among the evaluated static tools.
Table 6: The detection results for two dynamic tools on the
122 vulnerable contracts detected by Clairvoyance
∗.
Tool #N#TPR%Detection Time (min.)
Mythril 0.21.20 131310.65% 275
sFuzz 0.0.1 11119.01% 115
∗Note: the two dynamic tools cannot finish on 17770 contracts within one
week, and hence are applied on 122 vulnerable contracts.
suggests that the low-level call ***.payHouseFee.value() at line 12
isvulnerable,as betContrInterface isintaintinputsourceandwith-
outanyprotectionfrom PPTs.However ,thiscaseisanFP,asthe
constructor has assigned the contract address with msg.sender dur-
ing the deployment time ( msg.sender is the account address of the
deploying programmer). As betContrInterface is never modified
in other places, its address is the account address of the deploying
programmer.Noexternaladdresscantriggerthereentrancy,and
hence it is an FP due to overlooking of PPT2 in the constructor.
Besides,there are 11 FPsof Clairvoyance due to other PPTs (not
included in §4): (1) strict gas consumption checks for one entranceto prevent reentrancy of the payment function, (2) runtime condi-
tion checks on the basis of using block.number orblock.time , which
sometimes rely on the chain status. In general, these two other PPTs
cannotbehandledbystaticanalysis.Duetopagelimit,moredetails
and examples of other PPTs are available at the website [5].
AnswertoRQ1: Ingeneral,Clairvoyanceexhibitsasignif-
icantlybetterprecisionthantheotherthreestatictoolsowing
tobettersupportoffivePPTs.Theotherthreetoolsneedto
improveintermsofPPT1toPPT3,whileClairvoyanceneedsthedeploymentanalysisandmoreaccuratesymbolicanalysis.
6.3 RQ2: Evaluating the Recall
In Fig. 12, this Venn diagram shows that 122 TPs are found byClairvoyance, 3 TPs by Slither, 3 TPs by Securify and 4 TPs
byOyente.Fortheoverlappingpart,only2TPsarefoundbyall
the four static tools; Slither and Securify report the same 3 TPs;
Oyente has 2 TPs thatare also found by Clairvoyance. Notably,
our tool reports 117 unique TPs missed by the three static tools.
After we inspect the 122 TPs of Clairvoyance, we find the low
recall of the three static tools is attributed to two factors: (1) 55 out
of122(45%)ownthevulnerablecallchainsthatinvolvemultiple
contracts (except the external attack contract), which could be
10371contract RedEnvelope {
2 function create( address token, ...) public payable {
3...// checks and calculattion for other variables
4infos[hash] = Info(token, msg.sender, amount,..., 0);
5emit RedEnvelopeCreated( hash);
6}
7 function sendBack(bytes32 hash) public {
8Info storage info = infos[hash];
9 require (info.owner == msg.sender);
10 ...// more checks
11 uintback = info.amount - info.fill;
12 if(info.isSpecialERC20){
13 SpecialERC20(info.toke n).transfer(msg. sender,back);
14 }else{ERC20(info.token). transfer(msg. sender,back);}
15 emitRedEnvelopeSendBack(hash, msg. sender,back);
16}
17}
Figure 13: A real case of misusing PPT1 at line 9 due to the
issue of supporting struct Info, an FN for Clairvoyance.
similar with the call chain in Fig. 3; and the three static tools fail
to conduct cross-contractanalysis. (2) The other 67TP residing in
singlecontractmostlyhavethecalltoexternallydefinedhigh-level
functions,notthoselow-levelfunctions(e.g., call()) — however,
the three static tools mainly check the call to low-level functions.
In addition to static tools, two dynamic tools are compared in
terms of recall in Table 6. Out of 122 TPs found by Clairvoyance,
Mythril and sFuzz detect 13 and 11, respectively. Hence, the two
dynamictoolsshowabetterrecallthanthethreestatictools,butstillmissmostoftheTPs.Asdynamictoolsaresignificantlyslowerthan
statictools,itwilltaketoomuchtimetorunonthewhole17770
contracts. So we just randomly pick up the other 1000 contracts to
have testing in the wild for the two dynamic tools, and find two
vulnerable contracts (FNs) that are missed by Clairvoyance.
FN example of Clairvoyance. TPs mightbemissed by Clair-
voyanceduetothemisuseofthePPTs.Forexample,theFNshown
in Fig.13 mistakenly applies PPT1 (access control) for line 9 and
removesthiscasefromthesetof VC.Nevertheless,aftermanualau-
diting,wefindthat therequirecheckatline9isnottocheckthekey
member info.token , but to check an irrelevant member info.owner .
Accordingto hash(thesource),ourtaintanalyzerreportsthe whole
structInfoas tainted due to the initialization of the struct at line 4,
and then appliesPPT1 at line 9. Occasionally, due to thegranular-
ityissueofthetaintanalyzer,itcannotaccuratelyanswerwhich
memberofastructobjectistainted.ApartfromtheFNinFig.13,
anothertrickycaseofmisusingPPT1causestheotherFNforClair-
voyance— the external low-level call of a tainted address and a
permission check are meanwhile inside an ifcondition control,
which is mistakenly matched with the PPT1.
Answer to RQ2: In general, Clairvoyance exhibits much
betterrecallthantheotherthreestaticandtwodynamictools,owingtocross-contractcallchainanalysis.ButmisusingPPTs
will falsely filter some TPs and cause FNs for Clairvoyance.
6.4 RQ3: Evaluating the Efficiency
On the 17770 contracts, we observe that — light-weight static anal-
ysistools aremostefficient,tools basedonverificationor symbolic
execution are relatively slower. In Table 7, Slither and Clairvoy-
ance take the least time, 52 minand 181min, respectively.Oyente
is less efficient, taking 1352 min. Surprisingly, Securify is the least
efficient, using 8859 min. Although Oyente supports 4 types of
vulnerability and Securify supports 7 types, the analysis over-
headsdonotincreaseverymuchevenwhensupportingmoretypes.Table 7: The time (min.) of reentrancy vulnerability detec-
tion for each tool on 17770 contracts.
Dataset Sli. v0.6.4 Oye. v2.0 Sec. v1.0 Clairvoyance
17770 52 1352 8859 181
Slither and Clairvoyance both depend on light-weight data/con-
trol flow analysis. Our tool has more overheads due to the support
ofcross-contractstatictaintanalysis.OyenteisbasedonsymbolicexecutionofEVMIRdisassembledfromEVMbytecode.Theperfor-
mance issue of Securify roots in the time-consuming conversion
of IRs into Datalog format and then the verification on the datalog.
To sum up, the efficiency is essentially determined by the inherent
complexity of different techniques.
Answer to RQ3 : In general, Clairvoyance is efficient as a
light-weight cross-contract static taint analysis tool, which
avoidsusingverificationorheavy-weightsymbolicexecution.
6.5 RQ4: Reproduction of DAO Attack
To confirm the vulnerabilities of TPs found by Clairvoyance, we
manuallyinspect101TPs(notdetectedbyanyotherstaticordy-
namictool)andexperimentwiththetriggeringofthem.Accordingto the hints (e.g., the vulnerable call chains) provided by Clairvoy-
ance, we conclude that 82 out of 101 TPs could be easily triggered
with high confidence, owning to two reasons: 1) no clear PPTs are
foundalongthevulnerablecallchains,indicatingtheirfeasibility;
2) the contexts of the call chains are not too complicated to under-
stand,allowingus(orexternalattackers)tounderstandtheflaws
in the business logic. The remaining 19 TPs, for which we are with
lowconfidence,havecomplicatedlogicforunderstandingandown
complex constraints in paths that may be undecidable for staticanalysis. In the tool website [
5], we have added the exploitation
code(succeedon ourprivatechain )for20outofthe82TPs,andwe
will gradually add more. Here, we detail two interesting TPs:
Case1at 0x7bc51b19abe2cfb15d58f845dad027feab01bfa0 .Asimple
caseisthecontract DividendDistributor with6transactiontimes
and a total transaction amount of 1.6 Ethers. The vulnerable call
chaininvolves5functionsfrom 2contractsandhasaninternalvul-nerablefunction
loggedTransfer() ,whichproceedsthetransaction
with unchecked the transfer target and the amount. The low-level-
call of the transfer function is tainted. We can easily trigger this
reentrancy and steal money from it.Case 2 at
0x526af336D614adE5cc252A407062B8861aF998F5 .A com-
plicated case is the contract SaiProxy with 9,987 transaction times
and a total transaction amount of 107,172 Ethers. The shortest vul-
nerablecallchaininvolves4externalcontractsanditslengthis8
functions.Thefunctioncall tub.gem().deposit.value(msg.value)()
isthelow-level-calloftaintedobject tub.Wecanrecursivelycall
this function for causing gas exhaustion.
Answer to RQ4: Based on the vulnerable call chains re-
ported by Clairvoyance, triggering the TPs of reentrancy is
facilitatedandprovestheeffectivenessof Clairvoyancein
practice.
10386.6 Discussion
6.6.1 Generality of PPTs. PPTs can be applied for other bug types,
likeself-destruct abusing [8]. For example, ignoring PPT3 (self-
defined modifiers) when detecting self-destruct abusing causes
FPs, since strict permission control could be done via PPT3 and
make the function selfdestruct ()not accessible by the non-owner.
Besides, PPT3 is also found to prevent the bug of unexpected revert
[15],andtoolsignoringPPT3willinevitablyyieldFPs.Moredetails
on using PPTs for detecting other types of bugs are available in [ 5].
6.6.2 Threats to Validity. Threats to internal validity come from
the threshold hused in the light-weight symbolic analysis. Cur-
rently,his set to2 for unrollingevery loop (e.g., while) upto twice.
Wefindthatincreasingthevalue(e.g.,upto5)doesnothavesig-
nificantimpactonourresults.Thereasonisthatnotmanyloops
aresolved alongthe pathsfor thePPTs. Threatsto externalvalidity
mainly come from the representativeness of the two datasets of
smart contracts. However, there is no dataset available in previous
papers [35,49,50]. During the past two years, we have tried our
best to collected and downloaded 11714 real-world contracts from
Etherscan to assess the existing tools and summarize the PPTs.
Toavoidthebiasofusingonedataset,weusethe17770contracts
in Google BigQuery Open Dataset for tools evaluation. We will
release and contribute our datasets to the community.
6.6.3 Future Enhancement. Our Clairvoyance is not designed for
the compositional analysis, i.e., how can we avoid redundant inter-
proceduralanalysiswhenafewnewcontractsareaddedintoour
analysisscope.Themajorruntimeoverheadfornon-compositionalanalysisofourapproachliesinthatClairvoyanceneedstosearch
through all the contract scope for its caller contracts. The larger
the scope, the more overhead it will incur. In the future, we plan to
investigate incremental and compositional analysis for reentrancy
detectionbycachingandindexingthecallrelationamongcontracts.
Note that, the overhead for re-analyzing for callee contract is ac-
ceptable as a contract consists of only up to a few hundred lines of
code,whichrequiresonlyabout0.5secondforthecalleeanalysis
of individual contract.
7 RELATED WORK
7.1 Reentrancy Detection in Smart Contracts
Recently, many security scanners have been proposed for vulnera-
bility detection in smart contracts. Among them, Manticore [ 48],
Mythril [ 13], sFuzz [ 21], MythX [ 14], Echidna [ 47], Contract-
Fuzzer[24] and Ethracer [ 26] belong to dynamic testing/fuzzing
tools. Other scanners, including Slither [ 49], Oyente [ 35,36],
SmartCheck[ 11,46],Securify[ 10,50],Octopus[ 4],Zeus[25],
Maian[39]andsCompile[ 12],arebasedonstaticanalysis.Notably,
Maian and sCompile support inter-contract function call analysis
and apply verification technique, but do not support reentrancy
detection.
However,instatictools,onlySlither,Oyente,Securifyand
Zeus support the detection of reentrancy vulnerability. Among
them,Slither[ 49]servesasananalysisframeworkandrunsthe
built-in reentrancy detector on the basis of intra-contract control/-
dataflowanalysis.Oyente[ 35]worksontheEVMIRandleveragesZ3-solver[ 17]forconstraintsolvinginsymbolicexecution.Secu-
rify[50]convertsEVMbytecodeintodatalogrepresentationand
then applies verification on the datalog. Zeus [ 25] adopts XACML
as a language to write the safety and fairness properties, converts
them into LLVM IR [ 3] and applies a verification engine (e.g., Sea-
Horn [22]). Notably, Zeus is not included in tool comparison, as it
isnotopen-sourced.Recently,VerX[ 40],anautomatedverifier,has
beenproposedtoprovefunctionalpropertiesofEthereumsmart
contracts. VerX could detect a wide range of vulnerabilities viatechniques of reducing temporal property verification for reach-ability checking, a new symbolic execution engine, and delayedpredicate abstraction. Compared with all above tools, Clairvoy-
ancemakesthefirstattemptatadoptingPPTsforpathfeasibility
analysis.
7.2 Interprocedural Analysis
Callgraphconstructionisthefundamentalrequirementforinter-
procedural static analysis, which is used in many program analysisapplicationssuchassoftwaredebuggingandtesting[
30–32,37,51],
code recommendation [ 29,33], and template-based code reuse [ 28,
29]. There exist many call graph construction algorithms for re-
solvingvirtualdispatches andindirectcallsfor traditionalJavaand
C/C++ programs by using class hierarchy analysis [ 18], rapid type
analysis[9],variabletypeanalysis[ 45],andpointeranalysis[ 19,27].
UnlikeconventionalJavaorC/C++programs,Solidityhasnewand
complicated language features, such as low-level calls, explicit ma-
nipulations of contract addresses via keywords (e.g., msg.sender
andaddress(this) ), fallback mechanisms and inter-contract call-
backs(similartoresolvingcallbacksinevent-drivenprogramssuch
as Android apps [ 52,53]). Interprocedural static taint analysis has
alsobeenstudiedasaninstanceofdata-flowanalysis.Theanaly-
sisnormallyconductsreachabilityanalysisontopofaprogram’s
data-flowgraphwhichiseitherpre-computedusingfastandimpre-
ciseanalysis[ 34,44]orbeingbuilton-the-flyinademand-driven
manner [ 7,43]. Different from previous approaches on Java and
C/C++,thisworkconductsinter-contractstatictaintanalysison
topofsmartcontractprogramsbyconsideringSolidity’s14types
of IR operations to support precise taint propagation in detect-ing reentrancy vulnerability, one of the most important types of
vulnerabilities in smart contracts.
8 CONCLUSION
Inthispaper,wepresentareentrancydetectionapproachbasedon
(1) applying the light-weight cross-contract static taint analysis to
findreentrancycandidatesand(2)integratingthePPTstorefinethe
results.Onthepubliclycollected17770contracts,Clairvoyance
significantlyoutperformsthethreestatictoolsintermsofprecisionandrecall,andtwodynamictoolsintermsofrecall.Inthefuture,we
will extend ourapproach by combining withdynamic approaches
for detecting more vulnerability types.
ACKNOWLEDGMENTS
ThisworkissupportedbytheNationalNaturalScienceFoundation
of China (Grant No. 61972373) and partially supported by the Aus-
tralianResearchCouncilunderGrantDP200101328.Theresearch
of Dr. Xue is supported by CAS Pioneer Hundred Talents Program.
1039REFERENCES
[1]2015. Ethereum:BlockchainAppPlatform. https://www.ethereum.org/.(2015).
Online; accessed 29 January 2019.
[2]2019.ABlockExplorerandAnalyticsPlatformforEthereum.https://etherscan.io/.
(2019). Online; accessed 29 January 2019.
[3]2019. LLVMLanguageReferenceManual. https://blog.sigmaprime.io/solidity-
security.html. (2019). Online; accessed 29 January 2019.
[4]2019. Octopus. https://github.com/quoscient/octopus.(2019). Online;accessed
29 January 2019.
[5]2020. Clairvoyance:. https://toolman-demo.readthedocs.io/en/latest/index.html.
(2020). Online; accessed 1 May 2020.
[6]Adrian Manning. 30 May 2018. Solidity Security: Comprehensive List of Known
Attack Vectors and Common Anti-patterns. https://blog.sigmaprime.io/solidity-
security.html. (30 May 2018). Online; accessed 29 January 2019.
[7]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysis for android apps. In Acm Sigplan Notices, Vol. 49. ACM, 259–269.
[8]Nicola Atzei,MassimoBartoletti, andTiziana Cimoli.2016. A surveyof attacks
on Ethereum smart contracts. IACR Cryptology ePrint Archive 2016 (2016), 1007.
[9]David F Bacon and Peter F Sweeney. 1996. Fast static analysis of C++ virtual
function calls. ACM Sigplan Notices 31, 10 (1996), 324–341.
[10]ChainSecurity.2019. Securify. https://securify.chainsecurity.com/.(2019). Online;
accessed 29 January 2019.
[11]ChainSecurity. 2019. Smart Check. https://tool.smartdec.net/. (2019). Online;
accessed 29 January 2019.
[12]JialiangChang,BoGao,HaoXiao,JunSun,andZijiangYang.2018.sCompile:Crit-
icalPathIdentificationandAnalysisforSmartContracts. CoRRabs/1808.00624
(2018). arXiv:1808.00624 http://arxiv.org/abs/1808.00624
[13]ConsenSys. 2019. Mythril. https://github.com/ConsenSys/mythril-classic. (2019).
Online; accessed 29 January 2019.
[14]ConsenSys. 2019. MythX. https://mythx.io/. (2019). Online; accessed 29 January
2019.
[15]ConsenSys Diligence. 2019. Ethereum Smart Contract Best Practices:Known
Attacks. https://consensys.github.io/smart-contract-best-practices/known_
attacks/. (2019). Online; accessed 29 January 2019.
[16]DavidSiegel.[n.d.]. UnderstandingtheDAOAttack. Website.([n.d.]). https:
//www.coindesk.com/understanding-dao-hack-journalists.
[17]Leonardo Mendonça de Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT
Solver. In TACAS 2008. 337–340.
[18]JeffreyDean,DavidGrove,andCraigChambers.1995. Optimizationofobject-
oriented programsusing static classhierarchy analysis.In European Conference
on Object-Oriented Programming. Springer, 77–101.
[19]Xiaokang Fan, Yulei Sui, Xiangke Liao, and Jingling Xue. 2017. Boosting the
precisionofvirtualcallintegrityprotectionwithpartialpointeranalysisforC++.
InProceedings of the 26th ACM SIGSOFT International Symposium on Software
Testing and Analysis. ACM, 329–340.
[20]JosselinFeist,GustavoGreico,andAlexGroce.2019. Slither:AStaticAnalysis
Framework For Smart Contracts. In 2nd IEEE/ACM International Workshop on
Emerging Trends in Software Engineering for Blockchain, WETSEB@ICSE 2019,
MontrÃľal, Canada. to appear.
[21]GuardStrike. 2019. sFuzz: An AFL based fuzzer for smart contracts. https:
//fuzzing.gitbook.io/sfuzz/. (2019). Online; accessed 27 May 2019.
[22]Arie Gurfinkel, Temesghen Kahsai, Anvesh Komuravelli, and Jorge A. Navas.
2015. The SeaHorn Verification Framework. In CAV 2015. 343–361.
[23]Google Inc. 2019. Google Big Query Open Dataset. https://cloud.google.com/
bigquery/public-data. (2019). Online; accessed 29 January 2019.
[24]Bo Jiang, Ye Liu, and W. K. Chan. 2018. ContractFuzzer: fuzzing smart contracts
for vulnerability detection. In ASE. ACM, 259–269.
[25]Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. 2018. ZEUS:
Analyzing Safety of Smart Contracts. In NDSS 2018.
[26]AashishKolluri,IvicaNikolic, IlyaSergey, AquinasHobor, andPrateekSaxena.
2019. Exploitingthe laws oforder insmart contracts. In Proceedings ofthe 28th
ACM SIGSOFT International Symposium on Software Testing and Analysis, ISSTA
2019,Beijing,China,July15-19,2019. 363–373. https://doi.org/10.1145/3293882.
3330560
[27]OndřejLhotákandLaurieHendren.2003. ScalingJavapoints-toanalysisusingS
park. InInternational Conference on Compiler Construction. Springer, 153–169.
[28]Yun Lin, Guozhu Meng, Yinxing Xue, Zhenchang Xing, Jun Sun, Xin Peng, Yang
Liu,WenyunZhao,andJinsongDong.2017. Miningimplicitdesigntemplates
for actionable code reuse. In 2017 32nd IEEE/ACM International Conference on
Automated Software Engineering (ASE). IEEE, 394–404.
[29]Yun Lin, Xin Peng, Zhenchang Xing, Diwen Zheng, and Wenyun Zhao. 2015.
Clone-based and interactive recommendation for modifying pasted code. InProceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering.
520–531.
[30]Yun Lin, Jun Sun, Gordon Fraser, Ziheng Xiu, Ting Liu, and Jin Song Dong. 2020.
RecoveringfitnessgradientsforinterproceduralBooleanflagsinsearch-based
testing. In Proceedings of the 29th ACM SIGSOFT International Symposium on
Software Testing and Analysis. 440–451.
[31]YunLin,JunSun,LylyTran,GuangdongBai,HaijunWang,andJinsongDong.
2018. Breakthedeadendofdynamicslicing:localizingdataandcontrolomission
bug. InProceedings of the 33rd ACM/IEEE International Conference on Automated
Software Engineering. 509–519.
[32]Yun Lin, Jun Sun, Yinxing Xue, Yang Liu, and Jinsong Dong. 2017. Feedback-based debugging. In 2017 IEEE/ACM 39th International Conference on Software
Engineering (ICSE). IEEE, 393–403.
[33]Yun Lin, Zhenchang Xing, Xin Peng, Yang Liu, Jun Sun, Wenyun Zhao, and
JinsongDong.2014. Clonepedia:Summarizingcodeclonesbycommonsyntac-
ticcontextforsoftwaremaintenance.In 2014IEEEInternationalConferenceon
Software Maintenance and Evolution. IEEE, 341–350.
[34]VBenjamin Livshitsand MonicaSLam. 2003. Trackingpointerswith pathand
context sensitivity for bug detection in C programs. ACM SIGSOFT Software
Engineering Notes 28, 5 (2003), 317–326.
[35]LoiLuu,Duc-HiepChu,HrishiOlickel,PrateekSaxena,andAquinasHobor.2016.
Making Smart Contracts Smarter. In CCS 2016. 254–269.
[36]melonproject. 2019. Oyente. https://github.com/melonproject/oyente. (2019).
Online; accessed 29 January 2019.
[37]Tai D Nguyen, Long H Pham, Jun Sun, Yun Lin, and Quang Tran Minh. 2020.
sFuzz: An Efficient Adaptive Fuzzer for Solidity Smart Contracts. In Proceedings
of the 42nd International Conference on Software Engineering.
[38]Nick Szabo. 1996. Smart Contracts: Building Blocks for Digital Markets.http://www.fon.hum.uva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/smart_contracts_2.html.
(1996). Online; accessed 29 January 2019.
[39]IvicaNikolic, AashishKolluri, IlyaSergey, PrateekSaxena,and AquinasHobor.
2018.FindingTheGreedy,Prodigal,andSuicidalContractsatScale.In Proceedings
ofthe 34thAnnualComputerSecurity ApplicationsConference, ACSAC 2018,San
Juan,PR,USA,December03-07,2018.653–663. https://doi.org/10.1145/3274694.
3274743
[40]Anton Permenev, Dimitar Dimitrov, Petar Tsankov, Dana Drachsler-Cohen, and
Martin Vechev. 2020. VerX: Safety Verification of Smart Contracts. In IEEE S&P
2020.
[41]SlithIRDev.Team.2019. SlithIRTypes. https://github.com/crytic/slither/wiki/
SlithIR. (2019). Online; accessed 30 June 2019.
[42]Solidity Dev. Team. 2019. Solidity — Security Considerations. https://solidity.
readthedocs.io/en/v0.5.0/security-considerations.html. (2019). Online; accessed
30 June 2019.
[43]YuleiSuiandJinglingXue.2016. On-demandstrongupdateanalysisviavalue-
flow refinement. In Proceedings of the 2016 24th ACM SIGSOFT international
symposium on foundations of software engineering. ACM, 460–473.
[44]YuleiSui,DingYe,andJinglingXue.2012. Staticmemoryleakdetectionusing
full-sparsevalue-flowanalysis.In Proceedingsofthe2012InternationalSymposium
on Software Testing and Analysis. ACM, 254–264.
[45]Vijay Sundaresan, Laurie Hendren, Chrislain Razafimahefa, Raja Vallée-Rai,
Patrick Lam, Etienne Gagnon, and Charles Godin. 2000. Practical virtual method
call resolution for Java. Vol. 35. ACM.
[46]Sergei Tikhomirov, Ekaterina Voskresenskaya, Ivan Ivanitskiy, Ramil Takhaviev,
EvgenyMarchenko,andYaroslavAlexandrov.2018. SmartCheck:StaticAnalysis
of Ethereum Smart Contracts. In WETSEB@ICSE 2018. 9–16.
[47]trailofbits. 2019. Echidna. https://github.com/trailofbits/echidna. (2019). Online;
accessed 29 January 2019.
[48]trailofbits. 2019. Manticore. https://github.com/trailofbits/manticore. (2019).
Online; accessed 29 January 2019.
[49] trailofbits. 2019. Slither. github. (2019). https://github.com/trailofbits/slither.[50]
Petar Tsankov, Andrei Marian Dan, Dana Drachsler-Cohen, Arthur Gervais,
Florian Bünzli, and Martin T. Vechev. 2018. Securify: Practical Security Analysis
of Smart Contracts. In CCS 2018. 67–82.
[51]Haijun Wang, Yun Lin, Zijiang Yang, Jun Sun, Yang Liu, Jin Song Dong, Qinghua
Zheng, and Ting Liu. 2019. Explaining regressions via alignment slicing and
mending. IEEE Transactions on Software Engineering (2019).
[52]ShengqianYang,DacongYan,HaoweiWu,YanWang,andAtanasRountev.2015.
Static control-flow analysis of user-driven callbacks in Android applications. In
2015IEEE/ACM37thIEEEInternationalConferenceonSoftwareEngineering,Vol.1.
IEEE, 89–99.
[53]Yifei Zhang, Yulei Sui, and Jingling Xue. 2018. Launch-mode-aware context-
sensitiveactivitytransitionanalysis.In 2018IEEE/ACM40thInternationalConfer-
ence on Software Engineering (ICSE). IEEE, 598–608.
1040