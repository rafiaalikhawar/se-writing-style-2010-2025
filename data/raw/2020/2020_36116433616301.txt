PEM: Representing BinaryProgram Semantics forSimilarity
Analysis via a Probabilistic Execution Model
XiangzheXu∗
ZhouXuan∗
xu1415@purdue.edu
xuan1@purdue.edu
PurdueUniversity
WestLafayette,USAShiwei Feng
PurdueUniversity
WestLafayette,USA
feng292@purdue.eduSiyuanCheng
PurdueUniversity
WestLafayette, USA
cheng535@purdue.edu
Yapeng Ye
PurdueUniversity
WestLafayette,USA
ye203@purdue.eduQingkaiShi
PurdueUniversity
WestLafayette,USA
shi553@purdue.eduGuanhong Tao
PurdueUniversity
WestLafayette, USA
taog@purdue.edu
Le Yu
PurdueUniversity
WestLafayette,USA
yu759@purdue.eduZhuoZhang
PurdueUniversity
WestLafayette,USA
zhan3299@purdue.eduXiangyu Zhang
PurdueUniversity
WestLafayette, USA
xyzhang@cs.purdue.edu
ABSTRACT
Binary similarity analysis determines if two binary executables are
from the same source program. Existing techniques leverage static
and dynamic program features and may utilize advanced Deep
Learningtechniques.Althoughthey havedemonstratedgreat po-
tential,thecommunitybelievesthatamoreeﬀectiverepresentation
ofprogramsemanticscanfurtherimprovesimilarityanalysis.In
this paper, we propose a new method to represent binary program
semantics.Itisbasedonanovelprobabilisticexecutionenginethat
can eﬀectively sample the input space and the program path space
of subject binaries. More importantly, itensures that the collected
samples are comparable across binaries, addressing the substantial
variationsofinputspeciﬁcations.Ourevaluationon9real-world
projectswith35kfunctions,andcomparisonwith6state-of-the-art
techniques show that PEMcan achieve a precision of 96% with
common settings,outperformingthe baselines by10-20%.
CCSCONCEPTS
•Security andprivacy →Software reverseengineering .
KEYWORDS
Binary Similarity Analysis,Program Analysis
ACM Reference Format:
Xiangzhe Xu, Zhou Xuan, Shiwei Feng, Siyuan Cheng, Yapeng Ye, Qingkai
Shi,GuanhongTao,LeYu,ZhuoZhang,andXiangyuZhang.2023. PEM:
∗Bothauthorscontributed equallyto this research.
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby theowner/author(s).
ACM ISBN 979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.3616301Representing Binary Program Semantics for Similarity Analysis via a Prob-
abilistic Execution Model. In Proceedings of the 31st ACM Joint European
Software Engineering Conference and Symposium on the Foundations of Soft-
wareEngineering(ESEC/FSE’23),December3–9,2023,SanFrancisco,CA,USA.
ACM,NewYork,NY,USA, 12pages.https://doi.org/10.1145/3611643.3616301
1 INTRODUCTION
Binarysimilarityanalysisdeterminesiftwogivenbinaryexecuta-
blesoriginatefromthesamesourceprogram.Ithasawiderangeof
applications suchas automatic software patching [ 3,29,34,39,40,
49],softwareplagiarismdetection[ 6,27,38,42,52],andmalware
detection [ 4,7,14,15,18,21,51]. For example, assume a critical
security vulnerability has been reported and ﬁxed in a library. It
isofprominent importanceto applythe patchtoother deployed
projectsthatincludedthelibrary.However,thelibrarymaybecom-
piled with diﬀerent settings in diﬀerent projects. Binary similarity
analysisallowsidentifyingallthevariants.Givenapoolofcandi-
date binaries, which are usually functions in executable forms, a
similarityanalysistoolreportsallthebinariesinthepoolequiva-
lenttoaqueriedbinary .Theproblemischallengingasaggressive
code transformations such as loop unrolling and function inlining
in compiler optimizations may substantially change a program and
produce largely diﬀerent executables [ 36].
Given its importance, there is a large body of existing work.
Earlierwork(e.g.,[ 5,19])focusesonextractingstaticcodefeatures
such as control-ﬂow graphs and function call graphs. They are
highly eﬀective in detecting binaries that have small variations.
Many proposedto usedynamic informationinstead [ 9,12,16,43]
because it better discloses program semantics. For example, in-
memory-fuzzing (IMF)[43]usesfuzzingtogeneratemanyinputs
andcollects runtimeinformationwhenexecutingtheprogramon
these inputs. It then uses the collected information to compute
binary similarities. When the fuzzer can achieve good coverage,
IMF is able to deliver high-quality results. However, achieving
goodcoverageisdiﬃcultforcomplexprograms(seeourexample
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
401
ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA X.Xu,Z.Xuan,S.Feng,S.Cheng,Y. Ye, Q. Shi,G.Tao, L.Yu, Z.Zhang,andX.Zhang
in Section 2.1). Recently, Machine Learning and Deep Learning
techniquesareusedtoaddressthebinarysimilarityproblem[ 23,
28,30,31,44,50,52]. These techniques work by training models
on a large pool of binaries that have positive and negative samples.
Theformerincludesbinariescompiledfromthesamesourceand
the latter includes those that are functionally diﬀerent. The models
are hence supposed to learn (implicit) features that can be used
to cluster functionally equivalent programs. However, as shown
in Sections 2.2and4.2, these models may learn features that are
notrobust,andinmanycases,notsemanticsoriented,leadingto
sub-optimalresults.
Inspiredbytheexistingworksthatleveragedynamicinforma-
tion[12,16,43,54],weconsiderthesemanticsofabinarytobeadis-
tributionofitsinputsandtheircorresponding externallyobservable
valuesduring executions. Observable values are those encountered
in I/O operations, and global/heap memory accesses. Compared to
otherruntimevaluessuchasthoseinregisters,observablevalues
are persistent across automatic code transformations as compilers
hardly optimize these behavior [ 16,43]. However, since we need
to compare arbitrary binaries, ideally, we would have to collect
suﬃcientsamplesintheinputspaceofallthesebinaries.Making
such samples universally comparable is highly challenging. In Sec-
tion2.2,weshowthatanaivesamplingstrategythatexecutesall
subject binaries on the same set of seed inputs can hardly work as
diﬀerentbinariestakeinputsofdiﬀerentformats.Forexample,a
validinputfor aprogram /u1D434isverylikelyaninvalidinputforpro-
grams/u1D435and/u1D436. As such, it can only trigger similar error handling
logicsin/u1D435and/u1D436,makingthemnot distinguishable.
In this paper, we propose a sampling technique that can eﬀec-
tivelyapproximatesemanticsdistributionsbyselectingandinter-
pretingasmallsetofequivalentpathsacrossdiﬀerentversionsof
a program. It is powered by a novel probabilistic execution engine.
It runs candidate binaries on a ﬁxed set of random seed values.
Although many of these seed values lead to input errors, it system-
atically unfoldstheprogrambehavior starting fromthe execution
pathsoftheseseedvalues,calledthe seedpaths .Speciﬁcally,itﬂips
a bounded number of predicates along the seed paths. For instance,
ﬂippingafailinginputcheckforcesthebinarytoexecuteitsnormal
functionality.Whilepredicateﬂippingisnotnew[ 32,51,53],our
techniquefeatures a probabilistic sampling algorithm . Speciﬁcally,
wecannotaﬀordexhaustivelyexploringtheentireneighborhood
(of the seed paths) even with a small bound (of ﬂipped predicates).
Hence, we leverage a key observation that the predicates with the
largest and the smallest dynamic selectivity tend to be stable be-
fore and after automatic transformations, while other predicates
vary a lot (by the transformations). Dynamic selectivity is a metric
computed for a predicate instance that measures the distance to
the decision boundary. For example, assume a predicate x>yyields
true,x-ydenotesitsdynamicselectivity.Ourtheoreticalanalysis
inSection 3.5disclosesthatsinceautomatictransformationscannot
inventnewpredicates,butratherremove,duplicate,andreposition
them, the likelihood that code transformations change the ranking
ofpredicateswiththesmallest/largestselectivityismuchsmaller
than that for other predicates. Hence, we sample paths by ﬂipping
predicatesthathaveclosetothelargestandthesmallestselectivity,
followingthe Beta-distribution [17]thathasaUshape,biasingto-
wardsthetwoends.Therefore,iftwobinariesareequivalent,ouralgorithmcansampleasetofcorrespondingpathsinthebinaries
byﬂippingtheircorrespondingpredicatessuchthattheobservable
valuesalongthesepathsdisclosethe equivalence.
Our contributionsare summarizedas follows.
•Weproposeanovelprobabilisticexecutionmodelthatcan
eﬀectivelysamplethesemanticsdistributionofabinaryand
make the distributionsfrom allbinariescomparable.
•We develop a path sampling algorithm that is resilient to
code transformation and capable of sampling equivalent
pathswhentwobinariesareequivalent.Wealsoconducta
theoreticalanalysisto discloseits essence.
•We propose a probabilistic memory model that can tolerate
invalidmemory accesses due topredicate ﬂipping whilere-
specting the critical property of having equivalent behavior
when the binary programs are equivalent.
•Wedevelopaprototype PEM.Weconductexperimentson
twocommonlyuseddatasetsincluding35kfunctionsfrom30
binaryprojectsandcompare PEMwithﬁvebaselines[ 12,28,
30,31,43].Theresultsshowthat PEMcanachievemorethan
90% precision on average whereas the baselines can achieve
76%.PEMis also much more robust when the true positives
(i.e., binaries equivalent to the queried binary) are mixed
withvariousnumbersoftruenegatives(i.e.,binariesdiﬀerent
fromthequeriedbinary)inthecandidatepool,whichclosely
mimicsreal-worldapplicationscenarios.Consequently, PEM
cancorrectlyﬁnd7outof81-dayCVEsfrombinariesinthe
wild, whereas the baselines can only ﬁnd 2. We upload PEM
at [46].
2 MOTIVATION AND OVERVIEW
2.1 Motivating Example
Ourmotivatingexampleisadaptedfromthemainfunctionof catin
Coreutils . The simpliﬁed source code is shown in Fig. 1a. Lines2
to10parsethecommandlineoptions.Lines 12to19iterativelyread
the ﬁle names from the command line and emit the ﬁle contents to
theoutputbuﬀer.Thefunctiondelegatesthemainoperationstotwo
functions. When some conditions at line 13are satisﬁed, a simpler
methodsimple_cat() iscalled.Otherwise,itcallsamorecomplex
functionthatformatstheoutputaccordingtothefullpanoplyof
command line options. For example, at line 22, if the global ﬂag
print_invisible isset,thefunctionprintsouttheASCIIvalues
ofinvisible characters.
Compiler optimizations may substantially transform a program.
In Fig.2bandFig.2a,weshow thecontrol ﬂowgraphs (CFGs) for
our motivatingexamplegeneratedbytworespective compilation
settings, -O0 meaning no optimization and -O3 meaning having all
commonly used optimizations applied. The switchstatement at
line3iscompiledtohierarchical if-then-else structureswith-O0,
asshownintheorangecircleinFig. 2b.Incontrast,itiscompiledto
anindirect jump with -O3, as shown in the orange circle in Fig. 2a.
Thepredicateatline 13correspondstothebluecircleinFig. 2b.We
can see two branches, each consisting of only one basic block. Two
delegated functions are called in the two basic blocks, respectively.
However, the two functions are inlined in the optimized version,
resulting in branches with much more blocks, e.g., 50 blocks in the
branchofthecomplexfunction,asshowninthebluecircleinFig. 2a.
402PEM: Representing Binary Program Semantics forSimilarity Analysis viaaProbabilistic ExecutionModel ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
1voidmain_cat ( intargc ,char∗∗argv ) {
2 while(−1!=(c=get_cli_opt ( argc , argv , " bestuv " ) ) ) {
3 switch(c) {
4 case'b': flag0 = true ; . . . ; format = true ; break;
5 case'e': flag1 = true ; break;
6 case'v': print ( " Coreutils v8.30 " ) ;break;
7 . . .
8 default : quote ( " error " ) ; abort () ;
9 }
10 }
11 . . . // define : pageSize, inbuf andinsize
12 do{
13 if(( flag0 | | flag1 ) && format ) {
14 ret = simple_cat ( inbuf , insize ) ;
15 } else{ . . .
16 outbuf = xmalloc ( outbuf , pageSize )
17 ret = complex_cat ( inbuf , insize , outbuf ) ;
18 }
19 } while( . . . ) ;
20 }
21intcomplex_cat ( char∗inbuf , intinsize , char∗outbuf ) {
22 if( print_invisible && inbuf [ i ]<0x20)
23 outbuf [ . . . ] = to_ascii ( inbuf [ i ])
24 }
(a)Coreutils:cat
1voidmain_touch ( intargc ,char∗∗argv ) {
2 while(−1!=(c=get_cli_opt ( argc , argv , "bcdfhv " ) ) ) {
3 switch(c) {
4 case'b': flag |= 0x100 ; break;
5 case'c': flag = 0x1 ; break;
6 case'v': print ( " Coreutils v8.30 " ) ;break;
7 . . .
8 default : quote ( " error " ) ; abort () ;
9 }
10 }
11 for(inti = begin ; i < argc ; i ++)
12 touch_function ( argv[ i ]) ;
13
14 }
(b) Coreutils:touch
Figure 1:MotivatingExample
Tobetterillustratethechallenges,weintroduceanotherfunction
adapted from the main function of touchinCoreutils , as shown
in Fig.1b. The function touchmodiﬁes the meta information of
ﬁles.Lines 2to10parsethecommandlineoptionsandthefor-loop
atline11iterativelyperformsthetouchoperation.Wecanseefrom
Fig.2cthat the syntactic structures of touchandcatare more
similar than those between catwith and without optimizations.
TheobservationcanbequantiﬁedbythestatisticsoftheseCFGs
showninthe caption.
2.2 LimitationsofExistingTechniques
Fuzzing-BasedTechniques. Therearetechniquesthatleverage
fuzzingtoexplorethedynamicbehaviorofprogramsandusethem
insimilarityanalysis.Forexample, in-memoryfuzzing (IMF)[43]
iteratively mutates function inputs and collects traces. Since the
parameterspeciﬁcationsfor functionsinstrippedbinariesarenot
available,itischallengingtogenerateinputsthatcanachievegood
coverage. In our example, IMF can hardly generate legal command
line optionsfor the function main_cat . Thusmost collected behav-
ior is from the error processing code at line 8. Moreover, they tend
to collect similar (error processing) behavior from main_touch . As
such,thedownstreamsimilarityanalysislikelydrawsthewrong
conclusion about their equivalence. Our experiments in Section 4.2
show that IMF can achieve a precision of 76% on complex cases,
whereas ours can achieve 96%.Forced-Execution-Based Techniques. To extract more behavior
from binary code, there are methods that use coverage as guidance
to execute every instruction in a brute-force fashion. A representa-
tiveworkBLEX[ 12]executesafunctionfromtheentrypoint.Then
it iteratively selects the ﬁrst unexecuted instruction to start the
next round of execution until every instruction is covered. We call
techniquesofsuchnatureforced-execution-basedastheylargely
ignorepathfeasibility. Therearetwoessentialchallengesforthese
techniques. First, they tend to use code coverage within a function
astheguidanceforforcedexecution,whichhastheinherentdiﬃ-
cultyindealingwithfunctioninlining[ 36].Anotherchallengeis
to provide appropriate execution contexts when execution starts at
arbitrary (unexecuted) locations. For example, suppose that in the
ﬁrst few rounds, BLEX executes the true branch at line 14of Fig.1.
When it tries to cover the false branch at line 17, it uses a fresh
execution context, discarding the variables computed at line 11.
According to our experiments in Section 4.2, these techniques can
achieve a precision of 69%, whereas our technique can achieve 96%.
Learning-BasedTechniques. Emergingtechniques[ 30,31,45,52]
leverageMachineLearningmodels.Somemodels[ 45,52]extract
static features from CFGs. However, these static features are not
robust in the presence of optimizations. Another line of work uses
language models [ 30,31]. Their hypothesis is that these models
could learn instruction semantics and hence function semantics.
To limit the vocabulary (i.e., the set of words/tokens supported),
binaries are often normalized before they can be fed to models.
For example,immediatevalues(i.e.,constantsininstructions) and
constant call targets are replaced with a special token HIMMin
SAFE[30],e.g.,thetoken x_call_HIMM aroundline8inFig. 3(b)
and(c)thatcorrespondstothefunctioninvocation get_cli_opt .
Whilethismakestraining convergence feasible,a lot of semantics
are lost.
These models may not learn to classify based on instructions
essential to function semantics. For example, SAFE leverages an
NLP technique called attention [41]. Conceptually, the attention
mechanism determines which instructions are important to the
output. We highlight the statements and their tokens with the
largest attention values in Fig. 3. In these three functions, the
ﬁrst few tokens (in gray) with large attention values are in the
function prologues. The corresponding instructions (e.g., push)
perform the samefunctionality, savingregistervalues tomemory
andallocatingspaceforlocalvariables.InFig. 3a,themodelalso
pays attention to tokens/instructions related to the switch-case
statement.Asdiscussedbefore,however,staticstructuresarenot
reliable due to optimizations. In contrast, in Fig. 3b, the model
instead emphasizes the normalized function invocation at line 8,
which is not distinguishable from the invocation at line 8 in (c)
with a large attention value as well. From the parts that the model
paysattentionto,itiseasytoexplainwhySAFEconcludes cat@O0
is more similar to touch@O0 , instead of cat@O3. We visualize the
weights of full attention layers in Fig. 25 of an extended version of
this paper [ 47].
2.3 OurTechnique
Weaimtoleverageprogramsemanticsinsimilarityanalysis.We
deﬁnethe semantics ofabinary program /u1D443as follows.
403ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA X.Xu,Z.Xuan,S.Feng,S.Cheng,Y. Ye, Q. Shi,G.Tao, L.Yu, Z.Zhang,andX.Zhang
(a)Cat@O3(144blocksand218edges)
 (b) Cat@O0 (83 blocks and 144 edges)
 (c)Touch@O0(89blocksand120edges)
Figure 2:Control-Flow-Graphs forMotivation Examples
X_sub_eax,_0x41
X_cmp_eax,_0x35
X_UNK
X_jmp_raxX_push_r14
X_push_r12
X_sub_rsp,_0x148
X_jmp_0x971
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23voidmain_cat (intargc, char** argv){
//not meaningful in source code
while(-1!=(c=get_cli_opt (argc, argv, "bestuv")))
{
switch(c){
case'b’: 
flag0 = true; ...;
break; 
case'e’: 
flag1 = true; 
break;
case'v’: 
print("Coreutils v8.30" ); 
break;
default: quote( "error"); abort(); 
}
}
} (a)cat@O3X_movabs_rdx,_HIMM
X_call_HIMM
X_cdqeX_push_rbp
X_sub_rsp,_0x1c8
X_mov_[rbp*1+ -12],_edi1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23voidmain_cat (intargc, char** argv){
//not meaningful in source code
while(-1!=(c=get_cli_opt (argc, argv, "bestuv")))
{
switch(c){
case'b’: 
flag0 = true; ...;
break; 
case'e’: 
flag1 = true; 
break;
case'v’: 
print("Coreutils v8.30" ); 
break;
default: quote( "error"); abort(); 
}
}
} (b) cat@O0X_push_r14
X_push_r12
X_jmp_0x971
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23X_push_rbp
X_sub_rsp,_0x148
X_mov_[rbp*1+ -12],_edi
X_UNK
X_call_HIMMvoidmain_touch (intargc, char** argv){
//not meaningful in source code
while(-1!=(c=get_cli_opt (argc, argv, ”bcdfhv")))
{
switch(c){
case'b’: 
flag |= 0x100; ...;
break; 
case‘c’: 
flag = 0x1; 
break;
case'v’: 
print("Coreutils v8.30" ); 
break;
default: quote( "error"); abort(); 
}
}
} (c) touch@O0
Figure3:Ourexample(Fig. 1)inSAFE.Thestatementshighlightedinyellowhavelargeattention(andhenceareimportant).
The gray boxes to the right (of the yellow statements) denote the corresponding tokens. Special token HIMMdenotes a constant
oraconstant controlﬂow target.
Definition 2.1. The semantics of a binary program /u1D443is repre-
sented by a distribution (/u1D465,/u1D442/u1D449(/u1D443(/u1D465))) ∼ D, with/u1D465∈ Xan input to
/u1D443and/u1D442/u1D449(/u1D443(/u1D465))the set of externally observable values when execut-
ing/u1D443on/u1D465. Observable values are those observed in I/O operations,
global,and heapmemoryaccesses.
Intuitively,thejointdistributionofinputsandobservablevalues
when executing /u1D443on the inputs denotes /u1D443’s semantics. Observable
valuesare hardlyalteredbycode transformations.
A Naive Sampling Method. One may not need to collect a large
number of samples to model the aforementioned distribution be-
causeiftwoprogramsareequivalent,executingthemonequivalent
inputsproducesequivalentobservablevalues.Therefore,anaive
method is to provide the same set of inputs to all programs such
that those that are equivalent must have identical observable value
distributions.However,suchasimplemethodisineﬀectivebecause
of the following reasons. First, even equivalent programs might
have diﬀerent input speciﬁcations (e.g., diﬀerent numbers of pa-
rametersanddiﬀerentordersofparameters), makingautomatically
feedingequivalent inputs tothem diﬃcult. Furthermore,diﬀerent
programs have diﬀerent input domains. When the provided inputs
are out-of-range (and hence invalid), the corresponding observ-
able value distributions cannot be used to cluster programs. In our
example,thevaliddomainof /u1D450atline3ofmain_cat isasetofchar-
acters{b,e,s,t,u,v} whereas the domain of /u1D450at line3ofmain_touchis{b,c,d,f,h,v} .Withoutinputspeciﬁcations,whicharehardtoac-
quireforbinaryfunctions,thenaivesamplingmethodmayprovide
a random input, say, /u1D450=173. As a result, the executions of both
functions fall into the exception handling paths and the observable
valuesare not distinguishable.
OurMethod. Insteadofsolvingtheinputspeciﬁcationproblem,
which is very hard for binary programs, we propose a technique
agnostic to such speciﬁcations. Speciﬁcally, we propose a novel
probabilisticexecutionmodelthatservesasaneﬀectivesampling
method to approximate the distribution Ddenoting program se-
mantics.Givenaprogram /u1D443,weacquireitssemanticrepresentation
as follows. We execute /u1D443on a setXof pre-determined (random)
inputs, which is an invariant for all programs we want to repre-
sent. To address the challenge of input speciﬁcation diﬀerences,
we assign the same value /u1D465∈ Xto each input variable (for all
programs). That is, we feed the same value to all input parameters,
making their order irrelevant. We repeat this for all values in X.
As an example, for the programs in Fig. 1, we setargcand**argv
(allelementsinthebuﬀer)inboth main_cat andmain_touch ,as
well as*inbuf,insize, and*outbuf in function complex_cat , to
173, acquiring three executions. Then we set them to 97,acquiring
anotherthreeexecutions,andsoon.
These random values may not be valid inputs and hence the
corresponding executions may not disclose meaningful semantics.
We hence further sample k-edge-oﬀ behavior.
404PEM: Representing Binary Program Semantics forSimilarity Analysis viaaProbabilistic ExecutionModel ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Definition2.2. Givenaprogram /u1D443andaninput /u1D465,let/u1D45Dbethe
programpathtakenwithinput /u1D465,wesayapath /u1D45D′is/u1D458-edge-oﬀ(from
/u1D45D) if/u1D458predicates along the execution need to be ﬂipped to other
branchoutcomes in orderto acquire /u1D45D′.
Forinstance,supposethatwhenexecuting main_cat with/u1D450=
173,thepath/u1D45Dis2-3-8.Ifthebranchatline 2isﬂippedtoline 11,
assuming that the following execution path is 13-16-17-19,2-11-13-
16-17-19is1-edge-oﬀfrom /u1D45D./u1D43E-edge-oﬀbehavior(ofaninput /u1D465)
isessentiallytheobservablevaluesencounteredinall /u1D458-edge-oﬀ
paths(of/u1D465).Observethatfor main_cat andmain_touch ,although
the0-edge-oﬀbehaviors(i.e.,theoriginalexecutions)arenotdis-
tinguishable,the1-edge-oﬀbehaviorsarequitediﬀerent,e.g.,the
behaviorof main_cat includesthosefromthedelegatedfunction
at line17. However, there is a practical challenge: covering all
/u1D458-edge-oﬀbehaviorevenwhen /u1D458=2maybeinfeasibleforcomplex
programs since the number of /u1D458-edge-oﬀ paths grows exponen-
tiallywith/u1D458.Moreover,controllingthesamplingprocessexclusively
by/u1D458inducessubstantialnoiseduetocodeoptimizations/transfor-
mations.Speciﬁcally,optimizationssubstantiallychangeprogram
structures, adding/removingpredicates.The /u1D458-edge-oﬀbehaviors
are hence quite diﬀerent. An example can be found in Section A
of an extended version of this paper [ 47]. To suppress the noise
introducedbyoptimizations,we leverage theobservationthatopti-
mizationsrarelychangethe(selectivity)rankingofpredicateswith
the maximum andminimum dynamicselectivity .
Definition2.3. Dynamicselectivityforapredicateinstance /u1D465⊗/u1D466.alt
is/barex/barex[[/u1D466.alt]] − [[/u1D465]]/barex/barex, where[[/u1D466.alt]],[[/u1D465]]are the runtime valuesofvariable
/u1D465and/u1D466.alt,and⊗ ∈ {>,≥,≠,==,<,≤}.
Forinstance,supposethatinanexecution,thevalueof inbuf[i]
atline22inFig.1is173.Itisthencomparedwith0x20.Thedynamic
selectivity of the predicate instance is hence 141 (i.e., |173−0x20|).
Essentially, the dynamic selectivity reﬂects how likely a branch
predict evaluates to true[ 37].Althoughautomaticcode transfor-
mationsmaychangedynamicselectivity,thepredicateinstances
with the largest/smallest dynamic selectivity tend to stay as the
largest/smallest ones after transformations. We formally explain
the observation in Section 3.5and empirically validate it in Sec-
tion4.5.Therefore,weselectpredicateinstancestoﬂipfollowing
aBeta-distribution [17] with/u1D6FC=/u1D6FD=0.03. The distribution has
the largest probabilities for predicates with the minimum and max-
imum selectivity and small probabilities in the middle (like a U
shape). Intuitively, if two programs are equivalent/similar, their
predicateswiththelargestandthesmallestselectivitytendtobe
thesame.Byﬂippingthesepredicatesinthetwoversions,weare
exploringtheirequivalentnewbehavior.
In our example, for both the optimized and the unoptimized
versionof main_cat ,thealgorithmﬁrstﬂips thepredicateatline 2
withahighprobabilitysincethe -1!=chasthelargestselectivityon
path2-3-8.Thenweachievethe1-edge-oﬀpath 2-11-13-16-17-19
as discussed above. Along the new path, the algorithm ﬂips the
predicatewiththelargestselectivityatline 22forfurther2-edge-oﬀ
explorationinboth versions,exposing similar behavior.
Torealizetheprobabilisticexecutionmodel,wedevelopabinary
interpreterthatcanfeedthebinarywithspeciallycraftedinputsand
sample observable values (Section 3.3). It also features a probabilis-
tic memory model that can tolerate invalid memory accesses while
Observable
Values
Input 
Program
Input Distribution
Probabilistic Execution Observable Value DistributionSeed Inputs
Probabilistic
Mem Model
Path Sampling
Value FrequencyA Sequence of Same Value
Instructions
CFGInterpreted Paths
Next PathMultiple
Samples
Aggregation
InterpreterInvalid Pointer
Dereferences
Values
Figure 4:Workﬂow of PEM
ensuring equivalent observable values for equivalent programs
(Section3.6). Compared to traditional forced-execution-based tech-
niques,PEMnaturallyhandlesthefunctioninliningproblemasour
samplingisnotdelimitedbyfunctionboundariesandourexecution
contextsarelargelyrealistic.Comparedtofuzzingbasedtechniques,
ours does not rely on solving the hard problem of generating valid
inputs. Compared to Machine Learning based techniques, our tech-
niquefocusesondynamicbehaviorofprograms,whicharemore
accuratereﬂections ofprogram semantics [ 20].
3 DESIGN
3.1 OverallWorkﬂow
Theworkﬂowof PEMisshowninFig. 4.Theinputisinthegrey
boxontheleftside.Itconsistsofasetofseedinputs,eachbeing
an inﬁnite sequenceofthe same value,the binaryexecutable,and
a path sampling strategy that can predict the next path to interpret
based on the set of interpreted paths. The interpreter interprets
the subject binary on a seed input, supplying the same value to
any inputvariable encountered duringinterpretation, to eliminate
any semantic diﬀerences caused by parameter order diﬀerences.
The interpretation also strictly follows the path indicated by the
pathsamplingcomponent.Wheninvalidpointerdereferencesare
encountered, which can be easily detected, the interpreter inter-
acts with the probabilistic memory model to emulate the access
outcomes. The emulation ensures that the same sequence of (ob-
servable) values are returned for equivalent paths. After sampling,
ontherightside,theobservablevaluedistributionsaresummarized
for later similarity analysis, which simply compares two multi-sets.
Theremainderofthissectionisorganizedasfollows.Weﬁrst
model binary instructions using a simpliﬁed language. Then we
presentthesemanticrules.Afterthat,wediscussthepathsampling
methodandthe probabilisticmemory model.
3.2 Language
ThesyntaxofourlanguageisinFig. 5.Aprogram /u1D443consistsofa
sequence of instructions. There are three categories of instructions.
First, there are instructions that move values among registers: /u1D45F1=
/u1D45F2movesthevaluein /u1D45F2to/u1D45F1;/u1D45F=/u1D463movesaliteralvalue /u1D463;/u1D45F1=/u1D45F2⋄/u1D45F3
movestheresultof /u1D45F2⋄/u1D45F3to/u1D45F1.Thesecondcategoryisloadandstore
instructions. The load instruction /u1D45F1=[/u1D45F2]treats the value in /u1D45F2
asamemoryaddressandloadsthevalueinthespeciﬁedmemory
location to /u1D45F1. Store is similar. There are also instructions that
changethecontrolﬂow.Instruction jmp/u1D44Ejumpstotheinstruction
at/u1D44E;jcc/u1D45F /u1D44Eperforms the jump operation only when the value
in/u1D45Fis non-zero; jr/u1D45Fis an indirect jump that uses the value in /u1D45F
as the target address. Instruction donemeans the interpretation
is ﬁnished. Although our language does not model functions for
405ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA X.Xu,Z.Xuan,S.Feng,S.Cheng,Y. Ye, Q. Shi,G.Tao, L.Yu, Z.Zhang,andX.Zhang
⟨Program⟩/u1D443/Colonequal/u1D43C⟨Register ⟩/u1D445/Colonequal{/u1D45F0,/u1D45F1,...,/u1D45F31}
⟨Val⟩/u1D463/Colonequal{0,1,2,...} ⟨ Addr⟩/u1D44E/Colonequal{0,1,2,...}
⟨Comparison ⟩ ⊗/Colonequal{==,≥,≤,...} ⟨BinOp⟩ ⋄/Colonequal{+,−,∗,...}
⟨Instruction ⟩/u1D43C/Colonequal/u1D45F1=/u1D45F2|/u1D45F=/u1D463|/u1D45F1=/u1D45F2⊗/u1D45F3|/u1D45F1=/u1D45F2⋄/u1D45F3
|/u1D45F1=[/u1D45F2]|[/u1D45F1]=/u1D45F2|jmp/u1D44E|jcc/u1D45F /u1D44E|jr/u1D45F|done|/u1D43C1;/u1D43C2
Figure 5:Syntax ofOur Language
/u1D445/u1D452/u1D454/u1D460∈RegState/ColonequalRegister →Val
/u1D440∈Memory/ColonequalAddr→Val /u1D456/u1D450∈InstrCnt/ColonequalZ+
/u1D442/u1D449∈ObservableValDist /ColonequalVal→Z+ ⊥/ColonequalUndefined Value /u1D45D∈Path/ColonequalInstrCnt →Z+
/u1D460∈SeedValue/ColonequalZ+
decode(/u1D44E): returnsinstructions in a basicblock starting from /u1D44E.
valid(/u1D44E): if anaddress /u1D44Eis valid (pointing to allocated memory).
invalidLd (/u1D44E): load a valuefrom aninvalidaddress /u1D44E.
Figure6:StateDomainsinInterpretation(top)andAuxiliary
Data andFunctions (bottom)
simplicity,ourimplementationsupportsthefullx86instructionset,
includingfunctioninvocations andreturns.
3.3 Interpretation
Thestatedomainsoftheinterpreterareillustratedintheupperbox
ofFig.6.Theregisterstate /u1D445/u1D452/u1D454/u1D460isamappingfromaregistertoa
value.Whileinourpresentationvaluesaresimplynon-negativein-
tegers, our implementation distinguishes bytes, words, and strings.
The memory store /u1D440is a mapping from an address to a value. We
useaninstructioncounter /u1D456/u1D450toidentifyeachinterpretedinstruc-
tion along the execution path. /u1D442/u1D449denotes the observable value
statistics.Itisamappingfromavaluetothenumberofitsobser-
vations,thatis,howmanytimesthevalueappearsinthecurrent
interpretation.Inthelowerbox,wedeﬁneanumberofauxiliary
data/structuresthatareimmutableduringinterpretationandanum-
berofhelperfunctionsusedinthesemantic rules.In particular,we
use⊥todenoteanundeﬁnedvalue; /u1D45Dtodenotethepathtointer-
pret,determinedbythepathsamplingcomponent(foragivenseed
value/u1D460). It is a mapping from instruction count to an instruction
address. For example, a 2-edge-oﬀ path for a seed value 994 can be
{1000→0x804578,2000→0x80a41f}.Itmeansthatthepredicate
instancewiththe instructioncount1000ought totakethebranch
startingat0x804578whenexecutingthebinarywiththeseedinput
994, and the instance with count 2000 should take the branch at
0x80a41f. The helper function decode(/u1D44E) disassembles the instruc-
tionsinabasicblockstartingat /u1D44E.Thefunction valid(/u1D44E)determines
if an address is valid. Note that since we enforce branch outcomes
and use crafted inputs, the execution states may be corrupted. This
function helps detect such corrupted states and seeks help from
the probabilistic memory model. The function invalidLd (/u1D44E) loads
avaluefrom an invalidaddress.
PartofthesemanticrulesareinFig. 7.Asshownatthetopof
Fig.7,thestateconﬁgurationisatupleofﬁveentries.Aruleisread
as follows: if the preconditions at the top are satisﬁed, the state
transition at thebottom takes place. For example, Rule JccGTsays
that if there is a branch /u1D44E′speciﬁed in /u1D45Dfor the current instruction
count/u1D456/u1D450,theconditionaljump isinterpreted andthecontinuation
is/u1D43C′decodedfrom /u1D44E′.
Intuitively, given a seed value /u1D460, the interpreter initializes all
registers and parameters with the same value /u1D460, and starts interpre-
tationfromthebeginning(Rule Start).Theinterpretationlargely
follows concrete execution semantics except the following. First,StateConﬁguration: ⟨/u1D445/u1D452/u1D454/u1D460,/u1D43C,/u1D456/u1D450,/u1D440,/u1D442/u1D449 ⟩
EntryPoint =/u1D452/u1D45B∀/u1D45F,/u1D445/u1D452/u1D454/u1D460[/u1D45F]=/u1D460
⟨∅,∅,0,∅,∅⟩ → ⟨/u1D445/u1D452/u1D454/u1D460,decode(/u1D452/u1D45B),1,∅,∅⟩/u1D446/u1D461/u1D44E/u1D45F/u1D461
/u1D45D[/u1D456/u1D450]=/u1D44E′/u1D43C′=decode(/u1D44E′)
⟨/u1D445/u1D452/u1D454/u1D460,jcc/u1D45F /u1D44E;/u1D43C,/u1D456/u1D450,/u1D440,/u1D442/u1D449 ⟩ → ⟨/u1D445/u1D452/u1D454/u1D460,/u1D43C′,/u1D456/u1D450+1,/u1D440,/u1D442/u1D449⟩/u1D43D/u1D450/u1D450/u1D43A/u1D447
/u1D445/u1D452/u1D454/u1D460[/u1D45F]≠0/u1D45D[/u1D456/u1D450]=⊥/u1D43C′=decode(/u1D44E)
⟨/u1D445/u1D452/u1D454/u1D460,jcc/u1D45F /u1D44E;/u1D43C,/u1D456/u1D450,/u1D440,/u1D442/u1D449 ⟩ → ⟨/u1D445/u1D452/u1D454/u1D460,/u1D43C′,/u1D456/u1D450+1,/u1D440,/u1D442/u1D449⟩/u1D43D/u1D450/u1D450/u1D447
/u1D445/u1D452/u1D454/u1D460[/u1D45F]=0/u1D45D[/u1D456/u1D450]=⊥
⟨/u1D445/u1D452/u1D454/u1D460,jcc/u1D45F /u1D44E;/u1D43C,/u1D456/u1D450,/u1D440,/u1D442/u1D449 ⟩ → ⟨/u1D445/u1D452/u1D454/u1D460,/u1D43C,/u1D456/u1D450 +1,/u1D440,/u1D442/u1D449⟩/u1D43D/u1D450/u1D450/u1D439
/u1D445/u1D452/u1D454/u1D460[/u1D45F2]=/u1D44E /u1D463=/u1D440[/u1D44E]/u1D445/u1D452/u1D454/u1D460′=/u1D445/u1D452/u1D454/u1D460[/u1D45F1⇝/u1D463]
⟨/u1D445/u1D452/u1D454/u1D460,/u1D45F1=[/u1D45F2];/u1D43C,/u1D456/u1D450,/u1D440,/u1D442/u1D449 ⟩ → ⟨/u1D445/u1D452/u1D454/u1D460′,/u1D43C,/u1D456/u1D450+1,/u1D440,/u1D442/u1D449⟩/u1D43F/u1D451/u1D449
/u1D445/u1D452/u1D454/u1D460[/u1D45F2]=/u1D44Evalid(/u1D44E)/u1D440[/u1D44E]=⊥/u1D445/u1D452/u1D454/u1D460′=/u1D445/u1D452/u1D454/u1D460[/u1D45F1⇝/u1D460]
⟨/u1D445/u1D452/u1D454/u1D460,/u1D45F1=[/u1D45F2];/u1D43C,/u1D456/u1D450,/u1D440,/u1D442/u1D449 ⟩ → ⟨/u1D445/u1D452/u1D454/u1D460′,/u1D43C,/u1D456/u1D450+1,/u1D440,/u1D442/u1D449⟩/u1D43F/u1D451/u1D448/u1D451
/u1D445/u1D452/u1D454/u1D460[/u1D45F2]=/u1D44E
¬valid(/u1D44E)/u1D463=invalidLd (/u1D44E)/u1D445/u1D452/u1D454/u1D460′=/u1D445/u1D452/u1D454/u1D460[/u1D45F1⇝/u1D463]
⟨/u1D445/u1D452/u1D454/u1D460,/u1D45F1=[/u1D45F2];/u1D43C,/u1D456/u1D450,/u1D440,/u1D442/u1D449 ⟩ → ⟨/u1D445/u1D452/u1D454/u1D460′,/u1D43C,/u1D456/u1D450+1,/u1D440,/u1D442/u1D449⟩/u1D43F/u1D451/u1D43C/u1D463
Figure 7:InterpretationRules
when it encounters a conditional jump which is indicated by the
path descriptor /u1D45Dto take a speciﬁc branch, it takes the speciﬁed
branch (Rule JccGT). Otherwise, it follows the normal semantics
(RulesJccTandJccF). Second, when it encounters a load, if the
address is valid but the memory location has not been deﬁned,
it ﬁlls it with /u1D460(RuleLdUd); if the address is invalid, it fetches
a value from the probabilistic memory model (Rule LdIv); other-
wise it loads a value from the memory as usual (Rule LdV). Here
/u1D445/u1D452/u1D454/u1D460′=/u1D445/u1D452/u1D454/u1D460[/u1D45F1⇝/u1D463]meansthattheregisterstateisupdatedby
associating /u1D45F1to/u1D463, yielding a new state /u1D445/u1D452/u1D454/u1D460′. Store instructions
are interpreted similarly. We track all dynamic memory allocations
for access validity checks.Details are elidedas this isstandard.
Wealsohaveasetofloggingrulesthatdescribehow PEMrecords
the statistics of observable values. We record the frequencies of
memory addresses accessed, values loaded/stored, control transfer
targets,andpredicateoutcomes.Duetospacelimitations,details
arepresentedinSectionBofanextendedversionofthispaper[ 47].
Loops and Recursion. Since our goal is to disclose semantic simi-
larity and not to infer semantics faithful to any executions induced
byrealinputs,followingcommonpractice,weunrolleachloopand
recursive call20 times.
3.4 PathSampling
WepresentthepathsamplingmethodinAlgorithm 1.Itconsistsof
two functions. Function interpretat line1interprets the input pro-
gram and ﬂips the predicates that are indicated by path, a mapping
from instruction count to an address (Fig. 6). Speciﬁcally, during
interpretation,thealgorithmﬂipsapredicateinstancetoanaddress
indicatedin pathifthecorrespondinginstructioncountismet.The
function returns alistofencounteredpredicate instances.
Function sampleiteratively selects a predicate instance to ﬂip
(from all the interpretation results in previous steps). Variable can-
didatesdenote a set of candidate predicates for ﬂipping and budget
the number of interpretations allowed. To begin with, PEMﬁrst in-
terpretsafaithfulpathwithoutalteringanybranchoutcome.Itthen
adds predicates inthis faithful pathto the candidates list(line 7).
Asshownintheloopatline 8,PEMiterativelyselectsapredi-
cate to ﬂip (line 10), composes a new path with the outcome of the
406PEM: Representing Binary Program Semantics forSimilarity Analysis viaaProbabilistic ExecutionModel ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Algorithm1: ProbabilisticPathSampling
1Function interpret(program, path)
//Interpretsthe input program;ﬂips predicates indicated by
path
//Returns predicateinstancesin the form (path,instruction
count, predicate,selectivity,outcome)
2return[(/u1D45D/u1D44E/u1D461ℎ,/u1D456/u1D450 0,/u1D45D/u1D45F0,/u1D460/u1D452/u1D4590,/u1D45C/u1D462/u1D4610),...]
3Function sample(program)
4candidates = [] //Candidatebranchesto ﬂip
5budget = 400 //Numberofsample rounds
6faithful = interpret(program, ∅)
7candidates.add(faithful)
8whilebudget≥0do
9 budget = budget -1
10 (path,ic,pr,sel,out) = select(candidates)
11 nextPath= path ∪{ic→getBranch(pr, ¬out)}
12 results= interpret(program, nextPath)
13 candidates.add(results)
selectedpredicate ﬂippedatline 11(function getBranch() acquires
the target address for the true/false branch outcome of a predicate
pr), interprets the program according to the new path (line 12),
and updates the list of candidates (line 13). Note that at line 10,
to select the predicate instance to ﬂip, PEMsorts all the candi-
date predicates by their dynamic selectivity. Then a real number
/u1D456∈ [0,1]is sampled following the probability density function
(PDF) of a Beta-distribution [ 17].PEMselects a predicate that is at
the/u1D456-percentile of the sorted candidates list, i.e., /u1D460/u1D452/u1D459/u1D452/u1D450/u1D461/u1D452/u1D451_/u1D45D/u1D45F/u1D452/u1D451=
/u1D460/u1D45C/u1D45F/u1D461/u1D452/u1D451_/u1D450/u1D44E/u1D45B/u1D451/u1D456/u1D451/u1D44E/u1D461/u1D452/u1D460 [/u1D456× (/u1D459/u1D452/u1D45B(/u1D460/u1D45C/u1D45F/u1D461/u1D452/u1D451_/u1D450/u1D44E/u1D45B/u1D451/u1D456/u1D451/u1D44E/u1D461/u1D452/u1D460 ) −1)]. Details can
be foundinSection Fofan extendedversionofthis paper [ 47].
3.5 Formal Analysis ofPathSampling
The eﬀectiveness of our path sampling algorithm piggybacks on
the following theorem.
Theorem 3.1. Assume two functionally equivalent programs /u1D443
and/u1D443′.Ifweinterpretthemalongtwoequivalentpathsandcollect the
predicateinstancesduringinterpretation,thepredicate instanceswith
thelargest(smallest)dynamicselectivityinbothprogram shavealarger
probabilitytomatch,comparedtothosewithnon-extremese lectivity.
While optimizations (e.g., constraint elimination [26]) may mod-
ify predicates to simplify control ﬂow, predicates with the smallest
and largest dynamic selectivity are most resilient to optimizations,
namely,theirselectivityrankinghardlychangesbeforeandafter
optimizations. Modiﬁcations to predicates introduced by optimiza-
tions fall into two categories: predicate elimination andinsertion. A
predicate relocation can be considered as ﬁrst removing the predi-
cateandthenaddingittoanotherlocation.Speciﬁcally,compiler
may eliminate a predicate if its outcome is implied by the path
conditionreachingthepredicate.Forexample,itmayeliminatea
predicate/u1D465>10ifthepathconditionincludes /u1D465>20.Ontheother
hand, compiler may introduce new predicates to provide control
ﬂowshortcuts.TakeFig. 8asanexample.Compilerinsertsanew
predicate,/u1D465<10,inFig.8b(showninred).Themodiﬁcationsim-
pliﬁesthecontrolﬂowwhen /u1D465islessthan 10.Notethat,inthese
cases, the dynamic selectivity of an inserted predicate will be close
tothedynamicselectivityofanexistingonebecausetheseinserted
predicates are derivedfrom constraintsinexisting predicates.1ifx == 10: . . .
2else if x == 15: . . .
3else if x == 20: . . .
4 . . .
5else: abort ()
(a)BeforeOptimization1if x < 10: abort()
2ifx == 10: . . .
3else if x == 15: . . .
4else if x == 20: . . .
5 . . .
6else: abort ()
(b) After Optimization
Figure8:Exampleofoptimizationthatprovidescontrolﬂow
shortcutbyinsertingpredicates.Thecompilerinsertsapredi-
catex<10atline1inFig.8b.Whenx<10,theexecutiondirectly
goestoabort() without comparing with other values.
The intuition of ourtheorem is hencethat the rankings of predi-
cateswiththesmallest/largestselectivitydonotdependonwhether
other predicates are modiﬁed. In contrast, the predicates ranked in
themiddlebytheirselectivityaremorelikelytohavetheirrankings
changedwhen predicates are removedoraddedbyoptimization.
ProofSketch. Weformalizetheintuitionbyfirstreasoningaboutthe
predicateshavingclosetothesmallestdynamicselectivit y.Reason-
ingforthelargestonesissymmetric.Supposethatforeachp redicate,
thecompilerhasaprobability /u1D461toeliminateitandaprobability /u1D45Efor
havingapredicateinsertedthatranksrightbeforeit.Inei thercase,
wesaythepredicateismodified.Theprobabilitythatapred icateis
notmodifiedisnotedas /u1D45F=1−/u1D461−/u1D45E.Wefurtherdenoteas P/u1D458the
probabilitythatthe /u1D458-thsmallestpredicateisstillthe /u1D458-thsmallest
oneafteroptimization.Itiscalculatedbythefollowingfo rmula:
P/u1D458=/u1D45F×⌊/u1D458−1
2⌋/summationdisplay.1
/u1D456=0/parenleftbigg/u1D458−1
2/u1D456/parenrightbigg/parenleftbigg2/u1D456
/u1D456/parenrightbigg
/u1D45F/u1D458−1−2/u1D456/u1D461/u1D456/u1D45E/u1D456(1)
Intuitively,therankingofthe /u1D458-thsmallestpredicateisnotchanged
by optimizations if (a) this predicate is not modiﬁed and (b) the
numberofpredicateswithasmallerdynamicselectivitydoesnot
change. In the above formula, /u1D45Frepresents condition (a) and the
second term represents condition (b). Speciﬁcally, (b) is satisﬁed
only when the numbers of removed and inserted predicates that
rankbefore /u1D458areequal.Here,/parenleftbig/u1D458−1
2/u1D456/parenrightbig/u1D45F/u1D458−1−2/u1D456meansanevennumber
(2/u1D456)ofthe/u1D458−1predicateswithasmallerrankingaremodiﬁed,and/parenleftbig2/u1D456
/u1D456/parenrightbig/u1D461/u1D456/u1D45E/u1D456means half of the modiﬁcations are removals and the other
halfareinsertions.Wevisualizethedistributionof P/u1D458inFig.9with
threesetsofconﬁgurationsof /u1D461and/u1D45E.Wecanseethatinallsetups,
P/u1D458monotonically decreaseswhen /u1D458increases.□
Wealsoconductanempiricalstudytovalidateourtheoreticalanal-
ysis.TheresultsarevisualizedinSection 4.5.Theresultsshow PEM
hasan80-90%chanceofmakingcorrectselectionsandexploring
equivalent paths by deterministically selecting the predicates with
largest/smallest dynamic selectivity.
AdvantagesofProbabilisticPathSamplingOverDetermin-
istic Selection. Note that the probability of predicates with the
smallest/largest selectivity having theirrankings changedby op-
timizationisnot0,althoughitissmallerthanothers.Totolerate
suchcertainty, weemploy aprobabilisticapproach,meaning that
we follow a Beta-distribution instead of deterministically selecting
the predicates with extreme selectivities for ﬂipping. We further
conduct a formal analysis to justify why the probabilistic sampling
algorithm is better than the deterministic algorithm. Intuitively, by
407ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA X.Xu,Z.Xuan,S.Feng,S.Cheng,Y. Ye, Q. Shi,G.Tao, L.Yu, Z.Zhang,andX.Zhang
010203040
k-th Smallest0.00.20.40.60.8Pkt= 0.1,q= 0.05
t= 0.2,q= 0.1
t= 0.2,q= 0.2
Figure 9: P/u1D458w.r.t./u1D458; The/u1D465-axis denotes the ranking of
predicates by dynamic selectivity; the /u1D466.alt-axis denotes the
probabilitythatthepredicatewiththe /u1D458-thsmallestdynamic
selectivity after optimization has the same ranking. Each
line showsresults foroneset of /u1D461and/u1D45E.
followingaBetadistribution,PEMspendssomebudgetonpredi-
catesthatdonothavethelargestorsmallestselectivity,butselectiv-
ities close to the largest and smallest. These “additional” selections
increase the probability that PEM selects the correct path (i.e., the
equivalentpath)ateachstep.Takingmorecorrectstepsatearlier
selections increasesthe chancethat PEMchooses a correctstep at
later selections because the candidate predicates of later selections
comefrompreviouslyexploredpaths.Theformalproofisshown
inSection C ofan extendedversionofthis paper [ 47].
Eﬀect of Path Infeasibility. Our algorithm may select infeasible
paths. Two possible concerns are (1) whether observable values
along infeasible paths in two similar binaries can correctly disclose
their semantic similarity; and (2) whether observable values along
infeasible paths in twodissimilar binaries may undesirably match,
leadingto the wrongconclusion oftheirsimilarity.
Forthefirstconcern,weshowthat PEMlikelyselectscorrespond-
ingpathswhentwobinariesaresimilar,regardlessofthefe asibility
of selected paths. That is, although the paths may be infeasi ble,
thesequencesofobservablevaluesalongthemareequivalen t.We
showaproofsketchinSectionD.1andshowempiricalsupport in
SectionD.3ofanextendedversionofthispaper[ 47].
Forthesecondconcern,theprobabilitythattwoequivalentpaths
areselectedby PEMintwodissimilarbinariesisverysmall.Inthose
cases, although the initial seed paths may be undesirably similar
(e.g., the error handling paths), the following ﬂipped (infeasible)
pathsquicklybecomesubstantiallydiﬀerent.Theformalproofisin
SectionD.2andtheempiricalstudyisinSectionD.3ofanextended
versionofthis paper [ 47].
3.6 ProbabilisticMemoryModel
The goal of the probabilistic memory model (PMM) is to handle
loadsandstoreswithinvalidaddressesinducedbypredicateﬂipping
andtheuseof(out-of-bound)seedvalues.Akeyobservationisthat
the speciﬁc values written-to/read-from the PMM do not matter
aslongastheycanexposefunctionalequivalence.Wedeﬁnethe
following twopropertiesfor avalid PMM.
Definition 3.1. We say a PMM is equivalence preserving if
thesequenceof(invalid)addressesaccessed,and thevalueswritten-
to/read-fromthePMMmustbeequal,fortwoequivalentpathsintwo
functionallyequivalentprograms.
This property ensures PEMcanplaceequivalent programsinto
the same class.
Definition 3.2. We saya PMM is diﬀerence revealing if the se-
quenceof(invalid)addressesaccessed,andthevalueswritten-to/read-
fromthePMMmustbediﬀerentfortwodiﬀerentpaths(pertaininginvalid memory accesses) in two respective programs, which may or
may not beequivalent.
Thisistoensurediﬀerentprogramsarenotmistakenlyplaced
in the same class. For example, a naive PMM always returns a con-
stant value for any invalid reads and ignores any invalid writes. It
isequivalence preservingbut not diﬀerence revealing.
Our PMM is designed as follows. Before each interpretation
run,itinitializesa probabilisticmemory (/u1D443/u1D440),whichisamapping
Addr→Valofsize/u1D6FEsuchthat: ∀/u1D44E∈ [0,/u1D6FE], /u1D443/u1D440[/u1D44E]=/u1D45F/u1D44E/u1D45B/u1D451/u1D45C/u1D45A().An
invalid memory read from the normal memory /u1D440with address /u1D44E
isforwardedtothe /u1D443/u1D440throughthe invalidLd (/u1D44E)function,which
returns/u1D443/u1D440[/u1D44Emod/u1D6FE]. Similarly, an invalid memory write to the
normalmemory /u1D440withaddress /u1D44Eandvalue/u1D463isachievedbysetting
/u1D443/u1D440[/u1D44Emod/u1D6FE]=/u1D463.
Itcanbeeasilyinferredthat ourPMMsatisﬁesthe equivalence
preserving property by induction (on the length of program paths).
Intuitively,the ﬁrstinvalidaccessesintwoequivalentpathsmust
have the same invalid address. As such, our PMM must return
thesamerandomvalue.Thissamerandomvaluemaybeusedto
computeotheridentical(invalid)addressesinthetwopathssuch
that the following invalid loads/stores are equivalent. It also proba-
bilisticallysatisﬁesthediﬀerencerevealingproperty.Speciﬁcally,
diﬀerentpathsmanifestthemselvesbysomediﬀerentinvalidad-
dresses, and our PMMlikely returns diﬀerent(random)values for
these diﬀerent addresses,rendering thefollowing memorybehav-
iors (with invalid addresses) diﬀerent. The chance that diﬀerent
paths may exhibit the same behavior depends on /u1D6FE. Due to the
complexityofmodelingmemorybehaviorinreal-worldprogram
paths,wedidnotderiveatheoreticalprobabilisticboundforour
PMM. However, empirically we ﬁnd that /u1D6FE=64/u1D458enables very
goodresults(withourloopunrollingbound20).Anexamplecan
be foundinSection E ofan extendedversionof this paper [ 47].
4 EVALUATION
Weimplement PEMonQEMU[ 35].DetailsareinSectionFofan
extendedversionofthispaper[ 47].Weevaluate PEMviathefol-
lowing researchquestions:
RQ1:Howdoes PEMperform comparedto the baselines?
RQ2:Howuseful is PEMinreal-world applications?
RQ3:IsPEMgeneralizable?
RQ4:Howdoes eachcomponentaﬀectthe performance?
4.1 Setup
We conduct the experiments on a server with a 24-core Intel(R)
Xeon(R) 4214R CPUat 2.40GHz,188G memory,andUbuntu 18.04.
Datasets. Weusetwodatasets. Dataset-I:TocomparewithIMFand
BLEX, which only use Coreutils [ 8] as their dataset, we construct a
dataset from Coreutils-8.32. We compile the dataset using GCC-9.4
and Clang-12, with 3 optimization levels (i.e., -O0, -O2, and -O3).
Dataset-II includes 9 real-world projects commonly-usedin binary
similarity analysis projects [ 22,28,31]. They are Coreutils, Curl,
Diﬀutils, Findutils, OpenSSL, GMP, SQLite, ImageMagick, and Zlib.
The binaries are obtained from [ 31]. In total, we have 30 programs
with35kfunctions, compiledwith3diﬀerentoptions. Detailscan
be foundinTable8ofan extendedversionof this paper [ 47].
BaselineTools. Wecomparewith6baselines.Forexecution-based
methods (Baseline-I), we use IMF [ 43] and BLEX [ 12], which are
SOTAsasfarasweknow.ForDeepLearningmethods(Baseline-II),
408PEM: Representing Binary Program Semantics forSimilarity Analysis viaaProbabilistic ExecutionModel ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Table1:Comparisonof PEM,IMF,andBLEX. CandGdenote
ClangandGCC,respectively.Eachprecisionisaveragedover
the106 binariesinCoreutils.
PairPrecision@1 Precision@3 Precision@5
PEMIMF BLEX PEMIMFPEMIMF
C-O0C-O394.5 77.5 X 98.2 84.2 98.7 86.4
C-O2C-O399.8 97.3 X 100.0 99.3 100.0 99.4
C-O0G-O394.560.1 X 97.3 70.6 98.6 73.4
G-O0G-O396.3 70.4 61.1 98.0 81.3 98.7 84.6
G-O2G-O398.6 89.5 77.1 99.4 95.5 99.8 96.2
G-O0C-O392.266.0 X 94.1 76.1 96.2 80.0
Average 96.0 76.8 69.1 97.8 84.5 98.7 86.7
weuseSAFE[ 30]andTrex[ 31].Weusetheirpre-trainedmodelsor
trainusingtheirreleasedimplementationwiththedefaulthyper-
parameters. Also, we compare with the best two models (i.e., GNN
andGMN) inHow-Solve [ 28] that conducts ameasurement study
onMachineLearningmethods.
Metrics. FollowingthesameexperimentsetupinIMFandBLEX,
forafunctioncompiledwithahigherleveloptimizationoption(e.g.,
-O3), we query the most similar function in all the functions (in the
samebinary)compiledwithalowerleveloptimizationoption.As
such,thereisonlyonematchedfunction.WehenceusePrecisionat
Position 1 (PR@1) as the metric. Given a function, PR@1 measures
whether the matched function scores the highest out of the pool of
candidate functions. Many data-driven methods [ 28,30,31,52] use
Area Under Curve (AUC) of the Receiver Operating Characteristic
(ROC) curve. Existing literature [ 2] points out that a good AUC
score does not necessarily imply good performance on an imbal-
anced dataset (e.g., class 1 having 1 sample and class 2 having 100).
Therefore we choose PR@1 as our metric, which aligns better with
the real-world (imbalanced)use scenario ofbinary similarity.
4.2 RQ1: Comparisonto Baselines
Comparison to Baseline-I. We compare PEMwith Baseline-I on
Dataset-I.Toconducttheevaluation,weﬁrstuse PEMtosample
each function in these binaries and aggregate the distribution of
observable values. Then, for each function in an optimized binary,
we compute its similarity score against all functions of the same
program compiled with a lower optimization level, and use the
ones with the highest scores to compute PR@1. Besides PR@1, we
also use PR@3 and @5 for a more thorough comparison with IMF.
ThecomparisonresultswithIMFandBLEXareshowninTable 11.
Thefirsttwocolumnslistthecompilersandtheoptimizatio nflags
usedtogeneratethereferenceandquerybinaries.Columns3- 5,6-7,
and8-9listPR@1,@3,and@5,respectively.NotethatBLEXonly
reportsPR@1anddoesnothaveresultsforbinariescompiledwit h
Clang.PEMoutperformsBLEXonPR@1andoutperformsIMFonall
3metricsunderallsettings.Especially,forfunctionpairs( Clang-O0,
GCC-O3)and(GCC-O0,Clang-O3),whicharethemostchalleng ing
settingsinourexperiment, PEMoutperformsIMFbyabout25%.
ComparisontoBaseline-II. Wecompare PEMwithBaseline-IIon
Dataset-II.FollowingthesetupofHow-Solve[ 28],foreachpositive
pair (of functions), namely, similar functions, 100 negative pairs
(i.e., dissimilar functions) are introduced to build up the test set.
The results are shown in Fig. 10. The/u1D465axis represents diﬀerent
programs,andthe /u1D466.altaxisisPR@1.Theresultsof PEM,GNN,and
1Wecompare PEMwiththereportedresultsintheIMFpaperandcontacttheauthor s
ofIMFtoensureoursetupsarethesame.0.21.0O0 VS O3
GMN
GNN
PEM
Avg. GMN
Avg. GNN
Avg. PEMO2 VS O3
0.90
0.480.500.96
0.740.78
ProgramsPrecision@1
Figure10:ComparisonwithHow-Solve.Weleveragethebest
twomodels(i.e.,GNNandGMN)inHow-Solve.Eachbardenotes
aprogram,whosenameiselided.Abarwith1.0PR@1means
thatPEMfinds the correct matches for all functions in the
program.DashedlinesdenotetheaveragePR@1ofeachtool.
GMN are shown in green, yellow, and red bars. The average PR@1
of each tool is marked by the dashed line with the related color.
Note that GNN and GMN are the best two models out of all 10
ML-basedmethodsinHow-Solve[ 28](includingTrexandSAFE).
As Fig.10illustrates, PEMachieves scores from 0.84 to 1.00, which
isaround 20-40%betterthanGNN andGMN.
Comparisonwith Trex and SAFE. With the aforementionedcompo-
sitionofdataset, PEMoutperformsTrexby40%andoutperforms
SAFEby25%onaverage.Moreover,theperformanceofTrexand
SAFEissensitivetodatasetcomposition.Henceinthiscompara-
tive experiment, weanalyze howdiﬀerent data compositionsaﬀect
the performance of diﬀerent tools. Our results show that PEMis
50% more resilient than Trex and SAFE. Details can be found in
Section H ofan extendedversionof this paper [ 47].
4.3 RQ2: Real-WorldCaseStudy
Wedemonstratethepracticeuseof PEMviaacasestudyofdetecting
1-dayvulnerabilities.Supposethatafteravulnerability isreported,a
systemmaintainerwantstoknowifthevulnerablefunctiono ccurs
inaproductionsystem.Shecanuse PEMtosearchforthevulnerable
functionfromalargenumberofbinaryfunctionsanddecidew hether
furtheractionsshouldbetaken(e.g.,patchthesystem).We collect8
1-dayVulnerabilities(CVEs)andusetheoptimizedversion ofthe
problematicfunctiontosearchforitscounterpartintheun optimized
binary. The results show that in 7 out of the 8 cases, our tool c an
findthegroundtruthfunctionasthetopone,whiletheother two
ML-based methods each can only find 1 of them. Even if we look
intothetop30,bothofthemcanonlyfind2oftheseproblemat ic
functions.DetailscanbefoundinSectionIofanextendedve rsion
ofthispaper[ 47].
4.4 RQ3: Generalizability
We evaluate the generalizability of PEMfrom three perspectives.
First, we show that PEMis eﬃcient so that it can scale to large
projects. Second, we illustrate that PEMhas good code coverage
for most functions. That means it can explore enough semantic
behavior even for complex functions. Last but not least, besides
x86-64,weshowthat PEMcansupportanotherarchitecturewith
reasonablehumaneﬀorts,meaningthat PEMcanbeeasilygener-
alizedto analyzing binary programs from multiple architectures,
without the need of substantial eﬀorts in building lifting or reverse
engineeringtoolsto recover high-level semantics from binaries.
Eﬃciency. PEManalyzesmorethan3functionspersecondinmost
cases.Notethatthisisaone-timeeﬀort.Afterinterpretationand
generating semantic representations, PEMsearches these represen-
tations to ﬁnd similar functions. PEMcompares more than 2000
409ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA X.Xu,Z.Xuan,S.Feng,S.Cheng,Y. Ye, Q. Shi,G.Tao, L.Yu, Z.Zhang,andX.Zhang
CoreutilsDiﬀutilsFindutilsCurlGMPZlib
ImageMagickOpenSSLSQLite0.00.20.40.60.81.0O0
CoreutilsDiﬀutilsFindutilsCurlGMPZlib
ImageMagickOpenSSLSQLiteO3
0.0-0.1
0.1-0.2
0.2-0.3
0.3-0.4
0.4-0.5
0.5-0.6
0.6-0.7
0.7-0.8
0.8-0.9
0.9-1.0
Figure 11:Coverage of PEM
pairs per second in most cases. The comparison can be parallelized.
With 4 processes, we are able to compare 1.7 million function pairs
in4minutes(wall-clock).WevisualizetheresultsinFigure27of
an extendedversionofthis paper [ 47].
PEMtakes 13 minutes to cover more than 95% code for all func-
tions in Coreutils (with a single thread). In comparison, the forced-
executionbased methodBLEXtakes 1.2 hours. In our experiment,
PEMtakes26minutesto processtwo Coreutilsbinariescompiled
with diﬀerent optimization levels, and it takes another 14 minutes
tocompareall1.7millionfunctionpairsbetweenthesetwobinaries,
yielding atotal time cost of40 minutes. While IMF takes 32min-
utestocompletethesametask, PEMachievessigniﬁcantlybetter
precision than IMF. Machine learning models typically have an
expensivetrainingtime.Theyhavebetterperformanceintesttime.
Coverage. The code coverage of PEMon Dataset-II is shown in
Fig.11. The/u1D465axis marks the projects and the /u1D466.altaxis shows the
percentage of functions for which PEMhas achieved various levels
of coverage, denoted by diﬀerent colors. As we can see, 90% of the
functionsin-O0and85%functionsin-O3haveafullorclose-to-full
coverage. Those functions with less than 40% coverage have ex-
tremelycomplexcontrolﬂowstructures,withmanyinlinedcallees.
For example, the main function of sortin Coreutils has 496 basic
blocks, resulting in millions of potential paths. Note that even with
such a huge path space, PEMis still able to select similar paths and
collectconsistent valueswithahigh probability.
Cross-archSupport. WeaddAArch64[ 1]supportto PEMwith
only around 200 lines of C++ code and 0.5 person-day eﬀorts. This
ispossiblebecauseourprobabilisticexecutionmodelisgeneraland
does not rely on specialized features from the underlying architec-
ture.PEMachievesaPR@1of86.8forCoreutils(-O0and-O3)on
AArch64,whereasitscounterpartonx86-64is89.4.Inaddition,it
achievesaPR@1of84.9whenwequerywithfunctionscompiled
onx86-64inthepooloffunctionscompiledonAArch64.Details
can be found in Table 7 of an extended version of this paper [ 47].
4.5 RQ4: Ablation Study
ProbabilisticPathSampling. First,weempiricallyvalidateour
hypothesis that branches with the largest and smallest selectiv-
ity are stable before and after code transformations. We collect
equivalentinterpretationtracesfromthemainfunctionsinCore-
utils binaries compiled with diﬀerent options. Then we analyze the
matchingtracesandcheckifthepredicateswiththelargestandthe
smallest selectivity in these cross-version traces match, leveraging
thedebuginformation.Intotal,westudy636tracesfrom6binaries
withatotalof16kpredicateinstances.Weobservethatwithaprob-
abilityofmorethan80%,ourhypothesisholds.Thedetailedresults
areshowninFig. 12.Fromthetwoendsofthelines,wecanobserve
thatinmorethan80%cases,thepredicateswiththesmallestand
the largest selectivity match. In contrast, those in the middle doTable 2:Perf. w.r.t. DiﬀerentPath Sampling Strategies
LastPred Det. PEM
PR@1 40.24 79.27 91.46
Cover-O0 66.28 96.77 96.81
Cover-O3 53.14 92.95 92.97
Table 3:Perf. w.r.t. DiﬀerentBudgets
1 20 50 100 200 400 600
PR@1 70 74 79 81 85 86 86
Cover-O0 63 87 91 94 96 98 98
Cover-O3 51 79 84 88 93 95 96
Table 4:Perf. w.r.t. DiﬀerentMemory Models
No-Mem Const PMM
PR@1 76.35 83.48 85.75
Cover-O0 97.59 97.70 98.03
Cover-O3 94.39 95.11 95.52
nothavesuchaproperty.Themedianforthe max-3selectivityis
even closeto0%. Forpredicateinstanceswiththesmallest/largest
selectivityinonetrace(e.g.,-O3),wefurtherstudythese lectivity
rankingsof theircorrespondencesinthe othertrace (e.g., -O0).The
resultsarevisualizedinFig. 13.Observethatinmorethan98%cases,
theyhavethetop-3smallestorlargestselectivityintheot hertrace.
Furthermore,weselect80mostchallengingfunctionsinCore-
utilstofurtherstudytheeﬀectivenessofourpathsamplingstrategy.
Thesefunctionshavemorethan150basicblocksandtheaverage
connectivity is larger than 3, namely, a block is connected to more
than3blocksonaverage.Wecomparetheperformanceof3path
sampling strategies. The results are shown in Table 2. The three
rowsshowthePR@1,thecodecoveragefor-O0and-O3functions,
respectively. The second column presents a strategy in which PEM
ﬂips the last predicate encountered in the previous round with an
uncoveredbranch.Thethirdcolumndenotesastrategyinwhich
PEMdeterministicallyﬂips thepredicates withthe largest and the
smallest selectivity at each round. The last column presents our
probabilistic path sampling strategy. Observe that the probabilistic
strategysubstantiallyoutperformstheothertwoandboththede-
terministicand probabilistic strategies can achieve good coverage.
Code Coverage versus Precision. We runPEMwith diﬀerent
round budgets on Coreutils and observe coverage and precision
changes. The results are shown in Table 3. Observe that if we only
interpret each function once without any ﬂipping, the precision
is as low as 70 and the coverage is low too. With more budgets,
namely, ﬂipping more predicates, both the precision and the cover-
age improve, indicating PEMcan expose equivalent semantics. But
the improvement becomes marginalafter 200.
ProbabilisticMemoryModel(PMM). WerunPEMwithdifferent
memorymodelsetupsonCoreutilstoillustratethebenefito fmodel-
inginvalidmemoryaccesses.TheresultsareinTable 4.Specifically,
No-Memmeanswedonotmodelinvalidmemoryaccesses.Wereturn
randomvaluesforinvalidreadsandsimplydiscardinvalidw rites.
The precision of No-Mem is nearly 10% lower than PMM, while
their coverage is similar. That is because some dependencies be-
tweenmemoryaccessesaremissingwithouthandlinginvalid writes.
Ontheotherhand,ifweallowwritestoinvalidmemoryregion sbut
alwaysreturnaconstantvalueforallinvalidreads,asshow ninthe
columnof Const,theprecisionisbetterthanNo-Mem.However,it
410PEM: Representing Binary Program Semantics forSimilarity Analysis viaaProbabilistic ExecutionModel ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
min
min+2min+4min+6min+8max-8max-6max-4max-2max
Selectivity0.000.250.500.751.00 Results of a Program
Median
Figure 12: Predicate Correspondence versus Dynamic Selec-
tivity.Eachbluedashedlinerepresentstheanalysisresultsof
path pairs from two respective binaries compiled diﬀerently
fromaprogram.The /u1D465axisrepresentsselectivity(with min
theminimaland maxthemaximum)and /u1D466.altdenotestheper-
centageofpredicatematches.Wealsocomputethemedian
foreachselectivity,resultingintheorangeline.
min min+2 min+4 max-4 max-2 max
Selectivity0200400600Number ofPredicates
Figure13:CorrespondenceofPredicateswithMinandMax
Selectivity.Blueisforminandorangeformax.Forexample,
thebaratmin+1meansthatabout20predicateswithminse-
lectivityinonetracehavemin+1selectivityintheothertr ace.
isstillinferiortoPMM.Thisisduetoreturningtheconstan tvalue
makingreadsfromdifferentinvalidaddressesindistingui shable.
Robustness. We altersystemconﬁgurationsof PEMand runran-
dom sampling for each probabilistic component in PEM. The ex-
perimentalresultsshowthat PEMisrobustwithregardtodiﬀerent
conﬁgurations and variances in samplings. Details can be found in
Section G ofan extendedversionofthis paper [ 47].
5 RELATED WORK
BinarySimilarity. Manyexistingtechniquesaimtodetectseman-
tically similar functions, driven by static [ 11,24] and dynamic [ 12,
15,16,43] analysis. A number of representative methods have
been discussed in Section 2.2. Other techniques compare code sim-
ilarity at diﬀerent granularity, e.g., whole binary [ 25,48], assem-
bly [10,13,45], and basic block [ 33]. While our method represents
semanticsatthefunction level,theresultingvalue setsofoursys-
tem can be used as function semantic signatures and facilitate
comparisons workingat othergranularity.
Forced Execution. Forced execution [ 12,32,51,55] concretely
executesabinaryalongdifferentpathsbyflippingbrancho utcomes.
Theytypicallyaimtocovermorecodeinaprogramandthususe
coverageastheguidance.Theycanhardlyselectsimilarset sofpaths
forthesameprogramcompiledwithdifferentoptimizations .Their
focusisonrecoveringfrominvalidmemoryaccesses.Incont rast,the
probabilistic memory model of PEMreveals the different semantics
introducedbydifferentinvalidaccesseswithhighprobabi lity.
6 CONCLUSION
We develop a novel probabilistic execution modelfor eﬀective sam-
plingandrepresentationof binary programsemantics. Itfeatures apath-samplingalgorithmthatisresilienttocodetransformations
andaprobabilisticmemorymodelthatcantolerateinvalidmemory
accesses. Itsubstantially outperforms the state of the arts.
7 DATA AVAILABILITY
Our experimental data andthe artifact are available at [ 46].
ACKNOWLEDGMENTS
Wethanktheanonymousreviewersfortheirvaluablecomments
andsuggestions.Thisresearchwassupported,inpartbyDARPA
VSPELLS-HR001120S0058,IARPATrojAIW911NF-19-S-0012,NSF
1901242 and 1910300, ONR N000141712045, N000141410468 and
N000141712947. Any opinions, ﬁndings, and conclusions in this
paperarethoseoftheauthorsonlyanddonotnecessarilyreﬂect
the viewsofour sponsors.
REFERENCES
[1]ARM64 2022. Learn the architecture - AArch64 Instruction Set Architecture .https:
//developer.arm.com/documentation/102374/latest/
[2]Daniel Arp, Erwin Quiring, Feargus Pendlebury, Alexander Warnecke, Fabio
Pierazzi,ChristianWressnegger,LorenzoCavallaro,andKonradRieck.2020. Dos
and Don’ts of Machine Learning in Computer Security. CoRRabs/2010.09470
(2020). arXiv: 2010.09470 https://arxiv.org/abs/2010.09470
[3]Tiﬀany Bao, Jonathan Burket, Maverick Woo, Rafael Turner, and David Brumley.
2014. BYTEWEIGHT: Learning to recognize functions in binary code. In 23rd
USENIXSecuritySymposium(USENIXSecurity14) . 845–860.
[4]Leyla Bilge, Davide Balzarotti, William Robertson, Engin Kirda, and Christopher
Kruegel.2012. Disclosure:detectingbotnetcommandandcontrolserversthrough
large-scale netﬂow analysis. In Proceedings of the 28th Annual Computer Security
ApplicationsConference . ACM.
[5] BinDiﬀ 2022. zynamics BinDiﬀ .https://www.zynamics.com/bindiﬀ.html
[6]Dong-KyuChae,JiwoonHa, Sang-WookKim,BooJoong Kang,andEul GyuIm.
2013. Softwareplagiarismdetection:agraph-basedapproach.In Proceedingsof
the 22nd ACM international conference on Information & Knowledge Management .
1577–1580.
[7]Mahinthan Chandramohan, Yinxing Xue, Zhengzi Xu, Yang Liu, Chia Yuan Cho,
and Hee Beng Kuan Tan. 2016. BinGo: Cross-Architecture Cross-OS Binary
Search(FSE2016) .AssociationforComputingMachinery,NewYork,NY,USA,
678–689. https://doi.org/10.1145/2950290.2950350
[8]Coreutils 2022. Coreutils - GNU core utilities .https://www.gnu.org/software/
coreutils/
[9]Yaniv David, Nimrod Partush, and Eran Yahav. 2016. Statistical Similarity
of Binaries. In Proceedings of the 37th ACM SIGPLAN Conference on Program-
ming Language Design and Implementation (Santa Barbara, CA, USA) (PLDI
’16). Association for Computing Machinery, New York, NY, USA, 266–280.
https://doi.org/10.1145/2908080.2908126
[10]StevenH.H.Ding,BenjaminC.M.Fung,andPhilippeCharland.2019. Asm2Vec:
BoostingStaticRepresentationRobustnessforBinaryCloneSearchagainstCode
Obfuscation and Compiler Optimization. In 2019 IEEE Symposium on Security
and Privacy (SP) . 472–489. https://doi.org/10.1109/SP.2019.00003
[11]Yue Duan, Xuezixiang Li, Jinghan Wang, and Heng Yin. 2020. DeepBinDiﬀ:
LearningProgram-WideCodeRepresentationsforBinaryDiﬃng. https://doi.
org/10.14722/ndss.2020.24311
[12]ManuelEgele,MaverickWoo,PeterChapman,andDavidBrumley.2014. Blanket
Execution:DynamicSimilarityTestingforProgramBinariesandComponents.
InProceedings of the 23rd USENIX Conference on Security Symposium (San Diego,
CA)(SEC’14). USENIXAssociation, USA,303–317.
[13]Qian Feng, Rundong Zhou, Chengcheng Xu, Yao Cheng, Brian Testa, and Heng
Yin. 2016. Scalable graph-based bug search for ﬁrmware images.In Proceedings
ofthe2016ACMSIGSACConferenceonComputerandCommunicationsSecurity .
480–491.
[14]YanickFratantonio,AntonioBianchi,WilliamRobertson,EnginKirda,Christo-
pher Kruegel, and Giovanni Vigna. 2016. Triggerscope: Towards detecting logic
bombsin androidapplications.In 2016IEEEsymposiumonsecurity andprivacy
(SP). IEEE.
[15]Jian Gao, Xin Yang, Ying Fu, Yu Jiang, and Jiaguang Sun. 2018. VulSeeker: A
Semantic Learning Based Vulnerability Seeker for Cross-Platform Binary . As-
sociation for Computing Machinery, New York, NY, USA, 896–899. https:
//doi.org/10.1145/3238147.3240480
[16]Y.Hu,Y.Zhang,J.Li,H.Wang,B.Li,andD.Gu.2018. BinMatch:ASemantics-
BasedHybridApproachonBinaryCodeCloneAnalysis.In 2018IEEEInternational
Conference on Software Maintenance and Evolution (ICSME) . IEEE Computer
411ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA X.Xu,Z.Xuan,S.Feng,S.Cheng,Y. Ye, Q. Shi,G.Tao, L.Yu, Z.Zhang,andX.Zhang
Society,LosAlamitos,CA,USA,104–114. https://doi.org/10.1109/ICSME.2018.
00019
[17]N.L.JohnsonandS.Kotz.1972. DistributionsinStatistics:ContinuousMultivariate
Distributions . John Wiley, NewYork, NY.
[18]AlexandrosKapravelos,ChrisGrier,NehaChachra,ChristopherKruegel,Gio-
vanniVigna,andVernPaxson.2014.Hulk:Elicitingmaliciousbehaviorinbrowser
extensions.In 23rdUSENIXSecuritySymposium(USENIXSecurity14) .
[19]CharitonKaramitasandAthanasiosKehagias.2018. Eﬃcientfeaturesforfunction
matching between binary executables. In 2018 IEEE 25th International Conference
on Software Analysis, Evolution and Reengineering (SANER) . 335–345. https:
//doi.org/10.1109/SANER.2018.8330221
[20]UlfKargénandNahidShahmehri.2017. Towardsrobustinstruction-leveltrace
alignment of binary code. In 2017 32nd IEEE/ACM International Conference on
Automated Software Engineering (ASE) . 342–352. https://doi.org/10.1109/ASE.
2017.8115647
[21]Amin Kharraz, William Robertson, Davide Balzarotti, Leyla Bilge, and Engin
Kirda. 2015. Cutting the gordian knot: A look under the hood of ransomware
attacks.In InternationalConferenceonDetectionofIntrusionsandMalware,and
Vulnerability Assessment . Springer.
[22]DongkwanKim, EunsooKim, SangKil Cha, Sooel Son, and Yongdae Kim. 2022.
RevisitingBinaryCodeSimilarityAnalysisusingInterpretableFeatureEngineer-
ingandLessonsLearned. IEEETransactionsonSoftwareEngineering (2022), 1–23.
https://doi.org/10.1109/TSE.2022.3187689
[23]GeunwooKim,SanghyunHong,MichaelFranz,andDokyungSong.2022. Im-
proving Cross-Platform Binary Analysis Using Representation Learning via
Graph Alignment. In Proceedings of the 31st ACM SIGSOFT International Sym-
posium on Software Testing and Analysis (Virtual, South Korea) (ISSTA 2022) .
Association for Computing Machinery, New York, NY, USA, 151–163. https:
//doi.org/10.1145/3533767.3534383
[24] Yujia Li, Chenjie Gu, Thomas Dullien, OriolVinyals, and Pushmeet Kohli. 2019.
GraphMatchingNetworksforLearningtheSimilarityofGraphStructuredOb-
jects.CoRRabs/1904.12787(2019). arXiv: 1904.12787 http://arxiv.org/abs/1904.
12787
[25]Bingchang Liu, Wei Huo, Chao Zhang, Wenchao Li, Feng Li, Aihua Piao, and
WeiZou.2018. aDiﬀ:Cross-VersionBinaryCodeSimilarityDetectionwithDNN .
Association for Computing Machinery, New York, NY, USA, 667–678. https:
//doi.org/10.1145/3238147.3238199
[26]LLVM 2022. llvm-project .https://github.com/llvm/llvm-project/blob/release/12.
x/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp
[27]Lannan Luo, Jiang Ming, Dinghao Wu, Peng Liu, and Sencun Zhu. 2017.
Semantics-BasedObfuscation-ResilientBinaryCodeSimilarityComparisonwith
Applications to Software and Algorithm Plagiarism Detection. IEEE Transactions
onSoftwareEngineering 43,12(2017),1157–1177. https://doi.org/10.1109/TSE.
2017.2655046
[28]AndreaMarcelli, MarianoGraziano, XabierUgarte-Pedrero, Yanick Fratantonio,
Mohamad Mansouri, and Davide Balzarotti. 2022. How machine learning is
solving the binary function similarity problem. In USENIX 2022, 31st USENIX
SecuritySymposium, 10-12August 2022, Boston,MA, USA , Usenix(Ed.). Boston.
[29]Ehsan Mashhadi and Hadi Hemmati. 2021. Applying CodeBERT for Auto-
mated Program Repair of Java Simple Bugs. CoRRabs/2103.11626 (2021).
arXiv:2103.11626 https://arxiv.org/abs/2103.11626
[30]Luca Massarelli, GiuseppeAntonioDi Luna,FabioPetroni, Leonardo Querzoni,
andRobertoBaldoni.2018. SAFE:Self-AttentiveFunctionEmbeddingsforBinary
Similarity. https://doi.org/10.48550/ARXIV.1811.05296
[31]Kexin Pei, Zhou Xuan, Junfeng Yang, Suman Jana, and Baishakhi Ray. 2020.
Trex: Learning Execution Semantics from Micro-Traces for Binary Similarity.
https://doi.org/10.48550/ARXIV.2012.08680
[32]FeiPeng,ZhuiDeng,XiangyuZhang,DongyanXu,ZhiqiangLin,andZhendong
Su.2014. X-Force:Force-ExecutingBinaryProgramsforSecurityApplications.
InProceedings of the 23rd USENIX Conference on Security Symposium (San Diego,
CA)(SEC’14). USENIXAssociation, USA,829–844.
[33]JannikPewny,Behrad Garmany,RobertGawlik, ChristianRossow,andThorsten
Holz.2015. Cross-ArchitectureBugSearchinBinaryExecutables.In 2015IEEE
Symposium on Security and Privacy . 709–724. https://doi.org/10.1109/SP.2015.49
[34]Jannik Pewny, Felix Schuster, Lukas Bernhard, Thorsten Holz, and Christian
Rossow.2014.LeveragingSemanticSignaturesforBugSearchinBinaryPrograms.
InProceedingsofthe30thAnnualComputerSecurityApplicationsConference (New
Orleans,Louisiana,USA) (ACSAC’14) .AssociationforComputingMachinery,
NewYork, NY, USA,406–415. https://doi.org/10.1145/2664243.2664269
[35]QEMU 2023. A genericandopensource machine emulator andvirtualizer .https:
//www.qemu.org
[36]Xiaolei Ren, Michael Ho, Jiang Ming, Yu Lei, and Li Li. 2021. Unleashing the
Hidden Power of Compiler Optimization on Binary Code Diﬀerence: An Empirical
Study. Association for Computing Machinery, New York, NY, USA, 142–157.
https://doi.org/10.1145/3453483.3454035
[37]Seemanta Saha, Mara Downing, Tegan Brennan, and Tevﬁk Bultan. 2022.
PREACH: A Heuristic for Probabilistic Reachability to Identify Hard to ReachStatements. In 2022 IEEE/ACM 44th International Conference on Software Engi-
neering (ICSE) . 1706–1717. https://doi.org/10.1145/3510003.3510227
[38]HiteshSajnani,VaibhavSaini,JeﬀreySvajlenko,ChanchalK.Roy,andCristinaV.
Lopes.2016. SourcererCC:ScalingCodeCloneDetectiontoBig-Code.In 2016
IEEE/ACM38thInternationalConferenceonSoftwareEngineering(ICSE) .1157–
1168.https://doi.org/10.1145/2884781.2884877
[39]Ridwan Salihin Shariﬀdeen, Shin Hwei Tan, Mingyuan Gao, and Abhik Roy-
choudhury. 2021. Automated Patch Transplantation. ACM Trans. Softw. Eng.
Methodol. 30,1,Article6 (dec2021),36pages. https://doi.org/10.1145/3412376
[40]Eui Chul Richard Shin, Dawn Song, and Reza Moazzezi. 2015. Recognizing
functions in binarieswith neural networks.In 24th USENIXSecuritySymposium
(USENIXSecurity15) . 611–626.
[41]Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones,
Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. Attention Is All
YouNeed. CoRRabs/1706.03762(2017). arXiv: 1706.03762 http://arxiv.org/abs/
1706.03762
[42]Andrew Walker, Tomas Cerny, and Eungee Song. 2020. Open-Source Tools and
BenchmarksforCode-CloneDetection:Past,Present,andFutureTrends. SIGAPP
Appl. Comput. Rev. 19, 4 (jan 2020), 28–39. https://doi.org/10.1145/3381307.
3381310
[43]ShuaiWangandDinghaoWu.2017. In-MemoryFuzzingforBinaryCodeSimi-
larity Analysis. In Proceedings of the 32nd IEEE/ACM International Conference on
Automated Software Engineering (Urbana-Champaign, IL, USA) (ASE 2017) . IEEE
Press,319–330.
[44]XiangzheXu,ShiweiFeng,YapengYe,GuangyuShen,ZianSu,SiyuanCheng,
Guanhong Tao, Qingkai Shi, Zhuo Zhang, and Xiangyu Zhang. 2023. Improving
Binary Code Similarity Transformer Models by Semantics-Driven Instruction
Deemphasis.In Proceedingsofthe32ndACMSIGSOFTInternationalSymposium
on Software Testing and Analysis (Seattle, WA, USA) (ISSTA 2023) . Association for
ComputingMachinery,NewYork,NY,USA,1106–1118. https://doi.org/10.1145/
3597926.3598121
[45]Xiaojun Xu, Chang Liu, Qian Feng, Heng Yin, Le Song, and Dawn Song. 2017.
Neural Network-based Graph Embedding for Cross-Platform Binary Code Simi-
larity Detection. In Proceedings of the 2017 ACM SIGSAC Conference on Computer
and Communications Security . ACM.https://doi.org/10.1145/3133956.3134018
[46]XiangzheXu,ZhouXuan,ShiweiFeng,SiyuanCheng,YapengYe,QingkaiShi,
Guanhong Tao, Le Yu, Zhuo Zhang, and Xiangyu Zhang. 2023. PEM.https:
//github.com/XZ-X/PEM.git
[47]XiangzheXu,ZhouXuan,ShiweiFeng,SiyuanCheng,YapengYe,QingkaiShi,
GuanhongTao,LeYu,ZhuoZhang,andXiangyuZhang.2023.PEM:Representing
Binary Program Semantics for Similarity Analysis via a Probabilistic Execution
Model. arXiv: 2308.15449 [cs.SE]
[48]XiXu,QinghuaZheng,MingFan,JiaAng,andTingLiu.2021. Interpretation-
enabled Software Reuse Detection Based on a Multi-Level Birthmark Model.
873–884. https://doi.org/10.1109/ICSE43902.2021.00084
[49]ZhengziXu,BihuanChen,MahinthanChandramohan,YangLiu,andFuSong.
2017.SPAIN:SecurityPatchAnalysisforBinariestowardsUnderstandingthePain
andPills.In 2017IEEE/ACM39thInternationalConferenceonSoftwareEngineering
(ICSE). 462–472. https://doi.org/10.1109/ICSE.2017.49
[50]Jia Yang, Cai Fu, Xiao-Yang Liu, Heng Yin, and Pan Zhou. 2022. Codee: A Tensor
Embedding Scheme for Binary Code Search. IEEE Transactions on Software
Engineering 48,7 (2022), 2224–2244. https://doi.org/10.1109/TSE.2021.3056139
[51]WeiYou,ZhuoZhang,YonghwiKwon,YousraAafer,FeiPeng,YuShi,Carson
Harmon, and Xiangyu Zhang. 2020. PMP: Cost-eﬀective Forced Execution with
Probabilistic Memory Pre-planning. In 2020 IEEE Symposium on Security and
Privacy (SP) . 1121–1138. https://doi.org/10.1109/SP40000.2020.00035
[52]ZepingYu,RuiCao,QiyiTang,SenNie,JunzhouHuang,andShiWu.2020. Order
Matters:Semantic-AwareNeuralNetworksforBinaryCodeSimilarityDetection.
Proceedings of the AAAI Conference on Artiﬁcial Intelligence 34, 01 (Apr. 2020),
1145–1152. https://doi.org/10.1609/aaai.v34i01.5466
[53]Xiangyu Zhang, Neelam Gupta, and Rajiv Gupta. 2006. Locating Faults through
Automated Predicate Switching. In Proceedings of the 28th International Con-
ference on Software Engineering (Shanghai, China) (ICSE ’06) . Association for
ComputingMachinery,NewYork,NY,USA,272–281. https://doi.org/10.1145/
1134285.1134324
[54]Zhuo Zhang, Yapeng Ye, Wei You, Guanhong Tao, Wen-Chuan Lee, Yonghwi
Kwon,YousraAafer,andXiangyuZhang.2021. OSPREY:RecoveryofVariable
andDataStructureviaProbabilisticAnalysisforStrippedBinary.In 42ndIEEE
SymposiumonSecurityandPrivacy,SP2021,SanFrancisco,CA,USA,24-27May
2021. IEEE,813–832. https://doi.org/10.1109/SP40001.2021.00051
[55]Zhuo Zhang, Wei You, Guanhong Tao, Guannan Wei, Yonghwi Kwon, and
Xiangyu Zhang. 2019. BDA: practical dependence analysis for binary ex-
ecutables by unbiased whole-program path sampling and per-path abstract
interpretation. Proc. ACM Program. Lang. 3, OOPSLA (2019), 137:1–137:31.
https://doi.org/10.1145/3360563
Received 2023-02-02; accepted 2023-07-27
412