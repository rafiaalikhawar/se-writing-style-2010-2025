Where to Start: Studying Type Annotation Practices
in Python
Wuxia Jin†‡, Dinghong Zhong†‡, Zifan Ding†‡, Ming Fan‡, Ting Liu‡*
jinwuxia@mail.xjtu.edu.cn, {zhongdh,dingzifan19}@stu.xjtu.edu.cn,{mingfan,tingliu}@mail.xjtu.edu.cn
†School of Software Engineering, Xi’an Jiaotong University, Xi’an, China
‡Ministry of Education Key Laboratory of Intelligent Networks and Network Security, Xi’an Jiaotong University
Abstract —Dynamic programming languages have been em-
bracing gradual typing, which supports optional type annotations
in source code. Type-annotating a complex and long-lastingcodebase is indeed a gradual and expensive process, where twoissues have troubled developers. First, there is few guidanceabout how to implement type annotations due to the existenceof non-trivial type practices; second, there is few guidance aboutwhich portion of a codebase should be type-annotated ﬁrst.To address these issues, this paper investigates the patternsof non-trivial type-annotation practices and features of type-annotated code ﬁles. Our study detected six patterns of type-annotation practices, which involve recovering and expressingdesign concerns. Moreover, we revealed three complementaryfeatures of type-annotated ﬁles. Besides, we implemented atool for studying optional typing practice. We suggest that: 1)design concerns should be considered to improve type annotationimplementation by following at least six patterns; 2) ﬁles criticalto software architecture could be type-annotated in priority. Webelieve these guidelines would promote a better type annotationpractice for dynamic languages.
Index Terms—type annotation, dynamic languages
I. I NTRODUCTION
Dynamic programming languages have been embracing
gradual typing [1], supporting optional type annotations
in source code. For example, Python community proposesPEP483 to support optional type hints for Python 3.5 andlater versions in 2014. TypeScript [2] with the ﬁrst releaseversion in 2014 allows static type deﬁnitions for JavaScript.In 2020, Ruby 3.0 [3] claims featuring type annotations byintroducing RBS [4]. This trend indicates that dynamic typingcommunity increasingly acknowledges the beneﬁts of typeannotations, i.e., facilitating early bug detection and soft-ware maintenance [5], [6]. Notable Python communities likeApache PySpark have started modern type annotation practiceson their long-lasting codebases. By long-lasting codebases, we
mean that they were originally developed during that periodof optional typing feature unavailable.
Adding type annotations requires a monumental effort [5].
Type-annotating a complex and long-lasting codebase is not
* Ting Liu is the corresponding author.an overnight process, indeed a gradual migration from un-annotated codebase to a completely type-annotated one. Dur-ing this gradual and expensive process, two issues havetroubled developers:
First, there is few guidance on how to implement type
annotations. Some type annotation implementations requireadditional deﬁnitions, besides the types themselves. We deﬁnethem as non-trivial type annotation practices. Recent studies
[7], [8] concluded that adding type to a single variableconsumes about two minutes on average. However, the patternsfollowed by non-trivial type annotation are still unclear. Re-vealing these patterns would promote an effective and efﬁcienttype annotation practice.
Second, there is few guidance on which portion of a
codebase should be type-annotated in priority. When type-annotating a large-scale codebase, developers have struggledwith where to start adding types–“It should be decided ifannotations should cover only the public API(s), or internalsas well”, as stated by PySpark developers [9]. They agreethat there should be “a trade-off between completeness (of
the typing coverage) and the cost of maintenance (of typeannotations). ” However, it is unclear for type beginners about
which source ﬁles can be type-annotated with priority.
This paper focuses on the two issues by studying popular
Python projects that have experienced type annotations. Twosigniﬁcant considerations motivate our study. First, we con-jecture that the inconsistency between type annotation imple-mentations and the corresponding source code may imply thepatterns of non-trivial type annotations, due to the introductionof new code entities. Second, we assume that type-annotatedﬁles are likely critical to maintaining a software system. The
reason is that one intention of using types is to improvecodebase maintainability, which is commonly evaluated basedon code dependency structures [10], [11]. As a result, we willexplore three research questions:RQ1. What are the patterns that non-trivial type-annotationpractices follow?RQ2. Do type-annotated ﬁles present different dependencystructure?RQ3. Do type-annotated ﬁles incur different maintenancecost?
To support our study, we selected notable Python projects
with type hint experiences. These subjects are with diverse
5292021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000542021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678947
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
domains, sizes, and type-hint manners [12]. We designed the
THProﬁler to analyze projects’ source code and mine theirrevision history. We have created and released the dataset [13].
First, our study ﬁgured out six patterns followed by non-
trivial type hint practices. They are Typing Compatability,
API Visibility, BaseClass Presentation, Function Overloading,
Function-assigned V ariable, and Typing Extension . These type
annotation practices heavily involve recovering and expressingdesign or code decisions made by developers during codebasedevelopment. Second, we revealed three features of type-annotated ﬁles. Type-annotated ﬁles have a bigger value ofdegree centrality in dependency structure, reside at the up-permost layer in the hierarchical structure, and incur highermaintenance costs.
Our work is the ﬁrst to inspect non-trivial type-annotation
practices and identify features of type-annotated ﬁles, to thebest of our knowledge. Our ﬁndings beneﬁt type hint practicesand tools– 1) architecture concerns should be considered toimprove the effectiveness and efﬁciency of type implementa-tions by following these patterns; 2) ﬁles critical to softwarearchitecture could be type-annotated in priority for a gradualmigration from un-annotated codebase to type-annotated one.
Overall, our work makes the following contributions:
1) We deﬁne six patterns followed by non-trivial practices
and reveal three features of type-annotated ﬁles.
2) We suggest following these patterns with design con-
cerns to implement type annotations; we recommend type-
annotating ﬁles with the revealed features in priority.
3) We contribute a dataset and a tool for the continued study
of type annotation practices in dynamic languages.
The organization of the rest: Section II presents the key
concepts and our THProﬁler tool. Sections III, IV, and Vreport the study setup, study results, and potential impact ofour empirical study. Sections VI and VII discuss the threatsto validity and related work. Section VIII draws conclusions.
II. M
ETHODOLOGY
This section will introduce the concepts and THProﬁler we
designed to support our study.
A. Concepts
Listing 1: Example A
#a is type-annotated
#b,c are un-annotateddef func(a:int, b):
c=a+breturn cListing 2: Example B
#_P is a newly defined_P=TypeVar("_P",bound=int)def func(a:_P, b):
c=a+breturn c
1) Optional Type Annotation: Gradual typing [1] supports
optional type annotations in source code. The “optional”
means that developers can add type annotations to a portion ofsource ﬁles, and functions or variables inside one ﬁle. Onlytype-annotated entities will be statically type-checked whileothers remain type-checked at run-time. Listing 1 shows asnippet of Python code. In the function func , its parameter a
is annotated with int while the parameter band a variable c
have no type annotations.2) Type Annotation Implementation: Following
PEP484 [12], Python3.5 and later versions support twomanners of type annotation implementation:
inline type hints. Type annotations are directly inlined in
the source code. In Listing 3, type hints of var andadd are
inlined in test.py .
stub ﬁles. Type annotations are separately managed in stub
ﬁles named with ∗.pyi, which only contain type hints and are
only used by static type checkers (i.e., mypy [14], pytype [15]).In Listing 4, test.pyi is the stub ﬁle corresponding to test.py .
test.pyi only contains type-associated declarations and func-
tion signature of add. The function body of add is a single
ellipsis (...).
Python projects can adopt either one or both two manners
above at the same time.
Listing 3: Inline type hints
#test.py
var: int =1 0
def add(a:int,b:int)
->int:
c=a+b
return cListing 4: Stub ﬁle
#test.pyv a r=1 0def add(a,b):
c=a+breturn c
#test.pyivar: int
def add(a:int,b:int)->int:...
3) Trivial and Non-trivial Type Practices: We classify type
annotation implementations into two types:
Trivial type practices mean that type-annotating a code
entity simply requires assigning the type by following a syntax
of:type. In this case, the source code before and after type
annotation implementations are consistent with each other.Type-annotating ain Listing 1 is trivial by only adding :int.
Non-trivial type practices are complex implementations that
require introducing additional deﬁnitions such as variables,functions, and classes. This practice leads to the inconsistencybetween the code and type-annotated code. In listing 2,
Pis
introduced to type-annotate a.
B. THProﬁler
We designed and implemented THProﬁler to support our
study. THProﬁler analyzes the source code and mines revisionhistory of type-annotated Python codebases. As illustrated inFigure 1, the input of THProﬁler is a Python codebase withtype implementations. THProﬁler consists of three parts asfollows.
1) Typing Practice Identiﬁcation: This part detects entities
annotated with types and type usages in source code.
Typing Coverage Detection. Using Python ast library, this
module ﬁrst identiﬁes all code entities and type-annotatedentities. Then it calculates the typing coverages at variouslevels. We deﬁne typing coverage as the proportion of entities
(i.e., functions, ﬁles, variables) with type hints.
Diverse Type Extraction. Through traversing the AST struc-
tures of source ﬁles and stub ﬁles (if available), this moduledetects all types assigned to entities.
Complex Typing Usage Detection. This module detects the
usage of protocols and function overloadings. Overloaded
530Fig. 1: The overview of THProﬁler
functions are declared with @overload decorator, which is
imported from typing module. The @overload decorator
allows describing functions with same names but with different
combinations of argument types [16]. Protocol classes [17]explicitly extend from typing.P rotocol that supports struc-
tural typing. Structural typing can be considered as a static
equivalent of duck typing [18]. Protocol classes act as animplicit base-class in the static type analysis. That is, if a classhas some members that are also deﬁned by protocols, this classcan be (implicitly) treated as a sub-class of the protocols.
2) Dependency Structure Characterization: This part ex-
tracts and analyzes dependency structure of source code,following the Design Rule Theory [19]. Design Rule Theoryassumes that design rules and modules are major designconcerns in a software system. Design rules decouple the restof a system into mutually independent modules. In the sourcecode that follows Object-Oriented Programming pragmatics,design rules are often manifested as interfaces or abstractclasses. The removal, modiﬁcation, and addition of a moduleshould have no inﬂuence on design rules.
Dependency Extraction. This module considers both explicit
and possible dependencies in source code. As termed by Jinet al. [10], explicit dependencies are syntactic dependencies
that are explicitly referenced in source code, while possibledependencies are invisible and non-deterministic dependenciesdue to duck typing [18]. Following this work [10], this modulealso employs SCITool Understand [20] and ENRE [21] toextract explicit and possible dependencies, respectively.
Graph Construction. This module constructs the Attributed
Dependency Graph (ADG) from the union of explicit andpossible dependencies. In an ADG, each node denotes onesource ﬁle, and each directed edge denotes one dependencybetween two ﬁles. The node attribute speciﬁes whether anode has type hints (denoted as typed) or not. The attribute
information is obtained from the Typing Practice Identiﬁcation
of THProﬁler.
Design Rule Hierarchy (DRH). Based on the ADG, this
module employs DRH [22], [23] algorithm to identify designrules and independent modules in a software system. Fol-lowing the Design Rule Theory [19], DRH clusters sourceﬁles into a layering structure, where ﬁles in upper layersrepresent design rules, and ﬁles in lower layers are organizedinto independent modules decoupled by those design rules.Modules in lower layers depend on the modules in upperlayers, but not vice versa. Modules in the same layer aremutually independent.
We use a subset of source ﬁles in Django, one of our
subjects, to explain hierarchical structures created by DRH. InFigure 2, each row or column corresponds to a ﬁle and “dp”in a cell (i, j)indicates one dependency from ﬁle ito ﬁle j.
Dependencies can be “inherit” or “call” relations identiﬁed byDependency Extraction of THProﬁler. A diagonal cell means a
self-dependency. DRH clusters these 14 ﬁles into three layers,i.e.,L
0,L1, and L2. The uppermost layer L0(rows 1 to 6)
contains 6 ﬁles that denote design rules of this sub-system; L1
contains row 7 to 8; L2(row 9 to 14) includes four mutually
independent modules and they are row 9, 10, 11-13, and 14.
Fig. 2: The hierarchical structure formed by a subset of ﬁles in Django
3) Maintenance Measurement: This part computes the
maintenance cost of typed anduntyped ﬁles according to the
revision history managed by VCS (V ersion Control System)like Git.
Revision History Preprocess. This module exports the com-
mit log from a code repository. Each commit record includesthe commit ID, the author making this commit, a list ofmodiﬁed ﬁles, the IDs of issues ﬁxed by this commit, andthe LoC (Lines of Code) of addition and deletion.
Maintenance Cost Measurement. Based on commit records,
this module quantiﬁes the effort taken on maintaining sourceﬁles. Similar to the work of [10], [24], six measures arecomputed, including #commit —the number of commits made
to a ﬁle; #changeLoc—the total lines of changed code of
modifying a ﬁle; #author —the number of developers for
maintaining a ﬁle; #issue—the number of issues that a ﬁle
gets involved; #issueCmt —the number of commits of a ﬁle
for ﬁxing issues; #issueLoc—the total LoC changed to a ﬁle
531for ﬁxing issues. The bigger value of these measures indicates
the more maintenance cost invested on a ﬁle.
III. S TUDY SETUP
We collect Python projects that experience type annotation
practices and conduct a preliminary analysis during the setup.We will explore three research questions as follows.
RQ1: What are the patterns that non-trivial type-annotation
practices follow? This study will ﬁgure out and categorize thepatterns that complex type-hint practices will follow.
RQ2: Do type-annotated ﬁles present different dependency
structure? This study will compare the type-annotated ﬁleswith other ﬁles, based on ﬁle-level dependency structure.
RQ3: Do type-annotated ﬁles incur different maintenance
cost? The answer will advance our understanding of themaintainability of type-annotated ﬁles when compared withother ﬁles.
A. Collection and Subjects
We manually selected Python projects as subjects. The basic
selection criteria include: the project 1) is partially type-hinted;
2) is widely used, frequently starred, or downloaded; 3) hasa well-managed revision history with commits and issues; 4)follows type annotation syntax supported by Python 3.5 orlater versions; 5) uses non-Any types since Any is compatible
with every type and has no semantics.
Following these requirements, three contributors of our
work initially selected subjects from 105 public projectsstudied by a recent work [10] and selected frequently starredPython projects in Github. The selection process requiresmanually inspecting projects, the source code, and communitydiscussions to determine type-related information, such astype-hint manners they adopted and repositories that managetype implementations.
To alleviate the bias to our study, from the projects col-
lected by three contributors, we ﬁnally selected subjects withvarious diversities. 1) Diverse type hint manners: we chose
the projects, which only adopt inline type annotations, only
adopt stub type ﬁles, or adopt both inline andstub together.
2)Diverse domains: projects cover different domains such
as web framework, scientiﬁc computing, and type check. 3)Diverse sizes: projects can be small-scale (less than 10k LoC),medium-scale (at least 10k LoC), or large-scale (at least 100kLoC). Finally, we collected 19 subjects, as shown in Table I.
In Table I, V ersion is the project version we studied, #File
counts ﬁles, #LoC counts lines of code, TypeManner lists
type-hint manners used by projects, TypeCodeURL is the
Github repositories holding type implementations of projects,and Star denotes the project popularity. We can see that 3
projects manage type implementations in stub ﬁles; 9 projects
adopt inline type annotations; the remaining 7 projects adopt
both inline andstub manners. As listed in TypeCodeURL,
Django, DRF, and Matplotlib manage type stubs in separaterepositories from their codebase repositories.B. Statistics of Typing Coverage
By employing Typing Coverage Detection of our THProﬁler,
we detected type-annotated entities, then computed typingcoverage in terms of LoC, ﬁles, functions, and variables.Coverage (loc)is the ratio of LoC annotated with types to
the total LoC. The total LoC counts both the source codeand stub code in ∗.pyi (if have). Coverage (file)is the
proportion of ﬁles with type hints. Coverage (func)is the
proportion of functions or methods containing type-annotateddeclaration signatures. Coverage (var)counts the proportion
of type-annotated names or variables. The computation ofCoverage (var)excludes parameter variables since they are
considered for Coverage (func).
Table II lists typing coverage results. The values less
than 100% indicate that partial code entities are assignedwith type annotations. The values of Coverage (file)and
Coverage (func)are bigger than those of Coverage (loc)
andCoverage (var). For example, more than 90% ﬁles are
type-hinted in DRF, while the coverage values of variablesand functions are smaller. Besides, these results reveal asubstantial development and maintenance effort invested intype implementations.
C. Statistics of Diverse Type Usage
We used Diverse Type Extraction of THProﬁler to observe
type usages in subjects. We counted the types imported from
typing likeUnion andList since typing module is ofﬁcially
designed to support optional typing.
Fig. 3: The usage of diverse types
Figure 3 depicts shows that Any andOptional are most
frequently used in subjects. Optional means that the type of
a symbol can be a speciﬁed type or None . The Optional
usage indicates code objects are prone to be declared withNone by default. Any has no type semantics, meaning that
objects annotated by it will escape from static type-checking.
Our study will focus on non-Any annotation practices. If
a ﬁle only has Any types associated with code symbols,
we consider this ﬁle is un-annotated. In this case, the type-annotated ﬁle coverage as listed in Table III is sightly differentwith that in Table II for some projects.
532TABLE I: Subjects
Project V ersion File LoC TypeManner TypeCodeURL Star
Chainer 522e01 1,169 163,349 stub,inline https://github.com/chainer/chainer 5.6k
Django v3.1.7 2,531 280,529 stub https://github.com/typeddjango/django-stubs 56.4k
DRF v3.12.2 240 38,825 stub https://github.com/typeddjango/djangorestframework-stubs 20.6k
Elasticsearch 25b50e 225 42,546 stub,inline https://github.com/elastic/elasticsearch-py 3.2k
gRPC v1.36.2 280 32,317 inline https://github.com/grpc/grpc 29.8k
Matplotlib v3.3.3 1,151 213,369 stub https://github.com/predictive-analytics-lab/data-science-types 13.3kMypy v0.812 408 100,264 inline https://github.com/python/mypy 10.4k
Numpy v1.20.0 896 312,134 stub,inline https://github.com/numpy/numpy 16.6k
Pandas v1.2.3 1,350 349,932 inline https://github.com/pandas-dev/pandas/ 29.1k
Prefect c423a7 538 87,311 inline https://github.com/PrefectHQ/prefect 6.6.k
Pyproj dd84df 51 14,699 inline https://github.com/pyproj4/pyproj 633
PySpark v3.1.1 181 39,506 stub,inline https://github.com/apache/spark 29.2k
Pytest 940c6e 236 63,761 inline https://github.com/pytest-dev/pytest 7.5k
Rasa a4ee09 474 97,490 inline https://github.com/RasaHQ/rasa 11.7k
Returns v0.15.0 332 19,119 stub,inline https://github.com/dry-python/returns/ 1.6k
Sanic 021da3 141 18,943 inline https://github.com/sanic-org/sanic 15.1k
Scipy 6caa33 787 290,055 stub,inline https://github.com/scipy/scipy 8.4k
Uvicorn 62825d 64 5,554 inline https://github.com/encode/uvicorn 4.1k
Werkzeug 08624d 134 29,209 stub,inline https://github.com/pallets/werkzeug 5.8k
1DRF is Django-Rest-Framework.
TABLE II: Typing coverage results
Project Coverage
(loc)Coverage(ﬁle)Coverage(func)Coverage(var)
Project Coverage
(loc)Coverage(ﬁle)Coverage(func)Coverage(var)
Chainer 0.21% 2.86% 2.63% 0.00% Django 14.75% 75.89% 50.96% 27.92%
DRF 19.47% 91.67% 68.14% 33.56% Elasticsearch 43.46% 96.77% 95.88% 44.77%
gRPC 1.46% 8.20% 7.66% 0.00% Matplotlib 0.03% 4.87% 0.09% 0.01%
Mypy 10.22% 90.00% 99.98% 0.00% Numpy 2.12% 10.09% 2.07% 3.59%
Pandas 1.26% 20.37% 14.90% 0.57% Prefect 7.44% 69.78% 90.04% 0.00%
Pyproj 4.91% 61.90% 74.12% 0.00% PySpark 14.09% 43.55% 55.70% 6.38%
Pytest 11.48% 89.06% 93.11% 0.00% Rasa 8.45% 79.92% 100.00% 0.00%
Returns 11.82% 80.36% 90.64% 11.32% Sanic 7.32% 78.05% 52.19% 0.00%
Scipy 0.22% 3.01% 0.67% 0.03% Uvicorn 8.02% 75.61% 62.59% 0.00%
Werkzeug 11.98% 91.49% 98.39% 1.62%
TABLE III: Coverage (file )results after excluding Any types
Project Coverage Project Coverage Project Coverage
Chainer 2.86% Django 56.77% DRF 79.17%
Elasticsearch 60.22% gRPC 8.20% Matplotlib 2.21%
Mypy 90.00% Numpy 7.62% Pandas 20.37%
Prefect 69.40% Pyproj 61.90% PySpark 42.47%
Pytest 89.06% Rasa 79.92% Returns 80.36%
Sanic 78.05% Scipy 3.01% Uvicorn 73.17%
Werkzeug 91.49%
IV . E V ALUA TION
A. RQ1: Patterns of Non-trivial Type-annotation Practices
This RQ explores the patterns that non-trivial type annota-
tion practices follow. We ﬁrst illustrate this motivation. After
that, we manually screen subjects to categorize and explainthe patterns. We automatically detect these patterns through astatic code analysis on ASTs of subjects.
1) Motivation: When we employed Typing Coverage De-
tection of THProﬁler in Section III-B, we found an interesting
observation in subjects with stub ﬁles: besides adding a singletype to a symbol, developers sometimes deﬁne new entitieswhich were absent in the source ﬁles.
Table IV summarizes the stub ﬁles, classes, and functions
in the stub code, which are directly unmatched with thesource code. The results indicate that nine projects (exclud-ing Chainer) have a substantial number of entities newlyintroduced for type implementations. In Django, 13 stub ﬁles(∗.pyi) have no corresponding source ﬁles (∗.py ); 50 classes
and 266 functions are additionally deﬁned in stub code.
We assume that this inconsistency may capture non-trivial
type-annotation practices. Inspired by this assumption, weinspect the projects with such inconsistency.
2) Categorization Results: Due to the non-negligible in-
consistency (as shown in Table IV) between source code andstub code, we manually inspected the subjects with stub ﬁles,
as listed in Table I. We conducted a qualitative analysis andquantitative analysis supported by Complex Typing Usage De-
tection of THProﬁler. Finally, we ﬁgured out and categorized
six patterns that non-trivial type-hint practices follow.
Category 1 (Typing Compatibility): With the evolution of
typing module, typing inevitably provides fresh types that
were unavailable in earlier versions. When implementing type
annotations in older versions, such fresh types need to be user-deﬁned for version compatibility.
Listing 5: An example for Category 1
#numpy/core/function_base.pyi
ifsys.version_info >= (3, 8):
from typing import SupportsIndex
533TABLE IV: Summary of stub ﬁles, classes and functions that are deﬁned in
∗.pyi but absent in ∗.py
Project Absent Stub File Absent Class Absent Function
Chainer 0 0 0
Django 13 50 266
DRF 0 23 14
Elasticsearch 0 1 10
Matplotlib 3 5 0
Numpy 3 35 309
PySpark 8 0 96
Returns 0 1 2
Scipy 9 2 4
Werkzeug 0 0 56
*Since values in Chainer are zero, the study of RQ1 will exclude Chainer.
else:
from typing_extensions import Protocol
class SupportsIndex (Protocol):
def __index__(self) -> int: ...
For example, in Numpy project listed in Listing 5,
SupportsIndex is only supported by typing in Python3.8
and later versions. SupportsIndex should be user-deﬁned
in older versions. As a result, SupportsIndex is ab-
sent in function base.py while it is introduced in
function base.pyi.
Category 2 (API Visibility): One module deﬁnes an API while
its corresponding type-annotated API is declared in the stub
ﬁle of another module that depends on this API. In this case,type-annotated APIs are directly visible to their dependents.
Listing 6: An example for Category 2
#numpy/core/multiarray.py
__all__ = [’empty_like’, ...]def empty_like
(prototype, dtype=None, order=None, subok=None,
shape=None):
return (prototype,)
#numpy/core/numeric.pyidef empty_like
(a: _ArrayType, dtype: None = ...,
order: _OrderKACF = ..., subok: Literal[True] =..., shape: None = ...,) -> _ArrayType: ...
In Listing 6 excerpted from Numpy, empty like()is de-
ﬁned in multiarray.py module. This function is also in-
cluded in all , meaning that it is visible to other modules
by “from multiarray import ∗”. However, type implemen-
tation of empty like()appears in numeric.pyi instead of
multiarray.pyi . As a result, numeric can access the seman-
tic types of empty like().
Category 3 (Baseclass Presentation): Baseclasses, either ex-
tending from typing.P rotocol1or not, are newly introduced
into type implementations, making originally invisible inter-
faces explicit.
Listing 7: An example for Category 3
#rest_framework/permissions.py
class AND:
def __init__(self, op1, op2): ...
def has_permission(self, request, view): ...
1https://mypy.readthedocs.io/en/stable/protocols.htmlTABLE V: The classes present in stub code
Project Class All new class Protocol class Subclass
Django 1528 50 (3.27%) 10 25
DRF 236 2 (0.85%) 8 9
Elasticsearch 74 1 (1.35%) 0 0
Matplotlib 23 5 (21.74%) 0 2
Numpy 36 35 (97.22%) 27 18
PySpark 483 0 (0%) 0 0
Returns 1 1 (100%) 1 1
Scipy 1619 2 (0.12%) 3 0
Werkzeug 207 0 (0%) 1 0
def has_object_permission(self, request, view, obj
): ...
class OR:
def __init__(self, op1, op2): ...
def has_permission(self, request, view): ...
def has_object_permission(self, request, view, obj
): ...
#rest_framework-stubs/permissions.pyiclass _SupportsHasPermission
(Protocol):
def has_permission(self, request: Request, view:
APIView) -> bool: ...
def has_object_permission(self, request: Request,
view: APIView, obj: Any) -> bool: ...
class AND(_SupportsHasPermission ): ...
class OR(_SupportsHasPermission ): ...
In Listing 7, classes And andOR have no explicit relation-
ship in permissions.py . However, in permissions.pyi, both
of them explicitly inherit a newly deﬁned baseclass named
SupportHasPermission. The baseclass acts as an interface,
which was implicitly implemented by AND and OR in
permissions.py .
Table V summarizes the classes deﬁned in stub ﬁles. Con-
sidering Django, 1528 classes are type-annotated. 3.27% (i.e.,
50) of them are absent in source code but deﬁned for typehints. Among 50 new classes, 10 classes explicitly extend fromtyping.Protocol. 25 classes extend from these new classes.The presence of new base-classes helps build an explicitrelationship between base-classes and their sub-classes.
Category 4 (Function Overloading): A function in source
code may become overloaded in its type implementations.
Overloaded functions have the same name but are declaredwith different types of parameters or returns. In Listing 8,smart
text() is overloaded, generating two different deﬁni-
tions in type stub code.
Listing 8: An example for Category 4
#django/utils/encodings.py
def smart_text (s, encoding=’utf-8’, strings_only=
False, errors=’strict’):
warnings.warn("...")return smart_str(s, encoding, strings_only,
errors)
#django-stubs\utils\encoding.pyifrom typing import TypeVar, overload
@overloaddef smart_text
(s: _P, encoding: str = ...,
strings_only: bool = ..., errors: str = ...)
-> _P: ...
@overload
534TABLE VI: Summary of the overloaded functions (i.e., OFunc)
Project #OFunc all #OFunc 2 #OFunc 3 Max(OFunc i,i)
Django 45 35 9 4
DRF 4 4 0 2
Numpy 33 22 9 4Pyspark 115 92 14 28Scipy 18 2 16 3Werkzeug 18 12 5 4
def smart_text (s: _PT, encoding: str = ...,
strings_only: Literal[True] = ..., errors: str
= ...) -> _PT: ...
Table VI lists function overloading in subjects. For instance,
45 different functions in Django are overloaded in type im-
plementations, as indicated by #OFunc all.#OFunc 2=3 5
means that 35 of 45 functions are overloaded twice, i.e., eachfunction has two different declarations; #OFunc
3=9 shows
that 9 functions are overloaded with 3 times; the remainingone (i.e., 45-35-9=1) is overloaded with more than 3 times.Max(OFunc
i,i)=4 shows that there exists a function
overloaded with up to 4 separate declarations.
The common usage of function overloading in Table VI
implies a non-trivial effort for “splitting hairs” inﬂuenced bydifferent parameters.
Category 5 (Function-assigned V ariable): For variables as-
signed with function objects, type implementations may ex-
plicitly declare them as functions. This practice will generatenew function deﬁnitions in stub ﬁles.
Listing 9: An example for Category 5
#numpy/core/_internal.py
class _ctypes:
get_data = data.fget
get_shape = shape.fget
#numpy/core/_internal.pyiclass _ctypes:
def get_data
(self) -> int: ...
def get_shape (self) -> Any: ...
getdata in Listing 9 is a variable in internal.py ,
then declared as an explicit function getdata(self)in
internal.pyi. getshape is a similar case.
Category 6 (Typing Extension): Some stub ﬁles correspond
to extension ﬁles like ∗.pxd.∗.pxd works like C header ﬁles
and is provided by Cython, supporting writing C extensions
for Python language.
Listing 10: An example for Category 6
#numpy/__init__.pxd
ctypedef class numpy.flatiter [object
PyArrayIterObject, check_size ignore]:...
#numpy/__init__.pyiclass flatiter
(Generic[_NdArraySubClass]):...
In Listing 10, class flatiter with type annotations is deﬁned
in init .pyi while its declaration appears in init .pxd
instead of init .py.
Pattern Summary: Table VII summarizes the six patterns
detected in projects with stub ﬁles. First, Function Overloadingand Function-assigned V ariable are common practices adopted
by developers. The numbers of Baseclass Presentation, TypingCompatibility, and Typing Extension are smaller. API Visibil-ity is the most infrequent pattern. Second, projects in diversedomains present different number of patterns. For instance,SciPy and Numpy have the Typing Extension since theyintegrate with C/C++ extensions for scientiﬁc computation.
3) Answering RQ1: We ﬁgured out and categorized six
kinds of type practices that are non-trivial to conduct. Theytightly require recovering and expressing design decisions inlong-lasting codebase:
•Typing Compatability practice introduces new dependen-
cies into a codebase, due to new deﬁnitions for compat-ibility with older versions of typing module.
•Baseclass Presentation practice recovers and explicitly
expresses design rules, which are manifested as base-classes or protocols in type implementations.
•API Visibility practice makes some APIs directly visible
to the API dependents.
•Function Overloading practice reconstructs type seman-
tics for complex functions, unambiguously presentingreturn types based on different parameter types.
•Function-assigned V ariable practice makes implicit func-
tions explicit.
•Typing Extension practice connects code modules across
different programming languages in a software system.
Fig. 4: Using degree centrality to capture type-annotated ﬁles in Django
Fig. 5: Performance of degree centrality when capturing type-annotated ﬁles
535TABLE VII: The number of patterns detected in subjects with type stubs
ProjectTyping
CompatibilityAPIVisibility Baseclass Presentation FunctionOverloadingTypingExtensionFunction-assignedV ariable
New Baseclass New Protocol
Django 0 2 7 7 45 0 6
DRF 0 0 2 8 4 0 1
Elasticsearch 0 1 0 0 0 0 0
Matplotlib 0 0 2 0 0 0 0
Numpy 12 4 4 4 33 2 4
PySpark 0 0 0 0 115 0 73
Returns 0 0 1 0 0 0 0
Scipy 2 0 0 2 18 8 0
Werkzeug 0 0 0 0 18 0 56
Sum 14 7 16 21 233 10 140
B. RQ2: Characterizing Dependency Structure
This study explores whether type-annotated ﬁles present
different dependency structures when compared to ﬁles with-
out type annotations. Since Degree Centrality [25] and DRH
method [22], [23] have been widely used by prior work [25]–[27], we also employed them to observe software dependencystructure.
Degree centrality of a ﬁle is the fraction of ﬁles it connects
to. The higher value of the degree centrality, the more centralit is in the dependency structure. DRH, as aforementioned,
creates a hierarchical structure of a software system. Filesat the uppermost layers (L
0) are most inﬂuential since they
represent design rules of software architecture. We assume thattype-annotated ﬁles would dominate the ﬁle set with higherdegree centrality and dominate L
0layers in the hierarchical
structure.
1) Measures: We ﬁrst employed Networkx [28] to compute
degree centrality of ﬁles in the ADG built by Dependency
Structure Analysis of THProﬁler. We used P recision (P)and
Recall(R)to measure the ability of degree centrality when
capturing type-annotated ﬁles.
P=Ftyped∩Ftop
Ftop,R=Ftyped∩Ftop
Ftyped(1)
where Ftyped is a set of all type-annotated ﬁles in a project.
Ranking all ﬁles based on degree centrality measurements ina decreasing order, F
topis a set of top ﬁles such as top 10%,
top 20%, ..., and top 100%. Top 100% ﬁles include all ﬁlesin a project. We can obtain ten pairs of PandRresults from
top 10%, top 20%, ..., to top 100%. Based on them, we willobserve whether top ranking ﬁles with higher degree centralityare prone to be type-annotated.
Second, we employed Design Rule Hierarchy (DRH)
of THProﬁler to construct hierarchical structure based onthe ADG. We computed the proportion of type-annotatedﬁles at the layer L
0(i.e., Coverage (L0)) vs. other layers
(i.e., Coverage (LOthers)). If Coverage (L0)is bigger than
Coverage (LOthers), it would indicate that ﬁles, which are
manifested as software design rules, are prone to be type-annotated.
2) Results: Using Django as an example, Figure 4 il-
lustrates precision (P ) and recall (R ) results when usingtop10%,20%, ...,100% ﬁles ranked by degree centrality to
capture type-hinted ﬁles. The red-dotted line labeled with56.77% is the baseline precision, and the green-dotted line isthe baseline recall. Now we explain the baseline performance.The baseline denotes the performance when capturing type-annotated ﬁles by a random sample of project ﬁles. Consider-ing a random sample of 10% ﬁles, type-annotated ﬁles shouldtake 56.77% of this sample since 56.77% ﬁles (as listed inTable III) are type-annotated in Django. Because only 10%ﬁles of a project are randomly sampled, 10% type-annotatedﬁles should be captured statistically. We can observe that,the precision and recall results (at top 10%, top 20%, ...,and 100%) present consistent observations: the performanceof precision and recall based on degree centrality is biggerthan baseline performance.
Figure 5 shows the boxplots of precision and recall im-
provements when compared with baselines in all subjects.ΔP=P−P
baseline andΔR=R−Rbaseline . Due to the
page limitation, we only present performance improvementresults from top 10% (ΔP
10%,ΔR 10%), top 20% (ΔP 20%,
ΔR 20%), to top 30% (ΔP 30%,ΔR 30%). The boxplots indi-
cate that performance improvements of degree centrality arecommonly positive despite the existence of several outliers.On average, precision improvements are 14.80%, 11.40%, and9.18%; recall improvements are 11.73%, 12.79%, and 13.50%,respectively at top 10%, top 20%, and top 30%.
Figure 6 depicts the results of Coverage (L
0)
and Coverage (LOthers). We can observe that
13/19 projects exhibit consistent results withCoverage (L
0)> Coverage( LOther). Recall that ﬁles
in layer L0represent design rules of a software system. In
Django, 82.97% ﬁles are type-annotated at the uppermost layerL
0while 40.46% ﬁles are type-annotated at other layers. The
results indicate that ﬁles manifested as architectural designrules are more likely to be type-hinted than other ﬁles.
3) Answering RQ2: Our results indicate that type-annotated
ﬁles present different features in the software structure. Con-cretely, they have a higher value of degree centrality and theyreside at the uppermost layer in a hierarchical structure, hencemanifesting as design rules of a software system.
C. RQ3: Characterizing Maintenance Cost
This study investigates whether the maintenance cost
of type-annotated ﬁles differs from other ﬁles. Using
536Fig. 6: The proportion of type-annotated ﬁles at the uppermost layer (L 0) vs. other layers (L Others ) formed by the DRH
TABLE VIII: The performance of maintenance cost measures when capturing type-annotated ﬁles in Django project
Subject Top #author #commit #changeLoc #issue #issueCmt #issueLoc
(Coverage) PR PR PR PR PR PR
Django 10% 95.24 16.74 95.24 16.74 96.43 16.95 96.43 16.95 96.43 16.95 96.43 16.95
(56.77%) 20% 89.88 31.59 91.07 32.01 91.07 32.01 89.29 31.38 89.88 31.59 92.86 32.64
30% 89.29 47.07 89.68 47.28 88.89 46.86 84.52 44.56 88.89 46.86 87.70 46.23
Fig. 7: The performance of maintenance cost measures when capturing type-annotated ﬁles
the Maintenance Measurement of THProﬁler, we com-
puted#author ,#changeCmt, #changeLoc, #issue,
#issueCmt, #issueLoc for a source ﬁle. These measures
have been used by the work of [10], [24] to assess software
maintainability. The larger these measurements of a ﬁle, theheavier maintenance effort taken on it.
1) Measures: Similar to RQ2, we evaluated the precision
and recall when using top ﬁles ranked by maintenance costto capture type-hinted ﬁles. The precision measure, recallmeasure, and baseline values are same with those used inSection IV-B. If values of precision and recall are bigger thanthose of baseline, it would indicate that type-annotated ﬁlespresent a different feature in terms of maintenance cost.
2) Results: Table VIII lists evaluation results in Django.
56.77% ﬁles are type-annotated in total as shown in the ﬁrstcolumn. The (#author, P )column indicates that, among thetop 10% ﬁles with higher maintenance cost 95.24% ﬁles havetype annotations, greatly larger than the baseline precision(56.77%). As shown in (#author, R )column, type-annotated
ﬁles captured by top 10% measurements take 16.74% of alltyped ﬁles in Django, bigger than the baseline recall, i.e.,10%.
Figure 7 illustrates the boxplots of precision improvements
(ΔP ) and recall improvements (ΔR ) in all projects. The six
sub-ﬁgures correspond to the results of six maintainabilitymeasures. Similar to Section IV-B, we consider the top 10%,top 20%, and top 30% ﬁles ranked by maintenance costmeasurements.
From Figure 7, we can see that performance improvements
are positive when averaged on all 19 projects. The six sub-ﬁgures present consistent observations: using heavily main-tained ﬁles to capture type-annotated ﬁles, the precision valuesand recall values outperform the baseline performance. This
537observation indicates that ﬁles with greater maintenance costs
are more likely to be type-annotated in priority.
3) Answering RQ3: The results demonstrate the difference
of maintenance cost between type-annotated ﬁles and otherﬁles. This observation indicates that ﬁles difﬁcult to maintaincould be promising candidates to be type-annotated in priority.
V. P
OTENTIAL IMPACT
This section will discuss the possible impact of our ﬁndings
on type annotation practices, by citing developer discussionlists in notable Python projects, including Django [29], Numpy[30], and PySpark [31], which are studied in our work. Theyhave experienced type annotations for about four years, andtheir developers have been discussing type hint practices.
A. The Consideration of Design Concerns
Python developers have noticed the non-trivialness of type
annotation implementations. “Annotating the original code is
more than just adding annotations”, as discussed by Django
contributors. PySpark developers said that “some parts (of
type annotations) are close to trivial, other(s) are rather . ”Recent academic works by Ore et al. [7], [8] demonstrate thatannotating a single variable consumes about two minutes onaverage. However, it is still unknown about code-level patternsof non-trivial type annotations, which may guide beginnerssupplementing types more effectively.
Our results of RQ1 revealed six code patterns of non-
trivial type practices. First, these patterns demonstrate thedifﬁculty to include automated approaches for handling typeannotations, since type annotation of a code entity sometimesrequires introducing additional entities. Second, these patternshighlight that such non-trivial type practices deeply involveretrospecting, recovering, and expressing the design and cod-ing decisions originally made in the codebase development.
We suggest that type practitioners should take design
concerns [32]–[35] into account. For example, when type-annotating a group of classes that provide similar behaviorsbut do not explicitly extend a base-class, we advice thattheir common interfaces should be extracted as additionaldeﬁnitions to manifest design rules, as inspired by Baseclass
presentation practice (Listing 7). Learning from Function
Overloading practice (Listing 8), we recommend overloading
the functions that have complex logic due to type diversity ofparameters and returns.
B. Candidate Module Recommendation for Type Annotations
Python developers have struggled with which part of code
should be type-annotated ﬁrst. PySpark developers stated,
“It should be decided if annotations should cover only thepublic API, or internals as well.” Django developers con-sidered, “Partial type hinting is useful and viable, but not
randomly. ” Developers agreed that they should “trade-off
between completeness (of the typing coverage) and the costof maintenance (of type annotations). ” At the same time, they
complained about the lack of such guidance–“missing high
Fig. 8: The V enn diagram of project sets captured by three features
level guidance”, calling for “a type theory for beginners, both
in Python and more generally”.
Our ﬁndings in RQ2 and RQ3 shed a light on which portion
of modules (i.e., Python ﬁles) could be type-annotated inpriority. We revealed three features of the type-annotated ﬁles,i.e., they present a bigger value of degree centrality, theyare located at the uppermost layer in a hierarchical structure,and they incur a higher maintenance cost. These features arecomplementary to each other, as visualized in Figure 8. Among19 subjects in our study, degree centrality can effectivelycapture type-annotated ﬁles in
1+2+2+8
19=13
19projects; the
proportion is13
19for the hierarchical layer, and the proportion
is14
19for maintenance cost.
For a long-lasting large-scale project, migrating from an
un-annotated codebase to type-annotated one is a gradual andexpensive process. Our ﬁndings imply that Python modulespresenting three features could be type-annotated ﬁrst fora trade-off between the typing coverage and maintenanceefforts taken on type annotations. We believe our ﬁndingsand tools would beneﬁt the projects and developers that planto experience modern type hint practices. Our study is apreliminary trial at the ﬁle level, which will be continued at aﬁner-grained level like APIs or functions.
VI. T
HREA TS TO VALIDITY
First, subject collection is non-trivial. To reduce the bias to
our study, we followed the collection criteria to select projectswith diverse type-hint manners, domains, and sizes, as shownin Section III-A. We will collect more projects for our studyin the future.
Second, we manually categorized six patterns in non-trivial
type-annotation practices. One threat is that the categories maybe insufﬁcient to cover all non-trivial practices. To mitigatethis threat, we will continue mining more usable patterns.
Third, different techniques may produce inconsistent ob-
servations. To reduce this threat, our study employed well-accepted tools, techniques, and measures. Concretely, we usedUnderstand to extract code dependencies, which is suggestedby the industry [36]–[39]. We applied the DRH technique [35],[40], [41] to cluster ﬁles hierarchically. Our research employedsix maintainability measures [10], [24]. Besides, as shown inFigure 8, the revealed three features are complementary tocapture all subjects. One possible reason is that developers indifferent projects may have different typing decisions. We willanalyze them in next work.
538Finally, our study of RQ2 and RQ3 reveals the correlation
between three features and type-proneness of a source ﬁle,
but not the causality. We neither claim how the three featurescause a ﬁle to be type-annotated, nor the vice versa. Exploringthe causality will be our next work.
VII. R
ELA TED WORK
A. Static Typing Systems vs. Dynamic Typing Systems
Much prior work has demonstrated that static typing sys-
tems beneﬁt bug detection and software maintenance. Klein-schmager et al. [42] assigned developers with a set of pro-gramming tasks, and found that static typing systems cancapture type-related errors without program executions. Spizaet al. [43] supported that developers already beneﬁt from typesemantics of APIs even without static type checking. Gao etal. [44] manually added annotations to buggy code written inJavaScript and tested whether static typing systems can capturethe error on buggy code. Their experiments reported thatthe static typing systems, Flow [45] and TypeScript [2], cansuccessfully detect a portion of public bugs in revision history.Daly et al. [46] compared Ruby with DRuby, an extension toRuby with static typing. Their work indicated that DRuby failsin capturing complex errors. Besides discussing the beneﬁts,the work of [47]–[49] concluded that developers who usedynamic languages tend to switch between different ﬁles morefrequently than developers who use static languages. As shownin their results, the frequent search for different ﬁles inﬂuencesthe efﬁciency of development and maintenance activities.
These studies evaluated the beneﬁts and disadvantages of
the usage of static typing feature in dynamically typed lan-guages. Unlike them, our work ﬁgured out patterns of non-trivial type annotation implementations and features of type-annotated ﬁles.
B. Empirical Study of Type Annotation Practices
Existing work investigated the type annotation usage in
development activities. Souza et al. [50] conducted several
hypothesis tests to investigate type usage in Groovy language.This work presented that test classes and script ﬁles usetypes less frequently than other ﬁles. Another interestingﬁnding is that programmers, who often develop code in an“untyped” language, tend to declare types less often. Groovyis an object-oriented programming language for Java platform.Quite different from Groovy, Python is dynamically typed innature, thus perhaps leading to different observations. Ore etal. [7] studied 71 programmers using 20 code artifacts inthe cyber-physical domain. They assessed the time cost oftype annotation supplementation, showing that it takes morethan two minutes to annotate a single variable accurately.The considerable time cost demonstrated the complexity anddifﬁculty for developers to assign types to variables. Byextending this study [7], a recent work [8] further pointedthat developers reason about variable types primarily basedon names and operations of identiﬁers, which points out adirection to improve automated type annotation systems.Similar to those work, we also studied type annotation prac-
tices but presented an evidence that type-annotated ﬁles arecritical to understanding and maintaining software architectureby revealing three complementary features.
C. Static Type Inference in Dynamic Languages
Static type inference determines the types of program ex-
pressions statically without a need to run programs. Early type
inference methods such as [51], [52] formalize the type infer-ence problem as the type constraint resolution. The methodin [51] ﬁrst creates a trace graph, from which a set of typeconstraints are extracted. At last, it computes the least solutionof the set of type constraints by least ﬁxed-point derivation.Milojkovic et al. [53], [54] leveraged heuristics such as namingconvention to enhance type inference. Recent type inferencemethods employ machine learning or deep learning techniques.JSNice [55] learns a probabilistic model to predict variablenames and variable types for Javascript. DeepTyper [56], [57]transforms the type inference problem into a translation modelfrom a un-annotated code to annotated code. DLTPy [58] is adeep learning type inference solution. It predicts the types infunction signatures based on identiﬁer names, comments andreturn expressions of a function. The work of [59] exploredhow type inference techniques designed for static languagewill perform on dynamic languages.
Automated type inference approaches can assist type anno-
tation implementation. Our work also promotes type annota-tion practices but in a different view. We recommended thatsuch practices should consider architectural concerns due tothe existence of non-trivial type annotation implementations.
VIII. C
ONCLUSION
Our work is the ﬁrst to detect non-trivial type annotation
practices and reveal possible features of type-annotated ﬁles,to the best of our knowledge. We found six type annota-tion patterns that involve recovering and expressing designconcerns made in original codebase development. We alsoshowed that the ﬁles, characterized by three complementaryfeatures (i.e., presenting higher degree centrality, residing atthe uppermost layer of a hierarchical structure, and incurringhigher maintenance cost), are prone to be type-hinted.
More projects in dynamic languages are trying to embrace
optional typing practice, however, still lacking guidance. Dur-ing a gradual and expensive process of type-annotating a code-base, we suggest considering the revealed patterns with designconcerns and candidate type-annotated ﬁle recommendations.A consideration of them would promote a better practice ofoptional typing.
A
CKNOWLEDGMENT
This work was supported by National Key R&D Program
of China (2018YFB1004500), National Natural Science Foun-dation of China (62002280, 61632015, 61772408, U1766215,61721002, 61833015,61902306), China Postdoctoral ScienceFoundation (2020M683507, 2019TQ0251, 2020M673439),and Y outh Talent Support Plan of Xi’an Association forScience and Technology (095920201303).
539REFERENCES
[1] J. G. Siek and W. Taha, “Gradual typing for functional languages,” in
INSCHEME AND FUNCTIONAL PROGRAMMING WORKSHOP.
ACM, 2006, pp. 81–92.
[2] TypeScript, “https://www.typescriptlang.org/,” 2012–2021.
[3] Ruby, “https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-
released/,” 2020–2021.
[4] ——, “https://github.com/ruby/rbs,” 2020–2021.[5] M. Allamanis, E. T. Barr, S. Ducousso, and Z. Gao, “Typilus: Neural
type hints,” in
Proceedings ofthe 41st ACM SIGPLAN Conference on
Programming Language Design and Implementation, ser. PLDI 2020.
New Y ork, NY , USA: Association for Computing Machinery, 2020, p.
91–105. [Online]. Available: https://doi.org/10.1145/3385412.3385997
[6] R. Chatley, A. Donaldson, and A. Mycroft, The Next 7000 Programming
Languages. Computing and Software Science, 2019.
[7] J.-P . Ore, S. Elbaum, C. Detweiler, and L. Karkazis, “Assessing the type
annotation burden,” in Proceedings ofthe33rd ACM/IEEE International
Conference onAutomated Software Engineering, 2018, pp. 190–201.
[8] J.-P . Ore, C. Detweiler, and S. Elbaum, “An empirical study on
type annotations: Accuracy, speed, and suggestion effectiveness,” ACM
Transactions on Software Engineering and Methodology (TOSEM),
vol. 30, no. 2, pp. 1–29, 2021.
[9] Spark, “Re: [pyspark] revisiting pyspark type annotations,” –2021.
[10] W. Jin, Y . Cai, R. Kazman, G. Zhang, Q. Zheng, and T. Liu, “Exploring
the architectural impact of possible dependencies in python software,” in
2020 35th IEEE/ACM International Conference onAutomated Software
Engineering (ASE). IEEE, 2020, pp. 758–770.
[11] R. Mo, Y . Cai, R. Kazman, and L. Xiao, “Hotspot patterns: The formal
deﬁnition and automatic detection of architecture smells,” in 2015 12th
Working IEEE/IFIP Conference onSoftware Architecture. IEEE, 2015,
pp. 51–60.
[12] Python, “https://www.python.org/dev/peps/pep-0484/,” –.
[13] W. Jin, D. Zhong, Z. Ding, M. Fan, and T. Liu,
“https://github.com/xjtucoderesearch/dataset typehintpractice,” 2021–
2021.
[14] Python, “http://mypy-lang.org/,” 2014–2021.[15] Google, “https://google.github.io/pytype/,” 2015–2021.[16] Python, “https://www.python.org/dev/peps/pep-0484/#function-method-
overloading,” 2015–2021.
[17] ——, “https://www.python.org/dev/peps/pep-0544/,” –.[18] P . docs, “https://docs.python.org/3/glossary.html#term-duck-typing,”
2001-2020.
[19] C. Y . Baldwin and K. B. Clark,
Design rules: The power ofmodularity.
MIT press, 2000, vol. 1.
[20] S. Understand, “https://scitools.com/,” 1996-2020.[21] W. Jin, Y . Cai, R. Kazman, Q. Zheng, D. Cui, and T. Liu, “Enre: a tool
framework for extensible entity relation extraction,” in
Proceedings of
the41st International Conference onSoftware Engineering: Companion
Proceedings. IEEE Press, 2019, pp. 67–70.
[22] S. Wong, Y . Cai, G. V aletto, G. Simeonov, and K. Sethi, “De-
sign rule hierarchies and parallelism in software development tasks,”
inProceedings ofthe 2009 IEEE/ACM International Conference on
Automated Software Engineering. IEEE Computer Society, 2009, pp.
197–208.
[23] L. Xiao, Y . Cai, and R. Kazman, “Design rule spaces: A new form of
architecture insight,” in Proceedings ofthe36th International Conference
onSoftware Engineering. ACM, 2014, pp. 967–977.
[24] R. Mo, Y . Cai, R. Kazman, L. Xiao, and Q. Feng, “Decoupling level:
a new metric for architectural maintenance complexity,” in Proceedings
ofthe 38th International Conference onSoftware Engineering. IEEE,
2016, pp. 499–510.
[25] C. R. Myers, “Software systems as complex networks: Structure, func-
tion, and evolvability of software collaboration graphs,” Physical Review
E, vol. 68, no. 4, p. 046116, 2003.
[26] M. Harman, D. Binkley, K. Gallagher, N. Gold, and J. Krinke, “De-
pendence clusters in source code,” ACM Transactions onProgramming
Languages and Systems (TOPLAS), vol. 32, no. 1, pp. 1–33, 2009.
[27] P . Bhattacharya, M. Iliofotou, I. Neamtiu, and M. Faloutsos, “Graph-
based analysis and prediction for software evolution,” in 2012 34th
International Conference onSoftware Engineering (ICSE). IEEE, 2012,
pp. 419–429.
[28] Networkx, “https://networkx.org/,” –.[29] Django, “http://python.6.x6.nabble.com/django-developers-
f455249.html,” –2021.
[30] Numpy, “http://numpy-discussion.10968.n7.nabble.com,” –2021.
[31] Spark, “http://apache-spark-developers-list.1001551.n3.nabble.com,” –
2021.
[32] L. Bass, P . Clements, and R. Kazman, Software architecture inpractice.
Addison-Wesley Professional, 2003.
[33] J. Garcia, D. Popescu, C. Mattmann, N. Medvidovic, and Y . Cai, “En-
hancing architectural recovery using concerns,” in 2011 26th IEEE/ACM
International Conference onAutomated Software Engineering (ASE
2011). IEEE, 2011, pp. 552–555.
[34] J. Garcia, I. Ivkovic, and N. Medvidovic, “A comparative analy-
sis of software architecture recovery techniques,” in Proceedings of
28th IEEE/ACM International Conference on Automated Software
Engineering. IEEE, 2013, pp. 486–496.
[35] Y . Cai, L. Xiao, R. Kazman, R. Mo, and Q. Feng, “Design rule spaces: a
new model for representing and analyzing software architecture,” IEEE
Transactions onSoftware Engineering, 2018.
[36] Lattix, “https://www.sdcsystems.com/tools/lattix-software/lattix-
architect/,” 2004-2020.
[37] Structure101, “https://structure101.com/,” 2004-2020.[38] R. Mo, W. Snipes, Y . Cai, S. Ramaswamy, R. Kazman, and M. Naedele,
“Experiences applying automated architecture analysis tool suites,”
in
Proceedings ofthe 33rd ACM/IEEE International Conference on
Automated Software Engineering. ACM, 2018, pp. 779–789.
[39] ArchDia, “https://archdia.com,” 2004-2020.
[40] R. Mo, Y . Cai, R. Kazman, L. Xiao, and Q. Feng, “Architecture anti-
patterns: Automatically detectable violations of design principles,” IEEE
Transactions onSoftware Engineering, pp. 1–1, 2019.
[41] D. Cui, T. Liu, Y . Cai, Q. Zheng, Q. Feng, W. Jin, J. Guo, and Y . Qu,
“Investigating the impact of multiple dependency structures on software
defects,” in Software Engineering, 2019. ICSE 2019. Proceedings. 41th
International Conference on. IEEE, 2019, pp. –.
[42] S. Kleinschmager, R. Robbes, A. Steﬁk, S. Hanenberg, and E. Tanter,
“Do static type systems improve the maintainability of software systems?an empirical study,” in
2012 20th IEEE International Conference on
Program Comprehension (ICPC). IEEE, 2012, pp. 153–162.
[43] S. Spiza and S. Hanenberg, “Type names without static type checking
already improve the usability of apis (as long as the type names arecorrect) an empirical study,” in
Proceedings ofthe 13th international
conference onModularity, 2014, pp. 99–108.
[44] Z. Gao, C. Bird, and E. T. Barr, “To type or not to type: quantifying
detectable bugs in javascript,” in 2017 IEEE/ACM 39th International
Conference onSoftware Engineering (ICSE). IEEE, 2017, pp. 758–
769.
[45] Flow, “https://ﬂow.org/,” 2014–2021.
[46] M. T. Daly, V . Sazawal, and J. S. Foster, “Work in progress: an empirical
study of static typing in ruby,” 2009.
[47] A. Stuchlik and S. Hanenberg, “Static vs. dynamic type systems: An em-
pirical study about the relationship between type casts and development
time,” in Proceedings ofthe 7th symposium onDynamic languages,
2011, pp. 97–106.
[48] C. Mayer, S. Hanenberg, R. Robbes, ´E. Tanter, and A. Steﬁk, “An
empirical study of the inﬂuence of static type systems on the usabilityof undocumented software,”
ACM SIGPLAN Notices, vol. 47, no. 10,
pp. 683–702, 2012.
[49] S. Hanenberg, S. Kleinschmager, R. Robbes, ´E. Tanter, and A. Steﬁk,
“An empirical study on the impact of static typing on software maintain-ability,”
Empirical Software Engineering, vol. 19, no. 5, pp. 1335–1382,
2014.
[50] C. Souza and E. Figueiredo, “How do programmers use optional typing?
an empirical study,” in Proceedings ofthe13th international conference
onModularity, 2014, pp. 109–120.
[51] J. Palsberg, “Object-oriented type inference,” in Proc. OOPSLA ’91,
1991, pp. 146–161.
[52] J. O. Graver and R. E. Johnson, “A type system for smalltalk,” in
Proceedings ofthe 17th ACM SIGPLAN-SIGACT Symposium on
Principles ofProgramming Languages, ser. POPL ’90. New Y ork,
NY , USA: Association for Computing Machinery, 1989, p. 136–150.[Online]. Available: https://doi.org/10.1145/96709.96722
[53] N. Milojkovi ´c, C. B ´era, M. Ghafari, and O. Nierstrasz, “Inferring types
by mining class usage frequency from inline caches,” in
Proceedings
ofthe 11th edition ofthe International Workshop on Smalltalk
Technologies, 2016, pp. 1–11.
540[54] N. Milojkovi ´c, “Improving the precision of type inference algorithms
with lightweight heuristics,” 2017.
[55] V . Raychev, M. V echev, and A. Krause, “Predicting program properties
from” big code”,” ACM SIGPLAN Notices, vol. 50, no. 1, pp. 111–124,
2015.
[56] V . J. Hellendoorn, C. Bird, E. T. Barr, and M. Allamanis, “Deep learning
type inference,” in Proceedings ofthe 2018 26th acm joint meeting
oneuropean software engineering conference and symposium onthe
foundations ofsoftware engineering, 2018, pp. 152–162.
[57] R. S. Malik, J. Patra, and M. Pradel, “Nl2type: inferring javascript
function types from natural language information,” in Proceedings ofthe
41st International Conference onSoftware Engineering. IEEE Press,
2019, pp. 304–315.
[58] C. Boone, N. de Bruin, A. Langerak, and F. Stelmach, “Dltpy: Deep
learning type inference of python function signatures using natural
language context,” arXiv preprint arXiv:1912.00680, 2019.
[59] C. M. Khaled Saifullah, M. Asaduzzaman, and C. K. Roy, “Exploring
type inference techniques of dynamically typed languages,” in 2020
IEEE 27th International Conference onSoftware Analysis, Evolution
and Reengineering (SANER), 2020, pp. 70–80.
541