GenTree: Using Decision Trees to Learn
Interactions for ConÔ¨Ågurable Software
KimHao Nguyen and ThanhVu Nguyen
University of Nebraska-Lincoln, USA
fkdnguyen,tnguyeng@cse.unl.edu
Abstract ‚ÄîModern software systems are increasingly designed
to be highly conÔ¨Ågurable, which increases Ô¨Çexibility but can
make programs harder to develop, test, and analyze, e.g., how
conÔ¨Åguration options are set to reach certain locations, what
characterizes the conÔ¨Åguration space of an interesting or buggy
program behavior? We introduce GenTree, a new dynamic
analysis that automatically learns a program‚Äôs interactions‚Äî
logical formulae that describe how conÔ¨Åguration option settings
map to code coverage. GenTree uses an iterative reÔ¨Ånement
approach that runs the program under a small sample of
conÔ¨Ågurations to obtain coverage data; uses a custom classifying
algorithm on these data to build decision trees representing
interaction candidates; and then analyzes the trees to generate
new conÔ¨Ågurations to further reÔ¨Åne the trees and interactions in
the next iteration. Our experiments on 17 conÔ¨Ågurable systems
spanning 4 languages show that GenTree efÔ¨Åciently Ô¨Ånds precise
interactions using a tiny fraction of the conÔ¨Åguration space.
I. I NTRODUCTION
Modern software systems are increasingly designed to be
conÔ¨Ågurable. This has many beneÔ¨Åts, but also signiÔ¨Åcantly
complicates tasks such as testing, debugging, and analysis
due to the number of conÔ¨Ågurations that can be exponentially
large‚Äîin the worst case, every combination of option settings
can lead to a distinct behavior. This software conÔ¨Åguration
space explosion presents real challenges to software develop-
ers. It makes testing and debugging more difÔ¨Åcult as faults are
often visible under only speciÔ¨Åc combinations of conÔ¨Åguration
options. It also causes a challenge to static analyses because
conÔ¨Ågurable systems often have huge conÔ¨Åguration spaces and
use libraries and native code that are difÔ¨Åcult to reason about.
Existing works on highly-conÔ¨Ågurable systems [1]‚Äì[4]
showed that we can automatically Ô¨Ånd interactions to con-
cisely describe the conÔ¨Åguration space of the system. These
works focus on program coverage (but can be generalized to
arbitrary program behaviors) and deÔ¨Åne an interaction for a
location as a logically weakest formula over conÔ¨Åguration
options such that any conÔ¨Åguration satisfying that formula
would cover that location. These works showed that inter-
actions are useful to understand the conÔ¨Ågurations of the
system, e.g., determine what conÔ¨Åguration settings cover a
given location; determine what locations a given interaction
covers; Ô¨Ånd important options, and compute a minimal set of
conÔ¨Ågurations to achieve certain coverage; etc. In the software
production line community, feature interactions and presence
conditions (¬ßVII) are similar to interactions and has led to
many automated conÔ¨Åguration-aware testing techniques todebug functional (e.g., bug triggers, memory leaks) and non-
functional (e.g., performance anomalies, power consumption)
behaviors. Interactions also help reverse engineering and im-
pact analysis [5], [6], and even in the bioinformatics systems
for aligning and analyzing DNA sequences [7].
These interaction techniques are promising, but have several
limitations. The symbolic execution work in [1] does not scale
to large systems, even when being restricted to conÔ¨Åguration
options with a small number of values (e.g., boolean); needs
user-supplied models (mocks) to represent libraries, frame-
works, and native code; and is language-speciÔ¨Åc (C programs).
iTree [2], [3] uses decision trees to generate conÔ¨Ågurations
to maximize coverage, but achieves very few and imprecise
interactions. Both of these works only focus on interactions
that can be represented as purely conjunctive formulae.
The iGen interaction work [4] adopts the iterative reÔ¨Ånement
approach often used to Ô¨Ånd program preconditions and invari-
ants (e.g., [8]‚Äì[11]). This approach learns candidate invariants
from program execution traces and uses an oracle (e.g., a
static checker) to check the candidates. When the candidate
invariants are incorrect, the oracle returns counterexample
traces that the dynamic inference engine can use to infer
more accurate invariants. iGen adapts this iterative algorithm
to Ô¨Ånding interactions, but avoids static checking, which
has limitations similar to symbolic execution as mentioned
above. Instead, iGen modiÔ¨Åes certain parts of the candidate
interaction to generate new conÔ¨Ågurations and run them to test
the candidate. ConÔ¨Ågurations that ‚Äúbreak‚Äù the interaction are
counterexamples used to improve that interaction in the next
iteration. However, to effectively test interactions and generate
counterexample conÔ¨Ågurations, iGen is restricted to learning
interactions under speciÔ¨Åc forms (purely conjunctive, purely
disjunctive, and speciÔ¨Åc mixtures of the two) and thus cannot
capture complex interactions in real-world systems (¬ßVI).
In this paper, we introduce GenTree, a new dynamic
interaction inference technique inspired by the iterative in-
variant reÔ¨Ånement algorithm and iGen. Figure 1 gives an
overview of GenTree. First, GenTree creates an initial set
of conÔ¨Ågurations and runs the program to obtain (location)
coverage. Then for each covered location l,GenTree builds
a decision tree, which represents a candidate interaction, from
the conÔ¨Ågurations that do and do not cover l.
Because GenTree works with just a sample of all conÔ¨Åg-
urations, the decision trees representing candidate interactions
may be imprecise. To reÔ¨Åne these trees, GenTree analyzes
15982021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00142
Program and TestsuiteConÔ¨Ågs
FinalInteractionsNo1-waycovering arrayNew Trees ?postprocessingCoverageclassiÔ¨Åerrun programYesgen new conÔ¨ÅgsFig. 1: GenTree overview// 9 conÔ¨Åguration options:
//s;t;u;v (bool);a;b;c;d;e2f0;1;2g
printf ( "L0nn");//True
if(a1_b2)f
printf ( "L1nn");//a1_b2
g
else if (c0^d1)f
//a2f0;2g^b2f0;1g^c0^d1
printf ( "L2nn");
g
if(u^v)f
printf ( "L3nn");//u^v
return ;
g
elsef
printf ( "L4nn");//u_vif(s^e2)f
//s^e2^(u_v)
printf ( "L5nn");
return ;
g
g
//(s_e2f0;1g)^(u_v)
printf ( "L6nn");
if(e2)f
//s^e2^(u_v)
printf ( "L7nn");
if(u_v)f
//s^e2^((u^v)_(u^v))
printf ( "L8nn");
g
g
Fig. 2: A program having nine locations L0{L8annotated with interactions
them to generate new conÔ¨Ågurations. In the next iteration,
these conÔ¨Ågurations may provide the necessary data to inval-
idate the current trees (i.e., counterexamples) and build more
precise trees, which correspond to better interactions. This
process continues until we obtain no new coverage or trees
for several consecutive iterations, at which point GenTree
returns the Ô¨Ånal set of interactions.
The design of GenTree helps mitigate several limitations
of existing works. By using dynamic analysis, GenTree is
language agnostic and supports complex programs (e.g., those
using third party libraries) that might be difÔ¨Åcult for static
analyses. By considering only small conÔ¨Åguration samples,
GenTree is efÔ¨Åcient and scales well to large programs. By in-
tegrating with iterative reÔ¨Ånement, GenTree generates small
sets of useful conÔ¨Ågurations to gradually improve its results.
By using decision trees, GenTree supports expressive inter-
actions representing arbitrary boolean formulae and allows for
generating effective counterexample conÔ¨Ågurations. Finally, by
using a classiÔ¨Åcation algorithm customized for interactions,
GenTree can build trees from small data samples to represent
accurate interactions.
We evaluated GenTree on 17 programs in C, Python, Perl,
and OCaml having conÔ¨Åguration spaces containing 1024 to
3:51014conÔ¨Ågurations. We found that interaction results
from GenTree are precise, i.e., similar to what GenTree
would produce if it inferred interactions from all possible
conÔ¨Ågurations. We also found that GenTree scales well
to programs with many options because it only explores a
small fraction of the large conÔ¨Åguration spaces. We examined
GenTree ‚Äôs results and found that they conÔ¨Årmed several
observations made by prior work (e.g., conjunctive interactions
are common but disjunctive and mixed interactions are still
important for coverage; and enabling options, which must
be set in a certain way to cover most locations, are com-
mon). We also observed that complex interactions supported
byGenTree but not from prior works cover a non-trivial
number of locations and are critical to understand the programbehaviors at these locations.
In summary, this paper makes the following contributions:
(i) we introduce a new iterative reÔ¨Ånement algorithm that uses
decision trees to represent and reÔ¨Åne program interactions; (ii)
we present a decision tree classiÔ¨Åcation algorithm optimized
for interaction discovery; (iii) we implement these ideas in the
GenTree tool and make it freely available; and (iv) we eval-
uateGenTree on programs written in various languages and
analyze its results to Ô¨Ånd interesting conÔ¨Åguration properties.
GenTree and all benchmark data are available at [12].
II. I LLUSTRATION
We use the C program in Figure 2 to explain GenTree .
This program has nine conÔ¨Åguration options listed on the
Ô¨Årst line of the Ô¨Ågure. The four options s;t;u;v are boolean-
valued, and the other Ô¨Åve options, a;b;c;d;e , range over the
setf0;1;2g. The conÔ¨Åguration space of this program thus has
2435= 3888 possible conÔ¨Ågurations.
The code in Figure 2 includes print statements that mark
nine locations L0‚ÄìL8. At each location, we list the associated
desired interaction. For example, L5is covered by any con-
Ô¨Åguration in which sistrue ,eis 2, and either uorvis
false.L0is covered by every conÔ¨Åguration (i.e., having the
interaction true), butL6isnotcovered by every conÔ¨Åguration
because the program returns when it reaches L3orL5.
Prior interaction inference approaches are not sufÔ¨Åcient for
this example. The works of Reisner et. al [1] and iTree [2], [3]
only support conjunctions and therefore cannot generate the
correct interactions for any locations except L0,L2, andL3.
The iGen tool [4], which supports conjunctions, disjunctions,
and a limited form of both conjunctions and disjunctions, also
cannot generate the interactions for locations L6andL8.
Initial ConÔ¨Ågurations: GenTree Ô¨Årst creates a random
1-way covering array [13], [14] to obtain a set of initial
conÔ¨Ågurations, which contains all possible settings of each
individual option. Figure 3 shows the initial conÔ¨Ågurations
and their coverage information for the running example.
1599conÔ¨Åg s t u v a b c d e cov(L)
c1 1 1 0 0 0 1 2 1 0 0;4;6
c2 0 1 1 0 2 0 0 2 2 0;4;6;7;8
c3 1 0 1 1 1 2 1 0 1 0;1;3
sh (a) 1 m (b) 2 01
Fig. 3: Initial conÔ¨Ågurations using 1-way covering array and the decision tree for L8built from these conÔ¨Ågurations. The label
at the leaf, e.g., h (a) 1, indicates the classiÔ¨Åcation (hit or miss) of the path from the root to this leaf, the (name) of the path,
and the number of conÔ¨Ågurations used for this classiÔ¨Åcation
conÔ¨Åg s t u v a b c d e cov(L)
c4 0 1 1 1 1 1 0 1 0 0;1;3
c5 0 0 0 0 0 2 2 0 1 0;1;4;6
c6 0 1 0 0 2 0 1 2 2 0;4;6;7
c7 0 1 0 1 0 0 1 2 2 0;4;6;7;8
uem (a) 2m (b) 2m (c) 1vh (d) 1h (e) 12101001
Fig. 4: New conÔ¨Ågurations created from path (a) in the tree in Figure 3 (counterexamples are underlined ) and new decision
tree forL8.
conÔ¨Åg s t u v a b c d e cov(L) path in Fig. 4
c8 0 0 0 0 0 0 2 2 2 0;4;6;7 c
c9 1 1 0 0 2 1 1 0 2 0;4;5 c
c10 1 0 0 0 1 2 0 1 2 0;1;4;5 c
c11 0 0 0 1 2 2 1 0 2 0;1;4;6;7;8 d
c12 0 0 0 1 1 0 2 1 2 0;1;4;6;7;8 d
c13 1 1 0 1 0 1 0 2 2 0;4;5 d
c14 0 1 1 1 1 2 1 0 2 0;1;3 e
c15 1 0 1 0 0 0 2 1 2 0;4;5 e
c16 1 0 1 0 2 1 0 2 2 0;4;5 e
vem (a) 1m (b) 1m (c) 2uh (d) 1sm (g) 7
h (e) 3um (f) 101012010101
Fig. 5: New conÔ¨Ågurations created from paths (c), (d), (e) in the tree in Figure 4 and new decision tree for L8.
Decision Trees: For each covered location l,GenTree
uses a classiÔ¨Åcation algorithm called C5 i, developed speciÔ¨Å-
cally for this work, (¬ßIV-B) to build a decision tree represent-
ing the interaction for l. To build the tree for l, C5 iuses two
sets of data: the hitsets consisting of conÔ¨Ågurations covering
land the miss set consisting of conÔ¨Ågurations not covering
l. For example, for L8,GenTree builds the decision tree in
Figure 3 from the hit sets fc2gand the miss setfc1;c3g.
From the given conÔ¨Ågurations C5 idetermines that the
coverage of L8just requires option sbeing 0 ( false ). Thus,
the interaction for L8, represented by the condition of the
hitpath (a) of the tree in Figure 3, is s. This interaction
is quite different than s^e2^((u^v)_(u^v)), the
desired interaction for L8. However, even with only three
initial conÔ¨Ågurations, the tree is partially correct because
conÔ¨Ågurations having sas true would miss L8andsbeing
false is part of the requirements for hitting L8.
New ConÔ¨Ågurations: GenTree now attempts to create
new conÔ¨Ågurations to reÔ¨Åne the tree representing the inter-
action for location l. Observe that if a hit path is precise,
then any conÔ¨Åguration satisfying its condition would cover l(similarly, any conÔ¨Åguration satisfying the condition of a miss
path would not cover l). Thus, we can validate a path by gener-
ating conÔ¨Ågurations satisfying its condition and checking their
coverage. ConÔ¨Ågurations generated from a hit (or miss) path
that do not (or do) cover larecounterexample conÔ¨Ågurations,
which show the imprecision of the path condition and help
build a more precise tree in the next iteration.
In the running example, GenTree selects the condition s
of the hit path (a) of the tree shown in Figure 3 and generates
four new conÔ¨Ågurations shown in Figure 4 with s= 0 and
1-covering values for the other eight variables. If path (a) is
precise, then these conÔ¨Ågurations would cover L8. However,
only conÔ¨Åguration c7coversL8. Thus,c4;c5;c6, which do
not coverL8, are counterexamples showing that path (a) is
imprecise and thus sis not the correct interaction for L8.
Note that we could also generate new conÔ¨Ågurations using
path (b), which represents the interaction for notcoveringL8.
However, GenTree prefers path (a) because the classiÔ¨Åer
uses one conÔ¨Åguration for path (a) and two for path (b),
i.e., the condition sfor covering lis only supported by one
conÔ¨Åguration and thus is likely more imprecise.
1600Next Iterations: GenTree now repeats the process of
building trees and generating new conÔ¨Ågurations. Continuing
with our example on Ô¨Ånding the interaction for L8,GenTree
addsc7to the hit set and c4;c5;c6to the miss set and builds
the new tree for L8in Figure 4. The combination of the hit
paths (d) and (e) gives e2^(u_(u^v))as the interaction
forL8. This interaction contains options e;u;v , which appear
in the desired interaction s^e2^((u^v)_(u^v)).
To validate the new interaction for L8,GenTree generates
new conÔ¨Ågurations from paths (c), (d), (e) of the tree in
Figure 4, because they have the fewest number of supporting
conÔ¨Ågurations. Figure 5 shows the nine new conÔ¨Ågurations.
Note that (c) is a miss path and thus c8;c9;c10arenot
counterexamples because they do not hit L8. Also, in an actual
run,GenTree would select only one of these three paths and
take two additional iterations to obtain these conÔ¨Ågurations.
For illustration purposes, we combine these iterations and
show the generated conÔ¨Ågurations all together.
In the next iteration, using the new conÔ¨Ågurations and the
previous ones, GenTree builds the decision tree in Figure 5
forL8. The interaction obtained from the two hit paths (d) and
(e) is s^e2^((v^u)_(v^u)), which is equivalent to
the desired one and thus would remain unchanged regardless
of any additional conÔ¨Ågurations GenTree might create.
Finally, GenTree stops when it cannot generate new cov-
erage or reÔ¨Åne existing trees for several consecutive iterations.
In a postprocessing step, GenTree combines the hit path
conditions of the decision tree for each location linto a logical
formula representing the interaction for l.
Complete Run: GenTree found the correct interactions
for all locations in the running example within eight iterations
and under a second. The table below shows the number of
iterations and conÔ¨Ågurations used to Ô¨Ånd the interaction for
each location. For example, the desired interaction for L8
took 58 conÔ¨Ågurations and is discovered at iteration 4, and
the interaction true of L0 was quickly discovered from the
initial conÔ¨Ågurations.
L0 L1 L2 L3 L4 L5 L6 L7 L8
Iter. Found 1 2 6 1 2 5 3 3 4
# ConÔ¨Ågs 3 27 144 15 30 123 50 47 58
Overall, GenTree found all of these interactions by analyz-
ing approximately 360 conÔ¨Ågurations (median over 11 runs)
out of 3888 possible ones. The experiments in ¬ßVI show that
GenTree analyzes an even smaller fraction of the possible
conÔ¨Ågurations on programs with larger conÔ¨Åguration spaces.
III. P RELIMINARIES
A conÔ¨Ågurable software consists of multiple conÔ¨Åguration
options , where each option plays a similar role as a global
program variable, but often has a Ô¨Ånite domain (e.g., boolean)
and does not change during program execution. A conÔ¨Ågu-
ration is a set of settings of the form x=v, wherexis a
conÔ¨Åguration option and vis a (valid) value of x.a) Interactions: An interaction for a location lcharac-
terizes of the set of conÔ¨Ågurations covering l. For example,
we see from Figure 2 that any conÔ¨Åguration satisfying u^v
(i.e., they have the settings u= 1andv= 1) is guaranteed to
cover L3. Although we focus on location coverage, interaction
can be associated with more general program behaviors, e.g.,
we could use an interaction to characterize conÔ¨Ågurations
triggering some undesirable behavior. To obtain coverage, we
typically run the program using a conÔ¨Åguration and a test
suite , which is a set of Ô¨Åxed environment data or options
to run the program on, e.g., the test suite for the Unix ls
(listing) command might consist of directories to run lson.
In summary, we deÔ¨Åne program interactions as:
DeÔ¨Ånition III.1. Given a program P, a test suite T, and a
coverage criterion X(e.g., some location lor behavior b), an
interaction forXis a formula over the (initial settings of
the) conÔ¨Åguration options of Psuch that (a) any conÔ¨Åguration
satisfyingis guaranteed to cover XunderTand (b)is
the logically weakest such formula (i.e., if also describes
conÔ¨Ågurations covering Xthen)).
b) Decision Trees: We use a decision tree to represent the
interaction for a location l. A decision tree consists of a root,
leaves, and internal (non-leaf) nodes. Each non-leaf node is
labeled with a conÔ¨Åguration option and has koutgoing edges,
which correspond to the kpossible values of the option. Each
leaf is labeled with a hit or miss class, which represents the
classiÔ¨Åcation of that leaf. The path from the root to a leaf
represents a condition leading to the classiÔ¨Åcation of the leaf.
This path condition is the conjunction of the settings collected
along that path. The union (disjunction) of the hit conditions
is the interaction for l. Dually, the disjunction of the miss
conditions is the condition for not covering l. The length of a
path is the number of edges in the path.
For illustration purposes, we annotate each leaf with a label
t(a)k, wheretis either the (h) hit or (m) miss class, ais
the path name (so that we can refer to the path), and kis the
number of supporting conÔ¨Ågurations used to classify this path.
Intuitively, the more supporting conÔ¨Ågurations a path has, the
higher conÔ¨Ådence we have about its classiÔ¨Åcation.
For example, the decision tree in Figure 5 for location L8
consists of four internal nodes and seven leaves. The tree has
Ô¨Åve miss and two hit paths, e.g., path (d), which has length 4
and condition s^e2^v^u, is classiÔ¨Åed as a hit due to
one conÔ¨Åguration hitting L8(c2in Figure 3), and (g) is a miss
path with condition sbecause seven conÔ¨Ågurations satisfying
this condition miss L8. The interaction for L8iss^e
2^((v^u)_(v^u)), the disjunction of the two hit conditions.
IV. T HEGE NTR E E ALGORITHM
Figure 6 shows the GenTree algorithm, which takes as
input a program, a test suite, and an optional set of initial
conÔ¨Ågurations, and returns a set of interactions for locations
in the program that were covered. Initial conÔ¨Ågurations, e.g.,
default or factory-installed conÔ¨Ågurations, if available, are
useful starting points because they often give high coverage.
1601input : program P; test suite T; initial conÔ¨Ågs I(optional)
output : a set of interactions of P
1conÔ¨Ågs I[oneway_covering_configs()
2cov run(P; T; conÔ¨Ågs )
3trees ;
4explore iters 0
5while explore iters<max explore iters do
6 explore iters explore iters+ 1
7 explore mode explore iters>1
8 foreach location l2cov do
9 hits hit(cov; l)
10 misses miss (cov; l)
11 need rebuild is_null (trees[l])_
:test_tree (trees[l];hits;misses )
12 ifneed rebuild_explore mode then
13 ifneed rebuild then
14 explore iters 0
15 trees[l] build_tree (hits;misses )
16 paths select_ranked_paths (trees[l])
17 ifexplore mode then
18 paths paths[
select_random_paths (trees[l])
19 conÔ¨Ågs gen_new_configs (paths )
20 cov cov[run(P; T; conÔ¨Ågs )
21interactions post_process (trees)
22return interactions
Fig. 6: GenTree ‚Äôs iterative reÔ¨Ånement algorithm
GenTree starts by creating a set of conÔ¨Ågurations using a
randomly generated 1-covering array and the initial conÔ¨Ågu-
rations if they are available. GenTree then runs the program
onconfigs using the test suite and obtain their coverage.
Next, GenTree enters a loop that iteratively builds a
decision tree for each covered location (¬ßIV-B) and generates
new conÔ¨Ågurations from these trees (¬ßIV-A) in order to reÔ¨Åne
them. GenTree has two modes: exploit andexplore .
It starts in exploit mode and reÔ¨Ånes incorrect trees in each
iteration. When GenTree can no longer reÔ¨Åne trees (e.g.,
it is stuck in some plateau), it switches to explore mode
and generates random conÔ¨Ågurations, hoping that these could
help improve the trees (and if so, GenTree switches back to
exploit mode in the next iteration).
For each covered location l,GenTree performs the fol-
lowing steps. First, we create hit and miss sets consisting
of conÔ¨Ågurations hitting or missing l, respectively. Second, if
GenTree is inexploit mode, we build a decision tree for l
from the hit and miss sets of conÔ¨Ågurations if either lis a new
location (a tree for ldoes not exist) or that the existing tree for
lis not correct (the test_tree function checks if the tree
fails to classify some conÔ¨Ågurations). If both of these are not
true (i.e., the existing tree for lis correct), we continue to the
next location. Otherwise, if GenTree is inexplore mode,
we continue to the next step. Third, we rank and select paths
in the tree that are likely incorrect to reÔ¨Åne them. If GenTree
is inexplore mode, we also select random paths. Finally,
uem (a) 2m (b) 2m (c) 1vh (d) 1h (e) 20120101s t u v a b c d e
0 0 0 0 0 0 2 2 2
1 1 0 0 2 1 1 0 2
1 0 0 0 1 2 0 1 2
Fig. 7: A decision tree and new conÔ¨Ågurations created from
path (c) of the tree
we generate new conÔ¨Ågurations using the selected paths and
obtain their coverage. GenTree uses these conÔ¨Ågurations to
validate and reÔ¨Åne the decision tree for lin the next iteration.
GenTree repeats these steps until existing trees remain
the same and no new trees are generated (i.e., no new
coverage) for several iterations. In the end, GenTree uses a
postprocessing step to extract logical formulae from generated
trees to represent program interactions.
A. Selecting Paths and Generating ConÔ¨Ågurations
Given a decision tree, GenTree ranks paths in the tree
and generates new conÔ¨Ågurations from high-ranked ones.
Intuitively, we use conÔ¨Ågurations generated from a path to
validate that path condition, which represents an interaction.
If these conÔ¨Ågurations do not violate the path condition, we
gain conÔ¨Ådence in the corresponding interaction. Otherwise,
these conÔ¨Ågurations are counterexamples that are subsequently
used to learn a new tree with more accurate paths.
a) Selecting Paths: To select paths to generate new
conÔ¨Ågurations, GenTree favors those with fewer support-
ing conÔ¨Ågurations because such paths are likely inaccurate
and thus generating counterexample conÔ¨Ågurations to ‚Äúbreak‚Äù
them is likely easier.
If there are multiple paths with a similar number of support-
ing conÔ¨Ågurations, we break ties by choosing the longest ones.
Paths with few supporting conÔ¨Ågurations but involving many
options are likely more fragile and inaccurate. If there are
multiple paths with a similar length and number of supporting
conÔ¨Ågurations, we pick one arbitrary.
For example, paths (c) and (d) in the tree shown in Fig-
ure 7 have the highest rank because they each have just one
supporting conÔ¨Åguration. Paths (a), (b), and (e) have two
conÔ¨Ågurations each, but path (e) is longer and thus ranked
higher. The Ô¨Ånal ranking for this tree is then (c), (d), (e), (a),
and (b).
b) Generating ConÔ¨Ågurations: From the highest-ranked
path, GenTree generates 1-covering conÔ¨Ågurations that sat-
isfy the path condition, i.e., these conÔ¨Ågurations have the same
settings as those in the condition of that path. GenTree keeps
generating new conÔ¨Ågurations this way for the next highest-
ranked paths until it achieves up to a certain number of new
conÔ¨Ågurations (currently conÔ¨Ågured to generate at least two
new conÔ¨Ågurations).
1602tsm (a) 10m (b) 5h (d) 1zm (g) 1m (c) 1h (f) 1h (e) 1010101234(a)
m (a) 20/3(b)
tsm (a) 101m (b) 5h (c) 5/20101
(c)
Fig. 8: Ideal tree (a) and C5.0 trees (b,c)
Using high-ranked paths to generate conÔ¨Ågurations is a
greedy approach, which might not always give useful con-
Ô¨Ågurations that help improve the tree. Thus, GenTree also
selects random paths during the explore mode, i.e., when a
tree remains unchanged in the previous iteration so that lower-
ranked paths can also be improved.
Figure 7 shows one possible set of conÔ¨Ågurations generated
from the highest-ranked path c. The condition of path cis
e2^u0^v0and thus all generated conÔ¨Ågurations
have values of e;u;v Ô¨Åxed to 2;0;0, respectively.
B. Building Decision Trees
GenTree uses a specialized classiÔ¨Åcation algorithm to
build decision trees. While many decision tree classiÔ¨Åers
exist (e.g., the popular family of ID3, C4.5, and C5.0 algo-
rithms [15], [16]), they do not Ô¨Åt our purpose because they
employ aggressive pruning strategies to simplify trees and
need large dataset to produce accurate results.
1) Limitations of C5.0: Consider an example where we
have three options: s;tare bool and zranges over the values
f0;1;2;3;4g. Assume we use all 225 = 20 conÔ¨Ågurations
as sample data and use the interaction s^t^(1z^z3)
to classify these conÔ¨Ågurations: 3 hits (there are only 3
conÔ¨Ågurations satisfy this interaction) and 17 misses.
The C5.0 algorithm would not be able to create a decision
tree, e.g., the one shown in Figure 8a, that perfectly classiÔ¨Åes
this data set to represent the desired interaction. For example,
the ofÔ¨Åcial C5.0 implementation [17] with default settings
yields the tree in Figure 8b, which represents the interaction
False . This is because by default, the tool determines that
most samples were misses (17/20) and prunes nodes to create a
tree reÔ¨Çecting this belief1. After tweaking the tool‚Äôs parameters
to avoid pruning2, we obtain the tree in Figure 8c that
represents the interaction s^t, which is more accurate, but
is still far from the desired one shown in Figure 8a. Even
with this full set of conÔ¨Ågurations, we cannot modify C5.0
to obtain the desired interaction, because C5.0, like many
other ML techniques, requires a very large set of sample
data to be accurate (leaves with too few samples, e.g., the 3
1The label 20/3 indicates this classiÔ¨Åcation has a total of 20 samples, but
3 of them are incorrect.
2Using the custom parameters -c 100 -m 1 -g .hit conÔ¨Ågurations in this example, are given low ‚ÄúconÔ¨Ådence
level‚Äù and therefore are pruned).
2) The C5 ialgorithm: We develop C5 i, a ‚ÄúsimpliÔ¨Åed‚Äù
version of C5.0 for interaction learning. Similarly to C5.0, C5 i
builds a decision tree to split a training sample (e.g., hit and
miss conÔ¨Ågurations) based on the feature (e.g., conÔ¨Åguration
options) that provides the highest information gain. Each
subsample is then split again using a different feature, and
the process repeats until meeting some stopping criteria.
ClassiÔ¨Åcation algorithms including ID3, C4.5, C5.0, CART
are designed around the concept of pruning, i.e., ‚Äúremove parts
of the tree that do not contribute to classiÔ¨Åcation accuracy
on unseen cases, producing something less complex and thus
more comprehensible‚Äù [15]. But pruning leads to inaccuracy
as shown in ¬ßIV-B1. Thus, C5 iavoids pruning to achieve
a 100% accuracy on the training sample, i.e., every sample
conÔ¨Åguration is correctly classiÔ¨Åed.
Other than pruning, the two algorithms have several main
differences. First, we use two classiÔ¨Åcation categories (hit and
miss) and features (conÔ¨Åguration options) with Ô¨Ånite domains,
e.g., boolean or over a Ô¨Ånite set of values. Our training samples
do not contain unknown values (C5.0 allows some values in
the training data to be omitted). The sample data also does not
contain noise, e.g., if cis an interaction for a location, then any
conÔ¨Åguration satisÔ¨Åes cwill guarantee to hit c. We give similar
weights to samples and similar costs for misclassiÔ¨Åcations
(C5.0 allows different cost assignments to misclassiÔ¨Åcation).
Finally, we perform splitting until we can no longer split
subsamples while C5.0 uses heuristics to decide when to stop
splitting and prune the rest.
Using the set of 20 conÔ¨Ågurations in the example in ¬ßIV-B1,
C5igenerates the tree in Figure 8a, which represents the
desired interaction. In fact, C5 ican generate the same tree
using just 14 conÔ¨Ågurations. However, by requiring exact,
instead of more generalized, trees, C5 iis prone to ‚ÄúoverÔ¨Åtting‚Äù,
i.e., generating trees that are correct for the sample data
but might not in general. GenTree ‚Äôs iterative reÔ¨Ånement
phase is speciÔ¨Åcally designed to mitigate this problem, i.e., by
generating counterexample conÔ¨Ågurations to gradually correct
overÔ¨Åtting mistakes. In ¬ßVI, we show that the integration of
C5iand iterative reÔ¨Ånement helps GenTree scale to programs
with very large conÔ¨Åguration spaces and learn trees represent-
ing accurate interactions using small sets of conÔ¨Ågurations.
V. S UBJECT PROGRAMS
GenTree is implemented in C++ and uses the Z3 SMT
solver [18] to encode and simplify interactions. We also use
Z3 to analyze interactions as described in ¬ßVI (e.g., checking
that interactions are equivalent to ground truth).
A. Subject Programs
To evaluate GenTree , we used the subject programs listed
in Table I. For each program, we list its name, language,
version, and lines of code as measured by SLOCCount [19].
We also report the number of conÔ¨Åguration options ( opts )
and the conÔ¨Åguration spaces ( cspace ).
1603TABLE I: Subject programs
prog lang ver loc opts cspace
id C 8.32 342 10 1024
uname C 8.32 282 11 2048
cat C 8.32 484 12 4096
mv C 8.32 378 11 5120
ln C 8.32 521 12 10 240
date C 8.32 501 7 17 280
join C 8.32 895 12 18 432
sort C 8.32 3366 22 6 291 456
ls C 8.32 3972 47 3:51014
grin Python 1.2.1 628 22 4 194 304
pylint Python 1.9.5 15 493 28 2:91011
unison Ocaml 2.51.2 30 074 27 2:0108
bibtex2html Ocaml 1.99 9258 33 1:31010
cloc Perl 1.86 12 427 23 16 777 216
ack Perl 3.4.0 3244 28 5:4108
vsftpd C 2.0.7 10 482 30 2:1109
ngircd C 0.12.0 13 601 13 294 912
These programs and their setups (¬ßV-B) are collected from
iGen. We include all programs that we can reproduce the
iGen‚Äôs setup and omit those that we cannot (e.g., the runscripts
and tests are not available for the Haskell and Apache httpd
used in iGen). In total, we have 17 programs spanning 4
languages (C, Python, Perl, and Ocaml).
The Ô¨Årst group of programs comes from the widely used
GNU coreutils [20]. These programs are conÔ¨Ågured via
command-line options. We used a subset of coreutils
with relatively large conÔ¨Åguration spaces (at least 1024 con-
Ô¨Ågurations each). The second group contains an assortment
of programs to demonstrate GenTree ‚Äôs wide applicability.
BrieÔ¨Çy: grin andack are grep-like programs; pylint is
a static checker for Python; unison is a Ô¨Åle synchronizer;
bibtex2html converts BibTeX Ô¨Åles to HTML; and cloc
is a lines of code counter. These programs are written in
Python, Ocaml, and Perl and have the conÔ¨Åguration space size
ranging from four million to 1011. The third group contains
vsftpd , a secure FTP server, and ngircd , an IRC daemon.
These programs were also studied by [1], who uses the Otter
symbolic execution tool to exhaustively compute all possible
program executions under all possible settings. Rather than
using a test suite, we ran GenTree on these programs in a
special mode in which we used Otter‚Äôs outputs as an oracle
that maps conÔ¨Ågurations to covered lines.
B. Setup
We selected conÔ¨Åguration options in a variety of ways. For
coreutils programs, we used all options, most of which
are boolean-valued, but nine can take on a wider but Ô¨Ånite
range of values, all of which we included, e.g., all possible
string formats the program date accepts. We omit options
that range over an unbounded set of values. For the assorted
programs in the second group, we used the options that we
could get working correctly and ignore those that can take
arbitrary values, e.g., pylint options that take a regexp or
Python expression as input. For vsftpd andngircd we
used the same options as in iGen.We manually created tests for coreutils to cover com-
mon usage. For example, for cat, we wrote a test that read
data from a normal text Ô¨Åle. For ls, we let it list the Ô¨Åles
from a directory containing some Ô¨Åles, some subdirectories,
and some symbolic links.
Finally, we obtained line coverage using gcov [21] for C,
coverage [22] for Python, Devel::Cover [23] for Perl,
and expression coverage using Bisect [24] for OCaml. We
used a custom runner to get the coverage for vsftpd and
ngircd using Otter‚Äôs result as explained in ¬ßV-A.
Our experiments were performed on a 64-core AMD CPU
2.9GHz Linux system with 64 GB of RAM. GenTree and
all experimental data are available at [12].
VI. E VALUATION
To evaluate GenTree we consider four research ques-
tions: can GenTree learn accurate program interactions ( R1-
Accuracy )? how does it perform and scale to programs with
large conÔ¨Åguration spaces ( R2-Performance )? what can we
learn from the discovered interactions ( R3-Analysis )? and how
doesGenTree compare to iGen ( R4-Comparing to iGen )?
Table II summarizes the results of running GenTree on the
benchmark programs (¬ßV), taking median across 11 runs and
their variance as the semi-interquartile (SIQR) range [25]. For
each program, columns configs andcov report the number
of conÔ¨Ågurations generated by GenTree and the number
of locations covered by these conÔ¨Ågurations, respectively.
The next two columns report the running time of GenTree
(search is the total time minus the time spent running
programs to obtain coverage). The next Ô¨Åve columns report
the number of distinct interactions inferred by GenTree .
Column single shows the number of interactions that are
true ,false , or contain only one option, e.g., s. Columns
conj ,disj ,mix,total show the number of pure con-
junction, pure disjunction, mixed (arbitrary form), and all of
these interactions, respectively. The low SIQR values on the
discovered coverage and interactions indicate that GenTree ,
despite being non-deterministic3, produces relatively stable
results across 11 runs. The next two columns list the max
and median interaction lengths, which are further discussed
in ¬ßVI-C. Column min cspace lists the results for the
experiment discussed in ¬ßVI-C.
A. R1-Accuracy
To measure the accuracy of inferred interactions, we evalu-
ated whether GenTree produces the same results with its iter-
ative algorithm as it could produce if it used all conÔ¨Ågurations
(i.e., the results GenTree inferred using allconÔ¨Ågurations are
‚Äúground truths‚Äù, representing the real interactions). To do this
comparison, we use all coreutils programs (except ls),
grin , and ngircd because we can exhaustively enumerate
all conÔ¨Ågurations for these programs.
3GenTree has several sources of randomness: the initial one-way covering
array, the selection of paths used for generating new conÔ¨Ågurations, the
selection of option values in those new conÔ¨Ågurations, and the creation of
the decision tree by the classiÔ¨Åcation algorithm.
1604TABLE II: Results. Column min cspace lists the results for the experiment in ¬ßVI-C
time(s) interaction types inter. lengths min
prog conÔ¨Ågs cov search total single conj disj mix total max median cspace
id 609 277 150 1 0 0 0 0 3 017 31 1 11 5 32 810 2 5 2 10
uname 189 359 98 1 0 0 0 0 11 0 4 10 1 8 2 23 3 6 4 1 0 4
cat 1660 109 205 0 0 0 1 0 12 0 7 01 0 7 0 27 012 0 1 0 6
mv 4532 61 167 0 5 1 6 1 9 0 3 03 0 6 0 21 011 0 1 0 4
ln 2143 114 171 0 0 0 2 0 10 0 7 02 0 5 0 24 0 8 0 1 0 5
date 12050 741 125 0 4 1 7 1 2 0 3 02 0 10 0 17 0 6 0 6 0 7
join 4001 797 365 0 1 1 4 1 4 017 12 0 10 1 33 012 012 0 6
sort 141935 23903 1085 0744 310 1069 345 12 0 5 02 0132 0151 022 016 0 18
ls 112566 26356 1289 0 31 5 579 66 46 040 01 0106 0193 047 0 4 0 14
grin 1828 132 332 0 0 1 103 7 3 0 5 00 0 9 0 17 0 7 0 5 0 6
pylint 6850 27 10757 0 26 1 3868 14 1 012 02 0 8 0 23 0 7 0 5 0 6
unison 9690 790 3565 0 5 0 252 12 3 039 01 0 19 0 62 010 0 7 0 7
bibtex2html 38317 2311 1437 0 26 4 5195 201 35 011 01 0113 0160 033 0 1 0 10
cloc 12284 931 1147 0612 1 9494 530 3 035 01 0 20 0 59 0 9 0 5 0 9
ack 65553 6708 1212 2 13 5 10214 603 2 010 11 0 59 4 72 528 122 1 14
vsftpd 10920 614 2549 0 2 1 6 1 5 036 02 0 9 0 52 0 7 0 5 0 5
ngircd 28711 1335 3090 0 18 1 148 4 4 0 8 02 0 51 0 65 011 0 4 0 5
TABLE III: Comparing GenTree
(a) vs. exhaustive (b) vs. iGen (¬ßVI-D)
cov interactions mixed
prog exact total pure ok fail
id 0 32 32 21 2 9
uname -1 22 27 17 7 3
cat 0 27 27 20 6 1
mv 0 21 21 15 2 4
ln 0 24 25 20 3 2
date 0 17 17 7 0 10
join 0 33 33 23 3 7
sort 0 148 151 19 10 122
grin 0 17 17 8 9 0
ngircd 0 64 65 14 4 47
Table IIIa shows the comparison results. Column cov
compares the locations discovered by GenTree and by ex-
haustive runs (0 means no difference,  kmeans GenTree
foundkfewer locations). The next two columns show inter-
actions found by GenTree (exact ) that exactly match the
interactions discovered by exhaustive runs ( total ).
Overall, GenTree generates highly accurate results com-
paring to ground truth, while using only a small part of
the conÔ¨Åguration space as shown in Table II and further
described in ¬ßVI-B. For uname ,GenTree misses location
uname.c:278 , which is guarded by a long conjunction
of 11 options of uname (thus the chance of hitting it is
1/2048 conÔ¨Ågurations). Also, for 8/11 times, GenTree infers
inaccurately uname.c:202 , which is a long disjunction of
11 options. For ln,GenTree was not able to compute
the exact interaction for location ln.c:495 in all runs.
Manual investigation shows that the interaction of this lo-
cation is a long disjunction consisting of all 12 run-time
options and thus is misidentiÔ¨Åed by GenTree astrue . For
sort , three locations sort.c:3212, sort.c:3492,
sort.c:3497 are non-deterministic (running the program
on the same conÔ¨Åguration might not always hit or miss theselocations) and thus produce inaccurate interactions.
B. R2-Performance
Table II shows that for programs with large conÔ¨Åguration
spaces, GenTree runs longer because it has to analyze more
conÔ¨Ågurations, and the run time is dominated by running
the programs on these conÔ¨Ågurations ( total search ).
In general, GenTree scales well to large programs because
it only explores a small portion of the conÔ¨Åguration space
(shown in Table I). For small programs (e.g., id, uname,
cat),GenTree analyzes approximately half of the conÔ¨Ågu-
ration space. However, for larger programs (e.g., sort, ls,
pylint, bibtex2html ),GenTree shows its beneÔ¨Åts as
the number of conÔ¨Ågurations analyzed is not directly propor-
tional to the conÔ¨Åguration space size. For example, lshas
eight more orders of magnitude compared to sort , but the
number of explored conÔ¨Ågurations is about the same. Note
thatcloc andack‚Äôs long run times are due to them being
written in Perl, which runs much slower than other languages
such as C (and even Python on our machine).
Convergence: Figure 9 shows how GenTree converges
to its Ô¨Ånal results on the programs used in Table III, which
we can exhaustively run to obtain ground truth results. The x-
axis is the number of explored conÔ¨Ågurations (normalized such
that 1 represents all conÔ¨Ågurations used by GenTree for that
particular program). The y-axis is the number of discovered
interactions equivalent to ground truth (normalized such that
1 represents all interactions for that program). These results
show that GenTree converges fairly quickly. At around
40% of conÔ¨Ågurations, GenTree is able to accurately infer
more than 90% of the total ground truth interactions. It then
spent the rest of the time reÔ¨Åning few remaining difÔ¨Åcult
interactions.
Comparing to Random Search: We also compare interac-
tions inferred from GenTree ‚Äôs conÔ¨Ågurations and randomly
generated conÔ¨Ågurations. For each program, we generate the
same number of random conÔ¨Ågurations as the number of
16050 0:2 0:4 0:6 0:8 100:20:40:60:81
conÔ¨Ågurations (normalized)exact interactions (normalized)id
id
uname
uname
cat
cat
mv
mv
ln
ln
0 0:2 0:4 0:6 0:8 100:20:40:60:81
conÔ¨Ågurations (normalized)exact interactions (normalized)date
date
join
join
sort
sort
grin
grin
ngircd
ngircd
Fig. 9: Progress of GenTree on generating interactions (italic program name indicates randomized version)
conÔ¨Ågurations GenTree uses and then run C5 ion these
conÔ¨Ågurations to obtain interactions.
Figure 9 shows that GenTree ‚Äôs conÔ¨Ågurations help the tool
quickly outperform random conÔ¨Ågurations and stay dominated
throughout the runs. Comparing to random conÔ¨Ågurations,
GenTree ‚Äôs conÔ¨Ågurations also learns more accurate interac-
tions, especially for large programs or those with complex
interactions, e.g., random conÔ¨Ågurations can only achieve
about 56% (84/151) of the ground truth interactions for sort .
C. R3-Analysis
We analyze discovered interactions to learn interesting prop-
erties in conÔ¨Ågurable software. These experiments are similar
to those in previous interaction works [1]‚Äì[4].
Interaction Forms: Table II shows that singular and
conjunctive interactions are common, especially in small pro-
grams. However, disjunctive interactions are relatively rare,
e.g., only 1-2 disjunctions occur in the subject programs.
Mixed interactions are also common, especially in large pro-
grams (e.g., in sort ,ls,unison , and bibtext2html ).
Existing works do not support many of these interactions and
thus would not able to Ô¨Ånd them (see ¬ßVI-D).
Interaction Length: Table II shows that the number of
obtained interactions is far fewer than the number of possible
interactions, which is consistent with prior works‚Äô results.
For example, for id, which has 10 boolean options, 1024
total conÔ¨Ågurations, and 21024possible interactions, GenTree
found only 32 interactions, which are many orders of magni-
tude less than 21024.
Also, most interactions are relatively short, regardless of
the number of conÔ¨Ågurations (e.g., all but join ,sort , and
ack have the median interaction lengths less than 10). We
also observe that we can achieve 74% coverage using only
interactions with length at most 3 and 93% coverage with
length at most 10. This observation is similar to previous
works.
Enabling Option: Enabling options are those that must
be set in a certain way to achieve signiÔ¨Åcant coverage. Forexample, many locations in coreutils programs have in-
teractions involving the conjunction help^version .Thus,
bothhelp andversion are enabling options that must be
turned off to reach those locations (because if either one is
one, the program just prints a message and exits). We also have
the enabling options Zforid(because it is only applicable
in SELinux-enabled kernel) and ListenIPv4 forngircd
(this option need to be turned on to reach most of locations).
In general, enabling options are quite common, as suggested
in previous works [1], [4].
Minimal Covering ConÔ¨Ågurations: A useful application
ofGenTree is using the inferred interactions to compute a
minimal set of conÔ¨Ågurations with high coverage. To achieve
this, we can use a greedy algorithm, e.g., the one described
in iGen, which combines interactions having high coverage
and no conÔ¨Çict settings, generates a conÔ¨Åguration satisfying
those interactions, and repeats this process until the generated
conÔ¨Ågurations cover all interactions.
Column min cspace in Table II shows that GenTree ‚Äôs
interactions allow us to generate sets of high coverage conÔ¨Ågu-
rations with sizes that are several orders of magnitude smaller
than the sizes of conÔ¨Åguration spaces. For example, we only
need 10/1024 conÔ¨Ågurations to cover 150 lines in idand
18/6291456 conÔ¨Ågurations to cover 1085 lines in sort .
D. R4-Comparing to iGen
Comparing to iGen, GenTree generally explored more
conÔ¨Ågurations but discovered more expressive interactions.
Table IIIb compares the interactions inferred by GenTree
and iGen. Column pure shows the number of single, purely
conjunctive, and pure disjunctive interactions supported (and
thus inferred) by both tools. Columns okandfail show the
numbers of mixed interactions supported and not supported by
iGen, respectively ( GenTree found all of these). For example,
both iGen and GenTree discovered the purely conjunctive in-
teraction help^version^Zforid.c:182 andthe mixed
interaction help^version^Z^u^(g_G)forid.c:198 .
However, only GenTree inferred the more complex mixed
1606interaction help^version^Z^g^G^n^(u_(r^z))
for location id.c:325 .
For small programs, we observe that many interactions
are pure conjunctive or disjunctive, and hence, supported by
both tools. However, for larger and more complex programs
(e.g., sort ,ngircd ), iGen could not generate most mixed
interactions while GenTree could. For example, iGen failed
to generate 122/132 of the mixed interactions in sort while
GenTree generated most of them.
E. Threats to Validity
Although the benchmark systems we have are popular and
used in the real world, they only represent a small sample
of conÔ¨Ågurable software systems. Thus, our observations
may not generalize in certain ways or to certain systems.
GenTree runs the programs on test suites to obtains cov-
erage information. Our chosen tests have reasonable, but not
complete, coverage. Systems whose test suites are less (or
more) complete could have different results. Our experiments
used a substantial number of options, but do not include
every possible conÔ¨Åguration options. We focused on subsets
of conÔ¨Åguration options that appeared to be important based
on our experience. Finally, GenTree cannot infer interactions
that cannot be represented by decision trees (e.g., conÔ¨Åguration
options involving non-Ô¨Ånite numerical values). Interactions
involving such options might be important to the general
understanding and analysis of conÔ¨Ågurable software.
VII. R ELATED WORK
Interaction Generation: As mentioned, GenTree is
mostly related to iGen, which computes three forms of in-
teractions: purely conjunctive, purely disjunctive, and speciÔ¨Åc
mixtures of the two. In contrast, we use decision trees to
represent arbitrary boolean interactions and develop our own
classiÔ¨Åcation algorithm C5 ito manipulate decision trees. To
illustrate the differences, consider the interaction for location
id.c:325 ,help^version^Z^g^G^n^(u_(r^z)),
which can be written as the disjunction of two purely con-
junctive interactions: (help^version^Z^g^G^
n^u)_(help^version^Z^g^G^n^r^z).
iGen can infer each of these two purely conjunctions, but
itcannot discover their disjunction because iGen does not
support this form, e.g., (a^b)_(a^c). For this example,
even when running on all1024 conÔ¨Ågurations, iGen only
generates help^version^Z^g^G^n^u, which misses
the relation with randz. In contrast, GenTree generates
thisexact disjunctive interaction (and many others) using 609
conÔ¨Ågurations in under a second (Table II in ¬ßVI-B).
Moreover, while both tools rely on the iterative guess-
and-check approach, the learning and checking components
and their integration in GenTree are completely different
from those in iGen, e.g., using heuristics to select likely
fragile tree paths to generate counterexamples. Also, while
C5iis a restricted case of C5.0, it is nonetheless a useful
case that allows us to generate a tree that is exactly accurate
over data instead of a tree that approximates the data. Wedeveloped C5 ibecause existing classiÔ¨Åcation algorithms do
not allow easy interaction inference (due to agressive pruning
and simpliÔ¨Åcation as explained in ¬ßIV-B2).
Precondition and Invariant Discovery: Researchers have
used decision trees and general boolean formulae to repre-
sent program preconditions (interactions can be viewed as
preconditions over conÔ¨Ågurable options). The work in [26]
uses random SAT solving to generate data and decision trees
to learn preconditions, but does not generate counterexample
data to reÔ¨Åne inferred preconditions, which we Ô¨Ånd crucial
to improve resulting interactions. Similarly, PIE [27] uses
PAC (probably approximately correct algorithm) to learn CNF
formula over features to represent preconditions, but also does
not generate counterexamples to validate or improve inferred
results. Only when given the source code and postconditions
to infer loop invariants PIE would be able to learn additional
data using SMT solving.
GenTree adopts the iterative reÔ¨Ånement approach used in
several invariant analyses (e.g., [8]‚Äì[11]). These works (in par-
ticular [9], [10] that use decision trees) rely on static analysis
and constraint solving to check (and generate counterexam-
ples) that the inferred invariants are correct with respect to the
program with a given property/assertion (i.e., the purpose of
these works is to prove correct programs correct). In contrast,
GenTree is pure dynamic analysis, in both learning and
checking, and aims to discover interactions instead of proving
certain goals.
GenTree can be considered as a dynamic invariant tool
that analyzes coverage trace information. Daikon [28], [29]
infers invariants from templates that Ô¨Åt program execution
traces. GenTree focuses on inferring interactions represented
by arbitrary formulae and combines with iterative reÔ¨Ånement.
DySy is another invariant generator that uses symbolic execu-
tion for invariant inference [30]. The interaction work in [1]
also uses the symbolic executor Otter [31] to fully explore
the conÔ¨Åguration space of a software system, but is limited to
purely conjunctive formulae for efÔ¨Åciency. Symbolic execution
techniques often have similar limitations as static analysis, e.g.,
they require mocks or models to represent unknown libraries or
frameworks and are language-speciÔ¨Åc (e.g., Otter only works
on C programs). Finally, GenTree aims to discover new
locations and learns interactions for all discovered locations.
In contrast, invariant generation tools typically consider a few
speciÔ¨Åc locations (e.g., loop entrances and exit points).
Binary decision diagrams (BDDs): The popular BDD
data structure [32] can be used to represent boolean formulae,
and thus is an alternative to decision trees. Two main advan-
tages of BDDs are that a BDD can compactly represent a large
decision tree and equivalent formulae are represented by the
same BDD, which is desirable for equivalence checking.
However, our priority is not to compactly represent inter-
actions or check their equivalences, but instead to be able to
infer interactions from a small set of data. While C5 iavoids
aggressive prunings to improve accuracy, it is inherently a
classiÔ¨Åcation algorithm that computes results by generalizing
training data (like the original C5.0 algorithm, GenTree
1607performs generalization by using heuristics to decide when to
stop splitting nodes to build the tree as described in ¬ßIV-B2).
To create a BDD representing a desired interaction, we would
need many conÔ¨Ågurations, e.g., 2n+ 1 miss or2n 1hit
conÔ¨Ågurations to create a BDD for a^(b1_b2__bn). In
contrast, C5 iidentiÔ¨Åes and generalizes patterns from training
data and thus require much fewer conÔ¨Ågurations. For instance,
the conÔ¨Åguration space size of the example in Figure 3 is
3888, and from just 3 conÔ¨Ågurations c1;c2;c3, C5 ilearns the
interaction sbecause it sees that whenever s1,L8is
miss, and whenever s0,L8ishit. BDD would need 1944
conÔ¨Ågurations to infer the same interaction.
Combinatorial Interaction Testing and Variability-Aware
Analyses: Combinatorial interaction testing (CIT) [13], [14]
is often used to Ô¨Ånd variability bugs in conÔ¨Ågurable systems.
One popular CIT approach is using t-way covering arrays to
generate a set of conÔ¨Ågurations containing all t-way com-
binations of option settings at least once. CIT is effective,
but is expensive and requires the developers to choose ta
priori. Thus developers will often set tto small, causing higher
strength interactions to be ignored. GenTree initializes its set
of conÔ¨Ågurations using 1-way covering arrays.
Variability-Aware is another popular type of analysis to Ô¨Ånd
variability bugs [33]‚Äì[42]. [36] classify problems in software
product line research and surveys static analysis to solve
them. GenTree ‚Äôs interactions belong to the feature-based
classiÔ¨Åcation, and we propose a new dynamic analysis to
analyze them. [40] study feature interactions in a system and
their effects, including bug triggering, power consumption, etc.
GenTree complements these results by analyzing interactions
that affect code coverage.
VIII. C ONCLUSION
We presented GenTree , a new dynamic analysis technique
to learn program interactions, which are formulae that describe
the conÔ¨Ågurations covering a location. GenTree works by
iteratively running a subject program under a test suite and
set of conÔ¨Ågurations; building decision trees from the resulting
coverage information; and then generating new conÔ¨Ågurations
that aim to reÔ¨Åne the trees in the next iteration. Experimental
results show that GenTree is effective in accurately Ô¨Ånding
complex interactions and scales well to large programs.
IX. D ATA AVAILABILITY
GenTree and all benchmark data are available at the public
Github repository [12]. A snapshot of the tool and benchmark
used in this paper is available at [43].
ACKNOWLEDGMENT
We thank the anonymous reviewers for helpful comments.
This work was supported in part by awards CCF-1948536
from the National Science Foundation and W911NF-19-1-
0054 from the Army Research OfÔ¨Åce. KimHao Nguyen is
also supported by the UCARE Award from the University of
Nebraska-Lincoln.REFERENCES
[1] E. Reisner, C. Song, K. Ma, J. S. Foster, and A. Porter, ‚ÄúUsing symbolic
evaluation to understand behavior in conÔ¨Ågurable software systems,‚Äù in
International Conference on Software Engineering . ACM, 2010, pp.
445‚Äì454.
[2] C. Song, A. Porter, and J. S. Foster, ‚ÄúiTree: EfÔ¨Åciently discovering
high-coverage conÔ¨Ågurations using interaction trees,‚Äù in International
Conference on Software Engineering , Zurich, Switzerland, June 2012,
pp. 903‚Äì913.
[3] ‚Äî‚Äî, ‚ÄúiTree: EfÔ¨Åciently discovering high-coverage conÔ¨Ågurations using
interaction trees,‚Äù Transactions on Software Engineering , vol. 40, no. 3,
pp. 251‚Äì265, 2014.
[4] T. Nguyen, U. Koc, J. Cheng, J. S. Foster, and A. A. Porter, ‚ÄúiGen: Dy-
namic interaction inference for conÔ¨Ågurable software,‚Äù in Foundations
of Software Engineering , 2016, pp. 655‚Äì665.
[5] S. She, R. Lotufo, T. Berger, A. Wkasowski, and K. Czarnecki, ‚ÄúReverse
engineering feature models,‚Äù in International Conference on Software
Engineering . ACM, 2011, pp. 461‚Äì470.
[6] T. Berger, S. She, R. Lotufo, A. Wkasowski, and K. Czarnecki, ‚ÄúVari-
ability modeling in the real: A perspective from the operating systems
domain,‚Äù in Automated Software Engineering . ACM, 2010, pp. 73‚Äì82.
[7] M. Cashman, M. B. Cohen, P. Ranjan, and R. W. Cottingham, ‚ÄúNavigat-
ing the maze: the impact of conÔ¨Ågurability in bioinformatics software,‚Äù
inAutomated Software Engineering , 2018, pp. 757‚Äì767.
[8] R. Sharma, S. Gupta, B. Hariharan, A. Aiken, P. Liang, and A. V . Nori,
‚ÄúA data driven approach for algebraic loop invariants,‚Äù in European
Symposium on Programming . Springer, 2013, pp. 574‚Äì592.
[9] P. Garg, C. L ¬®oding, P. Madhusudan, and D. Neider, ‚ÄúIce: A robust
framework for learning invariants,‚Äù in Computer Aided VeriÔ¨Åcation .
Springer, 2014, pp. 69‚Äì87.
[10] P. Garg, D. Neider, P. Madhusudan, and D. Roth, ‚ÄúLearning invariants
using decision trees and implication counterexamples,‚Äù ACM Sigplan
Notices , vol. 51, no. 1, pp. 499‚Äì512, 2016.
[11] T. Nguyen, M. B. Dwyer, and W. Visser, ‚ÄúSymlnfer: Inferring program
invariants using symbolic states,‚Äù in Automated Software Engineering .
IEEE, 2017, pp. 804‚Äì814.
[12] K. Nguyen and T. Nguyen, ‚ÄúGenTree,‚Äù 2021, accessed on 2021-02-01.
[Online]. Available: https://github.com/unsat/gentree
[13] M. B. Cohen, P. B. Gibbons, W. B. Mugridge, and C. J. Colbourn, ‚ÄúCon-
structing test suites for interaction testing,‚Äù in International Conference
on Software Engineering . IEEE, 2003, pp. 38‚Äì48.
[14] D. M. Cohen, S. R. Dalal, J. Parelius, and G. C. Patton, ‚ÄúThe combi-
natorial design approach to automatic test generation,‚Äù IEEE Software ,
vol. 13, no. 5, pp. 83‚Äì88, 1996.
[15] J. R. Quinlan, C4.5: Programs for Machine Learning . Elsevier, 2014.
[16] M. Kuhn and K. Johnson, Applied predictive modeling . Springer, 2013,
vol. 26.
[17] RuleQuest, ‚ÄúData mining tools,‚Äù 2019, accessed on 2021-02-01.
[Online]. Available: https://www.rulequest.com/see5-info.html
[18] L. De Moura and N. Bj√∏rner, ‚ÄúZ3: An efÔ¨Åcient SMT solver,‚Äù in Tools
and Algorithms for the Construction and Analysis of Systems . Springer,
2008, pp. 337‚Äì340.
[19] D. A. Wheeler, ‚ÄúSLOCCount; LOC counter,‚Äù 2009, accessed on
2021-02-01. [Online]. Available: http://www.dwheeler.com/sloccount/
[20] GNU Software, ‚ÄúGNU Coreutils,‚Äù 2007, accessed on 2021-02-01.
[Online]. Available: https://www.gnu.org/software/coreutils/
[21] ‚Äî‚Äî, ‚Äúgcov: A test coverage program,‚Äù accessed on 2021-02-01.
[Online]. Available: https://gcc.gnu.org/onlinedocs/gcc/Gcov.html
[22] N. Batchelder, ‚ÄúCode coverage measurement for Python,‚Äù accessed on
2021-02-01. [Online]. Available: https://pypi.org/project/coverage/
[23] P. Johnson, ‚ÄúDevel::Cover - code coverage metrics for Perl,‚Äù accessed on
2021-02-01. [Online]. Available: http://search.cpan.org/%7Epjcj/Devel-
Cover-1.20/lib/Devel/Cover.pm
[24] X. Clerc, ‚ÄúBisect: coverage tool for OCaml,‚Äù accessed on 2021-02-01.
[Online]. Available: http://bisect.x9c.fr
[25] D. M. Lane, ‚ÄúSemi-interquartile range,‚Äù 2020, accessed on 2021-02-01.
[Online]. Available: http://davidmlane.com/hyperstat/A48607.html
[26] S. Sankaranarayanan, S. Chaudhuri, F. Ivan Àáci¬¥c, and A. Gupta, ‚ÄúDynamic
inference of likely data preconditions over predicates by tree learning,‚Äù
inInternational Symposium on Software Testing and Analysis , 2008, pp.
295‚Äì306.
1608[27] S. Padhi, R. Sharma, and T. Millstein, ‚ÄúData-driven precondition infer-
ence with learned features,‚Äù ACM SIGPLAN Notices , vol. 51, no. 6, pp.
42‚Äì56, 2016.
[28] M. D. Ernst, J. Cockrell, W. G. Griswold, and D. Notkin, ‚ÄúDynamically
discovering likely program invariants to support program evolution,‚Äù
Transactions on Software Engineering , vol. 27, no. 2, pp. 99‚Äì123, 2001.
[29] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant, C. Pacheco, M. S.
Tschantz, and C. Xiao, ‚ÄúThe daikon system for dynamic detection of
likely invariants,‚Äù Science of computer programming , vol. 69, no. 1-3,
pp. 35‚Äì45, 2007.
[30] C. Csallner, N. Tillmann, and Y . Smaragdakis, ‚ÄúDysy: Dynamic sym-
bolic execution for invariant inference,‚Äù in International Conference on
Software Engineering . ACM, 2008, pp. 281‚Äì290.
[31] K.-K. Ma, K. Y . Phang, J. S. Foster, and M. Hicks, ‚ÄúDirected symbolic
execution,‚Äù in Static Analysis Symposium . Springer, 2011, pp. 95‚Äì111.
[32] S. B. Akers, ‚ÄúBinary decision diagrams,‚Äù IEEE Computer Architecture
Letters , vol. 27, no. 06, pp. 509‚Äì516, 1978.
[33] K. Lauenroth, K. Pohl, and S. Toehning, ‚ÄúModel checking of domain ar-
tifacts in product line engineering,‚Äù in Automated Software Engineering .
IEEE, 2009, pp. 269‚Äì280.
[34] S. Apel, C. K ¬®astner, A. Gr ¬®o√ülinger, and C. Lengauer, ‚ÄúType safety
for feature-oriented product lines,‚Äù Automated Software Engineering ,
vol. 17, no. 3, pp. 251‚Äì300, 2010.
[35] J. Liebig, S. Apel, C. Lengauer, C. K ¬®astner, and M. Schulze, ‚ÄúAn analysis
of the variability in forty preprocessor-based software product lines,‚Äù inInternational Conference on Software Engineering , 2010, pp. 105‚Äì114.
[36] T. Th ¬®um, S. Apel, C. K ¬®astner, M. Kuhlemann, I. Schaefer, and G. Saake,
‚ÄúAnalysis strategies for software product lines,‚Äù School of Computer
Science, University of Magdeburg, Tech. Rep. FIN-004-2012 , 2012.
[37] C. K ¬®astner, S. Apel, T. Th ¬®um, and G. Saake, ‚ÄúType checking annotation-
based product lines,‚Äù Transactions on Software Engineering and Method-
ology , vol. 21, no. 3, pp. 1‚Äì39, 2012.
[38] J. Liebig, A. V on Rhein, C. K ¬®astner, S. Apel, J. D ¬®orre, and C. Lengauer,
‚ÄúScalable analysis of variable software,‚Äù in Foundations of Software
Engineering , 2013, pp. 81‚Äì91.
[39] A. Mordahl, J. Oh, U. Koc, S. Wei, and P. Gazzillo, ‚ÄúAn empirical study
of real-world variability bugs detected by variability-oblivious tools,‚Äù in
Foundations of Software Engineering , 2019, pp. 50‚Äì61.
[40] S. Apel, S. Kolesnikov, N. Siegmund, C. K ¬®astner, and B. Garvin,
‚ÄúExploring feature interactions in the wild: the new feature-interaction
challenge,‚Äù in Feature-Oriented Software Development , 2013, pp. 1‚Äì8.
[41] S. Apel, D. Batory, C. K ¬®astner, and G. Saake, Feature-oriented software
product lines . Springer, 2016.
[42] J. Meinicke, C. Wong, C. K ¬®astner, T. Th ¬®um, and G. Saake, ‚ÄúOn essential
conÔ¨Åguration complexity: measuring interactions in highly-conÔ¨Ågurable
systems,‚Äù in Automated Software Engineering , 2016, pp. 483‚Äì494.
[43] K. Nguyen and T. Nguyen, ‚ÄúArtifact for GenTree: Using decision
trees to learn interactions for conÔ¨Ågurable software,‚Äù 2021. [Online].
Available: https://doi.org/10.5281/zenodo.4514778
1609