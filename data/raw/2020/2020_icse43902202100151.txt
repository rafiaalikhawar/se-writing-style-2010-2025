JUSTGen: Effective Test Generation for
UnspeciÔ¨Åed JNI Behaviors on JVMs
Sungjae Hwang
School of Computing
KAIST
Daejeon, South Korea
sjhwang87@kaist.ac.krSungho Lee
Department of Computer Science and Engineering
Chungnam National University
Daejeon, South Korea
eshaj@cnu.ac.krJihoon Kim
School of Computing
KAIST
Daejeon, South Korea
kjh618@kaist.ac.krSukyoung Ryu
School of Computing
KAIST
Daejeon, South Korea
sryu.cs@kaist.ac.kr
Abstract ‚ÄîJava Native Interface (JNI) provides a way for Java
applications to access native libraries, but it is difÔ¨Åcult to develop
correct JNI programs. By leveraging native code, the JNI enables
Java developers to implement efÔ¨Åcient applications and to reuse
code written in other programming languages such as C and C++.
Besides, the core Java libraries already use the JNI to provide
system features like a graphical user interface. As a result, many
mainstream Java Virtual Machines (JVMs) support the JNI.
However, due to the complex interoperation semantics between
different programming languages, implementing correct JNI
programs is not trivial. Moreover, because of the performance
overhead, JVMs do not validate erroneous JNI interoperations
by default, but they validate them only when the debug feature,
the-Xcheck:jni option, is enabled. Therefore, the correctness of
JNI programs highly relies on the checks by the -Xcheck:jni
option of JVMs. Questions remain, however, on the quality of the
checks provided by the feature. Are there any properties that the
-Xcheck:jni option fails to validate? If so, what potential issues
can arise due to the lack of such validation? To the best of our
knowledge, no research has explored these questions in-depth.
In this paper, we empirically study the validation quality and
impacts of the -Xcheck:jni option on mainstream JVMs using
unspeciÔ¨Åed corner cases in the JNI speciÔ¨Åcation. Such unspeciÔ¨Åed
cases may lead to unexpected run-time behaviors because their
semantics is not deÔ¨Åned in the speciÔ¨Åcation. For a systematic
study, we propose JUSTG EN, a semi-automated approach to
identify unspeciÔ¨Åed cases from a speciÔ¨Åcation and generate test
programs. JUSTG ENreceives the JNI speciÔ¨Åcation written in
our domain speciÔ¨Åc language (DSL), and automatically discovers
unspeciÔ¨Åed cases using an SMT solver. It then generates test
programs that trigger the behaviors of unspeciÔ¨Åed cases. Using
the generated tests, we empirically study the validation ability
of the -Xcheck:jni option. Our experimental result shows that
the JNI debug feature does not validate thousands of unspeciÔ¨Åed
cases on JVMs, and they can cause critical run-time errors such
as violation of the Java type system and memory corruption. We
reported 792 unspeciÔ¨Åed cases that are not validated by JVMs
to their corresponding JVM vendors. Among them, 563 cases
have been Ô¨Åxed and the remaining cases will be Ô¨Åxed in near
future. Based on our empirical study, we believe that the JNI
speciÔ¨Åcation should specify the semantics of the missing cases
clearly and the debug feature should be supported completely.
Index Terms‚ÄîJava Native Interface, Java Virtual Machine,
Testing, Empirical Study, Debugging
I. I NTRODUCTION
Java developers use the Java Native Interface (JNI) in
various application domains including games and multimedia,
and mainstream Java Virtual Machines (JVMs) [1]‚Äì[4] supportthe JNI. The JNI is an interface that deÔ¨Ånes interoperation
between Java code and native code written in C or C++.
Using the JNI, developers can improve the performance of
programs by implementing performance-critical modules in
native code and composing them with Java modules into
a single program via the JNI. In addition, the JNI reduces
software development cost by allowing Java modules to reuse
existing native libraries.
However, building correct JNI programs is a difÔ¨Åcult task
due to the complex interoperation semantics between different
languages. In addition, because the JNI speciÔ¨Åcation does not
describe the interoperation semantics completely, the seman-
tics of numerous cases are unspeciÔ¨Åed, which may lead to
unexpected behaviors. Note that the JNI does not check for
programming errors for the following reasons [5]:
Forcing JNI functions to check for all possible
error conditions degrades the performance of
normal (correct) native methods.
In many cases, there is not enough run-time type
information to perform such checking.
While compilers can detect compile-time errors and provide
useful debug features for programs written in a single pro-
gramming language, they cannot Ô¨Ånd bugs in interoperation
between Java and native code. Furthermore, no publicly avail-
able tools can detect such interoperation errors.
The JNI supports the -Xcheck:jni option to help developers
to diagnose problems in JNI programs, but the speciÔ¨Åcation
does not deÔ¨Åne its semantics clearly. The -Xcheck:jni option
is a command-line option that causes the VM to do additional
validation on the arguments passed to JNI functions [6], [7].
However, the additional validation is not well deÔ¨Åned:
Note: The option is not guaranteed to Ô¨Ånd all invalid
arguments or diagnose logic bugs in the application
code, but it can help diagnose a large number of
such problems.
Because the speciÔ¨Åcation does not specify which problems
the option diagnoses, JNI programs may behave differently
on different JVMs depending on their implementation of the
option, which makes reasoning of JNI programs challenging.
In this paper, we study the semantics of the -Xcheck:jni
option and its impacts on mainstream JVMs. Our approach
17082021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00151
is to generate test programs for ‚ÄúunspeciÔ¨Åed cases,‚Äù which
are interoperation semantics that are not deÔ¨Åned in the JNI
speciÔ¨Åcation, to execute the test programs on JVMs with
the -Xcheck:jni option enabled, and to inspect the execution
results. Our study has two technical challenges: 1) how to
identify unspeciÔ¨Åed cases in the JNI speciÔ¨Åcation, and 2)
how to generate test programs that trigger the behaviors
of unspeciÔ¨Åed cases. For a systematic study, we propose
JUSTG EN, a semi-automated approach to identify unspeciÔ¨Åed
cases and generate test programs. We Ô¨Årst deÔ¨Åne a domain
speciÔ¨Åc language (DSL) that can express the JNI interoper-
ation semantics such as the return types and parameters of
JNI functions. Then, we manually transform the interoperation
semantics written in a natural language in Chapter 4 of the
JNI speciÔ¨Åcation [8] to a mechanized speciÔ¨Åcation expressed
in our DSL. Because the English phrases used to specify the
interoperation semantics are well structured and use speciÔ¨Åc
patterns, manually converting them to the DSL is considerably
straightforward. Then, JUSTG ENreceives the mechanized
speciÔ¨Åcation, automatically extracts unspeciÔ¨Åed cases from
the speciÔ¨Åcation, and generates test programs that provoke
them. JUSTG ENleverages an SMT solver to Ô¨Ånd unspeciÔ¨Åed
cases by verifying whether the speciÔ¨Åcation describes all the
conditions of JNI function calls. If JUSTG ENidentiÔ¨Åes a
condition of a JNI function call that the speciÔ¨Åcation does
not describe, it considers the condition as an unspeciÔ¨Åed case.
For test code generation, JUSTG ENtakes an unspeciÔ¨Åed case
and synthesizes C code consisting of JNI function calls with
arguments that satisfy the conditions of the unspeciÔ¨Åed case. It
then compiles and links the synthesized C code with prepared
Java modules to generate an executable JNI program.
Using 34,990 test programs generated by JUSTG EN, we
empirically evaluated the -Xcheck:jni option on Ô¨Åve main-
stream JVMs. Our study shows that thousands of unspeciÔ¨Åed
cases are not validated by JVMs, and they can cause critical
run-time errors such as run-time type errors and memory
corruption. In addition, we found a bug of the -Xcheck:jni
option, which leads to deadlock between multiple threads.
We also observed that the -Xcheck:jni option of HotSpot,
Zulu, Corretto, and GraalVM validate similar properties, but
OpenJ9 validates properties signiÔ¨Åcantly different from them.
We reported the problems of the -Xcheck:jni option to their
JVM vendors, and among 792 reported unspeciÔ¨Åed cases, 563
cases have been Ô¨Åxed. The tool used for the empirical study
and the identiÔ¨Åed unspeciÔ¨Åed cases are publicly available1.
The contributions of this paper include the following:
We present an approach to identify unspeciÔ¨Åed cases
from a speciÔ¨Åcation and implement JUSTG ENthat
automatically identiÔ¨Åes them from a mechanized spec-
iÔ¨Åcation and generates test code provoking them. We
believe that JUSTG ENis applicable to other speciÔ¨Åca-
tions with only changes in test code generation.
We identify unspeciÔ¨Åed cases from the JNI speciÔ¨Åca-
tion. Describing the semantics of the identiÔ¨Åed unspeci-
1https://github.com/sjmini/justgen.1public class HelloJNI{
2 static { System.loadLibrary( "Hello" ); }
3 private native String foo();
4 public static void main(String[] args){
5 String n = new HelloJNI().foo();
6 ... }
7 private String name(){
8 return this .getClass().getName(); }
9}
(a) Java code
1jmethodID get_name_id(JNIEnv *env, jobject obj){
2 jclass cls = ( *env)->GetObjectClass(env, obj);
3 return (*env)->GetMethodID(env, cls, "name" ,
"()LJava/lang/String;" );
4}
5jstring Java_HelloJNI_foo(JNIEnv *env, jobject
thisObj){
6 jmethodID mid = get_name_id(env, thisObj);
7 return (*env)->CallObjectMethod(env, thisObj,
mid);
8}
(b) Normal JNI interoperation in C code
1jstring Java_HelloJNI_foo(JNIEnv *env, jobject
thisObj){
2 jmethodID mid = get_name_id(env, thisObj);
3 jcharArray arr = ( *env)->NewCharArray(env, 2);
4 return (*env)->CallObjectMethod(env, arr,
mid);
5}
(c) UnspeciÔ¨Åed JNI interoperation case in C code
Fig. 1: JNI code example for normal and unspeciÔ¨Åed behaviors
Ô¨Åed cases in the JNI speciÔ¨Åcation would make consistent
behaviors of JNI programs on different JVMs.
It is the Ô¨Årst work that analyzes the quality of the
-Xcheck:jni option on Ô¨Åve mainstream JVMs. Our
empirical study reports limitations of the -Xcheck:jni
option, and JVM vendors Ô¨Åxed 563 among 792 reported
cases. We believe that our work would be helpful in
enhancing the quality of the JNI debug feature on JVMs,
which in turn improves the quality of JNI programs.
II. B ACKGROUND AND MOTIVATING EXAMPLE
A. JNI Interoperation
The JNI is a foreign function interface that enables bidi-
rectional interoperation between Java and native applications.
Figure 1(a) shows Java code that has an entrypoint of a
JNI program, and Figure 1(b) shows C code compiled to
a native library Hello.so . In Java, a class HelloJNI has
two Java methods, main andname , and a native method
foo declared with the native keyword. The native method
is linked with a C function Java_HelloJNI_foo , when
executing the System.loadLibrary method at line 2. When
the program runs, the main method calls the native method
foo at line 5. Then, the JVM transfers the program control
to the entry of the linked C function Java_HelloJNI_foo .
In C code, the function Java_HelloJNI_foo calls the Java
1709method name via a sequence of three JNI function calls. At
line 6 in Figure 1(b), the C code obtains a Java method ID by
calling get_name_id deÔ¨Åned at line 1. The function calls the
GetObjectClass JNI function that takes a JNIEnv pointer
and a Java object and returns class information of the Java
object. Then, it calls GetMethodID to obtain a Java method
ID using the class information, a method name, and a method
signature. Using the method ID and the Java object, it calls the
Java method name via the CallObjectMethod JNI function.
B. UnspeciÔ¨Åed Cases and the JNI Debug Feature
Because JVMs do not validate argument values at run-time
due to its performance overhead, the unspeciÔ¨Åed cases may
lead to unexpected behaviors or even security vulnerabilities
like memory corruption. Figure 1(c) shows one unspeciÔ¨Åed
case for the JNI function CallObjectMethod . The function
Java_HelloJNI_foo gets an ID of the Java method name
via the get_name_id function as the same as (b). However,
at line 4, it tries to call the Java method name using a Java
character array object created at line 3 instead of the Java
object propagated from Java. The JNI speciÔ¨Åcation describes
the behavior of CallObjectMethod as follow [8]:
NativeType Call<type>Method(JNIEnv *env,
jobject obj, jmethodID methodID, ...);
Methods from these three families of operations are
used to call a Java instance method from a native
method.themethodID must be derived from the
real class of obj, not from one of its superclasses.
However, in the example, because the method ID is derived
from HelloJNI while a class of this is a character array,
its behavior is not speciÔ¨Åed, which can cause problems on
mainstream JVMs. For example, calling CallObjectMethod
at line 4 triggers a segmentation fault on the HotSpot JVM,
but executes normally on the OpenJ9 JVM producing a wrong
result. After normal execution, the variable nhas a string value
[Cat line 5 in (a), instead of HelloJNI , which is wrong in
the Java semantics, because a this object in a Java method
must be an instance of a class having the method.
To prevent segmentation faults or abnormal executions from
JVMs due to the unspeciÔ¨Åed JNI interoperation semantics,
the JNI provides a debug feature, the -Xcheck:jni option, but
it does not guarantee to Ô¨Ånd all problems and its semantics
depends on the implementation on JVMs. The -Xcheck:jni
option enables JVMs to validate arguments passed to JNI
functions [7]. If argument values are not valid, JVMs stop
execution and report errors or warnings. For example, when
executing the example in Figure 1(c) on the OpenJ9 JVM with
the -Xcheck:jni option enabled, the JVM detects the invalid
argument and throws an exception with the error message: JNI
error in CallObjectMethod/CallObjectMethodV:
Ineligible receiver . However, because the debuggability
highly relies on JVMs, invalid interoperation in JNI programs
may still remain undiscovered after the debugging process,
which degrades the quality of JNI programs.
In this paper, we leverage unspeciÔ¨Åed cases to evaluate the
quality of the -Xcheck:jni option on mainstream JVMs. We be-lieve that unspeciÔ¨Åed cases are useful resources to evaluate the
-Xcheck:jni option since developers might have missed them
because they are not described in the speciÔ¨Åcation.
III. M ETHODOLOGY
A. Overview
To evaluate the quality of the -Xcheck:jni option, we
test JVMs with unspeciÔ¨Åed cases that are semi-automatically
extracted from the JNI speciÔ¨Åcation. Figure 2 presents an
overview of our testing approach consisting of two phases.
In the JNI Unspec. Code Generation Phase , JUSTG ENex-
tracts unspeciÔ¨Åed cases from the JNI speciÔ¨Åcation and gen-
erates test programs that provoke the behaviors of the un-
speciÔ¨Åed cases. Since the speciÔ¨Åcation is written in a natural
language that is not suitable for automated processing, our
Ô¨Årst step is to deÔ¨Åne a domain speciÔ¨Åc language (DSL) and
to manually transform the semantics in the speciÔ¨Åcation to a
mechanized speciÔ¨Åcation in the DSL. Then, Unspec. Extractor
discovers unspeciÔ¨Åed cases from the mechanized speciÔ¨Åcation
by utilizing an SMT solver. It encodes the mechanized speci-
Ô¨Åcation as logical formula in a way that the SMT solver can
recognize, and leverages the SMT solver to determine whether
a formula is unsatisÔ¨Åable. If the formula is satisÔ¨Åable, the
SMT solver generates a counterexample of such a case. The
counterexample denotes an unspeciÔ¨Åed case with a possible
argument combination. Similar to CounterExample-Guided
Abstraction ReÔ¨Ånement (CEGAR) [9], Unspec. Extractor up-
dates the speciÔ¨Åcation by adding the identiÔ¨Åed unspeciÔ¨Åed
case, and repeats the above process until the formula becomes
unsatisÔ¨Åable. Among various SMT solvers, we used Z3 [10].
For each unspeciÔ¨Åed case, Test Code Generator automatically
generates a sequence of valid JNI function calls that triggers
the behavior of the unspeciÔ¨Åed case. Then, it composes the
JNI function calls with a Java and C template code that we
deÔ¨Åned.
In the JVM Testing Phase , we execute the generated test
programs on mainstream JVMs with the -Xcheck:jni option
enabled. Because different JVMs may produce different re-
sults, we manually inspect the test results and analyze the
capability of the debug feature of each JVM, and identify
potential hazards due to the lack of validation from JVMs.
B. JNI SpeciÔ¨Åcation in a Domain SpeciÔ¨Åc Language
For automatic processing of the JNI speciÔ¨Åcation, we deÔ¨Åne
a simple DSL to describe the behaviors of JNI functions.
Because the expected behaviors of JNI functions are deÔ¨Åned
in Chapter 4 of the JNI speciÔ¨Åcation [8], we manually trans-
formed them to a mechanized speciÔ¨Åcation expressed in the
DSL. Since the JNI function behaviors are written in a well-
structured phrases using speciÔ¨Åc patterns, manually converting
them to the DSL is considerably straightforward.
Figure 3 presents the DSL syntax. A speciÔ¨Åcation sis a
sequence of type declarations typedeft, a sequence of reÔ¨Åne-
ment predicate declarations refinedef t@p, and a sequence
of JNI function speciÔ¨Åcation d. Typestdenote types in the
1710Fig. 2: Overall structure of JVM testing with unspeciÔ¨Åed cases
rule{
type void SetIntArrayRegion(JNIEnv *, jintArray, jsize, jsize, jint *)
spec void SetIntArrayRegion(JNIEnv *, jintArray@NotNULL, jsize@ValidIndex, jsize@ValidIndex,
jint *@NotNULL)
unspec void SetIntArrayRegion(JNIEnv *, jintArray@isNULL, jsize@ValidIndex, jsize@ValidIndex,
jint *@NotNULL)
...
}Fig. 4: Example JNI function speciÔ¨Åcation in DSL
s:= typedeftrefinedef t@pd
d:= rule ftypet F(t) t[@r]?F(t[@r]?)g
:= spec junspec
r:=pjr^r
Fig. 3: Domain speciÔ¨Åc language to deÔ¨Åne the JNI semantics
C programming language including primitive types and pre-
deÔ¨Åned types for the JNI in jni.h . A reÔ¨Ånement predicate
pdenotes a predicate name, which returns whether an input
satisÔ¨Åes its condition. A reÔ¨Ånement type [11] t@pdenotes a
set of values that have the type tand satisfy the reÔ¨Ånement
predicatep. For example, a set of all negative integer values
is denoted as int@isNegative where isNegative is
a predicate returning whether an input is a negative integer.
A JNI function speciÔ¨Åcation dconsists of a JNI function
descriptor and a sequence of reÔ¨Åned function descriptors. A
JNI function descriptor typet F(t) denotes a return type t,
a JNI function name F, and a sequence of parameter types t.
A reÔ¨Åned function descriptor  t[@r]?F(t[@r]?)denotes an
optionally reÔ¨Åned return type t[@r]?, a JNI function name F,
and a sequence of optionally reÔ¨Åned parameter types t[@r]?
whereis either spec orunspec . A reÔ¨Ånement ris a
reÔ¨Ånement predicate por its conjunctions. For our research,
we deÔ¨Åned 38 types and 105 reÔ¨Ånement types [12], [13]. To
distinguish function descriptors JVMs do not verify return
values of JNI functions, but because we use return types in
test code generation as described in Section III-D, we include
return types in reÔ¨Ånement types. speciÔ¨Åed in the speciÔ¨Åcation
and those constructed while Ô¨Ånding unspeciÔ¨Åed cases using
the SMT solver, we use spec for the former and unspec forthe latter.
Figure 4 shows an example JNI function speciÔ¨Åcation
in DSL. The JNI function SetIntArrayRegion takes a
JNI environment pointer JNIEnv *, a Java array of integers
jintArray , an integer value representing the start index of
an array jsize , an integer value indicating the number of
elements to be copied jsize , and the source buffer ( jint *).
The function copies a speciÔ¨Åed number of elements from
the source buffer to the Java array. According to the JNI
speciÔ¨Åcation, the Java array must not be NULL , the start
index and the number of elements must be greater than or
equal to zero, and the source buffer must not be NULL as
well. We transform the above speciÔ¨Åcation in the DSL as
thespec statement with reÔ¨Ånement predicates representing
the conditions for valid argument values. In this example,
NotNULL denotes that input values should not be NULL , and
ValideIndex denotes that input values must be greater than
or equal to zero. In addition to the spec statement, various
unspec statements are automatically generated in the process
of Ô¨Ånding unspeciÔ¨Åed cases of the JNI function as we discuss
in the next subsection.
C. Finding UnspeciÔ¨Åed Behaviors with an SMT Solver
We leverage the Z3 SMT solver version 4.8.1 to Ô¨Ånd
unspeciÔ¨Åed cases automatically from the mechanized JNI
speciÔ¨Åcation. To use the SMT solver, we convert the unspec-
iÔ¨Åed case Ô¨Ånding problem to an SAT problem. For example,
for a JNI function speciÔ¨Åcation spect1@r1F(t2@r2), we
extract a boolean formula as follows: is there a reÔ¨Åned type
xthat is matched with the type t2but is not covered by
the speciÔ¨Åcation t2@r2? When the formula is satisÔ¨Åable,
the SMT solver produces an example satisÔ¨Åable cases; the
1711produced example is an unspeciÔ¨Åed case. Then, we update the
boolean formula including the unspeciÔ¨Åed case to Ô¨Ånd another
unspeciÔ¨Åed case. We repeat the process to Ô¨Ånd unspeciÔ¨Åed
cases until the boolean formula is not satisÔ¨Åable, which means
that no more unspeciÔ¨Åed cases exist.
1) Bit vector representation for JNI function speciÔ¨Åcation:
We use bit vectors to represent each JNI function speciÔ¨Åcation
in a boolean formula so that the SMT solver can manipulate
it. A JNI function speciÔ¨Åcation consists of a possibly reÔ¨Åned
return type, a function name, and a list of possibly reÔ¨Åned
parameter types. Since only the parameters determine the
behavior of the JNI function, we can encode a JNI function
speciÔ¨Åcation into a list of bit vectors where each bit vector
represents each possibly reÔ¨Åned parameter type.
DeÔ¨Ånition 1 (Bit vector representation):
(Type) Each typetis mapped to a unique bit vector
representation Bt.
(ReÔ¨Ånement predicate) For each reÔ¨Åned type t@r, each
reÔ¨Ånement predicate pinris mapped to a unique bit
vectorBpwhose on-bits do not overlap with other bit
vectors representing reÔ¨Ånement predicates of t.
(ReÔ¨Ånement) For a reÔ¨Ånement r=p1^:::^pn, its bit
vector representation is Br=Bp1jBpnwherejis the
bitwise OR operator.
(JNI function speciÔ¨Åcation) For a JNI function speciÔ¨Åca-
tiont1@r1F(t2@r2;:::;t n@rn), its bit vector represen-
tation is ((Bt2,Br2), ..., (Btn,Brn)) whereBtiandBri
are bit vector representations of tiandri, respectively.
One challenge for the bit vector representation is to deÔ¨Åne
subtype relations among types. While C does not have any
subtype relations between types, JNI reference types have a
type hierarchy that corresponds to the Java type hierarchy [14].
For example, because jstring is a subtype of jobject ,
a JNI function that takes a jobject argument can take a
jstring value as well.
We deÔ¨Åne a subtype relation (<:t) between two bit vectors
using the bitwise AND operator &. For the previous example,
we encode jobject andjstring into two different bit
vectors,BtoandBts, which satisfy Bto&Bts=Bto.
DeÔ¨Ånition 2 (Subtype relation): Assume that t1is a subtype
oft2andBt1andBt2are bit vector representations of t1and
t2, respectively. Then, a subtype relation Bt1<:tBt2is valid.
The subtype relation is equivalent to a boolean expression,
Bt1&Bt2=Bt2.
Similarly, we also deÔ¨Åne a subreÔ¨Ånement relation (<:r) be-
tween two bit vectors representing reÔ¨Ånements. A reÔ¨Ånement
r1is a subreÔ¨Ånement of another reÔ¨Ånement r2, when all the
reÔ¨Ånement predicates in r1are included in r2.
DeÔ¨Ånition 3 (SubreÔ¨Ånement relation): Assume that r1is a
subreÔ¨Ånement of r2andBr1andBr2are bit vector repre-
sentations of r1andr2, respectively. Then, a subreÔ¨Ånement
relationBr1<:rBr2is valid. The subreÔ¨Ånement relation is
equivalent to a boolean expression, Br1&Br2=Br2.
2) SatisÔ¨Åability for unspeciÔ¨Åed case Ô¨Ånding: Using encoded
JNI function speciÔ¨Åcations, we convert each JNI function spec-
iÔ¨Åcation to a boolean formula to Ô¨Ånd unspeciÔ¨Åed cases. Onecomplexity is that because most JNI functions take multiple
parameters, we should consider many parameter combinations.
For example, if a JNI function takes Ô¨Åve parameters and
each parameter has ten reÔ¨Åned types, the number of possible
parameter combinations is 105, which is a huge search space.
For practicality, we handle each parameter independently to
reduce the search space. For a JNI function Fwithnparam-
eters, we make nfunctionsF1;;FnwhereFitakes only
thei-th parameter of F. Then, each function Figets converted
to a boolean formula, and the SMT solver Ô¨Ånds unspeciÔ¨Åed
cases for each boolean formula independently. This approach
may miss some unspeciÔ¨Åed cases that are caused only by a
combination of multiple parameters. However, our experiments
showed that because most unspeciÔ¨Åed cases are due to a single
parameter, few such cases are missing.
After deÔ¨Åning four auxiliary deÔ¨Ånitions, we deÔ¨Åne a boolean
formula to check the satisÔ¨Åability of a JNI function parameter
using the auxiliary deÔ¨Ånitions. Note that we now consider only
such JNI functions that take one parameter.
DeÔ¨Ånition 4 (Complete reÔ¨Ånement): For each type t, its
complete reÔ¨Ånement bit vector is Bt
cthat is a conjunction of
all the reÔ¨Ånement predicates of t.
DeÔ¨Ånition 5 (Validity of reÔ¨Åned type): A bit vector rep-
resentation of a reÔ¨Åned type ( Btx,Brx) is valid for a type
t, ifBtx<:tBtandBrx<:rBt
c. A logical predicate
valid ((Btx;Brx);t)istrue only when ( Btx,Brx) isvalid for
the typet.
DeÔ¨Ånition 6 (Equivalent type satisiÔ¨Åability): A bit vector
representation of a reÔ¨Åned type ( Btx,Brx) is equivalent
type satisÔ¨Åable to another bit vector representation ( Bty,
Bry), iffBtx=BtyandBrx<:rBry. A logical predicate
sateq((Btx;Brx);(Bty;Bry))istrue only when ( Btx,Brx)
isequivalent type satisÔ¨Åable to (Bty,Bry).
DeÔ¨Ånition 7 (Subtype satisiÔ¨Åability): A bit vector rep-
resentation of a reÔ¨Åned type ( Btx,Brx) is subtype sat-
isÔ¨Åable to another bit vector representation ( Bty,Bry),
iffBtx<:tBtyandBtx6=Bty. A logical predicate
satsub((Btx;Brx);(Bty;Bry))istrue only when ( Btx,Brx)
issubtype satisÔ¨Åable to (Bty,Bry).
Using the auxiliary deÔ¨Ånitions, we deÔ¨Åne a boolean formula
for the parameter satisiÔ¨Åability solved by the SMT solver.
Assume that a JNI function declaration is t1F(t2)and the bit
vector representation of its speciÔ¨Åcation is ( Bty,Bry). Then,
we can deÔ¨Åne its satisÔ¨Åability problem as follows:
9(Btx;Brx): valid ((Btx;Brx);t2)!
:(sateq((Btx;Brx);(Bty;Bry))
_satsub((Btx;Brx);(Bty;Bry)))
The formula represents that there is a valid parameter ( Btx,
Brx) that is matched with the JNI function parameter type
t2but not covered by the speciÔ¨Åcation ( Bty,Bry). When
the SMT solver concludes that this formula is satisÔ¨Åable, it
produces an example such as ( Btz,Brz) as a result repre-
senting an unspeciÔ¨Åed case that is not covered by the current
1712speciÔ¨Åcation. Then, we record the unspeciÔ¨Åed case and update
the formula by adding it as follows:
9(Btx;Brx): valid ((Btx;Brx);t2)!
:( (sateq((Btx;Brx);(Bty;Bry))
_satsub((Btx;Brx);(Bty;Bry)))
_(sateq((Btx;Brx);(Btz;Brz))
_satsub((Btx;Brx);(Btz;Brz))))
Thus, in the next iteration, the SMT solver tries to Ô¨Ånd
another unspeciÔ¨Åed case except for ones discovered previously.
When the SMT solver fails to Ô¨Ånd more unspeciÔ¨Åed cases, it
concludes that the formula is not satisÔ¨Åable, implying that the
updated speciÔ¨Åcation covers all the valid parameters.
D. Test Case Generation and Testing on JVMs
One difÔ¨Åculty in the test code generation phase is to
generate valid test code. As described in Section II, in JNI
programs, C code leverages a sequence of JNI function calls
to interact with Java modules. To investigate behaviors caused
by unspeciÔ¨Åed cases, generated test code should contain JNI
function call chains that do not introduce run-time errors
caused by other factors such as invalid arguments, unintended
unspeciÔ¨Åed cases, and so on. Random test generation is widely
used, but it is not suitable for our purpose; it produces too
many wrong JNI function call chains that cause run-time errors
unrelated to unspeciÔ¨Åed cases.
The Test Code Generator utilizes both ‚Äúa JNI function
mapping table‚Äù and ‚Äútemplate code‚Äù to generate valid test
code. Firstly, it constructs a mapping table by matching each
reÔ¨Åned parameter type of JNI functions with a reÔ¨Åned return
type of other JNI functions. For example, if a Ô¨Årst reÔ¨Åned
parameter type of a JNI function foo is matched with a reÔ¨Åned
return type of another JNI function bar, the mapping bar
!foo@1 is added to the table; it denotes that the return
value of bar can be used for the Ô¨Årst argument of foo.
JNI functions often take values of primitive types such as
integers and character arrays as arguments, and some primitive
types may not have matching JNI functions that have them as
return types. Therefore, for primitive types, we manually write
template code that consists of functions that return values of
primitive types according to reÔ¨Åned parameter types. With the
mapping table and the template code, Test Code Generator
generates valid C test code for unspeciÔ¨Åed cases by building
valid JNI function call chains and propagating valid arguments
for reÔ¨Åned parameter types. We compile the generated C test
code and link it with Java modules we developed to build
executable JNI test programs. Note that we focus on only C
test code while JNI supports both C and C++ because all the
mainstream JVMs handle the JNI interoperation for C and
C++ in the same way.
For testing on multiple JVMs, we install each JVM on an
individual Docker container [15] and execute the generated
test code on each container. Because different JVMs print
execution results in different formats, we develop a result
parser for each JVM to translate its execution result to a uniÔ¨ÅedTABLE I: Evaluation results of the -Xcheck:jni option on Ô¨Åve
JVMs for 34,990 unspeciÔ¨Åed cases
Category HotSpot OpenJ9 Zulu Corretto GraalVM
Misbehave 4,922 445 4,918 4,918 4,918
SegFault 1,050 567 1,050 1,050 1,010
Exception 24,338 23,377 24,339 24,339 24,339
Validation 4,680 10,601 4,683 4,683 4,723
format. Then, Test Result Assembler classiÔ¨Åes the execution
results into four categories: Misbehave ,SegFault ,Exception
and Validation . The Misbehave category represents that test
code terminates normally without any warnings or errors.
Since behaviors of unspeciÔ¨Åed cases are not deÔ¨Åned, each JVM
may produce different execution result from one another for
an unspeciÔ¨Åed case. The SegFault and Exception categories
represent that test code causes a segmentation fault and an
exception thrown, respectively, and the Validation category
represents that test code terminates with an error or a warning
produced by the debug feature as its validation result. In
addition, Test Result Assembler compares the execution results
of the JVMs to identify different debugging capabilities of the
JVMs.
IV. E VALUATION OF THE JNI D EBUG FEATURE ON JVM S
A. Evaluation Results for UnspeciÔ¨Åed Cases
To evaluate the debug capability of mainstream JVMs,
we chose Ô¨Åve JVMs based-on their popularity [16]: Oracle‚Äôs
Hotspot, IBM‚Äôs OpenJ9, Azul‚Äôs Zulu, Amazon‚Äôs Corretto, and
Oracle‚Äôs GraalVM. Among various Java versions, we chose
Java 11, since its popularity is ranked the second following
Java 8 and all Ô¨Åve JVMs have implementations for Java 11.
Table I shows the categorized evaluation results on the Ô¨Åve
JVMs for the test programs. JUSTG ENgenerated 34,990 test
programs for unspeciÔ¨Åed cases from the JNI speciÔ¨Åcation
within 403 seconds. As Table I indicates, the evaluation
results are very similar between JVMs except for OpenJ9,
because they are variants of OpenJDK. Even though they have
similar evaluation results, we believe that analyzing them is
signiÔ¨Åcant because different vendors support them. OpenJ9
validated much more unspeciÔ¨Åed cases than the others, but
it validated only 30.3% of the unspeciÔ¨Åed cases. The other
JVMs validated only 13.4%. In most cases, when JVMs do
not validate unspeciÔ¨Åed cases, they let test programs terminate
with exceptions. Throwing exceptions may be helpful for
developers diagnose the problems, but segmentation faults may
not be useful to point out where the problems occur. Moreover,
misbehaviors may make the problems undiscovered, which can
lead to unexpected behaviors.
In the following subsections, we report our empirical study
results for unspeciÔ¨Åed cases in the categories of misbehaviors
and segmentation faults. In addition, we discuss the differences
in the debug capability of the JVMs, the unspeciÔ¨Åed cases that
were not validated by all of the JVMs, and threats to validity.
1713B. Category: Misbehave
We manually investigated the unspeciÔ¨Åed cases in the
Misbehave category. Since there are many unspeciÔ¨Åed cases
as shown in Table I, it is impractical to investigate them
all. Instead, we chose one unspeciÔ¨Åed case for each param-
eter of JNI functions. In addition, for JNI function families
that provide the same functionality for different types such
asCallVoidMethod ,CallIntMethod , and so on, we
randomly selected one of them. Finally, we manually investi-
gated 132 unspeciÔ¨Åed cases for Hotspot, Zulu, Correctto, and
GraalVM, but only 17 cases for OpenJ9 because it has a small
number of Misbehave cases.
1) In All the JVMs: We found two cases where all Ô¨Åve
JVMs failed to identify unspeciÔ¨Åed cases.
Finding 1:Error handling using return values of JNI
functions is not reliable.
Some JNI functions return v alues that indicate the success
or failure of their e xecution, butthey may not return correct
results. One example isRegisterNative that re gisters
nativ e functions. According to thespeciÔ¨Åcation, the function
should tak e apositiv e number of nati vefunctions, and return
0 on success and a negativevalue on failure. Ho wever,all
Ô¨Åve JVMs failed to validate the case when the functi on tak es
no nati vefunctions. Moreo ver, in such cases, while OpenJ9
returns -1, the other JVMs return 0indicating the execution
success. Thus, relying on return v alues of JNI functions to
handle e xecution failures is not reliable.
Finding 2:Deleted references are not completely
validated.
Using deleted objects may lead to une xpected beha viors, b ut
JVMs do not v alidate it completely e ven with the debug
feature enabled. Forinstance, GetObjectRefType receiv es
a Javaobject and returns the reference type of the object.
One of our test code passed a deleted Java object as an
argument toGetObjectRefType , which is an unspec-
iÔ¨Åed case. Even though the JNI speciÔ¨Åcation states that
GetObjectRefType should not use deleted objects, we
found that the function returns the object type as a local
reference on OpenJ9, while the other JVMs successfully detect
the ca se. W e reported the problem to IBM and it is no w Ô¨Åx ed.
On the contrary, when a deleted object is stored in an array
using SetObjectArrayElement , OpenJ9 detects this case
butthe other JVMs cannot detect it. Thus, all the VMs failed
to validate them completely.
2) In four JVMs: Wereport six cases where all JVMs
except OpenJ9 f ailed to identify unspeciÔ¨Åed cases.
Finding 3:Methods may be treated as constructors.
According to the JNI speciÔ¨Åcation, the name of constructors
should be <init> . However,our test code re vealed that when
we call GetMethodID with a method whose name is NULL ,
the functi on returns the method ID of a constructor on all
JVMs e xcept for OpenJ9. W e found out that the JVMs returnthe method ID of a constructor only if there is a constructor
that satisÔ¨Åe s the method signature passed to GetMethodID
as a fourth ar gument.
Finding 4:Java objects may be incorrectly initialized.
InJNI programs, nativ e code can create Java objects using
NewObjectV . Whi le the speciÔ¨Åcation states that the method
ID of a constructor should be passed to NewObjectV , all
JVMs e xcept OpenJ9 cannot detect such cases when the
method ID of a non-constructor is used and simply create an
object using the non-constructor .
Finding 5:Native code may call Java methods with
ill-typed Java objects.
We observ ed se veral unspeciÔ¨Åed cases where nati vecode call
a Javamethod with a Javaobject that has a different type from
what the method e xpects. One such an example is calling a
Java method with a receiv er object of an incorrect type using
CallNonvirtualIntMethod . All JVMs e xcept OpenJ9
cannot detect such cases. Even though Ja vaprovides strong
type checking, nativ e code can break its type system.
Finding 6:Array elements may be updated with values
of incompatible types.
We observ ed another case that JNI programs break the Java
type system. TheReleaseBooleanArrayElements JNI
function tak es a Java array object as a second argument,
and a pointer to array elements as a third ar gument. If
this function takes 0 as its fourth argument, it copies the
values of the pointer to the Ja vaarray object and frees the
memory pointed by the pointer. According to the speciÔ¨Åcation,
the pointer used by ReleaseBooleanArrayElements
must be deriv ed by theGetBooleanArrayElements
function. Ho wever,one of our test code passed a pointer
that is deriv ed by theGetIntArrayElements function to
ReleaseBooleanArrayElements , and all JVMs except
OpenJ9 could not detect it and copied the values of the pointer
to the Java array object with an incompatible type.
Finding 7:JNI functions may change return values of
Java methods.
While nativ e code should use CallIntMethod to call
Java methods that return integers, our test code in voked
CallIntMethod with a Javamethod that returns v alues of
typeFloat , which was detected only by OpenJ9. In all the
other JVMs, the return value of the Java method wasunexpect-
edly changed. Forexample, when a Java method returns 3.5f
of type Flot , the nativ e code invoking CallIntMethod
returned 1080033280, which is very different from 3.5f.
Finding 8:An object can be popped from a local
reference frame even when no local reference frame
exists on the stack.
ThePopLocalFrame JNIfunction tak es a local reference
object, pops offthe current local reference frame, and re-
turns a local reference in the frame for the gi ven object.
1714However, we found that if a global reference is passed
toPopLocalFrame , the JVMs except for OpenJ9 behave
abnormally: i) the global reference object was returned when
the function is supposed to return local reference objects only,
and ii) the object was returned even when no local reference
frame exists on the stack.
3) Only in OpenJ9: We found four cases where only
OpenJ9 failed to identify unspeciÔ¨Åed cases. We reported them
all to IBM, and they are all Ô¨Åxed2.
Finding 9:Invalid Java objects can be constructed with
incorrect class names, and they lead to segmentation
faults in subsequent JNI function calls.
TheFindClass JNI function tak es a fully-qualiÔ¨Åed class
name and returns a class object, butOpenJ9 constructs Java
class objects even with incorrect cl ass names. Our test code
called FindClass with an incorrect class name, and OpenJ9
constructed a class object and returned it tonativ e code without
anyerror or warning. Howe ver, once the JNI program uses the
class object, it results in a segmentation fault.
Finding 10:Local references can be created with a
negative capacity.
According to the speciÔ¨Åcation, EnsureLocalCapacity
should tak e the capacity of a local reference, which must
not be negative. Ho wever,our auto-generated test code called
EnsureLocalCapacity with -5 for the capacity, which
was OpenJ9 did not detect. OpenJ9 silently generated a new
local reference object without anyerror or warning.
Finding 11:Invalid JNI function calls may be silently
ignored.
We observ ed that OpenJ9 sometimes silently ignore unspeci-
Ô¨Åed JNI function calls. One such an example is to change the
value of a static Ô¨Åeld of an object using SetObjectField ,
which should change the value of only non-static Ô¨Åelds.
OpenJ9 did not catch this unspeciÔ¨Åed case b ut silently ignored
the ille galoperation.
Finding 12: JNI Programs may not terminate.
We found one bug in the debug feature of OpenJ9
that caused JNI programs to not terminate. When our
test code releases NULL as array elements using the
Release<type>ArrayElements JNI function, the code
does not terminate because of a deadlock between mul-
tiple threads. One thread holds a VM access and tries
to enter MemMonitor , while the other thread already in
MemMonitor tries to acquire the VM access to exit JVM.
As we discussed, IBM Ô¨Åxed the b ug after our report.
C. Cate gory: Se gFault
In addition to abnormal behavi ors described so far,we
observed that unspeciÔ¨Åed cases can cause se gmentation f aults
due to the lack of validation from the -Xcheck:jni option.
2https://github.com/sjmini/justgen/blob/main/README.md.The root cause of the se gmentation f aults is accessing ille gal
memory locations, and attack ers can exploit such defects to
hijack the control Ô¨Ço ws of the programs [17]. Therefore, we
consider them as potential security vulnerabilities.
Table I sho ws the number of unspeciÔ¨Åed cases that caused
segmentation faults for each JVM. As the table sho ws, 567
unspeciÔ¨Åed cases provoked segmentation faults in OpenJ9,
1,011 cases in GraaalVM, and 1,051 cases in the other JVMs.
Wemanually in vestig ated them to understand which properties
were not validated, and T able II summarizes the results.
Wecategorized the se gmentation f aults into four reasons:
Type Check ,NULL Chec k,Liveness Chec k, and Releasability
Check . For OpenJ9, the lack ofNULL Check is the main reason
with 74.5% of se gmentation f aults. F or the other JVMs, the
primary cause of the se gmentation f aults is the lack of Type
Check; 76.1% of the segmentation faults on HotSpot, Zulu,
and Corretto, and 75.2% on GraalVM are due to missing
type checks. The second major reason for se gmentation f aults
on OpenJ9 is missing Liveness Check. Especially, when JNI
functions use deleted references, only OpenJ9 cannot detect
them, which amounts to 11.8% of the se gmentation f aults on
OpenJ9. Moreo ver, we also observ ed unspeciÔ¨Åed cases where
unreleasable arrays are released by JNI functions such as
ReleaseCharArrayElements . Due to the space limitation,
we pro vide detailed inform ation on each unspeciÔ¨Åed case in
a companion report [18]. Wefound that these unspeciÔ¨Åed
cases can be detected only by OpenJ9, and the other JVMs
throw segmentation faults. Wereported the segmentation fault
problems to JVM v endors and 415 unspeciÔ¨Åed cases ha vebeen
Ô¨Åxed so far and more Ô¨Åx es are on their way.
Another interesting point we found is that HotSpot, Zulu,
and Corretto have the same number of se gmentation f aults. Our
analysis on these cases concluded that the -Xcheck:jni option
of these JVMs v alidate the same properties. On the other hand,
OpenJ9 beha vesquite dif ferent from the other JVMs. Ov erall,
the -Xcheck:jni option on OpenJ9 v alidates more properties
than the other JVMs. In the next subsection, we further analyze
the dif ferences between JVMs.
D. Dif ferences between JVMs
Wenow compare the debug capability of Ô¨Åve JVMs. As
discussed in the pre vious subsect ion, the debug capability of
OpenJ9 is different from that of the other JVMs. On the
contrary, the other four JVMs show similar deb ug capability .
Our e valuation results sho w that there are 6,499 unspeciÔ¨Åed
cases that OpenJ9 v alidates correctly , but HotSpot misses.
Conv ersely, there are 578 unspeciÔ¨Åed cases that HotSpot
validates, butOpenJ9 misses. Forthose 6,499 and 578 un-
speciÔ¨Åed case, we chose representativ e case as we did in
Section IV -B and manually in vestig ated them to understand
the deb ug capability of Hotspot and OpenJ9. The analysis
results are summarized in Table III, where Oindicates that
the -Xcheck:jni option of the JVM properly v alidates the
unspeciÔ¨Åed case, andXindicates that the JVM does not
validate the unspeciÔ¨Åed case. The table clearly sho ws which
unspeciÔ¨Åed cases can or cannot be validated by HotSpot and
1715TABLE II: Root causes of segmentation faults
Root Causes UnspeciÔ¨Åed Cases HotSpot OpenJ9 Zulu Corretto GraalVM
Type CheckCall ill-typed objects‚Äô methods 720 0 720 720 680
DeÔ¨Åne classes with ill-typed classloaders 0 40 0 0 0
Use reÔ¨Çection with ill-typed objects 80 38 80 80 80
NULL CheckCall methods with NULL arguments 30 30 30 30 30
Call methods using a NULL method ID 0 372 0 0 0
Access Ô¨Åelds using a NULL Ô¨Åeld ID 18 18 18 18 18
Get Ô¨Åelds of a NULL object 0 1 0 0 0
Get Ô¨Åeld/method IDs using a NULL signature 166 0 166 166 166
Get Ô¨Åeld/method IDs and classes from a NULL object 29 0 29 29 29
Get strings into a NULL destination buffer 1 1 1 1 1
Liveness CheckCall objects‚Äô methods using deleted references 0 60 0 0 0
Compare types between a live and a deleted reference 0 3 0 0 0
Set Ô¨Åelds with deleted references 0 1 0 0 0
DeÔ¨Åne classes with deleted a reference name 0 1 0 0 0
Get Ô¨Åeld/method IDs using a deleted reference 0 2 0 0 0
Releasability Check Release unreleasable arrays 6 0 6 6 6
Total 1,050 567 1,050 1,050 1,010
TABLE III: Debug capability of Hotspot and OpenJ9
Causes UnspeciÔ¨Åed Cases Hot J9
TypeDeÔ¨Åne classes with wrong typed classloaders O X
Get classes using a wrong class descriptor O X
Throw exceptions using non-throwable objects O X
Call methods with unmatched return types X O
Create objects with array classes X O
Use reÔ¨Çection for Ô¨Åelds using wrong typed objects X O
NULLIniailize objects using a NULL method ID O X
Get Ô¨Åelds of a NULL object O X
Call methods of a NULL object X O
Call methods using a NULL method ID O X
Get Ô¨Åeld/method IDs of a NULL object X O
Get Ô¨Åeld/method IDs using a NULL signature X O
Get Ô¨Åeld/method IDs using a NULL name X O
Release a NULL string X O
LivenessGet types from deleted references O X
Put deleted references into an array X O
Call objects‚Äô methods using deleted references O X
Compare types between a live and a deleted reference O X
Pop a local frame from an empty frame stack X O
ModiÔ¨ÅerAccess non-static Ô¨Åelds using a static Ô¨Åeld ID O X
Access static Ô¨Åelds with a non-static Ô¨Åeld ID O X
Call private methods of super classes X O
Negative
IntegerSet a negative capacity of local frames O X
Access a negative index of arrays X O
Constructor Initialize objects using non-constructor methods X O
Releasability Release unreleasable arrays X O
OpenJ9. It shows three new causes: ModiÔ¨Åer ,Negative Integer ,
andConstructor . The ModiÔ¨Åer cause denotes when JVMs do
not check the correct use of modiÔ¨Åers such as static , and
public . For example, such a case when a JNI function uses
astatic Ô¨Åeld ID where a non-static Ô¨Åeld ID is expected
belongs to the ModiÔ¨Åer cause. OpenJ9 cannot validated them
whereas Hotspot can. The Negative Integer problem is when
a negative number is used where a non-negative number is
expected. For instance, we found that OpenJ9 cannot identify
creation of a local frame with a negative capacity, while
Hotspot validates it. We also observed an inverse case. OpenJ9TABLE IV: UnspeciÔ¨Åed cases not validated by JVMs
Causes UnspeciÔ¨Åed Cases
NULL CheckCall methods with a NULL argument list
Access static Ô¨Åelds using a NULL Ô¨Åeld ID
Copy a string value into a NULL buffer
Size CheckPush a zero-sized local frame into a frame stack
Register zero number of native functions
Type Check Use reÔ¨Çection for methods using wrong typed objects
throws an error message when accessing a negative index of
array, but Hotspot cannot validate it. The Constructor problem
is initialization of Java objects with non-constructor functions.
OpenJ9 detects the problem when a non-constructor method
ID is used to create a Java object, but Hotspot cannot.
We found no unspeciÔ¨Åed cases that HotSpot validates, but
Zulu, Corretto, and GraalVM misses. However, we found three
unspeciÔ¨Åed cases that Zulu and Corretto validate, but HotSpot
misses. Similarly, we found 43 unspeciÔ¨Åed cases that GraalVM
validates, but HotSpot misses. We manually investigated all
those 3 and 43 unspeciÔ¨Åed cases, and our analysis revealed
that they are due to the use of deleted objects and ill-typed
objects, respectively.
Our evaluation results show that the debug features of differ-
ent JVMs check different properties, and therefore validating
JNI programs on multiple JVMs especially OpenJ9 and one of
the others would be desirable. We provide detailed description
of each unspeciÔ¨Åed case in a companion report [18].
E. No Validation from Any JVMs
We observed that 23,880 unspeciÔ¨Åed cases are not validated
by any JVMs. Among them, all JVMs throw exceptions for
23,367 cases, but no JVMs throw exceptions for the remaining
513 cases. We believe that they are problematic cases because
even the -Xcheck:jni option cannot validate them on any
JVMs. We further analyzed them to understand what properties
1716are not validated by any JVMs. The analysis results are
summarized in Table IV.
As shown in the table, their root causes have three cate-
gories. The Ô¨Årst category is missing NULL check. We found
that a large number of cases are due to the missing NULL check
ofjvalue . It seems that no JVMs properly validate argument
lists like jvalue . Because dereferencing null values may
cause signiÔ¨Åcant errors, we believe that all JVMs should
validate them. The other two categories are missing size check
and type check. For example, the FromReflectedMethod
JNI function expects to receive an object of type
java.lang.reflect.Method/Constructor . If it re-
ceives an object of different type, JVMs should throw
an error. However, no JVMs validates this property. It is
particularly strange that OpenJ9 does not validate such a
case because it throws an error for similar cases. For in-
stance, the FromReflectedField JNI function does not
receive an object of type java.lang.reflect.Field ,
OpenJ9 throws an error with the following message: Argu-
ment #2 is not a subclass of java/lang/reÔ¨Çect/Field . OpenJ9
should throw an error with an appropriate message for the
FromReflectedMethod function as well.
F . Threats to Validity
To evaluate the quality of the -Xcheck:jni option on main-
stream JVMs, we leveraged unspeciÔ¨Åed cases. We adopted
a systematic and automated approach to Ô¨Ånd unspeciÔ¨Åed
cases from the JNI speciÔ¨Åcation. The only manual part in
Ô¨Ånding unspeciÔ¨Åed cases is transforming the JNI speciÔ¨Åcation
into our DSL. Manual transformation may contain human
errors leading to incorrect transformation. However, we believe
that our transformation is correct because we considered
only Chapter 4 of the JNI speciÔ¨Åcation, which is written in
a well-structured style using speciÔ¨Åc patterns. Furthermore,
we manually investigated automatically produced results by
JUSTG EN. Our manual investigation conÔ¨Årmed that the re-
sults are accurate, which indicates that the JNI speciÔ¨Åcation is
correctly transformed. The results of our manual evaluation are
trustworthy because external reviewers such as JVM vendors
validated them as well. Note that if the speciÔ¨Åcation is written
in a structural way like the JavaScript speciÔ¨Åcation, it may be
possible to make JUSTGen fully automatic [19].
Finally, because the transformed speciÔ¨Åcation in the DSL is
publicly available, researchers can reuse and validate it. Note
that JUSTG ENdoes not prove the correctness of -Xcheck:jni
implementations, but tests them, which may lead to false
positives and false negatives.
V. R ELATED WORK
JVM VeriÔ¨Åcation . Testing JVMs to ensure that they work
consistently with each other is crucial to support Java‚Äôs
slogan ‚ÄúWrite Once Run Anywhere.‚Äù The existing research
proposed methodologies to automatically generate test cases
for veriÔ¨Åcation of JVMs. Sirer and Bershad [20] developed
lava, a domain speciÔ¨Åc language for specifying productiongrammars to generate test cases for a JVM. They demon-
strated the effectiveness of lava when it is used with other
testing techniques by showing high code and value coverage
achievements. Yoshikawa et al. [21] implemented a generator
for Java classes that is Ô¨Ånite and executable on the Java runtime
environment. Similarly, Chen et al. [22] introduced classfuzz,
which generates invalid Java classes to reveal defects in the
startup processes of JVMs. classfuzz leverages predeÔ¨Åned
mutation operators to mutate seeding Java classes and Markov
Chain Monte Carlo (MCMC) sampling to select appropriate
mutation operators. On the other hand, classming [23] also
proposed by Chen et al generates executable Java classes in
order to verify execution engines of JVMs. classming also
leverages mutation operators to change the control and data
Ô¨Çows of bytecode to generate semantically different test cases.
Freund and Mitchell [24] introduced a type system to generate
Java classes that can test an implementation of a bytecode
veriÔ¨Åer.
Even though the above research can generate efÔ¨Åcient test
cases for verifying startup processes, execution engines, and a
bytecode veriÔ¨Åer of JVMs, they are not suitable for verifying
implementations of JNI interoperations on JVMs. Indeed, no
research exists that proposes an efÔ¨Åcient technique to generate
test cases for testing JNI interoperations.
JNI VeriÔ¨Åcation Researchers have tried to improve the safety
and reliability of JNI programs. Several papers address the
discrepancies in exception handling of Java and native code.
The exceptions from native code of JNI programs do not get
handled by JVMs immediately, but they are handled by JVMs
only after the native code Ô¨Ånishes its execution. Such different
semantics can lead to mishandling of exceptions in JNI pro-
grams. Li and Tan [25] proposed a static analysis framework
that examines exceptions and identiÔ¨Åes bugs in JNI programs.
Tan [26] proposed an operational semantics for a core of
the JNI. The work includes the formal semantics of handling
shared heap during cross-language function calls, exception
handling, and garbage collection. Because programs written
in C may be unsafe due to the lack of type system while
programs written in Java are type-safe, native code written in
C may make JNI programs unsafe. To ensure type safety of JNI
programs, Tan et al. [27] proposed SafeJNI. Tan and Croft [28]
also performed an empirical study of native codes in JDK.
Leveraging a large number of native code in JDK with various
static analysis techniques and manual inspection, the authors
identiÔ¨Åed new bugs and security issues in the native code of
JDK. Gu et al. [29] demonstrated another security issues in JNI
programs. They introduced the JGRE attack and proposed a
defense mechanism. Wei et al. [30] proposed a static analysis
framework that can analyze JNI programs. They introduced
JN-SAF that performs an inter-language dataÔ¨Çow analysis to
Ô¨Ånd security Ô¨Çaws in JNI programs. Lee et al. [31] devised
a static analysis technique utilizing both modular and whole
program analyses to analyze multilingual programs. Using the
technique, they proposed a static analyzer that detects possible
programmer errors in JNI interoperation.
1717Even though the existing research attempted to improve
the safety and reliability of JNI programs, none of them
systematically studied the unspeciÔ¨Åed behaviors in the JNI
speciÔ¨Åcation and their actual implementations on mainstream
JVMs.
VI. C ONCLUSION
JVMs provide a powerful run-time debug feature, the
-Xcheck:jni option, for developers to detect interoperation
bugs in JNI programs. However, some bugs may remain
unidentiÔ¨Åed even after intensive testing, due to the insufÔ¨Åcient
validation capability of the debug feature. In this paper, we
present a semi-automated approach to evaluate the validation
capability and impacts of the -Xcheck:jni option on various
JVMs. From the JNI speciÔ¨Åcation, we manually translated the
core functionality of JNI functions to our DSL, JUSTG EN
automatically discovers unspeciÔ¨Åed cases and generates test
code executing the cases. Then, we execute the test code on
Ô¨Åve mainstream JVMs and categorize the execution results to
assess their validation capability. In our empirical evaluation,
JUSTG ENdiscovered 34,990 unspeciÔ¨Åed cases that the JNI
speciÔ¨Åcation does not cover. We identiÔ¨Åed that 5,972 unspec-
iÔ¨Åed cases could not be validated by Hotspot‚Äôs debug feature,
5,968 by Zulu and Corretto, 5,928 by GraalVM, and 1,012 by
OpenJ9. These unspeciÔ¨Åed cases can cause ciritical run-time
errors due to violation of the Java type system and memory
corruption. We reported the validation issues of the debug
feature to corresponding JVM vendors with 792 unspeciÔ¨Åed
cases, and 563 cases among them have been Ô¨Åxed and the
remaining ones are planned to be Ô¨Åxed. We believe that our
study improves the validation capability of the -Xcheck:jni
option and the quality of JNI programs.
ACKNOWLEDGMENT
This work was supported by National Research Founda-
tion of Korea (NRF) (Grants NRF-2017R1A2B3012020 and
2017M3C4A7068177).
REFERENCES
[1] Oracle, ‚ÄúJava SE HotSpot at a Glance,‚Äù https://www.oracle.com/
technetwork/java/javase/tech/index-jsp-136373.html, 2019.
[2] Eclipse, ‚ÄúOpenJ9,‚Äù https://www.eclipse.org/openj9/, 2020.
[3] Azul System, ‚ÄúAzul Zing,‚Äù https://www.azul.com/products/zing/, 2020.
[4] Oracle, ‚ÄúGraalVM,‚Äù https://www.graalvm.org/, 2020.
[5] ‚Äî‚Äî, ‚ÄúJava SE Documentation - JNI Design Overview,‚Äù https://docs.
oracle.com/en/java/javase/11/docs/specs/jni/design.html, 2018.
[6] IBM, ‚ÄúTroubleshooting: JNI Checklist,‚Äù https://www.ibm.com/support/
pages/troubleshooting-jni-checklist, 2020.
[7] Oracle, ‚ÄúThe -Xcheck:jni Option,‚Äù https://docs.oracle.com/javase/8/docs/
technotes/guides/troubleshoot/clopts002.html, 2020.
[8] ‚Äî‚Äî, ‚ÄúJava SE Documentation - JNI Functions,‚Äù https://docs.oracle.
com/en/java/javase/11/docs/specs/jni/functions.html, 2018.
[9] E. Clarke, O. Grumberg, S. Jha, Y . Lu, and H. Veith, ‚ÄúCounterexample-
guided Abstraction ReÔ¨Ånement,‚Äù in International Conference on Com-
puter Aided VeriÔ¨Åcation . Springer, 2000, pp. 154‚Äì169.
[10] Microsoft Research, ‚ÄúThe Z3 Theorem Prover,‚Äù https://github.com/
Z3Prover/z3, 2020.
[11] T. Freeman and F. Pfenning, ‚ÄúReÔ¨Ånement Types for ML,‚Äù in Proceedings
of the ACM SIGPLAN 1991 Conference on Programming Language
Design and Implementation , 1991, pp. 268‚Äì277.
[12] Sungjae Hwang, ‚ÄúJNI SpeciÔ¨Åcation Expressed in Our DSL,‚Äù https://
github.com/sjmini/justgen/blob/main/test/rule, 2021.[13] ‚Äî‚Äî, ‚ÄúExplanation of ReÔ¨Ånements,‚Äù https://github.com/sjmini/justgen/
blob/main/test/reÔ¨Åne meaning, 2021.
[14] Oracle, ‚ÄúJava SE Documentation - JNI Types and Data Structures,‚Äù https:
//docs.oracle.com/en/java/javase/11/docs/specs/jni/types.html, 2018.
[15] Docker Inc., ‚ÄúDocker,‚Äù https://www.docker.com/, 2020.
[16] JReBel, ‚Äú2020 Java Technology Report,‚Äù https://www.jrebel.com/blog/
2020-java-technology-report, 2020.
[17] OWASP, ‚ÄúBuffer OverÔ¨Çow,‚Äù https : / / owasp . org / www-community /
vulnerabilities/Buffer OverÔ¨Çow, 2020.
[18] Sungjae Hwang Sungho Lee, Jihoon Kim, Sukyoung Ryu,
‚ÄúA Study of UnspeciÔ¨Åed Cases in the JNI SpeciÔ¨Åcation,‚Äù
https://github.com/sjmini/justgen/blob/main/supplementary/, 2021.
[19] J. Park, J. Park, S. An, and S. Ryu, ‚ÄúJiset: Javascript ir-based semantics
extraction toolchain,‚Äù in 2020 35th IEEE/ACM International Conference
on Automated Software Engineering (ASE) . IEEE, 2020, pp. 647‚Äì658.
[20] E. G. Sirer and B. N. Bershad, ‚ÄúUsing Production Grammars in Software
Testing,‚Äù ACM SIGPLAN Notices , vol. 35, no. 1, pp. 1‚Äì13, 1999.
[21] T. Yoshikawa, K. Shimura, and T. Ozawa, ‚ÄúRandom Program Generator
for Java JIT Compiler Test System,‚Äù in Third International Conference
on Quality Software, 2003. Proceedings. IEEE, 2003, pp. 20‚Äì23.
[22] Y . Chen, T. Su, C. Sun, Z. Su, and J. Zhao, ‚ÄúCoverage-directed
Differential Testing of JVM Implementations,‚Äù in Proceedings of the
37th ACM SIGPLAN Conference on Programming Language Design
and Implementation , 2016, pp. 85‚Äì99.
[23] Y . Chen, T. Su, and Z. Su, ‚ÄúDeep Differential Testing of JVM Implemen-
tations,‚Äù in 2019 IEEE/ACM 41st International Conference on Software
Engineering (ICSE) . IEEE, 2019, pp. 1257‚Äì1268.
[24] S. N. Freund and J. C. Mitchell, ‚ÄúA Type System for the Java Bytecode
Language and VeriÔ¨Åer,‚Äù Journal of Automated Reasoning , vol. 30, no.
3-4, pp. 271‚Äì321, 2003.
[25] S. Li and G. Tan, ‚ÄúFinding Bugs in Exceptional Situations of JNI
Programs,‚Äù in Proceedings of the 16th ACM Conference on Computer
and Communications Security , 2009, pp. 442‚Äì452.
[26] G. Tan, ‚ÄúJNI Light: An Operational Model for the Core JNI,‚Äù in Asian
Symposium on Programming Languages and Systems . Springer, 2010,
pp. 114‚Äì130.
[27] G. Tan, A. W. Appel, S. Chakradhar, A. Raghunathan, S. Ravi, and
D. Wang, ‚ÄúSafe Java Native Interface,‚Äù in Proceedings of IEEE Interna-
tional Symposium on Secure Software Engineering , vol. 97. Citeseer,
2006, p. 106.
[28] G. Tan and J. Croft, ‚ÄúAn Empirical Security Study of the Native Code
in the JDK.‚Äù in Usenix Security Symposium , 2008, pp. 365‚Äì378.
[29] Y . Gu, K. Sun, P. Su, Q. Li, Y . Lu, L. Ying, and D. Feng, ‚ÄúJGRE:
An Analysis of JNI Global Reference Exhaustion Vulnerabilities in
Android,‚Äù in 2017 47th Annual IEEE/IFIP International Conference on
Dependable Systems and Networks (DSN) . IEEE, 2017, pp. 427‚Äì438.
[30] F. Wei, X. Lin, X. Ou, T. Chen, and X. Zhang, ‚ÄúJN-SAF: Precise
and EfÔ¨Åcient NDK/JNI-aware Inter-anguage Static Analysis Framework
for Security Vetting of Android Applications with Native Code,‚Äù in
Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security , 2018, pp. 1137‚Äì1150.
[31] S. Lee, H. Lee, and S. Ryu, ‚ÄúBroadening horizons of multilingual
static analysis: Semantic summary extraction from c code for jni
program analysis,‚Äù in 2020 35th IEEE/ACM International Conference
on Automated Software Engineering (ASE) . IEEE, 2020, pp. 127‚Äì137.
1718