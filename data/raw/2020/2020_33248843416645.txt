Multiplex Symbolic Execution: Exploring Multiple Paths by
Solving Once
Yufeng Zhang∗
College of Computer Science and
Electronic Engineering, Hunan
University
Changsha, China
yufengzhang@hnu.edu.cnZhenbang Chen∗
College of Computer, National
University of Defense Technology
Changsha, China
zbchen@nudt.edu.cnZiqi Shuai
College of Computer, National
University of Defense Technology
Changsha, China
szq@nudt.edu.cn
Tianqi Zhang
College of Computer, National
University of Defense Technology
Changsha, China
zhangtianqi18@nudt.edu.cnKenli Li
College of Computer Science and
Electronic Engineering, National
Supercomputing Center in Changsha,
Hunan University
Changsha, China
lkl@hnu.edu.cnJi Wang
College of Computer, State Key
Laboratory of High Performance
Computing, National University of
Defense Technology
Changsha, China
wj@nudt.edu.cn
ABSTRACT
Pathexplosionandconstraintsolvingaretwochallengestosym-
bolicexecution’sscalability.Symbolicexecutionexploresthepro-
gram’spathspacewithasearchingstrategyandinvokestheunder-
lyingconstraintsolverinablack-boxmannertocheckthefeasibilityof a path. Inside the constraint solver, another searching procedureis employed to prove or disprove the feasibility. Hence, there exists
the problem of double searchings in symbolic execution. In this
paper, we propose to unify the double searching procedures to im-
prove the scalability of symbolic execution. We propose Multiplex
Symbolic Execution (MuSE) that utilizes the intermediate assign-
ments during the constraint solving procedure to generate newprogram inputs. MuSEmaps the constraint solving procedure to
the path exploration in symbolic execution and explores multi-
plepathsinonetimeofsolving.Wehaveimplemented MuSEon
twosymbolicexecutiontools(basedonKLEEandJPF)andthree
commonlyusedconstraintsolvingalgorithms.Theresultsoftheex-tensive experiments on real-world benchmarks indicate that MuSE
has orders of magnitude speedup to achieve the same coverage.
CCS CONCEPTS
•Software and its engineering →Software verification and
validation;
∗The first two authors contributed equally to this work and are co-first authors. Zhen-
bang Chen and Ji Wang are the corresponding authors.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416645KEYWORDS
symbolic execution, constraint solving, mathematical optimization
ACM Reference Format:
YufengZhang,ZhenbangChen,ZiqiShuai,TianqiZhang,KenliLi,andJi
Wang. 2020. Multiplex Symbolic Execution: Exploring Multiple Paths by
SolvingOnce.In 35thIEEE/ACMInternationalConferenceonAutomatedSoft-
ware Engineering (ASE ’20), September 21–25, 2020, Virtual Event, Australia.
ACM,NewYork,NY,USA,12pages.https://doi.org/10.1145/3324884.3416645
1 INTRODUCTION
Symbolic execution [ 18,21,38] is a precise program analysis tech-
nique that has been successfully applied to many software engi-
neeringactivities,includingautomaticsoftwaretesting[ 5,41],bug
finding [19], program repair [ 10],etc. One challenge of symbolic
executionisthescalabilityproblemcausedbypathexplosionand
constraint solving.
During symbolic execution, each variable in program Phas a
symbolicor concretevalue. Fornon-branchstatements, symbolic
executiondoessymbolicorconcretecalculationsandupdatesthe
symbolic or concrete values of the variables. When executing a
branch statement br, symbolic execution generates the path condi-
tion(PC)foreachbranchof br.Thepathconditionofabranch b
(denotedby PC(b)=/logicalandtext.1n
i=1Ci)isaconstraintin qualifier-free first-
order logic that encodes the feasibility of the program path to b,
andCnis the symbolic condition of b. Symbolic execution invokes
a constraint solver [ 11,16,40] to check the satisfiability [ 23]o f
eachbranch’s PC.IfPC(b)issatisfiable,thentheprogrampathto
bisfeasible,andsymbolicexecutionwillcontinuetoexecutethe
statementalong b;otherwise,itisinfeasible, i.e.,noinputcandrive
the program to b, and symbolic execution abandons b. In this way,
symbolic execution systematically explores the path space of P.
On one hand, the path number explodes exponentially in the num-
ber of branch statements. Onthe other hand, constraint solving is
well-known to be hard [ 23]. Another complexity explosion occurs
inside of the constraint solver. As shown in Figure 1, there exist
double explosions in symbolic execution. Such double explosions
8462020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
path space of program P
solution space SPC
symbolic execution engineconstraint solversolution: C1/\C2/\C3
partial solution: ¬C1/\~C2
bC1
C2
C3partial solution: ¬C1/\C2/\~C3
Figure 1: Double explosions in symbolic execution proce-
dure. MuSEgenerates multiple test inputs from partial so-
lutions with only one time of constraint solving. Partial so-lutions can be used to trigger off-the-path branches on the
current path.
obstruct the application of symbolic execution to larger real-world
programs.
Symbolic execution explores the path space with a search strat-
egy, such as depth-first search (DFS) and breadth-first search (BFS).
The underlying constraint solver also employs an internal search-
ing procedure in the solution space to decide the satisfiability of
pathconditions.Essentially,bothofthepathspaceandthesolution
spacerepresent P’sinputspace SI.Theconditionsof P’sbranch
statementssplit SIintodifferentparts.Eachpartcanberepresented
byapath.Forapathcondition PC(b)=/logicalandtext.1n
i=1Ci,thesolutionspace
SPCcontains all the possible assignments to the input variables in
PC(b).Whensolving PC(b),theconstraintsolversearches SPC,and
hencesearches SI.Duringthissearchingprocedure,thesolvermay
searchtheinputspacecorrespondingtootherpathsof P.However,
thesolveronlyreturnsthefinalsolutionsatisfying PC(b),ifSAT,
or returns UNSAT. Therefore, SIis doubly searched in the stack of
symbolicexecutionbythepathspaceexplorationandtheunder-
lying constraint solver. It is desirable to unify the two searching
procedures to improve the scalability.
In this paper, we propose Multiplex Symbolic Execution (MuSE)
towards eliminating the redundant searching in dynamic symbolic
execution(DSE).Theprincipleofourmethodisthatweleverage
theconstraintsolvertosearchthepathspacedirectlyviagenerating
multiple test inputs in one time of solving. For a path condition
PC(b)=/logicalandtext.1ni=1Ci, we call a point αin the solution space SPCa
partialsolution ifαsatisfiesasubsetoftheconstraintsin PC(b).A s
shown in Figure 1, the solver may touch plenty of partial solutions
before finding a solution or concluding the unsatisfiability. We can
usepartialsolutionsasthetestinputsforexploring P’sotherpaths.
In this way, MuSEmaps the constraint solving procedure to the
path space exploration, and reduces the redundant searching to
boost the whole symbolic execution procedure.
Partial solutions exist in a wide range of constraint solving algo-
rithms. We have instantiated the idea of MuSEto three constraint
solving methods to generate partial solutions: i) Simplex-based
quantifier-freelinearintegerarithmetic(QF_LIA)constraintsolving[13,25], ii) abstraction refinement based quantifier-free array and
bit-vector (QF_ABV) constraint solving [ 16], and iii) optimization-
basedfloating-pointconstraintsolving[ 15,40].Besides,wehave
implemented MuSEon two DSE engines based on KLEE [ 5] and
Symbolic PathFinder (SPF) [ 33] for C and Java programs, respec-
tively. We have applied our prototypes to real-world C and Java
programs. The evaluation results indicate the effectiveness and
efficiency of MuSE.
The main contributions of this paper are:
•Wepropose MuSEtoutilizethepartialsolutionsduringcon-
straint solving to generate multiple test inputs for exploring
multiple paths by solving once.
•We have instantiated the idea of partial solution to three
constraint solving methods and implemented MuSEon two
DSE engines for C and Java programs.
•We have carried out extensive experiments on real-world C
andJavaprograms.Theexperimentalresultsindicatethat
MuSEachieves one or two orders of magnitude speedup on
the three constraint solving methods for reaching the same
code coverage.
We organize the remainders of this paper as follows. Section
2motivates MuSEbyaSimplex-basedsolvingmethod.Section3
presents MuSEand its instantiations on three solving methods.
Section 4 explains the implementation of MuSEand the experi-
ments on real-world benchmarks. Section 5 reviews the related
work. Section 6 concludes the paper.
2 MOTIVATING EXAMPLE
In this section, we motivate the principle of MuSE. Figure 2 shows
a Java function startthat receives two parameters and has four
paths. In each path, the program prints a different number. We call
thesefourpathas p1∼p4,respectively.NowweuseDSEtoexplore
the path space. Suppose that the initial input is {x=1,y=3}.
Thenthefirstpathis p1thatcoversthelines {2,3,4,6,7}.Thepath
condition of p1isϕ1=x+y≥2∧2y−x≥1∧2x−y<0. If
we use DFSsearching strategy, thelast branch is flipped.The new
path condition ϕ2=x+y≥2∧2y−x≥1∧2x−y≥0 is feed
into off-the-shell constraint solver. Suppose that the solution of
ϕ2is{x=1,y=1}, then the second path is p2that covers the
lines{2,3,4,5}. Similarly, p3andp4will be explored. In total, DSE
invokes the constraint solver three times for p2∼p4.
Sincealltheconstraintsarelineararithmetic,wesupposethat
thesolverusestheSimplex-basedQF_LIAtheorysolvingalgorithm
[23,25]. The algorithm first considers all the integer variables in
the constraints as real variables and uses Simplex-based linear
realarithmeticsolvingalgorithmtosolvetheconstraints.Ifthere
is no solution, the constraints are unsatisfiable. If there exists asolution and the values in the solution are already integers, the
algorithmreturnsthesolution;otherwise,thealgorithmaddsthe
integer requirement constraints gradually and employs Simplex
procedures again to find the integer solution.
TheSimplexalgorithmmaintainsanassignment αtostorethe
values of variables1. If the assignment does not satisfy the con-
straints, the algorithm changes the assignment so that at least one
unsatisfiedconstraintbecomestrue.Thisprocedurecontinuesuntil
1Details of Simplex algorithm is discussed in Section 3.2.
8471public void start(int x,inty){// float x, float y
2if( x+y> =2 ){
3 if( 2*y-x> =1 ){
4 if( 2*x-y> =0 ){
5 System.out.println("#2");
6 }else{
7 System.out.println("#1");
8 }
9 }else{
10 System.out.println("#3");
11 }
12}else{
13 System.out.println("#4");
14}
15}
Figure 2: Motivating Example
Figure 3: Branch statements split the input space into dif-
ferent parts corresponding to different paths. The black ar-rowsshowhowSimplexsearchesthesolutionspacefor ϕ
2=
x+y≥2∧2y−x≥1∧2x−y≥0. The solving procedure
covers three points corresponding to the paths p4,p3andp2,
respectively.
alltheconstraintsaresatisfiedorreturns UNSAT.Forexample,sup-
posethatthepathconditionis ϕ2=x+y≥2∧2y−x≥1∧2x−y≥0
and the initialassignment is α0={x=0,y=0}. Sinceα0does not
satisfyx+y≥2and2y−x≥1,Simplex changestheassignment
toα1={x=2,y=0}by the so-called pivotoperation [ 23,25],
such that x+y≥2 is satisfied. Now Simplex validates assignment
α1andfindsthat2 y−x≥1isviolated.Inthenextstep,thepivot
operation changes assignment α1toα2={x=1,y=1}. Finally,
alltheconstraintsaresatisfiedand α2isalreadyanintegersolution.
So,α2is returned to the DSE engine for generating the input for
pathp2. In vanilla DSE, the constraint solver is used as a black box,
onlyα2is visible to the DSE engine, and the DSE engine generates
only one test case from one time of constraint solving.
In contrast, MuSEuses the constraint solver in a white-box
manner.AsshowninFigure3,theinputspaceof start(x-yplane)is split into 7 parts by the three lines corresponding to the three
branchstatements.Eachofpaths p1∼p3correspondstoonepart
andp4corresponds to four parts. Simplex algorithm leverages the
linearpropertyoftheconstraintsandsmartlyexploresthesolution
space. We can say that Simplex algorithm is exploring the path
spaceoftheprogram.Sincetheintermediateassignments α0and
α1satisfysubsetsoftheconstraintsin ϕ2,theycantrigger p4andp3,
respectively.Theseintermediateassignmentsare partialsolutions.
DSE can utilize these partial solutions to steer the exploration
alongoff-the-pathbranchesonthecurrentpath.Forexample,whensolvingthefirstpathcondition
ϕ2,MuSEgeneratestwoextrainputs
from the partial solutions α0andα1, and the executions of these
twoinputstrigger p4andp3,respectively.Hence,byutilizingpartial
solutions, MuSEonly needs one time of constraint solving to explore
all the paths.
Withthesupportofpartialsolutions, MuSEmapstheconstraint
solving procedure to thepath exploration in DSE by releasingthe
power ofconstraint solver.2The keyrequirement of MuSEis that
the underlying constraint solver can generate partial solutions.
Actually, partial solutions widely exist in the current constraint
solvingmethods(c.f. Section3.5).Besides,wewillseeintheexperi-
ments(c.f. Section4)that MuSEcangeneratehundredsofpartial
solutions with one time of constraint solving in practice.
3 METHOD
In this section, we first show how MuSEworks with dynamic sym-
bolic execution framework. Then we elaborate on how to generate
partial solutions in the existing constraint solving algorithms.
3.1 DSE With MuSE
Algorithm1showstheprocedureofDSEwith MuSE.Theinputsare
theprogram Pandaninitialinputseed I0.Tstoresallthegenerated
test inputs yet to be executed. The main body of the algorithm is a
repeat-until loop. In the beginning, the forloop selects all the test
inputs in Tand execute the program in a concolic manner [ 18,38]
(line5).Duringtheexecution,thealgorithmcancollectthecoverage
information, if needed. The function saveUnexploredBranches saves
all the unexplored branches on the current path pintoB(line 7).
Thenonebranch bisselectedfrom Baccordingtoasearchstrategy
(line9).Hereanystrategiescanbeusedtoprioritizethebranchesin
B,suchasDFSandBFS.Thenthefunction pathCondition generates
thepathcondition ϕalongb(line10).Thekeyofourmethodisthat
the algorithm uses an extended constraint solver which returnsa triple (res ,solution,partial-solutions ) (line 11). When resisSAT,
solutionisthetargettestinputthatcansteertheexecutionalong
b. Then the solutionis stored into Tfor future executions (line 13).
Otherwise, resisUNSATorUNKNOWN, solutionis set asnull.W e
assume that the underlying constraint solver may generate partial
solutions no matter whether the final solution can be found or not.
Therefore, partial solutions are also stored into T, if any (line 16).
So, the DSE procedure can get multiple inputs by invoking the
constraintsolveronce.Evenforanunsatisfiablepathcondition,the
2Multiplex means reusing a shared scarce resource by sending multiple messages
atonce,whichisanalogtoexploringmultiplepathsbysolvingonce.Sowecallour
method Multiplex Symbolic Execution (MuSE).
848Algorithm 1 Multiplex Dynamic Symbolic Execution
1:Input:Program P, initial input seed I0
2:T={I0}//test cases to be executed
3:B=∅// open branches to be explored
4:repeat
5:for allI∈Tdo
6:p=concolicExecute (P,I)
7:saveUnexploredBranches (p,B)
8:end for
9:b=searchStrategy (B)
10:ϕ=pathCondition (b)
11:(res,solution,partial-solutions )=solving (ϕ)
12:ifres=SATthen
13:T=T∪{solution}
14:end if
15:/∗savepartial-solutions whetherSATor not, if any∗/
16:T=T∪partial-solutions
17:untilB=∅∨stopCriterion ()
expensivecomputationspentonconstraintsolvingwouldnotbe
wasted.
The key to the success of our algorithm is that the constraint
solver can generate partial solutions. A wide range of constraint
solving algorithms conform a trial and error mode. Thus we can
extract plenty of partial solutions from the solving procedure. In
the following of this section, we firstly focus on several commonly
usedconstraintsolvingalgorithmsinsymbolicexecution.Thenwebrieflydiscussmoreconstraintsolvingalgorithms.Wewillseethatthenotionofpartialsolutionisauniversalprincipleapplicabletoa
wide range of constraint solving algorithms.
3.2 Partial Solutions in Simplex
Simplex is an old and efficient constraint solving method for linear
arithmetic[ 13,25].AlthoughtheworstcaseofSimplex’scomplexity
isexponential,itiswidelyusedinpractice.Forexample,oneofthe
state-of-the-art SMT solver Z3 [11] uses Simplex.
Algorithm 2 shows how partial solutions can be supported by
the basic procedure of general Simplex algorithm for quantifier
freelinearrealarithmatic(QF_LRA).Theinputsofthealgorithm
isasetof mlinearconstraints S.Withoutconsideringtheprepro-
cess of the constraint solver, we assume that Scorresponds to m
pathconstraintsin ϕ.Atthebeginningoftheprocedures,the i-th
constraint Σxj∈Naijxj⊿/triangleleftRi(⊿/triangleleft∈{=,≥,≤})3is transformed into
the general form Σxj∈Naijxj−xi=0∧xi⊿/triangleleftR, wherexiand
xjare real variables. For example, x+y≥2 is transformed into
x+y−s=0∧s≥2.Afterthepreprocessing,theconstraintsystem
Sis in the general form
Ax=0andm/logicalanddisplay.1
i=1li≤xi≤ui (1)
whereAisthem×(n+m)coefficientmatrixand xi∈B.Theelements
ofBandNare called basic variables and non-basic variables with
the real number set as domains. The algorithm represents Awith a
3Strictinequalitiesanddisequalitiesareprocessedbyadditionaltricks.Moredetails
can be referred to [13].Algorithm 2 General Simplex with Partial Solutions
1:Input:A set of constraints in linear real arithmetic
2:Transform Sinto general form
3:initialize assignment α
4:partial-solutions =∅
5:whileTruedo
6:ifno basic variable violates bounds then
7:return (SAT, α,partial-solutions )
8:else
9:partial-solutions =partial-solutions ∪{α}
10:ifcan findxiandxjfor pivoting then
11: pivot(xi,xj)
12: updateα
13:else
14: return (UNSAT, null,partial-solutions )
15:end if
16:end if
17:end while
tableau where the columns and rows correspond to non-basic and
basic variables respectively.
Simplex algorithm maintains an assignment α:B∪N→Q
whereQis rational numbers set. Initially, all variables are set to
zero(line3).Atline6,thealgorithmcheckswhetherallthebounds
in equation 1 are satisfied. If yes, the algorithm returns the current
assignmentasthesolution.Otherwise,thecurrentassignment α
violatesatleastoneboundinequation1.Herewealsoknowwhich
constraints in ϕare satisfied. Suppose that the first kconstraints
aresatisfied,andthe k+1constraintisnot.Thecurrentassignment
αcan be used as the test input steering the execution along the
(k+1)-thopenbranchinthecurrentpath p.Therefore,thecurrent
assignmentisstoredinthepartialsolutionset(line9).Simplexis
bothsoundandcomplete.Inthenextstep,thealgorithmschecks
whether there exist a basic variable xiand a non-basic variable
xjcan be pivoted. If not, the constraint system Sis unsatisfiable,
andthealgorithmreturns UNSATandthecurrentpartial-solutions.
Otherwise,theSimplexalgorithmchanges Ainthepivotoperation.
Herexjis solved in the row ias
xj=xi
aij−/summationdisplay.1
xk∈N−{xj}aikxk
aij,(aij/nequal0) (2)
In all other rows except row i,xjis replaced by equation 2 such
thatxjbecomesbasicvariablesand xibecomesnon-basicvariables.
Heretheassignment α(xj)ischangedsothat xisatisfiesitsbounds.
Asthewhileloopcontinues,moreandmoreboundsinequation
1maybesatisfied.Therefore,wecanrecordthecurrentassignment
before each pivot operation as a partial solution.
In this paper, we consider QF_LIA constraints, which can be
solved by a Simplex-based method [ 23]. The procedure first con-
sidersthevariablesasrealvariablesanduseSimplextosolvethe
constraint.Ifnosolution,theconstraintisunsatisfiable.Ifthereisa
solution, the procedure return the solution if all the variables have
integer values. Otherwise, the procedure selects a variable that has
anon-integervalueandaddtheconstraintsofintegerrequirements.
Then,theprocedureemploysSimplexagaintosearchtheinteger
solution. Hence, Simplex is the underlying searching procedure for
849solving QF_LIA. Solving a QF_LIA constraint may invoke Simplex
procedure multiple times. Hence, we record partial solutions for
QF_LIA constraint solving in the underlying Simplex procedures.
3.3 Partial Solutions in Array Theory Solving
Arrayswidelyexistinprograms.Existingsymbolicexecutors[ 5,6]
usearraytheoryforrepresentingthearrayoperationsinprograms.
Reasoning about array can be very complex when both index and
arrayelementsaresymbolicvalues.In thissubsection,wefocuson
how to generate partial solutions in array theory solving.
Abstract/refinement-based array theory solving [ 16] is the state-
of-the-art solving method. Several mainstream QF_ABV SMT tools
implements this method, such as STP [ 16] and Boolector [ 31]. It is
natural to generate partial solutions in the abstraction/refinement
loop. Algorithm 3 shows the procedure. At the beginning, formula
fis converted to an abstract version faby the function abstract
(line 3). In fact, fais a relaxation of f, where the constraints de-
rived from array axioms [ 23] are omitted, so fimpliesfa. Here
weassumethattheconstraintsareexpressedinbit-vectortheory.
The algorithm feeds fainto a SAT-based bit-vector solver. If fa
is unsatisfiable, then fis unsatisfiable too. Otherwise, the algo-
rithm validates the solution Maoffaonf.I fMais also a solution
off, then the algorithm returns Maas the solution. Otherwise,
fais refined so that more constraints derived from array axioms
are added as conjunctives to fa(line 18). The loop continues until
the algorithmterminates. The abstractversion fabecomes fif all
constraints derived from array axioms are added into fa.S ot h e
algorithm always terminates.
It is straightforward to extract partial solutions from this ab-
stract/refinementloop.Ineachloopiteration,westorethesolution
Maoftheabstractformula faaspartialsolution(line13).Infact,
we can also modify the SAT-based bit-vector solver to obtain more
partialsolutionsatline5.Wewilldiscussthistopicinsubsection
3.5.
3.4 Partial Solutions in Optimization-based
Solving
Floating-pointarithmeticisa challengeforconstraintsolving.Re-
cently,mathematicaloptimizationbasedsolvinghasbeenproposed
forfloating-pointarithmetic,suchasXSAT[ 15]andCORAL[ 40].
Optimization-basedconstraintsolvingintroducesthetechniques
from search-based testing, where the constraintsaretransformed
into an objective function for the optimization algorithms. The
global minimum of the objective function corresponds to the solu-
tiontothesolvingproblem.Thus,anymathematicaloptimization
algorithmscanbeused.Forexample,XSatusesMonteCarloMarkov
Chain(MCMC)methodtofindtheglobalminimum[ 15].CORAL
uses meta-heuristic algorithms, including random search or par-
ticle swarm optimization [ 40]. In this subsection, we take XSat
asanexampletoshowhowpartialsolutionscanbesupportedin
optimization-based constraint solving algorithms.
XSat transforms the constraints solving problem as follows.
Given a conjuctive normal form of constraint:
F=/logicalanddisplay.1
j∈J/logicalordisplay.1
i∈Iei,j⊿/trianglelefte/prime
i,j(⊿/triangleleft∈{==,≤,≥,<,>, /nequal})(3)Algorithm 3 Abstract/Refinement-based Array Theory Solving
with Partial Soltions
1:Input:A conjunction of formulas fin bit vector and array
theory
2:partial-solutions =∅
3:fa= abstract( f)
4:whiletruedo
5:(res,Ma)=BVSolver( fa)
6:ifres=UNSATthen
7:return (UNSAT, null,partial-solutions )
8:else
9:v= validate( Ma,f)
10:ifv=truethen
11: return (SAT, Ma,partial-solutions )
12:else
13: partial-solutions =partial-solutions ∪{Ma}
14: f/primea=refine(fa)
15: iff/primea=fathen
16: return (UNSAT, null,partial-solutions )
17: else
18: fa=f/primea
19: end if
20:end if
21:end if
22:end while
the objective function (or fitness function) corresponding to Fis
OF=/summationdisplay.1
j∈J/productdisplay.1
i∈Id(⊿/triangleleft,ei,j,e/prime
i,j) (4)
wheredis defined in table 1.
Table 1: Fitness function
d(==,x,y)θ(x,y)
d(≤,x,y)x≤y?0:θ(x,y)
d(≥,x,y)x≥y?0:θ(x,y)
d(<,x,y)x<y?0:θ(x,y)
d(>,x,y)x>y?0:θ(x,y)
d(/nequal,x,y)x/nequaly?0:1
Hereθ(x,y)is the number of floating-point numbers between
aandb, representing the distance between xandy. The fitness
functionevaluateshowcloseatestinputsatisfiestheconstraints.
Sinceθ≥0,OFequalsto0ifandonlyif Fissatisfied.Forexample,
supposethat xandyinFigure2arefloating-pointvariables.The
landscapeoftheobjectivefunctionforpathcondition ϕ2=x+y≥
2∧2y−x≥1∧2x−y≥0 is shown in Figure 4. Note that
thelandscapeofmorecomplexpathconstraintscanbeverynon-
convex.Thereisnoguaranteethattheglobalminimumcanalways
be found.
Given the objective function, we can use any mathematical opti-
mization methods to find the global minimum, including simulatedannealing,particleswarmOptimization, etc.Forexample,XSatuses
simulatedannealingalgorithmtofindtheglobalminimum.Simu-
lated annealing specializes the general MCMC sampling method
850Figure4:Landscapeofthefitnessfunctioncorrespondingto
pathcondition ϕ2=x+y≥2∧2y−x≥1∧2x−y≥0.MCMC
finds the global minimum after 5 steps.
by using symmetric proposal distribution and exp(−f(x)/T)as the
densityoftargetunnormalizeddistribution,where fistheobjective
function and Tis the temperature [ 22]. In principle, we can extract
thelocalminimumortheintermediatepointsaspartial solutions
directly. As shown in Figure 4, we get the final solution (1.68,2.06)
in 5 steps, and also two partial solutions (0,0),(1.45,1.06)corre-
sponding to path p4 andp3 respectively. Besides, the mathematical
optimizationproceduremayproducemanypartialsolutions,and
some of them may trigger the same path. We can choose to extract
partialsolutionsonlyfromlocalminimums,whicharesupportedby
modern optimization algorithms. For example, the Basin-Hopping
algorithmextendsMCMCmethodbyemployingalocaloptimiza-
tion method in each Monte Carlo step [ 32]. Note that, due to the
stochasticnatureofMCMCmethods,itmaytakedifferentstepsbe-forethefinalsolutionisfoundinmultipleruns.Hence,wemayget
different partial solutions in different runs for the same constraint.
3.5 The Ubiquitous Partial Solutions
Untilnow,wehavediscussedhowpartialsolutionscanbesupported
in three commonly used constraint solving algorithms in symbolic
execution.Inpractice,symbolicexecutionbarelygeneratesdisjunc-
tion in path condition, which is a hurdle to the general DPLL(T)
frameworkinSMTsolvers[ 23].Forexample,thedefaultconstraint
solverSTP[ 16]usedbyKLEEdoesnotsupportdisjunctions.There-
fore,inthispaper,webrieflydiscusshowpartialsolutionscanbe
supported in several other constraint solving algorithms. Here we
take some of them as instances.
CDCLframework forSAT.ThepopularCDCLframeworkused
inSATsolverssearchesthesolutionspacebyadecide-backtrack
loop[23].CDCLmaintainsapartialassignmenttovariables.Ineach
loopiteration,thedecidephasechoosesanassignmenttoaselected
variable, then the backtrackingphase erases some assignments to
resolve conflicts. The loop continues until the partial assignment is
extended to a full assignment or return UNSAT. Obviously, we can
extract the partial assignments as partial solutions. Besides, fixed-
sized bit-vector theory solving uses SAT solving as the underlying
solver.Nowadays,bit-vectortheory[ 23]iswidelyusedinsymbolic
executiontopreciselymodelthecomputationsofmachinenumbers
in programs. Many mainstream SMT solvers support bit-vectortheory, such as Z3 [
11] and STP [ 16]. Bit-vector theory solvingconverts a bit-vector constraint to a propositional formula and
invokestheunderlyingSATsolverforsolving.Therefore,wecan
record the partial solutions during the SAT solving procedure and
generatepartialsolutionsforbit-vectorsolving.Hence,themethodinSection3.3forQF_ABVcanbeimprovedfurther,whichisleftto
be the future work.
DPLL(T) for Satisfiability Modulo Theories (SMT). DPLL(T)
framework extends the CDCL framework with the decision proce-
duresof backgroundtheories [ 23].DPLL(T) usesCDCLalgorithm
tofindasolutiontothepropositionalskeletonoftheconstraints
and then employs a constraint solver of background theories (e.g.,
Simplex for linear arithmetic) to find a solution. We can extractpartial solutions as in CDCL framework and constraint solving
algorithms for background theories.
Congruence-Closure algorithm for equality logic and unin-
terpreted functions. The Congruence-Closure algorithm constructs
the congruence-closed equivalence classes for terms [ 23]. If a dise-
quality constraint violates the equivalence relation, the algorithmsreturnUNSAT. We can construct partial solutions according to the
equivalenceclassesatanypointduringtheconstructionprocedure.
JFSis a recent constraint solving algorithm for floating-point
arithmetic [ 28]. JFS transforms floating-point constraints into a
program having a list of branch statements. The inputs satisfy the
constraintsonlywhenthefinalstatementoftheprogramiscovered.
Thus, the constraint solving problem is transformed into a state-
mentcoveringproblem.JFSemployscoverage-guidedfuzzing[ 1]to
generatethetestcasestocoverthetargetstatement.Therefore,JFS
is similar to the optimization-based floating-point solving methods
where the optimization is implemented implicitly by the fuzzing
method. We can extract partial solutions as like in Section 3.4.
3.6 Discussion
MuSEisthefirststeptowardsunifyingthedoublesearchingproce-
dures in symbolic execution. Compared to vanilla symbolic execu-
tion,MuSEcangeneratemoretestinputswiththesameamountof
constraintsolvings, i.e.,exploringmultiplepathsbysolvingonce.
Wehavenoguaranteethateachofthegeneratedtestinputsbypar-
tialsolutionscantriggeradistinctpath.Fromtheresultsinsection
4, wewill seethat multiple partialsolutions indeedcorrespond to
the same path. A potential method to avoid expensive symbolic
executionwithequivalentpartialsolutionsasinputsistoemploy
lightweight concrete executions on these partial solutions. Suchadvanced synergy of concrete and symbolic execution can both
exploitpartialsolutionsandavoidexpensiveredundantsymbolic
computations. We leave this as the future work.
4 EXPERIMENTAL EVALUATION
4.1 Implementation
Inordertosupportpartialsolutions,wehaveextendedthethree
constraintsolvingmethodsdiscussedinsection3ontwostate-of-
the-art constraint solvers and one self-implemented solver.
•We use Z3 [ 11] for QF_LIA solving and modified Z3 to gen-
eratepartialsolutions.Z3employsSimplex-basedQF_LRA
solving to find the real solution to a relaxed problem first
andthenaddsconstraintsgraduallytofindintegersolutions
[12,26].Werecordthepartialsolutionsintheiterationsof
851Simplex-basedsolvingand converteachpartial solutionto
its closest integer version.
•WeuseSTP[ 16]forQF_ABVsolving.STPimplementsthe
abstract refinement-based approach for solving QF_ABV
formulas. We record the partial solution generated in STP’s
each refinement iteration.
•We have implemented an optimization-based floating-point
solverinJava.Weusesimulatedannealing[ 22]astheopti-
mization algorithm. In each Monte Carlo step, we check the
assignments and extract them as partial solutions if needed.
Toevaluate MuSEextensively,webuilttheDSEenginesutilizing
partialsolutionsforCandJavaprogramsbasedonthestate-of-the-
art symbolic executors.
•We have implemented MuSEon the DSE engine [ 34,44] for
C programs based on KLEE [ 5]. The engine uses the STP
enabled for providing partial solutions. Besides, the DSE
enginesupportstheunder-constrainedsymbolicexecution
[35] that can easily carry out the DSE for a function.
•We have implemented MuSEon the DSE engine [ 47] for
Java programs based on SPF [ 33]. The engine uses the Z3
supportingpartialsolutionsforsolvingQF_LIAformulasand
ouroptimization-basedsolverforanalyzingfloating-point
programs.
4.2 Research Questions
We carry out experiments to answer the following questions:
•Effectiveness: How effective is MuSEto test a program auto-
matically compared with the existing search strategies? We
use code coverage to measure the effectiveness.
•Efficiency: How efficient is MuSEto accomplish a testing
taskcomparedwiththeexistingsearchstrategies?Weuse
the time budget to achieve the same coverage to measure
the efficiency.
4.3 Setup
We conduct three experiments to evaluate MuSEwith the three
constraintsolving methods.Thesetups oftheseexperiments areas
follows.
4.3.1 Experiment 1: Simplex-based QF_LIA Solving. We use the
DSEengineforJavaprogramsandZ3enabledwithpartialsolutions
during QF_LIA solving for evaluation. Table 2 shows the bench-
mark programs. All the programs are real-world open-source Java
programs. The programs are file parsing libraries of different kinds
offileformats,includingBMP,MP3,WAV, etc.Fourprogramsare
from ImageJA library, which is a popular library for manipulating
images,andthetotalLOCofthelibraryis123783.Twoprograms
are from apache imaging library, whose LOC is 32594. For each
program, we countthe LOCof thefiles thatare directlyrelated to
the tested parsing interface.
We create a driver program for each parsing library program to
invokeitsmainparsinginterface.Weuseavalidfileastheinitial
input. The file sizes range from tens to thousands of bytes. We
symbolize each byte in the file for DSE. Note that, not all symbolic
bytesareinvolvedintheconstraintsduetothefunctionalityofthese
programs.Becausemanybitoperationsexistintheseprograms,andTable 2: The programs in the QF_LIA experiment.
Programs LOCBrief Description
BMPDecorder 266BMP file decoder
AviParser 2046ImageJA AVI file decoder
GifParser 439ImageJA GIF parser
BMPParser 205ImageJA BMP parser
PGMParser 2736ImageJA PGM parser
ImgParserPCX 945Imaging PCX decoder
ImgParserBMP 1123Imaging BMP decoder
JaadParser 115Jaad MP3 decoder
Schroeder 1448Schroeder WAV decoder
JMP3Parser 1634JavaMP3 decoder
Toba 1060Java bytecode decoder
Total 1201711 open source programs
QF_LIAdoesnotsupportthemodelingofbitoperations,weconvert
bitoperationstoitsinteger-implementedversion.WeuseDSEto
test these programs automatically in four configurations: DFS, DFS
with partial solutions (DFS+P), BFS, and BFS with partial solutions
(BFS+P). Since the initial inputs are valid files and cover a large
portion of instructions, we use the number of the new instructions
coveredafterthefirstpathasthecriteriontoevaluatemethods.We
test each program in each configuration for 15 minutes.
4.3.2 Experiment 2: Abstraction Refinement-based Array Theory
Solving.We use the DSE engine for C programs and the partial
solution enabled STP for evaluation. Table 3 shows the benchmark
programs, which are from the GNU scientific library (GSL) [ 14].
Floating-point operations and array operations are extensive in
theseprograms.Thesecondcolumn LOCdisplaysthetotalnumber
oftheLLVMinstructionsinsidethetestedfunctionanditscallee
functions.
Table 3: The programs in the QF_ABV experiment. LOC*:
lines of LLVM instructions.
Programs LOC*GSL Function
akimaei 2225akima_eval_integ
bilinea 2075bilinear_deriv_y
find 7706find
eigengs 9150gsl_eigen_genv_sort
fft-rrt 10199gsl_fft_real_radix2_transform
h2d-ps 7919gsl_histogram2d_pdf_sample
sort 328gsl_sort
sum-lum 2896gsl_sum_levin_u_minmax
linear-ed 1618linear_eval_deriv
linear-ei 2117linear_eval_integ
solve-ct 8066solve_cyc_tridiag
solve-ctn 8205solve_cyc_tridiag_nonsym
steffen-ei 1815steffen_eval_integ
Total 6431913 GSL functions
To support floating-point operations, we have implemented the
method in [ 36] that converts each floating-point instruction to
itsintegersimulationimplementation.Weusesoftfloat[ 3]asthe
852Table 4: The programs in the experiment for optimization-
based floating-point solving.
Programs LOCBrief Description
EigenD 1985La4j Eigen decomposition
JacobiS 1210La4j Jacobi solver
CholeskyD 1203La4j Cholesky decomposition
LeastS 1264La4j least squares solver
SquareR 1224La4j square root solver
EDAnalysis 1429Colt Eigen value decomposition
Mutil 1120Colt linear matrix multiplication
RankAnalysis 1120Colt rank for matrix
SVDAnalysis 1139Colt singular value decomposition
TVSAnalysis 1120Colt several kinds of decomposition
Total 1281410 open source programs
library for floating-point simulation. We test these programs in six
configurations:DFSwithpartialsolutions(DFS+P),BFSwithpartial
solutions(BFS+P),thedefaultrandom-covernewsearch(RCN),the
random state search (RSS), DFS, and BFS. We test each program in
each configuration for 15 minutes.
4.3.3 Experiment 3: Optimization-based Floating-point Solving.
Similar to experiment 1, we also evaluate MuSEequipped with
the partial solution enabled optimization-based floating-point con-
straint solver on the DSE engine for Java programs. Table 4 shows
the benchmark Java programs. All the programs are from two real-
worldlinearalgebraJavalibraries(i.e.,La4jandColt),whichinclude
verycomplexfloating-pointarithmetics.SameasTable2,wecount
the LOC of each benchmark’s directly related files. The LOCs of
Colt and La4j are 32879 and 10963, respectively.
We reuse the testing drivers that already exist in the libraries.
The drivers usually input double typed matrices to the library’s
interfaces. We symbolize each element in the matrixes to test these
programs.
Allexperimentsarecarriedoutonaserverwith64GBRAMand
one3.4GHz XeonCPU withsixcores.Theresults arethe average
of 3 runs.
4.4 Experimental Results
This sub-section illustrates the results of the three experiments
evaluating MuSE.
4.4.1 Experiment 1: Simplex-based LIA Solving. Table 5 gives
the experimental results of evaluating MuSEon QF_LIA constraint
solving. The column #Tdisplays the number of the tests generated
by DSE. The column #NIdisplays the number of new instructions
thathavebeencoveredafterthefirstpath.Boththesetwonumbersreflect the DSE’s ability of path exploration. As shown by the table,
compared with the baseline search strategy, i.e., DFS or BFS, MuSE
can cover more new instructions and generate more tests for most
of the programs, which indicate the effectiveness of MuSE.
Figure 5 shows the trends of covered new instructions under
different configurations for all the programs. We record the wall
timeaftereachpathiscovered.Intheend,wecomputethenumber
of newly covered instructions after the first path (Y-axis) at eachtimestep(X-axis).AsshownintheFigure5,underthesameperiod,
MuSEcovers more new instructions consistently than the baseline
search strategy. We also evaluate the efficiency of MuSEwith the
time needed to cover the same amount of new instructions. DFS
achieves its largest number of new instructions ( i.e., 398) at 625.6s,
and DFS+MuSE covers the closest number (i.e., 400) at 14.4s and
achieves at least 43.4x speedup. On the other hand, MuSEachieves
at least 12.9x (890.6s/69.2s) speedup on BFS for covering 1296 in-
structionsthatarenolessthanBFS’supperbound(i.e.,1296).These
results indicate that MuSEis highly efficient.
4.4.2 Experiment 2: Abstraction Refinement-based Array The-
ory Solving. Table 6 gives the experimental results. We use several
default strategies used in KLEE as the baselines, including RCN
(random+covernew),RSS(randomstatesearch),DFSandBFS.Col-
umn#PSshows the number of partial solutions generated during
analysis.Column COVshowsthecoverageresult.WecollectLLVM
codecoverageduringsymbolicexecution.Asshownbythetable,
compared with the other configurations, BFS+P,i.e.,MuSEplus
BFS, achieves the best result in average. Compared with the last
Table 5: Experimental Results of QF_LIA
ProgramsDFS+P DFS BFS+P BFS
#T #NI #T #NI #T #NI #T #NI
BMPDecorder 1125 134 50 3746 84 104 40
AviParser 340 117 144 46 1732 101 114 0
GifParser 721 25 60 5 1905 64 960 48
BMPParser 1203 52 80 4458 126 102 18
PGMParser 264 1 263 1 4736 188 7362 178
ImgParserPCX 387 38 81 20 2596 76 65 0
ImgParserBMP 458 314 114 21 1784 528 135 198
JaadParser 2083 64 134 0 2692 64 2835 59
Schroeder 1149 23 235 20 2267 29 402 22
JMP3Parser 214 286 37 198 319 653 279 646
Toba 1836 344 117 87 1670 311 179 87
Average 889 127 108 36 2536 202 1139 117
 0 500 1000 1500 2000 2500 3000
 0  1000  2000  3000  4000  5000  6000  7000  8000  9000Number of new instructions
Analysis time (0.1s)BFS+MuSE
BFS
DFS+MuSE
DFS
Figure 5: Trends of number of covered new instructions inexperiment on QF_LIA.
853four strategies in KLEE, BFS+Pimproves more than 20% coverage,
which indicates the effectiveness of MuSE.
Figure6showsthecoveragetrendunderdifferentstrategies.The
X-axis shows the analysis time, and the Y-axis shows the achieved
averagecoverage.Asshowninthefigure, MuSEperformsconsis-
tentlybetterthanthebaselinestrategies.Theresultsalsoindicate
thatMuSEhas two orders of magnitude speedup to achieve the
upper bound coverages of DFS and BFS, respectively.
4.4.3 Experiment 3: Optimization-based Floating-point Solving.
Table 7showstheexperimental resultsof MuSEonoptimization-
based floating-point solving. The meanings of the columns are the
same as those in Table 5. Compared with the baseline method,
MuSEcovers moreinstructions and generatesmore tests.Besides,
compared with BFS, MuSEimproves DFS more. The reason is that
DFS explored longer paths in priority. Longer paths have more
complex PCs that are hard to resolve. On the other hand, BFS
exploresshortpathsfirst,whosePCsaremorelikelytobesolvedby
optimization-based solvers. The results marked with an asterisk in
Table7meanthattheanalysesterminatebeforethetimelimit.This
Table 6: Experimental Results of QF_ABV
ProgramsDFS+P BFS+P Other Stategies
#PS COV #PS COV RCN RSS DFS BFS
akimaei 1 64.7 514 76.1 76.5 67.2 65.3 64.9
bilinea 305 71.6 172 80.8 79.0 77.4 59.1 65.4
find 177 96.9 156 96.7 91.3 40.0 91.5 97.7
eigengs 19 73.5 118 98.0 67.6 51.6 61.1 82.8
fft-rrt 1015 46.8 350 99.5 39.6 38.6 46.5 11.3
h2d-ps 4 95.7 130 98.6 47.5 47.5 95.7 98.6
sort 18 100.0 9 100.0 89.7 82.2 83.7 44.6
sum-lu 29 76.5 129 88.6 70.8 50.7 70.1 43.1
linear-ed 13 63.1 1015 82.8 79.9 78.7 56.3 63.8
linear-ei 3 73.5 376 80.5 77.5 71.2 64.2 72.6
solve-ct 135 93.4 33 94.4 26.6 22.3 13.8 93.5
solve-ctn 32 94.2 2 96.0 21.7 19.2 30.0 95.5
steffen-ei 18 74.8 253 83.4 68.7 65.6 67.4 68.8
Average 136 78.8 250 90.4 64.3 54.8 61.9 69.4
 0 20 40 60 80 100 120 140
 0  1000  2000  3000  4000  5000  6000  7000  8000  9000Average coverage
Analysis time (0.1s)BFS+MuSE
DFS+MuSE
RCN
RSS
DFS
BFS
Figure 6: Trends of coverage in experiment on QF_ABV.isbecausethepathconditionsaretoocomplexfortheconstraint
solver.Symbolicexecutioncannotexpandtheexecutiontreewhen
the constraint solver can not generate solutions.
Figure 7 shows the trend of newly covered instructions under
different configurations. The X-axis is the analysis time, and the
Y-axis shows the number of newly covered instructions for all the
programs after the first path. As shown by the figure, MuSEis con-
sistentlymoreefficientthanthebaselinemethod.Besides, MuSE
with DFS finally covers more instructions than BFS, which also
indicatesthatpartialsolutionsimprovetheeffectiveness.Similar
toexperiment1,wealsoevaluatetheefficiencyof MuSEbycom-
paring it with the baseline for covering the same amount of new
instructions. Toachieve DFS’s largest numberof new instructions
(i.e., 615 at 773.1s), MuSEuses 7.8s to cover 633 instructions and
gets99.1xspeedup.ForBFS, MuSEgetsatleast4.6x(290.2s/63.2s)
speedup for covering 4350 instructions that are closest to BFS’supper bound (i.e., 4265). These results indicate the efficiency of
MuSE.
Table 7: Experimental results of optimization-based
floating-point solving. Results marked with asterisk meanthat symbolic execution can not generate more inputs forcomplexpathconditionsandstopsexpandingtheexecutiontree before time limit at that run.
ProgramsDFS+P DFS BFS+P BFS
#T #NI #T #NI #T #NI #T #NI
EigenD 3 244 10 477 1028 20 965
JacobiS 1424 13 43 6 1151 13 43 6
CholeskyD 1376 1335 43 4 1116 8 42 8
LeastS 169 2000 10 573 2246 43 2196
SquareR 1541 166 43 4 1240 8 44 8
EDAnalysis 8 418* 33 * 8 392* 33 *
Mutil 10 7* 40 * 10 7* 40 *
RankAnalysis 255 406 15 180 325 427* 20 427*
SVDAnalysis 204 427* 38 418* 276 427* 19 427*
TVSAnalysis 343 430 10 484 612 7 225
Average 484 495 17 55 514 469 22 387
 0 1000 2000 3000 4000 5000 6000 7000
 0  1000  2000  3000  4000  5000  6000  7000  8000  9000Number of new instructions
Analysis time (0.1s)BFS+MuSE
BFS
DFS+MuSE
DFS
Figure 7: Trends of number of covered new instructions inexperiment on floating-point solving.
854(a) programs for QF_LIA
(b) programs for QF_ABV
(c) programs for floating-point
Figure 8: The average number of partial solutions (#PS) per
solvercall.Thex-axesaretheprogramsusedinexperiments.Some non-zero values are invisible due to scale.
4.4.4 Partial Solutions. We also collect the results of constraint
solving and the numbers of partial solutions. Figure 8 shows the
average number of partial solutions per solving in different experi-
ments.Duetothedifferencebetweenconstraintsolvingmethods,
the number of partial solutions can be very different. For example,
inoneanalysison BMPDecorder usingQF_LIAunderDFSmode,
ourmethodgenerates923partialsolutionsin4timesofsolvings.
Forfft-frrtusing QF_ABV under DFS mode, our method generates
940 partial solutions in 232 times of solvings. It worth noting thatour method usually generates more partial solutions under DFS
thanBFS.ThereasonisthatthepathconditionunderDFScontains
moreconstraintsandisusuallymorecomplicated,sothesolving
algorithms need more trials before finding the final solution.
4.5 Threats to Validity
Thethreatstothevalidityoftheexperimentalresultsaremainly
external. Although we only applied the idea of partial solutions on
three solving methods, the idea is general and can be applied to
otherconstraintsolvingmethods(c.f.,Section3.5).Thebenchmarks
weuseforevaluating MuSEonthreeconstraintsolvingmethods
arelimitedandthustheexperimentalresultscouldbebiased.We
plan to evaluate MuSEon other constraint solving methods and
benchmarkprogramsforamoregeneralvalidation.Theinternal
threatsmainlycomefromthebugsinimplementationduetothe
complexityofthesolversandtheDSEengines.Wehavedesigned
a set of test cases to test the partial solution enabled solvers and
the DSE engines utilizing partial solutions.
5 RELATED WORK
The key idea of MuSEis that the underlying constraint solver sup-
portspartialsolutions.Weexpectthatthemainstreamconstraint
solvers to provide a general interface to access partial solutions in
the future.
The most related work to our method is the constraint opti-
mization techniques. In many symbolic execution engines, solving
result cache stores the previous solving results so that the same
constraintsarenotrepeatedlysolved[ 5,6].Thecounter-example
cache also stores the sets of unsatisfiable constraints. When the
query contains a subset stored in the counter-example cache, there
is no need to invoke the constraint solver [ 5]. Both of symbolic
execution and constraint solving reduce constraints into simpler
forms before querying the underlying constraint solver. For exam-
ple,KLEErewritesexpressionsbyfoldingconstantsandsimplifyinglinearexpressions[
5].EXEseparatesaqueryintoindependentsub-
sets of constraints so that the solving result cache can be reused
better. The Green framework provides a unified facility so that the
constraint solution can be reused across multiple programs and
analysis[ 42].Greenalsocanonicalizesconstraintstoimprovethe
cachehitratio.In[ 20],Greenisextendedtosupportlogicalimplica-
tion relations between constraints. Speculative symbolic execution
(SSE)executesbranchstatementsspeculatively[ 49].Theconstraint
solverisinvokeduntilaspecifiednumberofconstraintsiscollectedon the current path. The total invocation times of constraint solver
is reduced. SSE also uses unsat core to help backtracking in wrong
speculations.
Another research track on boosting symbolic execution focuses
on path explosion problem. This research track can be classified
into two classes. The first class develops efficient path exploration
strategiestoachievespecificgoalswithlimitedresources,including
branch/statementcoverage,statementreachability, etc.Forexam-
ple, the SGS strategy steers the symbolic execution to less-traveled
paths toimprove statementcoverage[ 27]. Directedsymbolic exe-
cutionproposestwosearchstrategiestoreachaparticulartarget
statement [ 29]. CGDS strategy prioritizes branches with the short-
estdistancetotheunexploredprogrampart,aimingtoattainbetter
855branch coverage with fewer test inputs [ 4]. The recently proposed
adaptivesearchheuristicusesmachinelearningtechniquestolearn
searchstrategyonlinetoimprovethecoverage.Thelearnedsearch
strategy is adaptive with respect to the program under test. Experi-
mentalresultsalsoshowthatthelearnedsearchstrategyoutper-
forms traditional fixed search strategy in both statement coverage
and bug-finding [ 7,9]. Another class of research work reduces the
pathspacesothatuninterestingpaths areabandoned.RGSEcom-
bines static data-flow analysis and dynamic symbolic execution to
find paths satisfying the given regular property as soon as possi-
ble[48,50].Grammar-basedwhite-boxfuzzingusesthegrammar
specification of valid inputs, in order to avoid non-parsable inputs
andreachdeeperprogramparts[ 17].In[8],theinputtemplateis
automatically learned online to reduce the path space and hence
improve the branch coverage. The works proposed in [ 39,47] use
program slicing to reduce paths unrelated to the analysis target.For concurrent programs, partial order reduction can be used to
reducepathspace[ 37,43].MPI-SVcombinessymbolicexecution
and model checking to prune equivalent paths satisfying the same
propertyinlineartemporallogicproperty[ 46].Statemergingtech-
niques also can reduce the number of paths effectively [ 2,24]. It
worths noting that state merging with the iteoperator encodes
multiple paths into one formula, which is solved by the constraint
solver.Thisalsocanbeseenasusingconstraintsolvingtosearch
thepathspacedirectly.However,asfarasweknow,wearethefirst
to open up the constraint solver in symbolic execution.
Searchbasedsoftwaretesting(SBST)techniquesusefitnessfunc-
tiontomeasurehowcloseatestinputcanreachthetargetprogram
part,such asbranches andstatements, andthen employoptimiza-
tion algorithms to find the global minimum of the fitness function[
30,45]. SBST transforms the test input generation problem into a
mathematical optimization problem so that plenty of optimization
algorithms can be used. In Section 3.4, we discuss the optimization-
based constraint solving technique used in search-based testing.
6 CONCLUSION
Symbolic execution is facing the scalability problem caused by the
path explosion and the complexity explosion inside the constraint
solver. We observe that there exist redundant searchings in thestack of symbolic execution. In this paper, we propose MuSE,a
general method to use the constraint solver to explore the path
spacedirectly. MuSEmapsthesearchprocedure oftheconstraint
solvingalgorithmtothesearchingsinthepathspaceviaextractingpartial solutions produced in the solving procedure. We implement
MuSEin mainstream symbolic execution engines and the state-
of-the-artconstraintsolvers.Theexperimentalresultsshowthat
MuSEachieves one or two orders of magnitude speedups on the
three constraint solving methods to reach the same code cover-age. We believe that MuSEis the first step towards unifying the
searchingproceduresinsymbolicexecution.Thereareseveraldi-
rections for future work: 1) implementing MuSEon more theories
andconductingmoreextensiveexperiments;2)investigatingthe
synergy of concrete and symbolic executions to leverage partialsolutions more efficiently; 3) exploring the methods for unifying
the searching procedures under different backgrounds.ACKNOWLEDGEMENTS
This research was supported by National Key R&D Program of
China (No. 2017YFB1001802) and NSFC Program (No. 61632015,
61625202, 61690203 and 61532007).
REFERENCES
[1] 2020. LibFuzzer. http://llvm.org/docs/LibFuzzer.html.
[2]Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David Brumley.2014. Enhancing Symbolic Execution with Veritesting. In Proceedings of the
36th InternationalConference on Software Engineering (Hyderabad, India) (ICSE
2014). Association for Computing Machinery, New York, NY, USA, 1083–1094.
https://doi.org/10.1145/2568225.2568293
[3] Berkeley. 2020. SoftFloat 2b. http://www.jhauser.us/arithmetic/SoftFloat.html.[4]
J. Burnim and K. Sen. 2008. Heuristics for Scalable Dynamic Test Generation. In
2008 23rd IEEE/ACM International Conference on Automated Software Engineering.
443–446.
[5]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems Programs.
InProceedings of the 8th USENIX Conference on Operating Systems Design and
Implementation (San Diego, California) (OSDI’08). USENIX Association, USA,
209–224.
[6]Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill, and Dawson R.
Engler.2008. EXE:AutomaticallyGeneratingInputsofDeath. ACMTrans.Inf.
Syst.Secur. 12,2,Article10(Dec.2008),38pages. https://doi.org/10.1145/1455518.
1455522
[7]SooyoungCha,SeongjoonHong,JunheeLee,andHakjooOh.2018.Automatically
Generating Search Heuristics for Concolic Testing. In Proceedings of the 40th
International Conference on Software Engineering (Gothenburg, Sweden) (ICSE
’18). Association for Computing Machinery, New York, NY, USA, 1244–1254.
https://doi.org/10.1145/3180155.3180166
[8]S.Cha,S.Lee,andH.Oh.2018. Template-GuidedConcolicTestingviaOnline
Learning.In 201833rdIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (ASE). 408–418.
[9]SooyoungChaandHakjooOh.2019. ConcolicTestingwithAdaptivelyChangingSearchHeuristics.In Proceedingsofthe201927thACMJointMeetingonEuropean
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (Tallinn,Estonia) (ESEC/FSE2019).AssociationforComputingMa-
chinery, New York, NY, USA, 235–245. https://doi.org/10.1145/3338906.3338964
[10]BrettDaniel,TihomirGvero,andDarkoMarinov.2010.OnTestRepairUsingSym-
bolic Execution. In Proceedings of the 19th International Symposium on Software
TestingandAnalysis (Trento,Italy) (ISSTA’10).AssociationforComputingMa-
chinery, New York, NY, USA, 207–218. https://doi.org/10.1145/1831708.1831734
[11]LeonardodeMouraandNikolajBjørner.2008. Z3:AnEfficientSMTSolver.In
Tools and Algorithms for the Construction and Analysis of Systems, C. R. Ramakr-
ishnanandJakobRehof(Eds.).SpringerBerlinHeidelberg,Berlin,Heidelberg,
337–340.
[12]IsilDillig,ThomasDillig,andAlexAiken.2009.CutsfromProofs:ACompleteand
PracticalTechniqueforSolvingLinearInequalitiesoverIntegers.In Computer
Aided Verification, Ahmed Bouajjani and Oded Maler (Eds.). Springer Berlin
Heidelberg, Berlin, Heidelberg, 233–247.
[13]Bruno Dutertreand Leonardo deMoura. 2006. A Fast Linear-ArithmeticSolver
for DPLL(T). In Computer Aided Verification, Thomas Ball and Robert B. Jones
(Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 81–94.
[14]The Free Software Foundation. 2020. GNU Scientific Library. https://www.gnu.
org/software/gsl/.
[15]Zhoulai Fu and Zhendong Su. 2016. XSat: A Fast Floating-Point SatisfiabilitySolver. In Proceedings of the 28th International Conference on Computer Aided
Verification. 187–209.
[16]Vijay Ganesh and David L. Dill. 2007. A Decision Procedure for Bit-Vectorsand Arrays. In Proceedings of the 19th International Conference on Computer
AidedVerification (Berlin,Germany) (CAV’07).Springer-Verlag,Berlin,Heidelberg,
519–531.
[17]PatriceGodefroid,AdamKiezun,andMichaelY.Levin.2008. Grammar-Based
Whitebox Fuzzing. SIGPLAN Not. 43, 6 (June 2008), 206–215. https://doi.org/10.
1145/1379022.1375607
[18]Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Au-tomated Random Testing. SIGPLAN Not. 40, 6 (June 2005), 213–223. https:
//doi.org/10.1145/1064978.1065036
[19]PatriceGodefroid,MichaelY.Levin,andDavidMolnar.2012. SAGE:Whitebox
FuzzingforSecurityTesting. Queue10,1(Jan.2012),20–27. https://doi.org/10.
1145/2090147.2094081
[20]Xiangyang Jia, Carlo Ghezzi, and Shi Ying. 2015. Enhancing Reuse of Constraint
SolutionstoImproveSymbolicExecution.In Proceedingsofthe2015International
Symposium on Software Testing and Analysis (Baltimore, MD, USA) (ISSTA 2015).
Association for Computing Machinery, New York, NY, USA, 177–187. https:
856//doi.org/10.1145/2771783.2771806
[21]James C. King. 1976. Symbolic Execution and Program Testing. Commun. ACM
19, 7 (July 1976), 385–394. https://doi.org/10.1145/360248.360252
[22]S Kirkpatrick, C D Gelatt, andMPV e cchi. 1983. Optimization by Simulated
Annealing. Science220,4598(1983),671–680. https://doi.org/10.1126/science.
220.4598.671
[23]Daniel Kroening and Ofer Strichman. 2008. Decision Procedures: An Algorithmic
Point of View. https://doi.org/10.1007/978-3-540-74105-3
[24]Volodymyr Kuznetsov, Johannes Kinder, Stefan Bucur, and George Candea. 2012.
EfficientStateMerginginSymbolicExecution. SIGPLANNot. 47,6(June2012),
193–204. https://doi.org/10.1145/2345156.2254088
[25]LeonSLasdon,RichardLFox,andMargeryWRatner.1963. LinearProgramming
and Extensions. Princeton University.
[26]Eva K Lee and John E Mitchell. 2009. Integer programming: branch and bound
methodsIntegerProgramming:BranchandBoundMethods . SpringerUS,Boston,
MA, 1634–1643. https://doi.org/10.1007/978-0-387-74759-0_286
[27]YouLi,ZhendongSu,LinzhangWang,andXuandongLi.2013. SteeringSymbolic
ExecutiontoLessTraveledPaths. SIGPLANNot. 48,10(Oct.2013),19–32. https:
//doi.org/10.1145/2544173.2509553
[28]DanielLiew,CristianCadar,AlastairF.Donaldson,andJ.RyanStinnett.2019. Just
FuzzIt:SolvingFloating-PointConstraintsUsingCoverage-GuidedFuzzing.In
Proceedingsofthe201927thACMJointMeetingonEuropeanSoftwareEngineering
Conferenceand SymposiumontheFoundationsof SoftwareEngineering (Tallinn,
Estonia)(ESEC/FSE 2019). Association for Computing Machinery, New York, NY,
USA, 521–532. https://doi.org/10.1145/3338906.3338921
[29]Kin-Keung Ma, Khoo Yit Phang, Jeffrey S Foster, and Michael Hicks. 2011. Di-
rected Symbolic Execution. In Static Analysis, Eran Yahav (Ed.). Springer Berlin
Heidelberg, Berlin, Heidelberg, 95–111.
[30]Phil McMinn. 2004. Search-Based Software Test Data Generation: A Survey:
Research Articles. Softw. Test. Verif. Reliab. 14, 2 (June 2004), 105–156.
[31]AinaNiemetz,MathiasPreiner,andArminBiere.2014(published2015). Boolector
2.0 system description. Journal on Satisfiability, Boolean Modeling and Computa-
tion9 (2014 (published 2015)), 53–58.
[32] Brian Olson, IrinaHashmi, Kevin Molloy,and AmardaShehu. 2012. Basin Hop-
pingasaGeneralandVersatileOptimizationFrameworkfortheCharacterization
of Biological Macromolecules. Adv. in Artif. Intell. 2012, Article 3 (Jan. 2012),
1 pages. https://doi.org/10.1155/2012/674832
[33]Corina S. Păsăreanu and Neha Rungta. 2010. Symbolic PathFinder: Symbolic
ExecutionofJavaBytecode.In ProceedingsoftheIEEE/ACMInternationalCon-
ference on Automated Software Engineering (Antwerp, Belgium) (ASE ’10).A s -
sociation for Computing Machinery, New York, NY, USA, 179–180. https:
//doi.org/10.1145/1858996.1859035
[34]Minghui Quan. 2016. Hotspot symbolic execution of floating-point programs. InProceedings of the 24th ACM SIGSOFT International Symposium on Foundations of
Software Engineering, FSE 2016, Seattle, WA, USA, November 13-18, 2016, Thomas
Zimmermann,JaneCleland-Huang,andZhendongSu(Eds.).ACM,1112–1114.
https://doi.org/10.1145/2950290.2983966
[35]David A. Ramos and Dawson Engler. 2015. Under-Constrained Symbolic Exe-
cution:CorrectnessCheckingforRealCode.In Proceedingsofthe24thUSENIX
ConferenceonSecuritySymposium (Washington,D.C.) (SEC’15).USENIXAssocia-
tion, USA, 49–64.
[36]Anthony Romano. 2014. Practical Floating-Point Tests with Integer Code. In
Verification, Model Checking, and Abstract Interpretation - 15th International Con-
ference,VMCAI2014,SanDiego,CA,USA,January19-21,2014,Proceedings(LectureNotesinComputerScience),KennethL.McMillanandXavierRival(Eds.),Vol.8318.
Springer, 337–356. https://doi.org/10.1007/978-3-642-54013-4_19
[37]KoushikSen.2006. ScalableAutomatedMethods forDynamicProgramAnalysis.
Ph.D. Dissertation. USA. Advisor(s) Agha, Gul. AAI3242987.
[38]Koushik Sen, Darko Marinov, and Gul Agha. 2005. CUTE: A Concolic Unit
Testing Engine for C. SIGSOFT Softw. Eng. Notes 30, 5 (Sept. 2005), 263–272.
https://doi.org/10.1145/1095430.1081750
[39]Jiří Slab, Jan Strejček, and Marek Trtík. 2012. Checking Properties Described by
StateMachines:OnSynergyofInstrumentation,Slicing,andSymbolicExecution,
Vol. 7437. https://doi.org/10.1007/978-3-642-32469-7_14
[40]Matheus Souza, Mateus Borges, Marcelo d’Amorim, and Corina S. Pasareanu.
2011. CORAL: Solving Complex Constraints for Symbolic PathFinder. In NASA
Formal Methods.
[41]NikolaiTillmannandJonathandeHalleux.2008. Pex–WhiteBoxTestGenerationfor.NET.In TestsandProofs,BernhardBeckertandReinerHähnle(Eds.).Springer
Berlin Heidelberg, Berlin, Heidelberg, 134–153.
[42]Willem Visser, Jaco Geldenhuys, and Matthew B. Dwyer. 2012. Green: Reducing,
Reusing and Recycling Constraints in Program Analysis. In Proceedings of the
ACM SIGSOFT 20th International Symposium on the Foundations of Software Engi-
neering(Cary, North Carolina) (FSE ’12). Association for Computing Machinery,
NewYork,NY,USA,Article58,11pages. https://doi.org/10.1145/2393596.2393665
[43]ChaoWang,ZijiangYang,VineetKahlon,andAartiGupta.2008. PeepholePartial
Order Reduction. In Tools and Algorithms for the Construction and Analysis of
Systems,CRRamakrishnanandJakobRehof(Eds.).SpringerBerlinHeidelberg,Berlin, Heidelberg, 382–396.
[44]Xinyu Wang, Jun Sun, Zhenbang Chen, Peixin Zhang, Jingyi Wang, and Yun Lin.
2018. Towardsoptimalconcolictesting.In Proceedingsofthe40thInternational
ConferenceonSoftwareEngineering,ICSE2018,Gothenburg,Sweden,May27-June
03, 2018, Michel Chaudron, Ivica Crnkovic, Marsha Chechik, and Mark Harman
(Eds.). ACM, 291–302. https://doi.org/10.1145/3180155.3180177
[45]Joachim Wegener, Andre Baresel, and Harmen Sthamer. 2001. Evolutionarytest environment for automatic structural testing. Information and Software
Technology 43,14(2001),841–854. https://doi.org/10.1016/S0950-5849(01)00190-2
[46]HengbiaoYu,ZhenbangChen,XianjinFu,JiWang,ZhendongSu,JunSun,Chun
Huang, and Wei Dong. 2020. Symbolic Verification of Message Passing Inter-
facePrograms.In ProceedingsofThe42ndInternationalConferenceonSoftware
Engineering (Seoul, South Korea) (ICSE 2020). New York, NY, USA.
[47]HengbiaoYu,ZhenbangChen,JiWang,ZhendongSu,andWeiDong.2018. Sym-
bolicVerificationofRegularProperties.In Proceedingsofthe40thInternational
ConferenceonSoftwareEngineering (Gothenburg,Sweden) (ICSE’18).Association
for Computing Machinery, New York, NY, USA, 871–881.
[48]Hengbiao Yu, Zhenbang Chen, Yufeng Zhang, Ji Wang, and Wei Dong. 2017.
RGSE: A Regular Property Guided Symbolic Executor for Java. In Proceedings of
the201711thJointMeetingonFoundationsofSoftwareEngineering (Paderborn,
Germany) (ESEC/FSE 2017). Association for Computing Machinery, New York,
NY, USA, 954–958. https://doi.org/10.1145/3106237.3122830
[49]Y.Zhang,Z.Chen,andJ.Wang.2012. SpeculativeSymbolicExecution.In 2012
IEEE 23rd International Symposium on Software Reliability Engineering. 101–110.
[50]Yufeng Zhang, Zhenbang Chen, Ji Wang, Wei Dong, and Zhiming Liu. 2015.Regular Property Guided Dynamic Symbolic Execution. In Proceedings of the
37th International Conference on Software Engineering - Volume 1 (Florence, Italy)
(ICSE ’15). IEEE Press, 643–653.
857