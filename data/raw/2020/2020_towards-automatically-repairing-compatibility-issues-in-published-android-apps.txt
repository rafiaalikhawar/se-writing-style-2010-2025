Towards Automatically Repairing Compatibility Issues in
Published Android Apps
Yanjie Zhao
Monash University
Melbourne, Australia
Yanjie.Zhao@monash.eduLi Liâˆ—
Monash University
Melbourne, Australia
Li.Li@monash.edu
Kui Liu
Huawei
Hangzhou, China
liukui23@huawei.comJohn Grundy
Monash University
Melbourne, Australia
John.Grundy@monash.edu
ABSTRACT
TheheavyfragmentationoftheAndroidecosystemhasledtose-
verecompatibilityissueswithapps,includingthosethatcrashat
runtime or cannot be installed on certain devices but work well on
other devices. To address this problem, various approaches have
been proposed to detect and fix compatibility issues automatically.
However,theseallcomewithvariouslimitationsonfixingthecom-
patibilityissues,e.g.,canonlyfixonespecifictypeofissues,cannot
dealwithmulti-invocationissuesinasinglelineandissuesinre-
leasedapps.Toovercometheselimitations,weproposeageneric
approach that aims at fixing more types of compatibility issues
inreleasedAndroidapps.Tothisend,ourprototypetool, Repair-
Droid, provides a generic app patch description language for users
to create fix templates for compatibility issues. The created tem-
plateswillthenbeleveragedby RepairDroid toautomaticallyfixthe
correspondingissueatthebytecodelevel(e.g.,rightbeforeusers
install the app). RepairDroid can support template creations for
OS-induced, device-specific and inter-callback compatibility issues
detected by three state-of-the-art approaches. Our experimental re-
sults show that RepairDroid can fix 7,660 out of 8,976 compatibility
issues in 1,000 randomly selected Google Play apps. RepairDroid
isgenerictoconfigurenewcompatibilityissuesandoutperforms
the state-of-the-art on effectively repairing compatibility issues in
released Android apps.
CCS CONCEPTS
â€¢Software and its engineering â†’Software verification and
validation ;Softwaredefectanalysis ;Softwaretestinganddebug-
ging.
âˆ—Corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510128KEYWORDS
Android, Compatibility Issue, Automated Program Repair
ACM Reference Format:
Yanjie Zhao, Li Li, Kui Liu, and John Grundy. 2022. Towards Automati-
cally Repairing Compatibility Issues in Published Android Apps. In 44th
International Conference on Software Engineering (ICSE â€™22), May 21â€“29,
2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3510003.3510128
1 INTRODUCTION
The heavy fragmentation problem of Android â€“ many different
Android versions (official and customized) running on different
devicesreleasedbyhundredsofmanufacturersâ€“hascausedsevere
compatibility issues for the Android ecosystem. Android phone
usersoftenfindthatcertainappscannotbeinstalledontheirdevices
or can be installed but will crash later on if a specific function is
reached, leading to poor user experiences. Actually, as revealedby Byron Muhlberg, there are over a billion Android devices no
longer supported by Google. Hence, the users of those devices will
likelyencountercompatibilityissues,especiallywhentheywant
to leverage the latest Android apps, leading to serious problems in
the mobile ecosystem.
Toaddressthisproblem,approacheshaveexploredvariousways
to automaticallydetect compatibilityissues inAndroid apps [ 4,9,
11,12,14,18,21,26,40,43,56,58].Forexample,Wei etal.[ 53]em-
pirically looked into a set of fragmentation-induced compatibility
issues(includingthoseintroducedbythird-partymanufacturers)
in open-sourceAndroid apps.They furtherproposed atool called
FicFinder to detect the previously characterized compatibility is-
suesautomatically.Lietal.[ 27]proposedagenericapproachcalled
CiD,whichdetectsAPI-relatedcompatibilityissuesbasedonAn-
droidAPIlifecycleknowledgeminedfromtheofficialâ€™shistorical
evolution Android framework.
Unfortunately the majority of these works only focus on detect-
ingsomecompatibilityissues,leavingmanyidentifiedissuesstill
unfixed in real-world Android apps. Updating incompatible APIs is
a time-consuming endeavor and app developers are also known to
bereluctanttorepairtheirappsforfixingissuesyieldedbystatic
analyzers [ 10]. App developers have to learn the usages of new
APIsinordertoreplacetheincompatibleoneswhilemaintaining
21422022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yanjie Zhao, Li Li, Kui Liu, and John Grundy
backwardcompatibilitywiththeoldversion.Thisgreatlyincreases
the learning cost for developers.
Tomitigatethis,researchershaveproposedseveralautomated
approachestorepairincompatibleAPIsforAndroidapps.Fazzini
et al. [9] introduced AppEvolve to update incompatible APIs based
on examples of how other developers evolved their apps for the
same changes. Similarly, Lamothe et al. [ 21] proposed an approach
called A3 for supporting API migration through patterns mined
fromsourcecodeexamplesviaabstractsyntaxtree(AST).Theseap-
proaches require the target code under repair written syntactically
similar to the before- and after-update API change examples. This
makesthemhardtofindapplicableupdates,asclaimedbyThung
etal.[46].Tothisend,Haryonoetal.proposedCocciEvolve[ 11]to
onlylearnupdatesfromasingleafter-updateexample.Iteliminates
theweaknessofAppEvolvebynormalizingboththeafter-update
example and the target app code. Nevertheless, the serious issue
of CocciEvolveis its inability toresolve all the valuesused as API
arguments. These can be expressed in various complex forms, e.g.,
field access expressions, method invocations, and object creations.
Itsotherdrawbackisthepoorreadabilityofitsupdatedappcode
results.ItsauthorsfurtherextendtheirworkbyproposingAndroE-
volve [12], which addresses the limitations of CocciEvolve through
theaddition ofdata flowanalysisand variablenamedenormaliza-
tion.
Unfortunately,alltheaboveapproachesfocusonrepairingthe
source code of Android apps and hence cannot be applied to di-
rectlyrepairpublishedAndroidapps.Indeed,astimegoesby,many
published Android apps on popular app markets such as Google
Play, unless being timely fixed, will become obsolete, leading to
pooruserexperiencesinthemobileecosystem.Tocopewiththis,marketmaintainers couldchoosetoremovethoseapps.However,
thismaynotbeagoodbusinessmodelasitmayreducethemarketâ€™s
competitiveness, i.e., its competitors are providing more choices of
appsforuserstoexplore.Ifmarketmaintainersdonotremovethose
apps, certain apps in the market will not be able to be installed on
usersâ€™devicesorwillcrashafterinstallation.Itwillalsocausepoor
userexperiencesandcanevenharmthereputationofthemarket
and the app developers per se.
Asasupplementtoexistingrepairapproachesthatattemptto
helpdevelopersindevelopinghigher-qualityapps,webelievethere
isalsoaneedtoprovideapproachesforhelpingrepairpublished
apps (before they are installed on usersâ€™ devices), at least in the
timeperiodbeforetheirdevelopersexplicitlyupdatetheapps.This
paper proposes a novel, generic approach for repairing three types
ofcompatibilityissuesâ€“API,deviceandcallback-inducedproblems
â€“inpublishedAndroidapps.Sinceitisrelativelysimpletotrans-
form Java source code to bytecode and vice versa, the approach
targetingpublishedAndroidapps,withsmallchange,couldalsobeappliedtorepairappsatthesourcecodelevel(butnottheotherway
around). Nevertheless, we argue that source code- and bytecode-
basedrepairingapproachesarenotmutuallyexclusive.Theycan
co-exist and complement each other. Indeed, approaches targeting
publishedapprepaircouldbeleveragedtoachieveemergentrepair,
while source code-based approaches can come in later to gradually
fix the issues. For example, market maintainers could leverage pub-
lished app repairs to ensure the compatibility of their hosted apps
(with developersâ€™ permission) at app uploading or downloadingtime.Thisisextremelyuseful,especiallyforlegacyappsthatare
lessfrequently (willno longerbe)maintained bytheirdevelopers.
Correspondingly,end-usersareprovidedoptionstouseappsthat
could not be running initially on their devices.
In this work, we present a prototype tool, RepairDroid , which
leverages pre-defined patch templates to instrument Android apps
so as to fix compatibility issues. The templates are written by ded-
icated experts (i.e., app developers do not need to write patchesfor their apps) based on a structural model that is both descrip-
tiveandgeneric,i.e.,agivenpatchshouldbeapplicabletoallAn-
droid apps. The instrumentation process involves control-flow anddata-flow analysis to locate and repair compatibility issues. Experi-
mental results on thousands of real-world Android apps show that
RepairDroid is effective in automatically repair various types of
compatibility issues. In this research we make the following key
contributions:
â€¢We have designed a novel app patch description languageand demonstrated that it is generic enough to be used tocreate fix templates for various compatibility issues. The
genericity is achieved by allowing users to directly leverage
thesimplebutwell-definedJimplegrammar(i.e.,a3-address
intermediaterepresentationthathasbeendesignedtosim-
plify analysis and transformation of Java/Android bytecode)
to describe the patches.
â€¢Wehavedesignedandimplementedaprototypetool Repair-
Droid, which follows given fix templates to automatically
repair published real-world Android apps.
â€¢We have evaluated our approach against 1,000 real-world
Android apps. Experimental results show that our approach
iseffectiveinrepairingAndroidapps,outperformsthestate-
of-the-art and achieves 85.34% of successful repairing rate.
Opensource. Thesourcecodeanddatasetsareallmadepublicly
available in our artifact package [2].
2 MOTIVATION
The heavy fragmentation of the Android ecosystem has induced
many types of compatibilityissues in Android apps. Our research
community has spent lots of effort on disclosing such issues, in-
cluding at least the following three types:
OS-inducedcompatibilityissues. Thisisoneofthemostcom-
montypesofcompatibilityissues,whereissuesarecausedbythe
evolution of the Android framework. During framework evolution,
new APIs are regularly added to the framework, while existing
APIsarealsoregularlydeprecatedandremoved.Insomerarecases,
existingAPIsmayalsobesemanticallychanged,despitekeeping
thesignatureoftheAPIsunchanged.TheexamplegiveninListing1
shows a deprecated API issue.
1+if(android.os.Build.VERSION.SDK_INT >= 28) {
2+for (Network nw: cm.getAllNetworks()) {
3+ NetworkCapabilities nc =
cm.getNetworkCapabilities(nw);
4+ if(nc != null &&
nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI))
5+ return true ;
6+}
7+return false ;
8+}else {
9 return an.getType() ==
ConnectivityManager.TYPE_WIFI;
2143
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. Towards Automatically Repairing Compatibility Issues in Published Android Apps ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
10+}
Listing 1: An example of an OS-induced compatibility issue. API getTypeis
deprecated at SDK level 28. On devices running SDK versions larger than 28,
it is recommended to use API hasTransport instead.
Device-specific compatibility issues. These compatibility is-
suesareassociatedwithspecificdevicesrunningcustomizedAn-
droid systems. The problematic apps will only crash on certain de-
viceswhilebehavingnormallyonothers,despiteallthedevicesrun-
ning the same Android framework version. Listing 2 presents such
anexamplethatwasinitiallyreportedbyWeietal.[ 54].TheAPI
setRecordingHint dependsonaconditionalstatementthatchecks
the device identifier against â€œNexus 4â€. Only the condition to be
true, i.e., the corresponding app is indeed running on â€œNexus 4â€,
the API will be executed.
1Camera mCamera = Camera.open();
2Camera.Parameters params = mCamera.getParameters();
3......
4+if(android.os.Build.MODEL.equals( "Nexus 4"){
5+ params.setRecordingHint(true);
6+}
7......
8mCamera.setParameters(params);
9mCamera.startPreview();
Listing 2: Patch for Camera Preview Frame Rate Issue on Nexus 4, excerpted
from [54].
Inter-callback compatibility issues. This type of compatibil-
ityissueiscausedbythechangestoAndroidsystemcallbacks(also
known as lifecycle methods). Such system callback methods are
pre-defined by the Android system and will be directly executed
whencertain conditionsare satisfied.Listing3 illustratessuch an
example that was initially reported by Huang et al. [ 15]. TheonAt-
tach(Context) callback method is only introduced from API level
23.IfthiscodeisrunningonsmartphoneswithearlierAPIlevels,
this callback method will not be executed. Subsequently, the mAc-
tivityfield will not be initialized, and its usage will likely throw
NullPointerException s.
1public void onAttach(Context context) {
2 super.onAttach(context);
3- mActivity = (BrowserActivity) context;
4- ......
5+ attachActivity((BrowserActivity) context);
6}
7+public void onAttach(Activity activity) {
8+super.onAttach(activity);
9+if(Build.VERSION.SDK_INT < 23) {
10+ attachActivity((BrowserActivity) activity);
11+}
12+}
13+private void attachActivity(BrowserActivity
activity) {
14+ mActivity = activity;
15+ ......
16+}
Listing 3: The Patch for WordPress issue 6906. The compatibility issue is
caused by the fact that the callback method onAttach(Context) is not yet
available before API level 23, excerpted from [15].
All of these compatibility issues are equally critical to mobile
apps as all of them will cause apps to crash, leading to poor user
experiences.Compatibilityissue repairingapproachesshouldaim
tofixallofthem.Ho wever,curr entstate-of-the-arttoolsonlyfocus
onrepairingAPI-inducedcompatibilityissues.Automaticallyfixing
othertypesofcompatibilityissues,suchasdeviceorcallbackrelated
ones, has not yet been addressed.AssummarizedinTable1,existingapproachesalsocomewith
many limitations. For example, CocciEvolve only attempts to fix
incompatibleAPIswithinasinglemethod.Theirfollow-upwork
AndroEvolve fixes this limitation by additionally introducing data-
flow analysis into the fixing process. Compatibility issues withrespect to (1) out-of-file variables and (2) multi-invocations in asingle line and (3) compatibility issues in released Android apps
cannot be resolved by any of the state of the art.
Table 1: Problematic Android compatibility issues addressed by state-of-the-
art tools.
Feature A3AppEvolve CocciEvolve AndroEvolve
Out-of-method (within file) variables    
Out-of-file variables    
1-to-n replacement    
Multi-invocations in a single line    
Fix in published Android apps    
3 OUR APPROACH: REPAIRDROID
We introduce RepairDroid , a template-based repair approach, to
automatically repair three kinds of compatibility issues in Android
apps. Figure 1 presents an overview of RepairDroid . It has three
keymodules:(1)TemplateBuildModule(TBM),(2)BugLocation
Module (BLM), and (3) Bug Repair Module (BRM). Below we detail
these three modules.
Existing
Fixes
BLM:
Bug Location ModuleBRM:
Bug Repair Module
Bug-free
App
TBM:
Template Build ModuleTemplates
Published
App
Figure 1: The working process of RepairDroid .
3.1 TBM: Template Build Module
Thisfirstmoduleof RepairDroid aimsatpreparingasetofseman-
tic templates for subsequent modules to repair published Android
apps.Themaincontributionofthismoduleisagenericlanguage
fordescribingapppatchtemplates.Developersshouldbeableto
easily leverage the language to create templates for fixing compati-
bility issues, based on knowledge learned from the official Androiddocumentation,onlinequestionandanswerwebsitessuchasStack-
Overflow,orexistingfixingsamplesminedfromtheevolutionof
real-world Android apps. The grammar of the language is straight-
forward. As shown in Figure 2, it contains three blocks, namely
variable declaration block, issue location block, and patch block.
We now detail these three blocks, respectively.
Variable Declaration Block. The first block provides a means
for developers to specify all the variables involved in the template.
At the moment, the language supports three types of variables.
â€¢Variables to be directly reused from the original con-text.
These variables appear in the original code statements
(used for locating problems) and hence could be directly
reused in the new code.
â€¢Variablestobesearchedfromtheoriginalcontext. These
variables do not appear in the original code statements that
2144
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yanjie Zhao, Li Li, Kui Liu, and John Grundy
@@ Variable Declaration
$v0 := boolean$v1 := ANY[SEARCH] $v2 := <TYPE>
@@ Issue Location[<ISSUE_TYPE>] <CONDITION>
@@ Template Denotation+ //Replacement Statements- //Original Statements
OR+ $v0 = <CONDITION EXPRESSION>
+ if $v0 == true+    //Replacement Statements+ else       //Original Statements
Figure2:Thelanguagestructureforcreatingpatchtemplatesfor RepairDroid .
are defined to locate the problems but do exist in the app
context.Hence,backwarddata-flowanalysisisdemandedto
searchthedefinitionofthevariablesfordirectreuses.These
variableswillbeexplicitlymarkedbykeyword[SEARCH],
as demonstrated in Figure 2.
â€¢Variablestobecreated. Thesevariablesaretotallynewto
the app and hence need to be defined before applying the
template.
Issue Location Block. The second block is provided for de-
veloperstospecifyhowthecompatibilityissuescanbeprogram-
matically located. Developers first specify the issue type (in square
brackets)tobefixedtosimplifythelocationprocess.Thisisbecausedifferenttypesofcompatibilityissuesrequiredifferentstrategiesto
locate them. As inspired by the three types of compatibility issues
summarized in Section 2, the language currently provides three
issuetypes(i.e.,[OS],[DEVICE],and[CALLBACK],respectivelyforOS-induced,device-specific,andinter-callbackcompatibilityissues)
to guideRepairDroid for locatingcompatibility issues. Moreissue
types could be added to the language if new types of compatibility
issues are identified in the future.
Like the variable declaration block, the issue location block is
alsorelativelyeasytoconfigure.Inmostcases,itonlyneedsone
lineofstatementtospecifytheissue.Forexample,thecompatibility
issues in the three motivating examples shown in Section 2 can be
respectively specified by the issue location statements shown in
Listing 4.
InadditiontothetargetedAPIs,<CONDITION>alsospecifies
the situation when the issue should not be considered, even ifthe targeted APIs or call methods are located. Taking Line 1 inListing 1 as an example, if the invocation of the deprecated APIgetType() is already protected by an SDK version check (i.e., if
(Build.VERSION.SDK_INT >= 28)), this target should be ignored as
there should have no compatibility issue in such a case.
TemplateDenotationBlock. Thelastmoduleoftheapppatch
languageisusedbydeveloperstospecifytheactualtemplatefor
fixingthelocatedcompatibilityissues.Thefixtemplateisdesigned
to be written in Jimple-like pseudocode. Jimple is the default inter-
mediate representation of Soot [ 49], a well-known Java/Android
static analysis framework. The reason why we choose Jimple todescribe the template is that the instrumentation function of Re-
pairDroid isimplementedontopofSoot.Itallows RepairDroid to
quickly apply the template to fix compatibility issues in a deployed
app1.
As shown in Figure 2, the typical way to fix an OS-induced
compatibilityissueistoreplacetheoriginalproblematicstatements
with corrected new statements. In practice, we recommend the
developers to always guard their newly introduced code through a
conditionalcheck.Whenthecheckreturnstrue,thereplacement
statements will be invoked. Otherwise, the original statements will
be executed and hence the original behaviors are kept.
1[Method] <[android.app.Fragment]: void
onAttach(android.content.Context)>
2[Stmt]$r0 := @this: [android.app.Fragment]
3[Stmt]$a0 := @parameter0: android.content.Context
4[Stmt]specialinvoke $r0.<android.app.Fragment: void
onAttach(android.content.Context)>($a0)
5[CUT] ... when != [END of Method]
6+ $v0 = ([android.app.Activity]) $a0;
7+ virtualinvoke $r0.<[android.app.Fragment]: void
attachActivity([android.app.Activity])>($v0);
8+return
9
10+ [NEW Method][public ] <[android.app.Fragment]: void
onAttach(android.app.Activity)>
11+ $r1 := @this: [android.app.Fragment]
12+ $a1 := @parameter0: android.app.Activity
13+ specialinvoke $r1.<android.app.Fragment: void
onAttach(android.app.Activity)>($a1)
14+ $i1 = <android.os.Build$VERSION: int SDK_INT>
15+if$i1 >= 23 goto <label_1>
16+ $v1 = ([android.app.Activity]) $a1;
17+ virtualinvoke $r1.<[android.app.Fragment]: void
attachActivity([android.app.Activity])>($v1);
18+ <label_1>
19+return
20+ [END of Method]
21
22+ [NEW Method][private ] <[android.app.Fragment]: void
attachActivity([android.app.Activity])>
23+ $r2 := @this: [android.app.Fragment]
24+ $a2 := @parameter0: [android.app.Activity]
25[PASTE]
26+return
27+ [END of Method]
Listing 5: The template denotation block of the inter-callback example.
Listing5showsanexampleTemplateDenotationblockforthe
inter-callbackexampleshowninListing3.Basedontheexample
inListing5,wefurtherintroduceseveralkeywords,suchas[CUT],
[PASTE],torespectivelyrepresentcutandpasteoperations,with
whichtheycanbatchprocessstatementswithinthesetrange,as
shownatLine5andLine25.InspiredbySmPL[ 22],onthebasisof
ensuringtheuniversalityofthelanguage,thetemplatesforthese
threeissueshavedesignedsomespecialsymbols,includingtheuse
of some reserved words.
[ğ¶ğ‘ˆğ‘‡]...ğ‘¤â„ğ‘’ğ‘›!=[ğ¸ğ‘›ğ‘‘ ğ‘œğ‘“ ğ‘€ğ‘’ğ‘¡â„ğ‘œğ‘‘ ]
The"..."operatorinSmPLrepresentsanarbitrarysequence,i.e.,any
sequenceofstatementsoveranycontrolflowpath,whichisalso
used in our language. For example, the usage of when != [End of
1Ideally,wewouldliketosupportJavaasthelanguagefordescribingthepatchdirectly
asitwouldbemoreconvenientforpatchwriters.However,thiswillmakethepatch
parsingstepdifficulttoachieveasessentiallyitasksforaJavacompilertointerpret
the(random)Javacode.JimpleisasimplifiedJavarepresentationthatcouldbeanideal
trade-offsolution,i.e.,notverydifficulttounderstandandwritebutcanbeinterpreted
programmatically in practice (thanks to Soot).
2145
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. Towards Automatically Repairing Compatibility Issues in Published Android Apps ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
[OS] <android.net.NetworkInfo: int getType()> Build.VERSION.SDK_INT 28
[DEVICE] <Camera: Camera$Parameters getParameters()> Build.MODEL "Nexus 4"
[CALLBACK] <Fragment: void onAttach(Context)> Build.VERSION.SDK_INT 23
Listing 4: Examples of issue location statements for creating templates to fix the compatibility issues listed in the three motivating examples (i.e., Listings 1-3),
respectively
Method]atLine5meansthatthereshouldbenooccurrencesof [End
of Method] in the matched control-flow path, that is, the matching
process continues to the end of the method. Although there are no
complicated usages in the repair of the three types of compatibility
issues introduced above, our intention for this app patch language
designistoensurethefuturescalabilityof RepairDroid .Tothisend,
[End of Method] can be replaced with other statements (e.g., tag
statements such as <label_1>) to ensure that RepairDroid can be
guided to accurately collect statements.
In real-world Android projects, the class inheritance feature has
been frequently leveraged. In order to improve the versatility of
RepairDroid , we use ["Superclass Name"] to specify the superclass
oftheclasstobesearched.Forexample,[android.app.Fragment]
meansRepairDroid needs to search such a class that extends the
superclass named "android.app.Fragment" before performing sub-
sequent work. If the superclass does not need to be restricted,
[DECLARING_CLASS],areservedkeyword,canbedirectlyusedtoindicatetheclasstowhichthecurrentmethodbelongs. RepairDroid
will replace it with the actual value in the app when running on
the BRM module.
3.2 BLM: Bug Location Module
The second module of RepairDroid takes as input the Android APK
to be analyzedand the semantic templates generated by the first
moduleandoutputsthelocations(atthestatementlevel)indicating
where the templates should be applied. Specifically, this module
takes the following three steps to achieve its purpose: template
parsing,app pre-processing, and bug localization. We now detail
these steps, respectively.
Template parsing . As a prerequisite to the following steps,
RepairDroid firstreadsandparsesthesemantictemplatesgenerated
bytheTBMmodule.Theparsingprocessutilizestheprincipleof
FiniteStateMachinetoparsetheinputsemantictemplates.After
theparsingstep,eachsemantictemplateisstoredasastructured
object that is readily available for further references.
App pre-processing. This step first transforms the bytecode
into an intermediate representation code called Jimple, as it is non-
trivial to directly analyze the Dalvik bytecode of Android apps.
Jimple is the default intermediate representation format of Soot, a
Java/Androidappstaticanalysisandoptimizationframework.In
this work, RepairDroid leverages Soot to achieve the code transfor-
mation and the following-up static analysis of Android apps.
Buglocalization .ThissteptraversestheJimpleIRsofthetarget
app and detects the locations that need to be patched accordingto the specified conditions parsed from the semantic templates
above.RepairDroid automaticallyidentifiesthebuglocations(often
attheJimple statementlevel)fromtheappcode bytraversingeach
method in each class. Subsequently, the located bug statements,
alongwiththeirbelongingmethods,willberegardedasapotential
bug candidate.Then for each identified candidate, RepairDroid goes one step
further to check if it satisfies certain conditions, following what
will be also specified in thesemantic template. If so, the candidate
will be regarded as a true bug and hence will be propagated to
the next module for automated repairing. For compatibility issues,
thebuglocationswilloften be anAPIinvocationstatement(e.g.,because the API is no longer available in the latest Android de-
vicesorincertaincustomizedAndroidversions suchasSamsung
phones).Theconditionscouldbeaframeworkversioncheckora
devicemanufacturercheck.TakingListing6asasimpleexample,
APIabandonAudioFocus isdeprecatedintheAndroidframework
versionğ‘€andhenceisonlyrecommendedtobeinvokedondevices
running lower versions than ğ‘€. However, this method call should
notbedetectedascontainingacompatibilityissuebecausetheprob-
lemhasalready beenprotected(i.e.,fixed).The conditionalcheck
(i.e., against Build.VERSION_CODES.M ) should have been clearly
specifiedinthesemantictemplateofAPI abandonAudioFocus.T ore-
solvethisissue,afterlocatingcandidatebugs, RepairDroid goesone
step deeper to perform an inter-procedural backward control-flow
analysis to check if their associated conditions are presented. Only
if the incompatible API calls are not already protected, RepairDroid
will attempt to repair the corresponding issues.
We use the example shown in Listing 6 to illustrate this back-
ward analysis flow. The deprecated API abandonAudioFocus and
itsreplacementAPI abandonAudioFocusRequest arecalledintwo
separate methods, i.e., abandonAudioFocus() (i.e., Line 4) and aban-
donAudioFocusRequest() (i.e., Line 1), and the condition check state-
ment is located in the method dispose()(i.e., Line 7). When locating
an OS-induced issue, RepairDroid can easily pinpoint the depre-
catedAPI abandonAudioFocus (i.e.,Line5)anditsdeclaringmethod,
abandonAudioFocus(). However, there is no conditional check state-
ment for the SDK version in the abandonAudioFocus() method. As
aresult,weneedtolocatemethod dispose()thatcallsthemethod
abandonAudioFocus() through the backward analysis flow to de-
termine that the current case does not contain an incompatible
issue.
1public void abandonAudioFocusRequest() {
2audioManager.abandonAudioFocusRequest(request);
3}
4public void abandonAudioFocus() {
5audioManager.abandonAudioFocus( this);
6}
7public void dispose(){
8if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M){
9 abandonAudioFocusRequest();
10 }else {
11 abandonAudioFocus();
12 }
13}
Listing6:Codesnippetsshowingthedemandforconductinginter-procedural
backward flow analysis.
2146
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yanjie Zhao, Li Li, Kui Liu, and John Grundy
3.3 BRM: Bug Repair Module
The last module of RepairDroid is used to repair the located app
compatibility bugs by directly updating the code snippets (here-
inafterreferredtoasthe Target)locatedbytheBLMmodule,i.e.,
ğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡ğ‘‡ğ‘’ğ‘šğ‘ğ‘™ğ‘ğ‘¡ğ‘’â†’ğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡/prime. TheTemplate represents the list of state-
mentsusedtoupdatethe Targetthathasbeenidentifiedascontain-
ing bugs. Subsequently, ğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡/primerepresents the list of statements
having the identified bugs repaired.
Algorithm 1 summarizes the general repairing process imple-
mentedin RepairDroid .RepairDroid firstneedstoensurethatallthe
variablekeywords2involvedinthesemantictemplateareavailable
in the code context. It transforms the variable keywords defined as
strings in the template to Java objects at the code level. As demon-
stratedinLines2-12,foreachvariablekeyword, RepairDroid first
checks if its corresponding variable is directly available in the Tar-
getcode.Ifso,itwillbedirectlyreused.Ifagivenvariablekeyword
ismarkedbykeyword[SEARCH],wethenconsiderthevariable
keyword needs to be searched in the Targetâ€™s context (the variable
should have been defined in the app but has not been leveraged by
theTargetcode).Finally,ifthevariablekeywordisdefinedasanew
variable,itwillbedirectlyinitiated.Takingthecodesnippetshown
inListing1asanexample,thevariable cm(atLine2)issuchacase
thatneedstobesearchedbackward,and nw(atLine2)and nc(at
Line 3) are variables that need to be created based on the searched
variablecm.
When there are variables that do not exist in the original app
code statements, RepairDroid leverages the searchLocal function
toconductbackwardcontrol-flowanalysissoastoselectexisting
variables from the code context. The search process follows the
following rules. These are summarized based on our manual obser-
vationsamongvariousfixesthathappenedinreal-worldAndroid
apps. (1) Search backward from the position of Targetfor the vari-
ableinthelocatedbuggystatementâ€™sdeclaringmethod.Thefirst
seenvariable(matchedviatype)willbeconsidered.(2)Ifitisnot
possible to identify the variable in the current method, RepairDroid
thentraversesallthefieldsdeclaredintheclasstowhichthepre-
viouslysearchedmethodbelongs.Next,(3)ifitstillfailstolocate
thevariable, RepairDroid willresorttothewholeclass,including
its inner classes, to search for the variable. Finally, suppose it is
still impossible to locate an existing variable after exploring all the
aforementionedrules, RepairDroid willterminatetherepairprocess
and regard the fix as a failure case.
After preparing all the required variables, the next step is to
update the Targetcode following the Jimple statements defined in
thetemplate.SincetheJimplestatementsareprovidedasstrings,
RepairDroid takesadditionalstep toautomaticallytransformit to
code snippets (via the BUILD-JIMPLE-STMT function). Recall that
the Jimple statements written in the template may contain certain
placeholder keywords such as ["Superclass Name"], [CUT], and
[PASTE]. When transforming the statements, RepairDroid needsto
replace them with concrete values.
2To avoid confusion, we use variable keywords to describe the variables defined as
strings in the template. The term variable by itself is kept for referring to Java objects.For example, as shown in Line 1 of Listing 5, RepairDroid first
collectstheactualnameoftheclassinheritingthesuperclass an-
droid.app.Fragment,whichcontainsincompatibleissues.Then,itre-places[android.app.Fragment]withitsrealvalue,e.g., org.wordpress.
android.ui.themes.ThemeBrowserFragment in the app of Listing 3,
which extends the android.app.Fragment class, at runtime. Further-
more, some of the searched variables e.g. those returned by Rule
(3)), may not be directly accessible in the method under repairing.
To this end, RepairDroid goes one step further to introduce glue
code to change the visibility of the search variables so that they
can be freely used to repair the buggy statements.
Algorithm 1: The repair algorithm of BRM.
Input:ğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡: the located buggy statements.
ğ‘‡ğ‘’ğ‘šğ‘ğ‘™ğ‘ğ‘¡ğ‘’ : the classes/methods/statements that should be inserted.
1ğ‘‰ğ‘ğ‘Ÿ2ğ¿ğ‘œğ‘ğ‘ğ‘™= new HashMap;
2ğ‘‰ğ‘ğ‘Ÿğ‘–ğ‘ğ‘ğ‘™ğ‘’ğ¾ğ‘’ğ‘¦ğ‘¤ğ‘œğ‘Ÿğ‘‘ğ‘  = getVariableKeywords( ğ‘‡ğ‘’ğ‘šğ‘ğ‘™ğ‘ğ‘¡ğ‘’ );
3ğµğ‘œğ‘‘ğ‘¦=ğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡.getDeclaringMethodBody();
4forğ‘£ğ‘ğ‘Ÿâˆˆğ‘‰ğ‘ğ‘Ÿğ‘–ğ‘ğ‘ğ‘™ğ‘’ğ¾ğ‘’ğ‘¦ğ‘¤ğ‘œğ‘Ÿğ‘‘ğ‘  do
5ifğ‘£ğ‘ğ‘Ÿshows inğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡then
6 ğ¿ğ‘œğ‘ğ‘ğ‘™= getLocal( ğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡,ğ‘£ğ‘ğ‘Ÿ);
7else ifğ‘£ğ‘ğ‘Ÿneeds to be searched then
8 ğ¿ğ‘œğ‘ğ‘ğ‘™= searchLocal( ğµğ‘œğ‘‘ğ‘¦,ğ‘£ğ‘ğ‘Ÿ);
9else
10 ğ¿ğ‘œğ‘ğ‘ğ‘™= new Local( ğµğ‘œğ‘‘ğ‘¦,ğ‘£ğ‘ğ‘Ÿ,ğ‘‰ğ‘ğ‘Ÿ2ğ¿ğ‘œğ‘ğ‘ğ‘™);
11ğ‘‰ğ‘ğ‘Ÿ2ğ¿ğ‘œğ‘ğ‘ğ‘™.add(ğ‘£ğ‘ğ‘Ÿ,ğ¿ğ‘œğ‘ğ‘ğ‘™);
12end
13forğ¼ğ‘¡ğ‘’ğ‘šâˆˆğ‘‡ğ‘’ğ‘šğ‘ğ‘™ğ‘ğ‘¡ğ‘’ ğ‘ğ‘’ğ‘“ ğ‘œğ‘Ÿğ‘’do
14ğ‘ğ‘’ğ‘¤ğ‘†ğ‘¡ğ‘šğ‘¡ = BUILD-JIMPLE-STMT( ğ¼ğ‘¡ğ‘’ğ‘š,ğ‘‰ğ‘ğ‘Ÿ2ğ¿ğ‘œğ‘ğ‘ğ‘™);
15insertBefore( ğ‘ğ‘’ğ‘¤ğ‘†ğ‘¡ğ‘šğ‘¡ ,ğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡.ğ‘”ğ‘’ğ‘¡ [0]);
16end
17forğ¼ğ‘¡ğ‘’ğ‘šâˆˆğ‘‡ğ‘’ğ‘šğ‘ğ‘™ğ‘ğ‘¡ğ‘’ ğ‘ğ‘“ ğ‘¡ğ‘’ğ‘Ÿdo
18ğ‘ğ‘’ğ‘¤ğ‘†ğ‘¡ğ‘šğ‘¡ = BUILD-JIMPLE-STMT( ğ¼ğ‘¡ğ‘’ğ‘š,ğ‘‰ğ‘ğ‘Ÿ2ğ¿ğ‘œğ‘ğ‘ğ‘™);
19insertAfter( ğ‘ğ‘’ğ‘¤ğ‘†ğ‘¡ğ‘šğ‘¡ ,ğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡.ğ‘”ğ‘’ğ‘¡ [ğ‘‡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡.ğ‘ ğ‘–ğ‘§ğ‘’ () âˆ’1]);
20end
3.4 Implementation
RepairDroid isimplementedontopofSootandtherepairprocess
isdoneattheJimplecodelevel.ThankstoSoot,therepairedJimplecodeisfurthertransformedbacktoanewAndroidapp,whichcould
bedirectlyinstalledandusedbyusers.Althoughourapproachis
proposed to repair Android apps directly at the bytecode level, app
developerswhowanttorepairtheirappsatthesourcecodelevel
couldalsobenefitfromourapproach.Byreverse-engineeringthe
repairedAndroidapps,developerscangetfixedsourcecode,which
could then be directly ported to the source code project to achieve
source code repairs.
4 EVALUATION
The goal of this work is to automatically repair compatibility is-
sues in published Android apps. To determine if this objective has
been achieved, we look to answer the following four key research
questions:
RQ1:How generic is our proposed patch description language?
RQ2:How well does RepairDroid perform compared with exist-
ing tools?
RQ3:Howeffectiveis RepairDroid inautomaticallylocatingand
repairing incompatibility issues in real-world Android apps?
2147
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. Towards Automatically Repairing Compatibility Issues in Published Android Apps ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
RQ4:Whatisthetimeperformanceof RepairDroid inrepairing
published Android apps?
4.1 RQ1: Genericity
Inthefirstresearchquestion,weinvestigatethegenericityofour
proposedpatchdescriptionlanguage,whichisoneofthecoremod-
ulessupportingtheautomatedrepairofAndroidapps.Asdiscussed
in Section 2, there are at least three types of compatibility issues
sufferedbyreal-worldAndroidapps.Theissuesaresignificantly
different from one to another. Even within the same type, the com-
patibility issues could also be remarkably different. Recall that we
aim to design the patch description language to be as generic as
possible so that it can be leveraged to describe templates for all the
kinds of compatibility issues Android apps may encounter. To this
end,weresorttoevaluatingthelanguageâ€™sgenericitybydirectly
applying the language to create templates for all the compatibil-ity issues explicitly mentioned in the three articles in which the
aforementionedthreetypesofcompatibilityissues(cf.Section2)
are introduced, respectively.
By manually summarizing the examples detected by the pre-
viouslymentionedthreeapproaches(i.e.,CiD,Pivot,andCIDER,
respectively),weeventuallydecidedtocreatetemplatesforthree
OS-induced compatibility issues, seven device-specific compatibil-
ityissues,andsixinter-callbackcompatibilityissues.IntheworkofCiD, the authors listed seven issues, of which only three have been
confirmedandfixedbythedevelopers.Henceweonlytakethese
three issues into consideration. Furthermore, the authors of CiDhave further presented another work, CDA [
29], that reveals 19
more issues. As a supplement, we decided to also consider them to
create OS-induced compatibility issues. However, for five of them,
we cannot find intuitive replacements and hence these were ex-
cluded before the experiment. These five issues are associated with
the Apache HttpComponents project, for which the whole project
hasnowbeendeprecatedbytheAndroidframework.Toaddress
them hence requires fundamental code changes â€“ removal of all
the usage of Apache HttpComponents â€“ to repair their related app
compatibility issues. Such a change is far too difficult to be done
automatically.Wethuseliminatedthesefivecompatibilityissues
fromthisexperiment.Asaresult,17OS-inducedcompatibilityis-
suesareconsidered,asenumeratedinthesecondcolumninTable2.
In the work of Pivot, the authors present ten problematic apps,
among which only seven compatibility issues are eventually fixed.
ThesesevenissuescorrespondtothreedistinctAPIs.Intheworkof
CIDER,theauthorshave reportednineissues,amongwhichonly
sixissues(correspondtofourdistinctmethods)areeventuallyfixed.
To ensure that we can find repair examples that provide specimens
demonstrating how these compatibility issues can be fixed andthereby how to describe the templates, we decided to only focus
onthethreedevice-specificandfourinter-callbackcompatibility
issues that have been fixed or at least confirmed by the developers.
The detailed selected issues are also listed in the second column in
Table 2.
To evaluate the genericity of RepairDroid â€™s patch description
language, for eachof the selected compatibility issuesin Table 2,
the authors manually analysed each issue and its correct fixes andTable 2: Experimental results demonstrating the genericity of the patch de-
scription language.
Paper Issue If success Total
CiD [27] <Resources: Drawable getDrawable(...)> 
15/17CDA [29] <Notification: void setLatestEventInfo(...)> 
<View: void setBackgroundDrawable(...)> 
<Intent: ClipData getClipData()> 
<View: void setSystemUiVisibility(...)> 
<Notification.Builder: Notification.Builder set-
LocalOnly(...)>
<Notification: void <init>(...)> 
<NetworkInfo: int getType()> 
<Display: int getWidth()> 
<Display: int getHeight()> 
<Resources: int getColor(...)> 
<PopupWindow: void setWindowLayoutMode(...)> 
<Activity: void setProgress(...)> 
<ContentProviderClient: boolean release()> 
<AccessibilityServiceInfo: String getDescription()> 
<AccessibilityServiceInfo: boolean getCanRe-
trieveWindowContent()>
<Html: String toHtml(...)> 
Pivot [54] <DatePickerDialog: DatePickerDialog DatePickerDia-
log(...)>
3/3
<View: int getSystemUiVisibility()> 
<Camera$Parameters: void setRecordingHint(...)> 
CIDER [15] <Fragment: void onAttach(...)> 
<WebViewClient: boolean shouldOverrideUrlLoad-
ing(...)>
4/4<WebViewClient: onReceivedError(...)> 
<WebViewClient: onReceivedHttpError(...)> 
created templates following the rules defined by the language pre-
sented earlier. As shown in Table 2, for the 24 considered compati-
bility issues across three different types, wesuccessfullycreated
22 templates for these 24 app compatibility issues . We will
evaluate the correctness of these templates when answering the
third research question.
Theremainingtwoissueswecouldnotfixusingour RepairDroid
patch description language. That is because these two issues have
notbeenprovidedwithclearreplacementinformationindicating
howtheycanbeavoidedontheofficialAndroiddocumentationsite.
These failures, however, have no connection with the genericity of
the language. Indeed, if we are provided with well-structured re-
pairsamples,wecouldstillgeneratetemplatesforthesetwoissues.
Overall, this experimental result shows that our patch description
languageisquitegenericandshouldbecapableofdescribingpat-
terns for finding and fixing a wide range of compatibility issues
encountered by Android apps.
Â¾RepairDroidâ€™spatchdescriptionlanguageisgenericandshould
be capable of describing most of the compatibility issues available
in the Android ecosystem.
4.2 RQ2: Comparison With State-of-the-art
To answer our second research question, we compare RepairDroid
withallthestate-of-the-artrelatedworks.Tothebestofourknowl-
edge,aslistedinTable1,therearefourtools(i.e.,A3[ 21],AppE-
volve [9], CocciEvolve [ 11], AndroEvolve [ 12]) proposed by our
fellowresearchersusedtoautomaticallyfixOS-inducedcompati-
bility issues in Android apps. However, A3 is mainly developed to
mine migration patterns from code examples. Although it provides
mechanisms to automatically apply the mined migration patterns
tofixtheproblematicAPIs,thereisnoguaranteethatsuchattempts
will be correct. We believe it is not fair to compare our approach
with A3 and hence exclude A3 from the comparison.
2148
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yanjie Zhao, Li Li, Kui Liu, and John Grundy
Furthermore,becauseofcertainlimitationsofAppEvolve,e.g.,it
cannot handle updates spanning multiple methods, CocciEvolve is
proposedtocomplementAppEvolve.CocciEvolveisabletoachieve
betterperformancethanAppEvolveon112targetproblems.The
authors of CocciEvolve further propose AndroEvolve that extends
CocciEvolvetoachieveevenbetterperformanceinautomatically
repairing incompatible APIs. Therefore, in this work, we compare
ourapproachwithAndroEvolve,themostrelevantandadvanced
approach closest to ours.
In orderto experimentallycompare the performanceof Repair-
Droidagainst AndroEvolve, we need to ensure that these two tools
are launched to repair the same set of compatibility issues. We
hence made effort to create compatibility patch templates for all
oftheissuestargetedbyAndroEvolve.Specifically,AndroEvolve
was evaluated against 20 problematic APIs, as shown in the first
columninTable3.Following RepairDroid â€™sdescriptionlanguage,
wewereabletocreatetemplatesforallthe20APIs.Thisalsofur-
therdemonstratesthegenericityof RepairDroid â€™spatchdescription
language, complimenting our RQ1 answer above.
Wethenlaunch RepairDroid andAndroEvolvetorepairAndroid
appsthatcontaintheaforementioned20compatibilityissues.We
build the corresponding projects used in the evaluation of An-droEvolve into apps and conduct experiments based on them, asRepairDroid requires published Android apps to check if Repair-
Droidcan repair the corresponding issues. Table 3 summarizes the
experimentalresults. RepairDroid isabletosuccessfullyrepair
all theAPIs ,includingalloftheonesthatcannotbehandledby
AndroEvolve. As explicitly acknowledged by Hartono et al. [ 12],
AndroEvolve cannot handle the updates of a single API into multi-
pleAPIs.Therefore,AndroEvolvefailstorepair getAllNetworkInfo()
API as its fix requires to access two APIs, i.e., getAllNetworks() and
getNetworkInfo().Moreover,AndroEvolvecannotdealwiththecase
when multiple API invocations are written in a single line of code.
Itisindeednon-trivialtoresolvethischallengeasitmayinvolve
complicatedoperationsinthatlineofcode.However,thischallenge
will not be an issue for RepairDroid . Indeed, RepairDroid repairs
AndroidappsattheJimplecodelevelforwhichthemultipleinvoca-
tions are separated into different lines. These experimental results
show that RepairDroid goes beyond the state-of-the-art to repair
compatibility issues in Android apps.
Â¾RepairDroid outperformsthestate-of-the-arttoolsbyachieving
betterperformanceinautomaticallyrepairingcompatibilityissues
in Android apps.
4.3 RQ3: Effectiveness of RepairDroid
Ourthirdresearchquestionconcernstheeffectivenessof Repair-
Droidinautomaticallyrepairingcompatibilityissuesinpublished
Android apps. To answer this RQ we randomly selected 1,000 real-
worldAndroidappsfromAndroZootoformourtestdataset.These
1,000appswereoriginallycollectedfromtheofficialGooglePlay
storeandhenceareallpublishedapps(i.e.,theirsourcecodesare
not available anyway). Recall that, when answering RQ1 and RQ2,
wehavecreatedtemplatesfor42distinctcompatibilityissues.We
used all of these 42 templates when applying RepairDroid to try
and detect and repair compatibility issues in the randomly selectedTable3:Comparisonresultsbetween RepairDroid andthestate-of-the-artAn-
droEvolve approach.
API AndroEvolve RepairDroid
<AccessibilityNodeInfo: void addAction(...)>  
<ConnectivityManager: NetworkInfo[] getAllNetwork-
Info()> 
<TimePicker: Integer getCurrentHour()>  
<TimePicker: Integer getCurrentMinute()>  
<TimePicker: void setCurrentHour(...)>  
<TimePicker: void setCurrentMinute(...)>  
<TextView: void setTextAppearance(...)>  
<LocationManager: boolean addGpsStatusListener(...)>  
<Html: Spanned fromHtml(...)>  
<ContentProviderClient: boolean release()>  
<LocationManager: boolean addGpsStatusListener(...)>  
<WebViewClient: boolean shouldOverrideUrlLoading(...)> âˆ—
<View: boolean startDrag(...)>  
<AudioManager: int abandonAudioFocus(...)>  
<TelephonyManager: String getDeviceId()>  
<AudioManager: int requestAudioFocus(...)>  
<Canvas: int saveLayer(...)>  
<MediaPlayer: void setAudioStreamType(int)>  
<Vibrator: void vibrate(long)>  
<Vibrator: void vibrate(long[],int)>  
âˆ—No examples and scripts provided.
apps. Note that at this stage, we do not know yet whether these
apps contain true compatibility issues or not.
Table4 summarizestheexperimentalresults.714appscontain
potential OS-induced compatibility issues (i.e., 8,519 in total3), and
492appssufferfrompotentialdevice-specificissues(i.e.,3,086into-
tal). Only seven apps contain potential inter-callback compatibilityissues (i.e., 31 in total). In this experiment, we consider an app that
containsinter-callbackcompatibilityissuesonlyiftheunsupported
callback methodsare explicitlyoverriddenby developers.Among
all the identified issues, RepairDroid locates that 5,932 OS-induced,
3,042device-specific,and2inter-callbackcompatibilityissuesare
trueissuesforwhichtheyarenotalreadyprotected.Foreachofthelocated issues, RepairDroid then applies its corresponding template
to perform the automated repair. Eventually, 4,616 OS-induced,
3,042device-specific,and2 inter-callback compatibilityissuescan
be successfully fixed, giving a success rate at 77.82%, 100%, and
100%, respectively. To validate the fixes, we randomly sample 20
appsandleverageSootâ€™sgrammarcheckertocheckiftheirupdated
code is grammatically correct. Then, we evaluate the repaired app
through(1)manuallycomparingtherepairedcodewiththeoriginal
buggy code and (2) actually executing the repaired apps (as well as
their original counterparts) to verify the fixes of the corresponding
compatibility issues. The repaired code of the 20 sampled apps has
been manually verified and confirmed to be correct, and all therepaired apps can also be normally installed on Android devices.
Overall, RepairDroid is able to achieve an 85.34% of success
rate when repairing 1,000 randomly selected Android apps.
Figure 3 plots the distribution of the number of detected and the
numberof successfullyfixedcompatibilityissues, i.e.,themedian
andmeannumbersare10,12.77,and9,11.12,respectively.Thefact
that the majority of located issues can be automatically repaired
demonstrates the effectiveness of our approach.
The failure cases are mainly caused by the variable search mod-
ule,forwhich RepairDroid failstopinpointtherequiredvariables
basedonthevariablekeywordsleveragedinthetemplate.Taking
the code snippet displayed in Listing 1 again as an example, in our
experiment,atotalof760compatibilityissuesrelatedtoAPI getType
arelocated.However,foraround25%atthemoment, RepairDroid
3Issues lie in Android framework code are ignored.
2149
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. Towards Automatically Repairing Compatibility Issues in Published Android Apps ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
currently fails to search and locate the actual variable for keyword
cm.Furthermore,duetolimitationsofSoot, RepairDroid alsofailsto
repair a number of issues. Moreover, there might be multiple ways
tofixanissue.Werespectivelyprovideageneralrepairtemplate
targetingeachissue,whichmaynotfullymeetallcasesâ€™require-
ments. As of our future work, we commit to continuously improve
our approach to increase its success rate in automatically fixing
compatibility issues in published Android apps.
Table 4: Performance achieved by RepairDroid for repairing 1,000 randomly
selected Android apps.
Issue # Apps # Potential # Located Issues # Fixed
Type Issues (No Protection) Issues
OS-induced 714 8,519 5,932 4,616
Device-specific 492 3,086 3,042 3,042
Inter-callback 7 31 2 2
Total 725âˆ—11,636 8,976 7,660 (85.34%)
âˆ—One app may suffer from multiple type of issues.
Figure 3: Distribution of the located and successfully fixed compatibility is-
sues in each of the selected apps.
Â¾With an overall 85.34% of success rate, the experimental results
showthat RepairDroid iseffectiveinautomaticallyrepairingreal-
world Android apps.
4.4 RQ4: Time Performance of RepairDroid
In our last research question, we investigate the time performance
ofRepairDroid whenappliedtorepairreal-worldpublishedAndroid
apps.Takingthesame1,000appsasleveragedforansweringRQ3as
input, Figure 4 presents the distribution of the execution time that
RepairDroid spendsforanalyzinganapp.Thedistributionisplotted
withrespecttothenumberoflocatedcompatibilityissuesidentified
inanappandtheDEXsizeofeachapp,respectively.Asthenumber
of located issues per-app increases, the time spent to repair the
app also increases. Nevertheless, the increase seems to be gradual.
Indeed, the Pearson correlation coefficient confirms that there is
(a) # Located Issues. (b) DEX Size.
Figure 4: Distribution of the execution time with respect to the number ofissues contained per app and its DEX size, respectively.onlyaweakcorrelation( ğ‘Ÿ=0.34,ğ‘âˆ’ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ <0.001)betweenthem.
WhenDEXsizeisconcerned,wecannotobservedirectconnections
between the DEX size of the app and the time that RepairDroid
spendstorepairtheapp.Pearsoncorrelationanalysisalsoconfirms
our observation that there is literally no correlation ( ğ‘Ÿ=âˆ’0.07,ğ‘âˆ’
ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ =0.05) between them.
The results suggest that the time performance of Repair-
Droidisquitestableinanalyzingareal-worldAndroidapps ,
no matter how large the code size is or how many compatibilityissuesitsuffersfrom.Thisevidencefurthersuggeststhatourap-
proach issuitable tobe appliedto repairlarge-scale Androidapps.
Â¾The time spent by RepairDroid to repair a real-world Android
app is stable, with no impact by the appâ€™s code size and only a
slightimpactbythenumberofcompatibilityissuesthatneededto
be fixed.
5 DISCUSSION
5.1 Limitations
WhileRepairDroid aimsforpreciseandsoundanalysisandrepair,it
doessharesomeinherentlimitationswithmostotherstaticanalysis
tools[26].RepairDroid isoblivioustoreflectivecalls,nativecode,
multi-threading features, which may impact the static analysis
resultsandhenceleadtoinaccuratelocationsofcompatibilityissues.
As ofour future, we planto leverage theDroidRA [24, 25,45] and
JuCify [42] tool to mitigate the impact of reflective calls and native
code, respectively. Currently RepairDroid is onlyaware of the most
commonexpressiontypesdefinedinSoot.Insomerarecases,when
thereservedkeywordssuchas[CUT]and[PASTE]involveunusual
expressions, RepairDroid may not be able to recognize them and
hencewillnotgenerateexecutablestatements,resultinginincorrect
repairs. However, it is relatively easy to extend RepairDroid for
including more of Sootâ€™s expression types. This limitation could
be mitigated in practice. Furthermore, we have only evaluated the
correctnessofdevice-specificcompatibilityissuerepairingsthrough
manualconfirmationbecausewecannotfindtherelevantdevices
fortesting.Suchmanualprocessesare,however,knowntobeerror-
prone.Tomitigatethethreat,wehavecross-validatedtheresults.
We have also released our tool and dataset for public reference.
5.2 Mining Fix patterns from existing Android
apps
RepairDroid is limited by the set of templates prepared for analysis.
The more templates created and included, the more compatibil-
ityissueswilllikelybeautomaticallyfixed.However,itmightbe
non-trivialtocreatetemplatesforsomeissuesasitcouldrequire
complicatedbackgroundknowledgetounderstandtheissuesand
theircorrespondingfixes.Thisburdencouldbesignificantlymit-
igated if we can locate real-world code examples relevant to fixcompatibility issues. Following the idea of Fazzini et al. [
9], who
proposetolearnfixpatternsfromtheevolutionofopen-sourceAn-droidapps,weproposetominesuchfixpatternsfromtheevolution
ofpublishedAndroidapps.Webelievetheevolutionofpublished
Android apps could provide much more knowledge than mining
2150
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yanjie Zhao, Li Li, Kui Liu, and John Grundy
open-source apps since the majority of apps have only released
their published versions (i.e., source code not available).
Table 5: The list of the top-5 API Pairs mined from real-world Android apps.
Incompatible API Replacement API # Apps
setBackgroundDrawable setBackground 5,382
isScreenOn isInteractive 2,129
getDrawable(int) getDrawable(int,Theme) 1,543
setOnUtteranceCompletedListener setOnUtteranceProgressListener 1,240
getColorStateList(int) getColorStateList(int,Theme) 1,085
Tothisend,werandomlyselected20,000appsfromAndroZoo[ 3]
and conducted a lightweight static analysis to locate API calls that
are protected by SDK version checks (e.g., based on the follow-
ing pattern: if (condition) ğ´ğ‘ƒğ¼ğ‘–ğ‘›ğ‘ğ‘œğ‘šğ‘ğ‘ğ‘¡ğ‘–ğ‘ğ‘™ğ‘’ elseğ´ğ‘ƒğ¼ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ ). To
ensure that the located API calls are indeed relevant to fix compat-
ibility issues, we further resort to the list of 228 API deprecated-and-replacement pairs disclosed by Li et al. [
28]. We consider a
potential fix pattern is located if the following conditions are satis-
fied: (1) the API calls are protected by SDK version checks, (2) the
problematic API and its replacements are respectively presented
inthetwobranchesseparatedbytheSDKversioncheck.Among
the 228 pairs, we are able to locate 34 practical fix patterns, for
which the top-5 ones are illustrated in Table 5. Following the lo-
catedfixpatterns,wecouldindeedeasilycreatetemplatesforthe
involved problematic APIs. Those templates can subsequently help
RepairDroid in automatically repairing the pinpointed issues in the
corresponding real-world apps. This preliminary study experimen-
tally shows that our approach RepairDroid could indeed benefit
from existing compatibility issue fixes conducted by developers in
practice.Thisstudyisourinitialattemptandispartofourongoingeffortsatcreatingmoretemplatesforrepairingcompatibilityissues
in published apps.
5.3 Supporting automated repair for both Java
and Kotlin written Android apps
Since2017,GooglehaspromotedKotlinastheofficialprogramming
language for developing Android apps. In 2019, Google further
declaredthatAndroidbecomesâ€˜Kotlin-firstâ€™(i.e.,newAPI,libraries,documentationwilltargetKotlinfirst)andhenceadviseddevelopers
to develop new apps using Kotlin instead of Java. Since then, more
and more Android apps have completely migrated from Java toKotlin. However, to the best of our knowledge, all existing apprepairing approaches only focus on Java written apps, letting a
large number of Kotlin written apps untouched. Indeed, since Java
andKotlinaretwodifferentprogramminglanguages,coderepairing
approaches proposed for one language cannot be applied to theother. Analysts have to completely rewrite the code parser andrepair module following the new languagesâ€™ syntax. We hence
arguethatthereisaneedtosupportautomatedrepairforbothJava
and Kotlin written apps.
Fortunately, no matter which language is leveraged, the pub-
lished Android apps will be in Dalvik bytecode. Therefore, Re-
pairDroid couldbedirectlyappliedtorepairbothJavaandKotlin
writtenapps.Forexample, RepairDroid toolcanperformsuccessful
fixes on the DuckDuckGo-Kotlin [1] app.6 RELATED WORK
CompatibilityAnalysis: Compatibilityissueshavebeenakeyre-
searchtopicintheAndroidcommunity[ 6,15,27,37,44,51,53,54].
Toassistdevelopersinexhaustiveapptesting,Weietal.[ 53]em-
pirically study the fragmentation-induced issues to characterizethe symptoms and root causes and propose a technique namedFicFinder to detect such compatibility issues. After that, the au-thors [
54] further present an API-device correlation extracting
andlearningapproachnamedPivottohelpdetectfragmentation-
inducedcompatibilityissues.Huangetal.[ 15]delveintothecall-
back API evolution induced compatibility issues and provide atechnique named CIDER, leveraging a graph-based model to de-
tect two types of callback compatibility issues. Unfortunately, both
Pivot and CIDER focus on detecting some types of incompatibility
issuesinsteadofrepairingthem,themotivationofour RepairDroid .
TheexplorationofcompatibilityissuescausedbyAndroidOS
evolution is needed as apps are inseparably linked to the official
Android APIs. Researchers have put a lot of effort into deprecated
APIs [9,11,13,23,28,29,56], which could eventually lead to com-
patibilityissues.Lietal.[ 28]buildaprototypetoolcalledCDAand
apply it to different revisions of the Android framework to charac-
terizedeprecatedAndroidAPIs.Basedonanextensiveempirical
study,Heetal.[ 13]revealthatdrasticAPIchangesexistbetween
neighboring Android versions. They have additionally developed a
toolnamedIctApiFindertodetectincompatibleAPIusages.Simi-
larly, Li et al. [ 27] propose an approach named CiD to model the
lifecycle of the Android APIs and flag the error usages capableof causing compatibility issues, the issues declared by which arealso regarded as one of our motivations. Xia et al. [
55] perform
a large-scale study on the practice of handling OS-induced API
compatibilityissuesandtheirsolutions,andproposeatool,RAPID,
to ascertain whether a compatibility issue has been addressed.
Innon-Androidcommunities,researchonAPIdeprecatedisalso
ubiquitous[ 4,14,40,43,52,58].Zhouetal.[ 58]studyAPIdepreca-
tionusageinopen-sourceJavaframeworksandlibraries.TheyalsoproposeaframeworktodetectdeprecatedAPIusagesinsourcecodeexamples on the Web. Brito et al. [
4] perform a large-scale analysis
of real-world Java systems and reveal that there is almost no sig-
nificant effort to improve deprecation messages. Some researchers
concentrateontheimpactofAPIdeprecation[ 7,14,40,43].Hora
et al. [14] report on an exploratory study that aims to observe API
evolutionanditsimpactonthePharoecosystem.Sawantetal.[ 43]
extend the study on Java and investigate how many API clients
updatetheirdependenciestoactivelymaintaintheirprojectsand
count the number of affected projects by deprecation.
ProgramRepair: Programtransformationsandrepairinghave
been widely researched [ 5,8,16,17,19,20,22,34,36,38,41,47,48,
50].Forinstance,LASE[ 16,38]isanexample-basedprogramrepair
tool by learning non-trivial data and its context from multiple edit-
ingexamplesandautomaticallysearchingforeditinglocationsto
apply customized editing to these locations. Liu et al. [ 30] present
atechniquebasedonthecodeeditsperformedbydevelopersfor
automatically learning program transformations that are leveraged
to repair program defects automatically [ 32,33], while the patch
validation of such program repair relies on the test cases of the
targeted programs [ 31,35,39,57]. Coccinelle [ 5,22] is a C-based
2151
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. Towards Automatically Repairing Compatibility Issues in Published Android Apps ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
programmatchingandsource-to-sourcetransformationtoolthat
has been employed for the automatic evolution of the Linux ker-
nel. Coccinelle provides Semantic Patch Language (SmPL) to write
its transformation rules. As a Java extension to Coccinelle, Coc-
cinelle4J [ 17] is designed to apply for Java programs. Similar to
Coccinelle, it uses semantic patches written in SmPL.
Recently, studies have begun to focus on the usage of automati-
cally updating incompatible Android APIs. As one of the first tools
to implement this goal, AppEvolve [ 9] using GitHub as the code
base to perform API updates by learning examples before and after
theupdate.Haryonoetal.[ 11]improveAppEvolvebyproposing
CocciEvolve, which uses a single updated example to perform API
updates and provides readable and configurable scripts in the form
of semantic templates. They further broaden their study bypropos-
ing AndroEvolve [ 12], which addresses the defects of CocciEvolve
withdataflowanalysisandvariablenamedenormalization.Simi-
lartotheirworks, RepairDroid alsorelyonsemantictemplatesto
automatically perform API updates. Lamothe et al. [ 21] leverage
the basic diffin the version control system to learn API migration
patterns, where they use the ASTs to match the API calls in thesource code to the code examples. Unlike the above researchesthat directly act on the Java source code, our study concentrates
onthe low-level programminglanguage,intendingto modifyDex
files directly and break the limitation that they can only take effect
within the scope of a method or file.
7 CONCLUSION
We have proposed a novel prototype tool RepairDroid for auto-
matically repairing compatibility issues in published Android apps.
RepairDroid provides a patch description language for users to cre-
atefixtemplatesforgivencompatibilityissues. RepairDroid then
applies these created templates directly to the Android app byte-
codetorepairthecorrespondingcompatibilityissues.Experimental
resultsshowthatthepatchdescriptionlanguageisgeneric,being
abletocorrectlydescribe42outof44issues,andtherepairmoduleiseffective,beingabletooutperformthestate-of-the-artapproachesandachieveanoverall85.34%ofsuccessrateinrepairing1,000real-
word Android apps. RepairDroid â€™s execution time per app is also
stable, making it suitable to be applied to conduct market-scale
repairings.
ACKNOWLEDGEMENTS
This work is supported by ARC Laureate Fellowship FL190100035,
DiscoveryEarlyCareerResearcherAwardDE200100016,Discovery
Project DP200100020. This work is also partially supported by the
NationalNaturalScienceFoundationofChina(GrantNo.62172214),
theNationalKeyR&DProgramofChina(No.2020AAA0107704),
the Natural Science Foundation of Jiangsu Province, China (Grant
No.BK20210279),andtheOpenProjectProgramoftheStateKey
LaboratoryofMathematicalEngineeringandAdvancedComputing
(No. 2020A06).
REFERENCES
[1] 2017. DuckDuckGo Android App. https://github.com/duckduckgo/Android.
[2]2021. TowardsAutomaticallyRepairingCompatibilityIssuesinPublishedAn-
droid Apps. https://zenodo.org/record/5430715.
[3]Kevin Allix, TegawendÃ© F BissyandÃ©, Jacques Klein, and Yves Le Traon. 2016.
Androzoo:Collectingmillionsofandroidappsfortheresearchcommunity.In2016 IEEE/ACM13th Working Conferenceon MiningSoftware Repositories (MSR).
IEEE, 468â€“471.
[4]Gleison Brito, AndreHora, Marco Tulio Valente, and RomainRobbes. 2016. Do
developers deprecate apis with replacement messages? a large-scale analysis on
java systems. In 2016 IEEE 23rd International Conference on Software Analysis,
Evolution, and Reengineering (SANER), Vol. 1. IEEE, 360â€“369.
[5]JulienBrunel,DamienDoligez,RenÃ©RydhofHansen,JuliaLLawall,andGilles
Muller. 2009. Afoundation forflow-based programmatching: usingtemporallogic and model checking. In Proceedings of the 36th annual ACM SIGPLAN-
SIGACT symposium on Principles of programming languages. 114â€“126.
[6]Haipeng Cai, Ziyi Zhang, Li Li, and Xiaoqin Fu. 2019. A Large-Scale Study of
ApplicationIncompatibilitiesinAndroid.In The28thACMSIGSOFTInternational
Symposium on Software Testing and Analysis (ISSTA 2019).
[7]Lingchao Chen, Foyzul Hassan, Xiaoyin Wang, and Lingming Zhang. 2020. Tam-
ing behavioral backward incompatibilities via cross-project testing and analysis.
InProceedingsoftheACM/IEEE42ndInternationalConferenceonSoftwareEngi-
neering. 112â€“124.
[8]Bruce Collie, Philip Ginsbach, Jackson Woodruff, Ajitha Rajan, and MichaelOâ€™Boyle. 2020. M3: Semantic API Migrations. arXiv preprint arXiv:2008.12118
(2020).
[9]Mattia Fazzini, Qi Xin, and Alessandro Orso. 2019. Automated API-usage up-date for Android apps. In Proceedings of the 28th ACM SIGSOFT International
Symposium on Software Testing and Analysis. 204â€“215.
[10]JunGao,PingfanKong,LiLi,TegawendÃ©FBissyandÃ©,andJacquesKlein.2019.
Negative Results on Mining Crypto-API Usage Rules in Android Apps. In The
16th InternationalConference on Mining Software Repositories (MSR 2019) .
[11]StefanusAgusHaryono,FerdianThung,HongJinKang,LucasSerrano,Gilles
Muller, Julia Lawall, David Lo, and Lingxiao Jiang. 2020. Automatic Android
Deprecated-API Usage Update by Learning from Single Updated Example. arXiv
preprint arXiv:2005.13220 (2020).
[12]Stefanus A Haryono, Ferdian Thung, David Lo, Lingxiao Jiang, Julia Lawall,
HongJinKang,LucasSerrano,andGillesMuller.2020. AndroEvolve:Automated
Android API Update with Data Flow Analysis and Variable Denormalization.
arXiv preprint arXiv:2011.05020 (2020).
[13]DongjieHe,LianLi,LeiWang,HengjieZheng,GuangweiLi,andJinglingXue.
2018. Understanding and detecting evolution-induced compatibility issues inandroid apps. In 2018 33rd IEEE/ACM International Conference on Automated
Software Engineering (ASE). IEEE, 167â€“177.
[14]AndrÃ©Hora,RomainRobbes,NicolasAnquetil,AnneEtien,StÃ©phaneDucasse,
and Marco Tulio Valente. 2015. How do developers react to API evolution?
The Pharo ecosystem case. In 2015 IEEE International Conference on Software
Maintenance and Evolution (ICSME). IEEE, 251â€“260.
[15]Huaxun Huang, Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2018. Under-
standing and detecting callback compatibility issues for android applications. In
Proceedingsofthe33rdACM/IEEEInternationalConferenceonAutomatedSoftware
Engineering. 532â€“542.
[16]John Jacobellis, Na Meng, and Miryung Kim. 2013. LASE: an example-based
program transformation tool for locating and applying systematic edits. In 2013
35th InternationalConference on Software Engineering (ICSE) . IEEE, 1319â€“1322.
[17]HongJinKang,FerdianThung,JuliaLawall,GillesMuller,LingxiaoJiang,and
David Lo. 2019. Semantic Patches for Java Program Transformation (Experience
Report).In 33rdEuropeanConferenceonObject-OrientedProgramming(ECOOP
2019). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik.
[18]PingfanKong,LiLi,JunGao,KuiLiu,TegawendÃ©FBissyandÃ©,andJacquesKlein.2018. AutomatedTestingofAndroidApps:ASystematicLiteratureReview. IEEE
Transactions on Reliability (2018).
[19]Anil Koyuncu, Kui Liu, TegawendÃ© F. BissyandÃ©, Dongsun Kim, Martin Monper-
rus,JacquesKlein,andYvesLeTraon.2019. iFixR:BugReportdrivenProgram
Repair. In Proceedings of the 27the ACM Joint European Software Engineering
Conference and Symposium on the Foundations of Software Engineering. ACM,
314â€“325. https://doi.org/10.1145/3338906.3338935
[20]Anil Koyuncu, Kui Liu, TegawendÃ© F. BissyandÃ©, Dongsun Kim, Martin Mon-
perrus,JacquesKlein,andYvesLeTraon.2020. FixMiner:MiningRelevantFix
Patterns for Automated Program Repair. Empirical Software Engineering 25, 3
(2020), 1980â€“2024. https://doi.org/10.1007/s10664-019-09780-z
[21]MaximeLamothe,WeiyiShang,andTse-HsunPeterChen.2020. A3:Assisting
Android APIMigrationsUsing CodeExamples. IEEETransactionson Software
Engineering (2020).
[22]Julia Lawall and Gilles Muller. 2018. Coccinelle: 10 years of automated evolution
in the Linux kernel. In 2018 USENIX Annual Technical Conference. 601â€“614.
[23]LiLi,TegawendÃ©FBissyandÃ©,YvesLeTraon,andJacquesKlein.2016. Access-
ing Inaccessible Android APIs: An Empirical Study. In The 32nd International
Conference on Software Maintenance and Evolution (ICSME 2016).
[24]LiLi,TegawendÃ©FBissyandÃ©,DamienOcteau,andJacquesKlein.2016. DroidRA:
Taming Reflection to Support Whole-Program Analysis of Android Apps. In The
2016 InternationalSymposium on Software Testing and Analysis (ISSTA 2016) .
2152
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Yanjie Zhao, Li Li, Kui Liu, and John Grundy
[25]LiLi,TegawendÃ©FBissyandÃ©,DamienOcteau,andJacquesKlein.2016.Reflection-
Aware Static Analysis of Android Apps. In The 31st IEEE/ACM International
Conference on Automated Software Engineering, Demo Track (ASE 2016).
[26]LiLi,TegawendÃ©FBissyandÃ©,MikePapadakis,SiegfriedRasthofer,Alexandre
Bartel, DamienOcteau,Jacques Klein,and YvesLe Traon.2017. StaticAnalysis
of Android Apps: A Systematic Literature Review. Information and Software
Technology (2017).
[27]Li Li, TegawendÃ© F BissyandÃ©, Haoyu Wang, and Jacques Klein. 2018. Cid:
Automating the detection of api-related compatibility issues in android apps.
InProceedings of the 27th ACM SIGSOFT International Symposium on Software
Testing and Analysis. 153â€“163.
[28]Li Li, Jun Gao, TegawendÃ© F BissyandÃ©, Lei Ma, Xin Xia, and Jacques Klein. 2018.
Characterising deprecated android apis. In Proceedings of the 15th International
Conference on Mining Software Repositories. 254â€“264.
[29]Li Li, Jun Gao, TegawendÃ© F BissyandÃ©, Lei Ma, Xin Xia, and Jacques Klein. 2020.
CDA:Characterising DeprecatedAndroidAPIs. EmpiricalSoftware Engineering
(2020), 1â€“41.
[30]KuiLiu,DongsunKim,TegawendÃ©F.BissyandÃ©,ShinYoo,andYvesLeTraon.
2021. MiningFixPatternsforFindBugsViolations. IEEETransactionsonSoftware
Engineering 47, 1 (2021), 165â€“188. https://doi.org/10.1109/TSE.2018.2884955
[31]KuiLiu,AnilKoyuncu,TegawendÃ©F.BissyandÃ©,DongsunKim,JacquesKlein,
andYvesLeTraon.2019.YouCannotFixWhatYouCannotFind!AnInvestigation
of Fault Localization Bias in Benchmarking Automated Program Repair Systems.
InProceedings of the 12th IEEE International Conference on Software Testing, Veri-
fication and Validation. IEEE, 102â€“113. https://doi.org/10.1109/ICST.2019.00020
[32]Kui Liu, Anil Koyuncu, Dongsun Kim, and TegawendÃ© F. BissyandÃ©. 2019.
AVATAR:FixingSemanticBugswithFixPatternsofStaticAnalysisViolations.
InProceedings of the 26th IEEE International Conference on Software Analysis,
EvolutionandReengineering.IEEE,456â€“467. https://doi.org/10.1109/SANER.2019.
8667970
[33]Kui Liu, Anil Koyuncu, Dongsun Kim, and TegawendÃ© F. BissyandÃ©. 2019. TBar:
Revisiting Template-based Automated Program Repair. In Proceedings of the 28th
ACM SIGSOFT International Symposium on Software Testing and Analysis. ACM,
31â€“42. https://doi.org/10.1145/3293882.3330577
[34] Kui Liu, Anil Koyuncu, Kisub Kim, Dongsun Kim, and TegawendÃ© F. BissyandÃ©.
2018. LSRepair:LiveSearchofFixIngredientsforAutomatedProgramRepair.
InProceedings of the 25th Asia-Pacific Software Engineering Conference. IEEE,
658â€“662. https://doi.org/10.1109/APSEC.2018.00085
[35]Kui Liu, Li Li, Anil Koyuncu, Dongsun Kim, Zhe Liu, Jacques Klein, and
TegawendÃ© F. BissyandÃ©. 2021. A critical review on the evaluation of automated
program repair systems. Journal of Systems and Software 171 (2021), 110817.
https://doi.org/10.1016/j.jss.2020.110817
[36]Kui Liu, Shangwen Wang, Anil Koyuncu, TegawendÃ© F. BissyandÃ©, DongsunKim, Peng Wu, Jacques Klein, Xiaoguang Mao, and Yves Le Traon. 2020. Onthe Efficiency of Test Suite based Program Repair: A Systematic Assessmentof16AutomatedRepairSystemsforJavaPrograms.In Proceedingsofthe42nd
InternationalConferenceonSoftwareEngineering .ACM,615â€“627. https://doi.org/
10.1145/3377811.3380338
[37]Pei Liu, Li Li, Yichun Yan, Mattia Fazzini, and John Grundy. 2021. Identifyingand Characterizing Silently-Evolved Methods in the Android API. In The 43rd
ACM/IEEEInternationalConferenceonSoftwareEngineering,SEIPTrack(ICSE-SEIP
2021).
[38]Na Meng, Miryung Kim, and Kathryn S McKinley. 2013. LASE: locating and
applying systematic edits by learning from examples. In 2013 35th International
Conference on Software Engineering (ICSE). IEEE, 502â€“511.
[39]Yihao Qin, Shangwen Wang, Kui Liu, Xiaoguang Mao, and TegawendÃ© F Bis-syandÃ©. 2021. On the Impact of Flaky Tests in Automated Program Repair. In
Proceedings of the 2021 IEEE International Conference on Software Analysis, Evolu-
tion and Reengineering. IEEE, 295â€“306.
[40]RomainRobbes,MirceaLungu,andDavidRÃ¶thlisberger.2012.Howdodevelopers
reacttoAPIdeprecation?ThecaseofaSmalltalkecosystem.In Proceedingsof
the ACMSIGSOFT20th InternationalSymposium on theFoundations ofSoftware
Engineering. 1â€“11.
[41]ReudismamRolim,GustavoSoares,LorisDâ€™Antoni,OleksandrPolozov,Sumit
Gulwani,RohitGheyi,RyoSuzuki,andBjÃ¶rnHartmann.2017. Learningsyntactic
programtransformationsfromexamples.In 2017IEEE/ACM39thInternationalConference on Software Engineering (ICSE). IEEE, 404â€“415.
[42]JordanSamhi, JunGao,NadiaDaoudi,Pierre Graux,HenriHoyez,Xiaoyu Sun,
Kevin Allix, TegawendÃ© F BissyandÃ©, and Jacques Klein. 2021. JuCify: A Step
Towards Android Code Unification for Enhanced Static Analysis. arXiv preprint
arXiv:2112.10469 (2021).
[43]Anand Ashok Sawant, Romain Robbes, and Alberto Bacchelli. 2018. On the
reactiontodeprecationofclientsof4+1popularJavaAPIsandtheJDK. Empirical
Software Engineering 23, 4 (2018), 2158â€“2197.
[44]Simone Scalabrino, Gabriele Bavota, Mario Linares-VÃ¡squez, Michele Lanza, and
Rocco Oliveto. 2019. Data-driven solutions to detectapi compatibility issues inandroid: an empirical study. In 2019 IEEE/ACM 16th International Conference on
Mining Software Repositories (MSR). IEEE, 288â€“298.
[45]XiaoyuSun,LiLi,TegawendÃ©FBissyandÃ©,JacquesKlein,DamienOcteau,and
John Grundy. 2020. Taming Reflection: An Essential Step Towards Whole-
ProgramAnalysisofAndroidApps. ACMTransactionsonSoftwareEngineering
and Methodology (TOSEM) (2020).
[46]Ferdian Thung, Stefanus A Haryono, Lucas Serrano, GillesMuller, Julia Lawall,
DavidLo,andLingxiaoJiang.2020. AutomatedDeprecated-APIUsageUpdate
forAndroidApps:HowFarareWe?.In 2020IEEE27thInternationalConference
on Software Analysis, Evolution and Reengineering (SANER). IEEE, 602â€“611.
[47]HaoyeTian,YinghuaLi,WeiguoPian,AbdoulKaderKabore,KuiLiu,Andrew
Habib, JacquesKlein, andTegawendÃ©F. BissyandÃ©.2022. Predicting PatchCor-
rectness Based on the Similarity of Failing Test Cases. ACM Transactions on
Software Engineering and Methodology (2022).
[48]HaoyeTian,KuiLiu,AbdoulKaderKaborÃ©,AnilKoyuncu,LiLi,JacquesKlein,
and TegawendÃ© F. BissyandÃ©. 2020. Evaluating Representation Learning of Code
ChangesforPredictingPatchCorrectnessinProgramRepair.In Proceedingsof
the35th IEEE/ACMInternationalConference onAutomated SoftwareEngineering.
IEEE, 981â€“992. https://doi.org/10.1145/3324884.3416532
[49]RajaVallÃ©e-Rai,PhongCo, EtienneGagnon,Laurie Hendren,PatrickLam, and
Vijay Sundaresan. 2010. Soot: A Java bytecode optimization framework. In
CASCON First Decade High Impact Papers. 214â€“224.
[50]EelcoVisser.2001. Stratego:Alanguageforprogramtransformationbasedon
rewritingstrategiessystemdescriptionofstratego0.5.In InternationalConference
on Rewriting Techniques and Applications. Springer, 357â€“361.
[51]Haoyu Wang, Hongxuan Liu, Xusheng Xiao, Guozhu Meng, and Yao Guo. 2019.
Characterizing Android app signing issues. In 2019 34th IEEE/ACM International
Conference on Automated Software Engineering (ASE). IEEE, 280â€“292.
[52]Jiawei Wang, Li Li, Kui Liu, and Haipeng Cai. 2020. Exploring How Deprecated
PythonLibraryAPIsare(Not)Handled.In The28thACMJointMeetingonEu-
ropean Software Engineering Conference and Symposium on the Foundations of
Software Engineering (ESEC/FSE 2020).
[53]Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2016. Taming Android fragmen-tation: Characterizing and detecting compatibility issues for Android apps. In
Proceedingsofthe31stIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering. 226â€“237.
[54]LiliWei,YepangLiu,andShing-ChiCheung.2019. Pivot:learningAPI-device
correlationstofacilitateAndroidcompatibilityissuedetection.In 2019IEEE/ACM
41st InternationalConference on Software Engineering (ICSE) . IEEE, 878â€“888.
[55]HaoXia,YuanZhang,YingtianZhou,XiaotingChen,YangWang,XiangyuZhang,ShuaishuaiCui,GengHong,XiaohanZhang,MinYang,etal
.2020. HowAndroid
developershandleevolution-inducedAPIcompatibilityissues:alarge-scalestudy.
In2020 IEEE/ACM42nd International Conferenceon Software Engineering(ICSE).
IEEE, 886â€“898.
[56]Guowei Yang, Jeffrey Jones, Austin Moninger, and Meiru Che. 2018. How do
Android operating system updates impact apps?. In 2018 IEEE/ACM 5th Inter-
nationalConferenceonMobileSoftwareEngineeringandSystems(MOBILESoft).
IEEE, 156â€“160.
[57]Jingtang Zhang, Kui Liu, Dongsun Kim, Li Li, Zhe Liu, Jacques Klein, and
TegawendÃ© F BissyandÃ©. 2021. Revisiting Test Cases to Boost Generate-and-
ValidateProgramRepair.In Proceedingsofthe37thInternationalConferenceon
Software Maintenance and Evolution. IEEE, 35â€“46.
[58]JingZhouandRobertJWalker.2016.APIdeprecation:aretrospectiveanalysisand
detectionmethod forcode examplesonthe web.In Proceedingsof the2016 24th
ACM SIGSOFT International Symposium on Foundations of Software Engineering.
266â€“277.
2153
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:54:36 UTC from IEEE Xplore.  Restrictions apply. 