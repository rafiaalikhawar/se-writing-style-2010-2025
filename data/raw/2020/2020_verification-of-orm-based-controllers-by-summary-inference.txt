Verification of ORM-based Controllers by Summary Inference
Geetam Chawla
Indian Institute of Science
Bangalore, India
geetam.chawla@gmail.comNavneet Aman
Indian Institute of Science
Bangalore, India
navneetankur@gmail.comRaghavan Komondoor
Indian Institute of Science
Bangalore, India
raghavan@iisc.ac.in
Ashish Bokil
Indian Institute of Science
Bangalore, India
ashishsb@iisc.ac.inNilesh Kharat
Indian Institute of Science
Bangalore, India
nileshramesh@iisc.ac.in
ABSTRACT
Inthisworkwedescribeanovelapproachformodeling,analysis
and verification of database-accessing applications that use the
ORM(Object RelationalMapping)paradigm. Ratherthandirectly
analyzeORMcodetocheckspecificproperties,ourapproachinfers
ageneral-purposerelationalalgebrasummaryofeachcontrollerintheapplication.Thissummarycanthenbefedintoanyoff-the-shelf
relationalalgebrasolvertocheckforpropertiesorspecifications
given by a developer. The summaries can also aid program under-
standing, and may have other applications. We have implemented
ourapproachasaprototypetoolthatworksforâ€˜Springâ€™basedMVC
applications. A preliminary e valuation reveals that the approach is
efficient, andgives goodresults while checkinga setof properties
given by human subjects.
CCS CONCEPTS
â€¢Software and its engineering â†’Software verification and
validation ;Softwarefunctionalproperties ;â€¢Informationsys-
temsâ†’Web applications.
KEYWORDS
program analysis, database applications, relational algebra
ACM Reference Format:
Geetam Chawla, Navneet Aman, Raghavan Komondoor, Ashish Bokil,
andNileshKharat.2022.VerificationofORM-basedControllersbySummary
Inference.In 44thInternationalConferenceonSoftwareEngineering(ICSEâ€™22),
May 21â€“29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3510003.3510148
1 INTRODUCTION
MVC (Model-View-Controller) frameworks are regularly used to
develop web applications and RESTfulservices [ 8]. An MVC ap-
plication consists primarily of a set of controllers, each of which
receives requests directed to a specific URL. Much of the core logic
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.35101481@PostMapping("/se tDefaultPayment")
2public String setDefaultPayment(Long defPayId , Model
model , Principal pr incipal){
3Useruser = userService.f indByUsername(principal .
getName() ) ;
4userService.setUserDefaultPayment( defPayId , user);
5...
6}
7
8UserService :: public void setUserDefaultPayment(Long
defPayId , Useruser) {
9List<UserPayment> uPList = uPRepo. findAll () ;
10for(UserPayment uPIter: uPList){
11if(uPIter.getId()==defPayId){
12 uPIter.setDefaultPayment( true);
13 uPRepo.save(uPIter) ;
14}else{
15 uPIter.setDefaultPayment( false);
16 uPRepo.save(uPIter) ;
17}
18}
19}
Figure 1: Example controller
in these controllers tends to be focused on fetching or updating
data in databases. Therefore, MVC frameworks commonly include
ORM(ObjectRelationalMapping)APIs,whichmakedatabaseac-
cess intuitive for programmers. The ORM idea is basically to let
thedeveloperuseimperativeconstructssuchasloops,andaccess
or update a database table as if it were an in-memory collection
ofentities,whereentitiesarein-memoryobjectsrepresentingthe
tuples in the database. ORM is frequently preferred by develop-
ers over embedded SQL (via ODBC APIs) as it avoids impedance
mismatchbetweenSQLandimperativecodeaswellastype-and
schema-related errors.
While the imperative flavor of ORM code is intuitive to many
developers,mechanically checkingproperties ofimperativecodeismorechallengingthanmechanicallyreasoningaboutSQL,whichis
declarative in nature. We propose to bridge this gap by proposing
inthispaperanovelapproachthatinfersadeclarativesummary,
inrelational-algebra form, of the database updates performed by a
controller and of the model attributes that it may return.
23402022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Geetam Chawla, Navneet Aman, Raghavan Komondoor, Ashish Bokil, and Nilesh Kharat
1.1 Motivating Example
Figure 1 depicts a controller1named setDefaultPayment from
an open-source book-store application [ 9] in Spring. The con-
troller in turn calls the method setUserDefaultPayment . This
method first retrieves all â€œuser paymentâ€ entities from a table
named userPayment in Line 9. The repository variable â€˜uPRepoâ€™
corresponds to the table userPayment . Repository variables are
Springâ€™sinterfacestodatabase tables;eachrepositoryvariableim-
plicitlyprovidesmethodcallstoquerytheunderlyingtableusing
the fields of the table and to save tuples into the underlying table.
In the example, each â€˜UserPaymentâ€™ entity represents a pay-
ment method (e.g., the information about a credit card). Each ofthese entities contains a field â€˜idâ€™ (which is the primary key), aboolean field â€˜defaultPaymentâ€™, which encodes whether this pay-
mentmethodistheâ€œdefaultâ€paymentmethodornotforitsowninguser,andafieldâ€˜typeâ€™,whichencodeswhetherthispaymentmethod
is a credit card, or a debit card, etc.
In the loop in Lines 10-18, each â€˜UserPaymentâ€™ entityâ€™s â€˜default-
Paymentâ€™ field is set to trueorfalsedepending on whether this en-
tityâ€™sâ€˜idâ€™fieldisequalornottothegivenargumentâ€˜defPayIdâ€™.These
updated entities are also saved back into the table userPayment.
A developer might want to check if the controller in Figure 1
satisfies certain properties. Consider the following example, which
we denote as Property (1): Does the controller set to true(resp.
false) the â€˜defaultPaymentâ€™ field of a â€˜UserPaymentâ€™ entity only
if the entityâ€™s â€˜idâ€™ field is equal (resp. not equal) to the argument
â€˜defPayIdâ€™? This property is indeed satisfied by the code.
Automatedcheckingofpropertiessuchastheonesabovewould
enable the production of reliable software, and this is the problem
weaddressinthispaper.AutomatedpropertycheckingforORM
controllersisachallengingproblem,forafewdifferentreasons.Thefirstisthatin-memorycollectionsareusedtostorespecificsubsetsof database tables, and these subsets typically need to be character-
ized with good precision by analysis techniques to find property
violations.Secondly,ORMcodefrequentlyusesimperativeloops
to iterate over databases or collections. Generally, loops are known
to be challenging for automated property-checking approaches.
1.2 Our approach
In this paper we propose a static analysis approach to infer sum-maries in relational algebra form from ORM controllers. A sum-
maryofacontrollermaps eachdatabasetablethatisupdatedina
givencontrollerandeachreturnvaluefromthecontrollertoarela-
tionalalgebraexpression.Forthecontrollerâ€˜setDefaultPaymentâ€™in Figure 1, in its inferred summary, the expression for the table
userPayment (whichismappedtotherepositoryvariableâ€˜uPRepoâ€™)
would be as follows.
uPRepoâ†¦â†’Î id,true,type(ğœid=defPayId(uPRepo)) âˆª
Î id,false,type(ğœidâ‰ defPayId(uPRepo))(1)
Note,theoccurrenceofâ€˜uPRepoâ€™withintherelationalalgebraex-
pression to the right of the â€œ â†¦â†’â€ refers to the incoming contents of
the table userPayment when the controller is invoked, while the
1The code shown is simplified in minor ways for ease of presentation. Also, while we
refer to each request-handling method as a â€œcontrollerâ€, the general terminology is to
refer to a class that may contain several request handling methods as a controller.for (/angbracketleftitr/angbracketright:/angbracketleftcoll1/angbracketright){
if (/angbracketleftcond/angbracketright)
/angbracketleftcoll2/angbracketright.save(/angbracketlefttuple1/angbracketright);
else
/angbracketleftcoll2/angbracketright.save(/angbracketlefttuple2/angbracketright);
}â‡’/angbracketleftcoll2/angbracketright â†¦â†’
/angbracketleftcoll2/angbracketright-/angbracketleftcoll1/angbracketrightâˆª
Î /angbracketlefttuple1/angbracketright(ğœ/angbracketleftcond/angbracketright(/angbracketleftcoll1/angbracketright))âˆª
Î /angbracketlefttuple2/angbracketright(ğœÂ¬/angbracketleftcond/angbracketright(/angbracketleftcoll1/angbracketright))
Figure 2: Code pattern based rewrite rule
occurrencetotheleftofâ€˜ â†¦â†’â€™denotestheupdatedcontentswhen
thecontrollerfinishesexecution.Also,throughoutthispaperwe
use a generalized form of the projection operator â€˜ Î â€™ that allows
anytupleofexpressionsinitssubscript,andnotjustatupleoffield
names.
SaywewanttocheckProperty(1)mentionedinSection1.1.The
developer may specify this property as:
ğœidâ‰ defPayId âˆ§defaultPayment â‰ false(uPRepo)=âˆ…(2)
Now,anoff-the-shelfrelationalalgebrasolvercanbeusedtocheck
that the inferred summary shown in Equation (1) logically implies
thespecificationshownabove2,andhencedeclareProperty(1)as
holding.
Summarizing loops (such as the one in Figure 1) is similar to
inferring loopinvariants.Thisisknowntobeachallengingproblem
in program analysis, and would be especially so when loops iterateovercollections,copyentitiesfromonecollectiontoanotherunder
somecondition,etc.Tocircumventthisdifficulty,weproposean
efficientpattern-basedrewritingtechniquetoinfersummariesof
loops.
A pattern-based rewrite rule that suffices for our example in
Figure1isdepictedinFigure2.Thenameswithinanglebrackets
aremeta-variables,whichmatchactualexpressionsinthecode.Ifa
rewrite ruleâ€™s LHS (left hand side) matches a loop, then, intuitively,
thesummaryisobtainedbyinstantiatingtheRHS(righthandside)
pattern. That is, themeta-variables in the RHS are replaced with
their matching expressions as obtained from the LHS.
WhentheLHSofthe patternshown inFigure2ismatchedwith
the loop in Figure 1, the meta-variable /angbracketleftitr/angbracketrightmatches the iterator
variable â€˜uPIterâ€™, /angbracketleftcoll1/angbracketrightmatches the collection â€˜uPListâ€™, and so on.
Afterâ€˜uPListâ€™isdeterminedtobeequaltoâ€˜uPRepoâ€™(usingLine9
inthecode),theinstantiatedRHSbecomesequaltothesummary
shown in Equation (1).
Notwithstanding the simplified intuition mentioned above, the
rewritingprocessisnotentirelysyntacticorstraightforward.For
instance, even though /angbracketlefttuple1/angbracketrightsyntactically matches â€˜uPIterâ€™ in
Line 13 of the code, /angbracketlefttuple1/angbracketrightis replaced in the inferred summary
with â€œid, true, type â€, rather than with any references to â€˜uPIterâ€™.
Thetransformationsreferredtoaboveareperformedbyemploying
staticanalysistoinferthevaluesstoredinvariables.Thesetransfor-
mations are necessary because the inferred summary should refer
toonlytheincomingdatabasetablesandarguments,andnottothe
values of local variables or iterators.
2This can be done by replacing the â€˜uPRepoâ€™ in Equation (2) with the right-hand-side
of Equation (1) and then checking the validity of Equation (2).
2341
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Verification of ORM-based Controllers by Summary Inference ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
1.3 Contributions
Controllersummarization. Theprimarycontributionofthispa-
perisanovelapproachforsummarizationofORMcontrollersin
the form of relational algebra. Our approach is the first one to the
bestofourknowledgethatusesstaticanalysistoinferfunctional
summaries for Java controllers.
Pattern based rewriting. As part of our approach, we introduce a
novel, efficient and effective pattern-based rewriting mechanism to
summarize a variety of ORM loops.
Arelatedapproachthatalsoaddressestheproblemofsumma-
rization of ORM code is by BociÄ‡ and Bultan [ 2]. Their approach
attempts to infer loop-invariants for ORM code without any pat-
terns, but is guaranteed to terminate only on certain classes of
loops, and abstracts away scalar operations and conditionals.
Reasoningontraces. Weintroduceaninductiveandefficienttech-
niquetoverifypropertiesof allpossibletraces inaMVCapplication
that pass through specified controllers.
Prototypetool. Wedescribeaprototypeimplementationofour
approach, which is a tool called ORMInfer. ORMInfer infers a sum-
mary for a given controller method. While our approach conceptu-
allyappliestoanyORMmechanism,ourimplementationtargets
Spring[24], which is the most popular MVC framework for Java,
and the third most popular backend development framework over-
all [21]. ORMInfer includes a DSL (domain specific language) to
specify pattern-based rewrite rules. Our core implementation in-fers a relational algebra summary in a solver-independent form,
whileapostpasstranslatesthesummaryintothewidelyusedAlloy
Language[ 18]inordertobefurthercheckedbytheAlloysolver.
Wehavealsoimplementedourtrace-propertycheckingapproach
mentionedaboveasatool MultiORM,andthistoolisdependenton
ORMInfer to obtain summaries of the individual controllers that
the traces go through.
Evaluation. Weappliedourtoolonsixopen-sourceSpringbench-
marks,andusedtheinferredsummariestocheckpropertiespro-
vided by a set of volunteer graduate students. Our approach identi-
fiedcorrectresults(pass/fail)onabout76%oftheproperties,and
also demonstrated itself as being very efficient.
Therestofthispaperisstructuredasfollows.Section2describes
our core contribution of summarizing a controller. Section 3 de-scribes the trace-checking extension mentioned above. Section 4
givesanoverviewofourprototypeimplementation,whileSection5presentsourempiricalevaluation.Section6discussesrelatedwork,
while Section 7 concludes the paper.
2 OUR APPROACH FOR CONTROLLER
SUMMARIZATION
In this section we present the core of our approach, which is a
syntax-directedtechniquetoinferarelationalalgebrasummaryfor
a given controller.
2.1 Flattening
Inferring summaries for updated repositories and return values
requires,asanintermediatestep,summariesforlocalvariablesas
well as heap objects. Heap objects could potentially be modeledusingsymbolic objects provided by points-to analysis. However,
points-to analysis is in general expensive, and can also reduce
precisionbyover-approximatinginformationonwhichvariables
point to which objects. In bug-detection settings like ours, high
precision is desired in order to minimize false positives.
Therefore,weadopta flattening basedapproachthatdoesnot
use points-to or alias analysis. The idea intuitively is to modelthe heap using a set of variables, whose types are primitives or
collectionsbutnotobjectreferences.Forinstance,ifavariable v1
is an object reference, we replace v1with a set of access paths of
the form v1.f,v1.g, etc., based on the fields declared in v1â€™s type.
Ifv1.fis itself an object reference, we further replace it with a set
v1.f.k,v1.f.l, and so on. We do this at all depths, and retain a
variablewithoutfurtherexpansiononlyifitslastfieldisaprimitive
or a Java collection. This process can go into non-termination in
thepresenceofcyclicreferences.Therefore,toenforcetermination,
we impose a length bound on access paths, and throw away any
access path that ends in an object reference and that already has as
many fields as the bound permits.
Aftertheflatteningmentionedabove,weeffectivelytreateach
accesspathasifitwereasingle(nonobjectreference)variable.We
start referring to the access paths simply as variables from here
on,andcorrespondingly,useunderscoresinsteadofdotsintheir
representations.
Ournextstepistoreplaceeachoriginalassignmentstatement
withasetofstatementsthatmakeuseofthe(flattened)variables
obtained above. For instance, a statement of the form â€œ v 1=v 2â€
wouldbereplacedwiththeset(actually,sequence)ofstatements
â€œv1_g=v2_g;v1_f_k=v2_f_k;v1_f_l=v2_f_l;...â€, the statement
â€œv1.f = v3 â€wouldbereplacedwithâ€œ v1_f_k=v3_k;v1_f_l=v3_l;
...â€, and so on.
Theflatteningapproachmentionedabovecanpotentiallygive
rise to incorrect summaries in the presence of arbitrary aliasing
betweenvariablesoraccesspaths.H owever, it isourobservation
thatreal-lifeJavacontrollersareveryidiomatic,anddonotnormally
setup aliasing between access paths or use the heap in rich ways.
2.2 Summary inference for simple statements
The flattening mentioned above is done as a pre-pass. After the
flattening, the rest of the approach is syntax-directed. It essentially
performsabottom-uptraversalofthe AbstractSyntaxTree (AST)of
thecontrollerâ€™scode,andgeneratesthesummaryofeachsubtree
using the already generated summaries of the immediately nested
subtrees.Inthispartofthepaperwediscusshowsummariesare
inferred for non-looping code fragments.
Figure 3 gives a set of rules for the process described above, one
rule per kind of statement. The notation â€œ S/turnstileleftğ‘’â€ means that ğ‘’is the
inferredsummaryofstatement S,whereğ‘’isamappingfromaccess-
paths to relational algebra expressions. The subroutine mkcond
translates its argument syntactic condition into a conditionin the
syntaxofrelationalalgebra. Type(ğ‘£)returnsthenameofthetable
correspondingtothedeclaredtypeof ğ‘£(whichisanentityclass),
whileTypeElement (ğ‘£) returns the name of the table corresponding
to the entities declared to be stored in ğ‘£provided ğ‘£is a collection.
Figure4illustratesthebottom-upsummarizationforourrunning
exampleinFigure1.Sinceweareignoringmethodcallsatthispoint,
2342
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Geetam Chawla, Navneet Aman, Raghavan Komondoor, Ashish Bokil, and Nilesh Kharat
assign: v1:=v2/turnstileleft{(ğ‘£1,ğ‘£2)}
seqence:
ğ‘†1/turnstileleftVLğ‘†2/turnstileleftVR
S1; S2 /turnstileleft{(ğ‘˜,ğ‘£)|ğ‘£=VR(ğ‘˜)[VL(ğ‘”1)/ğ‘”1].....[VL(ğ‘”ğ‘›)/ğ‘”ğ‘›]
ifğ‘˜âˆˆdomain(VR),
n is the number of leaves in V R(ğ‘˜)
ğ‘”1,ğ‘”2...ğ‘”ğ‘›are leaves in V R(ğ‘˜)
ğ‘£=VL(ğ‘˜),ifğ‘˜âˆˆVL}
If-Then-Else:
ğ‘†1/turnstileleftVTğ‘†2/turnstileleftVE
if c then S1 else S2 /turnstileleft{(ğ‘˜,ğ‘£)|ğ‘£=(mkcond(c)?VT(ğ‘˜):VE(ğ‘˜))
ifğ‘˜âˆˆVTandğ‘˜âˆˆVE
ğ‘£=(mkcond(c)?VT(k):ğ‘˜)
ifğ‘˜âˆˆVT
ğ‘£=(mkcond(c)?ğ‘˜:VE(ğ‘˜))
ifğ‘˜âˆˆVE}
alloc: v=new T/turnstileleft{(ğ‘£,DefaultVal )}
CollAdd:
ğ‘“1.....ğ‘“ğ‘›are primitive columns in TypeElement (v)
v.add(w) /turnstileleft{(ğ‘£,ğ‘£âˆª(ğ‘¤_ğ‘“1,...,ğ‘¤_ğ‘“ğ‘›))}
RepoSave:
ğ‘“1.....ğ‘“ğ‘›are primitive columns in Type(ğ‘£)
repo.save(v) /turnstileleft{(repo,repoâˆ’ğœğ‘–ğ‘‘=ğ‘£_ğ‘–ğ‘‘(repo)âˆª
(ğ‘£_ğ‘“1,...,ğ‘£_ğ‘“ğ‘›))}
Delete: repo.deleteById(v) /turnstileleft{(repo,repoâˆ’ğœğ‘–ğ‘‘=ğ‘£(ğ‘Ÿğ‘’ğ‘ğ‘œ))}
Figure 3: Inference rules for simple statements
we treat the method setUserDefaultPayment as if it is the con-
troller in this illustration (although method setDefaultPayment
is the actual controller). Also, we treat the getter and setter calls
in Lines 11, 12, and 15 as if they were inlined to yield direct field
references. Each row in Figure 4 depicts the inferred summary for
acertainASTsubtree,whichcorrespondstothecoderegionwhoselinenumbersaregiveninthefirstcolumn.Eachsummaryisingen-
eral a mapping from variables that are modified in the code region
to their individual summaries, each of which is a relational algebra
expression.Relationalalgebraexpressionsuseprogramvariables,
repository variables or table names, and constants, as leaves.
The row for Line 12 in Figure 4 depicts how assignment state-
ments are modeled: the summary of the LHS variable is simply the
expressionthatoccursintheRHS.ThesummaryforLine13usesanextendedrelationalalgebraoperator,namely, save.Thisoperator
has two operands, namely, the repository (and underlying table) to
saveinto,andthetupletosave.Notethatthesinglevariable uPIter
in Line 13 in the code has become a tuple of variables at this point;
this happens because uPIteris an object reference, and has been
flattened. Another noteworthy point in Line 13 is that a variable
can occur on both sides of the â€˜ â†¦â†’â€™ symbol in a summary, with the
RHS(resp.LHS)occurrencedenotingtheincomingvalueinto(resp.
outgoing from) the corresponding code region.
The entry for Lines 12-13 in Figure 4 illustrates summary in-
ference for statement sequences. The mappings (i.e., summaries)
corresponding to the two regions are basically composed ; hence, in
the example, the second component in the tuple within the save
operation is now true(rather than uPIter_defaultPayment ).
TheentryforLines11-17illustratesprocessingforif-then-else
constructs.Aternaryâ€œ?:â€operatorisusedinourextendedrelational
algebra to model this construct in a straightforward manner.
Spring ORM implicitly provides schema-specific query methods
on repository variables. Our approach converts calls to these meth-ods to equivalent relational algebra. For instance, for the statement
inLine9inFigure1,thesummaryweinferisâ€œ upListâ†¦â†’upRepoâ€.
In cases where a query method returns a single element, summary
inference also accounts for flattening. For instance, a statement â€œ v
= uPRepo.findById(x) â€ would result in a summary as depicted
below:
v_id â†¦â†’Î id(ğœğ‘–ğ‘‘=ğ‘¥uPRepo)
v_defaultPayment â†¦â†’Î defaultPayment (ğœğ‘–ğ‘‘=ğ‘¥uPRepo)
v_type â†¦â†’Î type(ğœğ‘–ğ‘‘=ğ‘¥uPRepo)
Spring ORM supports certain kinds of annotations to intro-
duce fields within entity declarations. These annotated fieldsdo not correspond to columns in the underlying table, but arepointers that explicitly encode relationships with other entities.Our summary inference approach for query method calls ac-counts for these as well. For instance, consider a field declaredas â€œ
@OneToOne UserBilling uBilling â€ within the entity class
â€˜UserPaymentâ€™. Say nameis a primitive column in the â€˜userBillingâ€™
table, and say paymentId is another column in the â€˜userBillingâ€™
table and is a foreign key into the â€˜userPaymentâ€™ table. Say thecontroller had a statement â€œ
payment = uPRepo.findById(x) â€.
OurflatteningapproachtreatsOneToOneandManyToOnefields
similar to pointers, and flattens through them. Therefore, thestatement above would yield a set of statements, one of which
would be â€œ
payment_uBilling_name=uPRepo.findById(x) â€. Our
approach generates a summary for this statement in which
payment_uBilling_nameis mapped to the relational algebra
expression Î name(Î Cols(userBilling )(ğœid=paymentId (ğœid=x(uPRepo)Ã—
userBilling ))). In a similar manner, we handle â€˜OneToManyâ€™ and
â€˜ManyToManyâ€™ annotations as well.
A set of formal inference rules to summarize query-method call-
ing statementsis givenin Figure5. Thebottommost tworules are
therootrules. In these rulesâ€™ consequents, the part before the â€˜ /turnstileleftâ€™i s
the(flattened)statementthatneedstobesummarized,with accp
beingaflattenedaccesspath. relExpFor isasubroutinewhoseim-
plementation is not shown; it is assumed to return the relational
algebra expression corresponding to its argument. The â€˜ /dblarrowheadrightâ€™ deriva-
tions are defined using the first three rules in Figure 5. ğ‘’1/multicloseboth1ğ‘’2is a
2343
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Verification of ORM-based Controllers by Summary Inference ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Line #Summary
12uPIter_defaultPayment â†¦â†’true
13uPRepoâ†¦â†’save(uPRepo,(uPIter_id,uPIter_defaultPayment ,uPIter_type))
12-13uPIter_defaultPayment â†¦â†’true
uPRepoâ†¦â†’save(uPRepo,(uPIter_id,true,uPIter_type))
15-16uPIter_defaultPayment â†¦â†’false
uPRepoâ†¦â†’save(uPRepo,(uPIter_id,false,uPIter_type))
11-17uPIter_defaultPayment â†¦â†’(uPIter_id=defPayId)?true:false
uPRepoâ†¦â†’(uPIter_id=defPayId)?
save(uPRepo,(uPIter_id,true,uPIter_type)):save(uPRepo,(uPIter_id,false,uPIter_type))
10-18uPRepoâ†¦â†’(uPRepo-uPList)âˆªÎ id,true,type(ğœid=defPayIduPList)âˆªÎ id,false,type(ğœidâ‰ defPayIduPList)
uPListâ†¦â†’Î id,(id=defPayId )?true:false,typeğ‘¢ğ‘ƒğ¿ğ‘–ğ‘ ğ‘¡
9-18uPRepoâ†¦â†’Î id,true,type(ğœid=defPayIduPRepo)âˆªÎ id,false,type(ğœidâ‰ defPayIduPRepo)
uPListâ†¦â†’Î id,(id=defPayId )?true:false,typeğ‘¢ğ‘ƒğ‘…ğ‘’ğ‘ğ‘œ
Figure 4: Illustration of summary construction
ğ‘“2is a *ToOne field
/angbracketleftğ‘“2_ğ‘“3_ğ‘“4...,Î Cols(Type(ğ‘“2))(relExp /multicloseboth1Type(ğ‘“2))/angbracketright/dblarrowheadrightrelExp1
/angbracketleftğ‘“1_ğ‘“2_ğ‘“3_ğ‘“4...,relExp/angbracketright/dblarrowheadrightrelExp1
ğ‘“2is a *ToMany field
/angbracketleftğ‘“1_ğ‘“2,relExp/angbracketright/dblarrowheadrightÎ Cols(TypeElement (ğ‘“2))(relExp /multicloseboth1Type(ğ‘“2))
ğ‘“2is a primitive field
/angbracketleftğ‘“1_ğ‘“2,relExp/angbracketright/dblarrowheadrightÎ ğ‘“2(relExp)
/angbracketleftaccp,relExpFor (repo.findByCol (X))/angbracketright/dblarrowheadrightrelExp
accp=repo.findByCol (X)/turnstileleft{ (accp,relExp)}
accp=repo.findAll() /turnstileleft {(accp ,relExpFor (repo.findAll()))}
Figure 5: Inference rules for query-method calls
joinoperationwhosejoinpredicateequatestheforeign-keyfield
inğ‘’2with the primary key field field in ğ‘’1.
2.3 Summary inference for loops
Inthispartofthepaperwediscusshowweinferthesummaryof
aloopafterhavinginferredthesummaryofthebodyoftheloop
using pattern-based rewriting rules.
InFigure2,forsimplicityofpresentation,theLHSoftherewrite
rule was shown as if it was a syntactic or code-based pattern.
However, inoursystem,actually, anyrewriterule ğ‘–isofthe form
LHSğ‘–â‡’RHSğ‘–, where both LHSğ‘–andRHSğ‘–are relational algebra
expressions. Both these expressions are patterns, and are hence
allowed to have meta variables, also known as pattern variables, at
leaf (i.e., operand) positions.We made the important choice mentioned above for a couple
of reasons. Firstly, as our summary inference approach proceeds
bottom-upintheAST,therelationalalgebraexpressionforaloopâ€™s
bodywouldanywaybeavailablebythetimetheloopâ€™ssummary
is to be inferred. Secondly, relational algebra summaries are free
ofinternaldataflowthroughlocalvariables,andarehencemore
declarative. Thus, a pattern based on relational algebra is more
likely to successfully match a variety of different loop structures
that have the same semantics.
Algorithm 1 SummarizeLoop(body ,coll,itr)
1:summ=âˆ…
2:for allvariables ğ‘£inthedomainof body,excludingvariables
of the form itr_fdo
3:Letexpr1=body(ğ‘£)
4:ifexists a rewrite rule LHSğ‘–â‡’RHSğ‘–such that match(LHSğ‘–,
expr1,coll,itr,ğ‘£)=v2eandv2eâ‰ âŠ¥then
5:Letexpr2be equal to subst(RHSğ‘–,v2e), andexpr3be equal
toexpr2with each itr_fireplaced with coll.ğ‘“ğ‘–.
6:Addğ‘£â†’expr3tosumm
7:else
8:Addğ‘£â†’Unknown tosumm
9:end if
10:end for
11:ifanyitr_fiis in the domain of bodythen
12:Lettuplebethetupleformed fromtheexpressionsthatthe
variablesoftheform itr_fiaremappedtoin body.Addcollâ†’
Î tuple(coll)tosumm.
13:end if
14:returnsumm
TheapproachforsummarizingaloopisdepictedinAlgorithm1.
Theargument bodyisthesummaryoftheloopbodyalone,obtained
previouslyaspartofthebottom-uptraversaloftheAST.Inother
words,itisamappingfromeachvariablethatismodifiedwithin
the loop body to the relational-algebra summary of the value that
is assigned to the variable in the loop body (i.e., intuitively, ina single iteration of the loop). The argument
collis the name of
2344
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Geetam Chawla, Navneet Aman, Raghavan Komondoor, Ashish Bokil, and Nilesh Kharat
the collection variable being iterated over in the loop, while the
argument itris the name of the iterator variable. For the loop in
Figure 1, bodyis depicted next to Lines 11-17 in Figure 4, collis
â€˜uPListâ€™ and itris â€˜uPIterâ€™. summis the summary of the entire loop,
to be returned at the end.
The loop in Lines 2-10 in Algorithm 1 summarizes each variable
ğ‘£oneaftertheother. expr1isthesummaryofthevalueassigned
toğ‘£in the loopâ€™s body. The function matchis used to check if
theLHSofarewriterulematches expr1.Thefunctionchecksthe
following two conditions: (i) LHSğ‘–andexpr1are isomorphic as
trees, not counting the operand positions in LHSğ‘–where there
are meta variables, and (ii) at every position where the special
meta variables /angbracketleftcoll/angbracketright//angbracketleftitr/angbracketright//angbracketleftlvar/angbracketrightoccur inLHSğ‘–, the values of the
arguments coll/itr/ğ‘£,respectively,occurin expr1.Ifthecheckpasses,
matchreturns a mapping v2e, which maps every meta-variable
occurring in LHSğ‘–to its matching sub-expression in expr1.v2e
also maps /angbracketleftcoll/angbracketright//angbracketleftitr/angbracketright//angbracketleftlvar/angbracketrightto the values in arguments coll/itr/ğ‘£,
respectively. matchreturnsâŠ¥if the conditions named above do
nothold.IftheLHSâ€™sofmultiplerulesmatch expr1,Line4inthe
algorithm picks the earliest matching rule.
Lines 5-6 in the algorithm produce the summary of ğ‘£as far
the full loop is concerned; basically, this summary accounts for
thecumulativeupdatesdoneto ğ‘£acrossalliterationsoftheloop.
The summary is produced by the function subst, which simply
replaces every occurrence of any meta variable ğ‘¤inRHSğ‘–with the
correspondingsubexpression v2e(ğ‘¤).Eachoccurrenceof itr_fiis
finallyreplacedwith coll.ğ‘“ğ‘–,asitr_fiisalocalvariableandrepresents
the value of the field ğ‘“ğ‘–in a single iteration.
2.3.1 Illustrations. Part (A) of Figure 6 illustrates the summariza-
tion of the loop in Figure 1. Row (b) depicts the LHS of a rewriting
rule, while Row (c) depicts the RHS. (These correspond to the LHS-
RHS shown informally as a code-pattern in Figure 2.) The variable
whose summary is being computed ( ğ‘£in Algorithm 1) is â€˜uPRepoâ€™.
Row(a)depicts body(uPRepo),whichisthesummaryofâ€˜uPRepoâ€™
asinferredfromtheloopâ€™sbody.Themapping v2eisrepresented
by the underbraces. Row (d) depicts the result of applying subst
ontheRHSpatterninRow(c)usingthemapping v2ereferredto
above. This result is the final relational expression for â€˜uPRepoâ€™in the loopâ€™s summary (the same information is present againstLines 10-18 in Figure 4). Intuitively, this rewrite rule is meant tosummarize the action of saving different tuples into a repository
across different iterations of a loop.
Lines12-13inAlgorithm1basicallyproducethesummaryfor
â€˜uPListâ€™ that is shown against Lines 10-18 in Figure 4).
Rows (b) and (c) in Part (B) of Figure 6 depict another sample
rewrite rule. This rule is meant to summarize the action of delet-
ingspecifictuplesfromarepositoryineachiterationoftheloop.
Rows (a) and (d) show the pre-computed loop-body-summary and
the full-loop-summary inferred using the rewrite rule, respectively,
for the example loop that appears to the left in Part (B).
Finally,Part(C)followsasimilarformatasPart(B),andillustrates
aanothersamplerule,whichinfersasum-aggregationoperation
overafieldofallentitiesinacollection.Thisrulecanbegeneralizedeasilytoaccountforthesituationwhereonlycertainentitiesinthe
collection are selected for the aggregation.2.4 Capabilities and limitations
Our approach handles nested loops naturally. We handle precisely
onlyloopsthatiterateovercollections,asORMprogramsprimarilyusethistypeofloop.Forothertypesofloopsweconservativelymap
modified variables to â€˜Unknown â€™ values. Our approach performs
inter-procedural analysis basically by simulating inlining. Thistechnique may not terminate in the presence of recursion, but
we have not come across recursion in application code in Spring
benchmarksthatwehaveseen.Thetwolimitationsjustmentioned
are also shared by closely related work [2].
In our approach, the summary of a controller not only includes
summaries for updated repositories, but also summaries for model
attributes, which are the return values sent by controllers to views.
Our approach is soundwith regard to loop-free code fragments.
Soundnessmeansthat anypropertythatisimplied byasummary
is also satisfied by the code. Our approach is also complete with
regardtoloop-freecodefragments,inthesensethatifrelational
algebra suffices to capture the full semantics of a fragment of code,
our approach will infer such a summary. Both these claims areconditional on no-aliasing between variables and on a sufficient
bound for flattening.
Alimitationofourapproachisthatifavariableoraccesspath
refers to a collection of entities, then the summary of this variable
or access path will be a â€˜ ğœâ€™ expression that contains information
about primitive fields but contains no information about Spring-
annotation fields within these entities. Capturing such information
ingeneralneeds nestedrelationalalgebra.Currentlyourinferred
summaries as well user-provided properties are restricted to flat
relational algebra (in which only primitive fields in collections are
referred to).
Afinalpointtonoteisthatinthepresenceofloopsourapproach
does not have absolute soundness or completeness. Currently itis up to developers to ensure that the rewrite rules they specify
aresound,i.e.,semanticallyvalid.Also,theextenttowhichloops
aresummarizedpreciselydependsonthesufficiencyofthesetof
rewrite rules provided.
3 CHECKING PROPERTIES OF TRACES
Generally,manyinterestingpropertiesofcontrollersareinterms
oftheirincomingandoutgoing database states(inadditiontothe
inputargumentsandreturnedmodelattributes).Forinstance,inan
open-source benchmark called â€˜PetClinicâ€™ [ 14] that we used in our
evaluations, thereis acontroller named â€˜processCreationFormâ€™.It
acceptsatupleof(primitivetyped)inputargumentscorresponding
to an â€˜Ownerâ€™ entity, such as (id, lastName, firstName, city), and
saves thistuple asan entityinto arepository called â€˜owRepoâ€™. Say
the property that the developer has in mind is to check if thiscontroller indeed saves the given tuple into persistent state. To
write this as a single-controller property, the developer would first
need to guess that this controller would be saving its argument
tuple into some database table, and would secondly need to know
the name of repository it is saving into. We also refer the reader
tothesamplepropertyinEquation(2)inSection1.2,whichhasa
similar flavor, and is in terms of the updated state of the repository
â€˜uPRepoâ€™.
2345
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Verification of ORM-based Controllers by Summary Inference ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
(A)(a)(uPIter_id=defPayId)?
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipuprightsave(uPRepo,(uPIter_id,true,uPIter_type)):
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipuprightsave(uPRepo,(uPIter_id,false,uPIter_type))
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright
(b) /angbracketleftcond/angbracketright? save(/angbracketleftlvar/angbracketright,/angbracketlefttuple1/angbracketright): save(/angbracketleftlvar/angbracketright,/angbracketlefttuple2/angbracketright)
(c)(/angbracketleftlvar/angbracketrightâˆ’/angbracketleftcoll/angbracketright) âˆª Î /angbracketlefttuple1/angbracketright(ğœ/angbracketleftcond/angbracketright/angbracketleftcoll/angbracketright) âˆª Î /angbracketlefttuple2/angbracketright(ğœÂ¬/angbracketleftcond/angbracketright/angbracketleftcoll/angbracketright)
(d)/bracehtipdownleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright/bracehtipupleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright
(uPRepoâˆ’uPList)âˆª/bracehtipdownleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright/bracehtipupleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright
Î uPList.id,true,
uPList.type(ğœuPList.id=defPayId/angbracketleftuPList/angbracketright) âˆª/bracehtipdownleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright/bracehtipupleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright
Î uPList.id,false,
uPList.type(ğœuPList.idâ‰ defPayId/angbracketleftuPList/angbracketright)
(B)for (UType uItr: uColl) {
if (uItr.column1 = k) {
uRepo.deleteById(uItr.getId());
}
}(a)(uItr_column1 =ğ‘˜)?
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipuprightuRepo:uRepoâˆ’ğœuRepo.id=uItr_id(uRepo)
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright
(b) /angbracketleftcond/angbracketright? /angbracketleftlvar/angbracketright:/angbracketleftlvar/angbracketrightâˆ’ğœ/angbracketleftlvar/angbracketright./angbracketleftf/angbracketright=/angbracketleftexr/angbracketright(/angbracketleftlvar/angbracketright)
(c) /angbracketleftlvar/angbracketrightâˆ’ ğœ/angbracketleftlvar/angbracketright./angbracketleftf/angbracketrightâˆˆÎ /angbracketleftexpr/angbracketright(ğœ/angbracketleftcond/angbracketright(/angbracketleftcoll/angbracketright))(/angbracketleftlvar/angbracketright)
(d)/bracehtipdownleft/bracehext/bracehext/bracehext/bracehtipupright/bracehtipupleft /bracehext/bracehext/bracehext/bracehtipdownright
uRepoâˆ’/bracehtipdownleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright/bracehtipupleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright
ğœuRepo.idâˆˆÎ uColl.id(ğœ(uColl.column1=ğ‘˜)(uColl))(uRepo)
(C)for (Long pItr: pIds) {
PType product = pRepo.findById(pItr);
total = total + product.price;
}(a) total+/bracehtipupleft/bracehext/bracehtipdownright/bracehtipdownleft /bracehext/bracehtipuprightÎ pRepo.price(ğœpRepo.id=pItr(pRepo))
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright
(b) /angbracketleftlvar/angbracketright+ Î /angbracketleftrepo/angbracketright./angbracketleftf/angbracketright(ğœ/angbracketleftrepo/angbracketright./angbracketleftg/angbracketright=/angbracketleftitr/angbracketright(/angbracketleftrepo/angbracketright))
(c)/angbracketleftlvar/angbracketright+ğºsum(/angbracketleftrepo/angbracketright./angbracketleftf/angbracketright)(ğœ/angbracketleftrepo/angbracketright./angbracketleftg/angbracketrightâˆˆ/angbracketleftcoll/angbracketright(/angbracketleftrepo/angbracketright))
(d)/bracehtipdownleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright/bracehtipupleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright
total+ğºsum(pRepo.price)(/bracehtipdownleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright/bracehtipupleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright
ğœpRepo.idâˆˆpIds(pRepo))
Figure 6: Sample loop-summarization patterns
Ourobservationinthissectionisthatawarenessofthedatabase
schema and of the access relationships between controllers and
databasetablesmaybecomeunnecessaryifpropertiesarespecified
in a different way â€“ purely in terms of argument and return-value
behaviorof pairsofrelatedcontrollers.Forinstance,inthePetClinic
benchmarkthereisanothercontrollernamedâ€˜processFindFormâ€™,
which takes a lastName as argument, and returns (to a view) via a
modelattributethesetofallOwnerentitieswiththegivenlastName.
IfoneisawareofthiscontrolleranditsI/Obehaviorasstatedabove,onecouldwritemorenatural(i.e.,databaseindependent)versionofthesingle-controllerpropertymentionedinthepreviousparagraph
as follows:
IfprocessCreationFormisinvokedinatraceandthenprocessFind-
Form is invoked next, if the lastName given to processFindForm is
equal to the lastName given to processCreationForm, then one of the
â€˜Ownerâ€™entitiesreturnedbyprocessFindFormagreesinallitsfields
with the tuple of argument values given to processCreationForm.
3.1 Approach
Definition 3.1 (Trace property). A trace property wrt two con-
trollersğ¶ğ´andğ¶ğµis a predicate ğœ“(ğ‘–ğ‘“,ğ‘œğ‘“,ğ‘–ğ‘™,ğ‘œğ‘™)on the variables
ğ‘–ğ‘“,ğ‘œğ‘“,ğ‘–ğ‘™,ğ‘œğ‘™,whereğ‘–ğ‘“representsthetupleofinputargumentsto ğ¶ğ´,
ğ‘œğ‘“isthetupleofreturnvalues(i.e.,modelattributes)from ğ¶ğ´,and
ğ‘–ğ‘™andğ‘œğ‘™are analogously defined and pertain to ğ¶ğµ.
Definition 3.2 (Trace satisfaction). A traceğ‘¡(i.e., a run of the
application) is said to satisfy a trace property ğœ“(ğ‘–ğ‘“,ğ‘œğ‘“,ğ‘–ğ‘™,ğ‘œğ‘™)wrt
two given controllers ğ¶ğ´andğ¶ğµand wrt a given set of controllers
notBetween if the following condition holds: Ifğ‘¡invokesğ¶ğ´at some
point with actual arguments ğ‘–ğ‘and receives actual return values ğ‘œğ‘,
andğ‘¡invokesğ¶ğµat somelater pointwith actual arguments ğ‘–ğ‘and
receives actual values ğ‘œğ‘, andğ‘¡does not visit any controller in the set
notBetween betweentheaforementionedvisitsto ğ¶ğ´andğ¶ğµ,then
ğœ“(ğ‘–ğ‘,ğ‘œğ‘,ğ‘–ğ‘,ğ‘œğ‘)holds.Ourproblem statement is: Given two controllers ğ¶ğ´andğ¶ğµ
and a set of controllers notBetween and a trace-property ğœ“, check if
all traces of the application satisfy ğœ“.
Notethatwehavegeneralizedourproblemstatement,inthat ğ¶ğ´
andğ¶ğµneednotbeinvokedbacktoback.Thisgeneralizationgives
astrongerguaranteeabouttheapplication,asitreasonsacrossa
potentially infinite set of traces of unbounded lengths.
We use the notation ğ¶(ğ‘‘ğ‘–,ğ‘‘ğ‘œ,ğ‘–ğ‘,ğ‘œğ‘)to denote the summary of a
given controller ğ¶as inferred by the approach of Section 2. ğ‘‘ğ‘–and
ğ‘‘ğ‘œarevariablesinthesummarythatdenotetheincomingdatabase
state and outgoing data base state, respectively, while ğ‘–ğ‘andğ‘œğ‘
denotetheinputargumentstoandreturnvaluesfromthecontroller,
respectively.
The approachwe proposefor ourproblem is basicallyto check
the following two properties using any relational algebra solver.
âˆ€ğ‘‘1,ğ‘‘2,ğ‘‘3,ğ‘–ğ´,ğ‘–ğµ,ğ‘œğ´,ğ‘œğµ
ğ¶ğ´(ğ‘‘1,ğ‘‘2,ğ‘–ğ´,ğ‘œğ´)âˆ§ğ¶ğµ(ğ‘‘2,ğ‘‘3,ğ‘–ğµ,ğ‘œğµ)
â‡’ğœ“(ğ‘–ğ´,ğ‘œğ´,ğ‘–ğµ,ğ‘œğµ)(A)
Intuitively,Property(A)abovechecksthat ğœ“issatisfiedwhenever
controller ğ¶ğµis invoked directly after ğ¶ğ´in any trace.
âˆ€ğ¶ğ‘‹âˆ‰notBetween
âˆ€ğ‘‘1,ğ‘‘2,ğ‘‘3,ğ‘–ğ´,ğ‘œğ´,ğ‘–ğµ,ğ‘œğµ,ğ‘‘ğ‘‹,ğ‘–ğ‘‹,ğ‘œğ‘‹,ğ‘–4,ğ‘œ4
â¡â¢â¢â¢â¢â¢â¢â¢â¢â¢â£/parenleftBig
ğ¶
ğµ(ğ‘‘1,ğ‘‘2,ğ‘–ğµ,ğ‘œğµ)â‡’ ğœ“(ğ‘–ğ´,ğ‘œğ´,ğ‘–ğµ,ğ‘œğµ)/parenrightBig
=â‡’
â§âªâª â¨
âªâªâ©ğ¶ğ‘‹(ğ‘‘1,ğ‘‘ğ‘‹,ğ‘–ğ‘‹,ğ‘œğ‘‹)
âˆ§
ğ¶ğµ(ğ‘‘ğ‘‹,ğ‘‘3,ğ‘–4,ğ‘œ4)â«âªâª â¬
âªâªâ­â‡’ğœ“(ğ‘–ğ´,ğ‘œğ´,ğ‘–4,ğ‘œ4)â¤â¥â¥â¥â¥â¥â¥â¥â¥â¥â¦(I)
Property (I) is actually a template for a setof properties, one for
everyğ¶ğ‘‹âˆ‰notBetween .Thepropertyabovebasicallychecksthatif
2346
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Geetam Chawla, Navneet Aman, Raghavan Komondoor, Ashish Bokil, and Nilesh Kharat
a trace ends at ğ¶ğµand the trace satisfies ğœ“, then upon inserting an
invocation to ğ¶ğ‘‹just before ğ¶ğµthe resultant trace also satisfies ğœ“.
Thatis,aninvocationto ğ¶ğ‘‹doesnotinterferewiththesatisfaction
of the property.
Intuitively, the approach solves our problem in a sound manner
forthefollowingreason.Property(A)aboveisthebasecase,and
discharges correctness for traces that donâ€™t visit any controller
betweenğ¶ğ´andğ¶ğµ.Property(I)istheinductivecase,andbasically
implies that any sequence of visits to controllers that are not in
notBetween canbeinsertedbetween ğ¶ğ´andğ¶ğµwithoutinterfering
with the property. A detailed proof of soundness is included in a
supplementary document other-details.pdf [7] associated with this
paper.
3.1.1 Illustration. Ifğ¶ğ‘…denotes the controller processCreation-
Form and ğ¶ğ¹denotes processFindForm, then the inferred sum-
maries would be as follows:
ğ¶ğ‘…(owRepo, owRepoâ€™,( id, lastName, firstName, city ), _)â‰¡
owRepoâ€™=save(owRepo,( id, lastName, firstName, city ))
ğ¶ğ¹(owRepo, owRepo, lastNameX, ret ))â‰¡
ret=ğœlastNameX =owRepo.lastName(owRepo)
Note, we use owRepoâ€™to refer to the outgoing state of this repos-
itoryinordertotreatthesummaryasaformularatherthanasa
mapping.
The trace property given by the developer could be:
ğœ“((id, lastName, firstName, city ), _,lastNameX, ret )â‰¡
(lastName =lastNameX )â‡’
(id, firstName, lastName, city )âˆˆret
Thedevelopermayindicate notBetween tocontainallcontrollers
that they believe do not delete or update any â€˜Ownerâ€™ entity in the
persistent state.
3.2 Capabilities and limitations
To our knowledge, our proposal above is the first one to use an
efficient, inductive approach to check properties of alltraces in
a web application without bounding the lengths of traces. The
number of properties checked by the approach using calls to the
solver is linear in the number of controllers in the application.
Our approach is sound if the individual controller summaries
aresound;i.e.,theapproachwillnotdeclareapropertythatdoes
notholdasholding.Theapproachcansufferfromfalsepositives.
The fundamental cause is that the approach ignores the effects due
to views, which can restrict the order in which controllers may
beinvoked,andcanalsorestrictwhatdataflowsinasarguments
to a controller. Currently, the given property ğœ“can refer to two
controllers ğ¶ğ´andğ¶ğµ. An extension to more than two controllers
(but a fixed number of them) is conceptually straightforward, and
provided in our supplementary document other-details.pdf [7].
4 IMPLEMENTATION
We have implemented our controller summarization approach (de-
scribedin Section2) asa prototypetool called ORMInfer.The tool
isimplementedusingtheSootbytecodeanalysisframework[ 26].
Our summary-construction code is based on the DBridge [ 5]c od e ,
with many additional features added (which are summarized in
Section 6). The default flattening length bound in our tool (see
Section2.1)isthree(i.e.,threeunderscores).Wehaveidentifiedasubset of commonly used library functions, and translated themdirectly into relational algebra during summary inference. Anyother library calls, if encountered, are treated, in the interest of
efficiency, as if they return arbitrary values.
One of the major new components in our implementation over
DBridge is the one that accepts pattern-based rewrite rules, and
applies them during analysis time. Our tool provides a simple cus-
tom DSL (domain specific language) for specifying these rewrite
rules. For instance, for a simplified version of the rewrite rule in
Figure6(A),thecorrespondingruleintheDSLwouldbeasfollows:
(loop (bodyexpr (? <cond> (save <lvar> <tuple1>)
(save <lvar> <tuple2>))) <lvar> <coll> <itr>)
(union (- <lvar> <coll>)
(union (pi (select <coll> <cond>) <tuple1>)
(pi (select <coll> (= <cond> 0)) <tuple2>)))
The DSL uses a Lisp-like prefix notation, with keywords/operators
preceding operands. The first two lines above encode the LHS;
actually,thesoleoperandof bodyexpr keywordrepresentstheLHS
pattern.Thethreenamestowardstheendofthe loopconstructare
thenamesofthespecialmetavariablesintroducedinSection2.3
(these meta variable names are not fixed, and can be chosen by the
patternspecifier).ThelastthreelinesaboverepresenttheRHSof
thepattern.Weincludefivespecificrewriteruleswiththetool,and
more can be added by users. We providethese five patterns in the
supplementary document other-details.pdf [7].
We currently use Alloy [ 18] as our backend tool for checking
properties. To this end, we have implemented a postpass that takesarelationalalgebrasummaryofacontroller(inmemory)andtrans-latesitintoanAlloymodel.SinceAlloyitselfisbasedonrelational
algebra, the translation is defined quite naturally. Every variable
in the domain of a controllerâ€™s summary (i.e., updated repositories,
assigned model attributes) becomes a â€œsigâ€ in the Alloy model, andthe model contains facts that are translations of the relational alge-
bra expressions that the variables are mapped to. Assertions can
subsequently be added to the Alloy model by users. The assertions
can refer to the â€œsigâ€s mentioned above, and can be checked by the
Alloytool.Currently,weabstractawayanyscalararithmeticthat
maybepresentinthesummaryandreplacethesesubexpressions
with unconstrained values.
Wehavealsoimplementedthetrace-propertycheckerdescribed
inSection3asatool MultiORM.Thistoolusestherelationalalgebra
summariesinferredbyORMInferfortheindividualcontrollersto
emittheProperty(A)andasetofProperty(I)â€™sinAlloyformfor
each given trace property.
5 EMPIRICAL EVALUATION
This section describes the initial empirical evaluations we have
performedusingourprototypetoolstoevaluatetheirusefulness,
precision, and efficiency.
5.1 Benchmarks and Properties
We selected six open-source benchmarks for our evaluations. Key
statistics about the benchmarks are summarized in Table 1. Ourkey criteria for choosing a benchmark were that it should use
SpringORMfeaturesfordataaccess,andshouldnotusethird-party
libraries or frameworks extensively. Many of the benchmarks in
2347
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Verification of ORM-based Controllers by Summary Inference ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Benchmark Cont-Ent-JavaGithubURL
rollersitiesLOCStars
PetClinic 17627624955[14]
Spring Boot Blog 1441204 131[12]
Employee Directory 51375 0[10]
Imagine 2243538 17[11]
Spring Coffee Shop 63372 7[13]
Bookstore 24122892 0[9]
Table 1: Benchmark statistics
ourlistwerecreatedbytheSpringcommunitytoillustratetheideal
usage of Spring features to build realistic applications.
Our next step was to obtain a set of properties for evaluation.
Since the benchmarks come with almost no assertions in the code,
we approached volunteers we knew and asked them to understand
the benchmarks and provide us properties (or specifications) for us
to check. These volunteers were either PhD students or post-docs,
wereexperiencedinprogramming,andhadgoodfamiliaritywith
notions such as property checking, first-order logic, relational alge-
bra, etc. However, they were unfamiliar with our work and with
the abilities of our approach. There were a total of four volunteers.
We requested each volunteer to supply properties for three bench-
marks,soeachbenchmarkhadpropertiesfromtwovolunteers.We
asked each volunteer to give us single-controller properties, e.g.,
similartoProperty(1)inSection1.1,aswellas traceproperties,e.g.,
similar to the â€˜ ğœ“â€™ in Section 3.1.1, for all their benchmarks.
In order to make the work of the volunteers easier, we gave
them various resources, such as: (i) database schemas, to enable
them to write single-controller properties, (ii) hosted instancesof the applications, to enable them to use the applications andcome to understand them well, and (iii) a few sample properties
(of both types). The volunteers did not look at the source codes
of the benchmarks. An important guideline given to them was
towritepropertiesbasedon expectedbehaviorfromtheend-user
perspective, even if any bugs in the applications resulted in non-
expected behavior.
We asked the volunteers to give us each property in English
wording.Wedecidedthataskingthemtoformallystatetheproper-
tiesmightprovetooburdensomeandmightdisincentivizethem.Intheremainderofthissectionwepresenttheresultsfromourevalu-
ations. We have made available a virtual machine image [ 7] that
contains our tools, scripts to run them, as well as inputs necessary
to reproduce all results given in this section.
5.2 Performance on single-controller
properties
We first went through the given single-controller properties to
translate them manually to Alloy assertions using our best judg-
ment. We had to â€œrejectâ€ 14 of the given properties â€“ four because
they were too vague, five because they were trivially implied bytheconstraintsoftheschema,andtheremainingfiveforone-offreasons that would need more space to explain. We also ignored
â€œrepeatâ€ properties â€“ i.e., essentially duplicates of properties pro-
vided by other volunteers. What remained were 59 properties. WeCategory SingleTrace
True Neg. 4428
True Pos. 27
False Pos. 17
Unexpressed 12 4
TOTAL: 5946
Table 2: Usefulness and precision results
inferredsummariesinAlloyformforthecontrollerstowhichthese
properties pertained using ORMInfer, and then used the Alloy tool
tocheckifthesummariesimpliedtheproperties.Theresultsare
summarized in the â€œSingleâ€ column of Table 2.
Anegativemeansthepropertywasfoundtopassbythetool(i.e.,
the Alloy assertion did not fail), while a positiveis the converse.
Truemeans the toolâ€™s decision agrees with our understanding of
theapplicationâ€™sbehavior,whilea Falsemeanstheconverse.â€œUnex-
pressedâ€ means that although the summary (and its corresponding
Alloy model) were generated by the tool, the summary did not
containcertainelementsthatarenecessarytotranslatetheprop-
ertyintoanAlloyassertion.Note,wedidnotnoticeanycasesof
unsoundness, and hence there is no row titled â€œFalse Negativeâ€.
Overall, the performance of our approach is very good. 46/59
properties (78%) are in the Truecategories. Note that 44/59 proper-
ties hold. Two properties (which were on the same controller) actu-allydidnothold:thevolunteerexpectedthiscontroller,whichsaved
a given â€˜Employeeâ€™ entity into a database, to check for uniqueness
of the given email ID and non-emptyness of other fields. However,
it was not doing these checks.
Therewasonlyonefalsepositive.Itwasduetoconstraintson
incoming arguments imposed by preceding views, which were not
encoded in the summaries. 7/12 of the â€œunexpressedâ€ assertions
were not expressible because the summary had no information on
collection-typedfieldswhichwerethemselvesinsidecollections;
asdiscussedinSection2.4,oneneedsnestedrelationalalgebrato
representsuchsummaries.Theremaining5unexpressedproperties
were due to other one-off reasons that cannot be explained due to
space constraints.
Ourapproachturnsouttobeveryefficient.Onfourofthesix
benchmarks, the maximum analysis time per controller, including
summaryinferencetime andassertioncheckingtimeusing Alloy,
was 3 seconds. With â€˜Bookstoreâ€™ the maximum was 10 seconds and
average was 3 seconds, while with â€˜Imagineâ€™ the maximum time
was 104 seconds and average was 17 seconds. In our all runs of the
Alloy tool we used a universeof 20 elements.
5.3 Performance on trace properties
Wefollowedasimilarprocessasabove,beginningwithamanual
translation of the given English-language properties into Alloy as-
sertions. In this case, we had to â€œrejectâ€ 17 of the given properties.
The prevalent reason (accounting for 12/17 properties) was that
the property was referring to three different controllers that thetracehadtogothrough.Thecurrentlimitofourtoolistwocon-
trollers(seeSection3.2),althoughinprincipleitisnotdifficultto
extendourtooltoprocess3-controllerproperties.Afterignoring
â€œrepeatâ€ properties as well, there remained 46 properties that we
2348
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Geetam Chawla, Navneet Aman, Raghavan Komondoor, Ashish Bokil, and Nilesh Kharat
handled using our tool. We used our MultiORM tool to generate
AlloyfactsandassertionscorrespondingtotheProperty(A)and
the set of Property (I)â€™s for each given trace property, and checked
all these generated assertions using the Alloy tool. The results are
summarized in the â€œTraceâ€ column of Table 2.
Overall, the performance of our approach is very good. 35/46
properties (76%) are in the Truecategories. Seven of the properties
failed as per the tool, and truly did not hold in our opinion. Our
manual analysis revealed that all these were actually due to the
resultofoversightormisunderstandingbythevolunteers.Apreva-
lent reason was volunteers not putting all the controllersthat can
indeed be expected to affect the return value from ğ¶ğµin the set
notBetween.Notethatifahumansubjectexpectsapropertytohold
and it actually does not hold and the tool reports it as not hold-
ing,thenitreallyisa truepositive irrespectiveofthefactthatthe
subjectâ€™sexpectationwasduetoalimitationintheirunderstanding.
There are relatively larger number of false positives (7/46) in
this part of our evaluation. The reasons are varied, and hard topresent in detail. Imprecise handling of certain complex Springidioms and library calls account for many of these cases. Two of
the â€œUnexpressedâ€ cases were because a field of a result entity was
notpresentinthesummaryduetoitsdependenceonarithmetic,
while two were due to the need for nested relational algebra.
TheaveragetimespentbyAlloytocheckatracepropertywas5
seconds, while the maximum was 54 seconds.
5.4 Ability to find bugs
In this part of our study we wish to answer a natural question,namely, whether a reasonably large set of assertions if written
apriori would be useful in detecting bugs, including bugs that may
get introduced in the future. Since our benchmarks did not possess
many bugs at all, we decided to seed mutations in our benchmarks.
Thisisacommonpracticebyresearcherswhowishtoevaluatebug-
detection approaches. For this, we used the automated production-
quality tool PIT (https://pitest.org).
Since this study involved some time-consuming effort, we fo-
cused our attention on two benchmarks, namely, PetClinic and
Bookstore. From our single-controller study (Section 5.2), we iden-
tified all 16 passing (i.e., True Negative ) assertions, and applied PIT
on the controllers tested by these assertions as well as their callees.
PIT suggested a total of 33 separate mutations. We applied thesemutations one by one in the benchmark codes, and ran our toolseparately on each mutated version of the benchmark. 6 of the
mutationscouldnotbehandledbyourtool,becausethereiscur-
rrentlyalimitationinthetoolthatpreventsitfromanalyzingcallee
methods that contain an explicit â€œreturn nullâ€ statement (these
statementsgotintroducedduetothemutations).Ofthe27mutated
versionsthatwereanalyzedbyourtool,15causedatleastoneof
the provided assertions to fail (i.e., 15 were â€œkilledâ€).
Ourtakeawayisthatasetofgeneral-purposeassertionswritten
aprioriwithoutanyregardtoanyspecificbugsstillhasthepotential
to find a significant proportion of bugs that could be introduced in
the future (based on the 56% kill rate in the evaluation above).5.5 Comparison with a baseline
Finally, we wished to comparatively evaluate our approach with a
baselinetool.Therearenocomparablecontrollersummarization
tools for Java that we are aware of. The closest matching family of
toolsissymbolicexecution tools,astheycanautomaticallycheck
assertions. We decided to use the widely-used tool Java Pathfinder
(JPF), https://github.com/javapathfinder. JPF is not directly meant
to test Spring controllers, so we made some manual changes tothe benchmarks to make them amenable to analysis by JPF. Themain changes were to initialize the database tables with tuples
that contained symbolic values in order to enhance the coverage of
JPF,tocalleachcontrollerlikeanormalmethod,andtowritethe
assertions in Java.
Sincethisstudyalsoneededsignificantmanualeffort,wedecided
tofocusonlyonthe16assertionsmentionedinSection5.4above.
JPFalsofoundall16oftheseassertionstopass.Ittook7seconds
for one of the assertions, and around 1 second each for the rest. As
JPF explores execution traces in-depth, we expect it to also declare
as passing most of our false-positive assertions.
In other words, JPF is efficient and effective at checking asser-
tions, provided one puts in the manual work as discussed above.
However,theutilityofourapproachisnotjustincheckingasser-
tions,butinproducinggeneral-purposesummariesofcontrollers
that are amenable to various different downstream analyses. For
instance,thetrace-checkingapplicationwaseasilyenabledusing
oursummaries.WithJPF,onlyafinitenumberoftraces,ofbounded
lengths, can be checked.
5.6 Manual intervention during
experimentation
It is to be noted that in the studies reported above involving our
tool,wemanuallyaddedsome facts(i.e.,constraints)totheAlloy
models of some of the controllers to improve precision. The con-
straintswereonincomingargumentstothecontrollers,andwere
meant to either encode knowledge about these arguments derived
from preceding views or controllers, or prune out paths within
the controller that throw exceptions on ill-formed arguments, etc.
Eighteen of the 44 true negative properties in the single-controller
experimentsandnineofthe28truenegativepropertiesinthetracepropertyexperimentsneededsuchmanuallyaddedconstraints.We
believe that in real usage, developers would be willing to add such
constraints in order to get maximum benefit from the tool.
A limitation of our currently implemented Alloy generation
postpass is that â€œsigâ€s and fields are emitted only for those parts of
the database schema that are actually referred to in the controller.
However,assertionssometimesneedtorefertoschemaelements
that are not referred to in the controller. This limitation can be
removed from the tool in the future, but for now we manually add
such required information from the schema into the Alloy models
on demand.
Finally,forthetrace-checkingstudy(Section5.3)alone,wemod-
ifiedthebenchmarkstosimplifytwospecificidiomsthatcanob-
structtheprecisionofouranalysis:Replacedsubstringmatching
usingâ€œLIKEâ€withequalityinembeddedSQLwhereveritispresent,
and replaced calls to Springthat return the currently logged in
username with a constant username.
2349
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Verification of ORM-based Controllers by Summary Inference ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
6 RELATED WORK
TheclosestrelatedworktoourworkisthatbyBociÄ‡andBultan[ 2].
Theirapproachactuallyinfersaverificationconditionforchecking
a property for a controller, but it can be seen as inferring a sum-
mary as well. Their summary is represented in FOL (First Order
Logic).TheyuseFOLwithoutscalarsorarithmetic,soarithmetic
operations are abstracted away, as are allconditionals. This results
inimprecision.Ourcoresummaryinferenceapproach(described
inSection2)isbasedonrelationalalgebra,andpreciselyrepresentsscalars, arithmetic, conditionals, as well as aggregations over loops.OurcurrenttranslationofthesummariestoAlloydoesresultinab-stractingawayofarithmetic,butnon-arithmeticbasedconditionals
(suchastheoneintherunningexampleinFigure1)areretained,
and such conditionals did play a major role in enhancing precision
as per our evaluations.
The technique employed by their approach to summarize loops
is fully automated, and does not use patterns. However, their ap-
proachisefficientandterminatesinpracticeonlywhenthereare
noloop-carrieddataflows[ 3].Withpatternswedonothavethis
restriction,andweareabletosummarizepreciselyloopswithloop-
carried flows, e.g., ones that add up values from a collection. Also,
ourapproachemitsitssummariesinAlloy,whichisbothhuman
readable and amenable to a variety of downstream analysis-basedapplications.
It was not possible to directly apply their tool on our bench-
marks, as their work targets Ruby on Rails applications. They have
reportedintheirpaperasignificantlylowerrateoffalsepositives
and â€œunexpressedâ€ properties than we do. However, it appears that
theirpropertieswerewrittenbytheauthorsthemselves,whereas
ourpropertieswereprovidedbyvolunteerswhowerenotinvolved
in our work. We studied the ten loops that occur across our six
benchmarks,andfoundthatourapproachinfersprecisesummariesforsixofthem.Whereas,uponaconceptualandmanualapplication
oftheirapproachonourtenloops,wefoundthattheirapproach
would be able to infer a precise summary for only one of the ten
loops.
ThereexistsarichbodyofworkoninferringSQLfromimper-
ativecodefragmentsusingprogramanalysis,primarilyfocusingon loops that read from databases [
4,5,15,17,28]. The objective
of these works is generally to optimize loops by replacing them
withSQL,whichcanbeoptimizedbyqueryoptimizers.Theclosest
work from this body to our work is DBridge [ 5]. Their approach
performs bottom-up summarization of ASTs, and this aspect of
our implementation is in fact borrowed from their implementation.
They address a fixed set of looping idioms in code. We have gener-
alized this aspect of their work into a generic rewrite system for
loopsbasedondeveloperspecifiedpatterns.Theuseofflatteningto
address heap references is new in our approach, as is the handling
of various Spring-specific features. On the ten loops that we hadreferred to earlier in this section, DBridge is able to infer precise
SQL for just two of them.
A key difference between the approaches mentioned above and
ours is our focus on representing allthe effects of a controller,
including database updates and model attributes returned, into
the summary, andthen usingthe summaryfor property-checkingpurposes. A couple of recent approaches [ 19,23] perform black-
boxanalysisofaqueryingcodeorquerytoinferequivalentSQL,
with the objective of program understanding, reconstruction, or
migration.
Logical methods have been used by researchers to reason about
database accessing applications. The work of Itzhaky et al. [ 16]
focuses on computing weakest preconditions in a simple loop-free
scripting language that allows embedded SQL. The work of Wang
etal.[27]isaboutprovingequivalenceoftwodatabase-accessing
programs written in an intermediate language.
A number of papers propose techniques for automated test-
case generation or symbolic execution to find bugs in database-accessing applications [
6,20,22,25]. These approaches do not
produce summaries of code, but rather explore paths in the code inanattempttofindbugs.TheworkofAthaiyaetal.[
1]isorthogonal
toours,inthatitfocusesoninferringsummariesofviewsrather
than controllers.
7 CONCLUSIONS AND FUTURE WORK
Wepresentedinthispaperanovel,pattern-basedapproachforsum-
marization of ORM controllers. We explored in-depth applications
oftheinferredsummariestopropertycheckingforcontrollers.Our
implementation of our approach was very efficient, and showed
promising precision, with around 78% of the properties processed
with correct results. We not only checked properties of individual
controllersusingoursummaries,butalsoshowedanapplication
or extension of these summaries to check all possible traces in the
application to see if they satisfy a specific kind of trace property.
Our work opens up several ideas for future work. We could
expandthesetofcontrollersthatgetsummarizedpreciselybyin-
corporatingnestedrelationalalgebra,andbyincorporatingfeatures
such as â€œgroup byâ€ and â€œhavingâ€. Constraints on incoming argu-ments to controllers could be inferred from preceding views and
precedingcontrollers. Checkingsoundness(i.e.,semantics preser-
vation) of a given rewrite rule could be a very interesting problem.
We could potentially make use of points-to analysis in order to
eliminatethepotentialforunsoundnessinthecurrentflattening
approach in the presence of aliasing. Finally, we suggest that other
applicationsoftheinferredsummariesbeexplored,suchasauto-
mated comparison or merging of different versions of the same
controllerâ€™s code, automated test input generation, etc.
ACKNOWLEDGMENTS
This work was made possible by generous research sponsorship
from TCS Limited, by scholarships from the Ministry of Education,
Govt.ofIndia,andbyfinancialsupportfromIBMResearchIndia.
WethankAlvinGeorge,HabeebP,RekhaPai,andStanlySamuel,
for providing the properties for our evaluations.
REFERENCES
[1]SnigdhaAthaiyaandRaghavanKomondoor.2017. Testingandanalysisofweb
applications using page models. In Proceedings of the 26th ACM SIGSOFT Interna-
tional Symposium on Software Testing and Analysis. 181â€“191.
[2]IvanBociÄ‡andTevfikBultan.2014. Inductiveverificationofdatamodelinvari-
antsforwebapplications.In Proceedingsofthe36thInternationalConferenceon
Software Engineering. 620â€“631.
[3]Ivan BociÄ‡ and Tevfik Bultan. 2015. Coexecutability for efficient verification
ofdatamodelupdates.In 2015IEEE/ACM37thIEEEInternationalConferenceon
2350
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Geetam Chawla, Navneet Aman, Raghavan Komondoor, Ashish Bokil, and Nilesh Kharat
Software Engineering, Vol. 1. IEEE, 744â€“754.
[4]AlvinCheung,ArmandoSolar-Lezama,andSamuelMadden.2013. Optimizing
database-backed applications with query synthesis. ACM SIGPLAN Notices 48, 6
(2013), 3â€“14.
[5]K Venkatesh Emani, Karthik Ramachandra, Subhro Bhattacharya, and S Su-
darshan. 2016. Extracting equivalent SQL from imperative code in database
applications. In Proceedings of the 2016 International Conference on Management
of Data. 1781â€“1796.
[6]Michael Emmi, Rupak Majumdar, and Koushik Sen. 2007. Dynamic test inputgeneration for database applications. In Proceedings of the 2007 International
Symposium on Software Testing and Analysis. 151â€“162.
[7]Chawlaetal.2022. Supplementarymaterials. https://doi.org/10.6084/m9.figshare.
19087814
[8]Roy T Fielding and Richard N Taylor. 2002. Principled design of the modern
web architecture. ACM Transactions on Internet Technology (TOIT) 2, 2 (2002),
115â€“150.
[9] Github. 2022. Bookstore. https://github.com/justBrokkoly/bookstore.git
[10]Github. 2022. Employee. https://github.com/kiticgoran90/crud-employee-
thymeleaf/
[11] Github. 2022. Imagine. https://github.com/yyqian/imagine.git[12]
Github. 2022. Spring Boot Blog. https://github.com/reljicd/spring-boot-blog.git
[13]Github. 2022. Spring Coffee Shop. https://github.com/shakeelosmani/
springcoffeeshop
[14]Github. 2022. Spring Petclinic. https://github.com/spring-projects/spring-
petclinic
[15]Surabhi Gupta, Sanket Purandare, and Karthik Ramachandra. 2020. Aggify:
LiftingtheCurseofCursorLoopsusingCustomAggregates.In Proceedingsofthe
2020 ACM SIGMOD International Conference on Management of Data. 559â€“573.
[16]Shachar Itzhaky, Tomer Kotek, Noam Rinetzky, Mooly Sagiv, Orr Tamir, Helmut
Veith, and Florian Zuleger. 2017. On the Automated Verification of Web Applica-
tionswithEmbeddedSQL.In 20thInternationalConferenceonDatabaseTheory,
ICDT. 16:1â€“16:18.[17]Ming-YeeIu,EmmanuelCecchet,andWillyZwaenepoel.2010. JReq:Database
queries in imperative languages. In International Conference on Compiler Con-
struction. Springer, 84â€“103.
[18]DanielJackson.2019. Alloy:ALanguageandToolforExploringSoftwareDesigns.
Commun. ACM 62, 9 (Aug. 2019), 66â€“76. https://doi.org/10.1145/3338843
[19]KapilKhuranaandJayantRHaritsa.2021. SheddingLightonOpaqueApplication
Queries. In Proceedings of the 2021 International Conference on Management of
Data. 912â€“924.
[20]JosephPNearandDanielJackson.2012. Rubicon:boundedverificationofweb
applications.In ProceedingsoftheACMSIGSOFT20thInternationalSymposium
on the Foundations of Software Engineering. 1â€“11.
[21]StackOverflow.2020. StackOverflowDeveloperSurvey2020. https://insights.
stackoverflow.com/survey/2020#technology-web-frameworks
[22]Filippo Ricca and Paolo Tonella. 2001. Analysis and testing of web applications.
InProceedings of the 23rd International Conference on Software Engineering. ICSE
2001. IEEE, 25â€“34.
[23]JiasiShenandMartinCRinard.2019. Usingactivelearningtosynthesizemodels
ofapplicationsthataccessdatabases.In Proceedingsofthe40thACMSIGPLAN
Conference on Programming Language Design and Implementation. 269â€“285.
[24]Pivotal Software. 2022. Spring Framework. https://spring.io/projects/spring-
framework
[25]Suresh Thummalapenta, K Vasanta Lakshmi, Saurabh Sinha, Nishant Sinha, and
Satish Chandra.2013. Guidedtest generationfor webapplications.In 2013 35th
InternationalConference on Software Engineering (ICSE) . IEEE, 162â€“171.
[26]RajaVallÃ©e-Rai,PhongCo, EtienneGagnon,Laurie Hendren,PatrickLam, and
Vijay Sundaresan. 2010. Soot: A Java bytecode optimization framework. In
CASCON First Decade High Impact Papers. 214â€“224.
[27]YuepengWang,IsilDillig,ShuvenduKLahiri,andWilliamRCook.2017. Veri-
fying equivalence of database-driven applications. Proceedings of the ACM on
Programming Languages 2, POPL (2017), 1â€“29.
[28]BenWiedermann,AliIbrahim,andWilliamRCook.2008. Interproceduralqueryextractionfortransparentpersistence. ACMSigplanNotices 43,10(2008),19â€“36.
2351
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. 