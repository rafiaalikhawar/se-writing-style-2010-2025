1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
5859
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116Static Executes-Before Analysis for Event Driven Programs
Rekha Pai
Indian Institute of Science
Bengaluru, Karnataka, India
rekhapai@iisc.ac.inAbhishek Uppar
Indian Institute of Science
Bengaluru, Karnataka, India
abhisheku@iisc.ac.inAkshatha Shenoy
akshathabshenoy@gmail.com
TCS Research
Pune, India
Pranshul Kushwaha
Indian Institute of Science
Bengaluru, India
pranshulk@iisc.ac.inDeepak D’Souza
Indian Institute of Science
Bengaluru, India
deepakd@iisc.ac.in
ABSTRACT
Theexecutes-before relation between tasks is fundamental in
the analysis of Event Driven Programs with several down-
stream applications like race detection and identifying re-
dundant synchronizations. We present a sound, efficient, and
effective static analysis technique to compute executes-before
pairs of tasks for a general class of event driven programs.
The analysis is based on a small but comprehensive set of
rules evaluated on a novel structure called the task post graph
of a program. We show how to use the executes-before infor-
mation to identify disjoint-blocks in event driven programs
and further use them to improve the precision of data race
detection for these programs. We have implemented our anal-
ysis in the Flowdroid framework in a tool called AndRacer
and evaluated it on several Android apps, bringing out the
scalability, recall, and improved precision of the analyses.
CCS CONCEPTS
Software and its engineering →Automated static
analysis .
KEYWORDS
static analysis, executes-before, event driven programming,
race detection, asynchronous calls, Android applications.
ACM Reference Format:
Rekha Pai, Abhishek Uppar, Akshatha Shenoy, Pranshul Kush-
waha, and Deepak D’Souza. 2022. Static Executes-Before Analysis
for Event Driven Programs. In Proceedings of The 30th ACM
Joint European Software Engineering Conference and Symposium
on the Foundations of Software Engineering (ESEC/FSE 2022).
ACM, New York, NY, USA, 14 pages. https://doi.org/10.1145/
nnnnnnn.nnnnnnn
Permission to make digital or hard copies of all or part of this work
for personal or classroom use is granted without fee provided that
copies are not made or distributed for profit or commercial advantage
and that copies bear this notice and the full citation on the first
page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy
otherwise, or republish, to post on servers or to redistribute to lists,
requires prior specific permission and/or a fee. Request permissions
from permissions@acm.org.
ESEC/FSE 2022, 14–18 November, 2022, Singapore
©2022 Association for Computing Machinery.
ACM ISBN 978-x-xxxx-xxxx-x/YY/MM. . . $15.00
https://doi.org/10.1145/nnnnnnn.nnnnnnn1 INTRODUCTION
The Event-Driven Programming (EDP) model has become
a popular contemporary paradigm, widely used in the de-
velopment of mobile apps, distributed systems, graphical
user interfaces, and web applications, among others. These
programs are multi-threaded in which each thread has asso-
ciated with it a queue of program units called “tasks” that
are “posted” to it by other threads, and that it executes
sequentially in a FIFO manner. The posting of tasks is typ-
ically triggered by “events” like button clicks, completion
of background tasks, etc. While EDP is an efficient para-
digm, control flow in these programs can be complex and
non-standard, and pose a challenge to the developer to guard
against common concurrency issues like data races and atom-
icity violations. The non-standard concurrency model also
makes it challenging to carry out static analysis in a sound,
precise, and efficient manner.
A key notion that has proved useful in analyzing EDP
programs is the “executes-before” relation on the tasks of
a program. A task aexecutes-before another task bin an
EDP program Pif in every execution of P, every instance
ofacompletes execution before any instance of bbegins its
execution. Versions of the executes-before relation (derived
from a static happens-before relation on a partial unrolling
of the program in [ 8,15,18]) have been used to detect event-
races (where two conflicting accesses may not be ordered)
and use-after-free races. Another use of the executes-before
relation, which we show in this paper, is in a “disjoint block”
analysis (also known as a not May-Happen-in-Parallel or “not
MHP” analysis) for EDP programs. Disjoint blocks are blocks
of code in two tasks which are guaranteed never to overlap (or
Happen-in-Parallel) in any execution of the program, much
like blocks of code protected by the same lock. Disjoint block
information is fundamental for data race detection [ 3,5,17],
high-level race detection for atomicity violations [ 16], and
for identifying redundant synchronizations. A final promising
use of the executes-before relation is in carrying out efficient
data-flow analysis for EDP programs. One can imagine using
executes-before information to construct a combined control-
flow graph of the program and analyze it using techniques
like [3, 4, 7].
It is important for any analysis that computes the executes-
before relation to be sound (in that it never reports that
1117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174ESEC/FSE 2022, 14–18 November, 2022, Singapore R. Pai et al.
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232taskaexecutes-before task bunless aactually does execute
before b), particularly when one is interested in race-detection
for safety-critical applications, or eliminating redundant syn-
chronizations, or data-flow analysis. Unforunately none of
the existing techniques we are aware of are sound. In par-
ticular the works in [ 8,15,18] consider a finite unrolling of
the program wherein a task may have multiple copies corre-
sponding to different contexts (which task/thread they were
posted by, etc), and compute a happens-before ordering on
the start/end/invoke nodes in these copies using standard
causal rules. They then derive an executes-before relation on
tasks by declaring ato execute-before bif the end nodes of
all copies of ahappen-before the start nodes of all copies of
b. However, as we illustrate later, this is easily seen to be
unsound for EDP programs in general.
In this paper we propose a sound, efficient, and fairly
precise way of identifying executes-before pairs in an EDP
program. We give a small set of conditions and inference rules
that can be statically checked on a structure called a “task
post graph” induced by the program, which are sufficient to
guarantee that one task executes before another. We have
implemented and evaluated the analysis on several Android
apps, and observed that it has good recall of manually iden-
tified executes-before pairs in these apps. In fact we compare
favourably with ERCatcher [ 15], one of the state-of-the-art
event-race detection tools, in terms of recall of EB pairs
retrieved, on their specially created set of microbenchmarks
[14].
In a couple of applications downstream, we show how
to use the executes-before information (in addition to lock
information) to identify pairs of disjoint-blocks in EDP pro-
grams, and apply this to statically detect data races and
check for redundant synchronizations in Android apps. We
show the value of the executes-before-based disjoint-block
rules by observing that they are solely responsible for 57%
of the conflicting accesses eliminated, which techniques like
[9] would miss.
2 OVERVIEW
In this section we illustrate the main ideas of the paper with
an example event-driven program in the form of an Android
app adapted from [ 18], shown in Fig. 1. The figure shows
an Android activity ,MyActivity , that has a field pand four
tasks (or program units) onCreate ,a,b, and c. When the
application begins execution, the Android runtime creates
themain thread with a FIFO queue attached to it. It then
posts (or enqueues) the task onCreate (which is an Android
lifecycle callback) to the main thread. The main thread
begins by dequeing the only task in its queue, onCreate ,
and executing it. Tasks in an app can post other tasks onto
threads using handlers. The onCreate task creates a handler
formain (line 20) using which it posts tasks aand b, in
that order, onto the main thread’s queue (lines 21–22). The
main thread upon completion of onCreate proceeds with
dequeing and executing task awhich initializes the value of p
(line 4). The main thread then dequeues and executes task b.1. class MyActivity extends Activity {
2. long p;
3. Runnable a = new Runnable () {
4. public void run () {p = 0L;}
5. }
6. Runnable b = new Runnable () {
7. public void run () {
8. long y = p;
9. HandlerThread child = new HandlerThread ();
10. child . start ();
11. Handler hb = new Handler ( child . getLooper ());
12. hb. post (c);
13. long z = p;
14. }
15. }
16. Runnable c = new Runnable () {
17. public void run () {p = 10;}
18. }
19. public void onCreate () {
20. Handler handler = new Handler ();
21. handler . post (a);
22. handler . post (b);
23. }
24. }
on−
C1
C2C2
C1C1
(ii)Create Createon−
(i)
a b
childmain
mainmain
ca b
cmain
childmainmain
Figure 1: (Top) An example Android app, (i) its
TPG, and (ii) its TPG with the EB relation super-
imposed.
This task creates a child thread with a handler (lines 9–11),
and posts task cto it (line 12). The child thread dequeues
and executes task c, which writes to variable p(line 17).
We say that a task x“executes-before” a task yin an
EDP program Pif whenever we have an execution of Pwith
instances of tasks xandy, every instance of xmust complete
before any instance of ybegins execution. In this sense, in
the given program we can see that onCreate executes-before
both aand b. This is because firstly each task has a single
instance. Secondly, onCreate must execute for aandbto be
posted, and since they are posted to the same thread main ,
tasks aandbmust wait for onCreate to finish executing. We
further observe that aexecutes before bsince it is posted by
onCreate tomain before bis. Finally, both onCreate and
amust execute before c(even though they are posted to
different threads) since both onCreate and aexecute before
bwhich posts c. The five executes-before pairs are thus
(onCreate ,a),(onCreate ,b),(onCreate ,c),(a,b),and ( a,c).
We now describe how we statically identify such executes-
before pairs. We propose a small set of conditions ((C1), (C2)
2233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290Executes Before Analysis ESEC/FSE 2022, 14–18 November, 2022, Singapore
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348and (C3) described in Sec. 5), each of which allows us to
conclude that a task executes-before another. The conditions
are phrased on a structure we call a Task Post Graph (TPG),
which has the set of tasks as its nodes and an edge from node
xtoylabelled thwhenever task xcontains a post of task
yto thread th. Fig. 1(i) shows the TPG corresponding to
the example program. The small arc arrow across the edges
corresponding to posts of aand bfrom onCreate indicates
that all posts of atake place before those of binonCreate .
The dashed edges in Fig. 1(ii) show the executes-before pairs
inferred using the rules, with the labels indicating the rule
used. For example, we infer that onCreate executes before c
by rule (C1) (see Fig. 4(C1)(b)), which essentially says that
if all paths from the initial task to cpass through onCreate ,
and all these paths have at least one post to the thread to
which onCreate is posted, then onCreate executes-before c.
We note that all five executes-before pairs, mentioned in the
previous paragraph, are inferable by our rules.
We note that if we had modified the above program with a
loop around the post of tasks aandbin lines 21–22, then the
post of ais no longer ordered before the post of b, and our
rules would only allow us to infer that onCreate executes-
before each of tasks a,b, and c. However, the approach in
[15] unsoundly infers that aexecutes-before b.
One of the uses of the executes-before information is in
determining (in a sufficient way) when two blocks of code (or
two tasks themselves) are “disjoint,” in that they can never
happen-in-parallel (i.e. overlap in time during an execution).
We give a couple of such rules in Sec. 6. The first of these
rules says that if one task executes-before another they are
disjoint. This lets us infer that onCreate is disjoint with tasks
a,b, and c, and that ais disjoint with both band c. Our
second rule says that if it is the case that a parent xof task y
executes before any other parent of ythen task xis the first
to post y, and hence the block of statements before the post
ofyin task xare disjoint with the whole of y. In the above
example this lets us infer that the block of code in task bup
to the post of c(lines 8-12) is disjoint from the whole of c.
The disjoint block information can be used to detect data
races in a sound manner. To do this we first collect conflicting
accesses that may run on different threads. In the example
program, these are the pairs of statements (4 ,17), (8 ,17),
and (13 ,17). Whenever a pair of accesses is “covered” by a
pair of disjoint blocks, we can eliminate it as non-racy (since
they can never happen-in-parallel). The access pair (4 ,17)
is covered by the pair of disjoint tasks aand c, and hence
can be eliminated. Similarly, the pair of statements (8 ,17) is
covered by the pair of blocks comprising the first half of b
(till the post of c) and the whole of c, and hence can also
be eliminated. We note that the approach in [ 9] will fail to
eliminate the access (4 ,17) as non-racy. Finally, we report
(13,17) as a potential race since we were unable to eliminate
it using any of our rules. We note that this pair of accesses
actually constitutes a harmful race.3 EVENT DRIVEN PROGRAMS
An event driven program is essentially a multi-threaded pro-
gram with dynamically created threads. It is organized as
a set of program units called “tasks” which access a set
Table 1: EDP Program Commands Cmd V,L
Statement Description
t:=create () Create a new thread and store tid in t.
stopth () Stop executing the current thread.
join(t) Wait till thread tfinishes.
post(t,a) Enqueue task aon thread t’s queue.
skip Do nothing.
x:=e Assign the value of etox.
assume (b) Enabled if bevaluates to true; skips.
lock(l) Block till lis available; then take it.
unlock (l) Releases lock l.
of shared global variables. Initially there is only a “main”
thread which starts off by executing a designated “main”
task. Among other things, a task can create new threads
and “post” tasks to other threads. Each thread conceptually
maintains a FIFO queue of tasks that have been posted to it,
and repeatedly dequeues and executes the task at the head
of its queue. The table alongside shows the set of commands
that an event driven program can use over a set of variables
Vand locks L. We denote this set of commands by Cmd V,L.
More formally an event driven program Pis a tuple ( V, L, T ),
where Vis a finite set of global variables, Lis a finite set of
locks, and Tis a finite set of tasks. Every task a∈Tis repre-
sented as a control flow graph (CFG) Ga= (Loca,enta,exta,Insta),
where Locais the (finite) set of locations of a,enta,exta∈
Locaare the entry and exit locations of arespectively, and
Insta⊆Loca×Cmd V,L×Locais the set of instructions of
a. We use the notation InstP=S
a∈TInstato denote the
set of all instructions in P, and task(ι) for an instruction ι
inInstato denote the task ain whose CFG it occurs. We
assume a designated main task called minT, which begins
the program’s execution on the main thread. We also assume
anidletask, which does no useful work, and executes in a
thread whenever there are no other tasks to run on it. We
denote the class of event driven programs by EDP and refer
to such programs as EDP programs . Fig. 2 shows the textual
version of an example EDP program with 3 tasks: m,count ,
andprod.
Before we define the semantics of an EDP program, some
notation will be useful. We use Zto denote the set of integers.
We denote the set of finite sequences (or words ) over a finite
set of symbols SbyS∗, and represent the empty sequence
byϵ. For a function f:A→B,a∈Aandb∈B, we
usef[a7→b] to denote the function g:A→Bgiven by
g(x) =f(x) for x̸=aandg(x) =botherwise. If C⊆A, we
usef↾Cto denote the restriction of fto the domain C.
For a logical condition bover a set of variables Vwe denote
by [ [b] ] the set of valuations that satisfy b. For an arithmetic
expression eover variables V, and a valuation ϕforV, we
denote by [ [ e] ]ϕthe value obtained by evaluating einϕ.
3349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406ESEC/FSE 2022, 14–18 November, 2022, Singapore R. Pai et al.
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464Some general notions for rooted labelled directed graphs
will be useful going forward. We represent such a graph by
a tuple G= (V, r,Σ, E), where Vis the set of nodes of the
graph, r∈Vis a designated root node, Σ is the set of edge
labels, and E⊆V×Σ×Vis the set of labelled directed
edges of the graph. Let G= (V, r,Σ, E) be a labelled directed
graph. A path from node utovis a finite (possibly empty)
sequence of connected edges in the graph, starting at uand
ending at v. The length of a path is the number of edges
in the path. Given a label σ∈Σ, we define the σ-length of
a path πinGto be the number of σ-labelled edges in π.
We say a node mdominates another node ninG, denoted
dom(m, n), if every path from the root node rtonpasses
through m.
LetP= (V, L, T ) be an EDP program. We define the
semantics of Pas a labelled transition system SP= (S, s0, δ),
where Sis the set of states, s0∈Sis the initial state, and δ
is the transition relation, as described below.
A state s∈Sis a tuple ⟨T, MT, MQ, ML, ϕ⟩, where
• Tis a set of active threads (that are created but not
terminated),
•MT:T → (T×Loc) associates with each active thread
a task and a location in the task, representing its
current location. Thus if MT(th) = ( t, l), then we
require that l∈Loct.
•MQ:T → T∗associates with each thread a queue of
tasks (represented as a sequence of tasks),
•ML:L ⇀Tis a partial map which associates with
each lock the thread (if any) that has acquired the lock,
and
•ϕ:V→Zis a valuation for variables representing
their current value.
The initial state sinis ({main},main7→(m,entm),main7→
ϵ,
undef , λx. 0).
The transition relation δdescribes the possible transitions
between states, and captures the semantics of the program.
Lets= (T, MT, MQ, ML, ϕ) and s′= (T′, M′
T, M′
Q, M′
L, ϕ′)
be two states, and ι= (l, c, l′) be an instruction in a task a,
with l′̸=exta. Then we have ( s, ι, s′)∈δiff there exists a
thread tinTsuch that MT(t) = (a, l), and either:
•cis the command skip,T′=T,M′
T=MT[t7→(a, l′)],
M′
Q=MQ,M′
L=ML, and ϕ′=ϕ; or
•cis the command assume (b),ϕ∈[ [b] ],T′=T,M′
T=
MT[t7→(a, l′)],M′
Q=MQ,M′
L=ML, and ϕ′=ϕ; or
•cis the command x:=e,T′=T,M′
T=MT[t7→
(a, l′)],M′
Q=MQ,M′
L=ML, and ϕ′=ϕ[x7→[ [e] ]ϕ];
or
•cis the command stopth ,T′=T −{t},M′
T=MT↾T′,
M′
Q=MQ↾T′,M′
L=ML, and ϕ′=ϕ; or
•cis the command th:=create (),T′=T ∪ { tid}
for some tid̸∈ T,M′
T=MT[t7→(a, l′)][tid7→
(idle,entidle)],M′
Q=MQ∪ {tid7→ϵ},M′
L=ML,
andϕ′=ϕ[th7→tid]; or
•cis the command join(th),ϕ(th)̸∈ T,T′=T,M′
T=
MT[t7→(a, l′)],M′
Q=MQ,M′
L=ML, and ϕ′=ϕ; ortask m: task count: task prod:
1. n := 0; 8. n := n + x; 10. x := x + 1;
2. x := 0; 9. x := 0; 11. post(child, count);
3. post(main, count);
4. child := create();
5. post(child, prod);
6. x := x + 1;
7. post(main, count);
main
count
count
countcountx := x + 1;
n := n + x;
x := 0;child
countprodprod
count
x := 0;n := n + x;x := 0;n := n + x;x := x + 1;child := create()post(main,count);x := 0;n := 0;
post(child,prod);
post(main,count);post(child,count);
m
Figure 2: Example EDP program P1and one of its
executions
•cis the command post(th, b),t′=ϕ(th),MT(t′) =
(t′′,−) where t′′̸=idle,T′=T,M′
T=MT[t7→(a, l′)],
M′
Q=MQ[t′7→(MQ(t′)·b)],M′
L=ML, and ϕ′=ϕ;
or
•cis the command post(th, b),t′=ϕ(th),MQ(t′) =
ϵ,MT(t′) = ( idle,−),T′=T,M′
T=MT[t7→
(a, l′)][t′7→(b,entb)],M′
Q=MQ,M′
L=ML, and
ϕ′=ϕ; or
•cis the command lock(k),ML(k) is undefined, T′=T,
M′
T=MT[t7→(a, l′)],M′
Q=MQ,M′
L=ML[k7→t],
andϕ′=ϕ; or
•cis the command unlock (k),ML(k) =t,T′=T,
M′
T=MT[t7→(a, l′)],M′
Q=MQ,M′
L=ML−
{(k, t)}, and ϕ′=ϕ.
For the case when l′=exta, the rules are similar, except
that the thread tnow switches to ( b,entb) when t’s queue is
non-empty and bis the task at the head of t’s queue; when
t’s queue is empty, twill now point to ( idle,entidle).
Anexecution of an event driven program Pis a finite
sequence of transitions ρ=τ1, . . . , τ n(n≥1) ofSP, such
that there exists a sequence of states s0, . . . , s nofSP, with
each τiof the form ( si−1, ιi, si) for some ιi, and s0=sin.
The sequence of instructions executed in ρisι1, . . . , ι n.
4465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522Executes Before Analysis ESEC/FSE 2022, 14–18 November, 2022, Singapore
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580It is convenient to visualize an execution of an EDP pro-
gram as a sequence of instructions (or statements), with time
going downwards and a column for each thread, as shown in
Fig. 2. Note that there may be multiple instances of a task
that execute in the same or different threads in an execu-
tion. In the example execution of Fig. 2 the task count has
three instances, two in the main thread and one in the child
thread. However, each instance (except possibly the last one
on a thread) runs to completion in that once the instance is
executing on a thread, it is not switched out from the thread
until it completes by reaching its exit location. If we project
an execution to a single thread thit will look like a sequence
of initial and complete execution paths (except possibly for
the last one which may only be initial) through the CFGs of
the different tasks.
We close this section with a notion related to task CFGs.
LetP= (V, L, T ) be an EDP program, and let abe a task
inT. Let ι′= (l, c, l′) and ι= (m, c, m′) be instructions in
Insta. We say instruction ι′= (l, c, l′)may follow instruction
ιif there is a path from m′tolinGa.
4 TASK POST GRAPH
In this section we introduce the Task Post Graph (TPG)
structure for an event-driven program. This structure will
help us in identifying executes-before pairs in an EDP pro-
gram in a structural manner.
The TPG of an EDP program Pcontains information
about task apossibly posting task bto a thread th, repre-
sented by an edge in the graph from atoblabelled th. Note
however that tasks may be posted to “concrete” threads cre-
ated dynamically during the execution of P. To use a static
label for the post edges, we make use of the notion of abstract
threads. We associate all the threads created at a particular
create statement in the program with an “abstract” thread
corresponding to that statement. For convenience we assume
that in an EDP program a thread variable is assigned at
only one statement, and we use the thread variable as the
name of the abstract thread associated with that create
statement. We note that a create statement in Pmay be
executed multiple times during an execution of P, as it may
be in a loop in a task, or it may be in a task that is posted
multiple times during the execution of P. We say an abstract
thread is unique if it corresponds to exactly one concrete
thread. For convenience we call such an abstract thread a
unique thread .
To illustrate these notions, consider the example program
P2of Fig. 3. There are four abstract threads: child1 ,child2 ,
child3 , and the implicitly created thread main . The abstract
threads main andchild1 are unique. The abstract threads
child2 andchild3 due to lines 5 and 10, respectively, are not
unique: multiple concrete threads corresponding to child2 are
created in a loop, while child3 is created in a task (namely
a) that is posted multiple times (lines 2 and 20).
LetP= (V, L, T ) be an EDP program. The task post graph
(TPG) induced by P, denoted TPG P, is a labelled directed
graph ( N, E) where N=T∪ {s}is the set of vertices oftask m:
1. child1 := create();
2. post(child1, a);
3. post(main, b);
4. while (*)
5. child2 := create();
task a:
10. child3 := create();
task b:
20: post(main, a);
m
a bchild 1 main
mains
main
Figure 3: Illustrating abstract threads: Prog P2and
its TPG
the graph corresponding to the tasks of Pand a “dummy”
initial vertex s, and Eis the set of labelled edges of the form
(a,th, b) such that task acontains a post of task bto the
abstract thread thinP. We also add the edge ( s,main ,m)
inEto denote the implicit posting of the main task mto the
main thread. The TPG for the program P2in Fig. 3 is shown
to the right in Fig. 3. To avoid clutter, we henceforth leave
out the dummy node sfrom the diagrammatic representation
of the TPG.
Next we define a few notions related to the task post
graph that will be useful in the sequel. The “instance post
tree” corresponding to an execution of an EDP program
depicts the different task instances that were created during
the execution and the order in which one instance posted
other task instances to (abstract) threads. More formally,
letP= (V, L, T ) be an EDP program, and let ρbe an
execution of P. The instance post tree corresponding to ρ,
denoted IPT ρ, is a rooted directed ordered tree with nodes
corresponding to task instances in ρ, the first instance of mas
the root, and labelled edges ( i,th, j) whenever task instance
count prodmmain
countmain mainchild
child
countiposts task instance jto the ab-
stract thread th. Moreover for each
instance ithe children of iare
ordered according to the order in
which they were posted in i. The
figure alongside shows the instance
post tree corresponding to the exe-
cution of Fig. 2, with the children
of a node being ordered from left
to right (the blue arc also indicates this). We note that ev-
ery path in the instance post tree of an execution ρofP
is also a path in TPG P(essentially the tree IPT ρembeds
homomorphically into TPG P).
We say that an edge from task ato task blabelled thin
TPG Pis aunique post edge if there is exactly one post(th, b)
statement in a, and that statement is not in a loop. It is
easy to see that if ( a,th, b) is a unique post edge, then any
instance of acan post at most one instance of bto thread
th. We say that a task ainPisunique if every execution of
Pcontains at most one instance of a. A sufficient condition
onTPG Pthat ensures that task ais unique is that there
should be a unique path from mtoa, and all edges along
this path should be unique post edges (in the sequel we will
5581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638ESEC/FSE 2022, 14–18 November, 2022, Singapore R. Pai et al.
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696refer to this condition as “a unique path of unique posts”).
To see that the condition is indeed sufficient, suppose we had
two instances of ain an execution ρofP, and consider the
instance post tree IPT ρofρ. Consider the two paths πand
π′from mto the two instances of ain this tree, and let xbe
the lowest common ancestor of the two instances of aalong
these paths. Let xbe an instance of task b. Let yandy′be
the two children of xalong the paths πandπ′respectively.
Ifyandy′are instances of different tasks, then we do not
have a unique path from mtoainTPG P. Ifyandy′are
instances of the same task say c, then the ( b,th, c) edge in
TPG Pcannot be a unique post edge.
Finally, let πandπ′be two paths in the TPG of a program
P. We say πisordered-before π′ifπ=π1·(x,th, y)·π2and
π′=π1·(x,th′, z)·π′
2for some paths π1,π2, and π′
2, threads
thandth′, and tasks x,yandz, such that y̸=z,π2andπ′
2
have no node in common, and each post of task ydominates
all posts of task zin the CFG of task x.
5 EXECUTES-BEFORE
LetPbe an EDP program, and let aandcbe tasks in P. We
say task aexecutes before taskcinP, if in every execution
ρofP,every instance of acompletes execution before any
instance of cbegins execution in ρ. More precisely, suppose ρ
contains the entry instruction of an instance of cat position
jand the entry instruction of an instance of aat position i;
then i < j and there exists a position kwith i < k < j , such
that the instance of aexecutes its exit instruction at position
k.
We describe several sufficient conditions on an EDP pro-
gram and its TPG, which will ensure that a task executes
before another. Let P= (V, L, T ) be an EDP program, and
aandctwo distinct tasks in T. Each condition on TPG P
below aims to ensure that aexecutes before c. Figs. 4 and 5
illustrate these conditions. In the figures, an arc arrow across
path πandπ′indicates that πis ordered-before π′.
(C1) This condition is illustrated in Fig. 4(C1)(a). There is
a task xwhich is posted to a unique thread th, and a
number d≥0 such that:
(1)There is a unique path of unique posts from mtox;
(2) All paths from mtoaandmtocpass through x;
(3)Each path from xtoais labelled thand has length
at most d; and
(4) Every path from xtochasth-length at least d+ 1.
Fig. 4(C1)(b) shows the special case of this condition
when d= 0 and a=x.
(C2) This condition is illustrated in Fig. 4(C2). There is a
taskx, a unique thread th, and a number d≥1, such
that:
(1)There is a unique path of unique posts from mtox;
(2) All paths from mtoaandmtocpass through x;
(3)There is a unique path πof unique posts of length d
from xtoa, with all edges labelled th; and
(4)For every path π′from xtoc,π′is ordered after
the path πfrom xtoa; and the th-length of π′is at
least d.(C3) This condition is illustrated in Fig. 4(C3). There is a
taskxand a unique thread thsuch that:
(1)There is a unique path of unique posts from mtox;
(2)xposts task aonto thvia a unique post, and is the
only task to post a;
(3)For every child bofxother than a, the path from m
toashould be ordered-before a path from mtob;
(4) All paths from mtocpass through x; and
(5) Task cis always posted to the thread th.
Fig. 5 shows the TPGs of some EDP programs that satisfy
the conditions (C1)–(C3) respectively. The edge label “-”
indicates that the thread does not matter. In each case the
taskacan be seen to execute before task c.
Next we define some ways of inferring executes-before pairs
from an initial set of such pairs in P.
(I1)If a task aexecutes before every parent dof a task cin
TPG P, then amust execute before c. (See Fig. 6(I1)).
(I2)If tasks aandcare such that there is a unique path
of unique posts from mtoainTPG P,ais posted to
a unique thread th,aposts ctoth, and aexecutes
before every parent of cthat is different from a; then
amust execute before c. (See Fig. 6(I2)).
(I3)If tasks a,d, and care such that aexecutes before d,
dexecutes before c, and ddominates cinTPG P; then
amust execute before c. (See Fig. 6(I3)).
We can now give a simple saturation algorithm (Alg. 1),
to compute a sound set of executes-before pairs.
Algorithm 1: Compute EB pairs
Data: EDP Program P
Result: SetEBof executes-before pairs
EB:=∅;
Add pairs ( a, c) toEBbased on conditions (C1)–(C3);
while ∃a new pair (a, c)that can be inferred by rules
(I1)–(I3) do
EB:=EB∪ {(a, c)};
end
return EB;
Theorem 5.1. The set EBreturned by Alg. 1 for an EDP
program Pis sound in that if (a, c)∈EBthen aexecutes
before cinP.
Proof. Before we give a detailed proof as an illustration
of the argument, we argue why amust execute before cin a
program Pwith a TPG shown in Fig. 5(C1(a)). Assuming
thatthis a unique thread and mmakes a unique post of xto
th, the program Psatisfies condition (C1). Now consider an
execution ρofPwhich contains an instance naofaand an
instance ncofc. We will argue that the intance namust finish
execution before nccan begin execution. We note that there
must be a unique instance of xinρ, saynx. Now namay have
been posted by nxdirectly or by an instance ndof task dthat
was posted by nx. Let us consider the more interesting latter
case. The instance ncmust have been posted by an instance
6697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754Executes Before Analysis ESEC/FSE 2022, 14–18 November, 2022, Singapore
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
(C3)Unique
posts postsUnique Unique
postsUnique
posts
(C1)(b) (C1)(a) (C2)main
m
a
cthx
th thb
a cth-len≥dlendthxmain
m
th′
th-len≥1main
m
a
cth
th-len≥d+ 1
cathxmain
m
th
len≤d
Figure 4: Illustrating sufficient conditions (C1)–(C3) on the TPG of a program, for ato execute before c.
(C2) (C3) (C1)(a)
mmain
dth
e
f ath
cth− thxth
dth
ce
f
gathth
−
th
ththmain
m mmain
ath
b−
c−
th−
d
Figure 5: Example TPGs of programs satisfying con-
ditions (C1)–(C3). In each case task aexecutes be-
fore c.
(I1)EB
EB
EB
(I2)EB
EB
EBUnique path of
unique posts
EB
EB
(I3)EB
a d e
c− −a d e
c− −thm
thad
c
Figure 6: Illustrating executes-before inference rules
(I1), (I2) and (I3). Dark edges are inferred by the
rules.ngofg, which in turn was posted by an instance nfoff,
which in turn was posted by an instance neofe. The basic
observation is that nd(which is at a th-distance of 1 from
x) must be posted to thbefore ng(which is a th-distance
of 2 from x). This holds regardless of whether nxposted nd
before neor not. It then follows that nawill be posted to th
byndbefore ngexecutes on th; and hence namust complete
execution before nccan begin execution.
It is sufficient to argue that (a) the base rules (C1)-(C3)
are sound, and that (b) the inference rules (I1)–(I3) are sound
as well.
To see the soundness of rule (C1), let aandcbe tasks in
program Psatisfying the conditions of the rule, and consider
an execution ρofPcontaining an instance of aand an
instance of c. Consider the instance post tree IPT ρofρ,
and let naandncbe the nodes corresponding to the above
instances of aandcrespectively. Let πandπ′be the two
initial paths in the tree to naandncrespectively. We note
thatπandπ′must correspond to initial paths in TPG P. By
the conditions of (C1), the two paths in IPT ρmust appear
as shown in Fig. 7a (except possibly for the left-to-right
ordering). Here nxis posted to th,nyis the lowest common
ancestor of naandncin the tree, and all tasks from nxto
nyare posted onto th. Let ny=n0, n1, . . . , n k=na(k≥0)
be the task instances in the path from nytona(all these
task instances being posted to th). Then there must exist a
subsequence of task instances m1, . . . , m k+1in the path from
nytonc(excluding ny), such that each miis posted to th.
The dashed contours in the figure indicate the same th-level
from ny(ornx). It is clear that n0=nymust be posted to
thbefore m1is. We can now argue that n1must be posted to
thbefore m2is. Either n1is posted to thbefore m1is, or m1
is posted before n1is. In the former case it is clear that n1
would be posted before m2. In the latter case, m1must wait
fornyto complete its execution on thbefore it can post m2,
by when nywould have posted n1toth. Thus in both cases,
n1is posted to thbefore m2is. It now follows that n2must be
7813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870ESEC/FSE 2022, 14–18 November, 2022, Singapore R. Pai et al.
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
m
nx
ny
n1
n2m1
m2
mknk=nath
th
th
thth
th
thth
ncth
mk+1
(a) Inst. post tree for (C1)
nx
ny
n1
n2m1
m2
mknk=nath
th
th
thth
thm
ncth
(b) Inst. post tree for (C2)
(i) (ii)m
nx
nanxm
th
nanb
ncncth thth
(c) Inst. post tree for (C3)
Figure 7: Illustrating the soundness argument for (C1), (C2), and (C3)
posted to thbefore m3is; and so on, till na=nkis posted to
thbefore mk+1is. Since they are posted to the same unique
thread th,namust finish execution before mk+1can begin
execution. Since nccan be posted only after mk+1begins
execution, it follows that the instance namust complete its
execution before the instance of ncbegins execution. This
proves that amust execute before cinP.
For the soundness of (C2), consider tasks aandcsatisfying
the conditions of (C2), and consider an execution ρcontaining
an instance of aandc. Once again the instance post tree of
ρmust look like the one shown in Fig. 7b. By the ordering
condition, the post of the task corresponding to n1tothin
the instance nyofymust have taken place before the post
of the task (say z) that leads to the post of m1. Thus n1is
in the queue of thbefore the instance of zis posted, and
therefore before m1is eventually posted to th. Continuing
this argument, we have that nk=nais posted to thbefore
mkis; and hence nacompletes its execution on thbefore mk
begins, and hence also before ncbegins. This proves that a
executes before c.
For the soundness of (C3), consider an execution ρof the
program Pcontaining instances of aandc. Using the IPT ρ,
we show every instance of acompletes execution before an
instance of ccan even start. Let naandncbe the nodes in the
IPT ρ, corresponding to the instances of aandcrespectively.
InIPT ρ, due to constraints (1) and (2) of rule (C3), there
is exactly one instance of the tasks in the path from mtoainTPG P. Thus nais the only instance of task awhile
task ccan have multiple instances, ncbeing one of them.
Further, from constraints (2) and (4) in (C3), node nccan
be (i) a descendant of nainIPT ρ, or (ii) a descendant of nb
inIPT ρ, where bis a sibling of ainTPG P(as in Fig. 7c).
Case (i): It is easy to see that the instance nais posted even
before ncis posted. Since they are posted to the same unique
thread th(due to constraints (1) and (5) of (C3)), instance
nacompletes execution even before nccan start. Case (ii):
Instance ncis posted only after nbis posted. Since the path
from task mto task ais ordered before any path from mto
b(due to constraint (3)), instance nxposts naeven before
it posts nb. Since naandncare posted to the same unique
thread th,naappears in th’s queue even before nc. Thus
instance nacompletes execution before nccan even start. In
either case, instance naof task acompletes execution before
an instance ncof task c. Thus aexecutes before c.
Coming now to the soundness of the inference rules (I1)–
(I3). Consider rule (I1), and suppose tasks aandcsatisfy the
conditions of the rule in P. Consider an execution ρwith an
instance of aandc. Now the instance of cmust have been
posted by one of the parents dofc. But aexecutes before d,
so the instance of amust have completed before the instance
ofdbegan, and hence before the instance of cbegan. For
the case of (I2), suppose tasks aandcsatisfy the conditions
of rule (I2), and consider an execution ρwith an instance
ofnaofaandncofc. Ifncwas posted by a task different
8929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
957
958
959
960
961
962
963
964
965
966
967
968
969
970
971
972
973
974
975
976
977
978
979
980
981
982
983
984
985
986Executes Before Analysis ESEC/FSE 2022, 14–18 November, 2022, Singapore
987
988
989
990
991
992
993
994
995
996
997
998
999
1000
1001
1002
1003
1004
1005
1006
1007
1008
1009
1010
1011
1012
1013
1014
1015
1016
1017
1018
1019
1020
1021
1022
1023
1024
1025
1026
1027
1028
1029
1030
1031
1032
1033
1034
1035
1036
1037
1038
1039
1040
1041
1042
1043
1044from a, then similar to the previous argument nawould
execute before nc. Ifncwas posted by an instance of task
a, then since ahas at most one instance by the conditions
of (I2), ncmust have been posted by natoth. Since this a
unique thread, nccan only execute once nahas finished. This
completes the soundness argument for (I2). The soundness
of rule (I3) is fairly immediate. The only thing to note is
that the definition of executes-before is nottransitive. In
particular if we know aexecutes-before danddexecutes
before c, we cannot conclude that aexecutes before c. This is
because we may have an execution with instances of aandc,
butnoinstance of d. However note that if ddominates cin
the TPG of P(as the rule requires), then we must have an
instance of dwhenever we have one of c, since an instance of
dhas to execute to (transitively) post an instance of c. The
correctness now follows easily. □
6 DATA RACES AND MHP
Let us fix an EDP program P= (V, L, T ). Consider two
tasks aandbinT(aandbcould be the same task), and
two non-empty paths πandπ′inGaandGbrespectively.
We say πandπ′may happen in parallel inPif there is an
execution ρofP, and two instances of aandbinρ, in which
the execution follows paths πandπ′inaandbrespectively,
such that the paths πandπ′interleave (that is, either π′
begins after πhas begun but not yet ended; or vice-versa).
We now define when two statements s1ands2(correspond-
ing, say, to instructions ι1= (l1, c1, l′
1) and ι2= (l2, c2, l′
2))
in tasks aandbinPrespectively, “may happen in parallel.”
Consider the program P′obtained from Pby enclosing the
statements s1ands2inskip statements. More formally, we
obtain P′by replacing the instruction ι1by the sequence of
instructions ( l1,skip, m1), (m1, c1, m′
1), and ( m′
1,skip, l′
1),
where m1andm′
1are new locations in Loca; and similarly
forι2. Let π1be the path l1skip→m1c1→m′
1skip→l′
1inGa′,
and similarly π2inGb′. We now say s1ands2may happen
in parallel inP, if the paths π1andπ2may happen in par-
allel in the program P′. In the example program of Fig. 2,
statements in lines 6 and 10 may happen in parallel, whereas
statements in lines 2 and 10 cannot happen in parallel.
Two statements are called conflicting accesses if they are
read/write accesses to the same variable, at least one of
them is a write, and the two statements may run on different
threads. We say two statements s1ands2inPare involved in
adata race (or are simply racy) if they are conflicting accesses
that may happen in parallel. Thus, the statements 6 and 10
in the example program of Fig. 2 are racy, but statements 2
and 10 are not. Similarly, statement 8 races with itself, while
statement 10 does not.
Finally, we define what it means for a “block” of code
to happen in parallel with another. A block of code in Pis
specified by a pair ( l, X), where for some task ainP,lis
a location in LocaandX⊆Locais a subset of locations
reachable from l. An initial path in a block B= (l, X) of a
taskainP, is a non-empty path in Gathat begins at land
stays within the set of locations X, except possibly for thelast location in the path. We say a statement s= (m, c, m′)
inPbelongs to block B= (l, X) ifmbelongs to the set X.
We say two blocks B1andB2ofPmay happen in parallel
if there are two initial paths π1inB1andπ2inB2, which
may happen in parallel with each other. Otherwise, we say
B1andB2aredisjoint . In the example program of Fig. 2,
B1= (1,{1,2}) and B2= (10 ,{10,11}) are blocks in tasks
mand prod, respectively. The two blocks can be seen to be
disjoint. We observe that if s1ands2are statements in two
blocks B1andB2respectively in P, and B1andB2are
disjoint with each other, then it follows that s1ands2cannot
happen in parallel.
We now present four rules to identify pairs of disjoint
blocks in an EDP program. The first two are based on the
executes-before order in the program, while the last two based
on fork/join and locks are more standard. Let us fix an EDP
program P= (V, L, T ) and let aandbbe two tasks in T.
The rules below tell us when a(or a part of it) is disjoint
from b.
•(Rule 1, “First-To-Post”) If ais a unique task, aposts
b, and aexecutes before every other parent dofb;
then the blocks ( enta, X) and bare disjoint, where
X=Loca\{n∈Loca|nmay follow a post of bina}.
•(Rule 2, “Executes-Before”) If aexecutes before b, then
aandbare disjoint.
•(Rule 3, “Join”) If ahas a join(th′) statement such
that th′corresponds to a unique abstract thread, and
bis posted only to th′; Then the block Bcomprising
statements dominated by the join statement in a, is
disjoint with the task b.
•(Rule 4, “Lock”) If B1andB2are blocks enclosed in
lock(l)-unlock (l) statements, for some lock l; then B1
andB2are disjoint.
Theorem 6.1. The rules 1–4 are sound in that if any
EDP program Psatisfies the premise of one of the rules, the
identified blocks are indeed disjoint in P.
Proof. The soundness of Rules 3 and 4 are standard. To
see that Rule 1 is sound, suppose tasks aandbinPsatisfy
the conditions of the rule. Consider an execution ρofP
in which there is an instance of task aand an instance of
task b. Now there can only be one instance of ainρsince
ais a unique task. If the instance of bwas posted by some
other parent cofb, then since aexecutes before c, it must
have finished execution before bbegins, and hence must be
non-overlapping with b. On the other hand, if the instance
ofbwas posted by the (unique) instance of a, then clearly
no part of the statements in the block ( enta, X) can overlap
with statements of b. This completes the soundness of Rule 1.
The soundness of Rule 2 (Executes-Before) is immediate. □
Alg. 2 shows our algorithm to detect races in EDP pro-
grams. We say that the pair of blocks ( B, B′)covers a pair
of statements ( s, s′) in a program P, if either sbelongs to B
ands′belongs to B′or vice versa.
91045
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102ESEC/FSE 2022, 14–18 November, 2022, Singapore R. Pai et al.
1103
1104
1105
1106
1107
1108
1109
1110
1111
1112
1113
1114
1115
1116
1117
1118
1119
1120
1121
1122
1123
1124
1125
1126
1127
1128
1129
1130
1131
1132
1133
1134
1135
1136
1137
1138
1139
1140
1141
1142
1143
1144
1145
1146
1147
1148
1149
1150
1151
1152
1153
1154
1155
1156
1157
1158
1159
1160Algorithm 2: Race Detection
Data: EDP Program P
Result: SetPRof potential races
Find the set CAof conflicting accesses in P;
PR:=CA;
foreach conflicting access pair (s1, s2)in PR do
ifthere are disjoint blocks B1andB2which cover
(s1, s2)then
PR:=PR− {(s1, s2)}; // ( s1, s2) is non-racy;
end
end
return PR;
As another application of our EB-based disjoint block rules,
consider the problem of identifying redundant synchroniza-
tion blocks in an EDP prgram. We say that a block of code
enclosed in lock-unlock statements is a redundant synchro-
nization if the block does not contain a statement that may
happen in parallel with a conflicting access. Synchronization
blocks usually have significant performance overheads, and
locks that are provably redundant can safely be eliminated
from the program. We can compute a conservative set of
redundant synchronizations as follows. We first find the set
of conflicting accesses in the program, and eliminate all pairs
covered by the disjoint block rules (1–3) (i.e. all rules except
the lock rule). Let the resulting set of conflicting accesses be
S. Now for each synchronization block Bwe check whether
Bcontains an access that is part of a pair in S; if not, we
sayBis redundant.
7 ANDROID APPS AS EDP
PROGRAMS
An Android application (or app) is built using one or
more of Android’s four core components – activity ,ser-
vice,content provider , and broadcast receiver . An activity
is a component that provides a UI with which users can
interact. An activity undergoes a sequence of state tran-
sitions that permits it to interact with the user. These
state transitions are triggered by lifecycle callbacks such as
onCreate ,onStart ,onResume ,onPause ,onStop ,onRestart ,
andonDestroy . These callbacks run on the main thread. The
ActivityManagerService , a part of the Android system, con-
trols the order in which the activity callbacks are executed.
Android also provides ways for executing user events (UI
tasks) and background operations in threads other than the
main thread. In this section, we model the activity component
of Android and the background processing.
Modeling an activity. An Android application can be
viewed as an event driven program with the activity callbacks
running as tasks on the main thread. The sysTask running
on the system thread models ActivityManagerService and
it controls the order of callbacks running on the main thread.
A task in our model corresponds to the callbacks listed above.sysTask:
1. post(main, onCreate);
2. L1: post(main, onStart);
3. L2: post(main, onResume);
4. while(*)
5. post(main, onClick);
6. post(main, onPause);
7. if (*)
8. goto L2;
9. else {
10. post(main, onStop);
11. if (*) {
12. post(main, onRestart);
13. goto L1;
14. }
15. else
16. post(main, onDestroy);
17. }
Figure 8: sysTask as an EDP task
UI tasks (like onClick ) are modeled as EDP tasks that ex-
ecute on the main thread. These tasks are enabled for exe-
cution after the onResume task. Fig. 8 shows the sysTask as
an EDP task that posts the lifecycle tasks and an onClick
UI task in the expected order.
Android provides the AsyncTask feature that allows
to run instructions in the background and report re-
sults from the background thread to the main thread.
We model an AsyncTask as having three tasks namely
doInBackground ,onProgressUpdate and onPostExecute .
The doInBackground task which does background processing
runs on a new thread, while onProgressUpdate which passes
results of the background processing runs on the main thread,
andonPostExecute which does clean up operations after the
background processing finishes, runs on the main thread.
8 IMPLEMENTATION AND
EVALUATION
In this section we evaluate the recall of EB conditions (in
Sec. 5) in retrieving executes-before pairs. We also assess the
usefulness of these conditions in downstream applications
of race detection and redundant synchronization detection.
We present the tool AndRacer , that statically analyzes
Android apps to compute EB pairs, data races, and redundant
synchronizations. We first describe the tool implementation,
followed evaluation on several Android apps.
8.1 Tool Implementation
AndRacer takes an application package (as a .apk file) as
input and outputs a set of pairs of accesses that may be
involved in a data race. A schematic representation of the
tool is shown in Fig. 9. The tool has four components: (1)
TPG Builder that constructs the TPG of the input app, (2)
EB Generator that computes pairs of tasks that are executes-
before related, (3) CA Generator that computes the list of
conflicting access pairs, and (4) Rule Checker which applies
the disjoint block rules to eliminate non-racy conflicting
access pairs and to list redundant synchronizations.
TPG Builder. The TPG Builder relies on having an en-
try method for the application. The tool uses the FlowDroid
101161
1162
1163
1164
1165
1166
1167
1168
1169
1170
1171
1172
1173
1174
1175
1176
1177
1178
1179
1180
1181
1182
1183
1184
1185
1186
1187
1188
1189
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218Executes Before Analysis ESEC/FSE 2022, 14–18 November, 2022, Singapore
1219
1220
1221
1222
1223
1224
1225
1226
1227
1228
1229
1230
1231
1232
1233
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243
1244
1245
1246
1247
1248
1249
1250
1251
1252
1253
1254
1255
1256
1257
1258
1259
1260
1261
1262
1263
1264
1265
1266
1267
1268
1269
1270
1271
1272
1273
1274
1275
1276
CA ListEB
TPGTPG
BuilderEB
Generator
Rule
Checker
CA
GeneratorPot.Races
SyncRed.And.
AppAndRacer
Figure 9: Schematic of AndRacer tool
framework [ 2] to translate an application to one having an en-
try class, DummyMain , with an entry method dummyMain . The
dummyMain method posts all the life-cycle callbacks of the
Android components. We assume a single run-time instance
for a component. The TPG Builder first finds the nodes in
the TPG which essentially are the tasks. It then collects the
callbacks using FlowDroid . The post statement determines
an edge, in the TPG, from the task that has the statement
to the task being posted. The TPG Builder recognizes meth-
ods like Handler.post ,Thread.start ,Timer.schedule , and
AsyncTask.execute as post statements. Each edge has at-
tributes like the abstract thread for the post, uniqueness of
the abstract thread, uniqueness of the post, and the order of
the post. A post is determined to be non-unique if it appears
inside a loop or in different locations. Finally, the order of
posts made by a task is determined by the order it which it
appears in the CFG of the task.
EB Generator. This component implements Alg. 1 to
soundly compute the executes-before relation between all
possible callback pairs in a given app.
CA Generator. The CA Generator collects the set of ac-
cesses to shared variables and marks whether they are read or
write. For each callback pair that may be posted to different
threads (which is inferred from the labels of incoming edges
to the callbacks in the TPG) and for each pair of shared ac-
cesses in the callback pair, the CA Generator checks whether
the pair of accesses conflict. If so, the access pair is marked
as conflicting. The tool uses the points-to analysis computed
by the context- and flow-insensitive Spark framework [ 10],
to decide on the access pairs.
Rule Checker. Given a list of conflicting access pairs in the
app and the TPG for the app, this component applies the
disjoint block rules described in Sec. 6 to eliminate conflicting
access pairs that cannot happen in parallel. This component
also applies the procedure described in Sec. 6 to compute
redundant synchronization blocks.
8.2 Evaluation
Benchmarks. We ran our tool on the latest versions of 19
real world Android applications to demonstrate the usefulness
of the executes-before rules. The first part of Table 2 summa-
rizes the features of the applications which are taken from
various domains like finance, health, security, and education.
Only applications with multiple threads were selected for the
experiments and the column “Thds” shows the number ofthreads in each application and the “Tasks” column gives
the number of tasks.
Results. We conducted the experiments on an Intel Xeon
W-2295 CPU with 256GB RAM running Ubuntu 20.04 LTS.
The second part of Table 2 shows the recall of the executes-
before (EB) conditions in computing executes-before pairs,
when we ran AndRacer on the apps. The “AR-EB” col-
umn gives the number of executes-before pairs computed
by the tool while the “Man-EB” column gives the number
of executes-before pairs found on manual inspection. The
manual inspection was done on a subset of Android com-
ponents, mostly activities. The “Recall%” column gives the
fraction of the manual pairs identified by the tool (manual
pairs identified by the tool divided by total manual pairs) as
a percentage. The “Time” column gives the time taken (in
seconds) by the tool for the executes-before analysis.
Our tool performed well with an average recall of 97%,
demonstrating that our executes-before conditions are fairly
comprehensive in identifying executes-before pairs in practice.
In fact most of the missed EB pairs were either due to the
imprecise flow sensitive analysis of Spark or callbacks missed
byFlowDroid , rather than the inadequacy of the rules.
Table 2: Benchmark features and recall
Features Recall
App KLoC Thds Tasks AR-EB Man-EB Recall% Time (s)
ChildMon 1.0 3 34 44 45 97.7 0.05
Aard2 4.9 7 88 74 74 100.0 0.31
Dns66 4.9 7 47 22 22 100.0 0.10
CharReco 6.5 5 25 15 15 100.0 0.05
A2DPVol 6.8 9 113 148 158 94.0 0.42
ASetu 8.2 3 61 82 38 100.0 0.11
KPDroid 18.1 5 79 77 83 93.0 0.21
OpenApk 2.1 5 34 25 28 89.0 0.05
DeskCon 3.1 13 64 71 37 100.0 0.11
ClipStk 3.9 5 146 119 40 100.0 2.14
CresCash 5.3 13 165 130 42 100.0 0.91
BitCoinPr 7.0 13 115 38 22 100.0 0.20
OSMon 14.2 4 68 14 14 100.0 0.03
AnyMemo 23.3 14 251 175 81 95.0 0.52
Mileage 44.5 12 109 54 58 93.0 0.18
AntPod 54.5 11 458 310 151 97.3 3.47
OwnCloud 56.0 14 390 222 136 100.0 1.13
k9mail 76.1 6 296 138 20 100.0. 1.11
Fbreader 76.5 20 285 344 120 97.5 2.85
Table 3 compares the executes-before relations detected
byAndRacer and ERCatcher [ 15] on a set of microbench-
marks called “Benchdroid” [ 14], designed by the authors of
ERCatcher. The “App Groups” column lists the applications
grouped based on the usage of Android constructs. The num-
ber of apps in a group is listed in the “#Apps” column. The
“Man-EB” column lists the actual executes-before pairs in
these programs that we found by manual inspection. The
“ER-EB” column gives the number of executes-before pairs
111277
1278
1279
1280
1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300
1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
1313
1314
1315
1316
1317
1318
1319
1320
1321
1322
1323
1324
1325
1326
1327
1328
1329
1330
1331
1332
1333
1334ESEC/FSE 2022, 14–18 November, 2022, Singapore R. Pai et al.
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
1365
1366
1367
1368
1369
1370
1371
1372
1373
1374
1375
1376
1377
1378
1379
1380
1381
1382
1383
1384
1385
1386
1387
1388
1389
1390
1391
1392detected by ERCatcher (we disregard the unsound pairs re-
ported by ERCatcher) while “AR-EB” gives the number
detected by AndRacer . Our tool has a total recall of 94.8%
compared to ERCatcher’s recall of 67.2%.
Table 3: Comparison with ERCatcher
App Groups #Apps Man-EB ER-EB AR-EB
AsyncTask 6 22 13 22
Lifecycle 4 30 29 30
Looper 3 9 9 8
Executor 2 5 0 5
Singleactivity 8 40 18 35
Thread 2 7 7 7
Timertask 2 3 2 3
Table 4 shows the results of our tool for race detection
on these apps. The “CA” column shows the number of con-
flicting accesses detected. The table is further structured to
evaluate three main features of the tool: the effectiveness of
the EB relations in eliminating CA pairs as non-racy (“EB
usefulness”); the precision in detecting actual races (“Race
statistics”); and the usefulness in detecting redundant syn-
chronizations (“Redn. Sync.”). The “Syn” and “EB” columns
give the number of CA pairs eliminated as non-racy due to
the use of synchronizations and executes-before relation, re-
spectively. Note that some pairs can be eliminated by both.
The “SEB” column gives the number of CA pairs eliminated
solely due to the executes-before relation. Moving on to race
statistics, the “PR” column gives the number of CA pairs
flagged as potentially racy by the tool and “AR” is a conser-
vative count of actual races found by manual inspection. Due
to the complex control flow, we were not able to inspect some
of the apps for actual races. The top section of the table gives
AR values for those apps which we could manually analyze.
The time taken to report races (in sec) is given under the
“T (s)” column. Finally, the “RSB” column gives the number
of redundant synchronizations detected by our tool and the
number in parenthesis is the number of synchronizations used
in the apps. The “T (s)” column here is the time taken (in
sec) to report the redundant synchronizations.
Furthermore, among the Potential Races in the column
(PR) we looked at the applications with the PRs on the non-
atomic accesses of long, double, float. We see that PRs on non-
atomic accesses of long, double, and float were found in ap-
plications, CresCash(6), AntPod(267) and OwnCloud(1689).
The accesses of CresCash were manually verified and were
found to be Harmful Potential Racy Pairs(HPR).
Discussion. We note that our tool is able to filter out a
large part of the conflicting access pairs as non-racy (on the
average of 45.3% of CAs are eliminated). The proposed EB
based rules were found to be useful in eliminating CA pairs,
as on an average, 57% of CA pairs eliminated were solely due
to the EB rules. It is worth noting that the EB rules were
soley responsible all CA pairs eliminated in the CresCash appTable 4: Data Races reported by AndRacer
EB Usefulness Race Statistics Redn. Sync.
App CA Syn EB SEB PR AR T (s) RSB T (s)
ChildMon 22 0 10 10 12 12 2.3 0 (0) 2.2
Aard2 31 5 6 6 20 6 21.1 4 (6) 21.1
Dns66 51 21 22 3 27 0 11.4 5 (7) 11.4
CharReco 43 0 30 30 13 13 2.7 0 (0) 2.7
A2DPVol 47 0 17 17 30 30 7.6 0 (0) 7.3
ASetu 8 0 2 2 6 6 70.0 0 (0) 69.0
KPDroid 49 45 14 2 2 0 20.0 0 (1) 19.9
OpenApk 693 0 148 148 545 +9 9.1 0 (0) 9.0
DeskCon 122 0 29 29 93 +21 7.5 0 (0) 7.5
BitCoinPr 156 0 57 57 99 +35 17.7 0 (0) 17.5
AnyMemo 3602 98 96 96 3408 +115 27.6 3 (5) 27.4
Mileage 2592 225 951 909 1458 +475 5.5 0 (1) 5.7
OwnCloud 6130 15 73 62 6053 +1464 78.9 5 (6) 77.5
Fbreader 226 0 156 156 70 +37 29.3 44 (50) 29.2
ClipStk 371 269 1 1 101 10.6 4 (17) 10.7
CresCash 6058 05794 5794 264 72.5 0 (0) 70.6
OSMon 3911 0 221 221 3690 4.8 0 (0) 4.9
AntPod 2193 338 383 383 1472 157.8 50 (57) 148.3
k9mail 5146 4948 2 2 196 97.9 26 (36) 97.8
which had well over 6000 CAs. The figures for the CharReco
app are similarly encouraging.
Our tool is fairly precise in that only few of false positives
are reported. One of the reasons for imprecision in race detec-
tion is due to the imprecision in Spark ’s points-to analysis.
Another reason is that the tool considers that multiple in-
stances of a task to be represented by one “abstract” task.
There are several scenarios in the apps where multiple com-
ponents post the same task. Since none of the rules apply,
this leads to some false positives. Despite these, the average
precision of our tool is around 43%.
The redundant synchronizations analysis detects unnec-
essary use of synchronization constructs in the applications.
The tool found that some of the apps like Aard2, Dns66,
AntPod, OwnCloud, and Fbreader relied on a lot of synchro-
nizations which were not needed since their shared accesses
do not happen in parallel (as detected by the EB conditions).
To summarize, our tool performed well in detecting data
races and redundant synchronizations, despite the use of
imprecise points-to analysis. The proposed executes-before
conditions played a significant role in the performance num-
bers of the tool. It also performs well over ERCatcher in
detecting executes-before pairs.
9 RELATED WORK
We group related work according to work on executes-before,
MHP, and dynamic and bounded model-checking based tech-
niques for EDP programs, and discuss our work in relation
to them.
121393
1394
1395
1396
1397
1398
1399
1400
1401
1402
1403
1404
1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418
1419
1420
1421
1422
1423
1424
1425
1426
1427
1428
1429
1430
1431
1432
1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448
1449
1450Executes Before Analysis ESEC/FSE 2022, 14–18 November, 2022, Singapore
1451
1452
1453
1454
1455
1456
1457
1458
1459
1460
1461
1462
1463
1464
1465
1466
1467
1468
1469
1470
1471
1472
1473
1474
1475
1476
1477
1478
1479
1480
1481
1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500
1501
1502
1503
1504
1505
1506
1507
1508Executes-Before analysis. Hu et al. [ 8], Wu et al. [ 18], and
Salehamadi et al. [ 15] consider the problem of statically deter-
mining executes-before pairs as part of their goal of statically
detecting event-based races in Android apps. Event-races
are conflicting accesses that are not causally ordered in the
application (for instance, we would like an access to hap-
penafter the initialization and a free to happen after an
access). The basic approach in these works is to construct a
finite contextual unfolding of the program and to compute
“happens-before” orderings on this unfolding. They then im-
plicitly infer an executes-before ordering on tasks, by saying
thataexecutes-before bif the end node of every contextual
instance of ais happens-before ordered with the start node
of every contextual instance of b.
To begin with, event races are different from the standard
races we target in this paper: two accesses that run on the
same thread, or two accesses that are well-synchronized by
locks, and hence non-racy, may be event races simply because
there is no fixed order between them. Secondly, this way of
infering executes-before pairs is easily seen to be unsound
for general EDP programs where one has posts in a loop or
recursive posts by tasks. Thus the aim in [ 8,15,18] appears
to be produce a small set of potential event races with a
low false positive rate, with no intention of being sound.
In contrast, we want our execute-before rules to be sound
and effective on the general class of EDP programs, given
the downstream applications of MHP analysis, sound data
race and redundant synchronization detection, and data-flow
analysis.
MHP Analysis. Kahlon et al. [ 9] give a static analysis to
detect races in multi-threaded C programs with asynchronous
function calls which is similar to EDP programs. Their main
focus is on doing a context-sensitive points-to and must-held
lockset analysis for C programs in the presence of function
pointers. The MHP rules they give essentially correspond to
standard fork-join and lock-unlock rules. As demonstrated by
our experiments, the EB-based rules are crucial in obtaining
good precision for event-driven programs. The algorithm by
[1] computes precise MHP information for fork-join asynchro-
nous programs. This is not very useful in our setting (for
example in Android apps) where joins appear to be rarely
used.
Since Android apps are Java-based, one may ask if static
race-detection techniques for Java could be used for Android
apps. While many of the techniques for obtaining a precise set
of conflicting accesses (for example [ 13]) would help here too,
the MHP analysis would not be sound as they do not consider
the task posting feature of EDP programs. Moreover, these
techniques typically drop soundness in favour of precision.
For instance, [ 13] declare statements to be non-MHP even if
two may-held locks may-alias. The nAdroid tool of [ 6] tries
to address task posting in Android apps by converting them
to a standard Java program in which each callback is on a
different thread, and then invoking a Java race detector like
Chord [13]. However, as one would expect, this approach
leads to a lot of false positives.Bounded analysis. DroidRacer [11] uses a bounded model-
checking approach to detect a wide range of event-based races.
The authors give a formal semantics of event driven systems
that considers both thread interleavings and event dispatch.
In another bounded model-checking approach [ 12] implements
aphase-bounding algorithm, to analyze C programs that have
an execution model which supports asynchronous program-
ming, in a tool called BBS, which uses the bounded model
checker CBMC. While such approaches can be expected to
be very precise, they are not scalable and are inherently
unsound.
10 CONCLUSION
In this paper we have given a sound and efficient technique,
with good recall, to statically identify executes-before pairs
in event driven programs. The executes-before information is
shown to be effective in downstream analyses like data race
detection and identifying redundant synchronization blocks
in Android apps.
In future work we would like to explore the use of the
executes-before information in sound detection of event-based
races, as well as in efficient and precise data-flow analysis for
event driven programs.
ACKNOWLEDGEMENTS
The first author is grateful to the University Grants Com-
mission (UGC), New Delhi, India, for providing financial
assistance in the form of a Post-Doctoral Fellowship [F.4-
2/2006 (BSR)/EN/17-18/0039].
131509
1510
1511
1512
1513
1514
1515
1516
1517
1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528
1529
1530
1531
1532
1533
1534
1535
1536
1537
1538
1539
1540
1541
1542
1543
1544
1545
1546
1547
1548
1549
1550
1551
1552
1553
1554
1555
1556
1557
1558
1559
1560
1561
1562
1563
1564
1565
1566ESEC/FSE 2022, 14–18 November, 2022, Singapore R. Pai et al.
1567
1568
1569
1570
1571
1572
1573
1574
1575
1576
1577
1578
1579
1580
1581
1582
1583
1584
1585
1586
1587
1588
1589
1590
1591
1592
1593
1594
1595
1596
1597
1598
1599
1600
1601
1602
1603
1604
1605
1606
1607
1608
1609
1610
1611
1612
1613
1614
1615
1616
1617
1618
1619
1620
1621
1622
1623
1624REFERENCES
[1]Elvira Albert, Samir Genaim, and Pablo Gordillo. 2015. May-
Happen-in-Parallel Analysis for Asynchronous Programs with
Inter-Procedural Synchronization. In Proc. 22nd International
Symposium on Static Analysis (SAS 2015) (LNCS, Vol. 9291) .
Springer, Saint-Malo, France, 72–89.
[2]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden,
Alexandre Bartel, Jacques Klein, Yves Le Traon, Damien Octeau,
and Patrick McDaniel. 2014. FlowDroid: Precise Context, Flow,
Field, Object-Sensitive and Lifecycle-Aware Taint Analysis for
Android Apps. In Proc. 35th ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation (PLDI 2014) .
ACM, Edinburgh, United Kingdom, 259–269.
[3]Nikita Chopra, Rekha Pai, and Deepak D’Souza. 2019. Data Races
and Static Analysis for Interrupt-Driven Kernels. In Proc. 28th
European Symposium on Programming, (ESOP 2019) (LNCS,
Vol. 11423) . Springer, Prague, Czech Republic, 697–723.
[4]Arnab De, Deepak D’Souza, and Rupesh Nasre. 2011. Dataflow
Analysis for Datarace-Free Programs. In Proc. 20th European
Symposium on Programming, (ESOP 2011) (LNCS, Vol. 6602) .
Springer, Saarbr¨ ucken, Germany, 196–215. https://doi.org/10.
1007/978-3-642-19718-5 11
[5]Dawson R. Engler and Ken Ashcraft. 2003. RacerX: effective,
static detection of race conditions and deadlocks. In Proc. 19th
ACM Symposium on Operating Systems Principles (SOSP 2003) .
ACM, Bolton Landing, NY, USA, 237–252. https://doi.org/10.
1145/945445.945468
[6]Xinwei Fu, Dongyoon Lee, and Changhee Jung. 2018. nAdroid:
Statically Detecting Ordering Violations in Android Applications.
InProc. International Symposium on Code Generation and
Optimization (CGO 2018) . ACM, V¨ osendorf / Vienna, Austria,,
62–74. https://doi.org/10.1145/3168829
[7]Alexey Gotsman, Josh Berdine, Byron Cook, and Mooly Sagiv.
2007. Thread-modular shape analysis. In Proc. ACM SIGPLAN
Conference on Programming Language Design and Implementa-
tion (PLDI 2007) . 266–277.
[8]Yongjian Hu and Iulian Neamtiu. 2018. Static Detection of Event-
based Races in Android Apps. In Proc. 23rd International Con-
ference on Architectural Support for Programming Languages
and Operating Systems (ASPLOS 2018) . ACM, Williamsburg,
VA, USA, 257–270.
[9]Vineet Kahlon, Nishant Sinha, Erik Kruus, and Yun Zhang. 2009.
Static data race detection for concurrent programs with asynchro-
nous calls. In Proc. 7th Joint European Software Engineering
Conference and ACM SIGSOFT International Symposium on
Foundations of Software Engineering (ESEC/FSE 2009) . ACM,
Amsterdam, The Netherlands, 13–22.
[10] Ondrej Lhot´ ak and Laurie J. Hendren. 2003. Scaling Java Points-
to Analysis Using SPARK. In Proc. 12th International Confer-
ence on Compiler Construction (CC 2003) . Springer, Warsaw,
Poland, 153–169.
[11] Pallavi Maiya, Aditya Kanade, and Rupak Majumdar. 2014. Race
detection for Android applications. In Proc. ACM SIGPLAN
Conference on Programming Language Design and Implementa-
tion (PLDI 2014) . ACM, Edinburgh, United Kingdom, 316–325.
[12] Rupak Majumdar and Zilong Wang. 2015. Bbs: A Phase-Bounded
Model Checker for Asynchronous Programs. In Proc. 27th In-
ternational Conference on Computer Aided Verification (CAV
2015) (LNCS, Vol. 9206) . Springer, San Francisco, CA, USA,
496–503.
[13] Mayur Naik, Alex Aiken, and John Whaley. 2006. Effective static
race detection for Java. In Proc. ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI
2006) , Michael I. Schwartzbach and Thomas Ball (Eds.). ACM,
Ottawa, Ontario, Canada, 308–319.
[14]Navid Salehnamadi, Abdulaziz Alshayban, Iftekhar Ahmed, and
Sam Malek. 2020. A Benchmark for Event-Race Analysis in
Android Apps. In Proc. 18th International Conference on Mobile
Systems, Applications, and Services (MobiSys 2020) . ACM, New
York, NY, USA.
[15]Navid Salehnamadi, Abdulaziz Alshayban, Iftekhar Ahmed, and
Sam Malek. 2020. ER Catcher: A Static Analysis Framework
for Accurate and Scalable Event-Race Detection in Android. In
Proc. 35th IEEE/ACM International Conference on Automated
Software Engineering (ASE 2020) . IEEE, 324–335.
[16]Abhishek Singh, Rekha Pai, Deepak D’Souza, and Meenakshi
D’Souza. 2019. Static Analysis for Detecting High-Level Races inRTOS Kernels. In Proceedings of the Formal Methods - The Next
30 Years - Third World Congress, FM 2019 (Lecture Notes in
Computer Science, Vol. 11800) , Maurice H. ter Beek, Annabelle
McIver, and Jos´ e N. Oliveira (Eds.). Springer, Porto, Portugal,
337–353. https://doi.org/10.1007/978-3-030-30942-8 21
[17] Nicholas Sterling. 1993. WARLOCK - A Static Data Race Analysis
Tool. In USENIX Winter .
[18] Diyu Wu, Jie Liu, Yulei Sui, Shiping Chen, and Jingling Xue. 2019.
Precise Static Happens-Before Analysis for Detecting UAF Order
Violations in Android. In 12th IEEE Conference on Software
Testing, Validation and Verification, ICST 2019 . IEEE, Xi’an,
China, 276–287.
14