Demystifying Android Non-SDK APIs:Measurement and UnderstandingShishuai Yang1,2, Rui Li1,2, Jiongyi Chen3, Wenrui Diao1,2(/Letter), and Shanqing Guo1,21School of Cyber Science and Technology, Shandong University{shishuai,leiry}@mail.sdu.edu.cn,{diaowenrui,guoshanqing}@sdu.edu.cn,2Key Laboratory of Cryptologic Technology and Information Security of Ministry of Education, Shandong University3National University of Defense Technology,jiongyi_chen@126.comABSTRACTDuring the Android app development, the SDK is essential, whichprovides rich APIs to facilitate the implementations of functional-ities. However, in the Android framework, there still exist plentyof non-SDK APIs that are not well documented. These non-SDKAPIs can be invoked through unconventional ways, such as Javare/f_lection. On the other hand, these APIs are not stable and maybe changed or even removed in future Android versions, providingno guarantee for compatibility. From Android 9 (API level 28),Google began to strictly restrict the use of non-SDK APIs, andthe corresponding checking mechanism has been integrated intothe Android OS.In this work, we systematically study the use and designof Android non-SDK APIs. Notably, we propose four researchquestions covering the restriction mechanism, the present usagestatus, malicious usage, and the API list evolution. To answer thesequestions, we conducted a large-scale measurement based on over200K apps and the source code of three recent Android versions.As a result, a series of exciting and valuable"ndings are obtained.For example, Googleâ€™s restriction is not strong enough and canstill be bypassed. Besides, app developers use only a tiny part ofnon-SDK APIs. Our work provides new knowledge to the researchcommunity and can help researchers improve the Android APIdesigns.CCS CONCEPTSâ€¢Software and its engineeringâ†’Software reliability.KEYWORDSAndroid Non-SDK APIs; API Design and EvolutionACM Reference Format:Shishuai Yang, Rui Li, Jiongyi Chen, Wenrui Diao, and Shanqing Guo. 2022.Demystifying Android Non-SDK APIs: Measurement and Understanding.In44th International Conference on Software Engineering (ICSE â€™22), May21â€“29, 2022, Pittsburgh, PA, USA.ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3510003.3510045Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor pro"t or commercial advantage and that copies bear this notice and the full citationon the"rst page. Copyrights for components of this work owned by others than theauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, orrepublish, to post on servers or to redistribute to lists, requires prior speci"c permissionand/or a fee. Request permissions from permissions@acm.org.ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USAÂ© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.ACM ISBN 978-1-4503-9221-1/22/05...$15.00https://doi.org/10.1145/3510003.35100451 INTRODUCTIONAs the most popular mobile operating system, Android occupiesmore than 72% of the global smartphone market share [9]. At theend of 2020, close to 3.15 million apps are available for users todownload in Google Play [11]. Such a large number of apps bene"tfrom the Android SDK provided by Google. Developers can quicklybuild their apps through the rich APIs provided by the SDK andthen distribute them on the app market.During the app development, the APIs invoked by developers arederived from theandroid.jarlibrary. On the other hand, at the appexecution stage, the APIs referred by apps are dynamically linkedto the implementations of theframework.jarlibrary, a runtimelibrary located in the Android OS. Though bothandroid.jarandframework.jarare constructed based on the source code ofAOSP (Android Open Source Project), a large proportion of APIs inframework.jardo not exist inandroid.jar, callednon-SDK APIs.Non-SDK APIs are not documented in the Android frameworkPackage Index [12], and they could be internal APIs, restricted APIs,or hidden APIs (see Section 2.1 for details). These APIs are not stableand may be changed or even disappear in future Android versions,providing no guarantee for compatibility. Therefore, by design, non-SDK APIs cannot be invoked by developers directly. In practice, thewell-known programming tricks for accessing them are using theJava re/f_lection mechanism or replacing the o#cialandroid.jarwith a custom one containing the non-SDK APIs. Inevitably, usingthe unstable non-SDK APIs will cause compatibility issues, like appcrashes and unexpected behaviors [32, 36, 45].Obviously, the widespread use of non-SDK APIs is not a goodphenomenon. Therefore, from Android 9 (API level 28), Googlebegan to strictly restrict the invocations of non-SDK APIs andencouraged developers to use the public APIs provided by theSDK to build apps [15]. On the OS level, a new API invocationchecking mechanism was introduced, and restricted non-SDK APIlists were provided for reference o#cially. The current solutiontries to push app developers to drop non-SDK APIs gradually, andthe ideal situation is blocking the use of any non-SDK APIs in apps.However, such an ultimate aim cannot be easily reached, and thereis still a lack of up-to-date knowledge on the evolution of Androidnon-SDK APIs. Their usage in the wild and the e$ectiveness ofGoogleâ€™s restriction have not been systematically evaluated.Our Work.In this work, we systematically investigate howdevelopers use non-SDK APIs and the evolution of non-SDK APIs inthe Android framework. Notably, we seek to answer the followingresearch questions:6472022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. Usage of Developers:â‡’RQ1:Can Googleâ€™s restriction on non-SDK APIs be bypassed?â‡’RQ2:What is the present status of using non-SDK APIs in apps?Malware vs. Benign Apps:â‡’RQ3:What are the diï¬€erences in using non-SDK APIs betweenmalicious and benign apps?Evolution of Non-SDK APIs:â‡’RQ4:How did non-SDK APIs evolve in the Android framework?To answer these proposed research questions, we collected226,209 apps from multiple app markets to analyze how and whydevelopers use non-SDK APIs. We also constructed a malwaredataset based on VirusTotal [43] to analyze the di$erences in usingnon-SDK APIs between malicious and benign apps. In addition,through analyzing the source code of recent Android versions (9, 10,and 11), we studied the evolution of non-SDK APIs in the Androidframework. Also, to facilitate the measurement, we built a series oftargeted lightweight analysis tools, such asveridex++for scanningnon-SDK APIs used in apps.Contributions.Here we list the main contributions of this paper:â€¢Large-scale Measurement.Based on over 200K APK"lesand the source code of three recent Android versions, weconducted a multi-dimension large-scale measurement onthe Android non-SDK APIs in the wild.â€¢Systematic Study.We systematically studied the Androidnon-SDK APIs from the aspects of developers, malware, andsystem design. In particular, we proposed four signi"cantresearch questions and answered them with enough support-ing evidence. Here we give the corresponding short answers.(1)The restriction of Google still can be bypassed through thedouble-re/f_lection and call stack breaking techniques.(2)Non-SDK APIs are widely used in apps. The usage purposeis to achieve some app features not supported by the SDK.(3)Non-SDK APIs have been abused by malicious apps, forexample, to dynamically load malicious code.(4)The adjustment of non-SDK APIs is mainly for securityconcerns and/f_ine-grained functionality control.Both OS designers and the software engineering research com-munity can bene"t from this work. (1) For OS designers: Google canfollow our guidelines to reformulate the policy of restricting accessto non-SDK APIs, and change risky APIs with secure alternativeones. (2) For the research community: We provided multi-dimensionlarge-scale measurement data on the Android non-SDK APIs. Itre/f_lects how app developers use APIs, and the analysis results couldhelp design usable APIs in the future.Roadmap.The rest of this paper is organized as follows. Section 2provides the necessary background information to allow readers tounderstand this work better. Section 3 presents the experimentalsetup of this work. Section 4 details our empirical research toanswer the above research questions. Section 5 discusses somemitigation measures to reduce the use of non-SDK APIs and thelimitation of this work. Section 6 introduces related work, andSection 7 concludes this work.2 BACKGROUNDIn this section, we provide the necessary background of AndroidAPIs and focus on non-SDK APIs.2.1 Android APIsAPI is short for application programming interface, which is apre-de"ned function. Developers only need to call the correspond-ing API according to the convention de"ned by the interfacewithout accessing the source code or understanding the detailsof the internal working mechanism. Android APIs provide de-velopers with the ability to access system resources of Androiddevices. For example, they can access external storage through thegetExternalStorageDirectory()API. The collection of theseAPIs constitutes the SDK. The Android SDK is almost completelyclosed and interacts with developers through APIs.When developing apps, the APIs used by app developers areoriginated fromandroid.jar1which is a library in the devel-opment environment. Corresponding toandroid.jarused fordevelopment, there isframework.jar2, a runtime library in theAndroid system that contains more APIs, including non-SDK APIs.The relationship betweenandroid.jarandframework.jarisillustrated in Figure 1. Non-SDK APIs exist widely in the sourcecode, usually in the following three forms, as shown in Listing 1.Internal APIs are not planned to be open to the outside world andare only for internal use by the system. Restricted and hidden APIsare to prevent developers from using some unstable APIs. TheseAPIs may be removed from the Android framework or becomepublic APIs in a speci"c Android version.1// Internal API2packagecom.android.internal.telephony.cdma;3public classSmsMessageextendsSmsMessageBase{4@UnsupportedAppUsage5public staticSmsMessage createFromPdu(byte[]pdu) { }6}7// Restricted API8public classActivityextendsContextThemeWrapper{9private voidinitWindowDecorActionBar() { }10}11// Hidden API12public classTelephonyManager {13/!!Returns a constant indicating the stateof the card apps on the default SIM card.14!@hide!/15@SystemApi16publicSimStateintgetSimApplicationState(){}17}Listing 1: Example of non-SDK APIs.â€¢Internal APIs.These APIs are usually in thecom.android.internalpackage. The source code of all classes under thispackage is invisible and only can be used by system apps.1Location:<SDK-dir>/platforms/android-X/android.jar,Xis the API level.2Location:/system/framework/framework.jar648Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. APIs in        android.jarNon-SDK APIsframework.jarDevelopment environmentRuntime environment
Figure 1: Relationship ofandroid.jarandframework.jar.This package provides the core functions of the Androidsystem and can be used to access some sensitive resources.â€¢Restricted APIs.These APIs are labeled by the Java quali"ersprivateordefault.â€¢Hidden APIs.These APIs are usually clearly marked with@hidein the Java doc.As the Android OS evolves and new versions are released, eachversion is assigned a unique integer identi"er, called the API level.Each Android device runs at exactly one API level, which preciselyindicates the version of the API set that can be invoked by theapps running on the device. When an app is built, it contains thefollowing API level information:(1)minSdkVersionâ€“ the minimum API level required for theAndroid device to run this app. If the API level of the device is lowerthan the value speci"ed byminSdkVersion,t h ed e v i c ew i l lp r e v e n tthe user from installing this app.(2)targetSdkVersionâ€“ the API level of the Android deviceat which this app expects to run. This information indicatesthat the app developer has tested this app against the targetAPI level, and the system should not enable any compatibilitybehaviors to maintain this appâ€™s forward compatibility with thetarget version [17].2.2 Restricted Non-SDK APIsAccess Method.Non-SDK APIs cannot be accessed directlythrough the SDK provided by Google. Before Android 9, whendeveloping an app, the non-SDK APIs could be accessed throughthe following three ways:(1)SDK replacement.Developers can use a customandroid.jar(containing the non-SDK APIs implementations) to replace thedefaultandroid.jar.(2)Java reflection.Through Java re/f_lection [18], developers cancall the methods and properties of any object at runtime, evenif these methods and properties are labeled by the Java quali"erprivate.(3)Java Native Interface (JNI).In the Java layer, developers cancall the native code by de"ning JNI functions. Further, they canaccess SDK and non-SDK APIs through speci"c APIs provided byNDK in the native code [31].However, in Android 9, Google realized the problem of refer-encing a large number of non-SDK APIs in apps and began torestrict the use of non-SDK APIs [15]. The purpose of limitingthe use of non-SDK interfaces is mainly to improve appsâ€™ stabilityfurther, prevent apps from crashing during runtime, and improvethe experience of users and developers [6].Table 1: APK dataset.TypeSourceAmount(total)Amount(/f_iltered)Benign AppsAPKPure, F-Droid, Anzhi,Baidu, Huawei, Xiaomi, ...226,20979,493MalwareVirusTotal10,02910,029Non-SDK API Lists.To minimize the impact of non-SDK APIsrestrictions on development work/f_low, Google classi"ed all APIsin the Android framework into four di$erent lists and targeteddi$erent lists to enforce di$erent restrictions [10], as follows:â€¢blacklistâ€“blocklist. Regardless of thetargetSdkVersionof the app, once the app tries to access the APIs in this list, aruntime crash will be triggered.â€¢greylist-max-xâ€“conditionally blocked. The APIs in this listare usually expressed in the form ofgreylist-max-x, andxis the code name of Android. For example,greylist-max-pmeans that if thetargetSdkVersionof the app is no morethan Android P (i.e., API level 28), the app can still accessthe non-SDK APIs. However, if thetargetSdkVersionisgreater than Android P, a runtime crash will occur when theapp accesses the non-SDK APIs.â€¢greylistâ€“unsupported. The APIs in this list are currentlynot restricted and can still be used in apps.â€¢whitelistâ€“SDK APIs. The APIs in this list can be freelyused and are now supported as part of the o#cially docu-mented Android framework.The APIs in the"rst three lists (i.e., non-SDK APIs) are noto#cially supported and may be changed at any time without notice.3 METHODOLOGY AND DATASETTo answer the proposed research questions, in this section, weillustrate our measurement approach and constructed datasets.3.1 MethodologyAs illustrated in Figure 2, on a high level, our measurement containsthree main steps, as follows:â€¢APK Dataset Construction.First, we constructed the APKdataset used in the study, including benign apps and mali-cious ones.â€¢API List Generation.Based on the source code of AOSP, webuilt an automated app scannerveridex++and generatedthe non-SDK API lists.â€¢Multi-dimension Analysis.To answer the proposed researchquestions, we designed multiple kinds of targeted analysisbased on the data constructed in the previous steps.3.2 App Dataset ConstructionIn this work, the dataset used in our research is divided into twotypes, as shown in Table 1.â€¢Benign Apps.Since Google Play did not provide the appbulk downloading APIs anymore, we selected 18 popularapp markets, including 9Apps, 2265, Anzhi, APKPure, Baidu,DownloadPCAPK, F-Droid, Gfan, Huawei, LapTopPCAPK,649Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. APK Dataset
...APK Filtering
APK Analysis & TestRQ1
RQ4RQ2RQ3Source Code[Android 9-11]Veridex++(app scanner)Combined AnalysisDifferential AnalysisNon-SDK APIs in FrameworkFigure 2: Overview measurement/f_low.Lenovo, LePlay, Leyou, Flyme, PC6, Yingyongbao, Uptodown,and Xiaomi. After de-duplication, a total of 226,209 apps wereobtained.â€¢Malware. We requested access to the VirusTotal dataset [43]and obtained a total of 10,029 malicious samples. VirusTotalclaims that their provided malicious apps have been markedas "malicious" by at least 15 anti-virus engines.Since we focus on the change before & after the launch ofGoogleâ€™s restriction on non-SDK APIs (from API level 28), we"ltered the apps withtargetSdkVersion 27and later versions. The"lter implementation is based on Androguard [1]. Note that we didnot"lter malicious apps because most of theirtargetSdkVersionattributes are less than28.3.3 API List GenerationVeridex++.Starting from Android 9, in order to help developersdetect non-SDK APIs used in their apps, Google provided astatic detection tool â€“veridex[16]. This tool can be built bycompiling the source code of AOSP. To suit apps with di$erenttargetSdkVersionattributes, we built three versions ofveridexbased on the source code of Android 9, 10, and 11 (correspondingto API level 28, 29, and 30).In addition, we integrated these three versions ofveridexintoone tool and added the support of parallel execution for large-scale app scanning, calledveridex++. We utilized this tool to scanapps to obtain the used non-SDK APIs. To further re/f_lect the realintention of developers using non-SDK APIs, we excluded the non-SDK APIs in the o#cial libraries used by apps. These librariesare support libraries required to run apps, usually containingspeci"c characteristics, such as beginning withcom.google.!,com.android.!,androidx.!, andandroid.!.Non-SDK API Lists.Based on the source code of AOSP, throughexecuting the corresponding source code compiling command3,w eobtained all non-SDK APIs corresponding to Android 9, 10, and 11(API level 28, 29, and 30). For Android 12 (API level 31), the sourcecode is currently not available, but Google provides independentnon-SDK API lists for the Android 12 developer preview version.3Command:m out/soong/hiddenapi/hiddenapi-flags.csv3.4 Multi-dimension AnalysisTo answer the proposed four research questions, we designedtargeted analysis solutions. To RQ1, we tested various bypass ap-proaches to validate their e$ectiveness and explored the restrictionimplementation. To RQ 4, the analysis is mainly based on comparingdi$erent versions of non-SDK lists. To RQ 2 and 3, we combinedmultiple data sources to measure the status. The detailed analysismethods are given by research questions in Section 4. Note that datameasurement is only a part of our study, and we also investigatedthe fundamental causes behind these statistics results.4 FINDINGSIn this section, we summarize our empirical research results on theresearch questions proposed in Section 1./lightbulbRQ1. Can Googleâ€™s restriction on non-SDK APIs bebypassed?As mentioned in Section 2.2, there exist some approaches (SDKreplacement, Java re/f_lection, and JNI) to access the non-SDK APIs.Through developing multiple Android apps, on Google Pixel 2with Android 8, 9, 10, and 11, we tested the e$ectiveness of theseapproaches before/after Google launching the restriction.Current Restriction.Based on our tests, the execution results ofthe mentioned bypassing methods on theblacklistare listed inTable 2. We can"nd that, before Google launching the restriction,these approaches can achieve access successfully. The di$erence isthat only the Java re/f_lection approach can access restricted APIs (theprivateanddefaultAPIs) because such an approach can accessany object. After Google launching the restriction, all approachescannot work and will trigger a runtime crash.The execution results on thegreylistand thegreylist-max-xare consistent with Googleâ€™s claim (as mentioned in Section 2.2).That is, there is no accessing restriction to the APIs on thegreylist.When we tried to access the APIs on thegreylist-max-x, ifthetargetSdkVersionof the app is less than or equal to therestricted level, these APIs can be accessed successfully. WhenthetargetSdkVersionof the app is greater than the restrictedlevel, it will cause a runtime crash.Principle of Restriction.It seems that Googleâ€™s strategy ofrestricting non-SDK APIs works well in Android 9 and later versions.We further investigated the implementation of such a restriction. It650Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. Table 2: The eï¬€ectiveness of accessing non-SDK APIs on theblacklist.ApproachesBefore Google launching restrictionAfter Google launching restrictionInternal APIsRestricted APIsHidden APIsInternal APIsRestricted APIsHidden APIsNormal InvocationÃ—Ã—Ã—Ã—Ã—Ã—SDK ReplacementâˆšÃ—âˆšÃ—Ã—Ã—Java Re/f_lectionâˆšâˆšâˆšÃ—Ã—Ã—Java Native InterfaceâˆšÃ—âˆšÃ—Ã—Ã—is deployed on the Android Runtime level. Inside the ART virtualmachine, each API has a set ofaccess_flags/f_lag bits to expressthe attributes of the API [4]. For example, settingaccess_flagsas0x2is to indicate that the API isprivate. There are some reservedbits inaccess_flags, which were not fully utilized before Android9. In Android 9, these reserved bits can be used to identify which listeach API belongs. When an API call triggered by an app at runtimeenters the ART virtual machine, the ART virtual machine will"rstidentify the callerâ€™s identity. If the API call is made by system apps,it will not be restricted. If not, this APIâ€™s restriction level (i.e., thelist that this API belongs to) will be identi"ed according to the valueofaccess_flagsto restrict non-SDK API calls.In the above restriction, the ART virtual machine performs twochecks to prevent non-SDK API invocations: (1) Check the callerâ€™sidentity (system or third-party app). (2) Check the restriction levelof the invoked API.Bypass Restriction.Since the execution logic of Googleâ€™s re-striction needs to check the API callerâ€™s identity,it can still bebypassed by destroying the integrity of the callerâ€™s identity.There are two ways for developers to achieve this goal:(1)Double-reflection.This is a Java way. Using the systemclass to re/f_lect, we can change the callerâ€™s identity to be thesystem [5]. We"rst leverage re/f_lection to obtain the re/f_lectionAPI, called the meta-re/f_lection API. This meta-re/f_lection API isloaded by the system class. Then, we use this meta-re/f_lectionAPI to re/f_lect the call to the non-SDK API. At this time, thecall to the non-SDK API will be considered a system call. Inaddition, there is asetHiddenApiExemptions()API (a non-SDKAPI) under theVMRuntimeclass that can be used to exempt a non-SDK API from the restriction. Combining the double-re/f_lectionwithsetHiddenApiExemptions(), all non-SDK APIs can still beaccessed through the previous approaches (i.e., SDK replacement,Java re/f_lection, and JNI).(2)Call Stack Breaking.This is a JNI way. By breaking the callstack of the API, the ART virtual machine cannot identify thecaller [14]. Speci"cally, through creating a new native thread andthen attaching the new thread to the ART virtual machine, thisnew thread will be on a new call stack. Therefore, within this newthread, when invoking an API, this API call will occur within thenew call stack, and the ART virtual machine will recognize thatthis call is made by a system component, not a third-party app.RQ1 FindingIn Android 9 and later versions, app developers can still usedouble-re/f_lection and call stack breaking to bypass Googleâ€™srestriction and access non-SDK APIs.Table 3: Statistics of apps using non-SDK APIs.Target SDKversionTotal appsApps usingnon-SDK APIsPercentage27(Android 8.1)13,04311,15785.5%28(Android 9)39,83935,23788.4%29(Android 10)21,40719,09889.2%30(Android 11)5,2044,58188.0%Table 4: Statistics of average non-SDK APIs usage per app.Target SDKversionApps usingnon-SDK APIsUsed non-SDKAPIs amountAverageusage /app27(Android 8.1)11,157184,49116.528(Android 9)35,237737,46720.929(Android 10)19,098633,69733.230(Android 11)4,581167,46036.6/lightbulbRQ2. What is the present status of using non-SDKAPIs in apps?Next, we measured the usage of non-SDK APIs in the wild. Asmentioned in Section 3.3, we obtained the usage of non-SDK APIs inapps utilizingveridex++. Through comparing the usage in di$erentapp versions, we analyzed the reaction of developers to Googleâ€™srestriction. Note that, since there is no o#cial non-SDK APIs listsfor API level 27 (before Google launching the restriction), we usedveridex++con"gured for the API level 28 to analyze apps withtargetSdkVersion 27.Overall Statistics.As listed in Table 3,using non-SDK APIs isquite common, with over 85% of apps. Also, the usage percentagesin apps with di$erenttargetSdkVersionare stable, from 85.5% to89.2%, with a slight increase. Table 4 re/f_lects that,to a single app,more and more non-SDK APIs are used a/f_ter Google launchingthe restriction. On average, the apps withtargetSdkVersion27use 16.5 non-SDK APIs, and this number increases to 36.6 ontargetSdkVersion 30.To explore the causes behind the above statistics results, weconducted reverse analysis on various apps, especially thosewith multiple versions. Speci"cally, we decompiled them usingApktool [3] and performed di$erential analysis on their smali"les.Finally, we discovered three main reasons:(1) With the evolution of the Android OS, some APIs used inapps were adjusted to non-SDK API lists, but developers did notreplace these APIs used in their apps in time. For example, someapps end the call by using theendCall()API. This API is a publicAPI in Android 9 and was moved to thegreylistin Android 10.651Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. WDUJHW6GN9HUVLRQWDUJHW6GN9HUVLRQWDUJHW6GN9HUVLRQJUH\OLVWJUH\OLVWPD[[EODFNOLVWFigure 3: Distribution of non-SDK APIs referenced by apps.Table 5: Statistics of unique non-SDK APIs used in apps.Target SDKversionTotal non-SDKAPIs in listsUnique usednon-SDK APIsPercentage28(Android 9)141,7354,3463.1%29(Android 10)285,4634,3981.5%30(Android 11)315,8722,1940.7%(2) Some apps integrated third-party libraries containing non-SDK APIs. These libraries are updated with app updates, whichmay introduce new non-SDK APIs. For example, the appOperaintegratesMintegral[8], a third-party library for advertising SDKaggregation. Its updated version fortargetSdkVersion 29usesthegetBatteryCapacity()API (a non-SDK API) that does notexist in its previous versions.(3) To increase the competitiveness of apps, the developerprovides some unique functions through non-SDK APIs. Forexample, some developers utilize the non-SDK APIs under theBatteryStatsHelperclass to monitor the battery usage of apps.Usage by Lists.Next, we investigated what types of non-SDK APIsare used by app developers. We counted the number of non-SDKAPIs referenced by apps on thegreylist,greylist-max-x, andblacklistwithtargetSdkVersion 28,29, and30, as plotted inFigure 3. It shows that most of the used non-SDK APIs belong to thegreylistbecause thegreylistAPIs have not been totally blockedand will not trigger runtime crashes. Some apps still use the APIson theblacklist, and the proportion is gradually increasing.As listed in Table 5, the proportion of non-SDK APIs used inapps accounts for a small part of the whole non-SDK APIs space(0.7%âˆ¼3.1%), which means thatdevelopers are only interested insome speci/f_ic functions of non-SDK APIs.Usage by Purposes.To further explore the developersâ€™ intentionsof using non-SDK APIs, we located the belonged packages of thesefrequently used non-SDK APIs. According to the core keywords inthe package names extracted by the NLP techniques, we"lteredthe top 10 belonged packages, as shown in Figure 4.â€¢app. This package contains high-level classes encapsulatingthe overall Android application model [21]. For example,developers can obtain theActivityThreadclass instancethroughcurrentActivityThread()(greylist, 61,885 us-ing times) in apps, which is the main thread of the currentapp. Then, they can further obtain the context, package name,and other app information throughActivityThread.â€¢os. This package provides essential system services, messagepassing, and inter-process communication [26]. For example,developers can usegetVolumeList()(greylist, 17,0247KHQXPEHURIXVHGQRQ6'.$3,VFigure 4: Top 10 belonged packages of non-SDK APIs.using time) to return the path of all SD cards mounted on thedevice. However, thegetExternalStorageDirectory()API provided in the SDK can not achieve this.â€¢view. This package provides the classes that expose the basicuser interfaces handling screen layout and interaction withthe user [29]. For example, the developer can count the num-ber of user clicks in apps by hookingmOnClickListener(greylist, 8,355 using times) under themListenerInfo(greylist, 13,604 using times) object.â€¢content. This package contains the classes for accessing andpublishing data on the device [22]. For example, if developersneed to implement the hot patch function, they can invokeaddAssetPath()(greylist, 13,865 using times) to achievethe dynamic resource loading.â€¢widget. This package contains (mostly visual) UI elementsto use on the app screen [30]. For example, when devel-opers retrieve the width and height of a picture, if thispicture does not set the width and height values, the valuesofmMaxWidth(greylist-max-p, 11,952 using times) andmMaxHeight(greylist-max-p, 11,895 using times) will bereturned by default.â€¢net. This package assists network access, beyond the normaljava.net.!APIs [25]. For example, developers can judgethe current GPRS status throughgetMobileDataEnable()(greylist, 14,091 using times). If GPRS is turned on, theycan perform the network tra#c transmission tasks.â€¢telephony. This package provides APIs for monitoring basicphone information [27]. For example, developers can obtainthe neighboring cell information of the device throughgetNeighboringCellInfo()(greylist, 3,796 using times)to locate the current device location.â€¢graphics. This package provides low-level graphics tools,such as canvases, color"lters, points, and rectangles [23].For example, developers usually use custom fonts in apps,and they need to load the font"les and create fonts throughcreateFromFamiliesWithDefault()(greylist, 26,019 us-ing times).â€¢util. This package provides common utility APIs [28].For example, suppose developers need to enable apps toadapt di$erent device screens. In that case, they can use652Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. noncompatWidthPixels(greylist, 20,251 using times) andnoncompatHeightPixels(greylist, 18,472 using times) toobtain the device screen resolution.â€¢media. This package provides the classes that managevarious media interfaces (audio and video) [24]. For example,if developers want to keep audio and video in sync, theyusually need to usegetLatency()(greylist, 2,724 usingtimes) to obtain the trackâ€™s estimated latency.In summary, many popular app features cannot be supported bythe Android SDK APIs, developers have to use non-SDK APIs.RQ2 FindingUsing non-SDK APIs is very common in app developments,even after Google launching the restriction. App developersare only interested in a small part of non-SDK APIs, and thepurposes are using unique features not supported by the SDK./lightbulbRQ3. What are the diï¬€erences in using non-SDKAPIs between malicious and benign apps?ThetargetSdkVersionattributes of all malicious apps in ourdataset are less than 28, so we usedveridex++con"gured for APIlevel 28 to scan them for generating the usage list of non-SDK APIs.The result shows that the usage of non-SDK APIs is widespread. Intotal, 61% of malware (6,150/10,029) used at least one non-SDK API.Following the same approach, we scanned the benign appswithtargetSdkVersion 28. We compared the results and selectedthe top 10 non-SDK APIs used in two kinds of apps for furtheranalysis, as shown in Figure 5. It shows that the non-SDK APIsused by benign apps and malicious apps are quite di$erent, and onlyfour APIs (currentActivityThread(),status_bar_height(),noncompatWidthPixels(), andnoncompatHeightPixels()) ex-ist in both bar charts. Further checking showsmalicious appsabuse non-SDK APIs to achieve malicious purposes. Here wegive two concrete cases.Case Study 1.getService()is the most frequently used non-SDK API in malicious apps, which is designed for obtaining speci"csystem services. In some usage cases, the malicious app invokes thisAPI to obtain theIPhoneSubInfointerface [7], mainly responsiblefor querying SIM card information. Further, withIPhoneSubInfo,this app can use the hidden method â€“getSubscriberId(intsubId)to obtain the IMSI (International Mobile Subscriber Identity)of the SIM card4according tosubId. Finally, this app can guessthe PIN (Personal Identi"cation Number) code of the SIM cardbased on the IMSI. By default, it is usually the last six digits ofthe IMSI or 123456. The PIN code is essential and protects manysigni"cant functions of the SIM card, like network billing andinternal information modi"cation. With the PIN code, the maliciousapp can deduct fees without the userâ€™s consent. Part of the exploitcode is listed in Listing 2.1public staticString getPayPassword(String str,Context context){2if(!TextUtil.notNull(str)){3str = SIMUtil.getIMSI2(context);4}4If the current device is a dual-mode phone, it will return the IMSI of the main card.5returnTextUtil.notNull(str)?str.substring(str.length()-6, str.length()):"123456";6}Listing 2: Exploit case of PIN throughgetService().Case Study 2.Even if both benign and malicious apps use thesame non-SDK API, their purposes are di$erent. For example,currentActivityThread()can be used to obtain the hiddenActivityThreadclass instance. After an app getsActivityThread,all APIs belonging to this class can be invoked by re/f_lection, likethe APIs for obtaining the process name and the app package name.For the malicious usage (as demonstrated in Listing 3), an app canfurther obtain themPackagesinstance inActivityThreadthroughthe re/f_lection and set itsmClassLoaderparameter to a customDexClassLoaderobject referring to a malicious DEX"le (Line 9).When this malicious DEX"le is loaded, the app achieves dynamicmalicious code loading to bypass the anti-virus detection.For benign usage, the primary purpose is to improve theuser experience. In Android 9, if an app uses non-SDK APIs, adialog box will pop up at runtime to indicate that there existsan API compatibility problem. As a solution, the app can set themHiddenApiWarningShownparameter inActivityThreadtotrueto prevent displaying this warning dialog box.1public voidattachBaseContext(Context context){2...3Class <?> cls = Class.forName("android.app.ActivityThread");4Method method = cls.getMethod("currentActivityThread",newClass[0]);5...6DexClassLoader dexClassLoader =newDexClassLoader(String.valueOf(absolutePath2)+"/code.dex",a b s o l u t e P a t h ,"/data/data/"+c o n t e x t . g e t P a c k a g e N a m e ( )+"/lib/",context.getClassLoader().getParent());7Field declaredField2 = Class.forName("android.app.LoadedApk").getDeclaredField("mClassLoader");8declaredField2.setAccessible(true);9declaredField2.set(((WeakReference) ((Map)declaredField.get(invoke)).get(getPackageName())).get(), dexClassLoader);10}Listing 3: Malicious usage ofcurrentActivityThread().RQ3 FindingNon-SDK APIs have been abused for malware to achievemalicious purposes. Even for the same APIs, the usages ofmalicious and benign apps are usually di$erent./lightbulbRQ4. How did non-SDK APIs evolve in the Androidframework?The above analysis shows there are still a large number of appsusing non-SDK APIs, and intrusive changes to non-SDK APIs willcause extensive app crashes. Therefore, it is essential to understand653Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. QXPEHURIXVLQJWLPHVE%HQLJQ$SSVQXPEHURIXVLQJWLPHVD0DOLFLRXV$SSVFigure 5: Top 10 non-SDK APIs used by malicious and benign apps.7KHQXPEHURI$3,VFigure 6: Changes in the amount of non-SDK APIs.the evolution of non-SDK APIs in the Android framework. Asmentioned in Section 3.3, we obtained the non-SDK API lists ofAndroid 9, 10, 11, and 12 (API level 28, 29, 30, and 31). Further, weconducted a series of API list evolution analyses.Restricted APIs Amount.The number of APIs in each list of thefour versions is shown in Figure 6. It shows that Android 9 hasfewer restricted APIs than other versions, especially the APIs on theblacklist. However, the APIs on theblacklisthave increasedsigni"cantly in later versions, especially from Android 9 to 10,which has increased by about 16 times. The number of APIs inother lists has remained relatively stable. Since Android 9 is the"rst version that Google began to implement restrictions on, ifmany APIs are directly added to theblacklist, it will cause APIcompatibility issues for a large number of apps.API List Adjustments.To characterize the evolution of non-SDKAPI lists, we recorded the changes in the number of APIs in theselists between the adjacent Android versions, as shown in Table 6.In the adjustment of restricted API lists: (1) If a new non-SDKAPI is added to the Android framework, it will be highly likelyadded to theblacklistdirectly. The reason is that these newlyadded APIs have not been used by any apps, which can directlyserve the purpose of restricting developersâ€™ access. (2) The APIs ontheblacklistandgreylist-max-xare more likely to be removedfrom the Android framework than thegreylist. It is because thesetwo types of non-SDK APIs are used relatively infrequently. Also,their functions are more relevant to user privacy. For example,notifyLocationChanged()is on theblacklistin Android 10and was removed in Android 11. Using this API can notify the celllocation change of the device. (3) Only a few APIs will be movedto the list with lower restriction levels or become public APIs. TheAPIs are usually moved to the list with the adjacent restrictionlevel. For example, more APIs on thegreylistare moved to thegreylist-max-xrather than theblacklist. Since the APIs onthegreylistare still used by apps, moving them directly to theblacklistwill cause numerous app crashes at runtime. Movingthem to thegreylist-max-xnot only ensure that apps using theseAPIs can still run on old devices, but also achieve the purpose ofrestricting the use of these APIs on the latest version of devices.Reasons of Adjustments.We further explored that, in the listadjustment, why some APIs are further restricted (e.g.,greylistâ†’greylist-max-x), and some APIs are loosened to the lowerrestriction lists (e.g.,greylistâ†’whitelist). As a preliminary,we"rst investigated which kinds of non-SDK APIs were adjusted.Through"ltering the keywords of names of packages that eachnon-SDK API belongs to, we obtained the most frequently adjustedfeatures (packages) and the number of associated APIs in the processof list adjustment, as shown in Table 7. It shows that the APIsbelonging to the Android telephony framework are more likely tobe a$ected. Telephony is related to various system core services,such as CALL services, SMS services, and APN access points.For the case of enhancing the restriction, the"rst reason is thesecurity concern. These APIs may bypass privacy protection andinfringe user privacy. For example,deleteMessageFromIcc()ison thegreylistin Android 10 and was moved to theblacklistinAndroid 11. Text messages are stored on the SIM card by default, noton the Android device. Using this API can delete all text messagesstored on the SIM card, causing permanent loss of user data. Also,for the same reason, various newly added telephony-related APIsare directly added to theblacklist.Besides, adding some APIs to the restricted list can achieve amore/f_ine-grained access control of the APIâ€™s functions. Forexample,finish()is an overloaded function in theandroid.app.Activityclass used to close the activity and has two declarations654Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. Table 6: Changes of the amount of non-SDK APIs by list type between adjacent Android versions.List ChangesAndroid 9â†’Android 10Android 10â†’Android 11Android 11â†’Android 12newâ†’blacklist145,10353,80238,954newâ†’greylist-max-x52728newâ†’greylist16,96612630blacklistâ†’remove1,84717,97914,790greylist-max-xâ†’remove15,1954,9121,573greylistâ†’remove1,478488506blacklistâ†’greylist-max-x000blacklistâ†’greylist0236blacklistâ†’whitelist011997greylist-max-xâ†’blacklist117greylist-max-xâ†’greylist12140greylist-max-xâ†’whitelist1118323greylistâ†’blacklist16885314greylistâ†’greylist-max-x7918953,098greylistâ†’whitelist1979810whitelistâ†’blacklist1511whitelistâ†’greylist-max-x000whitelistâ†’greylist46770â€ :newrepresents the number of APIs newly added to the list, andremoverepresents the number of APIs removed from the list.Table 7: The most aï¬€ected features during the list change process and the number of related APIs.List ChangesAndroid 9â†’Android 10Android 10â†’Android 11Android 11â†’Android 12newâ†’blacklist(telephony, 25,218)(telephony, 7,690)(telephony, 6,759)newâ†’greylist-max-x(telephony, 1)(app, 5)(view, 12)newâ†’greylist(apache, 8,496)(telephony, 60)(libcore, 13)blacklistâ†’remove(media, 395)(telephony, 5,138)(telephony, 2,727)greylist-max-xâ†’remove(media, 2,124)(net, 567)(app, 234)greylistâ†’remove(util, 351)(telephony, 175)(provider, 108)blacklistâ†’greylist-max-xN/AN/AN/Ablacklistâ†’greylistN/A(telephony, 1)(bluetooth, 35)blacklistâ†’whitelistN/A(telephony, 45)(telephony, 30)greylist-max-xâ†’blacklist(system, 1)(telephony, 1)(media, 4)greylist-max-xâ†’greylist(os, 53)(telephony, 3)N/Agreylist-max-xâ†’whitelist(media, 21)(telephony, 29)(graphics, 5)greylistâ†’blacklist(hardware, 55)(app, 127)(graphics, 10)greylistâ†’greylist-max-x(telephony, 125)(R, 702)(telephony, 915)greylistâ†’whitelist(media, 75)(util, 58)(media, 3)whitelistâ†’blacklist(os, 11)(os, 1)(telephony, 1)whitelistâ†’greylist-max-xN/AN/AN/Awhitelistâ†’greylist(util, 107)(provider, 7)N/Aâ€ : N/A means that no features are a$ected.(with parameters or not), as shown in Listing 4. Note thatfinish()is a publicly accessible API. However,finish(int finishTask)belongs to thegreylistbefore Android 12 and was moved to thegreylist-max-xin Android 12. In fact, the internal implemen-tation offinish()callsfinish(int finishTask)and passes ina default parameter â€“DONT_FINISH_TASK_WITH_ACTIVITY(Line4-6), which means closing the activity without closing the stack.When the activity to be closed is not at the bottom of the stack, ifthe app callsfinish(int finishTask)rather thanfinish()andpasses in theFINISH_TASK_WITH_ROOT_ACTIVITparameter, thisapp will exit unexpectedly.1public static final intDONT_FINISH_TASK_WITH_ACTIVITY = 0;2public static final intFINISH_TASK_WITH_ROOT_ACTIVITY = 1;3public static final intFINISH_TASK_WITH_ACTIVITY = 2;4public voidfinish(){5finish(DONT_FINISH_TASK_WITH_ACTIVITY);6}7private voidfinish(intfinishTask){ ... }Listing 4: Example of the API being further restricted.655Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. The restriction onfinish(int finishTask)(and other similarAPIs) is bene"cial to less experienced developers, preventingthem from passing in wrong parameters and causing unexpectedconsequences.The main reason for loosening restrictions may be the requestsfrom app developers. Since some developers must use the restrictedAPIs to implement speci"c functions, they applied to Google forreleasing some APIs (through the Android Issue Tracker [13]). Onthe other hand, it is also related to the new features added in thenew versions of the Android OS. For example, from Android 9 to 10,many media-related APIs under theandroid.media.tvpackagewere moved from thegreylisttowhitelist. The correspondingis that, in Android 10, Google brought many improvements andchanges to the Android TV, including security & privacy, media &graphics, dynamic partitions, and energy consumption/doze [2].RQ4 FindingIn the evolution of Android OS, the non-SDK API lists wereadjusted frequently. The reasons for enhancing API restrictionsare mainly for security concerns and"ne-grained control.The reasons for loosening API restrictions are mainly due todeveloper requests and newly added features.5 DISCUSSIONSIn this section, we discuss some limitations of this work and givesuggestions for reducing the use of non-SDK APIs and improvingthe e#ciency of malware detection.Limitations.In this study, our basic data of non-SDK APIs usedin apps relies on theveridextool provided by Google. However,veridexcannot detect JNI calls, and the detection of re/f_lection isnot 100% accurate. On the other hand, dynamic analysis is not asuitable solution for the massive number of apps in our datasetdue to e#ciency and coverage issues. Therefore, compared withthe dynamic analysis approach, we developedveridex++based onveridex, a static analysis solution for the large-scale app scanning.We usedveridex++con"gured for API level 28 to scan appswithtargetSdkVersionattributes less than 28. It may cause falsepositives because, for some non-SDK APIs in API level 28, whenthese apps used them, these APIs might still be SDK APIs. For thetop 10 non-SDK APIs used by malicious apps, we manually excludedsuch false positives.The number of apps withtargetSdkVersion 30is relativelysmall (i.e., 5,204) because it is the latest Android API level (whenconducting this work), and the mainstream Android devices on themarket are still Android 10 (API level 29). Therefore, consideringthe future versions of released apps, some basic data may/f_luctuate,like Table 3, Table 4, and Table 5. Also, to further understandthe developersâ€™ intentions of using non-SDK APIs, large-scalesurveys/interviews on developers could be conducted.Restriction Suggestions.According to the above analysis, mostdevelopers may ignore Googleâ€™s restriction, resulting in an increasein using non-SDK APIs in recent versions of apps. Here we proposesome suggestions for balancing the requirements of developers andapp compatibility.(1)For app development, when developers invoke non-SDKAPIs, Android Studio should prompt a reminder about theconsequence of accessing the API or provide an alternativeto the public APIs with similar functions. Also, an integritycheck mechanism of SDK should be added to Android Studio.So it can detect whether theandroid.jarlibrary has beenreplaced and resets it to the o#cial version.(2)For app runtime, Google needs to further cut o$the wayto access non-SDK APIs, such as adding a mechanism toidentify double-re/f_lection calls. Also, at the native layer, appsshould be prohibited from creating new native threads toprevent them from bypassing the restriction by breaking thefunction call stack.(3)For API design, the widely used non-SDK APIs should bereleased or redesigned for public usage. Google could usethe API usage data and the developer requests as references.Malware Detection.Malware detection is a popular topic in themobile security research community. The current mainstreammalware detection technology is to build a classi"er throughmachine learning based on a series of features extracted from apps,such as requested permissions and API calls [19,34]. The accuracyof identifying malware basically depends on the extracted features.That is, the selected features should have signi"cant di$erencesbetween malicious and benign apps. This research shows that non-SDK APIs meet this requirement because there exist signi"cant APIusage di$erences (see Figure 5). In addition, the app behaviors areentirely di$erent for the same APIs, and the corresponding APIcall sequences are also entirely di$erent. Therefore, we recommendusing non-SDK APIs as an essential feature when building malwareclassi"ers to improve malware detection accuracy.6 RELATED WORKThe Android API has been studied by plenty of previous work.However, most research focused on public APIs, and rare worknoticed the non-SDK APIs in Android. In this section, we reviewthe related work on Android APIs.Non-SDK APIs.The most relevant work to non-SDK API wasconducted by Li et al. [35]. They empirically investigated theevolution of Android internal APIs and hidden APIs from theaspects of signi"cance, impact, and adoption. However, their workwas based on early versions of Android (â‰¤6.0) before Googledeployed the restriction on non-SDK APIs. The relevant knowledgeneeds to be updated to re/f_lect the current status. Also, at that time,since Google did not provide the complete list of non-SDK APIs ateach API level, the corresponding data analysis may not be accurate(may exist false positive or false negative).Unlike the above research, in this paper, we mainly focus on theusage of non-SDK APIs in the Android framework after Googledeployed access restrictions on non-SDK APIs. To the best of ourknowledge, we are the"rst to conduct a systematic study of non-SDK APIs after Google implemented the restriction.API Evolution.Various previous work studied the evolutionof Android APIs. McDonnell et al. [42] found that Android isevolving fast at a rate of 115 API updates per month on average.However, developers cannot adopt these newly added APIs in656Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. time. Linares-VÃ¡squez et al. [38] analyzed the relation betweenthe success of apps and the change- and fault-proneness of theunderlying APIs. Their study shows that less fault- and change-prone APIs contribute more to appsâ€™ successes. In addition, they alsoinvestigated a relationship between API changes and developersâ€™reactions [39]. Li et al. [37] performed an exploratory study ofdeprecated Android APIs based on a prototype research tool calledCDA and discovered that the Android framework codebase isregularly cleaned up from deprecated APIs in a short period. Morerecently, Liu et al. [40] conducted an empirical study to characterizesilently-evolved methods across ten versions of the Android API.These methods are functions whose behavior might have changed,but the corresponding documentation did not change accordingly.Compatibility Issues.API evolution causes compatibility issuesin Android apps [44]. Li et al. [36] proposed CiD to detect API-related compatibility issues based on an API lifecycle model.He et al. [32] studied compatibility problems induced by theevolution of Android OS. They developed IctApiFinder to discoverincompatible API usage issues in Android apps based on inter-procedural data-/f_low analysis. Huang et al. [33] identi"ed thecallback compatibility issues induced by callback API evolution anddevised Cider to detect this kind of issue. Cai et al. [20] empiricallyinvestigated the app incompatibilities that are actually exercisedat runtime and found that runtime incompatibilities are mostlydue to API changes during SDK evolution. Xia et al. [45] focusedon the Android developersâ€™ reactions to evolution-induced APIcompatibility issues. Their research shows that developers do notwant to provide alternative implementations for incompatible APIinvocations. More recently, Mahmud et al. [41] introduced ACID,which leverages API di$erences and static analysis of source code ofAndroid apps to detect compatibility issues caused by API evolution.7 CONCLUSIONSince Android 9, Google began to restrict access to non-SDK APIsto improve appsâ€™ stability. In this paper, we conducted the"rstlarge-scale study on the use and design of non-SDK APIs. We"rst explored the implementation of Googleâ€™s restriction. Then,we investigated the present usage trend and purposes of non-SDKAPIs. Next, we compared their usage in malicious apps. Finally,we characterized the evolution of non-SDK APIs in the Androidframework. A series of exciting and valuable"ndings are obtained,which provides new knowledge to the research community and canhelp researchers improve Android APIsâ€™ design.ACKNOWLEDGEMENTSWe thank the anonymous reviewers for their insightful comments.This work was partially supported by National Natural ScienceFoundation of China (Grant No. 61902148) and Qilu Young ScholarProgram of Shandong University.REFERENCES[1]2021.Androguard. Retrieved August 24, 2021 from https://github.com/androguard/[2]2021.Android 10 on Android TV. Retrieved August 24, 2021 from https://android-developers.googleblog.com/2019/12/android-10-on-android-tv.html[3]2021.Apktool. Retrieved August 24, 2021 from https://ibotpeaches.github.io/Apktool/[4]2021.Dalvik Executable format. Retrieved August 24, 2021 from https://source.android.com/devices/tech/dalvik/dex-format[5]2021.FreeRe/f_lection. Retrieved August 24, 2021 from https://github.com/tiann/FreeReflection/[6]2021.Improving Stability by Reducing Usage of non-SDK Interfaces. RetrievedAugust 24, 2021 from https://android-developers.googleblog.com/2018/02/improving-stability-by-reducing-usage.html[7]2021.IPhoneSubInfo. Retrieved August 24, 2021 from https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl[8]2021.Mintegral SDK. Retrieved August 24, 2021 from https://www.mintegral.com/cn/sdk/[9]2021.Mobile Operating System Market Share Worldwide - March 2021. RetrievedAugust 24, 2021 from https://gs.statcounter.com/os-market-share/mobile/[10]2021.Non-SDK API lists. Retrieved August 24, 2021 from https://developer.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces#list-names[11]2021.Number of Mobile Apps in Leading App Stores Worldwide in 2020. RetrievedAugust 24, 2021 from https://"nancesonline.com/number-of-apps-in-leading-app-stores/[12]2021.Package Index.R e t r i e v e d A u g u s t 2 4 , 2 0 2 1 f r o m h t t p s : / / d e v e l o p e r . a n d r o i d .com/reference/packages[13]2021.Public Java APIs Requests.R e t r i e v e d A u g u s t 2 4 , 2 0 2 1 f r o m h t t p s : / / i s s u e t r acker.google.com/issues?q=Public%20Java%20APIs%20Requests[14]2021.RestrictionBypass. Retrieved August 24, 2021 from https://github.com/ChickenHook/RestrictionBypass/[15]2021.Restrictions on non-SDK interfaces. Retrieved August 24, 2021 from https://developer.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces[16]2021.Test using the veridex tool.R e t r i e v e d A u g u s t 2 4 , 2 0 2 1 f r o m h t t p s : / / d e v e l oper.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces#test-veridex-tool[17]2021.Understanding Android API levels. Retrieved August 24, 2021 from https://docs.microsoft.com/en-us/xamarin/android/app-fundamentals/android-api-levels/[18]2021.Using Java Re/f_lection.R e t r i e v e d A u g u s t 2 4 , 2 0 2 1 f r o m h t t p s : / / w w w . o r a c l e.com/technical-resources/articles/java/javare/f_lection.html[19]Daniel Arp, Michael Spreitzenbarth, Malte Hubner, Hugo Gascon, and KonradRieck. 2014. DREBIN: E$ective and Explainable Detection of Android Malwarein Your Pocket. InProceedings of the 21st Annual Network and Distributed SystemSecurity Symposium (NDSS), San Diego, California, USA, February 23-26, 2014.[20]Haipeng Cai, Ziyi Zhang, Li Li, and Xiaoqin Fu. 2019. A Large-Scale Study ofApplication Incompatibilities in Android. InProceedings of the 28th ACM SIGSOFTInternational Symposium on Software Testing and Analysis (ISSTA), Beijing, China,July 15-19, 2019.[21]Google. 2021.android.app. Retrieved August 24, 2021 from https://developer.android.com/reference/android/app/package-summary[22]Google. 2021.android.content.R e t r i e v e d A u g u s t 2 4 , 2 0 2 1 f r o m h t t p s : / / d e v e l o p e r .android.com/reference/android/content/package-summary[23]Google. 2021.android.graphics. Retrieved August 24, 2021 from https://developer.android.com/reference/android/graphics/package-summary[24]Google. 2021.android.media. Retrieved August 24, 2021 from https://developer.android.com/reference/android/media/package-summary[25]Google. 2021.android.net. Retrieved August 24, 2021 from https://developer.android.com/reference/android/net/package-summary[26]Google. 2021.android.os. Retrieved August 24, 2021 from https://developer.android.com/reference/android/os/package-summary[27]Google. 2021.android.telephony. Retrieved August 24, 2021 from https://developer.android.com/reference/android/telephony/package-summary[28]Google. 2021.android.util. Retrieved August 24, 2021 from https://developer.android.com/reference/android/util/package-summary[29]Google. 2021.android.view. Retrieved August 24, 2021 from https://developer.android.com/reference/android/view/package-summary[30]Google. 2021.android.widget.R e t r i e v e d A u g u s t 2 4 , 2 0 2 1 f r o m h t t p s : / / d e v e l o p e r .android.com/reference/android/widget/package-summary[31]Google. 2021.JNI tips.R e t r i e v e d A u g u s t 2 4 , 2 0 2 1 f r o m h t t p s : / / d e v e l o p e r . a n d r o id.com/training/articles/perf-jni[32]Dongjie He, Lian Li, Lei Wang, Hengjie Zheng, Guangwei Li, and Jingling Xue.2018. Understanding and Detecting Evolution-Induced Compatibility Issues inAndroid Apps. InProceedings of the 33rd ACM/IEEE International Conference onAutomated Software Engineering (ASE), Montpellier, France, September 3-7, 2018.[33]Huaxun Huang, Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2018. Understandingand Detecting Callback Compatibility Issues for Android Applications. InProceedings of the 33rd ACM/IEEE International Conference on Automated SoftwareEngineering (ASE), Montpellier, France, September 3-7, 2018.[34]ElMouatez Billah Karbab, Mourad Debbabi, Abdelouahid Derhab, and DjedjigaMouheb. 2018. MalDozer: Automatic Framework for Android Malware DetectionUsing Deep Learning.Digital Investigation24 (2018), S48â€“S59.[35]Li Li, TegawendÃ© F. BissyandÃ©, Yves Le Traon, and Jacques Klein. 2016. AccessingInaccessible Android APIs: An Empirical Study. InProceedings of the 32nd IEEE657Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. International Conference on Software Maintenance and Evolution (ICSME), Raleigh,NC, USA, October 2-7, 2016.[36]Li Li, TegawendÃ© F. BissyandÃ©, Haoyu Wang, and Jacques Klein. 2018. CiD:Automating the Detection of API-Related Compatibility Issues in Android Apps.InProceedings of the 27th ACM SIGSOFT International Symposium on SoftwareTesting and Analysis (ISSTA), Amsterdam, The Netherlands, July 16-21, 2018.[37]Li Li, Jun Gao, TegawendÃ© F. BissyandÃ©, Lei Ma, Xin Xia, and Jacques Klein. 2020.CDA: Characterising Deprecated Android APIs.Empirical Software Engineering25, 3 (2020), 2058â€“2098.[38]Mario Linares-VÃ¡squez, Gabriele Bavota, Carlos Bernal-CÃ¡rdenas, Massimil-iano Di Penta, Rocco Oliveto, and Denys Poshyvanyk. 2013. API Change andFault Proneness: A Threat to the Success of Android Apps. InProceedings of the9th Joint Meeting of the European Software Engineering Conference and the ACMSIGSOFT Symposium on the Foundations of Software Engineering (ESEC/FSE), SaintPetersburg, Russian Federation, August 18-26, 2013.[39]Mario Linares-VÃ¡squez, Gabriele Bavota, Massimiliano Di Penta, Rocco Oliveto,and Denys Poshyvanyk. 2014. How Do API Changes Trigger Stack Over/f_lowDiscussions? A Study on the Android SDK. InProceedings of the 22nd InternationalConference on Program Comprehension (ICPC), Hyderabad, India, June 2-3, 2014.[40]Pei Liu, Li Li, Yichun Yan, Mattia Fazzini, and John C. Grundy. 2021. Identifyingand Characterizing Silently-Evolved Methods in the Android API. InProceedingsof the 43rd IEEE/ACM International Conference on Software Engineering: SoftwareEngineering in Practice (ICSEâ€“SEIP), Madrid, Spain, May 25-28, 2021.[41]Tarek Mahmud, Meiru Che, and Guowei Yang. 2021. Android Compatibility IssueDetection Using API Di$erences. InProceedings of the 28th IEEE InternationalConference on Software Analysis, Evolution and Reengineering (SANER), Honolulu,HI, USA, March 9-12, 2021.[42]Tyler McDonnell, Baishakhi Ray, and Miryung Kim. 2013. An Empirical Study ofAPI Stability and Adoption in the Android Ecosystem. InProceedings of the 29thIEEE International Conference on Software Maintenance (ICSM), Eindhoven, TheNetherlands, September 22-28, 2013.[43]VirusTotal. 2021.VirusTotal. Retrieved August 24, 2021 from https://www.virustotal.com/[44]Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2016. Taming Android Fragmenta-tion: Characterizing and Detecting Compatibility Issues for Android Apps. InProceedings of the 31st IEEE/ACM International Conference on Automated SoftwareEngineering (ASE), Singapore, September 3-7, 2016.[45]Hao Xia, Yuan Zhang, Yingtian Zhou, Xiaoting Chen, Yang Wang, Xiangyu Zhang,Shuaishuai Cui, Geng Hong, Xiaohan Zhang, Min Yang, and Zhemin Yang. 2020.How Android Developers Handle Evolution-induced API Compatibility Issues: ALarge-scale Study. InProceedings of the 42nd International Conference on SoftwareEngineering (ICSE), Seoul, South Korea, 27 June - 19 July, 2020.
658Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:14:34 UTC from IEEE Xplore.  Restrictions apply. 