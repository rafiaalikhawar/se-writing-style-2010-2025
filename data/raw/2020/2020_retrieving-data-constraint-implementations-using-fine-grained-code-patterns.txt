Retrieving Data Constraint Implementations
Using Fine-Grained Code Patterns
Juan Manuel Florez
Jonathan Perry
Shiyi Wei
Andrian Marcus
{jflorez,jperry,swei,amarcus}@utdallas.edu
The University of Texas at Dallas
Richardson, Texas, USA
ABSTRACT
Business rules are an important part of the requirements of soft-
waresystemsthataremeanttosupportanorganization.Theserules
describetheoperations,definitions,andconstraintsthatapplyto
the organization. Within the software system, business rules are
often translated into constraints on the values that are required or
allowed for data, called data constraints. Business rules are subject
to frequent changes, which in turn require changes to the corre-
sponding data constraints in the software. The ability to efficiently
andpreciselyidentifywheredataconstraintsareimplementedin
thesourcecodeisessentialforperformingsuchnecessarychanges.
In this paper, we introduce Lasso, the first technique that au-
tomatically retrieves the method and line of code where a given
dataconstraintisenforced.Lassoisbasedontraceabilitylinkre-
covery approaches and leverages results from recent research that
identified line-of-code level implementation patterns for data con-
straints. We implement three versions of Lasso that can retrieve
data constraint implementations when they are implemented with
any one of 13 frequently occurring patterns. We evaluate the three
versions on a set of 299 data constraints from 15 real-world Java
systems, and find that they improve method-level link recovery
by 30%, 70%, and 163%, in terms of true positives within the first
10 results, compared to their text-retrieval-based baseline. More
importantly, the Lasso variants correctly identify the line of code
implementing the constraint inside the methods for 68% of the 299
constraints.
CCS CONCEPTS
â€¢Software and its engineering â†’Software evolution ;Design
patterns; Requirements analysis; Software maintenance tools.
KEYWORDS
businessrule, dataconstraint, traceabilitylink recovery, empirical
study, fine-grained traceability, code pattern
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510167ACM Reference Format:
Juan Manuel Florez, Jonathan Perry, Shiyi Wei, and Andrian Marcus. 2022.
Retrieving Data Constraint Implementations Using Fine-Grained Code Pat-
terns. In44th International Conference on Software Engineering (ICSE â€™22),
May 21â€“29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 13 pages.
https://doi.org/10.1145/3510003.3510167
1 INTRODUCTION
Business rules describe the operations, definitions, and constraints
thatapplytoanorganization[ 68].Whenasoftwaresystemisde-
veloped to support such an organization, these rules inform the
creation of the software requirements. However, business rules are
known to change unpredictably. For example, the Reserve Require-
ments for Depository Institutions (Â§204.2(d)(2), Regulation D) of
TheFederalReserve[ 8]limitswithdrawalsoroutgoingtransfers
from a savings or money market account to no more than six such
transactionsperstatementperiod.Thisrestrictionwastemporarily
lifted in 2020 [ 7], making the number of transfers no longer lim-
ited. Performing this change on a system subject to this regulation
requiresknowingthesourcecodeelementsthatareresponsiblefor
implementing this rule.
Many business rules (and other type of requirements) are trans-
latedwithinthesoftwaresysteminto dataconstraints [27,67,68].
Data constraints specify what values are allowed or required for
thegivendata.Intheexampleabove,therelevantdataarethenum-
ber of monthly withdrawals and the number of monthly transfers
from an account (savings or money market). The constraint states
that the sum of the values of these two data elements should be
less than or equal to six. The two data elements are defined in the
code (we call these data definition statements ) and the constraint is
checked in some other part of the code (which we call constraint
enforcing statement ). Developers implementing the changes caused
by the new rule will have to find the data constraint enforcing
statements, and they could benefit from tool support, as is the case
in any software change process [12, 13].
Recent research by Yang et al.[69] explored the implementation
of data constraints in database-backed web applications. They dis-
covered that developers struggle with maintaining consistent data
constraintsandwithcheckingthemacrossdifferentcomponents
and versions of their web applications. This observation under-
scores the need for tool support when it comes to maintaining the
implementations of data constraints in particular.
Inthispaper,weproposeandevaluateanewapproach,Lasso
(LocatingdAtaconStraintsin SourcecOde),thatcanautomatically
18932022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Juan Manuel Florez, Jonathan Perry, Shiyi Wei, and Andrian Marcus
identifytheenforcingstatementsforagivendataconstraintina
software. Lasso is designed as an extensible framework (Section 3).
Theframeworkisbuiltontopofastandard traceabilitylinkrecovery
tool(i.e.,for a textual input, it returns a list of relevant methods
fromthecode),whichisreplaceableandcustomizable.Themain
novelty is that Lasso formalizes and uses structural information
aboutdataconstraintimplementationsoriginatingfromprevious
work on the subject [ 27] (Section 2). With this information, Lasso
is able to improve the method-level retrieval performance of the
underlyingtraceabilitylinkrecoverytool.Moreimportantly,Lasso
is able to pinpoint the lines of code where a constraint is imple-
mented.Theabilitytotracedataconstraintstoline-of-codelevel
implementations sets Lasso apart among traceability link recovery
approaches,whichlargelyoperateatcoarsergranularitylevels(i.e.,
file, class, method) [9].
Florez et al . [27]conducted an empirical study and identified
30 data constraint implementation patterns used by developers
inJavacode.Theimplementationpatternsdescribethestructure
of the implementations, and are presented in a pattern catalog.
We convert the pattern descriptions into context-free grammar
production rules. These productionsrules are then used by Lasso
to identify lines of code that exhibit the implementation patterns.
WeinstantiateLassowithdetectorsfor13ofthemostcommonly
occurringpatternsfromthepatterncatalog,andrefertothisver-
sionofLassoasLasso-13.Withthesecomponents,wecreatethree
instances of Lasso, i.e.,Lasso-13Luc which uses a Lucene-based
traceability tool [ 48] (BM25); Lasso-13VSM which uses the Vector
Space Model [ 32]; and Lasso-13LSI which uses an LSI-based trace-
abilitytool[ 22].WeevaluatethesethreeinstancesofLasso-13and
compare the performance of each with their respective traceabilitytool as the baseline. Specifically, we compare their performance on
retrieving methods implementing 299 constraints in 15 real-world
Javasystems.163oftheseconstraintsarefrompreviousresearch
[27], while 136 are new to this paper. We found that the Lasso-
13Luc, Lasso-13VSM, and Lasso-13LSI outperform their baselines
by30%,70%,and163%(intermsoftruepositivesretrievedinthe
first10results),respectively.Inaddition,weevaluateLassoâ€™sac-curacy in pinpointing the lines of code enforcing the constraints
withintherelevantmethods.WefoundthatLasso-13ranksthecor-
rect enforcing statements accurately for 79% of the 299 constraints
(68% at rank 1 and 11% at rank 2-3).
The main contributions of the paper are:
â€¢A novel approach and framework that, for a given data con-
straint, automatically finds the method and lines of code
where it is implemented.
â€¢Anewannotateddatasetof136dataconstraintsandtheir
implementations, from 7 real-world Java systems, which
complements data from existing research.
â€¢TheresultsoftheevaluationoftwoLassoinstancesandtwo
baseline approaches.
The data, code, and results are in our replication package [28].
2 BACKGROUND
Inthispaper,weusethe constraintimplementationpattern (CIP)cat-
alog defined by Florez et al.[27]. To make the paper self-contained,
we summarize here the most important information we use.Table 1: CIP Catalog [27] Excerpt.
CIP name: binary-comparison.
Description: Two values are compared using an operator such as
equals,does not equal, greater than, etc.
Statement type: Expression.
Parts:{variable1,opâˆˆ{>,â‰¥,<,â‰¤,=,â‰ },variable2 }
Example: Instance: if(maxFreq >wave.getNyquist())
Parts:{maxFreq,>,wave.getNyquist() }.
CIP name: if-chain.
Description: A chain of ifs is used like a switch on a field, checking
against the possible values of the variable.
Statement type: If statement.
Parts:{variable}
Example: Instance: if(onset ==EMERGENT){...}elseif(onset ==
IMPULSIVE){...}elseif...
Parts:{onset}.
Florezet al.studied the textual formulation and line-of-code
implementation on a set of 187 constraints from 8 Java systems.
The constraints were categorized into four types:
Value comparison has 2operands. The value of ğ‘‹(variable)
is constrained by the value of ğ‘Œ(variable) with an equality or
relational operator. Example: â€œSWARM will allow the maximum
frequencytobesettoanypositivevaluegreaterthantheminimum
frequency â€[64]containstwoconstraints: maxfrequency >0"and
"maxfrequency >minfrequency ".
Dual value comparison has 2operands. ğ‘‹(variable), and ğ‘Œ
(condition) isoneofthe2mutually-exclusivevaluesthatimpliesthe
other (e.g., true/false, enabled/disabled). Example: â€œIf configuration
file is not available or readable... â€[64] contains two constraints:
â€œfile isavailable " and â€œfileisreadable ".
Categorical value has 3+operands. ğ‘‹(variable) is constrained
to a finite set ğ‘†(2+ options) of two or more values. Example: â€œon-
MissingExtensionPoint: What to do if this target tries to extend a
missingextension-point.(fail,warn,ignore) â€[4]containsonecon-
straint: â€œonMissingExtensionPoint âˆˆ{fail,warn,ignore}".
Concretevalue has2operands.Theconstraintdirectlydeclares
ğ‘‹(variable) tobeğ¶(value).Example:â€œThedefault[switch]dateis
1582-10-15.â€ [39] contains a constraint: â€œswitchDate is1582-10-15".
The implementation of a constraint consists of two parts: an
enforcingstatement anddatadefinitionstatements.Eachenforcing
statement was categorized according to the type of code construct
whereitappears(e.g., expression, ifstatement, returnstatement,
etc.) and the number of operands it uses. The result was the defini-
tion of 30 CIPs, i.e.,code patterns with line-of-code granularity. In
this paper, we only utilize information about 13 CIPs, which were
identified as the most commonly used: boolean property, binary
comparison, constantargument, nullcheck, assignconstant, binary
flag check, if chain,equals or chain, switch len char, self comparison,
returnconstant, nullzerocheck,and nullemptycheck.Table1shows
thedefinitionof2ofthe13patterns.ThecompleteCIPCatalogcan
be found in the original publication [27].
ForeachCIP,weusethedescriptionandthenumberofrequired
operands(whichweconvertintoagrammar-Section3).Inaddi-
tion, for each constraint type, Florez et al.identified which CIPs
aremostcommonlyusedforimplementingconstraintsofthattype.
1894
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Retrieving Data Constraint Implementations
Using Fine-Grained Code PatternsICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Figure1:OverviewofLasso.Grayboxesarereplaceablecom-
ponents. There can be any number of CIP detectors.
For example, constraints of dual value comparison type are most
frequentlyimplementedusingthe booleanproperty CIP,withthe
next most common CIP being null check. Lasso also leverages this
information as part of its ranking model.
3 APPROACH DESCRIPTION
Ourapproach, Lasso( Locatingd AtaconStraintsin SourcecOde),
isdesignedasanextensibleframeworkthatautomaticallyidentifies
implementationsofgivendataconstraintsinthesourcecode.An
overview of the Lasso framework is presented in Figure 1.
The main novelty of Lasso is its ability to identify constraint
implementationsatline-of-codegranularity.Thisisenabledbythe
AST-based CIP matching component (AST-CIP, see Section 3.2).
AST-CIP is composed of several CIP detectors. Each one can detect
instances of one CIP in the source code bytraversingthe abstract
syntax trees (ASTs) of the target system. As shown in Table 1, Flo-rez et al
. [27]defined each CIP using natural language description
and an example. Such definition is ambiguous and can not be used
forspecifyingthepatternforeachdetector.Basedontheirdefini-
tions,wedefineasyntacticpatternofeachCIP,usingacontext-free
grammar (CFG). AST-CIP takes the source code as input, and iscomposed of a number of detectors, each capable of identifying
instancesofoneCIP.TheusercanmakeachoiceofhowmanyCIP
detectorstoprovide.Addingmorecanresultinmoreconstraints
beingcorrectlytraced.AST-CIPproducesasetofsourcecodestate-
ments,i.e.,enforcingstatementcandidates(ESCs),thatmatchthe
syntactic patterns of the CIPs used by the detectors (Section 3.2.2).
In addition, Lasso uses a traceability link recovery tool (TLRT),
that accepts natural language (i.e., the description of a data con-
straint) and source code as inputs. The TLRT retrieves relevantsource code methods for the constraint. Lasso is agnostic to the
internal retrieval model of the TLRT, which means the framework
can use any TLRT, as long as it uses the appropriate input and pro-
ducesoutputatmethod-levelgranularity.Weimplementedthree
instancesofLasso,usingLucene-,VSM-,andLSI-basedTLRT(Sec-
tion 4).
Finally, Lassoâ€™s ranking component (RANK) uses the ESCs iden-
tified by the AST-CIP component and the method-level results
returned by the TLRT to produce a list of methods, ranked by their
likelihoodthattheyimplementagivendataconstraint,andalistWhile SWARM will allow the maximum frequency to be set to any positive
value greater than the minimum frequency, this value will adjust automatically
ifit is greater than the Nyquist frequency of the wave being manipulated.
Figure 2: Example of constraint input from the Swarm sys-tem. The entire text is the context. The constraint in bold,and the operands are highlighted in gray.
Figure3:Theoperands,body,andblockelementsoftheESCthat implements the constraint in Figure 2.
of code statements inside each method, ranked by their likelihood
to enforce the constraint (Section 3.3).
3.1 Lasso Inputs
For each target system, Lasso takes as input its source code, which
is used by the TLRT and the AST-CIP components.
TheConstrainttypetoCIPmapping (Section2)containsinforma-
tion about the type of data constraints and frequency of existing
CIPsimplementingeachconstrainttype.Thisinformationisem-
ployedbytheusertodescribetheconstraintandalsobytherankingcomponenttoestimatethelikelihoodthatacertainCIPimplements
a given constraint type. For each constraint, three elements are
specified by the user and used as queries by Lasso.
1.Theconstraintcontext istheparagraphwheretheconstraint
is described in the existing documentation (e.g., requirements, use
cases, and manuals). This is used by TLRT.
2.Theconstraint type is set according to the definitions in the
constrainttypecatalog.TheCIPcatalogweusedefinesfourcon-
straint types: value comparison, dual value comparison, categorical
value, and concrete value (Section 2). This is used by RANK.
3.Theconstraint operands are the noun phrases referring to the
dataonwhichtheconstraintisdefined.Thenumberofoperands
varies foreach typeof constraint(Section 2):(1) two operandsfor
valuecomparison ;(2)twooperandsfor dualvaluecomparison ;(3)
three or more operands for categorical value ; and (4) two operands
forconcrete value. This information is used by RANK.
Figure2showsanexampleoftheconstraintinputsthatLasso
takes. The constraint context is all the text in the figure. The con-
strainttype (derivedfromthetextdescribingtheconstraint)is value
comparison, as it matches the definition "a value is constrained by
anothervalueusingarelationaloperator"(greaterthan inthiscase).
Theoperands ofthisconstraintare[maximumfrequency,Nyquist
frequency of the wave]. Note that reference resolution is not done
automatically, but left to the user, who in this case should select
the noun phrase â€œmaximum frequencyâ€ instead of the pronoun â€œitâ€.
1895
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Juan Manuel Florez, Jonathan Perry, Shiyi Wei, and Andrian Marcus
3.2 AST-CIP component
TheAST-CIPcomponentusesthesourcecodeandtheconstraint
detectors to identify enforcing statement candidates (ESCs).
3.2.1 ESC definition. Each ESC has the elements:
â€¢Abody,e.g.,theASTelementthatmatchestheCIP,which
can be a field definition, a statement, or an expression.
â€¢Amethodwhere it appears.
â€¢A list ofoperands.
â€¢An optional blockof statements.
â€¢ACIP type, corresponding to the CIP that it matches.
Thenumberof operands ofanESCdependsonits CIPtype,as
described in Section 2. Figure 3 shows the ESC that implements
theconstraintinFigure2.TheESCâ€™s CIPtypeisbinary-comparison ;
hence,ithashastwo operands (basedontheCIPcatalogweuse).
Lasso aggregates the terms of an operand, by collecting both the
identifierscontainedinsidetheESC body(â€œwave.getNyquist"for
operand 2, in the example), and the identifiers in the operandâ€™s
definition (â€œdouble getNyquist()" for operand 2, in the example).
Thedefinitionsareobtainedbysymbolresolution,andcanbedone
with any analysis framework that provides the functionality.
Theblockelement applies only to the ESCs whose bodyappears
in the condition of a if,while,o rdo-whilestatement. The block
correspondstoallthetextinthebodyof thestatement,including
boththenandelseblocks in the case of ifstatements. The ESC
blockdoes not apply to ESCs whose body appears between the
parentheses of a forstatement, because these conditions are more
complex than those of the previously mentioned statements.
NotethatsomeESCsmayappearoutsideofmethods, e.g.,infield
definitions. In this case, the corresponding definition is considered
to be apseudo-method.
3.2.2 CIP matching. As discussed, the ambiguity in the CIP defini-
tions by Florez et al.[27] makes it hard to specify which instances
should be matched by each CIP detector. To address this challenge,
weexpresstheCIPsusingacontext-freegrammar(CFG),shownin
Figure4.Wedefinegarmmarsfor13mostcommonCIPs(Section2).
The grammar of each CIP covers all instances of the pattern in
Florezâ€™sdata.Byconvention,non-terminalsareinuppercaseand
terminals are in lowercase. The non-terminals in blue are the start
symbolsformatchingthe13CIPs.Inthisgrammar,aterminalor
non-terminalmaybeassociatedwithan operandspecifier,which
is an annotation following a colon, e.g.,op in BOOL_VAL:op on
line 1. Operand specifiers are used to identify the symbols that
areoperandsineachCIP.Thesameoperandspecifierdefinesthe
samesymbolindifferentplacesinaCIPâ€™sgrammar.Forexample,
var:opon lines 23 to 25 requires the same variable to appear in
these conditional expressions.
Lasso can have any number of CIP detectors. To identify ESCs,
Lasso first parses all files in the source code except for the test
filestogenerateASTs.Testfilesareignoredbecausethesedonot
contain the implementation of business rules (in this case data
constraints). Investigating the association between data constraint
implementationsandtheirtestcodeissubjectoffuturework.Lasso
thenvisitseverynodeineachAST.WhenanASTnodeisvisited,
AST-CIP attemptstomatch thegrammarofeach detectoronsaid
node.AnindividualCIPdetectorwillreturnanESC ifandonlyifthe1BOOLEAN_PROPERTY â†’BOOL_VAL :ğ‘œğ‘
2BOOL_VAL â†’var_bool |method_call_bool |field_access_bool
3
4BINARY_COMPARISON â†’VAL:ğ‘œğ‘1CMP VAL:ğ‘œğ‘2
5 |VAL:ğ‘œğ‘1RELOP VAL :ğ‘œğ‘2
6CMPâ†’<|>|<=|>=
7RELOPâ†’==|!=
8VALâ†’var|method_call |field_access
9
10CONSTANT_ARGUMENT â†’var . m_name :ğ‘œğ‘1(ARGSliteral:ğ‘œğ‘2ARGS)
11ARGSâ†’exprARGS|ğœ†
12
13NULL_CHECK â†’nullRELOP VAL :ğ‘œğ‘
14 |VAL:ğ‘œğ‘RELOPnull
15
16ASSIGN_CONSTANT â†’VAR:ğ‘œğ‘1= literal :ğ‘œğ‘2
17VARâ†’var|field
18
19BINARY_FLAG_CHECK â†’INT_VAL:ğ‘œğ‘1BITOP INT_VAL :ğ‘œğ‘2RELOP
lit_int:ğ‘œğ‘2
20INT_VAL â†’var_int |method_call_int |field_access_int
21BITOPâ†’&||
22
23IF_CHAIN â†’if ( var :ğ‘œğ‘== literal ) BODY ELSEIF
24ELSE_IF â†’elseif ( var :ğ‘œğ‘== literal ) BODY ELSE
25ELSEâ†’elseif ( var :ğ‘œğ‘== literal ) BODY ELSE |ğœ†
26
27EQUALS_OR_CHAIN â†’var:ğ‘œğ‘== literal CHAIN
28OR_CHAIN â†’|| var:ğ‘œğ‘== literal CHAIN
29CHAINâ†’|| var:ğ‘œğ‘== literal CHAIN|ğœ†
30
31SWITCH_LEN_CHAR â†’switch ( VAL:ğ‘œğ‘. length() ) LEN_CASE
32LEN_CASE â†’case literal_int : stmts LEN_CASE |ğœ†
33
34SELF_COMPARISON â†’var:ğ‘œğ‘RELOPvar:ğ‘œğ‘
35
36RETURN_COSTANT â†’return literal :ğ‘œğ‘1
37
38NULL_ZERO_CHECK â†’NULL_CHECK AND_OR var:ğ‘œğ‘. length()>0
39AND_ORâ†’&&|||
40
41NULL_EMPTY_CHECK â†’NULL_CHECK AND_OR var:ğ‘œğ‘. equals("")
Figure 4: Grammar for 13 CIPs.
nodeisavalidproductionofthedetectorâ€™scorrespondinggrammar.
If the node is not a valid production, the detector returns nothing.
Traversing all nodes in all ASTs results in the final list of ESCs.
To produce all elements of the ESC as result, each detector uses
thematchingASTnode(ESC body),themethodwherethematching
nodeappears(ESC method),thespecificdetector(ESC CIPtype),and
thelistofoperands(ESC operands).Thenumberofoperandsdiffers
by CIP, and is extracted by each detector based on the grammar.
InadditiontotheoperandidentifiersintheESC body,Lassoalso
includesthetextfromtheirdefinitions(seeFigure3).Thedefinition
ofeachoperandisresolvedusingsymbolresolution,yieldingone
of the possible definitions: field definition, method definition, vari-
able/parameterdefinition.Incasetheoperanddefinitionisamethod
definition, only the identifiers corresponding to the method name,
parameternames,andparametertypesareaddedtotheoperand.
For parameters, only the parameter name and type are added to
theoperand.Fortheremainingtypesofdefinitions,allidentifiers
in the defining statement are added to the operand.
1896
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Retrieving Data Constraint Implementations
Using Fine-Grained Code PatternsICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
ConsidertheexampleinFigure3;whentheLassoreachesthe
AST node corresponding to the ifstatement condition, it attempts
tomatchthegrammarofeachdetector.Alldetectorsbuttheone
forbinary comparison will return nothing, as this node matches
no other CIPs. The given node matches the CIP, as it is a binary
expression using a relational operator. After finding that the node
matchesthegrammar,thedetector identifies theoperands.Inthis
case there are two operands, as per the CIP definition; they are
settings.spectrogramMaxFreq andwave.getNyquist() .Symbolres-
olution is applied as appropriate for each operand: in the first case,
the field is resolved, and in the second case, the method is resolved.
The identifiers found in the definitions are then added to the terms
of the corresponding operand.
3.3 Ranking component
RANKusesfourtypesofinformationfromtheinputs(i.e., userinput
and CIP catalog) and from the output of the other two components
(i.e.,TLRT and AST-CIP) to rank all ESCs for a given constraint:
â€¢Theconstraint context, the constraint type, and the list of
constraint operands, from the user input.
â€¢The ESC CIP type, the ESC method, the list of ESC operands,
andtheESC block,fromtheAST-CIPoutput,foreachESC
that matches any of the CIPs implemented in the detectors.
â€¢Which CIPs are used most frequently to implement con-
straintsofthegiven constrainttype,fromtheconstrainttype
to CIP mapping.
â€¢The ranked list of methods produced by the TLRT.
We introduce abbreviated notations for the various informa-
tion used in the ranking. For the constraint elements we use: ğ¶ğ‘
(constraint context ),ğ¶ğ‘¡(constraint type ), andğ¶ğ‘œ(list of constraint
operands).FortheESCelementsweuse: ğ¸ğ‘¡(ESCCIPtype),ğ¸ğ‘š(ESC
method),ğ¸ğ‘œ(list of ESC operands), andğ¸ğ‘(ESCblock).
Lasso first applies standard text retrieval preprocessing tech-
niques to all textual fields of both constraint inputs ( ğ¶ğ‘,ğ¶ğ‘œ) and
ESCs(ğ¸ğ‘œ,ğ¸ğ‘).Specifically,weapplyidentifiersplitting(basedon
camelCaseFormat andunderscore_format,stemmingusingthePorter
algorithm [ 54], and stop word removal (the list of stop words is
available in our replication package [ 28]). Lasso then uses ğ¶ğ‘or
ğ¶ğ‘œ(as appropriate) as input to TLRT and obtains a ranked list of
methods, which we denote as ğ‘ˆğ‘š.
Giventhe inputconstraint, foreach ESCidentified bythe AST-
CIP, Lasso uses four heuristics for computing a relevance score:
1.The common terms between the constraint operands (ğ¶ğ‘œ) and
the ESCoperands (ğ¸ğ‘œ). The intuition is that if the operands from
theconstraintdescriptionmatchtheESCoperands,thentheESC
is likely to implement the input constraint, e.g.,the term â€œNyquistâ€
appears in one constraint operand and one ESC operand in Fig. 3.
2.The common terms between the constraint operands (ğ¶ğ‘œ) and
theESCblock( ğ¸ğ‘).InsomecasestheESC bodyusestermsdifferent
from those in the constraint (e.g., i<=j), so the previous heuristic
will not find common terms. However, op erations in the ESC block
may indeed use these terms if the logic is related to the constraint.
Matching constraint operand terms with terms in the ESC block
increases the likelihood that the ESC enforces the given constraint.
3.ThefrequencyoftheESC CIPtypeğ¸ğ‘¡,withrespecttothecon-
strainttype ğ¶ğ‘¡,extractedfromtheCIPcatalog.PreviousresearchbyFlorezetal .[27](seeSection2)identifiedwhichconstrainttypes
are implemented by which CIPs. For example, they found that 59%
ofconstraintsofdualvaluecomparisontypeareimplementedus-
ing the boolean-property CIP, while 17% are implemented with the
null-checkCIP.Hence,iftheESC CIPtypematchestheformer,then
it is more likely it implements the given constraint.
4.TheTLRTrankoftheESC method,ğ¸ğ‘š.IftheESC methodis
ranked high by the TLRT, then it is likely that the ESC implements
the given constraint and less likely if the rank is low.
For these heuristics, we define five measures (two for the first
one, and one each for the others) that take values between 0 and 1.
1.COE(Constraint-ESC operands ). Lasso pairs each operand ğ‘œğ‘–
inğ¶ğ‘œto the operand ğ‘œğ‘—inğ¸ğ‘œwith which it has the largest number
oftermsincommon.Thepairingisstrictlyone-to-one.Thenthe
COEmeasure is calculated according to Equation 1.
ğ¶ğ‘‚ğ¸=/summationtext.1
ğ‘–,ğ‘—ğ‘ (ğ‘œğ‘ğ‘–,ğ‘œğ‘’ğ‘—)
|ğ¶ğ‘œ|(1)
Whereğ‘ returns the percentage of terms in the constraint operand
ğ‘œğ‘ğ‘–that are also in the ESC operand ğ‘œğ‘’ğ‘—. Unpaired elements (e.g.,
if the constraint has more operands than the ESC) have a valueof zero for
ğ‘ . For the example in Figure 3, the second constraint
operandğ‘œğ‘2â€œNyquistfrequencyofthewaveâ€getspairedwiththe
second ESC operand ğ‘œğ‘’2wave.getNyquist() . The first constraint
operandğ‘œğ‘1â€œmax frequencyâ€ gets paired with the remaining ESC
operandğ‘œğ‘’1, though they have no terms in common. The value of
the measure is then ğ¶ğ‘‚ğ¸=ğ‘ (ğ‘œğ‘1,ğ‘œğ‘’1)+ğ‘ (ğ‘œğ‘2,ğ‘œğ‘’2)
|ğ¶ğ‘œ|=0+0.4
2=0.2. The
value ofğ‘ (ğ‘œğ‘2,ğ‘œğ‘’2)is 0.4 because the second constraint operand
hastwooutoffivetermsincommonwiththesecondESCoperand:
Nyquist and wave.
2.ECO(ESC-constraintoperands )performsthesamepairingas
COE. This time, the ECOmeasure captures the percentage of terms
from each ESC operand ğ‘œğ‘—that in common with the constraint
operandğ‘œğ‘–.FortheexampleinFigure3, ğ¸ğ¶ğ‘‚=ğ‘ (ğ‘œğ‘’1,ğ‘œğ‘1)+ğ‘ (ğ‘œğ‘’2,ğ‘œğ‘2)
|ğ¸ğ‘œ|=
0+0.5
2=0.25. The value of ğ‘ (ğ‘œğ‘’2,ğ‘œğ‘2)is 0.5 because ğ‘œğ‘’2has four
terms (wave, get, Nyquist, double), and two of them match theconstraint operand: Nyquist and wave. The reason we performthe matching both ways (COE andECO) is that even though an
ESC may contain most or all terms in the constraint operands, also
including a lot of unrelated terms suggests that it might be dealing
with different data.
3.COB(Constraint-operandblock )isthepercentageoftermsinall
elements of ğ¶ğ‘œthat appear in ğ¸ğ‘. We do not perform the matching
in the opposite direction (analogous to COEandECO) because the
ESC blocks can be long, and hence contain a lot of different terms,
causing the values to be too small to make a difference in the score.
Thisscoreisbasedontheintuitionthatifthenamesofoperands
are used in the body of the conditional statement, then the ESCis more likely to be relevant compared to the case in which the
operands only appear in the condition.
4.ECIP(ExpectedCIP ).BasedontheinformationfromtheCIP
catalog,ECIPis 1.0i fğ¸ğ‘¡is the most frequently used pattern imple-
mentingğ¶ğ‘¡,0.5 if it is the second most frequent, and 0 .0 otherwise.
Specifically, valuecomparison :[binarycomparison ];dualvaluecom-
parison:[boolean property, null check ];concrete value :[constant
argument, assign constant ];categorical value :[if chain]. Notice that
1897
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Juan Manuel Florez, Jonathan Perry, Shiyi Wei, and Andrian Marcus
in the cases of value comparison andcategorical value there is only
one â€œmost common CIPâ€. In these cases we considered that the
second most common CIP did not appear in enough instances to
makeitcommonenough,soonlyoneCIPgetsthefullscore(1 .0)
and all others get zero.
5.CM(Contextmethod ).CMis1/âˆšğ‘Ÿwhereğ‘Ÿistherankofthe
ğ¸ğ‘šinğ‘ˆğ‘š, or 0 if TLRT did not return that method.
The final relevance score for an ESC is computed according to
Equation 2. Namely, the relevance score ( ğ‘Ÿğ‘ ) for an ESC ( ğ‘’) is equal
tothesumoftheweightedvaluesofthefivemeasuresforthatESC
(i.e., COE,ECO,COB,ECIP, andCM).
ğ‘Ÿğ‘ (ğ‘’)=5/summationdisplay.1
ğ‘–=1ğ‘šğ‘–(ğ‘’)âˆ—ğ‘¤(ğ‘šğ‘–) (2)
Whereeach ğ‘šğ‘–(ğ‘’)isthevalueofameasureandeach ğ‘¤(ğ‘šğ‘–)is
its corresponding weight.
TheESCsaresortedindescendingorderoftheirrelevancescore;
thosewithascoreofzeroareomittedfromtheresultlist.Results
that only have a non-zero value for CMare also omitted, as our
tool prioritizes results found via CIP matching. At most one ESC is
returned for each line of code in each file, with only the ESC withthe highest score returned for each line.
The ESC rankings are converted to method level by ranking
each distinct ğ¸ğ‘š(produced by the TLRT) in the same order as they
appearintherankedESClist,withoutrepetition.Forexample,if
ESCsinranks1,2,and100areinmethodA,andESCsinranks3
and4areinmethodB,methodAwillberankedfirst,andmethodB
will be ranked second. The list of ESCs is preserved alongside each
method, and they appear in the same order as in the original list of
ESCs. Continuing the above example, method A will have an ESC
result list with 3 ESCs, and method B will have 2 ESCs in its list.
4 LASSO INSTANTIATION
Weimplemented13CIPdetectors,oneforeachofthefrequently
occurring CIPs (see Section 2). We used the JavaParser library [ 38]
toimplementthesedetectors.Forthis,weemployedtheparsingca-pabilitiesofthelibrarytoparsethesourcecodefiles,andusedAST
visitors to implement each detector as specified by the correspond-
inggrammar.Wealsoreliedonthelibraryâ€™ssymbolresolutionto
resolve operand definitions.
We used these detectors to formulate three Lasso instances:
â€¢Lasso-13Luc, which uses as TLRT Lucene 8.6.3 [ 48] with
its default similaritymetric, implementing the BM25 model
[57].
â€¢Lasso-13VSM,whichusesasTLRTLucene8.6.3,withitsclas-
sicsimilarity metric,implementingthe VectorSpaceModel
(VSM) [32], more specifically, TF-IDF.
â€¢Lasso-13LSI, which uses as TLRT Latent Semantic Indexing
(LSI) [22].
Thethreeinstancesalsodifferinwhattextisprovidedasinputto
TLRT:inthecaseofLasso-13LucandLasso-13VSM,theconstraint
contextis used, while for Lasso-13LSI it is the concatenated terms
of all the constraint operands. These inputs were selected because
they achieved the highest performance for each TLRT according
toapreliminarytest.Theresultsofsuchtestcanbefoundinour
replicationpackage[ 28].ThethreeTLRTcomponentsusethesameTable 2: Software systems in the validation data set (VDS).
System Domain KLoC MTHğ‘
mybatis-3.5.5 Persistence Framework 60 3,639
shardingsphere-
5.0.0-rc1DB Sharding middleware 110 9,599
skywalking-8.0.1App. Perf. Manager 127 10,825
jabref-5.0 Citation Manager 130 12,796
jpos-2.1.4 Finance library 175 8,291
log4j-2.13.3 Logging Framework 191 15,952
checkstyle-8.35 Source Code Style Checker 276 6,379
ğ‘: Number of methods
text processing, as described in Section 3.3 and return results at
themethodlevel.ForLSI,weusedadimensionparameterof300.
Thisparameteryieldedthebestperformanceonourdataaccording
toourpreliminarytests(resultsfoundinourreplicationpackage
[28]).Thesetwotextretrieval-basedtraceabilitylinkrecoverytech-
niqueshavebeencommonlyusedasbaselinesinpriorstudieson
traceabilitylinkrecovery[ 6,11,42]andbuglocalization[ 16,50,52].
The Lasso instances and the two TLRT work on Java code.
5 EVALUATION
The goal of our evaluation is to assess how effective Lasso is in
locatingthedataconstraintimplementationsatbothmethodand
line-of-code level, as it works at both granularities.
Our evaluation answers two research questions:
â€¢RQ1:WhatistheperformanceofLasso-13Luc,Lasso-13LSI,
andLasso-13VSMonmethod-leveldataconstrainttraceabil-
ity link recovery?
â€¢RQ2:HowaccuratelycanLasso-13Luc,Lasso-13LSI,and
Lasso-13VSM retrieve the lines of code that implement a
constraint?
5.1 Experimental Setup
Subjects of the study. We perform an intrinsic evaluation by
comparing Lasso-13Luc and Lasso-13VSM with the Lucene-based
TLRT they are built upon. Likewise, we compare Lasso-13LSI with
the LSI-based TLRT.
Datasets. Weneedground-truthdatasetswherethetracesfrom
the data constraints to their implementations (lines of code) are
known. We use two datasets in the evaluation. The first is the data
published by Florez et al .[27], which we refer to as the Calibration
Data Set (CDS), since we use it for calibrating the weights of the
five measures used by the Lasso instances for ranking (see Sec-tion 3.3). We describe the calibration below. CDS consists of 163
tracedconstraintsin8real-worldJavasystems[ 27].Thatstudyhad
adatasetof187constraints.Weselectedonlythe163constraints
implemented with one of the 13 CIPs detected by Lasso-13.
We collected an additional dataset, called Validation Data Set
(VDS),consisting of136constraints from7new systemsdifferent
fromtheonesinCDS(Table2).Thetextualartifactsforallsystems
1898
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Retrieving Data Constraint Implementations
Using Fine-Grained Code PatternsICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
aretheircorrespondingusermanuals.Weusedthefollowingpro-
tocoltoconstructVDS,whichissimilartotheoneusedbyFlorez
et al. [27]. First, one author examined the textual artifacts of the
7 systems and extracted 30 data constraints from each. Next, we
recruited four tracers to identify the implementations of these con-
straints. All tracers are Computer Science graduate students, each
with at least 3 years of programming experience in Java.
The tracers were instructed to find a single implementation per
constraint, specifically the one described in the textual artifact
where the constraint originated. The reasons for this are aligned
withthosearguedbyFlorezetal .[27].Namely,(1)itisverydifficult
todefineastoppingcriterionthatwouldconsistentlyresultinall
implementations of a constraint being reliably found, and (2) term
mismatchandimplementationcomplexitiesmakeitnecessaryto
usetheconstraintcontexttohaveareasonablecertaintythatthe
trace is correct, which means only the instance of the constraint
defined in the text can be reliably traced.
Eachconstraintwasassignedtotwotracers.Thetracersproduced
identical traces for 116 constraints (55% of 210). The disagreements
were caused either from misunderstandings of the code semantics
(asthecodedoesnotalwaysusethesametermsastheconstraintâ€™s
textualdescription), or from tracersselectinga statementthat does
not refer to the specific implementation of the assigned constraint,
but rather one in related functionality. This relatively low agree-
mentrateistobeexpectedduetothecomplexnatureofthetask,
whichrequiresthetracersbefamiliarwiththetargetsystemâ€™scode.
To ensure the quality of VDS, two authors determined the final
trace through discussion based on the tracersâ€™ answers. Finally,
to determine which constraints were suitable for our evaluation,one author labeled each trace with the CIP that corresponded to
it. Only those constraints implemented with one of the 13 CIPs for
whichweimplementeddetectorswereaddedtotheVDSdataset,
resulting in 136 constraints in total.
Metrics. BecausebothCDSandVDScontaintraceabilitylinksat
line-of-codegranularity,thelinesofcodeforeachtracecorrespond
tothegroundtruth foreachconstraint.BothLassoinstancesand
thebaselinesproducerankedlistsofmethodsastheiroutputs. To
measuretheireffectiveness,ifamethodintheresultlistcontains
thegroundtruthlines,weconsidertheconstraintasretrievedat
thatrank.Wecallthisthe methodrank oftheconstraint.Recallthat
theLassoinstancesalsoproducearankedESClistforeachmethod.
Wedefinethe ESCrank asthepositionoftheESCcontainingthe
ground truth lines in the ESC corresponding ground truth method.
Aswediscussedabove,eachconstraintinCDSandVDShasonly
one ground truth. This means that commonly used information
retrievalmetricsarenotverymeaningfulhere.Specifically,MAP
[55] will always have the same value as MRR (1 divided by method
rank,or0iftheconstraintwasnotretrieved).Precisionwillalways
be either 0 if the ground truth was not retrieved, or 1 divided by
the amount of results if it was. Recall will either be 1 if the ground
truth was retrieved, and 0 if not. In light of this, we report MRR,
average recall, and the average method rank.
These metrics are provided for completeness, as we focus our
analysis on the %HITS@N metrics, defined as the percentage of
constraintswitha methodrank between1andN, i.e.,constraints
wherethegroundtruthwasretrievedwithinthefirstNmethodsof
the output ranked list. This metric is easy to interpret, as it meansthatapotentialuserhastoexamineNresults(inthiscasemethods)tofindtheconstraintimplementation.Theimportanceofthismetric
(sometimes under different names) has been argued in the fields of
buglocalization[ 66,70],queryreformulation[ 15,16,26,55],and
duplicate bug report detection [17, 58].
Inputgeneration. AsdiscussedinSection3.1,Lassorequires
the type, operands, and context of each constraint as input. To con-
structtheinput,oneauthorextractedtherequiredinputfieldsfor
each constraint.Specifically,the constraintcontext isa paragraph
wheretheconstraintisfoundinthetextualartifacts.Theconstraint
type was assigned as one of the four constraint types in Sec. 2. The
operand list is composed of the noun phrases that describe each
operand,usingonlytermsfoundintheconstraintcontext,exceptinthecaseofnumbers.Ifnumberswerespelledout,theywereturned
into digits, e.g.,â€œoneâ€ becameâ€œ1â€. Additionally, symbols werealso
spelled out, for example â€œ âˆâ€ becomes â€œinfinityâ€. Sec. 3.1 shows an
example of specific input for a constraint. The inputs for all 299
constraints can be found in our replication package [28].
Baselinecalibration. To find the optimal input (i.e., constraint
context or constraint operands) for the TLRT of each Lasso-13
instanceandthebestparametersforLSI,weevaluatedthebaselines
on the combined CDS and VDS data sets using each input with
eachtechnique.Thebestperformingcombinationsareexplained
in Section 4, and the full results are in our replication package [ 28].
Calibration of Lasso ranking weights. We empirically cali-
bratedtheweightsforthefiverankingmeasures(Sec.3.3),using
CDS.Wedesignedanalgorithmtofindthecombinationofweights
that result in the best results for Lasso-13Luc in CDS. We used
Lasso-13Luc for calibrations, as opposed to Lasso-13LSI or Lasso-
13VSM,becauseLucenewithitsdefaultsimilarityperformedbetter
than the other two approaches. That is, we optimized the weights
based on the strongest baseline.
The calibration algorithm runs 5 rounds of testing (one for each
weight). Each metric begins as a free metric, and at the end of
eachround,onemetricwillbecomefixedwithaweight.Oneach
round, for each free metric, the algorithm generates scenarios cor-
responding to all combinations of weights for all free metrics (one
of{0.0,0.1,0.2,...,0.9,1.0}) and the fixed weights. The value of
the free weight that leads to the highest value of %HITS@20 be-
comes fixed. The optimal configuration for Lasso-13Luc, for CDS,
isCOE=0.7,ECO=0.2,ECIP=0.2,COB=0.2,CM=1.0.Asmen-
tionedabove,weusethesameconfigurationfor Lasso-13LSIand
Lasso-13VSM, as we want to assess how robust these weights are
to changes in the data sets and TLRT.
5.2 RQ1 Results
Table 3a shows the results obtained by Lasso-13Luc, Lasso-13LSI,
Lasso-13VSM, the Lucene-based TLRT, the VSM-based TLRT, and
theLSI-basedTLRT,onthecalibrationdataset(CDS),with163con-
straints. Table 3b shows the results obtained by the six approaches
onthevalidationdataset(VDS),with136constraints,whileTable3c
shows the results on the combined data sets, with 299 constraints.
5.2.1 Weightcalibrationvalidation. Toensurethattheconfigura-
tion was not overfitted to the test data, we evaluated the Lasso
instancesonthevalidationdatasetwiththeconfigurationobtainedfromthealgorithminSec.5.1.ComparingtheresultsfromTable3a
1899
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Juan Manuel Florez, Jonathan Perry, Shiyi Wei, and Andrian Marcus
and Table 3b, we observe that all three Lasso-13 instances achieve
improvementsonbothdatasets.Lasso-13Lucimproves%HITS@10
from 39.3% to 57.7% (47%) over the Lucene baseline on CDS, and
from 66.2% to 77.9% (18%) on VDS. Similarly, Lasso-13VSM im-
proves%HITS@10from22.7%to49.7%overtheVSMbaselineon
CDS, and from 44.1% to 72.8% on VDS. Finally, Lasso-13LSI im-
proves%HITS@10overtheLSIbaselinefrom12.9%to39.9%(209%)onCDS,andfrom27.9%to66.2%(137%)onVDS.Thisindicatesthat
the weight calibration is robust and transfers to other data sets.
From here on, we perform all analyses on the results on the
combined data set (i.e., CDS + VDS).
5.2.2 Lasso-13Luc vs. Lucene-based TLRT. Table 3c shows the re-
sultsobtainedbyLasso-13LucandtheLucene-basedbaselineon
the combined data sets.
As discussed before, %HITS@N indicates the percentage of con-
straints for which the relevant method is retrieved in top N In
theory,insuchcases,theusersneedtocheckatmostNmethods
tofindtherelevantone.Priorresearchontraceabilitylinkrecov-
eryarguedthatretrievingthegroundtruthonthetoppositionis
perfect performance, returning it in the top 5 is excellent, and in
top 10 very good [ 15,16]. Note that the number of methods in the
targetsystemsis9.6konaverage(Table2).Wefocustheanalysisof
the results on %HITS@10 ( i.e.,indicating very good performance).
WeobservethatLasso-13Lucobtains25.4%%HITS@1,which
meansthatforoneinfourconstraints,Lasso-13Lucretrievesthe
relevant method in the first place. At %HITS@10, Lasso-13Luc
improvesthebaselineapproachby30%(66.9%vs51.5%).Inother
words,fortwothirdoftheconstraintsLasso-13Lucretrievesthe
relevant method in top 10, compared to half the constraints for the
baseline. Lasso-13Luc also improves the %HITS@1 and %HITS@5
results over the baseline by 44% and 42%, respectively.
NotehowLasso-13Lucimprovestheaveragemethodrankfrom
148.9 to 24.6, a reduction of one order of magnitude.
ThelowerrecallforbothLasso-13instancesvs.theirbaselinesis
tobeexpected,andalsobothreturnthesameresultsdespitehaving
differentTLRT(i.e.,Avg.Recall columninTable3isthesamefor
bothapproaches).Thisisbecause(asexplainedinSec.3.3),onlytheESCsthathaveavalueforthefirst4metricsareretrieved,meaning
that which ESCs are returned does not depend on the results of
TLRT. Instead,the TLRT resultsare used as partof the rankingof
these ESCs, and as such, both Lasso-13 instances achieve different
values of %HITS@N, average method rank, and MRR, as expected.
5.2.3 Lasso-13LSI and Lasso-13VSM vs. baseline TLRT. Table 3c
shows the results obtained by Lasso-13LSI, the LSI-based baseline,
Lasso-13VSM, and the VSM baseline on the combined data sets.
We observe that Lasso-13VSM improves the %HITS@10 results
of the VSM baseline by 86% (60.2% vs. 32.4%), while Lasso-13LSIhas an improvement of 163% (51.8% vs. 19.7%) over its baseline.
We note that the VSM baseline performs worse than the Lucene-
based one by 37% in terms of %HITS@10, while the LSI baselineperforms 62% worse. The improvement in terms of average rankfor Lasso-13VSM over its baseline is similar to that achieved byLasso-13Luc over its baseline, namely, one order of magnitude.
With that in mind, the size of the improvement obtained by Lasso-
13LSI (compared to Lasso-13Luc or Lasso-13VSM) indicates that
Lasso is especially well suited to improve a poorly performingbaselineTLRT.Notably,thereductioninaveragerankisevenmoredramatic for Lasso-13LSI, going from 2,286.2 to 41.4, or two orders
of magnitude.
5.2.4 Analysis of the results. We perform a deeper analysis of the
Lasso-13Lucresults,givenitperformsbetterthantheothertwo
Lasso variations. We examined a random sample of 30 constraints:
10 where the ground truth was not retrieved, 10 where it was
retrievedwithmethodrank11-20,and10wherethemethodrank
was 21+.
Themostcommonreasonfornotretrievingorlow-rankingof
the ground truth was a term mismatch between the operands in
the constraint text and the operands of the ESC, which is a known
problem in traceability link recovery. Specifically, we identified the
following causes of term mismatches:
(1)usesofabbreviations(ArgoUMLconstraintâ€œ[MinimiseClass
iconsindiagrams]isenabledbydefaultâ€,whichappearsin
the source code as â€œminiâ€);
(2)compoundidentifiers(Antconstraintâ€œIfthevalueof[clonevm]
is trueâ€, clonevm vs. isCloneVm); and
(3)misspellings(ArgoUMLconstraintâ€œUseguillemots(Â«Â»)for
stereotypes(clearbydefault)â€ guillemots inthetextvsthe
correctguillemets in the code).
ThestandardtextretrievaltechniquesthatLasso-13usestopro-
cessthetextinoperandscannotsuccessfullyovercomethesemis-
matches.Thereare,however,techniquesthathavebeenspecifically
designed to tackle these situations (e.g., abbreviation expansion
[36,41],identifiersplitting[ 25,30],spellcheckers[ 5,58]),which
could be easily integrated into our approach.
ThenextmostcommoncauseforlowrankingsistheTLRThigh
scoresforunrelatedmethods.Thishappensmostlybecauseofterms
intheconstraintcontextthatareverycommononthesystemor
thathappenincombinationsthattheBM25scoringconsiderstobe
veryrelevant.Forexample,fortheAntconstraintâ€œdefaultforcache
stillisfalseâ€thegroundtruthESChasmaximumvaluefor COEand
ECO,butavalueofonly0 .03forCM.Thishappensfortworeasons:
(1)thegroundtruthESCisinafielddefinition,whichonlyhastwo
matching terms with the constraint context (cache and false); (2)
BM25 ranks longer methods with the word combination "resource
collection" (from the context) near the top of its list.
Implementation decisions can also cause this problem: for the
Log4Jconstraintâ€œIf[locationInfois]trueâ€,thereare6classesinthe
system with â€œlocationInfoâ€ properties, plus a class actually named
â€œLocationInfoâ€.Theusagesofanyofthesesymbolsarerankedhighly
not only by the TLRT, but also by Lasso-13 specific scoring, since
theyalsohaveoperandtermsincommon.ForaMyBatisconstraint,
the first 8 ranked methods contain the same error message: â€œError:
Cannotrollback.Nomanagedsessionisstarted.â€,whichmatches
terms form the context and causes them to be ranked highly. This
appears to be a commonly used pattern in this system that hinders
our approach, but can be addressed by removing error messages
fromtheESCblock.Onewaytoaddressthesesituationsistouse
thecodearoundtheESCtobetterunderstandofthesemanticsof
the ESC. Such exploration is subject of future work.
Finally,anexpectedtypeofconstraintimplementationthatisdif-
ficult for Lasso-13 to retrieve is the case where the enforcing state-mentisusedtocheckmultipleconstraints.Theseweredescribedby
1900
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Retrieving Data Constraint Implementations
Using Fine-Grained Code PatternsICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 3: Retrieval performance of Lasso-13 variations and their corresponding baselines.
Data Set Technique %H@1 %H@5 %H@10Avg. Method
RankAvg. Recall MRR
CDSLasso-13Luc 14 .1% (23) 45 .4% (74) 57 .7% (94) 35.48 1.6% 27 .5%
Lucene 11 .0% (18) 27 .6% (45) 39 .3% (64) 218.39 8.2% 19 .8%
Lasso-13VSM 11.7% (19) 39.9% (65) 49.7% (81) 39.4 81.6%22.9%
VSM 2.5% (4) 13.5% (22) 22.7% (37) 270.5 98.2%8.3%
Lasso-13LSI 11 .0% (18) 27 .6% (45) 39 .9% (65) 58.68 1.6% 19 .6%
LSI 4.9% (8) 9 .2% (15) 12 .9% (21) 3309 .69 8.8% 7 .3%
(a) Results on CDS (163 constraints)
VDSLasso-13Luc 39 .0% (53) 66 .9% (91) 77 .9% (106) 12.98 9.7% 51 .5%
Lucene 25 .7% (35) 52 .2% (71) 66 .2% (90) 66.09 8.5% 37 .5%
Lasso-13VSM 39.7% (54) 64.0% (87) 72.8% (99) 13.5 89.7%50.5%
VSM 18.4% (25) 38.2% (52) 44.1% (60) 90.1 98.5%27.6%
Lasso-13LSI 29 .4% (40) 52 .2% (71) 66 .2% (90) 22.78 9.7% 40 .9%
LSI 12 .5% (17) 22 .1% (30) 27 .9% (38) 1065 .79 9.3% 18 .0%
(b) Results on VDS (136 constraints)
CDS + VDSLasso-13Luc 25 .4% (76) 55 .2% (165) 66 .9% (200) 24.68 5.3% 38 .4%
Lucene 17 .7% (53) 38 .8% (116) 51 .5% (154) 148.99 8.3% 27 .8%
Lasso-13VSM 24.4% (73) 50.8% (152) 60.2% (180) 27.0 85.3%35.4%
VSM 9.7% (29) 24.7% (74) 32.4% (97) 188.3 98.3%17.1%
Lasso-13LSI 19 .4% (58) 38 .8% (116) 51 .8% (155) 41.48 5.3% 29 .3%
LSI 8 .4% (25) 15 .1% (45) 19 .7% (59) 2286 .29 9.0% 12 .2%
(c) Results on CDS + VDS (299 constraints)
Florezetal .[27],andserveasjustificationfortheinclusionofâ€œdata
definition statementsâ€ in the definition of the CIPs. For example,
for the SkyWalking constraint â€œ[instance_name] [m]ax length is
50â€,itscorrespondingenforcingstatementis if(value!=null&&
value.length() >lengthDefine.value()) . This statement is used
to check many properties in the system, namely those that use the
â€œLengthâ€annotation( lengthDefineisoftype Length),definedinthe
code of the system. Locating this enforcing statement would re-
quireidentifyingusagesoftheâ€œLengthâ€annotation(relevantinthis
case â€œ@Length(50) publicvolatile staticStringINSTANCE_NAME
="";â€),andaddtheconcretevalueoftheannotationtothecorre-
sponding operand, in this case lengthDefine.value() . While this
processwouldmostlikelyimprovetheperformanceofLasso-13,it
is outside of the scope of this paper.
In 9 of the 30 analyzed constraints, a true positive, different from
the ground truth was retrieved within the first 10 results. This
wasexpected,asFlorezetal . [27]documentedthatinsomecases,
one constraint isenforced in several places inthe code (e.g., when
it is involved in multiple features). Since the ground truth dataonlyannotatesasingleenforcingstatementperconstraint(even
if there are more), we do not count the extra enforcing statements
as true positives. Expanding the data sets to annotate all enforcing
statements for each constraints is subject of future work.Lasso-13Luc outperforms the Lucene-based baseline by
30% (66.9% vs 51.5%); Lasso-13VSM outperforms the VSM-
basedbaselineby70%(60.2%vs.35.4%);Lasso-13LSIout-
performs the LSI-based baseline by 163% (51.8% vs. 19.7%);
all in terms of %HITS@10.
5.3 RQ2 Results
ToevaluatehowaccuratelyLasso-13canpointtothecorrectenforc-
ing statement, we further examine the ESC lists for the evaluation
results. We perform all analyses on the combined CDS + VDS data.
The ESC ranks for the three Lasso variations are the same, as
the TLRT does not change which ESCs the AST-CIP componentmatches, only the method ranking (this is why we get the same
recall for all variations).
Table 4 shows the distribution of the ESC ranks for all 299 con-
straints. Lasso-13 places the correct enforcing statement in ESCrank 1 for 202 of 299 constraints (68%) of cases, and in 2-3 for 33
(11%). Lasso-13 does not return the correct enforcing statement
for 13 constraints (4%) ("None" in table), and does not return the
ground truth method for 44 (15%) ("N/A" in table).
We focus on the subset of constraints for which the Lasso-13
instances return method-level results in top 10 (i.e., 200 constraints
for Lasso-13Luc, 180 for Lasso-13VSM, and 155 for Lasso-13LSI),
shown in Table 4.
1901
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Juan Manuel Florez, Jonathan Perry, Shiyi Wei, and Andrian Marcus
Table 4: Distribution of the ESC ranks for constraints with
methodsretrievedintop10byeachbaselineandalsoforall
constraints.
ESC
RankTop 10 LSI Top 10 VSM Top 10 Luc. All
1 130 ( 83.9%) 148 ( 82.2%) 162 ( 81.0%) 202 (67.6%)
2â€“3 1 6( 10.3%)2 3 ( 12.8%)2 8 ( 14.0%)3 3 (11.0%)
â‰¥4 4(2.6%)4 ( 2.2%)5 ( 2.5%)7 ( 2.3%)
None 5 ( 3.2%)5 ( 2.8%)5 ( 2.5%)1 3 ( 4.3%)
N/A Â·Â·Â· 44 (14.7%)
Total 155 180 200 299
For the 200 constraints, Lasso-13Luc ranks the ground truth
enforcingstatementas1in162cases(81%),as2-3in28(14%),as
4+ in 5 (2.5%), and it does not point to the ground truth in 5 (2.5%).
For 155 constraints, Lasso-13LSI ranks the ground truth first in
130 cases (84% of 155), 2-3 in 16 (10%), 4+ in 4 (3%), and does not
point to it in 5 (3%). In other words, for the methods returned byLasso-13Luc in top-10, the approach pinpoints precisely 95% of
theESCwithinthereturnedmethod(81%inthetoppositionand
14% on position 2 or 3). For Lasso-13LSI, this figure is 94% (84% in
1, and 10% in 2).
WemanuallyexaminedtheESCresultsforthegroundtruthof
27 constraints: 10 where the ground truth ESC had a rank of 2-3, 7
wheretheESCrankwas4+(allsuchcases),and10whereLasso-13
did not return the ground truth ESC.
Inconsistentidentifiernaminginthesourcecodewasthelargest
cause of low-rankedor missed ESCs. For example, theJabRef con-
straint â€œIf a file is importedâ€ has the terms â€œfileâ€ and â€œimportedâ€
aspartofitsoperands, however,its enforcingstatementusesthe
term â€œloadedâ€ instead, and â€œfileâ€ appears inside this ESCâ€™s block,
giving it a score of 0 for COE, though it achieves a maximum score
forCOB.However,otherESCsinthemethodcontaintheseterms
because they are related in functionality, but do not enforce thesame constraint, for example an ESC containing the identifier
is
FileExportachieves a higher COEscore and is thus ranked higher.
Similarly, the enforcing statement of the JabRef constraint â€œIf thereare[parsing]problemsâ€usesthetermâ€œwarningâ€,whichcausesittonot be retrieved, while the string passed to the exception reporting
the problem does contain the term, which is returned as an ESC.
Inthreecases,thegroundtruthenforcingstatementcouldnotbe
found because it checks the opposite condition to the one specifiedintheconstraint, e.g.,theJabRefconstraintâ€œtherearemorethantwo
personsintheauthorlistâ€isimplementedas if(authors.length
<3). One way to address these cases is to look for the negation of
the constraints as well, but that is subject of future work.
Inthreecases,thegroundtruthenforcingstatementwasreturned
in position 2, and the ESC ranked first has the same score as the
ground truth ESC. This happens because both ESCs have the same
numberof termsintheir bodyandthesame matchingtermswith
the constraint operands. For example, in the JabRef constraint â€œan
export option is also specifiedâ€, the two ESCs are f(cli.isFile
Export())and the ground truth is if(cli.isExportMatches()) .
Both have the same number of terms and match only â€œexportâ€.For three constraints (different from those mentioned in the
previoussection)wefoundthetoprankedESCtobeatruepositive.
TheAntconstraintâ€œIfthemanifestisomittedâ€ischeckedintwo
places in the ground truth method. This is because the manifestis loaded on-demand, and so the object can be in a state wherethe manifest was provided by the user but has not been loaded.
The method checks once to see if the manifest has been loaded,
and attempts to load it if not, and then again to confirm that the
loadingreturnedanything(becauseitcanreturnnullifthemanifest
was omitted). Since our ground truth data only has annotated one
enforcing statement per constraint, Lasso-13 finds additional â€œtrue
positivesâ€fortheconstraintsthatareenforcedinmultipleplacesin
the code. Florez et al .[27]found that 71 (44%) of the constraints in
the CDS are enforced in multiple places. Creating a data set where
all enforcing statements are annotated is subject of future work.
Lasso-13ranksthecorrectenforcingstatementaccurately
for 79% of the 299 constraints (68% at rank 1 and 11% atrank 2-3). For the methods returned by Lasso-13Luc in
top-10,itaccuratelypinpoints95%oftheESCwithinthe
returned method (81% in at rank 1 and 14% at rank 2-3).
6 THREATS TO VALIDITY
Our evaluation is implicit and relies on data sets from previous
research and new data we produced for this paper. These data sets
are built following the same protocol and only contain a single
ground truth enforcing statement per constraint, even if there may
bemoreinsomecases.Theresultsmaybedifferentondatawith
more complete ground truth annotations.
Ourevaluationassumesa"perfect"user,asLasso-13isgiventhe
correct inputs for each constraint, specifically the operand list and
theconstrainttype,whichwerederivedfromeachconstraintbyanauthor,whoisfamiliarwithboththecatalogofdataconstrainttypes
anddataconstraints, ingeneral.Inareal-world situationtheuser
maynotbeabletoprovidethecorrectinputineachcase.Evaluating
how robust Lasso is with respect to incomplete or incorrect input
issubjecttofuturework.Tomitigatethisissue,theinputforthe
Lasso-13 instances and the baselines are the same.
Our evaluation is performed only on constraints that are imple-
mented with the 13 CIPs that Lasso-13 has detectors for. This is by
design, as our goal was to evaluate the performance in detecting
known patterns (i.e., corresponding to the detectors). Tackling the
presence of unknown patterns is part of our future work.
The correctness of the traces in our data sets is also a threat.
Even though the level of agreement between tracers is arguably
low(55%),wearguethisisactuallyhigh,duetotheveryunlikely
natureoftwotracersagreeingonaline-of-codetracebychance,asouragreementcriterionwasstrict(i.e., thetracershadtoreportthe
exactsamelines).Tomitigatethisthreat,eachtracewassetonly
after a discussion between two authors.
The weight calibration algorithm we used to set the parameters
for Lasso-13 might not have generated the optimal combination of
weights. Ho wever, we show that a relatively simple process with a
small data set provides values that are robust against overfitting,
hence we believe they will translate to other data sets.
1902
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Retrieving Data Constraint Implementations
Using Fine-Grained Code PatternsICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Asweanysuchempiricalstudy,externalvaliditydependsonthe
sizeofourdata.Giventhenoveltyofthiswork,onlytwoannotated
data sets exists for supporting this work (i.e., the one from [ 27]
and the one we created). To mitigate this threat, we annotated data
from systems not used in the previous study.
7 RELATED WORK
Lasso is related to automated requirements-to-code traceability
link recovery techniques, albeit it focuses on a specific subset of
therequirements(i.e., dataconstraints).Researchinthisfieldspans
decades and has produced a multitude of techniques that can trace
naturallanguageartifactstosourcecodeartifacts.Ourworkdiffers
from the existing approaches in two main ways: (1) the natural
language artifacts are data constraints, a source of information not
yetleveragedbyanyotherapproaches,and(2)Lassoretrievesboth
method-levelandline-of-code-levelcodeartifact,whichhasonly
been achieved with limited success in previous studies.
Improvements in the performance of these techniques have
originated from both the use of different retrieval models (VSM
[1,34,35,53],probabilistic[ 1,2,11,19],topicmodels[ 34,43,47,53],
machine/deep learning [ 31,51], AI techniques [ 6,63]), and the use
of alternate sources of information (code authorship [ 23,56], non-
functionalkeywords [ 45,46],dynamic analysis[ 24,29,52]).More
related to the present work, code structure has been exploited[
24,40,49,59,60], but only in the form of method/class relation-
ships, unlike the line-of-code patterns that enable our approach.
The fine-grained code patterns represent an additional source
of information that is orthogonal to those previously studied (pre-
sented above), and similar performance improvements as the onesreported here could be expected to be achieved by integrating any
of these approaches with Lasso, as the TLRT component.
Thesemanticgreptool[ 10]canbeusedtodefineandretrieve
patternsliketheCIPsthatenableLasso.Whilewechosetousea
parsingandanalysislibraryforJava(JavaParser[ 38])toimplement
the detectors for the AST-CIP component of Lasso-13, any tool
that can return a list of ESCs could be used instead.
The work by Blasco et al . [6]uses LSI and genetic algorithms
toretrievetracesatlowergranularitythanmethodsforanatural
languagerequirement,inaspecificcommercialvideogame.This
approachisfundamentallydifferentfromLasso-13,asitismeant
totracerequirementsthatarelargerthandataconstraints,andthatare assumed to be implemented in multiple code locations, each. In
contrastour techniqueassumes thateach dataconstraint will be
implemented in a discrete location inside a method, as observed by
previous work [ 27]. Additionally, their technique randomly selects
seed lines for the genetic algorithm based, and the results are non-
deterministic.Ourapproachbothusesspecificline-of-codepatterns
to build the ESCs and is deterministic.
Arelatedlineofresearchusesstaticanalysistoreverseengineer
business rules, usually from a legacy system where only the binarycodeisavailable[
14,20,21,33,37,61,62,65].Theseapproachesdif-
ferfromLassointhattheydonotusethetextofthebusinessruleasinput,insteadrelyonthedeveloperselectingrelevantinput/output
variables. From this setof variables they perform forwards or back-
wardslicing,andfindthebranchesintheslice,sinceconditional
branches are the locations where business rules are checked.Finally, recent research by Yang et al.[69] explored the imple-
mentation of data constraints in database-backed web applications.
They discovered that developers struggle with maintaining con-
sistent data constraints and with checking them across different
componentsandversionsoftheirwebapplications.Thisworkis
one of the main motivation behind our research.
8 CONCLUSIONS
Lassoisanoveltraceabilitylinkrecoverytechnique,designedas
framework, which uses fine-grained code patterns to enable the
retrieval of links with line-of-code granularity. Three concrete ver-
sionsofthisframework, Lasso-13Luc,Lasso-13VSM,andLasso-
13LSI were shown to achieve a %HITS@10 of 66.9%, 60.2%, and
51.8%, respectively, while outperforming their corresponding base-
lines by 30%, 70%, and 163%, respectively. Additionally, all three
Lasso-13variationscanreturn thecorrectlineofcodeimplemen-
tationwithinthefirst3ranksinthecorrespondingmethodfor79%
of constraints.
Thesefindingsshowthatempiricalknowledgeofthespaceof
constraint implementations and common-sense heuristics can en-
able effective retrieval at line-of-code granularity, while improving
the performance of method-level approaches.
Lassoisextensiblewithnewtypesofconstraintimplementation
patternmatchersand,withenoughsuchextensions,Lassocould
beusedtotraceanytypeofdataconstraintsimplementedwithanycurrent or future implementation patterns. Since Lasso operates atline-of-codelevel,weenvisiontoolsthatwillautomaticallyidentify
and change the enforcing statement when the underlying rules
change.
Researchers identified trace accuracy and trace granularity as
tworemaininggrandchallengesintraceability[ 3,18,44].Future
requirements-to-code traceability link recovery approaches can
bootstraponLasso,whichwillfindthelinesofcodeimplementingtheconstraintsembeddedintherequirements,andusetheseâ€œseedsâ€
to improve the accuracy of tracing the larger requirements. This
willnotonlyimprovetheaccuracyofcoarse-grainedtraceability,
but will also provide fine-grained links that can be directly used
when they are needed.
ACKNOWLEDGMENTS
This research was supported in part by grants for the US National
Science Foundation: CCF-1955837, CCF-1910976.
REFERENCES
[1]Giuliano Antoniol, Gerardo Canfora, Gerardo Casazza, Andrea De Lucia, and
Ettore Merlo. 2002. Recovering Traceability Links between Code and Documen-
tation.IEEE Transactions on Software Engineering 28, 10 (Oct. 2002), 970â€“983.
https://doi.org/10.1109/TSE.2002.1041053
[2]GiulianoAntoniol,GerardoCanfora,AndreaDeLucia,andEttoreMerlo.1999.
Recovering Code to Documentation Links in OO Systems. In Proceedings of
the 6th Working Conference on Reverse Engineering (WCRE). 136â€“144. https:
//doi.org/10.1109/WCRE.1999.806954
[3]Giuliano Antoniol, Jane Cleland-Huang, Jane Huffman Hayes, and Michael
Vierhauser. 2017. Grand Challenges of Traceability: The Next Ten Years.
arXiv:1710.03129 [cs] (Oct. 2017). arXiv:1710.03129 [cs]
[4]ApacheAnt.2021. Targets. https://archive.apache.org/dist/ant/manual/apache-
ant-1.10.6-manual.zip.
[5]Nicolas Bettenburg, Bram Adams, Ahmed E. Hassan, and Michel Smidt. 2011. A
LightweightApproachto UncoverTechnicalArtifactsin UnstructuredData.In
Proceedings of the 19th IEEE International Conference on Program Comprehension
(ICPC). 185â€“188. https://doi.org/10.1109/ICPC.2011.36
1903
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Juan Manuel Florez, Jonathan Perry, Shiyi Wei, and Andrian Marcus
[6]DanielBlasco,CarlosCetina,andÃ“scarPastor.2020.AFine-GrainedRequirement
Traceability Evolutionary Algorithm: Kromaia, a Commercial Video Game Case
Study.Information and Software Technology 119 (March 2020), 106235. https:
//doi.org/10.1016/j.infsof.2019.106235
[7]Board of Governors of the Federal Reserve System. 2020. Federal Reserve
Board Announces Interim Final Rule to Delete the Six-per-Month Limit onConvenient Transfers from the "Savings Deposit" Definition in Regulation D.
https://www.federalreserve.gov/newsevents/pressreleases/bcreg20200424a.htm.
[8] Board ofGovernors of theFederal ReserveSystem. 2020. RegulationD Reserve
Requirements. https://www.federalreserve.gov/boarddocs/supmanual/cch/int_depos.pdf.
[9]
Markus Borg, Per Runeson, and Anders ArdÃ¶. 2014. Recovering from aDecade: A Systematic Mapping of Information Retrieval Approaches to Soft-
ware Traceability. Empirical Software Engineering 19, 6 (2014), 1565â€“1616.
https://doi.org/10.1007/s10664-013-9255-y
[10]R.IanBull,AndrewTrevors,AndrewJ.Malton,andMichaelW.Godfrey.2002.
Semantic Grep: Regular Expressions + Relational Abstraction. In Proceedings
ofthe9thWorkingConferenceonReverseEngineering(WCRE).267â€“276. https:
//doi.org/10.1109/WCRE.2002.1173084
[11]Gerardo Canfora and Luigi Cerulo. 2006. Fine Grained Indexing of Software
RepositoriestoSupportImpactAnalysis.In Proceedingsofthe3rdMiningSoftware
Repositories Conference (MSR) (MSR â€™06). Association for Computing Machinery,
New York, NY, USA, 105â€“111. https://doi.org/10.1145/1137983.1138009
[12]Karel Cemus, Tomas Cerny, and Michael J. Donahoo. 2015. Evaluation of Ap-
proachestoBusinessRulesMaintenanceinEnterpriseInformationSystems.In
Proceedings of the 2015 International Conference on Research in Adaptive and Con-
vergent Systems (RACS) (RACS). Association for Computing Machinery, New
York, NY, USA, 324â€“329. https://doi.org/10.1145/2811411.2811476
[13]Thomas Cerny and Michael J. Donahoo. 2011. How to Reduce Costs of Business
Logic Maintenance. In Proceedings of the 6th IEEE International Conference on
Computer Science and Automation Engineering (CSAE), Vol. 1. 77â€“82. https:
//doi.org/10.1109/CSAE.2011.5953174
[14]Oscar Chaparro, Jairo Aponte, Fernando Ortega, and Andrian Marcus. 2012.
Towards the Automatic Extraction of Structural Business Rules from Legacy
Databases. In Proceedings of the 19th Working Conference on Reverse Engineering
(WCRE). 479â€“488. https://doi.org/10.1109/WCRE.2012.57
[15]OscarChaparro,JuanManuelFlorez,andAndrianMarcus.2017. UsingObserved
BehaviortoReformulateQueriesduringTextRetrieval-basedBugLocalization.
InProceedings of the 33rd International Conference on Software Maintenance and
Evolution (ICSME). 376â€“387. https://doi.org/10.1109/ICSME.2017.100
[16]Oscar Chaparro, Juan Manuel Florez, and Andrian Marcus. 2019. Using BugDescriptions to Reformulate Queries during Text-Retrieval-Based Bug Local-ization.Empirical Software Engineering 24, 5 (Oct. 2019), 2947â€“3007. https:
//doi.org/10.1007/s10664-018-9672-z
[17]OscarChaparro,JuanManuelFlorez,UnnatiSingh,andAndrianMarcus.2019.
Reformulating Queries for Duplicate Bug Report Detection. In Proceedings of the
26thInternationalConfereneonSoftwareAnalysis,EvolutionandReengineering
(SANER). 218â€“229. https://doi.org/10.1109/SANER.2019.8667985
[18]JaneCleland-Huang,OrlenaC.Z.Gotel,JaneHuffmanHayes,PatrickMÃ¤der,and
AndreaZisman.2014. SoftwareTraceability:TrendsandFutureDirections.In
Proceedings of the Future of Software Engineering (FOSE) of the 36th International
ConferenceonSoftwareEngineering(ICSE)(FOSE2014).ACM,NewYork,NY,USA,
55â€“69. https://doi.org/10.1145/2593882.2593891
[19]Jane Cleland-Huang, Raffaella Settimi, Chuan Duan, and Xuchang Zou. 2005.
UtilizingSupportingEvidencetoImproveDynamicRequirementsTraceability.
InProceedingsofthe13thIEEEInternationalRequirementsEngineeringConference
(RE). 135â€“144. https://doi.org/10.1109/RE.2005.78
[20]Valerio Cosentino, Jordi Cabot, Patrick Albert, Philippe Bauquel, and Jacques
Perronnet.2012. AModelDrivenReverseEngineeringFrameworkforExtracting
Business Rules Out of a Java Application. In Rules on the Web: Research and
Applications (Lecture Notes in Computer Science), Antonis Bikakis and Adrian
Giurca (Eds.). Springer, Berlin, Heidelberg, 17â€“31.
[21]ValerioCosentino,JordiCabot,PatrickAlbert,PhilippeBauquel,andJacquesPer-ronnet.2013.ExtractingBusinessRulesfromCOBOL:AModel-BasedFramework.
InProceedings of the 20th Working Conference on Reverse Engineering (WCRE).
409â€“416. https://doi.org/10.1109/WCRE.2013.6671316
[22]Scott Deerwester, Susan Dumais, G. W. Furnas, Thomas Landauer, and R. Harsh-
man.1990. IndexingbyLatentSemanticAnalysis. JournaloftheAmericanSociety
for Information Science 41 (1990), 391â€“407.
[23]DianaDiaz,GabrieleBavota, AndrianMarcus, RoccoOliveto, SilviaTakahashi,
andAndreaDeLucia.2013.UsingCodeOwnershiptoImproveIR-basedTraceabil-
ity Link Recovery. In Proceedings of the 21st IEEE International Conference on Pro-
gramComprehension(ICPC).123â€“132. https://doi.org/10.1109/ICPC.2013.6613840
[24]Marc Eaddy, Alfred V. Aho, Giuliano Antoniol, and Yann-GaÃ«l GuÃ©hÃ©neuc. 2008.
CERBERUS: Tracing Requirements to Source Code Using Information Retrieval,
DynamicAnalysis,andProgramAnalysis.In Proceedingsofthe16thIEEEInter-
national Conference on Program Comprehension. 53â€“62. https://doi.org/10.1109/ICPC.2008.39
[25]Eric Enslen, Emily Hill, Lori Pollock, and K. Vijay-Shanker. 2009. Mining Source
Codeto AutomaticallySplit IdentifiersforSoftware Analysis.In Proceedingsof
the 6th Mining Software Repositories Conference (MSR). 71â€“80. https://doi.org/10.
1109/MSR.2009.5069482
[26]Juan Manuel Florez, Oscar Chaparro, Christoph Treude, and Andrian Marcus.2021. Combining Query Reduction and Expansion for Text-Retrieval-Based
Bug Localization.In Proceedings ofthe 28thInternationalConferene onSoftware
Analysis,EvolutionandReengineering(SANER).166â€“176. https://doi.org/10.1109/
SANER50967.2021.00024
[27]Juan Manuel Florez, Laura Moreno, Zenong Zhang, Shiyi Wei, and Andrian
Marcus.2021. AnEmpiricalStudyofDataConstraintImplementationsinJava.
arXiv:2107.04720 [cs] (July 2021). arXiv:2107.04720 [cs]
[28]JuanManuelFlorez,JonathanPerry,ShiyiWei,andAndrianMarcus.2022. Re-
trieving Data Constraint Implementations Using Fine-Grained Code Patterns
(Replication Package). https://doi.org/10.5281/zenodo.5915650.
[29]MalcomGethers, HuzefaKagdi,Bogdan Dit,andDenysPoshyvanyk. 2011. An
AdaptiveApproachtoImpactAnalysisfromChangeRequeststoSourceCode.In
2011 26th IEEE/ACM International Conference on Automated Software Engineering
(ASE 2011). 540â€“543. https://doi.org/10.1109/ASE.2011.6100120
[30]Latifa Guerrouj, Massimiliano Di Penta, Giuliano Antoniol, and Yann-GaÃ«l
GuÃ©hÃ©neuc.2013. TIDIER:AnIdentifierSplittingApproachUsingSpeechRecog-nitionTechniques. JournalofSoftware:EvolutionandProcess 25,6(2013),575â€“599.
https://doi.org/10.1002/smr.539
[31]Jin Guo, Jinghui Cheng, and Jane Cleland-Huang. 2017. Semantically Enhanced
Software Traceability Using Deep Learning Techniques. In Proceedings of the
39th IEEE/ACM International Conference on Software Engineering (ICSE). 3â€“14.
https://doi.org/10.1109/ICSE.2017.9
[32]DonnaHarman.1993. OverviewoftheFirstTRECConference.In Proceedings
ofthe16thInternationalACMSIGIRConferenceonResearchandDevelopmentin
Information Retrieval (SIGIR â€™93). Association for Computing Machinery, New
York, NY, USA, 36â€“47. https://doi.org/10.1145/160688.160692
[33]Tomomi Hatano, Takashi Ishio, Joji Okada, Yuji Sakata, and Katsuro Inoue. 2016.
Dependency-Based Extraction of Conditional Statements for Understanding
BusinessRules. IEICETransactionsonInformationandSystems E99.D,4(2016),
1117â€“1126. https://doi.org/10.1587/transinf.2015EDP7202
[34]JaneHuffmanHayes,AlexDekhtyar,andSenthilKarthikeyanSundaram.2006.
Advancing Candidate Link Generation for Requirements Tracing: The Study
of Methods. IEEE Transactions on Software Engineering 32, 1 (Jan. 2006), 4â€“19.
https://doi.org/10.1109/TSE.2006.3
[35]JaneHuffmanHayes,AlexDekhtyar,SenthilKarthikeyanSundaram,E.Ashlee
Holbrook,SravanthiVadlamudi,andAlainApril.2007. REquirementsTRacing
On Target (RETRO): Improving Software Maintenance through TraceabilityRecovery. Innovations in Systems and Software Engineering 3, 3 (Sept. 2007),
193â€“202. https://doi.org/10.1007/s11334-007-0024-1
[36]EmilyHill,ZacharyP.Fry,HaleyBoyd,GiriprasadSridhara,YanaNovikova,LoriPollock,andK.Vijay-Shanker.2008. AMAP:AutomaticallyMiningAbbreviation
Expansions in Programs to Enhance Software Maintenance Tools. In Proceedings
ofthe5thMiningSoftwareRepositoriesConference(MSR) (MSRâ€™08).Association
for Computing Machinery, New York, NY, USA, 79â€“88. https://doi.org/10.1145/
1370750.1370771
[37]HaiHuang,Wei-TekTsai,SouravBhattacharya,XiaopingChen,YaminWang,and
Jianhua Sun. 1996. Business Rule Extraction from Legacy Code. In Proceedings of
the20thInternationalComputerSoftwareandApplicationsConference(COMPSAC) .
162â€“167. https://doi.org/10.1109/CMPSAC.1996.544158
[38] JavaParser. 2021. JavaParser. https://javaparser.org/.[39]
Joda-Time. 2021. GregorianJulian (GJ) Calendar System.
https://www.joda.org/joda-time/cal gj.html.
[40]Hongyu Kuang, Jia Nie, Hao Hu, Patrick Rempel, Jian LÃ¼, Alexander Egyed, and
Patrick MÃ¤der. 2017. Analyzing Closeness of Code Dependencies for Improving
IR-based Traceability Recovery. In Proceedings of the 24th IEEE International
Conference on Software Analysis, Evolution and Reengineering (SANER). 68â€“78.
https://doi.org/10.1109/SANER.2017.7884610
[41]DawnLawrie,HenryFeild,andDavidBinkley.2007. ExtractingMeaningfrom
Abbreviated Identifiers. In Seventh IEEE International Working Conference on
SourceCodeAnalysisandManipulation(SCAM2007).213â€“222. https://doi.org/
10.1109/SCAM.2007.17
[42]Jinfeng Lin, Yalin Liu, Qingkai Zeng, Meng Jiang, and Jane Cleland-Huang. 2021.
Traceability Transformed: Generating More Accurate Links with Pre-Trained
BERTModels.In Proceedingsofthe43rdIEEE/ACMInternationalConferenceon
SoftwareEngineering(ICSE).324â€“335. https://doi.org/10.1109/ICSE43902.2021.
00040
[43]Andrea De Lucia, Fausto Fasano, Rocco Oliveto, and Genoveffa Tortora. 2007.
RecoveringTraceabilityLinks inSoftwareArtifactManagementSystemsUsing
Information Retrieval Methods. ACM Trans. Softw. Eng. Methodol. 16, 4 (Sept.
2007). https://doi.org/10.1145/1276933.1276934
1904
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. Retrieving Data Constraint Implementations
Using Fine-Grained Code PatternsICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
[44]Patrick MÃ¤der, Paul L. Jones, Yi Zhang, and Jane Cleland-Huang. 2013. Strategic
TraceabilityforSafety-CriticalProjects. IEEESoftware 30,3(May2013),58â€“66.
https://doi.org/10.1109/MS.2013.60
[45]AnasMahmoud.2015. AnInformationTheoreticApproachforExtractingand
TracingNon-FunctionalRequirements.In Proceedingsofthe23rdIEEEInterna-
tional Requirements Engineering Conference (RE). 36â€“45. https://doi.org/10.1109/
RE.2015.7320406
[46]AnasMahmoudandGrantWilliams.2016. Detecting,Classifying,andTracing
Non-FunctionalSoftwareRequirements. RequirementsEngineering 21,3(Sept.
2016), 357â€“381. https://doi.org/10.1007/s00766-016-0252-8
[47]AndrianMarcus,JonathanI.Maletic,andAndreySergeyev.2005. Recoveryof
Traceability Links Between Software Documentation and Source Code. Inter-
national Journal of SoftwareEngineering and Knowledge Engineering 15, 05 (Oct.
2005), 811â€“836. https://doi.org/10.1142/S0218194005002543
[48]Michael McCandless, Erik Hatcher, and Otis GospodnetiÄ‡. 2010. Lucene in Action
(2nd ed ed.). Manning, Greenwich.
[49]Collin McMillan, Denys Poshyvanyk, and Meghan Revelle. 2009. Combining
TextualandStructuralAnalysisofSoftwareArtifactsforTraceabilityLinkRecov-
ery.InProceedingsofthe5thICSEWorkshoponTraceabilityinEmergingForms
of Software Engineering (TEFSE). IEEE Computer Society, Washington, DC, USA,
41â€“48. https://doi.org/10.1109/TEFSE.2009.5069582
[50]Chris Mills, Esteban Parra, Jevgenija Pantiuchina, Gabriele Bavota, and Sonia
Haiduc. 2020. On the Relationship between Bug Reports and Queries for TextRetrieval-Based Bug Localization. Empirical Software Engineering 25, 5 (Sept.
2020), 3086â€“3127. https://doi.org/10.1007/s10664-020-09823-w
[51]Mehdi Mirakhorli and Jane Cleland-Huang. 2016. Detecting, Tracing, and Moni-
toring Architectural Tactics in Code. IEEE Transactions on Software Engineering
42, 3 (March 2016), 205â€“220. https://doi.org/10.1109/TSE.2015.2479217
[52]Laura Moreno, JohnJoseph Treadway, AndrianMarcus, and Wuwei Shen.2014.
On the Use of Stack Traces to Improve Text Retrieval-Based Bug Localization.
InProceedingsofthe30thInternationalConferenceonSoftwareMaintenanceand
Evolution (ICSME). 151â€“160. https://doi.org/10.1109/ICSME.2014.37
[53]Rocco Oliveto, Malcom Gethers, Denys Poshyvanyk, and Andrea De Lucia. 2010.
OntheEquivalenceofInformationRetrievalMethodsforAutomatedTraceabilityLinkRecovery.In Proceedingsofthe18thIEEEInternationalConferenceonProgram
Comprehension (ICPC). 68â€“71. https://doi.org/10.1109/ICPC.2010.20
[54]Martin F. Porter. 1980. An Algorithm for Suffix Stripping. Program: electronic
libraryandinformationsystems 14,3(1980),130â€“137. https://doi.org/10.1108/
eb046814
[55]Mohammad MasudurRahman and Chanchal K.Roy.2018. Improving IR-based
BugLocalizationwithContext-awareQueryReformulation.In Proceedingsofthe
201826thACMJointMeetingonEuropeanSoftwareEngineeringConferenceand
Symposium on the Foundations of Software Engineering (ESEC/FSE 2018). ACM,
New York, NY, USA, 621â€“632. https://doi.org/10.1145/3236024.3236065
[56]Michael Rath, Jacob Rendall, Jin L. C. Guo, Jane Cleland-Huang, and PatrickMÃ¤der.2018. TraceabilityintheWild:AutomaticallyAugmentingIncomplete
Trace Links. In Proceedings of the 40th IEEE/ACM International Conference on
SoftwareEngineering(ICSE)(ICSEâ€™18).ACM,NewYork,NY,USA,834â€“845. https:
//doi.org/10.1145/3180155.3180207
[57]Stephen Robertson, Hugo Zaragoza, and Michael Taylor. 2004. Simple BM25Extension to Multiple Weighted Fields. In Proceedings of the Thirteenth ACM
International Conference on Information and Knowledge Management (CIKM â€™04).
Association for Computing Machinery, New York, NY, USA, 42â€“49. https://doi.
org/10.1145/1031171.1031181
[58]Per Runeson, Magnus Alexandersson, and Oskar Nyholm. 2007. Detection ofDuplicate Defect Reports Using Natural Language Processing. In Proceedings
of the 29th IEEE/ACM International Conference on Software Engineering (ICSE).
499â€“510. https://doi.org/10.1109/ICSE.2007.32
[59]Giuseppe Scanniello and Andrian Marcus. 2011. Clustering Support for Static
ConceptLocationinSourceCode.In 19thIEEEInternationalConferenceonPro-
gram Comprehension (ICPCâ€™11). 1â€“10. https://doi.org/10.1109/icpc.2011.13
[60]Giuseppe Scanniello, Andrian Marcus, and Daniele Pascale. 2015. Link Analysis
Algorithms for Static Concept Location: An Empirical Assessment. Empirical
SoftwareEngineering 20,6(Dec.2015),1666â€“1720. https://doi.org/10.1007/s10664-
014-9327-7
[61]HarryM.Sneed.2001. ExtractingBusinessLogicfromExistingCOBOLProgramsasaBasisforRedevelopment.In Proceedingsofthe9thIEEEWorkshoponProgram
Comprehension (IWPC). 167â€“175. https://doi.org/10.1109/WPC.2001.921728
[62]Harry M. Sneed and Katalin ErdÃ¶s. 1996. Extracting Business Rules from Source
Code. InProceedings of the 4th IEEE Workshop on Program Comprehension (WPC).
Berlin, Germany, 240â€“247. https://doi.org/10.1109/WPC.1996.501138
[63]Hakim Sultanov, Jane Huffman Hayes, and Wei-Keat Kong. 2011. Application
of Swarm Techniques to Requirements Tracing. Requirements Engineering 16, 3
(Sept. 2011), 209â€“226. https://doi.org/10.1007/s00766-011-0121-4
[64]Swarm. 2021. Seismic Wave Analysis and Real-Time Monitor: User Manualand Reference Guide. Version 2.8.10. https://github.com/usgs/swarm/blob/
97f8b2f26830c764b816ca0a74270d5c0db35d06/docs/swarm_v2.pdf.[65]Xinyu Wang, Jianling Sun, Xiaohu Yang, Zhijun He, and Srini Maddineni. 2004.
BusinessRulesExtractionfromLargeLegacySystems.In Proceedingsofthe8th
EuropeanConferenceonSoftwareMaintenanceandReengineering(CSMR).249â€“258.
https://doi.org/10.1109/CSMR.2004.1281426
[66]MingWen,RongxinWu,andShing-ChiCheung.2016. Locus:LocatingBugsfromSoftware Changes. In 2016 31st IEEE/ACM International Conference on Automated
Software Engineering (ASE). 262â€“273.
[67]KarlE.WiegersandJoyBeatty.2013. SoftwareRequirements (thirded.). Microsoft
Press, Redmond, WA.
[68]Graham C. Witt. 2012. Writing Effective Business Rules : A Practical Method.
Morgan Kaufmann, Waltham, MA.
[69]JunwenYang,UtsavSethi,CongYan,AlvinCheung,andShanLu.2020.Managing
Data Constraints in Database-Backed Web Applications. In Proceedings of the
42nd ACM/IEEE International Conference on Software Engineering (ICSE) (ICSE
â€™20). Association for Computing Machinery, New York, NY, USA, 1098â€“1109.
https://doi.org/10.1145/3377811.3380375
[70]Jian Zhou, Hongyu Zhang, and David Lo. 2012. Where Should the Bugs Be
Fixed?MoreAccurateInformationRetrieval-BasedBugLocalizationBasedon
Bug Reports. In Proceedings of the 34th IEEE/ACM International Conference on
Software Engineering (ICSE). 14â€“24. https://doi.org/10.1109/ICSE.2012.6227210
1905
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:52:10 UTC from IEEE Xplore.  Restrictions apply. 