Eflect: Porting Energy-Aware Applications to Shared
Environments
Timur Babakol
tbabako1@binghamton.edu
SUNY Binghamton
Binghamton, NY, USAAnthony Canino
acanino1@binghamton.edu
SUNY Binghamton
Binghamton, NY, USAYu David Liu
davidl@binghamton.edu
SUNY Binghamton
Binghamton, NY, USA
ABSTRACT
Developing energy-awareapplicationsis awell knownapproach
tosoftware-basedenergyoptimization.Thispromisingapproach
is however faced with a significant hurdle when deployed to the
environments shared among multiple applications, where the en-
ergy consumption effected by one application may erroneously
be observed by another application. We introduce Eflect, a novel
software framework for disentangling the energy consumption of
co-running applications. Our key idea, called energy virtualization,
enables each energy-aware application to be only aware of theenergy consumption effected by itsexecution. Eflect is unique
in its lightweight design: it is a purely application-level solution
thatrequiresnomodificationtotheunderlyinghardwareorsystemsoftware.ExperimentsshowEflectincurslowoverheadwithhigh
precision. Furthermore, it can seamlessly portexisting application-
levelenergyframeworks‚Äîoneforenergy-adaptiveapproximation
and the other for energy profiling ‚Äî to shared environments while
retaining their intended effectiveness.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware performance.
KEYWORDS
Energy Accounting, Energy Profiling, Power Disturbance, Concur-
rency
ACM Reference Format:
Timur Babakol, Anthony Canino, and Yu David Liu. 2022. Eflect: Port-
ing Energy-Aware Applications to Shared Environments. In 44th Inter-
national Conference on Software Engineering (ICSE ‚Äô22), May 21‚Äì29, 2022,
Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages. https://doi.org/10.
1145/3510003.3510145
1 INTRODUCTION
Energy efficiency in server-class computation platforms has sig-nificant impact on environmental sustainability as well as oper-ational cost. Energy-aware applications [
14,35] emerge as a crit-
ical dimension of energy-efficient computing. An energy-aware
application is awareof its own energy consumption during the ex-
ecution, and the observation can in turn guide application-specific
energy optimization. In software engineering, two prominent use
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrightsforthird-partycomponentsofthisworkmustbehonored.
For all other uses, contact the owner/author(s).
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9221-1/22/05.
https://doi.org/10.1145/3510003.3510145A C
Underlying OS and HardwareIf w > 4J acc = 0.90
else acc = 0.95
Energy
Reflection
Underlying OS and HardwareEnergy
ReflectionD B
method 1 : 3J
method 2 : 5J
ApplicationApproximation
PolicyEnergy
ProfileEnergy 
Aware Application(a) Energy-Adaptive Approximation (b) Energy Profiling
Figure 1: Energy Awareness in Shared Environments
scenarios of energy-aware applications are energy-adaptive approx-
imation[3,7,9‚Äì11,18,19,23,29,30,33,41] andenergy profil-
ing[2,4,5,8,15,17,22,25,27]. In Fig. 1 (a), application Amay
adpatively adjust some application-specific accuracy parameter,
accin the example, based on prior energy consumption of some
work unit, w. In Fig. 1 (b), an energy profiler C, whose runtime is
defactoanenergy-aware application,maywishtodetermine the
energyconsumptionofdifferentlogicalunitswithinanapplication,
such as which method consumes more energy, m1orm2.
1.1 The Challenge: Shared Environments
Energy-aware applications are supported through energy reflec-
tion, i.e., the ability of an application to observe its own energy
consumption. Naively exposing hardware energy data [ 12] to the
application however is fundamentally unsound in sharedenviron-
mentswhere multiple applications co-exist. To gain intuition on
why well-designed energy-aware applications may ill-behave in
shared environments, let us revisit Fig. 1. In Fig. 1 (a), a co-running
application B‚Äîenergy-awareornot‚Äîmayincurenergyconsump-
tion. The raw energy consumption wduring the execution of the
work unit may include that incurred by B. As a result, application
Amay degrade its accuracy to 0.9 even though the energy con-
sumption due to its execution remains lower than 4J. Similarly, the
hardware energy consumption during the m1(orm2) execution in C
may include that incurred by D: the quality of profiling results is
severely discounted due to the noise introduced by D.
The unfortunate phenomenon here is a fundamental hurdle
againstthe portability ofenergy-awareapplications:awell-behaved
software system at the idealized exclusive development site ill-
behavesattherealisticshared deployment site.Thelackofportabil-
itydirectlychallengesthe correctness ofenergy-adaptiveapproxima-
tion, and the usability of in-situ energy profilers. From time-shared
OS to cloud computing platforms, running applications in a shared
8232022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Timur Babakol, Anthony Canino, and Yu David Liu
environmentisabasicneedinmoderncomputing.Inthatsense,the
portability of energy-aware applications in shared environments is
critical for the future adoption of this promising technique.
This overlooked problem is hitherto only addressed by a small
number of OS-centric solutions [ 16,32,34,38‚Äì40]. In other words,
to support energy-aware applications, service providers must mod-
ify existing OSinfrastructure that impacts all applications and all
usersontheserver,achallengingcaseforadoptioninpractice.This
is particularly bad news to software developers : the feasibility of
their solution (energy-aware applications) becomes dependent of
whether the OS in the deployment environment has adopted the
OS features that commodity OS do not support, severely limiting
the benefit of energy-aware applications.
1.2 Our Solution: Eflect
We introduce Eflect, a novel and lightweight software framework
thatallowsenergy-awareapplicationstogracefullyporttoashared
environment without anymodificationto theOS. The key insight
of Eflect is tointroduce anintermediate layer of energyvirtual-
izationduring energy reflection, so that the application in a shared
environment can only observe itsshare of energy consumption,
with the illusion that it is exclusively responsible for the energy
consumptionwhenitperformsenergyreflection.Eflectvirtualiza-
tionsignificantlysimplifiesthe interface betweentheapplication
and the underlying system, and prevents the otherwise impedance
mismatch between the development site and the deployment site.
The portability of energy-aware application is achieved in that an
energy-aware application can make the strong assumption that all
itsenergyconsumptionobservationindeedresultsfromitsownex-
ecution,regardlesswhetherthedeploymentenvironmentisshared.
The central problem Eflect addresses is to compute an appli-
cation‚Äôs share of energy consumption in a shared environment.It continuously monitors both the application behavior and the
underlying system behavior, with several unique features:
Whole-StackMonitoringwithMinimalInterface. Determiningthe
application share of energy consumption in a shared environment
requires a clear accounting of the complex behavior of the systems
stack.Eflectisasophisticatedframeworkthatinternallymonitors
a rich number of states: the activities of individual threads within
an application, the activities of individual applications in a shared
environment, the mapping between the application threads and
the OS threads, the affinity of the threads and their migration, and
the raw energy consumption by the CPUs across multiple energy
domains. The most important observation however is that Eflect
iscapableofhidingthesedetailswithinitself,and leavingaminimal
interface to the energy-aware application. The design philosophycan be summarized as, ‚Äúlet us worry about these details, so an
energy-aware application developer does not have to.‚Äù
An Application-Level Solution with Decentralized Monitoring. Un-
like existing OS-centric solutions, Eflect is built at the level of the
application, a significantly more lightweight approach without the
need of any VM/OS/hardware modification. Each energy-aware
application in a shared environment is monitored by an individual
instance of Eflect, and there is no coordination across differentEflect instances. This fundamentally decentralized design prin-ciple is a win for incremental deployment: an Eflect-monitored
application can not only work with existing OS and hardware, but
also can it co-run with arbitrary applications: the co-running ap-
plications may or may not be monitored by Eflect, and may not
even be the same language runtime.
Fine Granularity. Eflect is a fine-grained andonlinesolution
thatinformstheshareofenergyconsumptionfor everytimeinterval
(inmillisecondscale)oftheapplicationexecutionof everythread in
theapplicationwhiletheapplicationisrunninginasharedenviron-
ment.Underthehoodof Eflect,theactivitiesoftheapplication
as well as the activities of the entire underlying system are also
monitored at this fine granularity, and the relative ratio between
the two is used to determine the energy reflection for each time
interval and each thread in each application.
1.3 Results
We evaluate Eflect through co-running state-of-the-art multi-
threaded Java benchmarks with representative server workloads
fromtheDacapobenchmarksuite[ 6],togetherwithTensorflow[ 1].
Our results show Eflect is capable of achieving energy virtualiza-
tion with high precision and low overhead.
As end-to-end case studies, we further investigate how to in-
tegrate Eflect with two application-level energy management
frameworks‚ÄîAeneas[ 10]forenergy-adaptiveapproximation,and
Chappie [ 2] for energy profiling ‚Äî and seamlessly transition them
to a shared environment.
To the best of our knowledge, Eflect is the first application-
level solution for porting energy-aware applications to a shared
environment.Overall,thispapermakesthefollowingcontributions:
‚Ä¢a novel application-level software framework for energy
reflection in shared environments
‚Ä¢a systematic evaluation on the precision, overhead, and scal-
ability of the framework
‚Ä¢acasestudyonhowourframeworkmayportexistingenergy-
adaptive approximation solutions to shared environments
‚Ä¢acasestudyonhowourframeworkmayportexistingenergy
profiling solutions to shared environments
Eflect is an open-source project, and it is endowed with an
API that allows the framework to be programmed for different
porting needs. The project is hosted on an anonymous GitHub site
https://github.com/pl-eflect.
2 MOTIVATING SCENARIOS
In this section, we motivate the need for Eflect with concrete
examples of challenges when deploying energy-aware applications
in shared environments.
2.1 Porting Energy-Adaptive Approximation
One example of an energy-adaptive approximation framework is
Aeneas [ 10]. In Aeneas, alternative algorithms and application
parameters can be programmed as knobs, and a goal for optimiza-
tion can be defined by the programmer as a reward, e.g., the joules
consumedforsomeunitofworkintheapplication.Atruntime,Ae-
neas dynamically adjusts program knobs to find a reward-optimal
824
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. Eflect: Porting Energy-Aware Applications to Shared Environments ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
(a) an Aeneas run of sunflow when co-run with another sunflow
(b) an Aeneas run of sunflow when co-run with eclipse
Figure 2: Aeneas-Monitored Co-Runs of sunflowwith An-
other Application (Each graph is a representative trace of
a run. The X-Axis represents the units of work (frames) in
elapsedtime.ThedottedhorizontallinerepresentstheSLA.)
combination of knobs that meets the reward target, also known as
Service Level Agreement (SLA). For example, Aeneas may moni-
torsunflow [6], a popular ray tracing benchmark. A knob can be
set for managing the level of image post-processing quality: less
post processing produces an approximated image with less energy
consumption. Processing each frame of sunflow can be defined
as a unit of work, and 35J can be set as the SLA for processing aframe. In an environment where only one Aeneas runtime is inplace, experiments show that Aeneas is effective in convergingon the knobs that meet the SLA [
10]. In other words, the energy
consumption per frame will approach 35J ‚Äúas time goes on.‚Äù
Porting Aeneas to a shared environment ho wever is non-trivial.
Figure2showstworunsofanAeneas-monitored sunflow,eachin
asharedenvironmentco-runningwithanotherapplication.First,inbothsubfigures,Aeneasappearstohaveadifficulttimetoconverge
atthetargetSLAof35Jquickly.Indeed,inFig.2a,asthe250
thframe
isstillrenderedwithmorethan35J,itisuncleariftheSLAwillever
bereached.Second,theconvergencebehaviorof sunflow ofFig.2a
and that of Fig. 2b are different. In other words, the same energy-
aware application with the same setting may end up behaving
differently depending on what other application is co-running.
2.2 Porting In-Situ Energy Profilers
An energy profiler example is Chappie [ 2]. Given an application,
Chappie is able to produce an energy footprint, i.e., the relative(a)h2profile in a single-application environment
(b)h2profile when co-run with sunflow
Figure3:ChappieEnergyFootprintfor h2(TheX-Axisrepre-
sents the percentage of energy consumption consumed by a
particular method. The Y-Axis lists the methods with top-10
energy consumption.)
energy consumption of program methods. Figure 3a shows a foot-
printproducedbyChappie‚Äîthetop-10energyconsumingmethods
are shown for brevity‚Äîfor h2[6], a transactional database. Here
it shows the top energy-consuming method of the application‚Äî
ValueDataType.compare ‚Äîand the relative difference in energy
consumption between any pair of methods.
Porting Chappie for deployment-site in-situ energy profiling in
a shared environment, however, is a challenge. Figure 3b shows
energy footprint produced by Chappie for h2in the presence of a
co-running instance of sunflow. While the top consuming method
ValueDataType.compare remains stable, the ranking of the re-
mainingmethodsisdifferentfromtheresultinasingle-application
environment. For example, ValueDataType.compareValues and
ValueArray.getMemory swap their positions in the ranking. The
root problem is that when the energy consumption of a method,
sayValueDataType.compareValues , is profiled by Chappie, the
co-running sunflow also incurs energy consumption, which may
be incorrectly attributed to the method.
3 EFLECT DESIGN
Overall, Eflect performs whole-stack monitoring to determine
the ‚Äúshare‚Äù of energy consumption an application incurs in a per-
thread and per-time-interval manner. An algorithm specification is
825
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Timur Babakol, Anthony Canino, and Yu David Liu
Algorithm 1 Eflect Algorithm
1typedef Pid Int // process ID
2typedef Tid Int // thread ID
3typedef Eidenum{E1,E2,...Eùëõ}// energy domain ID
4typedef Energy Float // energy in joules
5typedef Activity Float // activity in jiffies
6typedef Samplestruct{
7ùúñ:Map/angbracketleftEid,Energy/angbracketright// per domain energy
8ùúÇ:Map/angbracketleftEid,Activity /angbracketright// per domain activeness
9ùõø:Map/angbracketleftTid,Eid/angbracketright// thread affinity
10ùõæ:Map/angbracketleftTid,Activity /angbracketright// per thread activeness
11}
12typedef VEnergy Map /angbracketleftTid,Energy/angbracketright// virtual energy
13V:List/angbracketleftVEnergy/angbracketright// virtual energy store
14INTERVAL :Int // sampling interval
15function Main
16p‚ÜêGetCurretProcess ()
17loop at rate (INTERVAL)
18 s‚ÜêDoSample (p)
19V+‚ÜêDoVirtualize (s)
20function DoSample(p : Pid): Sample
21s‚ÜênewSample
22forein{E1,E2,...Eùëõ}do
23 s.ùúñ[e]‚ÜêEflectEnergy (e)
24 s.ùúÇ[e]‚ÜêEflectActivity (e)
25fortinGetDomainThreads (e)do
26ifp=GetPid(t)then
27 s.ùõø[t]‚Üê e
28 s.ùõæ[t]‚ÜêEflectActivity (t)
29return s
30function DoVirtualize(s : Sample ): VEnergy
31v‚ÜênewVEnergy
32for each (t,e)ins.ùõødo
33 v[t]=s.ùõæ[t]
s.ùúÇ[e]‚àós.ùúñ[e]
34return v
35function ReadEnergy(p : Pid ): VEnergy
36V‚ÜênewVEnergy
37for each vinVdo
38 V+‚Üêv
39return V
40function EflectActivity(Tid) : Activity // obtain thread activity
41function EflectActivity(Eid) : Activity // obtain domain activity
42function EflectEnergy(Eid) : Energy // obtain domain energy reading
43function GetCurrentProcess() : Pid // obtain current running process
44function GetDomainThreads(Eid) : Tid[] // obtain processes in an energy
domain
45function GetPid(Tid) : Pid // get thread‚Äôs process id
shown in Algorithm 1. For readers unfamiliar with the application-
system interaction w.r.t. energy consumption, we first provide a
background.
A Primer on the System Stack. Server-class computers gener-
ally consist of multiple sockets. In mainstream multi-core CPUs,
a socket coincides with the conceptual notion of the energy do-
main, the hardware unit where energy consumption is reported,
andwherethevoltageandfrequencycanbeindependentlyadjusted
through Dynamic Voltage and Frequency Scaling (DVFS) [ 28]. In
other words, when one core in an energy domain is adjusted toa particular frequency, all cores in the same energy domain areadjusted to the same frequency. In our algorithm, we represent
these energy domains by {E1,E2,...Eùëõ}(Line 3). The per-domainenergy consumption is represented as a mapping ùúñin the Sample
structure collected at each time interval.
Duringthelifetimeofanapplication,athreadmaymigratefrom
one CPU core to another. The CPU core occupied by a thread is
known as affinity. It is represented as a mapping ùõøin the Sample
structure. As the energy domain is the granularity for which we
canobtainrawenergyreadings,italsoservesastheunitforthread
affinity: a thread may migrate between CPU cores within an en-ergy domain but will not produce an observable difference in its
contribution to the underlying energy readings.
The activities of individual applications in the OS are repre-
sented through some abstract notion of time used by a process.
Time keeping is a basic service universally supported in practical
OS. In Linux-compatible systems, the most widely known repre-
sentation of time that indicate process/thread activities is the jiffy.
For example, Linux periodically updates the number of jiffies the
threads of a process consumes in the user mode and in the kernel
mode. In addition, the same form of time keeping is also supported
for hardware, i.e., how much time the CPU is actively running any
process. In our algorithm, the thread activity information is repre-
sented as a mapping ùõæ, and the hardware activity information is
represented as a mapping ùúÇ, both in the Sample structure.
AlgorithmOverview. Eflect first obtains the process ID of the
monitored application through GetCurrentProcess (Line 16). As
shown by the top-level loop at Line 17, Eflect continuously moni-
torsthebehaviorofanapplication,andateach INTERVAL ,itsamples
the underlying hardware and operating system resources (Line 18),
and performs virtualization (Line 19), i.e., determining the shareof energy consumption attributable to the application thread ofinterest. Each step of virtualization produces a piece of virtual
energydata, i.e., the energy consumption due to the application,
represented as VEnergy. Structurally, each piece of virtual energy
data is a mapping from each thread in the application (Tid) to its
respectiveenergyconsumption(Energy).As Eflectproceeds,it
accumulates VEnergy data in structure V, which Eflect exposes
to the monitored application‚Äîwe will discuss this interface at the
end of this section. Notation ‚Üêis standard assignment, and+‚Üê
denotes list addition. Let us now focus on the two core steps in the
loop, sampling and virtualization.
Sampling. FunctionDoSample(Lines20-29)representsasingle
sampling of underlying hardware and operating system resources.
Each step of sampling populates a Sample (Lines 6-11). Eflectgathers the energy (EflectEnergy) of each energy domain andrecords this information in map
ùúñat Line 23. Hardware activity,
in the form of jiffies per energy domain, is also sampled, stored in
mapùúÇat Line 24. For each thread that belongs to the application
wemonitor(Line26),werecorditsaffinityinmap ùõøanditsactivity
in mapùõæ, at Line 27 and Line 28. Function EflectActivity is
overloadedtoinspectOSactivitieseitherbythread,orbyhardware.
Virtualization. We compute the ‚Äúshare‚Äù of energy consumption
due to the application through function DoVirtualize (Line 19). It
returns a value of VEnergy, i.e., a mapping from the application‚Äôs
threads to their computed share of energy consumption, from the
raw Sample collected from the underlying system. Logically, this
826
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. Eflect: Porting Energy-Aware Applications to Shared Environments ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
means we assign a thread a share of energy consumption based
upon its ‚Äúslice‚Äù of activity on an energy domain.
Recall that we use OS time (jiffies) to represent the level of
activities of a thread. The curious question is why times e rv e sa sa
goodattributingfactorfor energy.Inphysics,energyiscomputedas
the multiplication of powerand time. An important insight here is
that within an energy domain, all cores share the same voltage and
frequency,andasaresult,the samepower accordingtoDVFSdesign.
More concretely, given a Sample swith thread affinity mapping
s.ùõø, for each thread tand its associated domain e(Line 32), we
computes.ùõæ[t]
s.ùúÇ[e], i.e., the proportion of e‚Äôs activity that came from
t. Because we have energy measurements associated with energy
domains,weattributeaportionofthedomainenergyconsumption
(s.ùúÇ[e]) to thread tbased upon its proportional activity on that
domain on Line 33.
Virtualization hides the details of wherea thread performed its
work on the system. If a thread tmigrates from energy domain E1
toE2, DoSample will capture tlatest location upon a subsequent
sampling; the associated round of DoVirtualize will take the
threads latest energy domain into account. From the application‚Äôs
viewpoint, it sees that its threads consume energy, but does not
need concern itself with any of the details.
Overall,DoVirtualize(anditshelperDoSample)mustbeaware
of underlying system details ‚Äî OS jiffies, OS affinity, CPU energy
domains ‚Äî- but all such details are hidden from the client appli-cation: the latter only needs to be aware what share of energy
consumption it is attributed for. Recall the key design philosophy
of our framework (¬ß 1): let Eflect worry about the details so that
an application developer does notneed to.
AbstractionandCustomization. Eflectisanopenprogrammable
framework that supports flexible customization. In our algorithm
specification, it is important to observe that our discussion on en-
ergydomains,threadaffinity,andthreadactivityareall abstract,in-
dependent of specific hardware topology, OS file system structures,
or platform-specific representations. While these latter details may
beimportanttotheimplementation,theyareagnostictotheoverallprocedures of DoSample and in particular DoVirtualize. In other
words, our virtualization algorithm itself is platform-independent.
Eflect exposes an API for developers to specialize Eflect to
theirownsystems.ThesefunctionsarelistedatLines40-45.WealsoprovideasimpleprogramminginterfaceforEflecttointeractwith
the application it monitors. The primary function is ReadEnergy,
which returns the accumulated energy attributed to the monitored
application,definedasthesumofentriesin V.SeveralAPIvariants
are also supported, such as timer-based read. The simple design
here is aligned with the design goal of Eflect, exposing a minimalinterfacetotheapplication.Inaddition,itdecouplestheapplicationfromthevirtualizationprocess:theapplicationcanquery itsenergy
consumption at a pace it wishes, which may differ from INTERVAL .
Forexample,inourcurrentimplementation(see¬ß4),rawenergy
consumptionvaluesarereadthroughqueryingahardwareregister,
a common feature in Intel architectures. Alternatively, users work-
ing with alternative CPU architectures may need to re-implement
the ReadEnergy function to address their specific architectures,
or query the A/D converter values of the external energy meter if
energy values are obtained through a meter. The remaining logicof Eflect does not need to be changed. As a second example, our
current implementation focuses on the most dynamic portion of
energyconsumptioninserver-classplatforms‚ÄîtheCPUandmem-
ory sub-systems ‚Äî but a user can also write her own ReadEnergy
function to further include energy consumption values of network
adaptors, storage systems, etc, depending on need.
4 EFLECT IMPLEMENTATION
Eflect is implemented in Java, and its runtime shares the JVM
of the monitored application. We now describe our default imple-
mentation of our API on a multi-socket Intel platform with Linux
(details in ¬ß 5.1).
Our implementation of the EflectEnergy API function resorts
to the Intel RAPL [ 12] interface to obtain energy samples. These
samplesarecollectedusingjRAPL[ 21],aJavalibraryforinterfacing
with RAPL. As Intel RAPL reports energy samples per CPU socket,
eachCPUsocketcorrespondstoanenergydomaininouralgorithmspecification,i.e.,
E1andE2.Eachenergysampleisacombinationof
socket energy consumption from CPU cores, CPU uncore (caches,
TLB, etc), and memory.
OurimplementationoftheEflectActivityAPIfunctionqueries
the Linux jiffy information through the procpseudo-file system,
so that each sample collection is effectively a file system read. Re-
call that EflectActivity is an overloaded function that may ei-
ther collect hardware jiffies or thread jiffies. We gather the former
through proc‚Äôs subdirectory stat, and the latter through proc‚Äôs
subdirectorynamedbyeachPID.Ineachsubdirectory,thejiffiesareseparated by user time, kernel time, interrupt time, and ‚Äúnice‚Äù time
(forinvokingutilitiesorshellscriptswithaparticularpriority).Our
Activity data is the sum of them. In the case of hardware jiffies,
the per-core data are also aggregated per energy domain.
The GetCurrentProcess, GetDomainThreads, and GetPID
API functions are implemented with simple Linux features. The
firstfunctionisimplementedbythe GLIBCsyscall getpid.Thesec-
ond function is implemented by searching the /proc/[Pid]/task
directory. The third function is implemented by parsing the data in
/proc/[Pid]/task/[Tid]/stat.
TheINTERVAL is set at 40ms. The considerations of this setting
are three folds. First, jiffies in Linux are updated at 4ms by default,
so any rate higher than 4ms/sample is unlikely to observe jiffychanges.Second,energysampling,especiallyatahighrate,maydisturb the energy behavior of the original application [
2]. We
choose to set the rate at one magnitude lower than 4ms, so that nobenchmark we experimented is disturbed. Third, the 40ms appears
to incur low overhead with high precision (detail in ¬ß 5.5).
One implementation consideration is that querying RAPL and
the OS file system synchronously may serialize both. Worse, if one
returnswithadelayduetounexpectedsystemevents,bothmaybe
delayed. In our implementation, both are sampled asynchronously,
each with a thread, producing information to a buffer. The threads
are managed by a ThreadPoolExecutor . With this design, each
iteration of DoSample only involve efficient buffer lookups.
827
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Timur Babakol, Anthony Canino, and Yu David Liu
5 EXPERIMENTAL VALIDATION
One experimental evaluation aims to answer the following ques-
tions.RQ1: can Eflect virtualize energy consumption of applica-
tions in a shared environment, with decentralized and fine-grained
monitoring? RQ2: what is the precision, runtime overhead, and
scalability characteristics of Eflect? RQ3: can Eflect help devel-
opersporttheirenergy-awareapplicationstoasharedenvironment,
while retaining their effectiveness in energy management? We an-
swerRQ1andRQ2in this section, and defer RQ3t o¬ß6 .
5.1 Experimental Setup
WeevaluateEflectonadualsocketIntelE5-2630v42.20GHzCPU
server, with 64GB DDR4 of RAM. Each socket CPU has 10 cores,
20 ‚Äúvirtual‚Äù cores with hyper threading enabled. The machine runs
Debian 4.9 OS, Linux kernel 4.9, with the default Debian power
governor. All experiments were run with Java 11 on top of Hotspot
VM build 11.0.2+9-LTS.
We evaluate Eflect through co-running state-of-the-art multi-
threaded Java benchmarks with representative server workloads
spanning scientific computing, databases, graphics, graph process-
ing, and machine learning. Most of our benchmarks come from the
latestreleaseoftheDaCapobenchmarksuite[ 6]1,whichweselect
for two reasons. First, Dacapo is arguably the most widely usedbenchmark suite for evaluating the performance of (non-mobile)
multi-threadedJavaapplications.Second,thenewestreleasehassig-
nificantly expanded the data size of several benchmarks (sunflow
andh2), and more importantly, it includes some new benchmarks
(such as graphchi for graph processing and biojava for bioinfor-
matics) representative of the recent workloads. To further evaluate
Eflect against machine learning workloads, we also managed to
haveEflectmonitorTensorflow[ 1]inasharedenvironment.Each
instance of Tensorflow classifies images using a DNN, Inception
v3 [36].
For each experiment, we exclude harness setup time, and run a
benchmark for 10 iterations with the first 5 discarded as a warmup.
Fig. 4 shows benchmark statistics.
5.2 Eflect Virtualization
To answer RQ1, we evaluate Eflect‚Äôs virtualization in a shared
environment where each application is an instance of Eflect. As
a result, each application produces a virtualized energy trace ofits runtime. To visualize, we present the normalized energy share
trace, defined as a time series where each data point is the fraction
of energy attributed to the Eflect-monitored application over the
entire hardware energy consumption of the same time interval.
Examples of homogeneous and heterogeneous workloads are
presented in Figs. 5 and 6. In each figure, the time stamps start
when all co-running benchmarks have started its 6ùë°‚Ñéiteration,
and end immediately before any of the co-running benchmarks
completesits10ùë°‚Ñéiteration(recallthatwediscardtheresultsofthe
first 5 iterations). We align the traces from each application based
on timestamps, and ‚Äústack‚Äù them on top of each other. Since the
1version evaluation-git+8b7a2dc, released in June 2019
2https://dacapo-bench.orgbenchmark workload total threads active threads execution time (s)
avrora large 71 69 175.98
batik large 9 8 17.41
biojava default 7 6 22.76
eclipse large 706 18 59.14
graphchi huge 53 50 246.78
h2 large 954 39 115.91
jython default 7 6 10.63
pmd large 8 6 54.65
sunflow large 88 46 61.13
xalan default 47 46 9.00
tensorflow inception v3 45 21 23.39
Figure 4: Benchmark Statistics (Workload refers to the data
sizespecifiedbyDaCapoforeachbenchmark;theirdetails
can be found on Dacapo‚Äôs website2. Total threads shows the
number of the threads created throughout the lifetime of
theapplication.Activethreadsshowsthemaximumnumber
of the concurrent threads at any interval. Execution time is
averaged across runs when the application is not co-running
with other applications. These statistics were produced with
the experimental setup described in ¬ß 5.1).
decision-making of energy attribution is decentralized, the sum at
each timestamp is not guaranteed to be 100%.
According to Eflect, both instances of sunflow in the homo-
geneous run observe approximately 50% of hardware energy over
the course of the runs, aligned with our intuition of co-running
two similar CPU-intensive applications. Note that Eflect does not
result in a naive, even ‚Äúsplit‚Äù of system energy: as one sunflow
instance receives greater virtualized energy, the other receives less,
as can be seen at timestamp 90.
Eachofthetwoinstancesof tensorflow exhibitsasymmetric
workload distribution across two sockets. Interestingly, we found
that when 2 instances of tensorflow co-run, each instance would
choose one CPU socket to place the vast majority of its workload,
and this results in asymmetric workload distribution. As shown in
Fig.5b,thegreenapplicationinstancedominatestheuseofsocket1,
while the red application instance dominates socket 2. Despite the
asymmetric behavior however, the key observation is that for both
sockets, the ‚Äústacked‚Äù energy consumption approximates at 100%.
This result is aligned with our intuition that Eflect divides up
systemenergyacrossapplicationsatapertimeintervalgranularity,
despite the decentralized instances of Eflect at work.
In the first heterogeneous case, shown in Fig. 6a, we examine
sunflow and h2. The energy is not uniformly distributed, with
nearly 95% being consumed by sunflow. This is not surprising as
sunflow is CPU-bound, while h2is I/O-bound.
In the second heterogeneous case in Fig. 6b, we examine h2and
pmd.AlthoughEflectreportsdifferentutilizationofeachsocketfor
the applications, the total energy is more evenly distributed, with
h2consuming 51.74% of the total energy, pmdconsuming 39.89%,
and the rest is attributed to the OS. As a source code analyzer,
pmdis also I/O bound, so it is expected that the energy is more
evenly shared across the two I/O bound benchmarks. First, observe
that the benchmarks exhibit phased behaviors (on both sockets),
where energy utilization goes through significant fluctuation in
a near periodic fashion. Second, despite the fluctuations, the sum
of the two benchmark‚Äôs normalized energy use is relatively stable,
indicating the vast majority of energy use is distributed to the two
828
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. Eflect: Porting Energy-Aware Applications to Shared Environments ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
(a) Two co-runs of sunflow.
(b) Two co-runs of tensorflow.
Figure 5: Normalized Energy Share Traces of Homogeneous
Co-Runs (The red line is vertically stacked on top of the
greenline,withthegreenlineshowsthenormalizedshare
of one application, and the red line shows the sum of that of
both. The X-Axis represents the elapsed time.)
(a) Co-run of sunflow (green) and h2(red).
(b) Co-run of h2(green) and pmd(red).
Figure 6: Normalized Energy Share Traces of Heterogeneous
Co-Runs (The red line is vertically stacked on top of the
greenline,withthegreenlineshowsthenormalizedshare
of one application, and the red line shows the sum of that of
both. The X-Axis represents the elapsed time.)
applications.Sometimestampsinsocket2aretheexceptiontothis
trend. This is possible when both benchmarks are waiting for I/Os.Figure 7: Raw Energy Traces for Co-Runs. (The red line is
verticallystackedontopofthegreenline,withthegreenline
shows the energy consumption (in joule) of one application
during an interval, and the red line shows the sum of that
of both. The black line shows total energy consumed by the
hardware(socket)duringtheinterval.TheX-Axisrepresents
the elapsed time intervals.)
Before we proceed, we would like to distinguish between the
normalized energy share trace we introduced earlier and the raw
energy trace, a time series of raw energy consumption. An example
is shown in Fig. 7. As this figure shows, the hardware energy con-
sumption does fluctuate as time elapses. The top flat-line in Fig. 5
and Fig. 6 instead reveals that the overall share(in percentage) of
energy consumption attributed to the applications is close to all
consumed by the hardware.
In the rest of the section, we address RQ2.
5.3 Scalability
We next evaluate how Eflect virtualization scales with an increas-
ing number of applications. Scalability is important in applying
Eflect in a production-like environment, where the server may
consolidate applications.
ResultswithadditionalinstancesarepresentedinFig.8.Overall,
the data is consistent with what was shown in Fig. 5: as the num-
ber of applications increases, similar energy shares are intuitively
divided among the co-running applications. The consistency here
is remarkable in the presence of dencentralization : each Eflect
runtime makes independent decisions on how energy share is com-puted, and they happento match up well without any coordination.
One interesting observation is that the variations in energy be-
haviorbecomemorepronouncedastheapplicationcountincreases:
in the 5-co-run figure, the ‚Äúup‚Äù and ‚Äúdown‚Äù of individual lines (ex-
ceptthetopline)aremorenoticeablethanthoseofa3co-runfigure.
The resource competition between applications is exposed, which
is expected from CPU-intense workload. Despite the fluctuations
of individual applications, Eflect is capable of achieving a stable
sum: the top line ‚Äî the sum of all individual energy shares ‚Äî is
around 100% and remains flat throughout the runtime.
In Fig. 9, we further show a heterogeneous co-run of 4 Eflect-
monitoredapplications.Again, sunflow dominatestheenergyshare
(around75%),followedby xalan(around18-20%),thenby graphchi
(around 4-5%), and finally by h2. This is aligned with our general
knowledgeontheCPU-intensivenessofthesebenchmarks.Further-
more, observe that the top line closely matches 100% of hardware
energy consumption.
829
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Timur Babakol, Anthony Canino, and Yu David Liu
(a) 3 co-runs
(b) 4 co-runs
(c) 5 co-runs
Figure8:NormalizedEnergyShareTracesofCo-RunsWith3-
5sunflow Co-Runs. (The red line is vertically stacked on top
ofthe greenline,with thegreenline showsthenormalized
share of one application, and the red line shows the sum of
that of both. The X-Axis represents the elapsed time.)
Figure 9: Normalized Energy Share Traces of Heterogeneous
Co-Runs of sunflow,xalan,h2, and graphchi . (The red line
is vertically stacked on top of the green line, with the green
line shows the normalized share of one application, and the
redlineshowsthesumofthatofboth.TheX-Axisrepresents
the elapsed time.)
5.4 Precision
Precision evaluation for energy accounting in the shared environ-
ment is a challenging task. In particular, note that it would be
unsoundtoconsidertheenergytraceofanapplicationwhileitruns
in isolation as a baseline and compare it against its energy tracewhile co-running with others. Indeed, co-scheduling (e.g., [ 13,24])
isaclassictechniqueforimprovingenergyefficiency,andthisopti-
mization is rooted on the fact that an application while co-running
mayexhibita differentenergybehavior(i.e.,lessenergy)thanwhen
it runs in isolation.
Thedecentralizednatureof Eflectprovidesaninterestingalter-
nativeforprecisionevaluation.Akeyinsightfromourdiscussionof
Fig. 5, Fig. 6, and Fig. 8 is that the ‚Äútop flat line‚Äù is aligned with our
intuitionofprecision:despitethedecentralizeddecision-makingbyindividualEflectruntimes,thesumoftheirindividualenergycon-sumptionshouldaddupclosetothehardwareenergyconsumption.
Asignificantmisalignmentbetweenthetwowouldbeanindication
that Eflect mis-attributes energy.
Weconcretizeourintuitionwithtwometrics‚Äî gapandcorre-
lation‚Äî to study the precision of Eflect. Gap is defined as the
average normalized distance between the sum of raw energy con-
sumption of individual applications and the raw energy consump-
tion of the hardware per time interval.
Correlation is defined as the Pearson‚Äôs Correlation Coefficient
(PCC)betweenthestackedrawenergytraceoftheapplicationsand
therawenergytraceofthehardware.Asametric,gapindicatestheoverallmis-alignmentbetweenwhatEflectattributesandwhatthe
machine consumes. Correlation in addition offers further evidence
on alignment by taking the temporal dimension into consideration.
The gap and correlation results are produced using the data
collected in the virtualization experiments and are presented inFig. 10a and Fig. 10b respectively. Observe that across all bench-
markswith2 co-runs,theaveragegapis low(averagedat 3.15%),
indicating the misalignment is small. The correlation is high, with
an average of 0.90, where 0.70 is the golden standard for strongly
correlation. Overall, the combination result of low gap and high
correlation provides evidence on the precision of Eflect.
Moreencouragingly,ourprecisionresultsscaleswiththenumber
of applications. When compared with their counterparts of co-running 2 instances, co-running more than 2 instances does not
appeartoimpactprecisionsignificantly,bothingapandcorrelation.
It is worth pointing out that Eflect is capable of attributing the
energy consumption due to systemcalls to the calling application,
because the jiffies we use for attribution consist of both kernel
mode jiffies and user mode jiffies for each application; see ¬ß 4.
5.5 Overhead
We now discuss the impact of Eflect on execution time. We com-
pute the percentage difference of the execution time between anoriginal benchmark run and an Eflect-monitored run. Over allbenchmarks, Eflect incurs a 1.66% overhead for co-running 2
benchmark instances, as shown in Fig. 10c.
The same figure shows overhead appears to scale reasonably
well. As seen here, the overhead does not appear to follow a trend
ofincreasewhenthenumberofapplicationsincreases.Forexample,
as the number of runtime instances increases, neither batiknor
h2 shows a pattern of increased overhead.
5.6 Raw/Additional Data
Our project website contains the full raw data. It also includes co-
runscenariosthatweleaveoutduetospace,suchasheterogeneous
830
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. Eflect: Porting Energy-Aware Applications to Shared Environments ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
(a) Gap
(b) Correlation
(c) Overhead
Figure 10: Precision and Overhead. The number after the
benchmark name indicates the number of co-runs.
combinations (Fig. 9) or the precision and overhead results for
other benchmarks (Fig. 10) when co-running applications are 3 or
5 instances.
6 EFLECT CASE STUDIES
Toanswer RQ3,wenextperformtwocasestudiesofportingenergy-
aware frameworks with Eflect.
6.1 Eflect for Aeneas
WefirstdemonstratethebenefitofportingAeneastoenableenergy-
adaptive approximation in a shared environment with Eflect.
Fig. 11 shows two Aeneas runs of sunflow while the appli-
cation is monitored by Eflect, which corresponds to the same(a) co-run with another sunflow
(b) co-run with eclipse
Figure 11: Eflect-Monitored Aeneas-Enhanced Co-Runs of
sunflowwithAnotherApplication(TheX-Axisrepresentsthe
unitsofwork(frames)inelapsedtime.Thedottedhorizontal
line represents the SLA.)
experiments we introduced in Fig. 2. As shown, Eflect greatly en-
hances Aeneas optimization in a shared environment. In Fig. 11a,
Aeneas quickly converges to the target 35J SLA after 50 frames,
as opposed to its counterpart‚Äôs sub-optimal convergence without
Eflect in Fig. 2. In addition, the sunflow co-run with eclipse in
Fig. 11b also converges in a similar time frame.
Fig. 12 shows a co-run of Aeneas-enhanced sunflow where
both applications are Aeneas-enhanced, each targeting a different
SLA. This presents a challenging environment for both Eflect
virtualizationandtheAeneasoptimizer:bothinstancesof Aeneas-
enhanced sunflow‚Äôs perform online adaptive approximation, with
eachinstancepotentiallyadjustingthesystemenergyconsumption
whileEflecttriestopresentastablevirtualizationfortheother.As
itturnsout,eachinstanceof Aeneas-enhanced sunflow converges
to the their respective target SLA.
6.2 Eflect for Chappie
For our second case study, we use Eflect to port Chappie energy
profiling to a shared environment; in particular, we study the sta-
bilityof Chappie energy footprints of co-running applications. We
firstrunChappieonasingleinstanceofeachapplicationtoproduce
a representativeenergy footprint,and thenco-run twoinstances
of each application with Chappie using Eflect as a virtualization
layer to produce two energy footprints. We define the stability as
831
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Timur Babakol, Anthony Canino, and Yu David Liu
(a)sunflow instance with 35J SLA
(b)sunflow instance with 70J SLA
Figure 12: Eflect-Monitored Aeneas-Enhanced Co-Runs of
2sunflow‚ÄôswithDifferentSLAs(Thefirstapplicationtargets
35JSLA,andthesecondtargets70J.TheX-Axisrepresentstheunitsofwork(frames)inelapsedtime.Thedottedhorizontal
line represents the SLA.)
the PCC between each multi-application energy footprint and the
single instance footprint, aligned through method names.
We detail these results in Fig. 13. The data shows that Chappie
energy profiling results remain highly stable while being portedto the shared environment. The co-run energy footprints highly
correlate with their single instance counterparts, which indicates
thataprogrammerusingChappie+Eflecttoprofileanapplication
willseeconsistentenergyprofileseveninasharedenvironment.In
other words, despite co-running multiple applications may indeed
change the energy trace of each individual application, the relative
standingof methodenergyconsumptionwithineachapplication
depends more on the logic within each application, and it remains
stable.
Fig. 14 shows a computed footprint for h2. This footprint is
consistent with the single-run footprint in Figure 3a, and an im-provement over the shared environment case without Eflect in
Figure 3b.
6.3 Development Effort
Thecustomizationeffortforportingenergy-awareframeworkswith
support for shared environments is minimal. In our integration of
EflectwithAeneas,weprovideare-implementationof Aeneas‚Äôsbenchmark co-run 1 co-run 2
avrora 1.00¬±0.011.00¬±0.00
batik 0.98¬±0.071.00¬±0.03
biojava 1.00¬±0.001.00¬±0.01
eclipse 0.88¬±0.100.87¬±0.10
graphchi 0.89¬±0.060.89¬±0.07
h2 0.99¬±0.040.99¬±0.03
jython 0.89¬±0.140.90¬±0.14
pmd 0.99¬±0.060.99¬±0.07
sunflow 0.99¬±0.040.99¬±0.03
xalan 0.98¬±0.030.98¬±0.03
tensorflow 0.99¬±0.000.99¬±0.00
Figure13:EnergyFootprintCorrelationbetweenSingle-Runs
and Co-Runs with Eflect
Figure 14: Energy Footprint for h2in a Eflect Co-Run.
Rewardclass whose valuate method now calls Eflect‚Äôs ReadEn-
ergy (¬ß 3). In the Chappie customization, we reimplemented their
EnergySampler classtocallReadEnergyfromthe samplemethod.
Their original source code tracks thread migration through sam-
pling affinity. Since Eflect is already socket topology-aware, we
simplified their code. In both cases, we were able to complete the
customization within 1 hour.
7 THREATS TO VALIDITY
TheprimarytargetplatformsthatEflectisdesignedforareserver-
class computing systems. Our experimental setup and benchmark
selection reflect this assumption. We think Eflect may indeed be
customizedonotherplatformswhereenergyconsumptionmatters,
such as mobile/embedded systems. This can be achieved through
reimplementing a small number of APIs defined in ¬ß 3, but theexperimental effectiveness of Eflect on those platforms should
not be taken for granted. The use scenarios of co-running multiple
applications/apps in mobile/embedded systems do exist, but we
thinkthereisamorepressingneedforsupporttheminserver-class
systems where significant CPU/memory sharing across multiple
applications is a basic requirement. In mobile systems for instance,
the largest energy consumption components are the display [ 20],
where sharing across different apps is limited.
8 RELATED WORK
The essential question of how to regulate the share of energy con-
sumption to individual applications in a shared environment leads
832
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. Eflect: Porting Energy-Aware Applications to Shared Environments ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
to ‚Äúground-up‚Äù redesigns of operating systems. One classic exam-
ple is Currentcy [ 40] and its successor ECOSystem [ 39]. Just as
an OS can manage how CPU/memory resources are allocated to
processes, Currentcy manages how much energy is allocated or
delivered to processes. Another example with a similar design goal
is Cinder [ 32]. Strictly speaking, these solutions focus on energy
allocation instead of energy attribution, so their goals are different
from ours. That said, an energy-aware application in their frame-
works is only aware of the share of energy/power delivered by the
OS, so a parallel with ours can be set in terms of energy disentan-
glement. Unfortunately, extensive OS re-design is a hurdle to the
wider deployment of these attractive solutions.
AppScope [ 37] is an energy metering framework for Android
smartphones. It relies on an OS kernel modification to monitor
kernel/app activities, and in turn provide a breakdown on energy
consumption across hardware modules and systems/applications.
Power sandboxes [ 16] is another OS principal for mobile devices,
where an OS-level power sandbox can accurately attribute power
withlimitedhardwaresharingtoconsider.BothrequireOSchanges.
This requirement may be appropriate for their intended use con-
text ‚Äî mobile devices ‚Äî but can be challenging for adoption inservers (¬ß 1). Further afield, power containers [
34] is another OS
solution that builds a linear power model over hardware perfor-
mance counters on multi-core CPUs, such as cycles and last-level
cache requests, which serves as the basis for attribution of global
power to individual cores. this work differs from ours in that it
addresses energy attribution for hardware components instead of
applications. In Aequitus [ 31], multiple energy management ap-
plications thatmay adjust thefrequency of the underlyingCPUs
(through DVFS) are given an equal slice of time in scheduling in a
shared environment. The goal of that system is to ensure fairness
in energy management.
Anindependentproblemisenergyprofiling,i.e.,howtoattribute
applicationenergyconsumptiontoindividualsoftwarecomponentsandprogrammingabstractions withinanapplication.Eprof[
26]and
E-Android[ 15]aretwoexamplesthataccountforsmartphoneener-
gy/power by attributing them to different software/hardware func-
tionalities, such as phone, WiFi, or user-defined energy-consuming
events. We reviewed Chappie in ¬ß 2.
Finally,populartoolssuchasthe‚Äúscreentime‚ÄùfeatureoniPhones
and ‚Äúpower usage‚Äù feature on many Android phones support basic
functionalitiesoftrackingtheusagetimeofindividualapps.Eflect
is significantly finer-grained: its jiffy-based attribution is per time
interval per energy domain. Our use of jiffies as an indicator for
energyattributionisgroundedonthefactthatallcoresinthesame
energy domain has the same power during the same time interval.
The time-based energy estimation in the tools cited above however
does not conform to this assumption.
9 CONCLUSION
Eflect is a novel application-level software framework aiming to
port energy-aware applications to a shared environment. Eflect
monitors the activities of the underlying system in a fine-grained
manner, but exposes a minimal interface to the client application.
Through energy virtualization, Eflect can guide energy approxi-
mation and energy profiling frameworks to achieve their intendedgoals while avoiding energy entanglement. Eflect is a lightweight
approach thatrequiresno modificationto VM/OS/hardware,and
can be adopted to commodity computer systems.
ReflectionsandOutlook. Theportabilitychallengethat Eflect
addresses is based on our own experience. In prior efforts, we at-
temptedtoportexistingenergy-awaresolutions‚Äîthosethoroughly
evaluated in non-shared environments ‚Äî but they behaved poorly
in shared environments. The Eflect design we eventually came
up with is simple and easy to deploy, but the path leading to it was
a learning experience. In particular, this is a design space where
overhead, precision, and scalability all matter. For example, if we
hadignoredthreadaffinityormigrationinourdesign,theprecision
would suffer. As another example, if we had not taken a sampling-
basedapproachbutinsteadreliedonqueryingthreadjiffiesthrough
instrumentation, the overhead would rise significantly.
Inouropinion,therealexcitementof Eflectisthe bridgeroleit
playsforfutureresearch: enablesexistingapplication-levelenergy-
aware solutions to embrace platforms such as data centers andcloud servers with little additional effort. In essence, Eflect em-
powersdeveloperswithenergyvirtualizationinamulti-application
environment where energy-related developments would otherwise
be convoluted due to energy entanglement. Our case studies in ¬ß 6
demonstratetwoapplicationsof Eflectinenergy-relateddomains.
Now that the bridge is built, new doors may be opened for explor-
ing additional software engineering problems toward principled
energy management in shared environments. For example, future
research may systematically study the optimality and guarantees
when multiple energy-aware applications are approximated at the
same time in a data center setting. As another example, in-situenergy debugging tools may be designed for cloud servers, andnew opportunities may exist for deployment-site energy bug fix-ing when coupled with state-of-the-art techniques of automated
program repair. As yet another example, closer to the case studies
described in the paper, a developer may use an Eflect-enabledChappie to profile her Eflect-enabled Aeneas application in a
shared environment. Such a combination may enable adaptive en-
ergyoptimizationwithnewknobsrecommendedin-situinaserver
environment.
Acknowledgments. We thank Kenan Liu and Khaled Mahmoud
for their help during the development. This project is supported by
US NSF CNS-1910532.
REFERENCES
[1]Abadi, M., Barham, P., Chen, J., Chen, Z., Davis, A., Dean, J., Devin, M.,
Ghemawat, S., Irving, G., Isard, M., Kudlur, M., Levenberg, J., Monga, R.,Moore, S., Murray, D. G., Steiner, B., Tucker, P., Vasudevan, V., Warden,P., Wicke, M., Yu, Y., and Zheng, X. Tensorflow: A system for large-scalemachine learning. In 12th USENIX Symposium on Operating Systems Design
andImplementation(OSDI16) (Savannah, GA, Nov. 2016), USENIX Association,
pp. 265‚Äì283.
[2]Babakol,T.,Canino,A.,Mahmoud,K.,Saxena,R.,andLiu,Y.D. Calmenergy
accounting for multi-threaded java applications. In Proceedings of the 2020 ACM
JointMeetingonEuropeanSoftwareEngineeringConferenceandSymposiumonthe
Foundations of Software Engineering, ESEC/SIGSOFT FSE (Nov 2020), pp. 976‚Äì988.
[3]Baek, W., and Chilimbi, T. M. Green: a framework for supporting energy-
consciousprogrammingusingcontrolledapproximation. In PLDI‚Äô10:Proceedings
of the 31st ACM SIGPLAN Conference on Programming Language Design and
Implementation (June 2010), pp. 198‚Äì209.
[4]Banerjee, A., Chong, L. K., Ballabriga, C., and Roychoudhury, A. Energy-
patch: Repairing resource leaks to improve energy-efficiency of android apps.
833
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Timur Babakol, Anthony Canino, and Yu David Liu
IEEE Transactions on Software Engineering 44, 5 (2017), 470‚Äì490.
[5]Banerjee, A.,Chong, L. K.,Chattopadhyay, S., andRoychoudhury, A. De-
tecting energy bugs and hotspots in mobile apps. In Proceedings of the 22nd
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(New York, NY, USA, 2014), FSE 2014, Association for Computing Machinery,
p. 588‚Äì598.
[6]Blackburn, S. M., Garner, R., Hoffman, C., Khan, A. M., McKinley, K. S.,
Bentzur, R., Diwan, A., Feinberg, D., Frampton, D., Guyer, S. Z., Hirzel, M.,
Hosking, A., Jump, M., Lee, H., Moss, J. E. B., Phansalkar, A., Stefanoviƒá,
D., VanDrunen, T., von Dincklage, D., and Wiedermann, B. The DaCapobenchmarks: Java benchmarking development and analysis. In OOPSLA ‚Äô06,
pp. 169‚Äì190.
[7]Boston,B.,Sampson,A.,Grossman,D.,andCeze,L. Probabilitytypeinference
for flexibile approximate programming. In OOPSLA 2015: Proceedings of the 2015
ACMSIGPLANInternationalConferenceonObject-OrientedProgramming,Systems,
Languages, and Applications (Oct 2015), pp. 470‚Äì487.
[8]Bruce, B. R., Petke, J., and Harman, M. Reducing energy consumption using
geneticimprovement. In ProceedingsoftheGeneticandEvolutionaryComputation
Conference, GECCO 2015, Madrid, Spain, July 11-15, 2015 (2015), pp. 1327‚Äì1334.
[9]Canino, A., and Liu, Y. D. Proactive and adaptive energy-aware programming
with mixed typechecking. In PLDI2017:Proceedingsofthe38thACMSIGPLAN
Conference on Programming Language Design and Implementation (June 2017),
pp. 217‚Äì232.
[10]Canino, A., Liu, Y. D., and Masuhara, H. Stochastic energy optimizationfor mobile GPS applications. In Proceedings of the 2018 ACM Joint Meeting on
European Software Engineering Conference and Symposium on the Foundations of
Software Engineering, ESEC/SIGSOFT FSE (Nov 2018), pp. 703‚Äì713.
[11]Cohen,M.,Zhu,H.S.,Emgin,S.E.,andLiu,Y.D. Energytypes. In OOPSLA‚Äô12:
Proceedings of the ACM international conference on Object oriented programming
systems languages and applications (Oct 2012), pp. 831‚Äì850.
[12]David, H., Gorbatov, E., Hanebutte, U. R., Khanna, R., and Le, C. Rapl:Memorypowerestimationandcapping. In ISLPED‚Äô10:Proceedingsofthe16th
ACM/IEEEInternationalSymposiumonLowPowerElectronicsandDesign (New
York, NY, USA, 2010), ACM, pp. 189‚Äì194.
[13]Dhiman,G.,Marchetti,G.,andRosing,T.Vgreen:Asystemforenergyefficient
computing in virtualized environments. In Proceedings of the 2009 ACM/IEEE
International Symposium on Low Power Electronics and Design (New York, NY,
USA, 2009), ISLPED ‚Äô09, Association for Computing Machinery, p. 243‚Äì248.
[14]Flinn, J., and Satyanarayanan, M. Energy-aware adaptation for mobile appli-
cations. In Proceedings of the Seventeenth ACM Symposium on Operating Systems
Principles (New York, NY, USA, 1999), SOSP ‚Äô99, Association for Computing
Machinery, p. 48‚Äì63.
[15]Gao, X., Liu, D., Liu, D., Wang, H., and Stavrou, A. E-android: A new energy
profiling tool for smartphones. In 2017 IEEE 37th International Conference on
Distributed Computing Systems (ICDCS) (June 2017), pp. 492‚Äì502.
[16]Guo, L., Xu, T., Xu, M., Liu, X., and Lin, F. X. Power sandbox: Power awareness
redefined. In Proceedings of the Thirteenth EuroSys Conference (New York, NY,
USA, 2018), EuroSys ‚Äô18, ACM, pp. 37:1‚Äì37:15.
[17]Hao, S., Li, D., Halfond, W. G. J., and Govindan, R. Estimating mobile appli-
cation energy consumption using program analysis. In Proceedingsofthe2013
International Conference on Software Engineering (2013), ICSE ‚Äô13, IEEE Press,
p. 92‚Äì101.
[18]Hoffmann, H., Sidiroglou, S., Carbin, M., Misailovic, S., Agarwal, A., and
Rinard, M. Dynamic knobs for responsive power-aware computing. vol. 46,
Association for Computing Machinery, p. 199‚Äì212.
[19]Kansal, A., Saponas, S., Brush, A. B., McKinley, K. S., Mytkowicz, T., andZiola, R. The latency, accuracy, and battery (lab) abstraction: Programmer
productivityandenergyefficiencyforcontinuousmobilecontextsensing. vol.48,
Association for Computing Machinery, p. 661‚Äì676.
[20]Li, D., Tran, A. H., and Halfond, W. G. J. Making web applications moreenergy efficient for OLED smartphones. In 36th International Conference on
SoftwareEngineering,ICSE‚Äô14,Hyderabad,India-May31-June07,2014 (2014),
pp. 527‚Äì538.
[21]Liu, K., Pinto, G., and Liu, Y. D. Data-oriented characterization of application-
levelenergyoptimization. In FundamentalApproachestoSoftwareEngineering
(2015), Springer Berlin Heidelberg, pp. 316‚Äì331.
[22]Ma,X.,Huang,P.,Jin,X.,Wang,P.,Park,S.,Shen,D.,Zhou,Y.,Saul,L.K.,and
Voelker,G.M. edoctor:Automaticallydiagnosingabnormalbatterydrainissues
on smartphones. In Proceedings of the 10th USENIX Conference on Networked
Systems Design and Implementation (2013), nsdi‚Äô13, pp. 57‚Äì70.
[23]Manotas, I., Pollock, L., and Clause, J. Seeds: a software engineer‚Äôs energy-
optimizationdecisionsupportframework. In Proceedingsofthe36thInternationalConference on Software Engineering (2014), pp. 503‚Äì514.
[24]Merkel,A.,Stoess,J.,andBellosa,F.Resource-consciousschedulingforenergyefficiency on multicore processors. In Proceedings of the 5th European Conference
onComputerSystems (NewYork,NY, USA,2010),EuroSys‚Äô10, Associationfor
Computing Machinery, p. 153‚Äì166.
[25]Pathak, A., Hu, Y. C., and Zhang, M. Bootstrapping energy debugging on
smartphones: A first look at energy bugs in mobile devices. In Proceedings of
the10thACMWorkshoponHotTopicsinNetworks (New York, NY, USA, 2011),
HotNets-X, Association for Computing Machinery.
[26]Pathak, A., Hu, Y. C., and Zhang, M. Where is the energy spent inside my
app?:Finegrainedenergyaccountingonsmartphoneswitheprof. In Proceedings
of the 7th ACM European Conference on Computer Systems (2012), EuroSys ‚Äô12,
pp. 29‚Äì42.
[27]Pathak, A., Jindal, A., Hu, Y. C., and Midkiff, S. P. What is keeping my phone
awake? characterizing and detecting no-sleep energy bugs in smartphone apps.
InProceedingsofthe10thInternationalConferenceonMobileSystems,Applications,
andServices (NewYork,NY,USA,2012),MobiSys‚Äô12,AssociationforComputing
Machinery, p. 267‚Äì280.
[28]Pering, T., Burd, T., and Brodersen, R. The simulation and evaluation of
dynamic voltage scaling algorithms. In Proceedings of the 1998 International
Symposium on Low Power Electronics and Design (1998), ISLPED ‚Äô98, pp. 76‚Äì81.
[29]Pinto, G., Castor, F., and Liu, Y. D. Understanding energy behaviors of thread
managementconstructs. In The29thACMSIGPLANconferenceonObject-oriented
programming, systems, languages, and applications (OOPSLA‚Äô14) (October 2014).
[30]Pinto, G., Liu, K., Castor, F., and Liu, Y. D. A comprehensive study on theenergy efficiency of java‚Äôs thread-safe collections. In 2016 IEEE International
ConferenceonSoftwareMaintenanceandEvolution,ICSME2016,Raleigh,NC,USA,
October 2-7, 2016 (2016), pp. 20‚Äì31.
[31]Ribic, H., and Liu, Y. D. AEQUITAS: coordinated energy management acrossparallel applications. In Proceedings of the 2016 International Conference on
Supercomputing, ICS 2016, Istanbul, Turkey, June 1-3, 2016 (2016), O. Ozturk,
K. Ebcioglu, M. T. Kandemir, and O. Mutlu, Eds., ACM, pp. 4:1‚Äì4:12.
[32]Roy, A., Rumble, S. M., Stutsman, R., Levis, P., Mazi√®res, D., and Zeldovich,
N. Energy management in mobile devices with the cinder operating system. In
Proceedings of the Sixth Conference on Computer Systems (New York, NY, USA,
2011), EuroSys ‚Äô11, ACM, pp. 139‚Äì152.
[33]Sampson,A.,Dietl,W.,Fortuna,E.,Gnanapragasam,D.,Ceze,L.,andGross-
man, D. Enerj: Approximate data types for safe and general low-power compu-
tation. In Proceedings of the 32nd ACM SIGPLAN Conference on Programming
LanguageDesignandImplementation (New York, NY, USA, 2011), PLDI ‚Äô11, Asso-
ciation for Computing Machinery, p. 164‚Äì174.
[34]Shen, K., Shriraman, A., Dwarkadas, S., Zhang, X., and Chen, Z. Powercontainers: An os facility for fine-grained power and energy management onmulticore servers. In ProceedingsoftheEighteenthInternationalConferenceon
ArchitecturalSupportforProgrammingLanguagesandOperatingSystems (New
York, NY, USA, 2013), ASPLOS ‚Äô13, ACM, pp. 65‚Äì76.
[35]Sorber, J., Kostadinov, A., Garber, M., Brennan, M., Corner, M. D., andBerger, E. D. Eon: A language and runtime system for perpetual systems. InProceedings of the 5th International Conference on Embedded Networked SensorSystems(New York, NY, USA, 2007), SenSys ‚Äô07, Association for Computing
Machinery, p. 161‚Äì174.
[36]Szegedy,C.,Vanhoucke,V.,Ioffe,S.,Shlens,J.,andWojna,Z. Rethinkingthe
inception architecture for computer vision, 2015.
[37]Yoon,C.,Kim,D.,Jung,W.,Kang,C.,andCha,H. Appscope:Applicationenergy
metering framework for android smartphone using kernel activity monitoring.
InPresented as part of the 2012 USENIX Annual Technical Conference (USENIX
ATC 12)(Boston, MA, 2012), USENIX, pp. 387‚Äì400.
[38]Yoon,C.,Kim,D.,Jung,W.,Kang,C.,andCha,H. Appscope:Applicationenergy
metering framework for android smartphones using kernel activity monitoring.
InProceedings of the 2012 USENIX Conference on Annual Technical Conference
(USA, 2012), USENIX ATC‚Äô12, USENIX Association, p. 36.
[39]Zeng, H., Ellis, C. S., Lebeck, A. R., and Vahdat, A. Ecosystem: managing
energyasafirstclassoperatingsystemresource. In ASPLOS-X:Proceedingsofthe
10th international conference on Architectural support for programming languages
and operating systems (2002), pp. 123‚Äì132.
[40]Zeng, H., Ellis, C. S., Lebeck, A. R., and Vahdat, A. Currentcy: A unifying
abstraction for expressing energy management policies. In In Proceedings of the
USENIX Annual Technical Conference (2003), pp. 43‚Äì56.
[41]Zhu,H.S.,Lin,C.,andLiu,Y.D. Aprogrammingmodelforsustainablesoftware.
InProceedings of the 37th International Conference on Software Engineering -
Volume 1 (2015), ICSE ‚Äô15, IEEE Press, p. 767‚Äì777.
834
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:18:33 UTC from IEEE Xplore.  Restrictions apply. 