Linear-time Temporal Logic guided Greybox Fuzzing
Ruijie Mengâˆ—
National University of Singapore
Singapore
ruijie@comp.nus.edu.sgZhen Dongâˆ—â€ â€¡
Fudan University
China
zhendong@fudan.edu.cnJialin Li
National University of Singapore
Singapore
lijl@comp.nus.edu.sg
Ivan Beschastnikhâ€¡
University of British Columbia
Canada
bestchai@cs.ubc.caAbhik Roychoudhury
National University of Singapore
Singapore
abhik@comp.nus.edu.sg
ABSTRACT
Software model checking as well as runtime veri cation are veri-
 cation techniques which are widely used for checking temporal 
properties of software systems. Even though they are property 
veri cation techniques, their common usage in practice is in "bug 
 nding", that is,  nding violations of  temporal properties. Moti-
vated by this observation and leveraging the recent progress in 
fuzzing, we build a greybox fuzzing framework to  nd violations 
of Linear-time Temporal Logic (LTL) properties.
Our framework takes as input a sequential program written in 
C/C++, and an LTL property. It  nds violations, or counterexample 
traces, of the LTL property in stateful software systems; however, 
it does not achieve veri cation. Our work substantially extends 
directed greybox fuzzing to witness arbitrarily complex event or-
derings. We note that existing directed greybox fuzzing approaches 
are limited to witnessing reaching a location or witnessing simple 
event orderings like use-after-free. At the same time, compared 
to model checkers, our approach  nds the counterexamples faster, 
thereby  nding more counterexamples within a  given time budget.
Our LTL-Fuzzer tool, built on top of the AFL fuzzer, is shown 
to be effective in detecting bugs in well-known protocol imple-
mentations, such as OpenSSL and Telnet. We use LTL-Fuzzer to 
reproduce known vulnerabilities (CVEs), to  nd 15 zero-day bugs 
by checking properties extracted from RFCs (for which 12 CVEs 
have been assigned), and to  nd violations of both safety as well 
as liveness properties in real-world protocol implementations. Our 
work represents a practical advance over software model checkers
â€” while simultaneously representing a conceptual advance over 
existing greybox fuzzers. Our work thus provides a starting point 
for understanding the unexplored synergies among software model 
checking, runtime veri cation and greybox fuzzing.
âˆ—Joint  rst authors
â€ Corresponding Author
â€¡Zhen Dong and Ivan Beschastnikh participated in the work while being at the National 
University of Singapore as post-doc and visiting Associate Professor respectively.
.
This work is licensed under a Creative Commons Attribution-NoDerivs International 
4.0 License.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9221-1/22/05.
https://doi.org/10.1145/3510003.3510082ACM Reference Format:
Ruijie Meng, Zhen Dong, Jialin Li, Ivan Beschastnikh, and Abhik Roy-
choudhury. 2022. Linear-time Temporal Logic guided Greybox Fuzzing.In44th International Conference on Software Engineering (ICSE â€™22), May
21â€“29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 13 pages.
https://doi.org/10.1145/3510003.3510082
1 INTRODUCTION
Softwaremodelcheckingisapopularvalidationandverification
methodforreactivestatefulsoftwaresystems.Itisanautomated
techniquetochecktemporallogicproperties(constrainingevent
orderingsinprogramexecution)againstafinitestatetransitionsys-
tem. Model checking usually suffers from the state space explosion
problem;thisisexacerbatedinsoftwaresystemswhicharenatu-
rallyinfinite-state.Tocopewithinfinitelymanystates,theresearch
communityhaslookedintoautomaticallyderivingahierarchyof
finitestateabstractionsviapredicateabstractionsandabstraction
refinementoftheprogramâ€™sdatamemory(e.g.see[ 13]).Whenever
a counterexample trace is found in such model checking runs, the
trace can be analyzed to find (a) whether it is a spurious counterex-
ampleintroduceddue toabstractions,or(b)theroot-cause /bug
causing the counterexample. This has rendered model checking to
be a useful automated bug finding method for software systems.
Runtimeverificationisalightweightandyetrigorousverifica-
tionmethod,whichcomplementsmodelchecking[ 15,47,48].In
runtime verification, a single execution of a system is dynamically
checkedagainstformallyspecifiedproperties(e.g,temporallogic
properties).Specifically,formal propertiesspecifythecorrect be-
haviours ofa system.Then thesystem isinstrumented tocapture
events that are related to the properties being checked. During
runtime, a monitor collects the events to generate execution traces
and checks whether the traces conform to the specified properties.
When the properties are violated, it reports violations. Runtime
verificationaimstoachievealightweightbutnotfull-fledgedverifi-
cation method. It verifies software systems at runtime without the
needofconstructingmodelsaboutsoftwaresystemsandexecutionenvironments.However,togenerateeffectiveexecutiontraces,soft-
ware systems are required to be fed many inputs. These inputs are
usually obtained manually or via random generation [ 47]; there-
fore,runtimeverificationmaytakemuchmanualeffortandexplore
many useless inputs in the process of exposing property violations.
Paralleltotheworksinsoftwaremodelcheckingandruntime
verification, greybox fuzzing methods [ 1,3] have seen substantial
13432022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ruijie Meng, Zhen Dong, Jialin Li, Ivan Beschastnikh, and Abhik Roychoudhury
recentadvances.Thesemethodsconductabiasedrandomsearch
over the domain of program inputs, to find bugs or vulnerabilities.
Themainadvantageofgreyboxfuzzingliesinitsscalabilitytolarge
software systems. However, greybox fuzzing is only a testing (not
verification)methodanditismostlyusefulforfindingwitnessesto
simple oracles such as crashes or overflows. Recently there have
beensomeextensionofgreyboxfuzzingmethodstowardsgener-
atingwitnessesofmorecomplexoracles,suchastestsreachinga
location[ 17].However,generatinginputsandtracessatisfyinga
complextemporalpropertyremainsbeyondthereachofcurrent
greyboxfuzzingtools.Thus,todayâ€™sgreyboxfuzzingtechnology
cannotreplacethebug-findingabilitiesofsoftwaremodelchecking
and runtime verification.
Inthis paper, wetake astep forwardinunderstanding thesyn-
ergiesamongsoftwaremodelchecking,runtimeverificationand
greybox fuzzing. Given a sequential program and a Linear-time
TemporalLogic(LTL)property ğœ™,weconstructtheBÃ¼chiautomata
AÂ¬ğœ™accepting Â¬ğœ™, and use this automata to guide the fuzz cam-
paign. Thus, given a random input exercising an execution trace ğœ‹,
wecancheckthe"progress"of ğœ‹inreachingtheacceptingstates
ofAÂ¬ğœ™, and derive from AÂ¬ğœ™, the events that are needed to make
furtherprogressintheautomata.Furthermore,ingeneral,tracesac-
ceptedby AÂ¬ğœ™areinfiniteinlengthandvisitanacceptingstatein-
finitely often. To accomplish the generation of such infinite-length
traces in the course of a fuzz campaign, we can take application
state snapshots (at selected program locations) and detect whether
an accepting state of AÂ¬ğœ™is being visited with the same program
state. The application state snapshot can also involve a state ab-
straction if needed, in which case the counterexample trace can be
subsequently validated via concrete execution.
Wepresentafuzzing-basedtechniquethatdirectsfuzzingtofind
violationsof arbitraryLTLproperties .Tothebestofourknowledge,
no existing fuzzing technique is capable of finding violations of
complex constraints on event orderings such as LTL properties.
Existing works on greybox fuzzing are limited to finding witnesses
of simpleproperties such ascrashes or use-after-free.This is the
main contribution of our work: algorithms and an implementation
of our ideas in a tool that is able to validate any LTL property ,
thereby covering a much more expressive class of properties than
crashesoruse-after-free.Ourworkadaptsdirectedgreyboxfuzzing
(which directs the search towards specific program locations) to
findviolationsoftemporallogicformulae.Werealizeourapproach
for detecting violations of LTL properties in a new greybox fuzzer
tool called LTL-Fuzzer. LTL-Fuzzer is built on top of the AFL
fuzzer[1]andinvolvesadditionalprograminstrumentationtocheck
if a particular execution trace is accepted by the BÃ¼chi automaton
representing the negation of the given LTL property.
WeevaluatedLTL-Fuzzeronwell-knownandlarge-scalepro-
tocol implementations such as OpenSSL, OpenSSH, and Telnet.
We show that it efficiently finds bugs that are violations of both
safety and liveness properties. We use LTL-Fuzzer to reproduce
known bugs/violations in the protocol implementations. More im-
portantly,for50LTLpropertiesthatwemanuallyextractedfrom
Request-for-Comments (RFCs), LTL-Fuzzer found 15 new bugs
(representing the violation of these properties), out of which 12
CVEs have been assigned. These are zero-day bugs which have
previously not been found. We make the data-set of properties andthe bugs found available with this paper. We expect that in future,
otherresearcherswilltakeforwardthedirectioninthispaperto
detect temporal property violations via greybox fuzzing. The data-
setofbugsfoundbyLTL-Fuzzercanthusformabaselinestandard
for future research efforts. The dataset and tool are available at
https://github.com/ltlfuzzer/LTL-Fuzzer
2 APPROACH OVERVIEW
Atahighlevel,ourapproachtakesasequentialprogram ğ‘ƒanda
Linear-timeTemporalLogic(LTL)property ğœ™asinputs.Theatomic
propositionsin ğœ™refertopredicatesovertheprogramvariablesthat
canbeevaluatedtotrueorfalse.Anexampleisapredicate ğ‘¥>ğ‘¦
in which ğ‘¥andğ‘¦are program variables. Our approach identifies
program locations at which the atomic propositions in the LTL
property may be affected. For this, we find program locations at
whichthevaluesofvariablesintheatomicpropositionandtheir
aliasesmaychange.1Ourtechniqueoutputsa counterexample ,i.e.,a
concreteprograminputthatleadstoaviolationofthespecification.
Counterexample generation proceeds in two phases. In the first
phase, the program ğ‘ƒis transformed into ğ‘ƒ/prime. For this, we use code
instrumentationtomonitorprogrambehaviorsandstatetransitions
during program execution. We check these against the provided
LTL property. In the second phase, a fuzz campaign is launched for
the program ğ‘ƒ/primeto find a counterexample through directed fuzzing.
We illustrate our technique with an FTP implementation called
Pure-FTPd2. Pure-FTPd is a widely-used open source FTP server
whichcomplieswiththeFTPRFC3.Hereisapropertydescribedin
the RFCthat anFTP implementationmust satisfy.The FTPserver
muststopreceivingdatafromaclientandreplywithcode552when
user quota is exceeded while receiving data. Code 552 indicates
theallocatedstorageisexceeded.Throughoutthispaper,wewill
use this FTP property â€“ as represented by ğœ™â€“ to illustrate how our
technique finds property violations in Pure-FTPd.
2.1 LTL Property Construction
We start by manually translating the informal property in the
RFC into a LTL property ğœ™. For this, we search the Pure-FTPd
source code using keywords APPEand552. Source code analy-
sis reveals that (1) Pure-FTPd implements a quota-based mecha-
nism to manage user storage space and it works only when ac-
tivated, and (2) the command APPEis handled by the function
dostor() , in which user_quota_size is checked when receiving
data. When the quota is exceeded, the server replies with code 552
(MSG_QUOTA_EXCEEDED )viathefunction addreply() .Wetherefore
construct the property ğœ™as
Â¬ğ¹(ğ‘âˆ§ğ¹(ğ‘œâˆ§ğºÂ¬ğ‘›)) (1)
The negation of ğœ™is thus
ğ¹(ğ‘âˆ§ğ¹(ğ‘œâˆ§ğºÂ¬ğ‘›))
where definition of atomic propositions ğ‘,ğ‘œ,ğ‘›appear in Table 1.
Next, we identify program locations where the values of vari-
ables in atomic propositions in ğœ™may change at runtime. A simple
1In general, our approach requires an alias analysis to map the atomic propositions to
program locations.
2https://www.pureftpd.org/project/pure-ftpd/
3https://www.w3.org/Protocols/rfc959/
1344Linear-time Temporal Logic guided Greybox Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 1: Mapping between atomic propositions and
program locations (â€œ...â€ indicates omitted loop entries).
Predicate Atomic Prop. Locations
ğ‘ğ‘¢ğ‘œğ‘¡ğ‘_ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘’ğ‘‘ =ğ‘¡ğ‘Ÿğ‘¢ğ‘’ ğ‘ /angbracketleftğ‘“ğ‘¡ğ‘ğ‘‘.ğ‘,6072/angbracketright
ğ‘¢ğ‘ ğ‘’ğ‘Ÿ_ğ‘‘ğ‘–ğ‘Ÿ_ğ‘ ğ‘–ğ‘§ğ‘’>ğ‘¢ğ‘ ğ‘’ğ‘Ÿ_ğ‘ğ‘¢ğ‘œğ‘¡ğ‘ ğ‘œ/angbracketleftğ‘ ğ‘ğ‘“ğ‘’_ğ‘Ÿğ‘¤.ğ‘,12/angbracketright
/angbracketleftğ‘ ğ‘ğ‘“ğ‘’_ğ‘Ÿğ‘¤.ğ‘,43/angbracketright
ğ‘šğ‘ ğ‘”_ğ‘ğ‘¢ğ‘œğ‘¡ğ‘_ğ‘’ğ‘¥ğ‘ğ‘’ğ‘’ğ‘‘ğ‘’ğ‘‘ =ğ‘¡ğ‘Ÿğ‘¢ğ‘’ ğ‘›/angbracketleftğ‘“ğ‘¡ğ‘ğ‘‘.ğ‘,4444/angbracketright
/angbracketleftğ‘“ğ‘¡ğ‘ğ‘‘.ğ‘,3481/angbracketright
ğ‘™ğ‘œğ‘œğ‘_ğ‘’ğ‘›ğ‘¡ğ‘Ÿğ‘¦=ğ‘¡ğ‘Ÿğ‘¢ğ‘’ ğ‘™ /angbracketleftğ‘“ğ‘¡ğ‘ğ‘‘.ğ‘,4067/angbracketright...
example is the proposition ğ‘ğ‘¢ğ‘œğ‘¡ğ‘_ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘’ğ‘‘ =ğ‘¡ğ‘Ÿğ‘¢ğ‘’, which corre-
spondstotheprogramlocationwherequotacheckingisenabledin
Pure-FTPd. At another statement, ğ‘¢ğ‘ ğ‘’ğ‘Ÿ_ğ‘‘ğ‘–ğ‘Ÿ_ğ‘ ğ‘–ğ‘§ğ‘’>ğ‘¢ğ‘ ğ‘’ğ‘Ÿ_ğ‘ğ‘¢ğ‘œğ‘¡ğ‘,w e
consider the first statement of functions that are used to store data
in user directories. As a result, whenever data is written to user di-
rectories, those functions will be invoked and this proposition will
beevaluated,i.e.,allcaseswhereuserquotaisexceededwillbecap-
turedinanexecution.For ğ‘šğ‘ ğ‘”_ğ‘ğ‘¢ğ‘œğ‘¡ğ‘_ğ‘’ğ‘¥ğ‘ğ‘’ğ‘’ğ‘‘ğ‘’ğ‘‘ =ğ‘¡ğ‘Ÿğ‘¢ğ‘’,weidentify
functioninvocationsof addreply(552, MSG_QUOTA_EXCEEDED...)
which are a reply to clients when the quota is exceeded. Specific
program locations for each atomic proposition are listed in Table 1.
Their corresponding code snippets are shown in Listings 1, 2, 3,
and 4. Here, we show one code snippet per atomic proposition. For
convenience, we use a tuple /angbracketleftğ‘™,ğ‘,ğ‘ğ‘/angbracketrightin which ğ‘™denotes a program
location, ğ‘is an atomic proposition, and ğ‘ğ‘represents the predi-
cate for the atomic proposition ğ‘. At the end of our manual LTL
property generation process, we output a list ğ¿comprising such
tuples. For the example property, the manual process of writing
down the predicates and the accompanying tuples was completed
by one of the authors in 20 minutes.
Listing 1: Enabling the user quota option:<ftpd.c, 6072>.
6063 #ifdef QUOTAS
6064case'n': {
...
6072 us er_quota_size *= (1024ULL * 1024ULL);
6073 + if(1){
6074 + generate_event ("a");
6075 + if(liveness) record_state();
6076 + }
Listing 2: Writing to user directories:<safe_rw.c, 12>.
12 safe_write( const int fd,const void *constbuf_,
13 size_t count, const int timeout)
14 {
15 +if(user_dir_size > user_quota){
16 + generate_event("o");
17 + if(liveness) record_state();
18 + }
Listing 3: Replying msg_quota_exceeded:<ftpd.c, 4444>.
4442afterquota:
4443 if(overflow > 0) {
4444 addre ply(552, MSG_QUOTA_EXCEEDED , name);
4445 + if(1){
4446 + generate_event ("n");
4447 + if(liveness) record_state();
4448 + }
Listing 4: Entry of a loop statement:<ftpd.c. 4067>.
4066for(;;) {01
1a!o
2o!n
Figure 1: BÃ¼chi automata accepting traces satisfyingÂ¬ğœ™.
4067 + if(1){
4068 + generate_event ("l");
4069 + if(liveness) record_state();
4070 + }
2.2 Program Transformation
After deriving the property ğœ™and the list of tuples ğ¿, we transform
program ğ‘ƒintoğ‘ƒ/prime, which can report a failure at runtime whenever
ğœ™isviolated.Weperformthisprogramtransformationusingtwo
instrumentation modules: (1) Event generator, which generates an
eventwhenapropositionin ğœ™isevaluatedtotrueatruntime;(2)
Monitor,which collects the generated events into an execution
trace and evaluates if the trace violates ğœ™. If a violation is found,
the monitor reports a failure.
Event Generator. To detect changes in ğœ™â€™s proposition values
duringprogramexecution,theeventgeneratorinjectseventgen-
eration statements at specific program locations. To do so, the
generator takes the list ğ¿produced in the previous step as input.
For each tuple /angbracketleftğ‘™,ğ‘,ğ‘ğ‘/angbracketrightâˆˆğ¿, the generator injects a statement
if(ğ‘ğ‘) generate_event(" ğ‘");at the program location ğ‘™, such
thataneventassociatedwith ğ‘canbegeneratedwhencondition
ğ‘ğ‘is satisfied. For instance, the program location /angbracketleftğ‘“ğ‘¡ğ‘ğ‘‘.ğ‘,6072/angbracketright
correspondsto thepropositionvariable ğ‘(ğ‘ğ‘¢ğ‘œğ‘¡ğ‘_ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘’ğ‘‘ =ğ‘¡ğ‘Ÿğ‘¢ğ‘’)
and the enabling condition is true. The generator then inserts a
statement if(1) generate_event("a"); at line 6072 in ftpd.c
(seeListing1).Consequently,whenever /angbracketleftğ‘“ğ‘¡ğ‘ğ‘‘.ğ‘,6072/angbracketrightisreached,
an event associated with ğ‘is generated and recorded at runtime.
Instrumentation for the other tuples appear in Listings 2, 3, and 4.
Monitor.The monitor module inserts a monitorinto program ğ‘ƒ
toverifyiftheprogrambehaviorconformstoproperty ğœ™atruntime.
Specifically, the monitor produces a trace ğœby collecting events
that are generated during execution (by the instrumented code).
Itthenconvertsthenegationof ğœ™toaBÃ¼chiautomata AÂ¬ğœ™,and
checkswhether AÂ¬ğœ™acceptsğœ.Ifthetraceisaccepted,themonitor
reportsafailure,i.e., ğœ™doesnotholdin ğ‘ƒ.InourPure-FTPdexample,
the negation of ğœ™isğ¹(ğ‘âˆ§ğ¹(ğ‘œâˆ§ğºÂ¬ğ‘›)), and the converted BÃ¼chi
automata AÂ¬ğœ™is illustrated in Figure 1.
CheckingSafetyProperties. ABÃ¼chiautomataacceptsatrace ğœif
and only if ğœvisits an accepting state of the automata â€œinfinitely
oftenâ€(e.g.,state2inFigure1).Forthenegationofa safetyproperty
(Â¬ğœ™), the BÃ¼chi automata AÂ¬ğœ™accepts all traces which reach an
accepting state, since all traces reaching an accepting state will
loop thereinfinitely often. Since onlya finite prefixof the trace is
relevantforobtainingthecounter-exampleofasafetyproperty,the
monitor thus outputs a counterexample if it witnesses a trace that
leads to an accepting state in the BÃ¼chi automata AÂ¬ğœ™.
1345ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ruijie Meng, Zhen Dong, Jialin Li, Ivan Beschastnikh, and Abhik Roychoudhury
CheckingLivenessProperties. TheBÃ¼chiautomataofthenegation
ofğœ™accepts a trace ğœif and only if ğœvisits an accepting state of
AÂ¬ğœ™â€œinfinitely oftenâ€ (e.g., state 2 in Figure 1). For instance, an
infinite trace ğ‘,ğ‘œ,(ğ‘£)ğœ”in which ğ‘£â‰ ğ‘›will be accepted by AÂ¬ğœ™.
Formally,suchatracehastheform ğœ=ğœ1(ğœ2)ğœ”(|ğœ2|â‰ 0),where ğœ1
starts in an initial state of the BÃ¼chi automata AÂ¬ğœ™and runs until
anacceptingstate ğ‘ ofAÂ¬ğœ™,andğœ2runsfromtheacceptingstate
ğ‘ backtoitself.Witnessingatrace ğœ=ğœ1(ğœ2)ğœ”inwhich ğœ2occurs
â€œinfinitelymanytimesâ€isdifficultinpractice,sinceafuzzcampaign
visits program executions which are necessarily of finite length.
A straightforward approach to tackle this difficulty is to detect a
loopinthetraceandterminateexecutionwhenwitnessingtheloop
occursğ‘štimes, e.g., ğœ=ğœ1,ğ‘š
/bracehtipdownleft/bracehext/bracehext/bracehtipupright/bracehtipupleft /bracehext/bracehext/bracehtipdownright
ğœ2ğœ2Â·Â·Â·. This approach is insufficient
because witnessing ğœ2forğ‘štimes does not guarantee ğœ2occurs
infinitelyoften,forinstance for (i=0; i<m+2; i++){... ğœ2...}
may generate ğœ2forğ‘štimes but stops generating ğœ2afteri==m+1.
In this paper, we record program states when events associated
with atomic propositions occur in the execution and detect a state
loopinthewitnessedtrace.Iftheexecutionofthestatelooppro-
ducesğœ2, that means, trace ğœ2can be generated infinitely many
timesbyrepeatedlygoingthroughthestateloop.Asaresult,we
assume that the witnessed trace can be extended to an infinite
ğœ1(ğœ2)ğœ”shapedtrace.Considerfollowingtwosequenceswitnessed
in the execution
ğœğ‘’=ğ‘’0ğ‘’1Â·Â·Â·ğ‘’ğ‘–ğ‘’ğ‘–+1Â·Â·Â·ğ‘’ğ‘–+â„ğ‘’ğ‘–Â·Â·Â·ğ‘’ğ‘–+â„
ğœğ‘ =ğ‘ 0ğ‘ 1Â·Â·Â·ğ‘™ğ‘œğ‘œğ‘ğ‘ğ‘œğ‘‘ğ‘¦
/bracehtipdownleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehtipupright/bracehtipupleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehtipdownright
ğ‘ ğ‘–ğ‘ ğ‘–+1Â·Â·Â·ğ‘ ğ‘–+â„ğ‘ ğ‘–+â„+1Â·Â·Â·ğ‘ ğ‘–+2â„
whereğœğ‘’isasequenceofeventsassociatedwithatomicpropositions
thatoccurintheexecutionand ğœğ‘ isasequenceofprogramstates
thatarerecordedwheneventsoccur,forinstance ğ‘ ğ‘–indicatesthe
programstatethat isrecordedwhentheevent ğ‘’ğ‘–occurs.Suppose
ğ‘ ğ‘–is identical to ğ‘ ğ‘–+â„+1, thenğ‘ ğ‘–Â·Â·Â·ğ‘ ğ‘–+â„+1is a state loop and its loop
bodyisğ‘ ğ‘–Â·Â·Â·ğ‘ ğ‘–+â„.Whenever ğ‘ ğ‘–takesinput ğ¼ğ‘ ğ‘–Â·Â·Â·ğ‘ ğ‘–+â„+1thatleadsto
ğ‘ ğ‘–fromğ‘ ğ‘–+â„+1,ğ‘ ğ‘–will transition to ğ‘ ğ‘–itself. We assume that the
systemundertest isareactivesystemtakinga sequenceofinputs
anditisdeterministic,thatis,thesameinputalwaysleadstothe
sameprogrambehaviorintheexecution.Thus, ğ‘’ğ‘–ğ‘’ğ‘–+1Â·Â·Â·ğ‘’ğ‘–+â„can
begenerated infinitelymany timesby repeatedlyexecutinginput
ğ¼ğ‘ ğ‘–Â·Â·Â·ğ‘ ğ‘–+â„+1on state ğ‘ ğ‘–. Traceğœğ‘’=ğ‘’0Â·Â·Â·ğ‘’ğ‘–âˆ’1(ğ‘’ğ‘–Â·Â·Â·ğ‘’ğ‘–+â„)ğœ”can be
generated by running input ğ¼ğ‘ 0Â·Â·Â·ğ‘ ğ‘–(ğ¼ğ‘ ğ‘–Â·Â·Â·ğ‘ ğ‘–+â„+1)ğœ”, whereğ¼ğ‘ 0Â·Â·Â·ğ‘ ğ‘–is an
input that leads to state ğ‘ ğ‘–fromğ‘ 0andğ¼ğ‘ ğ‘–Â·Â·Â·ğ‘ ğ‘–+â„+1is an input that
leads toğ‘ ğ‘–fromğ‘ ğ‘–+â„+1.
As explained, occurrence of astate loop in the execution is evi-
dencethatthewitnessedtracecanbeextendedtoaninfinite ğœ1(ğœ2)ğœ”
shaped trace. We leverage this idea to find a violation of a liveness
property. When witnessing a trace in the execution that can be
extended to a ğœ1(ğœ2)ğœ”shaped trace that is accepted by BÃ¼chi au-
tomataAÂ¬ğœ™,weconsideraviolationofthelivenesspropertyhas
beenfound.Hence,forlivenesspropertyguidedfuzzing,weenrich
theprogramtransformationof ğ‘ƒtoğ‘ƒ/primeasfollows:(1)instrumenting
a function call that records the current program state when an
eventappearinginatranstionlabelof AÂ¬ğœ™occursintheexecution
(showninListing1-4)â€”specifically,functioncall record_state()
takes the current program state and generates a hash code forthe state at runtime; (2) instrumenting event-generating and state-
recording statements at the entries of forandwhileloop state-
mentsintheprogramtoobservepossibleloopsinfuzzing.Listing4
showstheinstrumentationofa forloopstatementinPure-FTPd.
More detailed and specific optimizations about state saving for
checking liveness properties, appear in Section 5.
2.3 Witnessing Event Sequences
Since program ğ‘ƒ/prime, generated in the previous step, reports a failure
whenğœ™is violated, we can find a counterexample for ğœ™by fuzzing
ğ‘ƒ/prime. An input that leads to such a failure is a counterexample. How-
ever,findinganinputofthiskindischallengingbecauseithasto
generateanexecutioninwhichcertaineventsoccurinaspecific
order. In our running example of Pure-FTPd, the quota mechanism
mustbeactivatedfirstintheexecution,then ğ‘¢ğ‘ ğ‘’ğ‘Ÿ_ğ‘ğ‘¢ğ‘œğ‘¡ğ‘mustbe
exceeded, and finally the execution must enter a loop in which no
ğ‘šğ‘ ğ‘”_ğ‘ğ‘¢ğ‘œğ‘¡ğ‘_ğ‘’ğ‘¥ğ‘ğ‘’ğ‘’ğ‘‘ğ‘’ğ‘‘ is sent back to the client. Existing directed
fuzzing approaches like AFLGo [ 17] aim to direct fuzzing towards
a particular program location and cannot drive execution through
multiple program locations in a specific order. We now discuss our
BÃ¼chi automata guided fuzzing in the next section.
3 BÃœCHI AUTOMATA GUIDED FUZZING
Given an LTL property ğœ™to be checked, automata-theoretic model
checkingofLTLproperties[ 62]constructstheBÃ¼chiautomata AÂ¬ğœ™
acceptingalltracessatisfying Â¬ğœ™.Inthissectionwewilldiscusshow
AÂ¬ğœ™can be used to guide fuzzing. First we design a mechanism
to generate an input whose execution passes through multiple
program locationsin a specificorder.We designthis mechanism
by augmenting a greybox fuzzer in two ways.
â€¢Power scheduling. During fuzzing, the power scheduling
componenttendstoselectseeds closertothetargetonthe
pre-built inter-procedural control flow graph. Thus, the tar-
get can be reached efficiently. To achieve this, we use the
fuzzing algorithm of AFLGo [17].
â€¢Inputprefixsaving.Thiscomponentobservesexecutionand
recordsinputelementsthathavebeenconsumedwhenreach-
ing a target.
As mentioned, we focus on fuzzing reactive systems that take a
sequenceofinputs.Themechanismwefollowinvolvesdirecting
fuzzing towards multiple program locations in a specific order.
Considerasequenceofprogramlocations ğ‘™1,ğ‘™2Â·Â·Â·ğ‘™ğ‘š.Ourapproach
works as follows: first, it takes ğ‘™1as the first target and focuses
on generating an input that leads to ğ‘™1. Meanwhile, it observes
execution and records the prefix ğ‘–1that leads to ğ‘™1. Next, it takes ğ‘™2
as the target, and focuses on exploring the space of inputs starting
with prefix ğ‘–1, i.e., keeping generating inputs starting with ğ‘–1.A sa
result, an input that reaches ğ‘™2viağ‘™1can be generated.
Basedontheabovemechanismofvisitingasequenceofprogram
locations,wedevelopanautomata-guidedfuzzingapproach.The
approachusestheBÃ¼chiautomata AÂ¬ğœ™instrumentedinprogram
ğ‘ƒ/primeand observes the progress that each trace makes on AÂ¬ğœ™at
runtime, e.g., how many state transitions are made towards the
accepting state. To guide fuzzing, the approach saves the progress
each input achieves on AÂ¬ğœ™and uses it to generate inputs that
makefurtherprogress.Specifically,itsavestheprogressforeach
1346Linear-time Temporal Logic guided Greybox Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
input by recording state transitions that are executed on AÂ¬ğœ™and
theinputprefixthatleadstothosetransitions.Considerinput ğ‘–0and
itstrace ğœ0goesfrominitialstate ğ‘ 0tostateğ‘ ğ‘šonautomata AÂ¬ğœ™.
Theachievedprogressisrepresentedasatuple /angbracketleftğ‘¥ğ‘–
0,ğ‘¥ğ‘ 
0/angbracketright,whereğ‘¥ğ‘–
0
is the shortest prefix of ğ‘–0whose execution trace goes from ğ‘ 0to
ğ‘ ğ‘šandğ‘¥ğ‘ 
0is the state transition sequence ğ‘ 0Â·Â·Â·ğ‘ ğ‘švisited. Such
progresstuplesarestoredintoaset Xandareusedtoguidefuzzing.
For input generation, the approach takes a tuple from Xand
usesittogenerateinputsthatmakesfurtherprogress.Considera
tuple/angbracketleftğ‘¥ğ‘–,ğ‘¥ğ‘ /angbracketright:ğ‘¥ğ‘ records state transitions on automata AÂ¬ğœ™which
input prefix ğ‘¥ğ‘–has led to. Thus, we can query AÂ¬ğœ™withğ‘¥ğ‘ to find
a transition that makes further progress, i.e., a state transition that
gets closer to an accepting state of AÂ¬ğœ™. In the example, assuming
ğ‘¥ğ‘ isstate0inFigure1,thenthetransitionfromstate0tostate1will
beidentifiedsincestate1isclosertotheacceptingstate2.Suppose
ğ‘¡is the next progressive state transition of ğ‘¥ğ‘ , then we can further
queryAÂ¬ğœ™to obtain atomic propositions that trigger transition
ğ‘¡. Then, by querying the map between atomic propositions and
program locations, we can identify program locations for those
atomic propositions. In the example, atomic proposition ğ‘triggers
transition from state 0 to state 1 and its corresponding program
location is /angbracketleftğ‘“ğ‘¡ğ‘ğ‘‘.ğ‘,6072/angbracketright, as shown in Table 1.
From the above we can define criteria for an input to make
further progress: (1) its execution has to follow the path that an
input prefix ğ‘¥ğ‘–has gone through such that the generated trace can
gothroughstatetransitions ğ‘¥ğ‘ ;and,(2)subsequentlytheexecution
reachesoneofprogramlocationsthatareidentifiedabovetoensure
the generated trace takes a step further in AÂ¬ğœ™.
Togenerateinputsofthiskind,ourmechanismforgenerating
inputsthattraverseasequenceofprogramlocationsinaspecific
ordercomesintoplay.Assume ğ‘™ğ‘–isoneofprogramlocationsidenti-
fied above, for making further "progress" in AÂ¬ğœ™. The mechanism
takesğ‘™ğ‘–as the target and keeps generating inputs that start with
prefixğ‘¥ğ‘–until generating an input that starts with prefix ğ‘¥ğ‘–and
subsequentlyvisitslocation ğ‘™ğ‘–.Thisishowourapproachusestuples
inXto generate inputs that make further "progress" towards an
acceptingstateintheBÃ¼chiautomata AÂ¬ğœ™.Thedetailedfuzzing
algorithm is now presented.
4 FUZZING ALGORITHM
Algorithm 1 shows the workflow of our counterexample guided
fuzzing. To find a counterexample, the algorithm guides fuzzing in
twodimensions.First,itprioritizestheexplorationofinputswhose
executiontracesaremorelikelytobeacceptedby AÂ¬ğœ™.Specifically,
if the trace of the prefix of an input reaches a state that is closer to
an accepting state on AÂ¬ğœ™, then its trace is more likely to be ac-
cepted.Thealgorithmselectsinputprefixeswhosetraceshavebeen
witnessedtogetclosetoanacceptingstateandkeepsgenerating
inputsstartingwiththem(showninline5andline10).Secondly,
thealgorithmfocusesongeneratinginputswhoseexecutionmakes
furtherprogresson AÂ¬ğœ™.Givenaninputprefix,thealgorithmfinds
a state transition ğ‘¡that helps us get closer to an accepting state
inAÂ¬ğœ™, and finds the atomic propositions which enable ğ‘¡to be
taken (line 6). For the atomic propositions enabling transition ğ‘¡,
we identify the corresponding program locations (line 7). Then
weattempttogenerateinputsthatreachtheprogramlocationinAlgorithm 1: Counterexample-Guided Fuzzing
Input:ğ‘ƒ/prime: The transformation of program under test
Input:AÂ¬ğœ™: Automata of negation of property under test
Input:ğ‘šğ‘ğ‘: Map between propositions and program locations
Input:ğ‘“ğ‘™ğ‘ğ‘”: True for liveness properties
Input:ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™_ğ‘¡ğ‘–ğ‘šğ‘’: Time budget for fuzzing
Input:ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’: Time budgetfor reaching a program location
1Procedure Fuzz(ğ‘ƒ/prime,AÂ¬ğœ™,ğ‘šğ‘ğ‘,ğ‘“ğ‘™ğ‘ğ‘”,ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™_ğ‘¡ğ‘–ğ‘šğ‘’,ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’)
2ğ‘ 0â†getInitState (AÂ¬ğœ™);
3Xâ†{/angbracketleftâˆ… ,ğ‘ 0/angbracketright};// Starting with init state of AÂ¬ğœ™
4forğ‘¡ğ‘–ğ‘šğ‘’ <ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™_ğ‘¡ğ‘–ğ‘šğ‘’do
5 /angbracketleftğ‘¥ğ‘–
ğ‘¡,ğ‘¥ğ‘ 
ğ‘¡/angbracketrightâ†selectPrefix (X);
6 ğ‘â†selectTargetAtomicProposition (AÂ¬ğœ™,ğ‘¥ğ‘ 
ğ‘¡);
7 ğ‘™â†selectProgramLocationTarget (ğ‘šğ‘ğ‘,ğ‘);
8 forğ‘¡ğ‘–ğ‘šğ‘’/prime<ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’do
//D: Feedback of CFG distance
//ğ‘†ğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ: Power schedule algorithm
9 ğ¼â†generateInput (D,ğ‘†ğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ);
10 ğ¼/primeâ†replacePrefix (ğ¼,ğ‘¥ğ‘–
ğ‘¡);
11 ğ‘‘,/angbracketleftğ‘¥ğ‘–,ğ‘¥ğ‘ /angbracketrightâ†evaluate (ğ‘ƒ/prime,ğ¼/prime,ğ‘“ğ‘™ğ‘ğ‘”);
12 Dâ†Dâˆª{ ğ‘‘};
13 Xâ†Xâˆª{/angbracketleft ğ‘¥ğ‘–,ğ‘¥ğ‘ /angbracketright}
14 end
15end
the execution and trigger the program behavior associated with
theatomicproposition.Asaresult,thegeneratedtracecanmake
further progress in AÂ¬ğœ™. To generate inputs that reach a particular
programlocation,weleveragethealgorithmproposedinAFLGo
(line8-14). Itsidea isto assignmore powerto seedsthat are closer
to the target on a pre-built control flow graph such that the gener-
ated inputs are more likely to reach the target. The time budget for
reaching a target is configurable, via parameter ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡_ğ‘¡ğ‘–ğ‘šğ‘’.
For prefix selection (line 5), the algorithm defines a fitness func-
tion to compute a fitness value for each prefix tuple. Given a tuple
/angbracketleftğ‘¥ğ‘–
ğ‘¡,ğ‘¥ğ‘ 
ğ‘¡/angbracketright, its fitness value is
ğ‘“ğ‘¡=ğ‘™ğ‘ 
ğ‘™ğ‘ +ğ‘™ğ‘+1
ğ‘™ğ‘–
whereğ‘™ğ‘ is the length of ğ‘¥ğ‘ 
ğ‘¡andğ‘™ğ‘is the length of the shortest
pathfromthelaststateof ğ‘¥ğ‘ 
ğ‘¡toanacceptingstateon AÂ¬ğœ™andğ‘™ğ‘–
isthelengthofinputprefix ğ‘¥ğ‘–
ğ‘¡.Asshownintheformula,aprefix
tuple has a higher fitness value if the last state of ğ‘¥ğ‘ 
ğ‘¡is closer to an
acceptingstateon AÂ¬ğœ™andtheinputprefixisshorter.Heuristically,
by extending such a prefix, our fuzzing algorithm is more likely to
generateaninputwhoseexecutiontraceisacceptedby AÂ¬ğœ™.Prefix
tuples with higher fitness values are prioritized for selection.
For atomic proposition selection (line 6), we adopt a random se-
lectionstrategy.Considertuple /angbracketleftğ‘¥ğ‘–
ğ‘¡,ğ‘¥ğ‘ 
ğ‘¡/angbracketrightandthelaststateof ğ‘¥ğ‘ 
ğ‘¡isğ‘ ğ‘¡,
thealgorithmidentifiesatomicpropositionsthatmakeaprogressive
transition from ğ‘ ğ‘¡onAÂ¬ğœ™as follows: if state ğ‘ ğ‘¡is not an accepting
stateofAÂ¬ğœ™,anyatomicpropositionthattriggersatransitionfrom
ğ‘ ğ‘¡towards an accepting state is selected. If state ğ‘ ğ‘¡is an accepting
state,anyatomicpropositionthattriggersatransitionfrom ğ‘ ğ‘¡back
to itselfis selected. Forsimplicity, the algorithmrandomly selects
one from the identified atomic propositions. When the selected
1347ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ruijie Meng, Zhen Dong, Jialin Li, Ivan Beschastnikh, and Abhik Roychoudhury
proposition ğ‘hasmultipleassociatedprogramlocations,weran-
domlyselectoneofthemasatarget.Themainconsiderationfor
adoptingarandomstrategyistokeepourtechniqueassimpleas
possible. Moreover, these strategies can be configured in our tool.
5 STATE SAVING
Inlivenesspropertyverification,LTL-Fuzzerdetectsastateloopin
thewitnessedtrace.Ifastateloopisdetected,LTL-Fuzzerassumes
thecurrenttracecanbeextendedtoalasso-shapedtrace ğœ1(ğœ2)ğœ”.
This works witha concreterepresentation of programstates, how-
everinrealitystaterepresentationofsoftwareimplementationsare
always abstracted. State representations that are too abstract may
misscapturingvariablestatesthatarerelevanttotheloop,which
leads to false positives. State representations that are too concrete
may containvariable states that areirrelevant to theloop such as
avariableforsystem-clock,whichleadstofalsenegatives.Tobe
practical, LTL-Fuzzer takes a snapshot of applicationâ€™s registers
andaddressable memory and hashes it into a 32-bit integer, which
is recorded as a state. Addressable memory indicates two kinds of
objects:(1)globalvariables(2)objectsthatareexplicitlyallocated
with functions malloc() andalloca() . Such a convention was
also adopted in previous works on infinite loop detection [20, 59].
Furthermore,LTL-Fuzzeronlyrecordsaprogramstateforse-
lectedprogramlocations,notforallprogramlocations.Specifically,
weonlysavestatesfortheprogramlocationsassociatedwiththe
transitionlabelsoftheautomata AÂ¬ğœ™whereğœ™isthelivenessprop-
erty being checked. Note that a transition label in AÂ¬ğœ™is a subset
of atomic propositions [ 62,63]. The full set of atomic propositions
isconstructedbytakingtheatomicpropositionsappearingin ğœ™and
embellishingthissetwithatomicpropositionsthatweintroduce
foroccurrenceofeachprogramloopheader(suchas ğ‘™inTable1).If
thetransitionlabelinvolvesaset ğ¿ofatomicpropositions,wetrack
states for only those atomic propositions in ğ¿which correspond
toloopheaderoccurrences.Thegoalhereistoquicklyfindpossi-
ble infinite loops by looking for a loop header being visited with
the same program state. Hence for the transition label ! ğ‘›in our
running example, we only store states for the program locations
corresponding atomic proposition ğ‘™in Table 1.
Listing 5: Quota checking:<ftpd.c. 4315>.
4315if(...(max_filesize >= (off_t) 0 &&
(max_filesize=user_quota_size - quota. size)
< (off_t) 0 )){
...
4322 gotoafterquota;
4323 }
IntheexampleshowninSection2,LTL-Fuzzerwitnessesastate
generatedatprogramlocation /angbracketleftğ‘“ğ‘¡ğ‘ğ‘‘.ğ‘,4067/angbracketright(showninListing4)
thathasbeenobservedbefore andatthesametimethewitnessed
trace is accepted by AÂ¬ğœ™. In this case, LTL-Fuzzer reports a vio-
lation of the LTL property ğœ™shown in Page 2. To validate if the
violation is spurious, we check if the observed state loop can be
repeated in the execution. Our analysis shows a chunk of data was
readduringtheexecutionofthestateloopandthechunkofdata
was from a file uploaded by the client. We duplicated the chunk
of data in the uploaded file and reran the experiment and found
the state loop was repeated. That means the witnessed trace canbeextendedtoa ğœ1(ğœ2)ğœ”shapedtrace,whichvisitstheaccepting
stateoftheautomataaccepting Â¬ğœ™(showninFigure1)infinitely
many times. Thus, the reported violation is not spurious.
We further analyzed the root cause of the violation. It shows
there was a logical bug in the quota checking module. As shown in
Listing 5, the assignment of max_filesize occurs in a conditional
statementandisneverexecutedduetothat max_filesize â€™sinitial
value is -1. To fix the bug, we created a patch and submitted a pull
requestontheGithubrepoofPure-FTPd,whichhasbeenconfirmed
and verified.
6 LTL-FUZZER IMPLEMENTATION
WeimplementLTL-Fuzzerasanopensourcetoolbuiltontopof
AFL, which comprises two main components: instrumentor and
fuzzer. In the following, we explain these components.
6.1 Instrumentation Module
AFLcomeswithaspecialcompilerpassfor clangthatinstruments
everybranchinstructiontoenablecoveragefeedback.Byextending
thiscompiler,weinstrumentaprogramundertestatthreelevels:
specific locations, basic blocks, and the application.
Specific locations. LTL-Fuzzer takes a list of program loca-
tionsatwhichprogrambehaviorsassociatedwithapropertyunder
test might occur. At each of the given program locations, the in-
strumentationmoduleinjectstwocomponents: eventgenerator and
state recorder . Event generator is a piece of code that generates an
eventwhentheprovidedconditionissatisfiedatrun-time.Thestate
recorder is a component that takes a snapshot of program states
and generates a hash code for the state when the given program
location is reached in the execution.
Basic blocks. LTL-Fuzzer guides fuzzing to a target using the
feedback on how close to the target an input is as explained in
Section 3. At runtime, LTL-Fuzzer requires the distance from each
basic block to the target on the CFG (control flow graph). The
instrumentor instruments a function call in each basic block at
runtime.Thefunctioncallwillqueryatablethatstoresdistances
from each block to program locations associated with the given
property (i.e., targets). The distance from a basic block to each
programlocationiscomputedofflinewiththedistancecalculator
component that is borrowed from AFLGo [17].
Applications. Foraprogramundertest,theinstrumentationmod-
uleinjectsa monitorintotheprogram.Duringfuzzing,themonitor
collects events generated by instrumented event generators and
produces execution traces. For property checking, the monitor
leverages Spot libraries [ 10] to generate a BÃ¼chi automata from
the negation of an LTL property and validates these traces. The
instrumentation module also instruments an observerin the pro-
gram that monitors execution of inputs; it maps a given suitable
execution trace prefix to the input event sequence producing it, so
thattheoccurrenceoftheprefixcanbedetectedbytheobserver,
duringfuzzing.Thefuzzingprocessthenseekstofurtherextend
this prefix with "suitable" events as described in the following.
1348Linear-time Temporal Logic guided Greybox Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Power
SchedulePrefix 
ReplacingPrefix Pool
Instrumented Program
AutomataTarget
&
Prefixes
Coverage
DataInputs PrefixesPrefix Controller Fuzz Engine: AFL
Figure 2: The architecture of LTL-Fuzzer.
6.2 Fuzzer
Figure2showstheFuzzercomponentâ€™sarchitecture.Itmainlycom-
prisestwomodules: prefixcontroller andfuzzengine .LTL-Fuzzer
saves input prefixes whose execution traces make transitions on
theautomataandreusesthemforfurtherexploration(Section3).
Atruntime,theprefixcontrollerconductsthreetasks:(1)collecting
prefixes reported by the monitor instrumented in the programun-
dertestandstoringthemintoapool;(2)selectingaprefixfromthe
pool for further exploration according to Algorithm 1; (3) identify-
ingthetargetprogramlocationbasedontheselectedprefix.The
fuzzengineisobtainedbymodifyingAFL[ 1].Itgeneratesinputs
starting with a given input prefix. To reach a target, our fuzzer
integratesthe powerscheduling componentdeveloped inAFLGo
[17] to direct fuzzing. In LTL-Fuzzer, we direct execution to reach
atargetaftertheexecutionofaninputprefix.Thus,thefuzzengine
collectsno feedback,such ascoveragedataduringexecution ofthe
input prefix, and only collects feedback data after the execution of
the input prefix is completed.
7 EVALUATION
In our experiments, we seek to answer the following questions:
RQ1 Effectiveness: How effective is LTL-Fuzzer at finding LTL
property violations?
RQ2 Comparison: How does LTL-Fuzzer compare to the state-
of-the-artvalidationtoolsintermsoffindingLTLproperty
violations?
RQ3 Usefulness: How useful is LTL-Fuzzer in revealing LTL
property violations in real-world systems?
7.1 Subject Programs
Table 2 lists the subject programs used in our evaluation. This
includes 7 open source software projects that implement 6 widely-
usednetworkprotocols.Weselectedtheseprojectsbecausethey
(1)arereactivesoftwaresystemsthatLTL-Fuzzerisdesignedfor,
(2) include appropriate specification documents from which LTL
propertiescanbegenerated,and(3)arewidely-usedandhavebeen
studied. Finding bugs in such real-world systems is thus valuable.
7.2 Experiment Setup
To answer the research questions, we conducted three empirical
studies on the subject programs.
7.2.1 Effectiveness of LTL-Fuzzer .We evaluate LTL-Fuzzerâ€™s ef-
fectiveness by running it on a set of LTL properties in subject
programs where violations are already known; we check the num-
ber of LTL properties for which LTL-Fuzzer can find violations.Table 2: Detailed information about our subject programs.
Project Protocol #SLOC InPreviousWork GithubStars
ProFTPD [7] FTP 210.8k [52] 339
Pure-FTPd [9] FTP 52.9k [52] 435
Live555 [4] RTSP 52.5k [53] [52] 526
OpenSSL [6] TLS 286.7k [40] [52] [27] 16.3K
OpenSSH [5] SSH 98.3k [32] [52] 1.5K
TinyDTLS [11] DTLS 63.2k [31] [52] 43
Contiki-Telnet [2] TELNET 353.4k [40] 3.4K
To create such a dataset, we collect event ordering related CVEs
(sothattheycanbecapturedasatemporalproperty)thataredis-
closed in subject programs, e.g., an FTP client copies files from
the server without logging in successfully. Specifically, for each
subject, we select 10 such CVEs with criteria: (1) reported recently
(during2010-2020);(2)includeinstructionstoreproducethebug,
(3) relevant to event orderings. Then we manually reproduce them
withthecorrespondingversionofcode.IfaCVEisreproducible,
then we write the property in LTL and put it in our dataset of LTL
properties.Basedontheaforementionedcriteria,wecollected14
CVEsin7subjectsasshowninTable3;theseLTLpropertiescanbe
foundinourdataset4andtheappendixofourarxivpaper5.Our
goalistocheckexperimentallyifLTL-Fuzzercanfindviolations
of these LTL properties.
7.2.2 Comparisonwithothertools. WeevaluateLTL-Fuzzerand
state-of-the-art techniques on the LTL property dataset above and
compare them in terms of the number of LTL properties for which
eachtechniquefindstheviolationsandthetimethatisusedtofind
aviolation.Forstate-of-the-arttechniques,wereviewedrecentand
well-known techniques in model checking, runtime verification
anddirectedfuzzingdomains.Wechosethefollowingtechniques
for comparison with LTL-Fuzzer.
â€¢AFLGo [17]. It is a well known directed greybox fuzzer which
drives execution to a target with a simulated annealing-based
power schedule that assigns more energy to inputs that hold the
trace closer to the target. We take it as a baseline tool.
â€¢AFLLTL. It is an implementation which enables AFLGo to detect
anLTLpropertyviolation.Specifically,AFL LTLpowersAFLGo
withonlytheLTLtestoraclesuchthatitcanreportanerrorwhen
thegivenLTLpropertyisviolatedintheexecution.Bycomparing
with AFL LTL, we evaluate how effective is our automata-guided
fuzzing strategy in finding LTL property violations. Note that
AFLLTLisalsoatoolbuiltbyus,butitlackstheautomataguided
fuzzing of LTL-Fuzzer.
â€¢L+NuSMV.Itcombinesmodellearningandmodelcheckingto
verifypropertiesinasoftwaresystem.Specifically,itleverages
a learning library called LearnLib [ 41] to build a model for the
softwaresystemandthenverifiesgivenpropertiesonthelearned
modelwiththewell-knownmodelcheckerNuSMV[ 23].Inthe
paper, we indicate it with L+NuSMV. This technique was pub-
lishedat CAV 2016 [ 30] andhas beensubsequently adoptedin
recent works such as [67] and [31].
4https://github.com/ltlfuzzer/LTL-Fuzzer/tree/main/ltl-property
5https://arxiv.org/abs/2109.02312
1349ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ruijie Meng, Zhen Dong, Jialin Li, Ivan Beschastnikh, and Abhik Roychoudhury
Table 3: Statistics of found violations and the performance of four tools in finding the violations.
PropCVE-ID Type of Vulnerability Program VersionLTL-Fuzzer AFLLTL AFLGo L+NuSMV
Time(h) Time(h) Ë†ğ´12Time(h) Ë†ğ´12Time(h) Ë†ğ´12
ğ‘ƒğ‘Ÿğ¹1CVE-2019-18217 Infinite Loop ProFTPD 1.3.6 4.62 T/O1.00 T/O1.00 T/O1.00
ğ‘ƒğ‘Ÿğ¹2CVE-2019-12815 Illegal File Copy ProFTPD 1.3.5 0.95 2.010.84 T/O1.00 T/O1.00
ğ‘ƒğ‘Ÿğ¹3CVE-2015-3306 Improper Access Control ProFTPD 1.3.5 1.14 1.890.76 T/O1.00 T/O1.00
ğ‘ƒğ‘Ÿğ¹4CVE-2010-3867 Illegal Path Traversal ProFTPD 1.3.3 2.06 5.170.85 T/O1.00 T/O1.00
ğ¿ğ‘‰1CVE-2019-6256 Improper Condition Handle Live555 2018.10.17 5.29 11.131.00 11.471.00 T/O1.00
ğ¿ğ‘‰2CVE-2019-15232 Use after Free Live555 2019.02.03 0.22 1.420.91 1.460.92 T/O1.00
ğ¿ğ‘‰3CVE-2019-7314 Use after Free Live555 2018.08.26 1.27 4.180.98 T/O1.00 T/O1.00
ğ¿ğ‘‰4CVE-2013-6934 Numeric Errors Live555 2013.11.26 2.73 2.58 0.40 2.21 0.39 T/O1.00
ğ¿ğ‘‰5CVE-2013-6933 Improper Operation Limit Live555 2011.12.23 1.80 1.99 0.63 1.45 0.33 T/O1.00
ğ‘†ğ»1CVE-2018-15473 User Enumeration OpenSSH 7.7p1 0.18 0.17 0.44 T/O1.00 24.001.00
ğ‘†ğ»2CVE-2016-6210 User Information Exposure OpenSSH 7.2p2 0.19 0.19 0.50 T/O1.00 24.001.00
ğ‘†ğ¿1CVE-2016-6309 Use after Free OpenSSL 1.1.0a 3.77 6.000.74 6.580.82 T/O1.00
ğ‘†ğ¿2CVE-2016-6305 Infinite Loop OpenSSL 1.1.0 1.45 T/O1.00 T/O1.00 T/O1.00
ğ‘†ğ¿3CVE-2014-0160 Illegal Memory Access OpenSSL 1.0.1f 1.11 7.311.00 T/O1.00 T/O1.00
Found violations in total - 14 12 5 2
Average time usage (hours) - 1.91 6.57 17.08 24.00
Comparison with LTL-Fuzzer on time usage - - 3.44x 8.93x 12.55x
1T/O represents tools cannot expose vulnerabilities within 24 hours for 10 experimental runs. We replace T/O with 24 hours when calculating average usage time.
2Statistically significant values of Ë†ğ´12are shown in bold.
We briefly summarize why we did not include certain other model-
checkers and fuzzers, and all runtime verification tools for com-
parison. Model checking tools CBMC [ 24], CPAChecker [ 16]6, Sea-
horn [36], SMACK [ 55], UAutomizer [ 38], DIVINE [ 14] cannot sup-
port LTL property verification. Schemmelâ€™s work [ 59] published at
CAV2018partiallysupportsLTLpropertyverification.SPIN[ 39]
supportsLTLpropertyverificationbutonlyworkswithamodeling
language Promela [ 8] and the tool provided in SPIN for extracting
modelsfromCprogramsfailedtoworkonoursubjectprograms.
Somemodelcheckingtools[ 40,60],anddirectedfuzzingtools(like
UAFL [66], Hawkeye [ 22] and TOFU [ 68]) we reviewed, are not
publicly available.
Finally, all of available runtime verification tools [ 29] (like Java-
MOP[42],MarQ[57]andMufin[ 28])cannotcheckLTLproperties
in C/C++ software systems. Furthermore, our method is concep-
tuallydifferentandcomplementarytoruntimeverificationâ€”our
methodgeneratestestexecutions,whileruntimeverificationchecks
atestexecution.Whilethecombinationofourmethodwithruntime
verification is possible, a comparison is less meaningful.
7.2.3 Real-worldutilty. Inthisstudy,wereadRFCspecifications
thatthesesubjectprogramsfollowtoextracttemporalproperties
and describe them in LTL. Then we use LTL-Fuzzer to check these
properties on the subject programs.
Configuration Parameters. Following fuzzing evaluation sugges-
tionsfromthecommunity[ 46],weruneachtechniquefor24hours
and repeat each experiment 10 times to achieve statistically signifi-
cant results. For the initial seeds, we use seed inputs provided in
ProFuzzBench[ 52]for allsubjects.ProFuzzBenchis abenchmark
6For some tools, the LTL checker module is not available for usage / experimentation,
as our email enquiry with CPAchecker team revealed.for stateful fuzzing of network protocols, which contains a suite of
representativeopen-sourcenetworkprotocolimplementations.For
Contiki-Telnet,whichisnotcontainedinProFuzzBench,wegen-
eraterandominputsasitsinitialseeds.ForLTL-Fuzzer,weneed
tospecifythetimebudgetforreachingasingleprogramlocation
and we configure it with 45 minutes for each target. For AFLGo
andAFL LTL,weneedtoprovideatargetforanLTLpropertybeing
checked.Wespecifythetargetbyrandomlyselectingfromprogram
locations that are associated with atomic propositions that trigger
thetransitiontoanacceptingstateontheautomataofthenegation
oftheproperty.IntheexampleinSection2,wechoseoneofloop
entriesasthetargetsinceproposition ğ‘œtriggersthetransitionto
the accepting state shown in Figure 1 and it corresponds with loop
entries. For execution environments, we conducted experiments
on a physical machine with 64 GB RAM and a 56 cores Intel(R)
Xeon(R) E5-2660 v4 CPU, running a 64-bit Ubuntu TLS 18.04 as the
operating system.
7.3 Experimental Results
7.3.1 [RQ1]Effectiveness. Table3showspropertyviolationsfound
byLTL-Fuzzerforthe14LTLpropertiesderivedfromknownCVEs.
The first column shows identifiers of the properties being checked.
The corresponding LTL properties and their descriptions can be
found in our dataset. Columns 2 - 5 represent CVE-IDs, types of
vulnerabilities that CVEs represent, subject names, and subject
versions, respectively. Column â€œLTL-Fuzzerâ€ shows the time that
is used to find a violation by LTL-Fuzzer. As shown in Table 3,
LTL-FuzzercaneffectivelydetectviolationsofLTLpropertiesin
thesubjects.Itsuccessfullydetectedtheviolationforallthe14LTL
propertiesinthedataset.Onaverage,ittookLTL-Fuzzer1.91hours
to find a violation.
1350Linear-time Temporal Logic guided Greybox Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 4: Zero-day Bugs found by LTL-Fuzzer; for several of them CVEs have been assigned but CVE ids are not shown.
PropProject Description of violated properties Bug Status
ğ‘‡ğ·1TinyDTLS (0.9-rc1)Iftheserverisinthe WAIT_CLIENTHELLO stateandreceivesa ClientHello requestwithvalidcookie
and the epoch value 0, must finally give ServerHello responses.CVE-2021-42143,
Fixed
ğ‘‡ğ·2TinyDTLS (0.9-rc1)If the server is in WAIT_CLIENTHELLO state and receives a ClientHello request with valid cookie but
not 0 epoch value, must not give ServerHello responses before receiving ClientHello with 0 epoch
value.CVE-2021-42142,
Fixed
ğ‘‡ğ·3TinyDTLS (0.9-rc1)If the server is in the WAIT_CLIENTHELLO state and receives a ClientHello request with an invalid
cookie, must reply HelloVerifyRequest .CVE-2021-42147,
Fixed
ğ‘‡ğ·5TinyDTLS (0.9-rc1)Iftheserverisinthe DTLS_HT_CERTIFICATE_REQUEST stateandreceivesa Certificate request,must
giveaDTLS_ALERT_HANDSHAKE_FAILURE orDTLS_ALERT_DECODE_ERROR response,orset Client_Auth
to be verified.CVE-2021-42145,
Fixed
ğ‘‡ğ·11TinyDTLS (0.9-rc1)After the server receives a ClientHello request without renegotiation extension and gives a
ServerHello response, then receives a ClientHello again, must refuse the renegotiation with an
Alert.Confirmed
ğ‘‡ğ·12TinyDTLS (0.9-rc1)Aftertheserverreceivesa ClientHello requestandgivesa ServerHello response,thenreceivesa
ClientKeyExchange request with a different epoch value than that of ClientHello , server must not
giveChangeCipherSpec responses.CVE-2021-42141,
Fixed
ğ‘‡ğ·13TinyDTLS (0.9-rc1)After the server receives a ClientHello request and gives a ServerHello response, then receives
aClientHello request with the same epoch value as that of the first one, server must not give
ServerHello .CVE-2021-42146
ğ‘‡ğ·14TinyDTLS (0.9-rc1)If the server receives a ClientHello request and gives a HelloVerifyRequest response, and then
receives a over-large packet even with valid cookies, the server must refuse it with an Alert.CVE-2021-42144,
Fixed
ğ¶ğ‘‡1Contiki-Telnet (3.0) AfterWILLrequestisreceivedandthecorrespondingoptionisdisabled,mustsend DOorDONTresponses. CVE-2021-40523
ğ¶ğ‘‡2Contiki-Telnet (3.0) AfterDOrequestisreceivedandthecorrespondingoptionisdisabled,mustsend WILLorWONTresponses. Confirmed
ğ¶ğ‘‡7Contiki-Telnet (3.0) AfterWONTrequest is received and the corresponding option is disabled, must not give responses. CVE-2021-38311
ğ¶ğ‘‡8Contiki-Telnet (3.0) AfterDONTrequest is received and the corresponding option is disabled, must not give responses. Confirmed
ğ¶ğ‘‡10Contiki-Telnet (3.0) BeforeDisconnection , must send an Alert to disconnect with clients. CVE-2021-38387
ğ¶ğ‘‡11Contiki-Telnet (3.0) If conducting COMMAND withoutAbortOutput , the response must be same as the real execution results. CVE-2021-38386
ğ‘ƒğ‘¢ğ¹5Pure-FTPd (1.0.49)When quota mechanism is activated and user quota is exceeded, must finally reply a quota exceed
message.CVE-2021-40524,
Fixed
LTL-Fuzzer is found to be effective in finding LTL property
violations,detectingviolationsforall14propertiesderivedfrom
known CVEs.
7.3.2 [RQ2]Comparison. AsshowninTable3,thelastthreemain
columnsshowthetimethatisusedforcomparisontechniquesto
findaviolationonthe14LTLpropertiesintheexperiment.Note
that â€œT/Oâ€indicates atechnique failedto findthe violationfor an
LTLproperty inthe giventimebudget (i.e.,24hours). Tomitigate
randomness in fuzzing, we adopted the Vargha-Delaney statistic
Ë†ğ´12[64] to evaluate whether one tool significantly outperforms
another in terms of the time that is used to find a violation. The
Ë†ğ´12is a non-parametric measure of effect size and gives the proba-
bility that a randomly chosen value from data group 1 is higher or
lower than one from data group 2. It is commonly used to evaluate
whetherthedifferencebetweentwogroupsofdataissignificant.
Moreover,wealsouseMann-WhitneyUtesttomeasurethestatisti-
cal significance of performance gain. When it is significant (taking
0.05 as a significance level), we mark the Ë†ğ´12values in bold.
LTL-Fuzzer found violations of all of the 14 LTL properties, fol-
lowed by AFL LTL(12), AFLGo (5), and L+NuSMV (2). We note that
AFLLTLis also a tool built by us, it partially embodies the ideas
in LTL-Fuzzer and is meant to help us understand the benefits
of automata-guided fuzzing. In terms of the time that is used tofind a violation, LTL-Fuzzer is the fastest (1.91 hours), followed by
AFLLTL(6.57 hours), AFLGo (17.08 hours), and L+NuSMV (24.00
hours). In other words, LTL-Fuzzer is 3.44x, 8.93x, 12.55x faster
than AFL LTL, AFLGo, and L+NuSMV, respectively. For CVE-2013-
6934 and CVE-2013-6933, AFLGo performed slightly better than
othertechniques,whileAFL LTLexhibitedthesameperformanceas
LTL-FuzzerforCVE-2018-15473andCVE-2016-6210.Weinvesti-
gated these 4 CVEs and found that triggering those vulnerabilities
isrelativelystraightforward.Theycan betriggeredwithoutsophis-
ticated directing strategies. As a result, other techniques achieve a
slightlybetterperformancethanLTL-FuzzerforthesefourCVEs.
In terms of the Ë†ğ´12statistic, LTL-Fuzzer performs significantly
better than other techniques in most cases.
LTL-Fuzzer found violations of all the 14 LTL properties in
theexperiment.AFL LTL,AFLGoandL+NuSMVfound12,5,2
property violations, respectively. LTL-Fuzzer is 3.44x, 8.93x,
12.55x faster than AFL LTL, AFLGo, and L+NuSMV.
7.3.3 [RQ3] Real-world utility. In this study, we evaluate utility
of LTL-Fuzzer by checking whether it can find zero-day bugs in
real-worldprotocolimplementations.Weextract50propertiesfrom
RFCs that our subject programs follow (aided by comments in the
1351ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ruijie Meng, Zhen Dong, Jialin Li, Ivan Beschastnikh, and Abhik Roychoudhury
source code of the programs) and write them in linear-time tem-
poral logic. The details of the 50 LTL properties can be found in
ourdataset.Intheexperiment,LTL-Fuzzerachievedapromising
result. Out of these 50 LTL properties, LTL-Fuzzer discovered new
violations for 15 properties, which are shown in Table 4. We re-
ported these 15 zero-day bugs to developers and all of them got
confirmedbydevelopers.Wereportedthemonthecommonvul-
nerabilitiesandexposures(CVE)system(seehttps://cve.mitre.org/)
and 12 of them were assigned CVE IDs. Out of 15 reported viola-
tions, 7 have been fixed at the time of the submission of our paper.
Notably, LTL-Fuzzer shows effectiveness in finding violations for
liveness properties. In the experiment, LTL-Fuzzer successfully
foundviolationsfor4livenesspropertieswhichare ğ‘ƒğ‘Ÿğ¹1,ğ‘†ğ¿2,ğ‘‡ğ·1
andğ‘ƒğ‘¢ğ¹5. All the 4 violations were confirmed by developers, i.e.,
theyarenotspuriousresults.Moreover,todiscoverviolationsfor
these4livenessproperties,LTL-Fuzzeronlyrecorded6,11,4and9
states, respectively. Since every state is recorded as a 32-bit integer,
thememoryconsumptionforrecordingstatesisthusfoundtobe
negligible in our experiments.
Among50LTLpropertiesextractedfromprotocolRFCs,LTL-
Fuzzer found 15 previously unknown violations in protocol
implementations and 12 of these have been assigned CVEs.
7.4 Threats to validity
Therearepotentialthreatstovalidityofourexperimentalresults.
Oneconcernis externalvalidity ,i.e.,thedegreetowhichourresults
can be generalized to and across other subjects. To mitigate this
concern,weselectedprotocolimplementationsthatarewidelyused
andhavebeenfrequentlyevaluatedinpreviousresearch(asshown
in Table 2). We may have made mistakes in converting informal
requirementsintoLTLproperties.Toreducethiskindofbias,we
lettwoauthorscheckgeneratedpropertiesandremovethoseon
which they do not agree, or do not think are important properties.
In principle, LTL-Fuzzer can report false positives due to in-
correctinstrumentation,e.g.,ifwefailtoinstrumentsometarget
locationsforanatomicproposition.Wemitigatetheriskoffalse
positives by checking the reported counterexamples and validating
thattheyaretrueviolationsofthetemporalpropertybeingchecked.
Weaddherethatwedidnotencountersuchfalsepositivesinany
of our experiments.
Anotherconcernis internalvalidity ,i.e.,thedegreetowhichour
results minimize systematic error. First, to mitigate spurious obser-
vations due to the randomness in the fuzzers and to gain statistical
significance,werepeatedeachexperiment10timesandreported
the Vargha-Delaney statistic Ë†ğ´12. Secondly, our LTL-Fuzzer im-
plementationmaycontainerrors.Tofacilitatescrutiny,wemake
LTL-Fuzzer code available.
8 RELATED WORK
Model Checkers. Model checking is a well-known property veri-
fication technique dating back to 1980s [ 25,54]; it is used to prove
a temporal property in a finite state system, or to find property
violation bugs. The early works check a temporal logic property
against a finite state transition system. There exist well-known
model checkers such as [ 23,39,43] which can be used to checktemporal properties on a constructed model (via state space explo-
ration).Toconstructmodels,onemethodismanualconstruction
viaamodelinglanguage.Thisrequiressubstantialeffortandcan
beerror-prone[ 35,50].LTL-Fuzzerdirectlycheckssoftwareim-
plementations; it does not separately extract models from software.
Early works on model checking have been extended to automat-
ically find bugs in software systems, which are typically infinite-
statesystems.Modelcheckingofsoftwaresystemsusuallyinvolves
either someextraction of finitestate models,or directly analyzing
theinfinite statesoftware systemvia techniquessuchas symbolic
analysis.Automaticmodelextractionapproaches[ 12,26,37,58]in-
cludetheworksonpredicateabstractionandabstractionrefinement
[12,13]whichbuildupahierarchyoffinite-stateabstractmodels
for a software system for proving a property. These approaches
extractmodelswhichareconservativeapproximationsandcapture
a superset of the program behavior. There are a number of stateful
softwaremodelcheckers,suchasCMC[ 50],JavaPathfinder[ 65],
MaceMC [ 44], CBMC [ 24], CPAchecker [ 16], which find assertion
violations in software implementations. Many of these checkers
do not check arbitrary LTL properties for software implementa-
tions.Thesemodelcheckerseithersufferfromstatespaceexplosion,
or suffer from other kinds of explosion such as the explosion in
the size/solving-time for the logical formula in bounded model
checking. In contrast, LTL-Fuzzer does not save any states for
safety property checking and saves only certain property-relevant
program states in liveness property checking. At the same time,
LTL-Fuzzer does not give verification guarantees and does not
perform completeexploration of thestate space. We nowproceed
to discuss incomplete validation approaches.
Incomplete Checkers. Instead of exploring the complete set of
behaviors,orasuper-setofbehaviors,onecanalsoexploreasubset
of behaviors. Incomplete model learning approaches [ 61] can be
mentioned in this regard. The active model learning technique,
such as LearnLib [ 41], is widely used to learn models of real-world
protocolimplementations[ 27,30â€“32].Itdoesnotneeduserinvolve-
ment. But it is time-consuming and hard to determine whether the
learned model represents the complete behavior of the software
system [61,69]. Compared with the active learning, LTL-Fuzzer
canmorerapidlycheckproperties,asshowninourexperimental
comparisonwithLearnLib+NuSMV.Toalleviatethestate-explosion
problem, stateless checkers such as VeriSoft [ 33] and Chess [ 51]
have been proposed; these checkers do not store program states.
These works typically involve specific search strategies to check
specificclassesofpropertiessuchasdeadlocks,assertionsandso
on. Incontrast, LTL-Fuzzer representsa generalapproach tofind
violations of anyLTL property.
RuntimeVerification. Runtimeverificationisalightweightand
yet rigorous verification technique [ 15,48]. It analyzes a single
execution trace of a system against formally specified properties
(e.g.,LTLproperties).Itoriginsfrommodelcheckingandapplies
model checking directly to the real implementations. Model check-
ingchecksamodelofatargetsystemtoverifycorrectnessofthe
system,whileruntimeverificationdirectlycheckstheimplemen-
tation, which could avoid different behaviours between models
and implementations. LTL-Fuzzer shares the same benefit as run-
time verification. Besides, runtime verification deals with finite
1352Linear-time Temporal Logic guided Greybox Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
executions,asonesingleexecutionhasnecessarilytobefinite.This
avoids the state explosion problem that model checking suffers
from.Meanwhile,itleadstothatruntimeverificationapproaches
[21,28,42,57]oftenonlychecksafetyproperties.LTL-Fuzzer,how-
ever, is able to check liveness properties by leveraging the strategy
of saving program states.
Conceptually, our method is very different from runtime verifi-
cation.Runtimeverificationfocusesonthechecking(atemporal
logic property) on a single execution. Our method is focused on
usingtemporallogicpropertytoguidetheconstructionofanex-
ecution which violates the property. Thus our work is more of a
testgenerationmethod.Sinceruntimeverificationmethodsneed
tests whose execution will be checked, our method can be comple-
mentarytoruntimeverification.Inotherwords,ourmethodcan
generatetestslikelytoviolateagiventemporalproperty,andthese
tests can further validated by run-time verification.
GreyboxFuzzing. Therearethreebroadvariantsoffuzzing:black-
boxfuzzing[ 49],whiteboxfuzzingorsymbolicexecution[ 19,40,
59], and greybox fuzzing [ 1,17,18,22,56,66]. We first discuss
greybox fuzzing since they are the most widely used in industry
today.Incontrasttosoftwaremodelchecking,blackbox/greybox
fuzzing techniques represent a random/biased-random search over
the domain of inputs for finding bugs or vulnerabilities in pro-
grams.Mostgreyboxfuzzingtechniquesareusedtodetectmemory
issues (e.g., buffer overflow and use after free) that can produce
observable behaviors (e.g., crashes). However, LTL-Fuzzer can not
only witness simple properties like memory corruption, but also
detectLTLpropertyviolations,for anygivenLTLproperty,how-
evercomplex.Recentadvancesingreyboxfuzzinguseinnovative
objective functions for achieving different goals, such as [ 17] di-
rectsthesearchtospecificprogramlocations.Thecapabilitiesof
LTL-Fuzzer go beyond visiting specific locations, and LTL-Fuzzer
is used to witness specific event ordering constraints embodied
by the negation of an arbitrary LTL property. PGFUZZ [ 45]i sa
greybox-fuzzing framework to find safety violations for robotic
vehicles, but it is customized to be used on implementations of
roboticvehicles.LTL-Fuzzercanbeusedtofindviolationof any
LTL property for software from any application domain.
SymbolicExecutionbasedValidation. Symbolicexecutionorwhite-
box fuzzing approaches are typically used to find violations of sim-
ple properties such as assertions [ 19,34]. Recent whitebox fuzzing
techniquesdofindviolationsofcertainclassesofproperties.Schem-
melâ€™s work [ 59] checks liveness properties while CHIRON [ 40]
checkssafetyproperties.[ 70,71]proposedregular-propertyguided
dynamicsymbolicexecutiontofindtheprogrampathssatisfying
a property. However, all of these approaches require a long time
budgetforheavy-weightprogramanalysisandback-endconstraint
solving. As a result, these techniques face challenges in scalability.
Incontrast,LTL-Fuzzerisbuiltontopofgreyboxfuzzing;itcan
validate arbitrarily large and complex software implementations.
9 PERSPECTIVE
We present LTL-Fuzzer, a linear-time temporal logic guided grey-
box fuzzing technique, which takes Linear-time Temporal Logic
(LTL)propertiesextractedfrominformalrequirementssuchasRFCsandfindsviolationsofthesepropertiesinC/C++softwareimple-
mentations.Ourevaluationshowsthat LTL-Fuzzeriseffectivein
finding property violations. It detected 15 LTL property violations
in real world protocol implementations that were previously un-
known; 12 of these zero day bugs have been assigned CVEs. We
make the data-set of LTL properties, and our tool available for
scrutiny.
Our work shows the promise of synergising concepts from tem-
poralpropertycheckingwithrecentadvancesingreyboxfuzzing
(theseadvanceshavemadegreyboxfuzzingmoresystematicand
effective).Specifically,inthispaperwehavetakenconceptsfrom
automata-theoreticmodelcheckingofLTLproperties[ 62],while
atthesametimeadapting/augmentingdirectedgreyboxfuzzing
[17]. The main advancement of greybox fuzzing in our work, is
the ability to find violations of arbitrary LTL properties, which
is achieved by borrowing the BÃ¼chi automata construction from
[62]. We note that the real-life practical value addition of software
modelcheckingisoftenfromautomatedbug-findinginsoftware
implementations rather than from formal verification. Runtime
verificationcomplementssoftwaremodelcheckingbyanalyzing
a single execution trace of software implementations. Our work
essentially shows thepromiseof enjoying the main practicalben-
efits of software model checking more efficiently and effectively
via augmentation of (directed) greybox fuzzing. This is partially
shown by the experiments in this paper where we have compared
our work with both model checkers and fuzzers. Our work is also
complementary to runtime verification since we generate test exe-
cutionsguidedbyaLTLproperty,whileruntimeverificationwould
check a LTL property against a single test execution.
ArguablywecouldcompareLTL-Fuzzerwithmoremodelcheck-
ersandfuzzers,experimentally.Atthesametime,wehavenoted
that many model checkers were found to be not applicable for
checking arbitrary LTL properties of arbitrary C/C++ software im-
plementations.Moreover,theproblemaddressedbyLTL-Fuzzer
is certainly beyond the reach of fuzzers since fuzzers cannot de-
tect temporal property violations. Overall, we believe our work
represents a practical advance over model checkers and runtime
verification, and a conceptual advance over greybox fuzzers. We
expectthattheresearchcommunitywilltaketheworkinourpa-
perforward,tofurtherunderstandthesynergiesamongsoftware
model checking, runtime verification and greybox fuzzing.
REFERENCES
[1] August. 2021 (last accessed). AFL. https://lcamtuf.coredump.cx/afl/.
[2]August. 2021 (last accessed). Contiki-Telnet. https://github.com/contiki-os/
contiki.
[3] August. 2021 (last accessed). libFuzzer. https://llvm.org/docs/LibFuzzer.html.
[4] August. 2021 (last accessed). Live555. http://www.live555.com/.
[5] August. 2021 (last accessed). OpenSSH. http://www.openssh.com/.
[6] August. 2021 (last accessed). OpenSSL. https://www.openssl.org/.
[7] August. 2021 (last accessed). ProFTPD. http://www.proftpd.org/.
[8]August.2021(lastaccessed). Promela. http://spinroot.com/spin/Man/promela.
html.
[9]August.2021(lastaccessed). Pure-FTPd. https://www.pureftpd.org/project/pure-
ftpd/.
[10] August. 2021 (last accessed). Spot. https://spot.lrde.epita.fr/.
[11]August. 2021 (last accessed). TinyDTLS. https://projects.eclipse.org/projects/iot.
tinydtls.
[12]Thomas Ball, Rupak Majumdar, Todd Millstein, and Sriram K. Rajamani. 2001.
AutomaticpredicateabstractionofCprograms.In proceedingsoftheACMSIG-
PLAN2001conferenceonProgramminglanguagedesignandimplementation(PLDI
2001). ACM, 203â€“213. https://dl.acm.org/doi/abs/10.1145/378795.378846
1353ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Ruijie Meng, Zhen Dong, Jialin Li, Ivan Beschastnikh, and Abhik Roychoudhury
[13]Thomas Ball and Sriram K. Rajamani. 2002. Automatically validating tempo-
ral safety properties of interfaces. In proceedings of the 8th international SPIN
workshop on Model checking of software (SPIN 2002) . ACM, 103â€“122. https:
//dl.acm.org/doi/10.5555/380921.380932
[14]Zuzana BaranovÃ¡, JiÅ™Ã­ Barnat, KatarÃ­na KejstovÃ¡, TadeÃ¡Å¡ KuÄera, Henrich Lauko,
Jan MrÃ¡zek, Petr RoÄkai, and VladimÃ­r Å till. 2017. Model checking of C and C++
with DIVINE 4. In proceedings of the 15th International Symposium on Automated
TechnologyforVerificationandAnalysis(ATVA2017) .Springer,201â€“207. https:
//link.springer.com/chapter/10.1007/978-3-319-68167-2_14
[15]EzioBartocci,YliÃ¨sFalcone,AdrianFrancalanza,andGilesReger.2018. Introduc-
tiontoruntimeverification. In LecturesonRuntimeVerification .Springer,1â€“33.
https://hal.inria.fr/hal-01762297
[16]Dirk Beyer and M Erkan Keremoglu. 2011. CPAchecker: A tool for config-
urable software verification. In proceedings of the 23rd International Confer-
ence on Computer-Aided Verification (CAV 2011) . Springer, 184â€“190. https:
//link.springer.com/chapter/10.1007/978-3-642-22110-1_16
[17]MarcelBÃ¶hme,Van-ThuanPham,Manh-DungNguyen,andAbhikRoychoudhury.
2017.Directedgreyboxfuzzing.In proceedingsofthe2017ACMSIGSACConference
on Computer and Communications Security (CCS 2017) . ACM, 2329â€“2344. https:
//dl.acm.org/doi/10.1145/3133956.3134020
[18]Marcel BÃ¶hme, Van-Thuan Pham, and Abhik Roychoudhury. 2017. Coverage-
basedgreyboxfuzzingasmarkovchain. IEEETransactionsonSoftwareEngineering
(TSE)45, 5 (2017), 489â€“506. https://dl.acm.org/doi/10.1145/2976749.2978428
[19]Cristian Cadar, Daniel Dunbar, Dawson R Engler, et al .2008. Klee: unassisted
and automatic generation of high-coverage tests for complex systems programs.
Inproceedings of the 8th USENIX conference on Operating systems design and
implementation (OSDI 2008) . USENIX Association, 209â€“224. https://dl.acm.org/
doi/10.5555/1855741.1855756
[20]Michael Carbin, Sasa Misailovic, Michael Kling, and Martin C. Rinard. 2011. De-
tecting and Escaping Infinite Loops with Jolt. In proceedings of the 25th European
Conference on Object-Oriented Programming (ECOOP 2011) . Springer, 609â€“633.
https://doi.org/10.1007/978-3-642-22655-7_28
[21]Feng Chen and Grigore RoÅŸu. 2007. Mop: an efficient and generic runtime verifi-
cationframework.In proceedingsofthe22ndannualACMSIGPLANconference
on Object-oriented programming systems, languages and applications (OOPSLA
2007). ACM, 569â€“588. https://doi.org/10.1145/1297027.1297069
[22]HongxuChen,YinxingXue,YuekangLi,BihuanChen,XiaofeiXie,XiuhengWu,
andYangLiu.2018. Hawkeye:TowardsaDesiredDirectedGreyboxFuzzer.In
proceedingsofthe2016ACMSIGSACConferenceonComputerandCommunications
Security (CCS 2016) . ACM, 2095â€“2108. https://doi.org/10.1145/3243734.3243849
[23]Alessandro Cimatti, Edmund Clarke, Enrico Giunchiglia, Fausto Giunchiglia,
Marco Pistore, Marco Roveri, Roberto Sebastiani, and Armando Tacchella. 2002.
Nusmv2:Anopensourcetoolforsymbolicmodelchecking.In proceedingsof14th
International Conference on Computer-Aided Verification (CAV 2002) . Springer,
359â€“364. https://link.springer.com/chapter/10.1007/3-540-45657-0_29
[24]EdmundClarke,DanielKroening,andFlavioLerda.2004. Atoolforchecking
ANSI-Cprograms.In proceedingsofthe10thInternationalConferenceonToolsand
Algorithms for the Construction and Analysis of Systems (TACAS 2004) . Springer,
168â€“176. https://link.springer.com/chapter/10.1007/978-3-540-24730-2_15
[25]Edmund M. Clarke and E Allen Emerson. 1981. Design and synthesis of syn-
chronization skeletons using branching time temporal logic. Lecture Notes in
ComputerScience(LNCS) 131(1981),55â€“71. https://link.springer.com/chapter/
10.1007/BFb0025774
[26]James C Corbett, Matthew B Dwyer, John Hatcliff, Shawn Laubach, Corina S
Pasareanu,HongjunZheng,etal .2000. Bandera:Extractingfinite-statemodels
from Java source code. In proceedings of the 22nd international conference on
Software engineering (ICSE 2000) . IEEE, 439â€“448. https://dl.acm.org/doi/10.1145/
337180.337234
[27]JoeriDeRuiterandErikPoll.2015.ProtocolStateFuzzingofTLSImplementations.
Inproceedings of the 24th USENIX Conference on Security Symposium (USENIX
Security 2015) . USENIX Association, 193â€“206. https://dl.acm.org/doi/10.5555/
2831143.2831156
[28]Normann Decker, Jannis Harder, Torben Scheffel, Malte Schmitz, and Daniel
Thoma. 2016. Runtime monitoring with union-find structures. In proceedings of
the22ndInternationalConferenceonToolsandAlgorithmsfortheConstructionand
AnalysisofSystems(TACAS2016) .Springer,868â€“884. https://doi.org/10.1007/978-
3-662-49674-9_54
[29]YliÃ¨s Falcone, SrÄ‘an KrstiÄ‡, Giles Reger, and Dmitriy Traytel. 2021. A taxonomy
for classifying runtime verification tools. International Journal on Software Tools
for Technology Transfer (STTT) 23, 2 (2021), 255â€“284. https://hal.inria.fr/hal-
01882410
[30]PaulFiterÄƒu-BroÅŸtean,RamonJanssen,andFritsVaandrager.2016. Combining
modellearningandmodelcheckingtoanalyzeTCPimplementations.In proceed-
ingsof28thInternationalConferenceonComputer-AidedVerification(CAV2016) .
Springer, 454â€“471. https://link.springer.com/chapter/10.1007/978-3-319-41540-
6_25
[31]Paul Fiterau-Brostean, Bengt Jonsson, Robert Merget, Joeri de Ruiter, Konstanti-
nosSagonas,andJurajSomorovsky.2020. AnalysisofDTLSImplementationsUsingProtocolStateFuzzing.In proceedingsofthe29thUSENIXConferenceon
Security Symposium Security (USENIX Security 2020) . USENIX Association, 2523â€“
2540. https://www.usenix.org/conference/usenixsecurity20/presentation/fiterau-
brostean
[32]Paul FiterÄƒu-BroÅŸtean, Toon Lenaerts, Erik Poll, Joeri de Ruiter, Frits Vaan-
drager, and Patrick Verleg. 2017. Model learning and model checking of
SSH implementations. In proceedings of the 24th ACM SIGSOFT International
SPIN Symposium on Model Checking of Software (SPIN 2017) . ACM, 142â€“151.
https://dl.acm.org/doi/10.1145/3092282.3092289
[33]Patrice Godefroid. 1997. Model checking for programming languages using
VeriSoft. In proceedings of the 24th ACM SIGPLAN-SIGACT symposium on Princi-
ples of programming languages (POPL 1997) . ACM, 174â€“186. https://dl.acm.org/
doi/10.1145/263699.263717
[34]PatriceGodefroid,NilsKlarlund,andKoushikSen.2005. DART:Directedauto-
mated random testing. In proceedings of the 2005 ACM SIGPLAN conference on
Programminglanguagedesignandimplementation(PLDI2005) .ACM,213â€“223.
https://dl.acm.org/doi/10.1145/1064978.1065036
[35]Huayang Guo, Ming Wu, Lidong Zhou, Gang Hu, Junfeng Yang, and Lintao
Zhang. 2011. Practical software model checking via dynamic interface reduction.
Inproceedings of the 23rd ACM Symposium on Operating Systems Principles (SOSP
2011). ACM, 265â€“278. https://dl.acm.org/doi/10.1145/2043556.2043582
[36]Arie Gurfinkel, Temesghen Kahsai, Anvesh Komuravelli, and Jorge A Navas.
2015. TheSeaHornverificationframework.In proceedingsof27thInternational
Conference on Computer-Aided Verification (CAV 2015) . Springer, 343â€“361. https:
//link.springer.com/chapter/10.1007/978-3-319-21690-4_20
[37]John Hatcliff, Matthew B Dwyer, and Hongjun Zheng. 2000. Slicing software for
modelconstruction. Higher-orderandsymboliccomputation(LISP) 13,4(2000),
315â€“353. https://dl.acm.org/doi/10.1023/A%3A1026599015809
[38]Matthias Heizmann, Jochen Hoenicke, and Andreas Podelski. 2013. Software
modelcheckingforpeoplewholoveautomata.In proceedingsof25thInternational
ConferenceonComputer-AidedVerification(CAV2013) .Springer,36â€“52. https:
//link.springer.com/chapter/10.1007/978-3-642-39799-8_2
[39]GerardJ.Holzmann.1997. ThemodelcheckerSPIN. IEEETransactionsonsoftware
engineering (TSE) 23, 5(1997), 279â€“295. https://dl.acm.org/doi/10.1109/32.588521
[40]Endadul Hoque, Omar Chowdhury, Sze Yiu Chau, Cristina Nita-Rotaru, and
Ninghui Li. 2017. Analyzing operational behavior of stateful protocol implemen-
tationsfordetectingsemanticbugs.In proceedingsofthe47thAnnualIEEE/IFIP
International Conference on Dependable Systems and Networks (DSN 2017) . IEEE,
627â€“638. https://ieeexplore.ieee.org/document/8023160
[41]Malte Isberner, Falk Howar, and Bernhard Steffen. 2015. The open-source Learn-
Lib. Inproceedings of the 27th International Conference on Computer-Aided Verifi-
cation (CAV 2015) . Springer, 487â€“495. https://link.springer.com/chapter/10.1007/
978-3-319-21690-4_32
[42]DongyunJin,PatrickOâ€™NeilMeredith,ChoonghwanLee,andGrigoreRoÅŸu.2012.
JavaMOP:Efficientparametricruntimemonitoringframework.In proceedings
of the 34th International Conference on Software Engineering (ICSE 2012) . IEEE,
1427â€“1430. https://ieeexplore.ieee.org/document/6227231
[43]GijsKant,AlfonsLaarman,JeroenMeijer,JacovandePol,StefanBlom,andTom
van Dijk. 2015. LTSmin: high-performance language-independent model check-
ing.Inproceedingsofthe21stInternationalConferenceonToolsandAlgorithms
for the Construction and Analysis of Systems (TACAS 2015) . Springer, 692â€“707.
https://link.springer.com/chapter/10.1007/978-3-662-46681-0_61
[44]CharlesKillian,JamesWAnderson,RanjitJhala,andAminVahdat.2007. Life,
death, and the critical transition: Finding liveness bugs in systems code. In
proceedings of the 4th USENIX conference on Networked systems design and imple-
mentation (NSDI 2007) . USENIX Association, 243â€“256. https://dl.acm.org/doi/10.
5555/1973430.1973448
[45]HyungsubKim,MuslumOzgurOzmen,AntonioBianchi,ZBerkayCelik,and
Dongyan Xu. 2021. PGFUZZ: Policy-Guided Fuzzing for Robotic Vehicles. In
proceedings of 2021 Network and Distributed SystemsSecurity Symposium (NDSS
2021). NDSS. https://dx.doi.org/10.14722/ndss.2021.24096
[46]GeorgeKlees,AndrewRuef,BenjiCooper,ShiyiWei,andMichaelHicks.2018.
Evaluating fuzz testing. In proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security (CCS 2018) . ACM, 2123â€“2138. https:
//dl.acm.org/doi/10.1145/3243734.3243804
[47]Owolabi Legunsen, Wajih Ul Hassan, Xinyue Xu, Grigore RoÅŸu, and Darko Mari-
nov. 2016. How good are the specs? A study of the bug-finding effectiveness
ofexistingJavaAPIspecifications.In proceedingsofthe31stIEEE/ACMInterna-
tionalConferenceonAutomatedSoftwareEngineering(ASE2016) .IEEE,602â€“613.
https://ieeexplore.ieee.org/abstract/document/7582795
[48]Martin Leucker and Christian Schallhart. 2009. A brief account of runtime
verification. The Journal of Logic and Algebraic Programming (JLAP) 78, 5 (2009),
293â€“303. https://doi.org/10.1016/j.jlap.2008.08.004
[49]BartonPMiller,GregoryCooksey,andFredrickMoore.2006. Anempiricalstudy
of the robustness of macos applications using random testing. In proceedings of
the 1st international workshop on Random testing (RT 2006) . ACM, 46â€“54. https:
//dl.acm.org/doi/10.1145/1145735.1145743
1354Linear-time Temporal Logic guided Greybox Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
[50]MadanlalMusuvathi,DavidYWPark,AndyChou,DawsonREngler,andDavidL
Dill.2002. CMC:Apragmaticapproachtomodelcheckingrealcode. ACMSIGOPS
OperatingSystemsReview(OSR) 36,SI(2002),75â€“88. https://dl.acm.org/doi/10.
1145/844128.844136
[51]Madanlal Musuvathi, Shaz Qadeer, Thomas Ball, Madanlal Musuvathi, Shaz
Qadeer, and Thomas Ball. 2007. Chess: A systematic testing tool for
concurrent software . Technical Report MSR-TR-2007-149. Microsoft Re-
search. https://www.microsoft.com/en-us/research/publication/chess-a-
systematic-testing-tool-for-concurrent-software/
[52]RobertoNatellaandVan-ThuanPham.2021. ProFuzzBench:ABenchmarkfor
Stateful Protocol Fuzzing. In proceedings of the 30th ACM SIGSOFT International
Symposium on Software Testing and Analysis (ISSTA 2021) . ACM, 662â€“665. https:
//dl.acm.org/doi/abs/10.1145/3460319.3469077?af=R
[53]Van-Thuan Pham, Marcel BÃ¶hme, and Abhik Roychoudhury. 2020. AFLNet: a
greybox fuzzer for network protocols. In proceedings of the 13th International
Conference on Software Testing, Validation and Verification (ICST 2020) . IEEE,
460â€“465. https://ieeexplore.ieee.org/document/9159093
[54]Jean-Pierre Queille and Joseph Sifakis. 1982. Specification and verification of
concurrentsystemsinCESAR.In proceedingsofthe1982InternationalSymposium
onprogramming .Springer,337â€“351. https://link.springer.com/chapter/10.1007/3-
540-11494-7_22
[55]Zvonimir RakamariÄ‡ and Michael Emmi. 2014. SMACK: Decoupling source
languagedetailsfromverifierimplementations.In proceedingsofthe26thInterna-
tionalConferenceonComputer-AidedVerification(CAV2014) .Springer,106â€“113.
https://link.springer.com/chapter/10.1007/978-3-319-08867-9_7
[56]Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,
and Herbert Bos. 2017. VUzzer: Application-aware Evolutionary Fuzzing. In
proceedings of 2017 Network and Distributed SystemsSecurity Symposium (NDSS
2017), Vol. 17. NDSS, 1â€“14. http://dx.doi.org/10.14722/ndss.2017.23404
[57]GilesReger,HelenaCuencaCruz,andDavidRydeheard.2015. MarQ:monitoring
at runtime with QEA. In proceedings of the 21st International Conference on
Tools and Algorithms for the Construction and Analysis of Systems (TACAS 2015) .
Springer, 596â€“610. https://doi.org/10.1007/978-3-662-46681-0_55
[58]Ronald L Rivest and Robert E Schapire. 1993. Inference of finite automata using
homingsequences. InformationandComputation(IANDC) 103,2(1993),299â€“347.
https://dl.acm.org/doi/10.1145/73007.73047
[59]Daniel Schemmel, Julian BÃ¼ning, Oscar Soria Dustmann, Thomas Noll, and
Klaus Wehrle. 2018. Symbolic Liveness Analysis of Real-World Software. In
proceedings of 30th International Conference on Computer-Aided Verification (CAV
2018). Springer, 447â€“466. https://doi.org/10.1007/978-3-319-96142-2_27
[60]MarkusSchordan,JanHÃ¼ckelheim,Pei-HungLin,andHarshithaMenon.2017.
Verifying the floating-point computation equivalence of manually and auto-
matically differentiated code. In proceedings of the 1st International Workshopon Software Correctness for HPC Applications (Correctness 2017) . ACM, 34â€“41.
https://dl.acm.org/doi/10.1145/3145344.3145489
[61]Frits Vaandrager. 2017. Model learning. Communications of the ACM (CACM) 60,
2 (2017), 86â€“95. https://dl.acm.org/doi/10.1145/2967606
[62]Moshe Y. Vardi and Pierre Wolper. 1986. An automata-theoretic approach to
automatic program verification. In proceedings of the 1st Symposium on Logic in
Computer Science (LICS 1986) . IEEE. https://orbi.uliege.be/handle/2268/116609
[63]Moshe Y. Vardi and Pierre Wolper. 1994. Reasoning about Infinite Computations.
Information and Computation (IANDC) 115 (1994), 1â€“37. Issue 1. https://doi.org/
10.1006/inco.1994.1092
[64]AndrÃ¡s Vargha and Harold D. Delaney. 2000. A Critique and Improvement of
the CL Common Language Effect Size Statistics of McGraw and Wong. Journal
of Educational and Behavioral Statistics (JEBS) 25, 2 (2000), 101â€“132. https:
//doi.org/10.3102/10769986025002101
[65]Willem Visser, Klaus Havelund, Guillaume Brat, SeungJoon Park, and Flavio
Lerda.2003. Modelcheckingprograms. Automatedsoftwareengineering(ASE)
10, 2 (2003), 203â€“232. https://link.springer.com/article/10.1023/A:1022920129859
[66]HaijunWang,Xiaofei Xie,YiLi,ChengWen,YuekangLi,YangLiu,Shengchao
Qin, Hongxu Chen, and Yulei Sui. 2020. Typestate-guided fuzzer for discovering
use-after-free vulnerabilities. In proceedings of the 42nd International Conference
on Software Engineering (ICSE 2020) . IEEE, 999â€“1010. https://dl.acm.org/doi/abs/
10.1145/3377811.3380386
[67]QinyingWang,ShoulingJi,YuanTian,XuhongZhang,BinbinZhao,YuhongKan,
Zhaowei Lin, Changting Lin, Shuiguang Deng, Alex X. Liu, and Raheem Beyah.
2021. MPInspector:ASystematicandAutomaticApproachforEvaluatingthe
SecurityofIoTMessagingProtocols.In proceedingsofthe30thUSENIXSecurity
Symposium (USENIX Security 2021) . USENIX Association, 4205â€“4222. https:
//www.usenix.org/conference/usenixsecurity21/presentation/wang-qinying
[68]Zi Wang, Ben Liblit, and Thomas W. Reps. 2020. TOFU: Target-Orienter FUzzer.
CoRRabs/2004.14375 (2020). https://arxiv.org/abs/2004.14375
[69]Nan Yang, Kousar Aslam, Ramon Schiffelers, Leonard Lensink, Dennis Hendriks,
LoekCleophas, andAlexanderSerebrenik. 2019. Improvingmodel inferencein
industry by combining active and passive learning. In proceedings of the 26th In-
ternational Conference on Software Analysis, Evolution and Reengineering (SANER
2019). IEEE, 253â€“263. https://ieeexplore.ieee.org/document/8668007
[70]Hengbiao Yu, Zhenbang Chen, Ji Wang, Zhendong Su, and Wei Dong. 2018.
Symbolicverificationofregularproperties.In proceedingsofthe40thInternational
ConferenceonSoftwareEngineering(ICSE2018) .IEEE,871â€“881. https://dl.acm.
org/doi/10.1145/3180155.3180227
[71]Yufeng Zhang, Zhenbang Chen, Ji Wang, Wei Dong, and Zhiming Liu. 2015.
Regular property guided dynamic symbolic execution. In proceedings of the 37th
IEEE International Conference on Software Engineering (ICSE 2015) . IEEE, 643â€“653.
https://dl.acm.org/doi/10.5555/2818754.2818833
1355