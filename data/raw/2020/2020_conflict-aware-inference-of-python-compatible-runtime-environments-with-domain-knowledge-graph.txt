Conflict-aware Inference of Python Compatible Runtime
Environments with Domain Knowledge Graph
Wei Cheng
State Key Laboratory for Novel
Software Technology
Nanjing University, China
wchengcs.nju@gmail.comXiangrong Zhu
State Key Laboratory for Novel
Software Technology
Nanjing University, China
xrzhu.nju@gmail.comWei Huâˆ—
State Key Laboratory for Novel
Software Technology
Nanjing University, China
whu@nju.edu.cn
ABSTRACT
Code sharing and reuse is a widespread use practice in software
engineering. Although a vast amount of open-source Python code
is accessible on many online platforms, programmers often find
it difficult to restore a successful runtime environment. Previous
studiesvalidatedautomaticinferenceofPythondependenciesusing
pre-built knowledge bases. However, these studies do not cover
sufficient knowledge to accurately match the Python code and also
ignore the potential conflicts between their inferred dependencies,
thusresultinginalowsuccessrateofinference.Inthispaper,we
propose PyCRE, a new approach to automatically inferring Python
compatible runtime environments with domain knowledge graph
(KG).Specifically,wedesignadomain-specificontologyforPython
third-party packages and construct KGs for over 10,000 popularpackages in Python 2 and Python 3. PyCRE discovers candidatelibraries by measuring the matching degree between the known
libraries and the third-party resources used in target code. For the
NP-complete problem of dependency solving, we propose a heuris-
ticgraphtraversalalgorithmtoefficientlyguaranteethecompat-
ibility between packages. PyCRE achieves superior performanceon a real-world dataset and efficiently resolves nearly half more
import errors than previous methods.
KEYWORDS
Python,Runtimeenvironmentinference,Knowledgegraph,Con-
flict resolution, Dependency solving, Configuration management
ACM Reference Format:
Wei Cheng, Xiangrong Zhu, and Wei Hu. 2022. Conflict-aware Inference
of Python Compatible Runtime Environments with Domain Knowledge
Graph.In 44thInternationalConferenceonSoftwareEngineering(ICSEâ€™22),
May 21â€“29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 11 pages.
https://doi.org/10.1145/3510003.3510078
1 INTRODUCTION
With the rise of programming communities such as GitHub and
StackOverflow, code sharing and reuse have become a common
âˆ—Corresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510078practice forprogrammers [ 25]. Pythonis oneof themost popular
high-levelprogramminglanguagestoday,dueinparttoitsmassive
third-partypackageresources,whichalsooftencauseenvironment
configuration issues. An empirical research [ 24] observed that the
usabilityrateofallthePythoncodesnippetsonStackOverflowis
76% parsableand 25%runnable, and thework in[ 9] furtherfound
that 75.6% of the Python code snippets shared through GitHub are
not executable with over half of failures due to missing dependen-
cies in a clean Python 2 environment.
ExecutingaPythoncodethatcontainsthird-partyresourcesina
clean Python environment triggers dependency errors, which raise
the built-in exception ImportError . To resolve this, programmers
needtospecifythepackagesanddesiredversionsinaconfiguration
scriptsuchas requirements.txt.However,thisisnotatrivialwork.
Thestudyin[ 9]observedthatprogrammersusuallyspendbetween
20 minutes and two hours to set up the environment, and in some
cases,theyevencannotrestoreacorrectexecutionenvironment.
Therefore, automatically inferring the runtime environments of
Python code helps, which can free up the time of programmers
spent on dependency issues, and thus is significant for code reuseand automated software configuration management.
However, there are several challenges to automatic inference of
Python runtime environments. Let us see a Python code snippet
showninFigure1a.Theimportedtop-levelmodules,namely redcap,
influxdb, openfisca_core andgpkit,arenotbuilt-inmodulesinthe
Python standard library. Executing pip install redcap receives
the error message ERROR: No matching distribution found
for redcap ,because redcapdoesnotexistonPythonPackageIndex
(PyPI) and the package corresponding to it is pycap. In fact, it is
commoninpracticethatthenameofamoduleimportedinPython
code does not match the name of the Python package it belongsto. Moreover, after a successful installation with
pip install
influxdb , another error message ImportError: cannot import
name InfluxDBClusterClient appears,whichindicatesthatthe
latest version influxdb-5.3.1 does not contain this attribute. In fact,
the last version containing attribute influxdb.InfluxDBClusterClient
is3.0.0.
A naive approach installs the Python packages with the same
names as the imported top-level modules. However, this approach
failstoinfercorrectdependenciesinmanycases,asillustratedinthe
above example. The challenges are essentially the lack of sufficient
domain knowledge. DockerizeMe [ 10] builds an offline knowledge
base semi-automatically to infer the environment dependencies
for Python code snippets. V2 [ 11] searches working environments
withproperversionsbasedontheerrormessagesofcodeexecution.
SnifferDog[ 21]buildsan APIbankof Pythonpackagestoinfer the
4512022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Wei Cheng, Xiangrong Zhu, and Wei Hu
1importurllib2 1numpy==1.15.4
2importredcap 2openfisca-core ==25.2.5
3frominfluxdb importInfluxDBClusterClient ascli 3pycap==1.1.1
4importopenfisca_core.simulations 4gpkit==0.9.9.2
5fromgpkitimportunits,Variable ,Model 5influxdb ==3.0.0
6fromgpkit.tools.autosweep importautosweep_1d (b) requirements.txt
7
8client = cli.from_DSN ('influxdb://usr:pwd@host1:8086â€™ )
9 1FROMpython:2.7.18
10A=Variable ("A","m**2") 2
11l=Variable ("l","m") 3COPYrequirements.txt /
12m1 =Model(A**2, [A >= l**2 + units.m**2]) 4RUNpip install -r /requirements.txt
13tol1 = 1e-3 5
14bst1 =autosweep_1d (m1, tol1, l, [1, 10], verbosity=0) 6COPYsnippet.py /snippets/snippet.py
15print("Solved after %2i passes, cost logtol +/-%.3g" % (bst1.nsols, bst1.tol)) 7CMDpython /snippets/snippet.py
(a) Python code: snippet.py (c) Dockerfile
Figure 1: A motivating example.
specificversionsandrestoretheexecutionenvironmentsofJupyter
notebooks.Thesepreviousstudieshaveachievedgoodperformancebyusingpre-builtknowledgebases,buttheydonotcoversufficient
knowledge to accurately match more complex Python code. In this
paper, we design an elaborated ontology for Python third-party
packagesandautomaticallyconstructPythonpackageknowledge
graphs (KGs) by installing and analyzing the releases on PyPI.
AfterbuildingthedomainKGs,wearestillchallengedbyhow
to match the target code with Python dependencies. To cope with
this, we design a novel metric of matching degree and treat allattributesunderatop-levelmoduleasawholetobetterdiscover
requiredlibraries.Furthermore,dependencyconflictsoccurwhen
differentinferredpackagesdependonthesamepackage,butspecify
different and incompatible versions of that package. Continuingtoconsiderthecodeshown inFigure1a,installingthelatestver-sions of packages openfisca-core andgpkitcauses a dependency
conflict,because openfisca-core-25.2.5 requiresnumpy <1.16,â‰¥1.11
andgpkit-0.9.9.9.1 requiresnumpyâ‰¥1.16.4. Thus, we should choose
an older version gpkit-0.9.9.2, which requires numpyâ‰¥1.13.3and
is compatible with other packages. Dependency solving shouldensure that all direct dependencies and transitive dependencies
(i.e. dependencies of dependencies) are compatible with the rest of
inferredenvironment.Tothebestofourknowledge,allprevious
studies [10,11,21] have not considered the compatibility of the
inferred Python environments yet. Due to the NP-completenessof dependency solving [
14], we propose a heuristic graph traver-
sal algorithm to infer a compatible environment, which efficiently
selects the newer versions and prunes the traversal paths.
The main contributions of this paper are listed as follows:
â€¢We design an ontology for Python third-party packages and
anautomaticapproachtoKGconstruction.Asaresult,we
createthePythonpackageKGsforPython2andPython3,
eachofwhichcontainstheknowledgeofover10,000Python
packages and nearly 300,000 versions. (Sections 3)
â€¢WedefineanewmetricofmatchingdegreebetweenPythonlibraries and third-party resources in target code to discover
requiredlibraries.Moreover,weconsiderthecompatibility
oftheinferredPythonenvironments,anddesignanefficient
heuristic algorithm for dependency solving. (Sections 4) 
	

		
 	


	






	
	


	
		

 	


Figure 2: Overview of our approach.
â€¢We implement our approach called PyCRE (https://github.com/nju-websoft/PyCRE) and evaluate it with 10,250 real-
worldPythoncodesnippetsonGistable[ 9].Ourexperiments
show that PyCRE efficiently resolves dependency issues for
bothPython2andPython3,leavingonly1,524 ImportError ,
which issignificantly superior to 2,654 ImportError of the
state-of-the-artapproach [11].
2 OVERVIEW OF PYCRE
Figure 2 depicts an overview of PyCRE, which automatically in-
fersPythoncompatibleruntimeenvironmentswiththepre-built
PythonpackageKGs.ThefundamentalrequirementofPyCREis
tocoverasmanythird-partyresourcesusedinthetargetcodeas
possible.Additionally,PyCREdirectlyspecifiesthepackagesand
their versions in a feasible installation order to avoid the potential
conflicts between inferred dependencies.
PyCREconsistsoftwophases,wheretheupperportionofthe
figureshowstheconstructionofour PythonpackageKGs.Allwe
canknowfromtargetcodearetheimportedmodulesandthecalled
attributes, including the names of variables, classes, functions and
even hidden submodules. See Figure 1a for example, matching the
third-partyresourcesintargetcodetothecorrectlibrariesrequires
agreatdealofdomainknowledge.Accordingtoourdesignedon-
tology, we offline construct two Python package KGs for Python 2
and Python 3, respectively.
Thebottomportionshowstheautomaticinferenceofcompati-
ble runtime environments. With the Python package KGs, PyCRE
452
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Conflict-aware Inference of Python Compatible Runtime Environments with Domain Knowledge Graph ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
parses a target Python code, discovers its candidate libraries ac-
cordingtomatchingdegrees,andgeneratesthecompatibleruntime
environment through dependency solving.
The output of PyCRE is a requirements.txt containing a list of
required Python packages with specific versions in a correct order
and aDockefile containing the inferred Python version. The de-
pendencies in requirements.txt work together, reducing the risk of
dependency conflicts compared to installing dependencies individ-
ually. For example, Figure 1b shows the requirements.txt generated
by PyCRE for the Python code shown in Figure 1a. The Dockerfile
shown in Figure 1c installs all Python packages with the command
pip install -r requirements.txt.
3 PYTHON PACKAGE KNOWLEDGE GRAPH
DomainknowledgeofPythonpackagesisessentialforautomatic
inferenceofcompatibleruntimeenvironments.Wedevoteouref-
fortstodesigninganontologyforPythonthird-partypackagesand
a method to automatically construct the corresponding KGs.
3.1 Python Package Ontology Design
As shown in Figure 3, we define an ontology to represent relation-
ships between entities and properties for describing entities:
â€¢Package node. Each package node represents a Python
package and stores the packageâ€™s nameas a property. The
storedpackagenamesarenormalizedandunified,making
no two package entities having an identical name.
â€¢Versionnode. EachversionofaPythonpackageisstoredas
adistinctversionnode.Aversionnodecontainsitsstandard
versionidentifierand install_status ofthecorrespondingre-
lease.Therearethreevaluesfor install_status :Success,Fail
andUnknown,where Unknown meansthattheversionhas
not been installed yet.
â€¢Module node. Each module node corresponds to a specific
module of a version and has two properties. Property im-
port_status takes the value TrueorFalse, indicating whether
the module can be successfully imported or not. Another
property is the fully-qualified name, e.g., clientis a submod-
ule of module redis, and its name is stored as redis.client.
However, module names are not unique, as different ver-
sions of a package may contain homonymous modules that
have different attributes, or even different packages may
have homonymous modules.
â€¢Attributenode. Eachattributenodestorestheattributeâ€™s
nameasaproperty.Unlikemodulenodes,attributeswithan
identical name are defined as a single entity in the ontology.
For example, attribute redis.client.Redis is saved as attribute
Redisof module redis.client. In our ontology, attribute can
be variable, function, class or any content available in the
corresponding module.
â—¦Package â†’Version: has_version edge,whichindicatesthe
relationship between the package and its version.
â—¦Version/Module â†’Module: has_module edge. Each suc-
cessfullyinstalledversionhasmodulesinprinciple,andmod-
ules may have their submodules.
â—¦Moduleâ†’Attribute: has_attribute edge,whichshowsthat
the attribute is available in the module.packageversion module
attributehas_versionhas_modulehas_module
has_attribute requires
Figure 3: Entities and relationships defined in the Python
package ontology.
â—¦Versionâ†’Package: requiresedge,whichrepresentsthat
the package is a direct dependency of the version, and has a
requirement property to store the version specifier.
3.2 Knowledge Acquisition
To extract knowledge, we first determine the Python packages that
we want to analyze and get all available versions. Then, we record
the installation status by installing each version of the packages.
At last, we acquire the modules, attributes and direct dependencies
of those versions that are successfully installed. The whole process
of knowledge acquisition is automated.
â€¢Packages. AlistofavailabledistributionsonPyPIcanbeob-
tainedaccordingtoPyPISimple.1Duetotheexpenseoftime
and storage, we usually specify a list of packages for further
knowledgeacquisition.Withtheknowledgeofcommonly
used Python packages in a certain domain, the success rate
ofinferredPythoncompatibleruntimeenvironmentscanbe
greatly improved.
â€¢Versions. Wegetallavailableversionsofeachpackageby
executing pip install <package >==<versionâˆ—>, since
manypackagesarenotavailableinexactlythesameversions
under different Python releases. <versionâˆ—>is a special
versionidentifierthatdoesnotexist,whichmakespipoutput
all available versions.
â€¢Installations. Some releases have strict requirements for
the supported Python versions or even require system-level
dependenciesthatpipcannothandle.Thus,noteveryrelease
onPyPIcanbeinstalledsuccessfully.Weattempttoinstall
eachversionofapackagewith pip install <package >==
<version >and record the installation status.
â€¢Requirements. Most releases require certain direct depen-
denciestobeinstalledbeforetheirinstallations,whichare
stored in their metadata. We get the dependency require-
mentsofeachsuccessfullyinstalledreleasefromits META-
DATAfile. Dependency requirements prompt a lot of un-
knownPythonpackages,duetotheincompletenessofour
KG.WecreatePackagenodesforthesepackages,butwithout
doing further knowledge acquisition.
â€¢Modulesandattributes. APythondistributionusuallyhas
multiplemodules.Foreachsuccessfullyinstalleddistribution,
wefirstattempttogetitstop-levelmodulesfrom top_level.txt.
If that file does not exist, we try to check all created directo-
riesandfilestoobtainitstop-levelmodules.Wethenfindall
1https://wiki.python.org/moin/PyPISimple
453
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Wei Cheng, Xiangrong Zhu, and Wei Hu
submodulesofeachtop-levelmodulerecursively.Finally,we
try to import each module and use Python built-in function
dir()to attain all attributes of the imported modules. We
removethemodulesandattributesthatstartwiththeunder-
score because they are conventionally intended for internal
use.
After constructing the Python package KGs, we can periodically
checkfornewpackagesandversionsbasedontheaboveprocess
to incrementally upgrade our KGs. Note that PyPI doesnâ€™t support
the replacement of existing releases but only deletion (we can also
delete the corresponding entities and relations in our KGs), thus
ensuring the consistency of our KGs.
4 ENVIRONMENT INFERENCE
Forenvironmentinference,wefirstobtaintheimportedthird-party
modules and called attributes by parsing the target code. Then, we
queryourKGstodiscovercandidatelibrariesthatbestmatchthese
modules and attributes. Finally, we expand a dependency graph
with transitive dependencies of candidate libraries, and infer the
installation instructions of compatible dependencies in order by
dependency solving.
4.1 Target Code Parsing
Astheonlyinput,weassumethatthecodeshouldbefullyparsed.To
determinewhichthird-partylibrariestobeinstalled,wefindallthe
imported modules that are not in the Python standard library and
thecalledattributesinthosemodules.Wefirstparsethetargetcode
into an abstract syntax tree (AST) in a clean Python environment,
and then walk in the AST for both of the following information:
â€¢Importedmodules .Thesyntaxforthe importstatementin
Pythonis import <module >as alias orfrom <module >
import <name>as alias .ThemodulesinthePythonstan-
dardlibraryareignored,andwestoreallpossiblethird-party
modules as imported modules. It is worth mentioning that
<name>canbeasubmodule,function,class,variableorany
attribute that can be accessed in the module. Additionally,
programmers can bind an imported resource with an op-
tionalaliasnameandusethealiasnamedirectlyinthecode,
butatthesametime,theoriginalnameoftheimportedre-
source would no longer be used. We record the mappings
between the imported resources and their alias names.
â€¢Calledattributes .Inadditiontotheimportedmodules,the
attributes of those modules used in the code are also cru-cial for discovering the candidate libraries. We visit each
attribute node in the AST and record all the attribute names
prefixedwithanimportedresourceoritsalias.Accordingto
themappingobtainedfromthe importstatement,wethen
mapthe prefixback tothecorresponding importedresource
name, thus restoring its fully qualified name for each at-tribute. For example, the fully qualified name of attribute
from_DSN isinfluxdb.InfluxDBClusterClient.from_DSN (Line
8inFigure1a).Duetotheuncertaintyin from <module >
import <name>,wetreat <module >.<name>asapossible
attribute name as well. We store these attribute names as
called attributes.gpkit
tools
autosweep
autosweep_1dVariable Model units
m
Figure 4: A parse tree generated by target code parsing.
Algorithm 1: ğ¶ğ‘ğ‘™ğ‘ğ‘¢ğ‘™ğ‘ğ‘¡ğ‘’ğ‘ ğ‘€ğ‘ğ‘¡ğ‘â„ğ‘–ğ‘›ğ‘”ğ·ğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘’ (ğ‘†,ğ¿)
Input:setğ‘†of resources, list ğ¿of resources in the library
Output:matching degree between ğ‘†andğ¿
1ğ‘‘ğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘’â†0;
2foreachğ‘Ÿğ‘’ğ‘ âˆˆğ‘†do
3ğ‘ğ‘Ÿğ‘’â†longestprefixreferencepathof ğ‘Ÿğ‘’ğ‘ matchedin ğ¿;
4ğ‘‘ğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘’â†ğ‘‘ğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘’+ğ‘ƒğ‘ğ‘¡â„ğ¿ğ‘’ğ‘›ğ‘”ğ‘¡â„ (ğ‘ğ‘Ÿğ‘’)
ğ‘ƒğ‘ğ‘¡â„ğ¿ğ‘’ğ‘›ğ‘”ğ‘¡â„ (ğ‘Ÿğ‘’ğ‘ );
5returnğ‘‘ğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘’;
We represent the imported modules andcalled attributes as a
forest.Eachtreeintheforesthasatop-levelmodulenameasarootnode,andcontainsallthesubmodulesandattributesofthatmodule
inthecode.Forinstance,byparsingtheexamplePythoncodein
Figure 1a, the parse tree of module gpkitis shown in Figure 4.
The results of target code parsing can be used to infer the candi-
date Python versions. We parse the code in Python 2 and 3, respec-
tively,andthePythonversionswiththefewest importedmodules
and no syntax errors are the candidates. For example, the imported
moduleurllib2(Line 1 in Figure 1a) is a standard library in Python
2andhasbeensplitintoseveralmodulesinPython3named url-
lib.request andurllib.error. The sample code imports fewer non-
standardmodulesinPython2thaninPython3,andthusitsPython
version is inferred. If the number of imported modules is equal, we
would extrapolate further in the following.
4.2 Candidate Library Discovery
In this phase, for each candidate Python version, we query the
correspondingPythonpackageKGtofindthecandidatelibraries
that best match the forest obtained by code parsing.
For the resources (i.e. modules or attributes) used in the code, it
is more reasonable to use partial matching than to precisely query
thefullyqualifiednamesintheKGduetoincompleteknowledge.
However,widely-usedstringsimilaritymetricssuchaseditdistanceandJaccardcoefficient[
5]arenotapplicablehere,asafullyqualified
namerepresentsareferencepath,e.g., openfisca_core.simulations
andsapphire.simulations aretwocompletelyunrelatedmodules.We
define a metric based on the longest prefix match of the reference
pathtocalculatethematchingdegreebetweenalistofresourcesand
a library, as shown in Algorithm 1. Reference paths in Python are
separatedbydots.Forexample,thelengthofthereferencepathfor
resourceinfluxdb.InfluxDBClusterClient.from_DSN is3.Although
therelease influxdb-5.3.1 hasattribute influxdb.InfluxDBClient,its
longest prefix reference path is influxdband matching degree is1
3.
We discover candidate libraries separately for each parse tree in
the forest according to the following steps:
454
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Conflict-aware Inference of Python Compatible Runtime Environments with Domain Knowledge Graph ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
S1.WequerytherootnodeoftheparsetreeintheKG,which
referstoatop-levelmodule.Iftherearemoduleentitieswith
thesamenameintheKG,wedirectlygotoS2withthequery
results.Otherwise,weattempttoinstallaPythonpackage
with the same name as the top-level module.
S2.Theremaybedifferentversionsorevendifferentpackages
thathavethesame top-levelmodule,sowefilterthese can-
didatesfurtherbysubmodules.Wesetmax-hopasthedepth
of the parse tree and query our KG to obtain spanningtrees reachable from the top-level modules following thehas_module relationships to max-hop. Then, we calculate
thematchingdegreebetweentheimportedmodulesandthe
modules with import_status asTruein each spanning tree.
The candidate spanning trees with the highest matching
degree are retained.
S3.Sincetheversionupdatesmaycausetheadditionorremoval
ofattributes,weneedtoselecttheproperversions.Ween-
richthespanningtreesbyqueryingtheattributesofmodulesintheparsetree.Similarly,wecalculatethematchingdegreebetweenthecalledattributesandtheresourcesineachspan-
ning tree. The candidate trees with the highest matchingdegree are retained, and their corresponding libraries are
optimal for the parse tree.
After our discovery process, we finally determine the candidate
libraries of each parse tree in the forest, which may correspondto multiple versions of more than one package. Meanwhile, thePython version with the maximum matching degree is selected.
Python 3 is the default if their matching degrees are equal.
4.3 Dependency Solving
Tocovermostthird-partyresourcesusedinthetargetcode,each
top-level module should have at least one candidate library in the
inferred runtime environment. Furthermore, we expect each pack-
age in the inferred environment to meet all its version constraints,
which is called dependency solving.
Dependency solving is a hard problem in all non-trivial com-
ponent models and has been proved NP-complete [ 1,14]. Existing
worktreatsdependencysolvingasaseparateconcerninpackage
manager[ 2]andreliesongenericdependencysolversbasedonthe
tried-and-tested techniques such as solvers of the Boolean satisfia-
bility problem (SAT) [ 3]. There are efficient modern SAT solvers
[7,13,18], but it is nearly impossible to control the answers pro-
vided by the solvers with many priorities. For optional versions
of a Python package, we prefer the latest version that can be in-stalled successfully, since the latest version is usually downward
compatiblewithpreviousversionsandcontainsnewresources.Fortimeefficiencyandcompliancewithversionselectionpriorities,we
propose an efficient heuristic graph traversal algorithm.
We create a start node, which points to all the virtual nodes that
representthetop-levelmodules.WequeryourKGsforalltransitive
dependenciesofthecandidatelibraries,formingaheterogeneous
directedgraphcalleda dependencygraph.Thedependencygraph
wouldbeiterativelyextendeduntiltherearenomoredependencies.
Thenodesinthedependencygrapharedividedintoconjunction
nodesanddisjunctionnodes.Conjunctionnodesincludethestart
node and version nodes, which depend on all its direct successors.Disjunctionnodesincludemodulenodesandpackagenodes,which
require at least one direct successor. Moreover, each edge pointing
to a package node is attached with specific dependency require-
ments,whichrestrictthechoiceofitsversions.Theversionsthat
failtobeinstalledduringknowledgeacquisitionarenotconsidered.
Definition 1 (Compatible dependency subgraph) .Letğº=(ğ‘‰,ğ¸)
beadependencygraph,where ğ‘‰denotesthevertexsetincluding
packages,versionsandmodules,and ğ¸denotesthedirectededgeset
based on the dependency relationships. A compatible dependency
subgraph ğº/prime=(ğ‘‰/prime,ğ¸/prime)ofğºsatisfies:
(i)ğ‘‰/primeâŠ†ğ‘‰,ğ¸/primeâŠ†ğ¸, and start node ğ‘ âˆˆğ‘‰/prime.
(ii)We denote edge ğ‘â†’ğ‘by(ğ‘,ğ‘), and regard a specific ver-
sionrequirementasacollectionofversionsthatsatisfythe
requirement. Compatibility requires:
â€¢For each conjunction node ğ‘âˆˆğ‘‰/prime,âˆ€ğ‘’=(ğ‘,ğ‘›)âˆˆğ¸,ğ‘’âˆˆğ¸/prime.
â€¢Foreachdisjunctionnode ğ‘‘âˆˆğ‘‰/prime,letğ‘†={ğ‘’|ğ‘’=(ğ‘‘,ğ‘›)âˆˆ
ğ¸},|ğ¸/primeâˆ©ğ‘†|â‰¥1(=1, ifğ‘‘is a package node).
â€¢For each package node ğ‘âˆˆğ‘‰/prime, letğ‘…={requirement of
ğ‘’|ğ‘’=(ğ‘–,ğ‘)âˆˆğ¸/prime},âˆƒ(ğ‘,ğ‘›)âˆˆğ¸/prime,ğ‘›âˆˆ/intersectiontext.1
ğ‘Ÿâˆˆğ‘…ğ‘Ÿ.
SAT solver. Withthedependencygraph,eachnodecorresponds
to a Boolean variable and the constraints are encoded as a Boolean
formula in conjunctive normal form (CNF). The constraints of a
dependencygrapharetranslatedintoBooleanclausesinCNFac-
cording to the following rules:
â€¢Start node ğ‘ is set toTrue, denoted by (ğ‘ ).
â€¢A conjunction node ğ‘decides all its direct successors ğ‘¥1,ğ‘¥2,
...,ğ‘¥ğ‘›:ğ‘â†’(ğ‘¥1âˆ§Â·Â·Â·âˆ§ğ‘¥ğ‘›)â‰¡/logicalandtext.1
1â‰¤ğ‘–â‰¤ğ‘›(Â¬ğ‘âˆ¨ğ‘¥ğ‘–).Conjunction
nodes include the start node and version nodes.
â€¢Adisjunctionnode ğ‘‘decidesatleastoneofitsdirectsucces-
sorsğ‘¥1,ğ‘¥2,...,ğ‘¥ğ‘›:ğ‘‘â†’(ğ‘¥1âˆ¨Â·Â·Â·âˆ¨ğ‘¥ğ‘›)â‰¡(/logicalortext.1
1â‰¤ğ‘–â‰¤ğ‘›(ğ‘¥ğ‘–)âˆ¨Â¬ğ‘‘).
Disjunctionnodesincludemodulenodesandpackagenodes.
â€¢A virtual module node ğ‘šrequires at least one of its can-
didate versions ğ‘£1,ğ‘£2,...,ğ‘£ğ‘›:ğ‘šâ†’(ğ‘£1âˆ¨ğ‘£2âˆ¨Â·Â·Â·âˆ¨ğ‘£ğ‘›)â‰¡
(/logicalortext.1
1â‰¤ğ‘–â‰¤ğ‘›(ğ‘£ğ‘–)âˆ¨Â¬ğ‘š).Meanwhile,eachcandidateversion ğ‘£ğ‘–
requires its package ğ‘ğ‘–:/logicalandtext.1
1â‰¤ğ‘–â‰¤ğ‘›(Â¬ğ‘£ğ‘–âˆ¨ğ‘ğ‘–).
â€¢A package node only has one of its versions ğ‘£1,ğ‘£2,...,ğ‘£ğ‘›:/logicalandtext.1
1â‰¤ğ‘–<ğ‘›,ğ‘–<ğ‘—â‰¤ğ‘›(Â¬ğ‘£ğ‘–âˆ¨Â¬ğ‘£ğ‘—).
â€¢A version node ğ‘£is incompatible with versions ğ‘£1,ğ‘£2,...,ğ‘£ğ‘›
of its direct dependencies that do not meet the specific re-
quirements: ğ‘£â†’( Â¬ğ‘£1âˆ§Â¬ğ‘£2âˆ§Â·Â·Â·âˆ§Â¬ğ‘£ğ‘›)â‰¡/logicalandtext.1
1â‰¤ğ‘–â‰¤ğ‘›(Â¬ğ‘£âˆ¨Â¬ğ‘£ğ‘–).
Iftheformulaissatisfiable,theresultingcompatibledependency
subgraph would consist of all the nodes with value Trueand the
edges between them.
Ourheuristicalgorithm. Thedetailsofouralgorithmareshown
in Algorithm 2 and we start traversing from the start node with
an empty subgraph. With the depth-first search (DFS), our algo-
rithm has two heuristic strategies: (i) Priority: we prefer the latest
version (Line 13) that can be successfully installed by sorting all
compatible versions (Line 8); (ii) Pruning: if one version of a pack-
ageisincompatible,weskiptheotherversionsofthatpackagewith
identicaldependencyrequirements(Line15),becausetheywould
cause the same conflicts. When the currently selected version ofa package does not satisfy the newly added version constraints,the current version and all its direct dependencies and transitive
dependencies need to be removed from the subgraph (Line 11). We
455
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Wei Cheng, Xiangrong Zhu, and Wei Hu
Algorithm 2: ğ¸ğ‘¥ğ‘¡ğ‘’ğ‘›ğ‘‘ğ‘ ğ‘†ğ‘¢ğ‘ğ‘”ğ‘Ÿğ‘ğ‘â„ (ğº/prime,ğ‘›,ğ‘)
Input:subgraph ğº/primeto be extended, current traversed node
ğ‘›, direct predecessor ğ‘ofğ‘›in this visit
Output:ğ‘‡ğ‘Ÿğ‘¢ğ‘’orğ¹ğ‘ğ‘™ğ‘ ğ‘’(indicating whether a compatible
subgraph can be found.)
1ğ‘¡ğ‘šğ‘ğºâ†ğº/prime, and add node ğ‘›and edge (ğ‘,ğ‘›)toğ‘¡ğ‘šğ‘ğº;
2ifğ‘›is a conjunction node then
3foreachdirect successor ğ‘ofğ‘›do
4 ifÂ¬ğ¸ğ‘¥ğ‘¡ğ‘’ğ‘›ğ‘‘ğ‘ ğ‘†ğ‘¢ğ‘ğ‘”ğ‘Ÿğ‘ğ‘â„ (ğ‘¡ğ‘šğ‘ğº,ğ‘,ğ‘› )then
5 returnğ¹ğ‘ğ‘™ğ‘ ğ‘’;
6ğº/primeâ†ğ‘¡ğ‘šğ‘ğº;returnğ‘‡ğ‘Ÿğ‘¢ğ‘’;
7else
8ğ¶â†version-sorted direct successors of ğ‘›which are
compatible in ğ‘¡ğ‘šğ‘ğº;
9ifexists edge (ğ‘›,ğ‘‘)âˆˆğ‘¡ğ‘šğ‘ğºthen
10 ifğ‘‘âˆˆğ¶thenğº/primeâ†ğ‘¡ğ‘šğ‘ğº;returnğ‘‡ğ‘Ÿğ‘¢ğ‘’;
11 elseremove(ğ‘›,ğ‘‘), and recursively remove the
dependencies of version ğ‘‘fromğº/prime;
12whileğ¶is not empty do
13 ifğ¸ğ‘¥ğ‘¡ğ‘’ğ‘›ğ‘‘ğ‘ ğ‘†ğ‘¢ğ‘ğ‘”ğ‘Ÿğ‘ğ‘â„ (ğ‘¡ğ‘šğ‘ğº,ğ¶[0],ğ‘›)then
14 ğº/primeâ†ğ‘¡ğ‘šğ‘ğº;returnğ‘‡ğ‘Ÿğ‘¢ğ‘’;
15 elseremoveğ¶[0]and the elements that have the
identical dependency requirements in ğ¶;
16returnğ¹ğ‘ğ‘™ğ‘ ğ‘’;
only backtrack on the current search path when we encounter a
dependencyconflict,whichishighlyefficientbutinrarecasesmay
miss solutions. To address it, we call a SAT solver as the fallback
to ensure the completeness of our algorithm when it claims that
there is no solution.
Let us see the dependency graph in Figure 5. According to DFS,
our algorithm first traverses to openfisca-core-25.2.5, depending on
numexper-2.6.8 thatrequires numpyâ‰¥1.7.Thus,thelatestversion
1.16.6ischosenfor numpy.Whenconsideringthedirectdependency
ofopenfisca-core-25.2.5 onnumpy,itisfoundthat numpy-1.16.6 does
not meet the new version requirements <1.16,â‰¥1.11.S o ,numpy-
1.16.6is removed (it does not depend on other packages) and a
compatible version 1.15.4is reselected. When traversing to the
packagegpkit, we prefer the latest version 0.9.9.9.1. However, its
versionrequirement â‰¥1.16.4fornumpyconflictswiththeprevious
requirement <1.16,â‰¥1.11, so we reselect the version of gpkit.W e
skip version 0.9.9.9, which has the identical requirement for numpy
as the incompatible version 0.9.9.9.1, and traverse to version 0.9.9.2.
The version requirements of gpkit-0.9.9.2 are compatible and the
currentversionof numpymeetsalltherequirements.Now,wefind
a compatible dependency subgraph using our heuristic algorithm.
At last, we identify the packages that need to be explicitly in-
stalled as well as the installation order. After removing the start
nodeandmodulenodesinthesubgraph,allpackageswithanin-
degreeof0arerequiredtobeinstalledexplicitly,sincetheyarenot
the dependencies of any packages. Moreover, for a package, if the
latestversionthatmeetsitsversionconstraintsisdifferentfromthe
selected version, it would probably lead to an unexpected version,start
gpkit gpkitopenfisca
_coreopenfisca
-core
0.9.9.9.1
0.9.9.2numpy25.2.5 numexper 2.6.8==2.6.8
Â•1.7
Figure5:Partialdisplayofadependencygraph.Nodecolorsare in accord with the colors of entity types in Figure 3 ex-cept for the start node. Nodes with dashed outgoing edgesareconjunctionnodes,andnodeswithsolidoutgoingedgesare disjunction nodes. Best viewed in color.
sowe installthispackage explicitly aswell.The installationorder
ofallpackagesisgeneratedbytopologicalsorting,whichensures
that all dependencies of each package are installed ahead of time.
5 EVALUATION
5.1 Experiment Settings
Dataset. We conduct ourexperiments onthe Gistable [ 9] dataset,
which is a real-world dataset built on the GitHubâ€™s gist system and
contains 10,250 single-file Python code snippets. DockerizeMe and
V2 have also been evaluated on this dataset.
Comparative methods. In addition to our PyCRE, several com-
parative methods are assessed in the experiments:
â€¢Gistable [ 9], which attempts to install the Python packages
withthesamenamesastheimportedtop-levelmodules.It
is a baseline method and does not use any knowledge.
â€¢DockerizeMe[ 10],whichinferstheruntimeenvironments
based on a pre-built knowledge base, without considering
Python versions nor specific dependency versions.
â€¢V2 [11], which reuses the inference results of DockerzieMe
as the starting environments in Python 2 and Python 3, and
guides the version changes by the error messages of code
execution until finding a working environment.
â€¢SnifferDog[ 21],which usesa pre-builtAPIbank torestore
the execution environments of Jupyter notebooks.
Prior knowledge. For the fairness of our experiments, all meth-
odsshouldacquireknowledgeforthesamePythonpackages.We
obtain a list of Python packages from the knowledge base built by
DockerizeMe[ 10].AccordingtoPythonEnhancementProposals
(PEP)508[ 6],Pythonpackagenamesarecase-insensitiveanddonot
distinguishbetweendash,dotandunderscore.So,wemergethedu-
plicatepackagessuchas Flask-RESTful andflask_restful.Eventually,
we have 10,765 unique Python packages for knowledge acquisition.
TheknowledgebasebuiltbyDockerizeMeforthe10,765Python
packages is available. V2 uses the inference results of DockerzieMe
as the starting environments, so it can be ignored. It is worth men-
tioning that the knowledge acquisition of DockerizeMe is not fully
automated but requires manual work. SnifferDog only acquires
knowledgeforaspecialselectionof488Pythonpackages.Inthis
paper, we build its API bank for the 10,765 packages using its pub-
liclyavailablecode.WealsoautomaticallyconstructourKGsfor
Python2andPython3bythemethoddescribedinSection3.2.The
456
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Conflict-aware Inference of Python Compatible Runtime Environments with Domain Knowledge Graph ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table1:Statisticsoftheexitstatusofcodeexecutiononthe
Gistable dataset.
Exit status Python 2 Python 3
Success 2,112 1,293
Timeout 132 71
ImportError 5,515 3,536
SyntaxError 719 4,388
Other Exceptions 1,772 3,212
knowledge of PyCRE and other methods is stored in a Neo4j data-
base,exceptforSnifferDog,whichisloadeddirectlyintomemory
according to its design.
Validationenvironment. WeleverageDockertoensurethateach
Pythoncodeexecutesinanisolatedenvironment.ForPython2and
Python3,ourDockerimagesareinitializedontheofficialimages
python:2.7.18 andpython:3.8.11,respectively.Weupdatepiptothe
latestversion,currently20.3.4and21.2.4forPython2andPython3,
respectively. We configure pip to use its new dependency resolver
by default, which refuses to install the packages with incompatible
requirement combinations. We conduct all experiments on Ubuntu
18.04 LTS with one Intel Xeon Gold 5117 CPU and 16GB memory.
Experiment procedure. GiventhatonlyourPyCREandV2can
infer the Python version for target code and V2 cannot specify afixed Python version, we conduct the experiments in three envi-
ronments: Python 2, Python 3 and the inferred Python versions.
For each method, we first infer dependencies for each code in
thedatasetandrecordthetimespentontheinferencetoanalyze
the efficiency. The timeout of inference is set to one hour, since V2
isadynamicinferencemethod,whichneedstorepeatedlyrollback
theversionsandgeneratethevalidationenvironments.Thecode
toinfer dependenciesinSnifferDog isincomplete,so wereplicate
it according to their paper for enabling SnifferDog to infer the
dependencies of Python code.
Then, we record the inferred Python dependencies in require-
ments.txt in order and build the Docker image according to the
experimental settings. To avoid the failures due to network fluctua-
tion or other factors, we give ten minutes for each Python package
installation whenbuilding each Docker imagefor validation. Fail-
ures to install dependencies when building images are ignored,
which is in line with the behavior of programmers.
Finally, we run the code in the corresponding Docker container.
The code snippets that run successfully are marked as Success.
Wemarkthecodesnippetsrunningformorethanoneminuteas
Timeout, because some code may not stop running due to await-
ing input,encountering dead loops,etc. The othersare marked as
Exception andthenamesoftheirexceptionsarerecorded.SinceV2
onlyreturnsdependencieswhenitfindsaworkingenvironment,foreachfailedcode,weselecttheexceptionnameofthelastvalidationfromitsoutputlogs.Built-inexception
ImportError israisedwhen
animportstatement fails to find the module definition or when a
from ... import statementfailstofindthenametoimport.We
alsoincludePython3â€™sbuilt-inexception ModuleNotFoundError
asImportError , which is a subclass of ImportError and raised
byimportwhen a module cannot be located.Table 2: Statistics of our Python package KGs.
Entity Python 2 Python 3
Package 12,948 13,439
Version 291,805 307,841Module 11,316,114 11,240,182Attribute 772,774 853,389
Total 12,393,641 12,414,851Relationship Python 2 Python 3
has_version 291,805 307,841
has_module 11,316,114 11,240,182
has_attribute 125,554,883 124,215,617
requires 717,357 946,092
Total 137,880,159 136,709,732
Dataset analysis. We run each code in the Gistable dataset in
the validation environment and the exit status is shown in Table 1.
Thereare4,388codesnippetswith SyntaxError inPython3,much
morethan719inPython2,whichinclude454codesnippetsthat
havesyntaxerrorsinbothversions.Thedifferenceinthenumberof
code snippets that run successfully also indicates the bias towards
Python2inthedataset.Allautomaticinferencemethodsonlyfocus
on dependencies, i.e. ImportError , because it is almost impossible
toautomaticallyresolveerrorsinthecodeitselformissingexternal
inputs such as database [ 16]. So, our experiments only validate the
inferred environments of code snippets with ImportError.
5.2 Evaluation of Knowledge Graph
Our knowledge graphs. Knowledge acquisition is indeed time-
consuming, which takes about 135 hours using 20 normal CPU
cores. The rest of the building process is negligible in comparison.
Thewholeprocesscanbeeasilyacceleratedbyparallelization,thus
reducingtime andeffort toa greatextent.Table 2shows thescale
ofourPythonpackageKGsandthequantitiesofeachtypeofen-
tities and relationships. Excluding those packages for which no
version is available in the corresponding Python environments, we
analyze 10,623 and 10,564 packages in Python 2.7.18 and Python
3.8.11,respectively.Theextra2,325and2,375packagesareadded
duetopackagedependencies,butwedonotperformknowledgeacquisition for these packages to ensure the fairness of knowl-
edge.ByfurtheranalyzingourKGs,wefindthat74,657(25.6%)and
68,281 (22.2%) versions fail to be installed, and 2,337,425 (20.7%)
and 2,360,264 (21.0%) modules fail to be imported in Python 2 and
Python 3, respectively, due to various issues such as missing de-
pendencies and incompatible Python versions. This indicates that
thereleasesonPyPIcannotalwaysbeinstalledsuccessfully,and
the modules andattributes obtained by statically parsing the code
cannot always be used successfully. Moreover, nearly 74% of the
successfully installed versions have at least one direct dependency,
showing the necessity to consider the compatibility of inferred
dependencies.
Domain knowledge. To compare the knowledge acquired by dif-
ferentmethods,wecountthequantitiesofversions,modulesand
attributes, which are shown in Table 3. The modules and attributes
with the same full-qualified names are counted only once, and the
packageshaveatleastoneversion.DockerizeMeanalyzesthelatest
version of each package to get the name of top-level modules, con-
taining the fewest domain knowledge. SnifferDog downloads all
releases on PyPI for each package and statically parses the Python
codetogetallthedefinedAPIs.Itfailstogetanytop-levelmodules
for 4,831packages, mainly because itcannot infer thePython ver-
sionsneededforstaticparsing.IncontrasttoourPyCRE,SnifferDog
getsslightlymoreversionsandattributes,butcannotdeterminethe
457
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Wei Cheng, Xiangrong Zhu, and Wei Hu
Table 3: Comparison of domain knowledge acquired by dif-
ferent methods.
Method Package Version Module Attribute
DockerizeMe 10,441 11,254 9,517 -
SnifferDog 10,638 316,376 5,7644,580,920
PyCRE (Python 2) 10,623 291,805 338,709 4,343,530
PyCRE (Python 3) 10,564 307,841 302,908 3,949,917
Table4:ComparisonofknowledgecoverageontheGistable
dataset.
Method Top-level module Submodule Attribute
Dataset 1,721 7,083 8,704
DockerizeMe 727 - -
SnifferDog 513 - 1,924
PyCRE (Python 2) 800 1,622 3,486
availability of this knowledge, which may cause unexpected errors
in the inferred environments. Additionally, we add submodules
intothePythonpackageontology.Theacquisitionofsubmodules
providesalargeamountofmoduleknowledgeforPyCRE,which
are useful to infer appropriate dependencies.
Knowledgecoverageondataset. Weanalyzethecoverageofthe
knowledgeacquiredbyeachmethodontheGistabledataset,which
significantlyinfluencestheresultsofinference.Consideringthat
thedatasetismorebiasedtowardsPython2,weparseeachcode
under Python 2.7.18 by the approach presented in Section 4.1. We
dividetheimportedmodulesintotop-levelmodulesandsubmod-
ules, since only our method supports queries for submodules. The
analytical results are shown in Table 4. Compared to DockerizeMe
and SnifferDog, our KG has the maximum coverage on all types
of knowledge, but still lacks a large amount of knowledge about
the dataset. Only800 (46.5%) top-level modules arecovered in our
KG, which means that in many cases PyCRE can only choose to
installthePythonpackagewiththesamename.Submodulesand
attributes are covered with 1,622 (22.9%) and 3,486 (40.1%), respec-
tively.Itincreasesthedifficultyofdiscoveringcandidatelibraries,
which reflects the realistic limitations of exact matching and the
necessity of our matching degree.
5.3 Evaluation of Inference
We evaluate the effectiveness and efficiency of PyCRE in infer-
ring Python compatible runtime environments. Table 5 shows the
validation results of the inferred environments by each method.
ImportError. The most intuitive assessment is the ability to re-
solve ImportError , which reflects the effectiveness of the runtime
environmentinference.AsshowninTable5,PyCREresolvesthe
most ImportError inallthreedifferentsettingsandissignificantly
better than the comparative methods.
Gistable, the baseline method that is consistent with the pro-
grammerâ€™s behaviors in solving dependency issues, fails to resolve
ImportError for2,592gistsand1,751gistsinPython2andPython
3, respectively. DockerizeMe fails to resolve ImportError in more
gists than the baseline Gistableâ€™s method, mainly because of itsTable 5: Validation of the inferred environments generated
by each method in different Python releases.
Method ImportError Success Timeout Others
Dataset 5,515 2,112 132 2,491
Gistable 2,592 2,988 422 4,248DockerizeMe 2,624 2,986 415 4,225SnifferDog 2,296 3,086 466 4,402PyCRE 1,645 3,309 499 4,797
(a) Environment validation in Python 2.
Method ImportError Success Timeout Others
Dataset 3,536 1,293 71 5,350
Gistable 1,751 1,934 218 6,347DockerizeMe 1,965 1,903 183 6,199SnifferDog 1,632 1,960 254 6,404PyCRE 1,302 2,114 270 6,564
(b) Environment validation in Python 3.
Method ImportError Success Timeout Others
V2 2,654 3,073 379 4,144PyCRE 1,524 3,410 579 4,737
(c) Environment validation with the inferred Python versions.
methodofmatchingtargetcodeandPythondependencies.Docker-
izeMe uses partial matching for imported modules to find libraries
in the knowledge base, which is based on the longest prefix of the
module name. For example, statement from pyspark.sql.functions
importudf inthecodesnippet2ismappedtothepackage py,be-
causethereisnomodule pysparkandthelongestmatchedprefixis
modulepyinDockerizemeâ€™sknowledge base.Howeve r,thePython
packagecorrespondingtothismoduleis pyspark,whichisthepack-
age that other methods choose to install. In fact, DockerizeMe uses
domain knowledge to solve 482 code for which baseline cannot
solve ImportError ,butfailstosolve514codeforwhichbaseline
can solve ImportError in Python 2. Although these two methods
do not specify versions for the inferred packages, which minimizes
the version restrictions, they still encounter dozens of dependency
conflicts.
SinceV2usestheinferenceresultsofDockerzieMeasthestarting
environments, its performance is similarly affected. V2 claims to
findworkingenvironments for3,206code,but133of themdonot
runsuccessfullyinourvalidation,andevenhavedependencyissues.
One major reason is that V2 does not consider the compatibility
betweenthe packagesinthe inferredenvironments. Additionally,
DockerizeMe and V2 install some packages incidentally according
totheirassociationrules,whichleadstomanyredundantpackages
and is also more likely to cause dependency conflicts.
SnifferDogachievesrelativelygoodperformance,mainlybecause
it has a large amount of API knowledge to assist its inference.
However,SnifferDogisdesignedforJupyternotebooksandignores
some issues in Python, such as the inference of Python versions,
which affects its applicability on more general Python code.
2https://gist.github.com/samuelsmal/feb86d4bdd9a658c122a706f26ba7e1e
458
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Conflict-aware Inference of Python Compatible Runtime Environments with Domain Knowledge Graph ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table6:Averageandlongestinferencetimeofeachmethod
for5,655codesnippetswithatleastonethird-partypackage
and have no inference timeout in all methods.
Method DockerizeMe V2 PyCRE
Avg. time (s) 5.0 128.0 7.0
Max. time (s) 120.6 3,570.7 215.2
Workingenvironments. Another valuable metric is the number
ofworkingenvironments,whichindicatestheabilityofaninfer-
ence method to restore the runtime environments of Python code.
As shown in Table 5, PyCRE infers a successfully runnable envi-
ronment for the most Python code snippets in all three different
settings.Moreover,thecodemarkedas Timeout usuallyhasadead
looporawaitsinputs,andcanbetreatedas Successatleastuntil
theytimeout.Inthissense,itcanbeassumedthatPyCREinfers
the working environments for 3,989 (38.9%) gists, which is also the
best result among all methods.
Inferencetime. Inferencetimeisacrucialmetricfortheefficiency
ofinferencemethodsandrepresentstheuserâ€™swaitingtime,which
is one of the most important performance metrics for software.
As listed in Table 6, we evaluate the average inference time and
thelongestinferencetimeforeachmethod.Weonlyconsiderthe
5,655giststhathaveatleastonethird-partypackageinPython2
or Python 3 and have no inference timeout in all methods. Since
the API bank of SnifferDog is loaded in memory and does notquery an external database, we do not discuss its inference time.
TheinferencetimeofDockerizeMeandPyCRE,whichfullyuses
pre-built knowledge bases, are short and comparable, whereas V2,
which involves online execution, has a much longer inference time.
ItisworthnotingthatonlytheinferenceofV2for353gistsdoes
not finish in one hour.
Ablation experiment. To validate the effectiveness of our pro-
posed heuristic algorithm, we exclusively use the SAT solver to
conductanablationexperiment(i.e.disableourheuristicalgorithm),
whichiscalledPyCRE(SATonly).IntheinferredPythonversion,
PyCRE(SATonly)infers3,337environmentsmarkedas Success
and 536 marked as Timeout, leaving 1,597 ImportError . PyCRE
withtheheuristicalgorithm,showninTable5c,issuperiortoPy-
CRE(SATonly)inthevalidationofinferredresults.Theaverage
solvingtimeoftheheuristicalgorithmis0.2secondswhiletheSAT
solver is 3.9 seconds. However, the longest time of the heuristic
algorithmis8.4seconds,whichismuchlowerthan219.3secondsof
the SAT solver, and the difference becomes more significant as the
sizeofthedependencygraphincreases.Moreover,comparedtoourheuristicalgorithm,onlyusingtheSATsolverhasproblemscaused
byrandomness.TheSATsolvermaychooseoldversionsaslong
asthedependencyrequirementsaremet,butitusuallyleadstoa
lossofcompatibilitywithnewerversions.Also,theenvironments
inferred by the SAT solver are variable and have the potential to
introduceredundantdependencies,whichmaycausetroublesfor
users.Basedonouranalysis,ourheuristicalgorithmsolves5,602
(99.4%)ofthe5,637codesnippetsforwhichhaveatleastonedepen-
dency and a compatible solution. We believe the approximation of
ourheuristic algorithmisgood. Besides,whilespecifyingaversion
for each inferred package can better match the target code, such24.30%
11.10%
11.00%
10.20%8.00%4.70%30.70%ImportError
OSError
SystemExit
NameError
SyntaxError
AttributeError
Others
Figure 6: Proportions of 6,261 ( =1,524+4,737) exceptions
thrown by the environment validation inferred by PyCRE.
versionrequirementsaremorelikelytocausedependencyconflicts.
Incontrast,ourapproachiseffectivelyconflict-awarethroughde-
pendency solving, with dependency conflicts occurring only in 18
inferred environments.
Exception statistics. We further analyze the exceptions in Ta-
ble 5c for the validated environments inferred by PyCRE. We in-
clude the subclasses of an exception in the count of that exception
and the results are shown in Figure 6. Except for ImportError ,
the three most common Python built-in exceptions are OSError,
SystemExit andNameError , which are mainly caused by code de-
sign or missing extra inputs, and cannot be solved by installing
dependencies. SyntaxError israisedlargelyduetothetargetcode
itself.Moreover, AttributeError israisedwhenanattributeref-
erence fails, mainly due to the reference on NoneType and some
third-party resource. Therefore, we can assume that in most cases,
the packages are also compatible in the inferred environments
where ImportError is resolved by PyCRE.
Practicalsignificance. TheeffectivenessandefficiencyofPyCRE
contributes to software engineers solving dependency issues of
Python code in practice. Beginners often have difficulty building a
runtimeenvironmentforsamplecode,andprofessionalprogram-
mers also waste muchtime with complicated versions and depen-
dencies. As in the manual evaluation on the Gistable dataset, it
takes software engineers between 20 minutes and 2 hours to build
theruntimeenvironment[ 9],whiletheaverageinferencetimeof
our approach on this dataset is only 7 seconds, which can signif-
icantly improve the efficiency of development. Considering the
performance of PyCRE, it is also important for the development of
automated configuration management.
5.4 Threats to Validity
Theresultsofourexperimentsmaysufferfromseveralthreatsto
validity.Thefirstisthefairnessofknowledge,whichcanlargely
affect the inferred results of individual methods. For this reason,all methods in our experiments acquire knowledge based on the
same 10,765 packages following their own methods. However, the
knowledge base shared by DockerizeMe and V2 was previouslyconstructed, and the latest versions of Python packages in it are
sometimesnotthelatestversionsatnow.Wethinkthatthishaslittle
459
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Wei Cheng, Xiangrong Zhu, and Wei Hu
impact on the experimental results because the dataset was pro-
posed earlier than the construction of the DockerizeMe knowledge
base,whichmeansthatthecodeactuallyreliesonolderversions
ofthe packages.Oppositely,more newversions inPyCRE alsoin-
crease the difficulty of inference. Another threat is Timeout in the
validation results. The code that is marked as Timeout does not
throw any exceptions in a minute, but this does no guarantee that
therearenoproblemsinsubsequentexecution.Consideringthat
the import statements for resources are usually at the beginning of
the Python code, code that executes with a timeout usually does
not have dependency issues, which mitigates this threat.
5.5 Case Study
Inadditiontoresolvingthecompatibilityofinferredenvironments,
the following Python code snippets illustrate several other unique
capabilities of PyCRE.
Skip unusable releases. PyCRE obtains the real status of pack-
age installations andmodule imports withknowledge acquisition,
which can guide PyCRE to skip the releases that are actually unus-
able. See the code snippet excerpted from a real-world gist:3
1frompytubeimport YouTube
2defdownload_video (video_url, output):
3 youtube = YouTube(video_url)
4 video = youtube.filter( 'mp4')[0]
5 return video.download(output)
NotethatthiscodeisonlycompatiblewithPython2.Gistable
and DockerizeMe generate pip install pytube to install the
dependency, which means that the latest version pytube-9.6.0 in
Python 2 would be installed by default. However, after successfully
installing the package, it fails to import pytubein the code, which
raisesanexceptionduetotheprobleminthisversionitself.V2fails
to find a working environment for this code, because it encounters
timeout while verifying the candidate environment, resulting in
no information available toguide the version changes. SnifferDog
statically parses all versions of pytubeand the latest version 11.0.0
contains the attribute pytube.YouTube, so it selects pytube-11.0.0,
which fails to be installed and is actually only available in Python
3. In the knowledge acquisition phase, we already know that the
modulecannotbesuccessfullyimportedintheseversions,sobased
onourpre-builtKGs,PyCREskipstheunusableversionsandinstalls
pytube==9.5.2.
Avoid useless downloads. If one version of a package fails to
beinstalledorisincompatiblewithotherpackages,pipwouldat-
tempt to install other versions instead, which is also known as the
backtrackingbehavior.4Sincepipdoesnothavefullpackagedepen-
dencyinformationbeforedownloadingthepackage,itmayleadtoa
large number of unnecessary downloads, which increases the time
andsystemmemoryspentonbuildingtheruntimeenvironment.
Skippingunusablereleasesasdescribedabovecanavoidtheuseless
downloadscausedbyfailedinstallations.The importstatements
below exemplify the strength of our approach in another aspect.
3https://gist.github.com/miratcan/4cd70e9515ab722b2bce
4https://pip.pypa.io/en/stable/user_guide/#dependency-resolution-backtracking1importnumpyas np
2fromdeepwalk.graph import Graph
The dependencies that are inferred to be explicitly installed
by all the methods except PyCRE are numpyanddeepwalk. Pip
first downloads numpy-1.16.6, and then downloads deepwalk-1.0.3.
However, deepwalk-1.0.3 dependson gensim-3.8.3,whichrequires
numpyâ‰¤1.16.1andisincompatiblewith numpy-1.16.6,sonumpy-
1.16.1is downloaded again. This causes a redundant download for
numpy.Basedontheuniqueknowledgeofdependencies,PyCRE
infersthatonly deepwalk-1.0.3 needstobeinstalledexplicitlyand
that compatible numpy-1.16.1 would be installed automatically.
6 RELATED WORK
6.1 Python Runtime Environment Inference
TherearemanystudiesrelatedtosoftwareKGinsoftwareengineer-
ing [12,17,22,23]. DockerizeMe [ 10] is a pioneering work, which
offline builds a knowledge base to infer the language/system-level
environment dependencies required for Python code to execute
withoutimporterrors.Comparedwithit,ourPyCREhasseveral
significant differences. First, DockerizeMe only considers the latest
versionofeachpackage,whichcannothandleremovalorrenaming
thatmayaccompanywithversionchanges.Second,DockerizeMe
mapsthetop-levelmodulestoPythonpackages,anddoesnotob-
tain submodules and attributes. However, there may be multiple
versionsofdifferentpackagescontainingmoduleswiththesame
name, whichneeds furtherdecision basedon theattributes called
in the code.
V2 [11] enhances DockerizeMe by exploring the possible con-
figurationspaceforaPythoncodesnippet.Itvalidatescandidate
environments iteratively through code execution and applies envi-
ronmentmutationtogeneratenewcandidateconfigurationsaccord-
ingtothefailuremessages.WhileV2canfindsuccessfulruntime
environmentsforsomePythoncode,itsfeedback-directedsearch
is quite time-consuming, and even fails when an incorrect version
does not manifest as a crash. On the contrary, PyCRE infers the
appropriatePythonlibrariesusingthepre-builtKGs,whichisan
efficient approach.
SnifferDog [ 21] is committed to restoring the execution envi-
ronmentsofJupyternotebooksandevenreproducingtheresults.
It builds an API bank to record mappings from popular Python
librariestotheirAPIsbyparsingthePythonfiles.Severalaspects
affecttheeffectivenessofitsenvironment inference.First,itsAPI
bankstoresonlypublicfunctions,butotherpublicsubmodulesand
variablesshouldalsobeconsidered.Second,thestaticanalysismay
failtogetanyknowledgeduetotheuncertaintyofPythonversions
usedbythereleases.Third,itdoesnotguaranteethatthedefined
APIs can actually be called, since the packages and modules where
these APIs are located may fail to be installed or imported.
Asfarasweknow,thereisnostudyaddressingthecompatibility
of the inferred environments like our work.
6.2 Dependency Solving
Dependency solving (and some of its variants) has been provedtobeNP-complete,whichcanbeeasilyencodedintoaSATsolv-ing problem using CNF [
2,3,14]. Any solution of SAT is equally
460
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. Conflict-aware Inference of Python Compatible Runtime Environments with Domain Knowledge Graph ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
valid,butpracticallysomesolutionsarebetterthanothersforde-
pendency solving. Trezentos et al. [ 19,20] defined the software
dependencyproblemasanextensionoftheSATformulationcalled
pseudo-Booleanoptimization(PBO).ThereareseveralefficientPBO
solvers, such as Open-WBO solver [ 15] and sat4j solver [ 4], and
pseudo-Boolean constraints can be translated into clauses that can
be handled by a standard SAT solver [8].
Abateetal.[ 1]reviewedproposalsfromthedependencysolving
fieldinrecentyears.Theytreatdependencysolvingasaseparate
concern in component evolution management [ 2]. Although a few
popularpackagemanagerslikeEclipseP2useSATsolversforde-
pendencysolving,thevastmajorityofpackagemanagersincluding
pipstillusescustomizeddependencygraphtraversals.Thetradi-
tionaldependencyresolverofpackagemanagersreceivesaspecificinstallation request given by the user, whereas dependency solving
inPyCREneedstodeterminetherequiredinstallations,whichis
more difficult. Fortunately, we have global knowledge through the
pre-built Python package KGs, which enables us to heuristically
prune the search path for generating the compatible environments.
7 CONCLUSION AND FUTURE WORK
Inthispaper,weproposeanapproachtoautomaticallyinferring
Python compatible runtime environments with domain KG. We
design a domain-specific ontology for Python third-party packages
and propose an automatic approach to constructing the Python
package KGs. Given a Python code, we discover candidate libraries
by measuring the matching degree with third-party resources used
in the code. Furthermore, we propose a heuristic graph traversal
algorithm to infer the compatible runtime environment. Compared
with existing approaches, we show the superior effectiveness, effi-
ciency and compatibility of our approach in runtime environment
inference.Ourapproachcancontributetoautomatedsoftwarecon-
figuration management and facilitate code reuse.
In future work, we will acquire knowledge for more Python
packages and improve the coverage. We also plan to add the depre-
cation information of modules and APIs into the KGs, and use ittofurtherinferappropriateversions.Besides,wewillextendthedependency inference to the entire project instead of single-file
codeandconsiderthecompatibilitywithlocaldependencies,which
is more general in practice. Finally, we will apply our approach toother languages with transitive dependencies such as Node.js.
ACKNOWLEDGMENTS
Wethanktheanonymousreviewersfortheirvaluablecomments.
ThisworkissupportedbytheNationalNaturalScienceFoundation
of China (No. 61872172), and the Collaborative Innovation Center
of Novel Software Technology and Industrialization.
REFERENCES
[1]Pietro Abate, Roberto Di Cosmo, Georgios Gousios, and Stefano Zacchiroli. 2020.
Dependency Solving Is Still Hard, but We Are Getting Better at It. In SANER.
IEEE, London, ON, Canada, 547â€“551.[2]Pietro Abate, Roberto Di Cosmo, Ralf Treinen, and Stefano Zacchiroli. 2012.
Dependency solving: A separate concern in component evolution management.
JournalofSystemsandSoftware 85,10(2012),2228â€“2240. https://doi.org/10.1016/
j.jss.2012.02.018
[3]Daniel Le Berre and Anne Parrain. 2008. On SAT Technologies for Dependency
Management and Beyond. In SPLC (2). Lero Int. Science Centre, University of
Limerick, Ireland, Limerick, Ireland, 197â€“200.
[4]DanielLeBerreandAnneParrain.2010. TheSat4jlibrary,release2.2. Journal
on Satisfiability, Boolean Modeling and Computation 7, 2-3 (2010), 59â€“6. https:
//doi.org/10.3233/sat190075
[5]William W. Cohen, Pradeep Ravikumar, and Stephen E. Fienberg. 2003. A Com-
parisonofStringDistanceMetricsforName-MatchingTasks.In IIWeb.AAAI,
Acapulco, Mexico, 73â€“78.
[6]RobertCollins.2015. PEP508-DependencyspecificationforPythonsoftware
packages. https://www.python.org/dev/peps/pep-0508/. Accessed March 23,
2021.
[7]NiklasEÃ©nandNiklasSÃ¶rensson.2003. AnExtensibleSAT-solver.In SAT (Lecture
Notes in Computer Science, Vol. 2919). Springer, Santa Margherita Ligure, Italy,
502â€“518.
[8]Niklas EÃ©n and Niklas SÃ¶rensson. 2006. Translating pseudo-boolean constraints
into SAT. Journal on Satisfiability, Boolean Modeling and Computation 2, 1-4
(2006), 1â€“26. https://doi.org/10.3233/sat190014
[9]Eric Horton and Chris Parnin. 2018. Gistable: Evaluating the Executability of
Python Code Snippets on GitHub. In ICSME. IEEE, Madrid, Spain, 217â€“227.
[10]Eric Horton and Chris Parnin. 2019. DockerizeMe: automatic inference of envi-
ronment dependencies for python code snippets. In ICSE. IEEE/ACM, Montreal,
QC, Canada, 328â€“338.
[11]Eric Horton and Chris Parnin. 2019. V2: Fast Detection of Configuration Drift in
Python. In ASE. IEEE, San Diego, CA, USA, 477â€“488.
[12]ZeqiLin,BingXie,YanzhenZou,JunfengZhao,Xuan-DongLi,JunWei,Hailong
Sun, and Gang Yin. 2017. Intelligent development environment and software
knowledge graph. Journal of Computer Science and Technology 32, 2 (2017),
242â€“249. https://doi.org/10.1007/s11390-017-1718-y
[13]YogeshS.Mahajan,ZhaohuiFu,andSharadMalik.2004. Zchaff2004:AnEfficient
SAT Solver. In SAT (Selected Papers (Lecture Notes in Computer Science, Vol. 3542).
Springer, Vancouver, BC, Canada, 360â€“375.
[14]FabioMancinelli,JaapBoender,RobertoDiCosmo,JeromeVouillon,BerkeDurak,
XavierLeroy,andRalfTreinen.2006. ManagingtheComplexityofLargeFree
and Open Source Package-Based Software Distributions. In ASE. IEEE, Tokyo,
Japan, 199â€“208.
[15]Ruben Martins, Vasco M. Manquinho, and InÃªs Lynce. 2014. Open-WBO: Amodular maxSAT solver. In SAT (Lecture Notes in Computer Science, Vol. 8561).
Springer, Vienna, Austria, 438â€“445.
[16]Saikat Mondal, Mohammad Masudur Rahman, and Chanchal K. Roy. 2019. Can
issuesreportedatstackoverflowquestionsbereproduced?:anexploratorystudy.
InMSR. IEEE/ACM, Montreal, Canada, 479â€“489.
[17]Xiaoxue Ren, Xinyuan Ye, Zhenchang Xing, Xin Xia, Xiwei Xu, Liming Zhu, and
Jianling Sun. 2020. API-misuse detection driven by fine-grained API-constraint
knowledge graph. In ASE. IEEE, Melbourne, Australia, 461â€“472.
[18]Mate Soos, Karsten Nohl, and Claude Castelluccia. 2009. Extending SAT Solvers
to Cryptographic Problems. In SAT (Lecture Notes in Computer Science, Vol. 5584).
Springer, Swansea, UK, 244â€“257.
[19]Paulo Trezentos. 2010. Comparison of PBO solvers in a dependency solving
domain. In LoCoCo (EPTCS, Vol. 29). Edinburgh, UK, 23â€“31.
[20]Paulo Trezentos, InÃªs Lynce, and Arlindo L. Oliveira. 2010. Apt-pbo: solving the
software dependency problem using pseudo-boolean optimization. In ASE. ACM,
Antwerp, Belgium, 427â€“436.
[21]Jiawei Wang, Li Li, and Andreas Zeller. 2021. Restoring Execution Environments
of Jupyter Notebooks. In ICSE. IEEE, Madrid, Spain, 1622â€“1633.
[22]LuWang,XiaobingSun,JingweiWang,YucongDuan,andBinLi.2017. Construct
bug knowledge graph for bug resolution: poster. In ICSE (Companion Volume).
IEEE, Buenos Aires, Argentina, 189â€“191.
[23]Min Wang, Yanzhen Zou, Yingkui Cao, and Bing Xie. 2019. Searching Software
Knowledge Graph with Question. In ICSR (Lecture Notes in Computer Science,
Vol. 11602). Springer, Cincinnati, OH, USA, 115â€“131.
[24]Di Yang, Aftab Hussain, and Cristina Videira Lopes. 2016. From query to usable
code: An analysis of Stack Overflow code snippets. In MSR. ACM, Austin, TX,
USA, 391â€“402.
[25]DiYang,PedroMartins,VaibhavSaini,andCristinaV.Lopes.2017. StackoverflowinGithub:Anysnippetsthere?.In MSR.IEEE,BuenosAires,Argentina,280â€“290.
461
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:54:11 UTC from IEEE Xplore.  Restrictions apply. 