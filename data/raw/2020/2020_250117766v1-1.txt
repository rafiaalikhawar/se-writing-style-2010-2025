arXiv:2501.17766v1  [cs.SE]  29 Jan 2025Formally Veriﬁed Binary-level Pointer Analysis
Freek Verbeek∗†, Ali Shokri†, Daniel Engel∗, Binoy Ravindran†
∗Open Universiteit, Heerlen, The Netherlands
Email:{freek.verbeek, daniel.engel }@ou.nl
†Virginia Tech, Blacksburg, V A, USA
Email:{freek, ashokri, binoy }@vt.edu
©2025 IEEE. Personal use of this material is permitted. Perm ission from IEEE must be obtained for all other uses, in any cu rrent or future media, including
reprinting/republishing this material for advertising or promotional purposes, creating new collective works, for r esale or redistribution to servers or lists, or
reuse of any copyrighted component of this work in other work s.Abstract —Binary-level pointer analysis can be of use in
symbolic execution, testing, veriﬁcation, and decompilat ion of
software binaries. In various such contexts, it is crucial t hat
the result is trustworthy, i.e., it can be formally establis hed
that the pointer designations are overapproximative. This paper
presents an approach to formally proven correct binary-lev el
pointer analysis. A salient property of our approach is that
it ﬁrst generically considers what proof obligations a gene ric
abstract domain for pointer analysis must satisfy. This all ows
easy instantiation of different domains, varying in precis ion,
while preserving the correctness of the analysis. In the tra de-
off between scalability and precision, such customization allows
“meaningful” precision (sufﬁciently precise to ensure bas ic sanity
properties, such as that relevant parts of the stack frame ar e
not overwritten during function execution) while also allo wing
coarse analysis when pointer computations have become too
obfuscated during compilation for sound and accurate bound s
analysis. We experiment with three different abstract doma ins
with high, medium, and low precision. Evaluation shows that
our approach is able to derive designations for memory write s
soundly in COTS binaries, in a context-sensitive interproc edural
fashion.
Index Terms —binary analysis, pointer analysis, formal meth-
ods
I. I NTRODUCTION
Pointer analysis is central to various forms of veriﬁcation
and analysis for software containing pointers, facilitati ng the
construction of a state-based semantic model of software [1 0],
[30], [1], [17], [38], [42]. It aims to statically resolve, f or any
pointer in a given program, which region of the memory it
may point to. Speciﬁcally, given any two pointers, it must be
known whether they are aliasing , always referring to separate
regions in memory, or if they may possibly overlap. If a value
is written to memory, and no pointer information is known,
then one cannot accurately describe what the next state will
be. This can lead to overapproximative thrashing parts of the
memory state or forking , i.e., to conservatively considering
both separation and aliasing possibilities. Both such case s are
undesirable as they will quickly lead to unrealistic states and
path explosions. In other words, pointer analysis is a neces sity
for building a state-based transition system that accurate ly
models the software under investigation. Such a model, then ,
typically precedes a veriﬁcation or analysis effort aimed a t
higher-level properties.
The necessity for pointer analysis immensely exacerbates
when dealing with binaries (i.e., machine or assembly code)
instead of source code. The reason is that at this level ofabstraction everything is a pointer . There are no variables,
and memory can be considered as a ﬂat unstructured address
space. In a typical x86-64 program, about 28% of all assembly
instructions write to memory1, producing tens of thousands of
pointers even in medium-sized programs. Moreover, control -
ﬂow related information is stored in writable memory, such a s
the current return address and the currently caught excepti on
stack. Theoretically, if the destination of even a single me mory
write cannot be resolved, then the effect of executing that
memory write could result in either thrashing all memory
(including such control-ﬂow pertinent information) or for king
into unrealistic states, such as when a memory write overlap s
with the return address, even though in reality it did not. Th is
may lead to a situation where it cannot even be established
what instruction is to be executed, let alone what an accurat e
next state can be. This is one of the key challenges in dealing
with binaries, preventing one from simply using techniques
developed for source code analysis and applying them to low-
level code found in binary executables [15].
This paper presents an approach to formally veriﬁed binary-
level pointer analysis. Typically, such analyses are based on a
form of abstract interpretation [12], where an abstract dom ain
is deﬁned that overapproximates concrete semantics [5], [3 5].
A fundamental challenge is choosing the “right” abstract
domain, as this essentially boils down to balancing precisi on
vs. scalability. This paper thus ﬁrst leaves the abstract do main
polymorphic and formulates a set of eight generic to-be-
reﬁned functions, as well as the proof obligations that thes e
functions must satisfy. Over these generic functions, an ex e-
cutable algorithm for pointer analysis is formalized and pr oven
correct. An instantiation thus deﬁnes an abstract domain and
an implementation of the generic functions. Any instantiat ion
that satisﬁes the proof obligations automatically constit utes a
formally proven correct binary-level pointer analysis. As will
be discussed later, all the formalism and proofs are carried out
in Isabelle/HOL and have been shared with the readers.
We then provide three different instantiations of our gener ic
functions, each of which strikes a different balance in the
trade-off between precision vs. scalability. First, pointer com-
putations form an abstract domain that keeps track of how
pointers were computed: highly precise, but in practice one
must cap the domain to a given size and produce top ( ⊤) when
1Measured over several CoreUtils binaries and Firefox libra ries with
different levels of optimization.that cap is exceeded. Second, pointer bases form an abstract
domain where each pointer is represented only by its pointer
base (e.g., a stack pointer, or the return value of a malloc ):
more coarse as it cannot be used for alias analysis, but still
allows accurate separation analysis (for binaries compile d
from source code, pointers based in different blocks can be
assumed to be separate, even if an out-of-bounds occurs [31] ).
Third, pointer sources are an abstract domain where a pointer
is modeled by the set of sources (e.g., user inputs, initial
parameter values) used in its computation. This is highly
coarse, but is scalable and still allows a form of separation
reasoning.
The pointer analysis presented in this paper is context-
sensitive and compositional. Context-sensitivity is desi rable,
since pointers are passed through from function to function .
We derive function preconditions , which states that invariably
a certain function is always called within in a context where ,
e.g., register rdi contains a heap-pointer, or register rsi
contains a pointer to within the stack frame of the caller.
Per function, we can then derive a function postcondition that
summarizes which regions were written to/read from by the
function, and if after termination abstract pointers are le ft
in return registers or global variables. Compositionally, these
summaries can then be used for pointer analysis for callers o f
summarized functions. Due to space limitation, we focus our
presentation on intraprocedural analysis and do not expand on
the above technique for composition.
Bottom-up pointer analysis (i.e., binary analysis, in cont rast
to top-down source code analysis) can be useful in various us e
cases (see Section VI):
•It can be integrated into a disassembly algorithm [37]. A
large facet of disassembly is assessing which instruction
addresses are reachable (i.e., control ﬂow recovery). A
key challenge is resolving indirections, i.e., dynamicall y
computed control ﬂow transfers. Context-sensitive pointe r
analysis can assist, by providing information on which
pointers are passed to a function.
•It can be a preliminary step to a decompilation effort [11].
Speciﬁcally, one of the steps in decompilation is to recover
variables. Bottom-up pointer analysis provides informati on
on which memory writes actually constitute variables.
•It can be the base of a bottom-up dataﬂow analysis. The
function summaries already provide a form of dataﬂow
analysis, by providing information on in- and output rela-
tions. They can be used to verify whether functions adhere
to a calling convention and to see which state parts are
overwritten or preserved by a given function. We also
demonstrate by example that an overapproximative pointer
analysis can be used for live variable analysis.
We emphasize the need for formally proven correct binary-
level pointer analysis. Symbolic treatment of pointers and
memory is notoriously difﬁcult. Existing approaches typic ally
make various assumptions implicitly , e.g., they may implicitly
assume a return address cannot be overwritten, assume sepa-
ration between pointers based on heuristics or best practic es,or assume alignment of regions. This paper aims to reduce the
trusted code base by explicitizing such assumptions and eit her
proving them through invariants or reporting them explicit ly
otherwise. The trusted code base is thus reduced to the valid ity
of explicit and conﬁgurable assumptions such as “regions
based on stack pointers of different functions are assumed t o
be separate”.
Limitations, assumptions and scope. A major assumption
behind our approach is the treatment of partially overlapping
memory accesses. Memory accesses (reads or writes) to par-
tially overlapping regions may happen, but we assume that
they do not concern pointers. More details can be found in
Section III-A. Moreover, our approach has been implemented
for the x86-64 architecture and does not deal with concurren cy.
A fundamental limitation is that not all indirections may be
resolved, which may lead to unexplored paths.
The approach has been formally proven correct in Is-
abelle/HOL [36], [14], and has been mirrored in Haskell for
experimental results. These conﬁrm soundness relative to a
ground truth obtained by observing executions. Moreover, t hey
show precision comparable to or improved upon the state-
of-the-art. We evaluate the effect of interprocedural bott om-
up pointer analysis with respect to resolving indirections ,
identifying 135 cases where context-sensitive informatio n al-
lowed resolving a function callback. Finally, for all analy zed
functions it has been veriﬁed whether the result is sufﬁcien tly
precise to show that the return address has not been overwrit ten
and that critical parts of the stack frame (e.g., storing non -
volatile register values) are unmodiﬁed during execution o f
the function. This was successful for 99.6% of all analyzed
functions.
In summary, we contribute:
•Aformally proven correct approach to binary-level pointer
analysis that leaves the abstract domain generic , allowing
easy development of instantiations with different charact er-
istics (e.g., different levels of preciseness);
•An evaluation over roughly 1.4 million assembly instruc-
tions, showing scalability and applicability of the approa ch.
Section II studies the related work. Sections III and IV pro-
vide details of our generic functions and their three differ ent
levels of instantiation, respectively. Section V, demonst rates
the realization of interprocedural pointer analysis throu gh our
general functions. While Section VI looks at several use
cases of the introduced approach, Section VII relates the
experimental results to those produced by the state-of-the -art
tools currently available. Section VIII concludes the pape r.
II. R ELATED WORK
Source-level pointer analysis has been an active research
ﬁeld for decades [22]. Its typical use cases lie in top-down con-
texts: it takes as input source code, and provides informati on
to the compiler for doing optimizations and data ﬂow analyse s.
We here do not aim to provide an overview of this ﬁeld,
since our work focuses on bottom-up contexts: taking as input
a binary, the result of pointer analysis provides informati on
usable for decompilation and veriﬁcation.Generally, source-level approaches to program analysis
cannot directly be applied to binary-level programs [6].
Various research therefore focuses on symbolic execution
and/or abstract interpretation speciﬁcally tailored to th e binary
level. We distinguish under approximative techniques from
overapproximative ones. In this discussion, we speciﬁcally
focus on how these techniques deal with pointers.
Underapproximative approaches:
SAGE combines symbolic execution of assembly code with
fuzz testing, allowing exposure of real-life vulnerabilit ies in
real-life software [21]. Initially, SAGE did “not reason ab out
symbolic pointer dereferences”, but it has been combined wi th
Yogi allowing runtime behavior observed from test cases to
be used in reﬁning abstractions to ﬁnd whether pointers may
be possibly aliasing [20]. S2E is a platform for traversing
binaries, allowing exploration of hundreds of thousands of
paths using selective symbolic execution [9], [8]. S2E provides
an approach where dereferencing a symbolic pointer provide s
next states with possible concrete values based on the symbo lic
pointer and the current path constraints. A similar approac h
is taken by F UZZBALL, a symbolic execution framework for
binaries, mainly concerned with improving the path coverag e
of binary fuzzers [3], [33]. It explores individual paths on e
by one and chooses concrete values for offsets in pointers.
BINSEC is a code analysis tool with a focus on the security
properties of binaries [16], [13]. It has been applied to ﬁnd
use-after-free bugs [18] and for reachability analyses [19 ].
Symbolic execution is based on forking, using an SMT solver
to prune infeasible paths. B INSEC is based on bounded ver-
iﬁcation, making it underapproximative. Kapus et al. provi de
an interesting approach by concretizing and segmenting the
memory model so that symbolic pointers can only refer to
single memory segments [24]. Use of a test harness ensures
both termination and that allocations always have a concret e
size.
These methods underapproximate either by not exploring
all paths, or by underapproximating pointer values. Undera p-
proximation typically is very well suited for ﬁnding bugs an d
vulnerabilities in software: it leads to few false negative s and
provides excellent scalability. It is suitable in the conte xt of
testing and binary exploration. In contrast, our pointer an alysis
is overapproximative, quantifying over all execution path s and
all values. This makes it suitable in the contexts of veriﬁca tion
and lifting to higher-level representations.
Overapproximative approaches:
Control Flow Reconstruction. Overapproximative ap-
proaches to binary analysis are generally based on a form of
abstract interpretation. Many approaches are aimed at control
ﬂow reconstruction and resolving of indirect branches. By hav-
ing abstract values represent a set of possible jump targets , an
indirection can be resolved by concretizing the abstract va lue
to all instruction addresses it represents. J AKSTAB performs
binary analysis and control ﬂow reconstruction based on thi s
principle [27], [28]. The user manually provides a harness
modeling the initial state, and relative to that initial sta te, the
generated control ﬂow graph overapproximates all paths in t hebinary. Pointer aliasing is dealt with by thrashing the symb olic
state [29]. Verbeek et al. present an overapproximative ap-
proach to control ﬂow reconstruction based on forking the st ate
non-deterministically [43]. Their output can be exported t o the
Isabelle/HOL theorem prover where it can be formally proven
correct. An important use case for overapproximative contr ol
ﬂow reconstruction is trimming a binary by removing provably
unreachable code. B INTRIMMER uses abstract interpretation
to prove the reachability of dead code and trim the binary
accordingly.
Using abstract interpretation for the purpose of control
ﬂow reconstruction (i.e., resolving of indirections) is di fferent
from using abstract interpretation for resolving designat ions
of memory writes (i.e., pointer analysis). It can be seen as a
speciﬁc form of the more generic technique value set analysis
(VSA).
Value Set Analysis. Various approaches use abstract in-
terpretation to do VSA: mapping state parts to abstract rep-
resentations of a set of values that the state part may hold
at a certain program point. C ODESURFER /X86 utilizes as
abstract domain a tuple storing a base and an offset [5], [39] .
The offset is modeled by an abstract domain that combines
intervals and congruences. Frameworks such as BAP [7] and
ANGR [41] provide implementations of binary-level VSA.
Abstract domains are typically a form of signed-agnostic
intervals [35]. To our knowledge, BinPointer [26] is the wor k
closest related to the contribution in this paper. Kim et al.
provide binary-level context-insensitive pointer analys is in a
sound and overapproximative fashion, while also targeting
scalability and evaluating preciseness of their produced o ut-
put. Their abstract domain is conceptually equivalent to th e
“pointer bases” domain presented in this paper, which is als o
similar to the abstract domain found in [5]. BinPointer reac hes
the conclusion of 100% soundness by running test-cases, whi le
we reach 100% soundness through formal proofs.
Summary of relation to overapproximative approaches.
Existing approaches use abstract interpretation to recons truct
control ﬂow, or to do VSA. It is a well-known issue that
in realistic, optimized and stripped COTS binaries, comput a-
tions quickly become too complicated and obfuscated to be
amenable for VSA sufﬁciently precise to enable reasoning
over separation [45]. This paper presents the ﬁrst approach to
VSA that is formally proven correct, that is generic wrt. the
abstract domain and that therefore allows different domain s
with different levels of preciseness to be used. To the best
of our knowledge, there exists no approach that can over-
approximatively assign pointer designations to virtually all
memory writes in large COTS binaries, in a context-sensitiv e
interprocedural fashion. In Section VII we aim to provide a
more technical head-to-head comparison with existing tool s.
III. O VERVIEW OF GENERIC CONSTITUENTS
There are three major constituents required to formulate th e
correctness theorem. First of all, a concrete semantics that
provides a step function step over concrete states (denoted by
s,s′,...). Second, an abstract semantics , deﬁned by 1.) anabstract step function step over abstract states (denoted by σ,
σ′,...), and 2.) a join (denoted ⊔). Third, a concretization
functionγSthat maps abstract states to sets of concrete states.
We prove the following two theorems:
Theorem 1: Function γSis asimulation relation [4] between
the concrete and abstract semantics:
s∈γS(σ) =⇒step(s)∈γS(step(σ))
This theorem shows that the abstract semantics overapproxi -
mate the concrete ones.
Second, we deﬁne an algorithm that performs symbolic
execution, while maintaining a mapping φfrom the visited
instruction addresses to the abstract states. Whenever an i n-
struction address is visited twice, the current abstract st ate is
joined with the abstract state stored during the previous vi sit,
and the algorithm proceeds if the joined state is unequal to
the stored one. In essence, this is a ﬁxed-point computation .
We prove:
Theorem 2: The mapping φproduced by the algorithm
provides invariants :
sis reachable =⇒s∈γS(φ(s.rip))
In words, any concrete reachable state sis included in the
set of states represented by the abstract state stored in map ping
φassociated to its instruction pointer rip. Reachability means
thatsis reachable from some unconstrained concrete state,
withripas the entry point, through a path of resolved control
ﬂow transfers.
A. Concrete Semantics
The concrete semantics are largely straightforward, excep t
for the treatment of partially overlapping memory accesses . At
the binary level, any memory access occurs through pointer
computations. We formulate the assumption that any region
in memory storing a pointer is from there on not accessed
in a partially overlapping fashion . For example, consider
a scenario where region /an}bracke⊔le{⊔rsp0−16,8/an}bracke⊔ri}h⊔has been accessed
(denoting the 8-byte region 16 bytes below the original
value of the stackpointer rsp). From that point on, regions
/an}bracke⊔le{⊔rsp0−16,4/an}bracke⊔ri}h⊔and/an}bracke⊔le{⊔rsp0−12,4/an}bracke⊔ri}h⊔are still considered valid
accesses. Region /an}bracke⊔le{⊔rsp0−12,8/an}bracke⊔ri}h⊔is not, as it partially overlaps
with a previously accessed region. As a consequence of this
assumption, any partially overlapping access is assumed no t to
produce a pointer. Since we are interested in pointer analys is,
we therefore allow the concrete semantics to make values
read from or written to by partially overlapping access to
become tainted . Overapproximation then concerns untainted
values only.
The concrete states stores concrete values , denoted V. A
concrete value is either an immediate bitvector or the speci al
value⊤(tainted). A concrete state contains an assignment of
registers to concrete values. Concrete memory assigns conc rete
values to concrete regions: tuples of type V×Vcontaining
the address and size of the region. A priori, no memory
alignment information is available and thus concrete memor y
must store concrete values as well as the current alignment.Every read/write updates the alignment information and tai nts
values in memory accordingly. The result is a type Smodeling
concrete states and function step: a formal but fully executable
semantics, in which small assembly programs can be executed
on concrete initial states.
B. Abstract Semantics
The abstract state stores abstract values . The datatype for
abstract values, denoted V, is left completely polymorphic. We
assume existence of a special ⊤element. Over this datatype,
the following generic (i.e., undeﬁned ) functions are assumed
to be available:
γVConcretization V/maps⊔o→ {V}
S Abstract semantics Operation ×[V]/maps⊔o→V
⊔ Join V×V/maps⊔o→V
⊲⊳ Separation /an}bracke⊔le{⊔V×V/an}bracke⊔ri}h⊔×/an}bracke⊔le{⊔V×V/an}bracke⊔ri}h⊔ /maps⊔o→B
⊑ Enclosure /an}bracke⊔le{⊔V×V/an}bracke⊔ri}h⊔×/an}bracke⊔le{⊔V×V/an}bracke⊔ri}h⊔ /maps⊔o→B
== Aliassing /an}bracke⊔le{⊔V×V/an}bracke⊔ri}h⊔×/an}bracke⊔le{⊔V×V/an}bracke⊔ri}h⊔ /maps⊔o→B
For sake of presentation, we omit functions used for getting
initial abstract values. Function Stakes as input the name of
an operation executed by an assembly instruction (e.g, add).
Note that a single assembly instruction may execute several
such operations (e.g., imul ). Function Ssymbolically executes
that operation on abstract values. The separation, enclosu re
and aliassing relations are over abstract regions. Functio nγR
concretizes an abstract region /an}bracke⊔le{⊔a,si/an}bracke⊔ri}h⊔by applying γVto both
the address and the size.
The above generic functions must satisfy a set of 26 proof
obligations. Most of these are trivial (e.g., the join must b e
a commutative semigroup over V; enclosure is transitive and
reﬂexive). We here provide some examples of interesting pro of
obligations. Join, separation, enclosure, aliasing, and a bstract
semantics must be overapproximative. For separation, this
means that concretizing separate abstract regions must pro duce
separate concrete regions; note that concrete separation ⊲⊳
can be expressed in terms of linear equalities for non-taint ed
values. For the semantics, overapproximation is formulate d by
stating that the result of applying some concrete operation /square
must be overapproximated by the semantics provided by S
for the corresponding symbolic operation /square. Here,/squarecan,
e.g., be an arithmetic, logical or bitvector operation. The
presentation shows binary operators, but this easily exten ds to
n-ary operators. Finally, there is a set of algebraic proper ties
concerning the relations over regions, such as “Enclosure i n
separate region”.
IV. O VERVIEW OF INSTANTIATIONS
We provide three different instantiations, each of which ha s
been formally deﬁned in Isabelle/HOL and for each of which
all proof obligations have been proven. All three domains ar e
represented by sets of elements from a different universe: C,B
andS. Elements of these domains satisfy the following syntax:
{c0,c1,...}
Constant
ComputationC| {b0,b1,...}
BasesB| {s0,s1,...}
SourcesSThe join must be overapproximative: γV(a0)⊆γV(a0⊔a1)
Separation must be overapproximative: r0⊲⊳ r1∧r0∈γR(r0)∧r1∈γR(r1) =⇒r0⊲⊳ r1
Semantics must be overapproximative: v0∈γV(a0)∪{⊤}∧ v1∈γV(a1)∪{⊤}=⇒v0/squarev1∈γV(S(/square,a0,a1))∪{⊤}
The join respects separation: r⊲⊳/an}bracke⊔le{⊔a0⊔a1,si/an}bracke⊔ri}h⊔=⇒r⊲⊳/an}bracke⊔le{⊔a0,si/an}bracke⊔ri}h⊔
The join respects enclosure: /an}bracke⊔le{⊔a0,si/an}bracke⊔ri}h⊔⊑/an}bracke⊔le{⊔a0⊔a1,si/an}bracke⊔ri}h⊔
Enclosure in separate region: r0⊑r1∧r1⊲⊳ r2=⇒r0⊑r2
Fig. 1: Examples of Proof Obligations
The abstract points ﬁrst of all concern symbolic expression s,
denoted by type E. As operators , symbolic expressions have
arithmetic and logical operations, bit-level operations s uch as
sign-extension or masking, and other operations related to
x86-64 assembly instructions. There is a dereference opera tor
∗/an}bracke⊔le{⊔e,si/an}bracke⊔ri}h⊔– whereeandsiare symbolic expressions – that mod-
els reading sibytes from address e. As operands , symbolic
expressions have immediate values ,state parts ,constants or
heap-pointers . Immediate values are words of ﬁxed size. State
parts can be registers (e.g., rax,edi,...) or ﬂags ( ZF,CF,
. . . ). Constants are values of state parts relative to the ini tial
state. For example, rax0denotes a constant: the initial value
stored in register rax. Constants thus represent initial values
of state parts when the current function was called. A heap-
pointer is an expression of the form alloc[id]and models
the return value of an allocation function such as malloc . The
idis an identiﬁer to distinguish different mallocs. A constant
computation is a symbolic expression with as operands only
immediate values and constants.
Pointers with constant computations. An expression
of the syntax {c0,c1,...}Cis based on a non-empty set
of constant computations. It non-deterministically repre sents
any value from the given set. For example, expression
{rsp0−8,rdi0+16}Csimply represents any of the two con-
stant computations. This domain is the most concrete.
Pointers with bases. Expressions of the form {b0,b1,...}B
partly abstract away from how the pointer is computed. It
keeps track only of positive addends in the computation that
can be recognized as a basis for a pointer. The given set is
a non-empty set of bases . A base is deﬁned by the following
datastructure:
Base≡StackPointer f|Globala|Allocid|Symbolname
Four types of pointer bases are recognized. The base may
be the stackpointer (in x86-64 this is register rsp) pointing
to somewhere in the stackframe of a certain function f. The
base may be a global address a. At the binary level, the global
address space is pointed to using immediate values and thus
ais a 64-bit immediate word. The base may be the result
of some dynamic memory allocation. Finally, a base can be
a named symbol. At the binary level, external variables are
named symbols with immediate addresses.
Note that any pointer will have at most one base. For
example, no pointer computation would allow addition of the
stack pointer and a heap address. The datastructure allows a setof bases to allow the abstract pointer to non-deterministic ally
represent different pointers with bases.
Pointers with sources. Expressions of the form
{s0,s1,...}Sfully abstract away from how the pointer
is computed. Whereas pointers with identiﬁable bases conta in
sufﬁcient information at least for roughly establishing a
memory designation, a pointer parameterized with sources
only concerns what information has been used in the
computation of the pointer. In other words, the pointer has
been computed by some expression with operands from the
given set of sources. The following sources are possible:
Source≡Constant c|Baseb|Funname
A source can be a constant, a base or the return value of some
function. For example, expression {rdi0,rsi0,Fungetc}Sin-
dicates a pointer that has been computed using only the initial
values of registers rdiandrsiand the return value of function
getc .
Example 1: Consider the running example in Figure 2.
The example allocates memory and performs some memory
writes. Two regions (at addresses 0x3006 and0x3008 ) are
relative to the initial value of the stackpointer rsp0. The
abstract pointers corresponding to these memory writes may be
represented in C: respectively {rsp0−16}Cand{rsp0−8}C.
The memory write at address 0x3005 occurs on the heap. Even
ifoﬀset is some convoluted dynamically computed offset, the
abstract pointer will be representable in B:{Alloc0x3003}B.
Finally, the memory write at address 0x3007 writes to the
address initially stored in register rdx plus the return value
of function getc . The abstract pointer is representable in S:
{rdx0,Fungetc}S.
A. Separation over Abstract Pointers
Each of the three domains allows a different type of
reasoning over separation. Intuitively, separation betwe en two
pointers implies that necessarily – i.e., for any address rep-
resented by the two pointers – two memory writes commute.
Separation is denoted by the inﬁx operator ⊲⊳.
Consider two pointers p0+oﬀset andp1. If both pointers are
deﬁned by constant computations, separation can be decided
by an SMT solver. For the other domains, however, one
may argue that separation cannot be guaranteed under any
circumstances. We argue this is too strict. For example, if
one pointer is based on the heap and the other on the local
stack, then it is safe to assume that even if oﬀset is chosen
nefariously, writes to the two pointers will either cause a0x3000:movrbp, rsp
0x3001:callgetc
0x3002:movrcx, rax
0x3003:callmalloc
0x3004:learsi, [rbp - 8]
0x3005:movqptr [rax + oﬀset], rsi
0x3006:movqptr [rsp-16], 0x2000
0x3007:movqptr [rdx + rcx], rax
0x3008:movdptr [rsi], 0
(a) x86-64 Assemblyσ.rsp ={rsp0}C
σ.rbp ={rsp0}C
σ.rcx ={Fungetc}S
σ.rax ={alloc[0x3003]}C
σ.rsi ={rsp0−8}C
σ.∗/an}bracke⊔le{⊔{Alloc0x3003}B/an}bracke⊔ri}h⊔={rsp0−8}C
σ.∗/an}bracke⊔le{⊔{rsp0−16}C,8/an}bracke⊔ri}h⊔={Global0x2000}B
σ.∗/an}bracke⊔le{⊔{rdx0,Fungetc}S/an}bracke⊔ri}h⊔={alloc[0x3003]}C
σ.∗/an}bracke⊔le{⊔{rsp0−8}C,4/an}bracke⊔ri}h⊔=⊤
(b) Abstract State
Fig. 2: Assembly code. For sake of presentation, pseudo code is given on the right. oﬀset denotes some dynamically computed
offset. Instruction lea loads an address into register rsi without reading from memory. The binary has a data section wi th
address range 0x2000 to0x2040 .
segmentation fault or they will commute. Assuming separati on
is thus safe. On the other hand, we argue that if both pointers
are based on local stackframes of different functions, then
assuming separation is dangerous as a stack overﬂow may
cause the pointers to overlap.
It may be the case that separation is not necessarily true,
butdesirable . Consider a pointer with source set {rdi0}. The
only way for that pointer to overlap with the stackframe of th e
current function, is if initially – at the time the current fu nction
was called – register rdi contained a pointer to below its
own stackframe. That is invalid source code and can therefor e
be considered undesirable. For various use cases, it can be
useful to distinguish “necessarily” separation from “desi rable”
separation (see Section VI).
For domains BandS, whether two abstract pointers are
separate is in essence domain speciﬁc knowledge on what
assumptions can validly be made when dealing with an x86-
64 binary. In Figure 3, this knowledge will be encoded in
algebraic deﬁnitions. Depending on ones view, one may easil y
add or remove cases of separation, and move cases from
“desirable” to “necessarily” or the other way around.
Pointers with constant computations. For two constant
computations, separation can be formulated as a linear pro-
gramming problem, solvable by an SMT solver [34]. This
requires the size of the regions pointed to, to be known.
Typically, these sizes can syntactically be inferred from t he
current instruction. We deﬁne function SMT[⊲⊳]as a function
that takes as input two constant computations c0andc1,
and two sizes si0andsi1and returns true if and only if
the following SMT problem is unsatisﬁable: c0≤a <
c0+si0∧c1≤a < c1+si1. In words, an address athat is
in both regions should be unsatisﬁable. Constant computati ons
typically consist of arithmetic operations containing onl y+,
−and∗, and bit-level operations supported by SMT-theory
QFBV.
Pointers with bases. Separation for pointers with bases can
be decided algebraically. Figure 3 presents relation ⊲⊳B, i.e.,
separation over bases. The local stack frame of any function fis assumed to be separate from the global address space and th e
heap. As argued above, separation over different stackfram es
is desirable, but not necessarily. The global address space is
assumed to be separate from the local address space and the
heap. The global address is not necessarily assumed to be
separate from the symbols in the binary, i.e., external vari ables.
Both are typically constant immediates, within the range of
addresses within the binary. Separation is considered to be
desirable. If two global addresses are based on immediates t hat
fall within the range of different data sections of the binar y,
then separation is considered desirable.
Two allocations with different ids are assumed to be sep-
arate, as different ids ensure these were different calls to
malloc . A pointer based on malloc should not lead to a
write overlapping with the region of a different malloc .
Whether this separation should be considered necessary or
desirable is debatable. Heap overﬂows are common and critic al
vulnerabilities, and if these are part of the attacker model ,
then this separation should be considered desirable. Note t hat
two pointers based on allocations with the same id, are not
necessarily notseparate.
Pointers with sources. Since pointers with sources are
more abstract, there are fewer cases that allow deciding
separation necessarily. For example, consider two pointer s
with source sets {rdi0}and{rsi0}. Whether these can be
considered separate depends on the initial state of the curr ent
function, i.e., whether registers rdi andrsi initially were
separate. However, there still are cases when separation ca n be
decided. First, when two sources are actually bases, the abo ve
relation⊲⊳Bcan used as decision procedure. Second, consider
a pointer computed using constant rdi0and a newly allocated
pointer. As long as the allocation happened within the curre nt
function, separation can safely be assumed: essentially th is
assumes that the initial state cannot predict where malloc
will allocate memory. Since sources of the form Funfdo
not represent pointers, separation between these sources a nd
all other sources can be assumed. Finally, consider a source
rdi0, i.e., the initial value of register rdi when the currentNecessarily:
StackPointer f ⊲⊳BAllocid
StackPointer f ⊲⊳BGlobala
StackPointer f ⊲⊳BSymbolname
Globala ⊲⊳BAllocid
Allocid0 ⊲⊳BSymbolname
Allocid0 ⊲⊳BAllocid1 ifid0/ne}a⊔ionslash=id1
Baseb0 ⊲⊳SBaseb1 ≡b0⊲⊳Bb1
Constant c ⊲⊳SBase Alloc id ifidbelongs to current function
Funf ⊲⊳Ss1
Desirable:
StackPointer f ⊲⊳BStackPointer f′iff/ne}a⊔ionslash=f′
Globala ⊲⊳BGlobala′ifaanda′are from different data sections
Globala ⊲⊳BSymbolname
Constant c ⊲⊳SBase StackPointer fiffis current function
Fig. 3: Separation over abstract pointers: the smallest sym metric relation such that the above holds.
function was called. It is possible that the caller initiali zed
rdi with a pointer to the stackframe of the callee, but we
consider it undesirable.
Example 2: Revisiting Example 1, we address the memory
accesses in order of execution. First a write happens to poin ter
p0={Alloc0x3003}B. Then, a write happens to pointer
p1={rsp0−16}C={StackPointer 0x3000}B. These two
regions are necessarily separate for all three domains. The n, a
write happens to pointer p2={rdx0,Fungetc}S. Separation
betweenp0andp2follows necessarily for domains BandS.
However, separation between p1andp2is not necessarily true.
It is, however, desirable . Finally, a write happens to pointer
p3={rsp0−8}C. Similar reasoning applies for separation
withp0andp2. For domain C, separation between p1andp3
is decided by an SMT solver.
In similar fashion, enclosure and aliassing are instantiat ed.
The join is deﬁned as set-union. Instantiating abstract sem an-
tics and concretization is straightforward.
V. I NTRAPROCEDURAL POINTER ANALYSIS
Algorithmically, intraprocedural pointer analysis can be
achieved using a standard abstract interpretation algo-
rithm [12], [23]. Essentially, starting at some initial abs tract
state with the instruction pointer set to the entry point of t he
binary (or a function of interest), symbolic execution trav erses
the assembly instructions step-by-step using function step.
It runs until a return statement, or an exiting function call .
Whenever an instruction address is visited twice, the curre nt
stateσcurris compared to the state σstored belonging to the
previous visit. If state σstored is more abstract then state σcurr,
exploration can stop. Otherwise, the two states must be joined
to a state σjoin. That state is stored and exploration continues.
Effectively, this algorithm provides a (partial) mapping f rom
instruction addresses to stored symbolic states. A post-st ate
σpostis computed by taking the supremum of all terminal
non-exiting states. Thus, we deﬁne state and a symbolic step
function on top of the generic constituents.Abstract States. A state stores values for registers, ﬂags
and memory. An abstract state part is deﬁned by the following
datatype:
SP≡Registerr|Flagf|Memory(V×N?)
A memory statepart is represented as a region, a tuple with
an abstract pointer and optionally a size. Whenever clear fr om
context, we will omit the constructors. For example, sp=rax
simply means that statepart spequals register rax. An abstract
state is a partial mapping from stateparts to abstract value s:
S≡SP⇀V.Notation σ.rdenotes the current value stored in
registerr. Memory partitions the address space into separate
abstract regions, and assigns stored values to each of these
regions. Notation σ.∗/an}bracke⊔le{⊔r/an}bracke⊔ri}h⊔denotes the value stored in region r,
where the size is omitted when not available.
Example 3: Revisit the running example in Figure 2. Based
on the separation relations decided in Example 2, the state σin
Figure 2b can model the state after execution of the assembly
snippet. Note that this state is based on desirable separation,
as otherwise regions would need to get joined. Intuitively, the
following claims are modeled by this state:
•Any region based on a heap-pointer allocated at line 0x3003
contains no pointers other than the pointer rsp0−8.
•The 8-byte region at address rsp0−16stores a value that
may point to the global data section.
•A memory write has occurred that is determined by the
initial value of register rdx as well as input provided via
function getc . That memory write was assumed to be
separate from all others.
•If the value stored in region /an}bracke⊔le{⊔rsp0−8,4/an}bracke⊔ri}h⊔would be deref-
erenced, then no information on its designation in memory
is known.
The claims in the above example can be formalized by con-
cretization of abstract states to concrete ones. Concretizationof state parts is provided by function γSPof typeSP/maps⊔o→2SP:
γSP(Registerr)≡ {Registerr}
γSP(Flagf)≡ {Flagf}
γSP(Memory r)≡ {Memory r|r∈γR(r)}
Deﬁnition 1: The concretization of states is function γSof
typeS/maps⊔o→2S, and is deﬁned as:
γS(σ)≡ {s| ∀sp·σ.sp=v=⇒
∀sp∈γSP(sp)·∃v∈γV(v)·s.sp=v}
In words, abstract state σis mapped to any concrete state s
in which both all stateparts and all stored values have been
concretized.
Abstract Step Function. Every assembly instruction can
be written as a sequence of micro-instructions of the follow ing
form:
dst:=f(in0,in1,...)
A single destination – be it a register, a memory region or
a ﬂag – gets assigned the return value of a pure operation
fthat is based on zero or more input-operands (registers,
memory regions, ﬂags, or immediate values). The operation
typically corresponds to a mnemonic, e.g., add orimul . In
x86-64, many (but not all) instructions have one destinatio n
operand (register or memory) and may set a list of ﬂags.
Typically, it cannot be the case that both destination and
sources are memory. We here make no assumptions, and
generalize the symbolic step function over any sequence of
micro-instructions. Transformation from basic assembly t o
sequences of micro-instructions can be done, e.g., using th e
Ghidra decompiler which translates assembly instructions of
various architectures into low P-code [40].
The semantics of executing a micro-instruction µconsists
of resolving the input-operands, applying operation f, and
writing the produced value to the state. This is implemented
in function step(µ,σ). The abstract semantics Sare used to
apply operation fon abstract values. Functions read(r,σ)and
write(r,a,σ)are deﬁned that take care of memory accesses
in abstract states.
Correctness and Termination. Correctness – the abstract
semantics overapproximate the concrete semantics – has bee n
deﬁned at the start of Section III and has been formally prove n
correct in Isabelle/HOL. Note that it may be the case that pat hs
are unexplored due to unresolved indirections.
Termination has also been proven, but it requires the proof
obligation that there does not exist an inﬁnite chain of diff erent
states such that σ0⊔σ1⊔.... We thus ensure termination
by putting bounds on the sizes of the sets of the abstract
pointers. These bounds are chosen manually. They do not
affect correctness. Making them larger makes the pointers
more precise, but increases running times. For bounds C,B,
andSthe bounds are resp. 10, 5 and 250. Any pointer with
more elements is shifted to ⊤.
VI. U SECASES
We here discuss several use cases with small pedagogical
examples.Integration into Disassembly: A fundamental problem
in disassembly is resolving indirections. Typically, indi rect
jumps can be analyzed through intra procedural analysis. For
example, they are the result of reading a jump table induced
by aswitch statement. For indirect calls, however, often
inter procedural analysis is necessary. An indirect call is often
the result of a function callback. These typically happen ac ross
function boundaries: a function pointer is passed from func tion
to function until it is called. This scenario mandates conte xt-
sensitive interprocedural analysis where the context prov ides
sufﬁcient information to resolve indirect calls.
Function f:
0x6000:mov qword ptr [0x2010], 0x6050
0x6001:call0x6500
0x6002:callexit
...
0x6050:pushrbp
0x6051:...
...
Function g:
0x6500:movrax,qword ptr [0x2010]
0x6501:callrax
0x6502:ret
Fig. 4: Example of Indirect Call
Figure 4 provides an example. Function pointer 0x6050 is
written to a global variable (at address 0x2010 ). Function h
will be analyzed in a context where the pre-state provides:
σpre.∗/an}bracke⊔le{⊔{Global0x2010}B/an}bracke⊔ri}h⊔={0x6050}C
When symbolically executing the indirect call at Line 0x6501 ,
it is overapproximatively known that any pointer stored in
the global address space based on address 0x2010 points
to instruction address 0x6050 . The recursive traversal can
therefore consider 0x6050 as a reachable instruction address.
Note that in a stripped binary, functions are not delineated :
it is not known what addresses are function entries. Without
context, the indirect call at Line 0x6501 cannot be resolved
and the entire function at entry 0x6050 would have been
missed. Section VII-B provides data on how many indirection s
can be resolved in practice.
Preliminary to Decompilation: At the assembly level,
there are no variables. Bottom-up analysis, such as decom-
pilation, has no ground truth as to what regions in memory
constituted variables. A variable in source code typically is
compiled to a memory region, with the characteristic that th is
region is separate from any memory write not to the same
variable. As example consider Figure 5. It shows assembly
with some hypothetical pointer analysis result on the right .
Based on the derived pointers, a decompilation tool can assi gn
a variable xto lines0x7000 and0x7002 .
Bottom-up Dataﬂow Analysis: The post-state produced
by analysis of a function provides overapproximative insig ht
into what parts of the state are modiﬁed by a function. One0x7000:mov qword ptr [rdi], 42
0x7001:mov qword ptr [rsi], 43
0x7002:mov qword ptr [rbp-40], 44
(a) x86-64 Assemblyx:= 42
*rsi:= 43
x:= 44
(b) Decompiledrdi={rsp0−48}C
rsi={Allocid}B
rbp={rsp0−8}C
(c) Abstract Pointers
Fig. 5: Assembly code, decompiled to code with variables bas ed on abstract pointers.
application of this, is that it can be used to verify whether a
certain function abides by a calling convention. The callin g
convention designates certain registers to be non-volatil e, i.e.,
they must be preserved by a function. This can be observed
from the post-state directly. If the post-state provides th at, for
a register r:σpost.r={r0}C,then this indicates that register r
has been properly preserved. Many compilers use a push/pop
pattern to achieve such preservation: a register value is in itially
pushed to the local stack, and popped just before return.
Calling convention adherence requires abstract pointer an alysis
to be sufﬁciently precise throughout symbolic execution th at
the local region into which a register value is pushed is not
overwritten. A push/pop pattern is not necessary though: ou r
approach is transparent to the means of register preservati on
a function may use.
We provide an additional example demonstrating this over-
approximative form of pointer analysis can be used for live
variable analysis. Consider a function returning with the s tate
in Example 3. The pointer allocated at line 0x3003 is stored
in the return register rax and can therefore considered to be
live. However, if the state overapproximately indicates th at
the pointer is not returned and not written to global memory,
the pointer can be considered as “not live” after return of th e
function.
Finding suspect patterns for automated exploit gener-
ation: Pointer analysis can enhance real-world downstream
analyses. As an example, we consider automated exploit
generation: automatically ﬁnding bugs and generating work ing
exploits [2], [44]. One of the many challenges in this ﬁeld,
is to deal with state space explosion. Our pointer analysis
can be used to ﬁnd patterns in the binary that may lead to
vulnerabilities, thereby pruning the state space to be expl ored.
As a concrete case study, we can enumerate all instructions
in a binary that do a function call to an external function, and
that pass a pointer to the current stackframe as parameter to
that function. This is a suspect pattern, as the external fun ction
has been given the opportunity to overwrite the return addre ss.
We have applied our pointer analysis to the ret2win challenge
provide by ROP emporium2. The above heuristic ﬁnds an
instruction at address 0x400701 :call memset where register
rdi (the ﬁrst parameter under the System V ABI calling
convention) contains a local pointer. Indeed, the example i s
(purposefully) exploitable, and the exploit leverages exa ctly
this particular instruction.
2https://ropemporium.comVII. E VALUATION
In addition to the formal proofs of the soundness of our
approach, we provide a prototype implementation and con-
ducted a series of experimental studies to evaluate soundness
andpreciseness . We run 1.) a comparative evaluation against
the state-of-the-art, and 2.) a more in-detail evaluation per
instantiation .
A. Comparative Evaluation
The closest related works to our binary pointer analyzer
are BinPointer [26] and BPA [25]. Unfortunately, even after
contacting the authors of the papers, either their source co de
was not available or the code was not runnable on our
examples. Therefore, to stay fair in our comparison, we used
the exact same dataset of binaries that BinPointer and BPA
used (SPEC 2006 V1) and we employed the same deﬁnition
of soundness and precision they used in their paper.
We map all abstract pointers to a subset of {L,G,H}
(for: local, global, heap). Domains that are provably withi n
the current stackframe are mapped to {L}, domains that are
relative to the stackpointer but that may possibly be above
the current stack frame (e.g., point to the stackframe of a
caller) are mapped to {L,H}. Global bases are mapped to
{G}. Top is mapped to {L,G,H}, the rest is considered heap
and mapped to {H}. This produces function PAthat maps
instruction addresses to observations.
To assess the ground truth, we built an instrumentation tool
based on the dynamic binary instrumentation tool PIN [32].
Each memory write observed at run-time to some address a
is mapped to an element of {L,G,H}. Ifrsp0−0x10000≤
a≤rsp0, address ais considered local (here rsp0denotes
the value of the stackpointer when the current function was
called). We cannot know how large the stackframe is, and
overapproximate the size with the constant 0x10000 for sake
of observation. If address ais a memory address covered by
any of the sections where the binary is located at run-time, i t
is considered global. In all other cases, address ais considered
heap. By running multiple executions, each memory write
is mapped to a subset of {L,G,H}as well. This produces
functionGTthat maps instruction addresses to observations.
The total set of (instruction addresses of) observed memory
writes is denoted with W.
Soundness: We consider a static pointer analysis to be sound
if its results support the ground truth, i.e., the observati ons
of PIN. In other words, the pointer analysis must predict a
superset of the ground truth. Soundness is computed using th erecall : the percentage of supported memory writes to the total
number. If the recall is 100% , the pointer analysis is sound.
Precision: Soundness does not imply usefulness. For exam-
ple, if the pointer analysis returns ⊤for all the instructions,
it will be consider sound but useless. We therefore measure
precision as well. In words, precision measures the speciﬁcity
of the returned pointer domains. The precision is computed
as the total average of the percentage of domains that PA
overapproximated but were not observed by GT.
recall ≡100∗|{a∈W·GT(a)⊆PA(a)}|
|W|
precision ≡100∗avga∈W(1−|PA(a)\GT(a)|
3)
Table I shows results. The authors of BinPointer have
reported that the recall of their approach on the SPEC datase t
is 100%. Since we also observed the same recall for our
approach on this dataset, we do not include it in the table. As
the results show, when it comes to heap and global memory
accesses, our approach achieves over a 29% and15% higher
precision compared to BinPointer and BPA. For the local
memory accesses, our approach shows almost similar precisi on
compared to that of BinPointer. All other larger case studie s
reported in [26] are not publicly available. Interpreting a nd
comparing their published results subjectively, we conclu de
that our work achieves at least similar precision. The large st
reported binary for BinPointer is 161K instructions. In the next
section, we show that our tool scales upto 507K instructions ,
and we thus argue we are at least as scalable as well.
B. Per-instantiation Evaluation
We also evaluate per instantiation soundness and precision .
As case studies, we consider a set of binaries covering over
1M instructions (see Table II). Overall recall is 100%.
We discuss precision in more detail (see Figure 6). In-
stantiation Cis always 100% precise – as no abstraction is
applied – unless it assigns ⊤to a pointer. It may assign,
e.g.,{rsp0−8,0x3000}C, in which case on different paths the
pointer can be local or global (0.79% of the overall memory
writes). Overall, instantiation Cassigns a non- ⊤pointer to
85.22% of all memory writes.
Instantiation B, then, only marginally improves that number.
It assigns pointers to 0.95% more memory writes, and for thos e
only the base of the pointer is known. However, the value of
this instantiation ﬂuctuates per binary: for some it did not
improve on Cat all, but for others up to 5% more memory
writes got assigned a non- ⊤pointer. These are typically the
hard cases, e.g., a local pointer to an array for which only a
base could be established.
Instantiation S, ﬁnally, assigns a non- ⊤pointer to all
memory writes. Figure 6 shows that this mostly concerns heap -
pointers. From this we can conclude that the cap on the number
of sources is never hit, since otherwise this instantiation would
assign⊤. For those writes where both CandBassign⊤,
instantiation Sat least provides us with information on which
sources (e.g., function inputs or malloc s) were used to com-
pute the pointer value.A holistic way of looking at precision, is 1.) to see whether
the pointer analysis is sufﬁciently precise such that for ea ch
function all its pointers are assigned a domain separate fro m
the top of the stack frame (where the return address is stored ),
and 2.) that it enables resolving indirections. Table II sho ws
that for 94.2% of all functions this was the case ( OK). For
5.41% of the functions, not all indirections could be resolv ed
(UN), but all resolved paths ending in a return were OK.
Finally, for 0.39% of the functions, our pointer analysis wa s
not sufﬁciently precise to show that the return address was n ot
overwritten ( ERR ). This typically happens for functions with
complex stackpointer manipulation, such as stack probing o r
dynamic stack allocation.
VIII. C ONCLUSION
This paper presented an approach to formally proven correct
binary-level pointer analysis, that aims to assign a desig-
nation to each memory write in a binary. The designations
are provably overapproximative: the write provably cannot
occur to any region in memory outside of its designation.
Evaluation conﬁrms this soundness, and shows that precisio n
is comparable to or improves upon the state-of-the-art.
Many existing approaches to binary analysis, whether it
is disassembly, decompilation, binary patching or securit y
analysis, are unsound. State-of-the-art tools apply heuri stics,
incorporate best practices, and are generally based on exte nsive
human-in-the-loop knowledge. Decompilation becomes a for m
of art rather than an algorithm. We envision an overapprox-
imative – provably sound – approach as an alternative. This
requires provably sound disassembly, control ﬂow reconstr uc-
tion, decompilation, and type inference, to begin with. At t he
heart of all of these overapproximative techniques lies a pr oper
understanding of the semantics of each individual instruct ion.
Binary-level pointer analysis aims to aid these future ende avors
in overapproximative binary analysis, by indicating what t he
effect of each memory write in a binary can be.
DATA-AVAILABILITY STATEMENT
The implementation of the pointer analysis in this paper, al l
case studies, and the formal Isabelle/HOL proofs are availa ble
anonymously at: https://doi.org/10.5281/zenodo.142231 08.
ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers for their
insightful comments and suggestions, which helped to great ly
improve the paper.
This work is supported by the Defense Advanced Research
Projects Agency (DARPA) and Naval Information Warfare
Center Paciﬁc (NIWC Paciﬁc) under Contract No. N66001-
21-C-4028, by DARPA and the Army Contracting Command
Aberdeen Proving Grounds (ACC-APG) under Prime Contract
No. W912CG23C0024, and by DARPA under Prime Contract
No. HR001124C0492.Binary #instructionsLocal Global Heap
BPA BinPointer This paper BPA BinPointer This paper BPA BinP ointer This paper
mcf 2.4K 26.3 100.0 100.0 27.0 85.7 91.5 N/A N/A 57.8
lbm 2.2K 22.3 99.5 100.0 73.1 100.0 66.7 N/A N/A 33.3
libquantum 9.6K 47.9 100.0 100.0 100.0 100.0 100.0 6.9 6.9 50 .0
bzip2 11K 16.9 93.2 89.2 51.7 51.7 100 3.6 21.8 40
sjeng 22K 32.7 97.5 79.1 55.1 55.6 99.8 N/A N/A 56.1
milc 23K 49.4 99.4 93.3 81.2 88.9 95.2 23.7 23.7 51.1
hmmer 60K 38.0 99.9 98.9 76.4 76.4 100.0 7.6 11.5 65.4
h264ref 100K 35.3 97.3 97.1 6.2 65.5 90.6 24.2 40.8 47.6
Average 33.6 98.4 94.7 58.8 78.0 93.0 13.2 20.9 50.2
TABLE I: Comparison study of the precision (%) of BPA, BinPoi nter, and this paper on the SPEC dataset.
L
G H14.140.02
26.3843.83
0.79
0.06
⊤: 14.78C
L
G H14.450.02
26.7044.11
0.82
0.06
⊤: 13.83B
L
G H14.450.33
40.1144.13
0.82
0.070.07
⊤: 0S
Fig. 6: Precision results per instantiation. The numbers ar e percentages. For example, instantiation Cassigned a local pointer
to 43.83% of all memory accesses, and to 0.79% a pointer set wi th both a local and a global pointer.
Binary #instrs Time (m:ss) #functions
OK UN ERR
du 30K 0:09 173 7 0
gzip 14K 0:04 101 5 0
host 12K 0:04 62 8 2
sha512sum 10K 0:05 36 3 0
sort 18K 0:08 146 8 0
spec/* 150K 1:22 942 41 11
sqlite3 319K 1:33 1687 144 8
ssh 124K 1:01 523 32 8
tar 91K 0:15 300 17 0
vim 507K 4:26 2922 86 1
wc 6K 0:01 46 4 0
wget2 61K 0:10 578 81 2
xxd 2K 0:01 13 0 0
zip 24K 1:09 103 2 0
Total 1.4M 94.2% 5.41% 0.39%
TABLE II: Evaluation on an Apple M1 Pro with 32 GB of
memory. Memory usage was at most roughly 15GB for vim.
REFERENCES
[1] L. O. Andersen, “Program analysis and specialization fo r the C program-
ming language,” Ph.D. dissertation, DIKU, University of Co penhagen,
1994.
[2] T. Avgerinos, S. K. Cha, A. Rebert, E. J. Schwartz, M. Woo, and
D. Brumley, “Automatic exploit generation,” Communications of the
ACM , vol. 57, no. 2, pp. 74–84, 2014.
[3] D. Babi´ c, L. Martignoni, S. McCamant, and D. Song, “Stat ically-
directed dynamic automated test generation,” in Proceedings of the 2011
International Symposium on Software Testing and Analysis , ser. ISSTA
’11. New York, NY , USA: Association for Computing Machinery , 2011,
p. 12–22. [Online]. Available: https://doi.org/10.1145/ 2001420.2001423[4] C. Baier and J.-P. Katoen, Principles of model checking . MIT press,
2008.
[5] G. Balakrishnan and T. Reps, “Analyzing memory accesses in x86
executables,” in International conference on compiler construction .
Springer, 2004, pp. 5–23.
[6] ——, “Wysinwyx: What you see is not what you execute,” ACM Trans-
actions on Programming Languages and Systems (TOPLAS) , vol. 32,
no. 6, pp. 1–84, 2010.
[7] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz, “B ap: A binary
analysis platform,” in Computer Aided Veriﬁcation , G. Gopalakrishnan
and S. Qadeer, Eds. Berlin, Heidelberg: Springer Berlin Hei delberg,
2011, pp. 463–469.
[8] V . Chipounov, V . Georgescu, C. Zamﬁr, and G. Candea, “Sel ective
symbolic execution,” in Proceedings of the 5th Workshop on Hot Topics
in System Dependability (HotDep) , 2009.
[9] V . Chipounov, V . Kuznetsov, and G. Candea, “The s2e
platform: Design, implementation, and applications,” ACM Trans.
Comput. Syst. , vol. 30, no. 1, feb 2012. [Online]. Available:
https://doi.org/10.1145/2110356.2110358
[10] J.-D. Choi, M. Burke, and P. Carini, “Efﬁcient ﬂow-sens itive inter-
procedural computation of pointer-induced aliases and sid e effects,”
inProceedings of the 20th ACM SIGPLAN-SIGACT symposium on
Principles of programming languages , 1993, pp. 232–245.
[11] C. Cifuentes and K. J. Gough, “Decompilation of binary p rograms,”
Software: Practice and Experience , vol. 25, no. 7, pp. 811–829, 1995.
[12] P. Cousot and R. Cousot, “Abstract interpretation: a un iﬁed lattice model
for static analysis of programs by construction or approxim ation of
ﬁxpoints,” in Proceedings of the 4th ACM SIGACT-SIGPLAN symposium
on Principles of programming languages , 1977, pp. 238–252.
[13] L.-A. Daniel, S. Bardin, and T. Rezk, “Binsec/rel: Efﬁc ient relational
symbolic execution for constant-time at binary-level,” in 2020 IEEE
Symposium on Security and Privacy (SP) . IEEE, 2020, pp. 1021–1038.
[14] J. Dawson, “Isabelle theories for machine words,” Electronic Notes in
Theoretical Computer Science , vol. 250, no. 1, pp. 55–70, 2009.
[15] S. Debray, R. Muth, and M. Weippert, “Alias analysis of e xecutablecode,” in Proceedings of the 25th ACM SIGPLAN-SIGACT symposium
on Principles of programming languages , 1998, pp. 12–24.
[16] A. Djoudi and S. Bardin, “BINSEC: binary code analysis w ith low-level
regions,” in Tools and Algorithms for the Construction and Analysis
of Systems - 21st International Conference, TACAS 2015, Hel d as
Part of the European Joint Conferences on Theory and Practic e of
Software, ETAPS 2015, London, UK, April 11-18, 2015. Procee dings ,
ser. Lecture Notes in Computer Science, C. Baier and C. Tinel li,
Eds., vol. 9035. Springer, 2015, pp. 212–217. [Online]. Ava ilable:
https://doi.org/10.1007/978-3-662-46681-0 17
[17] M. Emami, R. Ghiya, and L. J. Hendren, “Context-sensiti ve interpro-
cedural points-to analysis in the presence of function poin ters,” ACM
SIGPLAN Notices , vol. 29, no. 6, pp. 242–256, 1994.
[18] J. Feist, L. Mounier, S. Bardin, R. David, and M. Potet, “ Finding
the needle in the heap: combining static analysis and dynami c
symbolic execution to trigger use-after-free,” in Proceedings of
the 6th Workshop on Software Security, Protection, and Reve rse
Engineering, SSPREW@ACSAC 2016, Los Angeles, California, USA,
December 5-6, 2016 , M. D. Preda, N. Stakhanova, and J. T.
McDonald, Eds. ACM, 2016, pp. 2:1–2:12. [Online]. Availabl e:
https://doi.org/10.1145/3015135.3015137
[19] G. Girol, B. Farinier, and S. Bardin, “Not all bugs are cr eated
equal, but robust reachability can tell the difference,” in Computer
Aided Veriﬁcation - 33rd International Conference, CAV 202 1,
Virtual Event, July 20-23, 2021, Proceedings, Part I , ser. Lecture
Notes in Computer Science, A. Silva and K. R. M. Leino, Eds.,
vol. 12759. Springer, 2021, pp. 669–693. [Online]. Availab le:
https://doi.org/10.1007/978-3-030-81685-8 32
[20] P. Godefroid, P. de Halleux, A. V . Nori, S. K. Rajamani, W . Schulte,
N. Tillmann, and M. Y . Levin, “Automating software testing u sing
program analysis,” IEEE software , vol. 25, no. 5, pp. 30–37, 2008.
[21] P. Godefroid, M. Y . Levin, and D. A. Molnar, “Automated w hitebox fuzz
testing,” in Proceedings of the Network and Distributed System Security
Symposium, NDSS 2008, San Diego, California, USA, 10th Febr uary -
13th February 2008 . The Internet Society, 2008. [Online]. Available:
https://www.ndss-symposium.org/ndss2008/automated-w hitebox-fuzz-testing/
[22] M. Hind, “Pointer analysis: Haven’t we solved this prob lem yet?”
inProceedings of the 2001 ACM SIGPLAN-SIGSOFT workshop on
Program analysis for software tools and engineering , 2001, pp. 54–61.
[23] S. Horwitz, A. Demers, and T. Teitelbaum, “An efﬁcient g eneral iterative
algorithm for dataﬂow analysis,” Acta Informatica , vol. 24, no. 6, pp.
679–694, 1987.
[24] T. Kapus and C. Cadar, “A segmented memory model for symb olic
execution,” in Proceedings of the 2019 27th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the
Foundations of Software Engineering , ser. ESEC/FSE 2019. New
York, NY , USA: Association for Computing Machinery, 2019, p .
774–784. [Online]. Available: https://doi.org/10.1145/ 3338906.3338936
[25] S. H. Kim, C. Sun, D. Zeng, and G. Tan, “Reﬁning indirect c all targets
at the binary level.” in NDSS , 2021.
[26] S. H. Kim, D. Zeng, C. Sun, and G. Tan, “BinPointer: towar ds precise,
sound, and scalable binary-level pointer analysis,” in Proceedings of the
31st ACM SIGPLAN International Conference on Compiler Cons truc-
tion, 2022, pp. 169–180.
[27] J. Kinder, “Static analysis of x86 executables,” Ph.D. dissertation,
Technische Universit¨ at, Darmstadt, Nov. 2010. [Online]. Available:
http://tuprints.ulb.tu-darmstadt.de/2338/
[28] J. Kinder and D. Kravchenko, “Alternating control ﬂow r econstruction,”
inVeriﬁcation, Model Checking, and Abstract Interpretation , V . Kun-
cak and A. Rybalchenko, Eds. Berlin, Heidelberg: Springer B erlin
Heidelberg, 2012, pp. 267–282.
[29] J. Kinder and H. Veith, “Jakstab: A static analysis plat form for binaries,”
inInternational Conference on Computer Aided Veriﬁcation . Springer,
2008, pp. 423–427.
[30] W. Landi, B. G. Ryder, and S. Zhang, “Interprocedural mo diﬁcation side
effect analysis with pointer aliasing,” ACM SIGPLAN Notices , vol. 28,
no. 6, pp. 56–67, 1993.
[31] X. Leroy and S. Blazy, “Formal veriﬁcation of a c-like me mory
model and its uses for verifying program transformations,” Journal of
Automated Reasoning , vol. 41, no. 1, pp. 1–31, 2008.
[32] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lown ey,
S. Wallace, V . J. Reddi, and K. Hazelwood, “Pin: building cus tomized
program analysis tools with dynamic instrumentation,” Acm sigplan
notices , vol. 40, no. 6, pp. 190–200, 2005.[33] L. Martignoni, S. McCamant, P. Poosankam, D. Song, and P . Maniatis,
“Path-exploration lifting: Hi-ﬁ tests for lo-ﬁ emulators, ”SIGPLAN
Not., vol. 47, no. 4, p. 337–348, mar 2012. [Online]. Available:
https://doi.org/10.1145/2248487.2151012
[34] L. d. Moura and N. Bjørner, “Z3: An efﬁcient smt solver,” inInter-
national conference on Tools and Algorithms for the Constru ction and
Analysis of Systems . Springer, 2008, pp. 337–340.
[35] J. A. Navas, P. Schachte, H. Søndergaard, and P. J. Stuck ey, “Signedness-
agnostic program analysis: Precise integer bounds for low- level code,” in
Asian Symposium on Programming Languages and Systems . Springer,
2012, pp. 115–130.
[36] T. Nipkow, M. Wenzel, and L. C. Paulson, Isabelle/HOL: a proof
assistant for higher-order logic . Springer, 2002.
[37] C. Pang, R. Yu, Y . Chen, E. Koskinen, G. Portokalidis, B. Mao, and
J. Xu, “SoK: All you ever wanted to know about x86/x64 binary
disassembly but were afraid to ask,” in 2021 IEEE Symposium on
Security and Privacy (SP) . IEEE, 2021, pp. 833–851.
[38] G. Ramalingam, “The undecidability of aliasing,” ACM Trans. Program.
Lang. Syst. , vol. 16, no. 5, p. 1467–1471, sep 1994. [Online]. Available :
https://doi.org/10.1145/186025.186041
[39] T. Reps and G. Balakrishnan, “Improved memory-access a nalysis for
x86 executables,” in International Conference on Compiler Construc-
tion. Springer, 2008, pp. 16–35.
[40] R. Rohleder, “Hands-on Ghidra tutorial about the softw are reverse
engineering framework,” in Proceedings of the 3rd ACM Workshop on
Software Protection , 2019, pp. 77–78.
[41] Y . Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. P olino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. V igna,
“Sok: (state of) the art of war: Offensive techniques in bina ry analysis,”
in2016 IEEE Symposium on Security and Privacy (SP) , 2016, pp. 138–
157.
[42] B. Steensgaard, “Points-to analysis in almost linear t ime,” in Proceed-
ings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of
programming languages , 1996, pp. 32–41.
[43] F. Verbeek, J. Bockenek, Z. Fu, and B. Ravindran, “Forma lly veriﬁed
lifting of c-compiled x86-64 binaries,” in Proceedings of the 43rd ACM
SIGPLAN International Conference on Programming Language Design
and Implementation , 2022, pp. 934–949.
[44] W. You, P. Zong, K. Chen, X. Wang, X. Liao, P. Bian, and B. L iang,
“Semfuzz: Semantics-based automatic generation of proof- of-concept
exploits,” in Proceedings of the 2017 ACM SIGSAC conference on
computer and communications security , 2017, pp. 2139–2154.
[45] Z. Zhang, W. You, G. Tao, G. Wei, Y . Kwon, and X. Zhang, “BD A:
practical dependence analysis for binary executables by un biased whole-
program path sampling and per-path abstract interpretatio n,”Proceed-
ings of the ACM on Programming Languages , vol. 3, no. OOPSLA, pp.
1–31, 2019.