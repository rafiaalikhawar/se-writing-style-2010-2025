Mining Resource-Operation Knowledge to Support Resource
Leak Detection
Chong Wang
Fudan University
Shanghai, China
wangchong20@fudan.edu.cnYiling Louâˆ—
Fudan University
Shanghai, China
yilinglou@fudan.edu.cnXin Peng
Fudan University
Shanghai, China
pengxin@fudan.edu.cn
Jianan Liu
Fudan University
Shanghai, China
21210240250@m.fudan.edu.cnBaihan Zou
Fudan University
Shanghai, China
bhzou21@m.fudan.edu.cn
ABSTRACT
Resource leaks, which are caused by acquired resources not being re-
leased, often result in performance degradation and system crashes.
Resource leak detection relies on two essential components: identi-
fying potential Resource Acquisition and Release (RAR) API pairs,
and subsequently analyze code to uncover instances where the cor-
responding release API call is absent after an acquisition API call.
Yet, existing techniques conï¿¿ne themselves to an incomplete pair
pool, either pre-deï¿¿ned manually or mined from project-speciï¿¿c
code corpus, thus limiting coverage across libraries/APIs and po-
tentially overlooking latent resource leaks.
In this work, we propose to represent resource-operation knowl-
edge as abstract resource acquisition/release operation pairs
(Abs-RAR pairs for short), and present a novel approach called
Mï¿¿ROK to mine such Abs-RAR pairs to construct a better RAR pair
pool. Given a large code corpus, Mï¿¿ROK ï¿¿rst mines Abs-RAR pairs
with rule-based pair expansion and learning-based pair identiï¿¿-
cation strategies, and then instantiates these Abs-RAR pairs into
concrete RAR pairs. We implement Mï¿¿ROK and apply it to mine
RAR pairs from a large code corpus of 1,454,224 Java methods and
20,000 Maven libraries. We then perform an extensive evaluation
to investigate the mining eï¿¿ectiveness of Mï¿¿ROK and the practical
usage of its mined RAR pairs for supporting resource leak detec-
tion. Our results show that Mï¿¿ROK mines 1,313 new Abs-RAR pairs
and instantiates them into 6,314 RAR pairs with a high precision
(i.e., 93.3%). In addition, by feeding our mined RAR pairs, existing
approaches detect more resource leak defects in both online code
examples and open-source projects.
CCS CONCEPTS
â€¢Software and its engineering !Software libraries and reposito-
ries.
âˆ—Y. Lou is the corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¿¿t or commercial advantage and that copies bear this notice and the full citation
on the ï¿¿rst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciï¿¿c permission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
Â©2023 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0327-0/23/12. . . $15.00
https://doi.org/10.1145/3611643.3616315KEYWORDS
resource leaks, defect detection, knowledge representation, knowl-
edge mining
ACM Reference Format:
Chong Wang, Yiling Lou, Xin Peng, Jianan Liu, and Baihan Zou. 2023. Mining
Resource-Operation Knowledge to Support Resource Leak Detection. In
Proceedings of the 31st ACM Joint European Software Engineering Conference
and Symposium on the Foundations of Software Engineering (ESEC/FSE â€™23),
December 3â€“9, 2023, San Francisco, CA, USA. ACM, New York, NY, USA,
13pages. https://doi.org/10.1145/3611643.3616315
1 INTRODUCTION
Resource leaks, which are caused by acquired resources not being
released ( e.g., unclosed ï¿¿le handle), is a serious software defect
that may cause runtime exceptions or program crashes. Resource
leaks are prevalent in both software projects [ 13] and online code
examples (e.g., even those code snippets accepted as correct answers
in Stack Overï¿¿ow posts [ 54]).
To date, researchers have proposed various automated resource
leak detection techniques, which mainly rely on two essential com-
ponents. First, identify the potential pairs of the Resource Acqui-
sition API method and the corresponding Resource Release API
method ( RAR pairs for short); Then based on the RAR pairs, analyze
the code to check whether the release API is not subsequently called
after the acquisition API. For example, the resource acquisition API
method LockManager.acquireLock() and the resource release API
method LockManager.releaseLock() are one RAR pair of the lock re-
source; and a resource leak occurs when LockManager.releaseLock()
is not called subsequently after LockManager.acquireLock() .
Although achieving promising eï¿¿ectiveness, the majority of
existing resource leak detection techniques are concentrated on
proposing more precise and more scalable code analysis approaches
[21,44,49], while few of them focus on building a more complete
RAR pair pool. However, knowing the RAR pair is the prerequisite
of detecting the corresponding resource leak in the code, and an
incomplete RAR pair pool would limit the eï¿¿ectiveness of the fol-
lowing code analysis. In particular, most existing techniques [ 44,49]
rely on human expertise and heuristic rules to predeï¿¿ne RAR pairs.
Such predeï¿¿ned RAR pairs not only require non-trivial human
eï¿¿orts but also have limited coverage in libraries and APIs. For
example, FindBugs [ 2] only considers the predeï¿¿ned stream re-
lated RAR pairs and thus could only detect stream related resource
986
ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Chong Wang, Yiling Lou, Xin Peng, Jianan Liu, and Baihan Zou< Lock.acquire(), Lock.release() >< NoopLock.acquireLock(), NoopLock.releaseLock() >< GlobalLock.acquire(), GlobalLock.release() >â€¦< HLockManager.acquire, HLockManager.release>< LockManager.acquireLock(), LockManager.releaseLock() >â€¦Corresponding RAR Pairs in Different LibrariesAbs-RAR Pair for lock resourceã€ˆlock, acquire / releaseã€‰
Figure 1: Abs-RAR Pair and RAR Pairs for Resource lock
leaks. More recently, Bian et al. [8] propose to identify RAR pairs
for a given project by mining and classifying frequent API pairs
within the project code corpus. However, such project-speciï¿¿c fre-
quent mining is limited to speciï¿¿c libraries/projects and could only
ï¿¿nd RAR pairs that are frequently used in the project code corpus,
missing those infrequent RAR pairs.
Thus, in this work, we aim at building a large RAR pair pool
from a mass of projects and libraries, which could be used to en-
hance and support resource leak detection. In fact, it is challenging
to build such a relatively complete RAR pair pool that precisely
includes as many RAR pairs as possible. First, given the large va-
riety of libraries and APIs in the wild, it is not easy to cover the
diverse resources and acquisition/release operations. For example,
just for the lock resource, there are over 738 relevant RAR pairs
(reported by our approach), e.g., < LockManager.acquireLock() ,Lock-
Manager.releaseLock() > and < SoftLock.lock() ,SoftLock.unlock() >. In
addition to popular resources, there are many less common re-
sources (e.g., â€œsemaphoreâ€). Second, it is not easy to precisely iden-
tify whether two APIs belong to one RAR pair, since a pair of
antisense verbs do not always indicate the acquisition and release
operations. For example, although â€œopenâ€ and â€œcloseâ€ are a pair of
antisense verbs that are commonly used in acquisition and release
APIs for some resources ( e.g.,<Database.open() ,Database.close() >
and < Connection.open() ,Connection.close() >), they do not denote
resource acquisition and release in some context ( e.g.,â€œopenTag()â€
and â€œcloseTag()â€ actually denote the start tag and end tag of an XML
element).
To this end, we propose to represent resource-operation knowl-
edge as abstract resource acquisition/release operation pairs
(i.e., Abs-RAR pairs for short), and mine such Abs-RAR pairs from a
large code corpus. Diï¿¿erent from RAR pairs that are represented by
concrete API methods, an Abs-RAR pair uses conceptual-level noun
and verbs to describe the resource object and acquisition/release
operations, which thus is able to represent a group of RAR pairs
that share similar semantics. For example, as shown in Figure 1, the
Abs-RAR pair hlock, acquire / release icould represent a set of RAR
pairs that use â€œacquireâ€ and â€œreleaseâ€ to manage the â€œlockâ€ resource,
such as < GlobalLock.acquire() ,GlobalLock.release() > in library xml-
beans and < LockManager.acquireLock() ,LockManager.releaseLock() >
in library copper-coreengine (highlighted in Figure 1). Our insight
is that abstract representation could extract more general resource-
operation knowledge from a large code corpus and cover more
diverse RAR pairs across diï¿¿erent libraries/projects.
Based on this idea, we propose Mï¿¿ROK , a novel approach for
Mining Resource Operation Knowledge, which constructs a large
RAR pair pool to support resource leak detection. Given a large code
corpus, Mï¿¿ROK ï¿¿rst mines resource operation knowledge in theform of Abs-RAR pairs and then instantiates these Abs-RAR pairs
into concrete RAR pairs. In particular, Mï¿¿ROK iteratively mines new
Abs-RAR pairs based on existing ones with two strategies, i.e., the
rule-based Abs-RAR pair expansion strategy derives new Abs-RAR
pairs from existing ones based on the conceptual specialization
relationships between resources, and the learning-based Abs-RAR
pair identiï¿¿cation strategy trains a sequence labeling model to
identify new Abs-RAR pairs. After the Abs-RAR pairs are mined,
Mï¿¿ROK then instantiates them into concrete RAR pairs in diï¿¿erent
libraries with matching-based rules.
We implement Mï¿¿ROK and apply it to mine resource operation
knowledge from a large code corpus of 1,454,224 Java methods and
20,000 Maven libraries. We then perform an extensive evaluation
to investigate the mining eï¿¿ectiveness of Mï¿¿ROK and the usage of
its mined RAR pairs for supporting resource leak detection. First,
we investigate its mining eï¿¿ectiveness by checking the quality
of its mined Abs-RAR pairs and the instantiated RAR pairs. In
total, Mï¿¿ROK mines 1,313 new Abs-RAR pairs based on 26 seed
pairs and 89.2% (1,171) of them are manually checked as correct;
and all Abs-RAR pairs are then instantiated into 6,314 RAR pairs
from 2,261 libraries and 93.3% of them are manually checked as
correct. Second, we feed our mined RAR pairs to existing resource
leak detection analysis approaches and study how they could boost
resource leak detection. Given the prevalence of resource leak issues
in both online code examples and open-source projects, we evaluate
how our generated RAR pairs help resource leak detection in both
scenarios. First, for the online code examples, we ï¿¿nd that with our
newly-mined RAR pairs as inputs, even a simplistic static analysis
approach successfully detects 4.5 â‡¥more resource leaks ( i.e.,761
resource leaks in total) from 46,389 online code examples with a high
precision (73.4%). Second, for the open-source projects, we enhance
the widely-used resource leak static detection tool Findbugs by
enriching its initial RAR pool with our new RAR pairs. Our results
show that on 10 Github projects, the original Findbugs detects 4
resource leaks while the Findbugs extended with our RAR pairs
detects 3 more previously-unknown resource leaks. Among them
one has been conï¿¿rmed by developers as of the submission time.
In summary, the results show both the high quality and practical
usage of our mined RAR pairs.
In summary, this paper makes the following contributions:
â€¢A novel representation that represents resource operation
knowledge with Abs-RAR pairs. Such Abs-RAR pairs could rep-
resent a group of semantically-similar RAR pairs across diï¿¿er-
ent libraries/projects, and thus convey more general resource-
operation knowledge of a large code corpus.
â€¢A novel mining approach Mï¿¿ROK that constructs a large
RAR pair pool to support resource leak detection. Mï¿¿ROK ï¿¿rst
learns to mine Abs-RAR pairs from a large code corpus in an
iterative learning process and then instantiates these Abs-RAR
pairs into concrete RAR pairs.
â€¢A large-scale and high-quality RAR pair pool that contains
6,314 RAR pairs mined from 1,454,224 Java methods over 2,261
libraries. To the best of our knowledge, this is the largest RAR
pair pool for Java resource leak detection. We would publicly
release our RAR pairs, which could be incorporated by existing
or future resource leak detection work.
987Mining Resource-Operation Knowledge to Support Resource Leak Detection ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
â€¢An extensive evaluation that investigates both the mining
eï¿¿ectiveness and the practical usage of mined RAR pairs for sup-
porting resource leak detection. The results show that Mï¿¿ROK
successfully mines and instantiates a large number of RAR
pairs with a high precision, and our mined RAR pairs further
help existing resource leak detection approaches to ï¿¿nd more
resource leaks in both online code snippets and open-source
projects.
2 RELATED WORK
Since our work mines resource acquisition and release API pairs
to support resource leak detection, in this section, we discuss the
related work on resource leak detection (Section 2.1) and API usage
pattern mining (Section 2.2).
2.1 Resource Leak Detection
Automated resource leak detection techniques [ 11,16,21,22,25â€“
27,29,30,32,39,40,42â€“44,49,50] have been proposed to detect
whether some resource is not being released after its acquisition.
Typically there are two important components for resource leak
detection. First, identify the potential RAR pairs (the pair of the
resource acquisition API method and the corresponding resource
release API method); (2) then based on the RAR pairs, analyze the
code to check whether the release API is not subsequently called
after the acquisition API.
The majority of existing resource leak detection techniques are
concentrated on the analysis part by proposing more precise and
more scalable code analysis approaches [ 11,21,27,40,44,49]. For
example, Torlak et al. [44] combine intra-procedural analysis and
inter-procedural analysis to enable more scalable and more ac-
curate detection for system resource leaks (e.g., I/O stream and
database connections); Wu et al. [49] propose an inter-procedural
and callback-aware static analysis approach to detect resource leak
in Android apps; Kellogg et al. [21] incorporate ownership trans-
fer analysis, resource alias analysis, and obligation fresh to enable
more precise analysis. Our work is orthometric to this line of work,
since we focus on building a more diverse and large RAR pair pool
and our generated RAR pairs could further be incorporated into
existing resource leak detection techniques.
In fact, the RAR pairs used in most existing techniques [ 44,49]
are often predeï¿¿ned by human expertise and heuristic rules, which
not only require non-trivial human eï¿¿orts but also have limited cov-
erage in libraries and APIs. For example, Torlak et al. [44] manually
collect RAR pairs that are related to stream anddatabase resources
in JDK. In addition, FindBugs [ 2] only considers the predeï¿¿ned
stream related RAR pairs and thus could only detect stream related
resource leaks. More recently, Bian et al. [8] propose SinkFinder,
which mines RAR pairs for a given project by mining and classi-
fying frequent API pairs within the project code corpus. However,
its mined RAR pairs are limited to speciï¿¿c libraries/projects and
only include RAR pairs that are frequently used in the project
code corpus, thus missing those infrequent RAR pairs. Diï¿¿erent
from SinkFinder, our work represents and mines resource-operation
knowledge via a novel abstract representation (e.g., Abs-RAR pairs),
based on which we build a large RAR pair pool from a large amount
of diverse libraries/projects.
Call Sequence ExtractionAbs-RAR Pairs(Initializedwithseedpairs)Rule-based Abs-RAR Pair Expansion
Learning-based Abs-RAR Pair Identification
LargeCodeCorpus1.Preprocessing2.Abs-RARPairMiningResource-Operation Knowledge Base3.RARPairInstantiation
LibrariesConcreteRARPairsFigure 2: Approach Overview of Mï¿¿ROK
2.2 Mining API Usage Pattern for Misuse
Detection
In other domains, there are also some techniques that mine API
usage patterns to detect the relevant API misuse [ 7,8,10,28,36â€“
38,48,53â€“55]. For example, Chang et al. [10] leverage frequent
subgraph and itemset mining to mine rules for neglected condition
detection. ExampleCheck [ 54] mines 180 API usage patterns for
100 popular Java APIs to detect API misuses such as missing con-
trol constructs and incorrect guard conditions. Our work targets a
domain (i.e., resource leak) diï¿¿erent from these techniques, i.e., we
focus on mining the usage patterns of APIs on resource-operation
knowledge. To this end, we not only propose a novel representation
(i.e., Abs-RAR pairs) to represent the resource-knowledge-related
API usage pairs, but also propose a novel learning-based mining
approach to mine such Abs-RAR pairs from a large code corpus.
3 APPROACH
Mï¿¿ROK mines Abs-RAR pairs from a large code corpus and then
instantiates the Abs-RAR pairs into concrete RAR pairs of diï¿¿erent
libraries. Figure 2shows an overview of Mï¿¿ROK , which mainly
consists of three phases: call sequence extraction, Abs-RAR pair
mining, and RAR pair instantiation. (1) First, Mï¿¿ROK parses the
large code corpus to extract method call sequences (Section 3.1).
(2) Second, Mï¿¿ROK iteratively mines Abs-RAR pairs from the ex-
tracted sequences with two strategies (Section 3.2), i.e., rule-based
Abs-RAR pair expansion and learning-based Abs-RAR pair identi-
ï¿¿cation. (3) Lastly, Mï¿¿ROK instantiates the mined Abs-RAR pairs
into concrete RAR pairs (Section 3.3). In this work, we focus on
resource-operation knowledge in Java.
3.1 Method Call Sequence Extraction
Since resource acquisition and releasing are often achieved by in-
voking relevant API methods, Mï¿¿ROK ï¿¿rst parses the given code
corpus to extract method call sequences as the input of the Abs-RAR
pair mining.
For each source ï¿¿le in the code corpus, Mï¿¿ROK ï¿¿rst parses it
into an abstract syntax tree (AST) with the javalang toolkit [ 3], and
then extracts a sequence of method calls based on AST node types
following previous works [ 14,15].
An extracted method call sequence (is a list of method calls
ordered by their appearance in the code. For each method call >. <,
oandmdenote the name of the object and the called method respec-
tively. For example, for the method verify() shown in Figure 3(a),
Mï¿¿ROK extracts a method call sequence shown in Figure 3(b).
3.2 Abs-RAR Pair Mining
Abs-RAR Pair Deï¿¿nition. An Abs-RAR pair is a two-tuple %01B=
hA4B,02@/A4;i, where A4Brefers to a resource concept, and 02@ and
988ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Chong Wang, Yiling Lou, Xin Peng, Jianan Liu, and Baihan Zou
(a) Code Example
wakeLock.acquireRecoverySystem.verifyPackagewakeLock.releaseCall Sequence:(b) Method Call Sequence
wakeOBJTreslockOBJTresacquireMDTacqsystemOBJTnonverifyMDTnonwakeOBJTreslockMDTresToken Sequence:Part Sequence:Tag Sequence:recoveryOBJTnonpackageMDTnonreleaseMDTrel(c) Token Sequence, Part Sequence, and Tag Sequence
Figure 3: A Code Example and its Corresponding Call Se-
quence, Token Sequence, Part Sequence, and Tag Sequence
A4;is a pair of conceptual-level resource acquisition and release
operations for A4B. The beneï¿¿ts of conceptual-level abstraction in
Abs-RAR are two-folds. First, an Abs-RAR pair can be regarded
as an abstraction of similar RAR pairs that are implemented in
diï¿¿erent libraries. For example, hlock, acquire / release iis an Abs-
RAR pair for lock resource, as shown in Figure 1, it could represent
a group of relevant RAR pairs deï¿¿ned in diï¿¿erent libraries. Sec-
ond, representing the resources and acquisition/release operations
in a conceptual way could further support resource generaliza-
tion/specialization ( e.g.,â€œwake lockâ€ is a specialization of â€œlockâ€),
synonyms ( e.g., â€œdatabaseâ€ and â€œdbâ€ are synonyms), and seman-
tic relevance ( e.g.,â€œlockâ€ and â€œsemaphoreâ€ are both concurrency-
related resources, â€œacquireâ€/â€œreleaseâ€ and â€œlockâ€/â€œunlockâ€ are both
concurrency-related acquisition/release operations). These proper-
ties can help the transfer and generalization of resource-operation
knowledge, thus are beneï¿¿cial for the mining.
With a small set of seed Abs-RAR pairs, Mï¿¿ROK iteratively mines
Abs-RAR pairs from the extracted method call sequences via two
strategies (i.e., rule-based Abs-RAR pair expansion and learning-
based Abs-RAR pair identiï¿¿cation). Rule-based Abs-RAR pair ex-
pansion derives new Abs-RAR pairs from existing ones based on
the conceptual specialization relationships between resources; and
learning-based Abs-RAR pair identiï¿¿cation trains a sequence la-
beling model based on existing Abs-RAR pairs and uses the model
to identify new Abs-RAR pairs from the method call sequences. In
each iteration, Mï¿¿ROK leverages both strategies to extract new Abs-
RAR pairs, which are then included to extend the pool of Abs-RAR
pairs. The iteration process repeats until the maximum number of
iterations is reached or no new Abs-RAR pairs are found. We then
detail each mining strategy respectively.
3.2.1 Rule-based Abs-RAR Pair Expansion. Rule-based Abs-RAR
pair expansion derives new Abs-RAR pairs from existing ones based
on the specialization relationships between resources. In particu-
lar, a conceptual specialization relationship means that a resource
concept is a special instantiation of another resource concept. For
example, we regard the resource concept â€œwake lockâ€ as a special-
ization of the resource concept â€œlockâ€, and it is very likely that thespecialized resource concept â€œwake lockâ€ shares the similar acqui-
sition/release operations as â€œlockâ€ (e.g., â€œacquireâ€ and â€œreleaseâ€).
In particular, given a method call sequence (,Mï¿¿ROK ï¿¿rst iden-
tify all the candidate method call pairs, which match any existing
Abs-RAR pair as a conceptual specialization; then Mï¿¿ROK derives
new Abs-RAR pairs based on the candidate pairs. We then introduce
the detailed steps as follows.
First, Mï¿¿ROK tokenizes each method call >. < in the method call
sequence (based on camel case [ 14,15,31] and parse part-of-speech
(POS) tags [ 17,46,47]. In this way, each method call >. < is tok-
enized into the form [ O VB NP REST ], where Odenotes the object
name, and VB,NP, and REST denote the verb, noun phrase, and the
rest tokens in <, respectively. For example, the method call File-
sController.openFileByName is transformed into [ O(â€œï¿¿le controllersâ€)
VB(â€œopenâ€) NP(â€œï¿¿leâ€) REST(â€œby nameâ€) ].
Second, for each two methods calls (i.e., >. < 1and>. < 2) in(,
Mï¿¿ROK identiï¿¿es whether they are a pair of resource acquisition/re-
lease operations (based on our pairing rules) and whether they
match any existing Abs-RAR pair hA4B,02@/A4;ias a conceptual
specialization (based on our matching rules). The qualiï¿¿ed method
call pairs are considered as candidate pairs.
â€¢Matching Rules. We consider a method call >. < with the form
[O VB NP REST ] matches A4B. 02@ (orA4B. A4; ) if it satisï¿¿es the
following two conditions: (1) the noun phrase NPcontains A4B,
orOcontains A4BandNPis empty; (2) the verb VBequals 02@
(orA4;).
â€¢Pairing Rules. We consider two method calls >. <1and>. <2
as a pair of acquisition/release operations , if they satisfy the
following three conditions: (1) >. < 1and>. < 2match A4B. 02@
andA4B. A4; respectively; (2) the noun phrase ( i.e., NP ) and the
rest ( i.e., REST ) in>. < 1and>. < 2are the same; and (3) >. < 1
appears before >. < 2in the same method call sequence.
Third, based on each candidate pair < >. < 1,>. < 2>,Mï¿¿ROK cre-
ates a new Abs-RAR pair hA4B0,02@/A4;i, where A4B0is>if>con-
tains A4BandNPotherwise. For example, given an Abs-RAR pair
hlock, acquire / release i, we can derive a candidate Abs-RAR pair
hwake lock, acquire / release ifrom the method call sequence shown
in Figure 3(b). To avoid generating an overwhelming number of
Abs-RAR pairs in each iteration, we only include those ones whose
frequency is more than three into the Abs-RAR pair pool.
3.2.2 Learning-based Abs-RAR Pair Identification. Rule-based pair
expansion only mines new pairs which have conceptual specializa-
tion relationships of existing pairs. Hence, to include more diverse
Abs-RAR pairs, Mï¿¿ROK further leverages a learning-based Abs-
RAR pair identiï¿¿cation strategy. In particular, Mï¿¿ROK treats the
Abs-RAR pair identiï¿¿cation problem as a sequence labeling prob-
lem [ 20], leverages existing Abs-RAR pairs to automatically label
the data for model training, and then utilizes the trained model to
extract new Abs-RAR pairs. We then discuss details on the problem
deï¿¿nition, automatic data labeling, model design, and training/pre-
diction procedure, respectively.
Problem Deï¿¿nition. We model Abs-RAR pair identiï¿¿cation as
a sequence labeling problem. Sequence labeling has been widely
studied in natural language processing (NLP) [ 20] and applied to
software engineering tasks, e.g.,entity/concept recognition [ 45,51,
52], and its main goal is to tag each token in a token sequence.
989Mining Resource-Operation Knowledge to Support Resource Leak Detection ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
In our context, we deï¿¿ne four diï¿¿erent tags, i.e.,)A4B,)02@,)A4;,
and)=>=(denoting tokens corresponding to resource, acquisition
operation, release operation, and others, respectively). With each
method call sequence as a token sequence, our goal is to assign a tag
to each token; and based on the combination of these tagged tokens,
we could further identify possible combinations of a resource A4B,
an acquisition operation 02@, and a release operation A4;that can
form an Abs-RAR pair like hA4B,02@/A4;i. For example, the token
sequence and the tag sequence of the method call sequence in
Figure 3(b)are shown in Figure 3(c).
Automatic Data Labeling. To prepare the training data for the se-
quence labeling model, Mï¿¿ROK automatically labels the method call
sequences via a distant supervision method. Distant supervision
was originally proposed for the data labeling problem in relation
extraction [ 35]. The main idea is to use the existing knowledge
base to automatically label training data. In our work, we use ex-
isting Abs-RAR pairs as the resource-operation knowledge base to
automatically label method call sequences. For each method call
sequence (, if it matches an existing Abs-RAR pair, it is automat-
ically labeled and used a training sample; otherwise, it is used as
a prediction sample for identifying new Abs-RAR pairs. We then
explain the details as follows.
â€¢Token/Part Sequence Generation .Mï¿¿ROK generates a token se-
quence and a part sequence for the method call sequence (.
These two sequences will be used as the input of the sequence
labeling model. For each method call >. < in(,Mï¿¿ROK tok-
enizes >and<by camel case to get a subsequence of tokens.
For example, the method call â€œwakeLock.acquireâ€ is tokenized
into a subsequence [â€œwakeâ€, â€œlockâ€, â€œacquireâ€]. Then Mï¿¿ROK
generates a token sequence for (by concatenating the token
subsequences of all the method calls in (. To record the part
of method call (object or method) to which a token belongs,
Mï¿¿ROK generates a corresponding part sequence for the token
sequence. For each token, the part sequence uses OBJ orMD
to indicate that the token is from the object part or the method
part of the method call. For example, for the above token sub-
sequence [â€œwakeâ€, â€œlockâ€, â€œacquireâ€], its corresponding part
subsequence is [ OBJ,OBJ,MD].
â€¢Matching Sequences with Abs-RAR Pairs .Mï¿¿ROK then checks
whether (could match any existing Abs-RAR pair. For each
Abs-RAR pair, Mï¿¿ROK checks whether any pair of method calls
in(matches the Abs-RAR pair based on the pairing rules in
Section 3.2.1. If such a pair of method calls is found, the method
call sequence (matches the Abs-RAR pair. If (matches two
Abs-RAR pairs and one of them is derived from the other, we
only keep the derived one, i.e.,the specialized one. For example,
the method call sequence shown in Figure 3(b)matches both
hlock, acquire / release iandhwake lock, acquire / release iand
we only keep the latter.
â€¢Tag Sequence Generation . If(matches an existing Abs-RAR pair
hA4B,02@/A4;i,Mï¿¿ROK then generates a tag sequence for it. As-
suming the corresponding method call pair in (is <>. < 1,>. < 2>,
Mï¿¿ROK transforms >. < 1and>. < 2into the form [ O VB NP REST ]
and generates a tag for each token in the token sequence of
(in the following way: the verbs ( i.e., VB ) in<1and<2are
tagged with )02@and)A4;respectively; the tokens in >or the
wakeOBJlockOBJacquireMDsystemOBJverifyMDwakeOBJlockMDToken Sequence:Part Sequence:recoveryOBJpackageMDreleaseMDToken  Embedding & Part Embedding LayerBi-LSTM LayerBi-LSTM LayerTag Classification LayerTag Embedding Layerğ’‰ğŸğ’‰ğŸğ’‰ğŸ‘ğ’‰ğŸ“ğ’‰ğŸ”ğ’‰ğŸ–ğ’‰ğŸ—ğ’‰ğŸ’ğ’‰ğŸ•ğ’‰ğŸğŸHidden States:TresTresTacqTnonTnonTresTresTag Sequence:TnonTnonTrelTag Vectors:ğ’•ğŸğ’•ğŸğ’•ğŸ‘ğ’•ğŸ“ğ’•ğŸ”ğ’•ğŸ–ğ’•ğŸ—ğ’•ğŸ’ğ’•ğŸ•ğ’•ğŸğŸ
ğ’ŠğŸğ’ŠğŸğ’ŠğŸ‘ğ’ŠğŸ“ğ’ŠğŸ”ğ’ŠğŸ–ğ’ŠğŸ—ğ’ŠğŸ’ğ’ŠğŸ•ğ’ŠğŸğŸÃ—ğ·
ğ’†ğŸğ’†ğŸğ’†ğŸ‘ğ’†ğŸ“ğ’†ğŸ”ğ’†ğŸ–ğ’†ğŸ—ğ’†ğŸ’ğ’†ğŸ•ğ’†ğŸğŸEnriched Token Vectors:Input Vectors:Figure 4: Sequence Labeling Model in Mï¿¿ROK
noun phrase (i.e., NP) in<1and<2that contain A4Bare tagged
with )A4B; all the other tokens are tagged with )=>=. For exam-
ple, for the method call sequence shown in Figure 3(b)Mï¿¿ROK
generates a tag sequence as shown in Figure 3(c).
In this way, if a tag sequence could be generated for (,Mï¿¿ROK
treats it as a training sample and uses its token sequence, part
sequence, and tag sequence for training; otherwise, Mï¿¿ROK treats it
as a prediction sample and conducts sequence labeling on its token
sequence and part sequence to identify new Abs-RAR pairs.
Model Architecture. The sequence labeling model in Mï¿¿ROK
needs to meet the following two requirements. First, the model
should be able to produce multiple tag sequences for a method
call sequence, as there might be multiple Abs-RAR pairs. Thus, we
leverage the iterative grid labeling in OpenIE6 [ 24], which could
support iteratively producing multiple tag sequences for a method
call sequence. Second, the model should be able to incorporate
both the textual semantics of tokens and the sequential information
of method calls in the learning. Thus, we integrate LSTM (Long
Short-Term Memory) [ 18] in the model, which is commonly used
for capturing token semantics and sequential contexts.
Figure 4shows the detailed architecture of our sequence labeling
model, which takes a token sequence [C>:4= 1,C>:4= 2,. . . ,C > : 4 = #]
and a part sequence [?0AC 1,? 0 AC 2,. . . ,? 0 A C #]as input and outputs a
ï¿¿xed number ( D) of tag sequences. Here, Dindicates the depth of the
model. Note that some or even all of the Dproduced tag sequences
may include only the tag )=>=, indicating that no Abs-RAR pairs
are involved. Each token C>:4= 8and its corresponding part ?0AC 8
are ï¿¿rst projected into their vector representations 4<1 C>:(C>:4= 8)
and4<1 ?0AC(?0AC 8)respectively through an embedding layer. Then
the two vectors are concatenated into an enriched token vector
Ã†48=4<1 C>:(C>:4= 8) 4<1 ?0AC(?0AC 8). After processing all the
tokens, their enriched vectors, i.e.,[Ã†41,Ã†42,. . . , Ã†4#], are fed into a Bi-
LSTM layer to obtain the corresponding input vectors [Ã†81,Ã†82,. . . , Ã†8#]
for the iterative grid labeling block. The iterative grid labeling block
includes the following three layers:
â€¢Bi-LSTM Layer. This layer takes the input vectors and outputs
hidden states [Ã†âŒ˜1,Ã†âŒ˜2,. . . , Ã†âŒ˜#].
â€¢Fully-Connected Tag Classiï¿¿cation Layer. This layer predicts a
probability distribution ?8of the four tags ( i.e.,)A4B,)02@,)A4;,
990ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Chong Wang, Yiling Lou, Xin Peng, Jianan Liu, and Baihan Zou
)=>=) for each hidden state Ã†âŒ˜8. Based on ?8, a tag sequence
[C061,C0 6 2,. . . ,C 0 6 #]can be generated by selecting a tag C068
that has the highest probability in ?8.
â€¢Tag Embedding Layer. This layer converts the tag sequence into
the corresponding vector sequence [Ã†C1,Ã†C2,. . . , Ã†C#], where Ã†C8is
the vector representation of C068.
After each block iteration, current hidden states [Ã†âŒ˜1,Ã†âŒ˜2,. . . , Ã†âŒ˜#]
and tag vectors [Ã†C1,Ã†C2,. . . , Ã†C#]are added to produce new input vec-
tors, i.e.,[Ã†âŒ˜1+Ã†C1,Ã†âŒ˜2+Ã†C2,. . . , Ã†âŒ˜#+Ã†C#], for the next iteration of the
block. The iterative process continues until Dtag sequences are
generated for the current token sequence.
Token Embeddings Pre-training. To alleviate the parameter
overï¿¿tting problem in training and the out-of-vocabulary problem
in prediction, Mï¿¿ROK leverages token embeddings pre-trained on
the entire code corpus to initialize the token embedding layer of
the model. The token embeddings are pre-trained on all the token
sequences extracted from the code corpus using Word2Vec [ 34].
The token embeddings can help capture the semantic associations
between tokens by making tokens that frequently appear in simi-
lar contexts as close as possible in the space. For example, â€œlockâ€,
â€œsemaphoreâ€, â€œacquireâ€, and â€œreleaseâ€ are close in the space and the
embeddings can help the sequence labeling model to capture the
associations among the resources ( e.g., â€œlockâ€, â€œsemaphoreâ€) and
acquisition/release operations ( e.g.,â€œacquireâ€, â€œreleaseâ€). After ini-
tialized by the pre-trained token embeddings, the parameters of the
token embedding layer are frozen during model training.
Model Training. According to the grid labeling architecture of
the model, each training sample, which represents a method call
sequence, needs to have exactly D(the depth of the model) tag
sequences. Therefore, Mï¿¿ROK randomly selects Dtag sequences for
the training sample if it has no less than Dtag sequences; otherwise,
Mï¿¿ROK generates some tag sequences that include only the tag
)=>=for the training sample to reach the number D.
During training, the model parameters are continuously opti-
mized with the objective of minimizing the loss. Mï¿¿ROK deï¿¿nes the
loss function as the cross-entropy loss between the predicted tag
sequences and the labeled ones. For each training sample, the loss
is the sum of the loss in the Diterations of the grid labeling block.
In the 8-th iteration, the model predicts a tag sequence ?A43 with
a probability sequence ?A>1 . Here, the 9-th element in ?A>1 is the
predicted probability of the 9-th tag in ?A43 . Then Mï¿¿ROK takes
the corresponding tag sequence 6>;3 (i.e.,the8-th tag sequence
of the training sample) and calculates the cross-entropy loss Lâ‡ â‡¢
between ?A43 and6>;3 based on ?A>1 .
However, the cross-entropy loss is not so sensitive to the dif-
ference between the acquisition operation ( i.e.,02@) and release
operation ( i.e.,A4;), as they are close in the token embedding space
and have the same token part labels ( i.e., MD ). Therefore, we add a
penalty term to the cross-entropy loss to better reï¿¿ect the diï¿¿erence
between the acquisition operation and the release operation of the
same Abs-RAR pair. Given a predicted tag sequence ?A43 and the
corresponding tag sequence in the training sample 6>;3 ,Mï¿¿ROK
obtains the hidden states of the two tokens in the training sample
corresponding to the 02@ andA4;tags in 6>;3 . Based on the two
hidden states ( i.e., Ã†âŒ˜02@and Ã†âŒ˜A4;) we use Equation 1to calculatetheir cosine similarity and use it as the penalty term.
P=cos(Ã†âŒ˜02@, Ã†âŒ˜A4;) (1)
The ï¿¿nal loss Lis calculated as Equation 2, where Lâ‡ â‡¢
8and P8
are the cross-entropy loss and penalty term in the 8-th block itera-
tion. Based on the loss function, Mï¿¿ROK trains the model using a
stochastic optimizer such as Adam [ 23].
L=â‡¡â€™
8=1(Lâ‡ â‡¢
8+P8) (2)
Before training, Mï¿¿ROK splits the training samples into a training
set and a validation set by 9:1. The training set is used for model
training and the validation set is used to validate the performance
of the model. When the loss on the validation set ( i.e.,validation
loss) does not decrease in three consecutive epochs, Mï¿¿ROK stops
the training process and chooses the version of the model having
the lowest loss as the trained model.
Model Prediction and Abs-RAR Pair Extraction. Mï¿¿ROK use
the trained model to predict tag sequences for each prediction
sample and extracts new Abs-RAR pairs from the predicted tag
sequences. Given a prediction sample (,Mï¿¿ROK takes its token
sequence and part sequence as input and uses the trained model
to predict Dtag sequences for it. For each predicted tag sequence
?A43 ,Mï¿¿ROK tags the tokens in (according to the correspond-
ing tags in ?A43 . Then Mï¿¿ROK tries to extract an Abs-RAR pair
hA4B,02@/A4;iwhere A4B,02@, and A4;are continuous tokens in (
that respectively have the corresponding tags ( i.e.,)A4B,)02@,)A4;).
If such an Abs-RAR pair is extracted and 02@ andA4;are not the
same, Mï¿¿ROK treats it as a candidate Abs-RAR pair and calculates
its conï¿¿dence by averaging the probabilities of all the tags in ?A43 .
After all the prediction samples are processed, Mï¿¿ROK merges iden-
tical candidate Abs-RAR pairs and averages their conï¿¿dences as
the ï¿¿nal conï¿¿dence. To ensure the quality of new Abs-RAR pairs,
we only include the candidate Abs-RAR pairs whose frequency is
more than three and conï¿¿dence is higher than 0.8 to extend the
Abs-RAR pair pool.
3.3 RAR Pair Instantiation
The Abs-RAR pairs convey general resource-operation knowledge
summarized from a large code corpus, and they could further be
instantiated into concrete RAR pairs ( i.e.,the pair of API methods)
that are deï¿¿ned in diï¿¿erent libraries. These concrete RAR pairs
could be further incorporated by existing resource leak detection
techniques. Diï¿¿erent from existing work ( e.g.,SinkFinder) mining
RAR pairs from the project code that uses the APIs in RAR pairs, our
RAR pairs are instantiated from the library code that directly deï¿¿nes
the APIs in RAR pairs. Therefore, our approach could identify a
comprehensive pool of RAR pairs, including those pairs that are
infrequently or unpairwisely used in the project code.
In particular, for all API methods deï¿¿ned in a given library,
Mï¿¿ROK regards any two API methods 2. < 1and2. < 2(deï¿¿ned in a
same class 2) as an instantiation of the Abs-RAR pair hA4B,02@/A4;i,
if2. < 1and2. < 2match A4B. 02@ andA4B. A4; respectively. The match-
ing rules for method calls and resource operations are the same
as those in Section 3.2.1. For example, for the two API methods
991Mining Resource-Operation Knowledge to Support Resource Leak Detection ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
acquire() andrelease() which are both deï¿¿ned in same class Global-
Lock of the library xmlbeans , we consider them as an instantiated
RAR pair of the Abs-RAR pair hlock, acquire / release i.
4 IMPLEMENTATION
The implementation of Mï¿¿ROK includes the following important
preparations and decisions.
Seed Abs-RAR Pair Collection . The seed Abs-RAR pairs used in
our implementation are extracted from the API method pairs for
resource acquisition and release used in Wu et al. â€™s work [ 49]. We
manually extract 26 seed Abs-RAR pairs from the signatures of the
API method pairs. For example, from the API method pair < Wiï¿¿-
Manager.Lock.acquire() ,Wiï¿¿Manager.Lock.release() > we extract an
Abs-RAR pair hlock, acquire / release i. The full list of the 26 seed
Abs-RAR pairs can be found in our replication package [ 6].
Dataset Construction . (1) The code corpus used for Abs-RAR
pair mining mainly consists of two sources. First, we obtain crawl
the open-source Java projects on GitHub that were created dur-
ing the period of 2010 to 2016 and have more than 50 stars. These
projects have about 4M methods. Second, we collect the data in
CodeSearchNet [ 19], which is a collection of datasets and bench-
marks for code retrieval. It contains about 500K Java methods. We
merge the two data sources and ï¿¿lter out duplicate methods. We
further ï¿¿lter out the methods that contain less than three method
calls, as they are unlikely to include RAR pairs. We also ï¿¿lter out the
methods that contain more than 50 method calls, since the training
of the sequence labeling model will consume a lot of computational
resources when processing too long call sequences. As a result, the
ï¿¿nal code corpus contains 1,454,224 Java methods. (2) The libraries
used for RAR pair instantiation include top 20,000 Maven libraries
in the Libraries.io dataset [ 4] according to their stars on GitHub.
Maximum Number of Iterations in Abs-RAR Pair Mining .W e
set the maximum number of iterations to 20 based on our observa-
tion that the iterative mining process usually reaches convergence
in around 20 iterations (see Section 5.5).
Model Construction . The sequence labeling model is implemented
using PyTorch 1.9.1 [ 5], which is one of the most popular machine
learning frameworks. The hyper-parameters of the model are as
follows. The sizes of token embeddings and part embeddings in the
embedding layer are 100 and 30 respectively. The hidden sizes of
the two Bi-LSTM layers are both 64. The tag classiï¿¿cation layer
consists of two layers of fully-collected networks whose hidden
size is 128. The settings of these hyper-parameters are based on
common practice in related work and the considerations of machine
conï¿¿guration and training overhead. The depth of the model ( i.e.,
D) is set to 2.
Model Training . We add a dropout of 0.5, a commonly used tech-
nique for regularization, between the second Bi-LSTM layer and
the tag classiï¿¿cation layer. The learning rate is set to 0.001 and the
training batch size is set to 64. The maximum number of training
epochs is set to 100, which is rarely reached due to early stopping.
5 EVALUATION
We apply Mï¿¿ROK to ï¿¿rst mine Abs-RAR pairs from a large code
corpus of 1,454,224 Java methods and then to instantiate the Abs-
RAR pairs into concrete RAR pairs for 20,000 Maven libraries. InTable 1: Some Examples of the Mined Abs-RAR Pairs
Domain Abs-RAR Pairs
Concurrency hmutex, lock / unlock i,hsemaphore, acquire / release i
Database hdatabase, connect / disconnect i,hdb, connect / disconnect i
File hxml, open / close i,hzip, <init> / close i
I/O hstream, <init> / close i,hreader, <init> / close i
Web/Network hsocket, connect / close i,hclient, create / destroy i
Device hcamera, start / stop i,hdevice, open / close i
Service hmanager, activate / deactivate i,hcompactor, initialize / close i
this section, we ï¿¿rst evaluate the mining eï¿¿ectiveness of Mï¿¿ROK by
investigating the quality of its mined Abs-RAR pairs (RQ1) and its
instantiated RAR pairs (RQ2); we then evaluate the practical usage
of its RAR pairs by investigating whether they could boost resource
leak detection in online code examples (RQ3.a) and open-source
projects (RQ3.b); we also perform an ablation study to investigate
the contribution of both mining strategies (RQ4).
â€¢RQ1. (Eï¿¿ectiveness of Abs-RAR Pair Mining) : How
many Abs-RAR pairs are mined by Mï¿¿ROK ? How many
of them are valid?
â€¢RQ2. (Eï¿¿ectiveness of RAR Pair Instantiation) : How
many concrete RAR pairs are instantiated from the mined
Abs-RAR pairs? How many of them are valid?
â€¢RQ3. (Practical Usage for Resource Leak Detection):
â€“RQ3.a (Resource Leaks in Online Code Examples) :
Can our mined RAR pairs help detect resource leaks in
online code examples?
â€“RQ3.b (Resource Leaks in Open-source Projects) :
Can our mined RAR pairs help detect resource leaks in
open-source project?
â€¢RQ4. (Impact of Each Mining Strategy) : What is the con-
tribution of the each mining strategy in Mï¿¿ROK ?
5.1 RQ1: Abs-RAR Pair Mining
In this RQ, we analyze the Abs-RAR pairs mined by Mï¿¿ROK .
5.1.1 Protocol. We manually assess the quality of the Abs-RAR
pairs mined by Mï¿¿ROK . In particular, we invite two developers who
have more than four years Java development experience to inde-
pendently inspect the validity of all the mined Abs-RAR pairs. For
each Abs-RAR pair, they are asked to annotate whether it is valid,
i.e., representing a valid pair of acquisition/release operations on a
resource. To make a proper decision, they can search and consult
external sources for help, e.g., reading various technical documents
on Google or search GitHub projects using speciï¿¿c keywords to
ï¿¿nd code snippets that include the Abs-RAR pair. If their annota-
tions for an Abs-RAR pair are inconsistent, a third annotator is
assigned to give an additional annotation to resolve the conï¿¿ict
with a majority-win strategy. The Cohenâ€™s Kappa agreement [ 33]
of the two annotators is 0.812 in our manual assessing, indicating a
substantial agreement.
5.1.2 Results. Based on the 26 seed Abs-RAR pairs, Mï¿¿ROK mines
1,313 new Abs-RAR pairs from the code corpus, among which 1,171
(89.2%) are conï¿¿rmed to be valid. These new Abs-RAR pairs involve
982 resources (964 of them are not included in the seed pairs) and
43 operation pairs (30 of them are not included in the seed pairs).
992ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Chong Wang, Yiling Lou, Xin Peng, Jianan Liu, and Baihan Zou
Table 1shows some examples of the valid Abs-RAR pairs. The
involved resources scatter in diï¿¿erent domains such as concurrency,
database, ï¿¿le, I/O, web/network, device, and service. These Abs-
RAR pairs reï¿¿ect the following capabilities of Mï¿¿ROK in identifying
new Abs-RAR pairs based on existing ones.
1) Conceptual Specialization of Resources . New Abs-RAR pairs
perform the same acquisition/release operations on conceptually
specialized resources. For example, hwake lock, acquire / release i
has the same acquisition/release operations with hlock, acquire / re-
lease iand â€œwake lockâ€ is the conceptual specialization of â€œlockâ€.
This strategy is directly used by the rule-based Abs-RAR pair ex-
pansion (see Section 3.2.1).
2) Conceptually Relevant Resources . New Abs-RAR pairs per-
form the same acquisition/release operations on conceptually rele-
vant resources. For example, hsemaphore, acquire / release ihas the
same acquisition/release operations with hlock, acquire / release i
and â€œsemaphoreâ€ is a conceptually relevant concept of â€œlockâ€.
3) New Acquisition and Release Operations on Existing Re-
sources . New Abs-RAR pairs perform diï¿¿erent acquisition/release
operations on existing resources. For example, hmanager, activate /
deactivate ihas the same resource with hmanager, open / close iand
involves new acquisition/release operations â€œactivateâ€/â€œdeactivateâ€
instead of â€œopenâ€/â€œcloseâ€.
4) New Combinations of Existing Resources and Operations .
New Abs-RAR pairs combine existing resources and acquisition/re-
lease operations in diï¿¿erent ways. For example, hdatabase, con-
nect / disconnect icombines the resource â€œdatabaseâ€ and the ac-
quisition/release operations â€œconnectâ€/â€œdisconnectâ€ which exist
in existing Abs-RAR pairs such as hdatabase, open / close iand
hconnection, connect / disconnect. i
5) Completely New Resources and Operations . New Abs-RAR
pairs involve completely new resources and acquisition/release op-
erations. For example, hcompactor, initialize / close iandhclient, cre-
ate / destroy iboth involve unseen resources and acquisition/release
operations.
In summary, Mï¿¿ROK can mine a wide variety of Abs-RAR pairs
that involve new resources and/or acquisition/release operations.
The results reï¿¿ect the capabilities of Mï¿¿ROK in learning the latent
relationships between resources and acquisition/release operations.
We also investigate the invalid Abs-RAR pairs mined by Mï¿¿ROK ,
and ï¿¿nd that most of them are caused by the invalid combinations
of resources and acquisition/release operations. The problem might
be caused by the accumulation of errors during the iterative learn-
ing process, since Mï¿¿ROK adopts a distant supervision method to
train the sequence labeling model. For example, if an invalid Abs-
RAR pair (e.g., hstream, mark / reset i) is mined, it might lead to
more invalid Abs-RAR pairs with other I/O related resources ( e.g.,
â€œbuï¿¿erâ€) in subsequent iterations (e.g., hbuï¿¿er, mark / reset i). To
address this issue, future work could further introduce perturbation
to mitigate the negative aï¿¿ects in each iteration.
Summary: Mï¿¿ROK is highly eï¿¿ective in mining Abs-RAR
pairs by mining 1,313 new Abs-RAR pairs with 89.2% valid rate.
The mined Abs-RAR pairs cover a wide spectrum of unseen
resources and/or acquisition/release operations from diï¿¿erent
domains.5.2 RQ2: RAR Pair Instantiation
In this RQ, we analyze the concrete RAR pairs instantiated by
Mï¿¿ROK for 20,000 Maven libraries.
5.2.1 Protocol. We introduce the RAR pair mining baseline and
our manual assessment used in this RQ.
RAR pair mining baseline. In this RQ, we include the state-
of-the-art RAR pair mining technique SinkFinder as baseline by
applying both SinkFinder and Mï¿¿ROK on the 20,000 Maven libraries
to generate RAR pairs. SinkFinder ï¿¿rst mines frequent API pairs
from the given code corpus, based on which it further trains API
embeddings to infer reliable API pairs and learns to classify RAR
pairs. For a fair comparison, we re-implement SinkFinder for Java
and apply it to the same code corpus as Mï¿¿ROK .
More speciï¿¿cally, we ï¿¿rst mine frequent API pairs (associated
with the 20,000 Maven libraries) from the code corpus based on
the control ï¿¿ows and data dependencies, following the original
mining process of SinkFinder. This results in a total of 50,397
frequent API pairs are obtained as potential RAR pairs, such as
<org.slf4j.Logger.info ,org.slf4j.Logger.error > (occuring 9,971 times).
Subsequently, we utilize random walks on control-ï¿¿ow graphs to
extract API sequences and apply Word2Vec [ 34] and fastText [ 9]
to train API embeddings, thereby aligning with the approach used
in SinkFinder. Building upon the embeddings, a set of seed pairs
is employed to iteratively infer reliable positive and negative API
pairs, and a binary classiï¿¿cation model is trained to identify RAR
pairs from the 50,397 frequent API pairs. The seed RAR pairs for
initializing the inference process are obtained by matching the
50,397 frequent API pairs with the 26 seed Abs-RAR pairs, in the
same matching method presented in Section 3.3. Only one speciï¿¿c
seed pair, namely < ODatabaseDocumentTx.open() ,ODatabaseDocu-
mentTx.close() > from the orientdb-core library, emerges from this
matching process. Itâ€™s worth noting that having only one seed does
not does not pose a threat to the validity of the re-implementation,
as SinkFinder is originally crafted to address scenarios where just
one seed is available.
Manual Assessment. We manually evaluate the quality of the
instantiated RAR pairs. Given the large number of concrete RAR
pairs (i.e., Mï¿¿ROK instantiates 6,314 concrete RAR pairs in total),
we ï¿¿rst use a statistical sampling method [ 41] to randomly sample
372 concrete RAR pairs, which ensures the estimated precision is
in 0.05 error margin at 95% conï¿¿dence level. Then we invite two
developers with more than four years Java development experience
to independently inspect the 372 sampled pairs. To make a proper
decision, the annotators can search various resources such as library
documentation and source code on GitHub to conï¿¿rm whether the
API method pairs are actually for resource acquisition and release.
If their annotations for an instantiated RAR pair are inconsistent,
a third annotator is assigned to give an additional annotation to
resolve the conï¿¿ict by a majority-win strategy. The Cohenâ€™s Kappa
agreement [ 33] of the two annotators is 0.917, indicating substantial
agreement.
5.2.2 Results. In total, Mï¿¿ROK instantiates 1,197 valid Abs-RAR
pairs into 6,314 RAR pairs from 2,261 libraries. Among the 372 sam-
pled instantiated RAR pairs, 93.3% (347) are conï¿¿rmed to be valid. In
993Mining Resource-Operation Knowledge to Support Resource Leak Detection ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
contrast, the baseline SinkFinder demonstrates an inability to iden-
tify any RAR pair when tested on the same extensive code corpus as
Mï¿¿ROK . Based on the provided seed, SinkFinder infers only one reli-
able positive API pair < ODatabaseDocumentTx.create() ,ODatabase-
DocumentTx.close() >, causing it fails to perform the iterative reliable
pair inference and the subsequent API pair classiï¿¿cation. The main
reason is that SinkFinder relies on a set of closely-related APIs
to train high-quality API embeddings; however, when the code
corpus is large, there are too many APIs from diï¿¿erent libraries,
whose relevance is rather loose, resulting in much less eï¿¿ective
API embeddings. Our experimental results show that SinkFinder is
not applicable when mining RAR pairs from a large code corpus of
diï¿¿erent libraries.
Summary: Mï¿¿ROK instantiates 1,197 valid Abs-RAR pairs
into 6,314 RAR pairs in 2,261 libraries, and 93.3% of them are
valid.
5.3 RQ3.a: Resource Leaks in Online Code
Examples
As reported by existing work [ 12,54], a non-negligible (e.g., 30%)
portion of online code examples (e.g., code snippets in the accepted
answers of Stack Overï¿¿ow posts) may contain defects, such as
security issues or resource leak issues, which would further be
widely reused by developers in other projects. Therefore, in this
RQ, we incorporate our mined Abs-RAR pairs into a light resource
leak detection analysis approach to detect resource leaks in online
code examples from Stack Overï¿¿ow posts.
5.3.1 Protocol. We introduce the resource leak detection analysis
baseline, the online code example dataset, and evaluation procedure
used in this RQ.
Benchmark. We construct a online code example benchmark
which contains 46,389 Java code snippets in Stack Overï¿¿ow. In
particular, we ï¿¿rst include all the posts tagged with â€œ<java>â€ from
the Stack Overï¿¿ow dump [ 1]; then we extract the code snippets
surrounded with the tag pair â€œ<pre><code>â€ and â€œ</code></pre>â€
from their accepted answers; lastly, we ï¿¿lter out those low-quality
code examples with syntactic errors. In this way, we ï¿¿nally collect
a benchmark of 46,389 online code examples.
Resource leak analysis baseline. Existing resource leak analysis
tools mainly work at byte-code level and are only applicable for a
complete compilable project. However, online code examples are
often short code snippets without a complete project-level context,
and thus existing resource leak analysis tools cannot be directly
applied to detect resource leaks in online code examples. Therefore,
in this RQ, we ï¿¿rst implement a lightweight resource leak analysis
approach, which takes Abs-RAR pairs as input and parses code
snippets to detect resource leaks at source code level. In particular,
for a given code snippet, the lightweight detector ï¿¿rst extracts a
method call sequence (in the same way as Section 3.1and trans-
forms all method calls into the form [ O VB NP REST ] in the same
way as Section 3.2.1; then for each Abs-RAR pair hA4B,02@/A4;i, the
method sequence (could be considered as containing a resource
leak, if (1) a method call >. < 1in(matches A4B. 02@ , and (2) these
is no another method call >. < 2in(that appears after >. < 1and
matches A4B. A4; . We further compare the resource leaks reported by
(a) Resource Leak for Abs-RAR Pairhzip, <init> / closei
(b) Resource Leak for Abs-RAR Pairhsocket, <init> / closeiFigure 5: Examples of Valid Resource Leaksthe lightweight detector when it is incorporated with the 26 basicseed Abs-RAR pairs or with our mined 1,197 valid Abs-RAR pairs.Evaluation procedure.We manually evaluate the reported re-source leaks in online code examples. In particular, we ï¿¿rst ran-domly select 256 cases out of all the 761 detected resource leaks,and the sample size 256 is calculated based on the statistical sam-pling method [41], which ensures the estimated precision is in 0.05error margin at 95% conï¿¿dence level. Two developers who havemore than four yearsâ€™ Java development experience independentlyexamine the 256 resource leaks and annotate whether the they aretrue or not. The annotators could search various technical docu-ments and source code on Google and GitHub to understand thegiven code examples as well as the reported resource leak defects.If their annotations for a case are inconsistent, a third annotatoris assigned to give an additional annotation to resolve the conï¿¿ictby a majority-win strategy. The Cohenâ€™s Kappa agreement [33] ofthe two annotators is 0.929 in our evaluation procedure, indicatingsubstantial agreement.5.3.2 Results.The detector reports 4.5â‡¥more resource leaks withour mined Abs-RAR pairs compared to with the basic seed Abs-RAR pairs. In particular, the detector with our mined Abs-RARpairs reports 761 resource leaks, while only reports 168 resourceleaks with the basic seed Abs-RAR pairs. Among the 256 sampledresource leaks reported by the detector with our Abs-RAR pairs ,73.4% (188) are manually checked as true.Figure5shows two examples of the valid resource leak defects.In the two examples, the resource â€œzipâ€ and â€œsocketâ€ are acquired bythe constructors but not released using the â€œcloseâ€ operations. Todetect these resource leak defects, we can analyze the resource oper-ations in the code at the conceptual level and do not require knowl-edge about the corresponding APIs (e.g.,â€œZipFileâ€ and â€œSocketâ€) orlibraries.We further analyze the incorrect resource leak defects that arereported by our approach and ï¿¿nd that most of them are causedby the inherent limitations in source-code-level analysis (such as
994ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Chong Wang, Yiling Lou, Xin Peng, Jianan Liu, and Baihan Zou
the ambiguous identiï¿¿ers in code snippets) or the lack of library-
speciï¿¿c knowledge. In fact, it is hard to address these limitations
for online code examples, as they are often source code snippets
without global project contexts.
Summary: With our Abs-RAR pairs, even a simplistic re-
source leak analysis approach could identify 761 resource leaks
in the 46,389 online code examples, and 73.4% of them are man-
ually checked as true resource leaks. The detector reports 4.5X
more resource leaks with our Abs-RAR pairs compared to with
the basic seed Abs-RAR pairs.
5.4 RQ3.b: Resource Leaks in Open-source
Projects
In this RQ, we incorporate our generated RAR pairs with existing
resource leak detection tool to investigate whether it could detect
more resource leaks in open-source projects.
5.4.1 Protocol. We introduce the resource leak detection analy-
sis baseline, the open-source project benchmark, and evaluation
procedure used in this RQ.
Benchmark. We construct a benchmark of 10 open-source projects
from GitHub. In particular, we ï¿¿rst select 5,000 Java project repos-
itories with more than 20 stars from Github, then ï¿¿lter out the
projects that cannot be successfully compiled with â€œpom.xmlâ€ or do
not contain any relevant API method of our RAR pairs. To ensure
the diversity of projects, we then randomly select 10 projects from
the remaining projects. The detailed information of our projects
could be found in our replication package [ 6].
Resource leak analysis baseline. In this RQ, we select the state-
of-the-art resource leak detection tool FindBugs [ 2] as the analysis
baseline, as it is a representative static analysis tool that could
support general resource leak detection and has been widely used
in previous work [ 44]. In particular, the original FindBugs includes a
predeï¿¿ned RAR pair pool which contains stream related RAR pairs.
We enhance the original FindBugs by further extending its original
RAR pool with our 6,314 newly generated RAR pairs. We denote the
enhanced FindBugs as FindBugs*. We apply the original FindBugs
and the enhanced FindBugs* to scan projects in the benchmark,
respectively.
Evaluation procedure. We manually check the validity of all the
resource leaks reported by the original FindBugs and FindBugs*. In
particular, two developers with more than four years Java devel-
opment experience independently examine the reported resource
leaks. A third annotator is assigned to resolve the conï¿¿ict cases by
a majority-win strategy.
5.4.2 Results. The original FindBugs reports 9 resource leaks with
4 of them being true resource leaks (i.e., 44.4%); with our RAR
pairs, FindBugs* reports 15 resource leaks with 7 of them being
true resource leaks (i.e., 46.7%). We further report 3 newly-detected
unknown defects to the developers. By the submission time, one of
them have been conï¿¿rmed by the developers. Figure 6shows the
conï¿¿rmed defect1that is newly detected based on our unique RAR
pair < NetClient.connect() ,NetClient.close() > of library vertx-core .
1https://github.com/folio-org/okapi/pull/1303
Figure 6: The Conï¿¿rmed Resource Leak Defect
As shown in the ï¿¿gure, the resource leak occurs, as the NetClient
resource cis acquired (in line c.connect(...) ) but without subsequently
calling the release method c.close(...) . The original FindBugs fails
to detect this resource leak, as its initial RAR pair pool does not
contain the RAR pair < NetClient.connect() ,NetClient.close() > and it
is unaware of NetClient being a resource object.
Summary: Our new RAR pairs help existing resource leak
detection tool FindBugs report more unknown defects without
reducing its precision. Our results indicate that our mined
RAR pairs could be incorporated into existing resource leak
detection to enable more powerful resource leak detection.
5.5 RQ4: Impact of Each Mining Strategy
In this RQ, we investigate the contribution of each mining strategy
(i.e., rule-based Abs-RAR pair expansion and learning-based Abs-
RAR pair identiï¿¿cation).
5.5.1 Protocol. We compare the eï¿¿ectiveness of the following vari-
ants of Mï¿¿ROK to study the contribution of each mining strategy:
(1)Mï¿¿ROK -L, which removes learning-based Abs-RAR pair identiï¿¿-
cation and only includes rule-based Abs-RAR pair expansion; and
(2)Mï¿¿ROK -R, which removes rule-based Abs-RAR pair expansion
and only includes learning-based Abs-RAR pair identiï¿¿cation.
5.5.2 Results. The results of the impact of the two mining strate-
gies are shown in Figure 7, which provides the numbers of the mined
Abs-RAR pairs in diï¿¿erent iterations. We could observe that Mï¿¿ROK
mines much more Abs-RAR pairs with two strategies together. With
the learning-based Abs-RAR pair identiï¿¿cation removed, Mï¿¿ROK -L
only mines a few Abs-RAR pairs in the ï¿¿rst iteration and cannot
mine more abstract Abs-RAR pairs in the subsequent iterations.
With the rule-based Abs-RAR pair expansion removed, Mï¿¿ROK -R
only mines 38.0% fewer Abs-RAR pairs than the complete Mï¿¿ROK .
These results suggest that both the two strategies are important for
Mï¿¿ROK , and both strategies are complementary in their capabilities
of Abs-RAR pair mining. In particular, rule-based Abs-RAR pair
expansion can derive high-quality Abs-RAR pairs from existing
ones based on simple rules and plays an important role in early
iterations, while learning-based Abs-RAR pair identiï¿¿cation can
continuously identify Abs-RAR pairs in a broader scope.
995Mining Resource-Operation Knowledge to Support Resource Leak Detection ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
Figure 7: Numbers of Mined Abs-RAR Pairs with Diï¿¿erent
Mï¿¿ROK Variants
Summary: Both the rule-based Abs-RAR pair expansion and
the learning-based Abs-RAR pair identiï¿¿cation are important
forMï¿¿ROK . These two strategies are complementary in their
capabilities of Abs-RAR pair mining.
6 THREATS TO VALIDITY
The threats to the internal validity of our studies lie in the random-
ness of data sampling and the subjectiveness in data annotation.
To mitigate these threats, we follow commonly-used data sam-
pling strategy by controlling the estimated precision within 0.05
error margin at 95% conï¿¿dence level, and multiple annotators are
involved with high agreement coeï¿¿cients. Thee threats to the ex-
ternal validity lies in the benchmarks used by our work, which
cannot guarantee the generality of our ï¿¿ndings. To minimize such
threats, we leverage a large scale of code corpus and libraries and
include two resource leak detection scenarios for evaluation. We
believe it is interesting future work to extend Mï¿¿ROK to other pro-
gramming languages and incorporating Mï¿¿ROK with more resource
leak analysis tools.
7 CONCLUSIONS AND FUTURE WORK
In this work, we propose Mï¿¿ROK , a novel mining approach which
represents resource-operation knowledge as abstract resource ac-
quisition/release operation pairs (Abs-RAR pairs), and mine such
Abs-RAR pairs from a large code corpus. Given a large code cor-
pus, Mï¿¿ROK ï¿¿rst mines Abs-RAR pairs with novel rule-based pair
expansion and learning-based pair identiï¿¿cation strategies, and
then instantiates these Abs-RAR pairs into concrete RAR pairs. We
implement Mï¿¿ROK and apply it to mine RAR pairs from a large
code corpus of 1,454,224 Java methods and 20,000 Maven libraries.
We then perform an extensive evaluation to investigate the mining
eï¿¿ectiveness of Mï¿¿ROK and the practical usage of its mined RAR
pairs for supporting resource leak detection. Our results show that
Mï¿¿ROK mines 1,313 new Abs-RAR pairs and instantiates them into
6,314 RAR pairs with a high precision (i.e., 93.3%). In addition, we
feed our mined RAR pairs to existing resource leak analysis ap-
proaches, and help them detect more resource leak bugs in both
online code examples and open-source projects. Our results indi-
cate both the high quality and practical usage of our mined RARpairs. In addition, we further perform an ablation study to show
the contribution of each mining strategy in Mï¿¿ROK .
8 DATA AVAILABILITY
Our replication package is at [ 6].
ACKNOWLEDGMENT
This work was supported by the National Natural Science Founda-
tion of China under Grant 61972098.
REFERENCES
[1]2021. Stack Overï¿¿ow data dump version from March 4, 2021 . Retrieved September
4, 2021 from https://archive.org/download/stackexchange/
[2]2022. FindBugs . Retrieved Augest 5, 2022 from http://ï¿¿ndbugs.sourceforge.net//
[3]2022. javalang . Retrieved August 5, 2022 from https://github.com/c2nes/javalang
[4]2022. Libraries.io . Retrieved August 5, 2022 from https://libraries.io/maven
[5]2022. PyTorch . Retrieved August 5, 2022 from https://pytorch.org/
[6]2022. Replication Package . Retrieved August 5, 2022 from https://mirok-
replication.github.io/
[7]Mithun Acharya, Tao Xie, Jian Pei, and Jun Xu. 2007. Mining API patterns as
partial orders from source code: from usage scenarios to speciï¿¿cations. In Pro-
ceedings of the 6th joint meeting of the European Software Engineering Conference
and the ACM SIGSOFT International Symposium on Foundations of Software Engi-
neering, 2007, Dubrovnik, Croatia, September 3-7, 2007 , Ivica Crnkovic and Antonia
Bertolino (Eds.). ACM, 25â€“34. https://doi.org/10.1145/1287624.1287630
[8]Pan Bian, Bin Liang, Jianjun Huang, Wenchang Shi, Xidong Wang, and Jian Zhang.
2020. SinkFinder: harvesting hundreds of unknown interesting function pairs
with just one seed. In Proceedings of 28th ACM Joint European Software Engineering
Conference and Symposium on the Foundations of Software Engineering, Virtual
Event, USA, November 8-13, 2020 , Prem Devanbu, Myra B. Cohen, and Thomas
Zimmermann (Eds.). ACM, 1101â€“1113. https://doi.org/10.1145/3368089.3409678
[9]Piotr Bojanowski, Edouard Grave, Armand Joulin, and TomÃ¡s Mikolov. 2017.
Enriching Word Vectors with Subword Information. Trans. Assoc. Comput. Lin-
guistics 5 (2017), 135â€“146. https://doi.org/10.1162/tacl_a_00051
[10] Ray-Yaung Chang, Andy Podgurski, and Jiong Yang. 2007. Finding whatâ€™s not
there: a new approach to revealing neglected conditions in software. In Pro-
ceedings of the ACM/SIGSOFT International Symposium on Software Testing and
Analysis, ISSTA 2007, London, UK, July 9-12, 2007 , David S. Rosenblum and Sebas-
tian G. Elbaum (Eds.). ACM, 163â€“173. https://doi.org/10.1145/1273463.1273486
[11] Navid Emamdoost, Qiushi Wu, Kangjie Lu, and Stephen McCamant. 2021. De-
tecting Kernel Memory Leaks in Specialized Modules with Ownership Rea-
soning. In Proceedings of 28th Annual Network and Distributed System Secu-
rity Symposium, NDSS 2021, virtually, February 21-25, 2021 . The Internet So-
ciety. https://www.ndss-symposium.org/ndss-paper/detecting-kernel-memory-
leaks-in-specialized-modules-with-ownership-reasoning/
[12] Felix Fischer, Konstantin BÃ¶ttinger, Huang Xiao, Christian Stransky, Yasemin
Acar, Michael Backes, and Sascha Fahl. 2017. Stack Overï¿¿ow Considered Harmful?
The Impact of Copy&Paste on Android Application Security. In Proceedings of
2017 IEEE Symposium on Security and Privacy, SP 2017, San Jose, CA, USA, May
22-26, 2017 . IEEE Computer Society, 121â€“136. https://doi.org/10.1109/SP.2017.31
[13] Mohammadreza Ghanavati, Diego Costa, Janos Seboek, David Lo, and Artur
Andrzejak. 2020. Memory and resource leak defects and their repairs in Java
projects. Empir. Softw. Eng. 25, 1 (2020), 678â€“718. https://doi.org/10.1007/s10664-
019-09731-8
[14] Xiaodong Gu, Hongyu Zhang, and Sunghun Kim. 2018. Deep code search. In
Proceedings of the 40th International Conference on Software Engineering, ICSE 2018,
Gothenburg, Sweden, May 27 - June 03, 2018 , Michel Chaudron, Ivica Crnkovic,
Marsha Chechik, and Mark Harman (Eds.). ACM, 933â€“944. https://doi.org/10.
1145/3180155.3180167
[15] Xiaodong Gu, Hongyu Zhang, Dongmei Zhang, and Sunghun Kim. 2016. Deep
API learning. In Proceedings of the 24th ACM SIGSOFT International Symposium
on Foundations of Software Engineering, FSE 2016, Seattle, WA, USA, November
13-18, 2016 , Thomas Zimmermann, Jane Cleland-Huang, and Zhendong Su (Eds.).
ACM, 631â€“642. https://doi.org/10.1145/2950290.2950334
[16] Chaorong Guo, Jian Zhang, Jun Yan, Zhiqiang Zhang, and Yanli Zhang. 2013.
Characterizing and detecting resource leaks in Android applications. In Pro-
ceedings of 2013 28th IEEE/ACM International Conference on Automated Soft-
ware Engineering, ASE 2013, Silicon Valley, CA, USA, November 11-15, 2013 ,
Ewen Denney, Tevï¿¿k Bultan, and Andreas Zeller (Eds.). IEEE, 389â€“398. https:
//doi.org/10.1109/ASE.2013.6693097
[17] Samir Gupta, Sana Malik, Lori L. Pollock, and K. Vijay-Shanker. 2013. Part-of-
speech tagging of program identiï¿¿ers for improved text-based software engi-
neering tools. In Proceedings of IEEE 21st International Conference on Program
996ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA Chong Wang, Yiling Lou, Xin Peng, Jianan Liu, and Baihan Zou
Comprehension, ICPC 2013, San Francisco, CA, USA, 20-21 May, 2013 . IEEE Com-
puter Society, 3â€“12. https://doi.org/10.1109/ICPC.2013.6613828
[18] Sepp Hochreiter and JÃ¼rgen Schmidhuber. 1997. Long Short-Term Memory.
Neural Comput. 9, 8 (1997), 1735â€“1780. https://doi.org/10.1162/neco.1997.9.8.1735
[19] Hamel Husain, Ho-Hsiang Wu, Tiferet Gazit, Miltiadis Allamanis, and Marc
Brockschmidt. 2019. CodeSearchNet Challenge: Evaluating the State of Semantic
Code Search. CoRR abs/1909.09436 (2019). arXiv: 1909.09436 http://arxiv.org/abs/
1909.09436
[20] Dan Jurafsky. 2000. Speech & language processing . Pearson Education India.
[21] Martin Kellogg, Narges Shadab, Manu Sridharan, and Michael D. Ernst. 2021.
Lightweight and modular resource leak veriï¿¿cation. In Proceedings of 29th ACM
Joint European Software Engineering Conference and Symposium on the Foun-
dations of Software Engineering, Athens, Greece, August 23-28, 2021 , Diomidis
Spinellis, Georgios Gousios, Marsha Chechik, and Massimiliano Di Penta (Eds.).
ACM, 181â€“192. https://doi.org/10.1145/3468264.3468576
[22] Martin Kellogg, Narges Shadab, Manu Sridharan, and Michael D. Ernst. 2021.
Lightweight and modular resource leak veriï¿¿cation. In Proceedings of 29th ACM
Joint European Software Engineering Conference and Symposium on the Foun-
dations of Software Engineering, Athens, Greece, August 23-28, 2021 , Diomidis
Spinellis, Georgios Gousios, Marsha Chechik, and Massimiliano Di Penta (Eds.).
ACM, 181â€“192. https://doi.org/10.1145/3468264.3468576
[23] Diederik P. Kingma and Jimmy Ba. 2015. Adam: A Method for Stochastic Optimiza-
tion. In Proceedings of 3rd International Conference on Learning Representations,
ICLR 2015, San Diego, CA, USA, May 7-9, 2015, Conference Track Proceedings ,
Yoshua Bengio and Yann LeCun (Eds.). http://arxiv.org/abs/1412.6980
[24] Keshav Kolluru, Vaibhav Adlakha, Samarth Aggarwal, Mausam, and Soumen
Chakrabarti. 2020. OpenIE6: Iterative Grid Labeling and Coordination Analysis
for Open Information Extraction. In Proceedings of the 2020 Conference on Empiri-
cal Methods in Natural Language Processing, EMNLP 2020, Online, November 16-20,
2020, Bonnie Webber, Trevor Cohn, Yulan He, and Yang Liu (Eds.). Association for
Computational Linguistics, 3748â€“3761. https://doi.org/10.18653/v1/2020.emnlp-
main.306
[25] Sangho Lee, Changhee Jung, and Santosh Pande. 2014. Detecting memory leaks
through introspective dynamic behavior modelling using machine learning. In
Proceedings of 36th International Conference on Software Engineering, ICSE â€™14,
Hyderabad, India - May 31 - June 07, 2014 , Pankaj Jalote, Lionel C. Briand, and
AndrÃ© van der Hoek (Eds.). ACM, 814â€“824. https://doi.org/10.1145/2568225.
2568307
[26] Mengchen Li, Yuanjun Chen, Linzhang Wang, and Guoqing Xu. 2013. Dy-
namically validating static memory leak warnings. In Proceedings of Interna-
tional Symposium on Software Testing and Analysis, ISSTA â€™13, Lugano, Switzer-
land, July 15-20, 2013 , Mauro PezzÃ¨ and Mark Harman (Eds.). ACM, 112â€“122.
https://doi.org/10.1145/2483760.2483778
[27] Wen Li, Haipeng Cai, Yulei Sui, and David Manz. 2020. PCA: memory leak
detection using partial call-path analysis. In Proceedings of 28th ACM Joint
European Software Engineering Conference and Symposium on the Foundations
of Software Engineering, Virtual Event, USA, November 8-13, 2020 , Prem De-
vanbu, Myra B. Cohen, and Thomas Zimmermann (Eds.). ACM, 1621â€“1625.
https://doi.org/10.1145/3368089.3417923
[28] Zhenmin Li and Yuanyuan Zhou. 2005. PR-Miner: automatically extracting
implicit programming rules and detecting violations in large software code. In
Proceedings of the 10th European Software Engineering Conference held jointly
with 13th ACM SIGSOFT International Symposium on Foundations of Software
Engineering, 2005, Lisbon, Portugal, September 5-9, 2005 , Michel Wermelinger and
Harald C. Gall (Eds.). ACM, 306â€“315. https://doi.org/10.1145/1081706.1081755
[29] Yepang Liu, Jue Wang, Lili Wei, Chang Xu, Shing-Chi Cheung, Tianyong Wu, Jun
Yan, and Jian Zhang. 2019. DroidLeaks: a comprehensive database of resource
leaks in Android apps. Empir. Softw. Eng. 24, 6 (2019), 3435â€“3483. https://doi.
org/10.1007/s10664-019-09715-8
[30] Yepang Liu, Chang Xu, Shing-Chi Cheung, and Valerio Terragni. 2016. Un-
derstanding and detecting wake lock misuses for Android applications. In Pro-
ceedings of the 24th ACM SIGSOFT International Symposium on Foundations of
Software Engineering, FSE 2016, Seattle, WA, USA, November 13-18, 2016 , Thomas
Zimmermann, Jane Cleland-Huang, and Zhendong Su (Eds.). ACM, 396â€“409.
https://doi.org/10.1145/2950290.2950297
[31] Yi Liu, Yadong Yan, Chaofeng Sha, Xin Peng, Bihuan Chen, and Chong Wang.
2022. DeepAnna: Deep Learning based Java Annotation Recommendation and
Misuse Detection. In Proceedings of IEEE International Conference on Software
Analysis, Evolution and Reengineering, SANER 2022, Honolulu, HI, USA, March
15-18, 2022 . IEEE, 685â€“696. https://doi.org/10.1109/SANER53432.2022.00086
[32] Jun Ma, Sheng Liu, Shengtao Yue, Xianping Tao, and Jian Lu. 2017. LeakDAF:
An Automated Tool for Detecting Leaked Activities and Fragments of Android
Applications. In Proceedings of 41st IEEE Annual Computer Software and Ap-
plications Conference, COMPSAC 2017, Turin, Italy, July 4-8, 2017. Volume 1 ,
Sorel Reisman, Sheikh Iqbal Ahamed, Claudio Demartini, Thomas M. Conte,
Ling Liu, William R. Claycomb, Motonori Nakamura, Edmundo Tovar, Stelvio
Cimato, Chung-Horng Lung, Hiroki Takakura, Ji-Jiang Yang, Toyokazu Akiyama,Zhiyong Zhang, and Kamrul Hasan (Eds.). IEEE Computer Society, 23â€“32.
https://doi.org/10.1109/COMPSAC.2017.161
[33] Mary L McHugh. 2012. Interrater reliability: the kappa statistic. Biochemia
medica 22, 3 (2012), 276â€“282.
[34] TomÃ¡s Mikolov, Ilya Sutskever, Kai Chen, Gregory S. Corrado, and Jeï¿¿rey Dean.
2013. Distributed Representations of Words and Phrases and their Composi-
tionality. (2013), 3111â€“3119. https://proceedings.neurips.cc/paper/2013/hash/
9aa42b31882ec039965f3c4923ce901b-Abstract.html
[35] Mike Mintz, Steven Bills, Rion Snow, and Daniel Jurafsky. 2009. Distant supervi-
sion for relation extraction without labeled data. In Proceedings of the 47th Annual
Meeting of the Association for Computational Linguistics and the 4th International
Joint Conference on Natural Language Processing of the AFNLP, 2-7 August 2009,
Singapore , Keh-Yih Su, Jian Su, and Janyce Wiebe (Eds.). The Association for
Computer Linguistics, 1003â€“1011. https://aclanthology.org/P09-1113/
[36] Hoan Anh Nguyen, Robert Dyer, Tien N. Nguyen, and Hridesh Rajan. 2014.
Mining preconditions of APIs in large-scale code corpus. In Proceedings of the 22nd
ACM SIGSOFT International Symposium on Foundations of Software Engineering,
(FSE-22), Hong Kong, China, November 16 - 22, 2014 , Shing-Chi Cheung, Alessandro
Orso, and Margaret-Anne D. Storey (Eds.). ACM, 166â€“177. https://doi.org/10.
1145/2635868.2635924
[37] Tung Thanh Nguyen, Hoan Anh Nguyen, Nam H. Pham, Jafar M. Al-Kofahi, and
Tien N. Nguyen. 2009. Graph-based mining of multiple object usage patterns.
InProceedings of the 7th joint meeting of the European Software Engineering
Conference and the ACM SIGSOFT International Symposium on Foundations of
Software Engineering, 2009, Amsterdam, The Netherlands, August 24-28, 2009 , Hans
van Vliet and ValÃ©rie Issarny (Eds.). ACM, 383â€“392. https://doi.org/10.1145/
1595696.1595767
[38] Sebastian Nielebock, Robert HeumÃ¼ller, Kevin Michael Schott, and Frank Ort-
meier. 2021. Guided pattern mining for API misuse detection by change-based
code analysis. Autom. Softw. Eng. 28, 2 (2021), 15. https://doi.org/10.1007/s10515-
021-00294-x
[39] Jacques A. Pienaar and Robert Hundt. 2013. JSWhiz: Static analysis for JavaScript
memory leaks. In Proceedings of the 2013 IEEE/ACM International Symposium on
Code Generation and Optimization, CGO 2013, Shenzhen, China, February 23-27,
2013. IEEE Computer Society, 11:1â€“11:11. https://doi.org/10.1109/CGO.2013.
6495007
[40] Suman Saha, Jean-Pierre Lozi, GaÃ«l Thomas, Julia L. Lawall, and Gilles Muller.
2013. Hector: Detecting Resource-Release Omission Faults in error-handling code
for systems software. In Proceedings of 2013 43rd Annual IEEE/IFIP International
Conference on Dependable Systems and Networks (DSN), Budapest, Hungary, June
24-27, 2013 . IEEE Computer Society, 1â€“12. https://doi.org/10.1109/DSN.2013.
6575307
[41] Ravindra Singh and Naurang Singh Mangat. 2013. Elements of Survey Sampling .
Vol. 15. Springer Science & Business Media.
[42] Yulei Sui, Ding Ye, and Jingling Xue. 2012. Static memory leak detection using
full-sparse value-ï¿¿ow analysis. In Proceedings of International Symposium on
Software Testing and Analysis, ISSTA 2012, Minneapolis, MN, USA, July 15-20,
2012, Mats Per Erik Heimdahl and Zhendong Su (Eds.). ACM, 254â€“264. https:
//doi.org/10.1145/2338965.2336784
[43] Yulei Sui, Ding Ye, and Jingling Xue. 2014. Detecting Memory Leaks Statically
with Full-Sparse Value-Flow Analysis. IEEE Trans. Software Eng. 40, 2 (2014),
107â€“122. https://doi.org/10.1109/TSE.2014.2302311
[44] Emina Torlak and Satish Chandra. 2010. Eï¿¿ective interprocedural resource
leak detection. In Proceedings of the 32nd ACM/IEEE International Conference on
Software Engineering - Volume 1, ICSE 2010, Cape Town, South Africa, 1-8 May
2010, Jeï¿¿ Kramer, Judith Bishop, Premkumar T. Devanbu, and SebastiÃ¡n Uchitel
(Eds.). ACM, 535â€“544. https://doi.org/10.1145/1806799.1806876
[45] Chong Wang, Xin Peng, Mingwei Liu, Zhenchang Xing, Xuefang Bai, Bing Xie,
and Tuo Wang. 2019. A learning-based approach for automatic construction of
domain glossary from source code and documentation. In Proceedings of the ACM
Joint Meeting on European Software Engineering Conference and Symposium on
the Foundations of Software Engineering, ESEC/SIGSOFT FSE 2019, Tallinn, Estonia,
August 26-30, 2019 , Marlon Dumas, Dietmar Pfahl, Sven Apel, and Alessandra
Russo (Eds.). ACM, 97â€“108. https://doi.org/10.1145/3338906.3338963
[46] Chong Wang, Xin Peng, Zhenchang Xing, and Xiujie Meng. 2023. Beyond
Literal Meaning: Uncover and Explain Implicit Knowledge in Code Through
Wikipedia-Based Concept Linking. IEEE Trans. Software Eng. 49, 5 (2023), 3226â€“
3240. https://doi.org/10.1109/TSE.2023.3250029
[47] Chong Wang, Xin Peng, Zhenchang Xing, Yue Zhang, Mingwei Liu, Rong Luo,
and Xiujie Meng. 2023. XCoS: Explainable Code Search Based on Query Scoping
and Knowledge Graph. ACM Trans. Softw. Eng. Methodol. (apr 2023). https:
//doi.org/10.1145/3593800 Just Accepted.
[48] Qian Wu, Guangtai Liang, Qianxiang Wang, Tao Xie, and Hong Mei. 2011.
Iterative mining of resource-releasing speciï¿¿cations. In Proceedings of 26th
IEEE/ACM International Conference on Automated Software Engineering (ASE
2011), Lawrence, KS, USA, November 6-10, 2011 , Perry Alexander, Corina S. Pasare-
anu, and John G. Hosking (Eds.). IEEE Computer Society, 233â€“242. https:
//doi.org/10.1109/ASE.2011.6100058
997Mining Resource-Operation Knowledge to Support Resource Leak Detection ESEC/FSE â€™23, December 3â€“9, 2023, San Francisco, CA, USA
[49] Tianyong Wu, Jierui Liu, Zhenbo Xu, Chaorong Guo, Yanli Zhang, Jun Yan, and
Jian Zhang. 2016. Light-Weight, Inter-Procedural and Callback-Aware Resource
Leak Detection for Android Apps. IEEE Trans. Software Eng. 42, 11 (2016), 1054â€“
1076. https://doi.org/10.1109/TSE.2016.2547385
[50] Dacong Yan, Shengqian Yang, and Atanas Rountev. 2013. Systematic testing for
resource leaks in Android applications. In Proceedings of IEEE 24th International
Symposium on Software Reliability Engineering, ISSRE 2013, Pasadena, CA, USA,
November 4-7, 2013 . IEEE Computer Society, 411â€“420. https://doi.org/10.1109/
ISSRE.2013.6698894
[51] Deheng Ye, Zhenchang Xing, Chee Yong Foo, Zi Qun Ang, Jing Li, and Nachiket
Kapre. 2016. Software-Speciï¿¿c Named Entity Recognition in Software Engineer-
ing Social Content. In IEEE 23rd International Conference on Software Analysis, Evo-
lution, and Reengineering, SANER 2016, Suita, Osaka, Japan, March 14-18, 2016 - Vol-
ume 1 . IEEE Computer Society, 90â€“101. https://doi.org/10.1109/SANER.2016.10
[52] Deheng Ye, Zhenchang Xing, Chee Yong Foo, Jing Li, and Nachiket Kapre. 2016.
Learning to Extract API Mentions from Informal Natural Language Discussions.
In2016 IEEE International Conference on Software Maintenance and Evolution,
ICSME 2016, Raleigh, NC, USA, October 2-7, 2016 . IEEE Computer Society, 389â€“399.
https://doi.org/10.1109/ICSME.2016.11[53] Insu Yun, Changwoo Min, Xujie Si, Yeongjin Jang, Taesoo Kim, and Mayur
Naik. 2016. APISan: Sanitizing API Usages through Semantic Cross-Checking.
InProceedings of 25th USENIX Security Symposium, USENIX Security 16, Austin,
TX, USA, August 10-12, 2016 , Thorsten Holz and Stefan Savage (Eds.). USENIX
Association, 363â€“378. https://www.usenix.org/conference/usenixsecurity16/
technical-sessions/presentation/yun
[54] Tianyi Zhang, Ganesha Upadhyaya, Anastasia Reinhardt, Hridesh Rajan, and
Miryung Kim. 2018. Are code examples on an online Q&A forum reliable?: a
study of API misuse on stack overï¿¿ow. In Proceedings of the 40th International
Conference on Software Engineering, ICSE 2018, Gothenburg, Sweden, May 27 - June
03, 2018 , Michel Chaudron, Ivica Crnkovic, Marsha Chechik, and Mark Harman
(Eds.). ACM, 886â€“896. https://doi.org/10.1145/3180155.3180260
[55] Hao Zhong, Tao Xie, Lu Zhang, Jian Pei, and Hong Mei. 2009. MAPO: Mining
and Recommending API Usage Patterns. In Proceedings of ECOOP 2009 - Object-
Oriented Programming, 23rd European Conference, Genoa, Italy, July 6-10, 2009.
Proceedings (Lecture Notes in Computer Science, Vol. 5653) , Sophia Drossopoulou
(Ed.). Springer, 318â€“343. https://doi.org/10.1007/978-3-642-03013-0_15
Received 2023-02-02; accepted 2023-07-27
998