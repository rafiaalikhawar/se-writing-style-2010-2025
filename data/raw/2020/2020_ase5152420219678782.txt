Binary Difﬁng as a Network Alignment Problem
via Belief Propagation
Elie Mengin
SAMM, EA 4543
Universit ´e Paris 1 Panth ´eon-Sorbonne, Paris, France
Quarkslab SA
13 rue Saint-Ambroise, Paris, France
elie.mengin@gmail.comFabrice Rossi
CEREMADE, CNRS, UMR 7534
Universit ´e Paris-Dauphine, PSL University, Paris, France
fabrice.rossi@dauphine.psl.eu
Abstract —In this paper, we address the problem of ﬁnding
a correspondence, or matching, between the functions of two
programs in binary form, which is one of the most commontask in binary difﬁng. We introduce a new formulation of thisproblem as a particular instance of a graph edit problem overthe call graphs of the programs. In this formulation, the qualityof a mapping is evaluated simultaneously with respect to bothfunction content and call graph similarities. We show that thisformulation is equivalent to a network alignment problem. Wepropose a solving strategy for this problem based on max-productbelief propagation. Finally, we implement a prototype of ourmethod, called QBinDiff, and propose an extensive evaluationwhich shows that our approach outperforms state of the artdifﬁng tools.
Index T erms—Binary Difﬁng, Binary Program Analysis, Graph
Edit Distance, Network Alignment, Belief Propagation
I. I NTRODUCTION
Static program analysis is the process of analyzing and
predicting the possible execution behaviors and outcomes of
a program without actually executing it. It can be performedon the source code of the program or, with more difﬁculty,on the binary executable. Static program analysis has a widevariety of applications such as vulnerability detection, patchanalysis, malware detection, software clone detection, etc.
In most of the cases, static analysis of binaries needs human
expertise which is leveraged using speciﬁc software tools.Among those tools, differs are particularly useful as they allowthe analyst to focus on the differences between a previouslyanalyzed program and the one currently under investigation,enabling knowledge capitalization. Finding the differencesbetween two programs in binary form only is known as thebinary difﬁng problem.
Several different formulations of the problem have been
given, mostly depending on the use case or the desiredgranularity but also implicitly induced by the solving approach[1]. In this paper, we address the problem of ﬁnding the bestpossible one-to-one correspondence between the respectivefunctions of two programs in binary form.
Following previous authors [2], [3], [4], we leverage a graph
edit formulation of binary difﬁng: we ﬁnd an (almost) optimaltransformation of the call graph of program Ainto the call
graph of program B, with respect to some speciﬁc edit costs.
Fig. 1: Binary difﬁng as an alignment of call graphs. Thislayout represents the superposition of functions (dots) andfunction calls (lines) of two binaries (libz-1.2.4.3 vs libz-1.2.6.1). Such mapping provides useful information to ananalyst. In this ﬁgure, green dots and lines represent functionsand calls that remained identical from a program to theother, and thus correspond to duplicated code. Blue (resp.red) elements represent inserted (resp. deleted) items, andmay indicate added (resp. removed) functionalities. Yellowdots correspond to matched functions which content has beenmodiﬁed (substituted). They may thus record the functions thathave been patched during the release. The ﬁgure highlights theinterest of leveraging the function call consistency in order toﬁnd the best possible function correspondence.
9672021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000892021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678782
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
We then show that this formulation is equivalent to a network
alignment problem. Following [5], we propose an efﬁcientapproximate solver of this problem based on max-product
belief propagation. In summary, our contributions are:
•a new formulation of the binary difﬁng problem as agraph edit distance problem;
•an equivalent formulation as a network alignment prob-lem;
•an efﬁcient solver, QBinDiff, based on max-product belief
propagation;
•a new difﬁng benchmark dataset consisting in more than60 binaries and over 800 manually extracted ground truthcorrespondences;
•an extensive evaluation of our approach by comparing toother common matching methods, as well as other stateof the art function similarity measures;
Our experimental results show that the proposed approachoutperforms other difﬁng methods in almost all probleminstances. Moreover, they highlight that function similaritymeasures originally designed for near-duplicate detection arenot ﬁtted to compute difﬁng assignments. Finally, they suggestthat our problem formulation is particularly adapted to addressthe binary difﬁng problem.
The rest of paper is organized as follows. Section II intro-
duces in more details the binary difﬁng problem and reviewssome existing solutions. Our proposed formalization as anoptimization problem is described in Section III, while SectionIV summarizes the maximization algorithm used to solve theproblem. Section V is dedicated to the experimental evaluationof our solution.
II. B
INARY DIFFING
A. Graph representation and function matching
In binary analysis, in order to consider its different potential
execution behaviors, a binary executable can be representedas a directed attributed graph. In this graph, nodes stand foruninterrupted sequences of instructions, called basic blocks,and edges indicate the possible jumps from a basic blockto another (conditional jumps, calls or returns). Such graphtheoretically represents all possible execution paths of theprogram. It is known as the control-ﬂow graph (CFG) [6].
Another common representation of a program consists in
a partition of the control-ﬂow graph according to the callprocedures. The resulting directed attributed graph is com-posed of nodes denoting the different program functions andedges registering the calls among them. It is known as call
graph (CG). This representation corresponds to a higher level
of abstraction than the CFG, closer to the developer point ofview.
Note that retrieving both the CFG and the CG of a binary
executable is a challenging problem that may not be solvedexactly in some cases [6]. In this paper, we assume that boththe CFG and CG can be reliably obtained from the executableprograms.
In this paper, we deﬁne the binary difﬁng problem as the
problem of matching call graphs. We want to match functionsfrom one program to the functions of another such that theyshare similar functionalities (node content similarity) and theycall other functions in a similar way (induced edge similarity).As a result, when a matching is satisfactory, the remainingdifferences between the call graphs can be interpreted asmeaningful modiﬁcations from one program to the other.
As any binary difﬁng formulation, our deﬁnition requires
a measure to assess the quality of a matching between twocall graphs. This measure should evaluate the similarity ofmatched functions, as well as the relevance of the resultinggraph alignment. Therefore, any binary difﬁng instance ischaracterized by the given function similarity and topologysimilarity measures. Once they are properly deﬁned, we mayformulate the binary difﬁng problem as an assignment problemwhich solution is the best one-to-one correspondence betweenthe functions of both program.
In the rest of this section, we present a short state-of-the-art
of existing methods to measure function similarity, as well ascommon proposed approaches to compute the best functionmapping.
B. Binary code similarity
The problem of measuring how much two pieces of bi-
nary code are similar is a fundamental problem of program
analysis. Indeed, two seemingly different binary executablesmay have the exact same functionality. Such programs aresaid to be semantically equivalent while syntactically different.Conversely, two slightly divergent pieces of code may havevery different behaviors when executed. Moreover, syntacticsimilarity is relatively easy to compute but can lead to incorrectmatching, while full semantic characterization is undecidable(and heuristics tend to be computationally expensive). There-fore, the deﬁnition of a similarity measure between two binaryfunctions generally involves an arbitrary trade-off betweensyntactic [7], [8], [9] or semantic comparisons [10], [11], [12].
Many recent approaches propose a mixed strategy. The
idea is to use simple syntactic features and to encode partof the function semantic through its control-ﬂow graph. Forinstance, Gemini [13] introduces a Siamese graph neural
network to learn the common features of two semantically
similar functions. The model considers a very simple rep-resentation of the function instructions as well as the basicblock layout of the CFG. It then embeds these features intoa metric space where semantically similar functions are likelyto have close coordinates. Once every function representationis projected into this metric space, pairwise similarity scorescan be computed very efﬁciently using common vector-baseddistance computation routines.
Based on the same basis of Gemini, GraphMatching [14]
proposes to enhance the model with an attention mechanism
based on the structure of both function CFGs. Howeversince it actively uses the topology of both graphs during thesimilarity score computation itself, GraphMatching can notbeneﬁt from fast vector-based distance computation as Geminidoes. Therefore, the time required to compute all pairwise
968similarity scores may rise signiﬁcantly with the size of the
binaries.
Another alternative is Asm2V ec [15] which also provides
vector representations for binary functions but in an unsuper-vised way that does not need matching pairs of functions.DeepBinDiff [16] improves over Asm2V ec by working at thelevel of basic blocks. The embedding of a basic block is basedon its content but also the one of its closer neighbors. It usesan adaptation of a graph embedding algorithm, text-attributed
deep walk (TADW) [17] to extract a vector representation of
each basic blocks among both binaries. To do so, it ﬁrst mergesthe inter-procedural CFGs of both programs based on the
binary symbols and then runs the TADW algorithm to computethe embedding of each basic blocks in this larger graph. Notethat this approach is designed to proceed the difﬁng at a basicblock granularity, whereas ours seeks a mapping between thefunctions of each binaries.
C. Call graph matching
Given a similarity measures between functions, one must
now deﬁne a criteria of quality of the call graph alignment. In
practice, such measure is closely related to the chosen functionmatching strategy.
The simplest solution for matching two call graphs consists
in disregarding the call graph structure itself and simplylooking for a one-to-one mapping that maximizes the sumof the similarities between the matched functions. In order toaddress the binary difﬁng problem, this would be the naturalmatching strategy used by methods originally designed to re-trieve similar functions such as Gemini [13] or GraphMatching[14]. Finding the best match reduces to an instance of thelinear assignment problem also know as the maximum weight
matching problem (MWM). This is well known problem for
which optimal solutions can be found exactly in polynomialtime, using e.g. the Hungarian algorithm [18]. The major
drawback of this approach is that the resulting mapping mightbe highly inconsistent with regards to the call graph structureof the two programs.
To overcome this issue, other approaches such as BinDiff
[19] and DeepBindiff [16] propose instead to use matchingalgorithms designed to approximate the maximum common
edge subgraph problem (MCS) [20]. Therefore, they implicitly
deﬁne binary difﬁng as an instance of the MCS. This problemconsists in ﬁnding the node correspondence which inducesthe maximum number of overlapping edges when aligningthe graphs [21]. The general idea of those solutions is toexpand in an iterative way the partial solution by seekingpotential matches in the neighborhood of the current mapping(caller or callee of any already matched function). Though inpractice this strategy proved to provide satisfying results, itsuffers from a major limitation: by restricting new matchesto belong to the respective neighbors of the current partialmapping, it prevents the assignment of potentially better non-local correspondences. Therefore, this strategy mostly consistsin ﬁnding a locally-consistent mapping whereas a globallybetter assignment potentially exists.D. Graph edit distance
A natural way to globally assess the quality of a matching
is to consider it as a particular case of graph edition. One
deﬁnes a set of graph edit operations on both nodes and edgesof the graphs, and assigns to them a cost. The cost of a seriesof operations, also called an edit path, is simply the sum of the
costs of said operations. Then, the edit path that transformsgraphAintoBat the minimum cost is called an optimal edit
path and the resulting edit cost is known as the graph edit
distance [22].
A matching can be viewed as a particular edit path in
which matched nodes result from an edition, whereas un-matched nodes in Aare considered removed and unmatched
nodes in Binserted. The operation on the edges (inser-
tion/deletion/edition) are then completely induced by those onthe nodes (see Section III for details). Therefore, there is aclose relationship between an optimal matching and an optimaledit path.
Unfortunately, the computation of the graph edit distance
of two arbitrary graphs is known to be NP-complete and evenAPX-hard [23]. Though exact algorithms exist, they rapidlybecome intractable as the number of vertices rises [22]. Inpractice, the computation of the GED of graphs of more thana hundred nodes must be approximated. Note that the above-mentioned MCS problem is also NP-complete.
Several approaches previously proposed to compare pro-
grams in binary form through a GED formulation [2], [3],[4]. However, in order to compute an approximated solution,all of them refer to Riesen and Bunke’s linear programmingrelaxation [24], which reduces to a MWM formulation ofthe binary difﬁng problem with a function similarity measuretaking into account the number of incident edge of eachfunction.
In this paper, we propose to directly address the GED
problem through an equivalent network alignment problemformulation. In this form, the globally optimal edit-path canbe efﬁciently approximated by means of a message passingframework.
III. F
ORMALIZA TION
The novelty of our approach lies in the reformulation of
the graph edit distance calculation into a network alignment
problem (NAP) which can then be solved (approximately)
with a dedicated message passing algorithm. We give a formalderivation of the NAP in the present section.
A. Binary difﬁng as a graph edit distance problem
Let us consider two binary executables AandB.W e
assume that adapted disassembly tools are used to represent
them by their respective call graph G
A=(VA,EA)and
GB=(VB,EB). The vertices VA={1,...,n }andVB=
{1/prime,...,m/prime}represent the functions of AandB. The edges
EA={(i,j)|i,j∈V2
A,i/negationslash=j}andEB={(i/prime,j/prime)|i/prime,j/prime∈
V2
B,i/prime/negationslash=j/prime}represent the function calls (e.g. (i,j)∈EA
encodes the fact that function icalls function jin program A).
Without loss of generality, self-loops (a.k.a. recursive calls) are
969TABLE I: Graph edit operations and respective costs.
Operation Cost
edit function c(i→i/prime)=dii/prime
delete function c(i→/epsilon1)=d/epsilon1
insert function c(/epsilon1→i/prime)=d/epsilon1
edit call c((i,j )→(i/prime,j/prime)) =dii/primejj/prime
delete call c((i,j )→/epsilon1)=d/epsilon1/epsilon1
insert call c(/epsilon1→(i/prime,j/prime)) =d/epsilon1/epsilon1
not taken into account (they can be accounted for at the level
of the function similarity calculation).
We assume given two similarity measures. σVmeasures the
similarity between two functions i∈VAandi/prime∈VBsuch that
σV(i,i/prime)=sii/prime.σEmeasures the similarity between function
calls. IficallsjinAandi/primecallsj/primeinB, the similarity of
those calls is σE((i,j),(i/prime,j/prime)) =sii/primejj/prime. We assume that the
similarities give values in [0,1]. This enables us to convert
similarities into costs using dii/prime=1−sii/primeanddii/primejj/prime=1−
sii/primejj/prime. Finally, we assume given two non-negative constant
valuesd/epsilon1andd/epsilon1/epsilon1corresponding to the cost of insertion or
deletion of a function and call in a call graph.
We denote any series of graph edit operations P=
(op1,...,op k)an edit path, and deﬁne P(A,B)as
the set of all possible edit paths that transform GA
intoGB. Formally, if (op1,...,op k)∈P(A,B), then
opk(opk−1(...op 1(GA)...)) =GB. We ﬁnally denote
C(P)=/summationtextk
i=1c(opi)the cost the edit path P.
Table I lists the six possible graph edit operations we
consider, with their respective costs. In this paper, we restrict
P(A,B)to the set of restricted edit paths [25]. An important
property of such paths is that they correspond to a uniquemapping between the functions of Aand those of B(see
the Appendix for details). Note that unlike common GEDdeﬁnitions, our formulation implies a constant cost for everyfunction (or call) insertion or deletion, whatever its content.
Based on these deﬁnitions, our formulation of the binary
difﬁng problem consists in ﬁnding the minimal-cost edit pathP
∗that transforms A into B. Formally:
P∗=a r gm i n
P∈P(A,B )C(P),
=a r g m i n
(op1,...,op k)∈P (A,B )k/summationdisplay
i=1c(opi).(GED)
B. Binary difﬁng as a network alignment problem
We now reformulate our deﬁnition of the binary difﬁng
problem as an equivalent instance of a network alignment
problem.
We ﬁrst describe the difﬁng correspondences via a binary
vector x∈{0,1}|VA|×|V B|(where|U|denotes the cardinality
of the set U) for which xii/prime=1 if and only if function i
inAis matched with function i/primeinB. To ensure that each
function from Ais matched to at most one function in Band
vice versa, xmust fulﬁl the following constraints:
∀i∈VA,/summationdisplay
j/prime∈VBxij/prime≤1,∀i/prime∈VB,/summationdisplay
j∈VAxji/prime≤1. (1)A good matching should associate similar functions that havealso similar calling patterns. This can be captured in a cost
matrixQ∈R
|VA|2×|VB|2deﬁned as follows:
Qii/primejj/prime=⎧
⎪⎨
⎪⎩wii/prime ifii/prime=jj/prime,
wii/primejj/prime if(i,j)∈EAand(i/prime,j/prime)∈EB,
0, otherwise.
with
wii/prime=sii/prime+2d/epsilon1−1,w ii/primejj/prime=sii/primejj/prime+2d/epsilon1/epsilon1−1.
Using these deﬁnitions, it can be shown that computing the
optimal edit path of (GED) is equivalent to solving thefollowing network alignment problem:
x
∗=argmax
xxTQx
subject to ∀i∈VA,/summationdisplay
j/prime∈VBxij/prime≤1
∀i/prime∈VB,/summationdisplay
j∈VAxji/prime≤1(NAP)
We provide a proof in the Appendix.
C. Graph edit operation costs
1) Local vs global similarity trade-off: The deﬁnition of the
edit operation costs of any GED formulation usually relies on
carefully chosen data based considerations (see e.g. [4]). Costshave obviously an effect on the quality of the matching butalso on the ability of a solver to ﬁnd an approximately optimalsolution. Moreover, because of the difﬁculty of function com-parisons, local similarities might be inconsistent with the callpatterns and there may be no solution optimal both locally andglobally. Therefore, a matching results from an inherent trade-off between local node similarity and global graph topology.
In order to control the trade-off one can decompose Qinto
two terms and weight them. We deﬁne Q
1as the diagonal
matrix in R|VA|2×|VB|2with diagonal terms Q1ii/primeii/prime=wii/primeand
Q2asQ2=Q−Q1.Q1gathers the function/node similarities
whileQ2contains all the potential induced overlapping edges,
called “squares”. A potential square consists of a pair of edgesin both call graphs: (i,j)∈E
Aand(i/prime,j/prime)∈EB.I fi is
matched to i/primeandjtoj/prime, then the call structure is preserved
and, in a sense, forms a square (with two sides coming fromthe matches and two sides coming from the calls).
Given a trade-off parameter α∈[0,1], the objective
function of (NAP) can thus be modiﬁed into:
αx
TQ1x+(1−α)xTQ2x.
In terms of graph edit operations, this reformulation consistsin appropriately weighting the original edit operation costs.
Notice that extreme cases for αcorrespond to some inter-
esting particular cases. When α=1 , we recover a maximum
weight matching (MWM) strategy which disregards the callswhileα=0 corresponds to a maximum common edge
subgraph instance (MCS) where function similarities are notused. Therefore, our formulation can be seen as a balancedstrategy between the two most common binary code matchingmethods.
970TABLE II: Function features and respective weights used in
our proposed similarity measure. The ﬁnal similarity score iscomputed using the Canberra distance.
Type Weight Features
Content 23total # of instructions
# of instructions per classmax # of block instructions
Topology 19# of blocks# of jumpsmax # of block callersmax # of block callees
Neighboorhood 7# of function callers# of function callees
2) Function content similarity: In this paper, we propose a
simple function similarity metric σV. It consists in a weighted
Canberra distance [26] over the set of features given in Table
II. During the computation, each feature is properly weightedaccording to its type. We distinguish content based (instruc-tions), topological based (CFG layout), and neighborhoodbased features (CG callers and callees). Note that one of ourfeature refers to an instruction classiﬁcation. This classiﬁcationencodes each instruction using the class of its mnemonic andthe ones of its potential operands. Our taxonomy consistsin respectively 34 and 13 different mnemonic and operandclasses.
Since most matching algorithms are sensitive to ties between
function distances, we introduce a small perturbation to theresulting similarity scores. Assuming that the denomination ofthe functions is consistent with their order in terms of entryaddress, the similarity between function iinAandi
/primeinBis
being increased by the value 1−|i−i/prime|
max(|V A|,|V B|).
3) Function call similarity: In order to measure the sim-
ilarity of two function calls, we simply use a 0/1 indicator,i.e.σ
E((i,j),(i/prime,j/prime)) = 1 if and only if (i,j)∈EAand
(i/prime,j/prime)∈EB. Therefore, the matrix Q2can be computed
through the Kronecker product of the afﬁnity matrix of GA
andGB.
Finally, in order to compare with other state of the art
methods, and because, in general, binary difﬁng favors recallover precision, we set the insertion/deletion operation costs tod/epsilon1=d
/epsilon1/epsilon1=1
2. This forces the algorithm to produce a complete
mapping even when some assignments are of poor relevance.
As pointed out in Section II-B, other similarity measures
have been proposed, some of them being much more so-phisticated than the one we propose to use. However, thispaper aims at identifying the beneﬁt of the proposed matchingapproach and as such a simple metric seems more appropriateto emphasize the effect of variations in matching.
IV . N
ETWORK ALIGNMENT WITH MAX PRODUCT BELIEF
PROPAGA TION
The network alignment problem, sometimes also referred
to as graph matching problem, is an important optimizationproblem that has been extensively studied for decades [27].Although it is not easier to solve the NAP than the GED,several efﬁcient approximate algorithms have been proposed,based on spectral methods [28], [29], convex or indeﬁniterelaxations [30], [31] or linearization [32].
In this section, we introduce a novel algorithm to efﬁciently
approximate the binary difﬁng problem as a network alignmentproblem. This algorithm is inspired of a previous model of [5],which proposes to address the integer program (NAP) throughan equivalent graphical model mode inference.
A graphical model is a way to represent a class of proba-
bility distributions over some random variables [33]. There isa strong link between inference in graphical models and opti-mization, especially when we consider Maximum A Posteriori(MAP) inference. This is the general problem of ﬁnding themost probable value of some of the random variables giventhe value of the rest of the variables. A particular case of MAPinference is to ﬁnd the mode of a probability distribution,i.e. the most probable value of all its variables. One of themost efﬁcient algorithm for MAP inference is the max-product
algorithm. It consists in passing messages between the verticesof the graphical model that represents the distribution (see e.g.[33], chapter 13).
To leverage this algorithm, we design a graphical model that
encodes both the objective function and the constraints of NAPinto a probability distribution such that it assigns maximumprobability to the optimal assignment of the NAP . Finding themode of the distribution is then equivalent to solving the NAP .
Formally, matching vector xis associated to binary random
variables X={X
ii/prime∈{0,1},ii/prime∈VA×VB}. The
constraints (1) of NAP are encoded through Dirac measuresf
i:{0,1}|∂f i|→{0,1}andgi/prime:{0,1}|∂gi/prime|→{0,1}such
that:
∀i∈VA,fi(x∂fi)=/braceleftBigg
1, if/summationtext
j/prime∈VBxij/prime≤1,
0, otherwise.
∀i/prime∈VB,gi/prime(x∂gi/prime)=/braceleftBigg
1, if/summationtext
j∈VAxji/prime≤1,
0, otherwise,
wherex∂fi={xij/prime∈x,j/prime∈VB}, and similarly for x∂gi/prime.
The probability distribution of the corresponding graphical
model is then:
pX(x)=1
Z⎡
⎣n/productdisplay
i=1fi(x∂fi)m/prime/productdisplay
i/prime=1/primegi/prime(x∂gi/prime)⎤⎦e
xTQx(2)
Where the normalization constant Zdenotes the partition
function of the model.
It is clear that the support of the distribution (2) is equivalent
to the set of feasible solutions in (NAP). Furthermore, the
mode ofpX(x)corresponds to the optimal solution of (NAP).
In our work, we introduce modiﬁcations to the original
model of [5] in order to speed up the computation and favor themessages convergence. Though the details and improvementsof these modiﬁcations are out of scope for this paper, we pro-vide a complete derivation of the message passing frameworkin the Appendix.
A key property of this model is the local structure of the
message passing scheme. This later limits the propagation
971of updates to the connected components only, and therefore
reduces the overall computation cost of the problem whenworking on sparse graphs, which is generally the case ofcall graphs. Moreover, it enables to discard some potentialcorrespondences considered too unlikely, and thus signiﬁcantlyreduce the size of the problem solution set. This property isvery useful to control the required computation cost and mem-ory usage of larger problem instance: as shown in e.g. [34],the cost of one iteration of our algorithm is in O(nnz(Q
1)+
nnz(Q2))wherennz(x) denotes the number of non-zero
entries in x. Note that after the last iteration, we need to solve
a MWM problem which adds a O(nnz(Q1)N+N2logN)
cost to the whole procedure, where N=|VA|+|VB|.
Our implementation includes a sparsity ratio parameter
ξ∈[0,1]in order to remove a ratio of less probable
correspondences and forces the algorithm to ﬁnd a solutionamong the remaining ones.
V. E
V ALUA TION
This section is dedicated to a thorough evaluation of our
proposed solution, named QBinDiff, and to a comparisonof its performances with a selection of state-of-art difﬁngapproaches. We describe ﬁrst our evaluation benchmark, thenthe chosen binary code similarity and ﬁnally the experiments.
A. Benchmark
A difﬁng approach can be evaluated by comparing the
mapping results with “true” assignments, known as the ground
truth. Unfortunately, such assignments are not readily available
and may be in fact very difﬁcult to determine in an objectiveway. As part of this work, we have built a new benchmarkthat will be released to the research community.
1) Benchmark design: To select programs to include in
the proposed benchmark, we have considered several require-ments. First, the source of the programs should be made read-ily available, within several different versions. This enables usto compile the program with symbols and thus ease the deter-mination of the ground truth. Second, well maintained sourcerepositories with explicit commit descriptions, detailed changelogs, as well as a relatively consistent function denominationover time are also very important features for the ground truthextraction. Third, as this extraction is largely done manually,program sizes should be “reasonable”.
According to these considerations, we choose three well
known open source project to compose our experimentaldataset, namely Zlib
1, Libsodium2and OpenSSL3. Note that
some of these programs are amongst the most frequently usedfor evaluation in the literature [1].
For each of these projects, we ﬁrst downloaded the ofﬁcial
repository, then we compiled the different available versionsusing GCC v7.5 for x86-64 target architecture with -O3 opti-mization level and keeping the symbols. Once extracted, eachbinary was stripped to remove all symbols, then disassembled
1https://github.com/madler/zlib
2https://github.com/jedisct1/libsodium
3https://github.com/openssl/opensslTABLE III: Description of our binary difﬁng dataset. Thelast six columns respectively record the number of differentbinary versions, the number of resulting difﬁng instances, theaverage number of functions and function calls and the averageratio of conserved functions in our manually extracted andextrapolated ground truth.
Program V ers. Diff. Nodes Edges GT GT
Zlib 18 153 153 235 0.99 0.96
Libsodium 33 528 589 701 0.98 0.79
OpenSSL 17 136 3473 18563 0.94 0.72
using IDA Pro v7.24, and ﬁnally exported into a readable ﬁle
with the help of BinExport5. During the problem statement,
only plain text functions determined during the disassembly
process are considered.
This extraction protocol provided us with respectively 18,
33 and 17 different binary versions. For each project, given n
different versions of the program, we propose to evaluate our
method in difﬁng all then(n− 1)
2possible pairs of different
executables. Statistics describing our evaluation dataset are
given in Table III.
Notice that both the average call graph size and density of
the programs varies with the different projects. This varietywill provide insights on the scalability of the difﬁng methodsunder study as well as the effect of sparsity on our solver.
2) Ground Truth: As recalled in Section II, determining the
’true assignment’ between the functions of two given binariesis a difﬁcult task. In its strongest sense, this problem reducesto evaluate the semantic equivalence between two pieces ofcode and is known to be undecidable [1].
In practice, when working on different versions of the
same, open-source and well documented binary, one maysigniﬁcantly reduce the difﬁculty by carefully exploiting thehuman readable information available in both the source codeand the binary symbols. Moreover, some project repositoriesinclude detailed commit descriptions that precisely recordthe modiﬁcation from a version to another. However, theseinformation almost always refer to the changes occurringduring a release, and are thus only available for contiguousversions. Therefore, in order to obtain the function assignmentamong two arbitrary program versions, one must extrapolatethe different mappings of the releases that happened in themeantime.
Our ground truth extraction protocol has two steps. We
ﬁrst manually determine what we think to be the functionmapping that best describes the modiﬁcations between twosuccessive binary versions. This process is done with regardsto the Changelogs ﬁles, the source code and the unstrippedbinaries. Excepted for few major project modiﬁcations, almostall the functions are mapped from a version to its successor(see Table III).
Once all the contiguous version ground truth mappings are
extracted, we deduce all the pairwise difﬁng correspondences
4https://www.hex-rays.com/products/ida
5https://github.com/google/binexport
972by extrapolating the mappings from version to versions. For-
mally, if we encode the mapping between A1andA2into a
boolean matrix MA1→A2such that MA1→A2ii/prime=1 if and
only if function iinA1is paired with function i/primeinA2,
then, our extrapolating scheme simply consists in computingthe difﬁng correspondence between A
kandAnas follows:
MAk→An=/producttextn−1
i=kMAi→Ai+1.
B. Experimental setup
All the experiments have been conducted on an identical
hardware6, using the implementation provided by the authors
when possible.
Our method, QBinDiff, is used with its default parameters
(α=0.75and/epsilon1=0.5), and within a maximum of 1000
iterations. We set the sparsity ratio parameter ξto0for smaller
projects Zlib and Libsodium and to 0.9for OpenSSL.
We compare our method with BinDiff [19], a closed source
state-of-the-art binary difﬁng tool which uses a matchingalgorithm very close to MCS, but based on different, nonpublic, function similarity heuristics.
In addition, our approach is compared to differs constructed
by combinations chosen among three function similarity mea-sures and two matching algorithms outlined in Section II. Allcombinations are used. The baselines are described below.
1) Function content similarity: To evaluate the impact of
the function similarity measure on the difﬁng process, threestate-of-the-art binary code similarity approaches have beenselected: Gemini [13], GraphMatching (GraphM.) [14] andDeepBinDiff (DeepBD.) [16].
Gemini and GraphMatching are supervised learning models
that require to be trained on multiple pairs of functions labeledas similar or different. As the manual construction of such adataset is tedious, existing methods usually use a collection offunctions extracted from slightly mutated programs, such asdifferent versions of an executable. Then, a pair of functionsis labeled as similar if they share the same (or very similar)name, and dissimilar otherwise.
We applied this protocol to our dataset. Note that this
should give a small competitive advantage to differs basedon Gemini and GraphMatching as their similarity measureswill be optimized on the speciﬁc type of functions found inthe binaries under study.
During the training process, we collected 85680 samples of
7276 differently named functions from the unstripped binaries.80% of them were used as training examples, 10% as avalidation set and the remaining 10% were used to assess theﬁnal accuracy of the trained models. Both models were trainedusing their recommended hyper-parameters. To compute thesimilarity score of two embedded vectors, Gemini uses acosine similarity measure, whereas GraphMatching refers toa normalized euclidean metric. After the training, the modelsrespectively provided an estimated AUC
7of0.968 and0.939.
We also trained DeepBinDiff instruction embedding model
on each binary of our dataset, following the protocol and the
6Intel Xeon E5-2630 v4 @2.20GHz
7Area Under the ROC Curverecommendations of the corresponding article [16]. As Deep-BinDiff provides embeddings of basic blocks, we representeach function by the average of all its basic block embeddings.
2) Matching: Our matching algorithm is compared to the
two most common methods found in the literature, namelyMWM and MCS,
The MWM matching strategy implicitly used by Gemini
and GraphMatching consists in solving the linear assignmentproblem based on the computed pairwise similarity scores. Theexact solution of this problem can be found using conventionaloptimization solvers.
Several algorithms have been proposed to approximate
the MCS problem. In order to compare with BinDiff andDeepBinDiff, we based our implementation on the one usedin DeepBinDiff. However, since a CG is usually much moredense than a ICFG, we limited the neighbor parameter kto
2. Note that, to output a complete mapping, the algorithmterminates by applying a MWM solver to the set of unmatchedcorrespondences.
C. Results
The quality of a difﬁng result is measured using its precision
and recall with respect to the ground truth. We refer to the
standard deﬁnitions of precision and recall i.e. p=
|M∩G|
|G|and
r=|M∩G|
|M|whereMandGrespectively correspond to the set
of matched function pairs in the computed and ground truth
assignments. Note that, except for BinDiff, all the evaluatedmethods are designed to produce a complete mapping. In fact,none of them includes a mechanism to limit the mapping of themost unlikely correspondences during computation. Therefore,these matching strategies do not consider precision but onlyfocuses on recall. In future work, we will investigate the effectof rising the insertion/deletion operation costs d/epsilon1andd
/epsilon1/epsilon1in
order to favor the solution’s precision score.
Our experiments show that QBinDiff generally outperforms
other matching approaches in both precision and recall (seeTable IV, QBinDiff+NAP combinations). In fact, our methodappears to perform clearly better at difﬁng more differentprograms, whereas it provides comparable solutions on similarbinaries (see Figure 2). This highlights that the local greedymatching strategy of both MWM and MCS is able to providegood solutions on simple cases but generalizes poorly on moredifﬁcult problem instances. This results should be view aspromising in the perspective of difﬁng much more differentbinaries.
Our NAP matching strategy can be applied with the state-of-
the-art function similarities chosen as reference. As observedwith our custom metric, NAP provides better assignments thanother matching approaches. Moreover, it appears that in almostall cases, the chosen matching strategy has more inﬂuencethan the similarity metric. More surprisingly, the use of thesecomplex models does not improve the accuracy of the resultingmapping, and might even worsen it in some case. Since thetopology of the graphs does not change, this means that thecomputed similarity scores are not consistent with the actualground truth assignment. In fact, it appears that both Gemini
973Fig. 2: Average recall scores according to the program versions
distance. Every matching method provides comparable near-optimal results while difﬁng very similar programs. As thedistance increases, the performances of local matching strate-gies decline faster than our global approach.
(a) Pairwise similarity scores
 (b) Ground truth similarity scores
Fig. 3: Cumulative distribution function of all non-zero pair-wise similarity scores (a) and of the ground truth pairs only(b) (libsodium-0.4.2 vs libsodium-1.0.3). The similarity scoresin (a) that correspond to a ground truth correspondence aremarked by a cross. GraphMatching appears to be well ﬁttedto retrieve a large part of the correct matches but stronglydeteriorates the score of some. QBinDiff provides a more bal-anced score but keeps almost all ground truth correspondenceto a satisfying level.
and GraphMatching models very accurately retrieve similar
functions, but strongly deteriorate the similarity scores of morediverging ones (see Figure 3). This is consistent with theoriginal purpose of both model and with the training datasetwhich labels as completely different two similar functionswith different names. In the case of DeepBinDiff, it seemsthat the scores of ground truth correspondences are distributedrelatively uniformly over the cumulative distribution function,which means that the model itself does not provide sufﬁcientlydiscriminative scores, and thus leads to erroneous assignments.Moreover, we were not able to compute DeepBinDiff embed-dings on OpenSSL binaries in reasonable time. Indeed, theseproblem instances involve the factorization of the adjacencymatrices of graphs of over 100 000 nodes which is a verycomputationally intensive task.
An interesting analysis consists in comparing the differ-
ent matching method assignments to the ground truth cor-respondences in terms of function similarity score and callgraph alignment (see Figure 4). It appears that both Zliband OpenSSL ground truth assignments are near-optimal inboth maximum weight matching and maximum common edgesubgraph scores. This observation is consistent with our exper-TABLE IV: Average precision and recall scores for eachcombination of similarity measure (Similarity) and matchingmethod (Matcher). The three tables correspond to the resultson Zlib (top), Libsodium (middle) and OpenSSL (bottom)programs. The last two columns correspond to the similaritycalculation time (Sim. calc.) and to the matching time (Time),both given in second.
Similarity Matcher Precision Recall Sim. calc. Time
QBinDiffNAP 0.955 0.995
3.00.2
MWM 0.953 0.992 0.0
MCS 0.946 0.985 0.0
GeminiNAP 0.953 0.992
5.90.3
MWM 0.936 0.974 0.0
MCS 0.942 0.981 0.0
GraphM.NAP 0.938 0.977
77.10.8
MWM 0.901 0.937 0.0
MCS 0.927 0.964 0.0
DeepBD.NAP 0.909 0.946
489.34.7
MWM 0.820 0.853 0.1
MCS 0.834 0.868 0.2
BinDiff BinDiff 0.943 0.975 0.3 0.9
Similarity Matcher Precision Recall Sim. calc. Matching
QBinDiffNAP 0.722 0.880
13.36.6
MWM 0.699 0.847 0.2
MCS 0.704 0.854 0.3
GeminiNAP 0.714 0.863
24.27.5
MWM 0.668 0.802 0.2
MCS 0.686 0.823 0.2
GraphM.NAP 0.693 0.837
293.921.7
MWM 0.643 0.776 0.1
MCS 0.670 0.806 0.3
DeepBD.NAP 0.664 0.796
156.038.6
MWM 0.585 0.702 1.9
MCS 0.599 0.718 1.6
BinDiff BinDiff 0.752 0.869 0.4 0.9
Similarity Matcher Precision Recall Sim. calc. Matching
QBinDiffNAP 0.605 0.783
88.6213.3
MWM 0.522 0.670 25.5
MCS 0.522 0.670 24.4
GeminiNAP 0.577 0.685
164.8449.2
MWM 0.400 0.467 24.9
MCS 0.401 0.467 24.4
GraphM.NAP 0.548 0.686
36999.22187.5
MWM 0.316 0.408 54.7
MCS 0.317 0.409 55.1
BinDiff BinDiff 0.572 0.681 0.7 3.2
imental results that shows that a balanced network alignmentmatching strategy provide better accuracy results than otherapproaches. More importantly, it justiﬁes our intuition thatthe proposed problem formulation as a network alignmentproblem is very well suited to address the binary difﬁngproblem. However, in some cases, Libsodium correct assign-ments show to be sub-optimal in both function similarity andgraph topology. In these cases, the ground truth mappings areinconsistent in both function content syntax and invoked callprocedures. We investigated these cases, and noticed that overthe versions, several functions were split in two such that aﬁrst trivial function is solely designed to access a second corefunction actually containing the whole function semantic. Aswe largely determined our ground truth based on functionnames, we mapped full functions into their newly created
974Fig. 4: Relative similarity scores and square numbers of dif-
ferent matching methods compared to the optimal assignment.The grey lines record the normalized scores of the groundtruth. For Zlib (left) and OpenSSL (right) binaries, the groundtruth seems to be a near optimal NAP assignment in almostall cases. This result does not hold for Libsodium (center), asin some cases, assignments computed by QBinDiff are betterin both function similarity and number of induced squares.
accessors. We discuss these speciﬁc cases in the next section.
Our experiments also suggest that our rather basic function
similarity metric provides scores that are consistent with the
actual ground truth assignment (see Figure 4). Moreover,on the contrary to supervised learning models Gemini andGraphMatching, it produces less discriminative scores. Thoughit might be view as a less informative metric, it appears thatthis keeps the ground truth correspondences similarity scoresat a satisfying level and ultimately results in better solutions(see Figure 3).
Finally, we recorded the computing time of each methods.
As could be expected, it takes much more time to approximatethe NAP of two graphs than to compute the MWM or theMCS. However, this can be controlled by raising the sparsityratio parameter ξ, at the cost of limiting the problem solu-
tion set and potentially resulting in sub-optimal assignments.Moreover, it seems that better similarity scores speed-up thecomputation. This is due to the fact that the algorithm ﬁndsmore easily a satisfying local optima. Regarding the processingtimes, it appears that, whereas the use of Gemini model doesnot harm the required time, both GraphMatching and Deep-BinDiff take very long time to compute the pairwise similarityscores, which might be prohibitive for larger programs.
D. Limitations
While it improves the state-of-the-art, our method could be
further enhanced.
A ﬁrst limitation is that our approach is designed to ﬁnd
a one-to-one correspondence between the functions of both
programs. Thus, it can not properly handle cases where afunction in a binary is split into several ones in the otherprogram, or similarly, multiple functions are merged into asingle one. In such case, the information of both the functionsyntax and its call graph relations is diluted into multiplechunks and may be harder to retrieve. Note that, to our knowl-edge, this problem is common to all other difﬁng methods, andthat in practice, many function splits result in a core functioncontaining most of the semantic information, and few trivialfunctions that are immediately called before or after it (as inthe Libsodium programs). Such schemes could be handled bya pre-processing step.
The other key property of our approach is that it is based on
the assumption that the true expected mapping is the optimalsolution to the graph edit distance problem. Although it ispartially validated by our limited sized experiments, there is nogeneral available result that proves that this intuition is veriﬁedin practice, especially for more complex cross-compiler orcross-architecture difﬁng instances. One may argue that thisonly depends on the given graph edit operation costs deﬁnition.However, in practice, there is no known function similaritymetric that exactly encodes the functions semantic and theinterest of our method mostly rely on programs with rathersimilar call graphs. Moreover, the trade-off parameter αthat
balances the node and edge edit costs should be chosencarefully, which requires human expertise and prior knowledgeabout the binaries under analysis.
Finally, an important drawback of our problem formulation
is that it requires a quartic memory matrix Q. Though we
proposed to signiﬁcantly reduce the problem size by limitingthe solution set to the most probable correspondences, thisrelaxation inevitably induces information loss, especially forlarge graphs where the relaxation must rise consequently. Inpractice, binaries of several thousands of functions can behandled efﬁciently. For larger programs, it might be better toﬁrst partition the call graphs into smaller consistent subgraphs,and then proceed the matching among them. Although thispartition is not trivial and might result in important difﬁngerrors, it can be quite natural in modern programs for examplefollowing its modules.
E. Threats to validity
1) Internal validity: Our evaluation relies on a collection
of difﬁng instances for which the ground truth assignment
has been manually determined. Though we performed thisextraction with regards to multiple sources of information suchas source code, commit descriptions and unstripped symbols,we can not guarantee that our judgment is not biased, nor thatit actually meets other experts opinion. Furthermore, any erroror absence in our extracted mappings is later propagated inour extrapolation step. This may lower the conﬁdence in theground truth assignment between two distant versions. Thisthreat is inherent to any manually determined assignmentsand can only be mitigated by releasing the dataset for thecommunity to review.
2) External validity: Despite the relatively large number
of proposed difﬁng instances, several factors still threaten thegeneralizability of our experiments. First, our benchmark onlyincludes C programs taken from three open source projects.This is not representative of the variety of existing binaries.Moreover, all the executables were compiled with the samecompiler, optimization level and targeted architecture. In futureworks, we will investigate the performance of our approach onprograms built under different settings. Notice that this wouldprobably require more sophisticated measures of similarity,
975able to efﬁciently handle greater syntactic differences. Last but
not least, all our difﬁng instances compare different versionsof a same program. Though the manual determination of anunanimous ground truth assignment between two differentprograms appears to be quite challenging, the evaluation ofour method on such instances could be very instructive inthe perspective of many applications such as the detection ofvulnerability or of duplicate code.
3) Construct validity: The proposed comparison of our
approach with other state of the art methods could also includethreats to construct validity. First, all these methods are basedon machine learning models that require a prior training step.We trained the models on the same dataset than the onewe ran our experiments on. This could bias the resultingsimilarity scores, especially in case of overﬁtting. Moreover,we conﬁgured all models with their default parameters (recom-mended by the authors), though different settings could haveprovided better results. Finally, we must recall that none ofthe competitor methods where originally designed to addressthe exact same problem as ours. Indeed, both Gemini andGraphMatching have been initially proposed to retrieve near-duplicate functions whereas DeepBinDiff addresses the binarydifﬁng problem at a basic bloc granularity.
VI. C
ONCLUSION
In this paper, we introduced a new approach to address
the binary difﬁng problem. It is based on its reformulationas a graph edit distance problem. This problem was shownto be equivalent to the network alignment problem, for whichwe derived an approximate message-passing algorithm. Weproposed a new benchmark including hundreds of difﬁngground truths and used it to compare the proposed approachto state of the art binary difﬁng methods.
Our experiments showed that our algorithm outperforms
other existing approaches in almost every problem instances. Italso highlighted that the matching strategy is a crucial part ofthe difﬁng process and has more inﬂuence than the choiceof the function similarity measure. Moreover, it appearedthat using similarity metrics originally designed to retrievenear duplicate functions might actually harm the quality ofthe resulting mapping. Finally, our results suggest that ourproblem formulation is a very adapted way to address thebinary difﬁng problem.
Besides our formulation is quite natural and showed to result
in more accurate mappings, it also provides a proper metricfor measuring program-wide similarity. Indeed, any difﬁngassignment induces the (approximated) graph edit distancebetween the two programs. Therefore, our approach could alsobe used in a variety of metric-based analysis at a programlevel, such as library retrieval, program lineage, etc.
Finally, we believe that our graph matching algorithm could
also be leveraged to perform difﬁng between matched func-tions in a post-processing step. This would results in a ﬁnedgrained alignment between constitutive basic blocks of bothfunctions and could provide to an analyst precious informationabout their exact differences.A
PPENDIX
Proof of equivalence of (GED) and (NAP)
In the following proof, we ﬁrst show that the solution set
of (GED) can be reduced to the one of (NAP). Then we showthat both objective functions are equivalent up to a sign anda constant term, which completes the proof.
LetP(A,B)be the set of all restricted edit path transform-
ingG
AintoGB[25]. This set consists in edit paths where
any node can be removed only if its incident edges have beenpreviously removed, and where any edge can be inserted onlyif its terminal nodes previously existed or have been inserted.Moreover, no nodes or edges can be successively inserted thenedited, edited then deleted, inserted then deleted, or editedmultiple times. Finally, overlapping edge must be consideredas an edition and can not result from a deletion then aninsertion.
It can be shown [25] that any edit path in P∈P(A,B)
can be fully characterized by a unique injective function of asubsetˆV
AofVAtoVB, and reciprocally. Such a mapping can
be encoded as a binary vector x∈{0,1}|VA|×|V B|such that
xii/prime=1if and only if i→i/prime∈Pand satisfying the following
constraints:
∀i∈VA,/summationdisplay
j/prime∈VBxij/prime≤1,∀i/prime∈VB,/summationdisplay
j∈VAxji/prime≤1.
Indeed, the injection implies that any node i/prime∈VBis
the image to at most one node i∈VA. Therefore, ∀i/prime∈
VB,/summationtext
j∈VAxji/prime≤1. Moreover, any node i∈ˆVAhas a
unique image in VB,s o/summationtext
j/prime∈VBxij/prime=1 , whereas any node
j∈VA\ˆVAis not part of the injection and/summationtext
j/prime∈VBxjj/prime=0 .
Reciprocally, the constrained boolean vector deﬁnes a one-
to-one mapping between the subsets of nodes ˆVA∈VAand
ˆVB∈VB. Thus, it implies a unique injection between ˆVAand
the whole set of functions VB.
Therefore, there is a bijection between the solution set of
(GED) and the one of (NAP).
Let us now evaluate the cost of any arbitrary edit path P∈
P(A,B). Recall that this cost is completely induced by the
edit operation on the nodes.
We ﬁrst describe CV(P), the cost of the node operations in
P. We distinguish the different possible operations such that:
CV(P)=/summationdisplay
i→i/prime∈Pc(i→i/prime)
+/summationdisplay
i→/epsilon1∈Pc(i→/epsilon1)+/summationdisplay
/epsilon1→i/prime∈Pc(/epsilon1→i/prime)
=/summationdisplay
i→i/prime∈Pdii/prime−2d/epsilon1
+/summationdisplay
i→/epsilon1∈Pd/epsilon1+/summationdisplay
i→i/prime∈Pd/epsilon1+/summationdisplay
/epsilon1→i/prime∈Pd/epsilon1+/summationdisplay
i→i/prime∈Pd/epsilon1
=/summationdisplay
i→i/prime∈Pdii/prime−2d/epsilon1+/summationdisplay
i∈VAd/epsilon1+/summationdisplay
i/prime∈VBd/epsilon1
=/summationdisplay
i→i/prime∈Pdii/prime−2d/epsilon1+|VA|d/epsilon1+|VB|d/epsilon1.
976In order to evaluate the cost of all the edges operations, we
must consider the different possible conﬁgurations for pairsof nodes. But ﬁrst, we must introduce the following notations:
δ
A
ij=/braceleftBigg
=1, if(i,j)∈EA
=0, otherwise., and similarly for δB
i/primej/prime.
We may now evaluate CE(P)such that:
CE(P)=/summationdisplay
i→i/prime∈P/summationdisplay
j→j/prime∈P/bracketleftBig
dii/primejj/primeδA
ijδB
i/primej/prime
+d/epsilon1/epsilon1δA
ij(1−δB
i/primej/prime)+d/epsilon1/epsilon1(1−δA
ij)δB
i/primej/prime/bracketrightBig
+/summationdisplay
i→i/prime∈P/summationdisplay
j→/epsilon1∈Pd/epsilon1/epsilon1δA
ij+/summationdisplay
i→i/prime∈P/summationdisplay
/epsilon1→j/prime∈Pd/epsilon1/epsilon1δB
i/primej/prime
+/summationdisplay
i→/epsilon1∈P/summationdisplay
j→j/prime∈Pd/epsilon1/epsilon1δA
ij+/summationdisplay
/epsilon1→i/prime∈P/summationdisplay
j→j/prime∈Pd/epsilon1/epsilon1δB
i/primej/prime
+/summationdisplay
i→/epsilon1∈P/summationdisplay
j→/epsilon1∈Pd/epsilon1/epsilon1δA
ij+/summationdisplay
/epsilon1→i/prime∈P/summationdisplay
/epsilon1→j/prime∈Pd/epsilon1/epsilon1δB
i/primej/prime
=/summationdisplay
i→i/prime∈P/summationdisplay
j→j/prime∈P(dii/primejj/prime−2d/epsilon1/epsilon1)δA
ijδB
i/primej/prime
+/summationdisplay
i∈VA/summationdisplay
j∈VAd/epsilon1/epsilon1δA
ij+/summationdisplay
i/prime∈VB/summationdisplay
j/prime∈VBd/epsilon1/epsilon1δB
i/primej/prime
=/summationdisplay
i→i/prime∈P/summationdisplay
j→j/prime∈P(dii/primejj/prime−2d/epsilon1/epsilon1)δA
ijδB
i/primej/prime
+|EA|d/epsilon1/epsilon1+|EB|d/epsilon1/epsilon1.
Putting all together, and denoting C(P0)=|VA|d/epsilon1+
|VB|d/epsilon1+|EA|d/epsilon1/epsilon1+|EB|d/epsilon1/epsilon1, the cost of any edit path Pis:
C(P)=CV(P)+CE(P)
=C(P0)+/summationdisplay
i→i/prime∈Pdii/prime−2d/epsilon1
+/summationdisplay
i→i/prime∈P/summationdisplay
j→j/prime∈P(dii/primejj/prime−2d/epsilon1/epsilon1)δA
ijδB
i/primej/prime
=C(P0)+/summationdisplay
ii/prime∈VA×VBxii/prime(dii/prime−2d/epsilon1)
+/summationdisplay
ii/prime∈VA×VB/summationdisplay
jj/prime∈VA×VBxii/prime(dii/primejj/prime−2d/epsilon1/epsilon1)δA
ijδB
i/primej/primexjj/prime
=C(P0)−/summationdisplay
ii/prime∈VA×VBxii/primewii/prime
−/summationdisplay
ii/prime∈VA×VB/summationdisplay
jj/prime∈VA×VBxii/primewii/primejj/primeδA
ijδB
i/primej/primexjj/prime
=C(P0)−/summationdisplay
ii/prime∈VA×VB/summationdisplay
jj/prime∈VA×VBxii/primewii/primejj/primexjj/prime
=C(P0)−xTQx,
where we simply use the fact that dii/prime−1−2d/epsilon1+1=−wii/prime
and similarly for wii/primejj/prime.
Therefore, exploiting the one-to-one correspondence be-
tween an edit path Pand its boolean representation x, we may
turn the minimization of (GED) into a maximization problem
and obtain (NAP). /squaresolidQBinDiff’s message passing scheme
We reproduce the messages derivation of [5], and introduce
our modiﬁcations. For the sake of simplicity, we changed themessage passing denomination of the original paper to besthighlight their vectorial structure.
The messages f={f
ii/prime,wii/prime/negationslash=0},g={gii/prime,wii/prime/negationslash=0}
andh={hii/primejj/prime,wii/prime/negationslash=0∩wjj/prime/negationslash=0}are all initialized to 0.
At each iteration, the algorithm computes the following
updates:
f(t+1)
ii/prime=wii/prime−/parenleftbigg
max
k/negationslash=ig(t)
ki/prime/parenrightbigg
+−γ(t)
ii/prime
+/summationdisplay
jj/prime/bracketleftBig
wjj/primeii/prime+h(t)
jj/primeii/prime/bracketrightBigwjj/primeii/prime
0
g(t+1)
ii/prime=wii/prime−/parenleftbigg
max
k/prime/negationslash=i/primef(t)
ik/prime/parenrightbigg
+−φ(t)
ii/prime
+/summationdisplay
jj/prime/bracketleftBig
wjj/primeii/prime+h(t)
jj/primeii/prime/bracketrightBigwjj/primeii/prime
0
h(t+1)
ii/primejj/prime=wii/prime−/parenleftbigg
max
k/prime/negationslash=i/primef(t)
ik/prime/parenrightbigg
+−φ(t)ii
/prime
−/parenleftbigg
max
k/negationslash=ig(t)
ki/prime/parenrightbigg
+−γ(t)
ii/prime
+/summationdisplay
kk/prime/negationslash=jj/prime/bracketleftBig
wkk/primeii/prime+h(t)
kk/primeii/prime/bracketrightBigwkk/primeii/prime
0,
where:x+=max(0,x), and[x]b
a=⎧
⎪⎨
⎪⎩=a, ifx≤a,
=x, ifa<x<b
=b, otherwise,
and where we introduced Bertsekas’ /epsilon1-complementary slack-
ness mechanism [35]:
φ(t)
ii/prime=/braceleftBigg
/epsilon1, iff(t)
ii/prime/negationslash=max
k/primef(t)
ik/prime,
0, otherwise.
γ(t)
ii/prime=/braceleftBigg
/epsilon1, ifg(t)
ii/prime/negationslash=max
kg(t)
ki/prime,
0, otherwise.
At the end of iteration t, the estimated mode is achieved
by:
ˆx(t)
ii/prime=/braceleftBigg
=1, ifˆp(t)
Xii/prime>0,
=0, otherwise,
whereˆp(t)
Xii/primedenotes the log-ratio of the estimated marginal
distribution of xii/prime:
ˆp(t)
Xii/prime=wii/prime−/parenleftbigg
max
k/prime/negationslash=i/primef(t)
ik/prime/parenrightbigg
+−φ(t)
ii/prime
−/parenleftbigg
max
k/negationslash=ig(t)
ki/prime/parenrightbigg
+−γ(t)
ii/prime
+/summationdisplay
jj/prime/bracketleftBig
wjj/primeii/prime+h(t)
jj/primeii/prime/bracketrightBigwjj/primeii/prime
0
977REFERENCES
[1] I. U. Haq and J. Caballero, “A Survey of Binary Code Similarity,” ACM
Computing Surveys, vol. 54, no. 3, pp. 51:1–51:38, Apr. 2021.
[2] X. Hu, T.-c. Chiueh, and K. G. Shin, “Large-scale malware indexing
using function-call graphs,” in Proceedings of the 16th ACM conference
on Computer and communications security, ser. CCS ’09. Chicago,
Illinois, USA: Association for Computing Machinery, Nov. 2009, pp.611–620.
[3] O. Kostakis, J. Kinable, H. Mahmoudi, and K. Mustonen, “Improved
call graph comparison using simulated annealing,” in Proceedings of the
2011 ACM Symposium on Applied Computing, ser. SAC ’11. TaiChung,Taiwan: Association for Computing Machinery, Mar. 2011, pp. 1516–1523.
[4] M. Bourquin, A. King, and E. Robbins, “BinSlayer: accurate comparison
of binary executables,” in Proceedings of the 2nd ACM SIGPLAN
Program Protection and Reverse Engineering Workshop, ser. PPREW’13. Rome, Italy: Association for Computing Machinery, Jan. 2013,pp. 1–10.
[5] M. Bayati, M. Gerritsen, D. F. Gleich, A. Saberi, and Y . Wang, “Algo-
rithms for Large, Sparse Network Alignment Problems,” in Proceedings
of the 2009 Ninth IEEE International Conference on Data Mining, ser.ICDM ’09. USA: IEEE Computer Society, Dec. 2009, pp. 705–710.
[6] X. Meng and B. P . Miller, “Binary code is not easy,” in Proceedings
of the 25th International Symposium on Software Testing and Analysis,ser. ISSTA 2016. New Y ork, NY , USA: Association for ComputingMachinery, Jul. 2016, pp. 24–35.
[7] L. Massarelli, G. A. Di Luna, F. Petroni, L. Querzoni, and R. Baldoni,
“Investigating Graph Embedding Neural Networks with UnsupervisedFeatures Extraction for Binary Analysis,” in Proceedings 2019 Workshop
on Binary Analysis Research. San Diego, CA: Internet Society, 2019.
[8] K. Redmond, L. Luo, and Q. Zeng, “A Cross-Architecture Instruction
Embedding Model for Natural Language Processing-Inspired BinaryCode Analysis,” in Proceedings 2019 Workshop on Binary Analysis
Research. San Diego, CA: Internet Society, 2019.
[9] X. Zhang, W. Sun, J. Pang, F. Liu, and Z. Ma, “Similarity Metric
Method for Binary Basic Blocks of Cross-Instruction Set Architecture,”inProceedings 2020 Workshop on Binary Analysis Research. San
Diego, CA: Internet Society, 2020.
[10] M. Cova, V . Felmetsger, G. Banks, and G. Vigna, “Static Detection of
Vulnerabilities in x86 Executables,” in Proceedings of the 22nd Annual
Computer Security Applications Conference, ser. ACSAC ’06. USA:IEEE Computer Society, Dec. 2006, pp. 269–278.
[11] D. Gao, M. K. Reiter, and D. Song, “BinHunt: Automatically Finding
Semantic Differences in Binary Programs,” in Proceedings of the 10th
International Conference on Information and Communications Security,ser. ICICS ’08. Berlin, Heidelberg: Springer-V erlag, Oct. 2008, pp.238–255.
[12] Y . David, N. Partush, and E. Yahav, “Statistical similarity of binaries,”
inProceedings of the 37th ACM SIGPLAN Conference on Programming
Language Design and Implementation, ser. PLDI ’16. Santa Barbara,CA, USA: Association for Computing Machinery, Jun. 2016, pp. 266–280.
[13] X. Xu, C. Liu, Q. Feng, H. Yin, L. Song, and D. Song, “Neural Network-
based Graph Embedding for Cross-Platform Binary Code SimilarityDetection,” in Proceedings of the 2017 ACM SIGSAC Conference on
Computer and Communications Security, ser. CCS ’17. Dallas, Texas,USA: Association for Computing Machinery, Oct. 2017, pp. 363–376.
[14] Y . Li, C. Gu, T. Dullien, O. Vinyals, and P . Kohli, “Graph Matching
Networks for Learning the Similarity of Graph Structured Objects,” inInternational Conference on Machine Learning. PMLR, May 2019,pp. 3835–3845.
[15] S. H. H. Ding, B. C. M. Fung, and P . Charland, “Asm2V ec: Boosting
Static Representation Robustness for Binary Clone Search against CodeObfuscation and Compiler Optimization,” in 2019 IEEE Symposium on
Security and Privacy (SP), May 2019, pp. 472–489.
[16] Y . Duan, X. Li, J. Wang, and H. Yin, “DeepBinDiff: Learning Program-
Wide Code Representations for Binary Difﬁng,” in Proceedings 2020
Network and Distributed System Security Symposium. San Diego, CA:Internet Society, 2020.
[17] H. Gao and H. Huang, “Deep attributed network embedding,” in
Proceedings of the 27th International Joint Conference on ArtiﬁcialIntelligence , ser. IJCAI’18. Stockholm, Sweden: AAAI Press, Jul. 2018,
pp. 3364–3370.[18] H. W. Kuhn, “The Hungarian method for the assignment problem,”
Naval Research Logistics Quarterly, vol. 2, no. 1-2, pp. 83–97, 1955.
[19] T. Dullien, “Graph-based comparison of executable Objects,” SSTIC’05
: Symposium sur la Securite des Technologies de l’Information et desCommunications, Rennes, France, June 2005, 2005.
[20] L. P . Cordella, P . Foggia, C. Sansone, and M. V ento, “A (Sub)Graph
Isomorphism Algorithm for Matching Large Graphs,” IEEE Transactions
on Pattern Analysis and Machine Intelligence , vol. 26, no. 10, pp. 1367–
1372, Oct. 2004.
[21] L. Bahiense, G. Mani ´c, B. Piva, and C. C. De Souza, “The maximum
common edge subgraph problem: A polyhedral investigation,” Discrete
Applied Mathematics, vol. 160, no. 18, pp. 2523–2541, Dec. 2012.
[22] K. Riesen, Structural Pattern Recognition with Graph Edit Distance:
Approximation Algorithms and Applications, 1st ed. Springer Publish-ing Company, Incorporated, 2016.
[23] C.-L. Lin, “Hardness of Approximating Graph Transformation Problem,”
inProceedings of the 5th International Symposium on Algorithms and
Computation, ser. ISAAC ’94. Berlin, Heidelberg: Springer-V erlag,Aug. 1994, pp. 74–82.
[24] K. Riesen and H. Bunke, “Approximate graph edit distance computation
by means of bipartite graph matching,” Image and Vision Computing,
vol. 27, no. 7, pp. 950–959, Jun. 2009.
[25] S. Bougleux, L. Brun, V . Carletti, P . Foggia, B. Gazre, and M. V ento,
“Graph edit distance as a quadratic assignment problem,” Pattern
Recognition Letters, vol. 87, no. C, pp. 38–46, Feb. 2017.
[26] G. N. Lance and W. T. Williams, “Computer Programs for Hierarchical
Polythetic Classiﬁcation (“Similarity Analyses”),” The Computer Jour-
nal, vol. 9, no. 1, pp. 60–64, May 1966.
[27] R. E. Burkard, E. C ¸ ela, P . M. Pardalos, and L. S. Pitsoulis, “The
Quadratic Assignment Problem,” in Handbook of Combinatorial Op-
timization: V olume1–3, D.-Z. Du and P . M. Pardalos, Eds. Boston,MA: Springer US, 1998, pp. 1713–1809.
[28] R. Singh, J. Xu, and B. Berger, “Global alignment of multiple protein
interaction networks with application to functional orthology detection,”Proceedings of the National Academy of Sciences, vol. 105, no. 35, pp.12 763–12 768, Sep. 2008.
[29] S. Zhang and H. Tong, “FINAL: Fast Attributed Network Alignment,”
inProceedings of the 22nd ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining, ser. KDD ’16. New Y ork,NY , USA: Association for Computing Machinery, Aug. 2016, pp. 1345–1354.
[30] M. Zaslavskiy, F. Bach, and J.-P . V ert, “A Path Following Algorithm for
the Graph Matching Problem,” IEEE Transactions on Pattern Analysis
and Machine Intelligence, vol. 31, no. 12, pp. 2227–2242, Dec. 2009.
[31] V . Lyzinski, D. E. Fishkind, M. Fiori, J. T. V ogelstein, C. E. Priebe,
and G. Sapiro, “Graph Matching: Relax at Y our Own Risk,” IEEE
Transactions on Pattern Analysis and Machine Intelligence , vol. 38,
no. 1, pp. 60–73, Jan. 2016.
[32] G. W. Klau, “A new graph-based method for pairwise global network
alignment,” BMC Bioinformatics, vol. 10, no. 1, p. S59, Jan. 2009.
[33] D. Koller and N. Friedman, Probabilistic Graphical Models: Principles
and Techniques - Adaptive Computation and Machine Learning. TheMIT Press, 2009.
[34] A. M. Khan, D. F. Gleich, A. Pothen, and M. Halappanavar, “A mul-
tithreaded algorithm for network alignment via approximate matching,”inProceedings of the International Conference on High Performance
Computing, Networking, Storage and Analysis , ser. SC ’12. Washington,
DC, USA: IEEE Computer Society Press, Nov. 2012, pp. 1–11.
[35] D. P . Bertsekas, “Auction algorithms for network ﬂow problems: A
tutorial introduction,” Computational Optimization and Applications,
vol. 1, no. 1, pp. 7–66, Oct. 1992.
978