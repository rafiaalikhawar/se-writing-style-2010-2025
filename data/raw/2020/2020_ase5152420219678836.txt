Detecting Memory-Related Bugs by Tracking
Heap Memory Management of C++ Smart Pointers
Xutong Ma1,3, Jiwei Y an2,3, Wei Wang1,3, Jun Y an1,2,3,¬ßJian Zhang1,3,¬ßand Zongyan Qiu4
1State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences
2Technology Center of Software Engineering, Institute of Software, Chinese Academy of Sciences
3University of Chinese Academy of Sciences
4School of Mathematical Sciences, Peking University
Emails:{maxt, yanjw, wangwei19, yanjun, zj}@ios.ac.cn, qzy@math.pku.edu.cn
Abstract ‚ÄîThe smart pointer mechanism, which is improved
in the continuous versions of the C++ standards over the last
decade, is designed to prevent memory-leak bugs by automat-ically deallocating the managed memory blocks. However, notall kinds of memory errors can be immunized by adopting thismechanism. For example, dereferencing a null smart pointer willlead to a software failure. Due to the lack of specialized supportfor smart pointers, the off-the-shelf C++ static analyzers cannoteffectively reveal these bugs.
In this paper, we propose a static approach to detecting
memory-related bugs by tracking the heap memory managementof smart pointers. The behaviors of smart pointers are modeledduring their lifetime to trace the state transitions of managedmemory blocks. And the specially designed checkers are used tocheck the state changes according to Ô¨Åve collected bug patterns.To evaluate the effectiveness of our approach, we implement iton the top of the Clang Static Analyzer. A set of handmade codesnippets, as well as nine popular open-source C++ projects, areused to compare our tool against four other analyzers. The resultsshow that our approach can successfully discover nearly all thebuilt-in bugs. And 442 out of 648 reports generated from theopen-source projects are true positives after manual reviewing,where the bugs of dereferencing null smart pointers are mostfrequently reported. To further conÔ¨Årm our reports, we designpatches for Aria2, Restbed, MySQL and LLVM, in which sevenpull requests covering 76 bug reports have been merged by thedevelopers up to now. The results indicate that pointers shouldalways be carefully used even after migrated to smart pointersand static analysis upon specialized models can effectively detectsuch bugs.
Index T erms‚ÄîC++ Smart Pointer, Memory Errors
I. I NTRODUCTION
Due to the bug-prone and inconvenient approaches of
managing heap memory manually in the C/C++ languages,
developers and maintainers have fought for decades againstmemory errors, such as memory leak, null pointer dereference,and so on. Fortunately, the new C++ standards (the continuousversions since C++11) provide the Smart Pointer mechanism
to save them from the morass, which have been widely usedin recent years.
Figure 1 presents the trend of smart pointer usages crossing
the last decade. The lines represent the statistics on GitHubwhen searching with keywords of unique
ptr, shared ptr,
weak ptr and smart pointer. The entries in the Ô¨Ågure indicate
¬ßCorresponding authors2011 2013 2015 2017 2019 202100.20.40.60.811.2¬∑106
(a) Commits2011 2013 2015 2017 2019 2021012¬∑104
(b) Issues
2011 2013 2015 2017 2019 20210200400600
(c) Repositories2011 2013 2015 2017 2019 202101,0002,0003,0004,000
(d) Wiki
unique ptr shared ptr weak ptr smart pointer
Fig. 1: Trend of smart pointer usages on GitHub
the number of the entities which explicitly mention these key-
words. According to the results, more and more projects beginto use smart pointers to manage heap memory approximatelysince 2013 and 2014.
Smart pointers are designed to prevent memory-leak bugs.
The memory blocks assigned to smart pointers can be au-tomatically deallocated when the smart pointers go out ofscope. Besides, as the calls to destructors are scheduled by thecompiler, smart pointers can also prevent use-after-free bugscaused by improperly scheduled manual deallocations [1].
However, using smart pointers cannot immunize all kinds
of memory errors. The undeÔ¨Åned behaviors of smart pointermethods presented in the CPP Reference [2] can lead to
memory errors such as dereferencing null smart pointers andso on. In addition, improper usages of smart pointers, whichare prohibited by the C++ Core Guidelines [3] and widely
used coding regulations [4, 5], can also lead to memory leaksand efÔ¨Åciency issues [6, 7]. In this paper, we call all thesememory-related bugs caused by smart pointers the Misuses of
Smart Pointers (MisSP).
Static analysis is an effective way to check program defects.
8802021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000822021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678836
978-1-6654-0337-5/21/$31.00  ¬©2021  IEEE
However, according to our experiments on a handmade bench-
mark presented in Section V -B1, the off-the-shelf tools cannotprovide satisfactory results. On one hand, some coding stylecheckers like CppCheck [8] and SPrinter [6] can only detect
coding style problems and a few intra-procedural MisSPs insome simple functions. On the other hand, static analyzers likeClang Static Analyzer [9] and Facebook Infer [10] will miss
a lot of real bugs according to our experiments.
The shortcomings of the off-the-shelf analyzers can be
summarized into two aspects: model and checker. On onehand, it is a straightforward approach to model smart point-ers by directly analyzing their implementations in the C++Standard Library. However, as those most commonly usedimplementations (GCC libstdc++, Clang libc++ and MSVCStandard Library) are all very complex, it is difÔ¨Åcult andinefÔ¨Åcient to model the behaviors in this way. On the otherhand, new checkers should also be specially designed to revealthe MisSPs that cannot be reported by memory error checkers.
Facing the shortcomings, we propose our models of smart
pointers and checkers on MisSPs, which can be seen asa smart-pointer extension of the typestate analysis on heapmemory blocks [11, 12]. We extend a general heap memorymodel [13, 14] to handle C++ memory management operationsand cooperate with the model of smart pointers. And a set ofmeta-operations are deÔ¨Åned to model the method calls andrecord the states of smart pointer objects. Besides, we alsodeÔ¨Åne new checkers based on Ô¨Åve error patterns extracted fromthe C++ standard and famous coding regulations. And MisSPsare checked with these checkers according to the states of heapmemory and smart pointers.
We implement an analyzer, Spelton, on the top of the Clang
Static Analyzer [9] and evaluate it with a handmade benchmark
and nine open-source C++ projects. The experimental resultsindicate that our approach can effectively detect MisSPs. Ourmain contributions are listed as follows:
‚Ä¢We model the behavior of smart pointers via a set ofmeta-operations. And the states of heap memory blocksare also extended to be managed by smart pointers;
‚Ä¢An analyzer with checkers specially designed for Ô¨Åveextracted bug patterns is implemented to systematicallyscan for MisSPs on C++ projects;
‚Ä¢Our discoveries and suggestions on using smart pointersare also presented based on our statistics and bug reports.
II. B
ACKGROUND
In this section, we will introduce the usages of smart
pointers, the basic concepts that smart pointers are based on,as well as the different kinds of smart pointers deÔ¨Åned in theC++ standard.
A. Usage of C++ Smart Pointers
To roughly understand how smart pointers work, we present
the comparison of managing memory manually and using
smart pointers. The following two functions implement thesame functionality line by line. They Ô¨Årst allocate a Dog
object, then call its method bark and deallocate it at last.The left snippet manages the object manually, whereas theone on the right-hand side uses smart pointers.
void ManualBark() {
Dog *dog = new Dog;
dog->bark();
delete dog;
}void AutoBark() {
unique_ptr<Dog> dog(new Dog);
dog->bark();// No manual deallocations.
}
The comparison shows their two main differences. First, a
smart pointer object instead of a raw pointer is used to point
to the allocated memory. And second, manual deallocation forthe managed memory is not needed when using smart pointers.
B. RAII and Memory Ownership
1) RAII based Resource Management: C++ smart pointers
are designed based on a common programming idiom in
Object-Oriented Programming called Resource Acquisition Is
Initialization (RAII) or Scope-Bound Resource Management
(SBRM) [15]. The names explain this idiom from its twomain characteristics. First, the resource is allocated during theinitialization of a manager object. And second, their lifetimesare bound to the corresponding scope via the variable ofthe manager object. Therefore, the resource can be properlydeallocated when it is no longer accessible.
The smart pointers take this idiom to manage the memory
blocks assigned to them. More speciÔ¨Åcally, the manuallyallocated objects and arrays will be automatically deallocatedduring the destruction of the smart pointer objects that theyare assigned to. And a smart pointer object will be destructedwhen it goes out of scope as expected (e.g. the function
normally returns) or accidentally (e.g. an exception is thrown
from this scope). As the destruction is scheduled by compilers,the idiom can signiÔ¨Åcantly help to prevent memory errorscaused by improperly scheduled manual deallocations, suchas double-free and use-after-free bugs [1].
2) Ownership of Heap Memory Blocks: Different from
other RAII-based manager classes, such as the Ô¨Åle IO stream,whose resources can only be used through the manager object,the allocated memory can also be used via a raw pointer.To take advantage of both smart pointers and raw pointers,it is suggested by some coding guidelines [3, 4, 5] to usethe memory block through a raw pointer, and leave the smartpointers managing the deallocation of memory blocks only.These suggestions indicate that smart pointers are the owners
of their managed memory blocks.
The ownership of a heap memory block represents the
responsibility of deallocation [16]. If an object has a Ô¨Åeldpointing to a heap memory block and deallocates the blockin its destructor, such as smart pointers, we call these kindsof objects owners. While for other blocks that are manually
deallocated via a raw pointer, their ownership is held bythe programmer. Ownership can be either transferred betweenowners or shared by a group of owners. When ownership isuniquely held by one owner, it can be transferred to other
owners. And this unique owner is responsible to deallocatethe memory. While if the ownership is shared, it cannot be
881T ABLE I: Smart pointers in C++ standard and their features
Name Standard Ownership Dereference Array
auto_ptr C++ 98 unique Ye s N o
unique_ptr C++ 11 unique Ye s Ye s
shared_ptr C++ 11 shared Ye s Ye s
weak_ptr C++ 11 N/A No Y es
transferred but can only be released by one of these owners,
and the last owner reserved will deallocate the memory.
C. Smart Pointer Implementations in C++ Standard
We summarize all kinds of smart pointer classes of the
C++ standard in Table I. The entries presented in the table
include the class Name, the Standard in which the class is
introduced, the kind of Ownership management, whether users
can Dereference the smart pointer, and whether managing
dynamic Array (allocated with operator new[]) is supported.
In C++ 98 standard, the auto pointer (auto_ptr), the Ô¨Årst
smart pointer class, is introduced. However, as a consequenceof its ill-formed copy semantics, it is not widely used. Andit is replaced by the unique pointer (unique_ptr)i nt h eC++11 standard and fully removed in the C++17 standard.
Then in C++11 standard, the concept of smart pointers is
further perfected with three new smart pointers. The uniquepointer is designed as a unique owner, in contrast with the
shared pointer (shared_ptr), which is used as a shared
owner. Besides, to prevent possible memory leaks causedby circular referencing of shared pointers [17], the weakpointer (weak_ptr) is also introduced in the C++11 standard.Different from the two kinds of owners, the weak pointers arenot owners, and they only reference the ownership managedby a group of shared pointers. Therefore, they cannot bedereferenced. To access the memory, a weak pointer needsto be cast to a shared pointer.
Since the auto pointers are deprecated and become seldom
used, we mainly focus on the weak pointers and two owner
pointers (the unique and shared pointer) in this paper.
III. M
ISUSES OF SMART POINTERS
In this section, we will introduce the Misuses of Smart
Pointers (MisSP). A motivating example will Ô¨Årst show the
real-world MisSPs, then each pattern that we extracted isexplained with a simple example.
A. Motivating Example
The code presented in Figure 2 is composed of three real-
world MisSPs found in three different projects [18, 19, 20].
Among them, bug 1 and 2 are found and reported by us,and bug 3 is found from the commit history and can alsobe reported by our tool. There is one class and two functionsin the code. Class Request on line 1 has three methods,
and the other two functions, HandleRequest (line 6) and
Entry (line 11), work with a Request object managed by
a unique pointer.
When using an instance of class Request, users can add
a buffer to the instance via method addBuffer and handle1struct Request {
2 bool addBuffer(char *b);
3 static void HandleWithBuf(Request &R);
4 static void HandleWithoutBuf(Request &R);
5};
6void HandleRequest(unique_ptr<Request> r,
7 bool hasBuffer) {
8 if(r && hasBuffer) Request::HandleWithBuf( *r);
9 else Request::HandleWithoutBuf( *r); //Bug 1
10}
11void Entry(unique_ptr<Request> R) {
12 unique_ptr<char>b ( new char[size]); //Bug 2
13 HandleRequest(move(R),
14 R->addBuffer(b.get())); //Bug 3
15}
Fig. 2: The motivating example
the request with method HandleWithBuf, or users can
call function HandleWithoutBuf directly without adding
a buffer. The buffer added with method addBuffer will not
be deallocated in the class, and the function returns true if
the buffer is successfully added.
Function HandleRequest andEntry implement an
example of handling requests. The execution of the examplestarts from function Entry. A buffer is allocated and assigned
to a unique pointer. Then the buffer is lent to the argumentinstance of class Request. Then the request is moved to
function HandleRequest to be handled.
The three bugs are commented in the example. On line 8,
the nullity of unique pointer ris checked. And it can be
inferred that if pointer ris null, the operator *call on the else
branch (line 9) will dereference a null smart pointer (Bug 1).On line 12, a buffer is allocated with operator new[] and is
then assigned to a unique pointer of type char. This indicates
that operator delete will be used during deallocation, which
cannot be matched with the allocator operator (Bug 2). Andon line 13, the unique pointer Ris moved to the parameter
rof function HandleRequest. Then the operator -> will
dereference a null smart pointer on line 14 (Bug 3).
Although the three bugs can all trigger program crashes,
the off-the-shelf memory error checkers cannot provide uswith desired reports. We tried to scan the example codewith the latest version of two static analyzers (Clang StaticAnalyzer (CSA) [9] and Infer [10]) and two coding style
checkers (CppCheck [8] and SPrinter [6]). Among these four
tools, CSA can only report a use-after-moved bug on line 14,which seems less important than dereferencing a null smartpointer; whereas SPrinter can correctly report bug 2 on line 12,
but the report will be suppressed if there is an intermediateraw pointer forwarding the address. And the other two toolsfail to report any of the bugs.
B. Patterns of MisSPs
The bug patterns of Misuses of Smart Pointers (MisSP) are
extracted from the undeÔ¨Åned behaviors in the C++ standard
(according to the introductions on the CPP Reference [2]) as
well as the rules in the C++ Core Guidelines [3] and the Smart
Pointer guidelines of the Chromium project [5]. Five patterns
are Ô¨Ånally selected, as they are likely to cause a crash or have
882void DereferenceNull() {
unique_ptr<int>p ;
*p=5 ;
}
(a) Dereference Null (DN)void BadAssignment() {
int a=5 ;
unique_ptr<int> p(&a);
}
(b) Bad Assignment (BA)
void TypeMismatch() {
unique_ptr<int> op;
op.reset(new int[5]);unique_ptr<int[]> ap;ap.reset(new int(5));
}
(c) Type Mismatch (TM)struct T
{shared_ptr<T> t; };
void CircularReference() {
shared_ptr<T> t(new T);
t->t = t;
}
(d) Circular Reference (CR)
int use(shared_ptr<int> p2) {
return p2 ? *p 2+5:0 ;
}int UniqueShared() {
shared_ptr<int> p1(new int(5));return use(p1) + 5;
}
(e) Unique Shared (US)
Fig. 3: Examples of Misuses of Smart Pointers
efÔ¨Åciency issues that have not been paid enough attention
to. We will further introduce the reason why these patternsare selected and what the other patterns are in Section VI.These Ô¨Åve kinds of MisSPs can be illustrated with the simpleexamples presented in Figure 3.
Dereference Null (DN). The term dereference null is short
for dereferencing a null smart pointer. Similar to raw pointers,dereferencing a null smart pointer will also lead to a crash. Forthe two kinds of owner smart pointers, i.e. the unique and the
shared pointers, they can be dereferenced via the overriddenoperator arrow (->), star (*) and subscription ([]). There-
fore, we report a dereference null bug if these operators are
called with a null smart pointer.
Bad Assignment (BA). The memory managed by owner
smart pointers will always be deallocated. Therefore, when asmart pointer points to a memory block that should not bedeallocated, such as stack memory and so on, we will reportthe assignment as a bad assignment bug.
Type Mismatch (TM). The type argument of the
smart pointer will determine whether operator delete or
delete[] will be used to deallocate the memory. If it does
not match with the allocator of the managed memory, we willreport a type mismatch bug on the assignment.
Circular Reference (CR). All reference-counting-based
memory management mechanisms suffer the circular referenc-ing problem, so are the shared pointers. However, a garbagecollector is not available for shared pointers to reclaim thememory in the cyclic structures. When a ring of memoryblocks is connected with smart pointers, we will report acircular reference bug.
Unique Shared (US). Shared pointers consume more
memory and time than unique pointers [7] during execution.Besides, shared pointers are infectious. When a shared pointeris used, all related pointers should also be replaced with sharedpointers. Since there would be many shared pointers used, it isusually hard to infer which shared pointer actually deallocatesthe managed memory [5]. Therefore, as a consideration ofprogram efÔ¨Åciency and maintainability, unique pointers shouldbe used if the ownership is not semantically shared [3].
In the example, the parameter p2 is only dereferenced
without sharing the ownership to other objects or containers.And pointer p1 is used to automatically deallocate the memory
and satisfy the interface of calling function use. In this case,
we will report a unique shared bug for pointers p1 andp2.
The solution is to change pointer p1 to a unique pointer to
manage the memory block and replace p2 with a raw pointer
to dereference the memory.
IV . A
PPROACH OF CHECKING MISSP S
In this section, starting with the workÔ¨Çow, we will intro-
duce our extension of memory block states, models of smartpointers, as well as checkers for the bug patterns. And a casestudy on the motivating example will be presented at the endof this section to concretely illustrate our approach.
A. Overview of WorkÔ¨Çow
To explain how MisSPs are checked, we present the work-
Ô¨Çow of our approach in Figure 4. The components surrounded
with dashed lines represent the ones that are newly added tomodel and check smart pointers.
6RXUFH&RGH
%XJ5HSRUWV
 &KHFNHUVIRU0LV63V
6PDUW3RLQWHU
0RGHOHU
3URJUDP6WDWH
∆î 6WDWHRI0HPRU\%ORFNV
∆î 6WDWHRI6PDUW3RLQWHUV0HPRU\0RGHOHU
6WDWHPHQW
(YDOXDWRU
0HPRU\
2SHUDWLRQV
6PDUW3RLQWHU
2SHUDWLRQV0HPRU\
2SHUDWLRQV‰ë∂‰ë∑
‰ë∏
‰ëπ
Fig. 4: WorkÔ¨Çow of checking MisSPs
The Statement Evaluator will parse the input Ô¨Åle and
analyze each function according to the topological order ofthe call graph. It is used to explore program paths andevaluate the encountered statements that are not related toheap memory and smart pointers. For the operations on rawpointers and memory blocks, they are modeled by the Memory
Modeler (Section IV -C), which is a typestate analysis on the
heap memory blocks. And the Smart Pointer Modeler (Sec-
tion IV -D) extends the typestate analysis with new states andoperations of heap memory and smart pointers.
The modelers will modify the Program State (Section IV -B)
according to the operations executed. And if a smart pointeroperation needs to modify the state of its managed memoryblock, the Memory Modeler will be invoked by the Smart
Pointer Modeler to handle the corresponding memory op-
erations. When applying the model, the states of memoryblocks and smart pointers will be checked by the Checkers
for MisSPs (Section IV -E) and bug reports will be generated
if any MisSPs are found.
B. Program State
The program states record the states of memory blocks
and smart pointers. We use Mem to represent the set of
all valid heap memory blocks, which is composed of the
883allocated memory set AM , the set of captured memory from
external contexts EM and the set of null pointer values Œõ.F o r
simplicity, we use Œªto refer to the global null pointer constant.
And Set Ptr is used to denote all of the smart pointer objects
among the entire program, together with set Var to represent
all variable names in the code.
In the C++ language, three pairs of allocators and dealloca-
tors are used to manage heap memory: managing raw blocks
with function malloc, free and so on, managing dynamic
objects with the operator new anddelete, and managing
dynamic arrays with the operator new[] anddelete[].
We use enumerate value Raw ,Object andArray to rep-
resent the type of the allocators and deallocators that are
used in these three kinds of memory management approachesrespectively. And for simplicity, the set {Raw,Object,Array}
is represented as ADT . Besides, value Any is used as the
type of the allocator of a memory block captured from theexternal context, which indicates that we do not know howit is allocated, and it can be reclaimed with all kinds ofdeallocators. And there are no deallocators of type Any .
With the deÔ¨Ånitions of the above sets, we deÔ¨Åne the program
state as a triplet S=/angbracketleftM,P,Q/angbracketrightwhere
‚Ä¢M‚äÜMem is the set of monitored memory blocks that
are being analyzed in the current context;
‚Ä¢P‚äÜPtr indicates the set of all traced smart pointers;
‚Ä¢Q:M‚ÜíP(P)represents the map from a monitored
memory block to the set of all its owner smart pointers.
For a monitored memory block m‚ààM, it is deÔ¨Åned as a
tripletm=/angbracketleftid,at,st/angbracketrightwhere
‚Ä¢id‚ààNis a natural number used as the identiÔ¨Åer of the
memory block;
‚Ä¢at‚ààADT‚à™{Any}represents its allocator type;
‚Ä¢st‚ààMemSt denotes the state of the memory block,
where the set of all states is MemSt ={Allocated ,
Captured ,Escaped,Usable,Null,Freed,Bad}.
And we deÔ¨Åne a traced smart pointer p‚ààPas a triplet p=
/angbracketleftvn,dt,tm/angbracketrightwhere
‚Ä¢vn‚ààVar is its variable name used as a unique identiÔ¨Åer;
‚Ä¢dt‚ààADT represents the type of its pending deallocator;
‚Ä¢tm‚ààMem indicates the memory block it points to.
When a monitored non-null memory block m‚ààM\Œõis
assigned to a traced owner pointer p‚ààP,w eh a v e p.tm=m.
And it is required that pointer pshould be added to block m‚Äôs
owner set Q[m] and removed after unassigned.
In the following subsections, we will introduce the oper-
ations on memory blocks and smart pointers, as well as thetransitions of the program state.
C. Modeling State Transitions of Memory Blocks
The state transitions of memory blocks are modeled with the
Memory Modeler. For a memory block m, its identiÔ¨Åer m.id
and allocator type m.atare determined when it is created, and
will not be changed then. However, the operations performed
on memory blocks will change its state m.st. To support
checking C++ code with smart pointers, we extend the state5‡¨Ω€†›Ü‹º›±‡≠í‹ºV›Æ
'›±›±$‡¨Ω/›±‡≠Ö‡¨∂‡¨ª
$'›±›±‡¨Ω›±›Æ&‡¨Ω‡¨∫‡≠Å/‡≠Ö‡¨∂‡¨ª
&›Æ‡¨Ω‡¨∫‡≠Å/‡≠Ö‡¨∂‡¨ª$OORFDWHG (VFDSHG
1XOO%DGGG'‡¨Ω›±PDW%‡¨∂‡¨ª'‡¨Ω›±PDW
'
'‡¨Ω›±PDW
8VDEOH%‡¨∂‡¨ª'‡¨Ω›±PDW
&DSWXUHG)UHHG
Fig. 5: State transitions of memory blocks
transitions of heap memory, which are widely used to checkmemory errors [13, 14].
The operations on a memory block are composed of three
kinds of D
EALLOCA TE operations of the ADT types, as
well as the C HECK ,L OAD and R ELINQUISH operations. To
distinguish different kinds of D EALLOCA TE operations, for a
deallocator of type t, function D EL(t)is used to represent the
corresponding D EALLOCA TE operation. And for a monitored
memory block m, we deÔ¨Åne another function B ADDEL(m.at)
to represent the set of D EALLOCA TE operations with mis-
matched deallocators, where
BADDEL(m.at)=/braceleftBig
‚àÖ m.at =Any
{DEL(t)|‚àÄt‚ààADT\{m.at}} m.at‚ààADT
Figure 5 presents the state transitions of a memory block
m, where A LLDELrepresents all three kinds of D EALLOCA TE
operations. The operations that will not change the states areomitted for simplicity.
For an allocated memory block m
a‚ààAM , its initial state
isAllocated. And the type of the corresponding allocator will
be stored as its allocator type ma.at.I fm ais then managed
by a group of shared pointers, and one of the pointers is sentto an uninterpreted function or inserted into an STL container,operation R
ELINQUISH will change its state to Escaped.
For a memory block mecaptured via an external pointer
(me‚ààEM ), its initial state is Captured and its allocator type
is set to Any. On one hand, if meis directly dereferenced
via operation L OAD , we will modify its state to Usable.
On the other hand, if its nullity is checked with operation
CHECK , the state will be changed to Usable on the then branch
whereas Null on the else branch. The Usable state indicates
that memory block meis conÔ¨Årmed to be non-null on the then
branch. While the Null state on the else branch represents me
is a null constant, and block mewill also be moved from the
set of external memory EM to the null constant set Œõ.
All the Allocated, Escaped and Usable memory blocks can
be deallocated. The only exception is the Escaped memory
blocks whose deallocation via shared pointer destructors willbe omitted, as we cannot know whether there are any otherowners left. When a memory block mis reclaimed with the
D
EALLOCA TE operations that are not in the invalid deallocator
set B ADDEL(m.at), its state can be changed to Freed.
Apart from the transitions mentioned above, there are also
edges representing memory errors, which will change the statetoBad. These errors are mismatched memory management
routines (Allocated and Escaped toBad ),use after free (Freed
toBad ) and null pointer dereference (Null toBad ).
884D. Modeling Operations on Smart Pointers
The Smart Pointer Modeler manages the state transitions of
smart pointer objects. The states mainly focus on assignments
and ownership management. When a new smart pointer p
is deÔ¨Åned or an external one is referred to for the Ô¨Årsttime, we will create an object for it. Its variable name p.vn
and deallocator type p.dt are directly set according to its
declaration and will not be changed during its lifetime. Itsvaluep.tm will be assigned to the null pointer constant Œº
before it is further used via other operations.
As the owner pointers and weak pointers have differences
in ownership management, we will separately introduce theiroperations in the next two subsections.
1) Owner Smart Pointer Operations: To model the as-
signment of owner pointers, we deÔ¨Åne two meta-operations,
S
ET and U NSET , to assign or unassign a smart pointer. Their
operational semantics are presented below.
[SET]p‚ààP, m‚ààM, p. tm‚ààŒõ,p /‚ààQ[m]
SET(p, m):p. tm:=m, Q[m]: = Q[m]‚à™{p}(1)
[UNSET]p‚ààP, m‚ààM, p. tm=m, p‚ààQ[m]
UNSET(p):p.tm:=Œº, Q[m]: = Q[m]\{p}(2)
The S ET operation assigns a memory block mto an empty
smart pointer pwhereas the U NSET operation clears a previous
assignment. When assigning with operation S ET(p,m) , the
value of the assigned pointer p.tm will be modiÔ¨Åed to the
assigned memory block m, andpwill be added to m‚Äôs owner
setQ[m]; vice versa for operation U NSET(p). After operation
UNSET , the pointer will be reassigned to null.
With the deÔ¨Ånition of two meta-operations and operations
on memory blocks, we can now deÔ¨Åne the operations onowner pointers. The operational semantics of these operationsare presented below. Among these operations, apart from the
S
HARE operation which can only be used on a shared pointer,
the others can be applied to both kinds of owner pointers.For simplicity, we will omit the preconditions of requiring thementioned pointers to be traced (p ‚ààP).
[CLEAR]|Q(p.tm)|=1
CLEAR(p):DEL(p.dt)(p.tm);UNSET(p)(3)
|Q(p.tm)| /negationslash=1
CLEAR(p):UNSET(p)(4)
[ASSIGN]m‚ààM, m. st/‚àà{Freed ,Bad},Q[m]=‚àÖ,
m.at=Any‚à®(m.at/negationslash=Any‚àßm.at=p.dt)
ASSIGN(p, m): CLEAR(p);SET(p, m)(5)
[SHARE]SHARE(p1,p2):CLEAR(p2);SET(p2,p1.tm) (6)
[MOVE]MOVE(p1,p2):CLEAR(p2);SET(p2,p1.tm);UNSET(p1)(7)
[ACCESS]p.tm/‚ààŒõ
ACCESS(p):LOAD(p.tm)(8)
[INSPECT]INSPECT(p):CHECK(p.tm) (9)
Operation C LEAR is used to break the original assignment,
which is used when destructing or reassigning a smart pointer.For a unique pointer and the last live shared pointer, deÔ¨Åni-tion (3) is used to deallocate the managed memory block andset the pointer to null. Whereas when clearing an empty smartpointer or one of a group of shared pointers, deÔ¨Ånition (4) canunassign the pointer and leave the memory unchanged.
In contrast with operation C
LEAR , three operations are used
to assign an owner pointer. Operation A SSIGN is used to re-
assign a pointer. The S HARE operation is used to share the
ownership with another shared pointer. And operation M OVE
can transfer the ownership from one smart pointer to another.When assigning an owner pointer, the previous assignmentwill be canceled with operation C
LEAR , and then the new
value will be assigned with operation S ET. And for the M OVE
operation, the source pointer will also be cleared.
The other two operations, A CCESS and I NSPECT , are just
wrapped memory block operations. They are used to L OAD
or C HECK a memory block respectively.
The preconditions of A SSIGN and A CCESS operation are
used to check the MisSPs. We will further introduce them inSection IV -E.
2) Weak Pointer Operations: For the weak pointers, as they
do not manage the ownership and cannot be dereferenced, theyonly have two operations: C
AT C H and L OCK . The correspond-
ing operational semantics are presented below.
[CA TCH]CAT C H(pw,ps):p w.tm:=ps.tm (10)
[LOCK]pw.tm=m‚àßm.st=Captured
LOCK(ps,pw):CHECK(m);LOCK(pw,ps)(11)
pw.tm=m‚àßm.st‚àà{Allocated ,Escaped ,Usable}
LOCK(pw,ps):SHARE(pw,ps)(12)
pw.tm=m‚àßm.st‚àà{Null ,Freed ,Bad}
LOCK(pw,ps):CLEAR(ps)(13)
The C AT C H operation is used to reference the ownership
of a group of shared pointers. As the weak pointers are notowners of the managed memory block m, we will only reset
the value without adding the pointer to the owner set of thepointee memory block Q[m].
And the L
OCK operation is used to create a new shared
pointer from the referenced ownership. If a weak pointerpointing to a memory block mwith a Captured state, operation
C
HECK will be Ô¨Årst used to determine its nullity, and a shared
pointerpswill be created with a recursive call on both the
Usable and Null branches. When the state of misAllocated,
Escaped orUsable, the created shared pointer pswill share
the ownership of m. And if mcannot be dereferenced, i.e.
Freed, Null orBad, a null shared pointer will be created. A
weak pointer is expired when its memory block is deallocated.
E. Checkers for MisSPs
The checkers are specially designed for the Ô¨Åve patterns.
The states of related memory blocks and smart pointers, aswell as the owner sets Qwill be checked by the checkers.
The precondition of operation A
CCESS (p.tm/‚ààŒõ) requires
the dereferenced smart pointer should not point to a nullconstant, which is used to check the dereference null bugs.
Besides, to detect such bugs caused by expired weak pointers,we suppose the Ô¨Årst shared pointer created by operation L
OCK
on an external weak pointer is always the last remaining owner.And when the managed memory is therefore deallocated, the
885T ABLE II: State transitions of the motivating example
Line Statement Operation Monitored Memory Block Set ( M) Traced Smart Pointer Set ( P) Map of Owner Sets (Q )
11 BEGIN - ‚àÖ‚àÖ ‚àÖ
12 new char[] Allocate Array {/angbracketleftm 1,Array ,Allocated /angbracketright} ‚àÖ {m1:‚àÖ}
12 b(m 1) ASSIGN (b,m 1){/angbracketleftm 1,Array ,Allocated /angbracketright} {/angbracketleftb, Object ,m1/angbracketright} {m1:{b}}
13 R N:MOVE(R,r){/angbracketleftm 1,Array ,Allocated /angbracketright,/angbracketleftm2,Any ,Captured /angbracketright} {/angbracketleftb, Object ,m1/angbracketright,/angbracketleftR,Object ,m2/angbracketright} {m 1:{b},m 2:{R}}
13 move(R) MOVE(R,r){/angbracketleftm 1,Array ,Allocated /angbracketright,/angbracketleftm2,Any ,Captured /angbracketright} {/angbracketleftb, Object ,m1/angbracketright,/angbracketleftR,Object ,Œº/angbracketright,{m1:{b},m 2:{r}}
/angbracketleftr,Object ,m2/angbracketright}
6 BEGIN - ‚àÖ‚àÖ ‚àÖ
8 r N:INSPECT (r){/angbracketleftm 1,Any ,Captured /angbracketright} {/angbracketleftr,Object ,m1/angbracketright} {m1:{r}}
8 if (r) INSPECT (r):T {/angbracketleftm 1,Any ,Usable/angbracketright} {/angbracketleftr, Object ,m1/angbracketright} {m1:{r}}
8 if (r) INSPECT (r):F {/angbracketleftm 1,Any ,Null/angbracketright} {/angbracketleftr, Object ,m1/angbracketright} ‚àÖ
weak pointer will get expired and the future calls to operation
LOCK will generate null pointers only.
For operation A SSIGN , two kinds of bugs will be checked
on the assigned memory block m. The Ô¨Årst three clauses
of its preconditions require that block mshould have been
monitored and can be deallocated (m ‚ààM), and not in
deallocated or error state (m. st/‚àà{Freed,Bad}), or managed
by other owners (Q [m]=‚àÖ). If block mviolates any of the
conditions, it will trigger a bad assignment bug.
And the last clause requires that the memory block mis
either a captured external one (m. at=Any ), or is allocated
in the current context (m. at/negationslash=Any ) and the deallocator type
of the assigned smart pointer pcan match its allocator type
(m.at=p.dt). A type mismatch bug will be reported if the
condition is unsatisÔ¨Åable.
Acircular reference bug is deÔ¨Åned as a ring of memory
blocks linked with smart pointers. We use the owner set Qof
each monitored memory block to create the point-to graph. If
a cyclic structure can be found in the graph starting from thenewly assigned memory block, it means the assignment trig-gers a circular reference bug. The circular reference checker
is invoked every time after operation A
SSIGN .
To check the unique shared bugs, the owner set of a memory
block should be tracked when it is assigned to a shared pointer.When calling operation A
SSIGN with a shared pointer p,i t
will be recorded as the Ô¨Årst owner of the assigned memoryblock. And when operation C
LEAR on pointer pdeallocates its
managed memory (deÔ¨Ånition 3), it means that the ownership isuniquely held by the Ô¨Årst owner pand should be replaced with
a unique pointer. Besides, when the Ô¨Årst owner p
1is the only
remaining owner of its managed memory block, and operation
MOVE transfers its ownership to another shared pointer p2,
pointerp2will become the new Ô¨Årst owner.
F . Case Study on Motivating Example
In this subsection, we use the motivating example in Fig-
ure 2 to concretely illustrate how our checkers work. Theprogram state transitions are presented in Table II. The sufÔ¨ÅxesTand Fof operation I
NSPECT represent the state on the
true orfalse branch respectively, and preÔ¨Åx N denotes
the changed state before an operation.
The analysis starts from the top-level function among the
call graph, i.e. function Entry. At the beginning of the
function (line 11), the state is empty. The Ô¨Årst statement inthe function is the new[] operator call on line 12. It willcreate a memory block object of /angbracketleftm
1,Array,Allocated /angbracketright.A s
the block is not assigned to a smart pointer, its owner setQ(m
1)is left empty.
Next, the memory block m1will be assigned to smart
pointer bvia operation A SSIGN(b,m 1)on line 12. Before
that, pointer bwill be created as /angbracketleftb,Object,Œº/angbracketright. Then in
the operation, the checkers found that the last clause of theprecondition, m
1.at=Any‚à®(m1.at/negationslash=Any‚àßm1.at=b.dt)
is violated, where b.dt=Object andm1.at=Array .
Therefore, a type mismatch bug will be reported here. As
the error will not make the program crash, the analysis willcontinue. After the assignment, the pointer bwill be changed
to/angbracketleftb,Object,m
1/angbracketright, and it is added to the owner set of memory
blockm1.
After that, we will evaluate the arguments for the call to
function HandleRequest on line 13. As the evaluation
order of the arguments is undeÔ¨Åned in the C++ standard, wewill Ô¨Årst evaluate the call to function std::move and then
the arrow operator call of smart pointer R.
The function call to std::move on line 13 will trigger
operation M
OVE(R,r), which moves the ownership from the
parameter Rof function Entry to the parameter rof function
HandleRequest. After that, pointer Rwill be cleared, and
pointer rwill take the ownership of memory block m2.
Finally, on the next line, operation A CCESS(R)in the arrow
operator call of pointer Rwill trigger a dereference null bug,
as it breaks the precondition of the A CCESS operation. And
the analysis on this path is therefore terminated here.
As there are no remaining paths for function Entry, the
analysis will restart from function HandleRequest (line 6).
When checking the nullity of smart pointer r, a memory
blockmwith state Captured will be recovered to pointer r.
Then operation I NSPECT(r) will fork the path and change
the state of m toUsable orNull on the true orfalse
branch respectively. And a dereference null problem will be
then reported on the false branch with operation A CCESS(r)
when calling operator *of pointer r.
V. E V ALUA TION
To evaluate the effectiveness of our model and the ability
to reveal MisSPs, we carried out three groups of experimentsto answer the following three research questions.
‚Ä¢RQ 1: Effectiveness. How many handmade and real-world
MisSPs can be detected by our tool?
886‚Ä¢RQ 2: Usability. How much time and memory will be
consumed? What are the reasons for false alarms?
‚Ä¢RQ 3: Discoveries. What can we know about MisSPs
from our statistics?
The Ô¨Årst research question evaluates the effectiveness of our
tool. We use a handmade benchmark and nine open-source
C++ projects to present the effectiveness of our tool, andcompare the ability to detect MisSPs with the off-the-shelfopen-source static analysis tools. The comparison is presentedin Section V -B1 and V -B2. To evaluate the usability, we alsomeasure the time and memory cost of our tool on the open-source projects. And the composition of false positives andtheir reasons are also discussed in Section V -C. The thirdresearch question is used to present the discoveries duringchecking MisSPs. The corresponding empirical conclusionsand hints on using smart pointers are presented in Section V -D.
A. Setup of Experiments
1) Implementation: We implement our tool, Spelton, on top
of the symbolic execution engine of the Clang Static Analyzer
(CSA) [9] 9.0.0 with all its original checkers disabled. The
original CSA has very limited support of Cross Translation
Unit (CTU) analysis, i.e. inlining inter-Ô¨Åle function calls. To
help Spelton to Ô¨Ånd the desired inter-Ô¨Åle function deÔ¨Ånitions
and import them to the current analysis context, we also im-proved the features and Ô¨Åxed the bugs in CSA 9.0.0. Besides,to speed up the analysis process and take full advantage ofthe system resources, GNU Make [21] is used to concurrently
generate CTU function indexes as well as analyze the codefor each source Ô¨Åle. Therefore, our Spelton can be considered
as a standalone MisSP Ô¨Ånding tool.
When analyzing an input Ô¨Åle, the analysis engine of the
CSA will handle the static symbolic execution process, anditsChecker mechanism is used to model the smart pointer
method calls and check for MisSPs. When a smart pointermethod is called, instead of inlining the callee, we will applythe corresponding operations of smart pointers and memoryblocks, and check MisSPs based on our error patterns.
2) Environment and Tools: We set up all of our exper-
iments on a Linux server with two Intel
¬ÆXeon¬ÆE5-2680
v4 CPUs of 56 threads and 256 GB of memory in total. Weevaluate our tool against four off-the-shelf tools of the latestversion including Clang Static Analyzer (CSA) 11.0.1 [9],
Infer Static Analyzer (Infer) v1.0 [10], CppCheck v2.3 [8] and
SPrinter v1.1 [6].
3) Benchmark Composition: Our benchmark is composed
of two parts: handmade snippets and open-source projects.
The Ô¨Årst part is the 912 handmade code snippets which
are used to test the ability to model the behaviors of smartpointers and check the inserted MisSPs. Table III presents thedetailed statistics of the handmade benchmark. The number ofFiles, inserted bugs ( Pos.) and corresponding Ô¨Åxes (Neg.) are
presented for each category.
The Ô¨Årst group of 486 snippets is automatically generated
by imitating the Juliet Test Suite v1.3 (JTS) [22]. We manually
created 16 bug templates by replacing the invoked methods inT ABLE III: Statistics of handmade snippets. The imitatedones are grouped with bug types and the mutated ones arecategorized with their original CWE IDs.
TypesImitated Snippets Mutated SnippetsTotal
DN BA TM CR US C415 C476 C590 C762
Files 306 36 72 54 18 36 72 238 80 912
Pos. 342 36 72 54 18 104 72 238 82 1,018
Neg. 495 66 132 99 33 132 132 343 224 1,656
T ABLE IV: Information of the open-source project instances.Statistics of smart pointer utilization are presented as follows:the numbers of smart pointers of class members (#F), localvariables (#L) and reference variables (#R), as well as methodcalls with A
CCESS operations (#A) among all calls (#All).
Project Commit KLoc #F #L #R #A / #All
Aquila d5e3bd 15.92 0 3 4 9 / 9
Aria2 9d0a48 125.19 1,991 344 807 5,479 / 6,773
Celero 0d7b24 8.37 5 7 105 176 / 191
Evpp 867645 60.13 72 65 94 690 / 933
Osrm 15f0ca 746.33 11 22 83 384 / 567
Restbed 03f1f2 22.86 104 64 242 734 / 877
Spdlog 3dedb5 32.55 1 0 43 26 / 26
MySQL ee4455 3,633.72 230 234 996 2,803 / 5,088
LLVM bbd4eb 5,842.38 1,089 980 3,734 15,788 / 20,824
Ô¨Ågure 3 with the ones of the same functionality, and addingtests on our model of smart pointers. A part of them isdesigned for both unique and shared pointers, while others arefor shared pointers only. The test code snippets are generatedby applying the bug templates on 18 control Ô¨Çow templatesextracted from the JTS.
The remaining 426 snippets are semi-automatically mutated
from four types of memory errors in the JTS. For each typeof memory errors selected, we Ô¨Årst manually design how tomutate the bug to one of the patterns we check. Then, wecarry out the mutation on the original snippets and merge thesimilar ones where only their data types of the pointers aredifferent. And Ô¨Ånally, the snippets are manually reviewed toremove the invalid ones that cannot be analyzed by CSA.
The second part of our benchmark is composed of nine C++
open-source projects from GitHub, as shown in Table IV. The
selected projects are all written in C++11 or newer versions ofC++ standards whose usability is important in their applicationÔ¨Åelds: backend services, performance benchmarks, networklibraries and compilers. For each project, we use their latestversions when carrying out the experiments. The correspond-ing commit hashes and kilo lines of code are presented in thesecond and third columns. Besides, to present their utilizationof smart pointers, we also provide the corresponding statisticsin the last four columns.
B. Evaluation on Effectiveness
We evaluate the effectiveness of Spelton against four other
off-the-shelf tools on the handmade benchmark as well as the
open-source C++ projects.
1) Effectiveness on Handmade Benchmark: In this experi-
ment, the precision and recall of all Ô¨Åve tools are evaluated.
887T ABLE V: Effectiveness on handmade benchmark
Tool Spelton CSA Infer CppCheck SPrinter
TP 1016 72 0 172 206
TN 1656 1656 1656 1656 1656
FP 0 0 0 4 10
FN 2 946 1018 846 812
Precision 100.00% 100.00% N/A 97.73% 95.37%
Recall 99.80% 7.07% N/A 16.90% 20.24%
F1 99.90% 13.21% N/A 28.81% 33.39%
The purpose of this experiment is to use these straightforward
bugs to check their ability to reveal the MisSPs.
Table V presents the statistics of these measures. Among the
reports of these tools, the unrelated true reports are removedbefore counting, while the false ones are recorded as falsepositives. The Ô¨Årst four rows present the number of True orFalse, Positives or Negatives. And the last three rows showthe precision, recall, and F1-measure values.
According to the table, Spelton can Ô¨Ånd almost all bugs with
no false alarms. The only two false negatives are caused byimproperly handled switch-case statements. While other
tools can only detect a part of bugs with false positives.
2) Effectiveness on Open-Source Projects: To evaluate the
effectiveness on real-world C++ code, we run these tools onnine popular open-source C++ projects. Compared with thehandmade benchmark, these real-world projects have massivecode (8‚Äì5,842 Kloc each project) and complex features. Theresults are presented in the left two groups of Table VI, wherethe empty cells indicate no bugs are reported.
The Ô¨Årst group of columns provides how many bugs are
reported by the four other off-the-shelf tools. As there aretoo many reports to review, we use the information of smartpointer variables presented in Table IV to automatically Ô¨Åndthe reports related to smart pointers. The Ô¨Ålter selects 151reports (shown with the numbers in parentheses), and onlyone report of CSA and two reports of SPrinter are true bugs
with manual review. The bugs missed by Spelton are those
memory errors triggered with raw pointers cooperating withsmart pointers. We will have a discussion on such memoryerrors in Section VI.
For the results of Spelton in the second group, the number
of reports is categorized with their types of bug patterns, andthe results are presented with the ratio of true positives toall reports. According to the table, 442 out of 648 reportsgenerated by our tool are recognized as real bugs after amanual review. And the most frequently reported bugs are thedereference null bugs.
To further conÔ¨Årm the true positives generated by Spelton,
14 patches are designed and submitted to the developers,where related bugs are Ô¨Åxed together within one patch. Bynow, seven patches have been merged, and Ô¨Åve patches havenot been reviewed yet. Besides, one has been Ô¨Åxed before wesubmitted it; and one has been conÔ¨Årmed by the developers asa true bug, but they do not intend to Ô¨Åx such kinds of bugs.Among the merged patches, bugs in 76 reports are Ô¨Åxed.C. Evaluation on Usability
The usability of Spelton is evaluated with the cost of time
and memory. Besides, the reasons for our false positives in theopen-source projects are also discussed in this Section.
1) Evaluation on Time and Memory Cost: The total time
and memory costs of Spelton are presented in the last two
groups of Table VI. The time cost is measured in seconds,while for the memory cost, we measure the peak memory costcollected from the process status. For best performance, weoptimize Spelton with-O3 option. The Max cost is measured
for each input Ô¨Åle, and the Average value is computed for
every kilo line of source code.
According to the measurements, a project with the average
size of all evaluated projects (1,165.27 Kloc) can be ana-lyzed with 37,421.16 seconds and 8,913.68 MB of memorysequentially, or with approximately 1.3 hours and 69.64 GBof memory under an eight-thread concurrency.
2) Discussion on False Positives: More than a half (115
out of 208) of the false positives are triggered by the codethat is not analyzed. They can be separated into three groups.
The Ô¨Årst group is the uninterpreted functions, which indi-
cates Spelton cannot Ô¨Ånd the deÔ¨Ånition of a callee function.
The reasons include 1) the function is a third-party libraryfunction whose deÔ¨Ånition is not provided, 2) it is a virtualfunction call on an object with an unknown type, and 3) afailed CTU indexing or importing of the invoked externalfunctions. There are 22 reports clustered to this group.
The second group is the implicit constraints. These con-
straints hold among the entire program, but fail to be collectedin the current analysis context. For example an iterator classin LL VM, the nullity of its unique pointer Ô¨Åeld representswhether it is the end iterator or not. When analyzing the
code, as we cannot collect this constraint in the current context,Spelton will assume that an iterator with such a null pointer is
not the end iterator. It will therefore generate a dereference
null report at the dereference site of the iterator. And 88 false
reports can be categorized into this group.
The last group is the disabled assertions, where the assert
macros in the code are replaced with a void expression whenthe code under analysis is compiled with assertions disabled.As the conditions in the assertions are removed during pars-ing, Spelton cannot add the corresponding constraints in the
assertions, and therefore lead to false positives. There are 5false reports in this group.
Besides, 78 unique shared reports considered false ones may
still be true bugs or helpful to developers. In Spelton, we check
the unique shared bugs for every unique path. Therefore, we
will report the paths that do not share the ownership, whenthere are other paths in this function sharing the ownership.Since we cannot make sure whether all the involved sharedpointers can be replaced with unique and raw pointers. Forthe sake of conservation, we mark them as false positives.
There are 3 false positives of type bad assignment triggered
via the feature of user-customized deleters. This feature allows
users to determine what is to be done in the D
EL operation.
Therefore, it will still be correct when a non-heap memory
888T ABLE VI: Evaluation on open-source C++ projects
ProjectsReports of Compared Tools Reports of Spelton Time Cost (Sec) Memory Cost (kB)
CSA Infer CppCheck SPrinter DN BA TM CR US Max Average Max Average
Aquila 81 7 7/7 10.64 22.11 1,059.40 1,772.88
Aria2 4(1) 12 2(2) 6/7 15/28 162.87 32.68 4,327.29 1,682.89
Celero 3 3/3 0/1 0/2 21.12 16.17 1,591.04 1,233.15
Evpp 47(9) 14(6) 12 1 3/3 11/15 228.47 61.27 3,952.66 1,475.53
Osrm 14 12 20 0/1 6/6 401.43 8.69 5,226.96 259.47
Restbed 2 254(18) 34 1/1 0/2 2/4 237.73 26.76 1,931.03 463.75
Spdlog 13 3/3 15.10 1.91 312.88 52.67
MySQL 1637(14) 1668(2) crash 89(37) 51/59 0/4 2/2 6/14 593.48 14.94 7,530.18 400.40
LLVM 657(35) 5567(18) 326 59(9) 261/364 3/3 0/3 62/116 3,086.51 45.72 20,308.85 1,220.18
Total 2361(59) 7539(44) 412 151(48) 322/435 3/9 2/2 3/7 112/195 - 289.02 - 7,833.03
block is assigned to a smart pointer with a deleter that does
not deallocate the memory. As this feature is seldom used, wedo not model this feature in Spelton.
The remaining false reports include 7 reports for we con-
sider the reported site may be written on purpose by thedevelopers, and 5 reports that are too complex to be checkedand marked as false positives directly.
Although these reports may be difÔ¨Åcult to be Ô¨Åltered auto-
matically, it is easy for developers to Ô¨Ålter or suppress themvia automatic code transformation with the knowledge of theproject [23].
D. Discoveries about Smart Pointers
According to the bug reports on the open-source projects,
we have three discoveries. First, all of the real bad assignment
and type mismatch bugs are caused by not using function
std::make_unique andstd::make_shared to create
a new smart pointer. Another three commits found in the
history of project Osrm and LLVM also agree with this
conclusion. Therefore, it is strongly suggested to use thesetwo makers to allocate memory and create smart pointers.
Second, developers should pay more attention to shared
pointers. Although the unique shared bugs will not lead to
crashes or resource depletion, such bugs will strongly affectthe efÔ¨Åciency of the program [7]. Besides, shared pointers mayalso trigger circular reference bugs. Therefore, developers had
better have a double-check on whether the ownership needsto be shared before using shared pointers.
Third, smart pointers cannot immunize all kinds of memory
errors, especially the null pointer dereference bugs. The C++standard smart pointers are designed to prevent danglingpointers with null pointer values. And null pointer values arealways used as the return values of abnormal circumstances.Therefore, we believe these are the reasons why the derefer-
ence null bugs are reported most.
VI. T
HREA T TO VALIDITY
The main threats to the validity of our results lie in the
following three aspects.
‚Ä¢Error Pattern Selection. In this paper, we only address
the bugs that can be directly triggered by the method callsof three kinds of smart pointers. However, there are anothertwo kinds of smart pointer related memory errors that canbe triggered with raw pointers: 1) the memory leak bugs dueto not deallocating a memory block after its ownership hasbeen dropped with the release method of unique pointers,
and 2) the dangling raw pointer bugs after a smart pointerdeallocates its managed memory block.
Although smart pointers add new deallocation sites to the
program, these two kinds of bugs are still pure raw pointerbugs, since smart pointers are designed to avoid being dan-gling. As they have been well studied, we prefer checkingthese bugs that cannot be directly triggered by smart pointerswith the corresponding state-of-the-art approaches. And ourmodel of smart pointers can be integrated into them to perfectthe results.
‚Ä¢Benchmark Selection. The validity of our benchmark
may be subject to the threat that our handmade code snippetsmay not be complete enough to test all the circumstances.Therefore, the performance of Spelton on real-world projects
cannot be as good as the handmade benchmark. Besides, theprojects selected may not cover all language features either,there could be false negatives or positives when analyzingother complex projects.
‚Ä¢CSA Analysis Engine. When developing Spelton, the
latest release version of CSA was 9.0.0. There will be manyimprovements and bug Ô¨Åxes in the latest version at present.Some of our solutions and strategies during developing the toolcan be replaced with newer and better optimizations. And thebugs from old version may also affect outcome accuracy andexactness.
VII. R
ELA TED WORK
Our work is mainly related to modeling and checking smart
pointers and memory-related bugs. In this section, we willmainly present the existing researches in these aspects.
‚Ä¢Analysis on Smart Pointers. Currently, there is only
a little research about the C++ smart pointers on differentkinds of aspects. Babati et al. [7] researched the performance
of smart pointers under different compiler conÔ¨Ågurations,and concluded that using shared pointers is very resource-consuming. And Henriques et al. [24] compared the perfor-
mance of different memory deallocation methods in C++, C#and Java with smart pointers of C++ and garbage collectorof C# and Java. Their conclusion is the garbage collector ofC# outperforms the one of Java and the smart pointers ofC++. Donchev et al. [25] and Raj et al. [26] explored teaching
smart pointer usages to newbies and experienced programmers
889respectively. Their researches introduced their experience from
their courses. SMARTOR [27] is a tool that helps developers
to replace raw-pointer-based memory management with smartpointers. Apart from C++ smart pointers, the smart pointersof the Boost Libraries [28] are also involved in this tool.
And SPrinter [6] is a linter-like tool that mainly focuses on
checking coding-style problems of smart pointer usages. Someof the bug types of SPrinter are also supported by our tool in
this paper.
‚Ä¢Ownership of Memory Blocks. The concept of ownership
of memory blocks has been widely used to analyze memoryerrors. Svoboda et al. [16] introduced the Pointer Ownership
Model to represent a similar concept of smart pointers. Heine
et al. [29] utilized the ownership model to check for memory
leak and double-free problems. They introduced a uniquepointer like strategy to use raw pointers in C programs bylimiting the ownership of a memory block only managedby one owner raw pointer. And they developed a tool tocheck the violations of this model. And Aldrich et al. [30]
developed a tool to annotate variables in a Java program to helpprogrammers understanding the data Ô¨Çow. They introduceda static ownership model to annotate the variables, whichrequires the type of ownership of a variable cannot be changed.
‚Ä¢Pointer Analysis. Pointer analysis is also an important
part of our work, and pointer analysis of smart pointershas many similarities with raw pointer analysis. Trabishet al. [31] introduced a symbolic execution aided pointer
analysis method. The method uses the program state duringsymbolic execution to help a query on a static pointer analysis.And the results of the query are used to improve the precisionof the symbolic execution. By reusing the information avail-able, Krainz et al. [32] employed a diff-graph-based method to
quickly analyze points-to relations incrementally. The methoduses the diff-graph to represent each function, and re-computesthe graph for a function if it is changed. In this way, theprevious analysis results of an unchanged function can bereused. And Grech et al. [33] utilized a dynamic-snapshot-
based static analysis method to analyze Java programs. Theyuse dynamic analysis to make heap snapshots, and the staticanalysis uses the information from the snapshots to analyzethe pointers. A scalability-focused algorithm is presented by Liet al. [34]. They estimate the amount of information of points-
to relations that will be used when analyzing a function, andselect a proper sensitivity degree for each function to archivehigh scalability together with enough precision. And Thiessenet al. [35] presented a method of combining demand-driven
local reasoning analysis and object sensitivity for analyzingpointers. The results indicate the method is more efÔ¨Åcient forcontext-sensitive pointer analysis.
‚Ä¢Typestate Analysis on Heap Memory. Checking heap
memory usages for memory errors is a typical utilization ofthe typestate analysis approach. Melton [13] and Smoke [14]
are both tools for checking memory leaks. They model thestate of memory blocks to detect the ones that go out-of-scope without being deallocated. Y an et al. [36] checked use
after free problems by using Spatio-Temporal Context to inferthe potential usages after deallocation. They summarize theprogram with a k-level context-sensitive pointer analysis, and
diagnose use-after-free bugs by checking the intersection of thepointee set of deallocation with the set of dereferences. AndTsmartGP [37] is a tool for checking memory errors according
to pointer analysis. It uses a Ô¨Çow-, context-, Ô¨Åeld- and quasipath-sensitive pointer analysis to record the value of pointersand check errors with them.
Besides, Ô¨Åxing memory errors related to heap memory
management will also use a typestate-like analysis approachto model the state of heap memory blocks. MemFix [1] tries to
Ô¨Åx trivial memory leaks by rescheduling the calls to functionfree. They model the state transitions of heap memoryblocks, and use the state to Ô¨Ånd a better place to deallocatethe memory for all paths after they have removed all frees
in a function. SA VER [38] attempts to Ô¨Åx heap memory errors
according to given bug reports. They use a value-Ô¨Çow graph tomodel the operations on a memory block, and Ô¨Åx the given bugby inserting and replacing the memory operations. Finally, atypestate-like analysis is used to verify the patches generated.
VIII. C
ONCLUSION AND FUTURE WORK
In this paper, we proposed an approach to modeling the
state of C++ smart pointers together with the managed heapmemory, and we deÔ¨Åned a group of operations on themmodifying the states. To diagnose misuses of smart pointers(MisSP), we extracted Ô¨Åve error patterns for the operations onsmart pointers and implemented checkers for the patterns. Weevaluated our model and checkers on a handmade benchmarkand nine open-source C++ projects. The experimental resultsindicate our approach can precisely detect the MisSPs.
In the future, this work can be extended in three aspects.
First, as the Ô¨Årst tool focusing on precisely checking MisSPs,we check Ô¨Åve error patterns. More error patterns of MisSPs canbe added with the evolution of the C++ standard. Second, themodel can be applied to other analysis algorithms other thanstatic symbolic execution to make the check more precise andefÔ¨Åcient. And last, this paper only focuses on smart pointers ofthe C++ standard. Other kinds of smart-pointer-like managerclasses or pointer-like classes also need to be checked if theirimplementations cannot be precisely analyzed.
A
CKNOWLEDGMENT
The authors would like to thank the anonymous reviewers
for their suggestions. This work is supported in part by the KeyResearch Program of Frontier Sciences, Chinese Academy ofSciences under grant No. QYZDJ-SSW-JSC036, and the 973Program of China (2014CB340701).
R
EFERENCES
[1] J. Lee, S. Hong, and H. Oh, ‚ÄúMemÔ¨Åx: static analysis-based repair of
memory deallocation errors for C,‚Äù in Proceedings of the 2018 26th
ACM Joint Meeting on European Software Engineering Conference and
Symposium on the F oundations of Software Engineering, 2018, pp. 95‚Äì106.
[2] ‚ÄúCppReference.‚Äù [Online]. Available: https://en.cppreference.com/[3] B. Stroustrup and H. Sutter, ‚ÄúC++ core guidelines,‚Äù Web. Last accessed
February, 2018.
890[4] E. Geisseler and P . Meier, ‚ÄúGslAtorPtr-C++ core guidelines pointer
checker and support library refactorings,‚Äù Ph.D. dissertation, HSR
Hochschule f ¬®ur Technik Rapperswil, 2016.
[5] The Chromium Projects, ‚ÄúSmart Pointer Guidelines.‚Äù [Online]. Avail-
able: https://www.chromium.org/developers/smart-pointer-guidelines
[6] X. Ma, J. Y an, Y . Li, J. Y an, and J. Zhang, ‚ÄúSPrinter: a static checker for
Ô¨Ånding smart pointer errors in C++ programs,‚Äù in 2019 34th IEEE/ACM
International Conference on Automated Software Engineering (ASE).IEEE, 2019, pp. 1122‚Äì1125.
[7] B. Babati and N. Pataki, ‚ÄúComprehensive performance analysis of C++
smart pointers,‚Äù Pollack Periodica, vol. 12, no. 3, pp. 157‚Äì166, 2017.
[8] ‚ÄúCppCheck.‚Äù [Online]. Available: https://github.com/danmar/cppcheck[9] ‚ÄúClang Static Analyzer (CSA).‚Äù [Online]. Available: https:
//clang-analyzer.llvm.org
[10] ‚ÄúInfer Static Analyzer.‚Äù [Online]. Available: https://fbinfer.com[11] R. E. Strom and S. Y emini, ‚ÄúTypestate: A programming language con-
cept for enhancing software reliability,‚Äù IEEE Transactions on Software
Engineering, no. 1, pp. 157‚Äì171, 1986.
[12] R. DeLine and M. F ¬®ahndrich, ‚ÄúTypestates for objects,‚Äù in European
Conference on Object-Oriented Programming. Springer, 2004, pp. 465‚Äì490.
[13] Z. Xu, J. Zhang, and Z. Xu, ‚ÄúMelton: a practical and precise memory
leak detection tool for C programs,‚Äù Frontiers of Computer Science,
vol. 9, no. 1, pp. 34‚Äì54, 2015.
[14] G. Fan, R. Wu, Q. Shi, X. Xiao, J. Zhou, and C. Zhang, ‚ÄúSmoke: scalable
path-sensitive memory leak detection for millions of lines of code,‚Äù in2019 IEEE/ACM 41st International Conference on Software Engineering(ICSE). IEEE, 2019, pp. 72‚Äì82.
[15] ‚ÄúRAII - CppReference.‚Äù [Online]. Available: https://en.cppreference.
com/w/cpp/language/raii
[16] D. Svoboda and L. Wrage, ‚ÄúPointer ownership model,‚Äù in 2014 47th
Hawaii International Conference on System Sciences. IEEE, 2014, pp.5090‚Äì5099.
[17] S. Beyer, ‚ÄúEfÔ¨Åcient cycle collection in a hybrid garbage collector
with reference counting and mark-and-sweep,‚Äù Ph.D. dissertation, Wien,2020.
[18] ‚ÄúRestbed pull request #106.‚Äù [Online]. Available: https://github.com/
Corvusoft/restbed/pull/448
[19] ‚ÄúMySQL bug #101767.‚Äù [Online]. Available: https://bugs.mysql.com/
bug.php?id=101767
[20] ‚ÄúAria2 pull request #106.‚Äù [Online]. Available: https://github.com/aria2/
aria2/pull/106/
[21] ‚ÄúGNU Make.‚Äù [Online]. Available: https://www.gnu.org/software/make[22] P . E. Black and P . E. Black, Juliet 1.3 test suite: changes from 1.2.
US Department of Commerce, National Institute of Standards andTechnology, 2018.
[23] R. van Tonder and C. L. Goues, ‚ÄúTailoring programs for static analysis
via program transformation,‚Äù in Proceedings of the ACM/IEEE 42nd
International Conference on Software Engineering, 2020, pp. 824‚Äì834.
[24] L. Henriques and J. Bernardino, ‚ÄúPerformance of memory deallocation
in C++, C# and Java,‚Äù 2018.
[25] I. Donchev et al., ‚ÄúExperience in teaching C++11 within the under-
graduate informatics curriculum,‚Äù Inf. in Education, vol. 12, no. 1, pp.
59‚Äì79, 2013.
[26] A. G. S. Raj, V . Naik, J. M. Patel, and R. Halverson, ‚ÄúHow to
teach‚Äù modern C++‚Äù to someone who already knows programming?‚Äù inProceedings of the 20th Australasian Computing Education Conference,2018, pp. 97‚Äì104.
[27] A. Fr ¬®ohlich and C. Mollekopf, ‚ÄúSMARTOR-dress naked C++ pointers
to smart pointers,‚Äù Ph.D. dissertation, HSR Hochschule f ¬®ur Technik
Rapperswil, 2013.
[28] ‚ÄúBoost C++ Libraries.‚Äù [Online]. Available: https://www.boost.org/[29] D. L. Heine and M. S. Lam, ‚ÄúA practical Ô¨Çow-sensitive and context-
sensitive C and C++ memory leak detector,‚Äù in Proceedings of the
ACM SIGPLAN 2003 conference on Programming language design andimplementation, 2003, pp. 168‚Äì181.
[30] J. Aldrich, V . Kostadinov, and C. Chambers, ‚ÄúAlias annotations for
program understanding,‚Äù ACM SIGPLAN Notices, vol. 37, no. 11, pp.
311‚Äì330, 2002.
[31] D. Trabish, T. Kapus, N. Rinetzky, and C. Cadar, ‚ÄúPast-sensitive pointer
analysis for symbolic execution,‚Äù in Proceedings of the 28th ACM Joint
Meeting on European Software Engineering Conference and Symposiumon the F oundations of Software Engineering, 2020, pp. 197‚Äì208.
[32] J. Krainz and M. Philippsen, ‚ÄúDiff graphs for a fast incremental pointeranalysis,‚Äù in Proceedings of the 12th Workshop on Implementation,
Compilation, Optimization of Object-Oriented Languages, Programsand Systems, 2017, pp. 1‚Äì10.
[33] N. Grech, G. Fourtounis, A. Francalanza, and Y . Smaragdakis, ‚ÄúShooting
from the heap: Ultra-scalable static analysis with heap snapshots,‚Äù inProceedings of the 27th ACM SIGSOFT International Symposium onSoftware Testing and Analysis, 2018, pp. 198‚Äì208.
[34] Y . Li, T. Tan, A. M√∏ller, and Y . Smaragdakis, ‚ÄúScalability-Ô¨Årst pointer
analysis with self-tuning context-sensitivity,‚Äù in Proceedings of the 2018
26th ACM Joint Meeting on European Software Engineering Conferenceand Symposium on the F oundations of Software Engineering , 2018, pp.
129‚Äì140.
[35] R. Thiessen and O. Lhot ¬¥ak, ‚ÄúContext transformations for pointer anal-
ysis,‚Äù ACM SIGPLAN Notices, vol. 52, no. 6, pp. 263‚Äì277, 2017.
[36] H. Y an, Y . Sui, S. Chen, and J. Xue, ‚ÄúSpatio-temporal context reduction:
A pointer-analysis-based static approach for detecting use-after-freevulnerabilities,‚Äù in 2018 IEEE/ACM 40th International Conference on
Software Engineering (ICSE). IEEE, 2018, pp. 327‚Äì337.
[37] Y . Wang, G. Chen, M. Zhou, M. Gu, and J. Sun, ‚ÄúTsmartGP: a tool for
Ô¨Ånding memory defects with pointer analysis,‚Äù in 2019 34th IEEE/ACM
International Conference on Automated Software Engineering (ASE).IEEE, 2019, pp. 1170‚Äì1173.
[38] S. Hong, J. Lee, J. Lee, and H. Oh, ‚ÄúSaver: scalable, precise, and
safe memory-error repair,‚Äù in Proceedings of the ACM/IEEE 42nd
International Conference on Software Engineering , 2020, pp. 271‚Äì283.
891