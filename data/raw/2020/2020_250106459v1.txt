Enhancing The Open Network: Definition and
Automated Detection of Smart Contract Defects
Hao Song
Sichuan University
Chengdu, China
ttdelbert@foxmail.comTeng Li
University of Electronic Science and Technology of China
Chengdu, China
tengli2866@gmail.comJiachi Chen*
Sun Yat-Sen University
Guangzhou, China
chenjch86@mail.sysu.edu.cn
Ting Chen*
University of Electronic Science and Technology of China
Chengdu, China
brokendragon@uestc.edu.cnBeibei Li
Sichuan University
Chengdu, China
libeibei@scu.edu.cn
Zhangyan Lin
University of Electronic Science and Technology of China
Chengdu, China
2522579678@qq.comYi Lu
BitsLab
Singapore
y@movebit.xyzPan Li
TonBit
China
paul@movebit.xyzXihan Zhou
TonBit
China
han@movebit.xyz
Abstract —The Open Network (TON), designed to support
Telegram’s extensive user base of hundreds of millions, has
garnered considerable attention since its launch in 2022. FunC
is the most popular programming language for writing smart
contracts on TON. It is distinguished by a unique syntax compared
to other smart contract languages. Despite growing interest,
research on the practical defects of TON smart contracts is
still in its early stages. In this paper, we summarize eight
smart contract defects identified from TON’s official blogs and
audit reports, each with detailed definitions and code examples.
Furthermore, we propose a static analysis framework called
TONScanner to facilitate the detection of these defects. Specifically,
TONScanner reuses FunC compiler’s frontend code to transform
theFunC source code into FunC intermediate representation
(IR) in the form of a directed acyclic graph (DAG). Based on
this IR, TONScanner constructs a control flow graph (CFG),
then transforms it into a static single assignment (SSA) form
to simplify further analysis. TONScanner also integrates Data
Dependency, Call Graph, Taint Analysis, and Cell Construct,
which are specifically tailored for TON blockchain’s unique data
structures. These components finally facilitate the identification
of the eight defects. We evaluate the effectiveness of TONScanner
by applying it to 1,640 smart contracts and find a total of 14,995
defects. Through random sampling and manual labeling, we
find that TONScanner achieves an overall precision of 97.49%.
The results reveal that current TON contracts contain numerous
defects, indicating that developers are prone to making errors.
TONScanner has proven its ability to accurately identify these
defects, thereby aiding in their correction.
Index Terms —TON, FunC, defects definition and detection,
static analysis.
I. I NTRODUCTION
The Open Network (TON) blockchain [ 1] is designed to
make blockchain technology [ 2] a readily accessible tool for
* Jiachi Chen and Ting Chen are the corresponding authors.global users [ 3]. It aims to be capable of handling millions
of transactions per second [ 4], thereby becoming a ubiquitous
decentralized application (DApp) platform. Leveraging the
extensive user base of Telegram, TON blockchain has garnered
significant attention since its testnet phase. Following the
launch of the mainnet in 2022, TON blockchain has attracted
a substantial number of users interacting with DApps on the
platform. As of July 2024, according to DefiLlama, the Total
Value Locked (TVL) on TON blockchain has reached $752.95
million [ 5]. Compared to the beginning of the year, TVL on
TON blockchain has increased approximately 55 times.
The backend of DApps on TON blockchain is developed
based on smart contract technology. Smart contracts are Turing-
complete programs that run on the blockchain, allowing users
to interact with the decentralized ledger by invoking these
contracts [ 6], [7], [8]. TON blockchain uses “sharding” to
horizontally scale overall system performance. This design
differentiates TON from traditional blockchain platforms, as
TON smart contracts do not perform atomic, synchronous
access to persistent states [ 9]. Instead, the communication
paradigm between smart contracts has shifted to a non-atomic,
asynchronous approach. To meet performance and scalability
requirements, TON innovatively introduces the cell as its basic
data structure [ 10]. The storage and retrieval of smart contract
data in TON are centered around the cell. TON smart contracts
also break the limitation of immutable code by providing a
native upgrade mechanism [ 11]. Due to the non-atomicity
of calls, unique data structure, and modifiability of TON
blockchain, there are significant differences in the implemen-
tation of smart contracts compared to traditional blockchain
platforms like Ethereum. Given the unique characteristics of
the TON blockchain, developers may face an increased riskarXiv:2501.06459v1  [cs.SE]  11 Jan 2025of contract defects during the development process. Contract
defects refer to errors, flaws, or bugs within smart contracts
that result in incorrect or unexpected outcomes, or cause the
contract to behave in unforeseen ways [ 12]. Despite numerous
previous studies reporting various smart contract defects and
some works proposing frameworks or tools for defect detection,
most of this research has focused primarily on Ethereum [ 13],
[14], [12], [15], [16]. To the best of our knowledge, there is
currently no research specifically addressing smart contract
defects on TON blockchain.
To address this research gap, we first conduct an empirical
study to define smart contract defects. Specifically, we collect
blogs from the official documentations [ 17], the official
blogs [ 18] and the research community [ 19] recommended
by the official sources. Additionally, we gather audit reports
from blockchain security companies. These sources provide
substantial guidance for our defect definitions. Based on open
card sorting approach [ 20], we ultimately define eight types of
FunC [21] smart contract defects ( FunC is the smart contract
language of TON blockchain, which will be introduced in
Section II): Bad Randomness ,Precision Loss ,Unchecked
Return ,Global Var Redefined ,Improper Function Modifier ,
Unchecked Bounced Message ,Inconsistent Data , and Lack
End Parse . The first three defects may also appear on other
blockchains, while the latter five are specific to TON.
Furthermore, to identify the eight defined TON smart
contract defects, we propose a static analysis framework called
TONScanner. Specifically, TONScanner leverages the FunC
compiler to transform smart contract source code into a FunC
intermediate representation ( FunC IR ) with a directed acyclic
graph (DAG). Using FunC IR , TONScanner constructs a
Control Flow Graph (CFG) [ 22]. To enhance analysis efficiency,
TONScanner transforms the non-Static Single Assignment
(SSA) form CFG into SSA form, resulting in SSA-form IR .
TONScanner integrates the Data Dependency, Call Graph,
Taint Analysis [ 23], and a customized Cell Construct as
analyzers. Utilizing these four analyzers, TONScanner builds
eight detectors for the eight previously defined defects.
Based on the requirements for open-source and verified
code, we collect 922 real-world FunC contracts and 718 Tact
contracts ( Tact [24] is built on FunC , details see Section II),
totaling 1,640 contracts. Running our framework on these two
datasets, we find a total of 14,995 defects, indicating that the
defined defects are prevalent on TON blockchain. To evaluate
the performance of TONScanner, we randomly sample the two
datasets, using a confidence interval of 10 and a confidence
level of 95%. We then manually label them and compare the
results with our detection outcomes. TONScanner achieves
precision rates of 95.09% and 100% on the FunC andTact
datasets, respectively, with an overall precision of 97.49%.
The main contributions of our work are as follows:
•We define eight types of FunC smart contract defects,
including five of them are specific to TON blockchain. For
each defect, we provide a code example to help developers
understand and avoid these defects.•We develop a framework named TONScanner, based on
static analysis, for detecting smart contract defects on
TON blockchain. This framework transforms source code
into a SSA-form IR , enabling efficient and accurate defect
detection. TONScanner is also highly scalable, supporting
the addition of new defect detectors to address future
updates and newly identified defects.
•We test 1,640 smart contracts with TONScanner,
finding a total of 14,995 defects. Additionally,
our framework achieves an overall precision of
97.49% on the manually labeled datasets that we
randomly sample from these smart contracts. We
publish datasets, raw data, and TONScanner at
https://anonymous.4open.science/r/TON_support_material-
ECD4/.
II. B ACKGROUND
A. TON Smart Contract and TVM
TON smart contracts are computerized transaction protocols
running on TON blockchain [ 25], designed to manage dis-
tributed ledgers [ 26] and system state. The system state changes
of TON blockchain are governed by a specific execution model
[27]. Similar to Ethereum [ 28], [29], the execution model
is implemented through a virtual state machine, known in
TON blockchain as TON Virtual Machine (TVM) [ 30], [31].
TVM functions as a quasi-Turing machine, with the total
computation limited by gas [ 32]. TVM executes smart contracts
by representing contract code and data as cells [ 33] stored on
the blockchain. During execution, TVM loads these cells into
the stack and uses control registers to manage the execution
state. As a stack machine, TVM performs instructions by
manipulating values at the top of the stack, modifying persistent
data, and generating output actions [ 34]. TON smart contracts
can be written in three languages: Tact [24],FunC [21], and
Fift[35]. Next, we provide explanations of the relevant concepts
in this work.
FunC. FunC is a high-level, C-like, statically typed language.
FunC programs are compiled into Fiftassembly code, which
is then converted into bytecode for execution by the TVM.
Tact. Tact is the second most popular language for TON
contract development, after FunC .Tact is built on FunC , and its
compiler translates Tact programs into FunC form. Therefore,
our defect definitions are based on FunC .
recv_internal Function. In TON blockchain, this function
is executed when a contract is accessed directly [ 36]. It can
be simply understood as the main function and is a common
practice in TON contracts.
Bounced Message. Bounced message is a mechanism where
a message that could not be successfully processed is returned
to the sender. This is primarily used for error notifications and
refunding funds.
B. TON vs. Ethereum
In this subsection, we compare the differences between TON
and Ethereum to facilitate the understanding of this work. We
do not delve into the consensus mechanisms or architectures;instead, we focus solely on the differences related to smart
contracts, aligning with the theme of our research.
Non-atomicity of Calls. On Ethereum, calls between contracts
are atomic. If any step in the call chain fails, the entire
transaction will be rolled back. However, on TON blockchain,
calls between smart contracts are non-atomic [ 3]. This means
that if the final call in a call chain encounters an error, the
changes made by previous calls will not be rolled back to their
initial state. Thus, developers must account for such scenarios
when writing smart contracts. Specifically, developers need to
handle messages that are bounced back due to call errors. If a
developer fails to handle these bounced messages, it triggers
what we define as the Unchecked Bounced Message defect.
Unique Data Structure. TON blockchain uses a unique data
structure called a “cell” to store data. A cell can contain up
to 1023 bits of data and four references to other cells. Cells
are designed as opaque objects optimized for compact storage,
making direct modification or reading within smart contracts
impossible. Consequently, developers must use a builder to
add data and create a cell, and a slice to read and parse the
data from a cell within the smart contract [ 10]. This pattern is
frequently seen in the FunC language used for writing TON
smart contracts, and examples of this usage can be found in
the code examples in Section III.
Modifiability. Once a smart contract is deployed on Ethereum,
it cannot be modified [ 37]. This immutability forces developers
to adopt complex design patterns to upgrade smart contracts,
such as the proxy contract pattern [ 38]. This pattern allows
developers to point a proxy contract to the address of a new
implementation contract, effectively “upgrading” the contract
without changing its address or state. In contrast, on TON
blockchain, smart contracts can be modified. TON standard
library defines update functions [ 39]. This feature allows
developers to quickly modify smart contracts upon detecting
relevant defects when using our tool, thereby preventing
irreversible losses.
III. D EFECTS IN TON S MART CONTRACTS
A. Data Collection
1) Official Blogs: The blogs are sourced from official
documentations [ 17], official blogs [ 18], and TON research
community [ 19]. These blogs are usually written by security
experts or TON contract developers; thus, they typically
summarize common issues and provide security development
recommendations. We use the keywords “func secure” and
“func develop” for crawling and eventually collect 82 relevant
blogs. These 82 blogs totally contain 1327 security tips1that
are used for further manual analysis.
2) Audit Reports: Security audit reports are conducted by
specialized firms and are commissioned by blockchain projects
at a significant cost. These reports focus on real-world business
needs and highlight issues that could lead to potential losses.
Thus, we also collect audit reports to identify and define
1The example of the blog and tips can be found at: https://blog.ton.org/secure-
smart-contract-programming-in-func
Fig. 1. Example of a card of audit reports
defects. Specifically, we refer to the audit companies listed by
the official TON sources [ 40]. After a thorough review, we
manually collect all seven relevant reports from Certik [ 41]
and Quantstamp [42] for further analysis.
B. Data Analysis
We collaborate with a blockchain security company that
specializes in smart contract audits and invite experts to join
our data analysis effort. A total of four individuals participate
in this work: two of the paper’s authors, each with two
years of experience in smart contract development, and two
professionals specializing in auditing smart contracts.
After security experts manually exclude data unrelated to
FunC smart contract defects, we use an open card sorting
approach [ 20] to analyze and categorize the official blogs and
audit reports. Specifically, we create a card for each blog’s
tip and report, dividing the content into several sections: title,
description, and recommendations (defect types). Two authors
collaborate on the analysis and classification, which take place
in two rounds. In the first round, we randomly select 40%
of the cards. We first read the title and description of each
card to understand the associated defects. Then, we review the
recommendations to understand how to address the identified
defects. Cards without root causes are ignored, and possible
defects are categorized. The classification process is supervised
by security experts to ensure accuracy.
In the second round, we independently analyze and catego-
rized the remaining 60% of the cards following the same steps
as in the first round. Then, we compare the results and discuss
the differences with security experts. These discussions lead to
either unification or elimination of discrepancies. Finally, we
categorize the defects into eight types.
Figure 1 illustrates an example of a card generated from
a smart contract audit report [ 43]. The card comprises three
parts: the finding name (title), description, and recommendation.
As noted in the description, in the vesting-lockup-wallet.fc
smart contract, the function recv_function() neither modifies
the storage nor throws an exception, yet it is annotated with
theimpure modifier. The audit platform recommends removing
the impure modifier. Therefore, we categorize this issue as
Improper Function Modifier .
Figure 2 illustrates a card example generated from a TON
official blog tip [ 44]. The card comprises three parts: the tip
name (title), description, and recommendation. In the descrip-
tion, it is mentioned that the message flow may be constructed
incorrectly, requiring the contract to handle bounced messages.
For example, if the receiver’s wallet contract is unable toFig. 2. Example of a card of official blogs
accept tokens, the sender’s wallet contract must handle the
bounced message. The recommendation similarly suggests
processing bounced messages. Therefore, we categorize this
issue as Unchecked Bounced Message .
C. Defects Definition
We finally define eight TON smart contracts defects; among
them, Bad Randomness ,Precision Loss , and Unchecked Return
have similar definitions in previous studies on Solidity [12],
[14]. Note that there may be other defects common to both
FunC andSolidity . In this paper, we report only those defects
that are summarized from official blogs and audit reports to
ensure their reliability. Meanwhile, the other five defects are
specific to TON. We present a brief definition of each defect
in Table I, followed by detailed definitions and code examples.
(1) Bad Randomness (BR): Random number generation
is commonly used in blockchain projects [ 45]. Similar to
traditional programs, generating random numbers in TON
blockchain smart contracts also requires a seed. Since the
algorithm produces pseudo-random numbers, running the same
program multiple times with the same seed will yield the
same random number. Developers often use the current logical
time as a seed to ensure the randomness. However, similar to
Ethereum, miners can influence random number generation, as
they determine the current block’s information, including the
logical time [ 12]. This makes the generated random numbers
still somewhat predictable and controllable.
1() recv_internal (msg_value, in_msg_full,
in_msg_body) {
2 int seed = cur_lt ();
3 set_seed (seed);
4 if(rand (10000) == 7777) {
5 ;;...send reward...
6 }}
Listing 1. An example of Bad Randomness defect
Example: Listing 1 shows the recv_internal function, de-
signed to implement a lottery application. Among the function
parameters, in_msg_full includes the sender’s address. The
function body first retrieves the current logical time to use as a
random seed (lines 2-3). If the generated random number equals
7777 (line 4), the sender address is rewarded. Since miners
can influence the logical time, the random number generation
is not entirely unpredictable. This lottery application is unfair,
as miners can exploit this defect for profit.TABLE I
DEFINITIONS OF THE 8 D EFECTS
Contract Defect Definition
Bad RandomnessUsing transaction logic time as a
seed for randomness.
Precision LossUsing an improper order of opera-
tions causes result deviation.
Unchecked ReturnDo not check the return value of
call functions.
Global Var RedefinedDefining a variable with the same
name as a global variable.
Improper Function
ModifierUsing an incorrect modifier, which
causes function call failures.
Unchecked Bounced
MessageDo not check and handle the
bounced message.
Inconsistent DataReading the data in a manner in-
consistent with how it was written.
Lack End ParseLack of end_parse function to
check inputs.
(2) Precision Loss (PL): Currently, all unary and binary
operators in the FunC language are integer operators [ 46].
When the result of a division is not an integer, it is rounded
down. Thus, executing operations in the order of division
followed by multiplication might lead to a deviation from
the correct outcome. Although such precision loss may seem
insignificant, the improper operation order in decentralized
finance (DeFi) [47] projects can lead to asset loss.
Example: In Listing 2, the function accumulate_price is
designed to accumulate the calculation of two price metrics
based on the passage of time and the values of ton_reserve
andjetton_reserve with each call. The value of time_elapsed
is obtained by subtracting the timestamp of the last blockchain
update from the current time. If time_elapsed is greater than 0
and both ton_reserve and jetton_reserve are non-zero, the code
containing the Precision Loss defect is executed (lines 5-6).
The defective code performs division before multiplying by
time_elapsed , leading to coin loss. A better approach would be
to multiply by time_elapsed first and then perform the division.
1() accumulate_price() inline {
2 int time_elapsed = now() - block_timestamp_last;
3 if((time_elapsed > 0) & (ton_reserve != 0) &
4 (jetton_reserve != 0)) {
5 price0_cumulative_last += (ton_reserve /
jetton_reserve *time_elapsed);
6 price1_cumulative_last += (jetton_reserve /
ton_reserve *time_elapsed);
7 }
8 block_timestamp_last = now();}
Listing 2. An example of Precision Loss defect
(3) Unchecked Return (UR): This defect refers to not
checking return values in the FunC smart contracts. The
omission might prevent the relevant handling functions from
detecting unexpected states and errors. Since calls between
smart contracts on TON blockchain are not atomic, a failed
call chain does not result in a complete rollback of the
state. Developers must use return values to identify andhandle exceptions; otherwise, the resulting state from failed
transactions can be confusing and misleading.
1() recv_internal( int msg_value, cell in_msg_full,
slice in_msg_body) impure {
2 slice cs = in_msg_full. begin_parse ();
3 int flags = cs~ load_uint (4);
4 ;;if (flags & 1) unchecked flags
5 ;;...more code logic...
6}
Listing 3. An example of Unchecked Return defect
Example: Listing 3 presents a function containing the
Unchecked Return defect. This function takes a parameter
of type cellnamed in_msg_full . Within the function body, this
parameter is converted into a slice type for parsing, and a 4-bit
unsigned integer is read and stored in the flagvariable. The flag
variable holds the return message that needs to be checked, but
the code omits the necessary check logic. This results in the
contract cannot determine the type of the incoming message,
causing it to lose further processing.
(4) Global Var Redefined (GVR): References can lead
to complex state sharing and modification. Currently, the
FunC language does not support references. Instead, FunC
uses global variables to achieve similar functionality. If an
unexpected assignment operation occurs during a function’s
execution—specifically assigning a value to a variable with
the same name as a global variable—the value of the global
variable will be altered.
Example: In Listing 4, the global variable tokens records
the total amount. The function withdraw_jettons is used to
withdraw tokens and takes a parameter of type slice, named
s. When this function is called, it needs to load the child
wallet address and the amount to be withdrawn. Subsequent
logic handles the other operations required for the withdrawal.
However, while loading the amount, the assigned variable has
the same name as the global variable (line 5), causing the total
number of tokens (line 1) to be unintentionally altered.
1global int tokens;
2() withdraw_jettons( slice src, slice s)impure {
3 int query_id = s~ load_uint (64);
4 slice child_wallet = s~ load_msg_addr ();
5 int tokens = s~ load_coins ();
6 ;;...more code logic...
7}
Listing 4. An example of Global Var Redefined defect
(5) Improper Function Modifier (IFM): In the FunC
language, function declarations can include modifiers, one of
which is the impure modifier. This modifier indicates that the
function may have significant side effects, such as modifying
contract storage, sending messages, or throwing exceptions due
to invalid data [ 48]. If a function is declared without the impure
modifier and its return value is not used, the FunC compiler
might optimize away the function call, assuming that it has no
necessary side effects. This feature emphasizes the importance
of correctly using modifiers to ensure the intended effects of
code are preserved during compilation. This corresponds to a
programming paradigm in Ethereum called State Mutability ,
generally using view andpure to modify functions [49], [50].Example: In Listing 5, a function named store_base_data
is defined. This function uses begin_cell to construct a new
empty builder and fills it with bank balance, loans, and user
data. Finally, it converts the builder into a cell using end_cell
(lines 2-6). The function employs set_data to write the cell to
the contract’s storage, thereby modifying the contract’s state.
However, this modification is rendered ineffective due to the
absence of the impure modifier annotation.
1() store_base_data() {
2 set_data (begin_cell ()
3 .store_coins (ctx_bank_balance)
4 .store_coins (ctx_bank_borrowed)
5 .store_dict (ctx_users)
6 .end_cell ());
7 commit();}
Listing 5. An example of Improper Function Modifier defect
(6) Unchecked Bounced Message (UBM): On TON
blockchain, each transaction is executed independently of
others, and smart contracts communicate via messages. Due
to the asynchronous nature of this communication, developers
cannot ensure that message flows will complete as intended.
This necessitates thorough checking and handling of bounced
messages during contract development to prevent potential
issues. Failure to include such processes violates secure
development principles and is defined as the Unchecked
Bounced Message defect.
Example: In Listing 6, the recv_internal function is used
to handle received messages. The function first checks if the
message body is not empty before proceeding with further
processing. The Unchecked Bounced Message defect occurs in
the subsequent code logic (lines 6-7). Performing &operation
on parameter flag and 1 is to determine if the message is a
bounced message. However, when this operation yields true,
there is no handling logic for the bounced message; instead,
the function simply returns. The developer actually loses to
capture errors that occur in the middle of the call chain.
1() recv_internal( int msg_value, cell in_msg_full,
slice in_msg_body) impure {
2 if(in_msg_body.slice_empty?()) {
3 return ();}
4 slice cs = in_msg_full. begin_parse ();
5 int flags = cs~ load_uint (4);
6 if(flags & 1) {
7 return ();}
8 if(op == op::withdraw_ton_from_minter) {
9 ;;send message with op allows to bounce
10 }}
Listing 6. An example of Unchecked Bounced Message defect
(7) Inconsistent Data (ID): TON blockchain stores all
content in a data structure called a cell. It requires various types
of data to be serialized according to specific rules. The builder
and slice primitives provide APIs for storing and reading data
in/from cells, respectively [ 51]. These primitives require that the
order and type of variables must be consistent when reading and
writing the contract’s global state. Any inconsistency between
them results in the Inconsistent Data defect.
Example: In Listing 7, the save_data function creates a
new empty builder and stores a 2-bit unsigned integer named
created_at (line 3). However, when reading the data, it attemptsto read a 32-bit unsigned integer (line 9). This mismatch causes
the written data to be read in an invalid format, resulting in
incorrect outcomes.
1() save_data() impure {
2 set_data (begin_cell ()
3 .store_uint (created_at, 2)
4 .store_uint (state, 2)
5 ;;...more code logic...
6 .end_cell ());}
7() load_data() impure {
8 slice data = get_data ().begin_parse ();
9 created_at = data~ load_uint (32);
10 state = data~ load_uint (2);
11 ;;...more code logic...
12}
Listing 7. An example of Inconsistent Data defect
(8) Lack End Parse (LEP): Including the end_parse
function after each slice read is a best practice in secure FunC
contract development [ 52]. The end_parse function checks
if the slice is empty after loading its contents. If not, the
function throws an exception to ensure that the slice contains
expected data. Since omitting the end_parse function does
not immediately cause obvious security issues, it may be
overlooked by developers. However, TON blockchain uses bit
streams with variable data format, using end_parse to ensure
that the read and write operations are consistent is helpful [ 53].
Therefore, the absence of the end_parse check is defined as a
defect.
1() load_data() impure {
2 var ds = get_data ().begin_parse ();
3 owner = ds~ load_msg_addr ();
4 flag = ds~ load_int (32);
5 ;; ds.end_parse();
6}
Listing 8. An example of Lack End Parse defect
Example: In Listing 8, after reading the final 32-bit integer
from the slice, the end_parse function should be included
to verify that all data has been used (line 5). However, the
developer omitted this step (as indicated by line 5), which is
necessary to ensure that no unused data remains in the slice.
Without this check, the program loses the guarantee that it reads
as much data as it writes, which may increase the difficulty of
debugging.
IV. M ETHODOLOGY
A. Overview
Figure 3 illustrates the methodology of TONScanner, which
performs defect detection through three key stages: IR Con-
verting ,Code Analyzing , and Defect Detecting . TONScanner
also incorporates an Inputter module, which standardizes smart
contract source code into FunC language format. Specifically,
TON smart contracts can be written in Tact orFunC . For
contracts written in Tact, TONScanner compiles them into
FunC code. The differences between these two languages are
detailed in Section II.
To facilitate further detection, TONScanner generates IR in
the first stage. Inputter module feeds the FunC source code into
the compiler. The frontend of the FunC compiler performs lex-
ical analysis, syntax analysis, and semantic analysis to generate
Fig. 3. Architecture of TONScanner
theFunC IR in the form of a DAG. The FunC compiler also
performs necessary optimizations, such as constant propagation.
Next, the DAG-form FunC IR is converted into a CFG. Finally,
theFunC IR is transformed into SSA-form IR based on the
CFG.
During the second stage, the SSA-form IR serves as input,
and the necessary metadata for defect detection is collected.
This includes the Call Graph, Data Dependency Tree, Cell
Analysis, and Taint Analysis.
In the third stage, the metadata collected by the analyzer is
used to implement the eight defect detectors. These detectors
utilize the source map to accurately identify defects and produce
a defect detection report. The architecture of TONScanner
is designed to be extensible, allowing detectors to be added
without modifying the original design.
B. Stage 1: IR Converting
In this stage, TONScanner converts the FunC IR into the
SSA-form IR for further analysis in stage 2.
1) CFG: TONScanner converts DAG-form FunC IR to CFG
to facilitate further analysis. Figure 4 shows the source code
for a function with its DAG and CFG. In this example, blocks
#3, #4, and #5 represent the branching structure of lines 3-6
in the source code, while blocks #1 to #6 represent the entire
loop structure of lines 2-7. Block #1 and block #2 form a loop,
which is not reflected in the DAG. In contrast, the CFG clearly
includes control flow, making it more suitable for analysis.
The transition from DAG to CFG focuses on control
flow statements, namely conditional branches and loops. For
conditional branches, we identify and create basic blocks
[54] within the program: the condition check block, the true
condition block (then block), the false condition block (optional
else block), and the merge block. The condition check block
directs execution to the then block or else block based on the
condition’s result. The merge block represents code after the
branch, linking all blocks to form the CFG. For loop statements,
the CFG includes the loop condition check block, loop body
block, and exit block. The loop condition check block branches
to the loop body block or the exit block, and the loop body
block returns to the condition check block, forming a loop
back edge.
2) SSA-form IR: The difference between SSA and non-SSA
form lies in variable assignment and management. In SSA
form, each variable is assigned exactly once, with new variableFig. 4. Conversion of DAG to CFG
versions and ϕfunctions introduced to handle control flow
merge points. In contrast, non-SSA form allows variables to
be assigned multiple times, making variable value tracking
and management more complex. SSA form simplifies the
relationships between variable definitions and uses, making
data flow analysis more intuitive and accurate. Additionally,
in non-SSA form, data flow analysis requires maintaining the
value information for all elements at each program point. If
the CFG is large or there are many results to maintain, the
space and time overhead can be significant.
We use algorithms [ 55] to convert a non-SSA form CFG to
SSA form. First, TONScanner analyzes the CFG to determine
the dominance frontier for each variable definition. The
dominance frontier helps identify control flow convergence
points, requiring ϕfunctions to merge variable values. At these
frontiers, ϕfunctions are inserted to handle merging values
from different paths. Next, TONScanner traverses basic blocks
to perform reaching-def analysis, which identifies variable
definitions reaching each program point, ensuring correct
variable versions are used. Finally, all variables are renamed so
each is assigned only once in SSA form. This involves updating
ϕfunctions to reflect new variable names, simplifying variable
usage tracking throughout the program.
C. Stage 2: Code Analyzing
In this stage, TONScanner extracts the necessary metadata
for further defect detection based on the CFG.
1) Call Graph Constructing: A general call graph records
relationships between internal function calls within a contract.
Given the interoperability of smart contracts, inter-contract
calls are common. Thus, the call graph here also considers
calls to other contracts. Figure 5 illustrates the function calls in
TON contracts. The left part shows internal function calls, and
the right part shows special method calls to external contracts.
Due to TON’s unique message mechanism, where external
contracts are invoked by sending messages, TONScanner
includes functions for sending messages and receiving bounced
messages as nodes in the call graph.
TONScanner constructs the call graph through the following
four steps. First, it identifies all functions within the contract
to construct the nodes of the call graph. Second, it scans the
contract to identify all function call instructions, creating an
edge between the calling function and the called function
to represent the function call relationship. Third, it scans
Fig. 5. An example of a Call Graph in TON contract
the contract for instructions that call the send_raw_message
function, which is used to send a message to another contract.
This creates a send message node and an edge to represent the
message transmission between contracts. Fourth, if the contract
handles bounced messages, it can receive a bounced message
from an external source, creating a receive bounced message
node and an edge to represent the bounced message.
2) Data Dependency Tree: TONScanner determines data
dependencies through the following steps. First, TONScanner
collects variable assignment statements from the SSA-form IR
and constructs an index mapping variables to their components.
For example, the statement result_2 := ˆ_+=_ (result_2,m_0)
in a basic block of CFG maps to the source code result +=
m, where result_2 is composed of itself and m_0. Using this
index, TONScanner can efficiently retrieve the composition of
a given variable. Since TONScanner further converts the FunC
IRtoSSA-form IR , the composition of variables becomes even
clearer. Second, TONScanner traverses the variable assignment
statements to construct the data dependency tree.
3) Cell Analyzing: In TON programming, commonly used
variable types include int,uint,cell,slice,builder ,tuple and
etc [ 56]. Among these, cellis a data structure unique to the
TVM. In TON blockchain, different types of data are ultimately
persisted as celltypes. Both storing and loading data from a
cellshould follow a specific order. Besides, intanduint types
are often used with specific bit widths, and slice types may
also have bit widths. This requires consideration of bit widths
during both storing and loading operations. For example, in
Listing 7, two uint types with a width of 2 bits each are stored
sequentially. However, during loading, a uinttype with a width
of 32 bits is extracted. The characteristics of uintallow the data
types stored in the initial state of the cell to be inferred through
sequential analysis of the cell’s store or load operations.
Cell analysis involves storing/loading data within a cell.
To store data, a builder object is created using begin_cell ,
followed by store instructions to store data of specified types
and lengths. To load data, begin_parse serializes the cell into
a slice, from which data of specified types and lengths are
loaded. During the CFG traversal, each block’s cell data is
recorded, and sub-block computations are performed based on
this information. When dealing with branch statements, cell
structures from different branches may vary and need merging.
If the cell results are the same, they are merged; otherwise,
results are recorded separately. The cell records variable type,
length, and ID. Since the IR is in SSA form, the ID helps locate
the variable definition and corresponding source code position.
Anend_parse flag is used during analysis. It indicates if a cell
parsed with begin_parse has been validated with end_parse ,
aiding in identifying the Lack End Parse defect.4) Taint Analyzing: Taint analysis establishes the taint
propagation relationship graph among variables by traversing
Data Dependency Tree, handling three types of instructions:
assignment instructions, function call instructions and branch
instructions. Specifically, for assignment instructions, arithmetic
expressions containing tainted data as the right-hand side of
an assignment statement directly assign the value to the left-
hand side. The taint mark can be directly propagated from the
variables in the right-hand side expression to the left-hand side.
For function call instructions, when tainted data is passed as
an argument to a function, the function’s return value will be
marked as tainted. For branch instructions, if a tainted variable
is used as the branch condition, all assignment statements
within the branch block are tainted.
D. Stage 3: Defect Detecting
In this stage, each detector in TONScanner retrieves the
necessary basic metadata and then identifies whether the
target contract contains the defined defects. The scalability
of TONScanner allows for the development of new analyzers
and detectors within the existing framework.
1) Bad Randomness: TONScanner marks block-related
information, such as cur_lt andblock_lt , as taint sources since
these represent logical times. It uses Taint Analysis to track
the propagation of these data throughout the program, focusing
particularly on their use in random number generation. During
analysis, TONScanner monitors whether tainted data reach
taint sinks, such as array index accesses and value comparison
operations, to identify potential BRdefects.
2) Precision Loss: TONScanner traverses the function SSA-
form IR based on the CFG to identify all multiplication in-
structions. It then uses the Data Dependency Tree to determine
the two operands of these multiplication instructions. If any of
these operands result from a division operation, the instruction
is flagged for potential precision loss due to the sequence of
division followed by multiplication.
3) Unchecked Return: TONScanner uses the call graph to
check if the called functions have return values. If the value
exists, it then uses the Data Dependency Tree to determine if
the value is used by other variables. Considering that the IR
generated from the source code includes the original variable
names, if an underscore is used to receive the return value, it
indicates that the developer intentionally chose to ignore the
return value. In such cases, it is not considered an URdefect.
In summary, TONScanner only checks whether the defined
variable receiving the return value is used.
4) Global Var Redefined: TONScanner traverses all in-
structions in the SSA-form IR based on the CFG to identify
SetGlob instructions, which are used to modify global variables,
andGlobVar instructions, which are used to declare global
variables. Since identifying a GVR issue at the IR level alone
is challenging, the source map locates these statements in the
source code. The source code is then checked for variable
declaration keywords like int,slice,letand etc. If such
keywords are present, the defect is identified.5) Improper Function Modifier: TONScanner first identifies
functions without the impure modifier. It then checks the CFG
for four operations: (a) throwing exceptions, e.g., THROW-
IFNOT ; (b) sending messages, e.g., send_raw_message ; (c)
modifying storage, e.g., set_data ; and (d) modifying global
variables. Next, it uses the call graph to check if called functions
have any of these operations. If a function contains these
operations and its return value is unused or absent, it flags an
IFM defect. Unlike the URdetector, this one ensures none of
the return values are used.
6) Unchecked Bounced Message: TONScanner follows
three steps to detect this defect, i.e., checking sent messages,
checking bounced messages, and comparing the results.
In the first step, TONScanner traverses the function’s SSA-
form IR based on the CFG to identify the send_raw_message
function. Using cell analysis results, it retrieves the sent
message formatted as a cell and extracts the bounceable flag
located at the third bit [ 57]. If the message cannot bounce, it
is skipped. Otherwise, TONScanner extracts the opfield from
the message to determine the function to invoke in the receiver.
If the message contains a body, the opfield is in the first field
of the body; if not, the op field, as a uint32 type, follows some
header flags. In summary, the first step requires TONScanner
to extract the opfield from messages that can bounce.
In the second step, TONScanner traverses all instructions in
therecv_internal function’s SSA-form IR based on the CFG,
extracting the flag (the fourth bit of message [ 57]) that indicates
whether the bounced message is handled. As shown in Listing
6 (lines 7-9), this involves extracting and checking the flag
to determine if the bounced message is processed. If this flag
is checked within a basic block, TONScanner calculates all
blocks dominated by this basic block and extracts the second
field of the message body as the opfield (The first field of the
bounced message is the bounced message flag 0xFFFFFFFF .).
In summary, the second step requires TONScanner to extract
theopfield from bounced messages.
In the third step, TONScanner compares the two oplists
obtained from the previous two steps. If an opis present only
in the first list, TONScanner reports an UBM defect.
7) Inconsistent Data: TONScanner traverses all instructions
in the SSA-form IR based on the CFG to identify the load_data
and set_data functions, which are used to read and write
contract storage space. Based on the results of cell analysis,
it obtains the structure of the cells being set and loaded. It
then matches the types and widths of variables field by field to
ensure they correspond one-to-one. If any mismatch is found,
it is flagged as an IDdefect. This detector specifically focuses
on identifying IDdefects when load_data andset_data are
used to read and write contract storage space.
8) Lack End Parse: TONScanner first identifies basic blocks
with no sub-blocks based on the CFG, indicating these blocks
can reach the program’s end. It then uses cell analysis results
to determine the state of all cells at these blocks. If a cell
has not been validated with end_parse and is not passed as a
parameter to other functions (i.e., it is not further loaded in
other functions), TONScanner flags the cell with a LEP defect.Finally, TONScanner reports the defect at the last recorded
load operation of the cell. This defect is flagged if a cell in any
branch is not validated with end_parse , with the corresponding
source code location at the last load operation.
V. E XPERIMENT
A. Experimental Setup
The experiment is conducted on a server running Ubuntu
18.04.5 LTS and equipped with 12 Intel Xeon Gold 6132 CPUs
and 120 GB memory.
1) Dataset: We collect TON contract dataset from two
sources: TON Verifier [ 58] and GitHub. TON Verifier is
an open-source platform maintained by the official TON
team, featuring verified and deployed smart contracts on TON
blockchain. For the open-source dataset from GitHub, we
used GitHub’s advanced search function to filter repositories
using keywords such as file types “.func”, “.fc”, “.tact”, entry
functions “recv_internal” and “TON” to obtain the final results.
Both of them were collected by April 2024, and then we
deduplicated all the collected smart contracts. We finally
obtained 294 contracts from onchain and 628 contracts from
GitHub, resulting in a total of 922 unique FunC contracts . For
contracts originally written in Tact, we use the Tact compiler
to compile them into FunC form and then apply the same
deduplication method as used for FunC contracts. This process
results in 258 contracts onchain and 460 contracts from GitHub,
totaling 718 unique Tact contracts. We divide the dataset into
FunC andTact categories to facilitate the evaluation.
2) Evaluation Metrics: In this paper, we summarize the
following research questions (RQs):
•RQ1. What is the prevalence of the eight defects in real-
world smart contracts?
•RQ2. What is the effectiveness of TONScanner in identifying
defects in FunC dataset?
•RQ3. What is the effectiveness of TONScanner in identifying
defects in Tact dataset?
B. RQ1: Prevalence of Defects
To answer RQ1, we run TONScanner on 922 FunC contracts
and 718 Tact contracts. The detailed results are shown in Table
II, where the column # Defects shows how many relevant
defects appear in the collected datasets (it is possible that a
contract contains multiple defects).
ForFunC contracts, URand LEP are the most common
defects. TON use the cell for data storage, which allows only
sequential access, leading to a significant amount of URwhen
preceding data is not used. Most users, when encountering
the cell for the first time, are unaware of the necessity to use
end_parse to verify the cell, which results in a high incidence
ofLEPs . For Tact contracts, UR,LEP andIDare prevalent
and occur frequently, both due to defects caused by the Tact
compiler. Due to the insufficient knowledge of TON’s non-
atomic and bounced message characteristics, there is often
inadequate handling of bounced messages. This oversight
results in a significant prevalence of UBM . Other defects
occur relatively infrequently. They are typically associatedwith users’ coding practices (e.g., PLand GVR ), specific
business logic (e.g., BR), or they trigger severe errors that
are more readily detected (e.g., IFM). Overall, TONScanner
detects 7,744 defects in FunC contracts, averaging 8.4 defects
per contract. For Tact contracts, TONScanner detects 7,251
defects, averaging 10.1 defects per contract.
In the FunC dataset, we find 1 smart contract containing 6
types of defects, making it the contract with the most defects.
There are 33 smart contracts with 5 types of defects, 190
smart contracts with 4 types of defects, 379 smart contracts
with 3 types of defects, and 225 smart contracts with 2 types
of defects. In the Tact dataset, we find 31 smart contracts
containing 5 types of defects, making these the contracts with
the most defects. There are 510 smart contracts with 4 types
of defects, 136 smart contracts with 3 types of defects, and
40 smart contracts with 2 types of defects. According to the
TONScanner report, 1,545 smart contracts contain at least
one defect, accounting for about 94% of the collected dataset.
This indicates that many TON smart contract developers lack
sufficient experience to meet secure development requirements.
C. RQ2: Evaluation in FunC Dataset
In this RQ, we evaluate the performance of TONScanner
based on the FunC dataset. Specifically, we randomly sample
contracts from the positive results reported for each defect.
To determine the sample size for each defect, we follow a
confidence interval-based sampling method [ 59] to generalize
the total number of issues discovered for that defect. We set
a confidence interval of 10 and a confidence level of 95%,
calculating the required number of samples [ 60]. The calculated
sample sizes for the eight defects are 2, 46, 94, 16, 4, 72, 80,
and 93, respectively. We then sample the evaluation dataset
based on these results and carefully manually label them by
two authors. During the labeling process, we separate false
positives from true positives to analyze the performance of
TONScanner on the FunC dataset.
Columns 4, 6, 8 and 10 of Table II summarize the results
of applying TONScanner to our manually labeled FunC
contract samples. Due to the low number of detected BR,
GVR , and IFM defects, we analyze all contracts with these
three defects to make the results more reliable. Columns 6
and 8 display the number of samples categorized as true
positives (TP) and false positives (FP), respectively. We use
precision rate to demonstrate the performance of detecting each
defect. The precision rate is calculated#TP
#TP+#FP×100% .
We also calculate the overall precision to demonstrate the
effectiveness of TONScanner on the FunC dataset. The formula
for this calculation isPn
i=1pci×|ci|Pn
i=1|ci|, in which pcirepresents
the precision of detecting defect i, and|ci|is the number of
defect iin the FunC dataset.
ForUBM ,ID, and LEP defects, TONScanner reports them
at a precision of 93.06%, 83.75%, and 97.85%, respectively.
For the remaining 5 defects, our tool achieves 100% precision.
Furthermore, the overall precision of TONScanner achieves
95.09% on the FunC dataset.TABLE II
EXPERIMENTAL RESULTS ON FunC AND Tact DATASETS
# Defects # Samples # TP # FP Perc(%)
FunC Tact FunC Tact FunC Tact FunC Tact FunC Tact
BR 2 / 2 / 2 / 0 / 100 /
PL 90 53 46 34 46 34 0 0 100 100
UR 3927 4338 94 94 94 94 0 0 100 100
GVR 16 / 16 / 16 / 0 / 100 /
IFM 4 6 4 6 4 6 0 0 100 100
UBM 288 441 72 79 67 79 5 0 93.06 100
ID 493 976 80 87 67 87 13 0 83.75 100
LEP 2932 1618 93 91 91 91 2 0 97.85 100
False Positives Analysis. (1) When parsing messages, contracts
handle the opfield. Contracts evaluate the value of the variable
opwithin branch statements to determine different business
logics. For UBM , TONScanner does not incorporate conditional
constraint analysis, resulting in FPs. Moreover, custom message
formats may result in incorrectly parsed opfields, which is
another cause of such FPs. (2) For ID, we find that in branch
structures, different conditions execute different logic, making
it impossible to account for the cell structure in all cases,
leading to false positives. (3) As for LEP, we find that false
positives occur due to load operations on cells within complex
loops, which makes it challenging to accurately identify the
cell structure and the usage of end_parse .
False Negatives Analysis. To find contracts with defects that
TONScanner fails to report, we follow the same sampling
method used for precision analysis, adopting a confidence
interval of 10 and a confidence level of 95%. We sample 87
contracts from the 922 FunC contracts and conduct a manual
audit to identify defects, resulting in a total of 830 defects. We
compare the manually labeled results with the tool’s detection
results, finding that 25 defects are missed. Among these, 13
areLEP defects, and 12 are UBM defects. (1) When a cell
is used within a loop, the number of iterations cannot be
determined. This makes it impossible to pinpoint the position
ofend_parse , resulting in LEP defects being missed. (2) When
sending messages, contract developers do not always adhere
to the officially standardized message format but instead use
custom message formats. This leads to message parsing failures,
resulting in missed UBM defects.
D. RQ3: Evaluation in Tact Dataset
To answer RQ3, we select the same sampling method. The
calculated sample sizes for the six defects are 34, 94, 6, 51,
86, and 91, respectively. Two authors then manually label
the samples, analyze the results, and calculate the TP and
FP. We use the precision rate to evaluate the performance of
TONScanner on the Tact dataset.
False Positive Analysis. TONScanner reports six detected
defects with 100% precision, indicating that it maintains a high
detection precision on the Tact dataset as well. TONScanner
did not detect any BRdefects because they are rely on specific
business scenarios and are relatively rare. The absence of GVR
is due to the syntax characteristics of Tact, which uses member
variables of the Contract class to store global data, so there are
no custom global variables in the generated FunC code. Among
the six detected defects, only PLandUBM are controlled by
the developer, while the others are caused by the compiler.
Through the sampling analysis of the detection results, all thesedefects are true positives. The four compiler-caused defects
show the same defect pattern, indicating that the Tact compiler
is currently immature and needs optimization.
False Negatives Analysis. To find missed defects in contracts,
we use the same sampling method as in the previous section.
We sample 85 Tact contracts from the 718 in the Tact dataset.
After manually auditing and labeling the defects, we identify
a total of 740 defects. Comparing the labeled results with
TONScanner’s detection results, we find one missed LEP defect.
The reason for this missed detection is caused by loops.
VI. D ISCUSSION
A. Case Studies of FP and FN Instance
Listing 9 is taken from contract2. The code is to extract
the necessary information from the incoming message, then
construct and forward the message. However, it is flagged as
having a UBM defect, which is an FP. To distinguish different
messages, different opcodes are used, and the recipient
performs different operations depending on the value of the op
(line 1). When conducting UBM defect detection, it is necessary
to identify the op. However, in this case, the condition if(op
== op::proxy_send) imposes a constraint on the opwithin the
if-branch. This limits the flexibility of the implementation, as it
can only send messages that match the opvalue. In the case of
FPs in UBM defect detection, to achieve the desired constraint
functionality, it requires symbolic execution techniques.
1if(op == op::proxy_send) {
2 ;;...more code logic...
3}
Listing 9. FP instance of UBM defect
Listing 10 is taken from contract3. This code performs
the parsing of a job task and status checking. The end_parse
function is missing, but TONScanner encountered an FN issue.
The missed LEP defects occur because when a cell is used
within a loop (lines 3-4), the number of iterations cannot be
determined, leading to inaccurate cell analysis. As a result, it
is impossible to identify the position of the end_parse . The
missed LEP defects occur because when a cell is used within a
loop, the number of iterations cannot be determined, leading to
inaccurate cell analysis. As a result, it is impossible to identify
the position of the end_parse .
1int job::double_answer( slice ,int count, int)
impure {
2 ;;...more code logic...
3 repeat (count) {
4 status = status_slice~ load_uint (1);}}
Listing 10. FN instance of LEP defect
B. Threats to Validity
Internal Validity. To evaluate TONScanner, we need to conduct
random sampling checks on the collected smart contract dataset.
Individual misunderstandings of smart contracts can lead to
2Contract can be found at: https://verifier.ton.org/EQCPXKOygMDIuWI6v
-nSBt498PwHAwaatg5yLYC7TitxLLQbr
3Contract can be found at: https://github.com/ton-link/ton-link-contract-
v3/tree/main/typescript/source/CustomTokenOracleinaccuracies in our calculated precision. To reduce errors, we
select the most experienced authors to perform the initial checks.
After this, we invite security experts to review the results,
ensuring the accuracy of our final calculations.
External Validity. TON has garnered significant attention,
leading developers to deploy an increasing number of new smart
contracts. Many new TON ecosystem projects may publish
their blogs and audit reports, potentially exposing new defects.
Our tool adopts a modular design, enabling the development of
analyzers and detectors for new defects without affecting the
overall architecture. Additionally, it allows for the restructuring
of existing analyzers and detectors to adapt to updates.
C. Possible Solutions
To assist developers in writing secure TON smart contracts,
we provide possible defect solutions at Table III to help
developers avoid the defined defects.
TABLE III
POSSIBLE SOLUTIONS FOR THE 8 D EFECTS
Contract Defect Possible Solution
Bad RandomnessUse external sources of randomness
via oracles.
Precision LossAllow multiplication to be executed
before division.
Unchecked Return Check return values every time.
Global Var RedefinedAvoid defining variables with the
same names as global variables.
Improper Function
ModifierAdd the impure modifier when a
function has side effects; otherwise,
remove it.
Unchecked Bounced
MessageCatch and process bounced mes-
sage.
Inconsistent DataEnsure that the order and type of
read/write variables are consistent
each time.
Lack End ParseInclude the end_parse function after
each slice read.
VII. R ELATED WORK
A. Smart Contracts Defects
Atzei et al. summarized 12 security vulnerabilities at three
levels— Solidity , EVM, and blockchain. Although this work rep-
resents the first comprehensive overview of attacks on Ethereum
smart contracts, it does not provide rigorous definitions of the
vulnerabilities from a security perspective [ 61]. Chen et al.
used an open card sorting approach to identify and categorize
20 Ethereum smart contract defects from posts collected on
StackExchange [ 12]. In another study, they developed a tool
named DefectChecker, which can detect the smart contract
defects they defined in their previous work by analyzing the
bytecode of smart contracts [ 14]. The research team recently
provided precise definitions for five specific defects in NFT
smart contracts. Based on these definitions, they developed
a tool called NFTGuard, which uses symbolic execution to
detect these defined defects [ 37]. Overall, current research onsmart contract defect definitions remains focused on the Solidity
language and the Ethereum ecosystem. Studies on other smart
contract development languages and blockchain ecosystems
are limited. Our work addresses this gap by identifying defects
specific to FunC smart contracts.
B. Detection Tools for Solidity Smart Contracts
Tools for detecting security issues in Solidity smart contracts
are currently abundant. Specifically, Luu et al. proposed a tool
named Oyente, which detects smart contract vulnerabilities
based on symbolic execution [ 62]. Similarly, Nikoli ´c et al.
developed a tool called MAIAN, also based on symbolic
execution, that detects smart contract security issues using
defined execution rules, similar to Oyente [ 63]. Securify
decompiles EVM bytecode and analyzes semantic information
to detect smart contract security issues, capable of identifying
9 security problems [ 64]. Mythril, an industrial tool developed
by ConsenSys, constructs a CFG and uses Z3 [ 65] as an SMT
solver to detect issues based on predefined rules [ 66]. All these
tools are developed using static analysis techniques, consistent
with the technical background of our work. Some work is
based on dynamic techniques. Specifically, ContractFuzzer
[67], ItyFuzz [ 68], and sFuzz [ 69] utilize fuzzing techniques
to detect security issues in Solidity smart contracts.
VIII. C ONCLUSION
In this paper, our research addresses a significant gap in the
field of smart contract security on TON blockchain, an area
previously underexplored compared to platforms like Ethereum.
We analyze the collected official blogs and audit reports to
define 8 defects in TON smart contracts. Additionally, we
provide FunC code examples for each defect, which helps
developers and researchers gain a deeper understanding of
these defects. In this paper, we summarize eight defects for
TON smart contracts by analyzing official blogs and audit
reports. We then present TONScanner, a framework designed
to accurately detect these TON defects. The tool leverages
static analysis techniques to transform source code into a
SSA-form IR , facilitating efficient and precise detection of
various smart contract defects. TONScanner is built with a
modular design, allowing developers to customize analyzers
and detectors to identify potential new defects. Our evaluation
shows that TONScanner can effectively identify defects in
FunC andTact smart contracts, discovering a total of 14,995
defects across both datasets. TONScanner achieved overall
precision rates of 95.09% and 100% on the manually labeled
FunC andTact datasets, respectively. The overall precision rate
on total datasets is 97.49%.
IX. A CKNOWLEDGMENT
The authors thank Ton Foundation and BitsLab for their
invaluable support and the anonymous reviewers for their
constructive comments. This work is partially supported by
the National Natural Science Foundation of China (Grant
No. 62332004) and the Sichuan Provincial Natural Science
Foundation for Distinguished Young Scholars (Grant No.
2023NSFSC1963).REFERENCES
[1]“Ton: The open network for everyone,” 2024. [Online]. Available:
https://ton.org/
[2]Y . Liu, C. Lyu, F. Bai, O. Parishwad, and Y . Li, “The role of intelligent
technology in the development of urban air mobility systems: A technical
perspective,” Fundamental Research , vol. 4, no. 5, pp. 1017–1024, 2024.
[3]T. Kol, “Six unique aspects of ton blockchain that will surprise solidity
developers,” 2022. [Online]. Available: https://blog.ton.org/six-unique-a
spects-of-ton-blockchain-that-will-surprise-solidity-developers
[4]N. Durov, “The open network,” 2021. [Online]. Available: https:
//ton-blockchain.github.io/docs/ton.pdf
[5] DefiLlama, 2024. [Online]. Available: https://defillama.com/chain/TON
[6]Z. Zheng, S. Xie, H. Dai, X. Chen, and H. Wang, “An overview of
blockchain technology: Architecture, consensus, and future trends,” in
2017 IEEE International Congress on Big Data (BigData Congress) .
IEEE, 2017, pp. 557–564.
[7]X. Meng, Y . Li, K. Liu, Y . Liu, B. Yang, X. Song, G. Liao, S. Wang,
Z. Yu, L. Chen, X. Pan, and Y . Lin, “Spatial data intelligence and city
metaverse: A review,” Fundamental Research , 2023.
[8]Y . Jingyu, Y . Bo, W. Tao, and Z. Wenzheng, “A distributed self-tallying
electronic voting system using the smart contract,” Chinese Journal of
Electronics , vol. 33, no. 4, pp. 1063–1076, 2024.
[9]T. Kol, “How to shard your ton smart contract and why -
studying the anatomy of ton’s jettons,” 2022. [Online]. Available:
https://blog.ton.org/how-to-shard-your-ton-smart-contract-and-why-stu
dying-the-anatomy-of-tons-jettons
[10] B. Mehdi, “Cells as data storage,” 2023. [Online]. Available:
https://docs.ton.org/learn/overviews/cells
[11] K. Vladislav, “Func cookbook,” 2024. [Online]. Available: https:
//docs.ton.org/develop/func/cookbook
[12] J. Chen, X. Xia, D. Lo, J. Grundy, X. Luo, and T. Chen, “Defining
smart contract defects on ethereum,” IEEE Transactions on Software
Engineering , vol. 48, no. 1, pp. 327–345, 2022.
[13] Z. Li, H. Wu, J. Xu, X. Wang, L. Zhang, and Z. Chen, “Musc: A tool for
mutation testing of ethereum smart contract,” in 2019 34th IEEE/ACM
International Conference on Automated Software Engineering (ASE) ,
2019, pp. 1198–1201.
[14] J. Chen, X. Xia, D. Lo, J. Grundy, X. Luo, and T. Chen, “Defectchecker:
Automated smart contract defect detection by analyzing evm bytecode,”
IEEE Transactions on Software Engineering , vol. 48, no. 7, pp. 2189–
2207, 2022.
[15] Z. Zheng, N. Zhang, J. Su, Z. Zhong, M. Ye, and J. Chen, “Turn
the rudder: A beacon of reentrancy detection for smart contracts on
ethereum,” in 2023 IEEE/ACM 45th International Conference on Software
Engineering (ICSE) , 2023, pp. 295–306.
[16] Z. He, Z. Li, S. Yang, A. Qiao, X. Zhang, X. Luo, and T. Chen, “Large
language models for blockchain security: A systematic literature review,”
arXiv preprint arXiv:2403.14280 , 2024.
[17] “Ton docs,” 2024. [Online]. Available: https://docs.ton.org/
[18] “Ton blog,” 2024. [Online]. Available: https://blog.ton.org/
[19] “Ton research,” 2024. [Online]. Available: https://tonresear.ch/
[20] D. Spencer, Card Sorting: Designing Usable Categories . Rosenfeld
Media, 2009.
[21] Roman, “Func language overview,” 2024. [Online]. Available:
https://docs.ton.org/develop/func/overview
[22] P. Jinxue, W. Yong, X. Jingfeng, and L. Zhenyan, “Fast cross-platform
binary code similarity detection framework based on cfgs taking
advantage of nlp and inductive gnn,” Chinese Journal of Electronics ,
vol. 33, no. 1, pp. 128–138, 2024.
[23] C. Haoliang, S. Shuai, N. Shaozhang, Z. Wen, and Y . Yang, “Container-
based privacy preserving scheme for android applications,” Chinese
Journal of Electronics , vol. 29, no. 4, pp. 731–737, 2020.
[24] T. S. Foundation, “Tact documentation,” 2024. [Online]. Available:
https://docs.tact-lang.org/
[25] N. Szabo, “Formalizing and securing relationships on public networks,”
First monday , 1997.
[26] Q. Liu, Z. Chen, and S. X. Xiao, “A theory of carbon currency,”
Fundamental Research , vol. 2, no. 3, pp. 375–383, 2022.
[27] Wikipedia, “Execution model,” 2024. [Online]. Available: https:
//en.wikipedia.org/wiki/Execution_model
[28] Z. He, Z. Li, A. Qiao, X. Luo, X. Zhang, T. Chen, S. Song, D. Liu, and
W. Niu, “Nurgle: Exacerbating resource consumption in blockchain state
storage via mpt manipulation,” arXiv preprint arXiv:2406.10687 , 2024.[29] Z. He, S. Song, Y . Bai, X. Luo, T. Chen, W. Zhang, P. He, H. Li,
X. Lin, and X. Zhang, “Tokenaware: Accurate and efficient bookkeeping
recognition for token smart contracts,” ACM Transactions on Software
Engineering and Methodology , vol. 32, no. 1, pp. 1–35, 2023.
[30] G. Wood, “Ethereum: A secure decentralised generalised transaction
ledger,” 2024. [Online]. Available: https://ethereum.github.io/yellowpap
er/paper.pdf
[31] Roman, “Tvm overview,” 2024. [Online]. Available: https://docs.ton.org
/learn/tvm-instructions/tvm-overview
[32] Antonoff, “Transaction fees,” 2024. [Online]. Available: https:
//docs.ton.org/develop/smart-contracts/fees
[33] A. Tsivarev, “Cell & bag of cells (boc),” 2024. [Online]. Available:
https://docs.ton.org/develop/data-formats/cell-boc
[34] N. Durov, “Telegram open network virtual machine,” 2020. [Online].
Available: https://ton.org/tvm.pdf
[35] ——, “Fift: A brief introduction,” 2020. [Online]. Available:
https://ton.org/fiftbase.pdf
[36] K. Vladislav, “Solidity vs func,” 2024. [Online]. Available: https:
//docs.ton.org/develop/ethereum-to-ton/solidity-vs-func
[37] S. Yang, J. Chen, and Z. Zheng, “Definition and detection of defects
in nft smart contracts,” in Proceedings of the 32nd ACM SIGSOFT
International Symposium on Software Testing and Analysis , 2023, pp.
373–384.
[38] OpenZeppelin, “Proxy upgrade pattern,” 2024. [Online]. Available:
https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies
[39] Full-Hat, “Func standard library,” 2024. [Online]. Available: https:
//docs.ton.org/develop/func/stdlib#set_c3
[40] sansx, “Security assurance providers(sap),” 2024. [Online]. Available:
https://docs.ton.org/develop/companies/auditors
[41] Certik, “Security assessment,” 2023. [Online]. Available: https:
//skynet.certik.com/projects/the-open-network
[42] Quantstam, “Ton locker contract,” 2023. [Online]. Available: https:
//certificate.quantstamp.com/full/ton-locker-contract/6872997f-1110-4
5cc-b70f-2a4cd639da1f/index.html
[43] “Ton vesting,” 2022. [Online]. Available: https://skynet.certik.com/projec
ts/the-open-network?auditId=TON%20Vesting#code-security
[44] Certik, “Secure smart contract programming in func: Top 10 tips for ton
developers,” 2023. [Online]. Available: https://blog.ton.org/secure-smart
-contract-programming-in-func
[45] Anonymity, “Why true randomness is important in web3,” 2023.
[Online]. Available: https://chain.link/education-hub/randomness-web3
[46] EmelyanenkoK, “Statements,” 2023. [Online]. Available: https:
//docs.ton.org/develop/func/statements
[47] Wikipedia, “Decentralized finance,” 2024. [Online]. Available: https:
//en.wikipedia.org/wiki/Decentralized_finance
[48] AlexG, “Functions,” 2023. [Online]. Available: https://docs.ton.org/devel
op/func/functions
[49] Z. Wang, X. Chen, X. Zhou, Y . Huang, Z. Zheng, and J. Wu, “An
empirical study of solidity language features,” in 2021 IEEE 21st
International Conference on Software Quality, Reliability and Security
Companion (QRS-C) , 2021, pp. 698–707.
[50] Anonymity, “State mutability,” 2023. [Online]. Available: https:
//docs.soliditylang.org/en/latest/contracts.html#state-mutability
[51] K. Roman, “Func standard library,” 2024. [Online]. Available:
https://docs.ton.org/develop/func/stdlib
[52] R. Ma, “Wallet communication,” 2024. [Online]. Available: https://docs
.ton.org/develop/smart-contracts/tutorials/wallet#wallet-communication
[53] K. Vladislav, “Secure smart contract programming,” 2024. [Online].
Available: https://docs.ton.org/mandarin/develop/smart-contracts/security/
secure-programming
[54] Wikipedia, “Basic block,” 2023. [Online]. Available: https://en.wikipedia
.org/wiki/Basic_block
[55] Anonymity, “Static single assignment book,” 2018. [Online]. Available:
https://pfalcon.github.io/ssabook/latest/book-full.pdf
[56] Roman, “Types,” 2024. [Online]. Available: https://docs.ton.org/develop
/func/types
[57] AlexG, “Sending messages,” 2024. [Online]. Available: https:
//docs.ton.org/develop/smart-contracts/messages
[58] “Ton verifier,” 2023. [Online]. Available: https://verifier.ton.org/
[59] Wikipedia, “Confidence interval,” 2024. [Online]. Available: https:
//en.wikipedia.org/wiki/Confidence_interval
[60] SurveyMonkey, “Sample size calculator,” 2024. [Online]. Available:
https://zh.surveymonkey.com/mp/sample-size-calculator/[61] N. Atzei, M. Bartoletti, and T. Cimoli, “A survey of attacks on
ethereum smart contracts (sok),” in Principles of Security and Trust: 6th
International Conference, POST 2017, Held as Part of the European
Joint Conferences on Theory and Practice of Software, ETAPS 2017,
Uppsala, Sweden, April 22-29, 2017, Proceedings 6 . Springer, 2017,
pp. 164–186.
[62] L. Luu, D.-H. Chu, H. Olickel, P. Saxena, and A. Hobor, “Making smart
contracts smarter,” in Proceedings of the 2016 ACM SIGSAC conference
on computer and communications security , 2016, pp. 254–269.
[63] I. Nikoli ´c, A. Kolluri, I. Sergey, P. Saxena, and A. Hobor, “Finding
the greedy, prodigal, and suicidal contracts at scale,” in Proceedings of
the 34th annual computer security applications conference , 2018, pp.
653–663.
[64] P. Tsankov, A. Dan, D. Drachsler-Cohen, A. Gervais, F. Buenzli, and
M. Vechev, “Securify: Practical security analysis of smart contracts,” in
Proceedings of the 2018 ACM SIGSAC conference on computer and
communications security , 2018, pp. 67–82.
[65] L. De Moura and N. Bjørner, “Z3: An efficient smt solver,” in
International conference on Tools and Algorithms for the Construction
and Analysis of Systems . Springer, 2008, pp. 337–340.
[66] Consensys, “Mythril,” 2024. [Online]. Available: https://github.com/Con
senSys/mythril
[67] B. Jiang, Y . Liu, and W. K. Chan, “Contractfuzzer: Fuzzing smart
contracts for vulnerability detection,” in Proceedings of the 33rd
ACM/IEEE international conference on automated software engineering ,
2018, pp. 259–269.
[68] C. Shou, S. Tan, and K. Sen, “Ityfuzz: Snapshot-based fuzzer for smart
contract,” in Proceedings of the 32nd ACM SIGSOFT International
Symposium on Software Testing and Analysis , 2023, pp. 322–333.
[69] T. D. Nguyen, L. H. Pham, J. Sun, Y . Lin, and Q. T. Minh, “sfuzz: An
efficient adaptive fuzzer for solidity smart contracts,” in Proceedings of
the ACM/IEEE 42nd International Conference on Software Engineering ,
2020, pp. 778–788.