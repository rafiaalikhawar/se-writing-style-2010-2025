M3: Semantic API Migrations
Bruce Collie
School of Informatics
University of Edinburgh
Edinburgh, United Kingdom
bruce.collie@ed.ac.ukPhilip Ginsbach‚àó
GitHub Software UK
Oxford, United Kingdom
ginsbach@github.comJackson Woodruff
School of Informatics
University of Edinburgh
Edinburgh, United Kingdom
J.C.Woodruff@sms.ed.ac.uk
Ajitha Rajan
School of Informatics
University of Edinburgh
Edinburgh, United Kingdom
arajan@inf.ed.ac.ukMichael F.P. O‚ÄôBoyle
School of Informatics
University of Edinburgh
Edinburgh, United Kingdom
mob@inf.ed.ac.uk
ABSTRACT
Librarymigrationisachallengingproblem,wheremostexisting
approaches rely on prior knowledge. This can be, for example,
informationderivedfromchangelogsorstatisticalmodelsofAPI
usage.
ThispaperaddressesadifferentAPImigrationscenariowhere
thereisnopriorknowledgeofthetargetlibrary.Wehavenohistori-calchangelogsandnoaccesstoitsinternalrepresentation.Totackle
this problem, this paper proposes a novel approach (M3), where
probabilisticprogramsynthesisisusedto semantically modelthe
behavior of library functions. Then, we use an SMT-based code
searchenginetodiscoversimilarcodeinuserapplications.These
discoveredinstancesprovidepotentiallocationsforAPImigrations.
Weevaluateourapproachagainst7well-knownlibrariesfrom
variedapplicationdomains,learningcorrectimplementationsfor
94 functions. Our approach is integrated with standard compiler
tooling,andweusethisintegrationtoevaluatemigrationoppor-
tunities in 9 existing C/C++ applications with over 1MLoC. Wediscover over 7,000 instances of these functions, of which more
than 2,000 represent migration opportunities.
CCS CONCEPTS
‚Ä¢Softwareanditsengineering ‚ÜíSoftwaremaintenancetools ;
Software verification and validation ; Compilers.
ACM Reference Format:
Bruce Collie, Philip Ginsbach, Jackson Woodruff, Ajitha Rajan, and Michael
F.P.O‚ÄôBoyle.2020.M3:SemanticAPIMigrations.In 35thIEEE/ACMInterna-
tionalConferenceonAutomatedSoftwareEngineering(ASE‚Äô20),September
21‚Äì25,2020,VirtualEvent,Australia. ACM,NewYork,NY,USA,13pages.
https://doi.org/10.1145/3324884.3416618
‚àóWork performed while at the University of Edinburgh
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ‚Äô20, September 21‚Äì25, 2020, Virtual Event, Australia
¬© 2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.34166181 INTRODUCTION
1.1 API Migration
Libraries are a fundamental feature of software development. They
allowthesharingofcommoncode, separationofconcernsanda
reduction in overall development time. However, libraries are not
static.Theycontinuallyevolvetoprovideincreasedfunctionality,
security and performance. Unfortunately, upgrading software to
matchlibraryevolutionisasignificantengineeringchallengefor
large code bases.
Given the wide-scale nature of the problem, there is much prior
work in the area under various headings (e.g. library upgrade, API
evolutionorlibrarymigration).Workintheseareasaimstoanswer
the same question: when (and how) can a program using API ùëãbe
transformed to one that uses API ùëåwhile preserving its behavior?
Thisisadifficultproblemevenwhen ùëãandùëåhavesimilarinterfaces.
Itbecomesmorechallengingiftheir behaviors donotmatch,and
requires surrounding code to be factored in.
Thereareseveralapproachestothismigrationproblem:ifexam-
plesexistofprevioussuccessfulmigrations,thentheseexamples
canbeusedtoderivemappingrules[ 51].Thisapproachrequires
thatafullhistoryoftheapplication‚Äôssourcecodeisavailable,anno-
tated with the libraries in use at each commit. Neural models have
beenusedsuccessfully topredictpropertiesofprograms basedon
learned vector-space embeddings [ 32]. However, these approaches
require large training sets and are imprecise with respect to pro-
gram semantics. A more precise (but less automatic) approach is to
useexpertknowledgetoencodeknownmigrationpatterns[ 43,53].
AllthesepriorapproachesrequiresomeknowledgeoftheAPI.In
this paper we tackle the challenging task of API migration without
any prior knowledge of the source or target libraries. Here, wedo not have access to the library‚Äôs source code, nor to a corpusof example usages of the library. While this scenario may seemdraconian, it is often the case in practice [
26]. Libraries may be
closed-source[ 50]ordistributedinbinariesforconvenience[ 29],
and could even be implemented as hardware [ 10]. In this paper we
proposeanovelapproachwhichautomaticallylearnspattern-based
semantic migrations, but without up-front expert knowledge.
902020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
APPLICATION
ORIGINAL
SOURCE CODE
LIBRARY
SOURCE
FUNCTIONSLAPPLICATION
LLVM IR
(WITH CALLS )
SYNTHESIZED
LLVM IRPROGRAMS LAPPLICATION
LLVM IR
CONSTRAINT
DESCRIPTIONCAnDLAPPLICATION
CANDIDATE
(NEW CALLS )COMPILE
SYNTHESIZE
SYNTHESIZEMODEL
MATCHMIGRATEINLINE
INLINE
GENERALIZETEST
APPLICATION
VERIFIED
(NEW CALLS )LIBRARY
TARGET
FUNCTIONSL'
SYNTHESIZED
LLVM IRPROGRAMS L'
Figure 1: A summary of the M3workflow. Models for library functions are synthesized. Source functions are inlined while
synthesized target functions are generalized into constraint descriptions, which are then used to search compiled user code
for potential migrations.
1.2 M3: Model, Match and Migrate
The key to our approach is to derive a model that is actual exe-
cutable code. We call such an approach semantics-based migration.
Givenaspecificationforalibraryfunction(typesignature,function
name, library binary containing its implementation), M3attempts
toautomatically Modelitsbehaviorusingprogramsynthesisand
checks correctness with respect to automatically generated input-
output examples. It inlines the learned program models, then uses
compiler-based constraint analysis to Matchregions of application
code with compatible libraries. Finally, we Migratethese regions
by replacing application code with library calls.
A useful feature of this approach is that as well as library mi-
gration, it allows the refactoring of library-free user code to uselibraries. This is because the synthesized models are themselves
code, and are inlined and analyzed together with application code.
ComplexrefactoringsthatintegratecontextualcodearoundanAPI
call are enabled by this approach.
Our approach, while having the benefit of not requiring library
vendors to release their source code, relies on the ability to syn-
thesize programs in a reasonable time. We build on methods from
sketch-basedsynthesis[ 48]todiscoverprogramstructurebefore
performing a directed enumerative search. We incorporate new
probabilisticmodelstomoreeffectivelynavigatethelargesearch
space. We evaluate our approach across 7 libraries, synthesizing
94 functions, and match them to over 7,000 old library calls across
10 applications with up to 1MLoC. We were able to successfully
migrate more than 2,000 of these calls to another library.
Summary of Contributions. We provide a novel and efficient pro-
gram synthesizer for real-world library functions. Additionally, we
detail a method for matching similar code in applications using
solver-aidedtechniques.Usingthisprocedure,weareabletodis-
cover opportunities for usages of a source library Lor application
codeCtobemigratedtoatargetlibrary L‚Äô.Furthermore,wecan
migrate source libraries with surrounding contextual code ( C+L)to target libraries. This is achieved without any knowledge about
the implementation of either library.
2 OVERVIEW
In this section, we first present a high-level summary of the M3
workflow,thenshowanexampleofthetypeofmigrationsitenables
in practice.
2.1 M3Workflow
Figure 1 shows the flow of data through M3. It takes as input an
application, along with specifications for source and target library
APIs (currently used Land potential targets L‚Äô). The end result
is a modified application that references the target libraries. We
highlight the three distinct phases: Model,MatchandMigrate.
2.1.1 Model. Weassumethatthesourcecodeforlibrariesisnot
available, as is often the case in practice [ 26]. The first phase of
M3is Model: the synthesis of programs equivalent to functions in
boththesourceandtargetlibraries.Theprogramswesynthesize
are in the form of LLVM [ 27] intermediate representation; this
representationallowsustodirectlyintegratesynthesizedprogramsinexistingcompilertoolchains,andtobenefitfromrobustprogram
manipulation libraries. The synthesis process is specified using
randomly-generated input-output examples (see Section 3.1.1).
2.1.2 Match. Thesecondphase,Match,usesthesynthesizedim-
plementationsofsourceandtargetlibraryfunctionsintwoways.
First, we inline the synthesized code of the sourcelibrary functions
intotheuserapplicationateachcallsite.Secondly,wegeneralize
the synthesized code of the targetlibrary functions to a constraint-
based description that allows for matching code to be efficiently
searched for.
Performing inlining means that the behavior of the library func-
tionandthe contextinwhichitappearsareunified;migrationsthat
requiresplitting,mergingormovingfunctionalitycanbediscov-
ered and performed.
91call + context
strncpy(fn_buf, argv[0], n);
fn_buf[n - 1] = '\0';1
strlcpy(fn_buf, argv[0], n);
for(int i = 0; i < n; ++i) {  fn_buf[i] = argv[0][i];}fn_buf[n - 1] = '\0';user code + context
2
strlcpy(fn_buf, argv[0], n);
strlcpy(fn_buf, argv[0], n);strlcpy(pt_buf, argv[1], m);// handle other buffers...strncpy(fn_buf, argv[0], n);strncpy(pt_buf, argv[1], m);// handle other buffers...fn_buf[n - 1] = '\0';pt_buf[m - 1] = '\0';interleaved context
3
Figure 2: Example of three contexts in which M3is able to
performcontextualAPImigrationsusingonlythebehavior
of the source and target functions.
2.1.3 Migrate. Once matches are found, we verify whether or not
potentialmigrationsarecorrect.First,weperformbasicintegration
testing using random examples on the new code. This helps toeliminatefalsepositivematches.Atthisstage,themigrationcan
beperformedautomatically,althoughinpracticetheuserwouldbeaskedtoconfirmthemigration(asisusualwithAPImigrationtools).
We perform integration testing to check correctness of Migrate.
2.2 Example
To demonstrate the types of migration that M3offers, we use a
running example taken from the Common Weakness Enumeration
(CWE) database [ 1]. If the standard strncpy function is used
to copy a C string, null-termination is not guaranteed. This can
leadtobufferover-reads,andsoalternativefunctionsoftenexist
to perform a terminated copy (for example, strlcpy on BSD,
StringCchCopy on Windows or application-specific implemen-
tations).CWE-126identifiesacommonpatternofmanuallyadding
stringterminatorsthatcanbereplacedbythesefunctions;doing
so is a useful API migration task.
Figure2showsthethreepatternsidentifiedinCWE-126thatcan
berefactoredfor safety.Thefirstcase 1isthesimplest: acallto
strncpy isimmediatelyfollowedbyanexplicittermination.This
migrationcouldbeperformedusingtoolssuchasRefaster[ 53],but
would require an expert to encode it manually.Thesecondcase 2highlightstheutilityofM3:afterperforming
inlining,thecodethatexplicitlycalls strncpy isnodifferentto
code that performs an explicit loop. Both of these patterns exist in
realcode,andcanbemigratedequivalentlyusingM3.Becausemany
different syntaxes might represent the same semantics, writingsource-code based tools that discover loops in this way is a hard
problem [ 20]; M3‚Äôs compiler integration and IR-level search allows
it to handle loops and other control flow statements seamlessly.
Finally,thethirdcase 3showsacomplexmigrationwherecalls
tostrncpy areinterleavedwiththeirrespectiveterminations.By
operatingattheIRlevel,M3isabletoidentifythatnodependencies
exist between the calls, and so the migration is possible. In general,
source code-based tools, even with expert knowledge, are less able
to make this determination.
Unifyingthesedifferentformsofmigrationwithoutrequiringup-
frontexpertknowledgeorlibrarysourcecodeisthekeyadvantage
of M3.
3 MODEL
The Model phase of M3is a program synthesizer; it aims to gener-
atefunctionsthatbehaveequivalentlytotargetlibraryfunctions.
Modelusescomponent-basedsketching[ 24]togetherwithnovel
learnedprobabilisticmodelstoefficientlysearchforthemostlikely
structure for correct solutions. Then, a gradual refinement pro-
cess is used to instantiate working programs from these structures.
Candidatesaretestedagainstthetargetfunctionusingrandomly-
generated inputs; the adequacy of this testing strategy is validated
using branch coverage.
3.1 Correctness
Providingaformalproofoftotalcorrectnessforthistypeofsyn-
thesis problem is extremely complex [15]. In this paper, we define
correctness using the standard formulation of observational equiva-
lence: a candidate is correct if it behaves identically to the target
over a particular set of input examples. Most work in synthesis
using input-output examples shares this formulation [14, 47].
This definition relies on a good enough set of input examples
beingavailable.Wecannotrelyontheuserknowingenoughofthetarget‚Äôssemanticstoproduceasetofminimal,interestingexamples
[19,33] (and in fact wish to abstract this process away from the
user). We therefore resort to random generation of input examples.
3.1.1 Generating TestInputs. TheModelphasesupportsthe primi-
tive C types char,intandfloat, and pointers to these types.
Values of integer and floating-point types are generated by sam-
pling values uniformly in the range [‚àí64,64], and for characters
fromtheirentirerange.Forpointerdata,blocksof4,096elements
areallocated(toallowforlargecomputedindicesbasedoninput
data). Each element of these blocks is sampled according to the
appropriate scalar sampling method.
Existingworkonfuzzingandautomatedtesting[ 60]generally
observes that interesting behavior most often occurs at small input
values;ourinputrangewasselectedtoprovideavarieddistribu-
tion of values while also maintaining a reasonable probability of
generating small (and therefore interesting) inputs.
Our input generation methodology can be easily generalized to
moretypes;furtherprimitivetypes(e.g.differentlysizedintegersor
92booleans)followthesamemethodology,whileaggregatetypes(e.g.
aCstruct) can be generated compositionally over their individ-
ualelements.Generatingdatastructureswithinternalinvariants
or unusual distributions is an open problem [46].
3.1.2 TestingCoverage. Itisimportantthattherandomlygener-
ated inputs properly exercise the possible behaviors of both the
targetandcandidate. Whileitisnot possibletomeasurecoverage
forablack-boxtargetintheabsenceofsourcecode,wemeasure
branch coverage over each candidate during synthesis. New inputs
are generated until full coverage is achieved.
OurresultsinSection7.2showthatrandomtestingandcoverage
measurement is an effective means to validate the behavior of
synthesized programs.
3.2 Specification
Two inputs fully specify a synthesis problem: the type signature
and name of the target function, and a library containing an im-
plementation with that name. There are no requirements on the
internal details of this implementation.
Nofurtherinformationaboutthetargetfunctionisrequired.For
example,basecasesorsemanticannotations(suchasthoseusedby
ùúÜ2[19]orinthetype-directedsynthesisproceduredemonstrated
byCollieetal .[11])arenotrequiredbyourimplementation,andwe
do not require manually created inputs to test candidate programs
asother synthesizerssuch as Simpl[47]or SketchAdapt [33]do.
3.3 Fragment-Based Sketching
Program synthesis commonly divides the search for a solution into
twophases.Thefirst,sketching,aimstoestablishthe structure of
a solution. In its initial formulation, sketches were provided by
theuserbasedontheirinsightintotheproblem[ 48].Bydoingso,
searchforprogramswithcomplexcontrolflowcouldbereducedtomoretractableproblems.Morerecentapproachesaimtosynthesize
the sketch as well [ 17,33,52]. Our approach falls into this group
asitdoesnotrequiretheusertoprovideanysketchinformation.
Instead, it uses a novel probabilistic approach.
Weaimtobuildsketchescompositionallyfromsmaller fragments,
whichrepresentindependentelementsofprogramstructure.For
example, a program that performs a linear search may comprise a
loop fragment composed with a conditional test fragment. Some
fragmentsareparameterized;inthesecasesdifferentvariantsofthe
fragment are instantiated depending on the available information
foragivenproblem.ThefullsetoffragmentsusedbyM3toperform
synthesisarelistedbelow,alongwithC-likepseudocodedescribing
their semantics.
3.3.1 FragmentCorpus. ThelibraryoffragmentsusedbyModel
isgivenbelow.The usefunctionrepresentscodegeneratedthat
mayuseaparticularvalue, ?ispossiblecomposition,and _Pisa
placeholder value of appropriate type.LinearAbasicblockintowhichinstructionsshouldlaterbesyn-
thesized.
Fixed Loop Templateforaloopwithknownupperbound,param-
eterized on an optional pointer ptrand an integer x:
for(int i=0;i<x;++i) { ?}
for(int i=0;i<x;++i) { use(ptr[i]);? }
Delimiter Loop Template parameterized on a pointer ptr:
while( *ptr++ != _P) { use( *ptr); ?}
LoopAcatch-allforiterationsnotcoveredbythetwomorespe-
cialized fragments:while(_P) { ?}
If, If-Else Conditional control flow:
if(_P) { ?}
if(_P) { ?}else {?}
SeqExecute two fragments, one after the other:
?;?
Affine, Index
Synthesize affine and general index expressions re-
spectively, parameterized on ptr. For example:
int a_v =ptr[_P *_P+_P]; // e.g.
int v=ptr[_P -_P]; // e.g.
Theavailablesetoffragmentsfora synthesisproblemdepends
on which ones can be properly instantiated; we write Ffor this set.
Inthisworkweuseonlythefragmentsdescribedabove,butitis
possibleforuserstoextendthecorpusoffragments(forexample,
to specialize for a particular problem domain with partially-known
structure).
3.3.2 Composition. We define an intuitive composition operation
betweenanytwofragments,with ‚ó¶theleft-associativecomposition
operator.
3.4 Probabilistic Models
Thesetofpossiblefragmentcompositionsforsomeproblemsisvery
large.Modelusestwocooperatingprobabilisticmodelstoreduce
the size of the search space. The first predicts which fragmentsfrom the available set are most likely to appear anywhere in a
correctsolution,andthesecondusesaMarkovmodeltoidentify
compositions of fragments most likely to yield a correct program.
3.4.1 Fragment Likelihood. We use a random forest classification
model topredict, foreach fragment ùëì‚ààF, whetherit appearsin a
correctsolutionprogram.Theclassifier ùê∂takesasinputafragment
ùëìand type signature ùúè, and outputs a prediction of whether this
fragment willappear in acorrect solutionfor a functionwith that
typesignature.Applyingtheclassifier ùê∂toeveryfragmentproduces
a predicted set of fragments F0‚äÜF:
F0/defines{ùëì‚ààF|ùê∂(ùëì,ùúè)}
WeachievedameanJaccardscoreof0.82between FandF0using
this predictor; this means that the predictor does not significantlyover- or under-approximate.
3.4.2 CompositionSampling. Therearealargenumberofpotential
compositionsover F0thatproduceasketch.Itisthereforeimportant
to predict which compositions are the most likely to produce a
correct solution.
Weequatethelinearsequenceoffragments ùëì1,ùëì2,...,ùëì ùëõwiththe
composition ùëì1‚ó¶ùëì2‚ó¶¬∑¬∑¬∑‚ó¶ùëìùëõ.Thisallowsustosamplecompositions
93using a simple Markov model. To do so, we add start and end sym-
bolstothefragmentvocabulary,andsamplefragmentsaccording
to the probability P(ùëìùëõ|ùëìùëõ‚àí1)until the end symbol is sampled.
Theconditionalprobability P(ùëìùëõ|ùëìùëõ‚àí1)istrainedusingobserved
fragment composition bigrams. For example, if a sketch from com-
positionùëì‚ó¶ùëî‚ó¶‚Ñéproducesacorrectsolution,thenthebigrams ùëì‚ó¶ùëî
andùëî‚ó¶‚Ñéare both observed. Based on a matrix ùë§of observation
counts (where ùë§(ùëì,ùëì/prime)is the observed count of ùëì‚ó¶ùëì/prime), we define:
ùë§/prime(ùëìùëñ,ùëìùëó)/defines/braceleftBigg
ùë§(ùëìùëñ,ùëìùëó)ifùëìùëó‚ààF0
0 otherwise
ùë†(ùëì)/defines/summationdisplay.1
ùëì‚ààF0ùë§(ùëì,ùëì/prime)
ùë†/prime(ùëì)/defines/summationdisplay.1
ùëì‚ààF0ùë§/prime(ùëì,ùëì/prime)
Then, the Markov probabilities can be given as:
P(ùëìùëõ|ùëìùëõ‚àí1)/definesùëèùë§/prime(ùëìùëõ,ùëìùëõ‚àí1)
ùë†/prime(ùëìùëõ‚àí1)+(1‚àíùëè)ùë§(ùëìùëõ,ùëìùëõ‚àí1)
ùë†(ùëìùëõ‚àí1)
whereùëè‚àà[0,1]
3.4.3 Training. To train these models, a 25% subset of our evalua-
tionlibraryfunctionswasselectedrandomly.Groundtruthsketches
wereconstructedbyhandforeachtargetfunctioninthissubsetand
usedtotrainbothmodels.A25%trainingsetsplitwasidentified
through manual parameter search; there is enough redundancy
amongthefunctionstoenabletheuseofasmalltrainingpropor-
tion.
We do not believe the construction of such a training dataset
to be particularly onerous when compared to statistical migration
techniques, which often entail cleaning and preprocessing millions
oflinesofcode.Additionally,itispossibleto bootstrap ourtraining
set starting from the synthesized solutions to simple problems.
Doingsoprovidesnobenefittothemodelperformance(onlytothecollectionoftrainingdata),andsointhispaperwedonotexamine
the process.
3.5 Instruction Search
ThefinalstepinModel‚Äôssynthesisprocessistoperformanenumer-
ativesearchforcandidateprogramsbasedonpredictedsketches.Each fragment specifies a set of typed placeholder values; these
identifywherecomputationcanbeperformedwithinthatfragment.For example, in the LLVM code below, the values
%0and%2repre-
sent(possiblydistinct)valuesoftype i32.Placeholdersmayalso
be untyped (%1 below).
%0=call i32 @ph_i32()
%1=call void @ph()
%2=call i32 @ph_i32()
%3=call i1 @ph_i1()
To search for candidate programsbased on asketch with place-
holders, Model assigns concrete values to each placeholder in turn;
differentchoicesofvaluesproducedifferentprograms.Asvalues
areselected,thepotentialchoicesforothervaluesmayberestricted.
Theresultofthisisalightweightconstraint-solvingproblem(for
example, if the value add i32 %0, %1were selected for %2,
then the type of %1would be restricted to i32). Precise detailsof how this constraint problem can be implemented by the com-piler are given in prior work [
12]. To optimize the traversal of a
potentially large search space, Model uses the following heuristics:
‚Ä¢Placeholders of known type are assigned first.
‚Ä¢When selecting operands for unary or binary operators,
operands located closer to the operator are prioritized.
‚Ä¢Morecommonoperatorsareprioritized(e.g.additionisat-
tempted before division).
‚Ä¢A threshold for the total number of instructions is set anditeratively relaxed (e.g. initially programs of 3 concretized
instructionsareconsidered,then4ifnosuccessfulcandidate
is found, etc.).
By assigning values in this way, a concrete program is gradually
refinedfromasketch.Fragmentsarenotrequiredtoenforcecon-
crete types on their constituent values, but can enforce constraints
whentheydo(e.g.aconditionalfragmentrequiresabooleanvalue).
Once we have a complete program, we can compile and execute
it using randomly generated input values.
4M A T C H
OnceModelhassynthesizedaprogramwithbehaviorequivalent
to a target library function, the next step is Match: we aim todiscover regions of code that are equivalent to the synthesized
implementation.
4.1 Searching for Code Using CAnDL
Efficiently searching for sections within an application that satisfy
particular criteria is a hard problem to express using traditionalprogramming languages. The CAnDL language [
20] allows for
declarative specification of search patterns, which are compiled
to constraint-satisfaction problems that can be efficiently resolved
using backtracking search (in a manner similar to SMT solvers [ 4]).
CAnDLpatternsspecifydataflowrelationshipsbetweenvalues
inLLVMIRprograms,aswellaspropertiesofindividualvalues.For
example, the property ‚Äú ùë•is an add instruction, and ùë¶is a multiply
withùë•as one of its operands‚Äù is a simple CAnDL pattern. These
patternsamounttoasetof constraints ontheprogramthatmustbe
satisfied for the pattern to match it; searching for matching code is
therefore a constraint satisfaction problem.
WeusethestandardCAnDLtoolchaintoefficientlysolvesuch
constraint problems over LLVM. Full details of the search algo-rithms can be found in [
20]; in this paper we take as given an
efficientsolutionprocedureforCAnDL-compatibleconstraintprob-
lems over LLVM IR programs.
4.2 Translating LLVM to Constraints
In [20] the authors write CAnDL constraints by hand to match
specific computational idioms (for example, polyhedral control
flow or stencil codes) of interest to a domain-specific optimizer. By
comparison, we aim to generate constraints automatically from
synthesized code. Automatic generation of constraints is not a use
case envisioned by the original authors, and so we contribute a
novel algorithm for emitting constraint descriptions from example
LLVM programs.
94%iter =phi i64 [%new_iter,%loop], [0,%entry]
%addr =getelementptr i64,
i64*%array, i64 %iter
%elem =load i64, i64*%addr
%niter =add i64 %iter, 1
(a)FragmentofLLVMcodeextractedfromafunctionthatcomputes
the sum of an array of integers.
1Constraint Generated
2(opcode{iter} = phi
3&opcode{addr} = gep
4&opcode{elem} = load
5&opcode{niter} = add
6&ir_type{0} = literal
7&ir_type{1} = literal
8& {niter} = {iter}.arg[0]
9& {0} = {iter}.arg[1]
10& {array} = {addr}.arg[0]
11& {iter} = {addr}.arg[1]
12& {addr} = {elem}.arg[0]
13& {iter} = {new_iter}.arg[0]
14& {1} = {new_iter}.arg[1])
15End
(b)CAnDLconstraintsgeneratedfromtheLLVMcodeabove.These
constraints capture the structure of the code and can be efficiently
searched for in large LLVM code bases.
Figure 3: LLVM code sample and its corresponding CAnDL
constraints, as generated by Match.
Figure3ashowsasmallfragmentofLLVMIR;thecodeisinSSA
form and can be described by a directed acyclic graph. Below, Fig-
ure3bgivesasetofCAnDLconstraintsthatdescribethisfragment.
Each instruction (as well as constants and function parameters)occurs as a variable name in the constraints; the constraint pro-
gram serves as adescription of the data flow.The data flow graph
is serialized by classifying individual variables (lines 2‚Äì10), and
then the interactions between them (lines 11‚Äì21). This description
is passed to the CAnDL solver to efficiently find satisfying code.
Our constraint descriptions are built from a dataflow graph rep-
resentation of LLVM IR, where vertices are instructions and edges
capturetheargumentrelation.Algorithm1showshowwegenerate
a description of this graph structure.
Looping over the graph vertices (lines 4‚Äì17), the instruction
opcode constraints are emitted, as well as the constraints that deal
specificallywithconstantandfunctionargumentvalues.Inasecondloop(lines18‚Äì20),thedataflowgraphisserializedbyiteratingover
the graph edges and emitting positional argument constraints. The
remaining lines of the algorithm generate the logical conjunctions
holding the individual constraints together (lines 5‚Äì9) and produce
the boilerplate CAnDL code (lines 2 and 21).
4.3 Post-Processing Constraints
This approach results in a constraint program that searches for
exact sub-graph matches in user code, but is often too specific. WeAlgorithm 1 Emit Constraint Description
1:function EmitConstraints( ùëâ,ùê∏)
2:emit("Constraint Generated (")
3:ùëìùëñùëüùë†ùë°‚Üêùë°ùëüùë¢ùëí
4:forùë£inùëâdo
5: ifùëìùëñùëüùë†ùë°then
6: ùëìùëñùëüùë†ùë°‚Üêùëìùëéùëôùë†ùëí
7: else
8: emit("&")
9: end if
10: ifùëúùëù(ùë£)=parameter then
11: emit("ir_type", ùëõùëéùëöùëí(ùë£), " = argument")
12: else ifùëúùëù(ùë£)=constthen
13: emit("ir_type", ùëõùëéùëöùëí(ùë£), " = literal")
14: else
15: emit("opcode", ùëõùëéùëöùëí(ùë£),"=" ,ùëúùëù(ùë£))
16: end if
17:end for
18:forùëõ,ùëé,ùëèinùê∏do
19: emit(ùëõùëéùëöùëí(ùëé),"=" ,ùëõùëéùëöùëí(ùëè), ".args[", ùëõ, "]")
20:end for
21:emit(") End")
22:end function
therefore applya carefulweakening ofthe constraintsto produce
a more general matching.
Firstly, constraints that specify values to be function arguments
arecounterproductive;theseconstraintswillnotholdafterinlining,
so they are removed in post-processing. Secondly, some operators
arecommutativeandthereforethepositionalargumentconstraints
on them are too strict. They are replaced with a logical disjunc-
tion between the corresponding permutations. Finally, we remove
instructions that correspond only to compiler-specific code genera-
tion idioms.
5 MIGRATE
ModelandMatchmakeupthebulkoftheworkdonebyM3.The
final step is to leverage the synthesized programs and generatedconstraints to generate appropriate API migrations. We produce
source-levelsubstitutionsthatcanbeappliedmanuallytothesource
code, as well as automatically-tested IR transformations.
5.1 IR-level Replacements
Migrate is able to automatically apply a potential migration within
anapplicationbeingcompiled.Todothis,theIRvaluesthatmatched
againstalibraryfunction‚Äôsparametersandreturnvalueareiden-
tified.Acalltothefunctionisinsertedwiththeappropriateargu-
ments given, and uses of the matched return value are replaced
with the new call‚Äôs return value.
95Table 1: Corpora used to evaluate M3.
(a) Application source code for which migrations were tested.
Software Description LoC
ffmpeg Media processing 1,061,655
texinfo Typesetting 76,755
xrdp Remote access protocol 75,921
coreutils Utilities 66,355
gems Graphics helpers 46,619
darknet Deep learning 21,299
caffepresso Deep learning 14,602
nanvix Operating system 11,226
etr Game 2,399
androidfs Filesystem 1,840
(b) Library APIs for which synthesized implementations were
learned and used to drive migration.
Library Description
string.h C standard library string handling
StrSafe.h Safety-focused C string handling
glm Graphics functions
mathfu Mathematical functions
BLAS Linear algebra
Ti DSP DSP Kernels
ARM DSP DSP Kernels
By doing this, we obtain a modified version of the application‚Äôs
code.Regionsthatmatchthegeneratedconstraintsforlibraryfunc-
tions are replaced with calls to those library functions. Migrate
extendsthefunctionalityusedintheoriginalCAnDLpaper[ 20]by
notrequiringthemigrationprocesstobeimplementedmanually
for every relevant library function; having the synthesized code
available to map values allows us to do this.
5.2 Validation
The primaryusage ofautomated IRreplacement is tovalidate mi-
grations(i.e.tocheckwhetherornotperformingthemigrationwill
resultinacorrectprogram).Whileformallyprovingthisisunlikely
to be possible for any API migration tool, Migrate performs two
validationstepsthatprovidesomeassurancethatitssuggestions
arecorrect. First,we ensurethatno dependenciesto intermediate
valuesinthepre-replacementcodeexistlaterinthefunction.Then,
we test the code post-replacement with random IO examples using
the same methodology as Model uses; our results in Section 7.4
show that this validation is effective.
Beyond these checks, the user is likely to still perform their
ownvalidation(e.g.runningunitorintegrationtests).OtherAPI
migration tools share this characteristic; no changes suggested by
refactoring tools to any codebase are likely to go untested.5.3 Source-level Suggestions
Our methodology for this paper operates at the IR level, within
thecompiler;migrationsareappliedmechanicallybyperforming
substitutions of SSA values. Doing so allows us to automaticallytest applied migrations, but changes made at the IR level can be
difficult for a user to understand.
We implemented a prototype tool that used LLVM‚Äôs debugging
libraries to generate source-level suggestions instead. Source-level
suggestions are harder to apply mechanically, but allow for easier
userinsightintowhatchangeshavebeenmadebythemigration.
Evaluatingthistoolisoutsidethescopeofthepaper(asitsusage
was not necessary for any of our research questions), but we hope
toimplementitmorefullyandperformauserstudyasfuturework.
6 EXPERIMENTAL DESIGN
To evaluate the success of M3, we identify four research questions:
(RQ1) Feasibility and effectiveness of the Model phase: Canpro-
gramsynthesisbeusedeffectivelytolearnthebehaviorof
black-box library functions?
(RQ2) Correctness of synthesized programs: Do the synthe-
sized programs behave the same as the target program over
aparticularsetofinputs?Theinputsusedforthiscorrectness
check are randomly generated. To assess the adequacy of
the random inputs in checking behaviors of the synthesized
and target programs, we measure branch coverage achieved
by the random inputs over them.
(RQ3) Accuracy of Match phase: Givensynthesizedimplemen-
tations for library functions, can compatible instances in
application codebe accuratelydiscovered? In thisresearch
question, we focus on ability and accuracy of the Match
phase to discover inlined implementations of the samesyn-
thesized library functions in application code.
(RQ4) Accuracy of Migrate phase: Giveninstancesofusercode
that match the constraints generated from a library func-tion, can API migrations be correctly implemented? Thisresearch question investigates ability and accuracy of the
Migrate phasein matching andmigrating implementations
in application code to differentlibrary functions.
6.1 Evaluation Corpora
6.1.1 Applications. Weselected9widely-usedapplicationstoeval-
uateourapproachagainst;theyarelistedinTable1a.Eachapplica-tioniswritteninCorC++,andtheycoverawiderangeofproblem
domains.
WeselectedtheseapplicationsbymanuallysearchingGitHub
andsimilaronlinerepositories1forcodethatmatchedthefollowing
criteria: most importantly, we required a build system that permit-
ted easy interposition of our compiler toolchain. For our purposes,
this ruled out applications not written in C or C++, although with
some additional engineering work any language with an LLVM
frontend could be integrated.
When selecting applications, large, popular and real-world code
wasprioritized.Weselectedprojectsinactivedevelopment,orthose
forwhichsignificantdistributionandusagecouldbeidentified.We
1Using https://searchcode.com/
96Figure4:Proportionofeachlibrary‚ÄôsAPIthatwewereable
tosuccessfullysynthesize,acrossallfunctionsinthelibraryaswellasthosewithcompatibletypesignatures.Resultsarealso shown for TypeDirect [11].
aimed for a diverse range of application domains with minimal
duplication. No pre-selection of applications based on knowledge
of their source code was performed; the authors were not familiar
with these applications in advance.
6.1.2 Libraries. We selected 7 libraries to target for migration,
from two broad problem domains: string processing and math-ematical operations. Similar domains are commonly targeted by
othermigrationtools(withdifferenttoolingandlanguagecontexts).
We required libraries that could be called easily from C/C++ for
compatibility with the synthesizer.
For string processing, our starting point was the standard C
string.h header along with BSD extensions. We additionally se-
lectedtheMicrosoft StrSafe.h librarythatextendsthestandard
functionswithsaferalternativesthatavoidcommonsecurityissues.
We then selected five mathematical libraries with slightly different
areasofapplicationandplatformsupportinordertoevaluatethe
abilityofM3todiscovercross-vendororcross-platformmigrations.
Other work [ 11] identifies the usefulness of this type of migration.
Full details of the selected libraries are given in Table 1b.
7 RESULTS
7.1 RQ1: Feasibility and Effectiveness of Model
7.1.1 Library Coverage. Figure 4 shows the proportion of each
library‚ÄôsAPIwewereabletosynthesizecorrectlyacrossallfunc-
tionsinthelibrary(shownasbluebars).Asexpected,wecouldnot
synthesizeeveryfunctionfromeachlibrary.Theprimaryreason
for a synthesis failure was a function‚Äôs type signature not being
compatible with Model, for example those using pointers to point-
ersorcomplexstructuretypes.Beyondthesefailures,therewere
anumberofcaseswhereinternaldatastructureusagemeantthat
Model‚Äôscontrolflowfragmentswerenotabletoexpressthenec-
essary structure (e.g. the control flow required to operate on the
packed matrices in strsmfrom BLAS).
Model successfully synthesizes implementations for an average
of 37% ofthe functions in each library evaluated (blue bars in Fig-
ure4).Consideringonlyfunctions withtypesignaturescompatibleFigure 5: Distribution of synthesis times for each library
API.
Figure 6: Corpus branch coverage achieved using randomly
generatedinputs.Coveragevaluesarereportedasthemeanof three separate runs.
with Model (brown bars in Figure 4), we were able to synthesize
implementationsfornearly50%onaverage.Thisrepresentsasig-
nificantproportionofeachlibrary‚Äôsbehavior‚Äîeveninourworst
performingcase(BLAS),weareabletosynthesizenearly20%ofallfunctionsinthelibrary.PerformanceontheBLASlibraryislimited
by the high complexity of many of its constituent functions (e.g.
solving systems of equations on packed matrix structures).
For each synthesis failure in our set of evaluation functions, we
examinedthereferencefunctionbyhandtodeterminewhyitcould
not be synthesized. In some cases (e.g. strtok fromstring.h ),
the function demonstrated stateful behavior. Modeling this type
offunctionisanopenprobleminprogramsynthesis,withrecent
workaddressinglimitedcontextssuchasheapmanipulation[ 39].
Our synthesis methodology presumes that target functions are
idempotent, and so does not support stateful functions. Doing so isinterestingfuturework.Asmallnumberoffunctions(e.g.
ssyr2k
from blas) exhibit unusual control flow idioms not expressible
using our set of fragments. However, the majority of failures are
timeouts resulting from long required sequences of instructions in
target functions.
97Program synthesis over an entire library API is a challenging
problem; the programs that we were able to synthesize are consid-
erably more complex than comparable work in program synthesis
while requiring less information to do so. [41, 47].
7.1.2 Difficulty. Figure 5 shows the distribution of candidate func-
tions evaluated for the synthesis problems in each library. From
thesedistributionsweseethatthemajority(84%)offunctionswere
synthesized in less than 2 minutes. We were able to evaluate ap-
proximately1,000candidatespersecondonan8-coredesktop-class
machine.
The distribution of synthesis times is long-tailed; only two func-
tions from the BLASlibrary took more than 2 hours to synthesize.
These synthesis times are comparable to existing work in program
synthesis, and could be further improved by using techniques such
as hill-climbing to guide the search process.
7.1.3 ComparisontoTypeDirect. Wewereonlyabletoidentifyone
otherprogramsynthesizerwithlibraryfunctionsandmigrationsas
an explicitly stated goal. In that work, partial semantic knowledge
and typeinformation isused toguide asynthesizer (TypeDirect)
towardssynthesizedimplementationsofperformancebottleneck
functions [11]
Evaluation of TypeDirect is limitedto 12 suchfunctions, with
synthesisguidedbyannotationsthatspecifysemanticpropertiesof
thetargetfunctions[ 11].Werestatedoursetofsynthesisproblems
forTypeDirectandrecordedhowmanyitcouldsynthesize.TheseresultsarecomparedtothoseachievedbyModelinFigure4(green
bars); Model performs significantly better across all the libraries
evaluated,withTypeDirectfailingtosynthesizeanyfunctionin
fourofthesevenlibraries.Additionally,TypeDirecttooklongerto
synthesize the functions for which it was successful (up to 4 hours
in some cases).
Insum,comparedtoTypeDirect,wefindModelis(1)automated
and easy to use, not relying on annotations to guide synthesis and
(2) more widely applicable with better synthesis coverage across
different libraries. This is due primarily to TypeDirect‚Äôs focus onsynthesis for specific accelerator libraries rather than general APImigration.
7.2 RQ2: Correctness of Synthesis
Foreverysynthesizedlibraryfunction,weautomaticallygeneratedrandomandboundaryvalueinputsandcheckedifoutputsmatched
those from the target black-box function.
Random Testing. We generated test inputs for every synthesized
candidatebyuniformlysamplingvaluesintherangeoftheinput
datatypes,asdescribedinSection3.1.1.Wefoundallthesynthe-
sized library implementations were behaviorally equivalent to the
targetfunctionswithrespecttotherandominputsgeneratedfor
them.
ManualCheck. AswellastestingusingrandomIOexamples,we
examinedeachsynthesizedsolutionmanuallyusingourknowledge
of their intended behavior. Only one program was judged to beincorrect: the
memmove function from string.h . If the mem-
ory regions passed as arguments aliased (i.e. they overlapped), the
synthesized implementation would exhibit incorrect behavior. OurTable 2: Number of call sites where synthesized functions
were inlined in each application, along with the proportion
of these that were successfully rediscovered using Match.
ApplicationInlined Calls (L‚ÜíL) # User Code
#Instances Matched (%) Matches (C‚ÜíL)
ffmpeg 4,976 100% 24
texinfo 586 100% 1
xrdp 686 100% 0
coreutils 623 100% 16
gems 46 100% 61
darknet 128 100% 13
caffepresso 189 100% 0
nanvix 0 100% 16
etr 4 100% 45
androidfs 0 100% 2
Total 7,238 178
testingmethodologydidnotgeneratealiasedmemory.Wegener-
ated a set of aliased inputs manually and were able to correctly
synthesize memmove.
BoundaryValueTesting. Weadditionallytestedeachsynthesized
candidateusingboundaryandoutsiderangevaluesforinputs.In
everycase,thesynthesizedcandidateconformedtotheexpected
behavior on these inputs.
Adequacy of testing. We assessed the adequacy of the generated
inputs in exercising behaviors of the synthesized implementations
by measuring the branch coverage achieved. Figure 6 shows thebranch coverage achieved across the full set of library functions
evaluated. With as few as 10 distinct inputs, more than 98% of the
branchchoicesinourcorpusofsynthesizedprogramsareevaluated.
Typically, at most around 30 random inputs are needed to provide
100% branch coverage for a synthesized candidate. The numerical
libraries we evaluate most often contain loops as their primary
controlflow;branchcoverageislessdifficulttoachieveoverlooping
code than over conditionals.
Theseresultsprovideconfidencethatthesynthesizedcandidates
behaveequivalentlytothetargetprogramwithrespecttoinputs
that exercise the complete control flow in the candidates.
Inside the Black Box. In many cases, we had the source code for
libraries, making it possible to directly compare our synthesizedprograms to the original code by ‚Äúlooking inside‚Äù the black-box.
These programs were compiled to LLVM IR and used as input to
the Match and Migrate phases as if they had in fact been synthe-sized. We did not identify any meaningful divergence in results;
we achieved similar per-library branch coverage, and the compiled
IRforsynthesizedandhandwrittenimplementationswasalmost
identical in most cases. No behavioral differences were observed.
7.3 RQ3: Accuracy of Match
We assessed if the constraint descriptions of every synthesized
library implementation was able to match the inlined implementa-
tionofthesamelibraryinapplicationcode( L‚ÜíL).Matchisable
98Table 3: Migration opportunities discovered in each appli-
cation, broken down by the category of the source context
(source library calls L or user code C).
Application MigrationsCategory
L‚ÜíL‚Äô C‚ÜíL‚Äô L+C‚ÜíL‚Äô
ffmpeg 655629 24 2
texinfo 431413 1 17
xrdp 274269 0 5
coreutils 649633 16 0
gems 107 46 61 0
darknet 40 71 3 2 0
caffepresso 2424 0 0
nanvix 16 01 6 0
etr 49 44 5 0
androidfs 202 0
Total 2,2472,025 178 44
to successfully identify every instance of inlined code across all
the applications we evaluated; the number of inlined instances for
each application is given in Table 2. This is because the same code
is inlined at each site, and because inlining does not change the
structure of the code from which the constraint description was
generated.
Aswellasbeingabletosuccessfullyidentifyinlinedcalls,Match
isabletoidentifylocationsintheapplicationcodewhereequivalent
functionality to a library function is implemented, C‚ÜíL(number
of instances shown in Table 2). We performed a manual search for
furtherinstancesnotdiscoveredbyMatchbasedontheseresults.
A combination of several techniques was used to perform this
search:we used handwrittenCAnDLconstraintsforsignificantly
abstractedversionsofeachfunctiontoguideaninitialsearch,as
well as textual similarity and heuristic exploration of the code.
Forexample,whereare-implementationofonestring-processing
functionwasdiscovered,wesearchedbyhandforsimilarre-implementations
that were not discovered by Match. For a region to be classified as
are-implementation,werequiredthatonwell-formedinputs(i.e.
not accounting for ‚Äúexceptional‚Äù control flow), the region performs
the same task as the original function.
No further instancesof this kind were identified bythis search,
confirmingwithreasonablecertaintythattherewerenofalsenega-
tives from Match (though no technique can verify this formally).
TheconstraintsgeneratedbyMatchwerespecificenoughthatnone
of the application code matches represented false positives.
RunningtheCAnDLsolvertakesadditionaltimeduringcompila-
tion; approximately the same as compilation itself for each pattern
tobesearched for[ 20].This timeisnota bottleneck whenusing
M3practically.
7.4 RQ4: Accuracy of Migrate
Foreverysynthesizedtargetlibraryfunction,weassessedinhow
many cases the generated constraints for that function matched
applicationcodethatwasnotoriginallyacalltothatfunction.ThisquantifiesthenumberofpossiblemigrationsenabledbyM
3.Table3gives the total number of migrations found in each application, as
well as a breakdown into three categories:
‚Ä¢Replacementofasourcefunctionwithasemanticallyidenti-
cal target function from a different library (L‚ÜíL‚Äô).
‚Ä¢Identificationandreplacementofredundantapplicationcode
that could be better expressed as a target library function
call (C‚ÜíL‚Äô).
‚Ä¢Replacement of code that combines a source library call and
handwritten code with a target function (L+C‚ÜíL‚Äô).
The mostcommon migrationswere L‚ÜíL‚Äô, wheretwo libraries
implementedthesamefunction(forexample,delimitedstringcopy-ingoravectordotproduct).Somefunctionsdidnotproducemigra-tionopportunities,eventhoughtheycouldbeinlinedandmatched.
memcpy isanexampleofthis;applicationslike ffmpeg andxrdp
that frequently perform buffer copies show far fewer migrations
than inlined matches.
Notethatthecategory C‚ÜíL‚Äôcorrespondsexactlytothenumber
ofmatchesinusercode( C‚ÜíL)quotedinTable2.Thisisbecause
anymatchinginstanceofafunctioninapplicationcoderepresentsamigrationopportunity;thereisnooriginalfunctionwhosematches
we are not interested in.
TheseresultsdemonstratethatM3isabletosuccessfullyidentify
distinct classes of migration (other tools are often limited to oneof these classes only, and
L+C‚ÜíL‚Äô migrations generally require
expertknowledgetoexpress).Themigrationsweidentifyareuseful
and would be difficult to identify with existing tools.
7.5 Threats to Validity
WefindM3isabletoidentifyandperformalargenumberofuseful
migrations using real-world applications and libraries, in contexts
notwellservedbyexistingtools.Theprimarythreatsto internal
validityare:(1)ThefragmentvocabularyusedbyModelisalimiting
factor; the variety of programs that can be synthesized depends on
thisvocabulary.However,thisisalimitationsharedbyallsketching
program synthesizers. (2) Our CAnDL constraint generation is not
formallyverified;werelyontestingwithdifferentlibraryfunctions
tocheckconstraintsalwaysmatchtheirsourceprograms.(3)We
checkthecorrectnessofthesynthesizedimplementationsagainst
target functions using test inputs that achieve branch coverage.
Provingtotalcorrectnessisknowntobechallenging[ 15],especially
when the target source code is not visible.
Themainthreatto externalvalidity liesinthesubjectlibraries
chosen and the restriction to two problem domains: string pro-cessing and mathematical operations. These domains have alsobeen targeted by other migration tools and we used these to fa-cilitate comparison. Our synthesis technique is not restricted to
these domains and we will apply our techniques to other domains
in the future; extending the vocabulary of fragments to includemoreexpressivecomputationswillallowustoscalesynthesisto
more complex APIs and functions.
8 RELATED WORK
8.1 Library Migration
(Semi-)automatic rewriting of application code to use new libraries
hasbeenwellstudied,particularlyforJavaandotherobject-oriented
99languages [ 55,59]. Robillard et al . [40]partition migration tech-
niques into 3 sub-areas: library upgrade [ 16,56], API evolution
[13,44] and library migration [ 31,54,61]. Many schemes rely on a
largecorpusofprogramsusingtheoldandnewlibraries,frequently
focusing on change logs [ 51]. This ongoing need is highlighted by
AlrubayeandMkaouer [2],whoseworkaimstoautomaticallyiden-
tify key changes that produce a migration.
8.1.1 Automatic. Different levels of abstraction delineate auto-
maticapproaches.Similarityoftextdescriptionhasbeenusedto
map old to new APIs [ 36], while others [ 30,32,38] use a syn-
tacticviewofprogramstobuildalearnedvector-spaceencoding
[28] for migration given an initial parallel mapping. Although the
embedding-basedapproachtakenbyAPI2Vec[ 32]isflexible,the
resulting ambiguity is in fact a hindrance when performing migra-
tions.Morerecentworkattemptstogeneratemappingsbetween
APIs based on their usage [7].
Otherwork[ 57,58]goesbeyondsimple replacementoflibrary
API calls. Xu et al .[57]use syntactic program differencing and pro-
gram dependency analysis to target actual edits and replacements.
Although itis a syntacticrather thansemantic approach, theyare
able to add new code to help migration of libraries. EdSynth [58]
synthesizescandidateAPIcallstofillpartialprogramusinginfor-
mation from test executions and method constraints. Unlike our
synthesis approach, their work requires white-box informationon candidate methods, exact locations to insert API calls, and a
user-provided test suite to serve as a correctness specification.
Closer to our aimof not relying on prior APImapping examples
istheapproachtakenbyBui [6].ItusesGANstogenerateinitialmi-
grations(seeds)ratherthanusinghumanknowledgetodoso[ 5].To
achievethis,itmakestheassumptionthatuseofAPIswhenmigrat-
ingremainsroughlythesame.Ithassignificantlylowerprecision
than our approach, relies on lexical similarity and cannot perform
C‚ÜíL‚Äômigrations.Otherworkusesspecificsemanticknowledge
of functions to perform refactoring with semantic guarantees [ 45].
8.1.2 Expert-Driven. AdifferentapproachtoAPImigrationisto
use expert knowledge to encode migration patterns by hand, then
compilethemtoasearchablerepresentationtoperformmigrations.
This approach is taken by tools like ReFaster (Java) [ 53] and No-
Brainer(C/C++)[ 43];theypermitcomplexmigrationsbutrequire
experts to create the migration patterns initially. Similarly, IDL[
21] implements migrations of computational ‚Äúidioms‚Äù to target
heterogeneouscomputingplatforms.Theunderlyingcodesearch
mechanism for M3(CAnDL [ 20]) can be used to implement this
styleofmigrationtoolinaportableway.M3extendspriorworkby
addingalearningphasethatcreatesmigrationpatternsautomati-
cally.
8.2 Program Synthesis
M3usesprogramsynthesisasatechniqueformodelingthebehavior
of library functions. We give a brief overview of related work in
synthesis.
Priorworkinimperativesynthesisfrequentlyfocusesonstraight-
line code [ 23,42] or has to make special provision for control-flow
[22]. Simpl overcomes this problem by assuming a partial program
is already provided (such as a loop structure) [ 47]. Other workaimstocompletesuggestedsketches[ 49]ofprogramstoprovide
programmer abstraction and auto-parallelization [18]
Type signatures and information are often used to direct pro-
gramsynthesis,mostcommonlyforfunctionalprograms[ 34,35].
Otherworkusesextendedtypeinformationasameansofaccessingheterogeneousaccelerators[
11].Ourworkconsidersamuchwider,
more diverse class of libraries and applications without additional
annotation.
Others have used neural components to improve the perfor-
mance of an existing synthesizer. For example, both DeepCoder[
3] and PCCoder [ 62] aim to learn from input-output examples;
bothrequirefixed-sizeinputsandoutputsanduseasmallDSLto
generate training examples. Learned programs are limited to list
processingtasks;theDSLstargetedbythese(andsimilarimplemen-tationssuchasSketchAdapt[
33])alsorelyonhighlevelprimitive
including(forexample)primitivestotokenizestringsorperform
list manipulations.
Operating under the assumption of a black-box API means that
manyexistingapproachesinprogramsynthesisdonotapplyorfail
to generalize to ourcontext [ 8,9]. By using ablack-box oracle we
are able to avoid issues of generalization across datasets [25, 37].
9 CONCLUSION
InthispaperwehaveproposedanovelAPImigrationproblemthat
matches real-world problem contexts. Our approach, M3, uses the
behavioroflibraryfunctionstodiscovermigrationswithoutexpert
knowledge, changelogs, or access to the library‚Äôs source code.
We successfully applied this approach to 7 large, widely-used
librariesandwereabletosuccessfullysynthesizenearly40%oftheir
functions. We discovered over 7,000 instances of these functions
in 10 well-known C/C++ applications, and were able to discover a
number of missed optimizations and bugs.
Usingconstraint-basedsearch forAPImigration allowsforthe
semantics ofthecodeinquestiontobeaccountedfor,ratherthan
just the contexts in which they appear; this results in more precise
migrations. Future work applying these methods to more domains
is likely to be interesting.
ACKNOWLEDGMENTS
ThisworkwassupportedbytheEngineeringandPhysicalSciences
ResearchCouncil(grantEP/L01503X/1),EPSRCCentreforDoctoral
TraininginPervasiveParallelismattheUniversityofEdinburgh,
School of Informatics.
100REFERENCES
[1]2020. CWE-126:BufferOver-read. https://cwe.mitre.org/data/definitions/126.
html
[2]HusseinAlrubayeandMohamedWiemMkaouer.2018.AutomatingtheDetection
of Third-Party Java Library Migration at the Function Level. In Proceedings
of the 28th Annual International Conference on Computer Science and Software
Engineering (CASCON ‚Äô18). IBM Corp., Riverton, NJ, USA, 60‚Äì71.
[3]MatejBalog,AlexanderL.Gaunt,MarcBrockschmidt,SebastianNowozin,and
Daniel Tarlow. 2016. DeepCoder: Learning to Write Programs. (Nov. 2016).
https://arxiv.org/abs/1611.01989v2
[4]Clark Barrett and Cesare Tinelli. 2018. Satisfiability Modulo Theories. In Hand-
bookofModelChecking,EdmundM.Clarke,ThomasA.Henzinger,HelmutVeith,
andRoderickBloem(Eds.).SpringerInternationalPublishing,Cham,305‚Äì343.
https://doi.org/10.1007/978-3-319-10575-8_11
[5]Nghi DQBui, YijunYu, andLingxiao Jiang.2019. SAR: learningcross-language
APImappingswithlittleknowledge.In Proceedingsofthe201927thACMJoint
Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering. 796‚Äì806.
[6]Nghi D. Q. Bui. 2019. Towards Zero Knowledge Learning for Cross Language
API Mappings. In Proceedings of the 41st International Conference on Software
Engineering: Companion Proceedings. IEEE Press, 123‚Äì125. https://doi.org/10.
1109/ICSE-Companion.2019.00054
[7]ChunyangChen,ZhenchangXing,YangLiu,andKentLongXiongOng.2019.
Mining likely analogical apis across third-party libraries via large-scale unsu-pervisedapisemanticsembedding. IEEETransactionsonSoftwareEngineering
(2019).
[8]Qiaochu Chen, Xinyu Wang, Xi Ye, Greg Durrett, and Isil Dillig. 2019. Multi-
Modal Synthesis of Regular Expressions. (Aug. 2019).
[9]Yanju Chen, Ruben Martins, and Yu Feng. 2019. Maximal Multi-Layer Speci-fication Synthesis. In Proceedings of the 2019 27th ACM Joint Meeting on Euro-
pean Software Engineering Conference and Symposium on the Foundations ofSoftware Engineering (ESEC/FSE 2019). ACM, New York, NY, USA, 602‚Äì612.
https://doi.org/10.1145/3338906.3338951
[10]FabienCoelhoandFran√ßoisIrigoin.2013. APIcompilationforimagehardware
accelerators. ACM Transactions on Architecture and Code Optimization (TACO) 9,
4 (2013), 1‚Äì25.
[11]B.Collie,P.Ginsbach,andM.F.P.O‚ÄôBoyle.2019. Type-DirectedProgramSynthe-
sisandConstraintGenerationfor LibraryPortability.In 201928thInternational
ConferenceonParallelArchitecturesandCompilationTechniques(PACT).55‚Äì67.
https://doi.org/10.1109/PACT.2019.00013
[12]BruceCollieandMichaelO‚ÄôBoyle.[n.d.]. RetrofittingSymbolicHolestoLLVM
IR. ([n.d.]). arXiv:2006.05875 [cs] http://arxiv.org/abs/2006.05875
[13]Barth√©l√©myDagenaisandMartinP.Robillard.2008. RecommendingAdaptive
ChangesforFrameworkEvolution.In Proceedingsofthe30thInternationalCon-
ferenceonSoftwareEngineering (ICSE‚Äô08).ACM,NewYork,NY,USA,481‚Äì490.
https://doi.org/10.1145/1368088.1368154
[14]CristinaDavid andDanielKroening. 2017. Program Synthesis:Challengesand
Opportunities. PhilosophicalTransactionsoftheRoyalSocietyA:Mathematical,
Physical and Engineering Sciences 375, 2104 (Oct. 2017), 20150403. https://doi.
org/10.1098/rsta.2015.0403
[15]YvesDevilleandKung-KiuLau.1994. Logicprogramsynthesis. TheJournalof
Logic Programming 19 (1994), 321‚Äì350.
[16]DannyDig,CanComertoglu,DarkoMarinov,andRalphJohnson.2006. Auto-
mated Detection of Refactorings in Evolving Components. In Proceedings of the
20thEuropeanConferenceonObject-OrientedProgramming (ECOOP‚Äô06).Springer-
Verlag, Berlin, Heidelberg, 404‚Äì428. https://doi.org/10.1007/11785477_24
[17]KevinEllis,DanielRitchie,ArmandoSolar-Lezama,andJoshTenenbaum.2018.
Learning to Infer Graphics Programs from Hand-Drawn Images. In Advances in
NeuralInformationProcessingSystems31,S.Bengio,H.Wallach,H.Larochelle,
K. Grauman, N. Cesa-Bianchi, and R. Garnett (Eds.). Curran Associates, Inc.,
6059‚Äì6068.
[18]GrigoryFedyukovich,MaazBinSafeerAhmad,andRastislavBodik.2017.Gradual
Synthesis for Static Parallelization of Single-pass Array-processing Programs.
InProceedingsofthe38thACMSIGPLANConferenceonProgrammingLanguage
Design and Implementation (Barcelona, Spain) (PLDI 2017). ACM, New York, NY,
USA, 572‚Äì585. https://doi.org/10.1145/3062341.3062382
[19]JohnK.Feser,SwaratChaudhuri,andIsilDillig.2015.SynthesizingDataStructure
TransformationsfromInput-OutputExamples.In Proceedingsofthe36thACM
SIGPLANConferenceonProgrammingLanguageDesignandImplementation(PLDI
‚Äô15).ACM,NewYork,NY,USA,229‚Äì239. https://doi.org/10.1145/2737924.2737977
[20]Philip Ginsbach, Lewis Crawford, and Michael F. P. O‚ÄôBoyle. 2018. CAnDL: ADomain Specific Language for Compiler Analysis. In Proceedings of the 27th
International Conference on Compiler Construction (CC 2018). ACM, New York,
NY, USA, 151‚Äì162. https://doi.org/10.1145/3178372.3179515
[21]PhilipGinsbach,ToomasRemmelg,MichelSteuwer,BrunoBodin,Christophe
Dubach,andMichaelF.P.O‚ÄôBoyle.2018. AutomaticMatchingofLegacyCodeto
Heterogeneous APIs: An Idiomatic Approach. In Proceedings of the Twenty-ThirdInternational Conference on Architectural Support for Programming Languages
and Operating Systems (ASPLOS ‚Äô18). ACM, New York, NY, USA, 139‚Äì153. https:
//doi.org/10.1145/3173162.3173182
[22]SumitGulwani.2011. AutomatingStringProcessinginSpreadsheetsUsingInput-
Output Examples. In Proceedings of the 38th Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages (POPL ‚Äô11). ACM, New York,
NY, USA, 317‚Äì330. https://doi.org/10.1145/1926385.1926423
[23]Sumit Gulwani, Susmit Jha, Ashish Tiwari, and Ramarathnam Venkatesan. 2011.
Synthesis of Loop-Free Programs. In Proceedings of the 32Nd ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI ‚Äô11).
ACM, New York, NY, USA, 62‚Äì73. https://doi.org/10.1145/1993498.1993506
[24]Susmit Jha, Sumit Gulwani, Sanjit A. Seshia, and Ashish Tiwari. 2010. Oracle-Guided Component-Based Program Synthesis. In Proceedings of the 32Nd
ACM/IEEE International Conference on Software Engineering - Volume 1 (ICSE ‚Äô10).
ACM, New York, NY, USA, 215‚Äì224. https://doi.org/10.1145/1806799.1806833
[25]Ashwin Kalyan, Abhishek Mohta, Oleksandr Polozov, Dhruv Batra, Prateek
Jain, and Sumit Gulwani. 2018. Neural-Guided Deductive Search for Real-
Time Program Synthesis from Examples. arXiv:1804.01186 [cs] (Sept. 2018).
arXiv:1804.01186 [cs]
[26]Volodymyr Kuznetsov, Vitaly Chipounov, and George Candea. 2010. Testingclosed-source binary device drivers with DDT. In USENIX Annual Technical
Conference.
[27]Chris Lattner. 2002. LLVM: An Infrastructure for Multi-Stage Optimization.
Ph.D. Dissertation. Computer Science Dept., University of Illinois at Urbana-
Champaign.
[28]Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, and Jeffrey Dean. 2013.
DistributedRepresentationsofWordsandPhrasesandTheirCompositionality.In
Proceedings of the 26th International Conference on Neural Information Processing
Systems - Volume 2 (NIPS‚Äô13). Curran Associates Inc., USA, 3111‚Äì3119. http:
//dl.acm.org/citation.cfm?id=2999792.2999959
[29]Andr√©MirandaandJo√£oPimentel.2018. OntheUseofPackageManagersbytheC++Open-SourceCommunity.In Proceedingsofthe33rdAnnualACMSymposium
on Applied Computing (SAC ‚Äô18). Association for Computing Machinery, Pau,
France, 1483‚Äì1491. https://doi.org/10.1145/3167132.3167290
[30]AnhTuanNguyen,MichaelHilton,MihaiCodoban,HoanAnhNguyen,LilyMast,EliRademacher,TienNNguyen,andDannyDig.2016. APIcoderecommendationusingstatisticallearningfromfine-grainedchanges.In Proceedingsofthe201624th
ACM SIGSOFT International Symposium on Foundations of Software Engineering.
511‚Äì522.
[31]HoanAnhNguyen,TungThanhNguyen,GaryWilson,Jr.,AnhTuanNguyen,
MiryungKim,andTienN.Nguyen.2010. AGraph-BasedApproachtoAPIUsage
Adaptation.In ProceedingsoftheACMInternationalConferenceonObjectOriented
ProgrammingSystemsLanguagesandApplications(OOPSLA‚Äô10).ACM,NewYork,
NY, USA, 302‚Äì321. https://doi.org/10.1145/1869459.1869486
[32]TrongDucNguyen,AnhTuanNguyen,HungDangPhan,andTienNNguyen.
2017. Exploring API embedding for API usages and applications. In 2017
IEEE/ACM 39th International Conference on Software Engineering (ICSE). IEEE,
438‚Äì449.
[33]Maxwell Nye, Luke Hewitt, Joshua Tenenbaum, and Armando Solar-Lezama.
2019. LearningtoInferProgramSketches.In InternationalConferenceonMachine
Learning. Long Beach, CA, USA, 4861‚Äì4870.
[34]Peter-Michael Osera. 2019. Constraint-Based Type-Directed Program Synthesis.
InProceedingsofthe4thACMSIGPLANInternationalWorkshoponType-Driven
Development (TyDe2019).ACM, NewYork,NY, USA,64‚Äì76. https://doi.org/10.
1145/3331554.3342608
[35]Peter-MichaelOseraandSteveZdancewic.2015. Type-and-Example-Directed
Program Synthesis. In Proceedings of the 36th ACM SIGPLAN Conference on
ProgrammingLanguageDesignandImplementation (PLDI‚Äô15).ACM,NewYork,NY, USA, 619‚Äì630. https://doi.org/10.1145/2737924.2738007
[36]
Rahul Pandita, Raoul Praful Jetley, Sithu D Sudarsan, and Laurie Williams. 2015.
Discoveringlikelymappingsbetweenapisusingtextmining.In 2015IEEE15th
International Working Conference on Source Code Analysis and Manipulation
(SCAM). IEEE, 231‚Äì240.
[37]Emilio Parisotto, Abdel-rahman Mohamed, Rishabh Singh, Lihong Li, Dengy-ong Zhou, and Pushmeet Kohli. 2016. Neuro-Symbolic Program Synthesis.
arXiv:1611.01855 [cs] (Nov. 2016). arXiv:1611.01855 [cs]
[38]H. D. Phan, A. T. Nguyen, T. D. Nguyen, and T. N. Nguyen. 2017. StatisticalMigration of API Usages. In 2017 IEEE/ACM 39th International Conference on
Software Engineering Companion (ICSE-C). 47‚Äì50. https://doi.org/10.1109/ICSE-
C.2017.17
[39]Nadia Polikarpova and Ilya Sergey. 2019. Structuring the Synthesis of Heap-
ManipulatingPrograms. ProceedingsoftheACMonProgrammingLanguages 3,
POPL (Jan. 2019), 72:1‚Äì72:30. https://doi.org/10.1145/3290385
[40]M. P. Robillard, E. Bodden, D. Kawrykow, M. Mezini, and T. Ratchford. 2013.
AutomatedAPIPropertyInferenceTechniques. IEEETransactionsonSoftware
Engineering 39, 5 (May 2013), 613‚Äì637. https://doi.org/10.1109/TSE.2012.63
[41]ChristopherD.Rosin.2018. SteppingStonestoInductiveSynthesisofLow-Level
Looping Programs. arXiv:1811.10665 [cs] (Nov. 2018). arXiv:1811.10665 [cs]
101[42]RaimondasSasnauskas,YangChen,PeterCollingbourne,JeroenKetema,Gratian
Lup, Jubi Taneja, and John Regehr. 2017. Souper: A Synthesizing Superoptimizer.arXiv:1711.04422[cs] (Nov.2017). arXiv:1711.04422[cs] http://arxiv.org/abs/1711.
04422
[43]ValeriySavchenko,KonstantinSorokin,GeorgiyPankratenko,SergeyMarkov,
AlexanderSpiridonov,IliaAlexandrov,AlexanderVolkov,andKwangwonSun.
2019. Nobrainer:AnExample-DrivenFrameworkforC/C++CodeTransforma-
tions.InPerspectivesofSystemInformatics (LectureNotesinComputerScience).
Springer International Publishing, Cham, 140‚Äì155. https://doi.org/10.1007/978-
3-030-37487-7_12
[44]T.Sch√§fer,J.Jonas,andM.Mezini.2008. MiningFrameworkUsageChangesfrom
Instantiation Code. In 2008 ACM/IEEE 30th International Conference on Software
Engineering. 471‚Äì480. https://doi.org/10.1145/1368088.1368153
[45]A.Shaw,D.Doggett,andM.Hafiz.2014. AutomaticallyFixingCBufferOverflows
Using Program Transformations. In 2014 44th Annual IEEE/IFIP International
Conference on Dependable Systems and Networks . 124‚Äì135. https://doi.org/10.
1109/DSN.2014.25
[46]Richard Shin, Neel Kant, Kavi Gupta, Christopher Bender, Brandon Trabucco,Rishabh Singh, and Dawn Song. 2019. Synthetic Datasets for Neural Program
Synthesis. arXiv:1912.12345 [cs, stat] (Dec. 2019). arXiv:1912.12345 [cs, stat]
[47]Sunbeom So and Hakjoo Oh. 2017. Synthesizing Imperative Programs from
ExamplesGuidedbyStaticAnalysis.In StaticAnalysis(LectureNotesinComputer
Science), Francesco Ranzato (Ed.). Springer International Publishing, Freiburg,
Germany, 364‚Äì381.
[48]ArmandoSolar-Lezama.2009. TheSketchingApproachtoProgramSynthesis.
InProgramming Languages and Systems (Lecture Notes in Computer Science).
Springer, Berlin, Heidelberg, 4‚Äì13. https://doi.org/10.1007/978-3-642-10672-9_3
[49]Armando Solar-Lezama. 2013. Program sketching. International Journal on
Software Tools for Technology Transfer 15, 5-6 (2013), 475‚Äì495.
[50]Wei Tang, Ping Luo, Jialiang Fu, and Dan Zhang. 2020. LibDX: A Cross-PlatformandAccurateSystemtoDetectThird-PartyLibrariesinBinaryCode.In 2020IEEE
27thInternationalConferenceonSoftwareAnalysis,EvolutionandReengineering
(SANER). IEEE, 104‚Äì115.
[51]C.Teyton, J.Falleri,andX. Blanc.2013. AutomaticDiscoveryofFunction Map-
pings between Similar Libraries. In 2013 20th Working Conference on Reverse
Engineering (WCRE). 192‚Äì201. https://doi.org/10.1109/WCRE.2013.6671294
[52]ChenglongWang,AlvinCheung,andRastislavBodik.2017. SynthesizingHighly
Expressive SQL Queries from Input-Output Examples. In Proceedings of the 38th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(PLDI2017).ACM,NewYork,NY,USA,452‚Äì466. https://doi.org/10.1145/3062341.
3062365
[53]Louis Wasserman. 2013. Scalable, Example-Based Refactorings with Refaster. In
Workshop on Refactoring Tools.
[54]W.Wu,Y.Gu√©h√©neuc,G.Antoniol,andM.Kim.2010. AURA:AHybridApproachtoIdentifyFrameworkEvolution.In 2010ACM/IEEE32ndInternationalConference
onSoftwareEngineering,Vol.1.325‚Äì334. https://doi.org/10.1145/1806799.1806848
[55]LaerteXavier,AlineBrito,AndreHora,andMarcoTulioValente.2017. Historical
andimpactanalysisofAPIbreakingchanges:Alarge-scalestudy.In 2017IEEE
24thInternationalConferenceonSoftwareAnalysis,EvolutionandReengineering
(SANER). IEEE, 138‚Äì147.
[56]Z.XingandE.Stroulia.2007. API-EvolutionSupportwithDiff-CatchUp. IEEE
Transactions on Software Engineering 33, 12 (Dec. 2007), 818‚Äì836. https://doi.
org/10.1109/TSE.2007.70747
[57]ShengzheXu,ZiqiDong,andNaMeng.2019. Meditor:inferenceandapplication
of API migration edits. In Proceedings of the 27th International Conference on
Program Comprehension. IEEE Press, 335‚Äì346.
[58]ZijiangYang,JinruHua,KaiyuanWang,andSarfrazKhurshid.2018. EdSynth:
Synthesizing API sequences with conditionals and loops. In 2018 IEEE 11th Inter-
national Conference on Software Testing, Verification and Validation (ICST). IEEE,
161‚Äì171.
[59]Syed Sajjad Hussain Zaidi. 2019. Library Migration: A Retrospective Analysis and
Tool. Master‚Äôs thesis. Science.
[60]Micha≈Ç Zalewski. 2020. American Fuzzy Lop. https://lcamtuf.coredump.cx/afl/.
[61]Hao Zhong, Suresh Thummalapenta, Tao Xie, Lu Zhang, and Qing Wang.
2010. MiningAPIMappingforLanguageMigration.In Proceedingsofthe32Nd
ACM/IEEE International Conference on Software Engineering - Volume 1 (ICSE ‚Äô10) .
ACM, New York, NY, USA, 195‚Äì204. https://doi.org/10.1145/1806799.1806831
[62]Amit Zohar and Lior Wolf. 2018. Automatic Program Synthesis of Long Pro-
grams with a Learned Garbage Collector. In Proceedings of the 32Nd International
ConferenceonNeuralInformationProcessingSystems(NIPS‚Äô18).CurranAssociates
Inc., USA, 2098‚Äì2107.
102