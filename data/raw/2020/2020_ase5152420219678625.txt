Automated Repair of Size-Based Inaccessibility
Issues in Mobile Applications
Ali S. Alotaibi
University of Southern California
USA
aalotaib@usc.eduPaul T. Chiou
University of Southern California
USA
paulchio@usc.eduWilliam G.J. Halfond
University of Southern California
USA
halfond@usc.edu
Abstract —An increasing number of people are dependent on
mobile devices to access data and complete essential tasks. For
people with disabilities, mobile apps that violate accessibilityguidelines can prevent them from carrying out these activities.Size-Based Inaccessibility is one of the top accessibility issuesin mobile applications. These issues make apps difﬁcult to use,especially for older people and people with motor disabilities.Existing accessibility related techniques are limited in termsof helping developers to resolve these issues. In this paper,we present our novel automated approach for repairing Size-Based Inaccessibility issues in mobile applications. Our empiricalevaluation showed that our approach was able to successfullyresolve 99% of the reported Size-Based Inaccessibility issues andreceived a high approval rating in a user study of the appearanceof the repaired user interfaces.
I. I NTRODUCTION
Mobile devices have become one of the most essen-
tial means for accessing information and services. From e-
commerce to COVID vaccine passports, the ability to accessmobile applications (apps) is important for everyone. This isparticularly true for the 15% of the global population withdisabilities that depends on mobile devices to complete dailytasks [1], [2]. Despite the various legislation and efforts [3],[4] to ensure mobile technologies are accessible to all, mobileapps today still suffer from a wide range of accessibility issues[5], [6], [7], [8] that prevent users from interacting with theapp’s intended functionalities.
Touchscreen technology has been the most prominent input
method for users to interact with mobile devices [9]. Yet,interacting with mobile devices by touch can be difﬁcultfor many people, such as older adults and those with motorimpairments (e.g. paralysis, tremors, or neurological diseases).These difﬁculties can translate into imprecise touches, in-creased touch mistakes, or even the inability to access im-portant functionalities in mobile apps. Studies have shownthat inadequate size of touch targets is the root cause thatmanifests these difﬁculties [10], [11], [12], [13]. This typeof issue, known as Size-Based Inaccessibility Issue (SBII) [8],
occurs when the size of a touch target is less than the minimumsize speciﬁed by the accessibility guidelines [14], [15], [16].Recent studies have shown that SBIIs are among the mostprevalent accessibility issues that affect mobile apps [7], [8].In fact, a study on real-world apps from 33 app categories ofthe Google Play store showed that small touch target size wasranked as the second top accessibility issue [7]. Another recentlarge-scale empirical study on accessibility issues found that78% of apps had more than 10% of their elements too smallto pass the accessibility tests [8].
Automatically repairing SBIIs is a challenging task for
several reasons. First, a repair must account for multiple SBIIsholistically in order to preserve the relative consistency of theoriginal User Interface (UI) design. Second, due the complexrelationship between Android UI components, there is no clearway of identifying the set of views and properties that needsto be modiﬁed for a given SBII. Finally, assuming that therelevant views and properties can be identiﬁed, a change in sizeof one touch target element can introduce further alignmentor spacing issues to other areas of the UI. Together, thesechallenges make a seemingly simple repair difﬁcult to achieve.
Existing approaches cannot help developers repair SBIIs.
Research by Zhang et al. developed prototypes to addressAndroid accessibility by enhancing user interactions. Theirwork Interactiles [17] focuses on making touchscreens acces-
sible by attaching a hardware interface to the Android phone’sscreen to enhance tactile interaction for the visually impaired.Similar hardware overlay techniques [18], [19], [20] have beenproposed in HCI research but they do not ﬁx the underlyingissues and require the hardware cutouts to be tailored to ﬁt thedevices. Software-based approaches to improve touchscreenaccessibility [21], [22], [23] are more robust, but they mostlyfocus on using audio-based interaction techniques to allowthe visually impaired to access touchscreens. Zhang alsointroduced “interaction proxies” to be inserted on top of anapp’s original UI for disabled users to more easily manipulatethe app [24]. While this approach can potentially address size-based inaccessibility, it relies heavily on manually remappinginteraction into new interactions. Touch Guard [25] helpsusers to access inaccessible small touch targets by enhancingtheir touched areas with screen magniﬁcation to enlarge andto disambiguate the bounds between multiple targets. Theseexisting tools merely operate as “assistive technologies” toprovide increased usability. However, they do not provide away to help app developers repair the root causes of theproblem.
In this paper, we introduce a novel approach for automati-
cally repairing SBIIs in Android apps. Our approach deﬁnesa novel graph-based model called the Size Relation Graph(SRG) that models the visual and rendering relationshipsamong elements in an Android UI. The SRG allows our
7302021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000702021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678625
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
approach to effectively identify the set of problematic touch
targets that need to be modiﬁed to repair the UI. To computethe best repair, our approach employs a multi-objective geneticalgorithm to search for a solution that minimizes layoutdistortion. Our approach generates a repair patch and uses itto automatically generate a new APK of the repaired Androidapp.
The results show that our repairs can effectively ﬁx SBIIs.
In a user study that evaluated the repaired UIs, 90% of theparticipants rated the repaired UI as equal to or more preferredthan the original. Overall, these results are very positive andindicate that our approach can help developers improve theaccessibility of their mobile apps. The contributions of ourpaper are as follows:
1) The ﬁrst-ever technique for automatically generating re-
pairs to improve size-based accessibility in Android apps.
2) A novel graph-based model of the visual and rendering
relationships among the elements in an Android UI.
3) An empirical study on real-world apps that shows our
approach is effective in improving Android accessibility.
4) A user study that shows our repairs do not compromise
the UI’s attractiveness and are preferred for mobile usage.
Our paper is organized as follows: In Section II, we providebackground information on mobile accessibility. Then in Sec-tion III we present our approach in detail, and its evaluationin Section IV. We discuss related work in Section V, andconclude in Section VI.
II. B
ACKGROUND
An Android app consists of a set of activities.A n activity
is the class that creates the user interface (UI) window, and isitself comprised of a group of elements that are either Views or
ViewGroups.A View occupies a rectangular area on the screen
and is visible by default (e.g., Buttons). A ViewGroup is a
View that can contain other Views as children. A touch target
refers to any element on the UI that a user can touch, click, orinteract with to perform some action. These include interactiveelements (e.g., Buttons) and non-interactive elements attachedto event handler that allow them to respond to user actions(e.g., implementing an onClick method for an ImageView or
aLinearLayout ).
The visual properties of an element can be conﬁgured using
a set of attributes. Android uses these attributes to determinethe size and placement of elements when rendering the UI.The size of an element is expressed as a width and a heightthat can be conﬁgured using the attributes layoutwidth and
layoutheight , respectively. Each attribute can be speciﬁed
by using a speciﬁc number (e.g., 30dp) or using a certain
size constant (i.e., ‘match
parent’o r‘ wrapcontent’). If
an attribute is speciﬁed using a speciﬁc number, then it canhave a size that is equal to, at most, that number (although itmay not be able to achieve that size due to constraints of theUI). An element with an attribute speciﬁed as ‘match
parent’
means that the element wants to match the size of its im-mediate parent. An element with an attribute speciﬁed as‘wrap
content’ means that the element wants to expand to ﬁtits content (or children). Other attributes may also affect thesize of an element. These include attributes such as padding ,
which deﬁnes the spacing between an element’s borders andits encompassed content; minWidth andminHeight, which
specify a minimum bound constraint on the height and width;andmargin , which deﬁnes the spacing between an element
and its neighboring elements. Changing the value of oneattribute may impact the value of the other. For example,increasing the size of an element may reduce the spacing ithas with another element.
All of the elements in an activity can be represented in a
tree-based model of the layout, called a View Hierarchy (VH).The VH contains information about the logical relationshipsamong views (e.g., parent-child), and information about thevisual aspects of each view, such as color, size, and location.Numerous tools, such as UI Automator [26], can be used toto extract an XML ﬁle representing the VH. Other tools, likeLayout Inspector [27], can also parse the app’s layout ﬁlesto extract these attributes and then augment this informationwith the information obtained from dumping the state of therunning UI.
Web and mobile accessibility guidelines require apps to
have touch targets that are sufﬁcient in size. The requirementis outlined in Google’s Material Design principles for Androidaccessibility [14] and Guideline 2.5.5 of the international ac-cessibility standard WCAG 2.1 [15]. The guidelines formallyspecify that mobile apps’ touch targets should be at least48dp×48dp with respect to the screen [28], [14], [16]. Testing
tools such as Google Accessibility Scanner [29], AccessibilityTesting Framework [30], and IBM’s Mobile AccessibilityChecker [31] can detect touch targets issues in mobile appsbased on these guidelines. In this paper, we use the term Size-Based Inaccessibility Issue (SBII) to refer to any violations ofthis guideline, where a touch target falls below the requiredsize threshold.
III. A
PPROACH
The goal of our approach is to automatically repair the SBIIs
in a mobile app’s UI while maintaining, as much as possible,the aesthetics and design of the original UI. Fixing SBIIs, asdescribed in Section II, requires changes to the properties thatcontrol the size and placement of elements in the UI to allowthe UI to meet the accessibility requirements. Finding the newvalues that ﬁx the SBIIs while maintaining the UI’s aestheticis complicated by several challenges.
The ﬁrst challenge is to maintain the visual consistency of
the UI design. For example, for a navigation bar with a set ofmenu items, changing the size of one item without updatingthe other menu items will distort the navigation bar’s visualconsistency. The second challenge is knowing what needs to
be changed in order to ﬁx the SBIIs. Directly changing the
elements with accessibility problems does not always ﬁx theproblem due to the fact that the ﬁnal rendered appearance of anelement depends not only on its properties, but its containingelements and nearby elements. Therefore, the set of elementsand properties that need to be adjusted to ﬁx the SBIIs often
731Localization  Compute & 
Generate a RepairApply Repair to UI Generate Repaired 
APK
Repaired APK
App’s VH
A11y
Report
Identifying 
Visual Groups Repair  Clustering Visually 
Related Groups
 eaea e p
Fitness 
Score
Terminate?
Construct SRG
YesNo
Fig. 1: An overview of our approach
include other elements in addition to the one with an SBII. The
third challenge is that a repair can have a cascading effect .A
change to one part of a UI can trigger a chain of changesin other parts of the UI as elements change and move toaccommodate the change. This challenge is compounded withthe existence of multiple SBIIs in a UI or when many elementsmust be adjusted together to maintain the visual consistency,which increases the likelihood that the ﬁnal layout will bedistorted.
Figure 1 shows an overview of our approach, which can be
broken into three phases, identifying visually related elements,localization, and repair. The input for our approach is an APKof an app along with a detection report that lists each ofthe app’s Inaccessible Activities (IAs) (activities that exhibit
SBIIs) along with details about the SBIIs of each of theseactivities. The detection report can be provided by automateddetection techniques, such as Google Accessibility Scanner[29] or Accessibility Test Framework for Android (GATF) [30]
For each IA in an app, this step analyzes its layout to
identify and group visually related elements that need to beadjusted together to maintain the visual consistency of the UI.The localization step then identiﬁes and relates SBIIs to a setof elements and properties that need to be adjusted to repair theSBIIs. Finally, the repair step performs a guided search to ﬁndthe best values for the identiﬁed set of elements and propertiesthat repair the SBIIs in the IA while maintaining, as much aspossible, the aesthetics of the UI. When the search terminates,the best values obtained for all selected elements are used toupdate the IA’s corresponding static layouts. Once all of theIAs in the app are repaired, the app is compiled and providedas the output of the approach. We now explain the parts of theapproach in more detail in the following subsections.
A. Phase 1: Identifying Visually Related Elements
The goal of this phase is to identify the sets of elements that
should be adjusted together to maintain the visual consistency
of the repaired layout. Maintaining the consistency amongvisually related elements (e.g., items in a menu list) is essentialto maintaining the aesthetics and design of the original UI.However, identifying these sets is challenging since apps’ UIsvary signiﬁcantly from each other. This variation can evenexist within the same app as different UIs may have their ownlayouts with a varying number of elements and a differentset of visual relationships. This means relying on a predeﬁnednumber of groups with ﬁxed rules on how to map the elementsin any UI to those groups is not practical. Instead, these groupsneed to be identiﬁed on a per-UI basis. A simplistic approachto identifying these groups might put elements that have thesame class type (e.g., all Buttons) or style into the same group.However, in our experience this was generally inaccurate sinceelements with the same class type can vary widely in theirappearance, and styles are not used in a disciplined way bymost developers. Techniques with similar goals, but targetedto web applications (e.g., [32], [33], [34]), rely on variousmetrics, such as DOM structure, to group elements, and inour experience this also resulted in inaccurate groupings whenapplied to mobile app UIs.
To identify visually related elements, we characterized the
problem as a clustering problem, where elements representthe data points that need to be made into clusters, and thecluster membership is determined by the similarity of the ele-ments’ rendering attributes. To cluster elements, our approachuses the well-known density-based clustering technique, DB-SCAN [35]. This particular techniques is well suited for ourproblem since the algorithm (1) does not require predeﬁningthe number of clusters, and (2) produces mutually exclusiveclusters (i.e., hard clustering). Both of these attributes areimportant for our problem domain since the variance of appUI layouts means they can have varying numbers of groupingsand having non mutually exclusive clusters could preventour search technique (Section III-C) from converging. Todeﬁne the distance function, we found that (1) logical location(represented by the XPath), (2) element size, and (3) elementclass type consistently resulted in the most useful groupings.In our experience, elements with a similar XPaths had ahigher chance of being related in terms of sharing a similarvisual appearance and/or inheriting the same properties froma mutual parent (for example, icons in the navigation bar). Wealso found that elements with a similar size were often visuallyrelated (e.g., lists of buttons or items). Finally, we found thatwhile element class type was, by itself, insufﬁcient to indicateelement grouping, when combined with the other dimensions,it helped to improve the grouping’s accuracy.
We deﬁne our element clustering techniques as follows.
First, our approach analyzes the VH of the IA and extractseach unique element and its properties. The elements becomethe data points that will be clustered. Next, to determinethe distance between those data points, our approach deﬁnes
7321
2
3
4
1
2
3
4
1
2
3
4
Fig. 2: Example that shows two apps’ UIs annotated with
a simpliﬁed version of the visually related groups that wereidentiﬁed by our clustering algorithm.
a function based on the three above-mentioned metrics. To
calculate the location distance, our approach computes theLevenshtein distance between elements’ XPath. The Leven-shtein distance between two XPaths is the minimum numberof XPath tags that need to be modiﬁed to change one XPathinto the other. Our approach then normalizes the value of thelocation distance metric to a range of [0,1]. A metric valueof zero indicates a complete match between the two elements,while one indicates a maximum difference. To calculate thesize distance, our approach computes a metric for each of thesize properties (height, width, and margins). If elements v
1
andv2have the same size propriety (e.g., height), then the
metric value for that property is set to 0; otherwise, it is setto 1. Similarly, our approach computes a metric to calculatethe element class type distance. If two elements have thesame element class type, then the metric value is set to 0.Otherwise, it is set to 1. Our approach then calculates theoverall distance as a weighted sum of the normalized value ofeach of the above three metrics. The weights of the metricswere determined empirically based on our experiments. TheDBSCAN algorithm then uses this information to group theelements into different clusters. Each cluster then representsa set of visually related elements and the set of all clustersis the output of this phase. Fig. 2 shows a simpliﬁed versionof the visually related groups identiﬁed for two mobile apps’UIs. Each number on the graph represents an identiﬁed group.
B. Phase 2: Localization of Elements and Properties
The goal of this phase is to identify, for each of the
SBIIs, the set of elements and properties that need to be
changed in order to repair the SBII. Although the reports fromaccessibility detection tools can be used to identify elementsthat exhibit SBIIs, they do not necessarily indicate whichelements need to be adjusted to repair the SBIIs nor whichproperties should be adjusted.
There are several reasons for this limitation. First, the size of
the element may be set based on an interaction of its propertieswith the properties of other elements that are located close byor of elements from which it inherits display constraints. Forexample, the size of an element that is set to ﬁll the availablespace depends on its neighbors’ size or an element’s size maybe bounded by the ﬁxed size of another element in whichit is visually contained. Second, maintaining the consistencyof the repaired UI requires modiﬁcations to other elements,which may themselves have relationships with other elementsthat need to be modiﬁed to maintain consistency. One couldaddress both of these challenges by making the repair phase ofour approach consider modifying all elements and propertiespresent in the IA. However, such a solution would dramaticallyincrease the search space for a possible repair and meansthat the search process could take a long time to complete.Therefore, in this phase, our approach tries to identify a subsetof all elements and properties in the IA that is (1) safe, in thatit contains the elements and properties that when modiﬁed canrepair the observed SBII and keep the UI consistent; and (2)minimal, to reduce the runtime needed to identify a successfulrepair.
To accomplish this goal, we deﬁne an approach based on
building and analyzing a model of the visual and renderingrelationships among the elements in an activity. Given a set
of SBIIs, our approach can use this model to identify aminimal set of other elements and their properties that shouldbe considered as candidates for the repair. To serve as thismodel, we introduce a new graph that we call the Size RelationGraph (SRG), which is deﬁned by a tuple /angbracketleftV,E,M/angbracketright. A node
v∈Vcorresponds to an element in the IA. Eis a set of
directed edges that represent one of two relationships betweenelements in the IA: consistency relationships, which exist
between elements that need to be changed together to maintainthe visual consistency of the UI (i.e., elements that belong tothe same visually related group, identiﬁed in Section III-A);and size dependency relationships, which exist between two
elements if the size of one constrains, in some way, the sizeof the other. Mis a function that maps each edge to a set of
tuples of the form /angbracketleftp,ϕ/angbracketright .p∈P, whereP={height,width},
andϕis a ratio of the drawing values of pfor the edge’s nodes.
After building the SRG, our approach computes a subgraph
for each visually related group that contains an SBII. Thesubgraph identiﬁes the elements that will be targeted by therepair methodology in Section III-C. The edges of the sub-graph and their corresponding annotations identify propertiesto be considered for the repair and provide information onhow to propagate that repair to the other elements in thesubgraph. To compute the subgraphs, our approach iteratesover each visually related group that contains an SBII. Foreach such group g, our approach identiﬁes the set of elements
and properties that may need to be changed to resolve theSBII ing. To do this, our approach computes a subgraph of
733the SRG that corresponds to the transitive closure of the graph
originating from the element vaing, wherevarepresents the
view that has the SBII. If gcontains more than one element
with an SBII, our approach chooses, as va, the element that
requires the largest size increase to ﬁx its SBII. The intuition ofselecting vin this way is that the largest size increase applied
to this element will also likely repair the other elements thatrequire a smaller size increase. The computed subgraphs arerepresented as a set of tuples, A, with each tuple of the form
of/angbracketlefti,sb/angbracketrightwhereirepresents the ID of the element v
a∈V
that contains an SBII, and sbrepresents the subgraph of the
SRG computed for that node. We now describe each of thetwo edge types in more detail.
Aconsistency edge is created to represent the size relation-
ships between elements within a visually related group g. The
goal of this type of relationship is to ensure size changes arepropagated among elements within gto maintain their visual
consistency. For example, for the UI shown on the left-handside of Fig. 2, our approach creates consistency edges betweenthe nodes in the SRG that represent the three buttons in groupto ensure that a change applied to one can be propagated to
the others. To create the consistency edges for g, our approach
iterates over its elements and for each pair of elements v
1
andv2, our approach creates a consistency edge between their
correspondent nodes in the SRG. The approach then createsan edge tuple to capture the relationship between each of thepair’s dimensions (i.e., height and width) and calculate theratioϕfor that tuple by dividing the drawing value of the
dimension for v
1over the drawing value of the dimension for
v2. Returning to the example in Fig. 2, for the edge created
between the nodes in the SRG representing the ‘Sign up’ and‘Privacy Policy’ buttons, our approach creates a tuple thatmodels the height relationship between them. Since the heightof both buttons are 30dp, the tuple will be initialized with the
value/angbracketleftheight, 1.0/angbracketright.
Adependency edge is created to represent the size relation-
ship that can exist between an element and one of its ancestors.The goal of modeling this type of relationship is to identify theset of nodes and properties that, given a change to a propertypfor an element v, may need to be changed to accommodate
the change in v. To create the dependency edges, our approach
iterates over the nodes in the VH of the IA. For each nodev, our approach iterates through the set of its ancestors (i.e.,
containing layouts), starting from its parent. Then based onthe size attributes deﬁned for that ancestor, our approach willeither create a dependency edge with that ancestor or skip itand move on to the analysis of the next ancestor. Our approachdetermines that based on the following three cases. First, ifthe size attribute is set as an exact number, then our approachmarks that ancestor as the target node for the dependency edge.The reason for that is that an ancestor with a size attribute setas a ﬁxed number does not change in response to the changein the size of v. Therefore, the size of vis dependent on
this ancestor. Second, if the size attribute for the ancestor isset aswrap
content, then our approach, will only mark that
ancestor as the target node for the dependency edge if the sizeattribute for vwas set as matchparent. That is because this
is the only case where that ancestor may need to be changeddirectly as v’s size can not be directly increased. Third, if the
ancestor size is set as match
parent, then our approach skips
that ancestor and moves to the next one. The reason is that anancestorv
pwith size set as matchparent follows the size of
its own parent. Therefore, if vp’s parent increased, then vp’s
size will increase, allowing vto change. The dependency edge
is created between vand the identiﬁed ancestor in the SRG as
determined by these three cases. The approach then creates anedge tuple to capture the relationship between the two nodesand calculates the ratio ϕfor that tuple by dividing the value
ofvover the value of the identiﬁed ancestor.
C. Phase 3: Repairing the Activity
The goal of this phase is to generate a repair that resolves
the detected SBIIs in the IA without distorting the UI’s ap-pearance. Identifying such a repair is complicated for multiplereasons. First, a perfect repair may not exist due to UI layoutconstraints. Therefore, the repair may need to represent atradeoff between resolving SBIIs and minimizing distortion.Second, the space of possible solutions that can be consideredgrows exponentially as more elements and properties needto be considered. Third, assessing the quality of a repair isdifﬁcult to do, since it requires knowing exactly how a set ofproposed repairs would affect not only the changed elementsbut if they cause any cascading changes to other parts of theUI. Together, these challenges motivate the use of a search-based approach for ﬁnding a repair since these techniques canefﬁciently explore large solution spaces, consider tradeoffs inidentifying a best solution, and use approximation functionsto avoid expensive modeling operations (i.e., UI renderingimpact).
The search-based technique we deﬁne follows the general
approach of a genetic search algorithm. Therefore, we onlygive a brief overview below of the overall ﬂow of the searchand then describe the unique parts, the ﬁtness function, prob-lem representation, initial population, and repair generation,in more detail. In each iteration of the search, our approachevaluates the candidate repairs in the current population, usingthe metrics deﬁned in Section III-C1, then performs selec-tion, uniform crossover, and uniform random mutation. Ourapproach terminates the search once the maximum numberof predeﬁned generations has been reached or the approachreaches a ﬁxed point where no improvement in the populationhas been observed for multiple generations.
1) Fitness Function: The goal of our ﬁtness function is
to guide our search to a solution that resolves as many SBIIas possible. However, solutions that resolve SBIIs, may doso by increasing the size of touch targets dramatically andin a way that distorts the UI of an IA. Therefore, we designour ﬁtness function to include not only metrics that guide thesearch to a UI with improved accessibility, but also metrics thatpenalize solutions that cause the resulting UI to signiﬁcantlydiffer from the original or introduce new design problems.Based on our experiments with the automatically generated
734touch target size adjustments, we identiﬁed several aspects of
repairs that, when penalized, helped our approach to generateUIs that minimally altered the UI while generating repairs.These were: changes to view alignments, the relative positionof views, spacing between views, and the amount of view sizechange. The ﬁtness function for a candidate repair is calculatedas the weighted sum of these four objectives.
Accessibility Heuristic : This metric represents the primary
representation of how good a solution is with respect toimproving the identiﬁed SBIIs. Ideally, this could be measuredby inserting a solution into the app, and then running Google’sAccessibility Scanner [29] on the modiﬁed app and calculatinga new accessibility score based on its report. However, theprocess of running the scanner can take a signiﬁcant amountof time. Therefore we utilized an approximation of the acces-sibility score. Our approach inserts a candidate solution intothe app, then scans the rendered UI to identify the actual sizeof each touch target that had been reported as having an SBIIand is still below the minimum threshold for accessible size.Simply using this number as the metric is insufﬁcient, sinceit deﬁnes a step function that does not provide meaningfuldiscernment powers among solutions where both results in thesame number of SBII violations, but one may be closer. Toconvert this information into a gradient function with moreuseful notions of correctness, we calculate the amount of sizethat the touch targets would need to increase to satisfy thetouch target minimum. This enables the approach to valuesolutions that are getting closer to a satisfying solution even ifthe resulting UI has not yet completely resolved the detectedSBIIs.
Relative Positioning and Alignment of Views : Changes to
the size of touch targets can cause changes to the relativeposition and alignment of elements in the UI as they moveto accommodate the repaired elements’ changed size. In somecases this can signiﬁcantly distort the original layout of the UI.Therefore we introduce two metrics that favor solutions thatresult in lower amounts of change in the relative positioningand alignments of its elements with respect to the original UI.Our approach realizes these metrics using the following steps:First, our approach extracts the position of each element inthe VH of the original UI and identiﬁes the type of alignmentand relative position it has with the other elements. Forrelative position, any two elements may have the followingrelationships: (1) intersection, (2) containment, (3) above, (4)below, (5) to the left of, or (6) to the right of. For alignment,any two elements may be (1) top aligned, (2) bottom aligned,(3) left aligned, or (4) right aligned. These relationships canbe determined by comparing the xandycoordinates of
each element’s Minimum Bounding Rectangle (MBR). Forexample, two elements are bottom aligned if the yvalues
of their bottom-right and bottom-left coordinates are equal.The same process is repeated for an IA after a candidatesolution has been applied to it. Then the two sets of alignmentsand relative positions are compared. If a difference exists,then our approach computes the magnitude of the changeby computing the minimum Euclidean distance between thecurrent position of the changed element and where it wouldneed to be located in order to restore the violated relationship.For the bottom aligned example, this would be the absolutedifference between the ycoordinates. Our approach sums the
differences for all elements that have violated a prior alignmentor relative position relationship and reports this as the metricfor the candidate solution.
Minimum Spacing Between Views: Touch targets that
expand in size can do so by expanding into the space betweeneach pair of touch targets. However, doing so can have animpact on the layout of a UI and cause it to look verydifferent from its original design. Therefore, we introducea metric to favor solutions that do not cause the spacingbetween any pair of elements to become too small. To realizethis metric our approach computes the distance between theMBRs of each pair of touch targets, and if the resulting spaceis below the minimum value required by Google’s MaterialDesign guidelines, then the solution is penalized. This allowssolutions to utilize some of the space between touch targetsbut only penalizes them if it falls below this minimum value.This realization of the metric reﬂects our observations thatmany SBIIs could not be repaired without signiﬁcant distortionwithout utilizing at least some of the space between touchtargets.
Amount of View Size Change: A drawback of our accessi-
bility heuristic is that it favors solutions that always increasethe size of the touch targets. This can favor solutions thatunnecessarily increase the size of the touch targets, which inturn increases the amount of distortion relative to the originalUI. To penalize these changes, our approach deﬁnes a metricthat favors solutions that minimize the amount of change in thesize of the touch targets. To realize this metric, our approachcompares the size of a touch target in the original UI (using theelement’s MBRs) and compares this to the size of the touchtarget in the UI produced by a candidate repair. The sum ofall such changes in the element is used as the metric.
2) Solution Representation and Initial Population: Each
candidate repair (chromosome) is comprised of a set Sof
tuples (each tuple corresponds to a gene), where each tupleis of the form /angbracketlefti,p,v/angbracketright. In this tuple ican refer to either a
group (as deﬁned in Section III-A) or an individual element; v
denotes the amount of change or adjustment that the repair willmake toi; andpindicates the property of ito which vwill be
applied and can be the height, spacing, or width. Our candidaterepairs allow our approach to change an entire group (if irefers
to a group) with one adjustment or an individual element. Thegroup identiﬁed genes allow our approach to explore solutionsthat maintain consistency while the individual identiﬁed genesrepresent elements that have a size dependency relationshipwith the element containing the SBII.
For a given IA that contains SBIIs, our approach deﬁnes
the genes that will be included in the chromosome in thefollowing way. For each visually related group gand the
subgraph identiﬁed for gin Section III-B, the approach ﬁrst
identiﬁes the subset of properties (e.g., height or width) thatmight need to change to repair the SBIIs. These properties
735can be identiﬁed based on the violation reported in the SBII
detection report. For each such property p, the property deﬁnes
a gene for gand a gene for each element that is connected
tovain the subgraph via a dependency edge. For example,
if height is the property that needs to be changed for g, and
vbis the node connected to vavia a dependency edge, then
our approach will create two tuples in S. The ﬁrst tuple is
created with ireferring to the group gto which vabelongs
andp=height . The second tuple is created with ireferring
tovbandp=height . Note that the value ﬁeld vof each
tuple is undeﬁned at this point since this step only deﬁnes thechromosome structure.
Based on this chromosome structure, our approach then cre-
ates an initial population of size nof candidate solutions. For
each of the nsolutions the approaches creates a chromosome
with the gene structure deﬁned using the above process. Thenthe approach iterates over each gene and initializes its valueﬁeldvby sampling a random value in a Gaussian distribution
based on the element’s value.
3) Generating a Repair: When a candidate solution is
ready to be evaluated by the ﬁtness function, our approachconverts the solution to a repair that can be inserted intothe IA. Given a candidate solution c, our approach performs
the following steps: (1) For each gene in c, our approach
propagates the change represented by the gene to all ofthe elements in the subgraph. (2) Then our approach againtraverses the subgraphs capturing the changes in a set R
of concrete repairs, each of which is represented as a tuple/angbracketleftx
r,pr,ar,vr/angbracketright, wherexris the XPath of the node in the VH
that need to be changed, pris the property to be changed, ar
is the attribute that needs to be modiﬁed when applying thechange to the layout ﬁles, and v
ris the new value for pofxr.
After generating R, our approach (3) rewrites the app’s layout
ﬁles and generates a new APK that can be run. These foursteps are also used for generating the ﬁnal and best solutionidentiﬁed by our approach.
In the ﬁrst step, each gene in the candidate solution (c)i s
applied to each of the subgraphs. To do this our approach tran-sitively traverses each outgoing dependency and consistencyedge in each subgraph and for each edge, v
r→vt, traversed,
our approach computes vt’s new value of pby multiplying the
value assigned to pofvrby the ratio, ϕ, deﬁned by the edge
tuple between vrandvt. Our approach then uses this new
value of pto computes new values for the other size-related
properties deﬁned for vt, such as padding and minimum size.
This ensures that the ratio between these properties and pis
maintained after the size change. For each property changedforv
t, our approach creates a corresponding node in R.
In the second step, our approach once again traverses the set
of identiﬁed subgraphs. For each subgraph, our approach setsthe values of the corresponding tuples in Rwith the value
set for the node in the subgraph. For each node changedin the subgraph, our approach determines the value of a
r
based on a predeﬁned mapping between each property andthe corresponding attribute used in Android for that property.This is a direct mapping except in two cases. First, whenthe value of the attribute that pis mapped to is deﬁned as
awrap
content, then instead of mapping pto that attribute,
our approach maps pto its corresponding min attribute (e.g.,
android :minHeight). Second, If the value of the attribute is
set asmatchparent, then the change of pcannot be directly
applied to the attribute in vt. Instead, this change is indirectly
achieved by propagating the change, using the dependencyedges, to a containing node.
In the third and ﬁnal step, our approach iterates over the
set of changes in R, and for each, our approach modiﬁes the
corresponding attributes in the app’s layout ﬁles. The nodesin the subgraphs, VH, and the app’ layout ﬁles all use thesame identiﬁer, which simpliﬁes the mapping and matchingbetween the representations. Note that we omit the details ofthis step, since this is mainly an engineering challenge anddid not require the development of any new techniques oralgorithms.
IV . E
V ALUATION
To evaluate our approach, we designed experiments to
answer the following research questions:
RQ1: How effective is our approach in repairing SBIIs in
Android applications?RQ2: How long does it take for our approach to generate
repairs for SBIIs in Android applications?RQ3: How does our approach impact the visual appeal of
Android applications after applying the selected repair?
A. Implementation
We implemented our approach in Java as a prototype
tool, Size-based inAnaccessibiLity rEpair in Mobile apps
(SALEM). Our implementation uses Apktool [36] to disassem-
ble APK resource ﬁles and repack the modiﬁed ﬁles into a newAPK ﬁle. To collect UI information, we used UI Automator[26] and ADB [37] to dump the layout hierarchy ﬁles andcapture the screenshots when running an app on an AndroidEmulator based on Android 8.0. For detecting the SBIIs inan app, we used Google Accessibility Scanner [29] and thenﬁltered its output to capture SBIIs. To get the style informationand build the VH for activities, we used a tool based on
Layout Inspector [27] in addition to UI Automator. We ranour experiments with the following conﬁgurations: populationsize = 9, generation size = 8. We ran our approach on an AMDRyzen 7 2700X 64-bit machine with 64GB memory, runningUbuntu Linux 18.04.4 LTS. The implementation of SALEMand subjects will be made available to the community via ourproject website [38].
B. Subjects
We conducted our experiments on a set of 58 activities
from 48 real-world mobile apps gathered from a dataset of
apps used in a recent large scale study on accessibility issuesin mobile applications [7]. This dataset consists of 1,000apps collected from across 33 categories in the Google Playstore [39]. To select our subjects, we ran an accessibilityevaluation tool on the dataset [7] and randomly selected 48
736TABLE I. Results for SALEM’s effectiveness in repairing SBIIs (RQ1) and its run time (RQ2).
Original Repaired
# of Touch Targets # of SBIIs Accessibility Rate # of SBIIs Accessibility Rate Running Time (mins)
All 305 220 28 2 99 579
Average 5 4 26 0 99 9
Median 5 4 17 0 100 8
Max 20 17 93 1 100 19
Min 1 1 0 0 80 6
apps that contained SBIIs. We conﬁrmed these reported SBIIs
by manually verifying the size of each element reported. Foreach of these 48 apps, we selected the activities that the
detection tool reported to have at least one SBII. From thelist of SBIIs in each activity, we ﬁltered out the ones that
were part of WebViews orAdViews, which our approach does
not handle, as they require modifying web content which ourapproach does not handle. In total, we have 220 SBIIs in 58unique activities across the 48 subjects.
C. Experiment One
1) Protocol: To address RQ1 and RQ2, we ran SALEM
on each of the subject’s faulty activities. To account for
the non-determinism of our approach’s search technique, werepeated the experiment 10 times for each activity and reported
the results based on the average numbers. To evaluate theeffectiveness of our approach, for each activity we calculated
its number of SBIIs and its accessibility rate before and
after the repair. The number of SBIIs was determined basedon the reports from Google Accessibility Scanner [29]. Theaccessibility rate was calculated as the ratio of the number
of touch targets that are free of SBIIs over the total numberof touch targets in the activity. This is a widely-used metric
to measure and rank the accessibility of UIs in a mobile app[7], [8]. To address RQ2, we measured the time it took to runSALEM during the experiment.
2) Presentation of Results: The results for effectiveness
(RQ1) and time (RQ2) are shown in Table I. The “Original”and “Repaired” columns correspond to the results before andafter applying SALEM’s repairs. We list the number of SBIIsand the resulting accessibility rate under “# of SBIIs” and“Accessibility Rate” for the original and repaired versions.We also calculated the total, average, median, maximum, andminimum (rounded to whole numbers) across all 58 activities
for each of the metrics. Due to space constraints, we do notlist the details of the subjects in the paper, but include themas supplementary material on our project website.
3) Discussion of Results: Overall, the results of our ex-
periment show that SALEM was able to signiﬁcantly reducethe number of SBIIs in the subject apps. Out of the totalnumber of 220 reported SBIIs, our approach was able tocompletely ﬁx 218 (99%) of them. The total accessibility rate
across all 58 activities after the repair was 99%, compared
to only 28% before the repair. These results indicate that ourapproach was effective in repairing the SBIIs and improvingthe accessibility of apps. We investigated the two SBIIs intwo different activities that our approach could not repair and
found they were UI elements whose size properties are deﬁnedin code. These SBIIs can only be repaired by analyses thatwould require analyzing and rewriting the source code, whichis not handled by our approach.
The results for RQ2 shows that SALEM was able to
generate repairs within a reasonable time. We analyzed theruntime breakdown of each individual step in our approachand found that our approach spent a signiﬁcant ∼98% amount
of time evaluating the candidate repairs by compiling a newAPK for each repair and then running them on the emulator.This part can be further optimized by running the approach inparallel (e.g., using Amazon AWS).
D. Experiment Two
1) Protocol: To answer RQ3, we conducted a user-based
study where we asked users to compare the original and
repaired UIs. The goal of this evaluation was to understand,how our repairs affect the UI’s visual layout from a user’sperspective. The surveys presented side-by-side screenshots ofthe original and the repaired UIs, each calibrated to be shownin the resolution of the Nexus 6P mobile device that was usedto run the experiment. This device has a display and resolutionthat is within the range of the most popular Android mobilescreen sizes [40]. The order of the screenshots’ placement wasrandomized and only labeled V ersion 1 and V ersion 2.
Each survey was divided into two parts. For the ﬁrst part,
we wanted to measure the participants’ general opinion ofthe original and repaired versions of the UIs. We presentedthe two versions and asked each participant to (1) rate theirpreference on a 5-point Likert scale; and (2) rate each UI’sattractiveness on a numeric scale from 1 to 10. We also askedparticipants to provide a written explanation of their answers tounderstand the reason for their preference. For the second partof the survey, we wanted to measure the participants’ opinionof the two versions after knowing about the accessibilityimprovements. We presented the same set of UI screenshotsas the ﬁrst part, but this time we highlighted the SBIIs oneach screenshot in the same way as they would be shownin Google’s Accessibility Scanner [29]. We also presented ashort description explaining the issues and the functionalitiesthat are activated by each touch target affected by the SBIIs.We then asked the participants to again, rate their preferencebetween the original and the repaired on a 5-point Likert scale.
73781257
17
7
3850
23
15
1456
34
5
1241
36
20
1548
31
15
0051
30
19Before (55-)
After (55-)
Before (55+)
After (55+)
Before (SCI)
After (SCI)
81257
17
7
3850
23
15
1456
34
5
1241
36
20
1548
31
15
0051
30
19
0102030405060
I strongly prefer the
original UI.I prefer the original UI. No prefe rence. I prefer the repaired UI . I strongly prefer the
repaired UI.%
%
%
%
%
%
%
Fig. 3: Participants’ preference between the original and repaired UI versions
We conducted the survey on participants from two sources:
(1) Amazon Mechanical Turk (AMT), a crowd-sourcing plat-
form that has been widely used to conduct user studies [41];and (2) a group of disabled users that suffer paralysis withlimited hand mobility. For the AMT participants, we separatelycollected responses from those that are under 55 years-oldand those 55 years-old or older. To ensure the participantsunderstood our instructions, we limited the locality to U.S. andCanada. We chose only those workers that had been rated ashighly reliable (with an approval rating of over 98%) and whohad completed over 5000 approved tasks. We also followedAMT best practices by employing a captcha and a check-
question. In total, we had 122 responses from the 55- group,24 responses from the 55+ group, and 20 responses from thegroup with motor impairment.
2) Presentation of Results: The results from the user-study
are shown in Figure 3. The bar chart shows the distributionof the 5-point Likert scale preference ratings where the lighterbars are the preference ratings before accessibility awarenessand the darker bars are those after accessibility awareness. Weused solid bars to represent the group that is under 55 years-
old (55- group), striped bars to represent the group that is 55
years-old or older (55+ group), and dotted bars to represent
the group of users with motor impairment (SCI group).
In terms of average attractiveness, the participants rated
the original (O) slightly higher than the repaired (R) withan average of (O: 6.43 R: 6.40) among the 55- group. Forthe 55+ and the SCI groups, the repaired version had aslightly higher rating of (O: 6.11 R: 6.25) and (O: 6.46 R:6.94) respectively. The rating difference for the 55- groupwas not statistically signiﬁcant (p-value = 0.57563>0.05)
and the rating differences for the 55+ and the SCI groupswere statistically signiﬁcant (p-values = 0.03327<0.05, and
0.00891<0.05, respectively). We used the Wilcoxon Signed-Rank test for the analysis because we were comparing pairedratings from two dependent samples and these ratings werenot normally distributed.
3) Discussion of Results: The result from the user-study
showed that our approach was very successful in maintainingthe visual appeal of its repaired UIs. For preference, a majorityof participants rated “No preference” when deciding betweenthe original and repaired versions. This is a very good indica-tion that our repair did not negatively affect user preferencewhile it was able to ﬁx almost all of the SBIIs. In fact, acrossall three groups, when combining “No preference” with thosethat prefer the repaired UI, our repair was in favor among90% of the ratings. We investigated the comments providedby the 10% who did not prefer our repaired UI and found thatthe reason participants preferred the original was because theyperceived smaller UI components to be more attractive. Sincethis is a personal preference, we do not think it underminesthe quality of our repairs.
Participants preferred our repairs even more once they were
aware of the implications of the SBIIs. Across the threegroups, we see an average of 11% increase in favor of therepaired UI. Particularly, the number of ratings that “stronglyprefer” the repaired UI doubled for the general 55- group andquadrupled for the 55+ group. This is a very strong indicationthat participants value accessibility and are willing to changetheir initial preference for the trade off. We revisited those10% that did not favor the repair and preferred smaller layoutto see whether their preference changed. Interestingly, overhalf of them switched to either “No preference.” or preferredthe repaired version, leaving only under 5% still preferring theoriginal after awareness. The comments from the participantsthat switched were overwhelmingly positive, expressing thatthey were unaware of accessibility at ﬁrst, but had no problemadapting to the repaired UI for a greater gain. One commented
738Fig. 4: Example that demonstrates SALEM. The left screenshot shows the original UI, the middle screenshot highlights the
SBIIs detected by Google Accessibility Scanner, and the right screenshot shows the UI after applying SALEM’s repair.
“... and it still looks good, and now it is workable.”
In addition to a positive impact on visual appeal, the user-
study also showed that our repair was considered to be moreaccessible. We investigated the comments provided by theparticipants to understand the reason of the repaired UI beingboth more attractive and preferable among the 55+ and SCIgroups. We found in general, these groups perceived biggerUI components to be better and more usable even beforeaccessibility awareness. Many participants explained that thebigger touch targets from the repaired UI could help them bemore efﬁcient and avoid mistakes during interaction. Amongthe 19% of the SCI group that “strongly prefer” the repairedUI is a quadriplegic participant that uses his knuckles insteadof ﬁngertips to active touch screens. He explained “The largerspacing between lines would make it considerably easier forme to access each input box with my knuckles. ” These types
of insights from actual mobile users show that our approachcan be impactful in addressing accessibility.
E. Threats to V alidity
External Validity: The ﬁrst potential threat is that the selec-
tion of participants for the user-based study in our experiment
may not be representative of individuals impacted by SBIIs.To address this threat, we implemented an age question in ourAMT surveys and sought motor impaired paralysis patients toensure our participants are diverse in age and abilities.A second threat is that the repaired UIs may not rate as
well when displayed on screen dimensions different from theone we used in our evaluation. This aspect of generalizabilitywas not tested in our evaluation. However, we believe thatsince our approach’s focus was on maintaining relative visual
relationships and Android uses a dynamic layout renderingapproach, that repairs on screens with other dimensions wouldlikely look similar from an aesthetics point of view.
Internal Validity: One potential threat is that screenshots
used the user-based study may appear differently in sizedepending on the participants’ displays. To mitigate this threat,we asked the participants to enter the display device they usedfor answering the survey and included only those results witha screen PPI that would render the screenshots to near theactual size of the Nexus 6P device’s UI that was used in theemulator to generate the screenshots.
Another potential threat is that users rated the UIs based
on the screenshots without directly interacting with the UIson a mobile device. Our decision to use screenshots wasfor the following reasons. First, our user study does not askusers to evaluate apps’ usability, which would require directinteraction with the apps. Instead, users are only asked torate the attractiveness of the rendered UIs. Second, the use ofscreenshots allows us to avoid any variations in the results thatmay happen due to the differences in the participants’ mobiledevices or their selected settings. Third, the use of screenshots
739allows for easy comparison as users can view the two versions
of the UIs next to each other instead of having to install, run,and then uninstall different versions of our subjects. Finally,screenshots are frequently used in user-study that attempt toevaluate the attractiveness of UIs (e.g., [34], [42], [43], [44]).
Construct Validity: A potential threat is that our deﬁnition
of SBIIs is dependent on the reports of GATF and the GoogleAccessibility Scanner [29]. The use of this deﬁnition is rea-sonable because it is based on Google’s own Material Designresearch [14]. The guidelines’ metric is what is considered asthe accessibility threshold by experts. As further validation, weanalyzed the severity of the repaired SBIIs to see how muchlarger they had to be in order to be considered accessible.We found that the SBIIs needed an average 56% increasein their area. Of special note, 18% of the SBIIs requireddoubling their touch areas and 5% of the SBIIs required anarea increase of over three times to become accessible. Thisindicates that many of the repaired SBIIs were undersized andrequired signiﬁcant size increases to become accessible.
Another potential threat is that the attractiveness and pref-
erence ratings by participants are subjective. To mitigate thisthreat, our survey is designed to measure relative values with
either side-by-side comparison or before-and-after repair ver-sions for the activities. This ensures the same pair of activity
receives consistent ratings even though different participantsmay rate according to different standards.
V. R
ELATED WORK
Many empirical studies in the literature have studied the
prevalence of accessibility issues in mobile applications andhow they impact end-users [5], [6], [7], [8]. Although theyprovide useful insights that drive accessibility research incen-tive (such as our work), they do not offer solutions to solvethese underlying issues. Many Android accessibility toolstoday contribute to solving accessibility issues by detectingand identifying known issues based on violations of guidelines[31], [30], [7], [45], [46]. However they are only able to locate,not repair, these types of issues. Similarly, recent techniqueshave been developed to address various types of accessibilityissues in the web domain. KAFE [47] focuses on detectingaccessibility issues related to the keyboard interface. A
XERAY
[48] focuses on detecting semantic inconsistencies related toWAI-ARIA speciﬁcations. VizAssert [49], [50] uses formalveriﬁcation techniques to detect layout-based accessibilityissues in web applications.
Improving accessibility in the mobile domain has become
an active area of research. Work by Wu et al. aims topromote users awareness of the built-in assistive servicesby automatically recommending services to users based ontheir needs [51]. Recent mobile accessibility research [52],[53] focuses on making mobile UI components accessibleto assistive services, such as TalkBack [54], by annotatingthe app’s interface elements with semantics and accessibilitymetadata. Similar work has motivated repair tools to makeimage-based buttons with missing content labels accessible[55]. LabelDroid [56] and COALA [57] are repair techniquesbased on using deep learning to automatically predict thelabels of UI icons, while Brady et al. proposed a techniqueto suggest content labels using crowd-sourcing [58]. Theseapproaches can repair known issues that affect disabled usersfrom interacting with the apps via assistive technologies, butthey do not address SBIIs.
Research in HCI has helped to address difﬁculties in
touchscreen usage via both hardware and software. Hardwaretechniques [18], [19], [20] use physical attachments to thephone to improve tactical interactions. Software techniquesprovide “aids” to circumvent small touch targets by zoomingor increasing size [25], [59]. While these techniques may assistdisabled users on a case-by-base basis, they do not resolve theunderlying root causes of SBIIs.
There has been approaches that attempt to repair general UI
layout issues. OwlEye [60] focuses on repairing Android GUIlayout issues, such as text overlap, blurred screen, and missingimages. Other techniques, such as IF
IX[42] and CBRepair
[61], repair internationalization presentation issues in webapplications, and MF
IX[34] repairs presentation issues in the
mobile web environment. Although these tools target repairsof UI bugs, they do not ﬁx SBIIs in mobile applications.
Program repair have also been the focus of many techniques
from the research community [62], [63], [64], [65]. Droix [63]uses a search-based technique to automatically repair crashesin Android applications. Elixir [62] is a technique that canautomatically generate patches for Java applications. The focusof this line of research is to facilitate the generation of patchesto repair application crashes and defects but they do not repairaccessibility issues.
VI. C
ONCLUSION
In this paper, we introduced an approach for automatically
repairing SBIIs in mobile apps. Our approach builds a graph-based model of the mobile UI to identify the set of elementsand properties that need to be modiﬁed to repair the UI. Toidentify the best repair, our approach uses a genetic algorithmguided by a ﬁtness function that accounts for accessibility andUI distortion introduced by the repairs. Once the best repairhas been found, our approach automatically generates a newAPK of the repaired Android app. Our empirical evaluationshowed that our approach was able to successfully resolve99% of the SBIIs in a set of subject apps. In a user study thatevaluated the repaired UIs, 90% of the participants rated therepaired UI as equal to or more preferred than the original,and valued the increased accessibility offered by the repairs.Overall, these results are very positive and indicate that ourapproach can help developers to improve the accessibility oftheir mobile apps.
A
CKNOWLEDGMENT
This work was supported by the National Science Founda-
tion under grant 2009045.
740REFERENCES
[1] “WHO-Disability and health.” [Online]. Available:
https://www.who.int/news-room/fact-sheets/detail/disability-and-health
[2] J. T. Morris, M. W. Sweatman, and M. L. Jones, “Smartphone use
and activities by people with disabilities: 2015-2016 survey,” Journal
on Technology Persons with Disabilities , vol. 5, p. 50–66. [Online].
Available: http://hdl.handle.net/10211.3/190202
[3] J. Lazar, “The potential role of U.S. consumer protection laws in
improving digital accessibility for people with disabilities,” U. Pa. JL &
Soc. Change, vol. 22, p. 185, 2019.
[4] “Level Access: What Accessibility Standards Apply to Mobile Applica-
tions?” https://www.levelaccess.com/what-accessibility-standards-apply-
to-mobile-phone-applications/, updated: 2021-04-21.
[5] S. Yan and P. G. Ramachandran, “The Current Status of
Accessibility in Mobile Apps,” ACM Transactions on Accessible
Computing, vol. 12, no. 1, pp. 1–31, Feb. 2019. [Online]. Available:http://dl.acm.org/citation.cfm?doid=3312747.3300176
[6] C. Vendome, D. Solano, S. Li ˜n´an, and M. Linares-V ´asquez, “Can
Everyone use my app? An Empirical Study on Accessibility in AndroidApps,” in 2019 IEEE International Conference on Software Maintenance
and Evolution (ICSME), Sep. 2019, pp. 41–52, iSSN: 2576-3148.
[7] A. Alshayban, I. Ahmed, and S. Malek, “Accessibility Issues in Android
Apps: State of Affairs, Sentiments, and Ways Forward,” 2020, p. 12.
[8] A. S. Ross, X. Zhang, J. Fogarty, and J. O. Wobbrock,
“An Epidemiology-inspired Large-scale Analysis of AndroidApp Accessibility,” ACM Transactions on Accessible Computing,
vol. 13, no. 1, pp. 4:1–4:36, Apr. 2020. [Online]. Available:http://doi.org/10.1145/3348797
[9] M. E. Mott, R.-D. Vatavu, S. K. Kane, and J. O. Wobbrock, “Smart
Touch: Improving Touch Accuracy for People with Motor Impairmentswith Template Matching,” in Proceedings of the 2016 CHI Conference
on Human Factors in Computing Systems, ser. CHI ’16. New York,NY , USA: Association for Computing Machinery, May 2016, pp. 1934–1946. [Online]. Available: http://doi.org/10.1145/2858036.2858390
[10] S. N. Duff, C. B. Irwin, J. L. Skye, M. E. Sesto, and D. A. Wiegmann,
“The Effect of Disability and Approach on Touch Screen Performanceduring a Number Entry Task,” Proceedings of the Human Factors
and Ergonomics Society Annual Meeting, vol. 54, no. 6, pp. 566–570,Sep. 2010, publisher: SAGE Publications Inc. [Online]. Available:https://doi.org/10.1177/154193121005400605
[11] X. Valencia, J. E. P ´erez, M. Arrue, J. Abascal, C. Duarte, and
L. Moreno, “Adapting the Web for People With Upper BodyMotor Impairments Using Touch Screen Tablets,” Interacting with
Computers, vol. 29, no. 6, pp. 794–812, Nov. 2017. [Online]. Available:https://doi.org/10.1093/iwc/iwx013
[12] T. Guerreiro, H. Nicolau, J. Jorge, and D. Gonc ¸alves, “Towards
accessible touch interfaces,” in Proceedings of the 12th international
ACM SIGACCESS conference on Computers and accessibility,ser. ASSETS ’10. New York, NY , USA: Association forComputing Machinery, Oct. 2010, pp. 19–26. [Online]. Available:http://doi.org/10.1145/1878803.1878809
[13] L. Nurgalieva, J. J. J. Laconich, M. Baez, F. Casati, and M. Marchese, “A
Systematic Literature Review of Research-Derived Touchscreen DesignGuidelines for Older Adults,” IEEE Access, vol. 7, pp. 22 035–22 058,
2019, conference Name: IEEE Access.
[14] “Material Desing Accessibility.” [Online]. Avail-
able: https://material.io/design/usability/accessibility.htmllayout-and-typography
[15] “W3 Target Size.” [Online]. Available:
https://www.w3.org/WAI/WCAG21/Understanding/target-size
[16] “BBC Mobile Accessibility Guidlone.” [Online]. Available:
https://www.bbc.co.uk/accessibility/forproducts/guides/mobile/
[17] X. Zhang, T. Tran, Y . Sun, I. Culhane, S. Jain, J. Fogarty,
and J. Mankoff, “Interactiles: 3d printed tactile interfaces toenhance mobile touchscreen accessibility,” in Proceedings of the
20th International ACM SIGACCESS Conference on Computers andAccessibility, ser. ASSETS ’18. New York, NY , USA: Associationfor Computing Machinery, 2018, p. 131–142. [Online]. Available:https://doi.org/10.1145/3234695.3236349
[18] B. Taylor, A. Dey, D. Siewiorek, and A. Smailagic, “Customizable
3d printed tactile maps as interactive overlays,” in Proceedings of the
18th International ACM SIGACCESS Conference on Computers andAccessibility, ser. ASSETS ’16. New York, NY , USA: Associationfor Computing Machinery, 2016, p. 71–79. [Online]. Available:https://doi.org/10.1145/2982142.2982167
[19] L. He, Z. Wan, L. Findlater, and J. E. Froehlich, “Tactile: A
preliminary toolchain for creating accessible graphics with 3d-printed overlays and auditory annotations,” in Proceedings of the
19th International ACM SIGACCESS Conference on Computers andAccessibility, ser. ASSETS ’17. New York, NY , USA: Associationfor Computing Machinery, 2017, p. 397–398. [Online]. Available:https://doi.org/10.1145/3132525.3134818
[20] S. K. Kane, M. R. Morris, and J. O. Wobbrock, “Touchplates:
Low-cost tactile overlays for visually impaired touch screen users,” inProceedings of the 15th International ACM SIGACCESS Conferenceon Computers and Accessibility, ser. ASSETS ’13. New York, NY ,USA: Association for Computing Machinery, 2013. [Online]. Available:https://doi.org/10.1145/2513383.2513442
[21] S. K. Kane, M. R. Morris, A. Z. Perkins, D. Wigdor, R. E. Ladner, and
J. O. Wobbrock, “Access overlays: Improving non-visual access to largetouch screens for blind users,” in Proceedings of the 24th Annual ACM
Symposium on User Interface Software and Technology, ser. UIST ’11.New York, NY , USA: Association for Computing Machinery, 2011, p.273–282. [Online]. Available: https://doi.org/10.1145/2047196.2047232
[22] S. K. Kane, J. P. Bigham, and J. O. Wobbrock, “Slide rule: Making
mobile touch screens accessible to blind people using multi-touchinteraction techniques,” in Proceedings of the 10th International ACM
SIGACCESS Conference on Computers and Accessibility, ser. Assets’08. New York, NY , USA: Association for Computing Machinery, 2008,p. 73–80. [Online]. Available: https://doi.org/10.1145/1414471.1414487
[23] S. Azenkot, C. L. Bennett, and R. E. Ladner, “Digitaps: Eyes-free
number entry on touchscreens with minimal audio feedback,” inProceedings of the 26th Annual ACM Symposium on User InterfaceSoftware and Technology , ser. UIST ’13. New York, NY , USA:
Association for Computing Machinery, 2013, p. 85–90. [Online].Available: https://doi.org/10.1145/2501988.2502056
[24] X. Zhang, A. S. Ross, A. Caspi, J. Fogarty, and J. O. Wobbrock,
“Interaction proxies for runtime repair and enhancement of mobileapplication accessibility,” in Proceedings of the 2017 CHI Conference
on Human Factors in Computing Systems, ser. CHI ’17. New York,NY , USA: Association for Computing Machinery, 2017, p. 6024–6037.[Online]. Available: https://doi.org/10.1145/3025453.3025846
[25] Y . Zhong, A. Weber, C. Burkhardt, P. Weaver, and J. P.
Bigham, “Enhancing Android accessibility for users with handtremor by reducing ﬁne pointing and steady tapping,” inProceedings of the 12th International Web for All Conference.Florence Italy: ACM, May 2015, pp. 1–10. [Online]. Available:https://dl.acm.org/doi/10.1145/2745555.2747277
[26] “UI Automator.” [Online]. Available:
https://developer.android.com/training/testing/ui-automator
[27] “Layout Inspector.” [Online]. Available:
https://developer.android.com/studio/debug/layout-inspector
[28] “Google Accessibility for Android.” [Online]. Available:
https://developer.android.com/guide/topics/ui/accessibility
[29] “Android Accessibility Help: Get started with Accessibility Scanner,”
https://support.google.com/accessibility/android/answer/6376570?hl=en,updated: 2021-04-21.
[30] “google/Accessibility-Test-Framework-for-Android,” Dec. 2020,
original-date: 2015-09-12T00:49:01Z. [Online]. Available:https://github.com/google/Accessibility-Test-Framework-for-Android
[31] “IBM Mobile Accessibility Checker,” May 2020, original-date: 2017-
11-06T14:35:17Z. [Online]. Available: https://github.com/IBMa/MAC
[32] A. Sanoja and S. Ganc ¸arski, “Block-o-Matic: A web page segmentation
framework,” in 2014 International Conference on Multimedia Comput-
ing and Systems (ICMCS), Apr. 2014, pp. 595–600.
[33] S. Mahajan and W. G. J. Halfond, “Detection and Localization of HTML
Presentation Failures Using Computer Vision-Based Techniques,” in2015 IEEE 8th International Conference on Software Testing, V eriﬁ-cation and V alidation (ICST), Apr. 2015, pp. 1–10, iSSN: 2159-4848.
[34] S. Mahajan, N. Abolhassani, P. McMinn, and W. G. J. Halfond,
“Automated repair of mobile friendly problems in web pages,” inProceedings of 40th International Conference on Software Engineering.Gothenburg Sweden: ACM, May 2018, pp. 140–150. [Online].Available: https://dl.acm.org/doi/10.1145/3180155.3180262
[35] M. Ester, H.-P. Kriegel, and X. Xu, “A Density-Based Algorithm for
Discovering Clusters in Large Spatial Databases with Noise,” p. 6.
[36] “Apktool - A tool for reverse engineering 3rd party, closed, binary An-
droid apps.” [Online]. Available: https://ibotpeaches.github.io/Apktool/
741[37] “Google Developers: Android Debug Bridge (adb),”
https://developer.android.com/studio/command-line/adb, updated:
2021-02-18.
[38] “SALEM Project Web Site,” Aug. 2021. [Online]. Available:
https://sites.google.com/usc.edu/salem/
[39] Google, “Android Apps on Google Play.” [Online]. Available:
https://play.google.com/store/apps?hl=engl=US
[40] “Screen Sizes,” https://screensiz.es/nexus-6p, updated: 2021-04-19.[41] “Amazon Mechanical Turk.” [Online]. Available:
https://www.mturk.com/
[42] S. Mahajan, A. Alameer, P. McMinn, and W. G. J. Halfond, “Automated
repair of internationalization presentation failures in web pages usingstyle similarity clustering and search-based techniques,” in 2018 IEEE
11th International Conference on Software Testing, V eriﬁcation andV alidation (ICST), 2018, pp. 215–226.
[43] A. Alameer, P. Chiou, and W. G. Halfond, “Efﬁciently repairing inter-
nationalization presentation failures by solving layout constraints,” inProceedings of the IEEE international conference on software testing,veriﬁcation, and validation (ICST), Apr. 2019, tex.acceptancerate: 28%(31/110) tex.pubtype: Conference.
[44] M. Linares-V ´asquez, G. Bavota, C. Bernal-C ´ardenas, M. D. Penta,
R. Oliveto, and D. Poshyvanyk, “Multi-Objective Optimization ofEnergy Consumption of GUIs in Android Apps,” ACM Transactions on
Software Engineering and Methodology, vol. 27, no. 3, pp. 14:1–14:47,Sep. 2018. [Online]. Available: http://doi.org/10.1145/3241742
[45] S. Hao, B. Liu, S. Nath, W. G. Halfond, and R. Govindan, “Puma:
Programmable ui-automation for large scale dynamic analysis of mobileapps,” in Proceedings of the ACM International Conference on Mobile
Systems, Applications, and Services (MobiSys), June 2014.
[46] N. Salehnamadi, A. Alshayban, J.-W. Lin, I. Ahmed, S. Branham, and
S. Malek, “Latte: Use-Case and Assistive-Service Driven AutomatedAccessibility Testing Framework for Android,” in Proceedings of
the 2021 CHI Conference on Human Factors in ComputingSystems. New York, NY , USA: Association for ComputingMachinery, May 2021, no. 274, pp. 1–11. [Online]. Available:http://doi.org/10.1145/3411764.3445455
[47] P. T. Chiou, A. S. Alotaibi, and W. G. J. Halfond, “Detecting
and localizing keyboard accessibility failures in web applications,” inProceedings of the 29th ACM Joint Meeting on European SoftwareEngineering Conference and Symposium on the F oundations of SoftwareEngineering, ser. ESEC/FSE 2021. New York, NY , USA: Associationfor Computing Machinery, Aug. 2021, pp. 855–867. [Online]. Available:http://doi.org/10.1145/3468264.3468581
[48] M. Bajammal and A. Mesbah, “Semantic Web Accessibility Testing via
Hierarchical Visual Analysis,” in 2021 IEEE/ACM 43rd International
Conference on Software Engineering (ICSE), May 2021, pp. 1610–1621,iSSN: 1558-1225.
[49] P. Panchekha, A. T. Geller, M. D. Ernst, Z. Tatlock, and S. Kamil,
“Verifying that web pages have accessible layout,” in Proceedings
of the 39th ACM SIGPLAN Conference on Programming LanguageDesign and Implementation, ser. PLDI 2018. New York, NY , USA:Association for Computing Machinery, Jun. 2018, pp. 1–14. [Online].Available: http://doi.org/10.1145/3192366.3192407
[50] P. Panchekha, M. D. Ernst, Z. Tatlock, and S. Kamil, “Modular
veriﬁcation of web page layout,” Proceedings of the ACM on
Programming Languages, vol. 3, no. OOPSLA, pp. 151:1–151:26, Oct.2019. [Online]. Available: https://doi.org/10.1145/3360577
[51] J. Wu, G. Reyes, S. C. White, X. Zhang, and J. P. Bigham,
“When can accessibility help?: an exploration of accessibilityfeature recommendation on mobile devices,” in Proceedings of
the 18th International Web for All Conference. LjubljanaSlovenia: ACM, Apr. 2021, pp. 1–12. [Online]. Available:https://dl.acm.org/doi/10.1145/3430263.3452434
[52] X. Zhang, L. de Greef, A. Swearngin, S. White, K. Murray, L. Yu,
Q. Shan, J. Nichols, J. Wu, C. Fleizach, A. Everitt, and J. P. Bigham,“Screen recognition: Creating accessibility metadata for mobile appli-cations from pixels,” 2021.
[53] A. S. Ross, X. Zhang, J. Fogarty, and J. O. Wobbrock,
“Examining image-based button labeling for accessibility in androidapps through large-scale analysis,” in Proceedings of the 20th
International ACM SIGACCESS Conference on Computers andAccessibility, ser. ASSETS ’18. New York, NY , USA: Associationfor Computing Machinery, 2018, p. 119–130. [Online]. Available:https://doi.org/10.1145/3234695.3236364
[54] “Google: Our all-new TalkBack screen reader,”
https://blog.google/products/android/all-new-talkback/, updated: 2021-04-21.
[55] X. Zhang, A. S. Ross, and J. Fogarty, “Robust annotation of
mobile application interfaces in methods for accessibility repair andenhancement,” in Proceedings of the 31st Annual ACM Symposium on
User Interface Software and Technology, ser. UIST ’18. New York,NY , USA: Association for Computing Machinery, 2018, p. 609–621.
[Online]. Available: https://doi.org/10.1145/3242587.3242616
[56] J. Chen, C. Chen, Z. Xing, X. Xu, L. Zhu, G. Li, and J. Wang,
“Unblind Your Apps: Predicting Natural-Language Labels for Mobile
GUI Components by Deep Learning,” Mar. 2020. [Online]. Available:https://arxiv.org/abs/2003.00380v2
[57] F. Mehralian, N. Salehnamadi, and S. Malek, “Data-driven accessibility
repair revisited: on the effectiveness of generating labels for icons inAndroid apps,” in Proceedings of the 29th ACM Joint Meeting on
European Software Engineering Conference and Symposium on theF oundations of Software Engineering, ser. ESEC/FSE 2021. NewYork, NY , USA: Association for Computing Machinery, Aug. 2021, pp.107–118. [Online]. Available: https://doi.org/10.1145/3468264.3468604
[58] E. Brady and J. P. Bigham, “Crowdsourcing accessibility:
Human-powered access technologies,” F oundations and Trends®
in Human–Computer Interaction, vol. 8, no. 4, pp. 273–372, 2015.[Online]. Available: http://dx.doi.org/10.1561/1100000050
[59] “Android Accessibility Help: Magniﬁcation,”
https://support.google.com/accessibility/android/answer/6006949,updated: 2021-04-21.
[60] Z. Liu, C. Chen, J. Wang, Y . Huang, J. Hu, and Q. Wang, “Owl eyes:
Spotting ui display issues via visual understanding,” in Proceedings of
the 35th IEEE/ACM International Conference on Automated SoftwareEngineering, ser. ASE ’20. New York, NY , USA: Associationfor Computing Machinery, 2020, p. 398–409. [Online]. Available:https://doi.org/10.1145/3324884.3416547
[61] A. Alameer, P. T. Chiou, and W. G. J. Halfond, “Efﬁciently repairing
internationalization presentation failures by solving layout constraints,”in2019 12th IEEE Conference on Software Testing, V alidation and
V eriﬁcation (ICST), 2019, pp. 172–182.
[62] R. K. Saha, Y . Lyu, H. Yoshida, and M. R. Prasad, “Elixir: Effective
object-oriented program repair,” in 2017 32nd IEEE/ACM International
Conference on Automated Software Engineering (ASE) , Oct. 2017, pp.
648–659.
[63] S. H. Tan, Z. Dong, X. Gao, and A. Roychoudhury, “Repairing
crashes in Android apps,” in Proceedings of the 40th International
Conference on Software Engineering, ser. ICSE ’18. New York, NY ,USA: Association for Computing Machinery, May 2018, pp. 187–198.[Online]. Available: http://doi.org/10.1145/3180155.3180243
[64] R. S. Shariffdeen, S. H. Tan, M. Gao, and A. Roychoudhury,
“Automated Patch Transplantation,” ACM Transactions on Software
Engineering and Methodology, vol. 30, no. 1, pp. 6:1–6:36, Dec. 2021.[Online]. Available: http://doi.org/10.1145/3412376
[65] F. Long and M. Rinard, “Automatic patch generation by
learning correct code,” in Proceedings of the 43rd Annual
ACM SIGPLAN-SIGACT Symposium on Principles of ProgrammingLanguages, ser. POPL ’16. New York, NY , USA: Association forComputing Machinery, Jan. 2016, pp. 298–312. [Online]. Available:https://doi.org/10.1145/2837614.2837617
742