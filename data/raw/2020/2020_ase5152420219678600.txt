Why Do Developers Remove Lambda Expressions
in Java?
Mingwei Zheng‚Ä†¬ß, Jun Yang¬∂, Ming Wen‚Ä†¬ß‚àó, Hengcheng Zhu‚Ä°, Yepang Liu/bardbl, Hai Jin¬ß/sharp
‚Ä†Hubei Engineering Research Center on Big Data Security, School of Cyber Science and Engineering
Huazhong University of Science and Technology, Wuhan, China
¬ßNational Engineering Research Center for Big Data Technology and System, Services Computing Technology and System Lab
Huazhong University of Science and Technology, Wuhan, China
¬∂School of Electronic Information and Communications, Huazhong University of Science and Technology, Wuhan, China
/sharpCluster and Grid Computing Lab, School of Computer Science and Technology, HUST, Wuhan, China
‚Ä°Dept. of Computer Science and Engineering, The Hong Kong University of Science and Technology, Hong Kong, China
/bardblDept. of Computer Science and Engineering, Southern University of Science and Technology, Shenzhen, China
{zmw12306, claudeyangjun, mwenaa, hjin}@hust.edu.cn, hzhuaq@connect.ust.hk, liuyp1@sustech.edu.cn
Abstract ‚Äî Java 8 has introduced lambda expressions, a core
feature of functional programming. Since its introduction, there
is an increasing trend of lambda adoptions in Java projects.Developers often adopt lambda expressions to simplify code,avoid code duplication or simulate other functional features.However, we observe that lambda expressions can also incurdifferent types of side effects (i.e., performance issues andmemory leakages) or even severe bugs, and developers alsofrequently remove lambda expressions in their implementations.Consequently, the advantages of utilizing lambda expressions canbe signiÔ¨Åcantly compromised by the collateral side effects. In thisstudy, we present the Ô¨Årst large-scale, quantitative and qualitativeempirical study to characterize and understand inappropriateusages of lambda expressions. Particularly, we summarized sevenmain reasons for the removal of lambdas as well as seven commonmigration patterns. For instance, we observe that lambdas usingcustomized functional interfaces are more likely to be removedby developers. Moreover, from a complementary perspective, weperformed a user study over 30 developers to seek the underlyingreasons why they remove lambda expressions in practice. Finally,based on our empirical results, we made suggestions on scenariosto avoid lambda usages for Java developers and also pointed outfuture directions for researchers.
Index Terms‚ÄîLambda Expression, Empirical Study
I. I NTRODUCTION
Lambda expression [1] is an important functional feature,
which has been widely applied in functional programming
languages, such as Standard ML, Haskell, and so on. Plentifulmainstream Object-Oriented Languages, such as Java, C++,
and C#, also support lambda expressions to parameterizefunctionality with time evolves. Since the introduction oflambda expressions in Java 8,
1there is an increasing trend
of lambda adoptions in open-source Java projects as revealedby a recent study [2].
Utilizing the features of lambdas, developers have migrated
from anonymous classes to lambda expressions, and fromenhanced for loops to Streams. Unfortunately, with a wider
‚àóMing Wen is the corresponding author.
1We use lambdas and lambda expressions interchangeably for simplicity.1synchronized DocumentsWriterDeleteQueue
2 advanceQueue(int maxNumPendingOps) {
3 ...
4 return new DocumentsWriterDeleteQueue(infoStream,
5 generation +1, seqNo +1,
6 ()->nextSeqNo.get() -1);
7 }
Listing 1: Memory Leak Caused by Inappropriate Usage ofLambda Expression (LUCENE-9478)
range of the adoptions of lambda expressions in Java, we
also observe an increasing number of misuses of them inpractice. In this study, we denote a misuse of lambda ex-
pression as the case where a lambda expression is used
inappropriately which causes side effects or even inducesbugs. Listing 1 shows an issue (i.e., LUCENE-9478 [3]) from
Apache Lucene, a large-scale and open-source project. In thisexample, DocumentsWriterDeleteQueue is implemented to
advance the queue to the next one on Ô¨Çush, which uses alambda expression as one of its parameters. However, thereare 500 bytes of memory leakage on each full Ô¨Çush due tothe inappropriate usage of lambda expression. This is becausethe lambda expression maintains an implicit reference to theenclosing instance (the current queue object) at runtime inorder to access variable nextSeqNo, which is not deÔ¨Åned in
the lambda body. Therefore, on each Ô¨Çush, the new queue willunfortunately keep a reference to the outdated queue whichis no longer needed, thus preventing it from being garbagecollected. Consequently, memory leaks were observed by de-velopers. Such an issue is reported on JIRA for discussion andmarked as the type of Bug with the priority of Blocker, which
reÔ¨Çects the signiÔ¨Åcance of this issue. To Ô¨Åx it, developershave removed such a lambda expression in this context, andreplaced it with an invocation to a static method.
We observe it is pervasive that developers change a lambda
expression back into a conventional implementation afterintroducing it in large-scale open-source projects. For instance,
672021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000172021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678600
978-1-6654-0337-5/21/$31.00  ¬©2021  IEEE

   	 
    
	
Figure 1: The Trend of Lambda Removals. The number is
computed on 103 open-source projects as described in Section III-A.
in project Apache Camel [4], we found that 154 lambda
expressions have been removed during the last year. Such a
number is 784 in project Apache Geode [5], which indicates
that more than two lambdas have been removed in this projecteach day on average. Meanwhile, We found that the behaviorof developers to delete lambdas is increasing year by yearas shown in Figure 1. Worse still, we observe that lambdaexpressions can often be misused, in which case lambdas willeither induce bugs or cause side effects, such as efÔ¨Åciencyissues or memory leaks. Therefore, it arouses our great interestto investigate the characteristics of the lambda expressions thatare inappropriately used and removed by developers.
Despite its signiÔ¨Åcance and pervasiveness, little is known
about the misuse of lambda expressions in Java. In particu-lar, there is still limited empirical knowledge towards what
lambdas are often removed by developers, why do devel-
opers remove lambdas, and the migration patterns adopted
by developers to remove them. The lack of such knowledgeimpacts negatively for Java developers to correctly use lambdaexpressions in practice. This study aims to bridge this gap.SpeciÔ¨Åcally, we performed a quantitative and a qualitative
study to investigate the above-mentioned questions. In thequantitative study, we conducted a large-scale empirical studybased on 103 Apache projects to understand the characteristicsof those lambda expressions that were removed by developers.SpeciÔ¨Åcally, we collected 3,662 real cases of such lambdas andanalyzed their characteristics quantitatively. We then comparedthe characteristics with those of lambdas that have been keptin a project from beginning to end. Our qualitative analysisaims to answer the following research question:
RQ1: What lambda expressions are more frequently re-
moved by developers? We found that lambdas built on top
of customized functional interfaces, passed to self-deÔ¨Ånedmethod invocations are more likely to be removed. In addition,non-empty argument lambdas with more complex bodies aremuch more likely to be refactored.
In the qualitative study, we performed two separate experi-
ments with in-depth analysis. First, we collected 92 real issuescaused by lambda misuses from large open-source projects,and then analyzed such issues manually to characterize theremoval reasons, impacts, and code migration patterns of thoseinappropriate lambdas. Second, we designed and conducted asurvey with experienced Github contributors, from a comple-mentary perspective, to further understand the insights whydevelopers remove lambdas and got 25 additional issues intotal. With these two experiments, we aim to answer thefollowing research questions:(intx) -> { 
returnx*2;
}x -> x*2@FunctionalInterface
public interface IntOp {
intapply(int value);
}
	


Figure 2: Lambda Expressions and the Corresponding Func-
tional Interface
RQ2: Why do developers remove lambda expressions in
practice? What are the reasons behind and impacts? We
found seven common reasons for lambda removals, includingbut not limited to performance degradation, poor readability,serialization issues, and lazy evaluation issues.
RQ3: What are the migration patterns of the inappropriate
usages of lambda expressions? We summarized seven major
migration patterns and analyzed the relationship with removalreasons. Our results show that there are common migrationpatterns for most kinds of lambda misuses, which can facilitatedevelopers to Ô¨Åx those issues caused by inappropriate lambdas.Besides, in order to help developers avoid lambda misuse fromthe beginning, we summarized Ô¨Åve pieces of actionable advicefor utilizing lambda expressions appropriately.
The usefulness of this study is well recognized by develop-
ers. As mentioned by one developer from Apache Calcite [6],
‚ÄúAwesome work you are doing‚Äù. Meanwhile, our empiricalresults are anticipated by some developers: ‚ÄúI would be appre-ciated if you can share your Ô¨Åndings of the subject ‚Äù, ‚ÄúThanks
for the question and for pointing out the issue‚Äù, ‚ÄúWhere willI be able to read about your results‚Äù. Hence, we believethis study can shed light on the better utilization of lambdaexpressions for Java developers in practice. In summary, thisstudy makes the following major contributions:
‚Ä¢Originality: To our best knowledge, we are the Ô¨Årst
to comprehensively study the inappropriate usages oflambda expressions in Java.
‚Ä¢Quantitative Analysis: We collected 3,662 cases of re-
moved lambdas and compared their characteristics with31,288 kept ones and found that lambda expressionsthat are large in their sizes, built on top of customized
functional interfaces, passed to self-deÔ¨Åned method invo-
cations are more likely to be removed.
‚Ä¢Qualitative Analysis: We collected 117 real-world issues
and conducted a user study to explore the reasons, im-pacts, and migration patterns of lambda removals. Wealso generate actionable advice to guide Java program-ming with lambda expressions.
‚Ä¢Dataset: We open sourced our collected datasets and
the experimental results to facilitate future concern-ing researches, which is available at GitHub: https:
//github. com/CGCL-codes/LambdaMisuse.
II. B
ACKGROUND AND MOTIV A TION
A. Lambda Expressions
To support functional programming, Java 8 has introduced
several functional idioms. For instance, it re-designs the inter-
face, introduces lambda expression, retroÔ¨Åts the Collection
68framework, and introduces the Stream API. This evolution
enables developers to embrace various advantages from both
Object-Oriented programming and functional programming.Consequently, there is an increasing trend in the adoptionof such functional idioms in open-source Java projects. Theusage of certain new Java 8 API methods, especially theStream API, heavily relies on the usage of lambda expressions.For instance, most Stream operations accept parameters that
describe user-speciÔ¨Åed behaviors, which are often in the formof lambda expressions [7]. Therefore, according to an existingstudy [8], lambda expression is the most accepted functionidiom, being accepted by 16% of the investigated projectswhile the other features, such as the Stream API, are acceptedby no greater than 3% of the investigated projects. Due to sucha high accept ratio of lambdas and their signiÔ¨Åcance, we putour focus mainly on lambda expressions in this study.
A lambda expression is composed of three parts: parameter
list, the arrow token (i.e.,‚Üí), and a lambda body. The
parameter lists are similar to the formal parameters of a regularmethod except that the type information can be omitted ifit can be inferred by the compiler and the parentheses canbe omitted when there is exactly one parameter. The lambdabody should be either an expression, or a code block similarto the body of a regular method. In Java, a lambda expressioncan be assigned to a variable or be passed to a method as anargument if the corresponding type is a functional interface,
which contains only a single abstract method. Figure 2 showsan example of lambda expressions that doubles the giveninteger and their corresponding functional interface.
There are several studies trying to understand the usages
of lambda expressions in Java. SpeciÔ¨Åcally, Mazinanian etal. presented the Ô¨Årst large-scale empirical study on howdevelopers use lambda expressions in Java since its introduc-tion [2]. They observed an increasing trend in the adoption oflambdas in Java. SpeciÔ¨Åcally, developers often employ lambdaexpressions to simplify source code, avoid code duplicationand simulate lazy evaluations. Matsumoto et al. conducted astudy to explore the current use status of functional idioms inJava [8]. Their statistical results show that lambda expressionsare more widely utilized than Stream and Optional in Java
programming. Especially, they discovered that most developerswrite lambda expressions for good readability and betterperformance, while refusing them due to the complicationswhen handling exceptions and compatibility issues. Althoughit is common wisdom that refactoring a legacy code to alambda expression might simplify code and enhance pro-gram comprehension, Lucas et al. made contradictory ob-servations [9]. SpeciÔ¨Åcally, they found no evidence that theintroduction of lambda expressions can improve program com-prehension via qualitative and quantitative analysis. Gyori etal. implemented LambdaFicator to enable automatic refactors:
anonymous classes to lambda expressions, for loops that iterateover Collections to functional operations that use lambda
expressions [10]. Alqaimi et al. designed LAMBDADOC to
automatically generate documents for lambda expressions tohelp readers better understand their functionalities [11]. Be-sides, Tsantalis et al. investigated the applicability of lambdaexpressions for the refactoring of clones with behavioraldifferences [12], and found that lambda expressions enablethe refactoring of a signiÔ¨Åcant portion of clones that couldnot be refactored by any other means.
B. Misuse of Lambda Expressions
With an increasing number of lambda expressions adopted
in Java, we also observe that the usages of them might cause
side effects or even induce bugs. Listing 1 shows an example.Actually, similar issues can be frequently observed amongpopular open-source projects. For example, in Apache My-
Faces Core, we observed excessive object allocations (around1,000,000 object instances) caused by inappropriate usage oflambda expressions that are invoked many times [13]. Besides,we also notice several serialization issues in Apache FLINK
caused by lambda expressions [14], [15]. Unfortunately, thereis no systematic study that has comprehensively investigatedand understood the inappropriate usages of lambda expressionsin Java. This study aims to bridge this gap.
Be noted that lambda expression is just a type of syntactic
structure, which is often used under certain contexts withother code structures, such as the Stream API. Therefore, the
side effects of lambda expressions can be collectively affectedby their structures and contexts. Actually, we also tried toinvestigate the misusages of lambda expression itself excludingits contexts. However, most of the incorrect usages caused byitself (more than 80%) are syntactic issues, which are oftenmanifested as compilation errors. SpeciÔ¨Åcally, we collected186 issues from Stack OverÔ¨Çow related to the inappropriateusages of lambda expressions without considering their con-texts, and found that 80.65% of them led to compilation fail-
ures.
2Such syntactic compilation failures are relatively easier
for developers to debug and resolve, and thus the researchvalue is limited. Besides, it is rare to observe such issuesin real open-source projects since they are often guaranteedto be compiled successfully when released to the market.Therefore, we take the contexts of lambda expressions intoconsideration, especially the usages of other functional idioms,i.e., Stream API, Collections API, etc. This enriches our
research scope and enables us to understand the side-effectsof lambda expressions with respect to their semantics. Italso can provide more in-depth guidance for developers tobetter use lambda expressions under certain scenarios. We alsoconsidered conducting a comprehensive study on all the Javafunctional idioms. However, collecting such data is not aneasy task, which often contains too many noises. For instance,while searching the keyword ‚ÄúStream‚Äù on JIRA, most itemsreturned are related to the Java Process Streams instead ofthe Stream API. Therefore, in this study, we put our focus onthe side-effects caused by lambda expressions as well as theircontexts, including the functional APIs that rely on them. Inthe following parts of this paper, we will clearly distinguish
2We provide the details of such empirical results over Stack OverÔ¨Çow on
https://github.com/CGCL-codes/LambdaMisuse
69lambda expressions and the functional APIs while explaining
our Ô¨Åndings.
III. C HARACTERIZING THE REMOVED LAMBDAS
In this section, we aim to answer RQ1 by characterizing
the lambda expressions that have been removed by devel-opers. SpeciÔ¨Åcally, we constructed two datasets containingthe lambda expressions that are, respectively, removed andkept by developers. By comparing the characteristics of thelambda expressions in the two datasets, we can answer RQ1by presenting the potential factors that make the developersprone to remove a lambda expression.
A. Data Collection
In order to characterize the lambda expressions that were
removed by developers, we need to Ô¨Årst collect a dataset
containing the removed ones, which is denoted as follows:
Removed lambda expressions. Includes lambda expres-
sions that were removed by developers in order to addresscertain issues. Be noted that removal of lambda expressions
due to simply functional deletion is excluded from our scope.Our aim is to collect a set of lambda expressions that arerepresentatives of those misused by developers.
To enable a comprehensive understanding of the character-
istics of those removed lambdas, we also collect the followingdataset for comparison.
Kept lambda expressions. Includes lambda expressions
that have been kept in the project for a long term, which aremore likely to be those used correctly by developers.
By comparing the lambda expressions in the above two sets,
we can draw a picture of what kind of lambda expressionsare likely to be misused and thus should be removed from theprojects. Next, we present the data collection process in detail.
1) Project Selection: We select projects from the Apache
Software Foundation (ASF) because they are well maintained:they follow a rigorous project management strategy so that wecan extract more useful information about the code changes inthe commit messages. SpeciÔ¨Åcally, we selected 103 activelymaintained Java projects that contain at least 1,000 commitsand 10 committers from the ASF project list [16]. On theone hand, a sufÔ¨Åcient number of commits guarantees enoughcode changes for our empirical study. On the other hand, therequirement towards the committers ensures diversiÔ¨Åed codepractices in the projects. Such diversities are important toguarantee the generality of our dataset. As shown in Figure 3,our selected projects have commits ranging from 1.0k to 51.8k(8.71k on average), and have different committers rangingfrom 10 to 230 (40 on average), which shows that they arelarge and diversiÔ¨Åed sufÔ¨Åcient.
2) Collecting Removed Lambda Expressions: To identify
the removed lambda expressions by developers, we utilizedGumTree [17], an AST-based code differencing tool, to ana-lyze those commits that modify Java source Ô¨Åles. Since therecan be multiple changes to a Ô¨Åle in a single commit, whenanalyzing a commit, we further looked into the edit hunks [18]of the code diff and extracted the removed lambda expressions  
(a) # of Commits    
(b) # of Committers
Figure 3: Commits and Committers of the Selected Projects
at the hunk level, which enables us to apply the following rulesto improve the soundness of our dataset.
‚Ä¢We excluded those commits modifying more than 20 sourceÔ¨Åles since they are likely to be tangled with multiple inten-tions [19], thus introducing noises of irrelevant changes.
‚Ä¢We keep only the commits that either contain an issue ID,or have keywords that may describe an issue (e.g., bug,Ô¨Åx)
in its commit message. Such commits are likely to be madeto Ô¨Åx an issue. The complete list is available on our page.
3
‚Ä¢Merge commits are excluded as they aggregate multiplechanges from other branches and are considered redundant.
‚Ä¢We ignored the hunks in which more than 50% of the mod-iÔ¨Åed lines are irrelevant to the removed lambda expressionsince they may not focus on lambda expressions. Instead, thelambda might be deleted in collateral with other changes.
‚Ä¢We ignored the hunks that only delete source code since theintention of such changes is more likely to be functionalitydetection instead of removing misused lambda expressions.
Be noted that rigorous rules have been adopted here to
collect removed lambdas since our goal is to collect a datasetof high-quality which contains lambda expressions removedby inappropriate usages. Noises can still be inevitable, whilewe have made our best efforts to collect such a dataset. Finally,we collected 3,662 cases of removed lambda expressions.
3) Collecting Kept Lambda Expressions: In addition, we
collected lambda expressions in our selected projects that arekept by developers, which are considered as representatives ofthe correctly used ones. SpeciÔ¨Åcally, we applied the followingrules to Ô¨Ålter such lambda expressions.
‚Ä¢It must still exist in the latest version of the code repository.
‚Ä¢It must have stayed in the project for a sufÔ¨Åciently longtime since its introduction. In this paper, we consider 24months to be sufÔ¨Åciently long since it has been revealedthat bugs can be usually exposed and repaired within 24months [20], [21]. Besides, most of the removed lambdaexpressions (97.37%) collected by us have stayed in theproject for less than 24 months as shown in Figure 4a.
‚Ä¢Lambda expressions introduced in commits that modifymore than 100 Ô¨Åles are excluded since they are usuallyintroduced by large-scale refactoring.
By adopting the above process, we obtained a dataset
containing 31,228 kept lambda expressions.
B. Methodology
To answer RQ1, we Ô¨Årst inspect the lifetime of the removed
lambda expressions. SpeciÔ¨Åcally, for each case, we calculated
3https://github.com/CGCL-codes/LambdaMisuse
70the time period it has stayed in the project. Additionally, we
extracted several features of lambdas that may relate to theremoval of it from the following three different perspectives:
The usages of functional interfaces. There are 43 func-
tional interfaces introduced into JDK 8, providing plentiful in-put/output parameter combinations and covering a wide rangeof functionalities. Besides, developers can also implement theirown customized functional interfaces to enable throwing ex-ceptions or extending other interfaces. We investigated whetherthose lambda removals are related to the usages of differentfunctional interfaces.
The complexity of lambda expressions. From our dataset,
we observed that some lambda expressions are removed due tothe poor readability caused by their large sizes. Therefore, weare motivated to explore whether complexity can be a factorrelated to the removal of a lambda expression. SpeciÔ¨Åcally, wemeasure the complexity of a lambda expression with respectto four different aspects: number of parameters, lines of code,the height of the AST of the lambda body, and the number ofvariables accessed in the lambda body.
The contexts of lambda expressions. We investigated
whether a lambda expression is likely to be removed undercertain contexts, such as the locations and the type of codestructures where lambda expressions are used. We foundthat both kept and removed lambda expressions are mostlyused in method invocations. SpeciÔ¨Åcally, the ratio of methodinvocation is 85.64% for removed lambdas and 85.13% forkept ones. Therefore, we are motivated to analyze the methodAPIs which invoke the lambda expressions, and see whetherthe utilized APIs are different over removed and kept lambdas.
Note that when extracting features such as the fully qualiÔ¨Åed
name of functional interfaces, we need to compile the wholeproject to resolve the type information and method binding.However, some of the revisions may fail to compile. Therefore,for certain features, the analysis is performed on the revisionsthat can be compiled (including 1,847 removed lambdas and17,823 kept ones), which is our best effort.
C. Empirical Results
1) Lifetime of removed lambdas: We investigated the life-
time of the removed lambdas, 38.26% (1,401 out of 3,662)
of the lambdas have survived no longer than one month.However, 20.23% (741 out of 3,662) of the lambdas areremoved after more than one year. Especially, we found onelambda has lived as long as 61 months before its removal.Such results reveal that inappropriate usages of lambdas canbe removed as quickly as certain side effects are observed.However, some lambdas can be long-lived in the project,continuously affecting the project until it is discovered bydevelopers, for example, performance degradation.
2) The usage of functional interface: As shown in Figure 5,
35.68% of the removed lambdas are implemented on top of
customized functional interfaces (i.e., functional interfaces thatare deÔ¨Åned by developers) while that ratio is only 28.03%
among kept ones. Such a high ratio difference indicates thatcustomized functional interfaces are more likely to be misused.A Chi-Square test [22] of independence was performed toexamine the relation between the removal of lambda expres-sions and usage of customized functional interface, whichreveals that the relation was signiÔ¨Åcant at the signiÔ¨Åcance levelof 0.05, œá
2(1,n=1 9,670) = 47.49, p=5.52√ó10‚àí12.
The effect size œïwas 0.05, indicating that the magnitude
of the effect is small. This is because customized functionalinterfaces mostly deÔ¨Åne more complex functionalities that arenot implemented by the current built-in functional interfaces,and thus are much easier to introduce bugs. Besides, built-infunctional interfaces are deÔ¨Åned with speciÔ¨Åc functionalitiesand usually used together with built-in APIs, e.g., Stream API
with lambdas. Therefore, using such well-deÔ¨Åned interfaces isless likely to introduce issues.
Finding #1: Lambda expressions built on top of customized
functional interfaces are more likely to be removed.
3) The complexity of lambda expressions: We measure the
complexity of lambda expressions from four perspectives asmentioned above. The measure of parameter number is shownin Figure 6 while the statistics of the other three are depictedin Figure 4 (clipped down outliers exceeding Œº+3œÉ). It shows
that removed lambdas (38.34%) have a higher percentageofempty argument lambda (lambda expressions that do not
receive any argument) than kept ones (30.75%). Similarly, weapplied the Chi-Square test [22], and observe the relation issigniÔ¨Åcant at the signiÔ¨Åcance of 0.05 with a small effect size of0.05. Besides, for empty argument lambdas, we observed that
removed lambdas have signiÔ¨Åcantly fewer lines and smallerbody depth than kept ones as shown in Figure 4c and Figure 4dwith a p-value of 2.44√ó10
‚àí16and8.91√ó10‚àí28respectively
by the Mann-Whitney U Test [23]. One possible reason isthat empty argument lambdas with terse bodies can always beeasily refactored to method reference for code simpliÔ¨Åcation.
As for non-empty argument lambdas, removed lambdas
occupy more lines of code than kept ones as shown in Figure4b (p-value=2. 47√ó10
‚àí12at the signiÔ¨Åcance level of 5% by the
Mann-Whitney U Test [23]). In other words, for such lambdas,occupying more lines of code or having a more complex bodytend to exhibit a higher probability to be removed. That isnot a surprise because lambda expressions aim at providinga lightweight mechanism to deliver functionalities [24], whilelambdas with complicated structures violate such a philosophy.
We also investigated the number of variables inside lambda
bodies. As shown in Figure 4e, kept lambdas contain 4.89variables on average while removed lambdas contain 5.49variables. The Mann-Whitney U test [23] reveals that keptlambdas have signiÔ¨Åcantly fewer variables in their body thanremoved lambdas at the signiÔ¨Åcance of 5% (p-value=0.0036).
Finding #2: Empty argument lambdas has a larger possibil-
ity to be removed, while non-empty argument lambdas withmore complex bodies are more likely to be refactored.
4) The contexts of lambda expressions: We inspect the
contexts of lambda expressions as follows. First, we investigate
71
.HSW 5HPRYHG1XPEHU
(a) Life Time of Kept and Re-
moved Lambda Expressions
.HSW 5HPRYHG1XPEHU
(b) Line Number of Removed and
Kept Lambdas with Parameters
.HSW 5HPRYHG1XPEHU
(c) Line Number of Lambdas with-
out Parameters
.HSW 5HPRYHG1XPEHU
(d) Lambda Body Depth of Lamb-
das without Parameters
.HSW 5HPRYHG1XPEHU
(e) V ariable Number of Kept and
Removed Lambdas
Figure 4: Comparison between Removed and Kept Lambdas




	

	


     			

 	



Figure 5: Comparison between Removed and Kept Lambdas

   	

   
Figure 6: Parameter Numbers of Kept and Removed Lambdas
what speciÔ¨Åc APIs lambdas are often passed to. Figure 5
shows that lambda expressions passed to self-deÔ¨Åned methodsare more likely to be removed by developers (i.e., 67.38%
vs50.32%). A Chi-Square test reveals that the removal of
lambda expressions is signiÔ¨Åcantly correlated with whetherthe invoked method is self-deÔ¨Åned or not with a p-value ofp=8.50√ó10
‚àí46and a small effect size of 0.10. One
possible reason is that APIs deÔ¨Åned in JDK are a safer contextfor lambdas. For those lambdas passed to built-in APIs, wefurther dissect the distributions of speciÔ¨Åc APIs and show ourresult in Table I. We found that lambdas passed to APIs ofMap#computeIfAbsent and Optional#ifPresent are more
likely to be removed than those passed to other APIs. On thecontrary, lambdas passed to Stream#map and Stream#filter
are less likely to be removed. It is because that the Stream API
was designed to mainly work with lambdas. The manner towrite lambdas in Stream API methods is also well deÔ¨Åned. On
the contrary, Optional was not designed with the functional
programming style instead although it was also introduced inJava 8. Meanwhile, implementing with Optional is some-
times more complex than that with conventional if else
for branch logic processing [25]. For the same reason, Map,
which was introduced since JDK1.2, is not as compatible withlambda expressions as Stream API. Therefore, if developersTable I: APIs that Lambda Expressions Are Passed To
API Removed Kept Difference
Iterable.forEach 13.78% 12.65% 1.13%
Stream.map 8.49% 13.93% -5.44%
Map.computeIfAbsent 7.69% 4.57% 3.12%
Optional.ifPresent 7.05% 2.07% 4.98%
Stream.forEach 5.29% 4.96% 0.33%
Stream.filter 5.29% 14.20% -8.91%
Collectors.toMap 4.49% 4.70% -0.21%
Map.forEach 4.01% 3.50% 0.51%
ExecutorService.submit 3.69% 2.59% 1.10%
Optional.map 3.53% 1.51% 2.02%
IntStream.forEach 2.40% 1.48% 0.92%
intend to call lambda expressions within JDK built-in methodsin the functional programming style, Stream API is a better
choice, and thus lambda expressions used in Stream API are
less likely to be removed in practice.
Finding #3: Lambda expressions that are built on top
of customized functional interfaces, passed to self-deÔ¨Ånedmethod invocations are more likely to be removed.
IV . C
ONCERNS AND ACTIONS OF DEVELOPERS
In this section, we investigated the concerns of the develop-
ers when removing a lambda expression and the migration pat-terns afterwards. SpeciÔ¨Åcally, we analyzed the issue descrip-tions from the issue trackers and commit messages to Ô¨Ågureout the reason why developers remove a lambda expression.On the other hand, we also looked into the code changes ofÔ¨Åxes to explore how developers Ô¨Åx the problem induced bythe improper usages of lambda expressions. To have a deeperunderstanding of the reasons behind the removals of lambdaexpressions, we also communicated with some developers whoremoved lambda expressions in our subjects. Finally, we foundseven common reasons for removing lambda expressions andseven major migration patterns. We present the details of theempirical results as follows.
A. Data Collection
We collect a dataset of issues from the following sources
to understand the reason behind the removal of a lambda ex-
pression and the action taken by developers after the removal.
Apache JIRA. Most Apache open-source projects track
their issues on the JIRA issue tracker. Therefore, we searchthe issues on JIRA using the following query to collect theissue related to lambda expressions.
72status in (Resolved, Closed) AND text Àú "lambda"
The query returned 6,647 items. we further Ô¨Ålter out issues
in which the keyword lambda only appears in stack traces,
and those associated with Python lambda. We obtained 1,175issues afterwards and manually validate them to see whetherthey contain sufÔ¨Åcient information for us to understand thebehind reasons. Finally, 25 issues are kept.
Code Commits. Not all the Ô¨Åxes for improper usage of
lambda expressions are tracked in Apache JIRA. Meanwhile,the associated issues may not use the keyword ‚Äúlambda‚Äù inthe issue summary or description, thus escaping from ourqueries. In this study, we also search the commit messagesof the commits that remove a lambda expression and containscertain keywords (i.e., lambda, bug,Ô¨Åx,issue, Ô¨Åxup, problem,
abuse, error, optimize, etc). Such commits are likely to Ô¨Åx a
problem by removing a lambda expression. We Ô¨Ånally kept 60of such collected commits after manual validation.
GitHub Issues. Apart from JIRA, part of the issues in
our subjects are tracked on GitHub for discussion. Therefore,we searched the GitHub issues of our subjects with keywordlambda and then manually selected the issues containing
sufÔ¨Åcient information. We obtained seven issues in this step.
User Study. We further communicated with developers
asking for the details about the removal of lambda expressions.SpeciÔ¨Åcally, we discussed with developers, who have recentlyremoved lambdas in open-source projects (we automaticallymined such information via monitoring the commit historiesof the 103 projects), on the reason for removing the lambdaexpression, the impacts caused by the lambda expression, andscenarios in which they would avoid using lambda expressions.SpeciÔ¨Åcally, we sent 364 emails to the developers which haverecently removed lambda expressions and got in touch with38 of them, with a response rate of 10.4%. We retained thoseresponses with clear descriptions and got 25 issues included.
In total, we collected 117 issues for exploring the concern
and actions of the developers while removing lambda expres-sions, including 25 from Apache JIRA, 60 from code commits,seven from GitHub issues, and 25 from User Study.
B. Analysis Approach
For the collected data collection, we performed a process
similar to open coding [26] to identify common reasons for
removing lambda expressions as well as the migration patterns.For data collected from Apache JIRA, Code Commits , and
GitHub Issues, we read the descriptions of the issues orcommit messages to understand the reason for the removal.For data collected in the user study, we extract the removal
reasons from email replies. Besides, we read the code difffor all the data to Ô¨Ånd common migration patterns. In theclassiÔ¨Åcation process, two authors inspected and labeled thedataset independently and they discussed with each other toreach a consensus when there is a conÔ¨Çict.
After the analysis, we summarized the results of our quali-
tative study in this Section from two perspectives: the reasons
why such lambdas are deemed as misused and the associatedimpacts, and the migration patterns adopted by developers to       "!!	 !"	
!	

 

Figure 7: Reasons of Removing Lambda Expressions
replace such removed lambdas. We present our results in thefollowing two subsections.
C. Reasons for Misusing Lambda Expressions
We summarized seven major reasons (with over Ô¨Åve cases
for each reason) that why lambdas are deemed as misused
by developers and the associated impacts. Figure 7 shows thestatistics and we present the details as follows:
Performance Degradation (29/117). Performance degrada-
tion is one of the most crucial reasons that why developersremove lambda expressions. SpeciÔ¨Åcally, nearly 25% of thelambdas in our study are removed since their usages intro-duced performance issues. Such lambdas will be removedif such side effects are signiÔ¨Åcant and perceived by devel-opers. The most common inappropriate lambda usages thatcause performance issues is invoking lambdas in computation-critical code, especially for captured lambdas which accessvariables outside the lambda body. For captured lambdaswith multiple invocations, although the lambda class is onlycreated once on the Ô¨Årst invocation, each invocation willcreate a new lambda instance. This may introduce excessiveobject allocations and bring signiÔ¨Åcant pressure to the garbagecollector. Therefore, a developer in Apache Lucene removedsuch lambdas to avoid memory allocation for each invocationofcollectValFirstPhase [27]. Furthermore, as shown in
Listing 1, the lambda expression will hold a reference to theirenclosure instance when it accesses the enclosing instance‚Äôsnon-static Ô¨Åelds and methods, thus causing memory leaks.
Actually, the new Java 8 API methods (i.e., Collections,
Stream, and Optionals) can also introduce performance
differences when they are used with lambdas. Although it isstill controversial whether the performance of using lambdaswith such Java 8 API methods is worse than their counterpartimplementations in diverse scenarios [2]. There are many realissues which refactor these usages into conventional ways (i.e.,for loop, do while, enhanced for loops, if else, etc)
due to the excessive CPU cycles and non-trivial memoryallocation overhead based on performance test results [28].
Poor Readability (28/117). Poor readability is another
important reason for lambda removals in our dataset. Suchlambda expressions usually have a long body or containcomplex logic, setting obstacles for developers to understandthem. Worse still, lambda expressions are anonymous, andthus the intention of a lambda expression is far more difÔ¨Åcultto understand than a method. Besides, the syntax of lambdaexpressions looks less compact than that of method reference.
731- .collect(Collectors.groupingBy(url -> { ... }));
2+ .collect(Collectors.groupingBy(this::judgeCategory));
3+ private String judgeCategory(URL url) {
4+ // The same as the lambda body
5+}
Listing 2: Replacing a Lambda with a Method to Improve
Readability (Commit#9e9517d, Project Dubbo)
1- .apply(o -> Collections.emptyList());
2+ .apply(
3+ new MultimapView() {
4+ @Override public Iterable get() { ... }
5+ @Override public Iterable get(Object o) { ... }
6+ });
7
8 public interface MultimapView<K, V> {
9+ Iterable<K> get();
10 Iterable<V> get(@Nullable K k);
11 }
Listing 3: Switching from Lambda to Anonymous Class for
Better Extensibility (PR#10147, Project Beam)
Therefore, developers sometimes tend to remove lambda ex-
pressions to improve readability as well as make the codemore compact. For example, in Listing 2, developers in projectDubbo replaced a lambda containing more than 10 lines of
code with a method to make it more readable as shown in thedescription: simplify ‚Äúcollect‚Äù body to make it more readable.
Our Ô¨Ånding is also conÔ¨Årmed by developers in the user studyas a developer in project Apache Calcite [6] mentioned that:
‚ÄúI generally dislike long lambdas due to bad readability.‚Äù
Serialization Issues (16/117). There are 16 lambda expres-
sions in our dataset that are removed due to serialization issues.Since Java 8, one can make a lambda expression serializableby extending Serializable in its corresponding functional
interface. Serializing lambdas can be used for persisting con-
Ô¨Åguration, or as a visitor pattern to remote resources [29].
However, this is strongly discouraged according to the JavaLanguage SpeciÔ¨Åcation [30] because the serialization behaviorof synthetic class (what will be created when compiling alambda expression) can vary among JVM implementations,which can cause compatibility issues when the bytes serializedon one JVM are shipped to another JVM to deserialize, andvise versa. For instance, a developer successfully serializeda lambda and shipped the byte code via RemoteGraph to aremote server, but can not deserialize it on the new server [31].
Poor Extensibility (13/126). During code evolution, func-
tional interfaces can be evolved to accept no lambda anymore. In this case, a lambda expression is no longer acceptedwhen an object implementing such interfaces is required.Therefore, developers need to switch from lambda expressionsto anonymous classes for better extensibility. Listing 3 showsan example in project Beam. As shown in the code change,
a new method get() is added to inference MultimapView
and thus it is no longer a functional interface. To this end,developers replaced the lambda expression with an anonymousclass to make the code syntactic correct. Similarly, 13 suchcases are observed in our dataset.
Type Inference Failure (11/117). We observed 11 cases1- HasDisplayData subComponent = builder ->
2- builder.include("b", builder1 -> builder1.add(...));
3+ HasDisplayData subComponent = new HasDisplayData(){
4+ @Override
5+ public void populateDisplayData(Builder builder){
6+ builder.include("b", new HasDisplayData(){
7+ @Override
8+ public void populateDisplayData(Builder builder){
9+ ...
Listing 4: Replacing Lambda Expressions with AnonymousClasses (Commit#aedb4c8, Project Beam)
1@groovy.transform.CompileStatic
2java.lang.ClassCastException:
3 ThisTest$_m_lambda1 cannot be cast to ThisTest
4 at ThisTest$_m_lambda1$_lambda2.doCall(TS4.groovy:9)
5 at ThisTest$_m_lambda1.doCall(TS4.groovy:11)
6 at ThisTest.m(TS4.groovy:13)
7 at ThisTest$m.call(Unknown Source)
Listing 5: Stack Trace Related to Lambdas in GROOVY-9341
in our dataset where lambda expressions are removed toresolve type inference failures. As mentioned in Section II,the type information in a lambda expression can be omittedand inferred by the compiler. However, there are cases wherethere is no sufÔ¨Åcient contextual information for the compilerto infer the type, thus causing a compilation error. Listing 4shows an example in project Beam where developers replaced
two nested lambda expressions with anonymous classes to ‚ÄúÔ¨Åx
of some call sites where lambdas mess up coder inference‚Äù,as mentioned in the commit message.
Maintenance Issues (6/117). Apart from technical issues,
lambda expressions can also be removed due to human fac-tors (i.e., causing maintainability issues or inconsistent codestyles). Listing 5 shows a stack trace when debugging a codesnippet with lambda expressions in project Groovy. The names
of the stack frame related to lambda expressions are hardfor developers to recognize, which makes debugging coderelated to lambda expressions difÔ¨Åcult. Besides, the stacktraces for those lambdas used together with the new Java API 8methods are even more complex. For instance, as mentionedby a developer in our user study, ‚ÄúThey are often annoyingwhen debugging step by step inside an IDE compared toimperative programming. Especially in cases like this: col-lection.stream().Ô¨ÇatMap(...).Ô¨Ålter(...).map(...).collect(...).‚Äù.
Lazy Evaluation (5/117). One key feature of lambda expres-
sions is that they are not evaluated when they are deÔ¨Åned, andare actually evaluated when they are called instead. Therefore,lambda expressions are usually used for implementing lazyevaluation, which is delaying the evaluation of an expressionuntil its value is needed, thus avoiding needless calculationsand reducing memory footprints. However, some developersignored the nature of lazy evaluation and used lambda expres-sions in the cases where lazy evaluation is not desired, andthus introduced unexpected behaviors into the program. Forinstance, the code change in Listing 6 shows an inappropriateimplementation of lazy evaluation with lambda expressions.Since Supplier does not have memorization (cache the
result of a function call and return the cached value for the
741- final Supplier<Blackboard> bb = () -> {
2- RexNode sourceRef = rexBuilder.makeRangeRef(scan);
3- return createInsertBlackboard(table, sourceRef,
4- table.getRowType().getFieldNames());
5-} ;
6+ final RexNode sourceRef = rexBuilder.makeRangeRef(scan);
7+ final Blackboard bb = createInsertBlackboard(table,
8+ sourceRef, table.getRowType().getFieldNames());
9...
10- list.add(ief.newColumnDefaultValue(table,
11- f.getIndex(), bb.get()));
12+ list.add(ief.newColumnDefaultValue(table,
13+ f.getIndex(), bb));
Listing 6: Remove the Lazy Initialization Logic for the Black-
board Instance (Commit#22c76fb, Project Calcite)
following calls to save computation costs), each access to the
generated Blackboard instance needs to call method get()
ofSupplier again, thus increasing repeated computations.
Besides, the evaluations of intermediate operations in Stream,
such as map, filter, etc, can also be lazy. Applying these
Stream APIs with lambda expressions performs no operations
until the terminal operation is executed. Consequently, ignor-ing the lazy nature of intermediate operations in Stream may
also introduce problems (i.e., CASSANDRA-13905 [32]).
Others (9/117). Other issues are too speciÔ¨Åc to be sum-
marized into a single category. For instance, lambda expres-sion misuse leads to an ambiguous method call, unhandledexceptions, and so on. These problems are rare because mostof them can be found at compilation time and easily solvedbefore commit.
To summarize, we make the following Ô¨Ånding with respect
to why developers removed lambdas.
Finding #4: Performance degradation and poor readabil-
ity are the most common reasons why developers removelambdas. Lambdas can also be removed due to the natureof lazy evaluation. Besides, they might cause extensibilityand maintenance issues, thus being removed by developers.
D. Common Migration Patterns
We further identify how developers migrate those inappro-
priate usages of lambda expressions. For the collected 117cases, we drop those cases whose corresponding commitsare unavailable, and Ô¨Ånally obtained 104 unique cases forfurther classiÔ¨Åcation. Via investigating the available associatedcommits, we observed seven major code migration patterns(with over Ô¨Åve cases for each pattern), which are summarizedin Table II. Be noted that there may be more than one patternfor each issue. We also analyzed the relationship betweenthe reasons why lambdas got removed and the correspondingmigration patterns, which is shown in Figure 8. Our majorobservations are described as follows:
We observed that the most common migration pattern
(24/104) is to change new Java 8 API methods with lambdaexpressions back to conventional methods. According to ourstatistical results, 14 of such 24 cases are for performanceimprovement. It is because the compiler has well exploredhow to optimize old-fashioned code while the support of# ' $# $' %# %' &#		
!"	 !!"!
	 
     
Figure 8: Correlation between Lambda Removal Reasonsand Migration Patterns. The Number Denotes the MigrationPattern ID as Shown in Table II
performance optimization for new language features such as
Stream API is insufÔ¨Åcient. Therefore, when performance is of
signiÔ¨Åcant concern, developers should be careful when usingthese new Java 8 API methods with lambda expressions.
We observed that it is also common (22/104) to replace
lambda expressions with method references. SpeciÔ¨Åcally, 17of them aim to improve readability, which shows that it is acommon strategy to simplify the code with method references.We have elaborated above that how method references canmake the code more succinct, thus facilitating comprehension.
Besides, in 17 cases, lambda expressions are replaced with
anonymous objects (17/104). Among them, nine are associatedwith poor extensibility of lambda expressions. This conÔ¨Årmsthe intuition that anonymous objects have better extensibilitycompared with lambdas, which is especially important forinterface evolution. Besides, six of the 17 cases are solvingthe serialization and type inference problems since anonymousobjects are more friendly to serialization and type inferencecompared with lambda expressions.
We do not explain other migration patterns summarized in
Table II in detail, and we summarize our Ô¨Åndings as follows.
Finding #5: Lambda expressions that are inappropriately
utilized are often migrated to conventional implementationsusing anonymous class, method reference, inner class in-stance, and so on. Besides, lambdas passed to the new Java8 API methods are often migrated to conventional ones.
E. Actionable Advice for Using Lambda Expressions
Based on the above Ô¨Åndings, together with the responses
from developers in our user study, we are able to make thefollowing actionable advice for Java developers to better utilizelambda expressions in the future.
Avoid using lambdas in performance-critical code. Lamb-
das, especially in frequently invoked methods, can deterioratethe performance of programs, and thus should be refactoredinto implementations whose performance has been better op-timized by the compiler. SpeciÔ¨Åcally, in 29 out of the 117collected issues, lambda expressions are removed for perfor-mance optimizations, some of which explicitly mention in theircommit messages that ‚Äúlambdas are removed for optimization
to reduce object allocations in critical code path‚Äù. Meanwhile,Ô¨Åve developers supported this point in their responses. Forinstance, as suggested by one developer, ‚Äúon a JVM withmemory constraints or in a code base where the streams aregoing to be instantiated a comparable number of times to other
75Table II: Migration Patterns of Removing Lambda Expressions
ID Types Description Frequency
1 Lambda passed to new Java 8 API meth-
ods‚áíConventional methodsReplace new Java 8 API, i.e., Collections ,Stream andOptionals , with conventional for loop ,do
while ,enhanced for loops ,if else , etc.24
2 Lambda‚áíMethod reference Lambda expressions are refactored into method reference to improve readability or performance. In somecases, the lambda body is too large and should be Ô¨Årst extracted into another function and then being invokedwith method reference.22
3 Lambda‚áíAnonymous class Lambda expressions are refactored into anonymous class. 17
4 Lambda‚áíInner class instance The behavior existed in lambda expressions are wrapped into an newly deÔ¨Åned inner class. 10
5 Method with lambdas are replaced with anew method The method to which the lambda expression is passed, no longer exists and is replaced with a new methodwhich does not accept lambdas any more. 6
6 Adding a type cast Adding a type to provide more type information for type inference and overload resolution or implementingSerializable . 6
7 Existing method was changed to accept nolambdas Parameters of the existing method are changed to accept no lambdas any more. The corresponding parametersare either changed to a new one which enclose the behavior of lambda expressions, or deleted (logics inremoved lambdas are implemented in following code).5
1- Optional.ofNullable(securityExtension))
2- .map(Extension::hasAuthenticationMechanisms)
3- .filter(has -> has.equals(true))
4- .ifPresent(has -> Config.getFactory().register(...));
5+ if (securityExtension.hasAuthenticationMechanisms()) {
6+ Config.getFactory().register(...);
7+}
Listing 7: Replacing Lambda in Optionals with if else
(Commit#99d6f10, Project TomEE)
objects one might consider replacing lambdas for normal for
loops to avoid using extra memory resources‚Äù.
Avoid using lambdas with new Java 8 API methods in
branch logic processing. New Java 8 API methods with lamb-
das are unfriendly for branch logic processing. Two lambdaremovals that refactor new Java 8 API methods are caused bysuch a reason. Listing 7 displays an example, which showsthe comparison between the implementation with Optionals
and if else. The former is quite complex and can be easily
refactored to the latter one. Besides, one developer in the userstudy also pointed out that: ‚Äúbranch logic processing is hardto accomplish with existing stream processing mechanisms inJava. The degree of awkwardness to implement certain logicfor me is a criteria for using lambda expressions.‚Äù
Specify the type information in generic settings or over-
loaded methods. Since problems are common for lambda
expressions in overload resolution and type inference, it isbetter to explicitly specify the type information when usinglambdas. Otherwise, it is preferable to use an anonymousobject instead. This has been supported by ten issues andthree developers in our study. One developer responded that‚Äúlambda methods do not provide enough information forautomatic type extraction when Java generics are involved.An easy workaround is to use an (anonymous) class instead.Otherwise, the type has to be speciÔ¨Åed explicitly using typeinformation ‚Äù
Avoid lambdas if you want to throw a checked exception.
Throwing a checked exception in the lambda body is quitetricky, which should be avoided. This has been supportedby two issues in our study and three developers in the userstudy. Throwing a checked exception in lambda bodies isimplemented by either declaring it in the functional interface tothrow this exception, or wrapping the checked exception insideaRuntimeException, and then throw the wrapped unchecked1public void removeHivePluginFrom(Iterable<Drillbit>
2 drillbits) throws PluginException {
3 try {
4 drillbits.forEach(bit ->{
5 try {
6 bit.getContext().getStorage().remove(pluginName);
7 }catch (PluginException e) {
8 throw new RuntimeException("...", e);
9 }
10 });
11 }catch (RuntimeException e) {
12 throw (PluginException) e.getCause();
13 }
14}
Listing 8: Throwing a Checked exception with a Wrapper
1public void removeHivePluginFrom(Iterable<Drillbit>
2 drillbits) throws PluginException {
3 for (Drillbit drillbit : drillbits) {
4 drillbit.getContext().getStorage().remove(name);
5 }
6}
Listing 9: Throwing a Checked Exception with For Loop
exception instead. However, it is sometimes inconvenient tomodify functional interfaces (i.e., built-in functional interface).Using wrappers will perplex the programs, which contradictsthe intention of using lambda expressions to simplify code.Therefore, developers are prone to remove lambda expressionsfor such cases. Listing 8 shows an example as mentioned byone developer from the project Apache Drill [33]. SpeciÔ¨Å-
cally, the remove() method may throw a checked exception:
PluginException. The implementation with enhanced for
loop in Listing 9 is quite simple compared with that using a
wrapper with lambdas as shown in Listing 8.
Avoid constructing large lambdas. For a lambda which is
too large or encapsulates too much logic, it is better to berefactored to facilitate code comprehension. This has been sug-gested by six developers in the responses towards the scenariosthey would avoid using lambda expressions. As mentioned byone developer, ‚Äúa lambda expression encapsulates too muchlogic, and it would be easier to follow the code if broken outinto a named function, or refactored some other way.‚Äù
V. T
HREA TS TO VALIDITY
This study can suffer from the following threats to validity.
First, our collected dataset might contain noise and may not
be generalizable enough. In our dataset, there can be a lambda
76expression that is not removed for Ô¨Åxing an issue because it
is challenging to accurately infer the semantics of all codechanges in large-scale projects. To mitigate this threat, we triedour best to set several rigorous rules to reduce the potentialnoises in our dataset. Besides, our empirical Ô¨Åndings might notbe generalizable to other non-ASF projects since we mainlycollected the removed and kept lambda expressions from theASF open-source projects. To reduce such a threat, we se-lected 103 large-scale open-source Java projects from differentcategories including big data, cloud computing, databases,
mobile application, network client/server, and etc. to ensure
our dataset is diverse and representative enough.
Second, the issues collected for exploring the concerns and
actions of developers may not cover all aspects. To tacklethis problem, we collected our dataset from multiple sources,including Apache JIRA, GitHub Issues, and code commits.Furthermore, we also referred to the mailing lists of oursubjects and communicated with the developers who removedlambdas for further information. Collecting data from varioussources can help enrich the generality of our dataset.
Third, our study mainly focuses on lambda removals, which
may miss issues caused by lambda modiÔ¨Åcations. We chosethose removed lambdas since they are more likely to causeside effects. On the contrary, lambda modiÔ¨Åcations are mostlyassociated with functionality improvement or project main-tenance, which may introduce potential noises if we considersuch cases. However, important issues that are worth exploringcan also be caused by lambda modiÔ¨Åcations, and thus, in thefuture, we will try to devise more sophisticated methods tocollect such data for further studies.
Forth, the side effects summarized in our Ô¨Åndings are not
only caused by the lambda expressions themselves, but alsocan be collectively caused by the lambdas and the surroundingcontexts, such as the Stream APIs, to which the lambdas are
passed as parameters. Since the common usages of lambdasare frequently mixed with these APIs, we take such cases intoconsideration to enrich our scope as explained in Section II-B.To avoid misunderstanding by readers, we differentiate thesyntactic constructs of lambda expressions and the APIs thatrely on them while clarifying our Ô¨Åndings.
VI. D
ISCUSSION AND FUTURE WORK
Lambda Removal Recommender. We have explored a
set of static features for lambdas (see Section III-C) andsummarized several inappropriate ways of lambda usagesalong with common migration patterns (see Section IV-C),which are helpful for constructing automated tools to detectcertain lambda misuses and recommend a more appropriateimplementation instead. For instance, the tool can recom-mend migrating lambda expressions into method referencesfor readability enhancement if these lambdas are too complex(as measured by the features we extracted in the qualitativestudy). Besides, we also found that lambda expressions havea higher probability to cause type inference failures whenthe corresponding functional interfaces are generic. Therefore,the tool can recommend specifying the generic type for suchcases. In the future, we will explore the above ideas and buildautomated tools to facilitate appropriate lambda usages.
Study on more Java Functional Idioms. Along with
lambda expressions, some other functional idioms [8] (i.e.,Collections, Stream, and Optionals) are also introduced
in Java 8 to facilitate functional programming in Java. In thisstudy, we inspected two side-effects of these functional idioms:poor performance, and unfriendly to branch logic processing.Further efforts will be made to comprehensively understandthe advantages and disadvantages of applying these functionalidioms, thus providing more reliable and useful guidance onfunctional programming with Java.
Applicability to other Programming Languages. Lambda
expressions are also supported by other Object-Oriented lan-guages, such as C++, Python, etc. Some side effects thatwe observed in Java lambda expressions also exist in otherprogramming languages. For instance, usages of lambdasin Python can also lead to poor readability when lambdaexpressions are too long [34] or do not have names fordevelopers to understand their functionalities [35]. Therefore,some of our Ô¨Åndings are also applicable to other Object-Oriented languages. It is certain that the characteristics oflambda expressions might be diverse in different languages,while the methodology of our studies including both thequantitative analysis and qualitative analysis can be similarlyadapted to investigate other languages. It is also worth study-ing how functional programming paradigms impact Object-Oriented Programming and the differences among differentOOP languages. However, following existing studies [2], [8],[9], [11], we put our focus mainly on the Java language inthis study, and left the studies across different languages asour important future works.
VII. C
ONCLUSION
Based on our observation that lambda expressions can often
incur side effects or even severe bugs, we are motivated, inthis study, to understand inappropriate usages of lambda ex-pressions in Java. SpeciÔ¨Åcally, we performed a quantitative anda qualitative study in open-source Java projects to investigatethe characteristics of removed lambda expressions as well asthe concerns of developers when removing them. SpeciÔ¨Åcally,we explore four code-level characteristics of lambdas thatare removed by developers, which provide useful informationon the behind reasons. On the other hand, we summarizedseven major reasons for the removal of lambda expressionsalong with the associated migration patterns. Based on all ourÔ¨Åndings, we Ô¨Ånally come up with Ô¨Åve pieces of actionableadvice to help developers free from the side effects of lambdaexpressions as much as possible.
A
CKNOWLEDGMENT
We sincerely thank all anonymous reviewers for their valu-
able comments. This work was supported by the National Nat-ural Science Foundation of China (Grant No. 62002125 andNo. 61802164) as well as the Fundamental Research Fundsfor the Central Universities (HUST) No.2020kfyXJJS076.
77REFERENCES
[1] M. V anags and R. Cevere, ‚ÄúThe perfect lambda syntax,‚Äù Baltic Journal
of Modern Computing, vol. 6, no. 1, pp. 13‚Äì30, 2018. [Online].
Available: https://doi.org/10.22364/bjmc.2018.6.1.02
[2] D. Mazinanian, A. Ketkar, N. Tsantalis, and D. Dig, ‚ÄúUnderstanding
the use of lambda expressions in java,‚Äù Proceedings of the ACM
on Programming Languages, vol. 1, no. OOPSLA, pp. 1‚Äì31, 2017.[Online]. Available: https://doi.org/10.1145/3133909
[3] ‚ÄúLucene-9478,‚Äù 2021, accessed: 2021-4-12. [Online]. Available:
https://issues.apache.org/jira/browse/LUCENE-9478
[4] ‚ÄúApache camel,‚Äù 2021, accessed: 2021-4-12. [Online]. Available:
https://camel.apache.org/
[5] ‚ÄúApache geode,‚Äù 2021, accessed: 2021-4-12. [Online]. Available:
https://geode.apache.org/
[6] ‚ÄúApache calcite,‚Äù 2021, accessed: 2021-4-12. [Online]. Available:
https://github.com/apache/calcite
[7] ‚ÄúStream,‚Äù 2021, accessed: 2021-4-12. [Online]. Available: https:
//docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html
[8] H. Tanaka, S. Matsumoto, and S. Kusumoto, ‚ÄúA study on the current
status of functional idioms in java,‚Äù IEICE Transactions on Information
and Systems, vol. 102, no. 12, pp. 2414‚Äì2422, 2019. [Online].Available: https://doi.org/10.1587/transinf.2019MPP0002
[9] W. Lucas, R. Bonif ¬¥acio, E. D. Canedo, D. Marc ¬¥ƒ±lio, and F. Lima, ‚ÄúDoes
the introduction of lambda expressions improve the comprehension ofjava programs?‚Äù in Proceedings of the XXXIII Brazilian Symposium
on Software Engineering, 2019, pp. 187‚Äì196. [Online]. Available:https://doi.org/10.1145/3350768.3350791
[10] A. Gyori, L. Franklin, D. Dig, and J. Lahoda, ‚ÄúCrossing the gap
from imperative to functional programming through refactoring,‚ÄùinProceedings of the 2013 9th Joint Meeting on Foundations
of Software Engineering, 2013, pp. 543‚Äì553. [Online]. Available:https://doi.org/10.1145/2491411.2491461
[11] A. Alqaimi, P . Thongtanunam, and C. Treude, ‚ÄúAutomatically
generating documentation for lambda expressions in java,‚Äù in2019 IEEE/ACM 16th International Conference on Mining Software
Repositories (MSR). IEEE, 2019, pp. 310‚Äì320. [Online]. Available:
https://doi.org/10.1109/MSR.2019.00057
[12] N. Tsantalis, D. Mazinanian, and S. Rostami, ‚ÄúClone refactoring with
lambda expressions,‚Äù in 2017 IEEE/ACM 39th International Conference
on Software Engineering (ICSE). IEEE, 2017, pp. 60‚Äì70. [Online].
Available: https://doi.org/10.1109/ICSE.2017.14
[13] ‚ÄúMyfaces-4337,‚Äù 2021, accessed: 2021-7-20. [Online]. Available:
https://issues.apache.org/jira/browse/MYFACES-4337
[14] ‚ÄúFlink-18075,‚Äù 2021, accessed: 2021-4-20. [Online]. Available: https:
//issues.apache.org/jira/browse/FLINK-18075
[15] ‚ÄúFlink-20147,‚Äù 2021, accessed: 2021-4-20. [Online]. Available: https:
//issues.apache.org/jira/browse/FLINK-20147
[16] ‚ÄúAsf project list,‚Äù 2021, accessed: 2021-4-12. [Online]. Available:
https://projects.apache.org/projects.html?number
[17] J. Falleri, F. Morandat, X. Blanc, M. Martinez, and M. Monperrus,
‚ÄúFine-grained and accurate source code differencing,‚Äù in ACM/IEEE
International Conference on Automated Software Engineering, ASE‚Äô14, V asteras, Sweden - September 15 - 19, 2014, 2014, pp. 313‚Äì324.[Online]. Available: http://doi.acm.org/10.1145/2642937.2642982[18] ‚ÄúHunks,‚Äù 2021, accessed: 2021-4-12. [Online]. Available: http:
//www.gnu.org/software/diffutils/manual/html
node/Hunks.html
[19] K. Herzig and A. Zeller, ‚ÄúThe impact of tangled code changes,‚Äù
in2013 10th Working Conference on Mining Software Repositories
(MSR). IEEE, 2013, pp. 121‚Äì130. [Online]. Available: https://doi.org/10.1109/MSR.2013.6624018
[20] S. Kim and E. J. Whitehead Jr, ‚ÄúHow long did it take to
Ô¨Åx bugs?‚Äù in Proceedings of the 2006 international workshop on
Mining software repositories, 2006, pp. 173‚Äì174. [Online]. Available:https://doi.org/10.1145/1137983.1138027
[21] Y . Wang, M. Wen, Z. Liu, R. Wu, R. Wang, B. Yang, H. Y u,
Z. Zhu, and S.-C. Cheung, ‚ÄúDo the dependency conÔ¨Çicts in myproject matter?‚Äù in Proceedings of the 2018 26th ACM joint meeting
on european software engineering conference and symposium on thefoundations of software engineering, 2018, pp. 319‚Äì330. [Online].Available: https://doi.org/10.1145/3236024.3236056
[22] K. Pearson, ‚ÄúX. on the criterion that a given system of deviations from
the probable in the case of a correlated system of variables is such that itcan be reasonably supposed to have arisen from random sampling,‚Äù The
London, Edinburgh, and Dublin Philosophical Magazine and Journal ofScience, vol. 50, no. 302, pp. 157‚Äì175, 1900.
[23] H. B. Mann and D. R. Whitney, ‚ÄúOn a test of whether one of two
random variables is stochastically larger than the other,‚Äù The annals of
mathematical statistics, pp. 50‚Äì60, 1947.
[24] ‚ÄúState of the lambda,‚Äù 2021, accessed: 2021-4-12. [Online]. Available:
https://cr.openjdk.java.net/
‚àºbriangoetz/lambda/lambda-state-Ô¨Ånal.html
[25] ‚ÄúIs it worth to use if-else statement as java
optional pattern?‚Äù 2021, accessed: 2021-7-20. [Online].Available: https://codereview.stackexchange.com/questions/223277/is-it-worth-to-use-if-else-statement-as-java-optional-pattern
[26] J. W. Creswell and C. N. Poth, Qualitative inquiry and research design:
Choosing among Ô¨Åve approaches. Sage publications, 2016.
[27] ‚ÄúPr 476, project solr,‚Äù 2021, accessed: 2021-7-20. [Online]. Available:
https://github.com/apache/lucene-solr/pull/476/Ô¨Åles
[28] ‚ÄúCommit f555aa6, project presto,‚Äù 2021, accessed: 2021-7-20. [Online].
Available: https://github.com/prestodb/presto/commit/f555aa69
[29] ‚ÄúHow and why to serialize lambdas?‚Äù 2021, accessed: 2021-7-
20. [Online]. Available: https://dzone.com/articles/how-and-why-to-serialialize-lambdas
[30] ‚ÄúThe java
¬Ælanguage speciÔ¨Åcation,‚Äù 2015, accessed: 2020-10-28.
[Online]. Available: https://docs .oracle.com/javase/specs/jls/se8/html/
index.html
[31] ‚ÄúTinkerpop-1230,‚Äù 2021, accessed: 2021-7-20. [Online]. Available:
https://issues.apache.org/jira/browse/TINKERPOP-1230
[32] ‚ÄúCassandra-13905,‚Äù 2021, accessed: 2021-7-20. [Online]. Available:
https://issues.apache.org/jira/browse/CASSANDRA-13905
[33] ‚ÄúApache drill,‚Äù 2021, accessed: 2021-4-12. [Online]. Available:
https://github.com/apache/drill
[34] ‚Äúlambda function in different lines,‚Äù 2021, accessed: 2021-7-
20. [Online]. Available: https://stackoverÔ¨Çow.com/questions/57969592/lambda-function-in-different-lines
[35] ‚ÄúWhich is more preferable to use: lambda functions or
nested functions (‚Äôdef‚Äô)?‚Äù 2021, accessed: 2021-7-20. [Online].Available: https://stackoverÔ¨Çow.com/questions/134626/which-is-more-preferable-to-use-lambda-functions-or-nested-functions-def
78