One Fuzzing Strategy to Rule Them All
MingyuanWu ‚Ä†
SouthernUniversityof Science and
Technology, Shenzhen, China and the
University of Hong Kong, Hong Kong,
China
11849319@mail.sustech.edu.cnLing Jiang, Jiahong Xiang
SouthernUniversityof Science and
Technology
Shenzhen,China
11711906@mail.sustech.edu.cn11812613@mail.sustech.edu.cnYanwei Huang
ZhejiangUniversity
Hangzhou,China
huangyw@zju.edu.cn
Heming Cui
TheUniversityof Hong Kong
HongKong, China
heming@cs.hku.hkLingming Zhang
Universityof Illinois
Urbana-Champaign,USA
lingming@illinois.eduYuqun Zhang*
SouthernUniversityof Science and
Technology
Shenzhen,China
zhangyq@sustech.edu.cn
ABSTRACT
Coverage-guided fuzzing has become mainstream in fuzzing to
automatically expose program vulnerabilities. Recently, a group of
fuzzers are proposed to adopt a random search mechanism namely
Havoc,explicitlyorimplicitly,toaugmenttheiredgeexploration.
However, they only tend to adopt the default setup of Havocas an
implementation option while none of them attempts to explore its
power under diverse setups or inspect its rationale for potential
improvement. In this paper, to address such issues, we conductthe first empirical study on Havocto enhance the understanding
of its characteristics. Specifically, we first find that applying the
default setup of Havocto fuzzers can significantly improve their
edge coverage performance. Interestingly, we further observe that
even simply executing Havocitself without appending it to any
fuzzercanleadtostrongedgecoverageperformanceandoutper-
form most of our studied fuzzers. Moreover, we also extend the
execution time of Havocand find that most fuzzers can not only
achievesignificantlyhigheredgecoverage,butalsotendtoperform
similarly (i.e., their performance gaps get largely bridged). Inspired
bythefindings,wefurtherpropose Havoc ùëÄùê¥ùêµ,whichmodelsthe
Havocmutation strategy as a multi-armed bandit problem to be
solved by dynamically adjusting the mutation strategy. The evalua-
tionresultpresentsthat Havoc ùëÄùê¥ùêµcansignificantlyincreasethe
edgecoverage by11.1% onaveragefor allthe benchmarkprojects
comparedwith Havocandevenslightlyoutperformstate-of-the-art
QSYM whichaugments itscomputing resourceby adoptingthree
parallel threads. We further execute Havoc ùëÄùê¥ùêµwith three parallel
‚Ä†Mingyuan Wu is also affiliated with the Research Institute of Trustworthy Au-
tonomousSystems,Shenzhen,China.
* Yuqun Zhang is the corresponding author. He is also affiliated with the Research
Institute of Trustworthy Autonomous Systems, Shenzhen, China and Guangdong
Provincial Key Laboratory of Brain-inspired Intelligent Computation, China.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA
¬©2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05 ...$15.00
https://doi.org/10.1145/3510003.3510174threads and result in 9% higher average edge coverage over QSYM
upon all the benchmark projects.
ACM Reference Format:
Mingyuan Wu ‚Ä†, Ling Jiang, Jiahong Xiang, Yanwei Huang, Heming Cui,
LingmingZhang,andYuqunZhang*.2022.OneFuzzingStrategytoRule
ThemAll.In 44thInternationalConferenceonSoftwareEngineering(ICSE‚Äô22),
May 21‚Äì29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3510003.3510174
1 INTRODUCTION
Fuzzing (or fuzz testing) refers to an automated software testing
methodology that inputs invalid, unexpected, or random data to
programs for exposing unexpected program behaviors (such as
crashes, failing assertions, or memory leaks), which can be further
inspected or analyzed to detect potential vulnerabilities/bugs [ 43].
In particular, many existing fuzzers tend to facilitate their vulnera-
bility/bugexposureviaoptimizingcodecoverageofprograms[ 7,
20,33,34,52]. Given an initial collection of seeds, such coverage-
guidedfuzzersusuallydevelopstrategiestoiterativelymutatethem
forgeneratingnew seeds that can trigger higher code coverage.
Notably,anumberofrecentcoverage-guidedfuzzers(e.g.,AFL[ 52],
AFL++[12],MOPT[ 25],QSYM[ 50],andFairFuzz[ 20])integrate
alightweightrandomsearchmechanismnamely Havoc1totheir
respective fuzzing strategies for increasing their code coverage.
Forinstance,weobservethatwhilethemajorfuzzingstrategyof
FairFuzz can explore 12k+ program edges within around 21 hours,
its adopted Havoccan explore 7.8k+ program edges within only
around3hours.Incontrasttomanyexistingfuzzerswhichadopt
only onemutator under eachiterative execution, Havocrandomly
selectsmultiplediversemutators,e.g.,flippingasinglebitandin-
serting/deletingarandomly-chosencontinuouschuckofbytes,and
applies them altogether for generating one seed during each itera-
tion. Typically, under each iteration, Havoccan be integrated with
fuzzerseithersequentially,i.e.,executing Havocupontheseedscol-
lected after executing their major fuzzing strategies, or in parallel,
i.e., executing Havocand their major fuzzing strategies at the same
timein different processes/threads upon their seed aggregation.
1While such mechanism may have different names according to different fuzzing
papers,we adopt HavocfollowingAFL.
*&&&"$.UI*OUFSOBUJPOBM$POGFSFODFPO4PGUXBSF&OHJOFF SJOH	*$4&
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA Mingyuan Wu ‚Ä†, Ling Jiang, Jiahong Xiang, Yanwei Huang, Heming Cui, Lingming Zhang, and Yuqun Zhang*
Although Havochas been widely adopted by existing fuzzers,
they tend to include Havoconly as an implementation option with-
out further investigating its rationale or exploring its potentials.
Forinstance,AFL,AFL++andFairFuzzsimplyadopt Havocasan
additional mutation stage and QSYM utilizes Havocto generate
seeds for its concolic execution to increase code coverage. That
said, they simply adopt Havocunder its default setup, i.e., none
of the prior work attempt to study the impact of different Havoc
settings,exploredifferentwaystointegrate Havoc,orfurtherboost
theHavocstrategyitself.
Inthispaper,weconductthefirstcomprehensivestudyof Havoc
to unleash its potential. In particular, we first collect 7 recent bi-
nary fuzzers and the pure Havoc(i.e., applying Havoconly without
appending it to any fuzzer) as our studied subjects and construct a
benchmarkbycollectingtheirstudiedprojectsincommon.Then,
weconduct anextensivestudy toinvestigate howenabling Havoc
inthestudiedsubjectscanimpacttheirperformance(e.g.,codecov-
erageandbugexposure).Ourevaluationresultsindicatethatfor
allthestudiedfuzzers,appending Havoctothemunderitsdefault
setup can significantly increase their edge coverage upon all the
benchmark projects from 43.9% to 3.7X on average. Meanwhile, we
alsofindthatevendirectlyapplyingthepure Havoconlycanresult
in surprisingly strong edge coverage and significantly outperform
mostofourstudiedfuzzers.Moreover,whiledifferentfuzzerscan
achievequitedivergentedgecoverageresults,applying Havoctothe
studiedfuzzersundersufficientexecutiontimecaningeneralnot
onlysignificantlyincreasetheiredgecoveragecomparedwiththeir
defaultHavocintegration,butalsostronglyreducetheperformance
gapoftheiredgecoveragewhenapplyingtheiroriginalversions.
Lastly,Havoccan also help all the studied fuzzers expose more
uniquecrashesthantheircorrespondingmajorfuzzingstrategies.
Inspired by our findings, we propose an improved version of
HavocnamelyHavoc ùëÄùê¥ùêµ[32]whichmodelsthe Havocmutation
strategy as a multi-armed bandit problem (MAB) [ 45] to be further
solvedbydynamicallyadjustingthemutationstrategy.Theeval-
uation results indicate that under 24-hour execution, Havoc ùëÄùê¥ùêµ
canoutperformthepure Havocsignificantlyby11.1%intermsof
edge coverage on all the benchmarks on average. Havoc ùëÄùê¥ùêµcan
also slightly outperform state-of-the-art QSYM which augments
its computing resource by adopting three threads in parallel. More-
over,wealsodesign Havoc3
ùëÄùê¥ùêµbyexecuting Havoc ùëÄùê¥ùêµwiththree
threads in parallel. The evaluationresult indicates that Havoc3
ùëÄùê¥ùêµ
canoutperformstate-of-the-artQSYMby 9% on average.
To summarize, this paper makes the following contributions:
‚Ä¢Weextensivelystudytheperformanceimpactbyapplying
Havocto a set of studied fuzzers on real-world benchmarks.
‚Ä¢We find that applying Havoccan substantially improve edge
coverage and crash detection for all the studied fuzzers.
‚Ä¢Weproposealightweightapproach Havoc ùëÄùê¥ùêµbasedonour
findings which can boost the pure Havocby 11.1% under
a 24-hour execution, and outperform all the other studied
fuzzers.
2 BACKGROUND
Havocwas first proposed in AFL [ 52] and later further adopted
by many other fuzzers [ 6,7,12,20,25]. While their adoptions ofHavoccan be slightly different, they typically integrate Havocwith
theirmajorfuzzingstrategies(i.e.,thecorefuzzingstrategies)for
theiriterativeexecutions,i.e.,undereachiteration, Havocrepeat-
edly mutates each seed provided by (or aggregated to its own seed
collection from) executing the major fuzzing strategy via apply-
ing multiplerandomlyselectedmutators simultaneously. Figure1
presents the basic workflow of Havoc. For each seed in the seed
corpus,Havocfirst determines the count of its mutations based on
the real-time seed information, e.g., queuing time of seeds and the
existing ‚Äúinteresting‚Äù seed number (i.e., the number of the seeds
which can explore new edges defined by AFL). Next, each time
when mutating a seed, Havocimplements mutator stacking, i.e.,
mutating it by randomly applying multiple mutators (e.g., 15 for
AFL,MOPT, etc.) in order from a set of mutators. Note that Havoc
usuallyenablesamaximumsizeofsuchmutatorstack(e.g.,128for
AFL, MOPT, etc.) and one mutator can thus be selected multiple
timeswhenmutatingagivenseed.Ifthegeneratedmutantis‚Äúin-
teresting‚Äù(i.e.,exploringnewedges),itwillbeincludedasaseed
for further mutations. Havocrepeats such process until hitting the
mutationcount.Accordingly,itsfuzzercanresumetheexecution
of its major fuzzing strategy when needed.
Seed
Mutator StackingHavoc MutationSeed Corpus
 .C
Program  
(llvm-instrument)YESTrigger New Edge? 
gger New Ed
DiscardNOEdge Coverage
Mutant
Unit-7
 Unit-4
 Unit-11
Mutant
Unit-1
 Chunk-3
 Unit-3
Mutant
Chunk-4
 Unit-10
 Chunk-1
Figure 1: The framework of Havoc
Table 1: Mutation operators defined by Havoc
Type Meaning Mutator
bitflipFlip a bit at a random
position.bitflip 1
interesting
valuesSet bytes with hard-coded
interesting values.interest 8
interest 16
interest 32
arithmetic
increasePerformaddition operations.addition 8
addition 16
addition 32
arithmetic
decreasePerformsubtraction operations.decrease 8
decrease 16
decrease 32
random
valueRandomly set a byte to
a random value.random byte
delete
bytesRandomly delete
consecutive bytes.delete chunk bytes
clone/insert
bytesClone bytes in 75%, otherwise
insert a block of constant bytes.clone/insert
chunk bytes
overwritebytesRandomly overwrite the
selected consecutive bytes.overwrite
chunk bytes

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. OneFuzzingStrategyto Rule Them All ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA
2.1 Mutators and Mutator Stacking
Table 1 presents the details of Havocmutators. Note that in the
‚Äúmutator‚Äùcolumn,thenumberfollowedbythemutatornamerefers
tothebit-wisemutationrange.Forinstance, bitflip 1 refersto
flippingonerandombitatarandomposition.Toourbestknowl-
edge,mostfuzzers[ 6,7,12,25,50,52]enableatotalof15mutators
forHavoc.Inthispaper,wecategorizethemintotwodimensions:
unitmutators (labeledinredinTable1)and chunkmutators (labeled
inblue).Ingeneral, unitmutators refertomutatingtheunitsofdata
storage in programs, e.g., bit/byte/word. For example, applying the
bitflip mutator in Table 1 can flip a bit, i.e., switching between 0
and1.Meanwhile, chunkmutators tendtomutateaseedinterms
of its randomly chosen chunk. For instance, the delete bytes
mutator in Table 1 first randomly selects a chunk of bytes in the
seed and then deletes them altogether.
Whilemanyfuzzers[ 15,24,31,33,34]mainlyapplyonemutator
toaseedeachtime, Havocenablesmutatorstackingtostackand
apply multiple mutators on a seed to generate one mutant each
time. Typically, Havocfirst defines a stacking size for the applied
mutatorswhichisusuallyrandomlydeterminedbythepowerof
twotill128,i.e.,2,4,8,...128,foreachmutation.Accordingly, Havoc
can randomly select mutators into the stack where one mutator
can be possibly selected multiple times. Eventually, all the stacked
mutatorsareappliedtotheseedinordertogenerateamutant.Note
thatwhilemost fuzzersuniformlyselectmutatorsfortheir Havoc,
MOPT and AFL++ adopt a probability distribution generated by
ParticleSwarmOptimization[18]for Havocto select mutators.
2.2 Integration
Havoccan be typically integrated with fuzzers in two manners.
Oneisthe sequential manner,i.e.,appending Havocasalatermuta-
tion stage to their major fuzzing strategies. For instance, AFL [ 52]
launches Havocupon the seeds generated after applying its de-
terministicmutationstrategytogeneratemoreseedsundereach
iterative execution. The other is the parallelmanner, i.e., applying
Havocand the major fuzzing strategy of a fuzzer in parallel. For
instance, QSYM [ 50] enables three threads which execute Havoc,
AFLdeterministicmutationstrategy,andconcolicexecution[ 14]
respectively; more specifically, the first two threads are indepen-
dentlyexecutedinparallelandtheirrespectivegeneratedseedsare
continuouslyaggregated to be used for the concolic execution.
WhileHavochas been widely adopted by the aforementioned
fuzzers, it is simply utlized as an implementation option whilenone of the fuzzers has explicitly explored its potential power,
e.g., assessing its mechanism and adjusting its setup. Therefore,
our paper attempts to explicitly investigate Havoc, i.e., extensively
assessing its performance impact to fuzzers and its mechanisms,
forbetterleveragingitspowerandprovidingpracticalguidelines
forfuture research.
3HAVOCIMPACT STUDY
3.1 Subjects & Benchmarks
3.1.1 Subjects. In general, we determine to adopt the following
types of fuzzers as our study subjects. First, we attempt to include
the fuzzers which originally adopt Havocto expose how Havoccan impacttheirperformance bydefault. Next,we alsoattempt to
explore the fuzzers which do not originally adopt Havocbut can
possibly integrate Havocunder appropriate effort. Accordingly, we
can investigate whether and how Havoccan be effective in a wider
range of fuzzers. At last, we also include the pure Havoc, i.e., using
onlyoneseedtolaunch Havocforgeneratingnewseedswithout
appendingittoanyfuzzer,foranalyzinghowthepowerof Havoc
can be unleashed.
Note that while there are many existing fuzzers which can meet
ourselectioncriteriaabove,wealsoneedtofilterthemforselecting
the representative ones. To this end, we first determine to limit
our searchscope within thefuzzers published inthe top software
engineering andsecurity conferences, i.e.,ICSE, FSE, ASE,ISSTA,
CCS, S&P, USENIX Security, and NDSS, of recent years. Further-
more, we can only evaluate the fuzzers when their source code are
fully available and can be successfully executed. At last, it is rather
challengingtointegrate Havocwithcertainpotentialfuzzersdueto
the engineering-/concept-wise challenges. Therefore in this paper,
weonlytargetAFLvariantsduetotheappropriateworkloadsfor
implementing Havocforthem.
Eventually, we select 8 representative fuzzers as our studied
subjects, including 5 fuzzers with Havoc(AFL [52], AFL++ [ 12],
MOPT [25], FairFuzz [ 20], QSYM [ 50]), 2 fuzzers without Havoc
(Neuzz [34], MTFuzz [ 33]) and the pure Havocitself. Note that
such subjects can be rather representative in terms of technical
designs,i.e.,includingAFL-based,concolic-execution-based,and
neuralprogram-smoothing-based fuzzers.
3.1.2 Benchmarkprograms. Weconstructourbenchmarkbasedon
theprojectscommonlyadoptedbytheoriginalpapersofourstudied
fuzzers[20,25,33,34,50].Inparticular,weselect12frequentlyused
projects out of the papers to form our benchmark for evaluation.
Morespecifically,wefirstselectall6projectsthatareadoptedbyat
least 3 papers; then, we further randomly select another 6 projects
whichare adoptedbyoneortwo papers.Theselectiondetails are
presented in our Github page [ 32]. Table 2 presents the statistics of
our adopted benchmarks. Specifically, we consider our benchmark
to be sufficient and representative due to following reasons:
(1)These12benchmarkprojectscover7differentfileformats
forseed inputs, e.g., ELF,JPEG, and TIFF;
(2)The sizes of these programs that range from 1,885 to over
120KLoCcanrepresentawiderangeofprogramsinpractice;
(3)Theycoverdiversefunctionsincludingdevelopmenttools
(e.g.,readelf,objdump),codeprocessingtools(e.g.,tiff2bw),
graphicsprocessingtools(e.g.,djpeg),networkanalysistools
(e.g., tcpdump), etc.
3.2 Evaluation Setups
Our evaluations are performed on ESC servers with 128-core 2.6
GHz AMD EPYC‚Ñ¢ ROME 7H12 CPUs and 256 GiB RAM. The
serversrunonLinux4.15.0-147-genericUbuntu18.04.Theevalu-
ations that involve deep learning model training (i.e., Neuzz and
MTFuzz)are executed with four RTX 2080ti GPUs.
We strictly follow the respective original procedures of the
studied fuzzers to execute them. Specifically, we set the overall
execution time budget for each fuzzer 24 hours following prior
works[6,7,19,20,33,34].Notethatweruneachexperimentfive

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA Mingyuan Wu ‚Ä†, Ling Jiang, Jiahong Xiang, Yanwei Huang, Heming Cui, Lingming Zhang, and Yuqun Zhang*
Table 2: Statistics of the studied benchmarks
ProgramsLOCPackage Target Class
readelf ELF 72,164
nm ELF 55,307
binutils-2.36 objdump ELF 74,532
size ELF 54,429
strip ELF 65,432
libjpeg-9c djpeg JPEG 9,023
tcpdump-4.99.0 tcpdump PCAP 46,892
libxml2-2.9.12 xmllint XML 73,320
libtiff-4.2.0 tiff2bw TIFF 15,024
mupdf-1.18.0 mutool PDF 123,575
harfbuzz-2.8.0 harfbuzz TTF 9,847
jhead-3.04 jhead JPEG 1,885
times for obtaining the average results to reduce the impact of
randomness. Notably, all the studied fuzzers are executed with
the programs based on AFL instrumentation to collect the run-
timecoverageinformation.Tothisend,weapplytheAFL(v2.57)
llvm-mode (llvm-8.0) to instrument the source code during com-
pilation. We also follow the instructions mentioned in previous
work [11,17,19,20,41] to construct initial seed corpus. In particu-
lar,wecollectinitialseedsfor libjpeg,libtiffandjheadfrom
AFL official seed corpus [ 53] and for the rest projects from their
own test suites.
Weadopttheedgecoveragetoreflectcodecoveragewherean
edge refers to a transition between program blocks, e.g., a condi-
tionaljump.Wethenmeasureitviatheedgenumberderivedbythe
AFLbuilt-intoolnamed afl-showmap ,whichhasbeenwidelyused
asaguidancefunctionbymanyexistingfuzzers[ 8,20,33,34,50].
Note that the AFL authors also refer to such metrics as ‚Äúa better
predictor of how the tool will fare in the wild‚Äù [51].
3.3 Research Questions
We investigate the following research questions for extensively
studying Havoc.
‚Ä¢RQ1:Howdoesthedefault Havoc,i.e.,thedirectapplication
ofHavocwithoutmodifyingitssetupormechanism,perform
on different fuzzers? For thisRQ, we attempt to investigate
the performance impact of the default Havocused in the
studied fuzzers.
‚Ä¢RQ2:Howdoes Havocperformondifferentfuzzersunder
diverse setups? For this RQ, we investigate the performance
impactof Havocbyenabling Havocinthestudiedsubjects
underdifferent execution time setups.
3.4 Result Analysis
3.4.1 RQ1:performanceimpactofthedefaultHavoc. Wefirstinves-
tigatetheimpactofthedefault Havoconthefuzzerswith Havoc.As
mentioned in Section 2.2, there can be typically two default setting
types for integrating Havocto fuzzers. For many fuzzers which
appendHavocas a later fuzzing strategy to their major fuzzing
strategies under each iterative execution, Havocis launched upon
the termination of their major fuzzing strategies and terminated
after hitting the mutation count determined at runtime (illustratedinSection2)withoutanyspecificexecutiontimecontrolbydefault.
Asaresult,wecaninferthattheexecutiontimeofthedefault Havoc
cannot bedeterministic. Onthe other hand,for thefuzzers which
executeHavocand their major fuzzing strategies in parallel, the
defaultHavocisusuallyexecutedallalongundertheexecutiontime.
Therefore,itsexecutiontimecanbetypicallyequaltotheoverall
executiontime.Figure2presentstheexecutiontimedistribution
ofallthestudiedfuzzersunderthetotalexecutiontime24hours
(notethatNeuzzandMTFuzz,markedinred,donothavethe Havoc
stagebydefault,andwillbediscussedlater).Wecanobservethat
whileAFL,AFL++,andFairFuzzallowquitelimitedtotalexecution
time ofHavocby default (i.e., from 0.79 hour to 3.09 hours), MOPT
and QSYM allow much longer execution time for Havoc. Note that
the default setting of QSYM utilizes three threads including the
defaultHavoc.ThusHavocisexecutedinQSYMforthewhole24
hoursas mentioned in Section 2.2.
Havoc
AFL
AFL++
Fairfuzz
MOPT
Neuzz
MTFuzz
QSYM
0 0.25 0.5 0.75 1
Magor Fuzzing Strategy Havoc0.0393(0.94 h)
0.0328(0.79 h)
0.1288(3.09 h)0.6789(16.3 h)1.0000(24.0 h)
0.1063(2.25 h)
0.0833(2.00 h)
1.0000(24.0 h)
Figure 2: Execution time distribution within 24 hours
We first study the Havocimpact on the five fuzzers with Havoc.
Specifically,wecreatetheirvariantsbydeleting Havocfromtheir
original implementations, i.e., only retaining their major fuzzing
strategies. Table 3 presents the edge coverage results of the five
fuzzerswith Havocintermsoftheirmajorfuzzingstrategies(repre-
sentedas ‚ÄúMajor‚Äù)and theoriginal implementations(represented
as‚ÄúOriginal‚Äù)respectively.Generally,wecanobservethattheedge
coverageofallthestudiedfuzzersdecreasesignificantlyafterdelet-
ingHavocfrom their implementations averagely, i.e., 9.7% in AFL,
27.0% in AFL++, 32.2% in FairFuzz, 79.4% in MOPT, and 62.2% in
QSYM. Combining Figure 2, we can further infer that the 79.4%
edge coverage decrease for MOPT is caused by reassigning 16.3
hours (67.9% of all time budget) originally spent on Havocto its
majorstrategy;the62.2%edgecoveragedecreaseofQSYMiscaused
by excluding the thread executing Havoc. Even for AFL and AFL++
which executes their Havoconly less than 1 hour, excluding Havoc
decreases 9.7% in AFL and 27.0% in AFL++ in terms of edge cover-
age. All such facts indicate that Havoccan significantly increase
theedge coverage over the major fuzzing strategies.
We also attempt to append the default Havocinto the fuzzers
withoutHavoc, i.e., Neuzz and MTFuzz, and further investigate
howthedefault Havoccanimpacttheiredgecoverageperformance.
Specifically,theirintegrationfollowsthesequentialpatternadopted
by many existing fuzzers mentioned in Section 2.2, i.e., appending
Havocafter executing the original fuzzing strategies of Neuzz and
MTFuzzundereachiterativeexecution.Therefore,theexecution
time of the default Havocadopted by them cannot be deterministic.
In particular, their execution time distributions are presented in

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. OneFuzzingStrategyto Rule Them All ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA
Table 3: The edge coverage performance of fuzzers with Havoc
ProgramsAFL AFL++ FairFuzz MOPT QSYM
Original Major Original Major Original Major Original Major Original Major
readelf 12,112 11,598 9,844 8,268 36,372 20,184 67,505 8,006 69,597 15,984
nm 7,188 6,004 6,049 5,563 16,456 10,627 23,159 5,413 30,359 8,024
objdump 13,748 13,154 13,473 11,829 24,204 16,246 38,027 11,698 41,097 13,439
size 8,262 8,904 4,205 3,643 16,547 10,503 19,172 3,593 23,700 8,459
strip 15,310 14,938 12,116 9,425 26,622 20,870 37,318 9,814 46,633 16,287
djpeg 5,388 7,756 5,474 3,174 10,405 7,782 15,805 3,222 19,295 7,980
tcpdump 14,972 7,192 5,294 1,758 18,457 11,130 44,275 2,477 45,804 16,385
xmllint 18,189 15,314 15,986 13,955 28,174 14,817 49,618 13,632 46,538 20,635
tiff2bw 5,372 5,658 3,767 3,127 8,834 6,340 8,707 3,148 9,301 6,984
mutool 11,529 10,064 11,028 5,677 14,430 10,397 17,438 5,867 17,827 13,653
harfbuzz 21,713 20,513 16,411 9,651 29,939 27,262 54,178 10,365 59,270 26,574
jhead 1,012 636 1,057 404 1,114 633 1,127 452 4,516 2,047
Average 11,233 10,144 8,725 6,373 19,269 13,066 31,361 6,474 34,495 13,038
Table 4: The impact of Havocon Neuzz and MTFuzz
ProgramsPure
HavocNeuzz MTFuzz
OriginIntegrationOriginIntegration
Havoc Major Havoc Major
readelf 73,478 43,040 18,530 27,699 40,594 13,967 31,220
nm 20,696 16,002 8,617 12,469 20,863 9,841 12,745
objdump 37,401 29,155 14,619 18,661 25,369 12,057 18,784
size 17,634 13,228 6,191 8,040 12,256 8,593 6,686
strip 38,200 29,767 16,117 18,959 28,981 14,098 22,884
djpeg 16,142 15,805 12,861 8,549 7,640 7,432 5,142
tcpdump 43,482 17,216 20,704 5,755 14,067 19,237 9,727
xmllint 49,269 28,213 15,891 21,386 27,682 14,228 24,692
tiff2bw 8,516 9,168 3,174 6,016 7,254 2,088 5,806
mutool 17,014 15,560 5,171 13,196 14,391 3,976 12,961
harfbuzz 50,549 38,726 12,548 30,191 41,691 15,203 33,742
jhead 1,132 1,078 705 407 992 698 400
Average 31,126 21,413 11,261 14,277 20,148 10,118 15,399
Figure 2 where Neuzz spends 2.25 hours and MTFuzz spends 2
hourson executing the default Havoc.
Table 4 presents the edge coverage results where ‚ÄúOrigin‚Äù refers
to the original versions of Neuzz and MTFuzz, while ‚ÄúIntegration‚Äù
referstoNeuzzandMTFuzzintegratedwith Havoc.Wecanobserve
that overall, for the new integrated version, Havoccan achieve
78.9%/66.0%higher edgecoverage thanthe majorfuzzing strategy
of Neuzz/MTFuzz on average. Moreover, the integrated fuzzers can
achieve rather significant performance gain, i.e., 19.3% over the
original Neuzz and 26.6% over the original MTFuzz. To summarize,
wecanderivethatforallthestudiedfuzzers(nomatteroriginally
integratedwith Havocornot),appendingthedefault Havoctothem
cansignificantlyenhancetheirmajor/originalfuzzingstrategies.
Finding1:ApplyingHavocbythedefaultsetupcansignifi-
cantlyimprovetheedgecoverageperformanceofthestudied
fuzzers.
Interestingly, we can find from Table 4 that the pure Havoc, i.e.,
using only one seed to launch Havocand executing it all along
withoutappendingittoanyfuzzer,preformsratherstronginterms
of edge coverage, i.e., 31K+ edges on average on all the benchmark
projects. More specifically, thepure Havoccan significantlyoutper-
form most of the studied fuzzers, e.g., 177% over AFL, 257% over
AFL++,45%overNeuzz,whileobtainingcloseperformancewith
MOPTandQSYM.Notethatwhilewecandefinitelyenablemultiple
ways,e.g.,applyingmorethanoneseed,tolaunchtheexecutionofthe pureHavoc, the fact that using one seed can already achieve
such superior performance can be a strong evidence that Havoc
itselfis a powerful fuzzer.
Finding 2: Havoc is essentially a powerful fuzzer‚Äîexecuting
Havocunderoneseedwithoutbeingappendedtoanyfuzzer
forsufficienttimecanalreadyachievesuperioredgecoverage
over many existing fuzzers.
Wetheninvestigatethecorrelationbetweentheedgecoverage
performance and the execution time of Havoc. We can observe
thatwhileMTFuzz,QSYM,andthepure Havoccanachievemuch
strongeredgecoverageovertheotherfuzzersaccordingtoTables3
and 4, they also have longer execution time for Havocas shown in
Figure2.Morespecifically,therankingoftheedgecoverageperfor-
mancecanalmoststrictlyalignwiththerankingoftheexecution
time ofHavocamong all the studied fuzzers (except for Neuzz and
FairFuzz). Therefore, we can infer that for most fuzzers, executing
Havocfor longer timepotentially results in higher edge coverage.
Finding 3: ExecutingHavoc for a longertime upon a fuzzer
canpotentiallyresultinstrongeredgecoverageperformance.
3.4.2 RQ2:performanceimpactofHavocunderdiversesetups. In-
spiredbythepreviousfindings,weattempttofurtherinvestigate
theperformanceimpactof Havoconthefuzzersunderdiverseex-
ecutiontimesetups.Specifically,whileimplementingthedefault
Havocdoes not concern its execution time, executing Havocunder
diverseexecutiontimesetupsessentiallydemandsthemodifiedim-
plementation of integrating Havocto the fuzzers (i.e., the modified
Havoc).
Implementation. Notethatinthispaper,wefirstmodifythe
implementationforintegrating Havoctofuzzersinthesequential
manner.Tobeginwith,itisessentialtofigureouthowtocontrol
the execution time of the major fuzzing strategy and Havocof a
fuzzer. Specifically, our insight is to retain the fuzzing states of the
major fuzzing strategy and Havocwhen they are halting. To this
end, while realizing such insight by directly integrating the source
codeofHavocintodifferentfuzzersessentiallydemandssubstantial
engineering effort, we decide to adopt socketprogramming [ 46]
as an alternative solution, which can execute the major fuzzing
mechanism and its appended Havocin different processes since its

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA Mingyuan Wu ‚Ä†, Ling Jiang, Jiahong Xiang, Yanwei Huang, Heming Cui, Lingming Zhang, and Yuqun Zhang*
Table 5: Edge coverage results of fuzzers with modified Havoc
Programs Havoc QSYMAFL AFL++ FairFuzz MOPT Neuzz MTFuzz
Orig New Orig New Orig New Orig New Orig New Orig New
readelf 73,478 69,597 12,112 73,842 9,844 72,766 36,372 71,689 67,505 73,175 43,040 70,358 40,594 69,824
nm 20,696 30,359 7,188 21,398 6,049 25,259 16,456 21,537 23,159 26,602 16,002 22,258 20,863 24,387
objdump 37,401 41,097 13,748 36,775 13,473 35,004 24,204 35,802 38,027 37,358 29,155 35,739 25,369 36,203
size 17,634 23,700 8,262 17,296 4,205 18,393 16,547 18,118 19,172 18,707 13,228 16,121 12,256 17,395
strip 38,200 46,633 15,310 37,136 12,116 37,419 26,622 37,724 37,318 40,006 29,767 35,147 28,981 37,548
djpeg 16,142 19,295 5,388 18,543 5,474 15,628 10,405 14,660 15,805 18,127 15,805 23,420 7,640 15,962
tcpdump 43,482 45,804 14,972 40,581 5,294 41,178 18,457 40,407 44,275 44,394 17,216 39,687 14,067 42,317
xmllint 49,269 46,538 18,189 45,869 15,986 46,379 28,174 45,004 49,618 47,190 28,213 45,985 27,682 47,365
tiff2bw 8,516 9,301 5,372 8,093 3,767 7,645 8,834 8,204 8,707 8,083 9,168 9,260 7,254 8,671
mutool 17,014 17,827 11,529 17,325 11,028 17,280 14,430 17,065 17,438 17,504 15,560 19,438 14,391 18,554
harfbuzz 50,549 59,270 21,713 56,058 16,411 52,451 29,939 50,619 54,178 59,314 38,726 51,498 41,691 52,964
jhead 1,132 4,516 1,012 1,129 1,057 1,124 1,114 1,123 1,127 1,133 1,078 1,127 992 1,134
Average 31,126 34,495 11,233 31,170 8,725 30,877 19,296 30,163 31,361 32,633 21,413 30,836 20,148 31,027
Table 6: Average edge coverage results under different execution time setups
SetupAFL ‚Ñéùëéùë£ùëúùëê AFL++ ‚Ñéùëéùë£ùëúùëê FairFuzz ‚Ñéùëéùë£ùëúùëê MOPT ‚Ñéùëéùë£ùëúùëê Neuzz ‚Ñéùëéùë£ùëúùëê MTFuzz ‚Ñéùëéùë£ùëúùëêTotal Iteration
1h 31,170 30,877 30,163 32,633 30,836 31,027
24h 2h 30,451 31,069 30,853 31,465 31,259 31,265
4h 30,315 30,541 31,296 32,354 31,462 31,472
12h 30,567 30,247 30,543 31,764 30,975 30,865
built-inblockingmechanismcanprovidethe‚Äúwakeup‚Äùfunction
for both monitoring the execution time of an event given its preset
timeout and retaining the fuzzing states while halting. Note that
suchsolutioncanbequiteconsistentwithasingle-processfuzzerin
terms of CPU resource consumption. Specifically in the beginning,
weexecutethemajorfuzzingstrategyofafuzzerfortimeduration ùë°
to generate new seeds. Subsequently, we transmit the file names of
thegeneratedseedsto Havocbysocket.Aftercompletingthewhole
seed transmission, Havocis executed for time duration ùë°as well
while the execution of the original fuzzing strategy is paused. Note
thatinsteadofdynamicallysettingamutationcountforcontrolling
itsexecutionasthedefault Havoc,ourmodified Havociteratively
generates new seeds based on the updated collection of the ‚Äúin-
teresting‚Äùseedswithintimeduration ùë°.Similarlyafterexecuting
Havoc, we transmit the file names of its generated seeds to the
original fuzzing strategy of the fuzzer via socketfor further seed
generations. Such process is iterated until hitting the total time
budget.
Evaluation. We first evaluate Havocby setting the iterative
time duration ùë°of the major fuzzing strategy/ Havocas 1 hour (i.e.,
executing them for 1 hour respectively under each iteration). As a
result, for each fuzzer, its modified Havoccan be executed within a
total of 12 hours under our 24-hour budget. Table 5 presents the
evaluationresultsofthefuzzerswithandwithoutapplyingsuch
modified Havocwhere ‚ÄúOrig‚Äù represents the original fuzzers with
their default implementation and‚ÄúNew‚Äù represents the associated
fuzzer integrated with the modified Havoc. Note that since such
setupdoesnotfitfortheessentialmechanismsofthepure Havoc
and QSYM which execute Havocfor the whole execution, i.e., 24
hours, we retain their results of the previous evaluations in Table 5
simplyforillustrationandcomparison.
We can observe that while MOPT with the modified Havoccan
incur quite close edge coverage compared with its default Havocintegrationas in Table 3, the rest fuzzerswith the modified Havoc
can achieve much higher edge coverage compared with their orig-
inal versions, e.g., 1.8X for AFL. Such result can further validate
our Finding 3. Specifically, the original MOPT can already incur
quite long execution time for Havocby default, i.e., 16.3 hours,
and thus can result in rather strong edge coverage. On the other
hand, the execution time of Havocfor the other fuzzers turns to
bemuchlongerwithournewhybridstrategy,andthusresultsin
a significant performance gain. Note that for the fuzzers which
originally adopts no Havoc(i.e., Neuzz and MTFuzz), their edge
coverageperformancecanalsobesignificantlyimprovedcompared
with theiroriginalversions.
Moreinterestingly,wecanfindthatformostfuzzers,theycan
incur quite close edge coverage with the modified Havocon all the
benchmark projects averagely, i.e., around 31K. Moreover, their
project-wise performance can be quite close as well, e.g., around
71Kinproject readelfand38Kinproject objdump.Comparedwith
theedgecoveragefromtheiroriginalversions,theirperformance
gaps are significantly reduced. To illustrate, we adopt the STD
(Standard Deviation) of the average edge coverage for the studied
fuzzers.Specifically,theSTDofallthefuzzerswithournewstrategy
for integrating Havocis 819 compared with that of 8,879 when
using their default strategies for integrating Havoc, while their
average edge coverage is 31,118 compared with 20,278. Such result
canindicatethatbyexecuting Havocforsufficienttime,theedge
coverage performance gaps of different fuzzers can be significantly
reduced.Ontheotherhand,whiletheperformanceofmanystudied
fuzzers are significantly improved by extending the execution time
ofHavocinasequentialmanner,theirperformanceareratherclose
to the pure Havoc. Such factsindicate that Havoccanpotentially
dominatemanyfuzzersin terms of edge coverage.
Wealsoincludeblockcoveragerate(i.e.,thenumberofaccessed
basicblocksdividedbythetotalnumberofbasicblocks)[ 23,50]to

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. OneFuzzingStrategyto Rule Them All ICSE ‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA

    	
   	

Figure3:Blockcoverageofdifferentfuzzerswithmodified
Havoc
strengthen our findings. We can observe in Figure 3 that almost all
the studied fuzzers significantly increase block coverage compared
with their original implementations, e.g., 42.7% for AFL, and 26.9%
forMTFuzz.Moreover,allthestudiedfuzzersachievequiteclose
blockcoverageratesafterintegrating Havocwiththeaverageblock
coverage rate of 18.7% and STD of 0.00465, which are consistent
withtheedge coverage trends.
Finding 4: Executing Havoc for sufficient time can dominate
the performance of the studied fuzzers and significantly
reduce their performance gaps.
We further attempt to investigate how changing the integration
mode ofHavocwith fuzzers can impact their edge coverage perfor-
mance.Tothisend,wefirstenablediversesetupsoftheiterative
time duration ùë°ofHavocin terms of 2 hours, 4 hours, and 12 hours
under the total execution time of 24 hours. Table 6 presents the
evaluation results under such setups. We can observe that overall,
there is no significant performance difference under all the setups.
Specifically,thelargestgapoftheaverageedgecoverageofagiven
fuzzer is only 3.76%. Such fact can indicate that the edge coverage
performance is somewhat resilient to time duration ùë°, i.e., under
sufficienttotalexecutiontime,adaptingtheexecutiontimeof Havoc
under each iteration results in rather limited impact on the edge
coverage of the associated fuzzer.

	  	 
 	  
Figure 4:Edge coverageof different fuzzerswith thehybrid
integrationof HavocFinding 5: As long as the total execution time of Havoc is
fixed,howtoadaptitsiterativeexecutioncanhavelimited
impactontheedgecoverageperformanceoftheassociated
fuzzer.
While the performance gaps between different fuzzers can be
significantlyreducedbyapplyingthemodified Havoc,QSYMcan
still outperformthe other fuzzers by at least 10%. Accordingly, we
hypothesizethatexecutingmultiplefuzzingstrategiesinparallel
canbepotentiallymoreadvancedinboostingedgeexploration.We
then attempt to validate such hypothesis by also adopting addi-
tionalthreadsforexecuting Havocinparallelinourstudiedfuzzers,
i.e., while retaining the execution of their modified Havocin the
sequential manner for 12 hours, we also execute Havocfor the
whole24hoursinparallelinadditionalthreads.Inparticular,we
adoptoneandtwoadditionalthreadsforexecuting Havocrespec-
tively. Figure 4 presents our evaluation results. We observe that
when adopting one additional thread to execute Havoc(labelled as
‚ÄúHybrid-1‚Äù), averagely the edge coverage of all the studied fuzzers
can be increased by 7.4%. Moreover, we can also observe that com-
pared with adopting one additional thread for Havoc, adopting two
additional threads for Havoc(labelled as ‚ÄúHybrid-2‚Äù) can further
increasetheedgecoverageperformanceby2.9%ontopofallthe
studiedfuzzers.ComparedwithQSYMwhichoriginallyachieves
theoptimalperformanceviausingthreethreadsforfuzzing,MOPT
andAFLcannowevenincurperformancegainsof1.2%and0.4%.
Ontheotherhand,sincetheperformancegainbysimplyincreasing
additionalthreads forexecuting Havocbecomesmarginal, wecan
infer that simply investing more computing resource on executing
Havocmaynot be cost-effective.
Finding6:Investingmorecomputingresourceinexecuting
Havoccanpotentiallyreduceitsexecutiontimeforapproach-
ingtheperformance bound, but may not be cost-effective.
Whilethepreviousfindingsrevealthatundersufficientexecu-
tion time of Havoc, multiple fuzzers can approach quite close edge
coverage performance, we further attempt to investigate how com-
montheirexplorededgescanbe.Tothisend,wedeterminetoadopt
theconceptof JaccardDistance [44]todelineatethesimilarityof
the explored edges from different fuzzers. In particular, Jaccard
Distanceisusuallyusedtomeasurethedissimilarity betweentwo
sets by dividing the difference of their union size and intersection
size by their union size. Figure 5 presents the evaluation results of
seed dissimilarity between the pure Havocand the other fuzzers
(with the modified Havoc) on average, ranging from 0.134 to 0.256.
Suchresultindicatesthatapplying Havoctodifferentfuzzerscan
potentiallyexplorequitecommonedges.NotethatQSYMhasthe
biggestJaccardDistance althoughitexecutes Havocfor24hours.
The main reasons can be that 1) QSYM invests more computing
resource,i.e.,leveragingthreethreadsrunninginparallel,and2)
QSYM leverages concolic execution [ 14] that may explore different
pathscomparedwithfuzzing.Furthermore,MTFuzzandNeuzzalso
havelarge JaccardDistance mainlybecausetheyfurtheruseneural
networks to guide the fuzzing process.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA Mingyuan Wu ‚Ä†, Ling Jiang, Jiahong Xiang, Yanwei Huang, Heming Cui, Lingming Zhang, and Yuqun Zhang*
	
       	

Figure 5: The average Jaccard Distance of different fuzzers
in all studied programs.
Finding 7: Applying Havoc to different fuzzers potentially
explores rather common edges, while fuzzers guided by con-
colic execution or neural networks can better complement
Havoc.
At last, we investigate the impact of appending Havocon expos-
ingprogram vulnerabilities. To this end, we attempt to collect the
programcrashescausedbyexecutingthegeneratedseedswithand
withoutappending Havoctoallthestudiedfuzzers.Notethatwhen
we append Havocto fuzzers, we ensure that it can be executed
undersufficient timeto fully leverage its power.
To begin with, it is essential to identify unique crashes since
it is likely that many crashes are caused by the same program
vulnerability. In this paper, we follow prior work [ 6,7,9,19,20,
25,52] to identify the unique crashes only if they increase edge
coverage. Note that in this paper, all of the crashes are explored byall of our previous evaluations. While a crash can only be reported
once among all the fuzzing strategies (including Havoc) within a
fuzzer, it can be possibly explored by different fuzzers. We then
divide crashes into two sets, i.e., the ones explored by the involved
Havocmechanisms and the ones explored by the major fuzzing
strategies. At last, we count the unique crashes for the two sets
respectively.
Table7 presentstheresults oftheunique crashes.Overall,we
derive 256 unique crashes from a total of 879 crashes where 243
(95%) are exposed by Havocand 13 are exposed by their original
fuzzingstrategies,e.g.,theconstraint-solving-basedmutationsin
QSYMandthegradient-drivenmutationsinNeuzz.Notethatwe
exposed69uniquecasheswhichhavebeenfixedinthelatestver-
sions of their associated projects [ 3‚Äì5,13]. We also report the rest
unknown crashes (i.e., they can be exposed in the latest version) to
thecorrespondingdevelopers[ 2,27].Thedetailedbugreportcan
befoundinourGitHubpage[ 32].Moreover,applying Havoccan
exposethecrashesin7ofthe12totalbenchmarkprojectsandbe
powerfulinexposinguniquecrashesinprojects nm(78outof79)
andjhead(96 out of 107). Such facts indicate that applying Havoc
can not only successfully advance program vulnerability exposure,
but also potentially dominate the vulnerability exposure on certain
projects.Table 7: The unique crashes found by Havoc
Programs CrashesUnique crashes
Havoc Major
readelf (V2.30) 81 50 0
nm (V2.36) 89 78 1
objdump (V2.30) 110
size (V2.30) 421
strip (V2.30) 12 12 0
djpeg (V9c) 440
jhead (V3.04) 688 96 11
Total 879 243 13
Finding 8: Havoc can also play a vital role in exposing po-
tentialprogram vulnerabilities.
4 ENHANCING HAVOC
So far, our presented powerful performance of Havocis simply
caused by modifying its setups, including its execution time and
integrationmodeswithfuzzers.Inthissection,weattempttoin-
vestigatewhetherthepowerof Havoccanbefurtherboosted.To
thisend,wefirstinvestigatetheperformanceimpactofthemuta-
tor stacking mechanism adopted by Havoc, and then propose an
intuitive and lightweight technique to improve its performance
accordingly.
4.1 Performance Impact of the Mutator
Stacking Mechanism
Notethatasasimplifiedmutationstrategy,themutatorstacking
mechanism containstwo steps:determining stackingsize andran-
domly selecting mutators, to impact the performance of Havoc.W e
then investigate the performance impact caused by each step. In
particular,wefirstattempttoinvestigatetheperformanceimpactof
stackingsize .Tothisend,insteadofrandomlydetermining stacking
sizefor mutating seeds at runtime of Havocoriginally, we imple-
mentHavocunderafixed stackingsize forallitsmutations.Figure6
presentsourevaluationresultsoftheedgecoverageratioresultsin
terms of all the possible fixed stacking size , i.e., 2, 4, 8,...128, on top
of all the studied benchmark projects. Note that the edge coverage
ratioofoneprojectiscomputedasthetheexplorededgenumberin
termsofonefixed stackingsize overthetotalexplorededgenumber
ofallthefixed stackingsize s.Wecanobservethatoverall,the stack-
ingsizewhichcausestheoptimaledgecoverageperformancefor
each studied project can be quite divergent, e.g., selecting stacking
size8,2,and32canoptimizetheedgecoveragein tcpdump,djpeg,
andmutoolrespectively. Such results suggest that it is essential to
adapt the stacking size setup for different projects to optimize their
respective edge coverage.
We then investigate the performance impact from mutators. To
thisend,insteadofuniformlyselectingmutatorsoutofatotalof15
mutators,wefirstuniformlyselect chunkmutators orunitmutators
and then randomly select their inclusive mutators under the given
stacking size for mutating one seed. Figure 7 presents the edge
coverageratioresultsintermsoftheselectedmutatortypesontop
of all the studied benchmark projects. Note that the edge coverage
ratio is computed as the explored edge number by either chunk

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. OneFuzzingStrategyto Rule Them All ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA
Algorithm1 The Framework of Havoc ùëÄùê¥ùêµ
Input:seed
Output:newseed
1:function MULTI_ARMED_UCB_SELECTION
2:newseed ‚Üêseed
3:stacksize ‚ÜêselectStackArm ()
4:mutatortype ‚ÜêselectMutatorTypeArm (stacksize)
5:foriterationinstacksize do
6: mutator‚ÜêrandomSelectMutatorByType (mutatortype)
7: newseed ‚ÜêgenerateNewSeed (mutator, newseed)
8:reward‚Üê0
9:ifisInteresting (newseed) then
10: reward‚Üê1
11:updateStackBandit (reward, stacksize)
12:updateMutatorTypeBandit (reward, stacksize, mutatortype)
13:returnnewseed
mutators orunit mutators over their total explored edge number.
We can observe that overall, the distribution of the edge coverage
ratio performance can be quite divergent among different projects,
e.g.,theedgecoverageratioofthe unitmutators rangesfrom18.39%
(xmllint)to94.53%( tiff2bw).Suchresultssuggestthatitisalso
essentialtoadapt the selectionof the mutatortypes for different
projects to optimize their respective edge coverage performance.
Figure 6: Edge coverage for different fixed stack sizes

  	      
  	   	
 	
Figure7:Edgecoveragefor unit mutators andchunk muta-
tors
4.2 Approach
Inspired by the evaluation results above, we attempt to propose
solutionstoenhance Havocviadynamicallyadjustingtheproject-
wiseselectionson stackingsize andmutators.Also,notethatour
previousfindingsrevealthattounleashthepowerof Havoc,itis
essentialtoinveststrongcomputingresourcesfor Havoc.Accord-
ingly, our design adopts the following principles. First, we onlyenable single thread/process, i.e., enhancing Havocvia only apply-
ing our specifically designed technique instead of leveraging more
threads for more computing resource as found already. Second,
our technique should be lightweight. In particular, when designing
a technique for adjusting Havocgiven the deterministic comput-
ing resource, ideally we aim for minimizing its overhead while
maximizingtheexecution time for the Havocmechanism itself.
In this paper, we propose a lightweight single-threaded tech-
niqueHavoc ùëÄùê¥ùêµ(MABrefersto Multi-ArmedBandit),forthepure
Havocto automatically adjust its selections on stacking size and
mutators at runtime for facilitating its edge exploration. Specif-
ically, we determine to model our task as a multi-armed bandit
problem [ 45] which typically refers to allocating limited resources
to alternative choices (i.e., stacking size and mutator selections for
this problem) to maximizetheir expected gain (i.e., edge coverage
forthisproblem).Morespecifically,wedesignatwo-layermulti-
armedbanditmachine,i.e.,a stackingsize -levelbanditmachineand
amutator-levelbanditmachine,whichispresentedinFigure8.Note
thatthestackingsize -levelbanditmachineenables7armswhere
each arm is designed corresponding to a stacking size choice, i.e., 2,
4, 8,...128. After an arm of stacking size is chosen, the mutator-level
bandit machine which enables 2 arms representing chunk mutators
andunitmutators wouldfirstmake achoiceoutof themandthen
proceedtoselecttheexactmutatorsviauniformdistribution.Even-
tually,Havoc ùëÄùê¥ùêµgeneratesamutantviatheselectedmutatorsand
executes it on the program under test for obtaining environmental
feedback for further executions.
Stacking Size 
Bandit
‚Ä¶
 128-Bandit
4-Bandit
 2-Bandit
Stacking Size Mutator TypeSeed 
Corpus
Seed
Mutant
 .C
Program Explore New 
Edges?
Mutator Type Bandits
Mutator StackingMutator
 Mutator
 Mutator
 Mutator
Input Havoc MAB Mutation Stage Execution OutputSeed 
Corpus
Updating Bandits
YESNO
Discard
Discar
Figure 8: The Framework of Havoc ùëÄùê¥ùêµ
010,00020,00030,00040,000
0 4 8 12 16 20 24Edge Coverage
Time (  hours  )Havoc Havoc MAB Havoc3MAB QSYM
,   p1= 0.00 507p2= 0.01219
Figure 9: The average edge coverage of Havoc ùëÄùê¥ùêµover time
Weadoptthewidely-usedUCB1-Tuned[ 1]algorithmtosolveour
proposed multi-armed bandit problem. Equation 1 demonstrates

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA Mingyuan Wu ‚Ä†, Ling Jiang, Jiahong Xiang, Yanwei Huang, Heming Cui, Lingming Zhang, and Yuqun Zhang*
050,000100,000
0 6 12 18 24020,00040,000
0 6 12 18 24025,00050,000
0 6 12 18 24015,00030,000
0 6 12 18 24025,00050,000
0 6 12 18 24012,50025,000
0 6 12 18 24
030,00060,000
0 6 12 18 24040,00080,000
0 6 12 18 24010,00020,000
0 6 12 18 24012,50025,000
0 6 12 18 24040,00080,000
0 6 12 18 2402,5005,000
0 6 12 18 24readelf nm objdump size strip djpeg
tcpdump xmllint ti 2bw mutool harfbuzz jhead
Time ( hours  )Edge CoverageHavoc Havoc MAB Havoc3MAB QSYM
Figure 10: Edge coverage of Havoc ùëÄùê¥ùêµover time
how to select an ùëéùëüùëöunder such algorithm for a given bandit
machine at time ùë°. In particular, ¬Øùë•ùëórefers to the average reward for
ùëéùëüùëö ùëótill timeùë°,ùëõrefers to the total execution count for the bandit
machineand ùëõùëóreferstotheexecutioncountfor ùëéùëüùëö ùëó,ùúéùëórefersto
thesamplevarianceof ùëéùëüùëö ùëó.
ùëéùëüùëö(ùë°)=argmax
ùëó/parenleftbigg
¬Øùë•ùëó+/radicalBigg
lnùëõ
ùëõùëóùëöùëñùëõ(1
4,ùúéùëó+2lnùëõ
ùëõùëó)/parenrightbigg
(1)
Notethatwedefinetherewardattime ùë°aswhether Havoc ùëÄùê¥ùêµhas
explored new edges or not for all the eight bandit machines. If a
seed generated by a chosen stacking size and its selected mutators
canexplorenewedges,therewardsreturnedtothe stackingsize -
level bandit machine and its corresponding mutator-level bandit
machineare both 1; otherwise, they are both 0.
Algorithm1presentsouroverallapproach. Havoc ùëÄùê¥ùêµfirstse-
lectsstacking size for the executing seed and then selects its corre-
sponding mutator type (Lines 3 to 4). Next, Havoc ùëÄùê¥ùêµgenerates a
mutant by uniformly selecting the mutators of stacking size under
thechosentype(Lines5to 7).Eventually,ifsuch mutantexplores
newedges,wesettherewardas1foritscorresponding stackingsize -
level and mutator-level bandit machines (0 otherwise) to update
Equation1 for further executions (Lines 8 to 12).
4.3 Evaluation
Toevaluate Havoc ùëÄùê¥ùêµ,weincludeQSYMforperformancecompar-
isonsinceitpresentstheoptimaledgecoverageperformanceinour
previousstudies.Furthermore,wedesignavariantof Havoc ùëÄùê¥ùêµ
namelyHavoc3
ùëÄùê¥ùêµwhereHavoc ùëÄùê¥ùêµisexecutedinthreethreads
in parallel for comparing with QSYM under identical computing
resources. We also include the pure Havocas a baseline. Similar as
Section3.2, weexecute eachvariant forfive timesfor eachbench-
markproject to reduce the impact of randomness.
Figure9presentstheaverageevaluationresultsofedgecoverage
ofthestudiedapproachesontopofallthebenchmarkprojectsunder
24-hour execution. We can observe that Havoc ùëÄùê¥ùêµachieves sig-
nificantlybetterperformancethanpure Havoc,i.e.,increasingthe
average edge coverage among all the benchmark projects by 11.1%
(34,574vs31,126explorededges).Moreover,weapplytheMann-
WhitneyUtest[ 26]toillustratethesignificanceof Havoc ùëÄùê¥ùêµ.Thefact that the ùëù-value of Havoc ùëÄùê¥ùêµcomparing with Havocin terms
oftheaverageedgecoverageis0.00507indicatesthat Havoc ùëÄùê¥ùêµ
outperforms Havocsignificantly ( ùëù< 0.05). Interestingly, although
Havoc ùëÄùê¥ùêµonly adopts one thread for execution, it can slightly
outperform QSYM (which leverages three threads for execution)
by 0.2% on average among all 5 runs with the STD of 108.55. It can
also outperform QSYM for 4 out of 5 runs. On the other hand, exe-
cutingHavoc3
ùëÄùê¥ùêµcan result in 9% edge coverage gain over QSYM
(37,614vs34,495explorededges)witha ùëù-valueof0.01219.Such
results altogether can demonstrate the strength of our proposed
Havoc ùëÄùê¥ùêµ.
Figure10presentstheedgecoveragetrendsofourstudiedap-
proaches upon each benchmark for 24-hour execution. Overall,
Havoc ùëÄùê¥ùêµoutperforms pure Havocin most of the benchmarks sig-
nificantly. Moreover, Havoc ùëÄùê¥ùêµcan outperform QSYM by at least
10%(60%morein tiff2w)intermsofedgecoverageonfiveprojects
while incurring rather close performance on the rest projects with
asinglethreadexcept jhead.Meanwhile, Havoc3
ùëÄùê¥ùêµcanachieve
theoptimaledgecoverageperformanceoneightbenchmarks.Note
that QSYM outperforms all other fuzzers in jhead(averagely 4,516
vs.1,063).Thisdemonstratesthatgrey-boxfuzzingstrategiesalone
are ineffective for jheadwhile the effectiveness can be largely im-
proved by concolic execution leveraged in QSYM. Based on this
observation and Finding 7, we highly recommend future research
toinvestigatemorepowerfultechniquesforcombining Havoc,con-
colicexecution, and learning-based fuzzing.
5 THREATS TO VALIDITY
Threatstointernalvalidity. Onethreattointernalvaliditylies
in the implementation of the studied fuzzers in our evaluation. To
reduce this threat, we reused their original source code for our
implementationand experimentationdirectly.Moreover, thefirst
4 authors manually reviewed all the code carefully to ensure its
correctness and consistency.
Threats to external validity. The threats to external validity
mainlylieinthesubjectsandbenchmarks.Toreducethethreats,
weselect8representativestate-of-the-artfuzzers,includingAFL-
based, concolic-execution-based, and neural program-smoothing-
basedfuzzers.Wealsoadopt12benchmarkprojectsaccordingto

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. OneFuzzingStrategyto Rule Them All ICSE‚Äô22, May21‚Äì29,2022,Pittsburgh,PA, USA
their popularity, i.e., the most frequently used benchmarks by the
originalpapersofourstudiedfuzzers.Anotherthreattoexternal
validity may lie in the randomness of the evaluation results. To
reduce this threat, all the evaluation results are averaged upon five
runsto reduce the impact of randomness.
Threats to construct validity. The threat to construct validity
mainlyliesinthemainmetricusedinthispaper,i.e.,edgecoverage,
toreflectcodecoverage.Toreducethisthreat,whiletherecanbe
various ways to measure edge coverage, we choose to follow many
existingfuzzers[ 8,20,33,34,50]andleveragetheAFLbuilt-intool
named afl-showmap forcollectingedgecoverage.Furthermore,we
havealsoevaluatedfuzzingeffectivenessintermsofthenumberof
uniquecrashes.
6 RELATED WORK
Fuzzing. AFL[52]isoneofthemostpopularfuzzersandhasin-
spired many other recent fuzzers for different application domains.
Fioraldietal.[ 12]integratedmultipletechniques,e.g.,tainttracking,
intothebasicframeworkofAFL.Liangetal. [ 23]alsointroduced
a path-aware taint analysis fuzzer to facilitate the efficiency of
fuzzing. B√∂hme et al. [ 7] utilized a Markov chain model to allocate
energy for seed selection. Peng et al. [ 30] proposed T-Fuzz, which
removes sanity checks from the target program and then lever-
agesasymbolicexecutionenginetogenerateapathtothebuggy
pointifitfindsanycrash.Honggfuzz[ 15]boostedtheefficacyof
fuzzingundermultipleprocessesandthreadswhileChenetal.[ 10]
proposed a synchronization mechanism for integrating different
fuzzers. Wangetal.[ 38]proposedSYZVEGAStofuzzthekernel
ofoperatingsystemsbydynamicallyadjustingfuzzingstrategies
via reinforcement learning. Li et al. [ 21] introduced Steelix, which
integrates light-weight static analysis to coverage-guide fuzzing.
Wang et al. [ 39] proposed Skyfire, which leverages the knowledge
in the vast amount of existing samples to generate well-distributed
seed inputs for fuzzing programs that process highly-structured
inputs. They have also proposed a grammar-aware coverage-based
greybox fuzzing approach, named Superion [ 40], to fuzz programs
that process structured inputs. In more recent years, researchers
have alsoproposed various techniquesfor fuzzingdifferent types
ofsoftwaresystems[ 29,36,42,55].Wuetal.[ 48,49]pr oposedto
detect CUDA synchronization bugs via fuzzing and repair them
automatically.Zhangetal.[ 54]proposedDeepRoadtogenerateim-
agestofuzzimage-baseddrivingsystems.Zhouetal.[ 56]generated
realistic and continuous images to fuzz such systems. In this paper,
we propose a technique to dynamically adjust mutation selections
forHavocandresult in strong edge coverage performance.
StudiesonFuzzing/Testing. Shenetal.[ 35]investigateddifferent
bugs on different deep learning compilers. Metzman et al. [ 28]
introducedaplatformfordevelopersandresearcherstoevaluate
different fuzzers. Although they studied Havocassociated with
fuzzers,theydidnotevaluateitindependently. Kleesetal.[ 19]sur-
veyed the recent research literature and assessed the experimental
evaluationstoillustratetheessentialexperimentalsetupforreliable
experiments for fuzzing. We actually follow the instruction of this
work to construct our initial seed corpus. Furthermore, Herrera et
al.[16]systematicallyinvestigatedandevaluatedhowseedselec-
tion affects the performance of a fuzzer to expose vulnerabilitiesin real-world systems. Many researchers studied the rationales be-
hindfuzzingapproaches.Wuetal[ 47]empiricallyevaluatedthe
neuralprogram-smoothing-basedfuzzersandimprovedthemby
proposing lightweight learning-based mutation strategies. Liang
etal.[22]presented themainobstaclesandcorrespondingtypical
solutions for fuzzing. Tonder et al. [ 37] presented a technique to
mapcrashing inputsto unique bugs using program transformation.
In this paper, we conduct the first extensive study on Havocto
demonstratethat Havocis a powerful fuzzer, and have also shown
thatit is possible to further advance Havoc.
7 CONCLUSION
In this paper, we investigate the impact and design of a random
fuzzingstrategy Havoc.Wefirstconductanextensivestudytoevalu-
atetheimpactof Havocbyapplying Havoctoasetofstudiedfuzzers
onreal-worldbenchmarks.Theevaluationresultsdemonstratethat
the pure Havoccan already achieve superior edge coverage and
vulnerability detection compared with other fuzzers. Moreover,
integrating Havocto a fuzzer or extending total execution time
forHavoccan also increase the edge coverage significantly. The
performance gap among different fuzzers can also be considerably
reduced by appending Havoc. At last, we also design a lightweight
approach to further boost Havocby dynamically adjusting its mu-
tationstrategy.
8 ACKNOWLEDGEMENT
ThisworkispartiallysupportedbytheNationalNaturalScience
Foundation of China (Grant No. 61902169), Guangdong Provincial
Key Laboratory (Grant No. 2020B121201001), and Shenzhen Pea-
cockPlan(GrantNo.KQTD2016112514355531).Thisworkisalso
partiallysupportedbyNationalScienceFoundationunderGrant
Nos.CCF-2131943andCCF-2141474,as well as Ant Group.
REFERENCES
[1] Peter Auer, Nicolo Cesa-Bianchi, and Paul Fischer. 2002. Finite-time analysis of
themultiarmed bandit problem. Machinelearning 47,2 (2002), 235‚Äì256.
[2]GNUBinutils.2021. Bug28269-[nm]stack-overflowinnm-new‚Äôdemanglepath‚Äô.
https://sourceware.org/bugzilla/show_bug.cgi?id=28269.
[3]GNUBinutils.2021. Bug28272-[strip]SEGVingroupsignature-v2.30. https:
//sourceware.org/bugzilla/show_bug.cgi?id=28272.
[4]GNU Binutils. 2021. Bug 28273 - [strip] heap-use-after-free in ‚Äôgroup signature‚Äô.
https://sourceware.org/bugzilla/show_bug.cgi?id=28273.
[5]GNUBinutils.2021. Bug28274-[strip]heap-buffer-overflow. https://sourceware.
org/bugzilla/show_bug.cgi?id=28274.
[6]MarcelB√∂hme,Van-ThuanPham,Manh-DungNguyen,andAbhikRoychoud-
hury.2017. DirectedGreyboxFuzzing.In Proceedingsofthe2017ACMSIGSAC
Conference on Computer and Communications Security (Dallas, Texas, USA) (CCS
‚Äô17). Association for Computing Machinery, New York, NY, USA, 2329‚Äì2344.
https://doi.org/10.1145/3133956.3134020
[7]Marcel B√∂hme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
BasedGreyboxFuzzingasMarkovChain.In Proceedingsofthe2016ACMSIGSAC
Conference on Computer and Communications Security (Vienna, Austria) (CCS
‚Äô16). Association for Computing Machinery, New York, NY, USA, 1032‚Äì1043.
https://doi.org/10.1145/2976749.2978428
[8]Peng ChenandHaoChen. 2018. Angora:Efficientfuzzingbyprincipled search.
In2018IEEESymposiumon Security and Privacy (SP) . IEEE, 711‚Äì725.
[9]Peng ChenandHaoChen. 2018. Angora:Efficientfuzzingbyprincipled search.
In2018IEEESymposiumon Security and Privacy (SP) . IEEE, 711‚Äì725.
[10]YuanliangChen,YuJiang,FuchenMa,JieLiang,MingzheWang,ChijinZhou,
XunJiao,andZhuoSu.2019. Enfuzz:Ensemblefuzzingwithseedsynchronization
amongdiversefuzzers.In 28th{USENIX}SecuritySymposium( {USENIX}Security
19). 1967‚Äì1983.
[11]Yaohui Chen, Peng Li, Jun Xu, Shengjian Guo, Rundong Zhou, Yulong Zhang,
Tao Wei, and Long Lu. 2020. Savior: Towards bug-driven hybrid testing. In 2020

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. ICSE‚Äô22,May21‚Äì29,2022,Pittsburgh,PA, USA Mingyuan Wu ‚Ä†, Ling Jiang, Jiahong Xiang, Yanwei Huang, Heming Cui, Lingming Zhang, and Yuqun Zhang*
IEEESymposiumon Security and Privacy (SP) . IEEE, 1580‚Äì1596.
[12]Andrea Fioraldi, Dominik Maier, Heiko Ei√üfeldt, and Marc Heuse. 2020. AFL++:
Combiningincrementalstepsoffuzzingresearch.In 14th{USENIX}Workshop
on Offensive Technologies ( {WOOT}20).
[13]Probe Fuzzer. 2018. Reachable assertion in find section (src/binutils/readelf.c).
https://lists.gnu.org/archive/html/bug-binutils/2018-02/msg00076.html.
[14]PatriceGodefroid,Nils Klarlund,andKoushikSen.2005. DART:Directedauto-
mated random testing. In Proceedings of the 2005 ACM SIGPLAN conference on
Programming language design and implementation . 213‚Äì223.
[15] Google. 2021. Honggfuzz. https://github.com/google/honggfuzz.[16]
AdrianHerrera,HendraGunadi,ShaneMagrath,MichaelNorrish,MathiasPayer,
andAntonyLHosking.2021. Seedselectionforsuccessfulfuzzing.In Proceed-
ingsofthe30thACMSIGSOFT InternationalSymposiumonSoftwareTestingand
Analysis. 230‚Äì243.
[17]Heqing Huang, Peisen Yao, Rongxin wu,Qingkai Shi, and Charles Zhang. 2020.
Pangolin: Incremental Hybrid Fuzzing with Polyhedral Path Abstraction. 1613‚Äì
1627. https://doi.org/10.1109/SP40000.2020.00063
[18]James Kennedy and Russell Eberhart. 1995. Particle swarm optimization. In
ProceedingsofICNN‚Äô95-international conferenceonneuralnetworks ,Vol.4.IEEE,
1942‚Äì1948.
[19]GeorgeKlees,AndrewRuef,BenjiCooper,ShiyiWei,andMichaelHicks.2018.
Evaluating fuzz testing. In Proceedings of the 2018 ACM SIGSAC Conference on
ComputerandCommunicationsSecurity . 2123‚Äì2138.
[20]Caroline Lemieux and Koushik Sen. 2018. Fairfuzz: A targeted mutation strategy
forincreasinggreyboxfuzztestingcoverage.In Proceedingsofthe33rdACM/IEEE
InternationalConferenceon Automated Software Engineering . 475‚Äì485.
[21]Yuekang Li, Bihuan Chen, Mahinthan Chandramohan, Shang-Wei Lin, Yang Liu,
andAlwenTiu.2017. Steelix:Program-StateBasedBinaryFuzzing.In Proceedings
of the 2017 11th Joint Meeting on Foundations of Software Engineering (Paderborn,
Germany) (ESEC/FSE 2017) . Association for Computing Machinery, New York,
NY, USA, 627‚Äì637. https://doi.org/10.1145/3106237.3106295
[22]JieLiang,MingzheWang,YuanliangChen,YuJiang,andRenweiZhang.2018.
Fuzztesting in practice: Obstacles and solutions. In 2018IEEE 25thInternational
Conference on Software Analysis, Evolution and Reengineering (SANER) . 562‚Äì566.
https://doi.org/10.1109/SANER.2018.8330260
[23]J.Liang,M.Wang,C.Zhou,Z.Wu,Y.Jiang,J.Liu,Z.Liu,andJ.Sun.2022. PATA:
FuzzingwithPathAwareTaintAnalysis.In 20222022IEEESymposiumonSecurity
and Privacy (SP) (SP) . IEEE Computer Society, Los Alamitos, CA, USA, 154‚Äì170.
https://doi.org/10.1109/SP46214.2022.00010
[24] LLVM.2021. LibFuzzer. https://llvm.org/docs/LibFuzzer.html.[25]
ChenyangLyu,ShoulingJi,ChaoZhang,YuweiLi,Wei-HanLee,YuSong,and
RaheemBeyah.2019. {MOPT}:Optimizedmutationschedulingforfuzzers.In
28th{USENIX}Security Symposium ( {USENIX}Security 19) . 1949‚Äì1966.
[26]ThomasWMacFarlandandJanMYates.2016. Mann‚Äìwhitneyutest. In Intro-
duction to nonparametric statistics for the biological sciences using R . Springer,
103‚Äì132.
[27]Matthias-Wandel.2021. NonfatalErrorbyheap-buffer-overflow(version3.04).
https://github.com/Matthias-Wandel/jhead/issues/42.
[28]JonathanMetzman,L√°szl√≥Szekeres,LaurentSimon,ReadSprabery,andAbhishek
Arya. 2021. FuzzBench: An Open Fuzzer Benchmarking Platform and Service.
InProceedingsofthe29thACMJointMeetingonEuropeanSoftwareEngineering
ConferenceandSymposiumontheFoundationsofSoftwareEngineering (Athens,
Greece)(ESEC/FSE 2021) . Association for Computing Machinery, New York, NY,
USA,1393‚Äì1403. https://doi.org/10.1145/3468264.3473932
[29] Augustus Odena,CatherineOlsson,DavidAndersen,andIanGoodfellow.2019.
Tensorfuzz: Debugging neural networks with coverage-guided fuzzing. In Inter-
nationalConference on Machine Learning . PMLR, 4901‚Äì4911.
[30]Hui Peng, Yan Shoshitaishvili, and Mathias Payer. 2018. T-Fuzz: Fuzzing by
ProgramTransformation.In 2018IEEESymposiumonSecurityandPrivacy(SP) .
697‚Äì710. https://doi.org/10.1109/SP.2018.00056
[31]Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,
and Herbert Bos. 2017. VUzzer: Application-aware Evolutionary Fuzzing.. In
NDSS, Vol. 17. 1‚Äì14.
[32]Github Repository. 2021. Havoc-Study. https://github.com/MagicHavoc/Havoc-
Study.
[33]Dongdong She, Rahul Krishna, Lu Yan, Suman Jana, and Baishakhi Ray. 2020.MTFuzz: fuzzing with a multi-task neural network. In Proceedings of the 28th
ACM Joint Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering . 737‚Äì749.
[34]DongdongShe,KexinPei,DaveEpstein,JunfengYang,BaishakhiRay,andSuman
Jana.2019. NEUZZ:Efficientfuzzingwithneuralprogramsmoothing.In 2019
IEEESymposiumon Security and Privacy (SP) . IEEE, 803‚Äì817.
[35]QingchaoShen,Haoyang Ma, JunjieChen, Yongqiang Tian, Shing-Chi Cheung,
andXiangChen.2021. A comprehensive study of deep learning compilerbugs.
InProceedingsofthe29thACMJointMeetingonEuropeanSoftwareEngineering
Conference and Symposium on the Foundations of Software Engineering . 968‚Äì980.
[36]YuchiTian,KexinPei,SumanJana,andBaishakhiRay.2018. Deeptest:Automated
testing of deep-neural-network-driven autonomous cars. In Proceedings of the40thinternationalconferenceon software engineering . 303‚Äì314.
[37]Rijnard van Tonder, John Kotheimer, and Claire le Goues. 2018. Semantic Crash
Bucketing.In 201833rdIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering(ASE) . 612‚Äì622. https://doi.org/10.1145/3238147.3238200
[38] DaimengWang, ZhengZhang,HangZhang,ZhiyunQian,SrikanthV.Krishna-
murthy, and NaelAbu-Ghazaleh. 2021. SyzVegas: Beating Kernel FuzzingOdds
withReinforcementLearning.In 30thUSENIXSecuritySymposium(USENIXSecu-
rity21).USENIX Association,2741‚Äì2758. https://www.usenix.org/conference/
usenixsecurity21/presentation/wang-daimeng
[39]Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2017. Skyfire: Data-DrivenSeed Generation for Fuzzing. In 2017 IEEE Symposium on Security and Privacy
(SP). 579‚Äì594. https://doi.org/10.1109/SP.2017.23
[40]Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2019. Superion: Grammar-
aware greybox fuzzing. In 2019IEEE/ACM 41st InternationalConference on Soft-
ware Engineering (ICSE) . IEEE, 724‚Äì735.
[41]YanhaoWang,XiangkunJia,YuweiLiu,KyleZeng,TiffanyBao,DinghaoWu,
and Purui Su. 2020. Not All Coverage Measurements Are Equal: Fuzzing by
Coverage Accounting for Input Prioritization.. In NDSS.
[42]Anjiang Wei, Yinlin Deng, Chenyuan Yang, and Lingming Zhang. 2022. Free
LunchforTesting:FuzzingDeep-LearningLibrariesfromOpenSource.In 2022
IEEE/ACM 44th International Conference on Software Engineering (ICSE) .
[43]Wikipedia. 2021. Exposing Bugs by Fuzzing. https://en.wikipedia.org/wiki/
Fuzzing#Exposing_bugs.
[44]Wikipedia. 2021. Jaccard Distance. https://en.wikipedia.org/wiki/Jaccard_index.
[45]Wikipedia.2021. Multi-armedBanditProblem. https://en.wikipedia.org/wiki/
Multi-armed_bandit.
[46]Wikipedia. 2021. Socket programming. https://en.wikipedia.org/wiki/Network_
socket.
[47]MingyuanWu,LingJiang,JiahongXiang,YuqunZhang,GuoweiYang,Huixin
Ma,SenNie,ShiWu,HemingCui,andLingmingZhang.2022. Evaluatingand
ImprovingNeuralProgram-Smoothing-basedFuzzing.In 2022IEEE/ACM44th
InternationalConference on Software Engineering (ICSE) .
[48]Mingyuan Wu, Yicheng Ouyang, Husheng Zhou, Lingming Zhang, Cong Liu,and Yuqun Zhang. 2020. Simulee: Detecting cuda synchronization bugs viamemory-access modeling. In 2020 IEEE/ACM 42nd International Conference on
Software Engineering (ICSE) . IEEE, 937‚Äì948.
[49]MingyuanWu,LingmingZhang,CongLiu,ShinHweiTan,andYuqunZhang.
2019. Automating CUDA Synchronization via Program Transformation. In 2019
34thIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering(ASE) .
748‚Äì759. https://doi.org/10.1109/ASE.2019.00075
[50]InsuYun,SanghoLee,MengXu,YeongjinJang,andTaesooKim.2018. {QSYM}:A
practicalconcolicexecutionenginetailoredforhybridfuzzing.In 27th{USENIX}
Security Symposium ( {USENIX}Security 18) . 745‚Äì761.
[51]Michal Zalewski. 2016. Edge Coverage Dopted in AFL. https://groups.google.
com/g/afl-users/c/fOPeb62FZUg/m/LYxgPYheDwAJ.
[52] Micha≈ÇZalewski.2020. AmericanFuzzLop. https://github.com/google/AFL.
[53]Micha≈ÇZalewski.2021. AFLOfficialSeedCorpus. http://lcamtuf.coredump.cx/
afl/demo/.
[54]Mengshi Zhang, Yuqun Zhang, Lingming Zhang, Cong Liu, and Sarfraz Khur-shid. 2018. DeepRoad: GAN-Based Metamorphic Testing and Input Valida-tion Framework for Autonomous Driving Systems. In 2018 33rd IEEE/ACM
International Conference on Automated Software Engineering (ASE) . 132‚Äì142.
https://doi.org/10.1145/3238147.3238187
[55]Yingquan Zhao, Zan Wang, Junjie Chen, Mengdi Liu, Mingyuan Wu, YuqunZhang, and Lingming Zhang. 2022. History-Driven Test Program Synthesisfor JVM Testing. In 2022 IEEE/ACM 44th International Conference on Software
Engineering(ICSE) .
[56]HushengZhou,WeiLi,ZelunKong,JunfengGuo,YuqunZhang,BeiYu,LingmingZhang,andCongLiu.2020. DeepBillboard:SystematicPhysical-WorldTestingof
AutonomousDriving Systems.In 2020IEEE/ACM 42ndInternationalConference
on Software Engineering (ICSE) . 347‚Äì358.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:32:16 UTC from IEEE Xplore.  Restrictions apply. 