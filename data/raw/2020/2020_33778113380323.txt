SAVER: Scalable, Precise, and Safe Memory-Error Repair
Seongjoon Hong
Korea University
Republic of Korea
seongjoon@korea.ac.krJunhee Lee∗
Korea University
Republic of Korea
junhee_lee@korea.ac.krJeongsoo Lee
Korea University
Republic of Korea
jeongsoolee@korea.ac.krHakjoo Oh†
Korea University
Republic of Korea
hakjoo_oh@korea.ac.kr
ABSTRACT
We present SAVER, a new memory-error repair technique for C
programs.Memoryerrorssuchasmemoryleak,double-free,and
use-after-free are highly prevalent and fixing them requires signifi-
canteffort.Automatedprogramrepairtechniquesholdthepromise
ofreducingthisburdenbutthestate-of-the-artisstillunsatisfactory.Inparticular,noexistingtechniquesareabletofixthoseerrorsina
scalable, precise, and safe way, all of which are required for a truly
practical tool. SAVER aims to address theseshortcomings. Tothis
end,weproposeamethodbasedonanovelrepresentationofthe
programcalledobjectflowgraph,whichsummarizestheprogram’s
heap-related behavior using static analysis. We show that fixing
memoryerrorscanbeformulatedasagraphlabelingproblemover
object flow graph and present an efficient algorithm. We evaluated
SAVER in combination with Infer, an industrial-strength static
bug-finder,andshowthat74%ofthereportederrorscanbefixed
automatically for a range of open-source C programs.
CCS CONCEPTS
•Software and its engineering →Software verification and
validation; Software testing and debugging.
KEYWORDS
Program Repair, Program Analysis, Memory Errors, Debugging
ACM Reference Format:
Seongjoon Hong, Junhee Lee, Jeongsoo Lee, and Hakjoo Oh. 2020. SAVER:
Scalable, Precise, and Safe Memory-Error Repair. In 42nd International Con-
ferenceonSoftwareEngineering(ICSE’20),May23–29,2020,Seoul,Republicof
Korea.ACM, New York, NY, USA, 13 pages. https://doi.org/10.1145/3377811.
3380323
1 INTRODUCTION
Recent years have seen significant progress in automated tools for
static error detectionand their deployment inproduction code [ 7,
15,50].Yet,fixingthoseerrorsinpracticeremainsmostlyamanual
and unscalable process. The longterm goal of our research is to
∗The first and second authors contributed equally to this work.
†Corresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380323bridge this gap by automating the whole process of finding and
fixing common safety errors at compile-time.
Inthis paper,wefocus onfixingmemory errorsinC programs
such as memory leak, use-after-free, and double-free. We target
these errors because they are highly prevalent yet difficult to fix.For example, more than 4,800 memory leaks have been reported
andfixedinLinuxkernel[ 1],farmorefrequentlythanothererrors
such as buffer overflow. Fixing memory errors manually, however,
istime-consuminganderror-prone;evenasingleerrormayrequire
developers to spend several days or months until the error gets
fixedcorrectly(e.g.[ 2]).Weaimtoreducethisburdenbyachieving
a practical technique for automatically fixing memory errors.
ExistingTechniques .Recently,severaltechniqueswithsimilar
goals have been proposed in the program repair community [ 18,
34,60] but they suffer from significant drawbacks. On the one
hand, there are techniques that scale to large programs but may
produce unsafe patches. For example, FootPatch [ 60] is a state-of-
the-art tool that can fix memory leaks in large code bases but may
introducenewerrorssuchasdouble-freeasaside-effect(e.g.see
Section2.1).Ontheotherhandaretoolsthatguaranteetogenerate
safe patches but do so at the expense of scalability or repairability.
Forexample,MemFix[ 34]cansafelyfixmemoryleaks,use-after-
frees, and double-frees but is applicable only to small programs
(<5KLoC). LeakFix [ 18], another safe fixing tool, is scalable but
limitedtofixingsimplememory-leaks,havingarelativelylowfix
rate (e.g.<15% for GNU utilities [ 34]). All of these shortcomings of
existing techniques make them inappropriate for practical use.
OurApproach .Inthispaper,wepresentSAVER,ascalable,pre-
cise,andsafetechniqueforautomaticallyfixingmemoryerrors.To
guaranteesafety,SAVERusesasoundprogramverificationtech-
niqueandproducespatchesonlywhenitisconfidentthattheerrorgetsfixedwithoutviolatingothersafetyconditions.Toachievehigh
repairability,SAVER supportsvariousfixingstrategies,including
conditional deallocation and relocation of pointer dereferences. To
thisend,weproposeanewrepresentationoftheprogramcalled ob-
jectflowgraph,whichisalabeledgraphsummarizingtheprogram’s
heap-related behavior using a static heap analysis. The key techni-cal novelty is to formulate the problem of fixing memory errors as
a labeling problem over object flow graph and present an efficient
algorithm for finding correct labels. For scalability, SAVER applies
theaforementionedanalysisandverificationtechniquesselectively
and locally. The analysis is selective as it uses expensive abstrac-
tions (e.g. path-sensitivity) only when doing so benefits. Also, only
a fraction of the input program is analyzed by effectively slicing
out the program with respect to the target error.
The experimental results show that SAVER is a practical tool,
significantly outperforming existing techniques. We implemented
2712020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
1intappend_data (Node *node, int*ndata) {
2if(!(Node *n = malloc(sizeof(Node)))
3 return-1;// failed to be appended
4n->data = ndata;
5n->next = node->next; node->next = n;
6return0;// successfully appended
7}
8
9Node *lx = ... // a linked list
10Node *ly = ... // a linked list
11for(Node *node = lx; node != NULL; node = node->next) {
12int*dptr = malloc(sizeof(int));
13if(!dptr) return;
14*dptr = *(node->data);
15(-) append_data(ly, dptr); // potential memory-leak
16(+)if((append_data(ly, dptr)) == -1) free(dptr);
17}
Figure 1: A memory leak error (line 12) and the SAVER-
generated patch (line 16).
SAVER as a stand-alone tool that can be combined with off-the-shelf memory-error detectors (e.g. [
10,17,22,28,30,59,63,67]).
Inourevaluation,weusedInfer[ 10],astate-of-the-artstatican-
alyzer deployed within Facebook [ 15], which supports memory-
leak detection for C programs. For 10 open-source programs (2–320 kLoC), Infer reported 96 memory-leak errors with 66 falsealarms. SAVER successfully fixed 71 out of the 96 true alarms,achieving a 74% fix rate, and did not attempt to fix false alarms.
Ontheotherhand,FootPatch[ 60],theexistingstate-of-the-art,
fixed 19 out of the 96 memory leaks, leading to a 20% fix rate. In
doing so, FootPatch generated 5 unsafe patches introducing new
double-freesoruse-after-frees.FootPatchgenerated26patches
forfalsealarmsaswell,ofwhich25wereunsafe.Wealsoevaluated
the effectiveness of SAVER for fixing use-after-frees and double
frees by conducting case studies with 3 open-source projects in the
wild, where SAVER was able to correctly fix 15 out of 34 errors.
Contributions. This paper makes the following contributions:
•We present a new technique for fixing memory errors. The
keyideaistoconstructanobjectflowgraphviastaticanaly-
sis and generate a patch by finding correct labels.
•We present SAVER, a practical and publicly available tool
implementing the proposed approach.1
•We demonstrate the effectiveness of SAVER in realistic set-
tings by comparing it with existing state-of-the-arts.
2 OVERVIEW
We illustrate key features of SAVER and how it works.
2.1 Motivating Examples
Example1 .Figure1describesasimplifiedmemory-leakerror
intheopen-sourceprogram snort,whichcanbedetectedbythe
Infer static analyzer [10] with the following error report:
1https://github.com/kupl/SAVER_public/1structnode *cleanup; // list of objects to be deallocated
2structnode *first = NULL;
3for(...) {
4structnode *new = xmalloc(sizeof(*new));
5make_cleanup(new); // add new to the cleanup list
6new->name = ...;
7...
8if(...) {
9 first = new;
10(+) tmp = first->name;
11 continue;
12}
13/* potential use-after-free: `first->name` */
14(-)if(first == NULL || new->name != first->name)
15(+)if(first == NULL || new->name != tmp)
16 continue;
17do_cleanups(); // deallocate all objects in cleanup
18}
Figure 2: A use-after-free error (line 14) and the SAVER-generated patch (lines 10 and 15).
Object allocated at line 12 is unreachable at line 15.
Globalvariables lxandlyatlines9and10arepointerstolinked
lists.Atline11,theloopiteratesoverthelist lx.Ateachiterationof
the loop, a new data object is allocated (line 12) and the data of the
currentnodeiscopiedtotheallocatedobject(line14).Atline15,the
function call, append_data(ly, dptr) , stores the allocated object
(dptr) in the list lyas its first element. The function append_data
returns 0 if the data is stored successfully (line 6). However, it
returns−1 when the data object fails to be appended to ly(line 3).
A memory leak error occurs in the latter case; when append_data
fails, the object allocated at line 12 becomes unreachable from the
environment at the next iteration of the loop since the pointer
variabledptrgets assigned a newly allocated object.
Given the program snort(320 kLoC) and the error report (such
as the one produced by Infer), SAVER automatically generates the
patchatline16.Itreplacesthecallto append_data atline15bythe
conditional statement given at line 16, correctly deallocating the
object(dptr)onlywhen append_data failstostoretheobjectinthe
listly. SAVER does so by inferring the program invariant that the
allocated object ( dptr) at each loop iteration becomes unreachable
whenappend_data returns-1and thus deallocating the object
under this condition is always safe.
Bycontrast,FootPatch[ 60],MemFix[ 34],andLeakFix[ 18]fail
to correctly fix the error in Figure 1. In particular, FootPatch pro-
duces an unsafe patch by simply inserting free(dptr) after line
15 without checking the return value of append_data , which re-
moves the reported memory leak but introduces a more deadlyuse-after-free error (when the elements of list
lyare used later).
Safefixingtools,MemFixandLeakFix,arenotscalableorrobust
enoughtoanalyze320klinesofcode.Still,theywouldfailevenwith-
outtheseissuesbecausetheiruseislimitedtoproducingpatches
without conditionals. Note that the error in Figure 1 is never fixed
272without introducing a new conditional statement. For example, in-
sertingfree(ndata) betweenlines2and3causesuse-after-freein
snortasappend_data iscalledatmultipleplaceswheretheobject
pointed to by ndatais used even when the return value is −1 (e.g.
for printing the error code), which we omitted in Figure 1.
Example2 .Figure2showsatrickyuse-after-freeerror[ 3].In-
stead of using primitive deallocators (e.g. free), the program uses
themake_cleanup anddo_cleanups functionsasaspecialmech-
anismformemorymanagement.Thecodemaintainsagloballist
calledcleanup, which holds memory objects to be deallocated.
Function make_cleanup isusedtoappendanobjecttothe cleanup
list anddo_cleanups deallocates all objects in it.
Theuse-after-free erroroccursas follows.At thefirstiteration
of the loop, a newobject is allocated at line 4 and its address is
stored in the cleanup list by calling make_cleanup(new) at line 5.
Supposethetruebranchofthefirstconditionalatline8istaken,
whereanewalias( first)fortheallocatedobjectismade(line9).
The heap can be depicted as follows:
cleanup
newo1 cleanup
newfirsto1
The left and right diagrams show the heap right after lines 5 and 9,
respectively. In each diagram, oirepresents the object allocated at
thei-thiterationoftheloop.Intheseconditerationoftheloop,a
newobject o2isallocatedandappendedtolist cleanup,andfirst
still refers to o1as depicted in the left diagram below:
cleanup
first newo1o2 cleanup
first newo1o2
Nowassumethatwetakethefalsebranchesofbothconditionals
atlines8and14andreachthecallto do_cleanups atline17.Once
do_cleanups iscalled,both o1ando2aredeallocatedasdepicted
with the shaded boxes in the right diagram. In addition, the link
fromcleanup too1is removed. At the third iteration, suppose we
take the false branch of the conditional at line 8. Then, we reach
the second conditional (line 14) with the following heap:
cleanup
first newo1o2o3
Sincefirstholdsanon-null(dangling)pointer,theright-handside
ofthedisjunctionisevaluated,wherethedereference first->name
causes the program to crash as the object o1is already deallocated.
SAVER fixes this error by moving the dereference expression
(first->name ) from line 14 to 10, storing its value in a temporary
variable(tmp),andreplaces first->name atline14by tmpasshown
at line 15. Note that this patch correctly eliminates the use-after-
freeerrorbecausethepointer firstisnolongerdereferencedat
line 15 and dereferencing firstat line 10 is safe as the object is
not yet deallocated. Note also that moving first->name from line
14to10doesnotchangethemeaningoftheprogram.SAVER en-
suresthisbycheckingthatthevaluesof tmpandfirst->name are
always equivalent in the second disjunct at line 15 regardless of
program executions. Indeed, the SAVER-generated patch in this
case is exactly the same as the developer patch.[3]
The SAVER’s ability to fix such an error is clearly beyond the
reachoftheexistingtechniques.FootPatch,MemFix,andLeak-
Fix attempt to fix memory errors only by inserting or deleting1p = malloc(1); //o1
2if(C)
3q=p ;
4else
5q = malloc(1); //o2
6* p=1 ;
7free(q);
(a) Example codeentry
exit1,true,o1
5,¬C,o1
6,¬C,o1
7,¬C,o15,¬C,o2
6,¬C,o2
7,¬C,o23,C,o1
6,C,o1
7,C,o1allocallocϵ
use
free
unreachϵ
use
ϵ
unreachϵ
free
unreach
(b) Object flow graph
Figure 5: Example program and object flow graph
deallocators (without conditionals). However, it is impossible to fix
the use-after-free error described above with this strategy because
thereisnowaytodeallocateanunboundednumberofobjectswith
a finite number of primitive deallocators.
2.2 How SAVER Works
NowweoverviewhowSAVER works.Considerthememoryleak
error in Figure 5a: the object o1allocated at line 1 is not freed
whenthefalsebranchoftheconditionalistaken.Tofixtheerror,
SAVER inserts if(¬C) free(p) before line 7. SAVER generates
the patch with the following three steps.
Step1:ConstructingObjectFlowGraph .First,SAVERrunsa
static heap analysis to convert the input program into the objectflow graph (OFG) in Figure 5b. A vertex of the OFG represents aheap object at a certain program point and a path condition. Forexample, vertex
(6,C,o1)denotes the object o1available at line 6
whenthetruebranch( C)istakenduringprogramexecutionand
(6,¬C,o1)represents the same object o1at line 6 when the false
branch(¬C)istaken.Anedgerepresentstheprogram’scontrolflow
labeled with events that could occur for the destination object. For
example, edge (6,C,o1)free→(7,C,o1)indicates that the object o1is
freedwhenitflowsfromline6to7underthecondition Candedge
(6,¬C,o1)ϵ→(7,¬C,o1)indicatesthatnoeventsoccurfor o1under
thecondition¬C.Thisway,theOFGsummarizesthebehaviorof
all heap-allocated objects (both o1ando2) in the program.
Step2:RelabelingObjectFlowGraph .Next,SAVER attempts
tofixtheerrorbyrelabelingtheobjectflowgraph.Notethatthe
memory leak is captured by the red path in the middle of the OFG;
concatenating labels over the path produces the string of events:
alloc·ϵ·use·ϵ·unreach
whichindicatesthattheobject o1isallocatedandusedalongthe
path but it becomes unreachable without being freed. To eliminate
thismemory-leakpattern,SAVER replacestheemptylabel( ϵ)of
theedge (6,¬C,o1)ϵ→(7,¬C,o1)bythe freelabel,producingthe
following correct usage pattern of heap objects:
alloc·ϵ·use·free·unreach
Notethatitisunsafetoreplacethefirst ϵbyfree,asitintroduces
a use-after-free pattern, alloc·free·use·ϵ·unreach, which is
273useϵfree unreach
ϵfreeunreach
(a) Inserting freeϵfree freeϵ
unreach
(b) Relocating free
ϵuse free useϵ
(c) Relocating use (dereference)free freeϵ
(d) Deleting free
Figure 6: Fixing strategies that SAVER supports
absent in the original OFG. SAVER supports four types of labeling
strategies:inserting frees,deleting frees,andrelocating usesand
frees. Figure 6 shows example applications of these strategies for
eliminatingerrorpatterns.Forexample,SAVER usesthestrategy
(relocating use)inFigure6ctofixtheuse-after-freeerrorinFigure2.
Step 3: Generating a Patch .The last step is to generate the
patch,if(¬C) free(p) ,fromthenewlylabelededge (6,¬C,o1)free→
(7,¬C,o1). The patch location is between lines 6 and 7. The condi-
tional expression (¬C) of the patch comes from the path condition
of the destination object. The pointer expression pcomes from the
points-toinformationwhichissupposedtobeassociatedwitheach
vertex but omitted for simplicity in this example.
3 APPROACH DETAILS
The high-level idea described in Section 2.2 is simple but imple-
menting it for real programs is not straightforward. In this section,
we describe our approach in detail, explaining what technical is-
suesariseandhowweaddressthem.Thefirstissueisefficiency.In
reality,errorsoftenspanmultiplepathsandweneedtofinda set
of labeling operations from a large search space. In Section 3.2, we
explainthisissueandpresentanalgorithmbasedonspacereduc-
tion and pruning. Also, Section 3.1 describes our design choices for
cost-effectiveheapanalysis. Thesecondissueissafety.Ensuring
safetyrequiresexactreasoningaboutprogramsemantics.However,
any static analysis results are inexact, so care is needed when rela-
belingobjectflowgraph(Section3.2)andtransformingtheresult
into actual patches (Section 3.3).
Program and Error Report .Let us first define programs and
error reports, which are given as input to SAVER.
ThefirstinputtoSAVERisaprogram Prepresentedbyacontrol
flow graph (C,/arrowhookleft→,ce,cx), whereCdenotes the set of program
points,/arrowhookleft→⊆C×Cisthesetofflowedges,and ceandcxarethe
entry and exit points of the program. A program point c∈Cis
associated with a command, denoted cmd(c):
cmd→x:=y|x:=∗y|∗x:=y|alloc(x)|free(x)|assume(b)
b→x=n|x/nequaln|x=y|x/nequaly
A command is either copy ( x:=y), load (x:=∗y), store (∗x:=
y),heapallocation( alloc(x)),deallocation( free(x)),or assume(b)
wherebdenotesabranchcondition.Althoughweconsiderasimple
pointerlanguagewithoutfunctionsforpresentation,SAVERworks
in interprocedural settings and supports the full C language.
The second is an error report R=(c1,ev1,c2,ev2), wherec1
andc2are program points and ev1andev2areevents. We call(c1,ev1)and(c2,ev2)sourceandsink,respectively.Memoryerrors
are specified with five types of events:
ev1,ev2∈Event={alloc,free,use,def,unreach}.
For example, the following memory leak alarm reported by a static
analyzer (e.g., Infer [10])
An object allocated at line 1 is unreachable at line 5
is represented by (1,alloc,5,unreach). Note that ev1andev2deter-
minetheerrortype:memoryleak,double-free,anduse-after-free
are represented by (c1,alloc,c2,unreach),(c1,free,c2,free), and
(c1,free,c2,use/def), respectively.
3.1 Step 1: Constructing Object Flow Graph
The first step of SAVER is to construct an object flow graph by
statically analyzing the heap-related behavior of the program.
Static Heap Analysis .Asobjectflowgraphsplaykeyrolesin
ourapproach,wehavecarefullydesignedastaticheapanalysisthat
can generate precise object flow graphs in practice. The key design
decisions are path-sensitivity and heap abstraction. When fixing
anerror,itisimportanttoisolatetheerrorpathfromthenormal
executionpaths.Tothisend,wedevelopedapath-sensitiveanalysis
that uses relational invariants as the path information and merges
them selectively for scalability. Also, dynamic data structures such
as linked lists are used extensively in real-world C programs. To
accuratelydistinguishthememoryobjectsstoredindatastructures
fromthoseoutside,werepresenteachheapobjectbyapairofits
allocation-site and variables that must point-to the object.
The abstract domain of the analysis is defined as follows:
A∈D=C→P(State)
s∈State =PC×Store
π∈PC=P(Var×{=,/nequal}×(Var+Z))
σ∈Store =Loc→P(Heap)
l∈Loc=Var+Heap
h∈Heap =AllocSite×P(Var)
a∈AllocSite⊆C
Adomainelement A∈Disafinitetablethatmapseachprogram
point to a set of reachable states. A state s=(π,σ)∈Stateat
program point c∈Cconsists of a path condition ( π∈PC) and a
store(σ∈Store).Thepathcondition πisacollectionofbranches
that have been taken up to the program point c, where a single
branch denotes a relation between two variables (or a variable and
a number). The store σis a map from locations to heap objects,
representing the may-point-to information. A location l∈Locis
either a variable or of a heap object. We represent a heap object
h∈Heapbyitsallocationsite( AllocSite)andasetofmust-point-to
variables (P(Var)).
Theaimofthestaticanalysisistocomputealeastfixedpoint
(lfpF) of the semantic function F∈D→Ddefined as follows:
F(X)=λc.fc/parenleftBig/uniondisplay
c/prime/arrowhookleft→cX(c/prime)/parenrightBig
wherefc:P(State)→P(State)is the transfer function at c:
fc(S)={(fPC
c(π),fStore
c(σ))|(π,σ)∈S}.
274We update path conditions by fPCc:PC→PCas follows:
fPC
c(π)=⎧⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎩π∪{b}· · · cmd(c)=assume(b)
π\Kill(π,x)···cmd(c)=x:=y
π\Kill(π,x)···cmd(c)=x:=∗y
π···otherwise
where Kill(π,x)={(x/prime,_,x/prime/prime)∈π|x=x/prime∨x=x/prime/prime}∪{(x/prime,_,n)∈
π|x=x/prime}denotestherelationsthatarekilled.Weupdatestores
byfStorecas follows:
fStore
c(σ)=Tc/parenleftBig
ϕc(σ)|reach(ϕc(σ))/parenrightBig
which first computes the effect of the command ( ϕc:Store→
Store),projectsthestoresonthereachablelocations(i.e. reach(σ)=
lfp(λR.Var∪{l∈σ(l/prime)|l/prime∈R})), and renames the locations in
stores (i.e.,Tc(σ)=/unionsqtext
(l,H)∈σ[τc(l)/mapsto→{τc(h)|h∈H}] where
each location is updated by τc:Loc→Loc). Stores are updated as
follows:
ϕc(σ)=⎧⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎩σ[x/mapsto→{(c,{x})}]···cmd(c)=alloc(x)
σ[x/mapsto→σ(y)] ···cmd(c)=x:=y
σ[x/mapsto→/uniontext{σ(l)|l∈σ(y)}]···cmd(c)=x:=∗y
σ[S
x/mapsto→σ(y)][Wxweak/mapsto→σ(y)]···cmd(c)=∗x:=y
σ ···otherwise
where S x={(a,X)∈σ(x)|x∈X}is a set of strong-updatable
locationsandW x=σ(x)\Sisasetofweak-updatablelocations,
andσ[X/mapsto→Y] andσ[Xweak/mapsto→Y] mean strong and weak updates to
locations X, respectively. The variables in objects are updated by
τc((a,X))=
⎧⎪⎪⎨⎪⎪⎩{(a,X\{x})}···cmd(c)=alloc(x)orx:=∗y
{(a,X\{x}∪{x|y∈X})}· · ·cmd(c)=x:=y
{(a,X)}· ··otherwise
whereweassume τcdoesnotremove xfromXwhen(a,X)wascre-
ated byϕcwhencmd(c)=allocx. When the location is avariable,
we define τc(x)={x}.
ObjectFlowGraph .LetA=lfpFbetheresultofthestaticheap
analysis. From the program P=(C,/arrowhookleft→,ce,cx)and the analysis
resultA,weconstruct anobjectflowgraph.Anobject flowgraph
G=(V,E,M,Λ)consists of four components:
V⊆C×PC×Heap,E⊆V×V,
M∈V→P(Exp),Λ∈E→Event∪{ϵ}
whereVisthesetofvertices, Eisthesetofedges, Mmapsvertices
to points-to expressions, and Λdenotes the labels of the graph.
We generate the vertices Vas follows:
V={(c,π,h)|c∈C\{ce,cx}∧(π,σ)∈A(c)∧h∈range(σ)}
∪{(ce,true,⊥),(cx,true,⊥)}
A vertex is a triple (c,π,h)of a program point ( c), a path condition
(π),andaheapobject( h).Ateachprogrampoint c∈C,weconsider
every reachable state ( π,σ) and generate a vertex (c,π,h)for each
accessible heap object h(i.e.h∈range(σ)). Also,Vincludes two
specialvertices:theentry (ce,true,⊥)andexit(cx,true,⊥)ofthe
object flow graph, where truemeans the empty path condition and
⊥a dummy heap object.EdgesEaregeneratedbasedontheabstractsemanticsoftheheap
analysis.Thatis, Eincludes((c1,π1,h1),(c2,π2,h2))if(c1,π1,h1)
generates (c2,π2,h2)during the analysis:
c1/arrowhookleft→c2∧π2=fPC
c2(π1)∧h2=τc2(h1).
Inaddition, Eincludesedgesfromtheentry (ce,true,⊥)tothever-
ticeswithoutpredecessorsandfromtheverticeswithoutsuccessors
to the exit (cx,true,⊥).
The map Massociates each vertex (i.e., heap object) with the
pointer expressions that may evaluate to the object:
M((c,π,h))={e∈Exp|(_,σ)∈A(c)∧h∈[[e]](σ)}.
whereExpis the set of finite access paths (i.e., Exp={x,∗x|x∈
Var}forourlanguage)and[[ e]] :Store→P(Heap)istheevaluation
function for pointer expressions defined as follows:
[[x]](σ)=σ(x),[[∗x]](σ)=/uniondisplay
{σ(l)|l∈σ(x)}.
The map Λlabels the graph with events:
Λ((c1,π1,h1),(c2,π2,h2))=
⎧⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩alloc ifcmd(c
2)=alloc(x)∧h2=(c2,{x})
free ifcmd(c2)=free(x)∧x∈M((c2,π2,h2))
def ifcmd(c2)=∗x:=y∧x∈M((c2,π2,h2))
use ifcmd(c2)=x:=∗y∧y∈M((c2,π2,h2))
unreach if(c2,π2,h2)=(cx,true,⊥)
ϵ(empty event ) otherwise
Theedge ((c1,π1,h1),(c2,π2,h2))islabeledas allocifc2isthecom-
mand thatallocates the heap object h2(that is,cmd(c2)isalloc(x)
andh2is pointed to by the variable x). We label the edge as freeif
c2may deallocate the heap object h2. In our implementation, we
distinguish may- freeand must- freeevents to more precisely check
thesafetyofpatchesinthenextsubsectionbuthereweomitthis
detail for simplicity. Labels defanduseare given when the heap
h2isdefinedorread,respectively.Finally,theedgegetsthelabel
unreachwhen the heap h2is no longer accessible.
3.2 Step 2: Relabeling Object Flow Graph
The second step of SAVER is to relabel the object flow graph
G=(V,E,M,Λ)so that the reported error R=(c1,ev1,c2,ev2)
is eliminated with the new labeling.
ErrorPaths .Wefirstneedtoconverttheerrorreporttoasetof
errorpathsontheobjectflowgraph.Let Vc1ev2andVc2ev2bethevertices
inGthatcorrespondtothesource (c1,ev1)andsink( c2,ev2)ofthe
error report, respectively:
Vc1ev1={v∈V|v=(c1,_,_)∧∃v/prime.(v/prime,v)∈E∧Λ((v/prime,v))=ev1}
Vc2ev2={v∈V|v=(c2,_,_)∧∃v/prime.(v/prime,v)∈E∧Λ((v/prime,v))=ev2}
LetPaths(G)be the set of all paths in G. Given a path p=e1···en
(a sequence of edges), we write Λ(p)forΛ(e1)···Λ(en)(the con-
catenation of labels). The set of error paths, EP(G,R), is as follows:
EP(G,R)={p∈Paths(G)|(p0,p/turnstileright)∈Vc1ev1×Vc2ev2∧Λ(p)∈Rev1ev2}
wherep0andp/turnstilerightdenotethedestinationpointsofthefirstandlast
edges ofp, respectively, and Rev1ev2denotes the set of strings over
275events that represent the error specified by the source and sink
events. For each error type, we define Rev1ev2by regular expressions:
Ralloc
unreach=alloc(use|def)∗unreach
Rfree
free=_∗free_∗free_∗
Rfree
use=Rfree
def=_∗free_∗(use|def)_∗
The meaning is intuitive. Ralloc
unreachdescribes memory leak patterns:
amemoryleakerroroccursifanallocatedobjectbecomesunreach-
able without being deallocated. Rfree
freeandRfreeuse(orRfree
def) describe
double-free and use-after-free patterns, respectively.
Labeling Operators .We relabel the graph with labeling opera-
tors.Alabelingoperatorisafunctionthattransformsthelabelmap
(Λ) of the object flow graph. Labeling operators have four types:
free+
e(Λ)=Λ{e/mapsto→free} ifΛ(e)=ϵ
free−
e(Λ)=Λ{e/mapsto→ϵ} ifΛ(e)=free
free/leadsto
e1,e2(Λ)=Λ{e1/mapsto→ϵ,e2/mapsto→free}ifΛ(e1)=free∧Λ(e2)=ϵ
use/leadsto
e1,e2(Λ)=Λ{e1/mapsto→ϵ,e2/mapsto→use}ifΛ(e1)=use∧Λ(e2)=ϵ
Thefree+eoperatorreplacesthelabelofedge ebyfreeifehasthe
emptylabel( ϵ).The free−eoperatorremovesthe freelabelofe.The
free/leadstoe1,e2anduse/leadstoe1,e2operatorsmovethe freeanduselabelsfrom
e1toe2,respectively.Weassumethelabelingoperatorsactasan
identity function if the conditions (given on the right-hand side)
are not met. Given a set O={o1,...,on}of labeling operators,
wewriteO(Λ)forthenewlabelmapobtainedbyapplyingevery
labeling operator oitoΛ: i.e.,O(Λ)=(o1◦···◦on)(Λ).
Finding Labeling Operators .Our goal is to find a set Oof
labelingoperatorsthatcanremovetheerrorpathsintheoriginal
object flow graph. Let G/prime=(V,E,M,O(Λ))be the object flow
graph whose labels are replaced by O. We need to findOwith the
following properties:
(1)The reported error does not appear in G/prime: i.e.,EP(G/prime,R)=∅.
(2)No newerrors, which areabsent in G, areintroduced in G/prime.
(3)Ois semantics-preserving; fixing an error does not cause
the program to behave differently in normal execution.
Algorithm. Ouralgorithmtosearchforthelabelingoperators
Osatisfying the three conditions is given in Algorithm 1. Given
the object flow graph Gand error report R, the algorithm produces
a setCof all possible solutions, where a solution corresponds to
asetoflabelingoperatorsmeetingtheconditions.Thealgorithm
uses a worklist Wthat is a set of pairs; each pair (O,S)consists
ofa solutioncandidate Oanda search space S. The search space
is initialized at line 2, where InitSearchSpace (G,R)determines the
setofsearchspacesthatareappropriateforfixingtheerror R.At
line 4, we pop a work item (O,S)and remove it from the worklist.
We relabel the graph Gwith the current solution O(line 5) and
generate the new graph G/prime.I fG/primedoes not contain the error R(line
6)weincludeOininthesolutionset C(line7).Atline9,wereduce
thesearchspacebypruningoutlabelingoperatorsin Sthatbecome
unsafeunderthenewlabeling( G/prime).Whentheresultingsearchspace
S/primeisempty(line10),thealgorithmmovesontootherworkitems
(line11).Otherwise,itselectsanoperator ofromS/primeandbranches
onobyaddingnewitems (O∪{o},S/prime/prime)and(O,S/prime/prime)totheworklist.The algorithm repeats the procedure until the worklist becomes
emptyorhitsapredefinedtimelimit.Below,wedescribethetwo
key components: InitSearchSpace andSafe.
Weinitializesearchspacesbasedontheerrortype.Recallthat
wehavefourtypesoflabelingoperators: free+e,free−e,free/leadstoe1,e2,and
use/leadstoe1,e2.WhenR=(c1,ev1,c2,ev2)indicatesamemory-leak(i.e.,
ev1=alloc,ev2=unreach), we use free+eandfree/leadstoe1,e2, meaning
that we attempt to fix memory leaks by inserting or relocatingdeallocation statements. We fix double-free errors by removingdeallocation statements (
free−e). For use-after-free errors, we at-
tempttorelocatestatementsthatdeallocateorusethetargetobject
(free/leadstoe1,e2,use/leadstoe1,e2). Formally, InitSearchSpace is defined as:
InitSearchSpace (G,(c1,ev1,c2,ev2))=
⎧⎪⎪⎪⎪⎨⎪⎪⎪⎪⎩{S
ML
free+,SML
free/leadsto}ifev1=alloc∧ev2=unreach
{SDF
free−} ifev1=free∧ev2=free
{SUAF
free/leadsto,SUAF
use/leadsto}ifev1=free∧(ev2=use∨ev2=def)
whereSML
free+,SML
free/leadsto,SDF
free−,SUAF
free/leadsto, andSUAF
use/leadstoare search spaces
for memory leak (ML), double-free (DF), and use-after-free (UAF ):
SML
free+={free+
e|e∈E∧Λ(e)=ϵ∧e∈EP(G,R)}
SML
free/leadsto={free/leadsto
e1,e2|e1,e2∈E,Λ(e1)=free∧Λ(e2)=ϵ∧
e1/nelementEP(G,R)∧e2∈EP(G,R)}
SDF
free−={free−
e|e∈E∧Λ(e)=free∧e∈EP(G,R)}
SUAF
free/leadsto={free/leadsto
e1,e2|e1,e2∈E,Λ(e1)=free∧Λ(e2)=ϵ∧
e1∈EP(G,R)∧e2/nelementEP(G,R)∧e1/leadstoe2}
SUAF
use/leadsto={use/leadsto
e1,e2|e1,e2∈E,Λ(e1)=use∧Λ(e2)=ϵ∧
e1∈EP(G,R)∧e2/nelementEP(G,R)∧e2/leadstoe1}
Whendefiningthesesearchspaces,wedonotconsideroperators
thatareirrelevanttothecurrenterrorreport R.Forexample,when
fixing a memory leak error (c1,alloc,c2,unreach)by inserting a
deallocationstatement( free+e),thelocation( e)mustbecontained
intheerrorpaths EP(G,R).Thus,weexcludeallthe free+eoperators
from the search space whose location ( e) is on the outside of the
error paths. We apply similar rules for other error types too.
The Safe(G,o)predicate checks whether the new labels of G
obtained by applying the labeling operator otoGintroduces no
newerrors(safe)ornot.Wecheckthissafetyofalabelingoperator
basedongraphreachability.Let Eevbetheedgesof Gwhoselabels
are equivalent to ev,/leadstobe the reachability relation for G(e1/leadstoe2
iffe2isreachablefrom e1),andE1/precedesequaldomeandE1/precedesequalpostdomebethe
factsthatthe edgeset E1collectively dominateandpost-dominate
the edgee, respectively.
Then, we define Safe(G,o)for each type of o. When inserting
a deallocation statement ( o=free+e), we check if doing so does
not introduce new double-free or use-after-free errors. This safety
condition can be expressed as follows:
∀e/prime∈Efree∪{e}.e/prime/negationslash/leadstoe∧∀e/prime∈Efree∪Euse∪Edef.e/negationslash/leadstoe/prime.
Wheno=free−e,weneedtoensurethatnomemoryleakerrorsare
introduced: Efree/precedesequaldome∨Efree/precedesequalpostdomeWheno=free/leadstoe1,e2,we
276Algorithm 1 Finding Labeling Operators
Input:Object flow graph Gand error report R
Output: A setC={O1,...,On}of sets of labeling operators
1:C←∅
2:W←{(∅,S)|S∈InitSearchSpace (G,R)}
3:repeat
4:((O,S),Wrest)←pop a work item from W
5:G/prime←O(G) ⊿relabelGwithO
6:ifEP(G/prime,R)=∅then⊿Rdoes not appear in G/prime
7: C←C∪{O} ⊿addOtoCas a solution
8:end if
9:S/prime←{o∈S|Safe(G/prime,o)}⊿prune out unsafe operators
10:ifS/prime=∅then
11: W←Wrest
12:else
13: (o,S/prime/prime)←pop a labeling operator from S/prime
14: W←Wrest∪{(O∪{o},S/prime/prime),(O,S/prime/prime)}
15:end if
16:untilW=∅or timeout
17:returnC
check the condition:
(Efree∪{e2}/precedesequaldome1∨Efree∪{e2}/precedesequalpostdome1)∧
∀e∈(Efree\{e1})∪{e2}.e1/negationslash/leadstoe2∧
∀e∈Efree∪Euse∪Edef\{e1}.e2/negationslash/leadstoe1
wherethefirstlineensurestheabsenceofmemoryleak,thesecond
linechecksdouble-free,andthethirdlineguaranteesnodouble-free
anduse-after-freeerrorsareintroduced.(Intheaboveconditions,
ourimplementationdistinguishesmay-freeandmust-freeevents
formoreprecisesafetyguarantees,whichisomittedhereforsim-
plicity.)Finally,when o=use/leadstoe1,e2,weneedtoensurethatnouse-
after-freeerrors areintroduced ( ∀e∈Efree.e/negationslash/leadstoe2)and relocating
usedoes not cause the program to have different semantics:
(∄e∈Edef.e2/leadstoe∧e/leadstoe1)∧e2/precedesequaldome1
Wecheckthesemantics-preservingpropertybyensuringthatno
definitions exist between e1ande2ande2dominates e1.
Note that our algorithm produces a set Cof solutions such that
eachsolutionO∈Cconsistsoflabelingoperatorsofthesametype.
Forexample,asingle Odoesnotcontainboth free+e1andfree−e2.W e
made this design choice because this single type restriction does
notimpairtherepairabilityofouralgorithmtoomuchbutimproves
its efficiency significantly. Without this restriction, even unsafe op-
erators may become safe as the algorithm progresses. For example,
consider the path v1ϵ− →v2free−−−→v3, where the operator free+
(v1,v2)
is unsafe at the moment but it becomes safe when free−
(v2,v3)is
allowedlater.Thus,weshouldconsiderallthepossiblecombina-
tionsofthelabelingoperatorsineachsearchspace,whichcanbe
avoided with the restriction as unsafe operators never become safe.
3.3 Step 3: Generating a Patch
The last step of SAVER is to generate a patch from the set Cof
labeling operator sets produced by Algorithm 1. When C=∅,
SAVER failsto fixtheerrorand reportthatfailure.Otherwise, weconsidereachoperatorset O∈Candtrytoconvertittoapatch.
When the conversion is successful, SAVER returns the resulting
patchasitsfinaloutcome.If Oisnotconvertible,wemoveonto
the next candidate O/prime∈C. If no operators in Care convertible,
SAVER fails to generate a patch.
Next,wedescribehowtoconvertaset Oofoperatorsintoapatch.
Basically,weconverteachlabelingoperatorin Ointoaconditional
deallocator using the path condition and expression obtained from
the object flow graph. We explain the detail depending on the
typeofoperatorsin O.SupposeO={free+e1,..., free+en}.Wefirst
partitionObasedonprogrampointsusingtheequivalencerelation:
free+
ei∼free+
ej⇐⇒dest(ei)=dest(ej)
wheredest(_,(c,_,_))=cextractsthedestinationprogrampoint
from the given edge. Let Qbe the set of all equivalence classes
associated with corresponding program points:
Q={(dest(e),O)|O∈O/∼∧free+
e∈O}
whereO/∼denotes the quotient set of Oby∼. Now, we convert
each partition (ci,Oi)∈Qinto the conditional deallocator:
if(πi) free(expi)
andputitattheprogrampoint ciofinputtheprogram.Thepath
condition πiis collected from the object flow graph as follows:
πi=/logicalordisplay
(_,πj,_)∈Viπj
whereViis the set of the destination objects, i.e., Vi={v|free+e∈
Oi∧e=(_,v)}.Wechooseansafeexpression expifromthemap
Mof the object flow graph such that expimay point to the objects
inVibut never points to other objects at ci:
exp∈/intersectiondisplay
v∈ViM(v)∧exp/nelement/uniondisplay
V/prime
i\ViM(v)
whereV/prime
iis the set of all objects available at ciwhose path con-
ditions are compatible with πi:V/prime
i={(ci,π/prime,_)∈V|πi∧
π/primeis satisfiable}.Ifnoexpressionssatisfyingtheconditionareavail-
able, the current partition (ci,Oi)is not convertible and so is O.
Other cases are simpler because we do not need to synthesize
theexpression( expi).WhenO={free−e1,..., free−en},wetakethe
same steps described above to obtain πifor each partition (ci,Oi)
but in this case we insert if(¬πi) free(expi)atciafter deleting
thedeallocation statementoriginallylocated at ci.Here, wereuse
the expression expiof the original deallocator.
WhenO={free/leadsto
e1,e/prime
1,..., free/leadsto
en,e/primen}, we take similar steps but
partitionOwith the following equivalence relation:
free/leadsto
ei,e/prime
i∼free/leadsto
ej,e/prime
j⇐⇒dest(ei)=dest(ej)∧dest(e/prime
i)=dest(e/prime
j)
which results in the partitions Q={(c1,c/prime
1,O1),...,(cn,c/primen,On)}.
Weconverteach (ci,c/prime
i,Oi)intoapatchbyremovingtheoriginal
deallocatorat ci,inserting if(¬πi) free(expi)atci,andinserting
if(¬π/prime
i) free(expi)atc/prime
i. Here the path conditions πiandπ/prime
i
are obtained with respect to ciandc/prime
i, respectively, in a similar
way described above. The expression expicomes from the original
deallocatorat ci.WhenO={use/leadsto
e1,e/prime
1,..., use/leadsto
en,e/primen},wesimilarly
compute Q={(c1,c/prime
1,O1),...,(cn,c/primen,On)}. For each (ci,c/prime
i,Oi),
we obtain the path conditions πiandπ/prime
iand generate a patch by
277replacingtheloadcommand x:=∗yatcibyif(πi)x:=telse
x:=∗ywith a fresh variable t, and put if(π/prime
i)t:=∗yatc/prime
i.
3.4 Improving Scalability
Thecorealgorithmdescribedsofarisabletogenerateexpressive
yetsafepatchesbutisnotapplicabletolargeprograms.Inpractice,
we use two techniques to improve its scalability.
Slicing.We slice the input program with respect to the given
errorreport R=(c1,ev1,c2,ev2).Weusethistechniquetoreduce
the cost of applying SAVER in interprocedural settings. Let fsrc
andfsinkbethefunctionsthatcontainthesource( c1)andsink( c2)
programpoints.Wefirstfindthefunction fparentthatisthenearest
common caller of fsrcandfsinkon the call-graph of the program.
The function fparentbecomes the entry point of the SAVER’s heap
analysis, slicing out all functions in the program that are unreach-
ablefrom fparent.Often,theresultingslicedprogramisnotsmall
enough to be analyzed. Thus, we use a pre-analysis (a context-
sensitive and flow-insensitive points-to analysis) to further slice
out the functions that do not have side-effects on the heap objects
that have dependencies on the objects specified by the error report
R. We also slice out large recursive functions as well, which are
expensive to analyze but doing so provides little precision bene-fit. In place of the functions sliced out, we use the result of thepre-analysis to preserve the soundness of the heap analysis. For
example, SAVER starts from fparentwith the pre-analysis result.
Selective Path-Sensitivity .It is well-known that applying
expensive abstractions selectively is critical for obtaining cost-effective static analysis [
24,25,35,45,46]. In our case, we apply
path-sensitivity of the static heap analysis only when doing sois likely to improve the final fix rates. To support selective path-
sensitivity, we modify the definition of the semantic function Fas
follows:
F(X)=λc.merge/parenleftBig
fc/parenleftBig/uniondisplay
c/prime/arrowhookleft→cX(c/prime)/parenrightBig/parenrightBig
where merge(S)={/unionsqtextS/prime|S/prime∈(S/mergable )}partitions the
statesSand merges each partition into a single state with the
equivalence relation mergable⊆State×State. When two states
((π1,σ1),(π2,σ2)) are joined, the path-condition is generalized (i.e.,
π1∩π2)andthepoints-toinformationiscombined(i.e., σ1/unionsqσ2).We
define two states are mergeable if they are equivalent with respect
to(1)thesetofnull-pointing-variables,(2)thesetofvariablespoint-ingtoaliasedobjects,and(3)thesetofpairsofreturnvariablesand
their values. We designed these three criteria since they capture
thekeyfeaturesofprogramexecutionsrelatedtomemoryerrors
and help to analyze normal executions precisely while merging
erroneous paths. The first feature describes a set of variables only
pointing to null, which captures execution paths along which apointer is nullified or failed to be allocated. The second featureindicates whether objects are appended to a data-structure suchas lists or not. The third feature is to distinguish between states
withdifferentreturnvalueswhichareusuallyusedasasignalof
memory errors.4 EVALUATION
Inthissection,weevaluateSAVER.ThemainobjectiveistoseehoweffectivelySAVERcanfixmemoryerrorsinpracticeandcompareit
with existing techniques (Sections 4.1). In addition, we discuss the
importanceofthetechniquesforimprovingscalability(Section4.2).
Allexperiments weredone onavirtual machinerunning Ubuntu-
16.04with4virtualCPUsand32GBmemory,poweredbyIntelCore
i7-7700 processor.
Implementation .WeimplementedSAVERasastand-alonetool
in 5,400 lines of OCaml code. We used the front-end of Infer [ 23],
whichtranslatesCprogramsintoanintermediaterepresentation
(called SIL). We used 1-CFA for the pre-analysis in Section 3.4 and
full context-sensitivity (except for recursion) for the heap analysis
in Section 3.1. For common memory-related standard libraries (e.g.
memcpy, strdup), we used hand-crafted models to consider their
effectsduringtheheapanalysis.Modelinglibraryfunctionsdidnotrequiresignificanteffort.Wemodeled14standardlibraryfunctions,
10ofwhichcouldbesimplymodeledintermsofthemalloc,free,or
exit functions. We wrote the body of the remaining 4 library func-
tions.Otherstaticapproaches[ 18,34,60]alsorequirehand-crafted
models. For example, FootPatch [ 60] uses the models provided by
Infer. We set the timeout of Algorithm 1 to 10 minutes.
The implementation of SAVER is safe in principle. Our imple-
mentationofthestaticheapanalysisinSection3.1andpre-analysisinSection3.4supportsthefullintermediatelanguageanditsseman-tics.Notethatinaccurate(incomplete)heapanalysisorpre-analysis
may cause lower fix-rates but they never harm safety. Similarly,
usingtheoptimization techniquesinSection3.4maycause lower
fix-ratesbutneverharmsafety.Otherimplementationchoicesdo
notaffectsafetytoo.Context-sensitivityandtimeoutonlyaffectfix-rates.Thelibrarymodelscaptureallrelevantheap-effects.Nonethe-
less, SAVER might produce unsafe patches due to the following
issues. Ourheapanalysisassumesthatunknownprocedurecalls
(e.g.,librarycallswithoutmodeling)returnsarbitraryvaluewithout
side-effects.Theanalysisalsoignoreslow-levelpointerarithmeticsthatbreakthetypicalassumptionsofasimplememorymodel.Also,
the front-end of Infer may fail to handle some functions due to
engineeringissues.Thesearepotentialsourcesofunsafepatches,
though we observed no such cases in experiments.
4.1 Effectiveness for Fixing Errors
RecallthatouroriginalmotivationistocombineSAVERwithstatic
bug-finders,sothaterrorsarenotonlyfoundbutalsofixedauto-
matically. To demonstrate this, we used the memory-leak detector
of Infer[ 10,23],anopen-sourcetooldeployedwithinFacebook,
and compare SAVER and FootPatch [ 60] in this context. We used
Infer-0.9.3, since FootPatch is implemented on top of it.
Setup.Weused10open-sourceCprogramsshowninthefirst
column of Table 1. The three programs (rappel, Swoole, and lxc)
came from [ 60] since they were used for evaluating FootPatch re-
gardingmemoryleaks. Inaddition,wecollected7benchmarksfromGitHub.Wesearchedprogramssuchthat1)Inferproducesnobuild
errors and2) reports atleast 1 truepositive and <100total alarms
(foreaseofmanualinspection).Wealsotriedtocollectbenchmarks
278Table1:ComparisonofSAVERandFootPatchonfixingmemoryleaksdetectedbyInfer.Foreachprogram,#Tand#Fdenote
thenumbersoftrueandfalsealarms(i.e.errorreports)producedbyInfer,respectively. Pre(s)reportsthetimetakenbythe
pre-analysis of SAVER(pre-analysis is run only once and its result is shared by every error fix). Fix(s)reports the total time
taken by each tool in attempting to fix the reported errors. The patch statistics are given in columns G,,/triangleand, where
the subscripts T and F indicate whether the result is for true or false alarms, respectively. G: # of generated patches. :#
of successful patches that fixed errors (without introducing new errors). /triangle: # of incomplete patches that are safe but fail to
completely fix errors. : # of unsafe patches that introduce new errors.
Infer SAVER FootPatch [60]
Program kLoC #T #F Pre(s)Fix(s)GTT/triangleTTGFFFix(s)GTT/triangleTTGFF
rappel (ad8efd7) 2.2 1 0 2.2 0.0 1 1 0 0 0 0 8.9 1 1 0 0 0 0
flex (d3de49f) 22.3 3 4 26.3 2.5 0 0 0 0 0 0 51.0 0 0 0 0 1 1WavPack (22977b2) 31.2 1 2 44.6 22.1 0 0 0 0 0 0 67.9 0 0 0 0 2 2Swoole (a4256e4) 43.0 15 3 88.5 10.1 11 11 0 0 0 0 392.5 9 7 0 2 1 1lxc (72cc48f) 49.9 3 5 230.6 5.8 3 3 0 0 0 0 179.6 0 0 0 0 1 1p11-kit (ead7ara) 62.9 33 9 646.2 288.8 24 24 0 0 0 0 566.4 8 7 1 0 2 2x264 (d4099dd) 73.2 10 0 144.3 9.9 10 10 0 0 0 0 426.9 2 2 0 0 0 0recutils-1.8 92.0 10 11 144.1 44.4 8 8 0 0 0 0 662.2 3 2 1 0 0 0
inetutils-1.9.4 116.9 4 5 44.8 2.5 4 4 0 0 0 0 182.1 0 0 0 0 0 0snort-2.9.13 320.8 16 27 2372.0 216.0 11 10 1 0 0 0 4636.4 3 0 0 3 19 18
Total 814.4 96 66 3743.6 602.1 72 71 1 0 0 0 7173.9 26 19 2 5 26 25
from diverse domains: network (inetutils), text-processing (flex,
recutils),multimedia(WavPack,x264),andsecurity(p11-kit,Snort).
Running Infer on those 10 programs produced a total of 162
alarms. We manually classified the alarms into 96 true and 66 false
positives. Then we (automatically) converted each alarm into an
errorreportforSAVER.Weincludedfalsepositivesaswellinour
evaluation,becauseweassumeausecaseofrepairtoolsincombina-
tionwithstaticbug-findersinanend-to-endwaywithoutrequiring
humans to classify static analysis alarms into true or false.
When running Infer, we enabled the --headers option to ana-
lyzeheaderfilesaswell.Withoutthisoption,Inferskipstranslating
headers into IR, which results in imprecision and increases false
alarms.Thisiswhythenumber(18)ofalarmsforSwooleinTable1
is less than that(20) reported in [60].
In Table 1, we compared SAVER with FootPatch only, since
other tools, MemFix [ 34] and LeakFix [ 18], were not scalable or
robustenoughtoanalyzethebenchmarkprograms.MemFixdidnotterminateforthebenchmarkprogramsexceptforrappel,forwhich
it successfully fixed the reported error. LeakFix also ran on rappel
butproducednopatches.Forotherprograms,LeakFixproduced
runtime errors. We ran FootPatch in its global mode [ 60] to allow
it todiscover more patch candidatesfrom the entireprogram. We
obtained FootPatch from its public website.2
ForeachpatchgeneratedbySAVERandFootPatch,weman-
ually checked whether the patch fixed the target error correctly.For true alarms, we say a patch is correct (
T)i fi tr e m o v e st h e
reported memory-leak alarm completely (e.g. fixing all memory
leaks betweenthe source and sinkpoints specified byeach alarm)
and introduces no new errors. If the generated patch introduces
anewerror,wecounteditasunsafe( T,F).Theremainingcase
(i.e.,thepatchissafebutfailstofixtheerrorcompletely)iscounted
as incomplete (/triangleT).
2https://github.com/squaresLab/footpatchResult.Table 1 shows the experimental results. For the 96 true
positives, SAVER generated 72 patches. Among them, 71 were cor-
rect and fixed errors completely, leading to a 74% fix rate (71/96).
Onekeycontributortothishighfixratewastheabilitytogener-
ate conditional patches. For example, all of the correct patches for
snort-2.9.13 involve conditional.
ItisnotablethatSAVERgeneratednopatchesforfalsealarms.
This is mainly because SAVER aims to ensure the patch safety;
inmostcases,SAVERnaturallyfailsto“fix”falsealarmsbecause
otherwiseitneedstofindawaytomodifyaprogramthatisalreadycorrectwithoutintroducingerrors,whichismuchmorechallenging
than transforming an incorrect program into correct one.
Meanwhile,FootPatchgenerated26patchesfortruealarms,19
ofwhichwerecorrect,leadingtoa20%fixrate(19/96).Theremain-
ing7patcheswereclassifiedinto2incompleteand5unsafeones
(introducinguse-after-freesordouble-frees).Forthe66falsealarms,
FootPatch generated 26 patches where 25 were unsafe. Note that
mostofthefalsealarmpatchesareunsafe,implyingthat“fixing”
false alarms correctly is challenging in practice and a practical tool
needstoensuresafetytoavoidit.Intotal,FootPatchgenerated
52patchesforall162(trueandfalse)alarmsand30(58%)ofthem
were unsafe and introduced new errors.
Eachof SAVERandFootPatchgeneratedoneincompletepatch.
SAVER failed to completely fix an error in snort-2.9.13. Consider
the following simplified situation:
1intf(void*p) {
2if(...)return0;// memory leak
3if(...)return-1;// memory leak
4return0;// no memory leak }
5intg(void*p) {
6x = f(p);
7// Objects pointed by `p` are used
8/* SAVER: if(x==-1) free(p); */ }
279Table 2: Effectiveness for use-after-frees and double-frees.
ProgramAvg.
kLoCTime(s)UAF DF
#C#C
lxc 44.5 3448.3 8 4 6 0p11-kit 57.2 2732.5 2 1 2 2grub 292.5 1273.2 10 6 6 2
Total 394.2 7454.0 20 11 14 4
where the function fcan return 0 with and without memory
leaks.Tofixthis,SAVERinsertedaconditionalpatch, if(x==-1)
free(p), at the end of g, which partially eliminates the memory
leak error but some leaks still remain. In this case, it would not be
possible to fix the memory leak completely without modifying the
bodyoffsothatthenormalanderroneouspathsaredistinguished
by the associated return values.
FootPatch generated one incomplete patch for each of recutils-
1.8andp11-kitbecauseofitssimplefixingstrategy.Forexample,the
buf_new function in rectuils-1.8 allocates a base object whose field
is also allocated by buf_new, both of which cause memory leaks.
However, FootPatch inserted a single deallocator for the base ob-
ject and thus failed to free its field object. By contrast, SAVER iden-
tified bothleaky objects andgenerated a correctpath by inserting
multiple deallocators.
Use-After-Free andDouble-Free .Wealsoevaluatedtheeffec-
tivenessof SAVER forfixinguse-after-freesanddouble-frees.For
thisevaluation,weused34errorreportsmanuallycollectedfrom
open-sourceprojects.Wecouldnotuseautomatedbug-detectors
for this evaluation because Infer detected no errors but only pro-
ducedfalsealarmsforourbenchmarksandwecouldnotfindother
alternativetoolspubliclyavailable.Wecollectedtheerrorreports
fromprojectsthatcontainatleastone"use-after-free"(UAF)and
"double-free"(DF)keywordsintheircommitmessagesinGitHub.
We identified lxc and p11-kit in the memory-leak benchmarks, and
additionally collected grub from GNU projects, which had rela-
tively many UAF/DF commits. We collected allerror commits from
eachprojectandmanuallygenerated34errorreportsbyinspecting
commit messages or fixes by developers.
For each report, we ran SAVER on the version of the program
where the corresponding error commit was made, and manually
checked whether a patch fixed the target error correctly. For some
commits, we could not use their exact versions because they did
notalwayssucceedinbuilding.Inthosecaseswetriedtoaddress
the build errors by modifying the source codes or injecting the
error in question into another commit version without build issues.
If this attempt failed to resolve the issues, we instead identified
submodules containing relevant parts to the error of each program
and compiled only these submodules.
Table2showstheexperimentalresult. Avg.kLoC reportsaver-
agedLoCsacrosscollectedcommitversionsinarepository. Time(s)
reports total time taken in attempting to fix (including the pre-
analysis of SAVER) the errors in each project. The number of error
commitsfromeachprojectisgivenincolumn #C.Forthe34use-
after-freesanddouble-frees,SAVERcorrectlyfixed15errors(a44%
fixrate)intotalwithoutintroducingnewerrors.SAVERusedthreestrategiesforfixingthoseerrors.Foruse-after-frees,SAVERfixed11of20errorsbymovingfreeorusestatementsand4of14double-free
errors by deleting frees.
Limitations .Our evaluation also identified one major limita-
tion of SAVER: SAVER often fails to fix errors when they are in-
volved in custom allocators or deallocators. For example, consider
the following code snippet describing a double-free in lxc:
1voidput_ctx(ctx *ctx) {
2...// some side-effect
3free(ctx); // freed here
4}
5voidclone_payload(struct s* s){
6put_ctx(s->init); // second_call
7}
8...
9init = s->init;
10put_ctx(init); // first call
11clone_payload(s); // double-free
Thefunction put_ctx isacustomdeallocatorthathasaside-effect.
It is first used at line 10 to deallocate the object pointed to by
initand then called again at line 11 in the body of the function
clone_payload .Because s->initandinitarealiases,adouble-
free occurs at the second call. However, it is not possible to safely
fix this error by removing frees, for example, at line 3 because
doingsointroducesmemoryleaks.Itisalsonotpossibletoremove
thesecondcallto put_ctxbecauseitchangesthemeaningofthe
program (because the side-effect is also removed). Therefore, such
an error cannot be fixed safely with the current fixing strategies of
SAVER. This was the most frequent failure pattern (accounting for
more than 60%) in Table 2.
4.2 Effectiveness of Techniques for Scalability
Wefoundthatthetechniquesforimprovingscalability(Section3.4)
are critical components of SAVER. In particular, the slicing tech-
nique reduced the cost dramatically. For example, snort-2.9.13 (the
largest benchmark) has 7,469 functions but it is sliced to a small
programwith14functions(99.8%reduction)bythetechnique.Also,thetechniqueforselectivepath-sensitivitywasessentialforachiev-
inghigh fixrates.Figure 7comparesthe fixratesof SAVER (after
slicing) with and without our merge heuristic, where Full, Sel,
andNonrepresentSAVER withfullpath-sensitivity,selectivepath-
sensitivity, and path-insensitivity, respectively. The results show
that ours (Sel) performs the best among the three modes, striking
agoodbalancebetweenprecisionandcost.Overall,Selachieves
higher fix rates than Non and Full, since Non is imprecise and
Fulloftenfailstogeneratepatcheswithinthetimelimit.Thisisbe-causeourselectivepath-sensitiveanalysisworksinacost-effective
way; it achieved about 97% of the precision of full path-sensitivity
with <6% of its cost.
4.3 Threats to Validity
In our evaluation, we used 11 open-source programs but they may
not be representative or are not enough to objectively evaluate the
performance of errorrepair tools. Our evaluation focused oncom-
paring SAVER with FootPatch r egarding memory leaks. However,
280rappelSwoolep11-kit lxcx264recutilsinetutils snort050100Fix Rates (%)Full
Sel
Non
Figure 7: Fix rates with different path-sensitivities
thesetwotoolsareincomparableingeneral,asFootPatchsupports
other types of errors such as null dereference and SAVER supports
use-after-free and double-free.
5 RELATED WORK
AutomatedProgramRepair .Automatedprogramrepairtech-
niqueshavereceivedanincreasingamountofattentionfromthe
software engineering community in the last decade [ 19,43]. We
compare our work with a few major approaches below.
Existingrepairtechniquescanbeclassifiedasgeneral-purposeor
special-purpose,dependingonwhethertheyaredesignedtofixany
kindsor specifickinds oferrors. SAVER isa special-purposetech-
niquethatfocusesonfixingmemoryerrorssuchasmemoryleak,
use-after-free, and double-free. Other specialized techniques focus
onsafetypolicyviolations[ 61],buffer/integeroverflows[ 11,52],
nulldereferences[ 16,40,66],concurrencyerrors[ 4,27,36]anden-
ergybugs[ 6],amongothers.Inparticular,Weimer [61]presenteda
techniquesimilartoourstogenerateapatchfortemporalsafetyvi-olations,suchasresourceleaksandAPImisuses.Conceptually,the
technique is also applicable to memory errors. However, applying
the technique to memory errors in practice would require nontriv-
ialeffortstoextendthealgorithmtoconsiderpoliciesofmultiple
objectssimultaneously,whichisessentialforfixingmemoryerrors.
Techniques for localizing, mitigating, and fixing memory errors
have been studied extensively as well [ 9,13,18,20,34,49,55–
57,60,65,69]. Amongthem, thedirectly relatedto oursare Foot-
Patch [60],MemFix[ 34],andLeakFix[ 18].FootPatchisascalable
technique that fixes pointer safety errors such as memory leaks
and null dereferences by applying local reasoning based on separa-
tion logic. However, FootPatch does not ensure safety and mayintroduce new errors as it checks the patch correctness againstthe given error report only. MemFix uses a sound static analysis
toalwaysgeneratesafepatchesbutitsuffersfromlowscalability.
LeakFix is also a safe fixing tool based on data flow analysis butit focuses on simple patches. Furthermore, FootPatch, MemFix,
and LeakFix are unable to produce conditional patches, inherently
failingtofixdiverseerrorsinpractice.Toourknowledge,SAVERisthe first technique for memory errors that achieves high scalability
and repairability without compromising on safety.
General-purposerepairtechniques[ 29,31,32,37,39,41,42,44,
53,62,64] are in principle able to repair all types of errors. Most of
thesearetest-basedtechniques,whichusetestcasestoverifythe
correctnessofthegeneratedpatches(sometechniquesuseprogram
verification[ 33],metamorphictesting[ 26],orcontracts[ 47],buta majority of approaches are based on test cases). General repair
techniques are classified into generate-and-validate [ 29,37,39,62]
and semantics-based approaches [ 31,32,41,42,44]. Generate-and-
validate approaches use search algorithms such as genetic pro-
gramming [ 62] to explore the space of candidate patches until it
finds one that passes all test cases and accelerate the search pro-
cessusingmachinelearning[ 39]orfixtemplates[ 29].Semantics-
based approaches [ 31,32,41,42,44] formulates the patch prob-
lem as a constraint satisfaction problem by executing the program
symbolicallyandsolvestheproblemwithSMTsolvers.Although
these approaches are general, they are unlikelymore effective than
special-purposetechniquesforspecificerrors.Forexample,Xuet
al.recentlyshowedthataspecializedtechniquecanbesignificantly
moreeffectivegeneral-purposetechniquesforfixingnullpointer
exceptions [ 66]. Furthermore, general test-based techniques are
inappropriate for fixing memory errors because memory leaks, for
example, cannot be fully specified by theinput-output test cases.
Also,test-basedtechniquesareinherentlyunsafeasthetestcases
cannot be a complete specification [ 38,48,54,68,70]. Bavishi et
al. [8] recently presented a synthesis-based technique for fixing
static analysis violations, which is general but does not guaranteethe patch safety.
Compile-timeMemoryManagement
.Compile-time memory
management techniques[ 5,12,51,58] are similarto our work in
thatthey automaticallyinsert memorydeallocation statementsin
theprogram.Forexample,TofteandTalpin[ 58]andAikenetal.[ 5]
presented region-based memory management techniques for func-
tionallanguagestoreducethecostofgarbagecollection.Shaham
etal.[51],CheremandRugina[ 12],andGuyeretal.[ 21]present
staticanalysistechniquesforcompile-timememorymanagement
for Java. Dillig et al. [ 14] presented a technique for automating
resourcemanagement(e.g.networksocket)inJava.However,the
primarygoalofthesetechniquesistooptimizeperformance(e.g.
reducing space consumption) in garbage-collected languages such
as Java and ML. In contrast, our focus in this paper is on fixing
errors in programs written in unsafe languages.
6 CONCLUSION
Fixingmemoryerrorsistrickybecausenewandmoredeadlyerrors
are easily introduced. In this paper, we proposed a new technique
that can safely fix such errors in a scalable and precise way. Tothis end, we proposed a new repair algorithm based on object
flow graphs.We implemented thetechnique as a stand-alonetool,
SAVER, and evaluated its effectiveness with the Infer static ana-
lyzer.Foropen-sourceprograms,SAVERwasproventobeeffective
in combination with Infer; it was able to safely fix 74% of thememory-leak errors detected by Infer, demonstrating that this
combination can be actually useful in practice.
ACKNOWLEDGMENTS
This work was supported by Samsung Research, Samsung Elec-
tronics Co., Ltd. This work was supported by Samsung Research
Funding&IncubationCenterofSamsungElectronicsunderProject
Number SRFC-IT1701-09.
281REFERENCES
[1][n.d.]. https://github.com/torvalds/linux/search?q=fix+memory+leaks&
unscoped_q=fix+memory+leaks&type=Commits.
[2] [n.d.]. https://github.com/torvalds/linux/commit/852fef69.
[3][n.d.]. https://github.com/bminor/binutils-gdb/commit/
c91550fc5d8dae5f1140bca649690fa13e5276e9.
[4]Christoffer Quist Adamsen, Anders Møller, Rezwana Karim, Manu Sridharan,
FrankTip,andKoushikSen.2017. RepairingEventRaceErrorsbyControlling
Nondeterminism. In Proceedings of the 39th International Conference on Software
Engineering (ICSE’17).IEEEPress,Piscataway,NJ,USA,289–299. https://doi.
org/10.1109/ICSE.2017.34
[5]Alexander Aiken, Manuel Fähndrich, and Raph Levien. 1995. Better Static
MemoryManagement:ImprovingRegion-basedAnalysisofHigher-orderLan-
guages. In Proceedings of the ACM SIGPLAN 1995 Conference on Programming
Language Design and Implementation (PLDI ’95). ACM, New York, NY, USA,
174–185. https://doi.org/10.1145/207110.207137
[6]A.Banerjee,L.K.Chong,C.Ballabriga,andA.Roychoudhury.2018. EnergyPatch:
Repairing ResourceLeaks to ImproveEnergy-Efficiency of AndroidApps. IEEE
Transactions on Software Engineering 44, 5 (May 2018), 470–490. https://doi.org/
10.1109/TSE.2017.2689012
[7]SubarnoBanerjee,LazaroClapp,andManuSridharan.2019. NullAway:Practical
Type-basedNullSafetyforJava.In Proceedingsofthe201927thACMJointMeeting
on European Software Engineering Conference and Symposium on the Foundations
of Software Engineering (ESEC/FSE 2019). ACM, New York, NY, USA, 740–750.
https://doi.org/10.1145/3338906.3338919
[8]RohanBavishi,HiroakiYoshida,andMukulR.Prasad.2019. Phoenix:Automated
Data-driven Synthesis of Repairs for Static Analysis Violations. In Proceedings of
the201927thACMJointMeetingonEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE2019).ACM,
New York, NY, USA, 613–624. https://doi.org/10.1145/3338906.3338952
[9]MichaelD.BondandKathrynS.McKinley.2008. ToleratingMemoryLeaks.In
Proceedingsofthe23rdACMSIGPLANConferenceonObject-orientedProgramming
Systems Languages and Applications (OOPSLA ’08) . ACM, New York, NY, USA,
109–126. https://doi.org/10.1145/1449764.1449774
[10]Cristiano Calcagno and Dino Distefano. 2011. Infer: An Automatic Program
Verifier for Memory Safety of C Programs. In NASA Formal Methods, Mihaela
Bobaru,KlausHavelund,GerardJ.Holzmann,andRajeevJoshi(Eds.).Springer
Berlin Heidelberg, Berlin, Heidelberg, 459–465.
[11]Xi Cheng, Min Zhou, Xiaoyu Song, Ming Gu, and Jiaguang Sun. 2017. IntPTI:
Automatic Integer Error Repair with Proper-type Inference. In Proceedings of the
32NdIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering(ASE
2017). IEEE Press, Piscataway, NJ, USA, 996–1001. http://dl.acm.org/citation.
cfm?id=3155562.3155693
[12]Sigmund Cherem and Radu Rugina. 2006. Compile-time Deallocation of In-dividual Objects. In Proceedings of the 5th International Symposium on Mem-
ory Management (ISMM ’06). ACM, New York, NY, USA, 138–149. https:
//doi.org/10.1145/1133956.1133975
[13]James Clauseand Alessandro Orso.2010. LEAKPOINT: Pinpointing theCauses
of Memory Leaks. In Proceedings of the 32Nd ACM/IEEE International Conference
onSoftwareEngineering-Volume1(ICSE’10).ACM,NewYork,NY,USA,515–524.
https://doi.org/10.1145/1806799.1806874
[14]IsilDillig,ThomasDillig,EranYahav,andSatishChandra.2008. TheCLOSER:
AutomatingResourceManagementinJava.In Proceedingsofthe7thInternational
SymposiumonMemoryManagement (ISMM’08).ACM,NewYork,NY,USA,1–10.
https://doi.org/10.1145/1375634.1375636
[15]DinoDistefano,ManuelFähndrich,FrancescoLogozzo,andPeterW.O’Hearn.
2019. Scaling Static Analyses at Facebook. Commun. ACM 62, 8 (July 2019),
62–70. https://doi.org/10.1145/3338112
[16]T. Durieux, B. Cornu, L. Seinturier, and M. Monperrus. 2017. Dynamic patchgeneration for null pointer exceptions using metaprogramming. In 2017 IEEE
24thInternationalConferenceonSoftwareAnalysis,EvolutionandReengineering
(SANER). 349–358. https://doi.org/10.1109/SANER.2017.7884635
[17]GangFan,RongxinWu,QingkaiShi,XiaoXiao,JinguoZhou,andCharlesZhang.
2019. Smoke: Scalable Path-sensitive Memory Leak Detection for Millions ofLines of Code. In Proceedings of the 41st International Conference on Software
Engineering (ICSE ’19) . IEEE Press, Piscataway, NJ, USA, 72–82. https://doi.org/
10.1109/ICSE.2019.00025
[18]QingGao,YingfeiXiong,YaqingMi,LuZhang,WeikunYang,ZhaopingZhou,
Bing Xie, and Hong Mei. 2015. Safe Memory-leak Fixing for C Programs. In
Proceedings of the 37th International Conference on Software Engineering - Volume
1(ICSE’15).IEEEPress,Piscataway,NJ,USA,459–470. http://dl.acm.org/citation.
cfm?id=2818754.2818812
[19]L. Gazzola, D. Micucci, and L. Mariani. 2019. Automatic Software Repair: A
Survey.IEEE Transactions on Software Engineering 45, 1 (Jan 2019), 34–67. https:
//doi.org/10.1109/TSE.2017.2755013
[20]Mohammadreza Ghanavati, Diego Costa, Janos Seboek, David Lo, and Artur
Andrzejak. 2019. Memory and resource leak defects and their repairs in Javaprojects. EmpiricalSoftwareEngineering (26Jul2019). https://doi.org/10.1007/
s10664-019-09731-8
[21]Samuel Z. Guyer, Kathryn S. McKinley, and Daniel Frampton. 2006. Free-Me:
AStaticAnalysisforAutomaticIndividualObjectReclamation.In Proceedings
of the 27th ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI ’06). ACM, New York, NY, USA, 364–375. https://doi.org/
10.1145/1133981.1134024
[22]DavidL.HeineandMonicaS.Lam.2003. APracticalFlow-sensitiveandContext-sensitive C and C++ Memory Leak Detector. In Proceedings of the ACM SIGPLAN
2003ConferenceonProgrammingLanguageDesignandImplementation(PLDI’03).
ACM, New York, NY, USA, 168–181. https://doi.org/10.1145/781131.781150
[23]Facebook Inc. 2018. A tool to detect bugs in Java and C/C+++/Objective-C code
before it ships. Available: https://fbinfer.com.
[24]MinseokJeon,SehunJeong,SungdeokCha,andHakjooOh.2019. AMachine-
Learning Algorithm withDisjunctive Model for Data-DrivenProgram Analysis.
ACMTrans. Program.Lang.Syst. 41,2, ArticleArticle13(June2019), 41pages.
https://doi.org/10.1145/3293607
[25]Sehun Jeong, Minseok Jeon, Sungdeok Cha, and Hakjoo Oh. 2017. Data-Driven
Context-SensitivityforPoints-toAnalysis. Proc.ACMProgram.Lang. 1,OOPSLA,
Article Article 100 (Oct. 2017), 28 pages. https://doi.org/10.1145/3133924
[26]MingyueJiang,TsongYuehChen,Fei-ChingKuo,DaveTowey,andZuohuaDing.
2017. Ametamorphictestingapproachforsupportingprogramrepairwithout
the need fora test oracle. Journal of Systemsand Software 126 (2017), 127– 140.
https://doi.org/10.1016/j.jss.2016.04.002
[27]Guoliang Jin, Linhai Song, Wei Zhang, Shan Lu, and Ben Liblit. 2011. Automated
Atomicity-violation Fixing. In Proceedings of the 32Nd ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI ’11). ACM, New
York, NY, USA, 389–400. https://doi.org/10.1145/1993498.1993544
[28]Yungbum Jung and Kwangkeun Yi. 2008. Practical Memory Leak Detector Based
onParameterizedProceduralSummaries.In Proceedingsofthe7thInternational
Symposium on Memory Management (ISMM ’08). ACM, New York, NY, USA,
131–140. https://doi.org/10.1145/1375634.1375653
[29]Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Automatic
Patch Generation Learned from Human-written Patches. In Proceedings of the
2013 International Conference on Software Engineering (ICSE ’13). IEEE Press, Pis-
cataway, NJ, USA, 802–811. http://dl.acm.org/citation.cfm?id=2486788.2486893
[30]TedKremenek.2008. FindingsoftwarebugswiththeClangstaticanalyzer. LLVM
Developers’Meeting. Available:https://llvm.org/devmtg/2008-08/Kremenek_
StaticAnalyzer.pdf.
[31]Xuan-Bach D. Le, Duc-Hiep Chu, David Lo, Claire Le Goues, and Willem Visser.
2017. JFIX:Semantics-basedRepairofJavaProgramsviaSymbolicPathFinder.
InProceedings of the 26th ACM SIGSOFT International Symposium on Software
Testing and Analysis (ISSTA 2017). ACM, New York, NY, USA, 376–379. https:
//doi.org/10.1145/3092703.3098225
[32]Xuan-Bach D. Le, Duc-Hiep Chu, David Lo, Claire Le Goues, and Willem Visser.
2017. S3: Syntax- and Semantic-guided Repair Synthesis via Programming by
Examples.In Proceedingsofthe201711thJointMeetingonFoundationsofSoftware
Engineering (ESEC/FSE2017).ACM,NewYork,NY,USA,593–604. https://doi.
org/10.1145/3106237.3106309
[33]X.B.D.Le,Q.L.Le,D.Lo,andC.LeGoues.2016. EnhancingAutomatedProgram
Repair with Deductive Verification. In 2016 IEEE International Conference on
SoftwareMaintenanceandEvolution(ICSME).428–432. https://doi.org/10.1109/
ICSME.2016.66
[34]Junhee Lee, Seongjoon Hong, and Hakjoo Oh. 2018. MemFix: Static Analysis-
basedRepairofMemoryDeallocationErrorsforC.In Proceedingsofthe201826th
ACM Joint Meeting on European Software Engineering Conference and Symposium
ontheFoundationsofSoftwareEngineering (ESEC/FSE2018).ACM,NewYork,NY,
USA, 95–106. https://doi.org/10.1145/3236024.3236079
[35]YueLi,TianTan,AndersMøller,andYannisSmaragdakis.2018. Precision-Guided
Context Sensitivity for Pointer Analysis. Proc. ACM Program. Lang. 2, OOPSLA,
Article Article 141 (Oct. 2018), 29 pages. https://doi.org/10.1145/3276511
[36]Huarui Lin, Zan Wang, Shuang Liu, Jun Sun, Dongdi Zhang, and Guangning
Wei. 2018. PFix: Fixing Concurrency Bugs Based on Memory Access Patterns. In
Proceedingsofthe33rdACM/IEEEInternationalConferenceonAutomatedSoftware
Engineering (ASE 2018). ACM, New York, NY, USA, 589–600. https://doi.org/10.
1145/3238147.3238198
[37]Fan Long and Martin Rinard. 2015. Staged Program Repair with Condition
Synthesis.In Proceedingsofthe201510thJointMeetingonFoundationsofSoftware
Engineering (ESEC/FSE2015).ACM,NewYork,NY,USA,166–178. https://doi.
org/10.1145/2786805.2786811
[38]FanLongandMartinRinard.2016. AnAnalysisoftheSearchSpacesforGenerate
andValidatePatchGenerationSystems.In Proceedingsofthe38thInternational
ConferenceonSoftwareEngineering(ICSE’16).ACM,NewYork,NY,USA,702–713.
https://doi.org/10.1145/2884781.2884872
[39]Fan Long and Martin Rinard. 2016. Automatic Patch Generation by Learning
CorrectCode.In Proceedingsofthe43rd AnnualACMSIGPLAN-SIGACTSympo-
siumonPrinciplesofProgrammingLanguages (POPL’16).ACM,NewYork,NY,
USA, 298–312. https://doi.org/10.1145/2837614.2837617
282[40]A.Marginean,J.Bader,S.Chandra,M.Harman,Y.Jia,K.Mao,A.Mols,andA.
Scott. 2019. SapFix: Automated End-to-end Repair at Scale. In Proceedings of the
41st International Conference on Software Engineering: Software Engineering in
Practice.IEEEPress,Piscataway,NJ,USA,269–278. https://doi.org/10.1109/ICSE-
SEIP.2019.00039
[41]SergeyMechtaev,JooyongYi,andAbhikRoychoudhury.2015. DirectFix:Looking
forSimpleProgramRepairs.In Proceedingsofthe37thInternationalConference
onSoftwareEngineering-Volume1(ICSE’15).IEEEPress,Piscataway,NJ,USA,
448–458. http://dl.acm.org/citation.cfm?id=2818754.2818811
[42]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scalable
MultilineProgramPatchSynthesisviaSymbolicAnalysis.In Proceedingsofthe
38thInternationalConferenceonSoftwareEngineering (ICSE’16).ACM,NewYork,
NY, USA, 691–701. https://doi.org/10.1145/2884781.2884807
[43]Martin Monperrus. 2018. Automatic Software Repair: A Bibliography. ACM
Comput. Surv. 51, 1, Article 17 (Jan. 2018), 24 pages. https://doi.org/10.1145/
3105906
[44]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra.2013. SemFix:ProgramRepairviaSemanticAnalysis.In Proceedingsofthe
2013 International Conference on Software Engineering (ICSE ’13). IEEE Press, Pis-
cataway, NJ, USA, 772–781. http://dl.acm.org/citation.cfm?id=2486788.2486890
[45]Hakjoo Oh, Wonchan Lee, Kihong Heo, Hongseok Yang, and Kwangkeun Yi.
2014. SelectiveContext-sensitivityGuidedbyImpactPre-analysis.In Proceedings
of the 35th ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI ’14). ACM, New York, NY, USA, 475–484. https://doi.org/
10.1145/2594291.2594318
[46]HakjooOh,HongseokYang,andKwangkeunYi.2015. LearningaStrategyfor
AdaptingaProgramAnalysisviaBayesianOptimisation.In Proceedingsofthe2015
ACMSIGPLANInternationalConferenceonObject-OrientedProgramming,Systems,
Languages, and Applications (OOPSLA 2015). Association for Computing Machin-
ery, New York, NY, USA, 572–588. https://doi.org/10.1145/2814270.2814309
[47]Y.Pei,C.A.Furia,M.Nordio,Y.Wei,B.Meyer,andA.Zeller.2014. Automated
FixingofProgramswithContracts. IEEETransactionsonSoftwareEngineering
40, 5 (May 2014), 427–449. https://doi.org/10.1109/TSE.2014.2312918
[48]Zichao Qi, Fan Long, Sara Achour, and Martin Rinard. 2015. An Analysis of
Patch Plausibilityand Correctness for Generate-and-validatePatch Generation
Systems. In Proceedings of the 2015 International Symposium on Software Testing
and Analysis (ISSTA 2015). ACM, New York, NY, USA, 24–36. https://doi.org/10.
1145/2771783.2771791
[49]Derek Rayside and Lucy Mendel. 2007. Object Ownership Profiling: A Tech-
nique for Finding and Fixing Memory Leaks. In Proceedings of the Twenty-second
IEEE/ACM International Conference on Automated Software Engineering (ASE ’07).
ACM, New York, NY, USA, 194–203. https://doi.org/10.1145/1321631.1321661
[50]CaitlinSadowski,EdwardAftandilian,AlexEagle,LiamMiller-Cushon,andCiera
Jaspan.2018. LessonsfromBuildingStaticAnalysisToolsatGoogle. Commun.
ACM61, 4 (March 2018), 58–66. https://doi.org/10.1145/3188720
[51]Ran Shaham, Eran Yahav, Elliot K Kolodner, and Mooly Sagiv. 2003. Establishing
local temporal heap safety properties with applications to compile-time memory
management. In International Static Analysis Symposium. Springer, 483–503.
[52]AlexShaw,DustenDoggett,andMunawarHafiz.2014. AutomaticallyFixingC
BufferOverflowsUsingProgramTransformations.In Proceedingsofthe201444th
AnnualIEEE/IFIPInternationalConferenceonDependableSystemsandNetworks
(DSN ’14). IEEE Computer Society, Washington, DC, USA, 124–135. https://doi.
org/10.1109/DSN.2014.25
[53]SteliosSidiroglou-Douskos,EricLahtinen,FanLong,andMartinRinard.2015.
AutomaticErrorEliminationbyHorizontalCodeTransferAcrossMultipleAp-
plications. In Proceedings of the 36th ACM SIGPLAN Conference on Programming
LanguageDesignandImplementation(PLDI’15).ACM,NewYork,NY,USA,43–54.
https://doi.org/10.1145/2737924.2737988
[54]Edward K. Smith, Earl T. Barr, Claire Le Goues, and Yuriy Brun. 2015. Is theCure Worse Than the Disease? Overfitting in Automated Program Repair. In
Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering
(ESEC/FSE2015).ACM,NewYork,NY,USA,532–543. https://doi.org/10.1145/
2786805.2786825
[55]Tatsuya Sonobe, Kohei Suenaga, and Atsushi Igarashi. 2014. Automatic Memory
Management Based on Program Transformation Using Ownership. In Program-
ming Languages and Systems - 12th Asian Symposium, APLAS 2014, Singapore,November 17-19, 2014, Proceedings. 58–77.
[56]Kohei Suenaga, Ryota Fukuda, and Atsushi Igarashi. 2012. Type-based safe
resource deallocation for shared-memory concurrency. In Proceedings of the 27th
Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems,
Languages,andApplications,OOPSLA2012,partofSPLASH2012,Tucson,AZ,USA,
October 21-25, 2012. 1–20.
[57]KoheiSuenagaandNaokiKobayashi.2009. FractionalOwnershipsforSafeMem-
ory Deallocation. In Programming Languages and Systems, 7th Asian Symposium,
APLAS 2009, Seoul, Korea, December 14-16, 2009. Proceedings. 128–143.
[58]MadsTofte andJean-PierreTalpin. 1994. ImplementationoftheTypedCall-by-
valuelambda-calculusUsingaStackofRegions.In Proceedingsofthe21stACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL
’94). ACM, New York, NY, USA, 188–201. https://doi.org/10.1145/174675.177855
[59]Erik van der Kouwe, Vinod Nigade, and Cristiano Giuffrida. 2017. DangSan:Scalable Use-after-free Detection. In Proceedings of the Twelfth European Con-
ferenceonComputerSystems (EuroSys’17).ACM,NewYork,NY,USA,405–419.
https://doi.org/10.1145/3064176.3064211
[60]Rijnard van Tonder and Claire Le Goues. 2018. Static Automated ProgramRepair for Heap Properties. In Proceedings of the 40th International Conference
onSoftwareEngineering (ICSE’18).ACM,NewYork,NY,USA,151–162. https:
//doi.org/10.1145/3180155.3180250
[61]Westley Weimer. 2006. Patches as better bug reports. In Proceedings of the 5th
internationalconferenceonGenerativeprogrammingandcomponentengineering.
ACM, 181–190.
[62]WestleyWeimer,ThanhVuNguyen,ClaireLeGoues,andStephanieForrest.2009.
AutomaticallyFindingPatchesUsingGeneticProgramming.In Proceedingsofthe
31st International Conference on Software Engineering (ICSE ’09). IEEE Computer
Society, Washington, DC, USA, 364–374. https://doi.org/10.1109/ICSE.2009.
5070536
[63]Yichen Xie and Alex Aiken. 2005. Context- and Path-sensitive Memory Leak
Detection.In Proceedingsofthe10thEuropeanSoftwareEngineeringConference
Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of
Software Engineering (ESEC/FSE-13). ACM, New York, NY, USA, 115–125. https:
//doi.org/10.1145/1081706.1081728
[64]Yingfei Xiong, Jie Wang, Runfa Yan, Jiachen Zhang, Shi Han, Gang Huang, and
Lu Zhang. 2017. Precise Condition Synthesis for Program Repair. In Proceedings
ofthe39thInternationalConferenceonSoftwareEngineering (ICSE’17).IEEEPress,
Piscataway, NJ, USA, 416–426. https://doi.org/10.1109/ICSE.2017.45
[65]GuoqingXu,MichaelD.Bond,FengQin,andAtanasRountev.2011. LeakChaser:
HelpingProgrammersNarrowDownCausesofMemoryLeaks.In Proceedings
of the 32Nd ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI ’11). ACM, New York, NY, USA, 270–282. https://doi.org/
10.1145/1993498.1993530
[66]Xuezheng Xu, Yulei Sui, Hua Yan, and Jingling Xue. 2019. VFix: Value-flow-
guidedPreciseProgramRepairforNullPointerDereferences.In Proceedingsof
the 41stInternational Conference onSoftware Engineering (ICSE’19). IEEEPress,
Piscataway, NJ, USA, 512–523. https://doi.org/10.1109/ICSE.2019.00063
[67]Hua Yan, Yulei Sui, Shiping Chen, and Jingling Xue. 2018. Spatio-temporal
Context Reduction: A Pointer-analysis-based Static Approach for Detecting Use-
after-freeVulnerabilities.In Proceedingsofthe40thInternationalConferenceon
Software Engineering (ICSE ’18). ACM, New York, NY, USA, 327–337. https:
//doi.org/10.1145/3180155.3180178
[68]Jinqiu Yang, Alexey Zhikhartsev, Yuefei Liu, and Lin Tan. 2017. Better Test
Cases for Better Automated Program Repair. In Proceedings of the 2017 11th Joint
MeetingonFoundationsofSoftwareEngineering (ESEC/FSE2017).ACM,NewYork,
NY, USA, 831–841. https://doi.org/10.1145/3106237.3106274
[69]Bin Yu, Cong Tian, Nan Zhang, Zhenhua Duan, and Hongwei Du. 2019. A
dynamic approach to detecting, eliminating and fixing memory leaks. Journal of
Combinatorial Optimization (16 Mar 2019). https://doi.org/10.1007/s10878-019-
00398-x
[70]HaoZhongandZhendongSu.2015. AnEmpiricalStudyonRealBugFixes.In
Proceedings of the 37th International Conference on Software Engineering - Volume
1(ICSE’15).IEEEPress,Piscataway,NJ,USA,913–923. http://dl.acm.org/citation.
cfm?id=2818754.2818864
283