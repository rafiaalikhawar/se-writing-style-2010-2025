No Strings Attached:
An Empirical Study of String-related Software Bugs
Aryaz Eghbali
aryaz.egh@gmail.com
University of Stuttgart
GermanyMichael Pradel
michael@binaervarianz.de
University of Stuttgart
Germany
ABSTRACT
Stringsplaymanyrolesinprogrammingbecausetheyoftencontain
complex and semantically rich information. For example, program-
mers use strings to filter inputs via regular expression matching,
to express the names of program elements accessed through some
form of reflection, to embed code written in another formal lan-
guage, and to assemble textual output produced by a program. The
omnipresence of strings leads to a wide range of mistakes that
developers may make, yet little is currently known about these
mistakes. The lack of knowledge about string-related bugs leads to
developers repeating the same mistakes again and again, and to
poor support for finding and fixing such bugs. This paper presents
the first empirical study of the root causes, consequences, and
otherpropertiesofstring-relatedbugs.Wesystematicallystudy204string-relatedbugsinadiversesetofprojectswritteninJavaScript,
a language where strings play a particularly important role. Ourfindings include (i) that many string-related mistakes are caused
byarecurringsetofrootcausepatterns,suchasincorrectstringliteralsandregularexpressions,(ii)thatstring-relatedbugshave
adiversesetofconsequences,includingincorrectoutputorsilent
omission ofexpected behavior, (iii)that fixing string-relatedbugs
oftenrequireschangingjustasingleline,withmanyoftherequiredrepairingredientsavailableinthesurroundingcode,(iv)thatstring-
related bugs occur across all parts of applications, including thecore components, and (v) that almost none of these bugs are de-
tected by existing static analyzers. Our findings not only show the
importance and prevalence of string-related bugs, but they help
developerstoavoidcommonmistakesandtoolbuilderstotackle
the challenge of finding and fixing string-related bugs.
CCS CONCEPTS
•Software and its engineering →Software defect analysis.
KEYWORDS
strings, software bugs, string-related bugs, empirical study
This work was supported by the European Research Council (ERC, grant agreement
851895), and by the German Research Foundation within the ConcSys and Perf4JS
projects.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416576ACM Reference Format:
Aryaz Eghbali and Michael Pradel. 2020. No Strings Attached: An Em-
pirical Study of String-related Software Bugs. In 35th IEEE/ACM Interna-
tionalConferenceonAutomatedSoftwareEngineering(ASE’20),September
21–25,2020,VirtualEvent,Australia. ACM,NewYork,NY,USA,12pages.
https://doi.org/10.1145/3324884.3416576
1 INTRODUCTION
Programs are full of strings. The reason why strings are so pop-
ular in programming is that they can express semantically richand complex information, while providing maximum flexibility.For example, programmers use strings to filter user-provided in-puts using regular expressions and to build textual outputs of a
program. Strings also play an important role in dynamic program-
mingpatterns,such asreflection-likeaccessof anobjectproperty
based on the property name. To inspect, manipulate, and create
strings,mostprogramminglanguagesprovidearichsetofstring
APIs.Finally,stringsoftenalsoserveasaninterfacetootherformal
languages,e.g.,whenembeddingdatabasequeries,shellcommands,
or document markup code via a string.
The prevalence of strings in programming leads to a wide range
of possible string-related mistakes. When manipulating strings,programmers may accidentally misuse some API, use a wrong
regularexpression,orforgetaboutsomespecialstringvalue.Whenembeddingcodeinanotherformallanguageintotheprogramviaastring,programmersmaywritesyntacticallyincorrectcodeorrefer
to non-existing identifiers. Even when using simple string literals,
e.g.,torepresentfilepathsorenum-likeproperties,programmers
mayeasilyintroducetyposorforgettoupdateastringwhenthe
program evolves. Unfortunately, most compilers and bug detection
toolsareoflittlehelpbecausetheyrarelyreasonaboutthevalue
of a string variable or how it relates to the rest of the program.
Despite the omnipresence of strings and the various potential
mistakes related to them, little is currently known about string-related bugs. This lack of knowledge has several negative con-sequences. First, developers are likely to repeat the same mis-
takesagainandagain.Ifrecurringstring-relatedbugpatternswere
known, developerscould derivebestpractices toavoid them.Sec-
ond, creatorsof bug detectiontechniques, e.g., staticand dynamic
analyses,andofautomatedprogramrepairtoolsdonotknowwhat
kinds of problems are most pressing. Third, designers of APIs and
programminglanguages,whomaywanttopreventsomeclasses
of bugs by design, can only guess what mistakes developers suffer
from.
This paper presents the first empirical study of string-related
bugs in widely used, real-world software. To address the lack of
9562020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
knowledge about this class of mistakes, we ask the following re-
search questions:
•RQ 1: What are the main root causes of string-related bugs?
•RQ 2: What consequences do string-related bugs entail, i.e.,
whatkinds ofmisbehaviordo theycauseandhow dothese
bugs surface?
•RQ 3: How do developers fix string-related bugs?
•RQ 4: What kinds of software components or parts of an
application are most affected by string-related bugs?
•RQ5:Howeffectivearewidelyusedbugdetectiontoolsat
finding string-related bugs?
Toaddressthesequestions,wesystematicallystudystring-related
bugs in a diverse set of real-world JavaScript projects. Choosing
JavaScriptasthetargetlanguageismotivatedbythefactthatstrings
playaparticularlyimportantroleinthislanguage.Onereasonis
that JavaScript is widely used in the web, where strings are heavily
used to manipulate websites and to send data over the network.
Another reason is the dynamic nature of the language, which moti-
vatesdevelopers torepresent andmanipulate variousconcepts as
strings,includingreferencestoprogramelementsandevencode
itself.Wesystematicallygatherasetof204string-relatedbugsfrom
13popularopen-sourceprojects. Eachbugconsists oftheincorrect
code, the fix applied by the developers, and some informal descrip-
tion of the problem. Beyond our study, this dataset will support
futureworkonstring-relatedbugs,e.g.,onfindingandfixingthese
problems.
Our main findings include the following:
•Thevastmajority(95.6%)ofstring-relatedbugsarecaused
by one or more recurring kinds of root causes. These root
causepatternswillguidefutureeffortstowardfindingstring-
related bugs.
•Themostprevalentrootcausesareincorrectstringliterals
andincorrectregularexpressions(42%and37%respectively),
making these two problems prime targets for bug detection
techniques.
•Manybugscausetheprogramtoproduceincorrectoutput
(30%) or to corrupt a file (5%), while only 11% of the bugs
leadtoanerrormessage,i.e.,anobvioussignofmisbehavior.
Theseresultsunderlinetheneedforclevertestoracles[ 4],
beyondgenericsignsofmisbehavior,suchaserrormessages.
•Asignificantfractionofthebugs(18%)manifestonlyinsome
environments,e.g.,aspecificoperatingsystemorbrowser.
This finding motivates the automated analysis of code in
different environments.
•String-related bugs affect all components of the studied soft-
ware systems,with 53% of thebugs affecting thecore func-
tionality of the project, showing that string-related bugs are
an important class of problems.
•Mostbugs(61%)arefixedbymodifyingasinglelineofcode,
making them a promising target for automated program
repair [25].
•Forasignificantfractionofthebugs(26%),allcodetokens
required in the fix occur within the same file in the vicinity
ofthefixlocation.Moreover,45%ofthebugshaveatleast
70%oftheingredientsinthevicinity.Theavailabilityofsuch
repair ingredients will facilitate automated repairing efforts.•A widely used static code analyzer finds only one out of
the 204 studied bugs. This result confirms an earlier finding
thatstaticanalyzersmissmostbugs[ 18]andshowsthatthis
finding holds for string-related bugs in particular.
In summary, this paper contributes (1) the first systematic study
of string-related bugs, (2) findings about the root causes, conse-
quences,andotherpropertiesofthesebugs,(3)evidencethatdevel-
opersneedtoolstofindandfixstring-relatedbugs,(4)adocumented
dataset of 204 bugs. Our dataset will be available as a reference
pointforfutureworkonbestpracticesfordevelopers,bugdetection
tools, automated repair tools, and the design of string-related APIs
and programming language features.
2 METHODOLOGY
2.1 Scope
To conduct a systematic study of string-related bugs, it is essential
tohaveacleardefinitionofwhatbugsareconsideredstring-related,
and which types of those bugs fall into the scope of this study. We
definethreecriteriaforselecting thesubjectsofourstudy,which
we describe and illustrate with examples in the following.
Criterion 1: Bug. The study focuses on bugs, i.e., problems in the
sourcecodethatcausethefunctionalbehavioroftheprogramto
diverge from the expected behavior. The problems can range from
codecrashesoveromittedbehaviortoincorrectoutputmessages.In
contrast, new features and any other kinds of code improvements,
e.g., refactorings, are not considered in the scope of this study.
Criterion2:String-onlyproblem. Wefocusonstring-relatedbugs,
which we define as bugs that are possible only with strings or
customstringwrappers.Thiscriterionexcludesbugsthatcoinci-
dentally involve a string value but that may just as well happen
with another data type. For example, although the following ex-
amplefromtheSocket.IOframeworkinvolvesstrings,itdoesnot
fulfill our criterion:
1-varorigin = this.req.headers[ 'origin' ]
2+varorigin = this.req.headers[ 'origin' ]| |''
The reason is that forgetting to set a default value for a variable
may happen for several other data types. For example,the above
bug could also happen with a number that should be initializedto zero by default. In contrast, the following bug from the npmpackage manager is caused by a faulty regular expression, i.e., it
cannot happen with a data type other than string:
1- u = u.replace(/^git\+ssh:\/\//, "")
2- .replace(/^git\+/, "")
3+ u = u.replace(/^git\+/, "")
Although comments in the code are sequences of characters,
and hence similar to strings, we exclude fixes in comments fromthe study, as comments are not strings. Thus, this wrong type
declaration in the Mongoose tool,
1/**
2* ...
3- * @param {Number} val
4+ * @param {String} val
5* ...
6*/
957or this typo in a comment that provides a code example in Face-
book’s React framework
1/**
2* ...
3- * var ReactComponentWithPureRender =
4+ * var ReactComponentWithPureRenderMixin =
5* ...
6*/
are not considered string-related bugs.
Criterion3:Programminglanguagefile. String-relatedcodechanges
may happen in documentation or configuration files. The study
focusesonbugsinprogramminglanguagefiles,though,because
our goal is to gain insights for program analysis of code written in
Turing-complete languages. For example, this criterion excludes
version number changes in configuration files. Likewise, if a JSON
file contains some scripts, it also is beyond the scope of this study.
Forexample,thefollowingincorrectcommandforrunningthetests
of the Socket.IO framework is not considered in the study:
1"scripts" :{
2-"test":"make test"
3+"test":"mocha --reporter dot --slow 200ms --bail"
4}
2.2 Data
All widely used programming languages support strings. We focus
our study on string-related bugs in JavaScript code, which is moti-
vatedbythreereasons.First,JavaScripthasbecomeoneofthemost
popularlanguages,oftentimesevenreportedasthemostpopular
language of all [ 9]. Second, JavaScript code covers a wide range
of application domains. While traditionally JavaScript has been
mostlyusedforclient-sidewebapplications,ithasbecomepopular
forserver-sideapplications,mobileapplications,cloudapplications,andmanyothers.Asaresultofthefirsttwopoints,therearemany
open-sourceprojectstostudy,includingprojectsbackedbylarge
software organizations, such as Facebook and Mozilla, and smaller
community-drivenprojects.Third,stringsplayanimportantrole
in JavaScript, perhaps even more than in other languages, because
theyareheavilyusedtomanipulatewebsites,tosenddataoverthe
network, or to represent references to program elements and even
code itself in a string.
We gather string-related bugs from 13 JavaScript repositories
selected from the highest starred repositories on GitHub (Table 1).
The selection of these projects aims at covering a diverse set of
application domains and platforms, including stand-alone appli-cations, tools, libraries, and frameworks. We selected JavaScriptrepositories on GitHub by their stars in descending order, whileignoring websites (like freeCodeCamp/freeCodeCamp) and any
project that had a similar (in terms of domain and use case) project
selected before itself.1To emphasise the diversity of our selection,
we briefly describe each project. Atom is a desktop application
for editing text and source code, with support for plugins writ-ten in Node.js. Mozilla’s PDF.js renders PDF files using the webstandards. Impress.js is a feature-rich application to create non-conventional presentations. Video.js is a video player that uses
HTML5’s video functionality. Babel is a transcompiler that is used
1Data gathered on April 5, 2020Table 1: Repositories used in this study.
Repository Commits Used by Bugs
Applications
atom/atom 37.5k - 11
mozilla/pdf.js 12k 100 20
impress/impress.js 383 90 1
videojs/video.js 3.5k 7.5k 13
Tools
babel/babel 13.6k 2.2M 7
npm/cli 9k 150k 52
Libraries & Frameworks
jashkenas/backbone 3.3k - 16
jquery/jquery 6.5k 395k 49
koajs/koa 1k 111k 0
Automattic/mongoose 12k 938k 14
facebook/react 13k 3.4M 6
socketio/socket.io 1.7k 1.7M 7
react-boilerplate/react-boilerplate 1.4k - 8
toconvertJavaScriptcodewritteninnewerECMAScriptstandards
to older versions. The npm/cli project, provides the command line
interfaceforthewell-knownnodepackagemanager.Backbone.jsis
a framework based on the model-view-presenter design paradigm
that is used for developing web applications. JQuery is a famouslibrary used for simpler HTML DOM operations. Koa is a HTTP
middlewareframeworkforNode.js.MongooseisaMongoDBob-
jectmodelingtool(ODM).Facebook’sReact.jsisoneofthemost
popular front-end development frameworks. Socket.io provides
realtime,bi-directionalcommunicationbetweenclientsandservers.
And finally, react-boilerplate is a structured project to be used as a
starting point for developing react applications.
2.3 Bug Extraction
Togatherstring-relatedbugsfromthedevelopmenthistoriesofthe
projects in Table 1, we semi-automatically filter the commits madeto these repositories. The filtering is guided by the hypothesis that
moststring-relatedbugsarefixedbychangingjustafewlinesof
code. Section 3.3.1 provides evidence to support this hypothesis.
Aftercloningtherepositories,weautomaticallyextractallcommits
thatmodifyatleastoneJavaScriptfileandfilterthecommitsbythe
number of changed lines, i.e., the sum of added and removed lines.
We keep all commits up to four changed lines of code, resulting in
11,875 total commits.
Weinspecteachofthecommitsmanuallytoidentifybugfixes.
A commit is considered a bug fix if it explicitly mentions that a
programming mistake is corrected, e.g., by referring to an issuetracker or by describing the mistake in the commit message. Incase of doubt whether a change is indeed a bug fix, or when we
do notfully understandwhat thefix isabout, wedo notinclude a
commit,toensurethatourstudyfocusesonactualstring-related
bugs. Acrossall studiedprojects, thisprocess resultsin 204string-
relatedbugs.Table1givestheper-projectbreakdown,showingthat
958the bugs cover all but one project. For addressing the individual
research questions, the 204 bugs are further inspected manually
and also analyzed automatically, as explained in detail in Section 3.
Data availability. The full list of all studied bugs, along with the
results of our manual inspection, is publicly available.2
2.4 Categorization
ToanswerRQ1andRQ2theauthorsinspectedeachbugandde-
termined the category of root cause or consequence from personal
judgment.Theprocessincludeddiscussionsoncomplexcasesor
disagreements, and the categories were finalized when the authors
agreed on the same set or not categorized at all, otherwise. Bothauthors reviewed the dataset again after the above process was
finished.
3 RESULTS
3.1 RQ 1: Root Causes
What causes string-related bugs? Understanding the root causes
of these bugs is an important first step toward techniques that
helpdevelopersfindandfixthebugs.Furthermore,knowinghow
prevalentspecifickindsofstring-relatedbugsarehelpsprioritizing
efforts toward such techniques.
To better understandthe root causes of string-relatedbugs, we
identifyrecurringpatternsofrootcauses,categorizethesepatterns,
and investigate how many of all studied bugs match these patterns.Figure 1 shows the resulting taxonomy of root causes. The numbergivenforeachleafnodeinthetaxonomyisthenumberofbugsthat
matchthegivenpattern.Thepatternsarenotmutuallyexclusive,
i.e.,abugcanhavemultipleoftherootcauses,andsomebugsdo
not match any recurring patterns. The following describes the root
cause patterns in more detail and illustrates them with examples.
3.1.1 Bugs in String Literals. Theoverallmostprevalentclassof
bugs are incorrect string literals. For each of these bugs, the incor-
rectcodecontainsahard-codedstringthathasbeenmodifiedby
thedeveloperstoaddressthebug.Wedistinguishtwosubgroups
based on what exactly is wrong about the string literal.
Incorrectstringliteral. Thesebugs,whichaccountfor85(42%)
ofallstudiedbugs,areduetoamistakeinaspecificstringliteral.
For example, these bugs include typos in a string literal, using one
string literal that is also used in the program instead of the correct
one,andstringliteralsthataremissingsomeinformationorthat
include incorrect information.
Asaconcreteexample,considerthisexamplefromtheMongoose
project:
1- const City = db.model( 'City',newSchema({
2+ const City = db.model( 'City2' ,newSchema({
Another example is from the npm package manager:
1 if(!url) {
2- url = "https://npmjs.org/package/" + d.name
3+ url = "https://www.npmjs.org/package/" + d.name
4}
2https://github.com/sola-st/string-bugsInbothcases,thedevelopersfixthebugsbymodifyingthestring
literal in place, without touching any of the other code, which is
common for this bug pattern.
Should not use string literal at all. The second kind of string
literalbugsoccursfourtimes,i.e.,in2%ofallstudiedbugs.Here,
the incorrect code uses a string literal in a context where no literal
should be used at all. Instead, the code already contains a property,
a function, or a configuration value that yields the string to use.
Hard-coding a specific string instead may lead to the wrong string
being used, e.g., when the value needs to be updated.
This is an example of such a bug from the Atom text editor:
1- const executablesToSign = [ path.join( packagedAppPath,
'Atom.exe' )]
2+ const executablesToSign = [ path.join( packagedAppPath,
CONFIG.executableName) ]
As in the example, such bugs are typically fixed by replacing the
string literal with a reference to the property, function, or configu-
ration value that yields the correct string.
Bugs caused by incorrect string literals are hard to find, both by
humansand automatedtools. Forhumans, themainchallenge isto
keep track of the different string literals spread across a code base
and the (typically implicit) consistency constraints between them.
Forautomatedprogramanalyses,themainchallengeistoreason
about the content of string literals. Many existing analyses (see
Section6forsomeexceptions)donotevenattempttoreasonabout
stringliterals,butsimplyabstracttheircontentaway.Reasoning
about the semantics of string literals, and how they related to their
surrounding code, is a promising direction for future work.
3.1.2 Bugs in Regular Expressions. Another highly prevalent class
ofstring-relatedbugsarebugsinregularexpressions.Priorworkre-portsregularexpressiontobewidelyused[
10]yetpoorlytested[ 47].
We find 75 out of the 204 studied bugs (37%) to be within a regular
expression,whichconfirmstheearlierresultsandshowsthatthe
poor state of testing regular expression results in various bugs.
To get an impression of what kinds of mistakes developers typi-
cally make when writing regular expressions, Table 2 listssix re-
curring root cause patterns among the 75 regular expression bugs.
As for our overall classification, these patterns are not mutually
exclusive. The first two patterns are both the result of forgetting
to consider a specific case when designing a regular expression. In
pattern 1, the regular expression explicitly lists cases separated by
|. In pattern 2, the programmer searches and replaces particular
substringsinagivenstring usingthe replace()API,butforgetsto
searchforaspecifickindofsubstring.Together,thesetwopatterns
accountfor38%ofallregularexpressionbugsinourdataset.For
both patterns, the bug is typically fixed by adding the missing case,
as illustrated in the examples in Table 2.
Three of the remaining patterns are about incorrectly using, or
not using at all, a specific feature of the regular expression syntax.
Inpattern3,somepartoftheregularexpressionshouldbeoptional
or repeated, which the developer forgets to express using the ?,
{},or*syntax.Pattern5istheresultofnotanchoringtheregular
expressiontothestartorendofthematchedstringusingthe ^and
$symbols. Without such anchoring, the regular expression may
match any substring of the given string, which sometimes is not
959String-
related bugs
String literals
Incorrect
string literalShould not
use string
literal at allIncorrect
regular
expressionInterface to
language
or resource
Incorrect code
embedded
in stringWrong path
or URLIncorrect
API usageComparisons
and op-
erations
Incorrect
comparisonMissing check
or operationString vs.
other types
85 475
22 2226
55 1210
Figure 1: Common root causes of string-related bugs.
Table 2: Recurring bug patterns related to regular expressions.
Id Bug Pattern Example Occurrences
1 A case is missing in a list of alternatives. - loop|o(?:ff?|[rn]) 15
+ loop|for|o(?:ff?|[rn])
2 Incorrect chain of replacecalls. - n.replace(/[,\_]/g, "-") 15
+ n.replace(/[,\_]/g, "-").replace(/\s/g, "")
3 Incorrect or missing use of optional or repeated pattern. - /(\d\.\d)\.\d/ 14
+ /(\d+\.\d+)\.\d+/
4 Mistake in literal part of a pattern. - /Edge/i 7
+ /Edg/i
5 Missing anchors (start and end of string). - /---([\s\S]+)---/g 7
+ /^---([\s\S]+?)---/g
6 Character should be escaped. - /[^/]$/ 5
+ /[^\/]$/
the intended behavior. In pattern 6, the developer forgets to escape
a character that has a special meaning in the regular expression
syntax of the underlying programming language, such as the slash
character.
Finally,pattern4isaboutmistakesinaliteralpartofaregular
expression,i.e.,asequenceofcharactersthatdonothaveanyspecial
meaninginregularexpressions,butsimplymatchastheyare.Thesebugsaresimilarinnaturetoincorrectstringliterals,andtechniques
to detect one may also help detecting the other.
The high total number of bugs in regular expressions and the
factthatasignificantfractionofthemfallunderrecurringpatternsmotivatesworkontechniquestodetectandrepairsuchbugs.Whilesometechniqueshavebeenproposedinthepast,e.g.,atypesystemforregularexpressions[
38]andavisualizationtool[ 6],thereclearly
is a need for additional testing and analysis techniques for regular
expressions.
3.1.3 Interface to Other Languages and External Resources. One
importantroleofstringsinprogrammingisthattheyoftenserve
as an interface to other (programming) languages and external
resources.Forexample,aprogrammaycreatethesourcecodeof
anotherprogram,manipulateadocumentdescribedinamarkup
language,orissueoperatingsystem-levelcommandsthatrefertopaths in the filesystem. Because the well-formedness and contentof such strings is typically not checked before the execution, bugs
may easily arise. In our study, we find two common patterns of
such bugs.
Incorrect code embedded in string. This class of bugs is caused by
embedding code in one language as a string into another language.
Theembedded codemay, e.g.,be HTMLcodeembedded intoa UI
component or command line arguments embedded into a build
script.Wefind22(11%ofallstudiedbugs)tobelongtothisclassof
bugs. The following is an example from Facebook’s React library:
1ReactDOM.render(
2- <div className= "pgErr" >{err.toString()}</div>,
3+ <pre style={{overflowX: 'auto'}} className= "pgErr" >{
err.toString()}</pre>,
4 mountNode
5);
Wrong path or URL. When programs refer to resources stored
on the same or another machine, they often encode a path or URL
into a string. We find that 22 (11%) of the studied bugs are due to a
wrong path orURL. The following example is abug that occurred
in the Mongoose tool:
1- require( '../lib/utils' ).random()
5
9602+ require( '../../lib/utils' ).random()
Ingeneral,a wrongpathorURLmay betheresultofan incorrect
string literal, as in this example, or of a mistake in manipulating a
string.
Detectingbugsrelatedtointerfacingwithanotherlanguageor
externalresourcesseemspossiblebecausethesyntaxandsemantics
of the content of the string is well-defined. For example, paths that
refertothelocalfilesystemcouldbechecked,andsomelint-like
static checkers reason about local paths. Another approach is to
prevent suchbugs throughprogramming languageorAPI design,
e.g.,intheformofembeddedDSLsorAPIsthatallowprogrammers
to construct code while providing more safety guarantees than
whencreatingarawstring.Despitethefactthatatleastsomeof
these bugs seem in reach, the high number of bugs in this category
suggests that more effective techniques are needed.
3.1.4 Incorrect (Usages of) String APIs. To create, manipulate, and
validatestrings,developersoftenusebuilt-inAPIs.Wefind26bugs
(13%) caused by incorrect usages of string APIs. These bugs are
oftencausedbyusinganAPIthatisnotappropriatefortheintended
purpose, by using the API incorrectly, or by combining multiple
API calls in an unexpected way.
The following example is a bug in the npm package manager,
where the programmer accidentally used one API instead of an-
other:
1- && !!p.substr(0, -1).match(re[pattern]) )
2+ && !!p.slice(0, -1).match(re[pattern]) )
AnotherexampleisfromMozilla’sPDF.js,wheretheprogram-
merexpectedthe toLowerCase() APItomodifyastringinplace,while
it actually returns the modified string:
1- ch.toLowerCase();
2+ ch = ch.toLowerCase();
SincemanyclientsofpopularstringAPIsexist,techniquesfor
bug detection and repair based on API usage mining [ 2,26,32]
could help find such bugs.
3.1.5 Comparisons and Operations that Involve Strings. Another
commonrootcauseofstring-relatedbugsismistakesincomparing
strings and in operations applied to strings. We distinguish the
following two subcategories.
Incorrectcomparisons. Wefind12bugs(6%)thatarecausedbyan
incorrectcomparisonoftwostrings.Halfofthemarerelatedtothe
case-sensitivity of the comparison, such as the following example
from the Socket.IO framework:
1-this.req.headers.upgrade !== 'websocket'
2+this.req.headers.upgrade.toLowerCase() !== 'websocket'
Someofthecomparison-relatedbugsoccurwhencheckingsome
stringvariableagainstanexpectedvalued,e.g.,intestingcode,such
as this example from the npm package manager:
1- t.equal(stdout, 'cool\t\t\tprehistoric\t\t\ nfoo')
2+ t.equal(stdout, 'cool\t\t\tprehistoric\t1.0.0\t\ nfoo')0 20 40 60
Number of bugsSof twar e-specific pr oblemOS-specific pr oblemT est failur eT ask not doneEr r or messageCor rupt a fileIncor r ect output
20171332251161
Figure 2: Consequences of string-related bugs.
Missing checkor operation. 55 (27%) outof the studied bugsare
caused by a missing check or operation related to strings. These
bugsincludecodewhereonlypartoftheexpectedstringmanipula-
tionisperformedorwheretheprogrammerforgottoguardsome
operation by an appropriate check. For example, the following bug
occurred in Mozilla’s PDF.js due to a missing call to trim():
1- info.Version + ''+ (info. Producer || '-')
2+ info.Version + ''+ (info. Producer || '-').trim()
3.1.6 Strings vs. Other Types. Thefinalclassofrootcausesisabout
treatingavalueasastring,andnotsomeothertype.Amongthe
studiedbugs,10(5%)fallintothiscategory.Formanyofthesebugs,
somevariableisnotofstringtype,buttheprogrammerexpectsitto
be a string. Typically, these bugs are fixed by converting the value
intoastring,whichinJavaScriptcanbeachievedbyconcatenating
a value with a string, as in the following example from jQuery:
1- s.data = s.data.replace(jsre, "="+ jsonp);
2+ s.data = (s.data + "").replace(jsre, "="+ jsonp);
Suchtype-relatedbugscouldbedetectedbystatictypechecking,
e.g., using gradual type checkers for dynamically typed languages,
such as Flow for JavaScript, or Pyre and Mypy for Python.
3.2 RQ 2: Consequences
Thegoalofthisresearchquestionistounderstandtheconsequences
ofstring-relatedbugs,i.e.,whatkindsofmisbehaviortheycause
andhowthebugsmanifest.Understandingtheconsequenceswill
help determine effective techniques for finding string-related bugs,
in particular, testing-based and dynamic analysis-based techniques
that rely on a manifestation of misbehavior.
3.2.1 Common Kinds of Consequences. Figure2showsthemost
common kinds of consequences of string-related bugs. We identify
theseconsequencesbycarefullystudyingthecodeinwhicheach
bug occurs and issue descriptions associated with a bug. As for
RQ1,thecategoriesforconsequencesarenotmutuallyexclusive,
i.e., a bug may appear in multiple categories.
Incorrect output. Many of the string-related bugs (61, i.e., 30%)
causetheprogramtoproduceanincorrectoutput,suchasanincor-recttextprintedtotheconsoleoranincorrectUIelementrendered,
e.g., on a website. While incorrect outputs are often easy to spot
forhumans,identifyingtheminanautomatedtoolismuchmore
challenging,becausetheexpectedoutputoftenisnotspecified.One
961promisingdirectionforautomaticallydetectingincorrectoutputs
is cross-checking different, supposedly consistent outputs [14].
Corrupt a file. There are 11 bugs (5% of the studied bugs) that
causetheprogramtowriteincorrectdataintoafileortostoredata
into a wrong file. Both are severe consequences, as they perma-
nentlycorruptthestate. Fromabugdetectionperspective,these
bugsaresimilartothe“incorrectoutput”categorydiscussedabove.
Error message. Out of all the bugs found in our study, 23 bugs
(11%) lead to an error message being printed, e.g., to the command
line or the browser console. This relatively low percentage is likely
to be influenced by the “no crash philosophy” of JavaScript [ 3],
wheremanypotentialruntimemistakesdonotcauseerrorsbutare
silentlyhandledbythelanguage,e.g.,throughimplicittypeconver-
sions [33]. From a bug detection perspective, the lack of obvious
error messages for most bugs poses an interesting challenge.
Tasknotdone. Asignificantnumberofbugs(32,i.e.,16%)results
inaspecifictaskorexpectedbehaviornotbeingdone.Forexample,
thesebugsincludecodethataccidentallyfailstodownloadsome
input data, fails to sanitize a string in some cases, or ignores some
ofthegiveinputfiles.Suchomissionerrorsaredifficulttodetect
becausenothingwronghappens,butthecorrectbehaviorsimply
does not happen.
Test failure. Among the studied bugs, 13 bugs (6%) manifest
through a test failure. Because we gather the studied bugs frombug fixes in version histories, the dataset misses problems that
developers fixlocally, before committingto theshared repository.
These missed bugs are likely to include some bugs exposed by test
failures triggered when a developer runs the test suite locally.
OS-specificproblem. Somebugs manifestonly onspecific oper-
atingsystems,e.g.,becausetheyrelatetohowfilesystempathsare
encodedorhowwhethersomeexternaltoolisavailable.Wefind
17 such OS-specific bugs (8%). Detecting such bugs through any
kind of runtime analysis requires the program to be executed on a
specificoperatingsystem,whichincreasesthebugdetectioncost
in practice.
Software-specificproblem. Similartotheabovecategory,some
bugs manifest only when the code is executed within or in combi-
nation with a specific other software. These bugs include browser-
specificbugsthat,e.g.,manifestonlyinsomeversionsofInternet
Explorer.Wefind20suchbugs(10%)inourdataset.Combiningthisand the previous category of consequences, 37 bugs (18%) manifest
only in a specific environment.
3.2.2 Relation between Root Causes and Consequences. Our classi-
ficationofbugsbasedontheirrootcausesandconsequencesallows
for studying the relation between both. Figure 3 shows how much
bugswithaspecifickindofrootcauseleadtoaspecifickindofcon-
sequence.Therearea fewnoteworthyrelations.First,weobserve
that incorrect regular expressions often lead to incorrect output.
Almost half of all regular expression-related bugs have this con-
sequence.Second,testfailuresarefrequentlycausedbyincorrect
literals.Thereasonisthatliteralsoftenappearintestcasesashard-
coded inputs or as part of assertions about the output of the tested
code. Finally, we find that bugs caused by treating a non-string
Figure 3: Root causes leading to consequences.
asastring,orviceversa(category“Stringvs.othertypes”)often
manifestthroughanerrormessage.WeattributethisobservationtothefactthatJavaScriptraiseserrorsforsometype-relatedmistakes,
e.g., when trying to call a non-existing method of an object.
Overall,weconcludethatstring-relatedbugsarenotlimitedtoafew
kinds of consequences, but manifest on a variety of ways. The fact
that18%ofallbugsmanifestonlyinaspecificenvironmentimplies
thatdynamicanalysis-basedapproachesforfindingstring-related
bugs should execute the code under test in different environments.
Anotherinterestingfindingisthatthevastmajorityofbugsdoes
notleadtoanobvioussignofmisbehavior,suchasanerrormessage,butrathermanifestthroughtheabsenceofsomeexpectedbehavior
or an incorrect output. This finding calls for more work toward
implicitoracles,e.g.,throughdifferentialtesting[ 30],metamorphic
testing [12, 35], or some kind of consistency check.
3.3 RQ 3: Fixes
Thisresearchquestionisaboutthewaydevelopersfixstring-related
bugs. Specifically, we are interested in the size of bug fixes (Sec-tion 3.3.1) and in the degree to which the “ingredients” for a bug
fix are available in the buggy code (Section 3.3.2).
3.3.1 Size of Fixes. We measure the size of bug fixes in two ways.
Figure 4 shows how many lines a bug fix includes, where eachremoved and added line counts separately. That is, modifying a
singlelinecountsastwolinesinthebugfix,asonelineisremoved
and another line is added instead. The figure shows that most fixes
of string-related bugs (125 out of 204, i.e., 61%) affect only a single
line,i.e.,theyhaveoneortwolinesinthebugfix.Wheninterpreting
these results, one needs to consider that the bugs considered in
the study are filtered by the number of changed lines (at most four
added and removed lines, Section 2.3), i.e., our dataset is inherently
biased towards small bug fixes. Nevertheless, the fact that most
bugs are even smaller than our limit imposed when gathering bugs
shows that many string-related bugs indeed have small fixes.
The second measurement is about the number of characters
changed in a bug fix. For each bug fix, we take the sequence differ-
ence,usingPython’sdiffliblibrary,betweentheaddedandremoved
9621 2 3 4
Number of lines in bug fix020406080100120Number of bug fixes
Figure 4: Histogram of lines changed in bug fixes.
0 25 50 75 100 125 150 175 200
Number of changed characters in bug fix01020304050Number of bug fixes
Figure 5: Histogram of characters changed in bug fixes.
linestodetecttheminimumrequiredcharacterchange.Wethen
usethesumofadded,removed,andmodifiedcharactersasthetotal
number of changed characters. As an example, this is the output of
the sequence difference script for a bug in the JQuery library.
1-- varm = er.message.match(/^E[A-Z]+/)
2?^
3++ varm = er.message.match(/^(?:Error: )?(E[A-Z]+)/)
4? ^ +++++++++++++ +
5-- m=m [ 0 ]
6?^ ^
7++ m=m [ 1 ]
8?^ ^
Using the markers provided by the difflib tool, we can easily count
the numberof modified characters.Figure 5 shows thehistogram
ofthenumberofchangedcharacters.Theresultsconfirmtheob-
servationthatmoststring-relatedbugsrequireonlysmallfixes.Forexample, 111 out of the 204 bugs (54%) are fixed by changing fewer
than 30 characters.
3.3.2 Fix Ingredients. Thefactthatstring-relatedbugsfollowre-
curringpatternsandthattheyoftengetfixedbymodifyingjusta
single line of code may bring this class of bugs into the reach ofautomated program repair [ 25]. One challenge in automated repair
istofindtheprogramcodethatisrequiredinthefixbutnotpart
ofthe buggycode location,sometimescalled “fixingredients”.To
better understand the potential for finding such fix ingredients for
string-relatedbugs,weanalyzewhetherthetokensaddedwhenfix-ingabugareavailableclosetothelocationwherethestring-related
bug gets fixed.
In the first step, we compare the old and the new code that fix a
string-relatedbugbyextractingthetokensinthesecodefragments.
We then search up to a 100 lines before and 100 lines after the bug
for these tokens and measure how many of the otherwise missing
tokensarewithinthiswindowofnearbyavailablefixingredients.
Notallbugfixesaddtokens,e.g.,somefixesrequireremovingentire
lines or specific tokens from the source code. Our analysis doesnot consider these bug fixes (39 out of 204), since all ingredients
forfixingthesebugsaregiveninthebuggycode.Theanalysisis
automatedandimplementedbasedontheAcornJavaScriptparser3
and the Difflib.js4package, which is ported from Python’s difflib
library.5
We present two variants of the fix ingredients results. Figure 6a
includes all tokens except for regular expressions, which are repre-
sentedasasingletoken.Thefigureshowsthat25%ofthebugshave
all of the required ingredients present nearby, and 43% of the bugs
haveatleast70%ofthetokensneededforthefixaroundthebug.
Figure 6b shows the same results, now including regular expres-
sions.Here,12%ofthebugshaveallrequiredtokensinthevicinity
and 30% of the bugs have at least 70% of their repair ingredients
closeby.Thedifferencebetweenthesetwofiguresisduetothefact
that thechance of havingthe exact regularexpression required to
fix a bug somewhere in the code is small. Yet, both figures show
thatforasignificantfractionofstring-relatedbugs,alloratleast
many of the fix ingredients are available in the surrounding code.
Overall,theresultsofRQ3showthatmanystring-relatedbugsarefixedbymodifyingverylittlecode,oftenjustasingleline,andthat
manyofthefixingredientsareavailableinthesurroundingcode.
For example, for this bug in the React-boilerplate project, the entry
point path is wrong.
1console.log(path.join(__dirname, '..','app/js/app.js' ));
2...
3entry = [
4- path.join(__dirname, '..','js/app.js' )/// Start
with js/app.js...
5+ path.join(__dirname, '..','app/js/app.js' )/// Start
with js/app.js...
Noticethatafewlinesabove,ourscriptfoundthecorrectpathused
in a log message, which could potentially be used to repair thisbug automatically. These findings bring string-related bugs into
the reach of automated program repair, motivating future work in
this direction.
3.4 RQ 4: Program Components
This research question asks what parts of a software project are
mostaffectedbystring-relatedbugs.Weaddressthisquestionby
studying for each bug the code location where the bug is fixed,
3https://github.com/acornjs/acorn/
4https://www.npmjs.com/package/difflib
5https://docs.python.org/3/library/difflib.html
963(a) not counting regular expressions
(b) counting regular expressions
Figure 6: Histogram for the portion of repair ingredients
present in +/- 100 lines of the bug.
and by classifying these code locations into six categories: the core
functionalityoftheproject, utilityfunctions, UIcomponents, testing
code,buildscripts,and demoapplicationsorexamplesforhowto
use an API.
Figure 7 shows the results of our analysis. The overall finding is
thatstring-relatedbugsaffectallkindsofcodecomponents,andarenotlimitedto,e.g.,UIortestingcode.Themostcommonlyaffectedpartsofthestudiedprojectsarethecorecomponents,where109of
the bugs (53%) reside.
To assess whether the components where bugs resides relate in
anyparticularwaywiththerootcausesofbugs,Figure8showshow
manybugswithaspecificrootcauseareinaspecificcomponent.
For most kinds of root causes and components, we do not see aclear relation between root causes and where a bug resides. The
only exceptions are bugs caused by incorrect string literals, which
tend to appear relatively often in testing code. The likely reason
againisthathard-codedstringsarecommonintestingcode.The
absenceofstrongrelationsbetweenrootcausesandcomponentsFigure 7: Program components affected by string-relatedbugs.
Figure 8: Root causes affecting components.
impliesthatbugdetectiontoolsthattargetaspecifickindofroot
cause should be applied across all components of a software.
Overall, we conclude from the results in RQ 4 that string-relatedbugs are wide-spread, even in the most important parts of code
bases, and hence deserve appropriate attention.
3.5 RQ 5: Existing Bug Detection Tools
The following addresses the question of how effective existing bug
detectiontoolsareatfindingstring-relatedbugs.Therearemany
bugdetectiontools,e.g.,FindBugs[ 20],Google’sErrorProne[ 1],
or Facebook’s Infer [ 8]. For JavaScript, static linters are commonly
used in practice [ 41], and we therefore compare with JSHint6, one
of the most popular static linters for JavaScript. To check which of
the bugs studied in this paper are detected by JSHint, we apply the
tooltoeachofthebuggyfilesjustbeforethebugfixwasapplied.
We then compare any warnings reported by JSHint close to the
locations that were fixed to address the bug, focusing on warnings
in the line directly before, exactly at, or directly after a modified
line.
6http://jshint.com
964In total, there are 218 lines with a JSHint warning close to a
bug fix location. A manual inspection shows that almost all of
them are unrelated to the string-related bugs, but point to other
potentialproblemsatthesamecodelocation.Themajorityofthese
unrelatedwarningsareaboutmissingsemi-colons(whichislegal
butdiscouragedinJavaScript),languagefeaturessupportedonly
by ECMAScript 6 (which is not yet supported by all browsers), and
possibly undefined references to global variables available onlyin the browser (but not, e.g., in Node.js). Only one out of the 218
warningspointstooneofthestring-relatedbugs.Itwarnsabout
an invalid regular expression, which was fixed by the developer.
Overall,weconcludethatawidelyusedstaticbugdetectiontool
isnoteffectiveatdetectingstring-relatedbugs,offeringampleof
opportunities to improve the state of the art.
4 THREATS TO VALIDITY
Subjectprojectsandbugs. Ourstudyfocuseson204bugsgath-
ered from 13 JavaScript repositories. While we aim at a diverse set
ofprojects,theymaynotberepresentativeforotherprojects.Be-
causethestudyfocusesonJavaScriptonly,ourconclusionsmaynot
holdforotherlanguages.Theselectionprocessofbugsmayhave
introduced some bias, e.g., toward bugs that are locally fixed by
changingafewlinesofcode.Hence,ourfindingsapplytosuchbugs
only,andmorecomplexstring-relatedbugsmayhaveotherprop-
erties. Finally,because we study bugs fixedthrough commits,our
datasetmissesbugsthatneverappearintheversioncontrolsystem,
either because the developer fixes them even before committing or
because the bugs remain unnoticed.
Manualclassification. OuranswersforRQ1,2,and4relyona
manual inspection and classification of the 204 bugs. While such a
manual process is necessary to identify non-trivial patterns, it may
introduce mistakes. To mitigate this potential threat, the classifi-
cation results were checked by two authors and iteratively refined
until reaching agreement.
5 DISCUSSION
Thefactthatstring-relatedbugsoftenaffectthecorecomponentsof
a project and lead to hard-to-detect misbehavior, such as incorrect
output or corrupted files, raises the question of how developerscan find such bugs quicker. Unfortunately, developers currentlyhave access to little or no effective tool support for dealing withstring-related bugs. Most program analyses do not reason about
thevaluesofstrings,butsimplyabstractthesevaluesaway.Howto
developeffectivetoolsforfindingstring-relatedbugsneedsmore
research. NLP-based reasoning aboutthe content of strings may be
a promising, yet mostly unexplored, direction. The high number
of regular expression bugs, combined with the wide use of regular
expressions [ 10], suggests that mining-based or learning-based ap-
proachestofindregularexpressionbugscouldbeafruitfulresearch
direction. Our findings about recurring root cause patterns (RQ 1)
will help guide such efforts toward the most promising kinds of
string-related bugs.
Whilestring-relatedbugsarenon-trivialtodetect,fixingthem
often involves only small and local code changes. This findingmotivates work on automated repair of such bugs. A commonchallenge in automated repair is how to find repair ingredients,
i.e., code fragments needed in the corrected code. Our results for a
show that for many string-related bugs, the repair ingredients are
available, waiting to be exploited by appropriate repair tools.
6 RELATED WORK
6.1 String-related Bugs
Even though there is no comprehensive study of string-related
bugsyet,priorworkhaslookedintospecifickindsofstring-related
code.Regularexpressionsareshowntoberegularlyusedbypro-
grammers [ 10], and at the same time, tested less well than other
code [47]. Our finding that many string-related bugs are caused
by incorrect regular expressions show the natural consequence of
the two previous results. Recently, Wang et al.[ 46] have done an
empirical study on regular expression bugs, similar to Section 3.1.2
in ourstudy. Theresults in[ 46]areclose towhat wefound about
regular expression bugs, although the repositories and program-
ming languages in that study are different. To avoid such bugs,
visualization [ 6] and static type checking [ 38] of regular expres-
sions have been proposed. String-related bugs sometimes cause
securityvulnerabilities,e.g.,formatstringvulnerabilities[ 16,37],
cross site scripting vulnerabilities [ 5], or regular expression denial
of service vulnerabilities [ 17,39]. Compared to other string-related
bugs, such vulnerabilities have been studied intensively, and there
aretechniquestodetectandfixthem.Ourstudyshowsthatthere
aremanystring-relatedbugsbeyondvulnerabilities,forwhichvery
little tool support exists.
6.2 Program Analysis of String-related Code
Thereareseveraltechniquesforreasoningaboutstringsinapro-
gram analysis. Christensen et al . [15]propose an analysis of string
expressionsthattriestocreatearegularlanguagedescribingthe
values a string may have. String solvers, such as Hampi [ 23] and
Rex[43],helpexpressingandsolvingconstraintsgatheredduring
theanalysisofstring-manipulatingprograms,whichcanbeused,
e.g., to create injection attacks [ 24]. These techniques help reason-
ingaboutthequestionofwhatvaluesastringexpressionmayhave,
whichisanimportantpartofbettertoolstodetectstring-related
bugs.
6.3 Natural Language Information in Code
Stringsoftencontainsomeformofnaturallanguageinformation.
Some program analyses use such natural language information,
e.g., to infer specifications from API documentation [ 7,49], to find
inconsistenciesbetweencommentsandcode[ 40],towarnabout
potentially incorrect combinations of identifier names [ 34], and
topredicttypes[ 29].However,noneofthesetechniquesreasons
about natural language information within strings, which could
be interesting future work to find some of the bugs studied in this
paper.
6.4 Studies of Bugs
Other studies investigate bugs in specific application domains, e.g.,
inoperatingsystems[ 13],indeeplearningsystems[ 21,48],andin
blockchain code [ 44], or specific classes of bugs, e.g., concurrency
965bugs[28],bugsintestcode[ 42],long-lastingbugs[ 11],andperfor-
mancebugs[ 19,22,27].PriorstudiesofbugsinJavaScriptfocuson
client-sideJavaScriptbugs[ 31],performancebugsinJavaScript[ 36],
and bugs that occur on the Node.js platform [ 45]. Our work con-
tributes an in-depth analysis of the important yet currently under-
studiedclassofstring-relatedbugs.AstudybyHabibandPradel
[18]shows that state-of-the-art static bug detection tools miss the
majorityofbugsthatoccurinthewild.Ourfindingsaboutlint-like
tools for JavaScript reinforces this finding for string-related bugs.
7 CONCLUSION
This paper presents the first in-depth empirical study of string-
related software bugs.These programming mistakes are aclass of
simple yet prevalent bugs that we find to affect all kinds of com-
ponents of software projects, including the core functionality. Our
studyinvestigates204string-relatedbugsgatheredfrom13popular
JavaScript projects. We find that many bugs are instances of recur-
ring root cause patterns, with incorrect string literals (42%) and
incorrectregularexpressions(37%)beingthemostcommonroot
causes.Whilestring-relatedbugstendtorequireonlysmallfixes
(61% are fixed by modifying just one line), they can have severe
consequences(30%leadtoincorrectoutput)andarenon-obviousto
detect (only 11% leadto anerror message and18% manifestonly in
specific environments). A widely used static checker for JavaScript
missesallbutoneofthe204studiedbugs.Ingeneral,string-related
bugs are difficult to find with program analyses because most anal-
yses do not reason about the values of strings.
Ourdatasetismadeavailableasareferenceforfutureworkon
best practices for developers, bug detection tools, automated repair
tools, and the design of string-related APIs and programming lan-
guagefeatures.Inparticular,wehopetoinspireworkondevelopertoolstofindandfixstring-relatedbugs.Thecurrentstateoftheart
leavesahugeuntappedpotentialfortechniquesthatdetectsuch
bugs, and the root cause patterns described in this paper will guide
sucheffortstoward themostpromisingkindsofbugs.Moreover,
wefindstring-relatedbugstobeinreachforautomatedprogram
repair:Notonlyaremanyfixessimple,butformanybugs,thefix
ingredients,i.e., tokensaddedina fix,areavailable inthevicinity
of the fix location.
REFERENCES
[1]Edward Aftandilian, Raluca Sauciuc, Siddharth Priya, and Sundaresan Krishnan.
2012. Building Useful Program Analysis Tools Using an Extensible Java Com-
piler. In12th IEEE International Working Conference on Source Code Analysis and
Manipulation, SCAM 2012, Riva del Garda, Italy, September 23-24, 2012. 14–23.
[2]GlennAmmons,RastislavBodík,andJamesR.Larus.2002. Miningspecifications.
InSymposium on Principles of Programming Languages (POPL). ACM, 4–16.
[3]Esben Andreasen, Liang Gong, Anders Møller, Michael Pradel, Marija Selakovic,
KoushikSen,andCristian-AlexandruStaicu.2017. ASurveyofDynamicAnalysis
and Test Generation for JavaScript. Comput. Surveys (2017).
[4]Earl T. Barr, Mark Harman, Phil McMinn, Muzammil Shahbaz, and Shin Yoo.
2015. TheOracleProbleminSoftwareTesting:ASurvey. IEEETrans.Software
Eng.41, 5 (2015), 507–525.
[5]DanielBates,AdamBarth,andCollinJackson.2010. Regularexpressionscon-
sidered harmful in client-side XSS filters. In Proceedings of the 19th International
Conference on World Wide Web, WWW 2010, Raleigh, North Carolina, USA, April
26-30, 2010, Michael Rappa, Paul Jones, Juliana Freire, and Soumen Chakrabarti
(Eds.). ACM, 91–100. https://doi.org/10.1145/1772690.1772701
[6]Fabian Beck, Stefan Gulan, Benjamin Biegel, Sebastian Baltes, and Daniel
Weiskopf. 2014. RegViz: visual debugging of regular expressions. In 36th In-
ternational Conference on Software Engineering, ICSE ’14, Companion Proceedings,Hyderabad, India,May 31 -June07, 2014 , Pankaj Jalote, Lionel C.Briand, and An-
drévanderHoek(Eds.).ACM,504–507. https://doi.org/10.1145/2591062.2591111
[7]AriannaBlasi,AlbertoGoffi,KonstantinKuznetsov,AlessandraGorla,MichaelD.
Ernst, Mauro Pezzè, and Sergio Delgado Castellanos. 2018. Translating code
comments toprocedure specifications. In Proceedings ofthe 27th ACM SIGSOFT
InternationalSymposiumonSoftwareTestingandAnalysis,ISSTA2018,Amsterdam,
TheNetherlands,July16-21,2018,FrankTipandEricBodden(Eds.).ACM,242–253.
https://doi.org/10.1145/3213846.3213872
[8]Cristiano Calcagno, Dino Distefano, Jérémy Dubreil, Dominik Gabi, Pieter
Hooimeijer,MartinoLuca,PeterW.O’Hearn,IrenePapakonstantinou,JimPur-
brick,andDulmaRodriguez.2015. MovingFastwithSoftwareVerification.In
NASAFormalMethods-7thInternationalSymposium,NFM2015,Pasadena,CA,
USA, April 27-29, 2015, Proceedings (Lecture Notes in Computer Science), Klaus
Havelund, Gerard J. Holzmann, and Rajeev Joshi (Eds.), Vol. 9058. Springer, 3–11.
https://doi.org/10.1007/978-3-319-17524-9_1
[9]Michael Carraz, Konstaninos Korakitis, Peter Crocker, Richard Muir, and
Christina Voskoglou. 2020. Developer Economics: State of the Developer Nation.
SlashData, Ltd..
[10]Carl Chapman and Kathryn T. Stolee. 2016. Exploring regular expression usage
and context in Python. In Proceedings of the 25th International Symposium on
Software Testing and Analysis, ISSTA 2016, Saarbrücken, Germany, July 18-20,2016, Andreas Zeller and Abhik Roychoudhury (Eds.). ACM, 282–293. https:
//doi.org/10.1145/2931037.2931073
[11]Tse-Hsun Chen, Meiyappan Nagappan, Emad Shihab, and Ahmed E. Hassan.
2014. Anempiricalstudyofdormantbugs.In 11thWorkingConferenceonMining
SoftwareRepositories,MSR2014,Proceedings,May31-June1,2014,Hyderabad,
India,PremkumarT.Devanbu,SungKim,andMartinPinzger(Eds.).ACM,82–91.
https://doi.org/10.1145/2597073.2597108
[12]TsongYChen,ShingCCheung,andShiuMingYiu.1998. Metamorphictesting:a
newapproach forgeneratingnexttestcases. TechnicalReport.TechnicalReport
HKUST-CS98-01, Department of Computer Science, Hong Kong ....
[13]Andy Chou, Junfeng Yang, Benjamin Chelf, Seth Hallem, and Dawson R. Engler.
2001. An Empirical Study of Operating System Errors. In Proceedings of the
18thACMSymposiumonOperatingSystemPrinciples,SOSP2001,ChateauLake
Louise, Banff, Alberta, Canada, October 21-24, 2001 , Keith Marzullo and Mahadev
Satyanarayanan (Eds.). ACM, 73–88. https://doi.org/10.1145/502034.502042
[14]Shauvik Roy Choudhary, Husayn Versee, and Alessandro Orso. 2010. WEBDIFF:
Automated identification of cross-browser issues in web applications. In 26th
IEEEInternationalConferenceonSoftwareMaintenance(ICSM2010),September
12-18, 2010, Timisoara, Romania. IEEE Computer Society, 1–10. https://doi.org/
10.1109/ICSM.2010.5609723
[15]Aske Simon Christensen, Anders Møller, and Michael I. Schwartzbach. 2003.Precise Analysis of String Expressions. In Static Analysis, 10th International
Symposium, SAS 2003, San Diego, CA, USA, June 11-13, 2003, Proceedings (Lecture
Notes in Computer Science), Radhia Cousot (Ed.), Vol. 2694. Springer, 1–18. https:
//doi.org/10.1007/3-540-44898-5_1
[16]Crispin Cowan, Matt Barringer, Steve Beattie, Greg Kroah-Hartman, MichaelFrantzen, and Jamie Lokier. 2001. FormatGuard: Automatic Protection From
printf Format String Vulnerabilities. In 10th USENIX Security Symposium, August
13-17, 2001, Washington, D.C., USA, Dan S. Wallach (Ed.). USENIX. http://www.
usenix.org/publications/library/proceedings/sec01/cowanbarringer.html
[17]Scott A. Crosby and Dan S. Wallach. 2003. Denial of Service via AlgorithmicComplexity Attacks. In Proceedings of the 12th Conference on USENIX Security
Symposium - Volume 12. USENIX.
[18]Andrew Habib and Michael Pradel. 2018. How Many of All Bugs Do We Find? A
Study of Static Bug Detectors. In ASE.
[19]XueHanandTingtingYu.2016. AnEmpiricalStudyonPerformanceBugsfor
Highly Configurable Software Systems. In ESEM.
[20]David Hovemeyer and William Pugh. 2004. Finding bugs is easy. In Compan-
iontothe ConferenceonObject-OrientedProgramming, Systems,Languages,and
Applications (OOPSLA). ACM, 132–136.
[21]Md Johirul Islam, Giang Nguyen, Rangeet Pan, and Hridesh Rajan. 2019. A
Comprehensive Study on Deep Learning Bug Characteristics. In FSE.
[22]Guoliang Jin, Linhai Song, Xiaoming Shi, Joel Scherpelz, and Shan Lu. 2012.Understanding and detecting real-world performance bugs. In Conference on
Programming Language Design and Implementation (PLDI). ACM, 77–88.
[23]Adam Kiezun, Vijay Ganesh, Philip J. Guo, Pieter Hooimeijer, and Michael D.
Ernst.2009.HAMPI:asolverforstringconstraints.In ProceedingsoftheEighteenth
InternationalSymposiumonSoftwareTestingandAnalysis,ISSTA2009,Chicago,IL,USA,July19-23,2009,GreggRothermelandLauraK.Dillon(Eds.).ACM,105–116.
https://doi.org/10.1145/1572272.1572286
[24]Adam Kiezun, Philip J. Guo, Karthick Jayaraman, and Michael D. Ernst. 2009.
Automatic creation of SQL Injection and cross-site scripting attacks. In ICSE.
199–209.
[25]Claire Le Goues, Michael Pradel, and Abhik Roychoudhury. 2019. Automatedprogram repair. Commun. ACM 62, 12 (2019), 56–65. https://doi.org/10.1145/
3318162
966[26]Zhenmin Li and Yuanyuan Zhou. 2005. PR-Miner: Automatically Extracting
ImplicitProgrammingRulesandDetectingViolationsinLargeSoftwareCode.
InEuropeanSoftwareEngineeringConferenceandSymposiumonFoundationsof
Software Engineering (ESEC/FSE). ACM, 306–315.
[27]Yepang Liu, Chang Xu, and S.C. Cheung. 2014. Characterizing and Detecting
Performance Bugs for Smartphone Applications. In ICSE. 1013–1024.
[28]ShanLu,SoyeonPark,EunsooSeo,andYuanyuanZhou.2008. Learningfrom
mistakes: a comprehensive study on real world concurrency bug characteristics.
InConferenceonArchitecturalSupportforProgrammingLanguagesandOperating
Systems (ASPLOS). ACM, 329–339.
[29]Rabee Sohail Malik, Jibesh Patra, and Michael Pradel. 2019. NL2Type: inferring
JavaScriptfunctiontypesfromnaturallanguageinformation.In Proceedingsof
the 41st International Conference on Software Engineering, ICSE 2019, Montreal,
QC, Canada, May 25-31, 2019. 304–315. https://doi.org/10.1109/ICSE.2019.00045
[30]William M. McKeeman. 1998. Differential Testing for Software. Digital Technical
Journal10, 1 (1998), 100–107.
[31]FrolinS.OcarizaJr.,KartikBajaj,KarthikPattabiraman,andAliMesbah.2013.
AnEmpiricalStudyofClient-SideJavaScriptBugs.In SymposiumonEmpirical
Software Engineering and Measurement (ESEM). 55–64.
[32]Michael Pradel and Thomas R. Gross. 2009. Automatic Generation of Object
UsageSpecificationsfromLargeMethodTraces.In InternationalConferenceon
Automated Software Engineering (ASE). 371–382.
[33]Michael Pradeland KoushikSen. 2015. The Good, the Bad,and theUgly: An Em-
pirical Study of Implicit Type Conversions in JavaScript. In European Conference
on Object-Oriented Programming (ECOOP).
[34]Michael Pradel and Koushik Sen. 2018. DeepBugs: A learning approach to
name-based bug detection. PACMPL 2, OOPSLA (2018), 147:1–147:25. https:
//doi.org/10.1145/3276517
[35]Sergio Segura, Gordon Fraser, Ana B Sanchez, and Antonio Ruiz-Cortés. 2016. A
survey onmetamorphic testing. IEEE Transactionson softwareengineering 42, 9
(2016), 805–824.
[36]MarijaSelakovicandMichaelPradel. 2016. PerformanceIssuesandOptimiza-
tionsin JavaScript:AnEmpiricalStudy.In InternationalConference onSoftware
Engineering (ICSE). 61–72.
[37]Umesh Shankar, Kunal Talwar, Jeffrey S. Foster, and David A. Wagner. 2001.Detecting Format String Vulnerabilities with Type Qualifiers. In 10th USENIX
Security Symposium, August 13-17, 2001, Washington, D.C., USA, Dan S. Wallach
(Ed.).USENIX. http://www.usenix.org/publications/library/proceedings/sec01/
shankar.html
[38]EricSpishak,WernerDietl,andMichaelD.Ernst.2012. Atypesystemforregular
expressions. In Proceedings ofthe 14th Workshop on FormalTechniquesfor Java-
like Programs, FTfJP 2012, Beijing, China, June 12, 2012, Wei-Ngan Chin and
Aquinas Hobor (Eds.). ACM, 20–26. https://doi.org/10.1145/2318202.2318207
[39]Cristian-Alexandru Staicu and Michael Pradel. 2018. Freezing the Web: A Study
ofReDoSVulnerabilitiesinJavaScript-basedWebServers.In USENIXSecurity
Symposium. 361–376.
[40]LinTan,DingYuan,GopalKrishna,andYuanyuanZhou.2007. /*icomment:bugs
or bad comments?*/. In Proceedings of the 21st ACM Symposium on Operating
Systems Principles 2007, SOSP 2007, Stevenson, Washington, USA, October 14-17,
2007, Thomas C. Bressoud and M. Frans Kaashoek (Eds.). ACM, 145–158. https:
//doi.org/10.1145/1294261.1294276
[41]Kristín Fjóla Tómasdóttir, Mauricio Finavaro Aniche, and Arie van Deursen.
2017. Why and how JavaScript developers use linters. In Proceedings of the 32nd
IEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering,ASE2017,
Urbana, IL, USA, October 30 - November 03, 2017, Grigore Rosu, Massimiliano Di
Penta, and Tien N. Nguyen (Eds.). IEEE Computer Society, 578–589. https:
//doi.org/10.1109/ASE.2017.8115668
[42]Arash Vahabzadeh,Amin Milani Fard, and AliMesbah. 2015. Anempirical studyofbugsintestcode.In 2015IEEEInternationalConferenceonSoftwareMaintenance
and Evolution, ICSME 2015, Bremen, Germany, September 29 - October 1, 2015,Rainer Koschke, Jens Krinke, and Martin P. Robillard (Eds.). IEEE Computer
Society, 101–110. https://doi.org/10.1109/ICSM.2015.7332456
[43]Margus Veanes, Peli de Halleux, and Nikolai Tillmann. 2010. Rex: Symbolic
RegularExpressionExplorer.In ThirdInternationalConferenceonSoftwareTesting,
VerificationandValidation,ICST2010,Paris,France,April7-9,2010.IEEEComputer
Society, 498–507. https://doi.org/10.1109/ICST.2010.15
[44]Zhiyuan Wan, David Lo, Xin Xia, and Liang Cai. 2017. Bug characteristics inblockchain systems: a large-scale empirical study. In Proceedings of the 14th
International Conference on Mining Software Repositories, MSR 2017, Buenos Aires,
Argentina, May 20-28, 2017, Jesús M. González-Barahona, Abram Hindle, and Lin
Tan(Eds.).IEEEComputerSociety,413–424. https://doi.org/10.1109/MSR.2017.59
[45]Jie Wang, Wensheng Dou, Yu Gao, Chushu Gao, Feng Qin, Kang Yin, and Jun
Wei.2017. AcomprehensivestudyonrealworldconcurrencybugsinNode.js.In
Proceedingsofthe32ndIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering,ASE2017,Urbana,IL,USA,October30-November03,2017.520–531.
[46]PeipeiWang,ChrisBrown,JamieAJennings,andKathrynTStolee.[n.d.]. An
Empirical Study on Regular Expression Bugs. ([n.d.]).[47]Peipei Wang and Kathryn T. Stolee. 2018. How well are regular expressionstested in the wild?. In Proceedings of the 2018 ACM Joint Meeting on European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering, ESEC/SIGSOFT FSE 2018, Lake Buena Vista, FL, USA, November 04-09,
2018, Gary T. Leavens, Alessandro Garcia, and Corina S. Pasareanu (Eds.). ACM,
668–678. https://doi.org/10.1145/3236024.3236072
[48]YuhaoZhang,YifanChen,Shing-ChiCheung,YingfeiXiong,andLuZhang.2018.
AnempiricalstudyonTensorFlowprogrambugs.In Proceedingsofthe27thACM
SIGSOFTInternationalSymposiumonSoftwareTestingandAnalysis,ISSTA2018,
Amsterdam, The Netherlands, July 16-21, 2018, Frank Tip and Eric Bodden (Eds.).
ACM, 129–140. https://doi.org/10.1145/3213846.3213866
[49]HaoZhong,TaoXie,LuZhang,JianPei,andHongMei.2009. MAPO:Miningand
RecommendingAPIUsagePatterns.In EuropeanConferenceonObject-Oriented
Programming (ECOOP). 318–343.
967