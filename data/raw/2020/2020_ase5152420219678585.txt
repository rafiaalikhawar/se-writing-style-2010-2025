Refactorings and Technical Debt in
Docker Projects: An Empirical Study
Emna Ksontini, Marouane Kessentini, Thiago do N. Ferreira and Foyzul Hassan
University of Michigan-Dearborn, Dearborn, MI, USA
{emna, marouane, thiagod, Foyzul}@umich.edu,
Abstract ‚ÄîSoftware containers, such as Docker, are recently
considered as the mainstream technology of providing reusable
software artifacts. Developers can easily build and deploy theirapplications based on the large number of reusable Dockerimages that are publicly available. Thus, a current popular trendin industry is to move towards the containerization of their appli-cations. However, container-based projects compromise differentcomponents including the Docker and Docker-compose Ô¨Åles, andseveral other dependencies to the source code combining differentcontainers and facilitating the interactions with them. Similar toany other complex systems, container-based projects are proneto various quality and technical debt issues related to differentartifacts: Docker and Docker-compose Ô¨Åles, and regular sourcecode ones. Unfortunately, there is a gap of knowledge in howcontainer-based projects actually evolve and are maintained.
In this paper, we address the above gap by studying refac-
torings, i.e., structural changes while preserving the behavior,applied in open-source Docker projects, and the technical debtissues they alleviate. We analyzed 68 projects, consisting of 19,5MLOC, along with 193 manually examined commits. The resultsindicate that developers refactor these Docker projects for a vari-ety of reasons that are speciÔ¨Åc to the conÔ¨Åguration, combinationand execution of containers, leading to several new technical debtcategories and refactoring types compared to existing refactoringdomains. For instance, refactorings for reducing the image sizeof DockerÔ¨Åles, improving the extensibility of Docker-composeÔ¨Åles, and regular source code refactorings are mainly associatedwith the evolution of Docker and Docker-compose Ô¨Åles. We alsointroduced 24 new Docker-speciÔ¨Åc refactorings and technical debtcategories, respectively, and deÔ¨Åned different best practices. Theimplications of this study will assist practitioners, tool builders,and educators in improving the quality of Docker projects.
Index T erms‚ÄîDocker, containers, refactoring, technical debt,
maintenance
I. I NTRODUCTION
The containerization of software applications has recently
becoming popular in software industry to improve the reusabil-
ity, modularity, portability, security and costs of systems andtheir development [35], [7]. Among containerization frame-works, Docker is the main containerization framework inthe open-source community [7] and industry as 79% of ITcompanies use it [27]. Indeed, Docker enables packaging anapplication with its dependencies and execution environmentinto a standardized, self-contained unit, which can be usedfor software development and to increase the portability ofthe applications [7]. The contents of a Docker container aredeÔ¨Åned in a DockerÔ¨Åle. The Docker-compose is a tool forrunning multi-container applications on Docker and it is de-Ô¨Åned by a Compose Ô¨Åle format to orchestrate their execution.Source code repositories of Docker projects contain Dockerand Docker-compose Ô¨Åles, as well as regular source code Ô¨Åleswritten in a traditional programming language, such as Java,to implement the app hosting the containers and facilitate theirexecution and synchronization with other features.
Similar to any other complex systems, container-based
projects are prone to various quality and technical debt issuesrelated to different artifacts: Docker and Docker-compose Ô¨Ålesand regular source code ones. Unfortunately, there is a gapof knowledge in how container-based projects actually evolveand are maintained. Few recent studies focused mainly on thedetection of the quality issues related to the DockerÔ¨Åles interms of the violation of the basic shell scripts practices [15],[14]. However, there is no holistic understanding of thequality issues of Docker projects that could affect differentartifacts beyond just the shell scripts in the DockerÔ¨Åles.Furthermore, the correction of these issues via refactorings,deÔ¨Åned as changes to improve the structure while preservingthe behavior, is still not yet explore in the literature unlikeother refactoring domains [1]. As Docker projects becomemore complex and expensive to maintain [7], it is critical tounderstand the refactorings that developers would apply.
In this paper, we address the above gap by conducting
an empirical study on refactorings, i.e., structural changeswhile preserving the behavior, applied in open-source Dockerprojects. The new knowledge out of the empirical studyincludes the discovery of (a) the types of technical debtaddressed and whether they are speciÔ¨Åc to Docker projects, (b)the refactoring types that are common in the different artifactsof Docker projects, and (c) new generalizable Docker-speciÔ¨Åcrefactorings and technical debt categories, if any.
Studying the refactoring types and technical debt categories
that are typically found within Docker projects can lead tonew automated Docker-speciÔ¨Åc refactoring techniques, qualityissues detection tools for Docker and Docker-compose Ô¨Ålesand associated source code, and automated Docker-speciÔ¨Åcrefactoring mining tools and techniques. The implications ofthe empirical study of this paper will help to (i) understandhow and why quality issues and technical debts appear inDocker projects and how refactorings would address thoseissues, (ii) design new automated tools to integrate novelDocker-speciÔ¨Åc refactorings, (iii) provide guidelines for bestpractices, and anti-patterns/bad smells for practitioners inevolving effectively Docker projects, and (iv) assist educatorsin teaching quality issues related to Docker projects.
7812021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000742021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678585
978-1-6654-0337-5/21/$31.00  ¬©2021  IEEE
We analyzed 68 projects, consisting of 19,5 MLOC, along
with 193 manually examined commits that include refactor-
ings. The analyzed refactorings were labeled as being per-formed in Docker and Docker-compose Ô¨Åles or regular codeÔ¨Åles, and related to the Docker-speciÔ¨Åc debt they alleviated.For the regular code refactorings, we used RefMiner [33]to detect the refactorings in Java Ô¨Åles. With the identiÔ¨Åedrefactorings in Docker projects, we developed a refactoringtaxonomy. The results indicate that developers refactor theseDocker projects for a variety of reasons that are speciÔ¨Åc tothe conÔ¨Åguration, combination, and execution of containers,by leading to several new technical debt categories and refac-toring types compared to traditional source-focused refactor-ing domains. For instance, the reduction of the image sizeparticularly involved refactorings of DockerÔ¨Åles, improvingthe extensibility is one of the main reasons for refactoringthe Docker-compose, and regular source code refactoringsare mainly associated with the evolution of DockerÔ¨Åles andDocker-compose. Our study indicates that (i) improving thebuild time, maintainability and reducing the image size are themain quality issues addressed in DockerÔ¨Åles, (ii) increasing thereusability, understandably and extensibility are driven most ofthe applied refactoring applied to Docker-compose Ô¨Åles, and(iii) the evolution of the Docker and Docker-compose Ô¨Ålesresulted in various refactorings applied to the source coderelated to the Docker projects.
The main contributions of this paper can be summarized as
follows:
‚Ä¢Based on the manual analysis of 68 Docker projects,we propose a rich taxonomy of generic and Docker-speciÔ¨Åc refactorings. Furthermore, this study provides tothe community the Ô¨Årst dataset on refactorings in Dockerprojects.
‚Ä¢We also introduce 24 new refactorings and 7 new tech-nical debt categories speciÔ¨Åc to Docker projects.
‚Ä¢We propose recommendations, best practices, and anti-patterns for the evolution of Docker and Docker-composeÔ¨Åles from our in-depth analysis of Docker projects.
Replication Package. All material and data used in our
study are available in our replication package [4].
II. B
ACKGROUND
A. Docker and Container-based Projects
Docker [10], is the most popular container virtualization
technology [7], [27]. It aims on packaging application‚Äôs codeand dependencies into a light-weight, standalone and portableexecution environment. Thus, deploying containerized appli-cations is an agile process. Docker container images are builtusing Dockerfile, a document containing a sequence of
instructions used for creating the computational environment,following the notion of Infrastructure-as-Code(IaC) [17].
Listing 1 illustrates an example of Dockerfile. It starts
from a previously existing base image deÔ¨Åned by the
FROM
instruction which acts as a starting point from which theDocker image will inherit infrastructure deÔ¨Ånitions. This par-ent image can be an ofÔ¨Åcial Docker image (e.g., alpine) or1 FROM node:argon
2 # Create app directory
3 WORKDIR /usr/src/app
4 # Install app dependencies
5 COPY package *.json /usr/src/app/
6 RUN npm install
7 # Bundle app source
8 COPY . /usr/src/app
9 # Expose the app to the outside world
10 EXPOSE 8080
11 CMD ["npm", "start" ]
Listing 1: DockerÔ¨Åle example.
any other existing image (e.g., with a pre-installed software).In order to suit the application needs and to create the desiredenvironment, DockerÔ¨Åle offers a list of setup instructionswhich can be listed in Table I.
T ABLE I: DockerÔ¨Åle setup instructions.
Instruction Description
ENV Setting the environment variables
ARG DeÔ¨Åning variables that can be set at build time
WORKDIR Setting working directory for all subsequent instructions
COPY Copying Ô¨Åles from host to the Docker image
ADDSimilar to COPY instruction but supports two additional tricks. It
supports the use of URL instead of a local Ô¨Åle and can recognize
the archive format and extract it directly into the destination
LABEL Key value pairs, indicating image metadata
RUN Executing any command
EXPOSE Informs Docker that the container is exposing a particular port
CMDSetting a command and/or parameters, that executes when thecontainer is starting and which can be overwritten at build time
ENTRYPOINTSetting executable that will always run when the container isinitiated and cannot be overwritten.
In the Docker paradigm, each container captures one par-
ticular component of the software (e.g., database). Thus,
when creating multi-component application using Docker, it isunavoidable to combine multiple software components (con-tainers) into an intricate workÔ¨Çow. To tackle this challenge,containers need to be instantiated and properly integrated.Docker-compose [11], can be used to mitigate this challengeby providing a uniÔ¨Åed setup routine that deploys severalcontainers using a Y AML conÔ¨Åguration Ô¨Åle, as known as,Docker-compose.yml (or just Docker-compose).
1 version: "3.7"
2 services:
3 server:
4 build:.
5 ports:
6 - 8080:4040
7 environment:
8 - DB_ADDRESS=database-mongo
9 - DB_PORT=27017
10 - PORT=4040
11 depends_on:
12 - database
13 database:
14 image: mongo:latest
15 volumes:
16 - mydata:/data/db
17 volumes:
18 mydata:
Listing 2: Docker-compose example.
An example of a Docker-compose Ô¨Åle is available
in Listing 2. The example shows that the Docker-compose
782Ô¨Åle is composed of two components/containers ( SERVER and
DATABASE ). The SERVER component is represented by a
local image (built from a Dockerfile, for instance that
one available in Listing 1) and the DATABASE component is
created from the ‚Äúmongo‚Äù image, hosted in DockerHub [12]
(an online registry for Docker Images). Docker-compose Ô¨Ålealso provides a list of setup attributes which can be listedin Table II.
T ABLE II: Docker-compose setup attributes.
Attribute Description
BUILD Setting path to the build context
IMAGE Setting the image to start the container from
PORTS Specify ports binding
ENVIRONMENT Setting environment variables
DEPENDS _ON Expressing dependency between services
VOLUMES Setting volume bindings (host paths or named volumes)
Any typical Docker project includes the above Ô¨Åles along
with source code Ô¨Åles written in a typical programminglanguages, such as Java, to host the containers and enable theirexecutions and synchronization with other features of the appthat may not be containerized.
B. Technical Debt and Refactoring
Software technical debt reÔ¨Çects the implied cost of addi-
tional rework caused by choosing an easy (limited) solution
now instead of using a better approach that would take longerwhen designing and evolving software systems [6].
To deal with technical debt, refactorings are widely used
practice [8]. Martin Fowler [13] deÔ¨Ånes refactoring as ‚Äúachange made to the internal structure of software to make iteasier to understand and cheaper to modify without changingits observable behavior‚Äù. This implies that refactoring is amethod that reconÔ¨Ågures code structures, without altering itsbehavior, to improve code quality in terms of maintainability,extensibility, and reusability. Different refactoring types aredeÔ¨Åned in the literature including Move Method, ExtractMethod, Move Class, Move Attributes, etc. A full list oftypical code refactoring types can be found in [22], [2],[3]. Recent empirical studies on refactoring show that theserefactorings are widely used in open-source projects [31], [1],[28]. However, refactoring is still under-explored for Dockerand containerization unlike other paradigms, such as object-oriented programming, web services, etc.
III. M
ETHODOLOGY
Based mainly on manual analysis, we investigated the com-
mon refactorings in Docker projects. This study may presentan empirical foundation for new refactoring types for thedifferent artifacts of Docker projects to support practitionersin addressing Docker related technical debts.
A. Projects Selection
The proposed study includes a total of 68 open-source
Docker projects as described in Table III. They differ sig-
niÔ¨Åcantly in their size and their popularity. These projects arecomprising a total of 19+ MLOC with an average evolutionhistory of 6+ years per project. We Ô¨Årst selected Dockerprojects from the public GitHub archive on BigQuery [9],where our initial list included 2,342 open-source Dockerprojects. Then, we eliminated non-existing projects sinceBigQuery‚Äôs last update was in 2019 and removed repositoriesforked from other repositories to avoid biasing our study, aslarge and popular projects are forked frequently.
We applied a selection criterion aiming to have at least one
commit message mentioning the keywords
REFACTOR and
DOCKER , and at least one part of the project must include
Docker. The number of commits having the required keywordswas initially 4,469 commits with a maximum of 73 commitsper repository. In our Ô¨Ånal selection, we focused mainly ona total of 68 Docker projects that were mostly written inJava for the code beyond the Docker and Docker-composeÔ¨Åles, as it is a popular programming language to developapps hosting containers [37]. However, we still also consideredDocker projects with signiÔ¨Åcant evolution written in otherlanguages including C++. To support the manual analysis ofthe Java code, we used an assisting tool, RefMiner [33], butwe note that most of the manual investigation efforts weremainly on the Docker and Docker-compose Ô¨Åles to identifyrelevant Docker-speciÔ¨Åc refactorings beyond the traditionalobject-oriented refactoring.
The above selection mechanism yielded a total of 193
commits having the required keywords, ranging from 1 to 12commit per project (column KWS) and a total of 611 Docker-
speciÔ¨Åc Ô¨Åle changes (column DFC). We manually examined
the changes associated with these commits to Ô¨Ånd patches rep-resenting possible refactoring and addressed technical debts.
B. Commits Mining
To extracted commits that include refactorings from
BigQuery achieve, we used the SQL query presented
in Listing 3.
1 SELECT *FROM
2 "bigquery-public-data.github_repos.commits"
3 WHERE (message LIKE '%refactor%')
4 AND (message LIKE '%docker%')
Listing 3: SQL instructions for BigQuery.
The keywords were queried via the SQL like operator,
where the % sign was used to represent zero, one, or multiplecharacters. The expression %
REFACTOR % matches strings
containing the word refactor (.e.g., refactoring, refactored) andthe expression %
DOCKER % matches strings containing the
word docker (e.g., dockerÔ¨Åle, docker-compose).
C. Refactorings IdentiÔ¨Åcation
Since it is the Ô¨Årst study about Docker-speciÔ¨Åc refactorings,
it was necessary to manually inspect commits for refactoring
identiÔ¨Åcation. The keywords matching commits were chosenfor manual examination to Ô¨Ånd patches in DockerÔ¨Åle andDocker-compose Ô¨Åles representing one or more possible refac-toring, which required not only non-trivial efforts but alsodeep knowledge of the domain. Three of the authors have
783T ABLE III: Studied projects.
Subject KLOC DFC KWS
alebabai/linden-honey 4.8 8 8
all-of-us/workbench 350.7 2 1
amazeeio/lagoon 253.9 56 6
Artemkaaas/indy-sdk 352.5 6 4
aspuru-guzik-group/mission_control 87.3 2 1
Asqatasun/Contrast-Finder 23.8 16 1
bagage/cadastre-conÔ¨Çation 19.9 2 2
benbromhead/cassandra-operator 27.4 4 1
blobor/skipass.site 13.4 3 2
bookbrainz/bookbrainz-site 134.6 11 8
BSW ANG/denverdino.github.io 618.4 1 1
BuiltonDev/pipeline 2800 11 2
byran/cyber-dojo-web 37.6 1 5
cdietrich/che 1200 4 1
cgi-eoss/ftep 1400 1 1
cloudfoundry-incubator/diego-release 1300 24 1
CogStack/CogStack-Pipeline 53.2 9 3
collinbarrett/FilterLists 1100 28 6
CrunchyData/crunchy-containers 39.5 4 2
CrunchyData/crunchy-postgresql-manager 447.4 22 3
CrunchyData/postgres-operator 105.7 3 2
cyber-dojo-languages/image_builder 2.2 13 3
cyber-dojo-retired/storer 7 10 6
cyber-dojo/commander 5.4 1 12
di-unipi-socc/DockerFinder 28.4 5 1
drasko/mainÔ¨Çux 915.6 2 4
duderoot/generator-jhipster 218.9 3 1
eclipse/repairnator 400.8 4 2
ethereum/hive 22.2 2 2
gchq/stroom 1300 3 1
geotrellis/geodocker-cluster 2.9 8 2
go-ggz/ggz 8 18 2
harvard-vpal/bridge-adaptivity 12.2 2 1
hexagonkt/hexagon 33.8 6 6
HumanExposure/factotum 515.6 23 7
InnovateUKGitHub/innovation-funding-service 816.8 8 1
instructure/straitjacket 183.4 4 1
ITISFoundation/osparc-lab 459.2 1 2
kr1sp1n/node-vault 6.3 2 1
kuzzleio/kuzzle 143.9 2 2
labsai/EDDI 103.3 8 1
lixiaocong/lxcCMS 7.1 4 2
lockss/laaws-metadataservice 4.5 1 1
luismayta/dotÔ¨Åles 479.8 6 4
macarthur-lab/matchbox 85 1 1
mars-lan/datahub 79.3 17 5
Martin2112/trillian 119.2 3 1
MetaBarj0/carrier 13.1 6 1
mondediefr/mondedie-chat 10.9 6 6
muccg/rdrf 709 9 2
openpitrix/openpitrix 174 2 2
openzipkin/zipkin 111 20 3
ory-am/hydra 188.5 2 1
outlierbio/ob-pipelines 7.8 16 1
overture-stack/SONG 54.1 2 1
rackerlabs/blueÔ¨Çood 76.6 18 1
rancher/mesos-catalog 3.1 1 1
reportportal/service-api 55 10 9
RichardKnop/go-oauth2-server 9.8 7 1
robymes/OrdinglcDocker 42.7 24 10
scalableminds/webknossos 304.4 6 6
simonsdave/cloudfeaster 15 1 5
SKA-ScienceDataProcessor/integration-prototype 67.2 16 1
Soluto/tweek 74.2 8 2
staÔ¨Çi-org/staÔ¨Çi.stack.php 12.4 3 1
unbalancedparentheses/docker-erlang 5 69 1
vietj/vertx-pg-client 95.7 1 1
xhochy/arrow 1200 9 4
Total 19560.4 611 193
extensive expertise in refactoring, technical debt, and empirical
software engineering. Another author is an expert in Dockerand continuous integration including build repairs. Each of thefour authors analyzed separately all the considered commitsto identify the refactorings and later their rationale. They alsodiscussed the identiÔ¨Åed refactoring at the end of the process(and not before to avoid any bias) to solidify the resultsespecially when there are disagreements among the authors.
Cohen‚Äôs Kappa coefÔ¨Åcients [34] for refactoring identiÔ¨Å-
cation and related commits, including Docker and Docker-compose Ô¨Åles and regular source code Ô¨Åles, were 0.92, 0.83,and 0.88, respectively, which indicates a high conÔ¨Ådence ofagreement. Since the authors may not be very knowledgeableabout the code of the projects as they are not their originaldevelopers, they marked the refactorings and their associatedcommits only when they are very conÔ¨Ådent that the changesare actual refactorings. The authors also used commit mes-sages and comments in the code whenever available to conÔ¨Årmtheir decisions, which is a common practice [19].
D. Refactoring ClassiÔ¨Åcation
After the refactoring identiÔ¨Åcation phase and in order to
understand the refactoring types performed in Docker projects,
we analyzed the code changes within the selected list to deter-mine the refactoring types and their rationale (e.g., technicaldebts), whether the refactoring was applied in a DockerÔ¨Åle ora Docker-compose Ô¨Åle or regular source code Ô¨Åle (e.g., Java).
Discovered refactorings were then organized into a hi-
erarchy based on the addressed technical debts. Hence, afew categories were grouped beneath distinctive parent cat-egories within the hierarchy, i.e., change-sets containing afew interconnected refactorings were assembled into morecommon parent categories. A few of the refactorings weremore disconnected, i.e., change-sets comprising one sort ofrefactoring and difÔ¨Åcult to generalize.
Since the identiÔ¨Åed refactoring types of DockerÔ¨Åle and
Docker-compose may impact the regular source of the ap-plication hosting the containers, we have also manually in-vestigated the selected commits in this study to look at theintroduced code changes of Java/C++ Ô¨Åles, within the samecommit, whenever a Docker-speciÔ¨Åc refactoring is detected.To support the manual identiÔ¨Åcation of refactoring, we usedRefMiner [33] to conÔ¨Årm our manual Ô¨Åndings.
Finally, an inter-rater agreement analysis was used to
develop a classiÔ¨Åcation scheme to categorize the identiÔ¨Åedrefactorings under different technical debt categories. We alsoapplied the Cohen‚Äôs kappa coefÔ¨Åcient [34] by reaching 0.86 asresult between all the authors, which indicates high conÔ¨Ådenceof agreement. The few cases of disagreement were discussedbetween the authors at the end of the process and we wereable to Ô¨Ånd a consensus for all of them.
IV . R
ESULTS
A. Quantitative Analysis
We manually examined 193 unique commits from the dif-
ferent projects listed in Table III. The identiÔ¨Åcation of refactor-ings in these commits and analyzing is a very labor-intensivemanual task due to the lack of automated tools support. Wefound that 44 commits have DockerÔ¨Åle-related refactoring, 51commits have Docker-compose related refactorings, and 55commits of regular code refactorings (e.g., Java, C++, etc.)due to changes in DockerÔ¨Åle or Docker-compose. We observed
784T ABLE IV: Discovered Docker-speciÔ¨Åc refactoring types
Refactoring Type Artifact Description
Extract stage DockerÔ¨Åle Extract multi-stage building from a single-stage Building
Inline stage DockerÔ¨Åle Aggregate multi-stage building into a single stage
Move stage DockerÔ¨Åle Move a stage from a multi-stage context into another single stage context in a different DockerÔ¨Åle
Sort Instructions DockerÔ¨Åle Order Instructions sequence from the least frequently changing to the most frequently changing
Replace ADD Instruction
with COPY InstructionDockerÔ¨ÅleReplace ADD instruction with COPY Instruction when Ô¨Åles/directories need to be only copied from host tocontainer
Extract Run Instructions DockerÔ¨Åle Extract Run instructions commands into a separate script Ô¨Åle
Inline Run Instructions DockerÔ¨Åle Inline Run instructions into a single RUN instruction using && operator
Remove Run Instructionincluding mv commandDockerÔ¨Åle Delete RUN instruction with mv command and use previous COPY or ADD instructions to set the correct path
Update Base ImageDockerÔ¨Åle Avoid using unnecessary heavy image, replace base image with a lighter one
DockerÔ¨ÅleAvoid building and downloading dependencies on top of base image, replace base image with a larger one; ifdependencies are Ô¨Åxed and a similar image exits in public or private repo,use an existing Image
Rename ImageDocker-compose Set a relevant Name and T AG including the necessary information of your image (version, software..)
DockerÔ¨Åle Add or rename Image alias
Update RUN Instruction DockerÔ¨ÅleReformat RUN instruction commands; split commands into multiple lines where each line represents a singleoption/argument, order option/argument alphabetically, use backslash ...
Update Base Image T AGDockerÔ¨ÅleDRY principle, set a dynamic T AG using ARG instruction to avoid creating a new DockerÔ¨Åle when T AG isonly changing
DockerÔ¨Åle Change T AG value or Replace latest T AG with an explicit T AG
Add ENV variableDockerÔ¨ÅleAdd ENV variables to store useful system-wide valuesDocker-compose
Add ARG instruction DockerÔ¨ÅleDRY principle, set dynamic instructions using ARG instruction to avoid creating a new DockerÔ¨Åle for similarimages
Extract Ports Attribute Docker-compose Extract ports attribute into an override Docker-compose Ô¨Åle
Extract V olume Attribute Docker-compose Extract volume attribute into an override Docker-compose Ô¨Åle
Extract ENV Attribute Docker-compose Extract ENV attribute into an override Docker-compose Ô¨Åle or use .env Ô¨Åle
Move Service Docker-compose Extract service into an override Docker-compose Ô¨Åle
Rename Service Docker-compose Set a relevant Name for the service
Rename Container Docker-compose Set a relevant Name for the container
Rename V olume Docker-compose Set a relevant Name for the volume
Add Extends attribute Docker-compose Add Extends attribute to inherit conÔ¨Åguration from an existing service thus avoiding duplication
Reorder Services Docker-compose Order services based on their dependency order
Update Image T AG Docker-compose Change T AG value or Replace latest T AG with an explicit T AG
a total of 43 commits containing false-positive (22%). The
false-positive commits (i.e., keywords matching commits thatdid not include any refactorings), occurred due to differentreasons, including (i) the keyword refactor was used in
non-refactoring commit messages to highlight the needs forfuture refactorings; (ii) refactoring occurred out of Docker-speciÔ¨Åc context; or (iii) the lack of knowledge about thedomain as Docker-speciÔ¨Åc refactorings are a new concept andwere not explored before in the literature; thus some commitmessages described regular changes that alternate the behavioras refactoring.
The identiÔ¨Åed Docker-speciÔ¨Åc technical debts are listed
in Table V. For DockerÔ¨Åles, we found 6 technical debt cate-gories related to Image size, Build Time, Duplication, Main-
tainability, Understandability and Modularity. For Docker-
compose Ô¨Åles, 3 out of these 6 DockerÔ¨Åle categories arealso applicable: Duplication, Maintainability, and Understand-
ability. Furthermore, we found that Extensibility is another
technical debt addressed by developers in Docker-composeÔ¨Åles.
1) Docker-speciÔ¨Åc Technical Debts: Maintainability was
a major technical debt target for applied refactorings inDocker projects representing 55 occurrences (38%) and foundin DockerÔ¨Åle and Docker-composed Ô¨Åles. Indeed, container-based technologies are meant to provide the possibility toapply central modiÔ¨Åcations with having them rolled out overthe system with small endeavors and no downtime. Further-more, this technical debt was mainly associated mainly withthe excessive usage of environmental variables (27 commits)and T AG updates (21 commits) in both DockerÔ¨Åle and Docker-compose Ô¨Åles.
Understandability is the major refactorings target in Docker-
compose Ô¨Åles. In this category, 75% of the refactorings wereperformed to improve naming. The observed renaming hadvariety of motivation, such as avoiding the usage of irrelevantnames (e.g., using app as a service name), including softwareinformation (e.g., software version) in the image and T AGnames, as well as keeping naming consistency throughout theproject. Renaming was also present in DockerÔ¨Åle (6 commits).
Build Time was among the least addressed debts in
DockerÔ¨Åle (0.14%). In fact, the order of the DockerÔ¨Åle in-structions highly matters when re-building, because when astep‚Äôs cache is invalidated by changing Ô¨Åles or modifying linesin the DockerÔ¨Åle, subsequent steps of their cache will break.Thus, ordering steps from least to most frequently changing,is something to keep in mind when creating a DockerÔ¨Åle inorder to optimize caching.
Regarding to Modularity, we found 7 occurrences address-
ing only DockerÔ¨Åles where they try to apply multi-stagebuilding by separating the build from the run-time environ-
785T ABLE V: Discovered Docker-speciÔ¨Åc technical debt categories.
Technical Debt Artifact Goal Situation Consequence
Image size DockerÔ¨ÅleRefactorings are used to reduce the Ô¨Ånal image
sizeAdding new/changing componentsrequires huge modiÔ¨Åcations andmay lead to unexpected behaviors Huge disk space, difÔ¨Åcult to uploadand a huge attack surface
Build Time DockerÔ¨ÅleRefactorings are used to reduce the build or re-build time Docker engine takes a lot of timeto build the Ô¨Ånal image Evolving and changing the image be-came difÔ¨Åcult process
ExtensibilityDocker-
composeRefactorings are performed to increase the levelof abstractions and improve the reusability ofthe DockerÔ¨Åle and Docker-compose Ô¨Åles. Adding new components requireduplicationDuplication
DuplicationDocker-
composeRefactorings are introduced to Ô¨Åx duplicatedfragments in DockerÔ¨Åle and Docker-compose.Duplicated fragmentsAdding new/changing existing com-ponents is difÔ¨Åcult and error-prone
Maintainability BothRefactorings are performed to ease the modiÔ¨Å-cation as well as preventing large impact/spreadof future bugs/unexpected behavior Adding new/changing componentsrequires modifying existing Ô¨ÅlesModiÔ¨Åcations and upgrades requirehuge endeavors and conceivabledowntime
Understandability BothRefactorings are applied to reduce the effort tounderstand code, e.g., renaming elementsHuge efforts to understand codeSlight and simple modiÔ¨Åcations willbecome time consuming
Modularity DockerÔ¨ÅleRefactorings are used to reduce image complex-ity by breaking image into various stages.Complex imageAdding new/changing existing com-ponents is difÔ¨Åcult and error-prone
ment, which helps avoiding the inclusion of unnecessary build
dependencies in the Ô¨Ånal image.
2) Docker-speciÔ¨Åc Refactoring Types: We organized the
different refactoring types into a hierarchy based on thetechnical debt they addressed. Figure 1 shows the proposedtaxonomy of the refactorings and their rationale. We havealso highlighted the number of occurrence of these refactoringtypes in the analyzed commits. The gray square representsthe refactoring type along with the number of occurrences,the blue ellipse represents the artifact (DockerÔ¨Åle or Docker-compose), and the purple hexagon represents the technicaldebts which the detected refactoring addressed.
We categorized true-positive refactorings by manually clas-
sifying them into 24 new unique refactoring types. Table IVshows the lists of refactorings that were identiÔ¨Åed among theanalyzed commits. We deÔ¨Åned a total of 14 new DockerÔ¨Åle-related refactoring types and 12 new Docker-compose onesas described in Table IV. The overall number of refactoringsidentiÔ¨Åed in the manual commits analysis is 146 to addressthe aforementioned technical debts.
We found three extra DockerÔ¨Åle-related refactoring types
performed to improve Maintainability, namely, Update Base
Image (3 commits), Extract RUN Instructions (3 commits) and
Replace ADD Instruction with COPY Instruction (4 commits).
The Ô¨Årst refactoring type consists of using existing imageswhenever it is possible, to avoid building and downloadingdependencies on top of the base image. This will reduce main-tainability efforts as all required installations are done and bestpractices are probably applied especially when using ofÔ¨Åcialimages. The second refactoring type consists in extractinga shell script for a speciÔ¨Åc subsequent RUN instructions inDockerÔ¨Åle. This refactoring types does not only shrinks theimage size but also groups commands in a much more cleaner,simpler, and portable format. Finally, the third refactoringoperation embraces in using COPY instruction instead of ADDinstruction when Ô¨Åles/directories need to be only copied fromhost to container.
It is important to notice that the ADD instruction supports
other functionalities, such as the use of URL instead ofa local Ô¨Åles and it can also recognize the archive formatand extract it directly into the destination. This additionalfunctionalities might be considered as tricky in practice, asADD instruction may behave extremely unpredictable. Theresult of such unreliable behavior often came down to copyingwhen we want to extract and extracting when we want to copy.Unsurprisingly, a large proportion of the analyzed refactoringsin DockerÔ¨Åle aimed at reducing the image size (36%).
Regarding Image Size, we found Ô¨Åve possible refactorings
composed of Extract RUN Instructions (3 commits), Inline
RUN Instructions (4 commits), Remove RUN Instruction in-
cluding MV command (3 commits), Update Base Image (12
commits) and Extract stage (7 commits) were also included
in this category. Remove RUN Instruction including MV
command, in particular, aims at reducing layers number inattempt to shrinking the image size by removing the RUNinstruction with MV command and using previous COPY orADD instructions to set the correct path, if possible.
We also found several refactorings applied to make the
DockerÔ¨Åle less confusing and more modular. Such changesinvolved the improvement of structural aspects. For example,Update RUN Instruction (6 commits) in DockerÔ¨Åle which
consists in formatting commands within RUN instructions(e.g., splitting commands into multiple lines where each linerepresents a single option/argument) and Reorder Services (4
commits) in Docker-compose where developers reordered theservices sequence based on their dependency order.
Unlike Extract Stage, Inline Stage (4 commits) and Move
Stage (3 commits) aims at aggregating multi-stage building
into a single stage when multi-staging is unnecessary (i.e., nosigniÔ¨Åcant dependencies) and extracting a stage from a multi-stage context into a new single-stage context (e.g., extractingtest stage into a new DockerÔ¨Åle), respectively. The reasonbehind these refactorings is to improve the build time whenmulti-staging can be avoided. As multi-staging requires build-ing intermediary images that signiÔ¨Åcantly affects the buildtime.
We also found in DockerÔ¨Åle commits 10 refactorings aimed
at improving code design by avoiding duplication and fostering
786œ≤
œ∞
œ∞œ≤ œ≠ œ´œ≠ œ´œ±
œ¨
œ±œ∞œ± œ´ œ´ œ≤ œ≠
œ´
œ≠
œ≤
œ´œ™ œ´ œ´œ¨ œ≠ œ¨ œ´ œ¨ œ¨ œÆ )( 

(" +/ 

)./-0/$*)
) -./)$'$/4
0+'$/$*)
$)./-0/$*) +' 

)./-0/$*)2$/#

)./-0/$*)+/ . 

(" 

-$' +/ . 

(" 3/-/

)./-0/$*).
*& -!$'  )( 
 -1$ 
 )( 
*)/$) - )( 
*'0( 
 *- -
 -1$ . )( 

(" 
) -./)$'$/4
*& -–â*(+*. 3/-/
/" 
)'$) 
/" *1 
/" *-/

)./-0/$*).

//-$0/ 
-$' +/ 

(" 
œÆ
)'$) 

)./-0/$*). (*1 

)./-0/$*)$)'0$)"
*(()+/ . 

(" 
œ±3/-/
/" 3/-/

)./-0/$*).3/-/
//-$0/ .*1  -1$ 3/-/

//-$0/ .3/-/
//-$0/ .

(" .$5 
0$'$( 
*0'-$/4
$)/$)$'$/4
$)/$)$'$/4
 0+'$/$*)
3/ ).$$'$/4
Fig. 1: Docker speciÔ¨Åc refactorings taxonomy.
the reuse of the code fragments. Add ARG instruction (7
commits) in DockerÔ¨Åle involves adding arguments using the
ARG instruction to deÔ¨Åne common identiÔ¨Åers (e.g., softwareversion and Ô¨Åle/directories paths), that can be later used insideother instructions such as COPY , ADD and RUN, leadingto a dynamically changing DockerÔ¨Åle, as these identiÔ¨Åerscan be affected at build time. Besides, a total of 8 otherDocker-compose related refactorings were found to make theconÔ¨Åguration code more generalizable (3 commits), reusable(3 commits), and inter-operable (2 commits), by movingattributes to an override Docker-compose Ô¨Åle. Such practicehelps developers to reuse a single Docker-compose Ô¨Åle acrossdevelopment and production while being able to run differentservices.
on the vertical axis and regular code refactorings are rep-
resented on the horizontal axis. Each cell in the heatmapindicates the number of occurrences of a Docker-speciÔ¨Åcrefactoring type along with a regular code refactoring type.Darker colored cells indicates a strong co-occurence frequencywhile a lighter color signiÔ¨Åes a weaker co-occurence. Theobserved refactorings included 22 regular code refactoringtypes along with 9 Docker-speciÔ¨Åc refactorings types, 3 forDocker-compose (a) and 6 for DockerÔ¨Åle (b). It is clear thatUpdate Image TAG, Update Base Image and Extract Stage
are associated with extensive code refactoring of the hostingapplication involving almost all the refactoring types. In fact,those Docker-speciÔ¨Åc refactorings directly impact the codehosting the containers as they introduce signiÔ¨Åcant changesin the Image or the Stage(s) which are typically called fromthe hosting code similar to functions in APIs in other contexts.
B. Qualitative Analysis
The qualitative analysis aims at obtaining and analyzing
some examples of commits where the Docker-speciÔ¨Åc refac-
torings were found to address the most common/importanttechnical debt issues discussed in the previous section.
1) DockerÔ¨Åle Technical Debt and Refactoring Examples:
Several of analyzed refactorings aimed at improving maintain-Add ENV variableUpdate Image TAGRename Service
Rename VariableMove AttributeExtract Class
Rename MethodRename Class
Change Parameter TypeExtract SuperclassExtract MethodInline VariablePull Up MethodMove Class
Inline Method
Rename ParameterPull Up AttributeMove Method
 0 1 2 3
(a) Docker-compose.
Extract StageUpdate Base ImageAdd ARG InstructionUpdate Base Image TAGSort InstructionsAdd ENV Variable
Extract SubclassRename Variable
Modify Parameter AnnotationMove AttributeExtract Class
Extract AttributeRename MethodRename Class
Modify Attribute AnnotationPush Down Method
Change Parameter TypeExtract SuperclassChange Return TypeExtract MethodInline Variable
Push Down AttributePull Up MethodMove Class
Rename ParameterMove Method
 0 1 2 3
(b) DockerÔ¨Åle.
Fig. 2: Refactorings co-evolution: regular code refactoringsand Docker-speciÔ¨Åc refactorings.
ability from several perspectives. Let us consider the example
of the Update Base Image refactoring shown in Listing 4.
In this listing, openjdk was initially used as a base image
(Line 5) and Dockerize software was installed using RUN
instructions (Lines 7‚Äì12). However, the ofÔ¨Åcial Dockerize
image already exists with the required version v0.6.1 and itcan be easily pulled from DockerHub to act as a starting pointof the DockerÔ¨Åle (Line 6). This can save a lot of time spenton maintenance because all the installation steps are done andofÔ¨Åcial images can be highly trusted.
Build time is another critical technical debt in Docker
projects. When working on evolving and changing the image,build time is considered a dead time. The Sort Instructions
7871 diff --git Dockerfile
2 --- a/docker/elasticsearch/Dockerfile
3 +++ b/docker/elasticsearch/Dockerfile
4 @@ -1,17 +1,12 @@
5 -FROM openjdk:8
6 +FROM jwilder/dockerize:0.6.1
7 -RUN apt-get update && apt-get install -y wget
8 - && apt-get install -y curl
9 -ENV DOCKERIZE_VERSION v0.6.1
10 -RUN wget https://github.com/jwilder/docke[...]
11 - && tar -C /usr/local/bin -xzvf docker[...]
12 - && rm dockerize-linux-amd64-$DOCKERIZ[...]
Listing 4: Commit 4f221f9 from datahub: Refactored
DockerÔ¨Åle to reduce the number of pushed layers on a re-
build.
refactoring presented in Listing 5 can address build time
issues. In this example, a simple recompile of the app willchange the app.jar Ô¨Åle (Line 5) leading to a non-valid
caching step when rebuilding the image, and the subsequentsteps of the cache will then break (Lines 6‚Äì9). Orderinginstructions from the least frequently changing to the mostfrequently changing will be highly efÔ¨Åcient in such scenario.As mentioned in the commit message, the goal was to ‚Äúreducethe amount of pushed layers on a simple recompile‚Äù leadingto an optimize caching and a faster build time.
1 diff --git Dockerfile
2 --- [...]/src/main/docker/Dockerfile
3 +++ [...]/src/main/docker/Dockerfile
4 @@ -11,9 +11,10 @@
5 -ADD ifs-data-service-1.0-SNAPSHOT.jar app.jar
6 -RUN sh -c 'touch /app.jar'
7 -ENTRYPOINT ["java",[...],"-jar","/app.jar"]
8 -CMD curl -f http://localhost:8080/monito [...]
9 HEALTHCHECK --interval=10s --timeout=3s \
10 +CMD curl -f http://localhost:8080/monito [...]
11 +RUN sh -c 'touch /app.jar'
12 +ENTRYPOINT ["java",[...],"-jar","/app.jar"]
13 +ADD ifs-data-service-1.0-SNAPSHOT.jar app.jar
Listing 5: Commit f7b5921 from innovation-
funding-service: Refactored DockerÔ¨Åle to reducethe number of pushed layer on re-build.
Image Size is the second most frequent category of technical
debts in DockerÔ¨Åle besides Maintainbility. Indeed, Docker
projects are prone to image size increases due to layerbased structure of the image. In general, the smaller theimage, the quicker it is uploaded, and the faster it can scale.Besides, small images are considered to have less vulnera-bilities. The Update Image refactoring shown in Listing 6
can used to Ô¨Åx issues related to the Image Size. In thisexample, ubuntu:14.10 base image was replaced with
phusion/baseimage and the subsequent RUN instructions
(Lines 6‚Äì11) were extracted in a separate shell script calledinstall.sh. This new base image is also an ubuntu based
image, but it includes modiÔ¨Åcations for Docker-friendliness.Therefore, as each RUN instruction represents a unique andsingle layer, this refactoring can shrink the image by reducingthe number of layers. Besides, the goal of this refactoring wasalso described in the commit message ‚Äúrefactor of DockerÔ¨Åleto generate images that occupy less space‚Äù.1 diff --git Dockerfile
2 --- a/17.0-rc1/Dockerfile
3 +++ b/17.0-rc1/Dockerfile
4 -FROM ubuntu:14.10
5 +FROM phusion/baseimage
6 -RUN cd /usr/src \
7 - && tar xf otp_src_${ERLANG_VERSION}.tar.gz\
8 - && cd otp_src_${ERLANG_VERSION} \
9 - && ./configure \
10 - && make \
11 - && make install
12 +RUN /build/install.sh
13 diff --git install.sh
14 --- /dev/null
15 +++ b/17.0-rc1/install.sh
Listing 6: Commit 9787e1a fromdocker-erlang: Refac-
tored DockerÔ¨Åle to generate a smaller image.
2) Docker-compose Technical Debt and Refactoring Ex-
amples: Regarding to Docker-compose Ô¨Åles, Extensibility is
a common and frequent technical debt as described in thequantitative analysis. In general, the Docker-compose Ô¨Åle‚Äôsextensibility should be improved when both development andproduction environments are located in the same Ô¨Åle. Move
Services refactoring shown in Listing 7 can be used to improve
the extensibility of Docker compose Ô¨Åles. In this exampledevelopers moved benchmark_resin services (Lines 9‚Äì
12) to a new override Ô¨Åle (Line 16). Therefore, they wereable to reuse a single Docker-compose Ô¨Åle while being ableto run different services.
1 diff --git docker-compose.yaml
2 --- a/docker-compose.yaml
3 +++ b/docker-compose.yaml
4 @@ -24,22 +24,3 @@ services:
5 -benchmark_resin:
6 - build: {[...]}
7 - depends_on: [...]
8 - ports: [...]
9 diff --git/hexagon_benchmark/docker-compose.yaml
10 --- /dev/null
11 +++ b/hexagon_benchmark/docker-compose.yaml
Listing 7: Commit 99109b6 from hexagon: Refactored
Docker-compose Ô¨Åle to make ‚Äúbenchmark services‚Äú optional.
We have also found that the inheritance was mainly im-
proved in Docker-compose Ô¨Åles to remove Duplication. The
Add Extends Attribute refactoring presented in Listing 8 is
a common refactoring type for Docker-compose to addressduplication issues. This refactoring helped to solve the con-Ô¨Åguration duplication issue by using the extends attribute
(Line 12) and specifying the parent service db(from the parent
Docker-compose Ô¨Åle).
V. I
MPLICA TIONS AND DISCUSSIONS
A. Refactorings Co-Evolution
We found that several refactoring types when applied to
DockerÔ¨Åle and Docker-compose Ô¨Åles impact the source codeof the project that should be also refactored using regularrefactorings as well. This co-evolution process is currentlyperformed manually by developers and there is no semi-automate tool to support them. Thus, there are signiÔ¨Åcant
7881 diff --git a/docker-compose-jasper.yml
2 --- a/docker-compose-jasper.yml
3 +++ b/docker-compose-jasper.yml
4 @@ -1,105 +1,61 @@
5 db:
6 - image: muccg/postgres-ssl:9.4
7 - environment:
8 - - POSTGRES_USER=rdrfapp
9 - - POSTGRES_PASSWORD=rdrfapp
10 - ports:
11 - - "5432"
12 + extends:
13 + file: docker-compose-common.yml
14 + service: db
Listing 8: Commit f7d2b4d fromrdrf: Refactored Docker-
compose Ô¨Åle to remove duplicated conÔ¨Åguration.
costs that can be associated with Docker-speciÔ¨Åc refactorings
which can make developers reluctant to apply them. Thisstudy identiÔ¨Åed the most common co-evolution patterns thatwe found in multiple commits and then a semi-automated toolcan be designed to recommend code refactorings based on theapplied Docker-speciÔ¨Åc refactorings.
B. Docker-speciÔ¨Åc Refactorings and Technical Debt
We observed in Section IV that, in practice, software devel-
opers applied several refactoring types at the DockerÔ¨Åle and
Docker-compose levels. Currently, all the identiÔ¨Åed refactoringtypes are manually applied due to the lack of any semi-automated tool support. With this proposed empirical study,we described the scientiÔ¨Åc foundations required to enable theimplementation of the refactoring types identiÔ¨Åed for Docker-Ô¨Åles and Docker-compose Ô¨Åles. The same observation apply tothe technical debt categories for Docker projects. Thus, toolbuilders can use the deÔ¨Ånition and symptoms discovered inthis empirical foundation to deÔ¨Åne, validate, and implementdetection rules to automatically identify the quality issues inDockerÔ¨Åle and Docker-compose Ô¨Åles. Such tools could notonly save developers effort and time, but could also bringa discipline toward refactorings of Docker projects within asoftware development team.
Although we do not expect practitioners to Ô¨Åx all the
detected technical debts independently from the context, weexpect them to judge which quality issues in DockerÔ¨Ålesand Docker-compose Ô¨Åles are more relevant and adequate fortheir speciÔ¨Åc context. Team-leads can work with developersto establish customized guidelines from this study for dealingwith technical debts in Docker projects. These guidelines couldalso trigger developers to capture the impact and the rationaleof their Docker changes appropriately for each situation, bydeveloping beneÔ¨Åcial habits and long-lasting projects.
Our results can also provide a common ground for doc-
umenting, discussing, and assessing refactorings and theirimpact on Docker projects. This common ground will helpeducators to disseminate multiple dimensions of refactoringsin Docker projects. Further, they could encourage the practiceof refactoring continuously based on the examples and dataprovided in this empirical study.C. Optimizing Docker Performance
It is not surprising that the main rationale of refactoring
Docker projects is to optimize the usage of resources (e.g.,memory, CPU, etc.) needed to execute the containers viareducing the image size, removing duplication and reducingthe build time. Indeed, Docker projects are recently usedextensively in cyber-physical systems including automotiveindustry and smart manufacturing [25], [20]. The hardwareresources are typically limited, thus refactoring may play abigger role in optimizing the size and performance of Dockerprojects once semi-automated tools are available based on thescientiÔ¨Åc foundation of this study.
VI. T
HREA TS TO V ALIDITY
In this study, we selected 68 Docker projects to identify
refactoring types and technical debt categories but they maynot be representative to the very large number of Dockerprojects on GitHub. To address this threat, we ensured thatthe selected projects are diverse in domains, sizes and realisticin terms of the evolution history and popularity. Thus, weused various GitHub metrics including the number contributor,users, stars, commits, etc. to evaluate their popularity anddiversity. Despite Java was the dominant language on appli-cations hosting containers (selected to facilitate the manualanalysis of the regular code refactoring), around 30% of theprojects are written in C++. Indeed, the refactoring types (andtheir rationale) in object-oriented programming are almost thesame, thus the impact of our selection criteria are limited tothe generalizability of the co-evolution results between Dockerand Docker-compose refactorings, and regular code ones.
The manual identiÔ¨Åcations and classiÔ¨Åcation of refactoring
types and technical debt categories can be subjective. To miti-gate this threat, four experts evaluate all the selected commitsseparately and the agreement coefÔ¨Åcient score between allof them was high for all the identiÔ¨Åcation and classiÔ¨Åcationresults as discussed in Section III. For the few cases ofdisagreement, the different experts discussed the commit(s)after submitting their results to avoid any bias. Our studyalso involved many hours of manual inspection and analysisto understand and categorize the Docker-speciÔ¨Åc refactorings.To mitigate these threats, the four experts used the commitmessages, pull-requests descriptions and comments in the codeto better understand the context of the changes and they onlymarked the refactorings and their rationale when they are veryconÔ¨Ådent about them. For the regular code refactorings (co-evolution study), RefMiner [33] was used to conÔ¨Årm and aidthe manual inspection of the refactoring types, even though allcommits were manually inspected carefully for any potentialfalse positives.
VII. R
ELA TED WORK
A. Docker Smells
Few studies investigated quality issues in Docker projects
and they are all limited to DockerÔ¨Åle. Similar to traditionalconÔ¨Åguration code smells [29], Docker smells are indicatorsof certain designs Ô¨Çaws and weaknesses in the DockerÔ¨Åle.
789Without being actual bugs, these smells potentially affect the
image in a negative way. Although Docker‚Äôs documentationprovides a list of best practices
1to Ô¨Åx different kind of smells,
developers are still violating these recommendations. Yiwen etal. [36] divided DockerÔ¨Åle smells into two major categories:DL-smells (referring to the violation of the ofÔ¨Åcial DockerÔ¨Ålebest practices rules) and SC-smells (referring to the violationof the basic shell scripts practices). They described DockerÔ¨Ålesmells occurrence by proposing an empirical study in open-source projects and they found that nearly 84% of theseprojects have smells in their DockerÔ¨Åle code. Further, theyfound that DL-smells appear way more than SC-smells.
Some other studies focused on building automated and
semi-automated tools to help the detection of bad practices inDockerÔ¨Åle. Hadolint (Haskell DockerÔ¨Åle Linter)
2, is a smart
DockerÔ¨Åle linter that can be used to help developers to buildthe best practice into the Docker images. The linter parsesthe DockerÔ¨Åle into an AST and performs rules on top ofthe AST in order to detect DL-smells based on ShellCheck
3
to lint the Bash code inside RUN instructions for the SC-smells detection. Henkel et al. [15] proposed a tool (similarto Hadolint) named Binnacle, which performs rule miningover 178,000 DockerÔ¨Åles collected from GitHub. However,this tool mainly focused on bash related rules. Xu et al. [16]deÔ¨Åned a new type of smell named TF-smell which stands for‚ÄúTemporary Ô¨Åle smell‚Äù it indicates a careless use of temporaryÔ¨Åle in image building process that may cause temporary Ô¨Åleleft in the image, which increases the image size and affectsthe distribution.
All above-mentioned studies focus on detecting bad prac-
tice/smells on DockerÔ¨Åles. None of them worked on sug-gesting possible refactorings or the technical debt categories,including smells, for Docker-compose Ô¨Åles or the regular coderefactoring observed in Docker projects.
B. Refactoring and Design Flaws
Our work is mainly related to 1) approaches identifying
design Ô¨Çaws and recommending how to Ô¨Åx them; and 2) empir-
ical studies on refactoring. Several approaches have been pro-posed to automatically detect design Ô¨Çaws (i.e., anti-patterns,code smells, etc.). We only discuss a few representative worksand refer the interested reader to the recent survey by Sharmaand Spinellis [30] for a complete overview. Marinescu [21]proposes a metric-based mechanism to capture deviationsfrom good design principles and heuristics, called ‚Äúdetectionstrategies‚Äù. Such strategies are based on the identiÔ¨Åcation ofsymptoms characterizing a particular smell and metrics for
measuring such symptoms. Moha et al. [23] exploit a similaridea in their DECOR approach, proposing a Domain-SpeciÔ¨ÅcLanguage (DSL) for specifying smells using high-level ab-stractions. Besides metrics exploiting structural informationextracted from the code, Palomba et al. [26] provide evidence
1https://docs.docker.com/develop/develop-images/dockerÔ¨Åle_best-practices
2https://github.com/hadolint/hadolint
3https://github.com/koalaman/shellcheckthat historical data can be successfully exploited to identifycode smells.
A lot of effort has been devoted to the deÔ¨Ånition of ap-
proaches supporting refactorings. One representative exampleis JDeodorant, a tool proposed by Tsantalis and Chatzigeor-giou et al. [32] able to detect and refactor the code to Ô¨Åx fourcode smells (i.e., State Checking, Long Method, God Classes,
and Code clones). We point the interested reader to the survey
by Bavota et al. [5] for an overview of approaches supportingcode refactoring.
Empirical studies on software refactoring mainly aim to
investigate software developers‚Äô refactoring habits and the re-lationship between refactorings and code quality. Murphy-Hillet al. [24] investigated how developers perform refactorings.Examples of the exploited datasets are usage data from 41developers using the Eclipse environment and information ex-tracted from versioning systems. Among their several Ô¨Åndings,they show that developers often perform Ô¨Çoss refactoring,
namely they interleave refactorings with other programmingactivities, conÔ¨Årming that refactorings are rarely performedin isolation. Kim et al. [18] present a survey of softwarerefactoring with 328 Microsoft‚Äôs engineers to investigate whenand how they refactor code and the developers‚Äô perceptiontowards the beneÔ¨Åts, risks, and challenges of refactoring [18].They show that the major risk factor perceived by developerswith regards to refactoring is the introduction of bugs and oneof the main beneÔ¨Åts they expect is to have fewer bugs in thefuture, thus indicating the usefulness of refactoring for codecomponents exhibiting high fault-proneness.
To the best of our knowledge, this paper presents the Ô¨Årst
study on refactoring for Docker projects since most of theexisting studies focus on traditional paradigms, such as object-oriented programming. Several of the aforementioned studiescan be adopted to transfer the knowledge into this paradigm,but a Ô¨Årst step is to provide an empirical foundation to deÔ¨Ånerefactoring types for the Docker domain.
VIII. C
ONCLUSION
We proposed a study to advance the knowledge of Docker
refactorings and technical debts, which are under-exploredin the literature. We have manually investigated and deÔ¨ÅnedspeciÔ¨Åc refactoring types and technical debt categories forDocker projects. We have also studied the co-evolution be-tween applying those Docker-speciÔ¨Åc refactorings and regularrefactorings on the code of the app hosting the containers.A taxonomy of refactorings in Docker projects was proposedincluding 14 new DockerÔ¨Åle-related refactorings, 12 Docker-compose related refactorings and 7 technical debt categories.
In the future, we will use the scientiÔ¨Åc foundations of
this study to build new tools for refactorings detection andrecommendation for Docker projects.
R
EFERENCES
[1] C. Abid, V . Alizadeh, M. Kessentini, T. do Nascimento Ferreira, and
D. Dig. 30 years of software refactoring research:a systematic literature
review. IEEE Transactions on Software Engineering, 1(1), 2020.
790[2] V . Alizadeh and M. Kessentini. Reducing interactive refactoring effort
via clustering-based multi-objective search. In Proceedings of the 33rd
ACM/IEEE International Conference on Automated Software Engineer-
ing, pages 464‚Äì474, 2018.
[3] V . Alizadeh, M. Kessentini, W. Mkaouer, M. Ocinneide, A. Ouni,
and Y . Cai. An interactive and dynamic search-based approach tosoftware refactoring recommendations. IEEE Transactions on Software
Engineering, 2018.
[4] Anonymous Author(s). Study appendix, 2020. https://sites.google.com/
view/ase21-docker-refactorings.
[5] G. Bavota, A. De Lucia, A. Marcus, and R. Oliveto. Recommending
refactoring operations in large software systems. In M. P . Robillard,W. Maalej, R. J. Walker, and T. Zimmermann, editors, Recommenda-
tion Systems in Software Engineering, pages 387‚Äì419. Springer BerlinHeidelberg, 2014.
[6] N. Brown, Y . Cai, Y . Guo, R. Kazman, M. Kim, P . Kruchten, E. Lim,
A. MacCormack, R. Nord, I. Ozkaya, R. Sangwan, C. Seaman, K. Sul-livan, and N. Zazworka. Managing technical debt in software-reliantsystems. In Proceedings of the FSE/SDP Workshop on Future of
Software Engineering Research, FoSER ‚Äô10, page 47‚Äì52, New Y ork,NY , USA, 2010. Association for Computing Machinery.
[7] J. Cito, G. Schermann, J. E. Wittern, P . Leitner, S. Zumberi, and H. C.
Gall. An empirical analysis of the docker container ecosystem on github.InProceedings of the IEEE/ACM 14th International Conference on
Mining Software Repositories (MSR ‚Äô17), pages 323‚Äì333, 2017.
[8] Z. Codabux and B. Williams. Managing technical debt: An industrial
case study. In 4th International Workshop on Managing Technical Debt
(MTD 2013), 2103.
[9] B. P . Datasets, 2020. https://cloud.google.com/bigquery/public-data.
[10] Docker, 2020. https://docker.com.
[11] Docker Compose, 2020. https://github.com/docker/compose.[12] DockerHub, 2020. https://hub.docker.com.[13] M. Fowler. Refactoring: Improving the Design of Existing Programs.
Addison-Wesley Professional, 1 edition, 1999.
[14] F. Hassan, R. Rodriguez, and X. Wang. Rudsea: recommending updates
of dockerÔ¨Åles via software environment analysis. In Proceedings of
the 33rd ACM/IEEE International Conference on Automated Software
Engineering, pages 796‚Äì801, 2018.
[15] J. Henkel, C. Bird, S. K. Lahiri, and T. Reps. Learning from, under-
standing, and supporting devops artifacts for docker. In Proceedings of
the 42nd International Conference on Software Engineering (ICSE ‚Äô20),2020.
[16] iwei Xu, Y . Wu, Z. Lu, and T. Wang. DockerÔ¨Åle tf smell detection
based on dynamic and static analysis methods. In Proceedings of the
43rd IEEE Annual Computer Software and Applications Conference(COMPSAC ‚Äô19), 2019.
[17] Y . Jiang and B. Adams. Co-evolution of infrastructure and source code
- an empirical study. In Proceedings of the 12th Working Conference
on Mining Software Repositories, 2015.
[18] M. Kim, T. Zimmermann, and N. Nagappan. An empirical study of
refactoringchallenges and beneÔ¨Åts at microsoft. IEEE Transactions on
Software Engineering, 40(7):633‚Äì649, July 2014.
[19] P . S. Kochhar and D. Lo. Revisiting assert use in github projects. In
Proceedings of the 21st International Conference on Evaluation andAssessment in Software Engineering (EASE ‚Äô17) , pages 298‚Äì307, 2017.
[20] R. Lovas, A. Farkas, A. C. Marosi, S. √Åcs, J. Kov√°cs, √Å. Szal√≥ki, and
B. K√°d√°r. Orchestrated platform for cyber-physical systems. Complexity,
2018, 2018.
[21] R. Marinescu. Detection strategies: Metrics-based rules for detecting
design Ô¨Çaws. In Proceedings of the International Conference on
Software Maintenance (ICSM ‚Äô04), pages 350‚Äì359. IEEE, 2004.
[22] W. Mkaouer, M. Kessentini, A. Shaout, P . Koligheu, S. Bechikh, K. Deb,
and A. Ouni. Many-objective software remodularization using NSGA-III. ACM Transactions on Software Engineering and Methodology
(TOSEM), 24(3):17:1‚Äì17:45, 2015.
[23] N. Moha, Y .-G. Gu√©h√©neuc, L. Duchien, and A.-F. L. Meur. Decor: A
method for the speciÔ¨Åcation and detection of code and design smells.IEEE Transactions on Software Engineering, 36(1):20‚Äì36, 2010.
[24] E. Murphy-Hill, C. Parnin, and A. P . Black. How we refactor, and how
we know it. IEEE Transactions on Software Engineering, 38(1):5‚Äì18,
2011.
[25] A. D. Neal, R. G. Sharpe, P . P . Conway, and A. A. West. smaRTI-
a cyber-physical intelligent container for industry 4.0 manufacturing.
Journal of Manufacturing Systems, 52:63‚Äì75, 2019.[26] F. Palomba, G. Bavota, M. Di Penta, R. Oliveto, D. Poshyvanyk, and
A. De Lucia. Mining version histories for detecting code smells. IEEE
Transactions on Software Engineering, 41(5):462‚Äì489, 2015.
[27] Portworx. 2017 annual container adoption survey: Huge growth in con-
tainers, 2020. https://portworx.com/2017-container-adoption-survey/.
[28] N. Rachatasumrit and M. Kim. An empirical investigation into the
impact of refactoring on regression testing. In Software Maintenance
(ICSM), 2012 28th IEEE International Conference on, pages 357‚Äì366.IEEE, 2012.
[29] T. Sharma, M. Fragkoulis, and D. Spinellis. Does your conÔ¨Åguration
code smell? In Proceedings of the IEEE/ACM 13th Working Conference
on Mining Software Repositories (MSR ‚Äô16), pages 189‚Äì200. IEEE,2016.
[30] T. Sharma and D. Spinellis. A survey on software smells. Journal of
Systems and Software, 138:158 ‚Äì 173, 2018.
[31] D. Silva, N. Tsantalis, and M. T. V alente. Why we refactor? confessions
of github contributors. In Proceedings of the 2016 24th acm sigsoft
international symposium on foundations of software engineering, pages858‚Äì870, 2016.
[32] N. Tsantalis and A. Chatzigeorgiou. IdentiÔ¨Åcation of move method
refactoring opportunities. IEEE Transactions on Software Engineering,
35(3):347‚Äì367, 2009.
[33] N. Tsantalis, M. Mansouri, L. M. Eshkevari, D. Mazinanian, and D. Dig.
Accurate and efÔ¨Åcient refactoring detection in commit history. In Pro-
ceedings of the 40th International Conference on Software Engineering,ICSE ‚Äô18, pages 483‚Äì494, New Y ork, NY , USA, 2018. ACM.
[34] A. J. Viera, J. M. Garrett, et al. Understanding interobserver agreement:
the kappa statistic. Fam med, 37(5):360‚Äì363, 2005.
[35] Y . Wang, Y . Sun, Z. Lin, and J. Min. Container-based performance
isolation for multi-tenant saas applications in micro-service architecture.Journal of Physics: Conference Series, 1486(5):052032, 2020.
[36] Y . Wu, Y . Zhang, T. Wang, and H. Wang. Characterizing the occurrence
of dockerÔ¨Åle smells in open-source software: An empirical study. IEEE
Access, 2020.
[37] L. Zhang, D. Tiwari, B. Morin, B. Baudry, and M. Monperrus. Auto-
matic observability for dockerized java applications. arXiv, 248:1‚Äì14,
2019.
791