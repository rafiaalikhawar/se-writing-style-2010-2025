On the VulnerabilityProneness ofMultilingual Code
Wen Li
WashingtonStateUniversity
Pullman, WA,USA
li.wen@wsu.eduLi Li
Monash University
Melbourne,Victoria,Australia
li.li@monash.eduHaipeng Caiâˆ—
WashingtonStateUniversity
Pullman, WA, USA
haipeng.cai@wsu.edu
ABSTRACT
Software construction using multiple languages has long been a
norm,yetitisstillunclearifmultilingualcodeconstructionhassig-
nificant security implications and real security consequences. This
paperaimstoaddressthisquestionwithalarge-scalestudyofpopu-
larmulti-languageprojectsonGitHubandtheirevolutionhistories,
enabledbyournoveltechniquesformultilingualcodecharacteri-
zation.Wefoundstatisticallysignificantassociationsbetweenthe
proneness of multilingual code to vulnerabilities (in general and
of specific categories) and its language selection. We also found
this associationis correlated with that of thelanguage interfacing
mechanism, notthat of individual languages. We validated our sta-
tisticalfindingswithin-depthcasestudiesonactualvulnerabilities,
explainedviathemechanismandlanguageselection.Ourresults
callforimmediateactionstoassessanddefendagainstmultilingual
vulnerabilities, for which we providepractical recommendations.
CCSCONCEPTS
â€¢Security andprivacy â†’Software security engineering .
KEYWORDS
multi-languagesoftware,multilingualcode,softwaresecurity,cross-
languagevulnerability,languageinterfacing,regression analysis
ACM Reference Format:
Wen Li, Li Li, and Haipeng Cai. 2022. On the Vulnerability Proneness of
Multilingual Code. In Proceedingsof the 30thACM JointEuropean Software
Engineering Conference and Symposium on the Foundations of Software Engi-
neering(ESEC/FSEâ€™22),November14Å›18,2022,Singapore,Singapore. ACM,
NewYork, NY, USA, 13pages.https://doi.org/10.1145/3540250.3549173
1 INTRODUCTION
Studies have shown that software written in multiple languages
(i.e.,multi-language software) is dominant [ 21,41,50,54,77,87].
Intuitively,thisprevalencehastodowiththebenefitsofcombining
the best functional capabilities of different languages [ 3,16,56].
Yet the decisions on language selection may not fully depend on
functionalityconsiderations:Asearlierworksinitiallysuggested[ 4,
40,46],thedecisionsmaycomewithsecurity[ 35,92]consequences.
Cyber threats rooted in code vulnerabilities [ 34,63], as intro-
ducedduringtheconstructionofsoftware,havebeenontherise[ 30].
âˆ—Haipeng Caiis thecorresponding author.
ESEC/FSE â€™22, November 14Å›18,2022, Singapore, Singapore
Â©2022 Copyright heldby theowner/author(s).
ACM ISBN 978-1-4503-9413-0/22/11.
https://doi.org/10.1145/3540250.3549173Despitethedominanceofmultilingualconstructioninmodernsoft-
ware practice for years, it is still not clear whether multilingual
construction has significant security implications and real security
consequences in terms of vulnerabilities in the code . In particular,
we do not know whether certain language combinations are more
associatedwithcodepronenesstovulnerabilitiesthanothers and,ifso,
whatcontributestothegreaterorweakerassociations .Italsoremains
unknown whether the association, if exists, indicates actual vulnera-
bilities. Answers to these questions are essential for understanding
anddefendingthe holistic security of multi-language software.
Amonga number ofrelevant-looking works[ 13,16,43,56,77,
90,94], the majority addressed individual languages. Of the few
works on multi-language software, most were focused on preva-
lence [55,87] and good/bad practices of developers [ 3], or only
limitedto JNI (Java-C)programs[ 40,46,92].Grichiet al.[ 35]re-
portedlikelygreatersecurityrisksofmultilingualcodethansingle-
language ones, but still for JNI code only and based on only 10
projects. Individual languages were found to have little association
withbugproneness[ 10,77].Yetitisunclearifthesameholdsbe-
tweenvulnerability pronenessandselectionsofmultiplelanguages.
Relevantworks[ 13,21,45,54]lookedathigh-levelcompanionship
amonglanguages,butnotcode-levelinterfacingbetweenlanguages,
norwere they concernedwith security vulnerabilities.
Inthispaper,weconducta security-focusedcharacterizationstudy
ofmulti-languagesoftware ,targetingthoseintheopensourceworld
whilewithafocuson vulnerabilityproneness throughthelensof
languageselection andlanguageinterfacingmechanism . Motivated
bythe foregoingquestions,ourstudy has three specific aims :
â€¢Elucidatethesecurityrelevanceoflanguageselectioninterms
ofthequantitativeassociationbetweensuchselectionsandthe
resultingcodeâ€™s vulnerability proneness;
â€¢Explain/justify the relevance via such proneness of individual
languages andlanguageinterfacingmechanisms;
â€¢Validate/concretize statistical findings about the vulnerability
proneness byconnectingitto actualvulnerabilities.
To that end, we (1) developed a new taxonomy and two novel tools
formultilingualcodeanalysis,hence(2)conductedextensivestatis-
ticalanalyses of4,001 popularmulti-language projects on GitHub
and 20.37 million commits in their 3-year evolution history, and (3)
manuallyinspected50projectsand500commitsforeach,bothran-
domly sampled. With these facilities, we answered three questions
(justifiedbythe specific aims) with key findings as follows:
â€¢RQ1: How is language selection related to the vulnerabil-
itypronenessofmultilingualcodethatusesthelanguages?
Wefoundthatlanguageselectionwasoverallstronglyassociated
with the proneness and the association was even stronger for
specificcategoriesofvulnerabilities.Somelanguageselections
(e.g.,c++ python ) were much more prone to vulnerabilities overall
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
847
ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore WenLi, LiLi, andHaipeng Cai
thanothers(e.g., c c++ python ),andthesameselection(e.g., c shell)
canbemuchmorepronetoonevulnerabilitycategory(e.g., risky
resourcemanagement )thantoothers(e.g., insecureinteraction ).
The mostprone selections were c c++ shell andc python.
â€¢RQ2 What are the underlying factors contributing to the
strongerorweakervulnerabilitypronenessofalanguage
selection than others? We identified and examined two intu-
itive contributors: the individual languages selected, and the
mechanisms of interfacingacross languages. We found that the
interfacing mechanisms, especially those via code-level function
calls (either explicitly or implicitly), were overall strongly associ-
atedwiththemultilingualcodeâ€™spronenesstobothvulnerabili-
tiesingeneralandtoparticularvulnerabilitycategories.Some
mechanisms(e.g., foreign function invocation )were clearlymore
prone than others (e.g., embodiment ), and the most prone mech-
anism was implicit invocation . We found overall even stronger
associationof individual languages among the studiedselections
with such proneness. The most prone were javaandc. However,
the proneness of language selections was correlated with that of
themechanism ofinterfacingacross theselected languages, not
with the proneness of the individual languages in the selections.
â€¢RQ3Doesthevulnerabilitypronenessofmultilingualcode
indicate actual vulnerabilities in the code? The statistical
proneness was validated and concretized in sizable random man-
ual sampling to strongly indicate actual vulnerabilities. Exten-
sivein-depthcasestudiesfurther demonstratedthepresence of
various kinds ofreal-world vulnerabilities in thesampled multi-
lingual code. All of the vulnerabilities were explainable by the
underlying languageselection andinterfacingmechanism.
Importantly,wedefine/quantify the pronenessofmultilingual code
as#likelyvulnerability-fixingcommitsinthecodeâ€™sversionhistory.
Then,wedefinethe pronenessofanindividuallanguage,alanguage
selection,oraninterfacingmechanism astheirstatisticalassociation
with the proneness of the underlying codeÃand quantify these
pronenessmetricsviatheassociationsignificance/coefficients.This
paper only addresses such associations, notcausalityÃwe never
intend to claim multilingual code vulnerabilities are "caused by or
dueto"theindividuallanguages,theholisticlanguageselections,
orthe languageinterfacingmechanismsusedinthe code.
Contributionsandsignificance. Ournovelempiricalresultspro-
videnotonlytheoverallstrongstatisticalgroundsforthevulnerabil-
itypronenessofmultilingualcode,butalsoofferextensiveevidence
onconnectionsbetweenthepronenessandactualvulnerabilities.
Basedonthesefindings,weprovided practicalrecommendations
to researchers, developers, and tool builders, which facilitate un-
derstanding, analyzing, and defending against vulnerabilities in
multilingualcode.Wealsocontributeanautomatedvulnerability
classifierofcommitsmoreaccuratethanstate-of-the-artpeertools,
thefirstautomatedlanguageinterfacingmechanismdetectorbased
onthefirsttaxonomyofsuchmechanisms,andareal-worldvulner-
abilitydatasetofagreatersize,accuracy,anddiversity(covering
more projects) than peer datasets. These newtoolsanddataset
immediately support the practical adoption ofour suggestions.
Data-availability statement. Source code and datasets are all
availableinour artifact[48]andhavebeenmadepubliclyaccessible.
Vulnerability  
Categorization (VC)
Language Interfacing 
Classification (LIC) Negative Binomial 
Regression (NBR)
In-Depth Case 
Studies (ICS)VC resultsGitHub 
repositories Repository 
MiningTechniques for study Chosen repository list
Commits 
LIC results
ICS results
RQ1
RQ2
RQ3Figure 1:Overview ofour studyprocess.
2 METHODOLOGY
2.1 StudyOverview
Figure1illustrates the overall process flow of our study. As its
primary input, the process takes the repositories of open-source
projectsonGitHub[ 1].Fromthissource,weminedrepositorymeta-
data hence selected multilingual projects that met a few criteria,
andthen retrievedcommit information for eachproject.
Based on this dataset, we performed three main analyses: vul-
nerabilitycategorization(VC),languageinterfacingclassification
(LIC),andin-depthcasestudies(ICS).VCidentifiesandcategorizes
security vulnerabilities based on commits; further, with the VC
results,anegativebinomialregression(NBR)analysis[ 7]examines
the relationships between vulnerability proneness and language
selectiontoanswer RQ1.Then,LICanalyzeseachprojectâ€™scodeto
recognizeandclassifyitslanguageinterfacingmechanism.Wealso
applied NBR over the same set of projects as for RQ1 to discover
theassociationofthosemechanismsandindividuallanguageswith
the project vulnerability proneness to answer RQ2. Finally, we
randomlysampledasubsetoftheprojectstoexaminetheirvulnera-
bility specifics through extensive manual inspections, concretizing
thestatisticalfindingsobtainedfromRQ1andRQ2,toanswer RQ3.
2.2 RepositoryMining
We mined repositories using the GitHub API [ 2] while applying
fourfilters(selection criteria) as summarizedandjustifiedbelow:
â€¢The repository has 1,000 or more starsÃa popularity indicator
andthresholdusedinpeerpriorstudies[ 15,22,68,77,80];these
projects gained more attention, thus the (multi-language) soft-
warepracticeembodiedinthempotentiallyhasgreaterinfluence.
â€¢Therepositoryhasbeenupdatedinthelatest6monthsÃareason-
ableindicatorofactiveness;moreactiveprojectsismorelikely
to be representative of ongoingpractices.
â€¢Therepositoryhasbeeninmaintenanceforatleastthreeyears
until 2020 orlaterÃa reasonablylongversion history for identi-
fyingvulnerabilitypronenessbasedoncommits.
â€¢The language selection did not change during the studied evolu-
tion period (i.e., three years)Ãessential for validly analyzing the
effectsoflanguageselection onvulnerabilityproneness.
Withthese filters,ourdata samplingworkedintwosteps.First,we
sampledprojectsthatsatisfythefirsttwocriteriauntilweobtained
10,000 satisfying projectsÃthis number represents a reasonably
largescale.Second,wefilteredthese10,000projectsusingtheother
twocriteriawhiledismissing single-language projects.
Specifically, for the second step, we ensured to only include
unique projectsÃnoproject is afork of another in the dataset. We
alsoignoredthosethatarenotactualsoftwaredevelopmentprojects
848On the VulnerabilityPronenessof Multilingual Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
(e.g., course projects, teaching/tutorial code)Ãmany on GitHub
arenot[42].Foreachproject,weretrievedthelanguageURLfor
its repository, with which the GitHub API enables us to query
thedetailedlanguageinformation,includingthesetoflanguages
selected (referred to as language combination orlanguage selection ),
oftheproject.Languageswith<1%oftotalcodesizewereremoved
from each projectâ€™s language selection, and then projects using <2
languagesleft were dismissed.
The above two steps resulted in 4,001 multi-language projects
which were eventually used in our study; these projects cover a
varietyoflanguageselectionsunevenlydistributed(e.g., css,html,
javascript :10.4%,c,c++,shell:4.8%,c,python:2.3%).Wethenretrieved
all the commits of each chosen project in its 3-year version history,
resultingin20.37 million commits intotal.
2.3 Vulnerability Categorization (VC)
To examinethesecurity relevanceof language selection (asaway
to justify such selections), we needed to know, for each project,
the overall vulnerability proneness and the proneness with respect
to particular vulnerability categories. To that end, we developed
anewtoolthatidentifiesandcategorizesvulnerabilitiesbasedon
commits, andapplieditto eachprojectinour sample set.
In a well-known list compiled by MITRE and the SANS Insti-
tute, the top 25 most dangerous CWEs [ 57] are categorized into
threehigh-levelcategories[ 53]:Porousdefenses (11CWEs), Risky
resource management (8 CWEs), and Insecureinteraction (6 CWEs).
For each category, we applied common text pre-processing [ 38]
(e.g., tokenize, lemmatize, remove stop words) to the description of
eachCWE in thecategory to extract security-related keywords or
phrases.Forinstance,weextractedthephraseÅ‚integeroverflow"
for CWE-190 in Risky resourcemanagement . Table1lists suchkey-
words/phrasespercategory.Wethenappliedthesameprocessto
changedcodeineachcommitasanaturallanguagetokensequence.
Next, we used the FuzzyWuzzy technique [ 17] to match the
keywords/phrases that characterize each of the three vulnerability
categoriesagainstthetokensinacommitincludingitslog(i.e.,com-
mitmessage)andcode.Comparedtootherpopularapproaches(e.g.,
direct keyword searching, regex matching), FuzzyWuzzy does not
requireexactstringmatchingbutreportsthesimilaritybetweenthe
patternsandinputstrings;henceitstrikesabetterbalancebetween
precision andrecall. For instance,inourpreliminary experiments,
direct keyword searching caused too many false negatives, due
to exact string matching with respect to diverse/irregular word-
ing/stylesofcommitmessages(betweenvulnerability-relevantand
irrelevant ones); Regex matching was relatively more effective, but
notusinganywildcardsdegeneratedittodirectkeywordsearching,
whileextensivelyusingwildcardscausedtoomanyfalsepositives.
As shown in Algorithm 1, we first retrieve these categories (line
2)andapplythesametextpre-processingtothegivencommit(line
3), followed by computing a match score between each category
and the commit (lines 5Å›21). For each category, we retrieve (line
7) and traverse its keywords/phrases (lines 8Å›20). Next, for each
phrase/keyword of length ğ‘›, the pre-processed commit text is split
intoğ‘›-grams (lines 9Å›17), which are matched against the phrase
with FuzzyWuzzy (line 18). For better precision, we use a minimal
score of 90 as threshold (lines 6) and take the highest score overall
all phrases of a category (lines 19Å›20) as the score against thatAlgorithm1: Identifying and Clasifying a vulnerability-fixing commit
Input:ğ¶ğ‘šğ‘šğ‘¡:a commit includingitslogandcodesnippet
Output:ğ‘£ğ¶ğ‘ğ‘¡:thevulnerability category of ğ¶ğ‘šğ‘šğ‘¡
1Function classifyCommit (ğ¶ğ‘šğ‘šğ‘¡)
2ğ‘‰ğ¶â†initVulCategory () /* Categories with keywords/phrases */
3ğ¶ğ‘šğ‘šğ‘¡â†preprocessText (ğ¶ğ‘šğ‘šğ‘¡)/* Tokenize, stemmatize, etc. */
4ğ¶ğ‘ğ‘¡ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’â†ğœ™
5foreachğ¶ğ‘ğ‘¡inğ‘‰ğ¶do
6 ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’â†90 /* The minimum match score as the threshold */
7 ğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’ğ¿ğ‘–ğ‘ ğ‘¡â†ğ¶ğ‘ğ‘¡.phrases /* Keywords/phrases of category ğ¶ğ‘ğ‘¡*/
8 foreachğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’inğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’ğ¿ğ‘–ğ‘ ğ‘¡ do
9 ğ‘ğ‘â†getWordNum (ğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’)/* 1 ifğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’ is a keyword */
10 ğ‘ğ‘â†getWordNum (ğ¶ğ‘šğ‘šğ‘¡) /* Number of tokens */
11 ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘’ğ‘¡â†ğœ™/* The set of n-grams in ğ¶ğ‘šğ‘šğ‘¡;ğ‘›=ğ‘ğ‘*/
12 ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥â†0
13 whileğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥<ğ‘ğ‘do
14 ğ¸ğ‘›ğ‘‘â†ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥+ğ‘ğ‘ /* Split ğ¶ğ‘šğ‘šinto n-grams */
15 ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘¡ğ‘Ÿâ†ğ¶ğ‘šğ‘šğ‘¡[ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥:ğ¸ğ‘›ğ‘‘]
16 ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘’ğ‘¡ .append(ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘¡ğ‘Ÿ )
17 ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥++
/* Match ğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’ againstğ¶ğ‘šğ‘šâ€™s n-grams with FuzzyWuzzy */
18 ğ‘…ğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡=FuzzyWuzzy. extractOne (ğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’,ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘’ğ‘¡ )
19 ifğ‘…ğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡.ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ >ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’then
20 ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’â†ğ‘…ğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡.ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’
21 ğ¶ğ‘ğ‘¡ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’ [ğ¶ğ‘ğ‘¡]=ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’/* Keep the best match score with ğ¶ğ‘ğ‘¡*/
22ğ‘£ğ¶ğ‘ğ‘¡â†maxScoreCat (ğ¶ğ‘ğ‘¡ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’ )/* Take the best-matched category */
23 returnğ‘£ğ¶ğ‘ğ‘¡
category (line 21). The best matched category is finally returned as
the vulnerabilitycategory of the commit (lines22Å›23).
Anycommitwasidentifiedasavulnerability-fixingcommitif
itwascategorizedintooneofthethreecategorieswithscore>90.
Thekey assumptionhere isthatifa commitincludes phrases/key-
words relevant to a category, in its log or code, then the commit
represents an attempt to fixthe corresponding type of vulnera-
bilities.Given thataccuratevulnerability detection/categorization
remains an open challenge, we used this approximate, yet effi-
cient and language-agnostic approach under this assumption, in
thesamespiritaspriorwork[ 77]identifyingbug-fixingcommits
basedonsinglekeywordsearchbutincommitlogsonly.Eventu-
allyout ofthetotalof 20.37 million commits, we detected 141.38K
as vulnerability-fixing, of which 36%, 48%, 16% fall in the three
categories,respectively,as showninTable 1.
To evaluate our approach, we randomly sampled 50 projects
and500commitsforeach,andmeasuredtheprecisionandrecall
based on manual ground truth. The results are listed in the last
two columns of Table 1. In producing the ground truth, the au-
thorsindependentlylabeledthesampledcommits,by(1)reading
the commit log, (2) checking the associated code snippet, and (3)
checkingtheissuecommentswheneveravailable.Then,theycross-
validatedandacceptedthelabel for eachcommit when allagreed.
Forcaseswithinitialdisagreement,dedicateddiscussionswereheld
toreachfinaldecisions.Itisworthnotingthateachground-truth
vulnerability-fixing commit corresponds to an actual/confirmed
vulnerability rather than justkeyword/phrase matches.While not
complicated, our technique achieved a quite competitive level of
accuracycomparedtothestate-of-the-artpeertoolsÃe.g.,D2A[ 95]
which only reported 53% accuracy (based on a small manual study
ofonly57commitsintotal)andVCCFinder[ 71]whichwaseven
less accurate. We cannot make strong claims here though since we
did not compare thesetools on thesame datasetÃit is not immedi-
ately feasible to compare them against our tool on multi-language
projectsastheybothtargetC/C++projects.Meanwhile,ourtool
Liceislanguage-independent hence more widely applicable.
849ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore WenLi, LiLi, andHaipeng Cai
Table1:Characteristicsandourvulnerabilitycategorizationprecision( Prec)andrecall( Rec)ofthe20.37millioncommits( Cts)
Category SecurityVulnerability Description Search Keywords/Phrases %CtsPrecRec
Porous
defensesthesearethevulnerabilitiesthatarerelatedtode-
fensivetechniquesthatareoftenmisused,abused,
orjustplainignored.missing authentication, missing authorization, hard coded credential, missing
encryption,unnecessary privilege,user-controlled key,authorizationbypass,
brokencryptographic, excessive authentication,privilege escalation, etc.36%79%81%
Riskyresource
managementthe creation, usage, transfer, or destruction of im-
portant system resources is not properly managed.deadlock,datarace,dataleak,bufferoverflow,stackoverflow,memoryleak,
exposed danger, integer overflow, memory corruption, untrusted control, etc.48%83%86%
Insecure
interactiondata is sent and received between separate com-
ponents,modules, programs,processes, threads, or
systemsininsecure ways.sqlinjection,commandinjection,requestforgery,reflectedxss,unrestrictedup-
load, CSRF, unintended proxy, unintended intermediary, incomplete blacklist,
originvalidationerror,etc.16%81%88%
2.4 Language InterfacingClassification (LIC)
To gain an in-depth understanding of the security relevance of
languageselection,wehadtodeterminethelanguageinterfacing
mechanismofeachproject.Wethusdevelopedataxonomyofsuch
mechanismsthroughextensivemanualsearchviacodeandrelevant
documentation reviews. As per this taxonomy, we then developed
anewtoolfor automatedinterfacingclassification.
2.4.1 Taxonomy. In our taxonomy,we definefourmechanisms:
Foreign function invocation(FFI) A primary way of interfac-
ingbetweenmainstreamprogramminglanguageisFFI[ 46,86],
withwhichthehostlanguageprovidesaforeignfunctioninterface
to match its semantics and calling conventions with those of the
guest language. For instance, Java (the host) provides Java Native
Interface (JNI) to support interaction with native code written
in C (the guest). Two prominent features of FFI are that (1) the
language interfacing follows standard definitions as documented
(e.g., JNI [ 66], Python extension [ 74]) and (2) the interactions are
implementedwith explicitfunctioninvocations.
Implicitinvocation(IMI) We define IMI as a mechanism with
whichdifferentlanguagecomponentsinteractimplicitlyviainter-
processcommunication(IPC)Ãforinstance,socket-basedmessage
passing. This is often seen in multi-language distributed systems.
Embodiment (EBD) The involved languages do not interact by
explicit/implicitinvocationsbutviaoneembodyingtheotherÃthe
actualinteractionoftenoccurswithintheunderlyingruntimesys-
tem(e.g.,awebbrowserengine)thatexecutesthemulti-language
program. Typically, these languagesare interdependent on each
other and even co-exist. For instance, interfacing in the language
selection { css,html,javascript } isviaEBD as seen inWebapps.
Hidden interaction(HIT) In a selection with this mechanism,
there are no any code-level evidence of connection, even implicit
ones, between the languages. The interaction is often realized
through external data sharing. For instance, a Python component
downloads Webdata as inputsofan analyzerwritten inC.
2.4.2 Classification Technique. For our study, we developeda lan-
guageinterfacingclassification engine ( Lice), as describedbelow.
AsshowninFigure 2,Licetakesaprojectrepositoryasitsinput
anditoutputsthemechanismlabelsfortheproject.Itworksasa
chainofclassifiersets,whereeachsetfocusesononeofthefour
mechanisms and each classifier focuses on a unique pair of lan-
guages.Underlyingeachclassifier Cisacustomfinitestatemachine
(cFSM),asillustratedfor C-Python inthefigureanddefinedbelow:
C=(ğ‘ 0,F,ğ›¿,S,R,Î¦),ğ‘ 0âˆˆS,FâŠ‚S, ğ›¿: SÃ—Râ†’S, ğ›¿âˆ—: SÃ—Râˆ—â†’S
whereğ‘ 0istheinitialstate; Fisthefinalstateset; Sisthestateset; R
istheinputset:asetofpatternseachrepresentedbyaregex; ğ›¿isthe
state-transition function and Î¦is a regex engine. Given a sequenceFFI classifier set
IMI classifier set
EBD classifier set
HIT classifier setC_Python
classifierÄ‚Ä‚
classifierRuby_Java
classifier
S0S1
Fin
S2Import.*ctypes
#include <Python.h>ctypes.CDLL
Py_Initialize.*Ä‚Ä‚
Ä‚Ä‚
Ä‚Ä‚Mechanism 
labelsProject 
repository
LICEinitial 
state
Figure2:The proposedinterfacingclassificationtechnique.
of inputsI={ğ¼0,ğ¼1,...,ğ¼ğ‘›},Liceapplies the engine to obtain a set
of matched patterns R=Î¦(I). Iffğ›¿âˆ—(ğ‘ 0,R)âˆˆF,Iis accepted by
Cand the resulting label is that of the mechanism focused on by
the classifier set that includes C; otherwise, Licemoves to the next
classifier setÃthelast (HIT)setmustaccept I.
First,we manually built eachclassifier in Lice. We started with
the top 12 languages in the top language selections found in our
study(resultsforRQ1).Then,foreachofthe ğ¶2
12=66languagepairs,
we summarized the code (e.g., relevant functioncall) patterns of in-
terfacingbetweenthetwolanguageseachasaregexbyextensively
inspecting related real-world programs and official documentation
(e.g., that on JNI). Next, we crafted the cFSM from the resulting
regexsandtheirrelationshipsÃgiventhediversityofspecificuse
casesofinterfacingbetweenthetwolanguages,usuallymultiple
patterns need to be observed in particular sequences to accurately
recognizeamechanism,whichjustifiesouruseofautomatonfor
classification.Intheend,wefound20ofthe66pairsusedFFIhence
created20 classifiers for the FFIset.
Similarly, for the IMI classifier set, we created 7 classifiers by
inspecting relevant artifacts (e.g., D-bus [ 70], gRPC [36]). From our
top language selections, we only found one javascript, css, html
usingEBD;thuswecreatedoneclassifierfortheEBDset.Finally,
theHITset also includes oneclassifierwhich trivially acceptsany
inputandlabelsitasÅ‚HIT".Followingourprocedure, Licecanbe
easily extended to include additional classifiers. Further details on
the current29 classifiers can be foundinour artifact package .
When applying it to a project, Liceproduces the mechanism
label(s) by analyzing the source files as I, according to Algorithm 2.
After compiling regexs in all the available classifiers (lines 2Å›4),
Licefinds matched patterns R=Î¦(I)(line 6) in each file (line
5) and picks relevant classifiers (line 7). If a classifier accepts all
the matched patterns (regexs), the corresponding mechanism is
recognized (line 8Å›10). To determine the acceptance, Liceruns the
nFSM as a non-deterministic finite automaton against those regexs
(lines 15Å›27). Importantly, it maintains a matching context (via the
state queue ğ‘†ğ‘„) to obtain allpossiblyacceptedregex sequences.
850On the VulnerabilityPronenessof Multilingual Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Algorithm2: Classifyingaprojectbylanguageinterfacingmechanisms
Input:ğ‘ƒ:a multi-language project repository
Output:ğ¿ğ‘ƒ:theset ofinterfacingmechanism labels for ğ‘ƒ
1Function classifyProject (ğ‘ƒ)
2ğ´ğ¶â†getClassifiers ()/* Convene all the classifiers in L ICE*/
3ğ‘…â†compileRegex (ğ´ğ¶) /* Compile all regexs in ğ´ğ¶*/
4ğ‘…ğ¶â†createMap (ğ´ğ¶)/* Create a map from regexs to classifiers */
5foreachğ‘“ğ‘–ğ‘™ğ‘’inğ‘ƒdo
6 ğ‘…ğ‘€â†scanRegex (ğ‘…,ğ‘“ğ‘–ğ‘™ğ‘’) /* Obtain matched regexs */
7 ğ‘ƒğ¶â†pickClassifier (ğ‘…ğ¶,ğ‘…ğ‘€)/* Fetch relevant classifiers */
8 foreachğ¶inğ‘ƒğ¶do
9 ifclassifyMatch (ğ¶,ğ‘…ğ‘€)then
10 ğ¿ğ‘ƒ.insert (ğ¶.ğ‘™ğ‘ğ‘ğ‘’ğ‘™) /* One mechanism recognized */
11 ifğ¿ğ‘ƒ==âˆ…then
12 ğ¿ğ‘ƒ.insert ("HIT") /* Not FFI, IMI, or EBD, so defaulted to HIT */
13 returnğ¿ğ‘ƒ
14Function classifyMatch (ğ¶,ğ‘…ğ‘€)
15ğ‘†ğ‘„â†initStateQueue (ğ¶)/* Initialize with the initial state of ğ¶*/
16 foreachğ‘Ÿğ‘šinğ‘…ğ‘€do
17 ğ‘ğ‘™ğ‘’ğ‘›â†ğ‘†ğ‘„.length
18 forğ‘˜â†0toğ‘ğ‘™ğ‘’ğ‘›âˆ’1do
19 ğ‘†â†ğ‘†ğ‘„[ğ‘˜]
20 ğ‘ğ‘†â†nextState (ğ‘†,ğ‘Ÿğ‘š)/* State transition on input ğ‘Ÿğ‘š*/
21 ifğ‘ğ‘†==ğ‘ğ‘ˆğ¿ğ¿then
22 continue
23 ifisFinalState (ğ¶,ğ‘ğ‘†)then
24 returnTRUE /* Reached a final state */
25 else
26 ğ‘†ğ‘„.push (ğ‘ğ‘†)/* Save context for a matched pattern */
27 returnFALSE
Table 2:Evaluationresults for Lice
Category %Projects Precision Recall
FFI 35.67% 85% 89%
IMI 78.91% 78% 82%
EBD 32.18% 96% 90%
HIT 5.36% 81% 84%
Average 85% 82%
Asshown, Licemayreturnahybridmechanism.Forinstance,
givenarepositorywithlanguageselection{ java,c,python},Licewill
classify it as { FFI,IMI}: Java interfaces with C through JNI while C
interactswithPythonthroughD-bus.Followingasimilarprocedure
to that for evaluating our vulnerability categorization technique,
we evaluated Liceagainst 150 randomly sampled projects with
manual ground truth. The results are summarizedinTable 2.
2.5 Statistical Methods
We useNBRto model the number of vulnerability-fixingcommits
(as aresponse) against a set of factors (as predictors ) related to
multi-languagesoftwareprojectstostudytherelationshipbetween
vulnerability proneness and several indicator factors (e.g, language
selection),asinspiredbypeerwork[ 77].Wechose NBRasitcan
process data with over-dispersion [7,77], a property of our datasets.
In this regression analysis for RQ1, each ( language selection ,
project)pairisconsideredasamplefromthepopulationofmulti-
languagesoftware.Anyoftheprojectpredictorsislikelytoinflu-
ence the response. We consider the following predictors each as an
independent(control)variableofthemodel:projectage(#dayssince
creation), language selection size (#languages selected), and the
languageselectionitself.Wemainlyfocusonlanguageselections
as the indicator variables inour analysisto answer RQ1.
Asthefactorsinourstudyareunbalanced(thenumberofprojects
ofdifferentlanguageselectionsvariesinourdatasets),weemployed
weighted effects coding [ 76]. With this method, each regression
coefficient indicates the relative effect of the use of a particular
languageselectionontheresponseascomparedtotheweighted
mean of the dependent variable across all samples. Like in [ 77],Table 3: Distribution of the studied (4,001) projects over the
top-20language selections by %selecting projects
LanguageSelection %SelectingProjects
css html javascript 10.4%
c c++ shell 4.8%
python shell 3.6%
html python 2.7%
html ruby 2.4%
css html javascript python 2.3%
javascript python 2.2%
css html javascript shell 1.9%
javascript shell 1.9%
c shell 1.9%
java javascript 1.8%
html java 1.8%
c python 1.6%
c++ python 1.6%
objective-c ruby 1.5%
go shell 1.5%
c c++ python 1.5%
javascript php 1.4%
c c++ python shell 1.4%
java shell 1.4%
Table 4: NBRcoefficients on the vulnerability proneness of
language selections. AIC=42150, BIC=42383.08, Log Likelihood=-21038,
Deviance=8313.3;marks:***p<0.001, **p<0.01, *p<0.05
Independent factors Coeff. Std.Error
(Intercept) 1.4672 0.051 ***
projectage 0.0001 0.001 ***
languageselection size 0.0483 0.004 ***
css html javascript -0.0841 0.073
python shell 0.2818 0.069 ***
go shell 0.3234 0.077 ***
c c++ python shell -0.1922 0.201
javascript python -0.0925 0.113
css html javascript shell 0.1522 0.092 *
c c++ python -0.0300 0.162
objective-c ruby -0.2838 0.120 *
html python -0.4557 0.109 *
css html javascript python -0.0666 0.101
c++ python 0.4613 0.144 **
html ruby -0.1324 0.121
c python 0.6253 0.222 ***
c c++ shell 0.7641 0.098 ***
java shell 0.2766 0.096 **
javascript shell -0.2041 0.084
javascript php 0.1061 0.088 **
html java -0.1493 0.064
java javascript 0.2197 0.093 *
c shell 0.3019 0.125 *
weusedaChi-Square[ 18]testtocheckthedependencebetween
two factor variables; in a case of dependence, we used an r Ã—c
equivalentofthe phicoefficient to compute the effectsize [ 19].
We did the same analysis for RQ2, but changing the indicator
variables to interfacingmechanismsandindividuallanguages.
3 RESULTS
In this section, we present anddiscuss main results andfindings.
3.1RQ1:LanguageSelectionâ€™sSecurityRelevance
We studied two aspects of the security relevance of language selec-
tion:(1)differentialvulnerability pronenessoflanguage selections Ã
whether some language selections are more vulnerability-prone
than others, and (2) topic traits of security relevance Ãthe traits of
security topics in the underlying commit data that contribute to
(andthushelpinterpret)theeffectsoflanguageselectionsonmulti-
languagesoftwaresecurity.Forbrevity,weelaboratetheresultsfor
the top (most frequent) 20 language selections in our dataset, as
listed in Table 3. As we found in preliminary experiments, examin-
ing moreorevenall selectionsdid not changeour conclusions .
851ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore WenLi, LiLi, andHaipeng Cai
3.1.1 DifferentialVulnerabilityPronenessofLanguageSelections.
Toquantifytheoverallrelationshipbetweenlanguageselectionand
the proneness, we used a NBRmodel in which language selections
are encoded with weighted effects as predictors and the number of
vulnerability-fixingcommitsasaresponse(i.e.,dependentvariable).
Details ofthis modelare summarizedinTable 4.
Thefirsttwoindependentfactors( projectsize ,languageselection
size) are controlvariables.Ourstudyis not focusedon theimpact
of these factors, albeit all the impact issignificant as expected. All
of the other independent factorsÃthe language selection variables
(e.g.,html ruby)Ãare indicator variables.
Thecoefficientsherecompareeachlanguageselection(perproject)
tothegrandweightedmeanoflanguageselectionsinallprojects.
Each coefficient falls in one of three categories: (1) statistically
insignificantaccordingtothe ğ‘values(>0.05),(2)significantand
positive,and(3)significantandnegative.Apositivecoefficientindi-
catesthecorrespondinglanguageselection(e.g., c c++ shell ,css html
javascript shell )isassociated with more commitsintended for fix-
ingsecurityvulnerabilities,henceismorevulnerabilityprone,than
anaveragelanguage selection. Likewise, a negative coefficient indi-
cates a language selection(e.g., html python ,objective-c ruby ) isless
vulnerability prone than the average caseÃin other words, these
selections are less likely to result invulnerability-fixingcommits.
Table5:NBRcoefficientsonthepronenessoflanguageselec-
tionstoeachofthethreehigh-levelvulnerabilitycategories.
marks:***p<0.001, **p<0.01, *p<0.05
Independent factorsPorous defense Riskyresource mgmt. Insecureinteraction
Coeff.Std.Err. Coeff.Std.Err. Coeff.Std.Err.
(Intercept) -2.1670.157 *** 0.47460.070 *** -2.70660.149 ***
projectage 0.00010.001 * 0.00020.009 ** 0.00870.013
languageselection size 0.08110.010 *** 0.06240.005 *** 0.07670.010 ***
css html javascript -0.32340.218 -0.17410.105 * 0.30420.195 *
python shell 0.55270.212 ** 0.36270.093 *** 0.31590.189
go shell 0.48950.221 * 1.07640.099 *** -0.55750.264 *
c c++ python shell -0.70870.641 -0.60200.249 * -2.17990.180
javascript python 0.74640.339 * -0.88050.161 *** 1.80170.333 ***
css html javascript shell 0.82160.281 ** 0.11360.132 1.23340.301 ***
c c++ python -0.24420.509 0.09270.202 1.88190.295
objective-c ruby -0.26300.424 0.08550.170 -1.48540.626 *
html python 0.07350.315 -1.07420.163 *** 0.54490.287
css html javascript python 0.90980.306 * 0.23710.144 -1.64340.308 *
c++ python -0.10560.468 1.43840.181 *** -0.88600.583
html ruby -0.45250.357 * -0.69380.188 *** 1.67670.289 ***
c python -0.99070.714 1.29940.279 *** -1.74800.253
c c++ shell -0.30650.315 1.55370.123 *** -1.88350.443 ***
java shell -0.31450.316 0.77440.124 *** -1.00870.367 **
javascript shell -0.41940.264 -0.27210.120 * -1.57330.294 ***
javascript php 0.76950.226 *** -0.78150.125 *** 1.95090.200 ***
html java -0.14060.190 -0.26710.091 ** 0.45980.181 *
java javascript 0.65950.254 ** 0.19130.125 0.63860.237 **
c shell -0.41420.405 1.30670.156 *** -0.25940.371
AIC 25342 26358 13278
BIC 25575.03 26591.08 13511.08
Log Likelihood -12634 -13142 -6602
Deviance 7962.3 7679.5 4327.3
In essence, the coefficient of the languageselection variablecan
beunderstoodastheexpectedchangeinthelogorithmofdepen-
dent variable (i.e., #vulnerability-fixing commits) with the other
independent variables considered constant. If we define a base fac-
tor (the average of expected changes across all language selections
here)asğœ…,foragivencoefficientofone languageselection ğ›¾,then
wecanpredicttheresponseas: N=ğœ…Ã—ğ‘’ğ›½.Forexample,ifaproject
with an average language selection had five vulnerability-fixing
commits,amongsometotalnumberof(anykindof)commits,then
thenumber of vulnerability-fixingcommits wouldbe expected as
5Ã—ğ‘’0.7641=10.74in the case of using c c++ shell , much greaterthantheaverageoffive.Similarly,selecting html python wouldmean
fewer (5Ã—ğ‘’âˆ’0.4557=3.17) vulnerability-fixingcommits.
Vulnerability proneness of the studied projects were strongly associ-
ated withlanguage selections overall.Some selections were clearly
moreprone thanothers; c c++ shell andc pythonwere most prone.
3.1.2 TopicTraitsofSecurityRelevance. Togainadeeperunder-
stand of this relevance, we examined how language selection is
associatedwithspecificcategoriesofvulnerabilitiesintermsofthe
topic traits of the underlying commit data (logs and changed code).
To that end, we built a separate NBRmodel for each of the three
categories(Table 1).Eachmodelisthesameastheonefortheover-
allrelationshipexceptthattheresponse(dependentvariable)isthe
numberof vulnerability-fixing commitsbelonging to the particular
category.Table 5liststhe details of the three models.
Thedevianceforeachper-category NBRmodelissmallerthan
the deviance for overall vulnerability proneness in Table 4, indicat-
ing that language selection had a greater impact on the proneness
to specific vulnerability categories than its overall impact on the
pronenesstoanykindofvulnerabilities.Forexample,thecoefficient
ofcss html javascript was not significant per Table 4. In contrast, it
wassignificant intwoper-category models here.
Porous defenses. Vulnerabilities of this category are due to the
misuseorlackofuseofnecessarysecuritydefensetechniques(e.g.,
missing authentication for critical function ,use of hard-coded cre-
dentials,missing encryption of sensitive data ). Our results suggest a
strongassociationbetweenlanguageselectionandthesevulnerabil-
ities, similar to the overall association (Table 4). Certain selections
wereparticularlystronglyassociatedwithporousdefensevulner-
abilities. The most noticeable is css html javascript python for its
greatestpositivecoefficient0.9098(andhighestlevelofsignificance
strengthtoo).Notethat css html javascript haslittle(and insignifi-
cant) impact onthesevulnerabilities, though. This contrastpoints
totheclearsecurityinfluenceof pythonwheninteractingwiththose
three Web languages. In particular, using just javascript andpython
hadasimilarproneness(coefficient0.7464);thus,thesetwomaybe
mostresponsibleforthe(greatest)vulnerabilitypronenessof css
html javascript python .Ontheotherhand,someselections(e.g., html
ruby) had strong but negativeimpacts (e.g., coefficient -0.4525), sug-
gestingtheyarerelativelysecureagainstthisvulnerabilitycategory.
Similar observations can be madefor otherlanguageselections.
Riskyresource management(mgmt.) 48% of our vulnerability-
fixingcommitsfallinthiscategoryofvulnerabilities,whicharedue
toimpropercreation,usage,transfer,ordestructionofimportant
system resources [ 53] (e.g.,integer overflow/wraparound ,uncon-
trolled format string ). The results show that the impact of language
selection on these vulnerabilities was generally more significant
than that on the porous defenses category. One exception is java
javascript , whichhadasignificantimpacton thelatterbutalmost
no impact on resource management vulnerabilities. Most of the
languageselectionshavingagreater-than-averageassociationwith
these vulnerabilities include corc++: both are with unmanaged
memory type (hence prone to memory errors [ 47,77]) and well-
knownfor being prone to memory vulnerabilities[ 62].
Insecure interaction. Thesevulnerabilities,towhich16%ofour
vulnerability-fixingcommits belong,are aresultofinsecureways
852On the VulnerabilityPronenessof Multilingual Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
inwhichdataissentandreceivedbetweenseparatecomponents,
modules,programs, processes,threads,orsystems[ 53](e.g.,cross-
site request forgery ,cross-site scripting ,SQL injection ). While this
category was the weakest among the three (with respect to the
residualdevianceofthemodel),thedevianceexplainedbylanguage
selectionwasstillstrong.Theselectionswithsignificant,positive
coefficientsweremostlycombinationsoflanguagescommonlyused
inWebapplications(e.g., javascript php ,java javascript ).Thiscanbe
explainedbythefactthatvulnerabilitiesinducedbytheinteraction
amongtheseWebdevelopmentlanguagesareindeedprevalentin
WebapplicationsÃinparticular,interfacesbetweentheselanguages
arewellknowntobevulnerabletocodeinjections(e.g., cross-site
scriptingcommonly exploitedbyinjecting javascript code [81]).
Languageselectionwasmorestronglyassociatedwiththeproneness
tospecificcategoriesofvulnerabilitiesthantovulnerabilitiesoverall.
The top selections were more prone to resource management risks
and insecureinteractionsthanto porous defenserisks.
3.2 RQ2: Factors Contributingto theRelevance
Earlierstudiesrevealedcross-languagelinksaspossiblepointsof
high risks in multi-language systems in general [ 55] and inter-
language dependencies as contributors to the vulnerabilities of
JNI programs in particular [ 35]. We thus examine the effects of
languageinterfacingonthevulnerabilitypronenessofmultilingual
code that uses corresponding interfacing mechanisms, as a way to
justify/explainthesecurityrelevanceoflanguageselection.Westart
withanoverviewofhowvariousmechanismsareused,followed
bythesametwoaspectsofsecurityrelevanceasexaminedforRQ1.
Another potential contributing factor lies intuitively in the indi-
viduallanguagesselected.Thus, we alsoexamine theireffects.
3.2.1 OverallUseofInterfacingMechanisms. Foreachproject, Lice
mined the interfacing mechanisms as completely as possible, re-
sulting in some language selections having hybrid mechanisms.
In total, it found 8 combinations of mechanisms, over which our
4,001 language selections were non-overlappingly distributed as:
pureFFI8.68%,FFI EBD 1.19%,FFI IMI 24.55%,FFI IMI EBD
1.26%, pure IMI29.23%,IMI EBD 23.87%, pure EBD5.87%, pure HIT
5.36%.Implicitinterfacing was dominant: 86% of them used IMI,
EBD,orboth.Onereasonwasthatonlyasmallportion(20/66)of
thelanguagepairswhoseinterfacingpatternsunderlaidthecon-
struction of Lice(cf.Â§2.4.2) supported FFIÃnot many languages
support foreign functions. Another justification lies in the ben-
efits of implicit interfacingÃit helps reduce the coupling among
different(language)components andthecomplexity/difficulty(al-
though increasing the flexibility) of implementing the software,
especiallywiththeavailabilityofmaturesupportingframeworks
(e.g., gRPC [ 36] for interfacing among c, python, java, ruby ). We
also found a substantial use of EBD, mainly due to projects using
theselection{ javascript css html }.Thisechoespriorfindingsonthe
commonuseofgeneral-purposeprogramminglanguagesinterfaced
withdomain-specific languages[ 55].
Implicit interfacing was dominantly used over explicit mechanisms
like FFI (e.g., JNI), justifiable by the practical benefits of the former.
3.2.2 DifferentialVulnerabilityPronenessofLanguageInterfacing.
The 8 combinations of interfacing mechanisms were consideredTable 6: NBRcoefficients on the vulnerability proneness of
language interfacing mechanisms. AIC=42186, BIC=42267.89, Log
Likelihood=-21080,Deviance=8545.8;marks:***p<0.001, **p<0.01, *p<0.05
Independent factors Coeff.Std.Error
FFI 0.28170.092 **
FFI IMI 0.16760.095 *
FFI EBD -0.14540.415 *
FFI IMI EBD 0.75760.380
IMI 0.64410.164 ***
IMI EBD -0.30590.092 *
EBD -0.08110.089
HIT 0.49980.498
the independent variables (and predictors) in our NBR model here,
wherethenumberofvulnerability-fixingcommitsisagainencoded
as a response. Table 6shows the details of this model which quan-
tifiesthe overallsecurity effectsof languageinterfacing.
TheNBRnumbersrevealedstrongeffectsoflanguageinterfacing,
explicit(i.e., FFI)orimplicit(e.g., IMI,aloneorwith FFI),onthe
vulnerabilitypronenessofmultilingualcode.Itisknownthatusing
multiple languages make a system more vulnerable than when
usingasinglelanguage[ 35].Ourresultscomplementbyoffering
clearevidenceoflanguageinterfacingmechanismasamajorfactor
oftheoverallsecurityrelevanceofusingmultiplelanguages.Indeed,
contrasting the result here (e.g., Table 6) with that for RQ1 (e.g.,
Table4)confirmsthat themore(less)vulnerablemechanismswere
thoseused in themore(less) vulnerable languageselections .
Table7:NBRcoefficientsonthepronenessoflanguageinter-
facing mechanisms to each of the three high-level vulnera-
bility categories. marks:***p<0.001, **p<0.01, *p<0.05
Independent factorsPorousdefense Risky resource mgmt. Insecure interaction
Coeff.Std.Err. Coeff.Std.Err. Coeff.Std.Err.
(Intercept) -1.23280.152 *** -1.59020.059 *** -2.05170.096 ***
FFI 0.54340.315 ** 0.47330.109 *** -1.37080.180 *
FFI IMI 0.35620.321 * 0.47580.114 *** -1.16830.239 *
FFI EBD 1.83570.266 * 0.71600.525 1.09500.634 *
FFI IMI EBD 0.35400.471 0.86100.487 * -2.01671.186
IMI 1.11561.368 ** 0.74570.531 0.64900.643 *
IMI EBD -0.44700.320 -0.39170.113 ** -0.32150.241
EBD -1.63420.312 * -0.39420.108 *** 0.30440.233 **
HIT -0.00880.270 1.26190.126 *** -0.16340.642
AIC 25082 26224 13330
BIC 25163.89 26305.89 13411.89
Log Likelihood -12528 -13099 -6652
Deviance 7521.4 7374.5 3897.1
Three mechanisms ( FFI, FFI IMI, IMI ) were significantly
morevulnerability-prone,whichaccountedforthemajority(62.5%)
of the language selections in our dataset. Meanwhile, other mecha-
nismswerelessprone(e.g., FFI EBD)ornotsignificantlyassociated
with the proneness (e.g., EBD, HIT ). Based on ourextensive case
studiesbycodeinspection,akeyreasonforthesedifferentialeffects
is thatFFIandIMIallow for immediate data interoperations at
language boundaries, via code-level (explicit/implicit) data/control
flows induced by direct function calls. Such high data interoper-
ability promises for programming ease but welcomes additional
surfacesforstealthyattacks.Incontrast,thesearenotreadilypossi-
ble withEBDorHIT. Interestingly, EBDseemed to be not only more
securethanaveragebyitself,italsoappearedtohelpmitigatethe
insecurity of more vulnerable mechanisms (e.g., FFIversusFFI
EBD,IMIversusIMI EBD).Thisislikelybecauseitsusehelpedre-
duce the amount of vulnerable cross-language data exchanges that
wouldotherwisebe fully handledbythe vulnerable mechanisms.
853ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore WenLi, LiLi, andHaipeng Cai
Bothexplicitandimplicitlanguageinterfacingmechanismswere
strongly associated with code vulnerability proneness overall; FFI
and IMI werethemost vulnerability-prone mechanisms.
3.2.3 Topic Traits of Interfacing Effects. To understand the effects
on specific vulnerability categories, we built a separate NBR model
for each category, using the same predictors as in Â§3.2.2but the
number of vulnerability-fixing commits only belonging to that
category as a response. Table 7lists the details of the three models.
Theresultsshowthatthethreeoverallmostvulnerablemecha-
nismswerestronglyassociatedwitheachofthetwodominating
vulnerabilitycategories(cf.Table 1),whichlargelyexplainedthe
overallassociationstrength.Meanwhile,amongthesethree,both
FFIandFFI IMI actually had less-than-average proneness to Inse-
cure interaction vulnerabilities. The reason is because these vulner-
abilitiesweretypicallyassociatedwithWeblanguages(cf. Â§3.1.2),
whichdonotinteractthrough FFI.Thisexplanationwasconsoli-
datedbythepositiveassociationbetweenthisvulnerabilitycate-
gory and EBD, the dominant mechanism of interfacing across Web
languages(e.g., javascript php ).Thesamecanalsoexplainthestrong
effectofFFI EBD onthiscategory.Toverify,wemanuallysampled
and examined 10 projects that use { FFI EBD} and found that 7 of
them used the language selection { c c++ css html javascript }Ãthe
dominationofWeblanguagescaused insecureinteractions .
Proneness to insecure interaction vulnerabilities was most strongly
associated with using EBD but the strength was counteracted by
usingIMI;Themostoverall-vulnerability-pronemechanisms(FFI,
IMI)weremost prone to porous defensevulnerabilities.
3.2.4 EffectsofIndividualLanguages. WeperformedthesameNBR
analysis as inÂ§3.2.2, with (1) the model predictors changed to
individuallanguagesamongthestudiedselections(1stcolumnof
Table4), and (2) every data point changed to ğ‘˜points each for one
oftheğ‘˜languagesselectedintheprojectbutwiththesameproject
vulnerability proneness value. Table 8shows the model details.
Overall, the associations of individual languages were strong, even
strongerthanthoseoflanguageselections,withthepronenessto
bothvulnerabilitiesingeneralandthethreespecificvulnerability
categories.The mostprone languageswere java,c,go,andc++.
However, put together with Tables 4and5, the results show
thatthepronenessoftheseindividuallanguageshadgenerally no
consistent correlation with that of language selections. In some
cases,thelanguageselections(e.g., c python)andsomeoftheselected
individual languages (e.g., c) were consistently prone or not. Yet
inmorecases,languageselections(e.g., c c++ python )thatinclude
one or more strongly prone languages (e.g., candc++) were not
significantlyproneatall(orevennegativelyprone).Also,thereare
languageselections( c python,c++ python ,c c++ shell )thathavemuch
stronger pronenessthanany ofthe individuallanguagesselected.
Ontheotherhand,contrastingTables 6,7,and8revealedmostly
consistentcorrelationinthepronenessbetweenlanguageselections
andthecorrespondinginterfacingmechanisms.Forinstance,the
proneness of c c++ shell and that of the interfacing mechanism
mostcommonlyusedinthisselection IMIwereconsistentlystrong.
Foranotherexample, thepronenessof html rubyandhtml javawasTable8:NBRcoefficientsonthepronenessofindividuallan-
guages. marks:***p<0.001, **p<0.01, *p<0.05
IndependentfactorsOverall Porous defense Riskyresourcemgmt. Insecureinteraction
Coeff.Std.Err. Coeff.Std.Err. Coeff.Std.Err. Coeff.Std.Err.
(Intercept) 1.24550.074 *** -2.23140.121 *** -0.46930.102 *** -3.57890.224 **
html -0.07470.044 * 0.20490.067 -0.14730.063 * 0.74610.133 *
javascript 0.04510.057 *** 0.12060.077 -0.19830.077 * 0.56090.158 ***
shell 0.13290.037 0.05960.061 0.19350.052 * 0.11320.114
ruby 0.20040.069 ** 0.78810.104 * -0.42410.104 1.32930.186 ***
go 0.48940.086 ** 0.93710.127 * 0.96960.113 *** 0.25140.293
java 0.65840.065 *** 1.05200.090 *** 0.68490.087 *** 0.68790.190 ***
css 0.00740.048 -0.06150.075 -0.10040.071 0.10320.141
python 0.05310.045 * 0.39080.073 -0.20440.061 * 0.73860.134 **
c 0.54440.061 *** -0.15150.093 1.10800.078 *** 0.13690.193
c++ 0.42710.059 *** -0.00180.090 0.71120.075 *** -0.79950.195 *
php 0.24800.074 *** 0.91880.100 *** -0.48760.109 * 2.13350.191 ***
objective-c 0.38270.131 * -0.64880.295 * 0.59430.189 ** -1.86210.644 *
AIC 31056 5202.8 17879.4 5200.4
BIC 31040.29 5187.09 17863.69 5184.69
LogLikelihood -15516 -2589.4 -8927.7 -2588.2
Deviance 5615.3 1808.3 5672.7 2141.0
Table9:Sampledprojectsandnumbersofconfirmedvulner-
abilities (#Vul) in each, by language selection (LangSel, left
table) andinterfacingmechanism(InterMech, right table)
LangSel Projects #Vul
c c++ shellPencil [69]6
15Ncmpcpp[ 60]5
Proxysql[ 85]3
Fontforge[ 32]1
Lnav [83]0
c pythonLily[29] 6
9RediSearch[ 78]2
Pillow [72]1
Osmc[67]0
Phoenix [ 23]0
java shellEhcache3 [ 24]5
6Elassandra[ 25]1
Quasar [88]0
Smali[37]0
Siddhi [82]0InterMech Projects #Vul
FFIAngr [8] 6
13RestKit[79]5
Moderngl[ 58]1
Printrun2[ 44]1
SDMongoDB[ 20]0
FFI_IMIMysql5.6[ 26]5
8Brackets-shell [ 6]2
Openbr[65]1
UPX [89] 0
VisPy[91] 0
IMI_EBDUI-Grid [9]2
4Flask-Admin [ 31]1
Wormhole [ 52]1
Securedrop [ 33]0
Statamic3[ 84]0
negative,whichisconsistentwiththenegativepronenessof EMD,
themostcommonlyusedinterfacingmechanisminthoseselections.
The proneness of language selections was generally consistently
correlated with that of the underlying interfacing mechanisms, but
not consistentlywiththat ofthe individuallanguagesselected.
3.3 RQ3: Real-WorldMultilingualVulnerability
OurresultsforRQ1andRQ2revealed(1)strong statistical relevance
of language selection to vulnerability proneness of multilingual
code and (2) strong statistical contribution of language interfacing
mechanismtothatrelevance.Nowquestionsremain:(a)dothose
general, statistical findings hold in concretemultilingual code? and
(b) does the statistically strong proneness indicate actualvulner-
abilities? and if so (c) what do they look like and how are they
inducedby thelanguageselectionsandinterfacingmechanisms?.
To answer these, we conducted two large-scale manual studies:
one to (1) concretize/validate statistical findings from RQ1 and RQ2,
whiletheotherto(2) demonstrate/explainactualvulnerabilities in
multilingualcode indicatedbythe statisticalproneness.
3.3.1 Concretize/ValidateStatistical Findings. We randomly chose
3toplanguageselectionsandrandomlysampled5projectsforeach,
as listed in Table 9(left). Then, we randomly sampled 100 commits
foreachprojectandlookedintoeachcommittoconfirmifitwas
indeedforfixingan actualvulnerability.Thelasttwocolumnsof
thetable showthe numberof confirmedvulnerabilities(#Vul)per
project and the total for the language selection. The per-project
#Vuls are sortedto easecomparisons acrosslanguageselections.
854On the VulnerabilityPronenessof Multilingual Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
As per our statistical numbers (Table 4), the selection c c++
shellwas noticeably more vulnerability-prone than the selection
c python (coefficient 0.7641 vs. 0.6253, with the same level of
significance strengthÃ ğ‘<0.001). Now per the numbers of actual
vulnerabilitiesfound,the c c++ shell projectswereindeednotice-
ably more vulnerable than the c python projects in our random
samples. Similarly, the statistical finding that java shell was the
leastpronetovulnerabilities(coefficient0.2766with ğ‘<0.01)among
thethreechosenselectionsisalsoconsistentwithourcasestudy
resultshere(the java shell projectssampledhadtheleast#Vuls).
Withasimilarprocedurebutstartingwith3randomlychosen
interfacingmechanisms,we manuallystudiedanother randomset
of5projectspermechanism,aslistedinTable 9(right).PerTable 6,
FFI(coefficient0.2817with ğ‘<0.01)was morevulnerability-prone
thanFFI_IMI(coefficient0.1676with ğ‘<0.5).Thisisconsistentwith
theactual vulnerabilities found inour samplesÃthe projects using
FFIhadgenerallymorevulnerabilitiesthanthoseusing FFI_IMI.
The least statistical proneness of IMI_EBD (coefficient -0.3059 with
ğ‘<0.5)wasalsoconfirmedbythefewestvulnerabilitiesoverallin
our sampledprojectsusing this interfacingmechanism.
Ourstatisticalfindingsonthedifferentialvulnerabilityproneness
of both language selection (RQ1) and interfacing mechanism (RQ2)
were validated by (consistent with) the magnitude of actual vulner-
abilitiesin concretemultilingual codein ourextensive casestudies.
3.3.2 Demonstrate/ExplainActualVulnerabilities. Weobservedwide
presencesofcross-languagevulnerabilitiesinourdataset.Forspace
limits, wedemonstratethatin4 casesthat coverdifferent language
selections and interfacing mechanisms. In the per-case figures,
arrow-dashedlinesshowthevulnerableinformationflows,ofwhich
cross-language ones are in red; the associated (vulnerability-fixing)
commits are indicatedbythe code diffswithdeletedlinesgrayed.
Case 1(Figure3).Revealedviacommit[ 73],theTIFFimageis
the user input, taken (line 1) and loaded (line 5) in pythonand
then decoded (line 11)eventually, via FFI (offered with pythonâ€™sc
extension[ 75]),by_decodeStrip inc(line20).Withinthis cfunc-
tion,theincorrectboundarycheck(line27)ledtoa bufferover-read
vulnerabilityatline32.Thecheckshouldensuretherealrowsize
oftheTIFFimage( row_byte_size )islessthantheexpected(cal-
culated)size( unpacker_row_byte_size ),asfixedbythecommit
(line28).Thisvulnerabilityis explainedby theselectionof c,which
ismemory-unsafe,andtheuseofinterfacingmechanismFFI,which
propagatesthe pythondata to the unsafememory operation in c.
Case 2(Figure4). Found via commit [ 61], aninsecure string
copyvulnerability was induced by FFI (offered with native abstrac-
tionsforNode Ë™js[5])alsobutinadifferentlanguageselection c++
javascript .Injavascript ,testPort wastakenastheuserinput
(line1).Atline3,a SerialPort objectwasinitialized;thenthe c++
functionopen(definedatline20)wascalled(line4).Eventually,the
vulnerability occurred at line 15, where the string format specifier
(%s)wasmissinginthe c++functionsprintf,causingtheinsecure
stringcopy vulnerabilityacrossthe twolanguageshere.
Case 3(Figure5).Thecommit[ 14]ledustoa crosssiterequest
forgery(CSRF)across3languages: twiginterfacedwith javascript
viatheEBDmechanism,while javascript andphpexchangeddata
(atoken)overthenetwork(i.e.,viatheIMImechanism).Thevul-
nerabilitywasfixed byretrieving and validatingthe token(line 3)
Figure 3:Case 1Å›buffer over-read across c python .
Figure4:Case2Å›insecurestringcopyacross c++ javascript .
Figure 5:Case 3Å›CSRF across twig javascript php .
forafileoperation(renaming). Thetokenwasintegratedintothe
javascript function renamefile ,which wasembeddedin twig
(html)atline3.Then,thedefinitionof renamefile wasmodified
accordingly in javascript (line 7), including adding parameters
and obtaining the token. In php, the token was extracted from the
request (line 20) and verified (line 21). If the token is invalid, the
server wouldrefuse the request andabort (line22).
Case 4(Figure6).Thecommit[ 28]fixedaNULLpointerderef-
erencevulnerability explained by using the lilylanguage and c
that interfaced via the HIT mechanism. A code snippet in lily
was passed to an interpreter tat lines 5-9, where the variable
855ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore WenLi, LiLi, andHaipeng Cai
Figure 6:Case 4Å›NULL pointerdereferenceacross lily c.
b2was initialized as None. Whenb2reached line 8, the inter-
preter implemented in ctried to decode its class id at line 19
(right->value.container->class_id ). However, the container
pointerwasNULLwhen b2wasNone,causingtheNULLpointer
dereference vulnerability. To fix this issue, theinterpreter added a
validation checkat line17 before dereferencing the pointer.
Cross-language vulnerabilities were widely present in the studied
multilingual code and were all explainable through the language
selectionandinterfacingmechanismsamongtheselectedlanguages.
4 RELATED WORK
Studyofqualityeffectsoflanguages. Recentstudieshavelooked
at the fault proneness of design smells in multi-language soft-
ware [4] and how inter-language dependencies affect code qual-
ity [35]. Yet they were both limited to one particular language
selection (Java-C) and a small set (only 10 or less) sample projects.
The study by Abidi et al.[3] revealed that understandability is
the most impacted quality attribute in a multi-language system
based on the perceptions of 93 developers. Another study provided
empiricalevidencethatmostdevelopers hadencounteredatleast
onebugrelatedtocross-languagelinkingandthattheuseofmul-
tiple languages increased the difficulty of bug fixing [ 55]. A few
otherrelevantstudies[ 77,94]areonindividuallanguagesrather
than language combinations. Our work differs in addressing the
security impact of language selection in real-world multi-language
projects. On the other hand, it would be interesting future work to
studythevulnerabilitypronenessof single-language projectsÃprior
works [10,45] examined single-language codeâ€™s proneness to de-
fects in general (including security defects) but did not particularly
investigatethepronenesstosecurityvulnerabilities.Thesekinds
ofresults can be comparedwithandcomplementours.
Analysisoflanguageinteractions. BissyandÃ© etal.measuredthe
closenessbetweendifferentlanguagesthatinformsaboutlanguage
interoperability [ 13]. Similar results were also obtained through an
assessment of polyglotism, which indicated strong relationships
between languages and revealed the sets of languages that tend
to be used together in practice [ 54,87]. Our study also concerns
the interactions between languages but indirectly yet more deeply,
aswelookedatlanguagesinselections.Ourworkalsodiffersbylooking beyond the companionship of languages, into the security
rationales underlying the languageinteractions (viainterfacing).
Commit-based vulnerabilityidentification. LikeourVCtech-
nique, prior works also explored identifying vulnerabilities in code
repositories through analysis of commits. D2A [ 95] uses static ana-
lyzersandlearning-basedclassifierstodetectvulnerability-fixing
commits.AnotherrelevanttoolisVCCFinder[ 71],whichusescode
metricsandGitHubmetadataasfeaturestotrainaSVMclassifierto
labelacommitasvulnerability-contributingornot.Thetoolin[ 97]
usesfeaturesbasedoncommitmessagesandbugreportstoclassify
a commit or report as vulnerability-related or not. Our approach is
differentandtendedtobemoreaccurate(83%accuracyversus:53%
by D2A, 36% by VCCFinder, 50% by [ 97] for commit classification).
Real-world vulnerability datasets. We contribute a dataset on
vulnerability-fixingcommits,whichissimilartoD2A[ 95]innature
but much larger in size (ours 141,380 versus their 18,653 such com-
mits) with much (30%) greater accuracy. Meanwhile, our dataset
complements to CVE-based datasets such as BigVul [ 27] and CVE-
fixes [11], whichare muchsmallerandfor C/C++ code only.
5 DISCUSSION
5.1 ToolsandDataset
Despite the overwhelming and growing dominance of multilingual
systems[ 50,55,87]inreal-worldsoftwaredomains,toolsupport
forunderstandingandanalyzingthese systemsislacking.Beyond
ourempiricalfindings,wecontributetwonoveltools:VC( Â§2.3)for
automaticallyidentifying/classifyingvulnerability-fixing commits,
andLice(Â§2.4)forautomaticallyidentifying/classifyinglanguage
interfacing mechanisms [ 49]. Both tools offer promising accuracy;
they not only enabled our study but also will empower future
characterization studies andtool development for multi-language
software.Inparticular,VC outperformed thestate-of-the-artpeer
tools(asdiscussedin Â§4),whileLiceisthefirstofitskindbasedon
ournovel/first taxonomy of languageinterfacingmechanisms.
Importantly,usingVC,wecontributeanimportant,much-needed,
sizabledataset:asetof141.38Kvulnerability-fixingcommits,along
withtherepositoryinformation,associatedissueids,andbugtag-
ging whenever available. Beyond supporting relevant empirical
studies,thisdatasetcanboosttheperformanceofmachinelearn-
ing (ML), especially deep learning (DL) [ 64], based vulnerability
analysis (e.g., detection [ 96], repair [ 39]) tools. Extant such tools
sufferpoorperformanceonreal-worlddatasets[ 96]mainlybecause
theML/DLmodelswereonlytrainedonlargelyartificialdatasets
whichdonotwellrepresentrealisticvulnerabilitiesandcodebasesÃ
existing realistic datasets (e.g., [ 11,27]) are small while existing
sizeabledatasetsareonlyartificial.Ourcommitdatasetcorresponds
to141.38Kpairsofreal-worldvulnerablesamplesandtheirfixed
versions, which can serve as a large-scale, realistic dataset to train
DL/MLmodelshenceimprovetheirperformanceagainstreal-world
software.Asdiscussedin Â§4,oursismuchlargerandofhigherqual-
ity(duetoVCâ€™shigheraccuracy)thanthemostrecentpeerdataset.
Licecan also be used beyond our studies. For instance, with the
interfacingmechanism it reports, it can guide the development of
cross-language vulnerability detection [ 51] techniques. Interfacing-
mechanism-specificdetectionrules/algorithmscanbethendevised,
which would be more accurate than a universal/generic technique
handling multilingualcode of arbitrary interfacingmechanisms.
856On the VulnerabilityPronenessof Multilingual Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
5.2 Implications
5.2.1 AttentiontoCross-LanguageVulnerabilities. Wefoundstrong
vulnerability-proneness of multilingual code ( Â§3.1,Â§3.2). Our exten-
sive case studies further confirmed that the proneness did indicate
actualvulnerabilities( Â§3.3).Yet,existingworksonthesevulnerabil-
itiesarerare.Forexample,afterchecking1,000+papersonprogram
analysis randomly chosen from those published in the past 5 years
intheACMdigitallibrary,wefoundonly0.8%oftheseare generally
relatedtocross-languageanalysis,andthese0.8%almost[ 59]exclu-
sivelytargetedaparticularlanguageselection c java[4,40,46,92].
However, c javawasnoteveninourtop-20languageselections.
We suggestthatour communitystarts to attendto this severe gap
andurgentissuebyinvestingintoolsandstudiesoncross-language
defectswhilegoing beyondJava-C(JNI)software.
5.2.2 PracticalRecommendationsforResearchers. Whilebothbased
onGitHub,earlierstudies[ 10,77]foundlittleeffectof individual
languages on software proneness to defects, whereas ours revealed
strong effects of language selection on the vulnerability proneness
of multilingual code ( Â§3.1). We further found ( Â§3.2) that these ef-
fects weregenerally correlated with thoseoflanguageinterfacing
mechanisms, rather than with those of individual languages. Thus,
we suggest researchers examine and utilizelanguage interfaces
when addressing multilingualcode security.
We found FFI and IMI as the most vulnerability-prone mecha-
nisms for language interfacing. Both of them allow for direct data
interoperations via code-level invocations (explicit or implicit). We
suggest to prioritize on multilingual code using these mechanisms,
addressingnotonlyexplicitcross-languageinteractions(e.g.,via
foreign/native functions)but alsoimplicitones (e.g.,viaRPC).
5.2.3 PracticalRecommendationsforToolBuilders. Inparticularfor
thosetobuildtoolsformultilingualsecurity,wesuggesttheylever-
age ML/DL models in addition to program analysis approaches.
ML/DL models can be built using attributes of language selec-
tions (e.g., size, properties like types of each selected language)
and those of interfacing (e.g., mechanism category, interface pa-
rameters) as learning features, while leveraging our large, realistic
vulnerability dataset for training and validation. Meanwhile, given
thediversityoflanguageselectionandinterfacing,wesuggestcode-
analysis-based approaches focus on language-independent analyses
(e.g.,[12])Ãdevelopingalanguage-selection-specificanalysislike
the onesfor Java-Cis notsufficient[ 93]. Onespecificapproach is
tocompute cross-languageinformationflow toidentifymultilingual
vulnerabilities, as we demonstratedinour casestudies( Â§3.3).
5.2.4 PracticalRecommendationsforDevelopers. Ourresultsclearly
indicate that some language selections (e.g, c python ) were sig-
nificantlymorepronetovulnerabilitiesthanothers( Â§3.1)andthe
pronenessdidindicaterealvulnerabilities( Â§3.3),soweresomein-
terfacing mechanisms (e.g., FFI, IMI) than others ( Â§3.2). We suggest
developerschooselessproneselectionsandmechanisms,ifpossible,
tomakethemultilingualcodepotentiallymoresecure.Moreover,
wefoundthatitwasnotuncommonthatdifferentkindsofinterfac-
ingmechanismswereusedforthesamelanguageselection.Thus,if
alanguageselectionmustbechosen,wesuggesttostillchooseless
vulnerability-prone mechanisms for interfacing among the chosen
languagesifpossible.Finally,basedonTables 5and7,wesuggesttomake choices of the selections and mechanisms that are less prone
to thecategories ofvulnerabilitiesthat are mostconcerning.
5.3 Threatsto Validity
The validity of our results was affected by the inaccuracy of our
Licetoolusedforlanguageinterfacingclassification.Moreover,the
tool was built on our manual summaries of interfacing patterns
among the top 12 mainstream languages, and it was applied in our
studyaroundthemanuallyderivedtaxonomy.Andthetechnique
wasevaluatedonlyagainstasmallsample.Biasesanderrorsduring
such manual processes may have caused greater inaccuracy in our
studyresultsthanwhatwereported.Asimilarthreatappliestoour
tool for commit-based vulnerability categorization and the manual
processofevaluatingitsaccuracy.Inaddition,thecorrectnessof
bothtoolsislimitedbytheaccuracyoftheunderlyingtoolsused
(NLTK, Regex, and FuzzyWuzzy ). To mitigate these threats, we
followed a cross-validation procedure by which the results were
approvedbythethreeauthorsinvolved.Wealsochosetosample
randomly in the manual evaluation to reduce the associated threat.
Relativetothepopulationofmulti-languagesoftware,ourdatasets
onlyrepresentsmallsamples.Thus,ourfindingsandconclusions
are best interpretedfor the sampled projects, and we cannot claim
that our results generalize to any other projects. To reduce this
threat, we used a reasonably large dataset and applied multiple
projectfiltersalongwithrandomsamplingtoreducedatanoises.
Meanwhile,we cannotrelyonCVEsdueto the small dataset size.
Inaddition,wedidnotdifferentiatelanguagesofdifferentclasses
(data modeling versus programming languages) and treated all lan-
guages equally in calculating code sizes in bytes. We actually in-
tendednottolimitourstudytoaparticularlanguageclassÃnote
that non-programming languages can play critical roles in code
vulnerabilitiestoo(e.g.,the twigtemplatinglanguagecontributed
tothevulnerabilityinFigure 5);Wealsodidnotruleoutanypartic-
ular kind of language, because we do not have a-priori knowledge
regardingwhichkindsmustnotberelevanttovulnerabilities.Yet
thistreatmentmayhavecausedbiasesinourresultsinterpretations.
Thevalidityofmostofourresultsisalsoaffectedbytheinaccuracy
ofGitHublinguist [ 2]we usedfor retrievinglanguageselections.
6 CONCLUSION
We presented a large-scale study on the vulnerability proneness
of multilingualcode, enabled by a novel taxonomy of language in-
terfacing mechanisms, two novel/dedicated tools, and new/sizable
datasets. From 4,001 GitHub projects and 20.37 million commits in
their repositories, we revealed strong statistical relevance of lan-
guage selectionand interfacing mechanismtothe proneness, and
evenstrongeroneswithrespecttospecificcategoriesofvulnerabili-
ties.Wefurtherconducted extensive manualinspectionstudiesof50
sampleprojectswith500commitsforeach,bothrandomlysampled,
hence validated our statistical findings and demonstrated actual
multilingualvulnerabilitiesindicatedbytheproneness.Basedon
our results, we provided insights and actionable suggestions on
addressing multilingualvulnerabilitiesfor variousstakeholders.
ACKNOWLEDGMENT
Wethank ourreviewersforconstructivecomments. Thisresearch
wassupportedbyNSF (CCF-2146233) andONR (N000142212111).
857ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore WenLi, LiLi, andHaipeng Cai
REFERENCES
[1]2020. GitHub:aUS-basedglobalcompany, provideshostingforsoftwaredevel-
opment version controlusing Git. https://github.com/ .
[2]2020. GitHubDeveloper:providesAPIstoretriveorqueryrepositoriesinGitHub.
https://developer.github.com/v3 .
[3]Mouna Abidi, ManelGrichi, and FoutseKhomh.2019. Behind thescenes:devel-
opersâ€™ perception of multi-languagepractices. In Proceedings ofthe 29th Annual
InternationalConference onComputer Scienceand SoftwareEngineering . 72Å›81.
[4]Mouna Abidi, Md Saidur Rahman, Moses Openja, and Foutse Khomh. 2021. Are
multi-languagedesignsmellsfault-prone?Anempiricalstudy. ACMTransactions
onSoftwareEngineering and Methodology (TOSEM) 30,3 (2021), 1Å›56.
[5]Adilapapaya. 2020. Native Abstractions for Node.js. http://adilapapaya.com/
docs/nan/ .
[6]Adobe. 2021. The CEF3-based application shell for Brackets. https://github.com/
adobe/brackets-shell .
[7] Paul DAllisonand Richard P Waterman. 2002. FixedÅ›effectsnegativebinomial
regressionmodels. Sociologicalmethodology 32,1 (2002), 247Å›265.
[8]angr. 2021. A platform-agnostic binary analysis framework. https://github.com/
angr/angr .
[9]AngularUI.2021. AnAngularJSdatagrid. https://github.com/angular-ui/ui-grid .
[10]EmeryDBerger,CelesteHollenbeck,Petr Maj,OlgaVitek, andJanVitek.2019.
On the impact of programming languages on code quality: a reproduction study.
ACMTransactionsonProgrammingLanguagesandSystems(TOPLAS) 41,4(2019),
1Å›24.
[11]GuruBhandari,AmaraNaseer,andLeonMoonen.2021. CVEfixes:automated
collectionofvulnerabilitiesandtheirfixesfromopen-sourcesoftware.In Proceed-
ings of the 17th International Conference on Predictive Models and Data Analytics
inSoftwareEngineering . 30Å›39.
[12]DavidBinkley,NicolasGold,MarkHarman,SyedIslam,JensKrinke,andShinYoo.
2014. ORBS: Language-independent programslicing. In Proceedings ofthe 22nd
ACM SIGSOFT International Symposium on Foundationsof Software Engineering .
109Å›120.
[13]TegawendÃ© F BissyandÃ©, Ferdian Thung, David Lo, Lingxiao Jiang, and Lau-
rentRÃ©veillÃ¨re.2013. Popularity,interoperability,andimpactofprogramming
languages in 100,000 open source projects. In 2013 IEEE 37th annual computer
softwareand applications conference . IEEE,303Å›312.
[14]bolt. 2021. A CSRF issue fixing commit in bolt. https://github.com/bolt/bolt/
commit/ca49f43934b5381ca15e4e8f13e74b9aa6cec7ea .
[15]FrancescaDelBonifro,MaurizioGabbrielli,andStefanoZacchiroli.2021. Content-
Based Textual File Type Detection at Scale. In 2021 13th International Conference
onMachineLearning and Computing . 485Å›492.
[16]YaofeiChen,RoseDios,AliMili,LanWu,andKefeiWang.2005. Anempirical
studyof programminglanguagetrends. IEEE software 22,3 (2005), 72Å›79.
[17]AdamCohen.2011. FuzzyWuzzy:Fuzzystringmatchinginpython. ChairNerd
Blog22(2011).
[18]PoC Consul and Felix Famoye. 1992. Generalized Poisson regression model.
Communications inStatistics-Theoryand Methods 21,1 (1992), 89Å›109.
[19]Harald Cramir. 1946. Mathematical methods of statistics. Princeton U. Press,
Princeton 500(1946).
[20]SpringData.2021. SpringDataMongoDB. https://github.com/spring-projects/
spring-data-mongodb .
[21]Daniel P Delorey, Charles D Knutson, and Christophe Giraud-Carrier. 2007.
Programminglanguage trends in open source development: An evaluation using
data from all production phase sourceforge projects. In Second International
Workshop onPublic Data about SoftwareDevelopment (WoPDaSDâ€™07) .
[22]ClaudioDiSipio,RiccardoRubei,DavideDiRuscio,andPhuongTNguyen.2020.
AMultinomialNaÃ¯veBayesian(MNB)NetworktoAutomaticallyRecommend
Topics for GitHub Repositories. In Proceedings of the Evaluation and Assessment
inSoftwareEngineering . 71Å›80.
[23]Robin Dunn.2021. wxPythonProject Phoenix. https://github.com/wxWidgets/
Phoenix.
[24]ehcache. 2021. Ehcache3:Javaâ€™s most widely-used cache. https://github.com/
ehcache/ehcache3 .
[25]elassandra.2021. Elassandra:anApacheCassandradistribution. https://github.
com/strapdata/elassandra .
[26] Facebook.2021. MySQL Server 5.6. https://github.com/facebook/mysql-5.6 .
[27]Jiahao Fan, Yi Li, Shaohua Wang, and Tien N Nguyen. 2020. AC/C++ Code
Vulnerability Dataset with Code Changes and CVE Summaries. In Proceedings of
the 17thInternationalConference onMiningSoftwareRepositories . 508Å›512.
[28]FascinatedBox. 2021. A NULL pointer access fixing commit
in lily. https://api.github.com/repos/FascinatedBox/lily/commits/
7c848602989f59be50f30e096135c520d086650a .
[29]FascinatedBox.2021. Aprogramminglanguagefocusedonexpressivenessand
typesafety. https://github.com/FascinatedBox/lily .
[30]Jason Firch and Josh Allen. 2021. Cyber Security Trends You Canâ€™t Ignore In
2021.https://purplesec.us/cyber-security-trends-2021/ .
[31]flask admin. 2021. A batteries-included, simple-to-use Flask extension. https:
//github.com/flask-admin/flask-admin .[32]fontforge.2021. Afree(libre)fonteditor. https://github.com/fontforge/fontforge .
[33]freedompress.2021. Anopen-sourcewhistleblowersubmissionsystem. https:
//github.com/freedomofpress/securedrop .
[34]Xiaoqin Fu and Haipeng Cai. 2021. FlowDist:Multi-Staged Refinement-Based
DynamicInformationFlowAnalysisforDistributedSoftwareSystems.In 30th
USENIXSecuritySymposium(USENIXSecurity21) . 2093Å›2110.
[35]Manel Grichi, Mouna Abidi, Fehmi Jaafar, Ellis E Eghan, and Bram Adams. 2020.
On the Impact of Interlanguage Dependencies in Multilanguage Systems Empiri-
cal Case Study on Java Native Interface Applications (JNI). IEEE Transactions on
Reliability (2020).
[36] gRPC.2020. gRPC Tutorial. https://grpc.io/docs/ . (2020).
[37]BenGruver.2021. Anassembler/disassemblerforthedex. https://github.com/
JesusFreke/smali .
[38]EmmaHaddi,XiaohuiLiu,andYongShi.2013. Theroleoftextpre-processingin
sentiment analysis. ProcediaComputer Science 17(2013), 26Å›32.
[39]JacobAHarer,OnurOzdemir,TomoLazovich,ChristopherPReale,RebeccaL
Russell,LouisYKim,andPeterChin.2018. Learningtorepairsoftwarevulnerabil-
itieswithgenerativeadversarialnetworks.In Proceedingsofthe32ndInternational
Conference onNeural InformationProcessingSystems . 7944Å›7954.
[40]SungjaeHwang,SunghoLee,JihoonKim,andSukyoungRyu.2021. JUSTGen:Ef-
fectiveTestGenerationforUnspecifiedJNIBehaviorsonJVMs.In 2021IEEE/ACM
43rdInternationalConference onSoftwareEngineering (ICSE) . IEEE,1708Å›1718.
[41] CapersJones. 2009. Softwareengineering bestpractices . McGraw-Hill,Inc.
[42]Eirini Kalliamvakou, Georgios Gousios, Kelly Blincoe, Leif Singer, Daniel M
German,andDanielaDamian.2016. Anin-depthstudyofthepromisesandperils
of miningGitHub. EmpiricalSoftwareEngineering 21,5 (2016), 2035Å›2071.
[43]Siim Karusand HaraldGall. 2011. A study of languageusage evolutionin open
sourcesoftware.In Proceedingsofthe8thWorkingConferenceonMiningSoftware
Repositories . 13Å›22.
[44]kliment. 2021. The master branch holds the development of Printrun 2.x. https:
//github.com/kliment/Printrun .
[45]Pavneet Singh Kochhar, Dinusha Wijedasa, and David Lo. 2016. A large scale
study of multiple programming languages and code quality. In 2016 IEEE 23rd In-
ternationalConferenceonSoftwareAnalysis,Evolution,andReengineering(SANER) ,
Vol. 1.IEEE,563Å›573.
[46]Sungho Lee, Hyogun Lee, and Sukyoung Ryu. 2020. Broadening Horizons of
Multilingual Static Analysis: Semantic Summary Extraction from C Code for JNI
ProgramAnalysis.In 202035thIEEE/ACMInternationalConferenceonAutomated
SoftwareEngineering (ASE) . IEEE,127Å›137.
[47]Wen Li, Haipeng Cai, Yulei Sui, and David Manz. 2020. PCA: memory leak
detectionusingpartialcall-pathanalysis.In Proceedingsofthe28thACMJoint
Meeting on European Software Engineering Conference and Symposium on the
FoundationsofSoftwareEngineering . 1621Å›1625.
[48]Wen Li, Li Li, and Haipeng Cai. 2022. Peer-Evaluated Artifact Package for
Å‚OntheVulnerabilityPronenessofMultilingualCode". https://figshare.com/s/
f56fd5f5319bbfa5250a .https://doi.org/10.6084/m9.figshare.16528521.v1
[49]Wen Li, Li Li, and Haipeng Cai. 2022. PolyFax: A Toolkit for Characterizing
Multi-LanguageSoftware.In ACMJointMeetingonEuropeanSoftwareEngineering
ConferenceandSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE) .
[50]Wen Li, Na Meng, Li Li, and Haipeng Cai. 2021. Understanding Language Se-
lection in Multi-Language Software Projectson GitHub. In 2021 IEEE/ACM 43rd
International Conference on Software Engineering: CompanionProceedings(ICSE-
Companion) . IEEE,256Å›257.
[51]Wen Li, Jiang Ming, Xiapu Luo, and Haipeng Cai. 2022. PolyCruise: A Cross-
Language Dynamic Information Flow Analysis. In 31st USENIX Security Sympo-
sium (USENIXSecurity22) . Boston, MA,2513Å›2530.
[52]magicwormhole. 2021. Alibrary and acommand-line tool. https://github.com/
magic-wormhole/magic-wormhole .
[53]BobMartin, MasonBrown, Alan Paller,DennisKirby,andSteveChristey.2011.
2011CWE/SANStop25most dangeroussoftwareerrors. https://cwe.mitre.org/
top25/archive/2011/2011_cwe_sans_top25.pdf . (2011).
[54]Philip Mayer and Alexander Bauer. 2015. An empirical analysis of the utilization
of multiple programming languages in open source projects. In Proceedings
of the 19th International Conference on Evaluation and Assessment in Software
Engineering . 1Å›10.
[55]PhilipMayer,MichaelKirsch,andMinhAnhLe.2017. Onmulti-languagesoft-
ware development, cross-language links and accompanying tools: a survey of
professionalsoftwaredevelopers. JournalofSoftwareEngineeringResearchand
Development 5,1 (2017), 1.
[56]Leo A Meyerovich and Ariel S Rabkin. 2013. Empirical analysis of program-
ming language adoption. In Proceedings ofthe 2013 ACM SIGPLAN international
conference on Object oriented programming systems languages & applications .
1Å›18.
[57] MITRE. 2020. Common Weakness Enumeration. http://cwe.mitre.org/ .
[58]ModernGL.2021. ApythonwrapperoverOpenGL3.3+core. https://github.com/
moderngl/moderngl .
[59]RaphaÃ«lMonat,AbdelraoufOuadjaout,andAntoineMinÃ©.2021. AMultilanguage
Static Analysis of Python Programs with Native C Extensions. In Static Analysis
858On the VulnerabilityPronenessof Multilingual Code ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Symposium(SAS) .
[60]ncmpcpp.2021. ANCursesMusicPlayerClient. https://github.com/ncmpcpp/
ncmpcpp .
[61]node serialport. 2021. A insecure string copy fixing commit in
node-serialport. https://github.com/serialport/node-serialport/commit/
a250f0983c2ca9b2b0fd5d9a00e1d88b0e8d2480 .
[62]Yu Nong andHaipengCai.2020. Apreliminary studyonopen-source memory
vulnerability detectors. In 2020 IEEE 27th International Conference on Software
Analysis, Evolutionand Reengineering (SANER) . IEEE,557Å›561.
[63]Yu Nong, Haipeng Cai, Pengfei Ye, Li Li, and Feng Chen. 2021. Evaluating
and comparing memory error vulnerability detectors. Information and Software
Technology 137(2021), 106614.
[64]YuNong, Yuzhe Ou,MichaelPradel,Feng Chen, andHaipengCai. 2022. Gener-
atingRealisticVulnerabilitiesviaNeuralCodeEditing:AnEmpiricalStudy.In
ACM Joint Meeting on European Software Engineering Conference and Symposium
onthe FoundationsofSoftwareEngineering (ESEC/FSE) .
[65]OpenbiometricsOrg.2021. OpenSourceBiometricRecognition. https://github.
com/biometrics/openbr .
[66]ORACLE. 2020. Java Native Interface Specification Contents. https://docs.oracle.
com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html . (2020).
[67] OSMC. 2021. Open Source Media Center. https://github.com/osmc/osmc .
[68]MichailPapamichail,ThemistoklisDiamantopoulos,andAndreasSymeonidis.
2016. User-perceived source code quality estimation based on static analysis
metrics.In 2016IEEEInternationalConferenceonSoftwareQuality,Reliabilityand
Security(QRS) . IEEE,100Å›107.
[69]Pencil2D.2021. Ananimation/drawingsoftware. https://github.com/pencil2d/
pencil.
[70]Havoc Pennington. 2020. D-Bus Tutorial. https://dbus.freedesktop.org/doc/dbus-
tutorial.html . (2020).
[71]HenningPerl,SergejDechand,MatthewSmith,DanielArp,FabianYamaguchi,
Konrad Rieck, Sascha Fahl, and Yasemin Acar. 2015. Vccfinder: Finding potential
vulnerabilities in open-source projects to assist code audits. In Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications Security .
426Å›437.
[72]Pillow.2021. ThePythonImagingLibrary. https://github.com/python-pillow/
Pillow.
[73]Pillow. 2021. A read buffer overflow fixing commit in Pillow. https://github.com/
python-pillow/Pillow/commit/87934e22d056cb72ad6c7e9dc48e06d2a02e2dec .
[74]Python. 2020. Extending Python with C or C++. https://docs.python.org/3/
extending/extending.html . (2020).
[75] Python.2020. Python3.9.2documentation. https://docs.python.org/3.9 .
[76]Foyzur Rahman and Premkumar Devanbu. 2013. How, and why, process metrics
arebetter.In 201335thInternationalConferenceonSoftwareEngineering(ICSE) .
IEEE,432Å›441.
[77]BaishakhiRay,DarylPosnett,VladimirFilkov,andPremkumarDevanbu.2014.
A large scale study of programming languages and code quality in github. In
Proceedingsofthe22ndACMSIGSOFTInternationalSymposiumonFoundationsof
SoftwareEngineering . 155Å›165.
[78]RediSearch. 2021. The querying, secondary indexing, and full-text search for
Redis.https://github.com/RediSearch/RediSearch .
[79]RestKit. 2021. A Objective-C framework for implementing RESTful web services
clients.https://github.com/RestKit/RestKit .[80]Simone Romano, Maria Caulo, Matteo Buompastore, Leonardo Guerra, Anas
Mounsif, Michele Telesca, Maria Teresa Baldassarre, and Giuseppe Scanniello.
2021.G-Repo:aTooltoSupportMSRStudiesonGitHub.In 2021IEEEInternational
ConferenceonSoftwareAnalysis,EvolutionandReengineering(SANER) .IEEE,551Å›
555.
[81]HossainShahriarandMohammadZulkernine.2011. Injectingcommentstodetect
JavaScriptcodeinjectionattacks.In 2011IEEE35thAnnualComputerSoftware
and ApplicationsConference Workshops . IEEE,104Å›109.
[82]siddhi io. 2021. A cloud native Streaming and Complex Event Processing engine.
https://github.com/siddhi-io/siddhi .
[83]Tim Stack. 2021. LNAV Å› The Logfile Navigator. https://github.com/tstack/lnav .
[84]Statamic.2021. Theflat-first,Laravel+GitpoweredCMS. https://github.com/
statamic/cms .
[85]Sysown. 2021. The proxy for MySQL and forks. https://github.com/sysown/
proxysql.
[86]GangTanandGregMorrisett.2007.ILEA:Inter-languageanalysisacrossJavaand
C. InProceedings of the 22nd annual ACM SIGPLAN conference on Object-oriented
programmingsystems, languagesand applications . 39Å›56.
[87]Federico Tomassetti and Marco Torchiano. 2014. An empirical assessment of
polyglot-ism in github. In Proceedings of the 18th International Conference on
Evaluationand AssessmentinSoftwareEngineering . 1Å›4.
[88]Parallel Universe. 2021. Fibers, Channels and Actors for the JVM. https://github.
com/puniverse/quasar .
[89]UPX.2021. Anadvancedexecutablefilecompressor. https://github.com/upx/upx .
[90]Bogdan Vasilescu, Alexander Serebrenik, and Mark GJ van den Brand. 2013.
The Babel of software development: Linguistic diversity in Open Source. In
InternationalConference onSocial Informatics . Springer, 391Å›404.
[91]vispy. 2021. A high-performance interactive 2D/3D data visualization library.
https://github.com/vispy/vispy .
[92]Fengguo Wei, Xingwei Lin, Xinming Ou, Ting Chen, and Xiaosong Zhang. 2018.
Jn-saf:Preciseandefficientndk/jni-awareinter-languagestaticanalysisframe-
workforsecurityvettingofandroidapplicationswithnativecode.In Proceedings
ofthe2018ACMSIGSACConferenceonComputerandCommunicationsSecurity .
1137Å›1150.
[93]Haoran Yang, Wen Li, and Haipeng Cai. 2022. Language-Agnostic Dynamic
AnalysisofMultilingualCode:Promises,Pitfalls,andProspects.In ACMJoint
Meeting on European Software Engineering Conference and Symposium on the
FoundationsofSoftwareEngineering (ESEC/FSE) .
[94]Jie Zhang, Feng Li, Dan Hao, Meng Wang, Hao Tang, Lu Zhang, and Mark
Harman.2019. AStudyofProgrammingLanguagesandTheirBugResolution
Characteristics. IEEE Transactions onSoftwareEngineering (2019).
[95]Yunhui Zheng, Saurabh Pujar, Burn Lewis, Luca Buratti, Edward Epstein, Bo
Yang, Jim Laredo, Alessandro Morari, and Zhong Su. 2021. D2a: A dataset
builtforai-basedvulnerabilitydetectionmethodsusingdifferentialanalysis.In
2021IEEE/ACM43rdInternationalConferenceonSoftwareEngineering:Software
Engineering inPractice (ICSE-SEIP) . IEEE,111Å›120.
[96]Yaqin Zhou, Shangqing Liu, Jingkai Siow, Xiaoning Du, and Yang Liu. 2019.
Devign:Effectivevulnerabilityidentificationbylearningcomprehensiveprogram
semanticsviagraphneural networks. arXiv preprint arXiv:1909.03496 (2019).
[97]Yaqin Zhou and Asankhaya Sharma. 2017. Automated identification of security
issues from commit messages and bug reports. In Proceedings of the 2017 11th
jointmeetingonfoundations ofsoftwareengineering . 914Å›919.
859