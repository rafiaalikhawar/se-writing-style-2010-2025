CorbFuzz: Checking Browser Security Policies with
Fuzzing
Chaofan Shou, ˙Ismet Burak Kadron, Qi Su, and Tevﬁk Bultan
University of California, Santa Barbara
{shou, kadron, qisu, bultan}@cs.ucsb.edu
Abstract —Browsers use security policies to block malicious
behaviors. Cross-Origin Read Blocking (CORB) is a browser se-
curity policy for preventing side-channel attacks such as Spectre.We propose a web browser security policy fuzzer called CorbFuzzfor checking CORB and similar policies. In implementing asecurity policy, the browser only has access to HTTP requests andresponses, and takes policy actions based solely on those interac-tions. In checking the browser security policies, CorbFuzz uses apolicy oracle that tracks the web application behavior and infersthe desired policy action based on the web application state. Bycomparing the policy oracle with the browser behavior, CorbFuzzdetects weaknesses in browser security policies. CorbFuzz checksthe web browser policy by fuzzing a set of web applications wherethe state-related queries are symbolically evaluated for increasedcoverage and automation. CorbFuzz collects type informationfrom database queries and branch conditions in order to preventthe generation of inconsistent data values during fuzzing. Weevaluated CorbFuzz on CORB implementations of Chromiumand Webkit, and Opaque Response Blocking (ORB) policyimplementation of Firefox using web applications collected fromGitHub. We found three classes of weaknesses in Chromium’simplementation of CORB.
I. I NTRODUCTION
Web browsers allow users to various things, such as
streaming videos or accessing bank accounts. A malicious
website should not be able to access sensitive informationabout a web application user, for example a bank accountpage. Unfortunately, due to vulnerabilities like cross-site scriptinclusion [1], cross-site scripting [2], Spectre [3], and Melt-down [4], malicious websites can access sensitive informa-tion that they should not have access to. Because of theaforementioned threats, browsers have adopted an increasingnumber of security policies like Cross-Origin Read Blocking(CORB) policy [5] that they use to protect sensitive data. Thegoal of the CORB policy is to prevent cross-origin access toconﬁdential data.
In order to determine if a behavior is malicious or not, a
browser security policy has to infer properties about the webapplication that is being used. Yet, given that a browser doesnot have access to web applications’ internal state, nor itscodebase, it cannot precisely determine the properties of theweb applications. Instead, security policy implementations usethe information browsers have access to, like HTTP responses
This material is based on research supported by NSF under Grants CCF-
1901098 and CCF-1817242.and requests, to infer properties of web applications and decideto take a policy action according to those properties.
In this paper, we focus on CORB as a browser security
policy because it is one of the most important policies forprotecting cross-origin resources. CORB aims to identify andblock all cross-origin loads of conﬁdential response content.However, browsers can not determine whether a speciﬁcresponse is conﬁdential without inspecting the state of theweb application. Since the browser cannot do that, the CORBpolicy implementations examine the responses instead anduse information inside responses and heuristics that reﬂectthe expected behavior to determine whether the content isconﬁdential.
These heuristic approaches need to be tested comprehen-
sively in order to look for scenarios where they fail to protectsensitive information. A fully automated testing approachwould enable browser security policy developers to identifyweaknesses in existing policies and to quickly evaluate policymodiﬁcations.
We developed a fuzzing technique to check browser security
policies. Given a browser and a security policy, we use a setof open-source web applications to look for weaknesses inthe security policy implementation of that browser. We usethe open-source web applications as fuzzing targets, and ourfuzzer creates requests for each of them, intending to achieveas much coverage as possible. By exploring a variety of webapplications and covering as many behaviors as possible foreach web application, our fuzzer tests a large set of scenariosfor the browser security policy implementation.
In order to identify weaknesses in the browser policy
implementation, we deﬁne a reference implementation of thesecurity policy by tracking the web application states andutilize it as an oracle. The oracle is more accurate than thebrowser policy implementation since during fuzzing, the oraclehas access to all internal information of the web applicationand properties of each response. Our fuzzer compares the deci-sions made by the oracle to the security policy implementationof the browser and reports any differences, which correspondto a weakness in the browser security policy implementation.
Most web applications typically access session data, cook-
ies, and data store [6]. These web applications are called data-dependent. Fuzzing a data-dependent web application requiresmanually setting up these data sources (e.g., populating adatabase [7], [8]). However, given that we need to use a
2152021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000292021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678636
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
set of web applications during fuzzing, it is not practical
to manually set up the data store and session values foreach web application. Thus, we propose a runtime for data-dependent web applications that enables us to automate theprocess. Instead of manually setting up data sources for allfuzzing targets, our runtime automatically synthesizes datastore, sessions and cookies. This approach not only removesthe requirement for manually setting up an environment for aweb application, but also allows our fuzzer to easily mutatethe data store, leading to higher coverage.
The runtime we propose generates SMT constraints for
database queries and sessions or cookies usage. The SMTconstraints for a database query encode the SQL statement,and we use an SMT solver to generate data values consistentwith the query. The SMT constraints generated for sessionsand cookies are used to check the feasibility of execution pathsof the web application.
Using this approach, we have implemented a fuzzer focus-
ing on the CORB policy, which we call CorbFuzz. WhileCorbFuzz is optimized for CORB analysis, it can be easilyextended to support other policies by deﬁning correspond-ing oracles. Additionally, for our prototype, we restrict ourscope to PHP applications. Our approach can be extended tosupport web applications developed in different programminglanguages, including Python or NodeJS, by providing simpleinstrumentation for the target language as discussed in Sec-tion IV.
We evaluate the implementation of CORB policy in both
Chromium and Webkit. CorbFuzz did not ﬁnd any policyviolations in Webkit and shows that CORB implementation inWebkit is robust. In Chromium, on the other hand, CorbFuzzidentiﬁes three types of code patterns that can enable attack-ers to bypass CORB protection. Furthermore, we modiﬁedCorbFuzz to check a sibling policy by Firefox called OpaqueResponse Blocking (ORB).
In this paper we present the following research contribu-
tions:
•Browser Policy Fuzzer: We propose a new fuzzer, Corb-
Fuzz, for checking browser security policies. CorbFuzzis guided by web application code coverage and uses apolicy oracle to identify weaknesses in browser securitypolicies. It is fully automated and can be easily appliedafter each change in policy implementation.
•Data Synthesis: To tackle fuzzing environment setup
for data-dependent applications, we propose a runtimethat synthesizes and mutates the data when required.Our data synthesis approach uses SMT encoding andconstraint solving to ensure consistency of data generatedfor database queries and sessions or cookies usage.
•Empirical Evaluation: We used CorbFuzz to check the
CORB implementation of Chromium and Webkit. Wealso checked a sibling policy ORB for Firefox. We fuzzedthese policies using responses of PHP web applicationsthat we obtained from GitHub. Using CorbFuzz, wediscovered three code patterns that expose weaknesses inthe CORB implementation of Chromium. One of thesecode patterns has been previously documented, and theChromium team patched the policy weakness caused byanother code pattern we discovered after our report.
The paper is structured as follows. In Section II, we present
the background on browser precautions. In Section III, wepresent our fuzzing framework. In Section IV, we discusshow we synthesize the data and bypass authentication for webapplications. In Section V, we evaluate CorbFuzz and describethe detected CORB weaknesses by our tool. In Section VI,we present the related work. In Section VII, we conclude thepaper.
II. B
ACKGROUND
In this section, we provide the background information on
Site Isolation and Cross-Origin Read Blocking policy.
A. Site Isolation and Information Leakage
Browser information leakage has gained increasing expo-
sure in the last few years. According to the Same-Origin Policy
(SOP) [9], one of the fundamental rules in browsers, docu-ments from different origins cannot interact with each other.However, many exploits have been discovered to conductcross-origin content leak [10]–[15]. Additionally, the discoveryof cache-related side-channel vulnerabilities like Spectre [16]and Meltdown [4] worsen the information leaks.
Site Isolation policy [17], [18] has been proposed to counter
cross-origin content leaks. Such a policy is also known as“one site per process” policy. Namely, a browser shouldensure that documents from different origins are rendered andexecuted in their own respective sandbox. Such an effort re-duces the chance of success of cache side-channel attacks andmakes most cross-origin information leakage vulnerabilities inbrowsers no longer exploitable.
B. Cross-Origin Read Blocking
While Site Isolation policy removes the possibility of docu-
ments in different origins interacting with each other directly,
there are still ways to inject documents from different originsvia interfaces provided by browsers. A possible approach isto include the documents from different origins as resourcesrequired by the webpage. Some examples have been providedbelow, for which the ﬁrst line is to load an endpoint as animage, and the second line is to load it as a script.
<img src="//a.com/secret" />
<script src="//a.com/secret"></script>
In addition, other browser JavaScript interfaces could be
used to pass partial sensitive information from one origin
to another. A famous example is CVE-2020-6442 [19]. Thevulnerability is that by loading two cross-origin documentsinto the cache, it is possible to calculate the difference ofsizes between two documents by calculating the increase in thesize of the cache. The size leakage technique could be easilyexploited to deduce the preference and the visiting history ofusers.
All these interactions make Site Isolation policy no longer
effective. While blocking all cross-origin requests could solve
216the issue, existing websites legitimately utilizing cross-origin
resources would similarly be affected by such an approach.Thus, Cross-Origin Read Blocking (CORB) policy has beenproposed. It aims to prevent HTTP responses from beingloaded into contexts at different origins if the informationis deemed conﬁdential. The authors have claimed that thiscould effectively reduce potential dubious cross-origin re-source fetches. Previous examples of XSSI attacks or the CVE-2020-6442 vulnerability become ineffective when a browserimplements the CORB policy [20].
A simpliﬁed version of the CORB policy implementation in
Chromium is shown in Procedure 1. This code is executed assoon as a response is received by the browser. It performs afew initial checks, including whether the scheme is HTTP(S).If these checks are not violated, the response is allowed to beloaded into a context in a different origin (i.e., not blocked).The procedure returns NULL if the response is blocked.
The CORB policy authors deﬁned a set of response MIME
types likely related to secrets, namely protected MIME types.The response having Content Type header value as a protectedMIME type is blocked. For instance, responses with ContentType headers related to images would not be blocked, yetresponses with Content Type headers related to JSON areblocked because web developers commonly use JSON seri-alized responses to conduct communication between frontendand backend.
Chromium team took a different approach to implement
CORB. Instead of strictly following the policy documentedat W3C [21], the team added extra measures to conﬁrm theMIME types by inspecting the response content [22]. Thismeasure is known as “conﬁrmation snifﬁng”. They claimedthat this could effectively reduce false positives (i.e., re-duce the cases when a legitimate response is blocked), thusincreasing the compatibility of Chromium with more webapplications [5]. For instance, as seen in Lines 6 and 7 inProcedure 1, if the response MIME type is related to JSON,which is in the protected MIME type list, but the contentin the response is an image, not a JSON, then Chromiumfollows the property of the content and does not block. Onthe other hand, Webkit strictly follows the policy and blocksthe response since it does not have such a measure [23].
III. B
ROWSER POLICY FUZZING
In this section we present CorbFuzz, which is a fuzzing
technique for checking browser security policies.
A. Fuzzing Algorithm
We present the architecture of CorbFuzz in Figure 1 and its
algorithm in Procedure 2. CorbFuzz is a distributed and multi-
threaded fuzzer that loops over all given web applications andcalls C
ORBFUZZTESTONE, which conducts coverage-guided
fuzzing for the given web application individually.
Initially, C ORBFUZZTESTONEcreates multiple instances
of the application runtime instrumented with data synthesisdiscussed in Section-IV. We deﬁne the runtime to be afunction P:(URL, Seed)→{ Metrics, R,M}, where SeedProcedure 1 Partial CORB Implementation in Chromium
1:procedure CORBCHECK (Response)
2: ifResponse.Scheme /∈{HTTP, HTTPS} then
3: return Response
4: mime←Response.ContentType
5: ifmime∈ProtectedMimeTypes then
6: ifmime∈JSON∧¬IsJSON(Response) then
7: return Response
8: ifmime∈XML∧¬IsXML(Response) then
9: return Response
10: else
11: return NULL
12: return Response
PHP Runtime
PHP Runtime
PHP RuntimePHP Runtime
Data SynthesisCoverage
BitmapCorpusMutatorRequestor
& Monitor
Coverage Guided FuzzerHTTP 
Req/Resp
Coverage 
Stream
Result Sink
Application Hosting Env. OraclePolicy OracleBrowser CORB
Impl.
Fig. 1. CorbFuzz Architecture
is an identiﬁer mapping to a state of the web application(i.e., database, cookies, and sessions), Metrics represents thecoverage metrics, R represents the resource queried by theweb application, and M maps each CORB implementation toits decision on whether to block the response. Analogous toa pipeline, the HTTP requests are ﬁrst passed to the runtimehosting web application and HTTP responses generated arethen served as inputs for different CORB implementations.
In C
ORBFUZZTESTONE, a bitmap is created so as to record
the coverage (Procedure 2, Line 6). C ORBFUZZTESTONE
additionally declares a result sink (Line 7) for storing theinformation required by the oracle. The details of the oracleare elaborated in the following sections. A corpus (Line 8)is also deﬁned as a list of pairs, where each pair containsthe URL of the request and the seed. Additionally, a listis declared (Line 9) for storing the URLs extracted fromthe HTTP response (e.g., href values and API calls). Duringfuzzing in C
ORBFUZZTESTONE, it randomly selects an input
from either corpus or unvisited links extracted (Line 9). Theinput contains a request URL and potentially a seed mappingto a state. Then, C
ORBFUZZTESTONEmutates and sends the
corresponding HTTP request and seed to the runtime (Lines10, 12). If the input leads to increased coverage, it is addedto the corpus (Lines 14-15).
After the fuzzing terminates (i.e., ShouldTerminate() returns
true), the oracle aggregates the information in result sink andprovides a decision for each HTTP response. These decisions
217Procedure 2 CorbFuzz Algorithm
1:procedure CORBFUZZ(TestBench)
2: forWebApplication ∈TestBench do
3: CORBFUZZTESTONE(WebApplication)
4:procedure CORBFUZZTESTONE(WebApplication)
5:P←DataSynthesis( WebApplication)
6: CovBitMap ←BitMap()
7: ResultSink ←HashTable()
8: Corpus←List[Pair]()
9: NewURL ←List()
10: Visited←Set()
11: for¬ShouldTerminate() do
12: U, Seed←(Corpus∪(NewURL - Visited)).Pop()
13: U, Seed←Mutate(U, Seed)
14: Visited+←U
15: Metrics, R, M ←P(U, Seed)
16: NewURL+←ExtractLinks()
17: ifIsNewCoverage(CovBitMap, Metrics) then
18: Corpus+←U, Seed
19: CovBitMap+←Metrics
20: ifIsUniqueResponse() then
21: ResultSink+←(R, M)
22: RunOracle(ResultSink)
are compared with the browser decisions to identify potential
weaknesses.
B. Policy Oracle
To deﬁne a policy oracle (i.e., RunOracle function in Pro-
cedure 2, Line 22), we need to categorize the response as con-
ﬁdential or non-conﬁdential by evaluating resource accesses.We limit the scope of resources to be only provided by thedatabase for this work. We use a method similar to Pellegrinoet al. [24] which deduces conﬁdentiality of a resource byobserving resource access frequency. After fuzzing terminatesfor each web application, we aggregate and count the numberof resources accessed by each database query executed whilehandling each request. In our implementation, we use theaverage number of accesses as our threshold. If any queryuses resources that have a frequency below the threshold, theoracle infers that the query is accessing a conﬁdential resource,of which the response should be blocked, and checks whetherthe CORB implementation blocked it.
The granularity of the resource impacts the result of the
oracle. For example, if each resource is considered as a table,oracle is more likely to decide to block the response than ifeach individual resource is considered as a row in the table.Hence, using a coarse-grain resource deﬁnition is more likelyto produce false positives. We designed two types of oracleswith different resource granularity. To reduce false positives,one oracle considers each unique row (i.e., query constraints)to be a resource, and to reduce false negatives, the other oracleconsiders each table to be a resource.C. Coverage Metrics
In C
ORBFUZZTESTONE, rather than focusing on test cov-
erage for the CORB function of the browser implementation,fuzzing is guided by test coverage for the given web appli-cation. While the coverage information of CORB functionmay enhance the fuzzing in regards to efﬁciency, it wouldnot be useful since CORB function is a small piece of codein both WebKit and Chromium. Thus, it is easy to achievehigh test coverage for the CORB function while focusing onachieving high test coverage for the given web application.Additionally, we are evaluating the policy for different codepatterns. Focusing on what CORB is able to handle wouldnot lead to identiﬁcations of potential weaknesses in theimplementation.
IV . D
ATA SYNTHESIS
In this section, we discuss our data synthesis techniques
that enable us to handle data-dependent web applicationsautomatically during fuzzing (i.e., during the execution of
C
ORBFUZZTESTONE), without the need for manual set up
of fuzzing targets. Instead of querying the database, the datasynthesis approach translates the query to constraints andgenerates the respective data. Additionally, the data synthesisapproach generates results for comparisons involving sessionsor cookies so as to achieve higher test coverage and bypassauthentication.
The data synthesis workﬂow depends on a seed that is gener-
ated and tracked by C
ORBFUZZTESTONE, ﬁrst mentioned in
Procedure 2, Line 13. A seed is a 32-bit integer sampled froma uniform distribution over [0,2
32−1]. There is a bijection
between the seed and the state of the database and a weakbijection between the seed and the cookies or sessions.
A. Query Constraint Extraction
We ﬁrst discuss the handling of database queries. The results
generated for a speciﬁc database query are constrained by three
measures: row count, table architecture, and constraint thatdescribes the resulting rows and columns from the query. Mostopen-source web applications either do not include a tableschema or require laborious work to set up the tables. Thus, weassume that the table schema is not given, and the generationof the database query result is run without the knowledge ofthe table architecture. For these, we respectively deﬁne threefunctions: M
AXROW,FIELDS ,CONSTRAINT . The input of
all these functions is a relational algebra expression translatedfrom the query.
M
AXROWprovides an estimation of the maximum rows
of the query result. It is implemented by considering the setoperators and LIMIT.
To reconstruct the table schema, the data synthesis approach
learns from the query by observing the ﬁeld names used insideit. We deﬁne the F
IELDS function, which produces a set of
pairs representing ﬁelds returned by the query. The ﬁrst partof the pair indicates the table name, and the second part is thename of the ﬁeld. The function is implemented by trackingthe rename, projection, and select operators. In the case that
2181<?php
2$conn =mysqli_connect(...);
3
4$res =$conn->query(
5 "SELECT *FROM AWHERE A.c =1"
6);
7
8$x=$res->fetch_assoc();
9
10$a=$x["a"];
11
12if($a == 0) echo 1;
Fig. 2. Example of PHP Application Database Call
a wildcard projection (i.e., asterisk) is used, the function
only returns the ﬁelds used throughout the relational algebraexpression, which could be a subset of ﬁelds returned if thequery is executed on the correct table schema. The missingﬁelds are addressed by F
IELD procedure in Procedure 3.
To ensure that the response generated using data synthesis
can be reproduced in the web application with real databasesettings, we additionally extract the constraints from the queryand generate a consistent result that conforms to these con-straints. For this, we deﬁne C
ONSTRAINTS function, which
outputs all the row-based and column-based constraints in therelational algebra expression for the SMT solver. We utilizea subset of translation rules proposed by Veanes et al. [25].Note that this function also assigns types to ﬁelds if the ﬁeldis compared with a concrete value in the select operator orreturned by set functions like COUNT.
We provide an example for the query in Line 5 of Figure 2
as input. The relational algebra expression for the query isSELECT
A . c=1 (A). Since there is no LIMIT operation inside
the query, the M AXROWoutputs that the maximum line is
inﬁnite. The F IELDS function produces a set with one pair:
{/angbracketleftA,c/angbracketright}. The C ONSTRAINTS function translates the condition
in the select operator to the SMT formula: (= A#c 1) and
assigns/angbracketleftA,c/angbracketrightto be of integer type.
The crucial procedures for the generation workﬂow are pre-
sented in Procedure 3. Before fuzzing starts in C ORBFUZZTE-
STONE(Line 5, Procedure 2), the I NITIALIZATION procedure
is executed. This procedure initiates three global hashtables forcaching. These are preserved throughout the runtime lifecycleand synchronized throughout all runtimes (since we use multi-threaded distributed fuzzing, this is necessary).
When a query is sent to the database, and the web applica-
tion is waiting for the response, A
DDprocedure replaces the
original code for sending the query and receiving the responsefrom the database. A
DDprocedure takes two arguments: the
query and the seed. If the cache contains the previous solutionfor the query and the seed, the cached result is returned.Otherwise, the query is parsed into relational algebra to extractconstraints, ﬁelds, and maximum length (as mentioned before),and an empty hashtable is returned. The hashtable, regardlessof whether there is a cache hit, is tracked and used by the webapplication as the output of the database query.
Procedure 3 Database Query Result Generation Algorithm
1:procedure INITIALIZATION
2: ConcreteResults ←HashTable()
3: Types←HashTable()
4: Cache←HashTable()
5:procedure ADD(Query, Seed)
6: ifCache(Query) = NULL then
7: ra←Parse(Query)
8: Cache(Query).L ←MAXROW(ra)
9: Cache(Query).F ←FIELDS (ra)
10: Cache(Query).C ←CONSTRAINTS (ra)
11: results←ConcreteResults(Query, Seed)
12: return Tracked(results)
13: procedure FIELD (Query, Seed, Name)
14: cache←Cache(Query)
15: r←ConcreteResults(Query, Seed)
16: ifName/∈cache.F then
17: Types(Query, Name) ←τ.AssignWeight(0)
18: r.F←cache.F+←Name
19: forﬁeld∈r.Fdo
20: ifﬁeld.Type = NULL then
21: τ←Types(Query, ﬁeld)
22: ﬁeld.Type ←Sample(τ )
23: len←Seed % cache.L
24: r←Solve(cache.C ∪¬cache.Solved(r.F, len), len)
25: ifr = UNSAT then return Abort()
26: cache.Solved(r.F, len)+←r
27: return Tracked(r(Name))
28: procedure NOTIFY (Query, Name, IType)
29:τ←Type(Query)(Name)
30:τ(IType)←τ(IType) + Weight
If the tracked hashtable is searched in the later executions
of the web application and the searched key corresponds toNULL value, the F
IELD procedure is called. In addition to the
query and the seed, this procedure takes an additional argu-ment: the name of the ﬁeld (i.e., the key of the hashtable thatthe application is searching for). F
IELD procedure assumes
that the web application code is correct and the queried ﬁeldmust exist. Under the circumstance that this speciﬁc ﬁeld nameis not inferred from the SQL query statement (e.g., a wildcardselect), F
IELD appends the ﬁeld name to the global cache so
that in the future, for this query, this speciﬁc ﬁeld would beconsidered. Before solving the constraints generated from theevaluation of the query, F
IELD ﬁrst probabilistically selects
a type from all possible data types for each ﬁeld, which isdiscussed in Section B. The number of rows is generated usingthe seed value. To avoid generating an identical result, F
IELD
appends constraints stating that the result to be solved shouldnot be equal to previously generated results under the samecondition (i.e., same type and same amount of row). If thesolver concludes these constraints could derive no result (i.e.,UNSAT), the web application immediately returns an internal
219error to abort the data synthesis workﬂow. However, this case
rarely happens in our experiments because constraints for SQLqueries are very permissive. The returned value of F
IELD
procedure is also tracked for type inference purposes, whichis described in the following section.
We demonstrate an example for the workﬂow over the PHP
application code listed in Figure 2. Before the execution ofany code, as soon as the runtime starts, the I
NITIALIZA -
TION procedure is called. Then, on Line 2, the code calls
mysqli_connect to establish a connection to MySQL
database. Inside the runtime, this function is replaced witha dummy method that always acts as if there is a successfulconnection. Then, the code is executed to send a query toMySQL database (Line 4) and wait for the response (Line8). Instead of sending the query, the runtime calls the A
DD
procedure. Suppose we are using a new seed, the procedurewould evaluate the query and return a traced empty hashtable.On Line 10, the hashtable is searched with a key a. Since the
hashtable is empty, the key points to NULL value. Instead ofreturning NULL, the F
IELD procedure is called to solve for
all the ﬁelds, including the ﬁeld searched by the application.
B. Type Inference
The knowledge of ﬁeld names is not enough to generate the
data. Correct type of each ﬁeld is also required for generating a
consistent result. Note that for types here, we are not referringto the actual type of a concrete value. Instead, we are referringto the inherent types. The inherent type is the same after typejuggling. Suppose an integer is cast as string in the application,we do not record this as string but instead as integer. Indeed,all ﬁelds in the result from the call mysqli_query are cast
as string, regardless of what the type is attributed to each ofthem in the table schema. Yet, they are directly used as theirinherent type throughout the execution in web applications,which is made possible by type juggling. Hence, for datasynthesis purposes, we need to infer the inherent types butnot the actual types.
We consider type information crucial because an inaccurate
type makes web applications prone to producing errors andunrealistic responses. For instance, deserializing an integer orinteger-like object would inevitably lead to errors. Anotherexample is that using a string as an index for an integer-indexed array does not lead to error but breaks the originallogic of the web application. This situation is unwanted inthis context because it produces a spurious response that isnot reproducible in an actual run of the web application usingthe real table schema.
In the query, we could gain type information for ﬁelds when
the operations processing or generating the ﬁeld are known andthe argument or return types are well-deﬁned. This is becausetype juggling in SQL would lead to an error or warning.For instance, a comparison between a ﬁeld and an integerwould help us conclude that the ﬁeld type must be integer.However, it is impossible to infer all types from evaluatingqueries. Thus, we additionally infer the type of ﬁelds by theinformation during the execution. Speciﬁcally, data synthesisruntime collects type information via two methods. First, ifthe ﬁeld encounters the binary comparison operand, CorbFuzzrecords the type of the concrete value it is comparing to.Second, CorbFuzz tracks the internal functions that the ﬁeldis served as an argument. Internal functions typically have aclear deﬁnition of the types of each argument. For simplicity,CorbFuzz ignores corner cases like comparison between twoﬁelds and passing to an internal function supporting all types.Future work may leverage Hindley-Milner algorithm [26] toconstruct a more ﬁne-grained typing system.
Still, the runtime analysis is not enough for inferring types
of all ﬁelds. Some of them may not be passed to an internalfunction or used in comparisons. Additionally, comparisonbetween variables of different types is allowed, and it isimpossible to deduce the inherent type of a concrete value.These factors mean there is a possibility that a different typeis used against the compared variable. To accommodate thesecases, we deﬁne a domain of types (τ ) for each ﬁeld and assign
a weight to any type t∈τ. At initialization, each tis set with
an initial weight and increased whenever it matches inference(e.g., passed to an internal function), which we refer to as atype hint, after the generation of the result. If query analysishas already assigned a type, then the type would have inﬁniteweight in τ. Before constraint solving is initiated, CorbFuzz
conducts a probabilistic sampling from τfor each ﬁeld based
on weights assigned to types (the probability of a type tobe chosen is proportional to the weight of the type). Due toprobabilistic selection, a variety of types are explored duringfuzzing. Here, we assume that if a type for a variable is notintended, then this incorrect type used would lead to eithererrors or no effect on analysis. In general, CorbFuzz tries toincrease the likelihood that a correct type will be used.
In Procedure 3, F
IELD procedure conducts a probabilistic
sampling over the τfor each ﬁeld (Line 19-22). In our
implementation, we utilize A-res algorithm [27]. N OTIFY
procedure is called when the tracked value returned by F IELD
procedure is used in internal functions or for comparison. Thetype hint is then used to increase the weight for that typeinτ. In our implementation, we only let τinclude integers,
strings, and booleans. Type hints for types that are not in τ
are ignored.
In the example provided in Figure 2 Line 10, after the F
IELD
procedure ends, $ais assigned the generated value that is
tracked. On Line 12, the tracked value is compared to aninteger. The N
OTIFY procedure is called, adding weight for
the integer type for the ﬁeld ain global hashtable Types.
C. Authentication Bypass Workﬂow
Cookies and sessions are commonly leveraged by web
applications to make HTTP requests stateful [6], [28], allowingfor the implementation of authentication. Both of them couldbe represented as a hashtable. We observed that there couldbe a signiﬁcant increase in coverage for a web applicationif cookies or sessions are properly set (e.g., an authenticationtoken presents for a speciﬁc ﬁeld). It is because complex logicinside web applications tends to be reached after the request
2201<?php
2session_start();
3
4if(isset($_SESSION["is_auth"]))
5 echo $_SESSION["welcome_message"];
Fig. 3. Example of PHP Application Session Usage
presents to be authenticated or authorized. Usually, cookies
or sessions keys and values are compared to a constant or aresult from the database. Therefore, using a fuzzer to explorecookies and sessions is largely ineffective since there is a hugesearch space for the keys and values.
To better explore behaviors of web applications, we generate
decisions for comparison operations that involve sessions orcookies. Still, we conduct concolic execution and recordthe constraints for the decisions made to check whether alldecisions made are satisﬁable. CorbFuzz treats each item insession or cookie as a pair of symbolic variables: /angbracketleftφ,α/angbracketright, where
φis the gated boolean symbolic variable that shows whether
the item is deﬁned and αrepresents the symbolic variable
for the item. This method is inspired by hybrid fuzzing butdiffers from it. The runtime only solves the constraint onetime when necessary. That is, if an item of cookies or sessionshas not been passed to an operation that does not have anSMT formula translation available, the value would never begenerated.
The reason we do not generate the data as soon as it is used
is largely due to the use cases of sessions and cookies. Theyare used in multiple or nested branches, but most of the time,their concrete value would not be evaluated. Additionally, thereare very few internal functions that commonly use sessionsor cookies as arguments. We have implemented only basicarithmetic and isset [29] internal call with the translation
of the SMT formula. Still, most requests in our experimentdo not require generating the concrete value of sessions andcookies.
We have shown the crucial components for the workﬂow in
Procedure 4 for session, which is identical for cookie. Similarto the previous workﬂow for database, there is also an initial-ization procedure that creates a global hashtable for caching.Speciﬁcally, GCis for storing the mapping between seed and
the sessions. Additionally, there is a S
TART procedure, which
is called before each HTTP request is handled and the variabledeclared only survives during the lifecycle of that request. Theprocedure creates a copy of the seed and declares a hashtablefor saving the constraints for each session item used duringthe request.
When an item of sessions is compared with a concrete value,
the D
Oprocedure is used before evocation of the original
comparison handler. CorbFuzz ﬁrst checks whether there isalready a cached item for the given seed (Line 7). If there isa cache hit, then the item is assigned a concrete value, andthe internal implementation of the comparison operation is ex-ecuted. Otherwise, CorbFuzz checks whether the comparisonProcedure 4 Session Generation Algorithm
1:procedure INITIALIZATION
2: GC←HashTable()
3:procedure START
4: RCache←HashTable()
5: NewSeed ←Copy(Seed)
6:procedure DO(Name, Opline)
7: ifGC(Seed, Name) then
8: Session(Name) ←GC(Seed, Name)
9: return Next()
10: ifOpline.Operand ∈ImplementedOp then
11: decision←NewSeed & 1
12: ShiftRight(NewSeed)
13: cons←ToConstraint(Opline, decision)
14: if¬IsSAT(RCache(Name) ∪cons) then
15: return DO(Name, Opline)
16: RCache(Name)+←cons
17: return decision
18: else
19: solved←Subset(GC(*, Name))
20: cons←RCache(Name) ∪¬solved
21: if¬IsSAT(cons) then return Abort()
22: GC(Seed, Name) ←Solve(cons)
23: return DO(Name, Opline)
operation is implemented (Line 10) so that it could convert thedecision of the operation to a constraint. If so, a decision isgenerated from the seed, and the constraint for performingthis decision is appended to the constraints over that item(Lines 11-13). An SMT solver is then used to check whetherthe constraint is satisﬁable (Line 14). If it is not satisﬁable,then the procedure recursively consumes the seed until there isa decision that could be satisﬁed. Our implementation assumesthere are at most 32 decisions since we are using a 32-bitseed. In our experiments, the maximum consumption is only11 bits in a speciﬁc request. The decision is then returned, andthe internal implementation of the comparison is ignored. Asfor the corner case that a session item is compared to anothersession item, we treat this comparison as an unimplementedoperation for one side and then apply the workﬂow to the otherside. When the operation is not implemented, then a concretevalue is generated by solving the constraint for that item. Toensure the uniqueness of the concrete value generated, thesolver tries to avoid generating already solved values storedin the global cache for that ﬁeld name. To reduce UNSATcases, D
Oonly selects a random subset of the stored values
in the cache and removes them from consideration as theresult of solving (Line 19). Note that by doing so, we do notcreate a strict bijection here between the seed and the sessions.Same sessions may map to multiple seeds. This is because theconstraints here are not permissive.
For PHP code listed in Figure 3, when it executes until
Line 4, CorbFuzz ﬁrst declares a pair of symbolic variables/angbracketleftφ
0,α0/angbracketrightand makes a decision for the unary comparison
221isset based on the seed. Suppose the seed indicates the
decision is to return true, then the constraint φ0=true is added
to the set of constraints for the $_SESSION["is_auth"].
Note that this session item is not used later, so its concrete
value is never generated. Then, on Line 5, another sessionitem is used. We have not implemented echo function and
the value of $_SESSION["welcome_message"] is gen-
erated with respect to its constraints (i.e., no constraint in thiscontext).
In certain cases, the data stored in the cookies or sessions
may be subject to decryption or deserialization in web appli-cations. Before a decryption or decoding function is executedwith input from cookies or sessions, the workﬂow mustsynthesize the concrete value. This situation is undesirablebecause authentication cannot be bypassed. A more generalversion of this issue, which is that symbolic execution failsto model a comprehensive list of syscalls, also plagues hybridfuzzing [30], and no solution has been proposed so far. Wediscuss a potential ad-hoc solution and future work to addressthis problem in Section V-B.
D. Adapting to Other Programming Languages
The aforementioned methods target PHP applications. How-
ever, they can be extended to other programming languages
that are widely used for web application development. Specif-ically, the data synthesis workﬂows embedded with typeinference can be applied to other programming languagessupporting type juggling, like Perl or JavaScript/NodeJS, orusing a dynamic type system, like Ruby and Python. Forstatically typed programming languages, like Golang or Java,the type inference component would not be needed, but thedata synthesis workﬂows can similarly be adapted.
V. I
MPLEMENTATION &E V ALUATION
We have implemented the coverage-guided fuzzer and or-
acle for CorbFuzz in Python with 900 lines of code (LoC)for fuzzing web applications written in PHP. Unlike existingweb application fuzzers that only consider responses relatedto PHP, CorbFuzz considers all responses after a web pageis loaded, including images, CSS, and RPC communications.The data synthesis workﬂow is implemented as an externalmodule with 500 LoC in C and 1200 LoC in NodeJs forPHP. PHP 7.4 has been instrumented to support the workﬂowand provide branching information for coverage evaluation. Toallow for fair evaluation on data synthesis effectiveness, weimplement two baseline workﬂows by removing componentsinside CorbFuzz.
In the following subsections, we address the following
research questions;
RQ1. Is data synthesis workﬂow generating consistent data?
RQ2. Can data synthesis workﬂow increase test coverage?
RQ3. Can CorbFuzz detect bugs in implementation in existing
browsers?LoC Range Number of Applications Average LoC
Less than 1K 15 476.9
Between 1K and 10K 15 3022.5
Between 10K and 100K 6 43075.5
More than 100K 3 250875.5
TABLE I
TOTAL LOCS TATISTICS FOR FUZZING TARGETS
A. Experimental Setup
1) Environment: We evaluate CorbFuzz on two Intel Xeon
Phi 7210 (64 cores) nodes. Both nodes use Ubuntu 20.04 with
one node running NGINX [31] for serving web application onthe instrumented PHP environment and other node running thecoverage-guided fuzzer.
2) Targets: We evaluate CorbFuzz with two popular web
browsers: Chromium and WebKit (Safari). Chromium hasalready added CORB into its current stable release. We im-plement a test harness based on the Chromium shared librarycontaining the CORB implementation. For WebKit, the devel-opers have created a pull request for CORB implementationbut it has not yet been merged into the main branch. Since itsimplementation is relatively simple and straightforward, wedirectly translate it into Python to implement a test harnessfor CORB implementation of Webkit.
3) Web Applications: Web applications are fuzzed to pro-
vide responses as input for browser policy test harnesses. Wecrawled 300 repositories containing PHP code from GitHubbetween March 2nd, 2021 and April 10th, 2021. The reposi-tories are ﬁltered out if they do not contain index.php or
index.html. For simplicity, we do not consider applicationsthat require downloading dependencies with Composer [32],a dependency management tool. The number of remainingapplications is 58 with varying LoCs. We fuzz the policieswith these 58 applications but for the sake of evaluation ofdata synthesis effectiveness, we only use 39 of them, forwhich CorbFuzz reports existence of branches and utilizationof databases. The statistics of these applications are presentedin Table I.
B. Data Synthesis Effectiveness
To evaluate the data synthesis approach and address RQ1,
we ran CorbFuzz with and without type inference for three
minutes
1with each web application. We compared the per-
centage of correct type generations by tracking whether thegenerated value matches the type of (1) a concrete value whencompared to it; (2) the deﬁned argument when used to callinternal function. Figures 4 and 5 demonstrate the percentageof correct generations for comparison statements and internalfunction calls respectively. Figure 4 shows that for 10 appli-cations, CorbFuzz generates the correct type for comparisonsmore often than CorbFuzz without type inference with 17%more data generations with correct type on average. Figure 5shows that for 11 applications, CorbFuzz generates the correcttype for internal function calls more often than CorbFuzz
1Due to the randomness feature of the fuzzer, we ran each experiment ﬁve
times and take maximum value (e.g., edge coverage).
222Fig. 4. The percentage of correct type generation for comparison statements
for CorbFuzz and CorbFuzz without Type Inference for 3 minutes of fuzzing.X axis denotes the web application ID.
Fig. 5. The percentage of correct type generation for internal function callsfor CorbFuzz and CorbFuzz without Type Inference for 3 minutes of fuzzing.X axis denotes the web application ID.
without type inference with 5% more data generations with
correct type on average.
On some applications, CorbFuzz has little improvement on
the accuracy of type generation because in the results we show,we consider all type violations. However, many of these typeviolations are due to developers using type juggling and notdue to data synthesis. Therefore, these violations cannot beremoved by improving type inference in data synthesis.
We also evaluated the impact of data synthesis on fuzzing
effectiveness and address RQ2. Figure 6 demonstrates the
edge coverage difference, in terms of percentages, of edgecounts between CorbFuzz without any type inference andauthentication bypass, and CorbFuzz. For this evaluation, weonly chose applications containing more than one branch.Figure 6 shows that for almost all applications, the inclusion oftype inference and authentication bypass improves coverage.The average number of edges covered is 16.2 edges forCorbFuzz without type inference and authentication bypassFig. 6. The percentage of edges covered for CorbFuzz without Type Inference
and Authentication Bypass in 3 minutes of fuzzing against edges covered byCorbFuzz. X axis denotes the web application ID.
and 27.5 for CorbFuzz. These results demonstrate that with
the inclusion of type inference and authentication bypass, wecan cover on average 70% more edges, which shows theeffectiveness of our data synthesis approach.
The number of edges covered is low for some applications
because these applications (e.g., WordPress) save and usestructural, encrypted, or serialized data from the databaseor cookie. The data synthesis workﬂow is unaware of thestructural property of any ﬁeld. Therefore, it generates a largeamount of data that can not be deserialized or decrypted bythe web application, so CorbFuzz fails to explore these webapplications. However, we recognize that this can be preventedby enlarging the domain of type τdeﬁned. By considering the
common structural properties as types (e.g., JSON type) andinstrumenting deserialization libraries to provide type hints,future work could implement an approach that is able to furtherimprove web application coverage.
C. Detected CORB Weaknesses
In evaluation of RQ3, we have discovered three common
classes of code patterns, which are discussed in following
sections, that cause the CORB implementation in Chromium tonot function as expected. One of the cases has been ﬁled in theChromium bug tracker before our discovery by a Chromiumdeveloper and is still in discussion
2. We have reported another
case3, which has later been resolved by a patch in the CORB
component of Chromium4.
All the weaknesses discovered are due to the novel fuzzing
approach we present in this paper. The weaknesses are notpresent in every web application but only in a few of them.Fuzzing a single web application would likely not lead to thediscovery of any of the weaknesses, while fuzzing multipleweb applications without the data synthesis would require
2https://crbug.com/795470
3https://crbug.com/1148397
4https://chromium-review.googlesource.com/c/chromium/src/+/2596879/
223Left Brace
OtherwiseStart Quotation
OtherwiseLeft
Brace Control characters
QuotationLeft
Quote
Control characters
EscapeWhitespace
Not
JSON
Is
JSON
Otherwise
Right
Quotewhitespace\WhitespaceOtherwise
Colon
Fig. 7. Finite State Machine for Validating JSON
setting up the database and seeding the tables for numerous
web applications, which is infeasible. Data synthesis allows usto effortlessly fuzz multiple web applications by symbolicallyevaluating database queries. Additionally, all the web appli-cation states that lead to the aforementioned weaknesses areunder some extent of authentication or authorization. Withouta manual deﬁnition of the login method for a web application,the fuzzer would not discover these weaknesses. Yet, manuallydeﬁning authentication or authorization method for a consid-erable number of applications is tedious and unrealistic. Incontrast to the manual approach, the data synthesis approachwe present automatically generates appropriate sessions andcookies items, which allows exploration using authorizedrequests.
Serialized Array as JSON Response. In Chromium, if the
response MIME type is related to JSON, CORB would checkthe response content to learn whether it is indeed JSON. Aﬁnite state machine (FSM) conducts such a check. As illus-trated in Figure 7, the FSM does not comprehensively parsethe response content to perform the check. Instead, it onlychecks whether the content has a left brace at the beginningand has matching quotes for the ﬁrst key to determine if thecontent is JSON.
As permissive as it is, such a check would not identify a
serialized array in JSON format, which is considered a JSONobject inside the JavaScript runtime of Chromium. Indeed,the latest JSON speciﬁcation (RFC 8259 [33]) refers thisto be a different type from JSON object known as JSONarray. For instance, for a simple response as [1,2,3],a
JSON array, JSON check in CORB implementation wouldﬁrst look for the left brace. Yet, the ﬁrst character is leftbracket, which makes the FSM classify the content as notJSON. However, fetch, XMLDocument, and JSON.parse
APIs in JavaScript runtime parse the content into a JavaScriptobject without warning.
Sending JSON arrays as responses is commonly seen in web
application APIs. The responses of these APIs would likelycarry sensitive information. Thus, we consider catching JSONarray for JSON MIME type in CORB implementation to be areasonable patch.
Malformed JSON Response. It is not uncommon for web
application developer to adopt the following code pattern,where $var represents any variable the attacker can control
(i.e., a tainted variable), which could be achieved throughmethods including URL manipulation and security-unrelatedCSRF [34].
1<?php
2header(’Content-Type: application/json’);
3echo "{\"$var\":\"$secret\"}";
This code pattern does not leverage the existing serialization
library. Instead, it produces serialized objects by direct stringconcatenation and manipulation. If the attacker is able tocontrol at least one character in the ﬁrst key of a JSON object,they would be able to bypass the CORB check by makingthat key contain a control character. According to JSONspeciﬁcation, control characters (U+0000 through U+001F)inside key and value of JSON object should be escaped(i.e., append a reverse solidus before the control character).Similarly, the JSON veriﬁer inside CORB implementation inChromium follows this pattern and rejects all JSON objectswith unescaped control characters on the ﬁrst key.
Consider the PHP code shown above. If we set $var to be
the control character \u0017, the resulting response becomes
{"\u0017": "[SECRET]",[MORE SECRETS]}. TheJSON checker FSM enters the state “Left Quote” afterencountering the ﬁrst and second characters. It then comparescharacter \u0017 to control character range and identiﬁes it
as an unescaped control character, misclassifying the responseas not JSON.
We consider this weakness should be addressed as the
existence of such a code pattern is not negligible. We havereported this to the Chromium team, and it has been ﬁxedby removing the check for control character inside the JSONchecker.
The discovery of this weakness is only possible if the
fuzzer can mutate the database state efﬁciently. In all the casesthat lead to this malformed JSON response, the variable asthe key of the JSON array is retrieved from the database.CorbFuzz symbolically evaluates the database queries andsynthesizes the concrete value for that variable, which allowsthe efﬁcient exploration of the domain of this variable (i.e.,exploring interesting values for UTF-8 character). In contrast,a conventional fuzzing approach has to mutate the databasestate by sending requests to the web application or by resettingthe database, leading to signiﬁcantly larger search spaces andhigh timing overhead for mutating the content of the variablederived from the database.
Conﬁrmation Snifﬁng. In most web applications, warnings
and errors in plaintext or HTML are directly prepended to theresponse. For PHP, a warning in HTML is generated wheneveran undeﬁned behavior happens. If a malicious actor is able totrigger an undeﬁned behavior in responses that are checkedwith conﬁrmation snifﬁng, then CORB in Chromium could
224be bypassed since the responses start with data that is not of
their MIME type.
This weakness, including all previous weaknesses, could
be considered as the side effect of increase in permissivenesscaused by conﬁrmation snifﬁng. We consider that conﬁrmationsnifﬁng is harming the effectiveness of the CORB implemen-tation in Chromium. Future work, on the other hand, couldwork on testing the contribution of conﬁrmation snifﬁng oncompatibility and conclude whether conﬁrmation snifﬁng isindeed redundant.
D. Fuzzer Flexibility
We have constructed an oracle for ORB and test the
proposed implementation. Our fuzzer is unable to discover
any weakness of ORB. It is because ORB applies a whitelistapproach to block requests yet CORB uses a blacklist, whichmeans ORB is much less permissive than CORB. Future workcould apply similar approach to evaluate its compatibility.
VI. R
ELATED WORK
Coverage-guided Fuzzing. Coverage-guided fuzzing has
been used to ﬁnd bugs in different types of programs, such asvirtual machines [35], web browsers [36], [37], network func-tions [38], [39], and operating systems [40], [41]. The state-of-the-art implementations are AFL [42] and libFuzzer [43].In this paper, we leveraged coverage-guided fuzzing to exploreresponses from web applications for browser security policychecking. Yet, our approach is not using the coverage of thebrowser but is instead guided by the coverage of the webapplications. Our approach also conducts a series of coverage-guided fuzzing with different targets instead of fuzzing anindividual program.
Browser Fuzzing. Domato [44], Dharma [45], and Free-
Dom [36] are all specialized fuzzers used to discover memory-related vulnerabilities and assertion violations in DOM im-plementation of browsers. They generate structural data thatcontain valid HTML, CSS, and DOM-related JavaScript forbrowsers to render. Fuzzilli [37] and Jsfunfuzz [46] are fuzzersfor discovering vulnerabilities in JavaScript engines, whichutilize a similar approach to generating structural data. Ourwork is different from all these approaches since the oracleof CorbFuzz is deﬁned based on the property of the webapplications, and CorbFuzz does not generate the test casesbut instead utilizes web applications’ responses. Roy et al. [47]fuzzes web applications and supplies responses to browsers todetect visual inconsistencies between browsers. It is similar toour work in the sense that both works treat web applicationsand browsers together as a black box. Unlike their work whichfocuses on testing web applications, our work focuses ontesting security policies in browsers. We also do not cross-reference between browsers but use an oracle instead.
Web Application Testing. Alshahswan et al. [7] and Biagi-
ola et al. [8] propose search-based approaches to testing webapplications. Both works use metaheuristic approaches suchas genetic algorithms to explore and generate different inputsto extensively test web applications. Different from our work,[7] requires the input types and login information. [8] requiresPage Objects to be provided to test the web application. Ourwork instead avoids manual analysis through data synthesis.Elbaum et al. [48] proposes that web application testing shouldmutate the sessions and provides a few mutation techniquesthat could help achieve better coverage. Data synthesis in ourwork is different than the work of Elbaum et al. since we donot mutate the sessions but instead symbolically evaluate orgenerate them. Apollo [49] and Wassermann et al. [50] lever-age concolic testing to increase coverage of web applicationsand to discover vulnerabilities. Session generation workﬂowin our data synthesis approach is utilizing concolic execution,but it is fundamentally different than the concept of concolictesting.
VII. C
ONCLUSION
We have created a browser policy fuzzer CorbFuzz which
uses web application responses to fuzz the browser securitypolicies. To avoid setting up the web applications manually, weproposed a web application runtime that synthesizes data. Theresources queried by the web application are either generatedor symbolically represented. We have shown that the datasynthesis approach not only generates consistent data but alsoincreases test coverage for web applications. We have evalu-ated CorbFuzz on CORB implementations of Chromium andWebKit as well as ORB proposal for Firefox. By fuzzing with58 applications, we discovered three classes of weaknesses inCORB implementation of Chromium.
R
EFERENCES
[1] V . Hailperin, “Cross-Site Script Inclusion.” [Online]. Available:
https://www.scip.ch/en/?labs.20160414
[2] J. Grossman, S. Fogie, R. Hansen, A. Rager, and P. D. Petkov, XSS
attacks: cross site scripting exploits and defense. Syngress, 2007.
[3] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Ham-
burg, M. Lipp, S. Mangard, T. Prescher et al., “Spectre attacks: Exploit-
ing speculative execution,” in 2019 IEEE Symposium on Security and
Privacy (SP). IEEE, 2019, pp. 1–19.
[4] M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, A. Fogh, J. Horn,
S. Mangard, P. Kocher, D. Genkin, Y . Yarom, and M. Hamburg,
“Meltdown: Reading kernel memory from user space,” in 27th
USENIX Security Symposium, USENIX Security 2018, Baltimore, MD,USA, August 15-17, 2018., 2018, pp. 973–990. [Online]. Available:https://www.usenix.org/conference/usenixsecurity18/presentation/lipp
[5] “Cross-Origin Read Blocking (CORB).” [Online].
Available: https://chromium.googlesource.com/chromium/src/+/master/services/network/cross
origin read blocking explainer.md
[6] Y .-F. Li, P. K. Das, and D. L. Dowe, “Two decades of web
application testing—a survey of recent advances,” Information
Systems, vol. 43, pp. 20–54, 2014. [Online]. Available: https://www.sciencedirect.com/science/article/pii/S0306437914000271
[7] N. Alshahwan and M. Harman, “Automated web application testing
using search based software engineering,” in 2011 26th IEEE/ACM
International Conference on Automated Software Engineering (ASE2011). IEEE, 2011, pp. 3–12.
[8] M. Biagiola, F. Ricca, and P. Tonella, “Search based path and input data
generation for web application testing,” in International Symposium on
Search Based Software Engineering. Springer, 2017, pp. 18–32.
[9] J. Schwenk, M. Niemietz, and C. Mainka, “Same-origin policy:
Evaluation in modern browsers,” in 26th USENIX Security Symposium
(USENIX Security 17). Vancouver, BC: USENIX Association,Aug. 2017, pp. 713–727. [Online]. Available: https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/schwenk
225[10] B. Gulmezoglu, A. Zankl, T. Eisenbarth, and B. Sunar, “Perfweb: How
to violate web privacy with hardware performance events,” Computer
Security – ESORICS 2017, p. 80–97, 2017.
[11] S. Jana and V . Shmatikov, “Memento: Learning secrets from process
footprints,” 2012 IEEE Symposium on Security and Privacy, 2012.
[12] H. Kim, S. Lee, and J. Kim, “Inferring browser activity and status
through remote monitoring of storage usage,” Proceedings of the 32nd
Annual Conference on Computer Security Applications, 2016.
[13] S. Lee, Y . Kim, J. Kim, and J. Kim, “Stealing webpages rendered on
your browser by exploiting gpu vulnerabilities,” 2014 IEEE Symposium
on Security and Privacy, 2014.
[14] R. Spreitzer, S. Griesmayr, T. Korak, and S. Mangard, “Exploiting
data-usage statistics for website ﬁngerprinting attacks on android,”
Proceedings of the 9th ACM Conference on Security &; Privacy inWireless and Mobile Networks, 2016.
[15] S. Karami, P. Ilia, and J. Polakis, “Awakening the web’s sleeper
agents: Misusing service workers for privacy leakage,” Proceedings 2021
Network and Distributed System Security Symposium, 2021.
[16] P. Kocher, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp,
S. Mangard, T. Prescher, M. Schwarz, and Y . Yarom, “Spectre attacks:Exploiting speculative execution,” CoRR, vol. abs/1801.01203, 2018.
[Online]. Available: http://arxiv.org/abs/1801.01203
[17] C. Reis, A. Moshchuk, and N. Oskov, “Site isolation: Process separation
for web sites within the browser,” in Proceedings of the 28th USENIX
Conference on Security Symposium, ser. SEC’19. USA: USENIXAssociation, 2019, p. 1661–1678.
[18] “Site Isolation - The Chromium Projects.” [Online]. Available:
https://www.chromium.org/Home/chromium-security/site-isolation
[19] “CVE - CVE-2020-6442.” [Online]. Available: https://cve.mitre.org/
cgi-bin/cvename .cgi?name=CVE-2020-6442
[20] “Issue 1013906: Security: expose stored (in cache) cross-site
response’s size.” [Online]. Available: https://bugs.chromium.org/p/chromium/issues/detail?id=1013906
[21] “Fetch Standard.” [Online]. Available: https://fetch.spec.whatwg.org/
#corb
[22] “MIME Snifﬁng Standard.” [Online]. Available: https://
mimesniff.spec.whatwg.org/
[23] “185331 – Cross-Origin Read Blocking (CORB).” [Online]. Available:
https://bugs.webkit.org/show
bug .cgi?id=185331
[24] G. Pellegrino, M. Johns, S. Koch, M. Backes, and C. Rossow, “Deemon:
Detecting csrf with dynamic analysis and property graphs,” 2017.
[25] M. Veanes, J. d. Halleux, N. Tillmann, and P. de Halleux,
“Qex: Symbolic sql query explorer,” Tech. Rep. MSR-TR-2009-2015, October 2009, updated January 2010. [Online].Available: https://www.microsoft.com/en-us/research/publication/qex-symbolic-sql-query-explorer/
[26] R. Milner, “A theory of type polymorphism in programming,” Journal
of Computer and System Sciences, vol. 17, no. 3, pp. 348–375, Dec.1978. [Online]. Available: https://linkinghub.elsevier.com/retrieve/pii/0022000078900144
[27] J. S. Vitter, “Random sampling with a reservoir,” ACM Transactions on
Mathematical Software, vol. 11, no. 1, pp. 37–57, Mar. 1985. [Online].Available: https://dl.acm.org/doi/10.1145/3147.3165
[28] M. Johns, S. Lekies, B. Braun, and B. Flesch, “Betterauth: Web
authentication revisited,” in Proceedings of the 28th Annual Computer
Security Applications Conference, ser. ACSAC ’12. New York,NY , USA: Association for Computing Machinery, 2012, p. 169–178.[Online]. Available: https://doi.org/10.1145/2420950.2420977
[29] “isset - php manual.” [Online]. Available: https://www.php.net/manual/
en/function.isset.php
[30] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y . Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmentingfuzzing through selective symbolic execution.” in NDSS, vol. 16, 2016,
pp. 1–16.
[31] “NGINX |High Performance Load Balancer, Web Server, & Reverse
Proxy.” [Online]. Available: https://www.nginx.com/
[32] “Composer.” [Online]. Available: https://getcomposer.org/
[33] “The javascript object notation (json) data interchange format.”
[Online]. Available: https://tools.ietf.org/html/rfc8259
[34] A. Shankar (D1r3Wolf), “Chaining No impact(N/A) Bugs to get
High impact.” [Online]. Available: https://blog.d1r3wolf.com/2020/04/
chaning-no-impactna-bugs-to-get-high.html
[35] T. Brennan, S. Saha, and T. Bultan, “Jvm fuzzing for jit-induced side-
channel detection,” in Proceedings of the ACM/IEEE 42nd InternationalConference on Software Engineering, ser. ICSE ’20. New York, NY ,USA: Association for Computing Machinery, 2020, p. 1011–1023.[Online]. Available: https://doi.org/10 .1145/3377811.3380432
[36] W. Xu, S. Park, and T. Kim, “FREEDOM: Engineering a State-of-
the-Art DOM Fuzzer,” in Proceedings of the 2020 ACM SIGSAC
Conference on Computer and Communications Security. VirtualEvent USA: ACM, Oct. 2020, pp. 971–986. [Online]. Available:https://dl.acm.org/doi/10.1145/3372297.3423340
[37] “Fuzzilli - A JavaScript Engine Fuzzer,” Apr. 2021, original-
date: 2019-03-20T15:32:47Z. [Online]. Available: https://github.com/googleprojectzero/fuzzilli
[38] A. Shukla, K. N. Hudemann, A. Hecker, and S. Schmid, “Runtime
veriﬁcation of p4 switches with reinforcement learning,” in Proceedings
of the 2019 Workshop on Network Meets AI & ML, ser. NetAI’19.New York, NY , USA: Association for Computing Machinery, 2019, p.1–7. [Online]. Available: https://doi.org/10.1145/3341216.3342206
[39] C. Shou, “Porkfuzz: Testing stateful software-deﬁned network
applications with property graphs,” in Proceedings of the 29th
ACM Joint Meeting on European Software Engineering Conferenceand Symposium on the F oundations of Software Engineering,ser. ESEC/FSE 2021. New York, NY , USA: Association forComputing Machinery, 2021, p. 1660–1662. [Online]. Available:https://doi.org/10.1145/3468264.3473487
[40] S. Kim, M. Xu, S. Kashyap, J. Yoon, W. Xu, and T. Kim, “Finding
semantic bugs in ﬁle systems with an extensible fuzzing framework,”inProceedings of the 27th ACM Symposium on Operating Systems
Principles. Huntsville Ontario Canada: ACM, Oct. 2019, pp. 147–161.[Online]. Available: https://dl.acm.org/doi/10.1145/3341301.3359662
[41] K. Kim, D. R. Jeong, C. H. Kim, Y . Jang, I. Shin, and B. Lee,
“HFL: Hybrid Fuzzing on the Linux Kernel,” in Proceedings
2020 Network and Distributed System Security Symposium . San
Diego, CA: Internet Society, 2020. [Online]. Available: https://www.ndss-symposium.org/wp-content/uploads/2020/02/24018.pdf
[42] lcamtuf, “American Fuzzy Lop.” [Online]. Available: http:
//lcamtuf.coredump.cx/aﬂ/
[43] K. Serebryany, “libFuzzer, a library for coverage-guided fuzz testing,”
LLVM project, 2015.
[44] “Domato - DOM fuzzer,” Apr. 2021, original-date:
2017-09-21T15:28:59Z. [Online]. Available: https://github.com/googleprojectzero/domato
[45] “Dharma - Generation-based, context-free grammar fuzzer.” Apr.
2021, original-date: 2015-03-25T17:56:23Z. [Online]. Available: https://github.com/MozillaSecurity/dharma
[46] “A collection of fuzzers in a harness for testing the SpiderMonkey
JavaScript engine.” Apr. 2021, original-date: 2015-07-08T01:05:26Z.[Online]. Available: https://github. com/MozillaSecurity/funfuzz
[47] S. Roy Choudhary, M. R. Prasad, and A. Orso, “X-pert: a web
application testing tool for cross-browser inconsistency detection,” inProceedings of the 2014 International Symposium on Software Testingand Analysis, 2014, pp. 417–420.
[48] S. Elbaum, S. Karre, and G. Rothermel, “Improving web application
testing with user session data,” in 25th International Conference on
Software Engineering, 2003. Proceedings., 2003, pp. 49–59.
[49] S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. Paradkar, and
M. D. Ernst, “Finding bugs in dynamic web applications,” inProceedings of the 2008 International Symposium on Software Testingand Analysis, ser. ISSTA ’08. New York, NY , USA: Associationfor Computing Machinery, 2008, p. 261–272. [Online]. Available:https://doi.org/10.1145/1390630.1390662
[50] G. Wassermann, D. Yu, A. Chander, D. Dhurjati, H. Inamura, and
Z. Su, “Dynamic test input generation for web applications,” inProceedings of the 2008 International Symposium on Software Testingand Analysis, ser. ISSTA ’08. New York, NY , USA: Associationfor Computing Machinery, 2008, p. 249–260. [Online]. Available:https://doi.org/10.1145/1390630.1390661
226