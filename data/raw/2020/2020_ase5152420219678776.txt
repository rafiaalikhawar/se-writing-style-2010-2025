An Empirical Study of Bugs in
WebAssembly Compilers
Alan Romano
University at Buffalo, SUNY
alanroma@buffalo.eduXinyue Liu
University at Buffalo, SUNY
xliu234@buffalo.eduYonghwi Kwon
University of Virginia
yongkwon@virginia.eduWeihang Wang
University at Buffalo, SUNY
weihangw@buffalo.edu
Abstract ‚ÄîWebAssembly is the newest programming language
for the Web. It deÔ¨Ånes a portable bytecode format for use
as a compilation target for programs developed in high-level
languages such as C, C++, and Rust. As a result, WebAssembly
binaries are generally created by WebAssembly compilers rather
than being written manually. To port native code to the Web,
WebAssembly compilers need to address the differences between
the source and target languages and dissimilarities in their
execution environments. A deep understanding of the bugs in
WebAssembly compilers can help compiler developers determine
where to focus development and testing efforts. In this paper, we
conduct two empirical studies to understand the characteristics
of the bugs found in WebAssembly compilers. First, we perform
a qualitative analysis of bugs in Emscripten, the most widely-
used WebAssembly compiler. We investigate 146 bug reports in
Emscripten related to the unique challenges WebAssembly com-
pilers encounter compared with traditional compilers. Second,
we provide a quantitative analysis of 1,054 bugs in three open-
source WebAssembly compilers, AssemblyScript, Emscripten,
and Rustc/Wasm-Bindgen. We analyze these bugs along three
dimensions: lifecycle, impact, and sizes of bug-inducing inputs
and bug Ô¨Åxes. These studies deepen our understanding of
WebAssembly compiler bugs. We hope that the Ô¨Åndings of our
study will shed light on opportunities to design practical tools
for testing and debugging WebAssembly compilers.
I. I NTRODUCTION
WebAssembly is the newest language for the Web. Since
appearing in 2017 [1], many prominent tech companies and
news websites, such as eBay, Google, Norton, and CNN, have
adopted the technology for various use cases such as barcode
reading [2], video players, and TensorFlow.js machine learning
applications [3]. Currently, WebAssembly is supported by major
browsers including Chrome, Firefox, Safari, and Edge.
WebAssembly deÔ¨Ånes a portable bytecode format that serves
as a compilation target for high-level languages such as C/C++
and Rust, enabling developers to port native applications to
the Web. Rather than being written manually, WebAssembly
bytecode is usually created by WebAssembly compilers such
as Emscripten [4] or Rustc (with Wasm-Bindgen) [5].
As WebAssembly is increasingly adopted for various ap-
plications, there is a growing ecosystem of compilers that
support WebAssembly development. As shown in Table I,
there are currently 10 compilers available to support compiling
programs written in different programming languages to
WebAssembly [6].
Similar to compilers of native languages, WebAssembly
compilers also contain bugs that can miscompile binaryTABLE I
STATISTICS OF COMPILER PROJECTS .
Compiler Created Source LOC Releases Stars
AssemblyScript 2017-09 TypeScript 140,548 131 10,935
Emscripten 2011-02 C/C++ 226,196 363 20,191
Rustc/Wasm-Bindgen 2010-06 Rust 1,013,824 98 58,276
Asterius 2017-11 Haskell 92,078 0 1,537
Binaryen 2015-10 asm.js 115,106 190 4,597
Bytecoder 2017-04 Java 151,601 29 333
Faust 2016-11 Faust DSP 320,723 48 1,199
Ilwasm 2015-08 .NET CIL 4,549 0 344
Ppci-Mirror 2016-11 Python 12,998 0 174
TinyGo 2018-06 Go 4,910 20 7,399
outputs [7]. These bugs are difÔ¨Åcult to locate as they may be
encountered only at project‚Äôs runtime. Compiler bugs can also
waste development time when debugging an affected project
before realizing that the bug is introduced due to miscompi-
lation. For these reasons, it is important to understand how
reliable compiler projects are in discovering, understanding,
and resolving bugs.
In addition to handling the bugs associated with traditional
compilers, the developers of WebAssembly compilers face
unique challenges that can introduce buggy behavior. For ex-
ample, fully synchronous executions are not natively supported
by browser engines, which differs from the execution model
expected by C/C++. WebAssembly compiler developers should
ensure that synchronous operations in C/C++ code are properly
ported over to the asynchronous browser environment as relying
on asynchronous APIs to perform synchronous behavior can
lead to issues. Moreover, JavaScript does not support all data
types supported by WebAssembly. WebAssembly compilers
have to support the compilation of data types across multiple
target languages, as well as ensuring that, during runtime, types
are not used in incorrect ways.
In this paper, we perform an empirical analysis of bugs in
WebAssembly compilers to investigate the following research
questions:
RQ1: What new challenges exist in developing WebAssembly
compilers and how many bugs do they introduce?
RQ2: What are the root causes of these bugs?
RQ3: How do WebAssembly compiler developers reproduce
these bugs and what information is needed?
RQ4: How do WebAssembly compiler developers Ô¨Åx bugs?
RQ5: How long does it take to Ô¨Åx bugs in different compilers?
RQ6: What are the impacts of the bugs in diverse compilers?
To answer these research questions, we Ô¨Årst perform a
422021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000152021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678776
978-1-6654-0337-5/21/$31.00  ¬©2021  IEEE
TABLE II
FINDINGS AND IMPLICATIONS OF OURSTUDY .
Findings
Implications
1 Data type incompatibility bugs account
for 15.75% of the 146 bugs (Sec-
tion IV-B2).Interfaces (e.g., APIs) passing values between WebAssembly and JavaScript caused type incompatibility
bugs when their data types are mishandled in one of the languages. Such interfaces (e.g., ftell ,fseek ,
atoll ,llabs , and printf) require more attention.
2 Porting synchronous C/C++ paradigm
to event-loop paradigm causes a unique
challenge (Section IV-B1).While automated tools support the synchronous to event-loop conversion (e.g., Asyncify), bugs in them
may cause concurrency issues (e.g., race condition, out-of-order events). Programs going through this
conversation require extensive testing.
3 Supporting (or emulating) linear mem-
ory management models is challenging
(Section IV-B3).WebAssembly emulates the linear memory model (of the native execution environment). Many bugs
reported in this regard require a particular condition (e.g., allocation of a large memory to trigger heap
memory size growth), calling for more comprehensive testing.
4 Changes of external infrastructures used
in WebAssembly compilers lead to un-
expected bugs (Section IV-B4).Compiler developers should stay on top of developments that occur in the existing infrastructure used
within the compiler. In particular, valid changes (in one context) of existing infrastructure can introduce
unexpected bugs in WebAssembly. Rigorous testing is needed.
5 Despite WebAssembly being platform
independent, platform differences cause
bugs (Section IV-B8).The default Emscripten Test Suite focuses on testing V8 browser and Node.js, while there are bugs
reported due to the platform differences (e.g., caused by other browsers and OSes). The test suite should
pay attention to cover broader aspects of the platform differences.
6 Unsupported primitives not properly
documented lead to bugs being reported
in the compiler (Section IV-D9).WebAssembly compiler developers should pay attention to keeping the document consistent with the
implementation (e.g., mentioning sigsetjmp and function type bitcasting are not supported).
7 Some bug reports failed to include criti-
cal information, leading to a prolonged
time of debugging (Section IV-C).We observe that the current bug reporting practice can be improved. In particular, an automated tool
that collects critical information (e.g., inputs, compilation options, and runtime environments) would
signiÔ¨Åcantly help in the bug reproduction process.
8 Bugs that manifest during runtime made
up a signiÔ¨Åcant portion (43%) of the
bugs inspected (Section V-B).Many bugs in the compilers cause runtime bugs in the compiled programs, which are more difÔ¨Åcult to
detect and Ô¨Åx. To mitigate these bugs, compiler developers should be sure to test the emitted modules in
the test suites more exhaustively.
9 77.1% of bug-inducing inputs were less
than 20 line and developers manually
reduce the size of inputs (Section V-D).In many cases, bugs can be successfully reproduced by relatively small inputs that are less than 20 lines.
Currently, developers often manually reduce large inputs. Automated bug-inducing input reduction (e.g.,
delta debugging) would be beneÔ¨Åcial.
qualitative study on 146 bugs in Emscripten to identify
unique development challenges, and understand the root causes,
bug reproducing and bug Ô¨Åxing strategies of these bugs.
Next, we perform a quantitative study on 1,054 bugs among
three WebAssembly compilers, namely AssemblyScript [8],
Emscripten, and Rustc/Wasm-Bindgen. This study focuses on
the lifecycle of the bugs, their impacts, and the sizes of the
bug-inducing inputs and bug Ô¨Åxes. Based on the Ô¨Åndings
obtained from the two studies, we identify useful implications
for WebAssembly compiler developers. Our Ô¨Åndings and
implications are summarized in Table II. We hope that our
Ô¨Åndings can provide WebAssembly compiler developers with
speciÔ¨Åc areas that introduce bugs into the compiler, provide
details on these bugs and previous Ô¨Åxes to help in designing
new Ô¨Åxes, and provide general project management suggestions
to prevent the introduction of new bugs.
II. W EBASSEMBLY DEVELOPMENT FLOW
WebAssembly deÔ¨Ånes an assembly-like bytecode format that
is built to be fast and compact. The language also deÔ¨Ånes
a text format meant to ease understanding. SpeciÔ¨Åcally, the
text format provides a readable representation of the mod-
ule‚Äôs internal structure, including type, memory, and function
deÔ¨Ånitions. Unlike JavaScript, WebAssembly cannot access
the Web APIs directly. Any reliance on these technologies
such as the DOM, WebSockets API, and WebWorkers API
requires complementary JavaScript code. At the minimum,
WebAssembly requires JavaScript glue code to instantiate the
WebAssembly module.
For our study, we deÔ¨Åne a WebAssembly compiler as a tool
that can generate WebAssembly binary modules from sourcecode written in a high-level language. WebAssembly compilers
are composed of a frontend that parses the source code into
an intermediate representation (IR), an optional middle-end
that optimizes the IR of the program, and a backend that
generates WebAssembly binary code from the IR. In addition,
WebAssembly compilers include bindings of existing libraries
in order to support using standard libraries available in the
source language within a WebAssembly runtime.
Fig. 1shows a typical workÔ¨Çow of generating a We-
bAssembly program from the source code in C++ tothe
runtime usage on a website: (1) The C++ source program
example.cpp shown in Fig. 1(a) deÔ¨Ånes a function isEven() .
This C++ program is Ô¨Årst compiled by a WebAssembly
compiler, such as Emscripten (emcc), to generate the resulting
WebAssembly binary example.wasm as shown in Fig. 1(b).
The binary format is how a WebAssembly module is delivered
to and compiled by browsers. (2) To ease debugging, the
WebAssembly binary can be translated to its text format
(example.wat shown in Fig. 1(c)) by using a WebAssembly
toolkit, such as WebAssembly Binary Tool (WABT) [9]. The
text format shows examples of WebAssembly instructions,
such as get local andi32.and , as well as the WebAssembly
function isEven() . (3) To deploy the WebAssembly binary on
a website, a JavaScript glue code as shown in Fig. 1(d) that
instantiates the example.wasm Ô¨Åle is required. The JavaScript
code calls the function WebAssembly.instantiateStreaming
that takes the parameter fetch("example.wasm") as the binary
module source to instantiate. Finally, the returned module
invokes the exported function isEven().
WebAssembly modules are not typically standalone Ô¨Åles.
Instead, they are combined with generated JavaScript wrap-
243bool isEven(inta){
intb= a % 2;
if(b == 0)
return true;
else 
return false;
}example.cpp
(a) C++ Source Programexample.wasm
(b) WebAssembly Binary Formatexample.wat
(d) WebAssembly Text Format
Website or Web Application (e.g., Extensions)
(c) JavaScript ProgramWebAssembly. instantiateStreaming (fetch("example. wasm",imports)). then
(o=>{o.instance.exports. isEven()})(1) Compile 
via Emscripten
Compiler
(emcc )
(2) Execute via JavaScript glue code to instantiate(3) Translate 
via WebAssembly
Binary Tool 
(WABT)0x00 0061 736d 0100 0000 0186 8080 8000 0160  .asm...........`
0x10 017f 017f0382 8080 8000 0100 0484 8080  ................
0x20 8000 0170 0000 0583 8080 8000 0100 0106  ...p............
0x30 8180 8080 0000 0797 8080 8000 0206 6d65  ..............me
0x40 6d6f 7279 0200 0a5f 5a36 6973 4576 656e  mory..._Z6 isEven
0x50 6900 000a 8e80 8080 0001 8880 8080 0000  i...............(module(memory1)
(func$isEven(param$p0 i32)
(resulti32)
get_local $p0
i32.const1
i32.and
i32.eqzFig. 1. WebAssembly Development WorkÔ¨Çow.
per/glue code. Since WebAssembly cannot start on its own
and cannot directly interact with WebAPIs, the glue code is
responsible for importing the necessary functions used by the
module. Additionally, the glue code can set up data structures
necessary to implement the runtime provided by the native
language, such as memory allocation, Ô¨Åle system emulation,
and socket emulation.
The Ô¨Ånal output of a WebAssembly compiler includes (1)
a WebAssembly module, (2) a JavaScript Ô¨Åle that handles the
module imports and runs the module, and (3) an HTML Ô¨Åle
that loads the module.
III. D ATA COLLECTION
A. Selecting WebAssembly Compilers
We inspect WebAssembly compiler projects on GitHub
using the curated awesome-wasm list [6] that includes 10
WebAssembly compilers currently available, as shown in
Table I.
We focus on popular compilers that support general-purpose,
high-level programming languages. SpeciÔ¨Åcally, we prune
outFaust [10] (Domain SpeciÔ¨Åc Audio DSP Language) and
Binaryen (asm.js low-level target) as these source languages
are not general or high-level. We also Ô¨Ålter out compilers with
less than 100,000 lines of code (Asterius [11], Ilwasm [12],
Ppci-Mirror [13], and TinyGo [14]) and less than 50 releases
(Bytecoder [15]) to focus on mature projects. To this end, our
studies focus on three WebAssembly compilers, Emscripten [4],
Rustc/Wasm-Bindgen [16], and AssemblyScript [8].
1.Emscripten compiles C/C++ to WebAssembly [17]. It
originally targeted asm.js [18] ‚Äì a precursor language to
WebAssembly, so it precedes the creation of WebAssembly.
It uses a modiÔ¨Åed Clang frontend and originally used
Binaryen to provide the backend. It later adopted LLVM
as the backend [19].
2.Rustc compiles Rust programs to WebAssembly [16]. As
this compiler relies on the Wasm-Bindgen project [5] to
provide bindings necessary for WebAssembly compila-
tions, we include issues affecting both Rustc and Wasm-
Bindgen in our count. We use the name Rustc/Wasm-
Bindgen to highlight the combination of these two
components.3.AssemblyScript compiles a TypeScript-like language into
WebAssembly [8]. It uses its own frontend and relies on
Binaryen to handle the backend code generation.
In the qualitative study (Section IV), we aim to investigate
WebAssembly compiler bugs in-depth to answer the research
questions RQ1, RQ2, RQ3, and RQ4. For this purpose, we
choose Emscripten because it is the most mature and widely-
used WebAssembly compiler: (1) Emscripten was created
earliest and has the most numbers of stars and milestone
releases, compared with others. It also has the most number of
reported bugs (will be discussed in Section V). (2) It dominates
real-world usage [20].
B. Compiler Bug Collection
We collect bug reports from the three selected WebAssembly
compiler projects‚Äô GitHub repositories through two methods.
First, we use the GitHub Search API [21] to collect closed
GitHub issues related to WebAssembly1. Second, we use the
GitHub REST API [22] to collect all the issues and pull requests
for the projects. We also collect the commits referenced in the
timeline of each issue in order to Ô¨Ånd which Ô¨Åles the issues
affected in the repositories. After obtaining the full set of issues
for each project, we use the keywords ‚Äúbug‚Äù, ‚Äúdefect‚Äù, ‚Äúerror‚Äù,
and ‚Äúfault‚Äù to identify the issues likely to be bugs.
TABLE III
BUGREPORT DATASET .
Compiler
Start End Bugs Unique Bugs Commits
AssemblyScript
2018-02 2020-12 136 107 174
Emscripten 2015-06 2020-12 711 430 1,460
Rustc/W
asm-Bindgen 2017-12 2020-12 207 158 245
T
otals 1,054 695 1,879
Qualitative Study Dataset (Emscripten). We extract all 430
closed bugs from the Emscripten project. We read the bug
reports of these issues to only include those that are related to
the challenges unique to WebAssembly compilers. SpeciÔ¨Åcally,
we check the root causes of the 430 bugs to determine whether a
typical compiler targeting a native platform (e.g., GCC targeting
x86-64) would need to deal with a similar root cause. If not,
we consider that they are unique challenges to WebAssembly
1Issues with keywords like ‚Äúbug‚Äù, ‚Äúgood Ô¨Årst bug‚Äù, and ‚Äúbreaking changes‚Äù
with ‚ÄúWebAssembly‚Äù, ‚Äúwasm‚Äù, and ‚Äúwat‚Äù.
344and include them in our dataset. This brings the Ô¨Ånal number
of bugs to 146. This scale is on par with similar work involving
manual inspection [3], [23].
Quantitative Study Dataset. As shown in Table III, we obtain
a total of 1,054 bug reports and 1,879 related commits from
the three compilers‚Äô GitHub repositories. The second and
third columns show the earliest and latest dates of the bugs
considered for the dataset. The number of bugs from each
compiler (i.e., after applying the Ô¨Ålters) and the number of
commits relating to the bugs are presented in the fourth and Ô¨Åfth
columns, respectively. Note that we exclude bugs earlier than
June 2015 from consideration as these precede the development
of WebAssembly [24]. Also, there are multiple bug reports
for one single bug because they readdress previous issues for
various reasons (e.g., incomplete previous Ô¨Åx).
IV. S TUDY I: Q UALITATIVE STUDY OF EMSCRIPTEN ISSUES
In the Ô¨Årst study, we manually inspect Emscripten issues
that contain bug-inducing code inputs to identify development
challenges, bug causes, reproducing difÔ¨Åculties, and Ô¨Åxing
strategies.
Fig. 2presents the architecture of Emscripten. It is built
on top of existing compiler tools and infrastructures with
Clang being used to implement the frontend. LLVM is used
to provide middle-end optimizations. Binaryen and LLVM
provide the backend functionality. Although the three stages
resemble a traditional compilation pipeline for C/C++ compil-
ers, developers of Emscripten (and any WebAssembly compiler
in general) face unique challenges. SpeciÔ¨Åcally, Emscripten
provides implementations of the standard C and C++ that
emulate the functionality available on native platforms (e.g., Ô¨Åle
systems and threading). These emulation libraries implement
the semantics of legacy system calls by leveraging functions
from JavaScript runtime components. For example, the FS
library in Emscripten emulates traditional Ô¨Ålesystem operations
within the browser. Additionally, Emscripten provides libraries
that allow C/C++ to call JavaScript functions at runtime. This
is done to allow the C/C++ code to interact with the DOM and
Web APIs, which are only accessible through JavaScript. It also
includes several utilities supporting compilation or optimization
of the input rather than parts of the source language or libraries.
At the end of the compilation, a WebAssembly binary module
is emitted along with the JavaScript support code to provide a
full WebAssembly package.
A. RQ1: Development Challenges
WebAssembly compiler developers face a set of challenges
that are unique to the new language. We develop categories
for these challenges using an inductive coding approach [25]
where we create categories based on the description of the
underlying root cause. From this description, we determine
whether this is a common compiler issue [7] or an issue
unique to WebAssembly features. We iteratively add and reÔ¨Åne
categories to form district groups. As shown in Table IV,
we generalize 9 unique WebAssembly compiler development
challenges.TABLE IV
BUGS RELATED TO DEVELOPMENT CHALLENGES .
Development Challenge Count
1 Asyncify Synchronous Code 12
2 Incompatible Data Types 23
3 Memory Model Differences 12
4 Bugs in Other Infrastructures 25
5 Emulating Native Environment 23
6 Supporting Web APIs 17
7 Cross-Language Optimizations 15
8 Runtime Implementation Discrepancy 17
9 Unsupported Primitives 2
Total 146
Challenge 1: Asyncify Synchronous C/C++ Code. Most
basic operations in C/C++ are executed in a synchronous
and blocking manner. However, fully synchronous executions
are not supported by browser engines. Execution in browsers
follows an event loop that does not block execution to allow
user interactions [26], which differs from the execution model
expected by C/C++. In order to support compiling to this
model, WebAssembly compilers need to provide additional
tools to handle converting synchronous blocking code to Ô¨Åt the
event-based asynchronous browser environment. However, we
Ô¨Ånd that the implementations of these tools can be incorrect or
inconsistent, causing various bugs. We observe that 12 issues
were introduced by these tools.
Challenge 2: Incompatible Data Types. We Ô¨Ånd 23 issues
that are caused by incompatibilities in the data types passed
between the multiple languages involved in Emscripten compi-
lation. This includes type incompatibilities during compilation
between C and WebAssembly and type incompatibilities at
runtime between WebAssembly and JavaScript.
Challenge 3: Memory Model Differences. WebAssembly has
a different memory model than native environments. These
differences can lead to issues when compiling to WebAssembly,
and we Ô¨Ånd that 12 issues can be attributed to these differences.
Challenge 4: Other Infrastructures‚Äô Bugs. Emscripten is
built on top of existing compiler infrastructures and tools. As
a result, bugs can be reported in the Emscripten repository but
may be found to be caused in the tool of another infrastructure.
These existing infrastructures include frontend parsers, backend
code generators, and WebAssembly VMs (e.g., such as V8).
Challenge 5: Emulating Native Environment. Emscripten
provides libraries to seamlessly emulate native environment
features that are not available on the web. These include
Ô¨Ålesystems, POSIX threads, and sockets.
Challenge 6: Supporting Web APIs. In addition to emulating
native environment libraries, Emscripten also provides APIs to
support calling WebAPIs from C/C++ code. These WebAPIs
include WebGL, the Fullscreen API, and IndexedDB, and
these interfaces are called by existing C/C++ libraries such
as OpenGL and SDL or by using the Emscripten-provided
WebAPI bindings.
Challenge 7: Cross-Language Optimizations. Since Em-
scripten emits both a WebAssembly binary module and the
supporting JavaScript runtime code, optimizers used on either
output component must be able to collect usage information
445Input
Source Code
(.c/.cpp/.h)Existing 
Frontend
ClangMiddle -end
LLVM -
TransformsIR IREmscripten Compiler ToolchainOutput
Module (. wasm )Existing 
Backend
LLVM
Binaryen
Library Interface
WebAPIsNative Environment 
(NE) EmulationUtilities 
(e.g., Optimization, 
Minification, 
Sanitizer)
JS Support Code
NE Emulation 
Runtime
FS Math
WebAPIs
Implementation
 JS Support Code Fig. 2. Structure of Emscripten Compiler Toolchain.
TABLE V
ASYNCIFY SYNCHRONOUS C/C++ C ODE BUGS.
Asyncify Tool Causes Count
Emterpreter Parsing Errors 4
Emterpreter Incorrect Emterpretify Stack State 2
Missing Features in Emterpreter 3
Asyncify Missing sleep Callback 1
Animation requestAnimationFrame Misuse 1
IndexedDB Flawed Filesystem Sync Operation 1
Total 12
from both languages. These optimizers can contain bugs that
hinder the optimization of the resulting module.
Challenge 8: Runtime Implementation Discrepancy. Some
issues can arise from differences in the running environment.
This includes differences between browsers, differences in
browsers and runtimes, and differences in runtimes supporting
ES5 and/or ES6.
Challenge 9: Unsupported Primitives. Some issues arise
when users attempt to perform functionality that touches on
limitations in WebAssembly. For example, Emscripten does
not support the C keyword sigsetjmp, because WebAssembly
does not support signals [27].
B. RQ2: Bug Causes
We investigate the Emscripten bugs to identify and analyze
the types of root causes among the issues. We read the
conversation on the issue‚Äôs GitHub page to Ô¨Ånd what the
developers reported the underlying issue to be. After identifying
the root cause description for all issues, we generalize similar
root causes into challenges listed in Table IV. We create
root cause categories by using a deductive coding approach
beginning with root cause categories from existing work [28]‚Äì
[33]. We extend these categories to be more speciÔ¨Åc to
WebAssembly compilers. To categorize these bugs, we read
the issue reports to Ô¨Ånd what the compiler developers reported
the underlying issues to be. We decide to which category the
underlying root cause most relates to. Note that some root
causes may be related to more than one category. For example,
if the bug root cause is an invalid type operation from another
infrastructure, we classify it as under Incompatible Data Types.
1) Asyncify Synchronous Code Bug Causes: There are 12
bugs in Emscripten tools that convert synchronous execution
to asynchronous execution, as shown in Table V. SpeciÔ¨Åcally,
4 bugs are caused by parsing errors in the Emterpreter tool.
2 bugs are caused by the internal state management of theEmterpreter. 3 bugs are caused by unimplemented features in
the Emterpreter. 1 bug is caused by the omitted sleep callback.
1 bug is caused by a misuse of the requestAnimationFrame
browser function as a polling mechanism. 1 bug is caused by
a Ô¨Çawed Ô¨Ålesystem sync operation.
Fig. 3gives an example [34] of the missing sleep callback
bug. Emterpreter and Asyncify are two mechanisms provided
by Emscripten to handle porting synchronous C/C++ code
into event-based code compatible with the browser event-loop.
Asyncify [19] allows for asynchronous execution by modifying
WebAssembly code to allow for pausing and resuming during
the middle of execution. Emterpreter [35] converts the input
code into a bytecode format different from WebAssembly that
is run in an interpreter that can be paused and resumed.
According to the documentation, both methods should
perform the same functionality. This bug happens because the
emscripten sleep API in Asyncify behaves differently from
theemscripten sleep with yield function in Emterpreter.
In particular, emscripten sleep in Asyncify does not actually
call a sleep callback. This difference leads to issues in the SDL
library as it relies on these tools to handle streaming audio in
the main loop. Audio chunks are enqueued through the sleep
callback as shown in Fig. 3, so this lack of consistency leads
to audio distortion in Asyncify.
1 SDL_AudioSpec as;
2 as.callback = audio_callback;
3 void audio_callback(void *unused, Uint8 *stream, int len) {
4 // push audio stream data to stream variable
5 }
6 while (true) {
7 // calculate audio stream data
8 emscripten_sleep_with_yield(1); // emscripten_sleep(1); -
for asyncify ,!
9 }
Fig. 3. Emscripten Issue #9823: Missing sleep Callback.
This issue is Ô¨Åxed by adding the changes shown in Fig. 4to
the Asyncify library to call sleep callbacks, making it consistent
with the behavior in Emterpreter.
2) Incompatible Data Type Bug Causes: We Ô¨Ånd 23 bugs
within Emscripten that are a result of incompatible data
types passed between the various languages involved in the
compilation. As shown in Table VI, incompatible data type bugs
result from root causes that can be grouped into three broad
categories. The Ô¨Årst group includes root causes involving native
WebAssembly data types (i.e., i32,i64,f32, and f64). The
5461 + sleepCallbacks: [], // functions to call every time we sleep
2 ...
3 handleSleep: function(startAsync) {
4 + // Call all sleep callbacks now that the sleep-resume is all
done. ,!
5 + Asyncify.sleepCallbacks.forEach(function(func) {
6 + func();
7 + });
8 ...
9 }
Fig. 4. Bug Fix for Emscripten Issue #9823.
TABLE VI
INCOMPATIBLE DATA TYPES BUGCAUSES .
Data Type Causes Count
Incorrect i64 Legalization 7
Native Unsupported Floating-Point or Precision Loss 4
Missing i32 Operation 1
Incorrect C++ Atomic Types 4
Custom Invalid SIMD Type Operations 4
Error Code Type Change 1
UndeÔ¨Åned UndeÔ¨Åned Cross-Language Type Function 2
Total 23
second group involves types that are not native to WebAssembly,
including C++ atomic types designed for threads [36], Single
Instruction, Multiple Data (SIMD) values, and error code
constants. The last category, UndeÔ¨Åned Cross-Language Type
Function, involves missing utility functions that fetch type
information of compiled C/C++ values.
Fig.5gives an example [37] of the incorrect i64legalization
bug. This bug occurs when using a Ô¨Åle pointer provided by
thecstdio library and compiling the module with option
-s MAIN MODULE=1 . When compiling to WebAssembly, the
browser sandbox prevents accessing the host Ô¨Ålesystem. To
get around this limitation, Emscripten provides a Ô¨Ålesystem
library, FS, implemented in JavaScript that emulates most of the
functionality provided by libc andlibcxx . The Ô¨Åles are either
provided as a static asset to download or embedded within the
JavaScript wrapper. When the code in Fig. 5is compiled, the
calls to perform Ô¨Åle I/Os are handled within this FSlibrary on
the JavaScript side.
1 #include <cstdio>
2 int main() {
3 FILE* file_ = std::fopen("input.txt","rb");
4 if (file_) {
5 std::fseek(file_, 0l, SEEK_END);
6 std::fclose(file_);
7 }
8 return 0;
9 }
Fig. 5. Emscripten Issue #9562: Incorrect i64 Legalization.
Since JavaScript does not natively support 64-bit integers,
passing the 64-bit integer values to JavaScript is usually handled
by a method called legalization which converts the 64-bit value
into two 32-bit integers holding low and high bits separately.
Within the execution path to fseek() , an indirect call attempts
to pass a WebAssembly i64value to exported WebAssembly
function of a side module. The issue is that this other module‚Äôs
export function has been wrapped in JavaScript code to support
value legalization, so although the Ô¨Årst module knows thatthe export function‚Äôs type is i64, the intermediate JavaScript
function cannot accept the parameter.
The issue is Ô¨Åxed by exporting legalized and non-legalized
versions of WebAssembly functions so that function calls made
through the indirect calls used here can pass i64values to the
appropriate function when legalization is not required.
3) Memory Model Difference Bug Causes: We observe 12
bugs in Emscripten that are a result of the differences in mem-
ory model between WebAssembly and a native environment.
In a native environment, memory is allocated directly from the
main memory, while WebAssembly uses the data structures
available in the host VM to allocate a block of memory to
function as the module‚Äôs linear memory.
SpeciÔ¨Åcally, there are 5 bugs that do not update the memory
location after the memory is relocated. 2 bugs are caused by
unnecessarily disabling memory growth in combination with
another functionality, such as building standalone modules. 1
bug does not free unused resources after they are no longer
needed, resulting in increased memory usage. Another bug
attempts to access memory beyond the intended range. 1 bug
shifts the boundaries of a memory buffer incorrectly. A bug
incorrectly leaves zero-Ô¨Ålled memory regions in the initial
memory Ô¨Åle, increasing the size of the Ô¨Åle.
Fig.6shows an example [38] of the missing reference update
bug. When a WebAssembly program allocates a large amount
of heap memory, the memory might be relocated to a different
location. If a program stores a memory location and does
not update the location after the heap memory is relocated, it
will cause a runtime exception because it refers to an invalid
memory location.
This bug occurs when both WebAssembly memory growth
and Ô¨Åle system functionality are used (e.g., via MEMFS
Ô¨Ålesystem). When the WebAssembly module is initialized, the
Ô¨Åle content is stored in the heap section created in the module
memory. The MEMFS Ô¨Ålesystem is one of the Emscripten-
emulated Ô¨Ålesystems, and it supports in-memory Ô¨Åle storage. It
contains a reference to this location for future Ô¨Åle operations.
After the malloc(20000000) , the memory is grown, and the
heap is moved to a different location. However, the Ô¨Ålesystem
reference is not updated, and the Ô¨Åle contents cannot be read.
1 #include <stdio.h>
2 #include <stdlib.h>
3 void main() {
4 int c;
5 malloc(20000000); // Enlarge memory
6 FILE *fp = fopen("test.c", "r");
7 while ((c = fgetc(fp)) != EOF)
8 putchar(c);
9 }
Fig. 6. Emscripten Issue #5179: Missing Reference Updates.
The issue is Ô¨Åxed by forcibly enabling the ‚Äò‚Äìno-heap-copy‚Äô
Ô¨Çag, which stores the Ô¨Åle system in a separate array to allow
it to grow freely without worrying about Ô¨Ålesystem references.
However, this slows operations involving the mmap() syscall.
4) Other Infrastructures Bug Causes: We Ô¨Ånd 25 bugs
reported in Emscripten that are caused by the tool of another
infrastructure. The root causes of bugs related to the Other
647Infrastructure Bug Causes challenge can be grouped by the
infrastructure where the bug is caused. SpeciÔ¨Åcally, we Ô¨Ånd 12
bugs affecting the LLVM Wasm Backend and 1 bug affecting
the LLVM C++ standard library. There are 5 bugs affecting
Binaryen and 1 bug in Clang. We also observe 3 bugs located
in Firefox, 2 bugs in V8, and 1 bug in Safari.
For example, a bug was introduced into Emscripten when an
update in Clang changed a default behavior when compiling
with the options -g3or-g4(Emscripten Issue #7883 [39]).
Previously, Emscripten would use value names found in LLVM
IR to create the variable names in asm.js. An update in Clang
discards these value names when generating the IR in order
to improve the performance. The Emscripten developers were
not aware of this change in Clang.
To Ô¨Åx this issue, the Emscripten developers utilize a new
Clang Ô¨Çag ( -fno-discard-value-names ), which disables the
new behavior and emits the value names in the IR.
5) Emulating Native Environment Bug Causes: We Ô¨Ånd
that 23 bugs are related to the Emulating Native Environment
challenge. Among the 23 bugs, 11 are in the emulated Ô¨Ålesystem
library and are caused by issues such as implicit dependencies,
incorrect path resolving, and data truncation. 9 bugs are related
to the pthread library and include issues such as thread scoping
issues and incorrect termination. There are 3 bugs related to the
socket library caused by issues such as unsupported functions.
6) Supporting Web APIs Bug Causes: We Ô¨Ånd that 17 bugs
are caused by the challenge of Supporting Web APIs. 11 of the
bugs are related to the WebGL APIs behavior not matching
with OpenGL behavior. 2 bugs involving callback ordering are
related to the Fullscreen API. 2 bugs impact the IndexDB APIs
by not handling possible errors. 2 bugs affect the WebAPIs
exposed through the SDL library.
7) Cross-Language Optimizations Bug Causes: We Ô¨Ånd that
theCross-Language Optimization challenge produces 15 bugs.
9 bugs are caused by errors that lead to the optimizer marking
a symbol as unused and removing it when it is needed by the
code in the other language. 2 bugs are caused by syntactical
mistakes in the optimizer code. 2 bugs are caused by errors in
the optimizers variable scope tracking that prevent them from
identifying all unused variables within the scope.
8) Runtime Implementation Discrepancy Bug Causes: Our
results show that the Runtime Implementation Discrepancy
challenge is responsible for 17 bugs. 5 of these bugs are related
to Chrome API changes and behavior discrepancies. 1 bug is
related to Safari and its immutable native objects. 1 bug is
related to unsupported features in Internet Explorer. 2 bugs
are related to NodeJS are caused by misusing V8 or built-in
module APIs. 4 bugs are related to runtimes that do and do
not support ES6 are caused by the behavior changes made
between ES5 and ES6, including module export immutability
and new APIs being introduced. 4 bugs are related to other
runtimes through causes such as lack of fallback support, API
changes, and performance issues.C. RQ3: Bug Reproducing Analysis
Reproducing a bug is often the Ô¨Årst step of the debugging
process. However, some bugs may require a particular input,
environment setting, or compiler version. We analyze each
bug report and conversations in the bug issue to understand
the challenges in reproducing bugs. Moreover, we inspect bug
reports whether they contain all the critical information or not.
Information in Bug Reports. Table VIIpresents the critical
information for bug reproduction included or discussed in the
issues we check. ‚ÄúID‚Äù represents the GitHub issue IDs. ‚ÄúSrc.‚Äù
indicates the source code of a program that causes the bug. ‚ÄúJS‚Äù
means the JavaScript code snippet required to run the compiled
WebAssembly program. ‚ÄúStack‚Äù means a stack trace of the
buggy program. ‚ÄúGT‚Äù represents the bug‚Äôs ground truth which
includes the exact error message or expected values that can
determine whether the bug is reproduced or not. ‚ÄúOpt.‚Äù and
‚ÄúVer.‚Äù represent WebAssembly compiler options and versions
used. ‚ÄúEnv.‚Äù means the runtime environment (e.g., browser
name and version). ‚ÄúWasm‚Äù means the compiled WebAssembly
program. The /check_signsymbol means that the information is provided
in the bug report. Otherwise, they are not included in the report.
Table VIIshows the results from a subset of the bug reports.
A complete list can be found on [40]. Observe that most bug
reports include sources, stack traces, ground truth, and compiler
options, while information for compiler versions and runtime
environments are relatively less frequently included. Moreover,
compiled WebAssembly Ô¨Åles are rarely included. Our manual
investigation shows that those reports including WebAssembly
Ô¨Åles are typically high-quality reports. From those observations,
we realize that an automated approach to create informative
bug reports is highly desirable. SpeciÔ¨Åcally, when a compiler
generates a WebAssembly program, information for all the
columns of Table VIIcan be collected to create a bug report Ô¨Åle,
similar to memory dump Ô¨Åles containing various information
about the environment.
Bug Reports Lacking Information. We further investigate
bug reports that required signiÔ¨Åcantly more effort in repro-
ducing the bugs. Table VIII shows such cases. Note that we
introduce the /plus_square_osymbol to represent information added after
the initial report, requested mainly by the developers. It takes
some time for developers to request additional information for
the reports with many /plus_square_osymbols.
Compared with Table VII, sources (‚ÄúSrc.‚Äù) and ground truth
(‚ÄúGT‚Äù) are not frequently included in those reports, while
those are critical in reproducing the bugs. Compile options
and compiler versions are not well provided, and none of the
reports includes compiled WebAssembly programs. The last
Ô¨Åve cases are the ones that developers express difÔ¨Åculty in
reproducing. In particular, the initial report of #7409 lacks
critical information, leading to many conversations with the
developer to provide the missing information.
Overall, our analysis shows that many of the bug reports lack
sufÔ¨Åcient information to quickly reproduce reported bugs. We
Ô¨Ånd that this lack of information can lead to longer debugging
time in the compiler project. Compiler developers should
748explore methods to ensure as much useful information is
reported in these bug reports.
TABLE VII
INFORMATION INCLUDED IN THE BUGREPORTS .
Cat.
ID Src.1JS2Stack3GT4Opt.5Ver.6Env.7Wasm8Incompatible
Data Types3487/check_sign
/check_sign /check_sign /check_empty /check_sign /check_sign /check_empty /check_empty
3787/check_sign /check_empty /check_sign /check_sign /check_sign /check_empty /check_empty /check_empty
3788/check_sign /check_empty /check_sign /check_sign /check_sign /check_empty /check_empty /check_empty
3789/check_sign /check_empty /check_empty /check_sign /check_empty /check_empty /check_empty /check_empty
3849/check_sign /check_sign /check_empty /check_sign /check_empty /check_empty /check_empty /check_empty
3892/check_sign /check_empty /check_empty /check_sign /check_empty /check_sign /check_sign /check_empty
4251/check_sign /check_empty /check_empty /check_sign /check_sign /check_sign /check_sign /check_empty
5031/check_empty /check_empty /check_empty /check_empty /check_empty /check_empty /check_empty /check_empty
5370/check_sign /check_empty /check_empty /check_empty /check_sign /check_sign /check_empty /check_sign
6309/check_sign /check_empty /check_sign /check_empty /check_empty /check_empty /check_empty /check_empty
7199/check_sign /check_sign /check_empty /check_sign /check_sign /check_sign /check_empty /check_sign
7208/check_empty /check_empty /check_sign /check_sign /check_sign /check_sign /check_empty /check_emptyAsyncify
Synchronous Code3141/check_sign
/check_empty /check_sign /check_sign /check_sign /check_empty /check_empty /check_empty
3908/check_sign /check_empty /check_empty /check_sign /check_empty /check_sign /check_empty /check_empty
4046/check_empty /check_sign /check_sign /check_empty /check_sign /check_sign /check_sign /check_empty
5716/check_sign /check_empty /check_sign /check_sign /check_sign /check_empty /check_empty /check_empty
6724/check_sign /check_empty /check_sign /check_sign /check_sign /check_sign /check_empty /check_empty
6727/check_sign /check_empty /check_sign /check_sign /check_sign /check_empty /check_empty /check_empty
6738/check_sign /check_empty /check_sign /check_sign /check_sign /check_empty /check_empty /check_empty
6804/check_empty /check_sign /check_empty /check_empty /check_empty /check_empty /check_empty /check_empty
6818/check_empty /check_empty /check_sign /check_empty /check_empty /check_empty /check_sign /check_empty
7988/check_empty /check_empty /check_empty /check_empty /check_empty /check_empty /check_empty /check_empty
9823/check_sign /check_empty /check_empty /check_sign /check_sign /check_sign /check_empty /check_empty
10051/check_sign /check_empty /check_empty /check_sign /check_empty /check_empty /check_sign /check_emptyMemory
Model Differences3636/check_sign
/check_empty /check_sign /check_sign /check_sign /check_sign /check_sign /check_empty
3907/check_sign /check_empty /check_empty /check_sign /check_sign /check_sign /check_empty /check_empty
5179/check_sign /check_sign /check_sign /check_sign /check_sign /check_sign /check_sign /check_empty
5187/check_sign /check_sign /check_empty /check_sign /check_sign /check_sign /check_sign /check_empty
5585/check_empty /check_empty /check_empty /check_empty /check_sign /check_empty /check_empty /check_empty
6359/check_sign /check_empty /check_empty /check_sign /check_empty /check_empty /check_empty /check_empty
7409/check_sign /check_empty /check_sign /check_sign /check_sign /check_empty /check_sign /check_empty
8637/check_sign /check_sign /check_empty /check_sign /check_sign /check_sign /check_empty /check_empty
9497/check_empty /check_sign /check_empty /check_empty /check_empty /check_empty /check_empty /check_empty
9587/check_empty /check_sign /check_sign /check_empty /check_sign /check_sign /check_empty /check_empty
9808/check_sign /check_empty /check_empty /check_empty /check_empty /check_empty /check_empty /check_empty
10179/check_sign /check_empty /check_sign /check_sign /check_empty /check_empty /check_empty /check_empty
1./check_signmeans
the source code is available.
2./check_signthe JavaScript support code is available.
3./check_signmeans a stack trace is provided.
4./check_signmeans the ground truth of the expected output is listed.
5./check_signmeans the compiler options used are listed.
6./check_signmeans the version of the compiler used is listed.
7./check_signmeans the runtime information is provided.
8./check_signmeans the compiled WebAssembly binary is available.
D.
RQ4: Bug Fixing Strategies
We investigate the different strategies used to Ô¨Åx these
Emscripten bugs. We determine the bug Ô¨Åx strategy by reading
the issue conversation to see if the developers explicitly mention
the Ô¨Åx used. If it is not mentioned, we inspect the Ô¨Åxing commit,
which is the last commit before the issue is closed. For each
compiler challenge category, we group bugs with similar Ô¨Åxes
into categories developed using an inductive coding approach
on the Ô¨Åx descriptions. Note in all categories we omit low-
frequency categories.
1) Asyncify Synchronous Code Bug Fix: The Ô¨Åxing strategies
used to resolve the Asyncify Synchronous C/C++ Code issues
can be grouped by the tool used. Bugs caused by a fault in
the Emterpreter tool were Ô¨Åxed by extending the internal state
checking, improving the Emterpreter parsing, improving theTABLE VIII
BUGREPORTS WHERE THE BUGS AREDIFFICULT TO REPRODUCE .1;2
ID
Src. JS Stack GT Opt. Ver. Env. Wasm
3778/check_empty
/check_empty /check_empty /check_empty /check_empty /check_empty /check_sign /check_empty
3857/check_empty /check_sign /check_empty /check_sign /check_empty /check_empty /plus_square_o /check_empty
3861/check_empty /plus_square_o /check_sign /check_empty /check_empty /check_empty /check_sign /check_empty
3892/check_sign /check_empty /check_empty /check_sign /check_empty /check_sign /check_sign /check_empty
4046/plus_square_o /check_sign /check_sign /check_empty /check_sign /check_sign /check_sign /check_empty
4122/check_empty /check_empty /check_sign /check_empty /check_empty /check_empty /check_empty /check_empty
4646/check_empty /check_sign /check_empty /check_sign /check_empty /check_sign /check_empty /check_empty
5797/check_empty /plus_square_o /check_sign /check_empty /plus_square_o /plus_square_o /check_sign /check_empty
6169/check_empty /check_sign /check_sign /check_empty /check_sign /check_empty /check_sign /check_empty
6442/check_empty /check_empty /check_sign /check_sign /check_sign /check_sign /check_empty /check_empty
7146/check_empty /plus_square_o /plus_square_o /check_sign /check_empty /check_empty /plus_square_o /check_empty
7472/plus_square_o /check_empty /check_sign /check_empty /check_sign /check_sign /check_sign /check_empty
9091/check_empty /check_sign /check_sign /check_empty /check_sign /check_empty /check_sign /check_empty
9319/check_empty /check_empty /check_sign /check_empty /check_empty /check_empty /plus_square_o /check_empty
9650/check_empty /check_sign /check_sign /check_sign /check_empty /check_empty /check_sign /check_empty
10205/plus_square_o /check_empty /check_sign /check_sign /check_sign /check_sign /plus_square_o /check_empty
10317/check_empty /plus_square_o /check_empty /check_empty /check_empty /check_sign /check_empty /check_empty
10385/check_empty /check_sign /check_sign /check_empty /check_sign /check_sign /check_empty /check_empty
10675/check_empty /check_sign /check_sign /check_empty /check_sign /check_sign /check_empty /check_empty
3824/check_sign/check_empty/check_empty/check_empty/check_empty/check_empty/check_empty/check_empty
6534/check_sign/check_empty/check_empty/check_empty/check_sign/check_empty/check_empty/check_empty
7409/plus_square_o/check_empty/plus_square_o/check_sign/plus_square_o/check_empty/plus_square_o/check_empty
8001/check_sign/check_sign/check_sign/check_sign/check_sign/check_sign/check_sign/check_empty
10233/check_empty/check_empty/check_sign/check_empty/check_empty/check_empty/check_sign/check_empty
1.
Refer to Table VIIfor column headers.
2./plus_square_omeans the respective information was added after the initial post.
T
ABLE IX
ASYNCIFY SYNCHRONOUS C/C++ C ODE BUGFIXES .
Asyncify Tool Strategy Count
EmterpreterImprove State Checking 2
Improve Emterpreter Parsing 4
Improve Function Whitelisting 2
Throw Exception 1
Asyncify Add Sleep Callback 1
Animation Add Warning Message 1
IndexedDB Add Documentation 1
Total 12
function whitelisting functionality, or throwing an exception
message to prevent misuse. Bugs caused by faults in the
Asyncify tool were Ô¨Åxed by handling the missing sleep
callback that led to inconsistent behavior compared with
Emterpreter. Bugs caused by misuse of animation APIs were
Ô¨Åxed adding a warning message against the incorrect usage.
Bugs caused by a fault related to IndexedDB were resolved by
updating the documentation to mention the buggy behaviors.
TABLE X
INCOMPATIBLE DATA TYPES BUGFIXES .
Data Type Strategy Count
NativeFix/Bypass Legalization 5
Add/Improve Type Support 4
Add Documentation 2
Provide Workaround 1
Fix/Remove Emitted Type Operations 6
Custom Change Type Used 2
Provide Workaround 1
UndeÔ¨Åned Add Missing Function 2
Total 23
8492) Incompatible Data Type Bug Fix: The bug Ô¨Åxing strate-
gies applied on Incompatible Data Types bugs can be broken
down by whether the root causes affected native WebAssembly
types or special types not native to WebAssembly.
To Ô¨Åx Native Types issues, the following Ô¨Åxing strategies
were applied. The Fix/Bypass Legalization strategy changes
the JS-Wasm interfaces to either Ô¨Åx missing value legalization
wrappers or disable unnecessary value legalization. The Ad-
d/Improve Type Support Ô¨Åxing strategy adds code to handle the
unimplemented data types or improves the already-present code
to handle a missing operation. The Add Documentation category
describes the faulty behavior in the compiler documentation.
In the Provide Workaround strategy, the compiler developers
give the reporter a temporary solution to avoid triggering the
fault while performing the originally intended action.
To Ô¨Åx issues involving Custom Types, the following strategies
were applied. The Fix/Remove Emitted Type Operations Ô¨Åxing
strategy changes the faulty code to either Ô¨Åx or remove the
invalid type or related operations that caused the fault. Change
Type Used Ô¨Åxes entail changing the variable type used that
caused the faulty behavior.
The issues caused by UndeÔ¨Åned Cross-Language Type
Functions were Ô¨Åxed by adding the missing functions (Add
Missing Function strategy).
3) Memory Model Difference Bug Fix: The bug Ô¨Åxing
strategies applied to the 12 Memory Model bugs are as follows.
4 bugs Ô¨Åx the code obtaining memory references to change
when the linear memory undergoes a change, such as memory
growth. 2 bugs are Ô¨Åxed by releasing unused memory objects.
2 bugs change the operations calculating the boundaries of
memory regions to prevent going out of them. 2 bugs change
the allocation method used to remove the faulty method.
4) Other Infrastructure Bug Fix: The bug Ô¨Åxing strategies
applied to Other Infrastructure bugs can be grouped by the
related project. We Ô¨Ånd that the bugs in this challenge delegate
the other infrastructure to Ô¨Åx the issue, including 11 wasm-ld
bugs, 1 LLVM WebAssembly Codegen bug, 1 libcxx project
bug, 2 V8 bugs, 3 Firefox project bugs, 3 asm2wasm bugs,
and 1 wasm-opt bug. The Use Workaround Ô¨Åxing strategy is
used on 3 bugs related to Binaryen, Safari, and Clang to avoid
calling the code triggering the bug in the other infrastructure.
5) Emulating Native Environment Bug Fix: The bug Ô¨Åxing
strategies applied to the 23 Emulating Native Environment are
as follows. 6 bugs change the compiler options to automatically
export the necessary dependency APIs when compiling. 3 bugs
improve the functions gathering properties on the Ô¨Åles or paths
in the Ô¨Ålesystem. 2 bugs remove any functionality that implicitly
leads to a Ô¨Ålesystem library dependency. 3 bugs change the
code that sets global variables to also set those variables within
the worker thread‚Äôs scope. 2 bugs improve the release of used
resources more reliably.
6) Supporting Web APIs Bug Fix: The Ô¨Åxing strategies
applied to the 17 Supporting Web API bugs are as follows.
3 bugs add function cases to the list of supported WebGL
extensions. 3 bugs wrap the faulty code in type checking to
prevent accessing non-existent Ô¨Åelds. 2 bugs were not fullyÔ¨Åxed by linked commits. 3 bugs change the event listeners
used to avoid faulty behavior. 2 bugs impacting IndexedDB
allow errors to be handled with try-catch statements rather
than being hidden.
7) Cross-Language Optimizations Bug Fix: The Ô¨Åxing
strategies applied to the 15 Cross-Language Optimization bugs
are the following. 7 bugs change the code to prevent optimizers
from changing the variable or Ô¨Åeld name so that it matches
in both JavaScript and WebAssembly. 2 bugs add function
deÔ¨Ånitions provided by the runtime environment to prevent
the optimizer from marking the functions as undeÔ¨Åned. 2
bugs emit a warning message describing the faulty behavior
when it is called. 2 bugs correct typographical mistakes in the
implementation of the optimizers.
8) Runtime Implementation Discrepancy Bug Fix: The
Ô¨Åxing strategies applied to the 17 Runtime Implementation
Discrepancy bugs are as follows. 5 bugs patch the affected
code to avoid the runtime behavior discrepancies. 4 bugs add
code to handle the cases where a feature is not implemented
so that execution can continue. 3 bugs change the code logic
to conform to updated runtime APIs. 3 bugs Ô¨Åx the checks
that determine what properties or operations the environment
has or supports. 2 bugs change the code to enable the use of
particular runtime behaviors that improve performance.
9) Unsupported Primitives Bug Fix: The only Ô¨Åxing strat-
egy applied to WebAssembly Limitation bugs is the Provide
Workaround strategy to implement the unsupported functionality
through different WebAssembly features.
V. S TUDY II: Q UANTITATIVE STUDY
In the second study, we perform a quantitative analysis
on 1,054 bug reports collected from three compilers, Assem-
blyScript, Emscripten, and Rustc/Wasm-Bindgen, to understand
the lifecycle of these bugs, the impacts that they have on
compiled programs, the sizes of bug-inducing inputs, and
the sizes of the Ô¨Åxes applied. The bug lifecycle shows how
responsive compilers are in dealing with new bugs. Ideally, most
bugs should be solved within one day [7]; however, our results
show this is not the case. Investigating the impacts that bugs can
cause on miscompiled programs is important in understanding
the severity of the bugs that these compilers face. Understanding
the sizes of bug-inducing inputs reveals the average code
complexity needed to trigger bugs in these compilers, providing
guidance for designing test cases. Inspecting the sizes of bug
Ô¨Åxes reveals how widespread the bug impact is in the code.
A. RQ5: Lifecycle of Bugs
We analyze the duration between the time a bug is reported
and the time the bug is Ô¨Åxed. We consider a bug as Ô¨Åxed when it
is closed after a commit is referenced. If the bug is reopened, we
use the time of the last closing event as the end of the duration.
Fig. 7presents the cumulative distribution of bug lifecycles.
Rustc/Wasm-Bindgen, AssemblyScript, and Emscripten were
able to Ô¨Åx 35.1%, 27.5%, and 23.6% of their bugs within 1 day,
respectively. Within 10 days, the three compilers Ô¨Åxed over
50% of their bugs. These results show that the three compiler
950projects fall short of the ideal same-day Ô¨Åx turnaround time [7].
This should be taken into consideration when deciding to use
WebAssembly in a production-level project.
Fig. 7. Cumulative Distribution of Lifecycle of Bugs.
TABLE XI
IMPACT CATEGORIES FOR EACH COMPILER .
ImpactAssembly
Emscr- Wasm-
Script ipten Bindgen
Build-T
ime Build Error 23 54 18
Compile-T
imeCompile Error 50 151 63
Link
er Error 0 2 22
Code
Bloating 0 12 1
RuntimeCrash
1 61 14
Data
Corruption 0 7 2
F
ail to Instantiate 2 5 4
Performance
Drop 1 2 3
Hang
0 2 0
Incorrect
Functionality 5 59 14
Other
Runtime Error 25 75 17
T
otal 107 430 158
B. RQ6: Impact of Bugs
We manually inspect all 695 unique bugs in the three
compilers to Ô¨Ånd out whether the errors occurred at the compiler
build time, program compile time, or runtime:
(1)Build-Time Errors prevent the compiler itself from
successfully compiling [41], [42].
(2)Compile-Time Errors occur during the process that
compiles source programs to WebAssembly binaries, including:
(a)Compile Error fails to compile correct source programs
(with no syntax errors) to WebAssembly binaries. (b) Linker
Error fails to link the WebAssembly output with necessary
libraries such as stdlib . (c) Code Bloating increases the size
of the compiled WebAssembly Ô¨Åle but does not affect the
functionality [43], [44].
(3)Runtime Errors occur during the execution of a generated
WebAssembly binary. The impacts of runtime errors include:
(a)Crash leads to unrecoverable exceptions at runtime [45],
halting the execution [46]. (b) Data Corruption corrupts the
data stored in the output modules by losing or changing
stored information [47]. (c) Failure to Instantiate fails to
instantiate the WebAssembly binary because of inconsistencies
with the wrapper code. (d) Performance Drop causes a
noticeable slowdown in runtime performance when executing
WebAssembly [48], [49]. (e) Hang stops responding to browserevents [50]. (f) Incorrect Functionality results in functionality
inconsistent with what the compiled source code speciÔ¨Åed [51].
(g)Other Runtime Error does not Ô¨Åt into the above categories,
such as missing debugging information [52]. Table XIshows
the number of bugs by their impacts for the three compilers.
We observe a signiÔ¨Åcant portion of runtime errors. SpeciÔ¨Åcally,
49.1%, 34.2%, and 31.8% of the bugs in Emscripten, Wasm-
Bindgen, and AssemblyScript, respectively.
C. Bugs in Existing Compiler Projects
WebAssembly compilers often rely on components of
existing compiler projects such as LLVM and Clang. We Ô¨Ånd 43
bugs are located in external compiler infrastructures, including
32 Emscripten bugs (16 LLVM, 12 Binaryen, 4 Clang), 10
Rustc/Wasm-Bindgen bugs (LLVM), and 1 AssemblyScript
bug (Binaryen). Those bugs happen because the compiler
developers misunderstand external projects‚Äô behaviors [53],
[54] or updates on the external projects break assumptions made
by developers [55], [56]. Note that the counts for Emscripten
differ than those in Section IVdue to differences in the bug
selection criteria between the datasets.
D. Testing and Fixing Bugs
Fig. 8. Cumulative Distribution of Input Sizes.
1) Size of Bug-Inducing Test Inputs: Fig. 8shows the
distribution of the lines of code of the bug-inducing inputs
that are given in the issue postings to reproduce the bugs,
including source code and compiler options. Note that in our
dataset, only 340 (48.9%) issues include the bug-inducing
inputs. A large portion of bug-inducing inputs in all three
compilers (183, 53.8%) have 10 or fewer lines of code, and
262 (77.1%) bugs-inducing inputs have 20 lines or fewer. In
some cases, we observe a large program was provided initially
as a bug-inducing input [57]‚Äì[59]. Later on, multiple posts on
the same issue gradually developed to minimize the size of
the bug inputs [60]‚Äì[62]. This suggests that techniques that
can minimize testing inputs [63]‚Äì[66] are desirable.
2) Size of Bug Fixes: We analyze the size of bug Ô¨Åxes in
terms of the lines of code. Among all compilers, 58.4% of
all bugs (Emscripten: 43.7%, Rustc/Wasm-Bindgen: 34.2%,
AssemblyScript: 24.3%) of the bugs have been Ô¨Åxed with 10
or fewer LOC. Over 96% (Emscripten: 74.2%, AssemblyScript:
71% , Rustc/Wasm-Bindgen: 69%) of all bug Ô¨Åxes have 100 or
less LOC. On the other hand, two compilers, AssemblyScript
(213.6 LOC) and Emscripten (189 LOC), have the bug Ô¨Åxes
with an average LOC greater than 100. These large Ô¨Åxes are
usually the result of the compiler developers incorporating
1051many changes into a single commit, rather than relating to the
complexity of the issue. For example, in AssemblyScript, a bug
involving missing functions when importing from a Ô¨Åle was
Ô¨Åxed in the same commit the developer cleaned the project,
inÔ¨Çating the lines of code changed [67].
VI. D ISCUSSION
Our Ô¨Åndings can be found in Table II, and we highlight
the most insightful ones here. We also discuss the threats to
validity and a limitation in our bug Ô¨Åx identiÔ¨Åcation strategy.
Qualitative Study‚Äôs Findings. Through our qualitative study,
we Ô¨Ånd several interesting trends in the Emscripten compiler
bugs. Finding 1 shows that Incompatible Data Types bugs
make up 15.75% of the 146 bugs inspected. We Ô¨Ånd many of
these bugs originate from interfaces relating to string handling
(e.g., printf) and Ô¨Ålesystems (e.g., fseek) rather than numeric
interfaces. This Ô¨Ånding can help developers diagnose similar
bugs that arise by providing them with code locations to
investigate. Finding 4 shows that changes and bugs in existing
infrastructures can cause bugs. Compiler developers need
to follow the development of leveraged infrastructures more
closely to prevent these bugs. Finding 7 reveals that many bug
reports fail to include critical debugging information, including
the compiler version, environment, or source code used that
triggers the bug. Compiler developers should include automatic
reporting tools to include this information when submitting a
bug report to aid in debugging.
Quantitative Study‚Äôs Findings. Through our quantitative
study, we obtain some insights into these compiler projects.
For example, Finding 9 shows that 77.1% of bug-inducing
inputs used were less than 20 lines of code, and developers
frequently reduce this manually. This suggests that many bugs
in these compilers can be reproduced by small inputs, which
favors the use of automated input reduction techniques.
Threats to Validity. Similar to other empirical studies, our
study is potentially subject to several threats, namely the
representativeness of the chosen compilers, the generalization
of the studied bugs, and the correctness of the analysis
methodology. Regarding the representativeness of the chosen
compilers, we choose three compilers that are the most popular
and actively maintained WebAssembly compiler projects.
Another threat concerns the generalization of the studied
bugs. We uniformly use all bug issues satisfying the selection
criteria stated in Section III-B . We exclude bugs that were found
to be irrelevant to WebAssembly after manual inspection. To
ensure correct results, we only study Ô¨Åxed bugs because unÔ¨Åxed
or unconÔ¨Årmed reports may not be real bugs.
Regarding the correctness of the analysis methodology, aside
from the analysis of test case LOC and impact, we automate all
other analyses mentioned in this paper. The manual inspections
on bugs to identify the sizes of test cases and impacts might
be biased due to our inference of the test cases. To reduce
this threat, three authors analyzed these bugs separately and
discussed inconsistent results until an agreement was reached.
Sizes of Bug Fixes. Bug Ô¨Åxes may also contain feature updates
that are not relevant to the bugs. Moreover, Ô¨Åxes for somedesign bugs require signiÔ¨Åcant changes in the underlying code
base, resulting in large bug Ô¨Åxes. In general, identifying bug-Ô¨Åx
relevant parts from a software patch is a challenging problem.
In our paper, we do not aim to distinguish this, and we observe
a few such cases result in large bug Ô¨Åxes. However, from our
manual inspection results shows that those are exceptional
cases, and they do not affect our key Ô¨Åndings and observations.
VII. R ELATED WORK
Empirical Studies on Software Defects. Much research effort
has been made to study fault related characteristics of software
systems [7], [68]‚Äì[76]. For example, Sun et al. [7] conducted
the Ô¨Årst empirical study on the characteristics of the bugs in
two mainstream compilers, GCC and LLVM. Tan et al. [30]
inspect bug root causes, impacts and components to Ô¨Ånd
characteristics within open-source projects. Eyolfson et al. [77]
study open-source project commits to identify correlations
between bugginess and commit-time characteristics.
WebAssembly Analysis Tools. There are a few tools made to
analyze WebAssembly security and execution. Wasabi [78] is
a framework to perform dynamic analysis on WebAssembly
code by instrumenting the binary Ô¨Åles to insert analysis code.
Szanto et al. [79] and Fu et al. [80] perform taint tracking
on WebAssembly to identify possible input vulnerabilities in
a module. WasmView [81] visualizes the interaction between
WebAssembly and JavaScript for a web application. WATT [82]
is an authoring tool that helps create WebAssembly libraries.
WASim uses machine-learning to automatically identify the
purpose of a WebAssembly module [83].
WebAssembly Prevalence and Security Studies. Prior work
[84] conducts a study on the prevalence of WebAssembly in
the Alexa Top 1 Million websites. Hilbig et al. [20] study over
8,000 samples from various sources, including websites, GitHub
repositories, and package managers. Lehmann et al. [85]
analyze the binary security of WebAssembly and Ô¨Ånd weak-
nesses introduced by WebAssembly compilers. WebAssembly
compiler frameworks and changes to the speciÔ¨Åcation have
been proposed to protect against Spectre [86], enhance memory
safety [87], and support constant-time operations [88]. Finally,
previous security works have focused on detecting in-browser
cryptominers [89]‚Äì[91].
VIII. C ONCLUSION
We conduct two empirical studies. In the Ô¨Årst study, we
perform a qualitative analysis on 146 bugs in Emscripten and
analyze their root causes. We conduct a quantitative analysis
on 1,054 bugs in three open-source WebAssembly compilers
and reveal various aspects of these bugs. Our code and data set
are publicly available at https://wasm-compiler-bugs.github.io/.
IX. A CKNOWLEDGMENTS
We thank the anonymous reviewers for their constructive
comments. This research was partially supported by NSF
under awards 2047980, 1916499, 1908021, 1850392, and a
Mozilla Research Award (2019). Any opinions, Ô¨Åndings, and
conclusions in this paper are those of the authors only and do
not necessarily reÔ¨Çect the views of our sponsors.
1152REFERENCES
[1]A. Haas, A. Rossberg, D. L. Schuff, B. L. Titzer, M. Holman,
D. Gohman, L. Wagner, A. Zakai, and J. Bastien, ‚ÄúBringing the web up
to speed with webassembly,‚Äù in Proceedings of the 38th ACM SIGPLAN
Conference on Programming Language Design and Implementation, ser.
PLDI 2017. New York, NY , USA: ACM, 2017, pp. 185‚Äì200. [Online].
Available: http://doi.acm.org/10.1145/3062341.3062363
[2]S. Padmanabhan and P. Jha, ‚ÄúWebassembly at ebay: A real-world use
case,‚Äù 2020. [Online]. Available: https://tech.ebayinc.com/engineering/
webassembly-at-ebay-a-real-world-use-case/
[3]A. Y . Daniel Smilkov, Nikhil Thorat, ‚ÄúIntroducing the webassembly back-
end for tensorÔ¨Çow.js,‚Äù 2020. [Online]. Available: https://blog.tensorÔ¨Çow.
org/2020/03/introducing-webassembly-backend-for-tensorÔ¨Çow-js.html
[4]E. Contributors., ‚ÄúEmscripten,‚Äù 2020. [Online]. Available: https:
//github.com/emscripten-core/emscripten
[5]T. Rust and W. W. Group, ‚Äúwasm-bindgen,‚Äù 2020. [Online]. Available:
https://github.com/rustwasm/wasm-bindgen
[6]M. Basso, ‚Äúmbasso/awesome-wasm,‚Äù 2019. [Online]. Available:
https://github.com/mbasso/awesome-wasm
[7]C. Sun, V . Le, Q. Zhang, and Z. Su, ‚ÄúToward understanding compiler
bugs in gcc and llvm,‚Äù in Proceedings of the 25th International
Symposium on Software Testing and Analysis, ser. ISSTA 2016. New
York, NY , USA: Association for Computing Machinery, 2016, p.
294‚Äì305. [Online]. Available: https://doi.org/10.1145/2931037.2931074
[8] ‚ÄúAssemblyscript,‚Äù 2020. [Online]. Available: https://assemblyscript.org/
[9]W. C. Group, ‚Äúwebassembly/wabt,‚Äù 2019. [Online]. Available:
https://github.com/WebAssembly/wabt
[10] ‚Äúgrame-cncm/faust,‚Äù Jan. 2021, original-date: 2016-11-05T13:09:11Z.
[Online]. Available: https://github.com/grame-cncm/faust
[11] ‚ÄúContents - asterius documentation,‚Äù 2020. [Online]. Available:
https://asterius.netlify.app/
[12] K. Gadd, ‚Äúkg/ilwasm,‚Äù Jan. 2021, original-date: 2015-09-01T00:13:51Z.
[Online]. Available: https://github.com/kg/ilwasm
[13] tstreiff, ‚Äútstreiff/ppci-mirror,‚Äù Jun. 2020, original-date: 2020-03-
21T17:37:58Z. [Online]. Available: https://github.com/tstreiff/ppci-mirror
[14] ‚ÄúCompiler internals,‚Äù 2020. [Online]. Available: https://tinygo.org/
compiler-internals/
[15] M. Sertic, ‚Äúmirkosertic/Bytecoder,‚Äù Jan. 2021, original-date: 2017-
04-13T10:21:59Z. [Online]. Available: https://github.com/mirkosertic/
Bytecoder
[16] T. R. Foundation, ‚ÄúThe rust programming language,‚Äù 2021. [Online].
Available: https://github.com/rust-lang/rust
[17] E. Contributors., ‚ÄúEmscripten 1.39.4 documentation,‚Äù 2020. [Online].
Available: https://emscripten.org/
[18] A. Z. David Herman, Luke Wagner, ‚Äúasm.js working draft,‚Äù 2014.
[Online]. Available: http://asmjs.org/spec/latest/
[19] A. Zakai, ‚ÄúEmscripten and the llvm webassembly backend - v8,‚Äù 2019.
[Online]. Available: https://v8.dev/blog/emscripten-llvm-wasm
[20] A. Hilbig, D. Lehmann, and M. Pradel, ‚ÄúAn empirical study of
real-world webassembly binaries: Security, languages, use cases,‚Äù in
Proceedings of the Web Conference 2021, ser. WWW ‚Äô21. New York,
NY , USA: Association for Computing Machinery, 2021, p. 2696‚Äì2708.
[Online]. Available: https://doi.org/10.1145/3442381.3450138
[21] ‚ÄúSearch - GitHub Docs,‚Äù 2020, https://docs.github.com/en/rest/reference/
search.
[22] G. Inc., ‚ÄúGithub api v3,‚Äù 2019. [Online]. Available: https://developer.
github.com/v3/
[23] G. Jin, L. Song, X. Shi, J. Scherpelz, and S. Lu, ‚ÄúUnderstanding and
detecting real-world performance bugs,‚Äù Sigplan Notices - SIGPLAN,
vol. 47, 08 2012.
[24] W. C. Group, ‚ÄúRoadmap,‚Äù 2019. [Online]. Available: https://webassembly.
org/roadmap/
[25] X. Huang, H. Zhang, X. Zhou, M. A. Babar, and S. Yang,
‚ÄúSynthesizing qualitative research in software engineering: A critical
review,‚Äù in Proceedings of the 40th International Conference on
Software Engineering, ser. ICSE ‚Äô18. New York, NY , USA: Association
for Computing Machinery, 2018, p. 1207‚Äì1218. [Online]. Available:
https://doi.org/10.1145/3180155.3180235
[26] M. Contributors, ‚ÄúConcurrency model and the event loop - JavaScript j
MDN,‚Äù 2021. [Online]. Available: https://developer.mozilla.org/en-US/
docs/Web/JavaScript/EventLoop[27] A. Trosinenko, ‚ÄúUsage of sigsetjmp/siglongjmp leads to undeÔ¨Åned
symbol references ¬∑Issue #5204.‚Äù [Online]. Available: https:
//github.com/emscripten-core/emscripten/issues/5204
[28] S. Lu, Z. Li, F. Qin, L. Tan, P. Zhou, and Y . Zhou, ‚ÄúBugbench:
Benchmarks for evaluating bug detection tools,‚Äù 2005.
[29] Z. Li, L. Tan, X. Wang, S. Lu, Y . Zhou, and C. Zhai, ‚ÄúHave things
changed now?: An empirical study of bug characteristics in modern open
source software,‚Äù 01 2006, pp. 25‚Äì33.
[30] L. Tan, C. Liu, Z. Li, X. Wang, Y . Zhou, and C. Zhai, ‚ÄúBug
characteristics in open source software,‚Äù Empirical Software Engineering,
vol. 19, no. 6, pp. 1665‚Äì1705, Dec. 2014. [Online]. Available:
http://link.springer.com/10.1007/s10664-013-9258-8
[31] F. Ocariza, K. Bajaj, K. Pattabiraman, and A. Mesbah, ‚ÄúAn empirical
study of client-side javascript bugs,‚Äù in ACM / IEEE International
Symposium on Empirical Software Engineering and Measurement, 2013,
pp. 55‚Äì64.
[32] Z. Zhou, Z. Ren, G. Gao, and H. Jiang, ‚ÄúAn empirical study
of optimization bugs in gcc and llvm,‚Äù Journal of Systems
and Software, vol. 174, p. 110884, 2021. [Online]. Available:
https://www.sciencedirect.com/science/article/pii/S0164121220302740
[33] A. Vahabzadeh, A. M. Fard, and A. Mesbah, ‚ÄúAn empirical study of
bugs in test code,‚Äù in 2015 IEEE International Conference on Software
Maintenance and Evolution (ICSME), 2015, pp. 101‚Äì110.
[34] A. Guryanov, ‚ÄúAsyncify behaving differently then emterpreter ¬∑
Issue #9823.‚Äù [Online]. Available: https://github.com/emscripten-core/
emscripten/issues/9823
[35] ‚ÄúEmterpreter ‚Äî Emscripten 1.39.11 documentation.‚Äù [Online]. Available:
https://emscripten.org/docs/porting/emterpreter.html
[36] ‚Äústd::atomic - cppreference.com.‚Äù [Online]. Available: https://en.
cppreference.com/w/cpp/atomic/atomic
[37] ‚Äú-s MAIN module=1 + upstream + function pointer calls using i64 = >
TypeError: cannot pass i64 to or from JS ¬∑Issue #9562,‚Äù 2021. [Online].
Available: https://github.com/emscripten-core/emscripten/issues/9562
[38] kichikuou, ‚ÄúCannot access packaged Ô¨Åles after memory growth ¬∑
Issue #5179.‚Äù [Online]. Available: https://github.com/emscripten-core/
emscripten/issues/5179
[39] M. Zhang, ‚Äú1.38.24 does not generate asm.js with correct variable
names with -g3/g4 ¬∑Issue #7883.‚Äù [Online]. Available: https:
//github.com/emscripten-core/emscripten/issues/7883
[40] ‚ÄúAn Empirical Study on WebAssembly Compiler Bugs ‚Äî wasm-
compiler-bugs.github.io ,‚Äù 2020, https://wasm-compiler-bugs.github.io/.
[41] ‚ÄúCan‚Äôt build incoming 64bits ¬∑Issue 4105 ,‚Äù 2020, https://github.com/
emscripten-core/emscripten/issues/4105.
[42] ‚Äúbinaryen port failing to compile on windows ¬∑issue 4821,‚Äù 2020,
https://github.com/emscripten-core/emscripten/issues/4821.
[43] ‚ÄúExclude zero-initialized values from .mem Ô¨Åle ¬∑Issue #3907 ,‚Äù 2020,
https://github.com/emscripten-core/emscripten/issues/3907.
[44] ‚Äú-mbulk-memory generates a 500 byte zero segment embedded into
.wasm ¬∑Issue #8899 ,‚Äù 2020, https://github.com/emscripten-core/
emscripten/issues/8899.
[45] ‚ÄúCrash using Haskell ‚Äòread‚Äò function ¬∑Issue 60 ¬∑tweag/asterius ,‚Äù 2020,
https://github.com/tweag/asterius/issues/60.
[46] V . Tikhonov, ‚ÄúA speciÔ¨Åc pattern of pushes to array causes a
runtime error in lib/rt/tlsf/insertblock,‚Äù 2020. [Online]. Available:
https://github.com/AssemblyScript/assemblyscript/issues/1042
[47] S. Seghers, ‚Äúu32 interpreted as i32 when passed to js,‚Äù 2019. [Online].
Available: https://github.com/rustwasm/wasm-bindgen/issues/1388
[48] ‚ÄúFilesystem accesses from pthreads are much slower than in the
main thread. ¬∑Issue 3922 ,‚Äù 2020, https://github.com/emscripten-core/
emscripten/issues/3922.
[49] ‚Äú[Question] upstream compiled binaries are 30% to 50% slower than
fastcomp ones ¬∑Issue 9817 ,‚Äù 2020, https://github.com/emscripten-core/
emscripten/issues/9817.
[50] K. Hiiragi, ‚ÄúUse pthreads freezes Ô¨Årefox nightly 42.0a1,‚Äù 2015. [Online].
Available: https://github.com/emscripten-core/emscripten/issues/3636
[51] GraDKh, ‚ÄúWebassembly: wrong conversion from double to int64
when outlining limit isn‚Äôt 0,‚Äù 2018. [Online]. Available: https:
//github.com/emscripten-core/emscripten/issues/6352
[52] ‚Äú-g4 and wasm2js should generate JS source map or be an error ¬∑Issue
8743 ,‚Äù 2020, https://github.com/emscripten-core/emscripten/issues/8743.
[53] ‚ÄúSafe heap=1 breaks source map generation for wasm,‚Äù 2018. [Online].
Available: https://github.com/emscripten-core/emscripten/issues/6534
[54] E. Cheng, ‚ÄúBin-crate build fail with new lld linker in windows,‚Äù 2018.
[Online]. Available: https://github.com/rust-lang/rust/issues/48948
1253[55] M. Zhang, ‚Äú1.38.24 does not generate asm.js with correct variable
names with -g3/g4,‚Äù 2019. [Online]. Available: https://github.com/
emscripten-core/emscripten/issues/7883
[56] S. Clegg, ‚ÄúError on invalid archive member,‚Äù 2018. [Online]. Available:
https://github.com/emscripten-core/emscripten/pull/6961
[57] V . Tikhonov, ‚ÄúRuntime error during gc,‚Äù 2020. [Online]. Available:
https://github.com/AssemblyScript/assemblyscript/issues/1038
[58] makc, ‚Äúabort(‚Äùalignment fault‚Äù) at jsstacktrace,‚Äù 2016. [Online].
Available: https://github.com/emscripten-core/emscripten/issues/4760
[59] B. Vibber, ‚ÄúAssertion failure in wasm-ld linking libvpx with pthreads,‚Äù
2019. [Online]. Available: https://github.com/emscripten-core/emscripten/
issues/9155
[60] ‚Äî‚Äî, ‚Äúerror ‚Äùvariable fs is undeclared‚Äù in 1.39.7 with closure compiler,‚Äù
2020. [Online]. Available: https://github.com/emscripten-core/emscripten/
issues/10385
[61] A. WeissÔ¨Çog, ‚ÄúCode-gen bug related to 32-bit Ô¨Çoats (actually: rand()),‚Äù
2016. [Online]. Available: https://github.com/WebAssembly/binaryen/
issues/817
[62] Y . Delendik, ‚ÄúDwarf information does not contain absolute Ô¨Åle locations
for generics,‚Äù 2018. [Online]. Available: https://github.com/rust-lang/
rust/issues/54408
[63] A. Zeller and R. Hildebrandt, ‚ÄúSimplifying and isolating failure-inducing
input,‚Äù IEEE Trans. Softw. Eng., vol. 28, no. 2, p. 183‚Äì200, Feb. 2002.
[Online]. Available: https://doi.org/10.1109/32.988498
[64] Q. Luo, ‚ÄúAutomatic performance testing using input-sensitive proÔ¨Åling,‚Äù
inProceedings of the 2016 24th ACM SIGSOFT International Symposium
on Foundations of Software Engineering, ser. FSE 2016. New York,
NY , USA: Association for Computing Machinery, 2016, p. 1139‚Äì1141.
[Online]. Available: https://doi.org/10.1145/2950290.2983975
[65] S. Herfert, J. Patra, and M. Pradel, ‚ÄúAutomatically reducing tree-structured
test inputs,‚Äù in Proceedings of the 32nd IEEE/ACM International
Conference on Automated Software Engineering, ser. ASE 2017. IEEE
Press, 2017, p. 861‚Äì871.
[66] M. H ¬®oschele and A. Zeller, ‚ÄúMining input grammars from dynamic
taints,‚Äù in Proceedings of the 31st IEEE/ACM International Conference
on Automated Software Engineering, ser. ASE 2016. New York,
NY , USA: Association for Computing Machinery, 2016, p. 720‚Äì725.
[Online]. Available: https://doi.org/10.1145/2970276.2970321
[67] W. I. B. I. found on WasmBoy, ‚ÄúWeird importing bug i found on
wasmboy,‚Äù 2018. [Online]. Available: https://github.com/AssemblyScript/
assemblyscript/issues/29
[68] A. Chou, J. Yang, B. Chelf, S. Hallem, and D. Engler, ‚ÄúAn empirical
study of operating systems errors,‚Äù Operating Systems Review (ACM),
vol. 35, 09 2001.
[69] S. Lu, S. Park, E. Seo, and Y . Zhou, ‚ÄúLearning from mistakes: a
comprehensive study on real world concurrency bug characteristics,‚Äù
inASPLOS, 2008.
[70] S. K. Sahoo, J. Criswell, and V . Adve, ‚ÄúAn empirical study of reported
bugs in server software with implications for automated bug diagnosis,‚Äù
inProceedings of the 32nd ACM/IEEE International Conference on
Software Engineering - Volume 1, ser. ICSE ‚Äô10. New York, NY , USA:
Association for Computing Machinery, 2010, p. 485‚Äì494. [Online].
Available: https://doi.org/10.1145/1806799.1806870
[71] F. Thung, S. Wang, D. Lo, and L. Jiang, ‚ÄúAn empirical study of bugs in
machine learning systems,‚Äù in 2012 IEEE 23rd International Symposium
on Software Reliability Engineering, 2012, pp. 271‚Äì280.
[72] Z. Yin, D. Yuan, Y . Zhou, S. Pasupathy, and L. Bairavasundaram, ‚ÄúHow
do Ô¨Åxes become bugs?‚Äù in Proceedings of the 19th ACM SIGSOFT
Symposium and the 13th European Conference on Foundations of
Software Engineering, ser. ESEC/FSE ‚Äô11. New York, NY , USA:
Association for Computing Machinery, 2011, p. 26‚Äì36. [Online].
Available: https://doi.org/10.1145/2025113.2025121
[73] Z. Yin, X. Ma, J. Zheng, Y . Zhou, L. N. Bairavasundaram, and
S. Pasupathy, ‚ÄúAn empirical study on conÔ¨Åguration errors in commercial
and open source systems,‚Äù in Proceedings of the Twenty-Third ACM
Symposium on Operating Systems Principles, ser. SOSP ‚Äô11. New York,
NY , USA: Association for Computing Machinery, 2011, p. 159‚Äì172.
[Online]. Available: https://doi.org/10.1145/2043556.2043572
[74] Y . Zhang, Y . Chen, S.-C. Cheung, Y . Xiong, and L. Zhang, ‚ÄúAn
empirical study on tensorÔ¨Çow program bugs,‚Äù in Proceedings of the
27th ACM SIGSOFT International Symposium on Software Testing
and Analysis, ser. ISSTA 2018. New York, NY , USA: Association
for Computing Machinery, 2018, p. 129‚Äì140. [Online]. Available:
https://doi.org/10.1145/3213846.3213866[75] J. Aranda and G. Venolia, ‚ÄúThe secret life of bugs: Going past the errors
and omissions in software repositories,‚Äù in 2009 IEEE 31st International
Conference on Software Engineering, 2009, pp. 298‚Äì308.
[76] Weining Gu, Z. Kalbarczyk, Ravishankar, K. Iyer, and Zhenyu Yang,
‚ÄúCharacterization of linux kernel behavior under errors,‚Äù in 2003
International Conference on Dependable Systems and Networks, 2003.
Proceedings., 2003, pp. 459‚Äì468.
[77] J. Eyolfson, L. Tan, and P. Lam, ‚ÄúCorrelations between bugginess and
time-based commit characteristics,‚Äù Empirical Software Engineering,
vol. 19, no. 4, pp. 1009‚Äì1039, Aug. 2014. [Online]. Available:
https://doi.org/10.1007/s10664-013-9245-0
[78] D. Lehmann and M. Pradel, ‚ÄúWasabi: A framework for dynamically
analyzing webassembly,‚Äù in Proceedings of the Twenty-Fourth
International Conference on Architectural Support for Programming
Languages and Operating Systems, ser. ASPLOS ‚Äô19. New York,
NY , USA: Association for Computing Machinery, 2019, p. 1045‚Äì1058.
[Online]. Available: https://doi.org/10.1145/3297858.3304068
[79] A. Szanto, T. Tamm, and A. Pagnoni, ‚ÄúTaint tracking for
webassembly,‚Äù CoRR, vol. abs/1807.08349, 2018. [Online]. Available:
http://arxiv.org/abs/1807.08349
[80] W. Fu, R. Lin, and D. Inge, ‚ÄúTaintassembly: Taint-based information
Ô¨Çow control tracking for webassembly,‚Äù CoRR, vol. abs/1802.01050,
2018. [Online]. Available: http://arxiv.org/abs/1802.01050
[81] A. Romano and W. Wang, ‚ÄúWasmview: Visual testing for webassembly
applications,‚Äù in Proceedings of the 42nd International Conference on
Software Engineering Companion, ser. ICSE‚Äô20 Companion. New
York, NY , USA: Association for Computing Machinery, 2020. [Online].
Available: https://doi.org/10.1145/3377812.3382155
[82] H. Jeong, J. Jeong, S. Park, and K. Kim, ‚ÄúWatt : A novel web-based
toolkit to generate webassembly-based libraries and applications,‚Äù in
2018 IEEE International Conference on Consumer Electronics (ICCE),
Jan 2018, pp. 1‚Äì2.
[83] A. Romano and W. Wang, ‚ÄúWasim: Understanding webassembly applica-
tions through classiÔ¨Åcation,‚Äù in 35th IEEE/ACM International Conference
on Automated Software Engineering (ASE), 2020, pp. 1321‚Äì1325.
[84] M. Musch, C. Wressnegger, M. Johns, and K. Rieck, ‚ÄúNew kid on
the web: A study on the prevalence of webassembly in the wild,‚Äù in
International Conference on Detection of Intrusions and Malware, and
Vulnerability Assessment. Springer, 2019, pp. 23‚Äì42.
[85] D. Lehmann, J. Kinder, and M. Pradel, ‚ÄúEverything old is new again:
Binary security of webassembly,‚Äù in 29th USENIX Security Symposium
(USENIX Security 20). USENIX Association, Aug. 2020, pp. 217‚Äì234.
[Online]. Available: https://www.usenix.org/conference/usenixsecurity20/
presentation/lehmann
[86] S. Narayan, C. Disselkoen, D. Moghimi, S. Cauligi, E. Johnson,
Z. Gang, A. Vahldiek-Oberwagner, R. Sahita, H. Shacham, D. Tullsen,
and D. Stefan, ‚ÄúSwivel: Hardening WebAssembly against Spectre,‚Äù in
USENIX Security Symposium. USENIX, August 2021.
[87] C. Disselkoen, J. Renner, C. Watt, T. GarÔ¨Ånkel, A. Levy, and D. Stefan,
‚ÄúPosition paper: Bringing memory safety to WebAssembly,‚Äù in Hardware
and Architectural Support for Security and Privacy (HASP). ACM,
June 2019.
[88] J. Renner, S. Cauligi, and D. Stefan, ‚ÄúConstant-time WebAssembly,‚Äù in
Principles of Secure Compilation (PriSC), January 2018.
[89] R. K. Konoth, E. Vineti, V . Moonsamy, M. Lindorfer, C. Kruegel,
H. Bos, and G. Vigna, ‚ÄúMinesweeper: An in-depth look into drive-by
cryptocurrency mining and its defense,‚Äù in Proceedings of the 2018
ACM SIGSAC Conference on Computer and Communications Security,
ser. CCS ‚Äô18. New York, NY , USA: ACM, 2018, pp. 1714‚Äì1730.
[Online]. Available: http://doi.acm.org/10.1145/3243734.3243858
[90] A. Kharraz, Z. Ma, P. Murley, C. Lever, J. Mason, A. Miller, N. Borisov,
M. Antonakakis, and M. Bailey, ‚ÄúOutguard: Detecting in-browser covert
cryptocurrency mining in the wild,‚Äù in The World Wide Web Conference,
ser. WWW ‚Äô19. New York, NY , USA: ACM, 2019, pp. 840‚Äì852.
[Online]. Available: http://doi.acm.org/10.1145/3308558.3313665
[91] A. Romano, Y . Zheng, and W. Wang, ‚ÄúMinerray: Semantics-aware
analysis for ever-evolving cryptojacking detection,‚Äù in Proceedings of
the 35th IEEE/ACM International Conference on Automated Software
Engineering, ser. ASE ‚Äô20. New York, NY , USA: Association
for Computing Machinery, 2020, p. 1129‚Äì1140. [Online]. Available:
https://doi.org/10.1145/3324884.3416580
1354