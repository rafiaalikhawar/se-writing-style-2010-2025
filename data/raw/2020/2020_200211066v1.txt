Interactive, Effort-Aware Library Version Harmonization
Kaifeng Huang
Fudan University
ChinaBihuan Chen
Fudan University
ChinaBowen Shi
Fudan University
China
Ying Wang
Fudan University
ChinaCongying Xu
Fudan University
ChinaXin Peng
Fudan University
China
ABSTRACT
As a mixed result of intensive dependency on third-party libraries, flex-
ible mechanism to declare dependencies, and increased number of mod-
ules in a project, multiple versions of the same third-party library are
directly depended in different modules of a project. Such library ver-
sion inconsistencies can increase dependency maintenance cost, or
even lead to dependency conflicts when modules are inter-dependent.
Although automated build tools (e.g., Maven’s enforcer plugin) pro-
vide partial support to detect library version inconsistencies, they do
not provide any support to harmonize inconsistent library versions.
We first conduct a survey with 131 Java developers from GitHub
to retrieve first-hand information about the root causes, detection
methods, reasons for fixing or not fixing, fixing strategies, fixing ef-
forts, and tool expectations on library version inconsistencies. Then,
based on the insights from our survey, we propose LibHarmo , an in-
teractive, effort-aware library version harmonization technique, to
detect library version inconsistencies, interactively suggest a harmo-
nized version with the least harmonization efforts based on library
API usage analysis, and refactor build configuration files.
LibHarmo is currently developed for Java Maven projects. Our
experimental study on 443 highly-starred Java Maven projects from
GitHub indicates that i) LibHarmo identifies 621 library version in-
consistencies covering 152 (34.3%) of projects, and ii) the average
harmonization efforts are that 1 and 12 library API calls are affected,
respectively due to the deleted and changed library APIs in the har-
monized version. 5 library version inconsistencies have been con-
firmed, and 1 of them has been already harmonized by developers.
1 INTRODUCTION
With the increased diversity and complexity of modern systems, mod-
ular development [ 69] has become a common practice to encourage
reuse, improve maintainability, and provide efficient ways for large
teams of developers to collaborate [ 35]. Therefore, automated build
tools (e.g., Maven) provide mechanisms (e.g., the aggregation mecha-
nism in Maven [ 3]) to support multi-module projects for the ease of
management and build. In contrast to the benefits that multi-module
project brings to software development, one of the drawbacks is the
sophisticated dependency management (colloquially termed as “de-
pendency hell” [ 36]), exacerbated by the increased number of mod-
ules and the intensive dependency on third-party libraries. In this
paper, we focus on the dependency management in Maven projects
as Maven has dominated the build tool market for many years [ 59].
Problem. It is quite common that different modules of a project
directly depend on the same third-party libraries. Maven providesflexible mechanisms for child modules to either inherit third-party li-
brary dependencies from parent modules (e.g., the inheritance mech-
anism [ 3]) or declare their own third-party library dependencies. Be-
sides, Maven allows the version of a third-party library dependency
to be explicitly hard-coded or implicitly referenced from a property
which can be declared in parent modules. Therefore, library version
inconsistency can be easily caused in practice; i.e., multiple versions
of the same third-party library are directly depended in different
modules of a project. Even if the same version of a third-party li-
brary is directly depended in different modules, the versions can be
separately declared instead of referencing a common property. We
refer to it as library version false consistency as it is likely to turn into
library version inconsistency when there is an incomplete library
version update (e.g., a developer updates the version in one of the
modules). Intuitively, library version inconsistency could increase
dependency maintenance cost in the long run, or even lead to de-
pendency conflicts [73] when modules are inter-dependent.
For example, an issue HADOOP-6800 [1] was reported to the project
Apache Hadoop , and said that “ multiple versions of the same library
JAR are being pulled in .... Dependent subprojects use different versions.
E.g. Common depends on Avro 1.3.2 while MapReduce depends on 1.3.0.
Since MapReduce depends on Common, this has the potential to cause
a problem at runtime ”. This issue was prioritized as a blocker issue,
and was resolved in 30 days. Developers found other library version
inconsistencies, and finally harmonized the inconsistent versions
of libraries avro ,commons-logging ,commons-logging-api and
jets3t across modules Common ,MapReduce andHDFS .
Maven’s enforcer plugin uses a dependency convergence rule to de-
tect multiple versions of the same third-party library along the tran-
sitive dependency graph; i.e., if a module has two dependencies, A
andB, and both depends on the same dependency, C, this rule will fail
the build if Adepends on a different version of Cthan the version of
Cdepended on by B. In that sense, this rule cannot detect library ver-
sion inconsistencies across modules that are not inter-dependent,
and does not provide any support to harmonize inconsistent library
versions. As project developers have no direct control to harmonize
the inconsistent library versions in transitive dependencies, we only
consider direct dependencies across modules.
Approach. To better address the problem, e.g., by realizing prac-
tical solutions that are acceptable by developers, it is important to first
understand developers’ practices on library version inconsistencies.
Therefore, we conduct a survey with 131 Java developers from GitHub
to retrieve first-hand information about the root causes, detection
methods, reasons for fixing or not fixing, fixing strategies, fixing ef-
forts, and tool expectations on library version inconsistencies. 90.8%
of participants experienced library version inconsistency, and 69.4%
1arXiv:2002.11066v1  [cs.SE]  25 Feb 2020ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States Kaifeng Huang, Bihuan Chen, Bowen Shi, Ying Wang, Congying Xu, and Xin Peng
consider it as a problem in project maintenance. Our survey sug-
gests several insights, e.g., tools are needed to proactively locate and
harmonize inconsistent library versions, and such tools need to in-
teract with developers and provide API-level harmonization efforts.
Then, inspired by the insights from our developer survey, we pro-
pose LibHarmo , the first interactive, effort-aware technique to har-
monize inconsistent library versions in Java Maven projects. Lib-
Harmo works in three steps. First, it identifies library version in-
consistencies by analyzing build configuration files (i.e., POM files).
Second, for each library version inconsistency, it suggests a harmo-
nized version with the least harmonization efforts (e.g., the number
of calls to library APIs that are deleted and changed in the harmo-
nized version) based on library API usage analysis and interaction
with developers. Finally, if developers determine to harmonize, it
refactors POM files, and also suggests replacement library APIs to
some deleted library APIs based on API documentations.
We have run LibHarmo against 443 highly-starred Java Maven
projects from GitHub. Our experimental results have indicated that
i)LibHarmo detects 621 library version inconsistencies, which cover
152 (34.3%) of projects, and ii) the average harmonization efforts are
that 1 and 2 of the 24 called library APIs are respectively deleted and
changed in the harmonized version, totally affecting 1 and 12 library
API calls. Moreover, 5 library version inconsistencies have been
confirmed, and 1 of them has been harmonized by developers.
Contributions. This paper makes the following contributions.
•We conducted the first survey with 131 Java developers from GitHub
to retrieve first-hand information about the practices and tool ex-
pectations on library version inconsistencies.
•We proposed the first interactive, effort-aware library version har-
monization technique, LibHarmo , based on our survey insights.
•We evaluated LibHarmo on 443 highly-starred Java Maven projects
from GitHub, and found 621 library version inconsistencies. 5 of
them have been confirmed with 1 being harmonized.
2 DEVELOPER SURVEY
Our online survey is designed for developers who participated in the
development of Java Maven multi-module projects. Therefore, we se-
lected Java Maven multi-module projects from GitHub, and also re-
stricted that the number of stars was larger than 200 to ensure the
project popularity. Finally, we had 443 projects. From these projects,
we collected 5,316 developers whose email on profile page was valid.
We sent an email to each of the 5,316 developers to clarify the library
version inconsistency problem and kindly ask them to participate in
our online questionnaire survey (the questions are shown in Table 1,
and the complete questionnaire with options is available at [ 4]). We
promised that their participation would remain confidential, and all
the analysis and reporting would be based on aggregated responses.
Our survey consists of 14 questions, covering the following seven
aspects, to learn about their professional background, practices and
tool expectations on library version inconsistencies.
Professional Background (Q1–Q4). In response to the invita-
tion emails, 131 developers finished the questionnaire within seven
days (i.e., a participation rate of 2.5%). Of all participants, 44.3% have
more than 10 years of Java programming experience, 25.2% have 5 to
10 years, and 30.5% have less than 5 years. 47.3% participated in theTable 1: Survey Questions
Q1 How many years of Java programming experience do you have?
Q2 How many modules in a Java project did you participate in?
Q3 Have you ever encountered library version inconsistency?
Q4 Is library version inconsistency a problem during project maintenance?
Q5 What are the root causes of library version inconsistencies?
Q6 How did you detect library version inconsistencies?
Q7 What are the reasons of not fixing library version inconsistencies?
Q8 What are the reasons of fixing library version inconsistencies?
Q9 Which version do you use as the harmonized version to fix library version inconsistencies?
Q10 How do you fix library version inconsistencies?
Q11 How much time do you spend in fixing library version inconsistencies?
Q12 Which part of it is most time-consuming in fixing library version inconsistencies?
Q13 Is an automatic library version harmonization tool useful for library management?
Q14 Which features would be useful for an automatic library version harmonization tool?
development of more than 10 modules in one project, 23.7% partici-
pated in 5 to 10 modules, and 29.0% participated in less than 5 mod-
ules. 90.8% of participants experienced library version inconsistency,
and 69.4% consider it as a problem in project maintenance. The par-
ticipants have relatively good experience in modular development
as well as in handling library version inconsistencies.
Root Causes (Q5). 67.1% and 65.8% named unawareness of the
same library in other modules and backward incompatibility issues
in library versions as the major root causes of library version incon-
sistencies. Different development schedule among different modules
(46.1%), unawareness of the library version inconsistency problem
(31.6%), and not regarding library version inconsistency as a prob-
lem (23.7%) are the further root causes. Other minor root causes
(14.5%) include bad dependency management hygiene, unawareness
of new library versions, usage difficulty with Maven, etc.
Detection Methods (Q6). Being asked about the detection or
manifestation of library version inconsistencies, bugs due to con-
flicting library versions [ 73] (72.4%) is the main way to manifest,
followed by bugs due to library API behavior changes (47.4%). Man-
ual investigation of module POM files (46.1%) is the main way to de-
tect, followed by communication with developers of other modules
(14.5%) and adoption of Maven’s enforcer plugin (10.5%).
Reasons for Fixing or not Fixing (Q7–Q8). The participants
reported four main reasons for not fixing: heavy fixing efforts due to
backward incompatibility issues (45.3%), heavy fixing efforts due to
intensive library API dependency (38.7%), fixing difficulty due to dif-
ferent development schedule in different modules (36.0%), and no
serious consequence occurred (30.7%). 6.6% emphasized that they
always selected to fix. On the other hand, there are three main rea-
sons for fixing: avoiding great maintenance efforts in the long run
(68.4%), ensuring consistent library API behaviors across modules
(63.2%), and serious consequences occurred (e.g., bugs) (55.3%).
Fixing Strategies (Q9–Q10). When harmonizing the inconsis-
tent library versions, 77.6% used one of the newer versions than all
currently declared versions with the least harmonization efforts, but
29.0% chose one of the currently declared versions with the least
harmonization efforts. Besides, 61.8% harmonized the versions in all
of the affected modules, while 38.2% only harmonized the versions
in some of the affected modules.
Fixing Efforts (Q11–Q12). 50.0% spent hours in fixing library
version inconsistencies, 32.9% even spent days, and only 11.8% spent
minutes. Besides, locating all inconsistent library versions (56.7%),
determining the harmonized version (49.3%), and refactoring the
source code (48.0%) are the most time-consuming steps in fixing.
2Interactive, Effort-Aware Library Version Harmonization ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States
Other time-consuming steps include refactoring the POM files (32.0%)
and verifying the fix through regression testing (6.7%).
Tool Expectations (Q13–Q14). 45.6% thought an automated li-
brary version harmonization tool would be useful, but 14.0% thought
it would not be useful mostly because they already adopted Maven’s
enforcer plugin. 46.5% thought it depended on how well it would be
integrated into the build process, how automated it would be, etc.
With respect to the most useful feature in such a tool, detecting all
library version inconsistencies (75.9%) and suggesting the harmo-
nized version (71.4%) are the most useful ones, followed by reporting
detailed API-level fixing efforts (49.1%) and refactoring the POM
files (42.0%). Surprising, refactoring the source code (25.0%) is less
useful than all the previous features.
Insights. From our survey results, we have several insights. I1:
tools are needed to help developers proactively locate and harmo-
nize inconsistent library versions, as library version inconsistencies
are mostly manually detected, or passively found after serious conse-
quences. I2:developers should interact with such tools to determine
where and whether to harmonize, as library version inconsistencies
span multiple modules that have different development schedule,
and might be not fixed due to heavy harmonization efforts. I3:such
tools need to provide developers with API-level harmonization ef-
forts, as API backward incompatibility, API dependency intensity,
and API behavior consistency are key factors for developers to de-
termine whether to harmonize. I4:such tools need to be integrated
into the build process for the ease of adoption.
3 METHODOLOGY
Based on the insights I1,I2andI3from our developer survey, we pro-
pose the first interactive, effort-aware technique, named LibHarmo , to
assist developers in harmonizing inconsistent library versions (and
falsely consistent library versions). As shown in Fig. 1, it takes as an
input a Java Maven project repository, and interactively works with
developers in three steps, i.e., detecting inconsistency (Sec. 3.1), sug-
gesting harmonized version (Sec. 3.2), and refactoring POMs and
suggesting APIs (Sec. 3.3). LibHarmo also relies on a library data-
base (Sec. 3.4) to provide JAR files and documentations. Currently,
LibHarmo is at the stage of a prototype, and thus it is not integrated
into the build process and does not satisfy the insight I4.
3.1 Detecting Inconsistency
The first step of LibHarmo is composed of three sub-steps: it first gen-
erates the POM inheritance graph, then analyzes the inheritance re-
lations to resolve library dependencies in each POM, and finally iden-
tifies library version inconsistencies and false consistencies.
Generating POM Inheritance Graph. Maven provides the in-
heritance mechanism [ 3] to inherit elements (e.g., dependency) from
a parent POM. It does not support multiple inheritance, however, it
indirectly supports the concept by using the import scope [ 2]. Maven
also does not allow cyclic inheritance. Therefore, the inheritance
relations among POMs in a project form a directed acyclic graph. We
define such a POM inheritance graph Gas a 2-tuple⟨M,E⟩, whereM
denotes all the POMs in a project, and Edenotes the inheritance
relations among the POMs in M. Each inheritance relation e∈Eis
denoted as a 2-tuple ⟨m1,m2⟩, where m1,m2∈M , and m1inherits
m2(i.e., m2is the parent POM of m1).To constructGof a project, LibHarmo scans its repository recur-
sively to collect all the local POMs and put them into M. Then, for
each POM minM,LibHarmo parses it to locate its parent POMs
based on the inheritance mechanism and the import scope; i.e., Lib-
Harmo parses the parent section and the dependencyManagement
section. For each located parent POM m′, an inheritance relation
e=⟨m,m′⟩is generated and put into E. Asm′can be a remote POM,
LibHarmo crawls it from Maven repository, and puts it into M.Eis
constructed after all the local and remote POMs in Mare parsed.
Example 3.1. Fig. 2 presents a generated POM inheritance graph,
where the nodes represent POMs, the arrows represent inheritance
relations, and the dotted lines link to excerpts from POMs. Here A,B,
C,DandEare local POMs, and Ris a remote POM. Bhas two parent
POMs, AandR. In particular, Binherits Aby declaring the groudId ,
artifactId andversion ofAin the parent section (Line 1–5 in B).
Binherits Rby declaring the groudId ,artifactId andversion of
Rin a dependency with type being pom andscope being import in
thedependencyManagement section (Line 7–17 in B).
Resolving Library Dependencies. We first introduce Maven’s
dependency declaration mechanisms before diving into the details.
Thedependencies section contains the library dependencies that a
POM declares to use, and such library dependencies will be automat-
ically inherited by child POMs, whereas the dependencyManagement
section contains the library dependencies that a POM declares to
manage, and such library dependencies will be used/inherited only
when they are explicitly declared in the dependencies section with-
out specifying their version. Moreover, the version of a library de-
pendency can be explicitly declared by a hard-coded value or im-
plicitly declared via referencing a property. A property can be over-
written by declaring the same property with a different value.
Example 3.2. In Fig. 2, Bdeclares two library dependencies Bwants
to use, and the versions are hard-coded (Line 20–29 in B).Cdeclares
one library dependency Cwants to use (Line 10–16 in C); and Calso
declares one library dependency Cwants to manage (Line 1–9 in C),
and the version references a property, guava.version , which is
declared in Line 5–7 in A.Dautomatically inherits the library depen-
dency in Line 10–16 in C; and Dalso inherits the managed library
dependency in Line 1–9 in Cby explicitly declaring it in Line 1–6 in
D.Einherits from Dthe two library dependencies Dinherits from C.
Based on the dependency declaration mechanisms, all the library
dependencies of a POM can be resolved based on the resolved library
dependencies of its ancestor POMs. To ease the detection and harmo-
nization of inconsistencies and false consistencies, we first define a
library dependency das a 6-tuple⟨lib,ver,pro,mlib,mver,mpro⟩,
where libdenotes a library, uniquely identified by its groupId (i.e.,
the organization libbelongs to) and artifactId (i.e., the name of lib);
verdenotes the resolved version number of lib;prodenotes the prop-
erty that the version of libreferences, and it will be null when the ver-
sion of libis hard-coded; mlibdenotes the POM that owns libeither
by declaration or inheritance; mverdenotes the POM that declares
the version of lib; and mprodenotes the POM that declares pro, and
it will be null when proisnull .
For each POM minM, we resolve m’ library dependencies Dm
that are declared in mor inherited from ancestors of m. To this end,
3ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States Kaifeng Huang, Bihuan Chen, Bowen Shi, Ying Wang, Congying Xu, and Xin Peng
Detecting InconsistencyProject RepositorySuggesting Harmonized VersionRefactoring POMs and SuggestingAPIsInconsistencies and False ConsistenciesHarmonization Efforts
Library Database
Figure 1: An Overview of LibHarmo
<parent><groupId>A</groupId><artifactId>A</artifactId><version>1.0</version></parent>…<dependencyManagement><dependencies><dependency><groupId>R</groupId><artifactId>R</artifactId><version>1.0</version><type>pom</type><scope>import</scope></dependency></dependencies></dependencyManagement>…<dependencies><dependency><groupId>commons-io</groupId><artifactId>commons-io</artifactId><version>2.5</version></dependency><dependency><groupId>com.google.guava</groupId><artifactId>guava</artifactId><version>23.0</version></dependency><dependencies><dependencies></dependencies>A<project><groupId>A</groupId><artifactId>A</artifactId><version>1.0</version><properties><guava.version>16.0.1</guava.version><properties>…</project>
<dependencies><dependency><groupId>com.google.guava</groupId><artifactId>guava</artifactId></dependency></dependencies>CDEBR123456789101112131415161718192021222324252627282930123456789<dependencyManagement><dependencies><dependency><groupId>com.google.guava</groupId><artifactId>guava</artifactId><version>${guava.version}</version></dependency></dependencies></dependencyManagement><dependencies><dependency><groupId>commons-io</groupId><artifactId>commons-io</artifactId><version>2.5</version></dependency></dependencies>1234567891011121314151612345612
Figure 2: An Example of POM Inheritance Graph
Table 2: An Example of Resolving Library Dependencies
E
D <guava, , , E, , >
C <guava, , guava.version, E, C, > <commons-io, 2.5, null, E, C, null>
A <guava, 16.0.1, guava.version, E, C, A> <commons-io, 2.5, null, E, C, null>
LibHarmo performs a breath-first search on Gto visit mandm’s an-
cestors while following Maven’s “nearest definition wins” and “first
declaration wins” strategy [ 2]. For each visited POM, we parse each li-
brary dependency in the dependencies section to create a dand put
dtoDm, and analyze the properties anddependencyManagement
section to resolve the unresolved version of library dependencies in
Dm. Finally, we get all library dependencies D=Ð
m∈MDm.
Example 3.3. Table 2 presents the the process of resolving library
dependencies for Ein Fig. 2 along its inheritance hierarchy. At E, as
Edoes not declare any library dependency, no library dependency is
created. Next, at E’s parent D,guava is declared but its version is not
declared. Hence, d1is created with liband mlibset to guava andE.
Next, at D’s parent C,d1’s version is declared by referencing a prop-
erty. Thus, d1’sproandmveris set to guava.version andC. Mean-
while, Cdeclares commons-io and hard-codes its version. Thus, d2is
created as⟨commons-io ,2.5,null ,E,C,null⟩. Finally, at C’s par-
entA, the property guava.version is declared, and thus d1’sver
and mprois set to 16.0.1 andA.
Identifying Inconsistencies and False Consistencies. As we
do not have direct control over remote POMs, we remove from Dthe
library dependencies whose mlibis a remote POM. However, it is pos-
sible that the library dependencies of local POMs are inherited from
remote POMs. To detect library version inconsistencies and false con-
sistencies, we first identify the libraries LfromD, i.e.,L={d.lib|
d1= <guava, 16.0.1, guava.version, E, C, A> d2= <commons-io, 2.5, null, E, C, null>d3= <guava, 16.0.1, guava.version, D, C, A> d4= <commons-io, 2.5, null, D, C, null>d5= <commons-io, 2.5, null, C, C, null>d6= <commons-io, 2.5, null, B, B, null>d7= <guava, 23.0, null, B, B, null> Figure 3: The Resolved Library Dependencies of Fig. 2
d∈D} . Then, for each lib∈L, we find all the library dependencies
Dlib={d|d∈D∧ d.lib=lib}. Finally, we determine the consis-
tency ofDlibby classifying it into the following four types.
•Inconsistency (IC).Dlibbelongs to the type of inconsistency if the
library dependencies in Dlibdo not have the same version; i.e.,
Dlibsatisfies|Dlib|>1∧∃d1,d2∈D lib,d1.ver,d2.ver.
•True Consistency (TC). Dlibbelongs to the type of true consistency
if all the library dependencies in Dlibhave the same version by
referencing one property; i.e., Dlibsatisfies|Dlib|>1∧∀d1,d2
∈D lib,d1.pro,null∧d1.pro=d2.pro∧d1.mpro=d2.mpro.
•False Consistency (FC). Dlibbelongs to the type of false consis-
tency if all the library dependencies in Dlibhave the same version
but do not reference one property (i.e., the version is resolved
by referencing different properties or by hard-coding); i.e., Dlib
satisfies ∃d1,d2∈D lib,d1.pro,null∧d2.pro,null∧(d1.pro,
d2.pro∨d1.mpro,d2.mpro)∨∃d∈D lib,d.pro=null.
•Single Library (SL). Dlibbelongs to the type of single library if
there is only one library dependency in Dlib(i.e.,|Dlib|=1).
Example 3.4. Fig. 3 presents all the resolved library dependencies
of Fig. 2, which involve two libraries guava andcommons-io . Hence,
we haveDдuava={d1,d3,d7}andDcommons−io={d2,d4,d5,d6}.
Dдuavabelongs to IC, andDcommons−iobelongs to FC.
3.2 Suggesting Harmonized Version
For a false consistency, the same version is adopted across different
library dependencies, and it is likely to turn into an inconsistency if
there is an incomplete library version update (e.g., a developer only
updates the version of some of the library dependencies). Hence, it
also needs to be harmonized to become a true consistency (which
will be introduced in Sec. 3.3). Here we directly suggest the currently
used version as the harmonized version to reduce the harmonization
efforts. On the other hand, for an inconsistency Dlib, we first ana-
lyze the harmonization efforts at the library API level, and then in-
teractively suggest a harmonized version with the least efforts.
Analyzing Harmonization Efforts. Basically, we measure the
harmonization efforts in terms of the number of calls to library APIs
that are deleted or changed in the harmonized version, because the
deleted library APIs may cause program crashes, while the changed
4Interactive, Effort-Aware Library Version Harmonization ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States
library APIs may introduce API breaking. Hence, for each d∈D lib,
LibHarmo first applies JavaParser [ 70] on the srcfolder that has
the same prefix path to d.mlib, together with the JAR files from our
library database (see Sec. 3.4), to locate API calls to d. Thus, we have
a set of called library APIs Adand a set of library API calls Cd.
Then, LibHarmo determines the candidate library versions Vdfor
harmonization from our library database which contains all the re-
leased versions of d.lib. Here, we compute Vdas the versions that
are no older than the highest version in Dlibas developers tend to
use newer versions, as suggested by our survey. Next, for each can-
didate version v,LibHarmo locates the called library APIs in dthat
are deleted or changed in the candidate version v. Here, an library
API is deleted in vif there is no library API with the same fully qual-
ified name in v. An library API is changed in vif its fully qualified
name is not changed but the body code of the library API or the code
of the methods in its static call graph is changed. LibHarmo uses
java-callgraph [ 30] to extract the static call graph. Thus, we decom-
poseAdinto three setsADv
d,ACv
dandAUv
d, respectively rep-
resenting the called library APIs in dthat are deleted, changed and
unchanged in v. Correspondingly, we can decompose Cdinto three
setsCDv
d,CCv
dandCUv
d, respectively representing the calls to the
library APIs inADv
d,ACv
dandAUv
d(i.e., the calls to the deleted,
changed and unchanged library APIs). Therefore, the efforts fv
dto
harmonize dto the version vcan be characterized as a 6-tuple, i.e.,
fv
d=⟨ADv
d,ACv
d,AUv
d,CDv
d,CCv
d,CUv
d⟩.
Interactively Recommending Harmonized Version. As re-
vealed by our survey (see Sec. 2), developers may choose to not har-
monize all inconsistent library dependencies due to various reasons
(e.g., different development schedule, or heavy efforts due to API de-
pendency intensity or backward incompatibility). Thus, LibHarmo
is designed to interact with developers such that 1) developers are
provided with detailed library API-level harmonization efforts fv
d
for each library dependency d∈D libto be harmonized into each
candidate version v∈Vd; 2) developers have the flexibility to de-
cide which of the library dependencies D′
lib⊆D libneed to be har-
monized; and 3) developers are provided with a ranked list of candi-
date versions based on flexible combinations of ADv
d,ACv
d,AUv
d,
CDv
d,CCv
dandCUv
d(e.g., the default ranking is based on the sum-
mation of|CDv
d|and|CCv
d|over all library dependencies in D′
lib)
such that they can choose the harmonized version vhwith the least
harmonization efforts they consider acceptable.
To ease the determination of D′
lib, we first decompose Dlibac-
cording to d.mver; i.e., the library dependencies that have their ver-
sion declared in the same POM mverare grouped intoDmver
lib.Dmver
lib
actually belongs to the type of true consistency (or single library),
and should be harmonized together to still keep the consistency. For
example,Dдuavain Example 3.4 can be decomposed into DCдuava=
{d1,d3}andDBдuava={d7}. Based on the decomposition, we allow
developers to determine which groups need to be harmonized.
3.3 Refactoring POMs and Suggesting APIs
The last step of LibHarmo is to provide support to carry out the har-
monization on POMs and source code. LibHarmo can automatically
refactor POMs based on the library dependencies D′
libthat develop-
ers choose from an inconsistency Dliband the harmonized version
vhthat developers choose. The POM refactoring is exactly the same
<parent><groupId>A</groupId><artifactId>A</artifactId><version>1.0</version></parent>…<dependencyManagement><dependencies><dependency><groupId>R</groupId><artifactId>R</artifactId><version>1.0</version><type>pom</type><scope>import</scope></dependency></dependencies></dependencyManagement>…<dependencies><dependency><groupId>commons-io</groupId><artifactId>commons-io</artifactId><version>${commons-io.version}</version></dependency><dependency><groupId>com.google.guava</groupId><artifactId>guava</artifactId><version>${guava.new.version}</version></dependency><dependencies><dependencies></dependencies>A<project><groupId>A</groupId><artifactId>A</artifactId><version>1.0</version><properties><guava.new.version>23.0<guava.new.version><commons-io.version>2.5<commons-io.version><properties>…</project>
<dependencies><dependency><groupId>com.google.guava</groupId><artifactId>guava</artifactId></dependency></dependencies>CDEBR12345678910111213141516171819202122232425262728293012345678910<dependencyManagement><dependencies><dependency><groupId>com.google.guava</groupId><artifactId>guava</artifactId><version>${guava.new.version}</version></dependency></dependencies></dependencyManagement><dependencies><dependency><groupId>commons-io</groupId><artifactId>commons-io</artifactId><version>${commons-io.version}</version></dependency></dependencies>1234567891011121314151612345612Figure 4: An Example of Refactoring POMs
for false consistencies. Besides, LibHarmo provides conservative
support for library API adaptation; i.e., it only suggests replacement
library APIs to some of the deleted library APIs based on the ex-
tracted information from API documentations.
Refactoring POMs. The goal of our harmonization is to make
D′
libbecome a true consistency; i.e., all the library dependencies in
D′
libneed to have their version reference a property of value vh. To
this end, LibHarmo first locates the POMs M′that declare the ver-
sion of the library dependencies in D′
lib; i.e.,M′={d.mver|d∈
D′
lib}. On one hand, the lowest common ancestor of the POMs in
M′on the POM inheritance graph Gis the POM where LibHarmo
newly declares a property of value vh. On the other hand, M′con-
tains the POMs where LibHarmo changes the (implicit or explicit)
version declaration of libto a reference to the newly declared prop-
erty. Occasionally, the lowest common ancestor could be a remote
POM that we do not have direct control, or Gcontains several sub-
graphs that are not connected. Thus, LibHarmo finds several lowest
common ancestors, each of which is the lowest common ancestor of
some POMs inM′, and then applies the similar refactoring process.
Finally, LibHarmo checks whether the properties that are refer-
enced inD′
libare referenced by the other library dependencies in
D. Specifically, for each library dependency d∈D′
libthat declares
the version by referencing a property, LibHarmo extracts a 2-tuple
⟨d.pro,d.mpro⟩, and checks whether there exists a library depen-
dency d′inD−D′
libsuch that d.pro=d′.pro∧d.mpro=d′.mpro.
If exists, d.prois still referenced by other library dependencies, and
thus it is kept; otherwise, LibHarmo deletes d.profrom d.mpro.
Example 3.5. GivenDдuava={d1,d3,d7}in Example 3.4 and the
harmonized version 23.0 ,M′is computed as{B,C}, and their low-
est common ancestor is A. Hence, a property guava.new.version is
declared at Line 6 in Ain Fig. 4, and BandCrespectively change the
version declaration at Line 28 in Band at Line 6 in Cto reference the
property guava.new.version . Moreover, as the previous property
guava.version is not referenced by other library dependencies, it
is deleted from A. Similarly, for the false consistency Dcommons−io
={d2,d4,d5,d6}in Example 3.4,M′is computed as{B,C}. Hence,
5ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States Kaifeng Huang, Bihuan Chen, Bowen Shi, Ying Wang, Congying Xu, and Xin Peng
(a) Distribution
FC
TC
 IC
109
25
 142
2
70
51
 16
 (b) Intersection
Figure 5: Overall Distribution of IC, FC, TC and SL
a property commons-io.version is declared in A, the lowest com-
mon ancestor of BandC; and the version declaration at Line 23 in B
and at Line 14 in Cis changed to reference commons-io.version .
Suggesting APIs. After POMs are refactored, the source code
also needs to be adapted to the harmonized version. Library API adap-
tation has been widely investigated [ 6,16,19,20,27,32,58,68,76,
81], and empirical studies [ 17,78] have shown that they achieved an
average accuracy of 20%. Besides, our survey indicates that refactor-
ing the source code is surprisingly a less useful feature. Based on the
two observations, LibHarmo takes a conservation strategy to only
consider the library APIs that are deleted in the harmonized version
and attempt to suggest their replacement library APIs. The reason is
that some library APIs are deleted because they are deprecated and
their replacement library APIs might be clearly documented in the
deprecated page in Javadoc in the form of “use xxx” where xxxis
the fully qualified name of a replacement library API.
Specifically, for each deleted library API a∈ADv
d,LibHarmo
first obtain from our library database the Javadocs of all the library
releases released between the release date of the library version
d.verand the release data of the harmonized version v. Notice that
these library releases could possibly document the deprecation of a.
Then, for each Javadoc, LibHarmo checks in the deprecated page
whether the library API ais deprecated; and if yes, LibHarmo uses
pattern matching to search the existence of “use xxx”. If exists, the
replacement library API to ais found, and suggested to developers.
3.4 Library Database
Recall that our harmonization efforts analysis (see Sec. 3.2) requests
from the library database the JAR files of a library version and some
newer releases of the same library, and our replacement library API
suggestion (see Sec. 3.3) requests the Javadocs of some library re-
leases from the library database. Therefore, LibHarmo crawls the
JAR files and Javadocs of all releases of a library in a demand-driven
way from Maven repository. Besides, LibHarmo regularly updates
any new library releases for the libraries in our library database.
4 EVALUATION
We have implemented a prototype of LibHarmo in Java and Python
in a total of 14.6K lines of code. We have released the source code at
our website [ 4]. In this section, we report our experimental results
ofLibHarmo on GitHub projects.
(a) Distribution
(b) Projects Having IC, FC, TC and SL
Figure 6: Fine-Grained Distribution of IC, FC, TC and SL
4.1 Evaluation Design
We used the same set of 443 Java Maven multi-module projects used
in our survey as the dataset for our evaluation. We designed our eval-
uation to answer the following four research questions.
•RQ1: What is the distribution of inconsistency, false consistency,
true consistency, and single library? (Sec. 4.2)
•RQ2: What is the severity of the detected inconsistency and false
consistency? (Sec. 4.3)
•RQ3: What are the efforts for harmonizing inconsistency? (Sec. 4.4)
•RQ4: What is developers’ feedback about LibHarmo ? (Sec. 4.5)
Specifically, we ran LibHarmo against each project to 1) detect all
the inconsistencies and false consistencies, which is used to answer
RQ1 andRQ2 , 2) analyze the harmonization efforts for each incon-
sistency for each candidate harmonized version, which is used to an-
swer RQ3 , and 3) generate a report including the previous two set of
information and send it to developers, which is used to answer RQ4 .
4.2 Distribution Evaluation (RQ1)
We first measured the overall distribution of inconsistency, false con-
sistency, true consistency and single library, and then measured their
fine-grained distribution with respect to the modular complexity of
projects (approximated as the number of POMs).
Overall Distribution. Fig. 5a shows the overall distribution of
inconsistency (IC), false consistency (FC), true consistency (TC), and
single library (SL) (see Sec. 3.1). SL accounts for 61.0%, and IC, FC
and TC account for 39.0%, which means that more than one-third of
the libraries are used across multiple modules. More specifically, TC
accounts for 22.6%, which is much higher than IC and FC, and covers
318 projects. This indicates that library version harmonization (via
referencing a property) is already a practice that is adopted by many
6Interactive, Effort-Aware Library Version Harmonization ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States
projects. Nevertheless, there are still 2,576 cases of FC. They account
for 13.2% and cover 346 projects. They are very likely to turn into IC
if not carefully maintained, and thus increase the burden of library
maintenance. There are 621 cases of IC, which account for 3.2% and
cover 152 projects. These results indicate that library version incon-
sistency and false consistency are common in real-world projects.
Moreover, Fig. 5b reports the intersections among the projects
that are affected by IC, FC and TC. Noticeably, there is a high overlap
(i.e., 251 projects) between TC and FC. This indicates that while many
projects adopt consistent library versions, they still leave many li-
braries not truly consistent. Similarly, the libraries in 51 projects are
all consistent, while the libraries in 70 projects are all falsely consis-
tent. Moreover, the overlap between FC and IC is also high (i.e., 134
projects), and most of the projects that have IC also have FC. This is
potentially because that FC has a high chance to turn into IC. Fur-
thermore, 109 projects have IC, FC and TC at the same time, which
indicates that using consistent library versions is not consistently
recognized across the whole development team of a project.
Fine-Grained Distribution. The bars in Fig. 6a report the total
number of projects whose number of POMs is in a specific range. As
we can see, nearly half (47.6%) of the projects have less than 10 POMs,
and only 22.3% of projects have more than 30 POMs. These results in-
dicate that most projects have moderate complexity in modules. The
four curves in Fig. 6a reports the distribution of IC, FC, TC and SL
as projects’ complexity in modules increases, while the four curves
in Fig. 6b correspondingly present the ratio of projects that have IC,
FC, TC and SL. We can see that, the ratio of IC slightly increases and
the ratio of projects having IC greatly increases. This indicates that
as projects have more complexity in modules, library maintenance
becomes more complicated, and hence there is a higher chance to
introduce inconsistencies. Besides, the ratio of FC and TC does not
decrease, and the ratio of projects having FC and TC even increases.
This indicates that although projects become more complex in mod-
ules, developers may still willing to keep library versions consistent.
In that sense, LibHarmo can help developers systematically detect
inconsistencies or false consistencies as early as possible.
LibHarmo detected 621 library version inconsistencies and
2,576 false consistencies, accounting for 16.4% while affecting
364 projects. As projects have more complexity in modules, it
becomes more likely to introduce inconsistencies.
4.3 Severity Evaluation (RQ2)
We analyzed the severity of a detected inconsistency or false consis-
tency (i.e.,Mlib) in terms of four indicators: 1) the number of POMs
that are affected (i.e., |Mlib|), 2) the ratio of POMs that are affected
(i.e.,|Mlib|/|M|), 3) the number of distinct versions declared in
Mlib, and 4) whether the versions of library dependencies in Mlib
are all explicitly declared (i.e., hard-coded), all implicitly declared
(i.e., via referencing a property), or declared in a mixed way. The
third indicator is only applicable for inconsistencies as false consis-
tencies only have one version. The higher the first three indicators,
the more versions are simultaneously adopted in more POMs, and
thus the more severe the inconsistency or false consistency. For the
fourth indicator, we regard explicit declaration is more severe than
mixed declaration and implicit declaration because it indicates thatdevelopers seem to have no sense to harmonize library versions via
a property. We report the aggregated result over all consistencies
or false consistencies for each of the four indicators.
Affected POMs. Fig. 7a presents the distribution of IC and FC
with respect to the number of affected POMs. 67.8% of ICs and 70.8%
of FCs affect less than five POMs, and 21.3% of ICs and 12.9% of FCs
affect more than ten POMs. On the other hand, Fig. 7b reports the dis-
tribution of IC and FC with respect to the ratio of affected POMs.
70.9% of ICs and 53.5% of FCs affect less than 20% of POMs, while
9.7% of ICs and 22.9% of FCs affect more than 50% of POMs. These re-
sults indicate that most ICs and FCs affect a relatively small number
of POMs, but still around one-tenth of ICs and one-fifth of FCs could
involve a relatively large number of POMs.
Distinct Versions. Fig. 8a reports the distribution of distinct ver-
sions in inconsistencies. We can see that 81.8% of ICs only have two
distinct versions, and only 3.7% of ICs have more than five distinct
version. Moreover, we generated a box plot for each bar in Fig. 8a to
measure the affected POMs. The result is reported in Fig. 8b, where
the arrows indicate higher outliers that we hide to enhance the
comprehension of the box plots. As the number of distinct versions
in ICs increases, the number of affected POMs increases. In regard
of the ICs that have two distinct versions, the median number of
affected POMs is around three. This indicates that most ICs are still
manageable if developers want to harmonize them. Still, there are
80 outliers in the first box plot, and some of them can affect around
400 POMs. We looked into these 80 outliers, and found that in 72
(90.0%) outliers, more than 80% of the POMs use one version, while
less than 20% of the POMs use the other version. More interestingly,
in 58 (72.5%) outliers, one of the distinct version is only used in one
POM. One potential reason is that developers have to use a specific
version in a minority of POMs to avoid the heavy API backward
incompatibility in them. Another potential reason is that developers
are unaware of the minority of POMs that use a distinct version
due to the complex POM inheritance graph.
Version Declaration. Fig. 9 shows the distribution of version
declarations (i.e., explicit declaration (EX), implicit declaration (IM)
and mixed declaration (MX)) for IC and FC. It turns out that 94.1%
of FCs declare versions by hard-coding. This means that developers
need to change all the affected POMs at the same time to keep these
FCs consistent rather than turning such FCs into ICs, which is actu-
ally a huge but avoidable maintenance cost. Besides, 36.1% of ICs de-
clare versions by hard-coding. This shows that hard-coding version
numbers is probably not a good practice, and it tends to introduce in-
consistencies. 63.9% of ICs include implicitly declared versions. This
means that developers already have the sense to declare versions by
referencing a property for reducing library maintenance cost, but IC
still exists. As revealed by our survey (see Sec.2), there are multiple
reasons for not harmonizing inconsistencies intentionally. We at-
tempted to manually look into these cases to determine whether our
detected inconsistencies were intentionally kept. However, it is very
challenging to confirm the underlying reasons as they are often busi-
ness logic-related. This is also one of the reasons that we allow de-
velopers to interact with LibHarmo . Nevertheless, we did find some
cases that conformed to our survey; but we also found one case that
was not reported by our survey, i.e., developers intentionally declare
multiple properties for different versions of the same library to pro-
vide comprehensive support for different runtime environments.
7ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States Kaifeng Huang, Bihuan Chen, Bowen Shi, Ying Wang, Congying Xu, and Xin Peng
(a) Distribution across the Number of Affected POMs
 (b) Distribution across the Ratio of Affected POMs
Figure 7: Distribution of IC and FC across Affected POMs
(a) Distinct Versions
34, 404,404, 32,393, 393,48, 37, 27,26, 47, 38,26, 73, 31,39, 28, 73,48, 49, 111230, 145,389, 389,388, 55, 55,89, 67393, 26 4334 3831, 33
510152025
23456789>10The Number of Distinct Versions (#)The Number of Affected POMs (#) (b) Distinct Versions w.r.t. Affected POMs
Figure 8: Distribution of Distinct Versions in IC
(a) IC
 (b) FC
Figure 9: Version Declaration Distribution in IC and FC
For example, project memcached-session-manager is a tomcat ses-
sion manager that keeps sessions in memcached or Redis, for highly
available, scalable and fault tolerant web applications. It declares
four properties for version 6.0.45, 7.0.85, 8.5.29 and 9.0.6 for various
tomcat dependencies, as it is currently working with tomcat 6.x,
7.x, 8.x and 9.x (as explained in its README file).
67.8% of ICs and 70.8% of FCs affect less than five POMs. 81.8%
of ICs only have two distinct versions, affecting a median num-
ber of three POMs. 36.1% of ICs and 94.1% of FCs declare all
versions by hard-coding. Overall, the severity of ICs and FCs
is relatively not high.
5389692, 1290, 676,1074, 1637, 8893,508, 849, 766, 4506,512, 1467, 783, 726,4456, 533, 577, 807,521, 28175, 3273,755, 1243, 1785,7618, 6129777, 1290, 679,1106, 1637, 9395,510, 850, 766, 503,4506, 512, 1467,648, 568, 783, 726,4690, 533, 578, 807,521, 827, 28175,3273, 755, 1340,1785, 7618, 612
0100200300400500
Deleted ChangedUnchanged TotalThe Types of APIs/API CallsThe Number of APIs/API Calls (#)APIAPI CallFigure 10: Harmonization Efforts
4.4 Efforts Evaluation (RQ3)
We analyzed the harmonization efforts for each of the 621 inconsis-
tencies for each candidate harmonized version. We report the results
for the candidate version with the least harmonization efforts se-
lected based on our default ranking (see Sec. 3.2). Fig. 10 shows two
box plots (one denotes the number of APIs, and the other denotes
the number of API calls) for deleted, changed, unchanged, and total
library APIs that are called. Overall, 190 (30.6%) ICs have no harmo-
nization efforts; i.e., all the invoked library APIs are not changed in
the suggested harmonized version. In the remaining 431 ICs, on av-
erage, 1 and 2 of the 24 called library APIs are respectively deleted
and changed in the suggested harmonized version, affecting 1 and 12
of the 63 library API calls, as indicated by the green diamonds. These
results indicate that the harmonization efforts with respect to the
8Interactive, Effort-Aware Library Version Harmonization ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States
number of deleted and changed APIs seem small. However, the ac-
tual harmonization efforts depend on how the deleted or changed
APIs affect the business logic. Therefore, we choose to provide devel-
opers with detailed API-level report to assist them in determining
where and whether to harmonize.
Replacement API to Deleted APIs. In these suggested harmo-
nized versions for the 621 inconsistencies, a total of 1,798 library
APIs are deleted. Our documentation-based replacement API sug-
gestion method (see Sec. 3.3) successfully find the replacement APIs
for 207 (11.5%) of them. Such a low coverage indicates the potential
efforts in refactoring source code. Contrarily, our survey indicates
that automatic source code is a less useful feature. This is also why
we decide to design such an API suggestion method that only sug-
gests replacement APIs with 100% accuracy.
Case Studies. Here we choose a popular project Apache Tika to
demonstrate what our report tells to the developers. Apache Tika is
a toolkit for detecting and extracting metadata and structured text
content from various documents using existing parser libraries. It is
a project of the Apache Software Foundation. LibHarmo identifies
four inconsistencies and six false consistencies.
One of the inconsistencies is about library commons-cli . It in-
volves three modules: tika-server ,tika-batch andtika-eval .
The first module explicitly declares commons-cli with version 1.2.
The latter two reference two properties with the same property name
cli.version defined in their own POM file, and both of them de-
clare version 1.4. Therefore, an inconsistency occurs. Version 1.4 is
suggested as the harmonized version as it leads to the smallest num-
ber of calls to the deleted and changed library APIs, indicating that
updating commons-cli from 1.2 to 1.4 in tika-server solves the in-
consistency. It turns out that the number of called library APIs in
tika-server is 5, and there are totally 33 library API calls. These 5
library APIs are all changed in version 1.4. Finally, a lowest common
ancestor POM file, tika-parent/pom.xml , is located, where a new
property specifying version 1.4 is declared. The two old properties
declared separately in tika-batch andtika-eval can be removed
safely because no other library dependency references them. In fact,
according to the comment in the POM file, developers actually have
already noticed this inconsistency, and thought about moving the
property declaration into tika-parent/pom.xml (as suggested by
LibHarmo ) to harmonize the inconsistency. However, the harmo-
nization was postponed due to migration efforts.
One of the false consistencies is about json-simple . It involves
two modules: tika-parsers andtika-translate . In these two mod-
ules, json-simple is declared explicitly with version 1.1.1. Similar
to the previous inconsistency example, LibHarmo searches the POM
inheritance graph and locates tika-parent/pom.xml as a common
parent POM file; then it declares a property of version 1.1.1, and
refactors json-simple dependency declaration in tika-parsers
andtika-translate to implicitly reference the new property.
In 190 (30.6%) ICs, all the called library APIs are not changed in
the suggested harmonized version. In the remaining 431 ICs,
on average, 1 and 2 of the 24 called library APIs are deleted and
changed, affecting 1 and 12 library API calls. Overall, the har-
monization efforts seem relatively small but the true efforts
are often application-specific.4.5 Developer Feedback (RQ4)
To understand developers’ feedback about LibHarmo , we targeted
621 inconsistencies in 152 projects, and sent our generated report
to the developers of these projects. Within one week, 16 developers
replied. 8 of them explicitly commented that version inconsistency
is certainly a problem for library maintainers, and our tool and re-
port are useful; e.g., “ the problem you’re describing is very real, and I
have encountered it myself in my day-to-day job several times ”, “keep
up the good work with your harmonization tool. It definitely sounds
interesting! ”, and “ the cool reports here helped me find one real issue,
thanks! ”. 5 of them did not comment on our tool, but only discussed
the inconsistencies, and 3 of them were no longer Java developers
or no longer in charge of the projects.
Moreover, 4 developers confirmed the inconsistencies but ex-
plained that they were intentionally kept due to API compatibility,
and 1 developers confirmed and quickly fixed the consistency. As we
crawled the project repositories several months before our report,
4 developers asked us to re-generate the report for their current
repositories, and we are still waiting for their further feedback. The
others are still under discussion.
Interestingly, a developer from hadoop confirmed that adopt-
ing consistent libraries is one of their common practice, but “ peo-
ple neglect to do this; when that’s found we will pull the explicit
version declaration out and reference from hadoop-project; adding the
import there if not already present. Therefore any duplicate declara-
tion of a dependency with its own <version> field in any module other
than hadoop-project is an error. Your dependency graphs are helpful
here”. It is also worth mentioning that 4 developers commented that
they also cared about inconsistencies in transitive dependencies, but
also said that “ it is also very hard to fix, since the source code is not
owned by me ”. This is why we only focus on direct dependencies.
Half of the responded developers thought that our tool and
report are useful. 5 inconsistencies have been confirmed and
1 of them has been harmonized.
4.6 Discussions
Threats to Survey. First, we chose an online survey with GitHub
developers instead of a face-to-face interview study with industrial
developers, because it is difficult to recruit industrial developers for
interviews at a reasonable cost, and an online study allows us to re-
cruit a relatively large number of developers. Second, we decided to
not offer compensation but kindly ask participants to voluntarily
take the survey. As a result, we expected that GitHub developers
who were really interested in library version inconsistencies and
well motivated would participate in this survey. This instead could
improve the quality of our survey to avoid potential cases that par-
ticipants only wanted the compensation but answered haphazardly.
Threats to Evaluation. First, as we have not integrated our tool
into the build process, it is not feasible for us to empirically evaluate
the soundness of our tool in refactoring POMs on a large-scale of
diverse projects. However, we refactor POMs in such a non-invasive
way that does not change the inheritance relationship among POMs.
We believe our POM refactoring is sound. Second, due to the same
reason, we generated reports about inconsistencies and sent reports
to relevant developers for obtaining their feedback instead of letting
9ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States Kaifeng Huang, Bihuan Chen, Bowen Shi, Ying Wang, Congying Xu, and Xin Peng
developers directly use our tool on their projects. While this may not
get the first-hand information from developers, it relieves the bur-
den of developers to install our tool and only focuses on the results.
We believe this can help us obtain more feedback.
Limitations. First, due to the well-known limitation of static anal-
ysis, our generated API call graphs could be unsound (e.g., due to
reflection), which will affect the precision of our API-level harmo-
nization efforts analysis. We will investigate a combination of static
analysis and dynamic analysis to make the call graph generation
more precise. Second, we currently only target Maven Java projects,
but there are several other automated build tools such as Gradle and
Ant. The reasons we currently choose Maven are that 1) Maven is
the most widely-used build tool for Java project, and 2) many Maven
projects have been developed for decades and these long-history
projects may be mostly beneficial from our tool. Given the positive
feedback from developers, we plan to develop corresponding tools
for other automated build tools.
5 RELATED WORK
In this section, we review the related work in four areas: library anal-
ysis, API evoluation, API adaptation, and library empirical studies.
5.1 Library Analysis
Patra et al. [ 60] analyzed JavaScript library conflicts caused by the
lack of namespaces in JavaScript, and proposed ConflictJS to first
use dynamic analysis to identify potential conflicts and then use tar-
geted test synthesis to validate them. Wang et al. [ 73] investigated
the manifestation and fixing patterns of dependency conflicts in
Java, and designed Decca to detect dependency conflicts and assess
their severity via static analysis. Wang et al. [ 74] also proposed Rid-
dleto generate crashing stack traces for detected dependency con-
flicts. Such dependency conflicts are one of the bad consequences
of inconsistent library versions.
Cadariu et al. [ 15] proposed an alerting tool to notify develop-
ers about Java library dependencies with security vulnerabilities.
Mirhosseini and Parnin [ 55] compared the usage of pull requests
and badges to notify outdated npm packages. These approaches only
detect the inclusion of vulnerable libraries. To further determine if
the vulnerable library code is in the execution path of a project, Plate
et al. [ 61] applied dynamic analysis to check whether the vulnerable
methods were executed by a project; and Ponta et al. [ 62] extended it
by combining dynamic analysis with static analysis. It is interesting
to also consider security vulnerabilities as another factor when we
recommend harmonized versions in LibHarmo .
Bloemen et al. [ 11] analyzed the evolution of the Gentoo package
dependency graph, while Kikas et al. [ 38] and Decan et al. [ 24] com-
pared the evolution of dependency graphs in different ecosystems.
Kikas et al. [ 38] and Decan et al. [ 23] also investigated the impact of
security vulnerabilities on the dependency graph. Zimmermannet et
al. [82] further modeled maintainers and vulnerabilities into the de-
pendency graph in the npm ecosystem, and systematically analyzed
the risk of attacked packages and maintainers and vulnerabilities.
LibHarmo can be extended to support library version inconsistency
analysis on the ecosystem-level dependency graph.
To the best of our knowledge, no previous work has systemati-
cally investigate library version inconsistency.5.2 API Evolution
A large body of studies have been focused on API evolution to
analyze how developers react to API evolution [ 12,33,51,66,67],
how APIs are changed and used [ 77], how API stability is mea-
sured [ 64], how API stability affects Android apps’ success [ 48],
how refactoring influences API breaking [ 26,39,43], how and why
developers break APIs [ 14,37,80], how API breaking impacts client
programs [ 65,79], etc. Moreover, several advances have been made
to detect API breaking. Previous work mostly uses theorem proving
[28,29,44,49,50] or symbolic execution [ 57,72], but has scalability
issues when detecting breaking APIs in real-life program. Recently,
testing techniques have been used to detect breaking APIs. Gyori et
al. [31] relied on regression tests, while Soares et al. [ 71] generated
new tests to detect behavior changes in refactored APIs. Mezzetti et
al. [52] and Møller and Torp [ 56] targeted Node.js libraries, and used
model-based testing to detect type-related breaking (i.e., changes to
API signatures). Similarly, Brito et al. [ 13] used heuristics to stati-
cally detect type-related changes in Java libraries. However, it is an
open problem to detect behavior changes when API signatures are
not changed but the API bodies are changed. We will extend such
approaches to improve the precision of our effort analysis.
5.3 API Adaptation
A large number of advances have been made to adapt client pro-
grams to API evolution according to change rules. Change rules can
be manually written by developers [ 6,16], automatically recorded
from developers [ 32], derived through API similarity matching [ 81],
mined from API usage changes in libraries themselves [ 19,20]
as well as client programs [ 27,58,68], and extracted by a combi-
nation of some of these methods [ 76]. Several empirical studies
have also been proposed to investigate the effectiveness of these
methods [ 17,78]. They found that these methods only achieved an
average accuracy of 20%, but still could help developers. Currently,
we only recommend change rules that are extracted from documen-
tation and hence are absolutely correct, and we will integrate these
methods to recommend undocumented change rules.
5.4 Library Empirical Studies
A large body of studies has been focused on characterizing the us-
age and update practice of libraries in different ecosystems, e.g., the
usage trend and popularity of libraries and APIs [ 5,7,8,21,34,41,
45,47,53,54,63,75], the practice of updating library versions [ 9,42],
the latency of updating library versions [ 18,22,40,46], and the
reason of updating or not updating library versions [ 9,10,25,42].
To the best of our knowledge, we are the first to systematically un-
derstand library version inconsistency in real-life projects through
a survey with GitHub developers.
6 CONCLUSIONS
In this paper, we have conducted a survey with 131 Java developers
from GitHub to collect the first-hand information about root causes,
detection methods, reasons for fixing or not fixing, fixing strategies,
fixing efforts, and tool expectations on library version inconsisten-
cies. Our survey suggests several insights, e.g., tools are needed to
proactively locate and harmonize inconsistent library versions, and
such tools need to interact with developers and provide API-level
10Interactive, Effort-Aware Library Version Harmonization ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States
harmonization efforts. Based on such insights, we have developed
LibHarmo , the first interactive, effort-aware technique to harmo-
nize inconsistent library versions in Java Maven projects. We have
evaluated LibHarmo against 443 Java Maven projects from GitHub.
LibHarmo successfully detects 621 library version inconsistencies,
covering 152 of projects, as well as 2,576 false consistencies, cover-
ing 346 projects. The average harmonization efforts are that 1 and 2
of the 24 called library APIs are respectively deleted and changed in
the harmonized version, affecting 1 and 12 library API calls. More-
over, 5 library version inconsistencies have been confirmed, and
1 of them has been harmonized by developers. In future, we plan
to integrate LibHarmo into the build process so that developers
can more intensively and naturally interact with LibHarmo . We
also hope to extend LibHarmo to support other automation build
tools (e.g., Gradle), and develop advanced API breaking analysis
techniques to improve the accuracy of our API-level effort analysis.
REFERENCES
[1][n.d.]. HADOOP-6800 . Retrieved August 12, 2019 from https://issues.apache.org/
jira/browse/HADOOP-6800
[2][n.d.]. Introduction to the Dependency Mechanism . Retrieved August
12, 2019 from https://maven.apache.org/guides/introduction/introduction-to-
dependency-mechanism.html
[3][n.d.]. Introduction to the POM . Retrieved August 12, 2019 from https://maven.
apache.org/guides/introduction/introduction-to-the-pom.html
[4] [n.d.]. LibHarmo . Retrieved August 12, 2019 from https://libharmo.github.io
[5]Rabe Abdalkareem, Olivier Nourry, Sultan Wehaibi, Suhaib Mujahid, and Emad
Shihab. 2017. Why do developers use trivial packages? an empirical case study
on npm. In FSE. 385–395.
[6]Ittai Balaban, Frank Tip, and Robert Fuhrer. 2005. Refactoring Support for Class
Library Migration. In OOPSLA . 265–279.
[7]Veronika Bauer and Lars Heinemann. 2012. Understanding API usage to support
informed decision making in software maintenance. In CSMR . 435–440.
[8]Veronika Bauer, Lars Heinemann, and Florian Deissenboeck. 2012. A structured
approach to assess third-party library usage. In ICSM . 483–492.
[9]Gabriele Bavota, Gerardo Canfora, Massimiliano Di Penta, Rocco Oliveto, and
Sebastiano Panichella. 2013. The evolution of project inter-dependencies in a
software ecosystem: The case of apache. In ICSM . 280–289.
[10] Gabriele Bavota, Gerardo Canfora, Massimiliano Di Penta, Rocco Oliveto, and
Sebastiano Panichella. 2015. How the Apache community upgrades dependencies:
an evolutionary study. Empirical Software Engineering 20, 5 (2015), 1275–1317.
[11] Remco Bloemen, Chintan Amrit, Stefan Kuhlmann, and Gonzalo Ordóñez-
Matamoros. 2014. Gentoo package dependencies over time. In MSR. 404–407.
[12] Christopher Bogart, Christian Kästner, James Herbsleb, and Ferdian Thung. 2016.
How to Break an API: Cost Negotiation and Community Values in Three Software
Ecosystems. In FSE. 109–120.
[13] Aline Brito, Laerte Xavier, Andre Hora, and Marco Tulio Valente. 2018. APIDiff:
Detecting API breaking changes. In SANER . 507–511.
[14] Aline Brito, Laerte Xavier, Andre Hora, and Marco Tulio Valente. 2018. Why and
how Java developers break APIs. In SANER . 255–265.
[15] Mircea Cadariu, Eric Bouwers, Joost Visser, and Arie van Deursen. 2015. Tracking
known security vulnerabilities in proprietary software systems. In SANER . 516–
519.
[16] Kingsum Chow and David Notkin. 1996. Semi-automatic Update of Applications
in Response to Library Changes. In ICSM . 359–368.
[17] Bradley E Cossette and Robert J Walker. 2012. Seeking the ground truth: a
retroactive study on the evolution and migration of software libraries. In FSE. 55.
[18] Joël Cox, Eric Bouwers, Marko van Eekelen, and Joost Visser. 2015. Measuring
dependency freshness in software systems. In ICSE , Vol. 2. 109–118.
[19] Barthelemy Dagenais and Martin P Robillard. 2009. SemDiff: Analysis and
recommendation support for API evolution. In ICSE . 599–602.
[20] Barthélémy Dagenais and Martin P Robillard. 2011. Recommending adaptive
changes for framework evolution. ACM Transactions on Software Engineering
and Methodology 20, 4 (2011), 19.
[21] Coen De Roover, Ralf Lammel, and Ekaterina Pek. 2013. Multi-dimensional
exploration of api usage. In ICPC . 152–161.
[22] Alexandre Decan, Tom Mens, and Eleni Constantinou. 2018. On the Evolution of
Technical Lag in the npm Package Dependency Network. In ICSME . 404–414.
[23] Alexandre Decan, Tom Mens, and Eleni Constantinou. 2018. On the Impact
of Security Vulnerabilities in the Npm Package Dependency Network. In MSR.
181–191.[24] Alexandre Decan, Tom Mens, and Philippe Grosjean. 2019. An empirical compar-
ison of dependency network evolution in seven software packaging ecosystems.
Empirical Software Engineering 24, 1 (2019), 381–416.
[25] Erik Derr, Sven Bugiel, Sascha Fahl, Yasemin Acar, and Michael Backes. 2017.
Keep Me Updated: An Empirical Study of Third-Party Library Updatability on
Android. In CCS. 2187–2200.
[26] Danny Dig and Ralph Johnson. 2006. How Do APIs Evolve? A Story of Refactoring:
Research Articles. J. Softw. Maint. Evol. 18, 2 (2006), 83–107.
[27] Mattia Fazzini, Qi Xin, and Alessandro Orso. 2019. Automated API-usage update
for Android apps. In ISSTA . 204–215.
[28] Dennis Felsing, Sarah Grebing, Vladimir Klebanov, Philipp Rümmer, and Mattias
Ulbrich. 2014. Automating regression verification. In ASE. 349–360.
[29] Benny Godlin and Ofer Strichman. 2013. Regression verification: proving the
equivalence of similar programs. Software Testing, Verification and Reliability 23,
3 (2013), 241–258.
[30] Georgios Gousios. [n.d.]. java-callgraph . Retrieved August 12, 2019 from https:
//github.com/gousiosg/java-callgraph
[31] Alex Gyori, Owolabi Legunsen, Farah Hariri, and Darko Marinov. 2018. Eval-
uating Regression Test Selection Opportunities in a Very Large Open-Source
Ecosystem. In ISSRE . 112–122.
[32] Johannes Henkel and Amer Diwan. 2005. CatchUp! Capturing and replaying
refactorings to support API evolution. In ICSE . 274–283.
[33] André Hora, Romain Robbes, Nicolas Anquetil, Anne Etien, Stéphane Ducasse,
and Marco Tulio Valente. 2015. How do developers react to API evolution? The
Pharo ecosystem case. In ICSME . 251–260.
[34] Andre Hora and Marco Tulio Valente. 2015. apiwave: Keeping track of API
popularity and migration. In ICSME . 321–323.
[35] Humble, Jez, and David Farley. 2010. Continuous Delivery: Reliable Software
Releases through Build, Test, and Deployment Automation (Adobe Reader) . Pearson
Education.
[36] Michael Jang. 2006. Linux Annoyances for Geeks: Getting the Most Flexible System
in the World Just the Way You Want It . O’Reilly Media, Inc.
[37] Kamil Jezek, Jens Dietrich, and Premek Brada. 2015. How Java APIs break–an
empirical study. Information and Software Technology 65 (2015), 129–146.
[38] Riivo Kikas, Georgios Gousios, Marlon Dumas, and Dietmar Pfahl. 2017. Structure
and evolution of package dependency networks. In MSR. 102–112.
[39] Miryung Kim, Dongxiang Cai, and Sunghun Kim. 2011. An Empirical Investiga-
tion into the Role of API-level Refactorings During Software Evolution. In ICSE.
151–160.
[40] Raula Gaikovina Kula, Daniel M German, Takashi Ishio, and Katsuro Inoue. 2015.
Trusting a library: A study of the latency to adopt the latest maven release. In
SANER . 520–524.
[41] Raula Gaikovina Kula, Daniel M German, Takashi Ishio, Ali Ouni, and Katsuro
Inoue. 2017. An exploratory study on library aging by monitoring client usage
in a software ecosystem. In SANER . 407–411.
[42] Raula Gaikovina Kula, Daniel M German, Ali Ouni, Takashi Ishio, and Katsuro
Inoue. 2018. Do developers update their library dependencies? Empirical Software
Engineering 23, 1 (2018), 384–417.
[43] Raula Gaikovina Kula, Ali Ouni, Daniel M. German, and Katsuro Inoue. 2018. An
Empirical Study on the Impact of Refactoring Activities on Evolving Client-used
APIs. Inf. Softw. Technol. 93, C (2018), 186–199.
[44] Shuvendu K Lahiri, Chris Hawblitzel, Ming Kawaguchi, and Henrique Rebêlo.
2012. Symdiff: A language-agnostic semantic diff tool for imperative programs.
InCAV. 712–717.
[45] Ralf Lämmel, Ekaterina Pek, and Jürgen Starek. 2011. Large-scale, AST-based
API-usage analysis of open-source Java projects. In SAC. 1317–1324.
[46] Tobias Lauinger, Abdelberi Chaabane, Sajjad Arshad, William Robertson, Christo
Wilson, and Engin Kirda. 2017. Thou shalt not depend on me: Analysing the use
of outdated javascript libraries on the web. In NDSS .
[47] Li Li, Tegawendé F Bissyandé, Jacques Klein, and Yves Le Traon. 2016. An
investigation into the use of common libraries in android apps. In SANER . 403–
414.
[48] Mario Linares-Vásquez, Gabriele Bavota, Carlos Bernal-Cárdenas, Massimiliano
Di Penta, Rocco Oliveto, and Denys Poshyvanyk. 2013. API Change and Fault
Proneness: A Threat to the Success of Android Apps. In ESEC/FSE . 477–487.
[49] Stephen McCamant and Michael D. Ernst. 2003. Predicting Problems Caused by
Component Upgrades. In ESEC/FSE . 287–296.
[50] Stephen McCamant and Michael D Ernst. 2004. Early identification of incompati-
bilities in multi-component upgrades. In ECOOP . 440–464.
[51] Tyler McDonnell, Baishakhi Ray, and Miryung Kim. 2013. An Empirical Study of
API Stability and Adoption in the Android Ecosystem. In ICSM . 70–79.
[52] Gianluca Mezzetti, Anders Møller, and Martin Toldam Torp. 2018. Type regression
testing to detect breaking changes in Node. js libraries. In ECOOP .
[53] Yana Momchilova Mileva, Valentin Dallmeier, Martin Burger, and Andreas Zeller.
2009. Mining trends of library usage. In IWPSE-Evol . 57–62.
[54] Yana Momchilova Mileva, Valentin Dallmeier, and Andreas Zeller. 2010. Mining
API Popularity. In Testing – Practice and Research Techniques . 173–180.
11ESEC/FSE 2020, 8 - 13 November, 2020, Sacramento, California, United States Kaifeng Huang, Bihuan Chen, Bowen Shi, Ying Wang, Congying Xu, and Xin Peng
[55] Samim Mirhosseini and Chris Parnin. 2017. Can automated pull requests encour-
age software developers to upgrade out-of-date dependencies?. In ASE. 84–94.
[56] Anders Møller and Martin Toldam Torp. 2019. Model-based testing of breaking
changes in Node. js libraries. (2019).
[57] Federico Mora, Yi Li, Julia Rubin, and Marsha Chechik. 2018. Client-specific
Equivalence Checking. In ASE. 441–451.
[58] Hoan Anh Nguyen, Tung Thanh Nguyen, Gary Wilson, Jr., Anh Tuan Nguyen,
Miryung Kim, and Tien N. Nguyen. 2010. A Graph-based Approach to API Usage
Adaptation. In OOPSLA . 302–321.
[59] Eugen Paraschiv. 2018. The State of Java in 2018 . Retrieved August 12, 2019 from
https://www.baeldung.com/java-in-2018
[60] Jibesh Patra, Pooja N Dixit, and Michael Pradel. 2018. ConflictJS: finding and
understanding conflicts between JavaScript libraries. In ICSE . 741–751.
[61] Henrik Plate, Serena Elisa Ponta, and Antonino Sabetta. 2015. Impact assessment
for vulnerabilities in open-source software libraries. In ICSME . 411–420.
[62] Serena Elisa Ponta, Henrik Plate, and Antonino Sabetta. 2018. Beyond Meta-
data: Code-Centric and Usage-Based Analysis of Known Vulnerabilities in Open-
Source Software. In ICSME . 449–460.
[63] Dong Qiu, Bixin Li, and Hareton Leung. 2016. Understanding the API usage in
Java. Information and software technology 73 (2016), 81–100.
[64] Steven Raemaekers, Arie van Deursen, and Joost Visser. 2012. Measuring software
library stability through historical version analysis. In ICSM . 378–387.
[65] Steven Raemaekers, Arie van Deursen, and Joost Visser. 2017. Semantic versioning
and impact of breaking changes in the Maven repository. Journal of Systems and
Software 129 (2017), 140–158.
[66] Romain Robbes, Mircea Lungu, and David Röthlisberger. 2012. How do developers
react to API deprecation?: the case of a smalltalk ecosystem. In FSE. 56:1–56:11.
[67] Anand Ashok Sawant, Romain Robbes, and Alberto Bacchelli. 2016. On the
reaction to deprecation of 25,357 clients of 4+ 1 popular Java APIs. In ICSME .
400–410.
[68] Thorsten Schäfer, Jan Jonas, and Mira Mezini. 2008. Mining framework usage
changes from instantiation code. In ICSE . 471–480.[69] Schlosser, Gerhard, and GÃĳnter P. Wagner. 2004. Modularity in development
and evolution . University of Chicago Press.
[70] Nicholas Smith, Danny van Bruggen, and Federico Tomassetti. 2017. JavaParser:
Visited. Leanpub, oct. de (2017).
[71] Gustavo Soares, Rohit Gheyi, Dalton Serey, and Tiago Massoni. 2010. Making
program refactoring safer. IEEE software 27, 4 (2010), 52–57.
[72] Anna Trostanetski, Orna Grumberg, and Daniel Kroening. 2017. Modular demand-
driven analysis of semantic difference for program versions. In SAS. 405–427.
[73] Ying Wang, Ming Wen, Zhenwei Liu, Rongxin Wu, Rui Wang, Bo Yang, Hai Yu,
Zhiliang Zhu, and Shing-Chi Cheung. 2018. Do the Dependency Conflicts in My
Project Matter?. In ESEC/FSE . 319–330.
[74] Ying Wang, Ming Wen, Rongxin Wu, Zhenwei Liu, Shin Hwei Tan, Zhiliang Zhu,
Hai Yu, and Shing-Chi Cheung. 2019. ICSE. 572–583.
[75] Erik Wittern, Philippe Suter, and Shriram Rajagopalan. 2016. A look at the
dynamics of the JavaScript package ecosystem. In MSR. 351–361.
[76] Wei Wu, Yann-Gaël Guéhéneuc, Giuliano Antoniol, and Miryung Kim. 2010.
Aura: a hybrid approach to identify framework evolution. In ICSE . 325–334.
[77] Wei Wu, Foutse Khomh, Bram Adams, Yann-Gaël Guéhéneuc, and Giuliano
Antoniol. 2016. An exploratory study of api changes and usages based on apache
and eclipse ecosystems. Empirical Software Engineering 21, 6 (2016), 2366–2412.
[78] Wei Wu, Adrien Serveaux, Yann-Gaël Guéhéneuc, and Giuliano Antoniol. 2015.
The impact of imperfect change rules on framework api evolution identification:
an empirical study. Empirical Software Engineering 20, 4 (2015), 1126–1158.
[79] Laerte Xavier, Aline Brito, Andre Hora, and Marco Tulio Valente. 2017. Historical
and impact analysis of API breaking changes: A large-scale study. In SANER .
138–147.
[80] Laerte Xavier, Andre Hora, and Marco Tulio Valente. 2017. Why do we break
APIs? first answers from developers. In SANER . 392–396.
[81] Zhenchang Xing and Eleni Stroulia. 2007. API-evolution support with Diff-
CatchUp. IEEE Transactions on Software Engineering 33, 12 (2007), 818–836.
[82] Markus Zimmermann, Cristian-Alexandru Staicu, Cam Tenny, and Michael
Pradel. 2019. Small World with High Risks: A Study of Security Threats in
the npm Ecosystem. In USENIX Security .
12