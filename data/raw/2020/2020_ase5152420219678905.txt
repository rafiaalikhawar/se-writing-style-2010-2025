REPFINDER : Finding Replacements for Missing
APIs in Library Update
Kaifeng Huang, Bihuan Chen, Linghao Pan, Shuai Wu, Xin Peng
School of Computer Science and Shanghai Key Laboratory of Data Science, Fudan University, China
Abstract —Libraries are widely adopted in developing software
projects. Library APIs are often missing during library evolution
as library developers may deprecate, remove or refactor APIs. Asa result, client developers have to manually ﬁnd replacement APIsfor missing APIs when updating library versions in their projects,
which is a difﬁcult and expensive software maintenance task. One
of the key limitations of the existing automated approaches is thatthey usually consider the library itself as the single source to ﬁndreplacement APIs, which heavily limits their accuracy.
In this paper, we ﬁrst present an empirical study to understand
characteristics about missing APIs and their replacements. Specif-ically, we quantify the prevalence of missing APIs, and summarizethe knowledge sources where the replacements are found, and thecode change and mapping cardinality between missing APIs andtheir replacements. Then, inspired by the insights from our study,
we propose a heuristic-based approach, R
EPFINDER , to automati-
cally ﬁnd replacements for missing APIs in library update. We de-sign and combine a set of heuristics to hierarchically search threesources (deprecation message, own library, and external library)for ﬁnding replacements. Our evaluation has demonstrated that
R
EPFINDER can ﬁnd replacement APIs effectively and efﬁciently,
and signiﬁcantly outperform the state-of-the-art approaches.
I. I NTRODUCTION
Libraries are widely adopted in developing software projects
[86]. Developers need to update library versions in their projects
under various circumstances, e.g., using new functionalities and
b u gﬁ x e s[ 21], solving dependency conﬂicts [ 87,88], mitigating
vulnerability risks [ 11,20,62,63,86,101], and harmonizing in-
consistent library versions [ 34]. As libraries evolve (i.e., new li-
brary versions are released), library developers might introducemissing APIs (i.e., APIs that are missing in the new library ver-sions) by deprecating, removing or refactoring APIs. As a conse-quence, client projects fail to compile after library update, whileclient developers have to manually investigate how to replace us-ages of missing APIs. Due to this difﬁcult and expensive manualanalysis, client developers may choose not to update library ver-sions and thus cause technical lags [
16,19,21,39,44,69,97].
To achieve automated library update, various API adaptation
approaches have been introduced [ 15,91]. In general, API adap-
tation can be decomposed into two tasks; i.e., the ﬁrst is to ﬁnd
what is the replacement of a missing API (e.g., [ 13,18,89,95]),
and the second is to identify how usages of a missing API are ac-tually replaced by usages of its replacement API (e.g., [
24,81]).
The ﬁrst task, which is the focus of this paper, has been achieved
by four groups of approaches. Manual approaches [ 13,29,60]
require library developers to specify the mapping between miss-
ing APIs and their replacements or to record API refactoring
actions in IDE. However, the involvement of library developersis often not available. Similarity-based approaches [ 26,37,95]
utilize textual, metric and structural similarities to build the map-ping. Usage-based approaches [
17,18,74] identify the mapping
from API usage changes in library’s instantiation code or owncode. However, they become infeasible when missing APIs arenot used in library’s instantiation code or own code. Hybrid ap-
proaches [ 50,89] combine and extend similarity-based and
usage-based approaches, and hence also share their limitation.
All approaches share the same limitation that they consider the
library itself as the single source to ﬁnd replacement APIs, andonly Wu et al. [
89] further consider libraries of the same vendor.
Therefore, the accuracy of these approaches are limited.
To address the limitations, we ﬁrst conduct an empirical study
to characterize missing APIs and their replacement APIs. Here,
we regard public methods in public classes as APIs. Speciﬁcally,we quantify the prevalence of missing APIs in 85 major version
updates, 771 minor version updates and 1,048 patch version up-dates from 200 widely-used libraries. On average, 720, 330 and244 APIs are missing in major, minor and patch version updates.Moreover, we manually ﬁnd the replacement APIs for 738 miss-ing APIs in 99 version updates, and summarize the knowledgesources where the replacements are found, and the code change
and mapping cardinality between missing APIs and their re-
placements. Deprecation message, own library, and external li-
brary are the three sources to ﬁnd replacements, respectively
accounting for 13.6%, 50.8% and 14.6% of the missing APIs.Code change from missing APIs to their replacements can be
categorized into refactoring (64.4%), substitution (4.2%) and
deletion (13.6%). One-to-one mapping (91.1%) is the common-
est cardinality between missing APIs and their replacements.
Then, inspired by our study, we propose a heuristic-based ap-
proach, named R EPFINDER , to automatically ﬁnd replacement
APIs for missing APIs in library update. R EPFINDER takes as
inputs the old library version before update, the new library
version after update, and an API that resides in the old libraryversion but is missing in the new library version, and returns the
replacement APIs. R
EPFINDER searches the three sources, i.e.,
deprecation message, own library and external library, to ﬁnd
replacement APIs. Speciﬁcally, we design a set of heuristics for
each source based on our empirical study, and hierarchically
combine them to ﬁnd replacement APIs.
To evaluate the effectiveness of R EPFINDER , we compared
REPFINDER with two state-of-the-art approaches, i.e., R EFD-
IFF[75] and A URA [89], on 683 missing APIs. R EPFINDER
signiﬁcantly outperformed R EFDIFFand A URA in recall by
up to 213.6% while having a slight decrease in precision by
2662021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000332021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678905
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
5.4%. Further, we evaluated the efﬁciency of R EPFINDER .
REPFINDER took one seconds on average to ﬁnd replacements
for a missing API. Moreover, we applied R EPFINDER to li-
brary update on 32 projects. R EPFINDER successfully found
replacements for all missing APIs for 65.6% projects.
In summary, this work makes the following contributions.
•We conduct an empirical study to characterize missing APIs
and their replacement APIs in library update.
•We propose a heuristic-based approach, named R EPFINDER ,
to ﬁnd replacements for missing APIs in library update.
•We conduct extensive experiments to demonstrate the effec-
tiveness and efﬁciency of R EPFINDER .
II. A NEMPIRICAL STUDY
In this section, we present an empirical study to characterize
missing APIs and their replacements to inspire approach design.
A. Study Design
We designed our study to answer the following four research
questions about missing APIs and their replacements.
•RQ1 Prevalence Analysis: How prevalent are missing APIs
in library evolution? (Sec. II-C)
•RQ2 Source Analysis: What are the knowledge sources for
ﬁnding replacements for missing APIs? (Sec. II-D)
•RQ3 Change Analysis: What is the code change between
missing APIs and their replacements? (Sec. II-E)
•RQ4 Cardinality Analysis: What is the mapping cardinality
between missing APIs and their replacements? (Sec. II-F)
Before elaborating our RQ design, we deﬁne some library terms
to avoid confusion. Library update refers to updating an old li-brary version to a new library version. Hereafter, old library ver-sion refers to the library version before library update, and newlibrary version refers to the library version after library update.
We designed
RQ1 to quantify the prevalence of missing APIs
in library evolution. To this end, for each of the collected library
version updates (Sec. II-B), we analyzed the number of public
classes and the number of public methods in public classes
that are deﬁned in the old library version but are missing in thenew library version through code differencing [
33]. Deﬁned by
semantic versioning [ 64], version numbers must take the form
ofX.Y.Z, where X,Yand Zdenotes the major, minor and patch
version. Bug ﬁxes not affecting APIs increment Z, backwards
compatible API changes or additions increment Y, and back-
wards incompatible API changes increment X. Generally, client
developers need no integration effort if updating to a patch
or minor version, but need some integration effort if updating
to a major version. Therefore, we conducted our prevalence
analysis via distinguishing major version updates (the old and
new library version have different major version), minor version
updates (the old and new library version have the same major
version but different minor version), and patch version updates
(the old and new library version have the same major and minor
version but different patch version). Our results from RQ1
aim to motivate the need of an automated approach to ﬁnd
replacements for missing APIs.Fig. 1. Prevalence of Missing APIs in Library Evolution
We designed RQ2 ,RQ3 and RQ4 to characterize the knowl-
edge sources for ﬁnding replacements for missing APIs, and thecode change and mapping cardinality between missing APIs andtheir replacements. To this end, for each of the collected missing
APIs in the collected library version updates (Sec.
II-B), two of
the authors separately found its replacements by analyzing APIusages in client projects, looking at library documentations, andsearching internet resources, and recorded its knowledge source,code change and mapping cardinality. Then, they discussed andinvestigated inconsistent cases together to reach consensus, andcategorized knowledge sources, code change and mapping car-dinality. Our results from
RQ2 ,RQ3 and RQ4 aim to capture
the characteristics of missing APIs and their replacements to
inspire the design of an automated approach.
B. Data Collection
To prepare library version updates for our RQs, we decided
to choose libraries that were truly used by client projects so that
i) the characteristics about missing APIs and their replacements
would be more realistic and more representative and ii) our man-
ual analysis would become more accurate as we could use clientprojects to help to conﬁrm whether the replacements we found
were correct. Hence, we selected the GitHub Java projects thatwere created after 2013, used Maven as the build tool, and had
more than 20 stars. These criteria were adopted to ensure projectquality and ease the extraction of libraries, which restricted ourselection to 2,567 projects. From these projects, we extracted atotal of 11,419 used libraries and 31,393 used library versions,
and collected library API calls using JavaParser [76].
For RQ1 , we chose 200 libraries that were most widely used
according to our collected library API calls. 3,030 library ver-
sions from these libraries were used, from which we generated a
version update for any two adjacent major, minor and patchversions. If multiple library versions shared the same major,
minor or patch version, we randomly selected one of them. Fi-nally, we prepared 85 major version updates, 771 minor version
updates, and 1,048 patch version updates.
For RQ2 ,RQ3 and RQ4 , we selected libraries whose library
APIs were called by more than ten times across projects to in-
crease the possibility of ﬁnding missing APIs called by projects,
which resulted in 999 libraries. Of these libraries, 230 libraries
had at least two library versions used in projects. 841 library
267TABLE I. Examples of Missing APIs and Their Replacements in Library Update
No. LibraryVersion
UpdateMissing API Replacement API Source
1org.mapdb
mapdb0.9.30.9.13 org.mapdb.DBMaker.writeAheadLogDisable() org.mapdb.DBMaker.transactionDisable() Deprecation
Message
2org.apache.lucene
lucene-core5.1.06.0.0 org.apache.lucene.search.PhraseQuery.add(Term) org.apache.lucene.search.PhraseQuery.Builder.add(Term)Own Library
3org.apache.lucene
lucene-core3.0.3
4.0.0org.apache.lucene.analysis.standard.StandardAnalyzer.StandardAnalyzer(Version) org.apache.lucene.analysis.standard.
StandardAnalyzer.StandardAnalyzer(Version)VendorLibrary
4org.elasticsearchelasticsearch 1.7.12.0.0 org.elasticsearch.common.joda.time.format.DateTimeFormatter.print(long) org.joda.time.format.DateTimeFormatter.print(long) Dependency
Library
5org.elasticsearchelasticsearch 0.20.6
1.2.1org.elasticsearch.common.trove.list.array.
TIntArrayList.toArray()gnu.trove.list.array.
TIntArrayList.toArray()SimilarLibrary
6org.jsoupjsoup 1.7.2
1.13.1org.jsoup.select.Elements.contains(Object) java.util.
ArrayList.contains(Object)JDK Library
7org.apache.solrsolr-solrj 4.10.46.6.2 org.apache.solr.client.solrj.util.
ClientUtils.toSolrInputDocument(SolrDocument)NADeprecation
Message
versions from these 230 libraries were used in projects, from
which we generated version updates in three ways. First, we se-
lected the smallest and the largest version as a version update to
simulate the largest version gap in library update. Second, we se-lected any two adjacent versions as a version update to simulatetimely library update. Third, we selected any two adjacent major
versions as a version update to simulate major library version
update where missing APIs are very common. If multiple library
versions had the same major version, we selected the version
with the highest API usage. We generated 183 major version
updates, 320 minor version updates, and 149 patch version
updates. Of these version updates, 77 major version updates, 19minor version updates and 3 patch version updates had missing
APIs called across projects, resulting in 738 missing APIs that
were from 37 libraries and truly called across projects.
C. Prevalence Analysis (RQ1)
Fig.1presents the average number of missing public classes
and missing public methods in major, minor and patch version
updates. We can observe that major version updates introduce
the most missing public classes and missing public methods,
which is consistent to semantic versioning; and minor version
updates and patch version updates also introduce some missingpublic classes and missing public methods, which actually vio-lates semantic versioning. Averagely, 81 public classes and 215public methods are missing in a major version update. If we in-
clude the public methods in missing public classes, a total of
720 public methods are missing. In a minor and patch version
update, 17 and 4 public classes and 27 and 6 public methods aremissing. These results indicate that missing APIs are prevalent
and severe in major version updates, and also occur in minor
and patch version updates.
D. Source Analysis (RQ2)
We summarize three sources, i.e., deprecation message, own
library, and external library, where the replacement APIs can be
found. First, for 100 (13.6%) of the 738 missing APIs, the depre-cation message in JavaDoc gives the hint about the replacement
APIs. Speciﬁcally, 94.0% of the deprecation messages include a
link tag for developer to navigate to the replacement API, whileothers (6.0%) do not include a link but list the replacement in
text. However, the deprecation message is not always in theJavaDoc of the old library version, but can be in the JavaDoc of
a library version that is released before the new library version.
This result indicates that API changes might not be always doc-
umented in JavaDoc.
Example 2.1: The second row of Table Ireports an example
that the API org.mapdb.DBMaker .writeAheadLogDisable() in
the old version 0.9.3 of the library mapdb is missing in the new
version 0.9.13. There is no deprecation message in the JavaDoc
of the old version 0.9.3. It turns out that the deprecation mes-
sage is in the JavaDoc of the version 0.9.4, and says that “use
transactionDisable() instead” with a link to the replacement.
Second, for 375 (50.8%) of the 738 missing APIs, their re-
placement APIs can be found in their own library, i.e., the newlibrary version. As refactoring is a common practice in library
evolution, some APIs are refactored to become missing in the
new library version (see Sec. II-E for a detailed discussion).
Notice that for the missing APIs whose replacements are foundby deprecation message, their replacements are actually also in
the new library version, but here we do not include them.
Example 2.2: For the second example in Table I, no depreca-
tion message can be found in the versions of the library lucene-
core for the missing API org.apache.lucene.search.Phrase-
Query.add(Term) in the version 6.0.0. After investigating the
source code of the version 6.0.0, we ﬁnd that the missing APIis moved from the class PhraseQuery to its inner class Builder.
Third, for 108 (14.6%) of the 738 missing APIs, their replace-
ments can be found in related external libraries. Speciﬁcally, thereplacements are found in the library with the same vendor (i.e.,
vendor library) for 45 missing APIs, the library that is declared
as a direct dependency (i.e., dependency library) for 29 missing
APIs, the library that provides a similar API to the missing API
(i.e., similar library) for 18 missing APIs, and the JDK library
for 16 missing APIs.
Example 2.3: In the third example in Table I, the API locates
in the version 3.0.3 of the library lucene-core, but is missing in
the version 4.0.0. It turns out that the lucene project evolves intoa multiple module project, and it reorganizes its modules afterthe version 3.0.3. As a result, the API, originally a part of themodule corresponding to the library lucene-core, is moved into
another module corresponding to the library lucene-analyzer-
common that shares the same vendor.
Example 2.4: In the fourth example in Table I, the library
268TABLE II. Code Change between Missing APIs and their Replacements
Code Change Change Level Change Action Deprecation Message Own Library External Library None
RefactoringClassMove Class - 71 56 -
Rename Class 15 62 - -
MethodPull Up Method 46 62 39 -
Push Down Method - 5 - -
Change Method Signature 8 89 3 -
Move Method 3 16 - -
SubstitutionClassSubstitute by Method with Different
Name from Another Class18 - - -
Substitute by Method with Same
Name from Another Class8 - - -
MethodSubstitute by Method with Different
Name from Own Class- 5 - -
DeletionClass Delete Class - - - 33
Method Delete Method - - - 67
Composition NA NA 2 65 10 -
joda-time is used by the library elasticsearch by copy-and-
paste in the version 1.7.1; i.e., the source code of joda-time is
directly included in the packages of elasticsearch.H o w e v e r ,i n
the version 2.0.0, the source code of joda-time has already been
removed from elasticsearch, which introduces the missing API.
elasticsearch declares joda-time as a direct dependency as it
itself also uses the APIs in joda-time.
Example 2.5: The ﬁfth example in Table Iis similar to Exam-
ple2.4. The library trove is used by the library elasticsearch by
copy-and-paste in the version 0.20.6. However, in the version
1.2.1, the source code of trove has already been removed from
elasticsearch, which introduces the missing API. The difference
from Example 2.4is that elasticsearch does not declare trove
as a direct dependency after removing the source code of trove.
Example 2.6: The sixth example in Table Ishows that the API
jsoup.select.Elements.contains(Object) in the old version 1.7.2
of library jsoup is missing in the new version 1.13.1. It turns out
that the class Elements in the old version 1.7.2 inherits the
class ArrayList in the JDK library, and overrides the method
contains(Object). However, in the new version 1.7.2, the method
contains(Object) is removed but the inheritance still exists, and
thus the replacement API is the method contains(Object) in
the class ArrayList in the JDK library.
Finally, of the remaining 155 missing APIs, 100 (13.6%)
missing APIs have no replacement; i.e., these missing APIs aresimply removed. Here we take a conservative approach to con-
clude that a missing API has no replacement. We ﬁrst use the
previous three sources to check whether we can ﬁnd a replace-ment. If not, we then look for clear evidences of no replacement;
e.g., deprecation message and release note that clearly say the
removal of a functionality, and the functionality of the missing
API is inlined in other methods. Still, we fail to ﬁnd replacement
for 55 missing APIs but cannot conclude no replacement.
Example 2.7: The last example in Table Ishows that the API
org.apache.solr .client.solrj.util.ClientUtils.toSolrInputDocu-ment(SolrDocument) in the old version 4.10.4 of the library
solr-solrj is missing in the new version 6.6.2. The deprecation
message clearly says that “this method will be removed in
Solr 6.0”, and we make the conclusion of no replacement.
E. Change Analysis (RQ3)
We categorize three basic code changes from missing APIs to
their replacements, i.e., refactoring, substitution and deletion,and a composition of these basic code changes. Table IIreports
a detailed categorization and its correlation to the sources
discussed in Sec. II-D. Here, we denote the old library version
aslo, the missing API as mo, the residing class of moinlo
asco, the replacement API as mn, the residing class of mn
ascn, and the residing library of mnasln.
The ﬁrst category is refactoring, covering 475 (64.4%) of
the missing APIs. If mndoes not reside in lo, we consider the
change from motomnas refactoring. Speciﬁcally, as shown
in the second column, refactoring can be conducted at two
different levels. At the class level, cocan be moved into a dif-
ferent package in ln, while mnis the same to moexcept for
the residing package name. cocan be renamed in ln, while mn
is the same to moexcept for the residing class name. At the
method level, mocan be pushed up or pushed down along
the inheritance tree. The signature of mocan be changed in
ln, including its return type, method name and parameter type.
mocan also be move into a different class in ln.
The second category is substitution, covering 31 (4.2%) of
the missing APIs. Substitution means that there exists another
API that can do the similar job to the missing API. Both
APIs can co-exist and later the missing API is deprecated and
ﬁnally removed. Thus, if mnalso resides in lo, we consider
the change from motomnas substitution. In particular, as
shown in the second column, substitution can be conducted at
two different levels. At the class level, mocan be substituted
by a method from another class, either with the same method
name or a different method name. At the method level, mo
can be substituted by a different method from its own class.
The third category is deletion, covering 100 (13.6%) of the
missing APIs, which means there is no need in the functionali-
ties the API provides and the library developer simply removesit in the new library version. Thus, only the 100 missing APIs
we conclude no replacement (i.e., the last column in Table II)
belong to this category. As shown in the second column,
deletion can be conducted at two different levels. At the class
level, cocan be deleted and thus moincois also deleted. At
the method level, mocan be deleted while costill exists.
Apart from these basic code changes, there are more complex
code changes, which are a composition of the three basic code
changes. For example, the signature of mocan be changed in
ln, and then the method is pushed up into its super class; or
269TABLE III. Examples of Missing APIs and Their Replacements with Various Cardinality
No. LibraryVersion
UpdateMissing API Replacement APIs
1redis.clients
jedis2.2.12.5.1 redis.clients.jedis.
JedisPoolConﬁg.setMaxActive(int)org.apache.commons.pool2.impl.GenericObjectPoolConﬁg.setMaxTotal(int)
org.apache.commons.pool2.impl.GenericObjectPoolConﬁg.setMaxIdle(int)
2org.apache.lucene
lucene-core3.0.3
4.0.0org.apache.lucene.document.NumericField.setIntValue(int)org.apache.lucene.document.IntField.setIntValue(int)org.apache.lucene.document.LongField.setIntValue(int)org.apache.lucene.document.FloatField.setIntValue(int)org.apache.lucene.document.DoubleField.setIntValue(int)
3org.apache.lucene
lucene-core2.9.33.5.0 org.apache.lucene.search.Hits.iterator()org.apache.lucene.search.IndexSearcher.search(Query, int)org.apache.lucene.search.ScoreDoc.docorg.apache.lucene.search.IndexSearcher.doc(int)
cois moved into a different package in ln, while the signature
ofmois changed. This category accounts for a total of 77
(10.4%) missing APIs.
F . Cardinality Analysis (RQ4)
From the 583 missing APIs that we ﬁnd replacements, we
categorize ﬁve types of mapping cardinality, i.e., one-to-one,
one-to-many, one-to-some, many-to-one and many-to-many. We
observe that most of the missing APIs (531, 91.1%) have a one-to-one mapping to their replacements. The ﬁrst six examples in
Table Ibelong to this category. Besides, 26, 6, 4 and 16 missing
APIs have a one-to-many, one-to-some, many-to-one and many-
to-many mapping to their replacements. Here, one-to-some
mapping means the missing API has more than one replacement,
and which one to use depends on the API usage context.
Example 2.8: The ﬁrst example in Table Ishows an example
of one-to-many mapping. The missing API sets the ﬁeld max-
Active. Its two replacements respectively set the ﬁeld maxTotal
and maxIdle.A s maxTotal -maxIdle equals maxActive, the
missing API can be replaced by the two replacements together.
Example 2.9: The second example in Table Ishows an exam-
ple of one-to-some mapping. The missing API belongs to the
class NumericField, which is later replaced by speciﬁc classes
IntField, LongField, FloatField and DoubleField. Depending
on the type of numeric ﬁeld used, the missing API can be
replaced by the API from one of the four classes.
Example 2.10: The third example in Table Ishows an exam-
ple of many-to-many mapping. The missing API is the methoditerator() from the class Hits, which is often used in the scenario
to iterate over all hits for a search query and get the documentfor each hit. However, in the version 3.5.0, lucene-core provides
another set of APIs to realize this scenario. Therefore, these
APIs, often used together, should be replaced together.
G. Insights
From our study results, we have several insights. I1:tools are
needed to help developers ﬁnd replacement APIs for missing
APIs in library update, as missing APIs are prevalent, especially
in major version updates. I2:multiple sources should be lever-
aged together to ﬁnd replacements for missing APIs, as a single
source alone usually fails to ﬁnd replacements for all missing
APIs. I3:replacement APIs can be found by searching depre-
cation message in JavaDoc or searching similar methods in the
own library or some external libraries, as missing APIs might
have deprecation message to indicate their replacements, and
are often refactored or substituted into a similar method in theSearching 
Deprecation 
MessageSearching 
Own 
LibrarySearching 
External 
Library
Library 
DatabaseReplacement 
APIs
Missing 
APILibrary 
Update
Fig. 2. Approach Overview of R EPFINDER
own library or some external libraries. I5: it is still useful to
only ﬁnd one-to-one mapping for missing APIs, as most missing
APIs have a one-to-one mapping to their replacements.
III. O URAPPROACH
Based on the insights from our study, we propose a heuristic-
based approach, named R EPFINDER , to automatically ﬁnd re-
placements for missing APIs in library update. As shown in
Fig.2, it takes as inputs a library update (i.e., an old library ver-
sion lobefore the update and a new library version lnafter the
update) and a missing API mothat is resides in lobut is missing
inln, and returns a set of replacement APIs M.REPFINDER
has three steps, i.e., parsing deprecation message, searchingown library and searching external library, to ﬁnd
M. Each
step leverages one of the three sources to heuristically ﬁnd M.
REPFINDER has a library database, where the jar ﬁle, JavaDoc
ﬁle and POM ﬁle for all library releases and JDK libraries arestored. We have a pipeline to regularly crawl them from Maven.
To ease the approach presentation, we formally deﬁne two
terms. A library version lis denoted as a three-tuple /angbracketleftgroup,
artifact, version /angbracketright, where group andartifact denote the ven-
dor and name of the library, and version denotes the version
number of the library. An API, which is considered as a publicmethod in a public class in this work, is denoted as a six-tuple
/angbracketleftlib, pkg, cls, ret, name, param/angbracketright , where lib,pkg andclsde-
note its residing library version, package and class, retdenotes
its return type, name denotes its method name, and param de-
notes a list of its parameter types.
A. Searching Deprecation Message
Given lo,lnandmo, the ﬁrst step of R EPFINDER is to ﬁnd re-
placement APIs by searching deprecation message. As depreca-
tion often follows a deprecate-replace-remove cycle, momight
be deprecated in a library version before ln. Thus, R EPFINDER
ﬁrst retrieves a sorted list of the JavaDoc ﬁles for all the library
versions from lotoln, denoted as D, from our library database.
As revealed by our empirical study, a deprecation message may
use a hyper link or a text to indicate the replacements. Besides,there is no deprecation message for
moifmo.clsis deprecated
270P1. Use [the] <a href=“ link”>text</a>
P2. Use [the] <code> text</code>
P3. Use [the] text [instead]
P4. Replaced [by][with] <a href=“ link”>text</a>
P5. Replaced [by][with] text
P6. In favor of <a href=“ link”>text</a>
P7. In favor of text
P8. Rename to <a href=“ link”>text</a>
P9. Rename to textP10. Call <a href=“ link”>text</a>
P11. Move to [the] text
P12. [may][will] be removed
Fig. 3. Matching Patterns for Deprecation Message
as a whole. Thus, R EPFINDER then iterates over Din a reverse
order to search deprecation messages with following heuristics.
•Method Deprecation with Link. REPFINDER analyzes the dep-
recation message by matching patterns in Fig. 3summarized
through our empirical study. If a pattern is matched, it extracts
the hyper link of the replacement APIs and resolves their pkg,
cls,ret,name andparam from the documentation.
•Method Deprecation with Text. REPFINDER extracts the tex-
tual information (e.g., cls,name andparam ) about the re-
placement APIs by matching patterns in Fig. 3. If matched, it
uses the textual information to validate the existence of the re-placement APIs in JavaDoc. If validated, it resolves their
pkg,
cls,ret,name andparam from their documentation.
•Class Deprecation with Link. REPFINDER extracts the hyper
link of the replacement class of mo.clsby matching patterns
in Fig. 3. If matched, it identiﬁes the replacement API whose
method name equals to mo.name and whose parameter types
equal to mo.param . If identiﬁed, it resolves its pkg,cls,ret,
name andparam from the documentation.
•Class Deprecation with Text. REPFINDER extracts the name
of the replacement class of mo.clsby matching patterns in
Fig. 3. If matched, it validates the existence of the replace-
ment class in JavaDoc. If validated, it ﬁnds the replacement
API whose method name equals to mo.name and whose pa-
rameter types equal to mo.param . If found, it resolves its
pkg,cls,ret,name andparam from the documentation.
It is worth mentioning that i) we use exact matching to ﬁnd re-placement classes and APIs to improve the accuracy; ii) we mayﬁnd multiple replacement APIs as the method deprecation mes-sage might list multiple replacement APIs; and iii) once the last
pattern in Fig. 3is matched, we conclude no replacement.
Finally, R EPFINDER validates whether the replacement APIs
exist in lnby searching the JavaDoc ﬁle of lnbecause the re-
placement APIs might be resolved from the JavaDoc ﬁle of a
library version before ln. If validated, R EPFINDER resolves the
lib, puts the replacement APIs to M, and returns M. If not,
REPFINDER continues to the next two steps.
B. Searching Own Library
Given lo,lnandmo, the second step of R EPFINDER is to ﬁnd
the replacement API by searching ln.REPFINDER retrieves the
jar ﬁle of lnfrom our library database and ﬁnds the replacementAPI by sequentially applying following heuristics. Our idea is to
ﬁrst ﬁnd the API with identical name in super or similar classes
asmomay be moved to such classes (see Table II), and then
ﬁnd the API with similar name in super or similar classes as
momay be moved to such classes and changed (see Table II).
•Search Identical API in Super Classes. REPFINDER checks
whether mo.clsexists in ln. If yes, it analyzes mo.clsto ob-
tain its parent class and grant parent class. Here, we empiri-cally only track two super classes based on observations fromour empirical study. Then, it checks whether each super classexists in
ln. If yes, it analyzes the super class in lnto ﬁnd the
replacement API whose name equals to mo.name and whose
parameter types equal to mo.param . If found, it puts the
replacement API to Mand returns M. Notice that if we ﬁnd
the replacement API from both its parent class and grant par-
ent class, we use the replacement API from its parent class.
•Search Identical API in Similar Classes. REPFINDER checks
whether mo.pkg exists in ln. If yes, it iterates over each class
clsunder mo.pkg inlnto compute the distance from clsto
mo.clsby tokenizing class name according to camel case and
changing plurals into singles before applying Levenshtein dis-tance [
52]. For the classes that are similar to mo.cls(i.e., the
class distance is smaller than thc), it analyzes the class from
the smallest class distance to the largest class distance to ﬁnd
the replacement API whose name equals to mo.name and
whose parameter types equal to mo.param . Once it ﬁnds the
replacement API, it puts it to Mand returns M. Besides, if
mo.pkg does not exist in ln, it searches across all packages
inlnin the same way to the above procedure.
•Search Similar API in Super Classes. This heuristic shares the
same procedure to the ﬁrst heuristic except that it ﬁnds the re-placement API that is similar but not identical to
mo. To this
end, we borrow the distance metric from Nguyen et al.’s work[
59], which is computed as a weighted sum of the distances of
return types, method names and parameter types, as shown in
Eq.1, where dis() computes the Levenshtein distance [ 52].
dis(mo,mn)=0 .25∗dis(mo.ret, m n.ret)
+0.50∗dis(mo.name, m n.name)
+0.25∗dis(mo.param, m n.param )(1)
For the APIs whose distance to mois smaller than th1
m, it se-
lects the API with the smallest distance as the candidate API,
which will be ﬁnally determined in the last step.
•Search Similar API in Similar Classes. This heuristic has the
same procedure to the second heuristic except that it ﬁnds the
replacement API that is similar but not identical to mo. Thus,
it applies the same distance metric to the third heuristic to ﬁnd
candidate API except that a different threshold th2
mis used.
C. Searching External Library
Given lo,ln,moand the candidate API, the last step of
REPFINDER is triggered only when R EPFINDER does not ﬁnd
the replacement APIs or only ﬁnds the candidate API in the
previous steps. Our idea is to ﬁnd the API with identical name
in super or identical classes in some external libraries as mo
may be moved to such classes (see Table II).
271To this end, it ﬁrst collects four lists of external libraries, re-
spectively for JDK library, dependency library, vendor library
and similar library (see Sec. II-D). Speciﬁcally, it retrieves the
jar ﬁle of a speciﬁc JDK library version, which can be conﬁg-
ured by users as they often know the JDK library version their
projects use, from our library database, and puts it to Lj. Be-
sides, it retrieves the POM ﬁle of ln, uses the method in Wang
et al. [ 86] to parse the POM ﬁle for a list of direct library depen-
dencies of ln, retrieves their jar ﬁle from our library database,
and puts them to Ld. Further, it queries our library database for
all the libraries with the same group to lo.group but a different
artifact to lo.artifact . For each of such vendor libraries, it
selects the same version number to ln.version if exists; other-
wise, it selects the version number whose release date is no later
than lnbut is closest to ln, and then retrieves its jar ﬁle from
our library database and puts it to Jv. Finally, it uses tokens in
mo.pkg,mo.clsandmo.name to query our library database,
which is indexed with libraries’ group and artifact, selects the
top ten hits as similar libraries, selects their version number
whose release date is no later than lnbut is closest to ln, and
puts their jar ﬁles to Js.
Then, R EPFINDER sequentially iterates over the four types
of external libraries Lj,Ld,LvandLsto ﬁnd the replacement
API. This order is inspired by our empirical study as Ljhas the
highest possibility to provide the replacement while Lshas the
lowest possibility. Once a replacement API is found during theiteration, R
EPFINDER returns it. Only if no replacement API is
found in these external libraries, R EPFINDER returns the candi-
date API as the replacement. R EPFINDER uses following two
heuristics to ﬁnd the replacement in an external library le.
•Search Identical API in Super Classes. This heuristic has the
same procedure as the ﬁrst heuristic in Sec. III-B except that
it checks whether each super class exists in lebut not ln, and
if yes, it ﬁnds the identical API in the super class in le.
•Search Identical API in Identical Classes. This heuristic is
similar to the second heuristic in Sec. III-B . It checks whether
mo.pkg exists in le. If yes, it iterates over each class clsun-
dermo.pkg inleto ﬁnd the class whose name is identical to
mo.cls. If found, it analyzes the class to ﬁnd the replacement
API whose name is identical to mo.name and whose pa-
rameter types are identical to mo.param . Once it ﬁnds the
replacement API, it puts it to Mand returns M. Besides, if
mo.pkg does not exist in le, it searches across all packages
inlein the same way to the above procedure.
IV . E V ALUATION
We have implemented a prototype of R EPFINDER in 18.2K
lines of Java code, and released the source code at our website
https://repﬁnder.github.io/ with our experimental data set.
A. Evaluation Setup
To evaluate the effectiveness and efﬁciency of R EPFINDER ,
we designed our evaluation to answer four research questions.
•RQ5 Effectiveness Evaluation: How is the effectiveness of
REPFINDER , compared with state-of-the-art approaches?TABLE IV. Effectiveness Comparison to State-of-the-Art
Approach TP FP FN Pre. Rec.
AURA 159 135 576 0.54 0.22
REFDIFF 201 18 534 0.92 0.27
REPFINDER 509 75 226 0.87 0.69
•RQ6 Efﬁciency Evaluation: How is the time overhead of
REPFINDER in ﬁnding replacement APIs?
•RQ7 Sensitivity Analysis: How is the sensitivity of each pa-
rameter in R EPFINDER to the effectiveness of R EPFINDER ?
•RQ8 Application Analysis: How is effectiveness of apply-
ing R EPFINDER to library update in real-life projects?
Data Set. We used the 683 missing APIs whose replacements
were found or considered as none in our study (see Sec. II)a s
the data set for answering RQ5 ,RQ6 and RQ7 ; i.e., we did not
include the 55 uncertain missing APIs. Besides, to answer RQ8 ,
we used 32 GitHub Java projects to update their used libraries.
Comparison Approaches. For RQ5 , we selected two state-
of-the-art approaches: i) A URA [89], which is a hybrid approach
that combines similarity-based and usage-based approaches. Weselected it because it achieved the best performance over previ-ous approaches. ii) R
EFDIFF[75], which is the state-of-the-art
refactoring detection tool. Although R EFDIFFis not designed to
ﬁnd replacement APIs, we selected it because our study showed
that a large part of missing APIs were refactored into their re-
placement APIs. Notice that we failed to compare R EPFINDER
with H IMA[50] which is another hybrid approach, as it requires
libraries to use SVN but now libraries seldom use SVN. A URA
and R EFDIFFtake as inputs two library versions, and detect all
API mappings or API refactorings between the two versions. To
align with our data set, we ﬁltered their results to check whetherthey found the replacements for the missing API in our data set.
Evaluation Metrics. We used precision and recall as the in-
dicator of effectiveness as they were widely used in prior work.For the ease of computation for precision and recall, similar to
A
URA [89], we converted a one-to-many mapping as many one-
to-one mappings, a one-to-some mapping as a one-to-one map-
ping (i.e., we treated ﬁnding one of the some replacements as
correct), and a many-to-one mapping as a one-to-one mapping
and a many-to-many mapping as many one-to-one mappings
(i.e., we only targeted the missing API). Due to such conversion,
we had 735 mappings to ﬁnd for 683 missing APIs.
B. Effectiveness Evaluation (RQ5)
Table IVreports the overall results of A URA,REFDIFFand
REPFINDER with respect to true positive (TP), false positive
(FP), false negative ( FN), precision (Pre.) and recall (Rec.). We
can see that R EPFINDER signiﬁcantly increased the number of
true positives and reduced the number of false negatives, and
thus signiﬁcantly outperformed A URA and R EFDIFFin recall
by 213.6% and 155.6%. However, R EPFINDER had a higher
number of false positives than R EFDIFF, resulting in a 5.4%
decrease in precision than R EFDIFF; but R EPFINDER had a
lower number of false positives than A URA, resulting in a 61.1%
increase in precision than A URA. Besides, although R EFDIFF
was not originally designed for ﬁnding replacements, it achieved
the highest precision as it could accurately detect refactorings.
272TABLE V. Effectiveness Comparison w.r.t. Sources
Source Num.AURA REFDIFF REPFINDER
TP FP FN Pre. Rec. TP FP FN Pre. Rec. TP FP FN Pre. Rec.
Deprecation Message 111 11 9 100 0.55 0.10 51 1 60 0.98 0.46 94 15 17 0.86 0.85
Own Library 400 74 95 326 0.44 0.19 54 14 346 0.79 0.14 249 72 151 0.81 0.62
External Library 124 0 31 124 0.00 0.00 0 3 124 0.00 0.00 83 11 41 0.97 0.73
None 100 74 0 26 1.00 0.74 96 0 4 1.00 0.96 84 0 16 1.00 0.75
TABLE VI. Effectiveness Comparison w.r.t. Code Changes
Code Change Change Level Change Action Num.AURA REFDIFF REPFINDER
Pre. Rec. Pre. Rec. Pre. Rec.
RefactoringClassMove Class 141 0.26 0.11 0.00 0.00 0.89 0.78
Rename Class 80 0.88 0.54 1.00 0.05 0.95 0.86
MethodPull Up Method 147 0.33 0.10 0.87 0.53 0.99 0.95
Push Down Method 5 0.25 0.20 1.00 0.20 0.80 0.80
Change Method Signature 103 0.30 0.08 0.81 0.20 0.82 0.62
Move Method 28 0.00 0.00 0.00 0.00 0.50 0.18
SubstitutionClassSubstitute by Method with Different
Name from Another Class26 0.00 0.00 0.00 0.00 0.48 0.50
Substitute by Method with Same
Name from Another Class8 0.00 0.00 1.00 0.13 0.89 1.00
MethodSubstitute by Method with Different
Name from Own Class5 0.00 0.00 0.00 0.00 0.25 0.20
DeletionClass Delete Class 33 1.00 0.79 1.00 1.00 1.00 0.73
Method Delete Method 67 1.00 0.72 1.00 0.87 1.00 0.76
Composition NA NA 92 0.16 0.03 0.00 0.00 0.54 0.23
Moreover, Table Vbreaks down the effectiveness results ac-
cording to the sources where the replacements are found, where
the second column (i.e., Num.) reports the number of mappings
each approach should ﬁnd (i.e., their sum should be 735). We
can observe that A URA and R EFDIFFachieved 0 precision and
recall for missing APIs whose replacements were found in ex-
ternal libraries, while R EPFINDER had a precision and recall of
0.97 and 0.73. It owes to the fact that A URA and R EFDIFFare
designed to not use the source of external libraries. Besides, forthe source of deprecation message, A
URA and R EFDIFFcould
still ﬁnd some replacement APIs by using the libraries, but
REPFINDER achieved the highest recall by directly leveraging
the knowledge in deprecation message. For the source of own
library, R EPFINDER achieved the highest precision and recall
as our heuristics are designed based on a deep understanding ofthe characteristics of missing APIs and their replacements. Forthe missing APIs with no replacement, R
EPFINDER had a lower
recall. These results demonstrate the importance of combining
different knowledge sources for ﬁnding replacements.
In addition, Table VIbreaks down the effectiveness results ac-
cording to the code changes between missing APIs and their re-placements. We can observe that for refactoring, R
EFDIFFhad a
0 precision for move class and move method and a low recall,
because i) R EFDIFFoften works at the commit level but it may
work not well at the library version level due to the large amount
of changes between versions, and ii) replacements can bein external libraries. A
URA achieved low precision and re-
call across most change actions, because i) some missing
APIs have limited usages and ii) replacements can be in ex-
ternal libraries. Instead, R EPFINDER achieved a balanced
precision and recall except for move method, because the
missing API can be moved into a class that has a dissimilar
name from its original residing class. For substitution, A URA
and R EFDIFFalmost failed to ﬁnd replacements. R EPFINDER
also achieved low precision and recall because the missing APIcan be substituted by a dissimilar method (in a dissimilar class).
For deletion, R EPFINDER had a lower recall than A URA and
REFDIFFbecause A URA and R EFDIFFfound no replacement
for a large number of missing APIs. For composition, allapproaches had low precision and recall, while R
EPFINDER
was the best. These results indicate that syntactic similarity
measures used in R EPFINDER may not be good enough to ﬁnd
replacement APIs, and some semantic similarity measures may
be designed to further improve R EPFINDER .
REPFINDER signiﬁcantly improved the state-of-the-art ap-
proaches in recall by up to 213.6%, while having a slightdecrease in precision by 5.4%. We believe a slight decrease
in precision is acceptable as recall increases satisfactorily.
C. Efﬁciency Evaluation (RQ6)
REPFINDER took 689 seconds for ﬁnding replacements for
683 missing APIs. On average, R EPFINDER took about one
second to ﬁnd the replacements for a missing API. We believethe efﬁciency of R
EPFINDER is good, and it can be practically
used by developers. The good efﬁciency of R EPFINDER owes to
the availability of a library database as well as our lightweightdesign of heuristics. Notice that we did not compared the time
overhead of A URA and R EFDIFFbecause they found all API
mappings or refactorings between two library versions.
REPFINDER took about one second to ﬁnd the replace-
ments for a missing API, which was acceptable for prac-
tical usage by developers.
D. Sensitivity Analysis (RQ7)
Three thresholds, i.e., the class distance threshold thcand
two method distance thresholds th1
mandth2m, are conﬁgurable
in the second step of R EPFINDER (see Sec. III-B ). The default
conﬁguration is 2, 1.5 and 2, which is used in the experiment for
273(a)thc (b)th1
m (c)th2m
Fig. 4. Results of Parameter Sensitivity Analysis
TABLE VII. Code Change between Missing APIs and their Replacements
Code Change Change Level Change Action Deprecation Message Own Library External Library None
RefactoringClassMove Class - 5 50 -
Rename Class - 3 - -
MethodPull Up Method 15 8 - -
Push Down Method - - - -
Change Method Signature 1 5 1 -
Move Method - - - -
SubstitutionClassSubstitute by Method with Different
Name from Another Class1 - 2 -
Substitute by Method with Same
Name from Another Class4 1 - -
MethodSubstitute by Method with Different
Name from Own Class1 - - -
DeletionClass Delete Class - - - -
Method Delete Method - - - 4
Composition NA NA - 1 - -
RQ5 ,RQ6 and RQ8 . To evaluate their sensitivity to the effec-
tiveness of R EPFINDER , we re-conﬁgured one threshold and
ﬁxed the other two, and re-ran R EPFINDER against our data set.
Speciﬁcally, thcwas conﬁgured from 1 to 5 by a step of 1, and
th1
mandth2mwere conﬁgured from 0.5 to 5 by a step of 0.5.
Fig.4presents the impact of three thresholds on the precision
and recall of R EPFINDER , where x-axis denotes the value of
threshold, and y-axis denotes the precision or recall. Overall, as
thcincreased, the recall of R EPFINDER ﬁrst increased and then
stabilized, while its precision was almost stable. Thus, we be-
lieve 2.0 is a good value for thc.A s th1mincreased, the
recall and precision of R EPFINDER were ﬁrst stable and then
decreased. Thus, we believe 1.5 is a good value for th1m.
Asth2mincreased, the recall of R EPFINDER ﬁrst greatly
increased and then slightly decreased, while its precision
slightly decreased. Hence, we believe 2 is a good value for th2m.
Overall, the sensitivity of the conﬁgurable parameters to
the effectiveness of R EPFINDER is acceptable.
E. Application Analysis (RQ8)
To apply R EPFINDER to library update in real-life projects,
we initially selected 168 GitHub Java projects which had more
than 1000 stars and used Maven as the build tool. We analyzed
the library dependencies in these projects, and found that 121
projects used 690 outdated library versions. Here we set our
goal to update these outdated library versions to their latest
version. Thus, we analyzed library API usage in these projects,
and found that 59 outdated library versions in 33 projects had
105 used APIs missing in their latest version. Two of the authorsTABLE VIII. Effectiveness Comparison to State-of-the-Art
Approach TP FP FN Pre. Rec.
AURA 10 25 104 0.29 0.09
REFDIFF 29 5 85 0.85 0.25
REPFINDER 84 4 30 0.95 0.74
followed the same procedure to Sec. II-A to manually ﬁnd the
replacements, but could not determine the replacements for 3
missing APIs. Hence, we ran R EPFINDER against these 102
missing APIs, involving 57 outdated library versions in 32
projects. Notice that these 102 missing APIs had a overlapof 6 missing APIs to our data set in
RQ5 . Moreover, we
also categorized code changes of these missing APIs to their
replacements in Table VII. Compared to the results in Table II,
three change actions, i.e., push down method, move method,
and delete class, were not covered, indicating a relatively good
representativity of this data set.
REPFINDER achieved a precision of 0.95 and a recall of 0.74
on the 114 mappings for these 102 missing APIs, which were
comparable to the results in RQ5 , demonstrating the generality
of R EPFINDER . Speciﬁcally, R EPFINDER successfully found
replacements for all missing APIs for 21 (65.6%) projects,for partial missing APIs for 7 (21.9%) projects, but for no
missing APIs for 4 (12.5%) projects. This result indicates that
REPFINDER can be effectively used in real-life projects.
Moreover, we also compared R EPFINDER with A URA and
REFDIFFon this data set, as reported in Table VIII. While
REFDIFFand R EPFINDER achieved similar performance when
compared to the results in Table IV,A URA had a performance
degradation. Besides, we also broke down the effectivenessresults on this data set according to the sources and code
274TABLE IX. Effectiveness Comparison w.r.t. Sources
Source Num.AURA REFDIFF REPFINDER
TP FP FN Pre. Rec. TP FP FN Pre. Rec. TP FP FN Pre. Rec.
Deprecation Message 22 0 12 22 0.00 0.00 18 1 4 0.95 0.82 21 1 1 0.96 1.00
Own Library 35 9 4 26 0.70 0.26 8 2 27 0.80 0.23 17 1 18 0.94 0.49
External Library 53 0 9 53 0.00 0.00 0 2 53 0.00 0.00 34 11 19 0.96 0.81
None 4 1 0 3 1.00 0.25 3 0 1 1.00 0.75 2 0 2 1.00 0.50
TABLE X. Effectiveness Comparison w.r.t. Code Changes
Code Change Change Level Change Action Num.AURA REFDIFF REPFINDER
Pre. Rec. Pre. Rec. Pre. Rec.
RefactoringClassMove Class 55 0.40 0.07 0.00 0.00 0.96 0.87
Rename Class 3 0.00 0.00 1.00 0.67 1.00 1.00
MethodPull Up Method 23 0.13 0.09 0.95 0.87 0.96 0.96
Push Down Method - - - - - - -
Change Method Signature 7 0.75 0.43 0.33 0.14 1.00 0.43
Move Method - - - - - - -
SubstitutionClassSubstitute by Method with Different
Name from Another Class3 0.00 0.00 0.00 0.00 1.00 0.33
Substitute by Method with Same
Name from Another Class5 0.00 0.00 0.00 0.00 0.80 0.80
MethodSubstitute by Method with Different
Name from Own Class1 0.00 0.00 0.00 0.00 1.00 1.00
DeletionClass Delete Class - - - - - - -
Method Delete Method 4 1.00 0.25 1.00 0.75 1.00 0.50
Composition NA NA 13 0.00 0.00 0.00 0.00 0.00 0.00
changes, as shown in Table IXandX. Compared to the results
in Table VandVI, most of the ﬁndings still hold. These results
further demonstrate the generality of R EPFINDER .
REPFINDER effectively found replacements for all missing
APIs for 65.6% projects when all their outdated library
versions were updated to the latest version.
F . Discussion
Limitations. First, R EPFINDER mainly supports one-to-one
mappings, and only provides partial support for one-to-many
and one-to-some mappings by searching deprecation messages.
We believe it is still useful as the majority of missing APIs have
a one-to-one mapping to their replacements. One potential way
to enhance R EPFINDER is to consider the APIs called around
the missing API and its found replacement to determine the
possibility of a many-to-many mapping. Second, R EPFINDER
does not achieve good performance when the replacement
API is dissimilar from the missing API or the residing class
of replacement API is dissimilar from the residing class of
missing API because R EPFINDER only leverages syntactic
similarity measures. We plan to leverage semantic similarity
measures (e.g., code representation learning [ 1,98]) to improve
REPFINDER . Third, R EPFINDER is currently implemented for
the Java programming language. It is interesting to explore the
generality of R EPFINDER to other programming languages.
Threats. The main threat to our empirical study and evalua-
tion is the manual construction of the replacements for missing
APIs. To mitigate the threat, two of the authors conducted an
independent analysis followed by a group discussion to make
conclusions about replacement APIs. Further, we also intention-ally focused on missing APIs that were actually used in client
projects such that we could use the API usage information to
help conclude whether the replacement APIs identiﬁed by two
of the authors were correct or not.V. R ELATED WORK
We discuss the closely relevant work in ﬁve aspects, i.e., API
adaptation, API deprecation, API breaking, API evolution and
refactoring detection.
A. API Adaptation
A number of API adaptation approaches have been developed
to update usages of missing APIs in client projects to usages of
their replacement APIs for the ease of library update. To ﬁnd themapping between a missing API and its replacement, Chow andNotkin [
13] and Nita and Notkin [ 60] designed method to allow
library developers to manually specify the mapping. Henkel andDiwan [
29] developed an IDE plugin to allow library developers
to record API refactoring actions and allow client developers toreplay them. These approaches often provide accurate mappingsdue to the manual involvement of library developers. In practice,however, such involvement is often not available, which hindersthe generalizability of these approaches. Godfrey and Zou [
26]
proposed a semi-automated origin analysis using similarities ofname, declaration, complexity metrics and call dependencies. In-spired by this approach, Kim et al. [
37] extended the similarity
measures and automated Godfrey and Zou’s approach. Xing andStroulia [
95] used a set of heuristics to infer replacement APIs
based on API changes identiﬁed from logical design models oftwo library versions. These similarity-based approaches identifyreplacement APIs from the source of the library itself but do notconsider other sources. Sch
¨afer et al. [ 74] proposed to mine the
mapping from API usage changes in library’s instantiation code
(e.g., client projects), and Dagenais and Robillard [ 17,18] tried
to mine the mapping from API usage changes in library’s owncode. These usage-based approaches heavily rely on API usagesin instantiation code or own code, and are practically infeasibleas API usages are often not rich (since library’s own code doesnot call every API, and only a small portion of APIs are called
275across client projects [ 86]). Wu et al. [ 89] combined similarity-
based and usage-based approaches, and considered the source of
libraries of the same vendor. Meng et al. [ 50] analyzed commit
message to infer the mapping in two consecutive commits andconﬁrmed the mapping by analyzing source code, expanded themapping in the similar way to similarity-based and usage-basedapproaches, and aggregated the mapping across commits. These
hybrid approaches share similar limitations to similarity-based
and usage-based approaches. Cossette and Walker [ 15] reported
a retroactive study with ﬁve Java libraries to manually evaluate aset of techniques. Lamothe and Shang [
42] explored how docu-
mentation and commits could be leveraged to ﬁnd the mapping
for Android APIs. Wu et al. [ 91] investigated how imperfect
mappings affected client developers in updating libraries. It is
worth mentioning that several approaches have been proposed
for ﬁnding API mappings across similar libraries (e.g., [ 78,79])
and different programming languages (e.g., [10, 99]).
To update usages of a missing API in client projects to usages
of its replacement, several approaches have been proposed, e.g.,by replacing calls to a deprecated API with its bodies [
61], by
type constraint analysis [ 2], by heuristic rules [ 81,94], and by
historical update examples [ 24,43,59,80,96]. Our approach
is orthogonal to these approaches.
B. API Deprecation
Various empirical studies have been conducted to understand
API deprecation in different programming languages. Zhou et
al. [100] found that the classic deprecate–replace–remove cycle
is often not followed as many APIs were removed without prior
deprecation, many deprecated APIs were un-deprecated later,
and many removed APIs are even resurrected. Some studies ex-
plored why developers deprecated APIs [ 53,70,71], e.g., avoid-
ing bad code practices, functional and security bugs, redundantmethods, merged into existing methods, and renaming methods.
These studies reveal the importance of reacting to API depreca-
tion. Otherwise, the quality or maintainability of client projects
might be hurt. However, some studies studied how developers
reacted to API deprecation [ 45,68,70,72,73,84], and found
that deprecated APIs were still widely used due to reasons likeno suitable replacements and high update effort. Besides, somestudies investigated the quality of documentation for deprecated
APIs [ 8,9,38,45,58,84]. They found that 67%, 78%, 67%,
53% and 78% of the APIs were deprecated with replacement
messages in Java, C#, JavaScript, Python and Android. Apart
from API documentation, we leverage other sources for ﬁndingreplacement APIs. Except for API deprecation, Cogo et al. [
14]
analyzed how often and why package releases were deprecated
in npm, and how client packages adopted deprecated releases.
C. API Breaking
Many empirical studies have investigated API breaking to an-
alyze how and why developers break APIs [ 4,5,7,35,93], how
API breaking impacts client projects [ 67,92], etc. Besides, sev-
eral advances have been made to detect API breaking. Theoremproving [
25,27,41,47,48] and symbolic execution [ 56,82] areused to detect behavioral API breaking, but suffer scalability is-sues. To be scalable, testing techniques are used to dynamicallydetect behavioral API breaking in Java [
12,28,77], and heuris-
tics are applied to statically detect signature API breaking (e.g.,
changes to API signatures) in Java [ 6]. In JavaScript, testing
techniques are used to identify signature breaking [ 51,55] and
behavioral breaking [ 57], and heuristics are used to detect both
signature and behavioral breaking [ 54]. Our approach is focused
on signature API breaking as there is no need to ﬁnd replace-
ments for behavioral breaking APIs.
D. API Evolution
Several empirical studies have explored API evolution to un-
derstand how refactoring affects API evolution [ 22,23,36,40],
how client developers react to API evolution [ 30,31,85], how
API stability is measured [ 49,66], how Android API evolution
affects apps’ user ratings [ 3], how APIs are changed and used in
Apache and Eclipse [ 90], how API evolution triggers stack over-
ﬂow discussions [ 46], how and why APIs are evolved [ 32], etc.
Our empirical study on missing APIs has a different goal than
these studies, and provides insights for our approach.E. Refactoring Detection
Several refactoring detection approaches have been proposed,
e.g., R EFDIFF[75], R EPFINDER [65] and RM INER [83]. How-
ever, such tool cannot be directly applied to ﬁnd replacement
APIs because they are mostly work at the commit level and
library version-level changes would be much more complex
than commit-level changes.
VI. C ONCLUSIONS
In this paper, we have presented an empirical study to under-
stand the characteristics of missing APIs and their replacements.
Inspired by our study results, we have propose a heuristic-based
approach, named R EPFINDER , to automatically ﬁnd replace-
ments for missing APIs in library update. The key idea of
REPFINDER is to leverage multiple sources to ﬁnd replace-
ments. Our evaluation has demonstrated that R EPFINDER can
ﬁnd replacement APIs effectively and efﬁciently, and signiﬁ-
cantly outperformed the state-of-the-art approaches.
ACKNOWLEDGMENT
This work was supported by the National Natural Science
Foundation of China (Grant No. 61802067). Bihuan Chen is
the corresponding author of this paper.
REFERENCES
[1]M. Allamanis, E. T. Barr, P. Devanbu, and C. Sutton, “A survey of
machine learning for big code and naturalness,” ACM Computing
Surveys, vol. 51, no. 4, p. 81, 2018.
[2]I. Balaban, F. Tip, and R. Fuhrer, “Refactoring support for class library
migration,” in OOPSLA, 2005, pp. 265–279.
[3]G. Bavota, M. Linares-Vasquez, C. E. Bernal-Cardenas, M. Di Penta,
R. Oliveto, and D. Poshyvanyk, “The impact of api change-and fault-
proneness on the user ratings of android apps,” IEEE Transactions on
Software Engineering, vol. 41, no. 4, pp. 384–407, 2014.
[4]C. Bogart, C. K ¨astner, J. Herbsleb, and F. Thung, “How to break an api:
Cost negotiation and community values in three software ecosystems,”
inFSE, 2016, pp. 109–120.
276[5]A. Brito, M. T. Valente, L. Xavier, and A. Hora, “You broke my code:
understanding the motivations for breaking changes in apis,” Empirical
Software Engineering, vol. 25, no. 2, pp. 1458–1492, 2020.
[6]A. Brito, L. Xavier, A. Hora, and M. T. Valente, “Apidiff: Detecting
api breaking changes,” in SANER, 2018, pp. 507–511.
[7]A. Brito, L. Xavier, A. Hora, and M. T. Valente, “Why and how java
developers break apis,” in SANER, 2018, pp. 255–265.
[8]G. Brito, A. Hora, M. T. Valente, and R. Robbes, “Do developers
deprecate apis with replacement messages? a large-scale analysis on
java systems,” in SANER, 2016, pp. 360–369.
[9]G. Brito, A. Hora, M. T. Valente, and R. Robbes, “On the use of
replacement messages in api deprecation: An empirical study,” Journal
of Systems and Software, vol. 137, pp. 306–321, 2018.
[10] N. D. Bui, Y . Yu, and L. Jiang, “Sar: learning cross-language api
mappings with little knowledge,” in ESEC/FSE, 2019, pp. 796–806.
[11] M. Cadariu, E. Bouwers, J. Visser, and A. van Deursen, “Trackingknown security vulnerabilities in proprietary software systems,” in
SANER, 2015, pp. 516–519.
[12] L. Chen, F. Hassan, X. Wang, and L. Zhang, “Taming behavioralbackward incompatibilities via cross-project testing and analysis,” in
ICSE, 2020, pp. 112–124.
[13] K. Chow and D. Notkin, “Semi-automatic update of applications in
response to library changes,” in ICSM, 1996, pp. 359–368.
[14] F. R. Cogo, G. A. Oliva, and A. E. Hassan, “Deprecation of packages
and releases in software ecosystems: A case study on npm,” IEEE
Transactions on Software Engineering, 2021.
[15] B. E. Cossette and R. J. Walker, “Seeking the ground truth: a retroactive
study on the evolution and migration of software libraries,” in FSE,
2012, p. 55.
[16] J. Cox, E. Bouwers, M. van Eekelen, and J. Visser, “Measuringdependency freshness in software systems,” in ICSE, vol. 2, 2015,
pp. 109–118.
[17] B. Dagenais and M. P. Robillard, “Semdiff: Analysis and recommenda-
tion support for api evolution,” in ICSE, 2009, pp. 599–602.
[18] B. Dagenais and M. P. Robillard, “Recommending adaptive changes
for framework evolution,” ACM Transactions on Software Engineering
and Methodology, vol. 20, no. 4, p. 19, 2011.
[19] A. Decan, T. Mens, and M. Claes, “An empirical comparison ofdependency issues in oss packaging ecosystems,” in SANER, 2017,
pp. 2–12.
[20] A. Decan, T. Mens, and E. Constantinou, “On the impact of security
vulnerabilities in the npm package dependency network,” in MSR, 2018,
pp. 181–191.
[21] E. Derr, S. Bugiel, S. Fahl, Y . Acar, and M. Backes, “Keep me updated:
An empirical study of third-party library updatability on android,” in
CCS, 2017, pp. 2187–2200.
[22] D. Dig and R. Johnson, “The role of refactorings in api evolution,” in
ICSM, 2005, pp. 389–398.
[23] D. Dig and R. Johnson, “How do apis evolve? a story of refactoring,”
J. Softw. Maint. Evol., vol. 18, no. 2, pp. 83–107, 2006.
[24] M. Fazzini, Q. Xin, and A. Orso, “Automated api-usage update for
android apps,” in ISSTA, 2019, pp. 204–215.
[25] D. Felsing, S. Grebing, V . Klebanov, P. R ¨ummer, and M. Ulbrich,
“Automating regression veriﬁcation,” in ASE, 2014, pp. 349–360.
[26] M. W. Godfrey and L. Zou, “Using origin analysis to detect merging
and splitting of source code entities,” IEEE Transactions on Software
Engineering, vol. 31, no. 2, pp. 166–181, 2005.
[27] B. Godlin and O. Strichman, “Regression veriﬁcation: proving theequivalence of similar programs,” Software Testing, V eriﬁcation and
Reliability, vol. 23, no. 3, pp. 241–258, 2013.
[28] A. Gyori, O. Legunsen, F. Hariri, and D. Marinov, “Evaluating regression
test selection opportunities in a very large open-source ecosystem,” in
ISSRE, 2018, pp. 112–122.
[29] J. Henkel and A. Diwan, “Catchup! capturing and replaying refactorings
to support api evolution,” in ICSE, 2005, pp. 274–283.
[30] A. Hora, R. Robbes, N. Anquetil, A. Etien, S. Ducasse, and M. T.
Valente, “How do developers react to api evolution? the pharo ecosystem
case,” in ICSME, 2015, pp. 251–260.
[31] A. Hora, R. Robbes, M. T. Valente, N. Anquetil, A. Etien, and
S. Ducasse, “How do developers react to api evolution? a large-scale
empirical study,” Software Quality Journal, vol. 26, no. 1, pp. 161–191,
2018.
[32] D. Hou and X. Yao, “Exploring the intent behind api evolution: A case
study,” in WCRE, 2011, pp. 131–140.[33] K. Huang, B. Chen, X. Peng, D. Zhou, Y . Wang, Y . Liu, and W. Zhao,
“Cldiff: Generating concise linked code differences,” in Proceedings of
the 33rd ACM/IEEE International Conference on Automated Software
Engineering, 2018, p. 679–690.
[34] K. Huang, B. Chen, B. Shi, Y . Wang, C. Xu, and X. Peng, “Interactive,
effort-aware library version harmonization,” in ESEC/FSE, 2020, pp.
518–529.
[35] K. Jezek, J. Dietrich, and P. Brada, “How java apis break–an empirical
study,” Information and Software Technology, vol. 65, pp. 129–146,
2015.
[36] M. Kim, D. Cai, and S. Kim, “An empirical investigation into the roleof api-level refactorings during software evolution,” in ICSE, 2011, pp.
151–160.
[37] S. Kim, K. Pan, and E. J. Whitehead, “When functions change their
names: Automatic detection of origin relationships,” in WCRE, 2005,
pp. 10–pp.
[38] D. Ko, K. Ma, S. Park, S. Kim, D. Kim, and Y . Le Traon, “Apidocument quality for resolving deprecated apis,” in APSEC, vol. 2,
2014, pp. 27–30.
[39] R. G. Kula, D. M. German, A. Ouni, T. Ishio, and K. Inoue, “Dodevelopers update their library dependencies?” Empirical Software
Engineering, vol. 23, no. 1, pp. 384–417, 2018.
[40] R. G. Kula, A. Ouni, D. M. German, and K. Inoue, “An empirical study
on the impact of refactoring activities on evolving client-used apis,”
Information and Software Technology, vol. 93, pp. 186–199, 2018.
[41] S. K. Lahiri, C. Hawblitzel, M. Kawaguchi, and H. Reb ˆelo, “Symdiff:
A language-agnostic semantic diff tool for imperative programs,” in
CA V, 2012, pp. 712–717.
[42] M. Lamothe and W. Shang, “Exploring the use of automated apimigrating techniques in practice: An experience report on android,”
inMSR, 2018, pp. 503–514.
[43] M. Lamothe, W. Shang, and T.-H. P. Chen, “A3: Assisting android
api migrations using code examples,” IEEE Transactions on Software
Engineering, 2020.
[44] T. Lauinger, A. Chaabane, S. Arshad, W. Robertson, C. Wilson, and
E. Kirda, “Thou shalt not depend on me: Analysing the use of outdated
javascript libraries on the web,” in NDSS, 2017.
[45] L. Li, J. Gao, T. F. Bissyand ´e, L. Ma, X. Xia, and J. Klein, “Cda: Char-
acterising deprecated android apis,” Empirical Software Engineering,
vol. 25, no. 3, pp. 2058–2098, 2020.
[46] M. Linares-V ´asquez, G. Bavota, M. Di Penta, R. Oliveto, and D. Poshy-
vanyk, “How do api changes trigger stack overﬂow discussions? a study
on the android sdk,” in ICPC, 2014, pp. 83–94.
[47] S. McCamant and M. D. Ernst, “Predicting problems caused by
component upgrades,” in ESEC/FSE, 2003, pp. 287–296.
[48] S. McCamant and M. D. Ernst, “Early identiﬁcation of incompatibilities
in multi-component upgrades,” in ECOOP, 2004, pp. 440–464.
[49] T. McDonnell, B. Ray, and M. Kim, “An empirical study of api stability
and adoption in the android ecosystem,” in ICSM, 2013, pp. 70–79.
[50] S. Meng, X. Wang, L. Zhang, and H. Mei, “A history-based matching
approach to identiﬁcation of framework evolution,” in ICSE, 2012, pp.
353–363.
[51] G. Mezzetti, A. Møller, and M. T. Torp, “Type regression testing to
detect breaking changes in node. js libraries,” in ECOOP, 2018.
[52] F. P. Miller, A. F. Vandome, and J. McBrewster, Levenshtein Distance:
Information Theory, Computer Science, String (Computer Science),
String Metric, Damerau?Levenshtein Distance, Spell Checker , Hamming
Distance. Alpha Press, 2009.
[53] A. Mirian, N. Bhagat, C. Sadowski, A. P. Felt, S. Savage, and G. M.
V oelker, “Web feature deprecation: a case study for chrome,” in ICSE-
SEIP, 2019, pp. 302–311.
[54] A. Møller, B. B. Nielsen, and M. T. Torp, “Detecting locations in
javascript programs affected by breaking library changes,” in OOPSLA,
2020, pp. 1–25.
[55] A. Møller and M. T. Torp, “Model-based testing of breaking changes
in node. js libraries,” in ESEC/FSE, 2019, pp. 409–419.
[56] F. Mora, Y . Li, J. Rubin, and M. Chechik, “Client-speciﬁc equivalence
checking,” in ASE, 2018, pp. 441–451.
[57] S. Mujahid, R. Abdalkareem, E. Shihab, and S. McIntosh, “Using
others’ tests to identify breaking updates,” in MSR, 2020, pp. 466–476.
[58] R. Nascimento, A. Brito, A. Hora, and E. Figueiredo, “Javascript api
deprecation in the wild: A ﬁrst assessment,” in SANER, 2020, pp.
567–571.
[59] H. A. Nguyen, T. T. Nguyen, G. Wilson Jr, A. T. Nguyen, M. Kim,
277and T. N. Nguyen, “A graph-based approach to api usage adaptation,”
inOOPSLA, 2010, pp. 302–321.
[60] M. Nita and D. Notkin, “Using twinning to adapt programs to alternative
apis,” in ICSE, 2010, pp. 205–214.
[61] J. H. Perkins, “Automatically generating refactorings to support api
evolution,” in PASTE, 2005, pp. 111–114.
[62] H. Plate, S. E. Ponta, and A. Sabetta, “Impact assessment for vul-
nerabilities in open-source software libraries,” in ICSME, 2015, pp.
411–420.
[63] S. E. Ponta, H. Plate, and A. Sabetta, “Beyond metadata: Code-centric
and usage-based analysis of known vulnerabilities in open-source
software,” in ICSME, 2018, pp. 449–460.
[64] T. Preston-Werner, “Semantic versioning 2.0. 0,” http://semver . org,
2013.
[65] K. Prete, N. Rachatasumrit, N. Sudan, and M. Kim, “Template-based
reconstruction of complex refactorings,” in ICSM, 2010, pp. 1–10.
[66] S. Raemaekers, A. Van Deursen, and J. Visser, “Measuring software
library stability through historical version analysis,” in ICSM, 2012, pp.
378–387.
[67] S. Raemaekers, A. van Deursen, and J. Visser, “Semantic versioning
and impact of breaking changes in the maven repository,” Journal of
Systems and Software, vol. 129, pp. 140–158, 2017.
[68] R. Robbes, M. Lungu, and D. R ¨othlisberger, “How do developers react
to api deprecation? the case of a smalltalk ecosystem,” in FSE, 2012,
pp. 1–11.
[69] P. Salza, F. Palomba, D. Di Nucci, C. D’Uva, A. De Lucia, and
F. Ferrucci, “Do developers update third-party libraries in mobile apps?”
inICPC, 2018, pp. 255–265.
[70] A. A. Sawant, M. Aniche, A. van Deursen, and A. Bacchelli, “Under-
standing developers’ needs on deprecation as a language feature,” in
ICSE, 2018, pp. 561–571.
[71] A. A. Sawant, G. Huang, G. Vilen, S. Stojkovski, and A. Bacchelli,
“Why are features deprecated? an investigation into the motivation
behind deprecation,” in ICSME, 2018, pp. 13–24.
[72] A. A. Sawant, R. Robbes, and A. Bacchelli, “On the reaction todeprecation of 25,357 clients of 4+ 1 popular java apis,” in ICSME,
2016, pp. 400–410.
[73] A. A. Sawant, R. Robbes, and A. Bacchelli, “To react, or not to react:
Patterns of reaction to api deprecation,” Empirical Software Engineering,
vol. 24, no. 6, pp. 3824–3870, 2019.
[74] T. Sch ¨afer, J. Jonas, and M. Mezini, “Mining framework usage changes
from instantiation code,” in ICSE, 2008, pp. 471–480.
[75] D. Silva, J. Silva, G. J. D. S. Santos, R. Terra, and M. T. O.
Valente, “Refdiff 2.0: A multi-language refactoring detection tool,”
IEEE Transactions on Software Engineering, 2020.
[76] N. Smith, D. van Bruggen, and F. Tomassetti, “Javaparser: Visited,”
Leanpub, oct. de, 2017.
[77] G. Soares, R. Gheyi, D. Serey, and T. Massoni, “Making program
refactoring safer,” IEEE software, vol. 27, no. 4, pp. 52–57, 2010.
[78] C. Teyton, J.-R. Falleri, and X. Blanc, “Mining library migration graphs,”
inWCRE, 2012, pp. 289–298.
[79] C. Teyton, J.-R. Falleri, and X. Blanc, “Automatic discovery of function
mappings between similar libraries,” in WCRE, 2013, pp. 192–201.
[80] F. Thung, S. A. Haryono, L. Serrano, G. Muller, J. Lawall, D. Lo, and
L. Jiang, “Automated deprecated-api usage update for android apps:
How far are we?” in SANER, 2020, pp. 602–611.
[81] F. Thung, H. J. Kang, L. Jiang, and D. Lo, “Towards generating
transformation rules without examples for android api replacement,” in
ICSME, 2019, pp. 213–217.
[82] A. Trostanetski, O. Grumberg, and D. Kroening, “Modular demand-
driven analysis of semantic difference for program versions,” in SAS,
2017, pp. 405–427.
[83] N. Tsantalis, M. Mansouri, L. Eshkevari, D. Mazinanian, and D. Dig,
“Accurate and efﬁcient refactoring detection in commit history,” in ICSE,
2018, pp. 483–494.
[84] J. Wang, L. Li, K. Liu, and H. Cai, “Exploring how deprecated python
library apis are (not) handled,” in ESEC/FSE, 2020, pp. 233–244.
[85] S. Wang, I. Keivanloo, and Y . Zou, “How do developers react to restful
api evolution?” in ICSOC, 2014, pp. 245–259.
[86] Y . Wang, B. Chen, K. Huang, B. Shi, C. Xu, X. Peng, Y . Wu, and
Y . Liu, “An empirical study of usages, updates and risks of third-party
libraries in java projects,” in ICSME, 2020, pp. 35–45.
[87] Y . Wang, M. Wen, Y . Liu, Y . Wang, Z. Li, C. Wang, H. Yu, S.-C. Cheung,
C. Xu, and Z. Zhu, “Watchman: monitoring dependency conﬂicts forpython library ecosystem,” in ICSE, 2020, pp. 125–135.
[88] Y . Wang, M. Wen, Z. Liu, R. Wu, R. Wang, B. Yang, H. Yu, Z. Zhu,
and S.-C. Cheung, “Do the dependency conﬂicts in my project matter?”
inESEC/FSE, 2018, pp. 319–330.
[89] W. Wu, Y .-G. Gu ´eh´eneuc, G. Antoniol, and M. Kim, “Aura: a hybrid
approach to identify framework evolution,” in ICSE, 2010, pp. 325–334.
[90] W. Wu, F. Khomh, B. Adams, Y .-G. Gu ´eh´eneuc, and G. Antoniol,
“An exploratory study of api changes and usages based on apache and
eclipse ecosystems,” Empirical Software Engineering, vol. 21, no. 6,
pp. 2366–2412, 2016.
[91] W. Wu, A. Serveaux, Y .-G. Gu ´eh´eneuc, and G. Antoniol, “The impact
of imperfect change rules on framework api evolution identiﬁcation: an
empirical study,” Empirical Software Engineering, vol. 20, no. 4, pp.
1126–1158, 2015.
[92] L. Xavier, A. Brito, A. Hora, and M. T. Valente, “Historical and impactanalysis of api breaking changes: A large-scale study,” in SANER, 2017,
pp. 138–147.
[93] L. Xavier, A. Hora, and M. T. Valente, “Why do we break apis? ﬁrst
answers from developers,” in SANER, 2017, pp. 392–396.
[94] Y . Xi, L. Shen, Y . Gui, and W. Zhao, “Migrating deprecated api to
documented replacement: Patterns and tool,” in Internetware, 2019, pp.
1–10.
[95] Z. Xing and E. Stroulia, “Api-evolution support with diff-catchup,” IEEE
Transactions on Software Engineering, vol. 33, no. 12, pp. 818–836,
2007.
[96] S. Xu, Z. Dong, and N. Meng, “Meditor: inference and application of
api migration edits,” in ICPC, 2019, pp. 335–346.
[97] A. Zerouali, E. Constantinou, T. Mens, G. Robles, and J. Gonz ´alez-
Barahona, “An empirical analysis of technical lag in npm package
dependencies,” in ICSR, 2018, pp. 95–110.
[98] F. Zhang, B. Chen, R. Li, and X. Peng, “A hybrid code representation
learning approach for predicting method names,” Journal of Systems
and Software, vol. 180, 2021.
[99] W. Zheng, Q. Zhang, and M. Lyu, “Cross-library api recommendation
using web search engines,” in ESEC/FSE, 2011, pp. 480–483.
[100] J. Zhou and R. J. Walker, “Api deprecation: a retrospective analysisand detection method for code examples on the web,” in FSE, 2016,
pp. 266–277.
[101] M. Zimmermann, C. Staicu, C. Tenny, and M. Pradel, “Small world
with high risks: A study of security threats in the npm ecosystem,” in
USENIX Security, 2019.
278