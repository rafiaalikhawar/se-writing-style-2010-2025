Summary-Based Symbolic Evaluation for Smart Contracts
Yu Feng
yufeng@cs.ucsb.edu
University of California, Santa
BarbaraEmina Torlak
emina@cs.washington.edu
University of WashingtonRastislav Bodik
bodik@cs.washington.edu
University of Washington
ABSTRACT
This paper presents Solar, a system for automatic synthesis of
adversarialcontractsthat exploitvulnerabilitiesina victimsmart
contract. To make the synthesis tractable, we introduce a query
language as well as summary-based symbolic evaluation, which sig-
nificantlyreducesthenumberof instructionsthatoursynthesizer
needs to evaluate symbolically, without compromising the preci-
sionofthevulnerabilityquery.Weencodedcommonvulnerabilities
of smart contracts and evaluated Solar on the entire data set from
Etherscan.Ourexperimentsdemonstratethebenefitsofsummary-
based symbolic evaluation and show that Solar outperforms state-
of-the-art smart contracts analyzers, teether, Mythril, and Con-
tractFuzzer, in terms of running time and precision.
ACM Reference Format:
YuFeng,EminaTorlak,andRastislavBodik.2020.Summary-BasedSymbolic
Evaluation for Smart Contracts. In 35th IEEE/ACM International Conference
onAutomatedSoftwareEngineering(ASEâ€™20),September21â€“25,2020,Virtual
Event, Australia. ACM, New York, NY, USA, 12 pages. https://doi.org/10.
1145/3324884.3416646
1 INTRODUCTION
Smart contracts are programs running on top of blockchain plat-
formssuchasBitcoin[ 19]andEthereum[ 20].Theyinteractwith
each other to perform effective financial transactions in a dis-
tributed system without the intervention from trusted third parties
(e.g.,banks).Asmartcontractiswritteninahigh-levelprogram-
ming language (e.g., Solidity [ 23]), and it is typically comprisedof
a unique address, persistent storage holding a certain amount of
cryptocurrency(i.e.,EtherinEthereum),andasetoffunctionsthat
manipulate the persistent storage to fulfill credible transactions
without trusted parties. For contract-to-contract interaction, some
functions are public and callable by other contracts. Thanks to the
expressiveness afforded by thehigh-level programming languages
and the security guarantees from the underlying consensus proto-
col,smartcontractshaveshownmanyattractiveusecases,andtheir
numberhasskyrocketed,withover45million[ 11]instancescov-
ering financial products, online gaming, real estate [ 15], shipping,
and logistics [16].
Because all smart contracts deployed on a blockchain are freely
accessible through their public methods, any functional bugs or
vulnerabilities inside the contracts can lead to disastrous losses,
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Â© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-6768-4/20/09.
https://doi.org/10.1145/3324884.3416646as demonstrated by recent attacks [ 2,4,6,27]. For instance, the
code (simplified) in Figure 1 illustrates the notorious Reentrancy
attack [6]. When the victim program (3) issues a money transac-
tion to the attacker (2), it implicitly triggers the attackerâ€™s callback
method, which invokes the victimâ€™s method (i.e., withdraw ) again
to make another transaction withoutupdating thevictimâ€™s balance.
The attack maliciously extracted tokens from the victim and led
toafinanciallossof$150Min2016.Tomakethingsworse,smart
contracts are immutableâ€”once they are deployed, fixing their bugs
is extremely difficult due to the design of the consensus protocol.
Improving robustness of smart contracts is thus a pressing prac-
ticalproblem.Unsurprisingly,acomplexvulnerabilitylikeReen-
trancy typically involves interactions between multiple contracts,
which requires an analyzer to model the inter-contracts commu-
nication and reason about the execution in a preciseandscalable
way. But existing tools either aggressively overapproximate the
execution a smart contract and report warnings [ 34,48] that do
not correspond to feasible paths and therefore cannot be exploited,
ortheypreciselyenumerate[ 39,42,43]concretetraces ofasmart
contract, so cannot scale to large programs with many paths.
ThispaperpresentsSolar,anewpointinthedesignspaceof
smart contract analysis tools that achieves an effective trade-off
amongexpressiveness,precision,andscalability.Solarprovides
thesecurityanalystwithaquerylanguageforexpressing vulner-
ability patterns that can be exploited in an attack, as well as an
automatic engine for synthesizing an attack program (if one exists)
that exploits the given vulnerability. Our key insight is based on
the observation that an attacker typically exploits the vulnerability
bymakingasequenceoftransitions(callsoverpublicmethodsof
thevictim),inwhichstoragestatesarepreservedacrossdifferent
transitions. Because most types of vulnerabilities can be overap-
proximated through assertions over storage variables (Section 4.2),
thisinsightmotivatesaneffectivesummary-basedsymbolicevalua-
tiontechniquewherethesummaryofamethodsoundlymodelsits
side-effectoverstoragevariables,whichdramaticallyreducesthe
number of instructions that Solar has to re-evaluate symbolically.
Asaresult,Solarisabletoscalereasoningwithbetterprecision
to large contracts that are out of reach of existing symbolic exe-
cution[42,43]andfuzzing[ 39]tools.Furthermore,previoussum-
marization techniques [ 26,33] rely on symbolic execution and can
thereforeleadtosummariesthatareexponentialinprogramsize.
Ourtechnique relieson Rosette[ 47],a hybridsymbolic evaluator
thatcombinessymbolicexecutionandboundedmodelchecking,to
compute compact (i.e., polynomially-sized) and precise (i.e., encod-
ingallfeasibleboundedpaths)summariesattheprocedurelevel.
Using these summaries, Solar can perform precise all-paths anal-
ysis of a given contract while symbolically executing significantly
fewer paths than Rosette alone.
11412020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
This work is licensed under a Creative Commons Attribution International 4.0 License. 
Figure 1: Sample contracts to show the Reentrancy attack.
Touseourtool,asecurityanalystexpressesatargetvulnerability
query (e.g., the reentrancy vulnerability) as a declarative specifica-
tion. Solar then synthesizes an attack program that exploits the
victimâ€™spublicinterfacetosatisfythevulnerabilityquery.Given
this problem, a naive approach is to enumerate all possible can-
didate programs and then symbolically evaluate each of them tocheck if it satisfies the query. While precise, the naive approach
fails to scale to realistic contracts.
Evenwith summarization,the searchspaceis stilltoo largefor
brute-force enumeration. To address this issue, we partition the
searchspacebycasesplittingontherangeofsymbolicvariables,
whichallowsustosimultaneouslyexploremultipleattackprograms
using Rosetteâ€™s SMT-based symbolic evaluation engine [47].
We have evaluated Solar on the entire data set ( >25K) from
Etherscan [ 11], showing that our tool is expressive, efficient, and
effective.Solarâ€™squeryspecificationlanguageisexpressiveinthatit is rich enough to encode common vulnerabilities found in the lit-erature(suchastheReentrancyattack[
6],Timemanipulation[ 17],
andmaliciousaccesscontrol[ 42]),SecurityBestPractices[ 10],as
well as the recent BatchOverflow Bug [ 13] (CVE-2018â€“10299),
which allows the attacker to create an arbitrary amount of cryp-
tocurrency. Solar is efficient: on average it takes only 8 seconds toanalyzeasmartcontractfromEtherscan,whichisfourtimesfaster
thanteether[ 42]andtwoordersofmagnitudefasterthanCon-
tractFuzzer [ 39]. Solar is also effective in that it significantly
outperforms state-of-the-art smart contracts analyzers, namely,
teether,Mythril,andContractFuzzer,intermsoffalseposi-
tiveandfalsenegativerates.Theapproximatequeriesalsoenable
Solar to generate compact summaries and explore deeper vulnera-
bilities in exchange for a minor loss in precision.
In summary, this paper makes the following contributions:â€¢Weformalizetheproblemofexploitgenerationasaprogramsynthesisproblemandprovideaquerylanguageforexpress-ingcommonvulnerabilitiesinsmartcontractsasdeclarative
specifications (Section 4.2).
â€¢Weproposeanewsummary-basedsymbolicevaluationtech-niqueforsmartcontractsthatsignificantlyreducesthenum-
ber of paths that Solar has to execute symbolically (Sec-
tion 5).
â€¢We develop an efficient attack synthesizer based on thesummary-based symbolic evaluation, which incorporates
a novel combination of search space partitioning and paral-
lelsymbolicexecutionbasedonthesemanticsofcandidate
programs (Section 6.2).
â€¢WeperformasystematicevaluationofSolarontheentire
datasetfromEtherscan.Ourexperimentsdemonstratethe
substantialbenefitsofourtechniqueandshowthatSolar
outperformsthreestate-of-the-artsmartcontractsanalyzers
in terms of running time and precision. (Section 7).
2 BACKGROUND
We first review necessary background on smart contracts.
Smart Contract. Smart contracts are programs that are stored
andexecutedontheblockchain.Theyarecreatedthroughthetrans-
action system on the blockchain and are immutable once deployed.
Each smart contract is associated with a unique 160-bit address;a private persistent storage; a certain amount of cryptocurrency,
expressedasabalance(i.e.,EtherinEthereum)heldbythecontract;andapieceofexecutablecodethatfulfillscomplexcomputationsto
manipulatethestorageandbalance.Thecodeistypicallywritten
in a high-level Turing-complete programming language such as
Serpent[22],Vyper[24],andSolidity[ 23],andthencompiledtothe
1142Ethereum Virtual Machine (EVM) bytecode [ 21], a low-level stack-
basedlanguage.Forinstance,Figure1showstwosmartcontracts
written in the Solidity programming language [23].
Application Binary Interface. In the Ethereum ecosystem, smart
contracts communicate with each other using the Contract Ap-
plication Binary Interface (ABI), which defines the signatures of
public functions provided by the hosted contract. While ABI offers
aflexiblemechanismforcommunication,italsocreatesanattack
surface for exploits that use the ABI of a given smart contract.
Threat Model. To synthesize an adversarial contract, we assume
that the attacker can obtain the victim contractâ€™s bytecode andthe ABI specifying its public methods. To confirm an adversarial
contract is indeed an exploit, we must also be able to invoke publicmethodsbysubmittingtransactionsovertheEthereumBlockchain.
These requirements are easy to satisfy in practice.
3 OVERVIEW
Inthissection,wegiveanoverviewofourapproachwiththeaid
of a motivating example.
3.1 Smart Contract Vulnerabilities
Asecurityanalyst,Alice,canspecifyvarioustypesofvulnerabil-
ities that may appear in a smart contract. For instance, Figure 1
showsasimplifiedexampleofaReentrancyattack.The withdraw
function does two steps: 1send a given amount of Ether to the
caller,and 2updatethestoragestatetoreflectthenewbalance.At
any point, the total amount of balances of the victim and attacker
should remain the same (i.e., ğµğ‘£+ğµğ‘=ğ¶). Howeve r, since1hap-
pensbeforeupdatingthestatein 2,anattackercanre-enterthe
withdraw functionagainthroughtheanonymouscallbackfunction
triggered by 1. As a result, the execution of the attack program
canlead toaninconsistent state(i.e., ğµ/primeğ‘£+ğµ/primeğ‘>ğ¶),which enables
the attacker to extract a large amount of Ether from the victim.1
To automatically generate exploits for the Reentrancy vulnera-
bility,Alicefirstspecifiesa querythatcharacterizes thesemantics
of Reentrancy. As shown in the lower part of Figure 1, the attack
canbesummarizedusingasequenceofkeystatementsbetweenthe
victimandtheattacker,i.e.,twoormore transfer2instructions
followedbya storeoperation,whichcanbeexpressedusingthe
first-order formula3in Figure 1.
Once Alice expresses the Reentrancy vulnerability, the next
stepistoconstructanattacktoconfirmthatthevulnerabilityindeed
existsinthevictimcontract.Alicecanleverageexistingsymbolic
executiontools[ 12,42,43]togenerateexploitsforsimpleproper-
tiessuchasattack-control[ 42])inasinglecontract.Butforcomplex
vulnerabilities that require reasoning about interactions among
multiplecontracts(e.g.,attackerversusvictiminReentrancyorcallerversuscalleeinParityMultisig[
14]),existingtoolsprovide
either no support [ 42] or very limited support that leads to high
rates [43] of false positives and negatives (as shown in Section 7.1).
Yet Alice can easily initialize the boilerplate code for basic interac-
tions, like the â€œattack template" on the left hand side of Figure 1.
1Ethereumâ€™s gas mechanism ensures that this callback loop terminates.
2We use transfer to denote the callinstruction in EVM.
3SolarconvertsaqueryintoitscorrespondingFOLformulasthroughasyntax-directed
translation.
Figure 2: An example to show the BatchOverflow attack.
What she needs is an efficient way to fill in the details of the attack
program,whichinvolvesexploringthespaceofallprogramsthat
canbeobtainedbycompletingthetemplatewiththemethodsfrom
the victimâ€™s interface.
3.2Solar
Solar helps automate this process by searching for attacks thatexploit a given vulnerability in a victim contract. The tool takesas input a potential vulnerability
Vexpressed as a declarative
specification.If Vexistsinthevictimcontract,Solarautomatically
synthesizesan attackprogram thatexploits V.Anattackerinteracts
withavulnerablecontractthroughitspublicmethodsdefinedin
the ABI. Therefore, our goal is to construct an attack program that
exploits the victimâ€™s ABI and that contains at least one concrete
trace where Vholds.
To achieve this goal, Solar models the executions of a smart
contractas statetransitions overregisters,memory,andstorage.The
vulnerability VisexpressedinRacket[ 5]asabooleanpredicate
overthesestatetransitions.Thetechnicalchallengeaddressedby
Solaristoefficientlysearchforanattackprogramwhere Vholds.
Toillustratethedifficultyofthistask,considertheproblemof
synthesizing an attack program that exploits the BatchOverflow
vulnerability (CVE-2018â€“10299) [ 13] in Figure 2. The attack pro-
gram performs a complex three-step interaction with the victimcontract. First, the attacker must set the storage variable
flagto
trueto pass the check at line 11. Next, it needs to assign a large
number to vthat leads to an overflow at line 10. Finally, it specifies
the attackerâ€™s address as the beneficiary of the transaction (line
16).Synthesizingthisattackprograminvolvesdiscoveringwhich
methods to call, in what order, and with what arguments.
The naive approach to solving this problem is to generate all
possibleconcreteprograms andexplorethespaceoftheir concrete
traces.Thisapproachsuffersfromtwosourcesofexponentialex-
plosion. First, there are ğ‘‚(ğ‘›ğ‘˜)concrete programs of length ğ‘˜for
a victim contract with ğ‘›public methods. Second, the number of
concrete traces in each of these programs is exponential in the size
of the programâ€™s global control-flow graph obtained by inlining all
method calls.
Toaddressthetraceexplosionchallenge,Solaremploysanovel
summary-basedsymbolicevaluationtechniquepresentedinSec-tion 5. Intuitively, this technique enables Solar to preserve only
1143/angbracketleftvar/angbracketright::=def-symidğœwhereğœâˆˆ{boolean,number}
/angbracketleftpc/angbracketright::=/angbracketleftconst/angbracketright|/angbracketleftvar/angbracketright
/angbracketleftexpr/angbracketright::=/angbracketleftconst/angbracketright|/angbracketleftvar/angbracketright|/angbracketleftexpr/angbracketrightâŠ•/angbracketleftexpr/angbracketright
(âŠ•âˆˆ{ +,âˆ’,Ã—,/,âˆ¨,âˆ§,...})
/angbracketleftstmt/angbracketright::=/angbracketleftvar/angbracketright:=/angbracketleftexpr/angbracketright
|/angbracketleftvar/angbracketright:=mload/angbracketleftvar/angbracketright|mstore/angbracketleftvar/angbracketright/angbracketleftvar/angbracketright
|/angbracketleftvar/angbracketright:=sload/angbracketleftvar/angbracketright|sstore/angbracketleftvar/angbracketright/angbracketleftvar/angbracketright
|/angbracketleftvar/angbracketright:={balance, gas,address}
/angbracketleftstmts/angbracketright::=/angbracketleftstmt/angbracketright|/angbracketleftstmt/angbracketright;/angbracketleftstmts/angbracketright|sha3/angbracketleftvar/angbracketright/angbracketleftvar/angbracketright
|jumpI/angbracketleftpc/angbracketright/angbracketleftexpr/angbracketright|jump/angbracketleftpc/angbracketright|no-op
|transfer /angbracketleftvar/angbracketright/angbracketleftvar/angbracketright/angbracketleft.../angbracketright|selfdestruct /angbracketleftvar/angbracketright
/angbracketleftparam/angbracketright::=/angbracketleftvar/angbracketright
/angbracketleftparams/angbracketright::=/angbracketleftparam/angbracketright|/angbracketleftparam/angbracketright,/angbracketleftparams/angbracketright
/angbracketleftprog/angbracketright::=ğœ†/angbracketleftparams/angbracketright./angbracketleftstmts/angbracketright
Figure 3: Intermediate language for smart contract
thosestatetransitionsthatarepersistentacrossdifferenttransac-
tions and are sufficient to answer the vulnerability query.
Toaddresstheprogramexplosionchallenge,Section6introduces
twoadditionaloptimizations.First,insteadofexploringthespaceof
concreteprograms,weleverageRosette[ 47]topartitionthisspace
into a small set of symbolic programs (Section 6.1). Second, instead
of executing each symbolic program sequentially, we partition the
searchspacebycasesplittingontherangeofsymbolicvariables,
which enables Solar to simultaneously explore multiple symbolic
candidates (Section 6.2).
4 PROBLEM FORMULATION
This section formalizes the semantics of smart contracts, shows
howtoexpresssmartcontractvulnerabilitiesinSolar,anddefinestheproblemofsynthesizinganattackcontractthatexploitsagiven
vulnerability.
4.1 Smart Contract Language
Figure3showsthecorefeaturesofourintermediatelanguagefor
smartcontracts. Thislanguage isa supersetofthe EVMlanguage.
ItincludesstandardEVMbytecodeinstructionssuchasassignment
(x: =e), memory operations ( mstore,mload ), storage operations
(sstore,sload ), hash operation ( sha3), sequential composition
(ğ‘ 1;ğ‘ 2), conditional (jumpi) and unconditional jump (jump). It also
includestheEVMinstructionsspecifictosmartcontracts: transfer
denotes all functions that send tokens between different addresses,
balance accesses the current account balance, and selfdestruct
terminatesacontractandtransfersitsbalancetoagivenaddress.
Finally, our language extends EVM with features that facilitate
symbolicevaluation,including symbolicvariables (introducedby
def-sym) andsymbolic expressions (obtained by operating on sym-
bolic variables) whose concrete values will be determined by an
off-the-shelf SMT solver [44].
WedefinetheoperationalsemanticsofeachstatementinFigure3
basedonthestandarddefinedbytheEVMyellowpaper[ 7].The
semantics is lifted to work on symbolic values in the standard
way [47]. The meaning of a statement is given by a state transition
rulethatspecifiesthestatementâ€™seffectonthe programstate.W e
define states and transitions as follows.
Definition4.1. (ProgramState) TheProgramState Î“consistsof
astackğ¸,memory ğ‘€,persistentstorage ğ‘†,globalproperties(e.g.,(a) Solidity program
1 require(_amount > 0);
2 vesting.amount = _amount.sub(1);
3 transfer(msg. sender ,_to,vesting.amount);
4 uint256 v1 = _amount - 15;
5 uint256 wei = v1;
6 uint t1 = vesti ng.startTime;
7 emit VestTransfer(msg.sender, _to, wei, t1, _);
(b) Symbolic evaluation
1 assert(_amount > 0);
2 r1:=_amount - 1;
3 sstore (vesting.amount , _amount - 1);
4 transfer (msg.sender , _to, _amount - 1);
5 r2:=amount - 15;
6 r3:=amount - 15;
7 r4:= sload (vesting.startTime);
8 no-op ;
(c) Summary extraction
1ğ‘ ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘’(vesting.amount,Î“ğ‘†[_amount]âˆ’1)@(Î“ğ‘†[_amount]>0);
2ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ğ‘“ğ‘’ğ‘Ÿ (Î“ğ‘†[msg.sender],Î“ğ‘†[_to],Î“ğ‘†[_amount]âˆ’1)@(Î“ğ‘†[_amount]>0)
;
(d) Summary interpretation
1 if(Î“[_amount]>0)sstore(vesting.amount,Î“[_amount]âˆ’1);
2 if(Î“[_amount]>0)transfer (Î“[msg.sender],Î“[_to],Î“[_amount]âˆ’1);
Figure 4: From Standard to Summary-Based Symbolic Evaluation
balance, address, timestamp) of a smart contract, and the program
counter pc.W euseğ‘’ğ‘–,ğ‘šğ‘–,andğœ‡ğ‘–todenotevariablesfromthestack,
memory, and storage, respectively.
AprogramstatealsoincludesamodelofthegassysteminEVM,
but we omit this part of the semantics to simplify the presentation.
If a state maps a variable to a symbolic expression, we call it a
symbolic state.
Definition4.2. (Statetransitionoverstatement ğ‘ )AStateTran-
sitionToverastatement ğ‘ isdenotedbyajudgmentoftheform
Î“/turnstileleftğ‘ :Î“/prime,ğ‘£. The meaning of this judgment is the following: assum-
ingwesuccessfullyexecute ğ‘ underprogramstate Î“,itwillresult
in valueğ‘£and the new state is Î“/prime.
Example4.3. Figure4ashowsasmartcontractwritteninSolidity.
To analyze this contract, Solar first translates it to the program in
Figure 4b, using the intermediate language in Figure 3. The result-
ingprogramisthenevaluatedsymbolicallyinanenvironment Î“
that binds _amount to a fresh symbolic number. For instance, after
executing line 2 in Figure 4b, register r1holds a symbolic value
represented by Î“[_amount]âˆ’ 1. Since Solar does not model the
event system in Solidity, we turn the corresponding instructions
(e.g., line 7 in Figure 4b) into no-ops.
Definition 4.4. (Abstract execution trace) An abstract execu-
tion trace Rcontains a list of events (i.e., statements) that are of
interest. Each event has an event type representing the type of
statement, and a list of attributes.
11444.2 Smart Contract Vulnerabilities
Wenowdescribehowtoexpresssmartcontractvulnerabilitiesin
Solarandwhatitmeansforavulnerabilitytoappearinaprogram.
Figure5showsourquerylanguageoverprogramtraces.Aquery
consists of three parts. The usesblock declares typed variables,
whicharematchedagainstvariablesorstatementsappearinginthe
program. The matches block specifies a sequence of statements
that are matched against the program trace. The whereclause
further refines the search criteria by imposing constraints over the
matched statements.
Queryvariables. Queryvariablesinthe usesblockcorrespond
to variables or statements in the program trace. Common variables
include statements, storage variables, arguments, etc.
Statements. Statements in the query language correspond to
eventsintheexecutiontracediscussedinSection4.Inparticular,
an event is of type record whose fields are properties of that event.
Table 1 lists the fields of some representative statements appearing
in the query. Furthermore, a seqStmt such as a;bspecifies that
the event ahappens before b. Finally, the exclusion operator â€œ âˆ¼â€i s
used to prohibit an event from appearing in the trace.
Conditionalclauses. Thecriteriaofaquerycanbefurtherrefined
using the conditional clauses in thewhereblock. In particular, a
conditionalclauseisabooleanexpressionwhosesub-expressions
are constants, query variables, fields of query variables, or custom
predicate like interfere which we introduce later.
/angbracketleftquery/angbracketright::=/angbracketleftuses declList; /angbracketright
|/angbracketleftmatches {seqStmt} /angbracketright
|/angbracketleftwhere cond /angbracketright
/angbracketleftdeclList/angbracketright::=/angbracketlefttypeName id (,id)* /angbracketright
/angbracketlefttypeName /angbracketright::=/angbracketleftid/angbracketright
/angbracketleftstmt/angbracketright::=/angbracketlefttransfer/angbracketright|/angbracketleftsstore/angbracketright|/angbracketleftjump/angbracketright|/angbracketleftbinaryExp /angbracketright|/angbracketleft~stmt/angbracketright...
/angbracketleftseqStmt/angbracketright::=/angbracketleftstmt/angbracketright|/angbracketleftstmt;stmt /angbracketright
/angbracketleftcond/angbracketright::=/angbracketleftE/angbracketrightâŠ•/angbracketleftE/angbracketright(âŠ•âˆˆ{ +,âˆ’,>,â‰ ,âˆ¨,âˆ§,...})
/angbracketleftE/angbracketright::=/angbracketleftconst/angbracketright| [[var]] |/angbracketleftvar/angbracketright
|/angbracketleftfieldAccess/angbracketright| (interfere? /angbracketleftE/angbracketright/angbracketleftE/angbracketright)
/angbracketleftvar/angbracketright::=/angbracketleftlocal/angbracketright|/angbracketleftargument /angbracketright
/angbracketleftfieldAccess /angbracketright::=/angbracketleftid.id/angbracketright
/angbracketleftid/angbracketright::=/angbracketleftA-Za-z/angbracketright*
Figure 5: Query language for Solar
Compilationofquery. Solarconvertsqueryintocorrespond-
ingFOLformulasthroughasyntax-directedtranslation.Forqueries
thatcontainquantifiers,weuseskolemizationtomakethemquantifier-
free (or reject them if they cannot be skolemized).
The rest of this section introduces a few representative vulnera-
bilities,andshowshowtheyareencodedasformulasinSolar.But
first,weintroduceanauxiliaryfunction interfere? whichwillbe
used by several vulnerabilities.
Definition4.5. (Interference) Asymbolicvariable ğ‘£interferes
withasymbolicexpression ğ‘’iftheysatisfythefollowingconstraint:
âˆƒğ‘£0,ğ‘£1.ğ‘’[ğ‘£0/ğ‘£]â‰ ğ‘’[ğ‘£1/ğ‘£]âˆ§(ğ‘£0â‰ ğ‘£1)Fields of transfer statement
sender senderâ€™s address
recipient targetâ€™s address
loc program counter of the statement
gas gas budget for the transfer
amount amount of tokens
ret return value of the statement
Fields of jump statement
condVar condition variable of jump statement
target target address
Fields of sstore statement
name name of storage variable
value new value that is used
Fields of binary statement
lhs variable that is assigned
opcode opcode of the binary statement
oprand1 the first operand
oprand2 the second operand
Table1:Fieldsofcorestatementsappearinginthequerylan-
guage
Intuitively,changing ğ‘£â€™svaluewillalsoaffect ğ‘’â€™soutput,whichis
denoted as â€œ(interfere? ğ‘£ğ‘’)". Interference precisely captures the
data-andcontrol-dependenciesbetweentwoexpressionsandturns
out to be the necessary condition of many exploits.
Section 3 describes the BatchOverflow vulnerability, which
enables an attacker to perform a multiplication that overflows and
transfers a large amount of tokens on the attackerâ€™s behalf. This
vulnerability can be formalized as follows:
Vulnerability 1. BatchOverflow
uses Transfer ğ‘¡1; BinaryExp e; Argument ğ‘1,ğ‘2;
matches {e;ğ‘¡1;}where
(ğ‘’.ğ‘œğ‘ğ‘ğ‘œğ‘‘ğ‘’ ==â€Ã—â€âˆ§[ [ğ‘’.ğ‘œğ‘ğ‘Ÿğ‘ğ‘›ğ‘‘ 1]]>[[ğ‘’.ğ‘™â„ğ‘ ]]
âˆ§(interfere ?ğ‘’.ğ‘œğ‘ğ‘Ÿğ‘ğ‘›ğ‘‘ 1ğ‘¡1.ğ‘ğ‘šğ‘œğ‘¢ğ‘›ğ‘¡ )
âˆ§(interfere ?ğ‘1ğ‘¡1.ğ‘Ÿğ‘’ğ‘ğ‘–ğ‘ğ‘–ğ‘’ğ‘›ğ‘¡ )âˆ§(interfere ?ğ‘2ğ‘¡1.ğ‘ğ‘šğ‘œğ‘¢ğ‘›ğ‘¡ ))
Thequeryspecifiesthatthevictimprogramcontainsa transfer
instructionwhosebeneficiaryandvaluecanbecontrolledbythe
attacker. Furthermore, the transaction value is also influenced by a
variable from an arithmetic operation that overflows.
AnUnchecked-send Vulnerability occurs when the programmer
fails to check the return values of critical instructions such as
delegatecall and call. If these instructions result in runtime
errors, the programmer is responsible for manually checking their
return values and restoring the program state. Failing to do so can
lead to unexpected behavior [ 18]. We formalize the absence of this
check as follows:
Vulnerability 2. Unchecked-send (Gasless-send)
uses Transfer ğ‘¡; Jump j;
matches {t ;~ j ; } where ((interfere ?ğ‘¡.ğ‘Ÿğ‘’ğ‘¡ ğ‘—.ğ‘ğ‘œğ‘›ğ‘‘ğ‘‰ğ‘ğ‘Ÿ ))
1145Here, the return value of a transfer instruction does not interfere
withtheconditionalvariablesofany conditionaljump statements.
In other words, this return value is not checked.
The Reentrancy vulnerability (introduced in Section 1) occurs
when anattackerâ€™s call is allowed to repeatedly makenew calls to
the same victim contract without updating the victimâ€™s balance. It
can be overapproximated as follows:
Vulnerability 3. Reentrancy
uses Transfer ğ‘¡1,ğ‘¡2; Store s; Argument a;
matches {ğ‘¡1; ~s;ğ‘¡2;}where (ğ‘¡1.ğ‘™ğ‘œğ‘==ğ‘¡2.ğ‘™ğ‘œğ‘âˆ§ğ‘¡2.ğ‘”ğ‘ğ‘ >2300
âˆ§(interfere ?ağ‘¡2.ğ‘Ÿğ‘’ğ‘ğ‘–ğ‘ğ‘–ğ‘’ğ‘›ğ‘¡ ))
In other words, let trace Rcontains a sequence instructions that
includemultiple transfer statementsthatsharethesameprogram
counter, if there is no storestatement between the two transfer
functions that has the minimum gas (i.e., 2300), then there may
exist a Reentrancy vulnerability.
4.3 Attack Synthesis
Givenavulnerabilityquery,weareinterestedinsynthesizinganat-
tackprogramthatcanexploitthisvulnerabilityinavictimcontract.
The basic building blocks of an attack program are called com-
ponents, and each component Ccorresponds to a public method
providedbythevictimcontract.Weuse Î¥todenotetheunionof
all publicly available methods.
Definition 4.6. (Component) AComponent Cfrom an ABI con-
figuration is a pair (ğ‘“,ğœ)where: 1) ğ‘“isCâ€™s name, and 2) ğœis the
type signature of C.
Example4.7. ConsidertheABIconfigurationinFigure2.Itsfirst
element declares a component for the problematic batchTransfer
method. This component takes inputs as an array of address and
a 256-bit integer (uint256).
Werepresentasetofcandidateattackprogramsasa symbolic
program, which is a sequence of holesto be filled with components
from Î¥.Thesynthesizerfillstheseholestoobtaina concreteprogram
that exploits a given vulnerability.
Definition4.8. (SymbolicAttackProgram) Givenasetofcom-
ponents Î¥={(ğ‘“1,ğœ1),...,(ğ‘“ğ‘,ğœğ‘)},asymbolic attack program S
forÎ¥is a sequence of statement holes of the form
choose(ğ‘“1(/vecğ‘£ğœ1),...,ğ‘“ğ‘(/vecğ‘£ğœğ‘));
whereğ‘“ğ‘–(/vecğ‘£ğœğ‘–)stands for the application of the ğ‘–-th component to
fresh symbolic values of types specified by ğœğ‘–.
Definition 4.9. (Concrete Attack Program) Aconcrete attack
programfor a symbolic program Sreplaces each hole in Swith
one of the specified function calls, and each symbolic argument to
a function call is replaced with a concrete value.
Example 4.10. Here is a symbolic program that captures the
attack candidate in Fig 2:
choose(makeFlag( ğ‘¥1), batchTransfer( ğ‘¦1,ğ‘§1));
choose(makeFlag( ğ‘¥2), batchTransfer( ğ‘¦2,ğ‘§2));
And here is a concrete attack program for this symbolic attack:
makeFlag( true);
batchTransfer([0x123,0 x345], 2256âˆ’1);1 (define (get-summary s ğœ™)
2 (match s
3 [transfer(x, y, z) ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ğ‘“ğ‘’ğ‘Ÿ (Î“ğ‘†(ğ‘¥),Î“ğ‘†[ğ‘¦],Î“ğ‘†[ğ‘§])@ğœ™]
4 [sstore(x, y) ğ‘ ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘’ (x, Î“ğ‘†[ğ‘¦])@ğœ™]
5 [_ #f]))
Figure 6: Procedure for summary generation.
Thechooseconstructisanotationalshorthandforaconditional
statement that guards the specified choices with fresh symbolicbooleans. For example,
choose(ğ‘’1,ğ‘’2)stands for the statement
ifğ‘1thenğ‘’1elseğ‘’2, whereğ‘1is afresh symbolicboolean value.
Aconcreteattackprogramthereforesubstitutesconcretevaluesfor
the implicit chooseguards and the explicit function arguments of
a symbolic attack program.
The goal of attack synthesis is to find a concrete program ğ‘ƒfor
a given symbolic program Ssuch that ğ‘ƒreaches a state satisfying
a desired vulnerability query.
Definition 4.11. (Problem Specification) The specification for
ourattack synthesis problem is a tuple ( Î“0,V,S) where:
â€¢Sis a symbolic attack program for the set of components Î¥
of a victim contract ğ‘‰.
â€¢Î“0istheinitialstateofthesymbolicattackprogram,obtained
by executing the victimâ€™s initialization code.
â€¢Vis a first-order formula over the (symbolic) program state
[[S]] Î“reachable from Î“0by the attack program S.
Definition4.12. (AttackSynthesis) Givenaspecification( Î“0,V,
S),theAttackSynthesisproblem istofinda concreteattackprogram
ğ‘ƒforSsuch that: 1) [[ğ‘ƒ]]Î“0=Î“, and 2) Î“|=V. In other words,
executing ğ‘ƒfrom the initial state Î“0results in a program state Î“
that satisfies V.
5 SUMMARY-BASED SYMBOLIC
EVALUATION
Solving the attack synthesis problem involves searching for a con-
crete program ğ‘ƒin the space of candidate attacks defined by a
symbolic program S. Solar delegates this search to an off-the-
shelfSMTsolver,byusingsymbolicevaluationtoreducetheattack
synthesis problem to a satisfiability query. Given a specification
(Î“0,V,S), Solar evaluates Son the state Î“0to obtain the state
[[S]] Î“0,andthenusesthesolvertocheckthesatisfiabilityofthefor-
mulaâˆƒ/vecğ‘£.V([[S]] Î“0),where/vecğ‘£denotesthesymbolicvariablesin S.A
modelofthisformula,ifitexists,bindseveryvariablein /vecğ‘£toacon-
cretevalue,andsorepresentsaconcreteattackprogram ğ‘ƒforSthat
triggers the vulnerability V. But computing [[S]] Î“0is expensive
asitreliesonsymbolicevaluation[ 47].Inparticular,evaluatinga
choosestatement in Sinvolves symbolically evaluating each func-
tion call in that statement. So, for a symbolic program of length ğ¾,
everypublicfunctioninthevictimcontractmustbesymbolically
executedğ¾timesondifferentsymbolicarguments.Aswewillseein
section7,thisdirectapproachtoevaluating Sdoesnotscaletoreal
contracts that contain a large number of complex public functions.
Tomitigatethisissue,weuseasummary-basedsymbolicevaluation
that performs symbolic execution of each public method only once.
1146Ourapproachisbasedonthefollowinginsight.Anattackpro-
gramperformsasequenceoftransactionsâ€”i.e.,methodinvocationsâ€”
thatmanipulatethevictimâ€™spersistentstorageandglobalproperties.
Thetransactionsthatcompriseanattackexchangedataandinflu-
ence each otherâ€™s control flow exclusively through these two parts
of the program state. So, if we can faithfully summarize the effects
of a public method on the persistent storage and global properties,
evaluating this summary on the symbolic arguments passed to the
method is equivalent to symbolically executing the method itself.
Definition5.1. Asummary Minoursystemisapair ğ‘ @ğœ™where
ğ‘ represents a statement that has a side effect on the persistent
state (i.e., storage and global properties) of a smart contract, and ğœ™
denotes the path condition under which ğ‘ is executed.
We generate such faithful method summaries in two steps. First,
we evaluate the method on a program state Î“ğ‘†that maps every
state variable (i.e., persistent storage location, global property, etc.)
toafreshsymbolicvariableoftherighttype.Thisstepproducesa path condition and symbolic inputs for each instruction thatcapture every possible way to reach and execute the instruction
withinthegivenmethod.Next,weusetheprocedureinFigure6
togeneratethemethodsummary.4Givenastorage-storeinstruc-
tionsstore(x,y) and its path condition, we generate a â€œsummary
sstore"statement(i.e., ğ‘ ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘’)thattakesasinputthenameofthe
storage variable (i.e., ğ‘¥) and the symbolic expression Î“ğ‘†[ğ‘¦]held in
the register ğ‘¦. Similarly, given a call(gas,addr,value) instruc-
tion and path condition, we emit its â€œsummary call" statement (i.e.,
ğ‘ğ‘ğ‘™ğ‘™)thattakesasinputthesymbolicexpressionsoftheinstructionâ€™s
gasconsumption,recipientaddress,andamountofcryptocurrency,
respectively. All other instructions are omitted from the summary
sincetheyhavenoeffectonthepersistentstate.Byconstruction,
oursummarythereforepreciselycapturesallofthemethodâ€™seffects
on the persistent state, and the summaries are polynomially-sized
as guaranteed by Rosetteâ€™s symbolic evaluator [47].
Example5.2. Recallthatweintroducethefollowingcodesnippet
in Figure 4b:
1 assert(_amount > 0);
2r 1 :=_amount - 1;
3sstore (vesting.amount , _amount - 1);
4transfer (msg.sender , _to, _amount - 1);
5r 2 :=amount - 15;
6r 3 :=amount - 15;
7r 4 := sload (vesting.startTime);
8no-op ;
Then using the rule in Figure 6, Solar generates the following
summary:
ğ‘ ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘’(vesting.amount,Î“ğ‘†[_amount]âˆ’1)@(Î“ğ‘†[_amount]>0);
ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ğ‘“ğ‘’ğ‘Ÿ (Î“ğ‘†[msg.sender],Î“ğ‘†[_to],Î“ğ‘†[_amount]âˆ’1)@(Î“ğ‘†[_amount]>0);
In particular, our tool summarizes the side effects of the transfer
andsstoreinstructionsatlines2and3inFigure4b,respectively.
The remaining instructions (e.g., statements from line 5 to 8) are
omitted from the summary because they have no persistent side
effects.
Once Solar generates the summary for each procedure, we still
need to adjust the symbolic evaluation engine to take advantage
4We omit the details of other side-effecting instructions for simplicity.1 (define (interpret -summary ğ‘ @ğœ™Î“)
2 (define ğ‘ Î“@ğœ™Î“(substitute ğ‘ @ğœ™Î“))
3 (match ğ‘ Î“
4 [ğ‘¡ğ‘Ÿğ‘ğ‘›ğ‘ ğ‘“ğ‘’ğ‘Ÿ (ğ‘¥Î“,ğ‘¦Î“,ğ‘§Î“)(whenğœ™Î“transfer( ğ‘¥Î“,ğ‘¦Î“,ğ‘§Î“))]
5 [ğ‘ ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘’(ğ‘¥,ğ‘¦ Î“)(whenğœ™Î“sstore(x, ğ‘¦Î“))]
6 [_ no-op]))
Figure 7: Procedure for summary interpretation
1 (define (solar VÎ¥ğ¾)
2 (define program ( for/list ([i K]) ( apply choose* Î¥)))
3 (define i-pstate (get-initial-state Î¥))
4 (define o-pstate (interpret program i-state))
5 (define binding (solve (assert ( Vo-pstate ))))
6 (evaluate program binding))
Figure 8: Solarimplementation in Rosette.
ofthesummaries.Givenamethodsummaryandaprogramstate
Î“, we use the procedure in Figure 7 to reproduce the effects of
executing the method symbolically on Î“as follows. Recall that we
generatethesummarybyexecutingthemethodonafullysymbolic
state Î“ğ‘†={ğ‘¥1â†¦â†’ğ‘£1,...,ğ‘¥ğ‘›â†¦â†’ğ‘£ğ‘›}, so every path condition and
symbolic expression in the summary is given in terms of the sym-
bolicvariables ğ‘£1,...,ğ‘£ğ‘›.Oursummaryinterpretationprocedure
works by substituting each ğ‘£ğ‘–in an instructionâ€™s path condition
and inputs with its corresponding value in Î“, i.e., Î“[ğ‘¥ğ‘–]. The result-
ing instruction summary ğ‘ Î“@ğœ™Î“is therefore expressed in terms
ofÎ“,soapplyingitssideeffects ğ‘ Î“underthepathcondition ğœ™Î“is
equivalent to executing the instruction ğ‘ in the original method on
the state Î“. Since we interpret every instruction in the summary in
thisway,thecombinedeffectonthepersistentstateisequivalent
to executing the original method symbolically on Î“.
Example 5.3. Figure 4d shows an example for interpreting the
summaryinFigure4cbyapplyingtheprocedureinFigure7.Specif-
ically, given an environment Î“and the transfer summary at line
2 in Figure 4c, we first generate an ifstatement guarded by the
path condition ğœ™inÎ“, then in the body of the ifstatement, we
symbolically evaluate the transfer statement in the environment
Î“.
6 IMPLEMENTATION
This section discusses the design and implementation of Solar, as
well as two key optimizations that enable our tool to efficiently
solve the synthesis attack problem.
6.1 Symbolic Computation Using Rosette
SolarleveragesRosette[ 47]tosymbolicallysearchforattackpro-
grams. Rosette is a programming language that provides facilities
forsymbolicevaluation.Rosetteprogramsuseassertionsandsym-
bolicvaluestoformulatequeriesaboutprogrambehavior,which
are then solved with off-the-shelf SMT solvers. For example, the
(solve expr) querysearchesforabindingofsymbolicvariables
to concrete values that satisfies the assertions encountered during
the symbolic evaluation of the program expression expr. Solar
uses the solvequery to search for a concrete attack program.
Figure8showstheimplementationofSolarinRosette.Thetool
takesasinputavulnerabilityspecification V,thecomponents Î¥ofa
1147victimprogram,andabound ğ¾onthelengthoftheattackprogram.
Given these inputs, line 2 uses Î¥to construct a symbolic attack
programoflength ğ¾.Next,lines3runsthevictimâ€™sinitialization
codetoobtaintheinitialprogramstate, i-pstate ,fortheattack.
Then, line 4 evaluates the symbolic attack programon the initial
state to obtain a symbolic output state, o-pstate . Finally, lines 5-6
usethe solvequerytosearchforaconcreteattackprogramthat
satisfies the vulnerability assertion.
The core of our tool is the interpreter for our smart contract
language (Figure 3), which implements the semantics from the
EVM yellow paper [ 7]. We use this interpreter to compute the
symbolic summaries of the victimâ€™s public methods (Section 5)and to evaluate symbolic attack programs. The interpreter itself
does not implement symbolic execution; instead, it uses Rosetteâ€™s
symbolicevaluationenginetoexecuteprogramsinourlanguage
on symbolic values.
Another key component of Solar is the translator that converts
EVMbytecodeintoourlanguage(Figure3).Thetranslatorlever-
agestheVandalDecompiler[ 34]tosoundlyconvertthestack-based
EVM bytecode into itscorresponding three-addressformat inour
language. The jump targets are resolved through abstract interpre-
tation [32]. We use the translator to convert victim contracts to
the Solar language for attack synthesis. Both the translator and
theinterpretersupportalltheinstructionsdefinedintheEthereum
specification [21].
6.2 Parallel Synthesis using Hoisting
Solarusessummary-basedsymbolicevaluationtoefficientlyre-
duce attack synthesis problems to satisfiability queries. But the
resulting queries can still be too difficult to solve in practice, espe-
ciallywhenthevictimcontracthasmanypublicmethods.Tofurther
improve performance, Solar exploits the structure of symbolic at-
tackprograms(Definition4.8)todecomposethesingle solvequery
in Figure 8 into multiple smaller queries that can be solved quickly
and in parallel, without missing any concrete attacks.
The basic idea is as follows. Given a set of ğ‘components and
a boundğ¾on the length of the attack, line 2 creates a symbolic
attack program of the following form:
choose 1(ğ‘“1(/vecğ‘£1ğœ1),...,ğ‘“ ğ‘(/vecğ‘£1ğœğ‘));
...
choose ğ¾(ğ‘“1(/vecğ‘£ğ¾ğœ1),...,ğ‘“ ğ‘(/vecğ‘£ğ¾ğœğ‘));
Thissymbolicattackencodesasetofconcreteattacksthatcanalso
beexpressedusing ğ‘ğ¾symbolicprogramsthatfixthechoiceofthe
methodtocallateachline,butleavetheargumentssymbolic.So,
wecanenumeratethese ğ‘ğ¾programsandsolvethevulnerability
queryforeach ofthem,insteadof solvingthesinglequery atline
5. This approach essentially hoiststhe symbolic boolean guards
outofthe choosestatementsintheoriginalquery,andSolarex-
ploresallpossiblevaluesfortheseguardsexplicitly,ratherthanvia
SMT solving.5As we showin Section 7, hoistingthe guards leads
to significantly faster synthesis, both because it enables parallel
solving of the smaller queries, and because the smaller queries can
be solved quickly.
5For practical efficiency, our implementation hoists the guards to generate ğ‘ğ¾/ğ‘
symbolic programs, where ğ‘is the number of available cores.6.3 Practical EVM fragment
In this section, we briefly illustrate how Solar handles other chal-
lenging features of EVM.
Loops.Similarlytootheranalyzersbasedonsymbolicexecution,
Solar unrolls all potentially unbounded loops ğ¾times. We use
ğ¾=2 as the default bound for unrolling.
SHA and Storage access. In the EVM bytecode, the address of an
array or map element is determined by the following function:
ğ‘[ğ‘–]:=SHA-256(id(a)) +ğ‘›Ã—ğ‘–
Here,SHA-256(id(a)) stands for the SHA-256 hash of the arrayâ€™s
identifier, ğ‘›isthesizeoftheelementsstoredinthearray,and ğ‘–isthe
arrayindex.Reasoningaboutthisfunctiondirectlyisintractable
for solvers. Solar circumvents this problem by leveraging uninter-
preted functions to soundly model both the SHA-256 hash and the
address computation function. That is, two addresses are the same
if they share the same array identifier, index, and element size.
Gas consumption. Solarâ€™s program state tacks gas usage by
accumulatingthecostofinstructionsduringsymbolicevaluation.Ifatransactionrunsoutofgasinthemiddleoftheevaluation,Solar
terminates it with an â€œout of gasâ€ assertion failure.
7 EVALUATION
We evaluated Solar by conducting a set of experiments that are
designed to answer the following questions:
â€¢RQ1:Effectiveness :HowdoesSolarcompareagainststate-
of-the-art analyzers for smart contracts?
â€¢RQ2:Efficiency :Howmuchdoessummary-basedsymbolic
evaluation improve the performance of Solar?
To answer these questions, we perform a systematic evaluation
by running Solar on the entire set of smart contracts from Ether-
scan[11].UsingasnapshotfromFeb132019,weobtainedatotalof
25,983smartcontracts(duplicatecontractswereremoved)withpub-liclyavailablesourcecode.Solarstartsfromattackprogramsofsizeoneandgraduallyincreasesthesizeuntilfindingtheexploitorrun-ningoutoftime.Allexperimentsinthissectionareconductedona
t3.2xlarge machineonAmazonEC2withanIntelXeonPlatinum
8000CPUand32Gofmemory,runningtheUbuntu18.04operating
system and using a timeout of 10 minutes for each smart contract.
7.1 Comparison with Existing Tools
To show the advantages of our proposed approach, we compare
Solaragainstthreestate-of-the-artanalyzersforexploitsgener-ation: Mythril and teether, based on symbolic execution, and
ContractFuzzer, based on dynamic random testing.
Comparisonwith Mythril. WefirstcomparewithMythril[ 12]6
bygeneratingexploitsforthereentrancyvulnerability.Mythril
takesasinputasmartcontractandcheckswhethertherearecon-
crete traces that match the toolâ€™s predefined security properties. If
so,thetoolreturnsacounterexampleastheexploit.Weevaluate
6Since bothSolarandMythrilaregeneral-purpose analyzersfor commonvulnera-
bilities in smart contracts, for fair comparison, we only enable the relevant queries in
the evaluation.
1148FN FP010203040Percentage %Solar Mythril
Figure 9: Comparing SolaragainstMythril
Mythril and Solar on the Etherscan data set, and both systems
use a timeout of 10 minutes.
Summary of results. For 156 contracts flagged as Reentrancy
vulnerablitybyatleastonetool,wemanuallydeterminetheground
truthandsummarizetheresultsinFigure9.Thefalsenegative(FN)
andfalse positive(FP)ratesof Solarare7% and3%,whilethe FN
and FP rates of Mythril are 26% and 12%.
Performance. Mythriltakesanaverageof23secondstoana-
lyze a contract, while Solar takes an average of 8 seconds for this
data set.
Discussion. ThehighfalsenegativerateinMythriliscausedby
lowcoverageonthecorrespondingbenchmarks.Inthepresence
of large and complex methods, Mythril fails to generate tracesthat trigger the vulnerability. Moreover, Mythril does not sup-
port cross-function re-entrancyâ€”i.e., re-entrancy attacks that span
multiple functions of the victim contract.
We also investigated the cause of false positives reported by
Solar. It turns out that the false positives are caused by the im-
precisionofourqueries.Inparticular,weuseaspecificpatternof
traces to overapproximate the behavior of the Reentrancy attack.
While effective and efficient in practice, our query may generate
spuriousexploitsthatareinfeasible.Tomitigatethislimitation,one
compelling approach for developing secure smart contracts is toask the developers to provide invariants that the tool can use to
rule out infeasible attacks.
Comparison with teether.WenextcompareSolaragainst
teether [ 42], the most recent tool using dynamic symbolic execu-
tionforgeneratingexploitsthatwouldenabletheattackertocontrolthemoneytransactionsofavictimcontract.Inparticular, teether
looks for so-called critical instructions (i.e., call,selfdestruct ,
etc.) thatinclude recipientsâ€™addresses, whichcan bemanipulated
by the attacker to withdraw tokens from a vulnerable contract.
Summary of results. In total, there are 198 contracts that are
markedas attack-control vulnerabilitybyatleastonetool.While
Solar covers allexploitsgenerated by teether, Solar also finds
21extraexploits that cannot be generated by teether.
Performance. teethertakesanaverageof31secondstoana-
lyze a contract in the Etherscan data set, while Solar takes an
average of 8 seconds per contract.VulnerabilitySolar ContractFuzzer
No.FPFNNo.FPFN
Timestamp 16011337
Gasless Send 17001436
Bad Random 900515
Table 2: Comparing SolaragainstContractFuzzer
Discussion. The missing exploits in teether are caused by low
coverageonthecorrespondingbenchmarks.Forthe21benchmarks
withexploitsthatcannotbegeneratedbyteether,14involveat-
tack programs with four method calls, and each of the remaining 7
benchmarks contains over 3000 lines of source code with complex
controlflow.Asaresult,teetherfailstoexploresufficientlymany
concrete traces to find the exploits, even if we increase the timeout
from 10 minutes to 1 hour.
Comparisonwith ContractFuzzer .WefurthercomparedSo-
laragainstContractFuzzer[ 39],arecentsmartcontractanalyzer
based on dynamic fuzzing. ContractFuzzer takes as input the
ABIinterfacesofsmartcontractsand randomly generatesinputs
invoking the public methods provided by the ABI. To verify the
correctnessoftheexploits,ContractFuzzerimplementsoracles
for different vulnerabilities by instrumenting the Ethereum Virtual
Machine (EVM) with extra assertions.
We use the docker image [ 8] provided by the author of Con-
tractFuzzer.Theoriginalpaperdoesnotdiscusstheperformance
of the tool, but from our experience, ContractFuzzer is slow,
takingmorethan10minstofuzzasmartcontract.Sinceitwould
be time-consuming to run ContractFuzzer on the Etherscandata set, we evaluate both tools on the 33 benchmarks from the
ContractFuzzerartifact[ 9]plusanother67randomsamplesfrom
Etherscan for which we know the ground truth.
Summary of results. The results of our evaluation are summa-
rized in Table 2. For the timestamp dependency, ContractFuzzer
flags 13 benchmarks as vulnerable. However, 3 of them are falsealarms, and ContractFuzzer fails to detect 7 vulnerable bench-
marks.Ontheotherhand, Solardetectsmostofthebenchmarks
withonlyonefalsenegative,whichiscausedbyatimeoutofthe
Vandal decompiler [34].
Similarly, for the Gasless-send vulnerability, 14 benchmarks are
flagged by ContractFuzzer. However, 3 of them are false posi-
tives,and6vulnerablebenchmarkscannotbedetectedwithin10
minutes.Incontrast,Solarsuccessfullygeneratesexploitsforall
the vulnerable benchmarks.
Performance. On average, ContractFuzzer takes 10 mins to
analyze a smart contract. Solar takes an average of 11 seconds on
this data set.
Discussion. The cause of false negatives in ContractFuzzer is
easy to understand as it is based on random, rather than exhaus-
tive, exploration of an extremely large search space. So if there are
relativelyfewinputsinthisspacethatleadtoanattack,Contract-Fuzzerisunlikelytofindoneinreasonabletime.ThefalsepositivesinContractFuzzerarecausedbythelimitedexpressivenessofits
assertion language.For instance,the Time Dependencyis defined
1149ğ‘†â€ -meanğ‘†/diamondmath-mean# of Benchmarks Timeout
ğ‘†â€ âˆ§ğ‘†/diamondmathğ‘†â€ âˆ’ğ‘†/diamondmathğ‘†/diamondmathâˆ’ğ‘†â€ 
8s 35s 1846 548 17454
Table 3: Comparison between summary-based ( ğ‘†â€ ) and non-
summary( ğ‘†/diamondmath).ğ‘†â€ âˆ§ğ‘†/diamondmath,ğ‘†â€ âˆ’ğ‘†/diamondmath,andğ‘†/diamondmathâˆ’ğ‘†â€ representnumber
ofbenchmarkstimeoutonboth, ğ‘†â€ only,and ğ‘†/diamondmathonly,respec-
tively.
as the following assertion in ContractFuzzer:
TimestampOp âˆ§(SendCall âˆ¨EtherTransfer)
The assertion raises a Time Dependency vulnerability if the smart
contractcontainsthe timestamp andcallinstructions.Itiseasy
toraisefalsealarmswiththisassertionifthe callinstructiondoes
not depend on timestamp.
Result forRQ1: Solaroutperformsthreestate-of-the-art
analyzers in terms of running time, false positives, and false
negatives.
7.2 Impact of Summary-based Symbolic
Evaluation
To understand the impact of our summary-based symbolic evalua-
tiondescribedinSection5,weusetheReentrancyvulnerabilityas
the client and run Solar on the Etherscan data set with ( ğ‘†â€ ) and
without (ğ‘†/diamondmath) computing the summary. To speedup the evaluation,
for both settings, we enable the parallel synthesis optimizations
discussed in Section 6.
Figure 10 shows the results of running Solar with different set-
tingsandatimelimitof10minutes.Eachdotinthefigurerepresents
the pairwise running time of a specific benchmark under different
settings; a dot near thediagonal indicates that the performance of
two settings is similar. Our summary-based symbolic evaluation
significantlyoutperformsthebaseline(i.e.,non-summary)inthe
vast majority of benchmarks. As shown in Table 3, if we exclude
thebenchmarksthattimeoutin10minutes,themeantimeofour
summary-basedsymbolicevaluationisonly8seconds,whileittakes
35 seconds without computing the summary. Furthermore, 1846
benchmarkstimeoutforbothsettings,andonly548benchmarks
timeouton ğ‘†â€ butnoton ğ‘†/diamondmath.However,withoutcomputingthesum-
mary, 17454 (i.e., 69.8%) benchmarks time out. The result confirms
thatthesummary-basedtechniqueiskeytotheefficiencyofSolar.
Result for RQ2: Our summary-based technique is key to
the efficiency of Solar.
8 RELATED WORK
Smartcontractsecurityhasbeenextensivelystudiedinrecentyears.
This section briefly discusses prior closely related work.
Smart Contract Analysis. Many popular security analyzers for
smart contracts are based on symbolic execution [ 41]. Well-known
tools include Oyente [ 43], Mythril [ 12] and Manticore [ 3]. Their
key idea is to find an execution path that satisfies a given property
or assertion. While Solar also uses symbolic evaluation to search
Figure 10: Comparison of run times (in seconds) between
non-summary (x-axis) and summary-based (y-axis) (log-scale).
for attack programs, our system differs from these tools in two
ways.First,thepriortoolsadoptsymbolicexecutionfor bugfinding.
Ourtoolcanbeusednotonlyforbugfindingbutalsofor exploit
generation. Second, while symbolic execution is a powerful andprecise technique for finding security vulnerabilities, it does not
guaranteetoexploreallpossiblepaths,whichleadstofalsenega-
tiveratesasshowninSection7.1.Incontrast,Solaranalyzesall
(bounded)pathsthroughacontractusingsummary-basedsymbolic
evaluation,whichsignificantlyreducesthenumberofpathsthat
theunderlyingRosetteenginehastoexecutesymbolicallywhile
maintaining the same precision.
Toaddressthescalabilityandpathexplosionproblemsinsym-
bolic execution, researchers developed sound and scalable static
analyzers [ 34,36,40,48]. Both Securify [ 48] and Madmax [ 34]a r e
basedonabstractinterpretation[ 32],whichsoundlyoverapprox-
imates and merges execution paths to avoid path explosion. The
ZEUS [40] systemtakes thesource codeof asmart contractand a
policyasinputs,andthencompilesthemintoLLVMIRsthatwill
becheckedbyanoff-the-shelfverifier[ 46].TheECF[ 36]system
is designed to detect the DAO vulnerability. Similar to our tool,
Securifyalsoprovidesaquerylanguagetospecifythepatternsof
commonvulnerabilities.Unlikeourtool,noneofthesesystemscan
generate exploits. We could not directly compare Solar with Zeus
asthetoolandbenchmarksarenotpubliclyavailable.However,we
note that our system is complementary to existing static analyzers
such as Securify: in particular, we can use Securify to filter outsafe smart contracts and leverage Solar to generate exploits for
vulnerable ones.
Somesystems[ 35,38,45]forreasoningaboutsmartcontracts
relyonformalverification.Thesesystemsprovesecurityproperties
ofsmartcontractsusingexistinginteractivetheoremprovers[ 1].
Theytypicallyofferstrongguaranteesthatarecrucialtosmartcon-
tracts. However, unlike our system, all of them require significant
1150manual effort to encode the security properties and the semantics
of smart contracts.
Automatic Exploitation. Our work is also closely related to au-
tomatic exploitation [ 28,31,39,42]. While prior systems rely on
constraint solvers to generate counterexamples as potential ex-ploits, we note that there are additional challenges in automatic
exploitationfor smartcontracts.First, theexploitsin classicalvul-
nerabilities (e.g., buffer overflows, SQL injections) are typically
programinputsofaspecificdatatype(e.g.,integer,string)whereastheexploitsinoursettingareadversarialsmartcontractsthatfaith-
fully model the execution environment (storage, gas, etc.) of the
EVM. Second,Keccak-256 hashis ubiquitousin smartcontract for
accessingaddressesinmemoryorstorage.AsshowninSection7.1,basicsymbolicexecutionwillfailtoresolvetheKeccak-256hash,re-sultinginpoorcoverage.Toaddressthisproblem,theteether[
42]
system proposed a novel algorithm to infer the memory addresses
encoded as Keccak-256 hash. Unlike teether, our system directly
synthesizes function calls that manipulate the memory and stor-
age thus avoids expensive computation to resolve the hash values.
Our evaluation in Section 7.1 shows that Solar outperforms the
teether tool in terms of both running time and false negatives.
SimilartoSolar,ContractFuzzer[ 39]alsogeneratesexploitsfor
a limited class of vulnerabilities based on the ABI specificationsofsmartcontracts.However,asshowninSection7.1,sinceCon-
tractFuzzerisbasedonrandominputgeneration,itisanorderof
magnitudeslowerthanSolar,resultinginmanymissedexploits
compared to Solar. Its assertion language is also less expressive
than ours, leading to false positives that Solar avoids.
Symbolic Evaluation. Solar builds on the Rosette [ 47] sym-
bolicevaluationenginewithanewsummary-basedtechniquefor
scaling symbolic evaluation to large programs in the domain ofsmart contracts. As shown in Section 7.2, this technique is criti-cal for performance. The idea of computing summaries to speed
up symbolic evaluation has also been explored in the context ofsymbolic execution (see [
29] for a survey), leading to three main
approaches [ 26,30,33]. Two of these approaches [ 26,33] com-
putesummariespath-by-path,soafullsummarythatencodesall
(bounded) paths through a program would be, in the worst case,
exponential in program size. Prior tools therefore avoid comput-ingfullsummaries,insteadsummarizingasubsetofallpathsforthe purpose of test generation. Solar, in contrast, summarizesall (bounded) paths through a procedure, and produces compact
(polynomially-sized) summaries by employing a symbolic evalu-
ator [
47] that combines symbolic execution and bounded model
checking. Another summarization approach [ 30] uses a caching
schemethatletstheunderlyingsymbolicexecutionenginetermi-
nate the exploration of a path as soon as it reaches a previouslyseen state. The scheme does not compute explicit summaries of
code; instead, it only stores enough information to soundly decide
whenthesymbolicexecutionofapathreachesapreviouslyseen
state. In contrast, our approach computes an explicit and precise
summary of a procedureâ€™s semantics.
ProgramSynthesis. Solarusessyntax-guidedsynthesis[ 25]to
search for attack programs. Synthesizers of this kind (see [ 37] for a
survey) rely on either enumerative search (which can be stochasticorexhaustive)orsymbolicreasoningoracombinationofthetwo.
Solar combines exhaustive enumeration with symbolic synthesis
(Section6.1),andextendsthiswithaparallelsymbolicevaluation
technique(Section6.2)forfastenumeration.Bothoptimizationsare
specializedtothedomainofsmartcontracts,andtheyarecritical
for performance: disabling them renders the system unusable.
9 CONCLUSION
ThispaperpresentedSolar,atoolforautomaticsynthesisofad-
versarial contracts that exploit vulnerabilities in a victim smart
contract. To make synthesis tractable, Solar introduces summary-
basedsymbolicevaluation,whichenablesourtooltoperformprecise
all-paths analysis of large real-world contracts, while significantly
reducing the number of paths that need to be executed symboli-
cally.Solaralsointroducesoptimizationstopartitionthesynthesis
search space for parallel exploration. Evaluating Solar on the en-
tireEtherscandataset,wefindthatitsignificantlyoutperforms
state-of-the-art analyzers in terms of precision and execution time.
ACKNOWLEDGEMENTS
This work has been supported in part by the NSF Grants CCF-
1651225, ACI OACâ€“1535191, FMitF CCF-1918027, OIA-1936731,
SaTC-1908494, by the Intel and NSF joint research center for Com-
puterAssistedProgrammingforHeterogeneousArchitectures(CAPA
NSF CCF-1723352), the CONIX Research Center, one of six centers
in JUMP, a Semiconductor Research Corporation (SRC) programsponsored by DARPA CMU 1042741-394324 AM01, grants fromDARPA FA8750â€“14â€“Câ€“0011 and DARPA FA8750â€“16â€“2â€“0032, as
wellas giftsfrom Adobe,Facebook, Google, Intel,and Qualcomm.
REFERENCES
[1]2016.TheCoqProofAssistant.https://coq.inria.fr/. [Online;accessed01/09/2019].
[2]2016. GovernMentalâ€™s1100ETHpayoutisstuckbecauseitusestoomuchgas.
https://tinyurl.com/y83dn2yf/. [Online; accessed 01/09/2019].
[3]2016. Manticore. https://github.com/trailofbits/manticore/. [Online;accessed
01/09/2019].
[4]2017. Ontheparitywalletmultisighack. https://tinyurl.com/yca83zsg/. [Online;
accessed 01/09/2019].
[5]2017. The Racket Language. https://racket-lang.org/. [Online; accessed
01/09/2019].
[6]2017. UnderstandingTheDAOAttack. https://tinyurl.com/yc3o8ffk/. [Online;
accessed 01/09/2019].
[7]2018. ETHEREUM:ASECUREDECENTRALISEDGENERALISEDTRANSAC-
TION LEDGER. https://ethereum.github.io/yellowpaper/paper.pdf. [Online;
accessed 01/09/2019].
[8]2018. The Ethereum Smart Contract Fuzzer for Security Vulnerability Detection.
https://github.com/gongbell/ContractFuzzer. [Online; accessed 01/09/2019].
[9]2018. The Ethereum Smart Contract Fuzzer for Security Vulnerability Detection.
https://github.com/gongbell/ContractFuzzer. [Online; accessed 01/09/2019].
[10]2018. EthereumSmartContractSecurityBestPractices. https://consensys.github.
io/smart-contract-best-practices/. [Online; accessed 01/09/2019].
[11] 2018. Etherscan. https://etherscan.io/. [Online; accessed 01/09/2019].
[12]2018. MythrilClassic. https://github.com/ConsenSys/mythril-classic. [Online;
accessed 12/01/2018].
[13]2018. New batchOverflow Bug in Multiple ERC20 Smart Contracts. https://
tinyurl.com/yd78gpyt. [Online; accessed 01/09/2019].
[14]2018. Parity Multisig Wallet Hacked, or How Come? https://cointelegraph.com/news/parity-multisig-wallet-hacked-or-how-come. [Online; accessed
01/09/2019].
[15]2018. Real Estate Business Integrates Smart Contracts. https://tinyurl.com/
yawrkfpx/. [Online; accessed 01/09/2019].
[16]2018. Smart contracts for shipping offer shortcut. https://tinyurl.com/yavel7xe/.
[Online; accessed 01/09/2019].
[17] 2018. Time manipulation. https://dasp.co/. [Online; accessed 01/09/2019].[18]
2018. UncheckedReturnValuesForLowLevelCalls. https://dasp.co. [Online;
accessed 01/09/2019].
1151[19] 2019. Bitcoin. https://bitcoin.org/. [Online; accessed 01/09/2019].
[20] 2019. Ethereum. https://www.ethereum.org/. [Online; accessed 01/09/2019].[21]
2019. Ethereum YellowPaper. https://github.com/ethereum/yellowpaper. [On-
line; accessed 01/09/2019].
[22]2019. Serpent. https://github.com/ethereum/serpent. [Online; accessed
01/09/2019].
[23]2019. Solidity. https://solidity.readthedocs.io/en/v0.5.1/. [Online; accessed
01/09/2019].
[24]2019. Vyper. https://github.com/ethereum/vyper. [Online; accessed 01/09/2019].
[25]Rajeev Alur, Rastislav BodÃ­k, Eric Dallal, Dana Fisman, Pranav Garg, Garvit
Juniwal, Hadas Kress-Gazit, P. Madhusudan, Milo M. K. Martin, Mukund
Raghothaman,ShambwadityaSaha,SanjitA.Seshia,RishabhSingh,Armando
Solar-Lezama, Emina Torlak, and Abhishek Udupa. 2015. Syntax-Guided Synthe-
sis. InDependable Software Systems Engineering. 1â€“25.
[26]Saswat Anand, Patrice Godefroid, and Nikolai Tillmann. 2008. Demand-Driven
Compositional Symbolic Execution. In Tools and Algorithms for the Construction
and Analysis of Systems, 14th International Conference, TACAS 2008, Held as Part
of the Joint European Conferences on Theory and Practice of Software, ETAPS2008, Budapest, Hungary, March 29-April 6, 2008. Proceedings. 367â€“381. https:
//doi.org/10.1007/978-3-540-78800-3_28
[27]Nicola Atzei, Massimo Bartoletti, and Tiziana Cimoli. 2017. A Survey of Attacks
on Ethereum Smart Contracts (SoK). In Principles of Security and Trust - 6th
InternationalConference,POST2017,HeldasPartoftheEuropeanJointConferencesonTheoryandPracticeofSoftware,ETAPS2017,Uppsala,Sweden,April22-29,2017,
Proceedings. 164â€“186.
[28]ThanassisAvgerinos,SangKilCha,BrentLimTzeHao,andDavidBrumley.2011.
AEG:AutomaticExploitGeneration.In Proc.TheNetworkandDistributedSystem
Security Symposium.
[29]Roberto Baldoni, Emilio Coppa, Daniele Cono Dâ€™Elia, Camil Demetrescu, and
IreneFinocchi.2018. ASurveyofSymbolicExecutionTechniques. ACMComput.
Surv.51, 3 (2018), 50:1â€“50:39. https://doi.org/10.1145/3182657
[30]PeterBoonstoppel,CristianCadar,andDawsonR.Engler.2008. RWset:Attacking
Path Explosion in Constraint-Based Test Generation. In Tools and Algorithms for
theConstructionandAnalysisofSystems,14thInternationalConference,TACAS
2008, Held as Part of the Joint European Conferences on Theory and Practice ofSoftware, ETAPS 2008, Budapest, Hungary, March 29-April 6, 2008. Proceedings.
351â€“366. https://doi.org/10.1007/978-3-540-78800-3_27
[31]Sang Kil Cha, Thanassis Avgerinos, Alexandre Rebert, and David Brumley. 2012.
UnleashingMayhemonBinaryCode.In Proc.IEEESymposiumonSecurityand
Privacy. 380â€“394.
[32]Patrick Cousot and Radhia Cousot. 1977. Abstract Interpretation: A Unified
LatticeModelforStaticAnalysisofProgramsbyConstructionorApproximation
ofFixpoints. In Proc.Symposiumon PrinciplesofProgramming Languages.238â€“
252.
[33]Patrice Godefroid. 2007. Compositional dynamic test generation. In Proceedings
of the 34th ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, POPL 2007, Nice, France, January 17-19, 2007 . 47â€“54. https://doi.org/
10.1145/1190216.1190226
[34]Neville Grech, Michael Kong, Anton Jurisevic, Lexi Brent, Bernhard Scholz, and
YannisSmaragdakis.2018. MadMax:survivingout-of-gasconditionsinEthereumsmartcontracts.In Proc.InternationalConferenceonObject-OrientedProgramming,
Systems, Languages, and Applications. 116:1â€“116:27.
[35]Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. 2018. A Semantic
Framework for the Security Analysis of Ethereum Smart Contracts. In Principles
of Security and Trust - 7th International Conference, POST 2018, Held as Part of
theEuropeanJointConferencesonTheoryandPracticeofSoftware,ETAPS2018,
Thessaloniki, Greece, April 14-20, 2018, Proceedings. 243â€“269.
[36]Shelly Grossman, Ittai Abraham, Guy Golan-Gueta, Yan Michalevsky, NoamRinetzky, Mooly Sagiv, and Yoni Zohar. 2018. Online detection of effectively
callback free objects with applications to smart contracts. In Proc. Symposium on
Principles of Programming Languages. 48:1â€“48:28.
[37]SumitGulwani,OleksandrPolozov,andRishabhSingh.2017. ProgramSynthesis.
Foundations and Trends in Programming Languages 4, 1-2, 1â€“119.
[38]Yoichi Hirai. 2017. Defining the Ethereum Virtual Machine for Interactive Theo-
rem Provers. In Financial Cryptography and Data Security - FC 2017 International
Workshops, WAHC, BITCOIN, VOTING, WTSC, and TA, Sliema, Malta, April 7,
2017, Revised Selected Papers. 520â€“535.
[39]BoJiang,YeLiu,andW.K.Chan.2018.ContractFuzzer:fuzzingsmartcontractsfor
vulnerabilitydetection.In Proc.InternationalConferenceonAutomatedSoftware
Engineering. 259â€“269.
[40]Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. 2018. ZEUS:
AnalyzingSafetyofSmartContracts.In Proc.TheNetworkandDistributedSystem
Security Symposium.
[41]JamesCKing.1976. Symbolicexecutionandprogramtesting. Commun.ACM
19, 7 (1976), 385â€“394.
[42]Johannes Krupp and Christian Rossow. 2018. teEther: Gnawing at Ethereum
toAutomatically ExploitSmartContracts. In Proc.USENIX SecuritySymposium.
1317â€“1333.
[43]Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor.2016. Making Smart Contracts Smarter. In Proc. Conference on Computer and
Communications Security. 254â€“269.
[44]AinaNiemetz,MathiasPreiner,andArminBiere.2014(published2015). Boolector
2.0 system description. Journal on Satisfiability, Boolean Modeling and Computa-
tion9 (2014 (published 2015)), 53â€“58.
[45]DaejunPark,YiZhang,ManasviSaxena,PhilipDaian,andGrigoreRosu.2018.
A formal verification tool for Ethereum VM bytecode. In Proceedings of the 2018
ACM Joint Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering, ESEC/SIGSOFT FSE 2018, Lake Buena
Vista, FL, USA, November 04-09, 2018. 912â€“915.
[46]Zvonimir Rakamaric and Michael Emmi. 2014. SMACK: Decoupling Source
LanguageDetailsfromVerifierImplementations.In Proc.InternationalConference
on Computer Aided Verification. 106â€“113.
[47]EminaTorlakandRastislavBodÃ­k.2014. Alightweightsymbolicvirtualmachine
forsolver-aidedhostlanguages.In Proc.ConferenceonProgrammingLanguage
Design and Implementation. 530â€“541.
[48]Petar Tsankov, Andrei Marian Dan, Dana Drachsler-Cohen, Arthur Gervais,
Florian BÃ¼nzli, and Martin T. Vechev. 2018. Securify: Practical Security Analysis
ofSmartContracts.In Proc.ConferenceonComputerandCommunicationsSecurity.
67â€“82.
1152