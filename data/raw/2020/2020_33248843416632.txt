JISET: JavaScript IR-based Semantics Extraction Toolchain
Jihyeok Park
KAIST, South Korea
jhpark0223@kaist.ac.krJihee Park
KAIST, South Korea
j31d0@kaist.ac.kr
Seungmin An
KAIST, South Korea
h2oche@kaist.ac.krSukyoung Ryu
KAIST, South Korea
sryu.cs@kaist.ac.kr
ABSTRACT
JavaScript was initially designed for client-side programming in
web browsers, but its engine is now embedded in various kinds of
hostsoftware.Despitethepopularity,sincetheJavaScriptsemantics
iscomplexespeciallyduetoitsdynamicnature,understandingand
reasoningaboutJavaScriptprogramsarechallengingtasks.Thus,
researchers have proposed several attempts to define the formal
semanticsofJavaScriptbasedonECMAScript,theofficialJavaScript
specification. However, the existing approaches are manual, labor-
intensive, and error-prone and all of their formal semantics target
ECMAScript 5.1 (ES5.1, 2011) or its former versions. Therefore,
theyarenotsuitableforunderstanding modernJavaScript language
features introduced since ECMAScript 6 (ES6, 2015). Moreover,
ECMAScript hasbeen annuallyupdated sinceES6, whichalready
made five releases after ES5.1.
Toalleviatetheproblem,wepropose JISET,aJavaScriptIR-based
SemanticsExtractionToolchain.Itisthefirsttoolthat automatically
synthesizes parsersandAST-IRtranslatorsdirectlyfromagivenlan-
guage specification, ECMAScript. For syntax, we develop a parser
generationtechniquewith lookaheadparsing forBNFES,avariant
of the extended BNF used in ECMAScript. For semantics, JISET
synthesizesAST-IRtranslatorsusing forwardcompatible rule-based
compilation. Compile rules describe how to convert each step of ab-
stractalgorithmswritteninastructurednaturallanguageinto IRES,
an Intermediate Representation that we designed for ECMAScript.
ForthefourmostrecentECMAScriptversions, JISETautomatically
synthesized parsers for all versions, and compiled 95.03% of thealgorithmstepsonaverage.Afterwecompletethemissingpartsmanually, the extracted core semantics of the latest ECMAScript
(ES10,2019)passedall18,064applicabletests.Usingthis firstformal
semantics of modern JavaScript, we found nine specification errors
in ES10, which were all confirmed by the Ecma Technical Commit-
tee39.Furthermore,weshowedthat JISETisforwardcompatible by
applyingittoninefeatureproposalsreadyforinclusioninthenext
ECMAScript, which let us find three errors in the BigInt proposal.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416632
Figure 1: Existing approaches: Manually built parsers and
AST-IR translators for JavaScript IR-based semantics
KEYWORDS
JavaScript, mechanized formal semantics, program synthesis
1 INTRODUCTION
JavaScript is one of the most widely used programming languages
not only for client-side but also for server-side programming [ 5,6]
and even for small embedded systems [ 3,9]. It is the top-ranked
language used in active GitHub repositories1, and #7 in the TIOBE
ProgrammingCommunityindex2.AccordingtoW3Techs3,95.0%of
websites use JavaScript as their client-side programming language.
Despite its popularity, JavaScript developers often suffer from
itsintricatesemantics,whichmaycauseunexpectedbehaviors.For
example, the following function may seem to always return false:
function f(x) { returnx= =! x ;}
Unfortunately,itreturns truewhenitsargumentisanemptyar-
ray[].Tocorrectlyunderstandandreasonaboutsuchacomplex
behavior, the formal semantics of JavaScript is necessary.
ResearchershavedefinedvariousJavaScriptformalsemantics[ 17,
18,21,25]suitableforstaticanalysis[ 19,20,23,29]andformalveri-
fication[17]byreferringtoECMAScript.ECMAScriptistheofficial
specification that describes the JavaScript syntax using a variant of
theextendedBNF(EBNF)notation,anditssemanticsusingabstract
algorithms written in English in a clear and structured manner.
IR-based semanticsextraction is atraditional way todefine the for-
mal semantics of a language by building a compiler front-end that
takesprogramsandproducestheirIntermediateRepresentations
(IRs)toindirectlyrepresentthesemanticsofthegivenprograms.
As illustrated in Figure 1, a compiler front-end consists of a parser
that constructs Abstract Syntax Trees (ASTs) of given JavaScriptprograms, and an AST-IR translator that converts ASTs to their
own IRs. It helps researchers focus on IRs without worrying about
1https://githut.info/
2https://www.tiobe.com/tiobe-index/
3https://w3techs.com/technologies/details/cp-javascript/all/all
6472020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
diverse and enormous features of JavaScript in developing new
techniques for static analysis and formal verification.
However, to the best of our knowledge, all existing approaches
to JavaScript IR-based semantics extraction manually build parsers
and translators. Although manually building them was reason-
able until ECMAScript 5.1 (ES5.1, 2011) [ 1], it is too tedious, labor-
intensive, and error-prone to deal with the large size of modern
JavaScript since ECMAScript 6 (ES6, 2015) [ 2]. ES6 introduced nu-
meroussignificantlynewfeaturessuchaslexicalbindingvia let,
the spread ...operator, classes, the for-ofoperator, the async
functions,andgenerators.Forexample,considerKJS[ 25],oneof
formalsemanticsofES5.1definedontopof K,whichisaframework
for defining language semantics. According to an author of KJS,
it tookfour months to implement an AST-IR translator for 1,370
stepsoutof2,932stepsin368abstractalgorithms[ 24].However,
themostrecentversionofECMAScript(ES10,2019)[ 7]has2,026
abstract algorithms consisting of 10,101 steps. Thus, the manual
approachesdonotseemtobescalableenoughtobuildanAST-IR
translatorformodernJavaScript,andindeednoformalsemantics
exists for ES6 to ES10.
Moreover,JavaScriptsyntaxandsemanticsareannuallyupdated.
Until ES5.1, JavaScript was a stable language because the specifica-
tion was rarely updated. However, the Ecma Technical Committee
39(TC39)[ 8]decidedtoreleasethespecificationannuallyinlate
2014. After this official announcement, several syntax features and
roughly 1,000 to 3,000 steps of abstract algorithms have been mod-
ified or newly added in the specification every year. To handlethese frequent and massive updates of ECMAScript, the manualapproaches require researchers to manually update parsers and
AST-IR translators, which incurs tremendous efforts.
Toalleviatethisproblem,weproposeatechniqueto automati-
cally synthesize parsers and AST-IR translators directly from EC-
MAScriptwith forwardcompatibility.Thereareseveraltechnical
challenges in synthesizing parsers and translators. For syntax, EC-
MAScript utilizes its own variant of EBNF with parametric non-terminals, conditional alternatives, and various special terminal
symbols.Thus,noexistingparsergenerationtechniqueisdirectly
applicable for this variant. Moreover, JavaScript provides auto-matic semicolon insertion in its parsing algorithm with several
complex rules, not in a lexer. For semantics, abstract algorithms in
ECMAScript are written in English. Besides, a general and forward
compatible representation of abstract algorithms is necessary to
support future versions of ECMAScript.
Our contribution is JISET, a JavaScript IR-based Semantics Ex-
traction Toolchain:
•JISETisthefirsttoolthatautomaticallyextract IR-based
semanticsfromalanguagespecification,ECMAScript. For
syntax,weformallyintroduceavariantofEBNF, BNFES,and
propose a parser generation technique with lookahead pars-
ing forBNFES, which supports automatic semicolon insertion.
For semantics, we propose semi-automatic synthesis of AST-IR
translators assisted by compile rules. Compile rules describehow to convert each step of abstract algorithms into our in-
termediaterepresentation IRESdesignedforECMAScript. We
evaluated JISETwith the four most recent ECMAScript ver-
sions(ES7toES10). JISETautomaticallygeneratedparsersfor
Figure 2: Overall structure of JISET: Automatically synthe-
sizedJavaScript Parser andAST-IRESTranslator for JavaScript
IR-based semantics
all versions, and automatically compiled 95.03% of the steps in
abstract algorithms on average.
•JISETbridgesgapsbetweenthespecificationwrittenina
natural language and tests. To evaluate the correctness of
JISET, we checked the extracted semantics with the official test
conformance suite, Test262 [ 10]. By manually completing miss-
ing parts of the AST-IR translator for the latest ECMAScript
(ES10,2019),wedefinedthe firstIR-basedformalsemanticsof
modern JavaScript. It failed for 1,709 tests because of specifica-
tionerrorsinES10.Usingthetests,wefoundeightspecificationerrors,threeofwhichhadnotbeenreportedbefore.TheywereallconfirmedbyTC39andwillbefixedinthenextrelease.After
fixingthem, theformal semanticspassedall 18,064applicable
tests.
•JISETis alsoforward compatible with new language fea-
turesproposedforfutureECMAScriptspecifications. We
evaluatedtheforwardcompatibilityof JISETbyapplyingitto
allnineproposalsthatarereadyforinclusioninthenextEC-
MAScript(ES11,2020).Itautomaticallysynthesizedparsersand
compiled560 outof 595algorithm steps forall theproposals.
Aftercompletionofthemissingparts,wefoundthreespecifica-
tions errors in BigInt proposal by executing the corresponding
tests in Test262. After fixing them, the extracted semantics
passed all applicable ES10 tests and 303 new applicable tests.
2 OVERVIEW
Inthissection,weintroducetheoverallstructureof JISETdepicted
inFigure2.ComparedtotheexistingapproachesshowninFigure1,
our tool automatically synthesizes JavaScript Parser andAST-IRES
Translator directly from ECMAScript. The motivation of this work
is twofold: 1) ECMAScript is written in a well-organized style, and
2) the writing style is converged since ES7 in 2016. We explainhow
JISETutilizes such common patterns in the writing style to
648(a)ArrayLiteral production in ES10
valArrayLiteral: List[Boolean] =>LAParser[T] =memo {
caseList(Yield, Await) =>
"["~ opt(Elision) ~ "]" ^^ ArrayLiteral0 |
"["~ ElementList(Yield,Await) ~ "]"^^ ArrayLiteral1 |
"["~ ElementList(Yield,Await) ~ ","
~ opt(Elision)~ "]" ^^ ArrayLiteral2
}
(b) Generated parser for the ArrayLiteral production
Figure 3: ArrayLiteral production in ES10 and its parser
synthesize JavaScript Parser andAST-IRESTranslator using the
syntax and semantics in JSON format extracted from ECMAScript
bySpec Extractor.
Syntax.ECMAScript provides the lexical and syntactic gram-
mars in Appendix A using a variant of EBNF for ECMAScript. We
dubitBNFESandformallydefineitinSection3.Our SpecExtractor
readsthegrammarswrittenin BNFESandconvertsthemintoJSON
files.Forexample,Figure3(a)showsthe ArrayLiteral production
inES10.Ittakestwobooleanparameters YieldandAwaitandhas
threealternatives.Thefirstalternativeconsistsofthreesymbols:
two terminal symbols [and], and one non-terminal symbol Eli-
sionopt.Theoptsubscriptdenotesthatitisoptional.Inthesecond
and third alternatives, ElementList [?Yield, ?Await] denotes a paramet-
ricnon-terminalsymbol ElementList withtheparameters Yieldand
AwaitofArrayLiteral asitstwoarguments.Theprefix ?ofasymbol
denotes that the symbol is passed as an argument.
To generate JavaScript Parser from a given BNFESgrammar, we
construct Parser Generator in Scala. It synthesizes a JavaScript
parseraccordingtothegiven BNFES,andthegeneratedparseris
defined with Scala parser combinators [ 12]. Moreover, in order
to parse BNFESgrammars correctly and efficiently, we propose
lookahead parsers, which keep track of lookaheads, sets of possible
next tokens. With lookahead parsing, generated parsers now have
one-to-one mapping to their corresponding grammar productions,
improving readability. For example, Figure 3(b) shows the gener-ated parser for the ArrayLiteral production in Figure 3(a). Each
parserhasthe List[Boolean] => LAParser[T] typebecauseeach
productionin BNFESisparametricwithbooleanvalues.The memois
a memoization function for pairs of boolean parameters and result-
ing parsers for performance optimization. The value ArrayLiteral
corresponds to the ArrayLiteral production. In the parser, each
string literal such as "["or"]"denotes a parser for a terminal
symbol.The opthelperfunctioncreatesoptionalparsers.Thepara-
metricnon-terminal ElementList witharguments YieldandAwait
is represented as a function call ElementList(Yield, Await) . The
~operatorcombinestwoparsersandthe ˆˆoperatordescribeshow
to construct ASTs. When the left-hand side of ˆˆis matched, its
right-hand side shows a corresponding AST constructor, wherethe name of each constructor has a number denoting the order
(a) Evaluation abstract algorithm for the third alternative
ArrayLiteral[2].Evaluation (ElementList, Elision) => {
l e ta r r a y=!( ArrayCreate 0)
let len = (ElementList.ArrayAccumulation array 0)
?l e n
if (= Elision absent) let padding = 0
else let padding = Elision.ElisionWidth
(Set array "length" (ToUint32 (+ padding len)) false)
return array
}
(b) The generated IR ESfunction
Figure4:Evaluationabstractalgorithmforthethirdalterna-tive ofArrayLiteral in ES10 and its generated IR
ESfunction
among alternatives. For example, the ArrayLiteral0 constructor
corresponds to the first alternative of the ArrayLiteral production.
Semantics. ECMAScript describes the language semantics as
abstract algorithms in English. While they are written in a natural
language,thewritingstyleiswell-organizedwithorderedstepsandtaggedtokens. SpecExtractor readsabstractalgorithmswithHTML
tags and converts them into JSON files. For example, Figure 4(a)presents the
Evaluation abstract algorithm of the third alterna-
tiveof the ArrayLiteral productionin ES10,andit hassevensteps.
In the HTML files describing the abstract algorithms, each non-
terminalsymbol (e.g. ElementList ),localvariable (e.g. array),code
(e.g."length" ), or value (e.g. false) has the <nt>,<var>,<code>,o r
<emu-val> tag, respectively.
Totranslatesuchabstractalgorithmsintorepresentationssuit-
ableformanipulation,wedefine IRES,aspecializedintermediate
representation for ECMAScript. Then, we develop Algorithm Com-
pilerinScalausingScalaparsercombinatorsagaintoconvertgiven
abstractalgorithmsto IRESfunctions.Italsotakes CompileRules
as another input, which has two parts: parsing rules and conver-sion rules. They are manually specified for ECMAScript; we ex-
plain them in detail in Section 4. Thus, each abstract algorithmis converted into a function written in
IRESviaAlgorithm Com-
piler.Forexample,Figure4(b)presentsthegenerated IRESfunction
for theEvaluation abstract algorithm shown in Figure 4(a). The
ArrayLiteral[2].Evaluation function takes two parameters for
twonon-terminalsymbols: ElementList andElision.Theparam-
eterElisionhas a special value absentwhen the non-terminal
symbolElisionoptis not present. Thus, we convert the condition
in step 4, “if Elisionis not present,” into the equality check with
absent:if (= Elision absent) . Codes are represented as string
valuesandvaluesarerepresentedascorresponding IRESvalues.For
649instance,thecode "length" andthevalue falseareconvertedinto
thestringvalue "length" andthebooleanvalue false,respectively.
Finally,JISETconstructs AST-IRESTranslator with the given
IRESfunctions and manually specified Global Setting, which has
minorbutnecessaryinformationtoevaluateJavaScriptprograms
describedinECMAScriptsuchasthestructureofthestandardbuilt-
inobjectsandECMAScriptdatatypes.Puttingthemalltogether,
wecantranslateagivenJavaScriptprograminto IRESviagenerated
JavaScriptParser andAST-IRESTranslator byJISET.Eventhough
JISETisnotfullyautomaticbecauseof CompileRules andGlobal
Setting, it could dramatically reduce the efforts to building parsers
and translators from scratch.
In the remainder of this paper, we explain the details of how
toautomaticallygenerateparsers(Section3)andhowtocompile
abstract algorithms (Section 4). After evaluating JISET(Section 5),
we discuss related work (Section 6), and conclude (Section 7).
3 PARSER GENERATOR
Inthissection,weexplainhowtoautomaticallygenerateJavaScript
parsers from a given ECMAScript.
3.1 BNF ES: Grammar for ECMAScript
ECMAScript describes the JavaScript syntax using a variant of the
extendedBNF.Weformallydefinethenotationanddubit BNFES.
It consists of a number of productions with the following form:
A(p1,··· ,pk)::=(c1⇒)?α1|···|(cn⇒)?αn
The left-hand side of :: =represents a parametric non-terminal A
with multiple boolean parameters p1,··· ,pk. If a non-terminal
takes no parameter, parentheses are omitted for brevity. A produc-
tionhasmultiplealternativesseparatedby |withoptionalcondi-
tions. A condition cis either a boolean parameter por its negation
!p. An alternative αis a sequence of symbols, where a symbol sis
one of the following:
•ϵ:theemptysequence,whichpasseswithoutanyconditions
•a: a terminal, which is any token
•A(a1,··· ,ak): a non-terminal, which takes multiple argu-
mentswhere eachargument aiiseither abooleanvalue #t
or#f, or a parameter pi
•s?: option, which is the same with s|ϵ
•+s(−s):positive(negative)lookahead,whichcheckswhether
ssucceeds (fails) and never consumes any input
•s/integerdivides/prime: exclusion,which firstchecks whether ssucceeds and
then checks whether the parsing result does not correspond
tos/prime
•/angbracketleft¬LT/angbracketright: no line-terminator, which is a special symbol that
restricts the white spaces between two different symbols
For example, consider the following production:
A(p)::=p⇒a|!p⇒b|c
Then,A(#t)meansa|candA(#f)meansb|c.
3.2 Lookahead Parsing
Tosupport BNFEScorrectly,weextendPEG-basedparsergenera-
tion techniques with lookahead parsing.Background:ParsingExpressionGrammar. Mostparsergen-
erators target context-free languages with specific parsing algo-
rithmsforContext-FreeGrammar(CFG):JavaCCwithLL(k)[ 13],
Bison with GLR [ 30], and ANTLR with ALL(*) [ 26]. However, they
are not directly applicable for the ECMAScript syntax because EC-
MAScript lexical and syntactic grammars require context-sensitive
lexers and parsers:
•Context-sensitivetokens: ECMAScripttokensarecontext-
sensitive because of JavaScript regular expressions and tem-
plate strings. For example, /x/gcould be a single regular
expressiontokenorfourtokensthatrepresentdivisionby
variables xandgdependingonenclosingcontexts.Thus,lex-
ers should be evaluated during parsing not before parsing.
•Context-sensitiveBNF ESsymbols: BNFESsupportscontext-
sensitivesymbols,whicharepositive(negative)lookahead
+s(−s), exclusion s/integerdivides/prime, and no line-terminator /angbracketleft¬LT/angbracketright. They
arehighlyexpressiveandtheycanevenrepresenttheclas-
sic non-context-free language {anbncn:n≥1}with the
following productions:
S::=+(Xc)AY X::=aX?b
A::=aA? Y::=bY?c
However, it is not trivial to support such BNFESsymbols in
CFG-based parser generators.
Unlike CFG-based parser generators, parser generators based
onParsing Expression Grammar (PEG) [16] can easily resolve these
problems.PEGsaredefinedwithatop-down(LL-style)recursive
descent parser with backtracking. It visits each alternative of a
productioninorderandbacktrackstoitspreviousproductionwhen
parsingfails.PEG-basedparsergeneratorstreatlexersasparsers,
thus we can use appropriate lexers depending on parsing contexts.
Moreover, PEGs support and-predicate (&) andnot-predicate (!)
operatorsthatdenotethesamemeaningofthepositiveandnegative
lookaheadsymbolsin BNFES,respectively.Therefore,wecaneasily
supportcontext-sensitivetokensand BNFESsymbolsinPEG-based
parser generators.
Problem: Prioritized Choices. While PEG-based parser gen-
eratorssupportthecontext-sensitivity,PEGshaveonefundamental
difference with BNFES:prioritized choices. PEGs use the prioritized
choice operator ‘ /’ instead of the unordered pipe operator ‘ |’i n
BNFES; even when multiple alternatives are applicable, PEGs al-
wayspickthefirstsuccessfulalternative.Forexample,considerthe
following BNF ES:
S::=E+E
E::=x|x.p(1)
As expected, this grammar accepts the string x+x.p. However, the
following PEG:
S::=E+E
E::=x/x.p(2)
does not accept the same string x+x.p. Because the first alternative
xofEis chosen whenever an input string starts with x, the second
alternative x.pofEis always unreachable. A simple solution to
acceptthestringisjusttochangetheorderofalternativesof Elike
E::=x.p/x.
650firstα(s1···sn)=firsts(s1):+firstα(s2···sn)
wherex:+y=/braceleftBigg
x∪yif◦∈x
xotherwise
firsts(ϵ) ={◦}
firsts(a) ={a}
firsts(A(a1,··· ,ak))=firstα(α1)∪···∪ firstα(αn)
whereA(a1,··· ,ak)=α1|···|αn
firsts(s?) =firsts(s)∪{◦}
firsts(+s) =firsts(s)
firsts(−s) ={◦}
firsts(s/integerdivides/prime) =firsts(s)
firsts(/angbracketleft¬LT/angbracketright) ={◦}
Figure 5: Over-approximated first tokens of BNF ESsymbols
Unfortunately, simple reordering is not a general solution for all
cases. Consider the following BNF ES:
S::=Ab
A::=a|ab(3)
It accepts both strings abandabb. However, the following PEG:
S::=Ab
A::=a/ab(4)
accepts only ab, and another PEG with reordered productions as
follows:
S::=Ab
A::=ab/a(5)
accepts only abb.
Solution: Lookahead Tokens. To alleviate the problem, we
proposelookaheadparsing,whichisanextendedparsingalgorithm
for PEGs with lookahead tokens. The key idea of lookahead parsing
is to keep track of the next possible tokens by statically calculating
asetoffirsttokensforeachsymbolusingthealgorithminFigure5.
For example, the following steps explainhow to utilize lookahead
tokens during parsing of the string x+x.pwith the PEG in Equa-
tion (1):
x[+]+[x]E[◦] E[+]S[◦]
 ZZx[◦]x+x.p
x+x.p x+x .p
x+x. px+x.px+x.p
x+x.p x+x.p x+x .p
x[.].[p]p[◦]
x + . p x
Eachnode s[L]denotesasymbol swithasetoflookaheadtokens
L. The underlined character in the string of each node denotes the
current position in the parsing process that follows a pre-order
traversal.Theparserstartsfromthestartingnon-terminal Swith
thespeciallookahead ◦,whichdenotestheendofinputs.Then,it
visits the first alternative E+Ewith the same lookahead ◦. Each
symbol is visited with its corresponding lookahead, which is the(s1···sn)[L]=s1[firsts(s2···sn):+L](s1···sn)[L]
ϵ[L] =+gets(L)
a[L] =a+gets(L)
A(a1,··· ,ak)[L]=α1[L]|···|αn[L]
whereA(a1,··· ,ak)=α1|···|αn
s?[L] =s[L]|ϵ[L]
(±s)[L] =±(s[L])
(s/integerdivides/prime)[L] =s[L]/integerdivides/prime
/angbracketleft¬LT/angbracketright =/angbracketleft¬LT/angbracketright+gets(L)
Figure 6: Formal semantics of lookahead parsers
firsttokensoftherightnextsymbol.Forexample,forthesecond
symbol+inE+E, the next symbol is Eand its first tokens are:
firsts(E)=firstα(x)∪firstα(x.p)
=firsts(x)∪(firsts(x):+firstα(.p))={x}
Thus, the parser visits +with the lookahead x. The most important
point here is the difference between two visits of the non-terminal
EinE+E. The first visit of Ehas the lookahead +and the actual
next character after matching xis also+. Thus, the first alternative
xofEischosenforthefirstvisit.However,inthesecondvisitof
E, the lookahead is the end of inputs ◦but the next character after
matching xis the dot character ( .) instead of the end of inputs.
Therefore, thesecond alternative x.pis chosenin thesecond visit
and the parser now successfully parses the input x+x.p.
We formally define the semantics of lookahead parsers in Fig-
ure6.Thehelperfunction gets(L)generatesaparserbycombining
all tokens in the lookahead Lusing prioritized choices. In this case,
theorderdoesnotchangethesemanticsoflookaheadparsersbe-
causegets(L)just checks the existence of a given token.
3.3 Implementation
We implemented the lookahead parsing technique by extending
the Scala parser combinators library, which is a Scala library for
PEG-basedparsergeneration.Wedeveloped ParserGenerator to
synthesize PEG-based parsers with lookahead parsing for BNF ES.
AST Generation. Parser Generator first automatically synthe-
sizes ASTs as Scala classes from a given BNF ESgrammar. Because
thestructureoflexicalproductionsdonotaffecttheECMAScript
semantics, we represent lexical non-terminals as string values. For
each syntactic production A(p1,··· ,pk)::=(c1⇒)?α1| ··· |
(cn⇒)?αn, the generator synthesizes a trait Aand its multiple sub-
classesAifor 0≤i≤n−1 that represent its alternatives. Each
classAihas non-terminals in its corresponding alternative as its
fields. For instance, the ArrayLiteral production in Figure 3 gets
automatically translated to the following Scala classes:
traitArrayLiteral extends AST
case class ArrayLiteral0(x1: Option[Elision])
case class ArrayLiteral1(x1: ElementList)
case class ArrayLiteral2(x1: ElementList, x3: Option[Elision])
Parser Generation. The next step is to automatically synthe-
sizes parsers for each production in BNFES. We extended Scala
parser combinators to support lookahead parsing and BNFESno-
tations.Forexample,thesynthesizedparserfromtheproduction
651Figure 7: Overall structure of Algorithm Compiler
ArrayLiteral in Figure 3(a) is the one in Figure 3(b). A naïve im-
plementation of lookahead parsing would take exponential time
because of backtracking. To reduce it to linear time, we applied the
memoizationtechniqueintroducedinPackratparsing[ 15].More-
over,wealsoimplementedthe growingtheseed techniquepresented
byWarthetal .[32]tosupportdirectandevenindirectleftrecursive
productions.Itenablesthesynthesisofparserswithoutchanging
the structure of each production in BNF ES.
Thesynthesizedparsersalsosupporttheautomaticsemicolon
insertion algorithm, which is one of the most distinctive parsing
featuresinECMAScript.Weextendedourparsingalgorithmtokeep
track of the right-most position that fails to be parsed in a given
input. In ECMAScript, the token at that position is defined as an
offending token and the automatic semicolon insertion algorithm is
definedwithsuchtokens.Thealgorithmissimplewhenwealready
have the positions of offending tokens. Thus, we just manually
supportedthembyfollowingtherulesdefinedinSection11.94in
ES10. The automatic semicolon insertion rules rarely change; since
ES5.1 written in 2011, only one sub-rule was added.
4 ALGORITHM COMPILER
Inthissection,weexplain AlgorithmCompiler thatcompilesab-
stract algorithms to IR ESfunctions as illustrated in Figure 7.
4.1 Tokenizer
Beforecompilingabstractalgorithms, Tokenizer firsttokenizeseach
abstractalgorithmintoalistoftaggedtokens.Analgorithmcon-
sistsoforderedsteps,andastepmaycontainsub-stepsaswell.Forexample,the
Evaluation abstractalgorithminFigure4(a)hasseven
steps. Moreover, the tokens of each step have their own HTMLtags and each tag has a meaning. We keep such HTML tag infor-mation for each token to construct more precise Compile Rules.
If an HTML element is just a text without any explicit tags, it is
dividedintomultipletokensandeachtokenbecomesasequence
ofalphanumericcharactersorasinglenon-alphanumericcharac-
ter. For example, in the Evaluation algorithm, "length" is a single
tokenwiththeHTMLtag <code>andPerform Set( isdividedinto
three text tokens Perform,Set, and(.
Moreover, Tokenizer flattens a structured step to a single to-
ken list to handle multi-step statements easily. Some statementsinabstractalgorithmsconsistofmultiplesteps.Forexample,the
if−then−elsestatementoftenconsistsoftwosteps:oneforthe
then-branch and the other for the else-branch. To treat them as a
4https://www.ecma-international.org/ecma-262/#sec-automatic-semicolon-insertionlinearstructure, weintroducethreespecialtokensto breakdown
structured algorithms: ↓denotes the end of a single step, and /arrowsoutheast
and/arrowsouthwestdenote the start and the end of nested steps, respectively.
Forexample,thefollowingleftabstractalgorithmistokenizedto
the right token list.
1. A
2. B =⇒A↓B/arrowsoutheastC↓/arrowsouthwest↓
a. C
After tokenizing abstract algorithms, Algorithm Compiler com-
piles token lists into IRESfunctions using Token List Parser and
Token AST Converter. They depend on Compile Rules and each
compile rule consists of a parsing rule and aconversion rule :
valCompileRule =ParsingRule ^^ ConversionRule
For each compile rule, its parsing rule describes how to parse a
giventokenlistintoastructuredtokenAST,anditsconversionrule
describeshowtoconvertthegiventokenASTstructureintoan IRES
component.Now,weexplainthetokenlistparserandtokenAST
converter with parsing rules and conversion rules, respectively.
4.2 Token List Parser
Thetokenlistparserisdefinedwith parsingrules.Aparsingrule
isabasicparsingruleoracompositionofmultipleparsingrules.
Thecomposition A|Boftwoparsingrules AandBparsesaninput
usingbothrulesandcollectsthelongestmatchedresults.Ifbothrulesfailormatchthesamelengthoftheinput,thecomposition
fails.
We provide two kinds of basic parsing rules: tag-based rules
andcontent-basedrules.Atag-basedrulejustcheckswhetherthe
next token has a given tag. For example, the tag-based parser varT
andcodeTcheck whether the next token has the tag <var>and
<code>, respectively. A content-based parser checks whether the
next token is a text token and its content passes a given condition.
Forexample,thestringliteral "Perform" denotesacontent-based
parser that checks whether the next token is a text token withthe content
Perform. We also define two content-based parsers
wordandnumberthat check whether the content of the next token
consists of only alphabets or numbers, respectively. In addition,
we provide several helper functions such as the optional rule A?
andthepositive(negative)predicate +A(-A).Forinstance,thehelper
function repsep(A, B) generatesanewparsingrulethatdenotes
zero or more repetition of the parsing rule Ausing another parsing
ruleBas a separator.
Consider the following example parsing rule for the step 5 of
theEvaluation algorithm in Figure 4(a).
// statements
valStmt="Perform" ~ Expr ~ "."^^ ...
// expressions
valExpr=
// codes // false literal
codeT ^^ ... | "false" ^^ ... |
// variables // additions
varT ^^ ... | Expr ~ "+"~E x p r^ ^. . .|
// function calls
word ~"("~ repsep(Expr, ",")~")" ^^ ...
652We omit the conversion rule for each compile rule for brevity. The
Stmtcompileruledescribeshowtocompilestatementswithasingle
parsingrule,andthe Exprcompileruledescribeshowtocompile
expressions with five parsing rules. A token parser with the above
rulesparses thestep 5of Evaluation tothe followingtoken AST:
4.3 Token AST Converter
Conversion rules describe how to generate an IRESfunction for a
given token AST. Each conversion rule is defined with its corre-
sponding parsing rule. For basic parsing rules, their conversion
rulesalwaysreturnthestringvaluesofthecontentsinparsedto-
kens. For example, the following conversion rules are the omitted
parts in the previous example for the step 5 of Evaluation:
// statements
valStmt=... ^^ { case_~e~_=>IExpr(e) }
// expressions
valExpr=
// codes // false literal
. . .^ ^E S t r|. . .^ ^{ _=>EBool(false )} |
// variables // additions
. . .^ ^E I d |. . .^ ^{case x~_~y=>EAdd(x, y) } |
// function calls
... ^^ { casex~_~y~_=>ECall(x, y) }
)
The conversion rule of the Stmtcompile rule uses only the second
subtreeandconstructsan IExprIRESinstruction.Forthesecond
sub-tree,theconversionruleofthefifth Exprcompileruleisapplied.
It constructs ECallIRESexpression with the string value of the
first sub-treeand the sequence ofthe expressions of thethird sub-
tree. In this way, the step 5 of Evaluation is converted to the
following IRESinstruction whose beautified form is the seventh
line in Figure 4(b).
IExpr(ECall(EId("Set"), List(
EId(array), EStr("length"), ECall(EId(ToUint32), List(
EAdd(EId("padding"), EId("len")))), EBool(false))))
We define IRESto represent abstract algorithms as its functions
with the following design choices:
•Dynamictyping: Becauseeachvariableinabstractalgorithms
is not statically typed, variables do not have their own static
types while each value of IR EShas its dynamic type.
•Imperative style: IRESrepresentsalgorithmstepsasimpera-
tive instructions in the sense that each instruction changes the
current state consisting of an environment and a heap.Table 1: General compile rules for ECMAScript
Name Stmt Expr Cond Value Ty Ref
# Rules 21 27 16 11 34 9
•Higher-orderfunctionswithrestrictedscopes: Ineachfunc-
tionofIRES,onlyglobalvariables,parameters,anditslocalvari-
ablesareavailable,whichmeansthatafunctionclosuredoesnot
capture its current environment. We use such restricted scopes
because they are enough to represent abstract algorithms.
•Primitivevalues: IRESsupportsECMAScriptprimitivevalues
except “symbols” because symbols can be represented as sin-
gleton objects. Also, IRESprovides the unique absentvalue to
represent the absence of parameters. For example, when the
optionalsecondparameter ElisionofEvaluation inFigure4(a)
is absent, the parameter has the absentvalue.
•Abstract data types: IRESsupports only three abstract data
types:Recordfor mappings from values to values, Listfor
sequential data, and Symbolfor singleton data. For example,
ECMAScript environment records are represented as Record
fromstringvaluestoaddressesthatrepresentthebindingsof
the string values.
Wedefinethesyntaxof IRESthathas15kindsofinstructionsand26
kindsofexpressionswiththenotation iande,respectively.Wealso
formallydefineitsoperationalsemantics σ/turnstilelefti⇒σforinstructions
andσ/turnstilelefte⇒(v,σ)for expressions, where σdenotes a stateand v
denotesavalue.Forpresentationbrevity,weomittheformalization
of IRESin this paper and include it in a companion report [14].
4.4 Implementation
We implemented Algorithm Compiler by extending the Packrat
parsing [15] library inScala parser combinators. We modified the
meaning of the composition operator ( |) to collect all the longest
matched results. If a parser detects a step that cannot be parsed or
is parsed in multiple ways, it reports the stepwith parsing results.
Compile Rules. Algorithm Compiler requires compile rules to
compile given abstract algorithms to IRESfunctions. As already
explainedinSection2,wefoundcommonpatternsinthewriting
style of abstract algorithms. We manually defined general compile
rules to represent sucha writing style withsix different kinds as
summarized in Table 1. The compile rule for statements, Stmt, gen-
eratesIRESinstructions. The Expr,Cond, andValuecompile rules
generate IRESexpressions, but they represent different contexts
in ECMAScript; Exprrepresents a context where any expression
canappear, Conddenotesacontextwhereanyboolean-valuedex-
pressioncanappear,and Valuerepresentsacontextwhereafully
evaluatedvaluecanappear.The Tycompileruledenotestypenames
andgeneratesstringprimitivesusedinobjectconstructions.The
Refcompile rule represents references such as identifier lookup
and member accesses of objects, and it generates IR ESreferences.
Global Setting. AST-IRESTranslator uses global settings consist-
ingofECMAScriptdatatypes andbuilt-inobjects.Unlikecompile
rules,globalsettingsdependonECMAScriptversions.Inthispaper,
we construct global settings only for the latest ECMAScript, ES10.
653Table 2: Syntax coverage: Number of productions in each
specification and in each update between adjacent versions,
fromallof which JISETautomatically generated parsers
Version ES7 ES8 ES9 ES10 Average
# Lexical productions 78 78 78 81 78.75
# Syntactic productions 157 167 167 174 166.25
Old version ES7 ES8 ES9AverageNew version ES8 ES9 ES10
Δ# Lexical productions 35 6 4.67
Δ# Syntactic productions 140 15 8 54.33
ECMAScript describes data types with some fields and meth-
ods.Whilethemethodsarelikeabstractalgorithms,theirseman-
tics are slightly different from abstract algorithms. They implic-itly get their receiver objects as arguments at callsites. To mimic
suchanimplicitbehavior,weaddedaspecialvariable thisasthe
first parameterof each method,and passed a receiverobject at its
callsitebymodifying AlgorithmCompiler.Forexample,anEnvi-
ronment Record type has the DeleteBinding (N) method. Thus,
its corresponding IRESfunction has two parameters, the special
parameter thisand a normal parameter N, and the method call
in an abstract algorithm is compiled to the
IRESinstruction: (DclRec.DeleteBinding DclRec N) .
InECMAScript,built-inobjectsarepre-definedfunctionswith
several built-in functions. For example, Arrayis the constructor
of array objects, and its prototype Array.prototype has built-in
functions for array objects. For instance, [1,2,3].flat() calls the
Array.prototype.flat built-infunctionwiththearray [1,2,3].Be-
cause built-in functions are also abstract algorithms, each of them
is automatically converted to an IRESfunction. However, the struc-
turesofbuilt-inobjectsshouldbemanuallyimplemented.Thus,we
implementedbuilt-inobjectsinScalaandconnectedtheirproper-
ties with the extracted IRESfunctions. Some built-in objects that
areexplicitlyreferencedinabstractalgorithmsareintrinsicobjects,
which have their own aliased names summarized in Table 75of
Section 6.1.7.4 Well-Known Intrinsic Objects in ES10. We extracted
the alias into Global Setting to utilize it during evaluation.
5 EVALUATION
Wedeveloped JISETasanopen-sourcetool6,andevaluatedthetool
based on the following research questions:
•RQ1.Coverage: How much percentage of the syntax and se-
mantics does JISETautomatically extract from ES7 to ES10?
•RQ2.Correctness: DoesJISETextractanIR-basedformalse-
mantics from ECMAScript correctly?
•RQ3.ForwardCompatibility: IsJISETapplicabletolanguage
features ready for inclusion in the next ECMAScript (ES11)?
Weperformedourexperimentsonamachineequippedwith4.2GHz
Quad-Core Intel Core i7 and 64GB of RAM. On the machine, JISET
took less than one minute to extract IR-based semantics from a
given ECMAScript.
5https://www.ecma-international.org/ecma-262/10.0/#sec-well-known-intrinsic-
objects
6https://github.com/kaist-plrg/jiset
(a) For each ECMAScript version from ES7 to ES10
(b) For each update between adjacent versions
Figure8:Semanticscoverage:Numberofalgorithmstepsinspecifications, from which JISETgenerated the semantics
5.1 Coverage
We evaluated the coverage of JISETin two respects: syntax and se-
mantics.Forsyntax,wemeasuredhowmanygrammarproductions
inspecifications JISETautomaticallygeneratedparsersfrom,and
for semantics, we measured how many abstract algorithm steps in
specificationsit automaticallygenerated theJavaScriptsemantics
from. Because JISETutilizes common patterns in the converged
writingstylesinceES7aswediscussedinSection2,weevaluatedits
coverage using the most recent four versions of ECMAScript, ES7
toES10.WemeasuredthenumbersforeachECMAScriptversion
and for each update between adjacent versions.
For syntax, JISETautomatically generated parsers for allthe
lexical and syntactic productions. As Table 2 shows, the average
numbers of lexical and syntactic productions are 78.75 and 166.25,
respectively.Also,theaveragenumbersofannuallyupdatedlexical
and syntactic productions between adjacent versionsare4.67 and
54.33, respectively.
Forsemantics,Figure8showsthat JISETautomaticallycompiled
algorithmstepstocorresponding IRESinstructionswiththesuccess
rateof95.03%onaverageforeachECMAScriptversionfromES7
to ES10, and 94.31% for each update between adjacent versions.
654Table 3: Specification errors in ES10 and the BigInt proposal ready for inclusion in ES11
Name Feature Description Known Created Resolved Existed # Fails
ES10-1 IterationMissing the async-iterate case in the assertion of
ForIn/OfHeadEvaluationX2018-02-16 2020-03-25 768 days 1,116
ES10-2 ConditionAmbiguous grammar production for the dangling elseproblem in
IfStatementX2015-06-01 TBD TBD 1
ES10-3 String Wrong use of the =operator in StringGetOwnProperty X2015-06-01 2020-05-07 1,802 days 7
ES10-4 Completion Unhandling abrupt completion in Abstract Equality Comparison X2015-06-01 2020-04-28 1,793 days 9
ES10-5 Completion Unhandling abrupt completion in Evaluation ofEqualityExpression O2015-06-01 2019-05-02 1,431 days 2
ES10-6 AwaitPassing a value of wrong type to the second parameter of
PromiseResolveO2019-02-27 2019-04-13 45 days 1,294
ES10-7 Function No semantics of IsFunctionDefinition forfunction(...){...} O2015-10-30 2020-01-18 1,541 days 306
ES10-8 FunctionNo semantics of ExpectedArgumentCount for the base case of
FormalParametersO2016-11-02 2020-02-20 1,205 days 81
ES10-9 IterationTwo semantics of VarScopedDeclarations for
for await(var x of e){...}O2018-02-16 2019-10-11 602 days 0
BigInt-1 ExpressionUsing the wrong variable oldvalue instead of oldValue in
Evaluation ofUpdateExpressionX2019-09-27 2020-04-23 209 days 533
BigInt-2 NumberUsingToInt32 instead of ToUint32 in
Number::unsignedRightShiftX2019-09-27 2020-04-23 209 days 2
BigInt-3 Number Unhandling BigInt values in the Number constructor O2019-09-27 2019-11-19 53 days 1
Table 4: Test results for Test262
All Test262 Tests 35,990
Annexes 1,060
Internationalization 640
In-progress features 5,338
ES10 Tests 28,952
Non-strict mode 1,150
Modules 918
Early errors before actual execution 2,288
Inessential built-in objects 6,532
Applicable Tests 18,064
Passed tests 16,355
Failed tests 1,709
ECMAScriptabstractalgorithmsdescribenotonlycorelanguage
semantics but also built-in libraries with various helper functions.
Notethatbuilt-inlibrariesarewritteninmore diversestylesthan
corelanguagesemanticsduetotheirownspecificfunctionalities.
Therefore, built-in libraries have lower success rates (92.55% for
specificationsand91.50%forupdates)thancorelanguagesemantics
(97.06% for specifications and 97.14% for updates).
BecauseJISETautomatically extractsthe syntaxand semantics
fromspecificationsandupdateswithhighcoveragerates,itreduces
effortsnotonlyindevelopingJavaScripttoolsfromscratchfrom
specifications but also in evolving existing tools for updates.
5.2 Correctness
Toevaluatethecorrectnessof JISET,wetestedtheextractedseman-
tics from the latest ECMAScript (ES10) by executing Test262 as of
February28,2019,whenES10wasbranchedout.Tofocusonthe
corelanguagesemanticsofJavaScript,wecompletedonlynecessary
parts missing from the extracted AST-IR translator. As Figure 8(a)
shows,fortheabstractalgorithmsinES10,9,627stepsoutof10,101stepsareautomaticallycompiledby AlgorithmCompiler.Itfully
covers 1,783 algorithms out of 2,026 abstract algorithms and 243
algorithmsarepartiallycovered.Amongtheremaining474steps,
wemanually implementedallmissingstepsfor thecorelanguage
semantics(137steps)andtheessentialpartsofthebuilt-inlibraries
(140stepsoutof337).Basedonthismanualimplementation,146
moreabstractalgorithmsarefullycovered.Wealsomanuallyim-
plemented Global Setting as described in Section 4.4 for the core
language features. Note that we do not support minor language
features such as the non-strict mode, modules, earlyerrors before
actual execution, and inessential built-in objects. Among 35,990
testsinTest262,wefilteredout17,926testsassummarizedinTable4.
To focus on ES10, we excluded 7,038 tests for annexes, internation-
alization,andin-progressfeatures.Wealsofiltedout10,888tests
thatuseminorlanguagefeatures.Finally,theextractedsemantics
tookaboutthreehourstoevaluate18,064applicabletestsandfailed
for 1,709 tests.
We investigated the failed tests and found out that they failed
due to specification errors in ES10. Using the failed tests, we dis-
covered nine errors: ES10-1 to ES10-9 in Table 3. Among them, fiveerrors (ES10-5 to ES10-9) were previously reported and fixed in thecurrentdraftofthenextECMAScript,andtheremainingfourerrors
(ES10-1toES10-4)wereneverreportedbefore.Allfourerrorswere
confirmedbyTC39,andwillbefixedinthenextECMAScript,ES11.
ThespecificationerrorES10-1isduetoawrongassertion.While
ES9 introduced the for await iteration statement with a new iter-
ationKind tag,async-iterate , theForIn/OfHeadEvaluation algo-
rithmmissedthe async-iterate caseinanassertion,whichcaused
1,120testsfailed.Wereportedtheerrorandproposedaspecifica-
tion fix to include the async-iterate case, and TC39 accepted it
onMarch25,2020.BecausetheerrorwascreatedonFebruary16,
2018, it existed for 768 days.
ES10-2comesfromthewell-knowndangling elseproblemintro-
ducedinALGOL60[ 11].ES10describeshowtoparseitinprose:the
elsestatement should be associated with the nearest ifstatement.
655Table 5: Proposals that will be included in ES11
ProposalΔ#P r od .Δ#Steps Δ#Tests # TestsLex. Syn.
matchAll ofString 0 0 9/9 5/5 18,064/18,064
import() 0 2 38/38 0/0 18,064/18,064
BigInt 4 0 298/326 196/207 17,539/18,064
Promise.allSettled 0 0 79/85 50/50 18,064/18,064
globalThis 0 0 1/1 1/1 18,064/18,064
for-inmechanics 0 0 36/37 0/0 18,064/18,064
Optional Chaining 3 3 74/74 19/19 18,064/18,064
Nullish Coalescing Op. 1 4 10/10 21/21 18,064/18,064
import.meta 0 2 15/15 0/0 18,064/18,064
Total 8 11 560/595
Because it is written in prose rather than in the ES10 grammar
productions,itcausedonefailedtest.Weproposedafixtorevise
the ambiguous grammar production, and TC39 confirmed it on
April 23, 2020.
ES10-3 is due to a misuse of the =operator for numbers. In
abstract algorithms, “x =y” denotes equality testing for double-
precision64-bitbinaryformatIEEE754-2008values;thus, “+0 = -0”
evaluatestotrue.However,tocheckwhether indexisexactlythe
samewith-0, StringGetOwnProperty used“index= -0”,whichis
trueevenwhen indexis+0.Itcausedsevenfailedtests.Weproposed
afix acceptedonMay 7,2020.Thus, ES10-3existedfor 1,802days.
ES10-4andES10-5happenedbecauseES10didnothandleabrupt
completion from function calls. Our proposed fix to ES10-4 was
acceptedonApril28,2020,andES10-5wasresolvedonMay2,2019
after existing for 1,431 days.
ES10-6isduetoincorrectusesofanabstractalgorithm.While
PromiseResolve(C, x) expectsa JavaScript objectfor its second
argument,ES10passedalistofvaluesratherthananobjectinthree
invocationsof PromiseResolve .Thewronginvocationswerein-
troducedon February 27,2019and caused1,294testsfailed. They
were fixed on April 13, 2019 after existing 45 days.
ES10-7andES10-8happenedbecauseES10missedsemanticsfor
some cases. They both existed for more than 1,200 days.
ES10-9 is due to multiple semantics. While no tests in Test262
failwithanyofthesemantics,wecoulddetectthiserrorvia Spec
Extractor even before executing the semantics. It is supplementary
merit of the mechanization of IR-based semantics extraction.
AfterresolvingtheninespecificationerrorsinES10,weextracted
asemanticsfromtherevisedspecification.Theextractedsemantics
from the revised ES10 passed all 18,064 applicable tests in Test262,
whichshowsthat JISETextractsanIR-basedformalsemanticsfrom
ECMAScript correctly. In addition, the evaluation witnesses that
JISETcan detect specification errors effectively. We could detect
notonlyfivepreviously-knownerrorsbutalsofournewerrors.We
believethat JISETbridgesgapsbetweenECMAScriptwrittenina
natural language and executable tests in Test262.
5.3 Forward Compatibility
We evaluatedwhether JISETisforward compatibleby applyingit
to the proposals ready for inclusion in ES11. Because ECMAScript
isanopen-sourceproject,variousproposalsfornewfeaturesare
availablewiththeirownspecificationchangesandtests.Aseparate
repository [ 4] maintains them in six stages: Stage 0 to Stage 3,Finished,andInactive.AproposalstartswithStage0,andtheTC39
committeeexaminesproposalsinStage3.Ifaproposalisconfirmed,
thecommitteechangesitsstagetoFinishedandintegratesitinto
the next ECMAScript. Otherwise, its stage becomes Inactive.
We applied JISETto all nine Finished proposals as shown in
Table 5. Collectively, the proposals modified eight lexical and 11
syntacticproductions,and JISETsuccessfullysynthesizedparsers
for them.The synthesized parsersparse allapplicable tests forall
proposals.Forabstractalgorithms,560stepsoutof595areautomat-
icallyconvertedtocorresponding IRESinstructionsby Algorithm
Compiler without changing Compile Rules. Thus, JISEThas the
success rate of 94.12% on average for forthcoming proposals.
Wecheckedtheextractedsemanticsfromtheproposalsbyim-
plementedmissingpartsoftheAST-IRtranslatorforeachproposal
and checking the semantics with Test262. All of them passed all
applicabletestsexceptthesemanticsfromthe BigIntproposal.It
failedfor11testsoutof207applicabletestsfortheproposaland
525 tests out of 18,064 applicable tests for ES10.
Usingthefailedtests,wediscoveredthreeerrorsintheBigInt
proposal:twonewerrors(BigInt-1andBigInt-2)andoneknownerror (BigInt-3) as summarized in Table 3. All of them were con-firmed by TC39 and will be fixed in ES11. The proposal addedtwo new types: BigInt as a new type of primitives and Numeric
asaunifiedtypeoftheoriginalNumbertypeandthenewBigInt
type. Therefore, it not only added new algorithms for BigInt but
also modified all existing algorithms for Number values. The error
BigInt-1 is due to a misuse of the variable oldValue inEvaluation
ofUpdateExpression.BigInt-2breaksthebackwardcompatibilitybe-
cause of misusing ToInt32 instead of ToUint32 in unsigned right
shiftoperators.BigInt-3isduetomissingBigIntprimitivesinthe
Number constructor. On average, three errors existed for 157 days
in the proposal.
After fixing the errors in the proposal, we extracted a semantics
fromtherevisedspecification.Theextractedsemanticspassedall
207 applicable tests for the proposal and 18,064 applicable tests
for ES10. Thus, JISETalso correctly extracts an IR-based semantics
fromfutureproposals,whichimpliesthatitisforwardcompatible.
6 RELATED WORK
Ourtechniqueiscloselyrelatedtothreefields:parsergeneration,
automaticsemanticsextraction,andformalsemanticsofJavaScript.
ParserGeneration: FromPackratparsing[ 15]withPEG[ 16],
recursive-descent parsers with backtracking support linear-time
parsing.However,ithasthefundamentalproblemoforderedchoices:
abissilentlyunmatchedwith a/ab.WhileGeneralizedLL(GLL)
parsing[28]isbasicallyrecursive-descentwithbacktrackingthat
cansupportgeneralcontext-freegrammarseveninthepresenceof ambiguous grammars, its worst-time complexity is
O(n3)for
the input size nand it does not support context-sensitive fea-
tures. Unlike GLL parsing, our lookahead parsing is applicable
for JavaScript parsers with context sensitive features such as posi-
tive/negativelookaheads.Moreover,thecomplexityoflookahead
parsing is O(k·n)for the constant number of tokens k. We experi-
mentallyshowedthatitcangenerateparsersforthemostrecent
four versions of ECMAScript.
656AutomaticSemanticsExtraction: Theclosestworktooursis
theformalsemanticsextractionforx86[ 22]andARM[ 31].They
utilized complex Natural Language Processing (NLP) and Machine
Learning (ML) to extract formal semantics of small-sized low-level
assemblylanguages.AnotherrelatedworkisZhaietal .[33]’sauto-
maticmodelgeneration,whichgeneratesJavacodefromJavadoc
commentsforAPIfunctions.UsingNLPtechniquesandheuristic
methods,itproducescandidatecodeandremoveswrongonesby
testing them with actual implementation. Unlike their approach,
we introduce a semi-automatic synthesis using general compile
rulesthatrepresentcommonwritingpatternsofspecifications.The
extracted semantics by JISETis also executable, which allows to
bridgegapsbetweenthespecificationwritteninanaturallanguage
and executable tests.
SeveralapproachesdefinedtheformalsemanticsofJavaScript.
Guha et al . [18]defined a core calculus of JavaScript expressing
non-corefeaturesusingdesugaring,butitscorrespondencewithECMAScriptisnotobvious.KJS[
25]andJaVerT[ 17]definedthe
JavaScript semantics by manually converting ECMAScript to their
own formal languages. KJS mapped ES5.1 in the K framework [ 27]
and JaVerT converts the specification to their own IR. However,they all target only ES5.1 or former and they do not provide any
solutionforannualupdatesofECMAScript.Ourapproachprovides
amechanizedframeworktosynthesizeJavaScriptparsersandtoautomatically extract semantics using a rule-based compilation
technique, which significantly reduces human efforts.
7 CONCLUSION
Annual updatesof ECMAScript makeit difficult to buildprogram
analysis or formal verification of JavaScript due to the required hu-
maneffortsinmodelingamovingtarget.Inthispaper,weproposed
JISET,atoolthat automatically extractsthesyntaxandsemantics
as a parser and anAST-IRtranslator from ECMAScript written in
English.Thetoolautomaticallyextractsallthesyntaxand95.03%
ofthe semanticsforthemost recentfourversionsof ECMAScript
(ES7toES10).Weevaluatedthecorrectnessofthetoolbytesting
theextractedsemanticsfromES10withTest262,theofficialconfor-
mancesuite.Using1,709failedtests,wefoundninespecification
errors, four of which are newly discovered, confirmed by TC39,and planned to be integrated in ES11. After fixing the errors, the
extractedsemanticspassedall18,064applicabletestsinTest262.Wealsoshowedthat
JISETisforwardcompatiblebyapplyingittonine
proposalstobeincludedinES11,whichletusfindthreeerrorsin
the BigInt proposal. We believe that JISETcan dramatically reduce
human efforts in building various JavaScript tools correctly.
ACKNOWLEDGEMENTS
ThisworkwassupportedbyNationalResearchFoundationofKorea
(NRF) (Grants NRF-2017R1A2B3012020 and 2017M3C4A7068177).
REFERENCES
[1]2011.StandardECMA-2625.1EditionECMAScriptLanguageSpecification.(2011).
Retrieved May 8, 2020 from https://ecma-international.org/ecma-262/5.1/
[2]2015. Standard ECMA-262 6th Edition ECMAScript 2015 Language Specification.
(2015). Retrieved May 8, 2020 from https://ecma-international.org/ecma-262/6.0/
[3]2019. Espruino-JavaScriptforMicrocontrollers. (2019). RetrievedMay8,2020
from https://www.espruino.com/[4]2019. GitHub repository for ECMAScript proposals. (2019). Retrieved May 8,
2020 from https://github.com/tc39/proposals
[5]2019. MEAN.JS-Open-SourceFull-StackSolutionforMEANApplications. (2019).
Retrieved May 8, 2020 from https://meanjs.org/
[6]2019. Node.js - A JavaScript runtime built on Chrome’s V8 JavaScript engine.
(2019). Retrieved May 8, 2020 from https://nodejs.org/
[7]2019. StandardECMA-26210thEditionECMAScript2019LanguageSpecification.
(2019).RetrievedMay8,2020fromhttps://ecma-international.org/ecma-262/10.0/
[8]2019. TC39 – ECMAScript. (2019). Retrieved May 8, 2020 from https://www.
ecma-international.org/memento/tc39-m.htm
[9]2019.Tessel2isarobustIoTandroboticsdevelopmentplatform.(2019).Retrieved
May 8, 2020 from https://tessel.io/
[10]2019. Test262: ECMAScript Test Suite. (2019). Retrieved May 8, 2020 from
https://github.com/tc39/test262
[11]Paul W Abrahams. 1966. A final solution to the dangling else of ALGOL 60 and
related languages. Commun. ACM 9, 9 (1966), 679–682.
[12]MoorsAdriann,PiessensFrank, andMartinOdersky.2008. ParserCombinators
in Scala. Technical Report. K.U.Leuven, Leuven, Belgium, Technical Report.
http://www.cs.kuleuven.be/publicaties/rapporten/cw/CW491.pdf
[13]AlfredVAhoandJeffreyDUllman.1973. ThetheoryofParsing. Translationand
Compiling 1, 1972 (1973).
[14]Seungmin An,Jihyeok Park,and Sukyoung Ryu.2020. IRES: IntermediateRepre-
sentationforECMAScriptSpecifications. TechnicalReport. https://drive.google.
com/file/d/1chmyQullDPkSfoHk5PvO3r0yDHOQiAcj
[15]BryanFord.2002. PackratParsing::Simple,Powerful,Lazy,LinearTime,Func-
tional Pearl. In In Proceedings of the Seventh ACM SIGPLAN International Con-
ference on Functional Programming (ICFP ’02). ACM, New York, NY, USA, 36–47.
https://doi.org/10.1145/581478.581483
[16]Bryan Ford. 2004. Parsing Expression Grammars: A Recognition-based Syntactic
Foundation. In In Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium
onPrinciplesofProgrammingLanguages(POPL’04).ACM,NewYork,NY,USA,
111–122. https://doi.org/10.1145/964001.964011
[17]JoséFragosoSantos,PetarMaksimović,DaivaNaudži ¯unien˙e,ThomasWood,and
Philippa Gardner. 2017. JaVerT: JavaScript Verification Toolchain. Proc. ACM
Program. Lang. 2, POPL, Article 50(Dec.2017), 33 pages. https://doi.org/10.1145/
3158138
[18]Arjun Guha, Claudiu Saftoiu, and Shriram Krishnamurthi. 2010. The Essence of
Javascript.In InProceedingsofthe24thEuropeanConferenceonObject-oriented
Programming (ECOOP’10). Springer-Verlag, Berlin,Heidelberg, 126–150. http:
//dl.acm.org/citation.cfm?id=1883978.1883988
[19]SimonHolmJensen,AndersMøller,andPeterThiemann.2009. TypeAnalysis
forJavaScript.In InProceedingsoftheInternationalSymposiumonStaticAnalysis.
238–255.
[20]VineethKashyap, KyleDewey, EthanA.Kuefner,John Wagner,Kevin Gibbons,
John Sarracino, Ben Wiedermann, and Ben Hardekopf. 2014. JSAI: A Static
AnalysisPlatformforJavaScript.In InProceedingsoftheInternationalSymposium
on Foundations of Software Engineering. 121–132.
[21]Sergio Maffeis, John C. Mitchell, and Ankur Taly. 2008. An Operational Seman-
tics for JavaScript. In In Proceedings of the Asian Symposium on Programming
Languages and Systems (APLAS ’08). 307–325.
[22]HLYNguyen.2018. Automaticextractionofx86formalsemanticsfromitsnatural
language description. Information Science (2018).
[23]Changhee Park and Sukyoung Ryu. 2015. Scalable and Precise Static Analysis of
JavaScript Applicationsvia Loop-Sensitivity.In In Proceedingsof 29thEuropean
Conference on Object-Oriented Programming (ECOOP 2015) (Leibniz International
Proceedings in Informatics (LIPIcs)), John Tang Boyland (Ed.), Vol. 37. Schloss
Dagstuhl–Leibniz-Zentrum fuer Informatik, Dagstuhl, Germany, 735–756. https:
//doi.org/10.4230/LIPIcs.ECOOP.2015.735
[24]Daejun Park. 2015. KJS: A Complete Formal Semantics of JavaScript
(Slides). (2015). Retrieved May 8, 2020 from https://daejunpark.github.io/
2015-06-16-park-stefanescu-rosu-PLDI.pdf
[25]DaejunPark,AndreiStefănescu,andGrigoreRoşu.2015. KJS:ACompleteFormal
SemanticsofJavaScript. In InProceedingsof the36thACMSIGPLANConference
on Programming Language Design and Implementation (PLDI ’15). ACM, New
York, NY, USA, 346–356. https://doi.org/10.1145/2737924.2737991
[26]TerenceParr,SamHarwell,andKathleenFisher.2014. AdaptiveLL(*)parsing:
thepowerofdynamicanalysis.In InProceedingsofthe2014ACMInternational
ConferenceonObjectOrientedProgrammingSystemsLanguages&Applications
(OOPSLA ’14). ACM, 579–598. https://doi.org/10.1145/2660193.2660202
[27]Grigore Roşu and Traian Florin Şerb ˇanuţˇa. 2010. An overview of the K semantic
framework. TheJournalofLogicandAlgebraicProgramming 79,6(Aug.2010),
397–434.
[28]ElizabethScottandAdrianJohnstone.2010. GLLParsing.In ElectronicNotesin
Theoretical Computer Science. https://doi.org/10.1016/j.entcs.2010.08.041
[29]ManuSridharan,JulianDolby,SatishChandra,MaxSchäfer,andFrankTip.2012.
CorrelationTrackingforPoints-toAnalysisofJavaScript.In InProceedingsofthe
European Conference on Object-Oriented Programming.
657[30]MasaruTomita.1985. AnEfficientContext-FreeParsingAlgorithmforNatural
Languages.. In IJCAI, Vol. 2. 756–764.
[31]Anh V Vu and Mizuhito Ogawa. 2019. Formal semantics extraction from natural
language specifications for ARM. In International Symposium on Formal Methods.
Springer, 465–483.
[32]Alessandro Warth, James R. Douglass, and Todd Millstein. 2008. Packrat Parsers
Can Support Left Recursion. In In Proceedings of the 2008 ACM SIGPLAN Sympo-
siumonPartialEvaluationandSemantics-basedProgramManipulation(PEPM’08) .
ACM, New York, NY, USA, 103–110. https://doi.org/10.1145/1328408.1328424
[33]JuanZhai,JianjunHuang,ShiqingMa,XiangyuZhang,LinTan,JianhuaZhao,
and Feng Qin. 2016. Automatic Model Generation from Documentation for
Java API Functions. In In Proceedings of the 38th International Conference on
Software Engineering (ICSE ’16). ACM, New York, NY, USA, 380–391. https:
//doi.org/10.1145/2884781.2884881
658