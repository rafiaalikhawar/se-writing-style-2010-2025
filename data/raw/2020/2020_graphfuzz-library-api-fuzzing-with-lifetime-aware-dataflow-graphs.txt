GraphFuzz: Library API Fuzzing with Lifetime-aware Dataflow
Graphs
Harrison Green
hgarrereyn@forallsecure.com
ForAllSecure
U.S.A.Thanassis Avgerinos
thanassis@forallsecure.com
ForAllSecure
U.S.A.
ABSTRACT
We present the design and implementation of GraphFuzz, a new
structure-, coverage- and object lifetime-aware fuzzer capable of
automatically testing low-level Library APIs. Unlike other fuzzers,
GraphFuzzmodelssequencesofexecutedfunctionsasadataflow
graph,thusenablingittoperform graph-basedmutations bothat
thedataand at the execution trace level. GraphFuzz comes with
an automated specification generator to minimize the developer
integration effort.
WeuseGraphFuzztoanalyzeSkiaâ€”therigorouslytestedGoogle
Chrome graphics libraryâ€”and benchmark GraphFuzz-generated
fuzzingharnessesagainsthand-optimized,painstakinglywritten
libFuzzerharnesses.WefindthatGraphFuzzgeneratestestcases
that achieve 2-3x more code coverage on average with minimal
development effort, and also uncovered previous unknown defects
intheprocess.WedemonstrateGraphFuzzâ€™sapplicabilityonlow-
levelAPIsbyanalyzingfouradditionalopen-sourcelibrariesand
findingdozensofpreviouslyunknowndefects.Allsecurityrelevant
findings have already been reported and fixed by the developers.
Last, we open-source GraphFuzz under a permissive license and
provide code to reproduce all results in this paper.
ACM Reference Format:
Harrison Green and Thanassis Avgerinos. 2022. GraphFuzz: Library API
Fuzzing with Lifetime-aware Dataflow Graphs. In 44th International Confer-
enceonSoftwareEngineering(ICSEâ€™22),May21â€“29,2022,Pittsburgh,PA,USA.
ACM,NewYork,NY,USA,12pages.https://doi.org/10.1145/3510003.3510228
1 INTRODUCTION
Fuzzinghasbecomethede-factostandardforidentifyingnewsecu-
rityvulnerabilitiesandensuringsoftwarereliability.Fromcommon
opensourcelibrariestobrowsercomponenttesting[ 1]andfrom
safetycriticalsystemstoautomotiveandaerospacestandards[ 2],
the entire industry is adopting fuzzing and finding thousands of
critical issues before they occur in production.
The constantly increasing need for better automated testing has
led to the development of a taxonomy of fuzzer types. Coverage-
guided(grey-box) fuzzers such as libFuzzer [ 3] have gained sig-
nificantadoptionandvisibilitywithin theindustry.Thesefuzzers
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510228consume feedback information from the target (edge coverage,
valuecoverage,orsimilar)toguidetestcaseselectionandmutation.
Coverage guided fuzzing is an optimization problem : the goal is to
discoveracorpusoftestcasesthatmaximizescoverageforatarget.
Intuitively, maximizing coverage leads to edge cases, erroneous
behavior, and/or security vulnerabilities.
At the same time, the art of model-based (or structure-aware)
fuzzingisgrowingrapidlyasitofferstwosignificantbenefits.First,
it enables fuzzing targets which expect complex, structured inputs.
At the simplest level, a model-based fuzzer may simply unpack or
post-process the input byte string. For example, the LLVM project
[4]provides FuzzedDataProvider.h (FDP):autilityheaderfilethat
splits a single fuzzer input into multiple smaller inputs. More com-
plexmodel-basedfuzzers,suchaslibprotobuf-mutator(LPM)[ 5],
use custom generators and mutators to fuzz structured objects like
Protocol Buffers.
Second, model-based fuzzers realize efficiency improvements
overanalogousunstructuredfuzzersbyavoidingbadinputs.Tar-
getsthatvalidatetheirinputbeforeproceeding(i.e.throughtheuse
of checksums) are effectively un-fuzzable without manual counter-
measuressuchasdisablingvalidationatfuzz-time.Unstructured
fuzzers simply get stuck trying to brute force input after input.
Model-based fuzzers bypass this problem entirely by programmati-
cally synthesizing valid test cases. For example, a checksum-aware
fuzzer needs only to computeandsetthe correct checksum for a
given input.
Despitetherecentsurgeinfuzzingresearch,thereisanoticeable
lack of systems capable of fuzz-testing C/C++ libraries. Existing
grey-boxfuzzerssuchaslibFuzzer[ 3]areparticularlywellsuited
forfuzzingoneortwoendpointsatatimebutrequiremanualeffort
(using FDP for example) to scale to multiple endpoints at once.
CSmith [6] can synthesize realistic C code, but recompiling at each
iteration is expensive when the target is a C libraryand not the C
compiler. FUDGE [ 7] is a promising meta-fuzzing technique that
automatically generates harnesses by analyzingand slicinga seed
corpusofclient-sidecode;however,itreliesonGoogleâ€™sinternal
infrastructure and is not open source.
Toaddressthisgap,weintroducetheconceptofdataflowgraph-
based fuzzing in which a Library API interaction is represented as
a dataflow graph. We describe algorithms for dataflow graph muta-
tion,generationandexecutioninthecontextofC/C++libraries.We
open-source our implementation of dataflow graph-based fuzzing
calledGraphFuzzunderapermissivelicenseandwedemonstrate
its effectiveness by finding bugs in real-world targets and quan-titatively benchmarking its performance against state-of-the-art
10702022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Harrison Green and Thanassis Avgerinos
harnessesintheSkiaGraphicsLibrary.Additionally,webrieflysur-
vey the field of model-based API fuzzersto compare recent works
and understand the benefits and drawbacks of various systems.
Overall, GraphFuzz makes the following contributions:
1) Model-based API Fuzzer Survey. We present a taxonomy
for model-based fuzzers developed until today and show where
GraphFuzz fits within the design space.
2)Dataflowgraph-basedfuzzing. Weformallydefinedataflow
graph-basedfuzzingandintroducealgorithmsforperforminggraph
mutation and generation in the context of coverage-aware fuzzing.
3) GraphFuzz for C/C++. We introduce our open-source im-
plementation of dataflow graph-based fuzzing called GraphFuzzthat is capable of semi-automatically fuzz-testing C and C++ li-
braries. We validate this technique by finding real world bugs and
quantitatively benchmarking its performance against current state-
of-the-art harnesses.
Section 2 provides a taxonomy for model-based API fuzzers and
describeshowGraphFuzzfitsintothedesignspace.Weformally
definetheconceptofdataflowgraph-basedfuzzinginSection3and
inSection4,wedescribeouropen-sourceimplementationcalled
GraphFuzz. Section 5evaluates GraphFuzzon real-world targets.
We discuss limitations in Section 6 and the paper concludes in
Section 7.
2 MODEL-BASED FUZZING
Model-basedfuzzers(sometimescalledstructure-awareorgrammar-
based) use a modelto inform test-case generation and mutation.
The model constrains generated test cases and the search space of
the fuzzer. When used correctly, models enable fuzzers to generate
interesting inputs more efficiently than an unstructured fuzzer.
2.1 Model Domain
Model-based fuzzers specify (often implicitly) a model domain (D)
thatdescribesthespaceofpossiblefuzzertestcases.Thisdomain
describestheinternal structure ofeachtestcaseandthereforere-
stricts the typesof mutations possible and theways in which test
cases can be invoked in a target.
As a baseline example, unstructured fuzzers use a bytesdomain,
i.e., each test case is a byte sequence and fuzzers can apply byte-
levelmutations such as swapping bytes, inserting substrings or
mutating bytes. Libprotobuf-mutator (LPM) [ 5], an example of a
differentmodel-basedfuzzer,representstestcasesinternallyasa
tree(a Protocol Buffer object) and therefore uses a treedomain.
Using custom mutators, LPM performs tree-level mutations such as
adding or removing leaves and rearranging subtrees.
We identify four broad classes of model domains as follows:
(1)bytes:Domainsthatconsistofrawbytesequences.(i.e.all
unstructured fuzzers use this domain)
(2)tree: Domains that are tree-like. These inputs typically rep-
resentanabstractsyntaxtreeandaregeneratedwithagram-
mar such as a context-free grammar.
(3)sequence :Domainsthatconsistofalistofitems.Eachitem
in the list can contain additional metadata.
(4)graph:Domainsthatconsistofverticesandedges.Wede-
scribethefirstimplementationofgraph-baseddomainsin
this work.2.2 Anatomy of a Model-based Fuzzer
Model-based fuzzers consist of the following four functions which
operate on their respective model domains:
(1)Generation:seed â†’D
(2)Mutation: DÃ—seedâ†’D
(3)Crossover: DÃ—DÃ— seedâ†’D
(4)Invocation: Dâ†’feedback
Theseedenablespseudo-random,yetdeterministicbehavior.The
feedbackmetric always consists of at least a binary bugsignal (did
the target crash or not?) and typically contains more fine-grained
data such as specific AddressSanitizer [8] issues or code coverage.
Generation-based fuzzers use only the Generation function to
synthesize new test cases. These fuzzers are most applicable in
black-boxenvironmentswherenocoverageinformationisavailable
orwhenitistoocomplicatedtodefinea Mutation operation.For
example jsfunfuzz [ 9] and CSmith [ 6] use hand-crafted rules to
generate realistic JavaScript and C code respectively.
In grey-box environments, mutation is necessary to reap the
benefits of coverage feedback. Mutation-based fuzzers define the
Mutation and/orCrossover operatorstosynthesizenewtestcases
by mutating and mixing existing cases from a corpus. Mutation-
basedfuzzerssuchaslibFuzzer[ 3]havedemonstratedsubstantial
efficiencyimprovementsoverpurelygeneration-basedfuzzers.Cov-eragefeedbackhasalsobeenemployedwithsuccessinmodel-based
fuzzers such as Nautilus [ 10], a script language fuzzer, and Pythia
[11], a REST API fuzzer.
2.3 API Fuzzing Methods
Most real-world targets contain more than one endpoint:
â€¢a web application provides HTTP endpoints
â€¢a kernel provides system calls
â€¢a C++ library provides public functions
Fuzzingindividual endpointsatatimeisnotsufficienttodiscover
every bug in a target. Some erroneous behavior only arises from
the interaction of multipleendpoints. API fuzzers attempt to solve
this problem of fuzzing many endpoints at once.
While modern techniques are varied, we identify four broad
methodsofAPIfuzzingandusethemtocategorize APIfuzzersat
a high level:
Method 1: Harness. A standard grey-box harness can be configured
toactasanAPIfuzzerthroughmanualeffort.Forexample,adevel-opercanfuzz-testaC++librarybyprocedurallyinvokingfunctions
inside a for-loop and/or switch statement. Typically, a raw bytesequence from an unstructured fuzzer is used to initialize thesepseudo-random values. For example, in the FuzzedDataProvider
(FDP)approach,thefuzzerbytesequenceisinterpretedasa byte
streamand values are pulled from this stream to initialize variables
insidetheharness.Similarly,onecanuse libProtobuf-mutator (LPM)
[5] in conjunction with a coverage-guided fuzzer such as libFuzzer
[3]tobuildatree-basedAPIfuzzer.Forexample,inChromiumâ€™s
AppCache fuzzer [ 12], the Protocol Buffer instance represents a
sequence of IPC calls.
Method 2: Code-gen. Some API fuzzers synthesize and execute pro-
gramsourcecode.Thisapproachismostfeasibleforscript-based
1071
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. GraphFuzz: Library API Fuzzing with Lifetime-aware Dataflow Graphs ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
languages such as JavaScript and Ruby which do not require an ex-
pensive compilation step before execution, however this approach
has also been used to fuzz-test C compilers [6].
Whilethesefuzzerscangeneraterealisticsyntaxpatternsthrough
the use of context-free grammars or similar models, they often fail
to produce high-level, semantically meaningful code. For exam-
ple,Hanet.al[ 13]notedthat99%ofthetestcasesfromjsfunfuzz
[9],apopularJavaScriptfuzzer,raisearuntimeerrorafteronly3
statements.
Method 3: Harness-gen. Rather than building harnesses by hand,
it isalso possibleto createsystems thatgenerate harnessesauto-
matically or with little manual effort. For example, IMF [ 14] traces
syscalllogstoidentifydependenciesandsynthesizesCharnesses
thatcanfuzz-testthesesyscalls.Similarly,FUDGE[ 7]andFuzzGen
[15]analyzealargecode-baseofclient-sideC/C++codeandextract
slicesofcodetocreatefuzzerharnesses.Whilethesesystemscan
generatevariedharnesses,theAPIinvocationstructurewithina
single harness is staticat fuzz-time and only the values change.
Method 4: Dynamic. In thedynamicapproach to API fuzzing, each
test case represents a full API interaction sequence. The fuzzer
enginedynamicallyprocesseseachtestcase,invokingendpoints
one-by-one.Forexample,inRESTlerandPythia,eachtestcaseis
essentially a listof HTTP requests. The key distinction between
dynamic andharness-gen approaches is that in a dynamic fuzzer,
thestructureofAPIinteractionsisspecifiedatfuzz-time(aspart
of the test case) which allows the fuzzer to control both the values
andstructure ofAPIcalls.While code-genfuzzerscanalsochange
the structure of API calls at fuzz-time through recompilation (e.g.
CSmith[6]),dynamicfuzzerssuchasSyzkaller[ 16]andGraphFuzz
(this work) bypass this expensive recompilation step.
2.4 Recent Model-based API Fuzzers
Manes et al [ 17] have extensively surveyed the current field of
fuzzing. In this work, we focus specifically on model-based API
fuzzersandnarrowdownourcriteriaandcategorizationtoprovide
a detailed comparison. In Table 1, we survey a collection of recent
model-based API fuzzers and compare various features (explained
below). The table is primarily organized by the methodof API
fuzzing (as described in Section 2.3).
2.4.1 Fuzzer Features. Foreachfuzzerwelisttheprimarytarget
type,themodeldomain D(asdescribedinSection2.1)andthetype
of model used to generate and mutate inputs.
2.4.2 Mutation Engine. In the first column group, we compare
the method of generating and exploring inputs. For each fuzzer,
we list whether it supports generation, mutation, crossover and
collecting coverage information. Generation-based fuzzers such as
jsfunfuzz[ 9]andCSmith[ 6]implementonlythe generation function
while mutation-basedfuzzers alsoimplement the mutation and/or
crossover functions. In addition, some fuzzers such as Nautilus
[10]andGraphFuzz(thiswork)supportgrey-box,coverage-guided
fuzzing, using feedback from the target program to guide test case
selection and mutation.
2.4.3 API Conformity. For the purposes of API fuzzing it is useful
tocomparesyntacticandsemanticfeaturestounderstandhowwellthe fuzzer conforms to a target API specification. In the second
column group we compare the fuzzers based on three constraint
attributes:
â€¢Syntax: The fuzzer produces inputs that conform to lan-
guage syntax rules.
â€¢Endpoint Dependencies : The fuzzer produces inputs that
ensure endpoints with dependencies are invoked after their
dependents.
â€¢Object Lifetimes : The fuzzer manages object lifetimes and
invokes explicit constructors and destructors.
Fuzzers that conform to syntax rules alone will primarily target
theparsingorcompilationstageofthetarget.Thesefuzzersmay
becapableofgeneratingsemanticallymeaningfulinputsbutitis
notguaranteed,andalargepercentageoffuzz-timewillbespent
on inputs that are rejected. This level of fuzzing is most-applicable
forscript-basedlanguagesthattargetinterpreterssuchasjsfunfuzz
[9], LangFuzz [18], IFuzzer [19] and Nautilus [10].
Fuzzersthatunderstandendpointdependencyrequirementscan
synthesizeinputswhereallendpointargumentsaresatisfied.For
example, CodeAlchemist [ 13] maintains a set of JavaScript code
brickswith explicit inputs and outputs and stitches together inputs
that obey dependency rules. Similarly, RESTler [ 20] understands
RESTAPIdependenciesandinvokesendpointsthat consumespe-
cificparametersonly afterarequesthas beenmadethat generates
that parameter (for example, a POST /foo before aGET /foo).
Fuzzers that are lifetime-aware explicitly manage the lifetime
of objects. This ability enables fuzzers to operate in environments
without automatic memory management and enforce semantic
lifetime constrains such as the use of managed pointers. Addition-
ally, these fuzzers can identify issues such as memory leaks and
use-after-free bugs without false positives.
2.4.4 Applicability. Inthethirdcolumngroup,weidentifywhether
each fuzzer requires an input corpus of seed data (i.e. language
grammarexamples,client-sidecode,APItraces,etc)andwhether
each fuzzer is open-source.
3 DATAFLOW GRAPH-BASED FUZZING
We propose a new technique of dataflow graph-based fuzzing in
which aLibrary API interaction is represented as a dataflow graph.
We develop algorithms to generate and mutate dataflow graphs
according to a schemaand describe how to execute such graphs in
thecontextofC/C++libraries.Theconceptofdataflowgraph-basedfuzzingisnotrestrictedtoC/C++,andwebelievethatfutureworks
will apply this technique to new environments.
Tointroducetheconceptofadataflowgraph,wefirstprovide
an example of a bug found by GraphFuzz in the Skia Graphics
Library.Figure1containsasnippetofC++codethattriggersaheap-
use-after-free in Skia. In this example, the shrinkTofit method
frees memory that is being used by the SkContourMeasureIter
object.InFigure2weshowthe samebug representedasadataflow
graph; in short, functions are vertices and objects are edges. Thekey concept in GraphFuzz is that these two representations areequivalent. We can invoke this test case by either compiling and
running the C++ code in Figure 1 orby dynamically executing the
dataflow graph in Figure 2.
1072
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Harrison Green and Thanassis Avgerinos
Method Fuzzer Target Domain Model GenerationMutationCrossoverCoverageSyntaxEndpoint DepsObject LifetimesWorks w/o SeedsOpen-source
Harness libFuzzer (FDP) Library API bytes Procedural  11
Harness libFuzzer (LPM) Library API tree Protobuf  11
Code-gen jsfunfuzz (2007) [9] JavaScript bytes Procedural   
Code-gen CSmith (2011) [6] C Compilers bytes CFG   
Code-gen LangFuzz (2012) [18] Script Languages tree CFG    
Code-gen Dharma (2015) [21] Data tree CFG   
Code-gen IFuzzer (2016) [19] Script Languages tree CFG   
Code-gen Nautilus (2019) [10] Script Languages tree CFG   
Code-gen CodeAlchemist (2019) [13] JavaScript sequence API Spec   
Harness-gen IMF (2017) [14] Kernels - -    
Harness-gen FUDGE (2019) [7] Library API - -   
Harness-gen FuzzGen (2020) [15] Libary API - -   
Harness-gen RULF (2021) [22] Rust API - -   
Dynamic Syzkaller (2015) [16] Syscalls sequence API Spec    
Dynamic RESTler (2019) [20] REST API sequence API Spec    
Dynamic Pythia (2020) [11] REST API sequence RG   
Dynamic GraphFuzz (2021) Library API graph API Spec   
Table 1: A survey of recent model-based API fuzzers organized by method.1requires manual implementation
1SkPath *path = newSkPath();
2path->moveTo(0, 0);
3SkContourMeasureIter * iter = new
SkContourMeasureIter();
4iter->reset(*path, false);
5path->shrinkToFit();
6delete path;
7iter->next();
8delete iter;
Figure 1: The textual representation of crbug.com/1134261:
aheap-use-after-freeintheSkiaGraphicsLibraryfoundbyGraphFuzz.
Figure 2: The dataflow graph representation of cr-bug.com/1134261 (Figure 1).In this section we formally define the concept and terminol-
ogy of a dataflow graph and we introduce our graph mutation
and completion algorithms. In the following section we introduce
GraphFuzz: an open-source framework for fuzzing C/C++ libraries
with dataflow graphs.
3.1 Library API Specification
Library APIs provide two specifications for developers: Object dec-
larations and Endpoint specifications that consume and produce
the declared Objects.
Definition 3.1 (Object).An object is the abstract specification of
adatatype.Weuse Oğ‘¥todenoteanobjectdomainand Otosignify
the domain of all valid objects.Definition 3.2
(Endpoint) .An endpoint takes in a list of input
objectsandreturnsalistofoutputobjects.Forexample,anendpoint
Ewith x inputs and y outputs has a type signature of:
E:O1Ã—O2Ã—Â·Â·Â·Ã—O ğ‘¥â†’O/prime
1Ã—O/prime
2Ã—Â·Â·Â·Ã—O/prime
ğ‘¦
We use the notation E(ğ‘–)to refer to the iâ€™th input object and
E(ğ‘–/prime)to refer to the iâ€™th output object.
Definition 3.3 (Endpoint Driver) .Each endpoint is associated
withanendpointdriverthatspecifiesexactlyhowtoconvertobject
inputsintoobjectoutputs.ForC/C++targets,theendpointdriver
is a small function that is compiled into the harness.Definition 3.4
(Library API) .A Library API defines a list of ğ‘¥
Objectsand ğ‘¦Endpoints: ğ´ğ‘ƒğ¼:O1Ã—O2Ã—Â·Â·Â·Ã—O ğ‘¥Ã—E1Ã—E2Ã—Â·Â·Â·Ã—E ğ‘¦
ForaC/C++API,objectsconsistofstructs,classes,enumsand
primitivetypeswhileendpointsar egenerallymethods. However,
endpoints can be arbitrarily complex snippets of C/C++ code as
described in Section 4.5.
1073
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. GraphFuzz: Library API Fuzzing with Lifetime-aware Dataflow Graphs ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
3.2 Dataflow Graph
Definition3.5 (DataflowGraph) .Thedataflowgraphisastrongly-
typeddirectedacyclicgraph(DAG)thatrepresentsaspecific,de-
terministic interaction pattern between endpoints.
G:(ğ‘‰,ğ¸)
From a fuzzing perspective, each dataflow graph is equivalent to a
traditionalfuzzertestcase.Verticesinthegraphrepresent instances
of endpoints and edges represent object dependencies: objects that
areproducedbyoneendpointandconsumedbyanother.Forexam-
ple,theedge: ğ¸ğ‘–:(ğ‘‰ğ‘,ğ‘‰ğ‘,ğ‘—,ğ‘˜)indicatesthatoutput ğ‘—ofğ‘‰ğ‘becomes
inputğ‘˜ofğ‘‰ğ‘. Dataflow graphs are strongly typed, so this edge is
only valid if the object type is consistent, i.e. E(ğ‘—/prime)
ğ‘=E(ğ‘˜)
ğ‘.
A dataflow graph is validif and only if every vertex has a single
incoming edge for each object input and a single outbound edge
foreachobjectoutput.Additionally,therecanbenodirectedcycles
in the graph.
3.3 Invoking a Dataflow Graph
Each dataflow graph represents a deterministic, fully-formed inter-
actionbetweenendpoints.Toinvokeadataflowgraph,wegenerate
an ordering of the vertices such that endpoints with object depen-
dencies are invoked afterthe endpoints that produce those objects.
Then, we iterate and invoke each endpoint driver in order, passing
objects from one endpoint to the next as necessary.
For example, to execute the dataflow graph in Figure 2, we first
invoke the constructor SkPath() , producing a new SkPathobject.
Thisobjectispassedtothenextendpoint( SkPath::moveTo )which
performsamethodcallontheobject.Wecanâ€™tyetinvoke SkCon-
tourMeasure::reset becausewearemissingadependency,sowe
first invoke SkContourMeasureIter() to produce a new SkCon-
tourMeasureIter object.Onlythencanweinvoke SkContourMea-
sure::reset ,passingboththenewlycreated SkContourMeasureIt-
erobjectandthe SkPathobject.Executioncontinuesinthismanner
until every vertex has been visited. Each vertex in the graph main-
tains a fuzzable indexattribute to break ties in cases where the
ordering is ambiguous.
3.4 Endpoint Context
Forsometargets,itisunwieldytotrackalloftheprimitivevaluesasdiscretenodesinthegraph.Anendpointthatconsumesanarrayofintegersofsize100wouldnaivelyrequire100inboundconnections,
bloating the dataflow graph.
We simplify dataflow graphs by embedding certain objects di-
rectlyintothegraphvertexmetadata.ForC/C++targets,wecon-
sider primitive types such as integers, floats and enums to be short-
lived.Theseobjectsarenottrackedasedgesinthegraphbutrather
their values are embedded directly into a graph vertex.
Specifically,wecoalesceallfixed-size,short-livedobjectsfora
given endpoint into a single context byte string that is stored as
metadatainsideagraphvertex.Atfuzz-time,theseprimitiveobjectsareinitializedbydeserializingthecontextbytestringandprovided
to the corresponding endpoint driver.Definition 3.6 (ContextByteString) .Acontextbytestringcon-
sists of the concatenation of ğ‘§fixed-size, short-lived types:
C=Oâˆ—
1/bardblOâˆ—
2/bardbl.../bardblOâˆ—
ğ‘§
where/bardbldenotesconcatenationoftherawbyterepresentationsof
an objectâ€™s value.
Thecontext size is the number of bytes required to store all
objects, which is simply the sum of each objectâ€™s size:
|C|=ğ‘§/summationdisplay.1
ğ‘˜=1|Oâˆ—
ğ‘˜|
For example, |Oâˆ—
ğ‘˜|is implemented as the sizeofoperator for
C/C++ targets.
Definition3.7 (OptimizedEndpoint) .Anoptimizedendpointcon-
sists ofğ‘¥long-lived inputs, ğ‘¦outputs and ğ‘§short-lived inputs and
has the following type signature:
Eâˆ—:O1Ã—O2Ã—Â·Â·Â·Ã—O ğ‘¥Ã—Câ†’O/prime
1Ã—O/prime
2Ã—Â·Â·Â·Ã—O/prime
ğ‘¦
Eachvertexinthedataflowgraphmaintainsaninstanceofan
endpointâ€™scontextbytestringinadditiontotheendpointreference:
ğ‘‰:EÃ—B|C|,Bâˆˆ{0,1,...,255}
For example, in Figure 2, the short-lived types indicated in blue
(two float inputs and one bool input) are initialized from a context
stringratherthanaseparateendpoint.Theendpoint SkPath::move-
To(float,float) has an 8-byte context string which is deserial-
ized into two 4-byte floats. The endpoint SkContourMeasureIt-
er::reset(SkPath,bool) has a 1-byte context string which is
deserialized to initialize the boolvalue (in this case, only the least-
significant bit of this string is used).
3.5 Fuzzing Dataflow Graphs
The fuzzing process requires the ability to generateandmutate
dataflow graphs. At the surface level, changing the structure of
a dataflow graph (i.e. the vertices and edges) is straightforward.
However,ensuringthateachgraphasawholeisstill validrequires
meeting specific constraints.
If a generated graph is invalid (missing edges or mismatched
edgetypes),graphexecutionwillproducefalsepositiveerrorssuch
as null pointer dereferences or memory leaks. For simplicity, we
split the graph fuzzing problem into two parts, graph mutation and
graph completion :
(1)Mutation (Section3.6):Generateormutateadataflowgraph
to form an incomplete graph G/primewith potential missing
edges.
(2)Completion (Section 3.7): Add vertices and edges as neces-
sary to form a complete, valid graph G.
3.6 Graph Mutations
In this section we list the graph mutations used by GraphFuzz.
Thesespecificmutationsarenotrequiredfordataflowgraph-based
fuzzing,howeverinpractice,wefindthemeffectiveforthetypes
of schemas used in C/C++ libraries. Each mutation acts on a graph
ğºto produce an intermediate (potentially incomplete) graph ğº/prime.
1074
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Harrison Green and Thanassis Avgerinos
Figure 3: GraphFuzz Mutations
Following every mutation, the graph completion algorithm (Sec-
tion 3.7) acts on ğº/primeto produce a valid, fully-formed graph ğºâˆ—.A
graphical representation of these mutations is shown in Figure 3.
3.6.1 Graph Mutations.
(1)SpliceIn:Spliceanewendpointbetweentwoexistingend-
points.Givenanexistingedge (ğ‘‰ğ‘,ğ‘‰ğ‘,ğ‘–,ğ‘—),addanewvertex
ğ‘‰ğ‘˜andreplacetheoldedgewithtwonewedges: (ğ‘‰ğ‘,ğ‘‰ğ‘˜,ğ‘–,âˆ—)
and(ğ‘‰ğ‘˜,ğ‘‰ğ‘,âˆ—,ğ‘—).
(2)SpliceOut : The opposite of the SpliceIn mutation. Given,
a pair of edges (ğ‘‰ğ‘,ğ‘‰ğ‘˜,ğ‘–,âˆ—)and(ğ‘‰ğ‘˜,ğ‘‰ğ‘,âˆ—,ğ‘—)whereE(ğ‘–/prime)=
E(ğ‘—), remove the pair of edges and ğ‘‰ğ‘˜and add a direct edge
fromğ‘‰ğ‘toğ‘‰ğ‘:(ğ‘‰ğ‘,ğ‘‰ğ‘,ğ‘–,ğ‘—).
(3)Crosslink :Sampletwovertices ğ‘‰ğ‘andğ‘‰ğ‘atrandomsuch
thatE(ğ‘—/prime)=E(ğ‘˜)forsome ğ‘—,ğ‘˜.Removetheexistingedges
(ğ‘‰ğ‘,âˆ—,ğ‘—,âˆ—)and(âˆ—,ğ‘‰ğ‘,âˆ—,ğ‘˜),andaddanewinternaledgebe-
tweenğ‘‰ğ‘andğ‘‰ğ‘:(ğ‘‰ğ‘,ğ‘‰ğ‘,ğ‘—,ğ‘˜). If this mutation splits the
graphintomultipledisconnectedparts,keeponlythesub-
graph containing ğ‘‰ğ‘andğ‘‰ğ‘.
(4)Context: Sample a vertex ğ‘‰ğ‘˜with a non-zero sized context
byte string ( |ğ¶ğ‘˜|>0) and invoke libFuzzerâ€™s builtin mutator
(LLVMFuzzerMutate)o n ğ¶ğ‘˜.
(5)Priority: Sample two vertices ğ‘‰ğ‘andğ‘‰ğ‘at the same layer
and swap their vertex indexes, reversing vertex priority dur-
ing graph execution.
(6)Swap: Sample a random vertex ğ‘‰ğ‘and replace it with adif-
ferentendpointofthesamesignature.Bydefinition,thetwo
endpoints are compatiblewith the existing graph structure
so no further structural modification needs to be done.
(7)TruncateDestructor : Sample a vertex ğ‘‰ğ‘˜such that Eğ‘˜=
(Â·Â·Â·â†’Â·Â·Â·Ã—O/prime
ğ‘—Ã—...). Remove the edge (ğ‘‰ğ‘˜,âˆ—,ğ‘—,âˆ—)and ifthis splits the graph into two disconnected parts, keep only
the subgraph with ğ‘‰ğ‘˜.
(8)ExtendDestructor : Sample a vertex ğ‘‰ğ‘˜such that Eğ‘˜=
(O â†’âˆ…).Replacethisvertexwithanewvertex ğ‘‰/prime
ğ‘˜suchthat
Eğ‘˜=(Â·Â·Â·Ã—O ğ‘—Ã—Â·Â·Â·â†’...)andreplacetheedge (âˆ—,ğ‘‰ğ‘˜,âˆ—,0)
with a new edge (âˆ—,ğ‘‰/prime
ğ‘˜,âˆ—,ğ‘—).
(9)TruncateConstructor : Sample a vertex ğ‘‰ğ‘˜such that Eğ‘˜=
(Â·Â·Â·Ã—O ğ‘—Ã—Â·Â·Â·â†’...). Remove the edge (âˆ—,ğ‘‰ğ‘˜,âˆ—,ğ‘—)and if
this splits the graph into two disconnected parts, keep only
the subgraph with ğ‘‰ğ‘˜.
(10)ExtendConstructor : Sample a vertex ğ‘‰ğ‘˜such that Eğ‘˜=
(âˆ… â†’ O/prime). Replace this vertex with a new vertex ğ‘‰/prime
ğ‘˜such
thatEğ‘˜=(Â·Â·Â· â†’ Â·Â·Â· Ã— O/prime
ğ‘—Ã—...)and replace the edge
(ğ‘‰ğ‘˜,âˆ—,0,âˆ—)with a new edge (ğ‘‰/prime
ğ‘˜,âˆ—,ğ‘—,âˆ—).
3.6.2 Graph Crossover. Giventwographs Gğ‘andGğ‘,invokethe
Crosslink mutation on two vertices ğ‘‰ğ‘âˆˆG ğ‘andğ‘‰ğ‘âˆˆG ğ‘.
3.6.3 Graph Generation. Initialize a new graph ğºwith a single,
random endpoint Eand invoke the graph completion algorithm.
3.7 Graph Completion
Wenowintroducethe graphcompletion algorithmthatisusedin
graph generation and mutation to complete a partial graph G/prime.W e
reducethegraphcompletionproblemintoseveralsmallerproblems
of satisfying missing edges in a graph. To this end, we propose the
sub-problem of edge completion:
Definition3.8 (EdgeCompletion) .Givenanobjectoutputoftype
Oâˆ—, the goal is to generate a subgraph Gâˆ—that is valid except for
a single missing input edge of type Oâˆ—. Note that the problem is
symmetricaltothecasewheregivenanobject inputoftypeOâˆ—we
want to generate a subgraph missing the corresponding output.
An incomplete graph G/primecan be completed by invoking the edge
completion algorithmforeverymissinginputandoutputandlinking
the generated subgraphs.
A naive, probabilistic approach to edge completion such as ran-
domlysamplingviableendpointstendstogenerateextremelylarge
graphsorfailstoreturnasolutionatall(insteadthegraphgrows
endlessly).Itispossibletoenforcecertain cutoffrules,suchassam-
plingendpointswithfewerconnectionswithahigherprobability
but such heuristics are graph schema-dependent and we empiri-
callyfound thattheydo notalwayswork.Additionally, theedge
completion algorithm runs several times per mutation, which may
itself run 4 or 5 times per fuzzer iteration; a fast implementation is
critical for fuzzer performance.
OurGraphFuzzimplementationofedgecompletionpre-computes
everypossiblesubgraphforagiventargetobject Oâˆ—byperforming
abreadth-firstsearchofdepth ğ‘˜overthegraphschema.Thesub-
graphsarestoredinanprobability-encodedtreestructure(referred
to as aTypeTree ). At fuzz-time, the edge completion algorithm
can sample subgraphsfor any object type inconstant time. These
pre-computed trees are cached o n disk which speeds u p parallel
fuzzing.Forexample,inlibFuzzer -forkmode,anewlyspawned
thread can instantly retrieve the subgraph solutions.
In GraphFuzz, this pre-computation step also performs schema
validation.Warningsaredisplayedifthereareanyendpointsinthe
1075
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. GraphFuzz: Library API Fuzzing with Lifetime-aware Dataflow Graphs ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
schema which are unreachable orunsatisfiable (i.e. cannot exist in
a valid graph).
3.8 Graph Minimization
Crashing test cases often contain unnecessary cruft that can be
removedtoobtainaminimalreproducer.Althoughsimplistic,we
findthatbyrandomlyinvokingmutationsandretainingonlythose
graphs which exhibit the same crash and are smaller, we obtain
dataflow graphs close to the size of hand-minimized examples.
4 GRAPHFUZZ FOR C/C++
In this section, we describe GraphFuzz: an implementation of data-
flow graph-based fuzzing designed to fuzz-test C and C++ libraries.
Wehavereleasedthisframeworkalongwithdocumentationand
example code under https://github.com/ForAllSecure/GraphFuzz.
4.1 Overview
GraphFuzz consists of two parts:
â€¢libgraphfuzz :AcoreframeworkwritteninC++whichper-
forms dataflow graph mutations andis linked into the fuzz
harness.
â€¢gfuzz: A Python command-line tool used to generate har-
nessesfilesandperformmiscellaneoustaskssuchasgraph
minimization and automatic schema extraction.
4.2 GraphFuzz Schema
The core of a GraphFuzz harness is the schema. A schema is de-
fined in a human-readable YAML file and contains a list of the
API endpoints and object types available in a Library API. Using
the schema, GraphFuzz automatically generates the execandwrite
fuzzer harnesses.
An example, partial schema for the Skia SkPath API is shown
in Figure 4. This harness found a UAF in SkContourMeasureIter
(https://crbug.com/1134261). GraphFuzz understands C and C++
function signatures and often times, this is the only information
needed to define an endpoint.
4.3 Harnessing
Harnessing a target with GraphFuzz requires the following 5 steps,
visualized in Figure 5:
(1)Instrumentation : Compile the target library with fuzzer
coverage. With clangfor example, this just requires adding
the-fsanitize=fuzzer flag.
(2)SchemaInference (optional):Using gfuzz,runtheschema
extractor tooltoautomaticallyextractclasses,structs,enums,
typedefsandmethodsfromlibrarysourcecodeintoaschema.
The generated schema is a starting point for further modifi-
cation.
(3)Manual Revision : Applying an understanding of the Li-
brary API requirements, manually fix up the schema by
adding/removing classes, adding functions or redefining the
input and output types of a function.
(4)Harness Generation : Rungfuzzon the schema to auto-
matically generate two versions of the harness: fuzzExec
executesthedataflowgraphswhile fuzzWrite convertsthe1typedef_SkScalar:
2type: typedef
3name:SkScalar
4value: float
5
6struct_SkPath:
7...
8methods:
9- SkPath()
10-voidmoveTo(SkScalar x, SkScalar y)
11...
12-voidshrinkToFit()
13-voidclose()
14
15struct_SkContourMeasureIter:
16...
17methods:
18- SkContourMeasureIter()
19- SkContourMeasureIter( constSkPath &path,
20 boolforceClosed, SkScalar resScale)
21- sk_sp<SkContourMeasure> next()
22...
Figure 4: A partial GraphFuzz harness for the Skia SkPath
API.Thisharnessincludesfunctionsignaturesformethods
onthe SkPathand SkContourMeasureIter structsinaddition
toSkVector, SkPointand SkContourMeasure (not shown).
Figure5:AnoverviewoftheGraphFuzzharnessingprocess.
dataflow graphs to plain C/C++ source code which can be
recompiled externally.
(5)Compilation/Linking : Link both harness variants to the
target library to produce native libFuzzer executables.
4.4 Endpoint Driver Specification
In GraphFuzz, an endpoint specification is represented with the
following four components:
â€¢inputs: a list of endpoint input types
â€¢outputs: a list of endpoint output types
â€¢args: a list of context-based endpoint input types
â€¢exec: an endpoint driver template (C/C++ code)
Theseattributescaneitherbedefinedmanuallyoradeveloper
cansimplyprovideaC/C++functionsignatureandGraphFuzzwill
attempttogeneratetheendpointspecificationautomatically.Inreal
worldtargets,weobservethatfull,manualendpointdefinitionsare
1076
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Harrison Green and Thanassis Avgerinos
1inputs: [ "SkPath" ]
2outputs: [ "SkPath" ]
3args: [ "float" ,"float" ]
4exec: |
5 $i0->moveTo($a0, $a1);
6 $o0 = $i0;
Figure 6: A full endpoint driver specification for Sk-
Path::moveTo(SkScalar, SkScalar).
1struct_SkPath:
2...
3-intgetPoints(SkPoint points[], intmax):
4 inputs: [ "SkPath" ]
5 outputs: [ "SkPath" ]
6 args: [ "int"]
7 exec: |
8 SkPoint points[1024];
9 unsigned int max = $a0 % 1025;
10 $i0->getPoints(& points, max);
11 $o0 = $i0;
Figure 7: A custom endpoint definition for
SkPath::getPoints(SkPoint[], int).
onlyrequiredroughly10%ofthetime.Fortheremainingcases,the
function signature itself is sufficient.
Theendpointdrivertemplate( exec)isasnippetofC/C++code
that is exposed to several additional GraphFuzz-specific macros.
Inside the endpoint driver template, $iN,$oN, and$aNrefer to the
Nâ€™th input, output, and argument respectively. Inputs and outputs
havepointertypeswhileargumentscan bereferenceddirectlyas
raw types.
For example, the void moveTo(SkScalar, SkScalar) signa-
ture defined on the SkPathstruct in Figure 4 is converted into
thefullendpointspecificationinFigure6.GraphFuzzrecognizes
thatthisisamethodcallandautomaticallygeneratesthecorrect
input/output dependencies and execution driver template.
4.5 Custom Endpoint Drivers
Certain endpoints have implicit requirements about usage that are
notinferablefromthefunctionsignaturealone.Inthesecases,ade-
velopercanextendthe exectemplatetocustomizethespecification
of an endpoint.
Forexample,themethod SkPath::getPoints(SkPoint[] po-
ints, int max) is used to retrieve points from the underlying
path object. The pointsarray must have space for maxentries and
will be filled in during execution. While GraphFuzz cannot infer
theseconstraintsfromthefunctionsignature,theycanbemanually
defined in the GraphFuzz schema.
We incorporate this semantic knowledge into the schema by
defining a custom endpoint as in Figure 7. In this endpoint, we
manuallyallocatea SkPatharrayonthestackwithsize1024.Then
weinvoke SkPath::getPoints withthisarrayanda maxparameter
which is bounded to the range 0-1024.4.6 Fuzzing Process
GraphFuzz is implemented as a custom mutation engine on top
oflibFuzzer[ 3].Hence,theresultingbinariesarenativelibFuzzer
executablesandarecompatiblewithexistingfuzzinginfrastructure
such as OSS-Fuzz. The fuzzing process (Figure 8) consists of the
following steps:
(1)Selection: LibFuzzer selects inputs to mutate.
(2)Mutation :GraphFuzzinterpretseachcorpusinputasase-
rialized dataflow graph (section 3.2) and applies graph-level
mutations (section 3.6).
(3)Execution :GraphFuzzexecutesthedataflowgraph(section
3.3) by performing a dynamic traversal of the vertices, ex-ecuting corresponding endpoint drivers as necessary. The
fuzzExec harness executes actual target code while the fuz-
zWriteharnessconvertsnodestocorrespondingsourcecode
output.
(4)CoverageFeedback :Feedbackfromthetarget(intheform
of edge coverage, value coverage, etc.) is collected by lib-
Fuzzer and used to guide corpus growth and selection.
5 EVALUATION
WeusedGraphFuzztofuzz-test5real-worldCandC++libraries.
In this section we discuss challenges and results from our fuzzing
campaigns. We also include severalexamples of the types ofbugs
found with GraphFuzz.
Duringourresearch,wesoughttoestablishaquantitative,head-
to-head benchmark. This endeavor proved difficult simply because
there are not many existing harnesses that can test a large set of
APIendpointsatonceâ€”mostexistingharnessesonlytestoneor
two endpoints at a time, and therefore GraphFuzz could easily get
more coverage by invoking more endpoints. However, we were
able to find 10 harnesses in the Skia project which fuzzed between
6to350endpointsatatime.Weusedtheseharnessestoestablisha
quantitativebenchmarkthatwediscussinmoredetailinSection
5.2.2.
Wefoundhardbugs(i.e.segfaults,use-after-free,buffer-overfl-
ows) in 4 of the 5 libraries we fuzzed and we found soft bugs (in-
ternalassertionerrors)ineverylibrary.Sincemostofthesebugs
require API control to trigger, they are naturally less likely to man-
ifest as security vulnerabilities. However we did find potential
security vulnerabilities in both Skia and RDKit.
5.1 Implementation
All ofthe fuzzingexperiments described inthe followingsections
were performed on a 128-core AMD EPYC 7601 cluster with 512
GB of RAM. Fuzzer harnesses were compiled in an Ubuntu 18.04
or Ubuntu 20.04 Docker container using clang-10. For exploratory
fuzzerruns,weusedbetween1and32coresinlibFuzzerforkmode.
The Skia benchmark was performed with 4 cores per harness.
Weprovidealloftheharnessesandsupportingcodetoreproduce
these experiments in the GraphFuzz repository.
5.2 Skia Graphics Library
Skia[23]isaamature,C++graphicslibrary,maintainedbyGoogle
andused inhigh-profileprojects suchasChromium andAndroid.
1077
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. GraphFuzz: Library API Fuzzing with Lifetime-aware Dataflow Graphs ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Figure8:GraphFuzzFuzzingprocess.1.CorpusinputsareselectedbylibFuzzer2.GraphFuzzappliessemanticgraphmutations
3. Inputs are invoked through a dynamic traversal of the dataflow graph 4. Coverage feedback is collected and used to guidecorpus growth and selection.
TheSkiacodebasehasbeenrigorouslytestedbyGooglesecurityen-
gineers,independentbugbountyhuntersandtheOSS-Fuzzproject.
CumulativelybillionsofCPUhourshavebeenspentfuzz-testing
Skia.
Asagraphicslibrary,thecoreSkiaAPIcontainsdozensofob-
jectsrepresentinggraphicsprimitivesandthousandsoffunctions
that operate with these objects. Due to Skiaâ€™s use in high-profileprojects such as Chromium and Android, many of these internal
APIs are potentially attacker-controlled. A malicious webpage can
usespeciallycraftedSVGortheJavaScriptCanvasAPIto induce
specific API calls in the renderer process.
During our research, we found hundreds of unique assertion
errors.Wealsofoundandreported3securityvulnerabilitiesinSkia.
One we show in Figure 1.
5.2.1 Existing Harnesses. Duetoitssecurityimportance,consid-
erabletimehasbeenspenttodevelopfuzzingharnessesforSkia.
Currently there are 37 separate libFuzzer targets in the Skia repos-
itory, most of which are fuzz-tested at scale as part of OSS-Fuzz.
The majority of these harnesses isolate one specific endpoint such
as adeserialize function or a compile_shader function.
Several of these harnesses use the FuzzedDataProvider approach
to test a wide array of API endpoints at once. For example, the
fuzz_draw_functions harness simulates drawing random shapes
and paths to a canvas.
5.2.2 Head-to-head Benchmark. We selected 10 existing structure-
aware, OSS harnesses from the Skia project as a baseline. For each
existing harness, we created an equivalent GraphFuzz harness de-
signed to fuzz exactlythe same API surface. While in practice, it
isnotnecessarytoconstrainGraphFuzzinthisway,limitingthe
fuzzable API surface allows us to construct a fair head-to-head
benchmarkandensureanydifferencesingeneratedcoverageare
due to the flexibility andefficiency by which both variants can
fuzz-testAPIinteractionsandnotsimplythe numberoffuzzable
endpoints.
On average, for each GraphFuzz harness, we were able to ac-
curately specify the usage semantics of 90% of target endpointsusingonlythe function signatures. The remaining 10% of cases
requiredminimalrevision,forexampletospecifytheusageofan
array argument or constrain the domain of an input argument. See
the â€œAutoâ€ column in Table 2 for a breakdown by harness.
We performed 5 independent, 48-hour fuzz sessions for each
harnessusing4-coresinlibFuzzerâ€™sforkmode.Eachharnesswas
linkedagainsttheexactsameSkiabuild.Afterthedesignatedperiod,
we computed line coverage over the whole corpus using a gcov-
instrumentedversionofeachharness.Forcomparisonpurposeswecompiledasecond,instrumentedversionofeachharnesscalledthedry harness which is identical to the original harness except it does
not invoke the target API. This dry harness allows us to account
for differences in coverage due to the way both harnesses read
andpreparetestcases.Forexample,boththeOSSandGraphFuzz
harnesses use a small percentage of the Skia API to prepare data
streamsandsetupthefuzzenvironment.Wecanusethedifference
in coverage between the normal harness and the dry harness to
isolate only the code coverage that is due to actual target API
fuzzing.
Specifically,given ğ¶ğ‘œğ‘ ğ‘ andğ¶ğ‘”ğ‘“(setofcoveredlinesforOSSand
GraphFuzz respectively) and the dry harness coverage: ğ¶/primeğ‘œğ‘ ğ‘ and
ğ¶/prime
ğ‘”ğ‘“(setof coveredlinesin thedry harnessvariants),we compute
the shared fuzzer core coverage ğ‘…=ğ¶/primeğ‘œğ‘ ğ‘ âˆªğ¶/prime
ğ‘”ğ‘“(i.e. theuninter-
estingcode coverage due to harness-specific mechanics). Then we
compute the normalized line coverage as ğ‘ğ‘œğ‘ ğ‘ =|ğ¶ğ‘œğ‘ ğ‘ âˆ’ğ‘…|and
ğ‘ğ‘”ğ‘“=|ğ¶ğ‘”ğ‘“âˆ’ğ‘…|.
To obtain temporal coverage information, we parsed the lib-
Fuzzer log output which contains both the elapsed time and alibFuzzer internal covmetric for many data points over the 48-
hour period. This cov metric is not directly comparable between
harnessessinceitincludesharness-specificcoverageinformation.However,withthe assumptionthatthis metricscalesroughly lin-
early with the true normalized line coverage ( ğ‘ğ‘œğ‘ ğ‘ andğ‘ğ‘”ğ‘“), we
graph a linearly-scaled version of the libFuzzer covmetric such
that the final datapoint matches ğ‘ğ‘œğ‘ ğ‘ orğ‘ğ‘”ğ‘“exactly. This chart
providesavisualcuefortheevolutionofthefuzzercorporaover
time.
1078
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Harrison Green and Thanassis Avgerinos
5.2.3 Benchmark Results. FuzzercoverageisgraphedinFigure9
and we provide statistical information in Table 2.
In the best cases, the GraphFuzz harness generated nearly 9x as
muchlinecoveragecomparedtothebaselineandintheworsecases,
the GraphFuzz harness was roughly equivalent to the baseline.
In general, we see the largest coverage improvements with
GraphFuzz on the larger harnesses. Intuitively, more endpoints
means there are more opportunities for novel interactions. Man-ually defined harnesses miss these interactions unless they are
specifically programmed to test them.
For small harnesses such as api_regionop ,api_pathop and
api_path_measure, the GraphFuzz harnessesare roughly equiva-
lenttotheexistingSkiaharnesses.Bothharnessvariantsquickly
explore the majority of the state-space and plateau.
Inlargerharnessessuchas api_svg_canvas andapi_draw_fun-
ctions,GraphFuzzcontinuestofindnewcoverageuntiltheend
of the 48 hour period while the baseline harness plateaus early on.
5.3 Other OSS Targets
5.3.1 RDKit. RDKit [24] is a cheminformatics library written in
C++ with Python bindings for most of the API. Typical usage in-
volves constructing and manipulating many different objects such
asRDMol,RDAtom,andRDBond(representingmolecules,atoms,and
bonds respectively).
RDKithasbeencontinuouslyfuzzedaspartofOSS-Fuzzsince
May 2020. Despite this, we found 10+ bugs with GraphFuzz (in-
cluding heap-use-after-free and segmentation faults) after fuzzinga small portion of the RDKit API surface. Most of these bugs were
alsoreachablefromthePythonAPIbindings.Wedisclosedthree
security relevant bugs to the RDKit developers.
5.3.2 SQLite. SQLite [25] is a small SQL database library written
in C. It is used in Chrome, Android and hundreds of other projects.
We spent a few days harnessing most of the SQLite3 C API with
GraphFuzz.Weidentifiedtwocrashingtestcasesrequiring5and15
endpoints respectively. In the first case, GraphFuzz discovered that
settingthe SQLITE_LIMIT_LENGTH to0wouldcrashasubsequent
sqlite3_prepare_v2 statement.Inthesecond,GraphFuzzfound
awaytocrashSQLitebyinvokingthreeonlinebackupsatonceinaspecificorder.DuetothewaySQLiteisusedinthewild,thesebugs
are unlikely to manifest as security vulnerabilities. However, for a
heavily-fuzzed library like SQLite,it is impressive that GraphFuzz
could discover these bugs.
5.3.3 Eigen. Eigen3[26]isaC++templatelibraryforlinearalgebra.
ItisusedinprojectssuchasTensorFlowandChromium.Wefound
this target particularly interesting to harness due to the extensive
use of templates. AlthoughGraphFuzz does not currently support
C++ template syntax natively, it is possible to define schemas that
usefixed-argumenttemplatefunctions.WeusedGraphFuzztofuzz-
test a subset of the matrix and vector API. Although we did not
find any crashing bugs, we discovered test cases that reach dozens
of unique assertions in the Eigen core library.
5.3.4 IOWOW. IOWOW[ 27]isakey/valuestoragelibrarywritten
inC.TheprovidedAPIallowsausertocreateanddestroydatabase
objects and store/retrieve key-value pairs consisting of arbitrarybyte-string data. We spent less than a day configuring a schemaforIOWOWandfuzzingitandidentifiedtwocrashingbugswithin
minutes ofstarting the fuzzer. Inthe first, GraphFuzzdiscovered
thataddingmetadatatoadatabaseobjectwith iwkv_db_set_meta
and then destroying the database ( iwkv_db_destroy ) would cause
ause-after-freeuponclosingthecontaining IWKVinstance.Inthe
second,GraphFuzzidentifiedthatinitializingadatabasewiththe
IWDB_VNUM64_KEYS flagandtheninvoking iwkv_cursor_open on
thedatabaseusingalookupkeyofsize0 wouldtriggerasegmen-
tation fault. We reported both of these bugs to the maintainers and
they were quickly patched in the latest version.
6 LIMITATIONS
6.1 Automation
While GraphFuzz can automatically synthesize a schema from a
listoffunctionsignatures,wefindthatfunctionsignaturesalone
are not always sufficient to describe the usage requirements of
an endpoint. For example, in the C function void foo(bar *b) ,
argument bcould be an input, an output, or both. Similarly, in the
functionvoid sum(int arr[], int N) , there may be a â€œhiddenâ€
correlationbetween arrandNwherethesizeof arrisexpectedto
be at least N.
During our experiments, we observe that roughly 90% of end-
points(seetable2)canbeaccuratelymodeledwithonlythefunction
signature while the remaining 10% require human-curated custom
endpoint definitions. The development of systems which can au-tomatically infer (or search) these implicit constraints in Library
APIs is an interesting area for future research.
6.2 False Positives
Givenanincorrect schema,GraphFuzzcangenerate falsepositive
crashes do to invalid API usage. In other words, generated graphs
areonlyasaccurateastheprovidedschema.UsersofGraphFuzz
need to take care to ensure that the GraphFuzz schema aligns with
the target Library API. We call this problem schema alignment.
Inpractice,weobservetwodistincttypesofschemaalignment
issues:
6.2.1 Type 1: Single-endpoint Semantics. Givenaschemawithan
incorrectly specified endpoint (such as the examples in Section
6.1), GraphFuzz will quickly and frequently generate false positive
crashes. These issues are both easy to diagnose and easy to correct
by manually redefining the endpoint.
6.2.2 Type 2: Multi-endpoint Semantics. SomeLibraryAPIshave
hard-to-model usage requirements that span multiple endpoints.For example, one API pattern we observe in Skia is the use of a
sharedpointer sk_sp<Foo> alongwitha Foo *refFoo() method.
Thereturned Foopointerisvalidaslongastheoriginal sk_sp<Foo>
object has not been destroyed. In this case, modeling the usage re-
quirementsismoredifficultthansimplymodelingeachendpoint.
Auserneedstocreateaschemasuchthat sk_sp<Foo> cannotbe
destroyed while a Foopointer is still used elsewhere. For example,
it is possible to define a synthetic type in the GraphFuzz schema
which bundles the returned Foopointer along with the original
sk_sp<Foo> object such that the sk_sp<Foo> object cannot be de-
stroyed until the Foopointer is released.
1079
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. GraphFuzz: Library API Fuzzing with Lifetime-aware Dataflow Graphs ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
0h12h24h36h48h05101520api_draw_functions
0h12h24h36h48h0510api_raster_n32_canvas
0h12h24h36h48h02468api_null_canvas
0h12h24h36h48h0510api_pathop
0h12h24h36h48h0.00.51.01.5api_polyutils
0h12h24h36h48h0510api_svg_canvas
0h12h24h36h48h0510api_mock_gpu_canvas
0h12h24h36h48h0.00.20.40.6api_regionop
0h12h24h36h48h0.00.51.0api_path_measure
0h12h24h36h48h024region_set_path
GraphFuzz
Baseline
Average Coverage
Figure 9: GraphFuzz vs. OSS-Fuzz harnesses on 10 Skia benchmarks. Each line shows a complete, 48-hour fuzz session on 4
cores. The x-axis shows elapsed time (in hours) and the y-axis shows normalized line coverage (in thousands). The bold lines
(indicated by the marker) show the average coverage from GraphFuzz and OSS respectively across the 5 runs.
Harness Endpoints Auto Baseline NLC GraphFuzz NLC Coverage Î”
api_draw_functions 72 90% 12,770Â±497 18,486 Â±1,206 1.45x
api_raster_n32_canvas 350 84% 3,152Â±1,336 8,964 Â±1,640 2.84x
api_null_canvas 350 84% 2,114Â±267 8,152 Â±371 3.86x
api_pathop 19 100% 13,752Â±7 13,568 Â±158 0.99x
api_polyutils 7 86% 999Â±0 1,535 Â±1 1.54x
api_svg_canvas 350 84% 2,455Â±23 10,778 Â±558 4.39x
api_mock_gpu_canvas 350 84% 12,089Â±292 12,452 Â±1,061 1.03x
api_regionop 6 100% 676Â±0 669 Â±8 0.99x
api_path_measure 17 100% 1,273Â±0 1,293 Â±0 1.02x
region_set_path 53 85% 584Â±0 5,264 Â±10 9.01x
Table 2: Skia benchmark results. NLC = Normalized Line Coverage, reported as (mean Â±std) for 5 fuzzer runs. Coverage Î”=
average increase in coverage gained by GraphFuzz over the baseline (1x means no change). Auto = percentage of endpointsspecified using only the function signature.
This solution is effective at preventing false positives but is a
stop-gapforamorecomplexproblemandlimitstheflexibilityof
generatedgraphs.Furtherresearchisneededtodesignsolutions
that enable more accurate modeling of multi-endpoint semantics.
7 CONCLUSION
Inthispaper,weintroducedthetechniqueofdataflowgraph-based
fuzzingwhichisdesignedtofuzz-testLibraryAPIâ€™s.Wedescribe
this approach in the context of fuzzing C and C++ libraries and we
release our implementation of dataflow graph-based fuzzing called
GraphFuzzasanopen-sourceframework.Wevalidateourapproachonfivereal-worldtargetsanddemonstratethatGraphFuzzcanfind
realbugsandoutperformhand-craftedharnessesinquantitativebenchmarks at a fraction of the development cost. Often times,the only information required to fuzz with GraphFuzz is a list of
function signatures in a target.REFERENCES
[1]K. Serebryany, â€œOss-fuzz-googleâ€™s continuous fuzzing service for open source
software,â€ 2017.
[2]â€œFuzzing for safety critical systems.â€ https://forallsecure.com/safety-critical. Ac-
cessed: 2021-09-03.
[3]K. Serebryany, â€œlibfuzzerâ€“a library for coverage-guided fuzz testing,â€ LLVM
project, 2015.
[4]C.LattnerandV.Adve,â€œLlvm:Acompilationframeworkforlifelongprogram
analysis&transformation,â€in InternationalSymposiumonCodeGenerationand
Optimization,2004. CGO 2004. , pp. 75â€“86, IEEE, 2004.
[5] â€œgoogle/libprotobuf-mutator,â€ June 2021. original-date: 2017-01-11T22:57:02Z.
[6]X.Yang,Y.Chen,E.Eide,andJ.Regehr,â€œFindingandunderstandingbugsinc
compilers,â€ in Proceedings of the 32nd ACM SIGPLAN conference on Programming
language design and implementation, pp. 283â€“294, 2011.
[7]D.BabiÄ‡,S.Bucur,Y.Chen,F.IvanÄiÄ‡,T.King,M.Kusano,C.Lemieux,L.Szekeres,
and W. Wang, â€œFudge: fuzz driver generation at scale,â€ in Proceedings of the
201927thACMJointMeetingonEuropeanSoftwareEngineeringConferenceand
Symposium on the Foundations of Software Engineering, pp. 975â€“985, 2019.
[8]K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, â€œAddresssanitizer:
Afastaddresssanitychecker,â€in 2012{USENIX}AnnualTechnicalConference
({USENIX}{ATC}12), pp. 309â€“318, 2012.
1080
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Harrison Green and Thanassis Avgerinos
[9]J. Ruderman, â€œIntroducing jsfunfuzz,â€ URL http://www. squarefree.
com/2007/08/02/introducing-jsfunfuzz , vol. 20, pp. 25â€“29, 2007.
[10]C. Aschermann, T. Frassetto, T. Holz, P. Jauernig, A.-R. Sadeghi, and D. Teuchert,
â€œNautilus: Fishing for deep bugs with grammars.,â€ in NDSS, 2019.
[11]V. Atlidakis, R. Geambasu, P. Godefroid, M. Polishchuk, and B. Ray, â€œPythia:
grammar-based fuzzing of rest apis with coverage-guided feedback and learning-
based mutations,â€ arXiv preprint arXiv:2005.11498, 2020.
[12] â€œchromium/src.git - Git at Google.â€
[13]H. Han, D. Oh, and S. K. Cha, â€œCodealchemist: Semantics-aware code generation
to find vulnerabilities in javascript engines.,â€ in NDSS, 2019.
[14]H.HanandS.K.Cha,â€œImf:Inferredmodel-basedfuzzer,â€in Proceedingsofthe2017
ACMSIGSACConferenceonComputerandCommunicationsSecurity,pp.2345â€“
2358, 2017.
[15]K. Ispoglou, D. Austin, V. Mohan, and M. Payer, â€œFuzzgen: Automatic fuzzer gen-
eration,â€in 29th{USENIX}SecuritySymposium( {USENIX}Security20),pp.2271â€“
2287, 2020.
[16] D. Vyukov, â€œSyzkaller,â€ 2015.[17]
V. J. M. Manes, H. Han, C. Han, S. K. Cha, M. Egele, E. J. Schwartz, and M. Woo,
â€œThe Art,Science, andEngineering of Fuzzing:A Survey,â€ IEEE TransactionsonSoftware Engineering, pp. 1â€“1, 2019.
[18]C. Holler, K. Herzig, and A. Zeller, â€œFuzzing with code fragments,â€ in 21st
{USENIX}Security Symposium ( {USENIX}Security 12), pp. 445â€“458, 2012.
[19]S. Veggalam, S. Rawat, I. Haller, and H. Bos, â€œIfuzzer: An evolutionary inter-
preterfuzzer usinggenetic programming,â€ in EuropeanSymposium onResearch
in Computer Security, pp. 581â€“601, Springer, 2016.
[20]V. Atlidakis, P. Godefroid, and M. Polishchuk, â€œRestler: Stateful rest api fuzzing,â€
in2019IEEE/ACM41stInternationalConferenceonSoftwareEngineering(ICSE),
pp. 748â€“758, IEEE, 2019.
[21] â€œMozillaSecurity/dharma,â€ May 2021. original-date: 2015-03-25T17:56:23Z.[22]
J.Jiang,H.Xu,andY.Zhou,â€œRulf:Rustlibraryfuzzingviaapidependencygraph
traversal,â€ arXiv preprint arXiv:2104.12064, 2021.
[23] â€œSkia: The 2d graphics library.â€ https://skia.org/. Accessed: 2021-09-03.[24]
â€œRdkit: Open-source cheminformatics.â€ http://www.rdkit.org. Accessed: 2021-09-
03.
[25] â€œSqlite: In-memory database.â€ https://www.sqlite.org/. Accessed: 2021-09-03.[26] G. Guennebaud, B. Jacob, et al., â€œEigen v3.â€ http://eigen.tuxfamily.org, 2010.
[27]
â€œIowow:C11key/valuedatabaseengine.â€https://iowow.io/. Accessed:2021-09-03.
1081
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:20:26 UTC from IEEE Xplore.  Restrictions apply. 