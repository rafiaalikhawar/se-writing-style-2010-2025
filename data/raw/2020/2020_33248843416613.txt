UnchartIt: An Interactive Framework for
Program Recovery from Charts
Daniel Ramos
INESC-ID / IST, U. Lisboa
Lisboa, Portugal
daniel.r.ramos@tecnico.ulisboa.ptJorge Pereira
INESC-ID / IST, U. Lisboa
Lisboa, Portugal
jorge.m.s.pereira@tecnico.ulisboa.ptInÃªs Lynce
INESC-ID / IST, U. Lisboa
Lisboa, Portugal
ines.lynce@tecnico.ulisboa.pt
Vasco Manquinho
INESC-ID / IST, U. Lisboa
Lisboa, Portugal
vasco.manquinho@tecnico.ulisboa.ptRuben Martins
Carnegie Mellon University
Pittsburgh, USA
rubenm@andrew.cmu.edu
ABSTRACT
Chartsarecommonlyusedfordatavisualization.Generatingachart
usuallyinvolvesperformingdatatransformations,includingdata
pre-processingandaggregation.Thesetaskscanbecumbersome
andtime-consuming,evenforexperienceddatascientists.Repro-
ducingexistingchartscanalsobeachallengingtaskwheninfor-
mation about data transformations is no longer available.
In this paper, we tackle the problem of recovering data transfor-
mations from existing charts. Given an input table and a chart, our
goalistoautomaticallyrecoverthedatatransformationprogramun-
derlying the chart. We divide our approach into four steps: (1) data
extraction, (2)candidate generation,(3) candidate ranking,and (4)
candidate disambiguation. We implemented our approach in a tool
called UnchartIt and evaluated it on a set of 50 benchmarks from
Kaggle. Experimental results show that UnchartIt successfully
ranks the correct data transformation among the top-10 programs
in 92% of the benchmarks. To disambiguate the top-ranking pro-
grams,weuseournewinteractiveprocedure,whichsuccessfully
disambiguates 98% of the ambiguous benchmarks by asking on
average fewer than 2 questions to the user.
CCS CONCEPTS
â€¢Software and its engineering;
KEYWORDS
Recovering Data Transformations from Charts, Program Synthesis,
Interactive Disambiguation
ACM Reference Format:
DanielRamos,JorgePereira,InÃªsLynce,VascoManquinho,andRubenMar-
tins.2020.UnchartIt:AnInteractiveFrameworkforProgramRecovery
from Charts. In 35th IEEE/ACM International Conference on Automated Soft-
ware Engineering (ASE â€™20), September 21â€“25, 2020, Virtual Event, Australia.
ACM,NewYork,NY,USA,12pages.https://doi.org/10.1145/3324884.3416613
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Â© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-6768-4/20/09.
https://doi.org/10.1145/3324884.34166131 INTRODUCTION
In the last decade, data analysis has become one of the most im-
portanttoolsfororganizationstodrivetheirdecisions.Thehuge
demandfordomainexpertshasledmanydataanalystswithlimited
programming knowledge to be recruited. Thus, in the last years,
severaltools[ 13,14,23,25,39,45]havebeendevelopedtoaidinex-
perienced analysts in automating some programming tasks. These
toolswork byexample:theuser providesaset ofinput-outputex-
amples, and the tool finds a program that maps the inputs into the
output. Ho wever, the development of tools that work directly with
visual elements has remained unexplored. Hence, if a user prefers
to express his intent through visual elements (e.g., providing an
inputtableandabarchart),thereisnotoolthatisabletoreverse
engineer the necessary data manipulations in order to reproduce it.
In this paper, we propose UnchartIt, a tool for reverse engi-
neeringthenecessarytablemanipulationstogenerateagivenchart.
Note that, to the best of our knowledge, this is the first tool for
automaticgenerationofdatamanipulationsthatdirectlyusesvi-
sual elements.In this work,we consider thatthe user canprovide
the image of a bar chart and the raw data from which the chart
wasgenerated.Althoughweonlyconsiderbarcharts(oneofthe
most common chart types [ 3]), the proposed ideas can be easily
generalizedtoothertypesofchartsorgraphicalelements.More-
over,wealsoaddresshowtoautomaticallyextractthenecessary
information from the chart,how to adapt program synthesis tools
tothisnewchallengingproblem,aswellashowtodisambiguate
several programs while minimizing user interactions. Furthermore,
experimental results on real-world instances from Kaggle show
that UnchartIt is able to reverse engineer how to build the chart
presented by the user. Specifically, the correct data transforma-tionprogramisrankedamongthetoptenprogramsreturnedby
UnchartItin92%oftheinstances.Toselecttheuserâ€™sintended
programfromthetoptenrankedprograms,UnchartItinteracts
with the user by asking either yes or no questions, or multiple-
choicequestions,andsuccessfullyreturnsthecorrectprogramin
98% of the ambiguous instances.
This paper makes the following main contributions:
â€¢The first fully automated tool called UnchartIt that syn-
thesizes table manipulations from bar charts.
â€¢Automated input generation methods to disambiguate a set
ofprogramsthatminimizethenumberofuserinteractions.
1752020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
This work is licensed under a Creative Commons Attribution International 4.0 License.
date_received product ...
08/30/2013 Mortgage ...
08/30/2013 Mortgage ...08/30/2013 Credit reporting ...08/30/2013 Student loan ...08/30/2013 Debt collection ...08/30/2013 Credit card ...08/30/2013 Credit card ...08/30/2013 Debt collection ...
(a) Sample of the consumer complaints table (175.39MB).2011 2012 2013 2014 2015 20160.440.891.331.77Â·105
year# complaints
(b) Bar chart with yearly number of consumer complaints.
Figure 1: Consumer complaints data from 2011 to 2016.
â€¢Experimentalresultsonreal-worldbenchmarksthatshow
the success of the proposed approaches.
Thepaperisstructuredasfollows:Section2definestheresearch
challenge and motivates the problem with a concrete example.Section 3 addresses the problem of data extraction from visual
elements and Section 4 explains the necessary changes to program
synthesizers to solve this new research problem. Next, Section 5
addresses how to rank the programs generated by the synthesizer.
Section 6 proposes new models on how to disambiguate the top- ğ‘›
rankedprogramsfortwodifferentuserinteractionmodels.Section7presentstheexperimentalresultsonasetofrealdatafromdifferent
domains. Section 8 briefly reviews related work. Finally, the paper
concludes in Section 9.
2 MOTIVATION
Considerthesampleoftheconsumercomplaintsdatabaseshown
in Figure 1a. The database contains complaints submitted to theConsumer Financial Protection Bureau between 2011 and 2016.
Figure1bshowsabarchartwiththenumberofcomplaintsreceived
in each year.
Suppose that Alice, a data analyst with low programming skills,
needs to elaborate a report on an updated version of the consumer
complaints database.1As a reference, she received an old report
written by a former employee. This report contains a variety of
charts,includingFigure1b,butnottheprogramsfromwhichthe
chartsoriginated.Therefore,Aliceâ€™staskistorecovertheprogramsnecessarytoreproducethereportâ€™scharts.IfAlicehastheprograms
to generate the charts, she can update them whenever new data is
added to the database.
In this paper, we describe UnchartIt, a new tool that can au-
tomaticallyrecoveraprogram froma givenchartfor people like
Alice. To recover a program from a chart, Alice needs to provide
the raw data from which the chart originated and an image of the
chart.Figure2illustratestheUnchartItarchitecture.Givenapair
(data,chart),UnchartItstartsbyextractingdatafromthechart,
thereby creating a tabular representation of the chart. Since this
step involves automatically interpreting a chart, the resulting table
is prone to contain imprecisions. For instance, from the chart of
1https://www.consumerfinance.gov/data-research/consumer-complaints/Table1:Tableobtainedfrom
the bar chart of Figure 1b.
col0 col1
bar02345.18
bar172255.90
bar2108303.62
bar3153090.18
bar4168929.33
bar550954.98Table 2: Real table inherent
tothebarchartofFigure1b.
year # complaints
2011 25492012 725232013 1082732014 1531382015 1686212016 50853
Figure1b,UnchartItgeneratesTable1.Incontrast,Table2con-
tains the real table underlying the chart of Figure 1b. Note that the
numericaldataoftheextractedtableisimpreciseandthebarlabels
are missing.
Afterobtainingatabularrepresentationofthechart,UnchartIt
starts the candidate program generation step. During this stage,
UnchartItusestwomajorcomponents:(1)theprogramgenerator,
and(2)theprogramdecider.Theprogramgeneratorenumeratescandidate programs and provides them to the program decider.
The programdecider evaluatesthe candidateprograms, decidesif
they are good candidates, and provides feedback to the program
generator.Notethattheprogramdeciderdoesnothaveaccessto
the real table underlying the chart, but rather to an approximation
of the real table extracted from the chart image. Therefore, the
program decider cannot simply discard candidates because they do
not map the raw input data into the imprecise table it extracted in
the previous step. Instead, it decides to keep or discard candidates
usingaweakercriterion:acandidateprogramiskeptifandonly
if its output on the input data has the same number of rows andcolumnsastheextractedtable.Forexample,usingtheconsumercomplaintsdatafromFigure1aandtheextractedtableshownin
Table1,UnchartItfinds7differentprogramswhoseoutputonthe
inputdatahasthesamestructureasTable1(6rowsand2columns).
After generating a pool of candidates, UnchartIt assigns each
candidate program a score using a cost function and ranks the
programs according to their costs. Since it is possible that the best-
ranking program does not correspond to the program the user
176Data Extraction
Candidate Generation Candidate Ranking
â€¦
CandidatesProgram Disambiguation (optional)
Q1. Consider 
the input table:Is the following chart correct?  (Y/N)
Q2. Consider the input table:Select the correct output:
Input data
Top-n candidatesOutput chartProgram
Program 
DeciderProgram 
GeneratorCandidate
Feedback
Noisy
Output Data
Figure 2: UnchartIt architecture.
Consider the following
input table:date_received date_sent
24/07/2015 03/12/2011
10/01/2013 01/12/201223/01/2015 17/07/2014
Q: Is the following output table / chart correct? (Y/N)
yr count
2013 12015 2
2013 20150123
yrcount
Figure 3: User interaction example.
desires, UnchartIt gives the user the option to answer a series
of questions in order to disambiguate the top- ğ‘›programs of the
rank.Inparticular,UnchartIthastwodifferentuserinteraction
models to disambiguate programs. In the first interaction model,
UnchartItaskstheusertopickthecorrectoutput(fromasetof
options) for a given input. In the second interaction model, Un-
chartIt asksthe userif agiventest caseis correctornot (yes/no
question). In both approaches, UnchartIt automatically generates
small test cases that minimize the number of user interactions. For
example, after enumerating the 7 different candidate programs for
the specification given by the pair (Figure 1a, Figure 1b), Unchar-
tIt only needs to ask the user 3 questions before returning the
correct program using the yes/no interaction model.
Figure 3 illustrates the user interaction in the yes/no interac-
tion model. Given a small intput table (automatically generatedby UnchartIt), the user just needs to confirm if the given chart
correspondstothecorrectoutput.Thisexamplecorrespondstothe
last question of the user interaction for the problem in Figure 1,
and the returned program is shown in Figure 4.l1 <- df %>% mutate (date = mdy(date_received))
l2 <- l1 %>% mutate (yr = year (date))
l3 <- l2 %>% group_by (yr)
l4 <- l3 %>% summarise (count = n())
l5 <- l4 %>% ggplot (aes(x=yr, y=count)) + geom_col ()
Figure 4: Program returned by UnchartIt for the instancegiven by Figure 1 after the interaction of Figure 3.
3 DATA EXTRACTION
Thefirststepinourpipelinerequiresustotransformthechartâ€™s
imageintoastandardtabularrepresentation(e.g.,transformingthe
chart of Figure 1b into Table 1). This is a crucial step because there
can be many different ways of depicting the same information. By
transformingthechartintoastandardtabularrepresentation,we
canbuild asimpler validationmechanism todecide thesuitability
of candidate programs to the given specification. Let ğ‘‡ğ‘’denote the
tableextractedfromthechart.Givenaprogram Pthatoutputsa
tableğ‘‡ğ‘whenPisexecutedontheinputdata,thenwecancompare
ğ‘‡ğ‘’againstğ‘‡ğ‘in order to evaluate the quality of program P. In this
section, we focus on extracting data from bar charts. Nevertheless,
thetechniquesdiscussedherecanbeadaptedtoworkwithother
chart types.
3.1 WebPlotDigitizer
WebPlotDigitizer [ 34] is one of the most prominent tools for
manual and automatic extraction of data from charts. In particular,
WebPlotDigitizer can automatically extract numerical data from
simple2Dbarcharts(i.e.,withoutstackedandgroupedbars).To
extractdatafromabarchart,WebPlotDigitizerrequires3sets
of parameters: (1) the chartâ€™s image; (2) the pixel location of twodifferent points
(ğ‘ƒ1,ğ‘ƒ2)over the continuous axis along the bars,
and their corresponding values on that axis (Figure 5 shows an
example); (3) the width in pixels of the bars ( Î”ğ‘¥), and the height in
pixels of the highest bar ( Î”ğ‘£ğ‘ğ‘™).
WebPlotDigitizercombinesthesesetsofparameterstoextract
thenumericaldatafromthecharts,butitdoesnotextractthelabels
of the bars.
177Figure5:Firststepof WebPlotDigitizerâ€™saxiscalibration.
WebPlotDigitizer uses P1 and P2 to find the value of any
point on the axis by performing a linear interpolation.
3.2 Neural Data Extraction
Analternativeapproachtotraditionalchartdigitizationalgorithms,
such as those employed by WebPlotDigitizer, is to use machine
learning. Toolssuch as ReVision [ 36] andChartSense [ 24] have
previouslyusedmachinelearningalgorithmstodiscernbetween
charttypes(e.g.,decidingwhetheranimagecontainsabarchartor
ascatterplot).However,thesetoolsoftenrelyontraditionalalgo-
rithms to extract data from the charts. In this section, we propose
to leverage state-of-the-art Convolution Neural Networks (CNNs)
to retrieve data from bar charts.
CNNs are known for their huge success in modern computer vi-
sionsystems.Acomputervisionbenchmarkofparticularrelevance
on which CNNs shine is the ImageNet challenge [ 35]. The purpose
oftheImageNetchallengeistoassesstheperformanceofalgorithms
on classification and object detection tasks. The EfficientNet-B7
fulfills the current state-of-the-art performance on ImageNet chal-
lenge. The EfficientNets [ 37] are a family of eight CNNs ranging
fromEfficientNet-B0toEfficientNet-B7.Theâ€œXâ€inEfficientNet-BX
indicatesthenetworkâ€™scomplexity:thehighertheâ€œXâ€,themore
complex the network is.
OurgoalistoleveragethearchitectureofoneoftheEfficientNets
byreplacingitsoutputlayerwithacustomlayerthatsuitsourtask.
OneimportantpieceofinformationthatouradaptedEfficientNet
shouldextractisthenumberofbarsofagivenchart.Toretrievethisinformation,weadd
ğ‘›nodestothenetworkâ€™soutputlayer,eachone
representingtheprobability thatthegiven charthas ğ‘–âˆˆ{1,2,...,ğ‘›}
bars.Toachieveaprobabilitydistribution,the ğ‘›nodesuseasoftmax
activation function:
ğœğ‘–(z)=exp(ğ‘§ğ‘–)/summationtext.1ğ‘›
ğ‘—=1exp(ğ‘§ğ‘—),ğ‘–=1,2,...,ğ‘›
z=[ğ‘§1,ğ‘§2,...,ğ‘§ğ‘›]âˆˆIRğ‘›(1)
whereğœğ‘–(z)istheoutputofthe ğ‘–â€™thnode,indicatingtheprobability
that the given chart has ğ‘–bars. We extract the number of bars of
a given chart by taking the argmaxof the obtained probability
distribution:
Ë†ğ‘¦=argmax
ğ‘–âˆˆ{1,2,...,ğ‘›}ğœğ‘–(z)(2)
Besidesthenumberofbars,weshouldalsoretrievethebarsâ€™heights.
We can do this by adding ğ‘›more nodes to the networkâ€™s outputlayer (nodes ğ‘›+1t o2ğ‘›) with the following activation functions:
ğ‘ğ‘–(ğ‘¥)=max(0,min(ğ‘¥,1)),
ğ‘–=ğ‘›+1,ğ‘›+2,...,2ğ‘›(3)
whereğ‘ğ‘–is the output of the ğ‘–â€™th node, and it indicates how full is
theğ‘–âˆ’ğ‘›â€™thbarwithrespecttothemaximumpossibleheight( ğ‘ğ‘–=1
meansthatthe ğ‘–âˆ’ğ‘›â€™thbarisfull,and ğ‘ğ‘–=0meanstheğ‘–âˆ’ğ‘›â€™thbar
is empty). Using the height of each bar, we calculate its value by
doingalinearinterpolation betweentheaxismaximumandlowest
values:
Ë†ğ‘¦ğ‘–=/braceleftBigg
ğ¿+ğ‘ğ‘–+ğ‘›(ğ»âˆ’ğ¿),if 1â‰¤ğ‘–â‰¤Ë†ğ‘¦
0 otherwise(4)
whereË†ğ‘¦ğ‘–is the value of ğ‘–â€™th bar,ğ»is the axis maximum value, and
ğ¿is the axis lowest value. ğ»andğ¿are both user-provided inputs.
Similarly to WebPlotDigitizer, we do not extract the labels of
eachbar.Finally,totrainthenetwork,weminimizethesumofa
categorical cross-entropy loss(nodes 1 to ğ‘›) witha mean squared
error (nodes ğ‘›+1t o2ğ‘›).
4 PROGRAM SYNTHESIS
After extracting the table from the chart, UnchartIt starts search-
ingforcandidateprogramsthatcanpotentiallytransformtheinput
table into the table described by the chart. This problem can beseen as a program synthesis problem where the goal is to find a
program that satisfies a given specification. Program synthesis has
beensuccessfullyusedinmanyapplications(e.g.,stringmanipu-
lations [10,33], list manipulations [ 2,15], and table transforma-
tions [14,39]) as well as in commercial applications (e.g., Flash Fill
feature in Microsoft Excel [ 20]).Programming-by-example (PBE)
synthesis[ 21]isthemostcommonapproachforprogramsynthesis
wherethesynthesizertakesasspecificationasetofinput-output
examplesandsearchesforaprogramthatmapseachinputtothe
corresponding output. In our case, since the extracted table in the
previous step is only an approximation of the real table underlyingthe chart, we cannot use this criterion to accept or reject programs.
UnchartIt modifies the open-source Trinity synthesis frame-
work[28]totackletheproblemofrecoveringdatatransformations
from charts. The synthesis process used in UnchartIt is very
similartotheoneproposedforMorpheus[ 14].First,wecreated
a Domain Specific Language (DSL) for the data transformationdomain.NotethataDSLisjustausefulintermediaterepresenta-
tionfortheprogramthatabstractsfromsomesyntacticdetailsof
theprogramminglanguage.However,thereisadirectcorrespon-
dencefromtheDSLsymbolstotermsintheprogramminglanguage
syntax. The syntax of a DSL is described through a context-freegrammar
G=(ğ‘‰,Î£,ğ‘…,ğ‘†), whereğ‘‰is a finite set of non-terminal
symbols, Î£isafinitesetofterminalsymbols, ğ‘…isafiniterelation
fromğ‘‰to(ğ‘‰âˆªÎ£)âˆ—called the production rules, and ğ‘†is the start
symbol. Each terminal symbol ğœâˆˆÎ£is either a function, a vari-
able, a constant, or a special character (e.g., parenthesis or comma).
Each production rule ğœŒâˆˆğ‘…corresponding to a function is repre-
sented in form A0â†’ğ›½(A1,A2,...,Ağ‘›), whereğ›½is a function,
andA1,A2,...,Ağ‘›âˆˆğ‘‰are its arguments. A program is a string
ğ‘ƒâˆˆ(Î£âˆªğ‘‰)âˆ—, such thatğ‘†*=â‡’ğ‘ƒ.
178Example 4.1. The following grammar represents a subset of the
DSL used by UnchartIt.
ğ‘¡ğ‘ğ‘â†’summarize (ğ‘¡ğ‘ğ‘,ğ‘œğ‘ğ‘¡,ğ‘ğ‘œğ‘™ )|group_by (ğ‘¡ğ‘ğ‘,ğ‘ğ‘œğ‘™)|ğ‘¥0
ğ‘¡ğ‘ğ‘â†’count(ğ‘¡ğ‘ğ‘)|top_n(ğ‘¡ğ‘ğ‘,ğ‘ğ‘œğ‘™)|bottom_n (ğ‘¡ğ‘ğ‘,ğ‘ğ‘œğ‘™)
ğ‘œğ‘ğ‘¡â†’mean|median|sum
ğ‘ğ‘œğ‘™â†’1|2|3|4|5|6|7|8|9|10|...
where summarize ,group_by ,count,top_n,and bottom_n arefunc-
tions of the dplyr library for R, andğ‘¥0represents the programâ€™s
input. summarize (group_by (ğ‘¥0,1),mean,2)isanexampleofapro-
gram in this DSL. This program groups all the lines with the same
first column representation and for each group it computes the
mean of the numerical values in the second column.
OurfullDSLhasextraprimitivestosupportcommontabletrans-
formationsforbarcharts.Forinstance,itallowscleaningdataby
removing empty cells, supports ordering the values in a column,
normalization of values, and extraction of data within a given date.
Our DSL is functional, thus our programs do not contain loops.
Second, we wrote logical specifications for each library function
inourDSLusingaspropertiesthenumberofrows,columns,and
groups. These specifications are a complement to the DSL and
describe the relation on thenumber of columns, rows, and groups
betweentheinputandoutputtableafterusingalibraryfunction.
UnchartItcanthentakeadvantageofthepruningandlearning
techniquesimplementedinTrinityandpruneequivalentinfeasible
programs that share the same logical specifications.
Example 4.2. Consider the function summarise . This function
aggregates the data in each group, which is composed by a set
of rows. Let ğ‘Ÿ=summarise (ğ‘,mean,2)be the output of running
summarise ontable a.Foranyexecutionof summarise ,weknow
that the number of columns of the resulting table rwill be at most
thenumberofcolumnsintable a.Moreover,thenumberofrows
and groups in table rwill equal the number of groups in table
a. Hence, we can write the following logical specifications that
describetherelationonthenumberofcolumns,rowsandgroups
between table rand table a:
â€¢columns(r) â‰¤columns(a)
â€¢rows(r) = groups(a)
â€¢groups(r) = groups(a)
Third, since our output table has numerical imprecisions, we
modified the search of the program synthesizer to enumerate allprograms within a time limit that have an output table with thesame number of rows and columns as the extracted table. Even
thoughtheextractedtablehasnumericalimprecisions,theshape
ofthetableisusuallycorrect.Insteadofselectingasingleprogram,
UnchartIt maintains a list of programs that satisfies the row and
columnconstraints.Allprogramsarerankedusingthemetricsfrom
Section 5.
5 RANKING CANDIDATE SOLUTIONS
In order to rank the generated candidates, we assign a cost to each
program: the highest-ranking program is the program with the
lowest cost. In this section, we present two possible cost functions
to rank the candidate programs.Table 3: Re-scaled extracted
table.
col0col1
bar10.0106
bar20.3269
bar30.4901
bar40.6927
bar50.7644
bar60.2306Table 4: Re-scaled output ta-
ble.
year # complaints
2011 0 .0115
2012 0 .3282
2013 0 .4899
2014 0 .6929
2015 0 .7630
2016 0 .2301
Recall that the data extraction mechanisms described in Section
3 do not extract labels, only the bar values. Thus, we only consider
thenumericaldataextractedfromthecharttocalculateaprogramâ€™scost.Weproposetomeasurethequalityofprogramsbycomparing
the extracted bar values to those of the program output. Before
calculatingthecostoftheprogram,were-scalethebarvaluesusing
theaxismaximumandminimumvaluesofthechart.Thisscaling
allows us to have a standardized range of costs independent of the
chartâ€™sscale.Were-scaleeachbartoavaluebetween0and1using
the following function:
ğ‘“(ğ‘¦)=ğ‘¦âˆ’ğ¿
ğ»âˆ’ğ¿(5)
whereğ»andğ¿are the axis maximum and minimum values, re-
spectively. Two possible cost functions are the mean absolute error
(MAE) and the mean squared error (MSE).
MAE=1
ğ‘›ğ‘›/summationdisplay.1
ğ‘–=1|ğ‘“(ğ‘¦ğ‘–)âˆ’ğ‘“(Ë†ğ‘¦ğ‘–)|1(6)
MSE=1
ğ‘›ğ‘›/summationdisplay.1
ğ‘–=1|ğ‘“(ğ‘¦ğ‘–)âˆ’ğ‘“(Ë†ğ‘¦ğ‘–)|2(7)
whereğ‘›is the number of bars, ğ‘¦ğ‘–is theğ‘–â€™th bar value of the pro-
gramâ€™soutput,and Ë†ğ‘¦ğ‘–istheğ‘–â€™thbarvalueobtainedfromthedata
extraction mechanism.
Example5.1. Considerarecoverytaskwherethedataextraction
mechanismgeneratesTable1onthechartofFigure1b.Consider
also that a candidate program outputs Table 2 when applied to the
inputdata.Tocalculatetheprogramâ€™scostwestartbyre-scaling
thebarsâ€™values.Inthiscase,thechartâ€™smaximumandminimum
values areğ»=2.21Ã—105andğ¿=0, respectively. Thus, using
there-scalingfunction(5),wegetTables3and4.Usingthemean
absoluteerrorfrom(6),theprogramwouldhavethefollowingcost:
MAE=1
6/parenleftBig
|0.0106âˆ’0.0115|+|0.3269âˆ’0.3282|+
|0.4901âˆ’0.4899|+|0.6927âˆ’0.6929|+
|0.7644âˆ’0.7630|+|0.2306âˆ’0.2301|/parenrightBig
=0.00075
In order to rank the candidates, the cost of each program is
calculatedandthecandidatesareordered.Iftwodifferentprograms
have the same cost, the smaller program2is ranked higher.
2Aprogram P1isconsideredsmallerthanaprogram P2ifP1usesfeweroperators
from the DSL than P2.
1791 int main() {
2 int a = read(); // (ğ‘0=ğ›¼)
3 int b = read(); // (ğ‘0=ğ›½)
4 int c = 3; // (ğ‘0=3)
5
6 if(a+b == 3) // (ğ‘0+ğ‘0â‰ 3)=â‡’(ğ‘1=ğ‘0)
7 c += 10; // (ğ‘0+ğ‘0=3)=â‡’(ğ‘1=ğ‘0+10)
8 return c; // (ğ‘œP=ğ‘1)
9 }
Figure 6: Symbolic representation of a program in C.
6 PROGRAM DISAMBIGUATION
The proposed ranking functions are helpful in selecting promising
candidateprograms.However,insomecases,thehighestranked
program is not the desired solution. Therefore, given the top- ğ‘›
ranked programs, we propose to interact with the user in order to
select a program that corresponds to the userâ€™s intent.
This section starts by briefly reviewing Satisfiability Modulo
Theories (SMT) and how SMT can be used to formalize a symbolic
executionofaprogram.Next,twodifferentuserinteractionmodels
are presented. For each interaction model, we formalize how to
automatically generate an input test case that differentiates among
the candidateprograms.Finally,we refer how fuzzingtechniques
can also be used to this end.
6.1 Satisfiability Modulo Theories
The Satisfiability Modulo Theories (SMT) problem is a generaliza-
tionofthewell-knownPropositionalSatisfiability(SAT)problem.
Givenadecidablefirst-ordertheory T,aT-atomisagroundatomic
formulain T.AT-literaliseithera T-atomğ‘¡oritscomplement Â¬ğ‘¡.
AT-formulaissimilartoapropositionalformula,buta T-formula
is composed of T-literals instead of propositional literals. Given a
T-formulağœ™, the SMT problem consists of deciding if there exists
a total assignment over the variables of ğœ™such thatğœ™is satisfied.
Depending on the theory T, the variables can be of type integer,
real, Boolean, among other domains.
TheMaximum SatisfiabilityModulo Theories(MaxSMT) isthe
optimizationversionoftheSMTproblem.InMaxSMT,thegoalis
to find an assignment that optimizes a given objective function,
such that an SMT formula is satisfied. In the literature, MaxSMT is
sometimes definedovera setof hardand softformulas [ 30].How-
ever, it can also be defined as optimizing an objective function [ 5].
For ease of understanding, we use the latter formalization.
6.2 Symbolic Representation of Programs
Symbolic execution is a technique that allows executing a program
withsymbolicvaluesinsteadofconcretevalues.Inessence,givena
program P, one can build an SMT formula ğœ™Pthat represents the
symbolic execution of P. Hence,ğœ™Prepresents all possible execu-
tions of program Pwhen all possible input values are considered.
Example6.1. Considertheprogram PinFigure6withtwoinput
variables( aandb).TogenerateanSMTformulatorepresentthe
symbolic execution of P, we start by converting the program to a
staticsingleassignment(SSA)form.InSSAform,anewvariableiscreatedforeachassignmentintheprogram.Forexample,since
variablecisassignedtwice(lines4and7),wecreatetwoinstancesof
c:ğ‘0,andğ‘1,usedtorepresentthevalueof caftereachassignment.
Moreover, each input is assigned a symbolic value: ğ‘0=ğ›¼, and
ğ‘0=ğ›½.Notethatthesymbolicvalues ğ›¼andğ›½representallpossible
values that can be assigned to aandb, respectively. Finally, we
build the SMT formula that represents the programâ€™s execution
flow. For program Pthe formula is as follows:
ğœ™P:=(ğ‘0=ğ›¼)âˆ§(ğ‘0=ğ›½)âˆ§(ğ‘0=3)âˆ§
((ğ‘0+ğ‘0â‰ 3)=â‡’(ğ‘1=ğ‘0)) âˆ§
((ğ‘0+ğ‘0=3)=â‡’(ğ‘1=ğ‘0+10))
(ğ‘œP=ğ‘1)
Symbolic execution is often used to check a given property of a
program.Let Pbeaprogramand ğ‘œPdenotesthesymbolicrepre-
sentation of the return value of P. It is possible to check if there is
anexecution of Pthatreturns 0by usingan SMTsolver tocheck
the satisfiability of ğœ™ğ‘Ÿğ‘’ğ‘¡0, whereğœ™ğ‘Ÿğ‘’ğ‘¡0=ğœ™Pâˆ§(ğ‘œP=0). Observe
thatiftheSMTsolverfinds ğœ™ğ‘Ÿğ‘’ğ‘¡0tobeunsatisfiable,thenthereis
no inputof Psuch that Preturns 0.Otherwise, ifthe SMT solver
provides a satisfying assignment for ğœ™ğ‘Ÿğ‘’ğ‘¡0, then the assignment to
thesymbolicrepresentationoftheinputsof Pcontainstheconcrete
input values (i.e. the input test case) for when Preturns 0.
Symbolicexecutioncanalsobeusedtodifferentiatebetweentwo
programs P1andP2.Letğœ™Pğ‘–betheSMTformulathatcorresponds
tothesymbolicexecutionofprogram Pğ‘–.Letğ¼ğ‘–representtheinput
andğ‘œğ‘–the output of Pğ‘–. Hence, we can built a formula ğœ™ğ‘’ğ‘such as:
ğœ™ğ‘’ğ‘=ğœ™P1âˆ§ğœ™P2âˆ§(ğ¼1=ğ¼2)âˆ§(ğ‘œ1â‰ ğ‘œ2) (8)
Observe that if ğœ™ğ‘’ğ‘is satisfiable, then there is an input test case for
whichP1andP2providedifferentoutputs.Asaresult,onecanask
theusertoanswerwhichisthecorrectoutputanddisambiguate
betweenP1andP2. Otherwise, if ğœ™ğ‘’ğ‘is unsatisfiable,then there is
no input test case that differentiates between P1andP2and the
programs are deemed equivalent.
6.3 User Interaction Models
UnchartItisabletorankcandidateprograms,butthebestranked
programmightnotcorrespondtotheuserâ€™sintent.Moreover,itcanoccurthattherankingvalueisthesamefortwodifferentprograms.
Hence, our goal is to interact with the user in order to correctly
select the desired program among the top ranked candidates.
In UnchartIt, we define two different user interaction mod-
els.TheOptionsmodelshowstheuseraninputtable,aswellas
several output options corresponding to the output of candidate
programs for that input table. In this case, the user selects the cor-
rectoutputamongtheseveraloptions.Iftheselectedoutputstill
correspondstotheoutputofseveralcandidateprograms,additional
roundsofquestionsareperformedtodisambiguatesolelyamong
those programs. In the Options model, ideally, there is a single
inputtable suchthateach candidateprogramproduces adifferent
output. In this best-case scenario, a single question is sufficient to
disambiguateamongthecandidateprograms.Ontheotherhand,
theOptionsmodelrequirestheusertosolvetheproblemforthe
given input table in order to select the correct option.
180min.ğ‘›/summationdisplay.1
ğ‘–=1ğ‘›/summationdisplay.1
ğ‘—=ğ‘–+1ğ‘ğ‘–ğ‘— (9)
s.t.ğœ™P1âˆ§...âˆ§ğœ™Pğ‘›(10)
âˆ€ğ‘–,ğ‘—âˆˆ{1..ğ‘›},ğ‘–<ğ‘—:ğ¼ğ‘–=ğ¼ğ‘— (11)
âˆ€ğ‘–,ğ‘—âˆˆ{1..ğ‘›},ğ‘–<ğ‘—:(ğ‘œğ‘–=ğ‘œğ‘—)â‡”(ğ‘ğ‘–ğ‘—) (12)
ğ‘›/logicalordisplay.1
ğ‘–=1ğ‘›/logicalordisplay.1
ğ‘—=ğ‘–+1Â¬ğ‘ğ‘–ğ‘— (13)
Figure 7: Input generation for the Options model.
UnchartIt also implements the Y/N user interaction model. In
thiscase,theuserispresentedwithaninputtableandanoutput.
Next,theuseranswersyesorno,dependingiftheoutputiscorrect
for that input table. Note that the user only needs to check the
correctness of a single output option. In the Y/N model, the goal is
to split the set of candidate programs in two, such that the output
ofhalfthecandidateprogramsmatchestheproposedoutput,while
theotherhalfproducesadifferentoutput.Ifitisalwayspossible
to split the set of programs in two, the number of questions in the
Y/N interaction model would be ğ‘‚(ğ‘™ğ‘”(ğ‘›)).
6.4 Model Formalization
Section 6.3 presented the Options and the Y/N user interaction
modelsimplementedinUnchartIt.Inthissection,weproposetwo
MaxSMT formalizations that allow us to automatically generate
input examples for both user models.
In the Options user model, in order to minimize the number of
userinteractions,thegoalistofindasmallinputtestcasesuchthat
allthetop-ğ‘›rankedprogramsprovideadifferentoutput.Figure7
presents a MaxSMT formulation to solve the problem of finding
an input that maximizes the pairwise differences between the ğ‘›
programstodisambiguate.Inthisformula,weencodethesymbolicrepresentationofall
ğ‘›candidateprograms(10)andforcetheinputof
allprogramstobethesame(11).Moreover,foreachpairofprograms
Pğ‘–andPğ‘—wecreateaBooleanvariable ğ‘ğ‘–ğ‘—thatisassignedto1if
and only if the outputs of programs Pğ‘–andPğ‘—are the same (12).
Note that inputs that do not differentiate any pair of programs are
excluded(13).Sincethegoalistominimizethenumberofvariables
ğ‘ğ‘–ğ‘—assignedto1(9),anyoptimalsolutionofthisformulationwill
findanassignmenttotheinputvariables ğ¼ğ‘–(correspondingtoan
inputtestcase)thatmaximizesthepairwisedifferencebetweenthe
ğ‘›programs. Ideally, the solution for the formulation in Figure 7
contains all variables ğ‘ğ‘–ğ‘—assigned value 0.
On the Y/N interaction model, the goal is to identify an input
testcaseğ¼suchthatthesetof ğ‘›programsissplitintotwosets ğ´
andğµwith halfprograms in eachset. Moreover, fortest case ğ¼, all
programs Pğ‘–âˆˆğ´would provide the same output Pğ‘–(ğ¼), and all
programs Pğ‘—âˆˆğµwould provide a different output (i.e. Pğ‘–(ğ¼)â‰ 
Pğ‘—(ğ¼)) than the programs in ğ´.
Figure8containsaformulationthatsplitsagivensetof ğ‘›pro-
gramsintotwosets( ğ´andğµ).Asinthepreviousmodel,thisformu-
lation includesthe symbolicrepresentation ofall ğ‘›programs (15),
theprograminputsareconstrainedtobethesame(16)andBooleanmin./barex/barex/barex/barex/barexğ‘›/summationdisplay.1
ğ‘–=1ğ‘ğ´
ğ‘–âˆ’ğ‘›/summationdisplay.1
ğ‘–=1ğ‘ğµ
ğ‘–/barex/barex/barex/barex/barex(14)
s.t.ğœ™
P1âˆ§...âˆ§ğœ™Pğ‘›(15)
âˆ€ğ‘–,ğ‘—âˆˆ{1..ğ‘›},ğ‘–<ğ‘—:ğ¼ğ‘–=ğ¼ğ‘— (16)
âˆ€ğ‘–,ğ‘—âˆˆ{1..ğ‘›},ğ‘–<ğ‘—:(ğ‘œğ‘–=ğ‘œğ‘—)â‡”(ğ‘ğ‘–ğ‘—) (17)
âˆ€ğ‘–,ğ‘—âˆˆ{1..ğ‘›},ğ‘–<ğ‘—:(ğ‘ğ‘–ğ‘—)â‡’/parenleftBig
(ğ‘ğ´
ğ‘–âˆ§ğ‘ğ´
ğ‘—)âˆ¨(ğ‘ğµ
ğ‘–âˆ§ğ‘ğµ
ğ‘—)/parenrightBig
(18)
âˆ€ğ‘–,ğ‘—âˆˆ{1..ğ‘›},ğ‘–<ğ‘—:(Â¬ğ‘ğ‘–ğ‘—)â‡’( Â¬ğ‘ğ´
ğ‘–âˆ¨Â¬ğ‘ğ´
ğ‘—) (19)
âˆ€ğ‘–âˆˆ{1..ğ‘›}:ğ‘ğ´
ğ‘–+ğ‘ğµ
ğ‘–=1 (20)
ğ‘›/summationdisplay.1
ğ‘–=1ğ‘ğµ
ğ‘–â‰¤ğ‘›âˆ’1 (21)
Figure 8: Input generation for the Y/N model.
variablesğ‘ğ‘–ğ‘—are assigned to 1 if and only if the output of program
Pğ‘–is equal to the output of program Pğ‘—(17). Additionally, for each
program Pğ‘–two new Boolean variables are created ğ‘ğ´
ğ‘–andğ‘ğµ
ğ‘–,
denoting if program Pğ‘–belongs to set ğ´or to setğµ, respectively.
Inourformulation,iftwoprograms Pğ‘–andPğ‘—producethesame
output, then they both have to be assigned to the same set (18).
Moreover, if two programs Pğ‘–andPğ‘—produce different outputs
(i.e. variable ğ‘ğ‘–ğ‘—is 0), then at most one of them can be in set ğ´(19).
Therefore,asaresultofconstraints(18)and(19),allprogramsin
setğ´mustproducethesameoutput.Furthermore,eachprogram
must be assigned to one and only one set (20). Constraint (21)is used to make sure that if there is an input that differentiates
among programs, then not all programs are assigned to set ğµand a
partitionisproduced.Finally,ourformulationâ€™sgoalistominimize
the difference between the number of programs in each set (14).
6.5 Input Constraints
Inthesymbolicrepresentationofaprogram,eachinputisassociated
withasymbolicvaluethatrepresentsanarbitraryconcretevalue
thatcanbeassignedtothatinput.Sincetheinputsofourprogramsare tables, each symbolic value represents a table with a number ofrowsandcolumns.However,allowinginputtableswithanarbitrarystructurecanbeaproblem.Forinstance,itwouldnotbefeasibleto
ask the user to verify or select the correctoutput for a large input
table.Therefore,weimposerestrictionsonthestructureoftheinput
tables we allow in the symbolic representation of our programs. In
our case, the columns are restricted to those that are relevant inat least one of the programs to disambiguate. For instance, if we
want to disambiguate 2 programs that only use the first and the
lastcolumnsoftheinputtable,thentheinputtabletobegeneratedonlycontainsdataforthose2columns.Moreover,sincewewanttoobtainsmallinputtables,thenumberofrowsmustalsobebounded.
Thetableâ€™scontentmustalsoberestrictedsinceeachtableentry
should be associated with a meaningful value to the user. For in-
stance,iftheuserexpectsagivencolumntocontaincountrynames,
then the only concrete values we should allow on that column are
country names. In order to generate inputs that are familiar to the
user, we base our distinguishing inputs on the input table the user
181provided. In UnchartIt, the following rules are used to decide
theavailablevaluesforeachcolumn:(a)incolumnsofstringswe
restricttheavailablevaluestothosepresentintherespectivecol-
umn of the input table; (b) in columns of integers, floats, and dates
we restrict the values to the interval between the minimum and
maximum values of the respective column of the input table.
6.6 Input Generation
The MaxSMT formulations proposed in section 6.4 give us a theo-
retical guarantee that the resulting distinguishing input is the best
possible input for the respective interaction model. However, an
issue with both approaches is that our MaxSMT formulas growexponentially with the number of programs to disambiguate. In
scenarios where it is necessary to disambiguate a large number of
programs,one mightsacrifice optimalityin orderto haveamean-
ingful user interaction.
Thereisaplethoraofinputgenerationmethodscommonlyused
for program testing [ 9]. For example, in the context of UnchartIt,
onecouldapplydeltadebugging[ 42,43]ontheexampleinputtable
to try to generate a smaller input table that would differentiate the
programs. However, the input tables provided in our test cases can
be very large, resulting in a very time-consuming procedure.
Anotheralternativeistousefuzzing-basedmethods[ 31].Instead
of building a MaxSMT formula, we can generate random inputs
(guidedby theexample inputtable)until wefindan optimalsolu-
tion for a given interaction model or a time limit is reached. For
example,usingtheOptionsinteractionmodel,wecanrandomly
generateinputsuntilanexamplethatdisambiguatesallprograms
is found. Otherwise, if atime limit is reached, the generated input
thatsplitstheprogramsinalargernumberofsetsisreturned.In
UnchartIt, this technique was also implemented as a stand alone
method to disambiguate programs. Moreover, a hybrid method
was also developed that first applies fuzzing-based techniques and
then applies the proposed MaxSMT models when the number of
programs to disambiguate is small.
7 EXPERIMENTAL RESULTS
In order to evaluate our approach, we collected 50 benchmarksfrom
Kaggle,3a popular website for data scientists with diverse
open datasets. Each benchmark is comprised of a pair (table, barchart). The experimental results presented in this section aim to
answer the following research questions:
Q1.HoweffectivelycanUnchartItrecoverprogramsfromreal
data?
Q2.How long do we have to explore the search space to find
good candidates?
Q3.How does the Neural Network approach compare to the
WebPlotDigitizerâ€™s approach?
Q4.How many questions do we have to ask the user in orderto distinguish the best ranking programs, using the two
interaction models?
The results described herein were obtained from an Intel(R)
Xeon(R) CPU E5-2630 v2 @ 2.60GHz, with 64GB of RAM, running
Debian GNU/Linux 10.
3https://www.kaggle.com/Implementation. UnchartItintegratesseveraltoolsandtech-
nologies. In particular, our neural data extraction mechanism is
implementedusingtheKerasframework[ 6].Furthermore,ourcan-
didategeneratorisimplementedontopoftheTrinitysynthesis
framework[ 28].Whilethecandidategeneratorusesthe Rlanguage
(version 3.5.2), the program disambiguation is performed in C. For
that,allofourDSLoperatorshaveanequivalentimplementation
inCso that the symbolic representation of the programs can be
generated using CBMC [ 7], a Bounded Model Checker for C. Since
CBMCgeneratesBooleanformulas,thefinalMaxSMTformulaonlycontainsBooleanvariables.Asaresult,theOpen-LinSBPS[
8]solver
was used instead of a generic MaxSMT solver. Finally, the number
of rows of the generated input tables was bounded to 5.
Benchmarks. The average and median size of the input table
filesis16.52MBand1MB,respectively.However,therearemuch
largerinstancesinourbenchmarkset.Themotivationalexample
in Section 2 has one of the largest input tables (Table 1a), con-taining 175
.39MB,715,437rows and 18 columns. Moreover, the
median number of rows and columns is 10,841and 13, respectively,
whereas the mean number of rows and columns is 71,293.92and
17.66, respectively. Regarding the bar charts, the number of bars of
eachchartvariesbetween2and15bars.Everysolutioninvolvesgrouping the data by some column, and then summarizing each
groupusinganaggregatefunction(e.g., median,minormax).Some
solutions require operations such as calculating the days between
two dates or filtering nullvalues. It might also be necessary to
normalizethevaluesofanumericalcolumn,orselectingonlythe
top ranking rows.
DataExtraction. Whenevaluatingadataextractionprocedure
for bar charts we must consider its two outputs: the number ofbars, and the barsâ€™ values. Thus, to measure its accuracy we usetwo metrics: the percentage of plots in which the procedure suc-
cessfullyretrievedthenumberofbars,andthemeanabsoluteerrorof the barâ€™s values. To test both WebPlotDigitizer and the neural
network we used the bar charts of the benchmarks.
Recall that WebPlotDigitizer requires a considerable amount
of input. Before extracting the barsâ€™ values, it is necessary to mark
the pixel location of two different points along the vertical axis of
eachbarchartandthevaluesoftherespectivepoints.WebPlotDig-
itizerâ€™sbarextractionalgorithmalsorequirestuningparameters
before extracting the bars. It was found that the parameters that
worked best with our benchmarks were Î”ğ‘¥=30 and Î”ğ‘£ğ‘ğ‘™=500.
Using these parameters, WebPlotDigitizer successfully retrieved
the number of bars in 96% of the instances and achieved a mean
absolute error of 0 .002201.
Toevaluatetheaccuracyoftheneural-baseddataextraction,we
trained an adapted version of the EfficientNet-B1. We generateda set of
90,000bar charts of various forms and split it into train-
ing(90%)andvalidation(10%)sets.Totrainthenetwork,weused
RAdam [27] coupled with Lookahead [ 44] using the default param-
etersoftherespectivepapers.Weusedbatchsizesof 15andamax-
imumnumberofepochsof100,butweperformedearlystopping
oncethevalidationlossstoppeddecreasing.Onthebenchmarks,
EfficientNet-B1retrievedthe correctnumberofbars in 92%ofthe
instances. Considering the mean absolute error, the network has a
182024681 05060708090100
Timeout (min)Instances solved (%)top-1
top-3
top-5
top-10
Figure 9: Success rate with different timeouts, using Web-
PlotDigitizer and the MAE ranking.
Table 5: Success rate for a time limit of 3 minutes.
WebPlotDigitizer EfficientNet-B1
MAE MSE MAE MSE
top-1 88% 86% 66% 66%top-3 90% 88% 72% 72%top-5 90% 88% 76% 74%top-10 92% 92% 78% 80%
meanabsoluteerrorof0 .037356.AlthoughtheadaptedEfficientNet-
B1 is not as accurate as WebPlotDigitizer, it is important to note
that it requires significantly less input from the user.
Candidate Generation and Ranking. Since it is not feasible to
explore the whole program space, UnchartIt terminates whena given time limit is reached. In Figure 9, we show the success
rate for different timeouts. The top-1, top-3, top-5, and top-10 lines
showthenumberofbenchmarksinwhichthecorrectsolutionwas
rankedfirst(top-1),amongthefirstthree(top-3),five(top-5),and
ten (top-10) programs, respectively. We can see that UnchartIt
performsbestwhenusingatimeoutof3minutes,anditdoesnot
improvethereafter.Infact,thepercentageofcorrectprogramsin
top-1 decreases with higher time limits. This occurs due to the
fact that ifwe explore the searchspace longer, weare more prone
to finding programs that overfit to the cost function (especially
programswithahighnumberoflines).Moreover,theremightbe
other programswith more linesof codethat are equivalentto the
overfitting (e.g., adding a filter operation that does nothing on the
inputtable).Sincethesespuriousprogramshavethesamecostof
theoverfittingprogram,theypushthesolutiondownwards.Overall,
UnchartIt is able to find programs up to 7 lines of code within
the time limit, which is the same order to magnitude as other state
of the art tools for table manipulation [14].Table 5 shows the success rate with a timeout of 3 minutes,
using the two data extraction mechanisms, and the two ranking
functions.Wecanseethatbothrankingfunctionsperformsimilarly,
regardless of the data extraction mechanism. The correct solution
is the top ranked program in 88% of the instances when using
WebPlotDigitizer, and the MAE ranking function. Using the
adaptedEfficientNet-B1neuralnetworkweobtainslightlyworse
results.Nonetheless,wecanstillrankthecorrectsolutiononthe
top-10 in 80% of the instances. When using WebPlotDigitizer
this value increases to 92%. Recall that WebPlotDigitizer is moreprecisethanEfficientNet-B1withrespecttothenumericalextracted
values and number of extracted bars. However, EfficientNet-B1 is a
fully automated process, while WebPlotDigitizer needs the user
toindicatethepreciselocationoftwopixelsinthechartimageand
tune some parameters before extracting data.
Inthebestperformingapproach(WebPlotDigitizer+MAE),
there are 8% instances in which a correct solution was not ranked
among the top-10. These benchmarks correspond to 2 instances in
whichthenumberofbarswasincorrectlyextractedand2instances
in which 3 minutes is not sufficient to find a correct candidate.
Program Disambiguation. To ascertain that UnchartIt returns
a correct program, the top-10 ranking programs are to be disam-
biguatedbyinteractingwiththeuser.UnchartItintegratestwo
interaction schemes: the Options and the Y/N model. For each
model, questions can be generated using the following approaches:
(1) MaxSMT; (2) Fuzzing; (3) Hybrid Approach. In the hybrid ap-
proach, we combine fuzzing and MaxSMT as follows: if we need to
disambiguatemorethan5programs,thenweusefuzzing.Other-
wise, we use MaxSMT. In our experiments, we consider the top-10
programs(using WebPlotDigitizer)generated foreach instance.
Fromthe50instances,weconsider48instances,sinceforonein-
stance we only generated one candidate, and there was another
instance for which we did not generate a single candidate.
Figure 10 shows the average time necessary to generate the best
possible question with a timeout of 3 minutes per question. We
canseethatwhenusingfuzzing,weeitherfindthebestquestion
veryquickly,orwecannotfinditwithinthetimelimit.Inthe Op-
tionsmodel,fuzzingcanonlystopearlywhenitfindsaninputtest
caseforwhichallprogramsprovideadifferentoutput.However,thatinputtestcasemightnotexist.ThesameoccursfortheY/Nmodel, where an input test case that splits the set of programs
inhalfmightnotexist.However,theproposedMaxSMTformula-
tion is able to detect these cases. We can also see that the hybrid
approachgeneratesquestionsfasterthantheMaxSMTapproach.
ThishappensbecausetheformulasgeneratedbyCBMCgrowexpo-
nentially with the number of programs to disambiguate. Thus, the
firstMaxSMTcallusuallytakesmuchlongerthantheremaining
calls.However,fuzzingisparticularlyeffectivewhenthenumber
ofprogramsislarger.Hence,byusingfuzzinginthefirstcall,we
reduce the time necessary to generate the first question, thereby
reducing the average time to generate all questions.
Table6 presentsstatisticsonthenumberofquestionsaskedto
theuserusingthetwointeractionmodelsandthethreedifferent
implementations.Observethatwecandisambiguate47outofthe48instancesusingthehybridapproach.Althoughtheaveragenumber
18312 24 36 4810âˆ’1100101102103
Instances solvedAverage time (s)MaxSMT Y/N
MaxSMT Options
Fuzzing Y/N
Fuzzing Options
Hybrid Y/N
Hybrid Options
Figure10:Averagetimenecessarytogenerateaquestionus-
ing the different interaction models and implementations.
Table 6: Median ( Ëœğ‘¥), mean (ğ‘¥), standard deviation ( ğœ) of the
numberofquestionsasked.Numberofinstancessolved( ğ‘›).
MaxSMT Fuzzing Hybrid
Options Y/N Options Y/N Options Y/N
Ëœğ‘¥1 31 31 3
ğ‘¥1.53 3.28 1.17 3 1.32 3.23
ğœ0.631 0.854 0.537 0.698 0.556 0.813
ğ‘›43 43 42 42 47 47
of questions using fuzzing is slightly smaller, fuzzing can only dis-
ambiguate42instances,sinceitcannotprovetheboundedprogramequivalence.Thus,fuzzingpresentsinconclusiveresultstotheuser
in 6 instances. The same happens to the MaxSMT approach, where
sometimesthegiventimelimitisnotenoughtoprovetheprogram
equivalence for the bounded input.
Threats to Validity. Since our tool is limited to bar charts, our
techniques maynot generalize forother typesof charts.For other
typesofcharts,thedataextractionstagemustbeadapted.However,
ifthedataextractionprocedurefromothercharttypesresultsin
imprecisions similar to those found in bar charts, one can expect a
similar success rate.
The other issue is the simulation of the user interaction. In this
paper, we assume the user would select the correct answer in each
question.However,itisnotclearhowdifficultitisfortheuserto
answerthegeneratedquestions,sinceanempiricalstudyofuser
interaction was not performed. Additionally, we bound the time
limit to 3 minutes in order to generate a question. For tighter time
limits,theMaxSMTsolvermightproduceasolutionthatisfarfrom
optimal. As an alternative, an incomplete solver might be usedinstead. In general, incomplete solvers cannot prove optimality,
but are able to provide a good enough solution within tighter time
limits.8 RELATED WORK
In this section, we briefly discuss prior work that is closely related
toourapproach,inthecontextofprogramverification,program
synthesis, and interactive program synthesis.
8.1 Program Verification
The goal of program verification is to formally prove that a cer-
tain specification or property holds for all executions of the pro-gram. The last few decades have seen a significant improvementin verification tools based on SAT and SMT [
4]. In this work, we
leverage bounded model checking tools [7, 16] to either prove the
equivalencebetweenprogramsorfindacounterexamplethatdis-
ambiguatestheprograms.Inourcontext,sincethetablesforthe
disambiguation phase are small, it is possible to completely unroll
all loops and check if programs are equivalent to a bounded input.
Even though program equivalence of C programs has been studied
before[12,18,19],tothebestofourknowledgethisisthefirstappli-
cation of it for disambiguation of programs written in a real-world
programming language in the context of program synthesis.
8.2 Program Synthesis
Programsynthesizersfortabletransformationsworkbycombining
enumerative search and pruning techniques over a space of pro-
gramsdefinedbyaDSL.Scythe[ 39]generates SQLqueriesfrom
examples and prunes the search using equivalence classes. Mor-
pheus[14]synthesizestabletransformationsforthe Rlanguageand
uses logical specifications for each library function combined with
SMT-based reasoning to prune the search space. Neo [ 13] general-
izesMorpheustootherdomainsandincorporateslearningfrom
failed synthesis attempts which further prunes the search space.
Trinity [ 28] is a program synthesizer framework that makes it
easiertobuildnewprogramsynthesizerswhiletakingadvantageof
pruning and learning techniques based on SMT reasoning [ 13,14].
Viser [40] is built on top of Trinity for the domain of plot
visualization. It takes as input a table and a trace that partially
describes the plot. For instance, in the case of a bar chart, the trace
describestheheightofsomebars.ThespecificationusedinViserisnotasstrongasintraditionalPBEsystemssinceitdoesnotinvolve
aconcreteoutputtablebutasetoftableinclusionconstraints.In
contrast,UnchartIttakesasinputachartimageinsteadofatrace.
Given a chart image, we perform data extraction and our outputtable will have numerical imprecisions that are not part of theresult of the table transformation program. Moreover, since we
aretacklingtheproblemofrecoveringdatatransformationsfrom
existing plots, the user would not be able to provide the trace of
the plot required by Viser.
Another application of program synthesis to visualization is
theinferenceofgraphicsprogramsfromhand-drawnimagesand
synthesisofthecorrespondingL ATEXcodethatgeneratesthatim-
age[11].Thisapproachcombinestechniquesfromdeeplearning
and program synthesis. They learn a convolutional neural network
that proposes a set of traces in the form of primitive drawings
(e.g.,line,circle,rectangle)thatexplainstheimage.Theseprimitive
drawings serve as specification, and a program synthesizer is then
usedtogenerateaprogramthatgeneralizesthesetraceswithcondi-
tionals and loops. Even though our approach can also use a neural
184network for data extraction, our synthesis goal is very different
since it requires a sequence of table transformation operations and
not trace generalization.
8.3 Interactive Program Synthesis
Since PBE systems have incomplete specifications, it is often re-
quiredtodoaninteractivestepwiththeuserinordertofindthe
correct program. There are different forms of user interaction, but
the most commonly used by program synthesizers are: (i) the user
providesadditionalexamplestotheprogramsynthesizeruntilthere
is no more ambiguity [ 29,41], (ii) the synthesizer returns a ranked
list of programs to be selected by the user [ 17,26,41], (iii) the
synthesizer creates a distinguishing input and asks the user for
feedback [29, 32, 38].
There are different ways to create a distinguishing input, i.e. an
input for which at least two programs have a different output. One
approach is to randomly generate distinguishing inputs [ 29,38].
ThisissimilartoourinputgenerationapproachdescribedinSec-
tion 6.6. Another approach that is closer to our work is done by Ji
et al. [22]. They sample the space of valid programs and encode
the problem into SMT to determine an input that minimizes the
numberofprogramsthathavethesameoutputforagiveninput.
Afterward, they ask the user to provide the correct output for that
input.ThisapproachissimilartoourOptionsmodelwherewealso
minimize thenumber of differentoutputs for thesame input. Our
interactive approach can be seen as a generalization of Ji et al. [ 22]
work.First,weshowhowtoformalizetheoptimizationproblem
withMaxSMT.Second,weshowthatdifferentuserinteractionscan
be formalized in this way, namely the Options and Y/N user inter-
actionmodels.Third,weusesymbolicmodelcheckingtoencode
programs written in real-world programming languages to SMT,
whereas the previous approach uses programs from the Syntax-
GuidedSynthesisCompetition(SyGuS)[ 1]thatareexpressedusing
the SMT language and restricted to SMT constructs.
9 CONCLUSIONS AND FUTURE WORK
Data visualization is crucial for data analysts. However, many data
analystsarenotproficientprogrammersanditisoftenthecasethat
data analysts are unable to generate a given chart from the data.
Themaincontributionofthispaperisacomprehensiveapproach
to handle the problem of recovering data transformations from
charts. UnchartIt receives the input data and an output chart
(generated from the input data) and can automatically find the
underlyingtabletransformationtobuildthechart.Experimental
results on real data from Kaggle show that UnchartIt can findand rank the correct program in the top-10 programs in 92% ofinstances. To reduce the ambiguity of the programs returned by
UnchartIt,wedevelopedanewinteractivesynthesisprocedure
thatcandisambiguate98%oftheambiguousinstancesbyasking
on average fewer than 2 questions to the user.
UnchartIt is the first tool for automatic generation of data
transformationsthatdirectlyusesvisualelements.Anintegrated
prototype of our tool will become available online soon.4
Forfuturework,weproposetoextendUnchartItwithother
visual elements in the input examples besides bar charts. Ideally,
4http://sat.inesc-id.pt/unchartit/oneshouldbeableto useanhand-drawnimageofachartinstead
ofadigitalchartimage.Currently,thechartlabelsarenotyetused.However, labels provide useful information on the chart interpreta-tion.Hence,wealsoproposetoextendthedataextractionmodeltoidentify and use the labels in the chart image to direct the program
synthesis process.
ACKNOWLEDGMENTS
This work was partially supported by NSF award number 1762363
andbyPortuguesenationalfundsthroughFCT,FundaÃ§Ã£oparaaCiÃªnciaeaT e cnologia, under PhD grant SFRH/BD/150688/2020
and projects UIDB/50021/2020, DSAIPA/AI/0044/2018, and project
ANI 045917 funded by FEDER and FCT.
REFERENCES
[1]Rajeev Alur, Rastislav BodÃ­k, Eric Dallal, Dana Fisman, Pranav Garg, Garvit
Juniwal, Hadas Kress-Gazit, P. Madhusudan, Milo M. K. Martin, Mukund
Raghothaman,ShambwadityaSaha,SanjitA.Seshia,RishabhSingh,Armando
Solar-Lezama, Emina Torlak, and Abhishek Udupa. 2015. Syntax-Guided Synthe-
sis. InDependable Software Systems Engineering. IOS Press, 1â€“25.
[2]Matej Balog, Alexander Gaunt, Marc Brockschmidt, Sebastian Nowozin, and
DanielTarlow.2017. DeepCoder:LearningtoWritePrograms.In Proc.Interna-
tional Conference on Learning Representations.
[3]Leilani Battle, PeitongDuan, Zachery Miranda,Dana Mukusheva,Remco Chang,
and Michael Stonebraker. 2018. Beagle: Automated Extraction and Interpreta-
tion of Visualizations from the Web. In Proc. Conference on Human Factors in
Computing Systems. ACM, 594.
[4]Dirk Beyer, Matthias Dangl, and Philipp Wendler. 2018. A Unifying View on
SMT-BasedSoftwareVerification. JournalofAutomatedReasoning 60,3(2018),
299â€“335.
[5]Nikolaj BjÃ¸rner, Anh-Dung Phan, and Lars Fleckenstein. 2015. ğœˆZ - An Optimiz-
ing SMT Solver. In Proc. International Conference on Tools and Algorithms for the
Construction and Analysis of Systems. Springer, 194â€“199.
[6] FranÃ§ois Chollet et al. 2015 (accessed May 8, 2020). Keras. https://keras.io.[7]
EdmundM.Clarke,DanielKroening,andFlavioLerda.2004. AToolforChecking
ANSI-CPrograms.In Proc.InternationalConferenceonToolsandAlgorithmsfor
the Construction and Analysis of Systems. Springer, 168â€“176.
[8]Emir Demirovic and Peter J. Stuckey. 2019. Techniques Inspired by Local Search
for Incomplete MaxSAT and the Linear Algorithm: Varying Resolution and
Solution-Guided Search. In Proc.International ConferencePrinciples andPractice
of Constraint Programming. Springer, 177â€“194.
[9]Frank Elberzhager, Alla Rosbach, JÃ¼rgen MÃ¼nch, and Robert Eschbach. 2012.Reducing test effort: A systematic mapping study on existing approaches. Inf.
Softw. Technol. 54, 10 (2012), 1092â€“1106.
[10]KevinEllisandSumitGulwani.2017. LearningtoLearnProgramsfromExamples:
Going Beyond Program Structure. In Proc. International Joint Conference on
Artificial Intelligence. ijcai.org, 1638â€“1645.
[11]KevinEllis,DanielRitchie,ArmandoSolar-Lezama,andJoshTenenbaum.2018.
Learning to Infer Graphics Programs from Hand-Drawn Images. In Proc. Annual
Conference on Neural Information Processing Systems. 6062â€“6071.
[12]Dennis Felsing, Sarah Grebing, Vladimir Klebanov, Philipp RÃ¼mmer, and Mat-tias Ulbrich. 2014. Automating regression verification. In Proc. International
Conference on Automated Software Engineering. ACM, 349â€“360.
[13]Yu Feng, Ruben Martins, Osbert Bastani, and Isil Dillig. 2018. Program synthesis
usingconflict-drivenlearning.In Proc.ACMSIGPLANConferenceonProgramming
Language Design and Implementation. ACM, 420â€“435.
[14]YuFeng,RubenMartins,JacobVanGeffen,IsilDillig,andSwaratChaudhuri.2017.Component-basedsynthesisoftableconsolidationandtransformationtasksfrom
examples. In Proc. ACM SIGPLAN Conference on Programming Language Design
and Implementation. ACM, 422â€“436.
[15]JohnK.Feser,SwaratChaudhuri,andIsilDillig.2015. Synthesizingdatastructure
transformations from input-output examples. In Proc. ACM SIGPLAN Conference
on Programming Language Design and Implementation. ACM, 229â€“239.
[16]Mikhail R. Gadelha, Felipe R. Monteiro, Jeremy Morse, Lucas C. Cordeiro, Bernd
Fischer, and Denis A. Nicole. 2018. ESBMC 5.0: An Industrial-Strength C Model
Checker. In Proc. International Conference on Automated Software Engineering.
ACM, 888â€“891.
[17]Joel Galenson, Philip Reames, Rastislav BodÃ­k, BjÃ¶rn Hartmann, and Koushik
Sen.2014. CodeHint:dynamicandinteractivesynthesisofcodesnippets.In Proc.
International Conference on Software Engineering. ACM, 653â€“663.
[18]Benny Godlin and Ofer Strichman. 2008. Inference rules for proving the equiva-
lence of recursive procedures. Acta Informatica 45, 6 (2008), 403â€“439.
185[19]Benny Godlin and Ofer Strichman. 2009. Regression verification. In Proc. Design
Automation Conference. ACM, 466â€“471.
[20]Sumit Gulwani. 2011. Automating string processing in spreadsheets using input-
output examples. In Proc. ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages. ACM, 317â€“330.
[21]SumitGulwani,OleksandrPolozov,andRishabhSingh.2017. ProgramSynthesis.
Foundations and Trends in Programming Languages 4, 1-2 (2017), 1â€“119.
[22]Ruyi Ji, Jingjing Liang, Yingfei Xiong, Lu Zhang, and Zhenjiang Hu. 2020. Ques-
tion Selection for Interactive Program Synthesis. In Proc. ACM SIGPLAN Confer-
ence on Programming Language Design and Implementation. ACM.
[23]Zhongjun Jin, Michael R. Anderson, Michael J. Cafarella, and H. V. Jagadish.
2017. Foofah: TransformingDataBy Example.In Proc.International Conference
on Management of Data. ACM, 683â€“698.
[24]DaekyoungJung,WonjaeKim,HyunjooSong,JeonginHwang,BongshinLee,
BoHyoungKim,andJinwookSeo.2017. ChartSense:InteractiveDataExtraction
from Chart Images. In Proc. Conference on Human Factors in Computing Systems.
ACM, 6706â€“6717.
[25]Dmitri V. Kalashnikov, Laks V. S. Lakshmanan, and Divesh Srivastava. 2018.
FastQRE:FastQueryReverseEngineering.In Proc.InternationalConferenceon
Management of Data. ACM, 337â€“350.
[26]Sean Kandel, Andreas Paepcke, Joseph Hellerstein, and Jeffrey Heer. 2011. Wran-
gler: Interactive Visual Specification of Data Transformation Scripts. In Proc.
SIGCHI Conference on Human Factors in Computing Systems. Association for
Computing Machinery, 3363â€“3372.
[27]LiyuanLiu,HaomingJiang,PengchengHe,WeizhuChen,XiaodongLiu,Jianfeng
Gao, and JiaweiHan. 2019. On theVariance of the Adaptive LearningRate and
Beyond.CoRRabs/1908.03265 (2019).
[28]Ruben Martins, Jia Chen, Yanju Chen, Yu Feng, and Isil Dillig. 2019. Trinity:
An Extensible Synthesis Framework for Data Science. PVLDB12, 12 (2019),
1914â€“1917.
[29]MikaÃ«lMayer,GustavoSoares,MaximGrechkin,VuLe,MarkMarron,Oleksandr
Polozov, Rishabh Singh, Benjamin G. Zorn, and Sumit Gulwani. 2015. User
Interaction Models for Disambiguation in Programming by Example. In Proc.
Symposium on User Interface Software & Technology. ACM, 291â€“301.
[30]RobertNieuwenhuisandAlbertOliveras.2006. OnSATModuloTheoriesandOp-timization Problems. In Proc. International Conference on Theory and Applications
of Satisfiability Testing. Springer, 156â€“169.
[31]PeterOehlert.2005. ViolatingAssumptionswithFuzzing. IEEESecur.Priv. 3,2
(2005), 58â€“62.
[32]Saswat Padhi, Prateek Jain, Daniel Perelman, Oleksandr Polozov, Sumit Gulwani,
and Todd D. Millstein. 2018. FlashProfile: a framework for synthesizing data
profiles.Proc. ACM Program. Lang. 2, OOPSLA (2018), 150:1â€“150:28.
[33]MohammadRazaandSumitGulwani.2017. AutomatedDataExtractionUsing
Predictive Program Synthesis. In Proc. AAAI Conference on Artificial Intelligence.
AAAI Press, 882â€“890.
[34]AnkitRohatgi.2019(accessedMay8,2020). WebPlotDigitizer, Version 4.2. https:
//automeris.io/WebPlotDigitizer.
[35]OlgaRussakovsky,JiaDeng,HaoSu,JonathanKrause,SanjeevSatheesh,Sean
Ma, Zhiheng Huang, Andrej Karpathy, Aditya Khosla, Michael S. Bernstein,
AlexanderC.Berg,andFei-FeiLi.2015. ImageNetLargeScaleVisualRecognition
Challenge. International Journal of Computer Vision 115, 3 (2015), 211â€“252.
[36]Manolis Savva, Nicholas Kong, Arti Chhajta, Fei-Fei Li, Maneesh Agrawala, and
JeffreyHeer.2011. ReVision:automatedclassification,analysisandredesignof
chart images. In Proc. Annual ACM Symposium on User Interface Software. ACM,
393â€“402.
[37]Mingxing Tan and Quoc V. Le. 2019. EfficientNet: Rethinking Model Scaling for
Convolutional Neural Networks. In Proc. International Conference on Machine
Learning. 6105â€“6114.
[38]ChenglongWang,AlvinCheung,andRastislavBodÃ­k.2017. InteractiveQuery
Synthesis from Input-Output Examples. In Proc. International Conference on
Management of Data. ACM, 1631â€“1634.
[39]Chenglong Wang, Alvin Cheung, and Rastislav BodÃ­k. 2017. Synthesizing highly
expressive SQL queries from input-output examples. In Proc. ACM SIGPLAN
Conference on Programming Language Design and Implementation. ACM, 452â€“
466.
[40]ChenglongWang,YuFeng,RastislavBodÃ­k, AlvinCheung, andIsilDillig. 2020.
Visualization by example. PACMPL 4, POPL (2020), 49:1â€“49:28.
[41]KuatYessenov,ShubhamTulsiani,AdityaKrishnaMenon,RobertC.Miller,Sumit
Gulwani, Butler W. Lampson, and Adam Kalai. 2013. A colorful approach to
textprocessingbyexample.In Proc.SymposiumonUserInterfaceSoftwareand
Technology. ACM, 495â€“504.
[42]AndreasZeller.2001. AutomatedDebugging:AreWeClose. IEEEComputer 34,
11 (2001), 26â€“31.
[43]Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-
Inducing Input. IEEE Trans. Software Eng. 28, 2 (2002), 183â€“200.
[44]Michael R. Zhang, James Lucas, Jimmy Ba, and Geoffrey E. Hinton. 2019. Looka-
headOptimizer:kstepsforward,1stepback.In Proc.AnnualConferenceonNeural
Information Processing Systems. 9593â€“9604.[45]SaiZhangandYuyinSun.2013. AutomaticallysynthesizingSQLqueriesfrom
input-output examples. In Proc. International Conference on Automated Software
Engineering. IEEE, 224â€“234.
186