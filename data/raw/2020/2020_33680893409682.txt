Understanding and AutomaticallyDetectingConflicting
Interactions
betweenSmartHome IoT Applications
Rahmadi Trimananda
Universityof California,Irvine
USA
rtrimana@uci.eduSeyed AmirHosseinAqajari
Universityof California,Irvine
USA
amiraj.95@uci.eduJason Chuang
Universityof California,Irvine
USA
chuangj6@uci.edu@uci.edu
BrianDemsky
Universityof California,Irvine
USA
bdemsky@uci.eduGuoqing HarryXu
UCLA
USA
harryxu@cs.ucla.eduShanLu
Universityof Chicago
USA
shanlu@uchicago.edu
ABSTRACT
Smarthome devicesprovidetheconvenienceofremotelycontrol-
lingandautomatinghomeappliances.Themostadvancedsmart
home environments allow developers towrite apps to make smart
homedevicesworktogethertoaccomplishtasks, e.g.,homesecurity
and energy conservation. Asmart home apptypically implements
narrow functionality and thus to fully implement desired function-
alityhomeownersmayneedtoinstallmultipleapps.Thesedifferent
appscanconflictwitheachotherandtheseconflictscanresultin
undesired actions such as locking the doorduringafire.
Inthispaper,westudyconflictsbetweenappsonSamsungSmart-
Things,the mostpopular platformfor developing and deploying
smart home IoT devices. By collecting and studying 198 official
and 69 third-party apps, we found significant app conflicts in 3
categories: (1) close to 60% of app pairs that access the same de-
vice, (2) more than 90% of app pairs with physical interactions, and
(3) around 11% of app pairs that access the same global variable.
Our results suggest that the problem of conflicts between smart
homeappsisseriousandcancreatepotentialsafetyrisks. Wethen
developed a conflict detection tool that uses model checking to
automaticallydetectupto 96%of the conflicts.
CCS CONCEPTS
Â·Generalandreference â†’Empiricalstudies ;Â·Softwareand
its engineering â†’Empirical software validation.
KEYWORDS
smart homeapps, concurrency, program analysis, model checking
ACMReference Format:
RahmadiTrimananda,SeyedAmirHosseinAqajari,JasonChuang,Brian
Demsky, Guoqing Harry Xu, and Shan Lu. 2020. Understanding and Au-
tomatically Detecting Conflicting Interactions between Smart Home IoT
ESEC/FSE â€™20, November 8Å›13, 2020, Virtual Event, USA
Â© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-7043-1/20/11.
https://doi.org/10.1145/3368089.3409682Applications. In Proceedings of the 28th ACM Joint European Software En-
gineeringConferenceandSymposiumontheFoundationsofSoftwareEngi-
neering(ESEC/FSEâ€™20),November8Å›13,2020,VirtualEvent,USA. ACM,New
York, NY, USA, 13pages.https://doi.org/10.1145/3368089.3409682
1 INTRODUCTION
Smart home devices are widely available commercially. Modern
smart home platforms support developers writing apps that im-
plementusefulfunctionalityonsmartdevices.Significantefforts
have been made to create integration platforms such as Android
ThingsfromGoogle[ 43],SmartThingsfromSamsung[ 69],andthe
open-source openHAB platform [ 62]. All of these platforms allow
users to create smart home apps that integrate multiple devices
andperformmorecomplexroutines,suchasimplementingahome
security system.
In this work, we focus on Samsungâ€™s SmartThings platform
because it is the de-facto smart home development environment
andhasthemostextensivecollectionofsmarthomeapps,including
thoseofficiallycreatedbySmartThings[ 68]andthosedeveloped
by third-party companies and hobbyists. Homeowners that use
SmartThings can install any of these SmartApps and run them
simultaneouslyintheirhomedeployment.Manyoftheseappseach
implementaspecificfunctionality, e.g.,turnofflightsintheabsence
ofmotion.Thus,homeownerswill likelyneedto install multiple
apps that collectively achieve the desiredfunctionality.
1.1 The Problem
Interactions and Conflicts of Apps. The presence of multiple
apps that can control the same device creates interactions that can
potentiallybeundesirable( i.e.,conflicts).Forexampleahomeowner
may install the FireCO2Alarm [64] app which, upon the detection
of smoke, sounds alarms and door-unlocks1. The same homeowner
may also install the Lock-It-When-I-Leave[14] app todoor-lock
automaticallywhen the homeownerleaves the house.
Whileitmayappearthattheseappscanbesafelyinstalledto-
gether, closer examination reveals that they can interact in surpris-
ing ways. Consider the following scenario. If smoke is detected,
FireCO2Alarm will door-unlock the door. If someone leaves home
withthepresencetag,thiswillmakethepresencesensorchange
1We usedoor-lock anddoor-unlock to refer to actions on a physical door, and lockand
unlockto referto synchronizationsin concurrentprogramming.
1215This work is licensed under a Creative Commons Attribution International 4.0 License.
ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Trimananda, Aqajari,Chuang,Demsky, Xu,andLu
its state from "present" to"not present" , causing the Lock-It-
When-I-Leaveapp to door-lock the door. This defeats the intended
purpose ofthe FireCO2Alarm app.Thus, the twoapps conflict.
Data Races, Atomicity Violations. Interactions of smart home
apps may initially appear similar to those of concurrent programs,
includingdataraces[ 37,38,54]andatomicityviolations[ 41,56,82].
Data races can be resolved by acquiring locks appropriately, while
atomicityviolationscanberesolvedbyensuringthatlocksareheld
long enough to guarantee that a thread can finish all operations in
abatch withoutinterference from otherthreads.
Unfortunately, these techniques cannot resolve the above-
mentioned conflict. Suppose that we use a lock to guarantee the
atomicity of the critical region of the codeÃthe FireCO2Alarm app
needs to acquire the lock before triggering the alarm and holds
the lock while the alarm is sounding. Similar actions need to be
taken to door-lock and door-unlock for the Lock-It-When-I-Leave
app.However,thisapproachcoulddisablethedesirablefunction-
ality of the apps. To illustrate, consider a scenario in which the
Lock-It-When-I-Leaveapp detects that someone leaves the house.
Itthenacquiresthelockbeforeitentersthecriticalregioninwhich
door-lockisperformed.Itholdsthelocktokeepthedoorlocked
until the person returns. In this period, if the FireCO2Alarm app
detects smoke/fire and attempts to door-unlock, it will fail because
theLock-It-When-I-Leaveapp holds the lock. We end up in the
same situation: thedooris locked duringafire!
Feature Interaction. Feature interaction considers the problem
in which different software features can have negative interac-
tions [26Å›28,33,48,63]. Oursetting differs from mostof the pre-
vious work in this area in that smart home apps are developed
independently and composed by end users. For example, Smart-
Thingsappsaredistributedthroughmanydifferentchannels(in-
cludingpayforsource).Thus,theredoesnotexistameanstodetec-
t/resolve/avoid conflicts during development.Feature interactions
have also been studied in research prototypes for home automa-
tion [50,65,78]. These early systems were prototype systems, and
presumedmuchcoarserapps( e.g.,asingleappforlighting)than
current smart home apps implement. HCI researchers have shown
thatfeatureinteractionsinIoTsystemsmakeitdifficultforusersto
understandthesystemsâ€™behavior[ 81].Inrule-basedsmarthome
systems,researchershavedevelopedtoolsforrepairingincorrect
rules[59].
InteractionsofMobileApps. Researchers have also studied inter-
actions between Android apps [ 29,32,34,44,49,51,74]. However,
thesetechniquesfocusprimarilyoncross-appinformationflow/-
taint analysis via ICC/IAC mechanisms in Android ( e.g.,Intents)
and thus cannot be used in our setting. In particular, our prob-
lem requires checking properties of the execution trace that such
analysescannothandle (see Section 3.1).
The Smart Home App Interaction Problem. The problem we
focus on in this work is conflict of expectations . The expected result
of theLock-It-When-I-Leaveapp is that the door should be locked
when the homeowner leaves, while the expected result for the
FireCO2Alarm appisthatthedoorshouldbe unlocked duringafire.
These expectations conflict in certain scenarios. Hence, the funda-
mentalquestionhereis whatshouldbetheexpectedstateofthedoor
when these apps interact :lockedorunlocked? The potential conflict
betweenthe FireCO2Alarm andLock-It-When-I-Leaveappsisnotcorrectableusingstandardmechanismsfor concurrentaccessesto
program variables or entities Ãusing locks to restore atomicity still
violatestheintegrityofthe expected result .
State-of-the-art and Our Work. The research community has
beenactivelylookingintosmarthomeapps.Thereisabodyofwork
that aims to find bugs and issues that could lead to serious security
problems [ 25,30,35,36,39,40,70,83]. However, none of these
techniquesfocusesoninteractionsandconflicts betweenmultiple
apps. In the cyber-physical systems community, work has been
done to identify and resolve conflicts between smart home apps
at the system level, viewing apps as black boxes [58,75,76,79,80].
While suchtechniques areuseful incertain simplescenarios,they
are still semantics-agnostic and do not work even for the above-
mentioned conflictÃhow can we automatically resolve the conflict
withoutunderstandingthesemanticsoftheapps,andtheirpriority
andtiming requirements?
IA-Graph[ 52,53]studiessmart-homeappconflictsandproposes
alightweightapproachtocheckforconflicts.Thisworkextractsan
SMTformulathatdescribesthelegaltransitionsforanappandthen
usesan SMT solvertodetect whether a set of apps hasconflicting
transitions. As acknowledged in the IA-Graph paper, IA-Graph "ig-
nores complicated computations in the app code"Ãthey are, in fact,
used either(1) in condition statements, or(2) to updatethe device
stateÃandhencethepatternsitfindsarelimited.Inaddition,notall
transitions in an app can be expressed in SMT, further limiting the
kindsofconflictsIA-Graphcandetect. Anotherimportantdraw-
backisIA-Graphdoesnotcheckwhetheraconflictingtransition
is reachable in an execution and hence can produce many false
positives.Unfortunately,withoutaccesstotheirimplementation,
we could not conduct an empirical evaluation of theseissues.
Onthecontrary, ourstudycoversa broaderrange ofinteraction
patternsdiscoveredinawide-scalestudy. Ourconflictdetection
tool, IoTCheck, works for arbitrarily complicated application logic
since itmodel-checksallapp pairs directlyusing the app code.
1.2 OurContributions
Thegoalofthispaperistounderstandthenatureoftheinteractions
between smart home apps. We have identified the following five
researchquestionsto guide our study.
RQ1: What kinds of interactions are there? We have collected
and studied 198 official SmartThings apps and 69 third-party apps.
Compared withrecent studiesofsmart home apps [ 35,36,70,83],
wehaveamongthelargestappsuite.Tounderstandinteractions
and possible conflicts, we analyzed these apps in pairs (see Sec-
tion3) and examined all pairs of apps that can potentially interact.
Wediscoveredthreemaincategoriesofinteractions:(1)interactions
between apps that access the same device (see Section 4), (2) inter-
actions between apps such that the output from one app interferes
with the input of the other app (e.g., via sensors, see Section 5),
and(3)interactionsbetweenappsaccessingglobalvariables, e.g.,
whether the home isinthe HomeorAwaymode (see Section 6).
RQ2: What types of conflicts arise between smart home
apps?For an app pair, we first inspected their source code and
documentationtounderstandtheintendedbehaviorofeachindi-
vidual app and then reason about possible interactions between
them.Ifthereexistsaninteractionthatcancompromisethedesired
functionality of either app,we say that this pair has a conflict,e.g.,
1216UnderstandingandAutomatically DetectingConflicting Interactions ... ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
È«ÇŸÈ¬SmartThinÄ±s Cloud
Smart Home 
DeÇƒiÄŠes
Smart HuÄ‰Smart
ThinÄ±s
App
Third-partÇŠ
SÇŠstems
e.Ä±., IFTTT
Router
 Wi-Fi
DeÇƒiÄŠes
ZiÄ±Ä‰ee/
Z-WaÇƒe
DeÇƒiÄŠes                                                      ...DeÇƒiÄŠe 
HandlerDeÇƒiÄŠe 
HandlerDeÇƒiÄŠe 
Handler                                                              
                                                              ...
EÇ‰ample oÄ° ÇŸ SmartApps
SmartApp #Ç
FireCO2Alarm  
DeÇƒiÄŠe Handler
capability.lock
lock.lock()
lock.unlock()SmartApp #ÇŸ
Lock-It-When-I
-Leave  
ZiÄ±Ä‰ee 
door loÄŠk
È«ÇÈ¬
GloÄ‰al VariaÄ‰lesSmartApp SmartApp SmartApp
     NetÇ„ork/phÇŠsiÄŠal 
     ÄŠonneÄŠtion
     CommuniÄŠation
Figure 1: SmartThings platform with an example of two
appsrunninginparallel.
the functionality of the FireCO2Alarm app to door-lock is compro-
mised by the Lock-It-When-I-Leaveapp. Our goal is to carefully
inspect apps that interact, and understand whether they conflict
andif they do,why.
RQ3: How prevalent are these conflicts? We summarized the
resultsofourstudytounderstandhowprevalenttheconflictsare.
We foundthat almost60% ofpairsin thefirst category,more than
90% of pairs in the second category, and around 11% of pairs in the
thirdcategory have conflicts(see Sections 4.3,5.2,and6.3).
RQ4: Are there common coding patterns that are unsafe in
thepresenceofappinteractions? Duringourstudy,weobserved
several common programming idioms that often result in problem-
aticinteractionsbetweenapps.Discoveringandclassifyingthese
idioms can help developers mitigate potential conflicts by avoiding
theseidioms.
RQ5:Howcanweautomaticallydetectconflicts? Basedonour
findings,wedevelopatoolthatcanautomaticallydetectconflicts
(seeSection 7). Ourtoolanddatasetareavailableunderanopen
source license at http://plrg.ics.uci.edu/iotcheck/ [71Å›73].
Implications. The implications of this work are two-fold. First,
our study opens a new research direction in the area of testing
and verification of concurrent programs where the development of
different apps are done completelyindependently. The inability of
existingconcurrencycontrolmechanismstoresolvesmarthome
apps dictates the need of new techniques (such as IoTCheck) to
detectand/orrepairtheseconflicts.Second,forplatformvendors
such as Google and Samsung, new APIs should be designed and
appliedtotheseplatformssothatappdeveloperscanbedirected
to make more informed decisions during development even if they
are not aware ofpotentialruntimeconflicts.
2 BACKGROUND
ThissectionprovidesanoverviewofSmartThings[ 69],thede-facto
smart home IoTdevelopmentplatform.
Components. Figure1shows an overview of the SmartThings
platform.Therearethreemaincomponents,asdiscussedshortly.
The network/physical connections betweenthese componentsareshown in Figure 1as solid lines, while dashed lines represent com-
municationpaths.
(1) Smart Home Devices: SmartThings supports both Smart-
Things-branded and third-party devices as well as a variety of
communication protocols, including Wi-Fi, Zigbee, and Z-Wave.
While Wi-Fi devices are connected directly to the home router,
Zigbee/Z-Wave devices are connected to a SmartThings smart hub
through dedicated radios. The smart hub is connected to the home
router and relaysthe communication between the Zigbee/Z-Wave
devices and the SmartThings cloud via the router. Classes of de-
vices that are supported by the SmartThings platform include both
actuators( e.g.,switches,locks,thermostats,lights,oralarms)and
sensors (e.g.,illuminance,motion, water,orsound sensors).
(2) SmartThings Cloud: The SmartThings cloud hosts smart
homeapps( i.e.,SmartApps)anddevicehandlers( i.e.,driversthat
directly control devices) developed using an event-based program-
mingmodelinGroovy[ 42],amanagedlanguagerunningontop
of the Java Virtual Machine (JVM). SmartApps implement de-
sired functionalities on smart home devices by accessing global
variables and device features through capabilities exposed by de-
vice handlers . For instance, a door lock can be accessed by Smar-
tApps through its device handler that declares lock-related capa-
bilities using capability.lock . These capabilities provide access
to features such as door-lock anddoor-unlock via APIs such as
lock()andunlock() . Third-party systems, e.g.,IFTTT (If-This-
Then-That) [ 21], can also connect to the SmartThings cloud and
control smart home devices through SmartApps that expose HTTP
endpointsas acontrolinterface.
(3) SmartThings Smartphone App: Homeowners can use the
SmartThings smartphone app to install devices and SmartApps. To
communicatewithhomedevices,thesmartphonefirstconnectsand
sendscontrolinformationtotheSmartThingscloudeitheroverthe
Internet or via the home router, illustrated by arrows (1) and (2) in
Figure1,andthentheSmartThingscloudforwardstheinformation
to smart home devices viathe home router andthe smart hub.
Execution Model .SmartThings uses an event-driven execution
model and allows multiple SmartApps to run concurrently. Con-
sider for example the FireCO2Alarm app [64], which attempts to
door-unlockifitdetectssmoke/firethroughasmokesensor.The
appsubscribesto theevents generated by thesensorâ€™sdevicehan-
dler: when the sensor detects smoke/fire, it sends a message to the
smart home hub. The smart home hub relays the message to the
SmartThings cloud, which in turn runs the sensorâ€™s device handler
to process the message. The device handler will generate an event
and send it tothe appâ€™sevent handler method, which in turn calls
another method takeActions() to door-unlock. Since multiple
appsrunconcurrently,thetwoapps FireCO2Alarm andLock-It-
When-I-Leaveshare the device handler for the door lock, and thus
can both execute lock()andunlock() at any time on the same
device handler. The device handler on the cloud translates each
action intodevice specificcommands.Thecloud thensends these
commandstothelocalsmarthub,whichforwardsthecommands
to the doorlock.
3 METHODOLOGY
Thissectiondescribesourresearchmethodology.Wefirstdefine
severalterms.Next,wediscussourdatabaseofsmarthomeapps
1217ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Trimananda, Aqajari,Chuang,Demsky, Xu,andLu
X âˆˆExecution = (Action |Event|Update)âˆ—
A âˆˆAction = read( ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ)|write(ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£)|
moderead( ğ›¼)|modewrite( ğ›¼,ğœ‡)|
schedule( ğ›¼,ğ‘¡,ğ‘š)
V âˆˆEvent = devEv( ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£)|modeEv(ğ›¼,ğœ‡)|
schedEv(ğ›¼,ğ‘š)
U âˆˆUpdate = devUp( ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£)|modeUp(ğ›¼,ğœ‡)
ğ›¼âˆˆAppğ‘‘âˆˆDeviceID ğœâˆˆDeviceType ğ‘ŸâˆˆFeature
ğ‘£âˆˆValue ğ‘¡âˆˆTimeğœ‡âˆˆMode ğ‘šâˆˆMethod
Figure 2:SmartThings execution traces.
and the way we structure them for the study. Our study focuses on
pair-wiseinteractions.Therationaleisthatpair-wiseinteractions
are fundamental for understanding multi-app interactions since
multi-appinteractionscanbedecomposedtopair-wiseinteractions
for reasoning about. Upon carefully examining these apps, we did
not observe any code patterns that would lead to new interactions
arising when three ormore apps are involved.
3.1 Definitions
ExecutionTraces .Wefirstformalizeournotionofexecutiontraces
for SmartThings in Figure 2. The traces can be generated by one
ormoreappsthatrunconcurrently.Anexecution X âˆˆExecution
from asetofapps isasequenceofthe following:
(1) Action: Appğ›¼performsanaction A âˆˆActionbyexecutingany
ofthe following setofoperations:
â€¢read(ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ)and write( ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£),which readfromandwrite
avalueğ‘£toafeature ğ‘ŸofadevicewithID ğ‘‘anddevicetype ğœ,
respectively;
â€¢moderead( ğ›¼) and modewrite( ğ›¼,ğœ‡), which read from and write a
newmode ğœ‡to thelocation.mode variable,respectively;and
â€¢schedule( ğ›¼,ğ‘¡,ğ‘š), whichschedulesamethod ğ‘što run at time ğ‘¡.
(2) Event: An event V âˆˆEventiseither:
â€¢devEv(ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£), a device event is delivered to app ğ›¼from
deviceğ‘‘to notifythe app ofdevice statusupdate;
â€¢modeEv(ğ›¼,ğœ‡),amodeeventisdeliveredtoapp ğ›¼tonotifyitofa
mode change; or
â€¢schedEv(ğ›¼,ğ‘š), a schedule event denotes when the framework
processesa scheduleaction andexecutesthe method ğ‘šinappğ›¼.
(3) Update: Anupdate U âˆˆUpdateisanexternalinputtothesmart
home.Itiseither:
â€¢devUp(ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£),anupdatewithanewvalue ğ‘£generatedfrom
a device with ID ğ‘‘and type ğœfor feature ğ‘Ÿand value ğ‘£,i.e.,a
sensor readingatemperature change; or
â€¢modeUp(ğ›¼,ğœ‡);anupdatewithanewmode ğœ‡,e.g.,thehomeowner
manually settinganewmode.
Interacts-with Relation. We next define a relation interacts-with
over the domain of Apps Ã—Apps where Apps is the set of all smart
homeapps.Apairofapps( ğ›¼1,ğ›¼2)âˆˆinteracts-with (i.e.,ğ›¼1interacts-
withğ›¼2) if they interact witheachotherinone ofthe three ways:
(1)Accessthesamedevicecapability: Appsğ›¼1andğ›¼2canaccess
a shared device using the same capability; ğ›¼1updatesthe device
state (i.e.,featureğ‘Ÿand value ğ‘£) andğ›¼2accesses ( i.e.,updates orreads) the device state. We refer to this relationship as a device
interaction. For example, ğ›¼1may turn on a switch based on the
inputofalight/illuminancesensorand ğ›¼2mayturnoffthesame
switchbasedonamotionsensor,bothcallingmethodsonthesame
device handler object.
(2) Physical interaction: We say that two apps have a physical-
mediuminteractioniftheoutputof ğ›¼1physically becomesaninput
forğ›¼2and affects the execution of ğ›¼2. For example, ğ›¼1activates
a robot vacuum cleaner at a certain time during the day, and the
robotâ€™s movement becomes the input to a motion sensor that is
usedbyğ›¼2.
(3)Accessthesameglobalvariable: Appsğ›¼1andğ›¼2caninteract
via the same global variable, whose value is stored on the cloud,
e.g.,ğ›¼1updatesthevariableand ğ›¼2accessesit.Thisisreferredto
as aglobal-variable interaction. In this study, we focused on the
location.mode variablebecauseitistheonlyglobalvariableinthe
SmartThings platform that allows for both writeandreadaccesses.
location.mode has three preconfiguredvalues: Home,Away,and
Night.Anexamplescenarioisthatoneappupdates location.mode
based on the input of the presence sensor while the second app
reads itto determinewhether adoorshould be locked/unlocked.
ConflictRelation. Appsğ›¼1andğ›¼2conflictif they interact (in one
of the ways discussed above) and the interaction may compromise
thecorrectness oftheappsorproducean unintendedoutcome .Al-
thoughthenotionofaconflictissomewhatvague,wefoundthat
Definitions 3.1and3.2workedwell mostof the time inpractice.
Definition 3.1. Device/Global-Variable Conflict .Two apps ğ›¼1
andğ›¼2conflictiffthereexistsanexecution Xofğ›¼1andğ›¼2andtwo
actionsA1andA2that update the same feature ğ‘Ÿor modeğœ‡inX
such that: (1) A1andA2are performed by different apps ( ğ›¼1and
ğ›¼2), (2)A1andA2write different values ( ğ‘£1andğ‘£2, orğœ‡1andğœ‡2),
(3) there is no such A3that updates the same ğ‘Ÿorğœ‡and that the
update is ordered between A1andA2, and (4)A2was notinitiated
byadirectuseraction.
Definition3.2. Physical-MediumConflict .Twoappsğ›¼1andğ›¼2
conflictiffoneappperformsanactionthataffectsaphysicalmedium
(e.g.,motion) and the other app reads from a sensor that can sense
that physical medium(e.g.,amotion sensor).
3.2 SmartHome App Pairs
ChoiceofApps. Westudied198officialand69third-partysmart
home apps that we have collected from the SmartThings official
Github [68] and other third-party repositories. While the statistics
of appusagesandinstallationsareproprietary, allthe apps thatwe
used in this study can be obtained easily from the aforementioned
repositories. Today, the SmartThings official Github [ 68] has an ac-
tive user communityÃit has been forked into personal repositories
more than 70,000 times. Any user can get and upload any appâ€™s
sourcecodetotheSmartThingsMarketplaceviatheSmartThings
Groovy IDE [ 24]. Thus, userscan installanduse any app.
AppPairing. Theseappswereinitiallydevelopedtoperformtheir
specificfunctionality.Therearenostandardizedguidelineseither
from SmartThings or from the community as to how to develop an
app inawaysothat itcan safely interact withotherapps.
Ourprocessformanualexaminationwastoindependentlyexam-
ine the sourcecode of each app pair by at least two of the authors.
1218UnderstandingandAutomatically DetectingConflicting Interactions ... ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
Table 1:Groupsofappsfordevice-type pairing.
Group Capability Subgroup App
# Apps # Pairs
Switches switch General 24 276
Lights 32 496
AC/fan/heat 3 3
Vent 3 3
Camera 2 1
Locks lock 21 210
Thermostats thermostat 19 171
Lights colorControl Hue 13 78
Non-Hue 11 55
Dimmers switchLevel 11 55
Alarms alarm 10 45
Valves valve 7 21
MusicPlayers musicPlayer 5 10
Relay relaySwitch 5 10
Speech speechSynthesis 3 3
Synthesizers
Cameras imageCapture 2 1
Total 171 1,438
In the event that the two examiners disagreed about whether an
app pair conflicted, theydiscussed theirdisagreement onthe app-
pairâ€™s classification and reached a consensus. There are 35,511 app
pairs given the 267 apps we collected above. From this huge set of
pairs, we identify2,844 pairs of apps that potentiallyinteract with
each other. We next explain how we use the three interact-with
conditions to identify these 2,844 pairs. We will then study how
manyofthese2,844 pairscontain conflictsinSections 4Å›6.
Device-Type Pairing. To identify apps that have device interac-
tions,we firstdivide the 267apps intogroupsbasedonwhat type
of device an app aims to manage, as shown in Table 1. Clearly, if
two apps do not access a common device, it is impossible for them
to havedeviceinteraction.
Outofthe267apps,weexcluded132appsforthreereasons. First,
weexcludedappsthattakeinputsfromoutsideoftheSmartThings
platform. For instance, the IFTTT (If-This-Then-That) [ 21] app
functionsasabridgebetweentheSmartThingsplatformandIFTTT,
athird-party platform.Theseappstypicallywaitforathird-party
applicationbuiltonathird-partyplatform( e.g.,IFTTTandother
similar platforms) to send commands and generate events through
HTTPendpoints.Wedonothaveaccesstothesourcecodeofsuch
third-partyapplications;thus,itisnotpossibletoaccuratelyreason
aboutpotentialinteractions.Second,weexcludedappsthatonly
send messages to a smartphone about the state of sensors because
theseappsdonotinteractwithotherapps.Third,wealsoexcluded
apps that use third-party specific device handlers since these apps
cannot share a device with other apps. Therefore, we included 135
appsfordeviceinteraction.Someofthemaccessmultipledevices
and,thus,areincludedinmultiplegroupsofdevicesÃhence,atotal
of171apps.Attheend,weidentifiedatotalof1,438pairsfromthe
171apps classifiedinvariousdevice-type-basedgroups.
For some groups, we identify all pairs of apps from the group as
device-interactionpairs.Forexample,the Locksgroupcontains21
apps, we inspectedallthe/parenleftbig21
2/parenrightbig=210 pairsandconfirmedthemall
to bedevice-interactionpairs.
For some groups that provide genericfunctionality, such as
SwitchesandLights,wefurthercreatesub-groupsandonlyidentify
apps that belong to the same sub-group as having a deviceinter-
action. For example, for the Switches group, out of a total of 64Table 2:Groupsofappsforphysical-medium pairing.
Output # Apps Sensor # Apps # Pairs
Lights 42Illum. 5205
MovingDev. 2Motion 39 78
WaterValves 2Water 11 21
Sound Dev. 21Sound 1 21
Total 325
apps,24accessgeneralswitches(276pairs),32accesslightswitches
(496 pairs), 3 access AC/fan/heater (3 pairs), 3 access the ventila-
tion system (3 pairs), and 2 access cameras (1 pair). We also found
8apps(notincludedinTable 1)thatcontrolspecificdevices( e.g.,
curling-iron)thatarenotsharedbyotherapps;hence,nopairswere
constructed for theseapps. The Lights group consists of apps that
use the light device handler ( i.e.,capability.colorControl ) to
turn the lights on or off, set their illuminance level [ 18], or change
theircolors.Eachgroupwasdividedintoasubgroupofappsthat
controlsPhilipsHuelightsandanothersubgroupthatcontrolsnon-
Huelights.IntheLightsgroup,thereare13appsforHueleading
to 78 pairsand11 apps for non-Hueleading to 55 pairs.
Physical-Medium Pairing. Twoappscaninteractviaa physical
medium;e.g.,one app generates an output that could be a physical
inputtothe otherapp.Toillustrate, consideranapp thatchanges
thestate( i.e.,toggleon/off)oflightbulbs.Thesechangesalsoaffect
the illuminance produced by the light bulbs, which can become an
inputto apps that read from illuminancesensors.
Table2reports results for apps that interact physically. We
grouped them based on the output-input relationships, such as
lights (output) and illuminance sensors (input), moving devices
(output) and motion sensors (input), water valves (output) and wa-
tersensors(input),orsound-generatingdevices(output)andsound
sensors(input). Forthelight-illuminance-sensor relationship,for
example, we constructed a total of 205 pairs for the 42 apps that
controllights andthe 5apps that read from illuminancesensors.
Global-VariablePairing. Appscanalsointeractiftheyaccessthe
sameglobalvariable.Currently,thereisonlyoneglobalvariable
in the SmartThings platform that multiple apps can read from and
write into: location.mode . We grouped together all the 47 apps
that access itfor atotalof 1,081 pairs.
3.3 Threatsto Validity
ExternalValidity. This study focused on Samsungâ€™s SmartThings
platformandthusmaymissinteractionpatternsspecifictoother
platforms. However, we believe that most of the findings and in-
sights revealed in this study are universal for smart home appli-
cations and frameworks. For instance, our results also apply to
rule-based systems, e.g.,IFTTTÃtwo rules: (1) Å‚if the humidity
is high, turn off the ACÅ¾ and (2) Å‚if the temperature is low, turn
on the ACÅ¾, have a conflict by our definition if the humidity is
high and the temperature is low. Even for interactions that are
specifictotheSmartThingsplatform( e.g.,concurrentaccessesto
thelocation.mode variable),thepatternsdiscoveredundersuch
interactionsaregeneral.Forexample,otherplatformswouldalso
have global variables that serve similar purposes and hence our
results can be generalizedto theseotherplatforms as well.
InternalValidity. Thisstudycovers allofthe198officialapps that
wecouldfindintheSmartThingsofficialGithubrepositoryandthe
1219ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Trimananda, Aqajari,Chuang,Demsky, Xu,andLu
example set for SmartThings tutorials as of July 2018. We added 69
third-partyapps that we gatheredfrom variousothersources.
While we studied the complete set of the official apps, the third-
partyapps used in thestudy maynot be exhaustive. Nevertheless,
ourexperienceshowsthatthepatternsthatexistintheofficialapps
are similar to those in the third-party apps. We believe adding new
third-party apps would not change the main findingsand insights.
Inthisstudy,welimitedthescopeofappinteractionstopairs,and
hence, there could be new typesof interactions thatmanifest only
whenthreeormoreappsareinvolved.However,wehavealready
manuallyinspectedalargenumberoftripletsandnotfoundany
newinteraction patterns that donot exhibit inpairs.
We manually inspected app pairs to determine whether the two
apps in each pair can conflict. The manual determination is sub-
jective in some casesÃit reflects the authorsâ€™ beliefs of whether
the interactions between a pair of apps represent an unintended
outcome. Whether this conflict represents a problem in the real
world is a very complicated question and can depend on (1) the
intendeduseofthehomeownerand(2)thehomeenvironment.For
example, if one app turns a light on and a second app based on the
absenceofmotionfromasensorturnsthelightoff,weclassifythis
as a conflict. However, users may compose apps with the intention
of this app interaction. As another example, certain interactions
aremadeoverphysicalmediums;forinstance,thesoundgenerated
by a speaker app could become the input of a sound sensor used
by a different app. In this case, whether the sensor can pick up
the sound depends on whether it is physically close to the speaker
generating the sound. In the study, we assume that this interaction
canactuallyhappenalthoughthespeakerandthesensormaybe
farawayinareal-life deployment.
Conflictsthathavesafetyorsecurityaspectsarecertainlycritical
andcouldbeharmful.However,itissomewhatdifficulttodetermine
thepotentialsafetyhazardsorimplicationsofaconflictastheycan
dependonthespecificdeployment.Forexample,ifaconflictcauses
asmartoutlettoremainon,whetheritisasafetyhazarddependson
what is plugged into the smart outlet, e.g.,toaster versus LED light.
Nevertheless,evenbenignconflictscanrenderappsuselessÃthey
makeasmarthomesystemunpredictableandunreliable,ultimately
makingthe systemless useful.
Ourultimategoalistoidentifyall avoidable conflictsandtheir
possiblesourcessothatactionscanbetakeninfuturedevelopment
and/ordeploymenttomitigatepotentialconflicts.Someconflicts
canbepotentiallyhandledbythedevelopmentofAPIwithsupport
forcommonappinteractionpatterns.Onthecontrary,ifphysical
proximity is a concern, we could develop an analysis that warns
the user during installation. This explains why we treated these
twoscenarios differently.
4 DEVICE INTERACTION
This section presents our findings for apps that form pairs with
deviceinteractions. When we first studied this category, we found
that some apps monitor status changes but do not initiate any
changesondevices.Whensuchanappispairedwithanotherdevice
monitor app, both apps concurrently read the device status and
neitherofthemmakesanychangestothedevicestatus.Werefer
to such a pair of apps as having a read-read relationship. 128 (8.9%)
pairs have this relationship andthus do not interact. We classifiedTable 3:Statistics for deviceinteraction.
Relationship # Pairs Percentage
Read-read 128 8.9%
Non-conflicting Interactions
Direct-direct 20 1.4%
Composable 319 22.2%
Different-feature 52 3.6%
Same-feature 90 6.3%
481 33.5%
ConflictingInteractions
Featureconflicts 632 43.9%
Invalid-local-state 76 5.3%
Dropped-update 121 8.4%
829 57.6%
Total 1,438
deviceinteractions into non-conflicting andconflicting interactions;
the statisticsofthe classification are reportedinTable 3.
4.1 RQ1: TypesofNon-Conflicting Interactions
Weobservedthreetypesofnon-conflictinginteractions.First,al-
though two apps can access the same device, their accesses can
only be triggered manually by users. Consequently, whether they
conflictwitheachotherdependsonhowusersoperatethem.For
example, Big-Turn-ONis such an app: it turns on switches when
theusertouchestheappâ€™suserinterface[ 8].Twousersmaycon-
currently initiate conflicting commands to a switch through two
appslike Big-Turn-ON.Weconsiderthistypeofconflictsoutofthe
controlofapps.Werefertothistypeofinteractionasa direct-direct
relationship.Wefoundthatthisrelationshipholdsfor20(1.4%)app
pairsinthe devicecategory (see Table 3).
Second,certainappscanworktogethertorealizedesiredfunc-
tionality, and hence are intended to interact with each other. We
refertothistypeofinteractionasa composable relationshipandcor-
respondingappsas composable apps.Wefoundthatthiscomposable
relationship holdsfor 319(22.2%)pairs inthe devicecategory.
Note that many of these composable apps were developed inde-
pendently.Forexample,the FireCO2Alarm appsetsoffthealarm
and triggers door-unlocks when smoke/fire is detected [ 64], while
theInitial-State-Event-Streamer app [17] monitors and for-
wardseventsfrommanydevicesincludingthealarmdevicehandler
toawebsite[ 22]thatallowsuserstoremotelymonitordeviceactiv-
ities.Thesetwoappswereindependentlydeveloped,buttheycould
interact to fulfill a desired functionality at run timeÃnotifying a
userthroughthe specific website that an alarm issetoff.
Third, some apps simultaneously access different features of the
same device or the same feature of the same device in a consistent
way,andhence do not conflictwitheachother.
An example of the former ( i.e.,accesses to different features)
is theKeep-Me-CozyandThermostats [12,20] pair of apps from
theThermostatsgroup.Oneappcallsmethodsonthethermostat
to set heating orcooling points ( e.g.,setHeatingSetpoint() and
setCoolingSetpoint() ), while the other app sets the mode of
the thermostat ( e.g.,viasetThermostatMode() ). Although these
two apps control the same shared device, they operate on different
featuresofthedevice.Hence, althoughthefirstapp interacts-with
the second app, there is no conflict between them. We refer to
this interaction as a different-feature relationship and found this
relationship holdsfor 52 (3.6%) pairs inthe devicecategory.
1220UnderstandingandAutomatically DetectingConflicting Interactions ... ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
Anexampleofthelatter( i.e.,consistentaccessestothesamefea-
ture) is the following pair of apps from the Locks group: the Lock-
It-at-a-Specific -TimeandAuto-Lock-Doorapps [5,67]. Both
appscall lock.lock() todoor-lock.Weconsiderthisinteraction
non-conflicting, since these appsâ€™ actions would lead the shared
devicetothe samestate andhencetheexpectedoutcomeisnotcom-
promised.Werefertothisinteractionasa same-feature relationship
andfounditto holdfor 90 (6.3%) pairsinthe devicecategory.
4.2 RQ2: TypesofConflicting Interactions
Of the 1,438 app pairs in the devicecategory, 829 pairs exhibit
conflictingbehaviors. We classifiedthese conflictingbehaviors as
eitherfeatureconflicts andsaved-stateconflicts .
Feature Conflicts. There are many pairs where the two apps at-
tempt to update the same device state with incompatible values .
An example is the FireCO2Alarm andLock-It-When-I-Leavepair
discussed in Section 1. Recall that the FireCO2Alarm app attempts
to door-unlock during a fire while the Lock-It-When-I-Leaveapp
couldpotentiallydoor-lock. Werefertotheseconflictsas feature
conflicts. A majority of the app pairs: 632 (43.9%) pairs in the device
category have feature conflicts.
Saved-StateConflicts. Manyappsusetheirlocalvariablestokeep
track of device states and guide their own device updates. These
appseasilybecomebrokenwhenpairedwithotherappsthatcan
updatethe same devicesÃa concurrentupdatefrom the otherapp
wouldmake this appâ€™svariable inconsistentwiththe device state.
Consider Auto-Humidity -Ventthat turnson/off afanbased on
thehumiditylevel[ 2].Thisappconflictswiththe Big-Turn-OFFapp
thatallowsausertomanuallyturnoffthefan[ 7]forthefollowing
reason.When Auto-Humidity -Ventdetectsthattheroomhumidity
isaboveathreshold,itturnsonthefanandsimultaneouslyupdates
its local state variable state.fansOn totrue. A user may then
use theBig-Turn-OFFapp to turn off the fan, causing the room
humidity to increase above the threshold. Unfortunately, since the
local variable state.fansOn remainstruein theAuto-Humidity -
Ventapp, unaware of the fan being turned off by Big-Turn-OFF,
Auto-Humidity -Ventwouldstopfunctioning,incorrectlyassuming
that the fan is already on. We refer to this scenario as invalid-local-
stateconflicts, and found that 76 (5.3%) pairs in the devicecategory
exhibitthis pattern.
Acommonpatternweobservedisanappthatstoresandrestores
thestateofadevice.Forexample,the Thermostat -Auto-Offapp
restores the state of the thermostat to a previously stored state.
Consider an execution in which after the Thermostat -Auto-Off
app saves the current state ( e.g.,off) of the thermostat into a local
variable, a second app changes the actual device state to a different
value(e.g.,"cool"),whichdoesnotpropagateto Thermostat -Auto-
Offâ€™sinternalstate.Thenexttime Thermostat -Auto-Offtriesto
restore the thermostat state, the restoration will be based on the
staleand wrongvalue savedin the local variable. Thusthe update
performed by the second app is dropped. We refer to this scenario
asdropped-update conflicts,andfound121(8.4%)pairsinthe device
category exhibitthis pattern.
4.3 RQ3: Prevalence ofConflicts
AsreportedinTable 3,91.1%ofthepairsin devicecategoryhave
actualinteractions( i.e.,atleastonedeviceupdatesthedevicestate),Table 4:Statistics for physical-medium interaction.
Medium # Pairs Percentage
Non-Conflicting Interactions
Water 10 3.1%
Sound 21 6.4%
31 9.5%
ConflictingInteractions
Water 11 3.4%
Motion 78 24.0%
Light state 151 46.5%
Light color 20 6.2%
Light brightness 5 1.5%
Light combination 29 8.9%
294 90.5%
Total 325
while8.9%ofthepairshave read-read relationshipsandhencedo
not actually interact. Of the pairs that have actual interactions, the
majority (57.6%)have conflicts.
4.4 RQ4: Unsafe Coding Patterns
Wefoundthereareatleasttwounsafecodingpatternsfor device
interactions:(1) blind-update and(2)saved-state .Theblind-update
pattern occurs in apps that blindly update the same state of the
same device without checking the currentstate of the device.The
saved-state pattern occurs when an app that saves the state of a
devicefeatureintoalocalvariableandlaterusesthesavedvalue.
Thismaycauseupdatesfromotherappstobediscarded.Insome
cases, a check of the current state before doing the update could
help the app verify that its local state is consistent with the device
state. However, with the existing APIs, there is no way to do the
check-and-update in an atomicwayÃan app could only retrieve
thedevicestatebyinvokingamethod ğ‘š1andthenupdatethestate
by invoking another method ğ‘š2; the state could be changed by
anotherapp after ğ‘š1returns but before ğ‘š2iscompleted.
5 PHYSICAL-MEDIUMINTERACTION
This section presents our findings for apps that interact via the
physical world. In this category, two apps are paired when the
output from the first app can physically become the input of the
secondapp andaffectits operation. Table 4reports our findings.
5.1 RQ1&2:Typesof(Non-)Conflicting
Interactions
Motion.The first set of physical interactions are due to motion.
Anexamplepairis Neato-(Connect) andForgiving -Security [1,
23].Neato-(Connect) is a third-party app that controls a Neato
vacuum-cleaningrobot.Whentheappactivatestherobot,therobot
starts cleaning the house. While it is moving around the house, its
movementcouldtriggeramotionsensorusedbythe Forgiving -
Security appandthussetoffasecurityalarmÃa falsealarm .Of
the 325 app pairs in the physical-medium category, 78 pairs (24.0%)
interact viamotion andallexhibit conflicts.
Light.A similar set of app pairs are based on interactions via light.
TheTurn-On-at-SunsetandLight-Up-the-Nightapps[13,16]are
an example. Consider a deployment in which each app controls
adifferentlightbulb.Atsunset,the Turn-On-at-Sunsetappmay
turn on a light bulb whose light may affect the illuminance sensor
of theLight-Up-the-Nightapp. The Light-Up-the-Nightapp is
supposedtoturnonalightbulbwhenitsilluminancesensordetects
1221ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Trimananda, Aqajari,Chuang,Demsky, Xu,andLu
thatthesurroundingisdark.Ifthelightbulbcontrolledbythe Turn-
On-at-Sunsetapp is sufficiently close to the illuminance sensor
usedbythe Light-Up-the-Nightapp,thesensormaypickupsome
lightfromthelightbulb.Thiscouldcausethe Light-Up-the-Night
apptodeterminethatthereisnoneedtoturnonthelightbulb,and
hence,the twoapps conflict.
Someapps can control alight bulbby changingitson/off state,
colors,orbrightnesslevels.Anyofthesechangescanpotentially
be detectedbyan illuminancesensor [ 18].
Table4summarizesourfindings:151pairs(46.5%)haveaconflict
throughthechangeoflightâ€™son/offstate;20pairs(6.2%)conflict
throughthechangeoflightâ€™s color; 5pairs(1.5%) conflict through
thechangeoflightâ€™sbrightness;and29pairs(8.9%)conflictthrough
acombination ofthe three.
Water.Physical interactions can also occur via water. An example
pairthatinteractsviawaterconsistsofthe Sprayer-Controller -2
andClose-The-Valveapps [3,6].The formerschedules irrigation
for a certain amount of time periodically, while the latter closes
awatervalvewhenthewatersensordetectsmoisture.Whenthe
water coming from a water sprayer controlled by the Sprayer-
Controller -2app reaches the water sensor used by the Close-
The-Valveapp,the two apps interact. This interaction potentially
results in a conflict because a bad moisture sensor placement could
causethe Close-The-Valveapptopreventtheirrigationthathas
been scheduledbythe Sprayer-Controller -2app.
Ourresultsshowthat21pairsinteractthroughwater:11ofthem
haveconflictand10donot.Ineachofthese10pairs,theappthat
controls the water valve actually closes it when it detects moisture.
Therefore, no water can be produced and detected by the water
sensor ofthe otherapp.
Sound.Apps can also interact via sound. For example, an interest-
ingapppairis Bose-SoundTouch -ControlandInfluxDB -Logger,
which reads from a sound sensor [ 19]. In fact, the latter can be
paired with any other sound-producing apps, such as those that
controlspeakers, alarms, ormusic players.
Our findings show that there are 21 pairs (6.4%) that interact via
soundbutwecouldnotfindanyconflictsamongthem.Typically,a
pair consistsof asound-producingapp andthe InfluxDB -Logger
app. Since the InfluxDB -Loggerapp only logs the status of the
sound sensor, the two apps are actually composable Ãsimilar to the
composable relationship inthe deviceinteraction (see Section 4.1).
Physical Factors. Thephysical-medium interaction depends on
certainphysicalfactors.Thepositionofthefirstappâ€™sactuatorrela-
tivetothesecondappâ€™ssensordetermineswhethertheoutputfrom
theactuatorcouldreachthesensor.Iftheirproximityissufficiently
close for the actuatorâ€™s output to affect the sensor, the two apps
interact; otherwise, they do not. When we performed this study,
we assumed that theirlocationsare sufficientlyclose. Althoughit
isaconservativeapproximation,thisisthebestwecoulddoand
our findings can help developers and users to avoid such conflicts.
5.2 RQ3&4:Prevalence ofConflicts/Unsafe
Coding
Table4summarizes thestatistics forthe physical-medium interac-
tion pairs. Our findings suggest that typically, when a pair of apps
interact through aphysical medium, they will most likely conflict.
In most cases, the second app does not expect to receive any inputTable 5:Statistics for global-variable interaction.
Relationship # Pairs Percentage
Read-read 405 37.5%
Non-Conflicting Interactions
Direct-direct write-write 28 2.6%
Appwrite-read 302 27.9%
Direct write-read 221 20.4%
App-app write-write 1 0.1%
552 51.0%
ConflictingInteractions
App-app write-write 44 4.1%
App-direct write-write 80 7.4%
124 11.5%
Total 1,081
fromthefirstapp.Itnormallyexpectssensorinputsfromitssur-
roundings. Out of the325 pairs with physical-medium interaction,
90.5%(294pairs)ofthemhaveaconflict.Wedidnotobserveany
codingpatternsthatcauseconflictsinthiscategory.Hence,wecon-
cludedthatthe conflictinpairswith physical-medium interaction
is caused mainly by the physical proximity between theactuators
andsensors ofthe conflicting apps.
6 GLOBAL-VARIABLE INTERACTION
This section presents our findings for app pairs that have global-
variableinteractions.AsdiscussedinSection 3.1,sinceSmartThings
onlyhasoneglobalvariable location.mode thatallowsbothreads
andwrites,weconsidertwoappstohave global-variable interac-
tioniftheybothaccess location.mode .Ourstatisticsarereported
in Table5. 405 (37.5%) of the pairs (reported as pairs with read-
readrelationships in Table 5) contain apps that only read from
location.mode .Theseapps do not actuallyinteract.
6.1 RQ1: TypesofNon-Conflicting Interactions
The first type contains apps that only write location.mode and
theyarecontrolledmanuallybytheuser.Werefertothisasa direct-
directwrite-write relationship.AsdiscussedearlierinSection 4.1,
wedidnotconsidertheseappsasconflictingsincetheusercontrols
them. Thisgroupcontains28pairs(2.6%),reportedaspairswith
direct-directwrite-write relationships inTable 5.
Asecondtype,consistingof302apppairs (27.9%),exhibits app
write-read relationships,exemplifiedbythe Greetings -Earthling
andHello,-Home-Phrase-Director apps[4,11].TheGreetings -
Earthling app changes the value of location.mode when the
presence sensor detects that the homeowner arrives home. On
the other hand, the Hello,-Home-Phrase-Director app sends a
greeting message to the homeowner depending on the value of
location.mode . In this case, the two apps have a composable rela-
tionship:one app reads the variable updatedbythe other.
Athirdtype,consistingof221apppairs(20.4%),exhibits direct
write-read relationships: one app requires the user to manually
controltheapptowriteinto location.mode ,whiletheotherreads
from it. This is the intended usage scenario of location.mode ,
namely to facilitate interactions between apps through mode
changes.Hence,these write-read interactions are not conflicts.
Finally, we found one pair in which both apps write into
location.mode and yet do not conflict. This pair consists of
theGreetings -Earthling andBon-Voyageapps [9,11]. The
Greetings -Earthling appwritesinto location.mode whenthe
user arrives at home, while the Bon-Voyageapp writes into the
1222UnderstandingandAutomatically DetectingConflicting Interactions ... ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
same location when the user leaves. Hence, they do not conflict as
they have disjoint intents and never write at the same time. This is
an exception to our current formal definition that can be improved.
6.2 RQ2: TypesofConflicting Interactions
When two apps both write into location.mode , in most cases,
conflicts would result. There are two types of write-write con-
flicts:app-appwrite-write andapp-directwrite-write .Forexample,
there exists an app-app write-write conflict between the Smart-
Security andGood-Nightapps [10,15], which both attempt to
write into location.mode . While the Smart-Security app up-
dateslocation.mode withHome, theGood-Nightapp changes
location.mode toNightorAway. InSmart-Security , the update
tolocation.mode occurswhenintrusionisdetected.Thisisrather
animportantupdateandtheusercertainlydoesnotwanttheresult
of theSmart-Security app to be compromised. There are 44 pairs
(4.1%) ofsuch conflicts.
Anapp-direct write-write conflict occurs when in one app the
updateoftheglobalvariableistriggeredbyanon-userinput, e.g.,a
sensor,whilein the other appthe user performs anoperationthat
triggers the update. For example, the first app uses the motion sen-
sor to detect if there is anyone home and updates location.mode
based on the sensor input. The second app lets the user control the
lightÃwhentheuserturnsonthelight, location.mode isautomat-
icallyupdated.This category has 80 (7.4%) conflicting pairs.
6.3 RQ3&4:Prevalence ofConflicts andUnsafe
Coding
Thereareatotalof124(11.5%)conflictingapppairs.Thus,conflicts
arenotprevalentfor this type ofinteraction.
We found that concurrent-writes tolocation.mode is an unsafe
pattern,whichisduetotheSmartThingsAPIsthatallowappsto
directly change the value of location.mode . For instance, inthe
caseofthe Smart-Security app,agoodpracticewouldbetonot
allowotherappstowriteinto location.mode whenthealarmis
sounding;otherwise,thealarmmaybestoppedabruptlybeforeit
isnoticed. In the case of modes, the combination of(1) changing
the API to specify a duration for the mode change and (2) allowing
the userto specifypriorities wouldresolve manyofthe conflicts.
7 DETECTINGCONFLICTS
In this section weaddress RQ5:Howcan we automatically detect
conflicts?
WedevelopedIoTCheck,atoolthatautomaticallyidentifiescon-
flicts bymodel-checking pairs of apps. A model checker checks,
exhaustivelyandautomatically,ifasystemmeetsaspecification.
Model checking is particularly useful in detecting app conflicts
due to its ability to exhaustively check all potential interactions
between apps.
We begin by summarizing the key insights from our manual
studythat weusedfor designingIoTCheck.Our studyshowsthat
mostdeviceconflictsoccurwhentwoappsissueconflictingupdates
to the same device. We found that when one app writes to a device
featureandanotherappreadsfromthesamedevicefeature,ittypi-
cally doesnot representa conflict;thisscenariocommonlyoccurs
when apps compose. We also found that it is important to considerthereasonwhytwoappsperformconflictingupdates.Ifbothup-
dates are performed in response to user requests, there is typically
noconflictsincetheactionsaretriggeredbytheuser.Finally,we
foundthatconflictson global variablesoccur onlywhentwo apps
bothwritetotheglobalvariable;read-writeinteractionstypically
representnormalcooperationbetweenapps, notconflicts.IoTCheck
model-checks pairs of apps and monitors for conflicting updates to
thesamedeviceorglobalvariablesfromdifferentapps.IoTCheck
directly executes the original app code, eliminating the need to
build models of the apps. IoTCheck extends the Java Pathfinder
(JPF), an explicit state-basedmodelchecking infrastructure [ 77].
App
CodeIoTCheck
PreprocessorInstrumented GrooÇƒÇŠ 
Code
IoTCheck
ConÄ°iÄ±uration
Tool
App
ConÄ°iÄ±uration
GrooÇƒÇŠ
Compiler
BÇŠtecode
FileIoTCheck Simulation 
FrameÇ„ork
IoTCheck Monitor
JPF Ç„ith GrooÇƒÇŠ
&
IoTCheck EÇ‰tensions
ConÄ°lict AnalÇŠsis
Report
Figure 3:IoTCheckarchitecture.
Architecture. Figure3presentsIoTCheckâ€™sarchitecture. Thear-
rows represent the workflow of IoTCheck that starts from app
code as an input to the IoTCheck configuration tool and IoTCheck
preprocessor.EachSmartThingsapphasaconfigurationmethod
that asks users for configuration informationÃwhile most of the
configuration can be automatically generated, apps can ask for ar-
bitrary input and thus part of the configuration requires human
help. The IoTCheck configuration tool runs this method, automati-
callyconfiguresmostoptions,andaskstheuserfornon-standard
options. The IoTCheck configuration tool then outputs app config-
urationfiles,which,togetherwiththeoriginalapp,areprocessed
bytheIoTCheckpreprocessor.TheIoTCheckpreprocessorgener-
atesmodelcheckerhookstoenableJPFtogeneratedeviceevents,
combines multiple apps into the same program, and sets up the
necessary configuration to run the program. It then outputs in-
strumentedGroovycodewhichiscompiledintobytecodebythe
Groovy compiler.
We developed a SmartThings simulation framework for
IoTCheck. This framework contains virtualized devices ( i.e.,de-
vicehandlers)forallofthedevicesusedbyourbenchmarkapps.
While an actual SmartThings device handler controls an actual
device, a virtualized device handler changes the value of a state
variablethatrepresentsthevalueofadevicefeature.Thus,avirtual
devicehandlerforadoorlockchangesthevalueofthedoorlock
state variableinsteadofcontrollinganactual Zigbee doorlock (see
Figure1). These device handlers are under the control of the JPF
modelcheckerÃJPFtriggersdeviceeventssuchasamotiondetected
byamotionsensor,oratemperaturevaluechangedetectedbya
temperature sensor. For devices such as temperature sensors, there
isalargerangeofpotentialtemperaturesthatwouldmakemodel
checkinginfeasiblewithoutusingsymbolictechniques.IoTCheck
thus supports a set of potential temperature readings ( e.g.,a hot
1223ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Trimananda, Aqajari,Chuang,Demsky, Xu,andLu
reading and a cold reading), which is practical given the nature
of many smart home apps. IoTCheck does not currently model
physical interactions betweendevices (other than toflag thatthey
could potentiallyinteract);this remainsfuture work.
Finally,IoTCheckmodel-checksthegeneratedbytecodeusing
the JPF model checker. We developed IoTCheck conflict analysis
asaJPFlistenerthatperformstheanalysiswhileJPFisexecuting
the bytecode. When a conflict is detected, the listener halts JPF
and immediately reports the conflict. Otherwise, JPF finishes its
executionandthe listenerreports that there isnoconflict.
Challenges. There are 3 challenges in extending JPF for IoTCheck:
(1)JPFdoesnotprovideout-of-the-boxsupportforchecking
Groovy code. One challenge is that the Groovy runtime system
keeps its own internal state that thwarts JPFâ€™s state matching algo-
rithm; this often prevents even very simple Groovy programs from
model-checking.IoTCheckextendsJPFtoconsideronlythestateof
thevirtualsmarthomedevicesandtheappswhenmatchingstatesÃ
it ignores state changes that are internal to the Groovy runtime
library and do not affect the behavior of apps. This creates a sec-
ond issueÃJPF generates state matching points at many execution
points.AftereliminatingGroovyruntimestatefromstatematching,
therecanbespuriousstatematchesterminatingJPFbeforethestate
space is fully explored. To solve this problem, IoTCheck extends
JPFto only matchstates right before generatinganewevent.
(2) Groovy is a dynamic language. Thus, method calls are re-
solved at runtime via Java ReflectionÃJPF was missing this feature
and we had to extend it. Furthermore, the same call stack from the
perspective of the program can be implemented by many differ-
entbytecode-level call stacks due toGroovyâ€™s method lookup and
caching mechanisms. Since the call stack is considered by JPFâ€™s
state matching algorithm, this can cause the algorithm to fail to
match conceptually identical states and increasethe statespace to
beexplored.IoTCheckextendsJPFâ€™sstatematchingalgorithmto
match conceptually identical call stacks with different bytecode-
level stacks.
(3) Scalability is a challenge for JPF as an explicit-state
model checker. IoTCheck initially exhaustively model-checks a
app pair for up to 30 minutes. If it either a detects a conflict or
completes, IoTCheck outputs the result and finishes. Otherwise,
IoTCheck falls back on JPFâ€™s heuristic search and performs it for
an extended 30-minute period. If no conflict is detected during this
period or the tool runs out memory (usually caused by bigger apps
that have tens of events), IoTCheck reports that the result is incon-
clusive.Futureworkcanemploytechniquessuchaspartialorder
reduction to further improve IoTCheckâ€™s performance.
Detection. Conflicts cannot be directly checked on the executions
JPFexploresbecausestate-basedmodelcheckingisonlyguaranteed
to explore all program states and transitions and not all possible
pathsthroughthestatemachine.Considerapps ğ›¼1andğ›¼2whereğ›¼1
onlyturnsthelightonand ğ›¼2canturnthelightonandoff.Aconflict
only occurs when ğ›¼1turns the light on followed by ğ›¼2turning the
lightoff.However,allstatesandtransitionscanbereachedwithout
exploring this execution path. Thus, we must analyze the state
machine to determinewhether itcontains aconflicting path.
IoTCheckâ€™s conflict analysis is an online analysis of the state
machine that JPF explores. Our analysis is similar to a standard
dataflow compileranalysiswith theexception thatinour contextTable 6:Comparisonbetween manualstudyand IoTCheck.
Interaction IoTCheck Manual Study
Conflict Noconflict
Device Conflict 679 38
Noconflict 33 101
Not terminated 16 396
Excluded 100 75
Global-Variable Conflict 98 16
Noconflict 0 318
Not terminated 0 388
Excluded 26 235
nodesrepresentstatesandedgesrepresenttransitions.IoTCheck
updates its analysis results as JPF explores new states and halts
the exploration process when a conflict is detected. We abstract
state machine as a set of nodes ğ‘›âˆˆ Nthat represent the JPF states,
and edges ğ‘’âˆˆ Ethat represent transitions between JPF states.
Wedenotesequencesofactionsusing ğ´(see execution trace def-
initions in Section 3.1). Each transition ğ‘’has a corresponding se-
quence of actions ğ´ğ‘’. The relevant actions are write(ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£)
andmodewrite( ğ›¼,ğœ‡). We define in(ğ‘›)to be the set of incoming
edgestoğ‘›andsrc(ğ‘’)tobethesourcenodeoftheedge ğ‘’.Theanaly-
siscomputestheset ğ‘†(ğ‘›)ofthemostrecentupdatestoeachdevice
featureandmodeatnode ğ‘›.Wedefine app(ğ‘†,ğ‘‘,ğ‘Ÿ)tobethesetof
appsthathavemostrecentlyupdated ğ‘Ÿonğ‘‘andvalue(ğ‘†,ğ‘‘,ğ‘Ÿ)tobe
thevalueofthatupdate.Wedefine modeapp (ğ‘†)toreturnthesetof
apps that have most recently updated the mode and modevalue (ğ‘†)
to return the valuesofthe mostrecent updateto the mode set.
Figure4presentsequationsthatformalizeouranalysis.These
equations are evaluated using a standard fixed point algorithm
wheneverJPFexploresanew transitiontoeitheranexistingstate
oranewstate.Function ğœ™appliesthesequenceofactionsintransi-
tionto thesetSfor thepreviousnodetocomputethetransitionâ€™s
contributionstosetSforthedestinationnode.Thefunction update
applies an action to setS.
Results. We repeated the same set of evaluations, but using
IoTChecktocheckforconflictsinsteadofmanualinspection.Ta-
ble6comparesIoTCheckâ€™sresultswiththosefromthemanualstudy.
We did not use IoTCheck to detect conflicts in physical-medium
interactionssince theseconflictsdepend onphysical factors.
Forthedeviceinteraction,weinitiallyfound829conflictingpairs
through manual study: 632 pairs with feature conflict , 76 pairs with
invalid-local-state conflicts, and 121 pairs with dropped-update con-
flicts(seeTable 3).Fromthe829pairs,wehadtoexclude100conflict-
ing pairs because of the 8 apps that we could not run on IoTCheck:
5apps usethird-partyfeatures and3apps have seriousbugs.Be-
cause of these 8 apps, we also had to exclude 75 non-conflicting
pairs. Overall, IoTCheck was able to find conflicts in 679 pairs but
failed to detect conflicts in 33 pairsÃa thorough manual inspection
confirmed that 8 pairs are indeed non-conflicting ( i.e., mistakes in
ourmanualstudy),whileotherconflictswerenotdetecteddueto
IoTCheckâ€™slimitations( e.g.,inourmodelingoftime).Italsodidnot
terminate for 16 pairs labeled as conflicting in the manual study,
but4ofthemareindeednon-conflicting.Surprisingly,IoTCheck
found 38 newconflicting pairs that were overlooked in our manual
studyandlabeledasnon-conflicting.Thus,intotalIoTCheckfound
717conflicting pairs. Forthe 497pairslabeledasnon-conflicting
inthe manualstudy, IoTCheckconfirms that101pairsareindeed
non-conflicting, whereas itdidnot terminatefor 396of them.
1224UnderstandingandAutomatically DetectingConflicting Interactions ... ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
ğ‘†(ğ‘›)=/uniontext.1
ğœ–âˆˆin(ğ‘›)ğœ™(ğ´ğ‘’,ismanual (ğœ–),ğ‘†(in(ğœ–))ğœ™(âˆ…,ğœ†,ğ‘†)=ğ‘†
ğœ™(ğ´;write(ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£),ğœ†,ğ‘†)=/braceleftBigg
conflict, if(âˆƒğ‘âˆˆapp(ğ‘†,ğ‘‘,ğ‘Ÿ).ğ‘â‰ ğ›¼âˆ§value(ğ‘†,ğ‘‘,ğ‘Ÿ)â‰ ğ‘£âˆ§Â¬ğœ†)
update(ğœ™(ğ´,ğœ†,ğ‘†),ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£ ))otherwise
ğœ™(ğ´;modewrite( ğ›¼,ğœ‡),ğœ†,ğ‘†)=/braceleftBigg
conflict, if(âˆƒğ‘âˆˆmodeapp (ğ‘†).ğ‘â‰ ğ›¼âˆ§modevalue (ğ‘†)â‰ ğœ‡âˆ§Â¬ğœ†)
update(ğœ™(ğ´,ğœ†,ğ‘†),modewrite( ğ›¼,ğœ‡))otherwise
update(ğ‘†,A)={Aâ€²âˆˆğ‘†| Â¬Aâ‰œAâ€²}âˆª {A}
(write(ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£)â‰œwrite(ğ›¼â€™,ğ‘‘â€™,ğœâ€™,ğ‘Ÿâ€™,ğ‘£â€™)):=(ğ‘‘=ğ‘‘â€²) âˆ§ (ğ‘Ÿ=ğ‘Ÿâ€²)(modewrite( ğ›¼,ğœ‡)â‰œwrite(ğ›¼,ğ‘‘,ğœ,ğ‘Ÿ,ğ‘£)):=false
(modewrite( ğ›¼,ğœ‡)â‰œmodewrite( ğ›¼â€™,ğœ‡â€™)):=true
Figure 4:Conflict Analysis
For theglobal-variable interaction, our manual study found 124
pairsofconflictingapps:44pairswith app-appwrite-write conflicts
and80pairswith app-directwrite-write conflicts(seeTable 5).With
IoTCheck, we were able to find conflicts in 98 of the 124 pairs. We
had to exclude 26 of the pairs with conflicts because of 6 apps that
wecouldnotrunonIoTCheck:5appsusethird-partyfeaturesand1
app has serious bugs. Additionally, IoTCheck found 16 pairs with a
conflict that was initially labeled as a non-conflicting pair. Because
weexcluded6apps,wehadtoexclude235non-conflictingpairsini-
tiallyobservedinthemanualstudy. Amongthe706non-conflicting
pairslabeledin themanualstudy,IoTCheckwasable tocomplete
itscheckandfoundnoconflictsin318ofthem.IoTCheckdidnot
terminate for 388 of them. For the physical-medium interaction,
IoTCheckgenerates awarningif one app uses adevice that could
be the physical inputofadevice usedbythe otherapp.
Statistics. TheaverageruntimeforIoTChecktofindconflictsis
27 seconds for the deviceinteraction, and 11 seconds for the global-
variableinteraction. These suggest that conflicts are found quickly:
the30-minutetimelimitisenoughtoperformanexhaustivemodel
checkingingeneral.Thus,classifyingnon-terminatingrunsasnon-
conflictgivesIoTCheckaprecisionof100%andaspecificityof100%.
The recall is 95.1% for the deviceinteraction pairs and 100% for the
global-variable interaction pairsÃoverallrecallis95.7%.
FalsePositives. The false positives/negatives in our manual study
were typically due to subtle issues involving complex logic that
had several conditions for generating commands or subtle concur-
rentexecutionsÃpleaseseeourtoolanddatasetreleasesforafull
accounting [ 71Å›73].
8 RELATED WORK
The research community has recently looked into smart home
apps [25,30,35,36,39,40,55,61,70,83].Fernandes et al.present
a thorough study on the SmartThings environment [ 39]. They
pointed out underlying security issues and a simple program anal-
ysis to detect the overprivilege issue in the app source code. In [ 40],
Fernandes et al.present a solution to prevent applications from
leaking confidential information.
Researchershavepresentednewtechniquestomodel-checkand
analyze confidential information leakage in smart home applica-
tions. Thetechniques presented in [ 60,61] requiretranslatingthe
apps to perform the model checking using SPIN [ 45]. The limi-
tation is that the expressiveness of app features could be lost in
translation: with just3 apps the authors found 1 feature that their
system could not express concisely [ 60]. Other work [ 30,35,36]
ignores internal application state, and thus admits executions that
cannot happen. Several of our apps depend on internal state todecidewhethertoperformanaction,andthustheywouldnotbe
accuratelymodeledbytheirtechniques.Whileconflictsbetween
apps are discussed in [ 36], they considered a much smaller cor-
pus of apps and a number of of them are self-crafted to generate
theintendedconflicts.Unfortunately,theirsystemisnotpublicly
available for comparison.
Theinteractionsofsmarthomeappsalsoappearsimilartoevent-
based races inmobile apps [ 31,46,47,57,66]. Related work on mo-
bile apps deals with events only in one app by introducing various
newsynchronization mechanisms.However, our work focuses on
theinteractionsbetweenmultipleapps.Theeventhandlersinthese
appsaredevelopedbydifferentprogrammerswithabsolutelyno
coordination. Inaddition,a numberofapps alsoallowthe user to
generate arbitrary events, e.g.,using a touch screen. Hence, even if
the ordering between events in one app can be clearly defined, the
ordering between events across multiple apps combined with user-
generatedeventsiscomplicatedandarbitraryÃsynchronizations
inindividualapps wouldnot be useful inthis context.
There have also been efforts to resolve the conflicts between
smarthomeappsfromtheperspectiveofdependenciesbetweenap-
plicationcomponentsatthesystemlevel[ 58,75,76,79,80].Several
systems[75,76,79]provideframeworksforprogrammingnetworks
of sensors and actuators. DepSys [ 58] provides infrastructure with
comprehensive strategies to specify, detect, and resolve conflicts
throughtheuseofuser-specifiedmetadata.Kripke[ 80]performs
conflict detection through the use of model checking. Our work is
orthogonaltothisbodyofworkthatattemptstodealwithconflicts
betweenappsatthesystemlevel,byviewingappsasblackboxes.
Ourwork,onthecontrary,studieshowappsinteractandwhatcan
be done at the sourcecode level to mitigate conflicts.
9 CONCLUSION
This paper presents a comprehensive study of interactions and
conflictsbetweensmarthomeapps,aswellasanautomatedtool
for finding conflicts. These results can be readily used to guide
future designofsmart home systemsandapps.
ACKNOWLEDGMENTS
Wethanktheanonymousreviewersfortheirinvaluablefeedback.
This project was partly supported by the National Science Founda-
tion under grants CNS-1613023, CNS-1703598, CNS-1763172, OAC-
1740210, CCF-1837120, CNS-2006437, CCF-2006948, CNS-2007737,
andbytheOfficeofNavalResearchundergrantsN00014-16-1-2913
andN00014-18-1-2037.
1225ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA Trimananda, Aqajari,Chuang,Demsky, Xu,andLu
REFERENCES
[1]2013. Forgiving Security. https://github.com/imbrianj/forgiving_security/blob/
master/forgiving_security.groovy .
[2]2014. Auto Humidity Vent. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/jonathan-a/auto-humidity-vent.src/auto-humidity-vent.groovy .
[3]2014. Close The Valve. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/close-the-valve.src/close-the-valve.groovy .
[4]2014. Hello,HomePhraseDirector. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/tslagle13/hello-home-phrase-director.src/hello-home-phrase-
director.groovy .
[5]2014. Lock it at a specific time. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/user8798/lock-it-at-a-specific-time.src/lock-it-at-a-specific-
time.groovy .
[6]2014. Sprayer Controller 2. https://github.com/erocm123/SmartThingsPublic-
1/blob/master/smartapps/sprayercontroller/sprayer-controller-2.src/sprayer-
controller-2.groovy .
[7]2015. Big Turn OFF. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/big-turn-off.src/big-turn-off.groovy .
[8]2015. Big Turn ON. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/big-turn-on.src/big-turn-on.groovy .
[9]2015. Bon Voyage. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/bon-voyage.src/bon-voyage.groovy .
[10]2015. Good Night. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/good-night.src/good-night.groovy .
[11]2015. Greetings Earthling. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/greetings-earthling.src/greetings-earthling.groovy .
[12]2015. Keep Me Cozy. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/keep-me-cozy.src/keep-me-cozy.groovy .
[13]2015. Light Up the Night. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/light-up-the-night.src/light-up-the-night.groovy .
[14]2015. Lock It When I Leave. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/lock-it-when-i-leave.src/lock-it-when-i-leave.groovy .
[15]2015. Smart Security. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/master/smartapps/smartthings/smart-security.
src/smart-security.groovy .
[16]2015. Turn On at Sunset. https://github.com/SmartThingsCommunity/Code/
blob/master/smartapps/sunrise-sunset/turn-on-at-sunset.groovy .
[17]2016. Initial State Event Streamer. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/master/smartapps/initialstate-events/initial-state-
event-streamer.src/initial-state-event-streamer.groovy .
[18]2016. UnderstandingIlluminance:Whatâ€™sinaLux? https://www.allaboutcircuits.
com/technical-articles/understanding-illuminance-whats-in-a-lux/ .
[19]2017. InfluxDB Logger. https://github.com/codersaur/SmartThings/blob/master/
smartapps/influxdb-logger/influxdb-logger.groovy .
[20]2017. Thermostats. https://github.com/SmartThingsCommunity/
SmartThingsPublic/blob/61b864535321a6f61cf5a77216f1e779bde68bd5/
smartapps/smartthings/thermostats.src/thermostats.groovy .
[21] 2018. IFTTT. https://www.ifttt.com/ .
[22] 2018. Initial State. https://www.initialstate.com/ .
[23]2018. Neato (Connect). https://github.com/alyc100/SmartThingsPublic/blob/
master/smartapps/alyc100/neato-connect.src/neato-connect.groovy .
[24] 2019. SmartThings GroovyIDE. https://graph.api.smartthings.com/ .
[25]Omar Alrawi, Chaz Lever, Manos Antonakakis, and Fabian Monrose. 2019. Sok:
Security evaluation of home-based iot deployments. In 2019 IEEE Symposium on
Securityand Privacy (SP) . IEEE,1362Å›1380.
[26]Sven Apel,Sergiy Kolesnikov,NorbertSiegmund,ChristianKÃ¤stner,andBrady
Garvin. 2013. Exploring Feature Interactions in the Wild: The New Feature-
interactionChallenge.In Proceedingsofthe5thInternationalWorkshoponFeature-
OrientedSoftwareDevelopment (FOSD) . 1Å›8.
[27]Sven Apel, Wolfgang Scholz, Christian Lengauer, and Christian KÃ¤stner. 2010.
DetectingDependencesandInteractionsinFeature-OrientedDesign.In IEEE21st
InternationalSymposiumonSoftwareReliability Engineering (ISSRE) . 161Å›170.
[28]SvenApel,AlexanderVonRhein,ThomasThÃ¼M,andChristianKÃ¤Stner.2013.
Feature-interactionDetectionBasedonFeature-basedSpecifications. Computer
Networks: The International Journal of Computer and Telecommunications Net-
working57,12(August 2013),2399Å›2409.[29]Hamid Bagheri, Alireza Sadeghi, Reyhaneh Jabbarvand, and Sam Malek. 2016.
Practical, formal synthesis and automatic enforcement of security policies for
android.In 201646thAnnualIEEE/IFIPInternationalConferenceonDependable
Systemsand Networks (DSN) . IEEE,514Å›525.
[30]ZBerkayCelik,EarlenceFernandes,EricPauley,GangTan,andPatrickMcDaniel.
2018. ProgramAnalysisofCommodityIoTApplicationsforSecurityandPrivacy:
Challengesand Opportunities. arXiv preprint arXiv:1809.06962 (2018).
[31]Pavol Bielik, Veselin Raychev, and Martin Vechev. 2015. Scalable Race Detection
for Android Applications. In Proceedings of the 2015 ACM SIGPLAN International
ConferenceonObject-OrientedProgramming,Systems,Languages,andApplications
(Pittsburgh,PA,USA) (OOPSLA2015) .ACM,NewYork,NY,USA,332Å›348. https:
//doi.org/10.1145/2814270.2814303
[32]Amiangshu Bosu, Fang Liu, Danfeng Daphne Yao, and Gang Wang. 2017. Collu-
sivedataleakandmore:Large-scalethreatanalysisofinter-appcommunications.
InProceedings of the 2017 ACM on Asia Conference on Computer and Communica-
tions Security . ACM,71Å›85.
[33]Muffy Calder, Mario Kolberg, Evan H Magill, and Stephan Reiff-Marganiec. 2003.
Featureinteraction:acriticalreviewandconsideredforecast. ComputerNetworks
41,1 (2003), 115Å›141.
[34]Nguyen Tan Cam, Pham Van Hau, and Tuan Nguyen. 2016. Android security
analysis based on inter-application relationships. In Information Science and
Applications(ICISA)2016 . Springer, 689Å›700.
[35]Z Berkay Celik,LeonardoBabun, Amit Kumar Sikder, Hidayet Aksu, Gang Tan,
Patrick McDaniel, and A Selcuk Uluagac. [n.d.]. Sensitive Information Tracking
in Commodity IoT. In 27th USENIX Security Symposium (USENIX Security 18) .
USENIXAssociation.
[36]Z Berkay Celik, Patrick McDaniel, and Gang Tan. 2018. Soteria: Automated
IoTSafetyandSecurityAnalysis.In 2018USENIXAnnualTechnicalConference
(USENIXATC 18) . USENIXAssociation.
[37]Guang-IenCheng,MingdongFeng,CharlesE.Leiserson,KeithH.Randall,and
AndrewF.Stark.1998. DetectingDataRacesinCilkProgramsThatUseLocks.
InProceedingsoftheTenthAnnualACMSymposiumonParallelAlgorithmsand
Architectures (Puerto Vallarta, Mexico) (SPAA â€™98) . ACM, New York, NY, USA,
298Å›309. https://doi.org/10.1145/277651.277696
[38]Dawson Engler and Ken Ashcraft. 2003. RacerX: Effective, Static Detection of
RaceConditionsandDeadlocks.In ProceedingsoftheNineteenthACMSymposium
onOperatingSystemsPrinciples (BoltonLanding,NY,USA) (SOSPâ€™03) .ACM,New
York, NY, USA,237Å›252. https://doi.org/10.1145/945445.945468
[39]Earlence Fernandes, Jaeyeon Jung, and Atul Prakash. 2016. Security analysis
ofemergingsmarthomeapplications.In 2016IEEESymposiumonSecurityand
Privacy (SP) . IEEE,636Å›654.
[40]Earlence Fernandes, Justin Paupore, Amir Rahmati, Daniel Simionato, Mauro
Conti, andAtulPrakash.2016. FlowFence:PracticalDataProtection forEmerg-
ing IoTApplication Frameworks.In 25th USENIX Security Symposium(USENIX
Security 16) . USENIX Association, Austin, TX, 531Å›548. https://www.usenix.
org/conference/usenixsecurity16/technical-sessions/presentation/fernandes
[41]Cormac Flanagan and Stephen N Freund. 2004. Atomizer: A Dynamic Atomicity
CheckerforMultithreadedPrograms.In Proceedingsofthe31stACMSIGPLAN-
SIGACTSymposiumonPrinciplesofProgrammingLanguages (Venice,Italy) (POPL
â€™04). ACM, New York, NY, USA, 256Å›267. https://doi.org/10.1145/964001.964023
[42]TheApacheSoftwareFoundation.2003-2018. TheApacheGroovyprogramming
language. http://groovy-lang.org/ .
[43] Google. 2018. Android Things website. https://developer.android.com/things/ .
[44]Yi He, Qi Li, and Kun Sun. 2017. LinkFlow: Efficient Large-Scale Inter-app
PrivacyLeakageDetection.In InternationalConferenceonSecurityandPrivacyin
Communication Systems . Springer, 291Å›311.
[45]Gerard J Holzmann. [n.d.]. The SPIN model checker: Primer and reference manual .
Vol. 1003.
[46]Chun-HungHsiao,JieYu,SatishNarayanasamy,ZiyunKong,CristianoL.Pereira,
Gilles A. Pokam, Peter M. Chen, and Jason Flinn. 2014. Race Detection for
Event-driven Mobile Applications. In Proceedings of the 35th ACM SIGPLAN
Conference on Programming Language Design and Implementation (Edinburgh,
United Kingdom) (PLDI â€™14) . ACM, New York, NY, USA, 326Å›336. https://doi.
org/10.1145/2594291.2594330
[47]Yongjian Hu and Iulian Neamtiu. 2018. Static Detection of Event-based Races
in Android Apps. In Proceedings of the Twenty-Third International Conference
on Architectural Support for Programming Languages and Operating Systems
(Williamsburg, VA, USA) (ASPLOS â€™18) . ACM, New York, NY, USA, 257Å›270.
https://doi.org/10.1145/3173162.3173173
[48]Michael Jackson and Pamela Zave. 1998. Distributed Feature Composition: A
Virtual Architecture for Telecommunications Services. IEEE Transactions on
SoftwareEngineering 24,10(October 1998),831Å›847.
[49]YounKyuLee,JaeYoungBang,GholamrezaSafi,ArmanShahbazian,YixueZhao,
andNenadMedvidovic.2017. Asealantforinter-appsecurityholesinandroid.
In2017IEEE/ACM39thInternationalConferenceonSoftwareEngineering(ICSE) .
IEEE,312Å›323.
[50]Pattara Leelaprute, Takafumi Matsuo, Tatsuhiro Tsuchiya, and Tohru Kikuno.
2008. DetectingFeatureInteractionsinHomeApplianceNetworks.In Proceedings
1226UnderstandingandAutomatically DetectingConflicting Interactions ... ESEC/FSE â€™20, November8â€“13,2020,VirtualEvent, USA
ofthe2008NinthACISInternationalConferenceonSoftwareEngineering,Artificial
Intelligence,Networking,and Parallel/DistributedComputing(SNPD) . 895Å›903.
[51]LiLi,AlexandreBartel,TegawendÃ©FBissyandÃ©,JacquesKlein,andYvesLeTraon.
2015. Apkcombiner: Combining multiple android apps to support inter-app anal-
ysis.InIFIPInternationalInformationSecurityandPrivacyConference .Springer,
513Å›527.
[52]Xinyi Li, Lei Zhang, and Xipeng Shen. 2019. IA-graph Based Inter-app Conflicts
DetectioninOpenIoTSystems.In Proceedingsofthe20thACMSIGPLAN/SIGBED
InternationalConferenceonLanguages,Compilers,andToolsforEmbeddedSystems .
135Å›147.
[53]Xinyi Li, Lei Zhang, Xipeng Shen, and Yong Qi. 2017. A Systematic Examination
ofInter-AppConflictsDetectionsinOpenIoTSystems . TechnicalReportTR-2017-1.
North CarolinaState University, Dept.of Computer Science.
[54] Christopher Lidburyand AlastairF. Donaldson. 2017. Dynamic Race Detection
forC++11.In Proceedingsofthe44thACMSIGPLANSymposiumon Principlesof
Programming Languages (Paris, France) (POPL 2017) . ACM, New York, NY, USA,
443Å›457. https://doi.org/10.1145/3009837.3009857
[55]Renju Liu, Ziqi Wang, Luis Garcia, and Mani Srivastava. 2019. RemedioT: Re-
medialActionsforInternet-of-ThingsConflicts.In Proceedingsofthe6thACM
International Conference on Systems for Energy-Efficient Buildings, Cities, and
Transportation (BuildSysâ€™19) . 101Å›110.
[56]ShanLu,SoyeonPark,andYuanyuanZhou.2012. Findingatomicity-violation
bugsthroughunserializableinterleavingtesting. IEEETransactionsonSoftware
Engineering 38,4 (2012), 844Å›860.
[57]Pallavi Maiya, Aditya Kanade, and Rupak Majumdar. 2014. Race Detection
for Android Applications. SIGPLAN Not. 49, 6 (June 2014), 316Å›325. https:
//doi.org/10.1145/2666356.2594311
[58]SirajumMunirandJohnA.Stankovic.2014. DepSys:DependencyAwareInte-
grationofCyber-PhysicalSystemsforSmartHomes.In ICCPSâ€™14:ACM/IEEE5th
International Conference on Cyber-Physical Systems (with CPS Week 2014) (Berlin,
Germany) (ICCPS â€™14) . IEEE Computer Society, Washington, DC, USA, 127Å›138.
https://doi.org/10.1109/ICCPS.2014.6843717
[59]Chandrakana Nandi and Michael D. Ernst. 2016. Automatic Trigger Genera-
tionforRule-basedSmartHomes.In Proceedingsofthe2016ACMWorkshopon
ProgrammingLanguages and Analysisfor Security(PLAS) . 97Å›102.
[60]JulieLNewcomb,SatishChandra,Jean-BaptisteJeannin,ColeSchlesinger,and
Manu Sridharan. 2017. IOTA: a calculus for internet of things automation. In
Proceedings of the 2017 ACM SIGPLAN International Symposium on New Ideas,
NewParadigms,and ReflectionsonProgrammingand Software . 119Å›133.
[61]DangTuNguyen,Chengyu Song,ZhiyunQian,SrikanthV.Krishnamurthy, Ed-
ward J. M.Colbert, and PatrickMcDaniel.2018. IotSan: Fortifyingthe Safetyof
Systems.In Proceedingsofthe14thInternationalConferenceonEmergingNetwork-
ing EXperiments and Technologies (Heraklion, Greece) (CoNEXT â€™18) . ACM, New
York, NY, USA,191Å›203. https://doi.org/10.1145/3281411.3281440
[62] openHAB.2018. openHAB website. https://www.openhab.org/ .
[63]SebastianOster,MariusZink,MalteLochau,andMarkGrechanik.2011. Pairwise
Feature-interaction Testing forSPLs: Potentials andLimitations. In Proceedings
ofthe15thInternationalSoftwareProductLineConference (SPLC) .Article6,6:1Å›
6:8 pages.
[64]Yves Racine. 2014. FireCO2Alarm SmartApp. https://github.com/yracine/device-
type.myecobee/blob/master/smartapps/FireCO2Alarm.src/FireCO2Alarm.
groovy.
[65]AjithaRajan,LydieduBousquet,YvesLedru,GermanVega,andJean-LucRichier.
2010. Assertion-basedTestOraclesforHomeAutomationSystems.In Proceedings
of the 7th International Workshop on Model-Based Methodologies for Pervasive and
EmbeddedSoftware(MOMPRES) . 45Å›52.
[66]Veselin Raychev, Martin Vechev, and Manu Sridharan. 2013. Effective Race
Detection forEvent-drivenPrograms.In Proceedingsofthe 2013ACM SIGPLAN
International Conference on Object Oriented Programming Systems Languages&#38;Applications (Indianapolis,Indiana,USA) (OOPSLAâ€™13) .ACM,NewYork,
NY, USA,151Å›166. https://doi.org/10.1145/2509136.2509538
[67]ChrisSader.2013. AutoLockDoorSmartApp. https://github.com/smartthings-
users/smartapp.auto-lock-door/blob/master/auto-lock-door.smartapp.groovy .
[68]SmartThings. 2018. SmartThings Public GitHub Repo. https://github.com/
SmartThingsCommunity/SmartThingsPublic .
[69]Samsung SmartThings. 2018. Samsung SmartThings website. http://www.
smartthings.com .
[70]YuanTian,NanZhang,Yueh-HsunLin,XiaoFengWang,BlaseUr,XianZheng
Guo,andPatrickTague.2017. Smartauth:User-centeredAuthorizationforthe
Internet of Things. In Proceedings of the 26th USENIX Conference on Security
Symposium (Vancouver, BC, Canada) (SECâ€™17). USENIX Association, Berkeley,
CA, USA,361Å›378. http://dl.acm.org/citation.cfm?id=3241189.3241219
[71]RahmadiTrimananda,SeyedAmirHosseinAqajari,JasonChuang,BrianDemsky,
and Guoqing Harry Xu. 2020. IoTCheck. http://plrg.ics.uci.edu/iotcheck/ .https:
//doi.org/10.5281/zenodo.3866497
[72]RahmadiTrimananda,SeyedAmirHosseinAqajari,JasonChuang,BrianDemsky,
and Guoqing Harry Xu. 2020. IoTCheck and manual study supporting materials.
http://plrg.ics.uci.edu/iotcheck/ .https://doi.org/10.5281/zenodo.3866499
[73]RahmadiTrimananda,SeyedAmirHosseinAqajari,JasonChuang,BrianDemsky,
and Guoqing Harry Xu. 2020. IoTCheck Vagrant package. http://plrg.ics.uci.edu/
iotcheck/ .https://doi.org/10.5281/zenodo.3866491
[74]Yutaka Tsutano, Shakthi Bachala, Witawas Srisa-An, Gregg Rothermel, and Jack-
sonDinh.2017. Anefficient,robust,andscalableapproachforanalyzinginter-
acting android apps. In 2017 IEEE/ACM 39th International Conference on Software
Engineering (ICSE) . IEEE,324Å›334.
[75]Pascal A Vicaire, Enamul Hoque, Zhiheng Xie, and John A Stankovic. 2012.
Bundle: A group-based programming abstraction for cyber-physical systems.
IEEE Transactions onIndustrial Informatics 8,2 (2012), 379Å›392.
[76]PascalAVicaire,ZhihengXie,EnamulHoque,andJohnAStankovic.2010. Phys-
icalnet:Agenericframeworkformanagingandprogrammingacrosspervasive
computingnetworks.In Real-TimeandEmbeddedTechnologyandApplications
Symposium(RTAS),201016thIEEE . IEEE,269Å›278.
[77]William Visser, Klaus Havelund, Guillaume Brat, SeungJuun Park, and Flavio
Lerda.2003. Modelchecking programs. 10(April2003),203Å›232. Issue 2.
[78]Michael Wilson, Mario Kolberg, and Evan H. Magill. 2008. Considering side
effectsinserviceinteractionsinhomeautomation-anonlineapproach. Feature
Interactions inSoftwareand Communication SystemsIX (2008), 172Å›187.
[79]Anthony D Wood, John A Stankovic, Gilles Virone, Leo Selavo, Zhimin He,
Qiuhua Cao, Thao Doan, Yafeng Wu, Lei Fang, and Radu Stoleru. 2008. Context-
awarewirelesssensornetworksforassistedlivingandresidentialmonitoring.
IEEE network 22,4 (2008).
[80]Miki Yagita, Fuyuki Ishikawa, and Shinichi Honiden. 2015. An Application
ConflictDetectionandResolutionSystemforSmartHomes.In Proceedingsofthe
First International Workshop on Software Engineering for Smart Cyber-Physical
Systems(Florence, Italy) (SEsCPS â€™15) . IEEE Press, Piscataway, NJ, USA, 33Å›39.
http://dl.acm.org/citation.cfm?id=2821404.2821413
[81]SvetlanaYaroshandPamelaZave.2017. LockedorNot?:MentalModelsofIoT
FeatureInteraction.In Proceedingsofthe2017ConferenceonHumanFactorsin
ComputingSystems(CHI) . 2993Å›2997.
[82]AdarshYogaandSantoshNagarakatte.2016. AtomicityViolationCheckerfor
Task Parallel Programs. In Proceedings of the 2016 International Symposium on
CodeGenerationandOptimization (Barcelona,Spain) (CGOâ€™16) .ACM,NewYork,
NY, USA,239Å›249. https://doi.org/10.1145/2854038.2854063
[83]WeiZhang,YanMeng,YugengLiu,XiaokuanZhang,YinqianZhang,andHaojin
Zhu.2018. HoMonit: MonitoringSmartHomeAppsfromEncrypted Traffic.In
Proceedingsofthe2018ACMSIGSACConferenceonComputerandCommunications
Security(Toronto, Canada) (CCS â€™18) . ACM, New York, NY, USA, 1074Å›1088.
https://doi.org/10.1145/3243734.3243820
1227