Dynamic Update for Synthesized GR(1) Controllers
Gal Amram
Tel Aviv UniversityShahar Maoz
Tel Aviv University
Itai Segall
Nokia Bell LabsMatan Yossef
Tel Aviv University
ABSTRACT
Reactive synthesis is an automated procedure to obtain a correct-by-
construction reactive system from its temporal logic speci cation. 
GR(1) is an expressive fragment of LTL that enables efficient synthe-
sis and has been recently used in different contexts and application 
domains. In this paper we investigate the dynamic-update problem 
for GR(1): updating the behavior of an already running synthesized 
controller such that it would safely and dynamically, without stop-
ping, start conforming to a modi ed, up-to-date speci cation. We 
formally de ne the dynamic-update problem and present a  sound 
and complete solution that is based on the computation of a bridge-
controller. We implemented the work in the Spectra synthesis and 
execution environment and evaluated it over benchmark speci -
cations. The evaluation shows the efficiency and effectiveness of 
using dynamic updates. The work advances the state-of-the-art 
in reactive synthesis and opens the way to its use in application 
domains where dynamic updates are a necessary requirement.
ACM Reference Format:
Gal Amram, Shahar Maoz, Itai Segall, and Matan Yossef. 2022. Dynamic 
Update for Synthesized GR(1) Controllers. In 44th International Conference on 
Software Engineering (ICSE ’22), May 21–29, 2022, Pittsburgh, PA, USA. ACM, 
New York, NY, USA, 12 pages. https://doi.org/10.1145/3510003.3510054
1 INTRODUCTION
Reactive synthesis is an automated procedure to obtain a correct-
by-construction reactive system from its temporal logic speci ca-
tion [35]. Rather than manually constructing an implementation of 
a reactive controller and using model checking to verify it against 
a speci cation, synthesis offers  an approach where a correct im-
plementation is automatically obtained for a given speci cation, if 
such an implementation exists.
GR(1) is a fragment of Linear Temporal Logic (LTL) that has an 
efficient symbolic synthesis algorithm [7 ] and whose expressive 
power covers most of the well-known LTL speci cation patterns of 
Dwyer et al. [10, 24]. GR(1) speci cations include assumptions and 
guarantees about what needs to hold on all initial states, on all states 
and transitions (safety), and in nitely often on every run (justice). 
GR(1) has been used in several application domains, e.g., to spec-
ify and implement autonomous robots [20, 25], control protocols 
for smart camera networks [33], distributed control protocols for
.
This work is licensed under a Creative Commons Attribution International 4.0 License.
ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9221-1/22/05.
https://doi.org/10.1145/3510003.3510054aircraft vehicle management systems[ 32], and device drivers[ 36].
Several tools support GR(1) synthesis [6, 11, 26, 38].
Many reactive systems are very difficult or very expensive to
stop.Examplesincludemissionandbusinesscriticalsystemswhose
continuous operation is one of their key requirements. Thus, whenupdatesinfunctionalityarerequired,thebehaviorofsuchasystemhastobeupdatedwhileitisexecuting.Indeed,ourmainmotivation
for the present work comes from a proof-of-concept project we
have conducted, on using reactive synthesis in several application
domains,asacollaborationbetweenTelAvivUniversityandNokia
BellLabs.Dynamicupdatewaspresentedbytheindustrypartner
as a necessary requirement for the use of reactive synthesis in the
target application domain.
Inthisworkwepresentaformulationandsolutionofthe
dynamic-updateproblemforsynthesizedGR(1)reactivesys-tems.
Specifically,givenanalreadyexecutingcontroller C1,synthe-
sized from some GR(1) specification Spec1, and given anew GR(1)
specification Spec2, we formalize a notion of an update-strategy, a
strategyforthesystemtoforcetheexecutiononapathfromthe
current state of C1to some state of C2, a controller synthesized
fromSpec2, while taking some steps in compliance with Spec1and
from some point on start taking steps in compliance with Spec2.
Notethatanupdate-strategyexecutionstartsfromthecurrentstate
ofC1, which is a moving target. The dynamic-update problem is to
compute and then execute such an update-strategy, if one exists.
We solve the dynamic-update problem for GR(1) by showing
how to construct a bridge controller, which implements an update-
strategy,andapplyitto C1dynamically,whileitisexecuting.We
provethatoursolutioniscorrectandcomplete,i.e.,thatwhenan
update is possible we find one and execute it, and when an update
is not possible, we report so. We further prove that our solution is
optimal, i.e., that it minimizes the maximal possible bridge length.
Finally, we present a heuristic optimization based on the early
detectionofasuccessfulupdate,whichaimstosavecomputation
time and to shorten the length of the actualbridge that is executed.
This optimization is one of the unique features of our work, taking
advantage of the dynamic nature of the problem.
An important characteristics of our setup and algorithms is that
they are symbolic. Thus, the update-strategy we compute is a sym-
bolic representation of all possible correct and shortest bridges.
Then, the actual bridge that will be executed depends on the state
in which the running controller might be in when the bridge is
ready, and of course on the behavior of the environment.
Note that the dynamic-update problem is relevant for setups
where the synthesized controller is implemented in software, as in,
e.g., various robotics setups [ 20,25,26], and not in setups where
itisexpectedtobeimplementedasahardwarecircuit,e.g.,inthe
AIGERformat[ 5]usedintheSYNTCOMPcompetitionseries[ 3].
7862022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Gal Amram, Shahar Maoz, Itai Segall, and Matan Yossef
Indeed,oursolutiontakesadvantageoftherecentlypresentedjust-
in-timereactivesynthesis[ 28],whichisapplicableonlytosoftware
implementationsof synthesized controllers.
We have implemented dynamic updates on top of the open-
source Spectra synthesis and execution environment [ 1,26]. Given
an already executing synthesized system, the implementation al-lows the engineer to define a new specification and dynamically
update the executing system to comply with it. We deliberately di-
vide the implementation between two machines that communicate
overTCP,themachinethatrunscontrollerand bridgesynthesis,
andthemachinethatexecutesthecontroller(e.g.,arobot).Thus,
ourimplementationsupportsatrulyremotedynamicdeployment
asisindeedrequiredinthetargetapplicationdomaindefinedby
Nokia Bell Labs.
We evaluated our work using three sets of benchmark specifi-
cations.Theevaluationshowstheefficiencyandeffectivenessofour work. All examples and experiment results we report on in
this paper are implemented in Spectra and available in supporting
materials [2].
The dynamic-update problem for synthesized controllers has
beenstudiedbefore.Inparticular,Nahabedianetal.studieddynamic
updates in the context of event-based controller synthesis [ 30].
Our work is distinctive in several ways, most notably (A) in its
applicabilityandexpressiveness-supportfortheGR(1)fragmentofLTL,including safetiesandjustices,with acomputationmodel
that is not specific to event-based specifications; and (B) in itsefficiency and scalability - thanks to the symbolic nature of the
algorithms and implementation. We discuss related work in detail
in Sect. 8.
1.1 An Illustrative Running Example
To demonstrate the dynamic-update problem and our solution, we
consider a variant of the obstacle evasion specification, which isinspired by robotic motion planning and was recently used as a
benchmarkinthesynthesisliterature,see,e.g.[ 11,14,31].Moreover,
thisproblemisverysimilarinnature,size,andexpectedupdates,
to the target application developed in Nokia Bell Labs, a general
platform for scheduling the activities of several robots while they
patrol and perform different tasks in an environment with several
target locations and obstacles. The target locations, the specifictasks, and the location of most obstacles are fixed during mostnormal execution but do change dynamically from time to time.
Scalabilityintermsofthenumberoflocationsanddynamicupdate
without stopping are considered critical requirements.
Consider a single cell sized robot and a 2 ×2 cells sized obstacle,
bothmovingonan n×ngrid.Initially,therobotandtheobstacle
start in two opposite corners of the grid. Both the robot and theobstacle can move to any adjacent cell. The robot moves twice
upon every step of the obstacle. Moreover, the obstacle chases
the robot and always tries to get closer to it. The problem is tosynthesize a strategy for the robot so that collision never occurs,
regardless of the obstacle’s behavior. We model the robot’s and ob-
stacle’s locations via two coordinates robX,robY∈{1,...,n}, and
obsX,obsY∈{1,...,n−1}.1Weprovidethecompletespecification
with simulation videos in supporting materials [2].
1The coordinates specify the location of the obstacle’s upper left corner.1...
2pred robotLoc(x,y): robX =x&r o b Y=y ;
3
4// locations the robot must never visit
5gar Avoid1: G!robotLoc(2,1);
6gar Avoid2: G!robotLoc(6,4);
7gar Avoid3: G!robotLoc(7,7);
8gar Avoid4: G!robotLoc(7,4);
9
10// locations the robot must visit infinitely often
11gar AlwEventuallyVisit1: GFrobotLoc(3,3);
12gar AlwEventuallyVisit2: GFrobotLoc(1,7);
13gar AlwEventuallyVisit3: GFrobotLoc(5,2);
14
15// a switching condition
16switch robotLoc(2,8);
Listing 1: Examples of safety (avoid) guarantees, justice (always-
visit) guarantees, and a switching condition, using Spectra syntax.
These are the parts of the specification that may be updated from
time to time in our example.
In addition to evading the moving obstacle, in our specification,
the robot has some safety guarantees, to avoid certain locations
(avoid guarantees) and some justice guarantees, to visit some other
locations infinitely often (always-visit guarantees).2We provide an
example of such guarantees in Lst. 1. Fig. 1 illustrates our example
grid world.
Mostimportantlyforthedynamicupdatecontext,theavoidand
always-visitguaranteesmaychangefromtimetotime.Specifically,
weconsiderthatduringthecontroller’sexecution,thesystemre-
quirementsmaychange,sotheengineershavetoupdatetherobot’s
avoidandalways-visitguarantees,whiletherobotisrunningand
as it continues to evade the moving obstacle. Moreover, we include
an optional switching condition, cond, specified by the declaration
switch.The switchingconditionrequires therobottoswitch to
thenewspecificationonlyinastatewheretheassertion condholds.
Again, the need for supporting an optional switching condition, as
partofthedynamic-updateproblem,isarequirementdefinedby
Nokia Bell Labs.
Notethatthisexamplesynthesisproblemisnottrivial.Asthe
robot evades the obstacle that chases it, it has not only to avoidcertain locations, but also to always eventually visit some otherlocations. Since the obstacle is chasing it, in order to make sureit can visit a location, the robot sometimes has to first “lure” the
obstacle to move farther from the target location in point and then,
whentheobstacleisfarenough,racetogettothetargetinpoint
before the obstacle gets there or blocks the way. On top of this
non-trivial behavior, we add here the dynamic update of the avoid
and always-visit locations.
We now demonstrate the dynamic-update use case. The engi-
neers have synthesized a controller from an obstacle evasion speci-
ficationandstartedexecutingitonarobot.Usingthiscontroller,the robot evades the moving obstacle that chases it while avoid-
ingsomecellsandalwayseventuallyvisitingsomeothercells,as
specified in the specification. After some time, the requirementschange, so the engineers write a new specification that includesup-to-date avoid and always-visit guarantees (and optionally aswitching condition). Thus, while the first controller is running,
the engineers use our tool to synthesize a controller for the new
2This is an instance of the patrolling pattern from [29].
787Dynamic Update for Synthesized GR(1) Controllers ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
Figure1: Anillustrationofourexampleinagridworldwitharobot
that has to avoid the Acells and always-visit the Vcells, all while
evading a 2x2 moving obstacle chasing it.
specificationand,mostimportantly,abridge-controller.Then,ifthe
bridgecoversthestateinwhichthefirstcontrollerhappenstobe
atwhenitisready,thebridgeforcestheexecutionoftherobotto
takesomestepsincompliancewiththefirstspecification,reacha
statethatsatisfiestheswitchingcondition(e.g., robotLoc(2,8)
(seeLst.1)),andfromthatpointonstarttakingstepsincompliance
withthenewspecification,eventuallystartingtoexecuteusingthe
new controller.
2 PRELIMINARIES
2.1 Reactive Systems
GivenasetofBooleanvariables V,astatesoverVisasubsetof V,
i.e.,s∈2V.Ifs1,...,snarestatesoverthedisjointsets V1,...,Vn,
resp., we write (s1,...,sn)as an abbreviation for s1∪···∪sn.A n
assertion overVisaBooleanformulaover V.Foranassertion ρ
andastate s,wewrite s|=ρ,ifρisevaluatedto truebyassigning
trueto all variables in sandfalseto variables in V\s.I fs|=ρ,
wesay that sisaρ-state.For asetof variables V,V/primeisthe setof
variablesobtainedbyreplacingeach v∈Vwithitsprimedversion,
v/prime∈V/prime. Furthermore, for a state soverV,s/primeis a state over V/prime
defined by s/prime={v/prime:v∈s}.
A reactive system repeatedly reacts to inputs coming from its
environment. This interaction is modeled as a two-player game,
played between the environment player and the system player.
At each turn the environment provides an input, and the system
replieswithanoutput.Thisinteractionisformallycapturedthrough
a game structure.
Agame structure is a tuple GS=(X,Y,θe,θs,ρe,ρs)3where
(1)Xisthesetofvariablesownedbytheenvironment;(2) Yisthe
setofvariablesownedbythesystem,anditisdisjointto X;(3)θeis
anassertionover X,whichconstitutesthe initialassumptions ofthe
3Some presentations use a game structure that includes a graph and a winning condi-
tion formula. In our notation they are separate. The difference is only notational.environment;(4) θsisanassertionover X∪Y,whichconstitutesthe
initialguarantees ofthesystem;(5) ρeisassertionover X∪Y∪X/prime
whichconstitutesthe safetyassumptions oftheenvironment;and
(6)ρsis an assertion over X∪Y∪X/prime∪Y/primewhich constitutes the
safety guarantees of the system.
Intuitively, a game structure models the two-player game de-
scribedabove asfollows. First,the environmentchoosesan input
s0x∈2Xsuchthat s0x|=θe,andthesystemreplieswithanoutput
s0y∈2Ysuch that (s0x,s0y)|=θs.(s0x,s0y)forms the play’s first state,
and then the players repeatedly construct the next states by choos-
ing inputs andoutputs. Fromstate s, the environmentcan choose
aninputsx∈2Xif(s,s/primex)|=ρe,andthesystemcanrespondwith
sy∈2Yif(s,s/primex,s/primey)|=ρs. Game structures naturally extend to
finite type variables, which are not necessarily Boolean.
Example 2.1. For the obstacle evasion example (see Sect. 1.1),
X={obsX,obsY}andY={robX,robY}.Theinitialassumptionsand
guaranteesare: θe=(obsX=7∧obsY=7);θs=(robX=1∧robY=
1).Thesafetyassumptionsmodelthewaytheobstaclemoves(toan
adjacent cell at each step). The safety guarantees are a conjunction
of movement restriction (two cells at most at each step) and the
avoid guarantees from Lst. 1, e.g., robX /nequal2∨robX /nequal1.
LetGS=(X,Y,θe,θs,ρe,ρs)be a game structure. The game
structure’sstatesare2X∪Y.Atransitionfromstate stostatetis
consistent withρe(resp.ρs,(ρe,ρs))i f(s,t/prime)|=ρe(resp.|=ρs,
|=ρe∧ρs). Consistency with ρeis defined also when t∈2X.A
transitionthatisconsistentwith ρe(resp.ρs,(ρe,ρs))iscalleda
ρe-transition (and resp. for the others). A sequence of states is con-
sistent with ρe(resp.ρs,(ρe,ρs)) if anypair of consecutive states
init isconsistentwith ρe(resp.ρs,(ρe,ρs)).A state sisadeadlock
for the environment if ∀sx∈2X((s,s/primex) /negationslash|=ρe).sis a deadlock for
the system if ∃sx∈2X((s,s/primex)|=ρe∧∀sy∈2Y((s,s/primex,s/primey) /negationslash|=ρs)).
Aplayis a sequence of states such that (1) the first state in the
sequence s0|=θe∧θs, (2) any pair of consecutive states in the
sequence is consistent with (ρe,ρs), and (3) the sequence is either
infinite, or ends in a deadlock.
The system employs a strategy to repeatedly choose the next
output.Thisoutputdependsonthegiveninputandonthestates
traversedsofar.A strategyisapartialfunction σ:(2X∪Y)+×2X→
2Y. A state sisconsistent withσif for any sx∈2Xsuch that
(s,s/primex)|=ρe,(s,sx)is in the domain of σ. We further require that a
strategysatisfiesthefollowing:if s0,...,si∈(2X∪Y)+isconsistent
withσ,and(si,s/primex)|=ρeforsx∈2X,then(1)s0,...,si,sxisinthe
domain of σ, (2) forsy=σ(s0,...,si,sx),(si,(s/primex,s/primey)) |=ρs, and
(3) we say that (s0,...,si,(sx,sy))is consistent with σ. A play is
consistentwith σifeveryprefixofitisconsistentwith σ.W esay
thatσis fromS⊆2X∪Yif everys∈Sis consistent with σ.
Acontrollerisanalgorithmthatimplementsastrategy.There-
fore,acontrollerreceivesastateandaninputasarguments,and
returnsanoutput.Duringaplay,thecontrollerisrepeatedlyapplied
and reacts to the sequence of inputs produced by the environment.
Hence,acontrollerretainsmemoryfromoneinvocationtoanother.
Remark1. Forthestudyofdynamicupdates,weconsidergame
structures with no initial constraints, since an update occurs from
an“intermediate"state,whichdependsontheexecutionofanother,
runningcontroller.Allnotationsdefinedabovearetransferredtogame
788ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Gal Amram, Shahar Maoz, Itai Segall, and Matan Yossef
structureswithnoinitialconstraintswithaminorexception:wedo
not set rules for the initial state of a play.
2.2 The GR(1) Winning Condition
A GR(1) formula over a set of variables Vis a formula of the form
∧m
i=1GF(Je
i)→∧n
j=1GF(Js
j),whereJe
1,...,Jem,Js
1,...,Jsnareasser-
tions over V.GandFare the Linear Temporal Logic (LTL) [ 34]
operators, GloballyandFinally, resp. Therefore, a GR(1) formula
statesthatiftheassertions Je
1,...,Jem(thejusticeassumptions )hold
infinitelyoften,then Js
1,...,Jsn(thejusticeguarantees )holdinfin-
itely often as well.
Example2.2. Fortheobstacleevasionexample(seeSect.1.1),the
justice guarantees are the Always Eventually Visit guarantees in
Lst. 1, e.g., GF(robX=3∧robY=3).
For a game structure GSand a GR(1) formula φoverX∪Y,
(GS,φ)is aGR(1) specification. For an infinite play π=s0,s1,...
we write π|=φif (1) there exist 1 ≤k≤mandi≥0 such that
∀j≥i(sj/negationslash|=Je
k), or (2) for each 1 ≤k≤n, there are infinitely
many states siinπsuch that si|=Js
k. Given a specification (GS,φ),
the playπwins for the system if (1) πends in a deadlock for the
environment,or(2) πisinfiniteand π|=φ.Astrategywinsfrom
statesif any play from s, consistent with it, wins for the system.
The winning region of a specification is the set of all states from
whichawinningstrategyexists.Astrategyisawinningstrategyif
it wins from every state in the specification’s winning region.
3 PROBLEM DEFINITION
Consider a situation in which an engineer synthesized a controller
C1w.r.t.someGR(1)specification, Spec1,andduringanexecution
ofC1, new up to date system requirements are defined, formulated
in a new specification, Spec2. Apparently, the engineer can use
Spec2to synthesize a new controller C2, stopC1execution, and
startexecuting C2.However,theexecutionofthesystemwedeal
withmustnotbestopped;itshouldbeupdatedtobehaveaccording
toSpec2whileitisrunning.Hence,fromauserperspective,once
Spec2is provided to the synthesizer, the controller can take several
steps in compliance with Spec1and, from some point on, should
satisfySpec2.
Belowweelaborateontherequirementsthatanupdate-strategy
shouldsatisfy.Then,weformalizethesetoobtainaprecisedefini-
tion of the dynamic-update problem.
Timingofchangeinenvironmentbehavior. Weassumethat
onceSpec2is available, the environment starts behaving according
to its safety assumptions. This assumption is reasonable when the
environment is independent and uncontrollable. In these cases we
adaptSpec2immediately,asitprovidesanup-to-dateperspective
ontheenvironment’sbehavior.However,minormodificationsin
thesolutionweshallprovidecaptureotherpossibilitiesonemay
consider, as we elaborate later in Remark 5.
A switching condition. The dynamic-update problem may in-
clude a switching condition. That is, an assertion that must hold at
the state in which the controller starts obeying Spec2’s guarantees.
For example, we may require that the switch will occur only when
the robot is located at some specified region (i.e., as we have done
inLst.1),orwhenthedistancefromthemovingobstacleexceedssomethresholdetc.Weremarkthattherequirementtoallowthe
definitionofaswitchingconditionaspartoftheproblemdefinition
came from the concrete case study we work on with Nokia Bell
Labs.
Note that the switching condition is optional. If the engineer
does not provide a switching condition, we consider it to be true.
A bounded switching phase. Werequirethatthesystemup-
date(unlike,e.g.,satisfactionofajusticeguarantee)occurswithina
boundednumberofsteps.Consequently,thedynamic-updateprob-lemformulationexcludesthepossibilityofanunboundedswitchingphase.Wethusrequirethatreachingastatethatsatisfiestheswitch-
ingconditionandfromwhich Spec2’sguaranteesholdwilloccur
withinaboundednumberofsteps.Note,however,thatwedonot
assumeagiven,fixedbound,asinput,butonlyrequirethatabound
on the length of the switching phase exists.
We now formalize all the above. Note that for the simplicity
ofpresentation,inthedefinitionbelowweconsiderthatthetwo
specificationsaredefinedoverthesamevariables.Thisisjustifiedasfollows:if
Spec1isdefinedover (X1,Y1),andSpec2over(X2,Y2),we
mayregardbothasspecificationsover (X=X1∪X2,Y=Y1∪Y2),
since variables that are defined but do not appear in a specification
have no effect on its semantics.
Definition 3.1 (update-strategy). LetSpec1=(GS1=
(X,Y,θe
1,θs
1,ρe
1,ρs
1),φ1)andSpec2=(GS2=(X,Y,ρe
2,ρs
2),φ2)4
beGR(1)specifications,andlet condbeanassertionover X∪Y(the
switching-condition).Astrategy σisanupdate-strategyfromstate
s0if,assumingtheenvironmenttakesactionsincompliancewith ρe
2,
there exists k≥0 such that for every prefix of a play, s0,s1,...,sk,
consistent with σ, there exists siwithi≤k, for which:
(1)the switching phase prefix s0,...siis consistent with
(ρe
2,ρs
1);
(2) the switching condition holds: si|=cond;
(3)the switching phase future si,si+1,...is consistent with
(ρe
2,ρs
2)andsi,si+1,...|=φ2.
Intuitively,thestate siinDef.3.1isthestateinwhichtheswitch
actually occurs. (1) The system takes ρs
1-transitions until reaching
si, (2)sisatisfies the switching condition, and (3) the system takes
ρs
2-transitions from si. If there is no switching condition, we set
cond=true(and then item (2) holds vacuously).
Definition 3.2 (dynamic-update problem). Given game structures
and a switching condition as in Def. 3.1, compute a strategy σ
and a set W, such that σis an update-strategy from each s∈W
(soundness),andthereexistsanupdate-strategyfromastate siff
s∈W(completeness), iff such a set and strategy exist.
Illustration 1. Figure 2a illustrates the dynamic-update problem.
The red dashed arrow denotes a C1computation that reaches state
s0, from which we apply an update-strategy. The update-strategy
takesseveral (ρe
2,ρs
1)-transitions(redarrows)untilreachingstate si
(i=5in our example) that satisfies cond(marked in green). From
s5, only(ρe
2,ρs
2)-transitions are taken (blue arrows). The suffix of
that computation is performed by the controller C2, which ensures
satisfaction of Spec2. Note that s3also satisfies cond, but it isnotour
4Spec2does not include initial constraints as such constraints have no role in the
dynamic-update context, see Sect. 2, Rem. 1
789Dynamic Update for Synthesized GR(1) Controllers ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
(a) Update-strategy
(b) Bridge construction and its execution
Figure2: Illustrationsofanupdate-strategyandoursolution.Red
arrowsdenote Spec1-outputs,bluearrowsdenote Spec2-outputs,and
green states satisfy the assertion cond
“switching state", since two additional ρs
1-transitions were taken after
visiting it.
Example 3.3. In our obstacle evasion example, the required
update-strategy is not trivial. The robot must consider the old and
newavoidguarantees,whichmayblocksomepaths to andfrom
the switching cell, do it while observing the obstacle’s locationsand reacting to its moves, and eventually end up in a state from
which the new controller can take over.
4 SOLVING DYNAMIC UPDATE
To solve the dynamic-update problem we need to synthesize an
update-strategyorstatethatsuchastrategydoesnotexist.Wesolve
the problem in two stages. First, we compute the system’s winning
region w.r.t. Spec2=(GS2,φ2),W2, and synthesize a matching
controller C2.I fW2is empty, we already know that an update-
strategy does not exist.
Second,if W2isnotempty,wemoveontosynthesizeabridge-
controller B.Thebridgeforcestheplayfromthecurrent(butyet
unknown)statein C1intoW2,infinitelymanysteps.Onitsway,
thebridgemakessurepassingastatethatsatisfies condafterwhich
violationsofthesafetyguaranteesof Spec2(i.e.,ρs
2)arenotallowed.
Notethattheconstructionsof C2andthebridge-controller Bare
independent of one another. C2is constructed from Spec2, and the
bridgeisconstructedusingareachabilitygame,basedontheoldandnew specifications, as we elaborate next. Furthermore, importantly,
both constructions are independent of the controller C1, which
keeps running (typicallyon a separate machine) while C2and the
bridge-controller Bare constructed.
The computation of W2andC2is done by a standard GR(1) syn-
thesis and we omit its details. We turn to describe the construction
of the bridge-controller and the execution of the update. Finally,
we discuss correctness, optimality, and complexity.
Remark 2. Note that the bridge-controller that we compute in
Sect. 4.1 below does not represent a single possible update. Rather,
it is a symbolic representation of all possible correct and shortestbridges. Then, in Sect. 4.2, we show how a concrete bridge is executed,
depending on the state in which the running controller might be in
whenthebridgeis ready,andonthebehaviorofthe environmentin
every step of its execution.
4.1 Bridge-Controller Construction
To synthesize a bridge-controller we extend Ywith two variables,
switchandallowed. Intuitively, switchis turned on by the system
to mark that we switched to ρs
2-transitions. Unlike switch,allowed
is an auxiliary variable, i.e., a variable whose value is uniquely
determinedbyitspreviousvalueandbythevaluationofallother
variables. allowedmonitors the play-states, and evaluates to true
onlywhenthesystemisallowedtoswitch:ifonly ρs
2-transitions
havebeentakensincevisitinga cond-state,i.e.,astatewherethe
assertion condholds.
We consider the game structure /hatwiderGS=(X,Y∪
{switch,allowed},ρe
2,ρs)whereρsis the conjunction of the
formulaslistedbelow,dividedintothreegroups. Transitions (T1,T2)
set rules for an appropriate use of ρs
1andρs
2.Switch(S1-S3) set
rules for the valuation of switch.Permission (P1) defines how
allowedis updated in each step. Hence,
ρs=/logicalanddisplay.1
{T1,T2,S1,S2,S3,P1 },where
T1:=ρs
1∨ρs
2.Thesystemmustalwaysfollow Spec1orSpec2safety
guarantees.
T2:=switch/prime→ρs
2.Whenswitchistrue,only ρs
2-transitionsare
allowed.
S1:=(¬switch ∧switch/prime)→allowed/prime.We turn on switchfor the
first time only if we are allowed to.
S2:=switch→switch/prime.Onceswitchisturnedon,itremainstrue.
S3:=¬ρs
1→switch/prime.Whenwetakea ¬ρs
1∧ρs
2-transition,wemust
switch.
P1:=allowed/prime↔( (cond∧ρs
2)∨(allowed∧ρs
2)).allowedis valu-
atedto trueiff(1)wetakea ρs
2-transitionfroma cond-state,
or (2)allowedholds, and we continue with a ρs
2-transition.
Let/hatwideY=Y∪{switch,allowed},/hatwideV=X∪/hatwideY, and/hatwiderW2={s∈
2/hatwiderV:s|X∪Y∈W2}=W2×2{switch ,allowed},wherefor U⊆V,s|U
denotes the state s∩UoverU. Let/hatwideW⊆2/hatwiderVbe the set of states
fromwhichthesystemcanforcereaching /hatwiderW2∧switch,andletBbe
amatchingcontroller.Thatis, Bwinsthereachabilitygamewith
target set /hatwiderW2∧switch[17, Ch. 2].
/hatwideWandBareconstructedbytheprocedurepresentedinAlg.1.
The algorithm employs the modal μ-calculus [ 19]controllable-
predecessor operator [7], which is defined as follows. Let X
andYbe the environment and system variables, resp., and ρeand
ρsbe matching safety assumptions and guarantees, resp. For a set
of statesW,
(ρe,ρs)(W):={s∈2X∪Y:∀sx∈2X/parenleftbig(s,s/primex)|=ρe→
∃sy∈2Y((s,s/primex,s/primey)|=ρs∧(sx,sy)∈W)/parenrightbig}.
That is,(ρe,ρs)(W)includes all states from which the system
can forcereaching Win asingle step:for eachlegal inputby the
environment, the system has a legal output to reach W.
Consider Alg. 1, and observe that there exists k≥0 such that,
fors∈/hatwideW,Bforces reaching /hatwiderW2∧switchfromswithinksteps.
Indeed,kisthe numberoffixed-pointiterations performedinthe
790ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Gal Amram, Shahar Maoz, Itai Segall, and Matan Yossef
Algorithm 1 Computing /hatwideWand a matching bridge-controller B
1:j=0,Z0=/hatwiderW2∧switch,B0=∅
2:repeat
3:j++
4:Zj=Zj−1∪(ρe
2,ρs)Zj−1
5:Bj=Bj−1∪{(s,t)∈(Zj\Zj−1)×Zj−1:(s,t/prime)|=ρs}
6:untilZj=Zj−1
7:/hatwideW=Zj,B=Bj,return /hatwideW,B
computation of /hatwideW. In the next subsection we prove that Bis the
bridge-controller we are interested in.
Remark3. Toconstruct B,onemaysuggestanalternative,simpler,
naive approach to the problem, using two reachability strategies: a
(ρe
2,ρs
1)-reachability strategy with target cond, from which we can
applya(ρe
2,ρs
2)-reachabilitystrategywithtarget W2.Thissuggestion
is sound, but incomplete, i.e., it may not find all states from which an
update-strategyexists.Forexample,considerastate ssuchthat(1)for
someρe
2-inputs from s, the system has a ρs
1-response that leads the
playtoastatefromwhichanupdate-strategyexists,and(2)forall
otherρe
2-inputsfrom s,thesystemhasa ρs
2-responsethatleadstoa
statefromwhichanupdate-strategyexists.Hence,anupdate-strategy
exists from s, but the two-phase reachability suggestion above fails to
identifys.
Remark 4. We present switchandallowedas new variables only
for the presentation of the bridge construction. In practice, we do
notaddthemtothegamestructureandtheyonlyserveasmemory
variablesforthebridge-controller:whenactivatedfrom W=/hatwideW|X∪Y,
Bforces reaching W2withinksteps, for some k>0, so that the
memory variable switchistrue. Recall that if switchistrue, then
onlyρs
2-transitions have been taken since visiting a cond-state.
Remark5. Weconstructthebridgewhileconsideringthesafety
assumptions ρe
2, as we made a design decision, to immediately adapt
thenewenvironmentassumptions(seetheconsiderationswepresented
before Def. 3.1). Other options are easily supported via minor mod-
ifications in the game structure /hatwiderGS. As an example, we can let the
controllerchoosewhentheenvironmentswitchesfrom ρe
1toρe
2,by
addingafreshsystemvariableandconstrainingtheenvironment’s
behavior on its value. Likewise, we can decide that the change in
assumptionswilloccurina cond-state,whenthesystemswitchesto
ρs
2etc. These alternatives are relevant for setups where the timing of
the change in the environment can be controlled by the system or its
operator.
4.2 Execution of the Update
We are ready to present the execution of the update. Given Spec2’s
winningregion W2,amatchingcontroller C2,abridge-controller B,
anditswinningregion W,Alg.2showstheexecutionoftheupdate
Uas follows. First, if W=∅, then an update-strategy does not
existandweannounceit(line0).Otherwise,welookatthecurrent
play-state s0,andcheckwhether s0∈W(initialactivation(I)).In
cases0∈W, we proceed to (II), the code that we activate from this
point on. In (II), we iteratively generate a response sygiven the
currentstate sandthe input sx.Weapply Bfroms0,untilreachingAlgorithm 2 The execution of the update U
0:ifW=∅then return “switchingcannotbeforcedfromany
state"
// (I). initial activation from state s0
1:ifs0/nelementWthen return “switching cannot be forced from the
current state"
// (II). a response from state sand input sx
1:if(s/nelementW2)∨(switch==false)thensy=B(s,sx)
2:elsesy=C2(s,sx)
3:returnsy
W2whileswitchistrue(line(II).1).Afterwards,weapply C2for
the remainder of the play (line (II).2).
Incases0/nelementW,wereporttotheengineerthatanupdate-strategy
doesnotexistfromthecurrentstate(line(I).1).Notethatif s0/nelementW,
the engineer can try and execute Alg. 2 again, as the play may
traverse into W.
Illustration 2. Figure 2b illustrates a bridge controller B, as com-
putedby Alg.1, andhow itis used.The dashedred arrowrepresents
a play prefix induced by the Spec1controller, C1. In parallel to this
playprefix,wecomputethereachabilitybridgecontroller B,following
Alg.1.Fortunately,thecomputationof Bendswhentheplayprefix
reachesstate s0,coveredby B.Hence,thebridgetakescontrol,takes
two(ρe
2,ρs
1)-transitions(redarrows),reachesastate siwhichsatisfies
cond(i=2in our example, green states satisfy cond), takes an addi-
tional(ρe
2,ρe
2)-transition(bluearrow)andpassescontroltothe Spec2
controller C2for the remainder of the play (dashed blue arrow).
4.3 Correctness, Optimality, Complexity
Oursolutionissoundandcomplete.Ifthereisanupdate-strategy
we find it and execute it; if there is not any, we report so. Formally:
Theorem4.1(construction-correctness). Alg.2issoundand
complete:
(1) The algorithm implements an update-strategy from W.
(2) There exists an update-strategy from siffs∈W.
Beyondcorrectness,wementionthatthereachabilitystrategy
minimizesthenumberofstepstakenuntiltheactivationofthenew
controller. To elaborate, the bridge not only minimizes the longest
possibleswitchingphaselength(denoted k),butalsominimizesthe
number of steps actually executed (denoted j), see Def. 3.1. Both
results follow from the next theorem.
Theorem 4.2 (bridge-optimality). Fors∈W, letk(s)be the
minimalintegers.t.thereexistsanupdate-strategyfrom sthatsatisfies
the conditions of Def. 3.1 with the parameter k(s). Then, the bridge B
forces reaching /hatwiderW2∧switch from swithin, at most, k(s)+1steps.5
The proofs of Thms. 4.1 and 4.2 appear in [2].
Finally,notethat,asymptotically,theupdatecontrollersynthesis
does not add computational cost to the GR(1) synthesis of the new
controller.Theconstructionofthebridgeinvolvesasinglefixed-
point loop and is thus computed in O(N)symbolic operations,
5Thepossiblesingleredundantstepreportedinthetheoremcanbeavoidedbyaminor
modification of /hatwiderGS. Mainly, turning on allowedwhencondis reached. We decided to
give the “single-redundant-step" version as it slightly simplifies the correctness proof.
791Dynamic Update for Synthesized GR(1) Controllers ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
Algorithm 3 Optimized computation of Z⊆/hatwideWandB
(replacing Alg. 1)
1:j=0,Z0=/hatwiderW2∧switch,B0=∅
2:repeat
3:s=C1’s current state
4:if(s,¬switch,¬allowed)∈ Zjthen
5: stopC1
6: Z=Zj,B=Bj,returnZ,B
7:end if
8:j++
9:Zj=Zj−1∪(ρe
2,ρs)Zj−1
10:Bj=Bj−1∪{(s,t)∈(Zj\Zj−1)×Zj−1:(s,t/prime)|=ρs}
11:untilZj=Zj−1
12:/hatwideW=Zj,B=Bj,return /hatwideW,B
whereNisthesizeofthestatespace.Thatsaid,thenumberoffixed-
point iterations is just the length of the maximal possible bridge,
and in practice, the length of the bridge is orders of magnitude
smaller than the state space, see our evaluation in Sect. 7.
Remark 6 (no overhead accumulation). Our solution enables
theseamlessapplicationofasequenceofdynamicupdates.Thatis,
oncetheupdatecompletesandAlg.2returnsanoutputfrom C2,C2
controlstheexecution,andanotherdynamicupdatecanbeapplied
whennecessary.Applyingasequenceofupdatescomesatnocostin
terms of additional variables and thus no overhead is accumulated.
5 EARLY DETECTION OF SUCCESS
We propose an optimization for the execution of the update U,
based on a modified construction of the bridge-controller. The
optimizationwedescribecanleadtoashorterswitch,i.e.,reduce
thenumberofstepswetakeuntilswitchingto ρs
2-transitionsand
thus to a (GS2,φ2)-strategy. Furthermore, the optimization can
reduce the computation time of the bridge.
The optimization is based on a simple idea: rather than com-
puting the complete bridge Band only then checking whether the
currentstateoftheexecutingcontrolleriscoveredbyit,wesuggest
to check before every loop iteration of Alg. 1 whether the current
stateoftheexecutingcontrollerwasalreadycoveredbytheset B
computed so far. In case Balready covers the current state, we can
immediately apply Alg. 2, i.e., apply Buntil reaching its target, and
thenswitchto C2.Inotherwords,insteadofcomputingallstates
fromwhichanupdatecanbeexecuted,theoptimizationstopsas
soon as the current state of the controller is within the part of the
bridge that was computed so far. This early detection of success,
allowstostopthecomputationof Bandthustoreducecomputation
time. We present this optimized construction in Alg. 3.
Illustration3. Figure3illustratesanoptimizedbridgecomputation
ofAlg.3.Thereddashedarrowrepresentsaplayprefixinducedbythe
Spec1controller C1. After the computation of each bridge component,
we check if the current play state has been covered. Fortunately, after
the computation of B3, the play reaches s0which is covered by B
ascomputedsofar.Hence,wedonotcomputetheremaining(semi-
transparent)set B4thatAlg.1wouldhavecomputed.Welet Btake
control and lead the play to B0, from which we activate C2.Note that the optimization requires more communication be-
tweenthesynthesizerand C1aswellasmultiplechecksonwhether
itscurrentstateallowstoswitch(Alg.3,line4).Thisadditionalcom-
putation is however, negligible, as it involves only a small constant
number of symbolic operations.
Finally,notethattheheuristicoptimizationdoesnotcompromise
soundness and completeness. It potentially reduces the numberof steps during the bridge construction and it never adds steps.In our evaluation we present evidence that this optimization is
veryeffectiveinreducingthebridge’scomputationtimeandactual
length when executed.
6 IMPLEMENTATION
We have implemented and integrated the bridge construction of
Alg.1,theproposeddynamic-updatestrategyconstructionofAlg.2,
and further the optimized bridge construction of Alg. 3, in the
Spectraspecificationlanguageandsynthesisenvironment[ 1,26].
The implementation consists of two controller constructions: a
just-in-time controller [ 28] forSpec2,C2, and a bridge controller
Bfollowing Alg. 1 or Alg. 3. A just-in-time controller stores an
efficientsymbolicrepresentationandcomputesconcretenextstates
only when they are required. The separation between C2andB
allowsustoconsidertheaddedvariables, switchandallowed,only
during the bridge phase. C2does not use these variables, neither
asgamevariables,norasmemoryvariables,andthusthejust-in-
timeC2is synthesized from the new specification by the standard
synthesis procedure of Spectra (including the heuristics suggested
in [13]). The added cost of the dynamic-update synthesis is due
solely to the construction of B.
In our implementation, the bridge-controller Bminimizes the
number of steps taken until we can activate C2. Specifically, at
each step, from the current state s, given input in, we apply a
binary search on the array B0,...,Bj,6to find a valid output out,
such that (in,out)is of lowest index, i.e., closest as possible to
the target B0. Note that the array is strictly monotonic, i.e., for
allm, the set of transitions represented by Bmis a strict subset
of the set of transitions represented by Bm+1. The search for the
outputouttakeslog(|B|)steps, where |B|denotes the length of
thearray.Clearly, log(|B|)isboundedbythenumberofvariables
X∪Y∪{ switch,allowed}.Inpractice,ittendstobemuchsmaller.
6For efficiency, the actual implementation uses the array of winning regions
Z0,...,Zjratherthanthearrayofcontrollers B0,...,Bj.Weusethe Bnotation
for the simplicity of the presentation.
Figure 3: Optimized bridge construction. Red arrows denote Spec1-
outputs, blue arrows denote Spec2-outputs, green states satisfy the
assertion cond.Thesemi-transparentellipse B4isabasicbridgecom-
ponent that the optimized bridge did not compute.
792ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Gal Amram, Shahar Maoz, Itai Segall, and Matan Yossef
([HFXWHV &
6HQGምVWR
V\QWKHVL]HU
5HFHLYH &
DQGH[HFXWHLW,IXSGDWDEOH
H[HFXWH%*LYHQ: FKHFN
ZKHWKHU
XSGDWDEOH5HFHLYHDQ
XSGDWHUHTXHVW
&RPSXWH :
DQG%DQGVHQG
WKHPWR
H[HFXWRU&RPSXWH &
DQG:
,WHUDWLYHO\JLYHQ
HDFK%MUHWXUQ
ZKHWKHUXSGDWDEOH
,IXSGDWDEOH
VHQG&WR
H[HFXWRU,WHUDWLYHO\FRPSXWH
%DQGVHQGHDFK
%MWRH[HFXWRU
([HFXWHWKH
UHFHLYHGVWHSV
RIWKHEULGJH
rIEkj]g
 /s[jPIhQvIg
LPEIEVA@RANOEKJ
Figure 4: Dynamic-update communication timeline
Theimplementationisdividedbetweenanexecutorandasyn-
thesizer, which communicate over TCP. It thus supports a truly
remotecommunicationbetweenthemachinethatrunssynthesis
and the machine that executes the controller (e.g., a robot).
Figure4showsthetimelineofcommunicationduringanupdate.
While the executor is executing C1, the synthesizer receives an
update request for Spec2and synthesizes C2. Then, the synthesizer
uses Alg. 1 to compute BandW, the bridge and the set of states
from which the system can force an update, and sends them to
the executor. The executor checks whether an update is possible
fromitscurrentstateusing Wandreturnstheanswertothesyn-
thesizer.Iftheanswerispositive,theexecutorstartsexecuting B
immediately. While Bis executed, the executor receives C2from
the synthesizer, and it starts executing C2right after the bridge
execution is completed according to Alg. 2.
In the optimized version, where Alg. 1 is replaced by Alg. 3,
the bridge is computed and sent to the executor iteratively untilreaching a
Bjfrom which the system can force an update. Then,
the bridge Bjconstructed so far and C2, are executed using Alg. 2.
7 PRELIMINARY EVALUATION
Weprovideallthespecifications,rawresults,andmeanstorepro-
duce the experiments described below in supporting materials [ 2].
7.1 Research Questions
We consider the following research questions.
RQ1.Howdoupdate-strategysynthesisandstandardGR(1)syn-
thesis compare w.r.t. running times? What is the added cost
of supporting dynamic update?
RQ2.How many steps does it take for the bridge-controller to
complete and activate C2?
RQ3.Does our optimization improve performance, in terms of
(a) the bridge construction running time and (b) number of
steps taken to complete it?
7.2 Corpus and Applied Updates
Ourcorpusincludesthreesetsofspecifications:(1)instancesofour
runningexample,obstacleevasion,whichweusetodynamicallyupdate the avoids and always-visit guarantees, (2) instances of a
prioritized arbiter specification, a variant of a benchmark from the
reactivesynthesiscompetitionSYNTCOMP[ 3],whichweuseto
dynamically update the identity of the prioritized client, and (3)
instances of a job scheduler specification, which we use to dynami-
callyupdateasubsetoftheserversthatgoesdownformaintenance.Foreachofthesesets,wecreatedmanypairsofspecificationswhere
each pair is an example of an update from the first specification in
thepairtothesecondspecificationinthepair.Wedescribethem
below.
Configurations based on the obstacle evasion problem. For
everyn=8,16,32,64 andm=3,5,7,9, we created 30 pairs of
realizable specifications by adding to the obstacle evasion spec-
ification over an n×ngrid: (1)msafety guarantees: randomly
chosenmcellsthat therobot mustavoid;(2) mjusticeguarantees:
randomly chosen mcells thatthe robot mustvisit infinitely often;
and(3)onerandomlygeneratedswitchingconditionoftheform
cond=(robX=i∧robY=j),i.e.,aconditionthatinstructstherobot
to visit a randomly chosen designated cell as part of the update-
strategy (see Def. 3.1). We denote these pairs by pairs(n,m).
Configurationsbasedontheprioritizedarbiterproblem. The
arbiter (the system) grants requests raised by nclients (the envi-
ronment). It must never grant two requests simultaneously, it can
grant client i’s request only when client iraises a request, and it
mustmakesurethateachrequestiseventuallygranted.Weassumethataclientlowersarequestiffitwasjustgranted.Finally,prioriti-zationmeansthatoneoftheclientsisprioritized:apendingrequest
bytheprioritizedclientmustbegrantedbeforeanyotherclient’s
request is granted. We considered variants with n=70,80,90,100
clients. For each of these, we created 30 pairs of specifications with
nclients, that differ in the identity of the prioritized client. Our
switching condition is the assertion: “no pending request by the
prioritized client". We denote these pairs by pairs(n).
Configurations based on the job scheduler problem. The
scheduler(thesystem)assignsjobsofdifferentlengths(maxlength
k) to one of nservers. The scheduler must eventually assign every
incomingjob.Onceajobisassignedtoaserver,itcannotbereas-
signed. When a server is assigned a job of length l≤k, it works
on it for lconsecutive states, after which it is available for new
assignments if any. A new job must not be assigned to a serverthat is currently down for maintenance. For every
n=4,6,8,10
andk=4,8,12,16, we created 30 pairs of realizable specifications,
whereupdatesspecifywhichservershouldnowgodownformain-
tenance.Correctupdatestrategiesensurethatexistingjobsthatare
already assigned to a server complete before the server goes down
for maintenance. We denote these pairs by pairs(n,k).
Overall,ourcorpusincludes1080configurations:16setsofpairs
for the obstacle evasion problem, 4 sets of pairs for the prioritized
arbiter problem, and 16 sets of pairs for the job scheduler problem,
each consisting of 30 configurations.
7.3 Validation
To validate our implementation we defined assertions over the
behaviorofthesystemexecutionduringandaftertheupdate:as-
sertionsonthebridgephase,anassertionstatingthattheswitching
793Dynamic Update for Synthesized GR(1) Controllers ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
state satisfies cond, and an assertion stating that after the bridge,
the execution should match the behavior specified by Spec2.
We verified these assertions automatically using hundreds of
executionlogsofdynamicupdatesoverourcorpus.Forexample,
fortheobstacleevasion,weprogrammaticallyverifiedthatinthe
logs, the robot visits the specified condcell and from then on does
not visit the cells it should avoid according to Spec2.
7.4 Experiment Setups and Results
Our corpus includes pairs of realizable specifications, where the
second specification also includes a switching condition. For each
pair we performed the following experiment. First, we constructed
andexecutedacontrollerforthefirstspecificationinthepair.Then,
weperformedadynamic-updatewiththesecondspecificationas
the new specification. For each of the dynamic updates performed
we measured the time it took to synthesize the new controller (the
GR(1) just-in-time synthesis cost in Spectra), the time it took to
synthesize the bridge controller (the cost that the dynamic update
taskadds), andthe numberof stepstaken bythe bridgecontroller
when the update was executed.
We ran all experiments on an ordinary laptop PC, Intel Core
i7 CPU 1.8GHz, 8GB RAM with Ubuntu 18.04 64-bit OS, Java 13
64Bit,andCUDD3compiledfor64Bit.Timeswereportaremedian
values of 10 runs, measured by Java in milliseconds. Although the
algorithmswedealwitharedeterministic,weperformed10runs
since JVM garbage collection and BDD dynamic-reordering add
variance to running times.
Toaddress RQ1andRQ3(a), foreachset ofpairs,wereport the
median times we obtained. In Tbl. 1, Tbl. 2, and Tbl. 3, we report
median values for dynamic updates between obstacle evasion spec-
ifications,betweenprioritizedarbiterspecifications,andbetween
job scheduler specifications. For example, for the obstacle evasion
configurations,foragridofsize32 ×32andnumberofsafetiesand
justiceguarantees m=7(i.e.,for pairs(32,7)),themediansynthesis
timeofanewcontrolleris25.6sec,themedianbridgecontrollersyn-
thesis time is 23.5 sec, and the median optimized bridge controller
synthesis time is 10.5 sec. Hence, in Tbl. 1, the cell on row ‘32 ×32’
and column ‘7/new controller’ reads 25 .6, on row ‘32 ×32/No’ and
column ‘7/bridge’ reads 23 .5, and on row ‘32 ×32/Yes’ and column
‘7/bridge’ reads 10 .5.
ToaddressRQ2andRQ3(b),foreachperformeddynamicupdate,
wemeasuredtheactualbridgelengthasexecuted,i.e.,thenumberof
stepstakenbythebridgecontroller.Foreachsetofpairs, pairs(n,m),
pairs(n), andpairs(n,k), in Tbl. 1, Tbl. 2, and Tbl. 3 respectively,
wereportthemedianactuallengthasexecuted.Forexample,for
theobstacleevasionconfiguration pairs(64,7),themedianactual
executionlengthofthenon-optimizedbridgeis27steps,andofthe
optimizedbridgeis11.Hence,inTbl.1,thecellonrow‘64 ×64/No’
andcolumn‘7/length’reads27,andonrow‘64 ×64/Yes’andcolumn
‘7/length’ reads 11.ToanswerRQ1,weobservethatthetimethatthedynamicup-
dateadds, i.e.,synthesistime ofthe(non-optimized)bridge, is
approximatelyofthesamemagnitudeasthesynthesistimeofthe
new controller. In particular, this means that as long as the syn-
thesisofSpec2isfeasible,thedynamicupdateremainsfeasible
as well.
ToanswerRQ2,thelengthoftheactualbridgesasexecutedis
small, in particular ordersof magnitudes shorter relative to the
worst case length (see the last paragraph of Sect. 4.3). In the
arbiter’scase,bridgelengthisalways1sinceprioritizedrequestsareansweredimmediatelyandthuswearealwaysatmostastep
away from a switching condition state.
ToanswerRQ3,weseethattheoptimizationisefficientandeffec-
tive.Itreducesthebridgesynthesistimeandimprovesthequalityoftheupdateasitshortensitsactuallength.Moreover,themore
challenging the case, the higher the factor of improvement.
7.5 Threats to Validity
We consider the following threats to the validity of our evaluation.
First, our implementation may have bugs. To mitigate this, we
performed extensive validation (see Sect. 7.3).
Second, runningtime measurements have variance due tothe
random generation of updates, the BDD libraries, and the Javagarbage collector. To mitigate, we performed every experiment
multiple times and report median values (see Sect. 7.4).
Third,runningtimemeasurementsofouroptimizedversionmay
be affected by the time between steps of the controller executor,
whichisconfiguredinourtestingenvironment.Weusedaconstant
steptimeforeachsetofspecifications.Choosingadifferentstep
time could have changed our results. In reality, every system may
have a different step time.
Fourth, we used only three sets of specifications with specific
kinds of updates. We took the specifications from well-knownbenchmarks, but we do not know if these specifications and up-dates are representative of specifications and updates engineers
will apply in practice. That said, we chose the obstacle evasion
specification because it is very similar to the target application
developed byNokia BellLabs, and we used hundredsof randomly
generated updates involving changes in safeties and justices on all
three sets of specifications.
Finally,dynamicupdaterequirescommunicationbetweenthe
synthesizerandtheexecutor.Ourimplementationofthiscommuni-cationisbasedonTCP.Thecommunicationtimeisstronglyaffected
bytheconnectionbetweenthesynthesizerandtheexecutor.For
example,asynthesizerandanexecutorthatareconnectedviaWiFi
maycommunicate slowerthan asynthesizer andanexecutor that
are running on the same machine. Thus, our results in this regard
areimplementationspecific.Onemayobtaindifferentresultswhen
using different means of communication.
794ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Gal Amram, Shahar Maoz, Itai Segall, and Matan Yossef
m 3 5 7 9grid size
optimized?
new
controller
bridge
length
newcontroller
bridge
length
newcontroller
bridge
length
newcontroller
bridge
length
8×8No0.30.980.51.380.71.481.01.68
Yes 0.85 0.86 1.15 1.14
16×16No1.23.292.34.083.44.996.16.18
Yes 2.16 3.16 3.75 4.95
32×32No4.912.81513.916.21225.623.51441.830.313
Yes 4.69 5.97 10.56 18.18
64×64No29.270.82883.1110.526122.6148.727185.2189.725
Yes 18.115 33.711 61.811 71.811
Table 1: Obstacle evasion synthesis times (sec), bridge computation times (sec), and actual length as executed
#clients optimized? new controller bridge length
70No5.46.1 1
Yes 2.9 1
80No7.712.5 1
Yes 3.6 1
90No13.821.8 1
Yes 5.5 1
100No24.734.5 2
Yes 6.3 1
Table 2: Prioritized arbiter synthesis times (sec), bridge computa-
tion times (sec), and actual length as executed
8 RELATED WORK
Manyauthorshavediscusseddynamicadaptationingeneralandthe
dynamic-update problem in the context of synthesized controllers
in particular, see, e.g., [4, 30, 40].
Baresi and Ghezzi [ 4] present a broad discussion on the moti-
vation for dynamic updates, that is, for changes to occur as the
softwareisrunningandwhileassuringcontinuousdependability.
The combination of synthesis and dynamic updates goes in this
direction.
Zhang and Cheng[ 40] present A-LTL,an approach to formally
specifyadaptationrequirementsintemporallogic.Theyconsider
three adaptation variants (one point, guided, and overlap). One
mayviewourworkasimplementingacaseofguidedadaptation,
where the synthesized update-strategy plays the role of the guide.
In another work, the same authors [ 39] present a model-based
approach to adaptation, separating the adaptation behavior and
non-adaptivebehaviorspecifications,anddemonstratedusingan
adaptive GSM-oriented audio streaming protocol for a mobile com-
puting application. The two works do not use synthesis for the
construction of an update-strategy.
La Manna et al. [ 23] studied a notion of “updatable states”. A
state is updateable if the concatenation of someexecutions that
lead into the state, with anyfuture behavior induced by the new
controller, satisfies the new specification. Their work is specific to
assume-guaranteespecificationsgivenasuniversalModalSequenceDiagrams(MSDs)[ 18].Theydescribearelated tool in[ 15]butdo
not provide an empirical evaluation or complexity analysis.
Morerecently,Nahabedianetal.[ 30]proposedatechniquefor
dynamic update in the context of event-based controller synthesis.
The work supports updates of labeled transition systems (LTSs)
specifiedusingLTLsafetiesandfluents[ 16].Itpresentscorrectness
criteria and a sound and complete solution. It considers various
complexities of updates, e.g., planned updates, and allowing oneto specify the requirements for a transition period where both
the old and the new specification may not hold. It supports the
specification of a transition requirement which is similar to ouroptional switching condition. It is implemented as an extension
of the MTSA tool [ 9] and presents validation through several case
studies.
Ourworkisdistinctiveinseveralways,mostnotably(A)inits
applicabilityandexpressiveness-supportfortheGR(1)fragment
of LTL, including safeties and justices, with a general computation
model thatis notspecific toevent-based specifications;and (B)in
its efficiency and scalability - thanks to the symbolic nature of the
algorithms and implementation. Note that the work in [ 30] uses
concretealgorithmswhichinthissensedonotscale.Indeed,the
evaluation in [ 30] presents transition systems of up to 3000 states
andmaximumsynthesistimesof5minutes,whileourevaluation
uses controllers of up to about 120000 reachable states (from state
spaces of 220to 2110states) and synthesis times of up to 3 minutes
but typically much less. Importantly, due to the difference in com-
putation models, our main motivating example of obstacle evasion
whilepatrollingbetweenlocationsonagrid(andtheothersystems
we present in our evaluation), cannot be modeled and solved using
the approach of [30].
LivingstonandMurray[ 22]suggestedadynamic-updatetech-
niqueforGR(1),restrictedtoaddingorremovingjusticeguarantees.
Theiraimistousetheexistingcontrollertoreducethesynthesis
time of the modified specification, but their solution also works
at runtime, and thus forms a restricted dynamic-update technique.
Our work is not restricted to updates in justice guarantees, but
covers the complete GR(1), including safeties and justices.
Anotherrestricteddynamic-updatetechniqueforGR(1)ispro-
posedbyShietal.[ 37],whosuggesttechniquesforseveraltypes
795Dynamic Update for Synthesized GR(1) Controllers ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
k 4 8 12 16# servers
optimized?
new
controller
bridge
length
newcontroller
bridge
length
newcontroller
bridge
length
newcontroller
bridge
length
4No0.10.110.20.730.31.840.74.37
Yes 0.11 0.43 1.25 2.14
6No0.20.511.04.722.08.734.919.85
Yes 0.41 1.62 3.13 4.61
8No0.51.312.49.317.529.8123.276.54
Yes 0.81 2.51 9.01 15.61
10No1.32.615.934.8124.659.8256.8226.4 4
Yes 1.61 6.91 21.71 42.71
Table 3: Job scheduler synthesis times (sec), bridge computation times (sec), and actual length as executed
ofcontrollersynthesisandupdateinruntime,toovercomeunex-
pected accidents caused, e.g., by a malfunction device. The work
does not provide correctness criteria or an evaluation.
Finally, most recently, Finkbeiner et al. [ 12] present a form of
aliveupdateforcontrollerssynthesizedfromLTLspecifications,
withadifferentsemanticsthanours.Moreover,duetotheuseof
LTL,unlikeouruseofGR(1),theircomplexityofcheckingwhether
an update is possible is double exponential.
9 CONCLUSION
We formulated and solved the dynamic-update problem for synthe-
sizedGR(1)reactivesystems:updatingthebehaviorofanalready
runningsynthesizedcontrollersuchthatitwouldsafelyanddynam-
ically,without stopping, startconforming toa modified, up-to-date
specification. We formally defined the dynamic-update problem in
the context of GR(1) and presented a sound and complete solution.
Thesolutionisbasedonthesymboliccomputationofanoptimal
bridge-controller,whichguaranteesashortestswitchingphase,if
one exists. Finally, we presented a heuristic optimization based on
the early detection of a successful update, which may reduce both
bridge synthesis times and actual bridge steps when executed.
WeimplementedourideasintheSpectrasynthesizer.Ourevalu-
ation shows the efficiency and effectiveness of our work. The workopensthewayfortheuseofGR(1)synthesisinapplicationdomains
where dynamic updates are a necessary requirement.
Wesuggestthefollowingfutureworkdirections.First,wecon-
sider developing means to deal with the case of an unrealizable
dynamicupdate,i.e.,whereswitchingcannotbeforced.7Currently,
our technique is limited to detecting unrealizable dynamic updates,
butnottofurtherdealwiththem.Whenthesystemcannotforce
a strategy update, it is still possible that an update can be done
withthecooperation oftheenvironment.Thatis,theremayexist
a sequence of inputs by the environment that enables a strategy
switch. This calls for synthesizing a cooperative bridge-controller.
Second, we hope to complete the case study of deploying our
implementation in Nokia Bell Labs system and report on our expe-
rience in a follow-up paper.
7Notethatthisisdifferentthanthecasewherethenewspecificationisunrealizableby
itself,whichmaybeaddressedinvariousways,e.g.,usingcores,counter-strategies,
or repairs [8, 21, 27].ACKNOWLEDGEMENTS
This project has received funding from the European Research
Council (ERC) under the European Union’s Horizon 2020 research
and innovation programme (grant agreement No 638049, SYN-
TECH).
REFERENCES
[1] [n.d.]. Spectra Website. http://smlab.cs.tau.ac.il/syntech/spectra/.
[2][n.d.]. Supporting Materials Website. http://smlab.cs.tau.ac.il/syntech/dupdate/.
[3] [n.d.]. SYNTCOMP Website. http://www.syntcomp.org/.[4]
Luciano Baresi and Carlo Ghezzi. 2010. The disappearing boundary between
development-timeandrun-time.In Proc.oftheWorkshoponFutureofSoftware
Engineering Research (FoSER). ACM, 17–22. https://doi.org/10.1145/1882362.
1882367
[5]ArminBiere,KeijoHeljanko,andSiertWieringa.2011. AIGER1.9AndBeyond.
Technical Report 11/2. Institute for Formal Models and Verification, Johannes
Kepler University, Altenbergerstr. 69, 4040 Linz, Austria.
[6]Roderick Bloem, Alessandro Cimatti, Karin Greimel, Georg Hofferek, Robert
Könighofer, Marco Roveri, Viktor Schuppan, and Richard Seeber. 2010. RATSY -
A New Requirements Analysis Tool with Synthesis. In CAV (LNCS), Vol. 6174.
Springer, 425–429. http://dx.doi.org/10.1007/978-3-642-14295-6_37
[7]Roderick Bloem, Barbara Jobstmann, Nir Piterman, Amir Pnueli, and Yaniv Sa’ar.
2012. Synthesis of Reactive(1) Designs. J. Comput. Syst. Sci. 78, 3 (2012), 911–938.
http://dx.doi.org/10.1016/j.jcss.2011.08.007
[8]Davide G. Cavezza and Dalal Alrajeh. 2017. Interpolation-Based GR(1) Assump-
tionsRefinement.In TACAS (LNCS),Vol.10205.281–297. https://doi.org/10.1007/
978-3-662-54577-5_16
[9]NicolásD’Ippolito,DarioFischbein,MarshaChechik,andSebastiánUchitel.2008.
MTSA: The Modal Transition System Analyser. In 23rd IEEE/ACM International
Conference on Automated Software Engineering (ASE 2008), 15-19 September 2008,
L’Aquila,Italy.IEEEComputerSociety,475–476. https://doi.org/10.1109/ASE.
2008.78
[10]Matthew B.Dwyer, GeorgeS. Avrunin,and JamesC. Corbett.1999. Patternsin
Property Specifications for Finite-State Verification. In ICSE. ACM, 411–420.
[11]RüdigerEhlersandVasumathiRaman.2016. Slugs:ExtensibleGR(1)Synthesis.
InCAV (LNCS), Vol. 9780. Springer, 333–339.
[12]Bernd Finkbeiner, Felix Klein, and Niklas Metzger. 2021. Live Synthesis. In
AutomatedTechnologyforVerificationandAnalysis-19thInternationalSymposium,
ATVA 2021, Gold Coast, QLD, Australia, October 18-22, 2021, Proceedings (Lecture
NotesinComputerScience),ZheHouandVijayGanesh(Eds.),Vol.12971.Springer,
153–169. https://doi.org/10.1007/978-3-030-88885-5_11
[13]Elizabeth Firman, Shahar Maoz, and Jan Oliver Ringert. 2020. Performance
heuristicsforGR(1)synthesisandrelatedalgorithms. ActaInformatica 57,1-2
(2020), 37–79. https://doi.org/10.1007/s00236-019-00351-9
[14]EnricGalceranandMarcCarreras.2013. Asurveyoncoveragepathplanning
for robotics. Robotics Auton. Syst. 61, 12 (2013), 1258–1276. https://doi.org/10.
1016/j.robot.2013.09.004
[15]CarloGhezzi,JoelGreenyer,andValerioPanzicaLaManna.2012. Synthesizing
dynamically updating controllers from changes in scenario-based specifications.
InInt. Symp. on Software Engineering for Adaptive and Self-Managing Systems
(SEAMS). IEEE Computer Society, 145–154. https://doi.org/10.1109/SEAMS.2012.
796ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Gal Amram, Shahar Maoz, Itai Segall, and Matan Yossef
6224401
[16]Dimitra Giannakopoulou and Jeff Magee. 2003. Fluent model checking for event-
basedsystems.In Proceedingsofthe11thACMSIGSOFTSymposiumonFoundations
of Software Engineering 2003 held jointly with 9th European Software Engineering
Conference,ESEC/FSE 2003,Helsinki,Finland,September1-5, 2003,JukkaPaakki
andPaolaInverardi(Eds.).ACM,257–266. https://doi.org/10.1145/940071.940106
[17]Erich Grädel, Wolfgang Thomas, and Thomas Wilke (Eds.). 2002. Automata,
Logics,andInfiniteGames:AGuidetoCurrentResearch[outcomeofaDagstuhl
seminar, February 2001]. Lecture Notes in Computer Science, Vol. 2500. Springer.
https://doi.org/10.1007/3-540-36387-4
[18]DavidHarelandShaharMaoz.2008.Assertandnegaterevisited:Modalsemanticsfor UML sequence diagrams. Software and Systems Modeling 7, 2 (2008), 237–252.
https://doi.org/10.1007/s10270-007-0054-z
[19]DexterKozen.1982. ResultsonthePropositional μ-Calculus.In Proceedingsof
the9thColloquiumonAutomata,LanguagesandProgramming .Springer-Verlag,
London, UK, UK, 348–359. http://dl.acm.org/citation.cfm?id=646236.682866
[20]Hadas Kress-Gazit, Georgios E. Fainekos, and George J. Pappas. 2009. Temporal-
Logic-BasedReactiveMissionandMotionPlanning. IEEETrans.Robotics 25,6
(2009), 1370–1381. http://dx.doi.org/10.1109/TRO.2009.2030225
[21]Aviv Kuvent, Shahar Maoz, and Jan Oliver Ringert. 2017. A symbolic justice
violations transition system for unrealizable GR(1) specifications. In Proceedings
of the 2017 11th Joint Meeting on Foundations of Software Engineering, ESEC/FSE
2017, Paderborn, Germany, September 4-8, 2017, Eric Bodden, Wilhelm Schäfer,
Arie van Deursen, and Andrea Zisman (Eds.). ACM, 362–372. https://doi.org/10.
1145/3106237.3106240
[22]ScottC.LivingstonandRichardM.Murray.2014. Hot-swappingrobottaskgoals
in reactive formal synthesis. In 53rd IEEE Conference on Decision and Control,
CDC 2014, Los Angeles, CA, USA, December 15-17, 2014. IEEE, 101–107. https:
//doi.org/10.1109/CDC.2014.7039366
[23]Valerio Panzica La Manna, Joel Greenyer, Carlo Ghezzi, and Christian Bren-ner. 2013. Formalizing correctness criteria of dynamic updates derived fromspecification changes. In Int. Symp. on Software Engineering for Adaptive and
Self-Managing Systems (SEAMS). IEEE Computer Society, 63–72. https://doi.org/
10.1109/SEAMS.2013.6595493
[24]Shahar Maoz and Jan Oliver Ringert. 2015. GR(1) synthesis for LTL specification
patterns.In ESEC/FSE .ACM,96–106. http://doi.acm.org/10.1145/2786805.2786824
[25]ShaharMaozandJanOliverRingert.2015. SynthesizingaLegoForkliftController
in GR(1): A Case Study. In Proc. 4th Workshop on Synthesis, SYNT 2015 colocated
with CAV 2015 (EPTCS) , Vol. 202. 58–72.
[26]Shahar Maoz and Jan Oliver Ringert. 2021. Spectra: a specification language for
reactive systems. Softw. Syst. Model. 20, 5 (2021),1553–1586. https://doi.org/10.
1007/s10270-021-00868-z
[27]Shahar Maoz and Rafi Shalom. 2021. Unrealizable Cores for Reactive Systems
Specifications.In 43rdIEEE/ACMInternationalConferenceonSoftwareEngineering,
ICSE 2021, Madrid, Spain, 22-30 May 2021 . IEEE, 25–36. https://doi.org/10.1109/
ICSE43902.2021.00016
[28]Shahar Maoz and Ilia Shevrin. 2020. Just-In-Time Reactive Synthesis. In 35th
IEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering,ASE2020,
Melbourne,Australia,September21-25,2020.IEEE,635–646. https://doi.org/10.
1145/3324884.3416557
[29]Claudio Menghi, Christos Tsigkanos, Patrizio Pelliccione, Carlo Ghezzi, and
ThorstenBerger.2019. Specificationpatternsforroboticmissions. IEEETrans-
actionsonSoftwareEngineering(TSE) (2019). https://doi.org/10.1109/TSE.2019.
2945329
[30]LeandroNahabedian,VictorBraberman,NicolasD’Ippolito,ShinichiHoniden,
JeffKramer,KenjiTei,andSebastianUchitel.2020. Dynamicupdateofdiscrete
event controllers. IEEE Transactions on Software Engineering 46, 11 (2020), 1220–
1240.
[31]Daniel Neider and Ufuk Topcu. 2016. An Automaton Learning Approach to
Solving Safety Games over Infinite Graphs. In TACAS. 204–221. https://doi.org/
10.1007/978-3-662-49674-9_12
[32]Necmiye Ozay, Ufuk Topcu, and Richard M. Murray. 2011. Distributed powerallocation for vehicle management systems. In Proceedings of the 50th IEEE
Conference on Decision and Control and European Control Conference, CDC-ECC 2011, Orlando, FL, USA, December 12-15, 2011 . IEEE, 4841–4848. https:
//doi.org/10.1109/CDC.2011.6161470
[33]Necmiye Ozay, Ufuk Topcu, Richard M. Murray, and Tichakorn Wongpiromsarn.
2011. Distributed Synthesis of Control Protocols for Smart Camera Networks.In2011 IEEE/ACM International Conference on Cyber-Physical Systems, ICCPS
2011, Chicago, Illinois, USA, 12-14 April, 2011. IEEE Computer Society, 45–54.
https://doi.org/10.1109/ICCPS.2011.22
[34]Amir Pnueli. 1977. The Temporal Logic of Programs. In 18th Annual Symposium
onFoundationsofComputerScience,Providence,RhodeIsland,USA,31October-
1November1977.IEEEComputerSociety,46–57. https://doi.org/10.1109/SFCS.
1977.32
[35]AmirPnueliandRoniRosner.1989. OntheSynthesisofaReactiveModule.In
POPL. ACM Press, 179–190.[36]LeonidRyzhykandAdamWalker.2016.DevelopingaPracticalReactiveSynthesis
Tool:ExperienceandLessonsLearned.In ProceedingsFifthWorkshoponSynthesis,
SYNT@CAV2016,Toronto,Canada,July17-18,2016.(EPTCS) ,RuzicaPiskacand
Rayna Dimitrova (Eds.), Vol. 229. 84–99. http://dx.doi.org/10.4204/EPTCS.229
[37]H.Shi,W.Dong,R.Li,andW.Liu.2020. ControllerResynthesisforMultirobot
System When Changes Happen. Computer 53, 12 (2020), 69–79. https://doi.org/
10.1109/MC.2020.3017343
[38]TichakornWongpiromsarn,UfukTopcu,NecmiyeOzay,HuanXu,andRichardM.
Murray. 2011. TuLiP: A Software Toolbox for Receding Horizon Temporal Logic
Planning.In Proceedingsofthe14thInternationalConferenceonHybridSystems:
ComputationandControl (HSCC’11) .ACM,NewYork,NY,USA,313–314. https:
//doi.org/10.1145/1967701.1967747
[39]Ji Zhang and Betty H. C. Cheng. 2006. Model-based development of dynamicallyadaptive software. In 28th International Conference on Software Engineering (ICSE
2006),Shanghai,China,May20-28,2006 ,LeonJ.Osterweil,H.DieterRombach,and
Mary Lou Soffa (Eds.). ACM, 371–380. https://doi.org/10.1145/1134285.1134337
[40]Ji Zhang and Betty H. C. Cheng. 2006. Using temporal logic to specify adaptive
programsemantics. J.Syst.Softw. 79,10(2006),1361–1369. https://doi.org/10.
1016/j.jss.2006.02.062
797