Demystifying the Vulnerability Propagation and Its Evolutionvia Dependency Trees in the NPM EcosystemChengwei Liuâˆ—College of Intelligence andComputing, Tianjin UniversityTianjin, Chinachengwei001@e.ntu.edu.sgSen Chenâ€ College of Intelligence andComputing, Tianjin UniversityTianjin, Chinasenchen@tju.edu.cnLingling FanCollege of Cyber Science, NankaiUniversityTianjin, Chinalinglingfan@nankai.edu.cnBihuan ChenSchool of Computer Science andShanghai Key Laboratory of DataScience, Fudan UniversityShanghai, ChinaYang LiuSchool of Computer Science andEngineering, Nanyang TechnologicalUniversitySingapore, SingaporeXin PengSchool of Computer Science andShanghai Key Laboratory of DataScience, Fudan UniversityShanghai, ChinaABSTRACTThird-party libraries with rich functionalities facilitate the fast de-velopment of JavaScript software, leading to the explosive growthof the NPM ecosystem. However, it also brings new security threatsthat vulnerabilities could be introduced through dependencies fromthird-party libraries. In particular, the threats could be excessivelyamplified by transitive dependencies. Existing research only con-siders direct dependencies or reasoning transitive dependenciesbased on reachability analysis, which neglects the NPM-specificdependency resolution rules as adapted during real installation,resulting in wrongly resolved dependencies. Consequently, furtherfine-grained analysis, such as precise vulnerability propagationand their evolution over time in dependencies, cannot be carriedout precisely at a large scale, as well as deriving ecosystem-widesolutions for vulnerabilities in dependencies.Tofill this gap, we propose a knowledge graph-based depen-dency resolution, which resolves the inner dependency relationsof dependencies as trees (i.e.,dependency trees), and investigatesthe security threats from vulnerabilities in dependency trees at alarge scale. Specifically, wefirst construct a complete dependency-vulnerability knowledge graph (DVGraph) that captures the wholeNPM ecosystem (over 10 million library versions and 60 millionwell-resolved dependency relations). Based on it, we propose anovel algorithm (DTResolver) to statically and precisely resolvedependency trees, as well as transitive vulnerability propagationpaths, for each package by taking the official dependency resolutionrules into account. Based on that, we carry out an ecosystem-wideempirical study on vulnerability propagation and its evolution inâˆ—Also with Nanyang Technological University.â€ Sen Chen is the corresponding author.Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full citationon thefirst page. Copyrights for components of this work owned by others than ACMmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish,to post on servers or to redistribute to lists, requires prior specific permission and/or afee. Request permissions from permissions@acm.org.ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USAÂ© 2022 Association for Computing Machinery.ACM ISBN 978-1-4503-9221-1/22/05. . . $15.00https://doi.org/10.1145/3510003.3510142dependency trees. Our study unveils lots of usefulfindings, andwe further discuss the lessons learned and solutions for differentstakeholders to mitigate the vulnerability impact in NPM based onourfindings. For example, we implement a dependency tree basedvulnerability remediation method (DTReme) for NPM packages,and receive much better performance than the official tool (npmaudit fix).ACM Reference Format:Chengwei Liu, Sen Chen, Lingling Fan, Bihuan Chen, Yang Liu, and Xin Peng.2022. Demystifying the Vulnerability Propagation and Its Evolution via De-pendency Trees in the NPM Ecosystem. In44th International Conference onSoftware Engineering (ICSE â€™22), May 21â€“29, 2022, Pittsburgh, PA, USA.ACM,New York, NY, USA, 13 pages. https://doi.org/10.1145/3510003.35101421 INTRODUCTIONDue to the rapid growth of functionality complexity in softwareapplications, software componentization has become an irresistibletrend in software development, leading to the boosting of third-party libraries. As investigated, over 1.7 million Node.js librarieshave been published on NPM [13,14] (a node package manager)to facilitate software development. As Contrast Security [5] re-vealed, third-party libraries appear in a majority (79%) of todayâ€™ssoftware [76]. However, every coin has two sides. Although usinglibraries reduces development cost and time, these integrated li-braries pose a new security threat to the software ecosystem inpractice, that vulnerabilities in these libraries may expose softwarethat depend on them under security risks constantly [52,83â€“85].For example,lodash[9], a widely-used JavaScript utility librarywith over 80 million downloads as dependencies per month, isidentified to have severe vulnerability of prototype pollution andexposes 4.35 million projects on GitHub to the potential risk ofbeing attacked [31].Previous works have investigated vulnerability impact across theNPM ecosystem, while their approaches either only statically con-sider direct dependencies [52], or excessively analyze dependenciesbased on static reachability reasoning [85] which may introduceinaccurate transitive dependencies (illustrated by the motivatingexample of Figure 2 (b) in Section 2.1) resulting in false-positivevulnerability warnings. None of the existing approaches provideprecise dependencies, especially the inner complex relations among6722022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Chengwei Liu, Sen Chen, Lingling Fan, Bihuan Chen, Yang Liu, and Xin Pengdependencies of software, at a large scale, which makes the impactof their analysis weakened and limits further solutions (i.e., preciseremediation) to be proposed. Although some existing SCA tools (e.g.,Snyk [30] and Blackduck [1]) support NPM dependency analysisfor user projects, most of them retrieve dependency trees from realinstallation rather than static reasoning. Besides, dependencies, aswell as vulnerabilities in dependencies, are actually under dynamicchange over time due to theflexibility of semantic versioning [29].Therefore, although existing work has also investigated the impactof vulnerabilities [52,85], it is still challenging to analyze the evo-lution of vulnerability propagation existing in dependencies at alarge scale without static and precise dependency resolution, not tomention to derive practical solutions on preventing vulnerabilitiesfrom dynamically being introduced into dependencies.Tofill these gaps, we face the following challenges. 1)Com-pleteness. NPM ecosystem is the largest platform with over 1million published packages, which are hard to be fully analyzed.Some existing work only either analyzed with a limited numberof libraries [55,64,77], or studied vulnerabilities in dependencytrees of limited projects [39, 44, 61]. Besides, NPM allows variousways to reuse third-party libraries as dependency constraints [23],which are also hard to fully capture and resolve. 2)Accuracy. Exist-ing work [49,64,66,77] only conduct dependency-based analysisby identifying transitive dependencies via reachability reasoningwhile neglecting the NPM-specific dependency resolution rules [16],which would lead to inaccurate results. 3)Efficiency. Even thoughreal installation can precisely retrieve dependency trees, installingNPM packages (i.e.,npm install) is known to always take min-utes per run [18], which is obviously not efficient enough to sup-port large-scale studies. 4)Dynamic updates. NPM packages areknown to have the most dependencies. Any new release of librariesin dependency trees could lead to changes in installed dependen-cies for installation afterwards (as the example in Figure 6), whicheven complicates the management of dependencies, as well as thevulnerability propagation in dependencies. Thus, it is challengingto explore the vulnerability propagation evolution over time.In this paper, to overcome these challenges,1)we implementarobust dependency constraint parserto tackle the diversity of NPMdependency constraints, and based on it, we construct a completedependency-vulnerability knowledge graph (DVGraph) to capturethe dependency relations among all NPM packages (over 1.14 mil-lion libraries and 10.94 million versions), as well as over 800 knownCVEs (Common Vulnerabilities and Exposures) [4] from NVD [11],which further supports the thorough analysis of vulnerability prop-agation.2)We propose an accurate DVGraph based dependencyresolution algorithm (DTResolver) to calculate dependency trees1at any installation time. It integrates the official dependency reso-lution rules and DVGraph-based reasoning to simulate the processof installation (illustrated by the motivating example of Figure 2(c) in Section 2.1). OurDTResolveris validated to have an accuracyof over 90% of resolved dependency trees being exactly the samecomparing to real installation. (3) We further conduct an empiricalstudy on vulnerability propagation in dependency trees. First, weinvestigate the characteristics of dependency trees brought by NPMdependency resolution (details are available at our supplementary1The resolved dependency graph when a given root package is installed.material), based on which, we analyze the impact and features ofvulnerability propagation in dependency trees, particularly the vul-nerabilities from transitive dependencies. Besides, we also extendour study to time dimension to investigate the evolution of vul-nerability propagation in dependency trees over time to unveil thereasons of vulnerabilities being introduced in dependency trees, aswell as possible solutions.Through our empirical study, we conclude somefindings asfollows. For example,1)We statistically prove that vulnerabilitieswidely exist in the dependencies of NPM packages (over one-quarterof library versions from 20% of libraries), even in the latest versions(16% of libraries). Besides, vulnerabilities from direct dependenciesare widely neglected (over 30% affected library versions).2)Knownvulnerabilities are causing a larger impact over time, with moreaffected packages and more vulnerabilities in dependency trees.Most vulnerabilities (93%) are introduced into dependency treesbefore they are discovered, and mostfixing versions (87%) of themare released before they get published. Based on these timely re-leases, most of the vulnerable dependencies can be removed (90%)along with time (in average it takes a year), but there are still 40%of vulnerabilities unable to get thoroughly excluded.3)Consider-able user projects contain unavoidable vulnerabilities even thoughwe have exhausted all possible dependency trees. Morefindingscan be found in Section 5. Additionally, since the severe situationof vulnerability propagation is complicated and requires effortsfrom different roles to mitigate, we also conclude actionable solu-tions from different stakeholders in the supply chain of third-partylibraries based on ourfindings in Section 6.In summary, we make the main contributions as follows.â€¢We design and construct a complete and preciseDVGraphforthe whole NPM ecosystem by leveraging a robust dependencyconstraint parser. The construction and maintenance pipelinestake 20 person-months.â€¢We propose a novel algorithm (DTResolver) based on DVGraphto statically and precisely resolve the dependency trees for anyinstallation time with high accuracy (over 90%), which is validatedby around 100k representative packages.â€¢We conduct thefirst large-scale empirical study based on over50 million resolved dependency trees (calculated on an 8-coremachine for one month) to peek into the vulnerability propaga-tion and the evolution of vulnerability propagation over time andprovide usefulfindings.â€¢We provide an in-depth discussion, including lessons learned andactionable solutions, which provide useful insights to improve thesecurity of the whole NPM ecosystem for different stakeholders,such as the proposed remediation (DTReme) that excludes morevulnerabilities than the official toolnpm audit fix.â€¢We have made the relevant analytic data publicly available2tofacilitate the relevant research on the NPM ecosystem.Figure 1 demonstrates the overview of our work, includingthe dependency-vulnerability knowledge graph construction (Sec-tion 3), dependency tree resolution, vulnerable path identification,and their validations (Section 4), a large-scale empirical study (Sec-tion 5) and discussion on lessons learned and solutions, as well aspossible research directions (Section 6).2https://sites.google.com/view/npm-vulnerability-study/673Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. Demystifying the Vulnerability Propagation and Its Evolution via Dependency Trees in the NPM Ecosystem ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Figure 1: Overview of our work	
	

	

	
	ACBDDB@1.0.0D@1.1.0D@2.0.0C@1.0.01.0.0
D@1.2.0EE@1.0.0^1.1.0D1.0.0
*ACBDDB@1.0.0D@1.1.0D@2.0.0C@1.0.01.0.0
1.0.0  			 	
 	 			  	 	 			  

 	(1) D has four versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0(2)According tonode-semver,âˆ¼1.1.0represents â€œ<1.2.0 and >=1.1.0â€, Ë†1.1.0represents â€œ<2.0.0 and >=1.1.0â€, â€œ*â€ represents any version.Figure 2: An example of NPM dependency resolution2 MOTIVATING EXAMPLE ANDBACKGROUND2.1 Motivating ExampleHere, we present an example to illustrate why it is unreliable toconduct vulnerability propagation analysis via existing reachabil-ity analysis. Figure 2 presents an example, where each package isrepresented in the format oflibrary@version. Figure 2 (a) presentsthe original dependency relations of packages in the format ofli-brary:constraint. Figure 2 (b) and Figure 2 (c) present the resolveddependency of A@1.0.0 via reachability reasoning (i.e., dependencyreach in [85]) and NPM official rules, respectively. Specifically, whenresolving the dependency of C@1.0.0, reachability analysis selectsD@1.2.0 because 1.2.0 is the highest satisfying version of depen-dency constraint Ë†1.1.0 from C@1.0.0 to D, and package E@1.0.0 isalso selected. However, this may lead to inaccurate results. NPMfollows its own principle to resolve dependencies during installa-tion [16]. For example, NPM takesreal installation contextintoaccount when resolvingdependency trees(e.g., allowing existingversions to be reused), while resolving transitive dependency viareachability fails to involve such rules. As presented in Figure 2 (c),since existing D@1.1.0 satisfies Ë†1.1.0, it will directly reuse D@1.1.0instead of resolving a new one. Thus, D@1.2.0 and E@1.0.0 arewrongly resolved by reachability analysis in Figure 2 (b).2.2 BackgroundWe briefly introduce several concepts related to dependency man-agement and vulnerabilities in the NPM ecosystem.NPM Package Metadata.NPM [13] is the official package man-ager for Node.js and provides a public NPM registry to maintain
Figure 3: Schema of NPM dependency-vulnerability graphinformation of all published libraries (i.e.,NPM package meta-data[22]). Such metadata describes all information of a given li-brary and its released versions, and the dependency relation ofeach version, which is useful for indexing libraries and resolvingdependencies when installing a library.Dependency Constraints.Dependencies of packageğ‘are speci-fied as a list of key-value pairs in metadata, wherekeyrepresents alibraryğ‘™ğ‘–ğ‘ğ‘andvaluerepresents the allowed version range (i.e., con-straint) thatğ‘should follow when selecting the version of libraryğ‘™ğ‘–ğ‘ğ‘during installation. There are different types of constraints inNPM [21], such asVersionandRange,Tag,URLs(i.e., Git urls andRemote links), and local paths (Directory and File).Semantic Versioning.It has been proposed as a solution of ver-sion control when maintaining package dependencies. It definesversion numbers presented in the format ofMajor.Minor.Patch.When a new version is released,Majorincreases when incompati-ble API changes have been taken out,Minorraises when function-ality changes are still backward compatible, andPatchgrows whenbackward compatible bugfixes have been made.Vulnerabilities in NPM Packages.Vulnerabilities in NPM pack-ages are included in the CVE reports. Each CVE is published with de-tailed information about vulnerabilities and their references. Specif-ically, the affecting libraries and the corresponding versions arealways described in free text descriptions, which raises more effortsto retrieve and map CVEs with exact affecting library versions.3 DVGRAPH CONSTRUCTIONTo support large scale dependency-based vulnerability analysiswith high accuracy and efficiency, we design and implement a setof infrastructures to construct and maintain a complete and precisedependency-vulnerability graph (DVGraph).DVGraph Definition and Schema.The NPMğ·ğ‘‰ğºğ‘Ÿğ‘ğ‘â„is de-signed as a directed knowledge graph with labeled vertices anddirected edges:ğº=(ğ‘,ğ¸), whereğ‘represents all node entitieswith different types inğº, i.e., Library (Lib), Version (Ver), and674Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Chengwei Liu, Sen Chen, Lingling Fan, Bihuan Chen, Yang Liu, and Xin Peng
Figure 4: Automated data processing frameworkVulnerability (Vul).ğ¸represents the relations between nodes, 8types in total, including inner-library relations (i.e.,has,upper,andlower), cross-library relations (i.e.,depends,default, andlib-deps), and vulnerability-related relations (i.e.,affectsandlibaf-fects). Figure 3 shows the detailed schema of each type of nodesand relations. Specifically, we present relations in the format ofâ€œ<Node>â€“<relation>â†’<Node>â€ as follows:Â‚Inner-library rela-tions: â€œLib1â€“hasâ†’Ver1â€ denotes Lib1has a released version Ver1,â€œVer1â€“upper/lowerâ†’Ver2â€ denotes the next semantically upper/lowerversion ofVer1isVer2.ÂƒCross-library relations:â€œVer1â€“dependsâ†’Lib2â€ denotesVer1directly depends onLib2. Specifically, for eachğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘ , we denote â€œVer1â€“defaultâ†’Ver2â€, whereVer2is the latestversion ofLib2that satisfies theğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘›ğ‘ğ‘¦_ğ‘ğ‘œğ‘›ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘–ğ‘›ğ‘¡ofğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘ , because NPM takes the latest satisfied version when resolvingdependency constraint to specific versions by default. Moreover,â€œLib1â€“libdepsâ†’Lib2â€ denotes that there exists at least one versionofLib1depending onLib2.Â„Vulnerability-related relations: Sincevulnerabilities usually exist in multiple versions, â€œVul1â€“affectsâ†’Ver1â€ and â€œVul1â€“libaffectsâ†’Lib1â€ denote that Vul1exists in Ver1and exists in at least one version of Lib1, respectively.DVGraph Construction and Maintenance.The DVGraph isconstructed as a knowledge graph in Neo4j [12]. NPM resolves de-pendency constraints with the highest satisfying version by default,which claims a high demand for real-time updates of dependencydata. Therefore, we conduct an automated data processing frame-work for long-term maintenance as shown in Figure 4, including: (1)Metadata Pipeline, subscribes, daily collects, cleans, and processesnew coming NPM package metadata, and preserves them in ourmetadata database. (2)CVE Pipeline, collects CVE feeds [27] fromthe NVD database. Since some information in CVE feeds are usuallyin plain text, a CVE cleaner is designed tofilter the languages andidentify the affected libraries, as well as affecting version ranges,and save them as the initial results. (3)CVE Triage Pipeline, is asemi-automated pipeline. It helps experienced security analystsprocess, label and confirm the newly crawled CVE data with corre-sponding affected libraries and versions. (4)Graph Pipeline, parsesthe new coming metadata and mapped CVE data, calculates theoperations (i.e., adding, altering, and deleting nodes and edges) tobe done on DVGraph, andfinally executes them.Specifically, there are two challenges duringDVGraphupdate.â€¢Dependency Parser: The diversity of NPM dependency con-straints makes it complex to resolve proper versions. Wronglyhandled dependency relations can cause deviation when rea-soning transitive dependencies, and none of the existing workTable 1: Graph statisticsElements #InstancesElements #InstancesLib1,147,558has10,939,334Ver10,939,334upper9,804,406Vul815lower9,804,406depends62,232,906affects23,217default61,940,009libaffects830libdeps4,216,742Graph size 15.15GBhas taken all major types into account. To this end, we proposeand developa robust dependency constraint parserbasedonnode-semver[28]. It handles not only semver version rangesbut also version tags, Git URLs, and remote links [21].â€¢CVE Mappings: Even though the CVE pipeline crawls and pro-cesses CVE data and automatically recognizes affected librariesand version ranges, there still could be mislabeling since theyare usually given in free-text descriptions [58,59]. Therefore,we implement the CVE Triage Pipeline as shown in Figure 4and have devoted four experienced analysts to check the CVEmappings of affected library and version ranges, some exist-ing famous vulnerability databases [32] [34] are also involvedas references. After confirmation, all affected versions can besorted out by the constraint parser.Remarks: It takes 3 months for 3 co-authors and experiencedsoftware engineers to implement and test, and another 4 se-curity analysts to conduct daily validation of CVE mappings.DVGraph Statistics.To carry out large-scale studies on NPM vul-nerability propagation and evolution, we take a snapshot ofDV-Graphby the end of 2020 (Most of CVEs before 2020 arefinalized)to conduct further analysis. Table 1 shows the basic statistics of thesnapshot. 1,147,558 libraries and 10,939,334 versions have been cap-tured in theDVGraph, among which 62,232,906 direct dependencies(ğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘ ) are captured in DVGraph. Besides, 815 CVEs have beenincluded in DVGraph, generating 830libaffectsand 23,217affectsfrom these CVEs to 624 libraries and 14,651 versions, respectively.Overall, the storage size of the DVGraph snapshot is over 15GB.DVGraph and CVE Mapping Validations.To roughly validatethe coverage ofDVGraph, we take a snapshot of the metadatadatabase to compare with it. Wefind that DVGraph covers 100% oflibraries and 99.96% of versions of the metadata database (the restare unpublished [25]). Besides, only 0.36% of direct dependencies arenot captured inDVGraphbecause the corresponding dependencylibraries are missing in the NPM registry. Furthermore, we alsofind0.47% ofğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘ cannot be resolved to any satisfying version dueto no satisfying version or invalid dependency constraints.Remarks: As for the validation of CVE mappings, besides 4security analysts have validated all new-coming CVEs everyday, the co-authors still manually check the mappings betweenall CVEs and the affected library versions after we conduct thesnapshot. In particular, since the publish time of CVEs differsfrom several sources [4, 11, 32], we take the earliest ones.4 DEPENDENCY TREE RESOLUTION ANDVULNERABLE PATH IDENTIFICATIONTo facilitate large-scale studies, we propose a novel methodologyon dependency tree resolution to statically resolve the dependency675Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. Demystifying the Vulnerability Propagation and Its Evolution via Dependency Trees in the NPM Ecosystem ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USARoot package:ADirectdependency(a) Dependency tree of packageA
(b) Vulnerable PathsFigure 5: Examples of dependency tree and vulnerablepaths (each node represents a package with an exactversion)trees of packages based on the complete and well-maintained DV-Graph. It not only resolves dependency trees precisely but alsopreserves the high efficiency of static analysis, which enables mostof SCA [33] scanning tasks to be carried out without real installa-tion, e.g., license violation detection, untrustworthy dependencydetection, etc. Therefore, identifying vulnerabilities and correspond-ing vulnerable paths that vulnerable packages propagate to affectthe root package can also be accurately and efficiently captured.4.1 Dependency Tree DefinitionThird-party libraries are usually installed along with the installationof user projects as dependencies, during which NPM follows its owndependency resolution rules and resolves dependency constraintsinto specific library versions recursively. These resolved libraryversions and dependency relations among them form a directeddependency graph.Precisely, we denote the graph asdependency tree,ğ·ğ‘‡ğ‘Ÿğ‘œğ‘œğ‘¡=(ğ‘‰ğ‘’ğ‘Ÿ,ğ·ğ‘’ğ‘),ğ‘Ÿğ‘œğ‘œğ‘¡denotes the root package (could be user project)that is to be installed, andğ‘‰ğ‘’ğ‘Ÿrepresents the set of library versionsthat are resolved during the real installation, andğ·ğ‘’ğ‘is the set ofdependency relations amongğ‘‰ğ‘’ğ‘Ÿ. To distinguish withğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘ inDVGraph, we further defineğ‘£ğ‘–ğ‘‘ğ‘’ğ‘â†’ğ‘£ğ‘—as the specific dependencyrelation between library versionğ‘£ğ‘–andğ‘£ğ‘—inğ·ğ‘‡. Figure 5a showsthe dependency treeğ·ğ‘‡ğ´of packageAstarting from packageA(the root package) and connecting all resolved library versionswith dependency relations. Theğ‘‰ğ‘’ğ‘Ÿğ‘ that are directly depended onby the root package A are denoted asdirect dependencies, andthe others that are not directly depended on by A are denoted asindirect (transitive) dependencies, as presented in Figure 5a.4.2 Dependency Tree ResolutionLots of work [49,64,66,77] has been carried out to investigate tran-sitive dependencies in the NPM ecosystem. However, none of themhave taken into consideration the platform-specific dependencyresolution rules [6], which could result in inaccurate dependenciesbeing resolved (illustrated by the example shown in Figure 2). Tofill this gap, we aim tostaticallyresolve dependency trees that areconsistent with what NPM dynamically resolves and installs duringreal installation, so that we can identify vulnerabilities and vulnera-ble paths in dependency trees precisely and efficiently without realinstallation.Besides the reachability analysis, there exist other tools [15]scanning vulnerabilities by examining dependencies after real in-stallation. However, suchdynamic approaches always take a muchlonger time than static approaches and are not efficient enough forlarge-scale analysis. Besides, during installation, NPM manipulatesdependencies based on physical trees (connectingğ‘‰ğ‘’ğ‘Ÿğ‘ based onphysical location of installation), which makes the inner depen-dency relations in logical trees (connectingğ‘‰ğ‘’ğ‘Ÿğ‘ based on depen-dency relations) implicit. Therefore, to improve the accuracy andmeanwhile reserve the efficiency, we propose a DVGraph-based de-pendency resolution algorithm (DTResolver) to statically calculatethe implicit logical dependency trees without installation.Specifically, as presented in Algorithm 1, we simulate the folderallocation process [6] during real installation, and recursively re-solve dependencies for each selected library versions (lines 5âˆ¼27).ğ‘„denotes a queue to control the recursion process, andğ·ğ‘–ğ‘Ÿrepre-sents a virtual and empty directory (as well as an empty physicaltree, line 1). For each visited library version inğ‘„, we iterate itsdependencies alphabetically (line 8). For each dependency relation,the latest satisfied version will be selected when resolving a certaindependency (line 15). However, such resolving is also influenced bythe physical tree. If there is an installed versionğ‘£ğ‘–for the requiredlibrary that is on a higher position in the physical tree, the installedone will be reused instead of resolving a new version (lines 11âˆ¼13).Otherwise, a new latest satisfied version will be resolved and in-stalled (lines 15âˆ¼27). Note that, we denoteğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™_ğ‘ğ‘ğ‘¡â„to presentinstall position in the physical tree, and whenğ‘ğ‘ğ‘¡â„_1/subsetsqequalğ‘ğ‘ğ‘¡â„_2, itmeansğ‘ğ‘ğ‘¡â„_2 is insideğ‘ğ‘ğ‘¡â„_1. In other words,ğ‘ğ‘ğ‘¡â„_1 is on higherposition ofğ‘ğ‘ğ‘¡â„_2 (lines 11, 20).Meanwhile, we also maintain the individual dependency rela-tions between packages during the simulation process (lines 12, 25).Therefore, we can further recover the logical tree with the physicaltree structure and those dependency relations. Besides, we alsoinclude lots of individual version selection rules (e.g., priorities ondeprecated versions [19] and latest tags [36]) that NPM follows inour algorithm to the best of our knowledge.Additionally, we extend our algorithm totime dimensionbyaddingfilters on release time when selecting satisfying versions(comments on line 15), and this empowers the calculation of de-pendency trees at any previous time from release time. Therefore,more time-based analyses could be carried out.4.3 Vulnerable Path IdentificationSince all known vulnerabilities (CVEs) and their affecting librariesand versions are already well mapped inDVGraph, the resolveddependency trees can further provide the capability to extract de-pendency paths. Dependency paths connectğ‘‰ğ‘’ğ‘Ÿğ‘ inğ·ğ‘‡in seriesviağ·ğ‘’ğ‘ğ‘ among them, each pathğ‘ƒis a subset ofğ·ğ‘‡with orders,and can be denoted asğ‘ƒ=(ğ‘ƒğ‘,ğ‘ƒğ¸),ğ‘ƒ/subsetsqequalğ·ğ‘‡, whereğ‘ƒğ‘is anordered list ofğ‘‰ğ‘’ğ‘Ÿğ‘ that can be connected viağ·ğ‘’ğ‘ğ‘ in the givenorder, andğ‘ƒğ¸is the ordered list ofğ·ğ‘’ğ‘ğ‘ that connectğ‘‰ğ‘’ğ‘Ÿğ‘ , theysatisfy Equation 1 and 2, respectively.âˆ€ğ‘–.ğ‘–âˆˆ[0,ğ‘˜âˆ’1)âˆ§ğ‘£ğ‘–âˆˆğ‘ƒğ‘()ğ‘‘.(ğ‘‘âˆˆğ·ğ‘’ğ‘âˆ§ğ‘‘ğ‘ ğ‘Ÿğ‘=ğ‘£ğ‘–âˆ§ğ‘‘ğ‘‘ğ‘ ğ‘¡=ğ‘£ğ‘–+1)(1)âˆ€ğ‘’ğ‘–.(ğ‘’ğ‘–âˆˆğ‘ƒğ¸)(ğ‘’ğ‘–_ğ‘ ğ‘Ÿğ‘=ğ‘£ğ‘–âˆ§ğ‘’ğ‘–_ğ‘‘ğ‘ ğ‘¡=ğ‘£ğ‘–+1(2)ğ‘ƒ|ğ‘ ğ‘Ÿğ‘ğ‘‘ğ‘ ğ‘¡={ğ‘ƒğ‘–/subsetsqequalğ·ğ‘‡:ğ‘ƒğ‘ğ‘–_0=ğ‘£ğ‘ ğ‘Ÿğ‘âˆ§ğ‘ƒğ‘ğ‘–_ğ‘˜=ğ‘£ğ‘‘ğ‘ ğ‘¡)}(3)676Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Chengwei Liu, Sen Chen, Lingling Fan, Bihuan Chen, Yang Liu, and Xin PengAlgorithm 1:Dependency Tree ResolutionInput:ğº: DVGraph,ğ‘Ÿ: given root package,//ğ‘¡: given timeOutput:ğ·ğ‘‡ğ‘Ÿ: Resolved dependency tree of r1ğ·ğ‘–ğ‘Ÿâ†new InstallDirectory()2ğ‘Ÿğ‘œğ‘œğ‘¡_ğ‘ğ‘ğ‘¡â„â†+,ğ‘„â†+,ğ·ğ‘’ğ‘ğ‘ â†+3ğ·ğ‘–ğ‘Ÿ.install(ğ‘Ÿ,ğ‘Ÿğ‘œğ‘œğ‘¡_ğ‘ğ‘ğ‘¡â„)4ğ‘„.push(ğ‘Ÿ)// 1. Traverse all resolved dependency nodes by BFS, and simulatereal installation to create folders for packages5whileğ‘„/uni2260+do6ğ‘™ğ‘£â†ğ‘„.pop()7ğ‘‘ğ‘’ğ‘ğ‘ â†{ğ‘’âˆˆğº:ğ‘’ğ‘ ğ‘Ÿğ‘=ğ‘™ğ‘£âˆ§ğ‘’.ğ‘¡ğ‘¦ğ‘ğ‘’=ğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘ }8foreachğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘âˆˆğ‘‘ğ‘’ğ‘ğ‘ do9ğ‘£ğ‘’ğ‘Ÿğ‘ â†ğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘.ğ‘ ğ‘ğ‘¡ğ‘–ğ‘ ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘£ğ‘’ğ‘Ÿğ‘ ğ‘–ğ‘œğ‘›ğ‘ 10deplibâ†ğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘‘ğ‘ ğ‘¡11if)ğ‘£ğ‘–.ğ‘£ğ‘–âˆˆDirâˆ©versâˆ§ğ‘£ğ‘–.ğ‘‘ğ‘–ğ‘Ÿ_ğ‘ğ‘ğ‘¡â„/subsetsqequalğ‘™ğ‘£.ğ‘‘ğ‘–ğ‘Ÿ_ğ‘ğ‘ğ‘¡â„then12ğ‘Ÿâ†(CREATEğ‘™ğ‘£ğ‘‘ğ‘’ğ‘â†’ğ‘£ğ‘–)13ğ·ğ‘’ğ‘ğ‘ .push(ğ‘Ÿ)14else15ğ‘ ğ‘’ğ‘™ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘â†ğ‘£ğ‘–.ğ‘£ğ‘–âˆˆğ‘£ğ‘’ğ‘Ÿğ‘ âˆ§(âˆ€ğ‘£ğ‘—.ğ‘£ğ‘—âˆˆğ‘£ğ‘’ğ‘Ÿğ‘ âˆ§ğ‘–/uni2260ğ‘—âˆ§ğ‘£ğ‘–>ğ‘£ğ‘—)//âˆ§ğ‘£ğ‘–.ğ‘Ÿğ‘’ğ‘™ğ‘’ğ‘ğ‘ ğ‘’ğ‘‘_ğ‘¡ğ‘–ğ‘šğ‘’<ğ‘¡1617ifDirâˆ©vers =+then18ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™_ğ‘ğ‘ğ‘¡â„â†ğ‘Ÿğ‘œğ‘œğ‘¡_ğ‘ğ‘ğ‘¡â„19else20foreachsubpath/subsetsqequallv.dir_pathdo21ifÂ¬)ğ‘›.ğ‘›âˆˆğ‘ ğ‘¢ğ‘ğ‘ğ‘ğ‘¡â„âˆ§(ğ‘‘ğ‘’ğ‘ğ‘™ğ‘–ğ‘âˆ’â„ğ‘ğ‘ â†’ğ‘›)then22ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™_ğ‘ğ‘ğ‘¡â„â†ğ‘ ğ‘¢ğ‘ğ‘ğ‘ğ‘¡â„23break24ğ·ğ‘–ğ‘Ÿ.install(ğ‘ ğ‘’ğ‘™ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘,ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™_ğ‘ğ‘ğ‘¡â„)25ğ‘Ÿâ†(CREATEğ‘™ğ‘£ğ‘‘ğ‘’ğ‘â†’ğ‘ ğ‘’ğ‘™ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘)26ğ·ğ‘’ğ‘ğ‘ .push(ğ‘Ÿ)27ğ‘„.push(ğ‘ ğ‘’ğ‘™ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘)// 2. Recover a dependency tree from install directory and CREATEDDeps relations28ğ‘‰ğ‘’ğ‘Ÿğ‘Ÿâ†{ğ‘™ğ‘£:ğ‘™ğ‘£âˆˆğ·ğ‘–ğ‘Ÿ}29ğ·ğ‘’ğ‘ğ‘Ÿâ†ğ·ğ‘’ğ‘ğ‘ 30ğ·ğ‘‡ğ‘Ÿğ‘œğ‘œğ‘¡â†<ğ‘‰ğ‘’ğ‘Ÿğ‘Ÿ,ğ·ğ‘’ğ‘ğ‘Ÿ>31returnğ·ğ‘‡ğ‘Ÿwhereğ‘˜denotes the length ofğ‘ƒğ‘, andğ‘’ğ‘–denotes the dependencyrelation betweenğ‘£ğ‘–andğ‘£ğ‘–+1. Specifically, there could be multiplepaths to one target node in a dependency tree. Considering thecross dependencies, we denote the set of dependency paths fromlibrary versionğ‘£ğ‘ ğ‘Ÿğ‘to library versionğ‘£ğ‘‘ğ‘ ğ‘¡asğ‘ƒ|ğ‘ ğ‘Ÿğ‘ğ‘‘ğ‘ ğ‘¡, as defined inEquation 3. Specifically, we denote the set of dependency pathsfrom root package to library versionğ‘£ğ‘‘ğ‘ ğ‘¡asğ‘ƒ|ğ‘‘ğ‘ ğ‘¡.Based on the resolved dependency trees and paths for the in-stalled packages, the algorithm also facilitates the identification ofvulnerable packages in dependencies (i.e.,vulnerable point) andthe paths that these vulnerable packages propagate on to affect theroot package (i.e.,vulnerable path), and we also denote them asEquation 4 and 5, respectively.ğ´ğ‘ƒğ´denotes the set ofğ‘‰ğ‘’ğ‘Ÿğ‘ inğ·ğ‘‡ğ´that are affected by known vulnerabilities,ğ‘‰ğ‘ƒdenotes the set ofğ‘ƒğ‘–whose last nodeğ‘ƒğ‘–_ğ‘˜âˆ’1is affection point,ğ‘‰ğ‘¢ğ‘™denotes all vul-nerabilities we have maintained in DVGraph. Moreover, we defineK-step vulnerable pathğ‘‰ğ‘ƒğ‘†=ğ‘˜as vulnerable paths that containğ‘˜dependency relations, as defined in Equation 6.ğ´ğ‘ƒğ´={ğ‘£âˆˆğ‘‰ğ‘’ğ‘Ÿğ´:)ğ‘›ğ‘£ğ‘¢ğ‘™.(ğ‘›ğ‘£ğ‘¢ğ‘™âˆˆğ‘‰ğ‘¢ğ‘™âˆ§(ğ‘›ğ‘£ğ‘¢ğ‘™âˆ’ğ‘ğ‘“ ğ‘“ğ‘’ğ‘ğ‘¡ğ‘ âˆ’â†’ğ‘£))}(4)ğ‘‰ğ‘ƒğ´={ğ‘ƒ|ğ‘£/subsetsqequalğ·ğ‘‡ğ´:(ğ‘ƒ|ğ‘£)ğ‘˜âˆ’1âˆˆğ´ğ‘ƒğ´}(5)ğ‘‰ğ‘ƒğ‘†=ğ‘˜={ğ‘ƒ|ğ‘£âˆˆğ‘‰ğ‘ƒğ´:|(ğ‘ƒğ¸|ğ‘£)|=ğ‘˜}(6)Examples of vulnerable points and paths are given in Figure 5b.Thus, we implement a vulnerable path extractor by reverse DepthFirst Search (DFS) to exhaustivelyfind dependency relations fromvulnerable points to the root node in a dependency tree.4.4 Validation of Dependency Tree ResolutionWe validate theDTResolverby comparing the dependency treesresolved byDTResolverwith the real installed ones. Moreover, wetakenpm-remote-ls[24] as a baseline method when comparing,which is a widely-used public API to get dependency trees withoutreal installation in practice, and it exactly follows the dependencyreach to derive dependency trees.Data SelectionOur validation is based on the data collected bytwo criteria: (1)Popularity, for each popularity metrics (i.e., moststars, most forks, most downloaded in the past, past 3 years, and lastyear), we select the top 2,000 libraries respectively. (2)Centrality,for each centrality metric (i.e., most in and out degree), we alsoselect the top 2,000 libraries and top 20K versions. respectively. Forlibraries, we take the highest patch version for each minor version.Finally, 103,609 versions from 15,673 libraries are sorted out.Experiment.Based on the collected data, wefirst collect all in-stallation dependency trees (Install Tree) for each version fromreal installation (npm-install[17] andnpm-ls[20]), 82,415 of theseversions are successfully collected after excluding those with instal-lation errors. We also collect the dependency trees (Remote Tree)fromnpm-remote-ls. Moreover, to compare with real installationresults, we update the graph after allInstall Treesare well collected,so that all packages in theInstall Treesare updated into the graph.Based on it, we further compute the dependency trees (Graph Tree)for all versions with their corresponding installation times.Evaluation ofDTResolver.According to the result,90.58%ofGraph Treesexactly match theInstall Treesafter ignoring incalcu-lable cases, e.g., having bundled dependencies [3] and containingdependencies with no released time. While only 53.33% ofRemoteTreesexactly match theInstall Trees, which is becausenpm-remote-lshave missed some official resolution rules (e.g., priority selectionon not deprecated versions). Besides, we further identified twomajor reasons for mismatched dependency trees: 1) Dependenciesare deduplicated [7] in the output ofnpm ls, which omits somepackages and dependency relations to simplify the tree view. 2)Dependencies may not be fully installed due to environmental is-sues (e.g., some packages may not be installed when the requiredOS support is missing). Besides, missing library versions (i.e., notin the NPM registry or crawling failure) also cause some missingpackages in the dependency trees.Evaluation of Vulnerability Detection and Vulnerable PathIdentification.Besides the evaluation ofDTResolver, we also ex-tend to compare the detected vulnerabilities and vulnerable paths.Since theInstall Treeretrieved from real installation may be in-complete (e.g., some packages in dependencies are not installeddue to environment issues), we evaluate the accuracy of vulnera-bility detection by the recall of the identified vulnerabilities andvulnerable paths inGraph TreeandRemote Tree.W efind that both677Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. Demystifying the Vulnerability Propagation and Its Evolution via Dependency Trees in the NPM Ecosystem ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USADTResolver (98.1%) andnpm-remote-ls(97.7%) have similarly highcoverage on detecting vulnerable components but vary on identify-ing vulnerable paths (92.60% vs. 78.31%). This is probably becausemost dependency constraints are resolved to the highest satisfiedversion, and dependency reach also follows this rule, therefore,most vulnerable packages can still be identified. However, resolv-ing dependencies via dependency reach neglects the NPM specificresolution rules, which compromises the accuracy on identifyingdependency paths.The results not only prove the quality of theDVGraphand theaccuracy ofDTResolver, but also the accuracy of vulnerability de-tection and vulnerable path identification. We take more evaluationdetails and case analysis on our website (https://sites.google.com/view/npm-vulnerability-study/).5 LARGE-SCALE EMPIRICAL STUDYThe dependency reachability reasoning adapted in existing workmakes it difficult to carry out morefine-grained analysis on depen-dencies, such as deducing the dynamic changes of vulnerabilityin dependency trees, due to the neglecting of inner dependencyrelations (i.e., structure) in dependency trees as discussed in Sec-tion 4.2. However, such analysis is vital to unveil the reasons andcharacteristics of vulnerabilities being introduced as dependen-cies to support precise remediation for dependency trees and evensolutions to mitigate the entire NPM ecosystem. Therefore, ourproposedDTResolveris vital, and based on this, we further carryout our study on vulnerability propagation and evolution in thecontext of dependency trees from these two research questions:â€¢RQ1:(Vulnerability Propagation via Dependency Trees) Howdo vulnerabilities affect the NPM ecosystem? How do vulnera-bilities propagate to affect root packages via dependency tree?â€¢RQ2:(Vulnerability Propagation Evolution in DependencyTrees) How do vulnerability propagation evolves in depen-dency trees? How do dependency tree changes influence theevolution of vulnerability propagation?5.1 RQ1: Vulnerability Propagation viaDependency TreesThe goal of this section is to investigate how does NPM dependencyresolution influence the vulnerability propagation via dependencytrees from two aspects: 1) the propagation of vulnerability viadependency trees and 2) the influence on vulnerability propagationbrought by NPM dependency resolution.5.1.1How many packages are affected by existing knownvulnerabilities in the NPM ecosystem?Existing studies [52,85] have unveiled that vulnerabilities in third-party libraries canwidely affect the NPM ecosystem via dependencies, while theirneglecting on NPM specific dependency resolution rules may leadto inaccurate dependencies (cf.Figure 2), resulting in biases inconclusions. Therefore, we re-evaluate the vulnerability impact bycomputing dependency trees for all packages in the NPM ecosystemand analyzing vulnerability propagation for each of them.As presented in Table 1, we have captured 815 known vulnerabil-ities inDVGraph, which exist in 14,651 versions from 624 libraries.The amount of these library versions (directly affected) are rela-tively small, comparing to the mass of the NPM ecosystem. How-ever, based on the dependency trees we resolved, wefind thatanastonishing portion (i.e., 24.78%, 2,711,222) of versions, from 19.96%(229,037/1,147,558) libraries, are transitively affected by 416 CVEs,which are introduced from versions of 294 vulnerable libraries.Besides, since users are always recommended to take the latestversion of libraries to get rid of vulnerability, we further analyzethe vulnerability propagation in the latest versions of all libraries(1,147,558), and wefind that the latest versions of 185,598 libraries(16.17%) are still transitively affected. Thisfinding reveals that latestversions of third-party libraries are also under potential risk of beingaffected by known vulnerabilities via dependencies.Moreover, we further notice a bad practice that the latest versionof 35.03% (103/294) of vulnerable libraries that have dependentpackages are vulnerable. Since NPM usually resolves dependencyconstraints as the highest satisfying versions, these vulnerable latestversions have a much higher chance of being depended on by otherpackages than old versions, leading to much higher possibility ofdistributing indirect vulnerability propagation.Finding-1:xIt is statistically proved that vulnerabilities arewidely existing in dependencies of NPM packages (one-quarterversions of 19.96% libraries across the ecosystem).yLatestversions of third-party libraries (16.17%) are still under poten-tial risks of being affected by vulnerabilities via dependencies.zA considerable portion of vulnerable libs (over 100) that areused by others, still have vulnerable latest versions.5.1.2How do vulnerabilities propagate to affect root pack-ages via dependency tree?Based on the dependency trees (over10 million) we resolved, we also extract the vulnerable points andcorresponding vulnerable paths to investigate how do vulnerabili-ties propagate to affect root packages via dependency trees.For vulnerable points, we notice that there is clear centralitythat some influential vulnerabilities transitively affect a significantportion of library versions in the NPM ecosystem. Particularly, wefind 25 CVEs have affected over 10k libraries or 100k versions (1%of the entire ecosystem), which might be utilized to threaten theNPM ecosystem. The top 10 of them are presented in Table 2.Table 2: Top 10 CVEs that affect most versionsPublic ID Source Lib. #Affected Ver. #Affected Lib.CVE-2019-10747set-value948,208 73,947CVE-2019-10744lodash867,148 79,459CVE-2018-16487 lodash 819,360 77,433CVE-2018-3721 lodash 790,100 75,817CVE-2018-3728 hoek 741,754 62,227CVE-2019-1010266 lodash 712,971 70,956CVE-2018-1000620 cryptiles 601,414 52,334CVE-2018-20834 tar 592,691 48,356CVE-2017-16137 debug 509,455 38,626CVE-2016-10540 minimatch 388,126 41,423To have a more intuitive view of vulnerability propagation, weextract vulnerable paths from these vulnerable points to corre-sponding root packages. Note that we ignore library versions (0.5%)which have over 1k vulnerable paths, since it takes too much timeto compute all paths exhaustively. Finally, we identified88,192,572vulnerable paths. On average, each vulnerable version has 3.97
678Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Chengwei Liu, Sen Chen, Lingling Fan, Bihuan Chen, Yang Liu, and Xin Pengvulnerable points in its dependency tree, which generate 32.53 vul-nerable paths. Besides, nearly 90% of vulnerable paths are longerthan 3 steps. This means that each vulnerable point in dependencytrees may have multiple complex paths to affect the root packages,and these results prove that remediation on single dependency re-lation or even single vulnerable path may not be enough to excludecorresponding vulnerabilities completely.Besides, it is surprising that there are still 33.33% vulnerableversions (903,569) havingone-step vulnerable paths(refer toFigure 5b), and 12.04% of them (326,404) only have such paths.Since direct dependencies are visible to developers and maintainersas configured inpackage.json[23], one-step vulnerable path shouldbe easily identified and handled if developers and maintainers aresensitive to vulnerabilities in dependencies. Moreover, we furthernotice that one-step vulnerable paths exist in dependency trees of33.42% (62,022/185,598) of vulnerable latest versions, which meanseven for the latest versions, developers and maintainers have notpaid enough attention to security in dependencies. Thesefindingsindicate a universal lack of attention on vulnerabilities from depen-dencies, even for vulnerabilities from direct dependencies.As for multi-step vulnerable paths, the vulnerable paths of 49.57%of vulnerable versions (1,344,020) propagate and affect root packagevia only one direct dependency. Vulnerable paths of 78.94% of them(2,140,239) go through no more than 3 direct dependencies. Thisindicates that most vulnerable paths are centralized to propagateand affect root packages via limited direct dependencies, and itproves that controlling direct dependencies precisely may be aneffective solution to cut offmost vulnerable paths.Finding-2:xThere are centrality that some influentialknown CVEs widely exist in the dependency trees of a signifi-cant portion of packages.yPackages are usually affected bymultiple vulnerable points, and each vulnerable point affectsroot packages via multiple vulnerable paths (averagely, onevulnerable points introduce 8 vulnerable paths).zVulnerabil-ities still widely exist in direct dependencies of affected libraryversions (over 30%), even for the latest versions.{There isalso centrality on vulnerable paths that most of the vulnerablepaths go through limited direct dependencies, which could beutilized to cut offvulnerable paths.5.2 RQ2: Vulnerability Propagation Evolutionin Dependency TreesSince dependency trees installed by default could change along withthe release of new version of any library in the tree, it is highly pos-sible that the status of root packages being affected by vulnerabilityvia dependencies also changes over time. An example of depen-dency tree changes (DTCs) that introduces vulnerability is depictedin Figure 6. A@1.0.0 has experienced two DTCs when B and Crelease new versions, two vulnerable points (B@1.0.1 and D@1.1.0)are introduced into the dependency tree of A@1.0.0. Note that thedependency trees we analyze are the ones to be installed by default,instead of the outdated dependencies in runtime environment.To investigate the evolution of vulnerability propagation, there-fore,find out reasons for the widespread of vulnerability propaga-tion and further derive actionable solutions, we resolve dependency
Figure 6: An example of vulnerability propagationevolution via dependency tree changes (DTCs)
(a) Evolution of library versionsand CVEs
(b) Evolution of CVE density independency treesFigure 7: Evolution of known CVE propagationtrees and analyze corresponding vulnerable paths over time toinvestigate: 1) the overall evolution of known vulnerability prop-agation in dependency trees; 2) the lifecycle of vulnerabilities independency trees; 3) a possible solution to mitigate vulnerabilityaffection in dependency trees based on ourfindings.Due to the exponential increase of dependency trees over time,we conduct our analysis on the validation dataset in Section 4.4.Overall, 53,541 versions are selected after excluding versions withunusual dependency trees by Quartile Variation [40] and those thathave dependencies with unknown release times, and we furthercalculate their dependency trees from release time to the latest.Finally, we obtain 10,906,781 dependency trees in total.5.2.1How does known vulnerability propagation evolve overtime?To investigate the historical vulnerability propagation independency trees, wefirst take snapshots of dependency trees atthe end of each month for all the 53,541 versions. Note that herewe only measure the propagation of known vulnerabilities fromtheir publish time.As presented in Figure 7a, library versions and known CVEsgrow rapidly, which is consistent with existing work [52,85]. Be-sides, we further investigate known vulnerabilities in dependencytrees to analyze the breadth of known vulnerability propagation.Specifically, wefind 19.27% of these versions (10,320) were affectedby known vulnerabilities at release time, while 33.86% of versions(18,127) are affected by known vulnerabilities at the latest time.This indicates that more versions are getting affected by knownvulnerabilities from dependency trees over time.Besides, we analyze the changes of the number of CVEs in indi-vidual dependency trees over time. As shown in Figure 7b, the num-ber of CVEs in dependency trees increases rapidly over time. Specif-ically, we identify 69.76% of these ever affected versions (14,356)have more known vulnerabilities in dependency trees at the time ofsnapshot comparing to release time. In contrast, only 7.4% of them(1,524) are just the opposite. Ourfindings indicate that, along with679Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. Demystifying the Vulnerability Propagation and Its Evolution via Dependency Trees in the NPM Ecosystem ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USAthe discovery of known vulnerabilities and DTCs over time, theimpact of known vulnerabilities is getting larger that known vulner-abilities are not only affecting more library versions (breadth), butalso affecting each version via multiple vulnerable points (depth).Finding-3: Known vulnerabilities are causing a larger impactacross the NPM ecosystem over time. They are not only affect-ing more library versions but also affecting them with morevulnerable points in dependency trees.5.2.2How long do vulnerabilities live in dependency trees?Vulnerabilities in dependency trees can cause enormous impact notonly after published. To investigate the evolution of vulnerabilitypropagation (i.e., lifecycle of vulnerabilities) in dependency trees,we analyze how vulnerability changes in dependency trees.Therefore, we take the time when the root package was affectedby vulnerabilities as the initial time, and further define the livingtime of each CVE in dependency trees as the time interval betweenCVE introduction(thefirst DTC that brings this CVE to the de-pendency tree) andCVE elimination(the last DTC that removesthis CVE from the dependency tree).We have identified 213 CVEs from the 10 million dependencytrees, and quantified 243,448 individual CVE introductions relatedto these CVEs. Besides, to look into the living time of these CVEs independency trees, we have further quantified corresponding CVEeliminations for these introduced CVEs. As a result, 60.05% of them(146,192) are removed from the corresponding dependency treesafterward, with an average living time of 371 days, while the rest ofthem (39.95%) still remain in the latest dependency trees. Specially,wefind that 87.69% of CVE eliminations (128,190) happen beforethese CVEs are published, while only 7.4% of CVE introductionshappen after CVE publish time.Thesefindings reveal that most CVEs (around 93%) are intro-duced to dependency trees before they are discovered, and half ofthe introduced CVEs (60%) in dependency trees are removed viaDTCs. Besides, 88% of such CVE eliminations happen before CVEpublication since most CVEs only get published after the maintain-ers havefixed them. However, the living time of these removedCVEs is still longer than a year, and there is still 40% of CVEs independency trees not removed. This is probably because it indeedrequires a quite long time to handle CVEs (e.g., identifying securitybugs,fixing these bugs, publishing CVEs). However, the remainingCVEs prove that there still exist CVEs that can not be removed byDTCs automatically, and lacks mature mechanisms to warn usersof the CVEs in dependencies of their projects efficiently.Finding-4:xMost of the CVEs (93%) have already been in-troduced to dependency trees before they were discovered,and thefixed versions of these CVEs (87%) were also mostlyreleased before CVE publish.yOnly 60% of CVEs in depen-dency trees are removed automatically by DTCs, and even so,it still takes over one year for each CVE to get removed.5.2.3Why are there still a considerable portion of CVEs notremoved?Actually, most of the CVEs can be removed by DTCsover time, and the remained CVEs are the ones we should try tomitigate. To investigate the possible reasons of the remaining 40%of CVEs and further conclude applicable solutions, we extract allvulnerable paths introduced by these CVEs from dependency treesand classify them intoNot Removed Paths (NRP)(i.e., those re-mained in latest dependency trees) andRemoved Paths (RP)(i.e.,those removed by DTCs). Therefore, 318,652NRPsand 1,669,258RPshave been identified. According to our previousfindings, thelatest versions being vulnerable are probably the common featuresof remained vulnerable points, and the root cause of CVE intro-duction and elimination is the change of dependency trees, whichrequires two preconditions: 1) nodes in the dependency tree havenew versions released; 2) the newly released version satisfies thecorresponding dependency constraint. Therefore, we think thereare probably the two main reasons that may break preconditionsand block CVE eliminations:Outdated Maintenance(i.e., no cleanversion released) andUnsuitable Dependency Constraint(i.e., thereleased clean version does not satisfy the dependency constraint).We also select two typical cases to analyze how they block CVEeliminations: 1)Vulnerable Latest Version, the highest satisfyingversion of vulnerable point is vulnerable; (2)Fixed-Ver. D.C., thedependency constraints arefixed versions instead of ranges. Wemeasure both of them inNRPsandRPs. The result shows that 1)Compared toRPs,NRPscontain more Fixed-Ver. D.C. (53.10% vs.25.67%), and have more Fixed-Ver. D.C. per path (0.87 vs. 0.43). 2)Vulnerable points in 61.54% ofNRPsare Vulnerable Latest Versions,while only 16.12% ofRPsare in such cases. Thesefindings provethat bad practices such asOutdated Maintenance(provider) andUnsuitable Dependency Constraint(consumer) are possibly thereasons that postpone or even block the automatic removal of CVEsby DTCs over time, and more effective and actionable instructionsand solutions should be further derived against them.Finding-5:Outdated Maintenance(provider) andUnsuitableDependency Constraint(consumer) are the main reasons thathinder the automated vulnerability removal in dependencytrees over time. More countermeasures and solutions shouldbe carried out to avoid, monitor, or evenfix these bad practices.5.2.4Example of remediation by avoiding vulnerability in-troduction(DTReme).Outdated MaintenanceandUnsuitable De-pendency Constraintare the main reasons that hinder CVEs frombeing automatically removed, which requires all stakeholdersâ€™ ef-forts to exclude. However, we can remediate vulnerabilities fromanother direction by preventing CVE introductions. Therefore, wefurther propose and implement an application to provide a noveland more precise remediation (DTReme) for dependency trees,based on theDTResolverwe presented in Section 4.2.Theoretically, vulnerable paths could be introduced or removedby DTCs when new versions of libraries in the middle of pathsare released. Therefore, we could use forward checking [60] andbacktracking [54] to explore all possible solutions for single de-pendency path and avoid resolving vulnerable versions, therefore,avoiding the introduction of vulnerabilities. However, since depen-dency paths are not independent and could be influenced by otherexisting nodes in dependencies,fixing single vulnerable path maynot be able to remove the vulnerability thoroughly (i.e., these re-mained vulnerable points in Section 5.2.3). Therefore, we combineNPM dependency resolution and strategies of forward vulnerability680Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Chengwei Liu, Sen Chen, Lingling Fan, Bihuan Chen, Yang Liu, and Xin PengTable 3: Comparison of remediation effects betweennpmaudit fixand our remediation# of vulnerable points in Dependency Trees # of projectsDefDep = 0 198DefDep = AuditDep = RemeDep >0 86 (15)DefDep >AuditDep = RemeDep 69 (1)DefDep >= AuditDep >RemeDep77DefDep >= RemeDep >AuditDep30checking and backtracking to resolve clean dependency trees, thus,provides remediation for entire dependency trees.Notably, we add 1) forward vulnerability checking, when re-solving versions for new coming dependencies (line 13 and 17 inAlgorithm 1), only resolve clean versions for every dependencyrelation; 2) backward installed package tracking, once no clean ver-sion could be resolved, roll back to the resolution for parent nodeandfind alternative versions to avoid cases like no clean version.Therefore, we can traverse all possible solutions exhausitively andfind possible clean dependency trees, and a newpackage-lock.jsonfile can be generated for the entire dependency tree as the remedia-tion solution. Note that the integrity issue of lockfile is handled byssri[26].To prove the effectiveness, we evaluateDTRemewith popularJavaScript repositories from Github by comparing the remediationresult withnpm audit fix, the official dependency auditing tool. Wefirst collect top 1K most stared repositories from Github [8], afterexcluding unsuitable projects (115 have nopackage.json, 239 useyarn, 27 have no dependencies, 159 have dependencies that arenot published in NPM registry), we obtain 460 projects as exper-iment objects to compare withnpm audit fix. Next, we collect 3types of dependencies, default dependencies (DefDep), dependen-cies after auditfix(AuditDep), and dependencies after remediation(RemeDep), as well as vulnerable points in these dependency treesto compare remediation effects. The results are presented in Table 3.Overall, ourDTRemehandles more vulnerabilities thannpmaudit fix. Among the 262 projects that have vulnerabilities in theirdependencies, the performance of our DTReme is better thannpmaudit fixin 77 projects (i.e., the deep gray cell), while only 30 projects(i.e., the light gray cell) are opposite. However, these 30 cases arebecause that sometimesnpm audit fixremediates vulnerabilities byviolating direct dependency constraints [2], and our remediationfollows user-defined dependency constraint strictly. Besides, amongthe 155 projects thatDTRemeandnpm audit fixhave the sameperformance,DTRemereduces more vulnerable paths introducedby these vulnerable points in 16 projects.Finding-6: These results prove thatDTRemehas better per-formance on remediation thannpm audit fix. Back tracing thevulnerable paths to the status before vulnerabilities are intro-duced is an effective way to exclude more vulnerabilities independency trees. Besides, these results also prove that thereare noticeable vulnerabilities unavoidable even though wehave exhausted all possible dependency paths, and mitigatingsuch vulnerabilities requires all stockholders to be responsiblefor their parts and working together.6 DISCUSSION6.1 Lessons Learned by Our StudyWe discuss the actionable solutions from different stakeholders tomitigate the severe situation.For Package Providers. Outdated maintenance is one of the ma-jor reasons for CVEs remaining in dependency trees shown in Sec-tion 5.2.3. Thus, we conclude some tips:xreleasing patch versionssoon when vulnerabilities are found, especially for those majorversions that are not latest by still widely used;ydeprecating orunpublishing the vulnerable versions from the NPM registry;zbeing more responsible to maintain at least one satisfying clean ver-sion for most commonly used dependency constraints, especiallywhen moving to the next major versions;{frequently checkingthe dependencies of their own packages with additional tools (e.g.,third-party auditors), and remediating vulnerable dependencies intime, in case they propagate to transitively affect downstream users.For Package Consumers. We recommend managing dependencytrees with a compromised strategy, using dependency lock withperiodically updating dependency trees to include new features andvulnerabilityfixes that are still compatible. Such a strategy couldtrade offthe conflict with limited risks of containing known CVEsand reduced compatibility issues. Besides, there is a noticeablelack of attention on vulnerabilities in dependencies. A significantportion of the transitively affected packages contain one-step vul-nerable paths as shown in Section 5.1.2. We strongly call on theattention of users on vulnerabilities in dependencies, especiallyin direct dependencies, and more analysis tools (i.e., third-partyauditors) should also be applied during software development andmaintenance.For Third-party Auditors.Most existing software componentanalysis (SCA) tools are heavy (i.e., require real installation or lockfile). Lighter static tools (e.g.,DTReme) can be further included(e.g., in IDEs) and help developers examine their dependencies withmuch higher frequency. Besides, there are more directions basedon ourfindings that could improve the security for usersâ€™ projects.xMore fine-grained remediation.Apart from patching on vulner-able codes, currently, version-based remediations are manipulatingeither vulnerable points (npm audit fix) or direct dependenciesonly (e.g., snykâ€™s remediation [35]), while there are still lots ofCVEs in dependency trees unremediated. As presented byDTReme,simply excluding vulnerable dependencies from path level is ef-ficient to remediate much more vulnerabilities thannpm auditfix, and more recommendations, e.g., even replacing libraries withsimilar functionalities, could be further investigated.yMore accu-rate reachability analysis.Package-level detection is not accurateand could introduce false positives [56]. Although it is a difficulttask [63,67,73], reachability analysis based on call graph [68] canpreciselyfilter out if these vulnerable codes are really called.6.2 Limitations and Threats to ValidityFirst, the vulnerabilities in dependencies may never actually af-fect root packages since these vulnerable functions may never bereached. This can only be further tackled by analyzing vulnerablefunction call paths based on dependency trees and call graphs. Weleave this as our future work. Second, the mapping of CVEs and681Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. Demystifying the Vulnerability Propagation and Its Evolution via Dependency Trees in the NPM Ecosystem ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USAlibrary versions is labeled manually, which may cause data mislabel-ing, and the co-authors have cross-validated the data with existingCVEs to mitigate such threats. Third, we can not distinguish instal-lations that contain missing dependencies, which could make theground truth inaccurate, we only take packages in dependenciesthat are successfully installed as ground truth in validation. Fourth,we ignore versions with over 1k vulnerable paths when analyz-ing vulnerability propagation due to excessively high computationcosts. Overall, such versions only account for 2.01%, which can onlycause limited bias to our results.7 RELATED WORKVulnerability Analysis via Dependency.Lauinger et al. [65]checked 133k websites and found 37% websites use at least oneJavaScript library with a known vulnerability. Pfretzschner et al. [70]discussed four typical dependency-based attacks. Ohm et al [69] in-vestigated the security attacks via malicious packages from supplychain. Prana et al [71] observed the vulnerabilities from dependen-cies of selected projects in Java, Python and Ruby by Veracode [10].Alfade et al [39] measured the threats of vulnerabilities by theirlifecycle. Zerouali et al. [79] reported that the presence of outdatedNPM packages increases the risk of potential vulnerabilities. Gko-rtzis et al [57] found a strong correlation between a higher numberof dependencies and vulnerabilities. Javanjafari et al [61] inves-tigated the dependency smells that could cause negative impactin JavaScript projects. Decan et al. [52] conducted an empiricalstudy by leveraging the direct dependencies of JavaScript libraries.Their impact analysis is conducted only with direct dependentswhich are upstream traced with only one step, and did not considerthe dependencies as integrity to analyze the vulnerability impactvia transitive dependencies. Zerouali et al. [80] investigated vul-nerability impact via transitive dependencies, but they reasonedsuch impact via dependency reach, and they are more focusing oncomparison between packages and projects on general properties,i.e., dependency level. Zimmermann et al. [85] found the individualpackages could impact large parts of the NPM ecosystem, and theyanalyzed from the perspective of maintainer accounts that couldbe used to inject malicious code. However, their dependencies arealso derived from dependency reachability reasoning. Most exist-ing work only conducted dependency-based vulnerability impactanalysis on the reachability of library dependencies or limited tran-sitive dependency steps, while our study is conducted based ondependency trees with high accuracy at a large scale.Some work focused on improving security based on dependency.Cox et al. [47] proposed a metric-based method to decide if thedependencies should be updated. Van et al. [75] proposed Node-Sentry to identify the vulnerable libraries by using rules for secureintegration of JavaScript libraries.In summary, these work focused on mitigating vulnerabilitiesbased on dependencies that are already installed, while our ap-proach focuses on identifying vulnerabilities and vulnerable pathbefore installation. Besides, we can also include recommendationson possible remediation for identified vulnerabilities viaDTReme.Ecosystem Analysis.In most cases, researchers analyzed the de-pendency relations in various languages to understand the ecosys-tem status and dependency evolution. Wittern et al. [77] investi-gated the NPM ecosystem from several aspects (e.g., library de-pendency, download metrics). Decan et al. [49,50,53] conductedcomparison studies of different ecosystems, and they [48] alsorecommend recommend semantic versions by the wisdom of thecrowd. Similarly, Kikas et al. [62] analyzed the dependency net-work and evolution of three ecosystems (i.e., NPM, Ruby, andRust). Besides, some existing empirical studies further analyzeddifferent aspects of the ecosystem from various entry points. [66]used topological data analysis to investigate the NPM ecosystem.[38,42,45,64] investigated the prevalence and impact of trivialpackages. [44,51,74,78,81] investigate the technical lags of adopt-ing updates in several ecosystems. [82] compares different metricson popularity, and [55] predicts the popularity change based on de-pendency supply chain. [37] compares the dependency resolution ofdifferent package managers. [46] focus on packages with the sameday release. [72] investigates the problem of license violation. [41]inspects the packages that are usually co-occur dependencies. [43]investigated the slow patching process within the NPM ecosystem.Compared with our study, most of the existing work on ecosys-tem analysis only focused on a limited group of study subjects andmore focused on general statistics of entire ecosystems withoutprecisely considering the accurate dependency reachability. Instead,we have conducted a large-scale study on a full set of packages inthe NPM ecosystem, and have analyzed on both ecosystem andpackage (version) levels with accurate dependency trees considered.8 CONCLUSIONIn this paper, we carry out a large-scale empirical study on thevulnerability propagation and propagation evolution by leveraginga complete and preciseDVGraph, and a novel algorithm that wefirstly propose to statically and precisely resolves accurate depen-dency treesDVResolverat any time for each package. Our studyunveils many usefulfindings on the NPM ecosystem. Based on it,we proposeDVRemeas an example to mitigate vulnerability impact,and we also highlight some implications to shed light on the severesecurity threats in NPM ecosystem and further invoke actionablesolutions for different stakeholders to mitigate such security risks.ACKNOWLEDGMENTSThis research was partially supported by the National NaturalScience Foundation of China (Grant No. 62102284), the NationalResearch Foundation, Singapore under its the AI Singapore Pro-gramme (AISG2-RP-2020-019), the National Research Foundation,Prime Ministers Office, Singapore under its National CybersecurityR&D Program (Award No. NRF2018NCR-NCR005-0001), NRF Inves-tigatorship NRFI06-2020-0022-0001, the National Research Foun-dation through its National Satellite of Excellence in TrustworthySoftware Systems (NSOE-TSS) project under the National Cyberse-curity R&D (NCR) Grant award no. NRF2018NCR-NSOE003-0001,the Ministry of Education, Singapore under its Academic ResearchFund Tier 3 (MOET32020-0004). Any opinions,findings and con-clusions or recommendations expressed in this material are thoseof the author(s) and do not reflect the views of the Ministry ofEducation, Singapore.682Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Chengwei Liu, Sen Chen, Lingling Fan, Bihuan Chen, Yang Liu, and Xin PengREFERENCES[1] 2021.BlackDuck. https://www.blackducksoftware.com/[2]2021.[BUG] "npm auditfix" replaces direct dependencies without consideringsemantic version compatible. https://github.com/npm/cli/issues/2478[3]2021.bundledDependencies. https://docs.npmjs.com/files/package.json#bundleddependencies[4] 2021.Common Vulnerabilities and Exposures. https://cve.mitre.org/[5] 2021.Contrast Security. https://www.contrastsecurity.com/[6]2021.Dependency Resolution Rules. http://npm.github.io/npm-like-im-5/npm3/dependency-resolution.html[7]2021.How MPM3 Works. https://npm.github.io/how-npm-works-docs/npm3/how-npm3-works.html[8]2021.Introducing new ways to keep your code secure. https://github.blog/2019-05-23-introducing-new-ways-to-keep-your-code-secure[9] 2021.Ladash vulnerability. https://nvd.nist.gov/vuln/detail/CVE-2018-16487[10]2021.Manage Your Entire Application Security Program in a Single Platform.https://www.veracode.com/[11] 2021.National Vulnerability Database (NVD). https://nvd.nist.gov/[12] 2021.Neo4j. https://neo4j.com/[13] 2021.NPM - Build amazing things. https://www.npmjs.com/[14] 2021.npm - Libraries.io. https://libraries.io/npm[15] 2021.npm-audit. https://docs.npmjs.com/cli/v6/commands/npm-audit[16] 2021.NPM-install. https://docs.npmjs.com/cli/install#algorithm[17] 2021.npm-install. https://docs.npmjs.com/cli/v6/commands/npm-install[18]2021.NPM INSTALL DRIVES YOU CRAZY? YARN AND CHILL!https://geeklearning.io/npm-install-drives-you-crazy-yarn-and-chill/[19]2021.NPM install got different versions according to node-semver.https://stackoverflow.com/questions/60350847/npm-install-got-different-versions-according-to-node-semver[20] 2021.npm-ls. https://docs.npmjs.com/cli/ls[21] 2021.npm-package-arg. https://www.npmjs.com/package/npm-package-arg[22]2021.NPM Package Metadata. https://github.com/npm/registry/blob/master/docs/responses/package-metadata.md[23] 2021.npm-package.json. https://docs.npmjs.com/files/package.json[24] 2021.npm-remote-ls. https://www.npmjs.com/package/npm-remote-ls[25] 2021.npm-unpublish. https://docs.npmjs.com/cli/unpublish[26] 2021.npm/ssri. https://github.com/npm/ssri[27] 2021.NVD Data Feeds. https://nvd.nist.gov/vuln/data-feeds/[28]2021.Semantic Versioning. https://docs.npmjs.com/about-semantic-versioning[29] 2021.Semantic Versioning 2.0.0. https://semver.org/[30] 2021.Snyk. https://snyk.io/[31]2021.Snyk research team discovers severe prototype pollution security vulnerabili-ties affecting all versions of lodash. https://snyk.io/blog/snyk-research-team-discovers-severe-prototype-pollution-security-vulnerabilities-affecting-all-versions-of-lodash/[32] 2021.Snyk Vulnerability Database. https://snyk.io/vuln[33]2021.Software Composition Analysis (SCA). https://resources.whitesourcesoftware.com/blog-whitesource/sca-software-composition-analysis[34]2021.SourceClear Vulnerability Database. https://www.sourceclear.com/vulnerability-database[35]2021.Upgrading package versions tofix. https://support.snyk.io/hc/en-us/articles/360005993658-Upgrading-package-versions-to-fix[36]2021.Why does node semver use â€œlatestâ€ in dist-tags as max version for satisfiedversions?https://stackoverflow.com/questions/60335207/[37]Pietro Abate, Roberto Di Cosmo, Georgios Gousios, and Stefano Zacchiroli. 2020.Dependency solving is still hard, but we are getting better at it. In2020 IEEE27th International Conference on Software Analysis, Evolution and Reengineering(SANER). IEEE, 547â€“551.[38]Rabe Abdalkareem, Olivier Nourry, Sultan Wehaibi, Suhaib Mujahid, and EmadShihab. 2017. Why do developers use trivial packages? An empirical case studyon NPM. InProceedings of the 2017 11th Joint Meeting on Foundations of SoftwareEngineering. 385â€“395.[39] Mahmoud Alfadel, Diego Elias Costa, Mouafak Mokhallalati, Emad Shihab, andBram Adams. 2020. On the Threat of npm Vulnerable Dependencies in Node. jsApplications.arXiv preprint arXiv:2009.09019(2020).[40]Douglas G Bonett. 2006. Confidence interval for a coefficient of quartile variation.Computational statistics & data analysis(2006), 2953â€“2957.[41]Kyriakos C Chatzidimitriou, Michail D Papamichail, Themistoklis Diamantopou-los, Napoleon-Christos I Oikonomou, and Andreas L Symeonidis. 2019. npmPackages as Ingredients: A Recipe-based Approach.. InICSOFT. 544â€“551.[42]Xiaowei Chen, Rabe Abdalkareem, Suhaib Mujahid, Emad Shihab, and Xin Xia.2021. Helping or not helping? Why and how trivial packages impact the npmecosystem.Empirical Software Engineering26, 2 (2021), 1â€“24.[43]Bodin Chinthanet, Raula Gaikovina Kula, Takashi Ishio, Akinori Ihara, andKenichi Matsumoto. 2019. On The Lag of Library Vulnerability Updates: AnInvestigation into the Repackage and Delivery of Security Fixes Within The NPMJavaScript Ecosystem.arXiv preprint arXiv:1907.03407(2019).[44]Bodin Chinthanet, Raula Gaikovina Kula, Shane McIntosh, Takashi Ishio, AkinoriIhara, and Kenichi Matsumoto. 2021. Lags in the release, adoption, and propa-gation of npm vulnerabilityfixes.Empirical Software Engineering26, 3 (2021),1â€“28.[45]Md Atique Reza Chowdhury, Rabe Abdalkareem, Emad Shihab, and Bram Adams.2021. On the Untriviality of Trivial Packages: An Empirical Study of npmJavaScript Packages.IEEE Transactions on Software Engineering(2021).[46]Filipe R Cogo, Gustavo A Oliva, Cor-Paul Bezemer, and Ahmed E Hassan. 2021. Anempirical study of same-day releases of popular packages in the npm ecosystem.Empirical Software Engineering26, 5 (2021), 1â€“42.[47]JoÃ«l Cox, Eric Bouwers, Marko Van Eekelen, and Joost Visser. 2015. Measur-ing dependency freshness in software systems. In2015 IEEE/ACM 37th IEEEInternational Conference on Software Engineering, Vol. 2. IEEE, 109â€“118.[48]Alexandre Decan and Tom Mens. 2019. What do package dependencies tell usabout semantic versioning?IEEE Transactions on Software Engineering(2019).[49]Alexandre Decan, Tom Mens, and Maelick Claes. 2016. On the topology ofpackage dependency networks: A comparison of three programming languageecosystems. InProccedings of the 10th European Conference on Software Architec-ture Workshops. ACM.[50]A. Decan, T. Mens, and M. Claes. 2017. An empirical comparison of dependencyissues in OSS packaging ecosystems. In2017 IEEE 24th International Conference onSoftware Analysis, Evolution and Reengineering (SANER). 2â€“12. https://doi.org/10.1109/SANER.2017.7884604[51]Alexandre Decan, Tom Mens, and Eleni Constantinou. 2018. On the evolution oftechnical lag in the npm package dependency network. In2018 IEEE InternationalConference on Software Maintenance and Evolution (ICSME). IEEE, 404â€“414.[52]Alexandre Decan, Tom Mens, and Eleni Constantinou. 2018. On the impact ofsecurity vulnerabilities in the NPM package dependency network. InProceedingsof the 15th International Conference on Mining Software Repositories. 181â€“191.[53]Alexandre Decan, Tom Mens, and Philippe Grosjean. 2019. An empirical compar-ison of dependency network evolution in seven software packaging ecosystems.Empirical Software Engineering24, 1 (2019), 381â€“416.[54]Rina Dechter and Daniel Frost. 1998. Backtracking Algorithms for ConstraintSatisfaction ProblemsÃ¢â‚¬â€a Tutorial Survey.Information-and Computer ScienceTechnical Report56 (1998).[55]Tapajit Dey and Audris Mockus. 2018. Are software dependency supply chainmetrics useful in predicting change of popularity of npm packages?. InProceedingsof the 14th International Conference on Predictive Models and Data Analytics inSoftware Engineering. 66â€“69.[56]R. Elizalde Zapata, R. G. Kula, B. Chinthanet, T. Ishio, K. Matsumoto, and A. Ihara.2018. Towards Smoother Library Migrations: A Look at Vulnerable DependencyMigrations at Function Level for npm JavaScript Packages. In2018 IEEE Inter-national Conference on Software Maintenance and Evolution (ICSME). 559â€“563.https://doi.org/10.1109/ICSME.2018.00067[57]Antonios Gkortzis, Daniel Feitosa, and Diomidis Spinellis. 2021. Software reusecuts both ways: An empirical analysis of its relationship with security vulnera-bilities.Journal of Systems and Software172 (2021), 110653.[58]Hao Guo, Sen Chen, Zhenchang Xing, Xiaohong Li, Yude Bai, and XiaohongLi. 2021. Detecting and Augmenting Missing Key Aspects in Vulnerability De-scriptions.ACM Transactions on Software Engineering and Methodology (TOSEM)(2021).[59]Hao Guo, Zhenchang Xing, Sen Chen, Xiaohong Li, Yude Bai, and Hu Zhang.2021. Key aspects augmentation of vulnerability description based on multiplesecurity databases. In2021 IEEE 45th Annual Computers, Software, and ApplicationsConference (COMPSAC). IEEE, 1020â€“1025.[60]Robert M Haralick and Gordon L Elliott. 1980. Increasing tree search efficiencyfor constraint satisfaction problems.Artificial intelligence14, 3 (1980), 263â€“313.[61]Abbas Javanjafari, Diego Elias Costa, Rabe Abdalkareem, Emad Shihab, and Niko-laos Tsantalis. 2021. Dependency Smells in JavaScript Projects.IEEE Transactionson Software Engineering(2021).[62]Riivo Kikas, Georgios Gousios, Marlon Dumas, and Dietmar Pfahl. 2017. Struc-ture and evolution of package dependency networks. InProceedings of the 14thInternational Conference on Mining Software Repositories. IEEE press, 102â€“112.[63]Erik Krogh Kristensen and Anders MÃ¸ller. 2019. Reasonably-most-general clientsfor JavaScript library analysis. In2019 IEEE/ACM 41st International Conference onSoftware Engineering (ICSE). IEEE, 83â€“93.[64]Raula Gaikovina Kula, Ali Ouni, Daniel M German, and Katsuro Inoue. 2017.On the Impact of Micro-Packages: An Empirical Study of the NPM JavaScriptEcosystem.arXiv preprint arXiv:1709.04638(2017).[65]Tobias Lauinger, Abdelberi Chaabane, Sajjad Arshad, William Robertson, ChristoWilson, and Engin Kirda. 2018. Thou shalt not depend on me: Analysing theuse of outdated JavaScript libraries on the web.arXiv preprint arXiv:1811.00918(2018).[66]Nuttapon Lertwittayatrai, Raula Gaikovina Kula, Saya Onoue, Hideaki Hata,Arnon Rungsawang, Pattara Leelaprute, and Kenichi Matsumoto. 2017. Extractinginsights from the topology of the JavaScript package ecosystem. In2017 24thAsia-Pacific Software Engineering Conference (APSEC). IEEE, 298â€“307.683Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. Demystifying the Vulnerability Propagation and Its Evolution via Dependency Trees in the NPM Ecosystem ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA[67]Anders MÃ¸ller, Benjamin Barslev Nielsen, and Martin Toldam Torp. 2020. De-tecting locations in JavaScript programs affected by breaking library changes.Proceedings of the ACM on Programming Languages4, OOPSLA (2020), 1â€“25.[68]Benjamin Barslev Nielsen, Martin Toldam Torp, and Anders MÃ¸ller. 2021. Mod-ular call graph construction for security scanning of Node. js applications. InProceedings of the 30th ACM SIGSOFT International Symposium on Software Testingand Analysis. 29â€“41.[69]Marc Ohm, Arnold Sykosch, and Michael Meier. 2020. Towards detection ofsoftware supply chain attacks by forensic artifacts. InProceedings of the 15thinternational conference on availability, reliability and security. 1â€“6.[70] Brian Pfretzschner and Lotfiben Othmane. 2017. Identification of Dependency-Based Attacks on Node.Js. InProceedings of the 12th International Conferenceon Availability, Reliability and Security(Reggio Calabria, Italy)(ARES â€™17). As-sociation for Computing Machinery, New York, NY, USA, Article 68, 6 pages.https://doi.org/10.1145/3098954.3120928[71]Gede Artha Azriadi Prana, Abhishek Sharma, Lwin Khin Shar, Darius Foo, An-drew E Santosa, Asankhaya Sharma, and David Lo. 2021. Out of sight, out ofmind? How vulnerable dependencies affect open-source projects.EmpiricalSoftware Engineering26, 4 (2021), 1â€“34.[72]Shi Qiu, Daniel M German, and Katsuro Inoue. 2021. Empirical Study onDependency-related License Violation in the JavaScript Package Ecosystem.Journal of Information Processing29 (2021), 296â€“304.[73]Benno Stein, Benjamin Barslev Nielsen, Bor-Yuh Evan Chang, and Anders MÃ¸ller.2019. Static analysis with demand-driven value refinement.Proceedings of theACM on Programming Languages3, OOPSLA (2019), 1â€“29.[74]Jacob Stringer, Amjed Tahir, Kelly Blincoe, and Jens Dietrich. 2020. Technical Lagof Dependencies in Major Package Managers. In2020 27th Asia-Pacific SoftwareEngineering Conference (APSEC). IEEE, 228â€“237.[75]Neline van Ginkel, Willem De Groef, Fabio Massacci, and Frank Piessens. 2019. Aserver-side JavaScript security architecture for secure integration of third-partylibraries.Security and Communication Networks2019 (2019).[76]James Williams and Anand Dabirsiaghi. 2012. The unfortunate reality of insecurelibraries. Aspect Security.Inc., March(2012).[77]Erik Wittern, Philippe Suter, and Shriram Rajagopalan. 2016. A look at the dynam-ics of the JavaScript package ecosystem. InIEEE/ACM 13th Working Conferenceon Mining Software Repositories (MSR). IEEE, 351â€“361.[78]Ahmed Zerouali, Eleni Constantinou, Tom Mens, Gregorio Robles, and JesÃºsGonzÃ¡lez-Barahona. 2018. An empirical analysis of technical lag in npm packagedependencies. InInternational Conference on Software Reuse. Springer, 95â€“110.[79]Ahmed Zerouali, Valerio Cosentino, Tom Mens, Gregorio Robles, and Jesus MGonzalez-Barahona. 2019. On the impact of outdated and vulnerable JavaScriptpackages in docker images. In2019 IEEE 26th International Conference on SoftwareAnalysis, Evolution and Reengineering (SANER). IEEE, 619â€“623.[80]Ahmed Zerouali, Tom Mens, Alexandre Decan, and Coen De Roover. 2021. Onthe Impact of Security Vulnerabilities in the npm and RubyGems DependencyNetworks.arXiv preprint arXiv:2106.06747(2021).[81]Ahmed Zerouali, Tom Mens, Jesus Gonzalez-Barahona, Alexandre Decan, EleniConstantinou, and Gregorio Robles. 2019. A formal framework for measuringtechnical lag in component repositories and its application to npm.Journal ofSoftware: Evolution and Process31, 8 (2019), e2157.[82]Ahmed Zerouali, Tom Mens, Gregorio Robles, and Jesus M Gonzalez-Barahona.2019. On the diversity of software package popularity metrics: An empiricalstudy of npm. In2019 IEEE 26th International Conference on Software Analysis,Evolution and Reengineering (SANER). IEEE, 589â€“593.[83]Xian Zhan, Lingling Fan, Sen Chen, Feng Wu, Tianming Liu, Xiapu Luo, andYang Liu. 2021. Atvhunter: Reliable version detection of third-party librariesfor vulnerability identification in Android applications. In2021 IEEE/ACM 43rdInternational Conference on Software Engineering (ICSE). IEEE, 1695â€“1707.[84]Xian Zhan, Lingling Fan, Tianming Liu, Sen Chen, Li Li, Haoyu Wang, YifeiXu, Xiapu Luo, and Yang Liu. 2020. Automated third-party library detection forAndroid applications: Are we there yet?. In2020 35th IEEE/ACM InternationalConference on Automated Software Engineering (ASE). IEEE, 919â€“930.[85]Markus Zimmermann, Cristian-Alexandru Staicu, Cam Tenny, and Michael Pradel.2019. Small world with high risks: A study of security threats in the npmecosystem. In28th USENIX Security Symposium (USENIX Security 19). 995â€“1010.
684Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:12:57 UTC from IEEE Xplore.  Restrictions apply. 