Context Debloating for Object-Sensitive Pointer Analysis
Dongjie He, Jingbo Lu, and Jingling Xue
UNSW Sydney
Abstract —We introduce a new approach, C ONCH , for de-
bloating contexts for all the object-sensitive pointer analysis
algorithms developed for object-oriented languages, where thecalling contexts of a method are distinguished by its receiverobjects. Our key insight is to approximate a recently proposed setof two necessary conditions for an object to be context-sensitive,i.e., context-dependent (whose precise veriﬁcation is undecidable)
with a set of three linearly veriﬁable conditions (in terms ofthe number of statements in the program) that are almostalways necessary for real-world object-oriented applications,based on three key observations regarding context-dependabilityfor their objects used. To create a practical implementation,we introduce a new IFDS-based algorithm for reasoning aboutobject reachability in a program. By debloating contexts for tworepresentative object-sensitive pointer analyses applied to a set of12 representative Java programs, C
ONCH can speed up the two
baselines together substantially (3.1x on average with a maximumof 15.9x) and analyze 7 more programs scalably, but at only anegligible loss of precision (less than 0.1%).
Index T erms—Pointer Analysis, Object Sensitivity, Debloating
I. I NTRODUCTION
Many software engineering tasks such as call graph con-
struction [1], [2], program slicing [3], [4], program under-
standing [5], and bug detection [6]–[10] often require precisepoints-to/alias information. The quality of a pointer analysisdirectly determines the effectiveness and usefulness of thetools developed for accomplishing these tasks.
For object-oriented languages, object-sensitive pointer anal-
ysis, which distinguishes the (calling) contexts of a methodby its receiver objects, is regarded as providing highlyuseful precision [11]–[15] and thus widely adopted inseveral pointer analysis frameworks for Java, such as
S
OOT [16], D OOP [17] and W ALA [18]. Under k-object-
sensitivity [19], [20], denoted kOBJ , a context used for an-
alyzing a method mis represented by a sequence of kcontext
elements (under klimiting), [o1,...,o k], where o1is the
receiver object of mandoiis the receiver object of a method
in which oi−1is allocated [11]. So oiis an allocator ofoi−1.
Currently, kOBJ does not scale well for reasonably large
programs when k/greaterorequalslant3and is often time-consuming when it
is scalable [11]–[14]. As kincreases, the number of contexts
analyzed for a method often blows up exponentially withoutimproving precision much. To alleviate this issue, severalrecent research efforts [15], [21]–[24] focus on selectivecontext-sensitivity, which ﬁrst conducts a pre-analysis to theprogram and then instructs k
OBJ to apply context-sensitivity
only to some of its methods selected. A number of attemptshave been made, including client-speciﬁc machine learningtechniques [21] (guided by improving the precision of a givenclient, e.g., may-fail-casting) and general-purpose techniques,such as user-supplied hints [23], [24], pattern matching [22],and CFL (Context-Free Language) reachability [15], [25],[26]. Despite some performance improvements obtained (atno or a noticeable loss of precision), these existing selectivecontext-sensitive pointer analysis algorithms still suffer froman unreasonable explosion of contexts.
We introduce a new approach, C
ONCH , for debloating
contexts for all object-sensitive pointer analysis algorithms,including k
OBJ and its various incarnations for performing se-
lective context-sensitivity, by boosting their performance sig-niﬁcantly with negligible loss in precision. In object-orientedprograms, we observe that a large number of objects that areallocated in a method are used independently of its callingcontexts. Distinguishing these objects context-sensitively, asoften done in the past, will serve to increase only the numberof calling contexts analyzed for the methods invoked on theseobjects (as receivers) without any precision improvement.
Our key insight is to approximate a recently proposed set of
two necessary conditions for an object to be context-sensitive,i.e., context-dependent [15], [25] (whose precise veriﬁcation
is undecidable [27]) with a set of three linearly veriﬁable nec-essary conditions (in terms of the number of statements in theprogram), based on three key observations regarding context-dependability for the objects used practically in real-worldobject-oriented programs. To create a practical implementationfor C
ONCH , we have developed a new lightweight IFDS-based
algorithm [28] for verifying these conditions (governing objectreachability). By allowing only context-dependent objects tobe handled context-sensitively, C
ONCH can signiﬁcantly limit
the explosive growth of the number of contexts and achievesubstantially improved efﬁciency and scalability.
We have implemented C
ONCH on top of the S OOT frame-
work [16] and evaluated it with 12 popular Java benchmarksand applications. Compared with k
OBJ [20] and Z IPPER [22]
(a representative of selective context-sensitive pointer analyses[15], [22], [24]), C
ONCH can speed up the two baselines
together substantially (3.1x on average with a maximum of15.9x) and analyze 7 more programs scalably, but at no lossof precision for 10 programs and only a negligible loss ofprecision (less than 0.1%) for the remaining two.
In summary, this paper makes the following contributions:
•We present context debloating, a new approach for accel-erating all object-sensitive pointer analysis algorithms.
•We give a set of three mostly necesssary conditionsfor determining an object’s context-dependability andpropose a new lightweight IFDS-based algorithm for ver-ifying them on the P AG representation [1] of a program.
•We have implemented C ONCH in the S OOT framework
and will release it soon as an open-source tool.
792021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000182021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678880
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
1void main ( ) {
2B b 1 = new B();// B1
3 b1.foo();
4B b 2 = new B();// B2
5 b2.bar();
6}
7class A{
8 Object f;
9 void setF ( Object o){this.f = o ; }
10 Object getF ( ){return this.f ; }
11}
12class B{
13 A g ;14 B ( ) {15 this.g = new A();// A
16}
17 void f o o(){
18 Object o1 = new Object ();// O1
19 A a1 = this.g ;
20 a1.setF ( o1 ) ;
21 Object v1 = a1.getF();
22}
23 void b a r(){
24 Object o2 = new Object ();// O2
25 A a2 = this.g ;
26 a2.setF ( o2 ) ;27 Object v2 = a2.getF();
28}}
Fig. 1: An example for illustrating object sensitivity.
(O1, [])
(o, [])
(A.f, [])
(v1, [])(O2, [])
(v2, [])(O1, [])
(o, [])
(A.f, [])
(v1, [])(O2, [])
(v2, [])
(a) Andersen(O1, [B1])
(o, [A,B1])
(A.f, [B1])
(v1, [B1])(O2, [B2])
(A.f, [B2])
(v2, [B2])(O1, [B1])
(o, [A,B1])
(A.f, [B1])
(v1, [B1])(O2, [B2])
(A.f, [B2])
(v2, [B2])
(b) 2OBJ(o, [A,B2])
Fig. 2: Computing the points-to information for v1 andv2 in
Figure 1 by applying Andersen’s analysis and 2OBJ .
•We have extensively evaluated the effectiveness of
CONCH (using several popular metrics) and demonstrated
its practical signiﬁcance for real-world programs.
The rest of this paper is organized as follows. Section II
motivates our approach. Section III gives a version of kOBJ
that supports context debloating. Section IV presents our
CONCH approach. In Section V, we evaluate the effectiveness
of C ONCH in terms of context debloating. Section VI discusses
the related work. Finally, Section VII concludes the paper.
II. M OTIV A TION
We ﬁrst review object sensitivity as a context abstraction
(Section II-A). We then examine the limitations of existing
object-sensitive pointer analysis algorithms (Section II-B). Fi-nally, we motivate context debloating, by describing the basicidea behind this new approach, examining the main challengesfaced in realizing it efﬁciently and effectively, and discussingour solution for addressing these challenges (Section II-C).
A. Object Sensitivity
We brieﬂy review object-sensitive pointer analysis with
an example given in Figure 1. In lines 7-11, we deﬁne
class A, which has a ﬁeld fand its corresponding set-
ter and getter methods. In lines 12-28, we deﬁne class B,
which has a ﬁeld g, a constructor, and two regular methods
(foo() and bar()). In foo() (bar()) of class B, an instance of
java.lang.Object, O1 (O2) is created. Later, O1 (O2)
is ﬁrstly stored into A.f and then loaded into v1 (v2) via
thesetF() andgetF() methods, respectively. In main(),
two instances of B,B1 andB2, are created and used as the
receivers for invoking foo() and bar(), respectively.
In a context-insensitive Andersen’s analysis [1], [29], every
method is analyzed only once under an empty context, [ ]. Let
pts(v)denote the points-to set of a variable vthus computed.As illustrated in Figure 2(a), O1 andO2 are merged at o(line
9) and will later ﬂow spuriously to v2 andv1, respectively.
Hence, we have pts(v1)= pts(v2)={O1,O2}.
In ak-object-sensitive pointer analysis (k OBJ ), denoted
A, the calling contexts of a method are distinguished byits receiver objects, with each being abstracted by its k-
most-recent allocation sites [19], [20]. We write pts
A(v,c)
to represent the points-to set of a variable vthus computed
under a context c. In the case of 2OBJ (i.e.,kOBJ withk=2 ),
setF() (getF()) will be analyzed differently for its two
invocations in lines 20 and 26 (lines 21 and 27) under twodifferent contexts, [A,B1] and[A,B2] . As a result, O1 (created
under context [B1]) and O2 (created under context [B2]) will
ﬂow along two separate paths to v1 andv2, respectively
(Figure 2(b)). Hence, pts
2OBJ(v1,[B1]) ={(O1,[B1])} and
pts2OBJ(v2,[B2]) ={(O2,[B2])}, without the spurious points-
to information generated by Andersen’s analysis.
In general, when a method mis analyzed under a context
[o1,...,o k],o1is a receiver object of m, andoiis a receiver
object of a method where oi−1is allocated, and thus known as
theallocator (object) ofoi−1, where 1<i/lessorequalslantk. Thus, any ob-
jecto0that is allocated in mis identiﬁed as (o0,[o1,...,o k−1]),
where [o1,...,o k−1]is known as the heap context ofo0.
B. Limitations of Existing Algorithms
We now use an example in Figure 3, which reuses class
Bfrom Figure 1, to reveal the limitations of kOBJ [19], [20]
and existing approaches for selective context-sensitivity [15],[21]–[24] in analyzing real-world programs.
In lines 29-51, we deﬁne class C with a total of 2
n+1
methods. In lines 30-38, where 0/lessorequalslantj<2i−1(2i−1/lessorequalslantj<2i),
a method, foo i,j() (bar i,j()), is deﬁned, in which an object,
Ci,j, is created and used as the receiver to invoke fooi−1,j
2()
(bari−1,j
2()). In lines 39-51, we deﬁne foo 0,0() (bar 0,0()),
where an instance of B(deﬁned in Figure 1), B3 (B4), is
created and used to invoke foo() (bar()). In main()
(lines 53-65), 2ninstances of C, denoted as C n,j, where
0/lessorequalslantj< 2n, are created and used as the receivers to call
foon−1,j
2() whenj<2n−1and barn−1,j
2() whenj≥2n−1.
Figure 4 depicts the OAG (Object Allocation Graph) [30],
where an edge O→O/primesigniﬁes that O is an alloca-
tor ofO/prime.F o rk OBJ [11], [20], the contexts of a method
can be directly read off from this graph by starting fromits receiver object and then retrieving the next k−1ob-
jects backwards. For example, the contexts of foo() and
bar() are{[B3, C
1,j
2k−2,···,Ck−2,j
2,Ck−1,j]|0/lessorequalslantj<
2k−2}and{[B4, C1,j
2k−2,···,Ck−2,j
2,Ck−1,j]|2k−2/lessorequalslant
j< 2k−1}, respectively. Let Cj(X)=[ A,X, C1,j
2k−3,···,
Ck−3,j
2,Ck−2,j]. Both setF() andgetF() share the contexts
in{Cj(B3)|0/lessorequalslantj<2k−3}∪{Cj(B4)|2k−3/lessorequalslantj<2k−2}.
In practice, the number of contexts for analyzing a method
can be exponential. For example, there are a total of 2k−2con-
texts for foo(), bar(), setF() andgetF().A s kincreases,
such a method becomes exponentially expensive to analyze,consuming more and more memory and analysis time.
8029class C{
30 void fooi,j (){//j< 2i−1
31 C c i,j =new C();// C i,j
32 c i,j . fooi−1,j
2();
33}
34 D bar i,j (D d ){//2i−1≤j
35 C c i,j =new C();// C i,j
36 c i,j . bari−1,j
2(d);
37 return d;
38}
39 void foo0,0 (){
40 B b3 = new B();// B3
4 1 b 3.f o o();
42}
43 D bar 0,0 (D d ){
44 B b4 = new B();// B44 9 b 4.b a r();
50 return d;
51}}
52class D{}
53void main ( ){
54 D d = new D;// D
55 C c = new C();// C n,0
56 c . foo n−1,0 ();
57 . . .58 C c = new C();// C
n,2 n−1−1
59 c . foon−1,2 n−2−1();
60 C c = new C(); // Cn,2 n−1
61 c . barn−1,2 n−2 (d);
62 . . .63 C c = new C();// C
n,2 n−1
64 c . barn−1,2 n−1−1(d);
65}
Fig. 3: An example for motivating C ONCH (1/lessorequalslanti/lessorequalslantnand
0/lessorequalslantj<2i), reusing class Bdeﬁned in lines 12-28 in Figure 1.
Cn,0................ Cn,2n−1
......
Ci,0......
...Ci,j
...... C
i,2i−1
...
C1,1 C1,0
B3 B4
O1AD O2
Fig. 4: The object allocation graph (OAG) for Figure 3, where
only the two edges in red will remain after context debloating.
Existing approaches for selective context-sensitivity [15],
[21]–[24] can improve the efﬁciency and scalability of kOBJ .
For example, Z IPPER [22], which does not preserve the preci-
sion ofkOBJ , will select main(), B(), foo(), bar(), and
foo i,j() (where j<ri
2) to be analyzed context-insensitively.
However, the context explosion problem still remains forbar
i,j(),setF() andgetF().E AGLE [15], [25], which
preserves the precision of kOBJ , is worse as it will also analyze
B(), foo() andbar() partially context-sensitively.
C. CONCH : Our Context Debloating Approach
1) Basic Idea: We offer a new approach to mitigating
the context explosion problem. Our approach, named C ONCH
(CONtext-dependability CHecking), aims to debloat contextsduring the pointer analysis and thus complements the priorwork on selective context-sensitivity. C
ONCH can be plugged
into all object-sensitive analysis algorithms, including kOBJ
and its various incarnations for supporting selective context-sensitivity [15], [21]–[24], to boost their performance signif-icantly with negligible loss in precision. For our motivatingexample, only Ais context-dependent. Handling any of the
other objects context-sensitively will cost an exponential in-crease in analysis time without any precision beneﬁt.
To illustrate context debloating using the OAG in Figure 4,
we will remove all the allocators of a context-independentobject so that the exponential growth of contexts for the objectis avoided completely. Under C
ONCH , only the two edges in
red will remain, as Ais the only context-dependent object
in the example. This implies that only setF() and getF()
will be analyzed context-sensitively under [A, B3] and[A, B4]. All the other methods will be analyzed context-insensitively. For this example, debloating contexts can helpk
OBJ and its variants reduce their analysis times and memory
consumption signiﬁcantly without losing any precision.
LetAbe any existing object-sensitive analysis for Java. In
practice,Ais usually used for analyzing a program according
to client’s needs under different settings (depending on, forexample, how complex Java features such as exceptions,reﬂection, and native code are handled and whether or notcertain objects are pre-conﬁgured to be context-insensitiveempirically). Apparently, A will exhibit different analysis
times under different settings, a problem that we do not addressin this paper. However, for a ﬁxed setting given, C
ONCH can
accelerate Aat no or little loss of precision by debloating
its contexts. Let A1andA2be two different object-sensitive
analyses used for analyzing a program under two differentsettingsS
1andS2. It is possible that A1is faster than A2
underS1but the opposite is true under S2, which is again a
problem that we do not investigate here. However, for a ﬁxedsetting given, C
ONCH can accelerate both analyses at no or
little loss of precision by debloating their contexts.
2) Challenges: To debloat contexts, we must ﬁnd context-
dependent objects. Recently, the following two necessaryconditions are given for determining the context-dependabilityof an object Oallocated in a method mbased on CFL reach-
ability, requiring us to check the existence of a write into anda read from an access path O.f
1.···.fncontext-sensitively
(where the two accesses often happen outside m) [15], [25]:
•A(c− →O.f 1.···.fn: there exists an object Athat ﬂows
intomfrom outside and ends up being stored later into
O.f 1.···.fnunder a calling context cofm, and
•O.f 1.···.fn)c− →v: there exists a load of O.f 1.···.fn
ﬂowing into a variable voutsidemunder also c.
where context matching is formulated by solving the standardbalanced parentheses problem [28]. If these two conditionshold,Omust be context-dependent. Otherwise, different ob-
jectsA ﬂowing into O.f
1.···.fnunder different calling
contexts of mwill be conﬂated, causing them to ﬂow into
different variables vspuriously. In object-sensitive pointer
analysis, the parameters and return variable of a method arealso conceptually regarded as special ﬁelds of its receiverobjects [15], [25]. Thus, in the access path above, a ﬁeld f
i
can be either a real Java ﬁeld or one of such special ﬁelds.
Unfortunately, verifying these two conditions precisely is
undecidable [31], as it requires us to solve kOBJ fully context-
sensitively (with k=∞). In addition, weakening these two
conditions [15], [25] will over-approximate unduly the numberof context-dependent objects found but approximating themheuristically [21]–[24] may cut it down signiﬁcantly but atthe expense of some signiﬁcant precision loss.
3) Our Solution: To identify context-dependent objects
efﬁciently and effectively, our key insight is to approximatethe two aforementioned necessary conditions with the threeconditions that are linearly veriﬁable (in terms of the number
81of statements) and mostly necessary for real code, based on
three key observations governing how objects are used.
Like the prior work on selective context-sensitivity [21]–
[24], C ONCH also relies on the points-to information, pts,
pre-computed by Andersen’s analysis.
Observation 1. A context-dependent object Ooften has at
least one instance ﬁeld O.f that is both written into ( x.f=
···) and read from (··· =x.f), whereO∈pts(x).
1void main ( ) {
2A a = new A();// A
3 Object o= new Object ();// O
4 Object v = a . wrapId ( o ) ;
5}
6class B{
7 Object id (Object q){8 return q;
9}}
10class A{
11 Object wrapId ( Object p){
12 B b = new B(); // B
13 return b.i d (p);
14}}
Fig. 5: A context-dependent object Bviolating Obs 1.
There can be rare cases, as illustrated in Figure 5, where
Obs 1 may not be valid for some context-dependent objects,
such as B. Under object-sensitivity [15], [25], Opointed to by
pis ﬁrst written into B.q and then returned and stored into
v. As discussed in Section II-C2, qis considered as a special
ﬁeld of B. Such cases are rare in real-world object-oriented
programs, as C ONCH loses little precision (Section V).
Observation 2. A context-dependent object O, pointed to by
a variable or a ﬁeld of some object according to pts, usually
ﬂows out of its containing method (for allocating O).
1 V ector ( int size ){
2 this . elems = n e w Object [ size ];
3}
(a) Case 1 from Vector1 Iterator iterator () {
2 return new KeyIterator ();
3}
(b) Case 2 from HashMap
1void SunJCE ea(...) {
2 BufferedReader br = new BufferedReader ();
3 this .f = new StreamTokenizer ( br );
4}
(c) Case 3 from SunJCE_e
Fig. 6: Three common cases abstracted from JDK for Obs 2.
Figure 6 gives three representative cases abstracted from
the JDK where Obs 2 holds. In Figure 6(a), the array objectcreated ﬂows out of the constructor via a store. In Figure 6(b),theKeyIterator object created ﬂows out of iterator()
directly via a return. In Figure 6(c), we have a slightlymore complicated case. The BufferedReader object cre-
ated ﬂows out of its containing method as it is stored intotheinput ﬁeld of the StreamTokenizer object, which
ﬂows out of the containing method via a store. The objectsthat cannot ﬂow out of their containing methods are usuallycontext-independent as they are often created and used locally.
Observation 3. A context-dependent object Otends to have
a store statement x.f=yin a method m
/prime, whereO∈pts(x).
Letmbe the method where Ois allocated if m/primeis a
constructor (i.e., the constructor for creating O) andm/prime
otherwise. Then y(a) is data-dependent on a parameter of
mor (b) points to a context-dependent object.1 ArrayList () {
2 this . elems = new Object [5];
3}
4void set ( int idx , E e ) {
5 this . elems [ idx ] = e ;
6}
(a) Case 1 from ArrayList1void addEntry ( int idx , K k , V v) {
2 this . table [idx] = new Entry (k , v );
3}
4 Entry (K k , V v) {
5 this . key = k ; this . value = v;
6}
(b) Case 2 from HashMap.
1 HashSet ( ) {
2 this .m a p = new HashMap ( ) ;
3}4 HashMap(...) {
5 this . table = new Entry [10];
6}
(c) Case 3 from HashSet andHashMap.
Fig. 7: Three common cases abstracted from JDK for Obs 3.
Figure 7 gives three representative cases abstracted from the
JDK where Obs 3 holds. In Figure 7(a), Ois the Object[]
object allocated in line 2 and x.f=yisthis.elems[idx]
=e , which is modeled as this.elems.arr = e, where
arr is a special ﬁeld introduced to represent all the ele-
ments of an array (Section III). In this case, m=m/prime=
set(). Here, esatisﬁes Obs 3(a) trivially. In Figure 7(b),
O is the Entry object allocated in line 2, x.f =yis
this.key = k/this.value = v, m/prime=Entry(), and
m=addEntry(). Here, k/v (in line 5) also satisﬁes
Obs 3(a) trivially. In Figure 7(c), Ois the HashMap ob-
ject allocated in line 2, x.f =yisthis.table = new
Entry[10], m/prime=HashMap(), and m=HashSet().
Asnew Entry[10] is context-dependent by Obs 2 (as
well as Obs 1 and Obs 3 if the entire code is considered),
theHashMap object in line 2 is also context-dependent by
Obs 3(b). In Obs 3(b), the circular dependences on context-dependability are solved optimistically in Algorithm 1.
4) Motivating Example: For this example given in Figure 3
(with class Bfrom Figure 1), C
ONCH will identify Aas the
only context-dependent object. Let us examine Figure 1, whereAis created in line 15. Ais context-dependent as it satisﬁes all
the three observations: (1) Ahas an instance ﬁeld f, which has
a write and a read in lines 9 and 10, respectively (Obs 1), (2) A
can ﬂow out of B() via the store statement in line 15 (Obs 2),
and (3) ois stored into A.f in line 9, where ohappens to be
a parameter of setF() (Obs 3). Let us now consider B3 and
B4 created in Figure 3. Both are context-independent as both
satisfy Obs 1 (with an instance ﬁeld gofB3/B4 stored in B()
and loaded in foo()/bar() in Figure 1) and Obs 3 (due
to the existence of this.g = new A()// A in line 15,
where Ais context-dependent) but not Obs 2 (as B3/B4 does
not ﬂow out of its containing method foo
0,0()/bar 0,0()).
Finally, all the other objects are context-independent as theydo not contain instance ﬁelds and are used only locally, failingto satisfy any of the three observations stated.
5) Discussion: C
ONCH relies on Obs 1– Obs 3 to generate
three corresponding linearly veriﬁable conditions for determin-ing the context-dependability of an object. In Section IV, weintroduce a lightweight IFDS-based algorithm for verifyingthese conditions efﬁciently. In Section V, we demonstrate
C
ONCH is highly effective for real-world programs.
III.kOBJ WITH CONTEXT DEBLOA TING
We formalize context debloating here. We ﬁrst review the
classic algorithm for kOBJ (Section III-A) and then adapt it
82to support context debloating (Section III-B). C ONCH can be
used similarly for debloating contexts for any variant of kOBJ .
A.kOBJ
We describe kOBJ [11], [19], [20], [32] by considering a
simpliﬁed subset of Java, with ﬁve types of labeled statements
in Table I. Note that “x = newT(...)” is modeled as “x = new
T;x ./angbracketleftinit/angbracketright (...)”, where /angbracketleftinit/angbracketright (...) is the corresponding
constructor invoked. The control ﬂow statements are irrelevantsincek
OBJ is context-sensitive but ﬂow-insensitive. Loads and
stores to the elements of an array are modeled by collapsingall the elements into a special ﬁeld arr of the array. Every
method is assumed to have one return statement “return ret”,
whereret is known as its return variable. Section V discusses
how to handle static method calls and other complex languagefeatures such as exceptions, reﬂection, and native code.
Kind Statement Kind Statement
NEW l:x=new T ASSIGN l:x=y
STORE l:x.f=y LOAD l:x=y.f
CALL l:x=a0.f(a1, ..., a r)
T ABLE I: Five types of statements analyzed by kOBJ .
kOBJ makes use of the following domains: V,H,M,
F, andL, which represent sets of program variables, heap
objects (identiﬁed by their labels), methods, ﬁeld names, andstatements (identiﬁed also by their labels), respectively.
We useC=H
∗as the universe of contexts. Given a context
ctx=[e1,···,en]∈Cand a context element e∈H, we write
e+ +ctx for[e,e1,···,en]and⌈ctx⌉ kfor[e1,···,ek].
The following auxiliary functions are also used:
•methodOf :L→M
•methodCtx :M→℘(C)
•dispatch :M×H→M
•pts:(V∪H×F)×C→℘(H×C)
where methodOf gives the containing method of a state-
ment, methodCtx maintains the contexts used for analyzing
a method, dispatch resolves a virtual call to a target method,
and pts records the points-to information found context-
sensitively for a variable or an object’s ﬁeld.
Figure 8 gives the ﬁve rules used by kOBJ for analyzing
the ﬁve kinds of statements in table I. In [NEW ],Ol∈His
an abstract heap object created from the allocation site at l,
identiﬁed by its heap context hctx. Rules [ASSIGN ],[STORE ]
and [LOAD ]are handled in the standard manner. In [CALL ],
a call to an instance method x=a0.f(a1,...,a r)is analyzed.
In this paper, we write thism/prime,pm/prime
i andretm/primefor the “this”
variable,i-th parameter and return variable of m/prime, respectively,
wherem/primeis a target method resolved. Frequently, we also
writepm/prime
0 forthism/prime. In the conclusion of this rule, ctx/prime∈
methodCtx( m/prime)reveals how the contexts of a method are
maintained. Initially, methodCtx(“ main”) = {[]}.
B. Context Debloating
To debloat contexts, we assume that Drepresents the set
of context-independent objects found by C ONCH . Thus, thel:x=newTm =methodOf( l)
ctx∈methodCtx( m)hctx =⌈ctx⌉ k−1
(Ol,hctx )∈pts(x,ctx)[N EW]
l:x=ym =methodOf( l)ctx∈methodCtx( m)
pts(y,ctx )⊆pts(x,ctx )[A SSIGN ]
l:x.f=ym =methodOf( l)
ctx∈methodCtx( m)(O,hctx )∈pts(x,ctx)
pts(y,ctx )⊆pts(O.f,hctx )[STORE ]
l:x=y.f m =methodOf( l)
ctx∈methodCtx( m)(O,hctx )∈pts(y,ctx )
pts(O.f,hctx )⊆pts(x,ctx )[LOAD ]
l:x=a0.f(a1,...,a r)m=methodOf( l)
ctx∈methodCtx( m)(O,hctx )∈pts(a0,ctx)
m/prime=dispatch( f,O)ctx/prime=O+ +hctx
ctx/prime∈methodCtx( m/prime)(O,hctx )∈pts(thism/prime,ctx/prime)
∀i∈[1,r]:pts(ai,ctx)⊆pts(pm/prime
i,ctx/prime) pts(retm/prime,ctx/prime)⊆pts(x,ctx)[CALL ]
Fig. 8: Rules for kOBJ .
l:x=newTm =methodOf( l)ctx∈methodCtx( m)
hctx =/braceleftBigg
[] ifOl∈D
⌈ctx⌉ k−1 ifOl∈H\D
(Ol,hctx )∈pts(x,ctx)[N EW+D]
Fig. 9: Adapting [NEW ]to support context debloating.
objects in H\D are context-dependent. To modify kOBJ
to support context debloating, we simply replace [NEW ]by
[NEW +D] given in Figure 9. For a context-dependent object,
we proceed identically as before. For a context-independentobject, we no longer distinguish it under its different alloca-tors, by setting its heap context as hctx =[] , eliminating the
context explosion problem that would otherwise have occurredwhen it is used as a receiver object of an invoked method.
C
ONCH is conceptually simple, algorithmically easy to plug
into any existing object-sensitive pointer analysis, and practi-cally effective as validated during our extensive evaluation.
IV . C
ONCH :O UR CONTEXT DEBLOA TING APPROACH
We introduce an IFDS-based algorithm [28] for verifying
efﬁciently the three mostly necessary conditions stated inObs 1 – Obs 3 to ﬁnd the context-dependent objects ina program. As these conditions are not sufﬁcient, we maymis-classify context-independent objects as being context-dependent (but err on the side of preserving precision). Asthese conditions are mostly but not strictly necessary (Fig-ure 5), we may occasionally mis-classify context-dependentobjects as being context-independent (at a small loss ofprecision). We use the points-to information
pts pre-computed
by Andersen’s analysis [29] (which is the context-insensitiveversion of Figure 8). We ﬁrst give a high-level overview ofAlgorithm 1 and then discuss how to verify these conditions.
C
ONCH takes a program Pas input and returns Das the
set of context-independent objects in Pfor context-debloating.
Some additional notations are in order. For a given object O,
ﬁeldsOf( O)denotes the set of the ﬁelds of O. In addition,
hasLoad( O,f)(hasStore( O,f)) holds if Pcontains a load
···=x.f (storex.f=···) such that O∈pts(x).C Ia n d
CD, which are initialized to be ∅(line 1), represent the sets
83Algorithm 1: CONCH : context debloating.
Input: P // Input program
Output: D. // Set of Context-Indep Objects
1CI← CD←∅
2forOl∈Hdo
3 if∄f∈ﬁeldsOf(O l)s.thasLoad(O l,f)∧hasStore(O l,f)then
4 CI=CI∪{Ol} // Obs 1
5 else if Ol/∈leakObjects then
6 CI=CI∪{Ol} // Obs 2
7 else
8 R(Ol)={l/prime:x.f=yinP|Ol∈pts(x)}
9 forl/prime:x.f=y∈R(Ol)do
10 ifmethodOf(l/prime) is a constructor of Olthen
11 m=methodOf(l )
12 else
13 m=methodOf(l/prime)
14 ifdepOnParam(y, m )then
15 CD=CD∪{Ol} // Obs 3(a)
16 break
17UK←H\(CI∪CD), changed ← true
18while changed do
19 changed← false
20 forOl∈UK do
21 if∃l/prime:x.f=y∈R(Ol)s.t. pts(O l.f)∩CD/negationslash=∅then
22 CD=CD∪{Ol} // Obs 3(b)
23 changed← true
24D=CI∪(UK\CD);
25returnD
of context-independent and context-dependent objects found
so far, respectively. There are two stages, with the ﬁrst stage(lines 2-16) for verifying Obs 1, Obs 2 and Obs 3(a) and thesecond stage (lines 17-23) for verifying Obs 3(b).
A. V erifying Observation 1
In lines 3-4, an object O
lis classiﬁed as being context-
independent (and inserted into CI) if it does not satisfy Obs 1.
Otherwise, we will proceed to verify Obs 2 and Obs 3.
B. V erifying Observation 2
In lines 5-6, an object Olis classiﬁed as being context-
independent (and inserted into CI) if it does not satisfy Obs 2,
i.e.,Ol/∈leakObjects, where leakObjects contains the set
of objects that can ﬂow out of their containing methods byObs 2. Otherwise, we will proceed to verify Obs 3.
We introduce an IFDS-based algorithm given in Figure 14
for computing leakObjects inPcontext-sensitively, based on
the DFA (Deterministic Finite Automaton) given in Figure 13.Computing leakObjects entails reasoning about object reach-
ability in P. Let us describe it incrementally.
Initially, we start with a parameterless method containing
no calls. Its P AG (Pointer Assignment Graph) [1] can be builtby the rules in Figure 10. Our analysis is ﬁeld-insensitive, asreﬂected by [P-L
OAD ]and [P-S TORE ]. Figure 12(a) gives a
DFA for tracing approximately how an object Oallocated in a
method ﬂows over the P AG. There are four states: H(starting
at a heap object), F(moving forwards in the P AG), B(moving
backwards in the P AG), and E(exiting from the allocating
method). Due to the absence of parameters and returns, nol:x=newT
Olnew− − →xxnew− − →Ol[P-N EW]x=y
yassign−−−→xxassign−−−→y[P-A SSIGN ]
x=y.f
yload− − →xxload− − →y[P-L OAD ]x.f =y
ystore−−−→x[P-S TORE ]
Fig. 10: P AG edges for a parameterless method with no calls.
pis a parameter
pparam−−−→p[P-P ARAM ]ret is a return variable
retreturn−−−→ret[P-R ETURN ]
Fig. 11: P AG edges for parameters and return variables.
H startF
BEnewassign
store
assign|loadnew
(a) No calls/parameters/returnsH startF
BEnewassign
storereturn
assign|loadparamnew
(b) No calls
Fig. 12: Two intermediate DFAs for the DFA in Figure 13.
H startF
BEnewassign
storeinterAssign
return
interStore
assign|loadparam
interLoadnew
Fig. 13: The DFA for verifying Obs 2.
object can ﬂow out of a method, once it is allocated inside,as indicated by the lack of transitions into the ﬁnal state E.
Let us explain the object reachability analysis supported
by this DFA (Figure 13(a)). If the DFA starts with an objectOunder state H and transits to a node xunder state F
by following a sequence of P AG edges, then either Oﬂows
directly to x(via a new edge and possibly some assign edges)
orOﬁrst ﬂows into an access path O
/prime.f1.···.fn=O, where
O/prime, which is a locally allocated object, ﬂows to x. If the DFA
starts with an object Ounder state Hand transits to a node y
under state B, then either Ois stored directly into an access
path ofy, i.e.,y.f1.···.fn=O,o rO is ﬁrstly stored into an
access path of some locally allocated object O/primeand then O/prime
is stored into an access path of y, i.e.,y.f1.···.fn=O/prime.I n
this DFA, the load edges in the P AG are ignored as we track
whereOrather than its pointed-to objects ﬂow to (but are
used by the DFA in Figure 15 for computing depOnParam).
In addition, the DFA also ignores the store edges in the
P AG, as we assume that a method rarely contains a storeand a load operating on the same ﬁeld of an object (which
84is often accessed via its getter andsetter). In the rare
cases where this fails to hold, C ONCH may classify a context-
dependent object as being context-independent, causing the
underlying pointer analysis to lose some precision.
To support parameters and return variables, we add their
self-loop edges using the rules in Figure 11 and transform theDFA in Figure 12(a) into the one in Figure 12(b). Once anobject allocated in a method ﬂows to a parameter (suggestedby
param) or the return variable (suggested by return) under
stateE, it has leaked.
The ﬁnal DFA is presented in Figure 13, where the three
dotted transitions are added for handling call statements. Whileeach method has its own P AG, some summary edges are addedto its P AG for its call sites to capture the inter-proceduralvalue-ﬂows across these call sites context-sensitively, alongthe three dotted transitions. The call graph is built using
pts.
Given a call statement l:x=a0.f(a1,...,a r)contained in
methodm, letm/primebe a resolved target method (with pm/prime
ibeing
itsi-th parameter and retm/primebeing its return variable). Let n1
andn2be two P AG nodes. We write /angbracketleftn1,S1/angbracketright→/angbracketleftn2,S2/angbracketright
(known as a path edge in [28]) to indicate that node n1at
stateS1can reach node n2at stateS2. Let us write Gmas
the P AG of m. There are four cases considered when m/primeis
analyzed:
•/angbracketleftpm/prime
i,F/angbracketright→/angbracketleftpm/prime
j,E/angbracketright:pm/prime
i is saved into some access
path ofpm/prime
j, i.e.,pm/prime
j.f1.···.fn=pm/prime
i. Thus, we add
a summary edge, aiinterStore−−−−−→aj(i.e.,aj.f=ai), toGm
to propagate this reachability fact inter-procedurally.
•/angbracketleftpm/prime
i,F/angbracketright→/angbracketleftretm/prime,E/angbracketright:pm/prime
i is saved into some ac-
cess path of a locally allocated object Oinm/prime, i.e.,
O.f 1.···.fn=pm/prime
i, and then Oﬂows out of m/primevia its
return. Thus, we add a summary edge, aiinterAssign−−−−−−→x,
toGmto reﬂect this reachability fact inter-procedurally.
•/angbracketleftretm/prime,B/angbracketright→/angbracketleftpm/prime
i,E/angbracketright:retm/primeis loaded from some
access path of pm/prime
i, i.e.,retm/prime=pm/prime
i.f1.···.fn. Thus,
we add a summary edge, xinterLoad−−−−−→ai(i.e.,x=ai.f), to
Gmto propagate this reachability fact inter-procedurally.
•/angbracketleftO,H/angbracketright→/angbracketleftretm/prime,E/angbracketright:O, which is allocated in m/prime,ﬂ o w s
out ofm/primevia its return. We introduce a symbolic object
Sym lto abstract all the possible objects returned from
the call site land continue our analysis in m.
Figure 14 gives our IFDS-based algorithm [28] for com-
puting leakObjects, operating on a P AG instead of a CFG
representation of a program. The rules in [SEEDS ]inject
three kinds of path edges, where the ﬁrst one is for tracingleak objects while the other two are for ﬁnding summaryedges (which are not injected on-demand in order to improveparallelism in a parallel implementation of our algorithm).The rules in [P
ROPAGATE ]perform the reachability analysis
according to the DFA in Figure 13. Note that the three dottedtransitions in the DFA are implicitly handled by the summaryedges generated in [S
UMMARY ]. Finally, we collect the objects
that can reach the ﬁnal state, E, by using [COLLECT ].C. V erifying Observation 3
In lines 8-16, we verify if an object Olsatisﬁes Obs 3(a).
In the case of a positive answer, Olis considered immediately
as being context-dependent (and thus inserted into CD), sinceO
lhas already satisﬁed both Obs 1 and Obs 2 at this point.
Otherwise, we proceed to verify Obs 3(b) in lines 17-23.
The key to verifying Obs 3(a) lies in depOnParam( y,m),
which returns true if yis data-dependent on any parameter of
methodm. We have also designed and implemented an IFDS-
based algorithm for computing depOnParam, in a similar
manner as how we have computed leakObjects in Figure 14,
by making use of a simpler DFA given in Figure 15.
This DFA has only two states, FandE, recognizing only
four types of P AG edges, where interAssign is a summary
edge introduced for supporting call statements. Given a callstatement l:x=a
0.f(a1,···,ar)in method m. Letm/prime
be a target method invoked. When /angbracketleftpm/prime
i,F/angbracketright→/angbracketleftretm/prime,E/angbracketright
happens, retm/primeis recognized to be data-dependent on pm/prime
i
(i.e.,retm/prime=pm/prime
i.f1.···.fn). Thus, we add a summary edge,
aiinterAssign−−−−−−→x,t ot h eP A Go fm to propagate this reachability
fact inter-procedurally from the callee m/primeto the caller m.
Our algorithm for computing depOnParam, which pro-
ceeds forwards from method parameters, is a simpliﬁed ver-sion of the one in Figure 14. For [S
EEDS ], only the pa-
rameters need to be injected. The rules for [PROP AGA TE ],
are similar. For [SUMMARY ], we use the summary edges
added as discussed above. Finally, let dps(v,m v)={pmv
i|
/angbracketleftpmv
i,F/angbracketright→/angbracketlefty,F/angbracketright}, wherevis a variable deﬁned in its
containing method mvandpmv
i is some (i-th) parameter of
mv. Then depOnParam( y,m)can be deﬁned recursively as
(by taking care of chained constructors, in practice):
depOnParam(y, m )=⎧
⎪⎨
⎪⎩dps(y, m y)/negationslash=∅ ifm=my/logicalortext
pmy
i∈dps(y,m y)
depOnParam(a i,m) otherwise(1)
whereaiis the corresponding argument of pmy
i.
Finally, Obs 3(b) can be veriﬁed straightforwardly. At this
point, CI and CD contain the sets of context-independent and
context-dependent objects found so far. Let Obe an object
inH\(CI∪CD) .Ois regarded as being context-dependent
if it can point to any context-dependent object (found so far)transitively and context-independent otherwise.
D. Soundness and Time Complexity
C
ONCH is sound as it may mis-classify some context-
dependent objects as being context-independent and thus cause
the underlying pointer analysis to produce over-approximatedpoints-to information, resulting in some loss of precision.
The worst-case time complexity of C
ONCH in analyzing
a program Pis linear to the number of its statements, for
three reasons. First, leakObjects can be computed according
to Figure 14 in O(ED3)[28], where Eis the number of P AG
edges in P, which are constructed linearly to the number of
statements in Paccording to Figures 10 and 11, and D=4
is the number of states of the DFA in Figure 13. Second,the ﬁrst stage of Algorithm 1 (lines 2-16) runs in O(|L|),
85/angbracketleftOl,H/angbracketright→/angbracketleftOl,H/angbracketright/angbracketleftpm
i,F/angbracketright→/angbracketleftpmi,F/angbracketright/angbracketleftretm,B/angbracketright→/angbracketleftretm,B/angbracketright[SEEDS ]
/angbracketleftn1,S1/angbracketright→/angbracketleftOl,H/angbracketrightl:n2=newT
/angbracketleftn1,S1/angbracketright→/angbracketleftn2,F/angbracketright/angbracketleftn1,S1/angbracketright→/angbracketleftn2,F/angbracketrightl:n3=n2
/angbracketleftn1,S1/angbracketright→/angbracketleftn3,F/angbracketright
/angbracketleftn1,S1/angbracketright→/angbracketleftn2,F/angbracketrightl:n3.f=n2
/angbracketleftn1,S1/angbracketright→/angbracketleftn3,B/angbracketright/angbracketleftn1,S1/angbracketright→/angbracketleftn2,B/angbracketrightl:n2=n3|n3.f
/angbracketleftn1,S1/angbracketright→/angbracketleftn3,B/angbracketright[PROPAGATE ]
/angbracketleftn1,S1/angbracketright→/angbracketleftn2,B/angbracketrightl:n2=newTS 1/negationslash=B
/angbracketleftn1,S1/angbracketright→/angbracketleftOl,H/angbracketright/angbracketleftn1,S1/angbracketright→/angbracketleftn2,S2/angbracketright/angbracketleftn2,S2/angbracketright→/angbracketleftn3,S3/angbracketright∈ Sum
/angbracketleftn1,S1/angbracketright→/angbracketleftn3,S3/angbracketright
/angbracketleftn1,S1/angbracketright→/angbracketleftretm,F/angbracketright
/angbracketleftn1,S1/angbracketright→/angbracketleftretm,E/angbracketright/angbracketleftn1,S1/angbracketright→/angbracketleftpmi,B/angbracketright
/angbracketleftn1,S1/angbracketright→/angbracketleftpmi,E/angbracketright
/angbracketleftpmi,F/angbracketright→/angbracketleftpmj,E/angbracketrightpmi/negationslash=pmjl:x=a0.f(a1,···,ar)O∈pts(a0)m=dispatch( f,O)
/angbracketleftai,F/angbracketright→/angbracketleftaj,B/angbracketright∈ Sum
/angbracketleftpmi,F/angbracketright→/angbracketleftretm,E/angbracketrightl:x=a0.f(a1,···,ar)O∈pts(a0)m=dispatch( f,O)
/angbracketleftai,F/angbracketright→/angbracketleftx,F/angbracketright∈ Sum[SUMMARY ]
/angbracketleftretm,B/angbracketright→/angbracketleftpmi,E/angbracketrightl:x=a0.f(a1,···,ar)O∈pts(a0)m=dispatch( f,O)
/angbracketleftx,B/angbracketright→/angbracketleftai,B/angbracketright∈ Sum
/angbracketleftO,H/angbracketright→/angbracketleftretm,F/angbracketrightl:x=a0.f(a1,···,ar)O∈pts(a0)m=dispatch( f,O)
/angbracketleftx,B/angbracketright→/angbracketleftSym l,H/angbracketright∈ Sum/angbracketleftSym l,H/angbracketright→/angbracketleftx,F/angbracketright∈ Sum
/angbracketleftOl,H/angbracketright→/angbracketleftpmi,E/angbracketright
Ol∈leakObjects/angbracketleftOl,H/angbracketright→/angbracketleftretm,E/angbracketright
Ol∈leakObjects[COLLECT ]
Fig. 14: Rules for computing leakObjects, i.e., the set of objects that can ﬂow out of their containing methods for verifying
Obs 2.Si∈{H,F,B}, where i∈{1,2,3} andSym lis a symbolic object abstracting all objects returned from call site l.
F start Eassign|load
interAssignreturn
Fig. 15: The DFA used for computing depOnParam.
whereLis the set of statements in P. Finally, the second stage
of Algorithm 1 (lines 17-23) can be efﬁciently performed in
O(|H|), whereHis the set of heap objects in P.
V. E V ALUA TION
We demonstrate the effectiveness of our C ONCH approach
by addressing the following two research questions:
•RQ1. Is C ONCH precise and efﬁcient?
•RQ2. Can C ONCH speed up existing object-sensitive
analysis algorithms signiﬁcantly?
Implementation. We have implemented C ONCH in S OOT
[16], a program analysis and optimization framework for Java,on top of its context-insensitive Andersen’s pointer analysis,
S
P ARK [1] (for computing pts). C ONCH is implemented in
about 1500 lines of Java code, which will soon be releasedas an open-source tool at http://www.cse.unsw.edu.au/
∼corg/
conch along with a reproducible artifact in the form of a
Docker image. As described in Section II, C ONCH aims to
boost the performance of all object-sensitive pointer analysisalgorithms. We report and analyze our results by applying
C
ONCH to debloat two representative baselines, kOBJ (anobject-sensitive version of S P ARK ) and Z IPPER [22] (the latest
version b83b038, which can deliver the arguably best speedupsfork
OBJ among the recent algorithms for supporting selec-
tive context-sensitivity [15], [21]–[24] in our experimentalsetting). Due to space limitations, we will only summarizethe signiﬁcant performance beneﬁts also achieved by C
ONCH
in debloating contexts for E AGLE [15].
Experimental Setting. kOBJ is a standard in-house imple-
mentation of S P ARK in S OOT [33]. As for Z IPPER (originally
released in D OOP [17] but used here to accelerate kOBJ in
SOOT ), we have used an analysis setting that is as close
as possible to the one used by Z IPPER in several major
aspects. First, we perform an exception analysis on the ﬂywithk
OBJ as in D OOP by handling exceptions along the so-
called exception-catch links [34]. Second, we use the declaredtype of an array element instead of java.lang.Object
to ﬁlter type-incompatible points-to objects. Third, we handlenative code by using the summaries provided in S
OOT . Fourth,
we analyze a static method m by using the contexts of
m’s closest callers that are instance methods (on the callstack) and resolve Java reﬂection by using the reﬂection loggenerated by T
AMIFLEX [35] as is often done in the pointer
analysis literature [11], [12], [22], [24]. Finally, objects that areinstantiated from StringBuilder andStringBuffer as
well as Throwable (including its subtypes) are distinguished
per dynamic type and then analyzed context-insensitively asis done in D
OOP [36] and WALA [18].
We have conducted our experiments on an Intel(R) Xeon(R)
CPU E5-1660 3.2GHz machine with 256GB of RAM. We
86have selected a set of 12 popular Java programs, including
9 benchmarks from DaCapo [37], and 3 Java applications(checkstyle, JPC andfindbugs). The Java library used
isjre1.6.0_45. These are the standard Java programs
that are frequently used for evaluating pointer analysis algo-rithms [11], [12], [22], [24]. The time budget used for runningeach pointer analysis on a program is set as 12 hours. Theanalysis time of a program is an average of three runs.
A. RQ1: Is C
ONCH Precise and Efﬁcient?
Given Base (a baseline pointer analysis) and Base+D
(Base with its contexts debloated by C ONCH ), we measure
the precision of C ONCH in terms of precision loss incurred
with respect to a given metric (Metric) when both Base and
Base+D are applied to analyze the same program:
Δ=Metric( Base+D) −Metric( Base)
Metric( Base)(2)
where Metric( Base) and Metric( Base+D) are the metric
numbers obtained by Base and Base+D, respectively. We use
four common metrics for measuring the precision of a context-
sensitive pointer analysis [11], [13], [15], [22]: (1) #fail-cast :
the number of type casts that may fail, (2) #call-edges: the
number of call graph edges discovered, (3) #poly-calls: the
number of polymorphic calls discovered, and (4) #reach-mtds:
the number of reachable methods.
Table II gives our main results. For kOBJ ,ZkOBJ denotes
the version of kOBJ with selective context-sensitivity provided
by Z IPPER . All the baselines (where k∈{2,3}) and their
debloated versions are compared over the 12 Java programs.
CONCH is very precise in terms of supporting context
debloating while losing negligible precision. Our approachpreserves the precision of all the baselines for 10 programsconsisting of the 9 DaCapo benchmarks and findbugs.
Forcheckstyle andJPC, our approach suffers from an
average precision loss of only less than 0.1% (across the fourmetrics). This happens since a PropertyChangeEvent
object created in method firePropertyChange(...)
of class java.beans.PropertyChangeSupport
and a LineReader object created in method
load(InputStream) ofjava.util.Properties
have been misclassiﬁed as being context-independent by
C
ONCH as they do not satisfy Obs 2.
CONCH is also highly efﬁcient (as a pre-analysis). Table III
gives the times spent by S P ARK [1], Z IPPER [22] and C ONCH .
Note that both Z IPPER and C ONCH are designed to be multi-
threaded (with 8 threads used in our experiments). C ONCH
is slightly faster than Z IPPER and S P ARK across all the 12
programs. On average, we have 2.6 seconds (C ONCH ), 10.4
seconds (Z IPPER ) and 12.5 seconds (S P ARK ). Thus, C ONCH
is efﬁcient enough for supporting context debloating.
B. RQ2: Can CONCH Speed Up Baseline Analyses?
Table II also gives the analysis times of all the analyses.
CONCH deliver signiﬁcant speedups (geometric means) over
all the baselines. For kOBJ , the speedups of 2OBJ +D overT ABLE II: Main results. In all metrics (except for speedups),
smaller is better. Given an analysis Base, Base+D is its de-
bloated version by C ONCH . OoM stands for “Out of Memory”.
Classic kOBJ Selective kOBJ
Prog Metrics 2OBJ 2OBJ+D 3OBJ 3OBJ+D Z2OBJ Z2OBJ+D Z3OBJ Z3OBJ+D
Time (s) 45.4 13.9 (3.3x) 1049.3 185.4 (5.7x) 20.8 7.8 (2.7x) 337.9 32.1 (10.5x)
#fail-cast 509 509 449 449 559 559 507 507
#call-edges 51176 51176 51149 51149 51394 51394 51367 51367#poly-calls 1622 1622 1615 1615 1643 1643 1636 1636antlr
#reach-mtds 7804 7804 7803 7803 7842 7842 7841 7841
Time (s) 743.8 359.5 (2.1x) >12h 4093.7 519.9 279.7 (1.9x) OoM 2771.2
#fail-cast 1314 1314 - 1221 1368 1368 - 1279#call-edges 56699 56699 - 56464 57192 57192 - 57036#poly-calls 1695 1695 - 1675 1732 1732 - 1716bloat
#reach-mtds 9021 9021 - 9005 9093 9093 - 9085
Time (s) 253.0 85.5 (3.0x) OoM 4215.9 34.6 20.3 (1.7x) 573.6 178.3 (3.2x)
#fail-cast 1348 1348 - 1241 1418 1418 1323 1323#call-edges 72457 72457 - 72023 73123 73123 72738 72738#poly-calls 2032 2032 - 2008 2060 2060 2040 2040chart
#reach-mtds 15143 15143 - 15113 15269 15269 15247 15247
Time (s) >12h 4113.5 OoM OoM 2956.3 2487.7 (1.2x) OoM OoM
#fail-cast - 3215 - - 3357 3357 - -
#call-edges - 145763 - - 146492 146492 - -
#poly-calls - 8720 - - 8737 8737 - -eclipse
#reach-mtds - 19916 - - 19985 19985 - -
Time (s) 18.6 10.5 (1.8x) 572.3 177.8 (3.2x) 9.2 5.1 (1.8x) 113.3 28.1 (4.0x)
#fail-cast 395 395 336 336 444 444 400 400#call-edges 34120 34120 34100 34100 34343 34343 34323 34323#poly-calls 808 808 802 802 832 832 826 826fop
#reach-mtds 7582 7582 7582 7582 7620 7620 7620 7620
Time (s) 19.4 8.7 (2.2x) 555.3 192.6 (2.9x) 9.4 4.9 (1.9x) 129.5 31.0 (4.2x)
#fail-cast 394 394 340 340 448 448 398 398#call-edges 33495 33495 33468 33468 33728 33728 33701 33701#poly-calls 918 918 911 911 944 944 937 937luindex
#reach-mtds 7017 7017 7016 7016 7057 7057 7056 7056
Time (s) 30.4 11.8 (2.6x) 2225.7 252.1 (8.8x) 13.2 5.2 (2.5x) 622.7 39.2 (15.9x)
#fail-cast 409 409 357 357 466 466 418 418#call-edges 36377 36377 36350 36350 36605 36605 36578 36578#poly-calls 1116 1116 1109 1109 1143 1143 1136 1136lusearch
#reach-mtds 7669 7669 7668 7668 7707 7707 7706 7706
Time (s) 41.6 24.2 (1.7x) 1236.1 257.0 (4.8x) 23.9 14.9 (1.6x) 344.7 52.5 (6.6x)
#fail-cast 1432 1432 1367 1367 1514 1514 1461 1461#call-edges 59864 59864 59805 59805 60029 60029 59970 59970#poly-calls 2357 2357 2351 2351 2382 2382 2376 2376pmd
#reach-mtds 11841 11841 11841 11841 11880 11880 11880 11880
Time (s) 565.3 298.2 (1.9x) OoM 1632.1 230.7 227.5 (1.0x) 2487.7 1125.6 (2.2x)
#fail-cast 600 600 - 546 657 657 609 609#call-edges 46653 46653 - 46621 46842 46842 46815 46815#poly-calls 1613 1613 - 1606 1636 1636 1629 1629xalan
#reach-mtds 9659 9659 - 9657 9701 9701 9700 9700
Time (s) 1014.6 349.1 (2.9x) >12h OoM 404.4 236.1 (1.7x) OoM 4887.4
#fail-cast 1130 1130 - - 1206 1206 - 1117#call-edges 67039 67041 - - 67854 67854 - 66892#poly-calls 2210 2210 - - 2268 2268 - 2211checkstyle
#reach-mtds 12314 12314 - - 12383 12383 - 12342
Time (s) 106.1 54.6 (1.9x) 2163.3 240.6 (9.0x) 34.4 26.3 (1.3x) 181.0 44.8 (4.0x)
#fail-cast 1356 1356 1206 1206 1431 1431 1278 1278#call-edges 80965 80978 79297 79310 81616 81629 79932 79945#poly-calls 4263 4264 4127 4128 4324 4325 4187 4188JPC
#reach-mtds 15508 15508 15161 15161 15582 15582 15232 15232
Time (s) 1629.6 180.1 (9.0x) OoM 936.3 131.3 50.3 (2.6x) 1890.0 186.8 (10.1x)
#fail-cast 2072 2072 - 1696 2144 2144 1956 1956#call-edges 87915 87915 - 86993 88567 88567 87741 87741#poly-calls 3655 3655 - 3621 3670 3670 3643 3643ﬁndbugs
#reach-mtds 16266 16266 - 16219 16315 16315 16287 16287
T ABLE III: Times spent by pre-analyses in seconds.
antlr bloat chart eclipse fop luindex lusearch pmd xalan checkstyle JPC ﬁndbugs
SP ARK 8.6 8.9 15.6 25.9 7.6 6.9 7.8 11.7 8.7 14.0 17.4 16.7
ZIPPER 4.6 6.4 16.4 25.5 4.0 3.7 4.3 9.5 10.2 14.5 9.8 16.2
CONCH 1.7 2.0 3.2 6.6 1.5 1.4 1.4 2.2 2.5 2.9 2.6 3.1
2OBJ range from 1.7x (for pmd) to 9.0x (for findbugs)
with an average of 2.6x. When k=3 , the speedups of
3OBJ +D over 3OBJ are more impressive, ranging from 2.9x
(forluindex) to 9.0x (for JPC) with an average of 5.2x. For
ZIPPER , the speedups of Z 2OBJ +D over Z 2OBJ range from
1.0x (for xalan) to 2.7x (for antlr) with an average of
1.8x. When k=3 , the speedups of Z 3OBJ +D over Z 3OBJ
are also more impressive, ranging from 2.2x (for xalan)t o
15.9x (for lusearch) with an average of 5.6x.
87These results suggest that the speedups delivered by C ONCH
increase as kincreases, implying that C ONCH can help all
the baselines improve their scalability. In particular, 2OBJ +D
scales one more benchmark, i.e., eclipse than 2OBJ ,
3OBJ +D can scale 4 more benchmarks (bloat, chart,
xalan, and findbugs) than 3OBJ , and Z 3OBJ +D can scale
2 more benchmarks (bloat andcheckstyle) than Z3O BJ.
In general, an analysis may be unscalable due to running either
out of memory (“OoM”) or the time budget (“> 12h”).
Due to space limitations, let us summarize brieﬂy the
signiﬁcant performance beneﬁts achieved by C ONCH in de-
bloating contexts for E AGLE [15], [25]. Unlike Z IPPER (which
makeskOBJ run faster while losing precision), E AGLE aims
to accelerate kOBJ while preserving its precision. For kOBJ ,
let EkOBJ be the version of kOBJ with selective context-
sensitivity enabled by E AGLE . For the four precision metrics
considered in Table II, #fail-cast, #call-edges, #poly-calls,
and #reach-mtds,E kOBJ yields the same results as kOBJ and
EkOBJ +D yields the same results as kOBJ +D in theory. As
for the performance speedups achieved, C ONCH is nearly as
effective for E AGLE as for Z IPPER . The speedups of E 2OBJ +D
over E 2OBJ range from 1.3x (for eclipse) to 5.7x (for
findbugs) with an average of 2.1x, and the speedups of
E3OBJ +D over E 3OBJ range from 2.8x (for luindex)t o
9.2x (for lusearch) with an average of 4.8x. In addition,
CONCH scale 4 more benchmarks, bloat, chart, xalan,
andfindbugs, under E 3OBJ +D than under E 3OBJ .
Therefore, C ONCH can accelerate existing object-sensitive
pointer analyses signiﬁcantly with negligible loss in precision.These include not only k
OBJ (the standard algorithm) but also
its variants enabled by, e.g., Z IPPER [22] and E AGLE [15],
[25] (the two recent attempts on applying selective context-sensitivity to improve the performance of k
OBJ ).
Below we analyze in detail why context debloating can
enable baseline analyses, kOBJ and ZkOBJ , to improve their
efﬁciency and scalability (as reported in Table II).
Fig. 16: Percentage distribution of the two types of objects.
Figure 16 depicts the percentage distribution of context-
dependent objects and context-independent objects classiﬁedby C
ONCH .C ONCH has successfully identiﬁed a large per-
centage of context-independent objects in all the programs,ranging from 65.6% (in eclipse) to 78.7% (in fop) with an
average of 72.4%. Thus, a large amount of precision-irrelevantcontexts has been eliminated via context debloating.
Table IV compares the baseline analyses (i.e., k
OBJ and
ZkOBJ ) and their debloated counterparts (i.e., kOBJ +D and
ZkOBJ +D) in terms of the average number of contexts ana-
lyzed for a method, where k∈{2,3}. The debloated analysesT ABLE IV: Average number of contexts analyzed for a methodbyk
OBJ ,kOBJ +D, ZkOBJ and ZkOBJ +D, where k∈{2,3}.
antlr bloat chart eclipse fop luindex lusearch pmd xalan checkstyle JPC ﬁndbugs
2OBJ 27.1 30.3 36.5 - 15.6 17.1 20.0 17.3 50.8 66.4 24.7 37.9
2OBJ+D 13.1 18.3 20.8 31.1 9.2 9.9 10.3 10.3 31.6 41.4 16.0 18.8
Z2OBJ 8.1 14.3 6.9 14.8 4.9 5.6 6.0 6.1 15.3 18.7 7.4 9.6
Z2OBJ+D 4.8 8.7 5.2 12.3 3.6 4.0 4.0 4.4 11.8 14.4 6.1 7.3
3OBJ 99.8 - - - 53.0 58.1 91.5 53.5 - - 87.2 -
3OBJ+D 24.6 39.0 78.9 - 19.1 21.3 22.2 18.7 61.6 - 26.1 29.5
Z3OBJ 26.5 - 21.7 - 14.3 16.7 23.5 17.6 60.7 - 14.5 25.7
Z3OBJ+D 8.2 17.3 12.5 - 6.4 7.1 7.3 7.1 22.6 57.5 7.7 10.8
have achieved a substantial reduction in terms of this importantmetric across all the programs, providing the reasons behindthe improved efﬁciency and scalability via context debloating.
Finally, we can also understand the effectiveness of C
ONCH
from a substantial reduction it has achieved in the numberof context-sensitive facts inferred. In Table V, #cs-gpts, #cs-pts and #cs-fpts represent the numbers of context-sensitiveobjects pointed by global variables (i.e., static ﬁelds), localvariables and instance ﬁelds, respectively, and #cs-calls rep-resents the number of context-sensitive call edges. In general,the speedups of a pointer analysis over a baseline comefrom a signiﬁcant reduction in the number of context-sensitivefacts computed by the baseline. For example, 2
OBJ +D is
signiﬁcantly faster than 2OBJ forfindbugs as its num-
ber of context-sensitive facts is signiﬁcantly less than 2OBJ .
Similarly, Z 3OBJ +D is also much faster than Z 3OBJ for
lusearch. However, the analysis time of a pointer analysisis not linearly proportional to the number of context-sensitivefacts computed [13]. Consider xalan.Z 2
OBJ +D has achieved
a reduction of 16.2% over Z 2OBJ in terms of the number of
facts inferred but their analysis times are comparable.
VI. R ELA TED WORK
In this section, we mainly review the prior work that is the
most closely related to improving the performance of whole-program pointer analysis for object-oriented programs.
There are several recent efforts on exploiting selective
context-sensitivity to accelerate the performance of object-sensitive pointer analysis (i.e., k
OBJ ) [15], [22], [24]. E A-
GLE [15] improves the efﬁciency of kOBJ while preserving
its precision by conservatively reasoning about value ﬂowsvia CFL reachability. Z
IPPER [22], as a representative of non-
precision-preserving approaches [21]–[24], [38], trades preci-sion for efﬁciency by exploiting several value ﬂow patterns.These techniques mitigate the context explosion problem ofk
OBJ by analyzing only a subset of methods in the program
context-insensitively. In contrast, C ONCH represents a novel
mitigation approach as it can debloat contexts for all theobjects in the program, enabling existing algorithms to runsigniﬁcantly faster at a only negligible loss of precision.
When applying C
ONCH to debloat contexts for Z kOBJ
[22] and E kOBJ [15], we have observed that their relative
performance advantages depend on the experimental settingsused (for good reasons). In [15], E k
OBJ outperforms Z kOBJ
when both are evaluated in S OOT (by using the exception
analysis provided by S P ARK [1] and disallowing manual
88T ABLE V: Context-sensitive facts.
Classic kOBJ Selective kOBJ
Prog Metrics 2OBJ 2OBJ+D 3OBJ 3OBJ+D Z2OBJ Z2OBJ+D Z3OBJ Z3OBJ+D
#cs-gpts 4.9K 2.1K 12.1K 2.5K 5.7K 2.3K 17.6K 2.7K
#cs-pts 19.8M 3.6M 228.8M 32.1M 18.6M 3.3M 205.1M 10.4M#cs-fpts 0.6M 0.1M 13.6M 6.3M 0.6M 0.1M 13.7M 6.3M#cs-calls 5.4M 1.3M 87.5M 22.7M 1.9M 0.5M 22.7M 1.1Mantlr
Total 25.8M 5.1M 329.8M 61.1M 21.1M 3.9M 241.6M 17.8M
#cs-gpts 3.1K 1.9K - 2.3K 3.9K 2.0K - 2.4K#cs-pts 159.8M 68.0M - 325.0M 140.9M 53.6M - 235.0M#cs-fpts 5.7M 4.6M - 28.8M 6.9M 4.6M - 28.0M#cs-calls 47.1M 20.9M - 112.0M 38.2M 16.4M - 74.0Mbloat
Total 212.7M 93.5M - 465.8M 186.0M 74.5M - 336.9M
#cs-gpts 12.5K 6.9K - 11.3K 10.1K 5.5K 24.6K 6.9K#cs-pts 56.9M 20.8M - 944.2M 16.2M 6.9M 166.8M 55.1M#cs-fpts 1.1M 0.4M - 19.6M 0.7M 0.3M 21.7M 14.0M#cs-calls 20.0M 8.5M - 332.8M 2.5M 1.4M 26.7M 10.1Mchart
Total 78.0M 29.7M - 1296.6M 19.5M 8.6M 215.3M 79.1M
#cs-gpts - 7.8K - - 21.9K 8.0K - -#cs-pts - 585.7M - - 601.8M 512.5M - -#cs-fpts - 12.8M - - 16.7M 13.5M - -#cs-calls - 345.2M - - 161.2M 147.3M - -eclipse
Total - 943.7M - - 779.7M 673.4M - -
#cs-gpts 2.9K 1.8K 4.3K 2.0K 3.4K 1.9K 9.1K 2.2K#cs-pts 4.1M 1.2M 67.8M 27.5M 3.7M 1.1M 47.0M 7.9M#cs-fpts 0.2M 71.4K 8.0M 5.8M 0.2M 76.4K 8.2M 6.2M#cs-calls 1.3M 0.5M 31.0M 20.0M 0.5M 0.2M 5.1M 0.7Mfop
Total 5.6M 1.8M 106.7M 53.2M 4.4M 1.4M 60.4M 14.8M
#cs-gpts 2.8K 1.6K 4.5K 2.0K 3.7K 1.8K 10.6K 2.2K#cs-pts 4.4M 1.4M 72.6M 31.4M 4.1M 1.2M 53.0M 8.5M#cs-fpts 0.2M 73.0K 9.0M 6.6M 0.2M 77.3K 9.0M 6.6M#cs-calls 1.4M 0.6M 34.1M 22.9M 0.6M 0.3M 5.6M 0.8Mluindex
Total 6.0M 2.0M 115.6M 60.9M 4.9M 1.6M 67.7M 15.9M
#cs-gpts 2.9K 1.6K 4.2K 1.8K 3.7K 1.8K 10.3K 2.1K#cs-pts 6.8M 1.6M 193.6M 37.8M 5.4M 1.4M 116.5M 10.1M#cs-fpts 0.2M 77.4K 11.0M 7.9M 0.2M 82.7K 10.3M 7.9M#cs-calls 3.1M 0.7M 149.3M 27.8M 1.1M 0.3M 41.8M 1.0Mlusearch
Total 10.1M 2.4M 353.9M 73.6M 6.7M 1.8M 168.6M 19.0M
#cs-gpts 3.4K 1.9K 5.1K 2.1K 5.3K 2.1K 21.3K 2.4K#cs-pts 12.7M 5.1M 142.9M 42.0M 14.9M 4.8M 171.1M 14.8M#cs-fpts 0.6M 0.3M 13.1M 8.4M 1.1M 0.4M 17.0M 9.0M#cs-calls 3.9M 2.0M 56.8M 29.1M 2.2M 1.0M 17.4M 1.9Mpmd
Total 17.2M 7.3M 212.8M 79.6M 18.2M 6.2M 205.5M 25.7M
#cs-gpts 4.9K 2.9K - 3.2K 4.2K 2.8K 10.0K 3.2K#cs-pts 160.4M 49.0M - 161.0M 51.1M 41.5M 517.5M 123.6M#cs-fpts 6.3M 4.3M - 15.7M 5.4M 4.5M 33.1M 16.0M#cs-calls 49.6M 21.6M - 103.4M 14.6M 13.7M 86.0M 52.8Mxalan
Total 216.3M 74.9M - 280.2M 71.2M 59.7M 636.6M 192.3M
#cs-gpts 7.7K 3.5K - - 10.8K 4.3K - 5.2K#cs-pts 166.2M 44.7M - - 130.8M 38.3M - 353.9M#cs-fpts 1.5M 0.4M - - 2.8M 0.6M - 141.6M#cs-calls 86.5M 23.2M - - 24.1M 9.0M - 79.8Mcheckstyle
Total 254.2M 68.3M - - 157.6M 47.9M - 575.3M
#cs-gpts 7.3K 4.1K 21.3K 5.7K 7.0K 3.8K 16.4K 4.3K#cs-pts 27.8M 11.9M 606.3M 48.0M 13.2M 7.0M 67.3M 12.2M#cs-fpts 0.9M 0.3M 19.3M 7.2M 0.8M 0.3M 11.2M 6.7M#cs-calls 9.8M 5.5M 93.8M 28.8M 2.8M 2.0M 8.2M 2.0MJPC
Total 38.5M 17.7M 719.5M 84.1M 16.8M 9.4M 86.7M 20.8M
#cs-gpts 34.1K 4.5K - 6.0K 11.0K 4.5K 43.8K 5.9K#cs-pts 358.2M 41.2M - 126.9M 58.6M 19.5M 553.2M 38.6M#cs-fpts 18.0M 1.0M - 23.1M 5.0M 1.0M 61.1M 23.9M#cs-calls 147.2M 13.3M - 84.9M 13.2M 5.8M 101.5M 5.9Mﬁndbugs
Total 523.5M 55.5M - 234.8M 76.8M 26.2M 715.9M 68.4M
context-sensitivity selections to be pre-conﬁgured). In this
paper, however, E kOBJ underperforms Z kOBJ when both are
evaluated also in S OOT (but by using a more precise on-the-
ﬂy exception analysis [34] and turning on the manual heuristicdescribed in Section V to allow certain objects to be identi-ﬁed per dynamic type and then pre-conﬁgured to be alwaysanalyzed context-insensitively). As described in Section II-C,whichever is faster in whichever setting is irrelevant to thiswork, C
ONCH can boost their performance regardless (as eval-
uated in Section V). In the absence of this manual heuristic,
CONCH is observed to be even substantially more effective
in boosting the performance of an object-sensitive analysis A,
since it can help Aidentify more context-independent objects
that would otherwise be analyzed context-sensitively by A.
In our evaluation, turning this manual heuristic on aims tochallenge C
ONCH to demonstrate its performance beneﬁts overa faster baseline, by debloating the contexts for the fasterbaseline (that has already been debloated manually before).
Recently, T
URNER [26] exploits object containment to pre-
dict context-independent objects. In contrast, C ONCH is a more
principled approach and could ﬁnd more context-independentobjects than T
URNER .
MAHJONG [12] mitigates context explosion by merging
equivalent heap abstractions at the expense of precision inalias relations. C
ONCH is orthogonal to M AHJONG and may
boost its performance by debloating its contexts used.
In [13], context transformations are introduced as an alter-
native context abstraction to context strings (as used in kOBJ ),
but the practical beneﬁts are shown to be small.
Data-driven approaches [14], [21], [39] apply machine
learning to obtain various heuristics for supporting selectivecontext-sensitivity. S
CALER [40] trades precision for scalabil-
ity by selecting a suitable context-sensitivity variant for eachmethod so that the amount of points-to information is bounded.
Elsewhere [30], [41], [42], efforts have been made to
improve the precision of object-sensitive pointer analysis. Thisthread of research is orthogonal to ours considered here.
Finally, unlike whole-program analyses [1], [11], [20], [36],
[43], [44] considered in this paper, demand-driven pointeranalyses [45]–[50] typically only compute the points-to in-formation for program points that may affect a particular siteof interest for speciﬁc clients.
VII. C
ONCLUSION AND FUTURE WORK
Scalability is a major challenge in designing and developing
precise object-sensitive pointer analysis techniques due to thecombinatorial explosion of contexts in large object-orientedprograms. In this paper, we address this challenge by applyingcontext debloating so that we can boost the performance ofall object-sensitive pointer analysis algorithms with negligibleloss in precision. Our key insight is to replace a set of twoexisting necessary conditions (whose veriﬁcation is undecid-able) by a set of three necessary conditions that can be linearlyveriﬁable in terms of the number of statements in the programfor determining the context-dependability of any object. Ourevaluation shows that our new approach, C
ONCH , can improve
signiﬁcantly the efﬁciency and scalability of not only kOBJ but
also existing approaches to selective context-sensitivity thatcan already accelerate the performance of k
OBJ .
We believe that the performance beneﬁts of context debloat-
ing are not just limited to object-sensitive pointer analysis asdemonstrated here. In our future work, we plan to explore howto apply context debloating to other ﬂavors of pointer analysissuch as call-site-sensitive pointer analysis [51] and context-transformation-based pointer analysis [13]. In addition, wewill also investigate how to apply context debloating to othercontext-sensitive program analyses such as taint analysis [8]and data-dependence analysis [52] for improving their efﬁ-ciency and scalability, particularly for large codebases.
VIII. A
CKNOWLEDGEMENT
Thanks to all the reviewers for their constructive comments.
This research is supported by an ARC Grant DP180104069.
89REFERENCES
[1] O. Lhot ´ak and L. Hendren, “Scaling Java points-to analysis using
Spark,” in International Conference on Compiler Construction. Berlin,
Heidelberg: Springer Berlin Heidelberg, 2003, pp. 153–169.
[2] K. Ali and O. Lhot ´ak, “Application-only call graph construction,” in
ECOOP 2012 – Object-Oriented Programming. Berlin, Heidelberg:
Springer Berlin Heidelberg, 2012, pp. 688–712.
[3] M. Weiser, “Program slicing,” IEEE Transactions on software engineer-
ing, no. 4, pp. 352–357, 1984.
[4] M. Sridharan, S. J. Fink, and R. Bodik, “Thin slicing,” in Proceedings of
the 28th ACM SIGPLAN Conference on Programming Language Designand Implementation. New Y ork, NY , USA: Association for ComputingMachinery, 2007, pp. 112–122.
[5] Y . Li, T. Tan, Y . Zhang, and J. Xue, “Program tailoring: Slicing by
sequential criteria,” in 30th European Conference on Object-Oriented
Programming. Dagstuhl, Germany: Schloss Dagstuhl–Leibniz-Zentrumfuer Informatik, 2016, pp. 15:1–15:27.
[6] M. Naik, A. Aiken, and J. Whaley, “Effective static race detection
for Java,” in Proceedings of the 27th ACM SIGPLAN Conference on
Programming Language Design and Implementation. New Y ork, NY ,USA: Association for Computing Machinery, 2006, pp. 308–319.
[7] Y . Liu and A. Milanova, “Static analysis for inference of explicit
information ﬂow,” in Proceedings of the 8th ACM SIGPLAN-SIGSOFT
workshop on Program analysis for software tools and engineering,ser. P ASTE ’08. New Y ork, NY , USA: Association for ComputingMachinery, 2008, p. 50–56.
[8] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y . Le Traon, D. Octeau, and P . McDaniel, “FlowDroid: Precise context,ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for Androidapps,” in Proceedings of the 35th ACM SIGPLAN Conference on
Programming Language Design and Implementation. New Y ork, NY ,USA: Association for Computing Machinery, 2014, p. 259–269.
[9] D. He, L. Li, L. Wang, H. Zheng, G. Li, and J. Xue, “Understanding and
detecting evolution-induced compatibility issues in Android apps,” in2018 33rd IEEE/ACM International Conference on Automated SoftwareEngineering (ASE). New Y ork, NY , USA: Association for ComputingMachinery, 2018, pp. 167–177.
[10] D. He, H. Li, L. Wang, H. Meng, H. Zheng, J. Liu, S. Hu, L. Li, and
J. Xue, “Performance-boosting sparsiﬁcation of the ifds algorithm withapplications to taint analysis,” in 2019 34th IEEE/ACM International
Conference on Automated Software Engineering (ASE). San Diego,CA, USA: IEEE, 2019, pp. 267–279.
[11] Y . Smaragdakis, M. Bravenboer, and O. Lhot ´ak, “Pick your contexts
well: understanding object-sensitivity,” in Proceedings of the 38th an-
nual ACM SIGPLAN-SIGACT symposium on Principles of programminglanguages. New Y ork, NY , USA: Association for Computing Machin-ery, 2011, pp. 17–30.
[12] T. Tan, Y . Li and J. Xue, “Efﬁcient and precise points-to analysis:
modeling the heap by merging equivalent automata,” in Proceedings of
the 38th ACM SIGPLAN Conference on Programming Language Designand Implementation. New Y ork, NY , USA: Association for ComputingMachinery, 2017, pp. 278–291.
[13] R. Thiessen and O. Lhot ´ak, “Context transformations for pointer
analysis,” in Proceedings of the 38th ACM SIGPLAN Conference on
Programming Language Design and Implementation. New Y ork, NY ,USA: Association for Computing Machinery, 2017, p. 263–277.
[14] M. Jeon, S. Jeong, and H. Oh, “Precise and scalable points-to analysis
via data-driven context tunneling,” Proceedings of the ACM on Program-
ming Languages, vol. 2, no. OOPSLA, pp. 1–29, 2018.
[15] J. Lu and J. Xue, “Precision-preserving yet fast object-sensitive pointer
analysis with partial context sensitivity,” Proceedings of the ACM on
Programming Languages, vol. 3, no. OOPSLA, pp. 1–29, 2019.
[16] R. V all ´ee-Rai, P . Co, E. Gagnon, L. Hendren, P . Lam, and V . Sundaresan,
“Soot: A Java bytecode optimization framework,” in CASCON First
Decade High Impact Papers. USA: IBM Corp., 2010, pp. 214–224.
[17] Y . Smaragdakis, “Doop-framework for Java pointer and taint analysis
(using P/Taint),” 2021. [Online]. Available: https://bitbucket.org/yanniss/doop/
[18] IBM, “W ALA: T.J. Watson Libraries for Analysis,” 2020. [Online].
Available: http://wala.sourceforge.net/
[19] A. Milanova, A. Rountev, and B. G. Ryder, “Parameterized object
sensitivity for points-to and side-effect analyses for Java,” in Proceedings
of the 2002 ACM SIGSOFT international symposium on Software testingand analysis. New Y ork, NY , USA: Association for ComputingMachinery, 2002, pp. 1–11.
[20] ——, “Parameterized object sensitivity for points-to analysis for Java,”
ACM Transactions on Software Engineering and Methodology, vol. 14,no. 1, pp. 1–41, 2005.
[21] S. Jeong, M. Jeon, S. Cha, and H. Oh, “Data-driven context-sensitivity
for points-to analysis,” Proceedings of the ACM on Programming
Languages, vol. 1, no. OOPSLA, p. 100, 2017.
[22] Y . Li, T. Tan, A. Møller, and Y . Smaragdakis, “Precision-guided context
sensitivity for pointer analysis,” Proceedings of the ACM on Program-
ming Languages, vol. 2, no. OOPSLA, pp. 1–29, 2018.
[23] B. Hassanshahi, R. K. Ramesh, P . Krishnan, B. Scholz, and Y . Lu,
“An efﬁcient tunable selective points-to analysis for large codebases,” inProceedings of the 6th ACM SIGPLAN International Workshop on StateOf the Art in Program Analysis. New Y ork, NY , USA: Association forComputing Machinery, 2017, p. 13–18.
[24] Y . Smaragdakis, G. Kastrinis, and G. Balatsouras, “Introspective analy-
sis: context-sensitivity, across the board,” in Proceedings of the 35th
ACM SIGPLAN Conference on Programming Language Design andImplementation. New Y ork, NY , USA: Association for ComputingMachinery, 2014, pp. 485–495.
[25] J. Lu, D. He, and J. Xue, “Eagle: CFL-reachability-based precision-
preserving acceleration of object-sensitive pointer analysis with partialcontext sensitivity,” ACM Transactions on Software Engineering and
Methodology, 2021.
[26] D. He, J. Lu, Y . Gao, and J. Xue, “Accelerating Object-Sensitive Pointer
Analysis by Exploiting Object Containment and Reachability,” in 35th
European Conference on Object-Oriented Programming (ECOOP 2021),ser. Leibniz International Proceedings in Informatics (LIPIcs), vol. 194.Dagstuhl, Germany: Schloss Dagstuhl – Leibniz-Zentrum f ¨ur Informatik,
2021, pp. 16:1–16:31.
[27] T. Reps, “Undecidability of context-sensitive data-dependence analysis,”
ACM Transactions on Programming Languages and Systems, vol. 22,no. 1, pp. 162–186, 2000.
[28] T. Reps, S. Horwitz, and M. Sagiv, “Precise interprocedural dataﬂow
analysis via graph reachability,” in Proceedings of the 22nd ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Lan-guages , ser. POPL ’95. New Y ork, NY , USA: Association for
Computing Machinery, 1995, p. 49–61.
[29] L. O. Andersen, “Program analysis and specialization for the C program-
ming language,” Ph.D. dissertation, University of Cophenhagen, 1994.
[30] T. Tan, Y . Li, and J. Xue, “Making k-object-sensitive pointer analysis
more precise with still k-limiting,” in International Static Analysis
Symposium. Berlin, Heidelberg: Springer Berlin Heidelberg, 2016, pp.489–510.
[31] T. Reps, “Program analysis via graph reachability,” Information and
software technology, vol. 40, no. 11-12, pp. 701–726, 1998.
[32] Y . Smaragdakis and G. Balatsouras, “Pointer analysis,” F ound. Trends
Program. Lang., vol. 2, no. 1, p. 1–69, 2015.
[33] M. I. Gordon, D. Kim, J. H. Perkins, L. Gilham, N. Nguyen, and
M. C. Rinard, “Information ﬂow analysis of Android applications inDroidSafe,” in NDSS, vol. 15. The Internet Society, 2015, p. 110.
[34] M. Bravenboer and Y . Smaragdakis, “Exception analysis and points-
to analysis: Better together,” in Proceedings of the 18th International
Symposium on Software Testing and Analysis. New Y ork, NY , USA:Association for Computing Machinery, 2009, p. 1–12.
[35] E. Bodden, A. Sewe, J. Sinschek, H. Oueslati, and M. Mezini, “Taming
reﬂection: Aiding static analysis in the presence of reﬂection and customclass loaders,” in Proceedings of the 33rd International Conference on
Software Engineering. Honolulu, HI, USA: IEEE, 2011, pp. 241–250.
[36] M. Bravenboer and Y . Smaragdakis, “Strictly declarative speciﬁcation of
sophisticated points-to analyses,” in Proceedings of the 24th ACM SIG-
PLAN conference on Object oriented programming systems languagesand applications. New Y ork, NY , USA: Association for ComputingMachinery, 2009, pp. 243–262.
[37] S. M. Blackburn, R. Garner, C. Hoffmann, A. M. Khang, K. S.
McKinley, R. Bentzur, A. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer,M. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, A. Phansalkar,D. Stefanovi ´c, T. V anDrunen, D. von Dincklage, and B. Wiedermann,
“The DaCapo benchmarks: Java benchmarking development and anal-ysis,” in Proceedings of the 21st annual ACM SIGPLAN conference
on Object-oriented programming systems, languages, and applications.New Y ork, NY , USA: Association for Computing Machinery, 2006, pp.169–190.
90[38] Y . Li, T. Tan, A. Møller, and Y . Smaragdakis, “A principled approach to
selective context sensitivity for pointer analysis,” ACM Transactions on
Programming Languages and Systems, vol. 42, no. TOPLAS, pp. 1–40,
2020.
[39] M. Jeon, M. Lee, and H. Oh, “Learning graph-based heuristics for
pointer analysis without handcrafting application-speciﬁc features,” Pro-
ceedings of the ACM on Programming Languages, vol. 4, no. OOPSLA,pp. 1–30, 2020.
[40] Y . Li, T. Tan, A. Møller, and Y . Smaragdakis, “Scalability-ﬁrst pointer
analysis with self-tuning context-sensitivity,” in Proceedings of the 2018
26th ACM Joint Meeting on European Software Engineering Conferenceand Symposium on the F oundations of Software Engineering .N e w
Y ork, NY , USA: Association for Computing Machinery, 2018, pp. 129–140.
[41] A. Milanova, “Light context-sensitive points-to analysis for Java,” in
Proceedings of the 7th ACM SIGPLAN-SIGSOFT workshop on Programanalysis for software tools and engineering. New Y ork, NY , USA:Association for Computing Machinery, 2007, p. 25–30.
[42] G. Kastrinis and Y . Smaragdakis, “Hybrid context-sensitivity for points-
to analysis,” in Proceedings of the 34th ACM SIGPLAN Conference on
Programming Language Design and Implementation. New Y ork, NY ,USA: Association for Computing Machinery, 2013, p. 423–434.
[43] J. Whaley and M. S. Lam, “Cloning-based context-sensitive pointer
alias analysis using binary decision diagrams,” in Proceedings of the
ACM SIGPLAN 2004 conference on Programming language design andimplementation. New Y ork, NY , USA: Association for ComputingMachinery, 2004, pp. 131–144.
[44] L. Li, C. Cifuentes, and N. Keynes, “Boosting the performance of ﬂow-
sensitive points-to analysis using value ﬂow,” in Proceedings of the
19th ACM SIGSOFT symposium and the 13th European conference onF oundations of software engineering. New Y ork, NY , USA: Associationfor Computing Machinery, 2011, pp. 343–353.
[45] M. Sridharan, D. Gopan, L. Shan, and R. Bod ´ık, “Demand-driven points-
to analysis for Java,” in Proceedings of the 20th Annual ACM SIGPLANConference on Object-Oriented Programming, Systems, Languages, andApplications. New Y ork, NY , USA: Association for ComputingMachinery, 2005, p. 59–76.
[46] M. Sridharan and R. Bod ´ık, “Reﬁnement-based context-sensitive points-
to analysis for Java,” in Proceedings of the 27th ACM SIGPLAN
Conference on Programming Language Design and Implementation.New Y ork, NY , USA: Association for Computing Machinery, 2006, p.387–400.
[47] D. Y an, G. Xu, and A. Rountev, “Demand-driven context-sensitive alias
analysis for Java,” in Proceedings of the 2011 International Symposium
on Software Testing and Analysis. New Y ork, NY , USA: Associationfor Computing Machinery, 2011, pp. 155–165.
[48] L. Shang, X. Xie, and J. Xue, “On-demand dynamic summary-based
points-to analysis,” in Proceedings of the Tenth International Sympo-
sium on Code Generation and Optimization. New Y ork, NY , USA:Association for Computing Machinery, 2012, pp. 264–274.
[49] Y . Sui and J. Xue, “On-demand strong update analysis via value-
ﬂow reﬁnement,” in Proceedings of the 2016 24th ACM SIGSOFT
international symposium on foundations of software engineering.N e wY ork, NY , USA: Association for Computing Machinery, 2016, pp. 460–473.
[50] J. Sp ¨ath, L. Nguyen Quang Do, K. Ali, and E. Bodden, “Boomerang:
Demand-driven ﬂow-and context-sensitive pointer analysis for Java,” in30th European Conference on Object-Oriented Programming. Dagstuhl,Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2016, pp.22:1–22:26.
[51] M. Sharir and A. Pnueli, Two approaches to interprocedural data ﬂow
analysis. New Y ork University. Courant Institute of MathematicalSciences , 1978.
[52] Q. Zhang and Z. Su, “Context-sensitive data-dependence analysis via
linear conjunctive language reachability,” in Proceedings of the 44th
ACM SIGPLAN Symposium on Principles of Programming Languages.New Y ork, NY , USA: Association for Computing Machinery, 2017, pp.344–358.
91