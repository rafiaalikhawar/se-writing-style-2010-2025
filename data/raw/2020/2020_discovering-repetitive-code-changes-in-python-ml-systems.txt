Discovering Repetitive Code Changes in Python ML Systems
Malinda Dilhara
malinda.malwala@colorado.edu
University of Colorado Boulder
USAAmeya Ketkar‚àó
ketkara@uber.com
Uber Technologies Inc.
USA
Nikhith Sannidhi
nikhith.sannidhi@colorado.edu
University of Colorado Boulder
USADanny Dig
danny.dig@colorado.edu
University of Colorado Boulder
USA
ABSTRACT
Overtheyears,researcherscapitalizedontherepetitivenessofsoft-
ware changes to automate many software evolution tasks. Despite
theextraordinary riseinpopularityof Python-basedMLsystems,
theydonotbenefitfromtheseadvances.Withoutknowingwhat
aretherepetitivechangesthatMLdevelopersmake,researchers,
tool, and library designers miss opportunities for automation, and
ML developers fail to learn and use best coding practices.
Tofilltheknowledgegapandadvancethescienceandtooling
in ML software evolution, we conducted the first and most fine-
grained study on code change patterns in a diverse corpus of 1000
top-rated ML systems comprising 58 million SLOC. To conduct
thisstudywereuse,adapt,andimproveuponthestate-of-the-art
repetitivechangeminingtechniques.Ournoveltool,R-CPatMiner,
minesover 4Mcommitsand constructs350Kfine-grainedchange
graphsanddetects28Kchangepatterns.Usingthematicanalysis,
weidentified22patterngroupsandwereveal4majortrendsofhow
ML developers change their code. We surveyed 650 ML developers
to furthershed light onthese patternsand their applications,and
wereceiveda15%responserate.Wepresentactionable,empirically-
justified implications for four audiences: (i) researchers, (ii) tool
builders,(iii)MLlibraryvendors,and(iv)developersandeducators.
CCS CONCEPTS
‚Ä¢Softwareanditsengineering ‚ÜíSoftwaremaintenancetools ;
‚Ä¢Computing methodologies ‚ÜíMachine learning.
KEYWORDS
Refactoring, Repetition, Code changes, Machine learning, Python
ACM Reference Format:
Malinda Dilhara, Ameya Ketkar, Nikhith Sannidhi, and Danny Dig. 2022.
Discovering Repetitive Code Changes in Python ML Systems. In 44th In-
ternational Conference on Software Engineering (ICSE ‚Äô22), May 21‚Äì29, 2022,
Pittsburgh, PA, USA. ACM, New York, NY, USA, 13 pages. https://doi.org/10.
1145/3510003.3510225
‚àóAmeya Ketkar contributed this work as a research assistant at Oregon State University.
This work is licensed under a Creative Commons Attribution International 4.0 
License.
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
¬© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9221-1/22/05.
https://doi.org/10.1145/3510003.35102251 INTRODUCTION
Many software changes are repetitive by nature [ 7,33,53], thus
forming change patterns. Like in traditional software systems, Ma-
chineLearning(ML)developersperformrepetitivecodechanges
too. For example, Listing 1 shows a common change where ML
developers replaced a forloop that sums the list elements with
np.sum,ahighlyoptimizeddomain-specificabstractionprovided
bythelibrary NumPy[61].Sincethischangeinvolvesprogramming
idioms [2,80] at the sub-method level it is fine-grained. If this code
change is repeated at multiple locations or in multiple commits, it
is afine-grained code change pattern.
Listing 1: Commit c8b28432 in GitHub repositoryNifTK/NiftyNet: Replace
forloop with NumPy sum
1-for elem in elements:
2- result += elem
3+result = np.sum(elements)
Overtheyears,researchersinthetraditionalsoftwaresystems
have provided many applications that rely upon the repetitiveness
of changes: code completion in the IDEs [ 13,34,43,55,56], auto-
matedprogramrepair[ 6,9,50],APIrecommendation[ 32,55],type
migration[ 40],librarymigration[ 3,18,24,39,84],coderefactor-
ing[19,28],fine-grainedunderstandingofsoftwareevolution[ 3,
25,42,54,58,77,85].Unfortunately,thesearemostlyavailableonly
for Java, and do not support Python and ML systems.
Researchers [ 11,22,37,70] observed that Python dominates the
ML ecosystem in both the company-driven and the community-driven ML software systems, yet the tooling is significantly be-hind [
22,91]. In order to advance the science and tooling for ML
code development in Python, we need to understand how devel-
opers evolve and maintain ML systems. Previous researchers have
focused on high-level software evolution tasks like identifying ML
bugs[35,37,38],updatingMLlibraries[ 22],refactoringandtechni-
cal debt of ML systems [ 75,82], managing version control systems
for data [8], and testing [ 10,31,36]. However, there is a lack of un-
derstandingoftherepetitivefine-grainedcodechangepatternsthat
ML developers laboriously perform. What are fine-grained changes
performedinMLsystems?WhichonesareML-specific?Whatkinds
of automation do ML developers need?
Withoutanswerstosuchquestions,researchersmissopportu-
nities to improve the state-of-the-art in automation for softwareevolution in ML systems, tool builders do not invest resources
where automation is most needed, language and library designers
7362022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Malinda Dilhara, Ameya Ketkar, Nikhith Sannidhi, and Danny Dig
cannotmakeinformeddecisionswhenintroducingnewconstructs,
and ML developers fail to learn and use best practices.
Inthispaper,weconductthefirstlarge-scalestudyanddiscover
repetitive change patterns in Python-based ML systems. We em-
ploy both quantitative (miningrepositories and thematic analysis)
and qualitative methods (surveys) to answer the research ques-
tions. Blending these methods has the advantage of the results
beingtriangulated.Thequantitativemethodshelpusdiscover what
fine-grained change patterns ML developers perform. The quali-
tativemethodhelpsusanswer whythesechangesareperformed,
how they are performed, and how tool builders can improve ML
developer productivity.
For the quantitative analysis, we use a large data set of 1000 ML
projectsfromGitHub,comprising58millionsourcelinesofcode
(SLOC) at the latest revisions, 1.16 million mapped code blocks, 1.5
million changed files, and 0.4 billion changed SLOCs. We extracted
28,308finegrainedcodechangepatternswhere58%ofthemappear
in multiple projects. We applied thematic analysis [12,88]u p o n
2,500mostpopularpatternsfromourdataset,andcategorizedthem
into 22 fine-grained change pattern themes that reveal 4 majortrends. Moreover, we designed and conducted a survey with 650
MLdevelopers,inwhichwepresented1,235patternsfortheirfeed-
back and achieved a 15% response rate. In the survey, 71% of the
developersconfirmedtheneedofautomationfor22patterngroups.
Among these, we discovered four major trends: (1) transform to
Contextmanagers (e.g.,disableorenablegradientcalculation,swap
ML training device), (2) convert forloops to domain specific ab-
straction(e.g.,seeListing1),(3) updateAPIusage (e.g.,migrateto
TensorFlow.log from log, transform matrices), and (4) use ad-
vanced language features (e.g., transform to listcomprehension).
The mainchallenge inconducting suchlarge-scale, representa-
tive studies, is the lack of tools for mining non-Java repositories.
To overcome this challenge we reuse, adapt, and extend the vast
ecosystemofJavaAST-levelanalysistools[ 3,25,42,54,58,77,85]to
Python.Mostofthesetoolsrelyontechniquesthatareconceptually
language-independent, i.e., they operate on intermediate represen-
tation of the code (e.g., AST nodes). Second, we observed that 72%
of the Python AST node kinds identically overlap with those in
Java(e.g., While-Statment, Assignment-Statement,etc.).Moreover,
another18%ofPythonASTnodekindsalsoexistinJavawithsome
differences (e.g., Python‚Äôs forloop has multiple loop variables).
Only 10% of the Python AST node kinds are unique to Python (e.g.,
Withstatement, Generators ,etc.).Hence,oneofourkeyideasis
to reuse the Java AST-level analysis tools to analyse 72% of thePython AST nodes and for the remaining 28% of AST nodes we
either modify existing capabilities or add brand new ones.
We first developed a novel technique, JavaFyPy, to transform
PythonASTtoaformatthatcanbeprocessedbyJavaAST-levelmin-ingtools.WeusedJavaFyPytoadapttoPythonthestate-of-the-art
fine-grainedchangepatternminingtool,CPatMiner[ 58].CPat-
Minermatcheschangedmethodsandtheirbodystatementsacross
the commits and identifies fine-grained change patterns. Refactor-
ings such as move, rename, and extract method, re-arrange and
obfuscatethecodestatements,thatarehardtomatchacrosstheedit,
leading CPatMiner to miss multiple occurrences of patterns. To
improvetheaccuracyof CPatMiner,weintegrateitwiththestate-
of-the-art refactoring mining technique- RefactoringMiner [ 85],that de-obfuscates the re-arranged code statements. Our novel tool
R-CPatMiner performs refactoring-aware, fine-grained change pat-
tern mining in the commit history of Python systems.
Our findingsand toolshave actionableimplications for several
audiences. Among others, they (i) advance our understanding ofrepetitive changes that the ML developers perform which helps
theresearchcommunitytoimprovethescienceandtoolsforML
software evolution, (ii) provide a rich infrastructure to automateand significantly extend the scope of existing studies on ML sys-
tems [37,38,75], (iii) help tool builders comprehend the ML devel-
opers‚Äôstrugglesanddesireforautomation,(iv)providefeedbackto
language and API designers when introducing new ML constructs,
and (v) assist educators in teaching ML software evolution.
This paper makes the following contributions:
(1)Tothebestofourknowledge,weconductedthefirstandthe
largeststudyonfine-grained28,308codechangepatternsonML
systems. We identified code changes patterns. We applied thematic
analysison 2,500 most popular patterns and categorized them into
22 fine-grained change pattern themes that reveal 4 major trends.(2)
We designed and conducted a surveywith 650 open-source ML
developers to provide insights about the reasons motivating those
changes, the current practices of applying those changes, and their
recommendation for tool builders.(3)
We developed novel tools to collect fine-grained change pat-
terns applied in the evolution history of Python-based ML systems.
We applied these tools on 1000 open-source projects hosted on
GitHub. We make the collected information and tooling publicly
available for reuse [21] so that we enable further research.(4)
We present an empirically-justified set ofimplications of our
findingsfromtheperspectiveoffouraudiences:researchers,tool
builders, language designers, and ML developers.
2 MOTIVATING EXAMPLE
Listing2:Specifiesthedevice(CPU)foroperationsexecutedinthecontextandmovemethod
_init_model toparentclass
1class _FERNeuralNet():
2+ def _init_model(self):
3+ with tf.device(‚Äô/cpu:0‚Äô):
4+ B, H, T, _ = q.get_shape().as_list()
5...
6class TimeDelayNN(_FERNeuralNet):
7- def _init_model(self):
8- B, H, T, _ = q.get_shape().as_list()
ThecodechangeshowninListing2specifiesthehardwaredevice
using tf.device() (line 3) for the TensorFlow operation in line
4.tf.device() is a Context Manager [ 64] from the ML library,
TensorFlow .Thisisafine-grainedcodechangeandthedeveloperhas
interleavedthiswitha PullupMethod refactoringthatpulls _init_-
modelfrom TimeDelayNN into the parent class _FERNeuralNet .
Isspecifyinghardwaredevicefor TensorFlow operationsa pat-
tern?Howfrequentisthispattern?Dodevelopersneedtoolsupport
to recommend and automate this code change pattern ? We consider
thisfine-grained code change instance a repeated patternif a similar
code change was performed in the history of this project or any
otherproject.Researchershaveproposedadvancedtechniquesto
mine such fine-grained change patterns from the commit histo-
ries [58,59]. However, these techniques are inapplicable to mine
737Discovering Repetitive Code Changes in Python ML Systems ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Python codePython parser
(Jython)Typeaugmenter Syntaxtransformer
Customized EclipseJDT Java parserMiningAlgorithm Eclipse JDT
Java parser
Design of Java
AST analysis tools Design of JavaFyPyAST AST
21
Figure1:DesignofJavaFyPyandexistingASTanalysistools
thefine-grainedcodechangepatterns showninListing2because(1)
theirtechniquesminecodechangepatternsforJava,and(2)they
do not account for overlapping refactorings.
Researchers [ 51,52,78] have shown that developers often in-
terleave many programming activities such as bug fixes, feature
additions, or other refactoring operations, and often these changes
overlap [ 54] (as shown in Listing 2). Such overlapping changes
and refactorings can easily obfuscate existing fine-grained change
patternminingtools[ 58,59]becausetheydonotaccountforthese
changeswhenmatchingcodeacrossthecommit.Forexample,CPat-
Miner [58] does not match the method body of _init_model in
theclass _FERNeuralNet (lines3‚Äì4)tothebodyof _init_model
intheclass TimeDelayNN (line7)astheyareindifferentlocations
anddifferentfiles.Thislackof refactoringawareness isaseriouslim-
itationofexistingpatternminingalgorithmsbecausetheycanmiss
severalconcreteinstancesofchangepatternsthatareobfuscated
by overlapping refactorings.
Re-implementing the existing Java AST mining tools for Python
will require a significant amount of development effort. It is also
neither feasible nor sustainable as researchers are continuously
implementing new Java AST mining tools or improving existing
tools. For this purpose, we propose JavaFyPy, a technique to adapt
existingJavaASTminingtoolstoPythonthatleveragesthesimi-
laritybetweentheJavaandPythonabstractsyntaxtrees(AST).We
use JavaFyPy to adapt the state-of-the-art fine-grained change pat-
ternminingtool,CPatMiner[ 58],toPython.TomakeCPatMiner
refactoring aware, we adapt the state-of-the-art Java refactoring in-
ference tool, RefactoringMiner [85] (known as RMiner), to Python
and integrate it with CPatMiner as R-CPatMiner. Particularly,
the code-block mapping pairs (i.e., two versions of the same code-
blockinamethodbeforeandafterthechange)reportedbyRMiner
are provided as input to CPatMiner. R-CPatMiner mines change
patternsinPythonsoftwaresystemsinarefactoring-awaremanner.
3 TECHNIQUE
Mostofthecurrentcodechangeminingtools(i.e.ASTminingtools)
are conceptually language-independent because they operate upon
theabstractsyntaxtrees(AST)only.However,theirimplementation
isboundonlytoJava.Toovercomethispracticalimplementation
limitation, we propose a very pragmatic solution - JavaFyPy, atechnique that transforms the input Python program to an ASTthat can be processed by the mining algorithm of existing Java
ASTanalysistools.JavaFyPywillfast-trackresearchersandtool
buildersbymakingtheAST-basedminingtoolsimplementedfor
JavaprogramsapplicableforPythonprograms.Thus,itwillsave
severaldevelopment-hours ofworkrequired forre-implementing
these techniques. As shown in 1in Figure 1, JavaFyPy takes aPython code as an input and produces an AST, that can be usedin mining algorithms of Java AST analysis tools. To achieve this,
JavaFyPyfirsttransformsthePythoncodetoASTandenrichesthe
ASTbyaugmentingtypeinformation.Then,the Syntaxtransformer
mapsthecorrespondingJavaconcretesyntaxtotheASTnodes.The
Javaparser(EclipseJDT)usesittoproducethefinalAST.Eclipse
JDTisthemostpopularJavaparserusedinASTminingresearch
tools.Therefore,weselectedEclipseJDTastheparserthatproducesthefinalAST.This enhancedandenriched ASTcanbeprocessedby
theminingalgorithmsofJavaASTanalysistools.Toolbuildersand
researchers can use JavaFyPy, and extend their tools for Python.
3.1 Python code transformation
AsshowninFigure2JavaFyPyfirst parsestheinputPythonpro-
gram to an AST. We define an AST as:
Definition3.1. (AST)Let T bean AST.T has oneroot. Each node
Ni‚ààThas a parent (except the root node). Each node ( Ni‚ààT)
hasasequenceofchildnodes(denotedby CNi).Numberofnodes
in the sequence CNiis denoted by LengthCNi. Each node Niis
a specific syntax category known as AST node kind, KindNi=
{Assignment Statement, For statement, Method Invocation ...}.
WeleveragethesyntacticsimilaritybetweenPythonandJava
to adapt the Java AST analysis tools to Python. We thoroughly
studied the Java and Python language specifications [ 62,67] and
mappedthePythonASTnodekindstothoseinJavabasedonthe
description in the specifications.
Definition 3.2. (Mapped AST node) Let Tjbe a Java AST and
Tpbe a Python AST. Nj‚ààTj,Np‚ààTp. We state that NjandNp
are mapped AST node kind, if NjandNpmaintain a structural
similarity. Mapped node of node Npis denoted by M(Np)=Nj.
Wefoundthreekindsofmappingsnamely, IdenticalASTnode ,
Nearly identical AST node , andUnique AST node .
Definition 3.3. (Identical AST node) Let CNjbe a sequence of
childASTnodesofaparentJavanode NjandCNpbeasequence
ofchildASTnodes ofaPythonnode Np.Westatethat NjandNp
are identical AST nodes if (i) M(Np)isNj, and (ii) ‚àÄNi‚ààCNp:
M(Np)‚ààCNj.
(1)IdenticalASTnode (Definition3.3)-72%ofthePython‚ÄôsAST
node Kinds can be identically mapped to a Java‚Äôs AST Node. For
example,wemappedPython‚Äôs IftoJava‚ÄôsIf Statement andmapped
Python‚Äôs Assignto Java‚ÄôsAssignmentStatement.
Definition 3.4. (Nearly Identical AST node) We state that Njand
NpasnearlyidenticalASTnodes,if NjandNpmeetsconditions:
(i)M(Np)isNj, and (ii)‚àÉNi‚ààCNp:M(Ni)‚àâCNj.
(2)Nearly identical AST node (Definition 3.4) - 18% of Python‚Äôs
AST Node kinds could be partially mapped to those of Java. For
instance,bothPythonandJavaprovidethe forconstructtoiterate
over a collection, however unlike Java, Python allows to iterate
over multiple variables (see the forloop in Figure 2), thus AST of
Python forloop contains additional child AST node kinds.
Definition3.5. (UniqueASTnode)Let NpbeaPythonASTnode.
We state that Npis unique to Python, if there is no mapped AST
node inTj. i.e., (M(Np)‚àâTj).
738ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Malinda Dilhara, Ameya Ketkar, Nikhith Sannidhi, and Danny Dig
for x, y in iter:
z=x+y
yield z
Python ASTFor Statement
Expression (iter)
BlockExpression (y)
Expression (x)
Assignment statement (x=x+y) Yield StatementVariable Declaration (int x))
Variable Declaration (int y)for (int x,int y:iter){
z = x+y;yield z;
}For Statement
Expression (iter)
Block
Assignment statement (x=x+y) Yield StatementCoustomized
JDT Parser
Type augmented Python AST Transformed Code
Figure 2: An example Code transformationperformed by JavaFyPy
(3)UniqueASTnode -10%ofthePythonnodeshadnoJavacoun-
terpart. For instance, Java does not support listcomprehensions
oryieldstatement (as shown in Figure 2)
Aswecanobserve,JavaandPythonsyntaxsignificantlyoverlaps.
Asshownin 2inFigure1,ASTminingtoolslikeCPatMinerand
RMinerparsetheinputprogramtoEclipseJDTAST.Toadapttheir
tools to Python with JavaFyPy, tool builders or researchers simply
needtomigratetheirJavaparsertoourtechnique(JavaFyPy).After
that,wecansimplyreusetools‚ÄôAST-basedminingalgorithmsto
analyse72%ofthe IdenticalASTnode kinds,andmodifythecurrent
implementationtoaccommodatethe18% NearlyidenticalASTnode
kinds and add brand-new capabilities (often involving adding new
visitors) for handling the 10% Unique AST node kinds. After the
changes,thetoolstakePythoncodeasaninputandinfertheresults,
thus adapting Java AST mining tools to Python.
Figure 2 shows an example of the code transformation steps
(shown in Figure 1) that JavaFyPy performs automatically. The
Python code snippet in Figure 2 contains all three AST node kinds:
Identical AST node (z=x+y ),Nearly identical AST node (for
loop), and Unique AST node (yield z). TheJava parser first con-
structs the AST of the code snippet, then the Type Augmenter aug-
mentstheASTwithtypeinformationbyadding VariableDeclaration
nodes. Thisstep is importantbecause the Java-basedAST mining
tools [58,85] rely on the syntactic richness that the Java language
offers. Unlike Python, Java programmers have to explicitly declare
the types of variables, fields and methods. To add this syntactic
richness to the input program, JavaFyPy augments the AST of the
input program with type information (shown in Figure 2 as red
nodes).WeobtainthetypeinformationfromPyType[ 30],thestate-
of-the-practicetypeinferencetoolforPythondevelopedbyGoogle,
whichiswidelyadoptedbythePythoncommunity.Asthelaststep,
Syntax Transformer transforms the AST to code and passes it to
our customized Eclipse JDT parser which we extended to parse
Nearly identical AST node kinds and Unique AST node kinds.
Can JavaFyPy effectively transform all Identical, Nearly Identical,
and Unique AST node kinds? We evaluated this empirically with
14 popular Python projects including TensorFlow, PyTorch,Keras,
NLTK,Scikit learn, Scipy, and NumPythat comprise 23K Python
files and 2.9M SLOC. We checked whether all AST nodes, i.e., Iden-
ticalASTnodes ,NearlyidenticalASTnodes andUniqueASTnodes
weresuccessfullymappedandtransformedtotheoutputASTof
JavaFyPy. We achieved this by transforming all of the Python files
intheprojects,whichhad12MPythonASTnodes.Thisconfirms
that JavaFyPy can effectively transform any input Python program
to an Eclipse JDT AST format.3.2 Refactoring Aware Change Pattern Mining
3.2.1AdaptingCPatMiner .CPatMiner[ 58]isthestate-of-the-
art code change pattern mining tool that uses an efficient graph-
based representation of code changes to mine previously unknown
fine-grainedchangesfromgitcommithistory.Ititeratesoverchanged
methods in each commit and uses Eclipse JDT Java parser [27]
to generate an AST of Java source code. Then, its mining algo-
rithm builds program-dependence graphs for each AST node in-
dependentlyandthenmergesthegraphstocreateonebiggraph,
calledchange graph . CPatMiner builds change graphs for each
changed method, and it represents the before and after a source
code change that can be used to mine code change patterns. Since
72%ofthePythonASTnodekindsoverlapidenticallywiththose
in Java, we reused most of the capabilities for building the change
graphs.WeaddednewcapabilitiesinCPatMinertocreateprogram-dependencegraphsfor UniqueASTnodes ,andmodifiedtheexisting
capabilities of Nearly identical AST nodes . Overall, we extended
CPatMinerwith2%extracodelinesduetothenewormodified
capabilities, and reused the rest of the code. While this ratio might
bedifferentwhenadaptingothertools,itshowcasesthemeritof
JavaFyPy to reuse Java AST-based mining tools for Python.
3.2.2IntroducingRefactoringAwareness .AsdiscussedinSec-
tion 2, CPatMiner [ 58] does not account for the overlapping refac-
toringsappliedinthecommit.Theserefactoringsmovecodeblocks
between methods or change the method signature, making it hard
to match the changed code blocks. Thus missing the opportunities
tobuildchangegraphs fortheobfuscatedchanges.Toovercomethis,
we made the CPatMiner refactorings aware by integrating it with
RMiner [ 85]. We used JavaFyPy to adapt RMiner and use it to de-
tect 18 refactoring kinds that move code blocks. RMiner uses AST-
basedstatementmatchingalgorithmtomatchclasses,methods,and
statementsinsidemethodbodies,thushelpingusmatchmovedcodeblocks.Weconsulttheauthorsof RMinerandextenditsstatementmatchingalgorithmtoreasonaboutthe UniqueandNearlyidentical
ASTNodekinds.Forexample,Listing3showsavariablerename
refactoringinListComprehension,aPython UniqueASTnode kind
of the project "Deepmedic" detected by Python-adapted RMiner.
Listing3:Commit8d4be555inDeepMedic:VariablerenameinListComprehensiondetectedbyPython-adaptedRMiner
1- indices = [ layerNum - 1 for layerNum inlayers_norm]
2+ indices = [ layer_num - 1 for layer_num inlayers_norm]
We use Python adapted RMiner to accurately match the moved
codeblocks.WeextendedCPatMinertobuildchangegraphsfor
thecodeblockpairsreportedbyRMiner.Hence,CPatMinerno
longer misses obfuscated code-blocks that contain fine-grained
changes.Wedevelopedthetool R-CPATMiner ,toefficientlyand
739Discovering Repetitive Code Changes in Python ML Systems ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
accurately mines source code change patterns in the version histo-
ries of Python software systems, in a refactoring-aware manner.
4 RESEARCH METHODOLOGY
Weprefixalltheadaptedtoolnameswith Pytodisambiguatethe
toolnamesfromtheirJavacounterparts.Wefirstevaluatetheeffec-
tiveness ofthetools wedeveloped (oradapted). Then,we useour
reliable and validated tools , to explore the repetitive code changes
appliedinPythonMLSystems.Forthispurpose,weanswerthree
research questions:
RQ1.WhatarethefrequentcodechangepatternsinMLcode,and
whatpatternsneedautomation? Toanswerthisresearchquestion,
wetriangulatecomplementaryempiricalmethods,asshowninFig-
ure 3. (i) We mined 1000 repositories using R-CPatMiner and
extracted28,308patterns,(ii)Weappliedthematicanalysison2,500
patterns,(iii)Wesenta surveyto650MLdeveloperstoseektheir
opinion on automating the identified code change patterns.
RQ2.Howdoestherefactoringawarenessimprovethepatternmining
over the baseline CPatMiner? R-CPatMiner performs refactoring
awarechangepatternmining,thusimprovingbaselineCPatMiner.
Compared to CPatMiner, does R-CPatMiner extract (i) more
changegraphs?(ii)morecodechangepatterns?and(iii)morecode
instances per pattern?
RQ3.What is the runtime performance of R-CPatMiner, PyCPat-
Miner, and PyRMiner? To answer this,we compare the execution
time of the Python adapted tools with their Java counterparts.
5&3$70LQHU
 0/
SURMHFWVU&KDQJH
SDWWHUQV
$XWRPDWLRQ
VXJJHVWLRQVIRU
WRROEXLOGHUV
7KHPDWLF 
DQDO\VLV&KDQJHSDWWHUQV
IRUWKHVXUYH\
2QOLQH
VXUYH\
Figure3:Schematicdiagramoftheresearchmethodologytoanswer RQ3
4.1 Subject systems
Our corpus consists of 4,166,520 commits from 1000 large, mature,
anddiverseMLapplicationsystems,comprising58Mlinesofsource
codeand150KPythonfiles,usedbyotherresearchers[ 22]toun-
derstandthechallengesofevolvingMLsystems.Thiscorpus[ 22]is
showntobeverydiversefromtheperspectiveofPythonfiles,LOC,
contributors,andcommits.Theyvarywidelyintheirdomainand
application, include a mix of frameworks, web utilities, databases,
and robotics software systems that use ML. Further we added low-
level ML libraries [ 10] such as Scipy, SpaCy, and high-level ML
libraries[ 10]suchasKeras,PyTorch,Caffe,NLTK,andTheanoto
our subject systems. This ensures our dataset is representative and
large enough to answer our research questions comprehensively.
4.2 Static Analysis of Source Code History
4.2.1Change pattern identification: Running R-CPatMiner
on the ML corpus extracted 28,308 unique code change patterns,
where58%ofthemhavecodechangeinstancesinmultipleprojects,
63% of them have been performed by multiple authors.Since the mined patterns are numerous, we followed the best
practicesfromNegaraetal.[ 53].Theyorderedthepatternsalong
threedimensions-byfrequencyofthepattern(F),bythesizeofthe
pattern (S), and by F √óS. Since the repetitive changes done by sev-
eraldevelopersandprojectsarestable[ 59]andhaveahigherchance
ofbeingautomated,wealsoconsideredthenumberofprojectsand
authors as extra twodimensions. Then we ordered the mined pat-
terns along all five dimensions. Then, two of the authors who have
more than three years of professional software development ex-
perienceandextensiveexpertiseinsoftwareevolution,manually
investigated the top 500 patterns for each of the five dimensions
and identified meaningful code patterns, i.e., the patterns that can
be described as high-level program transformations.
Twoauthorsofthepapermanuallyanalyzedeachchangepat-
tern, to identify the high-level programming task performed in
thechangepatterns. Followingthebestpracticesguidelinesfrom
the literature, the authors used negotiated agreement technique
toachieveagreement[ 14,88].Twoauthorsofthepaperindepen-
dentlycodedthechangepatternscarefullyandassignedoneormore
descriptivephrases(i.e.,codes)tothepatterns.Bothauthorscon-
ducted the initial meeting after coding around 25% of the data (the
suggestedminimumsizeis10%[ 14]).Duringthemeeting,theau-
thorscarefullydiscussedthecodingprocessofallthepatterns.Also,theynegotiatedanydisagreementsbetweentheassignedcodesand
the patterns that cannot be described as high-level program trans-
formations. After 80% inter-coder agreement was achieved (rec-
ommendedinter-coderagreementlevelrangesfrom70%tomore
than 90% in the literature [ 14]), the two authors independently
coded the remaining change patterns. This process identified all
thepatternsforwhichthetwoauthorswereabletoagreeuponthe
underlyingmeaningofthepattern.Afterthecodingfinished,the
authors held another meeting in order to finalize the codes and ex-
tract themes. Themes capture something important about the data
inrelationtothemeaningofthepattern.Italsorepresentssome
levelofpatternedresponseormeaningwithinthedataset[ 12].The
two authors reviewed the initial themes against the data several
timesandrefinedtheirnamesanddefinitionsuntiltheybothagreed
that there were no further refinements possible. We identified four
trends(themes)ofpatternsbasedontheirstructuralsimilarityat
the statement and expression level, namely (i) transform to Con-
textmanagers ,(ii)convert forloopstodomainspecificabstraction ,
(iii)update API usage , and (iv) use advanced language features .
4.3 Qualitative Study
Themostreliablewaytounderstandthemotivationsandchallenges
associated with repetitive code changes is to ask the developers
who performed them. To achieve this, we surveyed 650 developers
who performed the identified change patterns.
4.3.1Contactingthedevelopers: Wecontactedthedevelopers
performingrepetitive codechanges thatwe consideredworthy of
furtherinvestigationbysendinganemailtotheaddressesprovidedintheirGitHubaccount.Thebodyofeachemailmessagewasauto-
matically generated by the application we developed, and included
the following information:
‚Ä¢Introduction to the research team and the purpose of the study.
‚Ä¢A plot of number of repetitive changes done in the project.
740ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Malinda Dilhara, Ameya Ketkar, Nikhith Sannidhi, and Danny Dig
‚Ä¢Alinktothefrequentrepetitivechangesdoneintherespective
projectsothatthedevelopercanuseitasaneducationalresource.
‚Ä¢The following four questions for the developer:
Q1.Whatarethereasonsforperformingthecodechangesabove?
Q2.How often do these code changes happen in ML codes?
Q3.Howoftenhaveyoumanuallyperformedthiskindofchange?
Q4.Would you like to have this change automated by a tool?
The first question aims at discovering actual motivations behind
a code change as expressed by the developers themselves. The
secondquestion focusesonthe frequencyofperforming thecode
change on ML codes, and it helps to examine the need for ML-
specificIDEs tools.The lastthree questionsaim atunderstanding
whetherdeveloperstrustandusetoolsupportforperformingthe
code changes. This is important, as there is relatively low IDE
supportforperformingcodechangesinMLcodes[ 22,91].Asample
email is available on the companion website [21].
In total, we sent 650 emails to developers, out of which 97 re-
sponded,bringingustoa15%responserate.Thisissignificantly
higherthantheusualresponserateachievedinquestionnaire-based
software engineering surveys, which is around 5% [79].
5 RESULTS
5.1 Repetitive changes in ML systems (RQ1)
5.1.1 Characteristics of patterns mined by R-CPatMiner. We ex-
ecutedR-CPatMineronourcorpusdescribedinSection4.1con-
taining1.5Mchangedsourcecodefiles,comprisingofover490M
lines of source code. For these changed files R-CPatMiner pro-
duced349,406changegraphswithatotalof4.7Mnodes.Thetool
extracted 28,308 unique code change patterns, where 63% and 58%
ofthemareperformedbymultipleauthorsandinmultipleprojects,
respectively.Figure4showsthe degreeofsharing ofthepatterns
amongstdevelopersand projects.Weobservedthat 53%ofthede-
velopers who performed the code change patterns share 100% of
their change patterns with other developers, 79% share at least 50%
of their patterns with others, and 91% share at least 10% of the
patterns.Moreover,36%oftheprojectsshare100%oftheirpatterns
withotherprojects,60%ofthemshareatleast50%oftheirpatterns
withothers,91%oftheprojectsshareatleast10%ofthepatterns.
This shows that R-CPatMiner extracts patterns that are pervasive
amongst the developers and projects.
(a) Developers (b) Projects
Figure 4: Degree of sharing of patterns amongst developers
and projects
5.1.2 Discovering pattern trends. Understanding code change pat-
terns that the ML developers perform is important to advance sci-
enceandtoolinginMLsoftwareevolution.Ourthematicanalysis
and developer surveys reveal 22 previously unknown repetitive
changepatternsgroupswherethedevelopersaskforautomation.Amongstthesepatterns,weidentifiedfourmajortrendsbasedon
their structural similarity (i.e., expression- and statement-level):
(1)transform to Context managers - 1237 instances
(2)convert forloopstodomainspecificabstraction -239instances
(3)update API usage - 166 instances
(4)use advanced language features - 415 instances
Next,wesummarizeandtriangulateresultsobtainedfromsource
code mining, thematic analysis, and developer surveys.
Note:Weusereal-worldcodeexamplestodescribefrequentchange
patterns. The examples use identifiers tf,np, andtorchas aliases of
ML libraries TensorFlow ,NumPy, andPyTorch. Due to space limita-
tions, we provide few code examples. Our companion website [ 21]
presentsacuratedrepositoryofexemplarsforeachpattern,aswell
asallthe instances for each pattern.
5.1.3Trend 1 - Transform to Context managers: A Python
Context manager is an abstraction for controlling the life-cycle for
a code block. It declares the methods __enter__ (initialization),
and__exit__ (finalization) which together define the desired run-
timeenvironmentfortheexecutionofacodeblock.Thecodeblock
needstobesurroundedina withstatement[ 68]thatinvokesthe
Contextmanager.Weobserved1,237changeinstancesbelonging
to eight pattern groups (P1‚ÄìP8 in Table 1) where developers move
code blocks into withstatements and use Context managers.
Listing 4: Commit dfb7520c in Pytorch: Disable gradient
1-input.grad.data.zero_()
2+with torch.no_grad():
3+ input.grad.zero_()
Listing 4 is an example of pattern P2 (Disable or enable gradient
calculation). The survey respondent S21 said, ‚Äúwhen we do not need
gradient computation in a DL network (using Tensor.backward() ),
itisimportanttodisablethegradientcalculationgloballytoreduce
memory consumption and increase speed‚Äù . The context manager
torch.no_grad() fromPyTorch,createsanexecutionenvironment
forthecodeinline3anddisablesthegradientcalculation.Likewise,
thepatterns(P2‚ÄìP8)inTable1createnewexecutionenvironments.
Listing 5: Commit 02ccf29b in tensorflow/datasets: Move
Context managers that used to read data to withstatement
1-file_ = tf.gfile.GFile(label_path)
2-dataset = csv.DictReader(file_, delimiter=" /tie")
3+with tf.gfile.GFile(label_path) as file_:
4+ dataset = csv.DictReader(file_, delimiter=" /tie")
We will now explain the most populous pattern group P1 (Read,
write, traverse data ) which moves an already existing Context man-
agerwithina withstatement(seeListing5).Thesurveyrespondent
S11 said, ‚ÄúWhen we use Context managers in withstatement, the
requiredresourcesareallocatedandreleasedprecisely.‚Äù Line3inList-
ing 5 uses the Context manager tf.gfile.GFile which handles
I/O operations. The developers do not need to handle I/O opera-tions such as file open (initialization) and file close (finalization)
when they use the Context manager insideawithstatement. How-
ever, ifdevelopers use theContext manager as afunction call (see
deletedline1in Listing5),theyneedtohandlealltheinitialization
and finalization logic [ 1]. Hence, if a Context manager is used as a
functioncall: (i)APImisuses oftenhappen,and allocatedresources
might not be managed efficiently [ 74,83], (ii) developers need to
741Discovering Repetitive Code Changes in Python ML Systems ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Table1: Triangulatingsourcecodeminingresultswithsurveyresponses:4majortrends,thepatterngroupsforeachtrend,and
whetherthatpatternisspecifictoMLcode(columnML).ColumnIshowsthenumberofinstancesforeachpattern.ColumnR
shows number of survey respondents. Next columns indicate their responses to survey Q2 (How often these changes happen
inMLcode?)andQ3(Howoftenhaveyoumanuallyperformedthischange?),withfrequency:VeryOften(VO),Often(O),Rare
(R), and Never (N). Q4 (Would you like to have this change automated by a tool?) response: Yes, No, Already Automated (AA).
Static Analysis Survey Responses
ùëÑ2 ùëÑ3 ùëÑ4
Trend PPattern ML1IRVOORNVOORNYesNoAA
Move to
with
statement
and use
ContextmanagersP1Read, write, traverse data √ó467667%17%-17%83%-17%-100%--
P2Disable or enable gradient calculation /check925100%---80%-20%-100%--
P3Swap ML training devices /check213100%---67%33%--67%33%-
P4Change name and variable scopes in DL networks /check106757%43%--57%29%14%-57%43%-
P5Execute dependencies of a Tensorflow graphs /check573100%---100%---33%67%-
P6Temporarily change configurations of libraries √ó592-50%50%-100%---50%50%-
P7Transform to context managers in pytest √ó335633%50%17%-67%33%--67%33%-
P8Use context managers to open temporary directories √ó100633%50%-17%67%-33%-83%17%-
Dissolve
forloops,
into domain
specific
abstractionsP9Transform to optimized operations in NumPy /check17910100%---90%-10%-100%--
P10Transform to operations in ListorDictionary √ó24367%33%--33%-67%-33%67%-
P11Transforming to Python built in functions √ó152 100%----100%-100%--
P12Transform functions in String √ó142-50%50%-100%---100%--
P13Transform to set operations √ó72100%---50%-50%-100%--
UpdateAPI
usage,
(212)P14Migrating to APIs ML libraries /check265100%---100%---100%--
P15Transform Matrix /check82683%17%--100%---33%50%-
P16Change data visualization /check28250%50%--50%-50%-50%50%-
P17Composite ML APIs /check225100%---100%---100%--
P18Update Container √ó115560%-40%-60%-40%-80%20%-
P19Update Type of Matrices /check164100%---50%-50%-50%50%-
Use advanced
Language
FeaturesP20Simplify conditional statement √ó243 33%67%-67%--33%33%-67%
P21Migrate from Dict, Set, List constructors to literals √ó424 25%75%-25%--75%25%-75%
P22Transform to Python List, Dict, or Set Comprehension √ó3496 33%67%-33%--67%33%-67%
1ML specific Patterns: i.e., patterns related to ML techniques. More than 80% developers confirmed they happen in ML very often or often
update all the initialisation and finalisation code when they update
the library versions (if the APIs have changed). The respondent
S13said, ‚ÄúIenvisionIDEsthatautomatemovingContextmanagers
towithstatements.‚Äù
Table 1 tabulates the results for each major trend and pattern
group, and shows survey responses for each pattern group. 90% of
thesurveyrespondentswhoperformedTrend-1changesconfirmed
thattheymoveto withstatementsveryoften(VO)oroften(O).All
respondentsperformthecodetransformationmanually,and74%
of the respondents requested automation in their IDEs.
5.1.4Trend 2 - Convert for-loops into domain specific ab-
straction: Listing 1 shows one such example where the developer
uses np.sumfromNumPy[61] instead of using forloop to com-
pute the sum of elements in a list. Developers often perform this
changetoenhancetheperformanceandcodereadability.Survey
respondentS22whoperformedpatternP9said, ‚ÄúSometimes,Python
forloopisarealperformancekiller.IwantmyIDEstosuggestthe
optimized APIs from ML libraries that I can use instead of loops‚Äù.Moreover, as alternatives to
forloops, developers use (i) List or
Dictionary operations (P10), (ii) Built in Python functions (P11),
(iii) Python String.join() (P12), and (iv) Set operations union
andintersection (P13).Pythonisaninterpretedlanguage,thus
compiler level optimisations do not happen in Python. The respon-
dent S24 said, ‚ÄúFor other programming languages, I might expect thecompilertooptimizethistypeofloop,soyes,IwouldbeinterestedinasuggestionbytheIDE.‚Äù AsshowninTable1,95%oftherespondents
who performed Trend 2 confirmed they do this very often (VO) or
often (O) in ML code. All the respondents manually perform the
change, and 89% of the respondents requested automation support.
5.1.5Trend 3 - Update API usage: Listing 6 shows an exam-
ple API migration where the developer uses a readily-available
np.mean instead of computing mean of the list first_occ . Survey
respondentS35said, ‚ÄúNumPyoffersefficientarraysandAPIsforcom-
putational operations, tools that inspect the code and suggest NumPy
APIs are very much needed.‚Äù
Listing 6: Commit 8592777b in inspirehep/magpie: Migrate
API to NumPy
1-return sum(first_occ) / len(first_occ)
2+return np.mean(first_occ)
Matrix transformations (P15) such as transpose ,broadcast ,
squeeze, and unsqueeze are frequent in ML projects. The respon-
dentS31said, ‚Äúbugsduetowrongmatrixshapesarehardtodetect
andprevalentinMLsystems.Iliketohavetoolsthatidentifythese
bugsandbroadcastthematricestocorrectshape‚Äù . Chenetal . [15]
observed developers change the bit size of matrices to get good
trade-off between training time and accuracy of the predictions.
742ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Malinda Dilhara, Ameya Ketkar, Nikhith Sannidhi, and Danny Dig
Congruent to this, we observed developers update the type of ma-
trices,e.g.,migratingtoanint64matrix(P19)asshowninListing7.
Listing7:Commit8f9cabbfinstellargraph/stellargraph:Up-
date matrix type
1-np.hstack((A.row[:, None], A.col[:, None])
2+np.hstack((A.row[:, None], A.col[:, None]))
‚Ü©‚Üí.astype(np.int64)
Other patterns include changing data visualization with Mat-
plotlib[48](P16),e.g.,betweendrawingalltheplotsinonefigure
vsusinganindividualfigureforeachplot.Anotherpatternisus-
ingcompositeMLAPIs(P17).Developersoftentraversedatasets
multiple times (which is inefficient). A more efficient solution is to
apply a composite operation. In Listing 8, developers compute dot
product on three matrices instead of applying a np.multi_dot .
Listing8:Commit180646fainscikit-learn:CompositeAPIs
1-denominator = np.dot(np.dot(W.T, W), H)
2+denominator = np.linalg.multi_dot([W.T, W, H])
ML libraries offer several optimized containers (e.g., NumPy ar-
rays, Tensors) for data processing. Updating containers,e.g., from
Python‚Äôs ListtoNumPy.Array , is another frequent change in ML
systems (P18). Ketkar et al . [42]discovered that in Java code, these
typemigrationsaremorecommonthanrenamerefactorings.More-
over, Table 1 shows that 85% of respondents who performed Trend
3,performitveryoften(VO).Alltherespondentsmanuallyperform
these changes, and 70% of respondents sought automation in IDEs.
5.1.6Trend 4 - Use advanced language features: Python of-
fers powerful features: (i) functions [ 65] such as boolandisinst-
ancethat can be used to simplify a conditional statement (P20),
(ii)literalssuchas [],{},()toefficientlycreatecontainersinstead
ofusingconstructorssuchas list(),dict(),tuple()(P21)(see
Listing 9). (iii) Python comprehension [ 66] to make code concise
and inline forloops (P22). Researchers [ 10,45] observed ML code
extensively operates on data, which results in expressions that are
longer and more complex than in traditional systems. Good soft-
wareengineeringprinciples[ 26,47]requirethatdeveloperschange
the code to make it concise and readable. However, 69% of the sur-
veyrespondentswhoperformedTrend4changesconfirmedthey
rarely performthis intheir project,and 30%of developerssought
automated help.
Listing9:Commit15d7634dinRasaHQ/rasa:Usesetliterals
instead of set constructor
1-set(utils.module_path_from_instance(p)
‚Ü©‚Üífor p in agent.policy_ensemble.policies)
2+{utils.module_path_from_instance(p)
‚Ü©‚Üífor p in agent.policy_ensemble.policies}
5.2 Improvements caused by Refactoring
Awareness (RQ2)
5.2.1 Impactofrefactoringawareness. Toanswerthisquestion,we
executedthePyCPatMinerandR-CPatMineronthestudycorpus
andcomparedtheresults.Wecompared,numberofchangegraphs,
number of patterns, and distribution of code instances per pattern
reported by both tools.AsshowninTable3,R-CPatMinerprocessed16%morechanged
methods,0.1BmoreASTnodesthanPyCPatMiner.PyCPatMiner
builds one change graph for each mapped code block pair (i.e., be-
foreandafterthechangedmethodbody).Therefore,R-CPatMiner
produces 16%morechange graphs, thus confirming the valus of
de-obfuscating change graphs that were previously obfuscated by
refactoring.ThentheR-CPatMinerminesallthegenerated change
graphsand extracts repeated isomorphic sub-graphs as patterns.
CPATMiner uses minimum frequencies of repeated subgraphs ùúéto
bethreeadherestotheRuleofThree[ 73],astandardrecurrence
measureinpatternanalysis.Therefore,allthepatternscontainat
least three code instances. We compared the number of patterns
generatedbytheR-CPatMinerandPyCPatMinerandobserved
thatR-CPatMinercaptures 15%morepatternsthanPyCPatMiner.
We also compared the distributions of the number of code in-
stancesperpatterninbothPyCPatMinerandR-CPatMiner.To
assessifthereisastatisticallysignificantdifferenceindistributions
ofthenumberofcodeinstancesperpatternreportedbyPyCPat-
Miner and R-CPatMiner, we applied the Wilcoxon Signed-Rank
test on the paired samples of number of code instances of eachpattern. The test rejected the null hypothesis that the density of
codeinstancesofthepatternproducedbyPyCPatMinerismore
thanitisinR-CPatMineratthesignificancelevelof5%(p-value
=1.12√ó10‚àí10). We used the Hodges-Lehman estimator to quantify
the difference between the two distributions, as it is appropriate to
be used withthe Wilcoxon Singed-Rank test. The valueturned out
to be 1, which is equal to the estimated median of the differencebetween the number of code instances per pattern from PyCPat-
Miner and R-CPatMiner. Therefore, R-CPatMiner extracts more
code change instances per pattern than the PyCPatMiner.
5.2.2 Evaluating the precision of PyRMiner. It is important for
PyRMiner to have a high precision as we use it to first matchtherefactoredcodeblocksthatwethenpasstoR-CPatMinerto
buildchangegraphs.Wefirstidentified18refactoringkindsthat
obfuscate fine-grained changes, i.e, the refactorings that change
methodsignaturesorshiftthemethodbodies.First,weexecuted
the PyRMiner on our study corpus and chose a statistically signifi-
cantrandomsampleofrefactoringinstancesforeachrefactoring
kind.Hence, usingat-test,weconclude with95%confidencethat
the precision of the refactoring detection is only ¬±5% for each
refactoring kind, as shown in Table 2.
Table 2: Precision of PyRMiner per refactoring kind
Refactoring Kind Precision (#TP) Refactoring Kind Precision (#TP)
Rename Method 96.32% (183) MoveAndRenameclass 96.67% (116)
Move Method 96.3% (156) Move class 100% (160)
Pull Up Method 86.46% (83) Extract Class 98.82% (84)
Push Down Method 89.36% (84) Extract Subclass 100% (45)
Extract Superclass 95.24% (40) Parameterize Variable 87.23% (82)
Split Parameter 91.66% (22) Move&RenameMethod 88.08% (133)
Rename Class 99.2% (124) Remove Parameter 97.56% (160)
Reorder Parameter 98.11% (104) Rename Parameter 93.59% (146)
Add Parameter 100% (192) Merge Parameter 91.07% (51)
Two of the authors that have more than three years of software
developmentexperienceandextensiveexpertiseinsoftwareevo-
lution manually validated the refactorings reported by PyRMiner.
743Discovering Repetitive Code Changes in Python ML Systems ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Most cases were straightforward and thus were validated individu-
ally,butbothauthorsinspectedsomechallengingcasestoreachan
agreement.Intotal,wevalidated2,062uniquerefactoringinstances,
outofwhich1,965weretruepositivesand97werefalsepositives.
This achieves an average precision of 95%, which is close to the
precision of the original Java-RMiner (99.6%). This also shows
theeffectivenessof JavaFyPytoadaptJavaAST-analysistoolsto
Python.Wereleaseallthevalidatedrefactoringinstancesonour
companionwebsite[ 21].Tothebestofourknowledge,thisisthe
largest to date Python data-set of validated refactoring instances.
Recallindicatestheproportionofactualrefactoringsidentified
byPyRMiner.Javaresearchersusepreviouslyformedunbiasedora-clestocomputerecalloftools[
42,85].Tothebestofourknowledge,
thereisnosuchunbiasedrefactoringoracleforPython.Considering
thecomplexityofbuildinganoracleandourmainfocus(toretrieve
correctcode-blockmappingstomakePyCPatMinerrefactoring-
aware), we leave computing recall as future work. However, we ob-
servedR-CPatMinerdetects16%morechange-graphs(i.e.,mappedcodeblocks)and15%morepatternsthanthePyCPatMiner,which
strongly indicates that the PyRMiner has a satisfactory recall.
5.3 Runtime performance of R-CPatMiner,
PyCPatMiner, and PyRMiner (RQ3)
A fast execution time persuades the users that the adapted tools
can be run on their systems (even on a consumer laptop) in anacceptable amount of time. It will enable the creation of biggerdatasets of repetitive code changes to strengthen the validity of
empiricalresearchortrainlearning-basedcoderecommendation
systems, aswellas enable innovativeuses of code changepattern
miningatcommittime.Therefore,weevaluatedtheexecutiontimesoftheadaptedtoolsandcomparedthemwiththeJavacounterparts.
Table 3: Analysed data set and execution time.
Java
CPATMinerPy-CPATMinerR-CPATMiner
Total changed methods 824K 1M 1.16M
Total AST nodes of changed methods 92M 4.5B 4.6BTotal changed graph nodes 8M 4M 4.7M
Total patterns 17K 24K 28K
Execution time <8hours <12hours <19hours
1The data of the Java-CPATMiner is obtained from its original paper [58]
To measure the execution time of the tools, we executed the
PythonadaptedRMiner,CPatMiner,andR-CPatMineronalarge
corpusandcomparedtheexecutiontimewiththeJavaversionof
thetools.Weexecutedeachtoolseparatelyonthesamemachine
with the following specifications: Intel Core i9 CPU @ 2.90GHz, 32
GB DDR4 memory, 1 TB SSD, macOS 10.14.6, and Java 13.0.1 √ó64.
First,werecordtherunningtimeofthe typeinference tool,Py-
Type[30] (version 2020.10.08). PyTypeis decoupled from JavaFyPy.
Therefore,wecomputedtheexecutiontimeof PyTypeseparately.
PyTypetook on mean 360ms and 61ms on median for type infer-
ence of all changed files in a commit. We pushed the inferred type
information of all the changed files in all the studied projects‚Äô com-
mitstoarepository[ 69]inGithub.Similarto Typeshed [86],atype
repository of Python library APIs that the library clients use fortypeannotations,researcherscanfast-tracktheiranalysisbysimply
reusing this inferred type information .
To record running time of PyRMiner, we followed the steps
used by Tsantalis et al. [ 85] for computing the running time of
their Java-RMiner. We recorded the time required for parsing the
sourcecodeofthecommit(anditsparent),andthetimerequired
fordetectrefactorings.OuranalysisshowsthatPyRMinertakes
55msonmedianand 296.32ms onmeantoprocessaPythoncom-
mit. Tsantalis et al. [ 85] found that the Java version of RMiner
takes44mson median and 253mson mean to process one Java
commit. Therefore, PyRMiner takes reasonable time overhead for
theadditional processing(i.e.,AST transformation),andwill not
impacttheprimarygoalof RMiner,i.e.,createlargerrefactoring
datasets to strengthen the validity of empirical studies or enable
novel applications of refactoring mining [85].
Table 3 shows the size of processed data and the execution time
ofthetools,Java-CPatMiner,PyCPatMiner,andR-CPatMiner.
TherunningtimeofthePyCPatMinerandR-CPatMinerisless
than 12 hours and 19 hours respectively, whereas Java-CPatMiner
takes less than 8 hours to mine patterns. However, the Java and
Pythoncorpusisdiverse(seeTable3).Hence,itishardtomakea
faircomparison. Nguyenetal . [58]statethattheprimarygoalof
theCPatMineristominethecorpusweeklytobuildadatabaseof
patterns.WebelievethatR-CPatMinerandPyCPatMinerhave
reasonable execution times for achieving the same goal.
6 IMPLICATIONS
Wepresentactionable,empirically-justifiedimplicationsforfour
audiences: (i) researchers, (ii) tool builders and IDE designers, (iii)
ML library vendors, and (iv) developers and educators.
6.1 Researchers
R1. ExploitapplicationsofchangerepetitivenessofPythonML software (RQ1, RQ3).
In the past, researchers exploited the
repetitiveness of changes in Java systems through: code comple-tion [
13,34,43,55,56], automated program repair [ 6,9,50], API
recommendation[ 32,55],typemigration[ 40],librarymigration[ 3,
18,24,39,84],andautomatedrefactoring[ 19,28].Usingourrichand
diversedatasetof28KchangepatternsinstancesandourJavaFyPy,
researchers can bring the same benefits to Python ML systems.R2. FoundationstostudyPythonMLSoftwareEvolution(RQ1,RQ2,RQ3).
Despite the widespread use of Python ML systems, its
evolutionandmaintenancetasksaretheleastautomatedandthe
least studied due to the unavailability oftool support to study ML
systems [ 22]. Previously, researchers have built infrastructure to
studymanyaspectsofsoftwareevolution.Forexample, RMiner[85]
andRefDiff[77] mine refactorings, TypeFactMiner [42] mines type
changes,MigrationMiner [3]andAPIMigrator [25]mineAPImigra-
tions,CPATMiner [58]andCodingTracker[ 54]minefine-grained
repetitive code changes in Java. This rich infrastructure allowsresearchers to study Java software systems, and there are hun-dreds of published papers that are built upon this infrastructure.
Unfortunately, they miss the whole ecosystem of Python ML code-
bases.Researcherscanuseourdataandtoolsettostudywhether
previously-held beliefs from traditional software are still valid for
MLsystemsorwhetherweneedtodesignnewtoolsandworkflows
744ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Malinda Dilhara, Ameya Ketkar, Nikhith Sannidhi, and Danny Dig
(e.g., version-control systems, code smells, technical debt, etc.) that
are specific to ML.
R3. EnhanceexistingresearchandtoolsforMLsystems(RQ1,RQ3):
Our infrastructure can be used to enhance the existing re-
search on ML systems. For example, Tang et al . [82]introduce
a taxonomy of refactoring kinds performed in Java ML systems,Humbatova et al
. [35], Islam et al . [37,38]introduce a taxonomy
of bugs in ML systems based on manual analysis of StackOverFlow
posts. These studies perform extensive manual analysis to build
varioustaxonomiesusingasmallerdatasetofchanges.Withour
significantlylargerdataset(of28Kchangepatterns),theycansig-
nificantly extend or further validate their taxonomies. Moreover,
researchers showed the potential of leveraging ML techniques for
codecompletion[ 16,32].However,theytraintheMLmodelseither
on a noisy or small dataset which could reduce the accuracy of the
recommendations.Researcherscanuseourtools/datasettotrain
theirmodelsonalarge,curateddatasetandimprovetheiraccuracy.
R4. Build novel applications for ML developers (RQ1). Re-
searchers can also use our tools/dataset to build novel applications.
BraiekandKhomh [10]observedMLlibrariesarecorecomponents
ofMLsystemsandarefrequentlyevolving,whichcausesdeveloper
frustration [ 22,92]. A tutoring system can suggest to developers
whichconstructstouseinordertomodernizetheirMLcode.For
example,atutoringsystemcouldrecommendchangingthecodeto
useMLlibraryAPIsinsteadof forloops,orremovingredundant
matrixoperations(orother changesfromRQ1:Table1).Moreover,
a tutor system can recommend novice programmers how to use
advanced language features (see Trend 4 in RQ1:Table 1).R5. Revisitexistingstudiesandtoolsformakingthemrefac-toring-aware (RQ2).
Thereexistaplethoraofresearchtoolsfor
mining software repositories, and hundreds of researchers usedthese tools to conduct empirical studies. Given that refactorings
obfuscateprogramelementsduringsoftwareevolution,weshowed
thatmakingastateof thearttoolsuchas CPatMinerrefactoring
awareincreasesitsoveralleffectivenessbyasmuchas15%.Wecall
theresearchcommunitytoadaptsimilarmethodsandtorevisitpre-
vious results obtained with tools that were not refactoring-aware.
6.2 Tool Builders and IDE Designers
T1. New inspirations for tool development (RQ1). To help
tool builders invest resources where automation is most needed, in
Table 1 we present 22 patterns along with the ML developers re-
questforautomation.Movingto withstatementsandusingContext
managersisthemostprevalentchangepatternamongtheanalysed
patterns(SeeRQ1,P1-P8).Inthesurvey,74%ofrespondentssuggest
toolsthatinspectdeeplearningcodebasesandrecommendusing
withstatementsto(i)turnonoroffgradientcalculations(P2),(ii)
specify hardware type (P3), (iii) change variable scopes (P4), and
(iv)executedependencies(P5).Respondentsfurthersuggestedtools
to(i)moveContextmanagerinvocationsto withstatements,and
(ii) detect misuses of Context managers.
6.3 ML Library vendors
L1. Understand ML Library Usage (RQ1). ML library vendors
continuouslyimprovelibrariesandintroducenewMLlibrariesat
an unprecedented rate [ 11,22]. Library developers deprecate APIs,introducemoreefficientalternativeAPIs(e.g.,Table1:P18),and
splitMLlibraries[ 22].Ourfindings,theaccompanyingdataset[ 21],
and the tools we developed can help ML library vendors to under-
standwhatAPIsaremostcommonlyused,misused,andunderused,
andhowthedevelopersadapttonewAPIs.Thus,theycanmakein-
formed, empirically-justified decision s to improve features [ 23,49].
6.4 Software Developers and Educators
S1. Richeducationalresource(RQ1) Developerslearnandedu-
catorsteachnewprogrammingconstructsthroughexamples.Robil-
lardetal.[ 71]studiedthechallengesoflearningAPIsandconcluded
that one of the important factors is the lack of usage examples. Us-
ingourdatasetof28Kcodechangepatternsthatweminedinour
corpus,developersandeducatorscanlearnfromreal-worldcode
transformations(e.g.,transformingto multi_dot ).Weprovide22
empiricallyjustifiedcodechangepatternsthatimproveMLcode
frommanyaspects, includingspeed ,codequality,andreadability.
MLdeveloperscanabsorbthesechangestotheircodeandimprove
the code. We released this through an educational resource [21].
7 THREATS TO VALIDITY
Internal Validity: Can we trust the results produced by tools? The
findingsof ourstudydependon theaccuracyofour toolstomine
code change patterns in a refactoring aware manner. We rely on
type inference for augmenting the AST with rich type information.
SinceType inference deduces the types of elements by statically
analysing the program, it may not accurately detect them (com-pared to the run time). This can effect the quality of mappings
reportedbyR-CPatMinerandthestatementsmatchedbyRMiner.
To mitigate this threat, we use PyType[30], a mature tool devel-
oped by Google. Thousands of projects at Google and other places
rely upon PyTypeto keep their codes well-typed [ 30]. Moreover,
wevalidateJavaFyPy‚Äôseffectivenessattransformingavarietyof
syntacticvariationsupon12MASTnodesfrom14popularprojects.
Our manual validations shows that PyRMiner reports refactorings
withhighprecision(95%).Wealsomanuallyvalidated2,500most
popular patterns produced by R-CPatMiner.
Toavoidthe experimentalbias,wefollowedthebestpractices[ 14,
88] for applying thematic analysis by achieving 80% inter coder
agreement when labelling the patterns.External Validity:
Do our results generalize? We studied 1000
projects from a wide range of application domains, making thestudy results generalizable to other open-source projects in sim-ilar domains. However, a study of proprietary code bases might
revealothertrends.Nevertheless,wemakeourtoolsavailableso
thatotherscanusethemtominepatternsinproprietarycodebases.
Moreover, R-CPatMiner reports numerous patterns, we manually
analyzedasubsetofthem;acompleteinvestigationisnotpracti-
cal. To mitigate this, we ranked the code change patterns in five
dimensions and manually validated the top ones.
Verifiability: Can others replicate our results? To ensure replicabil-
ity, we make the tools and the data publicly available [21].
8 RELATED WORK
8.0.1StudiesonevolutionofMLsoftwaresystems .Researchers
have studied repetitive tasks of ML systems from many aspects.
745Discovering Repetitive Code Changes in Python ML Systems ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
Humbatovaetal .[35]andIslametal .[37,38]introduceataxonomy
ofML-relatedbugsandbugfixpatterns,Shenetal .[76]studybugs
in Deep Learning(DL) compilers, and Yanet al .[90]study numer-
ical bugs in DL systems. Zhang et al . [91]observe DL program
failuresat Microsoftand highlighttheneedfor DL-specifictools to
fixDLbugs.Lwakatareetal .[46],Zhangetal .[92]classifycommon
challengesthatMLdevelopersfacewhenmaintainingandevolving
ML systems. Wan et al . [87]found anti-patterns and misused APIs
in MLlibraries. Nguyen etal . [57]create adatabase of DLmodels
extractedfromGitHubtoutilizeasdefaultmodelsandaccelerate
AutoML.Amershietal .[4]performafieldstudyatMicrosoftand
proposebest practicestoaddresscommonchallenges thatrepeats
amongMLsystems.Incontrast,ourfocusisonunderstandingfine-grainedrepeatedcodechangesthattheMLdevelopersperformand
their motivations.
TheclosestrelatedworkisbyTangetal .[82].Theauthorsstudy
327 gitpatches from26 JavaML systems and presenta taxonomy
ofrefactoringkindsthatoccurredinMLsystems.Incontrast,we
quantitativelyandqualitativelystudiedfine-grainedcodechange
patterns in a significantly larger corpus: 1000 Python-based ML
systems comprising 4,166,520 git patches. Our findings include
both refactorings (e.g., P1, P9) and other semantics-modifying codechanges (e.g., P2, P6). Moreover, we cross-validated our findings bysurveying97MLdevelopers.Wemakeourtoolsavailabletofurther
enhance the science and tooling for evolving Python ML systems.
8.0.2Studies on repetitive code changes .Researchers have
conductedmanystudiesonrepetitivecodechanges.Nguyenetal .
[58,59]use a graph-based algorithm to mine fine-grained code
changesatcommitlevel.Theyconductalarge-scalestudyonthe
repetitivenessofcodechangesinJavasoftwareevolutionandshowthatrepetitivenessiscommoninsmallgranularity(numberoflines),anditdropsexponentiallyasthegranularityincreases.Researchers
havealsostudiedrepetitivenessfromthevantagepointofhigher-
level maintenance and evolution tasks, (i) Dig and Johnson [20],
Cossette and Walker [17]study incompatibilities between API ver-
sions, (ii) Teyton et al . [84]mine the library migrations trends and
observehowfrequently,when,andwhytheyareperformed,and
(iii)Ketkaretal .[40]conductalarge-scalestudyontypechangesin
Java systems and reveal that type changes are more frequent than
renaming All of these studies focus on repetitiveness in traditional
systemsanddonotrevealthekindsofrepetitivechangesthedevel-
opers perform in MLsoftware. In contrast, we study the practices
of fine-grained code changes in ML systems and found four trends
of fine-grained changes. 71% of the sur veyed developers requested
automation support for the identified trends in their IDEs.
Previous researchers looked at Python idioms and how they
wereusedinPythonsystems. Alexandruetal . [1]presentanon-
exhaustive list of Python idioms gleaned from a developer survey.
Sakulniwat et al . [74]studied the evolution of Python withstate-
mentoverthetime. Phan-udometal . [63]usedeveloperforums
to builda database ofPython idioms andpropose Teddy, asystem
that recommends idioms to developers. In comparison, we provide
R-CPatMiner, which can mine repetitive code changes in Python
systemsinrefactoringawaremanner.R-CPatMinercanbeused
to increase related work‚Äôs idiom databases.Researchersreimplementedcertain JavaASTminingtoolsfor
Pythonfromscratch.PYREF[ 5]isaPythonreimplementofJava
RMiner[ 85]thatidentifies9kindsofPythonrefactoring.Incon-
trast,ourPyRMinerdoesnotrequirereimplementingfromscratch,
and it finds alllegitimate Java refactoring in Python. Moreover, we
manually validated 18 kinds of refactoring, as shown in Table 2.
Golubevetal . [29]developedPythonChangeMiner,atoolthat
usesfgPDG[58] to mine Python repetitive code changes involv-
ing function calls. In contrast, we present JavaFyPy, a techniqueforadaptingJavaASTminingtoolstoPythonwithouthavingto
rewritethemfromthegroundup.WeadaptedCPatMiner[ 58]and
RMiner[ 85]toPythonusingJavaFyPy,andsubsequentlycreated
R-CPatMiner,a refactoring-awarecodechange patternminerfor
Python systems.
Researchersproposedseveraltechniquesthatinfer specifickinds
ofcodechangepatterns.Forexample,Revisar[ 72],GetAFix[ 6],
andDeepDelta[ 50]inferrepeatedbugfixesandcompilationerrors
fromcommithistories. LibSync[ 60],MEditor[ 89],andA3[ 44]
infer the adaptations required to perform library migration. Ketkar
etal.[41]developedTCInferatechniquetoaccuratelyinferrewrite
rulesfortypechangesfromaproject‚Äôsversionhistory.Theyalso
proposed IntelliTC [ 81], a configurable IDE refactoring plugin
thatautomatestheseinferredtypechanges.Incontrast,wediscover
previously unknown patterns in ML systems that involve adapting
ML libraries (E.g. P9 - forloop toNumPy).
9 CONCLUSIONS
Thispaperpresentsthefirstandthelargeststudyoffine-grained
code change patterns in Python-based ML software systems. To
provideuniqueinsights,weusecomplementaryempiricalmethods:
(i) mining 1000 software repositories containing over 58 million
LOC, (ii) using thematic analysis to identify the groups and trends,
and (iii) surveying 97 ML developers. To conduct this study and ad-
vancethescienceandtoolinginPythonMLsoftwareevolution,we
designed a novel technique, JavaFyPy, to reuse, adapt and improve
upon the Java state-of-the-art AST mining tools. We introduce a
noveltoolR-CPatMinerthatperformsrefactoring-awarechange
patternminingintheversionhistoryofPythonprojects.Wepresent
22 code change pattern groups in four trends, where 10 of them
are specific to ML. In the developer survey, 71% of the respondents
requestedthesepatternsautomatedintheirIDEs.Theresultsand
thetoolspresentedinthisstudyhaveactionableimplicationsfor
researchers, tool builders, library designers, ML developers, and
educators.Wehopethatthispaperandourreadilyavailabledataset
and tools [ 21] catalyzes the community to advance the science and
tooling for the evolution of Python-based ML systems.
10 ACKNOWLEDGEMENTS
WewouldliketothankEllickChan,RahulKhanna,BobBanfield,
Julia Romero, Carla Pomian, Dorin Pomian, students from CSCI
7000-08-Spring2022atCUBoulder,CUPLVgroupatCUBoulder,
and the anonymous reviewers for their insightful and construc-
tive feedback for improving the paper. This research was partially
funded through the NSF grants CCF-1553741, CNS-1941898, and
the Industry-University Cooperative Research Center on Pervasive
Personalized Intelligence.
746ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA Malinda Dilhara, Ameya Ketkar, Nikhith Sannidhi, and Danny Dig
REFERENCES
[1]Carol V. Alexandru, Jos√© J. Merchante, Sebastiano Panichella, Sebastian Proksch,
Harald C. Gall, and Gregorio Robles. 2018. On the Usage of Pythonic Idioms.
InACM SIGPLAN International Symposium on New Ideas, New Paradigms, and
Reflections on Programming and Software (Boston, MA, USA) (Onward! 2018).
ACM, New York, NY, USA, 1‚Äì11. https://doi.org/10.1145/3276954.3276960
[2]Miltiadis Allamanis and Charles Sutton. 2014. Mining Idioms from Source Code.
InFSE 2014 (Hong Kong, China). Association for Computing Machinery, New
York, NY, USA, 472‚Äì483. https://doi.org/10.1145/2635868.2635901
[3]Hussein Alrubaye, Mohamed Wiem Mkaouer, and Ali Ouni. 2019. Migration-
Miner:AnAutomatedDetectionToolofThird-PartyJavaLibraryMigrationattheMethodLevel.In ICSME2019 .414‚Äì417. https://doi.org/10.1109/ICSME.2019.00072
[4]SaleemaAmershi,AndrewBegel,ChristianBird,RobertDeLine,HaraldGall,Ece
Kamar, Nachiappan Nagappan, Besmira Nushi, and Thomas Zimmermann. 2019.
SoftwareEngineeringforMachineLearning:ACaseStudy.In ICSE(Montreal,
Quebec, Canada) (ICSE-SEIP ‚Äô19). IEEE Press, Piscataway, NJ, USA, 291‚Äì300.
https://doi.org/10.1109/ICSE-SEIP.2019.00042
[5]Hassan Atwi, Bin Lin, Nikolaos Tsantalis, Yutaro Kashiwa, Yasutaka Kamei,
NaoyasuUbayashi,GabrieleBavota,andMicheleLanza.2021.PYREF:Refactoring
Detection in Python Projects. In 2021 IEEE 21st International Working Conference
on Source Code Analysis and Manipulation (SCAM). 136‚Äì141. https://doi.org/10.
1109/SCAM52516.2021.00025
[6]JohannesBader,AndrewScott,MichaelPradel,andSatishChandra.2019. Getafix:LearningtoFixBugsAutomatically. Proc.ACMProgram.Lang. 3,OOPSLA,Article
159 (Oct. 2019), 27 pages. https://doi.org/10.1145/3360585
[7]Earl T. Barr, Yuriy Brun, Premkumar Devanbu, Mark Harman, and FedericaSarro. 2014. The Plastic Surgery Hypothesis. In FSE 2014 (Hong Kong, China)
(FSE 2014). Association for Computing Machinery, New York, NY, USA, 306‚Äì317.
https://doi.org/10.1145/2635868.2635898
[8]AmineBarrak,EllisE.Eghan,andBramAdams.2021. OntheCo-evolutionof
MLPipelinesandSourceCode-EmpiricalStudyofDVCProjects.In SANER2021 .
422‚Äì433. https://doi.org/10.1109/SANER50967.2021.00046
[9]RohanBavishi,HiroakiYoshida,andMukulR.Prasad.2019. Phoenix:Automated
Data-Driven Synthesis of Repairs for Static Analysis Violations. In ESEC/FSE
2019(Tallinn, Estonia) (ESEC/FSE 2019). ACM, New York, NY, USA, 613‚Äì624.
https://doi.org/10.1145/3338906.3338952
[10]Houssem Ben Braiek and Foutse Khomh. 2020. On testing machine learning
programs. JournalofSystemsandSoftware 164(2020),110542. https://doi.org/
10.1016/j.jss.2020.110542
[11]Houssem Ben Braiek, Foutse Khomh, and Bram Adams. 2018. The Open-Closed
Principle of Modern Machine Learning Frameworks. In MSR ‚Äô18(Gothenburg,
Sweden)(MSR ‚Äô18) . Association for Computing Machinery, New York, NY, USA,
353‚Äì363. https://doi.org/10.1145/3196398.3196445
[12]Virginia Braun and Victoria Clarke.2006. Using thematic analysis in psychology.Qualitativeresearchinpsychology. QualitativeResearchinPsychology 3,2(2006),
77‚Äì101.
[13]Marcel Bruch, Martin Monperrus, and Mira Mezini. 2009. Learning from Exam-
ples to Improve Code Completion Systems. In ESEC/FSE ‚Äô09 (Amsterdam, The
Netherlands) (ESEC/FSE ‚Äô09). Association for Computing Machinery, New York,
NY, USA, 213‚Äì222. https://doi.org/10.1145/1595696.1595728
[14]John L Campbell, Charles Quincy, Jordan Osserman, and Ove K Pedersen. 2013.
Codingin-depthsemistructuredinterviews:Problemsofunitizationandinter-
coder reliability and agreement. Sociological Methods & Research 42, 3 (2013),
294‚Äì320. https://doi.org/10.1177/0049124113500475
[15]ZhenpengChen,YanbinCao,YuanqiangLiu,HaoyuWang,TaoXie,andXuanzhe
Liu.2020. AComprehensiveStudyonChallengesinDeployingDeepLearning
Based Software. In FSE(Virtual Event, USA) (ESEC/FSE 2020). Association for
ComputingMachinery,NewYork,NY,USA,750‚Äì762. https://doi.org/10.1145/
3368089.3409759
[16]Zimin Chen, Steve James Kommrusch, Michele Tufano, Louis-No√´l Pouchet,Denys Poshyvanyk, and Martin Monperrus. 2019. SEQUENCER: Sequence-to-Sequence Learning for End-to-End Program Repair. TSE 2019 (2019), 1‚Äì1.
https://doi.org/10.1109/TSE.2019.2940179
[17]Bradley E. Cossette and Robert J. Walker. 2012. Seeking the Ground Truth: A
RetroactiveStudyontheEvolutionandMigrationofSoftwareLibraries (FSE‚Äô12).
ACM, New York, NY, USA, Article 55, 11 pages. https://doi.org/10.1145/2393596.
2393661
[18]Barth√©l√©myDagenaisandMartinP.Robillard.2011. RecommendingAdaptive
ChangesforFrameworkEvolution. ACMTrans.Softw.Eng.Methodol. 20,4,Article
19 (Sept. 2011), 35 pages. https://doi.org/10.1145/2000799.2000805
[19]Danny Dig, Can Comertoglu, Darko Marinov, and Ralph Johnson. 2006. Au-
tomated Detection of Refactorings in Evolving Components. In ECOOP‚Äô06
(Nantes,France) (ECOOP‚Äô06) .Springer-Verlag,Berlin,Heidelberg,404‚Äì428. https:
//doi.org/10.1007/11785477_24
[20]DannyDigandRalphJohnson.2006.HowDoAPIsEvolve?AStoryofRefactoring:
Research Articles. J. Softw. Maint. Evol. 18, 2 (March 2006), 83‚Äì107.[21]Malinda Dilhara. 2022. Discovering Repetitive Code Changes in Python-based ML
Systems. https://mlcodepatterns.github.io Accessed: 2022-02-07.
[22]Malinda Dilhara, Ameya Ketkar, and Danny Dig. 2021. Understanding Software-
2.0: A Study of Machine Learning Library Usage and Evolution. ACM Trans.
Softw.Eng.Methodol. 30,4,Article55(July2021),42pages. https://doi.org/10.
1145/3453478
[23]Robert Dyer,HrideshRajan, HoanAnh Nguyen,and TienN. Nguyen. 2014. Min-
ing Billions of AST Nodes to Study Actual and Potential Usage of Java Language
Features. In ICSE(Hyderabad, India) (ICSE 2014). Association for Computing Ma-
chinery, New York, NY, USA, 779‚Äì790. https://doi.org/10.1145/2568225.2568295
[24]MattiaFazzini,QiXin,andAlessandroOrso.2019. AutomatedAPI-UsageUpdate
forAndroidApps.In ISSTA2019 (Beijing,China) (ISSTA2019).Associationfor
ComputingMachinery,NewYork,NY,USA,204‚Äì215. https://doi.org/10.1145/
3293882.3330571
[25]Mattia Fazzini, Qi Xin, and Alessandro Orso. 2020. APIMigrator: An API-Usage
Migration Tool for Android Apps. In MOBILESoft‚Äô20 (Seoul, Republic of Korea)
(MOBILESoft‚Äô20).AssociationforComputingMachinery,NewYork,NY,USA,
77‚Äì80. https://doi.org/10.1145/3387905.3388608
[26]Michael Feathers. 2004. Working Effectively with Legacy Code: WORK EFFECT
LEG CODE _p1. Prentice Hall Professional.
[27]Eclipse foundation. 2021. JDT Core Component. Eclipse. https://www.eclipse.
org/jdt/core/#JDT_CORE Accessed: 2021-03-31.
[28]LyleFranklin,AlexGyori,JanLahoda,andDannyDig.2013. LAMBDAFICATOR:
FromImperativetoFunctionalProgrammingthroughAutomatedRefactoring.
InICSE(San Francisco, CA, USA) (ICSE ‚Äô13). IEEE Press, 1287‚Äì1290. https:
//doi.org/10.1109/ICSE.2013.6606699
[29]YaroslavGolubev,JiaweiLi,ViacheslavBushev,TimofeyBryksin,andIftekhar
Ahmed. 2021. Changes from the trenches: Should we automate them? arXiv
preprint arXiv:2105.10157 (2021).
[30]Google. 2021. PyType. https://github.com/google/pytype Accessed: 2021-03-31.
[31]FabriceHarel-Canada,LingxiaoWang,MuhammadAliGulzar,QuanquanGu,
and Miryung Kim. 2020. Is Neuron Coverage a Meaningful Measure for Testing
DeepNeuralNetworks?.In FSE(VirtualEvent,USA) (ESEC/FSE2020) .ACM,New
York, NY, USA, 851‚Äì862. https://doi.org/10.1145/3368089.3409754
[32]XinchengHe,LeiXu,XiangyuZhang,RuiHao,YangFeng,andBaowenXu.2021.
PyART: Python API Recommendation in Real-Time. In ICSE 2021. 1634‚Äì1645.
https://doi.org/10.1109/ICSE43902.2021.00145
[33]AbramHindle,EarlT.Barr,MarkGabel,ZhendongSu,andPremkumarDevanbu.2016. OntheNaturalnessofSoftware. Commun.ACM 59,5(April2016),122‚Äì131.
https://doi.org/10.1145/2902362
[34]ReidHolmes,RobertJ.Walker,andGailC.Murphy.2006. ApproximateStructural
Context Matching: An Approach to Recommend Relevant Examples. IEEE Trans.
Softw. Eng. 32, 12 (Dec. 2006), 952‚Äì970. https://doi.org/10.1109/TSE.2006.117
[35]NargizHumbatova,GunelJahangirova,GabrieleBavota,VincenzoRiccio,Andrea
Stocco, and Paolo Tonella. 2020. Taxonomy of Real Faults in Deep Learning
Systems.In ICSE‚Äô20(Seoul,SouthKorea) (ICSE‚Äô20).ACM,NewYork,NY,USA,
1110‚Äì1121. https://doi.org/10.1145/3377811.3380395
[36]Nargiz Humbatova, Gunel Jahangirova, and Paolo Tonella. 2021. DeepCrime:Mutation Testing of Deep Learning Systems Based on Real Faults. In ISSTA-
2021(Virtual,Denmark) (ISSTA2021).ACM,New York,NY,USA,67‚Äì78. https:
//doi.org/10.1145/3460319.3464825
[37]Md Johirul Islam, Giang Nguyen, Rangeet Pan, and Hridesh Rajan. 2019. A
Comprehensive Study on Deep Learning Bug Characteristics. In ESEC/FSE 2019
(Tallinn,Estonia) (ESEC/FSE2019).Associationfor ComputingMachinery,New
York, NY, USA, 510‚Äì520. https://doi.org/10.1145/3338906.3338955
[38]MdJohirulIslam,RangeetPan,GiangNguyen,andHrideshRajan.2020.RepairingDeepNeuralNetworks:FixPatternsandChallenges.In ICSE‚Äô20(Seoul,Republic
of Korea) (ICSE ‚Äô20). ACM, New York, NY, USA, 11 pages. https://doi.org/10.
1145/1122445.1122456
[39]Suhas Kabinna, Cor-Paul Bezemer, Weiyi Shang, and Ahmed E. Hassan. 2016.
Logging Library Migrations: A Case Study for the Apache Software Foundation
Projects.In MSR‚Äô16(Austin,Texas) (MSR‚Äô16) .ACM,NewYork,NY,USA,154‚Äì164.
https://doi.org/10.1145/2901739.2901769
[40]Ameya Ketkar, Ali Mesbah, Davood Mazinanian, Danny Dig, and Edward Af-tandilian. 2019. Type Migration in Ultra-Large-Scale Codebases. In ICSE ‚Äô19
(Montreal,Quebec,Canada) (ICSE‚Äô19).IEEEPress,1142‚Äì1153. https://doi.org/
10.1109/ICSE.2019.00117
[41]Ameya Ketkar, Oleg Smirnov, Nikolaos Tsantalis, Danny Dig, and TimofeyBryksin. 2022. Inferring and Applying Type Changes. In 44th International
ConferenceonSoftwareEngineering(ICSE‚Äô22) (Pittsburgh,UnitedStates) (ICSE
‚Äô22). ACM. https://doi.org/10.1145/3510003.3510115
[42]AmeyaKetkar,NikolaosTsantalis,andDannyDig.2020. UnderstandingType
Changes in Java. In FSE(Virtual Event, USA) (ESEC/FSE 2020). Association for
ComputingMachinery,NewYork,NY,USA,629‚Äì641. https://doi.org/10.1145/
3368089.3409725
[43]Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Automatic
Patch Generation Learned from Human-Written Patches. In ICSE(San Francisco,
CA, USA) (ICSE ‚Äô13). IEEE Press, 802‚Äì811.
747Discovering Repetitive Code Changes in Python ML Systems ICSE ‚Äô22, May 21‚Äì29, 2022, Pittsburgh, PA, USA
[44]M.Lamothe,W.Shang,andT.Chen.2020. A3:AssistingAndroidAPIMigrations
Using Code Examples. TSE 2020 01 (apr 2020), 1‚Äì1. https://doi.org/10.1109/TSE.
2020.2988396
[45]Jiakun Liu, Qiao Huang, Xin Xia, Emad Shihab, David Lo, and Shanping Li. 2020.
Is Using Deep Learning Frameworks Free? Characterizing Technical Debt in
Deep Learning Frameworks. In ICSE(Seoul, South Korea) (ICSE-SEIS ‚Äô20). ACM,
New York, NY, USA, 1‚Äì10. https://doi.org/10.1145/3377815.3381377
[46]Lucy Ellen Lwakatare, Aiswarya Raj, Jan Bosch, Helena Holmstr√∂m Olsson,
and Ivica Crnkovic. 2019. A Taxonomy of Software Engineering Challengesfor Machine Learning Systems: An Empirical Investigation. In Agile Processes
in Software Engineering and Extreme Programming, Philippe Kruchten, StevenFraser, and Fran√ßois Coallier (Eds.). Springer International Publishing, Cham,
227‚Äì243.
[47]RobertCMartin.2009. Cleancode:ahandbookofagilesoftwarecraftsmanship.
Pearson Education.
[48] Matplotlib. 2021. Matplotlib. https://matplotlib.org Accessed: 2021-05-05.
[49]Davood Mazinanian, Ameya Ketkar, Nikolaos Tsantalis, and Danny Dig. 2017.
UnderstandingtheUseofLambdaExpressionsinJava. Proc.ACMProgram.Lang.
1, OOPSLA, Article 85 (Oct. 2017), 31 pages. https://doi.org/10.1145/3133909
[50]AliMesbah,AndrewRice,EmilyJohnston,NickGlorioso,andEdwardAftandilian.
2019. DeepDelta: Learning to Repair Compilation Errors. In ESEC/FSE. 925‚Äì936.
https://doi.org/10.1145/3338906.3340455
[51]Emerson Murphy-Hill, Chris Parnin, and Andrew P. Black. 2009. How We
Refactor,andHowWeKnowIt.In ICSE‚Äô09 (ICSE‚Äô09) .AssociationforComputing
Machinery, New York, NY, USA, 287‚Äì297. https://doi.org/10.1109/ICSE.2009.
5070529
[52]Stas Negara, Nicholas Chen, Mohsen Vakilian, Ralph E. Johnson, and Danny Dig.2013. AComparativeStudyofManualandAutomatedRefactorings.In ECOOP‚Äô13
(Montpellier,France) (ECOOP‚Äô13).Springer-Verlag,Berlin,Heidelberg,552‚Äì576.
https://doi.org/10.1007/978-3-642-39038-8_23
[53]StasNegara,MihaiCodoban,DannyDig,andRalphE.Johnson.2014.MiningFine-GrainedCodeChangestoDetectUnknownChangePatterns.In ICSE(Hyderabad,
India)(ICSE2014).AssociationforComputingMachinery,NewYork,NY,USA,
803‚Äì813. https://doi.org/10.1145/2568225.2568317
[54]Stas Negara, Mohsen Vakilian, Nicholas Chen, Ralph E. Johnson, and Danny Dig.
2012. Is It Dangerous to Use Version Control Histories to Study Source Code
Evolution?.In ECOOP‚Äô12 (Beijing,China) (ECOOP‚Äô12).Springer-Verlag,Berlin,
Heidelberg, 79‚Äì103. https://doi.org/10.1007/978-3-642-31057-7_5
[55]AnhTuanNguyen,MichaelHilton,MihaiCodoban,HoanAnhNguyen,LilyMast,EliRademacher,TienN.Nguyen,andDannyDig.2016. APICodeRecommendation
Using Statistical Learning from Fine-Grained Changes. ACM, New York, NY, USA,
511‚Äì522. https://doi.org/10.1145/2950290.2950333
[56] AnhTuanNguyen,TungThanhNguyen,HoanAnhNguyen,AhmedTamrawi,
Hung Viet Nguyen, Jafar Al-Kofahi, and Tien N. Nguyen. 2012. Graph-Based
Pattern-Oriented,Context-SensitiveSourceCodeCompletion.In ICSE(Zurich,
Switzerland) (ICSE ‚Äô12). IEEE Press, 69‚Äì79.
[57]Giang Nguyen, Johir Islam, Rangeet Pan, and Hridesh Rajan. 2022. Manas:
MiningSoftwareRepositoriestoAssistAutoML.In ICSE‚Äô22:The44thInternational
Conference on Software Engineering (Pittsburgh, PA, USA). https://doi.org/10.
1145/3510003.3510052 To appear.
[58]H.Nguyen,T.N.Nguyen,D.Dig,S.Nguyen,H.Tran,andM.Hilton.2019. Graph-
Based Mining of In-the-Wild, Fine-Grained, Semantic Code Change Patterns.
InICSE2019.IEEEComputerSociety,LosAlamitos,CA,USA,819‚Äì830. https:
//doi.org/10.1109/ICSE.2019.00089
[59]HoanAnhNguyen,AnhTuanNguyen,TungThanhNguyen,TienN.Nguyen,
andHrideshRajan.2013. AStudyofRepetitivenessofCodeChangesinSoftware
Evolution. In ASE ‚Äô13(Silicon Valley, CA, USA) (ASE‚Äô13). IEEE Press, 180‚Äì190.
https://doi.org/10.1109/ASE.2013.6693078
[60]Hoan Anh Nguyen, Tung Thanh Nguyen, Gary Wilson, Anh Tuan Nguyen,
MiryungKim,andTienN.Nguyen.2010. AGraph-BasedApproachtoAPIUsage
Adaptation. SIGPLAN Not. 45, 10 (Oct. 2010), 302‚Äì321. https://doi.org/10.1145/
1932682.1869486
[61] Numpy. 2021. NumPy. https://numpy.org Accessed: 2021-05-05.
[62]Oracle.2021. JavaSEspecification. Oracle. https://docs.oracle.com/javase/specs/
Accessed: 2021-03-31.
[63]Purit Phan-udom, Naruedon Wattanakul, Tattiya Sakulniwat, ChaiyongRagkhitwetsagul, Thanwadee Sunetnanta, Morakot Choetkiertikul, andRaula Gaikovina Kula. 2020. Teddy: Automatic Recommendation of Pythonic
IdiomUsageForPull-BasedSoftwareProjects.In ICSME-2020.806‚Äì809. https:
//doi.org/10.1109/ICSME46990.2020.00098
[64]Python. 2021. Context Manager. https://docs.python.org/3/reference/datamodel.
html#context-managers Accessed: 2021-03-31.
[65]Python.2021. Functions. Python. https://docs.python.org/3/library/functions.
html Accessed: 2021-03-31.
[66]Python. 2021. list-comprehensions. https://docs.python.org/3/tutorial/
datastructures.html#list-comprehensions Accessed: 2021-05-05.
[67]Python.2021. PythonAST. Python. https://docs.python.org/3/library/ast.html
Accessed: 2021-03-31.[68]Python. 2021. With Statement. Python. https://docs.python.org/3/reference/
compound_stmts.html#the-with-statement Accessed: 2021-03-31.
[69]PythonTypeInformation. 2021. PythonTypeInformation. GitHub. https://github.
com/mlcodepatterns/PythonTypeInformation Accessed: 2021-05-05.
[70]SebastianRaschkaandVahidMirjalili.2017. PythonMachineLearning:Machine
Learning and Deep Learning with Python, scikit-learn, and TensorFlow.
[71]Martin P. Robillard and Robert Deline. 2011. A Field Study of API Learning
Obstacles. EmpiricalSoftw.Engg. 16,6 (Dec.2011), 703‚Äì732. https://doi.org/10.
1007/s10664-010-9150-8
[72]ReudismamRolim,GustavoSoares,RohitGheyi,andLorisD‚ÄôAntoni.2018. Learn-
ing Quick Fixes from Code Repositories. (2018). http://arxiv.org/abs/1803.03806
[73]RuleOfThree. 2021. RuleOfThree. wikic2. http://wiki.c2.com/?RuleOfThree
Accessed: 2021-05-05.
[74]Tattiya Sakulniwat, Raula Gaikovina Kula, Chaiyong Ragkhitwetsagul, Morakot
Choetkiertikul, Thanwadee Sunetnanta, Dong Wang, Takashi Ishio, and Kenichi
Matsumoto.2019. VisualizingtheUsageofPythonicIdiomsoverTime:ACase
Study of the with open Idiom. In IWESEP-2019. IEEE, 43‚Äì435.
[75]D. Sculley, Gary Holt, Daniel Golovin, Eugene Davydov, Todd Phillips, Dietmar
Ebner, Vinay Chaudhary, Michael Young, Jean-Francois Crespo, and Dan Denni-
son.2015. HiddenTechnicalDebtinMachineLearningSystems (NIPS‚Äô15).MIT
Press, Cambridge, MA, USA, 2503‚Äì2511.
[76]Qingchao Shen, Haoyang Ma, Junjie Chen, Yongqiang Tian, Shing-Chi Cheung,
andXiangChen.2021. AComprehensiveStudyofDeepLearningCompilerBugs.
InFSE(Athens, Greece) (ESEC/FSE 2021). Association for Computing Machinery,
New York, NY, USA, 968‚Äì980. https://doi.org/10.1145/3468264.3468591
[77]D.Silva,J.Silva,G.DeSouzaSantos,R.Terra,andM.O.Valente.5555. RefDiff
2.0:AMulti-languageRefactoringDetectionTool. TSE2020 01(jan5555),1‚Äì1.
https://doi.org/10.1109/TSE.2020.2968072
[78]Danilo Silva, Nikolaos Tsantalis, and Marco Tulio Valente. 2016. Why We
Refactor?ConfessionsofGitHubContributors.In FSE(Seattle,WA,USA) (FSE
2016). Association for Computing Machinery, New York, NY, USA, 858‚Äì870.
https://doi.org/10.1145/2950290.2950305
[79]Janice Singer, Susan E Sim, and Timothy C Lethbridge. 2008. Software engineer-
ing data collection for field studies. In Guide to Advanced Empirical Software
Engineering. Springer, 9‚Äì34.
[80]Brett Slatkin. 2019. Effective python: 90 specific ways to write better python.
Addison-Wesley Professional.
[81]OlegSmirnov,AmeyaKetkar,TimofeyBryksin,NikolaosTsantalis,andDanny
Dig. 2022. IntelliTC: Automating Type Changes in IntelliJ IDEA. In 44th In-
ternational Conference on Software Engineering Companion (ICSE ‚Äô22 Compan-ion)(Pittsburgh, United States) (ICSE ‚Äô22 Companion). ACM/IEEE. https:
//doi.org/10.1145/3510454.3516851
[82]Y.Tang,R.Khatchadourian,M.Bagherzadeh,R.Singh,A.Stewart,andA.Raja.
2021.AnEmpiricalStudyofRefactoringsandTechnicalDebtinMachineLearning
Systems. In ICSE 2021. IEEE Computer Society, Los Alamitos, CA, USA, 238‚Äì250.
https://doi.org/10.1109/ICSE43902.2021.00033
[83]Tensorflow. 2022. TensorFlow Core v2.7.0. https://www.tensorflow.org/api_docs/
python/tf/io/gfile/GFile Accessed: 2022-01-05.
[84]C√©dric Teyton, Jean-R√©my Falleri, Marc Palyart, and Xavier Blanc. 2014. A StudyofLibraryMigrationsinJava. J.Softw.Evol.Process 26,11(Nov.2014),1030‚Äì1052.
https://doi.org/10.1002/smr.1660
[85]N. Tsantalis, A. Ketkar, and D. Dig. 5555. RefactoringMiner 2.0. TSE 2020 01 (jul
5555), 1‚Äì1. https://doi.org/10.1109/TSE.2020.3007722
[86]TypeShed. 2021. TypeShed. https://github.com/python/typeshed Accessed:
2021-09-03.
[87]C.Wan,S.Liu,H.Hoffmann,M.Maire,andS.Lu.2021. AreMachineLearning
Cloud APIs Used Correctly?. In ICSE 2021. IEEE Computer Society, Los Alamitos,
CA, USA, 125‚Äì137. https://doi.org/10.1109/ICSE43902.2021.00024
[88]DavidWicks.2017. Thecodingmanualforqualitativeresearchers. Qualitative
research in organizations and management: an international journal (2017). https:
//doi.org/10.1108/QROM-08-2016-1408
[89]ShengzheXu,ZiqiDong,andNaMeng.2019. Meditor:InferenceandApplica-tionofAPIMigrationEdits.In Proceedingsofthe27thInternationalConference
onProgramComprehension (Montreal,Quebec,Canada) (ICPC‚Äô19).IEEEPress,
Piscataway, NJ, USA, 335‚Äì346. https://doi.org/10.1109/ICPC.2019.00052
[90]MingYan,JunjieChen,XiangyuZhang,LinTan,GanWang,andZanWang.2021.
ExposingNumericalBugsinDeepLearningviaGradientBack-Propagation.In
FSE(Athens, Greece) (ESEC/FSE 2021). ACM, New York, NY, USA, 627‚Äì638.
[91]Ru Zhang, Wencong Xiao, Hongyu Zhang, Yu Liu, Haoxiang Lin, and Mao Yang.
2020. AnEmpiricalStudyonProgramFailuresofDeepLearningJobs.In ICSE
(Seoul, South Korea) (ICSE ‚Äô20). ACM, New York, NY, USA, 1159‚Äì1170. https:
//doi.org/10.1145/3377811.3380362
[92]T. Zhang, C. Gao, L. Ma, M. Lyu, and M. Kim. 2019. An Empirical Study of
Common Challenges in Developing Deep Learning Applications. In ISSRE. IEEE
Computer Society, Los Alamitos, CA, USA, 104‚Äì115. https://doi.org/10.1109/
ISSRE.2019.00020
748