Scaling Client-Specific Equivalence Checking via Impact
Boundary Search
Nick Feng
fengnick@cs.toronto.edu
University of TorontoFederico Mora
fmora@cs.berkeley.edu
University of Calfornia, Berkeley
Vincent Hui
vhui@cs.toronto.edu
University of TorontoMarsha Chechik
chechik@cs.toronto.edu
University of Toronto
ABSTRACT
Client-specific equivalence checking (CSEC) is a technique pro-
posedpreviouslytoperformimpactanalysisofchangestodown-
streamcomponents(libraries)fromtheperspectiveofanunchanged
system(client).Existinganalysistechniques,whethergeneral(re-
gression verification, equivalence checking) or special-purpose,
when applied to CSEC, either require users to provide specifica-
tions, or do not scale. We propose a novel solution to the CSEC
problem, called 2clever, that is based on searching the control-flow
of a program for impact boundaries. We evaluate a prototype im-
plementation of 2clever on a comprehensive set of benchmarks
and conclude that our prototype performs well compared to the
state-of-the-art.
ACM Reference Format:
Nick Feng, Federico Mora, Vincent Hui, and Marsha Chechik. 2020. Scaling
Client-Specific Equivalence Checking via Impact Boundary Search. In 35th
IEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering(ASE
â€™20),September21â€“25,2020,VirtualEvent,Australia. ACM,NewYork,NY,
USA, 12 pages. https://doi.org/10.1145/3324884.3416634
1 INTRODUCTION
Software systems are often composed of multiple independently
developed but related components. Upgrades to these components,
even those that do not alter APIs, can hinder the stability of thesystem [
31], making component upgrades a complex and time-
consuming task. Several existing techniques, such as ModDiff [ 34],
RVT[17],SymDiff[ 24],andRÃªve[ 15],canbeusedforvalidating
behavioralequivalencebetweentwoversionsofaprogramorfor
identifying the precise set of changes between them. Yet, these
techniquesdonotexploitthe usagepattern ofaparticularlibrary
component within its client.
Inourearlierwork[ 27],wearguedthattheequivalencecheck-
ing problem becomes more tractable when the usage pattern is
considered. We further defined the client-specific equivalence check-
ing(CSEC) problemasthatofdeterminingtheimpactofchanges
todownstreamcomponents(libraries)fromtheperspectiveofan
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Â© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-6768-4/20/09.
https://doi.org/10.1145/3324884.3416634unchanged system (client). We also argued for the practical rele-
vanceofCSECinanapplicabilitystudy,andproposedasolutionto
CSEC in a symbolic execution-based tool called Clever.
While Clever performs better than the general-purpose differen-
tialprogramanalysistechniquesoninstancesoftheCSECproblem,
it is still unable to handle realistic programs. Specifically, Cleverstruggles in cases of complex clients, multiple library calls, andcases where a finite set of paths is insufficient to solve the CSECproblem. Existing techniques share this scalability issue because
theyproduce monolithicqueries thattheir reasoningengine canâ€™t
handle,e.g.,RÃªve;theyarepath-based,e.g.,ModDiff;ortheydepend
on expensive invariant inference techniques, e.g., SymDiff. Instead
ofgeneratingonedifficultquerytoanunderlyingreasoningengine,
we propose an approach that generates a sequence of smaller, sim-
plerqueries.Thesesmallerqueriesfrequentlyhaveafinite-number
of paths, can be handled by invariant inference techniques, and
imply overall equivalence.
Illustrative Example. Consider the client and two libraries in
Fig.1.Fig.1ashowstheclient, sum_primes ,whichtakesaninteger
xandreturnsthesumofallprimesbetween 0andx.sum_primes
depends on a library, composite , to check if numbers are prime.
Figs.1band1cshowtwoversionsof composite .Thefirstlibrary
version, composite_0 , returns 0if its input is prime, and the num-
ber of factors of the input otherwise. The second, composite_1 ,
returns 0if its input is prime, and 1otherwise.
Existing techniquesâ€”in particular, Clever, ModDiff, SymDiff,
RVT,andRÃªveâ€”failtoprovethat composite_0 andcomposite_1
are client-specific equivalent for sum_primes . Clever and Mod-
Diff struggle because the problem has an infinite number of paths;
SymDiffandRÃªveâ€™sreasoningenginesareunabletoidentifyare-
lational invariant that is strong enough to prove equivalence; and
RVTâ€™s bottom-up approach fails to use the crucial client context.
In this paper, we propose a novel approach, 2clever, that scales
better than existing tools. 2clever hinges on two key observations:
(1)inpractice,asmallportionofclientcontrol-flowgraph(CFG)
is often sufficient to prove that a library call does not affect the
clientâ€”we call such a sub-CFG an impact boundary ; and (2) if all
librarycallshaveanimpactboundary,thenthelibraryupdatedoes
not affect the client.
For example, 2clever determines that sum_primes in Fig. 1a is
unaffectedbythechangeto composite inFigs.1band1cbybound-
ing the impact of the library call in sum_primes . More specifically,
2cleverprovesthattheimpactiscontainedwithintheloop,i.e.,thattheredoesnotexistavaluefor
x,j,and sumsuchthatasinglepassof
7342020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
This work is licensed under a Creative Commons Attribution-NoDerivs
International 4.0 License.
int sum_primes(int x){
int sum = 0;
int j=0;
while (j < x){
if(composite(j) == 0)
s u m=s u m+j ;
j++;}
return sum}
(a)sum_primes in C.int composite_0(int num) {
int count = 0;
int i=2;
while(i < num) {
if(num%i==0)
count++;
i++;}
return count ;}
(b)composite_0 in C.int composite_1(int num) {
int i=2;
while(i < num) {
if(num%i==0)
return 1;
i++;}
return 0;}
(c)composite_1 in C.
Figure 1: The client, sum_primes, returns the sum of all primes less than x. The client calls composite to check for primality.
Theoriginalversion, composite_0,returnsthenumberoffactorsofitsinput;thenewverison, composite_1,returns 1ifitfinds
a factor, and 0otherwise. The client is unaffected by their difference.
theloopusing composite_0 producesdifferentvaluesfor x,j,and
sumattheendoftheloopcomparedtousing composite_1 .Sinceno
librarycallaffectstheclient,2cleverconcludesthat composite_0
andcomposite_1 are client-specific equivalent. Using the same
strategy, 2clever is able to efficiently solve many other instances
that other existing tools are unable to handle. Furthermore, 2clever
can be implemented as a strategy on top of existing techniques
withrelativelylowoverhead.Thismeansthat,ingeneral,2clever
can handle any instance that existing tools can handle.
Contributions. This paper makes the following contributions.
(1) We observe that the CSEC problem can usually be solved using
limitedportionsoftheclientCFG.Theseportionsare extractable
sub-CFGs that imply equivalence; we call them impact boundaries.
(2)Wedevelopanapproach,2clever,thatsearchesforimpactbound-
aries. It makes a novel connection between the classic literature on
procedure extraction and equivalence checking. (3) We describe an
efficient realization of 2clever with two important components: an
algorithmforfindingextractable sub-CFGsandabespoke equiv-
alence checking algorithm. (4) We report on a prototype imple-
mentationof2cleverandempiricallyevaluateitonasuiteof568
benchmarks taken or constructed from related work.
Organization. Therestofthispaperisorganizedasfollows.Sec.2
gives the necessary formal background. Sec. 3 describes our ap-
proachatahighlevel,includingthedefinitionofimpactboundaries
andanaiveimpactboundarysearchstrategy.Sec.4describesan
advanced impact boundary search. Sec. 5 reports on the implemen-
tation of these ideas. Sec. 6 evaluates the performance of 2clever
comparedtostate-of-the-arttechniques.Sec.7surveysrelatedap-
proaches. We conclude in Sec. 8 with the summary of the paper
and discussion of future research directions.
2 FORMAL BACKGROUND
This section describes control-flow automaton(CFA), formally de-
fines the CSEC problem in terms of CFAs, and defines the CFA
analyses that we use in Sec. 3 to describe our approach.
2.1 Control-Flow Automaton (CFA)
WeborrowthedefinitionofCFAsfromBeyeretal.[ 5].Sincethe
original definition does not handle function calls, we extend CFAs
to allow us to express and reason about libraries and clients. Inparticular, we make five small changes: ( ğ‘€1) add a final location;
(ğ‘€2)adda vectorofinputs;( ğ‘€3)adda vectorofoutputs;( ğ‘€4)al-
lowcallstootherCFAs;and( ğ‘€5)allowmoredatatypesthanjust
rational numbers. We use ( ğ‘€1)â€“(ğ‘€3) to enable ( ğ‘€4). We use ( ğ‘€4)
to formalize the notions of client and library: clients are CFAs that
call other CFAs; libraries are CFAs that are called by other CFAs.Syntax.
AC F A(ğ¿,ğ‘™ğ‘–,ğ‘™ğ‘“,/vecğ‘¥,/vecğ‘Ÿ,ğº)is a finite set of program locations
ğ¿,aninitiallocation ğ‘™ğ‘–,afinallocation ğ‘™ğ‘“,avectorofinputvariables
/vecğ‘¥,avectorofoutputvariables /vecğ‘Ÿ,andafiniteset ğºâŠ†ğ¿Ã—ğ‘‚Ã—ğ¿of
control-flow edges. The set ğ‘‚of program operations consists of
assignment and assumption operations. Assignments are denoted
byğ‘¥â†ğ‘¡,whereğ‘¥isavariablein /vecğ‘¥or/vecğ‘Ÿandğ‘¡isatermofthesame
type.Assumptionsaredenotedby [ğ‘],whereğ‘isaBooleanterm.
The set of terms is defined inductively. Every constant is a term,
every variable in /vecğ‘¥or/vecğ‘Ÿis a term, and if ğ‘“is a CFA and /vecğ‘¡is a vector
of terms matching the input type of ğ‘“, thenğ‘“(/vecğ‘¡)is a term. In other
words, a call to the CFA ğ‘“with the arguments /vecğ‘¡is a term, and this
term is represented by ğ‘“(/vecğ‘¡).
Forexample,theCFAsoftheCfunctionsinFig.1aredepicted
in Fig. 2, where locations are numbered nodes, initial locations are
shaded, final locations are double circled, and operations appear as
labels on edges. In particular, the CFA of the client, sum_primes ,
hasğ¿=[1,10],ğ‘™0=1,ğ‘™ğ‘“=10,/vecğ‘¥=/angbracketleftğ‘¥/angbracketright,/vecğ‘Ÿ=/angbracketleftğ‘Ÿ/angbracketright, and uses ğ‘“as a
placeholder for either composite_0 orcomposite_1.
Semantics. Letğ‘“=(ğ¿,ğ‘™ğ‘–,ğ‘™ğ‘“,/vecğ‘¥,/vecğ‘Ÿ,ğº)b eaC F A .Aconcrete state of
ğ‘“is a pair (ğ‘™,ğœ), whereğ‘™âˆˆğ¿is a location and ğœis a variable
assignment. When the location of a concrete state is obvious or
irrelevantweabusenotationandomitit.Everyedge ğ‘”âˆˆğºdefinesa
transitionrelationbetweenconcretestatesğ‘”âˆ’ â†’âŠ†ğ¶Ã—{ğ‘”}Ã—ğ¶,where
ğ¶isthe setof allconcrete statesof ğ‘“. Forany twoconcrete states,
ğ‘andğ‘,wewrite ğ‘ğ‘”âˆ’ â†’ğ‘if(ğ‘,ğ‘”,ğ‘)âˆˆğ‘”âˆ’ â†’,andweuse ğ‘â†’ğ‘tomean
thatthereexistssome ğ‘”âˆˆğºsuchthat ğ‘ğ‘”âˆ’ â†’ğ‘holds.Forexample,
for the CFA of composite_1 in Fig. 2c,
ğ‘20=(20,{numâ†¦â†’0,ğ‘Ÿâ†¦â†’0,ğ‘–â†¦â†’0})
ğ‘21=(21,{numâ†¦â†’0,ğ‘Ÿâ†¦â†’0,ğ‘–â†¦â†’2})
areconcretestates, ğ‘”=(20,ğ‘–â†2,21)isacontrol-flowedge,and
we can write ğ‘20â†’ğ‘21, sinceğ‘20ğ‘”âˆ’ â†’ğ‘21holds.
Letğ‘1,ğ‘’1,...,ğ‘’ ğ‘›âˆ’1,ğ‘ğ‘›beasequenceofalternatingconcretestates
andedgessuchthat/logicalandtext.1ğ‘›âˆ’1
ğ‘–=1ğ‘ğ‘–ğ‘’ğ‘–âˆ’ â†’ğ‘ğ‘–+1holds.Wecall ğ‘1,ğ‘’1,...,ğ‘’ ğ‘›âˆ’1,ğ‘ğ‘›
7351 2 3
4 5
6
78
9[c/negationslash=0 ]jâ†j+1sumâ†0 jâ†0
[j<x ]
câ†f(j)
[c=0 ]
sumâ†sum + j[jâ‰¥x]
râ†sum
(a)sum_primes CFA.11 12 13
14
151617 18
[num%i /negationslash=0 ]iâ†i+1countâ†0 iâ†2
[i<num]
[num%i =0 ]countâ†count + 1[iâ‰¥num]râ†count
(b)composite_0 CFA.19 20 21
22
232425
[num%i /negationslash=0 ]iâ†i+1râ†0 iâ†2
[i<num]
[num%i =0 ]râ†1[iâ‰¥num]
(c)composite_1 CFA.
Figure 2: CFAs corresponding to C functions in Fig. 1, where locations are nodes, initial locations are shaded, final locations
are double circled, operations are labels on edges, and fstands for either a call to the CFA in 2b or to the CFA in 2c.
atraceif the location of ğ‘1isğ‘™0and the location of ğ‘ğ‘›isğ‘™ğ‘“. We call
ğ‘1,ğ‘’1,...,ğ‘’ ğ‘›âˆ’1,ğ‘ğ‘›arunotherwise. For a trace ğ‘1,ğ‘’1,...,ğ‘’ ğ‘›âˆ’1,ğ‘ğ‘›we
call the pair (ğ‘1,ğ‘ğ‘›)ani/o pairand denote it ğ‘1â‡’ğ‘ğ‘›. In other
words, ifğ‘1â‡’ğ‘ğ‘›is an i/o pair of ğ‘“, then executing ğ‘“starting at
ğ‘1will result in ğ‘2. For example, for the CFA of composite_1 in
Fig. 2c and concrete states
ğ‘19=(19,{numâ†¦â†’0,ğ‘Ÿâ†¦â†’0,ğ‘–â†¦â†’0})
ğ‘25=(25,{numâ†¦â†’0,ğ‘Ÿâ†¦â†’0,ğ‘–â†¦â†’2})
ğ‘19â‡’ğ‘25isani/opairbecause19istheinitiallocation,25isthefi-
nallocation,andthereisasequenceofconcretestatesthatconnects
ğ‘19andğ‘25(following the sequence of locations 19 ,20,21,25).
Given a concrete state ğœ, the term ğ‘“(/vecğ‘¡)denotesğœ/prime/prime(/vecğ‘Ÿ), where
ğœ/primeâ‡’ğœ/prime/primeisani/opairof ğ‘“andğœ/prime(/vecğ‘¥)=ğœ(/vecğ‘¡)istrue.Inotherwords,
ğ‘“(/vecğ‘¡)representsthereturnvalueofacallto ğ‘“withthearguments
/vecğ‘¡, using call by value semantics. For example, at the concrete state
(4,{ğ‘—â†¦â†’0,...})in the CFA of sum_primes , the meaning of the
termğ‘“(ğ‘—)is 0, regardless of the version of composite that you
plug in for ğ‘“(both composite_0 andcomposite_1 will return 0
when given the input 0).
2.2 Formal Problem Definition
The CSEC problem is that of determining whether a change to a
libraryaffectsitscallingclient.Inthispaper,wefocusonfunctional
effects: the input/output behaviour of the client.
Formally, let ğ‘“,ğ‘“/prime,ğ‘”, andğ‘”/primebe CFAs such that (1) ğ‘“callsğ‘”, and
(2)ğ‘“/primeisthesameas ğ‘“butwithcallsto ğ‘”replacedbycallsto ğ‘”/prime.W e
callğ‘“theclient, and we call ğ‘”andğ‘”/primetwo versions of the library.
We say that ğ‘”andğ‘”/primearefunctionally client-specific equivalent (CSE)
forğ‘“iffâˆ€ğœ,/vecğ‘¡ğ‘“(/vecğ‘¡)=ğ‘“/prime(/vecğ‘¡).Inotherwords,wesaythatthelibraries
are CSE for the client, if the input/output behaviour of the client is
unaffected by the version of the library that it uses.
Thegeneralfunctionalequivalencecheckingproblemisthesame
asCSECbutwithoutrestrictions(1)and(2).Inotherwords,thegen-
eralfunctional equivalencecheckingproblemisto checkwhether
two functions will always return the same output when given the
same input. This means that we can use equivalence checkers tosolvethe CSECproblem.However,weargue thatusingtheCSEC
problem restrictions improves performanceand makes many pre-
viouslyinfeasiblecasessolvable.Forexample,ourapproachfully
automatically proves that composite_0 andcomposite_1 are CSE
forsum_primes , while ModDiff, SymDiff, RVT, and RÃªve all fail
to prove the corresponding general equivalence checking problem
within a day.
There are two crucial insights behind our approach. First, we
often only need a portion of the client to prove that the client is
unaffectedbythelibrarychange.Wecallsuchaportionoftheclient
animpactboundary.Second,certaincandidateimpactboundaries
are(relatively)easytocheck.Ourapproachcombinestheseinsights
by searching the CFA of the client for (relatively) easy to check
candidate impact boundaries. The search stops when it finds a true
impact boundary or a counterexample to equivalence. This search
requires a guarantee that the client remains unchanged.
2.3 CFA Properties
Before describing our approach, we provide a few CFA definitions
culminatinginthedefinitionofa hammock.Hammocksarepartsof
aCFAthatareâ€œextractable.â€Thatis,thereisasemanticspreserving
transformation that replaces hammocks with calls to new, stan-
daloneCFAs.Weusehammockstodefinethestructureofimpact
boundaries in Sec. 3.
Thefirstsetofdefinitionsâ€”path, simplepath, domination, post-
domination, backedge, and reducibleâ€”are standard graph theory
termsusedinprogramanalysis[ 1].Letğ‘“beaCFA (ğ¿,ğ‘™ğ‘–,ğ‘™ğ‘“,/vecğ‘¥,/vecğ‘Ÿ,ğº).
ApathintheCFAisasequenceoflocationsin ğ¿thatareconnected
byedges in ğº.A pathisa simplepath ifno locationappearsmore
than once in the path. We say that a location ğ‘–âˆˆğ¿dominates a
locationğ‘—âˆˆğ¿if every path from ğ‘™0toğ‘—passes through ğ‘–.W e
say that a location ğ‘—âˆˆğ¿post-dominates a location ğ‘–âˆˆğ¿if every
path from ğ‘–toğ‘™ğ‘“passes through ğ‘—. An edge ğ‘—â†’ğ‘–is abackedge
ifğ‘–dominates ğ‘—.Agraph ğºisreducible ifğºbecomesacyclicafter
removing all backedges.
For example, in Fig. 2a, the label 3 dominates the label 7, the
label 8 post-dominates the label 3, the edge between 7 and 3 is a
736backedge, and the entire graph is reducible, since removing the
edge between 7 and 3 gives an acyclic graph.
We use the second set of definitionsâ€”strongly connected compo-
nent,entry point, and exit point â€”in our impact boundary search
algorithm of Sec. 4. Let ğ‘“=(ğ¿,ğ‘™ğ‘–,ğ‘™ğ‘“,/vecğ‘¥,/vecğ‘Ÿ,ğº)be a CFA. A strongly
connectedcomponent (SCC)ğ‘†ofğ‘“isthemaximalsub-graphof ğº
withthepropertythatthereisapathfromeverylocationin ğ‘†to
every other location in ğ‘†. We call a location ğ‘–anentry point ofğ‘†if
ğ‘–âˆˆğ‘†and there exists a location ğ‘›âˆ‰ğ‘†such that ğ‘›â†’ğ‘–holds. We
callalocation ğ‘—anexitpoint ofğ‘†ifğ‘—âˆˆğ‘†andthereexistsalocation
ğ‘›âˆ‰ğ‘†such that ğ‘—â†’ğ‘›holds.
Forexample,inFig.2a,thesub-graphcontaininglocations3,4,5,
6, and 7, and all edges between these locations, is an SCC. For this
SCC, the locations 3 and 8 are the entry and exit point,respectively.
The third set of definitionsâ€”sub-CFA andinduced sub-CFAâ€”
depend on the first set, and will give us the main structure of
impact boundaries. Let ğ‘“=(ğ¿,ğ‘™ğ‘–,ğ‘™ğ‘“,/vecğ‘¥,/vecğ‘Ÿ,ğº)beaC F A .Asub-CFA of
ğ‘“i saC F Aâ„=(ğ¿â„,ğ‘–,ğ‘—,/vecğ‘£,/vecğ‘£,ğºâ„)such that ğ¿â„âŠ†ğ¿,ğ‘—âˆˆğ¿â„,ğ‘–âˆˆğ¿â„,
/vecğ‘£âŠ†/vecğ‘¥âˆª/vecğ‘Ÿ, andğºâ„âŠ†ğº.I f/vecğ‘£=/vecğ‘¥âˆª/vecğ‘Ÿandğºâ„is exactly the set of
edgesofğ‘“thatconnectpairsoflocationsin ğ¿â„,thenwesaythat
â„isthesub-CFAofğ‘“inducedbyğ¿â„,ğ‘–,andğ‘—.Whenğºâ„isanSCC
ofğº, the entry point of ğºisğ‘–, and the exit point of ğºisğ‘—, then we
callâ„an SCC of ğ‘“.
For example, for the CFA in Fig. 2a, the sub-CFA induced by the
subset of locations {1,3,7}, initial location 3, and final location 1
doesnotcontainthelocations2,4,5,6,8or9,oranyedgestouching
them.Infact,itonlycontainstheedgefrom7to3.Thisexample
demonstrates the problem with induced sub-CFAs: they are too
unrestricted for our needs. This can make their behaviour too hard
to reason about and make the guarantees they can give too weak.
Thefinaldefinition, hammock,comesfromKomondoorandHor-
witz[22],butisadaptedtoourcontext.Hammocksarerelatedto
thefoldable sub-graphs of Lakhotia and Deprez [ 26]. Intuitively,
both are portions of a CFA that can be extracted into a standalone
CFA. A sub-CFA â„=(ğ¿â„,ğ‘–,ğ‘—,/vecğ‘£,/vecğ‘£,ğºâ„)induced by ğ¿â„,ğ‘–, andğ‘—is a
hammock iff thefollowing hold:(1) forevery ğ‘™âˆˆğ¿â„,ğ‘–dominates ğ‘™
inğ‘“;(2)forevery ğ‘™âˆˆğ¿â„,ğ‘—post-dominates ğ‘™inğ‘“;(3)everylocation
oneverysimplepathfrom ğ‘–toğ‘—isinğ¿â„;and(4)forevery ğ‘™âˆˆğ¿â„,
every simple path in ğ‘“betweenğ‘—andğ‘™containsğ‘–.
For example, for the CFA in Fig. 2a, we can define a sub-CFA
induced by the subset of locations {3,4,5,6,7}, initial location 3,
andfinallocation3.Thisinducedsub-CFAisahammocksince3
dominatesandpost-dominatesexactlythelocations4,5,6,and7,
thereisnoâ€œmissingâ€locationthatcanbereachedfromtheinitial
locationandleadstothefinallocation,andthereisnopathfrom
the final location to the sub-CFA that evades the initial location.
Intuitively,ahammockiseasiertoreasonaboutbecauseitacts
like a a standalone CFA. We use this fact in the soundness proofinSec.3.Specifically,weusethefactthatif
â„isahammockof ğ‘“,
then all traces of ğ‘“are of the form
(ğ‘™0,ğœ0),...,((ğ‘–,ğœğ‘˜
ğ‘–),...(ğ‘—,ğœğ‘˜
ğ‘—),...)âˆ—,...(ğ‘™ğ‘“,ğœğ‘“),
whereâˆ—isthestandardKleenestar, (ğ‘–,ğœğ‘˜
ğ‘–)and(ğ‘—,ğœğ‘˜
ğ‘—)aretheğ‘˜th
concrete states at location ğ‘–andğ‘—, respectively, and locations ğ‘–and
ğ‘—donotappearinanyellipses.Inotherwords,everytraceof ğ‘“has
zeroormorerunswithlocationsin â„,andeverysuchrunstartsat ğ‘–
4 5 câ†f(j)
(a)4 5
6
7[c/negationslash=0 ]câ†f(j)
[c=0 ]
sumâ†sum + j
(b)
Figure 3: The two smallest candidate impact boundaries ofsum_primes from Fig. 2a. Both are induced sub-CFAs.
andalwaysleaves â„exactlyatthelocation ğ‘—.Sinceeverytraceof ğ‘“
hastheseproperties,wecanthinkoftherunsfrom ğ‘–toğ‘—ascallsto
anexternalCFA.Weusethistracepatterntoreducetheanalysisof
a trace of ğ‘“to one of the candidate impact boundary runs inside.
3 2CLEVER AT A HIGH LEVEL
In this section, we formally define impact boundaries, provide a
simple impact boundary search strategy, and prove the soundness
and relative completeness of our approach. The completeness isrelative because our search strategy depends on an equivalence
checking oracle. Intuitively, our approach decomposes the CFA of
the client into smaller equivalence checking queries. This query
size reduction can often make intractable problems tractable.
For simplicity of presentation, we assume that every client CFA
containsonlyonecalltothelibrary,andthateveryclientCFAis
reducible. We relax the first assumption in Sec 4, and note that the
secondassumptionisinnocuoussinceirreduciblecontrol-flowis
rare in practice [ 33]. For the remainder of this section, let ğ‘”be the
old version of the library CFA, ğ‘”/primebe the new version of the library
CFA,and ğ‘“betheclientCFAwithasinglelibrarycallonanedge ğ‘’.
3.1 Impact Boundaries
Acandidate impact boundary â„=(ğ¿â„,ğ‘–,ğ‘—,/vecğ‘£,/vecğ‘£,ğºâ„)is a hammock of
ğ‘“=(ğ¿,ğ‘™0,ğ‘™ğ‘“,/vecğ‘¥,/vecğ‘Ÿ,ğº)such that â„containsğ‘’. Intuitively, a candidate
impactboundaryisaportionoftheclientwiththespecialproperty
that ifthe candidate impactboundary isunaffected by thelibrary
change, then the client is unaffected by the library change.
Animpact boundary is a candidate impact boundary â„such that
ğ‘”andğ‘”/primeare CSE for â„. For example, Fig. 3 depicts the two smallest
candidateimpactboundariesof sum_primes fromFig.1a.TheCFA
in Fig. 3b is a true impact boundary, while the CFA in Fig. 3a is not.
3.2 Impact Boundary Search
We call our boundary search algorithm 2clever. It takes in a client
and two versions of one of the clientâ€™s libraries. It returns â€œCSEâ€if it finds an impact boundary and â€œNot CSEâ€ otherwise. In this
section, we describe a simple realization of 2clever, called 2clever-
naive,andreasonaboutitscorrectnessandcompleteness.Themore
sophisticated realization is described in Sec. 4.
2clever-naiveenumerateseverysub-CFAoftheclient,filtersout
those that are not candidate impact boundaries, and then checks
each candidate for CSE using an existing equivalence checker. For
737example, when given the client and libraries from Fig. 2, 2clever-
naive will enumerate the two candidate impact boundaries in Fig 3
(amongothers),checkeachforCSE,andreturnâ€œCSEâ€,sincetheCFA
inFig.3bisatrueimpactboundary.Inthenextsection,weprovethe
soundnessofthisstrategy.Fornow,weassumecorrectnessandnote
that it is cheaper to check if composite_0 andcomposite_1 are
CSEfortheCFAinFig.3businganexistingequivalencechecker
than to check the original problem. In fact, the CFA in Fig. 3b
corresponds to removing an entire unbounded while loop from the
original CFA in Fig. 2a.
3.3 Analysis
In this section, we prove two theorems about 2clever: if 2clever
claimsğ‘”andğ‘”/primeare CSEfor ğ‘“, then theytruly are (soundness) and
ifğ‘”andğ‘”/primearenotCSEfor ğ‘“andourequivalencecheckingoracle
terminates on every query, then 2clever will terminate (relative
completeness).
Theorem 1 (Soundness). If 2clever finds an impact boundary,
thenğ‘”andğ‘”/primeare CSE for ğ‘“.
Proof.Letğ‘“=(ğ¿,ğ‘™0,ğ‘™ğ‘“,/vecğ‘¥,/vecğ‘Ÿ,ğº)betheclient,let ğ‘“/primebeğ‘“butwith
thecalltoğ‘”replacedbyacallto ğ‘”/prime.Similarly,let â„=(ğ¿â„,ğ‘–,ğ‘—,/vecğ‘£,/vecğ‘£,ğºâ„)
betheimpactboundary,andlet â„/primebeâ„butwiththecallto ğ‘”replaced
byacallto ğ‘”/prime.Bythedefinitionofcandidateimpactboundaries,all
traces ofğ‘“andğ‘“/primeare of the form
(ğ‘™0,ğœ0),...,((ğ‘–,ğœğ‘˜
ğ‘–),...(ğ‘—,ğœğ‘˜
ğ‘—),...)âˆ—,...(ğ‘™ğ‘“,ğœğ‘“)(ğ‘‡1)
(ğ‘™0,ğœƒ0),...,((ğ‘–,ğœƒğ‘˜
ğ‘–),...(ğ‘—,ğœƒğ‘˜
ğ‘—),...)âˆ—,...(ğ‘™ğ‘“,ğœƒğ‘“).(ğ‘‡2)
We want to prove that if ğœ0=ğœƒ0thenğœğ‘“=ğœƒğ‘“.
Sincetheclientisunchangedapartfromthecalltothelibrary,
weknowthatif ğœ0=ğœƒ0thenğœ1
ğ‘–=ğœƒ1
ğ‘–.Wealsoknowthat,forany
ğ‘šandğ‘›,ifğœğ‘š
ğ‘—=ğœƒğ‘›
ğ‘—theneveryconcretestatein( ğ‘‡1)after(ğ‘—,ğœğ‘š
ğ‘—)
isguaranteedtobeequaltothecorrespondingconcretestatein( ğ‘‡2)
after(ğ‘—,ğœƒğ‘›
ğ‘—)untilbothtracesreachaconcretestatewithlocation
ğ‘–. In other words, all the â€œcodeâ€ outside of the impact boundary
remains untouched, and two copiesof syntacticallyidentical code
thatstartatthesameconcretestatewillproduceidenticaltraces.
Given these two facts, we need to prove that the runs
(ğ‘–,ğœğ‘˜
ğ‘–),...(ğ‘—,ğœğ‘˜
ğ‘—) (ğ‘‡3)
(ğ‘–,ğœƒğ‘˜
ğ‘–),...(ğ‘—,ğœƒğ‘˜
ğ‘—) (ğ‘‡4)
insideof( ğ‘‡1)and(ğ‘‡2),respectively,areequal.Bythesemanticsof
function application, every run ( ğ‘‡3) is equivalent to the term â„(/vecğ‘£).
Similarly,everyrun( ğ‘‡4)isequivalenttotheterm â„/prime(/vecğ‘£).Sinceğ‘”and
ğ‘”/primeareCSEfor â„,â„(/vecğ‘£)=â„/prime(/vecğ‘£);therefore,( ğ‘‡3)and(ğ‘‡4)areequal. /square
Theorem2(RelativeCompleteness). Ifğ‘”andğ‘”/primeareCSE for
ğ‘“, then there is an impact boundary. Furthermore, if every call to
an equivalence checker oracle terminates, 2clever finds an impact
boundary.
Proof. If ğ‘”andğ‘”/primeare CSEfor ğ‘“, thenğ‘“isan impactboundary.
SincethesetoflocationsofaCFAisfinite,thenumberofcandidate
impact boundaries 2clever checks is finite. /square4 REALIZING 2CLEVER
In this section, we describe the actual impact boundary search
algorithm used by 2clever, a bespoke equivalence checker that we
use inside the search algorithm, and a resource (time) allocationscheme to improve 2cleverâ€™s chance of termination. 2clever also
extends2clever-naivetohandleclientsthatcallthelibrarymultiple
times.Atahighlevel,2cleverconfirmstheCSEonlyifitfindsan
impact boundary for every call-site of the library.
4.1 Impact Boundary Search Revisited
Finding and checking every candidate impact boundary is imprac-
ticalforcomplexclients.Inpractice,2cleverfocusesonfindingand
checkingasubsetofcandidateimpactboundaries.Someofthese
are still difficult to reason about, so we transform them to cycle-
broken candidates. While easier to check, confirming a cycle-broken
candidate implies confirming the impact boundary that it replaced.
Given this, and since 2clever keeps the client ğ‘“in the subset of
candidate impact boundaries to check, the proofs of soundness
(Thm. 1) and completeness (Thm. 2) still hold.
Given a candidate impact boundary, â„, whose initial and final
locationsarethesamelocation, ğ‘™,weproducea cycle-broken can-
didateâ„ğ‘ğ‘byseparating ğ‘™inâ„ğ‘ğ‘.Forexample,theCFAshownin
Fig.4bisacycle-brokencandidateoftheclient ğ‘“(seeFig.2a)whose
initial and final locations both belong to location 3 in ğ‘“. Locations
3, 4, 5, 6 and 7 form a strongly connected component (shown inFig. 4a), which is hard to check for CSE. On the other hand, thecycle-brokencandidate
â„ğ‘ğ‘breaksallcyclesinvolvinglocation3
(the final location does not have outgoing edges), hence makes
checkingCSEon â„ğ‘ğ‘easier.Eventhough â„ğ‘ğ‘istechnicallynota
sub-CFA of the client ğ‘“, we still refer to it as a candidate impact
boundary for the rest of the paper because it is a sub-CFA of anequivalent client
ğ‘“âˆ—where the common location ğ‘™is extended to
ğ‘™â†’ğ‘™ğ‘–andğ‘™ğ‘“â†’ğ‘™.
4.1.1 Candidate Search. The extended search algorithm, Search*
(Alg.1),identifiesasequenceofcycle-brokencandidates, BoundSeq ,
foreachlibrarycall-site ğ‘’.BoundSeq includesthecall-site ğ‘’itself
and the client ğ‘“as its first and last element, respectively (line 15
and 6). To identify cycle-broken candidates for a call-site ğ‘’, the
algorithmfirst looksfor thestronglyconnected component(SCC)
ğ‘†thatcontains ğ‘’.Search* usesanauxiliaryprocedure, Normalize ,
totransform ğ‘†intoanSCC ğ‘†âˆ—withauniqueentryandexitpoint, ğ‘–.
Thealgorithm thenconstructsa cycle-brokencandidate â„ğ‘ğ‘from
ğ‘†âˆ—, and adds â„ğ‘ğ‘toBoundSeq . Finally, the algorithm updates the
search context â„â†â„ğ‘ğ‘(line 13) and recursively looks for a new
cycle-brokencandidatein â„,untilâ„hasnoSCCcontaining ğ‘’(line8).
The discovered â„ğ‘ğ‘is always pushed to the head of the sequence.
For example, for the client ğ‘“in Fig. 2a, Search*identifies the
SCCğ‘†in Fig. 4a containing the call-site 4ğ‘”âˆ’ â†’5. Location 3 is the
unique entry and exit of ğ‘†, and it is replaced with ğ‘™ğ‘–andğ‘™ğ‘“incycle-
brokencandidate â„ğ‘ğ‘,whereğ‘™ğ‘–isacopyof3withonlyoutgoingedge
(ğ‘™ğ‘–â†’4), andğ‘™ğ‘“is another copyof 3 with only internalincoming
edges (7â†’ğ‘™ğ‘“). The resulting cycle-broken candidate â„ğ‘ğ‘is shown
in Fig. 4b. 2clever then attempts to find an SCC inside â„ğ‘ğ‘but fails.
Finally, the call-site and the client are added to BoundSeq.
738Algorithm 1 Search*
Require: Client CFA ğ‘“and library CFAs ğ‘”andğ‘”/prime
Ensure: BoundaryMap contains a sequence of candidate impact
boundaries for each call-site
1:procedure Search*(ğ‘“,ğ‘”)
2:ğ¸â†call-sites of ğ‘”inğ‘“
3: BoundaryMap â†Dict()
4:for eachğ‘’âˆˆğ¸do âŠ²For each call-site
5: BoundSeq â†stack âŠ²first in last out sequence
6: BoundSeq.push (ğ‘“)
7: â„â†ğ‘“ âŠ²search on hammock â„
8: whileâ„has SCC containing ğ‘’do
9: ğ‘†â†SCC containing ğ‘’inâ„
10: ğ‘†âˆ—,ğ‘–â†Normalize (ğ‘†,â„)
11: â„ğ‘ğ‘â†hammock induced from ğ‘†âˆ—andğ‘–
12: BoundSeq.push (â„ğ‘ğ‘)
13: â„â†â„ğ‘ğ‘ âŠ²update cycle-broken candidate
14: end while
15: BoundSeq.push (ğ‘’)
16: BoundaryMap [ğ‘’]â†BoundSeq
17:end for
18:return BoundaryMap
19:end procedure
3
4 5
6
7[c=0 ]jâ†j+1[j<x ]
câ†lib(j )
[c/negationslash=0 ]
sumâ†sum + j
(a)li 4 5
6
7 lf[c=0 ]
jâ†j+1[j<x ] câ†lib(j )
[c/negationslash=0 ]
sumâ†sum + j
(b)
Figure 4: 4b shows the cycle-broken candidate constructed
from the strongly connected component in 4a.
Theorem 3 (Correctness). Every sub-CFA â„inBoundSeq re-
turned by Search*is a candidate impact boundary.
Proof. BoundSeq containstheclient ğ‘“,thecall-site ğ‘’,andcycle-
broken candidates â„ğ‘ğ‘. Bothğ‘“andğ‘’are trivially candidate impact
boundaries. Every â„ğ‘ğ‘âˆˆBoundSeq is constructed from an SCC ğ‘†âˆ—
with a unique entry and exit ğ‘–. Therefore, ğ‘–dominates and post-
dominateseverynodein ğ‘†âˆ—,includingthesourceandtargetof ğ‘’.
Moreover, every path from ğ‘–toğ‘’must go through ğ‘–. Therefore, ğ‘†âˆ—
is a candidate impact boundary, and â„ğ‘ğ‘is acycle-broken candidate
constructed from ğ‘†âˆ—. /square
Theorem 4 (Monotonicity). For every BoundSeq =[â„1...â„ğ‘]
returnedby Search*,forallğ‘–inrange0â‰¤ğ‘–<ğ‘,â„ğ‘–isacandidate
impact boundary for â„ğ‘–+1.
Proof.For 0â‰¤ğ‘–<ğ‘,â„ğ‘–is the cycle-broken candidate con-
structed from theSCC ğ‘†âˆ—, whereğ‘†âˆ—is a sub-CFA of â„ğ‘–+1.Search*Algorithm 2 Check*
Require: BoundaryMap is returned by Search*
Ensure:ğ‘Ÿğ‘’ğ‘¡=/latticetopiffğ‘”andğ‘”/primeis CSE for ğ‘“
1:procedure Check*(BoundaryMap, ğ‘“,ğ‘”,ğ‘”/prime)
2:ğ¸â†call-sites of ğ‘”inğ‘“
3: Contained â†âˆ…
4:for eachğ‘’âˆˆğ¸do âŠ²For each call-site
5: BoundSeq â†BoundaryMap [ğ‘’]
6: while BoundSeq â‰ âˆ…âˆ§ğ‘’âˆ‰Contained do
7: â„â†BoundSeq.pop()
8: ifEQ(â„,ğ‘”,ğ‘”/prime)then
9: for each call-siteğ‘’/primeğ‘”inâ„do
10: Contained.add( ğ‘’/primeğ‘”)
11: end for
12: end if
13: end while
14:end for
15:ğ‘Ÿğ‘’ğ‘¡â†Contained =ğ¸
16:returnğ‘Ÿğ‘’ğ‘¡
17:end procedure
ensures that ğ‘†âˆ—has a unique entry and exit location in â„ğ‘–+1. There-
fore,â„ğ‘–satisfiestheconditionsof cycle-broken candidatefor â„ğ‘–+1.
The last item in BoundSeq â„ğ‘is the client ğ‘“. By correctness of
Search* (Thm. 3),â„ğ‘âˆ’1is a candidate impact boundary for ğ‘“./square
Monotonicitysuggestsagoodcheckingorderofcandidates: â„ğ‘–
is smaller and likely easier to check than â„ğ‘–+1, and confirming â„ğ‘–is
sufficient for proving CSE.
4.1.2 Checking Candidates. After finding candidate impact bound-
arieswith Search*,2cleveruses Check*tocheckeach.Specifically,
foreachcall-site ğ‘’inğ‘“,Check*fetchesthecorrespondingsequence
ofcandidateimpactboundaries, BoundSeq ,from BoundaryMap (line5),
anditeratesthroughthesequencetofindatrueimpactboundary
forğ‘’(lines 6-13). During each iteration, Check*checks whether ğ‘”
andğ‘”/primeare CSE for â„by calling anequivalence checker, EQ(line 8).
IfEQdetermines equivalence, then â„is an impact boundary for
everycall-site ğ‘’ğ‘”(including ğ‘’)inâ„.Therefore, thealgorithm adds
ğ‘’ğ‘”into the set Contained (line 10), which represents the set of
call-siteswithconfirmedimpactboundaries. Check*stopsiterat-
ing over BoundSeq when it either reaches the end, or the target
call-siteğ‘’is added to Contained (line 6). Finally, the algorithm
determines whether every call-site has an impact boundary by
comparing Contained andğ¸(line 15), and returns the result.
Theorem5(PartialCorrectnessof Check*).IfCheck*ter-
minates, then ğ‘”andğ‘”/primeare CSE for ğ‘“iffContained =ğ¸at line 15.
Proof Sketch. Forward: if ğ‘”andğ‘”/primeis CSE for ğ‘“, thenğ‘“is an impact
boundary for all call-sites. Since ğ‘“is in the BoundSeq for every
call-site, then every call-site is eventually added to Contained.
Backward: ğ‘’is added to Contained only if it has an impact
boundaryin BoundSeq . When Contained =ğ¸, every call-site has
an impact boundary. By Thm. 1, for every call-site ğ‘’, the state
difference caused by visiting edge ğ‘’is contained before reaching
the final location ğ‘™ğ‘“. /square
739Algorithm 3 2clever-EQ
Require: â„is a candidate impact boundary of ğ‘”.
Require: every SCC in â„has single entry and single exit.
Ensure: Returns proof or counterexample.
1:procedure 2clever-EQ( â„,ğ‘”,ğ‘”/prime)
2:ğ¸â†call-sites of ğ‘”inâ„
3: calleeâ†Merge(ğ¸)
4: pre-caller â†before(â„,callee)
5: post-caller â†after(â„,callee)
6: Preâ†pre_condition(summary(pre-caller))
7: Postâ†post_condition(summary(post-caller))
8: calleeÃ—â†product (callee,callee/prime)
9:return verify(Pre, calleeÃ—, Post)
10:end procedure
4.2 Bespoke Equivalence Checking Algorithm
Check*calls procedure EQto confirm or reject candidate impact
boundaries. While any sound equivalence checker can be used for
EQ,wedevelopedanin-housealgorithm, 2clever-EQ ,thatexploits
the structure of our queries to achieve the best performance.
2clever-EQ is given in Alg. 3. It takes the caller â„and two
versions of the callee, ğ‘”andğ‘”/prime, and requires that every strongly-
connected component (SCC) in â„has a single entry and a single
exit. 2clever-EQ first identifies all call-sites in â„and then merges
themintoasinglecall-site callee(line3).Specifically,theproce-
dure Mergefinds the smallest hammock, ğ‘¤, that contains all the
call-sites and then returns the largest SCC containing ğ‘¤inâ„(or
returnsğ‘¤if no SCC exists). Intuitively, â„is an impact boundary
for all call-sites if and only if it is an impact boundary for ğ‘¤, since
ğ‘¤contains all call-sites. The SCC returned by Mergeis the next
smallest possible impact boundary and it is called at most once
inâ„.Weknowtheformersince,bymonotonicity(Thm.4),atthe
time of checking â„,Check** has already checked the cycle-broken
candidate constructed from callee(the previous candidate impact
boundary in BoundSeq ), and failed. We use the latter to partition â„
bycallee, as discussed next.
2clever-EQ partitions â„intopre-caller andpost-caller :the
portions of â„before and after callee, respectively (lines 4 and
5).2clever-EQ then summarizes pre-caller andpost-caller
(lines6and7)andconvertsthesummariesintoapre-condition Pre
and a post-condition Postas described in Sec. 4.2.1. 2clever-EQ
then creates a product function calleeÃ— via self-composition [ 3]
(line8).Whenthesummariesof pre-caller andpost-caller are
definedforallpossibleinputs,candidate â„isanimpactboundaryif
and only if {Pre}calleeÃ—{Post}is a valid Hoare triple [ 19]. We
check this Hoare triple using conditional modeling checking [ 6]
by combining three existing program verifiers. We describe the
detailed workflow in Sec. 5.
4.2.1 Summary, Pre- and Post-condition Computation. Afunction
summary of ğ‘“is a first-order formula ğœ‘over/vecğ›¼and/vecğ›½if
âˆ€ğ‘€|=ğœ‘,(ğ‘€[/vecğ›¼]=/vecğ‘¥)=â‡’(ğ‘€[ğ›½]=ğ‘“(/vecğ‘¥)),
where/vecğ‘¥andğ‘“(/vecğ‘¥)are input and output of ğ‘“, andğ‘€[/vecğ›¼]is the in-
terpretation of /vecğ›¼in the model ğ‘€. A function summary is com-
pleteif it is defined for all possible inputs. Similar to Clever [ 27],2clever-EQ computessummariesbysymbolicallyexecuting[ 21]
pre-caller andpost-caller whilerecordingprogramsâ€™pathcon-
ditions and effects. During symbolic execution, calls to calleeare
uninterrupted. If pre-caller andpost-caller have finite execu-
tionpaths,thenthesummarybysymbolicexecutioniscomplete.
Otherwise,otherproceduresummarizationtechniques(e.g.abstrac-
tion refinement) may be used.
Givenğœ‘ğ‘ğ‘Ÿğ‘’â€”thecompletefunctionsummaryof pre-caller â€”
the pre-condition of calleeÃ— is
assume(âˆƒ/vecğ›¼Â·ğœ‘ğ‘ğ‘Ÿğ‘’(/vecğ›¼,/vecğ‘¥)),
where/vecğ›¼is the input of pre-caller , and/vecğ‘¥is the the output of
pre-caller andtheinputof calleeÃ—.Intuitively,thepre-condition
captures the possible invocations of calleeÃ—. Givenğœ‘ğ‘ğ‘œğ‘ ğ‘¡â€”the
complete function summary of post-caller â€”the post-condition
ofcalleeÃ— is
assert(âˆ€/vecğ›½Â·ğœ‘ğ‘ğ‘œğ‘ ğ‘¡(/vecğ‘Ÿ,/vecğ›½)â†”ğœ‘ğ‘ğ‘œğ‘ ğ‘¡(/vecğ‘Ÿ/prime,/vecğ›½)),
where/vecğ‘Ÿand/vecğ‘Ÿ/primearetheoutputsfrom calleeandcallee/prime,respec-
tively,and /vecğ›½issettobetheoutputof post-caller oninput/vecğ‘œand
/vecğ‘œ/prime.Intuitively,apost-conditionassertsthat post-caller mitigates
the difference, if any, in the outputs of calleeandcallee/prime.
For example, consider the candidate of impact boundary â„in
Fig. 3b, and the libraries ğ‘”,ğ‘”/primein Fig. 2b and Fig. 2c, respectively.
We know that â„is an impact boundary because the Hoare triple,
{Pre}product(ğ‘”,ğ‘”/prime){Post}, is valid, where the pre-condition Pre
isassume(ğ‘—<ğ‘¥âˆ§ğ‘›ğ‘¢ğ‘š=ğ‘—),andthepost-condition Postaftersim-
plification (removing /latticetopandâŠ¥from conjunctions and disjunctions,
respectively) is
assert((ğ‘™ğ‘–ğ‘(ğ‘—)=ğ‘™ğ‘–ğ‘/prime(ğ‘—)=0)âˆ¨((ğ‘™ğ‘–ğ‘(ğ‘—)â‰ 0âˆ§ğ‘™ğ‘–ğ‘/prime(ğ‘—)â‰ 0))).
4.3 Time-Bounded Equivalence Checking
Theprocedure EQmaynotterminateduetotheundecidabilityof
equivalence checking. Since Check*calls EQmultiple times over
BoundSeq ,weneedastrategyforresource(time)allocationtomaxi-
mizethechanceoftermination.Weachievethisbyaddingatimeout
argument ğ‘¡toevery EQcall,andmanaging ğ‘¡heuristically.Weuse
the following time allocation scheme: for a candidate sequence
BoundSeq , we start by calling EQwith some initial ğ‘¡, e.g., 30 sec-
onds. If a timeout occurs, we double the value of ğ‘¡for the next call.
IfEQproducesananswerwithinhalfof ğ‘¡,wereduce ğ‘¡byhalffor
the next call. When EQis called on the last candidate ğ‘“,w es e tğ‘¡to
the maximum possible value.
Intuitively,thetimeallocationschemeusestheresultfromthe
previous EQcall to predict the difficulty of the next call. We use
thisschemebecausecandidatesin BoundSeq havemonotonically
increasing contexts. Therefore, the difficulty of the previous call
usually correlates with the difficulty of the next one.
5 IMPLEMENTATION
We implemented a prototype of 2 ğ‘ğ‘™ğ‘’ğ‘£ğ‘’ğ‘Ÿusing 3000 lines of Python
code [16]. The prototype (see Fig. 5) consists of three main compo-
nents, denoted I-III: the front-end C_to_CFA and the implementa-
tionofalgorithm, Search*(Alg.1)and Check*(Alg.2),respectively.
C_to_CFA translates C99 [ 20] source programs (shown as A)t o
CFAğ‘“,ğ‘”,ğ‘”/prime(shown as B). It uses pycparser[ 13] for source parsing
andAbstractSyntaxTree(AST)transformation.Wechosepycparser
740Search*candidate
Impact boundary 
sequences C_to_CFACFA
f g gâ€™C Program
Client Lib Libâ€™
I
IIB
calleeCallerf
calleeâ€™Caller
calleeCallerh2
calleeâ€™Caller
calleeCallerh1
calleeâ€™CallerCA
CSEFind impact 
boundariesMiss an impact 
boundaryCheck* III
E F
Not CSE EQ
CC2-EQ or Reve
Figure 5: 2ğ‘ğ‘™ğ‘’ğ‘£ğ‘’ğ‘Ÿarchitecture and workflow. ğ¼,ğ¼ğ¼andğ¼ğ¼ğ¼are
the components of the architecture.
CC2-EQ
calleecaller
calleeâ€™callerself-
composition 
Seahorn CBMC KLEEConditional Model Checking
Answer Answer AnswerTimeout timeout timeoutD
GH
IJ
I IH Hprecondition
postcondition
timeoutcallee
    Ã—
calleeâ€™E
F
Figure 6: Internal workflow of 2clever-EQ.
because, like our implementations of Search* andCheck*,i ti s
written in Python.
TheSearch* implementation ( IIin Fig. 5) identifies a sequence
ofcandidateimpactboundariesforeverycall-site.Analyzingthe
sequences allows Search* to identify dependent and redundant
equivalence checking tasks across different call-sites when their
BoundSeq overlap,enablingoptimizationsthroughtaskplanning
and redundancy pruning. In addition, independent equivalence
checking tasks on different sequences are parallelizable.
Check*(IIIin Fig. 5) uses EQfor equivalence checking of in-
dividual candidate. In addition to RÃªve [ 15], we also implement
2clever-EQ â€“ the in-house checker for EQ, illustrated in Fig. 6.
2clever-EQ usesconditionalmodelchecking [6]tocombinethree
distinct verification approaches: bounded model checking using
CBMC[11],symbolicexecutionusingKLEE[ 7],andIC3/PDRusing
Seahorn [ 23]. Effectively, 2clever-EQ combines the strengths of
the supported verifiers by allowing them to communicate their
progress on a verification problem through a common information
exchange method.
Beforecheckingforequivalence, 2clever-EQ appliesself-compo-
sition[4]ontheinputstoexpresstheequivalencecheckingproblemasaverificationproblem( DinFig.6andline8inAlg.3)againstpre-
andpost-conditionscomputedfromthecallerâ€™ssummary(shown
as E).Self-composition facilitates mutual invariant learning on the
merged program ( F) for proving relational properties, and in our
case, functional equivalence.
Duringtheequivalenceverification(line9inAlg.3), 2clever-EQ
calls the verifiers in turn, with a timeout ( Gin Fig. 6). When a ver-
ifier times out, its progress is saved as program conditions and
passed to the next verifier to guide the exploration towards the un-
verified state space (step H). The verification process terminates if
2clever-EQ answerstheequivalencequestion(step I)orexhausts
all of the verifiers (step J).
Limitations. OurCFAmodelassumedtheinputfunctionsarenon-
recursive (see Sec. 2) and reducible (see Sec. 3). Additional con-
straints may be introduced by the equivalence checker for EQ. The
implementationofthein-housechecker 2clever-EQ hasthefollow-
ingconstraints,duetosourcelevelself-compositionandconditional
modelchecking,respectively:(1)functionsmustbewell-structured,
and they must exit from their last statement; and (2) datatypes are
limited to chars, integers, booleans and non-parametric arrays. We
use2clever-EQ as the default checker and automatically switch
to RÃªve for any instances that do not satisfy these constraints.
6 EVALUATION
Inthissection,wepresentasetofCSECbenchmarks,andcompareourprototypeimplementationof2clevertothestate-of-the-art.We
aim to answer the following research questions. RQ1: How does
2cleverâ€™s performance compare to state-of-the-art on benchmarks
fromrelatedwork? RQ2:Howdoes2cleverscalecomparedtostate-
of-the-art as the algorithmic complexity of the input programs
varies?RQ3:Howdoes2clever scalecomparedtostate-of-the-art
as the number of library calls in the input programs increases?
6.1 Subjects and Setup
We compare 2clever, Clever and RÃªve on 568 benchmarks. Each
benchmark consists of a pair of C programs before and after some
changestothelibrary.Atahighlevel,Clevergenerateslogicalsum-
mariesoftheclientandthelibraries,composesthem,andchecks
for CSE using an SMT solver. Cleverâ€™s performance depends on
two main features: eager counterexample detection andlazy library
summarization. The former is a method to disprove equivalence
whilegeneratingthelogicalsummaries;thelatterisamethodfor
only summarizing those parts of the libraries used by the client.
The original Clever tool checks Python programs. We use a our
reimplementation of Clever for C programs.
RÃªve [15] translates the equivalence checking problem into a
constrained Horn clause query that can be discharged by an off-
the-shelf solver. At a high level, RÃªve uses a solver to find coupling
predicates over the two input programs. For optimal performance,
we evaluate RÃªve on the benchmarks with library calls inlined.
We started with 29 publicly accessible benchmarks collected
fromrelatedwork[ 27,34]thatfollowedtheclient-libraryformat.
We removed five cases that had recursive calls and included the
examplefromSec.1.Mostcasesintheresultingsetweretoosimple
and therefore insufficient as test subjects for performance evalu-ation: 75% of the cases are solved by all three tools in under five
741seconds.Thissetalsohasnonestedloops;allloopsiteratefewer
than 20 times, and each case has only one library call. We thus
added15benchmarksthatRÃªveâ€™sauthorssourcedfrom glibcimple-
mentations. Thesebenchmarksdid not fit ourclient-libraryformat,
but we were able to find client functions for these benchmarks on
GitHub. This yielded the set B-Origof 40 casesâ€”32 equivalent and
eight non-equivalent.
Tofurtherincrease B-Origâ€™sdifficulty,wesystematicallygener-
ate528benchmarks,referringtotheresultingsetas B-Hard.B-Hard
consistsofcombinationsof B-Origbenchmarksinvolvingatleast
oneapplicable B-Origcasefromthe75thpercentileoftheslowest
cases (i.e., those that timed out or had a solution time of >5s ec -
ondsforatleastonetool).Below,wedescribethetwotemplates,
SeqMerge andNestMerge ,thatweusetogeneratethevariouscom-
binations.
SeqMerge takes an arithmetic operator Î˜âˆˆ{ +,âˆ’}two clients,
ğ‘“1andğ‘“2, and their corresponding libraries, ğ‘”1andğ‘”2, respectively.
SeqMerge returns two merged clients: ğ‘“ğ‘š1=ğ‘“1Î˜ğ‘“2[ğ‘”2â†ğ‘”1]and
ğ‘“ğ‘š2=ğ‘“1[ğ‘”1â†ğ‘”2]Î˜ğ‘“2,wherethesubstitution ğ‘“1[ğ‘”1â†ğ‘”2]means
replacing every call to ğ‘”1inğ‘“1withğ‘”2. This process guarantees
thattheresultingprogramshavetwolibrarycalls,mitigatingfor
theabsenceofmultiplelibrarycallsin B-Orig.Italsocreatesnew
examples with library calls under different client contexts.
NestMerge takesthesameinputas SeqMerge ,butreturnsclient
functions computed by ğ‘“ğ‘1=ğ‘“1[ğ‘”1â†ğ‘“2]andğ‘“ğ‘2=ğ‘“2[ğ‘”2â†ğ‘“1].
Intuitively, NestMerge uses one clientâ€™s context to call the other
client function as its library. NestMerge creates additional cases
withlibrarycallsundermorecomplexclientcontexts,andincreases
the variety of control flow patterns in benchmarks.
WeranexperimentsonUbuntu18.04withanIntel Â®Coreâ„¢i7
CPU processor and 8 GB of RAM. Each case was run with timeout
set to 300 seconds, and memory limit set to 10 GB.
6.2 RQ1: Performance of 2clever
Weevaluatetheoverallperformanceof2cleverrelativetoClever
and RÃªve by comparing their running times on all 568 benchmarks
â€“ both the 40 B-Origcases and 528 B-Hardcases.
Results. The cactus plot in Fig. 7 shows the number of benchmark
casescorrectlysolvedbyeachtoolunderthespecifiedtimelimit.
Timeismeasuredinsecondsandplottedonalogarithmicscale.Un-
dera300-secondtimelimit,2clever,CleverandRÃªverespectively
solved40,21,and19ofthe40 B-Origcases.On B-Hardbenchmarks,
2cleversolved498of528caseswith30instancestimingout,Clever
solved368,anddidnotsolve160,whileRÃªvesolved231,andwas
unabletosolve297.RÃªvetimedouton55cases,anddidnotprovide
correct solutions on 242. Individually, 2clever, Clever, and RÃªve
solved 236, 179, 100 out of 264 SeqMerge instances, and 262, 189,
131 out of 264 NestMerge instances, respectively. In particular, on
equivalent benchmarks, every case correctly solved by either RÃªve
orCleverwasalsosolvedby2clever,withoneexception.2clever
remained competitive with Clever on non-equivalent benchmarks,
solving 152 vs. Cleverâ€™s 156 despite the early detection of coun-
terexamplesfeatureofthelatter.Astheaveragesolutiontimefor
casesincreased,2cleversignificantlyoutperformedRÃªveandClever.
Even though CC2â€™s static analysis for searching candidate of im-pact boundaries (see Alg. 1) adds a near constant time cost, itsFigure 7: All benchmarks, sorted by the solution time.
benefitinrestrictingclientcontextsignificantlyoutweighsthecost
on non-trivial instances, and ultimately makes CC2 scale better.
Beyond performing well on our new benchmarks, 2clever also cor-
rectly handled the four original cases that contained unbounded
loops,ultra_prime_sum, pos,pos2andodd[16], which no previous
tool was able to solve under the given time limit. 2cleverâ€™s success
on these cases supports our claim that impact boundary search
ismoreeffectivethanpriortechniqueswheneverinputprograms
have unbounded loops with a non-trivial loop condition.
Answer to RQ1. 2cleverâ€™s performance on solving hard client-
specific equivalence instances is superior to state-of-the-art, while
its performance on easy instances remains competitive.
6.3 RQ2: Varying Program Complexity
We now study how 2clever scales with respect to the total pro-
gram complexity of the input programs. Complexity objectively
categorizes variation in control-flow patterns, while having exter-
nal validity. Intuitively, we take complexity to be a rough estimate
of the difficulty of equivalence checking for the benchmark cases.
To investigate,we present the results fromthe experiment con-
ducted in Sec. 6.2 but this time, we sort the benchmark cases bythe total benchmark complexity (as a function of
ğ‘â€“ the size of
input to each program) and organize them into four complexityclasses. Whenever an input program pair has two different com-
plexities, the benchmark is assigned the higher one. The first class,
denoted Constant, contains 359 ğ‘‚(1)cases. The second class, de-
noted Linear, contains100 ğ‘‚(ğ‘)cases, two ğ‘‚(ğ‘ğ‘™ğ‘œğ‘”ğ‘)cases and
38ğ‘‚(ğ‘™ğ‘œğ‘”ğ‘)cases.Thethirdclass,denotedQuadratic,contains50
ğ‘‚(ğ‘2)cases.Thefourthclass,denotedHigher-Order,contains
19 cases, and includes four ğ‘‚(ğ‘3)cases, as well as cases with non-
terminatingprogrampaths.Wecomparethepercentageofcases
solved by each tool across the complexity classes.
Results. Fig.8displaysthenumberandthepercentageofinstances
solvedby2clever,CleverandRÃªve,overeachcomplexityclass.The
mean solution time for each tool, over all solvedcases, is shown
underneath each complexity class. Time is measured in seconds,
and all cases where tools time out or do not provide a solution are
742Figure 8: All tools over all benchmarks, sorted by bench-
markcomplexity.Meansolutiontimesareover solvedcases.
disregarded. We observe that 2clever outperforms Clever and RÃªve
oneverybenchmarkcomplexityclass.Although2cleversolvesa
smallerpercentageofcasesascomplexitygrows,asexpected,itsad-
vantageoverCleverandRÃªve,intermsofdifferenceinsolvedcases,
increases. In particular, while Clever and RÃªve remain competitive
on lower complexity cases, 2clever significantly outperforms exist-
ing tools on higher complexity benchmarks; this provides further
evidencethatourimpactboundarysearchscalesmoreeffectively
to difficult cases than do RÃªve and Clever. Specifically, Clever does
not scale to benchmarks with higher complexities because it ispath-based and terminates only when exploring a finite numberof program paths is sufficient to produce an answer; this is not
thecasewheneverunboundedloopsexistanywhereintheinput
programs.RÃªveâ€™sscalabilityislimitedinsteadbyitsunderlyingrea-
soning engineâ€”while verification conditions are produced quickly,
theresultingmonolithicqueriescannotbehandledbythereason-
ing engine. 2cleverâ€™s ability to both handle unbounded client loops
and decompose large queries is key to explaining its significant
performance advantage on higher complexity benchmarks.
AnswertoRQ2. 2cleverscalesmoreeffectivelythanexistingtools
as the complexity of the input program increases. In particular,
2cleverâ€™srelativeperformance,intermsofthepercentageofsolved
cases, improves as complexity grows.
6.4 RQ3: Scaling Library Calls
We now study how 2clever scales as the number of library calls in
the input programs increases, since real software clients can calltheir libraries at multiple program locations. We believe that the
number of library calls correlates with the difficulty of equivalence
verification because each library call site can be a potential source
of difference that splits the input programsâ€™ control and data flows.
For this study, we generate another set of benchmarks with the
SeqMerge template, focusing specifically on the number of calls.
To do so, we merge B-Origcases (see Sec. 6.1) with themselves,
sequentially applying SeqMerge from one to fifteen times. This
yields fifteen new cases for every applicable B-Origcase, with
Figure 9: Scaling number of library calls over B-MultCall .
eachnewcasecontainingadifferentnumberoflibrarycalls.The
resultingbenchmark,denoted B-MultCall ,consistsof25 Ã—15=375
cases.Ourexperimentcompares2cleverâ€™sperformancetoClever
and RÃªve on B-MultCall in terms of the percentage of cases solved
by each tool.
Results. Fig. 9 plots the percentage of B-MultCall cases solved cor-
rectlyandindexedbythenumberoflibrarycallsinthebenchmark.
2clevernotonlyalwayssolvesthehighestpercentageofcasesbutitalsoextendsitsleadoverCleverandRÃªveasthenumberofcallsin-creases.Specifically,2cleverâ€™sleadoverCleverandRÃªvegrowsfrom
16% to 36%, and from 36% to 44%, respectively. Moreover, a regres-
sionline[ 28]fittoeachtoolâ€™sperformancedata(seeFig.9)suggests
2cleverâ€™s rate of performance decrease is not only smaller over the
observedrangeoflibrarycalls,butwillstaysmallerevenoutside
therange.2cleverâ€™sregressionlinehasagreaterslopecoefficient
(-1.49)comparedtoCleverâ€™s(-2.53)andRÃªveâ€™s(-2.49).Theseresults
show a noticeable performance advantage of 2clever compared to
other tools, as the number of library calls increases.
AnswertoRQ3. 2cleverâ€™sperformancescalesbetterthanthestate
oftheart,intermsofthepercentageofsolvedcases,asthenumber
of library calls increases.
6.5 Threats to Validity
Our strategies for determining ground truth and program complex-
ities of 528 new benchmarks are possible threats to validity.
To mitigate the absence of ground truth, two authors first man-
ually classified equivalence of all possible combinations of client
contexts and libraries from the original benchmarks, and recorded
results as known facts. We then automatically established ground
truthofeachmergedcaseusingconservativeinferencerulesand
theseknownfacts.For example,wesaythata SeqMerge case(see
Sec.6.1)isequivalentifbothargumentstothechosenarithmeticop-
erator are equivalent. Similarly, we say that a NestMerge case (see
Sec.6.1)isequivalentifitsinnerfunctionisunaffectedbythelibrary
change.Theseinferencerulesappliedto229outof264 SeqMerge ,
and191outof264 NestMerge cases.Wedeterminedgroundtruth
of the remaining 35 SeqMerge cases and 71 NestMerge cases by
743examiningconsensus,ifreached,betweenthedifferenttools.Dis-
agreements and random instances were manually inspected. In
caseswheredisagreementsarosefromtoolâ€™sdifferencesindefini-
tionsofequivalence(e.g.,theequivalencerelationovererrorstates),
or modeling semantics (e.g., whether integer overflows can occur),
bothanswerswereacceptedascorrect.Modellinganddefinitions
ofequivalenceareimportantconsiderations,butwedonotfocus
on them here.
Wedeterminedcomplexitiesbyfirstanalyzingthecomplexity
ofeachclientcontextandlibraryseparately,andthencombining
resultstodeterminethecomplexityofthecomposedbenchmark
cases.
Finally, we note that our combined benchmarks could give an
unfair advantage to our technique if either our original benchmark
cases, or our templates for combining them (i.e., SeqMerge and
NestMerge )favorit.Wemitigatetheformerthreatbygenerating
new examples exclusively from benchmarks found in related work.
Wemitigatethelatterbyusingtemplates,i.e.,sequentialandnested
compositions, that reflect how real programs are constructed.
7 RELATED WORK
Inthissection,wedescribethetoolsandtechniquesmostrelatedto
2clever.AfterrevisitingClever[ 27],wedescribetoolsthatperform
general equivalence checking, dividing them into those that priori-
tizeprovingequivalence,thosethatprioritizedisprovingequiva-
lence, and those that deal with similar input programs. We end by
examiningincrementalverification,arelatedverificationtechnique.
Client-SpecificEquivalenceChecking. Cleveristheonlyother
toolthatspecificallytargetstheCSECproblem.WedescribedClever
in Sec. 6.1, and analyzed it extensively in Sec. 6. Clever is effective
when there is a single library call per client path, and when a finite
number of paths is sufficient to solve the CSEC problem. The main
difference between 2clever and Clever is that 2clever targets more
realistic programs, i.e., those with multiple library calls and non-
constant time complexity.
Proving Program Equivalence. Barthe et al. [ 3] reduce equiva-
lencecheckingtothetaskofverifyingaproductprogram.Many
others extend this work. For a recent example, Churchill et al. [ 10]
optimize the construction of the product program by comparing
program traces. We incorporate the reduction idea into our ap-
proach(seeSec.4.2).However,unlikeBartheetal.,ourformulation
avoidstheneedforhumaninput,andunlikeChurchilletal.,our
main contribution is in the identification of impact boundaries.
SymDiff[ 24]usesmutualfunctionsummariestocheckpartial
equivalenceoftwoproceduresbydischargingverificationcondi-
tionstoBoogie[ 2].Morerecentimprovements[ 25]lessenSymD-
iffâ€™s user burden by automatically inferring common invariants.
Unfortunately, SymDiffwith thisextension isunable toautomati-callysolve ourexamples. Wedo notcompare 2cleverwithBarthe
et al., Churchill et al., or SymDiff because they do not disprove
equivalence.
Disproving Program Equivalence. Differential symbolic execu-
tion (DSE) by Person et al. [ 29] uses symbolic execution to char-
acterize the difference between two programs. DSE is similar to
Clever,butitdoesnotspecificallytargetCSEC. DirectedincrementalSymbolic Execution (DiSE) [30] extends DSE. It uses static analy-
sis to guide symbolic execution to areas of the program that are
likely to differ. Shadow Symbolic Execution (SSE) [8] is similar to
DiSE in that it is based on symbolic execution and it prioritizesthe exploration of paths that are likely to expose a difference inthetwoinputprograms.IncontrasttoDiSE,SSEâ€™sheuristicsare
dynamic. Like Clever, none of DSE, DiSE, or SSE are able to prove
equivalenceofinfinitepathprograms.Forthisreason,wedonot
compare 2clever with these tools.
Regression Verification. WedescribedRÃªve[ 15]inSec.6.1and
evaluated its performance in Sec. 6. RÃªve is similar to the work
by Barthe et al. [ 3] and Churchill et al. [ 10]. However, unlike the
former, RÃªve is fully automatic; unlike the latter, RÃªve is more
sensitivetothesyntacticsimilarityoftheinputprograms;unlike
both, it is able to disprove equivalence. RVT [ 17] uses a fixed set of
proof rules to prove the equivalence of two related programs. RVT
deals with function calls bottom up, making it difficult to reasonabout client contexts. We do not compare against RVT because
itdoesnotdisproveequivalence.ModDiff[ 34]extendsDSEwith
modular symbolic execution and abstraction. ModDiff is similar
toClever,butitdoesnottargettheCSECproblem,andthusdoes
not take advantage of the top-down exploration. We also do not
compare against ModDiff because it is unable to handle programs
with multiple library calls.
Incremental Verification. Incremental verification tools aim to
reduce the cost of verifying a system over time by reusing veri-fication results of previous versions [
9,12,14,18,32]. For exam-
ple, eVolCheck [ 32] maintains function summariesâ€”logical over-
approximations of the input systemâ€™s functions that satisfy the
systemâ€™s specificationâ€”that are updated if necessary for each new
version of the system. The goal of incremental verification tools
is related to client-specific equivalence checking, but the problem
differs in that it requires specifications.
8 CONCLUSION
Inthispaper,wedefinedthenotionofimpactboundary,andpre-
sented an algorithm, 2clever, that solves the functional CSEC prob-
lem by searching for impact boundaries. We implementeda proto-
typefor2cleverandcompareditagainstthestate-of-the-artona
novel set of 568 benchmarks. We found that 2cleverâ€™s performance
scalesbetterthanthestate-of-the-artintermsofthecomputational
complexity and number of library calls of the input programs.
Inthefuture,weintendtoextend2cleverâ€™sapplicability,scalabil-
ity,andinterfaceevenfurther.Specifically,weaimtosupportthe
analysisofrecursiveprogramsandprogramscontainingvariability.Intermsofscalability,weintendtoequip2cleverwithparallelsolv-ing capabilities.When candidate impactboundariesdo not overlap,
they can be checked independently, in parallel, with a potentialof improving performance on inputs with more than one library
call. 2cleverâ€™s naive parallelization approach is promising [ 16], and
weintendtofurtherourexplorationsinthisdirection.Finally,in
termsofinterface, weintendtostudyhow2clever canuseimpact
boundaries tocommunicate theâ€œreasonâ€ for equivalenceto client
developers.
744REFERENCES
[1]Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. 1986. Compilers, Principles,
Techniques. Addison Wesley.
[2]MikeBarnett,Bor-YuhEvanChang,RobertDeLine,BartJacobs,andK.RustanM.
Leino. 2006. Boogie: A Modular Reusable Verifier for Object-Oriented Programs.
InProc. of FMCOâ€™05. Springer Berlin Heidelberg, 364â€“387.
[3]GillesBarthe,JuanManuelCrespo,andCÃ©sarKunz.2011. RelationalVerification
Using Product Programs. In Proc. of FMâ€™11. Springer Berlin Heidelberg, 200â€“214.
[4]Gilles Barthe, Pedro R Dâ€™argenio, and Tamara Rezk. 2011. Secure InformationFlow by Self-Composition. Mathematical Structures in Computer Science 21, 6
(2011), 1207â€“1252.
[5]Dirk Beyer, Sumit Gulwani, and David A. Schmidt. 2018. Combining Model
Checking and Data-Flow Analysis. Springer International Publishing, Cham,
493â€“540.
[6]Dirk Beyer, Thomas A Henzinger, M Erkan Keremoglu, and Philipp Wendler.
2012. ConditionalModelChecking:ATechniquetoPassInformationBetween
Verifiers. In Proc. of SIGSOFT FSEâ€™12. ACM.
[7]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
AutomaticGenerationofHigh-coverageTestsforComplexSystemsPrograms.
InProc. of OSDIâ€™08. USENIX Association, Berkeley, CA, USA, 209â€“224.
[8]CristianCadarandHristinaPalikareva.2014. ShadowSymbolicExecutionfor
Better Testing of Evolving Software. In Proc. of ICSE NIERâ€™14 (Hyderabad, India).
432â€“435.
[9]Sagar Chaki, Edmund Clarke, Natasha Sharygina, and Nishant Sinha. 2008. Veri-
fication of Evolving Software via Component Substitutability Analysis. Formal
Methods in System Design 32, 3 (2008), 235â€“266.
[10]Berkeley Churchill, Oded Padon, Rahul Sharma, and Alex Aiken. 2019. Semantic
ProgramAlignmentforEquivalenceChecking.In Proc.ofPLDIâ€™19.ACM,New
York, NY, USA, 1027â€“1040.
[11]EdmundClarke,DanielKroening,andFlavioLerda.2004. AToolforChecking
ANSI-C Programs. In Proc. of TACASâ€™04. Springer, 168â€“176.
[12]ChristopherL.Conway,KedarS.Namjoshi,DennisDams,andStephenA.Ed-
wards. 2005. Incremental Algorithms for Inter-procedural Analysis of Safety
Properties. In Proc. of CAVâ€™05. Springer, 449â€“461.
[13]EliBendersky.2019. CompleteC99ParserinPurePython. https://github.com/
eliben/pycparser.
[14]GrigoryFedyukovich,ArieGurfinkel,andNatashaSharygina.2016. Property-
Directed Equivalence via Abstract Simulation. In Proc. of CAVâ€™16. Springer, 433â€“
453.
[15]Dennis Felsing, Sarah Grebing, Vladimir Klebanov, Philipp RÃ¼mmer, and Mattias
Ulbrich. 2014. Automating Regression Verification. In Proc. of ASEâ€™14. ACM,
349â€“360.
[16]N. Feng, V. Hui, F. Mora, and M. Chechik. 2020. CC2. https://github.com/
CC24LIFE/CC2.
[17]Benny Godlin and Ofer Strichman. 2013. Regression Verification: Proving the
Equivalence of Similar Programs. J. Software Testing, Verification and Reliability
23, 3 (2013), 241â€“258.
[18]Thomas A Henzinger, Ranjit Jhala, Rupak Majumdar, and Marco AA Sanvido.
2003. Extreme Model Checking. In Proc. of VSTTEâ€™03. Springer, 332â€“358.
[19]Charles Antony Richard Hoare. 1969. An Axiomatic Basis for Computer Pro-
gramming. Commun. ACM 12, 10 (1969), 576â€“580.
[20] ISO. 1999. ISO/IEC 9899:1999: Programming Languages â€” C.
[21]JamesCKing.1976. SymbolicExecutionandProgramTesting. Commun.ACM
19, 7 (1976), 385â€“394.
[22]RaghavanKomondoorandSusanHorwitz.2000. Semantics-PreservingProcedure
Extraction. In Proc. of POPLâ€™00. 155â€“169.
[23]Anvesh Komuravelli, Arie Gurfinkel, and Sagar Chaki. 2016. SMT-Based Model
Checking for Recursive Programs. Formal Methods in System Design 48, 3 (2016),
175â€“205.
[24]ShuvenduK.Lahiri,ChrisHawblitzel,MingKawaguchi,andHenriqueRebÃªlo.
2012. SYMDIFF: A Language-Agnostic Semantic Diff Tool for Imperative Pro-
grams. In Proc. of CAVâ€™12. Springer-Verlag, 712â€“717.
[25]Shuvendu K. Lahiri, Kenneth L. McMillan, Rahul Sharma, and Chris Hawblitzel.
2013. Differential Assertion Checking. In Proc. of ESEC/FSEâ€™13.
[26]ArunLakhotiaandJean-ChristopheDeprez.1998. RestructuringProgramsby
Tucking Statements into Functions. Information and Software Technology 40,
11-12 (1998), 677â€“689.
[27]Federico Mora, Yi Li, Julia Rubin, and Marsha Chechik. 2018. Client-Specific
Equivalence Checking. In Proc. of ASEâ€™18 (Montpellier, France). ACM, 441â€“451.
[28]RaymondH.MyersandRaymondH.Myers.1990. ClassicalandModernRegression
with Applications. Vol. 2. Duxbury Press, Belmont, CA.
[29]Suzette Person, Matthew B. Dwyer, Sebastian Elbaum, and Corina S. P Ë‡asË‡areanu.
2008. Differential Symbolic Execution. In Proc. of SIGSOFT FSEâ€™08.
[30]SuzettePerson,GuoweiYang,NehaRungta,andSarfrazKhurshid.2011. Directed
Incremental Symbolic Execution. In Proc. of PLDIâ€™11. ACM, 504â€“515.
[31]Julia Rubin and Martin Rinard. 2016. The Challenges of Staying Together While
Moving Fast: An Exploratory Study. In Proc. of ICSEâ€™16. 982â€“993.[32]OndrejSery,GrigoryFedyukovich,andNatashaSharygina.2012. Incremental
UpgradeCheckingbyMeansofInterpolation-BasedFunctionSummaries.In Proc.
of FMCADâ€™12. IEEE, 114â€“121.
[33]James Stanier and Des Watson. 2012. A Study of Irreducibility in C Programs.
Software: Practice and Experience 42, 1 (2012), 117â€“130.
[34]Anna Trostanetski, Orna Grumberg, and Daniel Kroening. 2017. Modular
Demand-DrivenAnalysisofSemanticDifferenceforProgramVersions.In Proc.
of SASâ€™17. Springer, 405â€“427.
745