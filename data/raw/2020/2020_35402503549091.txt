SecurityCodeSmells in Apps: AreWeGetting Better?
StevenArzt
steven.arzt@sit.fraunhofer.de
Fraunhofer SIT|ATHENE - NationalResearchCenter for AppliedCybersecurity
Darmstadt, Hessen, Germany
ABSTRACT
Usersincreasinglyrelyonmobileappsforeverydaytasks, includ-
ing security- and privacy-sensitive tasks such as online banking,
e-health, and e-government. Additionally, a wealth of sensors cap-
tures the movements and habits of the users for fitness tracking
and convenience. Despite legal regulations imposing requirements
andlimitsontheprocessingofprivacy-sensitivedata,usersmust
still trust the app developers to apply sufficient protections. In this
paper,weinvestigatethestateofsecurityinAndroidappsandhow
security-related code smells have evolved since the introduction of
the Androidoperatingsystem.
With an analysis of 300 apps per year over 12 years between
2010and2021fromtheGooglePlayStore,wefindthatthenumber
of code scanner findings per thousand lines of code decreases over
time. Still, this development is offset by the increase in code size.
Apps have more and more findings, suggesting that the overall
securitylevel decreases.Thistrendisdrivenbyflawsintheuseof
cryptography,insecurecompilerflags,insecureusesofWebView
components, and insecure uses of language features such as re-
flection.Based onour data,we argue forstricter controls onapps
before admission tothe store.
CCSCONCEPTS
·Securityandprivacy →Software andapplicationsecurity ;
·Software and its engineering →Software verification and vali-
dation.
KEYWORDS
Android,apps,statistics,security,programanalysis
ACM ReferenceFormat:
StevenArzt.2022.SecurityCodeSmellsinApps:AreWeGettingBetter?.In
Proceedingsofthe30thACMJointEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE’22),
November 14ś18, 2022, Singapore, Singapore. ACM, New York, NY, USA,
11pages.https://doi.org/10.1145/3540250.3549091
1 INTRODUCTION
Mobileappshavebecomeanaturalpartofmoderneverydaylife.
More and more tasks can be performed online via an app, without
the need for physical contact. Users can check their bank account
ESEC/FSE ’22,November 14ś18, 2022, Singapore, Singapore
©2022 Copyright held bytheowner/author(s).
ACM ISBN978-1-4503-9413-0/22/11.
https://doi.org/10.1145/3540250.3549091balance, transfer money, talk to a physician, manage drug pre-
scriptions, find romantic partners, or even vote via their phones.
At the same time, a multitude of sensors provide the user with
location-specific personalized recommendations for restaurants or
automatically display the right passes when they arrive at theaters
or airports. Some devices even provide medical data for fitness
trackingande-health applications.
Whileintegratingsuchfeaturesintoasingleextensibledevice
and platform is convenient, it also poses challenges for privacy
andsecurity.Attackersmaystealidentitiesandmoney,blackmail
the user, or abuse profiles for judging prospective customers or
employees.LegalregulationssuchastheEuropeanGDPRimpose
limitations and requirements on the processing of personal data,
but users must still trust the app developers to correctly apply
these principles. Even in the case of benign apps, programming
mistakes can easily lead to security violations. With the binary file
alone,assessingthequalityandsecurityofanappischallenging.
It requires tools and skills not commonly available to the end user.
Therefore, app developers must ensure to constantly improve their
level of security to match the requirements that come with the
evolving functional use cases and to retain user trust. We stress
that security updates are necessary even if the feature set of an
app doesnot evolve, as new attack patterns are invented. Further-
more, cryptographic algorithms become outdated over time, as the
computational capabilities of computers (and thus attackers) be-
come stronger. App developers need to adapt key sizes and replace
algorithms that are nolongerconsideredsecure.
In this paper, we investigate how the level of security in mobile
apps has evolved over the past years, whether critical issues are
prevalent,andwhetherdeveloperssucceedinreducingthenumber
andseverityofcriticalissuesovertime.WefocusonAndroid,which
is the most prevalent mobile operating system with 71% market
share as of October 20211. Its official app store, the Google Play
Store, contains around 1.85 million apps2as of November 2021.
While some of the apps are developed and maintained by large
IT organizations with professional development teams, this is not
a requirement for admission into the store. Smaller companies
and individual developers also account for a significant number of
apps in the store. Despite this openness, the Play Store does not
enforce an explicit code or architecture review before an app is
made available tousers.
The Play Store applies technical-level checks based on static
and dynamic code analysis mainly to prevent uploads of malicious
apps[20,21].Thedetailsoftheseapproachesarenotdocumentedby
the storeoperators tonot give attackersanadvantageinavoiding
detection. Still, they miss novel malware [ 10]. Detecting sloppy
programmingandmistakesinotherwisebenignappsthatdonot
1https://gs.statcounter.com/os-market-share/mobile/worldwide
2https://www.businessofapps.com/data/app-statistics
ThisworkislicensedunderaCreativeCommonsAttribution-ShareAlike4.0
InternationalLicense.
245
ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore StevenArzt
exhibit common traces of obfuscation and exploitation is even
harder.Varioustoolsfordetectingindividualtypesofvulnerabilities
orprivacy issues have beenproposed [ 3,6ś8,33].Still, to thebest
of our knowledge, no large-scale study has been conducted over
the Play Store andits developmentover the years yet.
We therefore argue that the level of security and privacy that
users can expect from an app in the store is unclear, and that users
must currently trust the developers and the ecosystem to evolve
overtime.Inthispaper,weconductalarge-scalestudyintowhether
and how the security level in the Google Play Store has evolved
between 2010 and2021.
We download a statistically significant number of randomly-
picked samplesfrom theGooglePlay Store for each year between
2010and2021toinvestigatethedevelopmentofsecurity-related
code smells (SRCSs) throughout the store. While SRCSs are not
equivalent to exploitable security vulnerabilities, they indicate
trends on patterns, best practices, and paradigms that develop-
ers use. For example, developers can avoid outdated cryptographic
algorithms even if the output is only used as a unique database ID,
whichisnot security-sensitive.
Notethatwedonotanalyzethedevelopmentofanindividual
appovertime.WefindthattheoverallnumberofSRCSsperappin-
creases,suggestinga decreaseinthesecuritylevelofappsovertime.
This increase in SRCSs is mainly driven by cryptographic weak-
nesses such as the use of insecure algorithms, insecure compiler
flags for native libraries, insecure uses of WebView components
forrenderingwebapplicationsinsideapps,andcodesecurityflaws
suchasaccessestoprivatefieldsandmethodsusingtheJavareflec-
tion API. As we show, while the number of SRCSs per thousand
linesofcodedecreasesovertime(suggestingthatcodequalityis
getting better), this effect is outset by the large increase in app size.
We make available an anonymized version of our data set to-
gether with the SQL statements used for this evaluation. We hope
thatourdataallowsotherresearcherstovalidateourresults,andto
conductownlarge-scaleresearchonthesecurityofAndroidapps.3
Theremainderofthispaperisstructuredasfollows.InSection 2,
we present the design of our study, followed by a discussion of
the limitations in Section 3. We present the the results of our in-
vestigation in Section 4. In Section 5, we discuss our results and
draw conclusions. In Section 6, we discuss related work, before
concluding the paper inSection 7.
2 STUDYDESIGN
For our study, we selected 300 apps per year for the 12 years be-
tween 2010 and 2021 from the Google Play Store, i.e., 3,600 apps
intotal.The apps weretaken fromAndroZoo [ 1].We selected the
apps irrespective of the category, i.e., our sample set approximates
thecategorydistributioninsidetheAndroZoodataset(andthus
transitivelyinside the Play Store).
EachAPKfilewassubmittedtotheVUSC4commercialvulner-
ability scanner in version 1.11. VUSC is based on Soot [ 11] and
usestheDexpler[ 5]componenttotranslatethebinaryappcode
intotheJimpleintermediaterepresentation[ 28].Afterwards,VUSC
3https://github.com/Fraunhofer-SIT/FSE22-CodeSmells
4https://secure-software.io/Table 1:FindingTypesperCategory
Category # FindingTypes
App Certificates 2
BackendCredentials 21
Backup 3
BuildParametrization 3
Code Quality 69
Cryptography 21
DynamicCode Loading 6
General 12
Inter-ComponentCommunication 4
Java Code Security 4
Libraries 9
SharedPreferences 5
SQL Databases 6
Logging 4
Network 63
Permissions 7
PotentiallyMalicious 5
Storage 13
UserInterface 5
WebSecurity 14
performsstaticanalysisontheJimplecodetodetectsecurityvul-
nerabilities. In case the definition of a particular vulnerability is
basedondataflows,e.g.,forinjectionvulnerabilities,VUSCinvokes
FlowDroid [ 3]. On average, VUSC was able to successfully analyze
285outofthe300appspearyear.Ontheremaining15apps,VUSC
failedanddidnot deliver any results.
VUSCscansfor377differenttypesoffindingsin19categories.
Table1showsthenumberofvulnerabilitytypessupportedbyVUSC
percategory.Sincethisstudyfocusesonsecurityvulnerabilities,
wedisabledthe CodeQuality category.Thesechecksusuallylead
to many findings and increase the time required for the analysis,
withoutcontributingto the core research questionsof this paper.
We find the łPermissionsž category to include cases in which
other apps installed on the same device can trigger Android API
actionsthatareguardedbypermissionsthroughthevulnerableapp
without needing to have the respective permission on their own
(confuseddeputyattack).However,thesepermissionsarealmost
always non-critical ones such as Internet access. In contrast to
łdangerousž permissions, łnormalž ones are granted to all apps
that request them at installation time without prompting the user5.
These permissions are requested so frequently that prompting the
user is infeasible, and granting the permission entails little risk.
Sincethescannerreportslargeamountsofsuchissues,wechoseto
removethiscategory.Weacceptthatwemayexcludesomerelevant
confused-deputyattackswiththis designdecision.
VUSCusesanattackermodelinwhichotherappsonthesame
device are considered potentially malicious. Therefore, if an app
writes sensitive data into a publicly-readable file, i.e., a file that
can be accessed by all apps on the device, this is reported as a
vulnerability. This designdecisionofmutually-distrusting apps is
compatible withAndroid’sconcept of app isolation.
5https://developer.android.com/guide/topics/permissions/overview#normal-
dangerous
246SecurityCode Smellsin Apps: Are We Getting Better? ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore
Inourstudy,weuniquelyidentifyeachapp,i.e.,concreteAPK
file of a particular version, using the SHA256 hash over the APK
file. We make the list of SHA256 hashesof all apps in our analysis
publicly available. For identifying different versions of the same
app,we relyonthepackagenamefromtheAndroidmanifestfile.
The Play Store also uses the package name to uniquely identify an
app,regardless ofthe version.
Note that our data set consists of independent app sets for each
year.Wedonottrackindividualappsovertheyears,i.e.,updates
of the same app. Instead, we approximate the security status of the
overall Play Store using statistics on the individual year-based sets
andcomparethesenumbersovertheyears.Wediscusshowapps
evolve ingeneral, andnot howaparticularapp evolves.
3 THREATS TO VALIDITY
For each year between 2010 and 2021 we obtained a set of 300
apps from AndroZoo. We filtered theAndroZoo data set using the
modification date of the dexfile in the app to build one set of apps
peryear.Notethatwedidnotconsidertheageoftheapps,i.e.,when
they were first introduced into the store, or when they received
their most recent update within that year. Consequently, two apps
fromadjacentyears(e.g.,onefromDecember2014andonefrom
January2015)maybetemporallycloser(albeitplacedindifferent
buckets) than two apps from the same year (e.g., January 2015 and
October2015),albeitplacedinthesamebucket.Weacknowledge
that years are not a fully precise measure for how recent a certain
app version is. Since we analyze 300 apps per year, and since we
consider12yearsintotal,weassumethatsucheffectsdonotaffect
the results of our study. We further assume that the year extracted
fromthe dexfiledateprovidedbyAndroZooisprecise.Mistakes
in the metadata from the AndroZoo data set may affect the results
ofourstudy.Wefoundonecaseinwhichthesameapp(identical
hash)wasassociatedwithtwoyears.
The findings reported byVUSCrepresentsecurity-relatedcode
smells(SRCSs),thatneednotnecessarilybeexploitable.Ifanout-
dated hash algorithm such as MD5, for example, is used only to
generate unique IDs based on the data, security properties such as
preimage resistance are not relevant. Without a deeper analysis,
however,thefindingisindistinguishablefrom,e.g.,apasswordhash.
Nevertheless, we consider SRCSs as relevant for identifying trends,
as they show whether developers continue to use outdated pat-
terns,orwhethertheyswitchtoupdatedcodingpatterns.Asfuture
work, we suggest to augment our analysis with manual reverse
engineering or penetration testing, or with dynamic automated
approaches such as guided fuzzing, to more precisely study the
security implications of the SRCSs, and to confirm whether the
trend inSRCSsalsoimplies atrend inoverallapp security.
Weonlyuseasinglevulnerabilityscannerinourstudy,which
makes our data inherit the false positive and false negative rate
of that scanner. We assume that such issues equivalently affectall
partialdatasets,i.e.,eachyear,andthereforedonotaffectthetrends
reported in this paper. Manual investigation showed that many
identified SRCSs stem from simple code patterns. Cryptographic
algorithms,forexample,areusuallyspecifiedasconstantstrings
passedtofactorymethods.We therefore consider theriskoffalsepositives or false negatives to be sufficiently low. We call upon the
community to validate our results withotherscanners.
OurdatasetonlycontainsappsreleasedontheGooglePlayStore,
whichalsoevolvesovertime.IfacertaintypeofSRCSdecreases
overtime,thismaybecausedbythestorecheckingfortheissue
andnotacceptinganynewappsthatcontainit[ 10].Lastly,weonly
focus on SRCSs that can be found by automated code scanners and
not, e.g.,conceptualweaknessessuch as missingauthentication.
We use VUSC to distinguish between app code and library code.
AnAndroidappconsistsofasingleAPKfilewithalllibraryclasses
compiled into the same file. VUSC contains a mapping between
known libraries and the package names of all classes contained
in them, generated from JARs crawled from Maven central. This
comparisonfailsforobfuscatedapps inwhich class and package
names have been changed, but a manual spot-check indicated that
only few apps are obfuscated in our data set. Integrating a more
reliable approach for library detection [ 4,13,31]isfuture work.
4 EVALUATION
In this section,we presentthe results of our statistical analysis on
the evolution ofthe security of apps inthe Google Play Store.
4.1 Research Questions
Inthissection,weevaluateourdatabasedonthefollowingresearch
questions:
RQ1Howdoes the totalnumber of SRCSsdevelop over time?
RQ2WhichcategoriesofSRCSsshowasignificanttrendandwhich
are the mostrelevantSRCSsinthat category?
RQ3Which individual types of SRCSs occur most frequently over
allcategoriesanddo they showasignificant trend?
For RQ2, we focus on the categories that exhibit clear trends:
Cryptography, build parameterization, backend credentials, Java
codesecurity,andstoragesecurity.TheothercategoriesfromTa-
ble1show no such trends. The numbers increase and decrease
between the years with no clear pattern. The numbers in the Po-
tentiallyMalicious categoryaregenerallylow,becausetheVUSC
scannerfocusesonSRCSsinbenignappsandthereforeonlyhas
limited capabilities in detecting potentially malicious behaviors
such as SMSmessagesto premium-rate numbers.
4.2 Baseline Statistics
Toput therawdatafrom theSRCSsintoperspective, wecompute
thenumberofclasses,methods,andunits(statementsintheJimple
representations)ofeachapp.Foreachyear,wecomputetherespec-
tiveminimum,average,andmaximumofallthreemetrics,asshown
in Table2. We observe a significant spread in the app sizes within
the same year, as the median numbers for classes, methods, and
Jimplestatementare muchsmallerthanthe respective averages.
We use the number of Jimple units as the main measure for the
code size. It correlates with the number of instructions in the app’s
Dalvikbytecode.OurdatashowsthattheaveragenumberofJimple
units increases by a factor 15.6 between 2010 and 2021, which is
similar to the factors for method(15.8) andclass (17.7) increase.
Wepickedthe300appsrandomlyforeachyear.Still,thepicks
are not independent, because many apps stay in the store for more
thanoneyear,i.e.,thesameapporanupdatedversionthereof,may
247ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore StevenArzt
Table 2:App SizeStatistics perYear
Year # Classes # Methods # Units
MinAvgMedian MaxMinAvgMedian MaxMinAvgMedian Max
20105414 388,491 62,762 15454,730 1836,223 2,603 608,028
201113641206,192 32,406 62638,600 1234,791 11,064 554,161
201254232073,311 62,951 1,16930,645 1839,888 18,952 373,195
201349765735,754 87,117 4,03948,694 18106,721 77,934 609,292
201441,550 8526,946 410,647 6,17554,229 12157,897 108,011 779,322
201553,2663,097 8,983 1121,602 20,875 55,317 27284,381 275,562 732,310
201663,9163,776 8,770 625,526 23,988 57,633 18340,198 327,456 801,723
2017104,2834,05810,414 2027,668 26,135 55,754 132357,483 352,735 829,071
2018124,2293,984 9,091 1626,934 25,467 54,810 68366,682 347,744 843,144
201944,5964,22810,347 2129,956 29,985 56,289 297414,957 409,163 893,189
202046,9717,59014,637 1442,384 50,008 59,451 147563,352 616,508 1,292,242
20211247,3047,90915,029 65743,591 51,552 59,3837,529563,070 622,365 1,311,841
be picked again for a later year. To evaluate the impact of such
duplicate picks on our study, we compare the package names of all
apps in our sample set. Recall that the Play Store uses the package
nameto uniquelyidentify an appand that the package name does
not change between two versions of the same app. In 20 cases,
wefindthatdifferentversionsofthesameappwerecollectedfor
differentyears.Wefind52casesinwhichayear’sdatasetcontained
atleasttwoversions ofa particular app(1.4% of allapps).Fromthe
3,600 APK files in total, this amounts to 207 apps with the same
package name (7.75%). With these few duplicates, we consider our
samples as nearly statistically independent. We did not remove
theseduplicatesfrom the data set.
4.3 RQ1: OverallSecurityTrend
Figure1shows the development of total number of SRCSs over all
apps of a particularyear overthe 12 years inthe dataset. The red
square dots show the SRCSs over all categories except for łPermis-
sionsž (see Section 2). We connected the dots to better visualize
trends. The blue dots show the average number of Jimple units per
appasameasureforthecodesize.Asidefromtheoutlierpeakin
2016,weobservethatthenumberofSRCSsgrowsovertime,e.g.,
appsfrom2021containmoreSRCSsthanonesfrom2012.Atthe
same time,app sizesalsogrowsignificantly.
We checked the exceptionally high value for 2016 in Figure 1
by repeating the analysis with a second data set. In addition to
AndroZoo,wealsoanalyzed300appsfromasamplethatwehad
crawled ourselves from dlapk6in 2016. The dlapk data set leads
to around 13% more SRCSs, and emphasizes the outlier. We do not
find this outlierto be reflectedinthe app sizes.
Giventhelargespreadinthesizesofindividualapps(compare
the median and average code sizes in Table 2), we must verify
thattheincreaseovertimeisnotcausedbyastatisticalerror.We
computeavectorofSRCScounts,i.e.,avectorof300elementsin
which eachelement isthecount of security-relatedcode smells in
the respective app. To show that our trend is significant, we refute
thenullhypothesisthatallofthesevectorsweredrawnfromthe
sameprobabilitydistribution.However,sinceourgoalistoshow
6https://dlapk.io/2010 2012 2014 2016 2018 2020 202200,511,522,5·104
Year#Security-RelatedCode Smells(SRCSs)
2010 2012 2014 2016 2018 2020 20220246·105
#Avg. Jimple Units#Sec.-RelatedCode Smells
Avg. AppSize (Units)
Figure 1:NumberofSRCSs overthe years
atrendthatisnotnecessarilystrictlymonotonic,weweakenthe
nullhypothesis. Insteadof comparing the vectors of twoadjacent
years, we combine a rolling window of two adjacent years, i.e., we
compare2010and2011with2012and2013,thencompare2011and
2012with2013and2014,etc.Thisapproachacknowledgesthatit
maytake twoyears to significantly changethe number of SRCSs.
For refuting the weakened null hypothesis, we apply the Mann-
Whitney U-Test, which does not assume a particular probability
distribution. More precisely, this test checks whether, when ran-
domlypickingavaluefromthefirstsetandonefromthesecond
one, the first value is equally likely to be larger or smaller than the
second value. If this hypothesis is refuted, we can assume that the
valuesfromonesettendtobelargerthanthevaluesfromtheother
set. For all but one pair of vectors in our rolling window approach,
wewereabletorefutethenullhypothesiswithanerrorprobability
of0.05,i.e.,thetrendisstatisticallysignificant.Wewerenotable
torefute thenullhypothesisfor thecombined years 2014/15(first
vector)and2016/17(secondvector)duetotheoutlierinthenumber
ofSRCSsin2016. However,this does not affectthe overalltrend.
248SecurityCode Smellsin Apps: Are We Getting Better? ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore
2010 2012 2014 2016 2018 2020 202200,511,522,5·104
Year#Security-RelatedCode Smells (SRCSs)
2010 2012 2014 2016 2018 2020 20220246
#Avg.SRCSsper 1,000 LoC#Sec.-RelatedCode Smells
SRCSsper 1,000 LoC
Figure 2:Security-related codesmellsper1000 LoC
To better understand how the security level develops in compar-
isontothecodesize,wedividethenumberofSRCSsperappbythe
number of Jimple statements as a measure for the code size of that
app. We then compute the average of these fractions for each year
as shown in Figure 2. We find that while the number of SRCSs per
1,000linesofcodehasdecreasedsharplybetween2010and2013,it
has - aside from outliers in 2014 and 2020 - stayed almost constant
at a low level since then. Still, due to the large and steady increase
in app size, a constant code error rate still leads to significantly
more SRCSsinthe overallapp.
Developersbuildtheirappsfromexistinglibraries.Sincepopular
libraries are shared between multiple apps, a single SRCS inside
such a library can affect multiple apps. For the security of the
Androidecosystem,itisimportanttounderstandwhetherseparate
issues in individual apps must be fixed one by one, or whether
security improvements can focus on shared libraries. Note that
librariesarecompiledintotheapponAndroid,insteadofplatform-
wide sharing of library binaries. Therefore, even if a SRCS in a
library is fixed, app developers must still update their apps, which
at leastrequires recompilation withthe newlibrary version.
To better understand these considerations, we analyze to which
degreethediscoveredSRCSsstemfromthird-partylibraries(see
Figure3). The blue line (axis on the right) shows the percentage
offindingsinlibrarycode.Theredline(squares)showsthetotal
numberofSRCSs,whereasthegreenline(emptycircles)showsthe
sumofSRCSsdiscoveredinlibraries.Thecountsusethescaleon
the left, the percentageuses the scaleonthe right.
Until2013,onlyabout7%ofallSRCSswereinlibrarycodeon
average. This number rose to 22% in 2015. From this point, the
percentagefellslightlytoabout18%in2021.Weobservethatthe
increasingtrend inthe overallnumber ofSRCSsis not driven by
libraries andthat mostSRCSsare inapp-specific code.
Overallyears,wefindthataround52%ofallclassesinanapp
are library classes, without a clear trend. Since 2014, the value is
alwaysbetween 47%and61%.The lowestvaluewas19%in2011.2010 2012 2014 2016 2018 2020 202200,511,522,5·104
Year#Security-Related Code Smells(SRCSs)
2010 2012 2014 2016 2018 2020 202205·10−20,10,150,2
% in LibrariesTotal SRCSs
LibrarySRCSs
% of Lib.SRCSs
Figure 3:Effect oflibrarieson SRCSs
Thecategorieswiththemostfindingsarenetwork(23%),cryp-
tography(11%)andJavacodesecurity(7%).Allothercategoriesare
responsible for less than one percent of all findings. When looking
at the number of affected apps, we find a similar list of top cate-
gories.However,wenotethat13categoriesoccurinmorethanone
percent of all apps. The top ones are: Network (19%), cryptography
(17%), Java code security (11%), storage (8%), inter-component com-
munication(5%),buildparametrization(4%).Inthefollowing,we
focusontrends inthesetop categories.
4.4 RQ2/3:Trends in Cryptography
Figure4showsthedevelopmentof Cryptography SRCSs(cf.Table 1).
The red boxes show the total number of crypto SRCSs over all
apps in the respective year, connected for visualizing the trend.
Thecryptocategoryshowsasimilartrendastheoverallfindings,
includingapeakinyear2016.Thebluedotsshowthenumberof
apps in which at least one crypto SRCSs was found. Recall that our
datasetcontains300apps peryear.Wefindthatsince2014,more
than80%ofallappscontainatleastonesuchSRCSandaplateau
has been reached. This means that a randomly-picked app from
2021 ismore likely to misuse cryptoAPIs thanone from 2012.
We find uses of outdated cryptographic algorithms to represent
between 65% and 72% of all findings in the Cryptography category.
The trends of this SRCS type almost exactly match the trends of
the entire category. Figure 5shows that most uses of outdated
cryptographic functions involve hashes. Since NIST deprecated the
useofSHA-1in2011anddisalloweditsusefordigitalsignatures
bytheendof2013[ 22],weconsideritsuseabadcodingpractice.
Notethat we usethe same NIST-based catalogof outdated crypto
algorithms across the entire data set. We would therefore expect
to find more outdated algorithms in older apps. However, our data
indicates the contrary.
WefindthatSHA-1(bluecurve)gainedincreasinguseinAndroid
apps after MD5 (grey curve), albeit at a time when SHA-1 was
already being phased out according to NIST. We see that uses of
MD5grewfrom2012onward,whereasSHA-1gainedtractionafter
2015.Atthispoint,developerswerealreadyadvisedtouseother
algorithmssuchasSHA-256.Wefurthernotethatthenumberof
249ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore StevenArzt
2010 2012 2014 2016 2018 2020 202200,20,40,60,81·104
Year#Security-RelatedCode Smells (SRCSs)
2010 2012 2014 2016 2018 2020 20220100200300400
#AppsCryptoSRCSs
Apps withCryptoSCRS
Figure 4:NumberofcryptoSRCSsovertheyears
2010 2012 2014 2016 2018 2020 2022010002000300040005000
Year#Algorithm UsesDES
TripleDES
Blowfish
MD5
SHA-1
AES
SHA256
Figure 5:Development ofCryptoAlgorithmUse
codelocationsthatuseMD5wasstillgrowingevenafterthispoint.
Therefore, our data does not suggest a switch from MD5 to SHA-1,
butratheraco-existenceofbothalgorithmswithMD5stillbeingthe
most prevalent algorithm. Similarly, although SHA-1 is deprecated
formorethanadecadebynow,wealsofailtoseeafullswitchto
otheralgorithmssuchasSHA-256inAndroidapps,butfindnew
uses of SHA-1 to be introduced every year. The use of SHA-256
gained traction after 2017. We find that its use surpassed the use
of MD5 in 2019, and the use of SHA-1 in 2018. Still, the uses of
SHA-256 from 2020 on grow slower than those of MD5 and SHA-1.
For the ciphers, we find find AES to be the most prevalent al-
gorithm in Android apps over the entire data set. Its use increases
significantly after 2017, but surpasses the use of earlier algorithms
over all years. We note that earlier encryption algorithms are al-
mostirrelevantinAndroidapps.Still,weobservesometrendsin
thefewappsthatrelyonolderalgorithms.Wefindanincreasing
useoftheoutdatedDESalgorithmfrom27instancesin2010to118instances in 2021. While the trend for the hash functions is almost
monotonic, the trend is more blurred for ciphers. We attribute this
tothecomparablylownumbers.Theuseoftriple-DES(3DES)does
not change significantly over time (23 in 2012, 24 in 2022). How-
ever,wefindaslighttrendtowardsusingtheBlowfishalgorithmin
recentyearswithatmost14usesuntil2019,but46usesin2020and
184 usesin 2021.Blowfish isconsidered outdatedin the successor
Twofish orthe more standardNIST-approvedalgorithm AES.
We further analyze the ratio between the number of uses of
outdated crypto algorithms and the code size in Jimple statements,
butdonotfindacleartrend.Thereareindividualpeaks(e.g.,for
DESin2014andforSHA-1andMD5in2020),buttheprevalenceof
individual algorithms is largely irrelevant from the overall growth
ofthe app code.
Whendividingtheusesofoutdatedalgorithmsbythetotalnum-
ber ofcrypto algorithmuses (i.e.,calls to Cipher.getInstance()
and related methods), we find the use of MD5 to drop from its
peak in2010at43%toabout21%in2021.The use ofSHA-1 drops
from 28% in 2010 to 17% in 2021. However, we also find a drop
in SHA-256 from 22% in 2010 to 13% in 2021. We attribute these
decreases to more differentalgorithms being used, e.g., ripemd160
or SHA-224. In 2010, we find 27 different algorithm configurations
(e.g.,sha256withrsaandmgf1 ), with128configurationsin2021.
4.5 RQ2: Trends in Build Parametrization
The category Build Parametrization contains checks for insecure
buildconfigurations ofnative libraries contained inthe apps. Not
activatingtheno-execute(NX)flagordisablingaddressspacelayout
randomization are such issues. In contrast to other findings, this
categorycontainsmissingcountermeasuresrather thanpotential
vulnerabilities. Since these countermeasures have long become
standard configurations in compilers and tool chains, we expect
them to be universally adopted. The NX flag was introduced to the
ARMinstructionsetwithARMv6releasedin2002andtothex86
instruction setaround2004.We thereforeexpectthefeature tobe
knownto app developers from the startof our data setin2010.
However, our data shows (see Figure 6) that such missing coun-
termeasuresappearevenmorefrequentlyinrecentapps.Thered
line (square marks) show the number of findings, the blue line
(round marks) shows the number of apps with at least one affected
library.Wefindthat thenumberoffindingsoverallappsshowsa
similar trend as the number of native libraries over all apps (green
line, triangular marks) in recent years. A single app can contain
multiplelibraries,whichexplainswhythetrendofmissingcoun-
termeasure can increase more rapidly than the number of affected
apps.Forthenumberoflibraries,wecountall *.sofilesintheAPK
files. An app can contain the same library compiled for different
targetplatformssuchasx86,ARM,MIPS,etc.Sinceallfilesmaybe
built with different configurations even if the source is identical,
we considerallofthesebuildartifacts as individuallibraries.
Misconfiguredbuildflagsareremarkablesincenewly-developed
libraries shouldbe built withpropersettings bydefaultandfixing
theseissuesinanexistingcodebaseonlyrequireschangestothe
buildconfigurationandistransparentto mostusercode.
250SecurityCode Smellsin Apps: Are We Getting Better? ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore
2010 2012 2014 2016 2018 2020 20220200400600
Year#SRCSs/ #Apps
2010 2012 2014 2016 2018 2020 202201000200030004000
#Librares inside AppsBuildSRCSs
Apps withBuildSRCSs
#Native Libraries
Figure 6:NumberofbuildSRCSsovertheyears
2010 2012 2014 2016 2018 2020 2022050100150
Year#Security-RelatedCode Smells (SRCSs)
2010 2012 2014 2016 2018 2020 2022010203040
#AppsBackendCredentials
Apps withBackendCredentials
Figure 7:Numberofbackendcredentials overtheyears
4.6 RQ2: Backend Credentials in Code
We found credentials for backend services inside Android apps,
especially between 2012 and 2018 (see Figure 7). Depending on
theprivileges that theseaccountshave onthe respective backend
systems, attackers may be able to extract data from arbitrary users
of the app, or to misuse the computational (cloud) resources of
the app developer [ 24]. The problem seems to have widely been
resolved in recent years. Despite an increase in affected apps in
2020,thetotalnumberofcredentialsdecreased.Evenin2020,there
are only 11 apps outof300(3.7%) withthis issue.
4.7 RQ2: Trends in Java CodeSecurity
Figure8shows how the number of Java code security findings
develops over the years. The Java Code Security category contains
checksonaccessestoprivatefieldsandmethodsviaJavareflection.
The latter may skip permission checks or input validation that
would have been performed if the proper public API had been2010 2012 2014 2016 2018 2020 20220200040006000
Year#Security-Related Code Smells(SRCSs)
2010 2012 2014 2016 2018 2020 2022050100150200250
#AppsCode SecuritySRCSs
Apps with Code SecuritySRCSs
Figure 8:NumberofcodesecuritySRCSs overthe years
used. This may not immediately be an exploitable vulnerability,
but is bad coding style as it breaks the principle of separation of
concernandJava’scodeisolation.Wenotethatpluginarchitectures
inwhichtargetclassesormethodsareconfiguration-dependentare
uncommoninAndroidapps.Smallerappsaremonolithic.Forlarger
appswithoptionalcomponentsinstalledondemand,thePlayStore
regulationsonlyallowsuchdynamiccodeloadingviathePlayStore
API.Appupdatesarealsoperformedviathestore.NotethatVUSC
only counts a reflective access if the setAccessible method is
calledtoexplicitlymakeatargetfieldormethodaccessible,thereby
disabling Java’schecksonthe access flags of the field ormethod.
WefindthenumberofSRCSstoincreaseovertheyears.Around
90% of all SRCSs in this category are about private method and
field accesses. Other checks focus on the insecure use of custom
class loaders. A class loader must verify the requested permis-
sions in the context of the current security manager. Developers
should therefore inherit from SecureClassLoader and invoke the
getPermissions() method of the superclass when overriding it
in their own class. Security managers are used to separate code
withdifferenttrustlevels(suchasmainapplicationandplugins)on
traditional Java VMs. Android, on the other hand, isolates code on
theapplevel.Theofficialdocumentationstatesthatłapplication
developerscanassumethatthere’snoSecurityManagerinstalled.ž7.
Consequently,findingsonclass loadersecurity are less relevant.
We find about 18% of all code security SRCSs to stem from li-
brarycode.Thenumbersdecreasefromabout25%in2010toabout
17%in 2021. We can therefore conclude thatdependency injection
frameworks thatuseJava reflection for invertingthecontrolflow
dependencies are not responsible for the majority of theseSRCSs.
4.8 RQ2: Trends in Storage Security
IntheStoragecategory,weseeanincreaseinthetotalnumberof
SRCSsandthenumberofappsaffectedbythemuntil2019anda
declineafterwardsasshowninFigure 9.Futureresearchneedsto
showwhether the downwardstrend continues inthe future.
TheStoragecategorycontains checkswhetherapps change file
permissions to world readable orworld writable . Such a change
7https://developer.android.com/reference/java/lang/SecurityManager
251ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore StevenArzt
2010 2012 2014 2016 2018 2020 20220200400600800
Year#Security-RelatedCode Smells (SRCSs)
2010 2012 2014 2016 2018 2020 2022050100150
#AppsStorage SRCSs
Apps withStorage SRCSs
Figure 9:Numberofstorage SRCSsovertheyears
makesthefilesaccessibletoallappsinstalledonthesamephone,
effectively disabling Android’s app isolation. Similar checks ap-
ply to the security flags for Android’s Shared Preference key-value
storage.Bydefault,thisstoreisonlyaccessiblebytherespective
app. However, developers can explicitly configure the shared pref-
erencestoreas worldreadable ,whichisexplicitlydiscouragedin
the Android documentation.
Explicitlymakingdirectoriesworldexecutableandfilesworld
readable( chmod)rankhighestasindividualfindingsinthiscategory
withalmostequalcounts(1,530and1,425issuesrespectivelyover
all years). Requesting a world-readable stream from the Android
APIoccursinonlyaboutathirdofthesecases(532issues),followed
bydirectorytraversalsuponwriteaccess(343cases).In190cases
we found apps to attempt installing another app from insecure
storage such as the SD card, which is shared between all apps.
Appscannotsilentlyinstallotherappsunlesstheyaresystemapps,
i.e., signed with the Android system key, or the device is rooted.
For most apps and configurations, neither is the case. Therefore,
installing an app on Android is only possible through either the
Google Play Store or, if sideloading is enabled, by launching the
APKinstallerwhichpromptstheuser.Updatesofappsobtainedvia
thestoreshouldbeperformedviathestore.Enablingsideloading
allowstheinstallationofarbitraryuncheckedandpotentiallyunsafe
apps(albeitwithuserconfirmation).Appsshouldnotencourage
users to enable this option. Further, if the app to be installed is
loaded from shared storage, other apps on the same device may
manipulate it before installation. A low-privileged app may abuse
such a vulnerability to inject malicious code into a high-privileged
app before installation.
4.9 RQ3: Individual CodeSmells
WeanalyzeourdatasetforthemostprevalentSRCSsoverallyears
andthencheckhowthesetop10SRCSshavedevelopedoverthe
12 years ofour dataset.For this analysis, we count thenumber of
apps affected by a SRCS, not the number of SRCSs. Note that some
SRCSs such as improper TLS host name verification only affect
a small number of statements in the app, since the same customHostNameVerifier implementation is re-used for all connections.
A custom host name verifier requires more code, and developers
avoidclutteringtheirappwithrepeatingthiscode.OtherSRCSs,
such as outdated crypto algorithms, are usually repeated at each
statement that initializes a new Cipherobject. Initializing a cipher
is a single statement that takes the algorithm as a string parameter.
ThefollowinglistshowsthetoptenSRCSsintermsofaffectedapps.
The percentages are computed over the entire data set, ignoring
the year to whichan app belongs.
ContentProviderAccessfromWebViews (63.9%)JavaScript
codeinsideaWebViewcontrolisallowedtoaccessdatafrom
contentproviders.ThismayallowuntrustedJavaScriptcode
to access ormanipulateapp data.
Insecure Crypto Algorithm (62.3%) The app uses a crypto-
graphic algorithm that isnolonger consideredsecure.
WebViewUniversalAccess (54.7%)CodeinWebView controls
is granted universal access to files, content providers, etc.
regardless of its origin. This effectively disables the same
originpolicyinside the WebView.
Insecure http Connection (48.9%). The app uses unprotected
http connections for accessingremoteservices.
Hard-Coded Cryptographic Keys (47.7%) The app uses hard-
coded keys for encrypting or decrypting data. Attackers can
reverse-engineertheapp,extractthekeys,anddecryptall
data supposedlyprotectedbythis key.
WebViewMixedModeContent (47.4%)Theappallowsamix-
tureofcontentdownloadedusingTLSconnectionsaswellas
unprotectedconnectionsinsidethesameWebViewcontrol.
This may allow an attacker to inject malicious JavaScript
or misleadinggraphics (phishing) intoan otherwise benign
webapplicationshowninside an app.
WebView File Access (47.0%) Code in WebView controls may
access files, including ones inside the app’s data directory.
If untrusted code is loaded, this configuration may break
Android’sapp isolation.
Private Field/Method Access (41.2%) Apps access private fields
or methods via the Java reflection API, potentially skipping
importantinputvalidation orsecurity checks.
Deprecatedhttpclientimplementation (41.0%)Theappusesa
deprecated implementation of the http(s) client, which does
not support modern TLSversions.
StaticInitializationVector (36.0%)Aninitializationvectormust
bechosenatrandomtoprotectagainsttheuseofprecomputed
tables for brute-force attacks against encryption algorithms.
The sum of all percentages exceeds 100%, because one app may
contain multiple SRCSs. Some SRCSs are overlapping. An app that
activates universal access also implicitly activates file access. How-
ever, only explicit calls to the respective configuration APIs are
counted.Ifthedeveloperexplicitlyactivatesuniversalaccess,one
SRCSiscounted.Only ifthedeveloperalsoexplicitly(andunnec-
essarily) activates file access as well, asecondSRCSiscounted.
Figure10showsthedevelopmentofthetopfivefindingsover
thetwelveyearsofourdataset.Wefindthatthenumberofapps
affected by the top cryptography SRCSs is consistent with our
analysisofthe Cryptography categoryinthescanner(seeFigure 4).
Theuseofinsecurecryptoalgorithmsincreasesuntilabout2015
252SecurityCode Smellsin Apps: Are We Getting Better? ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore
2010 2012 2014 2016 2018 2020 2022050100150200250
Year#Apps
Hard-CodedCryptoKey
Insecure CryptoAlgorithm
Universal Access
Insecure http Connection
ContentProviderAccess
Figure 10:Development ofTopFindings (#Apps)
and then arrives at a platform at about 250 affected apps. It does
not decrease over time, as discussed in Section 4.4. The number
of apps thatcontain hard-coded cryptographickeysshowsaclear
increasing trend over the twelve years.
ThemisconfigurationofWebViewstoallowJavaScriptcodeto
access content providers increases until 2016 and then drops. It
remains open whether the rebound in 2021 is the beginning of a
trend.Wefindthecontentprovideraccesstrendlinetobeverysim-
ilar to the trend for universal access until 2015. Conceptually, both
SRCSs are similar as they affect the same Android class (WebView)
andtheaccesspermissionsoftheJavaScriptcodeloadedinsidethis
WebView.WefindthenumberofappswithuniversalaccessSRCSs
todropsignificantlyafter2016toabouthalfofthevaluefrom2016.
The methodthatenables universalaccesswas deprecatedinAPI
level 30 (Android 11) released in September 2020. We note that
developers stoppedusing this configurationseveral years before.
The use of insecure http connections (no TLS) decreases over
recentyearsaswell.Wenotethatthisdecreasestartedbeforethe
release of Android 9 with its API level 28. From this version on,
the Android operating system required apps to explicitly opt-in for
cleartext traffic using a network security configuration file. The
use of deprecated https client implementations also decreases over
recentyearsinaratesimilartothecleartexttrafficSRCS.Whilethe
networksecurityconfigurationistechnicallyindependentfromthe
TLSclient,developersthatupdatetheirapp’snetworkconnectivity
mayalsoswitch the TLSimplementation.
We furtheranalyze themostfrequent SRCSsin appsto investi-
gatetrends,i.e.thenumberofSRCSsfoundintheapps,regardlessof
the number of apps affected. As explained above, counts cannot be
used to compare different types of SRCSs, as some security config-
urationsare centralized(e.g.,network securityconfiguration)and
others are spread across the code (e.g., encryption algorithms spec-
ified with every cipher initialization). Still, we investigate whether
counting the SRCSs shows different trends than counting the apps
affectedbytheseSRCSsover the years.
WefindthepercentagesofindividualSRCSs(numberofoccur-
rences of a given SRCS divided by the total number of SRCSs of all2010 2012 2014 2016 2018 2020 20220200040006000
Year#Security-RelatedCode Smells (SRCSs)Insecure CryptoAlgorithm
Private Method/Field Access
Deprecatedhttps Client
Insecure http Connection
Content ProviderAccess
Figure 11:Development ofTopFindings (#Findings)
types)tobelow,withonly6SRCStypesexceeding5%.Wetherefore
presentonlythetopfivelist,whichstillaccountsformorethan50%
of all SRCSs. We find the top 5 SRCSs in terms of SRCS count to all
be contained in the top ten list of SRCSs when counting affected
apps, albeit inadifferentorder.
Insecure CryptoAlgorithm (15.4%)
PrivateField/Method Access (13.7%)
Content ProviderAccess fromWebViews (9.0%)
Insecure httpConnection (6.9%)
Deprecated httpclientimplementation (6.8%)
Figure11showsthedevelopmentofthetopfivefindingsinterms
of number of findings over the years. We see an increase in almost
alltypesofSRCSsovertheyears.Thefigureshowsaclearupwards
trend on the number of code locations that access private fields
ormethodusingtheJavareflectionAPI.Similarly,weseeasharp
increaseinthenumberoffindingsconcerningtheuseofinsecure
cryptographicalgorithms.Althoughtheuseofinsecurecryptoal-
gorithmsandtheprivatefield/methodaccessesshowsimilartrends,
bothtypesofSRCSarenotconnectedconceptually.Cryptometh-
odssuchas Cipher.getInstance() arepartofthepublicAPIof
the Java Cryptography Extension (JCE). Even if third-party imple-
mentations such as BouncyCastle are used, they integrate into JCE
as providers, which are referenced through algorithm and provider
namesprovidedasstrings. Therefore,noaccessto privatemethods
isnecessary.We conclude that both trends are independent.
BothtypesofSRCSincreasebythehighestrateafter2018,which
cannot be explained by the growth of apps in terms of code size
(number of Jimple statements). The sharp increase of app sizes
between2012and2016isnotreflectedintheSRCSs,andafter2018,
theappsizesonly growsubstantiallybetween2019and2020,but
notovertheentireperiod,asshowninFigure 1.Weobservethat
the number of findings per thousand lines of code increases, i.e.,
the qualityofthe code decreaseswithregardto theseSRCSs.
WefindthetwomostrelevantSRCSstoberesponsibleforabout
30%ofallfindings.Thetop10findingsaccountforalmost75%ofall
findings.Ifwehadnotexcludedthe Permissions category,halfofall
findings would be related to this category. The most common case
253ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore StevenArzt
isotherappsinvokingpermission-protectedAndroidAPIsviainter-
process communication (confused deputy attack). As explained in
Section2, most of these permissions are not sensitive, e.g., internet
access.Therefore,thiscategorydoesnotprovideadditionalinsights
intothe security ofapps.
5 DISCUSSION
Inthissection,weinterpretourevaluationdatainthecontextof
softwaredevelopmentbestpracticesandfutureresearchdirections.
Thenotionofsecurityvulnerabilitiesand therespectiveSRCSs
changeovertime.Cryptographicalgorithms,for example,canbe-
comeoutdatedduetoincreasesincomputationalpoweroradvances
in cryptanalysis. Theprincipletobuildapps andlibraries toallow
for exchanging algorithms later is known as crypto agility [12,23].
We therefore expect a current scanner (vulnerability patterns from
2022) todetect insecurecrypto algorithmsinolderapps, although
thesealgorithmswereconsideredsafewhentherespectiveappwas
built. However, we findthat more modern apps are more likely to
useoutdated cryptographythanolderapps.Further, modernapps
use outdated algorithms more frequently, i.e., at more positions in
the code. In other words, our data indicates that developers not
only fail to replace outdated algorithms, but introduce new uses of
outdatedalgorithms.Future researchshouldprovidebetter means
for refactoring legacyapps for cryptoagility.
Note that we cannot distinguish whether developers attempt
tofixexistingfeaturesthatdidnotusecryptographybyintroduc-
ingoutdatedalgorithmsfromnewfeaturesbeingintroducedwith
outdated algorithms. In other words, we do not know whether
theintroductionof,e.g.,MD5isbetterthanapreviousversionof
the same app with no protection at all. Further, we cannot infer
whetherthealgorithm isusedfor asecurity-criticalpurpose.Still,
developers should use modern algorithms in all cases to avoid vul-
nerabilities by avoiding insecure coding patterns entirely. There is
alreadylimitedworkonautomaticallyfixingcertaintypesofissues
regardless oftheircriticality [ 9,16].
While our evaluation has shown that SRCSs can be detected
in Android apps, our data also shows that the number of SRCSs
increases over the years. While not every potentially vulnerable
code pattern identified by a static code scanner is necessarily ex-
ploitable, itshowsthat,despite alladvances inthe field,developers
lacksupportforin-depthsecuritythatavoidssuchriskypatterns.
We therefore argue that novel approaches are required to integrate
software security intothe app developmentlifecycle.
WehaveidentifiedthatmostSRCSsarelocatedinapp-specific
codeandnotinlibrarycode.ThismakestheSRCSshardertofix,
because each app has a separate codebase with only a very limited
numberofsharedclasses.Therefore,developersandstoreoperators
mustcheckeachindividualapp,e.g.,beforeadmissiontothestore.
6 RELATED WORK
StatisticsontheGooglePlayStore,includingitsevolutionovertime,
havebeendonebefore.Thesepreviousstudiesfocusedonlanguage
features,libraryusage,andapplicationcontent[ 25,29].Otherstud-
ieshavefocusedontheevolutionofmalwareapps[ 14,27],orhave
derived insights into app development processes [ 17]. Arzt has
shown that shortcomings in security and quality are correlated [ 2].Some works on app store security have focused on the trustworthi-
nessofthird-partyappstores,e.g.,incountriesinwhichthePlay
Store isnot available [ 19,30].
AndroVul[ 18]annotatesappsfromAndroZoowithmetadataon
dangerous permissions, code smells, and results from AndroBugs8.
The latter provides six categories and 40 metrics. VUSC checks
formorethan370typesofvulnerabilities.Further,AndroVulper-
forms no longitudinal analysis of their data set. In summary, to the
best ofourknowledge, we arethefirstto analyzetheevolution of
vulnerabilitiesinbenign apps.
Many works have been published on detecting individual types
ofsecurityvulnerabilities(e.g.,inter-componentcommunication[ 6,
33] and TLS misconfigurations [ 32]) and potential privacy viola-
tions [3,7,8]. Further, commercial and open-source tools alike
integrate thesechecksintoscanners.
Existing work has also focused on vulnerabilities inherited from
third-party libraries compiled into the apps and whether app de-
velopers update theirdependencies [ 26]. Ourstudy, onthe other
hand,focuses onthe entire app includingapp-specific code.
In contrast to analyzing existing app stores and their apps, re-
searchers have proposed novel app stores that only distribute apps
thatarecompatiblewithsecurityandprivacypoliciesdefinedby
the user[ 15]orthe store operator [ 34].
7 CONCLUSION
In this paper, we have analyzed the development of app security
overtheyearsbetween2010and2021.Ouranalyseshaveshown
that the rate of security-related code smells (SRCSs) per 1,000 lines
ofcode,hasdecreasedovertime,andhasleveledoffatalowrate.
However,thisimprovementinsecurityisoutweighedbythecon-
tinuing increase in app size. Consequently, a randomly-chosen
app downloaded from the store in 2021 has more SRCSs than a
randomly-chosenappfrom2010.Wefindthisincreasetobedriven
by cryptographic weaknesses, insecure compiler flags, Java code
security flaws such as misuses of the Java reflection API, and in-
secure uses of WebView components. We argue that more work
isnecessarytoimprovethesecuritylevelofAndroidappsandto
avoid insecure code patterns. Further, developers should be trained
better to better maintain their code, e.g., by replacing outdated
cryptographicalgorithms.
As future work, we plan to repeat the study with different code
scanners and compare the results. We will further extend the anal-
ysis to other app stores aside from Google Play. We invite the com-
munitytoconfirmourresults,andtoinvestigatetherelationship
between SRCSsandexploitablesecurity vulnerabilities.
ACKNOWLEDGMENTS
ThisresearchworkhasbeenfundedbytheGermanFederalMin-
istryofEducationandResearchandtheHessianMinistryofHigher
Education, Research, Science and the Arts within their joint sup-
port of the National Research Center for Applied Cybersecurity
ATHENE.
8https://www.androbugs.com/
254SecurityCode Smellsin Apps: Are We Getting Better? ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore
REFERENCES
[1]Kevin Allix, Tegawendé F Bissyandé, Jacques Klein, and Yves Le Traon. 2016.
Androzoo:Collectingmillionsofandroidappsfortheresearchcommunity.In
2016 IEEE/ACM13thWorkingConferenceonMiningSoftwareRepositories (MSR) .
IEEE,468ś471.
[2]StevenArzt.2021.Securityandquality:twosidesofthesamecoin?.In Proceedings
ofthe10thACMSIGPLANInternationalWorkshopontheStateOftheArtinProgram
Analysis. 7ś12.
[3]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysis for android apps. Acm Sigplan Notices 49,6 (2014), 259ś269.
[4]Michael Backes, Sven Bugiel, and Erik Derr. 2016. Reliable third-party library
detectioninandroidanditssecurityapplications.In Proceedingsofthe2016ACM
SIGSAC Conference onComputer and Communications Security . 356ś367.
[5]Alexandre Bartel, Jacques Klein, Yves Le Traon, and Martin Monperrus. 2012.
Dexpler:convertingandroiddalvikbytecodeto jimpleforstaticanalysiswith
soot.InProceedings oftheACMSIGPLANInternational Workshopon State ofthe
Art inJava Programanalysis . 27ś38.
[6]MohamedAEl-Zawawy,EleonoraLosiouk,andMauroConti.2021. Donotlet
Next-Intent Vulnerabilitybeyournext nightmare:typesystem-based approach
todetectitinAndroidapps. InternationalJournalofInformationSecurity 20,1
(2021), 39ś58.
[7]William Enck, Peter Gilbert, Seungyeop Han, Vasant Tendulkar, Byung-Gon
Chun, Landon P Cox, Jaeyeon Jung, Patrick McDaniel, and Anmol N Sheth. 2014.
Taintdroid:aninformation-flowtrackingsystemforrealtimeprivacymonitoring
on smartphones. ACM Transactions on Computer Systems (TOCS) 32, 2 (2014),
1ś29.
[8]AdamPFuchs,AvikChaudhuri,andJeffreySFoster.2009. Scandroid:Automated
security certification of android applications. Manuscript, Univ. of Maryland,
http://www.cs. umd.edu/avik/projects/scandroidascaa 2,3 (2009).
[9]Jyoti Gajrani, Meenakshi Tripathi, Vijay Laxmi, Gaurav Somani, Akka Zemmari,
andManojSinghGaur.2020. Vulvet:Vettingofvulnerabilitiesinandroidapps
to thwartexploitation. DigitalThreats: Research and Practice 1,2 (2020), 1ś25.
[10]Shinelle Hutchinson, Bing Zhou, and Umit Karabiyik. 2019. Are We Really
Protected?AnInvestigationintothePlayProtectService.In 2019IEEEInterna-
tional Conference on Big Data (Big Data) . 4997ś5004. https://doi.org/10.1109/
BigData47090.2019.9006100
[11]PatrickLam,EricBodden,OndrejLhoták,andLaurieHendren.2011. TheSoot
frameworkforJavaprogramanalysis:aretrospective.In CetusUsersandCompiler
InfastructureWorkshop (CETUS2011) , Vol. 15.
[12]AnthonyLangsworth.2011. UsingStaticAnalysisToolstoDetectandCorrect
Non-CompliantCryptography. SIGSOFTSoftw.Eng.Notes 36,6(nov2011),1ś7.
https://doi.org/10.1145/2047414.2047427
[13]Menghao Li, Wei Wang, Pei Wang, Shuai Wang, Dinghao Wu, Jian Liu, Rui Xue,
and WeiHuo.2017. Libd:Scalableand precisethird-partylibrary detectionin
android markets. In 2017 IEEE/ACM 39th International Conference on Software
Engineering (ICSE) . IEEE,335ś346.
[14]Martina Lindorfer, Matthias Neugschwandtner, Lukas Weichselbaum, Yanick
Fratantonio, Victor van der Veen, and Christian Platzer. 2014. ANDRUBIS ś
1,000,000AppsLater:AViewonCurrentAndroidMalwareBehaviors.In 2014
Third International Workshop on Building Analysis Datasets and Gathering Experi-
enceReturnsforSecurity(BADGERS) .3ś17.https://doi.org/10.1109/BADGERS.
2014.7
[15]SteffenLortz,HeikoMantel,ArtemStarostin,TimoBähr,DavidSchneider,and
Alexandra Weber. 2014. Cassandra: Towards a Certifying App Store for Android.
InProceedingsofthe4thACMWorkshoponSecurityandPrivacyinSmartphones&
MobileDevices (Scottsdale,Arizona,USA) (SPSM’14) .AssociationforComputing
Machinery,NewYork,NY,USA,93ś104. https://doi.org/10.1145/2666620.2666631
[16]SiqiMa,DavidLo,TengLi,andRobertHDeng.2016. Cdrep:Automaticrepair
of cryptographic misuses in android applications. In Proceedings of the 11th ACM
onAsiaConference onComputer and Communications Security . 711ś722.
[17]William Martin, Federica Sarro, Yue Jia, Yuanyuan Zhang, and Mark Harman.
2017.ASurveyofAppStoreAnalysisforSoftwareEngineering. IEEETransactions
on Software Engineering 43, 9 (2017), 817ś847. https://doi.org/10.1109/TSE.2016.2630689
[18]Zakeya Namrud, Sègla Kpodjedo, and Chamseddine Talhi. 2019. AndroVul: A
repository for Android security vulnerabilities. In Proceedings of the 29th Annual
InternationalConference onComputer Scienceand SoftwareEngineering . 64ś71.
[19]Yi Ying Ng, Hucheng Zhou, Zhiyuan Ji, Huan Luo, and Yuan Dong. 2014. Which
Android appstore can be trusted in China?. In 2014 IEEE 38th AnnualComputer
Softwareand ApplicationsConference . IEEE,509ś518.
[20]JPNicholasandSSean.2012. AdventuresinBouncerLand:FailuresofAutomated
Malware Detection within MobileApplication Markets. Proceedingsofthe Black
Hat USA2012, TrustwaveSpiderLabs (2012).
[21]JonOberheideandCharlieMiller.2012. Dissectingtheandroidbouncer. Sum-
merCon2012,NewYork 95(2012), 110.
[22]National Institute of Standards and Technology. 2019. Security Requirements for
CryptographicModules . TechnicalReportTransitioningtheUseofCryptographic
AlgorithmsandKeyLengths.U.S.DepartmentofCommerce,Washington,D.C.
https://doi.org/10.6028/NIST.SP.800-131Ar2
[23]Jonathan Protzenko, Bryan Parno, Aymeric Fromherz, Chris Hawblitzel, Ma-
rina Polubelova, Karthikeyan Bhargavan, Benjamin Beurdouche, Joonwon Choi,
Antoine Delignat-Lavaud, Cédric Fournet, Natalia Kulatova, Tahina Ramananan-
dro, Aseem Rastogi, Nikhil Swamy, Christoph M. Wintersteiger, and Santiago
Zanella-Beguelin. 2020. EverCrypt: A Fast, Verified, Cross-Platform Crypto-
graphic Provider.In 2020 IEEESymposiumonSecurity and Privacy (SP) .983ś1002.
https://doi.org/10.1109/SP40000.2020.00114
[24]Siegfried Rasthofer, Steven Arzt, Robert Hahn, and Max Kolhagen. 2015. (In)
Securityof Backend-as-a-Service. (2015).
[25]Siegfried Rasthofer, Steven Arzt, Max Kolhagen, Brian Pfretzschner, Stephan
Huber,EricBodden,andPhilippRichter.2015. Droidsearch:Atoolforscaling
android app triage to real-world app stores. In 2015 Science and Information
Conference (SAI) . IEEE,247ś256.
[26]Pasquale Salza, Fabio Palomba, Dario Di Nucci, Cosmo D’Uva, Andrea De Lucia,
and Filomena Ferrucci. 2018. Do Developers Update Third-Party Libraries in
MobileApps?.In Proceedings ofthe 26th ConferenceonProgramComprehension
(Gothenburg,Sweden) (ICPC’18) .AssociationforComputingMachinery,New
York, NY, USA,255ś265. https://doi.org/10.1145/3196321.3196341
[27]Guillermo Suarez-Tangil and Gianluca Stringhini. 2020. Eight years of rider
measurementintheandroidmalwareecosystem. IEEETransactionsonDependable
and SecureComputing (2020).
[28]RajaVallee-RaiandLaurieJHendren.1998. Jimple:SimplifyingJavabytecode
for analysesand transformations. (1998).
[29]NicolasViennot,EdwardGarcia,andJasonNieh.2014. AMeasurementStudy
ofGooglePlay.In The2014ACMInternationalConferenceonMeasurementand
ModelingofComputerSystems (Austin,Texas,USA) (SIGMETRICS’14) .Association
for Computing Machinery, New York, NY, USA, 221ś233. https://doi.org/10.
1145/2591971.2592003
[30]Haoyu Wang, Zhe Liu, Jingyue Liang, Narseo Vallina-Rodriguez, Yao Guo, Li Li,
JuanTapiador, Jingcun Cao, and Guoai Xu. 2018. Beyond Google Play: ALarge-
Scale Comparative Study of Chinese Android App Markets. In Proceedings of the
Internet Measurement Conference 2018 (Boston, MA, USA) (IMC ’18). Association
for Computing Machinery, New York, NY, USA, 293ś307. https://doi.org/10.
1145/3278532.3278558
[31]Yan Wang, Haowei Wu, Hailong Zhang, and Atanas Rountev. 2018. Orlis:
Obfuscation-resilientlibrary detectionforAndroid.In 2018IEEE/ACM5th Inter-
nationalConferenceonMobileSoftwareEngineeringandSystems(MOBILESoft) .
IEEE,13ś23.
[32]YingjieWang,GuangquanXu,XingLiu,WeixuanMao,ChengxiangSi,Witold
Pedrycz,andWeiWang.2020. IdentifyingvulnerabilitiesofSSL/TLScertificate
verificationinAndroidappswithstaticanddynamicanalysis. JournalofSystems
and Software 167(2020), 110609. https://doi.org/10.1016/j.jss.2020.110609
[33]MuZhangandHengYin.2014.AppSealer:AutomaticGenerationofVulnerability-
Specific Patches for Preventing Component Hijacking Attacks in Android Appli-
cations.. In NDSS.
[34]YuryZhauniarovich,OlgaGadyatskaya,andBrunoCrispo.2013.DEMO:Enabling
TrustedStoresforAndroid.In Proceedingsofthe2013ACMSIGSACConferenceon
Computer &CommunicationsSecurity (Berlin, Germany) (CCS’13). Association
forComputingMachinery,NewYork,NY,USA,1345ś1348. https://doi.org/10.
1145/2508859.2512496
255