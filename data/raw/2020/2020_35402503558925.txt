PolyFax: A Toolkitfor Characterizing Multi-languageSoftware
WenLi
WashingtonStateUniversity
Pullman, WA, USA
li.wen@wsu.eduLiLi
MonashUniversity
Melbourne, Victoria, Australia
li.li@monash.eduHaipeng Caiâˆ—
WashingtonStateUniversity
Pullman, WA, USA
haipeng.cai@wsu.edu
ABSTRACT
Todayâ€™s software systems are mostly developed in multiple lan-
guages(i.e.,multi-languagesoftware),yettoolsupportforunder-
standing andassuring these systems israre. To facilitate future re-
searchonmulti-languagesoftwareengineering,thispaperpresents
PolyFax,atoolkitthatoffersautomatedmeansfordatasetcollec-
tion from GitHub and two analysis utilitiesÃa vulnerability-fixing
commitcategorizationtool(VCC)andalanguageinterfacingmech-
anism identification/categorization tool (LIC). The VCC tool im-
mediately assists with assessing the vulnerability proneness of a
given multi-languageproject basedon itsversion histories,while
the LIC tool enables dissection of the most important aspect of the
constructionofmulti-languagesystems.Applicationof PolyFax to
7,113multi-languageprojectswith12.6millioncommitsshowedits
practical usefulness in terms of promising efficiency and accuracy.
CCSCONCEPTS
Â·Security and privacy â†’Software security engineering .
KEYWORDS
multi-language software,tool,language interfacing,vulnerability
ACM ReferenceFormat:
WenLi,LiLi,andHaipengCai.2022. PolyFax:AToolkitforCharacterizing
Multi-language Software. In Proceedings of the 30th ACM Joint European
Software Engineering Conference and Symposium on the Foundations of Soft-
wareEngineering(ESEC/FSEâ€™22),November14Å›18,2022,Singapore,Singapore.
ACM,NewYork,NY,USA, 5pages.https://doi.org/10.1145/3540250.3558925
1 INTRODUCTION
Large-scalestudiesofexistingsoftwareprojects,alongwiththecor-
respondingcoderepositories(e.g.,thoseonGitHub),havepropelled
significantprogressinunderstandinghenceimprovingmodernsoft-
ware systems. Practical tool support forminingsuchprojects and
analyzingthosesystemscanbegreatlyinstrumental[ 31],asthey
allowresearcherstofocusmoreonthecoreresearchquestionsand
insights. For instance, tools for automated data collection/crawl-
ing,filtering/cleaning,and commoncharacterizationanalysesare
essentialforresearch basedon miningopen-source projects.
In fact, a large body of research aims to mine and study open-
sourcerepositories[ 5,6,8,18,19,25,28Å›30,32],enabledoratleast
âˆ—Haipeng Caiis thecorresponding author.
ESEC/FSE â€™22,November 14Å›18, 2022, Singapore, Singapore
Â©2022 Copyright held bytheowner/author(s).
ACM ISBN978-1-4503-9413-0/22/11.
https://doi.org/10.1145/3540250.3558925facilitated by the underlying characterization tools. However, few
of these studies [ 30] provided a commonly reusable set of data
collectionandcharacterizationutilities(e.g.,forprojectprofiling,
completecommits/sourceretrieval,etc.).Mostimportantly,existing
characterizationtools(e.g.,D2A[ 32]andVccFinder[ 28])arelargely
limited to single-language projects. Tools dealing with typically
multi-languageprograms(e.g.,[ 7,17]forAndroidappswithnative
codeand[ 10Å›13]fordistributedsystemsoftenbuiltwithvarious
languagesfordifferentcomponents)endeduponlyaddressingpart
ofthose systems that is written in one language (e.g.,Java).
Yet the majority of todayâ€™s software systems are written in mul-
tiplelanguages(hencetheyarenotedas multi-language software)Ã
for example, a recent prior study [ 23] confirmed that more than
80%ofopen-sourceprojectsonGitHubaredevelopedwithmore
thanone language.It is also found latelythatmulti-language soft-
ware is notably prone to security vulnerabilities mainly induced
bythe interfacing betweendifferent languages used inasoftware
project[22]Ãinfact,thispronenesshasfoundcorrespondenceto
cross-languagevulnerabilitieswithsevereconsequences[ 24].On
the other hand, tools supporting studies of multi-language soft-
ware (e.g., those for identifying language interfacing and assessing
pronenesstovulnerabilitiesacrosslanguages)arecriticallylacking.
To fill this gap, we present PolyFax, a toolkit for characterizing
multi-language projects on GitHub and dissecting the construction
of multi-language systems. PolyFax consists of three related tool-
s/modules:Acrawler,ascrubber,andtwoanalyzers.Thecrawler
retrievesprojectdatapergivencriteria,includinggeneralproperties
andhistoricalcommits(i.e.,commitlogs,authors,codesnippets)
andsources.Thescrubbersupportsdatapre-processingtofacilitate
further analysis. As two instances of such analyses, PolyFax in-
cludesa tool forvulnerability-fixing commit categorization(VCC)
andoneforlanguage-interfacingidentification/categorization(LIC).
TheVCCtoolclassifiesagivencommitasonethatpotentiallyfixesa
vulnerabilityofaparticularclass,basedonfuzzymatchingbetween
thecommitlogandkeywords/phasessummarizedfromCWE[ 1].
The LICtool identifiesthe mechanismsin which the different lan-
guages usedin amulti-language systeminterface with eachother.
To assess its efficiency and effectiveness, we used PolyFax to
characterize 7,113 projects with 12.6 million commits. It finished
crawling, scrubbing, and analyzing the 193.9GB data in 23.1, 1.1,
and 17.2 hours (1.47 for VCC and 2.5 for LIC), respectively. Our
evaluation of the two analyzers based on random sampling and
cross-validation showed that they achieved 80%+ precision and
recall.PolyFax is the technical enabler of a recent study on the
vulnerability proneness of multi-language software [ 22] and ex-
pected to serve future studies of these systems. The VCC tool is
alsoimmediately applicable tosingle-language projects.
A demovideofor PolyFax ishereandtoolpackage here[20].
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
1662
ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore WenLi, LiLi, andHaipeng Cai
2 ARCHITECTURE
PolyFaxPolyFax
Configure Github
ReportsCrawlerProject metadataScrubber Analyzer
VCC-analyzer
LIC-analyzer
â€¦â€¦
Figure1:Overviewof PolyFax .Figure1gives an overview
ofPolyFaxâ€™s architecture. As
itsprimaryinput, PolyFax re-
trieves open-source projects
from GitHub [ 4]; optionally,
users can customize the con-
figuration as another input to
letPolyFax only collectsam-
ples ofinterests.
With these inputs, PolyFax performs data analysis with three
modules:Crawler,Scrubber andAnalyzer . Atfirst,the Crawler
grabs repository profiles, clones the projects, and retrieves histori-
cal commits to the specified local storage. Then, the Scrubber per-
formspre-processing[ 16]ofthetextualinformation(e.g.,project
descriptions,commit logs)outofallthe projectmetadata.
Finally, the Analyzer executes vulnerability-fixing commit cat-
egorization (VCC) and language interfacing mechanism categoriza-
tion(LIC).VCC utilizes theFuzzyWuzzytechnique [ 9]oncommit
logs to classify the commits into three high-level vulnerability cat-
egories (i.e., Porous defenses, Risky resource management, and
Insecure interaction) [ 1]. LIC takes project sources as input and
scansthemwithafinitestatemachine(FSM)modeledonsummaries
oflanguageinteraction patterns;itoutputs atuple oflanguagein-
terfacingmechanismsfor eachproject.Afterallof theseanalyses
complete,the Analyzer reports the results to users.
3 DESIGN AND IMPLEMENTATION
This section describesthedesign and implementationof PolyFax,
elaboratingits three modules: crawler,scrubber,andanalyzer.
3.1 Crawler
Crawler
by-DomainCrawler
by-Language
GithubCommit 
CrawlerRepository profiles
CommitsProfile Crawler
Figure 2:Overview of PolyFax .TheCrawler searches
repositories using the
GitHub API [ 2], filter-
ing/grabbingreposito-
ries matching the cri-
teria as configured. Specifically, it consists of three sub-modules,
twoProfile Crawlers (i.e., Crawler-by-Language and Crawler-by-
Domain) anda CommitCrawler ,as showninFigure 2.
3.1.1 Profile Crawler. A specific configuration defines the crite-
ria of repository collection, specifying project attributes such as
popularity, primary languages, size, creation date, and updated
date.Withtheseconstraintvalues,the ProfileCrawler constructs
profile requests following the manual ofGitHubâ€™sAPI [ 2].
Twoprofilecrawlersareavailablein PolyFaxforcomplementary
purposes. Crawler-by-Language grabs repositories according to
the user-specified languages while Crawler-by-Domain searches
andgrabsrepositoriesbasedonagivenfunctionality-domainlist.
When no languages or domains are specified, the crawler grabs
projectswithstars greater than1,000 (configurable)bydefault.
For the over 70 different project properties available on GitHub,
PolyFax retrieves7(i.e.,repositoryid,stargazerscount,languages,
URL, pushed date, topics, and description). Users can customize toinclude more or less to meet varying analysis needs. As the output,
asetofrepository profiles isstoredinadatabase.
3.1.2 CommitCrawler. Withtherepositoryprofilesasinput, Com-
mitCrawler clonesalltheprojectstothelocalstorage,andthen
retrieves (simply using git) and parses all the commit information
for each repository. This approach is much more efficient than
grabbing thecommitsusing GitHubAPIsdueto therate limitsof
GitHub [2]. For each commit, PolyFax saves five primary features
(i.e.,commitidentifier,author,date,relatedissue(ifexisted),and
commitlog);henceuserscanretrievecodechangesanddetailsof
issuesfor the commits for further,in-depthanalyses.
3.2 Scrubber
Usually,aninsightfulanalysisisnotreadilyfeasiblebyjustdirectly
using the raw, potentially noisy (e.g., textual) information [ 16].
Hence, the Scrubber is responsible for data cleaning, taking the
raw text (e.g., project descriptions, commit logs) as input. This
pre-processing procedure transforms the text to accommodate a
naturallanguageprocessing(NLP)algorithmviafourstepswhile
leveraging NLTKfor Python[ 3]: (a) remove all charactersbesides
numbers, letters, and commas from the input text; (b) tokenize
remaining text; (c) lemmatize each token; and (d) eliminate stop
words.Thisprocessresultsinasetofwordsthatcapturethecritical
information for eachtextsnippet.
3.3 Analyzer
TheAnalyzer analyzesthedatacollectedfromGitHub.Specifically
inPolyFax,itincludes twoanalysistools: VCCandLIC.
3.3.1 Vulnerability-FixingCommitCategorization(VCC). Wede-
velopedVCCbased on the following assumption: If the log of a
commitcontainskeywords/phrasesindicatingaclassofvulnerabili-
ties,thenweregardthecommitasaimingtofixthosevulnerabilities.
This is in the same spirit as prior work [ 29] identifying bug-fixing
commits basedonkeywordsearch incommit logs.
Based on the assumption, VCCworks in two steps: (1) Vulnera-
bilitykeywordssummarizing.Bysummarizingthetop25mostdan-
gerousCWEs[ 1],threehigh-levelcategories[ 26]areobtainedas
Porousdefenses(11CWEs),Riskyresourcemanagement(8CWEs),
and Insecure interaction (6 CWEs). We applied the Scrubber to
the description for each category and extracted security-related
keywords or phrases. (2) Vulnerability keywords matching. Based
on the per-category keywords, we improved the FuzzyWuzzy tech-
nique [9]to classifycommit logsas outlinedinAlgorithm 1.
The algorithm first retrieves these categories (line 2) and cleans
thegivencommitwithpre-processText(line3),followedbycomput-
inga matchscore between each category and the commit (lines 5-
21). Specifically, it retrieves (line 7) and traverse keywords/phrases
in each category (lines 8-20). Next, the commit log is split into
ğ‘›-grams (lines 9-17) for a given phrase/keyword of length ğ‘›and
matched against thephrasewithFuzzyWuzzy (line18). Forbetter
precision, we use a minimal score of 90 as the threshold (lines 6)
andtakethethehighestscoreforallphrasesofacategory(lines19-
20)asthescore againstthat category(line21). The best-matching
category is eventually returned as the vulnerability category for
the given commit (lines22-23).
1663PolyFax: A ToolkitforCharacterizing Multi-languageSoftware ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Algorithm1: Identifying and classifying a vulnerability-fixing commit
Input:ğ¶ğ‘šğ‘šğ‘¡:a commit includingitslogandcodesnippet
Output:ğ‘£ğ¶ğ‘ğ‘¡:thevulnerability category of ğ¶ğ‘šğ‘šğ‘¡
1Function classifyCommit (ğ¶ğ‘šğ‘šğ‘¡)
2ğ‘‰ğ¶â†initVulCategory () /* Categories with keywords/phrases */
3ğ¶ğ‘šğ‘šğ‘¡â†pre-processText (ğ¶ğ‘šğ‘šğ‘¡)/* Tokenize, stemmatize, etc. */
4ğ¶ğ‘ğ‘¡ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’â†ğœ™
5foreachğ¶ğ‘ğ‘¡inğ‘‰ğ¶do
6 ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’â†90 /* The minimum match score as the threshold */
7 ğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’ğ¿ğ‘–ğ‘ ğ‘¡â†ğ¶ğ‘ğ‘¡.phrases /* Keywords/phrases of category ğ¶ğ‘ğ‘¡*/
8 foreachğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’inğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’ğ¿ğ‘–ğ‘ ğ‘¡ do
9 ğ‘ğ‘â†getWordNum (ğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’)/* 1 ifğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’ is a keyword */
10 ğ‘ğ‘â†getWordNum (ğ¶ğ‘šğ‘šğ‘¡) /* Number of tokens */
11 ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘’ğ‘¡â†ğœ™/* The set of n-grams in ğ¶ğ‘šğ‘šğ‘¡;ğ‘›=ğ‘ğ‘*/
12 ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥â†0
13 whileğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥<ğ‘ğ‘do
14 ğ¸ğ‘›ğ‘‘â†ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥+ğ‘ğ‘ /* Split ğ¶ğ‘šğ‘šinto n-grams */
15 ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘¡ğ‘Ÿâ†ğ¶ğ‘šğ‘šğ‘¡[ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥:ğ¸ğ‘›ğ‘‘]
16 ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘’ğ‘¡ .append(ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘¡ğ‘Ÿ )
17 ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥++
/* Match ğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’ againstğ¶ğ‘šğ‘šâ€™s n-grams with FuzzyWuzzy */
18 ğ‘…ğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡=FuzzyWuzzy. extractOne (ğ‘ƒâ„ğ‘Ÿğ‘ğ‘ ğ‘’,ğ‘¥ğºğ‘Ÿğ‘ğ‘šğ‘†ğ‘’ğ‘¡ )
19 ifğ‘…ğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡.ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ >ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’then
20 ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’â†ğ‘…ğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡.ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’
21 ğ¶ğ‘ğ‘¡ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’ [ğ¶ğ‘ğ‘¡]=ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’/* Keep the best match score with ğ¶ğ‘ğ‘¡*/
22ğ‘£ğ¶ğ‘ğ‘¡â†maxScoreCat (ğ¶ğ‘ğ‘¡ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’ )/* Take the best-matched category */
23 returnğ‘£ğ¶ğ‘ğ‘¡
3.3.2 Language Interface Categorization (LIC). Through manually
checking respective languagesâ€™ official documentation, we derived
fourbasic languageinterfacingmechanisms:
(1)Foreign function invocation (FFI). With FFI, the host language
providesaforeignfunctioninterfacetobridgeitsownsemantics
and calling conventions and those of the guest languageâ€™s (e.g.,
Java Native Interface(JNI)inJava).
(2)Implicit invocation (IMI). IMI is a cross-language interfacing
mechanism based on inter-process communications (e.g., re-
mote procedure call(RPC)).
(3)Embodiment (EBD). With this mechanism, the languages are
interdependent and coexist with each other, with the code of
one language often embedded in that of another language (e.g.,
the interfacingamong { css,html,javascript }).
(4)Hiddeninteraction(HIT). WithHIT,thereisnoexplicitindica-
tion of direct interaction between languages, but there may be
indirectdata connection between differentlanguages.
Then,wedevisedarule-basedclassificationmodel Cbasedon
pattern matching andfinitestate machine (FSM) as follows:
C=(ğ‘ 0,F,ğ›¿,S,R,Î¦), ğ‘ 0,FâˆˆS, ğ›¿âˆ—: SÃ—Râˆ—â†’S
Inthemodel, ğ‘ 0andFrepresenttheinitialandendstaterespectively;
Sisthestateset; Risthepatternset; ğ›¿isthestatetransitionfunction
andÎ¦isaregularexpressionengine.Given asequenceofinputs
I={ğ¼0,ğ¼1,...,ğ¼ğ‘›},Cobtains a set of matched rules R=Î¦(I); iff
ğ›¿âˆ—(ğ‘ 0,R)=Fthen we sayIisclassifiedby C.
FFI classifier 
set
IMI classifier 
set
EBD classifier 
set
HIT classifier 
setC_Python 
classifierâ€¦â€¦ 
classifierRuby_Java 
classifier
S0S1
F
S2Import.*ctypes
#include <Python.h>ctypes.CDLL
Py_Initialize.*â€¦â€¦
â€¦â€¦
â€¦â€¦Language manuals
LICE
Categories RepositoryClassifier 
encode module
Classifier 
scan module
Figure 3:Languageinterfacingmechanismclassification.Algorithm2: Classifyingaprojectbylanguageinterfacingmechanisms
Input:ğ‘ƒ:a multi-language project repository
Output:ğ¿ğ‘ƒ:theset ofinterfacingmechanism labels for ğ‘ƒ
1Function classifyProject (ğ‘ƒ)
2ğ´ğ¶â†getClassifiers ()/* Convene all the classifiers in L ICE*/
3ğ‘…â†compileRegex (ğ´ğ¶) /* Compile all regexs in ğ´ğ¶*/
4ğ‘…ğ¶â†createMap (ğ´ğ¶)/* Create a map from regexs to classifiers */
5foreachğ‘“ğ‘–ğ‘™ğ‘’inğ‘ƒdo
6 ğ‘…ğ‘€â†scanRegex (ğ‘…,ğ‘“ğ‘–ğ‘™ğ‘’) /* Obtain matched regexs */
7 ğ‘ƒğ¶â†pickClassifier (ğ‘…ğ¶,ğ‘…ğ‘€)/* Fetch relevant classifiers */
8 foreachğ¶inğ‘ƒğ¶do
9 ifclassifyMatch (ğ¶,ğ‘…ğ‘€)then
10 ğ¿ğ‘ƒ.insert (ğ¶.ğ‘™ğ‘ğ‘ğ‘’ğ‘™) /* One mechanism recognized */
11 ifğ¿ğ‘ƒ==âˆ…then
12 ğ¿ğ‘ƒ.insert (Å‚HIT") /* Not FFI, IMI, or EBD, so defaulted to HIT */
13 returnğ¿ğ‘ƒ
14Function classifyMatch (ğ¶,ğ‘…ğ‘€)
15ğ‘†ğ‘„â†initStateQueue (ğ¶)/* Initialize with the initial state of ğ¶*/
16 foreachğ‘Ÿğ‘šinğ‘…ğ‘€do
17 ğ‘ğ‘™ğ‘’ğ‘›â†ğ‘†ğ‘„.length
18 forğ‘˜â†0toğ‘ğ‘™ğ‘’ğ‘›âˆ’1do
19 ğ‘†â†ğ‘†ğ‘„[ğ‘˜]
20 ğ‘ğ‘†â†nextState (ğ‘†,ğ‘Ÿğ‘š)/* State transition on input ğ‘Ÿğ‘š*/
21 ifğ‘ğ‘†==ğ‘ğ‘ˆğ¿ğ¿then
22 continue
23 ifisFinalState (ğ¶,ğ‘ğ‘†)then
24 returnTRUE /* Reached a final state */
25 else
26 ğ‘†ğ‘„.push (ğ‘ğ‘†)/* Save context for a matched pattern */
27 returnFALSE
Basedonthismodel,wedevelopedalanguageinterfacingclassi-
ficationengine(LICE),asshowninFigure 3.LICEconsistsoftwo
collaboratingmodules: Classifier encode andClassifier scan .
(1)Classifier encode module (CEM). CEM aims to construct a chain
ofclassifierset( FFI,IMI,EBD,andHIT).FortheFFIclassifierset,
we manuallysummarized the interfacing code patterns for top
languages[ 14];and20 FFIclassifierswerefinallyconstructed
(e.g.,c_java,c_python ). For IMI, we implemented 7 classifiers
byinvestigatingcodepatternsbased onstandardcomponents
that support remote calls (e.g., D-bus [ 27], gRPC [15]). TheEBD
classifier set consists of one classifier for languages {javascript,
css,html}asonlythesethreelanguagesareinterdependentand
existinthetoplanguageselections.The HITsetincludesone
classifier for the projectswithoutexplicit code patterns.
(2)Classifier scan module (CSM). With a repository as input, CSM
scans the source files one by one and works in a best-effort
fashiontoobtainalllanguageinterfacingtypes.Asshownin
Algorithm 2,aftercompilingregexsinalltheavailableclassi-
fiers (lines 2-4), PolyFax finds matched patterns R=Î¦(I)(line
6) in each file (line 5) and picks relevant classifiers (line 7). If
a classifier accepts all the matched patterns (regexs), the cor-
respondingmechanismisrecognized(line8-10).Todetermine
the acceptance, PolyFax runs the nFSM as a non-deterministic
finiteautomatonagainstthoseregexs(lines15-27).Importantly,
it maintains a matching context (via the state queue ğ‘†ğ‘„) to
obtain allpossiblyacceptedregex sequences.
4 EVALUATION
Weevaluate PolyFax throughthefollowingtworesearchquestions:
(1)RQ1Whatisthe efficiency of PolyFax?
(2)RQ2Whatisthe accuracyof PolyFax?
1664ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore WenLi, LiLi, andHaipeng Cai
Table1:Timecostofindividualmodulesonanalysisof7,113
projectswith 12.6million commits.
Module Crawler Scrubber VCCLIC
Time cost (inhours) 23.1 1.1 14.72.5
Table2:PolyFax â€™stimecostswithgrowingsamplesizes(T-*
denotes Å‚the timecost(in minutes)of").
SubsetNo. #Projects Size(GB) #Commits(K) T-VCC T-LIC
1 1,113 20.2 1,134 77.1 18.2
2 2,000 50.3 3,150 173.3 39.6
3 4,000 121.4 8,316 404.5 96.5
ExperimentSetup. We ran the Crawler inPolyFax without lan-
guages or domains specified; the default star count for repositories
wasconfigured in[1000, 15000], andonly multi-language projects
were saved. Both Crawlers andAnalyzers inPolyFax worked in
asingleprocess.AllexperimentswereconductedonaUbuntu18.04
systemwitha32-core AMD 3970X CPUand256GB memory.
4.1 RQ1: Efficiencyof PolyFax
With the defaultconfiguration, PolyFax took a total of 41.4 hours
tofinishthewholeprocessofdatacollectionandanalysis,during
which 7,113 projectsand12.6 million commits were collected [ 21].
The time costs of individual modules are shown in Table 1. By
contrast, PolyFax is much more efficient since it could take about
three months to grab 12.6million commits byGitHubAPI [ 2].
Tofurtherevaluatetherelationshipbetweentheefficiencyofthe
twoanalyzersandthesamplesize,Wedividedthe7,113samples
into three subsets and evaluated the time cost on the subsets as
showninTable 2.Fromtheresults,wecanseethatthetimecost
of VCC grows almost linearly as the number of projects or the
number of commits increases; a similar correlation can be found
betweenLICandcommitorprojectcount.Thisshowsthat PolyFax
iscapableof(scalablefor) large-scale repository mining.
4.2 RQ2: Accuracyof PolyFax
To evaluate the effectiveness of PolyFax, we adopted a strategy of
random sampling followedbycross-validation.
Evaluation of VCC. To evaluate the accuracy of VCC, we ran-
domlysampled50projectsand500commitsperprojectfromthe
dataset and constructed ground truth manually for gauging the
precisionandrecallofVCC.Specifically,theauthorsindependently
labeled the sampled commits following three steps: (1) read the
commit log, (2) check the associated code snippet, and (3) check
the issuecomments if they exist.
It is worth noting that each ground-truth vulnerability-fixing
commit corresponds to an actual/confirmed vulnerability rather
thanjustkeyword/phrasematches.Afteralltheauthorscompleted
independentlabeling,theycross-validatedandacceptedthelabelfor
eachcommit when all agreed. For cases withinitialdisagreement,
dedicateddiscussionswere held to reachfinal decisions.
Table3summarizes the evaluation results. While not compli-
cated, our tool achieved a quite competitive level of accuracy com-
paredtothestate-of-the-artpeertoolD2A[ 32],whichonlyreported
53%accuracy(basedonasmallmanualstudyofonly57commitsin
total)Ãalthoughwecannotmakestrongclaimsheresincewedid
notcomparebothtoolsonthesamedataset.Moreover,D2Aonly
targets C/C++ projects while PolyFax is language-independent;
hence itcan be appliedmore broadly.Table 3:Cross-validation results ofthe VCC tool
Category % Commits Precision Recall
Porousdefenses 43% 85% 89%
Riskyresourcemanagement 48% 83% 81%
Insecure interaction 9% 91% 83%
Table 4:Cross-validation results ofthe LIC tool
Category %Projects %Precision %Recall
FFI 28% 85% 89%
IMI 69% 78% 82%
EBD 35% 96% 90%
HIT 11% 81% 84%
Evaluation of LIC. Per its design, LIC can identify a set of lan-
guage interfacing mechanisms for each input repository. For in-
stance,givenarepositorywithlanguageselection{ java,c,python},
LIC may classify it as { FFI, II} because javainteracts with c
through JNI while cinteracts with pythonthrough D-bus. To eval-
uateLICâ€™sprecision,werandomlysampled150projectsandcon-
ductedacross-validationproceduretomeasuretheprecisionand
recallbasedonmanualgroundtruth.Accordingto theimplemen-
tation described in Section 3.3.2, the evaluation results are based
onthe samplesâ€™top languages[ 14]. Table4presents the precision
andrecallof LIConthesamples;since LICEsummarizedallthe
possible interfacing mechanisms between top languages according
to the respective official manuals, it achieved high precision and
recall. Specifically, the precision ranged from a minimum of 78%
for IMI upto 96%for EBD,andthe recallrangedfrom 82%to 90%.
4.3 Discussion
PolyFax offers a series of useful features, including repository
crawling,commitclassification,andlanguageinterfacingcatego-
rization.Itsprecisionandrecallindicateitspotentialofbeingappli-
cable for multiple purposes. For example, the VCC can be used for
empiricalanalysisaswellsforprovidingabundanttrainingdatafor
machinelearning(ordeep learning)basedvulnerabilitydetectors
sincethecodesnippets,issues,orevenCVEsofthecommitscan
be retrieved from the results of VCC. Moreover, it is not limited to
particularlanguagesdueto its language-independent nature.
Foranotherexample,resultsoftheLICmayinformthedesign
ofacross-languagevulnerabilitydetectorÃalgorithmsspecificto
eachinterfacingmechanismwillbemoreprecisethangenericones
for arbitrary interfacing mechanisms. For instance, for FFI, the
algorithm may identify vulnerabilities with more precise data flow
analysisbasedonforeign/native function calls.
5 CONCLUSION
We presented PolyFax, a novel toolkit for characterizing multi-
language software. It offers the capabilities of mining the reposito-
ries of open-source multi-language projects. It also includes two
analysistools,forvulnerability-fixingcommitcategorizationand
language interfacing mechanism identification/categorization, re-
spectively.Weempiricallydemonstrated PolyFaxâ€™smeritsineffi-
ciencyandeffectivenessagainstreal-worldopen-sourceprojects
onGitHub. PolyFax isopen sourceandpubliclyavailable.
ACKNOWLEDGMENT
Wethank ourreviewersforconstructivecomments. Thisresearch
wassupportedbyNSF (CCF-2146233) andONR (N000142212111).
1665PolyFax: A ToolkitforCharacterizing Multi-languageSoftware ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
REFERENCES
[1]2020. categories of security vulnerabilities. https://cwe.mitre.org/top25/archive/
2011/2011_cwe_sans_top25.pdf .
[2]2020. GitHubDeveloper:providesAPIstoretriveorqueryrepositoriesinGitHub.
https://developer.github.com/v3 .
[3]2020. NLTK:platformforbuildingPythonprogramstoworkwithhumanlan-
guagedata. https://www.nltk.org .
[4]2021. GitHub:aUS-basedglobalcompany, provideshostingforsoftwaredevel-
opment version controlusing Git. https://github.com/ .
[5]EmeryDBerger,CelesteHollenbeck,Petr Maj,OlgaVitek, andJanVitek.2019.
On the impact of programming languages on code quality: a reproduction study.
ACMTransactionsonProgrammingLanguagesandSystems(TOPLAS) 41,4(2019),
1Å›24.
[6]TegawendÃ© F BissyandÃ©, Ferdian Thung, David Lo, Lingxiao Jiang, and Lau-
rentRÃ©veillere.2013. Popularity,interoperability,andimpactofprogramming
languages in 100,000 open source projects. In 2013 IEEE 37th annual computer
softwareand applications conference . IEEE,303Å›312.
[7]Haipeng Cai and Barbara Ryder. 2017. DroidFax: A Toolkit for Systematic Char-
acterization of Android Applications. In International Conference on Software
Maintenance and Evolution(ICSME) . 643Å›647.
[8]CaseyCasalnuovo,YagnikSuchak,BaishakhiRay,andCindyRubio-GonzÃ¡lez.
2017. Gitcproc: A tool for processing and classifying github commits. In Proceed-
ingsofthe26thACMSIGSOFTInternationalSymposiumonSoftwareTestingand
Analysis. 396Å›399.
[9]AdamCohen.2011. FuzzyWuzzy:Fuzzystringmatchinginpython. ChairNerd
Blog22(2011).
[10]XiaoqinFuandHaipengCai.2019. ADynamicTaintAnalyzerforDistributed
Systems.In ACMJointEuropeanSoftwareEngineeringConferenceandSymposium
onthe FoundationsofSoftwareEngineering (ESEC/FSE) . 1115Å›1119.
[11]XiaoqinFu andHaipengCai.2021. FlowDist:Multi-StagedRefinement-Based
DynamicInformationFlowAnalysisforDistributedSoftwareSystems.In 30th
USENIXSecuritySymposium(USENIXSecurity) . 2093Å›2110.
[12]Xiaoqin Fu, HaipengCai,and Li Li. 2020. Dads:DynamicSlicingContinuously-
RunningDistributedProgramswithBudget Constraints.In ACMJointMeeting
on European Software Engineering Conference and Symposium on the Foundations
ofSoftwareEngineering (ESEC/FSE) . 1566Å›1570.
[13]XiaoqinFu,BoxiangLin,andHaipengCai.2022. DistFax:AToolkitforMeasuring
Interprocess Communications and Quality of Distributed Systems. In IEEE/ACM
InternationalConference onSoftwareEngineering (ICSE) . 51Å›55.
[14]GitHub.2020. The2020StateoftheOCTOÃÃVERSE. https://octoverse.github.
com/#project-spotlight-tensorflow . (2020).
[15] gRPC.2020. gRPC Tutorial. https://grpc.io/docs/ . (2020).
[16]EmmaHaddi,XiaohuiLiu,andYongShi.2013. Theroleoftextpre-processingin
sentiment analysis. ProcediaComputer Science 17(2013), 26Å›32.
[17]JohnJenkinsandHaipengCai.2018. ICC-inspect:Supportingruntimeinspection
of Android inter-component communications. In Proceedingsofthe 5th Interna-
tional Conference onMobileSoftwareEngineering and Systems . 80Å›83.
[18]Siim Karusand HaraldGall. 2011. A study of languageusage evolutionin open
sourcesoftware.In Proceedingsofthe8thWorkingConferenceonMiningSoftwareRepositories . 13Å›22.
[19]FrankLiandVernPaxson.2017. Alarge-scaleempiricalstudyofsecuritypatches.
InProceedingsofthe2017ACMSIGSACConferenceonComputerandCommunica-
tions Security . 2201Å›2215.
[20]Wen Li. 2022. PolyFax code repository. https://github.com/Daybreak2019/
PolyFax. (2022).
[21]Wen Li. 2022. PolyFax dataset. https://hub.docker.com/repository/docker/
daybreak2019/fse22_vpomc . (2022).
[22]WenLi,LiLi,andHaipengCai.2022. OntheVulnerabilityPronenessofMulti-
lingualCode.In ACMJointMeetingonEuropeanSoftwareEngineeringConference
and Symposiumonthe FoundationsofSoftwareEngineering (ESEC/FSE) .
[23]Wen Li, Na Meng, Li Li, and Haipeng Cai. 2021. Understanding language se-
lectioninmulti-languagesoftwareprojectsonGitHub.In 2021IEEE/ACM43rd
International Conference on Software Engineering: CompanionProceedings(ICSE-
Companion) . IEEE,256Å›257.
[24]Wen Li, Jiang Ming, Xiapu Luo, and Haipeng Cai. 2022. PolyCruise: A Cross-
Language Dynamic Information Flow Analysis. In 31st USENIX Security Sympo-
sium (USENIXSecurity22) . Boston, MA,2513Å›2530.
[25]Philip Mayer and Alexander Bauer. 2015. An empirical analysis of the utilization
of multiple programming languages in open source projects. In Proceedings
of the 19th International Conference on Evaluation and Assessment in Software
Engineering . 1Å›10.
[26] MITRE. 2020. Common Weakness Enumeration. http://cwe.mitre.org/ .
[27]Havoc Pennington. 2020. D-Bus Tutorial. https://dbus.freedesktop.org/doc/dbus-
tutorial.html . (2020).
[28]HenningPerl,SergejDechand,MatthewSmith,DanielArp,FabianYamaguchi,
Konrad Rieck, Sascha Fahl, and Yasemin Acar. 2015. Vccfinder: Finding potential
vulnerabilities in open-source projects to assist code audits. In Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications Security .
426Å›437.
[29]BaishakhiRay,DarylPosnett,VladimirFilkov,andPremkumarDevanbu.2014.
A large scale study of programming languages and code quality in github. In
Proceedingsofthe22ndACMSIGSOFTInternationalSymposiumonFoundationsof
SoftwareEngineering . 155Å›165.
[30]Alex VillazÃ³n, Haiyang Sun, Andrea RosÃ , Eduardo Rosales, Daniele Bonetta,
Isabella Defilippis, Sergio Oporto, and Walter Binder. 2019. NAB: automated
large-scalemulti-languagedynamicprogramanalysisinpubliccoderepositories.
InProceedings Companion of the 2019 ACM SIGPLAN International Conference
onSystems,Programming,Languages,andApplications:SoftwareforHumanity .
9Å›10.
[31]Haoran Yang, Wen Li, and Haipeng Cai. 2022. Language-Agnostic Dynamic
AnalysisofMultilingualCode:Promises,Pitfalls,andProspects.In ACMJoint
Meeting on European Software Engineering Conference and Symposium on the
FoundationsofSoftwareEngineering (ESEC/FSE) .
[32]Yunhui Zheng, Saurabh Pujar, Burn Lewis, Luca Buratti, Edward Epstein, Bo
Yang, Jim Laredo, Alessandro Morari, and Zhong Su. 2021. D2A: a dataset
built for AI-based vulnerability detection methods using differential analysis. In
2021IEEE/ACM43rdInternationalConferenceonSoftwareEngineering:Software
Engineering inPractice (ICSE-SEIP) . IEEE,111Å›120.
1666