Metamong : Detecting Render-UpdateBugsin Web Browsers
through Fuzzing
Suhwan Song
SeoulNational University
Seoul,SouthKorea
sshkeb96@snu.ac.krByoungyoung Lee‚àó
SeoulNational University
Seoul,SouthKorea
byoungyoung@snu.ac.kr
ABSTRACT
A render-update bug arises when a web browser produces an erro-
neousrenderingoutputduetoincorrectrenderingupdates.Such
render-updatebugsseriouslyharmthe usabilityandreliabilityof
webbrowsers.However,we/f_indthatdetecting render-updatebugs
ischallengingbecausetherender-updatebugisasemanticbug‚Äî
given arenderingresult,it isdiÔ¨Éculttodetermineifitiscorrect
due to the complex rendering speci/f_ication of DOM and CSS. Thus,
unlike memory corruption bugs, the incorrect rendering output
doesnotraisetheviolationorcrash.Inpractice,render-updatebug
detection relies on the time-prohibitive manual analysis of domain
expertsto determinethe bug.
This paper proposes Metamong , an automated framework to
detect render-update bugs without false positive issues via dif-
ferential fuzz testing. Metamong features two key components:
(i)pagemutator,and(ii)render-updateoracle.Thepagemutator
generates render-update operations,which change the content of
thewebpage,totriggerarender-updatebug.Therender-update
oracleexploitsanHTMLstandardrule,so-calledyielding,topro-
ducethecorrectrendering resultofagivenwebpage.Combining
thesecomponents, Metamong createstwoHTML/f_ileswhereeach
constructs the same web page, but only one of them induces the
render-update. It then uses diÔ¨Äerential testing to compare their
renderingoutputstodetermineabug.Weimplementedaprototype
ofMetamong , which performs diÔ¨Äerential fuzz testing on popular
browsers,ChromeandFirefox.Byfar, Metamong identi/f_ied19new
render-update bugs, 17 in Chrome and two in Firefox. All of those
have been con/f_irmed by each browser vendor and /f_ive are already
/f_ixed, demonstrating the practical eÔ¨Äectiveness of Metamong in
identifying render-updatebugs.
CCS CONCEPTS
‚Ä¢Softwareanditsengineering ‚ÜíSoftwaretestinganddebugging .
KEYWORDS
rendering update,web-browser,fuzz testing
‚àóCorresponding author
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forpro/f_itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe/f_irstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeci/f_icpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ‚Äô23, December 3‚Äì9, 2023, San Francisco, CA,USA
¬©2023 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 979-8-4007-0327-0/23/12...$15.00
https://doi.org/10.1145/3611643.3616336ACMReference Format:
Suhwan Song and Byoungyoung Lee. 2023. Metamong : Detecting Render-
UpdateBugsinWebBrowsersthroughFuzzing.In Proceedingsofthe31st
ACMJointEuropeanSoftwareEngineeringConferenceandSymposiumonthe
FoundationsofSoftwareEngineering(ESEC/FSE‚Äô23),December3‚Äì9,2023,San
Francisco, CA, USA. ACM, New York, NY, USA, 13pages.https://doi.org/10.
1145/3611643.3616336
1 INTRODUCTION
Therenderingperformancehasbeenthekeyrequirementforthe
webbrowsers.Traditionalbrowserswereveryslowbecausetheyre-
runtheentirerenderingprocessforeverywebpageupdate.Unlike
traditional browsers, in order to speed up the browser‚Äôs rendering
process, modern browsers employ a new technique, render-update ,
which re-renders only the updated part of the web page [ 16,17].
This technique reuses previous rendering results and re-renders
only the region that needs to be updated for eÔ¨Éciency. It is very
suitableandusefulformostofmodernwebapplicationsbecause
they frequently updatetheir webpage.
Theproblemisthistechniqueintroducesabugwherethebrowser
doesnotre-rendertheareasofthewebpagethatshouldbeupdated,
generatinganincorrectrenderingoutput.Wewillcallsuch abuga
render-update bug inthispaper. A render-update bug is abug that
occurswhenawebbrowsergeneratesanincorrectrenderingoutput
duetoanincorrectrender-updateofthebrowser.Render-update
bugscanseverelyharmtheusabilityandreliabilityofthewebpage
anditsservice.Inparticular,thisbugisveryfataltomodernweb
applications because it arises from render-update , and modern web
applicationsfrequentlyinvoke render-update toupdatetheirweb
pages. As an example, a major electric car company, Tesla, had a
service interruption because of a render-update bug where Chrome
87doesnotproperlychangethecolorofthecar,disturbingusers
from its service [ 19].
Therearetwokeychallengesto/f_ind render-update bugs.First,
it is challenging to generate javascript triggering render-update
bugs. This is because the render-update bugs can be triggered only
when the browser performs the incorrect render-update . Second,
itischallengingtoautomaticallydetect render-update bugswith-
out false positives. To be speci/f_ic, there is no oracle that can de-
termine whether the visual appearance of the web page violates
HTML/CSS speci/f_ications [ 4,10]. This is because it is diÔ¨Écult to
translate complex HTML/CSS speci/f_ications into programmable
expressions, which allow automated validation. Moreover, as some
ofthefeaturesforrenderinginspeci/f_icationsareunder-speci/f_ied,
the complete speci/f_ication translation is infeasible. To solve this
issue,previousworksleverageddiÔ¨Äerentialtestingandproposed
two testing methods: cross-browser testing, and cross-version test-
ing[29,30,43,49].Itispossibletoadaptthesemethodstodetect
1075
ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Suhwan Song andByoungyoungLee
render-update bugs, but they have a critical limitation, a false posi-
tive issue.This is because the rendering outputs can be benignly
diÔ¨Äerentduetotheunder-speci/f_iedfeatures(e.g.,tablewidthdis-
tribution[ 18])orthenewfeatureimplementation(e.g.,CSShas()
selector [ 1]).
In thispaper,we propose Metamong , aframeworktailored for
detecting render-update bugs inmodern browsers without the false
positiveissue.Inordertoaddresstheaforementionedchallenges,we
design two key components: 1) page mutator, and 2) render-update
oracle. The page mutator is used to trigger render-update bugs. As
therender-update bugcanbetriggeredonlywhenthebrowserruns
therender-update ,thepagemutatoronlygenerates render-update
operations, which change the content of a web page such as DOM
tree and CSS styles. By executing the render-update operations,
Metamong makes the browser run render-update and enhances
the chance of triggering render-update bugs. The render-update
oraclecanidentifythe render-update bugswithoutthefalsepositive
issues. The key insight of render-update oracle is each web page
hasexactlyonerenderingoutputregardlessofwhetheritiscreated
bythe wholeorpartial rendering (i.e., render-update ). To leverage
thiskeyinsight,weexploitanHTMLstandardrule,yielding[ 10].
By exploiting yielding, Metamong can change the web page while
preventingthebrowserfromrunning render-update .Byusingthese
components, Metamong creates two HTML /f_iles that both build
anidenticalwebpage,butonlyoneofthemcausesa render-update .
Metamong then uses diÔ¨Äerential testing to verify whether their
renderingoutputsarethesame.Finally, Metamong determinesa
render-update bugif theirrendering outputs are diÔ¨Äerent.
Weimplementedtheprototypeof Metamong andconductedthe
evaluationontwopopularbrowsers,ChromeandFirefox.During
theevaluation, Metamong wasabletodetectall28previous render-
updatebugs that were reported within two years at Chrome and
Firefox bug trackers (all 15 Chrome and all 13 Firefox bugs). More
importantly, Metamong has found 21 render-update bugs (17 in
Chrome and four in Firefox). All of the bugs were con/f_irmed by
the respective browser vendors, 19 of them were new bugs, and
/f_ive of them were /f_ixed, revealing Metamong ‚Äôs practical capability
to detect render-update bugswithoutfalse positives.
Tosummarize,this paper makesthe following contributions:
‚Ä¢Design.Wedesigned Metamong ,aframeworktoautomatically
detect browser render-update bugs without false positives. It
features two components for render-update bugs: (i) a render-
updateoracletodetect render-update bugsand(ii)apagemutator
to trigger render-update bugs.
‚Ä¢PromisingResults. Whileperformingtheevaluation, Metamong
candetectallof28previous render-update bugsobtainedfrom
Chrome and Firefox bug trackers. Importantly, it found 19 new
render-update bugs in Chrome and Firefox. All of these were
con/f_irmed by the respective developers and /f_ive have already
been /f_ixed. These results suggest the strong practical aspects of
Metamong for detecting render-update bugsinbrowsers.
2 BACKGROUND
2.1 Fuzzing andDiÔ¨Äerential Testing
Fuzzing. Fuzzingisapopularbug-/f_indingmethod.Itcontinually
executes atargetprogramwiththe randomlygenerated testcasesto see if the target program‚Äôs behavior is incorrect (e.g., crashing).
Sincefuzzingdoesnotrequiredomainexpertknowledgeofatarget
program, it is widely used in many software applications to detect
bugs.Mostfuzzersaredevelopedtohuntformemorycorruption
bugs[2,3,5,7,8,21‚Äì23,25,26,36,42,50,52,53].Thisisbecausethe
bugcannotbediscoveredbyafuzzeronitsown;rather,aparticular
bug condition must be observed during fuzzing. Because of this,
most fuzzing approaches have been presented to uncover memory
corruptionvulnerabilities, whichare operatedwithmemoryerror
detectors that clearly de/f_ine bug situations (or conditions) (e.g.,
ASAN[48]andUBSAN [ 20]).
DiÔ¨ÄerentialTesting. DuetothediÔ¨Écultyofexpressingsemantic
bugs as a bug condition and the requirement for domain expert
knowledge to identify them, fuzz testing alone is ineÔ¨Äective for
detecting semantic bugs. In this sense, diÔ¨Äerential testing methods
are widely used for detecting semantic bugs. More speci/f_ically,
diÔ¨Äerentialtestingemploysanumberofprograms,eachofwhich
is meant to get the same result for the same input. If the results
are diÔ¨Äerent for each program, we can determine that the program
might include a semanticbug. AsdiÔ¨Äerentialtesting describesthe
bugconditionofthesemanticbugs,recentresearchhaveemployed
diÔ¨Äerentialtestingwithfuzzingtouncovermanytypesofsemantic
bugs.Forinstance,itisusedtodiscoversemanticbugsinCPURTLs,
SSL/TLSimplementations,webbrowsers,debuggers,compilers,and
Java virtual machines (JVM)[ 24,27‚Äì30,33‚Äì35,39,43,47,49,54].
2.2 The Rendering ofaWeb Browser
Rendering is turning the content (e.g., HTML, CSS, and javascript)
intothepixels(i.e.,screenoutput)[ 11].Torenderthecontent,mod-
ernbrowserssuchasChromeandFirefoxbuild thedatastructure
called a page. The page is the browser-speci/f_ic memory object rep-
resenting the HTML document. Each page consists of HTML, CSS,
andjavascriptandhasitsownrenderingoutputaccordingtoDOM
and CSS speci/f_ications [ 4,10]. We will call the rendering output
asrenderin this paper. The page can be modi/f_ied by various ac-
tions such as javascript and mouse clicks, and its rendering output
alsochangesaccordingtotheupdatedpage.Traditionalbrowsers
re-dothewholerenderingprocesswheneverawebpageismodi-
/f_ied (or updated). However, they have a critical limitation re-doing
the whole rendering process is very heavy and increases the la-
tency. This limitation seriously degrades the performance of the
browsers and it also impacts most (modern) web applications as
they frequently updatetheir page.
To address this limitation, modern browsers build the rendering
process into two phases: 1) render-initial, and 2) render-update
[16,17].Render-initialisthe/f_irstrenderingphasethatabrowser
loads(orparses)anHTML/f_ile,buildsapagewithit,anddrawsthe
page‚Äôscorresponding output.Tobe speci/f_ic, the render-initialis
/u1D45D/u1D456/u1D45B/u1D456/u1D461‚Üê/u1D435/u1D462/u1D456/u1D459/u1D451/u1D443/u1D44E/u1D454/u1D452(/uni210E)
/u1D45F/u1D456/u1D45B/u1D456/u1D461‚Üê/u1D43C/u1D45B/u1D456/u1D461/u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F(/u1D45D/u1D456/u1D45B/u1D456/u1D461)(1)
where(i)/u1D435/u1D462/u1D456/u1D459/u1D451/u1D443/u1D44E/u1D454/u1D452 buildstheinitial-page /u1D45D/u1D456/u1D45B/u1D456/u1D461basedontheHTML
/f_ile/uni210E, and (ii) /u1D43C/u1D45B/u1D456/u1D461/u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F draws the initial-render /u1D45F/u1D456/u1D45B/u1D456/u1D461based on
theinitial-page /u1D45D/u1D456/u1D45B/u1D456/u1D461.Notethatthe render-update isnottriggered
inthis phase.
1076Metamong : DetectingRender-Update Bugs in WebBrowsers through Fuzzing ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
<style> 
.a{ background : plum; } 
.b{ background : aqua;} 
</style>
<body >
<p class ="a">Example</ p>
</body >
HTML (‚Ñé)body
p
Example background: plum
Initial-page (ùëù!"!#)class: ‚Äúa‚Äù‚ë†
Initial-render (ùëü!"!#)‚ë°Phase 1
Render-initial
body
p
Example background: aqua
Updated-page (ùëù$%&'#()class: ‚Äúb‚Äù
Updated-render (ùëü$%&'#()Phase 2
Render-update
JS (ùëó)letn = document .querySelector( ‚Äúp‚Äù); 
n.setAttribute( "class" , "b");‚ë¢‚ë£ ‚ë§
Figure 1:The example ofthebrowser rendering process.
Render-updateisthesecondrenderingphasethatthebrowser
re-rendersonlythechangedareasofthepagewheneverthepageis
updated. This approach reuses previous rendering results and only
re-renders the changed parts of the page to eÔ¨Éciently generate the
page‚Äôscorresponding output.Tobe speci/f_ic, the render-update is
/u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452‚Üê/u1D443/u1D44E/u1D454/u1D452/u1D448/u1D45D/u1D451/u1D44E/u1D461/u1D452(/u1D45D/u1D456/u1D45B/u1D456/u1D461, /u1D457)
/u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452‚Üê/u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F/u1D448/u1D45D/u1D451/u1D44E/u1D461/u1D452(/u1D45F/u1D456/u1D45B/u1D456/u1D461,/u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452)(2)
where (i) /u1D443/u1D44E/u1D454/u1D452/u1D448/u1D45D/u1D451/u1D44E/u1D461/u1D452 executes the javascript /u1D457and updates the
initial-page /u1D45D/u1D456/u1D45B/u1D456/u1D461totheupdated-page /u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452,and(ii)/u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F/u1D448/u1D45D/u1D451/u1D44E/u1D461/u1D452
updatestheinitial-render /u1D45F/u1D456/u1D45B/u1D456/u1D461totheupdated-render /u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452which
isthecorrespondingrenderingoutputof /u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452.Asrender-update
does not render the entire area yet only re-renders the part of
the area which should be updated, the browser can signi/f_icantly
decrease the performance overhead of the rendering with it. Be-
sides,the render-update canbealsoperformedontheupdated-page
/u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452toeÔ¨Écientlygeneratetherenderingoutputwhenthepage
isupdatedagainthroughthe javascript.
Anexampleofthebrowserrenderingprocessisshownin Fig-
ure 1. In phase 1, the browser loads the HTML /f_ile /uni210Eand builds
theinitial-page /u1D45D/u1D456/u1D45B/u1D456/u1D4611.Itproducestheinitial-render /u1D45F/u1D456/u1D45B/u1D456/u1D461based
ontheinitial-page /u1D45D/u1D456/u1D45B/u1D456/u1D4612.Then,whenthejavascriptcodeisex-
ecuted,thebrowserconductsthesecondrenderingphase.Inthis
example,thejavascriptcodechangesthe classattributeof<p>ele-
mentnodefrom‚Äúa‚Äùto‚Äúb‚Äù 3.Asthevalueofthe classattributeis
changedto‚Äúb‚Äù,thebackgroundcolorofthe <p>nodechangesfrom
"plum" to "aqua" and the initial-page becomes the updated-page
/u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D4524.Finally,thebrowserperforms render-update basedon
theupdated-page /u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452andtheinitial-render /u1D45F/u1D456/u1D45B/u1D456/u1D461togenerate
theupdated-render /u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452.Asonlythebackgroundcolorofthe
<p>node is changed, the browser re-renders only the area of <p>
node (i.e.,plum rectangle) tochangeto theaquacolor andit does
not re-renderthe restofthe area 5 .
2.3 Render-Update Bug
The browser developers try to optimize the render-update by max-
imizing the reuse of previous rendering results and minimizing
the areas to be re-rendered as possible. However, while making
render-update eÔ¨Écient,thebrowserdeveloperscanintroduceabug
that the browser incompletely re-renders the areas of the page
that should be updated. We will call such a bug a render-update
bug. Arender-update bug isa bug where the browserincorrectly
performs render-update on an updated page and generates an in-
correct rendering outputof the page, diÔ¨Äerent from the DOM and1<!DOCTYPE html>
2<script>
3functionupdate_page() { box.innerHTML ="Important text" ; }
4</script>
5<style> #box{transform:rotateY(0deg);height:30px; } </style>
6<body> Example of render-update bug < divid="box"></div></body>
(a)PoC HTMLcode
Execute update_page()
(b) Actual Result(Incorrect).
Execute update_page()
(c) ExpectedResult(Correct).
Figure 2: A render-update bug example (Chrome Issue
#1167352).
(a)Actual Result(Incorrect).
 (b) ExpectedResult(Correct).
Figure 3: A render-update bug (Chrome Issue # 1132218) trig-
gered on Tesla‚Äôs homepage . The car color does not change to
whiteeven after theuserclicks the white-color button.
CSSspeci/f_ications. Itisworthnotingthatthe render-update bug
and the rendering bug have diÔ¨Äerent root-causes although both
generate the incorrect rendering outputs which violate DOM/CSS
speci/f_ications. Render-update bugs can harm users and web ap-
plication developers in many ways. For instance, if the browser
has arender-update bug and it is triggered on the web application,
importantelementsthatshouldbedisplayedmaybecomedistorted
orinvisible,severelyharmingtheservicequality.Furthermore,if
elements are placed at awkward locations, users may not under-
standthecontentsormaybemisguided. Inaddition,render-update
bugs introduce unnecessary challengesto the web application de-
velopers.Supposethedeveloperfoundacertainbugintheirweb
application. Then the developer starts to manually debug the issue,
butsuchadebuggingprocessistypicallyperformedundertheas-
sumption thatthe underlying browser hasno bugs. If thisbug is a
render-updatebug,thedeveloperwillneedtospendquiteatimeto
/f_inally notice itis a browser‚Äôs issue or oftenfail to triage thebug.
We explain the exampleof a render-update bug withthe HTML
code shown in Figure 2. In this example, the Chrome browser /f_irst
opens the HTML code and generates its rendering output (i.e.,
initial-render).Itthenexecutes update_page() atline 3tomodify
thepagebysettingthetextof<div>elementwith Important text .
Afterward, the Chrome browser performs render-update on the up-
datedpageandgeneratesitsrenderingoutput(i.e.,updated-render).
If the Chrome browser works correctly, the text Important text
(highlighted with the red box) should be drawn below the text
1077ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Suhwan Song andByoungyoungLee
1<!DOCTYPE html>
2<style>body{font-size:30px;} </style>
3<script>
4functionupdate_page() {
5document.styleSheets[0].insertRule("ul:has(li) {background: plum;}" )
6}
7</script>
8<body><ul><li>Hello World</li></ul></body>
(a)PoC HTMLcode
update_page()
(b)ActualResultofChrome104
(Correct)update_page()
(c)ActualResultofChrome105
(Correct)
Figure 4:Afalsepositive example ofcross-versiontesting.
Example ofrender-update bug as shown in Figure 2c . However,
the Chrome browser incorrectly performs render-update ‚Äìit does
notre-renderthehighlightedareabecauseitdeterminesthatthe
highlighted area (which should be re-rendered) does not need to
be re-rendered. As a result, the Chrome browser does not draw the
textImportant text and produces the incorrect rendering result
as shownin Figure 2b .
Therender-update bug can severely harm the usability and relia-
bility of the page and its service if such a page is for commercial
services.Weexplainsuch acasewithareal-worldexamplewhere
therender-update bugwastriggeredonTesla‚Äôshomepageasshown
inFigure 3. Initially,the black buttonon the homepage was se-
lected, so the color of the car was black as well. Then the user can
select the color to change the car color. When the user selects the
white color, the browser should change the car color from black to
white. However, the problem was that eventhoughthe user selects
thewhitecolor(orothercolors),thecolordoesnotchangetowhite
andremainsblackdueto a render-update bug.
3 CHALLENGE AND APPROACH
3.1 Challenge
We elaborate on two challenges in triggering and detecting the
render-update bugs.
Challenge #1: Triggering Render-Update Bugs. It ischalleng-
ingto generate javascriptthattriggers render-update bugs. This is
because the render-update bugs can be triggered only when the
browser performs the render-update . If the javascript does not
change the page, the browser never performs render-update , which
is the origin of render-update bugs. To trigger the render-update
bugs,thejavascriptneedstochangethepageandmakethebrowser
perform the render-update . Thus,toincreasethe chancetotrigger
render-update bugs, the generated javascript should induce the
complex page andrenderchangefrom the browser.
Challenge#2:DetectingRender-UpdateBugswithoutFalse
Positives. Inordertodetect render-update bugs,thereshouldbean
oraclethatcantellthecorrectnessofthe render-update .However,
itisverychallenging tobuildsuch a render-update oraclebecausetherender-update bugisasemanticbug.Tobemorespeci/f_ic,the
render-update bug is triggered due to the semantically incorrect
behavior of render-update . It entails incorrect rendering outputs,
which violate DOM and CSS speci/f_ications [ 4,6]. However, it is
diÔ¨Écult to automatically validate their semantic correctness, be-
cause, unlike the memory corruption bug, the incorrect rendering
output does not trigger the violation or crash. This means that it is
impossibletodetectwhetherthebrowserviolatesDOMandCSS
speci/f_ications. Hence, detecting render-update bugs relies on the
manual analysis of domain experts or the bug reports from the
usersandwebapplicationdevelopers.
To resolve this issue, several studies leverage diÔ¨Äerential testing
that compares the result of two diÔ¨Äerent browsers for detecting
rendering bugs. To be speci/f_ic, the research area has proposed
two testing methods by using diÔ¨Äerential testing: (i) cross-browser
testing[29‚Äì31,43]and(ii)cross-versiontesting[ 49].Bothmethods
can be used to /f_ind the render-update bugs, but they have a critical
limitation‚ÄìtheysuÔ¨Äerfromthefalsepositiveissueon/f_inding render-
updatebugs.
Cross-browser testing can be used to detect the render-update
bugsbycomparingtheresultoftwoindependently-implemented
browsers(e.g.,ChromeandFirefox).Itdeterminesthereisa render-
updatebug when two browsers generate diÔ¨Äerent results from
thesameinput consistingofHTML/CSSwithjavascript(whichis
usedtotrigger render-update ).Thismethodcanbeeasilyemployed
to detect render-update bugs because it does not require domain
knowledge.However,R2Z2[ 49]hasshownthattheresultoftwo
independently-implementedbrowserscanbediÔ¨Äerentduetothe
benign browser incompatibilities (e.g., diÔ¨Äerent feature support) so
the cross-browsertestingalone can trigger manyfalse positives.
The cross-version testing compares the result of two diÔ¨Äerent
versions of the same browser (e.g., Chrome version 104 and 105)
to detect the render-update bugs. It determines there is a render-
updatebug when two browsers generate diÔ¨Äerent results from
the same input consisting of HTML/CSS with javascript. Unlike
cross-browser testing, it does not suÔ¨Äer from benign incompati-
bilitiessuchasdiÔ¨ÄerentsupportedfeaturesanddiÔ¨Äerentdesigns.
This is because such incompatibilities are introduced when two
browsers are independently-implemented. However, this approach
still suÔ¨Äers from the false positive issue‚Äìthe result of two diÔ¨Äerent
versionsofthesamebrowsercanbebenignlydiÔ¨Äerentduetothe
feature update or the bug /f_ix.In other words, it isstill challenging
to determinewhichone iscorrectwhen tworesults are diÔ¨Äerent.
Weexplainanexampleofafalsepositivecasethatcanbecaused
bythefeatureupdate(i.e.,CSSpseudo-class :has())asshownin Fig-
ure4.CSSpseudo-class :has()isnotsupportedbeforeChrome105
anditis/f_irstintroducedinChrome105.Inthisexample,Chrome
104and105producethesamerenderingoutputswhenopeningPoC
HTML code. After they execute update_page() to insert the CSS
rule, their rendering outputs become diÔ¨Äerent where only Chrome
105paintstheplumbackgroundon the<li>node.Thisisbecause
:has()is not supported by Chrome 104 so Chrome 104 ignores
theinsertedCSSrule.Theproblemhereisthateventhoughboth
browsers produce the correct rendering outputs, the cross-version
testingapproachdeterminesthiscaseas render-update bug,leading
to afalse positive.
1078Metamong : DetectingRender-Update Bugs in WebBrowsers through Fuzzing ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
<style> 
#before { background : plum; } 
#after { background : aqua;} 
</style> 
<body >
<p id=‚Äúbefore ‚Äú>Example</ p>
</body > 
Test HTML ( ‚Ñé!"#!)body
p
Example background: plum
Initial-page (ùëù!"#!$%$!)id: ‚Äúbefore‚Äù
Initial-render (ùëü!"#!$%$!)
body
p
Example background: aqua
Updated-Page (ùëù!"#!&'()*!")id: ‚Äúafter‚Äù
Updated-Render (ùëü!"#!&'()*!")
<style> 
#before { background : plum; } 
#after { background : aqua;} 
</style> 
<body >
<p id=‚Äúbefore ">Example</ p>
</body > 
<script> before.setAttribute( ‚Äòid‚Äô, ‚Äòafter‚Äô ); </script >
Reference HTML ( ‚Ñé+",)‚ë†
Render 
Checkerbefore.setAttribute( ‚Äòid‚Äô, ‚Äòafter‚Äô );‚ë¢‚ë£
body
p
Example background: aqua
Reference Page ( ùëù+",$%$!)id: ‚Äúafter‚Äù
Reference Render ( ùëü+",$%$!)IntegratorHTML
Generator
Page Mutator 
($4.2)‚ë°
‚ë§‚ë•‚ë¶
Bug Report‚ëß
Render-update Oracle ($4.3)Bug Triggering Phase Bug Detection Phase
 JS(j)
Figure 5:The overallwork/f_low of Metamong .
Summary: Both cross-browser and cross-version testings
triggermanyfalsepositives. This isaverycriticalproblem
because the browser developers should spend their time and
eÔ¨Äortonthe bugs,whichactually donot exist.
3.2 OurApproach
Approach #1: Generating Render-Update Operations Only.
Toaddresschallenge#1,webuildthepagemutator,whichgenerates
render-update operationstochangethepageandtriggerthe render-
update.Wedothisbasedonthefactthatthe render-update isthe
origin of the render-update bugs and the browser performs render-
updatewhen itchanges the page and has to re-render the page.In
this respect, the page mutator generates the mutation primitives
changing the DOM tree or the CSS style of the page. By executing
such mutation primitives, Metamong can /f_ind more render-update
bugsbecausethebrowserdrawsthepagebasedonitsDOMtree
and CSS style and performs render-update whenever the DOM tree
andCSSstyle are changed.We willdescribe the detailofthe page
mutatorat ¬ß4.2.
Approach #2: Exploiting an HTML Standard Rule to Build
Render-Update Oracle. To address challenge #2, we build the
render-update bugoraclewhichcanidentifythe render-update bugs
withoutthefalsepositiveissues.Thekeyassumptiontobuildthe
render-update oracle is that an initial-render can be used as a refer-
ence(oranswer)renderfromtheperspectiveofthe render-update
bug. We can use this assumption because when the browser gener-
atestheinitial-render,itdoesnotperform render-update whichis
the rootcause of render-update bugs. To leverage this key assump-
tion, we exploit one of the HTML standard rules called yielding.
Yielding is when the browser encounters the javascript while pars-
inganHTML/f_ile,it/f_irstblockstheparsing,executesthejavascript,
andthenresumesparsingtheHTML/f_iletobuildthepage.Byex-
ploiting yielding, we can make the browser build the page that
weaimforwithoutperformingthe render-update .Inotherwords,
the browser only performs the render-initial on the page so that
wecangetthereferencerenderoftheaimedpage.Tobespeci/f_ic,
Metamong generatestwoHTML/f_ileswheretheybuildthesame
page but one triggers the render-update and the other does not.Metamong then leverages diÔ¨Äerential testing to check whether
their rendering outputsare the same. Ifthey generate diÔ¨Äerent ren-
deringoutputs,the render-update bugoracledeterminesthiscaseas
arender-update bug.Wewilldescribethedetailofthe render-update
oracle at¬ß4.3.
4 DESIGN
Wedesign Metamong ,aframeworkfor/f_inding render-update bugs
inthemodernbrowsersthroughdiÔ¨Äerentialfuzztestingwithout
the false positive issue. First, we introduce the overall design of
Metamong (¬ß4.1). Then, we introduce the page mutator, which
generatesthemutationprimitivesinjavascripttotriggerthe render-
updatebug(¬ß4.2).Metamong usestheHTML/f_ileandthemutation
primitives to build the test page and get its rendering result, which
is used to determine the render-update bug later in ¬ß4.3. Lastly,
we present the render-update oracle that can detect the render-
updatebugs without the false positive ( ¬ß4.3). Therender-update
oracle consists of two components: 1) integrator, and 2) render
checker.Theintegratorexploitsyielding,whichistheoneofthe
HTMLstandardrules.ItmergestheHTML/f_ileandthemutation
primitives to construct the reference HTML /f_ile, which is used
to get the reference rendering result of the test page. The render
checkercomparestherenderingresultoftestpageanditsreference
rendering result to determine whether the browser triggers the
render-update bug. If they are diÔ¨Äerent, Metamong considers it
as arender-update bug. It is worth noting that the render-update
oracle can be easily adopted to the other DOM fuzzer to detect the
render-update bugs.
4.1 Overview
Theoveralldesignandwork/f_lowof Metamong areshownin Fig-
ure5.Metamong consistsoftwophases:1)bugtriggeringphase,
and2)bugdetectionphase.Inthebugtriggeringphase, Metamong
/f_irstgeneratesandopensanHTML/f_ile(i.e., /uni210E/u1D461/u1D452/u1D460/u1D461)onthebrowserto
buildtheinitial-page(i.e., /u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461)andproduceitscorrespondingren-
dering output (i.e., initial-render) denoted as /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D4611. In this exam-
ple,theinitial-page /u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461hasa<body>nodeasarootanda <p>node
asachild.The<p>nodehastheidattributeanditsvalueis ‚Äúbefore‚Äù
sothestyleofthenode <p>iscalculatedasbackground: plum .The
1079ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Suhwan Song andByoungyoungLee
after beforebody
button
Example color: seagreen;id: ‚Äúa‚Äùbody
button
Example color: seagreen;id: ‚Äúa‚ÄùfieldsetAppend <field>
Render 
Update
a.insertAdjacentHTML( 'afterend ', ‚Äò<fieldset ></fieldset >'); JS
(a)DOMNodeInsertion.after beforebody
button
Example color: seagreen;id: ‚Äúa‚Äùbody
button
Example color: seagreen;id: ‚Äúa‚ÄùAdd attribute ‚Äúhidden‚Äù
Render 
Updatehidden:
hidden
a. setAttribute( ‚Äòhidden ‚Äô, ‚Äòhidden‚Äô ); JS
(b) DOMNodeAttribute Insertion.after beforebody
butto n
Example color: seagreen;id: ‚Äúa‚Äùbody
button
Example color: seagreen;id: ‚Äúa‚ÄùFocus <button>
Render 
Update
a. focus()JS
(c) DOMNodeFocus.
Figure 6:The examples ofDOM mutation primitive.
browserdrawsthe /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461wherethetext‚ÄúExample‚Äù isdrawninside
of the plum rectangle. Then, it uses the mutation API generator to
make the mutation primitives, which can trigger the render-update
2.Metamong executes the mutation primitives on the page /u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461
to trigger the render-update bug3. After that, the browser up-
dates/u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461to the updated-page (i.e., /u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤) and performs the
render-update toupdate /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461totheupdated-render(i.e., /u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤)
4.Inthisexample, /u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461becomes /u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤‚Äìtheidattributevalue
of the<p>node changes to ‚Äúafter‚Äùand its style also changes to
background: aqua . At the same time, the browser performs the
render-update and generates /u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤where the text‚ÄúExample‚Äù is
stilldrawn within the plum background.
In the bug detection phase, the render-update oracle uses the
integrator to combine the HTML /f_ile /uni210E/u1D461/u1D452/u1D460/u1D461with the mutation prim-
itives to generate the reference HTML /f_ile (i.e., /uni210E/u1D45F/u1D452/u1D453)5. Then,
therender-update oracleopens /uni210E/u1D45F/u1D452/u1D453onthebrowsertogetitsref-
erence render (i.e., /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453), which is the correct rendering output
of/u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤6.Inthisexample,beforethebrowserreachestothe
<script> tag, the page has the <body>node as a root and the <p>
nodeasachildwiththe idattribute‚Äúbefore‚Äù.Whenthebrowser
reaches to the<script> tag, the browser executes the mutation
primitivetarget.setAttibute(‚Äôid‚Äô, ‚Äôafter‚Äô) . Itchangestheid
attribute value from ‚Äúbefore‚Äù to‚Äúafter‚Äùso the style of the <p>
node is calculated as background: aqua . The browser then con-
ducts the render-initial to draw the /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453where the text‚ÄúExample‚Äù
isdrawninsideoftheaquarectangle.Finally,itleveragestherender
checker to determine the render-update bug by comparing two ren-
deringoutputs, /u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤and/u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D4537.If/u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤isnotsameas /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453,
Metamong determines this case as the render-update bug8. In
thisexample,thetext ‚ÄúExample‚Äù shouldbedrawninsideoftheaqua
rectangle(i.e., /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453)butthebrowserfailstoupdatethebackground
colortoaqua.Inthisrespect,wecandeterminethatthebrowser
triggers the render-update bug.
4.2 Page Mutator
It is important that the render-update bug can be triggered only
whenthebrowserperformsthe render-update onthepage.Tomake
thebrowserperformthe render-update ,thepageshouldbeupdated
(or modi/f_ied) via javascript. To be speci/f_ic, the work/f_low of pagebody
button
Examplecolor: seagreen;
background: plum;id: ‚Äúa‚Äùbody
button
Examplecolor: seagreen;id: ‚Äúa‚Äù
after beforeRender 
UpdateAppend CSS rule 
‚Äúbackground: plum‚Äù
document .styleSheets [0].insertRule ('#a {background: plum;}' ,1) JS
Figure 7:Anexample ofCSS mutation primitive.
mutatoris
/u1D457‚Üê/u1D43A/u1D452/u1D45B/u1D452/u1D45F/u1D44E/u1D461/u1D452/u1D440/u1D462/u1D461/u1D44E/u1D461/u1D456/u1D45C/u1D45B ()
/u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤‚Üê/u1D443/u1D44E/u1D454/u1D452/u1D448/u1D45D/u1D451/u1D44E/u1D461/u1D452(/u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461, /u1D457)
/u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤‚Üê/u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F/u1D448/u1D45D/u1D451/u1D44E/u1D461/u1D452(/u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461,/u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤)(3)
where(i)/u1D43A/u1D452/u1D45B/u1D452/u1D45F/u1D44E/u1D461/u1D452/u1D440/u1D462/u1D461/u1D44E/u1D461/u1D456/u1D45C/u1D45B randomlygeneratesthemutationprim-
itives/u1D457,(ii)/u1D443/u1D44E/u1D454/u1D452/u1D448/u1D45D/u1D451/u1D44E/u1D461/u1D452 mutatestheinitial-page /u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461totheupdated-
page/u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤by executing the mutation primitives /u1D457(in javascript)
and (iii)/u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F/u1D448/u1D45D/u1D451/u1D44E/u1D461/u1D452 updates the rendering output /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D461/u1D452/u1D460/u1D461to the
/u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤,which isthe corresponding renderingoutput of /u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤.
AsthebrowserdrawsthepagebasedonitsDOMtreeandCSSstyle,
we employ two page-mutation methods: 1) DOM tree mutation;
and2)CSSstyle mutation.
DOMMutationPrimitive. Metamong currentlyhasthreeDOM
mutation operations: (1) DOM node insertion/deletion; (2) DOM
nodeattributeinsertion/deletion;(3)DOMevent;ForDOMnode
insertion, Metamong randomly selects where to insert and then
generates the DOM node. Then, it uses insertAdjacentElement
(position, element) DOMAPItoinsertthenodeintheselected
position.Similarly,forDOMnodedeletion, Metamong randomly
selectsanddeletestheoneoftheDOMnodesvia remove() DOM
API. The example of DOM node insertion is described in Figure 6a.
Before mutation, the page has the <body>node as a root and the
child node (i.e., the <button> node). The<button> node has theid
attribute with its value ‚Äúa‚Äù, the text nodeExample, and the CSS
stylecolor: seagreen .Here,Metamong selectsthe<body>node,
generates the<fieldset> node, and inserts it inside the <body>
nodeafteritslastchild node(i.e., <button> node).After mutation,
thebrowser performs render-update todraw the<fieldset> node
belowthe textExample.
1080Metamong : DetectingRender-Update Bugs in WebBrowsers through Fuzzing ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
For DOM node attribute insertion, Metamong randomly se-
lects the one of DOM nodes and inserts the attribute with the
value viasetAttribute(name, value) . Similarly, for DOM node
attribute deletion, Metamong randomly selects the one of DOM
nodes and deletes the one of selected node‚Äôs attribute names via
removeAttribute(name) . The example of DOM node attribute in-
sertionisdescribedin Figure6b .Metamong selectsthe<button>
nodeandinsertsthe hiddenattributewiththevalue ‚Äúhidden‚Äù .After
mutation,thebrowserperforms render-update toerasethe<button>
node andits textnode as well.
Metamong currentlyhasthreeDOMeventoperations:(1)DOM
nodefocus,(2)DOMnodescrolling,and(3)windowresizing.For
DOM node focus, Metamong randomly selects and focuses one of
the DOM nodes via focus()DOM API. For DOM node scrolling,
Metamong randomlyselectsandmovesthescrollvia scrollTo(x, y)
DOMAPI.Forwindowresizing, Metamong randomlychangesthe
size of the browser window via resizeTo(width, height) DOM
API.AnexampleofDOMnodefocusisshownin Figure6c.Metamong
selects and focuses the <button> node so the browser performs
render-update to thicken the outer edge ofthe <button> node.
CSS Mutation Primitive. Metamong currently has one CSS
mutation operation: CSS style insertion/deletion; For CSS style
insertion, Metamong randomly generates the CSS rule and se-
lects the index into which the CSS style rule is to be inserted via
insertRule(rule, index) API. Similarly, for CSS style deletion,
Metamong randomlyselectsanddeletesoneoftheCSSstylerules
viadeleteRule(index) API.AnexampleofCSSstyleinsertionis
describedin Figure7.Metamong selectsoneastheindexandin-
serts the CSS style rule ‚Äúp {background: plum;}‚Äù . After mutation,
the browser performs render-update to paint the background of the
text‚ÄúExample‚Äù .
4.3 Render-Update Oracle
Overview. Therender-update bug is a semantic bug, which is
triggered if the browser incorrectly performs the render-update
whenchangingthepagethroughthejavascript.Duetotheincorrect
render-update , it generates the incorrect rendering output. In order
todetectthe render-update bug,webuildthe render-update oracle
basedonthe following assumption:
Assumption: Initial-render is the reference (or answer)
rendering result of the page. The updated-render should
bethesameasthereferencerender(i.e.,initial-render)iftheir
pagesare the same.
This assumption is based on the following two properties of the
browser rendering process: i) each page has exactly one rendering
output, and ii) the browser only performs the render-initial phase,
not therender-update when generating the initial-render. Based on
these properties, if the initial-render and the updated-render are
generated from the same page, they should be the same. If they are
diÔ¨Äerent,this impliesthat atleastone ofthemis incorrect.In this
paper, the initial-render is always correct based on our assumption
becausewefocuson/f_indingthe render-update bug,whichcanbe
onlytriggeredinrender-updatephase,not inrender-initial phase.To this end, the render-update oracle determines a render-update
bugwhen the updated-render andthe initial-render are diÔ¨Äerent.
Tobe speci/f_ic, the render-update oracle is
/uni210E/u1D45F/u1D452/u1D453‚Üê/u1D43C/u1D45B/u1D461/u1D452/u1D454/u1D45F/u1D44E/u1D461/u1D456/u1D45C/u1D45B(/uni210E/u1D461/u1D452/u1D460/u1D461, /u1D457)
/u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453‚Üê/u1D435/u1D462/u1D456/u1D459/u1D451/u1D443/u1D44E/u1D454/u1D452(/uni210E/u1D45F/u1D452/u1D453)
/u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453‚Üê/u1D43C/u1D45B/u1D456/u1D461/u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F(/u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453)
/u1D45F/u1D452/u1D460/u1D462/u1D459/u1D461‚Üê/u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F/u1D436/uni210E/u1D452/u1D450/u1D458(/u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453,/u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤)(4)
where(i)/u1D43C/u1D45B/u1D461/u1D452/u1D454/u1D45F/u1D44E/u1D461/u1D456/u1D45C/u1D45B mergestheHTML/f_ile /uni210E/u1D461/u1D452/u1D460/u1D461withthemutation
primitives /u1D457togeneratethereferenceHTML/f_ile /uni210E/u1D45F/u1D452/u1D453;(ii)/u1D435/u1D462/u1D456/u1D459/u1D451/u1D443/u1D44E/u1D454/u1D452
buildsthepagewith /uni210E/u1D45F/u1D452/u1D453;(iii)/u1D43C/u1D45B/u1D456/u1D461/u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F rendersthepage /u1D45D/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453to
draw the reference (or answer) render /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453; and (iv) /u1D445/u1D452/u1D45B/u1D451/u1D452/u1D45F/u1D436/uni210E/u1D452/u1D450/u1D458
checkswhether /u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤isequalas /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453anddeterminesthe render-
updatebugif they are diÔ¨Äerent.
Integrator. The integrator generates the reference HTML /f_ile,
which is used to get the reference rendering result of the updated-
page/u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤. To do so, it exploits yielding , one of HTML rules
de/f_inedinHTMLstandard[ 10]:
Yielding: Whenthebrowserencountersthejavascriptwhile
parsing(orloading)anHTML/f_ile,itblockstheparsing,executes
the javascript,andthen resumes to parse the HTML/f_ile.
Byusingthisproperty,wecangetaninitial-render(i.e.,reference
render) of the page, which is the same as /u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤. That is, the
integrator can make the reference HTML /f_ile that can be used
to build the same page as /u1D45D/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤without the render-update . To
be speci/f_ic, if we execute the javascript right before the browser
/f_inishes building the page, we can make the browser block the
renderingprocessandchangethepage.Afterthepagechanges,the
browserperformstherender-initialsothatwecangetthereference
render ofthe page withouttriggering render-update .
To do so, the integrator wraps the primitives with <script> tag
and then appends it to the test HTML /f_ile to generate the refer-
enceHTML/f_ile.Bydoingso,whenthebrowserloadsthereference
HTML/f_ile, the browser loads the HTML/f_ile andexecutes the mu-
tationprimitives toupdate thepage.Then,it/f_inishesbuildingthe
pageandperformstherender-initialtodrawthereferencerender
ofthe page.
Render Checker. After the integrator produces the reference
render/u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453, therender-update oracle leverages the render checker
to determine render-update bug. The render checker compares two
rendering outputs, /u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤and/u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453, and determines as render-
updatebug if they are diÔ¨Äerent. To compare the rendering outputs,
weadoptthesameimagecomparisonalgorithm(i.e.,phash[ 13])
andcon/f_igurationusedbyR2Z2[ 49]becausethe render-update bugs
are very similar to the rendering bugs hunted by R2Z2. It is worth
noting that other image comparison algorithms also can be used to
detectrender-update bugs.Finally,iftherendercheckerdetermines
there isa render-update bug,itgeneratesthe bugreport.
5 IMPLEMENTATION
We implemented Metamong on topof R2Z2[ 49]todetect render-
updatebugs from modern browsers. The prototype of Metamong
1081ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Suhwan Song andByoungyoungLee
Table 1: The number of render-update bugs detected by each
oracle.
Browser # ofBugs R2Z2 LQC Render-updateOracle
Chrome 15 0 (0%) 3 (20.0%) 15(100%)
Firefox 13 0 (0%) 9 (69.2%) 13(100%)
Total 28 0 (0%) 12(42.9%) 28(100%)
canfuzzChromeandFirefoxbrowsers.FortheHTMLgenerator,
weleveragedDomatofuzzer[7],astate-of-the-artgrammar-based
DOM fuzzer. We modi/f_ied Domatofuzzer to generate the HTML
/f_ile (i.e., an initial test page) without animations and Javascript. In
order toimplement the pagemutator, we selected DOM/CSS APIs
changingtheDOMtreeandCSSstylefromthegrammarof Domato
fuzzer.We modi/f_iedR2Z2‚Äôs fuzzingimplementationtoimplement
theintegratorof render-update oracle.Fortherenderchecker,we
adaptR2Z2‚Äôsimagecomparisonimplementationandusedthesame
imagecomparisonalgorithmandcon/f_igurationofR2Z2.Intermsof
theimplementationcomplexity, Metamong isimplementedwith
2300 linesofPython.
6 EVALUATION
Weevaluate Metamong byansweringthefollowingresearchques-
tions:
‚Ä¢RQ 1.CanMetamong detectthe render-update bugs?
‚Ä¢RQ2.WhichmutationprimitiveiseÔ¨Äectiveto/f_ind render-update
bugs?
‚Ä¢RQ 3.Howmanybugshas Metamong found?
Forevaluation, weuseda24-core serverrunningUbuntu20.04,
withIntelXeon(R)Gold 5118(2.30GHz)CPUsand512GB ofRAM.
6.1 EÔ¨Äectiveness ofRender-Update Oracle
6.1.1 RecallofRender-UpdateOracle. InordertoshowtheeÔ¨Äec-
tivenessof render-update oracleindetectingbugs,wecomparedthe
render-update oracleagainsttwodiÔ¨Äerentoracles,R2Z2[ 49]and
LQC[12]. Tobespeci/f_ic,we/f_irstselectedthepopularwebbrowsers,
Chrome and Firefox. Then, we collected the render-update bugs
whichwere alreadyreportedinChromeandFirefox bugtrackers.
From the Chrome bug tracker, we searched the render-update bugs
thatwerereportedfrom2021to2022andobtained15 render-update
bugs [14]. From the Firefox bug tracker, we searched the render-
updatebugs that were reported from 2020 to 2022 and obtained
13render-update bugs[15]. Afterwe collectedthe render-update
bugs, we simpli/f_ied bugs for evaluation and ran three oracles to
check whether they can detect these render-update bugs. Then,
we setup the experiment environment for each oracle. To run
R2Z2, we provided the similar experiment setup as described in
its paper. We /f_irst selected a beta version of each bug as Band a
stable version released at the time of BasA. Then, we selected the
independently-developedbrowserasthereferencebrowser(i.e., R),
wheretheversionof Ristheclosestof B. TorunLQC,weused
the same experiment setupas Metamong .
Table 1describes the number of render-update bugs detected by
threeoracles.LQCidenti/f_iedthree render-update bugsinChrome
andnineinFirefox(i.e.,therecallofLQCis42.9%).However,itwas
not able to detect 12 Chrome bugs and four Firefox bugs that were
triggered by DOM events (e.g., scroll) because LQC onlyallows tomutate the DOM tree and CSS style to prevent false positives. On
theotherhand,R2Z2failedtodetectanyofthe28render-update
bugs, resulting in a recall rate of 0.0%. This failure is largely due to
thefollowingtworeasons.Firstly,R2Z2isspeci/f_icallytailoredto
detect "regression" bugs, and render-update bugs did not fall under
this category. Secondly, R2Z2 can only identify render-update bugs
when the browser interoperability conditions are met (i.e., Chrome
andFirefoxgeneratethesamerenderingresultforagiveninput).
In the case of Chrome render-update bugs, only two out of 15 were
regression bugs, and R2Z2 successfully detected the diÔ¨Äerences
betweenversions AandBfortwobugs.However,R2Z2failedto
detect two Chrome render-update bugs due to the unique design
variationsbetweenChromeandFirefox,whichmadeR2Z2failto
meetthebrowserinteroperabilityconditions.Furthermore,R2Z2
failedtodetect anyoftheFirefox render-update bugsbecausethere
werenoregressionbugs. Lastly,the render-update oraclewasable
todetectallof28 render-update bugs(i.e.,therecallof render-update
oracleis100%). Thisdemonstrates Metamong ‚Äôsstrongpractical
capability indetecting render-updatebugs.
Case Study: Chrome Issue #1222734. This bug is interesting
becauseMetamong wasableto detect thebuganddidnot report
the falsepositive eventhough thereference render is incorrectac-
cordingtoDOM/CSSspeci/f_ications. Inotherwords,evenif /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453is
incorrect fromthe perspective of DOM/CSS speci/f_ications, it is cor-
rectfromtheperspectiveofthe render-update bug. Thisisbecause
theinitial-rendercanbegeneratedonlybyrender-initialphaseand
therender-update bugcanbecausedonlybytheincorrectbehavior
ofrender-updatephase(i.e.,theoriginof render-update bug). In
this respect, the initial-render can be used as the reference render-
ingresult(i.e., /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453)todeterminethe render-update bug,making
Metamong avoidthefalsepositive. Besides, Metamong wasable
to detect this bug because /u1D45F/u1D462/u1D45D/u1D451/u1D44E/u1D461/u1D452
/u1D461/u1D452/u1D460/u1D461‚Ä≤is diÔ¨Äerent to /u1D45F/u1D456/u1D45B/u1D456/u1D461
/u1D45F/u1D452/u1D453. This case
study signi/f_ies that even if the reference result is incorrect accord-
ingtoDOM/CSSspeci/f_ications, Metamong does notgeneratethe
false positive and is able to detect the bug if render-update triggers
arender-update bug.
6.1.2 AccuracyofRender-UpdateOracle. Ideally,the render-update
oracle should not trigger the false positive issue. This is because
therender-update oracle compares tworendering outputs that are
generated from two same pages where one is updated and the
other is not. As each page has exactly one rendering output, there
must be a render-update bug if two rendering outputs are diÔ¨Äerent.
Ourclaimcanbesupportedbyourevaluationtesting Metamong
because all of the 21 render-update bugs reported by Metamong
werecon/f_irmedbythedevelopersofeachbrowser.Thatis,wecould
not /f_ind any false positive casewhileevaluating Metamong .
The limitation of LQC is it cannot detect render-update bugs
which can be triggered by DOM events because it employs only
DOM nodeand CSS style mutationprimitives topreventthefalse
positive.Inthisrespect,ifLQCisemployedtodetect render-update
bugs triggered by DOM events, it will suÔ¨Äer from the false positive
issues.Forexample, Figure8illustratesafalsepositivecaseofLQC
thatcanbecausedbytheDOMevent(i.e., scroll).Inthisexample,
Chrome drawsthe correctrendered result(asshown in Figure 8b )
afterexecutingthefunction update_page() whichmovesthetext
1082Metamong : DetectingRender-Update Bugs in WebBrowsers through Fuzzing ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
1<!DOCTYPE html>
2<script>
3functionupdate_page() { target.scrollTo( 0,50); }
4</script>
5<body><divid="target"style="height: 100px; overflow: auto;" >
6<divstyle="height: 800px; background: coral" >Example</div>
7</div></body>
(a)PoC HTMLcode
(b) Actual Result(Correct)
 (c)ReferenceResultofLQC
(Incorrect)
Figure8:A falsepositiveexampleofLQCwith scrollmuta-
tion primitive.
1569
892 9368643661
93914072250
1499
11931118
779 7971036
515842 8451321
05001000150020002500300035004000
Node
insertNode
deleteAttribute
insertAttribute
deleteFocus Scoll Window
resizeStyle
insertStyle
deleteNumber of Bugs
Mutation PrimitiveChrome Firefox
Figure 9: The average number of bugs triggered by each mu-
tation primitive on 100K HTML testcases across three exper-
iments.
False Positive 10pixelsupwards.TheproblemhereisthatLQC
doesnotconsidertheDOMeventwhengeneratingthereference
result. As a result, LQC generates the incorrect reference result
(shown in Figure 8c) and triggers the false positive as both results
(i.e.,Figure 8andFigure 8c) are diÔ¨Äerent.
6.2 EÔ¨Äectiveness ofPage Mutator
The eÔ¨Äectiveness of mutation primitives are important as they
are the key to trigger render-update bugs. To evaluate their impact,
we conducted three experiments measuring the number of bugs
triggered by each mutation primitive using the same set of 100,000
HTMLtestcasesonbothChromeandFirefox. Figure9describes
theaveragenumberof render-update bugsforeachmutationprimi-
tiveonChromeandFirefoxacrossthreeexperiments.According
tothisevaluation, FocusandStyle delete arethebestmutation
primitives triggering render-update bugs in Chrome and Firefox,
respectively.Node insert andStyle delete areeÔ¨Äectivemutation
primitives on both browsers as they can change many parts of the
page. On the other hand, Attribute delete andscrollare the
worstmutationprimitivestriggering render-update bugsinChrome
and Firefox, respectively. In this experiment, we were unable to
identify patterns of eÔ¨Äective mutation primitives because the num-
ber ofrender-update bugs for varies depending on the browser. We
leave this as afuture work.1<!DOCTYPE html>
2<script>
3functionupdate_page() { document.styleSheets[0].deleteRule(0); }
4</script>
5<style>
6#update{ offset-path: path(‚ÄôM 0 1 L -1 0‚Äô); }
7#update{transform:translatez(0); }
8#child{width:100px;height:100px;background:lightblue;}
9</style>
10<body><dlid="update"><divid="child"></div></dl></body>
(a)PoC HTMLcode.
(b) Before
 (c) After (Actual)
 (d)After (Expected)
Figure 10:AcasestudyofChrome Issue# 1365255.
6.3 NewRender-Update Bugs Discoveredby
Metamong
To discover render-update bugs, we ran Metamong on Chrome 89
and Firefox 85, which were the latest browser versions at the time
ofperformingourexperiment.Thenweconductedanadditional
experiment on the latest version of Chrome (i.e., Chrome 108) in
ordertouncovermore render-update bugs. Duringthe/f_irstex-
periment, Metamong found /f_ive and four render-update bugs in
Chrome 89 and Firefox 85, respectively, and total of nine render-
updatebugs were con/f_irmed by each browser vendor. Furthermore,
itwascon/f_irmedthat/f_ive of the Chromeandtwooutof fourFire-
foxbugswerenew render-update bugs.Inadditionalexperiment,
Metamong found 12 render-update bugs in Chrome 108, and the
Chromedeveloperscon/f_irmedthattotalof12 render-update bugs
were true andnew render-update bugs.
To summarize, Metamong has found 17 and four render-update
bugs(21intotal)and17and2ofthem(19intotal)werenew render-
updatebugs in Chrome and Firefox, respectively. The list of 21
render-update bugsfoundby Metamong isshownin Table2.All
of 21render-update bugs were con/f_irmed by the developers of each
browser vendor, 19 of them were new render-update bugs, and /f_ive
ofthemwere/f_ixedsofar,showingtheeÔ¨Äfectivenessof Metamong
fordetecting render-update bugs. Inaddition,theChromedevel-
oper has shown a positive reaction, mentioning that the design
ofMetamong is interesting [ 9]. It is diÔ¨Écult for us to clearly
measure how long it takes to /f_ind a certain vulnerability, as we
kept running Metamong andMetamong ‚Äôsbehavior (particularly
itsmutation)ismostlyrandom.Overallweran Metamong fortwo
months,whichincludesthetimetodetectandanalyzethebugas
well as updating Metamong .
Case Study: Chrome Issue 1365255. Thisrender-update bug
occurs when Chrome performs render-update on the node that
has the child node and the transform CSS style. Chrome should
update the node and its child node when the CSS style of the
node is changed. However, due to the performance optimization
ontransform CSSstyle,Chromeonlyupdatesthenodeanddoes
not update the child node, triggering the render-update bug. The
snippet of a PoC code is shown in Figure 10a . First, Chrome opens
the PoC HTML code and draws the rendering output ( Figure 10b ).
1083ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Suhwan Song andByoungyoungLee
Table 2:The list of21 render-update bugsfoundby Metamong inChrome and Firefox.
Browser Issue ID Correct Incorrect New Fixed Description
Chrome
(89.0.4329.0)#1154662
 ‚úì The dashed underline is incorrect after removing an
element.
Chrome
(89.0.4329.0)#1162740
 ‚úì The text in <dl> moves to the wrong position after
removing aCSS rule "content".
Chrome
(89.0.4329.0)#1163006
 ‚úì ‚úì The<details>movestoawrongpositionafterremov-
ingCSS rules"column" and"position".
Chrome
(89.0.4329.0)#1163031
 ‚úì Theheightof<dd>islargerthanexpectedafterremov-
ingaCSS rule "height".
Chrome
(89.0.4329.0)#1164643
 ‚úì ‚úì The position of <h4> is incorrect after adding a CSS
rule "position"
Chrome
(108.0.5305.0)#1364376
 ‚úì Thewidthof<keygen>doesnotchangeafterremoving
aCSS rule "border-style".
Chrome
(108.0.5305.0)#1365243
 ‚úì ‚úì Thetextislargerthan expected afterremoving aCSS
rule "scale".
Chrome
(108.0.5305.0)#1365244
 ‚úì Thepositionof<dialog>is incorrectafterremovinga
CSS rule "backdrop-/f_ilter".
Chrome
(108.0.5305.0)#1365252
 ‚úì The size of <th> is incorrect after removing a CSS rule
"writing-mode".
Chrome
(108.0.5305.0)#1365255
 ‚úì ‚úì The border line of </f_ieldset> is not updated after re-
moving aCSS rule "oÔ¨Äset-path".
Chrome
(108.0.5305.0)#1365746
 ‚úì Theheightof</f_ieldset>doesnotdecreaseafterremov-
ingaCSS rule "margin-right".
Chrome
(108.0.5305.0)#1366233
 ‚úì ‚úì Theshapeof<q>isincorrectafterremovingaCSSrule
"font-weight".
Chrome
(108.0.5305.0)#1366280
 ‚úì The height of <th> is incorrect after removing a CSS
rule "margin-left".
Chrome
(108.0.5305.0)#1370936
 ‚úì TheborderlineisincorrectafterremovingaCSSrule
"-webkit-border-end".
Chrome
(108.0.5305.0)#1370962
 ‚úì Thesizeof<table>isincorrectafterremovingaCSS
rule "@font-face".
Chrome
(108.0.5305.0)#1370987
 ‚úì The position of quote is incorrect after removing an
element.
Chrome
(108.0.5305.0)#1371003
 ‚úì Thelocationoftextisincorrectafteraddinganelement.
Firefox
(85.0a1)#1680232
 ‚úì The line moves to a wrong position after adding a CSS
rule "display".
Firefox
(85.0a1)#1683814
 ‚úì The size of<dir> isbigger unexpectlyafteraddingan
element.
Firefox
(85.0a1)#1683820
 The position of <dialog> is incorrect after adding an
element.
Firefox
(85.0a1)#1684290
 The position of <label> is incorrect after removing a
CSS rule "input".
Then,itexecutesthefunction update_page() todeletetheCSSrule
#update{offset-path: path(‚ÄôM 0 1 L -1 0‚Äô);} . The correct be-
havior is that Chrome removes the CSS rule from the <dl> node
and its child node <div> and performs render-update to update the
rendering output. The correct rendering output is shown in Fig-
ure10d.However,asChromedoesnotupdatethechildnode<div>,
it generates the incorrect rendering output ( Figure 10c ) introduced
bytherender-update bug.
Figure 11 illustrates a potential negative consequence of this
render-update bug.Considerascenariowhereawebsiteisselling
a new laptop, and users can view the laptop image by clicking a
button. The intended correct behavior is once the button is clicked,
the CSSoffset-path is removed and the laptop image should be
placed below the button (as depicted in Figure 11b ). Unfortunately,
as illustrated in Figure 11a , Chrome fails to move the laptop imagedue to the render-update bug, disturbing users from viewing the
laptop image.
7 RELATED WORK
BrowserLayoutTesting. Previousresearchhassuggestedtesting
methodstoaidwebapplicationdevelopersin/f_indingcross-browser
incompatibilities in their web applications [ 29,30,43]. They dis-
covered cross-browser incompatibilities in web applications by
checkingwhethertwoindependently-implementedbrowserspro-
ducediÔ¨Äerentrenderingoutputsfromthesamepage.Theydeter-
mine the bug if two browsers produce diÔ¨Äerent rendering outputs.
Note that, unlike the previous research, Metamong focuses on
detecting render-update bugs in web browsers, not in web applica-
tions. In addition, Metamong does not trigger any false positive
1084Metamong : DetectingRender-Update Bugs in WebBrowsers through Fuzzing ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
(a)Actual Result(Incorrect).
 (b) ExpectedResult(Correct).
Figure 11: A possible negative consequence of the render-
update bug by Chrome Issue # 1365255. The laptop image
shouldbeplacedbelowthebuttononceclicked,buttheimage
doesnotmove due to thebug.
issue,butthepreviousresearchsuÔ¨Äersfromthefalsepositiveissue
duetobenigncross-browserincompatibilities.Anotherprevious
research has used the manually-implemented oracle with image
comparisontechniquetodetectHTMLpresentationfailuresinweb
applications[ 40,41].Notethat Metamong doesnotrequireman-
ualeÔ¨Äortanddomainknowledgetobuildtheoraclewhichisthe
key contribution of our paper. There is another work, R2Z2 [ 49],
which detects regression rendering bugs from web browsers. It
combines cross-browser testing, cross-version testing, and WPT
tests to avoid false positive issues. Nonetheless, it still suÔ¨Äers from
the false positive issue due to the missing WPT tests. LQC [ 12] de-
tectsrender-update bugs in web browsers using diÔ¨Äerential testing.
It/f_irstupdatesthepage,reloadstheupdatedpage,andcompares
pages before and after reloading. It determines the bug if pages
before and after reloading are diÔ¨Äerent. However, this approach
cannot detect render-update bugs that DOM events can trigger due
tothecharacteristicofpagereloading.Notethat Metamong can
detectrender-update bugstriggeredbyDOMevents,meaningbetter
practical abilityinbugdetection.
BrowserLayoutVeri/f_ication. Severalworkspartiallyformalized
the browser layout algorithm [ 44‚Äì46]. They used static analysis
techniquestoverifytheoverallimplementationofthebrowser‚Äôs
rendering component. To do so, they translated the HTML and
CSS speci/f_ications into the formalized rules for the static analy-
sis.However,thisapproachhasthecriticallimiation‚Äìwritingthe
formalizedrulesnot onlyrequiresdomainknowledgebut alsois
very labor-intensive and error-prone. In this respect, this approach
suÔ¨Äers from the false positive issuewhen the formalizedrulesare
incorrectorinsuÔ¨Écient.
SemanticBugFuzzing. DiFuzzRTL[ 35]proposesanewcoverage
metric to capture the states of an RTL design and detect CPU bugs.
R2Z2[49]combinesthecross-browserandcross-versiontestings
todetecttheregressionrenderingbugsfromthebrowser.Several
works/f_indsemanticbugsinJavaVirtualMachine(JVM)implemen-
tationsviadiÔ¨Äerentialtesting[ 24,27,28].Somestudiesleveraged
the fuzzing to /f_ind the semantic bugs from the deep learning li-
braries[32,51].[32]automaticallyinferstherelationalAPIsto/f_ind
the inconsistencies from the deep learning libraries. [ 51] leverages
theopensourcetoinfertheAPIinputparametertypesforeÔ¨Äective
deeplearninglibraryfuzzing.PGFuzz[ 37]proposesapolicy-guidedfuzzer to detect policyviolations from robotic vehicle controlpro-
grams.FuzzOrigin[ 38]proposesastaticorigintaggingmechanism
to detectUXSSvulnerabilitiesinbrowsers.
8 DISCUSSION
SuÔ¨Écient Number of Mutation Primitives. Metamong cur-
rently has three DOM and one CSS mutation primitives. Com-
paredtoother DOMfuzzerssuchas Domato[7]andFreeDOM[53],
Metamong leverages a few number of DOM and CSS APIs. One
might think using a small number of APIs extremely limits the
bug /f_inding. However, while evaluating the recall of render-update
oracle(¬ß6.1.1),weobservedthatall28 render-update bugscanbe
triggeredby Metamong ‚Äôsmutationprimitives.Thisshowsthatthe
current implementation of Metamong does not limit the render-
updatebug/f_inding.
LackofGuidingMethods. Metamong employsDomatofuzzerto
generateHTML/f_iles. Domatoisagrammar-basedgenerationfuzzer
anditdoesnotuseguidancemethodssuchascoverage-guidingfor
testcasegeneration.Thus,itispossiblethatthe render-update bugis
hiddendeepinthebrowser‚Äôsrenderingimplementationand Domato
fuzzer cannot generate the HTML /f_ile triggering the render-update
bug.However,theunsuitableguidingmethodcanfurtherdisturb
/f_indingbugs.Forinstance, FreeDOMguidedbycoveragetriggers3.8X
fewer crashes inDOM fuzzing compared to its generation fuzzing.
Nonetheless,wethinkleveragingasuitableguidingapproachwould
de/f_initelyenhance Metamong ‚Äôsbug-/f_indingcapability.Weleave
this as future work.
9 CONCLUSION
Thispaperproposed Metamong ,a frameworktailoredfor detect-
ingrender-update bugs in web browsers without false positives.
Metamong consistsoftwokeycomponents:apagemutator,and
arender-update oracle.Thepagemutatorgeneratesthemutation
primitiveschangingtheDOMtreeandCSSstyles,totrigger render-
updatebugs. The render-update oracle exploits an HTML standard
rule, yielding, to detect render-update bugs without false positives.
Withtheprototypeimplementationof Metamong ,itdiscovered19
newrender-update bugsinChromeandFirefoxbrowserswithout
false positives, demonstrating its eÔ¨Äectiveness and practical ability
in/f_inding render-update bugs.
10 DATA AVAILABILITY
Wedisclosedthesourcecodeof Metamong andaswellasthedata
usedinthispaperat https:///f_igshare.com/s/d3c228e614672f9aa811 .
ACKNOWLEDGMENTS
ThisworkwaspartiallysupportedbyInstituteforInformation&
communications Technology Promotion (IITP) grant funded by
the Korea government(MSIP) (No.2020-0-01840, Analysis ontech-
nique of accessing and acquiring user data in smartphone) and
the National Research Foundation of Korea (NRF) grant funded by
theKoreagovernment(MSIT)(No.RS-2023-00209093).TheInsti-
tute of Engineering Research (IOER) and Automation and Systems
Research Institute (ASRI) at Seoul National University provided
researchfacilities for this work.
1085ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA Suhwan Song andByoungyoungLee
REFERENCES
[1]has() - css: Cascading style sheets - mdnweb docs. https://developer.mozilla.org/
en-US/docs/Web/CSS/:has .
[2] american fuzzylop. https://lcamtuf.coredump.cx/a/f_l/ .
[3]Canonical randomized crawl version optimal for most browsers. https://lcamtuf.
coredump.cx/cross_fuzz/ .
[4] Css standard. https://www.w3.org/TR/?tag=css .
[5] Dharma. https://github.com/MozillaSecurity/dharma .
[6] Dom standard,. https://dom.spec.whatwg.org/ .
[7] Domato, . https://github.com/googleprojectzero/domato .
[8] Domfuzz,. https://github.com/MozillaSecurity/domfuzz/tree/master/dom .
[9]Issue 1364376: Empty <span> still has height after removing border. https:
//bugs.chromium.org/p/chromium/issues/detail?id=1364376#c4 .
[10] Htmlspeci/f_ication. https://html.spec.whatwg.org/ .
[11]Life of a pixel. https://docs.google.com/presentation/d/
1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit .
[12]Browser layout testing - quickcheck. https://github.com/nathand8/layout-
quickcheck .
[13] Imagehashpythonlibaray. https://github.com/JohannesBuchner/imagehash .
[14]Thelistofrender-updatebugsinchromebugtracker,. https://bugs.chromium.
org/p/chromium/issues/list?q=opened%3E2021-1-1%20opened%3C2023-2-
28%20component%3ABlink%3EPaint%3EInvalidation%20-status%3DWontFix%
20-status%3DDuplicate%20-Type%3DTask%20-Type%3DCompat%20-label%
3APerformance-sheriÔ¨Ä%20-label%3AClusterFuzz%20-label%3AFindit&can=1/ .
[15]Thelistofrender-updatebugsin/f_irefoxbugtracker,. https://bugzilla.mozilla.
org/buglist.cgi?short_desc_type=allwordssubstr&short_desc=%7Binc%7D&
classi/f_ication=Client%20Software&classi/f_ication=Developer%20Infrastructure&
classi/f_ication=Components&classi/f_ication=Server%20Software&classi/f_ication=
Other&query_format=advanced&bug_status=RESOLVED&bug_status=NEW .
[16]Insidelookatmodernwebbrowser(part3),. https://developer.chrome.com/blog/
inside-browser-part3/ .
[17]Rendering overview, . https:///f_irefox-source-docs.mozilla.org/gfx/
RenderingOverview.html/ .
[18]Issue 1214206: Wide-cell percentage widths are distributed incorrectly. https:
//crbug.com/1214206 .
[19]Issue1132218:tesla.com:Coloroptionsnotrendereduntilwindow resizewhen
compositesvgisenabled. https://bugs.chromium.org/p/chromium/issues/detail?
id=1132218 .
[20]Unde/f_inedbehaviorsanitizer. https://clang.llvm.org/docs/
Unde/f_inedBehaviorSanitizer.html .
[21] Wadi. https://github.com/sensepost/wadi .
[22]C. Aschermann, T. Frassetto, T. Holz, P. Jauernig, A.-R. Sadeghi, and D. Teuchert.
Nautilus:Fishingfordeepbugswithgrammars. In Proceedingsofthe2019Annual
Network and Distributed System Security Symposium (NDSS) , San Diego, CA, Feb.
2019.
[23]M. B√∂hme, L. Szekeres, and J. Metzman. On the reliability of coverage-based
fuzzer benchmarking. In Proceedings of the 44th International Conference on
SoftwareEngineering (ICSE) , Pittsburgh,PA, May‚ÄìMay 2022.
[24]T.Brennan,S.Saha,andT.Bultan. Jvmfuzzingforjit-inducedside-channeldetec-
tion. InProceedings of the 42nd International Conference on Software Engineering
(ICSE), Seoul, SouthKorea, June‚ÄìJuly 2020.
[25]P. Chen and H. Chen. Angora: EÔ¨Écient fuzzing by principled search. In Proceed-
ingsofthe39thIEEESymposiumonSecurityandPrivacy(Oakland) ,SanFrancisco,
CA, May 2018.
[26]P. Chen, J. Liu, and H. Chen. Matryoshka: fuzzing deeply nested branches. In
Proceedingsofthe26thACMConferenceonComputerandCommunicationsSecurity
(CCS), London,UK, Nov. 2019.
[27]Y.Chen, T.Su, C.Sun,Z. Su,andJ. Zhao. Coverage-directed diÔ¨Äerentialtesting
of jvm implementations. In Proceedings of the 2016 ACM SIGPLAN Conference on
ProgrammingLanguageDesignandImplementation(PLDI) ,SantaBarbara,CA,
June2016.
[28]Y.Chen,T.Su,andZ.Su. DeepdiÔ¨Äerentialtestingofjvmimplementations. In
Proceedingsofthe41stInternationalConferenceonSoftwareEngineering(ICSE) ,
Montreal,QC, Canada,May 2019.
[29]S.R.Choudhary,H.Versee,andA.Orso. WebdiÔ¨Ä:Automatedidenti/f_icationof
cross-browserissuesinwebapplications. In 2010IEEEInternationalConference
onSoftwareMaintenance , pages1‚Äì10.IEEE,2010.[30]S.R.Choudhary,M.R.Prasad,andA.Orso. Crosscheck:Combiningcrawlingand
diÔ¨Äerencing to better detect cross-browser incompatibilities in web applications.
In2012IEEEFifthInternationalConferenceonSoftwareTesting,Veri/f_icationand
Validation , pages171‚Äì180. IEEE,2012.
[31]S. R. Choudhary, M. R. Prasad,and A. Orso. X-pert:Accurate identi/f_ication of
cross-browser issues in web applications. In Proceedings of the 35th International
Conference onSoftwareEngineering (ICSE) , San Francisco, CA, May 2013.
[32]Y. Deng, C. Yang, A. Wei, and L. Zhang. Fuzzing deep-learning libraries via
automated relational api inference. In Proceedings of the 30th ACM Joint Meeting
on European Software Engineering Conference and Symposium on the Foundations
ofSoftwareEngineering (ESEC/FSE) , Singapore, Nov. 2022.
[33]G.A.DiLuna,D.Italiano,L.Massarelli,S.√ñsterlund,C.GiuÔ¨Ärida,andL.Querzoni.
Who‚Äôs debugging the debuggers? exposing debug information bugs in optimized
binaries. In Proceedingsofthe26thACMInternationalConferenceonArchitectural
Support for Programming Languages and Operating Systems (ASPLOS) , Virtual,
Apr. 2021.
[34]A. F. Donaldson, H. Evrard, A. Lascu, and P. Thomson. Automated testing of
graphicsshadercompilers. ProceedingsoftheACMonProgrammingLanguages ,1
(OOPSLA):1‚Äì29, 2017.
[35] J. Hur,S. Song,D. Kwon,E. Baek,J. Kim,andB.Lee. Difuzzrtl:DiÔ¨Äerentialfuzz
testingto/f_indcpubugs. In Proceedings ofthe 42ndIEEESymposiumon Security
and Privacy (Oakland) , San Francisco, CA, May 2021.
[36]D.R.Jeong,K.Kim,B.Shivakumar,B.Lee,andI.Shin. Razzer:Findingkernel
racebugsthroughfuzzing. In Proceedingsofthe40thIEEESymposiumonSecurity
and Privacy (Oakland) , San Francisco, CA, May 2019.
[37]H.Kim, M.O. Ozmen,A.Bianchi,Z.B.Celik,andD.Xu. Pgfuzz:Policy-guided
fuzzing for robotic vehicles. In Proceedings of the 2021 Annual Network and
DistributedSystemSecuritySymposium(NDSS) , Virtual, Feb. 2021.
[38]S. Kim, Y. M. Kim, J. Hur, S. Song, G. Lee, and B. Lee. FuzzOrigin: Detecting
UXSSvulnerabilitiesinbrowsersthroughoriginfuzzing. In Proceedingsofthe
31st USENIXSecuritySymposium(Security) , Boston, MA,Aug.2022.
[39]D. Lehmann and M. Pradel. Feedback-directed diÔ¨Äerential testing of interactive
debuggers. In Proceedingsofthe26thACMJointMeetingonEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE) , LakeBuena Vista,FL, Nov. 2018.
[40]S. Mahajan and W. G. Halfond. Finding html presentation failures using im-
agecomparisontechniques. In Proceedingsofthe29thIEEE/ACMInternational
Conference on Automated Software Engineering (ASE) , V√§ster√•s, Sweden, Sept.
2014.
[41]S.MahajanandW.G.Halfond. Detectionandlocalizationofhtmlpresentation
failures using computer vision-basedtechniques. In 2015 IEEE 8th International
Conference on Software Testing, Veri/f_ication and Validation (ICST) , pages 1‚Äì10.
IEEE,2015.
[42]R. Meng, Z. Dong, J. Li, I. Beschastnikh, and A. Roychoudhury. Linear-time
temporallogicguidedgreyboxfuzzing. In Proceedingsofthe44thInternational
Conference onSoftwareEngineering (ICSE) , Pittsburgh,PA, May‚ÄìMay 2022.
[43]A. Mesbah and M. R. Prasad. Automated cross-browser compatibility testing. In
Proceedingsofthe33thInternationalConferenceonSoftwareEngineering(ICSE) ,
Honolulu, HI, May 2007.
[44]L. A. Meyerovich and R. Bodik. Fast and parallel webpage layout. In Proceedings
ofthe19thInternationalWorldWideWebConference(WWW) ,Raleigh,NC,Apr.
2010.
[45]P.PanchekhaandE.Torlak.Automatedreasoningforwebpagelayout.In Proceed-
ingsofthe ACMSIGPLANInternational ConferenceonObject-OrientedProgram-
ming, Systems, Languages, and Applications (OOPSLA) , Amsterdam, Netherlands,
Nov. 2016.
[46]P.Panchekha,A.T.Geller,M.D.Ernst,Z.Tatlock,andS.Kamil.Verifyingthatweb
pageshaveaccessiblelayout. In Proceedingsofthe2018ACMSIGPLANConference
onProgrammingLanguageDesignand Implementation(PLDI) ,Philadelphia,PA,
June2018.
[47]T.Petsios,A.Tang,S.Stolfo,A.D.Keromytis,andS.Jana.Nezha:EÔ¨Écientdomain-
independentdiÔ¨Äerentialtesting. In Proceedingsofthe38thIEEESymposiumon
Securityand Privacy (Oakland) , San Jose, CA, May 2017.
[48]K.Serebryany,D.Bruening,A.Potapenko,andD.Vyukov. Addresssanitizer:A
fast addresssanity checker. In Proceedings ofthe 2012 USENIX Annual Technical
Conference (ATC) , Boston, MA,June2012.
[49]S.Song,J.Hur,S.Kim,P.Rogers,andB.Lee.R2z2:Detectingrenderingregressions
in web browsers through diÔ¨Äerential fuzz testing. In Proceedings of the 44th
International Conference on Software Engineering (ICSE) , Pittsburgh, PA, May‚Äì
May 2022.
1086Metamong : DetectingRender-Update Bugs in WebBrowsers through Fuzzing ESEC/FSE ‚Äô23, December3‚Äì9, 2023,San Francisco, CA, USA
[50]J. Wang, B. Chen, L. Wei, and Y. Liu. Sky/f_ire: Data-driven seed generation for
fuzzing. In Proceedings of the 38th IEEE Symposium on Security and Privacy
(Oakland) , San Jose, CA, May 2017.
[51]A. Wei, Y. Deng, C. Yang, and L. Zhang. Free lunch for testing: Fuzzing deep-
learning libraries from open source. In Proceedings of the 44th International
Conference onSoftwareEngineering (ICSE) , Pittsburgh,PA, May‚ÄìMay 2022.
[52]M. Wu, L. Jiang, J. Xiang, Y. Huang, H. Cui, L. Zhang, and Y. Zhang. One fuzzing
strategytorulethemall. In Proceedingsofthe44thInternationalConferenceonSoftwareEngineering (ICSE) , Pittsburgh,PA, May‚ÄìMay 2022.
[53]W. Xu, S. Park, and T. Kim. Freedom: Engineering a state-of-the-art dom fuzzer.
InProceedings of the 27th ACM Conference on Computer and Communications
Security(CCS) , Virtual, USA,Nov. 2020.
[54]Y. Yang, Y. Zhou, H. Sun, Z. Su, Z. Zuo, L. Xu, and B. Xu. Hunting for bugs in
code coverage tools viarandomized diÔ¨Äerential testing. In Proceedings ofthe 41st
InternationalConferenceonSoftwareEngineering(ICSE) ,Montreal,QC,Canada,
May 2019.
1087