Gap between Theory and Practice : An Empirical Study of
Security Patches in Solidity
Sungjae Hwang
KAIST
Daejeon, South Korea
sjhwang87@kaist.ac.krSukyoung Ryu
KAIST
Daejeon, South Korea
sryu.cs@kaist.ac.kr
ABSTRACT
Ethereum,oneofthemostpopularblockchainplatforms,providesfi-
nancialtransactionslikepaymentsandauctionsthroughsmartcon-
tracts. Due to the immense interest in smart contracts in academia,
the research community of smart contract security has made a
significant improvement recently. Researchers have reported vari-
oussecurityvulnerabilitiesinsmartcontracts,anddevelopedstaticanalysistoolsandverificationframeworkstodetectthem.However,
itisunclearwhethersuchgreateffortsfromacademiahasindeed
enhanced the security of smart contracts in reality.
To understand thesecurity levelof smartcontracts in thewild,
we empirically studied 55,046 real-world Ethereum smart contracts
written in Solidity,the most popular programming language used
by Ethereum smart contract developers. We first examined how
manywell-knownvulnerabilitiestheSoliditycompilerhaspatched,
and how frequently the Solidity team publishes compiler releases.
Unfortunately,weobservedthatmanyknownvulnerabilitiesare
not yet patched, and some patches are not even sufficient to avoid
their target vulnerabilities. Subsequently, we investigated whether
smartcontractdevelopersusethemostrecentcompilerwithvul-
nerabilitiespatched.Wereportedthatdevelopersofmorethan98%
of real-world Solidity contracts still use older compilers without
vulnerabilitypatches,andmorethan25%ofthecontractsarepoten-
tiallyvulnerableduetothemissingsecuritypatches.Tounderstand
actual impacts of the missing patches, we manually investigatedpotentially vulnerable contracts that are detected by our static
analyzerandidentifiedcommonmistakesbySoliditydevelopers,
which may cause serious security issues such as financial loss. We
detected hundreds of vulnerable contracts and about one fourthof the vulnerable contracts are used by thousands of people. We
recommend the Solidity team to make patches that resolve known
vulnerabilitiescorrectly,anddeveloperstousethelatestSolidity
compiler to avoid missing security patches.
KEYWORDS
Empirical Study, Smart Contracts, Solidity, Security Patches
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380424ACM Reference Format:
SungjaeHwangandSukyoungRyu.2020.GapbetweenTheoryandPractice
:AnEmpiricalStudyofSecurityPatchesinSolidity.In 42ndInternational
ConferenceonSoftwareEngineering(ICSE’20),May23–29,2020,Seoul,Re-
publicofKorea. ACM,NewYork,NY,USA,12pages.https://doi.org/10.1145/
3377811.3380424
1 INTRODUCTION
Blockchaintechnologieshavebecomeincreasinglypopularandare
now considered as one of the key enablers of secure distributed
computations providing, a wide spectrum of applications withsmartcontracts.Oneofthemostpopularblockchainplatformsis
Ethereum[ 3,5],whichimplementsadecentralizedTuring-complete
virtual machine, called the Ethereum Virtual Machine (EVM), and
it can support not only cryptocurrency but also other applications
like games and financial services [ 4]. The key to support such a
variety of applications in the blockchain is smart contracts.
Smartcontractsareprogramsthatprovidesecurity-criticalap-
plications like financial transactions, but they are vulnerable to
varioussecurityattacks[ 6].Amonglanguagesthatarecompiled
to Ethereum bytecode, embedded in transactions as bytecode, and
run on EVM, Solidity [ 46] is the most widely supported and main-
tained one so far. However, because the semantics of Solidity is
notformallynorcompletelyspecified,severesecurityissueswith
smart contracts have been reported. For example, vulnerabilities of
the Decentralized Autonomous Organization (DAO) [ 2] resulted in
$150millionbeingstolen,andParity’s$280MEthereumwallets[ 1]
had to be frozen.
Toalleviatetheproblemofinsecuresmartcontracts,researchers
havestudied varioussecurityvulnerabilities,and developedstatic
analysis tools and verification frameworks to detect them. Static
analysistechniquestodetectsuchvulnerabilitiesformallyverify
a subset of Solidity [ 8], analyzes Ethereum bytecode using sym-
bolic execution [ 24,25,27,29], or analyzes Solidity contracts by
compiling them to LLVM bitcode [ 23]. Researchers also have at-
tempted to formalize the semantics of various subsets of Solid-
ity[18,20,21,28,34].Sucheffortsfromacademiamadeasignificant
improvement in the theory of smart contract security.
However, it is unknown whether such efforts from academia
improved the security of smart contracts in reality. To understand
the security level of smart contracts in the wild, we empirically
studied real-world Ethereum smart contracts in case of the Solidity
programming language. To the best of our knowledge, no previous
research answers the following questions. Does the Solidity lan-
guagebecomemoresecurebyfixingknownvulnerabilities.Does
theSoliditycompilergetsecuritypatchesfortheknownvulnerabil-ities?Ifso,wouldSoliditydeveloperstakeadvantageoftherepaired
5422020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
Soliditycompilers?Arethecompilerpatcheseffectiveenoughto
preventtheirtargetvulnerabilities?Inaddition,dodevelopersac-
tually make bugs and errors due to such vulnerabilities?
In this paper, we answer the above research questions and re-
portourempiricalfindingsaboutthegapbetweentheimportant
advances in the theory of smart contract security and the develop-
mentandusesinreal-worldcontracts.Aftercollecting41known
vulnerabilitiesfromdiversesourcesincludingacademicpapersand
industrial reports, we examined all the Solidity patches from the
official release notes [ 13] and found that seven out of 41 known
vulnerabilities are patched, and one patch is under development by
theSoliditycompilerteam.Thus,weobservedthatmanyknown
vulnerabilities are not yet patched, and even some patches applied
topreventspecificvulnerabilitiesarenotsufficienttoremovethem.
GiventhattheSolidityteamhaspatchedatleastsevenknown
vulnerabilities, would Solidity developers utilize the Solidity com-
pilerfixes?TounderstandwhetherSoliditydevelopersusesecuritypatchesintheircontractdevelopment,weinvestigatedwhetherthe
developersuse themost recentcompilerversion withvulnerabili-
tiespatched.Unfortunately,wefoundoutthatdevelopersof98.14%
ofSoliditycontractsinthewildusedoldercompilersthantheup-
to-dateversionatthetimeofdevelopingthecontracts.Moreover,
among 55,046 contracts that are currently available from Ether-
scan [16], 54,021 contracts are created by the compilers without all
the security patches available. To see the effects of not using the
mostrecentcompilerversions,webuiltalight-weightstaticana-
lyzerthatdetectscontractsexposedtounpatchedvulnerabilities.
Theanalyzerreportedthat13,943contracts(25.33%)arepotentially
vulnerable due to the missing security patches.
Inordertounderstandwhetherthepotentiallyvulnerablecon-
tracts reported by our tool actually contain security issues, we
manuallyinvestigatedthereportedcontractsthathadreceivedandsentmorethan10transactions.Foreachvulnerability,weinspected
howtheSoliditycompilerpatchedthevulnerability,whetherthe
patch is sufficient, what mistakes developers commonly make due
tothevulnerability,andwhatkindsofsecurityissuestheycancause.
Asfarasweknow,previousresearchdidnotconductin-depthin-
vestigation on most of the vulnerabilities discussed in this paper
such asstorage variable shadowing confusion andinheritance order
confusion.Ourinvestigationshowedthathundredsofvulnerable
contracts are doubtlessly exploitable.
Wereportedeightvulnerablecontractsthatrepresentallthevul-
nerabilities discussed in this paper and received eight CVE IDs for
them.Inaddition,ourwork alsorevealedinse curecodingpractices
from Solidity developers that have not been previously studied.
We recommend the Solidity team to make security patches that
resolve known vulnerabilities correctly, and developers to use the
latest Solidity compiler to avoid missing security patches. The tool
usedforourempiricalstudyispubliclyavailable1.Intheremainder
of this paper, we discuss the findings in detail.
2 BACKGROUND
Beforediscussingthefindings,thissectionexplainsbasicfeaturesof Solidity to understand the paper.
1https://github.com/sjmini/icse2020-Solidity2.1 Solidity Basics
Solidity[ 46]isahigh-levelprogramminglanguagedevelopedby
Ethereum Foundation. While Ethereum transactions embed smart
contracts inthe formof EVMbytecode, programmersoften write
contracts in high-level languages, which is less error-prone and
moreproductivethaninbytecode.Solidityisthemostsupported
and widely-used language that compiles to EVM bytecode.
Asmartcontractsourceunitisasequenceofcontractdefinitions.
Acontractdefinitiondefinesacontract,alibrary,oraninterface.A contract is like a class in object-oriented languages that sup-
port multiple inheritances. Contracts can specify their fields and
methods.Acontract residesataspecific addressontheEthereum
blockchain. The EVM is the runtime environment for Solidity con-
tracts, which is sandboxed and isolated. Solidity uses five memory
areas to save data of contracts: storage, stack, memory, logs, and
calldata. Among them, storage is the only persistent memory area,
and the other four are temporal ones.
2.2 Storage
Everycontracthasapersistentkey-valuestore,whichmaps256-bit
words to 256-bit words, called storage. Each key refers to a “slot”
and each slot can store 256-bit data; thus, storage is a collection of
slots. A contract can neither read nor write to any other storage
than its own.
The storage layout is defined and fixed at the creation time of a
contract, and it cannot be altered at run time [46]:
Statically-sized variables (everything except mapping
anddynamically-sizedarraytypes)arelaidoutcon-
tiguouslyinstoragestartingfromposition0.Multiple
itemsthatneedlessthan32bytesarepackedintoa
singlestorageslotifpossible,accordingtothefollow-
ing rules: ···Structs and array data always start a
new slot and occupy whole slots ···
Thus,eachelementofafixed-size uintarraytakestheentiresingle
256-bit slot in storage. Because the sizes of mapping types and
dynamic array types are unknown at compile-time, such types use
a Keccak-256 hash function to calculate the starting point of the
value or the array data.
3 SOLIDITY SECURITY PATCHES
First, we explored the question of whether the Solidity program-
ming languagebecomes moresecure byfixing knownvulnerabili-
ties. We examined the question in two respects: how many known
vulnerabilities are patched by the Solidity compiler and how often
the compiler gets released.
3.1 Does Solidity Patch Known Vulnerabilities?
We first collected known vulnerabilities from various sources in-
cludinglistsfromindustryandathoroughcollectionfromacademic
papers as follows:
(1)ThemostrecentversionoftheofficialSoliditydocumenta-
tion as of March 31, 2019 [46]
(2)SWCregistry:SmartContractWeaknessClassificationand
Test Cases [48]
(3) ConsenSys: Ethereum Smart Contract Best Practices [45]
543Table 1: Known vulnerabilities patched by the Solidity compiler and the number of contracts that are vulnerable to them
IDKnown VulnerabilityPatched No. of Vul. No. of Vul. Contracts Total No. of tx of
Version Contracts with≥10 tx Vul. Contracts with ≥10 tx
SPV-01 Misuse of constructors 0.5.0 482 109 359,671
SPV-02 Functions without visibility 0.5.0 754 363 3,604,633
SPV-03 Storage variable shadowing confusion Planned 493 231 895,828
SPV-04 Type casting to arbitrary contracts 0.4.0 and 0.5.0 864 374 1,940,529
SPV-05 Inheritance order confusion 0.4.24 and 0.5.0 475 177 1,898,334
SPV-06 Uninitialized storage pointers 0.5.0 89 32 159,975
SPV-07 Typo of the +=operator 0.5.0 4 4 106
SPV-08 Use of deprecated functions 0.5.0 10,782 3,342 22,164,034
Total 13,943 4,632 31,023,110
(4)NCCGroup:DecentralizedApplicationSecurityProject[ 19]
(5)186 academic papers from major conferences and arXiv that
contain “smart contract” in their titles and abstracts
The SWC registry is an implementation of the weakness classifi-
cation scheme proposed in EIP-1470 [ 12]; its purpose is to share
securityissuesinsmartcontracts.TheConsenSysgroupassembled
“EthereumSmartContractBestPractices”andtheNCCGroupruns
the “Decentralized Application Security Project”, which is a col-
laborative effort discover smart contract vulnerabilities within the
security community. We inspected all the sources and collected all
thereportedvulnerabilitiesfromthem,whichamountsto41.The
list of collected known vulnerabilities is publicly available2.
For each known vulnerability, we investigated whether any ver-
sionoftheSoliditycompilerpatchedthevulnerability.Wereviewed
the official Solidity release notes [ 13] and double-checked them
by implementing a contract with the vulnerability, compiling it
with a patched and an unpatched versions of the Solidity compiler,
and comparing their results. We found that seven out of 41 known
vulnerabilitiesarepatchedandoneisplannedtobepatchedassum-
marized in Table 1. We named each vulnerability in the table with
the “SPV” prefix, which stands for Smart contract Patched Vulnera-
bility. The second column describes the vulnerability and the third
column shows which Solidity compiler version patched the vulner-
ability.NotethatapatchforSPV-03isunderdevelopment[ 47].We
discuss the remaining columns of the table in Section 5.
Because all the existing Solidity patches for known vulnera-
bilities are available from Solidity 0.5.0, we strongly recommend
developers to use at least version 0.5.0 of the Solidity compiler.
3.2 How Often Does Solidity Get Updated?
InordertounderstandwhethertheSolidityteamactivelyresponds
to demands from developers such as feature requests and security
patches,weinspectedtheofficialSolidityreleasenotes.FromSo-
lidity0.1.2releasedonAugust21,2015,50compilerreleaseshave
madetillversion0.5.7releasedonMarch26,2019.Themaximum
numberofdaysbetweenconsecutivereleasesare121,theminimum
one,andtheaveragedays27.Basedonthedata,weregardthatthe
Solidity compileris activelyevolving and gettingsecurity patches
as long as they are available.
2https://github.com/sjmini/icse2020-Solidity/tree/master/material/known_weakness.pdfDaysNo. of Contracts
0 100 200 300 400
1 115 230 345 460 575> 30 (18632/55046, 33.85%)
> 60 (14002/55046, 25.44%)
> 90 (10409/55046, 18.91%)
Figure 1: Available days for developers to make their con-tracts conform to newly released compiler versions
4 USES OF SOLIDITY SECURITY PATCHES
Now that the Solidity compiler patched seven out of 41 known
vulnerabilities,dodevelopersusethecompilerwithpatches?We
studiedthequestioninthreeregards:1)howmanycontractsare
compiled by older versions of the compilers than the up-to-date
versions at the time of developing them, 2) how many contracts
are exposed to already patched vulnerabilities due to the use of old
compilers, and 3) how many contracts are statically reported as
vulnerable due to the use of old compilers.
Toanswerthesequestions,wedevelopedacrawlertocollectSo-
liditysmartcontractsfromEtherscan[ 16],awell-knownEthereum
blockchainexplorer.Foreachcontract,wecollecteditsname,sourcecode,compiledversion,deploymentdate,Etherbalance,numberof
transactions, andthe last transactiondate. We crawledthem from
December 14, 2018 to March 31, 2019, and collected 55,820 verified
contracts. Among 55,820 contracts, we excluded 774 destructed
contracts, which are unavailable for use because their bytecode are
removed from the blockchain [ 39]. For the remaining 55,046 live
contracts,weusedtheirtotalnumbersoftransactionsandthedates
of the last transactions to identify the most actively used ones.
4.1 How Many Contracts Are Compiled by Old
Compilers?
To get the number of contracts that are compiled by older versions
of compilers, we checked the deployed dates of contracts and their
54413579 1 2 1 5 1 8 2 1 2 4 2 7 3 2 3 5
No. of New CompilersNo. of Contracts
0 2000 4000 6000 8000Average : 3.90
Figure2:Numberofcompilerversionsmissedbydevelopers
Table2:Numberofcontractsthatarenotexposedtoknown
vulnerabilities due to the use of old compilers
Compiled Version No. of Contracts Patched Vulnerabilities
0.5.0≤ 1,025 ( 1.86%) SPV-01 to SPV-08 except SPV-03
0.4.24≤v<0.5.0 21,638 (39.31%) SPV-05 partially
<0.4.24 32,383 (58.83%) None
Total 55,046 ( 100%)
used compiler versions. When the used compiler version of a con-
tractisnotthelatestcompilerversionatthetimeofitsdeployment,
weconfirmedthatthecontractwascompiledbyanoldcompiler.
Among55,046livecontracts,26,373contractswerecompiledbyold
compilers,whichamountsto47.91%.Theresultindicatesthatmany
developers do not use the latest version of the Solidity compiler.
To understand why the developers did not use the latest version
of the Solidity compiler, we further investigated how many days
arepassedbetweenthereleasedatesofthenewestcompilersand
thecontractdeploymentdates.Theyshowthenumbersofavailable
days for developers to make their contracts applicable to newly
released versions of the compiler before deployment. Figure 1 illus-
tratesthat33.85%ofthecontractshadmorethan30days,25.44%
hadmorethan60days,and18.91%hadmorethan90daystouse
newly released compilers before deploying their contracts. The
resultshowsthatthedevelopersofaboutonethirdofthecontracts
had more than 30 days to make their contracts comply to the latest
compiler version.
In addition, for the contracts compiled by old compilers, we also
checked how many compiler versions were missed between the
newest ones and the used ones by developers. Figure 2 shows that
most developers used the previous versions of the latest ones, and
four compiler versions were missed on average.
4.2 How Many Contracts Are Exposed to
Already Patched Vulnerabilities?
Giventhat47.91%ofthecontractsarecompiledbyoldcompilers,
how many contracts are exposed to already patched vulnerabilities
due to the use of old compilers? Table 2 summarizes the result3.
More than a half of the live contracts, 58.83% were compiled by
compilerspriortov0.4.24,and98.14%werecompiledbytheones
3We considered v0.4.26 as v0.5.0 because it was officially released after v0.5.0.below v0.5.0. Therefore, more than 98% of the live contracts are
exposed to the vulnerabilities that are already patched in v0.5.0.
4.3 How Many Contracts Are Detected as
Vulnerable?
Among98%ofthelivecontractsthatareopentothevulnerabilities,
how many of them are actually vulnerable? To understand the im-
pactsofmissingSoliditypatchesinpractice,wedevelopedasimplestaticanalysistoolthatdetectspotentiallyvulnerablecontractsdue
to the lack of Solidity patches. We describe how the tool detects
vulnerable contracts for each vulnerability in the next section.
Table 1 presents the results of our static analyzer. Out of 55,046
contracts,itreportedthat13,943contractsmaybevulnerableduetothemissingpatches,whichcouldhavebee npreventedifthepatches
wereapplied.Thecontractsreportedasvulnerablearepopularones
asthenumbersoftheirtransactions,denotedastx,show.Evensuchpopularcontractswithmanytransactionsmayhavevulnerabilities
that were already patched in the current compiler.
5 VULNERABLE CONTRACTS IN PRACTICE
ToverifyactualimpactsofmissingSoliditypatchesinreality,we
manuallyinvestigatedthepotentiallyvulnerablecontractsreported
byourtool.Toanalyzeonlymeaningfulcontracts,wechosecon-
tracts with at least 10 transactions. For each vulnerability, whenover 300 contracts have more than or equal to 10 transactions,
we selected top 200 contracts in the order of the number of total
transactions.
Inthissection,weexplaineachvulnerability,howtheSolidity
compiler patches it, whether the patch is sufficient to avoid the
vulnerability,howourtooldetectspossiblyvulnerablecontracts,
what kinds of errors and mistakes developers actually make due
to the vulnerability, and how the developers’ mistakes can causeserious security problems. Code examples in this section are all
from real-world contracts.
5.1 Misuse of Constructors
Solidity initially provide two ways to define contract constructors,
but one has been deprecated from v0.5.0 because it often allows
developers to make vulnerable contracts. The original two ways tomake a function constructor are 1) using the
constructor keyword
and2)usingthesamenameasitscontract’sname.Thesecondway
is vulnerable because if a developer accidentally uses a different
nameforafunctionintendedtobeaconstructorfromitscontract’s
name,thefunctionbecomesanordinaryfunction,whichmaybe
accessible by external users. Since constructors usually perform
criticaloperationslikeinitializationofsensitivedatasuchascon-
tract owners, if they are open to external attackers, it may cause
security issues. Thus, the Solidity compiler from v0.5.0 forbids the
secondwaybyrejectingfunctionsthathavethesamenamewith
theircontracts.Unfortunately,thispatchisnotsufficienttoavoid
thevulnerability,becauseprogrammerscanstillmakemistakeslike
usingdifferentnamesforafunctionintendedtobeaconstructor
and its contract. As we show in this section, Solidity developersoften make such mistakes in real-world smart contracts, and we
received four CVE IDs for them as we discuss below.
545Our tool reports potentially vulnerable contracts due to misuse
of constructor names by using a well-known string similarity algo-
rithm,Levenshtein distance[26],forfunction namesandcontract
names. Because the algorithm gives the same weight for insertion
and delete of letters and case substitution, we modified the algo-
rithm using the weight rules proposed by Wagner and Fischer [52]
togivedifferentweightsforeachoperator.Inaddition,weadded
a swap operator to detect similar strings that are different only
in the order of two letters. The tool also analyzes comments; if a
comment just above a function definition contains the constructor
keywordignoringcases,andifthefunction’snameisdifferentfrom
its contract’s name, the tool reports it as a vulnerable constructor.
Wemanuallycheckedthepossiblyvulnerablecontractsreported
by the tool and confirmed that 482 contracts are vulnerable due to
themisuse ofconstructorsas Table1shows.We furthermanually
investigated109contractswithatleast10transactions,andwecon-firmed that all of them are indeed vulnerable constructor functions
in the sense that either their comments say that they are meant to
beconstructorsorthefunctionbodiesperformonlyinitialization.
Wefurtheridentified exploitable contractsthatarecallablebyexter-
nal users and let them change sensitive data such as their contract
owners.We found out that 55 contracts, which amounts to
50.46%, are exploitable due to vulnerable constructors. Thesecontracts are popular ones because the total number of theirtransactions is 63,674, and 13 contracts have more than 100token holders.
Weanalyzed55exploitablecontractsandclassifiedtheirmain
causes as the following three types of developer mistakes:
Incorrect Reuse of Standard Contracts: We observed that
developersincorrectlyreusestandardcontracts’constructorspro-
vided by Ethereum and other renowned blockchain companies. For
example,weencountereddevelopersincorrectlyreusestandardcon-tractssuchas
tokenERC20 [15]byEthereumand SimpleToken [31]by
OpenZeppelin[ 30].When developersreusedit, theyoftencopied
the contract and changed only the contract nameleaving the con-
structornameunchanged,whichmakesavulnerableconstructor.
Wefoundthat18differentcontractshadthesameconstructorof
tokenERC20 , and we received one CVE ID for them4.
Typos in Constructor Names: We observed that developers
domaketyposinconstructornamesduetowrongcapitalization,
swapping characters, and misspelling. For example, we encoun-tered 24 contracts with simple typos where contract names and
constructornamesdiffer onlyinoneletter, onenumber,theorder
of two characters, or capitalization. They are popular contracts in
that the total number of their transactions were 54,662, and we
received three CVE IDs for them5.
Usageof publicFunctions: Wefoundthatdevelopersuse public
functionsasconstructors.Ifa publicfunctionisusedasaconstruc-
tor, its contract should guarantee that only authorized users can
call the constructor. However, we found that ten contracts had no
authentication, which allows external attackers to call them and
alter their sensitive data, and another case checked only its initial-
ization flag, which may lead to the race condition attack [32]a s
4https://github.com/smsecgroup/SM-VUL/tree/master/copy-vul-00
5https://github.com/smsecgroup/SM-VUL/tree/master/typo-vul-00
https://github.com/smsecgroup/SM-VUL/tree/master/typo-vul-01
https://github.com/smsecgroup/SM-VUL/tree/master/typo-vul-02attackersmay beableto callthefunction beforethe ownerofthe
contract.
In addition to the three patterns from exploitable contracts, we
also observed another frequent pattern from 24 non-exploitable
contracts: splitting initialization functions in multiple functions.
Consider the following minimized code from a real-world contract:
1contract BookERC20EthV1p1 {
2 // Constructor.
3 // Creator needs to call init() to finish setup.
4 function BookERC20EthV1p1() { ... }
5 function init(...) public { ... }
6}
where initialization statements are distributed in BookERC20EthV1p1
and init. As the comment says, the contract owner should man-
uallycallallofthenecessaryfunctionstoproperlyfinishtheini-
tialization process. We analyzed transactions of these 24 contracts
to see whether the owners of the contracts called all the neces-
saryfunctionsproperlyrightaftertheircontractdeployment.We
foundoutthatsixoutof24contractsfailedtocallallthenecessary
functions, which may miss initialization of important data such
astokenaddressesandtheinitialtokenbalancesoftheirowners.
Even though they may cause such problems, we classified them as
non-exploitablebecausetheyallproperlyauthenticatedfunction
callers.
Finally, we report three insecure cases due to vulnerable con-
structorsobservedfromexploitablecontracts.First,19constructors
initialized their owners to callers. Consider the following example:
1contract Owned {
2 address public owner;
3 function owned() public {o w n e r=m s g . s e n d e r ;}
4}
where the ownedfunction was intended to be a constructor but it
isapublicfunctionduetothetypoinitsname.Anyattackerthat
calls ownedbecomes the owner of the contract, and the attacker
can stealing all the Ether reserved in the contract, obtain tokens
without paying a fee, and more. Second, we found 38 vulnerable
constructors that transfer their tokens to their callers. For example:
1contract BossCoin {
2 function TokenERC20(...) public {
3 totalSupply = 2000000000;
4 // Give the creator all initial tokens
5 balanceOf[msg.sender] = totalSupply;
6 }}
any attacker can get the total tokens of BossCoin by simply calling
TokenERC20 . Third, we found that vulnerable constructors initialize
flags for crowdsale and ICO status. By calling such constructors,
attackers can change the flag of a finished ICO and buy its tokens.
5.2 Functions without Visibility
Solidityusedtoallowfunctiondeclarationstoomittheirvisibilities,
but from v0.5.0 it throws a compilation error if a function visibility
isnotspecified.InSolidity,afunctionmaydeclareitsvisibilityas
external,internal,public,orprivate.Functionswiththe publicor
external visibilitycanbecalledbyexternalusers,whereas private
and internal functionsarehiddenfromthem.Hence,ifattackers
attempttoattackcontracts,theonlypossibleentrypointsare public
and external functions. However, before v0.5.0, when a function
546declarationdoesnotspecifyitsvisibility,itwas publicbydefault,
whichiscriticallyvulnerable.Thus,Solidityenforcesfunctionsto
declare their visibilities. Note that Android had a similar history.
SincethevisibilityofanAndroidcontentproviderusedtobe public
bydefault,itcausedmanysecurityissues[ 22]andGoogleofficially
changedthedefaultvisibilitytofalse,whichcorrespondsto private.
Our tool reports functions as potentially vulnerable due to func-
tionvisibilitywhentheysatisfythefollowingthreeconditions:1)no
visibilityspecified,2)nomodifierfunctioncheckingpre-conditions,
and 3) update of a “critical storage variable”, a storage variable that
is used by modifier functions, because modifiers often check the
validity of security-sensitive data stored in storage variables.
Table 1 shows that the tool detected 754 contracts as vulnera-
ble. We chose 200 contracts in the decreasing order of the num-
ber of total transactions, and manually investigated them to see
whether they are indeed exploitable. We considered contracts as
exploitableif1)theirfunctionsreportedasvulnerabledonotcheck
authorization for updating critical storage variables, which allows
any attacker to update them, and 2) updates on critical storage
variablesdisablethevaliditycheckingofthestoragevariablesin
modifier functions. Thus, we may have missed some exploitable
contractsthatdonotmeettheserequirementsbutwedonotfind
falsepositives. Outof200contracts,weconfirmedthat63con-
tracts have vulnerable functions, which amounts to 31.50%.They are popular ones whose total number of transactions is1,065,643,and48contractshavemorethan100tokenholders.
Among them, we reported one exploitable contract and received
one CVE ID for it6.
Weanalyzed63exploitablecontractsandobservedthreetypes
ofdevelopermistakes:(1)onlyinitializationchecking,(2)nocheck-
ing, and (3) misuse of constructors, again! We found that most
vulnerable functions checked only the initialization flags before
updating critical storage variables, which as we discussed in the
previoussection,cancausetheraceconditionattack.Wealsofound
that vulnerable functions often missed any authentication logic,
which allows anyone to call such functions to change critical stor-
agevariables.Thethirdpatterniswronglynamedfunctionsthat
were intended to be constructors. Consider the following example
from a real-world contract:
1contract Token {
2 function Ownable() { owner = msg.sender; }
3 function transfer(address _to ...) ... {...}
4 modifier onlyOwner() {
5 require(msg.sender == owner); _; }
6 ...}
whichshowsthatitsdevelopermergedastandardexamplecontract
Token[9] and an Ownablecontract [ 53] into one contract, but failed
to rename the constructor of Ownable, which became a general
publicfunction.Now,anyattackercancallthe Ownablefunctionto
change the owner of the contract.
Our investigation revealed that attackers can change the follow-
ing critical storage variables:
(1)important addresses such as the owners of the contracts,
crowdsale contract addresses, proxy token addresses, proxy
asset addresses, and wallet addresses
6https://github.com/smsecgroup/SM-VUL/tree/master/visibility-vul-00(2)ICOdateslikethestartdateofICO,theenddateofICO,and
the start date of pre-invest
Bychangingtheabovecriticalstoragevariable,attackerscan per-
formvariouscriticalattacks.Forexample,attackerscanstealallthe
Etherbalances reservedin acontractonce theychange theowner
of the contract.
5.3 Storage Variable Shadowing Confusion
InSolidity,whenaparentcontractandachildcontracthavestorage
variables with the same name, the storage variable in the parent is
hiddenfromthechild.Asaresult,withthesamename,functionsintheparent refer tothe variabledefined intheparent, andfunctions
inthechildrefertothevariabledefinedinthechild,whichcould
be confusing to developers. The Solidity team is currently working
onapatchforthisvulnerabilityandaimstopublishitinthenext
release [47].
Our tool identifies contracts as potentially vulnerable due to
storagevariableshadowingconfusionwhentheysatisfythefollow-
ing three conditions: (1) parent and child contracts have storage
variables with the same name, (2) one of the functions from the
parent contract reads or writes the storage variable with the same
namedefinedintheparenttoshowtheeffectsofshadowing,and
(3) the visibility of the storage variable in the parent is publicor
internal because only such storage variables are inherited.
Wemanuallycheckedthepossiblyvulnerablecontractsreported
by the tool and confirmed that 493 contracts are vulnerable due
to the storage variable shadowing confusion as Table 1 shows. We
manuallyinspected231contracts thathavemorethanorequalto
10 transactions. Among 231 contracts, we found out that 106
contractsareexploitable,whichamountsto45.89%.Thetotalnumber of transactions for 106 contracts is 292,048, and 26contracts have more than 100 token holders.
Amongthem,we
reported two exploitable contracts and received two CVE IDs7.
Weanalyzed106exploitablecontractsandobservedsixpatterns
of developers’ mistakes.
InitializationConflict: Thefirstpatternistoinitializeonlythe
storagevariabledefinedinthechildwithoutinitializingthestorage
variable defined in the parent, which causes a problem when a
function in the parent uses the uninitialized storage variable in the
parent. Consider the following example:
1contract StandardToken is ERC20, SafeMath {
2 uint public totalSupply;
3 function burn(uint256 _value)
4 public returns (bool success)
5 { totalSupply = safeSub(totalSupply ,_value); }
6}//end of parent contract
7contract USDXCoin is Own able , StandardToken {
8 uint public totalSupply;
9 function USDXCoin() public
10 { totalSupply= 10*(10**6)*(10**6); }
11 function mintToken( uint _value...)
12 { totalSupply = safeAdd(totalSupply , _value) }
13 }
Boththeparent StandardToken contractandthechild USDXCoin con-
tract have the storage variable named totalSupply , but only the
totalSupply variable in the child is initialized on line 10. Hence,
7https://github.com/smsecgroup/SM-VUL/tree/master/shadow-vul-00
https://github.com/smsecgroup/SM-VUL/tree/master/shadow-vul-01
547anintegerunderflowexceptionoccursifthe burnfunctioninthe
parent on line 3 is called.
FunctionConflict: Thesecondpatterndenotessuchcaseswhen
a developer splits functionalities into both parent and child con-
tracts. Let us consider the above example again. Addition to the
totalSupply variable is done only in the child contract by the
mintToken function on line 11 and subtraction from totalSupply
isdoneonlyintheparentcontractbythe burnfunctiononline3.
Thus, burnintheparentupdates totalSupply definedintheparent,
whereas mintToken in the child updates totalSupply defined in the
child, which may lead to unexpected behaviors due to inconsistent
use of totalSupply .
Write Conflict: The third pattern is when a developer updates
onlyoneofthestoragevariablesasshowninthefollowingexample:
1contract Ownable {
2 address public owner;
3 function Ownable() { owner = msg.sender; }
4 function transferOwnership(address newOwner)
5 onlyOwner public { owner = newOwner; }
6}
7contract DadiToken is StandardToken , Ownable {
8 address public owner;
9 function DadiToken (...) { o wner = msg.sender; }
10 }
Theparent Ownableandthechild DadiToken bothhavethestorage
variable named owner. Initially, both variables have the same value
on lines 3 and 9. However, once the transferOwnership function in
the parent gets called, it updates only the ownervariable defined in
the parent leaving ownerdefined in the child intact.
Missing Override: The fourth pattern is when a child contract
overridesonlysomeofitsparent’sfunctionsthatusethestorage
variable defined in both parent and child. Then, the overridden
functions in the child update the storage variable defined in the
child, whereas non-overridden functions update the one defined in
the parent.
SuperCallConflict: Thispatternrepresentscaseswhenachild
contract overrides all of itsparent’s functions that use the storage
variabledefinedinbothparentandchild,andoneoftheoverriding
functions in the child calls an overridden function in the parent
internally.Becausethecalledfunctionintheparentusesthestorage
variable in the parent, such super calls could be confusing.
Override Misunderstanding: The last pattern is due to the
confusionbetweenoverridingandoverloading.Considerthefol-
lowing example:
1contract Crowdsale {
2 uint256 public rate;
3 function transfer(address beneficiary ,
4 uint256 weiAmount) internal
5 { uint256 tokens = weiAmount.mul( rate); }}
6contract CappedCrowdsale is Crowdsale { ... }
7contract EthealNormalSale is CappedCrowdsale ... {
8 uint256 public rate = 700;
9 /// @dev Overriding Crowdsale#transferToken.
10 function transfer(address _beneficiary ,
11 uint256 _weiAmount ,
12 uint256 _time, ...)
13 internal {}}
While the comment on line 9 claims that transfer on lines 10–
13 overrides the function in the parent on lines 3–5, because the
former has more than two parameters and the latter has only twoparameters,theyareoverloadedratherthanoverridden.Asaresult,
a different rateis used depending on which function is called.
Finally, we report the following list of eight security issues that
we found from real-world contracts:
•Confusion of the total amount of tokens: The totalSupply
storagevariableholdsthetotalamountofavailabletokens.Duetoshadowingonsuchavariable,thecalculatedamountofavailable
tokens was wrong.
•Confusion of user balances: Storage variables like balances
and balanceOf holdtokenbalancesoftheirusers.Duetoshadow-
ing on them, the calculated amount of user balances was wrong.
•Confusion of owners: The ownerstorage variable stores the
addressofthecontractowner.Becauseofshadowingon owner,
only one of the storage variables from a parent contract and a
child contract got updated, which led to confusion on owners.
•Referencesofnull contracts: Mostcrowdsalecontractshave
thetokenstoragevariable,whichholdstheaddressoftheERC20
tokencontractimplementation.However,becausethisvariable
wasshadowed,thecorrectaddressofthetokenwasnotavailable.
•Confusionofthetotalamountofcommissionfees: Because
storagevariableslike ratewereshadowed,thecalculatedamount
ofcommissionfeeswasdifferentdependingonwhetheraparent
function or a child function was called.
•Confusionofthesaleduration: Storagevariablessuchas cap
and goaldecidethedurationoftokensales.Becausesuchvari-
ables were shadowed between parent and child contracts, the
functions in the parent and the child had different duration.
•Confusion of the mint duration: Since mintingFinished was
shadowedbetweenparentandchildcontracts,thefunctionsin
the parent and the child had different minting duration.
•Transferofinvalidtokens: The allowedstoragevariableholds
theallowedtokenamounttobetransferred.Sincethisvariable
was shadowed, the transferred amount was different depending
on whether a function from a parent or a child was called.
Notethatweencounteredapossiblymaliciouscontractthatuses
variable shadowing confusion. Consider the following contract:
1contract StandardToken is Token {
2 uint256 public totalFee;
3 function transfer(address to, ...) { ...
4 totalFee = safeAdd (totalFee , Fee); ...
5 } ... }
6contract HawalaToken is StandardToken {
7 uint256 public totalFee;
8 function disperseRewards(address to,
9 uint256 amount) { ...
10 if (totalFee > 0 && totalFee > amount) {
11 totalFee = safeSub (totalFee , amount);
12 balances[to] = safeAdd(balances[to], amount);
13 ... } ... } }
Becausebothparentandchildcontractsdefinethestoragevariable
totalFee,theparentaddsfeestoits totalFee online4,andthechild
subtractssomeamountsfromits totalFee online11aswediscussed
for theFunction Conflict pattern. This behavior is not only unin-
tuitive but possibly malicious. While the disperseRewards function
inHawalaToken distributes rewards only if totalFee is greater than
0, because totalFee indisperseRewards is always 0, users cannot
receive rewards. This behavior from a real-world contract could be
due to a developer’s mistake or an intentional malice, but it clearly
548shows that attackers can utilize the storage variable shadowing
vulnerability to implement malware that look benign.
5.4 Type Casting to Arbitrary Contracts
Solidityallowsexplicitandimplicittypeconversion[ 43],andthe
old Solidity compilers allowed developers to perform bad-casting:
(1)down-casting:conversionofaparentcontracttypetoachild
contract type
(2)unrelated-casting:conversionofacontracttypetoanother
contracttypethatisnotitsparentnoritschildcontracttype
(3)non-contractcasting:conversionofacontracttypetoanon-
contract type
Problemswithbad-castingaretwofold:callingafunctionfroma
wronglyconvertedtypemaycallanunintendedfunction,orsimply
performnooperationwithoutthrowinganyerror,dependingon
the existence of functions with the same name. To alleviate the
problems, the Solidity compiler from v0.4.0 throws an exceptionifan addressassociated withnocode iscalled,and fromv0.5.0 it
disallows down-casting and unrelated-casting. Despite these com-
piler patches, Solidity developers can still make bad-casting by
converting a contract type to addressfirst [44].
Our tool reports bad-casting by a simple type analysis using
def-use and class hierarchy information. We manually checked the
possiblyvulnerablecontractsreportedbythetoolandconfirmed
that864contractshave1,803bad-castingwithoutusingthe address
type as Table 1 shows. We chose 200 contracts in the order ofthe number of total transactions; the total number of their trans-actions is 1,937,026. We manually investigated them to identifyexploitable contracts that have type conversions causing unex-
pectedbehaviorslikecallingabsentfunctions. Ourinvestigation
showed that 114 out of 200 contracts are exploitable, whichamounts to 57.00%. The 114 exploitable contracts consist of33 down-casting, 73 unrelated-casting, and eight both down-castingandunrelated-castingones.Theexploitablecontractsarepopular,becausethetotalnumberoftheirtransactionsis730,820, and 73 contracts have more than 100 token holders.
Among them, we reported one exploitable contract with down-
casting and received one CVE ID for it8.
Whileinvestigatingthem,weobservedtwointerestingpoints.
First, among 200 live contracts, we found that only three contracts
validate whether type conversion results are correct. Consider one
of the example contract with validation:
1contract AuctionStorage is ... {
2 bool public isAuctionStorage = true;
3 ... }
4contract SaleClockAuction is ClockAuction {
5 function SaleClockAuction(address addr, ...) {
6 require(AuctionStorage(addr). isAuctionStorage());
7 ... } ... }
The AuctionStorage contract declares a publicstorage variable
called isAuctionStorage on line 2. Because Solidity generates a
getterfunctionforevery publicstoragevariable,itgeneratesaget-
ter function for isAuctionStorage as well. The SaleClockAuction
function on line 5 takes a parameter named addrof type address.
8https://github.com/smsecgroup/SM-VUL/tree/master/type-vul-00Then, addris converted to AuctionStorage on line 6, and the con-
version result is immediately verified by calling the getter function
ofisAuctionStorage .
Second, even with the Solidity compiler patches to avoid bad-
casting, developers still can perform bad-casting using the address
type. Out of 55,046 live contracts, 21,539 contracts use type con-
version; among 21,539 contracts, only 864contracts perform type
conversionwithoutusing address,andtheremaining20,675con-
tracts, which amounts to 95.99%, use casting with address. Our
investigation implies that instead of validating type conversion re-
sultsinsourcecode,developersrelyoncorrectinputsfromexternal
users, which is an insecure programming style.
5.5 Inheritance Order Confusion
SoliditysupportsmultipleinheritanceusingthereverseoftheC3
linearization order [ 7] to decide which function to call. Unfortu-
nately,alltheSolidityofficialdocumentationreleasedbeforeMay
16,2018wronglystatedthatSolidityusestheC3linearizationorder.
Thisdocumentationerroriscriticalbecauseprogramsemanticsare
differentdependingonwhetherC3linearizationisusedoritsre-
verseisused.IfdevelopersrelyonwhattheSoliditydocumentation
statedandimplementtheircontractswiththestatedsemantics,the
contracts may not operate as what the developers expected. Thus,the Solidity team fixed the documentation in v0.5.0 [40, 42].
Ourtoolreportspotentiallyvulnerablecontractsduetoinher-
itance order confusion when they satisfy all the following three
conditions:1)theyimplementmultipleinheritance,2)morethan
one parent contract have functions with the same signature, and 3)
these parent contracts do not inherit each other. If multiple parent
contracts that do not inherit each other have functions with the
same signature but different semantics, then using C3 linearization
and using its reverse may make different results.
AsTable1shows,thetooldetected475vulnerablecontractsdue
to inheritance order confusion out of 25,417 contracts deployedearlier than May 16, 2018. We manually examined 177 contracts
thathavemorethanorequalto10transactions. Ourinvestigation
showed that only 11 out of 177 contracts may have differentsemantics depending on the use of C3 linearization or its re-verse, which amounts to 6.21%. The total number of transac-tions of 11 contract is 4,336.
During manual investigation, we observed three cases of seman-
tics changes due to the confusion of inheritance order. The firstcase isWrong Token Minting, where different amounts of tokens
were minted because of the different semantics in the functionswith the same signature in different parent contracts. We found
sevencontractsinthiscase.Thesecondcaseis WrongOwnerCheck-
ing, where the results of owner checking were different because
differentobjectswerereferencedinthefunctionsindifferentpar-
ent contracts. We found three contracts in this case. Finally, the
thirdcaseappearedinonlyonecontractis WrongStorageUpdat-
ing. In this case, the functional logic of the functions in different
parent contracts were the same, but they updated different storage
variables due to variable shadowing.
Note that even though our empirical study with contracts avail-
able from Etherscan showed that only 6.21% of the contracts are
vulnerable to inheritance order confusion, this vulnerability can
549happenincomplexcontractsanddetectingitisquitechallenging.
Indeed, such bugs required extensive audits by external auditors
even for one of the renowned blockchain companies [54].
5.6 Uninitialized Storage Pointers
In Solidity, ifdevelopers do not specify the memorykeyword when
they declare local variables of type arraysorstructs, the local
variablesarebydefaultconsideredasstoragepointers,whichare
variablespointingtostoragelocations.Becausestorageisnotdy-
namicallyallocated,storage pointersshouldbe initialized before
being used. If a storage pointer is uninitialized, it points to thestorage slot 0 by default [
46]. This semantics implies that if a de-
veloperwritessomevaluetoanuninitializedstoragepointer,the
value is stored in the first storage variable. Because this semantics
isunintuitive,contractdeveloperscaneasilymakemistakes,which
mayleadtosecurityissues.Asafixtothisvulnerability,starting
fromv0.5.0, theSoliditycompiler throwsan errorifit detectsany
use of uninitialized storage pointers.
Ourtoolreportsuninitializedstoragepointerusesviaasimple
def-useanalysis.Wemanuallycheckedthepossiblyvulnerablecon-
tracts reported by the tool and confirmed that 89 contracts, among
which 32 contracts have more than or equal to 10 transactions, are
vulnerableduetotheuninitializedstoragepointerasTable1shows.
Weconsideredcontractsthatuseuninitializedstoragepointersand
corrupt storage values as exploitable. We found that 19 out of
32 contracts were exploitable, which amounts to 59.38%. Thetotal number of transactions of 19 contracts is 139,951, and11 contracts have more than 100 token holders.
Wereportthreekindsofsecurityissuesduetothisvulnerability.
Pollute winning numbers in storage (Game): Game con-
tracts should generate winning numbers randomly, and rewardusers when they correctly specify the winning numbers. If users
do not specify the winning numbers correctly, the contract owners
getthebettingfee.However,thecodebelowshowsacasewhere
no users can win the play because of uninitialized storage pointers:
1contract CryptoRoulette {
2 uint256 private secretNumber;
3 function play(uint256 number) payable public {
4 require(msg.value >= betPrice && number <= 10);
5 Game game;
6 game.player = msg.sender;
7 game.number = number;
8 if (number == secretNumber) {
9 msg.sender.transfer( this.balance); // win!
10 } ... } }
It generates a secret number and stores it in the secretNumber stor-
agevariabledefinedonline2.Whileitseemstobeabenigncon-
tract, because gameon line 5 is an uninitialized storage pointer,
two assignments of msg.sender andnumberon lines 6—7 store
theminstorage.Itisaserioussecurityissuebecausethevalueof
secretNumber on line 2 is changed to the value of msg.sender
since the uninitialized storage pointer gamepoints to the 0th-index
of storage. Therefore, to win the game, users have to input their
addresses.However,becauseofthe requirestatementonline4,no
onecanwintheplay.Thestatementrequiresthattheuserinputbe
equal or smaller than 10. Since users’ unique addresses are always
greater than 10, the execution terminates on line 4.Pollute dynamically decided storage: Some contracts had
uninitialized storage pointers that point to variables whose values
are dynamically determined at run time by external inputs. For
example, consider the following real-world contract:
1contract EmojiToken is ERC721 {
2 uint256 private startingPrice = 0.001 ether;
3 uint256 private firstStepLimit = 0.063 ether;
4 address public ceoAddress;
5 function createEmojiStory( uint[] parts) public {
6 MemoryHolder storage memD;
7 for (uint i = 0; i < parts.length; i++) { ...
8 memD.bal[parts[i]] = val[parts[i]]) ... ;
9 } memD.used[parts[i]]++;
10 }}
ThecreateEmojiStory functionhasanuninitializedstoragepointer
defined on line 6. Depending on the input value of parts, differ-
ent storage variables can be overwritten. This is a serious secu-rity issue because the values of
partsis controlled by external
users.Allthesensitivestoragevariablessuchas startingPrice ,
firstStepLimit, and ceoAddress can be overwritten.
Pollute other info in storage: We also discovered that some
contracts using uninitialized storage pointers overwrite the follow-
ing sensitive data:
(1)tokens:tokennames,totalsupplytokennumbers,andtoken
balances of users
(2)addresses:ownersofcontractsandaddressesofproxycon-
tracts
(3) sales: duration of sales and refund dates(4)
prices: the maximum profit and the limit level of exchanges
Whilethefollowingcontractreceivedandsentonlyfourtransac-
tions,wereportitbecauseitleverageduninitializedstoragepointers
to perform malicious behaviors:
1contract ETH_ANONIM_TRANSFER {
2 uint256 feePaid;
3 uint256 creatorFee = 0.001 ether;
4 modifier secure {
5 Transfer LogUnit;
6 LogUnit.timeStamp = now;
7 LogUnit.currContractBallance = this.balance;
8 _; }
9 function MakeTransfer(address _adr, uint256 _am)
10 payable secure {
11 creator.send( creatorFee);
12 _adr.send(_am);
13 }}
This contract always gives financial benefits to the owner of the
contract because of the uninitialized storage pointers on lines 5–7.
Because the creatorFee is updated to this.balance , which is the
totalamountofEtherthecontractreserved,the sendfunctionon
line12failssincealltheavailableEtherwassenttotheownerofthecontractonline11.Thefailureon
sendfunctiondoesnotthrowany
exception but just returns false[38]. Hence, the contract owner
alwaysgainsthefinancialprofiteventhe sendfailsonline12.Asthis
exampleillustrates,attackerscanuseuninitializedstoragepointers
tomakemaliciouscontractsthatlookbenign.TheSoliditypatch
cannotpreventsuchmaliciouscontractsasattackerscansimplyuseolderversionsofthecompilertoimplementthemaliciouscontracts.
5505.7 Typo of the +=Operator
Solidityusedtoprovidethe =+operator,butitprohibitstheoperator
fromv0.5.0 becausedevelopersoftenmake mistakesbecauseof it.
This vulnerability is the case where a developer’s intention is to
sum up numbers using the +=operator, but accidentally used =+as
a typo. To avoid such mistakes, the Solidity compiler throws an
error if it detects the =+operator since v0.5.0.
Our tool searched for the =+operator and found four con-
tracts that used the =+operator. All four contracts have more
than or equal to 10 transactions, and we confirmed that they all
implemented the same token named HackerGold :
1function transferFrom(address from, address to,
2 uint256 value) ... {
3 // do the actual transfer
4 balances[ from] -= value;
5 balances[to] =+ value;
6}
Unlike the valid subtraction on line 4, the addition on line 5 shows
thetypoof +=.Suchavulnerabilitycanbeavoidedifdevelopersuses
thelatestcompilersinceitautomaticallypreventsthevulnerability.
5.8 Use of Deprecated Functions
Usingdeprecatedfunctionsmayleadtosecurityissuesespecially
when the functions were deprecated due to security problems. We
inspecteddeprecatedfunctionsinSolidityfromitsreleasenotes[ 13]
and the official documentation [ 46], and found the following six
deprecated functions all deprecated in v0.5.0:
•The callcode functionwasreplacedwith delegatecall because
theimplementationof callcode hadbugssothatitdidnotpre-
serve the correct values of msg.sender and msg.value [41, 49].
•The throwfunctionisreplacedwith revertbecauseitusesupany
remaining gases, whereas revertreturns the remaining gases to
users. [41, 50]
•The block.blockhash function was replaced with blockhash be-
cause its name was misleading [36].
•The msg.gasfunctionwasreplacedwith gasleftbecauseitsname
was misleading [37].
•The sha3functionwasreplacedwith keccak256 becauseitsname
was ambiguous [35].
•The suicidefunctionwasreplacedwith selfdestruct touseless
connotative word [11].
Among55,046contracts,10,782contractsuseddeprecatedfunc-
tions, where only the callcode function can cause a security
issue.Outof10,782contracts,onlyonecontractusesthedep-recated
callcode function. All the other functions are depre-
cated due to their ambiguous and misleading names ratherthan security issues.
6 DISCUSSION
6.1 Recommendations
We give the following recommendations to Solidity developers:
•UsethelatestSoliditycompilertoapplyavailablesecuritypatches,
which resolves several vulnerabilities such as functions without
visibility, the typo of the +=operator, and deprecated functions.•When reusing a standard example contract, update the names
ofboththecontractanditsconstructorcorrectly.Moreover,be
carefulnottomaketyposinconstructornames.Itisalsorisky
to use publicfunctions for initialization.
•Do not use the same name for storage variables in parent and
child contracts. This makes the code complex to understand and
possibly causes security issues as described in this paper.
•Verify type conversion results, and do not use the address type
for conversion because the compiler cannot check bad-casting.
•Becarefulwhenmultipleparentcontractshavefunctionswiththe
samesignature,sincedifferentfunctionsmaybecalleddepending
on whether C3 linearization or its reverse is used.
•Do not use uninitialized storage pointers, which may corrupt
storagevalues.WhilethelatestSoliditycompilerpreventsthis
issue, attackers may leverage uninitialized storage pointers to
implement malicious behavior.
•Use our tool to verify contracts before making them publicly
available.
We give the following recommendations to the Solidity team:
•Release more security patches for known vulnerabilities.
•Improve the patches for constructor misuses and casting to arbi-
trary contracts, because they are not sufficient as we discussed.
6.2 Threats to Validity
Because we manually investigated potentially vulnerable contracts
toidentifydevelopers’mistakes,theresultsmaybesubjectiveto
human who analyzed. To reduce this threat, we performed manual
investigation independently for multiple times. There were no dis-
agreements between the authors in manual analyses because allthedetectedvulnerabilitiesanddevelopers’mistakepatternsare
obvious. Furthermore, because the known vulnerabilities are well-
defined, analyzing them in contracts was straightforward. Also,since we had to inspect only one to three functions per contractthat the tool detected, it reduced possible human errors due to
manual investigation.
Since identifying exploitable contracts simply by inspecting
sourcecodeisdifficult,theresultsmaybedependentonhumanwhoinspected.Tolessenthisthreat,weadditionallyperformeddynamicsimulationusingRemix[
14]forcomplexcontractstodouble-check
whetherthecontractsareexploitable.WealsorequestedCVEIDs
for exploitable contracts to receive external reviews. The eight
CVEsweobtainedsofarrepresentallthevulnerabilitiesintroduced
in this paper.
7 RELATED WORK
Recentworkhasstudiedvarioussecurityvulnerabilitiesinsmart
contracts.Atzeietal . [6]organizedpreviouslyknownvulnerabili-
tiesonEthereumcontracts.Theyreportedvulnerabilitiescaused
by the Solidity language features. We also discussed known vulner-
abilitiesbutwefocusedonthosethatarepatchedbytheSolidity
compiler.Delmolinoetal .[10]reportedcommonmistakesbyunder-
graduatestudentsfromacryptocurrencylaboratorysuchaslogicflaws in cryptography. On the other hand, we studied mistakes of
real-worldSoliditydevelopersduetoSolidityvulnerabilitiesthat
are patched or planned to be patched.
551Todetectvulnerable smartcontracts,researchersstudiedstatic
analysis tools. Luu et al . [27]developed a static analyzer using a
symbolic executor of EVM bytecode. Kalra et al . [23]converted
Solidity contract code to LLVM bitcode and detected potential vul-
nerabilities in contracts by using a symbolic model checker and an
abstractinterpreterdevelopedforLLVMbitcode.Tsankovetal .[51]
developedadomain-specificverifier,whichanalyzesEVMbytecode.
Krupp and Rossow [25]developed an automatic exploit generation
toolforsmartcontracts,Kollurietal .[24]developedETHRACER,
which detects event-ordering bugs in smart contracts, and Nikolić
et al. [29]introduced MAIAN, which applies inter-procedural sym-
bolicanalysistodetectvulnerablecontracts.FerreiraTorresetal .
[17]developed OSIRIS, which uses symbolic execution and taint
analysis to detect integer bugs in smart contracts. Researchers also
have formallyverified smartcontracts. Hirai [21]definedEVM in
alanguagethatcanbecompiledformultipleinteractivetheorem
provers, and Mavridou and Laszka [28]designed and implemented
a formal, finite-state machine for smart contracts. Hildenbrandt
etal.[20]definedthesemanticsofEVMbytecodeintheKframe-
work[33],andGrishchenkoetal .[18]definedacompletesmall-step
semanticsofEVMbytecode.Thesetoolsmayserveasafirmground
forunderstandingandreasoningabouttheSoliditysemantics.How-
ever,noneofthemstudiedeightknownvulnerabilitiesdiscussed
in this paper in detail. Moreover, it is unclear whether such efforts
from academia indeed improved the security of smart contracts in
reality.
8 CONCLUSION
WeconductedanempiricalstudyonSoliditypatchesand55,046live
contracts to understand the current security status of real-world
smart contracts. Our investigation results showed that many Solid-
itydevelopersareunawareoftheimportanceofSoliditypatches.
Wereportedthat98.14%of55,046livecontractsdidnotapplySolid-
ity patches for known vulnerabilities. Furthermore, we discovered
that 13,943 contracts are potentially vulnerable because Solidity
patches arenot adopted.Our manual investigationon potentially
vulnerable contracts in source code level revealed insecure coding
practicesfromdevelopersandlimitationsofsomeoftheSolidity
patches.Wefoundhundredsofexploitablevulnerablecontractsandaboutonefourthofthemareusedbythousandsofpeople.Wehope
that our empirical study results improve the security awareness
of Solidity developers and help them implement secure smart con-
tractsbypreventinginsecurecodingpractices.Finally,ourworkcanbealsohelpfultosecurityexpertsforsecurityauditingofcontracts
and to the Solidity team for improving Solidity.
ACKNOWLEDGEMENTS
We thank Joonyoung Park and Shinhae Kim for their contribution
inimplementingsomepartofthestaticanalysistool.ThisworkwassupportedbyNationalResearchFoundationofKorea(NRF)(GrantsNRF-2017R1A2B3012020and2017M3C4A7068177)andtheInstitute
for Information & communications Technology Promotion(IITP)
grant funded by the Korea government (MSIT) (2018-0-00251).
REFERENCES
[1]2017.Parity Wallet Hacking. Retrieved August 23, 2019 from https://www.
theregister.co.uk/2017/11/10/parity_280m_ethereum_wallet_lockdown_hack[2]2018.TheDAO. RetrievedAugust23,2019fromhttps://en.wikipedia.org/wiki/
The_DAO_(organization)
[3]2018.Ethereum:ASecureDecentralisedGeneralisedTransactionLedger. Retrieved
August 23, 2019 from https://ethereum.github.io/yellowpaper/paper.pdf
[4] 2018. List of DApp. Retrieved August 23, 2019 from https://dappradar.com/
[5]2018.ANext-GenerationSmartContractandDecentralizedApplicationPlatform.
Retrieved August 23,2019 from https://github.com/ethereum/wiki/wiki/White-
Paper
[6]Nicola Atzei, Massimo Bartoletti, and Tiziana Cimoli. 2017. A Survey of Attacks
on Ethereum Smart Contracts (SoK). In In Proceedings of the 6th Principles of
Security and Trust. Springer, 164–186.
[7]KimBarrett,BobCassels,PaulHaahr,DavidAMoon,KeithPlayford,andPTucker
Withington.1996. AMonotonicSuperclassLinearizationforDylan. ACMSIG-
PLAN Notices 31, 10 (1996), 69–82.
[8]Karthikeyan Bhargavan,Antoine Delignat-Lavaud, CédricFournet, AnithaGol-
lamudi, Georges Gonthier, Nadim Kobeissi, Natalia Kulatova, Aseem Rastogi,
Thomas Sibut-Pinote, Nikhil Swamy, and Santiago Zanellai-Béguelin. 2016. For-
mal Verification of Smart Contracts: Short Paper. In Proceedings of the 2016 ACM
Workshop on Programming Languages and Analysis for Security. ACM, 91–96.
[9]ConsenSys. 2016. Token.sol. Retrieved August 07, 2019 from https://github.com/
ConsenSys/Token-Factory/blob/master/contracts/Token.sol
[10]Kevin Delmolino, Mitchell Arnett, Ahmed Kosba, Andrew Miller, and Elaine Shi.
2016. StepbyStepTowardsCreatingASafeSmartContract:LessonsandInsights
From a Cryptocurrency Lab. In In Proceedings of the 2016 Financial Cryptography
and Data Security. Springer, 79–94.
[11]Ethereum EIPs. 2015. Renaming SUICIDE Opcode. Retrieved August 04, 2019
from https://github.com/ethereum/EIPs/blob/master/EIPS/eip-6.md
[12]Ethereum EIPs. 2019. EIP-1470: Smart Contract Weakness Classification (SWC).
Retrieved April 24, 2019 from https://github.com/ethereum/EIPs/issues/1469
[13]Ethereum.2019. ReleaseNotesofSolidityCompiler. RetrievedApril24,2019from
https://github.com/ethereum/solidity/releases
[14]Ethereum. 2019. Remix. Retrieved July 29, 2019 from https://github.com/
ethereum/remix
[15]Ethereum. 2019. TokenERC20 Example. Retrieved August 16, 2019 from https:
//github.com/ethereum/ethereum-org/blob/master/solidity/token-erc20.sol
[16]Etherscan. 2019. Etherscan. Retrieved July 3, 2019 from https://insights.
stackoverflow.com/survey/2019
[17]Christof FerreiraTorres, JulianSchütte,and RaduState. 2018. OSIRIS:Hunting
forIntegerBugsinEthereumSmartContracts.In InProceedingsof34thAnnual
Computer Security Applications Conference (ACSAC’18), San Juan, Puerto Rico,
USA, December 3-7, 2018.
[18]Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. 2018. A Semantic
Framework for the Security Analysis of Ethereum Smart Contracts. In In Pro-
ceedings of the 7th Principles of Security and Trust. Springer, 243–269.
[19]NCCGroup.2019. TheDecentralizedApplicationSecurityProject. RetrievedApril
24, 2019 from https://dasp.co
[20]EverettHildenbrandt, ManasviSaxena, XiaoranZhu, NishantRodrigues, Philip
Daian,Dwight Guth,andGrigoreRosu.2017. Kevm: ACompleteSemanticsofthe
Ethereum Virtual Machine. Technical Report.
[21]YoichiHirai.2017. DefiningtheEthereumVirtualMachineforInteractiveThe-
orem Provers. In In Proceedings of the 2017 Financial Cryptography and Data
Security. Springer International Publishing, 520–535.
[22]Yajin Zhou Xuxian Jiang and Zhou Xuxian. 2013. Detecting Passive Content
LeaksandPollutioninAndroidApplications.In InProceedingsofthe20thNetwork
and Distributed System Security Symposium (NDSS).
[23]Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. 2018. ZEUS:
AnalyzingSafetyofSmartContracts.InProceedingsofthe25thNetworkand
Distributed System Security Symposium (NDSS).
[24]AashishKolluri,IvicaNikolic, IlyaSergey, AquinasHobor, andPrateekSaxena.
2019. Exploiting the Laws of Order in Smart Contracts. In Proceedings of the 28th
ACM SIGSOFT International Symposium on Software Testing and Analysis. ACM,
363–373.
[25]Johannes Krupp and Christian Rossow. 2018. teEther: Gnawing at Ethereum
toAutomaticallyExploitSmartContracts.In InProceedingsofthe27thUSENIX
Security Symposium (USENIX Security 18). Baltimore, MD: USENIX Association.
[26]V.I.Levenshtein.1966. BinaryCodesCapableofCorrectingDeletions,Insertions
and Reversals. Soviet Physics Doklady 10 (Feb. 1966), 707.
[27]LoiLuu,Duc-HiepChu,HrishiOlickel,PrateekSaxena,andAquinasHobor.2016.
Making Smart Contracts Smarter. In In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security. ACM, 254–269.
[28]Anastasia Mavridouand AronLaszka. 2018. Designing SecureEthereum Smart
Contracts: A Finite State Machine Based Approach. In In Proceedings of the 22nd
Financial Cryptography and Data Security. Springer International Publishing.
[29]IvicaNikolić, AashishKolluri, IlyaSergey, PrateekSaxena,and AquinasHobor.
2018. Finding the Greedy, Prodigal, and Suicidal Contracts at Scale. In In Pro-
ceedings of the 34th Annual Computer Security Applications Conference. ACM,
653–663.
552[30]OpenZeppelin. 2019. OpenZeppelin. Retrieved August 16, 2019 from https:
//openzeppelin.com/
[31]OpenZeppelin. 2019. SimpleToken Example. Retrieved August 16, 2019
from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/
eda63c75c45e96e10d3fc188f717c8e7be64d420/contracts/examples/SimpleToken.
sol
[32]OWASP.2019. TestingforRaceConditions. RetrievedAugust07,2019fromhttps:
//www.owasp.org/index.php/Testing_for_Race_Conditions_(OWASP-AT-010)
[33]GrigoreRoşuandTraianFlorinŞerbănuţă.2010. AnOverviewoftheKSemantic
Framework. Journal of Logic and Algebraic Programming 79, 6 (2010), 397–434.
[34]Ilya Sergey and Aquinas Hobor. 2017. A Concurrent Perspective on Smart
Contracts. In In Proceedings of the 21th Financial Cryptography and Data Security.
Springer, 478–493.
[35]Solidity.2016. AliasANewNametotheSHA3Opcode. RetrievedAugust04,2019
from https://github.com/ethereum/solidity/issues/363
[36]Solidity.2017. Moveblockhashfromblock.blockhashtoGlobalLevel. Retrieved
August 04, 2019 from https://github.com/ethereum/solidity/issues/2970
[37]Solidity. 2017. Move msg.gas to Global Level As gasleft(). Retrieved August 04,
2019 from https://github.com/ethereum/solidity/issues/2971
[38]Solidity.2018. LowLevelOperations:sendFunction. RetrievedAugust07,2019
from https://solidity.readthedocs.io/en/v0.5.7/control-structures.html?highlight=
send#error-handling-assert-require-revert-and-exceptions
[39]Solidity. 2018. Solidity Documentation : Self-destruct. Retrieved January 06, 2020
fromhttps://solidity.readthedocs.io/en/v0.4.25/introduction-to-smart-contracts.
html?highlight=destruct
[40]Solidity.2018. SolidityMultipleInheritanceResolution. RetrievedAugust03,2019
from https://github.com/ethereum/solidity/issues/3856
[41]Solidity.2018. SolidityOfficialDocumentation:BreakChanges. RetrievedAugust
22, 2019 from https://solidity.readthedocs.io/en/v0.5.7/050-breaking-changes.
html#
[42]Solidity. 2018. Solidity Official Documentation : C3 Linearization. Retrieved
August 17, 2019 from https://solidity.readthedocs.io/en/v0.5.0/contracts.html?highlight=c3%20linearization#inheritance
[43]Solidity. 2018. Type Conversion. Retrieved August 07, 2019 from
https://solidity.readthedocs.io/en/v0.5.7/types.html?highlight=conversion#
conversions-between-elementary-types
[44]Solidity.2018. TypeConversionWorkAround. RetrievedAugust07,2019from
https://solidity.readthedocs.io/en/v0.5.7/050-breaking-changes.html
[45]Solidity. 2019. Ethereum Smart ContractBest Practices. Retrieved April 24,2019
from https://consensys.github.io/smart-contract-best-practices/known_attacks/
[46]Solidity. 2019. Official Solidity Documentation. Retrieved April 24, 2019 from
https://solidity.readthedocs.io/en/v0.5.7/
[47]Solidity.2019. ShadowingofInheritedStateVariablesShouldBeAnError. Retrieved
July 07, 2019 from https://github.com/ethereum/solidity/issues/2563
[48]Solidity. 2019. Smart Contract Weakness Classification and Test Cases. Retrieved
April 24, 2019 from https://smartcontractsecurity.github.io/SWC-registry/
[49]Ethereum StackExchange. 2016. Difference Between CALL, CALLCODE and DEL-
EGATECALL. RetrievedAugust22,2019fromhttps://ethereum.stackexchange.
com/questions/3667/difference-between-call-callcode-and-delegatecall
[50]EthereumStackExchange.2017. WhyDo‘throw‘and‘revert()‘CreateDifferent
Bytecodes? Retrieved August 22, 2019 from https://ethereum.stackexchange.
com/questions/20978/why-do-throw-and-revert-create-different-bytecodes
[51]Petar Tsankov, Andrei Dan, Dana Drachsler-Cohen, Arthur Gervais, Florian
Buenzli, andMartin Vechev. 2018. Securify:Practical security analysis ofsmart
contracts. In In Proceedings of the 25th ACM SIGSAC Conference on Computer and
Communications Security. ACM, 67–82.
[52]RobertAWagnerandMichaelJFischer.1974. TheString-to-StringCorrection
Problem. Journal of the ACM (JACM) 21, 1 (1974), 168–173.
[53]Zeppelin-Solidity. 2017. Ownable.sol. Retrieved August 07, 2019 from
https://github.com/aragon/zeppelin-solidity/blob/master/contracts/ownership/
Ownable.sol
[54]Qi Zhou. 2018. QuarkChain: Issues Due to the Inheritance Order. Personal
communication.
553