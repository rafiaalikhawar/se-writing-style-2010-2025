SymTuner: Maximizing the Power of Symbolic Execution by
Adaptively Tuning External Parameters
Sooyoung Cha
Sungkyunkwan University
Republic of Korea
sooyoung.cha@skku.eduMyungho Lee
Korea University
Republic of Korea
myungho_lee@korea.ac.krSeokhyun Lee
Korea University
Republic of Korea
seokhyunlee@korea.ac.krHakjoo Ohâˆ—
Korea University
Republic of Korea
hakjoo_oh@korea.ac.kr
ABSTRACT
We present SymTuner , a novel technique to automatically tune
externalparametersofsymbolicexecution.Practicalsymbolicex-
ecution tools have important external parameters (e.g., symbolic
arguments, seed input) that critically affect their performance. Due
tothehugeparameterspace,however,manuallycustomizingthose
parameters is notoriously difficult even for experts. As a conse-quence, symbolic execution tools have typically been used in a
suboptimalmannerthat,forexample,simplyreliesonthedefault
parametersettingsofthetoolsandlosestheopportunityforbet-
terperformance.Inthispaper,weaimtochangethissituationby
automatically configuring symbolic execution parameters. With
SymTuner that takes parameter spaces to be tuned, symbolic ex-
ecutors are run without manual parameter configurations; instead,
appropriate parameter values are learned and adjusted during sym-
bolicexecution.Toachievethis,wepresentalearningalgorithm
thatobservesthebehaviorofsymbolicexecutionandaccordingly
updatesthesamplingprobabilityofeachparameterspace.Weeval-
uatedSymTunerwithKLEEon12open-sourceCprograms.The
resultsshowthatSymTunerincreasesbranchcoverageofKLEEby
56%onaverageandfinds8morebugsthanKLEEwithitsdefault
parameters over the latest releases of the programs.
ACM Reference Format:
SooyoungCha,MyunghoLee,SeokhyunLee,andHakjooOh.2022.Sym-
Tuner:MaximizingthePowerofSymbolicExecutionbyAdaptivelyTuning
External Parameters. In 44th International Conference on Software Engineer-
ing(ICSEâ€™22),May21â€“29,2022,Pittsburgh,PA,USA. ACM,NewYork,NY,
USA, 12 pages. https://doi.org/10.1145/3510003.3510185
1 INTRODUCTION
Decadesofresearchhavetransformedsymbolicexecutionintoa
mainstreamtechniqueinsoftwaretesting.Thebasicideaofsym-
bolic execution is to replace program inputs by symbolic variables
andexploretheexecutionpathsofaprogramsymbolically.Sinceitsinception[
7,32,41],symbolicexecutionhasbeenanactiveresearch
area[5].Inparticular,thelastdecadehasseenremarkableadvances,
significantly mitigating main challenges such as path explosion
âˆ—Corresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510185$ klee --simplify-sym-indices --max-memory=1000 --optimize
--use-forked-solver --use-cex-cache --external-calls=all
--max-sym-array-size=4096 --max-instruction-time=30s--max-time=60min --max-memory-inhibit=false--max-static-fork-pct=1 --max-static-solve-pct=1--max-static-cpfork-pct=1 --switch-type=internal--search=random-path --search=nurs:covnew--batch-instructions=10000 ./pgm.bc --sym-args011 0--sym-args022--sym-files 1 8 --sym-stdin 8 --sym-stdout ...
Figure 1: The parameter setting of KLEE used in [49]
and constraint solving [ 6,14,23,34,36,38,39,45,48,52,54,66].
Equipped withthese techniques, symbolic executiontools such as
KLEE [11] have become publicly available and widely used in both
academia and industry [12, 13].
Despitetheprogress,however,maximizingtheperformanceof
modernsymbolicexecutiontoolsisnotoriouslydifficultinpractice.
Onemainreasonisthatstate-of-the-artsymbolicexecutorshave
a number of important external parameters that critically affect
theireffectiveness.Forexample,Figure1showsatypicalcommand
for running KLEE, which was tailored to GNU Coreutils by the
originalauthorsofKLEE[ 11,49].Theseparameters,forexample,
aretoselectwhichsearchstrategytouse,todecidethesymbolic
arguments,andtochoosethememorybudget.Itiswell-knownthat
these parameters have a huge impact on the runtime performance
of symbolic execution and therefore must be carefully tuned for
each target program [45, 60, 63].
Manuallytuningsuchparametersischallengingevenforexperts.
Note that more than half of the parameters in Figure 1 are of non-
booleantypes(e.g.,stringorinteger),andtheircombinationinduces
an enormous search space. Consequently, KLEE has typically been
used without proper configuration of those parameters; existing
workseither(1)simplyrelyontheparametersettinginFigure1[ 17,
18,23,50,63](evenforprogramsbeyondCoreutils)or(2)manually
tunespecificparameters(e.g.,symbolicarguments)atopthedefault
parametervalues[ 37,45,52,60,66].Recently,afewtechniques[ 14,
16] have been proposed for tuning search heuristics automatically
but other critical parameters still need to be configured manually.
In this paper, we present SymTuner , a novel technique for auto-
matically tuning symbolic execution parameters. Initially, from the
users,SymTuner takes as input the sample spaces for the parame-
terstobetuned.Then,with SymTuner ,symbolicexecutiontools
such as KLEE can be run without manual parameter tuning; appro-
priateparametervaluesforthetargetprogramareautomatically
adjusted by SymTuner during symbolic execution. To do so, along
20682022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Sooyoung Cha, Myungho Lee, Seokhyun Lee, and Hakjoo Oh
the symbolic execution process, SymTuner uses a custom learning
algorithmthatrepeatedlysamplesasetofparametervaluesfrom
thesamplespaces,evaluatestheperformanceofsymbolicexecution
withthesampledvalues,andrefinestheprobabilitydistributions
of the sample spaces based on the evaluation result.
ExperimentalresultsshowthatSymTunerremarkablyenhances
symbolicexecutionintermsofbothcodecoverageandbug-finding.
We applied SymTuner to KLEE [ 11], a representative symbolic ex-
ecution tool for C programs, and evaluated it on the latest versions
of12GNUopen-sourceprograms(rangingfrom5Kto161KLoC).
KLEE with SymTuner covered 56%and 31% morebranches on av-
erage than conventional KLEE with its default parameter values
andtheparametersettinginFigure1,respectively.Also, SymTuner
enabled KLEE to discover 11 different bugs that cause the latest
versionsoftheopen-sourceprogramstocrash,faroutweighingthe
conventionalKLEEthatendedupfindingthreeofthem.Compared
to KLEE with anaive approach that randomly samples parameter
values, SymTuner succeeded in increasing the number of covered
branches and found bugs by 12% and 45%, respectively. We also
show that our approach is also applicable to CREST [ 21], a tool for
concolictesting[ 13,25,53],anothermajorapproachofsymbolic
execution.
Contributions. We summarize our contributions below:
â€¢We present SymTuner , a new technique for automatically
tuningdiverseparametersofsymbolicexecution.Thekey
technicalcontributionis thedomain-specificlearningalgo-
rithm for symbolic execution, which observes the behavior
ofsymbolicexecutionwithrandomlysampledparameters
and gradually learns to sample effective parameter values.
â€¢Weconductextensiveevaluationof SymTuner on12GNU
open-source programs. We make our tool, SymTuner , open-
sourced and the benchmarks publicly available.1
2 PRELIMINARIES
2.1 Basic Symbolic Execution
Symbolic execution explores the execution paths of a program
by maintaining a set of program states, where a state is a triplet
(instr,store,Î¦)of an instruction ( instr) to be executed, a symbolic
memorystore( store)mappingprogramvariablestosymbolicvalues,
andapathcondition(Î¦ )thatisasequenceofsymbolicbranches
representing the path exercised by the current state.
Algorithm1describestheoverallalgorithm.Ittakesasinputa
program( pgm),atestingbudget( budget),andavectorofparameter
values (V ). For the moment, let us ignore the last input; the role of
the parameters (V ) will be described in Section 2.2.
At line 2, the algorithm creates the set of initial states, i.e., a
singleton set of the initial state s0=(instr0,store0,true), where
instr0denotes the first instruction of the program and store0is the
initialsymbolicmemory.Theset ğ‘‡oftestcasesisinitiallyempty
(line3).Afterinitializing ğ‘†andğ‘‡,symbolicexecutiongoesintothe
loop at lines 4â€“15.
At line 5, symbolic execution selects a state sfromğ‘†to navi-
gate deeper into the program, and removes sfromğ‘†(line 6). At
line7,theinstructioninthecurrentstate (instr,store,Î¦)isexecuted,
1SymTuner: https://github.com/skkusal/symtunerAlgorithm 1 Symbolic execution
Input:Program (pgm ), budget (budget ), and parameter values (V ).
Output: A set of test cases ( ğ‘‡)
1:procedure SymExecutor(pgm ,budget,V)
2:ğ‘†â†{s0} âŠ²s0=(instr0,store0,true)
3:ğ‘‡â†âˆ… âŠ²test cases
4:repeat
5: sâ†Choose(ğ‘†) âŠ²s=(instr,store,Î¦)
6: ğ‘†â†ğ‘†\{s}
7: s/primeâ†Execute(s) âŠ²s/prime=(instr/prime,store/prime,Î¦)
8: ifinstr/primeis a branch whose condition is ğœ™then
9: ifSAT(Î¦âˆ§ğœ™)then âŠ²true branch is reachable
10: ğ‘†â†ğ‘†âˆª{(instr1,store/prime,Î¦âˆ§ğœ™)}
11: ifSAT(Î¦âˆ§Â¬ğœ™)then âŠ²false branch is reachable
12: ğ‘†â†ğ‘†âˆª{(instr2,store/prime,Î¦âˆ§Â¬ğœ™)}
13: else ifinstr/primeis a halt instruction then
14: ğ‘‡â†ğ‘‡âˆª{Model(Î¦)} âŠ²generate a test case
15:untilbudgetexpires (or ğ‘†=âˆ…)
16:returnğ‘‡
producing the next state (instr/prime,store/prime,Î¦).I finstr/primeis a branch in-
struction whosecondition is ğœ™, thealgorithm checkswhether the
both sides of the branch are reachable from the current state. If thetruebranchisreachable(i.e.,
SAT(Î¦âˆ§ğœ™)),weaddtheupdatedstate
(instr1,store/prime,Î¦âˆ§ğœ™)toğ‘†(line 10), where instr1denotes the first
instruction in the true branch. Similarly, we add the updated state
for the false branch to ğ‘†when the path condition, i.e., (Î¦âˆ§Â¬ğœ™),
issatisfiable(line12).When instr/primeisahaltinstruction(line13),a
test case is generated from the model of the current path condition.
TheSymExecutor procedurerepeatsthe processdescribedsofar
untilthegivenbudgetexpires.Upontermination,theset ğ‘‡oftest
cases is returned.
2.2 Parameters of Symbolic Execution
Although the basic algorithm is simple, real-world symbolic execu-
tiontoolsinvolvevariousparametersthathaveacriticalimpacton
the performance of Algorithm 1. For example, symbolic executors
suchasKLEE[ 11]takeaparameterthatdetermineswhichprogram
inputs to be replaced by symbolic variables (e.g., --sym-args in
Figure 1); in Algorithm 1, the initial symbolic memory ( store0)i s
defined by this parameter value. Another example is a parame-ter that specifies the maximum memory capacity available (e.g.,
--max-memory inFigure1),whichisanimportantfactorinpractice
asstateexplosionfrequentlyoccurswhenrunningsymbolicexecu-tiononsizableprograms.The
Choosefunctionitselfatline5isalso
a parameter, called search heuristic [ 14,45,54], and users of KLEE
canchoosefrom10differentoptions(e.g., --search=nurs:covnew
in Figure 1) and interleave them. The constraint solver used bythe
SATandModelfunctions in Algorithm 1 can be configured
as well; for example, users can decide which SMT solver to useand fine-tune their behavior. Figure 1 shows that KLEE also pro-
videsvariousparameters,including max-instruction-time and
batching-instructions, which have a large space (e.g., integer).
Manually tuningthose parametervalues is sonontrivial that it
hasbeentypicaltousesymbolicexecutionwithoutproperconfigu-
ration [17,18,23,45,50,52,60,63,66]. The goal of this paper is to
2069
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SymTuner: Maximizing the Power of Symbolic Execution by Adaptively Tuning External Parameters ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
	



 
  
Figure 2: Overview of symbolic execution with SymTuner
change this unfortunate practice by automating the task of tuning
parameters of symbolic execution.
3 OUR APPROACH
Figure2illustrateshow SymTuner andsymbolicexecutioninteract.
Initially,SymTuner takeskpredefinedparameterspacesasinput,
where a parameter space prescribes possible values that the param-
eter can take on. At a high-level, SymTuner iteratively samples
kparametervalues basedon thelearned probabilitydistributions
of the parameter spaces, and runs symbolic execution with the
sampled parameter values. As output of symbolic execution,a set
of test cases is generated, which is in turn used for adjusting the
probability distributions of the sampling spaces. During the first
few times, SymTuner focuses on exploration by running symbolic
executionwithvariousrandomparametervalues.Onceanadequate
number of test cases is collected, SymTuner starts to update the
sampling probabilities and exploit the learned knowledge.
SymTuner worksinthreephases: Evaluate,Extract,andUpdate.
Thefirststepproduceslearningdatabyevaluatingthequalityof
the parameter values used for generating each test case in terms
of both code coverage and found bugs. The aim of the second step
(Extract) is to identify meaningful data from the total amount of
datageneratedbythefirststep.Usingtheextracteddata,thelast
step(Update)updatestheprobabilityofhow SymTuner samples
fromtheğ‘˜parameterspaces.Byrepeatingtheaboveprocesswhich
interleaves SymTuner and symbolic executor, the sampling proba-
bilitiesaregraduallyupdated.Upontermination(i.e.,hittingatime
limit), the set of all test cases generated so far are returned.
3.1 Parameter Space
Basically,wedefinethesamplespaceofeachparametertobedis-
crete rather than continuous to circumvent unnecessarily large
searchspace.Forinstance,supposethatwedefinetheparameter
spaceformemorybudget(MB)asallintegersbetween100and2000.
Onthebasisofaparametervalue,e.g.,1000MB,inthespace,the
adjacent values such as 999MB and 1001MB are unlikely to have asignificant impact on the performance of symbolic execution com-
pared to the farther values (e.g., 500MB, 2000MB); thus, our sample
space for each parameter is discrete to maintain only the values
which are likely to affect performance.
In our approach, we assume that ğ‘˜predefined parameter spaces,
denoted S=S1Ã—S2Ã—Â·Â·Â·Ã—Sğ‘˜,aregiven.Eachspace Sğ‘–(1â‰¤ğ‘–â‰¤ğ‘˜)
for theğ‘–-th parameter consists of two components:
Sğ‘–=(SVğ‘–,ğœ‚max
ğ‘–)whereSVğ‘–={sv1
ğ‘–,sv2
ğ‘–,Â·Â·Â·,svğ‘›
ğ‘–}is the set of possible parameter
valuesfor Sğ‘–andğœ‚max
ğ‘–denotesthemaximumnumberoftimesto
samplefromtheset SVğ‘–.Formostparameterspaces, ğœ‚maxis1as
aparametervalueistypicallyusedonlyonceduringasinglerun
of symbolic execution (e.g., --max-memory in Figure 1). In general,
however, it can be bigger than 1. For example, the value of ğœ‚max
for symbolic arguments can be any natural number as we can use
multiple symbolic arguments with different size in a single run
(e.g.,--sym-args in Figure 1). For instance, the parameter space
for symbolic arguments can be given as follows:
Sargs=({2,4,6,8},3).
which means we can select up to three symbolic arguments, where
each argument has the length of one of the elements in {2,4,6,8}.
3.1.1 Sample. To sample from each predefined space Sğ‘–, let us
define and use the following Samplefunction:
Sample(Sğ‘–,Pc
ğ‘–,Pğ‘–)=PVğ‘–
The inputs are a parameter space Sğ‘–and two probability functions,
Pğ‘–andPc
ğ‘–. The former Pğ‘–:SVğ‘–â†’[0,1]denotes the sampling
probability of each parameter value in SVğ‘–and the latter Pc
ğ‘–:
[1,ğœ‚max
ğ‘–]â†’[0,1]representstheprobabilityforthesamplingtimes.
Wedenotetheoutputof SamplebyPVğ‘–âˆˆâ„˜(SVğ‘–),whichisaset
ofsampledparametervalues.Here,weallow PVğ‘–tobeamultiset
that has duplicated elements and we abuse the notation â„˜(SVğ‘–)
to denote the set of all sub-multisets of SVğ‘–. To obtain PVğ‘–from
the space Sğ‘–, theSamplefunction first determines the number m
of sampling times based on the probability Pc
ğ‘–. Then, we sample a
candidate value from SVğ‘–formtimes using the probability Pğ‘–and
addthevalueto PVğ‘–.Forinstance,whenthe Samplefunctiontakes
theparameterspace Sargsshownabove,thepossibleoutcomesof
Sample, i.e., PVargs, are as follows:
{{2}},{{6}},{{8,6}},{{4,8}},{{2,4,2}},{{4,4,4}},Â·Â·Â·
where{{ }}denotes a multiset that allows duplicated elements.
Sincethetwoprobabilitiesinthe Samplefunctiondeterminethe
parametervaluesusedwhenperformingsymbolicexecutiononthe
target program, the most important question is how to learn these
probabilities, Pc
ğ‘–andPğ‘–, for each parameter space Sğ‘–(1â‰¤ğ‘–â‰¤ğ‘˜)t o
maximizetheperformanceofsymbolicexecution.Toresolvethis,
SymTuner learnsthoseprobabilitiesbasedonthedataaccumulated
during symbolic execution.
3.2 Symbolic Execution with SymTuner
Tolearnparametervalues,weperformsymbolicexecutionmultiple
times with diverse parameter values by dividing the total time
budget into smaller budgets. It enables SymTuner to interact with
symbolic executor multiple times during the given time budget,
and to gradually find more effective parameter values through the
multipleinteractions.Wedescribehow SymTuner interactswith
symbolic executor (Algorithm 2) in detail.
Algorithm2takesasinputaprogram,abudget,and kpredefined
parameter spaces. At lines 1, the algorithm first initializes each
of the following four components to an empty set or vector: the
vectorVâˆˆâ„˜(SV1)Ã—â„˜(SV2)Ã—Â·Â·Â·Ã— â„˜(SVğ‘˜)ofparametervalues
(recall â„˜(SVğ‘–)denotes the set of all sub-multisets of SVğ‘–), the set
Dof learning data, the set ğ‘‡of test cases, and the set TotalTof
2070
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Sooyoung Cha, Myungho Lee, Seokhyun Lee, and Hakjoo Oh
Algorithm 2 Symbolic execution with SymTuner
Input:Program (pgm ), budget (budget), kparameter spaces (S).
Output: Test cases (TotalT )
1:/angbracketleftV,D,ğ‘‡,TotalT/angbracketrightâ†/angbracketleft/angbracketleft /angbracketright,âˆ…,âˆ…,âˆ…/angbracketright âŠ²Dis learning data
2:flagâ†0
3:budgetsâ†budgetâˆ—ğœ‚ratio âŠ²ğœ‚ratio= 0.5%
4:repeat
5:forğ‘–=1toğœ‚stepdo âŠ²ğœ‚step=2 0
6: V,Dâ†SymTuner (ğ‘‡,S,V,D,flag)
7: ğ‘‡â†SymExecutor (pgm,budgets,V)
8: TotalTâ†TotalTâˆªğ‘‡
9:flagâ†1
10:budgetsâ†budgetsâˆ—2
11:untilbudgetexpires
12:returnTotalT
accumulated test cases. Then, the flagvalue is also initially set to 0
(line 2); the value of 0 makes SymTuner focus only on exploration
bytryingdiverseparametervaluesinthe kparameterspaces.At
thenextline,thealgorithminitializesthetimebudget budgetsfor
a single run of symbolic execution by multiplying the total testing
budgetbudgetand the hyper-parameter ğœ‚ratio. In the experiments,
we set the hyper-parameter ğœ‚ratioto a small value such as 0.005.
Atlines5â€“10,symbolicexecutorand SymTuner iterativelyinter-
act with each other by exchanging test cases and parameter values.
At line 6, SymTuner takes five input valuesâ€”test cases ( ğ‘‡), param-
eterspaces( S),previouslyusedparametervalues(V ),learningdata
(D),andflag( flag)â€”andreturnsaccumulatedlearningdatawith
newly sampled parameter values; at first, SymTuner generates the
parametervaluesbyrandomlysamplingfromthepredefinedspaces
S(line 6). Then, the SymExecutor is run with the program, the
currenttimebudget,andthenewparametervalues.Asoutputof
symbolic execution, a set ğ‘‡of test cases is produced (line 7). At
line8,weaccumulate ğ‘‡intheset TotalToftotaltestcases.Afterthe
firstinteractionbetween SymTuner andSymExecutor isrepeated
ğœ‚steptimes (lines 5â€“8), the algorithm sets flagto 1, which indicates
thatSymTuner isreadytoperformonlinelearning.Inexperiments,
wesetğœ‚step=20.Atline10,itdoublesthesizeofthetimebudget
budgetsas more learning data accumulation increases the confi-
denceinhowtotuneparametervalues.Theouterlooprepeatsuntil
the total time budget ( budget) is exhausted. Upon termination, the
algorithm returns as the final output the accumulated test cases.
3.3 SymTuner
Algorithm 3 describes how SymTuner generates the set Dof learn-
ing data from the set ğ‘‡of test cases and how it updates the sam-
pling probabilities of the parameter spaces based on D.SymTuner
worksinthethreesteps: Evaluate,Extract,andUpdate.Aftergoing
throughthesethreesteps,itreturnsasoutputthevector V/primeofnew
parameter values and D.
3.3.1 Evaluate. Thegoalofthefirststepistoevaluatethequality
oftheparametervector Vusedforgeneratingthetestcases ğ‘‡in
terms of code coverage and detected bugs. To this end, SymTuner
generates data dfor each test case tâˆˆğ‘‡(lines 3â€“4).
A single data dis represented by the quadruple (Br, Bu,t,V),
whereBrandBuarethesetsofbranchescoveredandbugstriggeredAlgorithm 3 SymTuner
Input:Test cases ( ğ‘‡), spaces (S), values (V ), data (D), flag (flag )
Output: New parameter values (V/prime) and Data (D )
1:procedure SymTuner( ğ‘‡,S,V,D,flag)
2:/* Step 1: Evaluate the quality of test cases */
3:for each tâˆˆğ‘‡do
4: Dâ†Dâˆª{ğ‘‘} âŠ²ğ‘‘=Evaluate(t,V)
5:
6:/* Step 2: Extract effective parameter values from data D*/
7:CoreV,TotalVâ†Extract(D)
8:9:
/* Step 3: Update sampling probabilities */
10:policyâ†sample from {Exploit,Explore}with prob=[ ğ›¼,1 -ğ›¼]
11:V/primeâ†/angbracketleft /angbracketright
12:forğ‘–=1toğ‘˜do âŠ²S=S1Ã—S2Ã—Â·Â·Â·Ã—Sğ‘˜
13: if(policy =Explore)or(flag=0)then
14: (Pc
i,Pi)â†Explore(TotalV,Si)
15: else
16: (Pc
i,Pi)â†Exploit(CoreV,TotalV,Si)
17: PVğ‘–â†Sample(Si,Pc
i,Pi)
18: V/primeâ†V/primeÂ·PVğ‘– âŠ²AppendPVğ‘–at the end of V/prime
19:returnV/prime,D
by the test case t, respectively. We identify a bug with an error
location, a pair of the function name and the line number (e.g.,
(foo,3)). To obtain the two sets, BrandBu, theEvaluate function at
line 4 executes the program with each test case tand performs a
coverage analysis (e.g., using gcov). The Evaluate function takes as
inputasingletestcase tandavector Vofusedparametervalues,
and returns data das output. SymTuner collects all data in D.
3.3.2 Extract. AfterSymTuner obtainstheset Dofdata,itmoves
ontothenextstep, Extract,whereitextractsaslearningdatatwo
sets,CoreVandTotalV, of parameter value vectors from CoreD
andD, respectively. Intuitively, the set CoreDincludes only core
elements of D, which we define as the smallest subset of Dthat
covers allbranches andall bugs in D. Toconstruct CoreD, wefirst
compute the set Dâˆ—:
Dâˆ—=argmax
D/primeâŠ†D|/uniondisplay.1
(Br,Bu,_,_)âˆˆD/prime(Br/unionmultiBu)|.
where â€œargmaxâ€ denotes the set of all possible arguments which
maximizethegivenobjective(e.g.,thenumberofcoveredbranches
and detected bugs) and /unionmultidenotes the disjoint union. From the
setDâˆ—, we define the set CoreDto be the smallest one in Dâˆ—, i.e.,
CoreD =argminD/primeâˆˆDâˆ—|D/prime|(here we assume â€œargminâ€ returns an
arbitrarysingleargumentthatminimizesthegivenobjective).In
otherwords, CoreDrepresentstheminimumsubsetof Dthatcollec-
tively maximizes the number of covered branches and found bugs.
For instance, suppose that the data Dhas four elements:
D={({b1,b2,b5},âˆ…,_,_),({b5},{(foo,3)},_,_),
({b1,b2,b3,b4},âˆ…,_,_),({b2,b3,b4},âˆ…,_,_)}
whereeachelementin Dconsistsofaquadrupleofasetofcovered
branches,asetofbugs,atestcase,andavectorofparametervalues.
From the set D, we can extract CoreDas:
CoreD ={({b5},{(foo,3)},_,_),({b1,b2,b3,b4},âˆ…,_,_)}.
2071
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SymTuner: Maximizing the Power of Symbolic Execution by Adaptively Tuning External Parameters ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Calculating CoreDcorrespondstosolvingthesetcoverproblem[ 40],
whichis awell-known NP-completeproblem. We compute CoreD
usingagreedyalgorithmthatiterativelyselectstheelementhaving
the largest number of uncovered branches and bugs at each stage.
FromCoreDandD, we collect the learning data, CoreVand
TotalV. We first obtain the set CoreVof effective parameter val-
ues inCoreDas follows:
CoreV ={{V|(_,_,_,V)âˆˆCoreD}}.
Note that we deliberately define the set CoreVas a multiset to
tracktheinfluentialparametervaluesmoreeffectively.Forexample,
supposethat CoreVis{{V1,V2,V1}},whereV1isduplicated.Since
the existence of duplication implies that the duplicated value is
usedmorethanonceintheset CoreD,wecanconcludethat V1is
the vector of more influential parameter values than V2in terms of
performance. We also collect the set TotalVof all parameter values
used in the accumulated data Das:
TotalV ={V|(_,_,_,V)âˆˆD}.
Note that the set TotalVis a standard set which does not allow
duplicated elements. The Extractfunction returns as output the
two setsCoreVandTotalVfor the final step.
3.3.3 Update. The aim of last step is to update sampling prob-
abilities of parameter spaces based on the extracted data, CoreV
andTotalV,andtogenerateanewvector V/primeofparametervalues
using the updated probabilities. More specifically, we update the
probability functions PiandPc
iby using the following two poli-
cies:ExploreandExploit.Ingeneral,theexplorationpolicy, Explore,
gives more opportunities to parameter values which have beenused less frequently. On the other hand, the exploitation policy,
Exploit, increases the probabilities for parameter values with good
performance while taking into account the number of times the
valueshavebeenused.Asbalancingexploitationandexploration
is a well-known important problem, based on trial and error, weset the sampling probability of
ExploitandExploreto be70% and
30%, respectively; that is, we set the hyper-parameter ğ›¼to 0.7 at
line 10 in Algorithm 3.
Exploration. Whentheselectedpolicyis Exploreorthevalue
offlagis 0 (line 13), SymTuner updates the probability for the ğ‘–-th
parameterspace Sibyusingthe Explorefunction(line14),andthen
samples the ğ‘–-th parameter value by using the Samplefunction
(line 17). The Explorefunction takes as input the set TotalVof
all parameter vectors used before and the ğ‘–-th parameter space
Si=(SVğ‘–,ğœ‚max
ğ‘–), and returns as output the updated probability
functions.
Toupdatethesamplingprobability, Explore(TotalV,(SVğ‘–,ğœ‚max
ğ‘–))
first scores each value v/primeinSVğ‘–as follows:
scorei(v/prime)=1
|{ğ‘‰âˆˆTotalV|v/primeâˆˆğ‘‰ğ‘–}|(1)
whereğ‘‰ğ‘–denotesthe ğ‘–-thelementofvector ğ‘‰.Thedenominator
isthenumberoftimesthevalue v/primeisusedasthe ğ‘–-thcomponent
duringthesymbolicexecutionsofar.Whenthevalue v/primeisnever
used(i.e.,dominator=0),wegiveahighestpossiblescorefor v/prime.The
intuition is that we give higher scores to parameter vectors that
have been used less frequently, so that SymTuner explores unseenparametervalues.With scorei,wedefinetheprobabilityfunction
Pi:SVğ‘–â†’[0,1]as follows:
Pi(v/prime)=scorei(v/prime)/summationtext.1
svâˆˆSVğ‘–scorei(sv)(2)
The probability is the normalized score of v/primedivided by the sum of
the scores of all parameter values in SVğ‘–. Intuitively, if the number
of all distinct parameter values used is the same, the sampling
probabilityisevenlydistributed; SymTuner samplestheparameter
values at complete random in this case.
Likewise,toobtaintheprobability Pc
iofthenumberofsampling
intheğ‘–-thspace Si=(SVğ‘–,ğœ‚max
ğ‘–),wecalculatethescoreforeach
numberğ‘š/primeof sampling (1 â‰¤ğ‘š/primeâ‰¤ğœ‚max
ğ‘–) usingscorec
idefined as:
scoreci(ğ‘š/prime)=1
|{ğ‘‰âˆˆTotalV|ğ‘š/prime=|ğ‘‰ğ‘–|}|(3)
The denominator is the number of times the value ğ‘š/primeequals to the
sample size ( |ğ‘‰ğ‘–|). We compute Pc
i:[1,ğœ‚max
ğ‘–]â†’[0,1]as follows:
Pc
i(ğ‘š/prime)=scoreci(ğ‘š/prime)
/summationtext.1
1â‰¤ğ‘šâ‰¤ğœ‚max
ğ‘–scorec
i(ğ‘š)(4)
At lines 17â€“18, with the two updated probabilities PiandPc
i,
the algorithm generates new ğ‘–-th parameter value PVğ‘–using the
Samplefunction, and then adds PVğ‘–to the vector V/prime.
Exploitation. Besidesexploration,weemployanexploitation
policy(Exploit)tolearnthesamplingprobabilitiesofeachparam-
eter space (lines 16). The policy uses the Exploitfunction which
increases the sampling probability of the values that have been
used more often as influential parameter values in CoreV.
Basically, theexploitationmethodcomputestheprobability Pi
ofeachparameterspaceinthesamewayastheexplorationmethod.
The scoring function, however, is different and defined as follows:
scorei(v/prime)=|{ğ‘‰âˆˆCoreV|v/primeâˆˆğ‘‰ğ‘–}|
|{ğ‘‰âˆˆTotalV|v/primeâˆˆğ‘‰ğ‘–}|
Intuitively, the score for the value v/primeindicates how often v/primeis
usedasinfluentialparametervaluesin CoreV.Moreprecisely,the
numerator represents the number of times the value is used in the
ğ‘–-th componentin theset CoreV. Notethat wedivide thisnumber
by the total number of times the value has been used, preferring
parametervalueswithhigherâ€œhitratesâ€insteadofjustpreferring
parametersin CoreVsimplybecausetheyhavebeentriedfrequently.
Similarly, we define the score function scorec
iforPc
ias follows:
scoreci(v/prime)=|{ğ‘‰âˆˆCoreV|v/prime=|ğ‘‰ğ‘–|}|
|{ğ‘‰âˆˆTotalV|v/prime=|ğ‘‰ğ‘–|}|
After the score calculation, the Exploitpolicy updates the probabil-
itiesPiandPc
iusingtheequations(2)and(4)atline16.Then,it
generates new ğ‘–-th parameter value based on the Samplefunction.
Through the three steps, Evaluate,Extract, andUpdate, Algo-
rithm 3 accumulates the set Dof learning data, and returns it as
output.ByrepeatingAlgorithm3,theset Discontinuouslyupdated,
andSymTuner graduallymakesasmartdecisiononhowtosample
ğ‘˜parameter values from ğ‘˜predefined parameter spaces towards
maximizing the performance of symbolic execution.
2072
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Sooyoung Cha, Myungho Lee, Seokhyun Lee, and Hakjoo Oh
4 EXPERIMENTS
In this section, we experimentally evaluate the effectiveness of our
approach. Research questions are as follows:
(1)Coverage: How effectively does SymTuner enhance sym-
bolic execution in terms of branch coverage?
(2)Bug-finding: Does the interaction between SymTuner and
symbolic executor enhance the bug-finding ability?
(3)Impact of parameters and the spaces: What is the most
influential parameter? How does the performance of our
approach change depending on different parameter spaces?
(4)Generality: IsSymTuner applicable to concolic testing, an-
other approach to dynamic symbolic execution?
WeusedKLEE[ 11]2asabasesymbolicexecutortointeractwith
SymTuner becauseKLEEisoneofthemostpopularandactively
maintained symbolic execution tools available today. All experi-
ments were conducted on a machine with two Intel Xeon Gold
6230R and 256GB RAM.
4.1 Experimental Settings
4.1.1Predefined Parameter Spaces. SymTuner takes as input
predefined parameter spaces ( S). In our experiments, we aimed to
tune all, more precisely 20, parameters in Figure 1, where their
typesconsistof7integer,3double,4string,and6booleantypes.In
particular, for the first 14 parameters which are not boolean types,
we defined their spaces as:
Ssearch =({s1,s2,Â·Â·Â·,s10},1),
Sargs=({1,2,3,4,5,6,7,8,9,10},5),
Sfiles=Sstdin=({4,8,12,16,20},1),
Smem=({500,1000,1500,2000,2500},1),
Sbatch=({6000,8000,10000,12000,14000},1),
Sinstr_time=({10,20,30,40,50},1),
Sarray_size=({3000,3500,4000,4500,5000},1),
Sfork=Scpfork =Ssolve=({0.25,0.5,1,2,4},1),
Sswitch =({â€œğ‘ ğ‘–ğ‘šğ‘ğ‘™ğ‘’â€,â€œğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘›ğ‘ğ‘™â€},1),Sseed=({},1),
Sexternal =({â€œğ‘ğ‘œğ‘›ğ‘ğ‘Ÿğ‘’ğ‘¡ğ‘’â€,â€œğ‘ğ‘™ğ‘™â€},1),
Therationalebehindthespacesistwofold.First,foreachparameter,
we simply chose 5â€“10 values around the value used in Figure 1.
Second, we tried to subsume the settings used in prior work [ 11,
45,63,66]. In the first space (S search),ğ‘ 1,...,ğ‘ 10denote the ten
search strategies implemented in KLEE. Note that we also tuned
the seed input parameter (â€˜--seed-fileâ€™) not involved in Figure 1 as
itsimpactontheperformanceofsymbolicexecutioniswell-known
in the literature [ 14,19,37,54]. Despite its importance, however, it
is not appropriate to predefine the seed sample space (e.g., Sseed)
because the corpus of seed inputs highly depends on the program
under test, which requires additional manual efforts for the end-users to use
SymTuner . Thus, we did not predefine Sseed, but let
it be dynamically determined during symbolic execution. More
precisely,on every iterationof theloopat lines5â€“8 in Algorithm2,
SymTuner calculatestop-20testcasesintermsofcoveredbranches
anddetectedbugs,andupdates Sseedwiththem.Thatis,unlikeother
predefined spaces, the candidate values in Sseedmay change as the
learning progresses.
2We used KLEE-2.0 released in March 2019.Table 1: 12 benchmark programs
Programs LOC # of Branches Programs LOC # of Branches
xorriso-1.5.2 161K 49,162 enscript-1.6.6 49K 3,796
gcal-4.1 89K 15,799 combine-0.4.0 32K 2,357
grep-3.4 82K 8,225 trueprint-5.4 12K 2,518
gawk-5.1.0 77K 10,720 diff (diffutils-3.7) 9K 7,612
sed-4.8 66K 6,798 du (coreutils-8.32) 8K 6,653
nano-4.9 54K 10,436 ls (coreutils-8.32) 5K 3,776
In total, the product of the 20 parameter spaces ( S) induces 1016
different parameter settings.
4.1.2Baselines. Wecomparedourapproach( Klee+SymTuner )
withthreebaselines: Kleedefault,Kleehand,andKlee+RandTuner .
Thefirstbaseline, Kleedefault,usesthedefaultparametervaluespro-
videdbyKLEEwithoutanymodification.Thesecondone, Kleehand,
uses the hand-tuned parameter setting in Figure 1. More precisely,
itsconfigurationisthesameastheparametervaluesprovidedinthe
KLEEdocumentation[ 49],whichhasbeenaconventionalchoice
inpriorwork[ 17,18,23,50,63].Thelastone, Klee+RandTuner ,
is a baseline that randomly samples parameter values from ourparameter spaces defined in Section 4.1.1; we simply substituted
RandTuner for SymTuner on line 6 in Algorithm 2.
For afair comparison ofKlee defaultand Klee hand, weran each
baseline in two different modes, respectively, and then reported
thebestresults.Theonlydifferencebetweenthetwomodesisin
how the given time budget is used. The first method is to perform
symbolic execution (Algorithm 1) only once for the total budget
(e.g.,10h)whiletheotheristorunAlgorithm1multipletimesby
dividingthe totalbudget intosmaller budgets.More precisely, the
secondmethodistorunAlgorithm2withouttheparameter-tuning
process.
4.1.3Benchmarks and Time Budgets. We used 12 GNU open-
source C programs in Table 1. Our benchmark suite includes the
largest programs used in prior works [ 14,16,17,47,54]. For exam-
ple, the last three programs in Table 1 are the largest (or second
largest)onesinGNUcoreutils-8.32anddiffutils-3.7.Foreachbench-
mark program, we collected the most recent releases (as of March
2020).Forallexperiments,wesetthetimebudgetto10hoursfor
eachbenchmarkprogram.Werepeatedeachexperiment4times,
and reported average results.
4.2 Branch Coverage
Our approach significantly outperformed the three baselines onall benchmarks in terms of branch coverage. On average over
allbenchmarkprograms, Klee+SymTuner achieved31%and56%
higherbranchcoveragethan KleehandandKleedefault,respectively.
SymTuner also succeeded in covering 12% more branches than
RandTuner ,showingthetruebenefitofonlinelearningalgorithm.
As the final outputs of our approach (Algorithm 2) and three
baselinesarethetestcasesgeneratedduringsymbolicexecution,
wedepictedthecoveragegraphovertimeinFigure3byaccumulat-
ingthenumberofbranchescoveredbythetestcasegeneratedat
eachtimestep.Todoso,weused gcov,atoolformeasuringcode
coverage.
2073
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SymTuner: Maximizing the Power of Symbolic Execution by Adaptively Tuning External Parameters ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
0 5000 10000 15000 20000 25000 30000 35000
time(s)050010001500200025003000# of Covered Branchesxorriso-1.5.2 (161K)
KLEE+SymTuner
KLEE hand
KLEE+RandTuner
KLEE default
0 5000 10000 15000 20000 25000 30000 35000
time(s)0500100015002000250030003500# of Covered Branchesgcal-4.1 (89K)
KLEE+SymTuner
KLEE+RandTuner
KLEE hand
KLEE default
0 5000 10000 15000 20000 25000 30000 35000
time(s)050010001500200025003000# of Covered Branchesgrep-3.4 (82K)
KLEE+SymTuner
KLEE+RandTuner
KLEE hand
KLEE default
0 5000 10000 15000 20000 25000 30000 35000
time(s)0500100015002000250030003500# of Covered Branchesgawk-5.1.0 (77K)
KLEE+SymTuner
KLEE+RandTuner
KLEE default
KLEE hand
0 5000 10000 15000 20000 25000 30000 35000
time(s)0500100015002000# of Covered Branchessed-4.8 (66K)
KLEE+SymTuner
KLEE default
KLEE hand
KLEE+RandTuner
0 5000 10000 15000 20000 25000 30000 35000
time(s)02505007501000125015001750# of Covered Branchesnano-4.9 (54K)
KLEE+SymTuner
KLEE+RandTuner
KLEE hand
KLEE default
0 5000 10000 15000 20000 25000 30000 35000
time(s)0200400600800100012001400# of Covered Branchesenscript-1.6.6 (49K)
KLEE+SymTuner
KLEE+RandTuner
KLEE hand
KLEE default
0 5000 10000 15000 20000 25000 30000 35000
time(s)0200400600800# of Covered Branchescombine-0.4.0 (32K)
KLEE+SymTuner
KLEE+RandTuner
KLEE hand
KLEE default
0 5000 10000 15000 20000 25000 30000 35000
time(s)02004006008001000# of Covered Branchestrueprint-5.4 (12K)
KLEE+SymTuner
KLEE+RandTuner
KLEE hand
KLEE default
0 5000 10000 15000 20000 25000 30000 35000
time(s)02505007501000125015001750# of Covered Branchesdiï¬€ (9K)
KLEE+SymTuner
KLEE+RandTuner
KLEE default
KLEE hand
0 5000 10000 15000 20000 25000 30000 35000
time(s)020040060080010001200# of Covered Branchesdu (8K)
KLEE+SymTuner
KLEE+RandTuner
KLEE hand
KLEE default
0 5000 10000 15000 20000 25000 30000 35000
time(s)02505007501000125015001750# of Covered Branchesls (5K)
KLEE+SymTuner
KLEE+RandTuner
KLEE hand
KLEE default
Figure 3: The average number of covered branches achieved by our approach and three baselines on 12 benchmarks
The results in Figure 3 show that Klee+SymTuner consistently
achieves the highest branch coverage on all benchmarks. In partic-
ular,theresultsforthetwolargestbenchmarks, xorriso andgcal,
arenoteworthy; Klee+SymTuner wasabletocover3,093branches
on average for xorriso whileKleehandandKlee+RandTuner
covered 2,509 and 2,415 branches, respectively. For gcal, the av-
erage number of branches covered by Klee+SymTuner was 3,539,
whichis353and1,062morethan Klee+RandTuner andKleehand,
respectively.
Excludingourapproach, Klee+RandTuner wasgenerallybet-
ter than the other two baselines, where this result implies that
performingsymbolicexecutionwithvariousparametervaluesis
usuallymoreeffectivethanrunningitwiththefixedvalues.Among
KleehandandKleedefault,theformerachieved19%higherbranch
coverage than the latter on all benchmarks. That is, using hand-
tunedparametervalueswasbetterthanblindlyusingthedefault
values provided in KLEE.
One interesting point is that Klee+RandTuner is sometimes
eveninferiortothetwobaselines, KleehandandKleedefault,which
donotchangetheparametervaluesatallduringsymbolicexecu-
tion. Onxorriso andsed,Klee+RandTuner managed to cover
about 100 and 150 branches less than KleehandandKleedefault,
respectively; Klee+RandTuner achievedthelowestcoverageon
sed. The instability of RandTuner supports that our approach
(Algorithm 2) is essential to consistently achieve higher coverage.
The standard deviations of branch coverage averaged over all
benchmarks and trials are as: SymTuner (122),RandTuner (99),Table2:Thebranchcoverageachievedbyrunning SymTuner
and RandTuner with multiple cores in parallel
# o f C o r e s 2468 10
xorriso-1.5.4SymTuner 3,260 3,385 3,604 4,083 5,202
RandTuner 2,726 3,225 3,440 3,441 3,631
gcal-4.1SymTuner 4,243 4,397 4,538 4,561 4,757
RandTuner 3,825 4,131 4,221 4,256 4,315
Kleedefault(102),and Kleehand(60);thesedifferencesareinsignifi-
cant considering the coverage gap between ours and the baselines.
Additionally, we investigated whether SymTuner still outper-
formsRandTuner evenwhenrunningtheminparallel.Wewon-
dered if running KLEE with more diverse parameters simply by
using many cores in parallel would diminish the advantage of
SymTuner comparedto RandTuner .So,wecompared SymTuner
andRandTuner byaccumulatingtheresultsofrunningthem(e.g.,
Algorithm2)withdifferentnumberofcoresinparallel,respectively.
Table2reportsthenumberofcoveredbranchesachievedbyeach
technique according to the number of cores used in parallel on the
two largest benchmarks: xorriso andgcal. The results show that
the difference in branch coverage between the two techniques be-
comes larger when more cores are used. For instance, on xorriso,
runningSymTuner with 10 cores in parallel succeeded in cover-
ing about 1,500 more branches than running RandTuner with the
same settings. That is, even in parallel settings, smartly tuning
2074
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Sooyoung Cha, Myungho Lee, Seokhyun Lee, and Hakjoo Oh
Table 3: Comparison of bug-finding ability of the three baselines and SymTuner. (SymTuner = Klee+SymTuner)
Benchmarks Error-Types Error Locations Bug-Triggering Test Cases SymTuner RandTuner Klee handKleedefault
gcal-4.1Segmentation fault â€˜Line: 740 in /src/file-io.câ€™ "@/âŠ™"(âŠ™denotes an ASCII character of 1.)   
Segmentation fault â€˜Line: 3956 in /src/gcal.câ€™ "@/" "--at=5"   
Segmentation fault â€˜Line: 72 in /libc/string/strncasecmp.câ€™ "@...//" "@.." "@../" "--u=Z="   
Abnormal termination â€˜Line: 27 in /libc/string/strcpy.câ€™ "/#" "âŠ™"A(Adenotes a symbolic file.)    
Abnormal termination â€˜Line: 29 in /libc/string/memcpy.câ€™ "@/" "-#__ âŠ™"A   
enscript-1.6.6 Segmentation fault â€˜Line: 1880 in /libc/stdio/_vfprintf.câ€™ "--to" "" "" "" ""  
gawk-5.1.0 Abnormal termination â€˜Line: 1337 in main.câ€™ "-W" "nost"  
combine-0.4.0Segmentation fault â€˜Line: 385 in /src/field.câ€™ "-f" "--field=,"   
Segmentation fault â€˜Line: 458 in /src/field.câ€™ "--re" "" "--fi" "d.e0-2,"   
Segmentation fault â€˜Line: 633 in /src/df_options.câ€™ "-Pp" "--no-ch" "--fi" "r.o1" "--r="  
Memory-exhaustion â€˜Line: 48 in /libc/string/memmove.câ€™ "-ecut" "--fiel" "8,--1"   
SymTunersym-argsearchseed-file
switch-type
max-memory
max-sym-array-size
max-static-fork-pct
max-static-solve-pct
max-static-cpfork-pct
max-instruction-time
batch-instructions
simplify-sym-indices
external-calls
sym-files
sym-stdin
use-cex-cache
max-memory-inhibit
use-forked-solver
optimize
sym-stdout2000240028003200xorriso-1.5.2# of Covered Branches
SymTunersym-argsearchseed-file
switch-type
max-memory
max-sym-array-size
max-static-fork-pct
max-static-solve-pct
max-static-cpfork-pct
max-instruction-time
batch-instructions
simplify-sym-indices
external-calls
sym-files
sym-stdin
use-cex-cache
max-memory-inhibit
use-forked-solver
optimize
sym-stdout20002400280032003600gcal-4.1# of Covered Branches
SymTuner
sym-arg
searchseed-file
switch-type
max-memory
max-sym-array-size
max-static-fork-pct
max-static-solve-pct
max-static-cpfork-pct
max-instruction-time
batch-instructions
simplify-sym-indices
external-callssym-files
sym-stdin
use-cex-cache
max-memory-inhibit
use-forked-solveroptimize
sym-stdout200024002800grep-3.4# of Covered Branches
Figure 4: The average branch coverage achieved by tuning only individual parameter on the three largest benchmarks
parametersisstillmoreeffectivethantryingvariousparametersin-
discriminately.Asfuturework,tofurtherimprovetheeffectivenessof
SymTuner whenrunningitinparallel,weplantoapplythecore
ideas of the existing techniques such as swarm testing [26, 31].
4.3 Bug-finding
Table 3 shows that SymTuner also has considerable promise in
improvingthebug-findingabilityofKLEE.Insummary, SymTuner
detected 11 different real-bugs from four open-source programs
while the best one among three baselines, RandTuner , found just
six of them.
Columns in Table 3 denote the benchmark program, error-type,
error-location, bug-triggering test case produced by SymTuner ,
and indication of success ( ) or failure ( ) for each technique.
In particular, we note that the failure mark â€˜ â€™ indicates that the
correspondingtechniquecompletelyfailedtofindthebugwithin
40hours(10h Ã—4repetitions).Conversely,ifsucceedingonthebug
detection at least once during the four trials, we marked the result
as â€˜successâ€™ ().
Ourapproach( Klee+SymTuner )found11differentbugsinto-
tal, and we classified them into three error-types: abnormal ter-mination, segmentation fault, and memory exhaustion. The firsttwoerror-typescausetheprogramtocrashwhilethethirdoneis
a performance bug. For example, the bug-triggering input ( "@/"
"--at=5" ) generated by Klee+SymTuner for the program gcal
causes a segmentation fault which terminates the programabnor-
mally.Klee+SymTuner also found fatal bugs in combine; the in-
put ("-ecut" "--fiel" "8,--1" ) leads to a serious performance
degradation which consumes all available memory of the machine.
Thesebug-triggeringtestcasesinTable3areeasilyreproducible.
Forexample,ongawk-5.1.0,executingthecommand( ./gawk "-W"
"nost")willaborttheprogramexecutionimmediately.Anunex-
pectedresultinTable3isthat RandTuner failedtofindabugthat
Kleehanddiscovered in gcal; that is,RandTuner is unstable even
in terms of bug-finding capability.
Additionally, we also investigated whether RandTuner could
findmorebugswhenrunningitinparallelwithmultipleCPUcores.
Compared to running RandTuner on a single core, using 10 cores
inparallelwasabletofindmorebugs,butitstillfailedtofindsome
bugswhichwerediscoveredby SymTuner (e.g.,thebugfoundin
thefileâ€˜strncasecmp.câ€™of gcal).Whenweexecuted RandTuner
formuch longer(e.g.,20h) using10cores inparallel, RandTuner
was eventually able to find all bugs that SymTuner found with a
single core for 10 hours.
2075
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SymTuner: Maximizing the Power of Symbolic Execution by Adaptively Tuning External Parameters ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
154 318229
322107 1062459SymTuner spaces SymTuner
SymTuner paramsxorriso-1.5.2
179 462223
168100 1802684SymTuner
spaces SymTuner
SymTuner paramsgcal-4.1
271 38144
335141 2852603SymTuner
spaces SymTuner
SymTuner paramsgrep-3.4
228 222113
46116 1483326SymTuner spaces SymTuner
SymTuner paramsgawk-5.1.0
Figure 5: Venn-diagrams illustrating the sets of branches covered by SymTuner with different parameter spaces
52 90 3381
Chameleon Chameleon+SymTunergawk-3.0.3
47 53 1506
Chameleon Chameleon+SymTunersed-1.17
21 18 2218
Chameleon Chameleon+SymTunergrep-2.2
Figure 6: Venn-diagrams depicting the sets of covered branches by Chameleon with/without SymTuner
4.4 Impact of Parameters and their Spaces
ImpactofIndividualParameters. Weinvestigatedwhichof
the 20 parameters in Table 1 had the greatest impact on the per-
formanceof symbolicexecutionfor thethreelargestbenchmarks,
xorriso,gcal, andgrep. To do so, we performed symbolic exe-
cutionwhiletuningeachparameteronebyone,andreportedthe
average branch coverage for each parameter-tuning with the same
setting of SymTuner (10h Ã—4 repetitions).
Figure4showsthatthemostinfluentialparameterstendtobe
similar across the three programs, but the least influential ones are
different depending on the target program. The two parameters,
symboliccommand-linearguments(â€˜--sym-argâ€™)andseedinput(â€˜--
seed-fileâ€™), were consistently included in the top-4 most influential
parametersforallthebenchmarks.Also,themostcrucialparameter
forgcalandgrepwasequalassearchstrategy(â€˜--searchâ€™),butthe
search strategy parameter was not included even in top-10 impor-
tant parameters for xorriso, which means that every important
parameter was not shared across all the programs. Likewise, theforth most important parameter (â€˜--batch-instructionsâ€™) on
gcal
was the most unimportant one on xorriso. On the other hand,
the least influential parameter for each program is different as:
â€˜--batch-instructionsâ€™ ( xorriso), â€˜--use-cex-cacheâ€™ ( gcal), and â€˜--
sym-stdinâ€™ ( grep). These results support our claim that we should
take a program-adaptive method to tune various parameters for
symbolic execution.
An unexpected observation from Figure 4 is that the parameter
type itself seems to be related to its importance. First, the string-type parameters (e.g., â€˜--searchâ€™, â€˜--seed-fileâ€™) ranked the most in
the most important top-4 parameters while none of the parametersbelongedtotheleastimportanttop-4parameters;thatis,thestring-typeparameterisimportanttotunecarefully.Second,booleantypeTable 4: 14 Parameter spaces added for SymTuner Params
Boolean Boolean Integer or (Double)
use-branch-cache cex-cache-exp redzone-size ( {5,10,15,20,25,30},1)
use-constant-arrays cex-cache-superset seed-time ( {5,10,15,20,25,30},1)
solver-optimize-divides cex-cache-try-all max-stack-frames ( {6000,7000,8000,9000,10000},1)
allocate-determ equality-substitution allocate-determ-size ( {50,100,150,200,250},1)
rewrite-equalities max-static-cpsolve-pct ( {0.25,0.5,1,2,4},1)
parameters are less valuable to tune than the other type parame-
tersasbooleantypesaccountfor50%oftheleastimportanttop-4
parameters.
The results in Figure 4 also demonstrate that tuning only the
most influential parameter is less beneficial than SymTuner which
adjusts the 20 parameters simultaneously. In particular, SymTuner
covered11.5%morebrancheson grepthantuningonlythemost
influential parameter (â€˜--searchâ€™). Also, in terms of bug-finding
capability,wefoundthattuningonlythemostinfluentialparameter
ongcalwas able to discover only a single bug located in â€˜/src/file-
io.câ€™amongthetotal5bugsfoundby SymTuner ongcalinTable3.
ImpactofParameterSpaces. Weevaluatedhowtheperfor-
mance of SymTuner changes depending on different parameter
spaces. To do so, we compared SymTuner with its two variants,
SymTuner SpacesandSymTuner Params,havingdifferentparameter
spaces.Theformer( SymTuner Spaces)isavariantthatdoubleseach
space of the 10 parameters with integer or double type definedin Section 4.1.1, respectively. For example, the space of S
argsof
SymTuner is between 1 and 10, but the space for SymTuner Spaces
will be between 1 and 20. That is, the parameter spaces for the first
variant will be 210âˆ—1016, which is about 1,000 times larger than
the spaces for SymTuner . The latter ( SymTuner Params) is another
variantthattunesmoreparametersthanthe20parameterstobe
2076
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Sooyoung Cha, Myungho Lee, Seokhyun Lee, and Hakjoo Oh
tunedoriginallyin SymTuner .Morespecifically,thisvariantaimed
tosimultaneouslytuneatotalof34parameters,includingthe20
parametersthat SymTuner tunedandthe14additionalparameters
in Table 4; we manually added the 14 parameters that are likely to
affecttheperformanceofsymbolicexecutionamongthetotalpa-
rametersprovidedtoKLEE.Weevaluatedthetwovariantswiththe
samesettings(e.g,10h Ã—4repetitions)as SymTuner on4largest
benchmarks, and reported the average results.
Figure 5 shows the Venn-diagrams which describe the relation-
shipsintermsofthesetsofbranchesreachedbyeachtechnique.
The results show that SymTuner is able to cover different code
areasofthetargetprogrameffectivelydependingontheparameter
spacestobetuned.Intermsofthetotalnumberofcoveredbranches,
SymTuner achieved the highest branch coverage on gcaland
the lowest coverage on grep. Exactly opposite, SymTuner Params
achieved the lowest branch coverage on gcaland the highest cov-
erage ongrep. Figure 5 also shows that there exist many branches
thatSymTuner anditstwovariantsareabletoexclusivelyreach.
For example, SymTuner Spacesexclusively covered 271 branches
ongrep,andSymTuner Paramssucceededincovering332unique
brancheson xorriso.Thatis,thepotentialof SymTuner mayvary
depending on different parameter spaces.
4.5 Generality of SymTuner
We checked if our approach is applicable to concolic testing [ 25,
53],anothermajorapproachtodynamicsymbolicexecution.We
appliedSymTuner toCREST[ 21]asitisapubliclyavailabletool
andChameleon [16], the state-of-the-art technique for tuning
search heuristics for concolic testing, is implemented on top of
CREST[58].Hence,ourapproach( Chameleon +SymTuner )aims
totunetheotherparameterswhileletting Chameleon tunesearch
strategies in its own way. To do so, we implemented SymTuner on
topofChameleon ,andfiguredoutwhether SymTuner wasable
to enhance Chameleon.
UnlikeKLEE,CRESTonlyprovidesthreeexternalparameters;
others are hard-coded inside the tool and difficult to tune fromthe outside. In our experiments, we tried to tune all of the threeparameters: symbolic command-line argument, seed input, and
the number of program executions. On the basis of the parameter
valuesusedin Chameleon [58],wedefinedtheirspacesasfollows:
Sargs=({12,14,16,18,20,22,24,26,28,30},1),
Sseed=({ğ¼0},1),
Sexecution =({3000,3500,4000,4500,5000},1)
Inparticular,wefirstinitializedthespace Sseedwithaninitialinput
(ğ¼0)providedin Chameleon [58],andletitbedynamicallydecided
during concolic testing like the space Sseedin Section 4.1.1. For
evaluation,weusedthesamethreebenchmarkprogramstakenfrom
Chameleon ,allocatedthe timebudgetto 10hours,and reported
the number of covered branches averaged over 5 times.
Figure6showsthatourapproach( Chameleon +SymTuner )has
itsownbenefitintermsofexclusivelycoveredbranches.Forthe
three benchmarks, Chameleon +SymTuner succeeded in covering
about30%moreuniquebranchesthan Chameleon alone.Weex-
pect that the usefulness of SymTuner will be greater if various
parameters provided in KLEE are also added to CREST in the fu-ture. Note that since
SymTuner uses a symbolic execution tool(e.g., KLEE and CREST) as a blackbox, we expect that applying
SymTuner toothersymbolicexecutiontools[ 51,56]doesnotre-
quire much effort.
4.6 Threats to Validity
(1)Weevaluated SymTuner onlyforKLEEandCREST.Wechose
themastheyaretherepresentativesymbolicexecutorsforCpro-
grams,buttheresultsreportedinthispapermaynotbevalidfor
other testing tools such as EVOSUITE [ 24], a widely used unit test-
ing tool. (2) We manually defined the 20 parameter spaces of KLEE
bychoosing5â€“10valuesaroundthevalueusedinFigure1.How-
ever, these predefined spaces may not be appropriate for the other
target programs beyond our 12 benchmarks. (3) Our approach (Al-
gorithm 2) involves hyper-parameters, e.g., ğœ‚ratioandğœ‚step, which
were selectedheuristically. Thesevalues mayneedto beset prop-
erly for target programs. (4) We used 12 programs including the
largest real-world programs (up to 161KLoC) among those used in
priorworks[ 14,16,17,47,54]forevaluatingKLEE.However,these
might not be representative enough.
5 RELATED WORK
ImprovingSymbolicExecution. Toourknowledge,SymTuneris
thefirsttechniquetotunegeneralparametersofsymbolicexecu-
tion automatically. Over the past decade, a lot of research has been
conducted to advance symbolic execution, and they can be clas-sified into three groups according to the main approach: searchstrategies [
10,45,54,62], pruning techniques [ 6,9,34,66], and
constraint solving techniques [ 23,35,52,65]. First, prior works
on search strategies aim to preferentially explore the execution
paths of the program that are likely to maximize the performance
(e.g., code coverage). For example, the CFDS strategy [ 10] prior-
itizes the programâ€™s paths closest to the branches that have not
yetbeenreached,andtheCGSstrategy[ 54]favorsexploringthe
paths with a new context (i.e., new sequence of branches). Second,
path-pruningtechniquesfocusonremovingtheredundantpaths
oftheprogrambasedonthepredefinedcriteria.Forinstance,Jaf-
far et al. [ 34] presented a criterion that eliminates the execution
pathsguaranteednottoreachtheerrorlocations.Lastly,diverse
techniques have emerged to reduce the cost for constraint solving,
one major bottleneck in symbolic execution, by simplifying the
arrayconstraints[ 52]orreusingtheconstraintsolutions[ 35,65].
SymTuner is orthogonal to the above three approaches and we be-
lievethatSymTunercanfurther enhancetheexistingapproachesby automatically tuning external parameters.
Software Testing with Learning. Our approach follows a re-
cent trend in software testing that leverages machine learning [ 14â€“
18,42,44,55,57].ParaDySE[ 14]boostsconcolictestingbyautomat-
ically generating search strategy via offline learning. Using online
learningtechnique,Chameleon[ 16]adaptivelyswitchesthesearch
strategiesofconcolictesting.LEO[ 18]aimstoimprovetheefficacy
ofsymbolicexecutionbylearninghowtousecompileroptimiza-
tions for code transformation. In Android GUI testing, QBE [ 42]
usesreinforcementlearningtoexploreGUIactionsthatarelikelytodetectbugsandincreaseactivitycoverage.RETECS[
57]learnshow
to preferentially select buggy test cases in Continuous Integration
2077
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. SymTuner: Maximizing the Power of Symbolic Execution by Adaptively Tuning External Parameters ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
based on reinforcement learning. In this paper, we use learning for
a novel application, i.e., tuning symbolic execution parameters.
Search-based Software Testing. Our work can be considered an
instanceofsearch-basedsoftwaretesting(SBST)[ 1,4,27,46]using
meta-heuristic search technique in the field of search-based soft-
wareengineering[ 3,28â€“30].SBSTaimstofindgoodsolutionsfrom
anextremelylargesearchspaceinareasonabletimeforenhancing
testingefficacy.Todoso,eachtechniqueinSBSTdefinesitsown
optimizationproblemandproposesafitnessfunctionspecialized
forsolvingtheproblem.Inourwork,weformulatedtheproblemof
tuning parameter values of symbolic execution as an optimization
problem that maximizes both the number of covered branches and
found bugs, and presented a specialized algorithm to solve it.
Automatic Parameter Tuning. Automatic parameter tuning has
beenstudiedextensivelyinvariousfields.Forexample,researchershavedevelopeddomain-specificalgorithmsfordatabasesystems[
22,
61], web systems [ 8,64], image segmentation [ 59], and big data
processingsystems[ 20,43].Ourworkliesinthislineofresearch
andpresents analgorithmspecializedfor symbolicexecution.Ex-
isting frameworks for algorithm configuration (e.g., ParamILS [ 33],
OpenTuner [ 2]) are inappropriate for our purpose. Note that these
are offline approaches; they aim to discover good parameter set-
tings of algorithms and the same settings are used without change
atruntime.Bycontrast,themainbenefitof SymTuner comesfrom
adaptively adjusting the parameter values online (during symbolic
execution),whichiscrucialinourcaseasoptimalparametervalues
varysignificantly depending onthe targetprograms (Section4.4).
Also, using these tools effectively often requires domain exper-
tise [2]; our goal is to enable users to use symbolic execution with-
out any prior knowledge.
6 CONCLUSION
Automatictuningofsymbolicexecutionparametershasreceived
little attention despite its importance in practice. In this paper, we
called for attention to this problem and presented SymTuner for
automatically tuning parameters of symbolic execution via online
learning.ExperimentalresultsshowedthatrunningKLEEincon-
cert with SymTuner leads to sharp increases in branch coverageand found bugs. We hope that SymTuner will help end-users to
maximallybenefitfrompowerfulyetdifficult-to-usemodernsym-
bolic execution tools.
ACKNOWLEDGMENTS
This work was supported by Samsung Research Funding & In-
cubation Center of Samsung Electronics under Project NumberSRFC-IT1701-51. This work was partly supported by Institute of
Information&communicationsTechnologyPlanning&Evaluation
(IITP) grant funded by the Korea government(MSIT) (No.2020-0-
01337,(SW STAR LAB) Research on Highly-Practical Automated
SoftwareRepair)andtheMSIT(MinistryofScienceandICT),Korea,
under the ICT Creative Consilience program (IITP-2022-2020-0-
01819) supervised by the IITP(Institute for Information & commu-
nications Technology Planning & Evaluation). This work was sup-
ported by the National Research Foundation of Korea (NRF) grant
funded bythe Korea government(MSIT) (No.2021R1A5A1021944,
No.NRF-2021R1C1C2006410).REFERENCES
[1]Wasif Afzal, Richard Torkar, and Robert Feldt. 2009. A systematic review of
search-based testing for non-functional system properties. Information and
Software Technology (2009), 957â€“976.
[2]J.Ansel,S.Kamil,K.Veeramachaneni,J.Ragan-Kelley,J.Bosboom,U.Oâ€™Reilly,
andS.Amarasinghe.2014. OpenTuner:Anextensibleframeworkforprogram
autotuning. In 2014 23rd International Conference on Parallel Architecture and
Compilation Techniques (PACTâ€™14). 303â€“315.
[3]Andrea Arcuri and Gordon Fraser. 2013. Parameter tuning or default values? An
empiricalinvestigationinsearch-basedsoftwareengineering. EmpiricalSoftware
Engineering (2013), 594â€“623.
[4]AndreaArcuriandXinYao.2008.Searchbasedsoftwaretestingofobject-oriented
containers. Information Sciences (2008), 3075â€“3095.
[5]Roberto Baldoni, Emilio Coppa, Daniele Cono Dâ€™elia, Camil Demetrescu, and
IreneFinocchi.2018. ASurveyofSymbolicExecutionTechniques. ACMComput.
Surv.51, 3, Article 50 (May 2018), 39 pages. https://doi.org/10.1145/3182657
[6]Peter Boonstoppel, Cristian Cadar, and Dawson Engler. 2008. RWset: Attacking
pathexplosioninconstraint-basedtestgeneration.In InternationalConference
on Tools and Algorithms for the Construction and Analysis of Systems (TACAS â€™08) .
351â€“366.
[7]Robert S. Boyer, Bernard Elspas, and Karl N. Levitt. 1975. SELECTâ€“a Formal
System for Testing and Debugging Programs by Symbolic Execution. SIGPLAN
Not.(1975), 234â€“245.
[8]XiangpingBu,JiaRao,andCheng-ZhongXu.2009. AReinforcementLearning
Approach to Online Web Systems Auto-Configuration. In Proceedings of the 2009
29th IEEE International Conference on Distributed Computing Systems (ICDCS â€™09).
2â€“11.
[9]SuhabeBugraraandDawsonEngler.2013. RedundantStateDetectionforDy-namic Symbolic Execution. In Proceedings of the 2013 USENIX Conference on
Annual Technical Conference (USENIX ATCâ€™13). 199â€“212.
[10]Jacob Burnim and Koushik Sen. 2008. Heuristics for Scalable Dynamic Test Gen-
eration. In Proceedings of 23rd IEEE/ACM International Conference on Automated
Software Engineering (ASE â€™08). 443â€“446.
[11]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
AutomaticGenerationofHigh-coverageTestsforComplexSystemsPrograms.
InProceedings of the 8th USENIX Conference on Operating Systems Design and
Implementation (OSDI â€™08). 209â€“224.
[12]C. Cadar, P. Godefroid, S. Khurshid, C. S. Pasareanu, K. Sen, N. Tillmann, and W.
Visser. 2011. Symbolic execution for software testing in practice: preliminary
assessment. In 2011 33rd International Conference on Software Engineering (ICSE).
1066â€“1071.
[13]Cristian Cadar and Koushik Sen. 2013. Symbolic Execution for Software Testing:
Three Decades Later. Commun. ACM 56, 2 (2013), 82â€“90.
[14]SooyoungCha,SeongjoonHong,JunheeLee,andHakjooOh.2018.Automatically
Generating Search Heuristics for Concolic Testing. In Proceedings of the 40th
International Conference on Software Engineering (ICSE â€™18) . 1244â€“1254.
[15]Sooyoung Cha, Seonho Lee, and Hakjoo Oh. 2018. Template-guided Concolic
TestingviaOnlineLearning.In Proceedingsofthe33rdACM/IEEEInternational
Conference on Automated Software Engineering (ASE â€™18) . 408â€“418.
[16]SooyoungChaandHakjooOh.2019. ConcolicTestingwithAdaptivelyChangingSearchHeuristics.In Proceedingsofthe201927thACMJointMeetingonEuropean
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (ESEC/FSE â€™19). 235â€“245.
[17]Sooyoung Cha and Hakjoo Oh. 2020. Making Symbolic Execution Promising by
Learning Aggressive State-Pruning Strategy. In The 28th ACM Joint European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (ESEC/FSE â€™20).
[18]JunjieChen,WenxiangHu,LingmingZhang,DanHao,SarfrazKhurshid,andLu
Zhang. 2018. Learning to accelerate symbolic execution via code transformation.
In32nd European Conference on Object-Oriented Programming (ECOOP â€™18).
[19]Yaohui Chen, Peng Li, Jun Xu, Shengjian Guo, Rundong Zhou, Yulong Zhang,
TaoWei,andLongLu.2020. SAVIOR:TowardsBug-DrivenHybridTesting.In
2020 IEEE Symposium on Security and Privacy (S&P â€™20). 1580â€“1596.
[20]Dazhao Cheng, Jia Rao, Yanfei Guo, and Xiaobo Zhou. 2014. Improving MapRe-
duce Performance in Heterogeneous Environments with Adaptive Task Tuning.
InProceedingsof the15th InternationalMiddlewareConference (Middleware â€™14).
97â€“108.
[21]CREST. A concolic test generation tool for C. 2008. https://github.com/jburnim/
crest.
[22]SongyunDuan,VamsidharThummala,andShivnathBabu.2009.TuningDatabase
Configuration Parameters with ITuned. Proc. VLDB Endow. (2009), 1246â€“â€“1257.
[23]Oscar Soria Dustmann, Klaus Wehrle, and Cristian Cadar. 2018. PARTI: A
Multi-Interval Theory Solver for Symbolic Execution. In Proceedings of the 33rd
ACM/IEEE International Conference on Automated Software Engineering (ASE â€™18) .
430â€“440.
2078
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Sooyoung Cha, Myungho Lee, Seokhyun Lee, and Hakjoo Oh
[24]Gordon Fraser and Andrea Arcuri. 2011. EvoSuite: Automatic Test Suite Gen-
erationforObject-OrientedSoftware.In Proceedingsofthe19thACMSIGSOFT
Symposiumandthe13thEuropeanConferenceonFoundationsofSoftwareEngi-
neering (ESEC/FSE â€™11). 416â€“419.
[25]Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed Auto-
mated Random Testing. In Proceedings of the 2005 ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI â€™05). 213â€“223.
[26]Alex Groce, Chaoqiang Zhang, Eric Eide, Yang Chen, and John Regehr. 2012.
SwarmTesting.In Proceedingsofthe 2012InternationalSymposiumonSoftware
Testing and Analysis (ISSTA â€™12) . 78â€“88.
[27]MarkHarman,YueJia,andYuanyuanZhang.2015. Achievements,openproblems
andchallengesforsearchbasedsoftwaretesting.In 2015IEEE8thInternational
Conference on Software Testing, Verification and Validation (ICST â€™15). 1â€“12.
[28]Mark Harman and Bryan F Jones. 2001. Search-based software engineering.
Information and software Technology (2001), 833â€“839.
[29]Mark Harman, S Afshin Mansouri, and Yuanyuan Zhang. 2012. Search-based
software engineering: Trends, techniques and applications. ACM Computing
Surveys (CSUR) (2012), 1â€“61.
[30]Mark Harman, Phil McMinn, Jerffeson Teixeira De Souza, and Shin Yoo. 2010.
Search based software engineering: Techniques, taxonomy, tutorial. In Empirical
software engineering and verification. 1â€“59.
[31]Gerard J. Holzmann, Rajeev Joshi, and Alex Groce. 2011. Swarm Verification
Techniques. IEEE Transactions on Software Engineering (2011), 845â€“857.
[32]W.E.Howden.1977. SymbolicTestingandtheDISSECTSymbolicEvaluation
System.IEEE Transactions on Software Engineering (1977), 266â€“278.
[33]FrankHutter,HolgerHHoos,KevinLeyton-Brown,andThomasStÃ¼tzle.2009.
ParamILS:anautomatic algorithmconfigurationframework. JournalofArtificial
Intelligence Research (2009), 267â€“306.
[34]JoxanJaffar,VijayaraghavanMurali,andJorgeA.Navas.2013. BoostingConcolic
Testing viaInterpolation. In Proceedings ofthe 9thJoint Meetingon Foundations
of Software Engineering (ESEC/FSE â€™13). 48â€“58.
[35]Xiangyang Jia, Carlo Ghezzi, and Shi Ying. 2015. Enhancing Reuse of Constraint
SolutionstoImproveSymbolicExecution.In Proceedingsofthe2015International
Symposium on Software Testing and Analysis (ISSTA â€™15). 177â€“187.
[36]Yue Jia, Myra B. Cohen, Mark Harman, and Justyna Petke. 2015. Learning Com-
binatorialInteractionTestGenerationStrategiesUsingHyperheuristicSearch.In
Proceedings of the 37th International Conference on Software Engineering - Volume
1 (ICSE â€™15). 540â€“550.
[37]TimotejKapus,FrankBusse,andCristianCadar.2020. PendingConstraintsin
SymbolicExecutionforBetterExplorationandSeeding.In Proceedingsofthe35th
IEEE/ACM International Conference on Automated Software Engineering (ASE â€™20).
115â€“â€“126.
[38]Timotej Kapus and Cristian Cadar. 2019. A Segmented Memory Model for Sym-
bolic Execution. In Proceedings of the 2019 27th ACM Joint Meeting on European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (Tallinn,Estonia) (ESEC/FSE2019).AssociationforComputingMa-
chinery, New York, NY, USA, 774â€“784. https://doi.org/10.1145/3338906.3338936
[39]TimotejKapus,MartinNowack,andCristianCadar.2019.ConstraintsinDynamic
Symbolic Execution: Bitvectors or Integers?. In Tests and Proofs, Dirk Beyer and
Chantal Keller (Eds.). Springer International Publishing, Cham, 41â€“54.
[40]RichardMKarp.1972. Reducibilityamongcombinatorialproblems. In Complexity
of computer computations. 85â€“103.
[41]James C. King. 1976. Symbolic Execution and Program Testing. Commun. ACM
19, 7 (1976), 385â€“394.
[42]YavuzKoroglu,AlperSen,OzlemMuslu,YunusMete,CeydaUlker,TolgaTan-
riverdi, and Yunus Donmez. 2018. QBE: QLearning-based exploration of android
applications. In 2018 IEEE 11th International Conference on Software Testing, Veri-
fication and Validation (ICST â€™18). 105â€“115.
[43]Min Li, Liangzhao Zeng, Shicong Meng, Jian Tan, Li Zhang, Ali R. Butt, and
NicholasFuller.2014. MRONLINE:MapReduceOnlinePerformanceTuning.In
Proceedingsofthe23rdInternationalSymposiumonHigh-PerformanceParalleland
Distributed Computing (HPDC â€™14) . 165â€“176.
[44]XinLi,YongjuanLiang,HongQian,Yi-QiHu,LeiBu,YangYu,XinChen,and
Xuandong Li. 2016. Symbolic Execution of Complex Program Driven by Ma-
chineLearningBasedConstraintSolving.In Proceedingsofthe31stIEEE/ACM
International Conference on Automated Software Engineering (ASE â€™16). 554â€“559.
[45]YouLi,ZhendongSu,LinzhangWang,andXuandongLi.2013. SteeringSymbolic
Execution to Less Traveled Paths. In Proceedings of the 2013 ACM SIGPLAN
InternationalConferenceonObjectOrientedProgrammingSystemsLanguages,and
Applications (OOPSLA â€™13). 19â€“32.
[46]PhilMcMinn.2011. Search-basedsoftwaretesting:Past,presentandfuture.In
2011 IEEE Fourth International Conference on Software Testing, Verification andValidation Workshops. 153â€“163.
[47]Sergey Mechtaev, Alberto Griggio, Alessandro Cimatti, and Abhik Roychoud-
hury.2018. SymbolicExecutionwithExistentialSecond-OrderConstraints.In
Proceedingsofthe201826thACMJointMeetingonEuropeanSoftwareEngineeringConference and Symposium on the Foundations of Software Engineering (ESEC/FSE
â€™18). 389â€“399.
[48]M.Nowack.2019. Fine-GrainMemoryObjectRepresentationinSymbolicExe-
cution.In 201934thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (ASE). 912â€“923.
[49]OSDIâ€™08_Coreutil_Experiments. 2008. https://klee.github.io/docs/coreutils-
experiments.
[50]Awanish Pandey, Phani Raj Goutham Kotcharlakota, and Subhajit Roy. 2019.
Deferred Concretization in Symbolic Execution via Fuzzing. In Proceedings of the
28th ACM SIGSOFT International Symposium on Software Testing and Analysis
(ISSTA â€™19). 228â€“238.
[51]Corina S PÄƒsÄƒreanu and Neha Rungta. 2010. Symbolic PathFinder: symbolic exe-
cution of Java bytecode. In Proceedings of the IEEE/ACM international conference
on Automated software engineering (ASE â€™10). 179â€“180.
[52]David M. Perry, Andrea Mattavelli, Xiangyu Zhang, and Cristian Cadar. 2017.
Accelerating Array Constraints in Symbolic Execution. In Proceedings of the 26th
ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA
â€™17). 68â€“78.
[53]KoushikSen,DarkoMarinov,andGulAgha.2005. CUTE:AConcolicUnitTestingEngineforC.In Proceedingsofthe10thEuropeanSoftwareEngineeringConference
Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of
Software Engineering (ESEC/FSE â€™05) . 263â€“272.
[54]HyunminSeoandSunghunKim.2014. HowWeGetThere:AContext-guided
Search Strategy in Concolic Testing. In Proceedings of the 22nd ACM SIGSOFT
International SymposiumonFoundations ofSoftware Engineering (FSEâ€™14) .413â€“
424.
[55]ShiqiShen,ShwetaShinde,SoundaryaRamesh,AbhikRoychoudhury,andPra-
teek Saxena. 2019. Neuro-Symbolic Execution: Augmenting Symbolic Execution
withNeuralConstraints..In ProceedingsoftheSymposiumonNetworkandDis-
tributed System Security (NDSS â€™19).
[56]Jiri Slaby, Jan StrejÄek, and Marek TrtÃ­k. 2013. Symbiotic: synergy of instrumen-
tation, slicing, and symbolic execution. In International Conference on Tools and
Algorithms for the Construction and Analysis of Systems (TACAS â€™13). 630â€“632.
[57]HelgeSpieker,ArnaudGotlieb,DusicaMarijan,andMortenMossige.2017. Re-
inforcement Learning for Automatic Test Case Prioritization and Selection in
ContinuousIntegration.In Proceedingsofthe26thACMSIGSOFTInternational
Symposium on Software Testing and Analysis (ISSTA â€™17). 12â€“22.
[58]Chameleon.Atoolthatperformsconcolictestingwithadaptivelychangingsearch
heuristics. 2019. https://github.com/kupl/chameleon.
[59]ThomasTorsney-Weir,AhmedSaad,TorstenMoller,Hans-ChristianHege,Britta
Weber, Jean-MarcVerbavatz, andStevenBergner. 2011. Tuner:Principled param-
eter finding for image segmentation algorithms using visual response surfaceexploration. IEEETransactionsonVisualizationandComputerGraphics (2011),
1892â€“1901.
[60]David Trabish, Andrea Mattavelli, Noam Rinetzky, and Cristian Cadar. 2018.
Chopped Symbolic Execution. In Proceedings of the 40th International Conference
on Software Engineering (ICSE â€™18). 350â€“360.
[61]Dana Van Aken, Andrew Pavlo, Geoffrey J. Gordon, and Bohan Zhang. 2017.
Automatic Database Management System Tuning Through Large-Scale Machine
Learning.In Proceedingsofthe2017ACMInternationalConferenceonManagement
of Data (SIGMOD â€™17). 1009â€“1024.
[62]Xinyu Wang, Jun Sun, Zhenbang Chen, Peixin Zhang, Jingyi Wang, and Yun Lin.
2018. Towards Optimal Concolic Testing. In Proceedings of the 40th International
Conference on Software Engineering (ICSE â€™18) . 291â€“302.
[63]E. Wong, L. Zhang, S. Wang, T. Liu, and L. Tan. 2015. DASE: Document-
Assisted Symbolic Execution for Improving Automated Software Testing. In
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering (ICSE
â€™15). 620â€“631.
[64]BoweiXi,ZhenLiu,MukundRaghavachari,CathyH.Xia,andLiZhang.2004.
ASmartHill-ClimbingAlgorithmforApplicationServerConfiguration.In Pro-
ceedings of the 13th International Conference on World Wide Web (WWW â€™04).
287â€“296.
[65]Guowei Yang, Corina S PÄƒsÄƒreanu, and Sarfraz Khurshid. 2012. Memoized sym-
bolicexecution. In Proceedingsof the2012InternationalSymposium onSoftware
Testing and Analysis (ISSTA â€™12). 144â€“154.
[66]Qiuping Yi, Zijiang Yang, Shengjian Guo, Chao Wang, JianLiu, and Chen Zhao.
2018. Eliminating Path Redundancy via Postconditioned Symbolic Execution.
IEEE Transactions on Software Engineering (2018), 25â€“43.
2079
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:53:04 UTC from IEEE Xplore.  Restrictions apply. 