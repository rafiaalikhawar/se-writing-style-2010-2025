Utilizing Parallelism in Smart Contracts on Decentralized
Blockchains by Taming Application-Inherent Conflicts
PÃ©ter GaramvÃ¶lgyi
peter.garamvolgyi@confluxnetwork.org
Shanghai Tree-Graph Blockchain
Research Institute
Shanghai, ChinaYuxi Liuâˆ—
yuxi.liu@duke.edu
Duke University
Durham, North Carolina, USADong Zhou
dongz@mail.tsinghua.edu.cn
Tsinghua University
Beijing, China
Shanghai Qi Zhi Institute
Shanghai, China
Fan Long
fanl@cs.toronto.edu
University of Toronto
Toronto, Canada
Shanghai Tree-Graph Blockchain
Research Institute
Shanghai, ChinaMing Wu
ming.wu@confluxnetwork.org
Shanghai Tree-Graph Blockchain
Research Institute
Shanghai, China
ABSTRACT
Traditional public blockchain systems typically had very limited
transaction throughput because of the bottleneck of the consensus
protocol itself. With recent advances in consensus technology, the
performance limit has been greatly lifted, typically to thousands
of transactions per second. With this, transaction execution hasbecomeanewperformancebottleneck.Exploitingparallelismin
transaction execution is a clear and direct way to address this and
to further increase transaction throughput. Although some recent
literature introduced concurrency control mechanisms to execute
smartcontracttransactionsinparallel,thereportedspeedupthat
they can achieve is far from ideal. The main reason is that theproposed parallel execution mechanisms cannot effectively deal
with the conflicts inherent in many blockchain applications.
Inthiswork,wethoroughlystudythehistoricaltransactionexe-
cution traces in Ethereum. We observe that application-inherent
conflicts are the major factors that limit the exploitable parallelism
during execution. We propose to use partitioned counters and spe-
cialcommutativeinstructionstobreakuptheapplicationconflict
chains in order to maximize the potential speedup. When we eval-uated the maximum parallel speedup achievable, these techniques
doubled this limit to an 18x overall speedup compared to serial
execution, thusapproaching the optimum. We alsopropose OCC-
DA,anoptimisticconcurrencycontrolschedulerwithdeterministic
aborts, which makes it possible to use OCC scheduling in public
blockchain settings.
âˆ—Work done while employed at Shanghai Qi Zhi Institute.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510086CCS CONCEPTS
â€¢Computing methodologies â†’Parallel algorithms; Concur-
rentcomputingmethodologies;â€¢Softwareandits engineer-
ingâ†’Software performance.
KEYWORDS
blockchain, distributed ledgers, smart contracts, parallel execution,
optimistic concurrency, deterministic concurrency
ACM Reference Format:
PÃ©ter GaramvÃ¶lgyi, Yuxi Liu, Dong Zhou, Fan Long, and Ming Wu. 2022.
UtilizingParallelisminSmartContractsonDecentralizedBlockchainsby
Taming Application-Inherent Conflicts. In 44th International Conference on
Software Engineering (ICSE â€™22), May 21â€“29, 2022, Pittsburgh, PA, USA. ACM,
New York, NY, USA, 12 pages. https://doi.org/10.1145/3510003.3510086
1 INTRODUCTION
The technical challenge of scaling permissionless blockchains has
been a hot research topic for the last few years. With various scal-
ing solutions, be it Ethereum 2.0â€™s sharding [ 24] or Confluxâ€™s Tree-
Graphledgerstructure[ 19],theconsensusmechanismceasestobe
theperformancebottleneck.WhilediskI/O,networkbandwidth,
and transaction execution are all possible sources of contention,
transactionexecutionisarguablythemostchallengingonetoad-
dress.
Distributed ledgers that follow the account model originally
introduced by Ethereum are designed to reach consensus on a
sequence of transactions, then process them serially. As a result,
currentprotocolsandtheirimplementationsareunabletomakeuse
of multiple threads on multi-core processors during this execution
step.Giventhedependenciesbetweentransactionsthroughtheir
accesses to a shared data structure called the state tree, the first
challenge is to understand how much speedupwe canpotentially
achieve byexecuting them inparallel. Then, thesecond challenge
istodesignaparallelschedulerwithsufficientdeterminismsothat
nodes can reach consensus.
23152022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA PÃ©ter GaramvÃ¶lgyi, Yuxi Liu, Dong Zhou, Fan Long, and Ming Wu
To understand the degree of parallelism that can be utilized
in existing transaction workloads, this paper empirically studied
a period of historical Ethereum transactions. Taking state access
traces(perfectinformation),transactiongascosts,andthedegree
ofparallelismofcomputingresources(e.g.,32threads)asinputs,
we constructed an optimal schedule for each block, then compared
its execution time to that of serial execution. Our major findings
include:
(1)Theoverallspeedupachievableislimitedatabout4xcom-
paredtoserialexecution.Whiletherearemanyblockswhoseexecution scales with the number of threads, a large portion
of blocks performs significantly worse. These results are
consistent with previous works [23, 25].
(2)Most blocks are bottlenecked on a single chain of depen-
dent transactions that need to be executed serially and thus
dominate the overall execution time.
(3)Amanualinspectionofthebottlenecktransactionsshows
thatmostofthemconflictonasinglecounterorarray.From
the applicationâ€™s perspective, most bottleneck transactions
can be classified into one of three categories: token distribu-
tion, collectibles, and decentralized finance.
Theempiricalstudyresultssuggestthat,insteadofoptimizing
scheduler implementations, our primary focus should be on elimi-
natingthesecommonsourcesofcontentioninsmartcontracts.In
thispaper,wepresentthreeindependenttechniquesforeliminating
theaforementionedbottlenecks.Orthogonaltothesetechniques,
we also present a novel scheduling framework called optimistic
concurrency control with deterministic aborts (OCC-DA). Parallel
schedulersthatfollowthisframeworkcancomplywiththestrin-
gent determinism requirements of distributed consensus.
The first, simplest approach to eliminating bottlenecks is to use
multiplesenderaddresses.Bymanuallydividingasetoftransac-
tions from a single sender to multiple disjoint sets of transactions,
many common bottleneck patterns can be eliminated.
The second approach is to use partitioned counters, similar to
sloppycounters,originallyintroducedbyBoyd-Wickizeretal.[ 5]
for the Linux kernel. In this approach, we maintain several sub-counters, the sum of which constitutes the value of the original
counter.Writesareroutedtoandoperateondifferentsub-counters
based on some attribute, e.g., the senderâ€™s address. This way, parti-
tioned counters reduce the probability that any two writing trans-
actions will conflict.
The third approach to addressing bottlenecks is to bypass avoid-
able conflicts arising from commutative updates on the virtual
machine level. Two transactions that both increment a counter but
donotuseitsoriginalvaluearesemanticallycommutative.How-
ever, under the current Ethereum Virtual Machine semantics such
increments are translated into a read ( SLOAD) and a write ( SSTORE)
instruction which will lead to read-write conflicts. We propose a
new instruction called CADD(commutative add). Two transactions
that only have CADDoperations but no other reads and writes on
agivenstateentryarenotconsideredconflicting.Incrementsare
applied during transaction commit serially.
Our evaluations suggest that these approaches can raise the
amount of speedup achievable to 18x or more, making it approach
the optimal case where all transaction dependencies are ignored.We also note that the non-determinism that is characteristic of
parallelexecutionmightpreventblockchainnodesfromreaching
consensus. A set of incentives for goodbehavior (i.e., following the
protocol)anddis-incentivesfor badbehavior(i.e.,attackingormis-
usingtheprotocol)isanessentialpartofpermissionlessblockchains.
Ethereum and similar systems offer no incentive to write smartcontracts or pack blocks in a way that improves transaction par-
allelizability.The numberofconflictsand/ortransactionabortsis
a metric of parallelizability that the incentive layer could use to
assign financial rewards and penalties. However, under traditional
approaches like optimistic concurrency control (OCC) [ 17], even if
weenforceadeterministiccommitorder,theactualexecutionon
differentnodesmightstilldiverge.Thiswouldleadtodifferences
inthismetricondifferentnodesandthusitwouldpreventnodes
from reaching consensus.
To address this issue, we introduce an optimistic scheduler with
deterministic transaction aborts. To our knowledge, this algorithm
is the first of its kind, mostly because distributed ledgers have
morestringentdeterminismrequirementsthanmostotherdomains.
Basedonourevaluation,thisapproachallowsustointroducein-
centives for parallelizability in exchange for a performance impact
that is, on average, acceptable.
In summary, the major contributions of this paper are recogniz-
ing that certain common application-inherent transaction conflicts
leadtobottlenecksunderparallelexecution,providingasetofef-
fectivetechniquestodealwiththese,andofferingadeterministic
scheduling algorithm that makes it possible to incentivize better
parallelism.
2 BACKGROUND AND MOTIVATION
Bitcoin [20] introduced blockchains with the goal of supporting
cryptocurrency paymenttransactionswithoutrelyingonanycen-
tral authority. Such a public blockchain is a distributed ledgermaintained by a peer-to-peer network in a trustlessandpermis-
sionlessway. The core piece of this technology is its consensus
protocol,Nakamoto consensus, that probabilisticallyguaranteesthe
irreversibility of transactions in decentralized public settings, even
under adversarial conditions. The ledger is composed of a chain
ofblocks,eachofwhichcontainsasequenceoftransactions,and
replicated among all the participant nodes. Each block is generatedby aminerthrough some Proof-of-Work mechanism, chained at the
tail of the valid chain in the minerâ€™s view, and broadcast to all the
othervalidator nodes through a peer-to-peer gossip network. Due
tothelatencyofblockpropagationinthenetwork,multipleminers
maygenerateblocksconcurrentlywithoutseeingtheothers,and
hence may introduce forksinto the ledger. The Nakamoto consen-
sus employs the longest chain rule to let all the honest nodes agree
on the valid chain and execute the transactions according to the
orderoftheblocksinthechainandtheorderofthetransactions
in each block. The miner of each block on the valid chain gets a
certainamountofbitcoinasarewardfromthesystem.Thesecurity
guarantee is achieved when forks are rare and the ledger basically
formsasinglechain.Inordertoavoidforks,theBitcoinprotocol
dictates a very low block generation rate in the entire network,
which seriously limits its throughput. Specifically, Bitcoin can only
achieve a throughput of 7 transactions per second (tps).
2316
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Utilizing Parallelism in Smart Contracts on Decentralized Blockchains by Taming Application-Inherent Conflicts ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
EthereumextendsBitcoinwithsupportforaTuring-complete
programming framework, and the Solidity programming language,
whichallowsdeveloperstoimplementcomplex decentralizedap-
plications. This makes it possible to apply blockchain in industries
likefinancialsystems,supplychains,andhealthcare[ 7,8,15].In
Ethereum,the stateresultingfromtransactionexecutionismain-
tained in the form of a Merkle tree. Ethereum adopts an account
modelinitsstate.Therearetwotypesofaccounts: useraccounts
andsmartcontract accounts.A useraccountis associated withits
etherbalanceinformationwhileeachsmartcontractaccountfurther
has an associated executable code and its own storage represented
as a collection of key-value pairs maintained in the Merkle tree.
Eachtransactionoccursbetweena senderaccountanda recipient
account. The majority of transactions are one of two kinds: either
avalue transfer , which is a purely monetary transfer of etherfrom
sender to recipient, or a contract call, where the sender account
triggersexecutionofthecodeassociatedwiththerecipientaccount.
During its execution, a contract call transaction can call functions
ofother smartcontracts.To ensurethat transaction executionter-
minates, each computational step incurs a cost denominated in gas,
paid by the transaction sender. The sender specifies a maximum
amountofgasitiswillingtopay(gaslimit ),andifthechargeex-
ceedsthisvalue,thecomputationisterminatedandrolledback,and
thesenderâ€™sgasisnotrefunded.Thesmartcontractcodeconsists
of a sequence of bytecode instructions that can be interpreted and
executedbythe EthereumVirtualMachine (EVM)tomanipulatethe
stateoftheMerkletreebyupdatingthevaluesofthecorresponding
keys.Everybytecodeinstructionconsumesacertainamountofgas.
Smart contracts developed using Solidity are compiled into such
bytecode sequence before they are published into the blockchain.
LikeBitcoin,EthereumalsoemploysNakamotoconsensus,al-
though with some different system parameters, e.g., block size,
blockgenerationrate,etc.Itimprovesthetransactionthroughput
to about 30 tps but the consensus still remains the major perfor-
mance bottleneck. In this situation, it makes sense that the EVM is
designedasasingle-threadenginewithouttheneedtointroduce
parallelism into the transaction execution.
To overcome the throughput bottleneck of Nakamoto consen-
sus, many new and more advanced consensus protocols have been
proposedinrecentyears[ 3,12,13,18,19,22,27,28,32].Theseproto-
colsexplorealternativestructurestoorganizeblocks,e.g.,DAG-like
structure,togetherwithsomenoveldeterministicblockordering
schemes to allow faster global block generation rate without com-
promising the decentralization and security of the network, and
hencetheconsensusmechanismceasestobethesystembottleneck.
Forexample,bothConflux[ 19]andOHIE[ 32]areabletoprocess
simple payment transactions with a throughput of more than 5000
tps,severalordersofmagnitudesfasterthantheoriginalNakamoto
consensus.FurtherresearchworklikeShrec[ 14]alsostudiesand
developsanewtransactionrelayprotocolthatcanmoreeffectivelyutilizethenetworkbandwidthtopreventitfrombecomingthenew
system bottleneck under high transaction throughput scenarios.
These techniques shift the throughput bottleneck of blockchain
systems to the transaction and smart contract execution, therefore,
introducethepressingneedfornewtechnologiesthatcanexploit
the parallelism and increase the efficiency of transaction execution.Somerecentresearchworks[ 2,4,9,10,21,23,25,33]haveex-
ploredthedesignsofaparallelsmartcontractvirtualmachineby
integrating various mechanisms of concurrency control. However,
according to the reported results, the speedup that can be achieved
by these proposed solutions is far from linear when applied to the
real Ethereumworkload. We observed thatthis is mainlybecause
of the lack of inherent parallelism in the real-world workload itself.
For example, by investigating the historical Ethereum workload,
we found that many critical paths of a series of transactions that
have to be executed sequentially are caused by the use of sharedglobal counters. We believe that the essential way to further im-prove significantly the inherent parallelism of the real workload
is to introduce a better programming paradigm that can allow the
developers to express parallelism more easily while keeping the
originalsemantics.Inaddition,inthedecentralizedenvironment,
driving users to adopt a new paradigm is not that straightforward,
as it may incur extra costs, from either the engineering or theeconomics considerations. Therefore, some new design of incen-tive mechanisms is required to make the paradigm applicable to
real-world applications.
3 EMPIRICAL STUDY
Whatspeedupshouldweexpec twhenweexecuteblockchaintrans-
actions in parallel? To answer this question, we designed an empir-
ical study using a dataset of historical Ethereum transactions.
3.1 Methodology
We empirically studied the amount of parallelism present in a real-
worlddatasetusinghistoricalEthereumtransactions.Tothisday,
Ethereumremainsthebackboneofthedecentralizedapplicationecosystem. As such, this workload represents the most common
smartcontractinteractionscenarios,andthefindingscanbegener-
alizedtomanyothersystems.Ourexperimentmainlyfocuseson
theperiodbetweenJan-01-2018andMay-28-2018(858 ,236blocks
intotal),seeSections3.3and7foramoredetailedjustificationof
the dataset used.
Thesubjectofthisexperimentissmartcontractstorageconflicts,
i.e., cases where two transactions within the same block access the
same entry in the state tree, and at least one of these accesses isa write. To obtain these results, we ran an OpenEthereum node
(formerlyParity)modifiedsothatittracksandstoresallcontract
storage accesses. We stored these traces for blocks #1to#5692235
in a local database. In this experiment, other kinds of conflicting
accesses (e.g., conflicts on the account balance) are not considered.
Giventhattheexecutiontimeoftransactionsisunknownand
might vary from node to node, we used the transaction gas cost,
obtained from the transaction receipt, as an approximation of this.
This follows the practice of a number of related works [23, 25].
Giventhe transactiondependenciesderived fromtheirstate ac-
cess tracesand thegas costsof thetransactions, weconstructed a
dependencygraphforeachblock.Then,simulatingnon-preemptive
execution on 2, 4, 8, 16, and 32 threads, we constructed an optimal
scheduleforeachblock,i.e.,aschedulethatensuresthatnotransac-tionneedstoabortwhilealsomaximizingthreadutilization.Under
this execution model, the overall execution cost of this schedule
puts an upper bound on the potential speedup that we can achieve;
2317
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA PÃ©ter GaramvÃ¶lgyi, Yuxi Liu, Dong Zhou, Fan Long, and Ming Wu
any other schedule might either need to abort and re-execute con-
flicting transactions, or delay execution through locking. Apart
from the overall execution cost (as approximated through the over-
all gas cost), we also inspected the heaviest path in the transaction
dependency graph.
3.2 Results and Findings
Execution Bottlenecks. The experiment shed some light on the
limitsofspeedupwecanexpecttoachievewhenexecutingEthereum
transactionsinparallel. We foundthat theoverall speedupon the
observed period wasonly 4x compared to theserial execution, an
underwhelming result considering that we had 8, 16, or even more
threads available. A closer look at the per-block results shows that
in fact, manyblocks have much higherspeedups, but a significant
portion of blocks perform poorly (see Figure 1).
Figure1:Distributionofparallelspeedupbounds
When comparing the execution cost of a block to the execution
cost of the heaviest path in its dependency graph, we found that
thesetwooftencoincide.Thismeansthattheoverallexecutionis
bottlenecked on the execution of the heaviest path. When we look
at single blocks, this heaviest path is often just a single transaction:
When, for example, a block has many simple payment transac-
tionsandoneexpensivesmartcontractcallthatexecuteshundreds
of token transfers, then this latter transaction will dominate the
execution time.
Under our non-preemptive scheduler model and the inherently
serial execution model of the EVM, there is no easy way to handle
suchsingle-transactionbottlenecks.Ourfocus,instead,isfinding
effective ways to handle bottleneck chains of two or more transac-
tions. To focus on these, we re-ran our experiment with batches of
consecutive blocks as the unit of execution, instead of just a single
block.Theideaisthat,giventhousandsoftransactions,therelative
weightofasingletransactionwillbemuchsmaller.Thesameexper-
iment, executed on batches of 30 blo cks, shows an overall speedup
of9.46xcomparedtoserialexecution. Inthiscase,we observedthe
same result: Batches are often bottlenecked on a single chain of
tens or sometimes hundreds of dependent transactions.We further examined the impact of these bottleneck transaction
chains by re-running the experiment, while ignoring conflicts aris-
ing from these smart contracts. The result is an overall speedup of
23.8x compared to serial execution. These results show that bottle-
necktransactionsnotonlyhaveacrucialimpactontheparallelismofourdataset,butalsothatbybreakingupthesedependencychains,
wecanpotentiallyachievesignificantlyhigherspeedups.
ClassificationofSmartContractConflicts. Togainabetterunder-
standingofsmartcontractbottlenecks,wecollectedtheprimary
bottlenecktransactionchainsforeach30-blockbatch,andcollectedthebatchesthathaveaspeedupboundof10xorless(3242intotal).
Then, we selected a random sample of 200 batches and analyzed
them manually. Table 1 shows selected examples from this sample.
In terms of application types, we identified three broad cate-
gories:ERC20 tokens (token distribution, airdrops) accounted for
60% of the bottlenecks in our sample, Decentralized Finance (DeFi)
applicationsmadeup29%,while gamesandcollectibles (non-fungible
tokens, NFTs [11]) were the cause in 10% of the cases.
In most cases, ERC20 tokens lead to conflicts when there are
several token transfers over multiple transactions that distribute
tokensfromthesamesenderaddress.Transactionsmightalsohave
other dependencies, for instance, the total supply is updated every
time new tokens are minted. While ERC20 token distributions are
heterogeneousintheirimplementation(e.g.,theyusevariousinter-faceslike
transfer ,multiTransfer ,batchTransfer ,multisend ,
aidrop), these all result in similar conflict patterns.
In DeFi applications like IDEX and Bancor, a common source of
conflict is the fee account whose token balance gets updated for
everytrade.InthecaseofIDEX,themajorityoftradesinvolveETH,
so they all increment the ETH balance of the IDEX fee account.
Examplesforgamesandcollectibles(NFTs)includeCryptoKit-
ties, Etheremon, and IdleEth. These often involve some globally
sharedcounters,likethenumberofkittiesinthecaseofCryptoKit-
ties. Maintaining an array of game items is also common. When a
game involves payments and rewards, the fee recipient and reward
sender accountâ€™s balance might also lead to storage conflicts.
Intermsofthesourceofconflicts,wefoundthatin194of200
batches (97%) the root cause is one or more counters that get incre-
mented(or decremented)by differenttransactions.In oursample,
theothercommonsourceofconflicts,arrays,onlyaccountedfor
about 2% of the cases.
BottleneckCodeExamples. Asanexampleforcounterconflicts
intokendistributions,letusdiscusstheexampleinListing1.When
calling transfer , the senderâ€™s balance ( balances[msg.sender] )
is debited, while the recipientâ€™s balance is credited. The senderâ€™sbalance corresponds to one specific storage location in the statetree. The debit operation will compile to a load (
SLOAD), an add
(ADD), and a store ( SSTORE) operation, among others. When two
transactions trigger this function from the same sender address
concurrently, this will result in a conflict.
1function transfer (address _to, uint256 _val) /* ... */ {
2 balances[ msg.sender ] -= _val; // <<<
3 balances[_to ] += _val;
4 // ...
5}
Listing 1: Solidity counters (source: ConsenSys EIP20.sol)
2318
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Utilizing Parallelism in Smart Contracts on Decentralized Blockchains by Taming Application-Inherent Conflicts ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 1: Examples for bottleneck root causes from our 200-batch random sample
block batch contract contract type method(s) conflict type conflict source
5536219-5536248 Storj ERC20 transfer (STORJ) counter same sender account
5559949-5559978 Free BOB Tokens ERC20 airdrop (BOBx) counter totalSupply
5497669-5497698 IDEX DeFi trade, adminWithdraw counter ETH fee account balance
5493409-5493438 Bancor DeFi quickConvert counter Bancor (BNT) fee recipient
5562289-5562318 CryptoKitties: Core games/NFT breedWithAuto counter pregnantKitties++
5562409-5562438 Mythereum Card games/NFT mintSpecificCards array cards.push(card)
Let us look at another example, this time for arrays and col-
lectibles(Listing2).InthepopularCryptoKittiesEthereumgame,
eachnewcollectibleisstoredinanarray.The pushoperationon
Solidityarrayswillmodifytwostorageentries:First,itwillstore
the new item at a location derived from the arrayâ€™s length, and
second,itwillincrementitslength.Twoconcurrenttransactions
will both modify the array length and as such, they will conflict.
1function _createKitty( /* ... */ )/* ... */ {
2 uint256 newKittenId = kitties. push (_kitty) - 1; // <<<
3 // ...
4}
Listing 2: Solidity arrays (source: CryptoKitties)
3.3 Generalizability of the Observations
Our evaluations are based on a relatively narrow period of the
Ethereum transaction history. This is because acquiring the en-tire transaction dataset and generating storage access traces is
extremely resource-consuming, both in terms of storage and time.
Webelievethechosenperiodisrepresentativeoftodayâ€™sEthereum
workload and so our findings are generalizable. The application
patterns we observed (DeFi, NFT, token distributions) are evenmore dominant today. Contract developers have no incentive toaddress common storage bottlenecks. In fact, just by a cursoryglance, we can spot storage conflicts in many recent popular ap-plications: Uniswap exchanges that involve the same token will
always conflict on the counters that represent token reserves (con-
tract UniswapV2Pair ). Similarly, OpenSea trades will transfer to-
kenstothesame protocolFeeRecipient .Thissuggeststhatthe
conflicts we identified are even more common today.
4 AVOIDING APPLICATION INHERENT
CONFLICTS
As we have seen in Section 3, a large portion of storage conflicts
is associated with storage slots that belong to either counters orarrays. By counterhere we mean a variable that one can use to
track a quantity by incrementing or decrementing it, regardless of
its current value. Arraysin Solidity are a simple data structure that
stores a sequence of elements, along with the number of elements.
Intheory,atransactiondependencychaincouldinvolvemultiple
conflictingstorageslots.Forinstance,thechain #a <â€“ #b <â€“ #c
couldmeanthat #aand#bconflictonacounter,while #band#c
conflictonanunrelatedarray.In practice,however, thisisrarely
thecase.Mosttransactionsinaconflictchain willexecutesimilar
operationsandwillconflictonthesamestorageentryorentries.In
this case, dependencies are transitive, i.e., #cwill conflict with #a.Toalleviatetheimpactofthesetransactionbottleneckchains,we
needtobreak them up into multiple shorter chains by eliminating
dependencies between subsets of the transactions involved (see
Figure2).Weproposethreetechniquestoachievethis.Asarrays
only account for a small fraction of storage bottlenecks (Section
3.2), we will focus on counters in this section.
Technique 1: Conflict-Aware Token Distribution. Inoureval-
uations, we saw that token distributions (token sales, airdrops) are
by far the most common sources of bottleneck conflicts. In themajority of cases, the source of conflict is the storage entry that
stores the sender accountâ€™s current balance.
Thesimplestwaytoaddressthesecommonbottlenecksistouse
multiple sender addresses. By distributing the initial funds (where
applicable)to asetof senderaccountsinstead ofasingle account,andusingdifferentsenderaddressesforconsecutivetransactions,
wecandividethesetofbottlenecktransactionsintodisjointsetsof
conflicting transactions, each less likely to form a bottleneck.
Ofcourse,thefeasibilityofthisapproachdependsonthespecific
implementationofthetoken.Sometokenshaveotherdependencies:
for instance,the total supply oftokens might alsobe incremented
eachtimenewtokensareminted.Inthepresenceofsuchdepen-
dencies, we need a more sophisticated and general approach.
Figure 2: Breaking up a conflict chain into multiple disjoint
conflictchains.Onthetopofthefigure,alongconflictchain
requires transactions #1-#2-#3-#7-#8-#9to be scheduled seri-
ally on the same thread, dominating the overall executiontime. By breaking up this chain into two (
#1-#3-#7-#8and
#2-#9), each resulting chain will still need to be executed se-
rially, but the two chains can be executed in parallel to each
other.Thisallowsustoachieveamuchhigherspeedup.
2319
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA PÃ©ter GaramvÃ¶lgyi, Yuxi Liu, Dong Zhou, Fan Long, and Ming Wu
Technique 2: Partitioned Counters. Using a technique similar
tosloppy counters widely used in the Linux kernel [ 5], we propose
a way to route multiple writes on the same counter to multiple
distinct storage entries. As writes to different storage entries do
not conflict, this technique can drastically reduce the conflict rate.
ThemainideaofpartitionedcountersisshowninListing3.Here
wehaveasinglecontractthatrepresentsacounterinstance.The
valueofthecounterisactuallymaintainedon3separatestorage
entries called sub-counters. Each time a transaction modifies the
counterâ€™svalue,weassignasub-counterbasedonthetransactionâ€™ssender address.As addressesare derived usingcryptographichash-ing,thiscanbeviewedasapseudorandomsub-counterassignment.
Whenreadingthevalueofthecounter,allsub-countersareaccessed
and their values are summed.
1contract PartitionedCounter { // LEN = 3
2 int256 [LEN] public cnt;
3
4 function add( uint32 n)internal {
5 uint8 slot = uint8 (tx.origin ) % LEN;
6 cnt[slot] += n;
7 }
8
9 function get() internal view returns (int256 sum) {
10 for (uint8 i = 0; i < LEN; ++i) { sum += cnt[i]; }
11 }
12 }
Listing 3: Partitioned counters implemented in Solidity
Partitionedcountershaveseveraladvantages.First,agiventrans-
actionâ€™swriteswillalloperateonasinglestorageentry,evenifit
incrementsthecountermultipletimes,asthesenderaddressdoes
not change throughout the transactionâ€™s execution. Second, twotransactions from two distinct sender addresses that both incre-ment the counter have a much-reduced chance of operating on
thesamesub-counterandthusconflictsareoftenavoided.Third,
the counter can be adjusted based on the use case, e.g., for coun-ters used frequently one could use more sub-counters, and onecould use different criteria for routing transactions to different
sub-counters.Ourexampleroutestransactionsbasedonthesender
address (tx.origin) as this addresses common token conflicts.
Partitioned counters have two main drawbacks. First, while we
onlyneedtoaccessasinglestorageentryforwritingthecounter,
readingit willtouchallsub-counters.As aresult,anytransaction
that reads the counter will conflict with all writing transactions.
As such, this technique is suitable for write-heavy counters. Fortu-
nately,manyofthecountersweanalyzedareneverreadthrough
transactions.Second,partitionedcounterscanbesignificantlymore
expensive than built-in integers, especially when it comes to read-
ingthecounter.Thisdrawbackisoffsetbythepotentialincreasein
parallelspeedupthatpartitionedcountersoffer.Moreover,many
counters are rarely or never read in a transaction context.
Technique 3: Commutative EVM Instructions. Wehavedis-
cussedtwoapproaches.Oneoperatesonthe applicationlevel,i.e.,it
addressesconflictsbyintroducingspecificwaystointeractwiththeapplication.Theotheroperatesonthe smartcontractlevel,byoffer-
ingtoolstocontractdeveloperstoavoidconflicts.Athirdapproach
istotackleconflictsonthe virtualmachinelevel byextendingthe
protocol by new instructions that have better conflict tolerance.When the Ethereum Virtual Machine (EVM) executes an incre-
ment operation, it first loads the storage entryâ€™s current value into
memory( SLOAD),thenmodifiesthisvalue( ADD),andfinallyitstores
the end result back into the storage entry ( SSTORE). This behav-
ior originates from the Solidity compiler. As discussed before, two
transactions incrementing the same counter will both read and
write the same storage entry, and so they will conflict.
For counter increments, the current value is only used for calcu-
lating the new value, and otherwise it is irrelevant. Put in another
way, unlike other read-write conflicts, increments are commutative.
Two transactions that increment the same counter, but do not use
itsvalueotherwise,couldbeexecutedinanyorder.However,under
the current semantics of the EVM, such transactions will conflict.
We introduce special semantics for executing increments in a
way that does not result in conflicts. Rather than compiling in-
crements into SSLOADandSSTOREinstructions, they instead get
compiledintoasingle CADDinstructionthatstandsfor commutative
add. This instruction takes a storage location and a value as its
parameters.WhentheVMencountersa CADDinstruction,itdoes
not eagerly execute the addition, but instead, it records this opera-
tion in an in-memory temporary storage. If the VM encounters an
SSTOREoperation, it then erases the pending CADDinstructions on
thesamestoragelocationastheyhavebeenoverwritten.IftheVM
encounters an SLOADoperation, it then first executes all pending
CADDoperations on the same storage location, then uses the result
for this SLOAD.
After the transaction has been executed, the scheduler proceeds
tocheckforconflicts.Concurrentstoragereadsandwritestothe
same storage location constitute conflicts. If, however, two transac-
tionsonlyhave CADDoperationsonastoragelocation,butnoother
reads,thentheyarenotconsideredconflicting.Inthiscase,these
CADDoperations are executed serially during the commit phase.
Introducing a CADDinstruction for signaling commutative oper-
ations to the VM allows us to avoid a major class of transaction
conflicts that originate from operations on a single counter.
5 OCC WITH DETERMINISTIC ABORTS
5.1 Incentives in Parallel Scheduling
Permissionless blockchains have no central authority that could
enforce protocol compliance. Instead, protocol designers introduce
incentives that encourage goodbehavior (creating blocks, avoiding
storagebloat)andpenalize badbehavior(attacks).Theefficiencyof
parallelschedulersdependsonvariousfactors,someofwhichare
under the usersâ€™ control. Therefore, parallel execution must also
come with a set of incentives that maximize its effectiveness.
Adetaileddesignofsuchasystemofincentivesisbeyondthe
scopeofthispaper.Weobserve,however,thatanyincentivesystem
must be able to deal with spam or Denial of Service attacks that
target mispriced operations and resources in the system, as has
happened several times on Ethereum [ 6]. Parallel execution based
on OCC will inevitably lead to some transaction aborts and re-
executions.Ifthereisawayforuserstointentionallytriggeraborts
without any penalty, then that opens up the door to a serious
DoSvulnerabilityofthescheduler.Ourgoal,then,istodefinean
execution framework that would allow schedulers to deal with this
issue by deterministically pricing transaction re-executions.
2320
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Utilizing Parallelism in Smart Contracts on Decentralized Blockchains by Taming Application-Inherent Conflicts ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Figure 3: Classic OCC: Transactions
are committed right after execution,regardless of their order in the block.
This results in different commit orders
(#1-#2-#3-#4and#3-#2-#1-#4)andend
states might diverge.
Figure4:OCCwithdet.commitorder:
After execution, commit is delayed un-
tiltheprevioustransactionintheblock
has committed. The commit/abort de-
cisionforatransactionmightdiverge
on different nodes (#3).
Figure 5: OCC-DA: Transactions can
onlyseeaversionofthestatedecided
prior to execution, even if a more re-cent version is available. Each execu-
tionofatransactionwilleithercommit
or abort on all nodes.
5.2 Levels of Determinism
Parallelschedulersintroducealevelofnon-determinismintothe
execution,astheprecisetimingoftransactionsmightdifferfrom
nodetonode.Thisisindirectconflictwiththerequirementsofthe
consensusmechanism,whichreliesonstrictdeterminismforthe
nodes to converge into a consensus state. In blockchain systems,
therefore, parallel schedulers must maintain higher levels of deter-
minismcomparedtotraditionalalgorithms.Wedefinethefollowing
three levels of determinism in optimistic transaction execution.
(1)ClassicOCC:ClassicOCC[ 17]hasnodeterminismguar-
antees. Generally, transactions start execution on a first-
come-first-servedbasis.Node-localconsistencyistypically
ensuredbythepropertyof serializability,whichdictatesthat
theobservableresultsoftheparallelexecutionareequivalent
to those of someserial execution. However, ex ecution of the
sametransaction set ondifferentnodesmight correspondto
different serial executions and yield diverging results.
(2)OCC with deterministic commit order: Instead of dic-
tatingthattheparallelscheduleisequivalentto anyserial
schedule, it must correspond to a specificserial schedule.
Thismeansthatthefinalexecutionresultondifferentnodes
willbeequivalent,eventhoughtheactualexecutionmight
differ.Thisrequirementcanbesatisfiedbycommittingtrans-
actionsstrictlyaccordingtotheblocktransactionorder,or
by scheduling according to a dependency graph [2].
(3)OCC with deterministic aborts: While deterministic seri-
alizationorderguaranteesthattheobservableoutputs(there-sultingstate)arethesameacrossallnodes,theactualexecu-tionmightstilldiffer:Duetodifferenttimingoftransactions,
a transaction might be committed on one node, and aborted
on another. If the protocolrelies on this commit/abort deci-
sion to penalize aborts and avoid DoS attacks (see Section
5.1),thiswillleadtodivergingstates.Thus,thehighestlevelof determinism we aim for is when aborts themselves are
deterministic:ifatransactionisabortedonceononenode,
it is aborted exactly once on all the other nodes as well.
OCCwithdeterministiccommitorder isatopicwithconsiderable
researchattentionindeterministicdatabasesystems[ 1,29â€“31].On
the other hand, the stringent requirements of OCC with determinis-
tic aborts, to the best of our knowledge, have not been describedelsewhere. While imposing such restrictions on OCC schedulersmight certainly have a negative impact on the parallel speedup,
we argue it is crucial for implementing parallel schedulers under a
distributed consensus setting.
5.3 OCC-DA: OCC with Deterministic Aborts
OurexecutionmodelisbasedonOCCwith snapshotisolation.Trans-
actionsarescheduledonasetofthreadsforexecution.Executed
transactionsarecommittedaccordingtotheblocktransactionorder.
Atthestartofitsexecution,eachtransactionreceivesa snapshot
correspondingtotheversionofthestorageaftersometransactions
preceding it have been committed. This snapshot does not change
during the execution of the transaction. The highest transaction
idwhosecommittedwritesarepartofthissnapshotcorresponds
tothestorageversion ofthesnapshot,or,equivalently,thestorage
version of the transaction to-be-scheduled.
As an example, let us assume that transaction #1has been com-
mitted, transaction #2is being executed on one thread, and we
are scheduling transaction #3on another thread. In this case, #3
canseestorageversion #1(i.e.,thecontentsofstorageuptoand
including #1â€™swrites).If,duringtheexecutionof #3,#2modifies
some storage values, these updates are not visible to #3. If, during
thecommitof #3,theschedulerdetectsthatsomevaluesreadby #3
wereconcurrentlymodifiedby #2andthus #3operatedonoutdated
values, then #3is aborted and scheduled for re-execution.
In distributed consensus,transaction execution is deterministic:
The same code triggered with the same inputs (its parameters and
2321
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA PÃ©ter GaramvÃ¶lgyi, Yuxi Liu, Dong Zhou, Fan Long, and Ming Wu
thecurrentstate)willproducethesameoutputs.Fromthis,itiseasy
to see that a transaction executed over a specific storage version
(i.e.,thesamestate)ontwodifferentnodeswilleithercommiton
both or abort on both.
WethendefineOCC-DAasfollows.Weassignastorageversion
to each execution of each transaction prior to execution :(ğ‘¡ğ‘¥ğ‘›,ğ‘–)â†’
ğ‘ ğ‘£ğ‘›,ğ‘–.(ğ‘¡ğ‘¥ğ‘›,ğ‘–)standsforthe ğ‘–â€™sexecutionoftransaction#n,where
ğ‘–=0,1,2,....Notethat,dependingontheschedulerimplementation,
atransactioncanbeexecutedtwoormoretimes.Thelastexecution
mustcommit,whileallprecedingexecutionswillbeaborted.Forallpotentialexecutions
ğ‘–ofalltransactions#ninanexecutionunit(e.g.,
in a block), ğ‘ ğ‘£ğ‘›,ğ‘–is defined uniformly on all nodes, and it is defined
prior to execution so that it does not rely on non-deterministic
executiondetails.Then,forany (ğ‘¡ğ‘¥ğ‘›,ğ‘–),transaction#nwilleither
abort or commit on all nodes.
Throughouttheexecutionof (ğ‘¡ğ‘¥ğ‘›,ğ‘–),theschedulermustallow
the transaction to access storage entries written by transactions up
to and including transaction ğ‘ ğ‘£ğ‘›,ğ‘–. The scheduler must not allow
thetransactiontoaccessstorageentrieswrittenbyatransaction
with an id higher than ğ‘ ğ‘£ğ‘›,ğ‘–, even if it is committed. If ğ‘ ğ‘£ğ‘›,ğ‘–has
not committed and therefore the storage version specified priorto execution is not available when
(ğ‘¡ğ‘¥ğ‘›,ğ‘–)is being scheduled for
execution, the transaction cannot start execution and must wait.
5.4 Example
Wehave4transactions,labeled #1-#4.Transactions #1and#3have
a storage conflict: #1writes a storage entry read by #3. Let us then
walkthroughschedulingthesefourtransactionsontwodifferent
nodeswith2threadseach,underdifferentdeterminismguarantees.
Figure 3 depicts an example schedule using classic OCC. This
approach has no determinism guarantees. In particular, we can see
that the commit order on node Ais#1-#2-#3-#4, while it is #3-#2-
#1-#4onnodeB.Thedivergingrelativeorderofthetwoconflicting
transactions ( #1-#3,#3-#1) might lead to diverging states on the
twonodes.While #1and#3conflict,inthisexampletheyarenot
executed concurrently and therefore neither needs to be aborted.
InFigure4,weseeanexampleof OCCwithdeterministiccommit
order.O nn o d e B,#3finishes execution before #1.H o w e v e r ,i ti s
is not committed until after #1has, at which point the conflict is
detectedand #3isaborted.Thefinalcommitorderonbothnodes A
andBis#1-#2-#3-#4.However,duetothedifferentrelativeorder
of the execution of #1and#3on the two nodes, the first execution
of#3commits on node Awhile it aborts on node B. In distributed
consensus, such non-determinism is not acceptable (Section 5.2).
Notethat #4onnodeBcannotread uncommitted resultsfrom
#2or#3,eventhoughbothfinishexecutionbefore #4.Thiskindof
snapshot isolation allows us to avoid cascading aborts. An investiga-
tion of whether allowing transactions to read uncommitted results
is beneficial is beyond the scope of this paper.
Finally, Figure 5 shows how OCC-DA works. Prior to execution,
all nodes decide that the first execution of #3can only read the
statepriorto #1â€™sexecution( ğ‘ ğ‘£3,0:=0),whilethesecondexecution
canseethestateafter #2(ğ‘ ğ‘£3,1:=2).(Therationaleforthesevalues
isdiscussedinSection5.5.)Asaresult,eventhough #3isscheduled
after #1onnodeA,itisnotallowedtosee #1â€™swritesandthusitwill
abort.Thisyieldsaresultconsistentwiththeothercasewhere #3isexecutedconcurrentlywith #1,asonnode B.Thesecondexecution
will see the latest state on both nodes AandBand consequently it
will commit on both nodes.
5.5 Assigning Storage Versions
Letusmakesomeremarksabouttheassignmentofstorageversions.
The simplest approach is to set ğ‘ ğ‘£ğ‘›,0:=âˆ’1. This approach does
notrelyonanyinformationaboutthetransactionset.Whilethis
simplefirstapproximationworks,setting ğ‘ ğ‘£ğ‘›,0toâˆ’1(thestateprior
to transaction #0â€™s execution) will lead to aborts if the transaction
set contains any dependencies.
For a more sophisticated heuristic for storage version assign-
ment,wecanrelyontwokindsofinformation.First,wecanusethe
expectedexecutiontimeoftransactionstofindthelateststorage
versionatransactionisexpectedtosee.If,basedonthisestimation,
#3willstartexecutionafter #1butbefore #2,thenweset ğ‘ ğ‘£3,0:=1.
Second, an estimation of the transaction dependency graph might
allowustopreventaborts.Forinstance,ifweguessthat #3islikely
to conflict with #1, then we can set ğ‘ ğ‘£3,0>=1. We do not have per-
fectinformationaboutexecutiontimesortransactiondependencies.
Forthe former,the transaction gaslimit canserve asa reasonable
firstestimation.Forthelatter,staticanalysisandvariousheuristics
might provide us with an approximate dependency graph.
Theaccuracyofthestorageversionassignmenthasadirecteffect
on the performance of the parallel scheduler: If we use a storage
versionthatistoolow,thenweriskintroducingmoreaborts.If,on
the other hand, we use a storage version that is too high, then the
transaction might need to be delayed while it waits for the storage
version to become available, leading to thread under-utilization.
Finally, another aspect to consider is the overhead of the sched-
uler.Maintainingmultiplestorageversions mightintroduceasig-
nificantstorageoverheadincasetherearemanywrites.Limiting
the lowest storage version each transaction can see might help us
put a limit on this overhead.
5.6 The Algorithm
AdetailedalgorithmforOCC-DAispresentedinAlgorithm1.This
algorithm takes a set of transactions and their dependencies as
inputs. The dependency graph can be constructed through an esti-
mation of the read-write set of each transaction. It is not necessaryfor the estimation to be perfect but it needs to be deterministic and
consistentonall theblockchainnodes.Themoreprecise itis,the
fewer unnecessary aborts we may encounter.
Inthebeginning,thestorageversionofeachtransactionisini-
tializedasthemaximumidofthetransactionsthatitdependson
according to the dependency graph, or âˆ’1 if it has no dependency
(lines2-11).Thetransactionsarepushedintoamin-heap ğ»ğ‘¡ğ‘¥ğ‘ in-
dexed by the storage version. There are three other min-heaps.
ğ»ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘¦maintainstransactionsreadytobescheduled, ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ is
exactly the thread pool for executing transactions, and ğ»ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡is
forthetransactionsthathavealreadyfinishedtheexecutionand
wait to be committed. The global variable ğ‘›ğ‘’ğ‘¥ğ‘¡maintains the id of
thenextto-be-committedtransaction.Notethatthealgorithmde-
scribesthetransactionexecutionmechanismusedinoursimulation
whichresultsindeterministicexecutioncompletionorderaccord-
ing to the given gas consumption of each transaction. However, in
2322
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Utilizing Parallelism in Smart Contracts on Decentralized Blockchains by Taming Application-Inherent Conflicts ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Algorithm 1: OCC-DA
Input:Transactions ğ‘‡, gasğºğ‘ğ‘ , number of threads ğ‘¡, none or a
dependency graph ğ·
1ğ»ğ‘¡ğ‘¥ğ‘ â†an empty minheap of (ğ‘ ğ‘£,ğ‘–ğ‘‘);
2forğ‘–ğ‘‘âˆˆ[0,|ğ‘‡|)do
3ifğ·existsthen
4 ğ‘–ğ‘‘ğ‘šğ‘ğ‘¥â†âˆ’1;
5 foredge(ğ‘–ğ‘‘,ğ‘–ğ‘‘ ğ‘ğ‘Ÿğ‘’ğ‘£)âˆˆğ·do
6 //tx_ğ‘–ğ‘‘depends on tx_ ğ‘–ğ‘‘ğ‘ğ‘Ÿğ‘’ğ‘£
7 //tx_ğ‘–ğ‘‘reads what tx_ ğ‘–ğ‘‘ğ‘ğ‘Ÿğ‘’ğ‘£ writes
8 ğ‘–ğ‘‘ğ‘šğ‘ğ‘¥â†ğ‘šğ‘ğ‘¥(ğ‘–ğ‘‘ğ‘šğ‘ğ‘¥,ğ‘–ğ‘‘ğ‘ğ‘Ÿğ‘’ğ‘£);
9 ğ»ğ‘¡ğ‘¥ğ‘ .ğ‘ğ‘¢ğ‘ â„((ğ‘–ğ‘‘ğ‘šğ‘ğ‘¥,ğ‘–ğ‘‘));
10else
11 ğ»ğ‘¡ğ‘¥ğ‘ .ğ‘ğ‘¢ğ‘ â„((âˆ’1,ğ‘–ğ‘‘));
12ğ»ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘¦â†an empty minheap of (ğ‘–ğ‘‘,ğ‘ ğ‘£);
13ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ â†an empty minheap of (ğ‘”ğ‘ğ‘ ,ğ‘–ğ‘‘,ğ‘ ğ‘£ );
14ğ»ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡â†an empty minheap of (ğ‘–ğ‘‘,ğ‘ ğ‘£);
15ğ‘›ğ‘’ğ‘¥ğ‘¡â†0;
16whileğ‘›ğ‘’ğ‘¥ğ‘¡ <|ğ‘‡|do
17//Stage 1 : Schedule
18for(ğ‘ ğ‘£,ğ‘–ğ‘‘)â†ğ»ğ‘¡ğ‘¥ğ‘ .ğ‘ğ‘œğ‘()do
19 ifğ‘ ğ‘£>ğ‘›ğ‘’ğ‘¥ğ‘¡âˆ’1then
20 ğ»ğ‘¡ğ‘¥ğ‘ .ğ‘ğ‘¢ğ‘ â„((ğ‘ ğ‘£,ğ‘–ğ‘‘));
21 break
22 else
23 ğ»ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘¦.ğ‘ğ‘¢ğ‘ â„((ğ‘–ğ‘‘,ğ‘ ğ‘£));
24while|ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ |<ğ‘ğ‘œğ‘œğ‘™_ğ‘ ğ‘–ğ‘§ğ‘’and|ğ»ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘¦|>0do
25 (ğ‘–ğ‘‘,ğ‘ ğ‘£)â†ğ»ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘¦.ğ‘ğ‘œğ‘();
26 ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ .ğ‘ğ‘¢ğ‘ â„((ğºğ‘ğ‘ [ğ‘–ğ‘‘],ğ‘–ğ‘‘,ğ‘ ğ‘£));
27//Stage 2 : Execution
28if|ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ |>0then
29 (ğ‘”ğ‘ğ‘ ,ğ‘–ğ‘‘,ğ‘ ğ‘£ )â†ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ .ğ‘ğ‘œğ‘();
30 ğ»ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡â†(ğ‘–ğ‘‘,ğ‘ ğ‘£);
31 forğ‘–âˆˆ[0,|ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ |)do
32 ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ [ğ‘–].ğ‘”ğ‘ğ‘ â†ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ [ğ‘–].ğ‘”ğ‘ğ‘ âˆ’ğ‘”ğ‘ğ‘ ;
33//Stage 3 : Commit/Abort
34while|ğ»ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡|>0do
35 (ğ‘–ğ‘‘,ğ‘ ğ‘£)â†ğ»ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡.ğ‘ğ‘œğ‘();
36 ifğ‘–ğ‘‘â‰ ğ‘›ğ‘’ğ‘¥ğ‘¡then
37 ğ»ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡.ğ‘ğ‘¢ğ‘ â„((ğ‘–ğ‘‘,ğ‘ ğ‘£));
38 break
39 forğ‘–ğ‘‘ğ‘ğ‘Ÿğ‘’ğ‘£âˆˆ[ğ‘ ğ‘£+1,ğ‘–ğ‘‘âˆ’1]do
40 iftx_ğ‘–ğ‘‘ğ‘ğ‘Ÿğ‘’ğ‘£â€™s write set âˆ©tx_ğ‘–ğ‘‘â€™s read set â‰ âˆ…then
41 get Aborted ;
42 break
43 ifAbortedthen
44 ğ»ğ‘¡ğ‘¥ğ‘ .ğ‘ğ‘¢ğ‘ â„((ğ‘–ğ‘‘âˆ’1,ğ‘–ğ‘‘));
45 else
46 //Commit successfully
47 ğ‘›ğ‘’ğ‘¥ğ‘¡â†ğ‘›ğ‘’ğ‘¥ğ‘¡+1;
48return
arealsystem,thecorrectnessandeffectivenessofourscheduling
strategy do not rely on this execution determinism.
Lines16-47showthestagesthattransactionsexperience.Stage1
isschedulingtransactionsintothethreadpool(17-26).Weconsider
a transaction ready to execute when the transaction correspondingto its storage version has been committed. Ready transactions are
pushed into the thread pool, if it has empty slots (24-26).
Stage2istheexecutionoftransactionsinthethreadpool.We
simply choose the transaction with the minimal remaining gas,
which is exactly the top of ğ»ğ‘¡â„ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ , push it into ğ»ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡, and
maintain the gas accordingly.
Thelaststageistryingtocommitthetransactionsonebyone
inğ»ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡(lines33-47).Transactionsin ğ»ğ‘ğ‘œğ‘šğ‘šğ‘–ğ‘¡aremaintained
in the order of id, since we always commit transactions in order
withoutskips.Foreachto-be-committedtransaction,thealgorithm
checkswhetheritshouldbeabortedorcommittedthroughchecking
whetherthereexistanyread-writeconflictsbetweenthecurrent
transaction and those transactions committed since it starts toexecute (lines 39-42). If aborted, the transaction is pushed back
intoğ»ğ‘¡ğ‘¥ğ‘ with its new storage version set as ğ‘–ğ‘‘âˆ’1, otherwise, the
commit succeeds.
6 EVALUATION
6.1 Experimental Setup
The experimental evaluation of the techniques presented in this
paper builds on the empirical study discussed previously. All simu-
lationsdiscussedhereoperateonthestorageaccesstracescollected
from the Ethereum transaction dataset, as outlined in Section 3.
For evaluating the proposed bottleneck-elimination techniques,
weanalyzedthebest-caseparallelexecutiontimeusingthetransac-
tiondependencygraph,withandwithoutapplyingthesetechniques.
In this experiment, we rely on perfect knowledge of transaction
dependencies. We start by constructing a dependency graph of
transactions,wherevertices(thatcorrespondtothetransactions)
areweightedbythetransactiongascosts.Then,wesimulatesched-
uling the transactions on a set of threads (2, 4, 8, 16, 32). In each
scheduling step, out of all transactions with no unexecuted depen-
dencies, we select the one that has the heaviest path starting from
it. The gas cost of this schedule serves as the baseline. For thisexperiment, we use 10-block batches as the unit of execution, to
reduce the effect of single-transaction bottlenecks (see Section 3.2).
For evaluating the potential effect of using partitioned counters,
weprunethetransactiondependenciesinapseudorandomfashion,
in a way that is consistent with this technique. For instance, fora counter of length 3, for each dependency, we remove it with a
probability of 8/9.
For seeing the impact of deterministic scheduling, we simulated
an OCC scheduler with deterministic commit order as our baseline.
Theschedulerhaszeroupfrontinformationaboutthetransaction
dependencies. When scheduling a transaction for execution, the
scheduler uses thehighest committed transaction id asits storage
version.Tomakethetransactioncommitorderdeterministic,the
scheduler commits transactions according to their block order. For
deterministic aborts, instead of using the highest executed transac-
tionidasthetransactionâ€™sstorageversion,weuseastorageversion
definedpriortoexecution:Weuse-1(i.e.,thestoragepriortothe
blockâ€™s execution) as the storage version for the transactionâ€™s first
execution, and use (ğ‘¡ğ‘¥_ğ‘–ğ‘‘âˆ’1)for its second execution. We then
compare the overall gas costs of these two OCC simulations.
2323
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA PÃ©ter GaramvÃ¶lgyi, Yuxi Liu, Dong Zhou, Fan Long, and Ming Wu
Figure 6: Distribution of speedup bounds (10-block batches)
6.2 Assumptions and Limitations
Ourevaluationsarebasedonsimulationsusingreal-worlddata,not
on implementation in a real-world blockchain system. We chose
to simulate scheduling because currently there is no parallel EVM
available.ThepotentialoverheadoftheparallelVMisnotconsid-
eredasitdependsheavilyontheactualimplementation.Weaimto
comparedifferenttechniquesinacontrolledanddeterministicway
without speculating about the VM implementation. For the two
experiments, our focus is on the change in the maximum speedup
achievableand thedifferencebetween thetwoOCCmethods. We
believe these relative measures also apply in a real-world system.
Theevaluationassumesthatpartitionedcounterscanbeapplied
toallstorageconflicts.ThisisareasonableapproximationbasedontheresultspresentedinSection3.2,wherewefoundthatalmostall
conflicts can be traced back to counters used in token distribution
scenarios. The information available to our simulated scheduler
(storageread/writetraces)isinsufficienttodecidewhetherastorage
location corresponds to a counter; for this, one would need to rely
on the contractâ€™s source code, which is often not publicly available.
Theothertwoproposedtechniquesarenotevaluated.Theeffect
of"Conflict-Aware Token Distribution" is equivalent to that of parti-
tionedcounters.AsforcommutativeEVMinstructions,ourstorage
tracesdonotprovideinformationabouttheseriesofinstructions
executed that would be necessary to evaluate commutative opera-
tions. We expect the effect of the three techniques to be similar, as
they all remove edges from the transaction dependency graph in a
similarway.Infact, "CommutativeEVMInstructions" mightbemore
effective: The first two techniques will still result in some conflicts,
while this third one could serialize all updates without conflict.
6.3 Evaluation Results
OverallResults. Foreach10-blockbatch,welookatits optimal
execution cost on 32 threads (based on the transaction dependencygraph),andcomparethistoitsserialexecutioncost.Forthebaseline
(with no modification), the average speedup over all batches is
11.93x, while the overall speedup on the whole period is 9.25x, due
to the bottlenecks discussed in Section 3. Using a counter of length
2,theaveragespeedupbecomes21.23x,whiletheoverallspeedup
is17.96x.Thehighestspeedupwecanhopetoachieve,whenwe
remove all transaction dependencies, is 23.63x on average, while
theoverallspeedupis20.61xinthisexperiment.
As for OCC-DA, over single blocks with 32 threads, the baseline
OCC scheduler has a 3.287x overall speedup (min: 0.52x, max: 32x,
Figure 7: OCC-DA performance impact
avg:5.89x),whilethedeterministicschedulerresultsin3.275xover-
all speedup (min: 0.52x, max: 32x, avg: 5.84x). We observed similar
results over batches of 30 blocks.
Discussion. Theseresultsshowthattheparallelisminherentin
thedataset(9.25x)ismuchlowerthanwhatthetransactionswouldallowfor(23.63x).Thisisduetothefactthattransactionsdepending
on each other need to be scheduled serially (or get aborted). By
eliminatingsomedependenciesusingtechniqueslikepartitioned
counters,wecanapproachthislimit,achievingupto17.96xspeedup
withjustacountersizeof2.Figure6showsoverlayedhistogramsfor
the distribution of speedup bounds for each block-batch. From this
figure, we can clearly see how partitioned counters let us converge
to the optimum, in terms of the parallel speedup achievable.
Figure 7 shows the performance degradation caused by OCC-
DA(blue),comparedtoOCCwithdet.commitorder(red)onsin-
gle blocks. For this figure, blocks were ordered by their baseline
speedup (red). We can see that extending the scheduler with deter-
ministicabortsdidcauseperformancedegradation,however,the
speedups generally still do not diverge much from the baseline,
exceptforafewoutliers.Infact,inthisdataset,92.47%oftheblocks
producedexactlythesameresultusingthetwoschedulers,while
only0.22%resultedin80%ofthebaselinespeeduporlower.
Implications. Theseresultssuggestthatpartitionedcounterscan
haveasignificantimpactonthehighestparallelspeedupthatwe
can achieve. Even with just a counter of length 2, when applied
toallconflicts,theparallelspeedupbounddoubled,approaching
the optimum. Raising the counter length, we keep approaching the
optimum. Based on these results, we believe that the techniques
proposedinthispaper,whenappliedtosomecontractsresponsible
forsomemajorbottlenecks,cansignificantlyincreasetheparallel
speedup that any real-world parallel scheduler can achieve.
TheresultsaboutOCC-DAsuggestthatraisingthelevelofdeter-
minism only has a minor performance impact, decreasing the over-
allspeedupfrom3.287xto3.275x.AsshowninFigure7,whilethere
areoccasionaloutlierswithsignificantperformancedegradation
underthis schedulingmechanism,they arerare. Whileitis possi-
blethatamoreperformantscheduler,andaworkloadwithmore
parallelism,willresultinalargerdiscrepancybetweenthesetwo
numbers, based on these initial evaluations, our expectation is that
OCC-DAissuitableforimplementationinreal-worldblockchain
protocols.
2324
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. Utilizing Parallelism in Smart Contracts on Decentralized Blockchains by Taming Application-Inherent Conflicts ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
7 THREATS TO VALIDITY
Themostsignificantthreattothevalidityofourstudyisthattrans-
action and contract interaction patterns have changed since the
observedperiodin2018andsoourconclusionsdonotholdformore
recent periods. We believe that this is unlikely. The issues pointed
outinthispaperhavenotbeenaddressed,andsotherehasbeen
neither awareness nor incentive to avoid these conflict-inducing
patterns.Ifanything,theproblemhaslikelybecomemoresevere,
with several new hotspot contracts emerging, many of which have
obviousstorageconflicts.AnexampleforthisisUniswap,aspointed
out in Section 3.3. Saraph et al. [ 25] also observes that the paral-
lelizability of blocks seems to decrease over time.
There is a chance that the gas cost of transactions does not
accurately capture their running time, which would reduce the
accuracyofourevaluations.Giventhat themosttime-consuming
operations(namely, SLOADandSSTORE)haveveryhighgascosts,
large deviation seems unlikely.
Inthisstudy,weonlyconsideredstorageconflicts.Otherconflict
types include conflicts on an accountâ€™s balance and nonce, andconflicts on contract creation/destruction. Balance conflicts canbe handled using partitioned counters. Nonce conflicts require
adjustingthenoncemanagementmechanism.Ascontractexistence
conflicts are rare, they are unlikely to have distorted our results.
8 RELEVANCE AND FUTURE WORK
Scope.OurworkfocusesonEthereumbutourfindingsandsolu-
tionsareapplicable tootherchainsas well.Thisclaimis supportedbytwotrends.First,manysignificantblockchainsadoptEthereumâ€™s
execution logic (Ethereum Classic, BSC), while others are in the
processofaddinganEVMcompatibilitylayer(Near,Solana).Sec-
ond,differentchainssharecommonusecases(DeFiswapplatforms,
NFTmarketplaces),andpopularEthereumapplicationsareoften
forkedandredeployedonotherchains(UniswapandPancakeSwap).
This results in similar transaction workloads on these chains. This
similarity is supported by previous research as well [23].
Feasibility. Implementing parallel execution of blockchain trans-
actions requires further research and engineering effort. We need
further research on parallel execution incentives, and the EVM
needstobe extendedwithaparallelscheduler. OCC-DAprovides
a foundation for these by offering a parallel scheduling frame-
work suitable for distributed consensus protocols. We also need
techniques for increasing the parallelizability of the transaction
workload.Theproposedbottleneck-eliminationtechniquesaddress
this requirement. Of these techniques, only "Commutative EVM
Instructions" requiresaprotocolupgrade.Finally,furtherworkis
required to design an optimized deterministic parallel scheduler,
building on existing techniques from traditional database systems.
9 RELATED WORK
Parallel execution of blockchain transactions has been the focus of
considerable research attention in recent years. Perhaps the firstsuch work is by Sergey et al. [
26], in which the authors propose
totreatsmart contractsasconcurrentobjects topreventcommon
bugs.In2019,Saraphetal.[ 25]publishedanexploratoryworkto
estimatethepotentialbenefitofexecutingEthereumtransactionsinparallelbysimulatinga2-phaseparallel-then-serialoptimistic
scheduler. They observe a 2-fold speedup for the period in 2018
using64threads,andidentify CryptoKitties asahotspotcontract.
Theybrieflyremarkonincentivesandcommutativeoperations.Rei-
jsbergen et al. [ 23] evaluate the potential speedup on seven public
blockchains using dependency graphs, working on the granularity
of contracts instead of storage entries. They report that up to 6x
speedupisachievableusing8ormorecores,andobservethatlarger
blocksareeasiertoparallelize.Ourempiricalstudyisinspiredby
these two works, and we reinforce or expand on some of their con-
clusions.Howev er,theseworksdonotanalyzeconflictsin-depth
andsotheyfailtoexplainthepoorparallelspeedupstheypredict.
Their models also do not fulfill the determinism requirements that
would make them practical in public blockchains.
Numerous previous works have proposed to use various concur-
rency control techniques to parallelize blockchain transactions. In
theapproachproposedbyAnjanaetal.[ 2],minersuseoptimistic
STM to execute transactions and produce a dependency graph that
validators can use to re-execute transactions. Zhang et al. [ 33],
insteadofusingadependencygraph,proposetoincludeeachtrans-actionâ€™swritesetintheblock,andletvalidatorsusethesetodetect
conflicts. Panget al. [ 21] alsoconsider the granularityof the addi-
tionalinformationincludedintheblock.Dickersonetal.[ 9]propose
to use abstract locks to detect conflicts during speculative parallel
execution.Dozieretal.[ 10],ontheotherhand,useaPessimistic
ConcurrencyControltechniquebylockingtheaccountsaccessed
during transaction execution. Finally, Bartoletti et al. [ 4] offer a
formalmodelofconcurrentblockchaintransactions.Mostofthe
proposedtechniquesareprotocol-breaking,inthesensethatthey
modify the block structure and the execution semantics, while our
approachremainscompatiblewithserialimplementations.These
works show modest speedup on parallel miners but they do not
address the root cause of the speedup limit. An overview of this
area can be found in the survey piece by Kemmoe et al. [16].
Optimistic concurrency control [ 17] has been widely used in
databasesandwide-areadistributedsystems.DeterministicOCC
was pioneered by Abadi et al. In Calvin [ 31], they use a determinis-
tic locking protocol to let nodes arrive on a consistent transaction
order, eliminating the need for distributed commit protocols. Their
approachisfurtheroutlinedinseveralotherpapers[ 1,29,30].Our
discussion of the determinism of blockchain transaction execution
was inspired by these works. In addition to using a predefined seri-
alization order, we introduced an even higher level of determinism,
where the effects of transactions that are normally not observable
are also deterministic, and can be used for incentive assignment.
10 CONCLUSION
With the evolution of consensus protocol technology in public
blockchain,theexecutionefficiencyisbecomingthenewbottleneckoftheentiresystem,whichdrivestheneedofparallelizingthetrans-
action execution. This work observes that the application inherent
conflictsarethefundamentalobstacletoachievingidealspeedup
in existing parallelization techniques. To address this issue, the
proposed solution introduces the convenient improvement on the
smartcontractprogrammingparadigmwithconsiderationofthe
supportofincentives,thereforeopensthepossibilityofmaximizing
the parallelism of transaction execution in public blockchains.
2325
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA PÃ©ter GaramvÃ¶lgyi, Yuxi Liu, Dong Zhou, Fan Long, and Ming Wu
REFERENCES
[1]DanielJAbadiandJoseMFaleiro.2018. AnOverviewofDeterministicDatabase
Systems. Commun. ACM 61, 9 (2018), 78â€“88.
[2]Parwat Singh Anjana, Sweta Kumari, Sathya Peri, Sachin Rathor, and Archit
Somani. 2019. An Efficient Framework for Optimistic Concurrent Execution
ofSmartContracts.In 201927thEuromicroInternationalConferenceonParallel,
Distributed and Network-Based Processing (PDP). IEEE, 83â€“92.
[3]Vivek Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and Pramod Viswanath.2019. Prism: Deconstructing the Blockchain to Approach Physical Limits. In Pro-
ceedingsofthe2019ACMSIGSACConferenceonComputerandCommunications
Security(London,UnitedKingdom) (CCSâ€™19).AssociationforComputingMa-
chinery, New York, NY, USA, 585â€“602. https://doi.org/10.1145/3319535.3363213
[4]MassimoBartoletti,LetterioGalletta,andMaurizioMurgia.2020. ATrueCon-
current Model of Smart Contracts Executions. In International Conference on
Coordination Languages and Models. Springer, 243â€“260.
[5]SilasBoyd-Wickizer,AustinTClements,YandongMao,AlekseyPesterev,MFrans
Kaashoek, Robert Tappan Morris, Nickolai Zeldovich, et al .2010. An Analysis of
Linux Scalability to Many Cores. In OSDI, Vol. 10. 86â€“93.
[6]Ting Chen, Xiaoqi Li, Ying Wang, Jiachi Chen, Zihao Li, Xiapu Luo, Man Ho Au,
and Xiaosong Zhang. 2017. An adaptive gas cost mechanism for ethereum to
defendagainstunder-priceddosattacks.In Internationalconferenceoninformation
security practice and experience. Springer, 3â€“24.
[7]Deloitte.2017. 5BlockchainTechnologyUseCasesinFinancialServices. http:
//blog.deloitte.com.ng/5-blockchain-use-cases-in-financial-services/.
[8]Deloitte. 2018. Blockchain: Opportunities for Health Care. https:
//www2.deloitte.com/us/en/pages/public-sector/articles/blockchain-
opportunities-for-health-care.html.
[9]Thomas Dickerson, Paul Gazzillo, Maurice Herlihy, and Eric Koskinen. 2019.
Adding Concurrency to Smart Contracts. Distributed Computing (2019), 1â€“17.
[10]RyanDozier,SamErvolino,ZachNewsom,FayeStrawn,andRossWagner.[n.d.].
A Correctness Tool to Verify Concurrent Ethereum Transactions. ([n.d.]).
[11]WilliamEntriken,DieterShirley,JacobEvans,andNastassiaSachs.2018. EIP-721:
Non-Fungible Token Standard. https://eips.ethereum.org/EIPS/eip-721.
[12]Ittay Eyal, Adem Efe Gencer, Emin GÃ¼n Sirer, and Robbert Van Renesse. 2016.
Bitcoin-NG:A Scalable Blockchain Protocol. In NSDI. 45â€“59.
[13]Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. In
Proceedings of the 26th Symposium on Operating Systems Principles. ACM, 51â€“68.
[14]Yilin Han, Chenxing Li, Peilun Li, Ming Wu, Dong Zhou, and Fan Long. 2020.
Shrec: Bandwidth-Efficient Transaction Relay in High-Throughput Blockchain
Systems.In Proceedingsofthe11thACMSymposiumonCloudComputing (Virtual
Event,USA) (SoCCâ€™20).AssociationforComputingMachinery,NewYork,NY,
USA, 238â€“252. https://doi.org/10.1145/3419111.3421283
[15]IBM. 2020. Blockchain for Supply Chain. https://www.ibm.com/blockchain/
supply-chain/.
[16]Victor Youdom Kemmoe, William Stone, Jeehyeong Kim, Daeyoung Kim, and
Junggab Son. 2020. Recent Advances in Smart Contracts: A Technical Overview
and State of the Art. IEEE Access 8 (2020), 117782â€“117801.
[17]Hsiang-Tsung Kung and John T Robinson. 1981. On Optimistic Methods for
Concurrency Control. ACM Transactions on Database Systems (TODS) 6, 2 (1981),
213â€“226.
[18]YoadLewenberg,YonatanSompolinsky,andAvivZohar.2015. InclusiveBlock
Chain Protocols. In International Conference on Financial Cryptography and Data
Security. Springer, 528â€“547.
[19]Chenxing Li, Peilun Li, Dong Zhou, Zhe Yang, Ming Wu, Guang Yang, Wei
Xu, Fan Long, and Andrew Chi-Chih Yao. 2020. A Decentralized Blockchain
with High Throughput and Fast Confirmation. In 2020 USENIX Annual Technical
Conference(USENIXATC20) .USENIXAssociation,515â€“528. https://www.usenix.
org/conference/atc20/presentation/li-chenxing
[20]Satoshi Nakamoto. 2008. Bitcoin: A Peer-to-Peer Electronic Cash System. Decen-
tralized Business Review (2008), 21260.
[21]Shuaifeng Pang, Xiaodong Qi, Zhao Zhang, Cheqing Jin, and Aoying Zhou. 2019.
Concurrency Protocol Aiming at High Performance of Execution and Replay for
Smart Contracts. arXiv preprint arXiv:1905.07169 (2019).
[22]RafaelPassandElaineShi.2017. Fruitchains:AFairBlockchain.In Proceedings
of the ACM Symposium on Principles of Distributed Computing. ACM, 315â€“324.
[23]DaniÃ«lReijsbergenandTienTuanAnhDinh.2020. OnExploitingTransaction
ConcurrencytoSpeedUpBlockchains.In 2020IEEE40thInternationalConference
on Distributed Computing Systems (ICDCS). IEEE, 1044â€“1054.
[24]Danny Ryan and Vitalik Buterin. 2020. EIP-2982: Serenity Phase 0 [DRAFT].
https://eips.ethereum.org/EIPS/eip-2982.
[25]VikramSaraphandMauriceHerlihy.2019. AnEmpiricalStudyofSpeculative
Concurrency in Ethereum Smart Contracts. arXiv preprint arXiv:1901.01376
(2019).
[26]Ilya Sergey and Aquinas Hobor. 2017. A Concurrent Perspective on Smart Con-
tracts.In InternationalConferenceonFinancialCryptographyandDataSecurity.
Springer, 478â€“493.[27]Yonatan Sompolinsky, Shai Wyborski, and Aviv Zohar. 2020. PHANTOMand GHOSTDAG, A Scalable Generalization of Nakamoto Consensus. (2020).
https://eprint.iacr.org/2018/104.pdf.
[28]Yonatan Sompolinsky and Aviv Zohar. 2015. Secure High-Rate Transaction
Processing in Bitcoin. In International Conference on Financial Cryptography and
Data Security. Springer, 507â€“527.
[29]Alexander Thomson and Daniel J Abadi. 2010. The Case for Determinism in
Database Systems. Proceedings of the VLDB Endowment 3, 1-2 (2010), 70â€“80.
[30]AlexanderThomsonandDanielJAbadi.2011.BuildingDeterministicTransaction
Processing Systems without Deterministic Thread Scheduling. In Proceedings
of the 2nd Workshop on Determinism and Correctness in Parallel Programming,
Vol. 5.
[31]Alexander Thomson, Thaddeus Diamond, Shu-Chun Weng, Kun Ren, Philip
Shao,andDanielJAbadi.2012. Calvin:FastDistributedTransactionsforParti-
tioned Database Systems. In Proceedings of the 2012 ACM SIGMOD International
Conference on Management of Data. 1â€“12.
[32]Haifeng Yu, Ivica Nikolic, Ruomu Hou, and Prateek Saxena. 2020. OHIE:
BlockchainScalingMadeSimple.In ProceedingsoftheIEEESymposiumonSecurity
and Privacy. IEEE.
[33]An Zhang and Kunlong Zhang. 2018. Enabling Concurrency on Smart Contracts
UsingMultiversionOrdering.In Asia-PacificWeb(APWeb)andWeb-AgeInfor-
mation Management (WAIM) Joint International Conference on Web and Big Data.
Springer, 425â€“439.
2326
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:59:43 UTC from IEEE Xplore.  Restrictions apply. 