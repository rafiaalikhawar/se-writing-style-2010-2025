Generating Concept based API Element Comparison Using a
Knowledge Graph
Yang Liu∗
Fudan University
ChinaMingwei Liu∗
Fudan University
ChinaXin Peng∗†
Fudan University
China
Christoph Treude
The University of Adelaide
AustraliaZhenchang Xing
Australian National University
AustraliaXiaoxin Zhang∗
Fudan University
China
ABSTRACT
Developers are concernedwith the comparison of similar APIsin
termsoftheircommonalitiesand(oftensubtle)differences.Ourem-
piricalstudyofStackOverflowquestionsandAPIdocumentation
confirmsthatAPIcomparisonquestionsarecommonandcanoften
be answered by knowledge contained in API reference documenta-
tion.OurstudyalsoidentifieseighttypesofAPIstatementsthatare
usefulforAPIcomparison. Basedonthesefindings,weproposea
knowledge graph based approach APIComp that automatically ex-
tractsAPIknowledgefromAPIreferencedocumentationtosupport
thecomparisonofapairofAPIclassesormethodsfromdifferent
aspects.Ourapproachincludesanofflinephaseforconstructingan
APIknowledgegraph,andanonlinephaseforgeneratinganAPI
comparison result for a given pair of API elements. Our evaluation
shows that the quality of different kinds of extracted knowledge
in the API knowledge graph is generally high. Furthermore, the
comparison results generated by APIComp are significantly better
than those generated by a baseline approach based on heuristic
rulesandtextsimilarity,andourgeneratedAPIcomparisonresults
are useful for helping developers in API selection tasks.
CCS CONCEPTS
•Softwareanditsengineering →Documentation ;•Comput-
ing methodologies →Information extraction.
KEYWORDS
API, Knowledge Graph, Documentation, Knowledge Extraction
∗Y.Liu,M.Liu,X.Peng,andX.ZhangarewiththeSchoolofComputerScienceand
ShanghaiKeyLaboratoryofDataScience,FudanUniversity,andtheShanghaiInstitute
of Intelligent Electronics & Systems, China.
†X. Peng is the corresponding author (pengxin@fudan.edu.cn).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416628ACM Reference Format:
Yang Liu, Mingwei Liu, Xin Peng, Christoph Treude, Zhenchang Xing,
and Xiaoxin Zhang. 2020. Generating Concept based API Element Com-
parison Using a Knowledge Graph. In 35th IEEE/ACM International Con-
ference on Automated Software Engineering (ASE ’20), September 21–25,2020, Virtual Event, Australia. ACM, New York, NY, USA, 12pages.https:
//doi.org/10.1145/3324884.3416628
1 INTRODUCTION
FrameworksandlibrariesoftenhaveAPIsthatprovidesimilarfunc-
tionalities,buthavesubtledifferences.Forexample, java.lang.String-
Bufferandjava.lang.StringBuilder can be used for string construc-
tion,butStringBuffer isthread-safewhile StringBuilder isnot.Over-
looking such subtle differences between similar APIs may resultin program errors, e.g.,usingjava.lang.StringBuilder in a multi-
thread context. Therefore, developers are often concerned with
the comparison of similar APIs. In fact, API comparison questions
arecommononSO(StackOverflow).Forexample,asofMarch3,
2019, 13,228 questions tagged with “java” have either the strings
“difference between” or“vs” intheirtitle. Amongthesequestions,
38% (5,075 of 13,228) questions do not have an accepted answer.
API reference documentation contains rich knowledge of a vari-
ety of aspects of an API, such as functionalities, constraints, direc-
tives, caveats, and resource specifications [ 3,7,8,15,22,31,32]. In
anempiricalstudywith100JDKAPIcomparisonquestionsfromSO,
we found that the JDK API reference documentation covers 74%
of the points made in the answers to these questions, covering
different aspects of API knowledge. We also found that knowledge
is scattered within the document of one API element (e.g., class)
andacrossthedocumentsofrelatedAPIelements,leadingtomany
challengesforAPIcomparisonknowledgediscoveryandsumma-
rization. First, API reference documentation has information over-
loadingissues.Forexample,theAPIdocumentof java.nio.file.Files1
contains1,003sentences.Second,APIreferencedocumentationcon-tainsdiversetypesofAPIknowledge,notallofwhicharerelatedto
API comparison. Third, API reference documentation contains het-
erogeneousinformation:codesnippets,variousaliases(e.g., “string
buffer” in the text for java.lang.StringBuffer ), and co-references
(e.g.,“this class” may reference different API classes depending on
the context).
ToassistdevelopersinAPIselectiontasksandautomaticallygen-
eratethecomparisonofAPIclassesormethodsbyextractingAPI
1https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html
8342020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
comparisonknowledgefromAPIreferencedocumentation,deep
understandingofthesemanticsoftheAPIdescriptiontextisneces-
sary.Moreover,lotsofAPIknowledgeisnotonlyinthetext,butalso
in the code structure, e.g.,classes implementing java.io.Serializable
areserializable. Howcanweeffectivelyminesuchknowledgefrom
both code and text? How to normalize and structure the mined API-
comparison knowledge is another big challenge, since the sameknowledge may be described in different ways in different parts
oftheAPIreferencedocumentation. e.g.,“Athread-safe,mutable
sequenceofcharacters”isthefirstsentenceof java.lang.StringBuffer
and “A StringBuffer is like a String, but can be modified” is the sec-
ond sentence, but they describe the overlapping knowledge about
java.lang.StringBuffer. That is “can be modified” implies the charac-
teristic“mutable”.Lastbutnotleast,weneedawaytoautomaticallyinferthecommonalitiesanddifferencesofAPIsbasedonthemined
API knowledge to answer API comparison questions.
Totacklethesechallenges,weproposeaknowledgegraphbased
approach APIComp that automatically extracts API comparison
knowledge from API reference documentation to support the com-
parisonofapairofAPIclassesormethodsfromdifferentaspects
(i.e.,functionality,characteristic,andcategorization).APICompcon-
sists of an offline phase for API knowledge graph construction and
anonlinephaseforAPIcomparisonservice.Theofflinephasetakes
as input API reference documentation and produces an API knowl-
edge graph. The online phase generates API comparison resultsfor a given pair of API elements. Our knowledge graph helps to
establish extensiverelations betweenAPI informationin different
ways,e.g.,linkingthenounconceptsrelatedtoAPIstotheconcepts
fromageneralknowledgegraph(e.g., Wikidata[ 25]).Inthisway,
we can gather API knowledge from different places and in diverse
forms, and describe it in a standardized format and present it in an
intuitive table for API comparison (see Figure 4).
We evaluated the quality of the key steps for API knowledge
graphconstructionandtheeffectivenessandusefulnessofAPIcom-
parisonresultsgeneratedbyAPIComp.Ourexperimentalresults
show that the quality of different kinds of knowledge in the API
knowledge graph is generally high. The comparison results gener-
atedbyAPICompoutperformthecomparisonresultsgeneratedbyatextsimilaritybasedbaselineincompleteness,conciseness,andun-
derstandability while covering more answer points. Moreover, we
designed12APIselectiontasksthatrequireAPIcomparisonknowl-
edge of similar APIs and asked 12 participants to solve the tasks
withAPICompandwithoutAPIComp(i.e., usingtheGooglesearch
engine). Our user study shows that participants that used API-
Compcansolvetasksfasterandmoreaccuratelycomparedtothose
using Google. This shows that APIComp can help developers in
real-worldAPIselectiontasks.Detailsoftheempiricalstudyand
evaluation can be found in our replication package [1].
This paper makes the following contributions:
1) We conducted an empirical study and revealed that API com-
parison questions can be answered by 8 types of API statements
from API reference documentation;
2) We proposed an approach APIComp that automatically ex-
tractsAPIcomparisonknowledgefromAPIreferencedocumenta-tion to support the comparison of a pair of API elements;
3)WeconstructedanAPIknowledgegraphforJDK1.8(including
188,163 entities and 339,770 relations for 44,809 API classes andmethods) and one for Android 27 (including 271,162 entities and
572,098 relations for 77,084 API classes and methods);
4) We evaluated the quality of the key steps for API knowledge
graph construction and the effectiveness and usefulness of API
comparison results generated by APIComp.
2 EMPIRICAL STUDY
To understandwhat informationdevelopers arelooking forwhen
comparing APIs and how we could design an approach to assist
developersbyprovidingsuchcomparisonsautomatically,wecon-
ducted an empirical study to investigate whether and where the
APIreferencedocumentationcontainsinformationusefulforan-
swering API comparison questions asked on SO. We answered the
following research questions:
RQ1: What API comparison information is available on SO?RQ2
: How much useful information does the API reference
documentationcontainforansweringAPIcomparisonquestions
and how scattered is this information in API documentation?
RQ3: What statement types can relevant information for an-
swering API comparison questions be classified into?
2.1 Study Design
2.1.1 Data Preparation. ToretrievequestionsaboutAPIcompar-
ison, we selected questions from the SO data dump [ 20] tagged
with “java” that had either of the strings “difference between” or
“vs” in the title. We chose Java since the JDK is one of the most
popular APIs. We obtained 13,228 such questions. Note that this
underestimates the total number of API comparison questions due
to our choice of search strings. For this empirical study, we only
keptquestionswithanacceptedanswerandascoreofgreaterthan
10,leadingtoatotalof1,487questions.BecausewefocusonAPI
class/method comparison, we manually removed questions that
were not about comparing two JDK API classes/methods by ex-
cluding (1) questions aimed at comparing aspects that are not API
classes/methods(2)questionsinvolvingnon-JDKAPIsand(3)ques-tionsaimedatcomparingmorethantwoAPIs.Themanualremoval
wasconductedbytwostudentsindependently(onePhDandone
MS student, both with more than five years Java experience), with
a Cohen’s Kappa agreement [ 10] of 0.897, i.e.,almost perfect agree-
ment. We only kept questions that had been annotated as relevant
by both students, resulting in 215 questions. Note that the total
numberofAPIcomparisonquestionsonSOismuchhigher—the
numberof215is theresultof strict filtering( e.g.,filteringoutall
threads with a score ≤10) to reduce the person power required
formanualannotation.Tofurtherreducetheeffort,werandomly
selected 100 API comparison questions out of the 215 questions for
subsequent analysis.
2.1.2 Protocol. To answer API comparison questions on SO, users
usuallysummarizeinformationaboutacertainaspectofthecom-
pared APIs (e.g., “Hashtable does not allow null keys or values”)
or directly compare APIs on a certain aspect (e.g., “Hashtable is
synchronized,whereasHashMapisnot”).Wecallthiskindofin-
formationinSOanswers answerpoints.Eachanswerpointcanbe
representedasasentenceandasentenceinananswermaycontain
835multipleanswerpoints.Foreachofthe100APIcomparisonques-
tions,wemanuallyextractedanswerpointsfromacceptedanswers,
following these criteria:
1) Extraction of answer points must be performed in order from
the first sentence of the accepted answer to the last.
2) Answer points must be related to at least one of the two API
elements being compared.
3) Extracted answer points must be complete or missing compo-
nents must be completed, and pronouns must be replaced with the
referenced objects.
4) The extracted answer points must be as atomic as possible,
describing the knowledge of a single aspect of the API.
Splitting, simplification, completion, and rephrasing of the orig-
inal sentence are allowed, e.g.,two answer points “Hashtable is
synchronized”and“HashMapisnotsynchronized”areextracted
fromthesentence“Hashtableissynchronized,whereasHashMapis
not”.IfasentencedirectlycomparestwoAPIelements,oneanswer
point is extracted. For example, from “I think the LinkedHashMap
hastobefasterthanHashMapintraversalduetoasuperiornextEn-tryimplementationinitsIterator.”,wewillextract“LinkedHashMap
isfasterthanHashMapintraversal”, i.e.,wemakesimplifications
totheoriginalsentencebutretainthebasicsemantics.Thiskindof
rephrasing has two advantages: (1) to enable better determination
ofwhethertheanswerpointinformationexistsintheAPIreferencedocumentation(e.g., “Hashtableissynchronized,whereasHashMap
isnot”maynotbedescribedbyonesentenceinHashMap’srefer-
ence documentation or HashTable’s reference documentation, but
each documentation page might describe one half – extracting the
original sentence as two answer points makes it easier to find the
corresponding information appearing in the API reference docu-mentatio); and (2) to make it easier for us to classify an answer
point into a single statement type (cf. RQ3).
Foreachanswerpointextracted,wetheninvestigatewhether
and where the information is available in some form in the API
referencedocumentationbyreadingthecorrespondingAPIrefer-
ence documentation of JDK 1.8. The documents considered are not
limited to the documentation of the API classes and methods being
compared, but also include other documents that may be relevant
(e.g.,documentsofparentclasses).Forinvestigatingwhereinthe
APIreferencedocumentationtheinformationfromananswerpoint
islocated,wedefinethedocumentationofaclassasthewholepageofAPIclassdocumentationincludingthedescriptionofallitsmem-
bers, and the documentation of a method as the description of the
method and the entire leading section of the class it belongs to.Ifmorethanonepagecontainstheinformationdescribedbythe
answerpoint,werecordallpages.OurreplicationpackagecontainstypicalexamplesofextractedanswerpointsandcorrespondingAPI
documentation.
Weconducttheannotationofthe100questionsintwophases:
small-scaleannotationbytwoannotatorsandlarge-scaleannota-
tion by one annotator, following the qualitative research design
of previous work (e.g., [4]). During the small-scale annotation, we
asked two students (one PhD and one MS student, both with atleast five years of Java experience) to extract answer points in-dependently for 20 randomly selected questions. Since different
studentsmightusedifferentlanguagestodescribethesameanswer
point, one of the authors examined the answer points extractedtodeterminewhethertheywereidentical(i.e., eitherusedtheex-
actsamelanguageorusedsimilarlanguagetodescribethesame
point,e.g.,“BufferedReader achieves greater efficiency than Input-
StreamReader”,“BufferedReaderismoreefficientthanInputStream-Reader”)andtoresolveconflictswhereneeded.Usingthisprotocol,
weobtained54uniqueanswerpointsafterarbitration,outofwhich
49(91%)wereextractedbybothstudents.Thenforeachofthe54
answer points, the same two students investigated whether the
correspondinginformationisavailableintheAPIreferencedocu-
mentation, and if so, where. We computed the agreement between
thetwostudentsforansweringwhethertheinformationisincluded
inAPIreferencedocumentation,resultinginaCohen’sKappaco-
efficient [ 10] of 0.764 (i.e., substantial agreement). For the location
of theinformation inAPI referencedocumentation, wecombined
the answers of both students. The remaining 80 API comparison
questions were only annotated by one student (i.e., large-scale an-
notation)followingtheguidelinessummarizedfromthesmall-scale
annotation.
For answering RQ3,we determined the statement type thatthe
answerpointscanbeclassifiedintobyqualitativelyanalyzingan-
swer points using open coding. The coding was done by threeauthors of this paper together and started with one seed code
(i.e.,functionality,themostimportantknowledgetypeinAPIref-
erencedocumentation[ 9]).Foreachanswerpoint,threeauthors
decided whichcode the answer pointcan be classified intoby dis-
cussion. If an answer point could not be classified into an existing
code,wecreatedanewcodeormodifiedthedefinitionandname
ofanexistingcode.Ifanewcodewascreatedoranexistingcode
was modified, we re-annotated all answer points that had been
annotated before. We stopped once all answer points had been
classifiedintoanexistingstatementtype, i.e.,code.Toverifythat
our statement type classification is correct and complete, we in-
vitedtwo MSstudents (notinvolved inpreviousannotation) with
more than five years’ experience of Java development to use our
statement types to annotate all answer points of the 100 questions.
Theannotationwasperformedbybothstudentsindependentlyand
ifthey thoughtthatan answerpointcannotbe classifiedintoany
existing statement type, they classified it as unknown. We analyzed
the annotation results and none of answer points was annotated as
unknown (i.e.,nonewcodeisneeded)andthereareno“not-used”
codes (i.e., all codes are useful). The Cohen’s Kappa coefficient [ 10]
is0.880(i.e., almostperfectagreement).Asaresult,weconsiderthe
statement type classification to be correct and complete.
2.2 Result and Analysis
2.2.1 Answer for RQ1. 255 answer points were extracted from the
accepted answersof 100 questions. Themost common caseis two
answer points for one answer (38%), with a maximum of six peranswer(onecase).54questionsareaboutcomparingAPIclasses
and 46 questions are about comparing API methods.
2.2.2 Answer for RQ2. The information for189 of the 255answer
points(74%)isavailableintheAPIreferencedocumentation.For85questions,atleastoneanswerpointisavailableintheAPIreference
documentation. Weconclude that most API comparison questions
couldbecompletelyorpartiallyansweredbytheAPIknowledge
in API reference documentation.
836Figure 1: Conceptual Schema of API Statements
For the 85 questions with at least one answer point available
in the API reference documentation, we counted how many doc-
uments the developer would need to check to answer them. Asa result, 20 questions could be answered by only checking one
document;buttheother65questionscouldonlybeansweredby
checking two or more documents (4 at most). In other words, in
76.5%ofcases,theinformationforansweringanAPIcomparison
question is scattered across documentation of different API ele-ments.Thisfurthermotivatesourworkonprovidingdevelopers
withanautomatedapproachforextractingandsummarizingAPI
comparison knowledge from API reference documentation.
2.2.3 Answer for RQ3. Table1showsthedefinitionsandexamples
ofeightstatementtypeswiththenumberofanswerpoints.Related
concepts and their relations can be explained by the conceptual
schema shown in Figure 1. These eight statement types are further
classified into three aspects: 1) Categorization , including concept
classification,membership;2) Functionality ,includingfunctional-
ity specification, behavior specification, functionality comparison;
3)Characteristic ,includingcharacteristicspecification,character-
istic comparison, constraint.
3 APPROACH
The results of the empirical study imply the necessity and possibil-
ity of automatically discovering and summarizing API comparison
knowledgeintheAPIreferencedocumentation.Wecanextractrele-
vantAPIstatementsandclassifythemintodifferenttypes.Withthe
supportofrelevantknowledge(includingconceptsandrelations)
wecanaligntheAPIstatementsoftwoAPIelementstogenerate
useful API comparison results. We propose a knowledge graphbased approach for comparing two API elements. The approach
(calledAPIComp)consistsofanofflinephaseforAPIknowledge
graph construction and an online phase for generating API com-
parison results (see Figure 2).
API Knowledge Graph Construction . Our API knowledge
graphfollowstheconceptualschemeshowninFigure 1,whichis
obtained by disassembling the relationships among the subjects,predicates, objects, and conditions involved in the eight types of
API statements. We first extract the API structure from the API
referencedocumentation,includingAPIelements(e.g., packages,
classes, interfaces,methods) andtheir relations (e.g., containment,
inheritance, implementation). We extract description sentences
Figure 2: Overview of APIComp
for API elements from the documentation. Based on predefinedtemplates, we use rule-based techniques to extract template nor-
malizedAPIstatementsfromtheAPIstructureandAPIdescription
sentences. The extracted API statements include various concepts
(e.g.,actionsandobjectsoffunctionalityspecifications).Torelate
API statements to each other and provide concept explanations
for them, we further extend the concepts and relations by intro-
ducing general concepts that are related to API statements and by
identifying additional relations. Thegeneral concepts are extracted
from general knowledge graphs (i.e., WikiData [ 25]) and linked
withrelatedconceptsofAPIstatements.Theadditionalrelations
are identified between API statements based on both lexical and
semantic analysis. The extracted API structure and API statements
aswellastheextendedconceptsandrelationsconstitutetheAPI
knowledge graph. We describe the details of these steps below.
API Comparison Service . We first align API statements of
twogivenAPIelementsbasedontheAPIknowledgegraph.The
alignmentidentifiescorrespondingandcomparableAPIstatements
for two APIs. The comparison results for the two API elements are
generatedbasedonthealignedAPIstatements.Theresultsincludeatable(seeFigure 4)showingthecommonalitiesanddifferencesof
the two API elements with explanations for the involved concepts.
Figure 3: An Example of API Knowledge Graph
3.1 Running Example
Figure3showspartoftheknowledgegraphfortheJDKAPI,where
rectangles,whiteellipses,andgrayellipsesdenoteAPIelements,
API statements, and extended concepts, respectively. The knowl-
edgegraphincludesthreekindsofknowledge, i.e.,APIstructure,
APIstatements,andextendedconceptsandrelations.TheAPIstruc-
tureinFigure 3describestwoAPIclasses (java.lang.StringBuilder
andjava.lang.StringBuffer ), related interfaces and methods, and
variousrelations(e.g., implementation)betweenthem(seeSec. 3.2).
837Table 1: API Statement Types Identified in Our Empirical Study
Statement Type Definition Example ClassMethod Total
Concept Classification Describe that an API element is an instance of a category by concept PrintWriter is a stream of characters 36 339
Membership Describe that an API element belongs to a category push operation is part of Stack 1 34
FunctionalitySpecification Describe what an API element can or cannot do SocketChannel reads from sockets 41 5091
Behavior Specification Describe specific behaviors of an API element under a certain condition FileWriter makes system call when calling to write 82028
Functionality ComparisonComparethefunctionalitiesoftwoAPIelementsbythreerelations(equivalentto,similar
to, different from)java.util.Properties is like java.util.Map 6 713
Characteristic
SpecificationDescribe the characteristics of an API element, its property (e.g., StringBuffer capacity)
or functionalityHashtable is synchronized 23 1336
Characteristic
ComparisonCompare the characteristics of two API elements, their properties or functionalities BufferedWriter is more efficient than FileWriter 20 828
ConstraintDescribetheconstraintsofanAPIelementoritspropertyusingpermissionverbs(e.g., al-
low, prohibit, guarantee, limit)HashSet allows null object 13 316
Total 148 107255
Note: Numbers in the table indicate the number of answer points with corresponding statement type for API comparison questions of classes and methodsrespectively
Figure 4: An Example of API Comparison Results
The API statements in Figure 3describe the categories, functionali-
ties,andcharacteristicsofthetwoclasses,whichareextractedfrom
two sources, i.e.,API description sentences and API structure (see
Sec.3.4). For example, the characteristic specification “appendable”
and the concept classification “char sequence” of the two classes
areextractedfromtheirclass-interfaceimplementationrelations
withjava.lang.Appendable andjava.lang.CharSequence respectively;
the characteristic specifications “thread-safe”, “mutable”, and “safe
for use by multiple threads” of java.lang.StringBuffer are extracted
from its description sentences “A thread-safe, mutable sequence of
characters.”and“Stringbuffersaresafeforusebymultiplethreads.”
fromthedocumentationaftersentencecompletionandAPImen-
tion resolution (see Sec. 3.3). The extended concepts and relations
in Figure 3conceptually relate API statements (see Sec. 3.5). For
example, the relations of opposite characteristic specifications and
the shared equivalent characteristic specifications (e.g., “modifi-
able”and“mutable”)areidentifiedtoconceptuallyrelatetheAPI
statements of the two classes. Moreover, general concepts may
also be introduced and linked with the concepts in API statements.
e.g.,“charsequence”islinkedtotheWikiDataconcept“sequence
(ordered list)”2.
BasedontheAPIknowledgegraph,APICompcangeneratecom-
parisonresultsforanytwoAPIelements.Forexample,thecompari-sonresultsfor java.lang.StringBuilder andjava.lang.StringBuffer are
showninFigure 4(excerpt),wherepinkrepresentsconceptclassifi-
cation, orange represents membership, green represents character-
isticspecification,andbluerepresentsfunctionalityspecification.
To generate the result, we first align the API statements of the
two classes (see Sec. 3.6),e.g.,“safe for use by multiple threads”
and “unsafe for use by multiple threads” are aligned based on their
oppositerelationand semanticsimilarity;thecategory“character
sequence”,thecharacteristics“serializable”,“appendable”ofboth
classesarealignedbasedontheirequivalencerelations.Basedon
2https://www.wikidata.org/wiki/Q133250thealignment,acomparisonresultstableisgeneratedbysumma-
rizingthecommonalitiesanddifferencesofthetwoAPIelements
(see Sec.3.7).
3.2 API Structure Extraction
FromtheAPIreferencedocumentationweextractfourtypesofAPI
elements, i.e.,packages, classes, interfaces, and methods, as well
asthefollowingrelationsbetweenthem: containment relations
betweenpackages,classes/interfaces,andmethods; inheritance re-
lations between classes/interfaces; and implementation relations
betweenclassesandinterfaces.TheseAPIelementsandrelations
can be extracted from the corresponding declarations in the docu-mentation based on their structure.
3.3 API Description Sentence Extraction
ToextractdescriptionsentencesforanAPIelement,wesplititstext
description intosentences. Then weidentify and remove sentences
that include code statements for reducing noise. To facilitate theextraction of API statements we conduct additional processing,
namelysentencecompletionandAPImentionresolution,toprovide
more complete description sentences. After that we filter out short
sentences that include no more than two words.
3.3.1 Sentence Completion. The first sentence of the text descrip-
tion of an API element usually provides a brief summary, such
as“Athread-safe,mutablesequenceofcharacters.”for java.lang.-
StringBuffer.Thesesentencesareoftenincompleteandlacksubjects
or predicates. We use an NLP tool (i.e., Spacy) to analyze and iden-
tify incomplete sentences based on the following two criteria: it
isadeclarativesentence;andithasnosubjectorpredicate.Fora
sentence that has no subject we add the fully-qualified name of the
correspondingAPIelementasthesubjectandifthesentencehas
no predicate we further add “is” as the predicate.
3.3.2 API Mention Resolution. TofacilitatetheextractionofAPI
statements we need to replace all the mentions of an API element
with its fully qualified name. First we identify all aliases of an API
element and replace all occurrences of these aliases in description
sentenceswiththefullyqualifiednameofthecorrespondingAPI
element.For eachAPIelement werecognizethe followingaliases:
1) the short name (i.e., the part after the last dot of the fully-
qualified name) of the API element, e.g.,“StringBuilder”;
2) the fully-qualified name or short name of the API element
(method)withoutparameters, e.g.,“java.lang.StringBuilder.append”
and “StringBuilder.append”;
3) the phrase obtained by splitting the short name of the API
element by camel case and underscore, e.g.,“string builder”;
8384) the phrase obtained by adding the type of the API element
(i.e.,package,class,interface,ormethod)afteranalias, e.g.,“String-
Builder class” and “string builder class”.
Then we use a coreference resolution tool (i.e., NeuralCoref3)t o
resolve pronouns which refer to API elements.
3.4 API Statement Extraction
WedesignaseriesofheuristicrulestoextractAPIstatementsfrom
descriptionsentencesandtheAPIstructure.Theserulesaresum-
marizedbyanalyzingthedescriptionsentencesandAPIstructure
identified in the empirical study. The word conversion involved in
the rules is implemented using WordNet [12].
3.4.1 Extracting from Description Sentences. Foreach description
sentence, we first parse it into simple sentences, then use heuristic
rules to extract API statements, and finally normalize the extracted
API statements. The process is described below.
We use Spacy to do POS tagging and dependency parsing for
the sentence. If the sentence is a compound sentence with mul-
tiple predicates, we split it into multiple simple sentences with
onlyonepredicatebyiterativelyexecutingthefollowingrulebased
on the dependency tree: for each subordinate clause, if it is an
adverbialclausethenkeepittogetherwiththemajorclause,oth-
erwise remove it from the sentence, complete its subject if miss-
ing,andtreatitasaseparatesentence.Forexample,thesentence
“java.lang.StringBufferislikeajava.lang.String,butcanbemodified.”
willbesplitintotwosimplesentences“java.lang.StringBufferislike
a java.lang.String” and “java.lang.StringBuffer can be modified”.
Threeauthorsmanuallyanalyzedthedescriptionsentencesfrom
thetwopackagesmostinvolvedinthe100APIcomparisonques-
tionsfromSec. 2.1(i.e.,java.io andjava.util),andsummarizedlin-
guistic patternsiteratively bycreating new patternsor modifying
and merging existing patterns until all patterns were stable. The
resulting27linguisticpatternsareshowninTable 2.Eachlinguistic
pattern is used as a heuristic rule for API statement extraction. For
example, basedon the pattern “ AE1be [similaras/similar to/like]
AE2” (where AE1andAE2represent two API elements) we can
extract a functionality comparison “similar to java.lang.String ” for
java.lang.StringBuffer from the sentence “A StringBuffer is like a
String.”.NotethatmultipleAPIstatementsofdifferenttypesmaybeextractedfromasimplesentenceusingdifferentlinguisticpatterns.
Forexample, wecan extractacategoryclassification“sequence of
characters” and two characteristic specifications “thread-safe” and
“mutable” for java.lang.StringBuffer from “java.lang.StringBuffer is
a thread-safe, mutable sequence of characters.”.
To facilitate the alignment of API statements we further nor-
malizethephrasesintheextractedAPIstatements.First,remove
articles at the beginning, such as “a”, “an”, and “the”. Second, for a
nounphrasehavingtheform“ NP1ofNP2”, “NP2’sNP1,or“NP2’
NP1”,weunifythemintotheform“ NP2 NP1 ”.Forexample,“se-
quenceofcharacters”willbeconvertedinto“charactersequence”.
Third, we convert nouns and verbs to their base forms using Word-
Net. Fourth, we convert adverbs and passive forms of verbs in
characteristic expressions to their adjective forms using WordNet.
For example, “can be modified” will be converted into “modifiable”.
3https://github.com/huggingface/neuralcoref3.4.2 Extracting from API Structure. The following rules extract
API statements from the names of API elements and their inher-
itance/implementation relations. These rules consider the short
names of API elements split by camel case and underscore.
Rule1:ExtractingFunctionalitySpecificationfromClass-
/InterfaceName .Ifthenameofaclassorinterface Cincludesa
noun or noun phrase N1followed by another noun N2andN2can
be converted to a verb, then extract a functionality specificationfor
Cwiththeverbformof N2astheactionand N1astheobject
(e.g.,“build string” for java.lang.StringBuilder ).
Rule2:ExtractingFunctionalitySpecificationfromMethod
Name. If the name of a method Mincludes a verb Vfollowed by a
nounornounphrase N,thenextractafunctionalityspecification
forMwith Vastheactionand Nastheobject(e.g., “setlength”for
java.lang.StringBuilder.setLength(int) ).
Rule3:ExtractingCharacteristicSpecificationfromClass-
/Interface Name . If the name of a class or interface Cincludes
adjectives, then for each adjective extract a characteristic speci-fication for
Cwith the adjective as the characteristic expression.
(e.g.,“writable” for javafx.scene.image.WritableImage).
Rule 4: Extracting Characteristic Specification from In-
heritance/Implementation Relation . If a class/interface C1in-
herits from or implements another class/interface C2and the name
ofC2ends with an adjective, then extract a characteristic spec-
ification for C1with C2’s name as the characteristic expression
(e.g.,“serializable” for java.lang.StringBuilder from its implementa-
tion relation with java.io.Serializable ).
Rule 5: Extracting Category Classification from Inherita-
nce/Implementation Relation . If a class/interface C1inherits
from or implements another class/interface C2and the name of C2
isanounornounphrase N,thenextractacategoryclassification
forC1with Nasthecategory(e.g., “charsequence”for java.lang.-
StringBuilder from implements java.lang.CharSequence ).
3.5 Concept and Relation Extension
Different API statements may use different language to express
thesameorsimilarknowledge.TofacilitatethealignmentofAPI
statementsweneedtoestablishconceptualrelationsbetweenthem.
In addition, to bridge conceptual gaps we also need to introduce
additional concepts and relations from a general knowledge graph.
3.5.1 Equal/Opposite Characteristics. Some API statements de-
scribeequaloroppositecharacteristicsofAPIelements,forexample
“mutable”and“modifiable”areequalwhile“safeforusebymulti-
ple threads” and “unsafe for use by multiple threads” are opposite.
These relations can be discovered by identifying synonyms and
antonyms in the adjectives of API characteristics using a lexical
database (e.g., WordNet [ 12]) and thesaurus (e.g., Thesaurus4). For
twoAPIcharacteristics AC1andAC2thathavethesameconditions
or no conditions, we use the following rules to identify possible
equal/opposite characteristic relations between them:
1) if the adjectives of AC1andAC2are synonyms in WordNet
orThesaurus(e.g., “mutable”and“modifiable”),orhavethesame
etymology (e.g., “synchronized” and “synchronous”), add a relation
<AC1, same as, AC2>;
4https://www.thesaurus.com
839Table 2: Linguistic Patterns for Extracting API Statements from Description Sentences
Statement Type Linguistic Pattern Example
Concept Classification AE[be/represent] (a/an) JJ* NP The GridLayout class is a layout manager.
Membership [AE/NP] [belong to/be part of/be a member of/have] [AE/NP] Queue is a member of the Java Collections Framework.
Functionality SpecificationAE VB((ADP) NP)+ (RB) BufferedReader reads text from a character-input stream.
AEbe [used/designed/provided] to VB((ADP) NP)+ ClassDesc is used to marshal java.lang.Class objects over IIOP.
AEbe [used/designed/provided] for VBG((ADP) NP)+ SynthPainter is used for painting portions of JComponents.
AEbe (JJ/NP) for VBG((ADP) NP)+ AsynchronousFileChannel is an asynchronous channel for reading file.
AEbe (JJ/NP) to VB((ADP) NP)+ The CertPathBuilder is able to restore prior path validation states.
NPbeVBNbyAE The modeling of HTML is provided by the class HTMLDocument.
AEbeVBN((ADP) NP)+ Image.getSource() is called by the image filtering classes and by methods .
AE1 VB((ADP) NP)+ RBR than AE2(COND) BufferedWriter writes file faster than OutputStreamWriter.
Behavior SpecificationAE VB((ADP) NP)+ (RB) COND isCellEditable(EventObject) returns true if anEvent is not a MouseEvent.
AEbe [used/designed/provided] to VB((ADP) NP)+COND TypeVisitor is used to operate on a type when the kind of type is unknown at compile time.
AEbe [used/designed/provided] for VBG((ADP) NP)+COND FileReader is used for reading file when IO is ready.
AEbe (JJ/NP) to VB((ADP) NP)+COND The ImageProducer is free to ignore this call if it cannot resend the data in that order.
AEbe (JJ/NP) for VBG((ADP) NP)+COND FileInputStream is for reading streams of bytes during threads communicate.
NPbeVBNbyAE COND File descriptor is modified by FileWriter when the thread starts.
AEbeVBN((ADP) NP)+COND Object.finalize()iscalledbythegarbagecollectoronanobjectwhengarbagecollectiondetermines.
Functionality ComparisonAE1be [same as/equivalent to] AE2 String.copyValueOf(char[]) is equivalent to String.valueOf(char[]).
AE1be [similar as/similar to/like] AE2 A StringBuffer is like a String.
AE1be [different from/unlike] AE2 InsufficientResourcesException is different from LimitExceededException .
Characteristic SpecificationAEbe [a/an] JJ+N P( COND) StringBuilder is a mutable sequence of characters.
AEbeJJ(COND) Instances of StringBuffer are thread-safe and mutable.
AE[can/could] be VBN(COND) StringBuffer could be modified.
AE VB((ADP) NP)+RB(COND) Filereader reads file efficiently.
Characteristic ComparisonAE1beJJRthan AE2(COND) ArrayDeque is faster than LinkedList when used as a queue.
AE1 VB((ADP) NP)+RBRthan AE2(COND) BufferedWriter writes file faster than OutputStreamWriter.
Constraint AE PV NP IdentityHashMap allows null values and the null key.
Note: AE (API element), NP (noun phrase), VB (verb), ADP (adposition), RB (adverb), RBR (adverb, comparative), JJ (adjective), JJR (adjective, comparative), VBN (past participle), VBG (present participle),
PV (permission verb, e.g., allow/guarantee/prohibit/limit), COND (condition, including adverbial clause, prepositional phrase).
2) if the adjectives of AC1andAC2are antonyms in WordNet or
Thesaurus(e.g., “safe”and“dangerous”),oronecanbetransformed
intotheotherbyaddingnegativeprefixes(e.g., “un”,“dis”,“anti”,
“ir”, “im”, “in”, “non”), add a relation < AC1, opposite of, AC2>.
3.5.2 Noun Concept Categorization. API statements involve many
noun concepts, e.g.,category in concept classification and mem-
bership. The names of these concepts may imply categorization
relations, e.g.,<bufferedwriter,is,writer>and<charactersequence
length, belong to, character sequence>. For two noun concepts C1
andC2intheextracted APIstatements,weuse thefollowingtwo
rules to identify possible categorization relations between them:
1)ifC1’snameisshorterthanandtheprefixof C2’snameand
there are no other longer concepts that satisfy this rule for C1, add
a relation < C2, belong to, C1>;
2)ifC1’snameisshorterthanandthesuffixof C2’snameand
there are no other longer concepts that satisfy this rule for C1, add
a relation < C2, is,C1>.
3.5.3 General Concepts and Relations. APIstatementsinvolvemany
noun concepts that are included in general knowledge graphs like
Wikidata[ 25].Relevantconceptsandrelationsingeneralknowl-
edgegraphsprovideadditionalknowledgeforAPIalignment.For
example, Wikidata provides knowledge like string is a sequence
ofcharactersandadatatype,and“str”isanaliasof“string”.This
knowledge not only helps to connect different API statements, but
also provides the required concept explanations. To harvest this
knowledgeweneedtolinktheconceptsinAPIstatementstothose
inWikidata.Thisconceptlinkingcannotbeeasilyresolvedbyname
matching,aspolysemantsarepopularamongWikidataconcepts.
e.g.,besides data type, “string” can also be a family name [ 28], a
musical instrument part [29], or a physical phenomenon [30].
Todecidewhetheraconcept CAinAPIstatementscanbelinked
to a concept CWin Wikidata, we consider: 1) whether the topic
ofCWis relevant to the API reference documentation; 2) whether
the local contexts of CAandCWare similar. We measure bothaspects based on the vector representations of words learned using
a Word2Vec [ 11] model. We use the 100-dimensional Word2Vec
model pretrained on the Wikipedia corpus5and tune the model
basedonthecorpusofallAPIdescriptionsentencesusinggensim6.
The topics of the API reference documentation are represented
by the names and aliases of all noun concepts involved in API
statements.Thelocalcontextof CAisreflectedbyitsneighbouring
concepts and itself in the API knowledge graph. Similarly the local
contextof CWisreflectedbyitsneighbouringconceptsanditself
in Wikidata.
3.6 API Statement Alignment
Given two API elements, we collect related API statements and
identify corresponding statements that can be aligned.
For an API element we collect and consider all its API state-
ments for alignment. If it is a class, we also collect and considerthe API statements of the classes/interfaces that it inherits from
orimplementsandthefunctionalityspecificationsofitsmember
methods.Forexample,for java.lang.StringBuffer weconsiderthe
characteristic“readable”,as itis thecharacteristic ofthe interface
java.lang.CharSequence whichitimplements.Thenwemergedu-
plicateAPIstatements, e.g.,incaseswherethesamestatementwas
collected from a class and its parent class. To determine whether a
statement S1of an API element E1can be aligned with a statement
S2of another API element E2, we calculate their relevance based
on both conceptual distance and text similarity.
Theconceptualdistancebetween S1andS2ismeasuredbased
ontheirdistanceintheknowledgegraph.EachAPIstatementhasacoreentityintheknowledgegraphasshowninFigure 1:forconcept
classification or membership, it is the category; for functionalityspecification, it is the functionality; for behavior specification, itis the behavior; for functionality comparison, it is the other API
5https://github.com/3Top/word2vec-api
6https://radimrehurek.com/gensim
840elementinthecomparison;forcharacteristicspecificationorcon-
straint, it is the characteristic. The distance between S1andS2can
bemeasured asthe lengthof theshortestpath betweentheir core
entities in the knowledge graph.
Thetextsimilaritybetween S1andS2ismeasuredbythesimi-
larity of their description words. The description words of an API
statement Sarethenamesandaliasesofallconceptsin Graph(S).
WeusethesameWord2VecmodelasinSec. 3.5.3tomeasurethe
text similarity between S1andS2by: 1) generating a vector for
S1andS2respectivelybyaveragingthevectorsofitsdescription
words;and2)calculatingcosinesimilaritybetweenthetwovectors.
Thentheconceptualdistanceandtextsimilaritybetween S1and
S2can be calculated as Equation 1and Equation 2respectively,
where Simcos(VS1,VS2)isthecosinesimilaritybetweenthevectors
ofS1andS2.ThecombineddistancecanbecalculatedasEquation 3,
where w1andw2aretwoweightssatisfying w1+w2=1.w1and
w2are set to 0.6 and 0.4 respectively by tuning on a test set.
Relconcept(S1,S2)=1/(distance (S1,S2)+1) (1)
Reltext(S1,S2)=(Sim cos(VS1,VS2)+1)/2 (2)
Relcombined (S1,S2)=w1×Relconcept(S1,S2)+w2×Reltext(S1,S2)(3)
FinallywedeterminethealignmentbetweentheAPIstatements
ofE1andE2.First,wegenerateasetofcandidatepairsandeachpair
hastwoAPIstatementsfrom E1andE2respectively.Toensurethat
only corresponding and comparable API statements are aligned,
we divide the API statements into four kinds: 1) concept classifi-
cation; 2)membership; 3) functionalityspecification (including its
characteristic), behavior specification, functionality comparison; 4)
characteristicspecification,characteristiccomparison,constraint.
Only API statements of the same kind can be aligned between two
API elements. Second, we remove all candidate pairs whose dis-
tance is lower than a threshold (i.e., 0.3 in our implementation).
Thisthresholdissetbasedonpreliminaryexperiments.Third,we
considereachoftheremainingcandidatepairsintheorderofrel-
evance(fromhightolow):ifneitheroftheAPIstatementsinthe
pair is aligned, accept the pair as an aligned pair. Finally, all the
accepted pairs are output as the results of alignment (see Figure 4).
3.7 API Comparison Generation
ThecomparisonresultsbetweentwoAPIelementsincludethree
parts:statementsforcommonalities,statementsfordifferences,and
unaligned statements.
ForanalignedpairofAPIstatements,ifallconstituents(e.g., the
action and object of a functionality specification, see Figure 1)a r e
thesameentitiesorentitiesconnectedby“sameas”relationsinthe
knowledgegraph,wetreatthepairasacommonality;otherwise,
we treat it as a difference. Unaligned statements are sometimes
duplicatedexpressionsofthesamestatements.Toreducethedupli-
cationweidentifyandmergeduplicatedstatementsofthesameAPIelementfollowingthesameprocessasforAPIstatementalignment,
e.g.,the characteristic “thread-safe” is a duplicated expression of
“safeforusebymultiplethreads”inFigure 4andmergedintolatter.
Ourconcept-basedAPIcomparisoncanfurtherprovideexplana-
tionsforinvolvedconcepts( e.g.,“thread”,“serializable”)basedon
the knowledge graph. The sources of the explanations include the
aliases of the concept, the definition of the concept from Wikidata,
and the definition of an API element in the documentation.4 EVALUATION
WeconstructedanAPIknowledgegraphforJDK1.8.Wedeveloped
a web crawler based on Scrapy 1.7.17to obtain HTML pages of the
JDK1.8APIreferencedocumentation8.ThenweusedBeautifulSoup
4.4.09to extract the API structure and text descriptions from the
HTML pages. After that we used Spacy 2.110as NLP tool to extract
API description sentences and API statements.
The resulting API knowledge graph includes 188,163entities
and339,770relations.Amongthem,thereare 44,809APIelements
and52,471relations between these API elements. The knowledge
graph includes 123,627API statements: 14,336for concept classi-
fication,21,104formembership, 62,641forfunctionalityspecifica-
tion,14,184forbehaviorspecification, 705forfunctionalitycom-
parison,10,698for characteristic specification, 394for characteris-
ticcomparison, 270forconstraint.AmongtheseAPIstatements,
22,985are extracted from API structure and the other 100,642
are extracted from API description sentences. In concept and rela-
tionextension,weintroduced 2,404equal/oppositecharacteristic
relations, 117,300noun concept categorization relations, 6,245
Wikidata concepts and 1,677noun concept links to Wikidata.
WealsoappliedourapproachtoAndroidSDK27andobtained
the same accuracy and effectiveness results as reported in Sec-tion4.1and Section 4.2for JDK. The resulting API knowledge
graph includes 271,162entities and 572,098relations. Due to the
spacelimitation,wecannotreporttheexperimentresultsonAn-
droidSDKindetailsinthispaper,butallexperimentsresultscan
be found in the replication package [1].
We conducted a series of experiments to evaluate the quality
oftheAPIknowledgeandtheeffectivenessandusefulnessofour
approach by answering the following research questions:
RQ4 (Quality) :Whatistheintrinsicqualityoftheknowledge
captured in the API knowledge graph?
RQ5 (Effectiveness) : How effective is APIComp in generating
API comparison results in terms of completeness, conciseness, and
understandability?
RQ6 (Usefulness) : How useful are the results generated by
APIComp in helping developers during API selection tasks?
4.1 Quality of Extracted API Knowledge (RQ4)
Our quality evaluation focuses on API statements as well as ex-
tendedconceptsandrelationssincetheAPIstructureisextracted
from structured information and thus intrinsically accurate.
4.1.1 Protocol. Similar to previous studies [ 7,26], we adopted a
sampling method [ 18] to ensure that ratios observed in the sample
generalizetothepopulationwithinina certainconfidenceintervalat a certain confidence level. For a confidence interval of 5 at a 95%
confidence level, the required sample size is 384.
We randomly selected 384 API statements for each of the three
aspects (i.e., category, functionality, characteristic) and each of the
twosources(i.e., APIstructure,descriptionsentences).Forextended
concepts and relations, we randomly selected 384 instances forequal/opposite characteristics, noun concept categorization, and
7https://scrapy.org
8https://docs.oracle.com/javase/8/docs/api
9https://www.crummy.com/software/BeautifulSoup/bs4/doc/
10https://spacy.io
841Table 3: Accuracy of API Statements
AspectAPI Structure Description Sentences
Accuracy Agreement Accuracy Agreement
Functionality 0.820 0.734 0.956 0.850
Category 1.000 1.000 0.956 0.915
Characteristic 0.945 0.975 0.698 0.706
Table 4: Accuracy of Concept and Relation Extension
Extension Approach Accuracy Agreement
Equal/Opposite Characteristics 0.740 0.914
Noun Concept Categorization 0.758 0.829
General Concept Linking 0.768 0.779
general concept linking. We invited two Master students (not affili-
ated to this work) familiar with Java to label the accuracy of the
selectedsamples independently.The criterionisthat anextracted
APIstatementoranextendedconcept/relationiscorrectandmean-
ingful. They were provided with the sources of the knowledge and
related documentation to make decisions. For each sample, if it
was labeled differently, a third student was assigned to give an
additional label to resolve the conflict by a majority-win strategy.
4.1.2 Results. The results are shown in Table 3and Table 4. For
each sample we provide the accuracy and Cohen’s Kappa agree-
ment [10]. We can see the agreement rates are all above 0.7, in-
dicatingsubstantialoralmostperfectagreement.Theaccuracyisgenerallyhigh(above0.8)exceptforthecharacteristicsextracted
from description sentences (0.698). We obtained similar results for
Android: the accuracy of API statement extraction from API struc-
tureandsentencesis0.878-0.940and0.682-0.904respectively;the
accuracy of concept and relation extension is 0.706-0.872.
Typical problems of API statements extraction include: 1) incor-
rect splitting of API names, e.g.,“getIssuerX500Principal” is split
into “get issuer X 500Principal”; 2) incomplete sentences caused by
incorrect HTML parsingor sentence splitting, e.g.,“java.sql.Resul-
tSetMetaData.isSearchable(int) indicate.”; 3) POS tagging or depen-
dencyparsingerrors, e.g.,“always-on-top”fromsentence“java.awt.-
Window.setAlwaysOnTop(boolean)isalways-on-top...”istagged
asanoun;4)meaninglessstatements, e.g.,“common”isextracted
as a characteristic of some APIs. The last one is the primary cause
for lower accuracy for extracting characteristics from sentences.
Typical problems of the extension of concepts and relations
include: 1) false categorization relation for non-noun concepts,
e.g.,<secondparameter,belongto,second>;2)falseconceptlinking
duetothelackofcontext, e.g.,“accumulator”islinkedto“recharge-
able battery (accumulator)”.
4.1.3 Summary. Thequalityofdifferentkindsofknowledge(i.e., API
structure, statements, and extended concepts/relations) in the API
knowledgegraphisofhighquality.Typicalproblemswiththequal-ityofextractedknowledgeincludetextprocessingerrors,meaning-
lessstatements,andfalseconceptlinking.Theseproblemscanbe
solvedinthefuturebydevelopingtextprocessingtechniquesfor
softwaretext,designingmorerulestoselectmeaningfulstatements,
and training models for concept linking and filtering.
4.2 Effectiveness of API Comparison (RQ5)
We compare the API comparison results produced by APIComp to
those produced by a baseline approach.
4.2.1 Baseline Approach. Since there is no existing approach that
candirectlycomparetwoAPIelementstothebestofourknowledge,we implementeda baselineapproach basedon heuristicrules and
text similarity. Given two API elements, we obtain all their descrip-
tionsentences,completethesentencesandresolveAPImentions
in the same way as the steps described inSec. 3.3in our approach.
We then select description sentences as the comparison result in
the following two ways. First, we select all sentences that mention
bothAPIelements(Type1sentence).Second,weselectsentence
pairs that are similar for each API element (Type 2 sentence).
We use the same Word2Vec model (see Sec. 3.5.3) to calculate
the similarity between two sentences: 1) remove API elements and
converteachsentencetoabagofwordsafterpreprocessing( i.e.,to-
kenization, stop word removal, and lemmatization); 2) generatea vector for each sentence by averaging the vectors of their bagof words; and 3) calculate the cosine similarity between the two
vectors. We calculate the similarity between each pair of sentences
from thetwo API elements andfilter out candidatepairs with low
similarity(i.e., lowerthan0.6).Thisthresholdissetbasedonprelim-
inaryexperiments.Thenweordertheremainingcandidatepairsby
similarityanduseagreedyselectionmethodtoacceptpairsfrom
hightolowsimilaritywiththeconditionthatnoneofthesentences
inapairincludedinanacceptedpair.Theselectedsentencesare
organized in a table, each row corresponding to a Type 1 sentence
orapairofType2sentences.Ascreenshotofthebaselineisshown
in the replication package [1].
Thisprocessaimstoemulatetheprocessofadeveloperbrowsing
twopagesoftheAPIreferencedocumentationandsummarizingthe
commonalities and differences of two API elements from the docu-
mentation, similar to the process suggested by SO questions about
comparing API elements (see Sec. 2.1). In contrast, APIComp ex-
plicitly constructs a knowledge graph for extracted API statements
and identifies corresponding and comparable API statements by
combining conceptual distance and text similarity.
4.2.2 Tasks. Werandomlyselected20APIcomparisonquestions
from the 85 questions in our empirical study that have at least one
answerpointintheAPIreferencedocumentation.Eachquestion
is used as an API comparison task and only the answer pointsavailable in the API reference documentation are considered. In
thisway,weobtain20APIcomparisontaskswith52answerpoints.
4.2.3 Protocol. We invited four Master students (familiar with
Java) to evaluate the results. For each task we produced a compari-
sonresultbyAPICompandthebaselineandshowedthetworesults
in a random order to the participants. They were asked to evaluate
each result in terms of completeness, conciseness, and understand-
ability on a 4-points Likert scale (1-disagree; 2-somewhat disagree;
3-somewhat agree; 4-agree) by the following questions:
1)Completeness .Doestheresultcontainallthenecessaryin-
formation to show the commonalities and differences?
2)Conciseness . Does the result contain no (or very little) un-
necessary or redundant information?
3)Understandability. Is the result understandable?
Wefurtherconducteda coverageevaluation bycomparingthe
two approaches against the answer points in the corresponding
SOquestions.Weinvitedtwostudents(onePhDandoneMaster
student) to check the API comparison results independently. For
each result they checked each answer point and labeled whether it
wascoveredintheresult.Iftheirdecisionsweredifferentathird
842Figure 5: Effectiveness of APIComp and Baseline Approach
student (Master) was assigned to give an additional label to resolve
the conflict by a majority-win strategy.
4.2.4 Results. TheresultsofthecomparisonareshowninFigure 5.
For completeness, conciseness, and understandability of APIComp,
63.75%, 83.75%, 92.50% respectively of the answers are 4 or 3 (agree
or somewhat agree). For completeness, conciseness, and under-
standability of the baseline, 58.75%, 58.75%, 67.50% respectivelyof the answers are 4 or 3 (agree or somewhat agree). Welch’s T-test [
27] was used for verifying the statistical significance of the
difference between the APIComp and baseline ratings for com-
pleteness, conciseness, and understandability. The differences are
statistically significant( p<<0.05) forconciseness andunderstand-
abilityandnotstatisticallysignificant( p=0.07)forcompleteness.
The coverage evaluation shows that APIComp covers 62.3% of the
answer points, while the baseline covers 47.2%. Cohen’s Kappaagreement for the two approaches are 0.807 and 0.811 (both al-
most perfect agreement). We obtained similar results for Android:
APICompcovers19(79.2%)ofthe24answerpointswithCohen’s
Kappa agreement of 0.864.
TheimprovementofAPICompoverthebaselinecanbeattrib-
uted to the knowledge based API statement analysis. For example,
forthecomparisonbetween java.util.concurrent.CopyOnWriteArray-
Listandjava.util.LinkedList APICompcanextractacharacteristic
specification “thread-safe” and “not synchronized” from the sen-
tence “java.util.concurrent.CopyOnWriteArrayList is a thread-safe
variantofArrayList...”and“Notethatjava.util.LinkedListisnotsyn-
chronized”respectively.ThetwoAPIstatementsarethenalignedas
a difference based on the “same as” relation between “thread-safe”
and “synchronized” and the opposite relation between “synchro-
nized”and“notsynchronized”.Incontrast,thebaselineapproach
alignsthefirstsentencewithanothersentence“java.util.LinkedList
implements all optional list operations, and permits all elements.”.
4.2.5 Summary. Ourapproachissignificantlybetterthanthebase-
line in terms of conciseness andunderstandability. Moreover, our
approach covers more answer points of API comparison questions
by15.1percentagepoints.Theimprovementcanbeattributedto
the knowledge graph based API statement analysis.
4.3 Usefulness of API Comparison (RQ6)
We evaluate the usefulness of APIComp in API selection tasks,
thatis,choosingthemostsuitableAPIelementbetweentwoAPI
elementsinagiven scenario.Notethatthisisdifferent fromAPI
retrieval, where the task would be to find potentially suitable API
elements among hundreds or thousands of possible elements.4.3.1 Tasks. We selected API selection tasks from the 215 API
comparisonquestionsinourempiricalstudybasedonthefollowing
criteria: 1) provide a scenario description that can be used to select
a single API element from the candidates; 2) have an API element
selectedintheacceptedanswer,whichindicatesthattheselected
APIis therightchoice forthegiven scenario;3)theAPI selection
can be determined based on the API reference documentation. We
ranked the questions meeting the above criteria by their votes
andselectedTop-6classcomparisonquestionsandTop-6method
comparisonquestionsasthetasks.Inthiswaywegot6APIclass
selection tasks and 6 API method selection tasks, each with two
APIelements,ascenariodescription,andarightanswer(i.e., oneof
the two API elements), all included in the replication package [1].
4.3.2 Protocol. We invited 12 Master students with 1-4 years Java
programmingexperience.Theyrepresentnovicedevelopers,which
are the primary target audience for API comparison. None of them
participatedinthequalityandeffectivenessexperimentsforRQ4
and RQ5. We conducted a pre-experiment survey on their Java
programmingexperienceanddividedthemintotwo“equivalent”
groups( GAandGB)basedonthesurvey.Werandomlydividedthe
12 tasks into two groups ( TAandTB), each with 3 class selection
tasks and 3 method selection tasks.
A common way for API selection without APIComp is to use
search engines (i.e., Google) to search various Web resources such
asAPIreferencedocumentations,tutorials,andonlineposts.There-
fore, in this experiment we asked participants to complete API
selection tasks with APIComp and without APIComp (i.e., only us-
ingGoogle)toevaluatetheusefulnessofAPICompinAPIselectiontasks. We adopted a balanced treatment distribution for the groups.Participantsingroup
GAwereaskedtocompletethetasksingroup
TAwith APIComp and the tasks in group TBwithout APIComp.
Conversely,participantsingroup GBwereaskedtocompletethe
tasksingroup TBwithAPICompandthetasksingroup TAwithout
APIComp.Foreachparticipant,thetaskswereinterleaved,onecom-
pleted with APIComp and onewithout APIComp. For each task, a
participantwasaskedtoselectanAPIelementfromtwocandidates
for a given scenario description. If participants completed tasks
withoutAPIComp, theycan searchwith anykeywords onGoogle
andcheckanyWebpagesexceptthecorrespondingSOquestion.
The participants usingAPIComp make the decisionbased on only
theresultsgeneratedbyAPIComp.Aparticipantcansubmitone
of thetwo candidate API elements as the answeror none ofthem
ifhe/shecannotdetermine.Thecorrectnessandcompletiontime
of each participant for each task were recorded.
4.3.3 Results. Figure6showstheaccuracy(i.e., theratiothatthe
right APIs were selected by a participant group for a task) and the
completion time of the two participant groups over the two groups
of tasks when completed with APIComp and without APIComp re-
spectively.UsingAPICompparticipants(inbothgroups)completed
thetasks41%faster(82secondsonaverage)and14.5%moreaccu-
rately(about0.10)thanwithoutAPIComp.WeuseWelch’sT-test
for verifying the statistical significance of the differences. The dif-
ference in time is statistically significant ( p<<0.05), while the
difference in accuracy is not significant ( p=0.18).
843(a) Accuracy
 (b) Time
Figure 6: Usefulness Evaluation for API Selection Tasks
Note that without APIComp the participants can search on
GooglenotonlytheAPIreferencedocumentationbutalsootheron-
lineresources(e.g., blogs)thatdiscussanAPIselectiontask. e.g.,the
APIelementscomparedinthetask“Whichclassismoreefficientfor
non-threadedapplications?java.util.Hashtableorjava.util.HashMap”
are often discussed together. It is therefore easy for the partici-pants to find the right answer from Google search results. The
API elements in another task “When developing a JDBC driver,
which one should be used if considering the exception chaining
mechanism? java.lang.Throwable.getCause() or java.sql.SQLExcep-
tion.getNextException().” are not often discussed together. For this
task the participants chose the right API element much faster (74s
vs 200s) and more accurately (0.83 vs 0.67) with APIComp.
4.3.4 Summary. Our approach significantly decreases the amount
oftimedevelopersneedforAPIselectiontasks.Theadvantageis
more significant when the compared API elements are not often
discussed together online.
5 THREATS TO VALIDITY
Theempiricalstudyandtheevaluationsharecommonthreatsto
validity. A threat to the internal validity is the subjective judgment
indifferentparts,forexampletheevaluationofthequalityofex-
tractedAPIknowledge.Toalleviatethisthreatwehavereported
the agreement for eachsubjective judgment or the corresponding
statisticalsignificance.Athreattotheexternalvalidityisthelimited
numberofsubjects (e.g., APIcomparisonquestions, tasks)consid-
ered indifferent partsand thefact thatwe onlyconsider JDKand
AndroidAPIs.Ourfindingsmaynotgeneralizetootherlibraries.
Another threat to the internal validity of the evaluation is the base-
lineapproachusedintheeffectivenessstudy(seeSec. 4.2)which
was implemented by ourselves and may not be optimized. To alle-
viate this threat we have tried to follow state-of-the-art techniques
(e.g.,Word2Vec) to create a comparable tool.
6 RELATED WORK
APIdocumentationisanimportantsourceofknowledgeforsoft-
ware developers, leading to a substantial body of work on API
documentation. Shi et al.[17] conducted a quantitative study of
API documentationevolution andfound thatit undergoes frequent
evolution. Monperrus et al.[13] presented a study on directives in
APIdocumentationandataxonomyof23kindsofAPIdirectives.
MaalejandRobillard[ 9]reportedonastudyofknowledgepatterns
inAPIdocumentation,suchasfunctionality,concepts,anddirec-
tives. They found that most API comparison questions could be
answered with knowledge from the API reference documentation.Inthiswork,wefurtherclassifythestatementsusedtoanswerAPI
comparison question into 3 aspects and 8 statement types.
Other workrelated toAPI documentation hasattempted toen-
rich API documentation with other sources, e.g.,by recovering
traceability links between APIs and their learning resources [ 2],
discovering relevant tutorial fragments [ 6], linking source code
examples to API documentation [ 21], or extracting API-related
insights from Stack Overflow [ 24]. These approaches link APIs
with relevant text or code fragments in various learning resources,
but they do not deeply mine the knowledge that already exists
intheAPIdocumentation.Incontrast,weextractAPIstatements
from API reference documentation and store them as a knowledge
graph. Further, we help to answer API comparison questions from
Stack Overflow with API documentation, which is a supplement to
previous work [24].
Other researchers have attempted to extract useful pieces of
knowledgefromAPIdocumentationbyinferringAPIspecifications
anddirectivessuchasresourcespecifications[ 31],methodspeci-
fications [ 15], and parameter constraints andexception-throwing
declarations [ 32], or API caveats [ 7]. These types of knowledge
are useful for understanding the usage of APIs, in particular interms of API directives. In contrast, we focus on extracting APIstatements related to three aspects (functionality, characteristic,
and categorization) which are relevant to API comparison.
Therearealsomanystudiesfordocumentcomparisongenera-
tion [5,16,23] for other domains (e.g., news reports). These cannot
beappliedtoAPIcomparisonsincethey(1)donottakeintoaccount
the specific types of knowledge required for API comparison; (2)are designed for documents with other characteristics, e.g.,with-
outcodeelements;and(3)cannotmineknowledgefromtheAPI
structure which is essential for API comparison.
Other work focuses on generating summaries for API elements.
Sridhara et al.[19] generated summaries for Java methods using
structure and linguistic information. Moreno et al.[14] provided
JSummarizertoautomaticallygeneratesummariesofJavaclasses,
and Liuet al.[8] designed KG-APISumm to generate query-specific
API class summaries through an API knowledge graph constructed
from API reference documentation. All of these can only generate
summaries for a single API element and the information contained
intheirsummariesisnotapplicabletoAPIcomparisoninvolving
two API elements.
7 CONCLUSION
In this paper, we conducted an empirical study on API comparison
questionsandidentified8typesofAPIstatementsthatareusefulfor
API comparison. We proposed a knowledge graph based approach
APICompforgeneratingAPIcomparisonresults.Ourevaluation
confirmsthequalityofvariouskindsofknowledgeintheknowl-
edgegraph,andtheeffectivenessandusefulnessofthegenerated
API comparison results. In the future, we will improve and extend
our approach by supporting context aware API comparison and
automaticallyidentifyingandrecommendingsimilarAPIelements.
ACKNOWLEDGMENTS
This work is supported by National Natural Science Foundation of
China under Grant No. 61972098.
844REFERENCES
[1]2020.ReplicationPackage. RetrievedAugust31,2020from https://fudanselab.
github.io/Research-ASE2020-APIComp/
[2]BarthélémyDagenaisandMartinP.Robillard.2012. Recoveringtraceabilitylinks
betweenanAPIanditslearningresources.In 34thInternationalConferenceon
Software Engineering, ICSE 2012, June 2-9, 2012, Zurich, Switzerland. 47–57.
[3]DavideFucci,AlirezaMollaalizadehbahnemiri,andWalidMaalej.2019. Onusing
machine learning to identify knowledge in API reference documentation. In
ProceedingsoftheACMJointMeetingonEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering,ESEC/SIGSOFTFSE
2019, Tallinn, Estonia, August 26-30, 2019, Marlon Dumas, Dietmar Pfahl, Sven
Apel, and Alessandra Russo (Eds.). ACM, 109–119.
[4]Hideaki Hata, Christoph Treude, Raula Gaikovina Kula, and Takashi Ishio. 2019.
9.6 million links in source code comments: purpose, evolution, and decay. In
Proceedings of the 41st International Conference on Software Engineering, ICSE
2019, Montreal, QC, Canada, May 25-31, 2019. 1211–1221.
[5]Xiaojiang Huang, Xiaojun Wan, and Jianguo Xiao. 2011. Comparative NewsSummarizationUsingLinearProgramming.In The49thAnnualMeetingofthe
Association for Computational Linguistics: Human Language Technologies, Pro-
ceedings of the Conference, 19-24 June, 2011, Portland, Oregon, USA - Short Papers.
The Association for Computer Linguistics, 648–653.
[6]HeJiang,JingxuanZhang,ZhileiRen,andTaoZhang.2017. Anunsupervised
approachfordiscoveringrelevanttutorialfragmentsforAPIs.In Proceedingsof
the39thInternationalConferenceonSoftwareEngineering,ICSE2017,BuenosAires,
Argentina, May 20-28, 2017. 38–48.
[7]Hongwei Li, Sirui Li, Jiamou Sun, Zhenchang Xing, Xin Peng, Mingwei Liu, and
XuejiaoZhao.2018. ImprovingAPICaveatsAccessibilitybyMiningAPICaveats
KnowledgeGraph.In 2018IEEEInternationalConferenceonSoftwareMaintenance
and Evolution, ICSME 2018, Madrid, Spain, September 23-29, 2018. 183–193.
[8]Mingwei Liu, Xin Peng, Andrian Marcus, Zhenchang Xing, Wenkai Xie, Shuang-
shuangXing,andYangLiu.2019. Generatingquery-specificclassAPIsummaries.InProceedingsoftheACMJointMeetingonEuropeanSoftwareEngineeringConfer-
enceandSymposiumontheFoundationsofSoftwareEngineering,ESEC/SIGSOFT
FSE 2019, Tallinn, Estonia, August 26-30, 2019. 120–130.
[9]Walid Maalej and Martin P. Robillard. 2013. Patterns of Knowledge in API
Reference Documentation. IEEE Trans. Software Eng. 39, 9 (2013), 1264–1282.
[10]Mary L McHugh. 2012. Interrater reliability: the kappa statistic. Biochemia
medica: Biochemia medica 22, 3 (2012), 276–282.
[11]Tomas Mikolov, Ilya Sutskever, Kai Chen, Gregory S. Corrado, and Jeffrey Dean.
2013. Distributed Representations of Words and Phrases and their Composi-
tionality.In AdvancesinNeuralInformationProcessingSystems26:27thAnnual
ConferenceonNeuralInformationProcessingSystems2013.Proceedingsofameeting
held December 5-8, 2013, Lake Tahoe, Nevada, United States. 3111–3119.
[12]GeorgeA.Miller.1995. WordNet:ALexicalDatabaseforEnglish. Commun.ACM
38, 11 (1995), 39–41.
[13]MartinMonperrus,MichaelEichberg,ElifTekes,andMiraMezini.2012. What
should developers be aware of? An empirical study on the directives of API
documentation. Empirical Software Engineering 17, 6 (2012), 703–737.
[14]Laura Moreno, Andrian Marcus, Lori L. Pollock, and K. Vijay-Shanker. 2013.
JSummarizer:AnautomaticgeneratorofnaturallanguagesummariesforJava
classes.In IEEE21stInternationalConferenceonProgramComprehension,ICPC
2013, San Francisco, CA, USA, 20-21 May, 2013. 230–232.
[15] Rahul Pandita, Xusheng Xiao, Hao Zhong, Tao Xie, Stephen Oney, and Amit M.
Paradkar. 2012. Inferring method specifications from natural language API
descriptions. In 34th International Conference on Software Engineering, ICSE 2012,
June 2-9, 2012, Zurich, Switzerland. 815–825.[16]Xiang Ren, Yuanhua Lv, Kuansan Wang, and Jiawei Han. 2017. ComparativeDocument Analysis for Large Text Corpora. In Proceedings of the Tenth ACM
InternationalConferenceonWebSearchandDataMining,WSDM2017,Cambridge,
United Kingdom, February 6-10, 2017, Maarten de Rijke, Milad Shokouhi, Andrew
Tomkins, and Min Zhang (Eds.). ACM, 325–334.
[17]Lin Shi, Hao Zhong, Tao Xie, and Mingshu Li. 2011. An Empirical Study on Evo-
lutionofAPIDocumentation.In FundamentalApproachestoSoftwareEngineering
- 14th International Conference, FASE 2011, Held as Part of the Joint European Con-
ferencesonTheoryandPracticeofSoftware,ETAPS2011,Saarbrücken,Germany,
March 26-April 3, 2011. Proceedings. 416–431.
[18]RavindraSingh andNaurangSinghMangat. 2013. Elementsof surveysampling.
Vol. 15. Springer Science & Business Media.
[19]Giriprasad Sridhara, Emily Hill, Divya Muppaneni, Lori L. Pollock, and K. Vijay-
Shanker.2010. TowardsautomaticallygeneratingsummarycommentsforJava
methods. In ASE 2010, 25th IEEE/ACM International Conference on Automated
Software Engineering, Antwerp, Belgium, September 20-24, 2010, Charles Pecheur,
Jamie Andrews, and Elisabetta Di Nitto (Eds.). ACM, 43–52.
[20]StackOverflow. 2019. Stack Overflow data dump version from March 3, 2019.
https://archive.org/download/stackexchange/.
[21]SiddharthSubramanian,LauraInozemtseva,andReidHolmes.2014. LiveAPI
documentation.In 36thInternationalConferenceonSoftwareEngineering,ICSE
’14, Hyderabad, India - May 31 - June 07, 2014. 643–652.
[22]Jiamou Sun, Zhenchang Xing, Rui Chu, Heilai Bai, Jinshui Wang, and Xin Peng.
2019.Know-HowinProgrammingTasks:FromTextualTutorialstoTask-OrientedKnowledgeGraph.In 2019IEEEInternationalConferenceonSoftwareMaintenance
andEvolution,ICSME2019,Cleveland,OH,USA,September29-October4,2019 .
IEEE, 257–268.
[23]Maksim Tkachenko and Hady W. Lauw. 2019. CompareLDA: A Topic Model for
Document Comparison. In The Thirty-Third AAAI Conference on Artificial Intelli-
gence, AAAI 2019, The Thirty-First Innovative Applications of Artificial Intelligence
Conference,IAAI2019,TheNinthAAAISymposiumonEducationalAdvancesin
Artificial Intelligence, EAAI 2019, Honolulu, Hawaii, USA, January 27 - February 1,
2019.7112–7119.
[24]ChristophTreudeandMartinP.Robillard.2016. AugmentingAPIdocumenta-
tionwithinsightsfromstackoverflow.In Proceedingsofthe38thInternational
Conference on Software Engineering, ICSE 2016, Austin, TX, USA, May 14-22, 2016.
392–403.
[25]Denny Vrandecic. 2013. The Rise of Wikidata. IEEE Intelligent Systems 28, 4
(2013), 90–95.
[26]ChongWang,XinPeng,MingweiLiu,ZhenchangXing,XuefangBai,BingXie,
andTuoWang.2019. A Learning-BasedApproachfor AutomaticConstruction
of Domain Glossary from Source Code and Documentation. In Proceedings of the
201927thACMJointMeetingonEuropeanSoftwareEngineeringConferenceand
Symposium on the Foundations of Software Engineering. ACM, 97–108.
[27]BernardLWelch.1947. ThegeneralizationofStudent’sproblemwhenseveral
different population variances are involved. Biometrika 34, 1/2 (1947), 28–35.
[28] wikidata. 2019. String. https://www.wikidata.org/wiki/Q37484380.
[29] wikidata. 2019. string. https://www.wikidata.org/wiki/Q326426.
[30] wikidata. 2019. string. https://www.wikidata.org/wiki/Q1376436.
[31]Hao Zhong, Lu Zhang, Tao Xie, and Hong Mei. 2011. Inferring specifications for
resources from natural language API documentation. Autom. Softw. Eng. 18, 3-4
(2011), 227–261.
[32]YuZhou,RuihangGu,TaolueChen,ZhiqiuHuang,SebastianoPanichella,and
HaraldC.Gall.2017. AnalyzingAPIsdocumentationandcodetodetectdirectivedefects.In Proceedingsofthe39thInternationalConferenceonSoftwareEngineering,
ICSE 2017, Buenos Aires, Argentina, May 20-28, 2017. 27–37.
845