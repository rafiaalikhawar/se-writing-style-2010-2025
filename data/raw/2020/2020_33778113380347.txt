Multiple-Entry Testing of Android Applications by Constructing
Activity Launching Contexts
Jiwei Yan
Tech. Center of Softw. Eng.
Institute of Software, CAS, China
Univ. of Chinese Academy of Sciences
Beijing, China
yanjw@ios.ac.cnHao Liu
Dept. of Informatics
Beijing University of Tech., China
Beijing, ChinaLinjie Pan
State Key Lab. of Computer Science
Institute of Software, CAS, China
Univ. of Chinese Academy of Sciences
Beijing, China
Jun Yan∗
State Key Lab. of Computer Science
Institute of Software, CAS, China
Univ. of Chinese Academy of Sciences
Beijing, ChinaJian Zhang∗
State Key Lab. of Computer Science
Institute of Software, CAS, China
Univ. of Chinese Academy of Sciences
Beijing, ChinaBin Liang
School of Information
Renmin University of China
Beijing, China
ABSTRACT
Existing GUI testing approaches of Android apps usually test apps
from a single entry. In this way, the marginal activities far away
from the default entry are difficult to be covered. The marginal
activities may fail to be launched due to requiring a great number
ofactivitytransitionsorinvolvingcomplexuseroperations,leading
to uneven coverage on activity components. Besides, since the test
spaceofGUIprogramsisinfinite,itisdifficulttotestactivitiesundercompletelaunchingcontextsusingsingle-entrytestingapproaches.
In this paper, we address these issues by constructing activity
launchingcontextsandproposingamultiple-entrytestingframe-
work. We perform an inter-procedural, flow-, context- and path-
sensitive analysis to build activity launching models and generate
completelaunchingcontexts.Byactivityexposingandstaticanaly-sis,wecouldlaunchactivitiesdirectlyundervariouscontextswith-out performing long event sequence on GUI. Besides, to achieve anin-depthexploration,wedesignanadaptiveexplorationframework
which supports the multiple-entry exploration and dynamically
assigns weights to entries in each turn.
Our approach is implemented in a tool called Fax, with an activ-
itylaunchingstrategyFax laandanexplorationstrategyFax ex.The
experimentson20real-worldappsshowthatFax lacancover96.4%
and successfully launch 60.6% activities, based on which Fax exfur-
ther achieves a relatively 19.7% improvement on method coverage
compared with the most popular tool Monkey. Our tool also be-haves well in revealing hidden bugs. Fax can trigger over sevenhundred unique crashes, including 180 Errorsand 539Warnings,
∗Corresponding Authors.
Email: yanjun@ios.ac.cn, zj@ios.ac.cn
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380347which is significantly higher than those of other tools. Among the
46 bugs reported to developers on Github, 33 have been fixed up
to now.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging;
KEYWORDS
Android app, Static Analysis, ICC, Multiple-Entry Testing
ACM Reference Format:
Jiwei Yan, Hao Liu, Linjie Pan, Jun Yan, Jian Zhang, and Bin Liang. 2020.
Multiple-EntryTestingofAndroidApplicationsbyConstructingActivity
Launching Contexts. In 42nd International Conference on Software Engineer-
ing(ICSE’20),May23–29,2020,Seoul,RepublicofKorea. ACM,NewYork,
NY, USA, 12 pages. https://doi.org/10.1145/3377811.3380347
1 INTRODUCTION
Mobile applications, especially Android apps, have witnessed an
explosive growth in recent years. Meanwhile, the defects in An-droidapplicationsarousedtheattentionofresearchers[
54].Due
to the event-based characteristic of Android apps, the test casesare in the form of GUI events. For GUI testing, a great number
ofautomaticexplorationapproacheshavebeenproposed,includ-
ing random [ 24,29,60], model-based [ 28,57,58] and systematic
ones [4,22], aiming to cover more components or transitions.
Despite using different exploration strategies, these approachesusually start their exploration from the default entry point, i.e.,
MainActivity , of the target app. In this paper, we refer them as
Single-Entry Testing (SET) ones.
In SET approaches, some obstacles, e.g., complex gesture or
logical operations, make some activities unreachable. Besides, each
activityhasanimpliedexplorationdistancefromthesingleentry
point,whichisunequalandleadstounevencoverageonactivity
components. One recent work makes use of the state-of-the-arttool Monkey [
29] to test a widely used app WeChat, and has a
similar observation: Monkey allocates a lopsided distribution of
exploration time on each activity [ 60]. Furthermore, because of the
4572020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
infinitetestspaceofGUIprograms,itisdifficulttolaunchactivities
under complete contexts using SET. To address these issues and
achieve in-depth GUI testing on mobile apps, we take each activity
as a separate entry and propose the Multiple-Entry Testing ( MET)
approach.
Fig. 1 shows the exploration paths in SET and MET. Under SET,
theactivity Accountcannotbelaunchedifitsdomainnode,e.g.,
Detail,failedtobevisited.Inaddition, Accounthasdifferentbe-
haviors depending on its Activity Launching Contexts ( ALCs),
whichisgeneratedbypreviouseventoperationsorreceivedfrom
outside (e.g., another app). Using SET, it is difficult to cover all
ALCs and measure the test adequacy involving activity launching.
IfweadoptMET, Accountcanobtainafairlaunchingchanceasthe
default entry and can be tested completely under multiple ALCs.
Display
Detail Search AccountMain SettingMultiple ContextsMain
Display Setting
Detail Search
Accountcomplex gesture/ 
logical operation
Figure 1: Single- and Multiple-Entry Testing
Usually, the user can successfully launch the default entry of
an app by simply clicking the icon on the launcher of the phone,
or sending an external command with the name of the target ac-
tivity.However,agreatnumberofactivitiesrequirespecificdata
itemsduringlaunchinganddecidetheexecutionpathsaccording
to the type and value of these data items. That is to say, without
proper ALCs,the METprocess maybe incomplete andineffective.
In Android, several context-related information may influence the
launching result, includingthe inter-component communication
(ICC)message,deviceconfiguration,activitystack,andglobaldata,
among which the ICC message is the most important one. To gen-
erate ICC messages properly, we should precisely model the name,
type,datastructureaswellasthevalueconstraintsofeachattribute.
Challenges. Thefirstchallengeliesinthemodelingofthecom-
plex attributes of ICC messages. Existing works [ 26,45,56,59]
extract the attribute declarations by XML file analysis. However,according to our research, the attribute declaration of activity isusually inconsistent with its usage. Therefore, it is necessary tomodel the ICC information by extracting the constraints of at-
tributeusageondifferentexecutionpaths.AccordingtotheAPIs
providedbyAndroidReference[ 20],Activitycanreceivetwotypes
of data items: Basic Attribute andExtra Parameter, in which the
Extra Parameter can be further separated into Prime,Objectand
Bundle Extra Parameter according to the value it contains. For a
basic attribute, we concentrate on the candidate values that can
influencethebranches;foraprimaryextraparameter,weshould
extract both the extra type and its key for input generation; an
objectextraparameterrequiresanobjectdataitem,whichmeansa
corresponding object must be instantiated first as test data; and for
abundleextraparameter,whichisanestablekey-valuemap,we
shouldreconstructitsoriginaldatastructure.TogenerateproperALCs as much as possible, all of these characteristics should be
considered.
Thesecondchallengeistheweightassignmentamongentries
in MET. Different from SET approaches, which always start testing
fromthedefaultentry,theMETrequiresustomakedecisionson
the exploration weight of each entry. On one hand, some activities
failtobelaunchedbytheconstructedALCsduetounexpectedapp
crashes. Thus the exploration should make more efforts to cover
theseactivitiesfortesting.Ontheotherhand,theactivitiesthatcan
lead to more activity transitions should have higher exploration
weight.Forexample,thedefaultentryisusuallymoreimportant
thantheleafactivitieswhichneverjumpout.ThestaticActivity
TransitionGraph(ATG)canbebuiltforhelp,however,itmaybe
imprecise. During testing, the activity launching result changes
dynamically and new transitions can be detected. Thus, the weight
assignment should be adaptive during the MET process.
OurApproach. Inthispaper,weproposetheMETapproachto
replacethetraditionalSETapproaches.WefirstanalyzetheICCre-ceivingprocessandperformaninter-procedural,flow-,context-andpath-sensitive analysis to construct the Activity Launching Models
(ALM),whichdescribestheconstraintsofrequiredattributesand
parametersineachactivity.EachALCintheALMcorrespondstoa
unique intent-resolving related execution path. Then we calculate
theweightsofALCsaccordingtoboththeactivitylaunchingstatusandthereachabilityinformationbetweenactivities.Theexploration
isdesignedformultiple-roundtesting,whichfirstlauncheseach
ALCandassignstheinitialweight.Thenitincreasesthenumber
oftotaleventsineachroundandreassignsthetestingweightdy-
namically. Finally, we can achieve an in-depth exploration by ALC
generation and adaptive weight assignment.
Contributions. The contributions of this work are three-fold:
•Context Construction. We perform static analysis to build
ALMs for activities and generate proper ALCs for them.
•ExplorationFramework. Wedesignageneraladaptiveframe-
work for multiple-entry testing, which supports two strategies:
the activity launching strategy Fax laand the exploration strat-
egy Faxex.
•Tool Implementation. We implement our approach in the
toolFax[13], which is publicly available on GitHub. The ex-
perimental results indicate that Fax has a strong bug detection
ability and reaches high code coverage.
2 BACKGROUND
Thissectionprovidesaintroductionofthefundamentalbuilding
blocks in Android apps.
2.1 Android Activity
Activity,whichprovidesagraphicaluserinterfacetousers,isthe
most frequently used component inthe Android system. The user
performsUIoperationsonactivitiesandtriggersactivitytransitionstocompletetheirdailytasks.Ifausertriggersanactivitytransition,thecalleractivitywillsendanICCmessageaccordingtothe
Intent
mechanism [ 20]. Then the current activity will be stopped and
thenewonewillbelaunched,whichismanagedbytheAndroidsystem. Each ICC message contains a specific invocation targetaswellasaseriesofdataitems.Accordingtowhetherthetarget
458activitiescanbelaunchedbyexternalapps,theycanbeseparated
into internalactivity ( IA) andexported activity ( EA). TheIAs can
only be visited through a set of user operations that start from the
EAs,whiletheEAscanbetakenashiddenentriesoftheappand
belauncheddirectly.Tovisitoneactivitydirectly,wecanmodifyit
as an EA to support one step invocation by declaring the attribute
android:exported=true or setting intent-filters in the manifest
file.Afterexported,eveninternalactivitiescanbelauncheddirectly
without performing complex user event sequences.
2.2 Activity Launching Context
According to the activity launching process, four types of sub-
context may have influences on the launching result.
•ICC Message. An ICC message is an Intentobject carried
with a set of data items, which depends on the caller activity.
•Device Configuration. The device configuration denotes the
user-configurable status of the mobile phone, e.g, wifi, GPS
status, which depends on the setting of the phone.
•Activity Stack. The activity stack stores the history activities
visited before reaching the current one, which depends on the
exploration trace.
•GlobalData. Theglobaldatacanbemodifiedanywhere,which
depends on the previous user operations.
To achieve effective testing of Android apps, we try to create
ALCs that can trigger as many program paths as possible using
these sub-contexts. For the ICC message, we model their usage
withthehelpofstaticanalysistoachievebackwardALCgenera-
tionandautomatictesting.Fordeviceconfiguration,wescanthe
corresponding APIs and give reports about the used configuration
itemsofanapp.Forstackcontext,anactivitycanbetestedunder
an empty stack with Fax laand under non-empty stack with Fax ex.
The global data is difficult to be controlled, e.g., the number of files
onthe sdcard.However,if theglobal datacan bemodifiedduring
exploration,itsvaluecanhelptotriggermoreprogrampathsinthe
multiple-round testing. For example, if the global setting related
activities are explored in multiple rounds, the operations on it will
create different global data contexts for other activities in that app.
2.3 ICC Message and Intent Receiving
ICC message is one of the most important sub-context, which has
a complex composition and is necessary for the activity launching.
Table 2 lists the required attributes in ICC invocation and gives
theircharacteristics,inwhichcolumns LocdandLocudenotethe
declarationandtheusagelocationsoftheseattributes,respectively.
In this table, we classify ICC attributes into two types: Basic At-
tributeandExtra Parameter. As we can see, the Basic Attribute,
including action,category ,dataandtype, can be declared both
in the intent-filters in the manifest file as well as be used in the
Javafiles. However, there are mismatches between the attribute
declarationanditsusage.Forexample,theactivity MessageList
inpopularapp k9Mail[42],whichhasover4000starsonGithub,
requeststhreeactionsinJavacode,inwhichonlyoneofthemis
declared in the manifest . This activity also declares two values
intheintent-filterinthe manifest file,butoneisinvalidandnot
used in the Java code.Wefurtherperform theconsistencydetection betweenthedec-
laration and usage of all the 1200 apps collected from F-Droid [ 12].
TheresultsarelistedinTable1,includingthestatisticresultsofthe
numberofdeclaredandusedattributevalues,aswellashowmanyofthemareconsistent.Notethatthevalueofthebasicattribute data
isaregularexpression,sowedonotgivetheconsistencyofdata
attribute. As we can see, there are huge inconsistencies. The key
reason is that the intent-filters are designed for implicit invocation.
Developers can declare multiple attribute values in intent-filters to
characterizeoneactivitybutdonotusetheminthe Javacode.The
attributethey actuallyusedmay notberelated toimplicitinvoca-
tionanddonotbedeclared.Therefore,onlycollectingthedeclared
valuesofICC-relatedattributesinthe manifest fileisnotsufficient
for activity modeling.
Table 1: Consistency of Basic Attributes of 1200 Apps
Declaration Usage Consistent
Action 2670 777 445
Category 2430 0 0
Data 2772 361 –
Type 727 81 36
BesidesBasic Attribute, ICC messages also accept Extra Parame-
ters. Each extra parameteris a key-value pair /angbracketleftk,v/angbracketright, which can be
separateditintothreesub-types: PrimaryExtraParameter, Object
Extra Parameter andBundle Extra Parameter, according to the type
of the value v. Different from the basic attribute, the extra parame-
tersarenotdeclaredanywhere,butonlyusedincode.Thecaller
activitycanattachan intentwithdifferenttypesofextradataitems
via a series of overloaded APIs. Android system provides a number
of APIs for thereceiver activity to get thetransferred data accord-
ingtothegivenkey.AccordingtoAndroidAPIdocument[ 8,20],
the valueof extra parametercan be anytype of theJava primitive
datatype,e.g., Int,Boolean,orothertypeslike String,Arrayand
ArrayList , etc. For example, the API getIntExra(String city)
isusedtogetanintegervalueaccordingtothekey city.Thevalue
ofanextraparametercanalsobeobjecttype( Serializable and
Parcelable ) or bundle type ( Bundle), in which the object type
denotesanobjectimplementingaspecificinterface,andabundle
typeisasetofkey-valuepairsthatstoresagroupofsub-itemsin
types of primary, object or nested bundle extra parameter.
Table 2: Composition of ICC Message
Type SubType LocdLocu Type
BasicAction XmlJava String
Category XmlJava Set/angbracketleftString/angbracketright
Data XmlJava String
Type XmlJava String
ExtraPrimary –Java/angbracketleftk,v/angbracketrightpair,kis inStringtype,
vis a sub-item in type of Java
primitive data types, String,
Array,ArrayList etc. [20]
Object –Java/angbracketleftk,v/angbracketrightpair,kis inStringtype,
vis aSerializable/Parcelable
object or a set of objects. [20]
Bundle –Javaset of/angbracketleftk,v/angbracketright, each of which can
be a primary extra, an object
extra or a nest bundle extra. [8]
4593 MOTIVATING EXAMPLE
Inordertoshowtheprocess ofhowtheICCmessagesarereceived
by activities as well as how the ICC attributes/parameters are used
in the code, we take ExampleActivity as our motivating example,
which is shown in Fig. 2.
Whenanactivityislaunched,theAndroidsystemwillcallitslife-
cyclemethods.Inthisexample,westartfromitslifecyclemethod
onCreate() .First,theactivitygetsan Intentobjectthroughthe
APIgetIntent() andcreatesan Intentvariableintenttostore
the information of the received ICC message. Then, the value of
each attribute carried in the ICC message will be obtained through
several APIs, e.g., using API getAction() to get the value of basic
attributeaction,usingAPI getIntExtra(key) togetthevalueof
primary extra parameter with a specific key, etc. After that, the
attribute value receiving variables will be used for branch picking,
log recording or other purposes. When the received value of an
attribute is used in a branch picking condition through compar-ison, there should be candidate values of this attribute that can
influencetheprogram’sexecutionpath.Forexample,thestatement
if(mAction.equals("ACTION_VIEW")) contains an attribute re-
ceiving variable mAction, a comparing operation equalsand a
candidate value "ACTION_VIEW" of the basic attribute action.
However, not all of the candidate values can be obtained di-
rectly.Ononehand,theattributereceivingvariablemaytransfer
its value to other variables and form new condition constraints.
Like in line 6, the attribute receiving variable action1 is not used
inbranchpickingconditions.Asshowninthefollowinglines,its
value is transferred to variables action2 andaction3. The new
constraintsare getAction().substring(1,4).equals ("act")
andgetAction().charAt(2)==‘C’ .Ontheotherhand,theString-
type candidate values may not be obtained directly. It could be
manipulated by a set of String-related APIs, come from the formal
1public class ExampleActivity extends Activity {
2@Override
3protected void onCreate(Bundle savedInstanceState) {
4// ICC Message
5Intent intent = getIntent(); //get intent
6String action1 = intent.getAction(); //get action
7String action2 = action1.substring(1,4);
8charaction3 = action1.charAt(2);
9if(action2.equals("act")){
10 if(action3 == 'C'){
11 doSomething(); //unsat path
12 }
13 }else if(action1.startsWith(getPrefix("startWith", 3))){
14 Bundle b1 = intent.getBundleExtra("b1");
15 String s1 = intent.getStringExtra("s1");
16 Float f3 = b1.getBundle("b2").getFloat("f3");
17 if(f3!=null){
18 doSomething();
19 }
20 }
21}
22private String getPrefix(String str, inti) {
23 String newStr = str.substring(0, i);
24 returnnewStr; //String operation
25}
26}
Figure 2: Motivating Exampleparameter of the current method or be the return value of another
method.Inline13,forinstance,thecandidatevalue"sta"isdecidedbythereturnvalueofmethod
getPrefix() ,i.e.,itdependsonboth
the value of the formal parameters of method getPrefix() and
the semantic of API getsubstring() . In addition to string anal-
ysis, the received ICC message may have specific structures. As
shown in line 14-16, each extra parameter may belong to different
datatypes,andmayhavespecificstructure( b1-bundle ,s1-string ,
b1.b2-bundle ,b1.b2.f3-float ),whichshouldbepreciselyrecon-
structedinordertogeneratedummycalleractivitieswithcorrect
ICC message as test cases.
4 FRAMEWORK OVERVIEW
InFig.3,wegivetheframeworkoverviewofFax,whichtakesan
apk file as input and generates a group of test cases. After test
execution,itoutputsasetofcorrespondingreports.First,weinstru-
menttheoriginalapktoexposeIAintoEA,whichonlymodifies
themanifest file and does not bring extra overhead in dynamic
testing.Then,weperformstaticanalysistogettheActivityLaunch-
ing Model (ALM) that describes the attribute usage information as
wellastheActivityTransitionGraph(ATG)thatshowstherelation-
shipofactivities.WeusetheALMtogenerateALCsofactivities
andperformtestcaseexecutiononAndroiddevices.Becausethe
generated test scripts only launch activities under various contexts
without GUI exploration, we call this strategy as Faxla. Besides,
we have another strategy Faxex, which first filters ALCs using the
launching results of Faxla. Then, it takes the activity relationships
in ATG and the set of activities failing to be launched, to guide the
weight assignment among ALCs. Fax supports multiple-round test-
ing. During the exploration, it collects the execution traces for the
weightcalculationinthenextround.Besides,theusercanadoptany
explorationstrategyaccordingtotheirrequirement.Therandom
strategy is adopted in the current version of our implementation.
5 CONTEXT CONSTRUCTION FOR TESTING
This section introduces the ALC construction process, which is
based on the inter-procedural, flow-, context- and path-sensitive
static analysis techniques.
5.1 String Constraint Extraction
Forbasicattributes,weaimtofindtheconstraintsoftheircandi-
dates precisely, which are combined by the manipulation of thedata receiving variable (
ReceiveVar ), the comparison operation
(CompareOp )andthepre-definedcandidatevalues( CandidateVal ).
And for the extra parameters ( ExtraPara ), we try to get the cor-
rect key and type of value. For both kinds, our method is mainly
Table 3: Information of String-related APIs
SetZ3Ret Value Used In API
S1TString
/CharReceiveVar
CompareVar
ExtraParaappend, concat,
toString, substring, charAt
S2FStringCandidateVal
ExtraParatrim, equalsIgnoreCases,
toUpperCase, toLowerCase
S3TBoolean CompareOp==, !=, isEmpty, contains,
equals, startsWith, endsWith
460Activity Exposing
Activity Launching Model
Activity Transition GraphTest 
ScriptsExecutionExecution 
Traces
Exploration 
Weight CalculationStatic 
AnalysisDynamic UpdateFaxla
FaxexReports
Exploration 
Sequence Generation
Exploration StrategyLaunch 
Command 
GenerationDummy 
Apps
Figure 3: Overview of the Multiple-Entry Testing framework, which is implemented in the tool Fax
based on reaching definition technique [ 30], which is a commonly
used data-flow analysis. It statically determines which definitions
mayreachagivenpointinthecode,andcanhelpustoconstruct
use-define chains [30] to capture data propagation.
Boththecandidatevalueofthebasicattributeandthekeyofthe
extraparameterarerelatedto String.InJava8,therearetotally67
StringrelatedAPIs[ 47],including value-relatedAPIs thatreturna
new string or char, compare-related APIs that return a boolean flag,
andinfo-related APIs, such as length() , etc. In our work, we only
concentrate on the first two types. In Table 3, we classify string-
relatedAPIsintothreeclassesaccordingtotheirreturntypeand
whether they are supported by string constraint solver Z3[11,61].
In the fourth column, we show where these APIs are used. Note
thatoperator"+"for Stringwillbetransferredtotheinvocation
ofappend() in the intermediate representation of Java.
Algorithm 1 demonstrates the process of intent receiving analy-
sis. It shows how the constraint set is constructed when finding an
intent-receiving statement. It accepts a method mas input, outputs
asetofextrakey-valuepairsandconstraintsofattributes.Inline2,
wecalculateuse-definechains udcofeachstatementin m,which
canbeobtainedbysomematureanalysisframework(e.g.,Soot[ 46]).
Then we locate the input data obtaining instructions (IDOIs) accord-
ing to Android APIs, including getAction() ,getCategories() ,
getData() ,getDataString() andgetType() [20]. For each in-
struction insin IDOIs, function дet_attr_varsreturns a set of vari-
ables which store the received input data. Note that the value of
anattributereceivingvariablecanbetransferredtoothervariables
through severalvalue-related APIs, wetrack thetainted variables
throughudcand add them into the attribute receiving variable set
vars.Inline6,wegetagroupofstatements Scowhichusethevari-
ablevarfor comparison in a condition (see S3 in Table 3). For each
insco,theinputdatawillbecomparedwithanotherstring,whichis
acandidatestring.Inline9,wegetthevariable canVarwhichstores
the candidate string and try to get its value. If canVaris defined as
aconstantstring,wecanobtainthestringdirectlyinline11.Other-
wise,werecursivelyanalyzeitsvaluewhichmaybemodifiedbythe
stringoperation(seeS1andS2inTable3).Ifthecandidatestring
is obtained from the return value of other methods or from the
formal parameter sent by the caller of the current method, we lookinto the invoked methods with current invoking context, i.e., pa-
rametersofmethodinvocation,orquerythesimulatedmethodcall
stack to build the correct candidate. In line 15, we use the collectedinformationtoupdatetheset
constraints .Theextraparametersare
extracted in line 19 by function extract_extras() , which will be
introduced in the following subsection.
Algorithm 1 intent_receiving_analysis
Input:methodm
Output: attribute constraint set constraints, extra set extras
1:constraints =∅,extras=∅
2:udc= ge_use_def_chains(m )
3:foreachinsin all IDOIs of mdo
4:vars= get_attr_vars(ins, udc)
5:forvarinvarsdo
6:Sco= get_compare_ins(var, udc)
7:forinscoinScodo
8: co= get_compare_operation( insco)
9: canVar= get_candidate_var( insco)
10: ifcanVarcan be obtained directly then
11: canValue = get_constant_value(canVar )
12: else
13: canValue = get_value_of_var(canVar, udc)
14: end if
15: constraints =constraints ∪{/angbracketleftins,var,co,canValue/angbracketright}
16:end for
17:end for
18:end for
19:extras= extract_extras(m, udc)
20:returnconstraints, extras
In the example in section 3, we can get variables vars={(l5-
intent), (l6-action), ( l7-action.substring(1,4)), ( l8-action.charAt(2)) },
and constraints constraints ={(l9, action.substring(1,4), equals,
“act”),(l10,action.charAt(2),==,‘C’),( l13,action,startsWith,“sta”) }.
5.2 Extra Parameter Analysis
TheextrasinAlgorithm1containsasetofextraparameters,each
of which is a key-value pair. An activity makes use of several spe-
cific system APIs of the Intentclass to retrieve the data with a
461specific type by a user-defined key, e.g.,getStringExtra("s1") .
Our goal is to locate the invocations of these APIs and obtain keys
andtypesofdataitemsforeachactivity.Tolocatethe extraparame-
terobtaininginstructions (EPOIs),wecollectanAPIlist,including29
APIsofIntentclass,24APIsof Bundleand4APIsof Parcelable ,
that can be used to get extra parameters with different types, ac-
cordingtotheAPIReference[ 8,20].Withthislist,itiseasytofind
outtheEPOIsanddeterminethetypesofextraparameters.Note
that,these extraparametersare usuallyusedfor providingvalues,
thus their data are arbitrary. After extracting their type and key,
we generate a set of data according to their types.
Algorithm2givestheprocessofhowtoextractextraparameters.
Forexample,in Javafile,wemayhaveastatement getStringExtra
("s1").Intheintermediaterepresentationformat Jimple/Shimple
transformedbySoot,thekey"s1"willbestoredinanadditionalvari-
able, e.g., we may have x = "s1" ,getStringExtra(x) . In line 3,
the function get_used_var() will return the variable that stores the
keyvalue,i.e,getvariable x.Togetthekeyofextraparameters,we
theninvokethefunction get_value_of_var() inline4togetthevalue
ofthegivenvariable,i.e,getvalue"s1".Function get_type() inline5
returns the type of an extra data item, which can be a basic Java
type (like Stringtype forgetStringExtra() ) or an encapsulated
Android-specific type (like BundleforgetBundleExtra() ). The
algorithm of function get_type() is shown in Algorithm 3. For basic
types, they can be extracted from the name of APIs. The special
situation is the getBundleExtra() -like instructions, which obtain
Algorithm 2 extract_extras
Input:methodm, use define chain udc
Output: extra setextras
1:extras=∅
2:foreachinsin all EPOIs of mdo
3:var= get_used_var(ins )
4:key= get_value_of_var(var, udc)
5:type= get_type(ins, var,udc)
6:extras.add( /angbracketleftkey,type/angbracketright)
7:end for
8:returnextras
Algorithm 3 get_type
Input:EPOIins, variable var, chain udc
Output: typeextraType
1:ifinsis in Basic Type then
2:extraType = get_basic_type(ins )
3:else ifinsis in Bundle Type then
4:ps= get_propagation_set(var, udc)
5:foreachbInsinpsdo
6:biVar= get_used_var(bIns )
7:biKey= get_value_of_var(biVar, udc)
8:biType= get_type(bIns, biVar,udc)
9:extraType.add( /angbracketleftbiKey,biType/angbracketright)
10:end for
11:end if
12:returnextraTypeadataitemwith Bundletypethatmayconsistofmultipleextrapa-
rameters,i.e.,keyandtypepairs.Thusitneedstorecursetoextract
thesenestedkeyandtypepairs.Forthiscase,themethod get_type()
firstcalculatesthesetofinstructions psthatvarispropagatedto.
With this set, we recursively get the key-type pairs attached to the
Bundletype and return a bundle object as the type. At last, the
tuple/angbracketleftkey,type/angbracketrightwill be collected and returned.
5.3 Activity Launching Model Construction
TheActivity Launching Model (ALM) can be formally defined
as a 5-tuple M=/angbracketleftentry,Nb,Ne,E,R/angbracketright, where
•entryis the root node of the ALM, which represents the execu-
tion entry of the activity.
•Nbisasetofbasicattributerelatednodes.Eachnode n∈Nb
is a triple (id,attr,constraint ), whereidis the identifier of
the node, attris an ICC-related basic attribute, and constraint
describes the constraints about attr.
•Neisasetofextraparameterrelatednodes.Eachnode n∈Neis
atuple(id,para),whereidistheidentifierofthenode,set para
containsagroupofextraparametersinthe formof (key,type).
•Eis a set of edges that link nodes on the same execution paths.
•Ris a tuple (path,res), wherepathcontains a list of idsof
nodes,n.id∈path,n∈Nb∪Ne, andresgives the solving
results of the constraints. After generating test data for eachattribute/parameter for one feasible path in
R, we can get an
Activity Launching Context (ALC) as a test case.
Fig. 4 uses a tree to display the ALM of the motivating example,
inwhicheachpathcorrespondstoalistofattributesorparametersinanICCmessageandtheleafnodesdisplaytheconstraintsolvingresults.Inthiscase,wegetthreefeasiblepaths.Onepathisdropped
out because the path condition is unsatisfiable.
Entry
action.substrin
g(1,4)= “act ”action.substring
(1,4)!= “act ”
action.
charAt(2)= ‘c’action.
charAt(8))!= ‘c’action.startsWi
th("sta")!action.startsW
ith("sta")
Extras: S1, b1,
b1.b2, b1.b2.l2p1: unsat p2: action:"sact"
p3: action:"stau"
Extras: S1, b1,
b1.b2, b1.b2.l2p4: action:"j"
Figure 4: ALM of the Motivating Example
In an ALM, each path can be transformed into a set of ALCs by
giving assignments of attributes/parameters in the path. For the
basic attributes, we generate assignments that satisfy the collected
constraintsinsection5.1.Consideringthateachreceivedvaluefrom
ICC should be checked by null-checkers before used, we mutate
the default paths by adding nullvalue as candidate value for each
attribute/parameter without using an explicit null-checker. For
theextraparameter,wedesignasetofabnormalvaluesforextra
parameters, e.g., nullvalue, the boundaryof corresponding extra
type, extremely long string, etc.
4625.4 Test Script Generation
TheALCswillbetransformedintoexecutabletestcases.Theadb-
formcommandiswidelyadoptedowingtoitssimplicityandeffi-
ciency. Unfortunately, it has several limitations. First, the adb-form
invocationdoesnotsupportpermissionrequirement,i.e.,thecalleeactivityrestrictsitscallersbyrequiringspecificpermission.Besides,thetypeofparametersthatanadbcommandcancarryislimited.Ifatestcasecontainsany
Javaobject,suchas BundleorArrayList
object, it can not be sent through adb.
Todealwiththisproblem,wedesignadummyapptotransitthe
launching command. First, Fax detects the required permissions of
the app under test. Then, an empty Android project will be created
with the required permissions. For each ALC, Fax creates an ex-
porteddummyactivitywhocanbedirectlylaunchedusingadbcom-
mand. For example, "adb shell am start -n com.fax.test/.dummy_id ".
In theonCreate() method of each dummy activity, we generate
launchingrelatedcodethatsendsanICCmessagewithcorrespond-
ing ALC. For each parameter in an ICC message, we create objects
accordingtoitstype.Forbundletype,wereconstructtheproperdata structure. Clicking on the UI of the activity in the dummy
app can also launch the activity to be tested. So that we can easily
perform the test by starting the activity-form test cases in dummy
apps instead of the activities in the app under test.
6 MULTIPLE-ENTRY EXPLORATION
Besides launching activities with proper ALCs, we also want to
detect hidden bugs that can be triggered during the in-depth explo-ration through multiple entries. Therefore, we need to measure the
importanceofeachentryandassignweightsamongthemduring
testing.However,partofactivitiescannotbesuccessfullylaunched
as exploration entries and the contribution of activities vary in
the whole testing approach, e.g., a leaf activity which never jumps
out is likely to need fewer testing events. Furthermore, both the
launchingresultand thetransitioncontributionaredifficulttobe
precisely obtained by pure static analysis. In the strategy Fax ex,
we combine the static model and the dynamic execution results to
perform an adaptive exploration.
Algorithm4givestheprocessoftheadaptiveexploration,which
starts with a coarse-grained ATG and adjusts the weights of ALCs
dynamically. At first, the ATG information is constructed statically
and the execution information is empty. We use function LA(lc)
togettheactuallylaunchedactivitybyexecutingALC lc.Ineach
round, we obtain the subview of each ALC. For crash-triggering
ALCs,theirweightsarezero.Foracrash-irrelevantALC,werecord
the subview svlcas thesub-graph of thecurrent ATG, which con-
tains all the reachable activities starting from activity LA(lc). Set
SFlcis the set of activities that failed to be launched in svlc. For
each ALC in the launching context set LCs, its weight will be re-
calculated in multiple rounds. The weight of lcin theithround
exploration can be calculated by formula (1):
Weiдht(lc,i)=/summationdisplay.1θ
Dis(LA(lc),aj)+/summationdisplay.1
Nm(ak)+γ(1)
wherei>0,lc∈LCs,0<j≤|SFlc|,0<k≤|SVlc|.Thefunction
Dis(LA(lc),aj)evaluatesthedistancebetweenthelaunchingtarget
activityLA(lc)andeachelementin SFlc.TheALCthatcanreachAlgorithm 4 adaptive_exploration
Input:application app, activity launching context set lcs
1:i=1
2:execution_info =∅
3:atg1= getSATG(app )
4:whilenot timeout do
5:atgi= get_ATG(app, execution_info )
6:foreachlcinlcsdo
7:la= LA(lc)
8:svlc= subview of lainatgi
9:SFlc= activities in svlcthat are failed to be launched
10:weightlc= get_weight(la,s v lc,S Flc)
11:end for
12:foreachlcinlcsdo
13:calculate the priority and event number of lc
14:end for
15:perform testing in the ithround
16:update the activity launching results into execution_info
17:update the execution traces into execution_info
18:i=i+1
19:end while
more unvisited activities or reach unvisited activities with fewer
transitionswillhaveahigherweight.Weusefunction Nmtocount
thenumberofmethodscontainedintheactivitiesinthesubview
svlc, which indicates the subview size of each launching target
activity. The ALC whose subview reaches more methods will have
ahigherweight.Inthe ith(i>0)roundexploration,setSF lcand
subviewsv lcareupdatedbythedynamictransitioninformationin
theprevious (i−1)throunds.Weuseparameter θtobalancethe
distance to unvisited activities as well as the contribution of the
launching target. Parameter γis a basic constant weight, which is
designedfornon-leafactivitieswhosetransitionsarelostintheini-tialATG.ItguaranteestheweightsofallALCstobepositive.After
weight calculation, we use the weight ratio among all launching
contextsintheset LCstogettheexplorationprioritybyformula
(2), where 1 ≤m≤|LCs|.
Priority(lc,i)=Weiдht(lc,i)/summationtext.1Weiдht(lcm,i)(2)
Accordingtotheexplorationeventnumberineachturn,wecan
get the exploration event owned by each activity using formula (3).
We use function En(i)to denote the number of events in the ith
round. And in our tool, the number of total events will increase
with the refinement of exploration model in multiple rounds.
Event(lc,i)=Priority(lc,i)×En(i) (3)
For example, consider the example in Fig. 1. If we have three
lcs (see Fig. 5) that can successfully launch activities: Main,Detail
andSetting, and the other activities failed to be launched. Sup-
poseθ=6,γ=1,i=1 and each activity has one method, we
can calculate their exploration weight as: Weight(lc 1)=11+6+1=18,
Weight(lc 2)=15+4+1=20, Weight(lc 3)=6+2+1=9. Priority(lc 1) =18/47,
Priority(lc 2)=20/47,Priority(lc 3)=9/47.Ifwehave470exploration
eventsinthefirstround,wehaveEvent(lc 1)=180,Event(lc 2)=200,
Event(lc 3)=90, rather than the assignment Event(lc 1)=470 in SET.
463DisplayDetail
SearchAccountLc2, alc2 = Detail
Setting
SearchLc3, alc3 = SettingMain
Display Setting
Detail Search
AccountLc1, alc1=Main
Figure 5: Subviews from Different Entries
7 EVALUATION
explorerWeimplementourapproachintoolFax[ 13](FairAndroid
eXplorer).AsshowninFig.3,Faxcontainstwostrategies:theactiv-
ity launching strategy Fax laand the adaptive exploration strategy
Faxex. In the preprocessing part, we adopt the decompilation tool
ApkTool[6] and the instrumentation tool InsDal[23] for activity
exposing and coverage measurement. The static analysis part is
builtontopofthedata-flowframework Soot[46]andAndrolic[43]
toconstructALMandATG.WeuseAndroid ADB[1]toinstallapks
and make use of the build tool Ant[5] to build app-form test cases.
Wecollected20popularopen-sourceappsfromGithubtoeval-
uate the effectiveness of our tool. All of our analysis processes
areperformedonanIntelCorei7-3770CPU@3.40GHzmachine,
with16GBmemoryandWindows7operatingsystem,aswellas
a mobile phone (Samsung S7) in the version of Android 8.0. On
our benchmark, the static analysis and the test case generation
modules take 6540 seconds in total. The generated 20 dummy apps
contain 2185 launching commands. Each launching command isan exported activity that can be invoked directly by ADB. Our
evaluation aims to address the following four research questions:
•RQ1 (Context Construction): What is the effectiveness of
the activity launching context construction?
•RQ2 (Activity Launching): What is the effectiveness of the
activity launching ability of Fax?
•RQ3 (App Exploration): Can the event reassignment mecha-
nism of Fax help to improve code coverage?
•RQ4 (Crash Detection): Can Fax find more real bugs by sup-
porting multiple-entry testing?
7.1 Effectiveness of Context Construction
We designabenchmark IntentBench [19]to evaluatethe effective-
ness of the context construction. It contains 43 activities and in-
volvesvariousfeatures,e.g.,branch,loop,override,inter-procedure,
and intent-receiving characteristics. We show the self-checking
result in Table 4, in which the first two columns give the category
nameandthenumberofactivities(#A).Thefollowingcolumnsgive
the results of ICC attribute identification and ALC generation. For
attributeidentification,wecollectthenumberofattributevalues
used in each category (#Attr), the correctly extracted attributes by
Fax (#TP), the misreported ones (#FP), e.g., giving the wrong candi-
date ofaction, and the lost ones (#FN), e.g., losing one candidate of
action.ForALCgeneration,wecheckthecorrectnessofALCsby
comparing them with all the ICC-related program paths.Table 4: Effectiveness Checking on IntentBench
ICC Attribute Launching ContextCategory #A#TP#FP#FN#TP#FP#FN
Basic Attrbute 312 0 0 27 0 0
Extra Parameter 837 0 0 90 0
Basic and Extra 310 0 0 90 0
String 729 0 234 0 2
Null Checker 2600 40 0
Override 5500 70 0
Lifecycle 210 0 0 50 0
Sensitivity 133531 3231
Complete 191060 0
Total 441534312733
The loss of precision in the sensitivity category is due to several
reasons: 1) there may be FPs when an attribute variable is com-
pared with a field/static value, whose assignment may be wrongly
obtained;2)whenthestringvalueisoperatedbyloopoperations
or obtained from unknown library functions, there will be FNs.
Besides, the path-sensitive analysis for ALC generation may suffer
from path-explosion, there will be FNs when the actual number
ofpathsisbeyondthethreshold.Inourexperiments,welimitthe
number of paths to 100,000.
7.2 Effectiveness of Activity Launching
According to the previous works [ 10,60], Monkey is one of the
most popular and effective testing tools due to its effectiveness
and simplicity. Although Monkey behaves well in GUI testing, we
noticed that there is a model-based testing tool Ape [ 15] which
aimstoreplaceMonkey.AndintentFuzzer[ 51],whichsendsintents
with null value as well as serializable data, aims to trigger activity-
launchingrelatedbugsspecifically.Therefore,wecomparewiththebaselineMonkeyandthestate-of-the-artGUIexplorationtoolApe,
aswellasthefuzzingtoolintentFuzzer,whosecharacteristicsare
listedinTable5.Inthefollowingexperiments,wesetonehourasthetestingupperlimittimeforalltoolsoneachinstance.Beforetesting,
weloginappsmanuallyaccordingtotheirfunctionalrequirements.
Table 5: Characteristics of Tools
Name Target Entry Strategy
Monkey GUI Exploration Single Random
Ape GUI Exploration Single Model-based
IntentFuzzer Intent Fuzzing Multiple None
Fax Both Multiple Random
Fig.6givesthenumberofactivitiesofeachappinourbenchmark
aswellasthecoveragereachedbyalltools.Thereare391activitiesinourbenchmark.Afteronehouroftesting,Monkeycovers147of
them and Ape covers 208. As we can see, Monkey reaches high ac-
tivitycoveragewhenthenumberofactivitiesinanappissmallbut
becomesineffectivewhenan apphasalargenumberofactivities.
ApehasasimilartendencyasMonkey,butitusuallyreacheshigher
coverage than Monkey does. The tool IntentFuzzer only covers
158 activities. Theperformance of IntentFuzzer isnot stable when
testing all activities continuously. And Fax with strategy Fax ex
covers377(96.4%),whichworkswellregardlessofthesizeofthe
app. Note that, some activities crashed when launched, e.g., which
4640102030405060NUMBER OF ACTIVITYNumber of Activity
Covered by Monkey
Covered by Ape
Covered by Intent Fuzzer
Covered by Fax
Figure 6: Activity Launching Comparison
meanstheyareineffectiveinstrategyFax ex.Thus,wecountthe
number of successfully launched ones by detecting whether the
activityondisplayisthesameasthelaunchtarget.Wefindthat,there are 237 activities that can be successfully launched by Fax,
which reaches 60.6%.
7.3 Effectiveness of Exploration
Weusemethodcoveragetoshowtheexplorationeffectivenessof
eachapplication.InTable6,thesecondcolumngivesthetotalnum-berofmethods.ThemethodcoverageofMonkey,Ape,IntentFuzzer
(IF for short) and Fax are shown in the following four columns. As
wecansee,FaxoutperformsMonkeyon18of20appsandachieves
thehighestcoveragein12apps,whichshowsitcanexploreappseffectively.ComparedwithMonkey,itachievesarelatively19.7%
high coverage. For some apps, such as EverCam andiNaturalist,
Faxcanvisitorderofmagnitudegreaternumberofmethodsthan
using one-hour Monkey testing. Overall, Ape achieves the highest
coverageandFaxreachesslightlylowercoverage.Therootcause
isthedifferencesintheirexplorationstrategy.Wecanfurthertry
to adopt the model-based strategy to improve the code coverage of
Fax. Fax achieves lower coverage on AntennaPod andPassAndroid
Table 6: Method Coverage Comparison
App #Method Monkey Ape IFFax
1Sheeld 3948 22.11 30.176.4625.94
AFWall+ 1578 0.82 3.170.253.23
AnkiDroid 2133 50.16 61.1323.9154.95
AntennaPod 3599 4.67 5.200.034.56
Calendula 3277 2.32 2.410.403.02
Conversations 5088 1.57 1.041.432.20
CSipSimple 3540 28.39 26.9213.1431.47
EteSync 2013 0.45 0.701.091.14
Evercam 1709 0.53 1.400.062.93
iNaturalist 3306 1.94 6.000.185.99
K9Mail 6733 39.91 45.794.1146.35
Lincal 325 34.77 37.5414.4638.46
OpenGPSTracker 899 42.94 43.8334.3752.73
OpenKeychain 7146 1.40 1.410.112.40
Padland 448 7.59 6.924.918.03
PassAndroid 881 47.79 50.2814.3038.80
Simple-Solitaire 1396 5.52 5.233.035.59
SteamGifts 1451 20.95 54.033.7953.96
SuntimesWidget 3401 58.37 68.421.3664.04
Syncthing 1074 3.82 4.751.404.38
Average 656.75 18.80 22.816.4422.51thanMonkeyandApe.Thereasonweinferredisthattheswitchingofentrytakesextracosts,andsomeALCsbringfewerbenefitsthan
the default entry does while having a high weight.
7.4 Bug Detection Ability
During the app launching and exploration, we record the runtime
loginformationandcollectthetriggereduniquecrashes.Totally,
Faxdetected719uniquecrashes,amongwhich655arelaunching
relatedbugsbytriggering1303launchingcommands,and64are
detectedduringtheGUIexplorationofapps.Asacomparison,Mon-
key finds 8 crashes during exploration, Ape finds 12. IntentFuzzer
finds 18 crashes by testing the original EAs in apps, and it finds 81
ones by testing all activities after exposing IAs into exported ones.
WecategorizethecrashesdetectedbyFaxinto ErrorsandWarn-
ingaccording to their triggering entries, error for EA and warning
for IA. The details of these crashes are listed in Table 7. All the 180
crashes triggered by EA launching and triggered by an exploration
startingfromEAscanbetakenasrealerrors.Inthesecases,anyonecanmakethetargetappcrashbysendingmalformedcommandstoEA.Besides,wefind539crashesthatcanbecategorizedaswarnings.
These crashes are triggered on exported IAs and may not harm the
usage of the app actually. A warning means the correctness of the
crashpointinthecalleedependsonthequalityofthecalleractivity.
However, developers suffer from the misexposure of activities [ 55],
which means they may misexpose activities unanticipatedly and
make these warnings become attackable. For example, a bug fixing
by the developer of EteSyncis to turn the EA AccountActivity
into an IA, which means there is a misexposed activity. So, wetake these crashes triggered on IAs as potential bugs and warn
developers earlier.
Table 7: Category of Crashes Detected by Fax.
FaxlaCrashes EntryNormal ObjectFaxexSum
Error 101 EAs 49 109 22180
Warning 290 IAs 107 390 42539
Sum 391 Acts 156 499 64719
The distribution of exception types is shown in Fig. 7. The
ClassNotFoundException isthe mostcommonone, whichmeans
thetargetclasscouldnotbeloaded.The BadParcelableException
happenswhenanactivityreceivesanunexpectedobjectvalue.If
1 2 4 8 16 32 64 128 256NumberFormatExceptionIllegalStateExceptionRuntimeExceptionIllegalArgumentExceptionOtherNullPointerExceptionBadParcelableExceptionClassNotFoundException
Error Warning
Figure 7: Detected Unique Crash Distribution
465Table 8: Feedbacks of Issues about Activity Launching Crashes.
Project #StarSize#BugIssue ID Status Fixing Revision Reason
AnkiDroid 20258M25401 [32] Fixed 2c890c1 Inadequate Check
AntennaPod 24297M23304 [33] Fixed f5956bc Misexpose
Conversations 329110M 13512 [34] Fixed 011bdd8 Inadequate Check
EteSync 964M184 [35] Fixed d1d0865 Inadequate Check
iNaturalist 5421M 1684 [36] Fixed cc4a44e Inadequate Check
K9Mail 45124M34160 [37] Fixed 4886f2f, 4815a2f, 16535af Inadequate Check
Padland 332M354 [38] Fixed d9709eb Inadequate Check
PassAndroid 4813M4228 [39] Fixed b81f79d Inadequate Check
SuntimesWidget 686M14353 [40] Fixed 4a6d761, 2efe94a Inadequate Check
Synthing 115826M 21382 [41] Fixed c762c18 Inadequate Check
thecarriedobjectcannotberesolvedbythecallee,thetargetactiv-
ity will crash. Another top exception is NullPointerException ,
which means the absence of input checking occurs frequently.
By analyzing the composition of the 1303 crash-triggering com-
mandsbyactivitylaunching,wecountthenumberofICCswithout
any attribute or parameter (Null) and with only basic attribute
(Basic).As wecan seeinTable 9,10.1%crashes aretriggered with
emptyICC,while8.2%needspecificbasicattributeandupto81.7%
containextraparameters.ForICCsthatcontainextraparameters,
we count the number of ICCs with primary parameter only (Pri-
mary),with Bundleitem(Bundle)aswellaswith Serializable or
Parcelable objectitem(Object).About67.4%commandscontain
objects,whichmeansobject-carryingcommandscaneasilycrash
an app. In our experiment, the longest crash triggering test case
requiressixnon-nullattributes,includingonebasicattributeand
five extra parameters.
Table 9: Type of ICC Message that Trigger Crash
Type NullBasicPrimary Bundle Object
Number 132107 137 97 878
Ratio 10.1%8.2% 10.5% 7.4% 67.4%
Wepick46crashesthatcanbetriggeredbylaunchingEAand
commit issues about them on Github. The committed bugs are
picked for three reasons: 1) we only select the crashes that aretriggered by launching EA; 2) we only submit the normal-typecrashes, which can be triggered by test cases that do not carry
complex objects, to make the bug confirming easier; 3) we exclude
theappsthatdidnotupdatewithinoneyear.Amongthe46reported
crashes,33havebeenconfirmedandfixed.Theresultsareshown
in Table 8, in which the issues without the developer’s reply aredropped out. For apps AnkiDroid andPassAndroid, we open pull
requests for bug fixing according to developers’ requirements, and
thedevelopershaveconfirmedthesefixing.Otherbugsarefixedby developers, in which two bugs in app AntennaPod were fixed
in a recently released version before our report. The developer
ofproject SuntimesWidget repliedthatthe"intentresolving"was
pretty much untestedbefore andthey decidedto addtest casesto
avoid this problem.
8 THREATS TO VALIDITY
Internal validity : There are two internal threats in our approach:
false positive of IA-related bugs and weight assignment.The first threat relates to the false positive of the bug detection
on IAs. If the exported activities are taken as the testing entries, all
detected activities are real bugs that can be exploited by attackers,
i.e.,allidentified Errorsaretruepositives.Inourapproach,tode-
tectmorehiddenbugs,weallowFaxtotakeinternalactivitiesas
testingobjects.Thetestingofinternalactivitiesismorelikelytobe
unit testing. Without analyzing ICC flows and tracking all the con-
straints of the input data, Faxsupposes that any input received by
internal activities is reasonable, which may contain invalid values.
ForWarnings,wewillconductfurtheranalysistoautomaticallyget
the number of true positives, e.g., make a forward tracking of each
received value to figure out the data sources and constraints.
Another threat relates to the accuracy of the weight assignment.
Foractivitylaunchingtesting,moreentriescanexploitmorepos-
siblebugs,butinexploration,thelow-qualityentrywilldecrease
the total coverage. In tool Fax, we evaluate the importance of each
entry based on the dynamically constructed ATG and use heuristic
strategiestofilterouttheentrieswithlowerimportance.Theexplo-
ration weight calculation depends on the accuracy of ATG and the
dynamicexecutiontraces.Generally,itisdifficulttoidentifyallthe
transitions statically and judge whether the transition is available
ornotbypurestaticanalysis.WecomplementthestaticATGby
dynamicexploration,however,westillcannotguaranteethefair-
nessoftesting.Butwemakeeffortstorecalculatetheexploration
weight among ALCs by multiple rounds and try to optimize the
weight assigning process adaptively.
Externalvalidity :Threatstoexternalvalidityrelatetothegen-
eralizability ofour experimental results.Our study islimitedto theevaluatedAndroidappsandourresultsmaynotgeneralizebeyond
the evaluated apps.
9 RELATED WORKS
In this section, we will briefly introduce representative works that
are related to the GUI exploration, ICC analysis and intent fuzzing
techniques in recent years.
GUI Exploration There are many kinds of GUI testing ap-
proaches for Android apps, including random, model-based, andsystematic testing techniques. Wang et al. propose a description
frameworktodemonstratethekeyissuesinautomatictest-input
generation[ 53].Inrandomtesting,thetesteventswillbegenerated
randomlywithlesscareofthecurrentstateoftheappundertest.
Monkey is one of the most widely used black-box random testing
tools. It is a simple and fully automatic tool that can generate alot of test events within a short time. There are works based on
466Monkey for detecting GUI bugs [ 17] and security bugs [ 25]. Sev-
eral researches construct the models to guide their exploration
process [2,3,9,15,16,28,57]. S. Yang et al. [ 57] provided a model
calledWindowTransitionGraph,withanaccuratestaticcallback
analysis. Su et al. [ 48] proposed a model-based approach recently,
which uses both dynamic and static analysis with a weighted UI
explorationstrategy.Andtheyrandomlyinjectsystem-levelevents,
like sending null intent, to trigger more bugs. However, they ex-
tracteventsaccordingtothedeclarationoftagintent-filterinthe
manifest .Systematictestingtechniques[ 7,22,27]areappliedin
more complicated circumstances, e.g., automatically finding event
sequencesthatreachagiventargetlineintheapplicationcode.Our
work focuses on GUI exploration, but we do not limit to one explo-
ration strategy. We concentrate on starting the exploration frommultiple entries and with various ALCs. During the exploration,
any event picking strategy can be integrated.
IntentFuzzing. Someresearchersadoptfuzzingtechnique[ 49]
tofindoutthepoorlydesignedexportedcomponents,whichalso
need to simulate the proper ALC. For example, tool Null Intent
Fuzzer[18]sendsintentswiththeonlyinputdata null.Andtool
DroidFuzzer [59]focusesonactivitiesthatprocess MIMEdata(e.g.,
"video/*") passed via an URI. Besides, Maji et al.[26] presents
thefirstempiricalevaluationoftherobustnessofICCinAndroid
through fuzz testing methodology. However, when fuzzing explicit
intents, they use straightforward strategies, such as "Semi-valid
ActionandData","BlankActionorData","RandomActionorData"
as well as "Random Extras", which may generate a large number ofredundant test cases. In its experiment, around 9000 intents will be
sent to test an activity, while we use less than ten test cases in our
approach.Toavoidtheaimlessexplorationwithinvalidparameters,
these works [ 26,45,56,59] adopt the configuration-directed testing
approach. They aim at the original exported components that have
an XML-formed declaration in manifest , which is providedby the
Androidsystemforappconfiguration.However,therearesevere
mismatchesbetweentheattributedeclarationandtheiractualus-
ageaccordingtoourstudy.SomeoftheICCparameterscanonly
be obtained in code but not the manifest file. Another tool intent-
Fuzzer[45]isdevelopedusingsomestaticanalysistechniqueswith
thegoaloftriggeringbugs,whichissimilartoouractivitymodeling.
However, they directly leverage FlowDroid, a static analysis tool
designedforprivacyleakdetection,toextractthekey-typepairsofextraparameters.So,theycannothandlelarge-scaleAndroidapps.
Besides, their approach has the inherent weakness from fuzzingthat the number of test cases is very large, while we avoid this
problem by path sensitive attribute usage analysis.
ICCExtraction. SomeworksaimatextractingICCinformation,
forexample,theresearch [ 31]proposedCOALlanguage tomodel
the ICC messages and apply the COAL solver to infer Android
ICC values. In this work, they implemented a practical tool called
IC3.Recently,someresearchers[ 50]conductresearchesbasedon
it. However, IC3doesnot provide theattribute usageinformation
ofICCanditisunabletogenerateALCs.Besides,itobtains basic
attributes frommanifest files, which is not accurate enough. In
ourapproach,weadoptalight-weightintentanalysismethodin
this paper to obtain the information needed.
String Analysis. As a widely used type in Android apps, the
stringisalsowidelystudiedbyrecentworks.Rasthofer etal.[44]presents a framework for automatically generating an Android
executioncontexttotriggermaliciousbehaviors,inwhichstring
informationshouldbeinferredcorrectly.Toaccomplishthis,they
give several string value providers. The constant value provider
theyusedgathersallthestringconstantsascandidatesforruntime
valueswhichcompareagainstconstants,whichwillincreasethe
burden oftesting, whilethe dynamically-computed valuesare not
taken into account. In our work, to find out candidate values for
ICC-relatedattributesprecisely,wecapturethedatapropagation
to obtain the actually used constant candidates, and model the ICC
related string APIs to calculate the dynamic operated ones.
Symbolic Execution Symbolic execution is a useful program
analysistechniquethatcansimultaneouslyexploremultiplepro-
gram paths with various execution contexts. However, the analysis
suffers from path divergence without simulating the behavior of
Androidlibraries.ToverifyAndroidappsprecisely,Merweet.al.ex-
tend JPF [ 21] to JPF-Android [ 52]. They model core libraries in the
Android framework semi-manually and symbolically execute apps
on Java Virtual Machine. Gao et al.[ 14] then proposed a dynamic
symbolic execution engine for Android apps, which automatically
synthesizes libraries without manual modeling. Our approach also
adopts a symbolic-execution-like analysis and collects path con-straints about ICC attribute variables. Concentrating on the ICC
attributesmodeling,wedonotperformanalysisoncompletepaths
but drop the ICC attributes/parameters-irrelevant information.
10 CONCLUSION
Inthis paper,we aimto breakthe unevenactivity coveragein the
exploration of Android apps and try to test each activity in variouslaunchingcontexts.Wefirstinvestigatethelaunchingprocessofac-tivitycomponent,thenperformaninter-procedural,flow-,context-
and path-sensitive analysis to build activity launching models and
generate complete launching contexts. Besides, we proposed an
adaptive explorationframework thatreassigns eventsto multiple
entriestoenhancetheexplorationability.Thekeychallengeslie
in how to handle various ICC attribute characteristics to construct
proper contexts as well as how to calculate the exploration weight
of each entry in each round. We implemented our approach in atool called Fax, with an activity launching strategy Fax
laand an
exploration strategy Fax ex. The experiments on real-world apps
showthatFaxbehaveswellbothinthein-depthexplorationand
the context-aware activity launching testing. In the future, we will
try to identify the trigger paths of IA-related crashes automatically
to make the bug confirmation easier.
ACKNOWLEDGMENTS
Theauthorswouldliketothanktheanonymousreviewersfortheir
helpful comments and suggestions. This work is supported by the
KeyResearchProgramofFrontierSciences,ChineseAcademyof
Sciences(GrantNo.QYZDJ-SSW-JSC036),andtheNationalNatural
Science Foundation of China (Grant No. 61672505).
467REFERENCES
[1]ADBshell-AndroidADBCommandsManual.2019. http://adbshell.com/.(2019).
[2]DomenicoAmalfitano,AnnaRitaFasolino,PorfirioTramontana,SalvatoreDe
Carmine, and Atif M. Memon. 2012. Using GUI ripping for automated testing of
Android applications. In ASE 2012. 258–261.
[3]DomenicoAmalfitano,AnnaRitaFasolino,PorfirioTramontana,BryanDzung
Ta, and Atif M. Memon. 2015. MobiGUITAR: Automated Model-Based Testing of
Mobile Apps. IEEE Software 32, 5 (2015), 53–59.
[4] Saswat Anand,MayurNaik,MaryJean Harrold,andHongseokYang.2012. Au-
tomated concolic testing of smartphone apps. In SIGSOFT/FSE 2012. 1–11.
[5] Ant. 2019. https://ant.apache.org/. (2019).
[6]Apktool - A tool for reverse engineering. 2019. http://ibotpeaches.github.io/
Apktool/. (2019).
[7]TanzirulAzimandIulianNeamtiu.2013. Targetedanddepth-firstexploration
for systematic testing of Android apps. In OOPSLA 2013, part of SPLASH 2013.
641–660.
[8]Bundle|Android Developers. 2019. https://developer.android.com/reference/
android/os/Bundle.html. (2019).
[9]Wontae Choi, George C.Necula, and Koushik Sen. 2013. GuidedGUI testing of
Android apps with minimal restart and approximate learning. In OOPSLA 2013,
part of SPLASH 2013. 623–640.
[10]Shauvik Roy Choudhary, Alessandra Gorla, and Alessandro Orso. 2015. Au-tomated Test Input Generation for Android: Are We There Yet?. In ASE 2015.
429–440.
[11]Leonardo Mendonça de Moura and Nikolaj Bjørner. 2008. Z3: An Efficient SMT
Solver. In ETAPS 2008. 337–340.
[12] F-Droid. 2019. https://f-droid.org/. (2019).[13] Fax. 2019. https://github.com/hanada31/Fax. (2019).[14]
XiangGao,ShinHweiTan,ZhenDong,andAbhikRoychoudhury.2018. Android
testing via synthetic symbolic execution. In Proceedings of the 33rd ACM/IEEE
International Conference on Automated Software Engineering, ASE 2018. 419–429.
[15]Tianxiao Gu, Chengnian Sun, Xiaoxing Ma, Chun Cao, Chang Xu, Yuan Yao,
Qirun Zhang, Jian Lu, and Zhendong Su. 2019. Practical GUI testing of Android
applications via model abstraction and refinement. In ICSE 2019. 269–280.
[16]Shuai Hao, Bin Liu, Suman Nath, William G. J. Halfond, and Ramesh Govindan.
2014. PUMA:programmableUI-automationforlarge-scaledynamicanalysisof
mobile apps. In MobiSys 2014. 204–217.
[17]Cuixiong Hu and Iulian Neamtiu. 2011. Automating GUI testing for Android
applications. In AST 2011. 77–83.
[18]Intent Fuzzer. 2019. https://www.nccgroup.trust/us/our-research/intent-fuzzer/.
(2019).
[19]IntentBench.2019. https://github.com/hanada31/Fax/tree/master/IntentBench.
(2019).
[20]Intents and Intent Filters |Android Developers. 2016. https://developer.android.
com/guide/components/intents-filters.html. (2016).
[21] Java Path Finder. 2019. http://javapathfinder.sourceforge.net/. (2019).[22]
Casper Svenning Jensen, Mukul R. Prasad, and Anders Møller. 2013. Automated
testing with targeted event sequence generation. In ISSTA 2013. 67–77.
[23]JieruiLiu,TianyongWu,JunYan,andJianZhang.2017. InsDal:Asafeandexten-
sible instrumentation tool on Dalvik byte-code for Android applications. In IEEE
24th International Conference on Software Analysis, Evolution and Reengineering,
SANER 2017. 502–506.
[24]Aravind Machiry, Rohan Tahiliani, and Mayur Naik. 2013. Dynodroid: an input
generation system for Android apps. In ESEC/FSE 2013. 224–234.
[25]RiyadhMahmood,NaeemEsfahani,ThabetKacem,NarimanMirzaei,SamMalek,
and Angelos Stavrou. 2012. A whitebox approach for automated security testing
of Android applications on the cloud. In AST 2012. 22–28.
[26]AmiyaKumarMaji,FahadA.Arshad,SaurabhBagchi,andJanS.Rellermeyer.
2012. An empirical study of the robustness of Inter-component Communication
in Android. In DSN 2012. 1–12.
[27]KeMao,MarkHarman,andYueJia.2016. Sapienz:multi-objectiveautomatedtest-
ing for Android applications. In Proceedings of the 25th International Symposium
on Software Testing and Analysis, ISSTA, 2016. 94–105.
[28]NarimanMirzaei,JoshuaGarcia,HamidBagheri,AlirezaSadeghi,andSamMalek.
2016. Reducing combinatorics in GUI testing of android applications. In ICSE
2016. 559–570.
[29] Monkey. 2019. https://developer.android.com/studio/test/monkey. (2019).[30]
Nielson, Flemming, Hanne R. Nielson, and Chris Hankin. 2015. Principles of
program analysis. Springer.
[31]Damien Octeau, Daniel Luchaup, Matthew Dering, Somesh Jha, and Patrick
McDaniel. 2015. Composite Constant Propagation: Application to Android Inter-
Component Communication Analysis. In ICSE 2015. 77–88.
[32]IssuseofAnkiDroid.2019. https://github.com/ankidroid/Anki-Android/issues/
5401. (2019).
[33]IssuseofAntennaPod.2019. https://github.com/AntennaPod/AntennaPod/issues/
3304. (2019).[34]Issuse of Conversations. 2019. https://github.com/siacs/Conversations/issues/
3512. (2019).
[35] Issuse of EteSync. 2019. https://github.com/etesync/android/issues/84. (2019).[36]
Issuse of iNaturalist. 2019. https://github.com/inaturalist/iNaturalistAndroid/
issues/684. (2019).
[37] Issuse of K9Mail. 2019. https://github.com/k9mail/k-9/issues/4160. (2019).[38] Issuse of Padland. 2019. https://github.com/mikifus/padland/issues/54. (2019).[39]
Issuse of PassAndroid. 2019. https://github.com/ligi/PassAndroid/issues/228.
(2019).
[40]Issuse of SuntimesWidget. 2019. https://github.com/forrestguice/
SuntimesWidget/issues/353. (2019).
[41]IssuseofSynthing.2019.https://github.com/syncthing/syncthing-android/issues/
1382. (2019).
[42]K9MailonGithub.2019.https://github.com/k9mail/k-9/tree/GH-701_fix_special_
use_folders_with_prefix. (2019).
[43]LinjiePan,BaoquanCui,JiweiYan,XutongMa,JunYan,andJianZhang.2019.An-
drolic: an extensible flow, context, object, field, and path-sensitive static analysis
framework for Android. In ISSTA 2019. 394–397.
[44]SiegfriedRasthofer,StevenArzt,StefanTriller,andMichaelPradel.2017. Making
malory behave maliciously: targeted fuzzing of android execution environments.
InICSE 2017. 300–311.
[45]Raimondas Sasnauskasand JohnRegehr. 2014. Intentfuzzer: craftingintents of
death. In WODA+PERTEA 2014. 1–5.
[46] Soot. 2019. http://www.bodden.de/2008/09/22/soot-intra. (2019).[47]
Java String. 2019. https://docs.oracle.com/javase/8/docs/api/java/lang/String.
html. (2019).
[48]Ting Su, Guozhu Meng, Yuting Chen, Ke Wu, Weiming Yang, Yao Yao, Geguang
Pu,YangLiu,andZhendongSu.2017. Guided,stochasticmodel-basedGUItesting
ofAndroidapps.In Proceedingsofthe201711thJointMeetingonFoundationsof
Software Engineering, ESEC/FSE, 2017. 245–256.
[49]Sutton, Michael, Adam Greene, and Pedram Amini. 2007. Fuzzing: brute force
vulnerability discovery. Pearson Education.
[50]Cong Tian, Congli Xia, and Zhenhua Duan. 2018. Android inter-component
communication analysis with intent revision. In ICSE 2018. 254–255.
[51] IntentFuzzer Tool. 2019. https://github.com/MindMac/IntentFuzzer. (2019).[52]
Heila van der Merwe, Brink van der Merwe, and Willem Visser. 2012. Verifying
android applications using Java PathFinder. ACM SIGSOFT Software Engineering
Notes37, 6 (2012), 1–5.
[53]Jue Wang, Yanyan Jiang, Chang Xu, Xiaoxing Ma, and Jian Lu. 2019. Automatic
test-input generation for Android applications (in Chinese). SCIENCE CHINA
Informationis 49, 10 (2019), 1234–1266. https://doi.org/10.1360/N112019-00003
[54]Tianyong Wu, Xi Deng, Jun Yan, and Jian Zhang. 2019. Analyses for specificdefects in android applications: a survey. Frontiers Comput. Sci. 13, 6 (2019),
1210–1227.
[55]Jiwei Yan, Xi Deng, Ping Wang, Tianyong Wu, Jun Yan, and Jian Zhang. 2018.
Characterizing and identifying misexposed activities in Android applications. In
ASE 2018. 691–701.
[56]KunYang,Jianwei Zhuge,Yongke Wang,Lujue Zhou,and Hai-XinDuan.2014.
IntentFuzzer: detecting capability leaks of android applications. In ASIA CCS
2014. 531–536.
[57]Shengqian Yang, Hailong Zhang, Haowei Wu, Yan Wang, Dacong Yan, and
Atanas Rountev. 2015. Static Window Transition Graphs for Android. In ASE
2015. 658–668.
[58]Wei Yang, Mukul R. Prasad, and Tao Xie. 2013. A Grey-Box Approach for Auto-
mated GUI-Model Generation of Mobile Applications. In ETAPS 2013. 250–265.
[59]HuiYe,ShaoyinCheng,LanboZhang,andFanJiang.2013. DroidFuzzer:Fuzzing
the Android Apps with Intent-Filter Tag. In MoMM 2013. 68–74.
[60]XiaZeng,DengfengLi,WujieZheng,FanXia,YuetangDeng,WingLam,Wei
Yang,andTaoXie.2016. AutomatedtestinputgenerationforAndroid:arewe
really there yet in an industrial case?. In FSE 2016. 987–992.
[61]YunhuiZheng,XiangyuZhang,andVijayGanesh.2013. Z3-str:az3-basedstring
solver for web application analysis. In ESEC/FSE 2013. 114–124.
468