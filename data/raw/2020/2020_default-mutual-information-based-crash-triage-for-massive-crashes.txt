D/e.scF/a.sc/u.sc$%: Mutual Information-based Crash Triage for MassiveCrashesXing Zhang1, Jiongyi Chen1(/Letter), Chao Feng1, Ruilin Li1,Wenrui Diao2,3, Kehuan Zhang4, Jing Lei1, Chaojing Tang11National University of Defense Technology2School of Cyber Science and Technology, Shandong University3Key Laboratory of Cryptologic Technology and Information Security, Ministry of Education, Shandong University4Chinese University of Hong KongABSTRACTWith the considerable success achieved by modern fuzzing in-frastructures, more crashes are produced than ever before. Todig out the root cause, rapid and faithful crash triage for largenumbers of crashes has always been attractive. However, hinderedby the practical diï¬ƒculty of reducing analysis imprecision withoutcompromising eï¬ƒciency, this goal has not been accomplished.In this paper, we present an end-to-end crash triage solutionD/e.scF/a.sc/u.sc$%, for accurately and quickly pinpointing unique root causefrom large numbers of crashes. In particular, we quantify theâ€œcrash relevanceâ€ of program entities based on mutual information,which serves as the criterion of unique crash bucketing and allowsus to bucket massive crashes without pre-analyzing their rootcause. The quanti/f_ication of â€œcrash relevanceâ€ is also used in theshortening of long crashing traces. On this basis, we use theinterpretability of neural networks to precisely pinpoint the rootcause in the shortened traces by evaluating each basic blockâ€™simpact on the crash label. Evaluated with 20 programs with22216 crashes in total, D/e.scF/a.sc/u.sc$%demonstrates remarkable accuracyand performance, which is way beyond what the state-of-the-arttechniques can achieve: crash de-duplication was achieved at asuper-fast processing speed â€“ 0.017 secondsper crashing trace,without missing any unique bugs. After that, it identi/f_ies the rootcause of 43 unique crashes with no false negatives and an averagefalse positive rate of 9.2%.CCS CONCEPTSâ€¢Security and privacyâ†’Software security engineering.KEYWORDSCrash Triage; Software Security/LetterCorresponding author,chenjiongyi@nudt.edu.cn.Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor pro/f_it or commercial advantage and that copies bear this notice and the full citationon the/f_irst page. Copyrights for components of this work owned by others than ACMmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish,to post on servers or to redistribute to lists, requires prior speci/f_ic permission and/or afee. Request permissions from permissions@acm.org.ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USAÂ© 2022 Association for Computing Machinery.ACM ISBN 978-1-4503-9221-1/22/05. . . $15.00https://doi.org/10.1145/3510003.3512760ACM Reference Format:Xing Zhang, Jiongyi Chen, Chao Feng, Ruilin Li, Wenrui Diao, KehuanZhang, Jing Lei, and Chaojing Tang. 2022. D/e.scF/a.sc/u.sc$%: Mutual Information-based Crash Triage for Massive Crashes. In44th International Conference onSoftware Engineering (ICSE â€™22), May 21â€“29, 2022, Pittsburgh, PA, USA.ACM,New York, NY, USA, 12 pages. https://doi.org/10.1145/3510003.35127601 INTRODUCTIONSoftware vulnerability is a prevailing threat in cyberspace. Todiscover and eliminate software vulnerabilities, fuzzing has beenrecognized as one of the most e(ective approaches by randomlyor strategically generating a large number of inputs to feed aprogram and trigger program exceptions. For example, the fuzzinginfrastructure ClusterFuzz has found more than 25,000 bugs inGoogle products (e.g., Chrome) and around 22,500 bugs in over340 open source projects in September 2020 [3]. Even though con-siderable progress has made in triggering crashes, the subsequentprocedureâ€”crash triageâ€”remains imprecise, time-consuming, andlabor-intensive.Accuracy, eï¬ƒciency, and generality are the major concerns ofcurrent crash triage techniques. However, there lacks a systematicsolution that can balance the trade-o(s and achieve accurate,fast, and fully-automated crash triage. For the past decade, al-though there has been a wealth of research into crash triage,including crash deduplication [16,18,27,29,33,34] and faultlocalization [5,10,20,25,26,31,42,44,47,48], the eï¬ƒcacy of thoseapproaches signi/f_icantly varies based on di(erent vulnerabilitytypes, crash reports, and running environment, making them lessapplicable to general programs. In particular, a line of prior crashdeduplication approaches work at the granularity of function calllevel and fail to bucket crashes by inspecting the crashesâ€™ actualroot cause, which could cause critical vulnerabilities triggeredbut missed. The other research aims to deduplicate crashes byexamining the root cause of crashes or representing root causewith the constraints on crashing paths, which takes signi/f_icant timewhen the number of processed crashes increases. Regarding faultlocalization, given that prior statistical approaches fail to capturesequence information of root-cause basic blocks, the accuracyof identi/f_ication is seriously a(ected. More importantly, thoseapproaches only output suspicious scores for a set of basic blocks,for example, top 20 basic blocks. In practice, this does not givesuï¬ƒcient guidance for analysts, as they still have a set of basiccandidate blocks to examine.6352022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. Inthis paper, we present an end-to-end crash triage solutioncalledD/e.scF/a.sc/u.sc$%, for rapidly de-duplicating massive traces of crashesand accurately pinpointing the root cause for unique crashes. Weborrow the concept of mutual information in information theoryand treat crash triage as an information mining process. Thekey insight is that mutual information of program entities (e.g.,functions and basic blocks) is a measurement of their relevance tothe crash. We leverage such â€œcrash relevanceâ€: (1) as the criteriato bucket unique crashes in crash deduplication; (2) to identifyand/f_ilter out irrelevant program entities for shortening traces inour neural network-based fault localization. Without inspectingeach crashâ€™s root cause, our approach allows crash deduplicationaccomplished within a short time without missing bugs. In thesubsequent fault localization procedure, the mutual informationabout â€œcrash relevanceâ€ is used again to/f_ilter program entities thatare irrelevant to the crash, which shortens the long execution tracesand thus facilitates the feeding of inputs to the neural network.On such a basis, in the last step, we utilize the interpretability ofneural networks to extract the actual root cause from the shortenedtraces. With the ability to capture sequence information, the neuralnetwork signi/f_icantly improves root cause identi/f_ication accuracycompared with the traditional approaches.We implemented a full-featured prototype ofD/e.scF/a.sc/u.sc$%andevaluated it with 20 programs, including 8 CGC programs and12 real-world programs. On the one hand, for crash de-duplication,D/e.scF/a.sc/u.sc$%processed 22216 crashing traces at a speed of 0.017 secondsper trace. It identi/f_ied 42 unique crashing traces without missingany bugs. Regarding fault localization, it reports no false negativesand low false positive rate of 9.2%, which is way beyond what thestate-of-the-art tools can achieve.Contributions.The contributions of this paper are summarizedas follows.â€¢New techniques.We propose a new approach to measurethe â€œcrash relevanceâ€ of program entities based on mutualinformation, which is critical for crash deduplication andfault localization. With such an approach, we design andpresent a novel end-to-end analysis system,D/e.scF/a.sc/u.sc$%, thatdirectly takes crashing execution traces from fuzzers as inputand automatically pinpoints the root cause of program faults.â€¢Evaluation.We evaluatedD/e.scF/a.sc/u.sc$%on 20 programs, includ-ing 8 CGC programs and 12 real-world programs. The resultsdemonstrate thatD/e.scF/a.sc/u.sc$%is both eï¬ƒcient and accurate. Thetool publicly available for continuous research1.Roadmap.The rest of this paper is organized as follows: Section 2surveys the related research. Section 3 provides the necessarybackground, covering mutual information and the attention mech-anism of interpretability of neural networks. Section 4 describesthe detailed design ofD/e.scF/a.sc/u.sc$%. Section 5 presents the evaluationresults and the comparison with existing techniques. Section 7concludes this paper.1D/e.scF/a.sc/u.sc$%is available at https://github.com/zxhree/default2 RELATED WORKIn this section, we review the related work on crash deduplicationand fault localization for software testing. The limitations of theexisting approaches are also summarized.2.1 Crash DeduplicationCrash deduplication aims to cluster crashes produced by fuzzersand select a unique crash (or a representative crash) from eachclustered group of crashes that share the same root cause. Thesubsequent fault localization is performed on such unique crashes.With more crashes produced by fuzzing infrastructures, crashdeduplication has become an urgent demand, easing the burden ofsubsequent fault localization. However, existing approaches are farfrom accurate and practical, as they are either coarse-grained ormake certain assumptions. Below we describe the related work.Call stack-based deduplication.The widely used call stack-based approaches measure the similarity among function callsequences [16,18,27,29], function arguments [9], or call graphs [23]of the functions on call stacks. In general, such approaches arecoarse-grained. If a program with diï¬€erent vulnerabilities crashedin the same function, call stack-based deduplication would missunique crashes.Constraint-based deduplication.As the typical representative,Pham et al. [33] and Podelski et al. [34] collect constraints on thefailing paths and passing paths, and deduce their longest commonpre/f_ix, which is further used to characterize the semantics of thefailure. deduplication is conducted based on the unique symbolicsemantics. However, hindered by the drawbacks of symbolicexecution techniques [11,14] (e.g., control/f_low dependence andunsolvable constraints), such approaches are less scalable formassive crashes of real-world programs.Patching-based deduplication.Patching-based deduplication/f_irst automatically/f_ixes speci/f_ic vulnerabilities [12,28,37] (e.g.,buï¬€er over/f_low and null pointer dereference) at crashing pointand then observes whether un/f_ixed crashes can be reproduced.The crashes that cannot be reproduced are clustered into the samegroup. This approach relies on source code analysis and speci/f_icvulnerability types, not to mention the side eï¬€ect of programtransformation. Therefore, it is less applicable to binary programswith unknown vulnerability types.Report-based deduplication.Report-based deduplication lever-ages information retrieval techniques to analyze text informationof crash reports. For examples, Wang et al. [38] leverage topicmodels, Sca%e et al. [35] use neural networks, and Ye et al. [46]utilize sort algorithms, to extract crash-related information like callsequences and the history of vulnerability patching. Kim et al. [22]use machine learning techniques to predict the root cause, for thepurpose of diï¬€erentiating various crashes. However, report-basedapproaches are too coarse, which are typically performed upon thefunction level. Apart from that, the eï¬€ectiveness depends on howthe OS or the debugger writes the record, which may not providesuï¬ƒcient crash-related information.636Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. 2.2 Fault LocalizationAutomatic fault localization techniques leverage the statistics oftarget programs at runtime to locate program faults. The relatedwork can be categorized as follows:Program spectrum-based approaches.Program spectrum, suchas the statistics of program paths executions, is a measurementof program running status. Collefello et al. [15] for the/f_irst timeleveraged program spectrum for fault localization. By comparingthe statistics of program entities about normal exit and crash, asuspicious score is given to each program entity. Generally, the moreexecution time a program entity has in crash samples than normalexit samples, the higher score the program entity gets. The scores ofprogram entities can be calculated and ranked according to variousapproaches [5,10,19,20,25,26,31,42,44,47,48]. However, allexisting approaches only consider whether a program entity existsin samples but neglect the execution times of the entities in a certainsample and the sequence of their executions. As demonstrated inSection 5, without such sequence information, program spectrum-based fault localization would inevitably introduce imprecision.Machine learning-based approaches.Machine learning-basedapproaches [30,32,36,50] treat program entities as input andleverage the classi/f_ication systems to output the probability of rootcause for each program entity. For instance, Liu et al. [30] representthe execution/f_low of a program as a graph. Also, they use graphmining approaches to extract sub-graphs about program faults anduse SVMs to identify each sub-graphâ€™s contributions to the crash.Similarly, Nessa et al. [32] use N-Gram to calculate the conditionalprobability of program entities in execution traces to the crash.However, similar to program spectrum-based approaches, thosestudies do not recover sequence information for root-cause basicblocks.Program slicing-based approaches.Program slicing techniques [39],including static slicing and dynamic slicing, are to compute aset of program statements that may aï¬€ect the values at somepoint of interest. In particular, dynamic slicing [6] is often used infault localization by analyzing program execution traces. Agrawalet al. [7] leverage dynamic slicing to locate program faults bycalculating the slicesâ€™ intersection. Wang et al. [40,41] use dynamicslicing to pinpoint program faults by analyzing data dependenceamong program entities. Zhang et al. [51,53] use dynamic slicingto extract the change of variables related to the crash to locate rootcauses. Moreover, Xu et al. [43] use backward program slicing tolocate program faults with the support of Intel PT. However, due tothe control/f_low dependence problem â€“ a fundamental drawbackof data/f_low analysis, the eï¬€ectiveness of those approaches is notsatisfactory.2.3 Limitations of Prior ResearchThough much eï¬€ort has been put into the research of crash triage,the existing approaches still have multiple critical limitations, assummarized below.â€¢Generality.The eï¬€ectiveness of crash triage techniquessigni/f_icantly varies with diï¬€erent vulnerability types, crashreports, and running environment, making them less appli-cable to general programs.â€¢Accuracy.Prior crash deduplication approaches work atthe granularity of function call level and fail to bucketcrashes by inspecting the actual root cause of the crashes,which may cause imprecision and miss bugs. On the otherhand, existing fault localization approaches do not considersequence information, which introduces imprecision again.â€¢Time consumption.To bucket the crashes, existing ap-proaches examine each crash regardless of the granularity.After that, a pair-wise match among all crashes is unavoid-able, which takes signi/f_icant time with the number of crashesincreasing.3 PRELIMINARIESThis section provides some necessary backgrounds of mutualinformation and introduces the attention mechanism of neuralnetworks.3.1 Mutual InformationIn information theory, mutual information is a measure of themutual dependence between two random variables. It can beregarded as the amount of information that one random variablecontains about the other random variable. Mutual information isan important criterion for feature selection in machine learning.The more information a feature brings to the classi/f_ication system,the larger the value of its mutual information is. Namely, such afeature is more relevant to the classi/f_ication. Inspired by the fact,we leverage the mutual information to measure the contribution ofbasic blocks to crashes. We use the mutual information not only incrash de-duplication, but also in the initial step of fault localizationby/f_iltering out the vast majority of program entities (e.g., functionsand basic blocks) that are irrelevant to the crash.Mutual information.We represent a crashing trace at basic blocklevel as a list of tuples:B={ğ‘Œ1:ğµ(ğ‘Œ1);ğ‘Œ2:ğµ(ğ‘Œ2)...;ğ‘Œğ‘‡:ğµ(ğ‘Œğ‘‡)},whereğ‘Œis (the starting address of) a basic block,ğµ(ğ‘Œ)is itsoccurrence in traceB. The output of a fuzzer forms a datasetD=<B,Y>, whereBis a set of crashing traces{B1,B2,. . . ,Bğ‘‡}andY={ğ‘‹1,ğ‘‹2,. . . ,ğ‘‹ğ‘‡}is a set of labels denoting whether a tracecorresponds a crash or a normal exit.For a given datasetğ‘¢, the mutual information of a basic blockğ‘Œto labelğ‘‹is given by:ğ‘€(ğœ‡|ğ¹)=ğ‘¢(ğ¹)âˆ’ğ‘¢(ğ¹|ğœ‡)=ğ‘¢(ğœ‡)âˆ’ğ‘¢(ğœ‡|ğ¹)(1)whereğ‘‚(ğ‘‹)is the entropy of labelğ‘‹andğ‘‚(ğ‘‹|ğ‘Œ)is the conditionalentropy of basic blockğ‘Œgiven labelğ‘‹. More speci/f_ically, we denoteğ´ğ‘‚as the amount of non-crashing traces in datasetğ‘¢andğ´/u1D453asthe amount of crashing traces in datasetğ‘¢(whereğµ=ğ´/u1D453+ğ´ğ‘‚).Then the entropy of labelğ‘‹is:ğ‘¢(ğœ‡)=âˆ’/u1D441/u1D45D/u1D441/u1D459/u1D45C/u1D454(/u1D441/u1D45D/u1D441)âˆ’/u1D441/u1D453/u1D441/u1D459/u1D45C/u1D454(/u1D441/u1D453/u1D441)(2)Using/u1D45A/u1D44E/u1D465(ğµ(ğ‘Œ))to denote the max ofğµ(ğ‘Œ)for basic blockğ‘ŒinallBthat belong toğ‘¢, we have the conditional entropyğ‘‚(ğ‘‹|ğ‘Œ):ğ‘¢(ğœ‡|ğ¹)=âˆ’/u1D45A/u1D44E/u1D465(/u1D45B(/u1D44F))/summationdisplay.1/u1D456=0ğ‘‚(ğ¹|/u1D45B(/u1D44F)=/u1D456)ğ‘¢(ğœ‡|ğ¹|/u1D45B(/u1D44F)=/u1D456)(3)where/u1D45D(ğ‘Œ|/u1D45B(/u1D44F)=/u1D456)=,/u1D456(ğ¹)/u1D441.637Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. Additionally, the conditional entropy ofğ‘‹toğ‘Œ|/u1D45B(/u1D44F)=/u1D456is:ğ‘‚(ğ‘‹|ğ‘Œ|/u1D45B(/u1D44F)=/u1D456)=âˆ’/u1D450ğ‘‚/u1D456(ğ‘Œ)/u1D450/u1D456(ğ‘Œ),/u1D45C.(/u1D450ğ‘‚/u1D456(ğ‘Œ)/u1D450/u1D456(ğ‘Œ))âˆ’/u1D450/u1D453/u1D456(ğ‘Œ)/u1D450/u1D456(ğ‘Œ),/u1D45C.(/u1D450/u1D453/u1D456(ğ‘Œ)/u1D450/u1D456(ğ‘Œ))(4)In the above formula,/u1D450/u1D456(ğ‘Œ)is the amount ofBinğ‘¢whenğµ(ğ‘Œ)=/u1D456,/u1D450ğ‘‚/u1D456(ğ‘Œ)is the amount ofBinğ‘¢whenğ‘‹=0 andğµ(ğ‘Œ)=/u1D456, and/u1D450/u1D453/u1D456(ğ‘Œ)is the amount ofBinğ‘¢whenğ‘‹=1 andğµ(ğ‘Œ)=/u1D456. CombiningEquation(3)and Equation(4), we can obtain the conditional entropyğ‘‚(ğ‘‹|ğ‘Œ)and the mutual information/u1D43C(ğ‘‹|ğ‘Œ):ğ‘¢(ğœ‡|ğ¹)=âˆ’/u1D45A/u1D44E/u1D465(/u1D45B(/u1D44F))/summationdisplay.1/u1D456=0,/u1D456(ğ¹)/u1D441(,/u1D45D/u1D456(ğ¹),/u1D456(ğ¹)/u1D459/u1D45C/u1D454,/u1D45D/u1D456(ğ¹),/u1D456(ğ¹)+,/u1D45D/u1D456(ğ¹),/u1D456(ğ¹)/u1D459/u1D45C/u1D454,/u1D45D/u1D456(ğ¹),/u1D456(ğ¹))(5)ğ‘€(ğœ‡|ğ¹)=ğ‘¢(ğœ‡)+/u1D45A/u1D44E/u1D465(/u1D45B(/u1D44F))/summationdisplay.1/u1D456=0,/u1D456(ğ¹)/u1D441(,/u1D45D/u1D456(ğ¹),/u1D456(ğ¹)/u1D459/u1D45C/u1D454,/u1D45D/u1D456(ğ¹),/u1D456(ğ¹)+,/u1D45D/u1D456(ğ¹),/u1D456(ğ¹)/u1D459/u1D45C/u1D454,/u1D45D/u1D456(ğ¹),/u1D456(ğ¹))(6)The mutual information/u1D43C(ğ‘‹|ğ‘Œ)quanti/f_ies the â€œamount of infor-mationâ€ obtained about a crash through observing the presenceof basic blockğ‘Œ. In plain English, it represents the contribution ofbasic blockğ‘Œto the crash.Mutual information with threshold.As can be seen from Equa-tion(6), the amount of â€œcrash relevanceâ€ is related to/u1D45A/u1D44E/u1D465(ğµ(ğ‘Œ))and the statistics ofğ‘Œsuch as/u1D450/u1D456(ğ‘Œ)and/u1D450ğ‘‚/u1D456(ğ‘Œ). Its value can varyaccording to diï¬€erent/u1D45A/u1D44E/u1D465(ğµ(ğ‘Œ)). To fairly compare the amount ofinformation for the basic blocks with diï¬€erent occurrence in the ex-ecution traces, we use a threshold that is automatically-determinedand turn the problem into a binary classi/f_ication problem (i.e.,occurrence is smaller than or larger than a threshold): assumewe have a threshold variable/u1D461/uni210E/u1D451whose value is a non-negativeinteger with/u1D461/uni210E/u1D451âˆˆ[0,/u1D45A/u1D44E/u1D465(ğµ(ğ‘Œ))). Given the threshold variable,ğ‘‚(ğ‘‹|ğ‘Œ)can be the addition ofğ‘‚(ğ‘‹|ğ‘Œ|/u1D45B(/u1D44F)â‰¤/u1D461/uni210E/u1D451)andğ‘‚(ğ‘‹|ğ‘Œ|/u1D45B(/u1D44F)>/u1D461/uni210E/u1D451),where:ğ‘‚(ğ‘‹|ğ‘Œ|/u1D45B(/u1D44F)â‰¤/u1D461/uni210E/u1D451)=âˆ’/summationtext.1./uni210E/u1D451/u1D456=0/u1D450ğ‘‚/u1D456(ğ‘Œ)/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ),/u1D45C.(/summationtext.1./uni210E/u1D451/u1D456=0/u1D450ğ‘‚/u1D456(ğ‘Œ)/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ))âˆ’/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D453/u1D456(ğ‘Œ)/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ),/u1D45C.(/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D453/u1D456(ğ‘Œ)/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ))(7)ğ‘‚(ğ‘‹|ğ‘Œ|/u1D45B(/u1D44F)>/u1D461/uni210E/u1D451)=âˆ’/summationtext.1/u1D45A/u1D44E/u1D465(ğ‘‡(ğ¹))/u1D456=./uni210E/u1D451+1/u1D450ğ‘‚/u1D456(ğ‘Œ)/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ),/u1D45C.(/summationtext.1/u1D45A/u1D44E/u1D465(ğ‘‡(ğ¹))/u1D456=./uni210E/u1D451+1/u1D450ğ‘‚/u1D456(ğ‘Œ)/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ))âˆ’/summationtext.1/u1D45A/u1D44E/u1D465(ğ‘‡(ğ¹))/u1D456=./uni210E/u1D451+1/u1D450/u1D453/u1D456(ğ‘Œ)/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ),/u1D45C.(/summationtext.1/u1D45A/u1D44E/u1D465(ğ‘‡(ğ¹))/u1D456=./uni210E/u1D451+1/u1D450/u1D453/u1D456(ğ‘Œ)/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ))(8)Combining Equation(1), Equation(5), Equation(7)and Equation(8), we have:/u1D43C(ğ‘‹|ğ‘Œ,/u1D461/uni210E/u1D451)=ğ‘‚(ğ‘‹)âˆ’/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ)ğ´ğ‘‚(ğ‘‹|ğ‘Œ|/u1D45B(/u1D44F)â‰¤/u1D461/uni210E/u1D451)âˆ’/summationtext.1/u1D45A/u1D44E/u1D465(ğ‘‡(ğ¹))/u1D456=./uni210E/u1D451+1/u1D450/u1D456(ğ‘Œ)ğ´ğ‘‚(ğ‘‹|ğ‘Œ|/u1D45B(/u1D44F)>/u1D461/uni210E/u1D451)(9)By iterating through[0,/u1D45A/u1D44E/u1D465(ğµ(ğ‘Œ))), we can determine the/u1D461/uni210E/u1D451that maximizes/u1D43C(ğ‘‹|ğ‘Œ):Ë†/u1D461/uni210E/u1D451=/u1D44E/u1D45F./u1D45A/u1D44E/u1D465./uni210E/u1D451âˆˆ[0,/u1D45A/u1D44E/u1D465(ğ‘‡(ğ¹))/u1D43C(ğ‘‹|ğ‘Œ,/u1D461/uni210E/u1D451)(10)In the execution trace, when the occurrence of a basic blockğ‘Œis larger thanË†/u1D461/uni210E/u1D451, the basic block has close relevance to labelğ‘‹. InEquation 10,/u1D43C(ğ‘‹|ğ‘Œ,Ë†/u1D461/uni210E/u1D451)represents the degree of â€œcrash relevanceâ€.Filtering of basic blocks withğ‘‹= 0.A criterion basic block isa basic block that is closely related to the crash (i.e., whenğ‘‹=1)and has high value of mutual information. Such a criterion basicblock (or a set of criterion basic blocks) is used as the criterion inthe subsequent crash grouping procedure. From the above analysis,we know that/u1D43C(ğ‘‹|ğ‘Œ,Ë†/u1D461/uni210E/u1D451)represents the contribution of basic blockğ‘Œto labelğ‘‹.H o w e v e r ,t h i sr e p resentation does not diï¬€erentiatewhether the contribution is related to normal program exit (i.e.,whenğ‘‹=0) or program crash (i.e., whenğ‘‹=1). Namely, using thebasic blocks whose/u1D43C(ğ‘‹|ğ‘Œ,Ë†/u1D461/uni210E/u1D451)is large and related toğ‘‹=0 wouldcause false negatives in crash deduplication. When the occurrenceofğ‘Œis larger than the threshold (i.e.,ğµ(ğ‘Œ)>Ë†/u1D461/uni210E/u1D451) and the numberof â€œnormal exitâ€ samples is larger than the number of â€œcrashingsamplesâ€, it indicates that, with such a basic block, the program isprone to exit normally. Therefore, we need to/f_ilter out the basicblocks that have a large/u1D43C(ğ‘‹|ğ‘Œ,Ë†/u1D461/uni210E/u1D451)and are closely related to normalprogram exit, and select criterion basic blocks from the rest. Thedetailed algorithm of/f_iltering of basic blocks withğ‘‹=0 is shown inAlgorithm 1.Algorithm 1Filtering of Basic Blocks withğ‘‹=0Require:ğ¹â†input basic blockË†./uni210E/u1D451â†threshold ofğ¹/u1D45A/u1D44E/u1D465(ğ‘‡(ğ¹))â†the maximum occurrence ofğ¹in the dataset,/u1D45D/u1D456(ğ¹)â†the amount of â€œnormal exitâ€ samples when occurrence ofğ¹is/u1D456,/u1D453/u1D456(ğ¹)â†the amount of â€œcrashingâ€ samples when occurrence ofğ¹is/u1D456/u1D441/u1D45Dâ†the amount of â€œnormal exitâ€ samples in the dataset/u1D441/u1D453â†the amount of â€œcrashingâ€ samples in the datasetEnsure:whether to considerğ¹as a criterion basic block1:if/summationtext.1/u1D45A/u1D44E/u1D465(/u1D45B(/u1D44F))/u1D456=Ë†/u1D461/uni210E/u1D451+1/u1D450/u1D45D/u1D456(/u1D44F)/u1D441/u1D45D>/summationtext.1/u1D45A/u1D44E/u1D465(/u1D45B(/u1D44F))/u1D456=Ë†/u1D461/uni210E/u1D451+1/u1D450/u1D453/u1D456(/u1D44F)/u1D441/u1D453then2:returnFalse3:else4:returnTrue5:end if3.2 Attention Mechanism of Neural NetworksThe attention mechanism was initially proposed to improve the/f_itting of neural networks by assigning diï¬€erent weights to the inputsequence and minimizing the loss function [13]. In recent years, aline of research [8,21,24,45] leveraged the attention mechanismfor the interpretability of neural networks, allowing us to inspectthe internal working of neural networks directly. The hypothesis isthat the magnitude of attention weights positively correlates withhow relevant a speci/f_ic input region is for predicting output at eachposition in a sequence. It can be easily accomplished by visualizingthe attention weights for a set of input and output pairs. In thispaper, we borrow this idea and leverage the attention mechanismto identify the root cause of program crash by weighing each inputbasic blockâ€™s contribution to the crash.638Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. As discussed, the idea of attention mechanism is straightforward.For an input vector(/vec/u1D4651,/vec/u1D4652,. . . ,/vec/u1D465ğ‘‡), suppose we have:/vec/u1D463=/u1D6FC1/vec/u1D4651+/u1D6FC2/vec/u1D4652+...+/u1D6FCğ‘‡/vec/u1D465ğ‘‡/u1D44Eğµ/u1D451 ğ‘‹=/u1D453(/vec/u1D463),/u1D464/uni210E/u1D452/u1D45F/u1D452/summationdisplay.1/u1D456/u1D6FC/u1D456=1,/u1D6FC/u1D456>0.(11)To functionğ‘‹=/u1D453(/vec/u1D465),/u1D6FC/u1D456can be regarded as the contribution thatinput byte/u1D465/u1D456makes toğ‘‹, where(/u1D6FC1,/u1D6FC2,. . . ,/u1D6FCğ‘‡)is also known asa weighted vector. Such a functionğ‘‹=/u1D453(/vec/u1D465)is often utilized todetermine the in/f_luence of input bytes to the output in seq2seqnetworks. The transition equation is as follows:/vec/u1D6FC=.(/vec/u1D465;/vec/u1D703),/vec/u1D463=/u1D6FC1/vec/u1D4651+/u1D6FC2/vec/u1D4652+...+/u1D6FCğ‘‡/vec/u1D465ğ‘‡,ğ‘‹=/u1D453(/vec/u1D463;/vec/u1D703),/u1D464/uni210E/u1D452/u1D45F/u1D452/summationdisplay.1/u1D456/u1D6FC/u1D456=1,/u1D6FC/u1D456>0(12)/vec/u1D703is the parameter to be determined in the training process. Function.(/vec/u1D465;/vec/u1D703)is used to calculate the weight vector, which is also knownas similarity function. In the dataset,/vec/u1D465/u1D456is the/u1D456th sample and/vecğ‘‹/u1D456isthe corresponding label. The loss function with mean square erroris:/u1D43F(/u1D453(/vec/u1D465,/vec/u1D703))=/summationdisplay.1/u1D456|/u1D453(.(/vec/u1D465/u1D456;/vec/u1D703)âŠ™/vec/u1D465/u1D456;/vec/u1D703)âˆ’ğ‘‹/u1D456|2,/u1D460./u1D461./summationdisplay.1.(/vec/u1D465/u1D456;/u1D703)=1(13)However, when using the gradient descent method to minimizeloss/u1D43F(/u1D453(/vec/u1D465,/vec/u1D703)), it is diï¬ƒcult to satisfy the constraint/summationtext.1.(/vec/u1D465/u1D456;/u1D703)=1and get/vec/u1D703. Therefore,so/f_tmaxfunction is adopted as the activationfunction of.(/vec/u1D465,/vec/u1D703)in the design of networks, given that the sumofso/f_tmaxfunctionâ€™s output equals to 1. The transition equationwithso/f_tmaxbecomes:/vec/u1D6FC=so/f_tmax(.(/vec/u1D465;/vec/u1D703)),/vec/u1D463=/u1D6FC1/vec/u1D4651+/u1D6FC2/vec/u1D4652+...+/u1D6FCğ‘‡/vec/u1D465ğ‘‡,ğ‘‹=/u1D453(/vec/u1D463;/vec/u1D703),so/f_tmax(/u1D465/u1D456)=/u1D452/u1D465/u1D456/summationtext.1/u1D457/u1D452/u1D465/u1D457(14)And the loss function becomes:/u1D43F(/vec/u1D703)=/summationdisplay.1/u1D456|/u1D453(so/f_tmax(.(/vec/u1D465/u1D456;/vec/u1D703))âŠ™/vec/u1D465/u1D456;/vec/u1D703))âˆ’ğ‘‹/u1D456|2(15)The network that we designed (as described in Section 4.3) followsthe above transition equation. In fact, Equation(14)is the corearchitecture of the attention mechanism and such an architecturecan be used to determine the relevance of the input bytes and theoutput. In particular, under this architecture, we are able to getthe/vec/u1D703by minimizing/u1D43F(/u1D453(/vec/u1D465,/vec/u1D703))with the gradient descent. Function.(/vec/u1D465;/vec/u1D703)or/u1D453(/vec/u1D465;/vec/u1D703)could be convolutional neural networks (CNN),recurrent neural networks (RNN) or fully connected networks.While in seq2seq networks,.(/vec/u1D465;/vec/u1D703)is LSTM and/u1D453(/vec/u1D465;/vec/u1D703)is a fullyconnected network.4 DESIGN OFDEFAULTThe high-level design of our system is illustrated in Figure 1. Theinput is a set of crashing execution traces produced by fuzzers.Those traces are fed into the crash deduplication module, whichbuckets crashing traces into multiple categories according to theirroot cause and outputs one representative crashing trace with aunique root cause from each category. Then the representativecrashing trace of each category is sent to the/f_iltering module,which consists of two/f_iltering steps â€“ function/f_iltering and basicblock/f_iltering. It/f_ilters out the vast majority of functions and basicblocks in the trace that are irrelevant to the crash, so that the neuralnetwork in the subsequent module can take the shortened tracesas its inputs. In the end, the fault localization module leverages theattention mechanism to identify a set of basic blocks that contributeto the crash.4.1 Crash DeduplicationThere are two steps for crash deduplication:/f_irst, we group crashingtraces into multiple groups based on the calculated mutual infor-mation of basic blocks; then, we select a representative crashingtrace from each group. The root cause of the selected representativecrashes is diï¬€erent from each other2.Grouping.Assume that the root cause of crashing trace/u1D447/u1D434includesbasic blockğ‘Œ/u1D434, andğ‘Œ/u1D434is not included in crashing trace/u1D447/u1D435. Thus,we can put those two traces into two groups: one group containstraces withğ‘Œ/u1D434, and the other contains traces withoutğ‘Œ/u1D434. Motivatedby that, we separate the dataset into two groups: Group/u1D43A/u1D434is theset of crashing traces with basic blockË†ğ‘Œ; the other group/u1D43A/u1D435theset of crashing traces without basic blockË†ğ‘Œ. The basic blockË†ğ‘Œhasthe highest/u1D43C(ğ‘‹|ğ‘Œ,Ë†/u1D461/uni210E/u1D451)in the datasetğ‘¢, which is believed to have asigni/f_icant contribution to a speci/f_ic crash.We repeat the above grouping step for group/u1D43A/u1D435until there isno crashing trace left. After such a preliminary grouping process,most of the crashing traces in a group have the same root cause.Since the traces with diï¬€erent basic block statistics could becategorized into diï¬€erent groups, such a grouping algorithm givesfalse positives. Nevertheless, it gives no false negatives. For instance,assume that basic blockğ‘Œ,in trace/u1D447/u1D436and basic blockğ‘Œ/u1D451in trace/u1D447/u1D437are relevant to the same root cause (namely, trace/u1D447/u1D436and trace/u1D447/u1D437share the same root cause), butğ‘Œ,andğ‘Œ/u1D451have diï¬€erent occurrences.This happens when the root cause leads to diï¬€erent crashing pointsin the program. As a result, our algorithm would put trace/u1D447/u1D436andtrace/u1D447/u1D437into two diï¬€erent groups. Fortunately, although moregroups are produced than the ground truth, the over-categorizationwould not miss any root cause of the crashing traces produced byfuzzers. We show the complete grouping algorithm in Algorithm 2.Selecting representative crashing traces.Within a group, whena crashing trace contains a criterion basic blockË†ğ‘Œand another basicblockğ‘Œ1which is the root cause of another unique crash, thiscrashing trace cannot represent this group. It would lead to falsepositives and false negatives in subsequent steps. Therefore, torepresent this group, we need to select a crashing trace, whose root-cause basic blocks only include a criterion basic blockË†ğ‘Œ, without2Our approach does not guarantee that the crash de-duplication module gives uniquecrashes. We only found that there are no false negatives in the evaluation.639Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. &UDVK'H'XSOLFDWLRQ0RGXOH&UDVK&UDVK&UDVK8QLTXH&UDVKÄÄÄ8QLTXH&UDVK5HSUHVHQWDWLYH&UDVKLQJ7UDFH)LOWHULQJ0RGXOH&UDVKÄÄÄ8QLTXH&UDVKÄÄÄ1HXUDO1HWZRUN0RGXOH6KRUWHQHG&UDVKLQJ7UDFH5RRW&DXVH)X]]LQJ,QIUDVWUXFWXUHÄÄÄFigure 1: Overall design ofD/e.scF/a.sc/u.sc$%.Algorithm 2Mutual Information-based GroupingRequire:B/u1D453â†set of crashing tracesB,B/u1D45Dâ†set of non-crashing tracesBEnsure:CCâ†set of grouped crashing traces,criterionâ†set of criterionbasic block of each group1:CCâ†[]2:criterionâ†[]3:Dâ†(<B/u1D453,1>)((<B/u1D45D,0>)4:calculate mutual information for each basic block inD5:selectğ¹that is related toğœ‡=1 and has the largest mutual informationvalue6:if/summationtext.1Ë†/u1D461/uni210E/u1D451/u1D456,/u1D453/u1D456(ğ¹)==0then7:CC./u1D44Eğ‘‚ğ‘‚/u1D452ğ‘‡/u1D451(/u1D435/u1D453)8:criterion./u1D44Eğ‘‚ğ‘‚/u1D452ğ‘‡/u1D451(ğ¹)9:returnCC,criterion10:else11:ğ‘‡/u1D452/u1D464B/u1D453â†{B|BâˆˆB/u1D453,ğ¹âˆˆB,ğ‘‡(ğ¹)>Ë†./uni210E/u1D451}12:CC./u1D44Eğ‘‚ğ‘‚/u1D452ğ‘‡/u1D451(B/u1D453)13:criterion./u1D44Eğ‘‚ğ‘‚/u1D452ğ‘‡/u1D451(ğ¹)14:B/u1D453â†{B|B/uni2209ğ‘‡/u1D452/u1D464B/u1D453,BâˆˆB/u1D453}15:goto line 316:end ifthe basic blocks of other unique crashes. To this aim, we rank thecrashing traces within a group, according to the occurrence of allcriterion basic blocks. A crashing trace obtains higher score if it hasmore occurrences of criteria basic blocks. In the end, we select thecrashing trace with the least score to represent its group, meaningthat the crashing trace is more â€œpureâ€. The algorithm is describedin Algorithm 3.4.2 FilteringOnce the representative crashing trace is selected, the/f_ilteringmodule (shown in Figure 2) performs preliminary/f_iltering to/f_ilterout functions and basic blocks irrelevant to the crash. It can vastlyshorten the length of crashing traces and facilitate the neuralnetwork module to process the shortened traces.Constructing Datasets.To cover more basic blocks and compre-hensively assess how the executions of diï¬€erent basic blocks aï¬€ecta crash, we construct a dataset that is bred from a unique crashingtrace. We use a/f_l-fuzz to mutate a single crashing input and breedAlgorithm 3Selection of Representative Crashing TraceRequire:CCâ†groups of crashing traces,Criterionâ†the set of criterionbasic blocksEnsure:Uniqueâ†the set of crashing traces after selection1:Uniqueâ†[]2:/u1D446,/u1D45C/u1D45F/u1D452â†score dictionary3:for/u1D435âˆˆCCdo4:forğ¹âˆˆ/u1D435do5:for.âˆˆCriteriondo6:if.âˆˆğ¹&&ğ‘‡(.)>Ë†./uni210E/u1D451then7:/u1D446,/u1D45C/u1D45F/u1D452[ğ¹]â†/u1D446,/u1D45C/u1D45F/u1D452[ğ¹]+18:end if9:end for10:end for11:ğ¹â†/u1D45A/u1D456ğ‘‡(/u1D446,/u1D45C/u1D45F/u1D452[{ğ¹|ğ¹âˆˆ/u1D435}])12:Unique./u1D44Eğ‘‚ğ‘‚/u1D452ğ‘‡/u1D451(ğ¹)13:end for14:returnUniqueinputs that explore diï¬€erent basic blocks. The output of a/f_l-fuzzcan be categorized into crashing inputs and non-crashing inputs.Note that in extreme cases, for example, when a/f_l-fuzz triggers newcrashes, the follow-up procedures would not be aï¬€ected. The non-crashing inputs are obtained by randomly mutating the crashinginputs. In this way, a large portion of the basic blocks in crashingtraces would also appear in the non-crashing trace, and those basicblocks are not related to the crash. Consequently, in the dataset, thestatistics of those overlapped basic blocks are signi/f_icantly diï¬€erentfrom the statistics of the crash-related basic blocks. It helps toform a dataset with diï¬€erentiable and adequate samples. Note thatthis dataset also serves for the training of the neural network inSection 4.3.Filtering out irrelevant functions.In the program, there existsome low-level functions like data copy functions, operationfunctions of linked lists, and constructors/destructors of structsor objects. When those functions are invoked near the root cause,the mutual information of those functionsâ€™ basic blocks would bevery close to the mutual information of the actual root cause, whichbrings false positives to the results. Therefore, we calculate mutual640Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. IXQFIXQFIXQFÄÄÄIXQFQIXQFRFFXU7UDFHDWIXQFWLRQOHYHO/DEHOV&DOFXODWLRQRI0XWXDO,QIR7UDFHDWEDVLFEORFNOHYHOEEEEEEÄÄÄEEQEERFFXU/DEHOV&DOFXODWLRQRI0XWXDO,QIR5HVWRUH7UDFH)RUP
5HVWRUH7UDFH)RUP6KRUWHQHGH[HFXWLRQWUDFHFigure 2: Illustration of/f_iltering.information at the function level to/f_ilter out the irrelevant functionsto the actual root cause.The dataset is composed of execution traces at function levelwith their corresponding labels:D=<F,Y>. In the dataset,/u1D439/u1D456is the/u1D456th trace ofFwhere/u1D439=(/u1D4531,/u1D4532,. . . ,/u1D453/u1D441/u1D453)is a sequence offunctions in that trace andğ‘‹/u1D456represents whether the executiontrace corresponds to a crash. We calculate the mutual informationof function/u1D453/u1D456to labelğ‘‹, to represent/u1D453/u1D456â€™s contribution to labelğ‘‹:/u1D43C(ğ‘‹|/u1D453/u1D457,Ë†/u1D461/uni210E/u1D451)=ğ‘‚(ğ‘‹)âˆ’/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(/u1D453/u1D457)ğ´ğ‘‚(ğ‘‹|/u1D453/u1D457|/u1D45B(/u1D453/u1D457)â‰¤Ë†/u1D461/uni210E/u1D451)âˆ’/summationtext.1/u1D45A/u1D44E/u1D465(ğ‘‡(/u1D453/u1D457))/u1D456=./uni210E/u1D451+1/u1D450/u1D456(/u1D453/u1D457)ğ´ğ‘‚(ğ‘‹|/u1D453/u1D457|ğ‘‡(/u1D453/u1D457)>Ë†./uni210E/u1D451)(16)whereğ´is the amount of samples in the dataset,ğ‘‚(/u1D44C)is theentropy of labelğ‘‹,/u1D450/u1D456(/u1D453/u1D457)is the amount of samples where/u1D453/u1D457â€™soccurrence is/u1D456,ğ‘‚(ğ‘‹|/u1D465)is the conditional entropy, andË†/u1D461/uni210E/u1D451is:Ë†/u1D461/uni210E/u1D451=/u1D44E/u1D45F./u1D45A/u1D44E/u1D465./uni210E/u1D451âˆˆ[0,/u1D45A/u1D44E/u1D465(ğ‘‡(/u1D453/u1D457))/u1D43C(ğ‘‹|/u1D453/u1D457,/u1D461/uni210E/u1D451)(17)After/f_iltering, function/u1D453/u1D456â€™s contribution to labelğ‘‹can beregarded as/u1D45F=ğ‘€(ğœ‡|/u1D453/u1D456,Ë†./uni210E/u1D451)/ğ‘¢(ğœ‡)with/u1D45Fâˆˆ(0,1], where/u1D43C(ğ‘‹|/u1D453/u1D457,Ë†/u1D461/uni210E/u1D451)is the mutual information andğ‘‚(ğ‘‹)is the entropy of labelğ‘‹. When/u1D45F=1, we can infer that an execution trace is a crashing trace byobserving that/u1D453/u1D456appears in the trace. Similarly, when/u1D45Fapproaches0, the (non-)existence of/u1D453/u1D456has little impact on whether an executiontrace is a crashing trace or not. Therefore, we/f_ilter out the functionswhose/u1D45Fis smaller than 0.53and obtain the traces with selected3The/f_iltering threshold/u1D45Fis empirically set to 0.5. We found that the following modulesproduced satisfactory results with this value.functions:/u1D439/u1D460={/u1D453|/u1D453âˆˆ/u1D439,/u1D43C(ğ‘‹|/u1D453,Ë†/u1D461/uni210E/u1D451)ğ‘‚(ğ‘‹)>0.5}(18)Filtering out irrelevant basic blocks.After the/f_iltering ofirrelevant functions, the next step is to/f_ilter out irrelevant basicblocks. We denote the dataset asD=<B,Y>, whereğµis theamount of samples,B={B1,B2,. . . ,Bğ‘‡}is a set of execution tracesat basic block level, andY={ğ‘‹1,ğ‘‹2,. . . ,ğ‘‹ğ‘‡}is the set of labels forthe execution traces. After the/f_iltering of irrelevant functions in thedataset, the/f_iltered execution trace becomes/u1D435/u1D45F=(ğ‘Œ/u1D45F1,ğ‘Œ/u1D45F2,. . . ,ğ‘Œ/u1D45F/u1D45B),whereğ‘Œ/u1D45F/u1D456is a basic block. By calculating the mutual information ofğ‘Œ/u1D45F/u1D457to labelğ‘‹=0, we can select the set of basic blocks that contributemore to the crash. The mutual information of basic blockğ‘Œ/u1D45F/u1D457tolabelğ‘‹is given by:/u1D43C(ğ‘‹|ğ‘Œ/u1D45F/u1D457,Ë†/u1D461/uni210E/u1D451)=ğ‘‚(ğ‘‹)âˆ’/summationtext.1./uni210E/u1D451/u1D456=0/u1D450/u1D456(ğ‘Œ/u1D45F/u1D457)ğ´ğ‘‚(ğ‘‹|ğ‘Œ/u1D45F/u1D457|/u1D45B(/u1D44F/u1D45F/u1D457)â‰¤Ë†/u1D461/uni210E/u1D451)âˆ’/summationtext.1/u1D45A/u1D44E/u1D465(ğ‘‡(ğ¹/u1D45F/u1D457))/u1D456=./uni210E/u1D451+1/u1D450/u1D456(ğ‘Œ/u1D45F/u1D457)ğ´ğ‘‚(ğ‘‹|ğ‘Œ/u1D45F/u1D457|ğ‘‡(ğ¹/u1D45F/u1D457)>Ë†./uni210E/u1D451)(19)whereË†/u1D461/uni210E/u1D451is:Ë†/u1D461/uni210E/u1D451=/u1D44E/u1D45F./u1D45A/u1D44E/u1D465./uni210E/u1D451âˆˆ[0,/u1D45A/u1D44E/u1D465(ğ‘‡(ğ¹/u1D45F/u1D457))/u1D43C(ğ‘‹|ğ‘Œ/u1D45F/u1D457,/u1D461/uni210E/u1D451)(20)We then/f_ilter out the basic block that are closely related tolabelğ‘‹=0. Similar to function/f_iltering, we calculate the ratio/u1D45F=ğ‘€(ğœ‡|ğ¹/u1D45F/u1D457,Ë†./uni210E/u1D451)/ğ‘¢(ğœ‡)and/f_ilter out basic block whose/u1D45Fis less than0.8. The/u1D45Fvalue is set higher than the/u1D45Fof function/f_iltering becausethe selection on basic blocks is more/f_ine-grained. In the end, weobtain the trace with selected basic blocks:/u1D435/u1D463=(ğ‘Œ/u1D4631,ğ‘Œ/u1D4632,. . . ,ğ‘Œ/u1D463/u1D441/u1D463)where:ğ‘Œ/u1D463={ğ‘Œ|ğ‘Œâˆˆ/u1D435/u1D45F,/u1D43C(ğ‘‹|ğ‘Œ/u1D45F/u1D457,Ë†/u1D461/uni210E/u1D451)ğ‘‚(/u1D44C)>0.8}(21)4.3 Fault LocalizationAfter/f_iltering irrelevant functions and basic blocks, the size oftraces has been largely reduced, which becomes suitable to feedneural networks. In the fault localization module, we leverage theneural network to identify the root causeâ€™s basic blocks. The basicblocks in the short traces have a high value of mutual informationto labelğ‘‹=1. However, so far, they still cannot be regarded as theroot cause because some basic blocks that are not the root causebut near the root cause also get high mutual information values.The fundamental cause is that basic blocksâ€™ statistical informationdoes not contain sequence information in its execution trace. Withall existing approaches fail to recover the sequence information inexecution traces, especially when handling the dependence in longsequences, we leverage LSTM with the attention mechanism tomodel and capture the sequence information about the root cause.More speci/f_ically, we have the datasetD=<B/u1D463,Y>, whereB/u1D463isthe set of execution traces composed of sequences of selected basicblocks andYis the set of corresponding labels. This module utilizesthe neural network to calculate the relevance score of each basicblock to the crash. The root cause is the basic blocks that contributeto the crash, which is indicated by the relevance score (i.e., the641Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. higher relevance score of a basic block indicates more contributionto the crash).Input and output of neural network.The data used for trainingthe network are the shortened basic blocks. The positive samplesare the shortened crashing traces and negative samples are theshortened non-crashing traces. We use one-hot vectors to encodethe input: denoting the number of basic blockğ‘Œ/u1D463/u1D456in trace/u1D435/u1D463asğµğ¹.Then basic blockğ‘Œ/u1D463/u1D456âˆˆ/u1D435/u1D463is represented as/vec/u1D465/u1D456with/vec/u1D465/u1D456={0,1}ğ‘‡/u1D44Fand/summationtext.1ğ‘‡/u1D44F/u1D457=0|/u1D465/u1D456/u1D457|2=1. The input is/vec/u1D44B=(/vec/u1D4651,/vec/u1D4652,. . . ,/vec/u1D465ğ‘‡). Since thelength of the input varies, we choose the longest/u1D435/u1D463as the inputlength and pad the short inputs with zero vectors whose magnitudeisğµğ¹. Every basic block is independent with each other in the input.The sequence information about root cause among basic blocksneeds to be recovered through weight assignment of the neuralnetwork. The output of neural network is the boolean value thatrepresents whether a crash is triggered or not. Besides, we usethe up-sampling [4] to balance the negative samples and positivesamples in the dataset.Network structure.The network structure is the classic LSTMnetwork with attention mechanism. After one-hot encoding, wesend execution trace/u1D435/u1D463to the LSTM network, the output of theLSTM network is:/u1D45C/u1D43F/u1D446/u1D447/u1D440/u1D456=/u1D453/u1D43F/u1D446/u1D447/u1D440(/vec/u1D465/u1D456,/u1D45C/u1D43F/u1D446/u1D447 /u1D440/u1D456âˆ’1). In the output of theLSTM network, the/u1D456th element is related to all the previous/u1D456âˆ’1elements. We then send/vec/u1D45C/u1D43F/u1D446/u1D447 /u1D440to the/u1D460/u1D45C/u1D453 /u1D461/u1D45A/u1D44E/u1D465layer, and get:/u1D6FC/u1D456=/u1D452/u1D45C/u1D43F/u1D446/u1D447 /u1D440/u1D456/summationtext.1ğ‘‡/u1D457=0/u1D452/u1D45C/u1D43F/u1D446/u1D447 /u1D440/u1D457(22)In the end, we multiply vectors/vec/u1D6FCand/vec/u1D44Bin the fully-connectedlayers and get the/f_inal output:/u1D45C/u1D462/u1D461/u1D45D/u1D462/u1D461=/u1D453/u1D451/u1D452ğ‘‡/u1D460/u1D452(/vec/u1D463)/vec/u1D463=/u1D6FC1)/vec/u1D4651+/u1D6FC2)/vec/u1D4652+...+/u1D6FCğ‘‡)/vec/u1D465ğ‘‡,(23)In the/u1D460/u1D45C/u1D453 /u1D461/u1D45A/u1D44E/u1D465layer, we have/summationtext.1/u1D456/u1D6FC/u1D456=1 and/u1D6FC/u1D456>0. Also ,theoutput is of the formğ‘‹=/u1D453(/u1D6FC1)/u1D4651+/u1D6FC2)/u1D4652+...+/u1D6FCğ‘‡)/u1D465ğ‘‡). Thus,/vec/u1D6FCis the relevance score vector (i.e., the weight vector), and/u1D6FC/u1D465/u1D456represents the contribution of/u1D465/u1D456to the outputğ‘‹.Calculation of relevance score.After network training, we getthe relevance score vector/vec/u1D6FC/u1D456for positive sample/u1D435/u1D463ğ‘‚/u1D456in the dataset.The relevance score of basic blockğ‘Œ/u1D463/u1D457in/u1D435/u1D463ğ‘‚/u1D456is/u1D45F/u1D457=/summationtext.1/u1D456/u1D6FC/u1D456/u1D463/u1D457. For allthe basic blocks in the positive samples, we need to categorize theminto two groups: one group includes basic blocks that are believedto be the root cause; the other group includes the rest of the basicblocks. The criterion for categorization is that, in each group, thevariance of relevance scores of basic blocks is the smallest. Thedetailed algorithm is described in Algorithm 4.5 EVALUATIONWe implemented a full-featured prototype ofD/e.scF/a.sc/u.sc$%. To evaluateits eï¬ƒcacy and performance, we conducted comprehensive real-world experiments. In this section, we present and discuss thecorresponding experiment results.Algorithm 4Selection of Root-Cause Basic BlocksRequire:/u1D45F/u1D457â†relevance score of basic blockğ¹/u1D463/u1D457ğ‘‡â†amount of basic blocks/u1D707â†varianceEnsure:/u1D460,/u1D45C/u1D45F/u1D452â†threshold of relevance score1:/u1D460/u1D45C/u1D45F.(/vec/u1D45F)2:/u1D45A/u1D456ğ‘‡â†/u1D707(/u1D45F0)+/u1D707(/u1D45F1,. . ,/u1D45F/u1D45Bâˆ’1)3:/u1D460,/u1D45C/u1D45F/u1D452â†/u1D45F04:for/u1D456âˆˆ[0,n)do5:./u1D45Ağ‘‚â†/u1D707(/u1D45F0,. . ,/u1D45F/u1D456)+/u1D707(/u1D45F/u1D456+1,. . ,/u1D45F/u1D45Bâˆ’1)6:if./u1D45Ağ‘‚</u1D45A/u1D456ğ‘‡then7:/u1D45A/u1D456ğ‘‡â†./u1D45Ağ‘‚8:/u1D460,/u1D45C/u1D45F/u1D452â†/u1D45F/u1D4579:end if10:end for5.1 Experimental SettingTarget programs and testing environment.We evaluated ourtool with 20 programs, including 8 CGC programs and 12 real-world programs. To reasonably choose the programs, we selectthe programs that have known crashes4and belong to diï¬€erentsoftware categories from the CGC program repositories and theCVE list, without examining the details of crash and programinternals. The functionalities of the programs include imageprocessing, document parsing, compilation, and audio processing.The experiments run in Ubuntu 18.04, with Intel i9 7900X, 48GBDDR4, and RTX 2080Ti (11GB VRAM). The version of AFL is 2.52b.TensorFlow and Keras are used for neural network training.Triggering crashes.The crashing inputs are produced with a/f_l-fuzz. With suï¬ƒcient fuzzing time (one week), a/f_l-fuzz reproducedcrashes in all 8 CGC programs that weselected. However, wealso selected 16 real-world programs, and a/f_l-fuzz only reproducedcrashes in 12 of them (with some initial seed inputs). On average,each program contains 2.15 faults. After fuzzing, the averageamount of crashes is 516.6 for each program fault.Neural network setup.The parameter of the neural network,LSTM (256 units) with attention mechanism. The mean squareerror is used as the loss function, and the Adam optimizer is usedwith an initial learning rate 10âˆ’6. We stop the training when the/f_itting rate becomes 99% or when the iteration round reaches 100.Ground truth.To obtain the ground truth, we manually inspecteach crashing trace backward from the crashing point to the rootcause and record the crashing point (one single basic block) andthe root cause (multiple basic blocks), by debugging and reverseengineering. Speci/f_ically, For crash de-duplication, we used scriptsto determine whether a crashing input would satisfy the constraints(that we manually written after examining the root cause) to triggerthe bug. For fault localization, we manually determined the root-cause basic blocks after manual inspection. The root causes of CGCprograms are publicly available. For the real-world buggy software,we also refer to the bug report from the CVE reference. If the rootcause of two diï¬€erent crashing traces is equivalent, we categorizethem into the same group, no matter how diverse are their crashingpoints.4For real-world programs, the crashes have been/f_ixed in new versions.642Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. (a) False positive rates in crash deduplication(b) Time cost in crash deduplicationFigure 3: Accuracy and performance of crash deduplication.
(a) False positive rate for fault localization(b) Time for fault localizationFigure 4: Accuracy and performance of fault localization.5.2 Crash Deduplication: Eï¬ƒcacy and AccuracyComparison with existing tools.Regarding crash deduplication,we compared our approach withSemantic Crash Bucketing(SCBfor short) [37], a/f_l-fuzzâ€™s deduplicator [49], and Honggfuzzâ€™sdeduplicator [2]. In particular, SCB achieves crash deduplication byautomatically/f_ixing bugs, which identi/f_ies crashes belonging to thesame bug. This approach is relatively accurate but only targets twotypes of bugs, namely buï¬€er over/f_lows and null pointer dereference,which is less applicable to general bugs. A/f_l-fuzzâ€™s deduplicator iscommonly used in industry. It/f_irst reduces the crashing trace usinga/f_l-tmin [1] and then calculates the hash of the crashing path. Crashbucketing is achieved by comparing the similarity of the hashes. Onthe contrary, Honggfuzzâ€™s deduplicator compares the similarity ofcall stack hashes, working at function call level. In the experiment,since a/f_l-tminâ€™s reduction on a single crashing trace introduces timeoverhead, we run a/f_l-tmin in parallel with 20 cores.False negatives.As can be seen from Table 1, there is no falsenegative given byD/e.scF/a.sc/u.sc$%. Neither SCB nor a/f_l-fuzzâ€™s dedupli-cator produces any false negatives. However, after investigatingHonggfuzzâ€™s deduplication results, we still found one case of falsenegative: in the softwarelistswf, when multiples root causes existin the same function, their execution traces are the same at thefunction level. Given that Honggfuzzâ€™s deduplication categorizescrashes based on the execution traces at the function call level, it isunable to identify and diï¬€erentiate two diï¬€erent kinds of the rootcause that occur in the same function and therefore misses somecrashes that have been triggered by the fuzzer.False positives.We show the false positive rate of all the tools inFigure 3a. Overall,D/e.scF/a.sc/u.sc$%outperforms all three tools by givingless false positives on 19 cases. SCBâ€™s high false positive rate canbe attribute to its limited support of bugs, namely buï¬€er over/f_lowsand null pointer dereference. For A/f_l-fuzzâ€™s deduplication, giventhat a/f_l-tminâ€™s reduction cannot completely remove redundantpaths and one single bug can be triggered from multiple paths,a/f_l-fuzz also gives high false positives. Similarly, when a bug can betriggered from multiple paths, the call stack hashes are also diï¬€erent.Therefore, Honggfuzzâ€™s deduplicator also gives false positives.Particularly, for case 18 and case 20 whereD/e.scF/a.sc/u.sc$%gives falsepositives, the crashes are caused by use-after-free vulnerabilities.The root cause of the vulnerabilities is typically the misuse offree()operation, while the crashing point could be large variantbased on diï¬€erent runtime memory layouts. Since the use-after-free vulnerabilities are triggered but do not cause any crashes insome positive samples, the basic blocks of root cause also appearin positive samples, which leads to low mutual information valuesand causes false positives.5.3 Crash Deduplication: PerformanceThe number of crashing trace for each program is 1110 on average.Processing 1110 traces takesD/e.scF/a.sc/u.sc$%19 seconds. With the sameworkload, SCB, a/f_l-fuzz and Honggfuzz takes 168 seconds, 595seconds and 24 seconds, respectively. The time cost ofD/e.scF/a.sc/u.sc$%isonly 11.3%, 3.1%, and 79% of that of SCB, a/f_l-fuzz and Honggfuzz,respectively.The comparison ofD/e.scF/a.sc/u.sc$%and other three toolsâ€™s time cost isshown in Figure 3b. As can be seen, to process execution traces, a/f_l-fuzzâ€™s deduplicator takes much more time thanD/e.scF/a.sc/u.sc$%. The mainreason is that a/f_l-fuzzâ€™s deduplication is based on the comparisonamong execution traces. The time cost increases exponentiallyas the amount of the traces grows, because each trace needs tobe compared with all other traces. On the contrary,D/e.scF/a.sc/u.sc$%analyzes the statistics of basic blocks, and the computation ofmutual information values only involves some of the basic blocks.The values of mutual information are stored and indexed from hashtables. As such, it takes much less time forD/e.scF/a.sc/u.sc$%.5.4 Fault Localization: Eï¬ƒcacy and AccuracyAssessment of e#ectiveness.Traditional program spectrum-based fault localization relies on the EXAM curve [17] to assesseï¬€ectiveness. A point(/u1D465,ğ‘‹)in the EXAM curve represents thesuspicious score of a basic block. However, such measurement643Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. Table 1: Overall ResultsIDProgramUniqueCrashby AFL(#)D/e.scF/a.sc/u.sc$%SCB/barex/barex/barexafl-fuzz/barex/barex/barexHonggfuzzAuroraCrash DeduplicationFault LocalizationCrash DeduplicationFault LocalizationTime(s)Groups(#)GroundTruthF.P.F.N.Time(s)BasicBlocks(#)GroundTruthF.P.F.N.Time(s)# of GroupsF.P.F.N.Time(s)BasicBlocks(#)F.P.F.N.1c/f_low44120220/01560550/0188/barex/barex/barex467/barex/barex/barex402/barex/barex/barex9/barex/barex/barex420/0/barex/barex/barex7/0/barex/barex/barex40/037205045/01680660/039005044/02mp3again32922220/02400440/0189/barex/barex/barex387/barex/barex/barex322/barex/barex/barex8/barex/barex/barex210/0/barex/barex/barex6/0/barex/barex/barex19/034205046/02460550/033005045/03jhead4088110/02160440/0179/barex/barex/barex365/barex/barex/barex121/barex/barex/barex12/barex/barex/barex320/0/barex/barex/barex11/0/barex/barex/barex31/036605046/04listswf157214550/02220651/0223/barex/barex/barex867/barex/barex/barex32117/barex/barex/barex33/barex/barex/barex12112/0/barex/barex/barex28/0/barex/barex/barex4/340205045/02220660/040805044/02280752/043205045/02220642/039005046/02280550/041405045/05GraphicsMagick76019220/02280541/0189/barex/barex/barex687/barex/barex/barex21243/barex/barex/barex21/barex/barex/barex23241/0/barex/barex/barex19/0/barex/barex/barex21/034205046/02340550/035405045/06jasper47923110/02100761/0124/barex/barex/barex398/barex/barex/barex16479/barex/barex/barex15/barex/barex/barex33478/0/barex/barex/barex14/0/barex/barex/barex32/039005044/07pdftopng(xpdf)98116110/02160550/0142/barex/barex/barex431/barex/barex/barex213/barex/barex/barex12/barex/barex/barex232/0/barex/barex/barex11/0/barex/barex/barex22/033605045/08nasm371325110/0234014122/0171/barex/barex/barex981/barex/barex/barex311/barex/barex/barex34/barex/barex/barex420/0/barex/barex/barex33/0/barex/barex/barex41/029405038/09latex2rtf178734220/02520660/0112/barex/barex/barex871/barex/barex/barex342/barex/barex/barex15/barex/barex/barex220/0/barex/barex/barex13/0/barex/barex/barex20/032405044/02280981/034805042/010mruby88743211/0264018153/0112/barex/barex/barex432/barex/barex/barex231/barex/barex/barex9/barex/barex/barex110/0/barex/barex/barex8/0/barex/barex/barex10/044405035/011tiï¬€cp(libtiï¬€)10929330/02340650/0162/barex/barex/barex562/barex/barex/barex24342/barex/barex/barex18/barex/barex/barex15339/0/barex/barex/barex15/0/barex/barex/barex12/028805045/02220642/027005046/02280660/033005044/012pdfrescurrent6828431/02520880/0184/barex/barex/barex442/barex/barex/barex17112/barex/barex/barex12/barex/barex/barex27109/0/barex/barex/barex9/0/barex/barex/barex24/039005042/02640550/038405045/02520431/037205047/013FileSys123113110/02100660/0165/barex/barex/barex872/barex/barex/barex241231/barex/barex/barex1/barex/barex/barex181230/0/barex/barex/barex0/0/barex/barex/barex17/027005044/014Street mapservice76223220/02220541/0187/barex/barex/barex365/barex/barex/barex184/barex/barex/barex3/barex/barex/barex122/0/barex/barex/barex2/0/barex/barex/barex10/028805046/02160862/031205044/015Kaprica ScriptInterpreter120815660/02220330/0114/barex/barex/barex762/barex/barex/barex23152/barex/barex/barex17/barex/barex/barex12146/0/barex/barex/barex11/0/barex/barex/barex5/134205047/02160440/027005046/02220660/025805044/02220990/028805041/02280440/025805046/02220330/030605047/016simple integercalculator108213440/02160660/0186/barex/barex/barex671/barex/barex/barex20365/barex/barex/barex9/barex/barex/barex22361/0/barex/barex/barex5/0/barex/barex/barex17/027005044/02160550/032405045/02100440/026405046/02220651/024605045/017CGCRPC_Server187622110/02100880/0199/barex/barex/barex812/barex/barex/barex291/barex/barex/barex2/barex/barex/barex30/0/barex/barex/barex1/0/barex/barex/barex2/027005042/018Shortest PathTree Calculator36516110/02100972/0198/barex/barex/barex231/barex/barex/barex18365/barex/barex/barex10/barex/barex/barex13364/0/barex/barex/barex9/0/barex/barex/barex12/039605043/019SOLFEDGE176324220/02220972/0167/barex/barex/barex761/barex/barex/barex33564/barex/barex/barex8/barex/barex/barex6562/0/barex/barex/barex6/0/barex/barex/barex4/032405043/021601091/029405041/020User_Manager79813220/01980862/0172/barex/barex/barex541/barex/barex/barex13798/barex/barex/barex6/barex/barex/barex11797/0/barex/barex/barex5/0/barex/barex/barex10/026405044/0does not make sense in practice, as analysts would wish a tool tooutput exact results rather than the topğµsuspiciousness rank ofthe basic blocks. For example, when the root cause is ranked 9 and10 within the top 10 suspicious basic blocks, analyzing the/f_irst8 basic blocks does not help. As such, in our evaluation, we useaccuracy and false positive rate as indicators. For a given binaryprogram and a crashing input, the number of false positives is/u1D439=ğ´/u1D462/u1D45A(/u1D442)âˆ’ğ´/u1D462/u1D45A(/u1D442âˆ©/u1D434), where/u1D442is the set of basic blocksreported byD/e.scF/a.sc/u.sc$%and/u1D434is the set of basic blocks of the rootcause. The accuracy and the false positive rate are de/f_ined as/u1D453/u1D45D=/u1D439/u1D434+100% and/u1D453ğµ=/u1D439/u1D441/u1D462/u1D45A(/u1D442)+100%, respectively.False positives.We compareD/e.scF/a.sc/u.sc$%withAurora[10], a recentwork that is based on analyzing the statistics of execution paths.Auroraoutputs top 50 basic blocks as its results of root causeidenti/f_ication. On the whole,D/e.scF/a.sc/u.sc$%demonstrates relatively lowfalse positive rates in fault localization: the average false positiverate on 42 crash cases is 9.2%. Note that no false negative occursin bothD/e.scF/a.sc/u.sc$%andAurora. Figure 4a shows the false positiverate on 42 crash cases in detail. The average number of basic blocksthat are reported as false positives is 0.7. The presence of use-after-free vulnerabilities causes false positives, but no crash is triggered.Namely, in the presence of a use-after-free vulnerability, when thereis no memory operation on the piece of memory that is freed, nocrash would be triggered. The behaviors of the root cause and thatof the crash point are the same, which causes false positives on thereported results.5.5 Fault Localization: PerformanceOn average, the time cost ofD/e.scF/a.sc/u.sc$%to locate each root cause is37 minutes. For the mutual-information-based/f_iltering, the timeconsumption is highly related to the scale of execution trace,including the length of execution trace and the amount of diï¬€erentbasic blocks. A longer execution trace with a large amount ofdiï¬€erent basic blocks takes more time to process. For the neuralnetwork module, the time cost is related to the size of the trainingdataset, network input size, and the number of parameters. With644Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. the attention mechanism and the high-performance GPU, trainingtime and localization time are controlled within 6.6 minutes onaverage. By that, time is mostly spent on recording execution traces.Figure 4b shows the comparison of time cost forD/e.scF/a.sc/u.sc$%andAurora.6 DISCUSSIONThe proposed approach locates root cause at control/f_low leveland relies on the sequence information of execution traces andwhether the dataset contains rich samples. As such, our approachis less eï¬€ective when execution trace is relatively short and whentriggering the vulnerability depends on data/f_lows. Fortunately, theroot cause of such vulnerabilities can be eï¬€ectively identi/f_ied withtaint analysis [52]. On the other hand,D/e.scF/a.sc/u.sc$%is not applicablewhen triggering the vulnerabilities requires to solve complicatedconstraints on their paths, especially for the programs with cryp-tographic algorithms or checksum functions. The branches withcomplicated constraints cannot be easily reached with the fuzzerâ€™ssimple mutation strategies. This results in the fact that the inputs areless explosive, which aï¬€ects the accuracy of the neural networkâ€™s/f_itting. To this end, as long as more diverse and adequate positivesamples are provided (more paths are explored), the network canassign accurate weights to each basic block. Therefore, to improvethe/f_itting accuracy, the trade-oï¬€is to spend time and suï¬ƒcientlymutate and produce samples to train the network.7 CONCLUSIONIn this paper, we have presentedD/e.scF/a.sc/u.sc$%, an end-to-end solutionfor crash triage of general programs. The core insight of our solutionis to leverage mutual information of basic blocks to represent â€œcrashrelevanceâ€. Implementing the insights also involves a set of newalgorithms. In the evaluation, we comparedD/e.scF/a.sc/u.sc$%with state-of-the-art solutions, which demonstrates considerable time eï¬ƒciencyand accuracy in both crash de-duplication and fault localization.8 ACKNOWLEDGEMENTSWe thank the anonymous reviewers for their insightful comments.Wenrui Diao was partially supported by National Natural ScienceFoundation of China (Grant No. 61902148) and Qilu Young ScholarProgram of Shandong University.REFERENCES[1]â€œamerican fuzzy lop - test case minimizer,â€ https://github.com/google/AFL/blob/master/afl-tmin.c, Accessed: Sep 2020.[2] â€œHonggfuzz,â€ https://github.com/google/honggfuzz, Accessed: Sep 2020.[3]â€œOSS-Fuzz: Continuous Fuzzing for Open Source Software,â€ https://github.com/google/oss-fuzz, Accessed: Sep 2020.[4] â€œUp-sampling,â€ https://en.wikipedia.org/wiki/Upsampling, Accessed: Sep 2020.[5]R. Abreu, P. Zoeteweij, and A. J. C. V. Gemund, â€œOn the accuracy of spectrum-based fault localization,â€ inTesting: Academic and Industrial Conference Practiceand Research Techniques-mutation, 2007.[6] H. Agrawal and J. R. Horgan,Dynamic program slicing, 1990.[7]H. Agrawal, J. R. Horgan, S. London, and W. E. Wong, â€œFault localizationusing execution slices and data/f_low tests,â€ inProceedings of Sixth InternationalSymposium on Software Reliability Engineering. ISSREâ€™95, 2002.[8]D. Bahdanau, K. Cho, and Y. Bengio, â€œNeural machine translation by jointlylearning to align and translate,â€arXiv preprint arXiv:1409.0473, 2014.[9]K. Bartz, J. W. Stokes, J. C. Platt, R. Kivett, and G. Loihle, â€œFinding similar failuresusing callstack similarity,â€ inThird Workshop on Tackling Computer SystemsProblems with Machine Learning Techniques, SysML 2008, December 11, 2008, SanDiego, CA, USA, Proceedings, 2008.[10]T. Blazytko, M. SchlÃ¶gel, C. Aschermann, A. Abbasi, J. Frank, S. WÃ¶rner,and T. Holz, â€œAURORA: Statistical Crash Analysis for Automated Root CauseExplanation,â€USENIX Security, 2020. [Online]. Available: https://github.com/RUB-SysSec/[11]C. Cadar, D. Dunbar, and D. Engler, â€œKlee: unassisted and automatic generationof high-coverage tests for complex systems programs,â€ inOSDIâ€™08 Proceedings ofthe 8th USENIX conference on Operating systems design and implementation, 2008,pp. 209â€“224.[12]S. Chandra, E. Torlak, S. Barman, and R. Bodik, â€œAngelic debugging,â€ inProceedingsof the 33rd International Conference on Software Engineering, 2011, pp. 121â€“130.[13]S. Chaudhari, G. Polatkan, R. Ramanath, and V. Mithal, â€œAn attentive survey ofattention models,â€arXiv preprint arXiv:1904.02874, 2019.[14]V. Chipounov, V. Kuznetsov, and G. Candea, â€œS2e: a platform for in-vivo multi-path analysis of software systems,â€ inProceedings of the sixteenth internationalconference on Architectural support for programming languages and operatingsystems, vol. 46, no. 3, 2011, pp. 265â€“278.[15]J. S. Collofello and L. Cousins, â€œTowards automatic software fault location throughdecision-to-decision path analysis,â€a/f_ips, 1899.[16]Y. Dang, R. Wu, H. Zhang, D. Zhang, and P. Nobel, â€œRebucket: a method forclustering duplicate crash reports based on call stack similarity,â€ inProceedingsof the 34th International Conference on Software Engineering, 2012.[17]H. A. de Souza, M. L. Chaim, and F. Kon, â€œSpectrum-based Software FaultLocalization: A Survey of Techniques, Advances, and Challenges, â€ pp. 1â€“46, 2016.[Online]. Available: http://arxiv.org/abs/1607.04347[18]T. Dhaliwal, F. Khomh, and Y. Zou, â€œClassifying/f_ield crash reports for/f_ixingbugs: A case study of mozilla/f_irefox, â€ inIEEE International Conference on SoftwareMaintenance, 2011.[19]D. Hao, Y. Pan, L. Zhang, W. Zhao, H. Mei, and J. Sun, â€œA similarity-awareapproach to testing based fault localization,â€ 2005, pp. 291â€“294.[20]D. Hao, L. Zhang, H. Zhong, H. Mei, and J. Sun, â€œEliminating harmful redundancyfor testing-based fault localization using test suite reduction: an experimentalstudy,â€ in21st IEEE International Conference on Software Maintenance (ICSMâ€™05),2005, pp. 683â€“686.[21]X. He, Z. He, J. Song, Z. Liu, Y.-G. Jiang, and T.-S. Chua, â€œNais: Neural attentiveitem similarity model for recommendation,â€IEEE Transactions on Knowledge andData Engineering, vol. 30, no. 12, pp. 2354â€“2366, 2018.[22]D. Kim, Y. Tao, S. Kim, and A. Zeller, â€œWhere should we/f_ix this bug? a two-phaserecommendation model, â€IEEE Transactions on Software Engineering, vol. 39, no. 11,pp. 1597â€“1610, 2013.[23]S. Kim, T. Zimmermann, and N. Nagappan, â€œCrash graphs: An aggregated viewof multiple crashes to improve crash triage,â€ in2011 IEEE/IFIP 41st InternationalConference on Dependable Systems and Networks (DSN), 2011, pp. 486â€“493.[24]J. Li, W. Monroe, and D. Jurafsky, â€œUnderstanding neural networks throughrepresentation erasure,â€arXiv preprint arXiv:1612.08220, 2016.[25]B. Liblit, M. Naik, A. X. Zheng, A. Aiken, and M. I. Jordan, â€œScalable statisticalbug isolation,â€Acm Sigplan Notices, 2005.[26]C. Liu, L. Fei, X. Yan, J. Han, and S. P. Midkiï¬€, â€œStatistical debugging: A hypothesistesting-based approach,â€IEEE Transactions on Software Engineering, vol. 32, no. 10,pp. 831â€“848, 2006.[27]C. Liu and J. Han, â€œFailure proximity: a fault localization-based approach,â€ inProceedings of the 14th ACM SIGSOFT international symposium on Foundations ofsoftware engineering, 2006, pp. 46â€“56.[28]F. Long, S. Sidiroglou-Douskos, and M. Rinard, â€œAutomatic runtime error repairand containment via recovery shepherding,â€ inProceedings of the 35th ACMSIGPLAN Conference on Programming Language Design and Implementation,vol. 49, no. 6, 2014, pp. 227â€“238.[29]N. Modani, R. Gupta, G. Lohman, T. Syeda-Mahmood, and L. Mignet, â€œAuto-matically identifying known software problems,â€ in2007 IEEE 23rd InternationalConference on Data Engineering Workshop, 2007, pp. 433â€“441.[30]S. S. Murtaza, M. Gittens, and N. Madhavji, â€œDiscoveringthe fault origin from/f_ield traces,â€ inInternational Symposium on Software Reliability Engineering, 2008.[31]L. Naish, H. J. Lee, and K. Ramamohanarao, â€œA model for spectra-based softwarediagnosis,â€Acm Transactions on Software Engineering & Methodology, vol. 20,no. 3, pp. 1â€“32, 2011.[32]S. Nessa, M. Abedin, W. E. Wong, L. Khan, and Y. Qi, â€œSoftware fault localizationusing n-gram analysis,â€ 2008, pp. 548â€“559.[33]V. T. Pham, S. Khurana, S. Roy, and A. Roychoudhury, â€œBucketing failing tests viasymbolic analysis,â€Lecture Notes in Computer Science (including subseries LectureNotes in Arti/f_icial Intelligence and Lecture Notes in Bioinformatics), vol. 10202LNCS, pp. 43â€“59, 2017.[34]A. Podelski, M. SchÃ¤f, and T. Wies, â€œClassifying bugs with interpolants, â€tests andproofs, pp. 151â€“168, 2016.[35]M. Pradel, R. Qian, E. Meijer, and S. Chandra, â€œSca%e : Bug Localization onMillions of Files,â€ 2020.[36]S. Roychowdhury and S. Khurshid, â€œSoftware fault localization using featureselection,â€Proceedings of the International Workshop on Machine LearningTechnologies in Software Engineering, pp. 11â€“18, 2011.645Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. [37]R. van Tonder, J. Kotheimer, and C. le Goues, â€œSemantic crash bucketing,â€ inProceedings of the 33rd ACM/IEEE International Conference on Automated SoftwareEngineering, 2018, pp. 612â€“622.[38]S. Wang, F. Khomh, and Y. Zou, â€œImproving bug localization using correlations incrash reports,â€ in2013 10th Working Conference on Mining Software Repositories(MSR), 2013, pp. 247â€“256.[39]M. Weiser, â€œProgram slicing,â€IEEE Transactions on Software Engineering, vol.SE-10, no. 4, pp. 352â€“357, 1984.[40]W. E. Wong and Y. Qi, â€œAn execution slice and inter-block data dependency-basedapproach for fault localization,â€ inAsia-paci/f_ic Software Engineering Conference,2004.[41]â€”â€”,Eï¬€ective program debugging based on execution slices and inter-block datadependency. Elsevier Science Inc., 2006.[42]X. Y. Xie, F. C. Kuo, T. Y. Chen, S. Yoo, and M. Harman, â€œProvably optimaland human-competitive results in sbse for spectrum based fault localisation,â€ inInternational Symposium on Search Based Software Engineering, 2013.[43]J. Xu, D. Mu, X. Xing, P. Liu, P. Chen, and B. Mao, â€œPoMP: Postmortem programanalysis with hardware-enhanced post-crash artifacts,â€Proceedings of the 26thUSENIX Security Symposium, pp. 17â€“32, 2017.[44]J. Xu, R. Chen, and Z. Du, â€œProbabilistic reasoning in diagnosing causes of programfailures,â€Software Testing Veri/f_ication and Reliability, vol. 26, no. 3, 2016.[45]K. Xu, J. Ba, R. Kiros, K. Cho, A. Courville, R. Salakhudinov, R. Zemel, andY. Bengio, â€œShow, attend and tell: Neural image caption generation with visualattention,â€ inInternational conference on machine learning, 2015, pp. 2048â€“2057.[46]X. Ye, R. Bunescu, and C. Liu, â€œLearning to rank relevant/f_iles for bug reportsusing domain knowledge, â€ inAcm Sigsoft International Symposium on Foundationsof Software Engineering, 2014.[47]S. Yoo, â€œEvolving human competitive spectra-based fault localisation techniques,â€inSSBSEâ€™12 Proceedings of the 4th international conference on Search Based SoftwareEngineering, 2012, pp. 244â€“258.[48]F. R. Zakani, K. Arhid, M. Bouksim, T. Gadi, and M. Aboulfatah, â€œKulczynskisimilarity index for objective evaluation of mesh segmentation algorithms,â€ in2016 5th International Conference on Multimedia Computing and Systems (ICMCS),2016.[49] M. Zalewski, â€œAmerican fuzzy lop,â€URL: http://lcamtuf. coredump. cx/a/f_l, 2017.[50]S. Zhang and C. Zhang, â€œSoftware bug localization with markov logic,â€CompanionProceedings of the 36th International Conference on Software Engineering, pp. 424â€“427, 2014.[51]X. Zhang, N. Gupta, and R. Gupta, â€œPruning dynamic slices with con/f_idence,â€Acm Sigplan Notices, vol. 41, no. 6, pp. 169â€“180, 2006.[52]â€”â€”, â€œA study of eï¬€ectiveness of dynamic slicing in locating real faults,â€EmpiricalSoftware Engineering, vol. 12, no. 2, pp. 143â€“160, 2007.[53]X. Zhang, S. Tallam, N. Gupta, and R. Gupta, â€œTowards locating executionomission errors,â€ vol. 42, 06 2007, pp. 415â€“424.
12646Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:13:53 UTC from IEEE Xplore.  Restrictions apply. 