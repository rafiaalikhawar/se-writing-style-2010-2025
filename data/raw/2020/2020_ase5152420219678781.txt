JST AR: JavaScript Speciﬁcation Type Analyzer
using Reﬁnement
Jihyeok Park
School of Computing
KAIST
Daejeon, South Korea
jhpark0223@kaist.ac.krSeungmin An
School of Computing
KAIST
Daejeon, South Korea
h2oche@kaist.ac.krWonho Shin
School of Computing
KAIST
Daejeon, South Korea
new170527@kaist.ac.krYusung Sim
School of Computing
KAIST
Daejeon, South Korea
yusungsim@kaist.ac.krSukyoung Ryu
School of Computing
KAIST
Daejeon, South Korea
sryu.cs@kaist.ac.kr
Abstract —JavaScript is one of the mainstream programming
languages for client-side programming, server-side programming,
and even embedded systems. Various JavaScript engines devel-oped and maintained in diverse ﬁelds must conform to the syntaxand semantics described in ECMAScript, the standard speciﬁca-tion of JavaScript. Since an incorrect description in ECMAScriptcan lead to wrong JavaScript engine implementations, checkingthe correctness of ECMAScript is critical and essential. However,all the speciﬁcation updates are currently manually reviewed bythe Ecma Technical Committee 39 (TC39) without any automatedtools. Moreover, in late 2014, the committee announced the yearlyrelease cadence and open development process of ECMAScript toquickly adapt to evolving development environments. Because ofsuch frequent updates, checking the correctness of ECMAScriptbecomes more labor-intensive and error-prone.
To alleviate the problem, we propose JSTAR, a JavaScript
Speciﬁcation Type Analyzer using Reﬁnement. It is the ﬁrsttool that performs type analysis on JavaScript speciﬁcations and
detects speciﬁcation bugs using a bug detector . For a given spec-
iﬁcation, JSTAR ﬁrst compiles each abstract algorithm written
in a structured natural language to a corresponding function inIR
ES, an untyped intermediate representation for ECMAScript.
Then, it performs type analysis for compiled functions withspeciﬁcation types deﬁned in ECMAScript. Based on the resultof type analysis, JSTAR detects speciﬁcation bugs using a bug
detector consisting of four checkers. To increase the precision
of the type analysis, we present condition-based reﬁnement for
type analysis, which prunes out infeasible abstract states using
conditions of assertions and branches. We evaluated JSTAR with
all 864 versions in the ofﬁcial ECMAScript repository for therecent three years from 2018 to 2021. JSTAR took 137.3 seconds
on average to perform type analysis for each version, and detected157 type-related speciﬁcation bugs with 59.2% precision; 93 outof 157 bugs are true bugs. Among them, 14 bugs are newlydetected by JSTAR, and the committee conﬁrmed them all.
Index T erms —JavaScript, mechanized speciﬁcation, type anal-
ysis, reﬁnement, bug detection
I. I NTRODUCTION
JavaScript is one of the most popular programming lan-
guages. According to the 2020 State of the Octoverse1, the
annual report of GitHub, the most dominating programming
language in GitHub repositories was JavaScript since 2014 to
2020. While JavaScript was initially designed for client-side
programming in web browsers, it is now widely used in server-side programming [1] and even in embedded systems [2]–
1https://octoverse.github.com/[4]. Developers in diverse ﬁelds build and maintain JavaScriptengines conforming to ECMAScript, the JavaScript standardspeciﬁcation, which describes the syntax and semantics of
JavaScript in a natural language.
The correctness of ECMAScript is critical because an
incorrect description in the speciﬁcation can lead to wrong im-plementations of JavaScript engines in various ﬁelds. However,
all the speciﬁcation updates are currently manually reviewedby the Ecma Technical Committee 39 (TC39) without any
automated tools. Such a manual review process is inherently
labor-intensive and error-prone, making ECMAScript vulnera-ble to speciﬁcation bugs. Besides, in late 2014, the committee
announced the yearly release cadence and open development
process of ECMAScript to quickly adapt to evolving devel-opment environments. According to Park et al. [5], the aver-
age number of updated steps of abstract algorithms between
consecutive releases from ECMAScript 2016 (ES7) to 2019
(ES10) is 9645.5. In the ofﬁcial ECMAScript repository, 1,355
pull requests and 2,005 commits exist in the master branch.Therefore, manually checking all the frequent speciﬁcation
updates is a challenging task.
Unfortunately, no existing tools can automatically detect
bugs in rapidly evolving JavaScript speciﬁcations writtenin English. Thus, the ECMAScript committee has pursued
various manual annotations in abstract algorithms to reducespeciﬁcation bugs. First, the committee has introduced two
kinds of annotations: 1) assertions to denote assumptions at
speciﬁc points of abstract algorithms and 2) two preﬁxes ?and
!to represent whether the execution of an abstract algorithm
completes abruptly or not. For example, “Assert: Type( O)i s
Object” denotes that the variable Oalways has an
Object
value at the point of the assertion, and “ ? GetV(V, P)” denotes
that the execution of GetV(V, P) may complete abruptly. Such
annotations help readers understand speciﬁcations clearly, andthey are also helpful for speciﬁcation-based tools
2such as
JavaScript engines [4], [6]–[8], debuggers [9], static analyz-
ers [10]–[13], and veriﬁcation tools [14], [15]. Second, the
committee has started internal discussions on type annota-
tions for variables, parameters, and return values of abstract
2https://github.com/tc39/ecmarkup/issues/173
6062021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
DOI 10.1109/ASE51524.2021.000602021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678781
978-1-6654-0337-5/21/$31.00  ©2021  IEEE
algorithms3. However, any kinds of manual annotations are
labor-intensive and error-prone, and they do not provide any
automatic mechanism to detect speciﬁcation bugs.
To alleviate this problem, we propose a novel tool JST AR ,
aJavaScript Speciﬁcation Type Analyzer using Reﬁnement.
The main challenge of ECMAScript type analysis to stati-cally detect type-related speciﬁcation bugs automatically is
that ECMAScript describes abstract algorithms in a natural
language, English. While researchers [16]–[18] have formallydeﬁned various JavaScript semantics for different versions of
ECMAScript by hand, manual formalization is not suitable
for automatically detecting bugs in rapidly evolving JavaScriptspeciﬁcations. Thus, recent approaches in diverse ﬁelds such
as system architectures [19], [20], network protocols [21], and
language speciﬁcations [22], [23] have utilized informationdirectly extracted from speciﬁcations written in a natural
language to lessen such burdens. Among them,
JISET [5] com-
piles ECMAScript abstract algorithms written in a structured
natural language to functions in IR ES, an untyped intermediate
representation for ECMAScript. Therefore, JST AR leverages
JISET to mechanically handle JavaScript speciﬁcations.
JST AR takes mechanized JavaScript speciﬁcations from
JISET and performs a type analysis of compiled functions
using speciﬁcation types deﬁned in ECMAScript. ECMAScript
contains not only JavaScript language types but also speciﬁca-tion types such as abstract syntax trees (ASTs), internal list-
like structures, and internal records including environments,
completions, and property descriptors. We deﬁne their typehierarchies based on subtype relations. For records and AST
types, we also deﬁne their ﬁelds. Using such type information,
JST AR performs a type analysis and detects speciﬁcation bugs
using a bug detector consisting of four checkers: 1) a reference
checker, 2) an arity checker, 3) an assertion checker, and 4)
an operand checker. JST AR also uses a condition-based reﬁne-
ment for type analysis, which prunes out infeasible parts in
abstract states by using conditions of assertions and branchesto improve the precision of type analysis. We evaluated
JST AR
with all 864 versions in the ofﬁcial ECMAScript repositoryfor the recent three years from 2018 to 2021. The experimentsshowed that the reﬁnement technique could reduce the number
of false-positive bugs caused by spurious types inferred by
imprecise type analysis.
The main contributions of this paper are as follows:
•We present JST AR , the ﬁrst tool that performs a type
analysis on ECMAScript written in a natural language
to check the correctness of JavaScript language speciﬁ-
cations. JST AR automatically detects type-related spec-
iﬁcation bugs such as unknown variables, duplicated
variables, missing parameters, assertion failures, ill-typed
operands, and unchecked abrupt completion bugs.
•We present a condition-based reﬁnement for type analysis
of ECMAScript to reduce the number of false-positivebugs by enhancing the analysis precision. We show that
the reﬁnement technique increases the analysis precision
3https://github.com/tc39/ecma262/pull/545#issuecomment-559292107
Fig. 1: JST AR : a type analyzer and a bug detector for mech-
anized speciﬁcations extracted from ECMAScript by JISET
from 33.0% to 59.2% by removing 122 false bugs anddetecting one more true bug.
•We demonstrate the practicality of JST AR . It takes 137.3
seconds on average to perform a type analysis for eachversion of ECMAScript and detected 157 type-related
speciﬁcation bugs with 59.2% precision; 93 out of 157
bugs are true bugs. Among them,
JST AR newly detected
14 bugs, and the ECMAScript committee conﬁrmed themall.
II. O
VERVIEW
In this section, we demonstrate the overall structure of
JST AR depicted in Figure 1. It consists of three components: 1)
speciﬁcation extraction, 2) type analysis, and 3) bug detection.
A. Speciﬁcation Extraction
JST AR extracts the JavaScript syntax and semantics using
JISET and extracts speciﬁcation types from ECMAScript.
a) Syntax and Semantics: ECMAScript describes the
JavaScript syntax in an EBNF notation and the semantics using
abstract algorithms written in a structured natural language.
From ECMAScript, JISET synthesizes AST structures for
syntax and compiles the abstract algorithms to IR ESfunctions
with parameters and local variables for semantics. For ex-ample, the algorithm step “
”
is compiled to an IR ESinstruction let baseObj = ↓
ToObject(V.Base) . To make it suitable for type analysis,
we modify IR ESas formally deﬁned in Section III-A.
b) Types: In addition to JavaScript types, JST AR repre-
sents three kinds of speciﬁcation types. First, because ASTs
are values in abstract algorithms, they can be stored invariables and passed as function arguments. For ASTs, we
use their production names as their types and automatically
link their corresponding syntax-directed algorithms to theirﬁelds. Second, ECMAScript supports various record types and
ﬁelds whose possible values are deﬁned in their corresponding
tables. For example, “Table 9: Completion Record Fields” in
the latest ECMAScript describes the ﬁelds of the completion
records. Thus, we manually model the ﬁelds of record typesbased on the tables in the latest version and use them in a type
analysis. Third, for list-like structures, we deﬁne the empty list
type
[]and parametric list types [τ].
607Fig. 2: An example JavaScript program with related previous speciﬁcation bugs and their bug ﬁxes
B. Type Analysis
JST AR performs a type analysis with ﬂow-sensitivity and
type-sensitivity for arguments. Each function is split into mul-
tiple ﬂow- and type-sensitive views, and an abstract state stores
mapping from views to corresponding abstract environments.To handle views separately, we use a worklist algorithm.
The type analyzer consists of two sub-modules: an analysis
initializer and an abstract transfer function.
a) Analysis Initializer: It deﬁnes the initial abstract state
and the initial set of views for a worklist. ECMAScript
provides three kinds of abstract algorithms: normal, syntax-
directed, and built-in. As for entry points of type analysis,
we use syntax-directed algorithms and built-in algorithmsbecause they have their parameter types. For each entry point,
the initializer deﬁnes its abstract environment with parameter
types and adds the ﬂow- and type-sensitive views of the entry
point to the worklist.
b) Abstract Transfer Function: For each iteration, the
abstract transfer function gets a speciﬁc view from the worklistand updates the abstract environments of the next views based
on the abstract semantics. It adds the next views to the worklistif it changes their abstract environments, and the iteration
ﬁnishes when the worklist becomes empty. To increase the
analysis precision, we perform a condition-based reﬁnement
for an abstract environment when the current control point is
a branch or an assertion as described in Section III-C.
C. Bug Detection
To detect speciﬁcation bugs utilizing the type analysis, we
develop four checkers in a bug detector. We explain the targets
of the checkers with an example JavaScript program that
contains related previous speciﬁcation bugs and their bug ﬁxes,as shown in Figure 2.
a) Reference Checker: The example JavaScript program
ﬁrst deﬁnes a variable
fwithout initialization, which has the
value undefined . It then assigns an anonymous function to f
using the operator ??=. While the corresponding Evaluationalgorithm in Figure 2(a) originally used the GetReferenced-
Name algorithm to get a reference name on line 4.a, a
contributor removed the GetReferencedName algorithm and
replaced all its invocations with accesses of the ﬁeld [[Refer-encedName]] on October 28, 2020. However, the contributor
missed several cases including the semantics of
??=, which
was ﬁxed by another contributor on November 3, 2020. Thus,
the unknown variable bug for GetReferencedName lasted for
7 days, which the reference checker can detect.
b) Arity Checker: The program ﬁnally calls fwith
an argument true . During the initialization of the function
call, IteratorBindingInitialization in Figure 2(b) is executed
with additional parameters iteratorRecord and environment to
assign argument values to parameters. However, a contributor
missed passing additional arguments to them on line 2 in Iter-
atorBindingInitialization ofArrowParameters on September
6, 2018. It caused an arity mismatch bug, which lasted for 533days until another contributor ﬁxed it on February 20, 2020.
The arity checker can detect such arity mismatches.
c) Assertion Checker: During the initialization of the
function call, IteratorBindingInitialization ofF ormalParam-
eter in Figure 2(c) contains another bug. Even though the
additional environment parameter may contain
undefined ,a
contributor did not consider it on line 5 in the initial commitof the open development process on September 22, 2015.It caused an assertion failure bug, which lasted for 1,297
days until another contributor ﬁxed it on April 10, 2019. The
assertion checker can detect such assertion failures.
d) Operand Checker: After the function call initializa-
tion, the parameter
xhas the value true , and Math.round
in Figure 2(d) is invoked with the argument true . The
Math.round built-in library ﬁrst converts the given parameter
xto its corresponding number value nusing ToNumber, and
performs the remaining steps using n. However, a contributor
mistakenly used xinstead of non lines 3 and 4 on September
11, 2020. This bug caused the algorithm to compare theboolean value
true with the numeric value 0.5 or 0 in the
608Fig. 3: Fields of completion records in ECMAScript 2020
example code. This bug lived for two days until another
contributor ﬁxed it, and the operand checker can detect them.
In the remainder of this paper, we explain the details of how
to perform type analysis for IR ESfunctions and how to increase
the analysis precision using the condition-based reﬁnement
(Section III) and how to detect type-related speciﬁcation bugs(Section IV). After we evaluate
JST AR (Section V), we discuss
related work (Section VI) and conclude (Section VII).
III. T YPE ANALYZER
This section formally deﬁnes a modiﬁed IR ESand its type
analysis and presents a condition-based reﬁnement of the typeanalysis to improve the analysis precision.
A. Intermediate Representation
IR
ESis an untyped intermediate representation for EC-
MAScript [5]. We modify it as a label-based language to make
it suitable for type analysis as follows:
Functions F/ownerf::=def x(x∗,[x∗]) l
Instructions I/owneri::=let x=e|x=(ee∗)|asserte
|ifell| returne|r=e
References r::=x|r[e]
Expressions e::=t{[x:e]∗}|[e∗]|e:τ|r?
|e⊕e|/circleminuse|r|c|p
Primitives P/ownerp::=undefined |null|b|n|j|s|@s
Types T/ownerτ::=t|[]|[τ]|js|prim
|undefined |null|bool|numeric
|num|bigint|str|symbol
A modiﬁed IR ESprogramP=(func,inst,next)consists of
three mappings; func:L→Fmaps labels to their functions,
inst:L→Imaps labels to their instructions, and next:
L→Lmaps labels to their next labels, where a label l∈L
denotes a program point. A function def f(x∗,[y∗]) l∈F
consists of its name f, normal parameters x∗, optional parame-
tersy∗, and a body label l. For presentation brevity, we assume
that no global variables exist in this paper. An instruction
iis a variable declaration, a function call, an assertion, a
branch, a return, or a reference update. An invocation of an
abstract algorithm in ECMAScript is compiled to a function
call instruction with a new temporary variable. We represent
loops using branch instructions with cyclic pointing of labels
innext . A reference ris a variable xor a ﬁeld access r[e].
We write r.fto brieﬂy represent r["f"] . An expression eis
a record, a list, a type check, an existence check, a binaryoperation, a unary operation, a reference, a constant, or a
Fig. 4: A graphical representation of the subtype relation <:
primitive, which is either undefined ,null ,aBoolean b,
aNumbern,aBigIntj,aStrings,o ra Symbol @ s.
A typeτ∈Tis either a nominal type t, an empty list type
[], a parametric list type [τ], a JavaScript type js, a primitive
type prim , a numeric type numeric ,num,bigint ,str,o r
symbol . A nominal type tis either 1) an AST type with its
corresponding syntax-directed algorithms as its ﬁelds, or 2) a
record type with speciﬁc ﬁelds as described in ECMAScript.
For example, Figure 3 shows an excerpt from ECMAScript2020 (ES11) that describes the ﬁelds of completion records
4,
which we model as follows:
Completion= {
Type:{cnormal,cbreak,ccontinue ,creturn,cthrow},
Value:{js,cempty},Target:{str,cempty}
}
The subtype relation <:⊆T×Tbetween types is depicted
in Figure 4; a directed edge from τ/primetoτdenotesτ/prime<:τ, and
the relation is reﬂexive and transitive. The subtype relation
depends on the nominal types deﬁned in ECMAScript. Weextract the subtype relation for AST types from the JavaScript
syntax. For example, consider the syntax-directed abstract
algorithm in Figure 2(c). Because the nonterminal Bindin-
gElement is the unique alternative of the F ormalParameter
production, we automatically extract the subtype relation:BindingElement <:F ormalParameter. Using the subtype rela-
tion, the expression e:τchecks whether the evaluation result
ofehas type τ
/primesatisfying τ/prime<:τ.
We deﬁne a denotational semantics of the modiﬁed IR ESfor
instructions /llbracketi/rrbracketi:S→S, references /llbracketr/rrbracketr:S→S×V, and
expressions /llbrackete/rrbrackete:S→S×VwhereSandVdenote states
and values, respectively. For brevity, we omit it in this paperand refer the interested readers to a companion report [24].
B. Type Analysis
We design a type analysis for the modiﬁed IR
ESbased on
the abstract interpretation framework [25], [26] with analysis
sensitivity [27]. We extend types as follows:
T/ownerτ::=···|f|c|?|b|s|normal(τ)|abrupt
with function types f, constant types c, and the absent type
?representing the absence of variables. Boolean valuesb,
String valuess,normal(τ)denoting normal completions
4https://262.ecma-international.org/11.0/#table-8
609/llbracketlet x=e/rrbracket/sharp
i(l,τ)(d/sharp)= ( {(next(l),τ)/mapsto→σ/sharp[x/mapsto→/llbrackete/rrbracket/sharpe(σ/sharp)]},∅)
/llbracketx=(ee1···en)/rrbracket/sharpi(l,τ)(d/sharp)=(m/prime,r/prime)
where⎧
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩τ
/sharp=/llbrackete/rrbracket/sharp
e(σ/sharp)∧τ/sharp
1=/llbrackete1/rrbracket/sharpe(σ/sharp)∧ ··· ∧ τ/sharp
n=/llbracketen/rrbracket/sharpe(σ/sharp)∧
T/prime={˙up([τ1,···,τn])|τ1∈τ/sharp
1∧ ··· ∧ τn∈τ/sharp
n}∧
f=def f(p1,···,[···,pkf]) lf∧
σ/sharp
f,τ/prime=[p1/mapsto→{τ/prime[1]},···,pkf/mapsto→{τ/prime[kf]}]∧
m/prime={(lf,τ/prime)/mapsto→σ/sharp
f,τ/prime|f∈τ/sharp∧τ/prime∈T/prime}∧
r/prime={(f,τ/prime)/mapsto→{(next(l),τ,x)}|f∈τ/sharp∧τ/prime∈T/prime}/llbracketreturne/rrbracket/sharpi(l,τ)(d/sharp)= ({(lr,τr)/mapsto→σ/sharp
r|(lr,τr,x)∈R},∅)
whereR=r(func(l),τ)∧σ/sharp
r=m(lr,τr)[x/mapsto→/llbrackete/rrbracket/sharpe(σ/sharp)]
/llbracketasserte/rrbracket/sharpi(l,τ)(d/sharp)= ({(next(l),τ)/mapsto→pass(e,#t)(σ/sharp)},∅)
/llbracketifeltlf/rrbracket/sharpi(l,τ)(d/sharp)= ({(lt,τ)/mapsto→pass(e,#t)(σ/sharp),
(lf,τ)/mapsto→pass(e,#f)(σ/sharp)},∅)
/llbracketx=e/rrbracket/sharp
i(l,τ)(d/sharp)= ( {(next(l),τ)/mapsto→σ/sharp[x/mapsto→/llbrackete/rrbracket/sharpe(σ/sharp)]},∅)
/llbracketr[e0]=e1/rrbracket/sharpi(l,τ)(d/sharp)=({(next(l),τ)/mapsto→σ/sharp},∅)
whered/sharp=(m,r)∧σ/sharp=m(l,τ)
Fig. 5: Abstract semantics of instructions for a program P=(func,inst,next),/llbracketi/rrbracket/sharpi:(L×T∗)→S/sharp→S/sharp
with Value ﬁelds of type τ, and abrupt denoting abrupt
completions serve to improve the analysis precision.
Using the extended types, we deﬁne abstract states with
ﬂow-sensitivity and type-sensitivity for arguments:
Abstract States d/sharp∈S/sharp=M×R
Result Maps m∈M=L×T∗→E/sharp
Return Point Maps r∈R=F×T∗→P(L×T∗×X)
Abstract Environments σ/sharp∈E/sharp=X→T/sharp
Abstract Types τ/sharp∈T/sharp=P(T)
An abstract state d/sharp∈S/sharpis a pair of a result map and a
return point map. A result map m∈Mrepresents an abstract
environment for each ﬂow- and type-sensitive view, and a
return point map r∈Rrepresents possible return points of
each function with a type-sensitive context; each return point
consists of a view for the caller function and a variable that
represents the return value. An abstract environment σ/sharp∈E/sharp
represents possible types for variables, and σ/sharp(x)={ ?}when
xis not deﬁned in σ/sharp. An abstract type τ/sharp∈T/sharpis a set of
types. We deﬁne the join operator /unionsq, the meet operator /intersectionsq, and
the partial order /subsetsqequalfor most of abstract domains in a point-wise
manner, and deﬁne the operators for types with a normalization
function norm because of their subtype relations:
τ/sharp
0/unionsqτ/sharp
1=norm(τ/sharp
0∪τ/sharp
1)
τ/sharp
0/intersectionsqτ/sharp
1=norm({τ0∈τ/sharp
0|{τ0}/subsetsqequalτ/sharp
1}∪{τ1∈τ/sharp
1|{τ1}/subsetsqequalτ/sharp
0})
τ/sharp
0/subsetsqequalτ/sharp
1⇔∀τ0∈τ/sharp
0.∃τ1∈norm(τ/sharp
1).s.t.τ0<:τ1
where norm(τ/sharp)={τ∈τ/sharp|∄τ/prime∈τ/sharp\{τ}.s.t.τ<:τ/prime}.
We now deﬁne the abstract semantics of instructions /llbracketi/rrbracket/sharp
i:
(L×T∗)→S/sharp→S/sharpin Figure 5 and the abstract semantics
of references /llbracketr/rrbracket/sharp
r:E/sharp→T/sharpand expressions /llbrackete/rrbracket/sharpe:E/sharp→T/sharp
in a companion report [24]. To avoid the explosion of type-
sensitive views, we upcast the argument type before functioncalls with the following function:
up(τ)=⎧
⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎩normal(up(τ/prime))ifτ=normal(τ/prime)
[up(τ/prime)] ifτ=[τ/prime]
str ifτ=s
bool ifτ=b
τ otherwise
and˙updenotes a point-wise extension of upfor type se-
quences. For branches and assertions, we use the following
pass function to prevent infeasible control ﬂows:pass(e,b)(σ/sharp)=/braceleftbigg
refine(e,b)(σ/sharp)ifb/subsetsqequal/llbrackete/rrbracket/sharp
e(σ/sharp)
∅ otherwise
where refine prunes out infeasible parts in abstract environ-
ments using their conditions as we describe in Section III-C.
Then, we deﬁne the abstract semantics /llbracketP/rrbracket/sharpof a program P
as the least ﬁxpoint of the abstract transfer function F/sharp:S/sharp→
S/sharp:
/llbracketP/rrbracket/sharp= limn→∞(F/sharp)n(d/sharp
ι)
F/sharp(d/sharp)=d/sharp/unionsq/parenleftBig/unionsqtext
(l,τ)∈Domain (m)/llbracketinst(l)/rrbracket/sharp
i(l,τ)(d/sharp)/parenrightBig
whered/sharp=(m,)andd/sharp
ιdenotes the initial abstract state.
As described in Section II, d/sharpιcontains the entry points of
all syntax-directed algorithms without additional parameters
and built-in algorithms with appropriate abstract environments.
For a syntax-directed algorithm, we construct its abstractenvironment containing the variable
this with its production
type and other variables for nonterminals. For example, thesyntax-directed algorithm in Figure 2(a) is initialized with thefollowing abstract environment:
this/mapsto→{AssignmentExpression },
LeftHandSideExpression /mapsto→{LeftHandSideExpression },
AssignmentExpression /mapsto→{AssignmentExpression }
For built-in algorithms, we assign pre-deﬁned variables this ,
args , and NewTarget with their corresponding types and
parameters with jstypes. For example, the following abstract
environment is for the built-in algorithm Math.round in
Figure 2(d):
this/mapsto→{js}, args/mapsto→{[js]},
NewTarget /mapsto→{Object,undefined }, x/mapsto→{js}
C. Condition-based Reﬁnement
We present a condition-based reﬁnement of the type analysis
for the modiﬁed IR ESto enhance the analysis precision. It
prunes out infeasible parts in abstract environments using the
conditions of branches and assertions. We formally deﬁne the
refine function as follows:
610TABLE I: Type-related speciﬁcation bugs ﬁxed by pull re-
quests for the recent three years from 2018 to 2021
Category Bug Kind # Pull Requests # Bug Fixes
ReferenceUnknownVar 5 12
DuplicatedVar 2 12
Arity MissingParam 2 4
Assertion Assertion 4 5
OperandNoNumber 1 2
Abrupt 5 6
Total 19 41
refine(!e,b)(σ/sharp)=refine(e,¬b)(σ/sharp)
refine(e0||e1,b)(σ/sharp)=/braceleftbiggσ/sharp
0/unionsqσ/sharp
1ifb
σ/sharp
0/intersectionsqσ/sharp
1if¬b
refine(e0&&e1,b)(σ/sharp)=/braceleftbigg
σ/sharp
0/intersectionsqσ/sharp
1ifb
σ/sharp
0/unionsqσ/sharp
1if¬b
refine(x.Type == cnormal,#t)(σ/sharp)=σ/sharp[x/mapsto→τ/sharpx/intersectionsqnormal(T)]
refine(x.Type == cnormal,#f)(σ/sharp)=σ/sharp[x/mapsto→τ/sharpx/intersectionsq{abrupt}]
refine(x= =e,#t)(σ/sharp)=σ/sharp[x/mapsto→τ/sharpx/intersectionsqτ/sharp
e]
refine(x= =e,#f)(σ/sharp)=σ/sharp[x/mapsto→τ/sharpx\⌊τ/sharp
e⌋]
refine(x:τ,#t)(σ/sharp)=σ/sharp[x/mapsto→τ/sharpx/intersectionsq{τ}]
refine(x:τ,#f)(σ/sharp)=σ/sharp[x/mapsto→τ/sharpx\{τ/prime|τ/prime<:τ}]
refine(e,b)(σ/sharp)=σ/sharp
whereσ/sharp
j=refine(ej,b)(σ/sharp)forj=0,1,τ/sharp
e=/llbrackete/rrbracket/sharp
e(σ/sharp),
and⌊τ/sharp⌋returns{τ}ifτ/sharpdenotes a singleton type τ, or returns
∅, otherwise.
IV . B UGDETECTOR
We develop a bug detector to statically detect type-related
speciﬁcation bugs in ECMAScript using an augmented ab-
stract transfer function F/sharp
awith additional checkers. Before
implementing checkers, we manually investigated pull requestsfor the recent three years from 2018 to 2021 to identifyimportant bugs to detect. As summarized in Table I, we found
19 pull requests that ﬁxed 41 type-related speciﬁcation bugs,
and classiﬁed the bugs into four categories with six kinds.To detect them automatically, we implement four checkers: a
reference checker,a n arity checker,a n assertion checker , and
anoperand checker.
A. Reference Checker
ECMAScript abstract algorithms dynamically introduce
variables in any contexts. A reference bug occurs when trying
to access variables not yet deﬁned (
UnknownVar ) or to redeﬁne
variables already deﬁned ( DuplicatedVar ). According to our
manual investigation of the pull requests, the reference bug
is the most prevalent type-related speciﬁcation bugs; ﬁve pull
requests ﬁxed 12 unknown variable bugs and two pull requests
ﬁxed 12 duplicated variable declaration bugs. We implement a
reference checker by adding additional checks to the abstract
semantics of variable lookups and variable declarations asfollows:
/llbracketx/rrbracket/sharp
e(σ/sharp)=/braceleftbigg
unknown variable xif/llbracketx/rrbracket/sharp
r(σ/sharp)={ ?}
··· otherwise
/llbracketlet x=e/rrbracket/sharpi(l,τ)(d/sharp)=/braceleftbigg
already deﬁned variable xifτ/sharp={#t}
··· otherwise
whereτ/sharp=/llbracketx?/rrbracket/sharpe(d/sharp(l,τ))If the abstract semantics of a variable lookup for xis a
singleton {?},xis always an unknown variable. For example,
consider the syntax-directed algorithm in Figure 2(a). Since
theGetReferencedName algorithm is removed, the variable
GetReferencedName does not exist in abstract environments
and its lookup returns {?}. Thus, the reference checker reports
the unknown variable bug for GetReferencedName .F o r
duplicated variable declarations, the reference checker utilizes
the abstract semantics of the existence check /llbracketx?/rrbracket/sharp
eto see
whether the variable xof each variable declaration is already
deﬁned.
B. Arity Checker
The arity of a function f=def f(p1,···,pn,[···,pm]) l
is an interval [n,m] wherenandm−ndenote the numbers
of normal and optional parameters, respectively. In function
invocations, an arity bug occurs when the number of argu-
ments does not match with the function arity ( MissingParam ).
In the last three years, two pull requests ﬁxed four missing
parameter bugs. The arity checker detects them by adding an
additional check to the abstract semantics of the function callinstruction:
/llbracketx=(ee1···ek)/rrbracket/sharp
i(l,τ)(d/sharp)=/braceleftbiggmissing parameters pk+1,···,pnfif∃f∈τ/sharp.s.t.k<nf
··· otherwise
wheref=def f(p 1,···,pnf,[···,pmf]) l∧
τ/sharp=/llbrackete/rrbracket/sharp
e(d/sharp(l,τ)).
For each function fin the abstract semantics of the function
expression e, the arity checker compares the number of
arguments with the arity of fto detect missing parameters.
For example, consider the syntax-directed algorithm in Fig-
ure 2(b). The algorithm invocation on line 2 is compiled to
the following function call instruction:
x = (formals.IteratorBindingInitialization formals)
using a temporary variable x. Because it passes only a single
argument formals even though the function arity is [3,3],t h e
arity checker reports missing parameter bugs for two additional
parameters iteratorRecord andenvironment .
C. Assertion Checker
An assertion failure (Assertion ) is a speciﬁcation bug that
occurs when the condition of an assertion instruction is not
true. We found four pull requests that ﬁxed ﬁve assertion
failures. The assertion checker detects them using an additionalcheck in the abstract semantics of the assertion instruction:
/llbracketasserte/rrbracket/sharp
i(l,τ)(d/sharp)=/braceleftbigg
assertion failure eif{#t} /negationslash/subsetsqequalτ/sharp
··· otherwise
whereτ/sharp=/llbrackete/rrbracket/sharpe(d/sharp(l,τ))
It checks whether the abstract semantics of the condi-
tion expression esubsumes {#t}. For example, consider
the syntax-directed algorithm in Figure 2(c). The parameter
environment of this algorithm has an environment record or
undefined . Since type sensitivity divides the abstract types
611(a) The number of functions
 (b) The number of views
 (c) The number of iterations
 (d) The analysis time
Fig. 6: The statistics of the type analysis using JST AR for 864 versions of ECMAScript
of arguments to upcasted single types, there are two different
abstract environments whose variable environment points
to{Environment }or{undefined }. When environment
is{Environment }, the abstract semantics of the assertion
condition environment = originalEnv is{bool}.E v e n
though we know that the type of originalEnv is also
{Environment }, because Environment is not a single-
ton type, we cannot conclude that they are the exactlysame environment. Thus, the assertion checker does notreport any bug for this case. However, if
environment
is{undefined }, the abstract semantics of the condition
environment = originalEnv is{#f}because an envi-
ronment is never equal to undefined . Therefore, the as-
sertion checker reports an assertion failure for the condition
environment = originalEnv .
D. Operand Checker
An ill-typed operand bug occurs when the type of an
operand does not conform to its corresponding parameter type.The operand checker detects such ill-typed operand bugs byadditional checks in the abstract semantics of operations:
/llbrackete0⊕e1/rrbracket/sharp
e(σ/sharp)=⎧
⎨
⎩ill-typed operand e0if/llbrackete0/rrbracket/sharp
r(σ/sharp)/negationslash/subsetsqequalτ/sharp
0
ill-typed operand e1if/llbrackete1/rrbracket/sharpr(σ/sharp)/negationslash/subsetsqequalτ/sharp
1
··· otherwise
/llbracket/circleminuse/rrbracket/sharp
e(σ/sharp)=/braceleftbigg
ill-typed operand e if/llbrackete/rrbracket/sharpr(σ/sharp)/negationslash/subsetsqequalτ/sharp
··· otherwise
whereτ/sharp
0,τ/sharp
1, andτ/sharpare expected abstract types of e0,e1,
ande, respectively. The additional checks report when a
given operand does not conform to its expected type. Our
manual investigation found two non-numeric operand bugs
(NoNumber ) in one pull request and six unchecked abrupt
completion bugs ( Abrupt ) in ﬁve pull requests.
For an example non-numeric operand bug, consider the
built-in algorithm Math.round in Figure 2(d). The types of x
andnare{js}and{num}, respectively, because ToNumber
always returns number values or abrupt completions, and thepreﬁx ?removes the latter case. The built-in algorithm misuses
xrather than non lines 3 and 4, and because the expected
abstract type {num,bigint}does not subsume {js},t h e
operand checker reports non-numeric operand bugs.
An unchecked abrupt completion bug occurs when an actual
value is necessary but it is an abrupt completion. ECMAScripthas a special implicit conversion for normal completions whentheir actual values stored in the
Value ﬁeld are necessary.
An actual value is necessary in various contexts such as
conditions, values of ﬁeld updates, and operands of operators.
For example, if the variable xhas a normal completion with
42as its actual value, x+1 should be 43because the normal
completion gets implicitly converted into its actual value 42.
We deﬁne a unary operator ↓to explicitly represent this
conversion:
↓v=⎧
⎨
⎩v ifvis not a completion
v.Value ifvis normal
unchecked abrupt completion votherwise
The operand checker detects unchecked abrupt completion
bugs by assuming that the operator ↓is used when the actual
value is necessary.
V. E V ALUATION
We implemented JST AR as an open-source tool5in Scala by
extending JISET , a JavaScript IR-based semantics extraction
toolchain [5], with a worklist-based ﬁxpoint algorithm for typeanalysis. Thus,
JST AR reports type-related speciﬁcation bugs
detected in fully compiled abstract algorithms by JISET .F o r
built-in libraries, JST AR analyzes the abstract algorithms of the
essential built-in objects: Array ,Object ,Function ,Math ,
Proxy , and objects for JavaScript primitive types.
We evaluate JST AR using the following research questions:
•RQ1. (Performance) How long does JST AR take to
perform type analysis for JavaScript speciﬁcations?
•RQ2. (Precision) How many type-related speciﬁcation
bugs detected by JST AR are true bugs?
•RQ3. (Effectiveness of Reﬁnement) Does the condition-
based reﬁnement improve the analysis precision with
modest performance overhead?
•RQ4: (Detection of New Bugs) Does JST AR detect new
speciﬁcation bugs in the latest version of ECMAScript?
Because the draft of the next ECMAScript (ES12, 2021) is
ﬁxed on March 9, 2021, we analyzed all 864 versions inthe ofﬁcial ECMAScript repository
6for the last three years
from January 1, 2018 to March 9, 2021. We performed ourexperiments on ﬁve Ubuntu machines equipped with 4.2GHz
Quad-Core Intel Core i7 and 32GB of RAM.
5https://github.com/kaist-plrg/jstar
6https://github.com/tc39/ecma262
612TABLE II: The analysis precision of JST AR without reﬁnement ( no-reﬁne ), with reﬁnement ( reﬁne ), and their difference (Δ)
Checker Bug KindPrecision = (# True Bugs) / (# Detected Bugs)
no-reﬁne reﬁne Δ
ReferenceUnknownVar62 / 106 ( 58.5%)17 / 60 ( 28.3%)63 / 78 ( 80.8%)17 / 31 ( 54.8%)+1 / -28 (+22.3%)/ -29 (+26.5%)
DuplicatedVar 45 / 46 ( 97.8%) 46 / 47 ( 97.9%) +1 / +1 ( +0.1%)
Arity MissingParam 4 / 4 (100.0%) 4 / 4 (100.0%) 4 / 4 (100.0%) 4 / 4 (100.0%) /( % ) /( % )
Assertion Assertion 4 / 56 ( 7.1%) 4/5 6( 7 . 1 % ) 4 / 31 ( 12.9%) 4 / 31 ( 12.9%) / -25 ( +5.8%) / -25 ( +5.8%)
OperandNoNumber22 / 113 ( 19.5%)2/6 5( 3 . 1 % )22 / 44 ( 50.0%)2 / 6 ( 33.3%)/ -69 (+30.5%)/ -59 (+30.3%)
Abrupt 20 / 48 ( 41.7%) 20 / 38 ( 52.6%) / -10 (+11.0%)
Total 92 / 279 (33.0%) 93 / 157 (59.2%) +1 / -122 (+26.3%)
(a) Life spans sorted by creation
 (b) The histogram of life spans
Fig. 7: Life spans of true bugs
A. Performance
Figure 6 shows the statistics of the type analysis using
JST AR for 864 versions of ECMAScript: (a) the number of
analyzed functions, (b) the number of ﬂow- and type-sensitive
views, (c) the number of worklist iterations, and (d) the analy-sis time. For each version,
JST AR analyzed 1,696.6 functions
on average. Since ECMAScript has gradually evolved, it ana-lyzed 1,491 functions for the ﬁrst version in 2018 but analyzed
1,864 functions in the latest.
JST AR analyzes functions with
ﬂow- and type-sensitive views. On average, each version has
92.0K views and each function has 54.1 views.
We measured the performance of JST AR with the worklist
iteration number and the analysis time. For each version ofECMAScript,
JST AR took 137.3 seconds with 301.6K worklist
iterations on average. The average analysis time is 8.0 seconds
for speciﬁcation extraction ( extract ), 128.5 seconds for type
analysis ( analyze ), and 0.8 seconds for bug detection ( detect ).
The performance overhead is modest enough for JST AR to be
integrated in the open development process of ECMAScript.
B. Precision
We measured the analysis precision with the ratio of true
bugs in the reported bugs by JST AR . As summarized in the
reﬁne column of Table II, the analysis precision is 59.2%; 93
out of 157 detected bugs are true bugs. The reference checker
detected the most bugs with 80.8% precision; 17 unknown
variables ( UnknownVar ) and 46 duplicated variable declara-
tions ( DuplicatedVar ) are true bugs. We found four missing
parameters ( MissingParam ) with 100.0% precision and four
assertion failures ( Assertion ) with 12.9% precision. Finally,
the operand checker detected two non-numeric operand bugs
(NoNumber ) with 33.3% precision and 20 unchecked abrupt
completion bugs ( Abrupt ) with 52.6% precision.
To understand the impact of the detected true bugs, we
extended JST AR to automatically extract when they are created
and resolved in the ECMAScript ofﬁcial repository. A bug iscreated when it exists in a speciﬁc version but does not exist in
its previous version, and a bug is resolved vice versa. The life
span of a bug denotes the number of days between the created
date and the resolved date. Figure 7 illustrates the life spans oftrue bugs; Figure 7(a) depicts the life spans sorted by creation
and Figure 7(b) depicts the histogram of the life spans in alogarithmic scale. Among 93 true bugs, 49 bugs are inherited,
which means that they are created before 2018. Moreover, 14bugs still exist in the latest ECMAScript, which are newlydetected by
JST AR . We discuss the details of 14 newly found
bugs in Section V-D. Even though we assume that 49 inheritedbugs are created on January 1, 2018, the average life span is422.8 and the maximum life span is 1,164. All the bugs with
the maximum life span are inherited ones and they are all
newly detected.
We manually investigated 64 false-positive bugs to under-
stand why
JST AR detected them. Among them, 17 bugs are
due to extraction failure of mechanized speciﬁcations caused
by wrong writing styles. Because ECMAScript is written in
HTML, JISET extracts abstract algorithms using the emu-alg
HTML tag. Unfortunately, several abstract algorithms aredeﬁned with the opening tag
<emu-alg> but without the
closing tag </emu-alg> , which causes extraction failure of
mechanized speciﬁcations leading to false-positive bugs. Theremaining 47 bugs are due to imprecise analysis. We foundthat 28 bugs are due to imprecise analysis of the conditions
of assertions and branches for speciﬁc function calls. For
example, consider the following algorithm step for GetValue :
Since IsPropertyReference always returns false when the
Base ﬁeld of a given reference record is cunresolvable ,t h e
ﬁeld access V.[[Base]] cannot be cunresolvable on line 4.a.
However, because the type analysis does not compute such in-formation, c
unresolvable is also passed as the argument of
ToObject. We believe that an advanced reﬁnement technique
can resolve this problem by pruning out infeasible ﬁeld types
depending on speciﬁc contexts.
C. Effectiveness of Reﬁnement
We measured the effectiveness of the condition-based reﬁne-
ment by comparing the performance and the analysis precision
ofJST AR without ( no-reﬁne ) and with reﬁnement ( reﬁne ).
For performance comparison, Figure 8 presents the iter-
ations and analysis time without and with reﬁnement. Fig-
ures 8(a) and 8(c) are histograms of the iterations and analysis
613TABLE III: Type-related speciﬁcation bugs newly detected by JST AR in the ofﬁcial draft of ECMAScript 2021 (ES12)
Name Feature # Description Checker Created Life Span
ES12-1 Switch 3Variables hasDuplicates andhasUndefinedLabels are already
deﬁned in algorithms for case blocks of switch statements.Reference 2015-09-22 1,996 days
ES12-2 Try 3Variables hasDuplicates andhasUndefinedLabels are already
deﬁned in algorithms for try statements.Reference 2015-09-22 1,996 days
ES12-3 Arguments 1A variable index is already deﬁned in CreateMappedArgumentsObject. Reference 2015-09-22 1,996 days
ES12-4 Array 2A variable succeeded is already deﬁned in algorithms for Array objects. Reference 2015-09-22 1,996 days
ES12-5 Async 1A variable value is already deﬁned in Evaluation foryield expressions. Reference 2015-09-22 1,996 days
ES12-6 Class 1A variable ClassHeritage is not deﬁned in Contains
for tails of class declarations.Reference 2015-09-22 1,996 days
ES12-7 Branch 1A variable Statement is not deﬁned in EarlyErrors forifstatement. Reference 2015-09-22 1,996 days
ES12-8 Arguments 2Abrupt completions are used in DeﬁneOwnProperty and GetOwnProperty
forarguments objects without any checks.Operand 2015-12-16 1,910 days
(a) The histogram of iterations
 (b) The ratio of iterations
(c) The histogram of time
 (d) The ratio of time
Fig. 8: Comparison of iterations and analysis time without
reﬁnement ( no-reﬁne ) and with reﬁnement ( reﬁne )
time, respectively, and Figures 8(b) and 8(d) are scatter charts
for their ratios. Without reﬁnement, the type analysis took
91.9 seconds with 261.5K iterations on average. After applyingreﬁnement, the number of iterations is increased at least 0.99x,
at most 1.36x, and 1.16x on average, and the analysis time is
increased at least 1.05x, at most 1.99x, and 1.41x on average.
Table II shows the analysis precision without reﬁnement,
with reﬁnement, and their difference. The reﬁnement improvedthe analysis precision from 33.0% to 59.2% by removing 122
false-positive bugs and detecting one more true bug. Among
six bug kinds, the most signiﬁcant improvement is for non-numeric operand bugs (
NoNumber ) from 3.1% to 33.3% by
removing 59 false-positive bugs. The reﬁnement techniquesuccessfully prunes out non-numeric values for numeric types.
The reﬁnement signiﬁcantly increased the analysis precision
also for unknown variable bugs (
UnknownVar ) and assertion
failures ( Assertion ) by removing 29 and 25 false-positive bugs,
respectively. Because JST AR can precisely analyze callees
of function invocations without reﬁnement, we found noimprovement for missing parameter bugs ( MissingParam ).
D. Detection of New Bugs
Among 93 true bugs detected by JST AR , 14 are newly
detected and still exist in the latest version of ECMAScript.
Table III summarizes the bugs, their related JavaScript lan-
guage features, and their life spans. Except for two bugs in
ES12-8, all bugs were introduced in the initial commit of the
open development on September 22, 2015. Thus, 12 newlydetected bugs last for 1,996 days until March 9, 2021. The two
bugs in ES12-8 were created when a contributor introduced the
preﬁxes ?and !on December 16, 2015, and they last for 1,910
days. We reported the newly detected bugs to TC39, and all
of them were conﬁrmed by the committee and will be ﬁxed
in ECMAScript 2022 (ES13).
ES12-1 contains three bugs due to duplicated variable decla-
rations in three syntax-directed algorithms for the
case block
of the switch statement: hasDuplicates inContains-
DuplicateLabels and hasUndefinedLabels inContain-
sUndeﬁnedBreakTarget and ContainsUndeﬁnedContinue-
Target.A case block optionally contains case clauses.
In the beginning of three algorithms, hasDuplicates or
hasUndefinedLabels is deﬁned if the clauses exist. How-
ever, because the same variable is deﬁned again after theconditional steps, three algorithms for
case blocks with case
clauses always have the duplicated variable declaration bugsfor
hasDuplicates orhasUndefinedLabels . Similarly,
ES12-2 contains three bugs caused by the same reason in the
same abstract algorithms for the try statement.
The bug in ES12-3 is a reference bug for a duplicated
declaration of the variable index in the abstract algorithm
CreateMappedArgumentsObject. For each function call inJavaScript programs, an
arguments object is created by Cre-
ateMappedArgumentsObject. In the algorithm, the variable
index is deﬁned to handle the index of a given list of
arguments. However, the variable is deﬁned twice in step 14
and 17 of the algorithm.
ES12-4 contains two reference bugs for the already deﬁned
variable succeeded inDeﬁneOwnProperty ofArray objects
and ArraySetLength . The Array objects are not ordinary
objects and have special algorithms for speciﬁc behaviors.
Two such algorithms are wrapper algorithms of Ordinary-
DeﬁneOwnProperty, which updates object properties. While
614they deﬁne the variable succeeded to represent the result of
OrdinaryDeﬁneOwnProperty, the variable is deﬁned twice
in a speciﬁc condition.
The bug in ES12-5 is a reference bug for the already deﬁned
variable value inEvaluation of the yield *expression. In
the evaluation of yield *e, the variable value is deﬁned
twice to represent 1) the evaluation result of the given expres-
sionein step 3, and 2) the iterator value in step 7.c.viii.1.
The bug in ES12-6 is a reference bug for the unknown
variable ClassHeritage inContains for the tails of class
declarations. A tail of a class declaration consists of an
optional class extension with the extends keyword and a
class body. When the optional class extension does not exist,
the variable ClassHeritage is not deﬁned but the Contains
algorithm tries to access it without any check of its existence.
The bug in ES12-7 is a reference bug for the unknown
variable Statement inEarlyErrors for the ifstatement.
In syntax-directed algorithms, when a production produces
multiple sub-ASTs, it uses ordinal numbers as preﬁxes of
variables. Because the ifstatement contains two sub-ASTs
produced by the Statement production, the ordinal number
preﬁxes are necessary for the variable Statement . However,
the EarlyErrors algorithm for the ifstatement uses the
variable without any ordinal number preﬁxes.
ES12-8 contains two operand type bugs related to abrupt
completions in DeﬁneOwnProperty and GetOwnProperty
forarguments objects. The two algorithms deﬁne or get own
properties of arguments objects. They use the Getalgorithm,
which returns JavaScript values stored in object propertiesor abrupt completions. Thus, they should check whether the
results of Get are abstract completions or not before using
them but they use the results without any checking of abrupt
completion.
VI. R
ELATED WORK
Type analysis of JavaScript speciﬁcations has three related
topics: JavaScript tools, mechanized speciﬁcation extraction,and speciﬁcation-based testing.
a) JavaScript Tools: ECMAScript is the standard lan-
guage speciﬁcation for JavaScript maintained by TC39. In
late 2014, the committee announced its plan to release EC-
MAScript annually and adopt the open development processto quickly adapt to evolving development environments. Var-
ious JavaScript engines such as Google V8 [6], GraalJS [7],
QuickJS [8], and Moddable XS [4] should conform to the syn-tax and semantics described in annually updated ECMAScript.
Beyond JavaScript engines, diverse research projects use
JavaScript speciﬁcations. The main research direction has beenstatic analyzers such as JSAI [12], SAFE [10], TAJS [11],
and WALA [13] based on the abstract interpretation frame-
work [25], [26] with their own analysis techniques. They
deﬁned abstract semantics of the JavaScript semantics de-
scribed in ECMAScript to statically analyze JavaScript pro-grams in a ﬁnite time. Chargu ´eraud et al. [9] presented
JSExplain, a debugger for JavaScript, by implementing areference interpreter in OCaml following the algorithm stepsin ECMAScript closely. For a given JavaScript program, thedebugger interactively produces execution traces investigatedin a browser, with an interface that displays the JavaScript
code and the interpreter’s state. Fragoso Santos et al. [14]
introduced JaVerT, a JavaScript veriﬁcation toolchain, basedon the separation logic with an intermediate goto language
JSIL. JaVerT 2.0 [15] extends it to support compositional
symbolic execution for JavaScript based on bi-abduction.However, because all of them manually handle ECMAScript
with their own intermediate representations, most of them still
target ES5.1 released in 2011 instead of the latest one.
b) Mechanized Speciﬁcation Extraction: Researchers in
various application domains have extracted mechanized spec-iﬁcations from speciﬁcations written in natural languages tohandle the contents in the speciﬁcations automatically. For
system architectures, researchers utilized Natural Language
Processing (NLP) and Machine Learning techniques to extract
formal semantics of small-sized low-level assembly languages
for x86 [19] and ARM [20]. For Java API functions, Zhaiet al. [23] presented a technique to automatically extract
models from their documentation using NLP techniques. For
the JavaScript programming language, Park et al. [5] presented
JISET , a tool that extracts a mechanized speciﬁcation from
ECMAScript. While all the previous JavaScript formal se-mantics [16]–[18] were manually deﬁned,
JISET automatically
extracts formal semantics directly from ECMAScript. We uti-
lized JISET to analyze 864 ECMAScript versions via JST AR .
c) Speciﬁcation-based Testing: Recently, researchers
have utilized speciﬁcations to test their implementations. Fornetwork protocols, Kim et al. [21] proposed a novel ap-
proach named B
ASESPEC, which extracts message structures
from tables in cellular speciﬁcations for L3 protocols to
perform comparative analysis of baseband software. Schumi
and Sun [22] presented SpecTest, which utilized an executablelanguage semantics to perform fuzzing for Java and Solidity
compilers. For JavaScript, Ye et al. [28] presented C
OMFORT ,
a compiler fuzzing framework to detect JavaScript engine bugs
using ECMAScript with deep learning-based language models.
Park et al. [29] extended JISET toJEST , which performs N+1-
version differential testing with Ndifferent JavaScript engines
and a reference interpreter extracted from ECMAScript. JEST
detects not only engine bugs but also speciﬁcation bugs in
ECMAScript using the cross-referencing oracle. However, it
requires multiple JavaScript engines and takes dozens of hours
to test a version of ECMAScript. Instead, JST AR can detect
speciﬁcation bugs without JavaScript engines in two minutes.
Because JST AR uses abstract semantics while JEST uses
concrete semantics, JST AR can quickly analyze more scope
of semantics than JEST .
VII. C ONCLUSION
Checking the correctness of ECMAScript is essential be-
cause an incorrect description in ECMAScript can lead to
wrong implementations of JavaScript engines. However, since
ECMAScript is annually released and developed in an open
process, checking its correctness becomes more labor-intensive
615and error-prone. To alleviate the problem, we propose JST AR ,
a JavaScript Speciﬁcation Type Analyzer using Reﬁnement. It
is the ﬁrst tool that performs type analysis on JavaScript spec-
iﬁcations and detects speciﬁcation bugs using a bug detector.
We also present condition-based reﬁnement for type analysis,
which prunes out infeasible abstract states using conditions
of assertions and branches to improve the analysis precision.
We evaluated JST AR with all 864 versions in the ofﬁcial
ECMAScript repository for the last three years from 2018
to 2021. It took 137.3 seconds on average to perform type
analysis for each version, and detected 157 type-related spec-iﬁcation bugs with 59.2% precision; 93 out of 157 reported
bugs are true bugs. Among them, 14 bugs are newly detected
by
JST AR , and the committee conﬁrmed them all.
ACKNOWLEDGEMENTS
This work was supported by the National Research Founda-
tion of Korea (NRF) (Grants NRF-2017R1A2B3012020 andNRF-2021R1A5A1021944).
R
EFERENCES
[1] (2021) Node.js, a JavaScript runtime built on Chrome’s V8 JavaScript
engine. [Online]. Available: https://nodejs.org/
[2] (2021) Espruino, JavaScript for Microcontrollers. [Online]. Available:
https://www.espruino.com/
[3] (2021) Tessel 2, a robust IoT and robotics development platform.
[Online]. Available: https://tessel.io/
[4] (2021) Moddable, a tool to create open IoT products using
standard JavaScript on low cast microcontrollers. [Online]. Available:
https://www.moddable.com/
[5] J. Park, J. Park, S. An, and S. Ryu, “JISET: JavaScript IR-based Se-
mantics Extraction Toolchain,” in Proceedings of 2020 35th IEEE/ACM
International Conference on Automated Software Engineering (ASE) ,
2020, pp. 647–658.
[6] (2021) Google’s open source high-performance JavaScript and
WebAssembly engine, written in C++. [Online]. Available: https://v8.dev/
[7] (2021) A high performance implementation of the JavaScript
programming language. Built on the GraalVM by Oracle Labs.
[Online]. Available: https://github.com/graalvm/graaljs
[8] (2021) A small and embeddable Javascript engine by Fabrice Bellard
and Charlie Gordon. [Online]. Available: https://bellard.org/quickjs/
[9] A. Chargu ´eraud, A. Schmitt, and T. Wood, “JSExplain: A Double
Debugger for JavaScript,” in Companion Proceedings of the The Web
Conference 2018, 2018, pp. 691–699.
[10] C. Park and S. Ryu, “Scalable and Precise Static Analysis of JavaScript
Applications via Loop-Sensitivity,” in Proceedings of 29th European
Conference on Object-Oriented Programming , 2015, pp. 735–756.
[11] S. H. Jensen, A. Møller, and P. Thiemann, “Type Analysis for
JavaScript,” in Proceedings of the 16th International Symposium on
Static Analysis, 2009, pp. 238–255.
[12] V . Kashyap, K. Dewey, E. A. Kuefner, J. Wagner, K. Gibbons, J. Sar-
racino, B. Wiedermann, and B. Hardekopf, “JSAI: A Static Analysis
Platform for JavaScript,” in Proceedings of the 22nd ACM SIGSOFT
International Symposium on F oundations of Software Engineering , 2014,
pp. 121–132.
[13] M. Sridharan, J. Dolby, S. Chandra, M. Sch ¨afer, and F. Tip, “Correlation
Tracking for Points-to Analysis of JavaScript,” in Proceedings of the
26th European Conference on Object-Oriented Programming, 2012, pp.465–483.
[14] J. Fragoso Santos, P. Maksimovi ´c, D. Naud ˇzi¯unienundeﬁned, T. Wood,
and P. Gardner, “JaVerT: JavaScript Veriﬁcation Toolchain,” in Pro-
ceedings of the 45th ACM SIGPLAN Symposium on Principles ofProgramming Languages , 2018, pp. 1–33.
[15] J. Fragoso Santos, P. Maksimovi ´c, G. Sampaio, and P. Gardner, “JaVerT
2.0: Compositional Symbolic Execution for JavaScript,” in Proceedings
of the 46th ACM SIGPLAN Symposium on Principles of ProgrammingLanguages , 2019, pp. 1–31.[16] A. Guha, C. Saftoiu, and S. Krishnamurthi, “The Essence of Javascript,”
inProceedings of the 24th European Conference on Object-oriented
Programming, 2010, pp. 126–150.
[17] M. Bodin, A. Chargueraud, D. Filaretti, P. Gardner, S. Maffeis,
D. Naudziuniene, A. Schmitt, and G. Smith, “A Trusted MechanisedJavaScript Speciﬁcation,” in Proceedings of the 41st ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages, 2014,pp. 87–100.
[18] D. Park, A. Stef ˘anescu, and G. Ros ¸u, “KJS: A Complete Formal
Semantics of JavaScript,” in Proceedings of the 36th ACM SIGPLAN
Conference on Programming Language Design and Implementation,2015, p. 346–356.
[19] H. Nguyen, “Automatic extraction of x86 formal semantics from its
natural language description,” Information Science , 2018.
[20] A. V . Vu and M. Ogawa, “Formal semantics extraction from natural
language speciﬁcations for ARM,” in International Symposium on
F ormal Methods , 2019, pp. 465–483.
[21] E. Kim, D. Kim, C. Park, I. Yun, and Y . Kim, “BASESPEC: Comparative
Analysis of Baseband Software and Cellular Speciﬁcations for L3
Protocols,” in Proceedings of the 2021 Annual Network and Distributed
System Security Symposium, 2021.
[22] R. Schumi and J. Sun, “SpecTest: Speciﬁcation-Based Compiler Test-
ing,” in Proceedings of the 24th International Conference on Funda-
mental Approaches to Software Engineering , 2021, pp. 269–291.
[23] J. Zhai, J. Huang, S. Ma, X. Zhang, L. Tan, J. Zhao, and F. Qin,
“Automatic Model Generation from Documentation for Java API Func-
tions,” in Proceedings of the 38th International Conference on Software
Engineering, 2016, pp. 380–391.
[24] J. Park and S. Ryu, “Type Analysis for A Modiﬁed IR
ES,” Tech. Rep.,
2021. [Online]. Available: https://bit.ly/3jEuaJ2
[25] P. Cousot and R. Cousot, “Abstract Interpretation: A Uniﬁed Lattice
Model for Static Analysis of Programs by Construction or Approxima-tion of Fixpoints,” in Proceedings of the 4th ACM SIGACT-SIGPLAN
Symposium on Principles of Programming Languages , 1977, pp. 238–
252.
[26] ——, “Abstract interpretation frameworks,” Journal of Logic and Com-
putation, vol. 2, no. 4, pp. 511–547, 1992.
[27] S.-W. Kim, X. Rival, and S. Ryu, “A Theoretical Foundation of
Sensitivity in an Abstract Interpretation Framework,” ACM Transactions
on Programming Languages and Systems , vol. 40, no. 3, pp. 1–44, 2018.
[28] G. Ye, Z. Tang, S. H. Tan, S. Huang, D. Fang, X. Sun, L. Bian, H. Wang,
and Z. Wang, “Automated Conformance Testing for JavaScript Engines
via Deep Compiler Fuzzing,” in Proceedings of the 42nd ACM SIGPLAN
Conference on Programming Language Design and Implementation,
2021.
[29] J. Park, S. An, D. Youn, G. Kim, and S. Ryu, “JEST: N+1-version
Differential Testing of Both JavaScript Engines and Speciﬁcation,” inProceedings of the 43rd International Conference on Software Engi-neering, 2021.
616