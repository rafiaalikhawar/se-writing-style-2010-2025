ModX: Binary Level Partially Imported Third-Party Library
Detection via Program Modularization and Semantic Matching
Can Yang1,2, Zhengzi Xuâˆ—3, Hongxu Chen4, Yang Liu3, Xiaorui Gong1,2, Baoxu Liu1,2
yangcan@iie.ac.cn,zhengzi.xu@ntu.edu.sg,chenhongxu5@huawei.com
yangliu@ntu.edu.sg,gongxiaorui@iie.ac.cn,liubaoxu@iie.ac.cn
School of Cyber Security, UCAS1; Institute of Information Engineering, CAS2; School of Computer Science and
Engineering, NTU3; Huawei Technologies Co., Ltd.4
ABSTRACT
Withtherapidgrowthofsoftware,usingthird-partylibraries(TPLs)
has become increasingly popular. The prosperity of the library us-
agehasprovidedthesoftwareengineerswithahandfulofmethods
to facilitate and boost the program development. Unfortunately,
it also poses great challenges as it becomes much more difficultto manage the large volume of libraries. Researches and studies
have been proposed to detect and understand the TPLs in the soft-
ware.However,mostexistingapproachesrelyonsyntacticfeatures,
whicharenotrobustwhenthesefeaturesarechangedordeliber-
atelyhiddenbytheadversarialparties.Moreover,theseapproaches
typically model each of the imported libraries as a whole, there-
fore,cannotbeappliedtoscenarioswherethehostsoftwareonly
partially uses the library code segments.
To detect both fully and partially imported TPLs at the semantic
level,weproposeModX,aframeworkthatleveragesnovelprogram
modularization techniques to decompose the program into fine-
grained functionality-based modules. By extracting both syntactic
andsemanticfeatures,itmeasuresthedistancebetweenmodulesto
detectsimilarlibrarymodule reuseintheprogram. Experimental
resultsshowthatModXoutperformsothermodularizationtoolsby
distinguishingmorecoherentprogrammoduleswith353%higher
module quality scores and beats other TPL detection tools with on
average 17% better in precision and 8% better in recall.
KEYWORDS
Third-Party Library Detection, Program Modularization, Semantic
Matcing
ACM Reference Format:
Can Yang1,2, Zhengzi Xuâˆ—3, Hongxu Chen4, Yang Liu3, Xiaorui Gong1,2,
Baoxu Liu1,2. 2022. ModX: Binary Level Partially Imported Third-Party
Library Detection via Program Modularization and Semantic Matching.
In44th International Conference on Software Engineering (ICSE â€™22), May
21â€“29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 13 pages. https:
//doi.org/10.1145/3510003.3510627
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.35106271 INTRODUCTION
With the rapid development of commercial software, third-party
library(TPL) reusehas becomemore andmorepopular toensure
high program quality and reduce the unnecessary development
costs. According to [ 3], over 90% of organizations leverage TPLs
inapplicationdevelopment. BothGitHub[ 4]andSonatype[ 2]r e-
portthatover80%ofmostapplicationsâ€™codecomesfromlibrary
dependencies. However, as the size of the software grows bigger
andmorelibrarieswithdifferentdependenciesareinvolved,itisdifficult to track all the imported TPLs accurately. The massiveuse of the uncontrolled libraries will result in issues in the areas
such as code auditing (licence violations) [ 24,42,63,64], malware
affection [ 29], and unexpected vulnerability introduction [ 26]. Un-
derstandingwhichlibrarieshavebeenimportedhasbecomethekeyto address these issues. As a result, TPL detection works have been
proposed, which extractfeatures from known libraries andmatch
them in the target software. For example, BAT [ 31] searches the
reliableconstantsandstringsintheprogramtodetectTPLs.OssPo-
lice[24]alsoleveragestheinvariantliteralstodetectTPLswitha
hierarchicalindexingscheme.Moreover,works[ 38,40,64,67]have
been proposed to improve the TPL detection ability on Android
applications with package dependency identification.
However, existing feature matching-based approaches have two
limitations.First,theyembedfeaturesfromtheentireTPLs.Ifthe
programonlyimportspartofthelibrary,thedetectionalgorithm
may fail due to the lack of fully matched features. To detect the
partiallyimportedlibraries,onepossiblesolutionistomatchthe
library at a more fine-grained level. The only existing ready-to-use
fine-grainedunitintheprogramisthefunction.Methods[ 22,58,
68] have been proposed to match the similar functions between
theprogramsandlibrariestodetecttheTPLusage.However,the
matchingalgorithmsarenotrobustatbinarylevel.Itisbecausethe
functions are very likely to be changed due to different compilersettings [
22]. Therefore, choosing a matching unit which is not
subject to change becomes the key in partial library detection.
The program module, as a conceptual unit, fits this need well
duetothefollowingreasons.First,itconsistsofseveralfunctions
whicharecombinedtogethertoachieveacommonfunctionality.
Sincetheprogramreusesthelibrarybyimportingthefunctionality
groups,themodulecanberegardedasthebasicfine-grainedunit.
Second,sincewithinamodule,thefunctionsareconnectedtoeach
otherto formacallgraph, themoduleitselfwill beenrichedwith
* corresponding author.
13932022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Can Yang1,2, Zhengzi Xuâˆ—3, Hongxu Chen4, Yang Liu3, Xiaorui Gong1,2, Baoxu Liu1,2
moresemanticgraphicalfeatures,whichareunlikelytobechanged
bycompilation.Ithelpstomakethemodulematchingmoreaccu-
rate and robust in the practical real-world TPL detection. However,
to our best knowledge, there are only few works on binary level
program modularization. BCD [ 34] is the state-of-the-art static
approach to decompose the binary executables into modules. How-
ever,themodulesitgeneratedusuallycontainisolatedfunctions,
whichwillhindertheTPLdetectioninthelaterstep.Therefore,the
first challenge of this work is to divide the given program into
meaningful and practical modules.
The second limitation of the existing works is that they rely too
muchonsyntacticfeatures,especiallythestrings,todetectTPLs,
sincestringsoftenbringdirectindicationofthelibraryinformation.However,thiskindoffeaturesmaybedeliberatelymodifiedbyoth-
ers to hide the libraryinformation [ 16]. Especially within modern
malware, strings obfuscation has been one of the most commonly
used evasion techniques [ 19]. To overcome the drawbacks of using
puresyntacticfeatures,plentyoffunctionmatchingandcodeclone
detection researches [ 20,22,25,27,44,58,68] have been proposed
to embrace more semantic features. H owever, these works focus
onfunctionlevelfeatures,whichmaynotbeaccurateinmeasur-
ing module similarity. Also, the module possesses unique features
that can help to distinguish themselves which are not capturedby existing works. Thus, the
second challenge of this work is
to accurately measure the semantic level similarity between the
modules by extracting suitable features.
To this end, we propose ModX, a framework, which utilizes a
novel modularization technique to decompose the program and li-
braryintomodulesandtosemanticallymatchthemtodetecteither
fully or partially imported TPLs. Inspired by the community detec-
tion algorithms [ 15,17,48,49], firstly, ModX defines the module
qualityscoretoassessthecoherenceofthefunctionclusters.Then,
for a given program or a library, it starts to group individual func-
tionstoformmoduleswhilemaximizingtheoverallmodulequality
score. After the programs and libraries have been modularized,ModX extracts both syntactic and semantic features from inter-
andintra-modulelevelsandmeasuresthesimilaritybetweenthe
modules. Based on the similarity, ModX will match and detect the
presenceoflibrarymodulesintheprogramsothatitcanfindthe
fully/partiallyimported TPLs.The experimentalresultsshow that
ModXachieves90.1%precisionand78.2%recallinTPLdetection
of self-crafted programs and 84.3% precision and 61.7% recall in
real-world software, which outperforms other TPL detection tools.
Moreover,sincethemodularizationalgorithmisastand-alonetech-
nique,italsohasgreatapplicantsbesidesTPLdetection.Wealso
test its possibilities in different software engineering tasks such as
reverse engineering and attack surface detection.
In summary, our main contributions are as follows:
â€¢Weproposeabinarylevelprogrammodularizationalgorithm
todecomposeaprogramintofunctionality-basedmodules,
and develop metrics to assess the module quality.
â€¢We propose a semantic measurement algorithm to calculate
the similarities between modules.
â€¢We conduct TPL detection experiments on 128 real-worldprojects, in which ModX outperforms the state-of-the-art
tools over 17% in accuracy on average.â€¢Weevaluatethepotentialapplicationsoftheprogrammodu-
larization algorithm, such as reverse engineering and attack
surface detection.
2 BACKGROUND
2.1 Motivating Example
Inthissectionweillustrateourmotivationwithareal-worldexam-
ple.Watcher[7]isamalwareusedasasecretimplantformonitoring
network traffics. We collect and upload the binary of Watchervari-
anttotheonlineplatformVirusTotal[ 10],whichperformsmalware
detectionvia60anti-virusengines.Theresultshowsthatonly7outof60leadingsecurityvendorssuccessfullydetectthemalware[
11].
Therestfailtodetectthemalwarevariantbecauseitchangesthe
binary instructions and the string literals to obfuscate itself.
Topreciselydetectthemalware,securityexpertscanusecom-
ponent analysis to determine the TPLs used by this malware as an
indicator of the malware presence. H owever, after the malware has
been detected and its signature has been recorded in the anti-virus
database, Watcheralsostartstoevolveandhideitself.Itremoves
all the strings inside the program since it does not need them tocarry malicious activities. Also, instead of using the entire pcaplibrary or dynamically linking it, it only uses 8 export functions
(The entire pcap library has 84 export functions). However, after
the evolution, existing tools fail to find the library. According toour experiment, the state-of-the-art TPL detection tool BAT [
31]
outputsseveralfalsepositives.Thus,themalwaresuccessfullyhides
the pcap library and escapes from the anti-malware detection.
Weproposetheprogrammodularizationtechniquetodividethe
pcaplibraryinto16modules.Wematchthemodulesinthemalwarebinaryanddetectthatitreuses3ofthemodules.Therefore,wehave
provided a strong evidence to confirm the binary to be Watcher.
Theapproachismorerobustsincethemalwarecannotlivewithout
thesupportofpcap.Nomatterwhatchangesthemalwaremakestohidethelibrary,aslongasitdoesnotchangethefunctionsemantics,
our tool can still find the trace of the library pcap.
2.2 Background Information
In this section, we briefly discuss about some software engineering
concepts used in our paper.
2.2.1 Third-PartyLibrary. TPLisareusablesoftwarecomponent
beingdevelopedbysomepartiesotherthantheoriginaldevelop-
mentvendor.Itisdistributedfreelyorundercertainlicencepolicies.
It is used to avoid the repeating development of software with the
samefunctionalitiessothatitcansavetimeandresources.However,duetolackofsupportfromthethirdparties,usingitalsointroduce
dependency issues and security concerns.
2.2.2 CommunityDetection Algorithm. Ina complexrelationnet-
work,nodestendtobegatheredtoformcommunitystructures.The
communitydetectionalgorithmaimstorevealthehiddengroup-
ing information of the communities, which are frequently used
in distributed network systems. It partitions the network graph
intosmallclustersanddetectsthecommunities.Inthiswork,the
entire program or library can be regarded as a graph network with
thefunctionsrepresentingthenodes.Programmodularizationis
1394
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ModX: Binary Level Partially Imported Third-Party Library Detection via Program Modularization and Semantic Matching ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
similartothecommunitydetectionalgorithm,whichtriestogroup
functions into different communities (modules).
2.2.3 BinaryCodeCloneDetection. Binarycodeclonedetection
triestofindsimilarfunctionsinthebinaryexecutables.Itisoften
usedtoauditthesoftwareoriginalityandtosearchforrecurring
software bugs caused by code reuse and sharing. The traditional
algorithmsextractdifferentfeaturestorepresentthecodeandmea-
surethecodesimilaritybasedonthesefeatures.Inthiswork,weaim
topropose algorithms tomeasurethesimilarity betweenmodules
rather than functions so that it can be more robust to detect TPLs.
We follow a similar approach as the traditional clone detection but
with a different feature set.
3 METHODOLOGY
3.1 Overview
Figure1showstheworkflowof ModX.Itconsistsoftwophases,
namely Binary Modularization and TPL Detection, to predict TPLs
from a binary program. In the first phase, it proposes a module
quality metric, which is based on community detection algorithm
with program specific adjustments. Then, it leverages a novel algo-
rithmwithheuristic biasestodecomposethe binaryintomodules
based on the metric. In the second phase, ModX performs the TPL
detection by matching program modules with TPL modules. It ex-
tracts syntactic features, graph topology features, and function
levelfeaturestomeasurethesimilaritybetweenmodules.Afterthe
matching, it also introduces module and library importance scores
to help improve the library detection accuracy.
3.1.1 Assumptions. First,inthiswork,weassumethatthemodules
of the program do not overlap with each other. For example, if
moduleð´andðµboth call the function ð‘“, thenð‘“will have a high
chancetobedividedintoaseparatedmodule ð¶.ð‘“willnotbelongto
eitherð´orðµ. Second, we assume that the content of each TPL will
notchangesignificantly.SinceModXaimstomatchTPLsacross
differentversionsusingsemanticfeatures,ifthesemanticsofthe
library have been changed significantly, ModX will fail to produce
accurate results.
3.2 Binary Program Modularization
Inourpaper,theprogrammodularizationtechniqueconsistsoftwo
components, the module quality metric and the actual modular-
ization algorithm. The module metric aims to measure the quality
gain from grouping functions into clusters, and the modularization
algorithm combines the functions in the way which will maximize
the overall module quality score.
3.2.1 Module Quality Assessment Design. The program consists of
functionswhichareconnectedwitheachotherthroughfunction
calls. The relationships can be represented by a call graph with
functions as the nodes and calls as the edges. Functions with simi-
lar functionalities are likely to appear close to each other to form a
communityinthegraph.Theprogrammodularizationprocessaims
to find these communities, which is very similar to the community
detection in a network. Therefore, to design a sound and practi-cal module quality assessment metric, we adopt the communitydetection quality metrics as the baseline. Then, we modify the met-
ricswithsoftwarespecificheuristicstofitinthespecificprogram
modularization task.Girvanâ€“Newman Algorithm
Inspiredbythecommunitydetec-
tion algorithm, we choose Girvanâ€“Newman Modularity Quality
(GN-MQ) [ 49] as the baseline metric since it has a good approxi-
mation on the program structure. It is the first algorithm proposed
formodularityoptimization,andhasfar-reachingimpactsonfol-
lowing researches [ 15,17,36]. Basically, given a network which
has been divided into multiple clusters, the metric counts the con-
nectededgesbetweeneachpairofnodesfromthesameclustersand
sums the number of such occurrences with adaptive weights based
on node degrees. If there is no connection between the nodes in
the same cluster, the weight will be assigned with negative values,
whichdecreasestheoverallqualityscore.Specifically,thequality
is calculated according to the Equation 1
ð‘„=1
2ð‘š/summationdisplay.1
ð‘–,ð‘—[ð´ð‘–ð‘—âˆ’ð‘˜ð‘–ð‘˜ð‘—
2ð‘š]ð›¿(ð¶ð‘–,ð¶ð‘—) (1)
whereð‘–andð‘—denotesthe ð‘–thnodeandthe ð‘—thnodeinthegraph
respectively, ð´ð‘–ð‘—denoteswhethernode ð‘–andð‘—areconnectedornot,
whichhasavalueeither1or0, ð‘˜ð‘–denotesthein-andout-degreeof
nodeð‘–,ð‘šis thenumber ofedgesin thegraph, ð¶ð‘–is thecommunity
wherenode ð‘–belongsto, ð›¿(ð¶ð‘–,ð¶ð‘—)standsforwhethernode ð‘–and
ð‘—belong to the same cluster, which has a value either 1 or 0. As
shown in this Equation, if the nodes ð‘–andð‘—belong to the same
clusterandtheyareconnectedtoeachother,thenthequalityscore
willincrease.Otherwise,ifthetwonodesfromthesameclusterare
notconnected,thescorewillbedecreasedsince ð´ð‘–ð‘—willbesetto
0andtheterm ð´ð‘–ð‘—âˆ’ð‘˜ð‘–ð‘˜ð‘—/2ð‘šwillbecomenegative.Therefore,in
this metric, the high quality score reflects that the high coherence
among the nodes within the cluster. Moreover, due to the negative
termâˆ’ð‘˜ð‘–ð‘˜ð‘—/2ð‘š, nodes having less in- and out-degree will have
moreweightsthanothers.Therefore,themetricalsodiscourages
the connectivity between nodes from different clusters.FunctionVolumeAdjustment.
Besidestheconnectivitybetween
nodes, the program modules have unique features that can be used
asthemodulequalityindicators.Functionvolumeisoneofthem,
which is specified by the number of statements in the function. In
the program, functions that have large volumes tend to perform
somecorefunctionalities,whereas,smallfunctionswilllikelybetheutilityfunctions[
14,58].Acompleteandcoherentprogrammodule
will consist of a small group of large-volume functions to perform
thecorefunctionalitiesandsomesmall-volumefunctions,which
are around the core group to provide useful utilities. Therefore,
we propose thefunction volume weight propagation algorithmto
addtheweightadjustmenttothemetricsothatitcanfavourthe
complete and coherence modules.
The aim of the propagation algorithm is to assign different
weights to each of the functions based on its volume and con-
nectivity. It functions in a way that is similar to the PageRank [ 50]
algorithm in website ranking. For programs that have hierarchi-cal structures, the functions at the top levels tend to control the
behaviourofthelow-levelfunctionsviafunctioncalls.Thepropaga-
tion algorithm guarantees that the top-level functions will receive
more attention compared to the low-level ones, which results in
1395
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Can Yang1,2, Zhengzi Xuâˆ—3, Hongxu Chen4, Yang Liu3, Xiaorui Gong1,2, Baoxu Liu1,2
Module Matching
Topology FeaturesSyntactic Features
Function FeaturesSimilar Scores:Binary
ModularizationTPL Detection
Ranking & Sorting
MatchesTPL Modules Database
Lib 1 Lib 2 Lib 3
Â·Â·Â·
2ndË–
Lib21stË–Lib1
3rdË–Â·Â·Â·Modules
Â·Â·Â·Program Specific
AdjustmentsClustering with
Heuristic Biases
Function Call Graphs
Figure 1: Overall Workflow of ModX
more weights being assigned to the top-level functions. Therefore,
whenwemodularizetheprograms,weareabletobeginwiththese
heavy-weighted functions to avoid generating modules with only
small utility functions.
Thedetailedstepsareasfollow:First,eachfunctionisinitialized
withitsownvolumevalue(e.g.thenumberofstatements).Then,
wechecktheout-degreeofeachfunctionandlookfortheendnode
which has 0 out-degree. Since the end node does not call other
functions, its weight will not be affected by the rest of functions in
thepropagation.Next,theweightoftheendnodewillbepropagated
backwardtoitsparentnode(thecallerfunction).Weidentifythe
number of function calls in the parent and adjust the weights by
normalizingthemagainstthenumberofcalls.Thepropagationis
defined as Equation 2,
ð¹ð‘‰/prime(ð‘¢)=ð¹ð‘‰(ð‘¢)+ð‘/summationdisplay.1
ð‘£âˆˆð¸(ð‘¢)ð¹ð‘‰(ð‘£)
ð¶ð‘£(2)
whereð¹ð‘‰referstothefunctionvolumeweight, ð‘¢andð‘£represent
thefunctionnodeswith ð‘¢callsð‘£.ð¸(ð‘¢)isthesetoftheendnodes,
whichð‘¢calls.ð¶ð‘£denotes the number of caller functions of ð‘£.ð‘is a
factorusedfornormalization.The ð¹ð‘‰ofthetoplevelnode ð‘¢will
beupdatedbyaddingtheweightsofthelowerlevelnodes.After
the propagation, we remove the end node and the edges which
connecttoitfromthecallgraph.Ifthereareloopsinthecallgraph,
wemergethefunctions intheloopintoonenodeand removethe
branch edge to generate a new end node. We repeat the process to
propagatetheweightsandremovetheendnodesuntilthereareno
more nodes in the graph.
Modified Quality Metric Besides adding in the volume size ad-
justment,wealsochangethemetricfrommeasuringtheindirect
graph to directed graph since the function calls have directions
(from caller to callee function). Therefore, when calculating the
termâˆ’ð‘˜ð‘–ð‘˜ð‘—/2ð‘šof Equation 1 [ 15], we modify it to incorporate the
directioninformation.Specifically,weonlymeasuretheout-degree
of the parent node and in-degree of the child node so that we can-
notavoidthenoisefromotherirrelevantcalledges.Thedirected
graphmodelqualitymetricwith volumeadjustmentiscalculated
according to the Equation 3,ð‘„=1
2ð‘Š/summationdisplay.1
ð‘–,ð‘—[ð‘¤ð‘–ð‘—âˆ’ð‘˜ð‘œð‘¢ð‘¡
ð‘–ð‘˜ð‘–ð‘›
ð‘—
2ð‘Š]ð›¿(ð¶ð‘–,ð¶ð‘—) (3)
whereð‘¤ð‘–ð‘—represents the weight of the edge between function ð‘–
andð‘—, which has the value equal to the function volume weight
ofð‘—.ð‘Šdenotesthesumofalltheweightforeachoftheedgesin
the graph, ð‘˜ð‘œð‘¢ð‘¡
ð‘–andð‘˜ð‘–ð‘›
ð‘—specify the weighted out-degree of node
i and the weighted in-degree of node j, the rest of the notationsare the same as Equation 1. With the modified quality score, the
functionwithalargevolumewillbemorelikelytobegroupedfirst,
since grouping them will output a higher quality score due to their
higherweights.Therefore,theresultingmodulesaremorecoherent
than the modules generated by treating all the functions equally.
3.2.2 ModularizationAlgorithm. Basedontheproposedmodule
qualityscore,westarttogroupfunctionsintheprogramtogenerate
modules. We regard each function as an individual cluster and
repeatedlycombinetwoclustersusingthefastunfoldingalgorithm
while maximizing the overall quality score. Moreover, to make the
generatedmodulesmoreintuitive,weaddintwobiasestoguide
the modularization process.Fast Unfolding Louvain Algorithm.
To boost the modulariza-
tionspeed,wechoosefastunfoldingLouvain[ 17],whichisagreedy
optimization algorithm,to guidethe groupingprocess. Thealgo-rithm is adapted to optimize the
ð‘„in Equation 3. The modified
Louvainalgorithmworksasfollows.First,itassignseachnodein
the network to an individual module. Then, it tries to merge any
moduleð‘Ÿwith its neighbor module ð‘ . The merging will change the
module quality by Î”ð‘„in Equation 4.
Î”ð‘„ð‘Ÿ,ð‘ =ð‘’ð‘–ð‘›
ð‘Ÿ,ð‘ +ð‘’ð‘œð‘¢ð‘¡
ð‘Ÿ,ð‘ +ð‘’ð‘–ð‘›
ð‘ ,ð‘Ÿ+ð‘’ð‘œð‘¢ð‘¡
ð‘ ,ð‘Ÿâˆ’2âˆ—(ð‘Žð‘–ð‘›
ð‘Ÿâˆ—ð‘Žð‘–ð‘›ð‘ +ð‘Žð‘œð‘¢ð‘¡
ð‘Ÿâˆ—ð‘Žð‘œð‘¢ð‘¡
ð‘ )(4)
where:
ð‘’ð‘–ð‘›
ð‘Ÿ,ð‘ =/summationdisplay.1
ð‘–âˆˆð‘Ÿ/summationdisplay.1
ð‘—âˆˆð‘ ð‘˜ð‘–ð‘›
ð‘–ð‘˜ð‘œð‘¢ð‘¡
ð‘—
2ð‘Š;ð‘’ð‘œð‘¢ð‘¡
ð‘Ÿ,ð‘ =/summationdisplay.1
ð‘–âˆˆð‘Ÿ/summationdisplay.1
ð‘—âˆˆð‘ ð‘˜ð‘œð‘¢ð‘¡
ð‘–ð‘˜ð‘–ð‘›
ð‘—
2ð‘Š(5)
ð‘Žð‘–ð‘›ð‘Ÿ=/summationdisplay.1
ð‘ ð‘’ð‘ ,ð‘Ÿð›¿(ð‘Ÿ,ð‘ );ð‘Žð‘œð‘¢ð‘¡
ð‘Ÿ=/summationdisplay.1
ð‘ ð‘’ð‘Ÿ,ð‘ ð›¿(ð‘Ÿ,ð‘ )(6)
where the Equation 4, 5 and 6 can be derived from the previous
work [15,48]. The notations are the same as Equation 3. The algo-
rithmwillmergethecommunity ð‘Ÿandð‘ ,ifthemergingincreases
1396
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ModX: Binary Level Partially Imported Third-Party Library Detection via Program Modularization and Semantic Matching ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
theoverallmodulequalityscorethemost.Thealgorithmwillrepeat
thesamesteptogreedilymergethenodesuntilthereisnomore
mergingoperationcouldbeapplied.Thecoremechanismof Fast
Unfolding is the calculation of the change to the global Modularity
Quality ( Î”ð‘„) for each merging operation. To give higher priorities
tothenodesthatshouldbefirstlyclusteredaccordingtoexpertsâ€™
experience,weintroducetwobiasestothe Î”ð‘„.Themodified Î”ð‘„
calculation is as follows:
Î”ð‘„=Î”ð‘„/primeÃ—ðµð‘™Ã—ðµð‘’ (7)
where Î”ð‘„/primeis the basic Î”ð‘„calculated in Equation 4. The ðµð‘™andðµð‘’
arelocalityandentry-limitbiasintroducedtoguidethemodular-
ization procedures.
Locality Bias. During program development, functions that are
designed to perform the same task are likely to be placed together
(e.g. in the same source file). As a result, after being compiled
into binary executable, these functions will be placed one after
anothercontinuously.Withthisheuristics,ModXintroducesthe
localitybiastothemodularizationalgorithm.Thekeyideaisthat
weexpecttogroupfunctionswhichareclosetoeachothersince
they have a higher chance to perform the same task. To achieve
this,eachfunctionisassignedwithanindexingnumberbasedon
itslocationsequenceinthebinary.Consequently,eachmodulewillhaveanaveragevalueofthefunctionindexing.Then,wedefinethe
dispersion scope ð·ð‘†of a module as the summation of the distances
from each of the functions indexing to the average value. Whenmerging the two modules, we can update the new values of the
average indexing and the ð·ð‘†. We limit the maximum ð·ð‘†to be the
numberoffunctionsintheentireprogramdividedby100.Ifthenew
ð·ð‘†exceedsthelimit,themergingalgorithmwillbediscouragedby
100%tocombinethetwomodules.Last,wescaletheencouragement
and discouragement to the range [0, 3], naming it ðµð‘™as the first
biasto Î”ð‘„.InEquation7,the ð‘„/primewillbeexpandedbythe ðµð‘™from0
to300%.Inthisway,weaddinthebiastoletthealgorithmconsiderthenearerfunctionsfirstratherthanreachingtofunctionsthatare
very far away.
ModuleEntryLimitBias. AccordingtotheSingle-Responsibility
Principle [ 5], each method or module should have a single func-
tionality, which should be encapsulated by it. We would like the
moduletohavelimitedentriestoensurethesingleandencapsulated
functionality.Therefore,weintroduceanentrybias ðµð‘’toduring
themodularization.Inthiswork,themoduleentryisdefinedasa
function node that only has its caller functions outside the module.
The Entry Quality (EQ) score is the number of entries of a particu-
larmodule.Whencalculatingthe Î”ð‘„ð‘Ÿ,ð‘ combiningmodule ð‘Ÿand
moduleð‘ together, the Î”ð¸ð‘„ð‘Ÿð‘ is defined as the difference between
theð¸ð‘„of the new module and the average value of ð¸ð‘„ð‘Ÿplusð¸ð‘„ð‘ .
Afterhaving ð¸ð‘„,wecalculatethebias Î”ðµð‘’accordingtoEquation8.
TheÎ”ðµð‘’will encourage to merge modules that could decrease the
number of entries, and in otherwise discourage to them.
Î”ðµð‘’=2âˆ’Î”ð¸ð‘„(8)
3.3 Third-Party Library Detection
After modularizing the program and the TPLs, we propose the
similarity measurement algorithm to match the modules based on
syntacticandsemanticfeaturesanddetecttheTPLsintheprogram.Syntactic
SimilarityGraph SimilarityFunction
SimilarityModules for Detecting
TF-IDF AdjustmentFunc
Func Func
FuncFunc
 Func
Func
FuncFunc Embedded
Vector
 1) Readable Strings
2) Constant Numbers
Greedy Matching
1) Data Behaviors
2) Switch Tables3) Anchor PointsModules from LibrariesModule
Similarity
Similarity
ScoresMI
ScoresNo. of
Modules
LI
ScoresNo. of
Libraries
Matched
ModuleCorresponding Libraries
Figure 2: Module Matching Overview
Figure2showstheoverviewoftheTPLsdetectionprocedurevia
module matching.
3.3.1 Module Similarity Measurement. Syntactic Features. In-
spired by syntactic feature based library detection works, we in-
corporatesimilarfeaturesinourmodulesimilaritymeasurement.
Specifically, we use the strings literal and constant numbers as the
syntacticfeatures.Stringliteralisthemostsignificantfeaturesince
itusuallyhasuniquevalues,whichcanbeeasilydistinguished.If
two functions in two modules have the same string literal, they
haveahighchancetobethesamefunction.However,thereareonly
asmallportionoffunctionswhichhavestringliterals.Therefore,
strings can only help us to accurately match some of the functions
andmodules.Comparedtostringliteral,theconstantswillhaveless
uniqueness. For example, we can detect a constant 0, which is used
in the branching comparison. Meanwhile, constant 0 can be also
usedtofreethememoryspace.Therefore,thiskindofconstantmaynotcarryusefulinformationforsimilaritymeasurement.Toaddress
it,weadopttheTF-IDF[ 53]algorithmtoassignmoreweightsto
moreuniqueconstants,whichusuallyappearlessfrequentlyinthe
module than the rest.Graph Similarity Features.
The module consists of functions
which call each other to form a call graph. We use propagation
graph kernel [ 47] algorithm to measure the call graph similarity.
The algorithm tries to measure the graph and sub-graph structure
similaritybetweentwographs.Formorefine-grainedfeatures,suchaseachedgeofthecallgraph,weadopttheedgeembeddingmethod
from RouAlign [ 62] to measure the edge similarity in the topology.
RouAlignpromotesarobustwaytoembedfeaturesoffunctioncallgraphs With the method, the edges of a particular module could be
embeddedintovectors.Andthenwecouldfigureoutwhichpart
of the graph is similarby vector searching, which is time efficient
and scalable.FunctionSimilarity Features.
Thesefeaturesmeasurethesimi-
laritybetweenfunctionsinthemodules.Sinceamoduleconsists
ofmultiple functions,thescorewill beaggregatedtomeasure the
modulesimilarity.Tocalculatethescore,weneedtoaddresstwo
problems. First, given two functions, how to measure their similar-
ity.Second,howtochoosethetwofunctionsfromthetwomodules
1397
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Can Yang1,2, Zhengzi Xuâˆ—3, Hongxu Chen4, Yang Liu3, Xiaorui Gong1,2, Baoxu Liu1,2
tocomparewith.Forthefirstproblem,weleverageastate-of-the-art
binary function matching tool Gemini [ 58] to produce a similarity
score between two given functions. The main idea of Gemini is to
embed the function control flow graph into a vector and calculate
thevectordifferencestodeterminethefunctionsimilarity.Basedon
ourexperiment,Geminihasarelativelygoodperformancewhich
can save the time in the feature generation step.
Amodulemayconsistoffunctionswithdifferentfunctionalities.
For example, a module may have functions to perform the core
operation, functions to do the error handling, and functions tocommunicate with other modules. Therefore, we would like to
compare functions with similar functionality rather than the ones
withdifferentfunctionalities,whichwillgivealowsimilarityscore.
Moreover, since each module will consist of multiple functions,
calculating the pairwise function similarity takes time. Therefore,
forthesecondproblem,weadoptadrill-downapproachtoselect
function pairs. As discovered in [ 34], similar functions usually
use a common group of data; or they will be referred to by the
same pointers. Therefore, to selectively measure the similarity, we
identifytwotypesofanchorpointswithinthemodulestohelpustolocatefunctionsthatarelikelytohavethesamefunctionalities.First,inonemodule,ifwedetectmultiplefunctionsaccessingthedatain
the same memory space, we will mark it as the anchor point (type
1); and wetry to detectthe similar anchor pointin other modules
andmeasurethesimilarityamongtherelatedfunctions.Second,we
accessing the dispatch table in the module if it exists. The dispatch
table is a table of pointers or memory addresses referring to the
functions. We will use these functions as the anchor point (type 2).
We will compare the similarity among the functions that belong to
the same type of anchor points.
3.3.2 TPLDetection. ModXperformsTPL detectionby checking
whetheramodulefromthetargetprogramcouldbematchedtoany
ofthemodulesinthesignatureTPLs.Foreachmoduleinthetargetprogram,ModXmatchesitagainstallthemodulesgeneratedinthe
signatureTPLdatabasebysummarizingthesimilaritiesbetween
each feature discussed in Section 3.3.1. ModX ranks the candidate
modules by the similarity score and selects the modules with high
and distinguishable similarity.
However, the matching result may contain false positives due
tothefollowingreasons:First,someofthelibrariesmaycontainsimilar modules. It is difficult to distinguish from which library
themodulecomes.Thiswillhappenespeciallywhenthemodules
aresmallinsize,whichwillconsistofsimplestructureswithfew
functions. Second, the TPLs are in different sizes, which will bring
unfairnessduringthematching.Forexample, libbz2libraryhas
only 5 modules with 81 functions, while libcrypto library has
over 186 modules with 6559 functions. Therefore, if ModX detects
a module of library libbz2, we may have high confidence that
the library is reused in the program. On the contrary, detecting
onlyonemoduleoflibrary libcrypto maysuggestthatitisafalse
alarm.
To further improve the accuracy, we adopt two adjustments.
First, we introduce the Module Importance (MI) score to select the
modules which are considered to be more important. In the heuris-
tics,webelievethatthebiggerthemodulesize,themoreimportant
the module would be. It is because that bigger modules tend tohave more unique structures which may not be miss-matched withothermodules.Therefore,MIisspecifiedinEquation9,where
|ð‘šð‘˜|
denotesthetotalfunctionsinthe ð‘˜-thmodule, ð‘›isthetotalnumber
of modules. Second, for a library, its importance ought to havepositive correlations with the reference frequency, and negative
correlationwiththenumberofthemodulesthatitcontains.The
morefrequentlyonelibraryisneededbyotherbinaries,andthelessnumberofmodulesthelibraryhas,themoreimportantitshouldbe
if its modules are detected in the program. The Equation 10 shows
the Library Importance (LI) for library â„Ž, where the |ð‘™â„Ž|denotes
the number of modules in the â„Ž-th library, the ðœˆ(ð‘™â„Ž)denotes the
timesthelibrary ð‘™â„Žisreferredto.Itisdifficulttodeterminewhether
a module is used in the detected binary, but the module usage
frequencycouldbeapproximatedbythelibraryusagefrequency.
Withthisassumption,wegivetheMatchingConfidence(MC)by
Equation 11 to the module ð‘˜of the library â„Ž. A higher MC score
meansthemorecreditablethedetectiononthemodule.Finally,we
combine thesimilarity scoresin Section3.3.1 with theMC togivethe final results of the TPL detection.
ð‘€ð¼
ð‘˜=|ð‘šð‘˜|/summationtext.1ð‘›
ð‘–|ð‘šð‘–|/ð‘›(9)
ð¿ð¼â„Ž=log(ðœˆ(ð‘™â„Ž)+1)
|ð‘™â„Ž|(10)
ð‘€ð¶ð‘˜=ð‘€ð¼ð‘˜Ã—ð¿ð¼â„Ž (11)
4 EVALUATION
In the experiments, we aim to answer the following research ques-
tions:
RQ1: What is the quality of the modules generated by ModX com-
pared to other program modularization works?RQ2
:Whatistheaccuracyof ModXindetectingTPLsinbinary
programs compared to related works?RQ3
:Whatisthebreakdownperformanceof ModXinmodular-
ization and library detection?RQ4
:Whatarethereal-worldusecasesofpartiallibrarydetection?
RQ5: What are other possible applications of program modulariza-
tion in software engineering and security?
4.1 Module Quality Evaluation (RQ1)
Module Quality Metrics Selection. To evaluate the quality of
the generated modules by ModX, we have selected 7 metrics from
different aspects.First, since theprogrammodularization process
is very similar to the community detection process, we choosethe commonly used community quality metrics to measure the
modules. [ 49] promotes the Orign MQ, which measures the quality
for an unweighted and undirected network. Moreover, since the
programcallgraphisdirectedandwehaveassignedweightstothegraph,wealsoselected DirectedMQ [
15]andWeightedandDirected
MQ[36]astheevaluationcriteria.Second,wehavereviewedthe
source code level program modularization works and selected 2
metricsusedinthestate-of-the-arttoolsâ€™evaluation,namely Bunch
MQ[42] andTurbo MQ [39,41]. The Bunch MQ [ 42] is designed
to reward the creation of highly cohesive clusters, and to penalize
excessive coupling between clusters. Turbo MQ is a lightweight
metric that includes edge weights. Last, from the program analysis
1398
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ModX: Binary Level Partially Imported Third-Party Library Detection via Program Modularization and Semantic Matching ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 1: The modularization results for several metrics .
Metrics ModX BCD AR modular-
ization
Orign MQ [49] 0.020299* 0.006988 0.019758
Directed MQ [15] 0.019193* 0.005998 0.011387
Weighted and
Directed MQ0.029362 0.016864 0.040163*
Bunch MQ [42] 0.007333* 0.001206 0.000403
Turbo MQ [39] 0.553336* 0.148786 0.045623
No. of Entries 1.819864* 11.799936 5.801478
No. of Isolated
Clusters1.000000* 15.223941 5.737548
The * denotes that the score is of the best performance out of the three.
pointof view,we wouldexpect thatfor eachmodule thereshould
beasfewentrypointsaspossible.Lessentrypointssuggestthatthe
module can be used/called in less different ways, which ensure the
module coherence. Moreover, we would like the clustering results
to be smooth, which means that there should be as few isolated
clusters as possible. Therefore, we count the average number of
Entriesandthenumberof IsolatedClusters withineachmoduleas
the last two metrics.RelatedWorkSelection.
Wehavechosentwoalgorithmstocom-
pared withto evaluatethe modulequality. First,as faras wehave
reviewed, BCDisthestate-of-the-artbinarylevelprogrammodular-
izationtoolintheliterature.Therefore,wehavecomparedModX
withBCDonthe7metrics.Second,theprogramdeveloperwilltend
to place functions with similar functionalities into the same file
atsourcecodelevel.Wecanregardeachofthefilesasaprogram
module so that the program is modularized naturally during the
development.Usually,thistypeofprogramwillbecompiledinto
archive files (".a" as suffix), which consists of many object files (".o"
assuffix).Wemeasurethequalityofthemodulesgeneratedaccord-ingtotheobjectfileboundaries,denotedas ARModularization and
compare it with ModX.Module Quality Assessment.
We have selected 106 commonly
used binaries compiled by nix [ 23] and run ModX and BCD on
them.ForARModularizationtechnique,sincenotallthebinaries
are compiled into archive files, we only tested it on 102 systemlibrary binaries, which have the archive files. Table 1 shows theaverage scores for each of the metrics of ModX, BCD and ARModularization respectively. In Table1, the first five metrics are
Modularity metrics. Among them, four metrics are used in related
works[15,39,42,49].Modularity[ 15]measuresthestrengthofdi-
visionofagraphnetworkintomodules.Thelasttwometricsare
heuristic statistical metrics. They measure the readability and rea-
sonableness of the modules. Generally, our method reaches higher
module quality scores than other modularization methods and has
less entries and isolated clusters per module. The only metric that
ARModularizationbeatsModXisthe WeightedandDirectedMQ.It
is becausethat when calculating themetric, the finalscore will be
normalizedagainstthetotalweightsoftheprogram.TheprogramsusedtomeasurethequalityforARModularizationtendtohaveless
weights than the programs used to test ModX and BCD. Therefore,
AR Modularization has a higher score even if its module quality is
lower than other tools.Human Labeled Modularization Comparison
We have collab-
orated with a big software vendor (name anonymized), which has
greatinteresttothesoftwarestructureunderstanding.Therefore,
itemployssoftwareengineeringexpertstomanuallymodularizeglob_filename
glob_dir_to_array
dequote_pathname
xdupmbstowcsglob_pattern_p xstrmatchstrmatchglob_vector
glob_testdir
wmatchlenmatch_pattern_char
match_pattern_wchar
wcsmatch
rangecmp
umatchlen
xmbsrtowcs
(a) Manually Labelled Module
remove_pattern
remove_upattern
match_pattern_char strmatch
rangecmpumatchlen
extmatchmatch_upattern
find_string_in_alist find_index_in_alist
wcsmatch
internal_wcsmatch
internal_wcsmatch_0xstrmatch
xdupmbstowcsinternal_strmatch
internal_strmatch_0
gmatch
patscan patscan_wcextmatch_wcparse_collsymgmatch_wc
parse_collwsym
(b) ModX Generated Module
Figure3:ComparisonbetweenManualandModXModular-ization Results
a real-world project Bash, which is a commonly used program for
commandprocessing. We alsocompare theresults of ModX with
it.Inthisexperiment,thesourcecodeBashversion4.2.0has2761
functions.Theexpertsmanuallydecomposethesoftwareinto13
modules. Then, we compile the source code into binary and apply
ModX to generate 198 modules.
Toevaluatetheresults,weproposeametrictomeasuretheover-
lapping between the generated modules and the human labelledmodules.Weselectall thefunctionsin onemodulegeneratedby
ModX and count the number of modules that the same set of func-
tions appear in the manually labelled modules. For example, if agenerated module contains three functions A, B and C. Function
A belongs to labelled module I, while function B and C belong
to labelled module II. Therefore, the overlap metric score will be2
/1=2. The average overlap score for each generated module is
1.45, which suggests that the modules generated by ModX have
ahighoverlapratiowiththehumanlabelledmodules.Therefore,
ModX will be a good solution to save the manpower to produce
precise modules automatically.
Moreover,Figure3(a)and(b)showstheconcreteexampleofthe
modulesgeneratedbyhumanexpertsandbyModXrespectively.
Since human experts group the source files to form the modules,
there may be some isolated functions in each module. As shown in
(a),there are6 isolatedfunctionswith 4beingmarked indifferent
color boxes.From thenames, weknow thatmost ofthe functions
inthismodulehavethesimilarfunctionalitytoprocesswild-cast
strings.ForthegeneratedmoduleinFigure3(b),ModXhasgrouped
the4isolatedfunctions(markedinthecolorboxes)intoabigger
1399
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Can Yang1,2, Zhengzi Xuâˆ—3, Hongxu Chen4, Yang Liu3, Xiaorui Gong1,2, Baoxu Liu1,2
module with some additional related functions. From the function
names, we can notice that most of the functions are with the same
functionality, which suggests that ModX has produced a more
complete module than the manually labelled approach.
Answering RQ1: Compared to the state-of-the-art pro-
gram modularization work, the average ratio in which
ModX outperforms in Modularity Quality(MQ) metrics is
3.53times.Moreover,thegeneratedmodulesaresimilarto
the modules decided by human experts.
4.2 Library Detection Accuracy Evaluation
(RQ2)
BinaryProgramandTPLDataSet. Weevaluatedourtoolontwo
setsofbinaries.First,weleveragethepackagemanager,nix[ 23],
tocollect programswiththeir buildingdependenceon Linux.Nix
has provided a service to automatically build binaries with both
static-linked and dynamic-linked libraries. We built all available
programs under the category "Applications" on nix packages store,
andsuccessfullygained106binarieswithgroundtruthasthetesting
data set. Second, since nix does not guarantee to include all therequired libraries in the binaries according to our inspection, togenerate the data set with the real ground truth, we manuallybuild a set of binaries on Ubuntu 20.04. Specifically, we choose
7 commonly used programs and build them with statically and
dynamically linked TPLs.
To detect the TPLs in the aforementioned binaries, we have
alsobuilta TPLdatabase.Wehavecrawledallthe 5,278librariespresented in Ubuntu 20.04. We prune off the duplicate libraries
with different architectures and versions and filter out the libraries
that cannot be statically linked with the help of "dpkg"package
manager. We order the remaining 795 libraries and choose the top
100 frequently used libraries to form the testing TPL database.
TPLDetectionToolsComparison. ToevaluatetheTPLdetection
accuracy of ModX, we choose two state-of-the-art tools, BAT [ 31]
and OssPolice [ 24], to compared with. We run the three tools over
the data sets built in the previous step. Since both BAT and Os-
sPolice are designed to detect third-party packages, which contain
multiple libraries, we choose to compare the accuracy of both li-brary detection and package detection among the three tools to
ensure the fairness.
Table 2 and Table 3 show the precision and recall results for
theTPLdetectiontoolsovernixgeneratedbinariesandmanually
compiled binaries respectively. For Table 2, OssPolice (1) stands
for detection results based on our implementation and experiment,
whereasOssPolice(2)standsforresultsclaimedintheirpaper.BAT
(1)andBAT(2)havethesamemeaning.FromtheTable2,wecan
notice that ModX has 83.0% precision and 73.8% recall in package
detection and 85.6% precision and 49.6% recall in TPL detection,
which are the highest among the three TPL detection tools. In
Table 3, we list detailed library detection results for the 7 manually
crafted Ubuntu binaries.The first two columnspresent the binary
namesandthenumberofTPLsineachofthem.TherestofTable3
showsthenumberoftruepositives(TP),falsepositives(FP),and
falsenegatives(FN)forthethreetools.Asshowninthetable,ModXTable 2: TPL Detection on Real-world Programs.
ModXOssPolice
(1)OssPolice
(2)BAT(1) BAT(1)
Package Detection
Precision(%) 83.0 83.8 82 66.1 75
Recall(%) 73.8 70.0 87 65.7 61
Library Detection
Precision(%) 85.6 77.8 / 41.4 /
Recall(%) 49.6 40.2 / 38.7 /
Table 3: Partial Library Detection on Ubuntu Binaries.
Binary LibsModX OssPolice BAT
Linked TPFPFNTPFPFNTPFPFN
ssldump 2200200220
vim 4202103133
busybox 3112102142
tcpdump 3300300211
openvpn 5401322312
sqlite3 4311222222
openssl 5213322312
Total 26173915611141412
Performance Summary
ModX OssPolice BAT
Precision Recall Precision Recall Precision Recall
85.0% 65.4% 71.4% 57.7% 50% 53.8%
alsoachievesthehighestresultswithprecision(85.0%)andrecall
(65.4%) on average.
Discussion. In the experiment, most of the binary libraries are
partially imported since the modern linkers will only link the used
portion of the TPL by default [ 37]. The ModX has better accuracy
comparedwithothertools,becausethemodulesnaturallyconsistofthefunctionsthatperformthesimilarfunctionality.Whendetectingpartialusageofthelibrary,thefeaturesofmoduleswillkeepstable
without being demolished.
FP.Thebottleneckiscausedbythecollisionofthemodulefeatures.
Theremayexistmoduleswithsimilarstructuresandfunctionalities
across different libraries. The feature extractedfrom these modules
may not be distinguishable enough to separate them. Therefore,
mistakenlymatchingamodulewithsimilaronesinotherlibrary
signatureswillresultinthedecreaseoftheprecision.ModXadapts
the semantic information into features, which adds in additional
featurespacestoincreasedifferencesbetweenmodules,sothatit
can produce higher precision in the evaluation.FN.
Sincesomeofthelibrariesaretinyinsize,whichonlyconsists
of few modules, it is difficult to extract distinguishable features
fromthelimitednumberofmodules.Thus,thelackoffeaturesin
smalllibrariesisthemainreasontopulldowntheoverallrecallfor
ModX. Same as many other tools, the ModX will perform better
when the versions between the signature library and library in the
target function are closer.
Answering RQ2: Compared to the state-of-the-art TPL
detection works, ModX has better on-average precision
(85%) and recall (66%) on both real-world and manually
crafteddatasetindetecting100commonly-usedTPLs.The
semantic module matching and partial library detection
capability enable ModX to outperform other works.
1400
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ModX: Binary Level Partially Imported Third-Party Library Detection via Program Modularization and Semantic Matching ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Table 4: Program Modularization Time Comparison
Data Set Set A Set B Set C Total
File Size (KB) 0 ~100 100 ~1000 > 1000 16.4~4413.5
AVG. Size (KB) 61.8 297.8 2210.2 724.8
No. of Binaries 15 66 25 106
AVG. Func. (#) 159.6 652.1 4224.8 1425.0
AVG. Modularization Time (seconds)
ModX 1.4 31.7 3722.1 896.5
BCD 1.6 52.6 13650.7 3252.7
Table 5: TPL Detection Time Comparison Time
Average Detecting Time (s) ModX OssPolice BAT
Set A (0 ~100 KB) 255.0 42.3 7.5
Set B (100 ~1000 KB) 915.3 81.8 32.2
Set C (> 1000 KB) 3538.8 127.1 193.5
Average 1440.6 86.9 66.8
4.3 Performance Evaluation (RQ3)
Table 4 gives the average time used to modularize a given program
of BCD and ModX. Since the time used to modularize the program
isproportionaltotheprogramsize,Wedividethetestingprograms
into three size ranges in the experiment. As shown in the table, in
allsizesofbinaries,ModXoutperformsBCD.ItisbecauseModX
uses locality scores to guide the rapid modularization. But in BCD,
the locality information is represented as edges between nodes,
which makes the graph complicated and slows the process.
Table 5 shows the average time used to detect TPLs in given
programs. Since OssPolice and BAT only use syntactic features,
such as strings, which can be indexed, they have better perfor-
mance than ModX. ModX extracts semantic features from graphs
and measures function similarities, which are mainly unstructured
data. Therefore, we do not have a better way to store and index
thesefeaturesquickly.Wehavetoloadandcomparethefeatures
one-by-one in the detecting procedure, which lowers the perfor-mance. A higher accuracy of ModX is guaranteed and is worth
the cost of time. Thus, in practice, we recommend using ModX as
a complementary process after syntactic approaches to produce
more accurate results.
Answering RQ3: ModX takes on average 897 seconds
to modularize binary program which outperforms BCD.
However, it costs 1440 seconds to finish the TPL detection,
which is slower compared to other approaches.
4.4 Use Case Study (RQ4)
Real-world malware programs usually share only partial codes
between variants. This would be a challenging case to evaluate the
partial TPL detection ability of ModX. We manually collected a
family of malware from VirusShare [ 9] to perform a use case study.
The malware is from a famous [ 8] botnet program family called
Mirai,whichhasbeenopen-sourcedsince2016.Ittargetsatvarious
kindsof networkingdevicesand mutatesrapidly.There areover
100 Mirai variants according to Microsoft collections [ 6]. We have
selectedtheoriginalMiraiasthesignaturetodetectthemalware
appearancein15variantssubmittedfrom2016to2020(4variantsindifferentarchitectures,3variantsintherecentyear2020,and8other
variants). Specifically, we build the malware binary from its sourceTable 6: Malware Variants Detection
Detections Total ModX BAT OssPolice
Different Architecture 4 3/4 2/4 0/1
Variants at 2020 3 3/3 0/3 0/0
Other Versions 8 6/8 6/8 2/4
Total 15 12/15 8/15 2/5
Summary
Precision / 80% 53% 40%
Recall / 80% 53% 13%
code and add the features into our library database. We regard the
malware as a TPL, named libmirai. For each collected malware
variants,wedetectTPLusagewithModX,BATandOssPolice.If
libmiraiis detected in the variantsâ€™ binaries, we count as a correct
malware prediction.
Table6showsthemalwaredetectionresults.Overall,ourmethod
has the best accuracy in detecting 12 out of 15 malware variants.
ThesecondrowinTable6showsthatModXcouldcatchtheseman-
ticaccuratelyevenacrossarchitecturessincethesemanticbased
signaturescanresistmanykindsofmodificationandmutation.The
third row shows that ModX is reliable in detecting small partial
codereuse,whileothertoolsfail.BATusesstringsasthesignature,
whichisnotstableacrossvariants.OssPoliceisnotgoodathandling
binary signatures, leading to the lowest accuracy performance.
Answering RQ4: ModX has the best malware variant
detectionaccuracy,whichsuggeststhatitcandetectpartial
codereusewiththehelpofmatchingmodulesinsteadof
the entire program.
4.5 Applications (RQ5)
Inthissection,weshowotherpotentialapplicationsoftheprogrammodularizationtechnique.BesidesdetectingtheTPLs,ModXoffers
themodularizationresultsforotherprogramanalysisworkssuch
as reverse engineering and attack surface detection.Reverse Engineering with Module Tagging.
Themodulescan
reveal high level semantic information, which is very helpful for
reverse engineering. As the proof of the concept, we assign tags to
the module by extracting the common strings from the function
namesitcontains.Then,wematchthemoduletodetectthesimilarmodulesinotherprogramsandcheckifthedetectedmodulesshare
similar tags. Table 7 shows an example of two matched modules
withthefunctionnamesindetail.Eventhoughthefunctionsoftwo
modulesaredifferent,thetagsextractedaresimilar,whichsuggests
that their functionality at high level are also similar. We manually
verifythiscasetofindthatbothofthetwomodulestrytodealwith
the connection between the server and the client. Therefore, if we
managetocollectdifferentmoduleswithtagsasthesignatures,we
can match the modules in the target program. Then, we can obtain
hints about what kind of functionalities the target program has,
which is critical in the reverse engineering tasks.Attack Surface Detection.
Vulnerabilityisaspecialtypeofpro-
gramflawwhichcanleadtosecurityissues.Todetectithelpsto
improvetheoverallsoftwaresecurity.Accordingto[ 57,60],func-
tions which contains the vulnerabilities follow certain patterns.
Therefore, we would like to use the modularization technique to
help to identify the attack surface, which aims to determine the
1401
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Can Yang1,2, Zhengzi Xuâˆ—3, Hongxu Chen4, Yang Liu3, Xiaorui Gong1,2, Baoxu Liu1,2
Table 7: Module Tagging Results
Module.1 Functions
ssl_find_cipher, ssl_set_server_random, ssl_process_server_session_id,
sslx_print_certificate, sslx_print_certificate, ssl_process_client_key_exchange,sslx_print_dn, decode_HandshakeType_ServerKeyExchange,
decode_HandshakeType_CertificateVerify, de-
code_HandshakeType_ClientKeyExchange, decode_HandshakeType_Finished,.sprintf, ssl_decode_opaque_array, decode_HandshakeType_ServerHello,
decode_HandshakeType_CertificateModule.2 Functions
tls_check_ncp_cipher_list,helper_client_server,options_postprocess_verify_ce,
options_postprocess, helper_keepalive, notnull, helper_tcp_nodelay,
clone_route_option_list,clone_route_ipv6_option_list,new_route_option_list,
init_key_type, push_option, alloc_connection_entry, check_file_access,rol_check_alloc_0, pre_pull_save_0, .access, check_file_access_chroot, plat-form_access, rol_check_alloc, ifconfig_pool_verify_range, pre_pull_save,cipher_kt_get, proto_is_net, print_topology, print_opt_route, print_netmask,
print_str_int, print_opt_route_gateway, verify_common_subnet
Common Tagscipher, type, client, print, server, verify
Conclusion in High Level
Some cryptography handshake between ServerandClient, verifying the identity
of the peer.
Table 8: Distribution of Vulnerabilities in Modules
BinUtils LibXML2 OpenSSL FreeType Tcpdump
Basic Information.
Functions 1726 3108 6340 1313 1266
Modules 100 267 431 60 91
Vulnerabilities Information.
No. of CVEs 147 37 70 57 88
Distribution of CVEs.
% of Modules-
ð›¼11.0 8.1 3.6 16.2 18.7
% of Funcs inModules-
ð›¼27.6 8.3 12.4 28.2 41.3
% of CVEs inModules-
ð›¼85.2 66.7 72.5 89.0 78.1
modulesthataremorelikelytohavevulnerabilitiesovertheothers.
Thesecurityanalysisworkscanbenefitfromitsincetheycanfocus
on the vulnerable modules (attack surface) to save time.
To test the attack surface detection ability, we have collected all
theCVEs(e.g.commonlyknownprogramvulnerabilities)from5
real-world projects (BinUtils, LibXML2, OpenSSL, FreeType, and
Tcpdump).WeuseModXtodecomposethe5projectsintomodules
and plot the CVEs to the modules that they belong to. In the exper-
iment,wefocusonthemodules,whichcontainatleastoneCVE,
named Modules- ð›¼. Table 8 shows the allocation of the CVEs in
Modules-ð›¼foreachoftheprojects.Thefirstfewrowsshowtheba-
sic information of the projects and their vulnerabilities. The 8th to
10throwsshowthepercentageofthenumberofModules- ð›¼overall
modules,the percentage ofthenumberof functionsinModules- ð›¼
overallfunctionsintheprogram,andthepercentageofthenumber
of CVEs the Modules- ð›¼has against all CVEs respectively.
Accordingtotheresult,wecanseeaclearindicationthatModules-
ð›¼s only account for a small portion of all the modules; but they
containthemajorityoftheCVEs.Forexample,inOpenSSLproject,
3.7% modules with 12.4% functions have 72.5% CVEs. Therefore,
themodularizationtechniquehasthepotentialtoaidthesecurity
analysis by providing modules which contain more vulnerabilities
and are worthy to be further studied.Answering RQ5: Program modularization has impactful
applicationsinsoftwareengineering.Experimentsshow
that it helps to understand the program in reverse engi-
neering and detects attack surfaces in security analysis.
5 DISCUSSION
Threats to Validity. Our work relies on reasonable modulariza-
tions on the program. If the program module semantics changed
greatly, our method would lose its effectiveness in matching them.
Therefore,twocommonthreatsare:1)Heavyobfuscationonthe
binaries.2)Significantsemanticchangesfromthebottom.Weac-
knowledge that these challenges are still difficult to handle and are
hot topics in the recent literature.
Limitations & Future Works. First, as mentioned in Section 4.3,
ModXhasmoreoverheadcomparedtoothersyntacticfeaturehash
matching based approaches. The overhead is mainly introduced by
the time to extract features during module matching. One possible
solutionistoleveragelightweightsyntacticmatchingtofilterout
obviously irrelevant cases and use ModX to confirm the results in
a much smaller candidate space.
Second, the software researchers have not reached a common
consensus about verifying the correctness of the result of binaryprogram modularization. We have tried our best via proposing
our ownmodule metric tomeasure the qualityand evaluating the
modulesagainststandard communitydetectionmetrics.However,
it is difficult to prove that the metrics themselves reflect the real
modulequality.Inthefuture,weaimtoperformanempiricalstudy
ontheimpact ofmetricschoseninprogram modularizationsince
different applications may require different customised metrics for
module quality measurement to produce better results.
Last,theTPLdetectionisthedirectapplicationofprogrammod-
ulization.Webelievethatthistechniquehasgreatpotentialinmany
other areas. We have evaluated some of the possibilities such as at-
tacksurfacedetectioninSection4.5.Inthefuture,weplantoextend
the work to facilitate other analyses in program understanding.
6 RELATED WORK
Inthissection,wediscusstherelatedworksintheareaofprogram
modularization, TPL detection, and code clone detection.ProgramModularization.
Theprogrammodularizationisahelp-
ful technique looking insight into a software system, which is now
welldevelopedinsourcecodesanalysis.Bunch[ 42]modularizes
source files of the program into clusters by Module DependencyGraph(MDG). Following studies [
33,39,43,45,52] improve the
clustering torealize theautomation andthe architecturerecovery.
Some later studies [ 35,46] can perform modularization more close
to human experts. It is still challenging to modularize a C/C++binary program and little progress has been made according thenewestsurvey[
13].C/C++binariesstripthethestructuralinfor-
mation of modules after compilation, which in very different from
otherprogramslikejavaapplications[ 40,64].BCD[34]introduces
communitydetectionmethodstodecomposeabinaryintomodules,
andcansuccessfullyrecoverspecificC++classes.Followingstud-
ies[29,30]concludesthatthemodularizationinbinaryprograms
1402
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ModX: Binary Level Partially Imported Third-Party Library Detection via Program Modularization and Semantic Matching ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
isamoresemanticapproach,andisusefulindetectingsmallpieces
of binary code. These works focus on analyzing the program struc-
tures with the modularization. Whereas, ModX tries to provide
a complete solution to modularize the program and measure the
similarity between them.
Manyideas ofprogram modularizationcome fromcommunity
detection algorithms. We briefly introduce the algorithms based
onthemodularitythatbenefitus.Theoriginalideawasgivenby
GirvanandNewman[ 49]withanimprovementtoperformfasterat
large communities [ 48]. Later, Fast Unfolding [ 17] was proposed to
achieve rapid convergence properties and high modularity output.
Afterslightmigrationonthedesign,variantmethods[ 15,36]in-
tended for directed and weighted networks were proposed, which
are more suitable for the program modularization task.
TPL Detection. TPL detection aims to find the code reuse in soft-
ware. Approaches are proposed to extract the features from source
codeandmatchtheTPLsinthebinaryprogram.BinaryAnalysis
Tool(BAT)[ 31]isarepresentativemethodbasedontheusageof
constants. BAT extracts the constant values from both sources and
binaries, and then utilizes a frequency-based ranking method to
identify the presence of third-party packages. This kind of method
is scalable in firmware analysis [ 21,66]. OSSPolice [ 24] introduces
a hierarchicalindexing schemeto makebetter useof theconstant
andthedirectorytreeofthesources. BCFinder[ 55]makesthein-
dexinglightweightandmakesthedetectionplatform-independent.
OSLDetector [ 65] builds an internal cloning forest to reduce the
efficiency of features duplication between libraries. B2SFinder [ 63]
makes a well study on the features before and after compilation,
givingmorereliablethird-partycodedetectionresults.Thesemeth-
ods are designed feature-based rather than semantic-based for effi-
ciency. Other approaches try to use binary level features to detect
TPLs,whichareoftenusedinmalwareanalysis.Nativeideaslike
BinDiff[28]andBinSlayer[ 18]trytodirectlymatchtwobinaries
viagraphmatching.LibDX[ 56]isatypicaltoolinTPLdetection,
with a gene map to overcome the duplication of features, where
featuresaremainlyconstantsforscalability.Asforjava binaries,
manymethods[ 38,40,64,67]leveragemodularizedstructuresto
achieve fast and accurate TPL detection.Function Level Clone Detection.
There are also many works
identifying function level clones in a binary. The early methods [ 1]
takethebytescodeatthefunctionbeginning,whichisknownas
IDA FLIRT. The latter ones [ 20,32,61] extract many internal func-
tion features, such as operation codes, control flow graphs [ 27], se-
quencesofbasicblocks[ 12],collectionsoflibrarycalls[ 44],symbol
executionconstraints [ 54],and simulateresults [ 25,51].Recently,
thestate-of-the-artsworks[ 22,58,68]utilizemachinelearningtech-
niques to achieve the automation in features extraction and clones
identification. Many clone detection methods have been proved
usefulinrealistictasks,likevulnerabledetection[ 59].Theseworks
focusonprovidingfunctionlevelfeatures.Ourworklearnsfrom
themtoproposeunique androbustfeaturesforprogrammodules.
7 CONCLUSION
Insummary,weproposeModXtodetectTPLsinsoftwareviase-
manticmodulematching.Withthenovelmodularizationalgorithm,it divides the target program and the signature library into fine-grained functionality-based modules. Then, it extracts syntactic
andsemanticfeaturesfrommodulesandmeasuresthesimilarity
amongthemtodetectthepresenceofTPLs.Experimentsshowthat
ModXoutperformsothermodularizationtoolswith353%higher
module quality scores, and outperforms the state-of-the-art TPL
detectiontoolswith17%lesserfalsepositives.Moreover,thebinarylevelprogrammodularizationtechnique,asthestand-alonemethod,alsohasapplicationssuchasreverseengineeringandattacksurface
identification, which provides new research opportunities.
8 ACKNOWLEDGEMENT
We appreciate all the anonymous reviewers for their invaluable
commentsandsuggestions. Thisresearchissupported bytheKey
LaboratoryofNetworkAssessmentTechnologyofChineseAcad-
emy of Sciences, and the Beijing Key Laboratory of Cyber Security.
This research is partially funded by the Strategic Pilot Science and
Technology Project of the Chinese Academy of Sciences (Cate-
gory C, DC02040100) and the Natural Science Foundation of China
(NO.61802404,NO.61802394).ThisresearchissupportedbytheMin-
istry of Education, Singapore under its Academic Research Fund
Tier 3 (MOET32020-0004). Any opinions, findings and conclusions
or recommendations expressed in this material are those of the
author(s) and do not reflect the views of the Ministry of Education,
Singapore. This research is partially supported by the NationalResearch Foundation, Singapore under its the AI Singapore Pro-
gramme (AISG2-RP-2020-019), the National Research Foundation,
Prime Ministers Office, Singapore under its National Cybersecurity
R&D Program (Award No. NRF2018NCR-NCR005-0001),NRF Inves-
tigatorship NRFI06-2020-0022-0001, the National Research Foun-
dationthroughitsNationalSatelliteofExcellenceinTrustworthy
Software Systems (NSOE-TSS) project under the National Cyberse-
curityR&D(NCR)Grantawardno.NRF2018NCR-NSOE003-0001.
This research is partially supported by the NTU-DESAY SV Re-
search Program 2018-0980.
REFERENCES
[1]2011. IDAF.L.I.R.T.Technology:In-Depth. https://hex-rays.com/products/ida/
tech/flirt/in_depth/
[2]2020. 2019StateoftheSoftwareSupplyChain. https://www.sonatype.com/hubfs/
SSC/2019%20SSC/SON_SSSC-Report-2019_jun16-DRAFT.pdf.
[3]2020. 2020 Gartner Market Guide for Software Composition Analysis. https:
//go.snyk.io/2020-Gartner-Market-Guide.html.
[4]2020. GitHub Octoverse 2020 Security Report. https://octoverse.github.com/
static/github-octoverse-2020-security-report.pdf#page=10.
[5]2020. WIKI:Single-responsibilityprinciple. https://en.wikipedia.org/wiki/Single-
responsibility_principle.
[6]2021. Backdoor:Linux/Mirai. https://www.microsoft.com/en-us/wdsi/threats/
threat-search?query=mirai.
[7]2021. A hacker tool collection by Electrospaces, Insights in Signals Intelligence,
Communications Security and Top Level Telecommunications equipment. https:
//t.co/69lmiMmo43.
[8]2021. Mirai:amalwarethatturnsnetworkeddevicesintoremotelycontrolled
bots. https://en.wikipedia.org/wiki/Mirai_(malware).
[9] 2021. VirusShare: a repository of malware samples. https://virusshare.com/.
[10] 2021. VirusTotal. https://www.virustotal.com/gui/home/upload.
[11]2021. VirusTotal: Analyze suspicious files and URLs to de-tect types of malware, automatically share them with thesecurity community. https://www.virustotal.com/gui/file/
a8d65593f6296d6d06230bcede53b9152842f1eee56a2a72b0a88c4f463a09c3/
detection.
[12]Saed Alrabaee, Paria Shirani, Lingyu Wang, and Mourad Debbabi. 2018. Fossil: a
resilient and efficient system for identifying foss functions in malware binaries.
ACM Transactions on Privacy and Security (TOPS) 21, 2 (2018), 1â€“34.
1403
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Can Yang1,2, Zhengzi Xuâˆ—3, Hongxu Chen4, Yang Liu3, Xiaorui Gong1,2, Baoxu Liu1,2
[13]QusayAlsarhan,BestounSAhmed,MiroslavBures,andKamalZuhairiZamli.
2020. Software Module Clustering: An In-Depth Literature Analysis. IEEE
Transactions on Software Engineering (2020).
[14]DennisAndriesse,XiChen,VictorVanDerVeen,AsiaSlowinska,andHerbert
Bos. 2016. An in-depth analysis of disassembly on full-scale x86/x64 binaries. In
25th{USENIX}Security Symposium ( {USENIX}Security 16). 583â€“600.
[15]Alex Arenas, Jordi Duch, Alberto FernÃ¡ndez, and Sergio GÃ³mez. 2007. Size
reduction of complex networks preserving modularity. New Journal of Physics 9,
6 (2007), 176.
[16]Fabrizio Biondi, Thomas Given-Wilson, Axel Legay, Cassius Puodzius, and Jean
Quilbeuf.2018. Tutorial:Anoverviewofmalwaredetectionandevasiontech-
niques.In InternationalSymposiumonLeveragingApplicationsofFormalMethods.
Springer, 565â€“586.
[17]Vincent D Blondel, Jean-Loup Guillaume, Renaud Lambiotte, and Etienne Lefeb-
vre. 2008. Fast unfolding of communities in large networks. Journal of statistical
mechanics: theory and experiment 2008, 10 (2008), P10008.
[18]Martial Bourquin, Andy King, and Edward Robbins. 2013. Binslayer: accurate
comparison of binary executables. In Proceedings of the 2nd ACM SIGPLAN Pro-
gram Protection and Reverse Engineering Workshop. 1â€“10.
[19]S Sibi Chakkaravarthy, D Sangeetha, and V Vaidehi. 2019. A Survey on malware
analysis and mitigation techniques. Computer Science Review 32 (2019), 1â€“23.
[20]Mahinthan Chandramohan, Yinxing Xue, Zhengzi Xu, Yang Liu, Chia Yuan
Cho,andHeeBengKuanTan.2016. Bingo:Cross-architecturecross-osbinary
search. In Proceedings of the 2016 24th ACM SIGSOFT International Symposium on
Foundations of Software Engineering. 678â€“689.
[21]Andrei Costin, Jonas Zaddach, AurÃ©lienFrancillon, and Davide Balzarotti. 2014.
A large-scale analysis of the security of embedded firmwares. In 23rd{USENIX}
Security Symposium ( {USENIX}Security 14). 95â€“110.
[22]StevenH.H.Ding,BenjaminC.M.Fung,andPhilippeCharland.2019. Asm2Vec:
BoostingStaticRepresentationRobustnessforBinaryCloneSearchagainstCode
Obfuscation and Compiler Optimization. In 2019 IEEE Symposium on Security
and Privacy (SP).
[23]Eelco Dolstra, Eelco Visser, and Merijn de Jonge. 2004. Imposing a memory
managementdisciplineonsoftwaredeployment.In Proceedings.26thInternational
Conference on Software Engineering. IEEE, 583â€“592.
[24]RuianDuan,AshishBijlani,MengXu,TaesooKim,andWenkeLee.2017. Iden-
tifying open-source license violation and 1-day security risk at large scale. In
Proceedingsofthe2017ACMSIGSACConferenceoncomputerandcommunications
security. 2169â€“2185.
[25]Yue Duan, Xuezixiang Li, Jinghan Wang, and Heng Yin. 2020. DeepBinDiff:Learning Program-Wide Code Representations for Binary Diffing. In Network
and Distributed System Security Symposium.
[26]SultanSAlqahtaniEllisEEghanandJuergenRilling.[n.d.]. RecoveringSemantic
Traceability Links between APIs and Security Vulnerabilities: An Ontological
Modeling Approach. ([n.d.]).
[27]SebastianEschweiler,KhaledYakdan,andElmarGerhards-Padilla.2016.discovRE:
Efficient Cross-Architecture Identification of Bugs in Binary Code.. In NDSS.
[28]Halvar Flake. 2004. Structural comparison of executable objects. In Detection
of intrusions and malware & vulnerability assessment, GI SIG SIDAR workshop,
DIMVA 2004. Gesellschaft fÃ¼r Informatik eV.
[29]Kevin W Hamlen, Zhiqiang Lin, and Latifur Khan. 2019. Automated, Binary
Evidence-based Attribution of Software Attacks. Technical Report. The University
of Texas at Dallas Richardson, United States.
[30]IrfanUlHaqandJuanCaballero.2021. ASurveyofBinaryCodeSimilarity. ACM
Computing Surveys (CSUR) 54, 3 (2021), 1â€“38.
[31]Armijn Hemel, Karl Trygve Kalleberg, Rob Vermaas, and Eelco Dolstra. 2011.Finding software license violations through binary code clone detection. In
Proceedingsofthe8thWorkingConferenceonMiningSoftwareRepositories.63â€“72.
[32]YikunHu,YuanyuanZhang,JuanruLi,HuiWang,BodongLi,andDawuGu.2018.
Binmatch: A semantics-based hybrid approach on binary code clone analysis.In2018 IEEE International Conference on Software Maintenance and Evolution
(ICSME). IEEE, 104â€“114.
[33]JinhuangHuangandJingLiu.2016. Asimilarity-basedmodularizationquality
measure for software module clustering problems. Information Sciences 342
(2016), 96â€“110.
[34]Vishal Karande, Swarup Chandra, Zhiqiang Lin, Juan Caballero, Latifur Khan,
and Kevin Hamlen. 2018. Bcd: Decomposing binary code into components using
graph-basedclustering.In Proceedingsofthe2018onAsiaConferenceonComputer
and Communications Security. 393â€“398.
[35]MasoudKargar,AyazIsazadeh,andHabibIzadkhah.2019. Multi-programminglanguage software systems modularization. Computers & Electrical Engineering
80 (2019), 106500.
[36]Bisma S Khan and Muaz A Niazi. 2017. Network community detection: A review
and visual survey. arXiv preprint arXiv:1708.00977 (2017).
[37] John R Levine. 2001. Linkers & loaders. Morgan Kaufmann; 1st edition.
[38]Menghao Li, Wei Wang, Pei Wang, Shuai Wang, Dinghao Wu, Jian Liu, Rui Xue,
and Wei Huo.2017. Libd:Scalable and precise third-party library detectioninandroid markets. In 2017 IEEE/ACM 39th International Conference on SoftwareEngineering (ICSE). IEEE, 335â€“346.
[39]T. Lutellier, D. Chollak, J. Garcia, L. Tan, and R. Kroeger. 2018. Measuring the
ImpactofCodeDependenciesonSoftwareArchitectureRecoveryTechniques.
IEEE Transactions on Software Engineering 44, 99 (2018), 159â€“181.
[40]Ziang Ma, Haoyu Wang, Yao Guo, and Xiangqun Chen. 2016. Libradar: fast and
accuratedetection ofthird-partylibrariesin androidapps.In Proceedingsofthe
38th international conference on software engineering companion. 653â€“656.
[41]AliSafariMamaghaniandMohammadRezaMeybodi.2009. Clusteringofsoft-
ware systems using new hybrid algorithms. In 2009 Ninth IEEE International
Conference on Computer and Information Technology, Vol. 1. IEEE, 20â€“25.
[42]Spiros Mancoridis, Brian S Mitchell, Yihfarn Chen, and Emden R Gansner. 1999.
Bunch:Aclusteringtoolfortherecoveryandmaintenanceofsoftwaresystem
structures. In Proceedings IEEE International Conference on Software Maintenance-
1999(ICSMâ€™99).â€™SoftwareMaintenanceforBusinessChangeâ€™(Cat.No.99CB36360) .
IEEE, 50â€“59.
[43]OnaizaMaqboolandHaroonBabri.2007. Hierarchicalclusteringforsoftware
architecturerecovery. IEEETransactionsonSoftwareEngineering 33,11(2007),
759â€“780.
[44]JiangMing,DongpengXu,YufeiJiang,andDinghaoWu.2017. BinSim:Trace-
based Semantic Binary Diffing via System Call Sliced Segment EquivalenceChecking. In 26th USENIX Security Symposium (USENIX Security 17). USENIX
Association, Vancouver, BC, 253â€“270. https://www.usenix.org/conference/
usenixsecurity17/technical-sessions/presentation/ming
[45]BrianSMitchellandSpirosMancoridis.2006. Ontheautomaticmodularizationofsoftwaresystemsusingthebunchtool. IEEETransactionsonSoftwareEngineering
32, 3 (2006), 193â€“208.
[46]Sina Mohammadi and Habib Izadkhah. 2019. A new algorithm for softwareclustering considering the knowledge of dependency between artifacts in the
source code. Information and Software Technology 105 (2019), 252â€“256.
[47]Marion Neumann, Roman Garnett, Christian Bauckhage, and Kristian Kersting.
2016. Propagation kernels: efficient graph kernels from propagated information.
Machine Learning 102, 2 (2016), 209â€“245.
[48]Mark EJ Newman. 2004. Fast algorithm for detecting community structure in
networks. Physical review E 69, 6 (2004), 066133.
[49]MarkEJNewmanandMichelleGirvan.2004. Findingandevaluatingcommunity
structure in networks. Physical review E 69, 2 (2004), 026113.
[50]LawrencePage,SergeyBrin,RajeevMotwani,andTerryWinograd.1999. The
PageRank citation ranking: Bringing order to the web. Technical Report. Stanford
InfoLab.
[51]JannikPewny,Behrad Garmany, RobertGawlik, ChristianRossow,andThorsten
Holz. 2015. Cross-architecture bug search in binary executables. In 2015 IEEE
Symposium on Security and Privacy. IEEE, 709â€“724.
[52]Kata Praditwong, Mark Harman, and Xin Yao. 2010. Software module clustering
as a multi-objectivesearch problem. IEEE Transactions onSoftware Engineering
37, 2 (2010), 264â€“282.
[53]Claude Sammut and Geoffrey I. Webb (Eds.). 2010. TFâ€“IDF. Springer US, Boston,
MA, 986â€“987. https://doi.org/10.1007/978-0-387-30164-8_832
[54]Noam Shalev and Nimrod Partush. 2018. Binary Similarity Detection Using
MachineLearning.In Proceedingsofthe13thWorkshoponProgrammingLanguages
andAnalysisforSecurity (Toronto,Canada) (PLASâ€™18).AssociationforComputing
Machinery,NewYork,NY,USA,42â€“47. https://doi.org/10.1145/3264820.3264821
[55]Wei Tang,DuChen, andPingLuo.2018. Bcfinder:A lightweightandplatform-
independenttooltofindthird-partycomponentsinbinaries.In 201825thAsia-
Pacific Software Engineering Conference (APSEC). IEEE, 288â€“297.
[56]Wei Tang, Ping Luo, Jialiang Fu, and Dan Zhang. 2020. LibDX: A Cross-PlatformandAccurateSystemtoDetectThird-PartyLibrariesinBinaryCode.In 2020IEEE
27thInternationalConferenceonSoftwareAnalysis,EvolutionandReengineering
(SANER). IEEE, 104â€“115.
[57]Yang Xiao, Bihuan Chen, Chendong Yu, Zhengzi Xu, Zimu Yuan, Feng Li,
Binghong Liu, YangLiu, Wei Huo, Wei Zou, etal .2020.{MVP}: DetectingVul-
nerabilitiesusing {Patch-Enhanced }VulnerabilitySignatures.In 29thUSENIX
Security Symposium (USENIX Security 20). 1165â€“1182.
[58]Xiaojun Xu, Chang Liu, Qian Feng, Heng Yin, Le Song, and Dawn Song. 2017.
Neuralnetwork-basedgraphembeddingforcross-platformbinarycodesimilarity
detection.In Proceedingsofthe2017ACMSIGSACConferenceonComputerand
Communications Security. 363â€“376.
[59]YifeiXu,ZhengziXu,BihuanChen,FuSong,YangLiu,andTingLiu.2020. Patchbasedvulnerabilitymatchingforbinaryprograms.In Proceedingsofthe29thACM
SIGSOFT International Symposium on Software Testing and Analysis. 376â€“387.
[60]ZhengziXu,BihuanChen,MahinthanChandramohan,YangLiu,andFuSong.
2017. Spain: security patch analysis for binaries towards understanding the pain
andpills.In 2017IEEE/ACM39thInternationalConferenceonSoftwareEngineering
(ICSE). IEEE, 462â€“472.
[61]Yinxing Xue, Zhengzi Xu, Mahinthan Chandramohan, and Yang Liu. 2018. Accu-
rate and scalable cross-architecture cross-os binary code search with emulation.
IEEE Transactions on Software Engineering 45, 11 (2018), 1125â€“1149.
[62]Can Yang, Jian Liu, Mengxia Luo, Xiaorui Gong, and Baoxu Liu. 2020. RouAlign:
Cross-VersionFunctionAlignmentandRoutineRecoverywithGraphletEdge
1404
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. ModX: Binary Level Partially Imported Third-Party Library Detection via Program Modularization and Semantic Matching ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Embedding. In IFIP International Conference on ICT Systems Security and Privacy
Protection. Springer, 155â€“170.
[63]Zimu Yuan, Muyue Feng, Feng Li, Gu Ban, Yang Xiao, Shiyang Wang, Qian
Tang, He Su, Chendong Yu, Jiahuan Xu, et al .2019. B2SFinder: Detecting Open-
SourceSoftwareReuseinCOTSSoftware.In 201934thIEEE/ACMInternational
Conference on Automated Software Engineering (ASE). IEEE, 1038â€“1049.
[64]Xian Zhan, Lingling Fan, Tianming Liu, Sen Chen, Li Li, Haoyu Wang, Yifei
Xu, Xiapu Luo, and Yang Liu. 2020. Automated third-party library detection for
android applications: Are we there yet?. In 2020 35th IEEE/ACM International
Conference on Automated Software Engineering (ASE). IEEE, 919â€“930.
[65]Dan Zhang, Ping Luo, Wei Tang, and Min Zhou. 2020. OSLDetector: identifying
open-sourcelibrariesthroughbinaryanalysis.In 202035thIEEE/ACMInterna-
tional Conference on Automated Software Engineering (ASE). IEEE, 1312â€“1315.[66]Han Zhang, Abhijith Anilkumar, Matt Fredrikson, and Yuvraj Agarwal. 2021.
Capture: Centralized Library Management for Heterogeneous IoT Devices. In
USENIX Security Symposium.
[67]JiexinZhang,AlastairRBeresford,andStephanAKollmann.2019. Libid:reliable
identification of obfuscated third-party android libraries. In Proceedings of the
28th ACM SIGSOFT International Symposium on Software Testing and Analysis.
55â€“65.
[68]FeiZuo,XiaopengLi,PatrickYoung,LannanLuo,QiangZeng,andZhexinZhang.
[n.d.]. Neural Machine Translation Inspired Binary Code Similarity Comparison
beyond Function Pairs. representations 48 ([n.d.]), 50.
1405
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:28:46 UTC from IEEE Xplore.  Restrictions apply. 