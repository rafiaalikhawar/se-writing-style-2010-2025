ProbabilisticDeltaDebugging
GuanchengWangâˆ—
Key Laboratory of HighConfidence
SoftwareTechnologies, MoE
Department of Computer Science and
Technology, Peking University
Beijing, PR China
guancheng.wang@pku.edu.cnRuobingShenâˆ—
Key Laboratory of HighConfidence
SoftwareTechnologies, MoE
Department of Computer Science and
Technology, Peking University
Beijing, PR China
ruobingshen@pku.edu.cnJunjie Chen
Collegeof Intelligence and
Computing,Tianjin University
Tianjin, PR China
junjiechen@tju.edu.cn
YingfeiXiong2
Key Laboratory of HighConfidence
SoftwareTechnologies, MoE
Department of Computer Science and
Technology, Peking University
Beijing, PR China
xiongyf@pku.edu.cnLuZhang
Key Laboratory of HighConfidence
SoftwareTechnologies, MoE
Department of Computer Science and
Technology, Peking University
Beijing, PR China
zhanglucs@pku.edu.cn
ABSTRACT
The delta debugging problem concerns how to reduce an object
while preserving a certain property, and widely exists in many
applications, such as compiler development, regression fault local-
ization, and software debloating. Given the importance of delta
debugging, multiple algorithms have been proposed to solve the
deltadebuggingproblemefficientlyandeffectively.However,theef-
ficiencyandeffectivenessofthestate-of-the-artalgorithmsarestill
notsatisfactory.For example,thestate-of-the-artdeltadebugging
tool,CHISEL,maytakeupto3hourstoreduceasingleprogram
with 14,092 lines of code, while the reduced program may be up to
2times unnecessarily large.
Inthispaper,weproposeaprobabilisticdeltadebuggingalgo-
rithm (named ProbDD) to improve the efficiency and the effective-
nessofdeltadebugging.Ourkeyinsightis,theddminalgorithm,
thebasicalgorithmuponwhichmanyexistingapproachesarebuilt,
followsapredefinedsequenceofattemptstoremoveelementsfrom
asequence,andfailstoutilizetheinformationfromexistingtestre-
sults.Toaddressthisproblem,ProbDDbuilds aprobabilisticmodel
toestimatetheprobabilitiesoftheelementstobekeptinthepro-
ducedresult,selectsasetofelementstomaximizethegainofthe
nexttestbasedonthemodel,andimprovesthemodelbasedonthe
test results.
WeprovethecorrectnessofProbDD,andanalyzetheminimality
ofitsresultandtheasymptoticnumberoftestsundertheworstcase.
TheasymptoticnumberoftestsintheworstcaseofProbDDis ğ‘‚(ğ‘›),
âˆ—Bothauthorscontributed equally to thisresearch.
2Corresponding Author
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™21, August 23Å›28,2021, Athens,Greece
Â©2021 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-8562-6/21/08...$15.00
https://doi.org/10.1145/3468264.3468625which is smaller than that of ddmin, ğ‘‚(ğ‘›2)worst-case asymptotic
numberoftests.Furthermore,weexperimentallycomparedProbDD
withddminon40subjectsinHDDandCHISEL,twoapproaches
thatwrapddminforreducingtreesandCprograms,respectively.
Theresultsshowthat,afterreplacingddminwithProbDD,HDD
and CHISEL produce 59.48% and 11.51% smaller results and use
63.22%and45.27%less time,respectively.
CCS CONCEPTS
Â·Software and its engineering â†’Software testing and de-
bugging.
KEYWORDS
Delta Debugging, ProbabilisticModel
ACMReference Format:
GuanchengWang,RuobingShen,JunjieChen,YingfeiXiong,andLuZhang.
2021.ProbabilisticDeltaDebugging.In Proceedingsofthe29thACMJointEu-
ropean Software Engineering Conference and Symposium on the Foundations
ofSoftwareEngineering(ESEC/FSEâ€™21),August23Å›28,2021,Athens,Greece.
ACM,NewYork,NY,USA, 12pages.https://doi.org/10.1145/3468264.3468625
1 INTRODUCTION
Delta debugging automatically reduces a set of elements while pre-
servingacertainproperty[ 31],andhasfoundapplicationsinmany
domains,suchascompilerdebugging[ 7,8,11,28,32],regression
fault localization [ 6,9,29], isolating the cause-effect chain of a
failure [10,17,30],anddebloatingsoftware toreduce thesize ofa
program whilekeeping certaindesiredfunctionalities [ 13].
Formally,deltadebuggingisdefinedasfollows.Let Xbeauni-
verse of all objects of interest, ğœ™:Xâ†’ {ğ¹,ğ‘‡}be a test function
determining whether an object exhibits a given property (T) or not
(F),and|ğ‘‹|bethesizeofanobject ğ‘‹âˆˆX.Givenanobject ğ‘‹âˆˆX
thatğœ™(ğ‘‹)=ğ‘‡,thegoalofdeltadebuggingistofindanotherobject
ğ‘‹âˆ—âˆˆXsuch that |ğ‘‹âˆ—|is as small as possible and ğœ™(ğ‘‹âˆ—)=ğ‘‡, i.e.,
ğ‘‹âˆ—preservesthe property. Forexample,in compilerdevelopment,
delta debugging is used to find a smaller program that reproduces
a compilation failure. Here Xis a universe of programs, ğ‘‹is a
881ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Guancheng Wang,RuobingShen, JunjieChen, Yingfei Xiong, andLu Zhang
possibly large program that leads a compilation failure, and ğœ™tests
whether the compilation failure stillexistsornot.
The state-of-the-art family of delta debugging approaches is
builtupontheddminalgorithm[ 32].Theddminalgorithmviews
an object ğ‘‹âˆˆXas a sequence. In each iteration, ddmin splits ğ‘‹
intoğ‘›subsequences and tries to remove each subsequence and
its complement from ğ‘‹. The number ğ‘›starts with 2 and doubles
in each iteration. Subsequent approaches in this family assume
morecomplexdomain-specificstructuresandapplyddmintothe
sequences in the structures. For example, HDD [ 21] assumes the
objects have a structure of a tree and applies ddmin only to the
sequencesofsiblings.CHISEL[ 13]furtherconsidersthedataand
control dependency relations between elements in a C program
andappliesddmininawaythatwouldnotbreakthedependencies.
However, the efficiency and effectiveness of the state-of-the-art
deltadebuggingalgorithmsarestillnotsatisfactory.Forexample,as
ourevaluationwillreveallater,thestate-of-the-artdeltadebugging
tool,CHISEL[ 13],maytakeupto3hourstoreduceasingleprogram
with 14,092 lines of code, while the reduced program may be up to
2times unnecessarily large.
In this paper, we aim to improve the effectiveness and efficiency
of delta debugging. Our key insight is, the ddmin algorithm, the
centralcomponentofmanyexistingapproaches,followsaprede-
finedsequenceofattemptstoremoveelementsfromtheoriginal
object, and fails to utilize the information from existing test results.
Toaddressthisproblem,weproposeaprobabilisticdeltadebugging
algorithm,ProbDD.ProbDDbuildsaprobabilisticmodeltoestimate
theprobabilityofeachelementtobekeptintheproducedresult.
In each iteration, ProbDD selects a subset of elements to maximize
the gain of the next test based on the probabilistic model, and tests
ifthedesiredpropertyispreservedinthissubset.Then,ProbDD
updatesthe probabilisticmodelbasedonthe testingresult.
WeprovetheresultproducedbyProbDDiscorrectandismin-
imal or minimum if the universe of objects satisfies certain con-
ditions. We also analyze the asymptotic number of tests under
theworstcase.Theasymptoticnumberoftestsintheworstcase
of ProbDD is ğ‘‚(ğ‘›), which is smaller than that of ddmin, ğ‘‚(ğ‘›2)
worst-case asymptoticnumber oftests.
Furthermore, we evaluated ProbDD on40 subjects in twoappli-
cation domains, i.e., trees and C programs, by substituting ProbDD
forddminintworepresentativeapproachesforthetwodomains,
HDD[21]andCHISEL[ 13].Thenumberofsubjectsinourevalu-
ation is larger than all recent publications on delta debugging at
top venues [ 13,15,16,18,21,23,25,29,30,32] as far as we are
aware.TheresultsdemonstratethatProbDDsignificantlyimproves
boththeefficiencyandtheeffectivenessoftherepresentativeap-
proachesinthetwodomains.Onaverage,aftersubstitutingProbDD
forddmin,HDDandCHISELproduces59.48%and11.51%smaller
resultswithinthetimelimit,respectively.Onthesubjectswhere
bothversionsfinishwithinthetimelimit,aftersubstitutingProbDD
forddmin,HDDandCHISELuse63.22%and45.27%lesstime,re-
spectively.
In summary, this paper makes the following main contributions.
â€¢We propose a novel probabilistic delta debugging algorithm,
ProbDD, which dynamically learns a probabilistic model to
efficiently andeffectivelyreduce asequenceofelements.â€¢WeprovethecorrectnessofProbDD,analyzetheminimality
of its result and the asymptotic number of tests under the
worst case.
â€¢We evaluate ProbDD in two application domains, demon-
strating that ProbDD significantly improves the representa-
tiveapproachesinthetwodomainsinbothefficiencyand
effectiveness.
2 MOTIVATING EXAMPLE
Weuseaprogramminimizationexampletoillustratehowddmin
works. Listing 1shows a real program from TensorFlow tutori-
als[2].Letusassumethatthefunctiontype()isfaultyandanyvalid
invocation to it will result in the same error. Now we would like
toreducetheprogramsuchthattheerrorisstillproduced.There
are8statementsintheprogram,andthegoalofdeltadebugging
is tofind a subsequence of statements thatstill invokestype() and
thus produces the error. Here we use ğ‘ ğ‘–to denote the statement in
Lineğ‘–.
Listing 1:Example program to be reduced
1import tensorflow as tf
2x = tf . constant (3.0)
3b = 1.0
4with tf . GradientTape () as tape :
5tape . watch(x)
6y = xâˆ—âˆ—2
7b = tape . gradient (y,x)
8print ( type (b ))
The ddmin algorithm views the set of elements as a sequence
andproceedsastwonestedloops.Theouterloopreducesavariable
ğ‘›representing the length of the subsequence to be considered.
The length ğ‘›starts from 1/2 of all elements and reduces by half
at each iteration until it reaches 1. The inner loop first tests all
consecutiveanddisjointsubsequencesoflength ğ‘›,andthentests
the complements of these subsequences. If any test is successful,
keep only this subsequence. If a subsequence or its complement
has been testedbefore,skip it.
The tests that ddmin performs for this example are shown in
Figure1. At the end of each row, there is a T or an F, which means
that the error is still produced (T) or not (F). First, ğ‘›is 4, the two
subsequencesof length4 aretested atlines 1and 2.Both testsfail
and their complements are all tested, so the first outer iteration
finishes.Second, ğ‘›ishalvedas 2,thefoursubsequencesoflength
2 are tested at lines 3 to 6. All the tests fail and the tests of their
complements also fail, so the second outer iteration finishes. Third,
ğ‘›is halved as 1, the eight subsequences of length 1 are tested
at lines 11 to 18. All these tests fail. Then, the complements are
testedandthecomplementof {ğ‘ 3}passesthetestatline21.Since
thetestpasses,theelementsinthecomplementarekeptandthe
seven subsequences and their complements need to be tested, so
the algorithm continues with ğ‘›as 1. However, none of the tests
forthesevensubsequencessucceed,whicharetestedbefore,and
none of their complements succeed (lines 22-28), so the third outer
iterationfinishesandthealgorithmreturns {ğ‘ 1,ğ‘ 2,ğ‘ 4,ğ‘ 5,ğ‘ 6,ğ‘ 7,ğ‘ 8}.
The returned set is 1-minimal because it cannot be further reduced
byremovingany singleelement from it.
882Probabilistic DeltaDebugging ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
s1s2s3s4s5s6s7s8
1s1s2s3s4s5s6s7s8F
2s1s2s3s4s5s6s7s8F
3s1s2s3s4s5s6s7s8F
4s1s2s3s4s5s6s7s8F
5s1s2s3s4s5s6s7s8F
6s1s2s3s4s5s6s7s8F
7s1s2s3s4s5s6s7s8F
8s1s2s3s4s5s6s7s8F
9s1s2s3s4s5s6s7s8F
10s1s2s3s4s5s6s7s8F
11s1s2s3s4s5s6s7s8F
12s1s2s3s4s5s6s7s8F
13s1s2s3s4s5s6s7s8F
14s1s2s3s4s5s6s7s8F
15s1s2s3s4s5s6s7s8F
16s1s2s3s4s5s6s7s8F
17s1s2s3s4s5s6s7s8F
18s1s2s3s4s5s6s7s8F
19s1s2s3s4s5s6s7s8F
20s1s2s3s4s5s6s7s8F
21s1s2s3s4s5s6s7s8T
22s1s2s3s4s5s6s7s8F
23s1s2s3s4s5s6s7s8F
24s1s2s3s4s5s6s7s8F
25s1s2s3s4s5s6s7s8F
26s1s2s3s4s5s6s7s8F
27s1s2s3s4s5s6s7s8F
28s1s2s3s4s5s6s7s8F
Figure 1:Detailed iterationsofddmin
Aswecanseefromtheexample,thesequenceofattemptsfor
ddminispredefinedanddoesnotlearnfrompasttestresults.For
example, in this example statement, ğ‘ 8should not be removed.
However,followingthepredefinedorder,thestatement ğ‘ 8hasbeen
triedtoremove13times,andalltheseattemptswouldfail.Infact,as
studied by Zeller and Hildebrandt[ 32], the worst-case asymptotic
number of tests in ddmin is ğ‘‚(ğ‘›2), whereğ‘›is the size of the initial
set.Also,thereducedresultcontainssevenstatements,whilethe
optimal result is {ğ‘ 3,ğ‘ 8},containingonly twostatements.
3 APPROACH
Fromtheanalysisoftheprevioussection,wecanseethatddmin
does not learn from the history of test results, and could keep
removinganelementthoughallhistoricalremovalsofthiselement
leadtotestfailures.Toovercomethisproblem,ourapproachbuilds
aprobabilisticmodeltoguidethetestsandupdatestheprobabilistic
model based on the test results. The process continues until the
probabilisticmodelpredictswith100%certaintythatasubsequence
is the optimal subsequence. In this way, the test history guides
future tests through the probabilistic model. In this section, we
describe(1)thismodel,(2)howthismodelshouldbeupdatedbased
onthe test results, and(3) howto use this modelto guide tests.3.1 The ProbabilisticModel
3.1.1 Notations. Sinceourgoalistooptimizeddmin,wealsoview
the input object as a sequence and try to identify a subsequence
that makesthe test functionpass. In otherwords,the universe Xis
an-dimensionalBooleanspaceandanobject ğ‘‹intheuniverseis
a Booleanvector ğ‘‹=âŸ¨ğ‘¥1,ğ‘¥2,...,ğ‘¥ğ‘›âŸ©whereğ‘¥ğ‘–âˆˆ {0,1}. Hereğ‘¥ğ‘–=1
indicatesthatthe ğ‘–thelementisincludedinthesubsequenceand
ğ‘¥ğ‘–=0 indicates that the ğ‘–th element is excluded from the subse-
quence.Tosimplifythepresentation,wealsoviewasubsequence
ğ‘‹as a set containing the indexes of the included elements, i.e.,
{ğ‘–|ğ‘¥ğ‘–=1}, so that the set operators such as âŠ†apply to subse-
quences.
3.1.2 The Existence of the Optimal Subsequence. To simplify the
probabilistic analysis, we assume two properties of the universe
Xwhichareoftenassumedordiscussedinexistingwork[ 29,32].
Please note the goal of assuming the two properties is to deduce
thedesignofourprobabilisticmodel,andthecorrectnessandthe
time complexityofProbDDdo not depend onthe twoproperties.
Themonotonypropertysaysthatif ğ‘‹failsthetestfunction,any
subsequenceof ğ‘‹fails the test function.
Definition 3.1 (Monotony). âˆ€ğ‘‹,ğ‘‹â€²âˆˆX,ğ‘‹â€²âŠ†ğ‘‹âˆ§ğœ™(ğ‘‹)=ğ¹â‡’
ğœ™(ğ‘‹â€²)=ğ¹
The unambiguityproperty saysthatiftwosubsequencespass
the test function, theirintersection passesthe test function.
Definition3.2 (Unambiguity). âˆ€ğ‘‹,ğ‘‹â€²âˆˆX,ğœ™(ğ‘‹)=ğ‘‡âˆ§ğœ™(ğ‘‹â€²)=
ğ‘‡â‡’ğœ™(ğ‘‹âˆ©ğ‘‹â€²)=ğ‘‡
Weshowthattheabovetwopropertiesimplytheexistenceof
an optimal subsequence where the test function passes if and only
if the elements inthe subsequenceare present.
Theorem3.3. IfauniverseXisbothmonotoneandunambiguous,
there exists an optimal subsequence ğ‘‹âˆ—such that the following holds.
ğœ™(ğ‘‹)=/braceleftbiggğ‘‡ ğ‘‹âˆ—âŠ†ğ‘‹
ğ¹otherwise
Proof.Letğ‘‹âˆ—=/intersectiontext.1
ğœ™(ğ‘‹)=ğ‘‡ğ‘‹.Basedonunambiguity,weknow
thatğœ™(ğ‘‹âˆ—)=ğ‘‡. Basedonmonotony, we knowthat any superset ğ‘‹
ofğ‘‹âˆ—makesthetestfunctionpass,i.e., ğœ™(ğ‘‹)=ğ‘‡.Nowlet ğ‘‹bea
subsequencethatisnotasupersetof ğ‘‹âˆ—.Ifweassume ğœ™(ğ‘‹)=ğ‘‡,we
haveğ‘‹âˆ©ğ‘‹âˆ—=ğ‘‹âˆ—by the definition of ğ‘‹âˆ—, which contradicts with
the fact that ğ‘‹isnot asuperset of ğ‘‹âˆ—.Therefore, ğœ™(ğ‘‹)=ğ¹.â–¡
3.1.3 TheModel. Nowweproceedtodefinetheprobabilisticmodel.
Giventheexistenceoftheoptimalsubsequence ğ‘‹âˆ—,thegoalofdelta
debuggingistoidentifyelementsin ğ‘‹âˆ—.Therefore,weassignthe
element at each index ğ‘–a Bernoulli random variable ğœƒğ‘–to denote
whetherthe ğ‘–thelementisin ğ‘‹âˆ—ornot.Weuseparameter ğ‘ğ‘–tode-
notetheprobabilityofthe ğ‘–thelementisin ğ‘‹âˆ—,i.e.,ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1)=ğ‘ğ‘–.
Therefore, our probabilistic model is a ğ‘›-dimensional vector of
parameters âŸ¨ğ‘1,ğ‘2,...,ğ‘ğ‘›âŸ©.
We further assume that the random variables ğœƒare mutually
independent. This assumption is reasonable because modern delta
debuggingapproacheshaveconsideredthedomain-specificstruc-
ture oftheobjects,and if twoelementsdependon eachother, e.g.,
they can be removed together but cannot be individually removed,
883ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Guancheng Wang,RuobingShen, JunjieChen, Yingfei Xiong, andLu Zhang
such a dependency are likely to be captured by the outer approach
wrappingddmin.Whenddminisappliedtoasequence,mostofthe
elements in this sequence should not depend on each other. Based
on this assumption, the probability of a vector ğ‘‹being equal to ğ‘‹âˆ—
is/producttext.1
ğ‘–ğ‘ğ‘¥ğ‘–
ğ‘–(1âˆ’ğ‘ğ‘–)1âˆ’ğ‘¥ğ‘–.1Thisalsoimpliesthatthedeltadebugging
processofour approach stops when each ğ‘ğ‘–iseither1or0.
With this model, it is easy for us to calculate the probability
ofatestresult.Forexample,theprobabilityof ğ‘‹passingthetest
function is theprobability that noelementin ğ‘‹âˆ—is excluded from
ğ‘‹,i.e.,ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ‘‡)=/producttext.1
ğ‘–(1âˆ’ğ‘ğ‘–)1âˆ’ğ‘¥ğ‘–.
3.1.4 Prior Distribution. Since initially we do not have any knowl-
edge about the individual elements, we uniformly set all ğ‘ğ‘–toğœ,
where0<ğœ<1isahyper-parameterofProbDD.Therearemul-
tiplewaystodetermine ğœbasedonthepropertiesoftheproblem
domain.Iftheresultsusuallyhaveafixedreductionratio,weset
ğœto this ratio. If the reduced subsequences usually have a fixed
lengthğ‘š,wecanset ğœtoğ‘š/ğ‘›,whereğ‘›isthelengthoftheinput
sequence.
3.2 Update theModel
Afterasetoftests,wewouldliketocalculatetheposteriorprobabil-
itiesconditionedonthetestresultssoastoguidefuturetestsusing
the posterior probabilities. Now assume that we have performed a
seriesoftestson ğ‘‹1,ğ‘‹2,...,ğ‘‹ğ‘šwithtestresults ğ‘…1,ğ‘…2,...,ğ‘…ğ‘š.We
denotetheeventthattesting ğ‘‹ğ‘–returning ğ‘…ğ‘–(i.e.,ğœ™(ğ‘‹ğ‘–)=ğ‘…ğ‘–)asğ‘‡ğ‘–.
Then we can calculatethe posteriorprobability of ğœƒğ‘–as follows.
ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1|ğ‘‡1,ğ‘‡2,...,ğ‘‡ğ‘›)=ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1,ğ‘‡1,ğ‘‡2,...,ğ‘‡ğ‘›)
ğ‘ƒğ‘Ÿ(ğ‘‡1,ğ‘‡2,..,ğ‘‡ğ‘›)
A basic method tocalculate the above two joint probabilities is
to enumerate the universe of subsequences, and sum up the proba-
bilityofasubsequencebeingtheoptimaloneforeachsubsequence
consistentwiththeevents.Asubsequence ğ‘‹isconsistentwitha
test result ğ‘‡=âŸ¨ğ‘‹â€²,ğ‘…âŸ©ifğœ™(ğ‘‹â€²)=ğ‘…whenğ‘‹is the optimal one.
Moreconcretely, wedefinethefollowingfunctiontotestwhether
asubsequenceisconsistent withthe test results.
ğ‘ğ‘œğ‘›(ğ‘‹,âŸ¨ğ‘‡1,...,ğ‘‡ğ‘šâŸ©)=/braceleftbigg1ğ‘ğ‘œğ‘›â€²(ğ‘‹,ğ‘‡1) âˆ§...âˆ§ğ‘ğ‘œğ‘›â€²(ğ‘‹,ğ‘‡ğ‘š)
0 otherwise
ğ‘ğ‘œğ‘›â€²(ğ‘‹,âŸ¨ğ‘‹â€²,ğ‘…âŸ©)=/braceleftBigg/logicalandtext.1
ğ‘¥â€²
ğ‘–=0ğ‘¥ğ‘–=0ğ‘…=ğ‘‡/logicalortext.1
ğ‘¥â€²
ğ‘–=0ğ‘¥ğ‘–=1ğ‘…=ğ¹
Basedonthis function, we have the following result.
ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1,ğ‘‡1,ğ‘‡2,...,ğ‘‡ğ‘›)
ğ‘ƒğ‘Ÿ(ğ‘‡1,ğ‘‡2,..,ğ‘‡ğ‘›)
=/summationtext.1
ğ‘‹âˆˆX/parenleftBig
ğ‘¥ğ‘–âˆ—ğ‘ğ‘œğ‘›(ğ‘‹,âŸ¨ğ‘‡1,...,ğ‘‡ğ‘šâŸ©) âˆ—Î ğ‘—ğ‘ğ‘¥ğ‘—
ğ‘—(1âˆ’ğ‘ğ‘—)1âˆ’ğ‘¥ğ‘—/parenrightBig
/summationtext.1
ğ‘‹âˆˆX/parenleftBig
ğ‘ğ‘œğ‘›(ğ‘‹,âŸ¨ğ‘‡1,...,ğ‘‡ğ‘šâŸ©) âˆ—Î ğ‘—ğ‘ğ‘¥ğ‘—
ğ‘—(1âˆ’ğ‘ğ‘—)1âˆ’ğ‘¥ğ‘—/parenrightBig
Calculatingtheaboveformulaisatypicalweightedmodelcount-
ing problem [ 5]: we need to sum up the weight of any solution
ğ‘‹satisfyinga constraint ğ‘ğ‘œğ‘›(ğ‘‹,âŸ¨ğ‘‡1,...,ğ‘‡ğ‘šâŸ©),and theweightofa
solutionistheproductofthe weightofindividualassignmentsto
ğ‘¥ğ‘–(i.e.,ğ‘ğ‘–or1âˆ’ğ‘ğ‘–). However,sofarwe stilllackan efficient algo-
rithmtosolveweightedmodelcounting:astate-of-the-artsolver
1In thispaper weassume 00=1.often takes thousands of seconds to solve a model of thousands of
variables[ 5],whichistypicalindeltadebugging.Thisistooslow
to accelerate delta debugging.
Alternatively,insteadofcalculatingtheposteriorprobabilities
conditioned on all test results, we calculate the posterior prob-
abilities after every single test and update the model for future
calculations. Concretely, we update ğ‘ğ‘–toğ‘ƒğ‘Ÿ(ğœƒğ‘–=1|ğ‘‡)after a
testğ‘‡. This method ignores the interaction between different tests
and is not as precise as the previous one, but can be calculated
efficiently.
Belowwedescribehowtoupdate ğ‘ğ‘–foreachğ‘–.Firstwehavethe
following lemma.
Lemma 3.4. Given a subsequence ğ‘‹whereğ‘¥ğ‘–=1, .i.e, the ğ‘–ğ‘¡â„
elementispreservedin ğ‘‹,thenğœ™(ğ‘‹)âŠ¥ğœƒğ‘–,i.e.,ğœ™(ğ‘‹)andğœƒğ‘–areinde-
pendent.
Proof.Denote the indexes of elements excluded from ğ‘‹as
ğ‘—1, ğ‘—2,..., ğ‘—ğ‘˜.Then
ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ¹)=ğ‘ƒğ‘Ÿ(ğœƒğ‘—1=1âˆªğœƒğ‘—2=1âˆª...âˆªğœƒğ‘—ğ‘˜=1)
and
ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ‘‡)=ğ‘ƒğ‘Ÿ(ğœƒğ‘—1=0âˆ©ğœƒğ‘—2=0âˆ©...âˆ©ğœƒğ‘—ğ‘˜=0).
The independence between ğœƒğ‘—1,ğœƒğ‘—2,...,ğœƒğ‘—ğ‘˜andğœƒğ‘–implies the inde-
pendence between ğœ™(ğ‘‹)andğœƒğ‘–. â–¡
Given the above lemma, we show how to update ğ‘ğ‘–for eachğ‘–.
On the one hand, if the test fails, the posterior probability is as
follows.
ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1|ğœ™(ğ‘‹)=ğ¹)
=ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1)ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ¹|ğœƒğ‘–=1)
ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ¹)
=ï£±ï£´ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£´ï£³ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1)Â·1
1âˆ’Î ğ‘—(1âˆ’ğ‘ƒğ‘Ÿ(ğœƒğ‘—=1))1âˆ’ğ‘¥ğ‘—=ğ‘ğ‘–
1âˆ’Î ğ‘—(1âˆ’ğ‘ğ‘—)1âˆ’ğ‘¥ğ‘—ğ‘¥ğ‘–=0
ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1)ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ¹)
ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ¹)=ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1)=ğ‘ğ‘–ğ‘¥ğ‘–=1
On the other hand, if the test passes, the posterior probability is as
follows.
ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1|ğœ™(ğ‘‹)=ğ‘‡)
=ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1)ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ‘‡|ğœƒğ‘–=1)
ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ‘‡)
=ï£±ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£³ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1)Â·0
ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ‘‡)=0 ğ‘¥ğ‘–=0
ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1)ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ‘‡)
ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ‘‡)=ğ‘ƒğ‘Ÿ(ğœƒğ‘–=1)=ğ‘ğ‘–ğ‘¥ğ‘–=1
Basedontheaboveequations,weupdatetheparameter ğ‘ğ‘–for
eachğ‘–after atest ğœ™(ğ‘‹)=ğ‘…according to the following rules.
(1)ğ‘ğ‘–remainsunchangedif the ğ‘–thelement isincludedin ğ‘‹.
(2)ğ‘ğ‘–issettozeroifthe ğ‘–thelementisexcludedfrom ğ‘‹andthe
test function passes.
(3)ğ‘ğ‘–issettoğ‘ğ‘–
1âˆ’Î ğ‘—(1âˆ’ğ‘ğ‘—)1âˆ’ğ‘¥ğ‘—iftheğ‘–thelementisexcludedfrom
ğ‘‹andthe test function fails.
884Probabilistic DeltaDebugging ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
3.3 Select aSubsequence forTesting
We first define the gain of a test and then discuss how to maximize
the expectedgain.
3.3.1 The Gain of a Test. As we can see from the previous section,
whenğ‘‹passesthetest,theprobabilitiesoftheelementsexcluded
fromğ‘‹would be set to zero, i.e., these elements should not be
selected again for testing. As a result, each passed test excludes
someelementsfromthefinalresult.Tomeasurehowmanyelements
atestcanexclude,wedefinethe gainofatestonsubsequence ğ‘‹
as the number of elements excluded if the test passes, and zero
otherwise.
ğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹,ğ‘‹ğ‘‡)=/braceleftbigg|ğ‘’ğ‘¥(ğ‘‹,ğ‘‹ğ‘‡)|ğœ™(ğ‘‹)=ğ‘‡
0ğœ™(ğ‘‹)=ğ¹
Hereğ‘‹ğ‘‡denotesthelastsubsequencepassingthetestfunction,and
ğ‘’ğ‘¥(ğ‘‹,ğ‘‹ğ‘‡)denotesthesetofelementsnewlyexcludedwhenthetest
ofğ‘‹passes, i.e., ğ‘’ğ‘¥(ğ‘‹,ğ‘‹ğ‘‡)ğ‘–=1 iffğ‘¥ğ‘–=0 andğ‘ğ‘–>0. To simplify
presentation, we would omit the parameter ğ‘‹ğ‘‡if no confusion
would be caused, i.e., we would write ğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹)forğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹,ğ‘‹ğ‘‡)and
ğ‘’ğ‘¥(ğ‘‹)forğ‘’ğ‘¥(ğ‘‹,ğ‘‹ğ‘‡).
Basedontheprobabilisticmodel âŸ¨ğ‘1,ğ‘2,...,ğ‘ğ‘›âŸ©,wecancalcu-
latethe expectedgainofatest.
E[ğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹)]=|ğ‘’ğ‘¥(ğ‘‹)|ğ‘ƒğ‘Ÿ(ğœ™(ğ‘‹)=ğ‘‡)=|ğ‘’ğ‘¥(ğ‘‹)|Î ğ‘–(1âˆ’ğ‘ğ‘–)1âˆ’ğ‘¥ğ‘–
Therefore, the goal of selecting a subsequence for a test is to
selectasubsequence ğ‘‹that maximizesE[ğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹)].
3.3.2 Maximizing the ExpectedGain. Pleasenotethatsimply se-
lecting the subsequence that has the maximum probability to be
equal toğ‘‹âˆ—does not necessarily lead to the maximum expected
gain because the probability for it to pass the test function may be
low.
Tounderstandhow to maximize theexpectedgain,letusfirst
consider a simple situation where all probabilities ğ‘ğ‘–are equal.
In this case, any subsequence of the same size leads to the same
expected gain. Figure 2shows the relation between E[ğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹)]
and|ğ‘’ğ‘¥(ğ‘‹)|when any ğ‘ğ‘–is 0.1. As we can see from the figure,
when we remove more elements, the expected gain first increases
and then decreases, with the maximum at the inflection. This is
becauseE[ğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹)]is the product of two components, |ğ‘’ğ‘¥(ğ‘‹)|
andÎ ğ‘–(1âˆ’ğ‘ğ‘–)1âˆ’ğ‘¥ğ‘–. The first one monotonously increases, but the
rateofincreasegraduallydecreases.Thesecondonemonotonously
decreases, but the rate of decrease remains the same. Therefore,
theremustbeapointatwhichtherateofdecreasesurpassesthe
rateofincrease,whichmaximizesthe expectedgain.
Nowletusconsiderthecasewheretheprobabilitiesaredifferent.
The first component, |ğ‘’ğ‘¥(ğ‘‹)|, is not affected by this change. The
second component, Î ğ‘–(1âˆ’ğ‘ğ‘–)1âˆ’ğ‘¥ğ‘–, may lead to different values
for different subsequencesofthe same length.To selectthe subse-
quence with the maximum value, we need to exclude the elements
whose probabilitiesofbeing in ğ‘‹âˆ—are the lowest.
Based on the above analysis, we use the following procedure to
findasubsequencethathasthemaximumexpectedgain.Remember
ğ‘‹ğ‘‡isthe last subsequencethat passesthe test function.
(1) Sortthe elements in ğ‘‹ğ‘‡ascending bytheirprobabilities ğ‘ğ‘–.
0
5
10
15
20
25
30
35
40
|ex(X)|
0.0
0.5
1.0
1.5
2.0
2.5
3.0
3.5E[gain(X)]Figure 2:The relation between E[ğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹)]and|ğ‘’ğ‘¥(ğ‘‹)|
(2)Excludetheelementsonebyonefrom ğ‘‹ğ‘‡basedontheabove
order until the expectedgain begins to decrease.
(3) Return the subsequencewiththe highestexpectedgain.
LetË†ğ‘‹be the subsequence returned from the above procedure.
Thefollowingtheoremshowsthat Ë†ğ‘‹hasthemaximumexpected
gain.
Theorem3.5.E[ğ‘”ğ‘ğ‘–ğ‘›(Ë†ğ‘‹)] â‰¥E[ğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹)]for anyğ‘‹âŠ†ğ‘‹ğ‘‡.
Proof.Useğ‘†(ğ‘˜)to denote the subsequence obtained after re-
movingğ‘˜elements in step (2). First, we prove âˆ€ğ‘‹âŠ†ğ‘‹ğ‘‡, the subse-
quenceğ‘†(|ğ‘’ğ‘¥(ğ‘‹)|)whichexcludesthesamenumberofelementsas
ğ‘‹butselectselementsinorderofincreasingprobabilitycannothave
a worse expected gain. Second, we show the subsequence returned
by the algorithm has the highest expected gain among ğ‘†(ğ‘˜)where
1â‰¤ğ‘˜â‰¤ |ğ‘‹ğ‘‡|.As a result ğ¸[ğ‘”ğ‘ğ‘–ğ‘›(Ë†ğ‘‹)] â‰¥ğ¸[ğ‘”ğ‘ğ‘–ğ‘›(ğ‘†(|ğ‘’ğ‘¥(ğ‘‹)|))] â‰¥
ğ¸[ğ‘”ğ‘ğ‘–ğ‘›(ğ‘‹)].The details can be foundinAppendix. â–¡
s1s2s3s4s5s6s7s8
0.25000.25000.25000.25000.25000.25000.25000.2500
1s1s2s3s4s5s6s7s8F
0.36570.36570.36570.25000.25000.25000.25000.3657
2s1s2s3s4s5s6s7s8T
0.36570.36570.3657 00000.3657
3s1s2s3s4s5s6s7s8F
0.61190.36570.3657 00000.6119
4s1s2s3s4s5s6s7s8F
0.61190.61190.6119 00000.6119
5s1s2s3s4s5s6s7s8T
0.6119 00.6119 00000.6119
6s1s2s3s4s5s6s7s8F
0.6119 0100000.6119
7s1s2s3s4s5s6s7s8T
00100000.6119
8s1s2s3s4s5s6s7s8F
00100001
Figure 3:Iterations ofour algorithm
3.4 RevisitingtheMotivating Example
Figure3showsapossibletestingsequenceofProbDDforthemo-
tivating example. In Figure 3, each odd row represents each test,
and the selected elements are shown in cells with darker colors.
The last cell of each odd row shows the result of each test. Each
even row represents the probability of each element after a test.
The changes are shownincells withdarker colors.
885ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Guancheng Wang,RuobingShen, JunjieChen, Yingfei Xiong, andLu Zhang
Let us assume that the expected reduction ratio (Section 3.1.4) is
0.25andinitiallyallprobabilitiesaresetto0.2500.Ineachiteration,
ProbDDkeepsexcludingtheelementwiththelowestprobability
untiltheexpectedgainbeginstodecrease.Sincetheinitialproba-
bilities are all equal, the selection of the first iteration is effectively
random. ProbDD excludes ğ‘ 1,ğ‘ 2,ğ‘ 3, andğ‘ 8and the test function
fails, so ProbDD updates the probabilities of the removed elements
based onrule (3) at theend ofSection 3.2.At thesecond iteration,
ProbDDselectsfourelements withthelowestprobabilities, ğ‘ 4,ğ‘ 5,
ğ‘ 6,andğ‘ 7toexclude.Inthiscase,thetestpasses,soProbDDdirectly
sets the probabilities of the removed elements to zero according to
rule(2).ProbDDsampled {ğ‘ 2,ğ‘ 3}and{ğ‘ 1,ğ‘ 8}totestatthethirdand
fourthiteration,respectively. Theyall failed the testand the prob-
abilitiesoftheremovedelementsareupdatedaccordingly.Inthe
remainingiterations,theprobabilitiesoftheremainingelements
haveraisedtoalevelsuchthatonlyoneelementcouldbeexcluded
at each time, and the probability of the removed element would be
settoeither0or1basedonthetestresult.Finally,ProbDDstops
whentheprobabilityofeachelementiseither1or0,andreturns
{ğ‘ 3,ğ‘ 8}.
As we can see from theabove process,ProbDD learnsfrom the
historyoftests:whenremoving ğ‘ 8fails,theprobabilityof ğ‘ 8would
be increased and ğ‘ 8would not be repetitively selected for removal.
Furthermore,intheaboveprocess,ProbDDreturnsamuchsmaller
result{ğ‘ 3,ğ‘ 8}than ddmin. To reach this result, we need to remove
ğ‘ 4,ğ‘ 5,ğ‘ 6,andğ‘ 7,andthefourelementsneedtoberemovedtogether,
otherwise, the error could not be reproduced. Since ddmin uses
fixed boundaries to partition subsequences, it would never remove
the fourelementstogether.Onthe other hand, ProbDDdoes not
usefixedpartitions,andcouldpossiblytestanysubsequenceinthe
universeX.
4 PROPERTIESOFProbDD
Inthissection,wediscusstheefficiency,thecorrectness,andthe
minimalityofthe result.
4.1 Efficiency
Theorem 4.1. Given input with size n, the asymptotic number
oftestsperformed byProbDD is bounded byO(n)in theworstcase.
Proof.First,therecanbeatmost ğ‘›passedtestsaseachpassing
test sets the probability of at least one element to 0. Second,it can
be shown that there can be at most ğ‘‚(ğ‘›)failed tests before the
probabilitiesofallelementsareeitherzeroorlargerthan0.5.When
theprobabilitiesof all remainingelementsarelarger than0.5,the
algorithm will test elements one by one, so there could be at most
ğ‘‚(ğ‘›)failedtests left. The details can be foundinAppendix. â–¡
PleasenotethatthistheoremimpliesthattheProbDDalways
terminates.
4.2 Correctness
Theorem4.2. Thereturnedsubsequence ğ‘‹ğ‘‚ofProbDDwillal-
waysmaintain theproperty,i.e., ğœ™(ğ‘‹ğ‘‚)=ğ‘‡.
Proof.Letğ‘‹ğ‘˜beasubsequencewhereallelementswithzero
probability after the ğ‘˜th iteration are removed and all elementswith non-zero probabilities are kept, i.e., ğ‘¥ğ‘˜
ğ‘–=1â‡”ğ‘ğ‘–â‰ 0, and
ğ‘‹0be such a sequencebefore thefirstiteration. We show that ğ‘‹ğ‘˜
passes the test function for ğ‘˜=0 and any iteration ğ‘˜during an
algorithm execution,i.e., ğœ™(ğ‘‹ğ‘˜)=ğ‘‡.
First,itiseasytoseethat ğ‘‹0istheinputobjectandpassesthe
test function.
Letusassumethat ğ‘‹ğ‘˜passesthetestfunction.Ifthetestfunction
failsin iteration ğ‘˜+1, then only the probabilities of someelements
whoseprobabilitieswerenotzerowouldincrease,andthus ğ‘‹ğ‘˜+1=
ğ‘‹ğ‘˜still passes the test function. If the test function passes, the
probabilities of the removed elements would be set to zero, and
thusğ‘‹ğ‘˜+1isthesameasthetestedsubsequenceandpassesthetest
function.
Puttingtheabovetogether,theabovepropertyholds.Since ğ‘‹ğ‘‚is
ğ‘‹ğ‘˜forthelastiteration ğ‘˜,weknowthat ğ‘‹ğ‘‚passesthetestfunction.
â–¡
4.3 Minimality
Theorem 4.3. If monotony holds, the output of ProbDD ğ‘‹ğ‘‚is
minimal, i.e., âˆ€ğ‘‹âŠ‚ğ‘‹ğ‘‚,ğœ™(ğ‘‹)=ğ¹.
Proof.Letğ‘ ğ‘–betheelementin ğ‘‹ğ‘‚butnotin ğ‘‹.Sinceğ‘‹ğ‘‚isthe
output, we know that ğ‘ğ‘–=1. It is easy to seeğ‘ğ‘–
1âˆ’Î ğ‘—(1âˆ’ğ‘ğ‘—)1âˆ’ğ‘¥ğ‘—=1
only when âˆ€ğ‘˜â‰ ğ‘–,ğ‘ğ‘˜=0âˆ¨ğ‘¥ğ‘˜=1, i.e., there exists a failed test
onğ‘‹â€²where only ğ‘ ğ‘–is newly removed. Since ğ‘‹ğ‘‚is the output, we
know that ğ‘‹âŠ‚ğ‘‹ğ‘‚âŠ†ğ‘‹â€²âˆª {ğ‘ ğ‘–}. Sinceğ‘ ğ‘–is not in ğ‘‹, we know
ğ‘‹âŠ†ğ‘‹â€².Sinceğœ™(ğ‘‹â€²)=ğ¹,bymonotonywe have ğœ™(ğ‘‹)=ğ¹.â–¡
Theorem4.4. If monotony and unambiguity both hold, the out-
put ofProbDD ğ‘‹ğ‘‚is minimum,i.e., âˆ€ğ‘‹,|ğ‘‹|<|ğ‘‹ğ‘‚| â‡’ğœ™(ğ‘‹)=ğ¹
Proof.BytheproofofTheorem 3.3,minimum ğ‘‹âˆ—=/intersectiontext.1
ğœ™(ğ‘‹)=ğ‘‡ğ‘‹.
Sinceğœ™(ğ‘‹ğ‘‚)=ğ‘‡,weknow ğ‘‹âˆ—âŠ†ğ‘‹ğ‘‚.Letusassume ğ‘‹âˆ—âŠ‚ğ‘‹ğ‘‚.Then
from Theorem 4.3, we know that ğœ™(ğ‘‹âˆ—)=ğ¹, which contradicts the
definitionof ğ‘‹âˆ—.As aresult, ğ‘‹âˆ—=ğ‘‹ğ‘‚,i.e.,ğ‘‹ğ‘‚isminimum.â–¡
5 EVALUATION
As discussed before, many existing delta debugging approaches
aredomain-specificbasedontheddminalgorithm.Specifically,a
typical domain-specific delta debugging approach considers the
constraintsinthedomain,andappliesddmintosubsequencesof
theelementssuchthatthedomain-specificconstraintswouldnot
beviolated.Sinceourgoalistoimproveddmin,wewouldliketo
understandwhetherandhowmuchProbDDoutperformsddmin
indifferentapplicationdomains,i.e.,whethertheperformanceof
adomain-specificapproachimproveswhenreplacingddminwith
ProbDD.Furthermore,wewouldliketoinvestigatehowProbDD
compares with ACTIVECOARSEN [ 20], which is the only random-
izedsearchalgorithmthatcanbeappliedtodeltadebuggingwithin
our knowledge. To sum up, our evaluation addresses the following
researchquestions.
â€¢RQ1:HowdoesProbDDcomparetoddminindifferentap-
plicationdomains?
â€¢RQ2:Whatisthe impact of the parameterinProbDD?
â€¢RQ3:How does ProbDD compare with ACTIVECOARSEN?
886Probabilistic DeltaDebugging ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
5.1 Experiment Setup
Application Domains. Our evaluation considers the following
two application domains, in each of which we picked the repre-
sentativedeltadebuggingapproachbasedonddminasthetarget
approach.WereplacedtheddmincomponentwithProbDDineach
target approach, andcompared the performance with the original
target approach withddmin.
â€¢Trees.Therepresentativedeltadebuggingapproachfortrees
is HDD [ 21], and is often applied to programs where the
abstract syntax tree (AST)ofthe program isavailable.
â€¢C Programs .TherepresentativedebuggingtoolforCpro-
gramisCHISEL[ 13],whichreliesonboththegrammarof
C language and the dependency relations between elements
inprograms.
We chose the two domains because they are actively studied in
existingdelta debugging research andthere are publicly available
implementations of the representative approaches based on ddmin.
To facilitate presentation, we call the original HDD with ddmin
asd-HDD,andtheversionwhereddminisreplacedwithProbDD
asp-HDD.Similarly,thetwoversionsofCHISELiscalled d-CHISEL
andp-CHISEL ,respectively.Wealsouse d-version andp-version if
nospecific approach isreferredto.
Subjects. Wemainlypickedthesubjectsforevaluatingtheoriginal
approachesinexistingpublicationstoavoidselectionbias.More
specifically,we chosethe following subjects.
â€¢Trees. We used 30 subjects in the domain of trees. We used
the 20 publicly available subjects in the benchmark for com-
paring HDD and Perses [ 25], which are C programs trig-
geringcrashandcompilationbugsinGCCandClang.The
property to be preserved is to reproduce the reported bug
without any undefined behavior. Since these subjects all fall
into the application domain of C programs, we added 10
XMLreductiontasksfordiversity.Wecrawledacorpusof
more than 1,000 XML files from repositories of XML files
publicly available on the Internet, filtered out 73 of those
that cannot be parsed, and randomly picked 10 XML files
as subjects. The property to be preservedisto keep at least
the original test coverage on an XML parser xmllint [ 3]. We
did not use the benchmark in the original publication of
HDD[21]because itisnot publiclyavailable.
â€¢C Programs . We used 30 subjects in the domain of C pro-
grams. We used the benchmark for evaluating CHISEL [ 13],
which includes 10 subjects that are C programs to be de-
bloatedtobeusedinembeddedsystems,aswellasthesame
20subjectsusedfortrees.Thepropertyforthose10subjects
is to compile successfully, pass given test cases, and contain
specificfunctions.Thepropertyforthose20subjectstokeep
isthe same as that usedinthe applicationdomainoftrees.
Intotal,weused40subjectsinourevaluation,and20ofthemare
usedinbothapplicationdomains.Thenumberofsubjectsinour
evaluation is larger than all recent publications on delta debugging
attopvenues[ 13,15,16,18,21,23,25,29,30,32]asfarasweare
aware. We made full use of 16 cores of the server, and the whole
process of our evaluation took about 90 hours per core on average
(1,441hoursintotal).Metrics. Followingtheexistingwork[ 13,21,25],weusedthree
metricstomeasuretheeffectivenessofadeltadebuggingapproach
inthestudy,i.e., thesizeof theproducedresult ,theprocessingtime ,
andthenumberoftokensdeletedpersecond .Wemeasuredthesize
of the subjects in both domains using the number of tokens. We
measured the processing time in seconds. The reduction process of
each subject has a timeout limit of 3 hours. If timed out, the size of
theproducedresultisthesizeofthesmallestobjectinallpassed
tests and the processing time is not available. When calculating
the average results, we calculated geometric means rather than
arithmeticmeansbecausedifferentsubjectsdivergesignificantly
onthe three metrics.
Process. ToanswerRQ1,wefirstrecordedtheoriginalsizeforeach
subject. Then, we applied both d- and p-version of the approaches
foreachsubjectandrecordedthesizeoftheproducedresultand
the processing time. Then we calculated the number of tokens
deleted per second. Whatâ€™s more, we calculated the p-value of a
paired sample Wilcoxon signed-ranked test given the size of the
produced result, the number of tokens deleted per second, and the
processing time of the subjects without timeout on the both p- and
d-version to answer whether our approach achieves significant
improvementinbotheffectivenessandefficiencycompared to the
originalapproaches,respectively.
To answer RQ2, we adjusted the values of the only parameter
used in ProbDD, i.e., the initial value of probability ğœ. Since this
experiment is time-consuming, we sampled a subset of subjects for
this experiment. Considering the diversity of the reduction ratio
(i.e., the ratio of the smallest returned size to the original size),
we sorted the reduction ratio of all subjects and evenly selected
14subjectswiththereductionratiofrom0.005to0.899.These14
subjects are xml-10, xml-5, xml-6, xml-3, clang-27747, gcc-64990,
clang-27137, gcc-65383, gcc-71626, chown-8.2, mkdir-5.2.1, date-
8.21,sort-8.16,andgrep-2.19astheascendingorderofthereduction
ratio. We ran the first half of subjects in the application domain
of trees and the remaining subjects in the application domain of
Cprograms.Wechangedtheinitialvalueofprobability ğœto0.01,
0.05,0.1,0.15,0.2,0.25,and0.3,respectively.Foreachsetting,we
measured the results using all the metrics. Since some subjects are
timedout,wedonotpresenttheresultsontheprocessingtimebut
use the number of tokens deleted per second as the main metric
for efficiency. In this RQ, we did not conduct experiments on all
subjectsbecause itwouldtake avery longtime.
To answer RQ3, we selected ACTIVECOARSEN [ 20] as the rep-
resentativerandomsearchalgorithmandusedthedefaultsetting
inACTIVECOARSEN.ThenwecreatedtwoversionsofHDDand
CHISELbyreplacingddminwithACTIVECOARSEN,andthere-
spectiveversionsarecalled a-HDDanda-CHISEL .Thenwecom-
pared the a-version and the p-version in all subjects in all domains.
TheresultsofProbDD,CHISEL,andACTIVECOARSENarealso
affectedbyrandomness.Toreducetheinfluenceofrandomness,we
ran all versions affected by randomness 5 times and computed the
averageresults.Wechose5timesbecausethestandarddeviationof
the 5 running results for each subject and each approach is already
less than 1% of their corresponding average results. In RQ1 and
RQ3, we set ğœinProbDDto 0.1.
887ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Guancheng Wang,RuobingShen, JunjieChen, Yingfei Xiong, andLu Zhang
Table 1:Comparisonbetween ProbDD andddmin
Summary ğ‘¹ğ’Šp-version d-versionâ†‘ğ‘¹ğ’‘âˆ’ğ’—ğ’‚ğ’ğ’–ğ’†ğ‘¹Ã—ğ‘º ğ’‘âˆ’ğ’—ğ’‚ğ’ğ’–ğ’†ğ‘ºâ†‘ğ‘»ğ’‘âˆ’ğ’—ğ’‚ğ’ğ’–ğ’†ğ‘»ğ‘¹ğ’‘ğ‘ºğ’‘ğ‘»ğ’‘ğ‘¹ğ’…ğ‘ºğ’…ğ‘»ğ’…
Trees 31,533 376 9 778 928 4 2,115 59.48% 0.0000 2.25 0.0000 63.22% 0.0015
C Programs 64,782 8,791 31 874 9,935 17 1,597 11.51% 0.0012 1.82 0.0000 45.27% 0.0000
Inthistableandthetablesinthe restofthissection, ğ‘…representsthesizeoftheresults; ğ‘†representsthenumberoftokensdeletedperseconds; ğ‘‡representstheprocessing
timeinseconds; ğ‘…ğ‘–representsthesizeoftheinput; ğ‘representsthep-versions; ğ‘‘representsthed-versions; â†‘denotestheimprovement,where â†‘ğ‘‹=(ğ‘‹ğ‘‘âˆ’ğ‘‹ğ‘)/ğ‘‹ğ‘‘;Ã—ğ‘†
denotes the speedup, where Ã—ğ‘†=ğ‘†ğ‘/ğ‘†ğ‘‘. In this table, all numbers are geometric means, and the means of process time are only calculated on the subjects where both p- and
d-versionsfinish withinthe time limit.
Implementation. We introduce the implementations for both
applicationdomainsbelow.
â€¢Trees. We adopted a recent implementation of HDD [ 1,15]
inPythonasd-HDDandimplementedp-HDDanda-HDD
ontop ofthis implementation.
â€¢C Programs . We adopted the implementation of CHISEL
in C++ by the original authors [ 13] as d-CHISEL and imple-
mentedp-CHISELanda-CHISELontopofit.Inparticular,
theCHISELimplementationincludescomponentsfor auto-
maticdeadcodeelimination(DCE)anddependencyanaly-
sis(DA),andwedisabledthesecomponentsbyusingthree
command-lineoptions,i.e.,-skip_local_dep,-skip_global_dep,
and -skip_dce, due to the following reasons. First, DCE is
designedforprogramdebloatinginCHISELanditfailsmost
ofthetestsinotherdomains,e.g.,compilerbugstriggered
by unreachable code. Second, we found that the DA compo-
nentproducesincorrectresultsinsomecases,e.g.,whena
function call is passed as a parameter, which exists in the
subjects used in our evaluation. Please note that DCE and
DA are disabledfor allversionsofCHISEL.
OurevaluationwasperformedonaLinuxserverwith16-core
32-thread Intel(R) Xeon(R)Gold 6130 CPU (3.7GHz), 128 Gigabyte
RAM, andthe operating systemofUbuntuLinux 16.04.
5.2 Results andAnalysis
5.2.1 Comparison between ProbDD and ddmin. Table1shows the
overallperformance ofthep- and d-versions in termsof the three
metrics.From Table 1,we can see that p-versions perform better
thand-versionsinallmetrics.Onaverage,p-versionsdelete5and14
moretokenspersecondtoobtain59.48%and11.51%smallerresults
thand-versionsintheapplicationdomainsoftreesandCprograms,
respectively.Onthesubjectswherebothp-andd-versionsfinish
within the time limit, p-HDD and p-CHISEL use 63.22% and 45.27%
less time,respectively.Allp-valuesare significant (<0.05).
DetailedResultsinEachApplicationDomain. Wetheninves-
tigate the detailed results of p-versions for each subject in both
applicationdomains.Table 2showsthecomparisonresultsbetween
p-andd-versions.FromTable 2,thep-versionsoutperformthed-
versions on 58 out of 60 subjects. Here we define the p-version
outperformsthed-versiononasubjectifthep-versionhasbetter
resultinanyofthethreemetricsanddoesnothaveworseresultin
anyofthemetrics.Onlyon2subjects,mkdir-5.2.1andgrep-2.19,
the p-versionperforms worse thanthe d-version.
We analyzed the two subjects and found that, to preserve tar-
get properties, we have to keep consecutive subsequences in the
returned result. In other words, if we know the element at indexTable2: ComparisonbetweenProbDDandddmin:Detailed
Data
DSubjectp-version d-versionâ†‘ğ‘¹Ã—ğ‘ºâ†‘ğ‘»ğ‘¹ğ’‘ğ‘»ğ’‘ğ‘ºğ’‘ğ‘¹ğ’…ğ‘»ğ’…ğ‘ºğ’…
Treesclang-22382 355 998 20.755 355 4,915 4.214 0.0% 4.9249 79.7%
clang-22704 1,540 - 16.936 1,826 - 16.909 15.7% 1.0016 -
clang-23309 1,327 - 3.456 13,782 - 2.302 90.4% 1.5009 -
clang-23353 325 1,780 16.782 344 3,932 7.592 5.5% 2.2104 54.7%
clang-25900 634 7,458 10.502 723 - 7.244 12.3% 1.4498 -
clang-26760 397 - 19.369 624 - 19.348 36.4% 1.0011 -
clang-27137 206 - 16.142 238 - 16.139 13.4% 1.0002 -
clang-27747 227 4,256 40.792 315 - 16.067 27.9% 2.5389 -
clang-31259 1,010 - 4.425 3,800 - 4.167 73.4% 1.0620 -
gcc-59903 538 - 5.282 1,550 - 5.188 65.3% 1.0181 -
gcc-60116 8,420 - 6.186 16,658 - 5.423 49.5% 1.1407 -
gcc-61383 957 - 2.916 1,636 - 2.853 41.5% 1.0220 -
gcc-61917 322 8,393 10.132 378 - 7.869 14.8% 1.2876 -
gcc-64990 1,451 - 13.656 41,104 - 9.984 96.5% 1.3677 -
gcc-65383 710 8,119 5.325 42,583 - 0.126 98.3% 42.3275 -
gcc-66186 1,010 - 4.303 46,993 - 0.045 97.9% 95.1969 -
gcc-66375 551 - 6.013 10,668 - 5.076 94.8% 1.1846 -
gcc-70127 428 - 14.295 659 - 14.274 35.1% 1.0015 -
gcc-70586 17,969 - 17.990 49,488 - 15.071 63.7% 1.1936 -
gcc-71626 179 103 57.806 179 397 14.998 0.0% 3.8544 74.1%
xml-1 30 486 11.152 170 3,731 1.415 82.4% 7.8804 87.0%
xml-2 181 2,572 2.703 181 3,612 1.925 0.0% 1.4043 28.8%
xml-3 236 2,508 3.462 236 3,378 2.571 0.0% 1.3469 25.8%
xml-4 293 2,515 3.697 325 3,768 2.459 9.8% 1.5034 33.3%
xml-5 46 509 11.493 230 2,765 2.049 80.0% 5.6086 81.6%
xml-6 177 422 18.860 200 2,346 3.383 11.5% 5.5753 82.0%
xml-7 54 382 12.421 54 807 5.880 0.0% 2.1126 52.7%
xml-8 50 273 21.000 50 921 6.225 0.0% 3.3736 70.4%
xml-9 179 2,707 1.768 195 3,240 1.472 8.2% 1.2009 16.5%
xml-10 39 431 17.629 58 822 9.220 32.8% 1.9120 47.6%
C Programsmkdir-5.2.1 8,321 1,429 18.530 8,291 1,417 18.709 -0.4% 0.9905 -0.8%
rm-8.4 7,427 3,232 11.458 7,427 4,192 8.834 0.0% 1.2970 22.9%
chown-8.2 7,445 3,704 9.834 8,286 5,297 6.718 10.1% 1.4639 30.1%
grep-2.19 114,754 - 1.197 113,155 - 1.345 -1.4% 0.8899 -
bzip2-1.05 51,123 - 1.797 64,686 - 0.541 21.0% 3.3208 -
sort-8.16 51,848 - 3.354 55,336 - 3.031 6.3% 1.1066 -
gzip-1.2.4 16,548 - 2.720 30,074 - 1.468 45.0% 1.8531 -
uniq-8.16 14,045 9,242 5.390 14,201 - 4.598 1.1% 1.1723 -
date-8.21 20,219 9,920 3.349 33,541 - 1.843 39.7% 1.8175 -
tar-1.14 58,374 - 9.715 130,328 - 3.053 55.2% 3.1825 -
clang-22382 4,028 150 113.600 4,028 453 37.616 0.0% 3.0200 66.9%
clang-22704 1,224 2,917 62.811 1,742 3,749 48.733 29.7% 1.2889 22.2%
clang-23309 7,267 1,006 31.193 7,272 2,365 13.266 0.1% 2.3513 57.5%
clang-23353 7,698 694 32.418 7,741 1,911 11.750 0.6% 2.7589 63.7%
clang-25900 2,988 1,270 59.821 3,016 2,343 32.413 0.9% 1.8456 45.8%
clang-26760 4,970 2,286 89.504 5,241 3,345 61.087 5.2% 1.4652 31.7%
clang-27137 14,400 2,907 55.087 15,373 4,995 31.865 6.3% 1.7288 41.8%
clang-27747 6,270 717 233.710 6,324 1,011 165.693 0.9% 1.4105 29.1%
clang-31259 4,166 633 70.510 4,166 1,197 37.287 0.0% 1.8910 47.1%
gcc-59903 6,602 737 69.171 7,614 1,342 37.233 13.3% 1.8578 45.1%
gcc-60116 9,453 886 74.234 9,611 1,750 37.493 1.6% 1.9799 49.4%
gcc-61383 9,702 1,109 20.511 9,932 1,265 17.800 2.3% 1.1523 12.3%
gcc-61917 13,691 947 75.679 13,691 1,607 44.597 0.0% 1.6969 41.1%
gcc-64990 6,970 882 160.953 7,532 1,891 74.775 7.5% 2.1525 53.4%
gcc-65383 5,065 397 97.927 5,065 1,509 25.763 0.0% 3.8010 73.7%
gcc-66186 6,447 622 65.971 6,447 1,196 34.309 0.0% 1.9228 48.0%
gcc-66375 5,169 854 70.631 5,169 2,243 26.892 0.0% 2.6265 61.9%
gcc-70127 12,452 1,346 105.768 12,452 2,043 69.684 0.0% 1.5178 34.1%
gcc-70586 8,383 908 224.533 8,383 1,677 121.572 0.0% 1.8469 45.9%
gcc-71626 639 14 392.429 639 33 166.485 0.0% 2.3571 57.6%
ğ‘–is inğ‘‹âˆ—, elements at indexes ğ‘–âˆ’1 andğ‘–+1 are also likely to be
inğ‘‹âˆ—. This contradicts with our independence assumption, and
thus p-CHISEL does not have better performance. Nevertheless,
evenonthetwosubjectswhereourindependenceassumptiondoes
888Probabilistic DeltaDebugging ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
Trees C Programs020406080100â†‘R
Trees C Programs0246810xS
(a)Detailedresultdistribution of Table 2Trees C Programs020406080100â†‘R
Trees C Programs0246810xS
(b) Detailedresultdistribution of Table 4
Figure 4:Detailed resultdistribution
not hold, the performance of p-CHISEL is only slightly worse than
d-CHISEL.
Further,weconsiderthevalueslargerthan0and1inthecolumns
â†‘ğ‘…andÃ—ğ‘†of Table2, and use boxplots to show the distribution,
as shown in left and right sub-figures of Figure 4a, respectively. In
each box, the line that divides the box into two parts represents
themedianofthedata,theendsoftheboxshowstheupper(Q3)
and lower (Q1) quartiles, the difference between Quartiles 1 and
3 is called the interquartile range (IQR), the extreme line shows
Q3+1.5xIQRto Q1-1.5xIQR, andthe outliersare omitted.
RQ1:On average, ProbDD improves HDD and CHISEL by
deleting5and14moretokenspersecondtoobtain59.48%and
11.51% smaller results, respectively. On the subjects where
both versions finish within the time limit, ProbDD reduces
theexecutiontimeofHDDandCHISELby63.22%and45.27%,
respectively.
5.2.2 Impactofthe Parameter. We then investigatethe impactof
theonlyparameterinp-versions,i.e.,theinitialprobabilityforeach
elementğœ, based on the selected 14 subjects in both application
domains (as presented in Section 5.1). The results are shown in
Figure5.Theleftsub-figuresinFigure 5aandFigure 5bshowthe
geometric meansof the produced size,while the right sub-figures
depict the geometric means of the number of tokens deleted per
second. In each sub-figure, the blue line marks the performance of
ProbDD.Also,weusedtheredlinetomarktheperformanceofthe
originalapproacheswithddminfor clear comparison.
Weobservethatthoughdifferent ğœvaluescausedeviationsinthe
performance, the p-versions stably outperform the d-versions with
allstudied ğœvalues.Furthermore,theperformancedifferencesbe-
tween different ğœvalues is significantly smaller than the difference
between the p-versionsandthe d-versions.
RQ2:Theparameter ğœhasasmallimpactontheperformance
of ProbDD and ProbDD stably improves HDD and CHISEL
inallparametervalueswe tested.
5.2.3 Compared between ProbDD and ACTIVECOARSEN. Table3
shows the overall comparison results between p-versions and a-
versions on all the subjects in the application domains of trees and
Cprograms.Fromthistable,p-versionsdelete3and21moretokens
per second to obtain 58.68% and 27.03% smaller size of producedresult than a-versions on average in the application domains of
treesandCprograms,respectively.Onsubjectswherebothversions
finish, the p-versions also use 58.77% and 68.65% less time. The
detailedcomparisonresultsoneachsubjectcanbefoundinTable 4,
and the distribution of the improvement ( â†‘ğ‘…) and speedup ( Ã—ğ‘†)
achievedbyProbDDcan be foundinFigure 4b.
RQ3:Onaverage,p-versionssignificantlyoutperforma-versions
bydeleting3and22moretokenspersecondtoobtain58.68%
and27.03%smallerresultsintheapplicationdomainsoftrees
andCprograms,respectively.Onthesubjectswherebothver-
sionsfinishwithinthe timelimit,p-versionsuse58.77%and
68.65% less processing time on the two domains, respectively.
5.3 Threatsto Validity
The threat to internalvalidity mainly lies in the correctness of
the implementation of p-versions and the experimental scripts. To
reduce this threat,we have carefullyreviewedour code.
The threat to externalvalidity mainly lies in the subjects and
the target approaches. Regarding the subjects used in our study,
weadoptedthesubjectsusedinexistingpublicationsforthetwo
applicationdomains,i.e.,treesandCprograms.Besides,toincrease
the subject diversity in the domain of trees, we additionallyevalu-
atedourapproachon10XMLfiles,whichwererandomlypicked
fromthecrawledcorpus.Inthefuture,wewillevaluateProbDDon
moresubjects.Regardingthetargetapproaches,weadoptedtwo
representative approaches in domains of trees and C programs, i.e.,
HDDandCHISEL,as presentedinSection 5.1.
Thethreatto construct validitymainlyliesinrandomness.The
randomness may impact the performance of p-versions, a-versions,
and d-CHISEL. To reduce this threat, we ran each of them on each
subject5timesandcalculatedtheaverageresultsaspresentedin
Section5.1.
6 RELATED WORK
Delta Debugging Approaches built on ddmin. As the basic
algorithm for delta debugging, ddmin was proposed by Zeller and
Hildebrandt to minimize failure-inducing test inputs [ 32], which
has been described in Section 1and2. Further, they proposed an
extended version of ddmin, named dd, which aims to obtain a
889ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Guancheng Wang,RuobingShen, JunjieChen, Yingfei Xiong, andLu Zhang
(a)Impact of ğœintrees (b) Impact of ğœinC programs
Figure 5:Impactof ğœforProbDD
Table 3:Comparisonbetween ProbDD andACTIVECOARSEN
Summary ğ‘¹ğ’Šp-version a-versionâ†‘ğ‘¹ğ’‘âˆ’ğ’—ğ’‚ğ’ğ’–ğ’†ğ‘¹Ã—ğ‘º ğ’‘âˆ’ğ’—ğ’‚ğ’ğ’–ğ’†ğ‘ºâ†‘ğ‘»ğ’‘âˆ’ğ’—ğ’‚ğ’ğ’–ğ’†ğ‘»ğ‘¹ğ’‘ğ‘ºğ’‘ğ‘»ğ’‘ğ‘¹ğ’‚ğ‘ºğ’‚ğ‘»ğ’‚
Trees 31,533 376 9 778 910 6 1,887 58.68% 0.0000 1.5 0.0000 58.77% 0.0015
C Programs 64,782 8,791 31 874 12,597 9 2,788 27.03% 0.0000 3.33 0.0000 68.65% 0.0001
minimaldifferencebetweenapassingtestinputandafailingtest
inputratherthanaminimal failure-inducingtest input[ 32].
Subsequently,someapproacheswrapddminfordifferentdomain-
specific structures. Misherghi and Su [ 21] proposed HDD for more
effective delta debugging on tree-structured data that has been
described in Section 1. Inspired by HDD, modernized HDD [ 15],
coarseHDD[ 16],andHDDr[ 18]wereproposedtofurtherimprove
theperformanceofHDD.Forexample,HDDrisarecursivevariant
ofHDD.Sun etal.[ 25]proposedPerses,whichutilizestheformal
syntax of a programming language to guide reduction and always
produces syntactically valid subsequences. For each iteration of
reduction, Perses invokes ddmin to prune the nodes in the parse
tree for quantified nodes, and it proposes replacement strategies
forregularnodes.CHISEL[ 13],implementedbasedonPerses,in-
troduces dependency analysis to understand which elements need
to be removed together. CHISEL also improves ddmin, and builds a
decision tree model to prune the predefined sequences of ddmin
duringthe reduction process.
Different from most existing approaches that wrap ddmin for
differentdomains,ourworkaimstoimproveddminitself.Different
from ddmin, ProbDD builds a probabilistic model to guide the tests
and updates the model based on the test results. Our study has
demonstratedthatProbDDsignificantlyimprovestheperformance
ofrepresentativeapproachesbuiltonddminindifferentapplication
domainsbyreplacing ddminwithProbDD.
Amongtheexistingapproaches,CHISELalsobuildsstatistical
model to improve ddmin and thus is closely related to our work.
However, CHISEL still relies on the predefined sequence of at-
tempts in ddmin and only uses the statistical model to prioritize
attempts in the sequence. Different from it, ProbDD directly se-
lects elements based on the learned distribution. Our evaluation
has demonstrated that ProbDD could significantly improve the
performance ofCHISEL.
Delta Debugging Approaches based on transformation tem-
plates.There are some approaches that employ transformation
templates to transform an original object. GTR [ 14] defines twotransformationtemplatesfortree-structureddataandcanautomati-
callychoosewhichtemplatetouseinthereductionstepbylearning
fromacorpusofexampledata.C-Reduce[ 23]wasproposedtosolve
the problem of test-case minimization, which employs plenty of
source-to-source transformations for a more effective reduction on
C, C++, and OpenCL programs. Although these transformation-
template-baseddeltadebuggingapproachescanfurtherimprovethe
reductioneffectivenessin theirdomains [ 14,23], theysufferfrom
the serious efficiency problem based on the existing study [ 13,25].
In thispaper,wefocusonsolving theefficiencyprobleminthe
existing approaches built on ddmin. Improving the transformation-
template-basedapproachesisfuture work.
BlackboxOptimization. Deltadebuggingisablackboxoptimiza-
tion problem. Bayesian optimization is widely used to solve black-
boxoptimizationproblems.Itbuildsaprobabilisticmodelandup-
dates the model with test results [ 22]. ProbDD can be viewed as
a Bayesian optimization algorithm specifically designed for the
deltadebuggingproblem.DifferentfromtheclassicBayesianop-
timization algorithms that are designed for objective functions
modeled by Gaussian process regression [ 12], ProbDD targets the
deltadebuggingproblemwith binarytestresults.Althoughrecently
some Bayesian optimization approaches were proposed for binary
objective functions [ 26,33], they are designed for specific tasks.
Furthermore,someBayesianapproacheshavebeenproposedfor
otherdebuggingtasks,e.g.,slicing[ 19]andfaultlocalization[ 4].To
ourknowledge,thereisnoexistingBayesianoptimizationapproach
that can be appliedto solve the delta debuggingproblem.
Furthermore, heuristic search algorithms (such as the genetic
searchalgorithms[ 24])arealsowidelyusedtosolveblackboxop-
timizationproblems,butsimilartoclassicBayesianoptimization,
classic heuristic search algorithms rely on continuous fitness func-
tions.Sincethetestresultsarebinary,howtodesignaneffective
fitnessfunctiontoguidethesealgorithmsisanopenproblemfor
future research.
The only heuristicsearch approach that can beappliedto delta
debugging within our knowledge is ACTIVECOARSEN [ 20]. It
aims to find a minimal abstraction in the domain of static analyses
890Probabilistic DeltaDebugging ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
Table 4: Comparison between ProbDD and ACTIVE-
COARSEN:Detailed Data
DSubjectp-version a-versionâ†‘ğ‘¹Ã—ğ‘ºâ†‘ğ‘»ğ‘¹ğ’‘ğ‘»ğ’‘ ğ‘ºğ’‘ğ‘¹ğ’‚ğ‘»ğ’‚ğ‘ºğ’‚
Treesclang-22382 355 998 20.755 452 4,250 4.851 21.5% 4.2786 76.5%
clang-22704 1,540 - 16.936 9,342 - 16.213 83.5% 1.0446 -
clang-23309 1,327 - 3.456 2,836 - 3.316 53.2% 1.0422 -
clang-23353 325 1,780 16.782 394 7,578 3.933 17.5% 4.2672 76.5%
clang-25900 634 7,458 10.502 1,248 - 7.196 49.2% 1.4595 -
clang-26760 397 - 19.369 544 - 19.355 27.0% 1.0007 -
clang-27137 206 - 16.142 1,280 - 16.042 83.9% 1.0062 -
clang-27747 227 4,256 40.792 945 - 16.009 76.0% 2.5481 -
clang-31259 1,010 - 4.425 1,380 - 4.391 26.8% 1.0078 -
gcc-59903 538 - 5.282 1,461 - 5.196 63.2% 1.0165 -
gcc-60116 8,420 - 6.186 10,880 - 5.958 22.6% 1.0382 -
gcc-61383 957 - 2.916 6,652 - 2.389 85.6% 1.2208 -
gcc-61917 322 8,393 10.132 8,969 - 7.073 96.4% 1.4325 -
gcc-64990 1,451 - 13.656 35,791 - 10.476 95.9% 1.3035 -
gcc-65383 710 8,119 5.325 2,201 - 3.865 67.7% 1.3777 -
gcc-66186 1,010 - 4.303 1,716 - 4.237 41.1% 1.0154 -
gcc-66375 551 - 6.013 7,095 - 5.407 92.2% 1.1121 -
gcc-70127 428 - 14.295 629 - 14.277 32.0% 1.0013 -
gcc-70586 17,969 - 17.990 27,172 - 17.138 33.9% 1.0497 -
gcc-71626 179 103 57.806 204 728 8.144 12.3% 7.0978 85.9%
xml-1 30 486 11.152 70 1,116 4.821 57.1% 2.3134 56.5%
xml-2 181 2,572 2.703 263 3,408 2.016 31.2% 1.3409 24.5%
xml-3 236 2,508 3.462 236 6,971 1.246 0.0% 2.7795 64.0%
xml-4 293 2,515 3.697 314 4,288 2.163 6.7% 1.7088 41.3%
xml-5 46 509 11.493 46 1,950 3.000 0.0% 3.8310 73.9%
xml-6 177 422 18.860 377 500 15.518 53.1% 1.2154 15.6%
xml-7 54 382 12.421 54 603 7.869 0.0% 1.5785 36.7%
xml-8 50 273 21.000 50 1,669 3.435 0.0% 6.1135 83.6%
xml-9 179 2,707 1.768 207 2,900 1.641 13.5% 1.0776 6.7%
xml-10 39 431 17.629 263 505 14.602 85.2% 1.2073 14.7%
C Programsmkdir-5.2.1 8,321 1,429 18.530 8,398 - 2.445 0.9% 7.5798 -
rm-8.4 7,427 3,232 11.458 15,867 - 2.647 53.2% 4.3280 -
chown-8.2 7,445 3,704 9.834 18,120 - 2.384 58.9% 4.1245 -
grep-2.19 114,754 - 1.197 114,871 - 1.186 0.1% 1.0091 -
bzip2-1.05 51,123 - 1.797 55,790 - 1.365 8.4% 1.3166 -
sort-8.16 51,848 - 3.354 71,271 - 1.555 27.3% 2.1563 -
gzip-1.2.4 16,548 - 2.720 35,799 - 0.938 53.8% 2.9003 -
uniq-8.16 14,045 9,242 5.390 47,209 - 1.542 70.2% 3.4958 -
date-8.21 20,219 9,920 3.349 37,061 - 1.517 45.4% 2.2080 -
tar-1.14 58,374 - 9.715 132,849 - 2.819 56.1% 3.4460 -
clang-22382 4,028 150 113.600 5,626 496 31.133 28.4% 3.6488 69.8%
clang-22704 1,224 2,917 62.811 2,288 6,425 28.351 46.5% 2.2155 54.6%
clang-23309 7,267 1,006 31.193 7,937 5,553 5.530 8.4% 5.6403 81.9%
clang-23353 7,698 694 32.418 7,850 3,062 7.298 1.9% 4.4421 77.3%
clang-25900 2,988 1,270 59.821 4,462 1,971 37.797 33.0% 1.5827 35.6%
clang-26760 4,970 2,286 89.504 5,489 5,653 36.103 9.5% 2.4792 59.6%
clang-27137 14,400 2,907 55.087 14,456 6,597 24.266 0.4% 2.2701 55.9%
clang-27747 6,270 717 233.710 6,322 4,072 41.139 0.8% 5.6810 82.4%
clang-31259 4,166 633 70.510 5,894 3,089 13.890 29.3% 5.0765 79.5%
gcc-59903 6,602 737 69.171 9,292 4,378 11.030 28.9% 6.2712 83.2%
gcc-60116 9,453 886 74.234 12,786 4,505 13.860 26.1% 5.3561 80.3%
gcc-61383 9,702 1,109 20.511 9,884 4,093 5.513 1.8% 3.7205 72.9%
gcc-61917 13,691 947 75.679 14,705 4,455 15.860 6.9% 4.7718 78.7%
gcc-64990 6,970 882 160.953 9,940 2,842 48.906 29.9% 3.2911 69.0%
gcc-65383 5,065 397 97.927 9,127 1,377 25.283 44.5% 3.8732 71.2%
gcc-66186 6,447 622 65.971 8,990 2,749 14.002 28.3% 4.7116 77.4%
gcc-66375 5,169 854 70.631 6,672 3,515 16.733 22.5% 4.2211 75.7%
gcc-70127 12,452 1,346 105.768 13,725 4,407 32.015 9.3% 3.3037 69.5%
gcc-70586 8,383 908 224.533 11,625 3,010 66.656 27.9% 3.3685 69.8%
gcc-71626 639 14 392.429 699 88 61.750 8.6% 6.3551 84.1%
usingheuristicsearch.Inourevaluation,weconsideredACTIVE-
COARSENasabaselineandtheresultsthatsuggestthatProbDD
outperforms ACTIVECOARSEN inimproving therepresentative
approachesinthe twodomains.
Recently,Xinetal .[27]alsoproposeasoftwaredebloatingap-
proach, DEBOP, that is based on MCMC with Metropolis-Hastings
sampling Ã a typical blackbox optimization approach. However,
DEBOPtargetsasoftwaredebloatingproblemthatisdifferentfrom
the standardone: instead of passing a testing function,the goalof
thisproblemistomaximizeasetofcontinuousobjectivefunctions.
Inotherwords,thereisnobinarytestfunctionandthustheMCMC
algorithm applies.7 FUTUREWORK
Unlike traditional delta debugging algorithms that search with
a pre-defined order, our approach ProbDD builds a probabilistic
model to estimate the probabilities of the elements to be kept in
theproducedresult. Abasic assumptionofthis modelisthateach
elementisindependentlyrelatedtothepropertytobepreserved.
However, elements may depend on each other due to structural
constraintsinthetargetdomain.Forexample,inatreestructure,
theexistenceofachilddependsontheexistenceofitsparent.Inthis
paper,weensurethesestructuralconstraintsbybuildingProbDD
into existing approaches such that these existing approaches apply
ProbDD to only the subsets that would not violate the constraints.
A more direct way to accomplish this is to directly build these
constraints in the probabilistic model. For example, in a tree of
two elements, we can use two random variables to represent the
probability of the parent and the conditional probability of the
childwhentheparentispresent.Wedonotneedtheconditional
probability of the child when the parent is not present because we
knowthe probability iszero.This isafuture direction.
8 CONCLUSION
Inthispaper,weproposeaprobabilisticdeltadebuggingalgorithm,
ProbDD,whichbuildsaprobabilisticmodeltoestimatetheprobabil-
ityofeachelementtobekeptinthereducedresult.ProbDDselects
a subset of elements basedon the probabilistic model to maximize
the gain of the next test, tests whether the subset maintains the
property, and improves the model based on the test results. Our al-
gorithmterminateswhenthe learnedprobabilitiesare either1or0.
Further, we prove the correctness of ProbDD, and analyze the min-
imalityofitsresultanditsworst-caseasymptoticnumberoftests.
We evaluated ProbDD in two application domains, i.e., trees and C
programs.Onaverage,afterreplacingddminwithProbDD,HDD
and CHISEL produces 59.48% and 11.51% smaller results within
the time limit, respectively. On the subjects where both versions
finish within the time limit, HDD and CHISEL with ProbDD use
63.22% and 45.27% less time, respectively. The results demonstrate
that learns from the test results based on a probabilistic model is a
promisingdirection andcallfor future work.
Ourtool,benchmarks,andtheappendixcontainingproofsfor
the theorems can be foundat:
https://github.com/Amocy-Wang/ProbDD
ACKNOWLEDGEMENTS
We thank the anonymous FSEreviewers for their thoughtful com-
mentsandeffortstowardsimprovingthiswork.Thisworkissup-
ported by the National Key Research and Development Program
ofChinaunderGrantNo.2017YFB1001803,theNationalNatural
Science Foundation of China under Grant Nos. 61922003, 62002256.
REFERENCES
[1]Accessed:2021. Theimplementationofmodernized HDD. https://github.com/
renatahodovan/picireny
[2] Accessed:2021. Tensorflowtutorials. https://www.tensorflow.org/guide
[3] Accessed:2021. xmllint. http://xmlsoft.org/xmllint.html
[4]Rui Abreu, Alberto Gonzalez-Sanchez, and Arjan JC van Gemund. 2010. Ex-
ploiting count spectra for bayesian fault localization. In Proceedings of the 6th
International Conference on Predictive Models in Software Engineering . 1Å›10.
https://doi.org/10.1145/1868328.1868347
891ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece Guancheng Wang,RuobingShen, JunjieChen, Yingfei Xiong, andLu Zhang
[5]Supratik Chakraborty, Dror Fried, Kuldeep S Meel, and Moshe Y Vardi. 2015.
From Weighted to Unweighted Model Counting. In IJCAI. 689Å›695. https:
//dl.acm.org/doi/10.5555/2832249.2832345
[6]Junjie Chen, Jiaqi Han, Peiyi Sun, Lingming Zhang, Dan Hao, and Lu Zhang.
2019. Compilerbugisolationviaeffectivewitnesstestprogramgeneration.In
Proceedingsofthe201927thACMJointMeetingonEuropeanSoftwareEngineering
ConferenceandSymposiumon theFoundationsofSoftwareEngineering .223Å›234.
https://doi.org/10.1145/3338906.3338957
[7]Junjie Chen, Guancheng Wang, Dan Hao, Yingfei Xiong, Hongyu Zhang, and
LuZhang.2019. History-guidedconfigurationdiversificationforcompilertest-
program generation. In 2019 34th IEEE/ACM International Conference on Auto-
mated Software Engineering (ASE) . IEEE, 305Å›316. https://doi.org/10.1109/ase.
2019.00037
[8]Junjie Chen, Guancheng Wang, Dan Hao, Yingfei Xiong, Hongyu Zhang, Lu
Zhang,andXIEBing.2018. Coveragepredictionforacceleratingcompilertesting.
IEEE Transactions on Software Engineering (2018).https://doi.org/10.1109/tse.
2018.2889771
[9]ArpitChristi,MatthewLyleOlson, MohammadAminAlipour,andAlexGroce.
2018.Reducebeforeyoulocalize:Delta-debuggingandspectrum-basedfaultlocal-
ization. In 2018 IEEE International Symposium on Software Reliability Engineering
Workshops (ISSREW) . IEEE,184Å›191. https://doi.org/10.1109/issrew.2018.00005
[10]HolgerCleveandAndreasZeller.2005. Locatingcausesofprogramfailures.In
Proceedings. 27th International Conference on Software Engineering, 2005. ICSE
2005.IEEE,342Å›351. https://doi.org/10.1109/icse.2005.1553577
[11]AlastairFDonaldson,PaulThomson,VasylTeliman,StefanoMilizia,AndrÃ©Perez
Maselco,andAntoniKarpiÅ„ski.2021. Test-CaseReductionandDeduplication
Almost for Free with Transformation-Based Compiler Testing. (2021). http:
//multicore.doc.ic.ac.uk/publications/pldi-21.html
[12]Peter I. Frazier. 2018. A Tutorial on Bayesian Optimization.
arXiv:1807.02811 [stat.ML] https://arxiv.org/abs/1807.02811
[13]KihongHeo,WoosukLee,PardisPashakhanloo,andMayurNaik.2018. Effective
program debloating via reinforcement learning. In Proceedings of the 2018 ACM
SIGSACConference on ComputerandCommunications Security .380Å›394. https:
//doi.org/10.1145/3243734.3243838
[14]Satia Herfert, Jibesh Patra, and Michael Pradel. 2017. Automatically reducing
tree-structuredtestinputs.In 201732ndIEEE/ACMInternationalConferenceon
AutomatedSoftwareEngineering(ASE) . IEEE,861Å›871. https://doi.org/10.1109/
ase.2017.8115697
[15]RenÃ¡taHodovÃ¡n andÃkosKiss.2016. Modernizinghierarchicaldeltadebugging.
InProceedings of the 7th International Workshop on Automating Test Case Design,
Selection,and Evaluation . 31Å›37.https://doi.org/10.1145/2994291.2994296
[16]RenÃ¡taHodovÃ¡n,ÃkosKiss,andTiborGyimÃ³thy.2017. Coarsehierarchicaldelta
debugging. In 2017 IEEE international conference on software maintenance and
evolution(ICSME) . IEEE,194Å›203. https://doi.org/10.1109/icsme.2017.26
[17]Sunghun Kim, Thomas Zimmermann, Kai Pan, E James Jr, et al .2006. Au-
tomatic identification of bug-introducing changes. In 21st IEEE/ACM inter-
national conference on automated software engineering (ASEâ€™06) . IEEE, 81Å›90.
https://doi.org/10.1109/ase.2006.23
[18]Ãkos Kiss, RenÃ¡ta HodovÃ¡n, and Tibor GyimÃ³thy. 2018. HDDr: a recursive
variantofthehierarchicaldeltadebuggingalgorithm.In Proceedingsofthe9th
ACMSIGSOFTInternationalWorkshoponAutomatingTESTCaseDesign,Selection,
and Evaluation . 16Å›22.https://doi.org/10.1145/3278186.3278189[19]Seongmin Lee, David Binkley, Robert Feldt, Nicolas Gold, and Shin Yoo. 2019.
MOAD: Modeling Observation-based Approximate Dependency. In 2019 19th
International Working Conference on Source Code Analysis and Manipulation
(SCAM). IEEE,12Å›22. https://doi.org/10.1109/scam.2019.00011
[20]Percy Liang, Omer Tripp, and Mayur Naik. 2011. Learning minimal abstractions.
InProceedingsofthe38thannualACMSIGPLAN-SIGACTsymposiumonPrinciples
ofprogramminglanguages . 31Å›42.https://doi.org/10.1145/1926385.1926391
[21]Ghassan Misherghi and Zhendong Su. 2006. HDD: hierarchical delta debugging.
InProceedingsofthe28thinternationalconferenceonSoftwareengineering .142Å›151.
https://doi.org/10.1145/1134285.1134307
[22]Martin Pelikan, David E Goldberg, Erick CantÃº-Paz, et al .1999. BOA: The
Bayesianoptimizationalgorithm.In Proceedingsofthegeneticandevolutionary
computation conference GECCO-99 , Vol. 1. Citeseer, 525Å›532. https://dl.acm.org/
doi/10.5555/2933923.2933973
[23]John Regehr, Yang Chen, Pascal Cuoq, Eric Eide, Chucky Ellison, and Xuejun
Yang.2012. Test-casereductionforCcompilerbugs.In Proceedingsofthe33rd
ACM SIGPLAN conference on Programming Language Design and Implementation .
335Å›346. https://doi.org/10.1145/2254064.2254104
[24]Mandavilli Srinivas and Lalit M Patnaik. 1994. Genetic algorithms: A survey.
computer 27,6 (1994), 17Å›26. https://dl.acm.org/doi/10.1109/2.294849
[25]Chengnian Sun, Yuanbo Li, QirunZhang, Tianxiao Gu, and Zhendong Su. 2018.
Perses: syntax-guided program reduction. In Proceedings of the 40th International
ConferenceonSoftwareEngineering .361Å›371. https://doi.org/10.1145/3180155.
3180236
[26]Kevin Swersky, Yulia Rubanova, David Dohan, and Kevin Murphy. 2020. Amor-
tizedbayesianoptimizationoverdiscretespaces.In ConferenceonUncertainty
in Artificial Intelligence . PMLR, 769Å›778. http://proceedings.mlr.press/v124/
swersky20a.html
[27]Qi Xin, Myeongsoo Kim, Qirun Zhang, and Alessandro Orso. 2020. Program
debloating via stochastic optimization. In Proceedings of the ACM/IEEE 42nd
InternationalConferenceonSoftwareEngineering:NewIdeasandEmergingResults .
65Å›68.https://doi.org/10.1145/3377816.3381739
[28]GuixinYe,ZhanyongTang,ShinHweiTan,SongfangHuang,DingyiFang,Xi-
aoyang Sun, Lizhong Bian, Haibo Wang, and Zheng Wang. 2021. Automated
ConformanceTesting for JavaScript EnginesviaDeepCompilerFuzzing. arXiv
preprint arXiv:2104.07460 (2021). arXiv: 2104.07460 [cs.PL]https://arxiv.org/abs/
2104.07460
[29] Andreas Zeller. 1999. Yesterday, myprogram worked.Today, it doesnot. Why?
ACM SIGSOFT Software engineering notes 24, 6 (1999), 253Å›267. https://doi.org/
10.1145/318774.318946
[30]Andreas Zeller. 2002. Isolating cause-effect chains from computer programs.
ACMSIGSOFTSoftwareEngineeringNotes 27,6(2002),1Å›10. https://doi.org/10.
1145/587051.587053
[31]AndreasZeller.2009. Whyprogramsfail:aguidetosystematicdebugging . Elsevier.
https://www.elsevier.com/books/why-programs-fail/zeller/978-0-08-092300-0
[32]Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and isolating failure-
inducing input. IEEETransactionson Software Engineering 28,2(2002), 183Å›200.
https://doi.org/10.1109/32.988498
[33]YehongZhang,ZhongxiangDai,andBryanKianHsiangLow.2020.Bayesianopti-
mizationwithbinaryauxiliaryinformation.In UncertaintyinArtificialIntelligence .
PMLR, 1222Å›1232. arXiv: 1807.02811 [stat.ML] https://arxiv.org/abs/1906.07277
892