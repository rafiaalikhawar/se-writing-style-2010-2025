Knowledge-Based Environment Dependency Inference for
Python Programs
Hongjie Ye
State Key Lab of Computer Sciences,
Institute of Software, Chinese
Academy of Sciences
University of Chinese Academy of
Sciences, Beijing, China
yehongjie19@otcaix.iscas.ac.cnWei Chen∗†
State Key Lab of Computer Sciences,
Institute of Software, Chinese
Academy of Sciences
University of Chinese Academy of
Sciences, Beijing, China
wchen@otcaix.iscas.ac.cnWensheng Dou†
State Key Lab of Computer Sciences,
Institute of Software, Chinese
Academy of Sciences
University of Chinese Academy of
Sciences, Beijing, China
wsdou@otcaix.iscas.ac.cn
Guoquan Wu†
State Key Lab of Computer Sciences,
Institute of Software, Chinese
Academy of Sciences
University of Chinese Academy of
Sciences, Beijing, China
gqwu@otcaix.iscas.ac.cnJun Wei
State Key Lab of Computer Sciences,
Institute of Software, Chinese
Academy of Sciences
University of Chinese Academy of
Sciences, Beijing, China
wj@otcaix.iscas.ac.cn
ABSTRACT
Besides third-party packages, the Python interpreter and system
libraries are also critical dependencies of a Python program. In our
empirical study, 34% programs are only compatible with specific
Python interpreter versions, and 24% programs require specificsystem libraries. However, existing techniques mainly focus on
inferring third-party package dependencies. Therefore, they can
lack other necessary dependencies and violate version constraints,
thus resulting in program build failures and runtime errors.
Thispaperproposesaknowledge-basedtechniquenamedPyEGo,
whichcanautomaticallyinferdependenciesofthird-partypackages,
the Python interpreter, and system libraries at compatible versions
for Python programs. We first construct the dependency knowl-
edge graph PyKG, which can portray the relations and constraints
among third-party packages, the Python interpreter, and system
libraries.Then,byqueryingPyKGwithextractedprogramfeatures,
PyEGoconstructsaprogram-relatedsub-graphwithdependency
candidatesofthethreetypes.Itfinallyoutputsthelatestcompatible
dependencyversionsbysolvingconstraintsinthesub-graph.We
evaluate PyEGoon 2,891single-filePython gists,100 open-source
∗Wei Chen is the corresponding author.
†WeiChen,WenshengDouandGuoquanWuarealsoaffiliatedwithNanjingInstitute
of Software Technology and University of Chinese Academy of Sciences, Nanjing,
China.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510127Python projects and 4,836 jupyter notebooks. The experimental re-
sultsshowthatPyEGoachievesbetteraccuracy,0.2xto3.5xhigher
than the state-of-the-art approaches.
CCS CONCEPTS
•Softwareanditsengineering →Softwarelibrariesandrepos-
itories;Software maintenance tools; Maintaining software;
KEYWORDS
Python, environment dependency inference, version constraint,
knowledge graph
ACM Reference Format:
Hongjie Ye, Wei Chen, Wensheng Dou, Guoquan Wu, and Jun Wei. 2022.
Knowledge-Based Environment Dependency Inference for Python Pro-
grams.In 44thInternationalConferenceonSoftwareEngineering(ICSE’22),
May 21–29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3510003.3510127
1 INTRODUCTION
Python programs depend on third-party packages (i.e., Python
libraries), the Python interpreter, and system libraries. Missing
andincompatibleenvironmentdependenciescanresultinprogram
build failures and runtime errors.
Developers need to infer environment dependencies for Python
programs due to the following reasons. First, many open-sourcePython programs (e.g., Python gists and Jupyter Notebooks in
GitHub) do not explicitly declare their dependencies or miss some
dependencies [ 23,38]. Second, Python libraries are usually fre-
quentlyupdated,maybecomedeprecated,orareremoveddueto
security issues [ 30]. Third, a program migrating from one envi-
ronmenttoanothermayfailduetooverlookingrequiredsystem
libraries, which are usually not explicitly documented.
Besidesthird-partypackages,Pythonprogramsalsodependon
specificsystemlibrariesandthePythoninterpreter.Inourempirical
12452022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Hongjie Ye, Wei Chen, Wensheng Dou, Guoquan Wu, and Jun Wei
study on 100 gists sampled from HG2.9k [ 24], we find that 34 gists
suffer from runtime errors due to incompatible Python interpreter
versions,and24gistsfailduetomissingsystemlibraries.Despite
theimportanceofsystemlibraryandPythoninterpreterdependen-
cies, we find that only half of our investigated programs declare
compatiblePythonversions,andonlyaquarterofprojectsdocu-
ment dependent system libraries. Therefore, an effective approach
isstillrequiredto“digandbuildthefullrequireddependencies [14].”
Some studies have tried to address Python program environ-
ment dependency issues. The prior work [ 23,24] infers third-party
packages and system libraries for single-file Python programs, but
they only recommend the latest package versions without concern-
ing version constraints. SnifferDog [37] infers dependent Python
libraries for Jupyter notebooks based on API usage analysis, butit neglects system libraries and the Python interpreter. Pipreqs
[6],apopularopen-sourcetool,onlyfocusesonthird-partypack-
ages and does not pay attention to system libraries and the Python
interpreter.
Thispaperproposesaknowledge-basedtechniquenamedPyEGo,
which can automatically infer dependencies at compatible versions
forPythonprograms.PyEGoconsidersdependenciesofthird-party
packages, the Python interpreter, and system libraries. Based on a
thoroughanalysisoftheknowledgerequiredforenvironmentde-
pendencyinferences,wefirstconstructthedependencyknowledge
graph PyKG, which can portray the three types of dependencies
andtheir relations.Then,facilitatedwith PyKG,PyEGoinfersen-
vironment dependencies for a Python program via static program
analysis and constraint solving. It extracts program features and
takesthemasinputstoqueryPyKGforthecandidateversionsof
possibledependencies.Thedependencycandidatesformaprogram-relateddependencysub-graphwiththeirinterrelations.PyEGofur-
therinfersthelatestcompatibledependencyversionswithinthe
sub-graph by solving constraints among the candidates. In essence,
PyEGo is an exploratory step towards automating dependency
inferences for Python program.
We evaluate PyEGo on HG2.9K [ 24], containing 2,891 single-
file Python programs, by resolving ImportErrors with inferred
environment dependencies. In addition, we evaluate PyEGo on 100
morecomplexPythonprojectsand4,836jupyternotebooks.Overall,
PyEGo achieves 46.14%, 62% and 60.90% accuracy, respectively,
which is 0.2x to 3.5x higher than the state-of-the-art approaches.
In summary, this work makes the following contributions.
•Weproposeadependencyknowledgegraphanditsconstruction
approach. PyKG can portray the relations among third-party
packages, the Python interpreter, and system libraries.
•We propose a knowledge-based environment dependency in-ference technique PyEGo, which regards constraints among a
programanditsdependenciesandcaninferthelatestcompatible
dependency versions of three dependency types, i.e., third-party
packages, the Python interpreter, and system libraries.
•The evaluations on HG2.9K, 100 open-source projects and 4,836
jupyternotebooksrevealthatPyEGoismoreeffectivethanstate-
of-the-art approaches.2 MOTIVATION
In this section, we perform an empirical study for investigatingthe prevalence of environment dependency issues. Then, we use
an example to analyze the challenges of environment dependency
inference for Python programs. Finally, we present an overview of
our approach addressing the challenges.
2.1 Empirical Study
Oursmall-scaleempiricalstudyconcentratesondependenciesis-
suesrelatingtothePythoninterpreterandsystemlibrariesbecause
the prior work [ 24,37] has confirmed that Python packages are in-
dispensabletoprogrambuildsandexecutions.Thisempiricalstudy
is dedicated to answering the following two research questions.
•RQ1: To what extent do open-source Python projects provide
documentedenvironmentdependencies?Whatkindsofdepen-
dencies are documented?
•RQ2: Besides Python packages, do the Python interpreter and
system libraries affect Python program builds and executions
seriously?
ToanswerRQ1,werandomlysample100popularPythonprojects
onGithubwithmorethan1000stars.Weidentifytheirdependency
declarationfilesandinvestigatewhatkindsofdependenciesthey
document.Wefindthat(1)79outof100projectsdeclarethird-party
packagedependencies,(2)51projectsdeclarecompatiblePython
interpreterversions,and(3)only27projectsdeclaresystemlibrary
dependencies.Inaddition, We categorize dependencydeclaration
files. Requirements.txt is the most popular declaration file (54
of100projects),buttheyonlyrecordthird-partypackagedepen-
dencies. Dockerfile ,Pipfiles , and conda YAML files can record
dependencies of the Python interpreter and system libraries, but
only 26 projects use declaration files of these types.
Findings: Most open-source Python projects document their
third-partypackagesdependencies.However,onlyhalfofthein-
vestigatedprojectsdeclaretheircompatiblePythonversions,and
evenworse,onlyaquarterofprojectsdeclaresystemlibrarydepen-
dencies. Moreover, although requirements.txt is most prevalent,
they do not document the dependencies of the Python interpreter
and system libraries.
ToanswerRQ2,werandomlysample100gistsfromHG2.9K[ 24].
Wemanuallyconstructruntimeenvironmentsforthesegistsand
investigate the encountered problems. Only 42 out of 100 gists can
executesuccessfullybysimplyinstallingthethird-partydependentpackages.Fortheremaining58gists,(1)34gistsencounterruntimeerrorsduetoincompatiblePythonversionsbecause19and15gists
are only compatible with Python2 and Python3, respectively. (2)24 gists fail to build or execute due to missing system libraries.In addition, we investigate the top 30 voted Python questions in
Stack Overflow. We find that (1) 11 of 30 questions are relevant to
incompatible Python interpreter versions, and (2) 6 of 30 questions
arerelevanttothird-partypackageinstallationfailurescausedby
missing some system libraries.
Findings: The Python interpreter and system libraries are criti-
cal dependencies of Python programs. Unfortunately, more than
half of the gists experience build failures and execution errors due
to incompatible Python versions or missing system libraries.
1246
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Knowledge-Based Environment Dependency Inference for Python Programs ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
Figure 1: An example code snippet and its dependencies.
Insummary,besidesthird-partypackages,thePythoninterpreter
and system libraries are also indispensable, but few techniques
concern them in practice.
2.2 Motivating Example
Figure1showsaPythoncodesnippetofaGitHubproject,anim-
plementation of SuperGlue network1. The code snippet belongs
todemo_superglue.py (superglue forshort),runningSuperPoint
and SuperGlue features matching an anchor image with live im-
ages[32].Table1lists superglue ’sfeasibledependencies,where
the expressions in brackets (e.g., /greaterorequalslant3.5) are version constraints.
Superglue’s dependencies include:
(1)Third-partypackage.Third-partypackagesarethebasicinstal-
lationunitsinsteadoftheircontainedmodules.Therefore, torch,
opencv-python , and matplotlib aredirect dependencies as they
containthedirectlyusedtop-levelmodules torch,cv2,matplotlib
(line3-5),andthesecond-levelmodule cm.Besides, numpy, pillow,
pyyamlaretransitivedependencies sincethedirectdependencies may
use them.
(2)Systemlibrary.Somethird-partypackagesarepartiallyim-
plemented in C, and the C code may depend on system libraries.
libopencv-contrib is a system-level dependency as the third-
party package opencv-python depends on it.
(3)ThePythoninterpreter.ThePythoninterpreterisnecessaryfor
providingaPythonenvironmentandstandardmodules. pathlib
andargparse (line 1-2) are standard modules installed with the
Python interpreter, and Pathis a second-level module in pathlib.
(4)Localmodule.A codesnippetmayuse othermodulesimple-
mented in a program itself, such as models(line 6-8) implemented
inanotherfile models.py .However,wedonotregardlocalmodules
as they are self-contained resources.
Besides,theimportedmodulesimplyversionconstraintsonsuch
dependencies, including:
1https://github.com/magicleap/SuperGluePretrainedNetwork(1)Pythonversionconstraint.ThecoderestrictsthePythoninter-
preterversionmustbe3.5orlaterasthestandardmodule pathlib
is introduced since Python 3.5.
(2)Third-partypackageversionconstraint. matplotlib 3.4.2 is
thelatestversion,anditrequiresthetransitivedependency pillow
/greaterorequalslant6.2.0.Moreover, matplotlib ,opencv-python andtorchdepend
onnumpysimultaneously, and the latest versions of the first two
packagesrestrict numpylaterthan1.16and1.19.3,respectively.Thus,
numpy /greaterorequalslant1.19.3 is a version constraint restricting numpycompatible
with all the other third-party packages using it.
Challenges .Thisexampleindicatesthatinferringdependencies
for a Python program has several difficulties.
(1) A Python package includes at least one module, and the
namesofthepackageandthemodulecanbedifferent,whichmakes
developershavetoknowtowhatpackagestheimportedmodules
belong when reusing open-source code.
(2) System libraries are necessary transitive dependencies used
bytheimportedmodules,butfewdocumentsrecordthedependent
relationsbetweenthird-partypackagesandsystemlibraries.The
priorworkfindsmissedsystemlibrariesbyiterativelyanalyzing
runtime error logs [24] with expensive costs.
(3) The differences in contained modules would restrict versions
ofadependentthird-partypackage.Therefore,additionalefforts
have to be taken to identify the compatible package versions.
(4)Theimportedstandardmodulesandleveragedsyntaxfeatures
implicitly restrict compatible Python interpreter versions, but it is
not easy to uncover such constraints in the target program code.
(5)Complexinterdependentrelationsanddependencyversion
constraintsamongaprogramanditsdependenciesmayresultin
versionconflicts[ 38].Therefore,adependencyatthelatestversion
maybeincompatible[ 30],andinconsequence,thelatestcompatible
versionofeachdependencyhastobefiguredout.Inotherwords,
weshouldfollowtheoptimizationprincipleof“usingdependencies
asnewaspossible ”whenmultiplecompatibleversionsexistbecause
installingthelatestversionsfollows pip’sworkingmechanism[ 15]
and may fix bugs and security vulnerabilities in prior versions [ 20].
1247
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Hongjie Ye, Wei Chen, Wensheng Dou, Guoquan Wu, and Jun Wei
Table 1: Environment dependencies of the example code
Dependent Resource Version
Python 3.9 (/greaterorequalslant3.5)
opencv-python 4.5.2.52
matplotlib 3.4.2
torch 1.8.1
numpy 1.20.3 ( /greaterorequalslant1.19.3)
pillow 8.2.0 ( /greaterorequalslant6.2.0)
libopencv-contrib3.2 3.2.0+dfsg-4ubuntu0.1
Pyyamlis not a necessary transitive dependency as thedirect
dependency torch 1.8.1 no longer uses it
Figure 2: Knowledge graph model
Limitations of the existing work . The state-of-the-art ap-
proaches,pipreqs[ 6],DockerizeMe[ 24]andSnifferDog[ 37]mainly
focusoninferringthird-partypackagedependencies.Weexecute
pipreqs and DockerizeMe to infer dependencies for superglue.
Without regarding the version constraint of the Python inter-
preter, DockerizeMe takes Python2.7 as the default interpreter and
fails with “ ImportError: No module named pathlib .” This is
because the standard module is introduced since Python 3.5. Al-
though we use Python 3.5 or later, DockerizeMe still fails with an-
other ImportError as itcannot identify thedependency between
opencv-python andlibopencv-contrib3.2.
PipreqsdirectlyusesthelocalPythonenvironmentandwould
alsofail withthe ImportError ifthe Pythonversion isolder than
3.5.Besides,pipreqspaysnoattentiontodependentsystemlibraries,
and hence it still fails even if we use a compatible Python version.
SnifferDog infers dependencies forJupyter notebooks. Notably,
wecannotsuccessfullyexecuteSnifferDogsinceitspublicreposi-
tory[11]doesnotofferthecriticalcomponentAPI-bank.Although
SnifferDog analyzes modules, functions, and classes in third-party
packages,itslimitationsare(1)notregardingPythonversioncon-
straint and dependent system libraries and (2) simply taking the
latest package versions containing used APIs as dependencies.
2.3 Our Approach Overview
As a result, much knowledge is required for dependency infer-
ences. (1) Syntax features and standard modules of each Python
interpreter version are required for identifying compatible Python
versions.(2)Modulesineachthird-partypackageversionshould
beknowntodeterminewhatpackageversionsarecompatible. (3)
DependenciesbetweenPythonpackagesandsystemlibrariesarerequiredforinstallingdependentsystemlibrariesproactively.(4)
Versionconstraintsamongthird-partypackagesandbetween the
Python interpreter and third-party packages are required to avoid
incompatibilities and dependency conflicts (DCs) [38].
Wearemotivatedtodesignaknowledge-basedandconstraint-
awaretechniquetoinferenvironmentdependenciesatthelatest
compatible versions. The technique comprises two main parts, i.e.,
a knowledge graph offering knowledge relevant to the three types
ofdependenciesandatoolinferringPythonprogramdependencies
by solving version constraints.
In the first part, we propose a dependency knowledge graph
model to portray the relations among third-party packages, the
Pythoninterpreter,systemlibraries,andotherrelatedentities.Then,
we identify multiple sources from which we acquire data and in-
formationrelatingtotherequiredknowledge.Finally,weextract
knowledge from the data with several methods and construct a
dependency knowledge graph PyKG.
In the second part, we design a technique PyEGo to infer depen-
dencies for Python programs. Given a program, PyEGo extracts its
syntaxandmodulefeaturesandgetstheprogram-relateddepen-
dencycandidatesfromPyKG.Afterthat,weproposedependency
constraintsaccordingtothedependencyinferencerequirements,
andPyEGoinfersfinaldependenciesfromthecandidatesbysolving
dependency constraints.
3 KNOWLEDGE GRAPH CONSTRUCTION
We structure the required knowledge as a dependency knowledge
graph whose model is illustrated in Figure 2.
Dependency Knowledge Graph is defined as G=<V,E>,
where(1) V={ni|i/greaterorequalslant0,∀ni∈{f,c,lt,ls,ms,mt}}isasetofver-
tices relevant to dependencies, meaning a vertex can be the python
interpreter (c), athird-party package (lt), asystem library (ls), a
third-partymodule (mt),astandardmodule (ms),andasyntaxfea-
ture(f). (2)E={ej|j/greaterorequalslant0,∀ej∈{dep,asso}is a set of edges of two
relationtypes,i.e., depend-on andassociated-with arerepresented
by symbols ‘ →’ and ‘↔’, respectively. Table 2 lists the symbols
used in this definition.
Ontheonehand, depend-on relationsdescribeinter-dependencies
among the three types of dependencies. In particular, a third-party
package can depend on other packages, the Python interpreter andsystemlibraries,andasystemlibrarymaydependonotherlibraries.
In addition, the dependent relations between such dependency ver-
sions also specify the version constraints among them.
On the other hand, associated-with relations describe features of
third-party packages and the Python interpreter. Thus, the knowl-
edge graph model characterizes a third-party package version withthethird-partymodulestheycontain.ItalsocharacterizesaspecificPythonversionwithitsstandardmodulesandthesupportedsyntax
features.
3.1 Data Source
Table3liststhesourcesfromwhichwedirectlyacquiredataand
information, where
•PyPI [8] is the world-class Python library repository hosting
300k+ third-party open-source packages, and from which we
crawl the most popular ones and their inter-dependent relations;
1248
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Knowledge-Based Environment Dependency Inference for Python Programs ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
Table 2: Symbols in dependency knowledge graph model
Symbol Description
cPython interpreter
ltThird-party package
lsSystem library
fLanguage syntax feature
msStandard module
mtThird-party module
→depend-on relationship
↔associated-with relationship
Table 3: Data sources of dependency knowledge
Source Acquired Data & Information
PyPI [8] Top 10,000 popular third-party pack-
ages at each version
Libraries.io [4] Popularity measured by SourceRanks of
third-party packages
APT [1] Information of system libraries
Python docs [9] Syntax features of Python versions
Python environ-
mentsPython versions and their standard
modules
•Libraries.io[ 4]provides SourceRanks thatmeasurethepopularity
of open-source Python libraries;
•APT [1] is the official system software repository of Debian
family operating systems provisioning system libraries;
•Pythonofficialwebsite[ 10]offersPythoninterpreterversions,
and from which we download and install Python at various ver-
sions.WeanalyzeinstalledPythonenvironmentsandextractthe
standard modules;
•OnlinePythondocuments[ 9]providenewfeatures,userguid-
ance, and other information on each Python version.
Notethatwesampledatainsteadofcrawlingalltomakeatrade-
off between the expensive cost of exhaustively acquiring data and
adequate verification and demonstration of our work. Table 3 also
lists what data and information we acquire from the data sources.
3.2 Knowledge Extraction
Weproposeseveralmethodsforextractingknowledge,particularly
syntaxfeatures,dependencyversionconstraintsofthird-partypack-
ages, and dependencies between third-party packages and system
libraries, from the obtained data.
3.2.1 Syntax feature extraction and representation. Syntaxfea-
turessupportedbyeachPythoninterpreterversionarescatteredin
onlinedocumentsandusuallydescribedinnaturallanguage,and
hence how to extract and present such knowledge is concerned.
Wenoticethatthe“what’snew ”documentofeachPythonversion
explains new features compared with the previous version, such as
“What’s New In Python 3.9 ”[12]. Therefore, we extract context-free
syntax features from the “New Features ” section in each feature
document because such features can be directly recognized in atarget program withoutneeding to analyze program contextsand
other factors.For example, “positional-only parameters ”(PEP 570)
[27] is a context-free syntax feature can be recognized when a
symbol “/” appears like a parameter in a function definition based
on the static analysis. Conversely, “Dictionary Merge & Update
Operators ”(PEP 584)[33]isnotasuchfeatureasthe context(i.e.,
operandtypes)mustbeconcerned.Besides,otherfeatures,like“NewParser”(
PEP 617)[22],irrelevanttosourcecodearealsodiscarded.
In this way, we systematically investigate feature documents of
sixPythonversionsandrecognize26context-freesyntaxfeatures
(syntax features for short hereafter). c(v)↔{f1,f2,···}denotes
the syntax features supported by the Python interpreter at version
v(or a version range).
Furthermore,toautomatesyntaxfeaturerecognitionforatarget
Python program, wemanually transform19 outof the26 extracted
syntaxfeaturesintoregularexpressions.Forexample,theknowl-
edgeofthefeature“positional-onlyparameters ”introducedsince
Python 3.8 is represented as:
c(/greaterorequalslant3.8)↔“def\S*\(.*, ?/.*\)”
Notably, we do not present all extracted syntax features due to
space limitations, and they are available in our released knowledge
graph.
3.2.2 Version constraint extraction and module identification.
A third-party package’s metadata usually provides information
on contained third-party modules, compatible Python versions,
and version constraints on its dep endent packages. Ho wever, such
information is scatteredin several metadata files, and evenworse,
some information is incomplete or absent.
Forathird-partypackageversion lt(v),weextractitscompatible
Python versions and dependent third-Party packages by analyzing
its metadata in the files METADATA and requirements.txt . The
obtainedinformationisrepresentedas lt(v)→c(vc)andlt(v)→
{lt1(v1),lt2(v2),···}, wherec(vc)is compatible Python versions
and{lt1(v1),lt2(v2),···}is a set of dependent package versions.
Thedifferencesincontainedthird-partymodules(particularly
lower-levelmodules)areimportantfordistinguishingversionsof
a package. However, the file top_level.txt in a package only
records its top-level modules. Therefore, we traverse each pack-
agetop-downtogetitsmodulesateachlevel.Theinformationis
represented as lt(v)↔{mt1,mt2,···}.
3.2.3 Dependency inference between third-party packages and
system libraries. As aforementioned, dependencies between a pack-
age and its system libraries are absent. We mine such dependency
knowledge with two methods, i.e., (a) association mining-based de-
pendency inference and (b) similarity-based dependency inference.
Since the former is similar to that proposed in prior work [ 24], we
only elaborate on the latter below.
We observe that some pip-installable third-party packages have
similarapt-installable distributions with slight differences in their
names and structures. For example, python-matplotlib ,a napt-
installable package, is similar to the package matplotlib onPyPI
as their names are similar and they both contain the same top-level modules
matplotlib ,pylab, and mpl_toolkits . Moreover,
if anapt-installable package depends on a set of system libraries
{ls1,ls2,···}, the similar pip-installable one is likely depending on
1249
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Hongjie Ye, Wei Chen, Wensheng Dou, Guoquan Wu, and Jun Wei
them,too.Thus,wecangetdependentsystemlibrariesofan apt-
installable packagewiththecommand“ apt-cache depends ”.And
then, we search for the similar pip-installable package ( lt)o ft h e
apt-installable one (l/prime
t) by measuring the comprehensive similar-
ity(Equation1)betweentheirnames(Equation2)andcontained
top-level modules (Equation 3). ltandl/prime
tare similar only if their
similarity exceeds a threshold set with 0.8 in practice. In Equa-
tion2,LCStr()returnsthelongestcommonsubstringoftheirnames
andMax()returns the max length of their names. In Equation 3,
Module()returns the top-level module set of a package.
S(lt,l/prime
t)=SN(lt,l/prime
t)+SM(lt,l/prime
t)
2(1)
SN(lt,l/prime
t)=|LCStr(lt,l/prime
t)|
Max(lt,l/prime
t)(2)
SM(lt,l/prime
t)=|Module(lt)∩Module(l/prime
t)|
|Module(lt)∪Module(l/prime
t)|(3)
The inferred dependency knowledge is represented as lt→
{ls1,ls2,···}. For instance,
opencv-python→ {libopencv-contrib3.2}
means“the pip-installable package opencv-python dependsonthe
system library libopencv-contrib3.2.”
3.3 KnowledgeGraphConstructionandUpdate
We organize extracted knowledge as a knowledge graph named
PyKG, which is stored in Neo4j[36], a popular graph database. At
the time of writing, PyKG contains about 256 thousand nodes and
1.9 million relations.
PyKGisextensibleandevolvable.Ontheonehand,PyKGcan
update periodically as most data acquisition and knowledge extrac-
tion are automated. For each existed package, PyKG re-accesses
PyPIandcomparesthelocalandtheonlineversions.Ifthelatest
versionisnotfetched,PyKGautomaticallycrawlsit,analyzesits
metadata, extracts corresponding knowledge, and makes a syn-
chronization. In practice, PyKG synchronizes every threemonths,
and each synchronization takes about 1.5 days. On the other hand,
PyKGcanincrementinasimilarwayforcrawlingnewpackages
and extracting relevant knowledge.
4 ENVIRONMENT DEPENDENCY INFERENCE
Figure3depictsPyEGo’sworkflow.Thefirststepextractsimported
modules and used syntax features of a target program via static
analysis. Next, PyEGo gets dependency candidates by querying
PyKG with extracted modules and syntax features. Finally, PyEGo
outputs the inferred dependencies at the latest compatible versions
based on constraint solving.
4.1 Program Feature Extraction
Foratargetprogram P={pm|m/greaterorequalslant1}comprisingasetof .pyfiles,
PyEGo extracts P’s features, i.e., used syntax features, imported
third-party modules and standard modules. For each python file
pi(1/lessorequalslanti/lessorequalslantm)inP,
(1)PyEGo matches the code against each regular expression inPyKG that represents a syntax feature and groups identified
syntax features in a set S(pi).(2)PyEGoparses piintoanabstractsyntaxtree(AST)andextracts
itsusedmodulesfrom importstatements.Next,inassistance
with PyKG, PyEGo filters out local modules and groups the
remainingonesinastandardmoduleset( Ms(pi))andathird-
party module set ( Mt(pi)), respectively.
Inthisway,PyEGoiterativelyanalyzesall .pyfilesandintegrates
theirfeaturesas F(P)={S,Mt,Ms},whereS,MtandMsdenote
P’ssyntaxfeatureset,third-partymoduleset,andstandardmodule
set, respectively.
For example, superglue’s (Sec. 2.2) feature set includes
•S=ϕ, meaning no special syntax feature is identified,
•Ms={arдparse ,pathlib,pathlib.Path}, and
•Mt={cv2,torch,matplotlib ,matplotlib .cm}.
4.2 Dependency Candidate Identification
PyEGo identifies P’s dependency candidates by querying PyKG
withF(P).
Python interpretercandidates . PyKG returns all Python ver-
sionsnotonlysupportingallsyntaxfeaturesin F(P).Sbutalsocon-
tainingallstandardmodulesin F(P).Msasaninterpretercandidate
setC(P)={cv1,cv2,···}.Thus,C(P)impliesPythoninterpreter
version constraint of P.
For example, the usage of standard module pathlib makes
superglue compatible with Python 3.5 or later as the module is
introducedsincePython3.5.Therefore,itscandidatePythonver-
sion set is C(superдlue )={cv|3.5/lessorequalslantv/lessorequalslant3.9}(the latest Python
version is 3.9).
Third-party package candidates . For each third-party mod-
ulemtinF(P).Mt,PyKGreturnsallthird-partypackageversions
containingthemodule,i.e., Lt(mt).Inthisway,allpossiblethird-
party packages directly used in Pare grouped in Lt(P). On the
otherhand,PyEGoconstructs L/prime
t(P)thatcomprisesalltransitive
dependent third-party packages of P.
Thisstepconcernsthefollowingcaseandheuristicallyfiltersthe
initialthird-partypackagecandidates.Foramodulesimultaneouslycontainedinseveraldifferentthird-partypackages,weheuristically
select the most popular package instead of all for the followingreasons: (1) packages containing the same modules may conflict
withoneanother[ 5];and(2)takingallthepackagesasdependency
candidateswouldincreasethetimecostofthesubsequentdepen-
dencyinference.Forexample, cv2isamodulein opencv-python ,
opencv-python-headless , and opencv-contrib-python . Thus,
we select opencv-python as the candidate due to its popularity
(withSourceRank 18 in Libraries.io [4]).
System library candidates .PyKG returnssystem librarieson
which any element in Lt(P)orL/prime
t(P)depends. PyEGo takes all
returned system libraries as P’s dependency candidates of system
libraries, i.e., Ls(P).
Targetprogramcentricdependencygraph .P’sdependency
candidates form a subgraph of PyKG, G/prime=<V/prime,E/prime>, where the
vertices in V/primeare dependency versions in C(P)∪Lt(P)∪L/prime
t(P)∪
Ls(P);E/primecontains dependent relations among them. Without loss
of generality, we denote a dependency nat version vasnv, whose
dependency candidates in G/primeisdep(nv)={α,β,···}.
1250
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Knowledge-Based Environment Dependency Inference for Python Programs ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
Figure 3: PyEGo’s workflow of inferring environment dependencies for a Python program.
Figure 4: A part of Superglue’s dependency graph.
Figure4showsapartof superglue ’sdependencygraphformed
byitsdependencycandidates.Forsimplicity,eachvertexisanno-
tated with a symbol plus a number representing a specific version.
For example, the dependencies of vertex MA34(i.e., matplotlib
3.4.2) are represented as dep(MA34)={PY39,PL82,NP20}.
4.3 Dependency Inference
As aforementioned, a package’s latest version is preferred, but
it is not always feasible due to DCs [ 38] and version constraint
violations. Therefore, several requirements in inferring P’s depen-
dencies from the candidate set are summarized, i.e., the inferred
dependencies must be compatible with one another, necessary, and
as new as possible. To this end, PyEGo infers dependencies by
solving dependency constraints with an optimization objective.
Dependency constraints . Suppose ˆG=<ˆV,ˆE>,ˆG⊆G/prime,i s
the graph formed by P’s final inferred dependencies. It should
satisfy the following constraints.
(1)Existenceconstraint restricts ˆGmustcontainthePythonin-
terpreter and all P’s directly dependent third-party packages, i.e.,
•∀nv1
i∈C(P)∪Lt(P),∃nv2
j∈ˆG.ˆV,ni≡nj.For example, in Figure 4, Python,opencv-python ,matplotlib ,
andtorchare dependencies must be installed. In contrast, pyyaml
is not necessary if torch 1.8.1 (TH18) is chosen.
(2)Uniqueconstraint restricts ˆGtocontainonlyoneversionof
each dependency n, i.e.,
•∀nv1
i,nv2
j∈ˆG.ˆV,ni/nequalnj.
For example, in Figure 4, one can choose either torch 1.8.1 or
torch 0.1.2 (TH01), but cannot choose both at the same time.
(3)Version constraint restricts each dependency nvinˆGmust be
compatible with all the other resources depending on it, i.e.,
•∀nv1
i∈ˆG.ˆV,∀nv2
j∈dep(nv1
i),∃nv3
k∈ˆG.ˆV,nj≡nk∧nv3
k∈
dep(nv1
i).
For example, in Figure 4, one cannot choose matplotlib 3.4.2
andPython 3.5 (PY35)atthesametime,since matplotlib 3.4.2
is not compatible with Python 3.5.
Optimization objective . We harmonize the latter two require-
ments above into an optimization objective. PyEGo sorts all ver-
sions of each dependency ninG/primefrom the oldest to the latest as
a vectorVer(n)=<nv1,nv2,···,nv0>. Notably, nv0is avirtual
versiondenotingnoversionsof nareselected.Therefore,theop-
timizationobjectiveisrepresentedasEquation4,where index(n)
denotes the index of the selected version in Ver(n). For example,
index(n)=0 if the oldest version in Ver(n)is selected. Nis the set
of all dependency candidates (not their versions) of P.
O=maxΣ∀n∈Nindex(n) (4)
To maximize O, PyEGo first tries to select nv0(i.e., not install
any version of n), and ifnis necessary or a constraint violation
occurs, it replaces nv0with the latest version of nsatisfying all
its relevant version constraints. To this end, PyEGo exploits thefamous SMT solver Z3 [
13] to obtain the optimized solution, i.e.,
the final inferred environment dependencies, such as the inference
result of the example listed in Table 1.
1251
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Hongjie Ye, Wei Chen, Wensheng Dou, Guoquan Wu, and Jun Wei
5 EVALUATION
Toevaluatetheeffectivenessandefficiencyof PyEGo,weanswer
the follow research questions (RQs).
RQ3:HoweffectiveisPyEGoininferringdependenciesforPython
programs?
RQ4:DoesPyEGooutperform state-of-the-art approaches?How
better is PyEGo than others?
RQ5:HowefficientisPyEGoininferringdependenciesforPython
programs?
ForRQ3,PyEGoinfersenvironmentdependenciesforPython
programs in the dataset HG2.9K [ 24], 100 complex Python projects
collectedfromGithub,and4,836jupyternotebooks.Weevaluate
dependency inference results in terms of accuracy andaverage
inferred dependencies.
ForRQ4,weexecutepipreqs[ 6]andDockerizeMe[ 24]withthe
datasetsHG2.9K,the100collectedprojectsandthe4,836jupyter
notebooksandcomparetheirresultswiththoseof PyEGo.Notably,
SnifferDog[ 37]isanotherrelatedwork,butwecannotreplicateits
experimentandquantitativelycompareitwithPyEGoasitisnot
executable due to the lack of critical component API-bank.
ForRQ5, we compare PyEGo with pipreqs and DockerizeMe in
terms ofaverage execution time.
5.1 Methodology
5.1.1 Datasets. Threedatasetsareusedinevaluations,i.e.,HG2.9K
[24],100open-sourcePythonprojects,and4,836jupyternotebooks.
HG2.9K contains 2,891 Python gists, i.e., single-file Python pro-
gramsfromGitHubgistservice,experiencing importerrorshard
to fix in the prior work [23, 24].
Inaddition,followingthecriterialistedbelow,wecreateadataset
SDcontaining100real-worldopen-sourcePythonprojectscollected
from GitHub.
•executable,i.e.,runningwithouterrorsonceallthedependencies
are configured;
•well documented, i.e., document their dependencies explicitly;
•popular, i.e., having at least hundreds of stars;
•diverse, i.e., varying in forms and application types.
The projects in SD arethird-partypackages (47), applications (49)
and tutorials (4), belonging to machine/deep learning (30), Internet
(29), development (25), database (4), security (13), computer vision
(14) and natural language processing (6) (a project can belong to
multiple types). On average, these projects contain 58 Python files
(with .py extensions), 10,821 lines of code (LOC), and 270 import
statements.
Besides,wecreateadatasetJPDcontaining4,836jupyternote-
books. SnifferDog [ 37] provides a list of 6,004 notebooks in its
repositories, and we try to download the notebooks and convert
them into Python files. 1,168 notebooks fail in download or con-
version,andwetaketherest4,836notebooksasthefinaldataset.
Notably, we comment out magic commands [ 2] contained in the
notebooks as they cannot be executed by CPython interpreter.
5.1.2 Evaluation metrics. Equation 5 measures the effectiveness
of dependency inference, where Inf(proдrams )is the number of
programs whose environment dependencies are successfully in-
ferredwithinadataset.Followingthecriterioninthepriorwork[24], an inference is considered successful only if the program
does not encounter ImportErrors anymore. In addition, since the
projects in SD record dependencies originally, we further compare
their inference results with the documented dependencies to check
whethertheinferredenvironmentdependenciesaresemantically
correct.
accuracy =Inf(proдrams )
totalproдrams(5)
5.1.3 Experimental environment. Ourexperimentsareperformed
onacomputerrunning Ubuntu 18.04 LTS with8-core3.50GHz
CPU and 32 GB RAM.
5.2 Answer to RQ3
Experimental result . Table 4 shows the dependency inference
results of PyEGo for programs in the three datasets.
(1)PyEGosuccessfullyinfersdependenciesfor1,334outof2,891
(46.14%)gistsinHG2.9K,1.41third-partypackagesand2.31system
librariespergistonaverage.Amongthe1,334gists,PyEGoinfers
Python 3.9 for 765 gists, Python 2.7 for 528 gists, and Python 3.8
for 41 gists, respectively.
(2) PyEGo successfully infers dependencies for 62 out of 100
(62%) projects in SD, 8.91 dependencies (4.01 third-party packages
and 4.90 system libraries) per project on average. The accuracy on
SDissignificantlyhigherthanthatonHG2.9KsinceeachprojectinSDiscompleteandexecutableoriginally.Therefore,theywouldnotencounter
ImportErrors causedbymissinglocalmodules.Among
the 62 projects, PyEGo infers Python 3.9 for 51 projects, Python2.7
for 6 projects, and other Python versions for 5 projects. We inspect
theinferenceresults ofthe62projectsand findthat4resultscon-
tainlater dependencyversions,butthey donotchange thetarget
projects’executionsemanticsastheusedAPIsintheimportedthird-
party package versions do not change. For example, jd-assistant
[3] declares it depends on pycryptodome 3.6.6, while PyEGo in-
fers version 3.10.1. We inspect the change log of pycryptodome
[7] and confirm the used APIs, i.e., Crypto.PublicKey.RSA and
Crypto.Cipher.PKCS1_v1_5 , do not change since 3.6.1. Thus, we
consider the inferred result is correct.
(3)PyEGosuccessfullyinfersdependenciesfor2,945outof4,836
(60.90%)notebooksinJPD,8.51dependencies(3.30third-partypack-
ages and 5.21 system libraries) per project on average. Among
the 2,945 notebooks, PyEGo infers Python3.9 for 2,193 notebooks,
Python2.7 for 479 gists and other Python versions for 273 note-
books.
Failurerootcausesanalysis .Weinspectprogramsfailingwith
incorrectdependencyinferenceresultsandanalyzetherootcauses.
Overall, the root causes are classified into several categories.
(1)Missingdependencies.First,someprogramsfailduetomissing
third-partypackages.Takethecodesnippetbelowasanexample,
PyEGoinfers numpy 1.16.1 andscipy 1.2.3 ,butfailstofigure
outwhatpackagecontainsthemodule sparsesvd astheknowledge
is absent.
1 import scipy.sparse
2 import numpy
3 import sparsesvd
Second, some programs fail to install third-party packages be-
cause of missing required system libraries. For example, installing
1252
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Knowledge-Based Environment Dependency Inference for Python Programs ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
Table 4: Dependency inference results of PyEGo and two state-of-the-art approaches
Tool ACC ADP ATP AT (sec.)
HG2.9kPyEGo 46.14%(1334/2891) 3.68 1.39 0.69
pipreqs 10.27%(297/2891) 1.521.52 2.18
DockerizeMe 30.72%(888/2891) 7.32 5.99 13.45
SDPyEGo 62.00%(62/100) 8.98 4.01 2.52
pipreqs 45.00%(45/100) 6.256.25 2.43
DockerizeMe 23.00%(23/100) 13.18 10.41 10.37
JPDPyEGo 60.90%(2,945/4,836) 8.51 3.30 2.86
pipreqs 52.92%(2,559/4,836) 3.413.41 3.11
DockerizeMe 46.20%(2,234/4,836) 8.48 6.86 7.97
ACC is the dependency inference accuracy; ADP is the average inferred dependent packages, including system libraries and third-party
packages; ATP is the average inferred dependent third-party packages; AT is the average execution time.
dbus-python without the system library libdbus-1-dev leads to
“error: Package requirements(dubs-1 >= 1.8) were not met .”
PyEGofailstofigureoutonwhatsystemlibrariesthethird-party
package depends.
Third, some programs fail due to missing extradependencies.
Some third-party packages are installed optionally ( PEP 508)[19],
i.e.,theywouldnotbeautomaticallyinstalledunlessaskingforthem
explicitly. For example, xlrdis anextradependency of pandas,
which would not be automatically installed with ” pip install
pandas”.Executingfunction pandas.read_excel() without xlrd,
the program would encounter an import error, i.e., “ ImportError:
Missing optional dependency ‘xlrd’...”.
(2)Incompatibledependencyversions.First,someprogramsfail
due to incompatible dependency versions induced by incorrect
version constraints documented in third-party packages’ metadata.
Forexample, pyarrow 2.0.0 specifiesitiscompatiblewith Python
>=3.5. However, it is incompatible with Python 3.9 and would
fail with “Installing build dependencies ... error.”.
Second, some programs fail due to incompatible classes or func-
tions in third-party package versions. For example, the function
numpy.rank is removedsince numpy 1.18 . Unfortunately, PyEGo
cannotidentifysuchanincompatiblechangeasitfocusesonfea-
tures at module granularity.
(3)Incompatible operating systems. Some programs fail due to
their dependent third-party packages are OS-specific. For example,
pyobjc-core isonlycompatiblewith OS X,andinstallingitinLinux
would fail with “error: PyObjC requires macOS to build.”
(4)Conditional dependency. A program conditionally declares
its dependencies on standard modules specific to Python2 and
Python3 intry-catch orif-else code blocks for being compati-
ble with both Python versions. In the code snippet below, cPickle
andpicklearestandardmodulesspecificto Python2andPython3,
respectively. PyEGo does not consider the importstatements’ con-
text and cannot find a Python version containing both modules.
1try:
2 import cPickle as pickle
3except ImportError:
4 import pickle5.3 Answer to RQ4
Table4listsalldependencyinferenceresultsofthethreeapproaches
(including PyEGo). Since pipreqs and DockerizeMe do not con-
sider Python versions, we config them with Python 2.7 for HG2.9k,
following the original experimental setting of DockerizeMe, and
config them with Python 3.9, the version most projects compat-ible with, for SD and JPD. Notably, our replicated evaluation onDockerizeMe with HG2.9K is slightly different from the original,
i.e., itsuccessfully infersdependencies for888 insteadof 892gists.
ThereasonisthatsomepackagesthatDockerizeMerecordshave
beenremovedfrom PyPIandcannotbe downloadedandinstalled
anymore. Overall, PyEGo reaches the highest accuracy on both
datasets. In particular,
•PyEGo’saccuracyisabout3.5x,0.4xand0.2xhigherthanthatof
pipreqs on the datasets HG2.9K, SD and JPD, respectively;
•PyEGo’saccuracyisabout0.5x,1.7xand0.3xhigherthanthatof
DockerizeMe on the datasets HG2.9K, SD and JPD, respectively.
In comparison,•
DockerizeMe reaches the lowest accuracy on SD since it does
notconsiderthehierarchicalstructureofaPythonprojectand
only analyzes .py files at the top-level.
•Pipreqs reaches the lowest accuracy on HG2.9k as it does not
concern system libraries and Python version constraints.
Thereasons of PyEGo outperforming theother approachesare
summarized as follows.
Finer-grained module analysis . Pipreqs and DockerizeMe
only focus on top-level modules, while PyEGo analyzes lower-
levelmodules inaddition.In comparison,lower-levelmodules are
usually distinctive features for third-party package versions and
Pythonversions.Inthecodesnippetbelow, urllibexistsinboth
Python2 and 3, but the second-level module urllib.parse is only
in Python3. On the other hand, DockerizeMe and pipreqs infer the
codesnippetdependson google-api-python-client throughthe
top-level module oauth2client . However, only versions between
1.0and1.2ofthepackagecontain oauth2client.appengine .Con-
sequently, DockerizeMe and pipreqs recommend the incompatible
latest version 2.15, and conversely, PyEGo infers the package at
version 1.2 and solves the ImportError.
1253
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Hongjie Ye, Wei Chen, Wensheng Dou, Guoquan Wu, and Jun Wei
Table 5: Pairwise comparison results
# programs ADP ATP AT (sec.)
HG2.9K-PyEGo 246 2.76 1.37 0.46
HG2.9K-pipreqs 246 1.431.43 1.11
HG2.9K-PyEGo 734 4.23 1.63 0.49
HG2.9K-DockerizeMe 734 3.082.94 5.10
SD-PyEGo 38 6.242.92 0.55
SD-pipreqs 38 3.003.00 1.21
SD-PyEGo 19 7.843.26 0.53
SD-DockerizeMe 19 7.746.95 8.78
JPD-PyEGo 2,287 6.85 2.85 2.91
JPD-pipreqs 2,287 2.862.86 2.93
JPD-PyEGo 2,035 6.32 2.72 2.80
JPD-DockerizeMe 2,035 5.264.82 6.18
The top two sub-datasets are gists in HG2.9K whose dependen-
cies are inferred byboth PyEGo and pipreqs, and both PyEGo
and DockerizeMe.The middle two sub-datasetsare projects in
SDwhosedependenciesareinferredbybothPyEGoandpipreqs,
andbothPyEGoandDockerizeMe.Thebottomtwosub-datasets
are projects in JPD whose dependencies are inferred by both
PyEGo and pipreqs, and both PyEGo and DockerizeMe.
1 import urllib.parse
2 from oauth2client import appengine
Discoveringmoredependentsystemlibraries .Pipreqsdoes
notconsidersystemlibraries,andDockerizeMeonlydiscoverssuch
dependencies based on association mining. In comparison, PyEGo
discoversmoredependencieswithanadditionalsimilarity-based
approach (Sec.3.2). For instance, PyEGo discovers avdepending
onlibavcodec-dev ,and pyldapdependingon libldap2-dev and
libsasl2-dev . Such knowledge helps PyEGo achieve high accu-
racy.
Pythonversioncompatibilityawareness .DockerizeMetakes
Python2.7asthedefaultinterpreter,andpipreqsonlyusesthelocal
Python versions directly . However, not all programs are compat-
ible with pre-installed Python versions. PyEGo analyzes syntax
features and standard modules used in programs, and thus PyEGo
recommends a compatible Python version for each target program.
Dependency conflicts prevention . Both pipreqs and Docker-
izeMe simply take the latest package versions without concern-
ingdependency conflicts. PyEGoavoidspotential DCsbysolving
constraints among dependencies. For example, in the followingcode snippet, the latest version of
torchmeta andtorchvision
are1.7.0and0.10.0,respectively.However, torchmeta 1.7.0 de-
pendson torchvision<0.10.0 .Thus,installingthelatestversions
of both packages would result in a DC. Conversely, PyEGo installs
torchmeta 1.7.0 andtorchvision 0.9.0 and avoids the DC.
1 from torchvision import models
2 from torchmeta.utils.data import BatchMetaDataLoaderOnaverage,PyEGoinfersthefewestthird-partypackages(ATP)
butalittlemoresystemlibrariesthanpipreqsandDockerizeMe.On
the one hand, although pipreqs does not consider system libraries,
someprogramshappenedtodependonsystemlibrariesinstalledin
default.Ontheotherhand,someobtaineddependenciesbetween
systemlibrariesandthird-partypackagesarefalsepositives,result-
ing in unnecessary system libraries. However, a little more false
positives is an acceptable price to pay for the higher accuracy.
Tomakeamorethoroughevaluation,weperformasetofpair-
wisecomparisons.Thatis,wecomparePyEGowitheveryotherap-
proachbasedontheprogramswhosedependenciesaresuccessfully
inferred by both. For example, we compare PyEGo with pipreqsbased on the gists whose dependencies are successfully inferred
by both of them. Table 5 lists the pairwise comparison results. We
noticethatPyEGocaninferdependenciesformostprogramswhosedependenciesaresuccessfullyinferredbypipreqsandDockerizeMe.
5.4 Answer to RQ5
WecomparePyEGowithDockerizeMeandpipreqsintermsoftheir
average execution time. As Table 4 shows, PyEGo runs 2.2x and
18.5xfasterthanpipreqsandDockerizeMeonHG2.9K,aswellas
0.1x and 1.8x faster than pipreqs and DockerizeMe on JPD, respec-
tively.PyEGoruns3.1xfasterthanDockerizeMe,butalmostequallytopipreqsonSD.However,unlikepipreqs,whichimmediatelyexitsonceencounteringa
SyntaxError (causedbyincompatiblePython
versions)duringprogramanalysis,PyEGotriestheotherPython
version until it finds a compatible one. PyEGo runs faster on all
sub-datasets in the pairwise comparison since pipreqs would no
longer encounter any SyntaxErrors and exit immediately.
PyEGo avoids online queries by storing the obtained knowledge
in PyKG locally, and thus, its performance bottleneck becomes
querying knowledge graph PyKG. Hence, we partially cache PyKG
(10% in practice) to speed up PyEGo. T ake the dataset SD as an
example, PyEGo takes 2.52s in a dependency inference on average
withcache,1.79xfasterthanwithoutcache.Incomparison,pipreqs
only locally records modules in third-party packages and has toquery PyPI for the latest version, increasing its time overhead.On the other hand, DockerizeMe runs slowly because it directly
accesses its knowledge base step by step without leveraging cache.
6 DISCUSSION
We discuss some future work to deal with limitations.
More comprehensive knowledge acquirement. PyEGo is
limited in the equipped domain knowledge, e.g., PyKG stores only
a small part (e.g., 1/30 third-party packages in PyPI) of domainknowledge. Thus, PyEGo does not know to what packages the
unrecognized imported modules belong. Therefore, we will contin-
uously and incrementally enrich PyKG by acquiring more domain
knowledge.
OS-specificdependencyidentification. Ourfailurerootcause
analysis found that some third-party packages are compatible with
specificOSes,e.g.,macOS.Currently,PyEGoconcentratesonde-
pendencies in Linux,and we will enrich PyKG with OS-level com-patibility information in the future.
Finer-grained feature utilization.
Functionsandclassesare
alsoimportantfordistinguishingversionsofthePythoninterpreter
1254
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. Knowledge-Based Environment Dependency Inference for Python Programs ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA
andpackages,especiallyinsituationswheretwoversionsofapack-
age only differ in implementation details. However, PyEGo only
concerns module-level features and cannot recognize the function-
and class-level differences. We will extract and utilize such finer-
grainedfeaturesinstandardandthird-partymodulesforimproving
dependency inference accuracy.
Conditional dependency identification. PyEGo fails to in-
ferconditionaldependencies fortargetprograms.Wewillexplore
context-aware program analysis to identify such dependencies.
7 THREATS TO VALIDITY
Internal validity threats come from the acquired knowledge, partic-
ularly the dependencies between third-party packages and system
libraries.Thesimilarity-andassociation-baseddependencymining
mayintroducefalsepositives(Sec.3.2).Wemitigatethethreatby
(1) leveraging a comprehensive metric for increasing the accuracy
of similarity-based mining and (2) setting the threshold with a
moderately high value to filter out more false positives.
Theexternalvalidityconcernsthegeneralityofourwork.We
evaluate PyEGo by resolving ImportErrors for 2,891 single-file
Python programs. In particular, each program in HG2.9K is a “hard
gist” whose ImportErrors cannot be resolved by the naive algo-
rithm [24]. The experimental result reveals that PyEGo is more
effectivethanstate-of-the-artapproaches.Ontheotherhand,we
evaluatePyEGoon100real-worldprojectsselectedfromGitHub
basedonseveralcriteriaand4,836jupyternotebooks.Theseprojects
aremorecomplexwithmultiplecodefiles.Theexperimentalresult
shows that PyEGo is scalable to infer dependencies for complex
Pythonprojectsofvarioustypes,andmostinferreddependencies
do not change execution semantics.
Construct validity refers to the suitability of our evaluation
measures.Likethepriorstudy[ 24],wethinkadependencyinfer-
ence is successful only if the target program no longer experiences
ImportErrors .Weevaluatethedependencyinferenceresultofa
Pythonprojectmorestrictly.AdependencyinferenceofacompletePythonprojectissuccessfuliftheprojectcanexecutecorrectlyandtheinferenceisconsistentwithitsoriginallydeclareddependencies.
8 RELATED WORK
Dependency inference . The most relevant work is DockerizeMe
[24], SnifferDog [ 37], and pipreqs [ 6]. DockerizeMe infers third-
partypackageandsystemlibrarydependenciesusingacombination
of static analysis, dynamic analysis, and association rule mining.
Pipreqs,apopularopen-sourcetool,generatesa requirements.txt
filefor aPython programbased on importstatementsanalysis. It
resolvestheinconsistenciesbetweenpackagenamesandmodule
names based on a pre-constructed dictionary and queries PyPI [ 8]
onthefly.SnifferDog[ 37]analyzesJupyternotebookstodetermine
candidates for required packages and versions based on a database
of APIs. PyEGo is more effective since it (1) concerns more depen-
dencies,(2)considersversionconstraintsamongdependencies,and
(3) is configured with rich and detailed dependency knowledge.
Dependency conflict management . WatchMan [ 38] detects
DCsinthePyPIecosystem.Riddle[ 40]generatesteststocollect
crashingstacktracestofacilitateDCissuediagnosisofJavaprojectsbased on the empirical study findings [ 39]. Pradel et al. [ 31]p r o -
posed a detection strategy for DCs between JavaScript libraries.LibHarmo [
26] detects library version inconsistencies for Java
Maven projects and interactively suggests a harmonized version
withtheleastharmonizationefforts.Sensor[ 41]synthesizestest
casestotriggerinconsistentbehaviorsoftheAPIswiththesame
signatures in conflicting Java library versions.
Breakingchangedetection .PyDFix[ 30]detectsandfixesun-
reproducibility in Python builds caused by breaking changes of
dependencies.V2[ 25]detectsbreakingchangesbasedonPython
program crash information. It fixes crashes by repeatedly building
environmentsandrunningprogramswithinferreddependencies
in atrial-and-error manner, inducing intolerable time overhead.
Mezzettietal.[ 28]presentedatechnique,typeregressiontesting,to
detectbreakingchangesinNode.jslibraries.Throughcross-project
testing and analysis, DeBBI [ 17] detects backward behavioral in-
compatibilities between Java software libraries and client software
projects.Mujahidetal.[ 29]leveragedautomatedtestsuitesofother
projectsdependinguponthesamedependenciestotestnewlyre-
leasednpmpackage versions.
Pythonecosystemstudy .Valievetal.[ 34]performedamixed-
methods study on ecosystem-level factors affecting the sustain-
abilityofopen-sourcePythonprojects.Bommaritoetal.[ 16]and
Chen et al. [ 18] conducted empirical studies on PyPI and language
features, respectively. Vu et al. [ 35] found that PyPI is an attractive
targetforattackerstotrickdevelopersintousingmaliciouspack-
ages.Theystudiedtheattacksandproposedanapproachtoidentify
combosquatting and typosquatting [21] packages automatically.
9 CONCLUSION
Configuring a Python program execution environment is non-trivial due to complex dependencies. This work proposes an au-
tomated dependency inference technique PyEGo. Assistedwith a
dependencyknowledgegraph,PyEGoconsidersdependenciesof
third-party packages, thePython interpreter and systemlibraries,
andinfersdependenciesforaprogrambyconstructingitsdepen-
dency graph and solving constraints in it. The evaluation shows
that PyEGo is more effective and efficient than the state-of-the-art
approaches. In the future, we plan to enhance PyEGo in several as-
pects,e.g.,consideringfiner-granularityfeatures,improvingdepen-
dencyminingbetweensystemlibrariesandthird-partypackages,
automating language feature identification and representation.
10 DATA AVAILABILITY
PyEGo and its experimental data are publicly available at https:
//github.com/PyEGo/PyEGo.
ACKNOWLEDGEMENTS
This work was partially supported by National Key R&D Program
of China (2017YFA0700603), National Natural Science Foundation
ofChina(61732019,U20A6003,62072444),FoundationofScience
and Technology on Parallel and Distributed Processing Laboratory
(61421102000402), Frontier Science Project of Chinese Academy of
Sciences(QYZDJ-SSW-JSC036),andYouthInnovationPromotion
Association at Chinese Academy of Sciences (2018142).
1255
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. ICSE ’22, May 21–29, 2022, Pittsburgh, PA, USA Hongjie Ye, Wei Chen, Wensheng Dou, Guoquan Wu, and Jun Wei
REFERENCES
[1][n.d.]. The Advanced packaging tool, or APT (from Wikipedia). Retrieved
August 20, 2021 from https://en.wikipedia.org/wiki/APT_(software)
[2][n.d.]. Built-inmagiccommands. RetrievedAugust11,2021fromhttps://ipython.
readthedocs.io/en/stable/interactive/magics.html
[3][n.d.]. Jd-assistant. Retrieved August 24, 2021 from https://github.com/tychxn/
jd-assistant
[4] [n.d.]. Libraries.io. Retrieved August 10, 2021 from https://libraries.io/
[5][n.d.]. Opencv-python. Retrieved September 2, 2021 from https://pypi.org/
project/opencv-python/
[6][n.d.]. pipreqs. Retrieved August 4, 2021 from https://github.com/bndr/pipreqs
[7][n.d.]. Pycryptodome changelog. Retrieved August 24, 2021 from https://
pycryptodome.readthedocs.io/en/latest/src/changelog.html#
[8] [n.d.]. PyPI. Retrieved August 7, 2021 from https://pypi.org/[9]
[n.d.]. Python Docs by version. Retrieved August 11, 2021 from https://docs.
python.org/3/
[10][n.d.]. PythonOfficialWebsite. RetrievedAugust13,2021fromhttps://www.
python.org/
[11][n.d.]. SnifferDog repository. Retrieved August 24, 2021 from https://github.
com/SMAT-Lab/SnifferDog
[12][n.d.]. What’s New in Python. Retrieved August 25, 2021 from https://docs.
python.org/3.9/whatsnew/
[13][n.d.]. Z3. Retrieved August 17, 2021 from https://github.com/Z3Prover/z3/
wiki#background
[14]2019. Customized dependency resolution / full required graph #3118. Retrieved
July 30, 2021 from https://github.com/pypa/pipenv/issues/3118
[15]2019. pip documentation v21.0.1. Retrieved July 30, 2021 from https://pip.pypa.
io/en/stable/reference/pip_install/
[16]EthanBommaritoandMichaelBommarito.2019. Anempiricalanalysisofthe
python package index (PyPI). arXiv preprint arXiv:1907.11073 (2019).
[17]Lingchao Chen, Foyzul Hassan, Xiaoyin Wang, and Lingming Zhang. 2020. Tam-
ing behavioral backward incompatibilities via cross-project testing and analysis.
InProceedingsoftheACM/IEEE42ndInternationalConferenceonSoftwareEngi-
neering. 112–124.
[18]Zhifei Chen, Yanhui Li, Bihuan Chen, Wanwangying Ma, Lin Chen, and Baowen
Xu.2020. AnEmpiricalStudyonDynamicTypingRelatedPracticesinPython
Systems. In Proceedings of the 28th International Conference on Program Compre-
hension. 83–93.
[19]RobertCollins.2015. DependencyspecificationforPythonSoftwarePackages.
RetrievedJuly30,2021fromhttps://www.python.org/dev/peps/pep-0508/#extras
[20]Jens Dietrich, David Pearce, Jacob Stringer, Amjed Tahir, and Kelly Blincoe.
2019. Dependencyversioninginthewild.In 2019IEEE/ACM16thInternational
Conference on Mining Software Repositories (MSR). IEEE, 349–359.
[21]John E Dunn. 2017. PyPI Python repository hit by typosquatting sneak at-
tack. RetrievedJuly28,2021fromhttps://nakedsecurity.sophos.com/2017/09/
19/pypi-python-repository-hit-by-typosquatting-sneak-attack/
[22]LysandrosNikolaouGuidovanRossum,PabloGalindo.2020. NewPEGparser
forCPython. RetrievedAugust11,2021fromhttps://www.python.org/dev/peps/
pep-0617/#overview
[23]Eric Horton and Chris Parnin. 2018. Gistable: Evaluating the executability of
pythoncodesnippetsongithub.In 2018IEEEInternationalConferenceonSoftware
Maintenance and Evolution (ICSME). IEEE, 217–227.
[24]EricHortonandChrisParnin.2019.Dockerizeme:Automaticinferenceofenviron-mentdependenciesforpythoncodesnippets.In 2019IEEE/ACM41stInternational
Conference on Software Engineering (ICSE). IEEE, 328–338.
[25]EricHortonandChrisParnin.2019. V2:fastdetectionofconfigurationdriftin
Python. In 2019 34th IEEE/ACM InternationalConference on Automated SoftwareEngineering (ASE). IEEE, 477–488.
[26]Kaifeng Huang, Bihuan Chen, Bowen Shi, Ying Wang, Congying Xu, and Xin
Peng.2020.Interactive,effort-awarelibraryversionharmonization.In Proceedings
of the 28th ACM Joint Meeting on European Software Engineering Conference and
Symposium on the Foundations of Software Engineering. 518–529.
[27]MarioCorcheroLarryHastings,PabloGalindoandEricN.VanderWeele.2018.
Python Positional-Only Parameters. Retrieved August 23, 2021 from https:
//www.python.org/dev/peps/pep-0570/
[28]Gianluca Mezzetti,AndersMøller,and MartinToldamTorp.2018. Typeregres-
sion testing to detect breaking changes in Node. js libraries. In 32nd European
Conference on Object-Oriented Programming (ECOOP 2018). Schloss Dagstuhl-
Leibniz-Zentrum fuer Informatik.
[29]Suhaib Mujahid, Rabe Abdalkareem, Emad Shihab, and Shane McIntosh. 2020.Using Others’ Tests to Identify Breaking Updates. In Proceedings of the 17th
International Conference on Mining Software Repositories. 466–476.
[30]SuchitaMukherjee,AbigailAlmanza,andCindyRubio-González.2021. Fixing
dependency errors for Python build reproducibility. In Proceedings of the 30th
ACMSIGSOFTInternationalSymposiumonSoftwareTestingandAnalysis.439–
451.
[31]Jibesh Patra, Pooja N Dixit, and Michael Pradel. 2018. Conflictjs: finding and
understandingconflictsbetweenjavascriptlibraries.In Proceedingsofthe40th
International Conference on Software Engineering. 741–751.
[32]Paul-Edouard Sarlin, Daniel DeTone, Tomasz Malisiewicz, and Andrew Rabi-
novich.2020. Superglue:Learning featurematching withgraph neural networks.
InProceedings of the IEEE/CVF conference on computer vision and pattern recogni-
tion. 4938–4947.
[33]Brandt Bucher Steven D’Aprano. 2019. Add Union Operators To dict. Retrieved
August 11, 2021 from https://www.python.org/dev/peps/pep-0584/#abstract
[34]Marat Valiev, Bogdan Vasilescu, and James Herbsleb. 2018. Ecosystem-level
determinantsofsustainedactivityinopen-sourceprojects:Acasestudyofthe
PyPI ecosystem. In Proceedings of the 2018 26th ACM Joint Meeting on European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering. 644–655.
[35]Duc-LyVu,IvanPashchenko,FabioMassacci,HenrikPlate,andAntoninoSabetta.
2020. Typosquatting and Combosquatting Attacks on the Python Ecosystem. In
2020IEEE EuropeanSymposiumonSecurity andPrivacyWorkshops(EuroS&PW).
IEEE, 509–514.
[36]AleksaVukotic,NickiWatt,TareqAbedrabbo,DominicFox,andJonasPartner.
2015.Neo4j in action. Vol. 22. Manning Shelter Island.
[37]Jiawei Wang, Li Li, and Andreas Zeller. 2021. Restoring Execution EnvironmentsofJupyterNotebooks.In 2021IEEE/ACM43rdInternationalConferenceonSoftware
Engineering (ICSE). IEEE, 1622–1633.
[38]Ying Wang, Ming Wen, Yepang Liu, Yibo Wang, Zhenming Li, Chao Wang,Hai Yu, Shing-Chi Cheung, Chang Xu, and Zhiliang Zhu. 2020. Watchman:
monitoring dependency conflicts for Python library ecosystem. In Proceedings of
the ACM/IEEE 42nd International Conference on Software Engineering. 125–135.
[39]Ying Wang, Ming Wen, Zhenwei Liu, Rongxin Wu, Rui Wang, Bo Yang, Hai Yu,
Zhiliang Zhu, and Shing-Chi Cheung. 2018. Do the dependency conflicts in my
projectmatter?.In Proceedingsofthe201826thACMJointMeetingonEuropean
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering. 319–330.
[40]YingWang,MingWen,RongxinWu,ZhenweiLiu,ShinHweiTan,ZhiliangZhu,
Hai Yu, and Shing-Chi Cheung. 2019. Could I have a stack trace to examine the
dependencyconflictissue?.In 2019IEEE/ACM41stInternationalConferenceon
Software Engineering (ICSE). IEEE, 572–583.
[41]YingWang,RongxinWu,ChaoWang,MingWen,YepangLiu,Shing-ChiCheung,
HaiYu,ChangXu,andZhi-liangZhu.2021. WillDependencyConflictsAffect
My Program’s Semantics. IEEE Transactions on Software Engineering (2021).
1256
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 08:26:40 UTC from IEEE Xplore.  Restrictions apply. 