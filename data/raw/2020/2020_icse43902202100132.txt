How to Identify Boundary Conditions with
Contrasty Metric?
1stWeilin Luo
School of Computer Science and Engineering
Sun Yat-sen University
Guangzhou, China
luowlin3@mail2.sysu.edu.cn2ndHai Wany
School of Computer Science and Engineering
Sun Yat-sen University
Guangzhou, China
wanhai@mail.sysu.edu.cn
3rdXiaotong Song
School of Computer Science and Engineering
Sun Yat-sen University
Guangzhou, China
songxt5@mail2.sysu.edu.cn4thBinhao Yang
School of Computer Science and Engineering
Sun Yat-sen University
Guangzhou, China
yangbh7@mail2.sysu.edu.cn
5thHongzhen Zhong
School of Computer Science and Engineering
Sun Yat-sen University
Guangzhou, China
zhonghzh5@mail2.sysu.edu.cn6thYin Chen
School of Computer Science
South China Normal University
Guangzhou, China
ychen@scnu.edu.cn
Abstract ‚ÄîThe boundary conditions (BCs) have shown great
potential in requirements engineering because a BC captures
the particular combination of circumstances, i.e.,divergence , in
which the goals of the requirement cannot be satisÔ¨Åed as a whole.
Existing researches have attempted to automatically identify lots
of BCs. Unfortunately, a large number of identiÔ¨Åed BCs make
assessing and resolving divergences expensive. Existing methods
adopt a coarse-grained metric, generality , to Ô¨Ålter out less
general BCs. However, the results still retain a large number of
redundant BCs since a general BC potentially captures redundant
circumstances that do not lead to a divergence. Furthermore, the
likelihood of BC can be misled by redundant BCs resulting in
costly repeatedly assessing and resolving divergences.
In this paper, we present a Ô¨Åne-grained metric to Ô¨Ålter out the
redundant BCs. We Ô¨Årst introduce the concept of contrasty of
BC. Intuitively, if two BCs are contrastive, they capture different
divergences. We argue that a set of contrastive BCs should be
recommended to engineers, rather than a set of general BCs
that potentially only indicates the same divergence. Then we
design a post-processing framework ( PPFc ) to produce a set of
contrastive BCs after identifying BCs. Experimental results show
that the contrasty metric dramatically reduces the number of BCs
recommended to engineers. Results also demonstrate that lots of
BCs identiÔ¨Åed by the state-of-the-art method are redundant in
most cases. Besides, to improve efÔ¨Åciency, we propose a joint
framework ( JFc) to interleave assessing based on the contrasty
metric with identifying BCs. The primary intuition behind JFc is
that it considers the search bias toward contrastive BCs during
yCorresponding author.
This paper was supported by the Guangdong Province Science and
Technology Plan projects (No. 2017B010110011), National Natural Science
Foundation of China (No. 61976232), National Key R&D Program of China
(No. 2018YFC0830600), Guangdong Province Natural Science Foundation
(No. 2018A030313086 and 2017A070706010 (soft science)).identifying BCs, thereby pruning the BCs capturing the same
divergence. Experiments conÔ¨Årm the improvements of JFc in
identifying contrastive BCs.
Index Terms ‚ÄîGoal-Oriented Requirement Engineering,
Boundary Conditions, Goal-ConÔ¨Çict IdentiÔ¨Åcation
I. I NTRODUCTION
Goal-oriented requirement engineering (GORE) [31] is an
essential phase of the software development life cycle, the
important task of which is to attain correct software re-
quirements speciÔ¨Åcations. Many researches have demonstrated
the signiÔ¨Åcant advantages that formal and goal-oriented ap-
proaches help generate correct speciÔ¨Åcations [1], [7], [11]. In
such approaches, domain properties andgoals are represented
inlinear-time temporal logic (LTL) because LTL is proved
convenient for abstracting speciÔ¨Åcations of a large class of
requirements, assumptions, and domain properties [31].
The identify-assess-control cycle in GORE aims at identify-
ing, assessing, and resolving inconsistency in which the goals
of the requirement cannot be satisÔ¨Åed as a whole. The diver-
gence is a weak inconsistency, i.e., particular circumstances
where the satisfaction of some goals inhibits the satisfaction
of others. A divergence is captured by boundary conditions
(BCs) which explain why the divergence happens. Various
approaches [9], [10], [32] have been proposed to automatically
identify BCs in the context of GORE.
As the number of identiÔ¨Åed BCs in the identiÔ¨Åcation stage
increases, for example, there are more than 100 BCs in the
case named London Ambulance Service in [9], the assess-
14732021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00132
ment stage and the resolution stage become very expensive,
and even impractical. In order to provide engineers with an
acceptable number of BCs to analyze, the generality metric
(DeÔ¨Ånition 2) [9] has been proposed to automatically Ô¨Ålter
out the less general BCs. The generality metric qualitatively
distinguishes the importance of BC using the implication
relationship of BCs. Intuitively, a more general (also known
as weaker) BC is more important because it potentially covers
more circumstances to represent a divergence. Therefore, the
less general BCs can be Ô¨Åltered out by the more general one.
Unfortunately, we observe that a set of general BCs still
retains a large number of redundant BCs. The reason is that the
generality metric can be considered as a coarse-grained metric.
A general BC potentially captures redundant circumstances
that do not lead to a divergence.
Furthermore, the accuracy of the assessment step based on
likelihood is sensitive to the redundant circumstances, so a set
of general BCs can lead to mistakes in the assessment step (an
example shown in Section III). The assessment stage is con-
cerned with evaluating how likely the identiÔ¨Åed conÔ¨Çicts are,
and how likely and severe are their consequences. Degiovanni
et al. [8] proposed an automatically assessing method based
on model counting, which can be used to prioritize BCs to be
resolved. However, a set of general BCs misleads to prioritize
the BCs because a general BC potentially captures redundant
circumstances that do not lead to a divergence.
In this paper, we present a new metric to assess the differ-
ences among the divergences captured by BCs. Our approach
is novel in the following respects: (1) It is a Ô¨Åne-grained metric
because it can Ô¨Ålter out not only the less general BCs but also
the BCs that capture the same divergence; (2) and it measures
the differences between BCs from the different divergences
captured by them. We Ô¨Årst introduce the concept of contrasty
of BCs motivated by avoiding boundary conditions [32] in
resolving divergences. More precisely, given two BCs and
', we consider whether 0=^:'and'0='^:are BCs.
0(resp.'0) represents the circumstances left by removing the
circumstances captured by '(resp.) from that captured by 
(resp.'). If neither 0nor'0is BC,and'are contrastive.
Intuitively, if two BCs are contrastive, they capture different
divergences. We argue that a set of contrastive BCs should be
recommended to engineers, rather than a set of general BCs
since they potentially only indicate the same divergence.
Based on the contrasty metric, we design a post-processing
framework ( PPFc ) to produce a set of contrastive BCs after
identifying BCs. Experimental results show that the contrasty
metric can Ô¨Ålter out all the BCs that capture the same
divergence, which dramatically reduces the number of BCs
recommended to engineers. Furthermore, experiments show
that the BCs identiÔ¨Åed by the state-of-the-art method are not
contrastive in most cases. In other words, these BCs capture
the same divergence, in which engineers only consider one
BC to resolve a divergence while others are redundant.
In order to improve efÔ¨Åciency, we propose a joint framework
(JFc) to interleave assessing based on the contrasty metric
with identifying BCs. SpeciÔ¨Åcally, when a BC is identiÔ¨Åedduring the search, we add its negation as an additional con-
straint to domain properties. The additional constraint makes
the domain properties dynamically change so that it prevents
the same circumstances from being identiÔ¨Åed as a BC again.
The insight behind this is that it produces the search bias
towards the BCs that capture different divergences. Besides,
we propose a sufÔ¨Åcient condition for the case where there not
exist BCs. It guarantees that if we resolve the divergences
captured by the BCs in the set of contrastive BCs, there
not exist divergences under the original domain properties
and goals. Experiments conÔ¨Årm the improvements of JFc in
identifying contrastive BCs.
Our main contributions are summarized as follows.
We present the novel contrasty metric to evaluate the
differences between BCs , which can Ô¨Ålter out more
redundant BCs that capture the same divergence.
We design a post-processing framework ( PPFc ) to pro-
duce a set of contrastive BCs. In order to improve
efÔ¨Åciency, we also design a joint framework ( JFc) to
capture different divergences during the search.
Experiments show that the contrasty metric is better than
the generality metric for Ô¨Åltering out redundant BCs.
II. B ACKGROUND
In this section, we introduce the background of goal-conÔ¨Çict
analysis and linear-time temporal logic. We brieÔ¨Çy recall some
basic notions for the rest of the paper.
A. Goal-ConÔ¨Çict Analysis
In GORE [31], goals are prescriptive statements that the
system must achieve, and domain properties are descriptive
statements that capture the domain of the problem world. In
practice, it is unrealistic to require requirements speciÔ¨Åcations
to be complete or all goals to be satisÔ¨Åable, because inconsis-
tencies may occur. Goal-conÔ¨Çict analysis [31], [33] deals with
the inconsistencies via the following identify-assess-control
cycle:
1) the identiÔ¨Åcation stage is to identify a condition whose
occurrence makes some inconsistencies;
2) the assessment stage is to assess and prioritize the
identiÔ¨Åed inconsistencies according to their likelihood
and severity;
3) the resolution stage is to resolve the identiÔ¨Åed inconsis-
tencies by providing appropriate countermeasures.
Goal-ConÔ¨Çict IdentiÔ¨Åcation. In this paper, we focus on a
weak inconsistency, i.e.,divergence . A divergence essentially
represents a boundary condition (BC) whose occurrence re-
sults in the loss of satisfaction of the goals, which makes the
goal divergence [32].
DeÔ¨Ånition 1. LetG=fg1;:::;gngbe a set of goals and
Dom a set of domain properties. A divergence occurs within
1474Dom iff there exists a boundary condition 'underDom and
Gsuch that the following conditions hold:
Dom^G^'j=? (logical inconsistency)
Dom^G i^'6j=?, for each 1in (minimality)
:G6' (non-triviality)
whereG=V
1ingiandG i=V
j6=igj.
Intuitively, a BC captures a particular combination of cir-
cumstances in which the goals cannot be satisÔ¨Åed as a whole.
The logical inconsistency property means the conjunction of
goals becomes inconsistent when 'holds. The minimality
property states that disregarding any of the goals no longer
results in inconsistency. The non-triviality property forbids
a BC to be a trivial condition which is the negation of the
conjunction of the goals. Note that BCs are not false due to
the minimality property.
Specifying software requirements in the LTL formulation
allows us to employ automated LTL satisÔ¨Åability solvers to
check for the feasibility of the corresponding requirements.
With an efÔ¨Åcient LTL satisÔ¨Åability solver, we can automati-
cally check if the generated candidate formulae are valid BCs
or not by checking if they satisfy the properties.
In the identiÔ¨Åcation stage, the generality [9] metric has been
proposed to reduce the redundant BCs. It is deÔ¨Åned as follows.
DeÔ¨Ånition 2. LetSbe a set of BCs. A BC 'i2Sismore
general than another BC 'j2Sif'jimplies'i.
Intuitively, a more general BC 'captures all the particular
combinations of circumstances captured by the less general
BCs than'. Therefore, it is important to provide engineers
with more general BCs. As far as we know, the generality
metric is the only metric to Ô¨Ålter out BCs.
Goal-ConÔ¨Çict Assessment. In the assessment stage, in order
to give engineers more guidance on which BCs need to get
attention, probabilities [3] of their occurrence are considered as
an important indicator. For systems without extra probabilistic
information, there is an approach [8] based on model counting
to analyze the likelihood of BCs. It is deÔ¨Åned as follows.
DeÔ¨Ånition 3. Letbe a BC,Dom domain properties, and k
a positive integer. The likelihood of isL() =#(Dom[;k)
#(Dom;k )
where #(C;k)denotes that the total number of models bases
of lengthksatisfying constraints in C.
Intuitively, the larger likelihood of a BC indicates that the
divergence captured by the BC is more likely to happen.
Goal-ConÔ¨Çict Resolution. In the resolution stage, as the
BCs malfunction the system when the system reaches the
circumstances captured by BCs, the engineers need some
strategies to resolve the divergences captured by the BCs.
DeÔ¨Ånition 4. LetDom be domain properties, Ggoals, and
a BC under Dom andG.Resolving divergences aims to
modifyDom andGto getDom0andG0, so thatunder
Dom0andG0does not fulÔ¨Åll at least one of the following
constraints:1)Dom0^G0^'j=?;
2)Dom0^G0
 i^'6j=?, for each 1in;
3):G06'.
Intuitively, after resolving divergences, the circumstances
captured by the BC do not happen under the new system
expressed by updated domain properties and goals. Van Lam-
sweerde et al. [32] proposed that generating reasonably up-
dated domain properties and goals is an open problem because
it requires a lot of experience. We will illustrate an example
of resolving divergences in VIII. Therefore, a large number of
identiÔ¨Åed BCs make the resolution stage very expensive.
A straightforward strategy can be adopted to avoid the
circumstances captured by a BC. The avoid pattern [32] is
therefore introduced: (Dom!:B)whereBdenotes a
BC to be inhibited.
B. Linear-Time Temporal Logic
Linear-Time Temporal Logic (LTL) [29] is widely used
to describe inÔ¨Ånite behaviors of discrete systems, which is
suitable for specifying software requirements [32]. Throughout
this paper, we use lower case letters ( e.g.,p,h) to denote
propositions. The syntax of LTL for a Ô¨Ånite set of proposi-
tionsPincludes the standard logical connectives ( ^,_,:),
B=f?;>g, and temporal operators next (),until (U).
':=?j>jpj'1^'2j'1_'2j:'j'j'1U'2
Operator release ( R), eventually ( ), always ( ), and
weak-until (W) are commonly used, and can be deÔ¨Åned as
'1R'2:=:(:'1U:'2),':=>U',':=:(>U:'),
and'1W'2:='1U('2_'1), respectively. We use j'jto
denote the sizeof the formula ',i.e., the number of temporal
operators, logical connectives, and literals in '.
LTL formulae are interpreted over a linear-time structure . A
linear-time structure is a pair of W= (S;")whereSis a state
sequence and ":S!2Pis a function mapping each state sito
a set of propositions. Let Wbe a linear-time structure, i1
a position, and '1,'2two LTL formulae. The satisfaction
relationj=is deÔ¨Åned as follows:
W;ij=p iffp2"(si), wherep2P
W;ij=: iffW;i6j=
W;ij='1^'2 iffW;ij='1andW;ij='2
W;ij=' iffW;i + 1j='
W;ij='1U'2iff9kis.t.W;kj='2and
8ij <k;W;jj='1
An LTL formula 'is called satisÔ¨Åable if and only if there is
a linear-time structure (model) satisfying '. An LTL formula
'implies an LTL formula '0, noted'!'0, if the models
of'are also models of '0. The LTL satisÔ¨Åability problem
is to check whether an LTL formula is satisÔ¨Åable, which is
PSPACE-complete [30]. Recently, LTL satisÔ¨Åability checkers
based on different techniques have been developed. Among
these checkers, nuXmv [6] and Aalta [22] have achieved better
performance.
1475III. M OTIVATING EXAMPLE
In this section, we will illustrate the drawbacks of the
generality metric through an example and discuss the insights
behind the contrasty metric. Below we illustrate an example,
MinePump [20].
Example 1. Consider a system to control a pump inside a
mine. The main goal of the system is avoiding Ô¨Çood in the
mine. The system has two sensors. One detects the high water
level (h), the other detects methane in the environment ( m).
When the water level is high, the system should turn on the
pump (p). When there is methane in the environment, the pump
should be turned off. Domain property ( Dom ) and goals ( G)
are represented via the following LTL formulae.
Domain Property:
1)Name : PumpEffect ( d1)
Description : The pump is turned on for two time steps,
then in the following one the water level is not high.
Formula :((p^p)! (:h))
Goals:
1)Name : NoFlooding ( g1)
Description : When the water level is high, the system
should turn on the pump.
Formula :(h! (p))
2)Name : NoExplosion ( g2)
Description : When there is methane in the environment,
the pump should be turned off.
Formula :(m! (:p))
Although the speciÔ¨Åcation is consistent, i.e., all domain
properties and goals can simultaneously be satisÔ¨Åed, this
speciÔ¨Åcation exhibits some goal divergences. One of the BCs
is'1=(h^m), which captures the circumstances where
the high water level and the methane occur at the same time.
Under this situation, two goals are unsatisÔ¨Åable simultaneously
within domain property.
We also consider other two BCs '2=h^mand'3=
(h^:m^p^ (:h^:p_h^(m_:p))).'2captures
the circumstances that the water level is high and the methane
occurs at the beginning. Through equivalent transformation,
we can obtain '3=((h^:m^p)^ ((:h^m^:p)_
(h^m^p)_(:h^:m^:p)_(h^m^:p)_(h^:m^:p))).
Clearly,'3captures Ô¨Åve circumstances, where, in the future,
the system will migrate from the state where the high water
level occurs, the methane does not occur, and the pump is
turned on (h^:m^p) to the state described as follows.
1) the high water level does not occur, the methane occurs,
and the pump is not turned on ( :h^m^:p);
2) the high water level and the methane occur and the pump
is turned on ( h^m^p);
3) the high water level and the methane do not occur and
the pump is not turned on ( :h^:m^:p);
4) the high water level and the methane occur and the pump
is not turned on ( h^m^:p);
5) the high water level occurs, the methane does not occur,
and the pump is not turned on ( h^:m^:p).Existing methods can search for a large number of BCs. It
makes the assessment and resolution stages very expensive,
and even impractical. In order to provide engineers with an
acceptable number of BCs to be analyzed, it is necessary to
proposed metric to Ô¨Ålter out the redundant BCs.
If we apply the generality metric, we Ô¨Ålter out '2because
'1is more general than '2. However, the generality metric
cannot evaluate '1and'3since the generality relationship
between them does not hold. In the assessment stage, if we
compute the likelihood based on the method [8], we can
classify'3as being more likely than '1in the long term, and
engineers should prioritize '3in the search for mechanisms
that would allow us to reduce the chances of reaching '3.
Unfortunately, the assessment method [8] lacks the accu-
racy to compute the likelihood by model counting because
some models are meaningless, i.e., there does not exist the
circumstances to lead the divergence in reality. Considering
the circumstances captured by '3, we observe that the cir-
cumstances (1), (3), (4), and (5) violate g1. Therefore, they
cannot satisfy the minimality of BC, which means that they
cannot capture the divergence in reality. These circumstances
areredundant , so'0
3=((h^:m^p)^ (h^p^m))
stands for the circumstances captured by '3. We Ô¨Ånd that '1
is more likely than '0
3using the assessment method [8], so
'1should be prioritized. Situations like this show that the
accuracy of the assessment method based on likelihood is
sensitive to redundant circumstances.
In addition, we Ô¨Ånd that '1,'2, and'3capture the same
divergence, in which the high water level and the methane
occur at the same time, i.e., the circumstance captured by
'1. It is very useful to identify the BC like '1in resolving
divergences. Engineers only resolve '1instead of resolving
'3Ô¨Årst and then '1. It avoids wasting computing resources
caused by assessing and resolving redundant BCs.
In this paper, motivated by avoiding boundary condi-
tions [32] in resolving divergence, we introduce the concept
of witness (DeÔ¨Ånition 5) and contrasty (DeÔ¨Ånition 6) of BCs.
Intuitively, the witness of a BC indicates the cause of diver-
gence. If the two BCs are not mutual witnesses, then the two
BCs are contrastive, i.e., they capture different divergences. In
this case,'1and'3are not contrastive because '1is a witness
of'3, but not vice versa, which means that the divergences
captured by '1are wider than that captured by '3. Therefore,
we recommend '1to engineers and Ô¨Ålter out '3.
IV. I DENTIFYING BOUNDARY CONDITIONS WITH
CONTRASTY METRIC
In this section, we Ô¨Årst introduce the concept of contrasty of
BCs. Then, we design a post-processing framework to identify
a set of contrastive BCs.
A. Contrasty
We Ô¨Årst introduce the concepts of witness andcontrasty .
DeÔ¨Ånition 5. Letfbe an LTL formula and 'a BC.fis a
witness of'iff'^:fis not a BC.
1476In the deÔ¨Ånition, motivated by avoiding boundary condi-
tions [32] in resolving divergences, we use a negative LTL
formula to avoid some circumstances, i.e., resolving the diver-
gence. Therefore, the witness fof a BC'indicates why 'is
a BC. Iffis a BC, it means that the divergence captured by
'is also captured by f.
DeÔ¨Ånition 6. Letand'be BCs.and'arecontrastive ,
iffis not a witness of 'and'is not a witness of .
DeÔ¨Ånition 7. LetBcbe a set of BCs.Bcis contrastive, iff
8;'2Bc^6=',and'is contrastive.
Intuitively, the contrastive BCs capture different diver-
gences. We use an example to illustrate the deÔ¨Ånition of
witness and contrasty.
Example 2 (Example 1 cont.) .'1=(h^m),'2=h^m,
and'3=(h^:m^p^(:h^:p_h^(m_:p))). Because
'1^:'3is also a BC, e.g., it captures the circumstances where
the high water level and the methane occur at the beginning,
'3is not a witness of '1.'1is a witness of '3since'3^:'1
does not satisfy the minimality constraint of BC, i.e., d1^g1^
('3^:'1)is unsatisÔ¨Åable. Therefore, '1and'3are not
contrastive. '1is a witness of '2and'2is not a witness
of'1, so'1and'2are not contrastive. Intuitively, '1is
more important than '2since the divergence captured by '1
is wider than that captured by '2('2is a special case of '1).
'2and'3are contrastive since they express the occurrence
of the high water level and the methane in different situations.
Based on the deÔ¨Ånition, we have the following theorems.
These theorems indicate the highlight of the contrasty metric.
Theorem 1. Letand'be BCs. If!', then'is a
witness of.
It is straightforward to prove Theorem 1 because ^:'is
unsatisÔ¨Åable. Because of Theorem 1, we have Theorem 2.
Theorem 2. LetBcbe a set of contrastive BCs. 8;'2
Bc^6=',6!'^'6!.
Theorem 2 shows that there is not a general relation between
any two BCs in a contrastive BC set, while there can be a
witness relation between some two BCs in a general BC set.
According to Theorem 2, the contrasty metric can be regarded
as a Ô¨Åner-grained metric than the generality metric because
contrasty metric can Ô¨Ålter out more redundant BCs than the
generality metric. Let us recall Example 1. f'1;'3gis general,
but not contrastive. If the contrasty metric is considered, then
f'1gis a contrastive.
Property 1. Letand'be BCs. Ifis a witness of 'and'
is not a witness of , then resolving the divergence captured
byleads to resolving the divergence captured by '.
Property 1 shows that it is reasonable that engineers priori-
tizeto resolve since the circumstances captured by include
the circumstances captured by '.Theorem 3. Letand'be two BCs. If and'are
contrastive, then and'capture different divergences.
Sketch of proof. and'are contrastive, so (resp.') is
not the witness of '(resp.), which means that ^:'
(resp.'^:) is still a BC. The primary intuition behind
^:'(resp.'^:) is that after resolving the divergences
captured by '(resp.), there are still divergences captured
by(resp.'). Therefore, and'capture different diver-
gences.
Theorem 3 shows that contrastive BCs capture different
divergences. Therefore, it is meaningful to recommend a set
of contrastive BCs to engineers.
According to the above analysis, we argue that a set of
contrastive BCs should be recommended to engineers, rather
than a set of general BCs since they potentially only indicate
the same divergences. In Section V, we will discuss the
different divergences captured by contrastive BCs and report
the advantage of the contrasty metric.
B. Post-Processing Framework
We design a p ost-p rocessing framework for f iltering the BCs
based on the c ontrasty metric ( PPFc ). It takes a set of BCs
(B) identiÔ¨Åed by a BC solver as inputs. Its output is a set of
contrastive BCs (Bc).
Algorithm 1: PPFc
Input: a set of BCsB.
Output: a set of contrastive BCs Bc.
1Bc B ;
2foreach BC2Bcdo
3B0
c Bc=;
4isContrastive;W  
EXTERNAL CONTRASTY FILTER (,B0
c);
5 ifisContrastive then
6Bc Bc=W;
7 else
8Bc Bc=;
9returnBc;
The pseudo code is outlined in Algorithm 1. At each
iteration, we choose a BC 2Bc(Alg. 1 of line 2), then
discuss its relationship with other BCs 'inBc(Alg. 1 of
line 4). Ifand'are witnesses of each other (Alg. 2 of line 3),
which means that and'capture the same divergences, we
select the one with smaller size1to stay inBc. Ifis a witness
of'and'is not a witness of (Alg. 2 of line 8), which
means that the divergences captured by is wider than that
captured by ', we retain; otherwise (Alg. 2 of line 10), we
remove. Ifand'are not witnesses of each other, we do
not delete any one because they are contrastive.
Theorem 4. When Algorithm 1 terminates, Bcis contrastive.
1The BC with smaller size is more compact, and easier to interpret.
1477Algorithm 2: EXTERNAL CONTRASTY FILTER
Input: a BCand a set of BCsB.
Output: whetheris contrastive inBand a set of
BCsWÔ¨Åltered by.
1W ;;
2foreach BC'2B do
3 ifis a witness of 'and'is a witness of then
4 ifthe size ofis larger then that of 'then
5 return False,;;
6 else
7 W W[f'g;
8 else ifis a witness of 'and'is not a witness
ofthen
9W W[f'g;
10 else ifis not a witness of 'and'is a witness
ofthen
11 return False,;;
12return True,W;
It is straightforward to prove Theorem 4. Theorem 4 guar-
antees that Algorithm 1 returns a set of contrastive BCs. We
illustrate our method through a running example as follows.
Example 3 (Example 1 cont.) .Assume that the BC solver
returns the set of BC B=f'1;'2;'3g, where'1=(h^m),
'2=h^m, and'3=(h^:m^p^ (:h^:p_
h^(m_:p))).Bcis initialized tof'1;'2;'3g. At the Ô¨Årst
iteration, assume that PPFc chooses'2.'2will be compared
with'1and'3. Because'2is not a witness of '1and'1is a
witness of'2,EXTERNAL CONTRASTY FILTER returns False
and an empty set. Bcwill be updated as f'1;'3g. At the
second iteration, assume that PPFc chooses'1.'1will be
compared with '3. Because'1is a witness of '3and'3is not
a witness of '1,EXTERNAL CONTRASTY FILTER returns True
andf'3g.Bcwill be updated as f'1g. Then PPFc returns
f'1gand terminates.
C. Discussion about completeness and Performance
In this paper, we are not concerned with the completeness
of identifying contrastive BCs, i.e., the divergences captured
by contrastive BCs cover all the divergences captured by BCs
that have been found. The reason is as follows.
Firstly, we focus on Ô¨Åltering out redundant BCs for better
resolving divergences which is the fundamental purpose of
GORE. In general, the better the identiÔ¨Åcation result is, the
easier the resolution stage is. Therefore, we argue that the
identiÔ¨Åed BCs should be conducive to resolving divergences
as much as possible rather than completeness.
Furthermore, the completeness of the BC set does not help
to resolve divergences. Resolving divergences is a dynamic
process. After resolving a BC, some BCs in the original BC
set are no longer BCs under the updated domain properties andTABLE I
THE DETAILS OF CASES
Case #Dom #Goal #Var Size
RetractionPattern1 (RP1) 0 2 2 9
RetractionPattern2 (RP2) 0 2 4 10
Elevator (Ele) 1 1 3 10
TCP 0 2 3 14
AchieveAvoidPattern (AAP) 1 2 4 15
MinePump (MP) 1 2 3 21
ATM 1 2 3 22
Rail Road Crossing System (RRCS) 2 2 5 22
Telephone (Tel) 3 2 4 31
London Ambulance Service (LAS) 0 5 7 32
Prioritized Arbiter (PA) 6 1 6 57
Round Robin Arbiter (RRA) 6 3 4 77
Simple Arbiter (SA) 4 3 6 84
Load Balancer (LB) 3 7 5 85
LiftController (LC) 7 8 6 124
ARM‚Äôs Advanced Microcontroller
Bus Architecture (AMBA)6 21 16 415
goals. In this way, for resolving divergences, it is meaningless
to get the complete BC set in the BC identiÔ¨Åcation stage.
For example, a set of general BCs fulÔ¨Ålls the completeness,
but it still retains a large number of redundant BCs that
capture the same divergences, so that engineers will do a lot of
meaningless work for resolving divergences. In other words,
although the generality metric satisÔ¨Åes the completeness, it
will also increase the burden of resolving divergences. By
comparison, the contrasty metric Ô¨Årst considers the optimiza-
tion of BC resolving divergences.
PPFc only begins to Ô¨Ålter out redundant BCs after the
BC solver returns a set of BCs. A natural idea is to directly
identify contrastive BCs during searching for BCs. In this
way, pruning the BCs capturing the same divergence can be
performed directly in the search process, thereby speeding up
the searching process. Based on this idea, we will discuss a
joint framework for identifying contrastive BCs in Section VI.
V. E VALUATION OF CONTRASTY
In this section, we reported the advantage of the contrasty
metric. Here, we presented the Ô¨Årst research question.
RQ 1. Compared with the generality metric, what are the
advantages of the contrasty metric?
Given a set of BCs BidentiÔ¨Åed by a BC solver, we
applied different metrics to Ô¨Ålter out redundant BCs. For
the competitor, we combined the generality metric and the
likelihood to Ô¨Ålter and sort the BCs. SpeciÔ¨Åcally, we Ô¨Årst
Ô¨Åltered out the less general BCs to produce a set of general
BCsBgand then sorted them according to the likelihood of
BC from high to low. Based on PPFc , we computed a set
of contrastive BCs Bcand sorted them by the likelihood.
We analyzed the shortcomings of the generality metric and
reported the advantages of the contrasty metric by comparing
BgandBc.
1478TABLE II
THEBCS PRODUCED BY DIFFERENT METRICS
CaseGL CL
Rank BC Rank BC Witness
RP11 (((p^((:q)))U((q^(:p))))_((p^((:q))))) 1 (p^((:q)))_((q^(:p))) 1,2,3, 4
2((p^((:q)))_((q^(:p))))
3 ((:qU(q^:p))U((p^((:q)))))_((:qU(q^:p)))
4 (p^((:q)))_((q^:p))
RP21 ((p^(:q^:s))_(q^:r)) 1 ((q^:r)_((p^(:sU(:q^:s))))) 1,2,3
2((p^(:sU(:q^:s)))_(q^:r))
3 (p^(:sU(:q^:s)))_(q^:r)
Ele1((call^((:open )))) 1((call^(:open ))) 1,3
2 (((:atfloor^(open )))U(call^((:open ))))_(((:atfloor^(open )))) 2 openU(call^(:open )) 2,4
3 (:atfloor^(call)) 3 (call^((:open )))_(((call^(:open )))) 2,3,5
4 openU(call^(:open ))
5 (call^((:open )))_(((call^((:open )))))
TCP1 (delivered^(send^:ack))_(send^(ack^:delivered )) 1 (((send^:ack)U(send^(ack^:delivered )))_((send^:ack))) 1,2,3
2 (((send^:ack)U(send^(ack^:delivered )))_((send^:ack)))
3((delivered^:ack)U(send^ack^:delivered ))_
((delivered^:ack))
AAP1 (r^p) 1 (r^p) 1,2,3,5
2 (r^p)_((r^(s))) 2 r^((p)) 4,5
3 (r^p)_((r^(q)))
4 r^((p))
5 ((r^p)U((p^((:q)))))_((r^p))
MP1 (h^:m^p^ (:h^:p_hw^(m_:p))) 1 (h^m) 1,2,3,4,5,6
2 (m^h)
3 (m^h)_(h^(:p))
4 (m^h)_(m^(p))
5 (m^(p))U((m^h))_(m^(p))
6 (h)_(m^h)
ATM1 ((:p^(:l))_(:m^(p^:l))) 1 ((:p^(:l))_(:m^(p^:l))) 1,2,3,4,5,6,7,8
2 ((:p^(m_(:l)))_(:m^(p^:l)))
3 (((:m^(p^(:l)))U(:p^(m_(:l))))_(:m^(p^:l)))
4 (((:pU(:m^(p^:l)))_:p))
5 ((:m^p)U(:p^(m_(:l))))_(:m^p)
6 (:p^(m_(:l)))_(:m^(p^:l))
7((:p^(m_(:l)))_(:m^(p^:l)))
8 (((:pU(l))_:p)_(:m^:l))
RRCS1 (((cc^tc))_((go^ta))) 1 (cc^tc)_((go^ta)) 1,2,3,4
2 ((cc^tc))_(go^ta)
3 (cc^tc)_((go^ta))
4 ((cc^tc))_((go^tc))
Tel1 (((>^:d)U(:c^(>^: d)))^c) 1 ((:dU(f^:d))^c) 1,2,3,4
2 ((:dU(o^:d))^c)
3 ((:dU(f^:d))^c)
4 ((((:dU(:c^:d))_(:d))^c))
RRA1 (((((r1^(:g1)))U((g0^g1)))_((r1^(:g1))))_(r0^(g1))) 1 (((r1^(:g1)))_(r0^(g1))) 1,2,3,4,5
2 (((r1^(:g1)))_(r0^(g1)))
3 ((((r1^(:g1)))U(g0^g1))_((r1^(:g1))))_(r0^(g1))
4((((r1^(g0)))U(r0^(r1)))_((r1^(g0))))
5(((((r1^(:g1)))U((r1^g1)))_((r1^(:g1))))U(r0^(g1)))_
((((r1^(:g1)))U((r1^g1)))_((r1^(:g1))))
1479A. Benchmarks
We evaluated contrasty on 16different cases introduced
by [9]. The details of each case are shown in Table I including
the numbers of domain properties (column ‚Äò#Dom‚Äô), goals
(column ‚Äò#Goal‚Äô), variables (column ‚Äò#Var‚Äô), and the total size
of all formulae (column ‚ÄòSize‚Äô) for the speciÔ¨Åcation of each
case. The order of the cases is sorted by the size of all formulae
from small to large.
B. Experimental Setups
We used the following experimental setups.
We employed the state-of-the-art BC solver2[9] denoted
byGAto identify BCs. It is based on a genetic algorithm
to search BCs.
We followed the conÔ¨Åguration of GAdescribed in the
paper [9] including the size of the initial population
generated from such a speciÔ¨Åcation and the limit of 50
generations, i.e.,50evolutions of the genetic algorithm
population.
We invoked Aalta [22] as the LTL satisÔ¨Åability checker
to check whether an LTL formula is a BC, whether one
BC is more general than the other, and whether one BC
is a witness of the other. Note that GA[9] also used Aalta
as the LTL satisÔ¨Åability checker.
We computed the likelihood of a BC by the method [8].
And we set kto1000 , which is used in the paper [8] for
good accuracy.
For each case, we ran the algorithm 10times and reported
the mean data.
All the experiments were run on the 2:13GHz Intel E 7-
4830 , with 128GB memory under GNU/Linux (Ubuntu
16:04).
C. Experimental Results
Table III summarizes the number of BC in B(‚ÄòjBj‚Äô),Bg
(‚ÄòjBgj‚Äô), andBc(‚ÄòjBcj‚Äô), where the column ‚Äò#suc.‚Äô means the
number of successful runs (out of 10 runs). If GAfails in all
10 runs, the results are marked by ‚ÄòN/A‚Äô. Overall, our method
can solve all the cases that can be solved by GAto identify
BCs. Clearly, if the solver cannot identify BCs, our method
cannot perform the post-processing.
For most cases, GAreturns a large number of BCs thanks
to the development of search-based methods. Note that such
a large set of BC can cause a huge burden in the assessment
stage and the resolution stage. Seeing the columns ‚Äò jBgj‚Äô and
‚ÄòjBcj‚Äô, we observe that the size of Bcis much smaller than
that ofBgfor all cases. It means that, compared with the
generality metric, the contrasty metric can considerably reduce
the number of BCs to be analyzed by engineers.
Table II summarizes the results of the different metrics,
for the BCs identiÔ¨Åed for each of the case studies. We
selected the data that GAgot the most number of BC from 10
times experiments for display. The column ‚ÄòGL‚Äô ( resp. ‚ÄòCL‚Äô)
illustrates the BCs (‚ÄòBC‚Äô) in Bg(resp.Bc) and their rank
2http://dc.exa.unrc.edu.ar/staff/rdegiovanni/ASE2018.htmlTABLE III
THE NUMBER OF BC RECOMMENDED BY DIFFERENT METRICS
CasejBjjBgjjBcj#suc.
RP1 37.1 3.2 1.2 10
RP2 35.1 2.6 1.2 10
Ele 28 3.2 2.6 10
TCP 53.9 2.1 1.5 10
AAP 50.3 3.7 1.8 10
MP 40.7 4.5 1.4 10
ATM 64.4 3.4 1.2 10
RRCS 27.9 3 1 10
Tel 36.5 3 1 2
LAS N/A N/A N/A N/A
PA N/A N/A N/A N/A
RRA 40.571 3.14 1 7
SA N/A N/A N/A N/A
LB N/A N/A N/A N/A
LC N/A N/A N/A N/A
AMBA N/A N/A N/A N/A
(‚ÄòRank‚Äô) based on the likelihood metric. We also use the
column ‚ÄòRank‚Äô as the identiÔ¨Åcation of BCs. For every BCs 
inBc, we report which BCs in Bg(‚ÄòWitness‚Äô)is a witness
of and the identiÔ¨Åcation of inBgis marked in red.
For all cases,Bcis much smaller than BgandBcis a subset
ofBg, which conÔ¨Årms that the contrasty metric is a more
Ô¨Åner-grained metric than the generality metric. The results
also show that a set of general BCs still retains the BCs that
represent the same divergence. Particularly, for MP, ATM, and
RRA, the redundant BCs are too much to assess and resolve
divergences efÔ¨Åciently.
From the column ‚ÄòWitness‚Äô, every BC in Bgcan Ô¨Ånd a
witness of it inBc. This observation means that the BCs in
Bccapture all the divergences captured by the BCs in Bg.
Therefore, engineers only need to consider the BCs in Bc
when resolving divergences. In addition, we also observe that
the contrastive BCs rank lower in Bgin Ele, TCP, AAP, MP,
RRCS, TEL, and RRA. The reason, as mentioned above, is
that the circumstances that cannot describe the divergence lead
to mistakes of likelihood. Such mistakes are serious, which
will prevent engineers from grasping the main cause of the
divergence quickly. It leads to costly assessing and resolving
the same divergence repeatedly.
In summary, the generality metric cannot capture the differ-
ence between BCs. Surprisingly, lots of BCs identiÔ¨Åed by the
state-of-the-art BC solver are redundant in most cases. It puts
an expensive burden on assessing and resolving divergences.
The method we propose can compare this well and give a
recommendation that is more conducive to saving the costs of
assessing and resolving divergences.
VI. J OINT FRAMEWORK
In this section, we design a j oint framework to interleave
filtering based on the c ontrasty metric with identifying BCs
(JFc). We Ô¨Årst introduce the termination condition for iden-
tifying BCs and then propose JFc.
Motivated by the blocking clause approach to solving All-
SAT problem [25], we consider excluding the circumstances
1480captured by identiÔ¨Åed BCs in the search process to generate a
search bias towards the BCs that capture different divergences.
SpeciÔ¨Åcally, in the process of searching for BCs, once a
BCis identiÔ¨Åed, we add :as an additional constraint
to domain properties. The additional constraint makes the
domain properties dynamically change so that it can prevent
the same circumstances from being identiÔ¨Åed as a BC again
(Theorem 7). Moreover, we will prove that the BCs under the
additional constraint are also BCs under the original domain
properties and goals (Theorem 6).
Before introducing JFc, We Ô¨Årst propose a sufÔ¨Åcient con-
dition for the case where there does not exist a BC (called BC
termination condition ).
Theorem 5. LetDom be domain properties and Ggoals. If
91ijGj;Dom^G i^:Gij=?, then there does not
exist a BC under Dom andG.
Sketch of proof. We prove that if there exists a BC, then
81ijGj;Dom^G i^:Gi6j=?. If there is a BC under
Dom andG, thenDom^G^j=?(logical inconsistency)
and81ijGj;Dom^G i^6j=?(minimality). Because
of the logical inconsistency, we have ! : (Dom^G).
Therefore,Dom^G i^!Dom^G i^:(Dom^G).
Consider the minimality, we have 81ijGj;Dom^G i^
:(Dom^G)6j=?,i.e.,81ijGj;Dom^G i^:Gi6j=
?.
Based on Theorem 5, we can check whether there still exists
a BC under the dynamical domain properties and goals.
Algorithm 3: JFc
Input: domain properties Dom and goalsG.
Output: a set of contrastive BCs Bc.
1Bc ;;
2while True do
3isEnd; CALL BCS OLVER (Dom[f:'j'2
Bcg,G);
4 ifisEnd then
5 returnBc;
6 else
7W INTERNAL CONTRASTY FILTER (,Bc);
8Bc Bc=W;
9 ifthere is not a BC under
Dom[f:'j'2BcgandGthen
10 returnBc;
JFc takes the domain properties Dom and goalsGas
inputs. Its output is a set of contrastive BCs Bc. The pseudo
code is outlined in Algorithm 3. In order to identify BCs,
we involve existing BC solvers, e.g.,GA[9] and Tab [10]
(Alg. 3 of line 3). Note that we consider the dynamical domain
properties (Dom[f:'j'2Bcg). If the BC solver terminates,
we returnBc(Alg. 3 of line 5). Otherwise, unlike PPFc , we
updateBcwhen identifying a new BC (Alg. 3 of line 7-8).Algorithm 4: INTERNAL CONTRASTY FILTER
Input: a BCand a set of BCsB.
Output: a set of BCs WÔ¨Åltered by.
1W ;;
2foreach BC'2B do
3 ifis a witness of 'then
4W W[f'g;
5return True,W;
Note that we only remove the BCs which the new BC is a
witness of (Alg. 4 of line 3) because none of the BCs in Bcis
a witness of the new BC (Theorem 7). Afterward, if there still
exists a BC under Dom[f:'j'2BcgandG, we continue
to involve BC solver; otherwise, return Bc(Alg. 3 of line 9).
Theorem 6. LetDom be domain properties, Ggoals, andB
a set of BCs that has been identiÔ¨Åed. A LTL formula is a BC
underDom andG, ifis a BC under Dom[f:'j'2Bg
andG.
Sketch of proof. Because8'2B is a BC under Dom andG,
we haveDom^(V
'2B:')^G^Dom^G^. Therefore,
Dom^(V
'2B:')^G^j=?(logical inconsistency) holds.
BecauseDom^(V
'2B:')^G i^!Dom^G i^,
81ijGj;Dom^(V
'2B:')^G i^6j=?(minimality)
holds. The non-triviality obviously holds.
Theorem 6 shows that although the additional constraint is
considered, the results are still BCs under the original domain
properties and goals.
Theorem 7. In Algorithm 3, @'2Bcs.t.'is a witness of .
Sketch of proof. We prove Theorem 7 by inductive hypothesis
as follows.
At the Ô¨Årst iteration where Bcis an empty set, assume
we get a BC '1, Theorem 7 holds.
We suppose that at the k-th iteration where we get a BC
'k, Theorem 7 holds.
At thek+1-th iteration where Bc=f'1;:::;'kg, assume
we get a BC . Becauseis a BC under Dom[f:'j'2
BcgandG,81ijGj;Dom^(V
'2Bc:')^G i^
6j=?. Therefore, for every 'j2Bc,^:'jis a BC
underDom[f:'j'2Bc^'6='jgandG. Because
of Theorem 6, ^:'jis a BC under Dom andG.
Intuitively, based on Theorem 7, JFc can produce a search
bias towards the BCs that capture different divergences.
Theorem 8. In Algorithm 3, the BCs in the Ô¨Ånal Bcare not
witnesses with each other.
It is straightforward to prove Theorem 8 because of The-
orem 7 and Algorithm 4. Theorem 8 guarantees that Algo-
rithm 3 returns a set of contrastive BCs.
1481TABLE IV
THE OVERALL PERFORMANCE OF PPF CANDJFC
CasePPFc JFc
jBj jB cjGA t. (s) t. (s) #suc. jBj jB cj#T t. (s) #suc.
RP1 37.1 1.2 157.4 224.53 10 1 1 10 29.5 10
RP2 35.1 1.2 130.2 206 10 1.1 1.1 10 78.9 10
Ele 28 2.6 45.8 88.01 10 2.1 2.1 10 43.4 10
TCP 53.9 1.5 225.1 308.26 10 1.4 1.4 0 801.6 10
AAP 50.3 1.8 65.3 208.64 10 1 1 10 41.3 10
MP 40.7 1.4 59.3 146.02 10 1 1 10 60.8 10
ATM 64.4 1.2 102.2 259.19 10 1 1 10 25.2 10
RRCS 27.9 1 68.3 91.87 10 1 1 10 15 10
Tel 36.5 1 35.3 46.53 2 1 1 10 27 10
LAS N/A N/A N/A N/A 0 N/A N/A 0 N/A 0
PA N/A N/A N/A N/A 0 N/A N/A 0 N/A 0
RRA 40.571 1 696.43 878.7 7 1 1 10 255.1 10
SA N/A N/A N/A N/A 0 N/A N/A 0 N/A 0
LB N/A N/A N/A N/A 0 N/A N/A 0 N/A 0
LC N/A N/A N/A N/A 0 N/A N/A 0 N/A 0
AMBA N/A N/A N/A N/A 0 N/A N/A 0 N/A 0
VII. E XPERIMENTS
In this section, we conducted extensive experiments on a
broad range of benchmarks shown in Table I to evaluate
the performance of JFc by comparing with PPFc . We Ô¨Årst
presented the research questions.
RQ 2. What is the performance of the joint framework ( JFc)
for producing the contrastive BC set compared with the post-
processing framework ( PPFc )?
A. Experimental Setups
The experimental setups used in this section was the same
as the one described in Section V. In addition, we added the
new experimental setups.
We set the same BC solver ( GA[9]) for PPFc andJFc.
We invoked Aalta [22] to check the BC termination
condition.
B. Experimental Results
Table IV shows the overall performance of PPFc and
JFc, including the running time of GA(‚ÄòGA t.‚Äô), the running
time of the framework (‚Äòt.‚Äô), and the number of meeting the
BC termination condition (‚Äò#T‚Äô). In JFc,Brecords all BCs
identiÔ¨Åed during the search.
From the column ‚Äò jBcj‚Äô, the contrastive BCs obtained by
JFc is slightly less than that obtained by PPFc . This is
because JFc not only considers the contrasty in BC but also
considers the BC termination condition where JFc searches
for a set of contrastive BCs that is enough so that there is no
BC in the domain properties and goals after avoiding these
contrastive BCs. We also observe that the size of BofJFc
is much smaller than that of PPFc . Moreover, for JFc, the
size ofBis close to that ofBc. These observations show that
JFc produces a strong search bias towards the BCs that are
contrastive with the identiÔ¨Åed BCs.
InPPFc , the running time of GAis approximately the same
as that of producing a set of contrastive BCs. And the runningtime of producing a set of contrastive BCs increases as the
number of BCs identiÔ¨Åed by GAincreases. In particular, in
AAP, MP, and ATM, the running time of producing a set of
contrastive BCs is about 1:5times that of GA. It indicates
the drawback of PPFc , namely, the cost of producing a set of
contrastive BCs is proportional to the number of BCs identiÔ¨Åed
by a BC solver. It is foreseeable that the redundant BCs in
Bwill greatly reduce the efÔ¨Åciency of producing a set of
contrastive BCs.
JFc deals with the drawback of PPFc , because JFc uses
the identiÔ¨Åed contrastive BC for pruning during the search
process, thereby avoiding searching for the redundant BCs.
The shorter running time for meeting the BC termination
condition conÔ¨Årms this conclusion. If JFc meets the BC
termination condition, JFc will produce a set of contrastive
BCs efÔ¨Åciently.
Particularly, in RP1 and ATM, JFc is10times faster than
PPFc . We also observe that if JFc does not meet the BC
termination condition (only TCP), JFc is slower than PPFc .
It is reasonable because JFc additionally checks the BC
termination condition after Ô¨Ånding a new BC.
Conclusively, JFc produces the search bias towards con-
trastive BCs. In addition, the efÔ¨Åciency of JFc is not limited
to the number of BCs identiÔ¨Åed by a BC solver.
VIII. R ELATED WORK
Inconsistency management, i.e., how to deal with inconsis-
tencies in requirements, has also been the focus of several stud-
ies, in particular on the formal side. Besides the inconsistency
management approaches based on the informal or semi-formal
methods, such as [15], [16], [18], [19], a series of formal
approaches [11], [12], [14], [27] recently have been proposed,
which only focus on logical inconsistency or ontology mis-
match. Another related approach is proposed by Nuseibeh and
Russo [28], which generates the conjunction of ground literals
as an explanation for the unsatisÔ¨Åable speciÔ¨Åcation based on
abduction reasoning. As for consistency checking methods, we
1482have to mention the approach of Harel et al. [14], which iden-
tiÔ¨Åes inconsistencies between two requirements represented
as conditional scenarios. Moreover, the work [17], [23], [24]
studied the reasoning about conÔ¨Çicts in requirements. In this
paper, we focus on the situations that lead to goal divergences,
which are nothing but weak inconsistencies.
Goal-conÔ¨Çict analysis has been widely used as an abstrac-
tion for risk analysis in GORE. It is typically driven by the
identify-assess-control cycle, aimed at identifying, assessing
and resolving inconsistencies that may obstruct the satisfaction
of the expected goals.
In identifying inconsistencies, we have to mention the work
on obstacle analysis. An obstacle, Ô¨Årst proposed in [34], is a
particular goal conÔ¨Çict, which captures the situation that only
one goal is inconsistent with the domain properties. Alrajeh
et al. [2] exploited the model checking technique to generate
tracks that violate or satisfy the goals, and then to compute
obstacles from these tracks based on the machine learning
technique. Other approaches for obstacle analysis include [3]‚Äì
[5], [34]. Whereas, as obstacles only capture the inconsistency
for single goals, these approaches fail to deal with the situation
where multiple goals are conÔ¨Çicting.
In this work, we focus on the other inconsistencies ‚Äì
boundary condition. Let us come back to the problem of
identifying BCs. Existing approaches mainly categorize into
construct-based approaches and search-based approaches. For
construct-based approaches, Van Lamsweerde et al. [32] pro-
posed a pattern-based approach which only returns a BC in
a pre-deÔ¨Åned limited form. Degiovanni et al. [10] exploited a
tableaux-based approach that generates general BCs but only
works on small speciÔ¨Åcations because tableaux are difÔ¨Åcult to
be constructed.
For the search-based approach, Degiovanni et al. [9] pre-
sented a genetic algorithm which seeks for BCs and han-
dles speciÔ¨Åcations that are beyond the scope of previous
approaches. Moreover, Degiovanni et al. [9] Ô¨Årst proposed the
concept of generality to assess BCs. Their work Ô¨Åltered out
the less general BCs to reduce the set of BCs. However, the
generality is a coarse-grained assessment metric.
As the number of identiÔ¨Åed inconsistencies increases, the
assessment stage and the resolution stage become very expen-
sive and even impractical. Recently, the assessment stage in
GORE has been widely discussed to prioritize inconsistencies
to be resolved and suggest which goals to drive attention
to for reÔ¨Ånements. However, some of the work [2]‚Äì[5], [34]
assume that certain probabilistic information on the domain
is provided and analyzes to simpler kinds of inconsistencies
(obstacles).
In order to automatically assess BCs, Degiovanni et al. [8]
recently have proposed an automated approach to assess how
likely conÔ¨Çict is, under an assumption that all events are
equally likely. They estimated the likelihood of BCs by count-
ing how many models satisfy a circumstance captured by a BC.
However, the number of models cannot accurately indicate the
likelihood of divergence, because not all the circumstances
captured by a BC result in divergence. In this paper, wediscovered the drawbacks and proposed a new metric to avoid
evaluation mistakes for the likelihood.
For the resolution of conÔ¨Çicts, Murukannaiah et al. [26]
resolved the conÔ¨Çicts among stakeholder goals of system-to-be
based on the Analysis of Competing Hypotheses technique and
argumentation patterns. Related works on conÔ¨Çict resolution
also include [13] which calculates the personalized repairs for
the conÔ¨Çicts of requirements with the principle of model-based
diagnosis.
However, these approaches presuppose that the conÔ¨Çicts
have been already identiÔ¨Åed and our approach for boundary
condition discovery provides a footstone for solving these
problems. Let us recall Example 1. Letier et al. [21] resolved
the BC by reÔ¨Åning the Ô¨Årst goal as: the pump is switched on
when the water level is high and there is no methane. Formally,
((h^:m)! (p)).
IX. C ONCLUSION AND FUTURE WORK
Providing a reasonable set of BCs for assessing and re-
solving divergences is of great signiÔ¨Åcance both from an
economical perspective and an impact on software quality. In
this paper, we have proposed a new metric, contrasty, to deal
with the drawbacks caused by the generality metric. Because
BCs are ultimately used for resolving divergences, we argue
that the identiÔ¨Åed BCs should help to assess and resolve
divergences. The contrasty metric mainly distinguishes the dif-
ference between BCs from the point of resolving divergences.
Experimental results have shown the advantage of contrasty
metric, namely, it Ô¨Ålters out the BCs capturing the same
divergence. It helps to avoid costly reworks, i.e., assessing and
resolving the same divergence captured by redundant BCs. In
addition, we have designed a joint framework to improve the
performance of the post-processing framework.
Future work will extend our contrasty metric to the assess-
ment stage and the resolution stage.
ACKNOWLEDGMENT
We thank Fangzhen Lin, Yongmei Liu, Jianwen Li, and
Ximing Wen for discussion on the paper and anonymous
referees for helpful comments.
REFERENCES
[1] D. Alrajeh, J. Kramer, A. Russo, and S. Uchitel, ‚ÄúLearning operational
requirements from goal models,‚Äù in ICSE , 2009, pp. 265‚Äì275.
[2] D. Alrajeh, J. Kramer, A. Van Lamsweerde, A. Russo, and S. Uchitel,
‚ÄúGenerating obstacle conditions for requirements completeness,‚Äù in
ICSE , 2012, pp. 705‚Äì715.
[3] A. Cailliau and A. Van Lamsweerde, ‚ÄúA probabilistic framework for
goal-oriented risk analysis,‚Äù in RE, 2012, pp. 201‚Äì210.
[4] ‚Äî‚Äî, ‚ÄúIntegrating exception handling in goal models,‚Äù in RE, 2014, pp.
43‚Äì52.
[5] A. Cailliau and A. van Lamsweerde, ‚ÄúHandling knowledge uncertainty
in risk-based requirements engineering,‚Äù in RE, 2015, pp. 106‚Äì115.
[6] R. Cavada, A. Cimatti, M. Dorigatti, A. Griggio, A. Mariotti, A. Micheli,
S. Mover, M. Roveri, and S. Tonetta, ‚ÄúThe nuxmv symbolic model
checker,‚Äù in CAV, 2014, pp. 334‚Äì342.
[7] R. Degiovanni, D. Alrajeh, N. Aguirre, and S. Uchitel, ‚ÄúAutomated goal
operationalisation based on interpolation and sat solving,‚Äù in ICSE , 2014,
pp. 129‚Äì139.
1483[8] R. Degiovanni, P. Castro, M. Arroyo, M. Ruiz, N. Aguirre, and M. Frias,
‚ÄúGoal-conÔ¨Çict likelihood assessment based on model counting,‚Äù in ICSE ,
2018, pp. 1125‚Äì1135.
[9] R. Degiovanni, F. Molina, G. Regis, and N. Aguirre, ‚ÄúA genetic
algorithm for goal-conÔ¨Çict identiÔ¨Åcation,‚Äù in ASE, 2018, pp. 520‚Äì531.
[10] R. Degiovanni, N. Ricci, D. Alrajeh, P. Castro, and N. Aguirre, ‚ÄúGoal-
conÔ¨Çict detection based on temporal satisÔ¨Åability checking,‚Äù in ASE,
2016, pp. 507‚Äì518.
[11] C. Ellen, S. Sieverding, and H. Hungar, ‚ÄúDetecting consistencies and
inconsistencies of pattern-based functional requirements,‚Äù in FMICS ,
2014, pp. 155‚Äì169.
[12] N. A. Ernst, A. Borgida, J. Mylopoulos, and I. J. Jureta, ‚ÄúAgile
requirements evolution via paraconsistent reasoning,‚Äù in CAiSE , 2012,
pp. 382‚Äì397.
[13] A. Felfernig, G. Friedrich, M. Schubert, M. Mandl, M. Mairitsch, and
E. Teppan, ‚ÄúPlausible repairs for inconsistent requirements,‚Äù in IJCAI ,
2009, pp. 791‚Äì796.
[14] D. Harel, H. Kugler, and A. Pnueli, ‚ÄúSynthesis revisited: Generating
statechart models from scenario-based requirements,‚Äù in Formal Methods
in Software and Systems Modeling , 2005, pp. 309‚Äì324.
[15] J. H. Hausmann, R. Heckel, and G. Taentzer, ‚ÄúDetection of conÔ¨Çicting
functional requirements in a use case-driven approach,‚Äù in ICSE , 2002,
pp. 105‚Äì115.
[16] S. J. Herzig and C. J. Paredis, ‚ÄúA conceptual basis for inconsistency
management in model-based systems engineering,‚Äù Procedia CIRP ,
vol. 21, pp. 52‚Äì57, 2014.
[17] I. J. Jureta, A. Borgida, N. A. Ernst, and J. Mylopoulos, ‚ÄúTechne:
Towards a new generation of requirements modeling languages with
goals, preferences, and inconsistency handling,‚Äù in RE, 2010, pp. 115‚Äì
124.
[18] M. Kamalrudin, ‚ÄúAutomated software tool support for checking the
inconsistency of requirements,‚Äù in ASE, 2009, pp. 693‚Äì697.
[19] M. Kamalrudin, J. Hosking, and J. Grundy, ‚ÄúImproving requirements
quality using essential use case interaction patterns,‚Äù in ICSE , 2011, pp.
531‚Äì540.
[20] J. Kramer, J. Magee, M. Sloman, and A. Lister, ‚ÄúConic: an integrated
approach to distributed computer control systems,‚Äù IET Computers &
Digital Techniques , vol. 130, no. 1, pp. 1‚Äì10, 1983.
[21] E. Letier et al. , ‚ÄúReasoning about agents in goal-oriented requirements
engineering,‚Äù Ph.D. dissertation, PhD thesis, Universit ¬¥e catholique de
Louvain, 2001.
[22] J. Li, S. Zhu, G. Pu, and M. Y . Vardi, ‚ÄúSat-based explicit ltl reasoning,‚Äù
inHVC , 2015, pp. 209‚Äì224.
[23] C.-L. Liu, ‚ÄúOntology-based conÔ¨Çict analysis method in non-functional
requirements,‚Äù in ACIS-ICIS , 2010, pp. 491‚Äì496.
[24] D. Mairiza and D. Zowghi, ‚ÄúConstructing a catalogue of conÔ¨Çicts among
non-functional requirements,‚Äù in ENASE , 2010, pp. 31‚Äì44.
[25] K. L. McMillan, ‚ÄúApplying sat methods in unbounded symbolic model
checking,‚Äù in CAV, 2002, pp. 250‚Äì264.
[26] P. K. Murukannaiah, A. K. Kalia, P. R. Telangy, and M. P. Singh,
‚ÄúResolving goal conÔ¨Çicts via argumentation-based analysis of competing
hypotheses,‚Äù in RE, 2015, pp. 156‚Äì165.
[27] T. H. Nguyen, B. Q. V o, M. Lumpe, and J. Grundy, ‚ÄúKbre: a frame-
work for knowledge-based requirements engineering,‚Äù Software Quality
Journal , vol. 22, no. 1, pp. 87‚Äì119, 2014.
[28] B. Nuseibeh and A. Russo, ‚ÄúUsing abduction to evolve inconsistent
requirements speciÔ¨Åcation,‚Äù Australasian J. of Inf. Systems , vol. 7, no.
1; SPI, pp. 118‚Äì130, 1999.
[29] A. Pnueli, ‚ÄúThe temporal logic of programs,‚Äù in Annual Symposium on
Foundations of Computer Science , 1977, pp. 46‚Äì57.
[30] A. P. Sistla and E. M. Clarke, ‚ÄúThe complexity of propositional linear
temporal logics,‚Äù J. ACM , vol. 32, no. 3, pp. 733‚Äì749, 1985.
[31] A. Van Lamsweerde, Requirements engineering: From system goals to
UML models to software . Chichester, UK: John Wiley & Sons, 2009,
vol. 10.
[32] A. Van Lamsweerde, R. Darimont, and E. Letier, ‚ÄúManaging conÔ¨Çicts
in goal-driven requirements engineering,‚Äù IEEE Trans. Software Eng. ,
vol. 24, no. 11, pp. 908‚Äì926, 1998.
[33] A. Van Lamsweerde and E. Letier, ‚ÄúIntegrating obstacles in goal-driven
requirements engineering,‚Äù in ICSE , 1998, pp. 53‚Äì62.
[34] ‚Äî‚Äî, ‚ÄúHandling obstacles in goal-oriented requirements engineering,‚Äù
IEEE Trans. Software Eng. , vol. 26, no. 10, pp. 978‚Äì1005, 2000.
1484