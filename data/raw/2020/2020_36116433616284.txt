CAmpactor : A Novel and EﬀectiveLocalSearch Algorithm for
Optimizing PairwiseCoveringArrays
QiyuanZhao
Beihang University
Beijing, China
zqy1018@hotmail.comChuanLuo∗
Beihang University
Beijing, China
chuanluo@buaa.edu.cnShaowei Cai
Institute of Software,
Chinese Academy of
Sciences
Beijing, China
caisw@ios.ac.cnWei Wu
CentralSouthUniversity
and XiangjiangLaboratory
Changsha,China
william.third.wu@gmail.com
Jinkun Lin
SeedMathTechnology
Limited
Beijing, China
linjk@seedmath.comHongyuZhang
ChongqingUniversity
Chongqing,China
hyzhang@cqu.edu.cnChunmingHu
Beihang University
Beijing, China
hucm@buaa.edu.cn
ABSTRACT
Theincreasingdemandforsoftwarecustomizationhasledtothe
development ofhighly con/f_igurable systems. Combinatorialinter-
actiontesting(CIT)isaneﬀectivemethodfortestingthesetypes
ofsystems.TheultimategoalofCITistogenerateatestsuiteof
acceptable size, calleda /u1D461-wise covering array (CA), where /u1D461is the
testingstrength.Pairwisetesting( i.e.,CITwith/u1D461=2)isrecognizedto
be the most widely-used CIT technique and has strong fault detec-
tioncapability.Inpairwisetesting,themostimportantproblemis
pairwiseCAgeneration(PCAG),whichistogenerateapairwiseCA
(PCA)ofminimumsize.However,existingstate-of-the-artPCAG
algorithmssuﬀerfromtheseverescalabilitychallenge;thatis,they
cannottacklelarge-scalePCAGinstanceseﬀectively,resultingin
PCAs of large sizes. To alleviate this challenge, in this paper we
proposeCAmpactor , a novel and eﬀective local search algorithm
for compacting given PCAs into smaller sizes. Extensive experi-
ments on a large number of real-world, public PCAG instances
showthatthesizesof CAmpactor ’sgeneratedPCAsarearound45%
smaller than the sizes of PCAs constructed by existing state-of-the-
artPCAGalgorithms,indicatingitssuperiority.Also,ourevaluation
con/f_irmsthegeneralityof CAmpactor ,sinceCAmpactor canreduce
the sizesofPCAs generatedbyavarietyofPCAG algorithms.
CCS CONCEPTS
•Softwareanditsengineering →Softwaretestinganddebug-
ging;Search-basedsoftwareengineering ;•Theoryofcomputation
→Randomized local search .
∗ChuanLuois the corresponding authorof thiswork.
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forpro/f_itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe/f_irstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeci/f_icpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 979-8-4007-0327-0/23/12...$15.00
https://doi.org/10.1145/3611643.3616284KEYWORDS
PairwiseTesting, CoveringArray,Local Search, Optimization
ACMReference Format:
QiyuanZhao,ChuanLuo,ShaoweiCai,WeiWu,JinkunLin,HongyuZhang,
andChunmingHu.2023. CAmpactor :ANovelandEﬀectiveLocalSearch
Algorithmfor OptimizingPairwiseCoveringArrays.In Proceedingsofthe
31stACMJointEuropeanSoftwareEngineeringConferenceand Symposium
on the Foundations of Software Engineering (ESEC/FSE ’23), December 3–9,
2023, San Francisco, CA, USA. ACM, New York, NY, USA, 13pages.https:
//doi.org/10.1145/3611643.3616284
1 INTRODUCTION
Theincreasingdemandforcustomizedsoftwareandserviceshasled
toagrowinginterestinhighlycon/f_igurablesystems[ 5,35,47,55,
74,75]. These systems allow users to customize their functionality
by choosing diﬀerent con/f_igurations of options. However, this /f_lex-
ibility also poses challenges forsoftware testing, as the number of
possiblecon/f_igurationscangrowexponentiallywiththenumberof
options. In practice, many real-world, highly con/f_igurable systems
provide users with thousands of options to con/f_igure [ 5,55,62].
Givenahighlycon/f_igurable systemwith1,000options,where each
option has 2 possible values, there could be 21000possible con/f_igu-
rations, which is a huge number to test. Hence, in practice testing
allpossible con/f_igurationsisusually infeasible.
Combinatorialinteractiontesting(CIT)isapracticalandeﬀec-
tivemethodforidentifyingfaultsinhighlycon/f_igurablesystems[ 5].
CITinvolvesconstructing atestsuite( i.e.,asetof con/f_igurations)
of a reasonable size and then using it to detect faults triggered
by interactions of any /u1D461options, where /u1D461is the testing strength
[55,69,93]. In particular, pairwise testing ( i.e.,CIT with /u1D461=2) is
the most common CIT technique [ 62,73], which is less costly than
CIT with larger /u1D461values while still preserving high fault-detecting
ability in practice [ 16,30,39,40,83,94]. For a con/f_igurable system,
apairwisetuplerepresentstheinteractionoftwooptions,andpair-
wisetestingaimstobuildapairwisecoveringarray(PCA)ofthe
givensystem,whichisatestsuitecoveringallpairwisetuples.Itis
crucial to use small-sized PCAs in real-world applications so that a
large amount oftestingeﬀortcould be saved.
81
ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Qiyuan Zhao,Chuan Luo, ShaoweiCai,WeiWu, JinkunLin, Hongyu Zhang,andChunmingHu
In most real-world scenarios, there are also constraints ( e.g.,mu-
tual dependencies and exclusiveness) over con/f_igurable options.
Testcases( i.e.,con/f_igurations)inaPCAmustsatisfyallconstraints
to guarantee the eﬃciency and accuracy of testing [ 76]. This re-
quirement gives rise to the pairwise covering array generation
(PCAG) problem, which aims to generate a minimum-sized PCA
that satis/f_ies all constraints, and remains a challenging problem in
pairwise testing. Actually, highly con/f_igurable systems correspond
tolarge-scaleinstancesofthePCAGproblem.SincethePCAGprob-
lem is recognized as a hard combinatorial optimization problem
[43,71], it is challenging to solve the PCAG problem for highly
con/f_igurable systems,whichurgentlycalls for practical solutions.
TherearethreemajortypesofpracticalPCAGalgorithms, i.e.,
constraint-encoding algorithms ( e.g.,[1,4,31,92,98]), greedy algo-
rithms (e.g.,[8–10,16,37,41–43,85,88,91,95]) and meta-heuristic
algorithms( e.g.,[8,17–19,23,25,27,34,46,47,55,67]).Although
constraint-encoding algorithms can generate PCAs for small-scale
PCAGinstances, theycannot handlelarge-scaleinstances. Greedy
algorithms can eﬃciently generate PCAs for medium-scale PCAG
instances,butthegenerated PCAsareusuallyoflargesizes.Thus,
greedy algorithms are impractical in those application scenarios
with limited testing budget. Compared to constraint-encoding and
greedy algorithms, meta-heuristic algorithms can generate smaller-
sizedPCAs atthe expenseoflong executiontime. However,exist-
ingPCAGalgorithmssuﬀerfromtheseverescalabilitychallenge
[62,77,90].Whenhandlinghighlycon/f_igurablesystemswiththou-
sands of options, a recent study demonstrates that these PCAG
algorithms require a fairly long timeto generatelarge-sized PCAs
(i.e.,constructinglarge-sizedtestsuites),whichwouldgreatlyde-
gradethe eﬃciency intestinghighly con/f_igurable systems[ 62].
Localsearchisaneﬀectivemeta-heuristicsearchparadigmfor
solvinghardcombinatorialoptimizationproblems[ 13,33,50,54,60,
65,81].Manystate-of-the-artmeta-heuristicPCAGalgorithms( e.g.,
AutoCCAG [55],FastCA[46],TCA[47]) are based on local search
[46].Theselocalsearchalgorithmsconsistoftwophases, i.e.,the
initializationphaseandtheoptimizationphase.Intheinitialization
phase, an eﬃcient PCAG algorithm ( e.g.,[16,95]) is activated to
construct an initial PCA in a short time. Then the optimization
phase begins, where the initial PCA gets compacted ( i.e.,its size
gets reduced). Recently, Luo et al.proposed the state-of-the-art
PCAG algorithm dubbed SamplingCA [62], which can generate
PCAsforlarge-scaleinstanceseﬃcientlyandthereforeisagood
candidate in the initialization phase. Although SamplingCA can
generatePCAsofreasonablesizes,itdoesnotexplicitlyincorporate
any optimization technique for reducing the sizes of generated
PCAs,leavingroom for further optimization.
In this work, we propose CAmpactor , a novel and eﬀective local
searchalgorithmdedicatedforcompactingPCAsintheoptimiza-
tion phase. CAmpactor adopts a two-mode local search framework
to optimize the sizes of input PCAs iteratively, and works between
theexploitationmodeandtheexplorationmode.Intheexploitation
mode,CAmpactor conducts optimization to search for a smaller-
sized PCA, while in the exploration mode CAmpactor tends to
explore promising search space. Given a PCA of size /u1D706,CAmpactor
attempts to /f_ind a PCA of size /u1D706−1. If a PCA of size /u1D706−1is found,
thenCAmpactor continuestoseekaPCAwithafurthersmallersize
(e.g.,/u1D706−2).Byrepeatingthisprocedure, CAmpactor cangenerateahighlyoptimizedPCAofsmallersize.Furthermore,wepropose
twonovelandpowerfultechniques( i.e.,assignment-levelforbidden
mechanism and forced patching technique) to further enhance the
eﬀectiveness of CAmpactor andalleviate the scalability challenge.
To evaluate CAmpactor , we conduct extensive experiments on a
largenumberofpubliclyavailablePCAGinstancesencodedfrom
real-worldhighlycon/f_igurablesystems.Ourexperimentspresent
that, when using SamplingCA for initialization, CAmpactor can
generatePCAswitharound45%smallersizesthanthosefromexist-
ingstate-of-the-artPCAGalgorithms( i.e.,SamplingCA ,AutoCCAG ,
FastCAandTCA), indicating the superiority of CAmpactor . Our
results also con/f_irm the eﬀectiveness of core techniques used in
CAmpactor .Further,theresultspresentthegeneralityof CAmpactor ,
sinceCAmpactor can signi/f_icantly reduce the sizes of the PCAs
generated by diﬀerent PCAG algorithms. Our results show that
CAmpactor can eﬀectively mitigate the scalability challenge and
signi/f_icantly advancethe state of the art inpairwisetesting.
Our main contributionsare summarizedas follows.
•We propose CAmpactor , a novel and eﬀective local search
algorithm that can greatly reduce the size of inputPCA.
•To enhance the performance of CAmpactor , we propose two
novel and powerful techniques ( i.e.,assignment-level forbid-
den mechanismandforcedpatchingtechnique).
•Weconductextensiveexperimentstopresentthesuperiority
ofCAmpactor overexistingstate-of-the-artalgorithms.Also,
ourresultsshowtheeﬀectivenessofcoretechniquesused
inCAmpactor ,as well as CAmpactor ’sgenerality.
Potentialimpacttothecommunity: Whenintegratedwith
SamplingCA ,CAmpactor can generate small-sized PCAs eﬃciently.
Compared to existing PCAG algorithms ( e.g., TCA,FastCAand
AutoCCAG ),CAmpactor can save much time in both preparing
PCAsandconductingtestsusingthegeneratedPCAs.Ontheother
hand, CIT has been applied to testing various types of systems
andservice,includingsoftwareAPIs[ 89],securityprotocols[ 64],
programming language applications [ 26], deep learning systems
[14,63],quantumprograms[ 87],andevenmission-criticalsystems
[39]. Another successful story is that recent deployment of CIT
inLGElectronicsexposedcriticalfaultsduringthetestingphase,
thereby avoiding potential /f_inancial damageon tens of millions of
dollars[74].Therefore, CAmpactor mightbringbene/f_itinthefuture
applicationsofCIT andalsothe software testingcommunity.
2 PRELIMINARIES
This section presents importantde/f_initionsandnotations.
2.1 PairwiseCoveringArrayGeneration
Acon/f_igurablesystem, i.e.,asystemundertest (SUT),canbecon/f_ig-
uredby a/f_initesetof options,denotedas /u1D442.Each option /u1D45C/u1D456∈/u1D442is
relatedtoits valuedomain /u1D444/u1D456,a/f_initesetwhere /u1D45C/u1D456cantakediﬀerent
values.Forreal-worldcon/f_igurablesystemsthereusuallyexistsa
setofconstraints on the options [ 76], denoted as /u1D43B, indicating the
allowedcombinationsofvaluesoftheoptionsin /u1D442.Thisworkuses
apair inthe form of (/u1D442,/u1D43B)to represent an SUT.
For an SUT /u1D446=(/u1D442,/u1D43B), atest case, also known as a con/f_igu-
ration, can be considered as a set of |/u1D442|option-value pairs /u1D447=/braceleftbig
(/u1D45C1,/u1D45E1),(/u1D45C2,/u1D45E2),···,(/u1D45C|/u1D442|,/u1D45E|/u1D442|)/bracerightbig, which assigns to each option
82CAmpactor : A Novel andEﬀective LocalSearchAlgorithm forOptimizingPairwise CoveringArrays ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
/u1D45C/u1D456∈/u1D442a value/u1D45E/u1D456∈/u1D444/u1D456. A test suite is a collection of multi-
ple test cases. Similarly, a pairwise tuple is a set of exactly two
option-value pairs /u1D70F={(/u1D45C/u1D456,/u1D45E/u1D456),(/u1D45C/u1D457,/u1D45E/u1D457)}, indicating that the op-
tions/u1D45C/u1D456∈/u1D442,/u1D45C/u1D457∈/u1D442takethevalues /u1D45E/u1D456∈/u1D444/u1D456,/u1D45E/u1D457∈/u1D444/u1D457,respectively.
Apairwisetuple /u1D70Fiscoveredbyatestcase /u1D447if/u1D70F⊆/u1D447,whichmeans
thatthevaluesofthetwooptionsin /u1D70Farethesamewiththoseones
in/u1D447. More generally, a pairwise tuple /u1D70Fiscoveredby a test suite
if/u1D70Fiscoveredbyatleastonetestcaseinthattestsuite.Foratest
case/u1D447and a pairwise tuple /u1D70F={(/u1D45C/u1D456,/u1D45E/u1D456),(/u1D45C/u1D457,/u1D45E/u1D457)}, we de/f_ine the
notation/u1D447◁/u1D70Fto denote a new test case /u1D447′, satisfying that a) /u1D447′
covers/u1D70Fand b) for any option /u1D45Cother than /u1D45C/u1D456and/u1D45C/u1D457, the values of
option/u1D45Cin/u1D447and/u1D447′arethesame.Thatis, /u1D447◁/u1D70Fcanbeunderstood
as anewtest casethat overrides /u1D447by/u1D70F.
Duetotheexistenceofconstraints,foranSUT /u1D446=(/u1D442,/u1D43B),atest
case/u1D447isvalidif/u1D447satis/f_ies all constraints in /u1D43B; otherwise ( i.e.,/u1D447
violates at least one constraint in /u1D43B),/u1D447isinvalid. A pairwise tuple
/u1D70Fisvalidif there exists at least one valid test case covering /u1D70F. In
practice,invalidtestcaseswouldpossiblyincurincorrecttesting
results, soitiscrucial to ensure that alltest casesare valid.
Given an SUT /u1D446=(/u1D442,/u1D43B), apairwise covering array (PCA) is
a test suite ( i.e.,a set of valid test cases), which covers all valid
pairwisetuples.Foratestsuite /u1D434,if/u1D434isnotaPCA,then /u1D434iscalled
anon-PCA test suite . Also, a PCA or a test suite can be represented
asamatrix,whereeachrowisavalidtestcase,andeachentryis
calledcellinthiswork.Particularly,foratestsuite /u1D434,U(A)denotes
the collection ofvalid pairwisetuples that are not coveredby /u1D434.
Asakeyprobleminpairwisetesting,the pairwisecoveringarray
generation (PCAG)problemisto/f_indaminimum-sizedPCAforthe
givenSUT.ItisrecognizedthatthePCAGproblemisachallenging
combinatorial optimization problem [ 43,71], which urgently calls
for practical solutions.
Remark: Withoutlossofgenerality,followingrecentstudieson
highly con/f_igurable systems [ 5,60,62], this work concentrates on
thescenariowhereeachoptiontakesBooleanvalues;thatis,the
value domains of all options are {0,1}. Actually, it is well acknowl-
edgedthatthegeneralscenario,wherethevaluedomainofeach
option isa set of multiplevalues, canbe feasibly transformed into
the binary scenario studied in this work [ 5,60,62]. Furthermore,
thePCAGinstancesadoptedinthisworkareofbinaryscenario,and
all of them are transformed from the general scenario and encoded
frompractical,highlycon/f_igurablesystems.Hence,itiscrucialto
study the binary scenario inPCAG solving.
2.2 Boolean Formulae
Followingrecentwork[ 2,5,6,45,60,62,68,82],inthisworkhighly
con/f_igurable systems are modeled as Boolean formulae, whose
necessary notations are introducedas follows.
Boolean variables are atoms of Boolean formulae. For a Boolean
variable/u1D465,aliteralof/u1D465iseither/u1D465itselforitsnegation ¬/u1D465.ABoolean
formulacanbeexpressedin conjunctivenormalform (CNF),i.e.,a
conjunction of clauses, where a clauseis a disjunction of literals.
For a formula /u1D439in CNF, we use V(F)andC(F)to denote the set of
allBoolean variables andthe setofallclauses in /u1D439,respectively.
GivenaBooleanvariable /u1D465/u1D456,itsvalue/u1D463/u1D456iseither0or1.Thevalues
of literals /u1D465/u1D456and¬/u1D465/u1D456are/u1D463/u1D456and1−/u1D463/u1D456, respectively. An assignment
of a formula /u1D439is a mapping /u1D6FC:/u1D449(/u1D439)→{0,1}, which assigns aBoolean value to each variable. Given an assignment /u1D6FC, a clause
/u1D450issatis/f_iedif at least one literal in /u1D450evaluates to be 1 under /u1D6FC;
otherwise, /u1D450isunsatis/f_ied . Given an assignment /u1D6FC, if all clauses are
satis/f_ied under /u1D6FC, then/u1D6FCis asolution(i.e.,a satisfying assignment);
otherwise, /u1D6FCisan unsatisfying assignment.
GivenanSUT /u1D446=(/u1D442,/u1D43B),wecantransform /u1D446intoaformula /u1D439in
CNF such that /u1D442and/u1D43Bcorrespond to V(F)andC(F), respectively.
Throughthisway,avalid testcaseof /u1D446isindeedasolution( i.e.,a
satisfyingassignment)of /u1D439,andapairwisetupleof /u1D446isasetoftwo
literalsof /u1D439(e.g.,thepairwisetuple{(/u1D45C1,0),(/u1D45C2,1)}correspondsto
the setoftwoliterals {¬/u1D4651,/u1D4652}).
Given an SUT /u1D446and its corresponding formula /u1D439, the PCAG
problemaimsto/f_indasetof /u1D439’ssolutionssuchthatallvalidpair-
wise tuples of /u1D446are covered. In fact, seeking one solution for a
formula in CNF is known as the in/f_luential, propositional satis/f_i-
ablity (SAT) problem [ 7], which is a challenging problem in theory.
Hence,tosolvethePCAGproblemeﬀectively,apracticalSATsolver
isindispensable.
A recently proposed SAT algorithm dubbed ContextSAT [62]
showsitshighperformanceineﬀectivelygeneratingvalidtestcases
forhighlycon/f_igurablesystems. ContextSAT [62]isdevelopedbased
onMiniSAT [22],awell-knownandeﬀectiveSATsolver.Theinputs
ofContextSAT areasfollows:a) /u1D439:aBooleanformulainCNF;b) /u1D43F:a
setofliterals;c) /u1D6FC:anassignmentof /u1D439.Asdescribedin ContextSAT ’s
literature [ 62], apart from these inputs, running ContextSAT needs
todetermineavariableorderof V(F),whichguidesthedirection
of the backtracking process. In this work, the variable order of
ContextSAT is the one determined by MiniSAT [22]. In this setting,
ContextSAT targets to seek a solution of /u1D439, which is similar to /u1D6FC
(i.e.,many variables take the same values in ContextSAT ’s solution
and/u1D6FC) and guarantees that all literals in /u1D43Fevaluate to be 1. We use
ContextSAT(/u1D439,/u1D43F,/u1D6FC)todenote ContextSAT ’soutputsolution.Partic-
ularly,givenavalidpairwisetuple /u1D70F,ContextSAT(/u1D439,/u1D70F,/u1D6FC)denotesa
satisfyingassignment of /u1D439that covers /u1D70Fandissimilar to /u1D6FC.
3 LOCAL SEARCHPCAG ALGORITHMS
In thissection, we describethegeneral frameworkoflocal search
PCAG algorithms, anddiscuss their limitations.
3.1 GeneralFrameworkofLocalSearch
As aforementioned, compared to other types of PCAG algorithms,
meta-heuristic PCAG algorithms are more eﬀective in minimizing
thesizeofPCA.Also,state-of-the-artmeta-heuristicPCAGalgo-
rithms(including AutoCCAG [55],FastCA[46]andTCA[47])are
basedonthelocalsearchparadigm[ 46],andlocalsearchalgorithms
haveachievedeﬀectivenessinPCAGsolving.ApartfromthePCAG
problem,localsearchhasexhibitedgreatsuccessinsolvingvarious
hardcombinatorialoptimizationproblems[ 11,13,15,21,28,33,48–
54,56–61,65,79,81].Thus,CAmpactor isalsobasedonlocalsearch.
State-of-the-artlocalsearchPCAGalgorithms( e.g.,AutoCCAG ,
FastCAandTCA)consistoftwophases, i.e.,initializationphaseand
optimizationphase.Intheinitializationphase,aneﬃcientPCAG
algorithm is activated ( e.g.,[16,95]) to construct an initial PCA.
Then, local search switches to the optimization phase that takes
the initial PCA as inputand optimizes the input PCA ( i.e.,reduces
the size ofPCA).
83ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Qiyuan Zhao,Chuan Luo, ShaoweiCai,WeiWu, JinkunLin, Hongyu Zhang,andChunmingHu
Algorithm 1: Optimization Phase ofLocalSearch forPCAG
Input:/u1D46D:Booleanformulain CNF;
/u1D468:the initial PCAof /u1D439;
Output:/u1D468∗:the optimized PCAof /u1D439;
1/u1D434∗←/u1D434;
2whilenoterminationcriterion is met do
3if/u1D434is a PCA of /u1D439then
4 /u1D434∗←/u1D434;
5 Removean assignment from /u1D434;
6 continue ;
7Perform oneoperation on /u1D434;
8return/u1D434∗;
Thegeneralframeworkoftheoptimizationphaseoflocalsearch
PCAG algorithms is outlined in Algorithm 1. The output of this
phase,denotedby /u1D434∗,isthesmallest-sizedPCAfoundduringthe
optimization phase, and is updated with the initial PCA /u1D434in the
beginning(Line 1inAlgorithm 1).Inthisphase,localsearchper-
forms search steps iteratively until the termination criterion is met
(Line2in Algorithm 1). In each iteration ( i.e.,search step), local
search/f_irstcheckswhether /u1D434isaPCA(Line 3inAlgorithm 1).Ifso,
local search updates /u1D434∗accordingly, and reduces the size of /u1D434by 1
through removing an assignment ( i.e.,a test case) from /u1D434, which
possibly makes /u1D434no longer be a PCA (Line 4-6in Algorithm 1).
Otherwise( i.e.,/u1D434isnotaPCA),localsearchtriestomake /u1D434become
a PCA by performing one operation on /u1D434(Line7in Algorithm
1).1Whentheterminationcriterionismet,localsearchstopsand
outputs/u1D434∗(Line8inAlgorithm 1).
Themainideaoftheoptimizationphaseissummarizedasfol-
lows: local search aims to seek a PCA of a speci/f_ic size /u1D706; once a
/u1D706-sizedPCAisfound,thenlocalsearchtriesto/f_indaPCAofsize
/u1D706−1.Hence, thesize of /u1D434∗isdecreasing duringthe search, and /u1D434∗
isessentiallythe minimum-sizedPCA that local searchcan /f_ind.
3.2 LimitationsofExistingLocalSearch
As introduced in Section 1, existing PCAG algorithms, including
local search ones, suﬀer from the severe scalability challenge. In
particular, when dealing with highly con/f_igurable systems with
thousandsofoptions,arecentempiricalstudypresentsthatexisting
state-of-the-art local search algorithms fail to generate PCAs of
small sizes [ 62]. Hence, before introducing CAmpactor , we identify
twoissuesthatmakeexistinglocalsearchalgorithmssuﬀerfrom
the scalability challenge,anddiscuss theirpossible solutions.
3.2.1 CyclingIssue. Inthecontextoflocalsearchforcombinato-
rial optimizationproblems, the cyclingissue[ 70], referringto the
circumstance where local search stagnates in a local part of search
space,isamajorweaknessoflocalsearch,andseverelydegrades
the performance oflocal search[ 12].
To handle the cycling issue, it is advisable to equip local search
witheﬀectiveforbiddenmechanisms.Actually,state-of-the-artlo-
cal search PCAG algorithms [ 46,47,55] adopt the well-known
forbiddenmechanism, i.e.,cell-leveltabumechanism[ 47],tohan-
dlethecyclingissue.Inparticular,thecell-leveltabumechanism
1In thiswork,performing oneoperationon /u1D434meansmodifyinganassignment /u1D6FC∈/u1D434
viachanging the values of cells in /u1D6FC.prohibitssuchoperationsaimingtomodifycellswhosevalueshave
been changed recently [ 47]. When solving large-scale PCAG in-
stances, since there are a large number of candidate operations,
suchcell-leveltabumechanismcanonlyprohibitfewofthem,so
itsforbiddenstrengthisrelativelyweak.However,itisknownthat,
for a forbidden mechanism, weak forbidden strength ( i.e.,only few
operationsareimpermissible)wouldstillmakelocalsearchsuﬀer
from the cycling issue [ 49,52]. Unfortunately, in the context of
PCAGsolving,littleattentionhasbeenpaidonenhancingforbid-
den strategies. Thus, an eﬀective solution to the cycling issue is to
strengthenforbidden mechanisms.
3.2.2 HinderingIssue. Givenanon-PCAtestsuite /u1D434,ineachsearch
step existing state-of-the-art local search PCAG algorithms ( e.g.,
AutoCCAG [55],FastCA[46]andTCA[47])performaminoroper-
ation on/u1D434, where at most two cells in an assignment /u1D6FC∈/u1D434get
theirvalues changed.Particularly,ineachsearchstep,existinglo-
calsearchPCAGalgorithmsselectoneuncoveredpairwisetuple
/u1D70F∈/u1D448(/u1D434)randomly, and attempt to cover /u1D70Fby performing one
minor operation on /u1D434while preserving the validity of test cases in
/u1D434. However, recent studies presentthat practical SUTs have many
constraintsoveroptions( e.g.,thewell-knownFreeBSDoperating
systemhas62,183constraints)[ 5,60,62].Duetotheexistenceof
complexconstraints,itisfrequentlyinfeasibletocover /u1D70Fviaper-
forming only one minor operation on /u1D434while keeping that all test
cases in/u1D434are valid. This hindering issue greatly prevents local
searchfrom being eﬀective.
To alleviate the hindering issue, rather than performing a minor
operationinasearchstepasexistinglocalsearchPCAGalgorithms
do,itisdesirabletoperformamajoroperation,wheremorethan
twocellsinanassignment /u1D6FC∈/u1D434gettheirvalueschanged,tocover
/u1D70Finasearchstep whilesatisfyingallconstraints.
4OUR PROPOSED CAMPACTOR ALGORITHM
In thissection, we propose CAmpactor , a novel and eﬀective local
searchalgorithm for reducing the size of given PCA.
4.1 OverallDesign of CAmpactor
Based on the general framework of local search PCAG algorithms
outlinedinAlgorithm 1,wepropose CAmpactor thatisdedicatedto
reducingthesizeofthegivenPCA.Theoveralldesignof CAmpactor
ispresentedinAlgorithm 2.CAmpactor requirestwoinputs:a) /u1D439,a
Boolean formula in CNF that is transformed from an SUT and b)
/u1D434, the initial PCA of /u1D439generated in the initialization phase. The
outputof CAmpactor is/u1D434∗,an optimizedPCA of /u1D439.
AccordingtothegeneralframeworkinAlgorithm 1,thereare
three essential components: a) the termination criterion, b) the
strategy to select the assignment to be removed from /u1D434when/u1D434is
a PCA, and c) the mechanism to determine what operation to be
performed on /u1D434. We specify and introduce these components in
CAmpactor as follows.
4.1.1 TerminationCriterion. ForCAmpactor ,wedesignabudget-
aware termination criterion, which works as follows. In the be-
ginning,thesearchbudgetis initialized asalarge-valuedpositive
integer/u1D6FE(Line2inAlgorithm 2).Onceasearchstep( i.e.,aniter-
ation)hasbeenconducted,thenthesearchbudgetdecreasesby1
84CAmpactor : A Novel andEﬀective LocalSearchAlgorithm forOptimizingPairwise CoveringArrays ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Algorithm 2: TheCAmpactor Algorithm
Input:/u1D46D:Booleanformulain CNF;
/u1D468:the initial PCAof /u1D439;
Output:/u1D468∗:the optimized PCAof /u1D439;
1/u1D434∗←/u1D434;
2budget←/u1D6FE;
3whilebudget>0do
4if/u1D434is a PCA of /u1D439then
5 /u1D434∗←/u1D434;
6 Removethe assignment withthe smallest lossfrom /u1D434;
7 budget←/u1D6FE;
8 continue ;
9budget←budget−1;
10/u1D70F←arandomuncovered pairwisetuple in U(A);
11/u1D445={(/u1D6FC,/u1D6FC◁/u1D70F)|/u1D6FC∈/u1D434,age(/u1D6FC)>/u1D6FF,/u1D6FC◁/u1D70Fis valid};
12if/u1D445≠∅then
13(/u1D6FC∗,/u1D6FC∗◁/u1D70F)←operation withthe largest pro/f_it in /u1D445;
14 Perform operation (/u1D6FC∗,/u1D6FC∗◁/u1D70F)on/u1D434;
15else ifwithprobability /u1D713then
16 /u1D440={(/u1D6FC,ContextSAT(/u1D439,/u1D70F,/u1D6FC))|/u1D6FC∈/u1D434,age(/u1D6FC)>/u1D6FF};
17(/u1D6FC∗,ContextSAT(/u1D439,/u1D70F,/u1D6FC∗))←operation withthe largest
pro/f_it in/u1D440;
18 Perform operation (/u1D6FC∗,ContextSAT(/u1D439,/u1D70F,/u1D6FC∗))on/u1D434;
19else
20 foreachcell/u1D452of/u1D434witha random order do
21 /u1D6FC←the assignment wherecell /u1D452locates;
22 /u1D6FC′←/u1D6FCwithcell/u1D452modi/f_ied;
23 if/u1D6FC′is a satisfyingassignment then
24 Perform operation (/u1D6FC,/u1D6FC′)on/u1D434;
25 break;
26return/u1D434∗;
(Line9inAlgorithm 2).Particularly,whenever /u1D434isaPCA,thenthe
searchbudget isresetto /u1D6FE(Line7inAlgorithm 2).Duringthe local
searchprocess,oncethesearchbudgetreaches0,thentheentire
searchprocessof CAmpactor terminates(Line 3inAlgorithm 2).
According to our budget-aware termination criterion described
above,CAmpactor terminatesifandonlyifitdoesnot/f_indasmaller-
sizedPCAinconsecutive /u1D6FEsearchsteps.Actually, /u1D6FEisaninteger-
valuedhyper-parameterin CAmpactor ,andadjusting /u1D6FEcanbalance
the eﬃciency and eﬀectiveness of CAmpactor . With a large-valued
/u1D6FE,CAmpactor takeslongerrunningtimebutoutputsasmaller-sized
PCA. Conversely, with a small-valued /u1D6FE,CAmpactor terminates
quickly, while the generated PCA is possibly of larger size. The
eﬀectof/u1D6FEwillbe investigatedempirically inSection 6.3.
4.1.2 RemovalStrategy. Beforedescribingtheremovalstrategy,we
/f_irstde/f_inethe lossofassignment,akeyconceptin CAmpactor .For
a PCA/u1D434, the loss of anassignment /u1D6FC∈/u1D434is the numberof covered
pairwisetuplesthatwouldbecomeuncovered, i.e.,theincrement
of|U(A)|,if/u1D6FCisremovedfrom /u1D434.
Intuitively,inthesearchprocess,ifthere existmoreuncovered
tuples,thenmoreoperationsneedtobeperformedon /u1D434tomake/u1D434
becomeaPCA.Hence, CAmpactor adoptsagreedyremovalstrategy,
whichworksasfollows:once /u1D434becomesaPCA, CAmpactor selectsthe assignment /u1D6FC∈/u1D434with the smallest loss to be removed from /u1D434
(Line6inAlgorithm 2).
4.1.3 Operation Determination Method. The operation determina-
tion method is the most important component in CAmpactor , since
itdirectlyguides CAmpactor ’ssearchdirectionandthusitseﬀec-
tivenessgreatlyaﬀectsthesizeofoutputPCA.Infact,two-mode
localsearchalgorithms,whichworkbetweentheexploitationmode
andtheexplorationmode,haveachievedgreatsuccessinsolving
various combinatorial optimization problems [ 33,44,49,50,70].
Therefore, CAmpactor follows the two-mode design. Generally, in
the exploitation mode local search tends to optimize the objec-
tive, while in the exploration mode local search targets to diver-
sify thesearch direction. More precisely,intheexploitation mode
CAmpactor prefers to conduct those operations that can reduce
the number of uncovered pairwise tuples, i.e.,trying to make /u1D434be-
come a PCA (Lines 10–18in Algorithm 2). In the exploration mode
CAmpactor aimstoperformsuchoperationsthatcanbetterexplore
the promising search space (Lines 20–25in Algorithm 2). In this
way,CAmpactor canachieve agood balance between exploitation
and exploration. The technical details of both exploitation mode
andexplorationmode are describedinthe following subsections.
4.2 ExploitationMode
Asaforementioned,intheexploitation mode CAmpactor conducts
operations to reduce the number of uncovered pairwise tuples ( i.e.,
decreasing|U(A)|). It is advisable to design the exploitation mode
asfollows:/f_irst,anuncoveredpairwisetuple /u1D70F∈U(A)israndomly
selected, and then an operation, which modi/f_ies an assignment
/u1D6FC∈/u1D434toanothervalidassignment /u1D6FC′thatcovers /u1D70F,isperformed.
Thus,inthisworkanoperationcanbe expressedbya combination
of two assignments (/u1D6FC,/u1D6FC′), which means modifying /u1D6FCto/u1D6FC′in
/u1D434. Based on this design, at least one uncovered tuple ( i.e.,/u1D70F) is
ensuredtobecovered,soitispossiblethat |U(A)|(i.e.,thenumber
ofuncoveredpairwisetuples)could be reduced.
Since there usually exist more than one candidate operation
covering/u1D70F,itisnecessarytoutilizeametrictoassessthebene/f_itof
anoperation,suchthatthebestcandidateoperationcanbeselected.
Thus,weadoptametriccalled pro/f_ittoassessanoperation’sbene/f_it.
Given anoperation (/u1D6FC,/u1D6FC′),thepro/f_it of the operation,denotedby
pro/f_it(/u1D6FC,/u1D6FC′),isthedecrementinthenumberofuncoveredpairwise
tuples, if theoperation is performed ( i.e.,/u1D6FCismodi/f_ied to /u1D6FC′in/u1D434);
particularly, pro/f_it(/u1D6FC,/u1D6FC′)is calculated as the number of uncovered
pairwise tuples becoming covered minus the number of covered
tuples becoming uncovered, if operation (/u1D6FC,/u1D6FC′)is taken. Clearly,
performingan operation withlarger pro/f_it bringsmore bene/f_it.
4.2.1 Assignment-level Forbidden Mechanism. It is recognized that
the cycling issue greatlydegrades the performance of local search,
andadoptingforbiddenstrategiescanreducethenegativeconse-
quence.Infact,existingstate-of-the-artPCAGalgorithms[ 46,47,
55]adoptacell-leveltabumechanism[ 47],whichpreventsmodi-
fyingseveralcellsthathavebeenchangedrecently.Asdiscussed
in Section 3.2.1, due to its weak forbidden strength, such cell-level
tabumechanismisineﬀectiveinhandlingthecyclingissue.Forthe
empirical evidence,readers can refer to Section 6.2.
85ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Qiyuan Zhao,Chuan Luo, ShaoweiCai,WeiWu, JinkunLin, Hongyu Zhang,andChunmingHu
ForCAmpactor we propose a novel, assignment-level forbid-
denmechanismwithstrongforbiddenstrength.Beforeintroduc-
ing our new forbidden mechanism, we de/f_ine an important no-
tion,i.e.,the age of assignment. Given an assignment /u1D6FC∈/u1D434, the
age of/u1D6FC, denoted by age(/u1D6FC), is the number of search steps that
have been conducted since the last modi/f_ication of /u1D6FC. Particu-
larly, our assignment-level forbidden mechanism is designed to
strictly prohibit such an operation which aims to modify an as-
signment /u1D6FCthat has been changed in the last /u1D6FFsearch steps ( i.e.,
/u1D44E/u1D454/u1D452(/u1D6FC)≤/u1D6FF),where/u1D6FFisapositiveinteger.Followingournewfor-
bidden mechanism, once the uncovered pairwise tuple /u1D70F∈U(A)is
selected,CAmpactor constructsacandidateset /u1D445ofoperationsas
/u1D445={(/u1D6FC,/u1D6FC◁/u1D70F)|/u1D6FC∈/u1D434,age(/u1D6FC)>/u1D6FF,/u1D6FC◁/u1D70Fisvalid}, recalling that
theoperator◁isde/f_inedinSection 2.1,and/u1D6FC◁/u1D70Fcanbeunderstood
as an assignment that overrides /u1D6FCby/u1D70F. ThenCAmpactor adopts
agreedyoperationdeterminationmethod:afterthecandidateset
/u1D445is constructed, CAmpactor selects and performs the operation
(/u1D6FC∗,/u1D6FC∗◁/u1D70F)withthe largestpro/f_it in /u1D445.
Whensolvingalarge-scalePCAGinstance(whichindicatesthat
anassignmenthasalargenumberofcells),comparedtotheexisting
cell-level tabu mechanism,our assignment-level forbiddenmecha-
nismcanprohibitmoreoperations,andthushasstrongerforbidden
strength. In addition, /u1D6FFis a hyper-parameter in CAmpactor that
controlstheforbiddenstrength,anditseﬀectwillbeanalyzedin
Section6.3.
4.2.2 Forced Patching Technique. In fact, the operation selected by
our forbidden mechanism is a minor operation where an assign-
ment/u1D6FC∗is modi/f_ied to /u1D6FC∗◁/u1D70F. However, as described in Section
3.2.2, due to the existence of complex constraints, the hindering
issue frequently causes that no feasible, minor operation can be
performedtocovertheselected,uncoveredpairwisetuple /u1D70F,which
is a crucial problem that prevents existing local search PCAG algo-
rithmsfrombeingeﬀective.Thus,thecandidateset /u1D445canbeempty,
as afrequent scenario.
Once/u1D445is empty, a natural solution is to abandon covering /u1D70F,
and instead to take a minor operation that does not violate any
constraint,soastocontinuethesearchprocess.Thatis,thenatural
solutiondirectlyignoressuchcrucialprobleminthecurrentsearch
step. However,since /u1D70Fcannot be covered by any minoroperation,
thesameproblemwouldthereforeoccurinsubsequentsearchsteps.
Hence, an advisable solution is to perform a major operation to
make/u1D434cover/u1D70Fbyforce.Hereweneedtoaddressthecoretechnical
challenge, i.e.,how to /f_ind appropriate operations that cover /u1D70Fand
meanwhilemake allconstraintssatis/f_ied.
To address this challenge, we propose an eﬀective forced patch-
ing technique, which leverages the power of a SAT solver, since
aSATsolvercan/f_indasatisfyingassignmentthatcoversagiven
pairwise tuple for a given formula. As described in Section 2.2,
ContextSAT [62] is an eﬀective SAT solver; also, given a formula /u1D439
inCNF,avalidpairwisetuple /u1D70Fandanassignment /u1D6FCof/u1D439asinputs,
ContextSAT canreturnasatisfyingassignmentof /u1D439thatcovers /u1D70F
and is similar to /u1D6FC, denoted by ContextSAT(/u1D439,/u1D70F,/u1D6FC). Since we aim
to/f_indsuchoperationsthatmodifyanassignment /u1D6FC∈/u1D434tocover/u1D70F
andmeanwhiletosatisfyallconstraintsappearingin /u1D439,anadvisable
solution isas follows: for eachassignment /u1D6FC∈/u1D434withage(/u1D6FC)>/u1D6FF,
acandidateoperation (/u1D6FC,ContextSAT(/u1D439,/u1D70F,/u1D6FC))canbeconstructed.Actually,apartfrommaking /u1D434cover/u1D70F,anotherimportantobjective
istomake /u1D434covermorepairwisetuples.Thankstotheproperty
that both assignments /u1D6FCandContextSAT(/u1D439,/u1D70F,/u1D6FC)are similar, it is
clear that many pairwise tuples exclusively covered by /u1D6FCcan be
preservedifthe operation (/u1D6FC,ContextSAT(/u1D439,/u1D70F,/u1D6FC))is performed.In
a nutshell, we can construct a candidate set /u1D440of major operations,
i.e.,/u1D440={(/u1D6FC,ContextSAT(/u1D439,/u1D70F,/u1D6FC))|/u1D6FC∈/u1D434,age(/u1D6FC)>/u1D6FF}.
Once the candidate set /u1D440of major operations is constructed,
from the candidate set /u1D440,CAmpactor selects and performs the
bestoperation(/u1D6FC∗,ContextSAT(/u1D439,/u1D70F,/u1D6FC∗))with the largestpro/f_it.It
is clear that activating the forced patching technique would call
theContextSAT solver multiple times. Since calling ContextSAT
requires a certain amount of computation time, in order to keep
theeﬃciencyof CAmpactor ,we activatetheforced patchingtech-
nique with a /f_ixed probability /u1D713. That is, with a /f_ixed probability /u1D713,
CAmpactor callstheforcedpatchingtechnique;otherwise( i.e.,with
a probability 1−/u1D713),CAmpactor works in the exploration mode,
which will be introducedin the nextsubsection.Here /u1D713isa real-
valuedhyper-parameterof CAmpactor ,anditsvaluedomainranges
from0to 1.Since /u1D713plays a key roleinbalancing theeﬀectiveness
andeﬃciencyof CAmpactor ,itseﬀectwillbestudiedinSection 6.3.
4.3 Exploration Mode
It is clear that the exploitation mode of CAmpactor aims to modify
the test suite /u1D434in a greedy manner. However, existing studies
presentthatonlyadoptinggreedystrategiescouldmakelocalsearch
get stuck in a small part of search space [ 3,32,66]. Thus, it is
desirable to incorporateexplorationmode intolocal search.
The task of CAmpactor ’s exploration mode is to explore the
promising part of search space. Also, in the context of local search
for solving combinatorial optimization problems, applying ran-
domizedstrategiesintheexplorationmodecanhelplocalsearch
better explore promising search space [ 33,44,49,50,70]. Based on
thisdesign,intheexplorationmode CAmpactor worksasfollows.
CAmpactor tries to traverse all cells of /u1D434with a random order. For
eachcell /u1D452of/u1D434,CAmpactor selectstheassignment /u1D6FCwherecell /u1D452
locates,andtriestomodifycell /u1D452in/u1D6FC,resultinginanewassignment
/u1D6FC′. Once/u1D6FC′is a satisfying assignment, CAmpactor performs the
minoroperation(/u1D6FC,/u1D6FC′)on/u1D434,andthenterminatesitsexploration
mode. Through this way, CAmpactor is able to generally perform a
random,minoroperation.
4.4 Discussions
Here,weconcludehow CAmpactor handlesthecyclingissueand
the hindering issue, and also we discuss the novelties of forced
patchingtechniqueandassignment-level forbidden mechanism.
CAmpactor ’ssolutiontothecyclingissue: InSection 4.2.1,
CAmpactor utilizesanovel,assignment-levelforbiddenmechanism,
which has stronger forbidden strength than existing cell-level tabu
mechanism.AsdiscussedinSection 3.2.1,forbiddenmechanisms
with strong forbidden strength can tackle the cycling issue. There-
fore,comparedtoexistinglocalsearchalgorithmsthatadoptthe
cell-leveltabumechanism, CAmpactor canbetteralleviatethecy-
clingissuethroughour assignment-level forbidden mechanism.
CAmpactor ’ssolution to the hinderingissue: From Section
3.2.2, performing major operations can help mitigate the hindering
86CAmpactor : A Novel andEﬀective LocalSearchAlgorithm forOptimizingPairwise CoveringArrays ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
issue. Compared to existing local search PCAG algorithms that
generally perform minor operations, CAmpactor can better handle
the hindering issue, through complementing the minor operations
withappropriatemajoroperations,whicharedeterminedbyour
forcedpatchingtechnique(as introducedinSection 4.2.2).
As discussed in Section 3.2, both cycling issue and hindering
issue cause existing local search algorithms suﬀer from the scal-
ability challenge. Since CAmpactor can tackle both issues more
eﬀectivelythan existing localsearch algorithms, CAmpactor is able
tobetteralleviatethescalabilitychallenge,whichiscon/f_irmedby
our evaluation presentedinSection 6.
Discussiononthenoveltyofeachcoretechnique: Asdis-
cussedabove, we propose to mitigate the hindering issuethrough
the novel forced patching technique. Its originality is underscored
bythe innovative utilizationofaSATsolver( i.e.,ContextSAT )to
forcibly cover a pairwise tuple and avoid losing many other al-
ready covered pairwise tuples at the same time, which is funda-
mentallydiﬀerentfromotherlocalsearchPCAGalgorithms( e.g.,
TCA,FastCAandAutoCCAG ). Moreover, due to the existence of
major operations brought by the forced patching technique, we
correspondinglymakeanewimprovementontheexistingcell-level
tabumechanismbyelevatingtheobjectsofprohibitedoperationsto
thelevelofassignments( i.e.,testcases),resultingintheassignment-
level forbidden mechanism.
5 EXPERIMENTALPRELIMINARIES
This section describes the experimental preliminaries of this work.
5.1 PublicPCAG Instances
In our experiments, we adopt a collection of 124 public PCAG
instances.EachPCAGinstanceisderivedfromapractical,highly
con/f_igurablesystem,andisencodedasaBooleanformulainCNF.
ThesePCAGinstancesareoriginallypresentedbyBaranov etal.[5],
andhavebeenbroadlyevaluatedinrecentstudiesontestinghighly
con/f_igurable systems [ 5,36,45,60,62,72,77,78]. For all PCAG
instances, the numbers of options range from 94 to 11,254, and the
numbers of constraints vary from 190 to 62,183. To help readers
better reproduce our experiments, all adopted PCAG instances and
theinformationofeachinstance( i.e.,thenumbersofoptionsand
constraints)are publiclyavailable inour publicrepository.2
5.2 State-of-the-art PCAG Algorithms
In thiswork, CAmpactor iscomparedagainst fourstate-of-the-art
PCAGalgorithms, i.e.,SamplingCA [62],AutoCCAG [55],FastCA
[46]andTCA[47], whichare describedas follows.
SamplingCA [62]isarecentlyproposed,samplingbasedPCAG
algorithm, and represents the current state of the art in solving
thePCAGproblem.The experimentsreportedinthe literature[ 62]
show that SamplingCA performs much better than all other PCAG
algorithms(including AutoCCAG ,FastCAandTCA)whendealing
with many highly con/f_igurable systems. The implementation of
SamplingCA ispubliclyavailable.3
AutoCCAG [55]isanadvancedapproachbasedonautomated
algorithmoptimization.Assummarizedintheliterature[ 55],the
2https://github.com/chuanluocs/CAmpactor
3https://github.com/chuanluocs/SamplingCAperformanceof AutoCCAG is muchbetterthanthat of otherwell-
knownmethods(including CASA[23,24],TCA[47]andCHiP[69])
on many real-world instances. The source code of AutoCCAG is
obtainedfrom its authors[ 55].
FastCA[46]isaneﬀectivemeta-heuristicalgorithm.Asreported
in the literature [ 46],FastCAexhibits better performance than a
variety of eﬀective algorithms (including TCA,CASA,ACTS[95]
andHHSA[34])onextensiveapplicationinstances.Thesourcecode
ofFastCAcan be obtainedonline.4
TCA[47] is a high-performance meta-heuristic algorithm. As
demonstrated in the literature [ 47],TCAgreatly reduces the size of
PCAscomparedtoanumberofin/f_luentialalgorithms(including
CASA,ACTSandCascade[98])onplentyofpracticalinstances.The
implementationof TCAispubliclyavailable online.5
Also, we conduct experiments to measure the performance of
four other in/f_luential PCAG algorithms, i.e., HHSA6[34],CASA7
[23,24],ACTS8[95]andCTLog9[1].SinceCTLogincludesimple-
mentations of multiple algorithms,we test CTLogusing the latest
published algorithm called MaxSAT MCAC [1] that is integrated
intoCTLog. Our evaluationresults show that HHSA,CASA,ACTS
andCTLogfail to construct PCAs for the majority of the testing
instances.Tosavespace,wedonotreporttheirresultsinthispaper.
Forthefullresultsof HHSA,CASA,ACTSandCTLog,readerscan
refer to our publicrepository.2
5.3 Research Questions
This work aims to advance the state of the art in solving the PCAG
problem.ThetargetofPCAGistoreducethesizeofgeneratedPCA,
soourexperimentsfocusonminimizingthesizeofgeneratedPCA.
We aim to answer the following research questions(RQs).
RQ1. IsCAmpactor able to generate smaller-sized PCAs
than its state-of-the-artcompetitors?
In this RQ, we compare CAmpactor against four state-of-the-art
PCAGalgorithms, i.e.,SamplingCA ,AutoCCAG ,FastCAandTCA
onavarietyofpublicPCAG instances.
RQ2.Doeseachcoretechniqueof CAmpactor contribute
to theperformanceimprovement of CAmpactor ?
In this RQ, we conduct extensive experiments to analyze the
eﬀectiveness of all core algorithmictechniques of CAmpactor ,i.e.,
assignment-levelforbiddenmechanism(inSection 4.2.1)andforced
patchingtechnique(inSection 4.2.2).
RQ3.Howdoeseachhyper-parameterof CAmpactor im-
pact theeﬀectiveness of CAmpactor ?
In this RQ,we conduct empirical evaluation to explore how the
settingsofall CAmpactor ’shyper-parameters, i.e.,/u1D713,/u1D6FFand/u1D6FE,impact
the eﬀectiveness of CAmpactor .
RQ4.Can CAmpactor furtherreducethesizesofPCAsthat
are generated by diﬀerentPCAG algorithms?
InthisRQ,weempiricallystudywhether CAmpactor canopti-
mize the PCAs constructedbydiﬀerentPCAG algorithms.
4https://github.com/jkunlin/fastca
5https://github.com/jkunlin/TCA
6http://www0.cs.ucl.ac.uk/staﬀ/Yue.Jia/projects/cit_hyperheuristic/downloads/
Comb_Linux_64.tar.gz
7https://cse.unl.edu/~citportal/
8https://csrc.nist.gov/projects/automated-combinatorial-testing-for-software/
downloadable-tools
9http://hardlog.udl.cat/static/doc/ctlog/html/index.html
87ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Qiyuan Zhao,Chuan Luo, ShaoweiCai,WeiWu, JinkunLin, Hongyu Zhang,andChunmingHu
Table 1:Results of CAmpactor ,CAmpactor-Short ,SamplingCA ,AutoCCAG ,FastCAandTCAon 20selected PCAG instances.
InstanceCAmpactor CAmpactor-Short SamplingCA AutoCCAG FastCA TCA
min.(avg.)time(s) min.(avg.)time(s) min.(avg.)time(s) min.(avg.)time(s) min.(avg.)time(s) min.(avg.)time(s)
busybox_1_28_0 24 (24.7) 64.3 42(44.5) 14.1 57(58.8) 11.5 45(47.4) 637.6 42(46.7) 19.2 53(55.6) 14.1
calm16_ceb 43 (45.2) 215.7 77(81.1) 33.0 100(103.0) 26.7 81(83.9) 635.7 81(84.5) 383.7 93(97.0) 33.0
cq7750 44 (46.6) 242.0 81(84.8) 37.7 103(105.3) 31.4 84(87.9) 377.0 85(88.1) 341.2 92(99.2) 37.7
dreamcast 50 (53.2) 273.9 87(94.1) 40.1 109(113.4) 33.7 89(95.2) 54.6 89(95.6) 391.5 102(107.7) 40.1
eb40a 45 (46.4) 226.7 77(80.8) 37.0 99(103.6) 29.9 81(85.1) 498.8 81(85.0) 630.4 94(97.2) 37.0
ecos-icse11 47 (48.7) 242.8 81(84.4) 39.6 107(108.4) 31.1 88(91.9) 589.9 89(92.4) 352.3 99(102.0) 39.6
freebsd-icse11 53 (56.2) 354.4 73(77.9) 74.5 118(121.7) 43.8 78(82.2) 2639.1 81(83.4) 2076.6 101(108.4) 74.5
integrator_arm9 58 (60.1) 324.9 103(105.3) 43.3 118(122.1) 37.1 101(105.0) 383.1 101(105.1) 886.7 115(117.1) 43.3
linux 51 (53.9) 279.2 91(98.1) 38.2 111(115.3) 32.9 94(97.6) 257.0 92(97.7) 163.2 106(110.0) 38.2
mb93091 47 (48.4) 307.0 83(86.5) 38.3 103(106.3) 31.1 85(89.3) 325.9 84(89.2) 493.5 97(101.5) 38.3
mpc50 43 (45.0) 253.3 77(80.3) 34.8 96(100.9) 28.3 80(83.3) 99.5 79(83.1) 383.3 86(95.2) 34.8
olpce2294 48 (49.7) 314.2 83(85.6) 43.8 106(109.8) 33.4 91(93.4) 414.1 91(92.9) 509.6 102(103.9) 43.8
pc_i82544 48 (49.8) 314.2 82(84.7) 44.3 107(109.9) 32.5 89(93.9) 50.4 91(93.7) 342.7 98(104.2) 44.3
pc_usb_d12 45 (47.1) 278.8 78(81.1) 41.9 102(105.8) 32.4 82(89.2) 46.7 82(88.8) 545.7 95(100.2) 41.9
refidt334 52 (54.6) 252.8 84(89.5) 43.3 110(113.5) 33.8 89(94.5) 677.0 88(94.0) 478.5 101(106.6) 43.3
sam7ex256 47 (50.3) 293.2 86(88.2) 45.9 105(109.6) 36.4 91(93.5) 432.7 91(93.5) 177.1 102(104.5) 45.9
sleb 43 (44.5) 229.7 71(74.7) 34.1 98(99.3) 26.2 78(81.4) 322.7 78(81.4) 457.7 90(93.5) 34.1
uClinux-config 36 (37.6) 3495.2 52(52.9) 1856.1 64(66.5) 1493.0 64(65.4) 1856.5 64(65.4) 1613.3 64(65.4) 1856.1
vrc4375 48 (49.8) 257.8 85(88.8) 39.5 105(109.3) 32.4 89(91.9) 98.8 89(91.4) 364.7 99(104.0) 39.5
XSEngine 48 (49.7) 277.5 81(83.5) 41.1 104(107.7) 32.1 86(89.5) 236.2 87(89.4) 118.6 98(101.1) 41.1
5.4 ExperimentalDesign
Hardware environment: In this work, all experiments are per-
formed on a computing workstation with 2.60GHz Intel Xeon Plat-
inum8171M CPU and256GBmemory, runningtheoperatingsys-
temofUbuntu18.04.4LTS.
Setting of initialization algorithm: According to Section 4,
CAmpactor aims to reduce the sizes of PCAs. Hence, a PCAG algo-
rithm is /f_irst used to initialize a PCA as CAmpactor ’s input; then
CAmpactor isactivatedtooptimizesuchinitializedPCA,andthe
output of CAmpactor is reported as the /f_inal, optimized PCA. Since
a recent study [ 62] demonstrates that SamplingCA is able to gener-
atesmaller-sizedPCAsthan AutoCCAG ,FastCAandTCA,inthis
workCAmpactor adoptsSamplingCA as its initialization algorithm.
For simplicity, in our experiments we use CAmpactor to directly
represent CAmpactor ’s instantiationthat generates its initial PCA
throughSamplingCA . In fact,CAmpactor treats the initialization
algorithm as a black box, so CAmpactor is able to integrate any
other PCAG algorithms as its initialization algorithm. To study
thegenerality of CAmpactor (i.e.,whetherCAmpactor canfurther
compactthePCAs outputbydiﬀerentPCAGalgorithms),theper-
formanceof CAmpactor adopting AutoCCAG ,FastCAandTCAas
its initializationalgorithms willbe showninSection 6.4.
SinceCAmpactor employsSamplingCA as its initialization algo-
rithm,inordertomakeourcomparisonfair, AutoCCAG ,FastCAand
TCAallreplacetheirowninitializationalgorithmswith SamplingCA
in our experiments. We have conducted the evaluation to com-
pare the versions of AutoCCAG ,FastCAandTCA, which utilize
SamplingCA as their initialization algorithms, against the origi-
nal versions of AutoCCAG ,FastCAandTCA, which usetheir own,
originalinitializationalgorithms.Actually,accordingtoourevalua-
tion, through adopting SamplingCA as the initialization algorithm,
AutoCCAG ,FastCAandTCAachieve considerable performance
improvement. To save space, we do not report these results in thispaper.Forthefullcomparativeresults,readerscanrefertoourpub-
licrepository.2Forsimplicity,inourexperimentswedirectlyuse
AutoCCAG ,FastCAandTCAtodenotetheirversionsthatconstruct
initialPCAs through SamplingCA .
Experimentalsetup: ForCAmpactor ,itshyper-parameters /u1D6FE,/u1D713
and/u1D6FFare set to 10,000, 0.1 and 10, respectively, and the eﬀect of
CAmpactor ’s each hyper-parameter will be analyzed in Section
6.3. The implementation of CAmpactor is available in our public
repository.2Inourexperiments, SamplingCA ,AutoCCAG ,FastCA
andTCAare evaluated using thehyper-parameter settings recom-
mendedbytheirauthors[ 46,47,55,62].
SinceCAmpactor and all its state-of-the-art competitors, i.e.,
SamplingCA ,AutoCCAG ,FastCAandTCA, are randomized algo-
rithms, we conduct 10 independent runs per instance for each
algorithm.Inourexperiments,thecutoﬀtimeforeachalgorithm
run is set to 3,600 CPU seconds, as suggested by a recent study on
solving hardcombinatorial optimization problems [ 97].
ForeachalgorithmonsolvingeachPCAGinstance,wereport
theminimumsizeoftheoutputPCAsamong10runs,denotedas
‘min’, the average size of the output PCAs over 10 runs, denoted as
‘avg’,andtherunningtimemeasuredinCPUsecondsaveragedover
10 runs, denoted as ‘time’. In our experiments, the running time
ofCAmpactor ,AutoCCAG ,FastCAandTCAincludethecomputa-
tionaltimeoftheirinitializationalgorithms.Tostudytheoverall
performance,for each algorithm,we presentthe averagesize and
theaveragerunningtimeoverthewholePCAGinstancecollection.
Since the objective of the PCAG problem is to minimize the size
ofgenerated PCA, inour experiments, for eachPCAGinstance or
the whole PCAG instance collection, if an algorithm generates the
smallest-sizedPCA amongallcompetingalgorithms, itsresultsof
‘min’and‘avg’ are highlightedusing the boldface font.
Statisticalsigni/f_icance and eﬀect size calculation: Further-
more,assuggestedbyrecentempiricalstudies[ 55,60,62],inour
experiments, for each PCAG instance or the whole PCAG instance
88CAmpactor : A Novel andEﬀective LocalSearchAlgorithm forOptimizingPairwise CoveringArrays ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
0 20 40 60 80 100 120
Indices of Instances20406080100120140Average Size of Generated PCAsSamplingCA
TCAFastCA
AutoCCAGCAmpactor-Short
CAmpactor
Figure1:The averagesizesofgeneratedPCAsforeachinstancebyallalgorithms.TheX-axisdepictstheindices ofinstances
that are sorted by the number of options in ascending order, while the Y-axis presents the average size of generated PCA. Each
line inthis/f_igure correspondsto onealgorithm. Notethat thelinesof AutoCCAG andFastCAare mostly overlapped.
Table2:Averagesizeandaveragerunningtimeof CAmpactor ,
CAmpactor-Short ,SamplingCA ,AutoCCAG ,FastCAandTCA
overallPCAG instances.
CAmpactor Short∗SamplingCA AutoCCAG FastCA TCA
avg.size 47.482.7 104.0 86.6 86.7 98.1
avg.time 284.6 52.7 42.1 377.9 357.2 52.7
∗Tosave space,we use ‘ Short’to denote‘ CAmpactor-Short ’.
collection,weperformtheWilcoxonsigned-ranktest[ 20]toexam-
ine the statistical signi/f_icance of any pairwise comparison between
CAmpactor andeachofitscompetitors,andwecalculatetheVargha-
Delaney eﬀect size [ 86] for each pairwise comparison. For each
PCAG instance or the whole PCAG instance collection, if a) all the
p-values of Wilcoxon signed-rank tests at 95% con/f_idence level are
smallerthan0.05,andb)theVargha-Delaneyeﬀectsizesforallpair-
wisecomparisons(between CAmpactor andeachofitscompetitors)
are larger than 0.71 (implying large eﬀect sizes) [ 55,60,62,80,86],
weconsiderthattheperformanceimprovementof CAmpactor over
allitscompetitorsisbothstatisticallysigni/f_icantandmeaningful,
andCAmpactor ’sresults are indicatedusing underline .
6 EXPERIMENTALRESULTS
This section reports andanalyzes the experimental results.
6.1 Comparisonswith State oftheArt (RQ1)
Thecomparativeresultsof CAmpactor andexistingstate-of-the-art
PCAG algorithms (including SamplingCA ,AutoCCAG ,FastCAand
TCA) on 20 selected PCAG instances are reported in Table 1. For
these20selectedPCAGinstances,10ofthemareidenti/f_iedtobe
representative in a recent study [ 5], and the other 10 instances are
randomlyselected.Duetospacelimit,weillustratetheaveragesize
of generated PCAs by each competing algorithm for each instance
in Figure 1. Still, all detailed results of CAmpactor and its competi-
tors on the whole instance collection are available in our public
repository.2Inaddition,theaveragesizeandtheaveragerunningTable3:Averagesizeandaveragerunningtimeof CAmpactor
andallits alternative versionsoverallinstances.
CAmpactor Alt-1 Alt-2 Alt-3
avg.size 47.479.8 54.3 98.6
avg.time 284.6 67.3 278.7 46.1
timeofCAmpactor anditscompetitorsoverallPCAGinstancesare
summarizedinTable 2.
FromTables 1and2aswellasFigure 1,CAmpactor cangener-
ate much smaller-sized PCAs compared to existing state-of-the-art
PCAG algorithms. In particular, Table 2presents that CAmpactor is
able to generate PCAs with around 45% smaller sizes compared to
thoseconstructedbyexistingstate-of-the-artalgorithms,indicating
the superiority of CAmpactor over all its competitors. As recog-
nized by the literature [ 29], a PCAG instance, i.e.,ecos-icse11 , is
challengingtobesolved,anditseemedtobeimpossibletogenerate
PCAs with the size smaller than 50 for this challenging instance.
Moreencouragingly,Table 1demonstratesthat CAmpactor isableto
generatePCAswiththeaveragesizeof48.7forthe ecos-icse11 in-
stance,whiletheaveragesizesofPCAsconstructedby SamplingCA ,
AutoCCAG ,FastCAandTCAfor theecos-icse11 instance are
108.4, 91.9, 92.4 and 102.0, respectively. Our experimental results in
Tables1and2con/f_irmthat CAmpactor substantiallyadvances the
state ofthe art insolving the PCAG problem.
Herewediscusstheeﬃciencyof CAmpactor .AccordingtoTables
1and2, it is not surprising that CAmpactor requires more running
time than SamplingCA , sinceCAmpactor adoptsSamplingCA as its
initialization algorithm (as described in Section 5.4). When com-
paring to existing state-of-the-art meta-heuristic PCAG algorithms
(i.e.,AutoCCAG ,FastCAandTCA),although CAmpactor needsmore
running time than TCA,CAmpactor runs faster than AutoCCAG
andFastCA.Tofurtherstudytheeﬃciencyof CAmpactor ,wede-
noteCAmpactor-Short asCAmpactor with shorter running time:
for each instance, CAmpactor-Short ’s running time is restricted
totheaveragerunningtimeof TCAforthatinstance.Theresults
89ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Qiyuan Zhao,Chuan Luo, ShaoweiCai,WeiWu, JinkunLin, Hongyu Zhang,andChunmingHu
Table 4:Average size andaverage runningtimeof CAmpactor with various hyper-parameter settings of /u1D74Doverallinstances.
/u1D713=0/u1D713=0.1/u1D713=0.2/u1D713=0.3/u1D713=0.4/u1D713=0.5/u1D713=0.6/u1D713=0.7/u1D713=0.8/u1D713=0.9/u1D713=1.0
avg.size 98.6 47.4 46.6 46.1 45.9 45.7 45.7 45.5 45.5 45.4 45.4
avg.time 46.1 284.6 362.2 440.8 503.6 569.0 610.8 673.6 710.6 794.7 825.9
Table5:Averagesizeandaveragerunningtimeof CAmpactor
withvarioushyper-parametersettingsof /u1D739overallinstances.
/u1D6FF=5/u1D6FF=10/u1D6FF=15/u1D6FF=20/u1D6FF=25/u1D6FF=30
avg.size 47.7 47.448.3 49.9 51.9 54.1
avg.time 296.8 284.6 266.1 243.8 222.3 202.1
Table6:Averagesizeandaveragerunningtimeof CAmpactor
withvarioushyper-parametersettingsof /u1D738overallinstances.
/u1D6FE=102/u1D6FE=103/u1D6FE=104/u1D6FE=105
avg.size 73.3 55.0 47.4 43.7
avg.time 58.9 117.2 284.6 1,173.2
ofCAmpactor-Short arealsopresentedinTables 1and2.Accord-
ing to Table 2, with slightly more running time of 10.6 seconds,
CAmpactor-Short can reduce the average size of SamplingCA ’s gen-
erated PCAs by 21.3 over all PCAG instances. As outlined in Algo-
rithm2,CAmpactor tacklesthePCAGproblembyiterativelysolving
thedecisionsub-problemof/f_indingaPCAofsize /u1D706;ifa/u1D706-sizedPCA
isfound,CAmpactor continuesto/f_indaPCAofsize /u1D706−1.Intuitively,
comparedtosolvingadecisionsub-problemwithsmaller /u1D706,solving
adecisionsub-problemwithlarger /u1D706issimplerandthusrequires
lesstime.Hence,itisnotsurprisingthat CAmpactor greatlyopti-
mizesSamplingCA ’soutputPCAseﬃciently.Also,withthesame
running time, the average size of PCAs output by CAmpactor-Short
is82.7,whilethisnumberfor SamplingCA+TCA is98.1.Moreover,
CAmpactor-Short stilloutperforms AutoCCAG andFastCA,con/f_irm-
ingboth eﬀectiveness andeﬃciency of CAmpactor .
6.2 Eﬀects ofCoreTechniques (RQ2)
There are two core techniques of CAmpactor ,i.e.,assignment-level
forbiddenmechanism(inSection 4.2.1)andforcedpatchingtech-
nique (in Section 4.2.2). To study the eﬀect of assignment-level
forbiddenmechanism,basedon CAmpactor wedeveloptwoalter-
nativeversions, i.e.,Alt-1andAlt-2:Alt-1isCAmpactor ’salternative
versionthatdirectlyworkswithoutourassignment-levelforbidden
mechanism, while Alt-2isCAmpactor ’s alternative version that
replacestheassignment-levelforbiddenmechanismwiththe cell-
level tabu mechanism [ 47] used in AutoCCAG ,FastCAandTCA.
To analyze the eﬀect of our forced patching technique, we remove
the forced patching technique from CAmpactor , resulting in an
alternative versionof CAmpactor calledAlt-3.
Table3shows the average size and the average running time
ofCAmpactor and all its alternative versions over all PCAG in-
stances. From Table 3,CAmpactor generates smaller-sized PCAsTable7:Averagesizeandaveragerunningtimeof AutoCCAG ,
FastCA,TCA,Alt-A,Alt-FandAlt-Toverallinstances.
AutoCCAG Alt-A FastCA Alt-F TCA Alt-T
avg.size 86.6 47.4 86.7 47.398.147.3
avg.time 377.9 611.1 357.2 591.5 52.7 293.4
thanallitsalternativeversions,indicatingthateachcoretechnique
ofCAmpactor greatlycontributestotheperformanceimprovement.
6.3 ImpactsofHyper-parameterSettings(RQ3)
AccordingtoSection 4,CAmpactor hasthreehyper-parameters, i.e.,
/u1D713,/u1D6FFand/u1D6FE, recalling that /u1D713controls the probability of activating
the forced patching technique (in Section 4.2.2),/u1D6FFis used in the
assignment-level forbidden mechanism (in Section 4.2.1), and/u1D6FE
decides when CAmpactor terminates (in Section 4.1.1). Here we
analyzehowthesettingsofthesethreehyper-parametersimpact
the practical performance of CAmpactor .
Tables4,5and6report the performance of CAmpactor with
diﬀerentsettingsof /u1D713,/u1D6FFand/u1D6FE,respectively.AccordingtoTable 4,
wherethevaluedomainof /u1D713rangesfrom0to1,withtheincrement
of0.1,intermsofaveragesizeofgeneratedPCAs, CAmpactor shows
robustnesswhen /u1D713≥0.1.FromTable 5,wherethevaluedomainof
/u1D6FFvariesfrom5to30,withtheincrementof5, CAmpactor generates
the smallest-sized PCAs when /u1D6FFis set to 10, and CAmpactor shows
its eﬀectiveness when /u1D6FFis around 10. Table 6, where the value
domain of /u1D6FEis/braceleftbig
102,103,104,105/bracerightbig, shows that when /u1D6FEis set to a
larger value ( i.e.,the searching budget of CAmpactor enlarges),
CAmpactor generates smaller-sized PCAs and meanwhile requires
longer running time. Hence, CAmpactor is a /f_lexible algorithm,
since itcan balanceeﬀectiveness andeﬃciency viaadjusting /u1D6FE.
6.4 Optimizing OtherPCAG Algorithms(RQ4)
AccordingtoSection 5.4,intheprecedingexperiments(Tables 1–6),
CAmpactor adoptsSamplingCA asitsinitializationalgorithm,and
therelatedresultspresentthat CAmpactor cangreatlyreducethe
sizeofPCAconstructedby SamplingCA .Hereweaimtoanalyze
whetherCAmpactor canoptimizethePCAsoutputbyotherstate-of-
the-artPCAGalgorithms. Hence,we integrate AutoCCAG ,FastCA
andTCAintoCAmpactor asCAmpactor ’sinitializationalgorithm
(i.e.,usingCAmpactor tooptimizethe PCAsoutputby AutoCCAG ,
FastCAandTCA), resulting in three new alternative versions of
CAmpactor ,i.e.,Alt-A ,Alt-FandAlt-T,respectively.
Table7presents thecomparative results of AutoCCAG ,FastCA,
TCA,Alt-A,Alt-FandAlt-Ton all instances. According to Table
7, the average sizes of PCAs output by AutoCCAG ,FastCAand
TCAare86.6,86.7and98.1,respectively.Encouragingly,afterthe
90CAmpactor : A Novel andEﬀective LocalSearchAlgorithm forOptimizingPairwise CoveringArrays ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
optimization of CAmpactor , their average sizes are decreased to
47.4,47.3and47.3,respectively.Also,for AutoCCAG ,FastCAand
TCA, the additional running time brought by CAmpactor is around
240seconds.Hence,ourevaluationdemonstratesthat CAmpactor
can further optimize PCAs output by diﬀerent PCAG algorithms
eﬀectivelyandeﬃciently,indicating the generalityof CAmpactor .
6.5 Threatsto Validity
There are twopotentialthreatsto validity ofthis work.
Representativeness of adopted instances: Our evaluation
adopts a diverse collection of 124 public PCAG instances, where
each instance is collected from a real-world, highly con/f_igurable
system.AccordingtoSection 5.1,theseadoptedinstancescovera
broad range of numbers of options and constraints, and they have
been extensively studied in plenty of recent work [ 5,36,45,60,62,
72,77,78]. Therefore,this threatcan be mitigated.
Randomnessofcompetingapproachesinourexperiments:
There are 5 PCAG algorithms evaluated in our experiments, i.e.,
CAmpactor ,SamplingCA ,AutoCCAG ,FastCAandTCA,allofwhich
are randomized algorithms. For a randomized algorithm, conduct-
ing one single run per instance might not precisely evaluate its
performance. Following recent studies [ 46,47,55], for each algo-
rithm we perform 10 independent runs per instance. Moreover,
as described in Section 5.4, we conduct the signi/f_icance test and
calculate the eﬀect size to examine the comparative results. As a
result, this potentialthreatcan be reduced.
7 RELATED WORK
Asanimportanttopicofsoftwaretesting,combinatorialinteraction
testing(CIT)hasbeenwidelystudied.ForliteraturereviewsonCIT,
readerscanrefertosurveys[ 71,84]andbooks[ 38,96].Recently,
CIThasshownitsusefulnessintestingcriticalsystemsfromdiverse
real-worldapplications,asintroducedinSection 1.Pairwisetesting
is the most common CIT technique [ 62], since it can be feasibly
performed inpracticewhilekeeping strongabilitytodetect faults
[16,30,39,83,94].Thisworkaimstoadvancethestateoftheart
insolving the PCAG problem,acore problem inpairwisetesting.
TherearethreemainclassesofpracticalPCAGalgorithms, i.e.,
constraint-encoding algorithms ( e.g.,[1,4,31,92,98]), greedy algo-
rithms (e.g.,[8–10,16,37,41–43,85,88,91,95]) and meta-heuristic
algorithms ( e.g.,[8,17–19,23,25,27,34,46,47,55,67]). Given a
PCAG instance, constraint-encoding PCAG algorithms /f_irst encode
itintoaninstanceofothercombinatorialoptimizationproblems,
and then existing optimization solvers are used to solve the en-
coded instance [ 1,4,31,92,98]. In practice, constraint-encoding
algorithms can only generate PCAs for small-scale instances. How-
ever,they cannothandle large-scale PCAG instanceseﬀectively.
Greedyalgorithms,subdividedintoone-test-at-a-time(OTAT)
and in-parameter-order (IPO) types, are suited for medium-scale
instances but may generate large PCAs, which makes them not
applicableinsuchapplicationscenarioswithlimitedtimebudget.
The OTAT category was pioneered by the AETGalgorithm [ 16],
while the IPO strategy was initially introduced by Lei and Tai [ 43].
Both have numerous improved variants and are widely used [ 8–
10,37,41,42,85,88,92,95],includingthefamous ACTStoolthat
has been widely utilizedinboth academiaandindustry [ 95].Comparedtoconstraint-encodingalgorithmsandgreedyalgo-
rithms, meta-heuristic PCAG algorithms can generate PCAs of
signi/f_icantly smaller sizesyet require much longerrunning time.
Meta-heuristicalgorithmsiterativelysearchforsmaller-sizedPCAs
via advanced searching strategies. In practice, there are various
types ofmeta-heuristic algorithms, including simulated annealing
(e.g.,CASA [23,24]),hyper-heuristicsearch( e.g.,HHSA [34])and
local search ( e.g., TCA[47],FastCA[46] andAutoCCAG [55]). Un-
fortunately, existing PCAG algorithms (including thethree classes
ofalgorithmsintroducedabove)suﬀerfromtheseverescalability
challenge[ 62,77,90]:whendealingwithhighlycon/f_igurablesys-
tems with thousands of options, existing PCAG algorithms require
much running time to construct large-sized PCAs, which would
maketestinghighlycon/f_igurablesystemsconsiderablyineﬃcient.
To alleviate the scalability challenge, Luo et al.proposed a state-
of-the-art PCAG algorithm dubbed SamplingCA [62], which can
generate PCAs for large-scale instances fast via eﬀective sampling
techniques.However, SamplingCA doesnotexplicitlyincorporate
anyoptimizationtechniquetoreducethesizeofitsgeneratedPCA,
so the size can be further reduced. This work proposes CAmpactor ,
whichcancompactPCAsoflarge-scaleinstancesintomuchsmaller-
sizedeﬃcientlyinexperimentalevaluationsandthereforewould
nicely complement SamplingCA . Since constructing small-sized
PCAs is important in practice, we believe that the proposal of
CAmpactor can alleviate the scalability challenge more eﬀectively
andsigni/f_icantly advancethe state of the art inPCAG solving.
8 CONCLUSION
Inthiswork,weproposeanovelandeﬀectivelocalsearchPCAG
algorithm named CAmpactor which can further alleviate the scala-
bilitychallenge.Inparticular, CAmpactor incorporatestwonovel
techniques, i.e.,assignment-level forbidden mechanism and forced
patching technique, to enhance its performance. Our extensive ex-
perimentson124publicinstancesclearlypresentthat CAmpactor
generatesmuchsmaller-sizedPCAsthanexistingstate-of-the-art
PCAG algorithms. Moreover, our evaluation con/f_irms the eﬀects of
all core techniques of CAmpactor and presentthat CAmpactor can
further optimize the PCAs outputbydiﬀerentPCAG algorithms.
9 DATA AVAILABILITY
Thesourcecodeof CAmpactor ,alladoptedPCAGinstancesandthe
detailed experimental results are available in our public repository:
https://github.com/chuanluocs/CAmpactor .
ACKNOWLEDGMENTS
This work was supported in part by the National Key Research
and Development Program of China (Grant 2022YFB4502003), in
partbytheNationalNaturalScienceFoundationofChina(Grant
62202025, Grant 62122078 and Grant 62302528), in part by CCF-
HuaweiPopulusGroveFund(GrantCCF-HuaweiSY202311),inpart
bytheOpenProjectofXiangjiangLaboratory(Grant22XJ03010),
and in part by the Natural Science Foundation of Changsha (Grant
kq2202104).Wewouldliketothanktheanonymousreviewersfor
theirinsightful comments andsuggestions.
91ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Qiyuan Zhao,Chuan Luo, ShaoweiCai,WeiWu, JinkunLin, Hongyu Zhang,andChunmingHu
REFERENCES
[1]Carlos Ansótegui, Felip Manyà, Jesus Ojeda, Josep M. Salvia, and Eduard Torres.
2022. Incomplete MaxSAT approaches for combinatorial testing. Journal of
Heuristics 28,4 (2022), 377–431.
[2]SvenApel,DonS.Batory,ChristianKästner,andGunterSaake.2013. Feature-
OrientedSoftwareProductLines-Concepts and Implementation . Springer.
[3]AdrianBalintandAndreasFröhlich.2010. ImprovingStochasticLocalSearchfor
SATwithaNewProbabilityDistribution.In ProceedingsofSAT2010 .Springer,
10–15.
[4]Mutsunori Banbara, Haruki Matsunaka, Naoyuki Tamura, and Katsumi Inoue.
2010. Generating Combinatorial Test Cases by Eﬃcient SAT Encodings Suitable
for CDCLSATSolvers.In ProceedingsofLPAR 2010 . 112–126.
[5]Eduard Baranov, Axel Legay, and Kuldeep S. Meel. 2020. Baital: An Adaptive
WeightedSamplingApproachforImprovedt-wiseCoverage.In Proceedingsof
ESEC/FSE 2020 . 1114–1126.
[6]Don S. Batory. 2005. Feature Models, Grammars, and Propositional Formulas. In
ProceedingsofSPLC2005 . 7–20.
[7]Armin Biere, Marijn Heule, Hans van Maaren, and Toby Walsh (Eds.). 2009.
HandbookofSatis/f_iability .FrontiersinArti/f_icialIntelligenceandApplications,
Vol. 185. IOS Press.
[8]Renée C. Bryce and Charles J. Colbourn. 2007. The Density Algorithm for
PairwiseInteractionTesting. SoftwareTesting,Veri/f_icationandReliability 17,3
(2007), 159–182.
[9]RenéeC.BryceandCharlesJ.Colbourn.2009.ADensity-basedGreedyAlgorithm
forHigherStrengthCoveringArrays. SoftwareTesting,Veri/f_icationandReliability
19,1 (2009), 37–53.
[10]Renée C. Bryce, Charles J. Colbourn, and Myra B. Cohen. 2005. A Framework of
Greedy Methods for Constructing Interaction Test Suites. In Proceedings of ICSE
2005. 146–155.
[11]ShaoweiCai,JinkunLin,andChuanLuo.2017. FindingASmallVertexCover
inMassiveSparseGraphs:Construct,LocalSearch,andPreprocess. Journalof
Arti/f_icial IntelligenceResearch 59(2017), 463–494.
[12]Shaowei Cai and Kaile Su. 2013. Local search for Boolean Satis/f_iability with
con/f_igurationchecking and subscore. Arti/f_icial Intelligence 204(2013), 75–98.
[13]XinyeCai,HaoranSun,QingfuZhang,andYuhuaHuang.2019. AGridWeighted
Sum Pareto Local Search for Combinatorial Multi and Many-Objective Optimiza-
tion.IEEE Transactions onCybernetics 49,9 (2019), 3586–3598.
[14]YanshanChen,ZiyuanWang,DongWang,ChunrongFang,andZhenyuChen.
2019. Variable Strength Combinatorial Testing for Deep Neural Networks. In
ProceedingsofICST Workshops 2019 . 281–284.
[15]Yi Chu, Shaowei Cai, and Chuan Luo. 2023. NuWLS: Improving Local Search
for (Weighted) Partial MaxSAT by New Weighting Techniques. In Proceedings of
AAAI 2023 . 3915–3923.
[16]DavidM.Cohen,SiddharthaR.Dalal,MichaelL.Fredman,andGardnerC.Patton.
1997. TheAETGSystem:AnApproachtoTestingBasedonCombinatorialDesign.
IEEE Transactions onSoftwareEngineering 23,7 (1997), 437–444.
[17]Myra B. Cohen, Charles J. Colbourn, and Alan C. H. Ling. 2003. Augmenting
SimulatedAnnealingtoBuildInteractionTestSuites.In ProceedingsofISSRE2003 .
394–405.
[18]MyraB.Cohen,PeterB.Gibbons,WarwickB.Mugridge,andCharlesJ.Colbourn.
2003. ConstructingTestSuitesforInteractionTesting.In ProceedingsICSE2003 .
38–48.
[19]MyraB.Cohen,PeterB.Gibbons,WarwickB.Mugridge,CharlesJ.Colbourn,and
JamesS.Collofello.2003. AVariableStrengthInteractionTestingofComponents.
InProceedingsofCOMPAC 2003 . 413–418.
[20] W. J. Conover. 1999. PracticalNonparametricStatistics . Conover.
[21]HangDong,Boshi Wang,BoQiao,WenqianXing,ChuanLuo,Si Qin, Qingwei
Lin, Dongmei Zhang, Gurpreet Virdi, and Thomas Moscibroda. 2021. Predictive
Job Scheduling under Uncertain Constraints in Cloud Computing. In Proceedings
ofIJCAI2021 . 3627–3634.
[22]NiklasEén andNiklasSörensson.2003. AnExtensibleSAT-solver.In Proceedings
ofSAT2003 . 502–518.
[23]Brady J. Garvin, Myra B. Cohen, and Matthew B. Dwyer. 2009. An Improved
Meta-Heuristic Search for Constrained Interaction Testing. In Proceedings of
InternationalSymposiumonSearch BasedSoftwareEngineering 2009 . 13–22.
[24]Brady J. Garvin, Myra B. Cohen, and Matthew B. Dwyer. 2011. Evaluating
Improvements to a Meta-heuristic Search for Constrained Interaction Testing.
EmpiricalSoftwareEngineering 16,1 (2011), 61–102.
[25]Syed A. Ghazi and Moataz A. Ahmed. 2003. Pair-wise Test Coverage using
Genetic Algorithms.In ProceedingsofCEC 2003 . 1420–1424.
[26]Harrison Goldstein, John Hughes, Leonidas Lampropoulos, and Benjamin C.
Pierce. 2021. Do Judge a Test by its Cover - Combining Combinatorial and
Property-Based Testing.In ProceedingsofESOP2021 . 264–291.
[27]Loreto Gonzalez-Hernandez, Nelson Rangel-Valdez, and Jose Torres-Jimenez.
2010. Construction of Mixed Covering Arrays of Variable Strength Using a Tabu
SearchApproach.In ProceedingsofCOCOA2010 . 51–64.
[28]Jiazhen Gu, Chuan Luo, Si Qin, Bo Qiao, Qingwei Lin, Hongyu Zhang, Ze Li,
YingnongDang, ShaoweiCai, Wei Wu,YangfanZhou, Murali Chintalapati, andDongmei Zhang. 2020. Eﬃcient IncidentIdenti/f_ication from Multi-dimensional
IssueReportsviaMeta-heuristicSearch.In ProceedingsofESEC/FSE2020 .292–303.
[29]ChristopherHenard,MikePapadakis,GillesPerrouin,JacquesKlein,PatrickHey-
mans,andYvesLeTraon.2014. BypassingtheCombinatorialExplosion:Using
SimilaritytoGenerateandPrioritizeT-WiseTestCon/f_igurationsforSoftware
Product Lines. IEEE Transactions on Software Engineering 40, 7 (2014), 650–670.
[30]Aymeric Hervieu, Dusica Marijan, Arnaud Gotlieb, and Benoit Baudry. 2016.
PracticalMinimizationofPairwise-coveringTestCon/f_igurationsusingConstraint
Programming. Informationand SoftwareTechnology 71(2016), 129–146.
[31]Brahim Hnich, Steven David Prestwich, Evgeny Selensky, and Barbara M. Smith.
2006. Constraint Models for the Covering Test Problem. Constraints 11, 2-3
(2006), 199–219.
[32]HolgerH.Hoos.2002.AnAdaptiveNoiseMechanismforWalkSAT.In Proceedings
ofAAAI 2002 . 655–660.
[33]HolgerH.HoosandThomasStützle.2004. StochasticLocalSearch:Foundations&
Applications . Elsevier / Morgan Kaufmann.
[34]Yue Jia, Myra B. Cohen, Mark Harman, and Justyna Petke. 2015. Learning Com-
binatorialInteractionTestGenerationStrategiesUsingHyperheuristicSearch.
InProceedingsofICSE2015 . 540–550.
[35]Christian Kaltenecker, Alexander Grebhahn, Norbert Siegmund, Jianmei Guo,
andSvenApel.2019. Distance-basedSamplingofSoftwareCon/f_igurationSpaces.
InProceedingsofICSE2019 . 1084–1094.
[36]AlexanderKnüppel,ThomasThüm,StephanMennicke,JensMeinicke,andIna
Schaefer. 2017. Is There a Mismatch between Real-world Feature Models and
Product-lineResearch?. In ProceedingsofESEC/FSE 2017 . 291–302.
[37]Sebastian Krieter, Thomas Thüm, Sandro Schulze, Gunter Saake, and Thomas
Leich.2020. YASA:yetanothersamplingalgorithm.In ProceedingsofVaMoS2020 .
4:1–4:10.
[38]D.RichardKuhn,RaghuN.Kacker,andYuLei.2013. IntroductiontoCombinatorial
Testing. CRC press.
[39]D. Richard Kuhn, Dolores R. Wallace, and Albert M.Gallo. 2004. SoftwareFault
InteractionsandImplicationsforSoftwareTesting. IEEETransactionsonSoftware
Engineering 30,6 (2004), 418–421.
[40]RickKuhn,RaghuN.Kacker,JeﬀYuLei,andDimitrisE.Simos.2020. InputSpace
CoverageMatters. Computer 53,1 (2020), 37–44.
[41]Yu Lei, Raghu Kacker, D. Richard Kuhn, Vadim Okun, and James Lawrence. 2007.
IPOG:AGeneralStrategyforT-WaySoftwareTesting.In ProceedingsofECBS
2007. 549–556.
[42]Yu Lei, Raghu Kacker, D. Richard Kuhn, Vadim Okun, and James Lawrence. 2008.
IPOG/IPOG-D:EﬃcientTestGenerationforMulti-wayCombinatorialTesting.
SoftwareTesting,Veri/f_ication and Reliability 18,3 (2008), 125–148.
[43]YuLeiandKuo-ChungTai.1998. In-Parameter-Order:ATestGenerationStrategy
for PairwiseTesting.In ProceedingsofHASE 1998 . 254–261.
[44]ChuMinLiandWenqiHuang.2005. Diversi/f_icationandDeterminisminLocal
Searchfor Satis/f_iability. In ProceedingsofSAT2005 . 158–172.
[45]JiaHuiLiang,VijayGanesh,KrzysztofCzarnecki,andVenkateshRaman.2015.
SAT-based Analysisof Large Real-worldFeatureModelsis Easy. In Proceedings
ofSPLC2015 , Douglas C. Schmidt (Ed.). 91–100.
[46]Jinkun Lin, Shaowei Cai, Chuan Luo, Qingwei Lin, and Hongyu Zhang. 2019.
TowardsMoreEﬃcientMeta-heuristicAlgorithmsforCombinatorialTestGen-
eration.In ProceedingsofESEC/FSE 2019 . 212–222.
[47]Jinkun Lin, Chuan Luo, Shaowei Cai, Kaile Su, Dan Hao, and Lu Zhang. 2015.
TCA: AnEﬃcient Two-Mode Meta-Heuristic Algorithm for CombinatorialTest
Generation. In ProceedingsofASE 2015 . 494–505.
[48]Chuan Luo, Shaowei Cai, Kaile Su, and Wenxuan Huang. 2017. CCEHC: An
Eﬃcient Local Search Algorithm for Weighted Partial Maximum Satis/f_iability.
Arti/f_icial Intelligence 243(2017), 26–44.
[49]Chuan Luo, Shaowei Cai, Kaile Su, and Wei Wu. 2015. Clause States Based
Con/f_igurationCheckinginLocalSearchforSatis/f_iability. IEEETransactionson
Cybernetics 45,5 (2015), 1014–1027.
[50]Chuan Luo, Shaowei Cai, Wei Wu, Zhong Jie, and Kaile Su. 2015. CCLS: An
Eﬃcient Local Search Algorithm for Weighted Maximum Satis/f_iability. IEEE
Transactions onComputers 64,7 (2015), 1830–1843.
[51]ChuanLuo,ShaoweiCai,WeiWu,andKaileSu.2013.FocusedRandomWalkwith
Con/f_iguration Checking and Break Minimum for Satis/f_iability. In Proceedings of
CP2013. 481–496.
[52]Chuan Luo, Shaowei Cai, Wei Wu, and Kaile Su. 2014. Double Con/f_iguration
Checking in Stochastic Local Search for Satis/f_iability. In Proceedings of AAAI
2014. 2703–2709.
[53]ChuanLuo,HolgerH.Hoos,andShaoweiCai.2020. PbO-CCSAT:BoostingLocal
SearchforSatis/f_iabilityUsingProgrammingbyOptimisation.In Proceedingsof
PPSN 2020 . 373–389.
[54]Chuan Luo, Holger H. Hoos, Shaowei Cai, Qingwei Lin, Hongyu Zhang, and
Dongmei Zhang. 2019. Local Search with Eﬃcient Automatic Con/f_iguration for
Minimum VertexCover. In ProceedingsofIJCAI2019 . 1297–1304.
[55]Chuan Luo, Jinkun Lin, Shaowei Cai, Xin Chen, Bing He, Bo Qiao, Pu Zhao,
Qingwei Lin, Hongyu Zhang, Wei Wu, Saravanakumar Rajmohan, and Dongmei
Zhang. 2021. AutoCCAG: An Automated Approach to Constrained Covering
92CAmpactor : A Novel andEﬀective LocalSearchAlgorithm forOptimizingPairwise CoveringArrays ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Array Generation. In ProceedingsofICSE2021 . 201–212.
[56]ChuanLuo,BoQiao,XinChen,PuZhao,RandolphYao,HongyuZhang,WeiWu,
Andrew Zhou, and Qingwei Lin. 2020. Intelligent Virtual Machine Provisioning
in Cloud Computing. In ProceedingsofIJCAI2020 . 1495–1502.
[57]ChuanLuo,BoQiao,WenqianXing,XinChen,PuZhao,ChaoDu,RandolphYao,
Hongyu Zhang, Wei Wu, Shaowei Cai, Bing He, Saravanakumar Rajmohan, and
Qingwei Lin.2021. Correlation-AwareHeuristic Searchfor Intelligent Virtual
Machine Provisioning in Cloud Systems. In Proceedings of AAAI 2021 . 12363–
12372.
[58]ChuanLuo,KaileSu,andShaoweiCai.2012. ImprovingLocalSearchforRandom
3-SAT Using Quantitative Con/f_iguration Checking. In Proceedings of ECAI 2012 .
570–575.
[59]Chuan Luo, Kaile Su, and Shaowei Cai. 2014. More eﬃcient two-mode stochastic
localsearchforrandom3-satis/f_iability. AppliedIntelligence 41,3(2014),665–680.
[60]ChuanLuo,BinqiSun,BoQiao,JunjieChen,HongyuZhang,JinkunLin,Qing-
wei Lin, and Dongmei Zhang. 2021. LS-Sampling: An Eﬀective Local Search
based Sampling Approach for Achieving High t-wise Coverage. In Proceedings of
ESEC/FSE 2021 . 1081–1092.
[61]Chuan Luo, Wenqian Xing, Shaowei Cai, and Chunming Hu. 2022. NuSC: An
Eﬀective Local Search Algorithm for Solving the Set Covering Problem. IEEE
Transactions onCybernetics (2022).
[62]ChuanLuo,QiyuanZhao,ShaoweiCai,HongyuZhang,andChunmingHu.2022.
SamplingCA:Eﬀective and Eﬃcient Sampling-Based Pairwise Testing forHighly
Con/f_igurableSoftwareSystems. In ProceedingsofESEC/FSE 2022 . 1185–1197.
[63]Lei Ma, Felix Juefei-Xu, Minhui Xue, Bo Li, Li Li, Yang Liu, and Jianjun Zhao.
2019. DeepCT: Tomographic Combinatorial Testing for Deep Learning Systems.
InProceedingsofSANER2019 . 614–618.
[64]MarcelMaehren,PhilippNieting,SvenHebrok,RobertMerget,JurajSomorovsky,
and Jörg Schwenk. 2022. TLS-Anvil: Adapting Combinatorial Testing for TLS
Libraries.In ProceedingsofUSENIXSecurity2022 . 215–232.
[65]Michalis Mavrovouniotis, Felipe Martins Müller, and Shengxiang Yang. 2017.
AntColonyOptimizationWithLocalSearchforDynamicTravelingSalesman
Problems. IEEE Transactions onCybernetics 47,7 (2017), 1743–1756.
[66]David A. McAllester, Bart Selman, and Henry A. Kautz. 1997. Evidence for
Invariantsin LocalSearch. In ProceedingsofAAAI 1997 . 321–326.
[67]James D. McCaﬀrey. 2009. Generation of Pairwise Test Sets Using a Genetic
Algorithm. In ProceedingsofCOMPSAC 2009 . 626–631.
[68]Flávio Medeiros, Christian Kästner, Márcio Ribeiro, Rohit Gheyi, and Sven Apel.
2016. A Comparison of 10 Sampling Algorithms for Con/f_igurable Systems. In
ProceedingsofICSE2016 . 643–654.
[69]Hane/f_i Mercan, Cemal Yilmaz, and Kamer Kaya. 2019. CHiP: A Con/f_igurable
Hybrid Parallel Covering Array Constructor. IEEE Transactions on Software
Engineering 45,12(2019), 1270–1291.
[70]Wil Michiels, Emile H. L. Aarts, and Jan H. M. Korst. 2007. Theoretical aspects of
localsearch . Springer.
[71]Changhai Nie and Hareton Leung. 2011. A Survey of Combinatorial Testing.
Comput. Surveys 43,2 (2011), 11:1–11:29.
[72]Jeho Oh, Paul Gazzillo, and Don S. Batory. 2019. t-wise Coverage by Uniform
Sampling. In ProceedingsofSPLC2019 . 15:1–15:4.
[73]SebastianOster,FlorianMarkert,andPhilippRitter.2010. AutomatedIncremental
PairwiseTestingofSoftwareProductLines.In ProceedingsofSPLC2010 .196–210.
[74] Mingyu Park,HoonJang,TaejoonByun,and YunjaChoi.2020. Property-based
testingforLGhomeappliancesusingacceleratedsoftware-in-the-loopsimulation.
InProceedingsofICSE-SEIP 2020 . 120–129.
[75]Justyna Petke, Myra B. Cohen, Mark Harman, and Shin Yoo. 2015. Practical
CombinatorialInteractionTesting:EmpiricalFindingsonEﬃciencyandEarly
FaultDetection. IEEETransactionsonSoftwareEngineering 41,9(2015),901–924.
[76]JustynaPetke,ShinYoo,MyraB.Cohen,andMarkHarman.2013. Eﬃciencyand
earlyfaultdetectionwithlowerandhigherstrengthcombinatorialinteraction
testing. In ProceedingsofESEC/FSE 2013 . 26–36.
[77]Tobias Pett, Thomas Thüm, Tobias Runge, Sebastian Krieter, Malte Lochau, and
InaSchaefer.2019. ProductSamplingforProductLines:TheScalabilityChallenge.InProceedingsofSPLC2019 . 14:1–14:6.
[78]Quentin Plazar, Mathieu Acher, Gilles Perrouin, Xavier Devroey, and Maxime
Cordy. 2019. Uniform Sampling of SAT Solutions for Con/f_igurable Systems: Are
WeThereYet?. In ProceedingsofICST 2019 . 240–251.
[79]BoQiao,FangkaiYang,ChuanLuo,YananWang,JohnnyLi,QingweiLin,Hongyu
Zhang,MohitDatta,AndrewZhou,ThomasMoscibroda,SaravanakumarRajmo-
han, and Dongmei Zhang.2021. IntelligentContainerReallocationatMicrosoft
365. InProceedingsofESEC/FSE 2021 . 1438–1443.
[80]Federica Sarro, Mark Harman, Yue Jia, and Yuanyuan Zhang. 2018. Customer
Rating ReactionsCan Be PredictedPurely using AppFeatures. In Proceedings of
RE2018. 76–87.
[81]JialongShi,QingfuZhang,andJianyongSun.2020. PPLS/D:ParallelParetoLocal
SearchBasedonDecomposition. IEEETransactionsonCybernetics 50,3(2020),
1060–1071.
[82]JingSun,HongyuZhang,Yuan-FangLi,andHaiH.Wang.2005.FormalSemantics
and Veri/f_icationfor FeatureModeling. In ProceedingsofICECCS2005 . 303–312.
[83]Kuo-ChungTaiandYuLei.2002. ATestGenerationStrategyforPairwiseTesting.
IEEE Transactions onSoftwareEngineering 28,1 (2002), 109–111.
[84]Thomas Thüm, Sven Apel, Christian Kästner, Ina Schaefer, and Gunter Saake.
2014. A Classi/f_ication and Survey of AnalysisStrategies for SoftwareProduct
Lines.ACMComputingSurveys 47,1 (2014), 6:1–6:45.
[85]Yu-Wen Tung and Wafa S. Aldiwan. 2000. Automating Test Case Generation for
the New Generation Mission Software System. In Proceedings of IEEE Aerospace
Conference 2000 . 431–437.
[86]AndrásVarghaandHaroldD.Delaney.2000. ACritiqueandImprovementofthe
CLCommonLanguageEﬀectSizeStatisticsofMcGrawandWong. Journalof
Educationaland Behavioral Statistics 25,2 (2000), 101–132.
[87]Xinyi Wang, Paolo Arcaini, Tao Yue, and Shaukat Ali. 2021. Application of
CombinatorialTestingtoQuantumPrograms.In ProceedingsofQRS2021 .179–
188.
[88]Ziyuan Wang, Changhai Nie,and Baowen Xu.2007. Generating Combinatorial
Test Suite for Interaction Relationship. In ProceedingsofSOQUA2007 . 55–61.
[89]HuayaoWu,LixinXu,XintaoNiu,andChanghaiNie.2022. Combinatorialtesting
of restfulapis.In ProceedingsofICSE2022 . 426–437.
[90]Yi Xiang, Han Huang, Miqing Li, Sizhe Li, and Xiaowei Yang. 2022. Looking For
Novelty in Search-Based Software Product Line Testing. IEEE Transactions on
SoftwareEngineering 48,7 (2022), 2317–2338.
[91]Akihisa Yamada, Armin Biere, Cyrille Artho, Takashi Kitamura, and Eun-Hye
Choi. 2016. Greedy Combinatorial Test Case Generation using Unsatis/f_iable
Cores. In ProceedingsofASE 2016 . 614–624.
[92]Akihisa Yamada, Takashi Kitamura, Cyrille Artho, Eun-Hye Choi, Yutaka Oiwa,
andArminBiere.2015. OptimizationofCombinatorialTestingbyIncremental
SATSolving.In ProceedingsofICST 2015 . 1–10.
[93]Cemal Yilmaz, Myra B. Cohen, and Adam A. Porter. 2006. Covering Arrays
for Eﬃcient Fault Characterization in Complex Con/f_iguration Spaces. IEEE
Transactions onSoftwareEngineering 32,1 (2006), 20–34.
[94]Cemal Yilmaz, Sandro Fouché, Myra B. Cohen, Adam A. Porter, Gülsen Demiröz,
andUgurKoc.2014. MovingForwardwithCombinatorialInteractionTesting.
Computer 47,2 (2014), 37–45.
[95]LinbinYu,YuLei,Mehra NourozBorazjany,RaghuKacker,andD.RichardKuhn.
2013. An Eﬃcient Algorithm for Constraint Handling in Combinatorial Test
Generation. In ProceedingsofICST 2013 . 242–251.
[96]Jian Zhang, Zhiqiang Zhang, and Feifei Ma. 2014. Automatic Generation of
Combinatorial TestData . Springer.
[97]Xindi Zhang, Bohan Li, Shaowei Cai, and Yiyuan Wang. 2021. Eﬃcient Local
SearchbasedonDynamicConnectivityMaintenanceforMinimumConnected
DominatingSet. Journal ofArti/f_icial IntelligenceResearch 71(2021), 89–119.
[98]Zhiqiang Zhang, Jun Yan, Yong Zhao, and Jian Zhang. 2014. Generating Combi-
natorial Test Suite using Combinatorial Optimization. Journal of Systems and
Software98(2014), 191–207.
Received 2023-02-02; accepted 2023-07-27
93