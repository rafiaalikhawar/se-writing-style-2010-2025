Singapor e Management Univ ersity Singapor e Management Univ ersity 
Institutional K nowledge at Singapor e Management Univ ersity Institutional K nowledge at Singapor e Management Univ ersity 
Resear ch Collection School Of Computing and 
Information Systems School of Computing and Information Systems 
11-2022 
Large-scale analysis of non-termination bugs in r eal-world OSS Large-scale analysis of non-termination bugs in r eal-world OSS 
projects projects 
Xiuhan SHI 
Xiaof ei XIE 
Singapor e Management Univ ersity , xfxie@smu.edu.sg 
Yi LI 
Yao ZH ANG 
Sen CHEN 
See next page for additional authors 
Follow this and additional works at: https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch 
 Part of the Programming Languages and Compilers Commons , and the Softwar e Engineering 
Commons 
Citation Citation 
SHI, Xiuhan; XIE, Xiaof ei; LI, Yi; ZH ANG, Y ao; CHEN, Sen; and LI, Xiaohong. Lar ge-scale analysis of non-
termination bugs in r eal-world OSS pr ojects. (2022). Proceedings of the 30th A CM Joint E uropean 
Softwar e Engineering Conf erence and Symposium on the F oundations of Softwar e Engineering, 
Singapor e, 2022 No vember 14-18 . 256-268. 
Available at:Available at:  https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch/7496 
This Conf erence Pr oceeding Ar ticle is br ought t o you for fr ee and open access b y the School of Computing and 
Information Systems at Institutional K nowledge at Singapor e Management Univ ersity . It has been accepted for 
inclusion in Resear ch Collection School Of Computing and Information Systems b y an authoriz ed administr ator of 
Institutional K nowledge at Singapor e Management Univ ersity . For mor e information, please email 
cher ylds@smu.edu.sg . Author Author 
Xiuhan SHI, Xiaof ei XIE, Yi LI, Y ao ZH ANG, Sen CHEN, and Xiaohong LI 
This conf erence pr oceeding ar ticle is a vailable at Institutional K nowledge at Singapor e Management Univ ersity: 
https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch/7496 Large-Scale Analysis of Non-Termination Bugs in Real-World OSS
Projects
Xiuhan Shi
Collegeof Intelligence and
Computing,TianjinUniversity
Tianjin,China
shixiuhan@tju.edu.cnXiaofei Xie
SingaporeManagementUniversity
Singapore,Singapore
xfxie@smu.edu.sgYiLi
Schoolof ComputerScienceand
Engineering,Nanyang Technological
University
Singapore,Singapore
yi_li@ntu.edu.sg
YaoZhang
Collegeof Intelligence and
Computing,TianjinUniversity
Tianjin,China
zzyy@tju.edu.cnSen Chen‚àó
Collegeof Intelligence and
Computing,Tianjin University
Tianjin,China
senchen@tju.edu.cnXiaohong Li‚àó
Collegeof Intelligence and
Computing,TianjinUniversity
Tianjin,China
xiaohongli@tju.edu.cn
ABSTRACT
Termination isacrucialprogram property. Non-terminationbugs
can be subtle to detect and may remain hidden for long before
they take effect. Many real-world programs still suffer from vast
consequences( e.g.,noresponse)causedbynon-terminationbugs.
As a classic problem, termination proving has been studied for
manyyears.Manyterminationcheckingtoolsandtechniqueshave
beendevelopedanddemonstratedeffectivenessonexistingwell-
established benchmarks. However, the capability of these tools
infindingpracticalnon-terminationbugshasyettobetestedon
real-worldprojects.Tofill in thisgap, inthispaper, we conducted
the first large-scale empirical study of non-termination bugs in
real-worldOSSprojects.Specifically,wefirstdevotedsubstantial
manual efforts in collecting and analyzing 445 non-termination
bugsfrom3,142GitHubcommitsandprovidedasystematicclassifi-
cationofthebugsbasedontheirrootcauses.Weconstructedanew
benchmarksetcharacterizingthereal-worldbugswithsimplified
programs, including a non-termination dataset with 56 real and
reproducible non-termination bugs and a termination dataset with
58 fixed programs. With the constructed benchmark, we evaluated
five state-of-the-art termination analysis tools. The results show
that the capabilities of the tested tools to make correct verdicts
haveobviouslydroppedcomparedwiththeexistingbenchmarks.
Meanwhile, we identified the challenges and limitations that these
tools face by analyzing the root causes of their unhandled bugs. Fi-
nally,wesummarizedthechallengesandfutureresearchdirections
for detectingnon-terminationbugsinreal-world projects.
‚àóSenChen and Xiaohong Li arethe corresponding authors.
Permissionto make digitalor hard copies of allor part ofthis work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ‚Äô22, November 14‚Äì18,2022, Singapore, Singapore
¬© 2022 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-9413-0/22/11...$15.00
https://doi.org/10.1145/3540250.3549129CCS CONCEPTS
‚Ä¢Theoryofcomputation ‚ÜíProgramanalysis ;‚Ä¢Softwareand
itsengineering ‚ÜíSoftware post-developmentissues .
KEYWORDS
Non-terminationBug, Benchmarking,EmpiricalStudy
ACM Reference Format:
Xiuhan Shi, Xiaofei Xie, Yi Li, Yao Zhang, Sen Chen, and Xiaohong Li. 2022.
Large-Scale Analysis of Non-Termination Bugs in Real-World OSS Projects.
InProceedings of the 30th ACM Joint European Software Engineering Confer-
ence and Symposium on the Foundations of Software Engineering (ESEC/FSE
‚Äô22), November 14‚Äì18, 2022, Singapore, Singapore. ACM, New York, NY, USA,
13pages.https://doi.org/10.1145/3540250.3549129
1 INTRODUCTION
Termination concerns the livenessof a program, which is crucial
to software quality. A program is non-terminating if there exist
someinputsthatcausetheprogramtoexecuteindefinitely.Non-
terminationofprogramsmayhavevastconsequences,especially
whenemployedinsafety-criticalenvironments, e.g.,aerospacesoft-
ware.Forexample,softwarewithnon-terminationbugscanbecome
unresponsive [ 12], leading to degraded user experiences and some-
times denial-of-service attacks [ 15]. The current attempts to this
problem focus on proving termination [ 4,7,10,20,24,46]. Yet,
determiningprogramterminationisshowntobeanundecidable
problem [ 23], and a failure to prove terminationdoes not indicate
that the program can always terminate. On the other hand, it is
alsochallengingtoshowthataprogramisnon-terminating.The
challengeliesinthefactthattheviolationwitnessesofaliveness
propertyare infinite traces,therefore, one cannotcome up witha
finiteoracleas inthe caseof a safetyproperty.
In recent years, many advanced algorithms and techniques [ 5,6,
38,56]have been proposed to eitherprove terminationordemon-
strate non-termination of programs. Generally, they are able to
achieve good performance on standard benchmarks, such as SV-
COMP [21] and TermCOMP [ 52]. These benchmarks often include
manuallycrafted programs,with significantlysimplified language
256ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore Xiuhan Shi,XiaofeiXie, Yi Li, Yao Zhang,Sen Chen andXiaohongLi.
featuresandexecutionenvironments,tomaketheevaluationofvar-
iousalgorithms[ 14,39,56]easier.Thisbringsconcernstowhether
the evaluation results can truly reflect the performance of the
techniquesonreal-worldnon-terminationbugs.Forexample,our
studyshows thatwhileUAutomizer [ 34]correctlyhandles 71.5%
(1,581/2,212) programs in SV-COMP 2021, but it cannot be directly
appliedonrealOSSprojects,anditonlysuccessfullyhandles47%of
thereal-worldnon-terminatingprogramsafternecessarysimplifica-
tions have been made. This indicates that the existing benchmarks
maynotbeidealevaluationsubjectswhenthepracticalvaluesof
the non-terminationchecking techniques are concerned.
There have been a number of studies done on real-world soft-
ware bugs [26,28,30,36,42,59], which play significant roles in
raising awareness and bringing new insights to software quality
assurance [ 35,53,54]. Similarly, we believe that a deep analysis
of real-world non-termination bugs will provide useful insights
todevelopersandguidethedevelopmentof newnon-termination
detectiontechniques.Tothebestofourknowledge,thereisstillno
such study on non-termination bugs, which motivates our work.
In particular, we would like to find out the answers to the fol-
lowing questions. How commondo non-termination bugs appearin
real-worldprograms? Whataretherootcausesofthesebugs? How
difficult is it to find these bugs? How effective are the state-of-the-
arttechniquesindetectingnon-terminationbugsinreal-worldOSS
projects?
Inthis paper,we aimto bridgethisgap byconducting alarge-
scaleempiricalstudyofnon-terminationbugsinreal-worldOSS
projects.Wefacethreemainchallengesinthisstudy. First,there
is no existing dataset on the non-termination bugs from real-world
OSSprojects.Itisdifficulttoestablishreasonablecriteriaandcollect
representative non-termination bugs to build the dataset. Second,
the root cause analysis of non-termination bugs is difficult. Due
to the complexity of the real-world program logic ( e.g., complex
datastructure,nestedloops,andrecursivefunction)andthelack
of a test oracle, it is non-trivial to understand whether they are
real non-termination bugs and why the programs do not termi-
nate.Third,the state-of-the-art tools cannot be directly applied
to real-world OSS projects since many complex features are not
well supported, such as dependencies and complex data structures,
makingitdifficult to evaluate thesetoolsonOSS projects.
To overcome these challenges, we first collect 3,142 commits
from1,600C/C++projects,whicharerelatedtonon-termination
bugs. Note that we selected C/C++ in our work because the pop-
ular termination analysis tools (e.g., AProVE, CBMC, and UAu-
tomizer)onlysupportC/C++programs. We dedicatedsubstantial
efforts to manually investigate these commits and finally identified
445non-terminationbugsfrom199projects.Throughfurtherin-
depth analysis on the root causes of these bugs, we systematically
builtahierarchicaltaxonomycontaining24categories.Toevaluate
the state-of-the-art tools ( i.e., UAutomizer [ 34], CPAChecker [ 9],
2LS [48], AProVE [ 31], and T2 [ 11]) on real-world programs, we
built a new benchmark including 56 non-terminating programs
and58fixedversions,whichareextractedfromthereal-worldnon-
terminationbugs.Weevaluatedtheireffectivenessandsummarized
thecommonreasonsfortheirfailures.Ingeneral,weaimtoanswer
the followingresearchquestions:‚Ä¢RQ1:Whataretherootcausesofnon-terminationbugsin
real-world OSS projects?
‚Ä¢RQ2:How effective are the state-of-the-art tools in proving
the non-terminationof real-world programs?
‚Ä¢RQ3:Whatarethepotentialrootcausesforthefailuresof
the studiedtools?
By answering these questions, we characterize the real-world
non-terminationbugsandprovideusefulinsightsfordevelopers
and researchers. For e xample, our results rev eal that infinite loops
canbecausedby10typesofcommonlogicalfaults( e.g.,missing
iteratorupdate,usingerroneouscondition)aswellas6otherbug
types related to general programming features ( e.g., overflow, type
conversion). Infinite recursions can be caused by three incorrect
recursion designs ( e.g., incorrect return) and 5 types of unexpected
recursion ( e.g., misusing method overloading). Our study on the
existingtoolsshowsthattheyarealmostcompletelyinapplicable
to real projects.Compared to the existing benchmarks,the perfor-
mance of existing toolsdrop significantly on theextractedbench-
marks,indicatingthattheyarestillfarfromeffectiveindiscovering
real-world non-terminationbugs. We also discussand summarize
keychallengesthatshouldbeaddressedinfutureresearch.More
details canbe foundonour website.1
In summary,this paper makes the following contributions:
‚Ä¢Tothebestofourknowledge,weconductedthefirstcom-
prehensive study on analyzing root causes of real-world
non-terminationbugs.Weconstructedasystematictaxon-
omy of 24 bug categories and highlight their characteristics
includingthe distributions,root causes, fixstrategies, etc.
‚Ä¢We constructed a new benchmark that is extracted from
differentcategories of real-worldnon-terminationbugs, in-
cludingthenon-terminationversionsandthecorresponding
fixedversions.Thebenchmarkispublicavailableandwill
be expandedcontinuously.
‚Ä¢We evaluated the state-of-the-art termination analysis tools
ontheextractedbenchmarksandidentifiedtheirweaknesses.
We summarized the main challenges and provided future
research directions for detecting non-termination bugs in
real-world projects.
2 RELATED WORK
2.1 TerminationAnalysis
The general approach to prove termination is to search for ranking
functions [4,7,10,20,24,40,46,55,58].whichmapaprogramstate
toanelementofsomewell-fundedorderedset.Mosttermination
analysisapproachesrelyonstaticanalysisandconstraintsolvingto
synthesize ranking functions. Podelski et al.[46] proposed an auto-
mated method for proving the termination of an unnested loop by
synthesizing linear ranking functions. Cousot et al.[24] expressed
programsemanticsinpolynomialformandautomatizedtheFloyd/-
Naur/Hoare proof method to verify semialgebraic programs. Chen
et al.[20]reduced non-linearrankingfunctioninference forpoly-
nomialprogramstosemi-algebraicsystemsolvingproblems.Xie
etal.[57]proposethepathdependencyautomatontocapturethe
1https://sites.google.com/view/non-termbug/home
257Large-Scale Analysis of Non-TerminationBugs in Real-WorldOSSProjects ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore
dependencies among the multiple paths in a loop. Ultimate Au-
tomizer [34] covers the whole set of program executions by taking
the union of the languages of several automata, each of which
isprovedtobeterminatingbyexhibitinganappropriateranking
function.Formorecomplexprograms,morecomplexrankingfunc-
tions[4,7,10]are proposedtoprove termination.
Although a lotof termination-proving techniques are proposed,
most of them are incomplete. The failure of proving termination
does not indicate that the program is non-terminating. Hence, this
paper mainly focuses on detecting non-termination bugs, which
cannot be directly solved by the proposed techniques. We also
aim to study real-world non-termination bugs and evaluate the
state-of-the-arttoolsonprovingnon-termination.
2.2 Non-TerminationAnalysis
The general approach to prove non-termination is to search for
recurrentsets .Guptaetal.[33] developed a non-termination p rover
‚ÄúTNT‚Äù,whichprovesnon-terminationbydynamicallyenumerat-
ing lasso-shaped candidate paths to search for counterexamples to
terminationandsearchforarecurrentsetforeachlasso.Giesl et
al.[31]usedconstraintsolvingtofindarecurrentsetinagivenloop
to prove non-termination ofthe loop. Cook etal.[22]proved non-
terminationbyusingabstractinterpretationtoover-approximate
nonlinearprogramsandinferringlinearrecurrentsets.Le etal.[39]
proved non-termination by iteratively collecting executions traces
anddynamicallylearningconditionstorefinerecurrentsets.For
provingthenon-terminationofnon-deterministicprograms,closed
recurrent sets are proposed, which is a stronger notion than re-
current sets. Chen et al.[14] used a safety prover to eliminate
terminating paths iteratively until it finds a closed recurrent set in
theremainingpaths.Larraz etal.[38]proved non-terminationby
Max-SMT-basedinvariantgeneration.
In addition, there are other techniques that tend to identify infi-
nitestates[ 12,13,16,45].Carbin etal.[12]useddynamicaldetec-
tion torecord the program state atthe start of each loopiteration,
and proved non-termination when two consecutive loop iterations
produced the same state. Menendez et al.[45] proposed a method-
ology to detect non-termination issues with a suite of peephole
optimizations. Chatterjee et al.[13] provedthe non-termination of
non-deterministicintegerprogramsbyrelyingonapurelysyntactic
reversal of the program‚Äôs transition system. Xie et al.[56] reduced
the non-termination analysis to a reachability problem, i.e., to find
acounterexample that reaches an infinite state.
Someeffortshavebeenrecentlymadetotakelow-levelprogram-
ming features ( e.g., overflow) into consideration, which could be
helpful for analyzing real-world projects. Schrammel et al.[48]
presented a modular termination analysis for C programs using
template-based inter-procedural summarization towards analyz-
ing real-world software with bit-precise termination arguments
thatweresynthesizedoverlexicographiclinearrankingfunction
templates. Maurica et al.[43] transposed theterminationanalysis
offloating-pointloopsintoterminationanalysisofrationalloops
through the use of an innovative rational approximation, which
covers overflowissues.
Theexistingtechniquesaremainlyevaluatedonstandardsim-
plifiedbenchmarkswhichfailtorepresentmostofthereal-worldnon-termination bugs. This paper aims to study the real-world
non-termination bugs and evaluate the practical value of the state-
of-the-art techniques while identifying potential future research
directions.
2.3 ExistingStudies on Real-WorldBugs
Researchershavemadegreateffortsinexploringtherootcauses
of various bugs and corresponding fix strategies in real-world
projects,includingAndroidbugs[ 17‚Äì19,27,28,41,44,50],OSSfuzz-
bugs [26], buffer overflow bugs [ 59], deep learning bugs [ 36,47],
autonomousvehicle bugs[ 30],etc.. These studieshelp developers
understandthepracticalrelevanceof different bugsandprovidein-
sights through examples for researchers to develop more advanced
detection techniques. However, almost all of them focus on the
violationofsafetyproperties,whilethe violationof livenessprop-
erties(i.e.,non-termination bugs) are not touched.Tothe bestof
our knowledge, our work is the first large-scale empirical study
onnon-terminationbugsinreal-worldprojects.Additionally,we
constructed a new benchmark by simplifying the non-termination
bugsfrom real-world projects.
3 DATA PREPARATION
3.1 Data Collection
In this paper, we mainly study the non-termination bugs in C/C++
projects. We first randomly collected 1,600 C/C++ projects from
GitHubbyGitHubAPIs[ 32].Theseprojectsarecollectedfromtwo
considerations:1)mostofthecodeareC/C++programsand2)they
havedifferentnumbersofstarsrepresentingdifferentpopularity.
The collected projects cover open source projects designed for
variouspurposes( e.g.,database,operatingsystem,mediatools,and
game).Thenwechosefivekeywords, i.e.,‚Äúinfiniteloop‚Äù,‚Äúendless
loop‚Äù, ‚Äúlong loop‚Äù, ‚Äúinfinite recursion‚Äù, and ‚Äúdeep recursion‚Äù, to
identifypotentialnon-terminationbugsfromthecommitmessages
of these projects. Finally, we obtained 3,142 commit messages that
cover466outofthe1,600projects.Table 1showsthedetailedresults
from eachkeyword.
We spent five person-months investigating the collected com-
mits.Specifically,wemanuallyanalyzedthecodesnippetscorre-
sponding to the 3,142 commit messages to understand the root
causes of thenon-termination. Notethat thekeychallenge isthat
there is no oracle for non-termination. Due to the high complexity
of real-world code, it is difficult to understand some code in terms
of whether and why they are non-terminating. We filtered some
commitsthataredifficulttoanalyze:1)theircorrespondingcode
snippets do not contain a clear repeated procedure ( e.g., loop struc-
ture and recursion); 2) the repeated procedures are too complex to
understand( e.g.,loopswithhundredsoflinesofcodeorcommits
with large changes), and 3) the non-termination can be affected by
non-C/C++code.Finally,wekept445commits( i.e.,non-termination
bugs) from 199 real-world projects, which cover the different num-
bers of starsand involve various typesof projects. These commits
mainly belong to the following two categories: infinite loop (318)
andinfinite recursion (127). To confirm these bugs, each of them
isanalyzed,discussed,andconfirmedbyatleasttwoauthors.For
cases that they could not decide, all authors participated in the
258ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore Xiuhan Shi,XiaofeiXie, Yi Li, Yao Zhang,Sen Chen andXiaohongLi.
Table 1:Detailsofthecollected commits.
Keywords #Projects #Commits
infinite loop 313 2,400
endless loop 127 445
long loop 9 27
deep recursion 14 17
infinite recursion 97 253
Total 466 3,142
discussion and confirmation. Note that for the commits that are
filtered,we cannotconclude that they are terminating either.
Finding 1: A large portion (29.1%) of the collected OSS projects
havenon-terminationissues.Inparticular,theconfirmednon-
termination bugs mainly belong to infinite loops (71.5%) and
infiniterecursion (28.5%).
3.2 ManualLabelling
Based on the 445 non-termination bugs, we performed a deep anal-
ysisontherootcauses.Weadoptedanopencardsortstrategy[ 29]
toconstructanewhierarchicaltaxonomyoftherootcauses.Three
oftheauthorsmainlyparticipatedinthetaxonomyconstruction.
Each participant had more than two years of experience in the
researchofterminationanalysis.
Two authors first constructed the leaf categories for all the bugs.
Specifically, in the first round, the two participants individually
analyzed the commit messages, the original code, and the changed
code to define the root causes. In the second round, they had a
discussiontoiterativelyunifythetwoversionsoftheleafcategories.
If there were disagreements between them, other authors joined
the discussionuntil a consensus wasreached.In the thirdround,
we randomly selected 20% of the 445 bugs, which were labeled
by the third participant based on the created leaf categories. For
resultsfromthethirdparticipantthatcontradictedthelabelsofthe
firsttwoauthors,allauthorsdiscussedthemuntilthecontradiction
was resolved by updating the leaf categories or re-labeling the
conflictingcases.Finally,allauthorsdiscussedtheleafcategories
and grouped leaf categories into high-level categories to construct
the hierarchical taxonomy of the root causes. For example, the
common characteristic of ‚Äú Signed Over/f_low Error ‚Äù and ‚ÄúUnsigned
Wraparound Error ‚Äù is overflow, therefore, we grouped these two
leafcategoriesintoahigh-levelcategory ‚Äú Over/f_low‚Äù.
Note that, as infiniteloops and infiniterecursionhavevery dif-
ferentcharacteristics,weadoptedthesamemethodologydescribed
above toestablishthe taxonomies for themseparately.
4 ROOT CAUSES OF INFINITE LOOPS
Figure1showsthe hierarchical taxonomy ofinfinite loopsinclud-
ingfourlevelsofcategories.Ourtaxonomyofinfiniteloopsconsists
of 10 inner categories (marked in grey color) and 16 leaf categories
(marked in white color). To measure the frequency of bugs ap-
pearingineachcategory,wecounted thenumberofbugs ineach
category and the number of projects where the bugs are located,
showninthe upper the right corner ofeachcategory in Figure 1.Ingeneral,therootcausesofinfiniteloopscanbedividedinto
two categories, namely, logical errors (Category 1) that are more
related to the loop structure itself ( e.g., loop condition and loop
iteratorvariable),and generalprogrammingerrors (Category2)that
may affect the loop execution ( e.g., overflow). Specifically, most
of the infinite loops (85.8%) are caused by logical errors that are
rootedattheimproperdesignofloops( e.g.,incorrectusageofloop
iterator variable or incomplete loop condition checking), which
causesthelooptobestuckinastate.Tooursurprise,manyinfinite
loops (14.2%) are caused by general programming errors such as
improper type conversions, even if the logic of the loops is correct.
However,duetootherprogrammingerrorssuchasintegeroverflow
andimplicitcasting,theseloopscanbeexecutedinfinitely.Next,
we providedetailfor eachcategory.
Finding 2: The main reasons for infinite loops are logical er-
rors (85.8% of the bugs covering 92.7% of the projects), indi-
cating the difficulty of designing loops correctly. In addition,
common programming mistakes can make logically-correct
loops execute infinitely (14.2% of the bugs covering 20.4% of
the projects), which may challenge the methods that attempt to
prove(non)termination based only onprogramlogic.
4.1 Logical Error (Category1)
Fromtheprogram-logicperspective,thebehaviorofaloopiteration
depends on the loop condition , theloop iterator variables , and the
controlstatements (e.g.,break).Specifically,theloopcontinuesto
iterate whilethe conditionis true,a loopiteratorvariable(or loop
iterator) serves as an index of the loop and may affect the value
of loop conditions, and control statements may change the flow
ofloopexecution.Logicalerrorsaredividedintothreecategories
related to these three loop elements ( i.e., Category 1.1, 1.2, and 1.3).
In total, there are 10 specific leafcategoriesunderCategory 1.
Finding3: Mostofthelogicalerrorsarecausedbyincorrectloop
iterators(54.6%)andincorrectloopconditions(40.3%).Asmall
numberoferrorsareduetoincorrectcontrolstatements(5.1%).
Furthermore,10differentrootcaseswereidentified,indicating
thediversityoflogical errors.
4.1.1 Loop Iterator Error (Category 1.1). During loop execution,
loopvariablesareupdatediteratively.A Loopiteratorerror refers
to an incorrect update to loop iterators, making the loop condition
to be always true. Updates to loop iterators usually involve only a
few lines of code but are error-prone when their cascading effects
span multiple iterations. We found 149 loop iterator bugs rooted in
differentcauses.
Category1.1.1:MisusingSameLoopIteratorinNestedLoops. We
observed that, in nested loops, developers may confuse the loop
iteratorsof the inner loopswiththoseof the outerloops.There are
sixinfiniteloops(4.0%)thatarecausedbyreusingthe sameiterator
in nested loops.For example, ifthe inner loop incorrectly uses the
loopiteratoroftheouterloop( e.g.,settingittozero),theouterloop
neverterminates.
259Large-Scale Analysis of Non-TerminationBugs in Real-WorldOSSProjects ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore
Root Causes of Infinite Loops
Logical Error (1) 
Loop Iterator Error ( 1.1 )
Misusing Same Loop 
Iterator ( 1.1.1 )No Update for Loop 
Iterator ( 1.1.2 )
Missing Iterator 
Update ( 1.1.2.1 )
Adding/Subtracting 
Zero ( 1.1.2.2 )
Incorrect Bit 
Calculation ( 1.1.2.3 )Initialization Error for 
Loop Iterator ( 1.1.3 )
Missing Initialization 
( 1.1.3.1 )
Incorrect Initialization 
( 1.1.3.2 )Incorrect Update for 
Loop Iterator ( 1.1.4 )Loop Condition Error  
( 1.3 )
Missing Corner-case 
Handling ( 1.3.1 )
Using Erroneous 
Condition( 1.3.2 )Incorrect Control 
Statement ( 1.2 )General Programming Error (2)
Overflow ( 2.1 )
Unsigned 
Wraparound 
Error ( 2.1.1 )
Signed 
Overflow 
Error(2.1.2)Incorrect Variable Type 
( 2.2 )
Type Conversion    
( 2.2.1 )
Type Conversion in Comparison   
( 2.2.1.1 )
Type Conversion in Assignment    
( 2.2.1.2 )Misusing Variable Type 
( 2.2.2 )Undefined Behavior 
( 2.3 )( 318 , 137 )
( 273 , 127 ) ( 45 , 28 )
( 149 , 83 ) ( 14 , 11 ) ( 110 , 66 ) ( 15 , 14 ) ( 24 , 17 ) ( 6 , 4 )
( 6 , 6 ) ( 124 , 76 ) ( 13 , 9 ) ( 6 , 6 )
( 74 , 53 )
( 46 , 34 )
( 4 , 4 )( 3 , 3 )
( 10 , 9 )(7 6,4 8)
(3 4,2 4)(  9 , 9  )
( 6 , 5 )( 14 , 12 ) ( 10 , 10 )
( 9 , 9 )
( 5 , 5 )
Figure 1: Taxonomy ofInfinite Loop.
Category1.1.2:NoUpdatetoLoopIterator. Alargeportionoferrors
are caused when the loop iterators remain constant under some
conditions,makingthe loop stuckwithnoprogress. Specifically, to
oursurprise,thereare74cases(59.7%ofCategory1.1.2)thataredue
tomissingiteratorupdates(Category1.1.2.1).Ouranalysisshows
that the iterator updating statements are missed in 54 cases which
are often due to careless mistakes of developers. The remaining 20
casesarebecausetheiteratorupdatesareplacedincorrectlyafter
thecontinuestatements, not being executed as a result. Another
group of errors (37.1%) is caused when the change made to the
iterator value is effectively zero (Category 1.1.2.2). For example,
inùëñ+=ùë•, the loop iterator ùëñremains unchanged when ùë•is zero.
Bit manipulations (Category 1.1.2.3), such as ‚Äò&‚Äô (AND), ‚Äò|‚Äô (OR),
and ‚Äò‚â™‚Äô (shift left), can also lead to such errors. Figure 2shows an
example of Bit Operation from the project ‚Äúbrltty‚Äù.2In this case,
the loop terminates only if ùë§ùëêbecomes zero. However, since ùë§ùëêis
anextended signedcharactertype( i.e.,wchar_t),theloopmakes
noprogressif ùë§ùëêisnegativebeforeenteringtheloop.Becauseof
theshift-rightoperations, ùë§ùëêwilleventually remain -1,causing a
non-termination.
1 wchar_t wc;
2++static const wchar_t mask=(1< <((sizeof(wchar_t)*8)-6))-1;
3 do{
4 *--byte=(wc& 0X3F)| 0X80;
5--}while(wc>>= 6);
6++}while((wc=(wc>> 6)&mask));
Figure 2: Anexample ofIncorrect BitOperation.
Finding 4: Most (83.2%) of the loop iterator errors are due to
no update to loop iterators. They are due to careless mistakes
2Commit: 5bec3fff0bac50f4b4d4d3b02e70161a2bf38d0f(i.e.,forgottoupdateiterator,43.5%),incorrectlocationsofup-
date statements ( i.e., update after continue statement, 16.1%),
incorrect update to iterators ( i.e., update being zero, 37.1%) and
incorrectbit manipulations (3.2%).
Category1.1.3:InitializationErrorforLoopIterator. Variableini-
tializationisimportantbuterror-prone.Wefound13cases(8.7%)
thatarecausedbytheincorrectinitializationofloopiterators,such
asMissingInitialization (category1.1.3.1)and IncorrectInitialization
(category 1.1.3.2). Uninitialized variables may lead to undefined
behaviors that can cause an infinite loop. Incorrect initialization
can also affect the loop execution, which mainly includes incorrect
positions ofinitialization statements( e.g.,theinitialization forthe
outer loop is incorrectly put in the inner loop) and incorrect ini-
tializationvalues( e.g.,thebinarysearchmaynotterminateifthe
variables lowandhighare not initializedproperly).
Category1.1.4:IncorrectUpdateforLoopIterators. Incorrectup-
dates to loop iterators lead to non-termination. We identified six
infinite loops that are caused by incorrectly updated loop iterators.
NotethatwedistinguishthiscategoryfromCategory1.1.2because
wewouldliketoemphasizethedifferenteffectsofnoupdateand
incorrectupdate.Noupdateforloopiterator( i.e.,Category1.1.2)
causesthelooptogetstuckinonestate,whileincorrectupdates
maycausethelooptogetstuckinarecurrentsetofstates.Figure 3
showsaninfiniteloop3fromtheasteriskproject.Ineachloopitera-
tion,ùëôisdecreasedby2,whichresults inaninfiniteexecutionif ùëô
isinitializedtoanoddnumber.Theupdateshouldvarybasedon
the parityofthe initialvalueof ùëô.
Finding5: Apartfromtheproblemofnoupdatetoloopiterators,
infiniteloops can alsobeintroducedby incorrectinitializations
(8.7%), incorrect updates (4.0%), and incorrect reusing of loop
iterators(4.0%).
3Commit: 3322180d4b452e11545b70abc9b2d5af3d241361
260ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore Xiuhan Shi,XiaofeiXie, Yi Li, Yao Zhang,Sen Chen andXiaohongLi.
1staticvoidunpacksms16 (unsigned char *i,
2unsigned char l,...,unsigned short *ud, ...){
3 unsigned short *o=ud;
4 while(l--){
5 intv=*i++;
6-- if(l--)
7++ if(l&&l--)
8 v=(v<< 8)+*i++;
9 *o++ =v;
10 }
11}
Figure 3: An infinite loop bug of Incorrect Update of Loop
Iterator.
4.1.2 Incorrect Control Statement (Category 1.2). Control state-
mentsare usedto directthecontrol flowof theloopexecution.In
our analysis, 14 of the logical errors (5.1%) are attributed to the
incorrect control statements ( i.e.,break,goto, andcontinue). For
example, the continueandbreakstatements can be misused; break
statements can be placed at incorrect locations, resulting in in-
correct termination condition; and gotostatements may jump to
incorrect program locations.
Finding 6: Incorrect control statements (14 bugs from 11
projects) can also introduce infinite loops, where incorrect break
statementscaused themost (50.00%) non-termination bugs.
4.1.3 Loop Condition Error (Category 1.3). Loop conditions de-
termine whether the loop can start or terminate. A proper loop
condition is critical for the correctness and termination of the loop.
Weobservedthatalargenumberofinfiniteloops(40.3%)arecaused
byincorrect loop conditions.
Category1.3.1:MissingCorner-caseHandling. Theloopcondition
restrictsthescopeofstates( i.e.,differentvaluesofvariables)that
can be reached. If the scope is not well designed, it may cause
infinite execution. We observe 76 (69.1%) bugs caused by loose
conditions that miss handling some corner-cases. 11 of them are
causedbythegeneralincorrectcomparisonoperators( e.g.,useùëñ‚â§0
rather than ùëñ<0). The incorrect comparison operators can miss
someboundarychecking.Figure 4showsaninfiniteloopcausedby
themissingcorner-casehandlingfrom‚Äúlibssh‚Äù.4Thecomparison
operator is not correct, which makes the loop condition always
satisfied. channel_read function returns 0 if no more data can be
read.Theremaining65casesarecausedbylooseconditionsthat
are more relatedtothe specific business logic ofthe programs.
1-while((rc=channel_read(channel, buffer, sizeof(buffer), 0))>= 0){
2+while((rc=channel_read(channel, buffer, sizeof(buffer), 0))>0){
3 fwrite(buffer, 1, rc, stdout);
4}
Figure 4: Anexample ofMissing Corner-case Handling.
4Commit: 1b15896e8b29561447fff9a7bcaa028179eab51bCategory 1.3.2: Using Erroneous Condition. It is worth noting that
thereare34bugs(30.9%)causedbythetotallyincorrectloopcondi-
tions. These conditionsmayuse incorrect iterator variables,incor-
rectterminationlogic,or TRUEcondition(thevalueisalwaystrue),
indicatingthedifficultyofsettingcorrectterminationconditions
insomeloops.Figure 5showsaninfiniteloopfrom‚Äúbinutils-gdb
‚Äù.5.Itisobviousthattheloopconditioncanalwaysbetruewhen
cached_frame->reg_countisnot zero.
1--for(inti=0; cached_frame ->reg_count; i ++)
2++for(inti=0;i<cached_frame ->reg_count; i ++)
3 xfree (cached_frame ->reg[i].data);
Figure 5: Anexample ofUsing Erroneous Condition.
Finding 7: A large part of logic errors (40.3%) are due to the
incorrectloopconditions.Mostofthem(69.1%)areaffectedby
improper corner-case handling, which reveals that developers
shouldbeverycarefulontheloopconditions( e.g.,theboundary).
What is more worrisome is that 30.9% of them are caused by
completely incorrect loop conditions that usually depend on the
businesslogic.
4.2 GeneralProgrammingError (Category2)
In additionto the logicalerrors about the loopdesign, weobserve
that general programming errors can also lead to infinite loops,
whichaccountfor14.2%infiniteloops.Specifically,integeroverflow,
variable type casting and undefined behavior can affect the update
ofloopiterators,resultinginnon-termination.Theseerrorsarenot
directlyrelatedtothelooplogic.Hence,itishardtodetectthem
byexistingterminationtools(seeSection 6)thatmainlyfocuson
the logicerrors.
4.2.1 Overflow (Category 2.1). Without good consideration for
overflow,developerscanmisestimatetheupdateofloopiterators
during the loop execution. We observe 15 infinite loops (4.7%) that
are caused by overflow including Unsigned Wraparound Error (Cat-
egory 2.1.1)and Signed Over/f_low Error (Category 2.1.2).
Category 2.1.1: Unsigned Wraparound Error. For unsigned integer
types, wraparound operations will be executed when the value
of the variable is out of scope. For example, the result of the ex-
pression‚ÄúUINT_MAX+1‚Äùwillbe0,whichiswell-defined.Dueto
the wraparound of unsigned numbers, the loop iterators can never
breakthe loop condition, causing infinite loops. We find 9infinite
loops due to the wraparound of unsigned numbers, which account
for2.83%ofallinfiniteloops.Figure 6showsanexampleinfinite
loop from ‚Äúmupdf‚Äù.6ùë†ùëñùëßùëí_ùë°is an unsigned type. If ùëõis less than 16,
ùëõwillbe wrappedaround to be anotherlarge positive value.
Category 2.1.2: Signed Over/f_low Error. It is well-defined that
wraparoundoperationwillbeexecutedwhenoverfloworunderflow
ofunsignedintegeroccurs.Butwhenoverflowoccurs,theresultsof
5Commit: 8455d26243aef72f7b827ec0d8367b6b7816de07
6Commit: ce9d4462423ac74a1dbbc4ce52c2c81cfcdda766
261Large-Scale Analysis of Non-TerminationBugs in Real-WorldOSSProjects ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore
1voidpdf_encrypt_data (...,size_tn){
2 while(n>0){
3 size_tlen=n;
4-- n-= 16;
5++ n-=len;
6 }
7}
Figure 6: Anexample ofUnsigned WraparoundError.
signed integer types maybe various. In general, wraparound opera-
tionwillbeexecutedwhenoverfloworunderflowofsignedinteger
occurs,i.e., the result of expression INT_MAX+1 is INT_MIN [ 25].
Similarly, Signed Over/f_low Error leads to the abnormal change of
loopiterators,leadingtoinfiniteexecution.Wetotally find6such
bugs,accountingfor1.89% ofallloopbugs.
4.2.2 Incorrect Variable Type (Category 2.2). The storage of differ-
enttypesofvariablesisdifferent( i.e.,differentranges).Incorrect
use of variable types can also cause infinite loops by changing the
valueofloopiteratorsabnormally.Thereare24bugsinthiscate-
goryincluding TypeConversion (Category2.2.1)and MisuseVariable
Type(Category 2.2.2).
1 uint16_t s,len;
2--for(s=seqnum; s <seqnum+len; s++){
3++for(i=0,s=seqnum; i <len; i++,s++){// int i,len
4 ... }
Figure 7: Anexample ofType ConversioninComparison.
Category 2.2.1: Type Conversion. When the types of left values
and right values do not match, the type conversion can happen
inassignmentstatementsandcomparisonstatements,whichcan
affect the value of loop iterators and loop conditions. There are
atotalnumberof14bugscausedbytypeconversionincluding9
TypeConversionin Comparison bugs(Category2.2.1.1) and 5 Type
ConversioninAssignment bugs(Category2.2.1.2).Figure 7showsan
infiniteloopfrom‚Äúowntone-server‚Äù.7Thisloopwillgetstuckwhen
ùë†ùëíùëûùëõùë¢ùëö+ùëôùëíùëõis greater than UINT16_MAX. In this case, bit expan-
sionwilloccur,andthetypeoftherightvalueintheloopcondition
willbealarge32-bitinteger, i.e.,itisgreaterthanUINT16_MAX.
However,themaximumvalueoftheleftvalue( i.e.,ùë†)islessthan
orequaltoUINT16_MAX,indicatingthattheloopconditionwill
be always TRUE. Type Conversion in Assignment (Category 2.2.1.2)
involves the type conversion in assignment statements. For exam-
ple,the valueofthe loop iterator can be truncatedifit is assigned
to asmall type sothat itneverbreaksthe loopcondition.
Category 2.2.2: Misusing Variable Type. The type of a variable
determinestherangeofitsvalues.Theincorrecttypemaylimitthe
range of the loop iterator, which can lead to an infinite loop. We
totally find 10 bugs caused by misusing variables, which accounts
for3.14%ofinfiniteloops.Figure 8showsaninfiniteloopbugfrom
7Commit: f9bfec180f91671d8ba72a01cab1781c1f5e99991--u32 div1, div2;
2++intdiv1, div2;
3 for(div1=1; div1>= 0; div1--)
4 for(div2=7; div2>= 0; div2--)
5 ....
Figure 8: Anexample ofMisusingVariable Type.
‚Äúlinux_media‚Äù.8Becauseùëëùëñùë£1andùëëùëñùë£2areunsignedvariable, they
never become negative. Hence, the loop condition ùëëùëñùë£1‚â•0 and
ùëëùëñùë£2‚â•0willbe alwaysTRUE.
Finding 8: Not like logic errors that directly affect the loop
execution,generalprogrammingerrorscanalsoaffecttheloop
execution,whichmaybeverydifferentasexpectedbydevelopers.
Specifically,over/f_low(4.7%)andincorrectvariabletype(7.5%)
can implicitly change the value of loop iterators and loop condi-
tions, which leads to infinite loops. Furthermore, such errors are
verycomplexandsubtle,eachtakinganaverageofanhourto
analyzeandconfirm.
4.2.3 Undefined Behavior (Category2.3). During our classification,
we find some potential infinite bugs caused by undefined behavior
andtheterminationoftheseprogramsmaybedifferentindifferent
compilersandplatforms.Thebest-knownexamplesofundefined
behaviors[ 37]inprogramminglanguagescomefromCandC++,
which have hundreds of them, including simple local operations
(overflowingsignedintegerarithmetic). UndefinedBehavior could
makeunexpectedconsequences( e.g.,SilentBreakage,TimeBombs),
which depends on different compilers and platforms [ 25].9The
unexpectedconsequencescanaffecttheterminationofloops.Inour
study,undefinedbehaviorisarootcauseofinfiniteloop,accounting
for 1.9%ofallloopbugsandinvolving 2.92% projects.
1 uint64_t val;
2 inti, bytes =1;
3--while(val>>bytes*8) bytes++;
4++while(val>>bytes*8 &&bytes<8) bytes++;
Figure 9: Anexample ofUndefined Behavior.
Figure9showsapotentialnon-terminationloopbugfrom‚ÄúFFm-
peg‚Äù.10When the value of ùëèùë¶ùë°ùëíùë†is 8,ùë¢ùëñùëõùë°64_ùë°>>64 is an unde-
finedoperationleadingtotheundefinedbehavior.Itsvaluevaries
in differentcompilers and platforms, i.e., the loop can be infinitely
executedifitsvalueisparsedasnon-zero.Theconfirmationofthis
categoryofbugsisdifficult.Weconfirmedthesebugsfrom1)the
commitmessagesthatclearlypointoutthenon-terminationand
2) we reproduce them by simplifying the program. For example,
we compile the loop in Figure 9with gcc (version 7.3.0) in Ubuntu
8Commit: 090341b0a95d1f6d762915a75c13b393366f4ab3
9These typesof bugs aremainly confirmed fromthe commitmessages
10Commit: d597655f771979c70c08f8f8ed84c1319da121e8
262ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore Xiuhan Shi,XiaofeiXie, Yi Li, Yao Zhang,Sen Chen andXiaohongLi.
Root Causes of Infinite Recursion
Incorrect Recursion Design ( 1 )
Incorrect Arguments
( 1.1 )
Incorrect Return ( 1.2 )
Deep Recursion ( 1.3 )Unexpected Recursion ( 2 )
Incorrect Self-invoking ( 2.1 )
Misusing Namespace ( 2.1.1 )
Miscalling Inherited Method ( 2.1.2 )
Misusing Method Overloading ( 2.1.3 )
Missing undef Instruction ( 2.1.4 )Incorrect Cyclic Invoking (2.2)
( 12 , 11 )
( 6 , 4 )
( 15 , 13 )
( 5 , 5 )( 38 , 30 ) ( 24 , 16 )( 62 , 43 )( 127 , 70 )
( 65 , 40 )
( 7 , 7 )
( 25 , 18 )
( 33 , 22 )
Figure 10:TaxonomyofInfinite Recursion.
4.15.0.Thevalueof ùë£ùëéùëôwasinitializedto-1,thusthisloopfallsinto
an infinite loop.
Finding 9: Undefined Behavior (1.9%)couldlead topotential
infinite loop bugs, which is more difficult to confirm as it
depends onthe compilersandplatforms.
5 ROOT CAUSES OF INFINITE RECURSION
Recursion11isanotherrepeatedstructurethatoneofthestepsof
the function reenters the function itself. Figure 10illustrates the
hierarchical taxonomy of infinite recursion bugs in real-world C
and C++ projects. Generally speaking, our taxonomy of infinite
recursion bugs consists of 4 inner categories (in grey) and 8 leaf
categories(inwhite).
Finding 10: Infinite recursion accounts for a large portion
(28.5%) of non-termination bugs. 51.2% of the bugs are caused
byIncorrectRecursion thatmeanstheincorrectdesignofrecur-
sions.48.8%ofthebugsarecausedby UnexpectedRecursion ,i.e.,
developers do not intend to use recursions, but the recursions
are unexpectedlygenerateddueto programming errors.
5.1 Incorrect Recursion Design (Category1)
Theterminationofrecursionmainlydependsonthe argument that
will be sent to the parameters of the recursive function and the
returnthatcandeterminetheexitofthecurrentiteration.Ingeneral,
the incorrect recursion is mainly caused by Incorrect Arguments
(Category1.1), IncorrectReturn (Category1.2)and DeepRecursion
(Category 1.3).
Category 1.1: Incorrect Arguments. We observe 7 infinite re-
cursions (10.8%) in Incorrect Recursion that are caused by using the
unchangedarguments.Similarwithloop,theargumentsdetermine
the number of iterations. If the arguments keep unchanged, the
recursion gets stuck to a state ( i.e., the values of arguments do not
change)leadingto the infinite execution.
11Due to the space limit and the complex structure of recursion, we put more detailed
examples and discussions onourwebsite.Category 1.2: Incorrect Return. Most (38.5%) of the incorrect
recursions are caused by the incorrect return12. It is because of the
incomplete condition for return. For example, the current iteration
should exit, but couldn‚Äôt because of an incorrect return condition.
Category 1.3: Deep Recursion. We also find a large part of re-
cursion bugs (50.7%) in Incorrect Recursion that can cause stack
overflow rather than non-termination bugs, so are linked with a
dashed line in Figure 10. When recursion is executed, the variables
andsomeinformationneedtobesavedintostack.Astherecursion
can be excessively deep, it causes call stack buffer overflow. The
Deep Recursion bugs are related to complex data structures ( e.g.,
binarytreetraversal,compilationprocess,anddatabaseoperations).
Finding11: 10.8%oftheincorrectrecursionsarecausedwhen
incorrectarguments( e.g.,unchangedvalue)areusedforthe
recursions.Determiningtheconditionforreturningvalueis
error-prone, which accounts for 38.5% of incorrect recursions.
In addition, a largeportion ofbugs (50.7%) in incorrect recur-
sions are deep recursion which may lead to stack overflow
althoughthey can terminateintheory.
5.2 Unexpected Recursion (Category2)
Programmingerrorscanleadtounexpectedrecursionthatdoesnot
terminate.Specifically,our study showsthat UnexpectedRecursion
involves62infiniterecursionbugsthatcover61.4%(43/70)projects.
The major reasons include Incorrect Self-invoking (Category 2.1)
andCyclic Invoking (Category 2.2).
Category2.1:IncorrectSelf-invoking Thereare38infiniterecur-
sions (29.9%) caused bythat the functioninvokes itself incorrectly
and unintentionally. Specifically, 12 of them are due to Misusing
Namespace (Category2.1.1).Thefunction ùëÄ::ùëìintendstoinvoke
another function ùëÅ::ùëìwhereùëÄandùëÅare different namespaces.
However, developers forget to use ùëÅcausing it to call itself. 6 of
themareduetothe MiscallingInheritedMethod (Category2.1.2).In
C++ inheritance, the method ùëöin a child class ùê¥intends to invoke
the method ùëöin another child class ùêµ, However, developers forget
to use the class name ùêµ(i.e.,ùêµ::ùëö), thusùê¥::ùëöcalls itself. 15 of them
aredueto MisusingMethodOverloading (Category2.1.3).Ithappens
whenthemethod ùëöintendstoinvokeanotheroverloadedfunction
ùëöbut it incorrectlyinvokes itself ( i.e., using thesame arguments).
5of themare causedby Missingundef Instruction (Category2.1.4).
Forthiscategory,developersfirstuse#definetodefineanidentifier
ùê¥as a function ùêµ. However, in the function ùêµ, it invokes ùê¥(i.e.,
itself) again before undef ùê¥.
Category2.2:IncorrectCyclicInvoking. ComparedtoCategory
2.1 which involves self-invoking, there are 24 of infinite recursions
(18.9%)thatarecausedbycycliccalling.Giventwofunctions ùê¥and
ùêµ,i fùê¥callsùêµandùêµalso calls ùê¥, then the unexpected cyclic calling
isformed,causing an infinite execution.
12Withoutlossofgenerality,arecursivefunctionthatdoesnotreturnanythingcanbe
considered to returnnull.
263Large-Scale Analysis of Non-TerminationBugs in Real-WorldOSSProjects ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore
Finding 12: Our study shows that the number of infinite
recursionscausedbyunexpectedrecursionandincorrectre-
cursion are very close (65 and 62), indicating that unexpected
recursionisalsoimportantfornon-terminationchecking.The
main reasons include the unexpected self-invoking (61.3%)
andunexpectedcyclic-invoking(38.7%).
6 EMPIRICALSTUDYON TERMINATION
ANALYSIS TOOLS
In this section, we introduce the benchmark extraction based on
the 445 non-termination bugs and conduct an assessment of the
SOTA tools based on the extracted benchmark to answer RQ2. We
thenconductanin-depthanalysisforthedetectionfailuresofthese
toolsto answer RQ3.
6.1 BenchmarkExtraction
To evaluate the performance of the state-of-the-art tools in analyz-
ingtheterminationofreal-worldprograms,oneimportantstepisto
setup a ground-truth benchmark with real-world non-termination
bugsbasedonaseriesofvaliditycriteria.Thisisbecausereal-world
sourcecodecontainsnoisesthatarenotrelevanttonon-termination
bugs, and existing tools cannot be directly applied to real-world
projects. For ensuring the representativeness of our benchmark,
we extracted and sliced our benchmark from 445 bugs based on
thefollowingprinciples: (0) BugsFiltration .Thenon-termination
bugs should be further filtered because most non-termination bugs
haveverycomplexdependencies(e.g.,thebugsdependonmultiple
codefiles,complexvariabletypes,andAPIs).Wekeepsmall-size
bugsandfiltercomplexbugsbecauseitismoredifficultforusto
guaranteethecorrectnessoflarge-scalebenchmarksandexisting
benchmarks often cannot support complex dependencies. After
this step, we keep 56 bugs to construct our benchmark from 445
non-termination bugs and used them for assessment. (1) Context
Simplification . For infinite loop bugs, we follow four steps: First,
weidentifyalltheloopiterations(definedin¬ß 4.1)andretainthe
completeloopcondition.Second,weretaininstructions( e.g.,if-else
branch)andobjectsinthesourcecodeoftheprojectthatinvolve
loop iterators, which can change the value of loop iterators. Then,
weretainallcontrolinstructionsanddatestructure( e.g.,circular
linked list). Finally, we remove other instructions that are extra-
neouswiththe loopin the project.For infinite recursion bugs,we
retain the instructions related to the value change of recursion
parameters. (2) Function Rewriting . We rewrite the function and
retaintheeffectandreturnvaluesofthefunction(includingAPI
function and customfunction).Forrecursive bugs,we focus more
attentiononretainingrecursivecallsbetweenfunctions. (3)Reserve
NameandType .Wekeeptheconsistentnameandtypeofvariables
andfunctionsinourbenchmarkwithprojects. (4) MakeBenchmark
Executable . We adapt the selected loops and recursion functions
by putting the loops and the first function call of recursion in a
mainfunctionandaddingnon-deterministicinitializationforthe
variablestomakethemexecutable.Notethatweextractedthenon-
termination benchmark based on non-termination bugs and the1intmain(){
2 unsigned char l=__VERIFIER_nondet_uchar();
3 while(l--)
4 if(l--){//loop }
5 return0;
6}
Figure 11:Benchmarkprogram extracted from Figure 3.
terminationbenchmarkfromthecorrespondingfixedversionsrely-
ing on the above principles. We highlight that the extraction of the
recursionbenchmarkismoredifficultthanloopbecauseitinvolves
moredatastructuresandfunctioncalls.Finally,weconstructedour
benchmark set, including a non-termination dataset with 56 real
andreproduciblenon-terminationbugsanda terminationdataset
with58fixedprograms.Throughourstatistics,theaveragenum-
bersoflinesinSV-COMP2021benchmarksandourbenchmarks
are 20.82 and24.52, respectively.
Figure3shows an infinite loop and the corresponding extracted
benchmarkisshown inFigure 11.First, basedonthedefinitionof
loop iterator in ¬ß 4.1, the unsigned char variable ùëôis a loop iterator
inloopcondition (Line 4).Therefore,we retainthe sourcecode in
Line 2, 4 and 6 (7) to our benchmark (correspond to Line 2, 3 and 4
inFigure 11).Othervariables( ùë£,ùëñ,and/u1D45C)canbeignoredbecause
theydonotimpactanyloopiteratorsandloopterminationproperty
of this benchmark. Notice that we keep the consistent name of
variables ( ùëô) and variable type (unsigned char) in our benchmark
with real-world projects and we set ùëôto be non-deterministic. In
addition,we setamain function to make itexecutable.
CorrectnessofBenchmark. Sincetheextractedbenchmarksmay
containmistakesduetosubjective biases(detailsin¬ß 7.2), we put
lotsofefforttoensuringthe correctnessofourbenchmarks( e.g.,
whether it can terminate or not). First, we manually verify our
benchmarkwithatleastthreeco-authors.Onlyifalltheauthors
confirmthebenchmark,weaccepttheresults.Fornon-termination
benchmarks,except for themanualconfirmation, we alsodirectly
run the program by setting the potential bug-triggering values. We
ensurethatthebenchmarkscannotterminateinhalfanhourwhich
could be a reasonable indicator because our program is simple and
hasnohugebound( e.g.,i<1000000).Forterminatingbenchmarks,
theoretically,itisdifficulttoensurethattheprogramscantermi-
nateforallinputs.Exceptforourmanualconfirmation,wefound
thatexistingtoolsalso rarelydeterminethemasnon-terminating
whichcouldbeanindicatorforthecorrectnessofterminatingcases.
Finally,weconstructabenchmarkset,includinganon-termination
datasetwith56realandreproduciblebugsandaterminationdataset
with58fixedversions.Notethat2non-terminatingprogramsre-
latedtoundefinedbehaviorareremovedfromourbenchmarkbe-
cause they cannotbe successfully reproduced.
6.2 ToolAssessment
In this section, our goal is to explore whether the termination of
programsinourbenchmarkcanbedeterminedcorrectlybystate-of-
the-artterminationanalysistools.Inordertomakeourassessment
264ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore Xiuhan Shi,XiaofeiXie, Yi Li, Yao Zhang,Sen Chen andXiaohongLi.
48%
47%
5%
53%
33%
14%
74%
26%
0%
65%
31%
4%
73%
17%
10%28.53%
71.47%
0%
50.82%
48.73%
0.45%
55.69%
44.17%
0.14%
49.98%
50.02%
0%
71.34%
28.66%
0%0%10%20%30%40%50%60%70%80%
UAutomizer CPAchecker 2LS A3ro9( T2Our benchmark Existing benchmark
Figure 12: Comparison results of the termination analysis
tools on theexisting benchmarkandours.
moreconvincing,weselectfiveexistingtoolsforconductingourex-
periment:UAutomizer[ 34],CPAchecker[ 9],2LS[48],AProVE[ 31],
andT2[11].Amongthem,UAutomizerwonthefirstprizeinthe
termination category from SV-COMP 2017 to SV-COMP 2021 [ 51].
CPAcheckerand2LSrespectivelywonthesilverandbronzeforthe
terminationcategoryinSV-COMP2020andSV-COMP2021.The
performanceofAProVEisdemonstratedintheannualinternational
competitionofTerminationTools,andAProVEgotthetopthree
fromSV-COMP2017toSV-COMP2019.T2ispowerfulandmore
successful than Julia [ 49] and TNT [ 33], which is demonstrated
in[14].Therefore,ourselectedfivetoolsarerepresentativetools
forterminationanalysis.Theversionsofthesetoolsweusedinthe
experimentsare:UAutomizer(0.2.2,providedversionforSV-COMP
2022),CPAchecker(2.0),2LS(0.9.5),AProVE(providedaversionfor
SV-COMP 2022), and T2 (2016 version). Note that, we tested these
fivetoolsinUbuntu4.15.0withamemorylimitof14.6GiBofRAM,
aruntimelimitof15min ofCPUtime,and alimitto8 processing
unitsofaCPU,the same configurationsusedin SV-COMP.
We evaluate our benchmark on the state-of-the-art termina-
tion analysis tools, however, these tools cannot directly work on a
part ofspecial variable typesand functionsin real-worldprojects.
Therefore,wefirstreplacethesespecialvariabletypeswiththeir
supportedtypesandrewritethefunctionswiththeformthatcanbe
supported in the termination analysis tools, e.g., file type variables
arereplacedbyarray.Wefindthatthefivetoolsallcannotworkon
the C++benchmark but can work on the C benchmark. Therefore,
14 recursion benchmarks involving C++ characteristics ( e.g., class,
inheritance) cannot be accepted by these five tools. In conclude,
we test 100 benchmarks in C programs in total, and 90 of them are
loops,theothersarerecursions.Weprovidereplicationpackages
(including log files, command lines, and our benchmark files) on
Zenodo13andwemakethepackagesavailableforotherstoallow
other researchers and practitioners to generate interesting ideas
andbuilduponour work.
13DOI:10.5281/zenodo.6548310Table 2: The result of these five tools on our benchmark
involving special features. UA. refers to UAutomizer and Ap.
presentsAProVE.UNreferstoUNKNOWNandWrefersto
WRONG.
Features(Total) Cate. UA. CPA 2LS Ap. T2 Avg. Perc.
Pointer
Manipulation (10)UN 81 0 1 09 1 0 9.494.00%
Recursion (10) UN 57 7 7 1 0 7.272.00%
Array (16) UN 91 6 1 3 1 4 1 6 13.685.00%
Data Structure (14) UN 81 2 1 2 1 3 1 4 11.884.29%
Over/f_low (16)UN 10 5 10 11 8 8.855.00%
W 36 0 3 3 3.018.75%
Type (10)UN 72 6 7 4 5.252.00%
W 04 0 1 3 1.616.00%
Bit Calculation (15)UN 5 2 11 14 6 7.650.67%
W 36 0 0 4 2.617.33%
Total(67) UN+W 43 51 48 59 56 51.476.72%
Figure12showsthestatisticalresultsofthesetoolsonourbench-
mark.Overall,thecapabilitiesofthesefivetoolstomakecorrect
verdictsdropcomparedwithexistingbenchmarks.Amongthem,
the capabilities of UAutomizer to make correct verdicts drop most,
from 71.47% correctly in SV-COMP 2021 [ 8] to 47% correctly in
ourbenchmark.Besides,asshowninFigure 12,allfivetoolspre-
fer to answer ‚ÄúUNKNOWN‚Äù, which indicates the complexity of
our benchmark is more than that in existing benchmarks. The
dropping in accuracyand thepreferenceto answer‚ÄúUNKNOWN‚Äù
involvestwomainreasons: (1)Duringourbenchmarkextraction,
we set the precondition of these programs to be non-deterministic,
which causes an over-approximation to their real preconditions
and makes termination analysis more complex. For example, in
Figure3and Figure 11, the value of ùëôdepends on the valuepassed
when calling the function, and we set ùëôto be non-deterministic. (2)
The benchmark extracted from real-world projects may contain
complexcomputation( e.g.,bitcalculation,pointermanipulation),
various data structures ( e.g., linked list), and data type ( e.g., size_t).
Furthermore, the error rate of these tools is increased in Figure 12.
Among them, CPAchecker has the highest error rate ( i.e., 14%),
more than 30 times the error rate in SV-COMP 2021 [ 8](i.e., 0.45%).
Wealsotriedtoanalyzetherelationshipbetweenthesuccessrate
anddifferentcategories14.Ingeneral,thesetoolsperformbetter
ontheLogicalErrorcategorythanGeneralProgrammingErrorcat-
egory,confirmedthatexistingtoolsmainlyprove(non)termination
logically. For Logical Error benchmarks, since they have been man-
uallysimplifiedfromreal-worldprojects,thesetoolscouldhandle
them relatively easier. To our surprise, the non-terminating bench-
marksabout ReusingSameLoopIterator cannotbehandledbyall
toolsalthoughtheylookquitesimple.Forothers,wecouldnotfind
a clear relation between the success rate and different leaf cate-
gories. Therefore, we further manually analyzed the failed cases
and summarized common features that revealed the weaknesses of
existing tools(refer to Section 6.3).
14Due to the space limit, more details including the results of each tool and the results
oneachcategorycanbefoundonourwebsite [ 3].
265Large-Scale Analysis of Non-TerminationBugs in Real-WorldOSSProjects ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore
6.3 AnalysisoftheUnhandled Cases
BasedontheresultsshowninFigure 12,comparedwiththeresults
on existing benchmarks, the error rate of four tools except 2LS
and the ‚ÄúUNKNOWN‚Äù rate of these five tools are raising on our
benchmark.Therefore,wefurtheranalyzetheseunhandledbugs
to explore the weaknessesoftheseexisting tools.
Table2shows the results that the tools cannot handle bench-
marksinvolvingspecialfeatures.Thefirstcolumnrepresentsthe
special features that can significantly affect the results of the tools.
We also list the total number of benchmarks involving correspond-
ing features. The second column refers to the results that the tools
analyze these programs. First, all of these special features in the
firstcolumncanmaketheterminationanalysistoolsprefertoan-
swer ‚ÄúUNKNOWN‚Äù, especially for the pointer manipulation . 94.00%
benchmarksinvolving pointermanipulation areunhandledbythese
tools.However ,thesespecialfeaturesarecommonlyusedinreal
world, which indicates that the state-of-the-art tools are inefficient
andimmature in analyzing the terminationofreal-world projects.
Exceptformakingthesetoolsprefertoanswer‚ÄúUNKNOWN‚Äù,
somefeaturescanaffectthesoundnessofthesetools( i.e.,wrong
answers),whichshouldbepaidmoreattention.Itismainlybecause
some programming errors caused by Over/f_low, Type , andBit Calcu-
lation,whichcanchangethe ideal executionofprograms,are not
well considered.For example, on average, the programs involving
Over/f_low, Type , andBit Calculation can introduce 18.75%, 16.00%
and 17.33% wrong results, respectively. This strongly indicates that
the termination analysis techniques should take these features into
account to make them sound and more practical. In addition, we
observe that 2LS doesnot have any wrong answersbecausethese
potentialprogrammingerrorshave been considered[ 48].
Finding 13: We identify seven programming features that
can pose challenges to the existing termination analysis tools.
Theytendtoproduceunknownanderroneousresults(76.72%)
onthe programs involving thesefeatures.
7 DISCUSSIONS
7.1 Implications
For program developers. Firstly, the findings from our study can
help avoid non-termination bugs for developers in developing pro-
grams.Specifically,whenworkingonloops,developersshould(1)
becarefulwiththewritestoloopiteratorsandensuretheloopvari-
ablesneverendupstayingconstant;(2)becarefulwiththereuseof
loop iterators; (3) check for possible overflow and type conversion
errors,andcarefullychooseappropriatevariabletypes.Forrecur-
sions, programmers should be careful about unexpected recursions
andpay attentionto the recursion arguments andreturns.
Secondly, we provide useful advice for troubleshooting non-
terminationbugs.Specifically,fixstrategiesofinfiniteloopsmainly
include: (1) Add missing constraints to loop conditions . This fixes
incorrectly chosen loop condition that is inconsistent with the pro-
grammers‚Äô expectations. (2) Handle specific values . Most infinite
loops end up being stuck in one state. Developers should first iden-
tify the problematic program state and then handle specific values(e.g.,addanifstatementand‚Äúbreak‚Äùtheexecution fromtheloop)
forthestate.(3) Useloopcounters .Loopcounterscanlimitthemax-
imum executions of the loop. This fix strategy is simple but may
leadtoerrorsinsubsequentprocedures.Itisareasonablechoice
whenthevalueofeachvariableattheendoftheloophasnoimpact
ontheexecutionofthesubsequentcode.Forinfiniterecursions,the
developersshouldidentifyifrecursionisusedintentionally.Ifso,
they mainly correct the argument as well as the return. Otherwise,
one shouldbreakfrom the recursive orcycliccalls.
For researchers. Based on the experimental results in ¬ß 6.2,w e
noticed that these tools fail to work on real-world projects directly
and perform worse on our real-world benchmark than on exist-
ingwell-establishedbenchmarks.Therefore,existingtermination
analysis tools should be improved in terms of their scalability and
applicabilityonreal-worldprojects.Furthermore,generalprogram-
ming errors,suchasoverflows, should be paidmore attention in
future terminationanalysisresearch.
7.2 Threatsto Validity
Thecollectionofreal-worldprojectsmayintroducebias.Tomiti-
gate this threat, we downloaded 1,600 C/C++ projects to expand
the evaluation scope with our best efforts. Furthermore, we further
selectedfivecommonlyusedkeywordstoidentifypotentialnon-
termination-related commits. Due to the complexity of real-world
projects,theclassificationofthenon-terminationbugsinevitably
involvessubjectivebiases.Toaddressthis,wefilteredourdataset
basedonwell-thought-out criteria, mentionedin¬ß 3.1.Whilecon-
structingthenon-terminationbenchmark,thenecessarysimplifi-
cation and abstractionmay change the original program behaviors.
Tomitigate sucha threat,eachbenchmarkextractedwasinspected
by two authors independently and any discrepancy was discussed
until aconsensus wasreached.
8 CONCLUSION
Inthispaper,weconductedastudyof445non-terminationbugs
collected from 199 real-world OSS projects. With substantial man-
ualefforts,wepresentedasystematictaxonomyofnon-termination
bugs including 16 categories of infinite loops and 8 groups of re-
cursions,andfurtherextractedanovelbenchmarkincluding114
programs simplified from these bugs. Moreover, we evaluated five
state-of-the-art termination analysis tools using our newly con-
structed benchmark and identifiedchallenges that these tools face.
Finally, we highlighted the limitations of existing termination anal-
ysistechniques anddiscussednewresearch directions.
9 DATA AVAILABILITYSTATEMENT
Thedatathatsupportthefindingsofthisstudyareopenlyavailable
in[2]andthe artifact isopenlyavailable in[ 1].
ACKNOWLEDGMENTS
This work was partially supported by the National Natural Science
Foundation of China (No. 61872262), the Ministry of Education,
SingaporeunderitsAcademicResearchFundTier1(21-SIS-SMU-
033, T1-251RES1901), Tier 2 (MOE2019-T2-1-040, T2EP20120-0019),
andTier 3(MOET32020-0004).
266ESEC/FSE ‚Äô22, November14‚Äì18, 2022,Singapore, Singapore Xiuhan Shi,XiaofeiXie, Yi Li, Yao Zhang,Sen Chen andXiaohongLi.
REFERENCES
[1]2022.ArtifactforLarge-ScaleAnalysisofNon-TerminationBugsinReal-WorldOSS
Projects.https://doi.org/10.34740/kaggle/ds/2440949
[2]2022.DataforLarge-ScaleAnalysisofNon-TerminationBugsinReal-WorldOSS
Projects.https://zenodo.org/record/6548310#.Yn-DBOhByUk
[3]2022.Large-ScaleAnalysisofNon-TerminationBugsinReal-WorldOSSProjects .
https://sites.google.com/view/non-termbug/home
[4]Sheshansh Agrawal, Krishnendu Chatterjee, and Petr Novotn√Ω. 2017. Lexico-
graphic Ranking Supermartingales: An Efficient Approach to Termination of
Probabilistic Programs. Proc. ACM Program. Lang. 2, POPL, Article 34 (dec 2017),
32pages. https://doi.org/10.1145/3158122
[5]ChristopheAlias,AlainDarte,PaulFeautrier,andLaureGonnord.2010. Multi-
dimensionalRankings,Program Termination,andComplexity Boundsof Flow-
chart Programs. In Static Analysis , Radhia Cousot and Matthieu Martel (Eds.).
Springer Berlin Heidelberg, Berlin, Heidelberg, 117‚Äì133.
[6]MohamedFaouziAtig,AhmedBouajjani,MichaelEmmi,andAkashLal.2012.
Detecting Fair Non-termination in Multithreaded Programs. In Computer Aided
Verification ,P.MadhusudanandSanjitA.Seshia(Eds.).SpringerBerlinHeidel-
berg, Berlin, Heidelberg, 210‚Äì226.
[7]AmirM.Ben-AmramandSamirGenaim.2015. ComplexityofBradley-Manna-
Sipma Lexicographic Ranking Functions. In Computer Aided Verification , Daniel
Kroening and Corina S. PƒÉsƒÉreanu (Eds.). Springer International Publishing,
Cham, 304‚Äì321.
[8]DirkBeyer.2021. SoftwareVerification:10thComparativeEvaluation(SV-COMP
2021). In Tools and Algorithms for the Construction and Analysis of Systems ,
JanFrisoGrooteandKimGuldstrandLarsen(Eds.).SpringerInternationalPub-
lishing, Cham, 401‚Äì422.
[9]DirkBeyerandM.ErkanKeremoglu.2011. CPAchecker:AToolforConfigurable
SoftwareVerification.In ComputerAidedVerification ,GaneshGopalakrishnan
andShazQadeer(Eds.).SpringerBerlinHeidelberg,Berlin,Heidelberg,184‚Äì190.
[10]Aaron R. Bradley, Zohar Manna, and Henny B. Sipma. 2005. Linear Ranking
withReachability.In ComputerAidedVerification ,KoushaEtessamiandSriramK.
Rajamani (Eds.).Springer Berlin Heidelberg, Berlin, Heidelberg, 491‚Äì504.
[11]Marc Brockschmidt, Byron Cook, Samin Ishtiaq, Heidy Khlaaf, and Nir Piter-
man.2016. T2:TemporalPropertyVerification.In ToolsandAlgorithmsforthe
Construction and Analysis of Systems , Marsha Chechik and Jean-Fran√ßois Raskin
(Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 387‚Äì393.
[12]Michael Carbin, Sasa Misailovic, Michael Kling, and Martin C. Rinard. 2011.
DetectingandEscapingInfiniteLoopswithJolt.In ECOOP2011‚ÄìObject-Oriented
Programming , Mira Mezini (Ed.). Springer Berlin Heidelberg, Berlin, Heidelberg,
609‚Äì633.
[13]KrishnenduChatterjee,EhsanKafshdarGoharshady,PetrNovotn√Ω,andunde-
finedorundefinede ≈Ωikeliƒá. 2021. Proving Non-Termination by Program Re-
versal. In Proceedings of the 42nd ACM SIGPLAN International Conference on
Programming Language Design and Implementation (Virtual, Canada) (PLDI
2021). Association for Computing Machinery, New York, NY, USA, 1033‚Äì1048.
https://doi.org/10.1145/3453483.3454093
[14]Hong-YiChen, Byron Cook, Carsten Fuhs, Kaustubh Nimkar, andPeter O‚ÄôHearn.
2014. Proving Nonterminationvia Safety. In Toolsand Algorithms forthe Con-
struction and Analysis of Systems , Erika √Åbrah√°m and Klaus Havelund (Eds.).
Springer Berlin Heidelberg, Berlin, Heidelberg, 156‚Äì171.
[15]Hong-Yi Chen, Cristina David, Daniel Kroening, Peter Schrammel, and Bj√∂rn
Wachter. 2015. Synthesising Interprocedural Bit-Precise Termination Proofs. In
Proceedingsofthe30thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (Lincoln, Nebraska) (ASE ‚Äô15). IEEE Press, Lincoln, Nebraska, 53‚Äì64.
https://doi.org/10.1109/ASE.2015.10
[16]JianhuiChenandFeiHe.2020. ProvingTerminationby<i>k</i>-Induction.In
Proceedingsofthe35thIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering (Virtual Event, Australia) (ASE ‚Äô20) . Association for Computing
Machinery, New York, NY, USA, 1239‚Äì1243. https://doi.org/10.1145/3324884.
3418929
[17]Sen Chen, Lingling Fan, Guozhu Meng, Ting Su, Minhui Xue, Yinxing Xue,
Yang Liu, and Lihua Xu. 2020. An empirical assessment of security risks of
globalAndroidbankingapps.In 2020IEEE/ACM42ndInternationalConference
onSoftwareEngineering (ICSE) . IEEE,1310‚Äì1322.
[18]Sen Chen, Ting Su, Lingling Fan, Guozhu Meng, Minhui Xue, Yang Liu, and
Lihua Xu. 2018. Are mobile banking apps secure? what can be improved?. In
Proceedingsofthe201826thACMJointMeetingonEuropeanSoftwareEngineering
Conference and Symposium on the Foundations of Software Engineering . 797‚Äì802.
[19]Sen Chen, Yuxin Zhang, Lingling Fan, Jiaming Li, and Yang Liu. 2022. AUSERA:
Automated Security Risk Assessment for Vulnerability Detection in Android
Apps.InProceedingsofthe37thACM/IEEEInternationalConferenceonAutomated
SoftwareEngineering . 1‚Äì5.
[20]Yinghua Chen, Bican Xia, Lu Yang, Naijun Zhan, and Chaochen Zhou. 2007.
DiscoveringNon-linearRankingFunctionsbySolvingSemi-algebraicSystems.
InTheoretical Aspects of Computing ‚Äì ICTAC 2007 , Cliff B. Jones, Zhiming Liu,
andJim Woodcock (Eds.). SpringerBerlin Heidelberg, Berlin, Heidelberg, 34‚Äì49.[21]International Conference on Tools and Algorithms for the Construction and
Analysis of Systems 2021. Collection of Verification Tasks . International Con-
ferenceonToolsandAlgorithmsfortheConstructionandAnalysisofSystems.
Retrieved Oct 5,2021 from https://github.com/sosy-lab/sv-benchmarks/
[22]Byron Cook, Carsten Fuhs, Kaustubh Nimkar, and Peter O‚ÄôHearn. 2014. Disprov-
ingTermination with Overapproximation. In Proceedingsof the 14th Conference
on FormalMethods in Computer-Aided Design (Lausanne, Switzerland) (FMCAD
‚Äô14). FMCADInc, Austin,Texas,67‚Äì74.
[23]ByronCook,AndreasPodelski,andAndreyRybalchenko.2011. ProvingProgram
Termination. Commun.ACM 54,5(may2011),88‚Äì98. https://doi.org/10.1145/
1941487.1941509
[24]Patrick Cousot. 2005. Proving Program Invariance and Termination by Para-
metricAbstraction,LagrangianRelaxationandSemidefiniteProgramming.In
Verification, Model Checking, and Abstract Interpretation , Radhia Cousot (Ed.).
Springer Berlin Heidelberg, Berlin, Heidelberg, 1‚Äì24.
[25]WillDietz,PengLi,JohnRegehr,andVikramAdve.2015. UnderstandingInteger
Overflow in C/C++. ACM Trans. Softw. Eng. Methodol. 25, 1, Article 2 (dec 2015),
29pages. https://doi.org/10.1145/2743019
[26]Zhen Yu Ding and Claire Le Goues. 2021. An Empirical Study of OSS-Fuzz Bugs.
In2021IEEE/ACM18thInternationalConferenceonMiningSoftwareRepositories
(MSR). IEEE,131‚Äì142.
[27]LinglingFan,TingSu,SenChen,GuozhuMeng,YangLiu,LihuaXu,andGeguang
Pu. 2018. Efficiently manifesting asynchronous programming errors in Android
apps. InProceedings of the 33rd ACM/IEEE International Conference on Automated
SoftwareEngineering . 486‚Äì497.
[28]LinglingFan,TingSu,SenChen,GuozhuMeng,YangLiu,LihuaXu,GeguangPu,
and Zhendong Su. 2018. Large-Scale Analysis of Framework-Specific Exceptions
in Android Apps. In Proceedings of the 40th International Conference on Software
Engineering (Gothenburg, Sweden) (ICSE‚Äô18) . Associationfor Computing Ma-
chinery, New York, NY, USA, 408‚Äì419. https://doi.org/10.1145/3180155.3180222
[29]SallyFincherandJoshTenenberg.2010. Makingsenseofcardsortingdata. Expert
Systems22,3 (2010), 89‚Äì93.
[30]JoshuaGarcia,YangFeng,JunjieShen,SumayaAlmanee,YuanXia,.Chen,andQi
Alfred.2020. Acomprehensivestudyofautonomousvehiclebugs.In Proceedings
oftheACM/IEEE42ndInternationalConferenceonSoftwareEngineering .385‚Äì396.
[31]J√ºrgenGiesl,MarcBrockschmidt,FabianEmmes,FlorianFrohn,CarstenFuhs,
Carsten Otto, Martin Pl√ºcker, Peter Schneider-Kamp, Thomas Str√∂der, Stephanie
Swiderski,andRen√©Thiemann.2014. ProvingTerminationofProgramsAutomat-
icallywithAProVE.In AutomatedReasoning ,St√©phaneDemri,DeepakKapur,and
ChristophWeidenbach(Eds.).SpringerInternationalPublishing,Cham,184‚Äì191.
[32]GitHub2022. GitHubDocs . GitHub. RetrievedMar10,2022from https://docs.
github.com/cn
[33]Ashutosh Gupta, Thomas A. Henzinger, Rupak Majumdar, Andrey Rybalchenko,
andRu-GangXu.2008. ProvingNon-Termination. SIGPLANNot. 43,1(jan2008),
147‚Äì158. https://doi.org/10.1145/1328897.1328459
[34]Matthias Heizmann, Jochen Hoenicke, and Andreas Podelski. 2014. Termination
Analysis by Learning Terminating Programs. In Computer Aided Verification ,
ArminBiereandRoderickBloem(Eds.).SpringerInternationalPublishing,Cham,
797‚Äì813.
[35]Huaxun Huang, Lili Wei, Yepang Liu, and Shing-Chi Cheung. 2018. Under-
standing and detecting callback compatibility issues for android applications. In
Proceedingsofthe33rdACM/IEEEInternationalConferenceonAutomatedSoftware
Engineering . 532‚Äì542.
[36]Md Johirul Islam, Giang Nguyen, Rangeet Pan, and Hridesh Rajan. 2019. A
comprehensive study on deep learning bug characteristics. In Proceedings of the
201927thACMJointMeetingonEuropeanSoftwareEngineeringConferenceand
Symposium onthe FoundationsofSoftwareEngineering . 510‚Äì520.
[37]ISO/IECJTC1/SC22Programminglanguages,theirenvironmentsandsystem
softwareinterfaces1999. ISO/IEC9899:1999Programminglanguages‚ÄîC . ISO/IEC
JTC1/SC22Programminglanguages,theirenvironmentsandsystemsoftware
interfaces. https://www.iso.org/standard/29237.html
[38]Daniel Larraz, Kaustubh Nimkar, Albert Oliveras, Enric Rodr√≠guez-Carbonell,
and Albert Rubio. 2014. Proving Non-termination Using Max-SMT. In Computer
AidedVerification ,ArminBiereandRoderickBloem(Eds.).SpringerInternational
Publishing, Cham, 779‚Äì796.
[39]Ton Chanh Le, Timos Antonopoulos, Parisa Fathololumi, Eric Koskinen, and
ThanhVuNguyen.2020. DynamiTe:DynamicTerminationandNon-Termination
Proofs.Proc.ACMProgram.Lang. 4,OOPSLA,Article189(nov2020),30pages.
https://doi.org/10.1145/3428257
[40]YingwenLin,YaoZhang,SenChen,FuSong,XiaofeiXie,XiaohongLi,andLintan
Sun. 2021. Inferring Loop Invariants for Multi-Path Loops. In 2021 International
SymposiumonTheoreticalAspectsofSoftwareEngineering(TASE) .63‚Äì70.https:
//doi.org/10.1109/TASE52547.2021.00030
[41]Yepang Liu, Chang Xu, and Shing-Chi Cheung. 2014. Characterizing and De-
tecting Performance Bugs for Smartphone Applications. In Proceedings of the
36th InternationalConference on SoftwareEngineering (Hyderabad, India) (ICSE
2014). Association for Computing Machinery, New York, NY, USA, 1013‚Äì1024.
https://doi.org/10.1145/2568225.2568229
267Large-Scale Analysis ofNon-Termination BugsinReal-WorldOSSProjects ESEC/FSE ‚Äô22, November 14‚Äì18,2022, Singapore,Singapore
[42]ShanLu,SoyeonPark,EunsooSeo,andYuanyuanZhou.2008. Learningfrom
mistakes: a comprehensive study on real world concurrency bug characteristics.
InProceedings of the 13th international conference on Architectural support for
programming languagesand operating systems .329‚Äì339.
[43]FonenantsoaMaurica,Fr√©d√©ricMesnard,and√âtiennePayet.2016. Termination
AnalysisofFloating-PointProgramsUsingParameterizableRationalApproxima-
tions.InProceedingsofthe31stAnnualACMSymposiumonAppliedComputing
(Pisa,Italy) (SAC‚Äô16).AssociationforComputingMachinery,NewYork,NY,USA,
1674‚Äì1679. https://doi.org/10.1145/2851613.2851834
[44]TylerMcDonnell,BaishakhiRay,andMiryungKim.2013. AnEmpiricalStudyof
API Stability and Adoption in the Android Ecosystem. In 2013 IEEE International
ConferenceonSoftwareMaintenance .70‚Äì79.https://doi.org/10.1109/ICSM.2013.18
[45]David Menendez and Santosh Nagarakatte. 2016. Termination-Checking for
LLVMPeepholeOptimizations.In Proceedingsofthe38thInternationalConference
onSoftwareEngineering (Austin,Texas) (ICSE‚Äô16) .AssociationforComputingMa-
chinery, New York, NY, USA, 191‚Äì202. https://doi.org/10.1145/2884781.2884809
[46]AndreasPodelskiandAndreyRybalchenko.2004. ACompleteMethodforthe
Synthesis of Linear Ranking Functions. In Verification, Model Checking, and
Abstract Interpretation , Bernhard Steffen and Giorgio Levi (Eds.). Springer Berlin
Heidelberg, Berlin, Heidelberg, 239‚Äì251.
[47]Lili Quan, Qianyu Guo, Xiaofei Xie, Sen Chen, Xiaohong Li, and Yang. Liu. 2022.
Towards UnderstandingtheFaultsofJavaScript-BasedDeepLearningSystems.
In37thIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering
(ASE ‚Äô22).
[48]Peter Schrammel and Daniel Kroening. 2016. 2LS for Program Analysis. In Tools
and Algorithms for the Construction and Analysis of Systems , Marsha Chechik
andJean-Fran√ßoisRaskin(Eds.).SpringerBerlinHeidelberg,Berlin,Heidelberg,
905‚Äì907.
[49]FaustoSpoto,FredMesnard,and√âtiennePayet.2010. ATerminationAnalyzer
for Java Bytecode Based on Path-Length. ACM Trans. Program. Lang. Syst. 32, 3,
Article 8(mar2010), 70pages. https://doi.org/10.1145/1709093.1709095
[50]Sufatrio,DarellJ.J.Tan,Tong-WeiChua,andVrizlynnL.L.Thing.2015. Securing
Android:ASurvey,Taxonomy,andChallenges. ACMComput.Surv. 47,4,Article
58(may2015), 45pages. https://doi.org/10.1145/2733306
[51]International Conference on Tools and Algorithms for the Construction and
Analysis of Systems 2021. Result of 10th Competition on Software Verification
(SV-COMP 2021) . International Conference on Tools and Algorithms for the
Construction and Analysis of Systems. Retrieved Oct 5, 2021 from https://sv-
comp.sosy-lab.org/2021/results/results-verified/[52]TheTerminationProblemDatabase2021. TheTerminationProblemDatabase.
Retrieved1Jul 2021 from https://github.com/TermCOMP/TPDB
[53]HaijunWang,Xiaofei Xie,YiLi,ChengWen,YuekangLi,YangLiu,Shengchao
Qin, Hongxu Chen, and Yulei Sui. 2020. Typestate-guided fuzzer for discovering
use-after-free vulnerabilities. In 2020 IEEE/ACM 42nd International Conference on
Software Engineering (ICSE) .IEEE, 999‚Äì1010.
[54]Lili Wei, Yepang Liu, Shing-Chi Cheung, Huaxun Huang, Xuan Lu, and Xuanzhe
Liu. 2018. Understanding and detecting fragmentation-induced compatibility
issues for android apps. IEEE Transactions on Software Engineering 46, 11 (2018),
1176‚Äì1199.
[55]Xiaofei Xie, Bihuan Chen, Yang Liu, Wei Le, and Xiaohong Li. 2016. Proteus:
ComputingDisjunctiveLoopSummaryviaPathDependencyAnalysis.In Pro-
ceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations
ofSoftwareEngineering (Seattle,WA,USA) (FSE2016) .AssociationforComputing
Machinery,NewYork,NY,USA,61‚Äì72. https://doi.org/10.1145/2950290.2950340
[56]XiaofeiXie,BihuanChen,LiangZou,Shang-WeiLin,YangLiu,andXiaohong
Li.2017. Loopster:StaticLoopTerminationAnalysis.In Proceedingsofthe2017
11th Joint Meeting on Foundations of Software Engineering (Paderborn, Germany)
(ESEC/FSE 2017) . Association for Computing Machinery, New York, NY, USA,
84‚Äì94.https://doi.org/10.1145/3106237.3106260
[57]XiaofeiXie,BihuanChen,LiangZou,YangLiu,WeiLe,andXiaohongLi.2019.
AutomaticLoopSummarizationviaPathDependencyAnalysis. IEEETransactions
on Software Engineering 45, 6 (2019), 537‚Äì557. https://doi.org/10.1109/TSE.2017.
2788018
[58]XiaofeiXie,YangLiu,WeiLe,XiaohongLi,andHongxuChen.2015. S-Looper:
Automatic Summarization for Multipath String Loops. In Proceedings of the 2015
International Symposium on Software Testing and Analysis (Baltimore, MD, USA)
(ISSTA2015) .AssociationforComputingMachinery,NewYork,NY,USA,188‚Äì198.
https://doi.org/10.1145/2771783.2771815
[59]Tao Ye, Lingming Zhang, Linzhang Wang, and Xuandong Li. 2016. An empirical
study on detecting and fixing buffer overflow bugs. In 2016 IEEE International
Conference on Software Testing, Verification and Validation (ICST) . IEEE, 91‚Äì101.
268