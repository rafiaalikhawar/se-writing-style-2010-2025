Language-Agnostic Dynamic Analysis of Multilingual Code:
Promises,Pitfalls,and Prospects
HaoranYang
WashingtonStateUniversity
Pullman, WA, USA
haoran.yang2@wsu.eduWenLi
WashingtonStateUniversity
Pullman, WA, USA
wen.li@wsu.eduHaipeng Cai∗
WashingtonStateUniversity
Pullman, WA, USA
haipeng.cai@wsu.edu
ABSTRACT
Analyzingmultilingualcode holistically iskeytosystematic quality
assuranceofreal-worldsoftwarewhichismostlydevelopedinmul-
tiplecomputerlanguages.Towardsuchanalyses,state-of-the-art
approachesproposeanalmost-fully language-agnostic methodology
andapplyittodynamicdependenceanalysis/slicingofmultilingual
code, showing great promises. We investigated this methodology
through a technical analysis followed by a replication study apply-
ing it to 10 real-world multilingual projects of diverse language
combinations. Our results revealed critical practicality (i.e., having
the levels of efficiency/scalability, precision, and extensibility to
various language combinations for practical use) challenges to the
methodology.Basedontheresults,wereflectontheunderlying pit-
fallsof the language-agnostic design that leads to such challenges.
Finally, looking forward to the prospects of dynamic analysis for
multilingual code, we identify a new research direction towards
better practicality and precision while not sacrificing extensibility
much, as supported by preliminary results. The key takeaway is
that pursuing fully language-agnostic analysis may be both im-
practical and unnecessary, and striving for a better balance between
languageindependenceand practicality may be more fruitful.
CCSCONCEPTS
·Software and its engineering →Dynamic analysis .
KEYWORDS
multi-language software,multilingualcode,dynamic analysis
ACM ReferenceFormat:
Haoran Yang, Wen Li, and Haipeng Cai. 2022. Language-Agnostic Dynamic
Analysis of Multilingual Code: Promises, Pitfalls, and Prospects. In Proceed-
ingsofthe30thACMJointEuropeanSoftwareEngineeringConferenceand
Symposiumonthe FoundationsofSoftware Engineering (ESEC/FSE’22),No-
vember14ś18,2022,Singapore,Singapore. ACM,NewYork,NY,USA, 6pages.
https://doi.org/10.1145/3540250.3560880
1 INTRODUCTION
Softwarefailures areconsequentialandcostly.Afundamentalap-
proach to assuring software quality hence mitigating these failures
∗Haipeng Caiis thecorresponding author.
ESEC/FSE ’22,November 14ś18, 2022, Singapore, Singapore
©2022 Copyright held bytheowner/author(s).
ACM ISBN978-1-4503-9413-0/22/11.
https://doi.org/10.1145/3540250.3560880is to verify program behaviors via dynamic analysis [ 16,17,37].
For instance, among other such analyses, dynamic dependence
analysis[ 15,26](includingoneofitsspecialforms,dynamicslic-
ing[36]),hasempoweredarangeofapplicationsinsoftwarequality
assurance(e.g.,faultdiagnosis[ 20,25],securitytesting[ 33,35,47]).
Meanwhile, most (80+%) real-world software today is multilingual
(i.e., the program is written in multiple languages), according to re-
centstudiesregardlessofthesamplesize(e.g.,around1,000[ 52]or
over 15,000 [ 63]) and data sources (e.g., at major companies [ 41] or
inthe open-source world [ 57,58]). The latest studyconfirmed the
status quo: only 18% of the studied systems use one language [ 50].
In this context, holisticanalysis of multilingual code is key to
systematicqualityassuranceofreal-worldsoftwaresystems[ 48].
To understand this critical need, consider a few specific cases. In
severalsamplesofAndroidmalware[ 12],themainapplogicinone
languageinvokedmaliciouscodeinanotherlanguage.Forinstance,
thegamemalware com.tinker.gameone [32]retrievestheuser’s
Facebook credential through its C# code, and passes the private
datatoanuntrustworthyremoteserverinitsJavacode.Suchissues
alsohavebeenfoundintheAndroidframeworkitself.Forexample,
asreported inCVE-2016-6691[ 55], the framework called, fromits
JavacodeviatheJavanative interface(JNI), the Qualcomm Wi-Fi
gbk2utfmodule in C++which hadGBKencodingerrors.
Yet cross-languagebugs are not limited toone language combi-
nation(e.g,Java-C)or oneinterfacing mechanism (e.g.,JNI)[ 49],
albeit the onlyfewprior relevant worksavailable all targeted that
particularcase(i.e.,Java-CwithJNI)[ 11,39,40,46].Forinstance,
recently Li et al. [ 51] demonstrated multiple cases of high-severity
securityvulnerabilitiesofdifferentkindsthathappenacrossPython
andC code in popularopen-source projects such as NumPy [ 61].
While these examples are about security defects, cross-language
correctness defectswouldhappenthesameway.Therootcauseis
common: thedefectsoriginatedinthecodewritteninonelanguage
(i.e.,onelanguageunit)propagatedtoandwereonlyexhibitedina
differentlanguageunit .Itwouldbedifficultforsingle-languagetech-
niques/tools[ 19,21ś24,28]tofindthesedefectsastheirunderlying
analysesarenotholisticÐtheydismisscross-languagedependen-
ciesandbehaviors.Manualapproaches(e.g.,codereview)arenot
always practical because humans can get easily lost in complex,
large codebases like that of NumPy (one million SLOC) [ 61]. To ad-
dressthischallenge,thestate-of-the-artapproach Orbs[13]andits
follow-upworks[ 14,44,45]proposeandpromote language-agnostic
dynamic analysis for multilingual code, focusing on (dynamic) pro-
gramslicingasademonstratingcase.Herebeinglanguage-agnostic
means total language independence Ðthe analysis is designed with-
out assuming (i.e., independently of) any specific knowledge about
the particularlanguages usedin the multilingualsoftware.
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
1621
ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore Haoran Yang,WenLi, andHaipeng Cai
Giventhegeneraldiversity(intermsofvaryinglanguagecom-
binations used) of multilingual code, the promises of the language-
agnostic methodology advocated in these prior approaches are
highly meritorious, both intuitively (e.g., it would work for any
language combinations)and based ontheirevaluation results.Yet
as we arguably and empiricallyshow, there are also major pitfalls
underneath this methodology that risk practicality. Ultimately, the
sensible pursuit should be on the balance between the language
independence of the analysis design and the practicality of the
analysiswithrespectto real-world multilingualsoftware.
In this paper, we reflect on thelanguage-agnostic methodology
as demonstrated in Orbs[13], the core in the line of works around
it. We first briefly revisit how it works and the promises it holds
(§2), followed by discussing the pitfallsas illustrated through a
replication study of Orbsagainst 10 randomly chosen multilin-
gualprojectsonGitHub( §3).Weofferinsightsintoourempirical
findingsandlayoutanewresearchdirectiontowardsalternative
tradeoffsbetweenlanguageindependenceandpracticalitythatlead
tomorepracticalsolutions( §4),aswelookforwardtothe prospects
oflanguage-agnostic dynamicanalysisofmultilingualcode.
Openscience.Our artifact for this paper isavailable on figshare.
2 THE PROMISES
The state-of-the-art multilingual analysis, Orbs[13], achieves the
greatestlanguage-independencetodateÐitinstrumentsatthegiven
query(i.e.,slicingcriterion,whichincludesacodelinenumberand
a variable on that line), and the rest of the analysis is language
agnostic. It works by tentatively deleting some other code lines,
recompiling and executing the remaining code, and checking if the
variable’svaluechangesÐifso,thoselinesaredeleted.Thisprocess
isrepeateduntilnomorelinescanbedeleted,andtheremaining
code linesare consideredthe dynamicslice ofthe query.
Indeed,peritsinnerworkings, Orbsonlyrequiresprobingfor
therun-timevaluesofcriterionvariablesintheenclosinglanguage
unit.Otherthanthislanguage-specificstep,theanalysisdoesnotas-
sumeanyknowledgeabout(thesyntaxorsemantics)thelanguages
involved in the multilingual code under analysis. This language-
agnosticdesignholdsgreatpromises,becausemultilingualsoftware
isdiverseandcomplex.Priorstudiesonsuccessfulprojectsintop
companies reported that there were 2,500 languages in use and
most applications were written in 2 to 15 languages [ 41]. Later
studies basedon open-source projects found that more than half
of the samples used two or more languages. Most recently, further
studiesshowedthatmultilingualcodeusesavarietyoflanguage
combinations (e.g., java c++ ,python shell ,javascript ruby
php)[50]anddiversemechanismsforinterfacingbetweendifferent
language units (e.g., one unit calling another via explicit calls to
foreign functions, one unitembedding another) [ 51].
With these levels of diversity and complexity, it is clearly desir-
able to have an analysis be agnostic of the underlying languages of
a given multilingual program, as it implies that the analysis can be
perfectlygeneralizedtoanygivenmultilingualsoftwarewithout
additional (e.g., language-specificengineering) effort. Theoriginal
evaluationexperimentsfor Orbs[13]consolidatedthepromisesÐit
worked reasonably well for not only small benchmarks (of a fewhundredlinesofcode),butalsowith(foursourcefileschosenfrom)
areal-world multilingualproject Bash(aUnixshell).
In sum, as in non-code-based approaches (e.g., entirely drop-
pinganycodeanalysis)[ 18],thelanguage-agnosticmethodology
demonstratedvia Orbsappearedto be highly promising.
3 THE PITFALLS
Despite its appealing promises, the language-agnostic design in-
stantiatedin Orbs[13]couldfacepracticalitychallengeswithlarge-
scale, real-world multilingual systems. The largest-scale real-world
case studied in the original Orbsevaluation only considered a
quitesmallportion(foursourcefiles)oftheproject,ratherthanthe
holisticsystem.Asaresult,thecomplexitydealtwithmaynotbe
representative ofthat ofawhole,real-world multilingualsystem.
3.1 Technical Analysis
Technically,thedesignmaysufferfromafewlimitationsthatmake
it impractical: (1) since the code lines to remove must be deleted
togetherandlinesaregroupedspeculatively[ 13](despiteaidsof
simple heuristics [ 14,45]), it can take numerous trials, resulting in
alongtimetodeleteevenoneline(e.g.,upto1minuteperlinefora
smallprogramof2KLOC[ 45]);(2)everysingletrialrequiresacom-
pleterecompilationandthenre-executionoftheentiresoftware,
another potential source of overhead and inefficiency; (3) it only
works with source code, because it relies on deleting the code at
sourcelevel and (re)buildingthe sourceafter deletion;and (4) itis
semi-automatedasitrequiresuserstowritemultiplescriptsthatfit
the inner workings of the analysis for each system under analysis.
As a result, the technique is not applicable where recompilation is
infeasible(e.g.,sourcecode isunavailableorincomplete).
The fact that the deleted lines are grouped speculatively has
another potential consequenceÐthese linesmay not be maximally
removable foreach instanceof the line-deletionoperation. Inpar-
ticular,sincethegroupingisheuristicandtentativewhilehaving
tobedonescrupulouslytoreducethepossibilityof(re)compilation
failure, there may often be code lines that could be deleted but are
not comprehensively identified for deletion. The consequence is
that the resulting slice may include many code lines that should
not be in the slice (i.e., they should have been deleted since the
criterion is not dependent on them). In other words, the language-
agnosticmethodologyof Orbsmayresultinanexcessiverateof
false positives (i.e.,greatimpression).
Aboveall,thegreatestbarrierwiththelanguage-agnosticmethod-
ology in Orbsmay be its efficiency and scalability. Follow-up
works achieved valuable improvements (e.g., enabling forward
slicing[44]Ðtheoriginalimplementationof Orbsonlyworksfor
backward slicing, mitigating the efficiency issue [ 45]), but the prac-
ticality (efficiency/scalability wise) challenge remains due to the
unchangednature ofthe language-agnostic methodology.
3.2 Empirical Analysis
Tovalidatetheabovedissectionandunderstandthegap,weper-
formedareplicationstudyon Orbsusingtheartifactsharedbythe
authorsintheirpaper [ 13].
Dataset: Wetargetedopen-sourcemultilingualprojectsonGitHub
that primarily used two or all of three programming languages:
1622Language-AgnosticDynamic Analysis of Multilingual Code: Promises,Pitfalls,andProspects ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore
Table 1:Efficiency results of Orbson real-world systems.
Subject Languagecombination Codesize #Qfin.Time (hrs)
Pyrasite[ 1]python c++ 1,580 10 2.67
Affinity[ 2]java c++ 4,677 0 24+
Pyjnius [3]python java 5,071 10 7.36
Snappy [4]java c++ shell 14,615 0 24+
Pysonar2[ 5]java python 18,247 0 24+
Deap[6]python c 22,491 7 22.2
sbe[7] java c++ c 48,406 0 24+
brotli [8]c c# java javascript 51,073 0 24+
Vertx-web[ 9]java python 124,942 0 24+
Mongo[10]c++ javascript python 178,735 0 24+
Python,C/C++,andJava,becausetheyarewidelyconsideredmain-
streamlanguages andcommonly rankedamongthetop-5lists by
various sources (e.g., [ ?]). Among all such projects, we sampled
thosethatarepopular(i.e.,with1,000ormorestars)andactive(i.e.,
updated within the last six months). We also dismissed projects
where the language unit in any of the three targeted languages
accounts for less than 1% of total project code size. Then, from the
resultingsample,werandomlyselected10projectsthatcoverall
possiblecombinationsof thethreeprimarylanguages,asoutlined
inTable1.The firstcolumn gives the projectname andlink.
Metrics: As per our technical analysis of the pitfalls, we mainly
examinetheefficiencyof Orbsintermsoftheslicingtimecost.For
eachslicingcriterion,weseta timeoutof24hours ,whichisareason-
ablylargebudgetthatadeveloperpossiblyaffordsinpractice.In
addition, concerning the practical usefulness of the resulting slices,
we also look at the slice sizeÐgenerally the smaller slices are more
desirablebecausedevelopersmaynotaffordinspectingavery-large
slice,especiallygiventhat Orbsitselfdoesnotprovideadditional
guidance(e.g.,inspectionprioritiesorrankingofstatementsina
slice) for the post-slicing analysis.
Procedure: Wehaveapplied Orbstothe10chosenmultilingual
systems,onaUbuntu18.04.5LTSserverwithIntel(R)Xeon(R)CPU
E7- 4870 2.40GHz and512GB RAM.
For each subject, we randomly picked one test to exercise it
and10queries(i.e.,slicingcriteria)tocomputedynamicslicesfor,
suchthateachlanguageunitcontainsthenumberofqueriesthat
is proportional to the code size of the unit. For a given criterion, if
Orbsdoesnotfinishtheslicingwithin24hours,weterminatedit
andconsideredthe casea timeout/failure.
Results: TheoverallefficiencyresultsaresummarizedinTable 1.
Thelanguagesforwhichatleastonequerywaspickedarelistedin
the second column, and the total code size of each subject in the
third.Thefourthcolumn( #Qfin.)indicatesthenumberofqueries
withwhich Orbssuccessfully finishedthe slicing in24 hours.
As shown, only 3 (relatively small) subjects saw some queries
finished within the timeout, and Orbstimed out for any query
of the other subjects. For the only 27 (out of 100 total) queries it
returnedaslice for,the averagecostwas9.5 hoursper query.
Table2outlinesthefurtherdetailsonthe27successfullyfinished
cases,includingtheslicingcriterion( SC)no.(2ndcolumn),theslice
sizeÐthe number of source lines of code (SLOC) in the slice (3rd
column),andthenumberofhours( hrs)spentoncomputingeach
slice(lastcolumn).The sliceratio Ðtheratiooftheslicesizetothe
total number of executed lines in the subject execution underlying
the slicing (4th column)Ðprovides another perspective into theslicesizewithrespecttotheworst-caseslicingresults(i.e.,allthe
executedlinesare consideredpart of the slice).
Table 2: Detailed results
on the finished cases of
slicing. (Sb.: Subject; Sn.:
Slicing criterion no.; Ss.:
Slicesize(SLOC);Sr.:Slice
ratio (%);Th.: Time (hrs)
Sb.Sn.Ss.Sr.Th.Pyrasite113211%3.00
218815%3.18
318815%3.15
412911%3.10
512911%3.40
611810%1.94
711810%1.95
811810%1.93
913511%2.48
1013511%2.60Pyjnius12,96283%8.33
22,96183%8.29
32,52171%8.32
42,96283%8.36
52,61273%5.79
62,54071%8.42
72,97784%8.42
82,97383%8.42
92,34166%4.69
102,97383%4.53Deap15,46053%19.63
25,46053%19.84
35,46053%23.99
75,00849%21.99
85,00849%22.60
95,00849%23.28
105,00849%23.75Asintheoriginal Orbsevaluation,
wedidnothavetheground-truthslic-
ing results to compute precision and
recall. Yet the numbers of Table 2
show that Orbsis very likely to be
excessively impreciseÐit produced
more than halfofthe executedcode
lines in all of the slices for the two
relative large subjects.
3.3 KeyInsights
Overall, the empirical results ap-
peared to corroborate the results
of our technical analysis ( §3.1): the
language-agnostic design instanti-
atedinOrbssufferedcriticalefficien-
cy/scalability barriers and was sub-
jectto excessive imprecision.
Taking a closer look into the re-
sults, we observed that in all the fail-
ure(timeout)cases, Orbswasstuck
inunfruitfulcyclesbetweenrecompi-
lation and line deletion (because the
deletioncausesfailurestocompile).
The underlying reason, as outlined
earlier,wasthat Orbsmade heuristic attemptsinidentifyingthe
group of code lines to delete without even fully knowing about the
syntactic(nottomentionsemantic)relationshipsamongthoselines.
Asaresult,themajorityofsuchattemptsfailedastheremaining
program withthoselinesdeletedfailedto compile.
Meanwhile, in the small percentage of cases in which it finished
the slicing within 24 hours, Orbsoften identified excessively large
groupsofcodelinestodelete.Inparticular,whenheuristicallyform-
ing the group of code lines to delete, the deletion-line grouping
step often ended up also including the lines that have no depen-
dence relationships with the slicing criterion,The result was the
excessively-largedynamicslices,asseenespeciallyinthecasesof
Pyjnius.Apparently,therewasnoconsistentcorrelationbetween
thedegree ofthisimprecision andthetotalcodesizeofthemulti-
lingual systemÐe.g., Deap is much larger than Pyjnius (22.5 verus
5.1 KLOC), but the former saw much smaller slices produced by
Orbs(50% versus80%) interms of slice ratio.
Inshort,thisreplicationstudyledustothefollowing insights:
(1)theneedforalmostnoknowledgeaboutanylanguagemakes
Orbsalmost fully language-agnostic, yet that lack of knowledge
also led to totally uninformed hence opportunistic line deletion,
a core step in the design of the language-agnostic methodology;
thus, (2) a more practical design would need to strike a better
balance between language independence and efficiency/scalability
byutilizing slightly more knowledge abouteachlanguage.
4 THE PROSPECTS
Followingtheinsightsobtainedfromourtechnicalandempirical
analyses( §3.3),webelieveitis necessarytoexploreothertradeoffs
1623ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore Haoran Yang,WenLi, andHaipeng Cai
Analysis algorithm
Language-1
analysisLanguage-2
analysisLanguage-n
analysis ĂĂLanguage-independent analysis data
Data harvesting
Instrumented multilingual codeLanguage-agnostic 
dynamic analysisanalysis 
data
Unification
Language-specific 
static analyses
decoupling   
Original multilingual code 
(written in ndifferent languages)
Figure1:Envisionedhigh-leveldesignforbetterbalancing
language independence andanalysis practicality.
betweenthelanguageindependenceandpracticality(intermsofef-
ficiency/scalability primarily but also concerning practically useful
levels of precision).Note thatlanguage independencedoes matter
for a multilingual code analysis, because the more independent
theanalysisisoftheunderlyinglanguages,themoreextensible/-
generalizable the analysis is to accommodate the diverse language
combinationsinreal-worldmultilingualsystems.Thus,atotalre-
laxationofthetradeoffwiththe(almostfully)language-agnostic
methodologyasdemonstratedin Orbsbyentirelycompromising
languageindependencetofavorpracticalityisnotaviablesolution.
Ingeneral,weenvisionanewmethodologyfordynamicanalysis
ofmultilingualcode(asfordistributedsystems[ 34,38])todecouple
analysis(e.g.,dependencecomputationorslicing)algorithmfromdata
harvesting (i.e., the process of collecting the program data needed by
the analysis) . An overview of this decoupling design is depicted in
Figure1.Thekeyideaandrationaleisthat(1)thedataharvestingis
realizedviaminimal, language-specific staticanalyses,relyingonas
little knowledge about each particular language of the multilingual
codeaspossible,buttheharvesteddataislanguage-independent
intermsof itsformatand semantics, and (2) the analysis algorithm
itselfisthatofanentirely language-agnostic dynamicanalysis,as
enabledbythelanguageindependenceofthedataharvested.Inthis
way, we will overcome semantics disparity induced by language
heterogeneity through minimal language-specific effort, so as to
reach the practicality goal at the sweet spot in balancing language
independence and practicality. Conceptually, the language-specific
(static) analyses and the language-agnostic (dynamic) analysis are
bridgedthroughan analysisdataunification layerinbetweenwhere
data harvestingwillactually happen at runtime.
The key insight underlying this proposed design is that min-
imizing language-specific analysis hence maximizing language-
independenceand analysis-extensibility (yet not losing scalability)
can be achieved by decoupling analysis algorithms from specific lan-
guagesemanticsthroughharvestinglanguage-independentdata .Asa
proof of concept of this design, we built a cross-language dynamic
data dependence analyzer for Java-C programs on top of an earlier
work SensA [ 17]. We instrumented at every statement where a
variableisdefinedorusedasin[ 27]tosendatruntimethevariable
valueinalanguage-agnosticformattoananalysisserverthroughin-
terprocesscommunication(IPC).WeusedSoot[ 42]andLLVM[ 43]for probing and identifying variable definitions and uses in the
JavaandCunit,respectively.Wethenrantheinstrumentedcode
twice,onenormallytogettheoriginalexecutionandtheotherwith
statements ofinterest beingvoided (i.e., operations there changed
tołnooperation").Oncetheanalysisdataiscollectedbytheserver,
it computes dependencies through differencing the original and
voided executions. Our experiments on a number of Java-C pro-
grams showedthat the decoupling design workedsuccessfullyÐit
correctly computed all dynamic data dependenciesacross the two
heterogeneous language units. The key here is that decoupling the
analysis data collection and the core analysis algorithm is realized
viaIPCÐwhich isbynature language-independent.
5 RELATED WORK
Previousstudiessuggestedthatunifyingorabstractinglanguage
semantics is not scalable because it relies on heavyweight per-
language engineering [ 53,54,59,60]. Converting code in differ-
entlanguagesintoauniform intermediaterepresentation (IR)suf-
fers from misinterpretation/misconversion issues due to language-
semanticsdisparity.Also,theIRconversionforagivenlanguage
is not always practical, because it requires vast engineering ef-
fort [12]; these issues are further aggravated by the evolution of
eachlanguageÐforinstance,whileLLVM[ 43]aimsatauniformIR
forseverallanguages, onlyacoupleoffrontends (e.g.,forC/C++)
receivedregularmaintenancewhilethoseneededfortheIRconver-
sionforother languages didnot henceare not practically usable.
Meanwhile,acommon ormeta model[ 53,60,62]isnot amenable
to dynamic analysis, since code represented in such models (e.g,
theuniform IR)cannotbe executedanymore, noraretheyable to
represent executioninformation of the originalcode.
Earlier approaches [ 53,54,56,59,60] to cross-language analy-
sis are mostly staticwhile relying on substantial language-specific
modeling and/or engineering. Recently proposed dynamic cross-
languageanalysis[ 29]capturescoarse-grained(file-level)depen-
dencies by modifying OS kernel for regression test selection. Ex-
tractingco-changepatternstoderivefile-leveldependenciesachieves
languageindependencebyavoidingcodeanalysis[ 30,31],which
isdifficult to extend for finergranularity.
6 CONCLUSION
Asthegrowingmajorityoftoday’ssoftwaresystemsarebuiltusing
multiplelanguages,holisticanalysisofmultilingualcodeisessen-
tial for systematic software quality assurance. We revisited the
promises of a state-of-the-artmethodology for dynamicanalysis of
multilingualcodethatpromotessuchanalysesbe language-agnostic .
Whileconceptuallyappealingandpromising,thismethodologymay
suffer technical limitations that impede its practical use against
real-world multilingual software systems. We thus proceeded with
an empirical analysis to demonstrate such pitfalls of the language-
agnostic methodology. Following the insights distilled from our
study,weenvisionedanewmethodologytowardsmorepractical
dynamic analysisofmultilingualsoftware.
ACKNOWLEDGMENT
Wethank ourreviewersforconstructivecomments. Thisresearch
wassupportedbyNSF (CCF-2146233) andONR (N000142212111).
1624Language-AgnosticDynamic Analysis of Multilingual Code: Promises,Pitfalls,andProspects ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore
REFERENCES
[1] 2021. https://github.com/lmacken/pyrasite .
[2] 2021. https://github.com/OpenHFT/Java-Thread-Affinity .
[3] 2021. https://github.com/kivy/pyjnius .
[4] 2021. https://github.com/xerial/snappy-java .
[5] 2021. https://github.com/yinwang0/pysonar2 .
[6] 2021. https://github.com/DEAP/deap .
[7] 2021. https://github.com/real-logic/simple-binary-encoding .
[8] 2021. https://github.com/google/brotli .
[9] 2021. https://github.com/vert-x3/vertx-web .
[10] 2021. https://github.com/mongodb/mongo .
[11]Mouna Abidi, Md Saidur Rahman, Moses Openja, and Foutse Khomh. 2021. Are
multi-languagedesignsmellsfault-prone?Anempiricalstudy. ACMTransactions
onSoftwareEngineering and Methodology (TOSEM) 30,3 (2021), 1ś56.
[12]StevenArzt,TobiasKussmaul,andEricBodden.2016. Towardscross-platform
cross-languageanalysis withSoot.In ACM SIGPLAN International Workshop on
the State Of the Art inProgramAnalysis(SOAP) . 1ś6.
[13]DavidBinkley,NicolasGold,MarkHarman,SyedIslam,JensKrinke,andShin
Yoo. 2014. ORBS: Language-independent program slicing. In The ACM Joint
EuropeanSoftware Engineering Conference and Symposium onthe Foundations of
SoftwareEngineering (ESEC/FSE) . 109ś120.
[14] DavidBinkley,NicolasGold,SyedIslam,JensKrinke,andShinYoo.2017. Tree-
oriented vs. line-oriented Observation-Based Slicing. In IEEE International Work-
ingConference onSourceCodeAnalysisand Manipulation (SCAM) . 21ś30.
[15]HaipengCai.2018. HybridProgramDependenceApproximationforEffective
Dynamic Impact Prediction. IEEE Transactions on Software Engineering (TSE) 44
(2018), 334ś364.
[16]HaipengCaiandXiaoqinFu.2021.D2ABS:Aframeworkfordynamicdependence
analysisofdistributedprograms. IEEETransactionsonSoftwareEngineering(TSE)
(2021).
[17]Haipeng Cai, Siyuan Jiang, Raul Santelices, Ying jie Zhang, and Yiji Zhang.
2014.SensA: Sensitivity Analysis for Quantitative Change-impact Prediction. In
IEEE International Working Conference on Source Code Analysis and Manipulation
(SCAM). 165ś174.
[18]Haipeng Cai, Shiv Raj Pant, and Wen Li. 2020. Towards Learning Visual Se-
mantics. In ACM Joint Meeting on European Software Engineering Conference and
SymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE),Visionsand
Reflections . 1537ś1540.
[19]HaipengCai and Raul Santelices. 2014. Diver: Precise dynamic impact analysis
using dependence-based trace pruning. In Proceedings of the 29th ACM/IEEE
international conference onAutomatedsoftwareengineering (ASE) . 343ś348.
[20]HaipengCaiandRaulSantelices.2015. Abstractingprogramdependenciesusing
the method dependence graph. In IEEE International Conference on Software
Quality,Reliability and Security(QRS) . IEEE,49ś58.
[21]HaipengCaiandRaulSantelices.2015. AComprehensiveStudyofthePredictive
Accuracy of Dynamic Change-Impact Analysis. Journal of Systems and Software
(JSS)103(2015), 248ś265.
[22]Haipeng Cai and Raul Santelices. 2015. A framework for cost-effective
dependence-based dynamic impact analysis. In 2015 IEEE 22nd International
ConferenceonSoftwareAnalysis,Evolution,andReengineering(SANER) .231ś240.
[23]HaipengCaiand RaulSantelices. 2015. TracerJD: Generic trace-based dynamic
dependenceanalysiswithfine-grainedlogging.In 2015IEEE22ndInternational
Conference on Software Analysis, Evolution, and Reengineering (SANER) . IEEE,
489ś493.
[24]Haipeng Cai and Raul Santelices. 2016. Method-Level Program Dependence
Abstraction and Its Application to Impact Analysis. Journal of Systems and
Software(JSS) 122(2016), 311ś326.
[25]HaipengCai,RaulSantelices,andSiyuanJiang.2016. PrioritizingChangeImpacts
viaSemanticDependenceQuantification. IEEETransactionsonReliability(TR)
65,3 (2016), 1114ś1132.
[26]HaipengCai,RaulSantelices,andDouglasThain.2016.DiaPro:UnifyingDynamic
ImpactAnalysesforImprovedandVariableCost-Effectiveness. ACMTransactions
onSoftwareEngineering and Methodology (TOSEM) 25,2 (2016).
[27]Haipeng Cai, Raul Santelices, and Tianyu Xu. 2014. Estimating the accuracy
of dynamic change-impact analysis using sensitivity analysis. In 2014 Eighth
InternationalConferenceonSoftwareSecurityandReliability(SERE) .IEEE,48ś57.
[28]Haipeng Cai and Douglas Thain. 2016. DistIA: a cost-effective dynamic im-
pact analysis for distributed programs. In Proceedings of IEEE/ACM International
Conference onAutomatedSoftwareEngineering (ASE) . 344ś355.
[29]AhmetCelik,MarkoVasic,AleksandarMilicevic,andMilosGligoric.2017.Regres-
sion testselection across JVMboundaries. In The ACM JointEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE) . ACM,809ś820.
[30]Catarina Costa, Jair Figueiredo, Leonardo Murta, and Anita Sarma. 2016. TIP-
Merge:recommending expertsforintegratingchangesacrossbranches.In The
ACM Joint European Software Engineering Conference and Symposium on the
FoundationsofSoftwareEngineering (ESEC/FSE) . ACM,523ś534.[31]Catarina Costa, Jair Figueiredo, Anita Sarma, and Leonardo Murta. 2016. TIP-
Merge:recommendingdevelopersformergingbranches.In TheACMJointEu-
ropean Software Engineering Conference and Symposium on the Foundations of
SoftwareEngineering (ESEC/FSE) . ACM,998ś1002. ToolDemonstration.
[32]Cowbody Adventure. 2021. Android malware: com.tinker.gameone. https://
github.com/ashishb/android-malware/tree/master/feabme .
[33]XiaoqinFuandHaipengCai.2019. ADynamicTaintAnalyzerforDistributed
Systems. In The ACM Joint European SoftwareEngineering Conference and Sym-
posiumontheFoundationsofSoftwareEngineering(ESEC/FSE) .1115ś1119. Tool
Demonstration.
[34]Xiaoqin Fu and Haipeng Cai. 2019. Measuring Interprocess Communications in
Distributed Systems. In IEEE/ACM International Conference on Program Compre-
hension(ICPC) . 323ś334.
[35]XiaoqinFu andHaipengCai.2021. FlowDist:Multi-StagedRefinement-Based
DynamicInformationFlowAnalysisforDistributedSoftwareSystems.In 30th
USENIXSecuritySymposium(USENIXSecurity) . 2093ś2110.
[36]Xiaoqin Fu, HaipengCai,and LiLi. 2020. Dads:DynamicSlicingContinuously-
RunningDistributedProgramswithBudgetConstraints.In TheACMJointEu-
ropean Software Engineering Conference and Symposium on the Foundations of
SoftwareEngineering (ESEC/FSE) . 1566ś1570. ToolDemonstration.
[37]Xiaoqin Fu, Haipeng Cai, Wen Li, and Li Li. 2021. Seads: Scalable and Cost-
EffectiveDynamicDependenceAnalysisofDistributedSystemsviaReinforce-
ment Learning. ACM Transactions on Software Engineering and Methodology
(TOSEM) 30,1 (2021), 10:1ś10:45.
[38]XiaoqinFu,BoxiangLin,andHaipengCai.2022. DistFax:AToolkitforMeasuring
Interprocess Communications and Quality of Distributed Systems. In IEEE/ACM
InternationalConference onSoftwareEngineering (ICSE),ToolDemos . 51ś55.
[39]Manel Grichi, Mouna Abidi, Fehmi Jaafar, Ellis E Eghan, and Bram Adams. 2020.
On the Impact of Interlanguage Dependencies in Multilanguage Systems Empiri-
cal Case Study on Java Native Interface Applications (JNI). IEEE Transactions on
Reliability (TR) 70,1 (2020), 428ś440.
[40]SungjaeHwang,SunghoLee,JihoonKim,andSukyoungRyu.2021. JUSTGen:Ef-
fectiveTestGenerationforUnspecifiedJNIBehaviorsonJVMs.In 2021IEEE/ACM
43rdInternationalConference onSoftwareEngineering (ICSE) . IEEE,1708ś1718.
[41] CapersJones. 2010. Softwareengineering bestpractices . McGraw-Hill,Inc.
[42]PatrickLam,EricBodden,OndrejLhoták,andLaurieHendren.2011. Soot-aJava
BytecodeOptimizationFramework.In CetusUsersandCompilerInfrastructure
Workshop .
[43]Chris Lattner and Vikram Adve. 2004. LLVM: A compilation framework for
lifelongprogramanalysis&transformation.In Proceedingsoftheinternational
symposiumonCodegenerationandoptimization:feedback-directedandruntime
optimization (CGO) . IEEE Computer Society, 75.
[44]Seongmin Lee, David Binkley, Robert Feldt, Nicolas Gold, and Shin Yoo. 2021.
Observation-basedapproximatedependencymodelingandits useforprogram
slicing.Journal ofSystemsand Software(JSS) 179(2021), 110988.
[45]SeongminLee,DavidBinkley,NicolasGold,SyedIslam,JensKrinke,andShin
Yoo. 2018. MOBS: multi-operator observation-based slicing using lexical ap-
proximation of program dependence. In Proceedings of the 40th International
Conference on Software Engineering: Companion Proceeedings (ICSE-Companion) .
ACM,302ś303.
[46]Sungho Lee, Hyogun Lee, and Sukyoung Ryu. 2020. Broadening Horizons of
Multilingual Static Analysis: Semantic Summary Extraction from C Code for JNI
ProgramAnalysis.In 202035thIEEE/ACMInternationalConferenceonAutomated
SoftwareEngineering (ASE) . IEEE,127ś137.
[47]Wen Li, Haipeng Cai, Yulei Sui, and David Manz. 2020. PCA: Memory Leak
Detection using Partial Call-Path Analysis. In The ACM Joint European Software
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering
(ESEC/FSE) . 1621ś1625. ToolDemonstration.
[48]WenLi,LiLi,andHaipengCai.2022. OntheVulnerabilityPronenessofMulti-
lingualCode.In TheACMJointEuropeanSoftwareEngineeringConferenceand
Symposiumonthe FoundationsofSoftwareEngineering (ESEC/FSE) .
[49]Wen Li, Li Li, and Haipeng Cai. 2022. PolyFax: A Toolkit for Characterizing
Multi-LanguageSoftware.In ACMJointMeetingonEuropeanSoftwareEngineering
ConferenceandSymposiumontheFoundationsofSoftwareEngineering(ESEC/FSE) .
ToolDemonstration.
[50]Wen Li, Na Meng, Li Li, and Haipeng Cai. 2021. Understanding Language Se-
lection in Multi-Language Software Projectson GitHub. In 2021 IEEE/ACM 43rd
International Conference on Software Engineering: CompanionProceedings(ICSE-
Companion) . IEEE,256ś257.
[51]Wen Li, Jiang Ming, Xiapu Luo, and Haipeng Cai. 2022. PolyCruise: A Cross-
Language Dynamic Information Flow Analysis. In 31st USENIX Security Sympo-
sium (USENIXSecurity22) . Boston, MA,2513ś2530.
[52]Philip Mayer and Alexander Bauer. 2015. An empirical analysis of the utilization
of multiple programming languages in open source projects. In The International
Conference on Evaluationand Assessment in Software Engineering (EASE) .ACM,
1ś10.
[53]PhilipMayerandAndreasSchroeder.2012. Cross-languagecodeanalysisand
refactoring.In ProceedingsofIEEEWorkingConferenceonSourceCodeAnalysis
and Manipulation (SCAM) . IEEE,94ś103.
1625ESEC/FSE ’22, November14ś18, 2022,Singapore, Singapore Haoran Yang,WenLi, andHaipeng Cai
[54]Daniel L Moise and Kenny Wong. 2005. Extracting and Representing Cross-
LanguageDependencies in Diverse Software Systems. In Proceedingsof the 12th
Working Conference onReverse Engineering (WCRE) . 209ś218.
[55]National Vulnerability Database. 2021. CVE-2016-6691. https://nvd.nist.gov/
vuln/detail/CVE-2016-6691 .
[56]HungVietNguyen,ChristianKästner,andTienNNguyen.2015. Cross-language
programslicingfordynamicweb applications.In TheACM JointEuropeanSoft-
ware Engineering Conference and Symposium on the Foundations of Software
Engineering (ESEC/FSE) . ACM,369ś380.
[57]BaishakhiRay,DarylPosnett,PremkumarDevanbu,andVladimirFilkov.2017.
A Large-scale Study of Programming Languages and Code Quality in GitHub.
Communications ofthe ACM(CACM) 60,10(2017), 91ś100.
[58]BaishakhiRay,DarylPosnett,VladimirFilkov,andPremkumarDevanbu.2014.
Alargescale study ofprogramminglanguagesand code qualityinGitHub.In
The ACM Joint European Software Engineering Conference and Symposium on the
FoundationsofSoftwareEngineering (ESEC/FSE) . ACM,155ś165.[59]Miloš Savić, Gordana Rakić, Zoran Budimac, and Mirjana Ivanović. 2014. A
language-independent approach to the extraction of dependencies between
source code entities. Information and Software Technology (IST) 56, 10 (2014),
1268ś1288.
[60]DennisStrein,HansKratz,andWelfLowe.2006.Cross-languageprogramanalysis
andrefactoring.In ProceedingsofIEEEWorkingConferenceonSourceCodeAnalysis
and Manipulation (SCAM) . IEEE,207ś216.
[61]The NumPy team. 2021. NumPyśthe fundamental package needed for scientific
computing with Python. https://github.com/numpy/numpy .
[62]Sander Tichelaar, Stéphane Ducasse, Serge Demeyer, and Oscar Nierstrasz. 2000.
A meta-model for language-independent refactoring. In Principles of Software
Evolution, 2000. Proceedings.InternationalSymposiumon . IEEE,154ś164.
[63]Federico Tomassetti and Marco Torchiano. 2014. An empirical assessment of
polyglot-ism in GitHub. In The International Conference on Evaluation and As-
sessmentinSoftwareEngineering (EASE) . ACM,1ś4.
1626