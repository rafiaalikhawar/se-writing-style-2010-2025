Parallel Shadow Execution to Accelerate the Debugging of
NumericalErrors
Sangeeta Chowdhary
Departmentof ComputerScience
Rutgers University
USA
sangeeta.chowdhary@rutgers.eduSantosh Nagarakatte
Departmentof ComputerScience
Rutgers University
USA
santosh.nagarakatte@cs.rutgers.edu
ABSTRACT
Thispaperproposesanewapproachfordebuggingerrorsinfloating
pointcomputationbyperformingshadowexecutionwithhigher
precisioninparallel.Theprogrammerspecifiespartsoftheprogram
that needto be debuggedfor errors. Our compilercreates shadow
execution tasks, which execute on different cores and perform the
computation with higher precision. We propose a novel method
to execute a shadow execution task from an arbitrary memory
state,whichisnecessarybecausewearecreatingaparallelshadow
executionfromasequentialprogram.Ourapproachalsoensures
thattheshadowexecutionfollowsthesamecontrolflowpathasthe
originalprogram.Ourruntimeautomaticallydistributestheshadow
execution tasks to balance the load on the cores. Our prototype for
parallel shadow execution, PFPSanitizer , provides comprehensive
detectionoferrorswhilehavinglowerperformanceoverheadsthan
prior approaches.
CCS CONCEPTS
Â·Software and its engineering â†’Software testing and de-
bugging;Â·Computingmethodologies â†’Parallelcomputing
methodologies .
KEYWORDS
floatingpoint,dynamicanalysis,FPSanitizer,roundingerrors
ACMReference Format:
Sangeeta Chowdhary and Santosh Nagarakatte. 2021. Parallel Shadow Exe-
cutiontoAcceleratethe DebuggingofNumericalErrors. In Proceedingsof
the 29th ACM Joint European Software Engineering Conference and Sym-
posium on the Foundations of Software Engineering (ESEC/FSE â€™21), Au-
gust 23Å›28, 2021, Athens, Greece. ACM, New York, NY, USA, 12pages.
https://doi.org/10.1145/3468264.3468585
1 INTRODUCTION
The floating point (FP) representation approximates a real number
usingafinitenumberofbits.Hence,someroundingerrorwitheach
operationisinevitable.Suchroundingerrorscanbeamplifiedby
certainoperations( e.g.,subtraction)suchthattheentireresultis
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™21, August 23Å›28,2021, Athens,Greece
Â©2021 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-8562-6/21/08...$15.00
https://doi.org/10.1145/3468264.3468585influenced by rounding errors. Even the control flow of the pro-
gramcandiffercomparedtoanoracleexecutionduetorounding
errors,whichcanresultinslowconvergenceorwrongresults.In
extremecases,mathlibrariescanproducewrongresults,whichcan
beamplifiedbyotheroperations.Further,theprogramcanproduce
exceptionalvaluessuchasNot-a-Number(NaNs),whichgetpropa-
gatedthroughouttheprogramtoproduceincorrectresults.Such
errorshave causedwell documentedmishaps[ 33].
GiventhehistoryoferrorswithFPprograms,therehavebeen
numerous proposalsto detect [ 1,3,15,16,24],debug [ 9,38],and
repairerrors[ 34].Therearenumeroustoolstodetectspecificer-
rors[1,15,16,24].Acomprehensiveapproachtodetecterrorsin
FPprogramsistoperforminlinedshadowexecutionwithrealnum-
bers[3,9,38].Intheshadowexecution,everyFPvariableinmemory
and registers is represented with a type that has a large amount of
precision ( e.g., using MPFR library [ 17]). When the FP value and
the shadow value differ significantly, the error is reported to the
user.Suchshadowexecutiontoolscancomprehensivelydetecta
wide range of errors: cancellation errors, branch divergences, and
thepresenceofspecialvalues( e.g.,NaNs).Toassistindebugging
the error, Herbgrind [ 38] and FPSanitizer [ 9] provide a directed
acyclic graph (DAG) of instructions. Herbgrind when coupled with
Herbie[34]hasbeenusefulinrewritingFPexpressions.Thedebug-
ging features in our prior work, FPSanitizer [9], have been useful
inour effortto develop correctlyroundedmath libraries [ 25Å›29].
Inlined shadow execution is useful in detecting errors with unit
tests. However, it has more than 100Ã—performance overhead. Soft-
ware emulation of a real number using the MPFR library and addi-
tionalinformation( i.e.,metadata)maintainedwitheachmemory
location during inlined shadow execution are the primary sources
ofthisperformanceoverhead.Theseoverheadspreventtheusage
ofsuch debuggingtoolsinmanyapplications.
Our objective is to enable the use of shadow execution tools for
debuggingnumericalerrorswithlongrunningapplications.This
paperproposesanewapproachfordebuggingnumericalerrorsthat
performs shadowexecution in parallel on the multicore machines.
Inourapproach,theuserspecifiespartsofthecodethatneedsto
bedebugged( i.e.,withdirectives #pragma pfpsan inFigure 3(a))
similar to task parallel programs. Our compiler creates shadow
executiontasksthatmimictheoriginalprogrambutexecutetheFP
computation with higher precision inparallel. The shadow execu-
tiontasksofasequentialprogram,bydefault,arealsosequential
becausetheyneedthememorystatefrompriortasks.Toexecute
the shadow execution tasks in parallel, we need to provide these
shadow execution tasks with appropriate memory state and input
arguments. We also need to ensure that the parallel task follows
615
ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece Sangeeta Chowdhary andSantoshNagarakatte
the same control-flow path as the original program to be useful for
debugging.
Our key insight for parallel shadow execution from a sequential
programistousetheFPvalueproducedbytheoriginalprogramas
theoraclewheneverwedonothavethehigh-precisioninformation
available. Our approach is partly inspired from prior efforts on
speculative parallelization [ 44]. In our model, the shadow task can
startexecutionevenifpriorshadowtasks(accordingtotheorderin
the sequential program) have not completed as long as the original
program has executed the corresponding FP computation. The
original program pushes the live FP values, memory addresses,
and the FP values loaded from those addresses to a queue that is
used by the shadow execution task (see Figure 4). The original
program and the shadow execution task execute in a decoupled
fashion and communicate only through the queues. The shadow
executiontaskreadstheliveFPvaluesfromthequeueandexecutes
the high-precision version of the program created by our compiler.
Itmaintainsahigh-precisionvalue( i.e.,aMPFRvalue)witheach
FPvariable inboth memory andintemporaries.
Whentheshadowexecutiontaskloadsavaluefromamemory
location,itneedstoidentifywhetherthememorylocationwaspre-
viously written by that task. The high-precision value is available
in memory when the task haspreviously written to that address.
Otherwise, it needs to initialize the shadow execution using the
FPvaluefromtheoriginalprogram.Todetectsuchscenarios,the
shadowexecutiontaskstoresboththehigh-precisionvalueandthe
FPvalueproducedbytheprograminitsmemorywhenitperforms
a store. Subsequently when the shadow execution task performs a
load, it checks whether the loaded FP value from memory and the
valueproducedbytheprogramareidentical.TheFPvaluesfrom
theprogramandtheonesinthememoryoftheshadowtaskwill
mismatch whenthe shadow taskis accessingthe memory address
forthefirsttimeorwhenthememoryaddressdependsonvalues
frompriorshadowtasks.Insuchcases,theshadowtaskusestheFP
value from the program as the oracle and re-initializes its memory
(seeFigure 6).Thistechniquetousetheoriginalprogramâ€™sFPvalue
asanoracleallowsustoexecuteshadowexecutiontasksfroman
arbitrary state.Toenableeffectivedebuggingofnumericalerrors,
the shadow execution task also maintains information about the
operationthatproducedthevalueinmemory,whichcanbeused
to provideaDAG ofinstructionsresponsible for the error.
Our prototype, PFPSanitizer , is open-source and publicly avail-
able[11].ItenhancestheLLVMcompilertoinstrumenttheprogram
and generate shadow execution tasks. PFPSanitizer â€™s runtime cre-
ates a team of threads for shadow execution, allocates bounded
queues to communicate values for shadow execution tasks, and
dynamicallyassignsshadowexecutiontaskstothecorestobalance
the load. The speedup with PFPSanitizer over inlined shadow
executiondependsonthenumberofshadowtasks.Iftheuserdoes
notcreateanytask,thentheentireexecutionisasingletaskand
PFPSanitizer can attain a maximum speedup of 2Ã—. When the
user creates sufficient number of shadow tasks, PFPSanitizer is
approximately 30Ã—fasteronaverageonamachinewith64-cores
whencomparedto FPSanitizer ,whichisthestate-of-the-artfor
debuggingFPprograms.sign bit
(1 bit)01100000000000000000000 10000001 0
exponent 
(8 bits)fraction
(23 bits)
Figure 1: A 32-bit FP representation of 5.5 in decimal. First,
thenumber5.5isconvertedtoabinaryfraction (1.011)2Ã—22
andtheactualbitpatternsfortheexponentandthefraction
aredetermined.As ğ‘ğ‘–ğ‘ğ‘ =127fora32-bitfloatand ğ¸âˆ’ğ‘ğ‘–ğ‘ğ‘ =2,
ğ¸=129whichis 10000001 inbinary.Theleastsignificantbits
ofthefraction are populated with zeros.
Real: 0.5f
Computed: 0.5fReal: 0.00134f
Computed: 0.00134f+-Real: 0.50133999
Computed: 0.50133997
Real: 0.00134f
Computed: 0.00134fReal: 0.5
Computed: 0.4999-
Real: 0.5f
Computed: 0.5fReal: 0
Computed: 2.98023e-08*
Real: 200000000.0f
Computed: 200000000.0fReal: 0
Computed: 5.96
A BBAC
Computation of (A - (( A+ B) - B)) * CCancellation
Figure2:Erroramplificationwithasequenceofoperations,
represented as a DAG. We show the real value and the FP
resultforeachoperation.
2 BACKGROUND
WeprovideaprimerontheFPrepresentation,thecauseoferrors
andtheiraccumulationwithFPcomputation,anoverviewofinlined
shadowexecution,andacomparison of existing approaches.
The floating point representation. The floating point (FP)
representationisthemostwidelyusedrepresentationtoapproxi-
materealnumbers.ItwasstandardizedbytheIEEE-754standard.
TheFPrepresentationisspecifiedbythetotalnumberofbits( ğ‘›)and
thenumberofbitsfortheexponent( |ğ¸|).Therepresentationhas
threecomponents:asignbit, |ğ¸|exponentbits,and ğ‘›âˆ’1âˆ’|ğ¸|bitsto
representthefraction.Figure 1showstherepresentationfora32-bit
float,whichhasasignbit,8-bitsfortheexponent,and23-bitsfor
thefraction.A64-bitdoublehasasignbit,11-bitsfortheexponent,
and 52-bits for the fraction. The goal of the FP representation is to
encode both large andvery small values.
Thesignbitindicateswhetherthenumberispositiveornegative.
There are three classes of values depending on the bit pattern
in the exponent. If the exponent bits are all 1â€™s, the bit pattern
representsspecialvalues.Itrepresentsinfinityifthefractionbits
areall0â€™sandNaNs(Not-a-Number)otherwise.Thesespecialvalues
propagatewitheachoperation.Iftheexponentbitpatternisall0â€™s,
itrepresentsdenormalvalues( i.e.,valuesveryclosetozero).The
value of the number represented is (âˆ’1)ğ‘ Ã—0.ğ¹Ã—21âˆ’ğ‘ğ‘–ğ‘ğ‘ , where
ğ‘ğ‘–ğ‘ğ‘ =2|ğ¸|âˆ’1âˆ’1andğ¹isthevalueofthebinaryfraction( i.e.,from
thefractionbits).Iftheexponentbitpatternisneitherall0â€™snor
616Parallel ShadowExecutionto Acceleratethe Debuggingof Numerical Errors ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
Table 1: Comparison of various dynamic analysis tools. We indicate whether they support parallel execution, type of instru-
mentation, performance overhead, kind of errors detected, and the oracle used for the analysis. Here, IL indicates that the
tool provides debugging information at an instruction level, which is useful for debugging. FL represents information being
presented at thegranularity ofafunction.
Tool NameParallel
Shadow
AnalysisInstrumentation OverheadRounding
ErrorsBranch
FlipsConversion
ErrorsRoot Cause
AnalysisOracle
BZ [1] âœ—Compiler(GIMPLE IR) 7.91Ã— âœ“ âœ“ âœ“ âœ— Canceled Bits
FPSpy [15] âœ— Binary(Valgrind) 127Ã— âœ“ âœ— âœ— âœ— Condition Codes
Verrou[16] âœ— Binary(Valgrind) 7Ã— âœ“ âœ— âœ— âœ“(FL) Randomized Rounding
FPDebug [ 3] âœ— Binary(Valgrind) >395Ã— âœ“ âœ— âœ“ âœ“(IL) MPFR
Herbgrind [ 38] âœ— Binary(Valgrind) >574Ã— âœ“ âœ“ âœ“ âœ“(IL) MPFR
FPSanitizer[ 10] âœ— Compiler(LLVMIR) >100Ã— âœ“ âœ“ âœ“ âœ“(IL) MPFR
PFPSanitizer âœ“Compiler(LLVMIR) 5.6Ã— âœ“ âœ“ âœ“ âœ“(IL) MPFR
all1â€™s,thenitrepresentsnormalvalues.Thevaluerepresentedis
(âˆ’1)ğ‘ Ã—1.ğ¹Ã—2ğ¸âˆ’ğ‘ğ‘–ğ‘ğ‘ .
Rounding error. When a real number is not exactly repre-
sentable, then it must be rounded to the nearest FP number ac-
cordingtotheroundingmode.TheIEEE-754hasmultiplerounding
modes. Round-to-nearest-with-ties-to-even is the default rounding
mode [18]. Hence, each primitive arithmetic operation has some
error, which is bounded by 0.5 ULP (units in the last place) [ 18,30].
Accumulation oferrors. Althougheachprimitivearithmetic
operation has a small amount of rounding error ( â‰¤0.5ULP), the
error can get amplified with a sequence of operations and produce
wrong results, exceptions, and branch divergences. Figure 2shows
the accumulation of error while computing the expression (ğ´âˆ’
((ğ´+ğµ) âˆ’ğµ)) âˆ—ğ¶.An executionwithrealsproduces zerobutthe
FPexecutionproducesanon-zerovalue.Whenthisvalueisused
as a branch condition, then the outcome of the branch will diverge
fromtheidealexecution.Onereasonforthiserroristhatwhentwo
numbers that are close to each to other are subtracted, the most
significant precision bits can get canceled. If the remaining bits are
influencedbyrounding,then the roundingerrorgetsamplified.
Inlinedshadowexecutionwithreals. Onewaytodetectsuch
numericalerrorsisbycomparingtheresultsoftheFPprogramand
the program that is rewritten with real numbers ( i.e., differential
analysis).Suchanapproach candetecterrorsbutdoesnot helpin
debuggingbecauseitisinfeasibletostoreallintermediateresults
and compare them. A lock-step inlined shadow execution [ 3,9,38]
wheretheanalysisperformsrealcomputationaftereachinstruction,
maintainstherealvaluewitheachvariableinregistersandmemory,
and checks error after each instruction is useful. The real numbers
are simulated with a widely used GNU MPFR library, which is a C
libraryformultiple-precisionfloatingpointcomputationswithcor-
rectrounding.Bymaintainingappropriateinformationwitheach
memorylocation,suchlock-stepshadowexecutioncanprovidea
directed acyclic graph (DAG) of instructions ( i.e., a backward slice
ofinstructions) to debug an error[ 9,38].
Comparison of prior approaches with PFPSanitizer .Ta-
ble1comparesvariousdynamicanalysistoolstodetectFPerrors.
Manyofthepriorapproachesdonotusetherealexecutionasan
oracle because it is expensive [ 1,15,16]. Hence, they detect likelyerrorsrather than actual errors. Amongthe shadow executionap-
proaches that use real numbers as an oracle, Herbgrind [ 38] and
FPDebug [ 3] perform binary instrumentation and have significant
overheads.Ourpriorwork,FPSanitizer[ 9],reducestheoverhead
by keeping the memory usage bounded. In contrast to prior ap-
proaches, PFPSanitizer performsparallelshadowexecutionthat
reduces overheads by an order of magnitude while providing com-
prehensive detection anddebuggingsupport.
3 PARALLEL SHADOWEXECUTION
Our objective is to facilitate detection and debugging of numerical
errors by performing a fine-grained comparison of a programâ€™s
executionwithaparallelshadowexecutioncarriedoutwithhigher-
precision.Incontrasttoapproachesthatdetectspecificerrors[ 1,
15,16], a shadow execution with higher precision can enable com-
prehensive detection and debugging of errors such as cancellation,
exceptions, precision loss, and control-flow divergences. Typically
FPdatatypessuchas floatanddoublearesupportedinhardware
andthehigher-precisionexecutionisperformedusingasoftware
library(e.g.,MPFR).Hence,inlinedshadowexecutionwillbesig-
nificantlyslowerthantheprogramâ€™sexecution.Toaddressthese
overheads,we propose to perform parallelshadowexecution.
Performingshadowexecutioninparallelischallengingforthe
following four reasons. First, we have to create a higher-precision
versionoftheprogramautomatically,whichchecksitsexecution
with the original program in a fine-grained manner. Second, sig-
nificant communication between the original program and the
shadowexecutionwillreduceperformance.Third,executingthe
entire shadow execution on another core ( i.e., a single core) will
notprovidesignificantspeedupcomparedtoinlinedshadowexecu-
tion because the shadow execution is significantly slower than the
original program. Hence, we need a mechanism to identify and ex-
ecutefragmentsofshadowexecutioninparallel( i.e.,parallelizethe
shadow execution). Finally, we need to initialize the memory state
appropriately for each such parallel fragment of shadow execution.
3.1 High-Level Overviewof PFPSanitizer
We propose a new approach for debugging numerical errors where
theuserspecifiespartsoftheprogramthatneedstobedebugged.
Our compiler automatically creates a high-precision version of
617ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece Sangeeta Chowdhary andSantoshNagarakatte
1 float foo(float *a, float *b){
2  #pragma pfpsan{
3   float aval = *a;
4   float bval = *b;
5   float x1 = aval + bval;
6   float x2 = x1 - aval;
7   float x3 = x2 - bval;
8   float z = 0.0;
9   if(x3 == 0){
10     z = x2*x3;
11  }
12  else{
13    z = x2+x3;
14  }
15 }
 
16 return z;
17}
(a) Original program with a directive 1 float foo(float *a, float *b){
 2   task = create_task();
 3   float aval = *a;
 3a  task.enqueue(a, aval);
 4   float bval = *b;
 4a  task.enqueue(b, bval);
 5   float x1 = aval + bval;
 6   float x2 = x1 - aval;
 7   float x3 = x2 - bval;
 8   float z = 0.0;
 9   task. enqueue(x3 == 0);
 9a  if(x3 == 0){
 
 10   z = x2*x3;
 11  }
 12  else{
 13    z = x2+x3;
 14  }
 15  task.enqueue(z);
 15a end_task(task);
 16  return z;
 17} 1 void foo_shadow(task & t){
 2   
 3a  <a_addr, a> = t.dequeue();
 3b  a_s = pfpsan_load(a, a_addr);
 4   <b_addr, b> = t.dequeue();
 4a  b_s = pfpsan_load(b, b_addr);
 5   x1_s = pfpsan_add(a_s, b_s);
 6   x2_s = pfpsan_sub(x1_s, a_s);
 7   x3_s = pfpsan_sub(x2_s, b_s);
 8   z_s = pfpsan_const(0.0);
 9   cond = t.dequeue();
 9a  cond_s = pfpsan_cmp(x3_s, 0);
 9b  pfpsan_check_branch(cond, cond_s);
 9c  if(cond){
 10   z_s = pfpsan_mul(x2_s, x3_s);
 11  }
 12  else{
 13    z_s = pfpsan_add(x2_s, x3_s);
 14  }
 15   z = t.dequeue();
 15a  pfpsan_check_return(z, z_s);
 16.  
 17 }
(b)  Compiler generated producer program 
with FP computation(c)  Compiler generated shadow execution task 
with high-precision computationpfsan 
compiler 
Figure3:Transformationsdonebythe PFPSanitizer â€™scompiler.(a)Programwith pfpsandirective.(b)Theproducer(original
program)withadditionalinstrumentationtowriteFPvaluesandaddressestothequeue.Theproducerpassestheaddressofthe
memory read and the actual FP value because it enables the shadow execution task to map the address to a shadow memory
address. The FP value enables it to check if the shadow task is starting from an arbitrary memory state. (c) The consumer
(shadow execution task) that performs high-precision computation. By default, PFPSanitizer checks error on every branch
conditionandreturn value ( i.e.,pfpsan_check_branch andpfpsan_check_return )
the original program corresponding to it, which we call as the
shadowexecutiontask.Therearetworequirementsfortheshadow
execution: (1) it has to follow the same control-flow path as the
original program and (2) we should be able to check the shadow
executionâ€™s value with the original programâ€™s value at various
pointsofinterest.Ourgoalistoexecutemultipleshadowexecution
tasksinparallel.However,theseshadowexecutiontasksarederived
fromasequentialprogramandtheyaredependentoneachother.To
executetheminparallel,weneedtobreakdependenciesbetween
theseshadowexecutiontasks.
Tobreakdependenciesbetweentwoshadowexecutiontasks,we
needtoprovideappropriatestateformemorylocationsthatdepend
on values produced by prior shadow tasks. Our key insight is to
use the FP values from the original programas the oracle to break
dependencies.Inourmodel,wetreatashadowexecutiontaskto
be independent of other shadow tasks and use the values produced
bythecorrespondingregionsoftheoriginalprogramtoinitialize
the memory state. Hence, our compiler introduces additional in-
strumentation to the original program to provide live FP values,
addressesofmemoryaccesses,FPvaluesreadfromeachmemory
access,andoutcomesofbranchestothequeue.Figure 3(b)presents
the instrumented version of the original program. The shadow exe-
cutiontasks created by our compiler readFP values and addresses
from the queue.Itexecutesthe FPcomputationwithhigher preci-
sion. To ensure that the shadow execution taskfollows the same
control-flowpathastheoriginalprogram, PFPSanitizer â€™scompilerchangeseverybranchintheshadowtasktousetheoutcomeofthe
original program. Figure 3(c) illustrates the shadow execution task
createdbyour compilerfor the program inFigure 3(a).
The shadow task maps every memory location with an FP value
in the original program to a shadow memory location that has a
high-precisionvalue.Whentheshadowtaskexecutesamemory
access,itneedstodeterminewhetherthatlocationhasbeenpre-
viously accessed by it. If it has previously accessed the memory
location,thenthehigh-precisionvalueisavailableinshadowmem-
ory. Otherwise,itneeds toinitializetheshadowmemory with the
FPvaluefromtheprogram.Hence,everyshadowmemorylocation
maintainsthehigh-precisionvalueandtheFPvalueproducedby
theoriginalprogram.Whentheshadowexecutiontaskperforms
aload, we checkif the FPvalue loadedfrom shadow memory and
theFPvalueproducedbytheoriginalprogramareidentical.Ifthey
match, we use the high-precision value for shadow execution. Oth-
erwise,weusetheFPvalueproducedbytheprogramtoreinitialize
shadow memory for that location. This technique to use the FP
valuefromtheoriginalprogramastheoracleenablesustoperform
parallel shadow execution from a sequential program. It limits the
detection of errors to instructions in the region provided by the
programmer,whichwefoundtobesufficienttodebugvariousFPer-
rors.Toassistdebugging,eachshadowmemorylocationmaintains
information about the operations that produced the value. This
informationenables PFPSanitizer todetecterrorsandprovidea
DAG ofinstructionsfor thoseerrors.
618Parallel ShadowExecutionto Acceleratethe Debuggingof Numerical Errors ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
for(..){
 int res = foo(â€¦.);
}Core 0
.. .. bk ak ..
The original 
program (producer)Task 1
Task 1
(foo_shadow) .. .. b0 a0 ..
.. .. b1 a1 ..Task 2
Task kShadow
Memory Core 1
Task 2
(foo_shadow) Shadow
Memory Core 2
Task k
(foo_shadow) Shadow
Memory Core k
Shadow execution 
tasks (Consumers)Active tasks along with 
bounded queues 
for live FP values
Figure 4: Parallel execution of shadow execution tasks dur-
ing dynamic execution on a multicore machine. The pro-
ducer (original program) and the consumer communicate
live FP values, addresses of memory accesses, and branch
outcomes usingqueues.
PFPSanitizer â€™sruntimemapsashadowexecutiontasktooneof
thecoresinthesystemdynamicallybalancingtheload.Theoriginal
program and the shadow execution task operate in a decoupled
fashionandcommunicateonlythroughthequeues(seeFigure 4).
This decoupled execution with dynamic load balancing provides
significant speedups withthe increaseinthe number ofcores.
3.2 OurModel forDebuggingFP Errors
As our goal is to enable programmers to debug numerical errors in
longrunningprograms,performinganexpensiveshadowexecution
for the entire program may not be feasible. In our approach, the
programmermarkspartsoftheprogramthatneedstobedebugged
withthepfpsandirective( i.e.,pragma pfpsan inFigure 3(a)).Each
pfpsandirective represents a scoped block where the programmer
suspectsthepresenceofnumericalerrorsandwantstodebugthem
withshadowexecution.Ourcompilergeneratesashadowexecution
taskforeachsuchdirective.Eachsuchdirectivecorrespondstoa
single shadow task, which can be executed on another core. We do
not support nested directives. If the dynamic execution encounters
nested directives, the nested directives are ignored and the shadow
executiontaskcorrespondsto the outermost directive.
Two non-nested directives in the dynamic execution result in
two shadow execution tasks that can execute in parallel. If the pro-
grammer places the directive at the beginning of the main method,
theentireprogramwillbeasingleshadowexecutiontask.Itcanat
most get a speedup of 2Ã—over inlined shadow execution. As the
programmerintroducesmoredirectives,moreshadowexecution
tasks can be executed in parallel. With the introduction of addi-
tional non-nested directives, the window of instructions tracked to
debug an error decreases. Numerical errors have a relatively small
windowofdynamicinstructionsthatareusefultodebugandfixthe
error[9,38].Hence,whentheprogrammerusesasufficientnumber
of directives, the programmer can obtain sufficient speedup and
relatively rich DAG of instructions to debug the error using our
approach.
3.3 Compiler GeneratedShadowTasks
Given a program with directives, PFPSanitizer â€™s compiler auto-
maticallycreatesashadowhigher-precisionversionoftheprogramthatcanoperateinparallelwiththeoriginalprogramonaseparate
core.Wewanttheoriginalprogramandtheshadowtasktoexecute
independently with minimum communication. In our design, they
communicatethroughboundedqueues.Theoriginalprogramisthe
producerandtheshadowexecutiontaskistheconsumer.Toenable
effectivedebugging,weneedtoensurethattheshadowtaskfollows
thesamecontrol-flowpathastheoriginalprogram. PFPSanitizer â€™s
compileridentifiesthe pfpsandirectiveandcreatesthemodified
original program and the shadow execution task corresponding to
the directive. Figure 3(b) shows the modified original program and
the shadowexecutiontaskcorresponding to the directive.
Modified original program. PFPSanitizer â€™s compiler modi-
fies the original program to account for the creation of the shadow
task.Itaddsacalltotheruntimetoobtainanuniquetaskidenti-
fier and a queue associated with it. Subsequently, PFPSanitizer
captures the FP values that are live to the directive and introduces
enqueue operations. Our shadow tasks do not have information
aboutintegeroperations.Hence, PFPSanitizer enqueuesthead-
dressandthe FPvalueloaded/storedfor everymemoryoperation.
Toprovideinformationaboutthebranchconditions,thecompiler
alsoenqueuesthe branchcondition.Attheend ofthescopedblock
corresponding to the directive, the compiler adds a runtime call to
indicatethe end ofthe shadowtask.
Shadow execution task. PFPSanitizer creates ashadow exe-
cutiontaskthatperformsthehigher-precisionexecutiontofacili-
tatedetectionanddebuggingofFPerrors.Toimproveperformance,
PFPSanitizer doesnotcreateahigh-precisionreplicaoftheentire
scopedblockindicatedbythedirective.Further,rewritinganentire
program especially global data structures with indirect references
is a challenging task. Instead, PFPSanitizer â€™s compiler removes
allnon-FPoperations(exceptthebranchconditions),changesFP
arithmetic operations to use the corresponding higher-precision
operations in the MPFR library, and replaces FP load and store
operations with loads and stores of MPFR data type in shadow
memory.
For each live FP value in the directive, PFPSanitizer introduces
a dequeue operation to read the input FP value from the queue
associated with the shadow task. All FP arithmetic operations use
thecorrespondinghigh-precisionvalues.Forexample, pfpsan_add
performs high-precision arithmetic using the MPFR library. For
each memory operation ( i.e., a load or a store), PFPSanitizer â€™s
compiler inserts a runtime call in the shadow execution task to
access the shadow memory corresponding to the address of the
memory operation. The FP value produced by the original pro-
gram is maintained as metadata in shadow memory along with the
high-precision value. It enables us to start shadow execution at an
arbitrarypointintheprogrambyusingtheoriginalprogramasthe
oracle.
The shadow execution task does not perform any integer opera-
tions.Astheshadowtaskneedstofollowthesamecontrolflowpath
astheoriginalprogram, PFPSanitizer insertsadequeueoperation
from the queue to obtain the branch outcome of the producer. Sub-
sequently,itchangesthebranchconditionintheshadowexecution
tasktobranchbasedontheproducerâ€™sbranchoutcome.Figure 3(c)
presentstheshadowexecutiontaskcreatedbythe PFPSanitizer
compilerfortheprograminFigure 3(a).Overall, PFPSanitizer â€™s
compiler generates a high-precision version of the program that
619ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece Sangeeta Chowdhary andSantoshNagarakatte
Metadata in Shadow MemoryDynamic Trace of the 
Shadow Execution task
x1_s = pfpsan_add(a_s, b_s);
x2_s = pfpsan_sub(x1_s, a_s);
pfpsan_store(x2_s, res);Metadata for temporaries
Float 
valueReal 
valueOperand 1 Operand 2
2.5 a_s 2.5 .. .. â€¦Op
3.75 3.74900. a_s b_s x1_s +1.25 b_s 1.24900. .. .. â€¦
1.25 1.24900. x1_s a_s x2_s -
1.25 1.24900. x2_s Shadow address (res)
Float 
valueReal 
valuePointer to 
temporaryâ€™s 
metadata           ..
           ..
Figure 5: Metadata maintained with temporaries and in
shadow memory. Every temporaryâ€™s metadata has the op-
eration (op), float value, real value (MPFR), pointers to
operands that produced it. Every FP value in memory has
metadatainshadowmemorythathastheFPvalue,thereal
value,andthepointertothepreviouswriterâ€™smetadata.The
arrows indicate how a DAG can be constructed using the
metadata.
executes FP operations with a MPFR type and will follow the exact
same control-flowpathas the originalprogram duringexecution.
3.4 DynamicExecution ofShadowTasks
PFPSanitizer â€™sruntimecreatesapoolofthreadsatthestartofthe
producerâ€™sexecution,whichexecutetheshadowexecutiontasks.
Astheproducerexecutes,theinstrumentationcorrespondingtothe
directivescreatetasksandtheirassociatedqueues. PFPSanitizer â€™s
runtimeemploysawork-stealing algorithmto dispatchashadow
executiontasktoathreadinthepool.Thethreadexecutesashadow
executiontask to completion,whichis similarto taskparallel run-
times[35].Astheoriginalprogramuses floatordoubletypesthat
have hardware support,it issubstantially faster thanthe software
MPFRlibrary.Hence,therearesufficientshadowexecutiontasks
forthepoolofthreadstoexecute.Tokeeptheresource(memory)
usage bounded, there are fixed number of entries in the task queue.
If the producer ( i.e., original program) creates more tasks thanthe
size of the task queue, then the producer stalls until there is space
in the queue. To minimize contention, the queue used to communi-
catevaluesfromtheproducertotheshadowexecutiontaskuses
non-blocking datastructures. The useofnon-blocking tasksand
thework-stealingalgorithmensuresdynamicloadbalancingand
providesscalablespeedups.
Metadatatodetectanddebugerrors. The shadow execution
task has all the live FP values from the queue and the runtime
callsintroducedbythecompilerperformshigh-precisionexecution
usingrealnumbers( i.e.theMPFRdatatype).Theshadowexecution
taskstoreshigh-precisionvaluesinshadowmemory( i.e.,anaddress
mapped to the original address produced by the program). The
shadowmemoryoftwodifferenttasksarecompletelyisolatedfrom
eachother.
TodetecterrorsintheFPprogramcomparedtoanoracleexe-
cutionwithrealnumbers( i.e.,theMPFRdatatype),wemaintain
therealvaluewitheachtemporaryandeachmemorylocation.The
temporariesaretypicallyregisterallocatedorallocatedonthestack.
The metadata for temporaries also maintains information abouttheoperationandthepointerstothemetadataoftheoperandsof
theinstruction.Foreverymemorylocation,wemaintainthereal
value and the pointer to the metadata of the temporary that previ-
ously wrote to that memory location. Figure 5shows the metadata
maintained with each temporary. This metadata about operands
in temporaries enables us to construct the DAG on an error ( i.e.,
backwardsliceresponsiblefortheerror).Figure 5alsoillustrates
theconstructionoftheDAGusingthemetadatainshadowmemory
andforthetemporaries,whichissimilarto ourdesignin FPSani-
tizer[9].
OnamemoryoperationthatreadsaFPvaluefrommemorytoa
variable, the shadow executiontask creates a new metadata entry
for the variable ( i.e., a temporary). It copies the real value from
shadowmemorytothetemporaryâ€™smetadata.Further,itcopiesthe
informationaboutthepreviouswriteranditsoperandstofacilitate
the subsequent construction of the DAG.
Shadowexecutionfromanarbitrarymemorystate. Aswe
arecreatingaparallelshadowexecutionfromasequentialprogram,
we needto provideappropriatememory statefor the shadowexe-
cutiontasks.Our key insight is to useFPvaluesfromtheoriginal
program (theproducer)as the oracle whenevershadow execution
lacks information ( i.e., either due to an uninstrumented library call
or the task is accessing an untracked location for the first time).
Hence, we can execute the shadow execution task even when prior
shadow execution tasks have not completed as long as the original
program has executedthe corresponding instructions.
InadditiontotheliveFPvaluesandaddressesforthememory
accesses, the producer also provides the FP value loaded by the
programoneverymemoryreadinstruction.Theshadowexecution
taskmaintainstheFPvalueinthemetadataforbothtemporaries
and shadow memory locations as shown in Figure 5. To enable the
shadow execution task to start from an arbitrary memory state,
PFPSanitizer takesthefollowingactionswheneverthetaskwants
toperformamemory(read)access.First,theshadowtaskretrieves
the address of the memory operation and the FP value produced
by the producer from the queue. Second, it accesses the shadow
memory location corresponding to the address provided by the
producer. Third, it checks if the FP value in the metadata is exactly
equaltotheFPvaluefromtheproducer.Ifso, PFPSanitizer con-
tinues to use the real value in the metadata because the shadow
taskpreviouslywrotetothatlocation.Otherwise, PFPSanitizer
uses the FP value fromthe producer as the oracle and reinitializes
the shadow memory for that memory location with the producerâ€™s
FP value. If the FP values do not match, then the previous writer to
the particular memory location did not update metadata. Such mis-
matcheshappenwhenanupdateoccursinuninstrumentedcodeor
the update happens in other shadow tasks. Figure 6illustrates our
approachtostartshadowexecutionfromarbitrarymemorystate
withthis technique.
Detecting errors. To detect FP errors, PFPSanitizer â€™s runtime
needs to convert the MPFR value in the shadow task to a double
valueandcompareittothedoublevaluegeneratedbytheproducer.
Ifthe errorexceeds somethreshold, then it can be reported tothe
user.Such checksare performedon branchconditionsthatuseFP
values,argumentstosystemcalls,returnvaluesfromfunctions,and
user-specifiedoperations.Thisfine-grainedcomparisonoftheFP
620Parallel ShadowExecutionto Acceleratethe Debuggingof Numerical Errors ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
   x_val = *x;
0x6800a0 2.35  x_s = pfpsan_load(2.35, 0x6800a0);
enqueuedequeueOriginal program 
load (producer)
address FP valueShadow execution task (consumer) 
2.35Shadow Memory (smem)
2.3486.. .. 0x44ab0
.. .. ..ï¬‚oat realDAG
 info
.. .. ..
3.5 3.51 ..0x44ab0 = shadow_addr( 0x68000);
smem(0x44ab0).ï¬‚oat 
== 2.35? 
x_s = 2.3486.. x_s = 2.35Yes Nopfpsan_load in action
Figure 6: Our approach to execute shadow task from an arbitrary memory state. PFPSanitizer maintains the FP value in
shadow memory and checks if the programâ€™s FP value is exactly equal to the value in shadow memory. If so, it uses the real
valueforsubsequentshadowexecution.Otherwise,itusestheprogramâ€™sFPvalueastheoracle.Here, pfpsan_load firstmaps
theproducerâ€™s address to ashadow address andretrievesthemetadata fromshadow memory.
programand thehigh-precision executionenables comprehensive
detection ofnumerical errors.
4 IMPLEMENTATION CONSIDERATIONS
PFPSanitizer enhances the LLVM compiler to add instrumenta-
tion to the original program and to create shadow execution tasks.
PFPSanitizer â€™s runtime is in C++, which is linked with the binary
whentheprogramiscompiled.Specifically,theruntimemanages
taskcreation,managementofqueuesassociatedwithtasks,creation
of worker threads, and the implementation of the work stealing
algorithmtodynamicallybalancetheloadamongthethreads.Al-
though the producer creates numerous shadow tasks, the number
ofthreadscreatedbytheruntimeisequaltothenumberofcores
in the system to avoid unnecessary context switches. We describe
important implementation decisions in building the PFPSanitizer
prototype.
Shadow memory organization. Ashadowexecutiontaskac-
cesses shadow memory, which maps each memory address with
an FP value to its corresponding real value. Each worker thread
hasitsownshadowmemory,whichiscompletelyisolatedfromthe
shadowmemoryofotherthreads.Toboundthememoryusage, PF-
PSanitizer uses a fixed-size shadow memory for each thread that
is organized as a best-effort hash table (similar to a direct-mapped
cache). On a conflict, when two addresses map to the same shadow
memorylocation, PFPSanitizer overwritestheshadowmemory
location with the information about the latest writer. We handle
thislossofinformationonconflictsusingourtechniquetoperform
shadowexecutionfrom an arbitrary memory state.
Management oftemporary metadata space. PFPSanitizer
maintainsmetadatawith eachtemporaryintheLLVMintermedi-
aterepresentation. PFPSanitizer usesaseparateboundedspace
to maintain temporary metadata. When this space is completely
utilized,PFPSanitizer automaticallyreclaimsthespace allocated
to oldest entry in this metadata space. Hence, PFPSanitizer â€™s run-
time also checks the validity of the temporary metadata pointer
in shadow memory before dereferencing it, which is similar to FP-
Sanitizerâ€™stemporalsafetychecking[ 9].Ratherthanmaintaining
uniquemetadataentryforeachdynamicinstruction, PFPSanitizer
maintainsauniqueentryforeachstaticinstruction.Asaresult, PF-
PSanitizer produces DAGs that are restricted to the last iteration
inaprogram withloops.Handling indirect function calls. PFPSanitizer â€™s compiler
creates ahigh-precision versionfor eachfunctionin theprogram.
PFPSanitizer â€™sruntimemaintainsthemappingbetweenthead-
dress of the original function and the address of the corresponding
shadow function. PFPSanitizer â€™s compiler replaces all direct func-
tioncallsintheshadowexecutiontaskwiththeircorresponding
shadowfunctions.Tohandleindirectfunctions( i.e.,callsthrougha
function pointer), PFPSanitizer â€™s compiler introduces a call to the
runtimeintheshadowexecutiontaskthatusestheaddressofthe
original function provided by the producer on the queue and calls
the corresponding shadow function using the mapping maintained
bythe runtime.
Support for multithreaded applications. Although we de-
scribeourapproachassumingasinglethreadedprogram,ourap-
proachwillworkseamlesslywithmultithreadedapplications.As
PFPSanitizer treats the FPvalue produced by theprogram as the
oracle,itcandetecterrorseveninprogramswithraces.However,it
willnotdetecterrorsspecificallyduetodataraces.Onechallenge
with multithreaded applications is the allocation of cores to the
original program and the shadow execution tasks. Parallel shadow
executionwith PFPSanitizer willbebeneficialcomparedtoinlined
shadow execution when there is at least one core unused by the
originalmultithreadedapplication.
Usage with interactive debuggers. PFPSanitizer supports
debugging with interactive debuggers like gdb. To enable such
debugging,wepropagatedebuggingsymbolsfromtheoriginalpro-
gramtotheshadowexecutiontask.Hence,thedevelopercaninsert
breakpoints/watchpoints on functions in the shadow execution
task. The backward slice of the instructions with the DAG and the
detection enabled us to find and debug errors with the Cholesky
application.
5 EXPERIMENTALEVALUATION
This section briefly describes our prototype, methodology, and
performance evaluation.
5.1 PrototypeandExperimentalMethodology
Prototype .Webuilttheprototypeof PFPSanitizer withtwocom-
ponents:(1)anLLVM-9.0compilerpassthattakesCprogramsas
input and creates binaries with shadow tasks and (2) a runtime
written in C++ that manages worker threads, shadow memory,
621ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece Sangeeta Chowdhary andSantoshNagarakatte
andperformsthehigh-precisioncomputationusingtheMPFRli-
brary [17].PFPSanitizer can be customized to perform shadow
execution with a wide range of precision bits and also check error
at various granularities. PFPSanitizer is open source and publicly
available [ 11].
Methodology. To evaluate the detection abilities and perfor-
mance of PFPSanitizer , we perform experiments using C appli-
cationsfrom the SPEC 2000,SPEC 2006,PolyBench, and CORAL
applicationsuites.SPECiswidelyusedtotesttheperformanceof
compilersandprocessors.CORALisasuiteofapplicationsdevel-
opedbyLawrenceLivermoreNationalLaboratorytotesttheperfor-
manceofsupercomputers.Specifically,AMGisaCapplicationthat
isanalgebraicmulti-gridlinearsystemsolverforunstructuredmesh
physicspackages.Totestthedetectionabilities,weusedatestsuite
with43micro-benchmarksthatcontainvariousFPerrorsthathave
beenusedpreviouslybypriorapproaches[ 9,38].Weperformedall
ourexperimentsonamachinewithAMDEPYC7702P64-CorePro-
cessorand126GBofmainmemory.Wedisabledhyper-threading
andturbo-boostonourmachinestominimizeperturbations.We
measureend-to-endwallclocktimetoevaluateperformance.We
report speedups over our prior work FPSanitizer [ 9,10] , which
is the state-of-the-art shadow execution tool for inlined shadow
execution.Weusetheexactsameprecisionbothfor FPSanitizer
andPFPSanitizer when we report speedups. We use the uninstru-
mented original program to report slowdowns with PFPSanitizer .
Tocomputethe errorinthe doublevalue produced by the program
in comparison to the real value, we convert the MPFR value to
doubleandcomputetheULPerrorbetweenthedoubles[ 9,38].If
the exponent of the two such values differ, then all the precision
bitsareinerror.Ifallthebitsdiffer,thenentiredoubleisinfluenced
byroundingerror.
Placement of directives. To create tasks for parallel shadow
execution, we profiled applications to identify loops with inde-
pendent iterations and placed directives. In the absence of such
fragments, we placed directives following the approach that one
typicallytakestodebugalargeprogram.Whentheprogrammer
doesnotknowifabugexistsintheprogram,itmaybebeneficial
to run it with a single directive ( i.e., entire program), which can
provide a maximum speedup of 2Ã—over inlined shadow execution.
Once we are certain about the existence of the bug, we use the fol-
lowing procedure to debug it. We profile the application using the
gprofprofiler,identifythetop- ğ‘›functions,andplacethedirectives
atthebeginningofthesefunctions.Ifthishassufficientparallelism
andwecandebugtheerror,thentheprocessends.Otherwise,we
remove the old directives, insert new ğ‘›/2directives corresponding
tothetop ğ‘›/2long-runningfunctions,andrepeatthisprocess.This
processcontinuesuntilweeitherdebugtherootcauseofthebug
with sufficient parallelism or end up with a single directive. For
ourperformanceexperiments,weplaceddirectivesusingtheabove
procedure to ensure that the application had enough parallelism
for executionon64-cores.
5.2 Ability to Detect FP Errors
To test the effectiveness of PFPSanitizer in detecting existing
errors, we tested it with a test suite used by previous tools. Out
of the 43 tests, 12 test cases are from the Herbgrind test suite,Table 2: Table reports the various kinds of bugs that we
found in the programs used for our performance experi-
ments. We report the number of static instructions that ex-
periencebranchdivergencesinthesecondcolumn,thenum-
ber of instances where all bits are wrong in the third col-
umn (i.e., sign, exponent, and precision bits), number of in-
stances where all the precision bits are wrong in the fourth
column ( i.e., 52 bits of precision with double), and number
ofinstanceswherethanmorethanfiftypercentofthepreci-
sionbitsarewrong(fifthcolumn).Thelastcolumnprovides
thenumberofnon-commentandnon-blanklinesofcodein
theapplication.
NameBranch
FlipsAllBits
WrongAllPrecision
BitsWrong50%Precision
BitsWrong#
Lines
art 2 0 0 0 1070
ammp 0 0 0 0 9791
equake 0 0 310 605 1125
lbm 4 0 609 1197 721
milc 1 0 378 607 8568
sphinx 0 0 2 56 11029
amg 0 0 4 14 58679
milcmk 0 0 0 0 88064
and the rest are from the FPSanitizer test suite. These test cases
include 16 cases of catastrophic cancellation ( i.e., all the bits are
wrong between the real value andthe FP value), 5 cases of branch
divergences, and 2 cases of exceptional conditions such as NaNs
and infinities. Rest of them do not have any numerical error but
have tricky FP computation that test dynamic tools. PFPSanitizer
detectsallerrorswithoutreportingany spuriouserrors.
Table2providesinformationontheerrorsthatwedetectedin
applications from SPEC and CORAL, which have several thousand
linesofcode.Astheseapplicationsarewelltestedforexceptions,
we did not find exceptional conditions such as NaNs/infinities and
instanceswhereallbitsarewrong.However,wedetectedbranch
divergences in the SPEC application art. When we investigated
the root cause of these branch divergences, we identified the FP
equality comparison as the culprit. Similarly, we observed many
instancesofprecisionlosswhereallprecisionbitsarewrong(52
bitsinadouble)ormorethan50%oftheprecisionbitsarewrong.
Our investigation indicates that these are real divergences from an
oracle execution with reals. These bugs need to be validated by the
developer oftheseapplications.
5.3 DebugginganError in Cholesky
We discovered an error in the Cholesky decomposition program
fromthePolybenchbenchmarksuite. PFPSanitizer detectedinfini-
ties and NaNs ( i.e., exceptional conditions) at various places in the
application. The programâ€™s code or documentation did not provide
thereasonfortheexception.Wedescribehow PFPSanitizer was
helpfulinbothdetectinganddebuggingtherootcauseofthiserror.
Cholesky decomposition [ 21]isa widely used algorithm invar-
ious domains and problems such as Monte Carlo simulation and
Kalman filters.Cholesky takes a ğ‘Ã—ğ‘positive-definite matrix ğ´
asinputandoutputsalowertriangularmatrixwhere ğ¿Ã—ğ¿ğ‘‡=ğ´,
622Parallel ShadowExecutionto Acceleratethe Debuggingof Numerical Errors ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
fdiv:189
ï¬‚oat:Inf
mpfr:5472
fsub:172
ï¬‚oat:5472.0
mpfr:5472.0sqrt:238
ï¬‚oat:0.0
mpfr:1.0Error: 61 bits
Error: 61 bits
fsub:218
ï¬‚oat:0.0
mpfr:1.0
fadd:450
ï¬‚oat:27040000.0
mpfr:27040001.0fmul:212
ï¬‚oat:27040000.0
mpfr:27040000.0Error: 28 bitsError: 61 bitsError: 0 bits
fmul:443
ï¬‚oat:1.0
mpfr:1.0Error: 0 bitsError: 28 bits
Error: 0 bitsfadd:450
ï¬‚oat:27040000.0
mpfr:27040001.0
fadd:450
ï¬‚oat:27040000.0
mpfr:27040000.0
Error: 0 bits
(a) (b)
Figure7:ADAGofinstructionsgeneratedby PFPSanitizer
whiledebuggingtheerrorinCholesky.Eachnodeshowsthe
opcode, instruction id, computed value, real value and the
numerical error occurred. (a) The DAG for the fdivinstruc-
tion that results in infinities (inf). (b) The DAG for the fadd
instructionthat istheroot cause oftheerror.
whereğ¿ğ‘‡isthetransposeof ğ¿.Lowertriangularmatrix ğ¿iscom-
putedas shownbelow,where iandj represent matrixindices.
ğ¿ğ‘–,ğ‘—=ï£±ï£´ï£´ ï£²
ï£´ï£´ï£³ğ‘–=ğ‘—:/radicalBig
ğ´(ğ‘–,ğ‘–) âˆ’/summationtext.1ğ‘–âˆ’1
ğ‘˜=0ğ¿(ğ‘–,ğ‘˜)2
ğ‘–>ğ‘—:ğ´(ğ‘–,ğ‘—)âˆ’/summationtext.1ğ‘—âˆ’1
ğ‘˜=0ğ¿(ğ‘–,ğ‘˜)ğ¿(ğ‘˜,ğ‘—)
ğ¿(ğ‘—,ğ‘—)(1)
Itcanbeobservedthatthecomputationcanproduceinfinities
(andNaNswheninfinitiesgetpropagated)when ğ¿(ğ‘—, ğ‘—)evaluatesto
zero,whichhappenswhenthematrix ğ´isnotpositivesemi-definite.
Tomake the matrix positive semi-definite, Cholesky in Polybench
computes ğ´=ğ´Ã—ğ´ğ‘‡.Whenthiscomputationisperformedwith
reals, the resultingmatrix ğ´is positive semi-definite for allinputs.
Wegeneratedinputstothisapplicationusinganinputgenerator
and ran the application with PFPSanitizer using those inputs.
Specifically,when we generatedthe inputmatrix.
ğ´=ï£®ï£¯ï£¯ï£¯ï£¯ï£°1.0 0.0 0.0
5200.0 1.0 0.0
0.0 5472 .0 1.0ï£¹ï£ºï£ºï£ºï£ºï£»(2)
PFPSanitizer detectedNaNsandinfinitiesintheprogram.Next,
we describe the processwe usedto debug this error.
When the matrix ğ´is adjusted to make it positive semi-definite
(i.e.,ğ´Ã—ğ´ğ‘‡), the resultantmatrix ğ´inreal numbers is
ï£®ï£¯ï£¯ï£¯ï£¯ï£°1.0 5200 .0 0 .0
5200.027040001.0 5472.0
0.0 5472 .0 29942785 .0ï£¹ï£ºï£ºï£ºï£ºï£»(3)
UsingPFPSanitizer ,we observed thattheprogram computes the
following matrix.
ï£®ï£¯ï£¯ï£¯ï£¯ï£°1.0 5200 .0 0 .0
5200.027040000.0 5472.0
0.0 5472 .0 29942785 .0ï£¹ï£ºï£ºï£ºï£ºï£»(4)
Specifically, ğ´[1][1]when computedwith real numbers cannot
be exactly represented in a 32-bit float. Hence, it is rounded to
27040000.PFPSanitizer identifiedthatthecomputationof ğ´[1][1]
in the lower triangular matrix differs from the oracle execution.
Specifically, ğ´[1][1]iscomputedas ğ´[1][1]âˆ’(ğ´[1][0]âˆ—ğ´[1][0]).TheFPprogramproducesa0whereastheoracleexecutionwith
realarithmeticproduces1.Subsequent,divisionoperationresults
ininfinitiesfor the 32-bitfloat version.
We used the gdbdebugger to insert a conditional breakpoint
in thePFPSanitizer â€™s runtime when the program produces an
infinityoraNaNintheresultofanyoperation.Weobservedthat
breakpoint was triggered with a fdivinstruction. We generated
theDAGinthedebugger.Figure 7providestheDAG,whereeach
nodes provides the instruction (instruction opcode:instructionid)
and number of bits of error with it. Figure 7(a) shows that error
occursin fadd:450 and is amplifiedby fsub:218 . Toidentify why
fadd:450 hasanyerror,wesetabreakpointonthe faddinstruc-
tioniftheerrorisgreaterthanorequalto28bits.Figure 7(b)shows
theDAGgeneratedby PFPSanitizer .Thereal executionwiththe
MPFRtypecomputed27040001whiletheFPcomputationproduced
27040000.Thevalue27040001cannotbeexactlyrepresentedina
32-bitfloatandit isroundedto27040000.Wereportedthis bugto
the maintainersof thePolyBenchsuite.Theyhaveacknowledged
the error. For performance reasons, all kernels in the PolyBench
suite avoid such checks. They delegate the responsibility of check-
ing invalid inputs to the user. Our experience demonstrates that
PFPSanitizer willbeusefulindebuggingerrorsthatresultfrom
such implicitpreconditions.
5.4 Performance Evaluationof PFPSanitizer
Figure8reports the speedup with PFPSanitizer that uses 512-bits
of precision for the MPFR type when compared to FPSanitizer ,
whichis thestateoftheartforshadowexecutionofFPprograms,
withtheincreaseinthenumberofcores.Onaverage, PFPSanitizer
providesaspeedupof 30.6Ã—speedupoverFPSanitizerwith64cores.
PFPSanitizer provides speedups of 3.0Ã—,7.0Ã—,14.3Ã—, and25.8Ã—
speedup over FPSanitizer with 4 cores, 8 cores, 16 cores, and 32
cores,respectively.Thisincreaseinspeedupwiththeincreaseinthe
number of cores highlights PFPSanitizer â€™s scalability. We observe
thatsomeapplicationsprovidemorespeedupwith32coresthan64
coresbecausethereisnotenoughworkintheapplicationtoutilize
allcores when executedwith64 cores.
Figure9shows execution time slowdown of PFPSanitizer with
varyingprecisions fortheMPFR type(128,256, 512,and1024 bits
of precision) over a baseline that does not perform any shadow
execution.Onaverage, PFPSanitizer experiencesaslowdownof
5.6Ã—,6.2Ã—,7.5Ã—,and10.9Ã—comparedtothebaselinewithoutany
shadow execution for the MPFR types with 128, 256, 512, and 1024
bitsofprecision,respectively.Incontrast,priorworkFPSanitizer
has slowdowns of 232Ã—on average with 512 bits ofprecision over
the same baseline with these applications. This order of magnitude
decreaseinslowdownfromFPSanitizerto PFPSanitizer enables
effective debuggingwithlong-running applications.
We also investigated the cause of the remaining overheads with
parallelshadowexecution.First,theproducerhastoprovidevalues
tothequeueandhastowaitwhenallthetasksareactive,which
causes an overhead of 3Ã—over the baseline. Second, accesses to
shadowmemoryandthequeuesbytheconsumertaskintroducesan
additionaloverheadof 3Ã—.Third,thehighprecisioncomputation
with the MPFR library introduces additional 1.5Ã—overhead on
average. All these overheads together add up to 7.5Ã—slowdown
623ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece Sangeeta Chowdhary andSantoshNagarakatte
0X20X40X60XSpeedup 
4-Core 8-Core 16-Core 32-Core 64-Core
art
ammp equakelbm milcsphinxamg
milcmkgeomean
Figure8:Thisgraphreportsthespeedupof PFPSanitizer overFPSanitizerwhentheprogramisexecutedwith4cores,8cores,
16cores,32cores,and64cores,respectively.As these report speedups, higher bars are better.
0X10X20X30XSlowdown 
Prec-1024 Prec-512 Prec-256 Prec-128
art
ammp equakelbm milcsphinxamg
milcmkgeomean
Figure9:Thisgraphreportstheslowdownexperiencedduetoparallelshadowexecutionwith PFPSanitizer whencompared
toabaselinewithoutanyinstrumentation.Wereporttheslowdownswhenwevarythenumberofbitsusedfortheprecision
intheMPFR data type:1024 (Prec-1024), 512 (Prec-512),256 (Prec-256),and128 (Prec-128) bits ofprecision.
withPFPSanitizer using 512 bits of precision over the baseline.
Insummary, PFPSanitizer reducestheperformanceoverheadof
shadowexecutionsignificantly,whichenablestheuseofshadow
executionwithlong-running applications.
6 RELATED WORK
Therelatedworkcanbebroadlyclassifiedintotwomaincategories:
(a)thosethat detectnumericalerrorsand(2)thosethataccelerate
dynamicanalysiswithparallelism.
Detectingnumericalerrors. Thereisalargebodyofworkon
detectingnumericalerrorsusing bothstaticanalysis anddynamic
analysis.Staticanalysistechniques[ 2,12Å›14,19,39]useabstract
interpretation or interval arithmetic to reason about numerical
errorsforallinputs.Errorboundsforallinputsfromstaticanalysis
isappealing.However,theboundscanbetoolargeespeciallyinthe
presenceofloops,functioncalls,andpointer-intensive programs.
Dynamicanalysisfordetectinganddebuggingnumerical
errors.Dynamic analysesfocusonthe programâ€™s behavior fora
giveninput.Theycanbeclassifiedintoapproachesthattargetaspe-
cific classof errors[ 1,16,22,24] and thosethatare comprehensive
detectors [ 3,9,38].Any such analysis needssome oracleto com-
pareagainsttheFPexecution.Inlinedshadowexecutionwithareal
number, whichisapproximatedwithahigh-precisionMPFRdatatype, is one such oracle. FPDebug [ 3], Herbgrind [ 38], and FPSani-
tizer[9]areexamplesofapproacheswithinlinedshadowexecution.
FPDebug and Herbgrind perform shadow execution with dynamic
binaryinstrumentationusingValgrind[ 32],whichintroducessig-
nificantoverheads.FPSanitizeraddressesthisissuewithaLLVM
IR based instrumentation. Among these approaches, FPDebug does
notprovideadditionalinformationfordebuggingerrors.Herbgrind
and FPSanitizer provide DAGs to debug errors. Such DAGs can be
used with tools like Herbie [ 34] to rewrite expressions. To provide
DAGs,Herbgrind storesmetadatathatisproportionalto thenum-
ber ofdynamicinstructions with each memory location.Hence, it
runsout-of-memorywithlong-runningapplications.Incontrast,
FPSanitizerboundstheusageofmemoryandcanrunwithlargeap-
plicationswithoutencounteringout-of-memoryerrors.However,
large performance overheads ( i.e.,100Ã—or more) makes it chal-
lenging for debugging. Further, expert-crafted code ( e.g., error free
transformations[ 31])isachallengefortheseapproachesasthey
canreportspuriouserrorswiththem.PSO[ 42]tacklesthisproblem
bybuildingheuristicstodetectsuchinstructionsandassisttools
to avoid such scenarios. Our approach is inspired by FPSanitizer
butreduces the performance overheads significantly with parallel
execution so that the shadow execution can be performed with
long-running applications.
624Parallel ShadowExecutionto Acceleratethe Debuggingof Numerical Errors ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece
Instead of using the MPFR library, real arithmetic has also been
approximated with constructive reals [ 4,5,23]. However, they will
likely be as slowas theMPFR library. To addressthe issue of slow
oracles, BZ [ 1] monitors just the exponent of the operands and
theresultoftheFPcomputation.Iftheexponentoftheoperands
exceeds the exponent of the result, then it flags those operations
as errors. Although approximate, such checks can be performed
without the real execution as an oracle. The propagation of such
likelyerrorscanbetrackedtoseeiftheyaffectbranchpredicates.
RAIVE [24] uses similar approximation, computes the impact of
such likely errors on the final output of the program, and uses
vectorizationtoreduceperformanceoverheads.FPSpy[ 15]relies
on hardware condition flags and uses exception handling to detect
FPerrorsinbinaries.Ithaslowoverheadsaslongastheprogram
is monitored rarely and overhead can exceed shadow execution
tools when such exceptions are monitored on each instruction.
To check the sensitivity of the program to the rounding mode,
another approach is to perform dynamic analysis with random
rounding. CADNA [ 22] and Verrou [ 16] use random rounding.
Similarly,conditionnumberofindividualoperationscanbeused
todetectnumericalerrorsandinstabilityinFPapplications[ 45].In
contrasttotheseapproachesthatdetectlikelyerrors,ourapproach
has similar or lower performance overheads when compared to
them while providing comprehensive detection and debugging
support using shadowexecutionwithreal numbers.
Precision tuning to reduce errors. One way to avoid com-
mon numerical errors is to select appropriate precision for each
variable.Previousapproacheshaveexploredtuningtheprecision
ofFPvariablesforallinputsandforaspecificexecutiontoimprove
performance andto reduce the occurrence ofFPerrors[ 7,37].
Identifying inputs with high FP error. Dynamic analyses
need inputs that exercise operations with FP error. Hence, prior
research hasexploredsymbolicexecution, forwardandbackward
erroranalysis,andrandominputgenerationtogeneratesuchin-
puts [8,20,36]. Techniques to generate inputs complement our
approachandcanenableustodetectanddebugFPerrorsefficiently
as we illustratedwithour Cholesky casestudy.
Parallel dynamic analysis. In the context of dynamic anal-
ysis for detecting memory safety errors and race detection, nu-
merous parallel analysis techniques have been explored [ 6,40,43].
Approaches that perform fine grained monitoring use hardware
support as with a dedicated operand queue in Log-Based Architec-
ture (LBA) [ 6]. Further, dataflow analyses have been modified to
accelerate dynamic analyseswith LBA [ 41]. Other approachesfor
parallel data race detection and deterministic execution monitor
programsatthegranularityofepochs[ 40].Theclosestrelatedwork
is Cruiser [ 43], which is a heap-based overflow detector. Cruiser
performsvaliditychecksforeachmemoryaccessonaseparatecore.
It has a single producer and a consumer, which is acceptable when
the checks are lightweight. Cruiser just needs to pass the memory
address of the access to another core performing the check. In con-
trasttoCruiser, PFPSanitizer addressestheissuesofmonitoring
errors even on arithmetic instructions, parallel execution from a
single threadeddynamic execution,and a relatively heavy-weight
dynamicanalysiswithsupport for debugging.7 CONCLUSION
Thispaper advances the state-of-the-artindebuggingnumerical
errors by performing shadow execution with higher precision. To
enable the use of such shadow execution with long-running ap-
plications, we perform shadow execution in parallel. As we are
creating parallel execution from a sequential program, we need
to provide appropriate memory state for shadow execution. Our
key insight is to use the FP values from the original program as
the oracle for initializing memory state. The resulting tool is an
orderofmagnitudefasterthanexistingshadowexecutiontools.We
believecomprehensivedetectionwiththeseoverheadscanenable
their usage in latestages of development and debugging. Ourexpe-
rience suggests that other dynamic analyses ( e.g., race detectors)
can also benefit from this approach, which we plan to explore in
future work.
ACKNOWLEDGMENTS
WethankthemembersoftheRutgersArchitectureandProgram-
ming Languages group for their feedback. This material is based
uponworksupportedinpartbytheNationalScienceFoundation
underGrantNo.1908798,GrantNo.1917897,andGrantNo.2110861.
Anyopinions,findings,andconclusionsorrecommendationsex-
pressed inthis materialare those oftheauthors and do not neces-
sarilyreflectthe viewsof the National ScienceFoundation.
REFERENCES
[1]Tao Bao and Xiangyu Zhang. 2013. On-the-Fly Detection of Instability Problems
inFloating-PointProgramExecution.In Proceedingsofthe2013ACMSIGPLAN
InternationalConferenceonObjectOrientedProgrammingSystemsLanguages&
Applications (Indianapolis, Indiana, USA) (OOPSLA â€™13) . Association for Comput-
ingMachinery,NewYork,NY,USA,817Å›832. https://doi.org/10.1145/2509136.
2509526
[2]Earl T. Barr, Thanh Vo, Vu Le, and Zhendong Su. 2013. Automatic Detection
ofFloating-pointExceptions.In Proceedingsofthe40thAnnualACMSIGPLAN-
SIGACT Symposium on Principles of Programming Languages (Rome, Italy) (POPL
â€™13).ACM,NewYork,NY,USA,549Å›560. https://doi.org/10.1145/2480359.2429133
[3]Florian Benz, Andreas Hildebrandt, and Sebastian Hack. 2012. A Dynamic
Program Analysis to Find Floating-point Accuracy Problems. In Proceedings
of the 33rd ACM SIGPLAN Conference on Programming Language Design and
Implementation (Beijing,China) (PLDIâ€™12) .ACM,NewYork,NY,USA,453Å›462.
https://doi.org/10.1145/2345156.2254118
[4]Hans-J.Boehm.2005. TheconstructiverealsasaJavalibrary.In TheJournalof
LogicandAlgebraicProgramming ,Vol.64.3Å›11. https://doi.org/10.1016/j.jlap.
2004.07.002
[5]Hans-J. Boehm, Robert Cartwright, Mark Riggle, and Michael J. Oâ€™Donnell. 1986.
Exact Real Arithmetic: A Case Study in Higher Order Programming. In Proceed-
ingsofthe1986ACMConferenceonLISPandFunctionalProgramming (Cambridge,
Massachusetts,USA) (LFPâ€™86).AssociationforComputingMachinery,NewYork,
NY, USA,162Å›173. https://doi.org/10.1145/319838.319860
[6]S. Chen, M. Kozuch, T. Strigkos, B. Falsafi, P. B. Gibbons, T. C. Mowry, V.
Ramachandran, O. Ruwase, M. Ryan, and E. Vlachos. 2008. Flexible Hard-
ware Acceleration for Instruction-Grain Program Monitoring. In 2008 Inter-
national Symposium on Computer Architecture (ISCA 2008) . 377Å›388. https:
//doi.org/10.1109/ISCA.2008.20
[7]Wei-Fan Chiang, Mark Baranowski, Ian Briggs, Alexey Solovyev, Ganesh
Gopalakrishnan, and Zvonimir RakamariÄ‡. 2017. Rigorous Floating-point Mixed-
precision Tuning. In Proceedings of the 44th ACM SIGPLAN Symposium on Princi-
ples of Programming Languages (Paris, France) (POPL 2017) . ACM, New York, NY,
USA,300Å›315. https://doi.org/10.1145/3009837.3009846
[8]Wei-Fan Chiang, Ganesh Gopalakrishnan, Zvonimir Rakamaric, and Alexey
Solovyev.2014. Efficient Searchfor InputsCausingHigh Floating-pointErrors.
InProceedings of the 19th ACM SIGPLAN Symposium on Principles and Practice of
ParallelProgramming (Orlando,Florida,USA) (PPoPPâ€™14) .ACM,NewYork,NY,
USA,43Å›52. https://doi.org/10.1145/2555243.2555265
[9]SangeetaChowdhary,JayP.Lim,andSantoshNagarakatte.2020. Debuggingand
DetectingNumericalErrorsinComputationwithPosits.In Proceedingsofthe41st
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
625ESEC/FSE â€™21, August 23Å›28, 2021,Athens,Greece Sangeeta Chowdhary andSantoshNagarakatte
(London, UK) (PLDI 2020) . Association for Computing Machinery, New York, NY,
USA,731Å›746. https://doi.org/10.1145/3385412.3386004
[10]Sangeeta Chowdhary, Jay P Lim, and Santosh Nagarakatte. 2020. FPSanitizer
- A debugger to detect and diagnose numerical errors in floating point programs .
Retrieved June, 2021 from https://github.com/rutgers-apl/fpsanitizer
[11]Sangeeta Chowdhary and Santosh Nagarakatte. 2021. PFPSanitizer - Parallel
Shadow Execution to Detect and Diagnose Numerical Errors in Floating Point Pro-
grams. Retrieved June, 2021 from https://github.com/rutgers-apl/PFPSanitizer
[12]Eva Darulova and Viktor Kuncak. 2014. Sound Compilation of Reals. In Proceed-
ings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages (SanDiego,California,USA) (POPLâ€™14) .ACM,NewYork,NY,USA,
235Å›248. https://doi.org/10.1145/2535838.2535874
[13]Marc Daumas and Guillaume Melquiond. 2010. Certification of Bounds on
ExpressionsInvolvingRoundedOperators. ACMTrans.Math.Softw. 37,1,Article
2 (Jan. 2010),20pages. https://doi.org/10.1145/1644001.1644003
[14]David Delmas and Jean Souyris. 2007. AstrÃ©e: From Research to Industry.
InProceedings of the 14th International Conference on Static Analysis (Kon-
gensLyngby,Denmark) (SASâ€™07).Springer-Verlag,Berlin,Heidelberg,437Å›451.
https://doi.org/10.1007/978-3-540-74061-2_27
[15]PeterDinda,AlexBernat,andConorHetland.2020. SpyingontheFloatingPoint
BehaviorofExisting,UnmodifiedScientificApplications.In Proceedingsofthe29th
InternationalSymposiumonHigh-PerformanceParallelandDistributedComputing
(Stockholm,Sweden) (HPDCâ€™20) .AssociationforComputingMachinery,New
York, NY, USA,5Å›16. https://doi.org/10.1145/3369583.3392673
[16]FranÃ§oisFÃ©votteandBrunoLathuiliÃ¨re.2016. VERROU:AssessingFloating-Point
AccuracyWithoutRecompiling.(Oct.2016). https://hal.archives-ouvertes.fr/hal-
01383417 working paper orpreprint.
[17]LaurentFousse,GuillaumeHanrot,VincentLefÃ¨vre,PatrickPÃ©lissier,andPaul
Zimmermann. 2007. MPFR: A Multiple-precision Binary Floating-point Library
with Correct Rounding. In ACM Transactions on Mathematical Software , Vol. 33.
ACM,NewYork,NY,USA,Article13. https://doi.org/10.1145/1236463.1236468
[18]David Goldberg. 1991. What Every Computer Scientist Should Know About
Floating-point Arithmetic. In ACM Computing Surveys , Vol. 23. ACM, New York,
NY, USA,5Å›48. https://doi.org/10.1145/103162.103163
[19]Eric Goubault. 2001. Static Analyses of the Precision of Floating-Point Opera-
tions. InProceedings ofthe 8th InternationalSymposiumonStatic Analysis (SAS) .
Springer, 234Å›259. https://doi.org/10.1007/3-540-47764-0_14
[20]HuiGuoandCindyRubio-GonzÃ¡lez.2020. EfficientGenerationofError-Inducing
Floating-PointInputsviaSymbolicExecution.In ProceedingsoftheACM/IEEE
42nd International Conference on Software Engineering (ICSE 2020) . 1261Å›1272.
https://doi.org/10.1145/3377811.3380359
[21]Caroline N. Haddad. 2009. Cholesky Factorization . Springer US, Boston, MA,
374Å›377. https://doi.org/10.1007/978-0-387-74759-0_67
[22]Fabienne JÃ©zÃ©quel and Jean-Marie Chesneaux. 2008. CADNA: a library for
estimatinground-offerrorpropagation. ComputerPhysicsCommunications 178,
12(June2008),933Å›955. https://doi.org/10.1016/j.cpc.2008.02.003
[23]Vernon A. Lee, Jr. and Hans-J. Boehm. 1990. Optimizing Programs over the
Constructive Reals. In Proceedings of the ACM SIGPLAN 1990 Conference on
Programming Language Design and Implementation (White Plains, New York,
USA)(PLDIâ€™90) .ACM,NewYork,NY,USA,102Å›111. https://doi.org/10.1145/
93548.9355
[24]Wen-Chuan Lee, Tao Bao, Yunhui Zheng, Xiangyu Zhang, Keval Vora, and
Rajiv Gupta. 2015. RAIVE: Runtime Assessment of Floating-point Instabil-
ity by Vectorization. In Proceedings of the 2015 ACM SIGPLAN International
Conference on Object-Oriented Programming, Systems, Languages, and Applica-
tions(Pittsburgh, PA,USA) (OOPSLA2015) .ACM, NewYork,NY,USA,623Å›638.
https://doi.org/10.1145/2814270.2814299
[25]JayP.Lim,MridulAanjaneya,JohnGustafson,andSantoshNagarakatte.2020. A
NovelApproachtoGenerateCorrectlyRoundedMathLibrariesforNewFloating
Point Representations. arXiv: 2007.05344 Rutgers Department of Computer
Science Technical Report DCS-TR-753.
[26]JayP.Lim,MridulAanjaneya,JohnGustafson,andSantoshNagarakatte.2021.
AnApproachtoGenerateCorrectlyRoundedMathLibrariesforNewFloating
Point Variants. Proceedings of the ACM on Programming Languages 6, POPL,
Article29(Jan. 2021),30pages. https://doi.org/10.1145/3434310
[27]JayP.LimandSantoshNagarakatte.2021. HighPerformanceCorrectlyRounded
Math Libraries for 32-bit Floating Point Representations. In 42nd ACM SIGPLAN
ConferenceonProgrammingLanguageDesignandImplementation(PLDIâ€™21) .https:
//doi.org/10.1145/3453483.3454049
[28]JayPLimandRutgersUniversitySantoshNagarakatte.2021. RLIBM-32:High
Performance Correctly Rounded Math Libraries for 32-bit Floating Point Rep-
resentations. Rutgers Department of Computer Science Technical Report
DCS-TR-754.
[29]Jay P. Lim, Matan Shachnai, and Santosh Nagarakatte. 2020. Approximating
Trigonometric Functions for Posits Using the CORDIC Method. In Proceedings ofthe 17th ACM International Conference on Computing Frontiers (Catania, Sicily,
Italy)(CFâ€™20).AssociationforComputingMachinery,NewYork,NY,USA,19Å›28.
https://doi.org/10.1145/3387902.3392632
[30]Jean-MichelMuller.2005. Onthedefinitionofulp(x) . ResearchReportRR-5504,
LIPRR-2005-09.INRIA,LIP. 16pages. https://hal.inria.fr/inria-00070503
[31]Jean-MichelMuller,NicolasBrunie,FlorentdeDinechin,Claude-PierreJeannerod,
Mioara Joldes, Vincent Lefvre, Guillaume Melquiond, Nathalie Revol, and Serge
Torres.2018. HandbookofFloating-PointArithmetic (2nded.). BirkhÃ¤userBasel.
https://doi.org/10.1007/978-3-319-76526-6
[32]Nicholas Nethercote and Julian Seward. 2007. Valgrind: A Framework for
HeavyweightDynamicBinaryInstrumentation.In Proceedingsofthe28thACM
SIGPLAN Conference on Programming Language Design and Implementation
(San Diego, California, USA) (PLDI â€™07) . ACM, New York, NY, USA, 89Å›100.
https://doi.org/10.1145/1250734.1250746
[33]United StatesGeneral Accounting Office.1992. Patriot MissileDefense: Software
ProblemLedtoSystemFailureatDhahran,SaudiArabia .https://www.gao.gov/
products/IMTEC-92-26
[34]Pavel Panchekha, Alex Sanchez-Stern, James R. Wilcox, and Zachary Tatlock.
2015. Automatically Improving Accuracy for Floating Point Expressions. In Pro-
ceedings of the 36th ACM SIGPLAN Conference on Programming Language Design
andImplementation (Portland,OR,USA) (PLDIâ€™15) .AssociationforComputing
Machinery, New York, NY, USA, 1Å›11. https://doi.org/10.1145/2737924.2737959
[35]JamesReinders.2007. IntelThreadingBuildingBlocks (firsted.). Oâ€™ReillyAsso-
ciates,Inc.,USA.
[36]CindyRubio-GonzÃ¡lez,CuongNguyen,BenjaminMehne,KoushikSen,James
Demmel, William Kahan, Costin Iancu, Wim Lavrijsen, David H. Bailey, and
DavidHough.2016. Floating-PointPrecisionTuningUsingBlameAnalysis.In
Proceedings of the 38th International Conference on Software Engineering (Austin,
Texas)(ICSE â€™16) . Association for Computing Machinery, New York, NY, USA,
1074Å›1085. https://doi.org/10.1145/2884781.2884850
[37]Cindy Rubio-GonzÃ¡lez, Cuong Nguyen, Hong Diep Nguyen, James Demmel,
WilliamKahan,KoushikSen,DavidH.Bailey,CostinIancu,andDavidHough.
2013. Precimonious:TuningAssistantforFloating-pointPrecision.In Proceedings
of the International Conference on High Performance Computing, Networking,
Storage and Analysis (Denver, Colorado) (SC â€™13). ACM, New York, NY, USA,
Article27,12pages. https://doi.org/10.1145/2503210.2503296
[38]Alex Sanchez-Stern,PavelPanchekha, SorinLerner, andZachary Tatlock.2018.
Finding Root Causes of Floating Point Error. In Proceedings of the 39th ACM
SIGPLAN Conference on Programming Language Design and Implementation
(Philadelphia, PA, USA) (PLDI 2018) . ACM, New York, NY, USA, 256Å›269. https:
//doi.org/10.1145/3192366.3192411
[39]Alexey Solovyev, Charles Jacobsen, Zvonimir Rakamaric, and Ganesh Gopalakr-
ishnan. 2015. Rigorous Estimation of Floating-Point Round-off Errors with Sym-
bolic TaylorExpansions.In Formal Methods (LectureNotesin ComputerScience) ,
Vol. 9109.Springer, 532Å›550. https://doi.org/10.1007/978-3-319-19249-9_33
[40]KaushikVeeraraghavan,DongyoonLee,BenjaminWester,JessicaOuyang,Pe-
terM.Chen,JasonFlinn,andSatishNarayanasamy.2012. DoublePlay:Paralleliz-
ing Sequential Logging and Replay. ACM Trans. Comput. Syst. 30, 1, Article 3,
24pages. https://doi.org/10.1145/2110356.2110359
[41]Evangelos Vlachos, Michelle L. Goodstein, Michael A. Kozuch, Shimin Chen,
Babak Falsafi, PhillipB.Gibbons, and ToddC. Mowry. 2010. ParaLog: Enabling
andAccelerating OnlineParallel MonitoringofMultithreadedApplications.In
Proceedings of the Fifteenth International Conference on Architectural Support
for Programming Languages and Operating Systems (Pittsburgh, Pennsylvania,
USA)(ASPLOS XV) . Association for Computing Machinery, New York, NY, USA,
271Å›284. https://doi.org/10.1145/1736020.1736051
[42]RanWang, DamingZou, XinruiHe, Yingfei Xiong, Lu Zhang, andGang Huang.
2016. DetectingandFixingPrecision-specificOperationsforMeasuringFloating-
point Errors. In Proceedings of the 2016 24th ACM SIGSOFT International Sympo-
siumon Foundations of Software Engineering (Seattle,WA, USA) (FSE2016) .ACM,
NewYork, NY, USA,619Å›630. https://doi.org/10.1145/2950290.2950355
[43]Qiang Zeng, Dinghao Wu, and Peng Liu. 2011. Cruiser: Concurrent Heap Buffer
OverflowMonitoringUsingLock-FreeDataStructures.In Proceedingsofthe32nd
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(San Jose, California, USA) (PLDI â€™11) . Association for Computing Machinery,
NewYork, NY, USA,367Å›377. https://doi.org/10.1145/1993498.1993541
[44]CraigZillesandGurindarSohi.2002. Master/SlaveSpeculativeParallelization.In
Proceedingsofthe35thAnnualACM/IEEEInternationalSymposiumonMicroarchi-
tecture(Istanbul,Turkey) (MICRO35) .IEEEComputerSocietyPress,Washington,
DC, USA,85Å›96. https://doi.org/10.1109/MICRO.2002.1176241
[45]Daming Zou, Muhan Zeng, Yingfei Xiong, Zhoulai Fu, Lu Zhang, and Zhendong
Su. 2019. Detecting Floating-Point Errors via Atomic Conditions. Proc. ACM
Program.Lang. 4,POPL,Article60(Dec.2019),27pages. https://doi.org/10.1145/
3371128
626