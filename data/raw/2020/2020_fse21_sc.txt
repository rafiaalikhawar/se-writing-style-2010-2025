SmartCommit: A Graph-Based Interactive Assistant for
Activity-Oriented Commits
Bo Shen
Key Lab of High Confidence Software
Technology (Peking University), MoE
Beijing, ChinaWei Zhang
Key Lab of High Confidence Software
Technology (Peking University), MoE
Beijing, ChinaChristian KÃ¤stner
Carnegie Mellon University
Pittsburgh, PA, USA
Haiyan Zhao
Key Lab of High Confidence Software
Technology (Peking University), MoE
Beijing, ChinaZhao Wei
Huawei Technologies Co., Ltd.
Beijing, ChinaGuangtai Liang
Huawei Technologies Co., Ltd.
Beijing, China
Zhi Jin
Key Lab of High Confidence Software
Technology (Peking University), MoE
Beijing, China
ABSTRACT
In collaborative software development, it is considered to be a best
practice to submit code changes as a sequence of cohesive commits,
each of which records the work result of a specific development
activity , such as adding a new feature, bug fixing, and refactoring.
However, rather than following this best practice, developers of-
ten submit a set of loosely-related changes serving for different
development activities as a composite commit , due to the tedious
manual work and lack of effective tool support to decompose such
atangled changeset . Composite commits often obfuscate the change
history of software artifacts and bring challenges to efficient collab-
oration among developers. To encourage activity-oriented commits,
we propose SmartCommit , a graph-partitioning-based interactive
approach to tangled changeset decomposition that leverages not
only the efficiency of algorithms but also the knowledge of develop-
ers. To evaluate the effectiveness of our approach, we (1) deployed
SmartCommit in an international IT company, and analyzed usage
data collected from a field study with 83 engineers over 9 months;
and (2) conducted a controlled experiment on 3,000 synthetic com-
posite commits from 10 diverse open-source projects. Results show
that SmartCommit achieves a median accuracy between 71â€“84%
when decomposing composite commits without developer involve-
ment, and significantly helps developers follow the best practice of
submitting activity-oriented commits with acceptable interaction
effort and time cost in real collaborative software development.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Â©2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8562-6/21/08. . . $15.00
https://doi.org/10.1145/3468264.3468551CCS CONCEPTS
â€¢Software and its engineering â†’Software configuration man-
agement and version control systems ;Collaboration in soft-
ware development .
KEYWORDS
revision control system, code commit, changes decomposition
ACM Reference Format:
Bo Shen, Wei Zhang, Christian KÃ¤stner, Haiyan Zhao, Zhao Wei, Guangtai
Liang, and Zhi Jin. 2021. SmartCommit: A Graph-Based Interactive Assistant
for Activity-Oriented Commits. In Proceedings of the 29th ACM Joint Euro-
pean Software Engineering Conference and Symposium on the Foundations
of Software Engineering (ESEC/FSE â€™21), August 23â€“28, 2021, Athens, Greece.
ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3468264.3468551
1 INTRODUCTION
In collaborative software development, software artifacts are usu-
ally under continuous evolution. Developers modify software arti-
facts for various development tasks/activities, such as implementing
new features, fixing bugs or vulnerabilities, and refactoring. To effi-
ciently manage the life-cycle of software artifacts, the version control
system (VCS) like Git is employed to track the change history of
software artifacts as a sequence of commits : each commit consists
of a set of differences ( diffs) representing the changes of source
code since the last version, as well as a textual description ( commit
message ) summarizing the content and intent of these code changes.
Consequently, commits act as the basic unit to organize changes on
software artifacts, upon which many other VCS functions are built.
It is considered to be a best practice to submit code changes as a
sequence of cohesive commits, each of which records the work re-
sult of a specific development activity [4,28]; such kind of commits
is also called atomic ,single-activity oractivity-oriented commits.
When following this practice, a clear change history of software
artifacts can be maintained, which benefits various activities related
to software development [ 22]. For an individual developer, activity-
oriented commits make it easier to revert a buggy commit or reuseESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Bo Shen, Wei Zhang, Christian KÃ¤stner, Haiyan Zhao, Zhao Wei, Guangtai Liang, and Zhi Jin
specific changes. For a team of developers, activity-oriented com-
mits make it easier for a developer to understand and review code
changes made by other developers [ 1,3,28]. For a researcher in
the field of software development, activity-oriented commits bring
less noise when carrying out studies that depend on historical data
(e.g. mining software repositories) [ 8,12]. Because of these benefits,
developers are encouraged to follow this best practice in many open-
source communities (e.g. Git official1and Angular2) and companies
(e.g. Google3), through explicit regulations and guidelines.
However, rather than following this best practice, developers
often submit a set of loosely-related changes serving for differ-
ent development activities as a composite commit [8], due to the
tedious manual work and lack of effective tool support to decom-
pose such a tangled changeset . In daily development, developers
are often observed to perform several independent activities si-
multaneously [ 14], such as refactoring the code structure while
working on a new feature ( floss refactoring [20,21]) or fixing a bug
along the way while optimizing a function, leading to a tangled
changeset in the workspace. Prior empirical studies repeatedly and
consistently confirmed that composite commits are common in soft-
ware projects, both for open-source and industrial ones. Herzig and
Zeller [ 8] found that composite commits occur in up to 15% of all
bug-fix commits in 5 open-source projects. Tao and Kim [ 28] stud-
ied 453 code changes from 4 open-source projects and concluded
that on average 17% and up to 29% of all commits are composite and
address two or more issues. Barnett et al. [ 1] found that changesets
can be decomposed in over 40% of code reviews at Microsoft. In
researches on defect prediction and localization, Nguyen et al. [ 23]
reported that 11% to 39% of bug-fix commits include other changes.
Worse still, the chances of depending on developers to eliminate
composite commits are slim, because of unawareness or tedious
manual effort [ 22]. On one hand, some developers simply do not
know the best practice. On another hand, although some VCSs (like
Git interactive staging4) or tools (like GitKraken andFork) do pro-
vide functions to decompose changes in a developerâ€™s workspace,
these functions totally depend on manual operations.
Researchers have proposed various approaches to address the
problem of composite commits by decomposing them with algo-
rithms, typically based on heuristic rules [ 8,34], program slicing
techniques [ 22], code dependency [ 1,32] or pattern matching [ 4].
But there are still two weaknesses in these approaches. First, most
of these approaches identify and decompose composite commits
temporarily at the code review stage, where composite commits
have been recorded in the version history or shared with collabora-
tors. We argue that it is more meaningful to prevent the occurrence
of composite commits, by proactively decomposing the correspond-
ing tangled changeset before the submission, as also suggested in
several works [ 12,13,26]. Second, these approaches often gener-
ate too fine-grained decomposition results [ 22], which can hardly
be used as activity-oriented commits. The cause is that these ap-
proaches usually rely on a limited set of information retrieved from
source code; many valuable relations between diff hunks are out of
consideration, leading to the result that two diff hunks that should
1https://git-scm.com/docs/gitworkflows#_separate_changes
2https://github.com/angular/angular/blob/master/CONTRIBUTING.md
3https://google.github.io/eng-practices/
4https://git-scm.com/book/en/v2/Git-Tools-Interactive-Stagingbe submitted together are separated. We argue that a promising
approach should identify and utilize a diverse set of information,
even including knowledge from developers.
For the purpose of reminding, leading, and assisting developers
to follow the best practice of activity-oriented commits, in this work
we propose an interactive approach, named SmartCommit , which
leverages both the efficiency of the algorithm and the knowledge of
the developer. In particular, this approach has two features. First, it
assumes that it is very difficult to design a fully automated algorithm
that can decompose tangled changesets accurately and without de-
velopersâ€™ intervention, since what constitutes an activity-oriented
commit is closely related to a projectâ€™s characteristics and a devel-
operâ€™s subjective criteria; for this reason, it employs an intuitive
GUI-based interaction mechanism for a developer to participate in
the decomposing process efficiently. Second, it adopts an extensible
graph representation, named Diff Hunk Graph , to capture compre-
hensive semantic and heuristic relations between changes, and
transforms the problem of changeset decomposition into a graph
partition problem correspondingly.
We evaluated SmartCommit with regard to effectiveness and
scalability under industrial as well as open-source settings. On one
hand, we deployed SmartCommit in an international IT company
and recruited 83 engineers to use it for 9 months. On the other
hand, we generated 3,000 synthetic tangled changesets from 10
popular open-source projects (with different scales and from dif-
ferent domains), and compared the decomposition suggested by
SmartCommit with the original commits (i.e. the ground truth ). The
industrial field study shows that SmartCommit could help develop-
ers submit activity-oriented commits with acceptable manual effort
(3.41 operations on average). The open-source experiment shows
that SmartCommit achieves a median accuracy of 71.00â€“83.50%,
with stable performance under different input sizes (less than 5
seconds in 90% cases).
Overall, our work makes the following contributions:
â€¢An extensible graph representation to capture 4 categories
of relations between code changes, including the Hard Links ,
Soft Links ,Refactoring Links andCosmetic Links .
â€¢A graph-partitioning-based algorithm to decompose tangled
changesets, which outperforms the state-of-the-art approach
in terms of accuracy and interpretability.
â€¢An interaction mechanism between the decomposing algo-
rithm and the developer, which leverages developersâ€™ knowl-
edge through two kinds of simple adjustment operation.
â€¢A well-engineered open-source tool for SmartCommit , which
stands the test of a 9-month practical use as well as an ex-
tensive evaluation on 10 diverse open-source projects.
2 MOTIVATING EXAMPLE AND
EXPLORATORY STUDY
In Figure 1, we show a real composite commit from jruby project.5In
this commit, two Java source files were changed with 71 diff regions,
but the diff content and the commit message both indicate that this
commit contains code changes for multiple activities, including
refactoring, fixing two issues, and cleaning up some dead code.
Although this commit comes with a clear bullet-list description
5https://github.com/jruby/jruby/commit/f79d6cSmartCommit: A Graph-Based Interactive Assistant for Activity-Oriented Commits ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
(whereas many composite commits do not [ 8]), it is still difficult to
review, integrate, or reuse, since changes corresponding to different
activities are mixing up and intersecting with each other.
To better understand the state-of-the-practice about composite
commits, we conducted semi-structured interviews with 6 software
practitioners for their viewpoints about composite commits. They
were recruited through our professional network: four (P1â€“P4) are
industrial software engineers, two are open-source contributors
(P5 and P6), and all of them have more than 2-year experience
of Java programming. After showing them the above motivating
example, we asked each participant to find 3 composite commits
from the historical commits or pull requests in their own projects,
so as to ground the later discussion. Inspired by contextual inquiry
techniques [9], we discussed with participants about the composite
commits they have submitted recently to collect insights about
the cause and effect of composite commits. Each interview was
conducted with an observation phase (we observed how each partic-
ipant decomposed composite commits with Git interactive staging)
and a discussion phase (we asked them 5 questions about the cause
and effect of composite commits as well as the expected assistance).
Details about questions, process and quoted user responses are
available in our supplementary data repository [2].
We categorized the collected insights into 4 topics:
(1)Benefits : All participants agreed that the best practice of
activity-oriented commits would generally be beneficial for
development, maintenance, and collaboration among devel-
opers, e.g., making it easier to describe, understand, revert,
and integrate code changes. For example, one developer (P3)
mentioned that "When using git-bisect to locate bugs, it will
be good if the buggy commit is small to safely revert."
(2)Causes : By recalling the submission process of historical com-
posite commits, participants pointed out three major causes
of composite commits: interleaved development tasks, the
time stress, and the absence of regulations/guidelines/tool
support in practice, e.g., "Our team have regulations about
code style but nothing about commit style." (P2)
(3)Clues : When manually decomposing changesets, participants
tended to find clues like code structure and dependency,
change similarity, and refactoring. Other clues included sys-
tematic edits, change couplings, and frameworks. For ex-
ample, one developer (P6) told us his experience: "To fix a
buggy condition in if/for/while, I am used to also check other
similar ones."
(4)Expectations : When asked to imagine an automatic tool for
changeset decomposition, they all thought it is difficult and
also unsafe to fully automate this process. But they did expect
such a tool to save their effort in reviewing and organizing
changes with an intuitive GUI, and if it would not change
their code, some inaccuracy would be find "A few errors are
tolerable as long as I can correct them quickly." (P5)
The Benefits andCauses insights confirmed the findings in the
previous works, and the Clues insights motivated us to design an
approach to decomposing changesets by simulating the process
of manual decomposition. The Expectations from developers moti-
vated us to make it interactive and co-work with the developer to
improve its feasibility in practice.
Project: jrubyCommit Id: f79d6c3087b93b08f47a122aa42e72d7ddf87a3dCommit Message:Fixes plus partial refactor of SelectExecutor.* Eliminate fdsarray, since we already have an object and fields.First step to reducing allocation.* Attach list of fdsto key to allow both read and write to reg.* Update (rather than replace) key ops with additional operations.* Use SelectorPoolto acquire/release selectors.* Misccleanup of dead code.Fixes #2102Fixes #2106ChangedFiles: core/src/main/java/org/jruby/ir/Compiler.javacore/src/main/java/org/jruby/util/io/SelectExecutor.java...-IRubyObjectselectEnd(ThreadContextcontext) {-int i;+IRubyObjectselectEnd(ThreadContextcontext) throws IOException{+fdTerm(readKeyList);+fdTerm(writeKeyList);+fdTerm(errorKeyList);...-for (i= 0; i< 2; ++i) {-fdTerm(fds[i]);+// clear cancelled keys (with selectNow) and return to pool+for (Selector selector : selectors.values()) {+try {+selector.selectNow();+} finally {+context.runtime.getSelectorPool().put(selector);+}...-private static void fdSet(List[] fds, int offset, ChannelFDfd){-if (fds[offset] == null) fds[offset] = new ArrayList(1);-fds[offset].add(fd);-}...-IRubyObjectread, write, except;-List<SelectionKey>[] fds= new List[6];+final IRubyObjectread, write, except;+List<SelectionKey> readKeyList;+List<SelectionKey> writeKeyList;+List<SelectionKey> errorKeyList;+List<ChannelFD> unselectableReadFDs;+List<ChannelFD> unselectableWriteFDs;+List<ChannelFD> pendingReadFDs;...Figure 1: An example composite commit from the jruby
project, in which multiple activities were done and two is-
sues were addressed in single commit.
AllchangesInonegroupOnechangeIneachgroupInitialStateExtremeStateAcceptedDecompositionInitialSuggestionCoarseControlFineTuning
Figure 2: Getting close to the accepted decomposition
through coarse and fine interactions.
3 APPROACH
In this section, we first describe the target problem as well as the
major challenge. After that, we present an approach named Smart-
Commit , to address the problem and challenge.
3.1 Problem Statement
The target problem is to decompose a tangled changeset into a
sequence of activity-oriented subsets, each of which corresponds
to the work result of a specific development activity. The major
challenge of this problem is how to group low-level operational code
changes according to implicitly-specified high-level development
activities, which can hardly be fully automated for two reasons.
First, what constitutes an activity-oriented commit is often specific
to project and subjective to developer. Existing approaches try
to decompose changesets typically based on predefined heuristics
about source code and code changes, and have been proved to be too
rigid to meet the developerâ€™s expectation [ 22]. Second, it is difficult
to encode information beyond source code (e.g. project/change-
specific knowledge, or developer-specific criteria) into an algorithm
to improve the decomposition process.
To cope with the above challenge, we argue that a promising
approach should be a human-in-the-loop solution, which integrates
the developer knowledge with a semi-automatic algorithm in the
decomposition process. As shown in Figure 2, we consider the
target problem in general as finding an accepted decomposition
between the initial state (where all changes are submitted as a single
commit) and the extreme state (where each change is submitted
as a separate commit). In this way, the decomposition is a process
where an algorithm co-works with the author of code changes to
find an activity-oriented decomposition.ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Bo Shen, Wei Zhang, Christian KÃ¤stner, Haiyan Zhao, Zhao Wei, Guangtai Liang, and Zhi Jin
CommitsSubmissionInteractiveDecompositionGraphConstructionPreprocessingRepository
Figure1.Overview
HEADversion1version2version3DiffHunkGraph
Accepted GroupsGeneratedGroupsCommits
Changesetbasecurrentâ‘ â‘¡â‘¢â‘£Start
EndDiff-Hunk 1Diff-Hunk 2Diff-Hunk nCoarseControlFineTuning
Figure 3: An overview of the proposed approach.
3.2 Approach Overview
Based on the collected insights in the exploratory study (Section 2),
we propose an interactive approach named SmartCommit to ad-
dressing the target problem. Initially, without the developerâ€™s in-
volvement, SmartCommit generates a decomposition as the initial
suggestion , which will be presented to the developer for review. The
developer then can perform coarse control andfine tuning (see Fig-
ure 2) to quickly adjust it towards the accepted decomposition . As a
result, the decomposition generated by the algorithm offers a good
start to save manual effort, whereas adjustment operations (i.e.,
coarse control and fine tuning) improves flexibility of our approach
as well as trustworthiness of the final result.
Specifically, SmartCommit takes the changed files in a devel-
operâ€™s workspace as input, and forms the accepted decomposi-
tion through 4 consecutive stages, as shown in Figure 3. In a pre-
processing stage, changes contained in the changed files are re-
trieved and structured as a set of diff hunks . In the subsequent
graph-construction stage, a diff hunk graph (cf. Definition 3.1) is
constructed, which models a series of explicit and implicit links
between diff hunks. In the next interactive-decomposition stage,
first, an edge-shrinking algorithm is used to partition the diff hunk
graph into a set of sub-graphs, each of which represents a group
of closely-related diff hunks, as the initial decomposition. The de-
veloper can review the decomposition to determine whether to
adjust it or not. In particular, via coarse control , the developer can
adjust the parameter of the partition algorithm, which will lead to
an updated decomposition at a different granularity, until it is close
enough to the expectation; and via fine tuning , the developer can
directly move diff hunks between change groups to further refine
it accurately. In the final commit-submission stage, the developer
selects all or a sub-set of change groups, writes commit messages,
and submits them as a sequence of separate commits. Next, we will
explain each of these stages in detail.
3.3 Preprocessing
The preprocessing stage targets at collecting the internal and con-
text information for code changes, and representing them in the
form of diff hunks . In our approach, we treat diff hunk as the basic
unit to organize code changes.
Intuitively, a diff hunk is a combination of the textual diff with
involved syntactic code elements (abstract syntax subtree(s)). A diffhunk is represented as a 5-tuple â„(file_index, index, change_type,
base_hunk, current_hunk ), a pair of hunks (namely base_hunk and
current_hunk ) corresponds to the version before and after the
change respectively. The combination of file_index andindex in-
dicates its location in the changeset and also serves as an unique
identifier of a diff hunk .
3.4 Graph Construction
We design a graph representation named Diff Hunk Graph for later
decomposition, which is defined as follows:
Definition 3.1 (Diff Hunk Graph). A diff hunk graph is a labeled ,
weighted , and directed graphğº(ğ‘‰,ğ¸,ğ‘¤,ğ‘‡), where:
â€¢ğ‘‰is the vertex set, each element of which represents a diff
hunk in the changeset, with a unique id <file_index:index>.
â€¢ğ¸âŠ†{( source,target,type)|(source,target)âˆˆğ‘‰Ã—ğ‘‰,source â‰ 
target,typeâˆˆğ‘‡}is the edge set. Each element in ğ¸stands
for a specific link between two diff hunks.
â€¢ğ‘¤:ğ¸â†’( 0,1]is the function that maps each element in ğ¸
to a weight value, which denotes the strength of the link.
â€¢ğ‘‡{depend, refactor, similar, proximate, reformat, cleanup,
moving, non-code } is the set of link types currently supported,
which is amenable to be extended.
Edges in this graph represent relational links between diff hunks
identified from code changes that suggest two changes may re-
sult from the same development activity. Currently, we consider 4
categories of link:
(1)Hard Links represent syntactic and semantic constraints be-
tween AST nodes covered by diff hunks, where code in a
diff hunk explicitly or implicitly depends on code in others.
To detect such links, we first build a graph that combines
the AST, data dependency, and call graph from the base and
current versions of all changed files respectively, then locate
all nodes covered by diff hunks. If two diff hunks contain
nodes with direct hierarchical relation or dependency, then
adirect dependency link will be added; if they contain nodes
with multi-hop dependency, then an indirect dependency link
will be added.
(2)Soft Links represent heuristic factors like similarity and prox-
imity of diff hunks, to associate repetitive change patterns
and spatially related changes. Our approach compares eachSmartCommit: A Graph-Based Interactive Assistant for Activity-Oriented Commits ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
pair of diff hunks to measure the similarity textually and
syntactically, and the proximity according to the syntactic
hierarchy of their covered nodes.
(3)Refactoring Links represent multiple edits in different loca-
tions that likely originate from the same refactoring, e.g.,
renaming a method and all corresponding calls to it. We
first detect all refactored nodes in the whole changeset, then
connect the involved diff hunks.
(4)Cosmetic Links relate diff hunks that are cosmetic changes in
nature (i.e. they do not affect the program semantics), such
as reformatting, fixing typos in comments, or cleaning up
comments. We detect such links by comparing the snippet
and covered_nodes of the base_hunk and current_hunk.
Each link has a weight to indicate the relative confidence that
two linked diff hunks should be committed together. For the direct
dependency in Hard Links , the weight is assigned a maximum value
of 1.0 to indicate that if such links exist, the source and target vertex
should almost certainly be committed together (but the developer
can still override the decision with adjustments). For other links
(indirect dependency, similarity, proximity, etc.), we assign lower
weights based on a measure that is specific to the kind of link. For
example, the weight of indirect dependency is the reciprocal of the
hop number of the shortest path between all nodes covered by two
diff hunks, the similarity is with the average of textual similarity of
code snippets and tree similarity of covered syntax tree nodes, and
the proximity is the reciprocal of the maximal hop number from the
covered nodes to their common ancestor node (see supplementary
data repository [2] for detailed calculation rules).
Different from previous works, our approach does not depend
on particular heuristic rules or features, although it does cover com-
mon heuristics in previous works. There are often multiple links of
different types between two diff hunks, and we combine the infor-
mation carried by different links in a flexible and extensible way
via an extensible graph representation. It is easy to add new kinds
of links through extra analyses, e.g., the evolutionary coupling [ 31]
and the timing information of recorded edits [14].
3.5 Interactive Decomposition
3.5.1 Generating the Initial Suggestion. Based on the concept of
diff hunk graph, we transform the problem of tangled-changeset
decomposition into a graph partitioning problem. Inspired by the
multilevel graph partitioning [ 11] and Kruskalâ€™s algorithm [ 16],
we design an edge-shrinking algorithm (see Algorithm 1) to parti-
tion the diff hunk graph based on edges, which encode relations for
decomposition. The main steps of this algorithm are described as fol-
lows. Initially, the algorithm creates an empty priority queue ğ‘„and
a map representing a disjoint-set ğ‘†, which initializes single-vertex
partition (i.e. each element in ğ‘†is a group consisting of exactly one
vertex connected with itself). Then, each edge ( ğ‘¢,ğ‘£,ğ‘¡ğ‘¦ğ‘ğ‘’ ) in the
graph is added into the priority queue as a triple ( ğ‘¤ğ‘¡,ğ‘¢,ğ‘£ ), where
the priority of an edge is determined by the weight of the edge
ğ‘¤ğ‘¡=ğ‘¤(ğ‘¢,ğ‘£,ğ‘¡ğ‘¦ğ‘ğ‘’)first (descending), the source vertex id ğ‘¢next
(ascending), and the target vertex id ğ‘£last (ascending). After that,
the algorithm enters a loop where the edge with the highest priority
inğ‘„is popped out in each iteration. If the edgeâ€™s two endpoints
are already in the same group, the loop will continue to the nextiteration. Otherwise, if the edgeâ€™s weight is above a threshold (0.6
by default, tuned through experiments on real composite commits
in the exploratory study), the two groups that respectively contains
the edgeâ€™s two endpoints will be merged via the union-find algo-
rithm. If the edgeâ€™s weight is under the threshold or there are no
edges left in ğ‘„, the loop will break, then we traverse ğ‘†to generate
groups from connected subsets. In the last, if there exist groups still
with only one original vertex, these groups will be merged into one,
gathering the isolated vertices that stand for trivial changes. A set
of groups will be generated from the connected subsets of ğ‘†, as the
initial suggested decomposition for the tangled changeset.
Algorithm 1: Edge-shrinking Graph Partitioning
Input :ğº(ğ‘‰,ğ¸,ğ‘¤,ğ‘‡), the diff hunk graph of a changeset;
W, the edge filtering threshold
Output: A suggested decomposition ğ·
1Function partition(G, W)
2ğ‘„â†PriorityQueue(),ğ‘†â†{ğ‘¢:(ğ‘¢,1)|ğ‘¢âˆˆğ‘‰}
3 foreachğ‘’=(ğ‘¢,ğ‘£,ğ‘¡ğ‘¦ğ‘ğ‘’)âˆˆğ¸do
4ğ‘„.ğ‘ğ‘‘ğ‘‘((ğ‘¤(ğ‘’),ğ‘¢,ğ‘£))
5 end
6 whileğ‘„not empty do
7ğ‘¤ğ‘¡,ğ‘¢,ğ‘£â†ğ‘„.ğ‘ğ‘œğ‘()// the edge with the highest priority
8 ifğ‘¤ğ‘¡â‰¤Wthen break
9 // already in the same group then skip
10 ifğ‘“ğ‘–ğ‘›ğ‘‘(ğ‘¢)==ğ‘“ğ‘–ğ‘›ğ‘‘(ğ‘£)then continue
11 ifğ‘“ğ‘–ğ‘›ğ‘‘(ğ‘¢)==ğ‘¢&&ğ‘“ğ‘–ğ‘›ğ‘‘(ğ‘£)==ğ‘£then
12 // bothğ‘¢andğ‘£are in single-vertex groups
13 ğ‘†[ğ‘¢]â†(ğ‘£,ğ‘¤ğ‘¡)// group them with confidence ğ‘¤ğ‘¡
14 else
15 ğ‘¢ğ‘›ğ‘–ğ‘œğ‘›(ğ‘¢,ğ‘£,ğ‘†)// union the groups that contains ğ‘¢andğ‘£
16 end
17 end
18ğ·â†ğ‘”ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘’ğºğ‘Ÿğ‘œğ‘¢ğ‘ğ‘ (ğ‘†)// get connected subsets as groups
19 returnğ·
20end
21Function generateGroups(S)
22ğ·â†ğ‘†ğ‘’ğ‘¡(),trivialâ†âˆ…
23 foreachğ‘¢,(ğ‘£,ğ‘¤ğ‘¡)âˆˆğ‘†do
24 ifğ‘¢==ğ‘£then
25 trivial .add(ğ‘¢)// collect still isolated vertices
26 else
27 // merge the groups that contains ğ‘¢andğ‘£
28 merge (getGroup (D,ğ‘¢),getGroup (D,ğ‘£))
29 end
30 end
31 D.add(trivial) // append the group consisting of all trivial changes
32 return D
33end
Figure 4 shows an example of diff hunk graph to illustrate how
the algorithm works. Each vertex in the graph represents a diff
hunk, with its idas the label. Each edge represents the link with the
maximum weight value between a pair of diff hunks (other links
are hidden for simplification). At the beginning of the algorithm,
all edges are added into a priority queue in the form of ( weight,
source_index, target_index ). In each iteration of the loop, the edge
with the largest weight value and the smallest id is popped out from
the queue, and the source and target vertices will be put into one
group, if the weight is above the threshold and the two vertices
do not belong to the same group yet. The algorithm terminates
when there are no unvisited edges with a weight value above the
threshold. Finally, it partitions the 14 vertices into 4 groups, each of
which is expected to correspond to an activity (e.g. feature addition,
refactoring, adding test, and reformatting).ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Bo Shen, Wei Zhang, Christian KÃ¤stner, Haiyan Zhao, Zhao Wei, Guangtai Liang, and Zhi Jin
hardlinkscosmetic linkssoftlinksrefactoring linkssimilar-0.7reformat-0.4thresholddepend-1.0similar-0.35proximate-0.33similar-0.4depend-1.0depend-1.0depend-0.5depend-0.95
reformat-0.85depend-1.0similar-0.8moving-0.25proximate-0.5extract-1.0proximate-0.91:12:1
3:13:42:42:22:3
3:21:22:63:3
1:31:42:512
345967
8101:12:31.02:13:31.03:13:41.03:23:11.01:12:10.82:52:40.951:31:40.851.32.60.712345678910OrderofEdgesAreVisited3:41:21.02:42:20.9â€¦
Figure 4: A simplified example of Diff Hunk Graph . The
14 vertices are decomposed into 4 groups. Numbers on ver-
tices denote the file_index:diff_hunk_index , while numbers
besides edges indicate the order they are visited.
3.5.2 Interacting with the Developer. The initial suggestion will be
presented through a graphical user interface, with which the de-
veloper can review and adjust the suggested decomposition. Corre-
sponding to Figure 2, we design two kinds of adjustment operation:
coarse control andfine tuning :
â€¢Coarse control is an operation that regenerates a suggested
decomposition at different granularity by assigning a new
value to the threshold Wthat controls the shrinking criteria
of edges and the stop criteria of the decomposition algorithm.
â€¢Fine tuning is an operation through which the developer can
manually move diff hunks across groups or move a group to
change its order.
We consider the above interacting mechanism as important
as the decomposition algorithm for two reasons. First, the algo-
rithm makes use of the feedback from the developer to quickly
reach a better state that requires no or minimal extra manual ef-
fort, and can greatly save manual effort to follow the best practice
of activity-oriented commits. Second, considering that the code
submission is essentially a human-computer interaction process
(choosing changes to stage and writing descriptions), the interac-
tion can be seamlessly embedded in developersâ€™ normal workflow,
with the additional benefits of greatly improving the credibility and
reliability of our approach.
3.6 Commits Submission
The last stage is to submit the groups as a list of consecutive commits
appended in the version history. When the developer is ready to
commit, they should select part or all of the generated groups,
complete the corresponding messages, and submit them with one
single click. In this stage, SmartCommit will perform two steps:
â€¢Correctly reorder the groups : by default, diff hunks with di-
rected dependency are kept in the same group, to avoid
commits with compilation errors. However, this property
can be broken by developers unconsciously or on purpose
(e.g. for stacked pull requests6). Therefore, before submission
the selected groups are reordered by the topological order
of their vertices in the diff hunk graph, to make sure the diff
6https://unhashable.com/stacked-pull-requests-keeping-github-diffs-small/hunk that is depended on by others is committed before or
with its dependents. If this criterion cannot be satisfied, an
error will be reported for further fine-tuning.
â€¢Incrementally apply the changes : since all diff hunks are com-
puted upon the original HEAD commit (the last commit
before all submission), but it moves forward as groups are
committed, so the changes cannot be applied directly. We
solve this problem with incremental patch , which includes
changes in the to-be-submitted group and all changes in the
previously-submitted groups, so as to be applied on the origi-
nalHEAD version to get a correct workspace for submission.
4 EVALUATION
We implement SmartCommit as an open-source tool (see Figure 5),
which works either as a standalone software, a plugin in IntelliJ
IDEA , or as a customized Git sub-command git sc . The source code
(with about 13,000 lines of Java code) is available on GitHub.7In
the implementation, we extract the hierarchical and dependency
relations with Eclipse JDTParser8and symbol resolver, and detect
refactoring with the state-of-the-art tool RefactoringMiner [29].
We adopt parallelization and cache diff hunk graph in memory to
quickly respond to coarse control. SmartCommit takes the working
directory of a Git repository as input, and presents the suggested
decomposition as a list of groups, which can be adjusted in two
ways: (1) change the threshold with the sliding bar on the left side
to coarsely change the granularity, and (2) drag&drop specific diff
hunks for fine-tuning. When ready to commit, the user can select
one or several groups (with the check marks in green background),
complete the commit message, and then click the Commit button
at the top right corner to trigger the submission.
4.1 Research Questions
The goal of our approach is to quickly reach a good initial decom-
position which the developer then can refine without too much
effort. Hence, we evaluate accuracy of the initial decomposition,
interactivity, performance and usefulness with 4 research questions:
(1)RQ1 (Accuracy) : What is the accuracy of initial decompo-
sition suggested by SmartCommit ?
(2)RQ2 (Interactivity) : Are the manual effort to adjust the
suggested decomposition acceptable for developers?
(3)RQ3 (Performance) : What about the performance and how
does it change with different input sizes?
(4)RQ4 (Usefulness) : IsSmartCommit useful for developers
to follow the best practice?
4.2 Research Design
We conducted the evaluation with mixed methods research [ 5,30],
andtriangulate results from two complementary studies conducted
in parallel: (1) a field study in which we observed 83 software en-
gineers in an international IT company use SmartCommit for 9
months and interviewed a subset of them, and (2) an experiment
(without human subjects) in a controlled setting of 3,000 synthetic
composite commits from 10 well-known open-source projects from
7https://github.com/Symbolk/SmartCommitCore
8https://www.eclipse.org/jdt/SmartCommit: A Graph-Based Interactive Assistant for Activity-Oriented Commits ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Figure 5: A screenshot of the GUI of SmartCommit .
various domains. By mixing both qualitative and quantitative evalu-
ations in the field and in controlled settings, we triangulate between
evaluations in different settings and environments to gain more
confidence in the conclusion [30].
In particular, the two studies exhibit the traditional tradeoff be-
tween internal and external validity [ 25]. The field study was per-
formed within the realism of an industrial setting when developers
perform their daily tasks â€“ but this realism (supporting external
validity) comes at the cost of limited control (threatening inter-
nal validity). In contrast, the open-source experiment was highly
controlled and allows us to evaluate the approach under various
experimental conditions on an extensive dataset (supporting inter-
nal validity) â€“ but these tangled changesets were generated syn-
thetically to provide a reliable ground truth (threatening external
validity). Taken together, triangulating results from the two studies
increases confidence that our conclusions are not simply accidental
due to a weakness in one specific study design.
4.2.1 Industrial Field Study. We conducted our field study in a
large international IT company from 2020-05-18 to 2021-01-23. A
total of 83 experienced software engineers from two product teams
were involved: the first team included 32 developers working on
a music application for Android ( Project a ), and the second team
comprised 51 developers working on a general cloud computing
platform ( Project b ). All participants have more than 2 years of
programming experience with Java, and write code in IntelliJ IDEA .
Correspondingly, we deployed SmartCommit as a plugin. We con-
ducted a quick-start training course through an online conference
about the best practice of activity-oriented commits and the usage
instructions of SmartCommit .
Although we initially recommended these engineers to use Smart-
Commit for every commit, we did not intervene in their daily work;
they were free to choose any other existing tools to submit commits
(like Git commands or the built-in Git support in IDEA ). If they
chose to use SmartCommit , this tool would analyze changes in the
local workspace, and open a web-based GUI (similar to Figure 5)
when the analysis was done. From startup to exit, SmartCommitcollected the following telemetry data for further analysis: (1) the
meta information, e.g. timestamp, user id, repository name; (2) the
change information, e.g. number of changed files and lines of code;
(3) the decomposition information, i.e. the initial suggestion and
the final commits; and (4) interactive operations.
After the end of the field study, we conducted a focus group
session [ 17] to collect comments and feedback from users. Specifi-
cally, we recruited the top 5 active users by usage frequency from
each team (active users), and 5 users who just tried a few (less
than 5) times (inactive users, 3 from Project a and 2 from Project
b). The online meeting with all 15 participants was started by one
of the researchers with warm-up questions about the pros and
cons of SmartCommit , which laid the foundation for further discus-
sions. During the discussion, another researcher was responsible
for recording the responses and discussions. After the meeting,
researchers worked together to analyze the collected information
using inductive thematic analysis [6].
4.2.2 Controlled Open-Source Experiment. The main challenge of
a controlled study that evaluates the accuracy of SmartCommit is to
establish the ground truth decomposition for a large set of diverse
composite commits. Unfortunately, we are not aware of any existing
validated dataset, and it will also open doors for many forms of
bias if asking experienced developers to decompose commits or
contacting commit authors for the ground truth.9Therefore, we
adopted an approach that synthesizes composite commits from
existing individual commits â€” in this way these individual commits
provide the ground truth decomposition.
The key idea, inspired by past research [ 8,36], is to artificially
simulate a composite commit by merging multiple consecutive non-
composite commits of the same author from the version history.
That is, we merged code where a developer actually split work
9We did try the latter approach, but discarded it for two reasons: (1) given a commit,
determining whether it is composite is challenging, especially for project outsiders [ 8];
(2) due to the complexity of studied projects, manually decomposing suspected com-
posite commits could bias the ground truth, especially when the changeset is large. We
also built an online platform and contacted authors of suspected composite commits
to validate the decomposition, but the response rate was too low for rigorous analysis.ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Bo Shen, Wei Zhang, Christian KÃ¤stner, Haiyan Zhao, Zhao Wei, Guangtai Liang, and Zhi Jin
Table 1: Studied Projects
Project Field #Stars #Total #Atomic
rocketmq Messaging and streaming 14.1k 1,144 459
nomulus Domain name registry 1.4k 3,034 572
glide Image loading library 29k 2,383 650
antlr4 Parser generator 7.7k 5,888 1,117
storm Realtime computation 6.1k 10,287 1,444
realm-java Mobile database 10.9k 5,465 1,614
netty Web application 23.5k 9,688 2,786
cassandra Partitioned row store 6.1k 25,210 3,459
deeplearning4j Deep learning 11.8K 24,119 4,699
elasticsearch Search engine 48.7k 47,564 6,728
The last three columns represent the number of stargazers (#Stars), the number
of all commits (#Total) and atomic commits (#Atomic), collected on the master or
main branch until Feb.1, 2020.
into multiple commits to simulate a setting where they did not.
Specifically, we generated 3,000 synthetic composite commits from
10 open-source projects, by merging 2, 3, or 5 consecutive non-
composite commits. We picked these numbers to mirror the normal
size and number of activities observed in real composite commits,
and these numbers are also consistent with finally-submitted groups
in our later statistics for the field study results. Then we decom-
posed the tangled changeset in each synthetic composite commit
with SmartCommit , and compared suggested decomposition with
original commits to measure the accuracy as well as the distance
in terms of the minimal number of fine-grained operations to get
from the suggested decomposition to the ground truth.
Select studied projects. To select representative and diverse sam-
ple projects, we first searched for projects with Java as the main
language on GitHub, and ranked them by the number of stargaz-
ers. Then we chose projects that are popular (with at least 1,000
stargazers), mature (with at least 1,000 commits) and well-known
in their domains. The selected projects are listed in Table 1.
Collect atomic commits. To generate synthetic composite com-
mits, we first needed to identify atomic/non-composite commits as
inputs. According to common characteristics of composite commits
from previous works [ 8,23,28] and our manual validation on 100
sample commits from studied projects, we considered a commit
as non-composite if its commit message did not satisfy any of the
following criteria:
â€¢references multiple issue ids (e.g. Fix #X and #Y... ),
â€¢contains a bullet list of performed actions (e.g. - Fixed ... -
Changed ... ),
â€¢contains multiple phrases/sentences with verbs (e.g. Rename
... Removed ... ), or
â€¢contains parallel sentences starting with conjunction key-
words like and, also, plus (e.g. Refactor ... Also ... And ... ).
Synthesize composite commits. For each project, we randomly
selected sequences of consecutive non-composite commits from the
same author. For each of the 10 projects, we selected 100 sequences
of length 2, 100 sequences of length 3, and 100 sequences of length 5,
getting a total of 3,000 sequences. For each sequence, we generated
one composite commit by merging all changes, and recorded the
original commits and their order as the ground truth. When therewere overlapping changes between merged commits, we only kept
the last change on the same lines.
4.2.3 Threats to Validity. As discussed, the field study and con-
trolled experiment have different limitations regarding internal and
external validity, but triangulation helps us to interpret findings
despite these limitations. The field study was conducted in a realis-
tic setting, but with less control and limited scope of projects and
teams. For the controlled study, threats to validity lie in the process
of simulating composite commits to establish ground truth.
Nonetheless, it is worth acknowledging that, despite best efforts
in our study design (e.g., long-period observation in the field study),
common experimental biases (like the novelty effect of new tools
and the response bias in interviews) may still affect our results
in the field study. Also in our controlled experiment, despite best
efforts of simulating realistic merged commits (e.g., mirroring real
composite commits in size and using a large dataset to reduce the
impact of random noise), the synthetic commits are only a proxy
for realistic commits. Readers should interpret results, especially
results that are not consistent across both studies, carefully in the
context of these limitations.
4.3 Evaluation Results
We summarize and triangulate results from the two studies in Ta-
ble 2. Details about the evaluation metrics, process and results for
each research question are presented as follows. More detailed
quantitative data and qualitative results are publicly available in
oursupplementary data repository [2].
4.3.1 Evaluation of Accuracy (RQ1) .We evaluate the accuracy
of the initial suggested decomposition of SmartCommit , by compar-
ing it with the ground truth, as well as three baselines.
Metric. In both studies, we adopted Rand Index [15], a commonly-
used measure of the similarity between two data clusterings, to
measure the accuracy of the suggested decomposition.
Definition 4.1 (Accuracy). Given a set of ğ‘›diff hunksğ», the ground
truth decomposition ğ·ğ‘”(apartition toğ»), and an decomposition
suggested by an approach ğ·ğ‘ (also a partition toğ»), the accuracy
ofğ·ğ‘ relative toğ·ğ‘”is defined as follows:
ğ‘ğ‘ğ‘(ğ·ğ‘ |ğ·ğ‘”)|ğ‘ƒğ‘ğ‘–ğ‘Ÿ(ğ·ğ‘ )âˆ©ğ‘ƒğ‘ğ‘–ğ‘Ÿ(ğ·ğ‘”)|
|ğ‘ƒğ‘ğ‘–ğ‘Ÿ(ğ·ğ‘”)|=|ğ‘ƒğ‘ğ‘–ğ‘Ÿ(ğ·ğ‘ )âˆ©ğ‘ƒğ‘ğ‘–ğ‘Ÿ(ğ·ğ‘”)|
ğ‘›(ğ‘›âˆ’1)/2
where,ğ‘ƒğ‘ğ‘–ğ‘Ÿ(ğ·)is the set of element pairs in partition ğ·, which
is defined as {(â„ğ‘–,â„ğ‘—,1)|â„ğ‘–,â„ğ‘—âˆˆğ»,ğ‘–<ğ‘—,âˆƒğ‘†âˆˆğ·Â·{â„ğ‘–,â„ğ‘—}âŠ†
ğ‘†}âˆª{(â„ğ‘–,â„ğ‘—,0)|â„ğ‘–,â„ğ‘—âˆˆğ»,ğ‘–<ğ‘—,âˆ„ğ‘†âˆˆğ·Â·{â„ğ‘–,â„ğ‘—}âŠ†ğ‘†}.
In the field study, we regard the decomposition submitted by
developers as the ground truth. In the controlled experiment, we
derived the ground truth from the original commits. Furthermore,
in the controlled experiment, we also compare the accuracy of our
approach with three baselines: (1) putting all changes into one
group (denoted as All); (2) putting changes in each file into one
group (denoted as File); and (3) considering only def-use ,use-use and
same-enclosing-method relations (denoted as DefUse , corresponding
to the strategy used in ClusterChanges [1]).
Results. In the field study, SmartCommit achieves the median
accuracy of 74.70% for Project a and 70.45% for Project b . In over 60%SmartCommit: A Graph-Based Interactive Assistant for Activity-Oriented Commits ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Table 2: Triangulation of 2 Studies to Answer 4 Research Questions
Research Question Results from Field Study Results from Controlled Experiment
RQ1: Accuracy SmartCommit achieves median accuracy of 74.70% and 70.45%
for 2 industrial projects, and over 60% of generate groups are
accepted without adjustment. All interviewed long-term users
agreed that it could suggest reasonable decomposition.SmartCommit achieves median accuracy between 71.00â€“83.50%
for the 3,000 synthetic composite commits from 10 projects, and
outperforms the state-of-the-art baseline.
RQ2: Interactivity Users frequently need adjustments, but usually fewer than 5.
Coarse control is important, as it greatly reduces the manual
effort for fine tuning.Without human intervention and coarse control, typically 1-15
reassigns are needed, 1-3 reorders are needed.
RQ3: Performance Most interviewees consider the performance as acceptable, and
seldom complained or abandoned SmartCommit for run time.Computation time is under 5 seconds for 90% composite commits,
and does not change drastically as input size increases.
RQ4: Usefulness Interviewees reported that SmartCommit was particularly use-
ful when they realized there were interleaved works done. All
interviewed active and long-term users agreed that it effectively
improved their commit style .(The controlled experiment can not provide direct insights to
usefulness, since it does not involve human subjects.)
(a) Accuracy with Baselines
 (b) Accuracy of SmartCommit
Figure 6: (a) Accuracy comparison of different approaches,
each bar aggregates 300 composite commits, (b) accuracy dis-
tribution of SmartCommit with the number of merged com-
mits, each bar aggregates 100 composite commits.
invocations, the initial suggested decomposition was committed
with no adjustments (see Figure 7a). In over 95% invocations, the
number of manually-committed groups is equal or less than 3, but
we find that the accuracy for changesets from 4 or more activities is
similar. Interviewees also reported that in most cases, SmartCommit
could generate decompositions close to their expectations.
In the controlled experiment, SmartCommit achieves a median
accuracy of 71.00â€“83.50% and outperforms the three baselines in
most projects, see Figure 6a for details. Note that although File
(group changes by file) achieves higher accuracy in some cases, it
generates far more groups than SmartCommit and the ground truth,
which would require more adjustment effort in practice. As shown
in Figure 6b, SmarCommit performs best for composites commits
synthesized with 2 commits, and the accuracy reduces for 3 and 5
as expected but not much (around 75%).
Answer to RQ1: While not perfect, results from both field study
and controlled experiment indicate that SmartCommit can provide
a good initial suggestion for decomposing tangled changesets.4.3.2 Evaluation of Interactivity (RQ2) .We observe and eval-
uate how many interactions are commonly needed to adjust the
suggested decomposition.
Metric. In the field study, we logged the number of coarse con-
trolandfine tuning operations performed by developers in each
submission. In the controlled experiment, since no humans were
involved, we computed the minimum number of fine tuning adjust-
ments required to change the initial suggested decomposition ğ·ğ‘ 
to the ground truth ğ·ğ‘”. To this end, we measured the edit distance
betweenğ·ğ‘ andğ·ğ‘”, by considering two kinds of edit operation:
(1)reassign to move a diff hunk to another group, and (2) reorder
to move a group to change the order. The shortest edits distance
betweenğ·ğ‘ andğ·ğ‘”is computed in two steps: (1) find a mapping
between groups in ğ·ğ‘ andğ·ğ‘”with maximum weight bipartite match-
ing, in whichğ·ğ‘ andğ·ğ‘”are treated as the two vertex-subsets of a
bipartite graph respectively, and the weight between two groups is
the number of their common elements; (2) compute the number of
wrongly-assigned diff hunks as the number of reassign operations,
and the moving distance between the two lists of groups as the
number of reorder operations.
Results. In the field study, users only needed less than 3 coarse
control operations in over 95% cases, and less than 5 fine tuning
operations in over 90% cases (see Figure 7a). We observed from the
data that in some cases with large changesets, users often tried the
coarse control several times to find the most appropriate decom-
position. In the focus group session, interviewees also agreed that
the interaction mechanism is necessary and acceptable for them,
especially the coarse control. Two interviewees used the coarse
control in a novel way: they first submitted those suggested groups
that met their expectation, and then decomposed the remaining
changeset with coarse control to get a new decomposition, upon
which they handled overwhelming changes and groups iteratively.
In the controlled experiment, without developer involvement, we
see a little larger number of reassign operations (see Figure 7b). The
reason is that the decomposition process purely based on source
code tends to generate more groups than actually desired, mirroring
findings from previous work [ 22]. However, even for changesetsESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Bo Shen, Wei Zhang, Christian KÃ¤stner, Haiyan Zhao, Zhao Wei, Guangtai Liang, and Zhi Jin
12312312340056â€¦..coarsecontrolfinetuning(b)controlledexperiment25%50%75%100%0%(a)fieldstudy010reorderreassign456-1023â€¦10-15â€¦
Figure 7: Distribution of adjustments in the field study (a)
and the controlled experiment (b) (ignoring those under 2%).
with dozens or hundreds of diff hunks, the algorithm still keeps the
number of reassign operations relatively small, and thus provides
an acceptable start for later manual adjustment. In over 95% cases,
the number of reorder adjustment is less than 3.
Answer to RQ2: Adjustments are commonly needed for activity-
oriented decomposition, but the manual effort is kept acceptable
through the interaction mechanism of SmartCommit.
4.3.3 Evaluation of Performance (RQ3) .We evaluate the run
time of SmartCommit with inputs of different sizes, since perfor-
mance matters for user acceptance and experience.
Metric. We evaluated the performance qualitatively in the field
study, and quantitatively in the controlled experiment. For the quali-
tative part, we report results from the focus group session and infor-
mal user feedback during the field study. For the quantitative part,
for the 3,000 changesets of different sizes, we recorded the elapsed
time in miliseconds from the start of SmartCommit to the output
of the suggested decomposition. We analyze the performance with
regard to two factors of the input size: the number of diff hunks
(#diff_hunks), and the number of changed lines (#changed_lines,
including both removed and added ones).
Results. In the field study and the focus group session, most
users thought that the run time is usually acceptable, only two
users complained about too long run time of SmartCommit (over
10 seconds in their cases, one with many entire-file changes, and
one with many resolved conflicts after a huge merge), which led
them to terminate it. These observations suggest that the typical
performance of SmartCommit is acceptable for daily practical use,
but could benefit from optimizations for corner cases.
In the controlled experiment, over 90% changesets can be pro-
cessed within 5 seconds, and the analysis time slightly increases
with the growth of #diff_hunks and#changed_lines (the detailed dis-
tribution is available in the supplementary data repository [2]). The
worst-cased overhead occurred with several extra-large changesets
that consist of more than 500 diff hunks and 8,000 changed lines,
where the run time exceeds 10 seconds. However, we found in the
field study that most real changesets in the workspace are much
smaller in size than these, so we view the extra-large samples as a
stress test for our implementation.
Answer to RQ3: SmartCommit shows acceptable performance
in practical use, and keeps run time stably under 5 seconds for a
wide range of input sizes in the controlled experiment.
4.3.4 Evaluation of Usefulness (RQ4) .We focus on the field
study to analyze the usefulness of SmartCommit in practice.Table 3: Usage Data Statistics (2020-05-18 - 2021-01-23)
Scope Effect
#invocations 2,632 #generated_groups 4,838
#diff_files 8,763 #committed_groups 3,552
#diff_hunks 31,086 #unchanged_groups 2,262
#diff_lines 422,128 #avg_adjustments 3.41
(a) Usage Frequency
 (b) Diff Hunk Groups
Figure 8: (a) The trend of usage, (b) the distribution of gen-
erated and manually-committed groups, both aggregated by
week. Shaded area represents the standard deviation.
Quantitative analysis. We examine the scope andeffect ofSmart-
Commit .Scope is characterized by the number of usages and the
size of processed changesets, while Effect is characterized with the
generated groups and manually-committed groups.
During the study period from 2020-05-18 to 2021-01-23 (see
Table 3), 83 developers invoked SmartCommit for 2,632 times (#in-
vocations), with more than 422K lines of changed code processed.
In total, the tool generated 4,838 (#generated_groups) groups as
the initial suggestion, and the developer submitted 3,552 commits
(#committed_groups), in which 2,262 (63.68%) (#unchanged_groups)
were exactly the same as the initial suggestion. In over 60% invo-
cations, there was no adjustments performed (see Figure 7); when
adjustments were required, the average number of adjustments is
3.41 (including both coarse control and fine tuning).
Over time, the number of users per week stabilized within range
[10, 15] after the 5th week. About a half of developers (40/83) used
SmartCommit in at least 2 weeks, and 13 of them were particularly
active and used it in at least 10 weeks. According to Figure 8a, the
overall usage frequency increased in the first 5 weeks, but dropped
between the 5th and 13th week; later on, the usage frequency of
active users increased gradually with time, suggesting that for
these users SmartCommit was considered to be useful and helpful.
As a result, the distribution shows a long-tail phenomenon: 40
users invoked it 5â€“551 times (the most active one used the tool
for 551 times in 32 weeks), but the others used it less than 5 times,
mainly because their work has less need for large-scale changes
(see qualitative analysis).
SmartCommit tended to generate more groups than the user
expectation initially (see Figure 8b), and the extra groups were
mostly small (with a few diff hunks), which were either moved to
the other groups or left uncommitted. This is reasonable, because
not all valuable links between diff hunks can be retrieved from
source code, so the automatic decomposition tends to be more fine-
grained than activities [ 22]; this also explains why the interaction
is necessary in this problem. Besides, interviewees responded thatSmartCommit: A Graph-Based Interactive Assistant for Activity-Oriented Commits ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
when the tool suggested more than 4 groups (although in less than
5% cases), coarse control is especially useful for them to rapidly
find the appropriate granularity.
Qualitative analysis. After the focus group with 10 active users
and 5 inactive users, we summarize the collected insights for future
improvements as follows:
â€¢All interviewed active users agreed that SmartCommit could
suggest reasonable decomposition, and effectively improved
their commit style by making them concentrate on and double-
check code changes before submission. For example, users
commented that "Basically the given grouping makes sense. ",
"I am getting used to checking my change size consciously
before committing."
â€¢Eight of interviewed active users reported that SmartCom-
mitwas particularly useful when they realized there were
interleaved works done. But when the change was small
and trivial (e.g. small bug fix towards an issue, or non-code
changes), especially for interviewed inactive users, develop-
ers tended to prefer plain Git commands instead of any other
clients or tools, e.g., "Comparing with Git, I did not find [it]
necessary since my project is stable and issue-driven."
â€¢Three of interviewed active users mentioned that SmartCom-
mitadditionally helped them to avoid accidentally submit-
ting unwanted or dangerous changes, such as local/personal
configurations, resources, personal and sensitive informa-
tion/data/secrets. For example, one user appreciated that
"The tool can often group my local test config in one group,
which will pollute the server config if committed."
â€¢Most interviewees (12/15) expected to use SmartCommit as
the main committing tool if it could provide a more complete
workflow by supporting other Git functions (like pushing
and creating merge request after committing). Besides, sup-
porting other languages and suggesting commit messages
were also highly wanted, e.g., "I find that it becomes easier
for me to describe my changes for more compact commits,
so will it also be easier to apply some automatic commit
message generators?"
Answer to RQ4: SmartCommit is considered and proved to be
useful in assisting developers to submit activity-oriented commits.
5 RELATED WORK
Several approaches have been proposed to address the change de-
composition problem in the literature. Herzig and Zeller [ 8] used
a heuristic-based algorithm to untangle changes, in which they
considered their relations as confidence voters . Similarly, Wang et
al. [32] adopted a heuristic method based on code dependency anal-
ysis and similar code detection to decompose composite commits
for code review. Barnett et al. [ 1] proposed CLUSTERCHANGES ,
which relies on the def-use and use-use links to cluster changes.
Guo and Song [ 7] presented CHGCUTTER , which generates re-
lated change subsets with the program dependence. Muylaert and
De Roover [ 22] used program slicing technique on program de-
pendence graphs to decompose tangled changesets. Dias et al. [ 4]
developed EpiceaUntangler to untangle changes by predicting theprobability of two changes belonging to one cluster, based on code
structure and recorded IDE events when developers write code in
SmallTalk. A few works suggest the necessity of developer involve-
ment in the decomposition process. Taeumel et al. [ 27] proposed
Thresher , an interactive tool to group changes in Squeak/Smalltalk,
based on user-implemented scripts. Recently, Yamashita et al. [ 34]
introduced ChangeBeadsThreader , an environment that untangles
changes based on four metrics and allows the user to split/merge
clusters totally by hand.
Our approach differs from these works in three aspects. (1) Target
scenario : while most previous works decompose composite commits
temporarily for code review, our approach focuses on preventing
the occurrence of composite commits before submission. Our tar-
get scenario is more challenging because the generated change
groups must align with high-level development activities. (2) Tech-
nique : comparing with previous works, we propose an extensible
graph representation that uniformly covers common heuristic links
among code changes, and design a graph-partition-based algorithm
for changeset decomposition correspondingly. (3) Interaction : com-
paring to other interactive approaches, we provide a more intuitive
and efficient interaction mechanism that greatly saves manual ef-
fort for adjustments. In this way, we integrate human knowledge
into the algorithm without bringing extra burden to developers.
Furthermore, we have conducted a much more solid evaluation of
our approach than any other previous works, and have the tool
undergone a rather long-time practical use.
6 CONCLUSION AND FUTURE WORK
In this paper, we present SmartCommit , an interactive approach
to help developers follow the best practice of activity-oriented
commits. Given a changeset as input, SmartCommit generates sug-
gested decomposition and co-work with the developer to refine it
through interactions. We evaluate the effectiveness and scalability
ofSmartCommit under both industrial and open-source settings.
The results show that: (1) when decomposing synthetic compos-
ite commits from open-source projects, SmartCommit achieves a
median accuracy of 71.00â€“83.50% with run time mostly under 5
seconds; (2) when used in real industrial developments, SmartCom-
mitmanifested its capability to facilitate the adoption of the best
practice of activity-oriented commits. Following the current work,
we plan to extend more types of links for the diff hunk graph to
further improve the accuracy, and extend SmartCommit by inte-
grating state-of-the-art commit message generation and suggestion
works [10, 18, 19, 33].
In the long term, we aim to construct an artificial collective
intelligence (ACI) system [ 35] for collaborative software develop-
ment, a system that enables a continuously executing loop about
information exploration ,integration , and feedback . The approach
SmartCommit presented in this paper is about organizing the result
of a developerâ€™s information exploration in a cohesive way, and our
previous work IntelliMerge [24] focuses on integrating information
from different developers into a consistent code version.
ACKNOWLEDGMENTS
This work was partially supported by the National Natural Science
Foundation of China under Grant Nos. 61690200 and 61620106007.ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Bo Shen, Wei Zhang, Christian KÃ¤stner, Haiyan Zhao, Zhao Wei, Guangtai Liang, and Zhi Jin
REFERENCES
[1]Mike Barnett, Christian Bird, JoÃ£o Brunet, and Shuvendu K Lahiri. 2015. Help-
ing Developers Help Themselves: Automatic Decomposition of Code Review
Changesets. In 2015 IEEE/ACM 37th IEEE International Conference on Software
Engineering , Vol. 1. IEEE, 134â€“144. https://doi.org/10.1109/ICSE.2015.35
[2]BoShen. 2020. Supplementary data repository. https://github.com/Symbolk/
SmartCommitEvaluation-Viz.
[3]Marco di Biase, Magiel Bruntink, Arie van Deursen, and Alberto Bacchelli. 2019.
The effects of change decomposition on code reviewâ€”a controlled experiment.
PeerJ Computer Science 5 (may 2019), e193. https://doi.org/10.7717/peerj-cs.193
[4]MartÃ­n Dias, Alberto Bacchelli, Georgios Gousios, Damien Cassou, and StÃ©phane
Ducasse. 2015. Untangling fine-grained code changes. In 2015 IEEE 22nd Inter-
national Conference on Software Analysis, Evolution, and Reengineering (SANER) .
IEEE, 341â€“350. https://doi.org/10.1109/saner.2015.7081844
[5]Steve Easterbrook, Janice Singer, Margaret-Anne Storey, and Daniela Damian.
2008. Selecting Empirical Methods for Software Engineering Research. In Guide
to Advanced Empirical Software Engineering . Springer London, 285â€“311. https:
//doi.org/10.1007/978-1-84800-044-5_11
[6]Douglas Ezzy. 2013. Qualitative Analysis . Routledge. https://doi.org/10.4324/
9781315015484
[7]Bo Guo and Myoungkyu Song. 2017. Interactively decomposing composite
changes to support code review and regression testing. In 2017 IEEE 41st Annual
Computer Software and Applications Conference (COMPSAC) , Vol. 1. IEEE, 118â€“127.
https://doi.org/10.1109/compsac.2017.153
[8]Kim Herzig and Andreas Zeller. 2013. The impact of tangled code changes. In 2013
10th Working Conference on Mining Software Repositories (MSR) . IEEE, 121â€“130.
https://doi.org/10.1109/msr.2013.6624018
[9]Karen Holtzblatt and Hugh Beyer. 1998. Contextual design. In CHI 98 Conference
Summary on Human Factors in Computing Systems . ACM. https://doi.org/10.
1145/286498.286629
[10] Shuyao Jiang. 2019. Boosting Neural Commit Message Generation with Code
Semantic Analysis. In 2019 34th IEEE/ACM International Conference on Automated
Software Engineering (ASE) . IEEE, 1280â€“1282. https://doi.org/10.1109/ase.2019.
00162
[11] George Karypis and Vipin Kumar. 1998. Multilevel algorithms for multi-constraint
graph partitioning. In SCâ€™98: Proceedings of the 1998 ACM/IEEE Conference on
Supercomputing . IEEE, 28â€“28. https://doi.org/10.1109/sc.1998.10018
[12] Hiroyuki Kirinuki, Yoshiki Higo, Keisuke Hotta, and Shinji Kusumoto. 2014. Hey!
are you committing tangled changes?. In Proceedings of the 22nd International
Conference on Program Comprehension . 262â€“265. https://doi.org/10.1145/2597008.
2597798
[13] Hiroyuki Kirinuki, Yoshiki Higo, Keisuke Hotta, and Shinji Kusumoto. 2016.
Splitting Commits via Past Code Changes. In 2016 23rd Asia-Pacific Software
Engineering Conference (APSEC) . IEEE, 129â€“136. https://doi.org/10.1109/apsec.
2016.028
[14] Martin Konopka and Pavol NÃ¡vrat. 2015. Untangling development tasks with
software developerâ€™s activity. CSD@ICSE (2015), 13â€“14. https://doi.org/10.1109/
csd.2015.10
[15] Abba M. Krieger. 1999. A Generalized Rand-Index Method for Consensus Clus-
tering of Separate Partitions of the Same Data Base. Journal of Classification 16,
1 (jan 1999), 63â€“89. https://doi.org/10.1007/s003579900043
[16] Haiming Li, Qiyang Xia, and Yong Wang. 2017. Research and Improvement of
Kruskal Algorithm. Journal of Computer and Communications 05, 12 (2017), 63â€“69.
https://doi.org/10.4236/jcc.2017.512007
[17] Pranee Liamputtong. 2011. Focus group methodology: Principle and practice . Sage
Publications.
[18] Qin Liu, Zihe Liu, Hongming Zhu, Hongfei Fan, Bowen Du, and Yu Qian. 2019.
Generating commit messages from diffs using pointer-generator network. In 2019
IEEE/ACM 16th International Conference on Mining Software Repositories (MSR) .
IEEE, 299â€“309. https://doi.org/10.1109/msr.2019.00056
[19] Zhongxin Liu, Xin Xia, Christoph Treude, David Lo, and Shanping Li. 2019.
Automatic Generation of Pull Request Descriptions. In 2019 34th IEEE/ACM
International Conference on Automated Software Engineering (ASE) . IEEE, 176â€“188.
https://doi.org/10.1109/ase.2019.00026[20] Emerson Murphy-Hill and Andrew P. Black. 2008. Refactoring Tools: Fitness for
Purpose. IEEE Software 25, 5 (sep 2008), 38â€“44. https://doi.org/10.1109/ms.2008.
123
[21] R. Emerson Murphy-Hill, Chris Parnin, and P. Andrew Black. 2012. How We
Refactor, and How We Know It. Software Engineering, IEEE Transactions (2012),
5â€“18. https://doi.org/10.1109/icse.2009.5070529
[22] Ward Muylaert and Coen De Roover. 2018. Untangling Composite Commits
Using Program Slicing. In 2018 IEEE 18th International Working Conference on
Source Code Analysis and Manipulation (SCAM) . IEEE, 193â€“202. https://doi.org/
10.1109/scam.2018.00030
[23] Hoan Anh Nguyen, Anh Tuan Nguyen, and Tien N Nguyen. 2013. Filtering noise
in mixed-purpose fixing commits to improve defect prediction and localization.
In2013 IEEE 24th International Symposium on Software Reliability Engineering
(ISSRE) . IEEE, 138â€“147. https://doi.org/10.1109/issre.2013.6698913
[24] Bo Shen, Wei Zhang, Haiyan Zhao, Guangtai Liang, Zhi Jin, and Qianxiang Wang.
2019. IntelliMerge: a refactoring-aware software merging technique. Proc. ACM
Program. Lang. 3, OOPSLA (2019), 170:1â€“170:28. https://doi.org/10.1145/3360596
[25] Janet Siegmund, Norbert Siegmund, and Sven Apel. 2015. Views on Internal and
External Validity in Empirical Software Engineering. In 2015 IEEE/ACM 37th IEEE
International Conference on Software Engineering . IEEE. https://doi.org/10.1109/
icse.2015.24
[26] Sarocha Sothornprapakorn, Shinpei Hayashi, and Motoshi Saeki. 2018. Visualiz-
ing a tangled change for supporting its decomposition and commit construction.
In2018 IEEE 42nd Annual Computer Software and Applications Conference (COMP-
SAC) , Vol. 1. IEEE, 74â€“79. https://doi.org/10.1109/compsac.2018.00018
[27] Marcel Taeumel, Stephanie Platz, Bastian Steinert, Robert Hirschfeld, and Hide-
hiko Masuhara. 2017. Unravel Programming Sessions with THRESHER: Iden-
tifying Coherent and Complete Sets of Fine-granular Source Code Changes.
Computer Software (2017). https://doi.org/10.11185/imt.12.24
[28] Yida Tao and Sunghun Kim. 2015. Partitioning composite code changes to
facilitate code review. In 2015 IEEE/ACM 12th Working Conference on Mining
Software Repositories . IEEE, 180â€“190. https://doi.org/10.1109/msr.2015.24
[29] Nikolaos Tsantalis, Matin Mansouri, Laleh Eshkevari, Davood Mazinanian, and
Danny Dig. 2018. Accurate and efficient refactoring detection in commit history.
In2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE) .
IEEE, 483â€“494. https://doi.org/10.1145/3180155.3180206
[30] Alison Twycross. 2004. Research design: qualitative, quantitative and mixed
methods approachesResearch design: qualitative, quantitative and mixed meth-
ods approaches Creswell John W Sage 320 Â£29 0761924426 0761924426. Nurse
Researcher 12, 1 (sep 2004), 82â€“83. https://doi.org/10.7748/nr.12.1.82.s2
[31] Laszlo Vidacs and Martin Pinzger. 2018. Co-evolution analysis of production
and test code by learning association rules of changes. In 2018 IEEE Workshop
on Machine Learning Techniques for Software Quality Evaluation (MaLTeSQuE) .
IEEE, 31â€“36. https://doi.org/10.1109/maltesque.2018.8368456
[32] Min Wang, Zeqi Lin, Yanzhen Zou, and Bing Xie. 2019. CoRA: Decomposing
and Describing Tangled Code Changes for Reviewer. In 2019 34th IEEE/ACM
International Conference on Automated Software Engineering (ASE) . IEEE, 1050â€“
1061. https://doi.org/10.1109/ase.2019.00101
[33] Shengbin Xu, Yuan Yao, Feng Xu, Tianxiao Gu, Hanghang Tong, and Jian Lu.
2019. Commit message generation for source code changes. In Proceedings of
the Twenty-Eighth International Joint Conference on Artificial Intelligence, IJCAI-
19. International Joint Conferences on Artificial Intelligence Organization , Vol. 7.
3975â€“3981. https://doi.org/10.24963/ijcai.2019/552
[34] Satoshi Yamashita, Shinpei Hayashi, and Motoshi Saeki. 2020. ChangeBead-
sThreader: An Interactive Environment for Tailoring Automatically Untangled
Changes. In 2020 IEEE 27th International Conference on Software Analysis, Evo-
lution and Reengineering (SANER) . IEEE, 657â€“661. https://doi.org/10.1109/
saner48275.2020.9054861
[35] Wei Zhang and Hong Mei. 2020. A constructive model for collective intelligence.
National Science Review 7, 8 (05 2020), 1273â€“1277. https://doi.org/10.1093/nsr/
nwaa092
[36] Shurui Zhou, Stefan Stanciulescu, Olaf LeÃŸenich, Yingfei Xiong, Andrzej Wa-
sowski, and Christian KÃ¤stner. 2018. Identifying features in forks. In 2018
IEEE/ACM 40th International Conference on Software Engineering (ICSE) . IEEE,
105â€“116. https://doi.org/10.1145/3180155.3180205