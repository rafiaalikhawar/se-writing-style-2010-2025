FlashRegex: Deducing Anti-ReDoS Regexes from Examples
Yeting Li
State Key Laboratory of Computer
Science,InstituteofSoftware,Chinese
Academy of Sciences
University of Chinese Academy of
Sciences
Beijing, China
liyt@ios.ac.cnZhiwu Xu
College of Computer Science and
Software Engineering, Shenzhen
University
Shenzhen, China
xuzhiwu@szu.edu.cnJialun Cao
Department of Computer Science and
Engineering, The Hong Kong
University of Science and Technology
Hong Kong, China
jcaoap@cse.ust.hk
Haiming Chenâˆ—
State Key Laboratory of Computer
Science,InstituteofSoftware,Chinese
Academy of Sciences
Beijing, China
chm@ios.ac.cnTingjian Ge
University of Massachusetts
Lowell, United States
ge@cs.uml.eduShing-Chi Cheung
Department of Computer Science and
Engineering, The Hong Kong
University of Science and Technology
Hong Kong, China
scc@cse.ust.hk
Haoren Zhao
Shaanxi Normal University
Xiâ€™an, China
zhaohaoren666@gmail.com
ABSTRACT
Regular expressions (regexes) are widely used in different fields of
computer science such as programming languages, string process-
inganddatabases.However,existingtoolsforsynthesizingorre-
pairingregexeswerenotdesignedtoberesilienttoRegexDenialof
Service(ReDoS)attacks.Specifically,ifaregexhassuper-linear(SL)
worst-case complexity, an attacker could provide carefully-crafted
inputstolaunchReDoSattacks.Therefore,inthispaper,weproposeaprogramming-by-exampleframework,FlashRegex,forgenerating
anti-ReDoS regexes by either synthesizing or repairing from given
examples.Itisthefirstframeworkthatintegratesregexsynthesis
andrepairwiththeawarenessofReDoS-vulnerabilities.Wepresent
novel algorithms to deduce anti-ReDoS regexes by reducing the
ambiguityoftheseregexesandbyusingBooleanSatisfiability(SAT)
or Neighborhood Search (NS) techniques. We evaluate FlashRegex
with five related state-of-the-art tools. The evaluation results show
thatourworkcaneffectivelyandefficientlygenerateanti-ReDoS
regexesfromgivenexamples,andalsorevealthatexistingsynthesis
andrepairtoolshaveneglectedReDoS-vulnerabilitiesofregexes.
Specifically, the existing synthesis and repair tools generated up to
394 ReDoS-vulnerable regex within few seconds to more than one
âˆ—Haiming Chen is the corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™20, September 21â€“25, 2020, Virtual Event, Australia
Â© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416556hour,whileFlashRegexgeneratednoSLregexwithinaroundfive
seconds. Furthermore, the evaluation results on ReDoS-vulnerable
regexrepairalsoshowthatFlashRegexhasbettercapabilitythan
existing repair tools and even human experts, achieving 4 more
ReDoS-invulnerable regex after repair without trimming and re-
sorting,highlightingtheusefulnessofFlashRegexintermsofthe
generality, automation and user-friendliness.
KEYWORDS
regular expression (regexes), Anti-ReDoS, program synthesis, pro-
gram repair
ACM Reference Format:
YetingLi,ZhiwuXu,JialunCao,HaimingChen,TingjianGe,Shing-ChiChe-
ung,andHaorenZhao.2020.FlashRegex:DeducingAnti-ReDoSRegexes
fromExamples.In 35thIEEE/ACMInternationalConferenceonAutomated
SoftwareEngineering(ASEâ€™20),September21â€“25,2020,VirtualEvent,Aus-
tralia.ACM, New York, NY, USA, 13 pages. https://doi.org/10.1145/3324884.
3416556
1 INTRODUCTION
Regular expressions (regexes) are a fundamental concept across
the fields of computer science, e.g., programming languages, string
processingtools,anddatabasequerylanguages[ 5,10,14,15,29,47].
Though popular, regexes are hard for users and even experts to
understandandcompose[ 10,29,51].Toalleviatethisproblem,var-
ioustechniques[ 3â€“5,7,8,21,24,32,34]havebeenproposed.From
eitherpositiveand/ornegativeexamples,thesetechniquescansyn-
thesize regexes by accepting all positive examples while rejecting
allnegativeones.This programming-by-example (PBE)technique
has the salient advantage of allowing users to provide examples to
reflecttheirtrueintentions.However,existingworks[ 14,15,29,47]
6592020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
donotconsidertheissueofsecurityvulnerabilityinregexsynthesis.
As such, the synthesized regexes are subject to attacks.
To bemore specific, if a regexhas super-linear worst-case com-
plexity(abbrev.SLregex),anattackermaybeabletotriggerthis
complexitybymaligninput,exhaustingthevictimâ€™sCPUresources
and causing Regex Denial of Service (ReDoS) [ 14]. In other words,
SLregexesareReDoS-vulnerable,sincefortheseregexes,theevalu-
ationcouldtakehigher-degreepolynomials(i.e.,quadraticorworse)orevenexponentialtimeinthesizeoftheinput.In2016,ReDoSled
to an outage at StackOverflow [ 19] and rendered vulnerable any
websites built with the popular Express.JS framework [ 2]. Further-
more,arecentstudy[ 14]foundthatSLregexesarerathercommon
inpracticeâ€”theyappearinthecoreNode.JS(JavaScript)andPython
libraries as well as in thousands of modules in the npm [ 38] and
PyPI [23] module registries, including some popular modules with
millions of downloads per month. Similar concerns are made by
Wstholz[ 59]:â€œSinceitisoftendifficultforhumanstoreasonabout
thecomplexityofregularexpressionmatching,webelievethereisa
realneedfortechniquesthatcanautomaticallysynthesizeequivalent
regular expressions with linear complexityâ€.
We extend this idea to notonly synthesize ReDos-invulnerable
regexes,butalsohelp repairincorrect1and/orReDos-vulnerable
regexes.Existingtechniques[ 33,39,44]thataimatrepairingregexes
usually focusonly on theincorrect ones. Thereis only twoline of
work [11,55] targeting on repairing ReDos-vulnerable regexes; yet
the restriction to revisions that would match the exact same lan-
guages(refertoSection2fordefinition)isactuallyrarelyapplicable
in practice (for example, cases #5, #7, and #20 in Table 3) according
to [14,47]. To achieve the aforementioned goals , there are three
challenges to be addressed.
Huge search space . For both regex synthesis and repair, the
searchspaceisextremelylarge[ 32,39]becausepracticalregexes:(i)
arelarge,(ii)operateoververylargealphabetsize,and(iii)contain
variousoperatorssuchasdisjunction,concatenation,quantifiers,
and so on.
Difficultyoflearningregexesfromexamples. Theproblem
of synthesis- [ 25] and repair-from-examples [ 39] is shown to be an
NP-completeproblem.WefurtheraddtherequirementofReDoS-
invulnerabilities, making the problem even harder.
Difficulty of prevention of ReDoS-vulnerabilities . Instead
ofavoidingcertainpatternsofregexesasprerequisitesofReDoSat-tacks[
14],developersorusersexpecttoaddressReDoS-vulnerability
fromitsrootcauseâ€”theambiguityofregexes.Indeed,ambiguity
can lead to SL behavior (also known as catastrophic backtracking)
that causes ReDoS attacks [ 14]. How to avoid generating these
ambiguousregexes effectivelyis adistinct meritof ourwork over
existing techniques.
Ourkeyideaisthatusing deterministicregexes (DREs)[9]can
prevent generating SL regexes. As its name implies, determinism
means that when matching a string from left to right against a
regex, a symbolin the string canbe matched to onlyone position
intheregexwithoutlookahead.Taketwoequivalent2regexesas
an example: (i) Non-deterministic regex: \s*#?\s* [14] and (ii)
DRE:\s*(#\s*)? . If we input a whitespace character (i.e., \s),
1A regex is incorrect if it is not consistent with all the given examples.
2Two regexes are equal iff the corresponding languages are equivalent.the first regex cannot decide which \s*(the first or the second)
should be matched without looking ahead, while the DRE can
efficientlymatchthefirst \s*withoutambiguity.Fromthisexample,
we can see that one merit of DREs is their efficient matching with
maligninputavoidingcatastrophicbacktracking[ 14],becauseeach
matchingpositionintheinputwordcanbeuniquelydecided,which
is in line with the spirit of avoiding ReDoS-vulnerabilities.
This paper proposes FlashRegex with three functionalities: (i)
regexsynthesis,(ii)incorrectregexrepair,and(iii)ReDoS-vulnerable
(i.e., SL) regex repair. Given positive and/or negative examples,
FlashRegex automatically generates anti-ReDoS regexes that are
consistent with the given examples.
We develop novel algorithms that generate anti-ReDoS regexes
by reducingthe ambiguityof theseregexes andby usingBoolean
Satisfiability(SAT)andNeighborhoodSearch(NS)techniques.In
particular, we design Boolean formulae for the determinism con-
straintandpositive and negative example constraints, and use a
heuristic strategy called Local Constraints Strengthening (LCS) to
furtherspeeduptheprocess(seeFigure3inSection4),enablingus to encode the synthesis problem into SAT. For regex repair,FlashRegex adopts a strategy that a regex after repair is as closetoitsoriginalregexaspossible.Tothisend,wepresentawayofslightly changing the edges of the current regex (represented by
anautomaton)( i.e.,theneighborhood)andperformneighborhood
searchstartingfromtheoriginalregexusinga measurefunction (see
Section 5), until a solution is found. In fact, the synthesis problem
andtherepairproblemarerelated.Thelattercanbereducedtotheformerbydisregardingthe originalregex. However,the regexsuch
repaired may be very dissimilar to the original one.
Although in this paper we only consider the regexes that do not
containnon-regularoperators(e.g.,positivelookahead),ourtool
isexpressiveenoughtocapturemostoftheregexesappearingin
practical applications according to the statistical result [ 39]. We
evaluateFlashRegexbycomparingFlashRegexwithfivestate-of-
the-arttoolsintermsofeffectiveness(includingthecorrectnessandReDoS-vulnerabilities)andtimeefficiencyonthepubliclyavailable
benchmarks.TheevaluationresultsrevealthatFlashRegexisthe
only technique that can run on all benchmarks with higher effi-
ciency and generate anti-ReDoS regexes, while the results of other
tools can be ReDoS-vulnerable. For example, on benchmark Multi-
Syn-Regex,FlashRegexreducestheaverageruntimefrommorethan
1 hour by GP-RegexGolf [ 4] containing 4 ReDoS-vulnerable results
to 4 seconds and without ReDoS-vulnerabilities. The evaluation
resultsonReDoS-vulnerableregexrepairalsoshowthatFlashRegex
has better capability than existing repair tools and even human
experts(seeSection6.4),demonstratingtheusefulnessofourwork.
To summarize, this paper makes three main contributions:
â€¢We develop FlashRegex, a programming-by-example frame-
work, to deduce anti-ReDoS regexes by either synthesizing
or repairing from given examples. To the best of our knowl-
edge,itisthefirstframeworkthatintegratesregexsynthesis
and repair with the awareness of ReDoS-vulnerabilities.
â€¢Wepresentnovelalgorithmstogenerateanti-ReDoSregexes
byreducingtheambiguityoftheseregexes.Theprocesses
are greatly accelerated by using deterministic automata and
optimizations such as the LCS strategy and SAT techniques.
660â€¢We conduct a series of comprehensive experiments compar-
ingFlashRegexwiththestate-of-the-arttools.Theevaluation
results show that FlashRegex can effectively and efficiently
generate anti-ReDoS regexes from given examples, and also
revealthatexistingsynthesisandrepairtools haveneglected
ReDoS-vulnerabilities of regexes.
2 PRELIMINARIES
LetÎ£be a finite alphabet of symbols. The set of all words over Î£is
denoted by Î£âˆ—. The empty word and the empty set are denoted by
ğœ€andâˆ…, respectively.
Aregular expression (regex) over Î£is defined inductively
as follows: ğœ€,âˆ…, andğ‘âˆˆÎ£are regular expressions; for regular
expressions ğ‘Ÿ1andğ‘Ÿ2, the disjunction ğ‘Ÿ1|ğ‘Ÿ2, the concatenation ğ‘Ÿ1ğ‘Ÿ2,
and the quantifier ğ‘Ÿ1{ğ‘š,ğ‘›}whereğ‘šâˆˆN,ğ‘›âˆˆNâˆª{âˆ}, andğ‘šâ‰¤ğ‘›
arealsoregularexpressions.Besides, ğ‘Ÿ?,ğ‘Ÿâˆ—,ğ‘Ÿ+andğ‘Ÿ{ğ‘–}whereğ‘–âˆˆN
areabbreviationsof ğ‘Ÿ{0,1},ğ‘Ÿ{0,âˆ},ğ‘Ÿ{1,âˆ}andğ‘Ÿ{ğ‘–,ğ‘–},respectively.
ğ‘Ÿ1{ğ‘š,âˆ}is often simplified as ğ‘Ÿ1{ğ‘š,}.
Thelanguage ğ¿(ğ‘Ÿ)of a regex ğ‘Ÿis defined as follows: ğ¿(âˆ…)=
âˆ…;ğ¿(ğœ€)={ğœ€};ğ¿(ğ‘)={ğ‘};ğ¿(ğ‘Ÿ1|ğ‘Ÿ2)=ğ¿(ğ‘Ÿ1)âˆªğ¿(ğ‘Ÿ2);ğ¿(ğ‘Ÿ1ğ‘Ÿ2)=
{ğ‘£ğ‘¤|ğ‘£âˆˆğ¿(ğ‘Ÿ1),ğ‘¤âˆˆğ¿(ğ‘Ÿ2)};ğ¿(ğ‘Ÿ{ğ‘š,ğ‘›})=/uniontext.1
ğ‘š/lessorequalslantğ‘–/lessorequalslantğ‘›ğ¿(ğ‘Ÿ)ğ‘–.
Practical regexes support special operators , also known as char-
acterclasses,todenotecertainsetsofcharacters.Commoncharacter
classesinclude:(i) \s,whichcontainsallwhitespacecharacters,(ii)
\d,whichcontainsdigitalcharacters,(iii)intervals[ ğ‘1-ğ‘2]which
specifies a range of characters from ğ‘1toğ‘2by using a hyphen, for
example, the regex [a-d]is the same as (a|b|c|d).
A marked form of a regex ğ‘Ÿis denoted as ğ‘Ÿ, which is obtained
by marking symbols in ğ‘Ÿwith subscripts, such that each marked
symbol occurs only once in ğ‘Ÿ. For instance, given an expression
ğ‘Ÿ=ğ‘(ğ‘|ğ‘)(ğ‘ğ‘)âˆ—, its marked form can be ğ‘1(ğ‘2|ğ‘1)(ğ‘3ğ‘2)âˆ—. The
samenotationwillalsobeusedforunmarking,namely,dropping
off subscripts from the marked symbols: ğ‘Ÿ=ğ‘Ÿ. We extend this
notation for words and sets of symbols in the same way. The set of
symbols that occur in a regex ğ‘Ÿis denoted by sym (ğ‘Ÿ).
Definition 1. Deterministic Regular Expression (DRE) [9].
Letğ‘Ÿbe a marked form of the expression ğ‘Ÿ,ğ‘Ÿis deterministic if
and only if for all words ğ‘¢ğ‘¥ğ‘£,ğ‘¢ğ‘¦ğ‘¤âˆˆğ¿(ğ‘Ÿ)whereğ‘¥,ğ‘¦âˆˆsym(ğ‘Ÿ)
andğ‘¢,ğ‘£,ğ‘¤âˆˆsym(ğ‘Ÿ)âˆ—,i fğ‘¥=ğ‘¦thenğ‘¥=ğ‘¦. An expression ğ‘Ÿis
deterministic iff ğ‘Ÿis deterministic.
Theregex ğ‘Ÿ1=ğ‘âˆ—ğ‘isnondeterministicsince ğ‘Ÿ1=ğ‘âˆ—
1ğ‘2isnonde-
terministic: given two words ğ‘1ğ‘2,ğ‘2âˆˆğ¿(ğ‘Ÿ1), there isğ‘1=ğ‘2=ğ‘
butğ‘1â‰ ğ‘2. Similarly, one can verify that ğ‘Ÿ2=ğ‘ğ‘âˆ—is deterministic.
NoticethatDREs are arestrictedsubclassofregularexpressions
â€”i.e., not every regular expression has an equivalent DRE.
Definition 2. Ağ‘˜-Occurrence Regular Expression ( ğ‘˜-ORE) [7,8]
isaregularexpressioninwhicheveryalphabetsymboloccursat
mostğ‘˜times.
For example, ğ‘ğ‘+is a 1-ORE and ğ‘(ğ‘ğ‘)?ğ‘+is a 2-ORE. Note
that1-OREisalsoknownasSingle-OccurrenceRegularExpression
(SORE)[8,24].Ağ‘˜-OccurrenceAutomaton( ğ‘˜-OA)isaspecifictype
of finite state automaton defined in the following (where the states
are labeled with symbols while edges are not).
Definition 3. ğ’Œ-Occurrence Automaton (ğ’Œ -OA) [7, 34]. Ağ‘˜-
OA is a node-labeled graph ğº=(ğ‘‰,ğ‘…,ğ‘™ğ‘ğ‘)where:â€¢ğ‘‰is a finite set of nodes (also known as states) with a distin-
guished source ğ‘ ğ‘Ÿğ‘and sinkğ‘ ğ‘›ğ‘˜.
â€¢ğ‘…is a set of edge relations representing reachable paths. ğ‘ ğ‘Ÿğ‘
hasonlyoutgoingedgesand ğ‘ ğ‘›ğ‘˜hasonlyincomingedges.
Everyğ‘£âˆˆğ‘‰\{ğ‘ ğ‘Ÿğ‘,ğ‘ ğ‘›ğ‘˜}is reachable by a path from ğ‘ ğ‘Ÿğ‘toğ‘ ğ‘›ğ‘˜.
â€¢ğ‘™ğ‘ğ‘is the labeling function ğ‘‰\{ğ‘ ğ‘Ÿğ‘,ğ‘ ğ‘›ğ‘˜}â†’Î£.
â€¢Thereareatmost ğ‘˜stateslabeledwiththesamesymbolin
Î£.
We useğ‘œğ‘¢ğ‘¡(ğ‘£,ğœ)to denote {ğ‘£1|(ğ‘£,ğ‘£1)âˆˆğ‘…ğ‘ ğ‘› ğ‘‘ğœ=ğ‘™ğ‘ğ‘(ğ‘£1)}, i.e.,
the set of direct successors of a state ğ‘£inAthat are labeled ğœ.
ASingle-OccurrenceAutomaton(SOA)[ 8,24]isaspecialcase
ofğ‘˜-OA where ğ‘˜=1. A markedğ‘˜-OAAis ağ‘˜-OA where each
nodeismarkedwithasubscriptsuchthateachnodelabelisunique
inA. It is clear that a marked ğ‘˜- O Ai sa nS O A .A deterministic
ğ‘˜-OA is ağ‘˜-OA in which for each node ğ‘£âˆˆğ‘‰andğœâˆˆÎ£,ğ‘œğ‘¢ğ‘¡(ğ‘£,ğœ)
contains at most one state.
We can use an adjacency matrix to represent a ğ‘˜-OA. The 2-OA
Afor the regex ğ‘(ğ‘ğ‘)?ğ‘+and its adjacency matrix Ağºare shown
in Figure 1.
ğ‘ ğ‘Ÿğ‘ ğ‘ ğ‘
ğ‘ ğ‘ ğ‘ ğ‘›ğ‘˜Ağº=ğ‘ğ‘ğ‘ğ‘ğ‘  ğ‘› ğ‘˜
/parenlefttpA/parenleftexA/parenleftexA/parenleftexA/parenleftexA
/parenleftbtA/parenrighttpA/parenrightexA/parenrightexA/parenrightexA/parenrightexA
/parenrightbtAğ‘ ğ‘Ÿğ‘TFFF F
ğ‘FTFT F
ğ‘FFTF F
ğ‘FFFT F
ğ‘FFFT T
Figure 1: 2-OA Aforğ‘(ğ‘ğ‘)
?ğ‘+and its adjacency matrix Ağº.
3 OVERVIEW
In this section, we present an overview of our approach.
Regex Synthesis. The first problem we target at is to synthesize
anti-ReDoSregexesfrompositiveandnegativeexamples.Thatis,
given a positive example set ğ‘†+and a negative example set ğ‘†âˆ’, the
goalistolearnaregex ğ‘Ÿsuchthat(i) ğ‘†+âŠ†ğ¿(ğ‘Ÿ)andğ‘†âˆ’âˆ©ğ¿(ğ‘Ÿ)=âˆ…;
and (ii)ğ‘Ÿis invulnerable to ReDoS attacks.
The key of our solution to tackle this problem is the use of
deterministic regexes. In particular, our solution consists of twosteps, namely,
ğ‘˜-OA synthesis (Section 4.1) and regex extraction
(Section 4.2). ğ‘˜-OA synthesis takes the given positive and negative
examplesasinputandtriestosynthesizeadeterministic ğ‘˜-OAfrom
the examples via SAT. This task first uses a Boolean variable to
representapossibleedgerelationbetweentwonodes,wherein ğ‘‡
represents an edge exists while ğ¹represents no edge exists; and
thenitencodesthepropertiesofthepossible ğ‘˜-OAsintoBoolean
formulas, which are then fed into a SAT solver. If the formulas
are satisfiable, the SAT solver returns a solution, from which ğ‘˜-OA
synthesis builds ağ‘˜-OA.
After that, regex extraction marks the synthesized deterministic
ğ‘˜-OA and extracts a marked regex from the marked ğ‘˜-OA, by call-
ingtheprocedure ğ‘†ğ‘œğ‘2ğ‘†ğ‘œğ‘Ÿğ‘’usedinFreydenbergerandKotzingâ€™s
work[24].Thisprocedure ğ‘†ğ‘œğ‘2ğ‘†ğ‘œğ‘Ÿğ‘’buildsfromagivenSOA Aan
SOREğ‘Ÿthat minimally generalizes ğ¿(A)(see [24] for the explana-
tion of minimal generalization). Then regex extraction unmarks the
regex and returns it if it is deterministic.
661Generally, regexes with smaller nested quantifiers (e.g., â€œstar
heightâ€)arelesslikelytosufferfromReDoSattacks.Wealsofind
that a regex extracted from a ğ‘˜-OA with a smallervalue ofğ‘˜has a
smallernested quantifiers. Thus, our solution will perform these
twotasksstartingfrom ğ‘˜=1.Onceapossibleregexisfound,our
solution returns this regex immediately. Furthermore, a ğ‘˜of 7 is
sufficienttocapturetheintendedsemanticsof95 .76%oftheregexes
fromRegExLib[ 45],anditistreatedasauserparametercontrolling
how long the synthesizer searches. The bounding of ğ‘˜is helpful in
reducing the huge search space.
Regex Repair. The second problem is to repair an incorrect (i.e.,
rejectingsomeexamplesin ğ‘†+oracceptingsomeexamplesin ğ‘†âˆ’)or
ReDos-vulnerableregex ğ‘Ÿ(i.e.,ReDoS-prone)withrespecttoaposi-
tiveexampleset ğ‘†+andanegativeexampleset ğ‘†âˆ’.Theideaisquite
similar to regex synthesis: to use deterministic regexes when possi-
ble. That is, our solution (Section5) tries to derive a deterministic
regex from ğ‘Ÿto achieve the same goal of regex synthesis.
Indetail,oursolutionstartswithadeterministic ğ‘˜-OA,which
is converted from the given regex ğ‘Ÿ. Then it searches for a ğ‘˜-OA
whichcanacceptthemostpositiveexamplesand/orrejectthemost
negative ones among those in the neighborhood (i.e., those with
onedifferent valuefrom thecurrent ğ‘˜-OA).Our methodkeeps on
searching, until it finds a deterministic ğ‘˜-OA that accepts all the
positive examples and rejects all the negative ones, or the number
of iterations exceeds a given number (set to be 200 in this paper).A Case Study of Regex Synthesis.
Weillustrateoursolutionwith
an example, whose positive example set is ğ‘†+={ğ‘ğ‘,ğ‘ğ‘ğ‘ğ‘,ğ‘ğ‘ğ‘ğ‘ }
and negative example set is ğ‘†âˆ’={ğ‘ğ‘,ğ‘ğ‘ğ‘,ğ‘ğ‘ğ‘ğ‘ }. Assume the au-
tomaton to synthesize is a deterministic 2-OA. That is to say, we
have at most two nodes labeled with ğ‘(resp.ğ‘), which are denoted
asğ‘1andğ‘2(resp.ğ‘1andğ‘2),respectively.Andwerepresentapos-
sibleedgebetweentwonodes ğ‘¢andğ‘£asaBooleanvariable ğ´ğ‘¢,ğ‘£.
Firstly,asthe2-OAisdeterministic,thereisatmostonenodethatislabelledbyanysymbol
ğœâˆˆ{ğ‘,ğ‘}aswellasdirectsuccessorsofany
nodeğ‘£âˆˆ{ğ‘1,ğ‘2,ğ‘1,ğ‘2,ğ‘ ğ‘Ÿğ‘,ğ‘ ğ‘›ğ‘˜}.Thatistosay, ğ‘œğ‘¢ğ‘¡(ğ‘£,ğœ)containsat
mostonenode,whichcanbeencodedasaBooleanformula.Forex-ample,theconditionfor
ğ‘œğ‘¢ğ‘¡(ğ‘1,ğ‘)canbeencodedasthefollowing
formula:(Â¬ğ´ğ‘1,ğ‘1âˆ§Â¬ğ´ğ‘1,ğ‘2)âˆ¨(ğ´ğ‘1,ğ‘1âˆ§Â¬ğ´ğ‘1,ğ‘2)âˆ¨(Â¬ğ´ğ‘1,ğ‘1âˆ§ğ´ğ‘1,ğ‘2).
Wedothesametoother ğ‘œğ‘¢ğ‘¡(ğ‘£,ğœ)â€™s.Secondly,eachword ğ‘¤inğ‘†+
should be accepted by this synthesizd 2-OA; hence there existsa path for
ğ‘¤. Takeğ‘ğ‘as an example. As both ğ‘andğ‘have two
possiblelabellednodes,therearefourpossiblecasesforthepathof
ğ‘ğ‘, which can be represented as the following formula:
(ğ´ğ‘ ğ‘Ÿğ‘,ğ‘1âˆ§ğ´ğ‘1,ğ‘1âˆ§ğ´ğ‘1,ğ‘ ğ‘›ğ‘˜)âˆ¨(ğ´ğ‘ ğ‘Ÿğ‘,ğ‘1âˆ§ğ´ğ‘1,ğ‘2âˆ§ğ´ğ‘2,ğ‘ ğ‘›ğ‘˜)âˆ¨
(ğ´ğ‘ ğ‘Ÿğ‘,ğ‘2âˆ§ğ´ğ‘2,ğ‘1âˆ§ğ´ğ‘1,ğ‘ ğ‘›ğ‘˜)âˆ¨(ğ´ğ‘ ğ‘Ÿğ‘,ğ‘2âˆ§ğ´ğ‘2,ğ‘2âˆ§ğ´ğ‘2,ğ‘ ğ‘›ğ‘˜)
Itisthesamewiththeotherwordsin ğ‘†+.Finally,wealsorequire
that each word ğ‘¤inğ‘†âˆ’should notbeacceptedby the 2-OA, which
can be converted into Boolean formulas similarly (with a negation
onthetop).Whentheformulasaregenerated3,wefeedtheformulas
intotheSATsolverandgetasolution,whichisillustratedasthe
matrixAğºinFigure1.Basedonthissolution,adeterministic2-OA
A2can be built easily, which is also given in Figure 1.
3We can also generate the formulas according to the local properties, such as 2-
successive-steps, of the given words to synthesize a sound ğ‘˜-OA faster, which are
called Local Constraints Strengthening (LCS) heuristic strategy (see Section 4.1 for
more detail).ğ‘ ğ‘Ÿğ‘ ğ‘1 ğ›¾ ğ‘+
2ğ‘ ğ‘›ğ‘˜ğ›¾=(ğ‘2ğ‘1)?
Figure 2: An intermediate SOA in ğ‘†ğ‘œğ‘2ğ‘†ğ‘œğ‘Ÿğ‘’(A2)
Next, we mark A2, on which we call the procedure ğ‘†ğ‘œğ‘2ğ‘†ğ‘œğ‘Ÿğ‘’
to extract a regex. Figure 2 gives an intermediate SOA obtained
inğ‘†ğ‘œğ‘2ğ‘†ğ‘œğ‘Ÿğ‘’(A2), from which a marked regex ğ‘1(ğ‘2ğ‘1)?ğ‘+
2is built
byğ‘†ğ‘œğ‘2ğ‘†ğ‘œğ‘Ÿğ‘’. Therefore, the final regex we extract for A2isğ‘Ÿ2=
ğ‘(ğ‘ğ‘)?ğ‘+.
4 SYNTHESIS ALGORITHM
In this section, we present the details of our synthesis algorithm
SynRegex.
Our synthesis algorithm is shown in Algorithm 1, which tries
to synthesize a possible ğ‘˜-ORE for ğ‘˜ranging in [1,ğ‘˜ğ‘šğ‘ğ‘¥]. Here,
ğ‘˜ğ‘šğ‘ğ‘¥is a customized parameter, and in this paper, ğ‘˜ğ‘šğ‘ğ‘¥is set to
7 due to the reason discussed in Â§3. In detail, for a given ğ‘˜, our
algorithm first synthesizes a deterministic ğ‘˜-OA from the given
examples (line 2), which is introduced in Section 4.1, and then it
extracts a regex from the marked version of the synthesized ğ‘˜-OA
(line 4), which is presented in Section 4.2, if the ğ‘˜-OA is not ğ‘›ğ‘¢ğ‘™ğ‘™.
Finally,ouralgorithmreturnstheregexwiththesmallest ğ‘˜iffound
(lines 5âˆ’6), or returns ğ‘›ğ‘¢ğ‘™ğ‘™otherwise (line 7).
Algorithm 1: SynRegex
Input:a positive set ğ‘†+and a negative set ğ‘†âˆ’
Output:a deterministic regex ğ‘Ÿwithğ‘†+âŠ†ğ¿(ğ‘Ÿ)and
ğ‘†âˆ’âˆ©ğ¿(ğ‘Ÿ)=âˆ…if solvable for ğ‘˜ğ‘šğ‘ğ‘¥,o rğ‘›ğ‘¢ğ‘™ğ‘™
otherwise
1forğ‘˜=1toğ‘˜ğ‘šğ‘ğ‘¥do
2Aâ†ğ‘ ğ‘¦ğ‘›KOA+âˆ’(ğ‘†+,ğ‘†âˆ’,ğ‘˜)
3ifAâ‰ ğ‘›ğ‘¢ğ‘™ğ‘™then
4ğ‘Ÿâ†GenRegex( A)
5 ifğ‘Ÿâ‰ ğ‘›ğ‘¢ğ‘™ğ‘™then
6 returnğ‘Ÿ
7returnğ‘›ğ‘¢ğ‘™ğ‘™
4.1 k-OA Synthesis
This section presents the ğ‘˜-OA synthesis algorithm, which synthe-
sizeadeterministic ğ‘˜-OAbyencodingthesynthesisproblemintoa
Boolean satisfiability problem (SAT).
AsshowninFigure1(Section2),a ğ‘˜-OAcanberepresentedasa
Boolean adjacency matrix. Therefore, we use a Boolean variable to
represent a possible edge in a ğ‘˜-OA. Once all the Boolean variables
are fixed, a ğ‘˜-OA is obtained meanwhile.
Recallthatthe ğ‘˜-OAtobesynthesized(a)isdeterministicand
(b)acceptsthewordsin ğ‘†+whilerejectingthewordsin ğ‘†âˆ’.Forthe
condition (a), ğ‘œğ‘¢ğ‘¡(ğ‘£,ğœ)contains at most one state for any ğ‘£âˆˆğ‘‰
andğœâˆˆÎ£. Then this deterministic condition on a ğ‘˜-OA can be
encodedintoaformulaviatheconstraintgenerator Deter(k),which
662is shown in Figure 3,where Î£is the alphabet, ğ›¼ğ‘š,ğ›¼ğ‘›andğ›¼ğ‘¡are
indexedstatesfor ğ›¼âˆˆÎ£,andğ´ğ‘¢,ğ‘£isaBooleanvariablerepresenting
apossibleedge(i.e.,aunitintheBooleanadjacencymatrix)fortwo
indexed states ğ‘¢andğ‘£.
Letusconsiderthecondition(b).AsillustratedinSection3,both
positiveexamplesandnegativeexamplescanbeentirelydealtwith
by a general example constraint generator (called global constraint
generator). Thus, the longer the example, the more the possible
cases(i.e.,theconjunctiveclausesyieldedbythetransformationon
thecorrespondinglogicformulas).Moreover,fornegativeexamples,
atopnegationneedstobetaken,sothatthenumberofcasesfor
anegativeexample ğ‘¤wouldbe (2|ğ‘¤|âˆ’1)timesthatofapositive
exampleofthesamelength,where |ğ‘¤|denotesthelengthof ğ‘¤.A s
a result, with the increase of negative examples, the runtime of the
algorithm could grow significantly, especially for the long ones.
Tospeedupthe ğ‘˜-OAsynthesisalgorithm,wepresentaheuristic
algorithm ğ‘“ğ‘ğ‘ ğ‘¡KOA+âˆ’, which adopts local constraints, rather than
the global constraintson the whole words. Wecall the strategy as
Local Constraints Strengthening (LCS) heuristic one.
ThelocalconstraintgeneratorsarealsogiveninFigure3,where
Exam(ğ‘¤,ğ‘˜)denotes the global constraint generator for positive
examples.Differentfromthe globalconstraintgenerator,theposi-
tive example constraint generator Posadoes not ensure that there
existsapathinthe ğ‘˜-OAforeachword ğ‘¤inthepositiveset ğ‘†+,but
ensuresthateverystepofapossiblepathfor ğ‘¤existsinğ‘˜-OA.This
isclearlyaweakercondition.Toensurethesoundness,weenhance
our constraints with another generator Posb.Posbchecks that if a
step of a possible path for ğ‘¤âˆˆğ‘†+exists in the ğ‘˜-OA, then its next
2-successive-steps exists as well. The condition is a complement of
Posa,andthecompositionof PosaandPosbisastrongercondition.
Take the word ğ‘¤=ğ‘ğ‘ğ‘ğ‘ğ‘‘ğ‘’for example. Posb(ğ‘ğ‘ğ‘ğ‘ğ‘‘ğ‘’,ğ‘˜)requires
thatboth2-successive-steps ğ‘ğ‘andğ‘‘ğ‘’shouldbenexttoeverystate
labelledby ğ‘intheğ‘˜-OA.Whilethenegativeexampleconstraint
generator Neg(ğ‘¤,ğ‘˜)requiresthatforeachstepofapossiblepath
forğ‘¤âˆˆğ‘†âˆ’, none of its next 2-successive-steps in the path exists
in theğ‘˜-OA. The condition is a stronger one as well. Note that
only one of the next 2-successive-steps does not exist in the ğ‘˜-OA
maybesufficient.Forexample,if ğ‘ğ‘ğ‘ğ‘ğ‘‘ğ‘’isnegative,thenoneof ğ‘ğ‘
andğ‘‘ğ‘’not following ğ‘is sufficient. But this is similar to the global
constraint generator: there is a top-level negation. In brief, local
constraint generators take 2 steps forward for each step. This step
size2issetupbasedonourexperience,whichcanguaranteethe
solvability of most problems and speedupthe solution process.
The algorithm ğ‘“ğ‘ğ‘ ğ‘¡KOA+âˆ’is shown in Algorithm 2, which first
encodesour ğ‘˜-OAsynthesisintoaSATviatheconstraintgenerators
inFigure3(lines1-6)andthensolvestheSATproblemifsatisfiable
(lines7-11).IfSATisunsatisfiable,thenthealgorithm willinvoke
the exact version ğ‘–KOA+âˆ’(line 12), wherein the global constraint
generatorforexamplesareusedinstead.Notethatthepruningstep
aims to delete useless states and edges in an automaton, especially
thetrapstates,whichwillnotaffecttheacceptancesoftheexamples
but could cause the procedure ğ‘†ğ‘œğ‘2ğ‘†ğ‘œğ‘Ÿğ‘’used inregex extraction to
fail.
We remark that our algorithm is flexible. From the synthesis
process, it can be seen that our algorithm not only supports regexAlgorithm 2: ğ‘“ğ‘ğ‘ ğ‘¡KOA+âˆ’
Input:a positive set ğ‘†+, a negative set ğ‘†âˆ’, a valueğ‘˜
Output:a deterministic ğ‘˜-OAAorğ‘›ğ‘¢ğ‘™ğ‘™
1initialize the formula set D â†âˆ…
2add Deter (ğ‘˜)to D
3forğ‘¤âˆˆğ‘†+do
4add Pos a(ğ‘¤,ğ‘˜)âˆ§Posb(ğ‘¤,ğ‘˜)to D
5forğ‘¤âˆˆğ‘†âˆ’do
6add Neg(ğ‘¤,ğ‘˜)to D
7Put D in a SAT solver
8ifDis satisfiable then
9convert Boolean variables (matrix) to a ğ‘˜-OAA
10Aâ†pruneAw.r.t.ğ‘†+andğ‘†âˆ’
11returnA
12else return ğ‘–KOA+âˆ’(ğ‘†+,ğ‘†âˆ’,ğ‘˜);
synthesis from positive and negative examples, but it can also syn-
thesize regular expressions from positive (or negative) examples
onlybyremovingthecorrespondingconstraintsofnegative(orpos-
itive) examples. Moreover, our algorithm is incremental, since one
can synthesize a correct regex by feeding more and more examples
gradually.
4.2 Regex Extraction
In this section, we present our procedure ğºğ‘’ğ‘›ğ‘…ğ‘’ğ‘”ğ‘’ğ‘¥ to extract a
regexfromamarked ğ‘˜-OA.AsmentionedinSection2,amarked ğ‘˜-
OA is also an SOA. Freydenberger and Kotzing [24] have proposed
an efficient procedure ğ‘†ğ‘œğ‘2ğ‘†ğ‘œğ‘Ÿğ‘’to convert a given SOA Ato an
SOREğ‘Ÿthat minimally generalizes ğ¿(A). This procedure recurses
first on all strongly connected looped components and then on
the directed acyclic graph obtained by contracting all Strongly
Connected Components (SCCs) (i.e., a maximal subgraph in which
every node is reachable from every other node) with pluses â€œ+â€.
Here we use this procedure to extract regex from a marked ğ‘˜-OA.
The procedure ğºğ‘’ğ‘›ğ‘…ğ‘’ğ‘”ğ‘’ğ‘¥ proceeds as follows: ğºğ‘’ğ‘›ğ‘…ğ‘’ğ‘”ğ‘’ğ‘¥ first
invokesğ‘†ğ‘œğ‘2ğ‘†ğ‘œğ‘Ÿğ‘’(A)to converta marked ğ‘˜-OAAinto anSORE
(i.e.,amarkedregex) ğ‘Ÿ,thendropsoffthemarksofallsymbolsin
ğ‘Ÿ, and finally returns the unmarked regex if it is deterministic4,o r
returnsğ‘›ğ‘¢ğ‘™ğ‘™otherwise.
Further, we adopted a regex rewriting step to prettify the synthe-
sized regex ğ‘Ÿin order to get a more concise and practical one by
performing on ğ‘Ÿthe rewritingrules inFigure 4until nomore rule
is applicable.
Finally, as shown in Algorithm 1, our algorithm may return ğ‘›ğ‘¢ğ‘™ğ‘™
(i.e., fail), which is mainly due to (i) the parameter ğ‘˜may not be
sufficientlylarge;and(ii)noteveryregexhasanequivalentdeter-ministicversion,asdeterministicregexesare arestrictedsubclass
of regexes.
5 REPAIR ALGORITHM
In practice, one may write an incorrect or ReDoS-vulnerable regex.
So,inthesection,wepresentanalgorithmbasedonNeighborhood
4The determinism of a regex can be decided in linear time [26].
663(1) Determinism Constraint Generator:
Deter(ğ‘˜)=/logicalanddisplay.1
ğ›¼âˆˆÎ£/braceleftbigg/bracketleftBig/logicalordisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/parenleftbigğ´ğ‘ ğ‘Ÿğ‘,ğ›¼ğ‘šâˆ§/logicalanddisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜,ğ‘›â‰ ğ‘šÂ¬ğ´ğ‘ ğ‘Ÿğ‘,ğ›¼ğ‘›/parenrightbig/bracketrightBig
âˆ¨/parenleftbig/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜Â¬ğ´ğ‘ ğ‘Ÿğ‘,ğ›¼ğ‘š/parenrightbig/bracerightbigg
âˆ§/logicalanddisplay.1
ğ›¼âˆˆÎ£,ğ›½âˆˆÎ£/logicalanddisplay.1
1â‰¤ğ‘¡â‰¤ğ‘˜/braceleftbigg/bracketleftBig/logicalordisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/parenleftbigğ´ğ›¼ğ‘¡,ğ›½ğ‘šâˆ§/logicalanddisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜,ğ‘›â‰ ğ‘šÂ¬ğ´ğ›¼ğ‘¡,ğ›½ğ‘›/parenrightbig/bracketrightBig
âˆ¨/parenleftbig/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜Â¬ğ´ğ›¼ğ‘¡,ğ›½ğ‘š/parenrightbig/bracerightbigg
(2) Positive Example Constraint Generators:
Posa(ğ‘¤,ğ‘˜)=â§âªâªâªâªâªâª â¨
âªâªâªâªâªâªâ©ğ´
ğ‘ ğ‘Ÿğ‘,ğ‘ ğ‘›ğ‘˜ |ğ‘¤|=0/logicalordisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/parenleftbigğ´ğ‘ ğ‘Ÿğ‘,ğ‘¤[1]ğ‘šâˆ§ğ´ğ‘¤[1]ğ‘š,ğ‘ ğ‘›ğ‘˜/parenrightbig|ğ‘¤|=1
/logicalordisplay.1
1â‰¤ğ‘š1â‰¤ğ‘˜ğ´ğ‘ ğ‘Ÿğ‘,ğ‘¤[1]ğ‘š1âˆ§/logicalanddisplay.1
1â‰¤ğ‘–â‰¤|ğ‘¤|âˆ’1/parenleftbig /logicalordisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜,1â‰¤ğ‘›â‰¤ğ‘˜ğ´ğ‘¤[ğ‘–]ğ‘š,ğ‘¤[ğ‘–+1]ğ‘›/parenrightbigâˆ§/logicalordisplay.1
1â‰¤ğ‘š|ğ‘¤|â‰¤ğ‘˜ğ´ğ‘¤[|ğ‘¤|]ğ‘š|ğ‘¤|,ğ‘ ğ‘›ğ‘˜|ğ‘¤|â‰¥2
Posb(ğ‘¤,ğ‘˜)=â§âªâªâªâªâªâªâªâªâªâªâªâªâªâªâª â¨
âªâªâªâªâªâªâªâªâªâªâªâªâªâªâªâ©T |ğ‘¤|<2/logicalanddisplay.1
1â‰¤ğ‘š1â‰¤ğ‘˜/bracketleftBig
ğ´ğ‘ ğ‘Ÿğ‘,ğ‘¤[1]ğ‘š1â†’/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/parenleftbigğ´ğ‘¤[1]ğ‘š1,ğ‘¤[2]ğ‘šâˆ§ğ´ğ‘¤[2]ğ‘š,ğ‘ ğ‘›ğ‘˜/parenrightbig/bracketrightBig
|ğ‘¤|=2
/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘š1â‰¤ğ‘˜/parenleftbigğ´ğ‘ ğ‘Ÿğ‘,ğ‘¤[1]ğ‘š1â†’/logicalordisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜ğ´ğ‘¤[1]ğ‘š1,ğ‘¤[2]ğ‘šâˆ§/parenleftbig/logicalordisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜ğ´ğ‘¤[2]ğ‘š,ğ‘¤[3]ğ‘›/parenrightbig/parenrightbig/bracketrightBig
âˆ§/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/logicalanddisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[1]ğ‘š,ğ‘¤[2]ğ‘›â†’/logicalordisplay.1
1â‰¤ğ‘¡â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[2]ğ‘›,ğ‘¤[3]ğ‘¡âˆ§ğ´ğ‘¤[3]ğ‘¡,ğ‘ ğ‘›ğ‘˜/parenrightbig/parenrightbig/bracketrightBig
|ğ‘¤|=3
â§âªâªâªâª â¨
âªâªâªâªâ©/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘š1â‰¤ğ‘˜/parenleftbigğ´ğ‘ ğ‘Ÿğ‘,ğ‘¤[1]ğ‘š1â†’/logicalordisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜ğ´ğ‘¤[1]ğ‘š1,ğ‘¤[2]ğ‘šâˆ§/parenleftbig/logicalordisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜ğ´ğ‘¤[2]ğ‘š,ğ‘¤[3]ğ‘›/parenrightbig/parenrightbig/bracketrightBig
âˆ§/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘–â‰¤|ğ‘¤|âˆ’3/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/logicalanddisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[ğ‘–]ğ‘š,ğ‘¤[ğ‘–+1]ğ‘›â†’
/logicalortext.1
1â‰¤ğ‘¡â‰¤ğ‘˜ğ´ğ‘¤[ğ‘–+1]ğ‘›,ğ‘¤[ğ‘–+2]ğ‘¡âˆ§/parenleftbig/logicalortext.1
1â‰¤ğ‘œâ‰¤ğ‘˜ğ´ğ‘¤[ğ‘–+2]ğ‘¡,ğ‘¤[ğ‘–+3]ğ‘œ/parenrightbig/parenrightbig/bracketrightBig
âˆ§/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/logicalanddisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[|ğ‘¤|âˆ’2]ğ‘š,ğ‘¤[|ğ‘¤|âˆ’1]ğ‘›â†’/logicalordisplay.1
1â‰¤ğ‘¡â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[|ğ‘¤|âˆ’1]ğ‘›,ğ‘¤[|ğ‘¤|]ğ‘¡âˆ§ğ´ğ‘¤[|ğ‘¤|]ğ‘¡,ğ‘ ğ‘›ğ‘˜/parenrightbig/parenrightbig/bracketrightBig|ğ‘¤|>3
(3) Negative Example Constraint Generators:
Neg(ğ‘¤,ğ‘˜)=â§âªâªâªâªâªâªâªâªâªâª â¨
âªâªâªâªâªâªâªâªâªâªâ©Â¬Exam(ğ‘¤,ğ‘˜) |ğ‘¤|â‰¤2/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/parenleftbigğ´ğ‘ ğ‘Ÿğ‘,ğ‘¤[1]ğ‘šâ†’Â¬/parenleftbig/logicalordisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜ğ´ğ‘¤[1]ğ‘š,ğ‘¤[2]ğ‘›âˆ§/parenleftbig/logicalordisplay.1
1â‰¤ğ‘¡â‰¤ğ‘˜ğ´ğ‘¤[2]ğ‘›,ğ‘¤[3]ğ‘¡/parenrightbig/parenrightbig/parenrightbig/bracketrightBig
âˆ§/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/logicalanddisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[1]ğ‘š,ğ‘¤[2]ğ‘›â†’Â¬/parenleftbig/logicalordisplay.1
1â‰¤ğ‘¡â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[2]ğ‘›,ğ‘¤[3]ğ‘¡âˆ§ğ´ğ‘¤[3]ğ‘¡,ğ‘ ğ‘›ğ‘˜/parenrightbig/parenrightbig/parenrightbig/bracketrightBig
|ğ‘¤|=3
â§âªâªâªâª â¨
âªâªâªâªâ©/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/parenleftbigğ´ğ‘ ğ‘Ÿğ‘,ğ‘¤[1]ğ‘šâ†’Â¬/parenleftbig/logicalordisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜ğ´ğ‘¤[1]ğ‘š,ğ‘¤[2]ğ‘›âˆ§/parenleftbig/logicalordisplay.1
1â‰¤ğ‘¡â‰¤ğ‘˜ğ´ğ‘¤[2]ğ‘›,ğ‘¤[3]ğ‘¡/parenrightbig/parenrightbig/parenrightbig/bracketrightBig
âˆ§/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘–â‰¤|ğ‘¤|âˆ’3/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/logicalanddisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[ğ‘–]ğ‘š,ğ‘¤[ğ‘–+1]ğ‘›â†’
Â¬/parenleftbig/logicalortext.1
1â‰¤ğ‘¡â‰¤ğ‘˜ğ´ğ‘¤[ğ‘–+1]ğ‘›,ğ‘¤[ğ‘–+2]ğ‘¡âˆ§/parenleftbig/logicalortext.1
1â‰¤ğ‘œâ‰¤ğ‘˜ğ´ğ‘¤[ğ‘–+2]ğ‘¡,ğ‘¤[ğ‘–+3]ğ‘œ/parenrightbig/parenrightbig/parenrightbig/bracketrightBig
âˆ§/bracketleftBig/logicalanddisplay.1
1â‰¤ğ‘šâ‰¤ğ‘˜/logicalanddisplay.1
1â‰¤ğ‘›â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[|ğ‘¤|âˆ’2]ğ‘š,ğ‘¤[|ğ‘¤|âˆ’1]ğ‘›â†’Â¬/parenleftbig/logicalordisplay.1
1â‰¤ğ‘¡â‰¤ğ‘˜/parenleftbigğ´ğ‘¤[|ğ‘¤|âˆ’1]ğ‘›,ğ‘¤[|ğ‘¤|]ğ‘¡âˆ§ğ´ğ‘¤[|ğ‘¤|]ğ‘¡,ğ‘ ğ‘›ğ‘˜/parenrightbig/parenrightbig/parenrightbig/bracketrightBig|ğ‘¤|>3
Figure 3: Determinism Constraint Generator and Local Constraint Generators
ğ‘1|...|ğ‘ğ‘›=â‡’[ğ‘1-ğ‘ğ‘›]
[A-Za-z0-9_] =â‡’\w
ğ‘Ÿ1...ğ‘Ÿ1
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehtipupright
ğ‘˜times=â‡’ğ‘Ÿ1{ğ‘˜}
ğ‘Ÿ1...ğ‘Ÿ1
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehtipupright
ğ‘˜timesğ‘Ÿâˆ—
1=â‡’ğ‘Ÿ1{ğ‘˜,}[0-9] =â‡’\d
[ \t\r\n\f] =â‡’\s
ğ‘Ÿ1...ğ‘Ÿ1
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehtipupright
ğ‘˜timesğ‘Ÿ1?=â‡’ğ‘Ÿ1{ğ‘˜,ğ‘˜+1}
ğ‘Ÿ1...ğ‘Ÿ1
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehtipupright
ğ‘˜timesğ‘Ÿ+
1=â‡’ğ‘Ÿ1{ğ‘˜+1,}
Figure 4: Rewriting Rules for Regex
Search (NS) to repair such an incorrect or ReDos-vulnerable regex
to achieve the same goals as our synthesis algorithm. In particular,
given an incorrect or ReDos-vulnerable regex ğ‘Ÿand sets of positive
and negative examples, it returns a ReDoS-invulnerable regex ğ‘Ÿ/prime
that is consistent with the examples.
We assume that the given regex is close to a solution. So the
key idea of our algorithm is to search for a better solution, i.e., one
that accepts more positive samples and/or rejects more negative
samples, from the neighborhoods of a candidate ğ‘˜-OA. To start
with, we define the neighborhood and an evaluation criterion of
ağ‘˜-OAA. Given a ğ‘˜-OAA, i.e., a Boolean matrix, we define its
neighborhood, denoted as ğ‘(A), as the set of ğ‘˜-OAs, which can be
obtainedbyflippingone Booleanvalueof A.Inordertoselecta
ğ‘˜-OA among a set of ğ‘˜-OAs, we define a measure ğ‘“onğ‘˜-OA with
respectto ğ‘†+andğ‘†âˆ’as
ğ‘“(A,ğ‘†+,ğ‘†âˆ’)=|ğ‘‡ğ‘ƒ|âˆ’|ğ¹ğ‘|+|ğ‘‡ğ‘|âˆ’|ğ¹ğ‘ƒ|
|ğ‘†+|+|ğ‘†âˆ’|
where we have ğ‘‡ğ‘ƒ={ğ‘¤âˆˆğ‘†+|ğ‘¤âˆˆğ¿(A)},ğ¹ğ‘={ğ‘¤âˆˆğ‘†+|ğ‘¤âˆ‰
ğ¿(A)},ğ‘‡ğ‘={ğ‘¤âˆˆğ‘†âˆ’|ğ‘¤âˆ‰ğ¿(A)},ğ¹ğ‘ƒ={ğ‘¤âˆˆğ‘†âˆ’|ğ‘¤âˆˆğ¿(A)},
and|ğ‘†|isthenumberofelementsintheset ğ‘†.Intuitively,thehighertheğ‘“value, the better the ğ‘˜-OA. Especially, the ğ‘˜-OA with ğ‘“value
1 will acceptall positive samplesand reject allnegative samples. In
addition,iftwo ğ‘˜-OAssharethesame ğ‘“value,wewillselecttheone
withfewerSCCs(orloops).Moreover,similartoregexsynthesis,
we use deterministic regexes to avoid ReDoS-vulnerabilities.
The repair algorithm is shown in Algorithm 3. It starts with a
deterministic ğ‘˜-OAAthatisconvertedfromthemarkedversion
ofthegivenregex ğ‘Ÿ(line1).Then,thealgorithmselects the ğ‘˜-OA
withthemaximum ğ‘“value,denotedas Amax,fromtheneighbor-
hoods of A(line 4). Next, it compares the ğ‘“values between the
currentğ‘˜-OA and the selected ğ‘˜-OA. If the selected ğ‘˜-OA gets a
higherğ‘“value, then the algorithm replaces the current ğ‘˜-OA by
the deterministic version of the selected ğ‘˜-OA (lines 5-6). After
that,itcheckswhetherthecurrent ğ‘˜-OAissatisfied,namely,the
ğ‘“value is 1. If it is, the algorithm returns a regex extracted from
the pruned version of the current ğ‘˜-OA (lines 7-10). While if the
selectedğ‘˜-OA gets a lower ğ‘“value, then the current ğ‘˜-OA may
bealocalmaximum,sothealgorithmreturns ğ‘›ğ‘¢ğ‘™ğ‘™5(line12).The
algorithm repeats the processing above until a satisfactory ğ‘˜-OA is
returnedortheiterationnumberexceedsITER_MAX(lines3-12).
Finally, the algorithm returns ğ‘›ğ‘¢ğ‘™ğ‘™if the iteration number exceeds
ITER_MAX (line 13).
Ağ‘˜-OAcanbeobtainedeasilyfromthemarkedform ğ‘Ÿofğ‘Ÿ:(i)
eachsymbolin ğ‘Ÿformsastateof ğ‘˜-OA;(ii)foreachsymbol ğ‘,there
is an edge from ğ‘to any symbol that follows ğ‘inğ‘Ÿ; (iii) there is an
edgefrom ğ‘ ğ‘Ÿğ‘toanysymbolthatmaybematchedfirstin ğ‘Ÿ,similar
5Enlarging the neighborhood is a possible but ineffective approach to search a better
solution.
664Algorithm 3: RepairingRE
Input:a regexğ‘Ÿ, a positive set ğ‘†+, a negative set ğ‘†âˆ’
Output:a deterministic regex ğ‘Ÿwithğ‘†+âŠ†ğ¿(ğ‘Ÿ)and
ğ‘†âˆ’âˆ©ğ¿(ğ‘Ÿ)=âˆ…if solvable or ğ‘›ğ‘¢ğ‘™ğ‘™otherwise
1Aâ†DISAMBIGUATE(RE2KOA( ğ‘Ÿ),ğ‘†+,ğ‘†âˆ’);
2ğ‘–â†0;
3whileğ‘–<ITER_MAX do
4Ağ‘šğ‘ğ‘¥â†arg max A/primeâˆˆğ‘(A)ğ‘“(A/prime,ğ‘†+,ğ‘†âˆ’);
5ifğ‘“(Ağ‘šğ‘ğ‘¥,ğ‘†+,ğ‘†âˆ’)>ğ‘“(A,ğ‘†+,ğ‘†âˆ’)then
6 Aâ†DISAMBIGUATE( Ağ‘šğ‘ğ‘¥,ğ‘†+,ğ‘†âˆ’);
7 ifğ‘“(A,ğ‘†+,ğ‘†âˆ’)==1then
8 Aâ†pruneAw.r.t.ğ‘†+andğ‘†âˆ’;
9 ğ‘Ÿâ†ğºğ‘’ğ‘›ğ‘…ğ‘’ğ‘”ğ‘’ğ‘¥ (A);
10 returnğ‘Ÿ;
11 ğ‘–â†ğ‘–+1;
12else return ğ‘›ğ‘¢ğ‘™ğ‘™;
13returnğ‘›ğ‘¢ğ‘™ğ‘™;
toğ‘ ğ‘–ğ‘›ğ‘˜. Then a deterministic version can be obtained by removing
the superfluous edges via the procedure DISAMBIGUATE given in
Algorithm 4.
Algorithm 4: DISAMBIGUATE
Input:ağ‘˜-OAA, a positive set ğ‘†+, a negative set ğ‘†âˆ’
Output:a deterministic ğ‘˜-OAA
1whileâˆƒğ‘ âˆˆA.ğ‘‰andğœâˆˆÎ£.|ğ‘œğ‘¢ğ‘¡(ğ‘£,ğœ)|>1do
2ğ¶â†âˆ…;
3forğ‘¡âˆˆğ‘œğ‘¢ğ‘¡(ğ‘£,ğœ)do
4 A/primeâ†A;
5 delete(ğ‘ ,ğ‘¡/prime)inA/primefor allğ‘¡/primeâˆˆğ‘œğ‘¢ğ‘¡(ğ‘£,ğœ)\{ğ‘¡};
6 addA/primeinğ¶;
7Aâ†arg max A/primeâˆˆğ¶ğ‘“(A/prime,ğ‘†+,ğ‘†âˆ’);
8returnA;
Note that character classes can be treated as special symbols
such that all (special) symbols are pairwise disjoint.
Inaddition,therepairalgorithmisincrementalaswell.Theuser
may think that if she keeps on repairing the regex with some more
interesting positive or negative examples, then she could finally
get the equivalent one that she wants. However, the fact is that
our neighborhood search may not find such a solution in a limited
number of iterations, if the given examples are too many or the
given regex is far away from a solution. Nevertheless, in that case,
we would strongly suggest the user to use the synthesis algorithm
instead.
6 EVALUATION
WeimplementedFlashRegexbasedonZ3[ 16]SMTsolverinPython,
and conducted experiments on a machine with 16 cores Intel Xeon
CPU E5620 @ 2.40GHz with 12MB Cache, 24GB RAM, running
Windows10operatingsystem.Ouropen-sourceimplementationTable 1: Benchmarks
Task Benchmark Number Sources Description
SynthesisBin-Syn-Rege x5 0AlphaRegexPublic [32] (25)
AutoTutor [13] (25)- Alphabet size is binary
Multi-Syn-Regex 50Regex Golf [17] (17)RegExLib [45] (33)- Alphabet size is large
Repair
(Incorrect)Pos-Rep-Regex 50 Rebele et al. [44] (50)- Incorrect regex- Positive examples only
Pos-Neg-Rep-Regex 2,129RegExLib [45] (25)AutoTutor [13] (2,104)- Incorrect regex- Positive and negative examples
Repair
(SL)SL-Regex2 0OWASP (3), StackOverflow (1)snyk (1), RegExLib [45] (3)Davis et al. [14] (3), CVE (9)- ReDoS-vulnerable regex- Positive and negative examples
andthedatasetsoftheexperimentsareavailableonline6.Theex-
periments were designed to study three sets of research questions
concerning FlashRegexâ€™s functionalities (i.e., synthesizing regexes,
repairing incorrect regexes, and repairing SL regexes).
RQ1.Evaluation of regex synthesis. Can FlashRegex synthe-
size regexes efficiently? (Â§6.2.1) Can FlashRegex synthesize
regexes from examples correctly? (Â§6.2.2) Can FlashRegex
synthesizesaferegexesthatarefreefromReDoS-vulnerabilities?
(Â§6.2.3)Canthelocalconstraintss peedupthe solutionpro-
cess? (Â§6.2.4)
RQ2.Evaluationofincorrectregexrepair. CanFlashRegexre-
pair incorrect regexes efficiently? (Â§6.3.1) Can FlashRegex
repair incorrect regexes from examples correctly? (Â§6.3.2)
CanFlashRegexrepairincorrectregexessothattheyarefree
from ReDoS-vulnerabilities? (Â§6.3.3)
RQ3.Evaluation of SL regex repair. CanFlashRegex repairSL
regexesefficiently?(Â§6.4.1)CanFlashRegexrepairSLregexes
from examplescorrectly? (Â§6.4.2) CanFlashRegex repair SL
regexessothattheyarefreefromReDoS-vulnerabilitiesafter
repair? (Â§6.4.3)
6.1 Benchmarks and Existing Tools
To evaluate FlashRegex in three application scenarios under dif-
ferentprerequisites,weconstructedtenseparatebenchmarksac-
cordingly, collectedfrom widely-usedsources: (i)Regex Golf[ 17],
(ii) AlphaRegexPublic [ 32], (iii) AutoTutor dataset [ 13], (iv) the
RegExLib library [ 45], (v) Rebele et al. [ 44], (vi) OWASP7, (vii)
StackOverflow8(viii) snyk9, (ix) Davis et al. [ 14], and (x) Common
Vulnerabilities and Exposures (CVE)10. Some information of them
is given in Table 1.
We compared FlashRegex with five state-of-the-art tools, GP-
RegexGolf [4],AlphaRegex [32],RegexGenerator++ [3,5],RFixer[39],
andtheonerecentlyproposedby Rebeleetal. [44].Amongthem,
GP-RegexGolf, AlphaRegex, and RegexGenerator++ were developed
for regex synthesis, while the remaining two for regex repair. Fur-
thermore, we used three tools to detect ReDoS-vulnerabilities, ReS-
cue[47],Rexploiter[ 59]andSDLFuzzer[ 53]andmanuallychecked
all inconsistent results concluded by these tools.
6https://github.com/EasyRegex/FlashRegex
7https://www.owasp.org/
8https://stackoverflow.com/
9https://snyk.io/blog/redos-and-catastrophic-backtracking/
10https://cve.mitre.org/
665Table 2: The effectiveness and efficiency of regex synthesis
Benchmarks Bin-Syn-Rege x Multi-Syn-Rege x
Technique #Sol(%) #CSol (%) #VulAvg.#Sol(% #CSol (%) #VulAvg.
Time(s) Time(s)
RegexGenerator++ - -- - 50(100%) 3 (6%) 0 198.0
GP-RegexGolf - -- - 50(100%) 7 (14%) 4 3889.6
AlphaRegex 50(100%) 50 (100%) 21 7.6 - -- -
FlashRegex-Exact 50(100%) 50 (100%) 0 3.3 38(76%) 38 (100%) 0 5.3
FlashRegex-LCS 36(72%) 36 (100%) 0 1.1 29(58%) 29 (100%) 0 3.4
FlashRegex 50(100%) 50 (100%) 0 1.9 38(76%) 38 (100%) 0 4.0
6.2 Evaluation of Regex Synthesis
In this experiment, we evaluated the effectiveness and efficiency of
regex synthesis, as well as its comparison with the exact-directed
(FlashRegex-Exact) and local-directed (FlashRegex-LCS) constraint
encodings. The evaluation results are shown in Table 2. The ex-
periments were conducted on two benchmarks, Bin-Syn-Regex and
Multi-Syn-Regex, measuring the performance on benchmarks with
different alphabet sizes. Columns in each benchmark represent the
number of synthesized regexes by each tool (#Sol), the number
of correctly synthesized ones by each tool (i.e., the ones that areconsistent with all the examples) (#CSol), the number of ReDoS-
vulnerableonesinthesynthesizedresults(#Vul)andtheaverage
time of synthesizing one regex in seconds (Avg Time), respectively.
Thesymbolâ€œ-â€indicatesthatthetooldoesnotsupportthecorre-
sponding benchmark functionally.
6.2.1EfficiencyofRegexSynthesis .Table2comparestherun-
time efficiency of FlashRegex with three synthesis tools by their
average time (in seconds) taken to synthesize a regex on the corre-
sponding benchmark. On benchmark Bin-Syn-Regex with binary
alphabetsize,thoughthedifferencesinaveragetimearesmall(rang-ingfrom1.1to7.6seconds),theaverageruntimeofFlashRegex(1.9
seconds)isstilllessthanhalfofthatofAlphaRegex(7.6seconds).
On benchmark Mul-Syn-Regex with multiple alphabet sizes, the
average time varies greatly, from one hour to few seconds. Note
that the time in Table 2 refers to average time, so the total running
time taken by RegexGenerator++ and GP-RegexGolf on this bench-
mark are more than 2 hours and 50 hours, respectively, which is
considered unaffordable in practice. In contrast, FlashRegex (using
eitherofthesynthesisalgorithms)onlytakesanaverage4seconds,
which is significantly more efficient than the other tools.
6.2.2Correctness of Regex Synthesis .Theresultsoncorrect-
nessaresummarizedbycolumn#CSolinTable2.Thecorrectnessof
synthesized regex is crucial. It guarantees the quality of regexes af-
tersynthesis.Theexperimentsshowthatthecorrectnessofexisting
toolsisunsatisfactory.WecanseethatthoughRegexGenerator++
and GP-RegexGolf can synthesize all the 50 regexes on the second
benchmark,only3and7ofthemarecorrect.Itismainlybecause
theyrequirethesynthesizedregextobeconsistentwithasmany
givenexamplesaspossible,insteadofalltheexamples.Bycontrast,
FlashRegex and AlphaRegex achieve 100% correctness ratio, be-
causetheyaimtofindaregexthatacceptsallthepositiveexamples
while rejecting all the negative examples.
Figure 5: 0*(1(0|1)?)*
 Figure 6: 0*(10?)*
6.2.3ReDoS-vulnerabilityofRegexSynthesis .Thetwo#Vul
columns in Table 2 show that 4 and 21 regexes synthesized by GP-
RegexGolf and AlphaRegex, respectively, are ReDoS-vulnerable.In other words, the consistency with given examples does notnecessarily guarantee the synthesized regexes free from ReDoS-
vulnerability.Incontrast,alltheregexessynthesizedbyFlashRegex
are ReDoS-invulnerable.
Letusgiveanexamplefrom Bin-Syn-Regex toillustratethediffer-
encebetweenReDoS-vulnerableandReDoS-invulnerableregexes.
Given the same set of positive and negative examples, AlphaRegex
synthesizes 0*(1(0|1)?)* ,whileFlashRegexsynthesizes 0*(10?)* .
Although the two regexes are equivalent, their evaluations take
exponential and linear time in the length of the input, respectively.
Let us consider therailroad diagrams of these two regexes, which
are given in Figures 5 and 6. Suppose the given string is â€œ11â€; there
are two possible paths in Figure 5 to generate this string, while
thereisonlyonepathinFigure6.Whenthegivenstringisâ€œ111â€,
there are four possible paths in Figure 5, whereas there is still one
possiblepathinFigure6.Thisillustrateshowthetwosearchspaces
differ as the length of the input increases.
6.2.4Evaluation of Different Constraint Encodings .Table 2
shows that FlashRegex-Exact is more effective than FlashRegex-
LCS in synthesizing significantly more regexes. On the other hand,
FlashRegex-LCSismoreefficientbyleveragingtheLCSheuristic
strategy.Thereare14(9)benchmarkson Bin-Syn-Regex (Multi-Syn-
Regex) that FlashRegex-Exact can solve while FlashRegex-LCS can-
not. FlashRegex-Exact is, on average, 2.0X slower than FlashRegex-
LCS onBin-Syn-Regex, and 0.6X slower on Multi-Syn-Regex. The
two constraint encodings are complementary on effectiveness and
efficiency.
SummarytoRQ1: FlashRegexcansynthesizeregexefficiently,
correctlyandsafely.TheadvantageofhighefficiencyofFlashRegexbecomesmoreobviouswiththeincreaseofthealphabetsize.Also,
the two constraint encodings of FlashRegex are complementary
oneffectivenessandefficiency.Theresultsalsoconfirmedthelack
of focus on ReDoS-vulnerability in previous works, thus making
further repair a necessity.
6.3 Evaluation of Incorrect Regex Repair
Table 5 shows the evaluation results of repairing incorrect regexes
in terms of efficiency, correctness and ReDoS-vulnerability. It uses
the same columns as Table 2. The experiments were conducted on
Pos-Rep-Regex andPos-Neg-Rep-Regex benchmarks.Forcomparison,
thetools proposedby Rebeleet al[ 44]and RFixerwere evaluated.
Notethattheregexesunderrepairintheevaluationareincorrect.
666Table 3: ReDoS-vulnerable Regexes Repaired by RFixer and FlashRegex. RV denotes ReDoS-vulnerable.
No. Source SL (Sub-)RegexRFixer FlashRegex
Repaired (Sub-)Regex Time (s) RV Repaired (Sub-)Regex Time (s) RV
#1OWASP (a|aa)+ (a|aa)+ 0.098 V a+ 0.596 I
#2 OWASP (a|a?)+ (a?)+ 0.133 I a* 0.028 I
#3 OWASP ([a-zA-Z]+)* ([a-zA-Z]+)* 0.057 V ([a-zA-Z])* 0.059 I
#4 StackOverflow (x+x+)+y (x+)+y 10.289 V xx+y 0.183 I
#5 snyk (\w+\d+)+C (\w+\d+)+C 0.176 V ([A-Za-z_]*\d)+C 0.058 I
#6 RegExLib (\d+(,\d+)*)+ (\d+(,\d+)*)+ 0.196 V \d+(,\d+)* 0.427 I
#7 RegExLib ([0-9a-f]+\d+)* ([0-9a-f]+\d+)* 0.204 V (([a-f]+\d)|\d)* 0.574 I
#8 RegExLib (\d+|(\d*\.\d+))+ (\d+|(\d*\.\d+))+ 0.158 V (\.?\d)+ 0.040 I
#9 Davis et al. [14] \s*#?\s* \s*#?\s* 0.139 V \s*(#\s*)? 0.249 I
#10 Davis et al. [14] (\n\s*)+ (\n\s*)+ 0.004 V \n\s* 0.052 I
#11 Davis et al. [14] [$_a-z]+[$_a-z0-9-]* [$_a-z]+[$_a-z0-9-]* 0.003 V [$_a-z][$_a-z0-9-]* 0.061 I
#12 CVE-2009-3277 ((a{1,2}){1,2}){1,10} ((a{1,2}){1,2}){1,10} 15.763 V a{1,40} 8.555 I
#13 CVE-2016-4055 A(B|C+)+D A(B+|C+)+D 0.162 V A(B|C)+D 0.063 I
#14 CVE-2017-15010 ([^=;]+)\s*=\s*([^\n\r\0]*) ([^=;\s]+)\s*=\s*([^\s\0]*) 31.534 I ([^=;\s]+)\s*=\s*([^\s\0]*) 5.484 I
#15 CVE-2017-16098 \s*=\s*['"]? *([\w\-]+) \s*=\s*['"]? *([\w\-]+) 3.218 V \s*=\s*(['"] *)?([\w\-]+) 20.125 I
#16 CVE-2017-16137 \s*\n\s* [ \f\r\t\v]*\n\s* 0.368 I [ \f\r\t\v]*\n\s* 0.543 I
#17 CVE-2017-18214 (\s*?[\u0600-\u06FF]+){1,2} (\s*?[\u0600-\u06FF]+){1,2} 3.270 V \s*[\u0600-\u06FF]+(\s+[\u0600-\u06FF]+)? 23.074 I
#18 CVE-2018-3737 ([\n \t]+([^\n]+))? ([\n \t]+([^\n]+))? 183.469 V ([\n \t]+([^\n \t]+))? 0.375 I
#19 CVE-2019-17592 (\-|\+)?([1-9]+[0-9]*) (\-|\+)?([1-9]+[0-9]*) 15.936 V (\-|\+)?[1-9]\d* 4.305 I
#20 CVE-2020-5243 *([^;]+) * *([^; ]+) * 1.406 I *([^; ]+) * 2.102 I
Table 4: ReDoS-vulnerable Regexes Repaired by Experts and FlashRegex. RV denotes ReDoS-vulnerable.
Source SL RegexExpert FlashRegex
Strategy Fix Solution RV Strategy Fix Solution RV
CVE-2016-4055 A(B|C+)+D Revise A(?=(B|C+))\1+D I Revise A(B|C)+D I
CVE-2017-15010 ([^=;]+)\s*=\s*([^\n\r\0]*) Revise (([^=;]+))\s{0,512}=\s*([^\n\r\0]*) V Revise ([^=;\s]+)\s*=\s*([^\s\0]*) I
CVE-2017-16098 \s*=\s*['"]? *([\w\-]+) Trim limit match string, only allow max 10
spaces and 100 charset string- Revise \s*=\s*(['"] *)?([\w\-]+) I
CVE-2017-16137 \s*\n\s* Resort (i)splitthelinebyâ€™ \nâ€™,and(ii)trimeach
line, (iii) then join each line by â€™ â€™- Revise [ \f\r\t\v]*\n\s* I
CVE-2017-18214 (\s*?[\u0600-\u06FF]+){1,2} Revise (\s*?[\u0600-\u06FF]{1,256}){1,2} V Revise \s*[\u0600-\u06FF]+(\s+[\u0600-\u06FF]+)? I
CVE-2018-3737 ([\n \t]+([^\n]+))? Revise ([\n \t]+([^\n \t][^\n]*))? I Revise ([\n \t]+([^\n \t]+))? I
CVE-2019-17592 (\-|\+)?([1-9]+[0-9]*) Revise (\-|\+)?[1-9][0-9]* I Revise (\-|\+)?[1-9]\d* I
CVE-2020-5243 *([^;]+) * Revise {0,2}([^;]+) {0,2} I Revise *([^; ]+) * I
They either reject some positive examples or accept some negative
ones.
Table 5: The effectiveness and efficiency of incorrect regex
repair
Benchmarks Pos-Rep-Rege x Pos-Neg-Rep-Rege x
Technique #Sol(%) #CSol (%) #VulAvg.#Sol(% #CSol (%) #VulAvg.
Time(s) Time(s)
Rebele et al [44] 50(100%) 50 (100%) 0 0.2 - -- -
RFixer 35(70%) 35 (100%) 3 2.4 1,611(75.67%) 1,611 (100%) 349 9.3
FlashRegex 35(70%) 35 (100%) 0 1.5 1,948(91.50%) 1,948 (100%) 0 1.66.3.1EfficiencyofIncorrectRegexRepair .Thetoolproposed
by Rebele et al. [ 44] ran the fastest (0.2 seconds) on the first bench-
mark (i.e., the one from the tool), but it cannot handle negative ex-
amples. RFixer took the longest average time on both benchmarks.
Ittookmuchmoreaveragetimeonthegivennegativeexamples.In
constrast,theefficiencyofFlashRegexwasmildlyaffectedbythe
negative samples.The averagetime it tookincreased mildlyfrom
1.5 to 1.6 seconds.
6.3.2Correctness of Incorrect Regex Repair .Table 5 shows
thatthetoolproposedbyRebeleetal.[ 44]canrepairthemostnum-
ber of regexes on the first benchmark, but it is not able to process
any negativeexamples on thesecond benchmark. FlashRegexcan
repair 91.5% of the incorrect regexes, 337 (15.83%) more regexes
than those repaired by RFixer, on the second benchmark.
6676.3.3ReDoS-vulnerabilityofIncorrectRegexRepair .Accord-
ing to the #Vul coulmn in Table 5, three (8.57%) ReDoS-vulnerable
regexes were generated by RFixer on the first benchmark. The
number increases significantly on the second benchmark. There
were 349 (21.66%) regexes repaired by RFixer suffered from ReDoS-
vulnerability.Incontrast,FlashRegexcanrepair337moreregexes
than RFixer with no ReDoS-vulnerable regexes generated.
Letuspresentafewincorrectregexestoillustratethevulnerable
and invulnerable repairs. From Pos-Neg-Rep-Regex, for the incor-
rectregex (((0+1*)*0+)*|((1+0*)*1+)*)* ,arepairedregexpro-
ducedbyRFixeris (0(0*|1+0)*)|(1(1*|0+1)*) ,whichisReDos-
vulnerable. Wecan seethat althoughthis regex isconsistent with
the given examples, it still causes ambiguity because its star height
(i.e.,nestedquantifiers)equalstotwo.Forexample,thestringâ€œ0â€
can be either consumed by the inner quantifier (*) or the outer
one(*),leadingtoincorrectbehaviorwithworst-caseexponential
costs on a mismatch. In contrast, FlashRegex deduced the regex
((01?)+|(10*)+) , which successfully avoids the security issue.
SimilarincorrectonesrepairedbyRFixerhavealsobeenfoundfrom
Pos-Rep-Regex, they are (([1234567,] [1234568,]|[79,]))*\d
and(([a-z]|[A-Z])? [AegikLloPr3tuVwX ])+(\d+\.?)+ .Both
are ReDoS-vulnerable.
Summary to RQ2: FlashRegex can repair incorrect regex effi-
ciently,correctlyandsafely.Theefficiencyisnotaffectedsignif-
icantly by negative examples, and the regex after repair is free
from ReDoS-vulnerability.
6.4 Evaluation of SL Regex Repair
The evaluation results of SL regex repair are shown in Table 3.
We compared FlashRegex with RFixer, which is designed to repair
regexes from both positive and negative examples. The benchmark
contains20SLregexes(listedinTable3)withpositiveandnegative
examples. Due to the space constraint, we only show the problem-
aticsub-regexesforsomeregexes.Examplescorrespondingtothese
(sub-)regexesaregeneratedmanuallyorbasedontheBricsautoma-
ton library [ 37]. Specifically, the positive examples are enumerated
byrandomlytraversingthedeterministicfiniteautomaton(DFA)
of the given regex (resp. the negative examples are synthesized
bystochasticallytraversingtheDFAofthenegationofthegiven
regex).Thecolumnsinthetablerepresentthesourcesofeachregex
(Source), the ReDoS-vulnerable regex (SL (Sub)-Regex); columns in
RFixerandFlashRegexaretheregexrepairedbythecorresponding
tools(Repaired(Sub-)Regex),therunningtimeinseconds(Time)
and whether the repaired regexes are ReDoS-vulnerable (RV) ( ğ‘‰
for vulnerable, ğ¼for invulnerable).
6.4.1EfficiencyofSLRegexRepair .Theaveragerunningtime
takenforrepairingvariesacrossregexes.RFixertookfromlessthan
0.057 to 183 seconds, and 13.329 seconds on average. FlashRegex
offersamorestableandbetterefficiency,rangingfrom0.04to23.074
seconds, and 3.348 seconds on average.
6.4.2Correctness of SL Regex Repair .In Table 3, all the re-
paired regexes are consistent with the given examples. This sug-
gests the correctness of both tools. The results are also in line with
the results of repairing incorrect regexes in Table 5.6.4.3ReDoS-vulnerability of SL Regex Repair .According to
Table 3, 16/20 (80%) regexes repaired by RFixer are still vulnera-
ble to ReDoS attacks. In constrast, all the SL regexes repaired by
FlashRegex are free from ReDoS-vulnerabilities.
We further compared the results repaired by FlashRegex with
theresultsachievedbydeveloperexperts,whicharegiveninTa-ble 4
11. We found that experts repaired SL regexes using one of
three strategies introduced by Davis et al. [14]: revising the regex,
trimming the input, or resorting it to alternate logic. The first one
ismotivatedbutnoteasytodoitmanually,asdemonstratedbythe
results, 2/6 (33%) regexes repaired by experts are still vulnerable to
ReDoS attacks, and the invulnerable ones may be difficult for users
tofollow(e.g.,thefirstoneusingback-referenceandthelastone
usingboundediteration).Incontrast,alltheSLregexesrepairedby
FlashRegex are free from ReDoS-vulnerabilities. The second one
works well but is not friendly to users, while the last one is only
effective for some special regexes (i.e., it cannot be generalized).
Summary to RQ3: FlashRegex can repair ReDoS-vulnerable
regex efficiently and correctly. The experiment also indicates
the incapability of existing work for repairing ReDoS-vulnerable
regex. Further, comparing with the manual repair, FlashRegex
worksinan automatic anduser-friendlymanner,keepingusersâ€™
intention meanwhile getting rid of the ReDoS-vulnerability.
7 THREATS TO FLASHREGEXâ€™S VALIDITY
Considering that FlashRegex is aprogramming-by-example (PBE)
algorithm,thequalityofregexsynthesizedbyFlashRegexhighly
dependsonthequalityofexamples.Inotherwords,ifuserscannot
provide sufficient characteristic examples, the synthesized regexes
willbeunsatisfactory(i.e.,over-fittingorunder-fitting).Toalleviate
this problem, we can adopt the following three strategies:
Generalizedexamples.Theusersprovidesomeabstractgeneral-
izedexamples ratherthanconcreteexamples.The generalizedex-
amples can reduce the amount of required concrete (characteristic)
examplesmeanwhilelesseningtheworkloadfromusers,thereby
improving the quality of regex synthesis by generalizing concrete
examples.Forinstance,Wecanuseageneralizedexample <NUM>dog
instead of concrete examples (e.g., 1dog,2dog,3dog).
Integration of PBE and programming by natural language (PBNL).
WecanleveragePBNLtechniquestoovercomethedrawbacksof
PBEtechniques.Specifically,incorporatingnaturallanguagecan
greatlyimprovethegeneralizationofPBEtechniques.Forexample,
we can use the natural language description â€œlines with vowels
after lower-case lettersâ€ as a major resource, and some concrete
example(e.g., biiiiandcee)insteadofalargenumberofconcrete
examples.
Interactionwithusers.Amoreuser-friendlystrategyisthatwhen-
ever the generated regex is out of expectation of users, they can
add/delete/updateexamplesinteractivelysothattheresultingregex
can be adjusted dynamically until meet usersâ€™ requirements.
11Due to space constraint, only solutions from CVE are given.
6688 RELATED WORK
Programming-by-Example (PBE). PBE techniques have been
the subject of research in the past few decades [ 46] and successful
paradigms for program synthesis, allowing end-users to construct
and run new programs by providing examples of the intended pro-
grambehavior[ 18].Recently,PBEtechniqueshavebeensuccess-
fullyusedforstringtransformations[ 27,48,49],datafiltering[ 57],
datastructuremanipulations[ 22,60],tabletransformations[ 20,28],
SQLqueries[ 56,62],MapReduceprograms[ 1,50],andalsoregex
synthesis[ 3â€“5,7,8,21,24,32,34].Inthispaper,wetakeadvantage
ofPBEtechniquestoenhanceuser-friendlinessbyallowingusers
to provide examples to reflect their true intentions.
ReDoSDetectionandPrevention. Varioustechniqueshavebeen
proposed[ 30,41â€“43,47,52,53,58,59]toidentifyReDoS-vulnerabilities,
which can be mainly classified into two paradigms: static analy-
sis [30, 42, 43, 52, 58, 59] and dynamic fuzzing [41, 47, 53].
To prevent ReDoS attacks, Davis et al. [ 14] identified three
anti-patterns of regexes as prerequisites of ReDoS attacks andrecommended avoiding using them. These anti-patterns include:
(i) regexes with nested quantifiers (e.g.,
A(B|C+)+D ); (ii) Regexes
withQuantifiedOverlappingDisjunction(QOD) (e.g.,(\ğ‘¤|\ğ‘‘)+);and
(iii) Regexes with Quantified Overlapping Adjacency (QOA) (e.g.,
\s*#?\s* ).Inourwork,weadoptdeterministic ğ‘˜-OAanddeter-
ministicregexconstraintstoavoidtheambiguitycausedbyQODorQOAinFlashRegexalgorithms,andsearchingforsolutionsstarting
fromğ‘˜=1 can effectively avoid nested quantifiers.
ReDoSattackscanalsobealleviatedbyregexmatchingspeedup,
whichispossibleinsomespecialcases,e.g.,byparallelalgorithms[ 35],
GPU-basedalgorithms[ 61],state-mergingalgorithms[ 6],andThomp-
sonâ€™sNon-deterministicFiniteAutomatonalgorithm[ 12,54].How-
ever, these can only alleviate the ReDoS-vulnerability problem,
sincetheregexesthemselvesarestillsubjecttoReDoSattacks.In
our work, we address this issue from the regexes side.Regexes Synthesis.
The problem of automatic regex synthesis
fromexampleshasbeenexploredinmanydomains[ 3â€“5,7,8,21,
24,31,32,34,36,40,63]. AlphaRegex [ 32] is an enumeration al-
gorithm for synthesizing simple regexes over binary alphabets
from examples. However, all the synthesized expressions are over
alphabets of size 2. RegexGenerator++ [3,5] is a state-of-the-art
approach for the synthesis of regexes from examples. The fact that
RegexGenerator++ utilizes genetic programming means that it is
not guaranteed to generate a correct solutionâ€“i.e., accepting all the
positiveexampleswhilerejectingallthenegativeexamples.Lotsof
existingworksfocusonXMLschemasinference[ 7,8,21,24,34],
via resorting to infer regexes from examples. These approaches
usuallyaimtotacklerestrictedformsof deterministic regexes[9]
frompositiveexamplesonly. GP-RegexGolf [4]isanapproachbased
on genetic programming for playing regex golf [17] automatically,
i.e., for writing the shortest regex that matches all positive strings
and does not match any negative string. Unlike many of these
efforts which aim to generalize beyond the provided examples, GP-
RegexGolf focuses on binary classifying input strings and it does
notrequireaformofgeneralization, i.e.,theabilityofinducinga
generalpatternfromtheprovidedexamples.Severalworksfrom
the Natural Language Processing community address the problemofgeneratingregexesfromnaturallanguagespecificationsbased
on sequence-to-sequence (seq2seq) model [31, 36, 40, 63].
All of the synthesis techniques above barely pay attention to
preventing ReDoS during the synthesis process, making the syn-
thesized regexes (hyper-)vulnerable to ReDoS attacks.RegexesRepair.
Thereareseveralworkstargetingatrepairingor
modifyingregexesfromexamples,specificallytheincorrectregexes.
We discuss two main paradigms of them. In the first paradigm,
works only consider either positive or negative examples. Li et
al. [33] proposed ReLIE, which can modify complex regexes by
rejectingthenewly-inputnegativeexamples.Bycontrast,Rebele
et al. [44] proposed a novel way to generalize a given regex so that
itacceptsthegivenpositiveexamples.Ontheotherhand,works
in thesecond paradigmtake bothpositive and negativeexamples
into consideration. Pan et al. [ 39] designed RFixer, a tool for repair-
ing incorrect regexes using both examples. It took advantage of
skeletons of regexes to effectively prune out the search space, and
itemployedSMTsolverstoefficientlyexplorethesetsofpossible
character classes and numerical quantifiers. Our work is similarto their work, yet differs in the effectiveness and quality of re-
pairedregexesâ€”weconsidernotonlythecorrectness,butalsothe
ReDoS-invulnerability of the regexes.
ThereisonlytwoworkexploringhowtorepairReDoS-vulnerable
regexes [ 11,55], which considers revisions that match the exact
same languages of the original regexes. However, the (exact) equiv-
alence is too strong to use in practice [14, 47].
9 CONCLUSION
Manytechniquesforsynthesizingorrepairingregexeshavebeen
proposed. However, the lack of attention to ReDoS-vulnerabilities
affects the security of existing tools. We propose a PBE framework,
FlashRegex, which provides three core functionalities including
regex synthesis, incorrect regex repair, and ReDoS-vulnerable (i.e.,
SL)regexrepair.Thisisachievedbydevisingnovelalgorithmsto
deducedeterministicregexesfrombothpositiveandnegativeexam-plesbasedonSATorNS.Oursisthefirstframeworkthatintegrates
thesynthesisandrepairofregexeswiththeawarenessofReDoS-
vulnerabilities. The evaluation results show that our work can
effectively and efficiently generate anti-ReDoS regexes from given
examples,andhasbettercapabilitythanexistingrepairtoolsand
evenhumanexpertsonReDoS-vulnerableregexrepair, demonstrat-ingtheusefulnessofourwork.The resultsalsorev ealthatexisting
synthesis and repair tools have neglected ReDoS-vulnerabilities of
regexes. Although ourexperiments haveshown theeffectiveness
andefficiencyofFlahsRegex,weplantoconductalargerscaleof
evaluation with more complex subjects in our future work.
ACKNOWLEDGMENT
The authors would like to thank the anonymous reviewers for
their comments and suggestions. This work is supported in part by
NationalNaturalScienceFoundationofChina(Grants#61872339,
#61472405,#61932021,#61972260,#61772347,#61836005),NSFgrant
IIS-1633271, Guangdong Basic and Applied Basic Research Founda-
tion under Grant #2019A1515011577, and Huawei PhD Fellowship,
MSRA Collaborative Research Grant.
669REFERENCES
[1]Maaz Bin Safeer Ahmad and Alvin Cheung. 2016. Leveraging Parallel Data
ProcessingFrameworksWithVerifiedLifting.In ProceedingsFifth Workshopon
Synthesis, SYNT@CAV 2016, Toronto, Canada, July 17-18, 2016. 67â€“83.
[2]Adam Baldwin. 2016. Regular Expression Denial Of Service Affecting Express.js.
https://medium.com/node-security/
[3]Alberto Bartoli, Giorgio Davanzo, Andrea De Lorenzo, Eric Medvet, and Enrico
Sorio. 2014. Automatic Synthesis Of Regular Expressions From Examples. IEEE
Computer 47, 12 (2014), 72â€“80.
[4]Alberto Bartoli, Andrea De Lorenzo, Eric Medvet, and Fabiano Tarlao. 2014.
Playing Regex Golf With Genetic Programming. In Genetic and Evolutionary
Computation Conference, GECCO â€™14, Vancouver, BC, Canada, July 12-16, 2014.
1063â€“1070.
[5]Alberto Bartoli, Andrea De Lorenzo, Eric Medvet, and Fabiano Tarlao. 2016.Inference Of Regular Expressions For Text Extraction From Examples. IEEE
Trans. Knowl. Data Eng. 28, 5 (2016), 1217â€“1230.
[6]Michela Becchi and Srihari Cadambi. 2007. Memory-Efficient Regular Expres-sion Search Using State Merging. In INFOCOM 2007. 26th IEEE International
Conference on Computer Communications, Joint Conference of the IEEE Computer
and Communications Societies, 6-12 May 2007, Anchorage, Alaska, USA. IEEE,
1064â€“1072.
[7]Geert Jan Bex, Wouter Gelade, Frank Neven, and Stijn Vansummeren. 2010.
LearningDeterministicRegularExpressionsForTheInferenceOfSchemasFrom
XML Data. TWEB4, 4 (2010), 14:1â€“14:32.
[8]Geert Jan Bex, Frank Neven, Thomas Schwentick, and Stijn Vansummeren. 2010.
InferenceOfConciseRegularExpressionsAndDTDs. ACMTrans.DatabaseSyst.
35, 2 (2010), 11:1â€“11:47.
[9]Anne BrÃ¼ggemann-Klein. 1993. Unambiguity Of Extended Regular Expressions
InSGMLDocumentGrammars.In Algorithms-ESAâ€™93,FirstAnnualEuropean
Symposium, Bad Honnef, Germany, September 30 - October 2, 1993, Proceedings.
73â€“84.
[10]Carl Chapman, Peipei Wang, and Kathryn T. Stolee. 2017. Exploring Regular
ExpressionComprehension.In Proceedingsofthe32ndIEEE/ACMInternational
ConferenceonAutomatedSoftwareEngineering,ASE2017,Urbana,IL,USA,October
30 - November 03, 2017. 405â€“416.
[11]Brendan Cody-Kenny, Michael Fenton, Adrian Ronayne, Eoghan Considine,
Thomas McGuire, and Michael Oâ€™Neill. 2017. A Search For Improved Perfor-
mance In Regular Expressions. In Proceedings of the Genetic and Evolutionary
ComputationConference,GECCO2017,Berlin,Germany,July15-19,2017 .1280â€“
1287.
[12]RussCox.2007.RegularExpressionMatchingCanBeSimpleAndFast(ButIsSlowInJava,Perl,PHP,Python,Ruby,...). https://swtch.com/~rsc/regexp/regexp1.html
[13]LorisDâ€™Antoni,RishabhSingh,andMichaelVaughn.2017. NoFAQ:Synthesizing
Command Repairs From Examples. In Proceedings of the 2017 11th Joint Meeting
on Foundations of Software Engineering, ESEC/FSE 2017, Paderborn, Germany,
September 4-8, 2017. 582â€“592.
[14]James C. Davis, Christy A. Coghlan, Francisco Servant, and Dongyoon Lee. 2018.
The Impact Of Regular Expression Denial Of Service (ReDoS) In Practice: An
EmpiricalStudyAtTheEcosystemScale.In Proceedingsofthe2018ACMJoint
Meeting on European Software Engineering Conference and Symposium on the
FoundationsofSoftwareEngineering,ESEC/SIGSOFTFSE2018,LakeBuenaVista,
FL, USA, November 04-09, 2018. 246â€“256.
[15]James C. Davis, Louis G. Michael IV, Christy A. Coghlan, Francisco Servant,and Dongyoon Lee. 2019. Why Arenâ€™t Regular Expressions A Lingua Franca?
AnEmpiricalStudyOnTheRe-UseAnd PortabilityOfRegularExpressions.In
ProceedingsoftheACMJointMeetingonEuropeanSoftwareEngineeringConference
andSymposiumontheFoundationsofSoftwareEngineering,ESEC/SIGSOFTFSE
2019, Tallinn, Estonia, August 26-30, 2019. 443â€“454.
[16]Leonardo MendonÃ§a de Moura and Nikolaj BjÃ¸rner. 2008. Z3: An Efficient SMT
Solver. In Tools and Algorithms for the Construction and Analysis of Systems,
14th International Conference, TACAS 2008, Held as Part of the Joint European
Conferences on Theory and Practiceof Software, ETAPS 2008,Budapest, Hungary,
March 29-April 6, 2008. Proceedings. 337â€“340.
[17] Erling Ellingsen. 2019. Regex Golf. https://alf.nu/RegexGolf[18]
KevinEllisandSumitGulwani.2017.LearningToLearnProgramsFromExamples:GoingBeyondProgramStructure.In ProceedingsoftheTwenty-SixthInternational
JointConferenceonArtificialIntelligence,IJCAI2017,Melbourne,Australia,August
19-25, 2017. 1638â€“1645.
[19]Stack Exchange. 2016. Outage Postmortem. http://stackstatus.net/post/
147710624694/outage-postmortem-july-20-2016
[20]Yu Feng, Ruben Martins, Jacob Van Geffen, Isil Dillig, and Swarat Chaudhuri.
2017. Component-Based Synthesis Of Table Consolidation And Transformation
Tasks From Examples. In Proceedings of the 38th ACM SIGPLAN Conference on
Programming Language Design and Implementation, PLDI 2017, Barcelona, Spain,
June 18-23, 2017. 422â€“436.
[21]Henning Fernau. 2009. Algorithms For Learning Regular Expressions From
Positive Data. Inf. Comput. 207, 4 (2009), 521â€“541.[22]John K. Feser, Swarat Chaudhuri,and Isil Dillig. 2015. Synthesizing Data Struc-
ture Transformations From Input-Output Examples. In Proceedings of the 36th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation,
Portland, OR, USA, June 15-17, 2015. 229â€“239.
[23]Python Software Foundation. 2018. PyPIâ€“The Python Package Index. https:
//pypi.org/
[24]Dominik D. Freydenberger and Timo KÃ¶tzing. 2015. Fast Learning Of Restricted
Regular Expressions And DTDs. Theory Comput. Syst. 57, 4 (2015), 1114â€“1158.
[25] E. MarkGold.1978. ComplexityOfAutomatonIdentificationFrom GivenData.
Information and Control 37, 3 (1978), 302â€“320.
[26]BenoÃ®t Groz and Sebastian Maneth. 2017. Efficient Testing And Matching Of
Deterministic Regular Expressions. J. Comput. Syst. Sci. 89 (2017), 372â€“399.
[27]SumitGulwani.2011. AutomatingStringProcessingInSpreadsheetsUsingInput-
Output Examples. In Proceedings of the 38th ACM SIGPLAN-SIGACT Symposium
onPrinciplesofProgrammingLanguages,POPL2011,Austin,TX,USA,January
26-28, 2011. 317â€“330.
[28]William R. Harris and Sumit Gulwani. 2011. Spreadsheet Table Transformations
FromExamples.In Proceedingsofthe32ndACMSIGPLANConferenceonProgram-
mingLanguageDesignandImplementation,PLDI2011,SanJose,CA,USA,June
4-8, 2011. 317â€“328.
[29]LouisG.Michael IV,JamesDonohue,James C.Davis,DongyoonLee,and Fran-
cisco Servant. 2019. Regexes Are Hard: Decision-Making, Difficulties, And Risks
InProgrammingRegularExpressions.In 34thIEEE/ACMInternationalConference
on Automated Software Engineering, ASE 2019, San Diego, CA, USA, November
11-15, 2019. 415â€“426.
[30]James Kirrage, Asiri Rathnayake, and Hayo Thielecke. 2013. Static Analysis For
RegularExpression Denial-of-ServiceAttacks.In Networkand SystemSecurity-
7th International Conference, NSS 2013, Madrid, Spain, June 3-4, 2013. Proceedings.
135â€“148.
[31]NateKushmanandReginaBarzilay.2013.UsingSemanticUnificationToGenerate
Regular ExpressionsFromNatural Language.In Human LanguageTechnologies:
Conference of the North American Chapter of the Association of ComputationalLinguistics, Proceedings, June 9-14, 2013, Westin Peachtree Plaza Hotel, Atlanta,
Georgia, USA. 826â€“836.
[32]Mina Lee, Sunbeom So, and Hakjoo Oh. 2016. Synthesizing Regular Expressions
FromExamplesForIntroductoryAutomataAssignments.In Proceedingsofthe
2016ACMSIGPLANInternationalConferenceonGenerativeProgramming:Concepts
and Experiences, GPCE 2016, Amsterdam, The Netherlands, October 31 - November
1, 2016. 70â€“80.
[33]Yunyao Li, Rajasekar Krishnamurthy, Sriram Raghavan, Shivakumar
Vaithyanathan, and H. V. Jagadish. 2008. Regular Expression Learning
For Information Extraction. In 2008 Conference on Empirical Methods in Natural
LanguageProcessing,EMNLP2008,ProceedingsoftheConference,25-27October
2008, Honolulu, Hawaii, USA, A meeting of SIGDAT, a Special Interest Group of the
ACL. 21â€“30.
[34]Yeting Li, Xiaolan Zhang, Jialun Cao, Haiming Chen, and Chong Gao. 2019.Learning K-Occurrence Regular Expressions With Interleaving. In Database
Systems for Advanced Applications - 24th International Conference, DASFAA 2019,
Chiang Mai, Thailand, April 22-25, 2019, Proceedings, Part II. 70â€“85.
[35]Cheng-Hung Lin, Chen-Hsiung Liu, and Shih-Chieh Chang. 2011. Accelerating
Regular Expression Matching Using Hierarchical Parallel Machines On GPU.
InProceedingsoftheGlobalCommunicationsConference,GLOBECOM2011,5-9
December 2011, Houston, Texas, USA. IEEE, 1â€“5.
[36]NicholasLocascio,KarthikNarasimhan,EduardoDeLeon,NateKushman,and
Regina Barzilay. 2016. Neural Generation Of Regular Expressions From Natural
LanguageWithMinimalDomainKnowledge.In Proceedingsofthe2016Conference
on Empirical Methods in Natural Language Processing, EMNLP 2016, Austin, Texas,
USA, November 1-4, 2016. 1918â€“1923.
[37]AndersMÃ¸ller.2017. dk.brics.automatonâ€“Finite-StateAutomataandRegular
Expressions for Java. https://www.brics.dk/automaton/
[38] Inc. NPM. 2018. NPM. https://www.npmjs.com/[39]
Rong Pan, Qinheping Hu, Gaowei Xu, and Loris Dâ€™Antoni. 2019. Automatic
Repair Of Regular Expressions. PACMPL 3, OOPSLA (2019), 139:1â€“139:29.
[40]Jun-U. Park, Sang-Ki Ko, Marco Cognetta, and Yo-Sub Han. 2019. SoftRegex:
GeneratingRegexFromNaturalLanguageDescriptionsUsingSoftenedRegex
Equivalence. In Proceedings of the 2019 Conference on Empirical Methods in Nat-
uralLanguage Processingandthe 9thInternationalJoint ConferenceonNatural
LanguageProcessing,EMNLP-IJCNLP2019,HongKong,China,November3-7,2019.
6424â€“6430.
[41]TheofilosPetsios,JasonZhao,AngelosD.Keromytis,andSumanJana.2017. Slow-
Fuzz: Automated Domain-Independent Detection Of Algorithmic Complexity
Vulnerabilities. In Proceedings of the 2017 ACM SIGSAC Conference on Computer
and Communications Security, CCS 2017, Dallas, TX, USA, October 30 - November
03, 2017. 2155â€“2168.
[42]AsiriRathnayake.2015. Semantics,AnalysisAndSecurityOfBacktrackingRegular
Expression Matchers. Ph.D. Dissertation. University of Birmingham, UK.
[43]Asiri Rathnayake and Hayo Thielecke. 2014. Static Analysis For Regular Ex-pression Exponential Runtime Via Substructural Logics. CoRRabs/1405.7058
670(2014).
[44]ThomasRebele,KaterinaTzompanaki,andFabianM.Suchanek.2018. Adding
Missing Words To Regular Expressions. In Advances in Knowledge Discovery
and Data Mining - 22nd Pacific-Asia Conference, PAKDD 2018, Melbourne, VIC,
Australia, June 3-6, 2018, Proceedings, Part II. 67â€“79.
[45] RegExLib. 2019. Regular Expression Library. http://regexlib.com/
[46]David E. Shaw, William R. Swartout, and C. Cordell Green. 1975. Inferring LISP
Programs From Examples. In Advance Papers of the Fourth International Joint
Conference on Artificial Intelligence, Tbilisi, Georgia, USSR, September 3-8, 1975.
260â€“267.
[47]Yuju Shen, Yanyan Jiang, Chang Xu, Ping Yu, Xiaoxing Ma, and Jian Lu. 2018.ReScue: Crafting Regular Expression DoS Attacks. In Proceedings of the 33rd
ACM/IEEEInternationalConferenceonAutomatedSoftwareEngineering,ASE2018,
Montpellier, France, September 3-7, 2018. 225â€“235.
[48]Rishabh Singh.2016. BlinkFill:Semi-Supervised Programming ByExample For
Syntactic String Transformations. PVLDB9, 10 (2016), 816â€“827.
[49]Rishabh Singh and Sumit Gulwani. 2012. Learning Semantic String Transforma-
tions From Examples. PVLDB5, 8 (2012), 740â€“751.
[50]CalvinSmithandAwsAlbarghouthi.2016. MapReduceProgramSynthesis.In
Proceedings of the 37th ACM SIGPLAN Conference on Programming Language
Design and Implementation, PLDI 2016, Santa Barbara, CA, USA, June 13-17, 2016.
326â€“340.
[51]Eric Spishak, Werner Dietl, and Michael D. Ernst. 2012. A Type System For
RegularExpressions.In Proceedingsofthe14thWorkshoponFormalTechniques
for Java-like Programs, FTfJP 2012, Beijing, China, June 12, 2012. 20â€“26.
[52]SatoshiSugiyamaandYasuhikoMinamide.2014. CheckingTimeLinearityOf
Regular Expression Matching Based On Backtracking. Information and Media
Technologies 9, 3 (2014), 222â€“232.
[53]BryanSullivan.2010. NewTool:SDLRegexFuzzer. https://cloudblogs.microsoft.
com/microsoftsecure/2010/10/12/new-tool-sdl-regex-fuzzer
[54]Ken Thompson. 1968. Regular Expression Search Algorithm. Commun. ACM 11,
6 (1968), 419â€“422.
[55]Brink van der Merwe, Nicolaas Weideman, and Martin Berglund. 2017. Turning
Evil Regexes Harmless. In Proceedings of the South African Institute of Computer
Scientists and Information Technologists, SAICSIT 2017, Thaba Nchu, South Africa,
September 26-28, 2017. 38:1â€“38:10.[56]ChenglongWang,AlvinCheung,andRastislavBodÃ­k.2017. SynthesizingHighly
Expressive SQL Queries From Input-Output Examples. In Proceedings of the 38th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation,
PLDI 2017, Barcelona, Spain, June 18-23, 2017. 452â€“466.
[57]Xinyu Wang, Sumit Gulwani, and Rishabh Singh. 2016. FIDEX: Filtering Spread-
sheetDataUsingExamples.In Proceedingsofthe2016ACMSIGPLANInternational
Conference on Object-Oriented Programming, Systems, Languages, and Applica-
tions,OOPSLA2016,partofSPLASH2016,Amsterdam,TheNetherlands,October
30 - November 4, 2016. 195â€“213.
[58]Nicolaas Weideman, Brink van der Merwe, Martin Berglund, and Bruce W. Wat-
son. 2016. Analyzing Matching Time Behavior Of Backtracking Regular Expres-
sionMatchers ByUsing AmbiguityOf NFA. In Implementationand Application
ofAutomata-21stInternationalConference,CIAA2016,Seoul,SouthKorea,July
19-22, 2016, Proceedings. 322â€“334.
[59]ValentinWÃ¼stholz,OswaldoOlivo,MarijnJ.H.Heule,andIsilDillig.2017. Static
Detection Of DoS Vulnerabilities In Programs That Use Regular Expressions. In
Tools and Algorithms for the Construction and Analysis of Systems - 23rd Interna-
tional Conference, TACAS 2017, Held as Part of the European Joint Conferences on
TheoryandPracticeofSoftware,ETAPS2017,Uppsala,Sweden,April22-29,2017,
Proceedings, Part II. 3â€“20.
[60]NavidYaghmazadeh, ChristianKlinger,Isil Dillig,andSwaratChaudhuri.2016.
Synthesizing Transformations On Hierarchically Structured Data. In Proceedings
of the 37th ACM SIGPLAN Conference on Programming Language Design and
Implementation, PLDI 2016, Santa Barbara, CA, USA, June 13-17, 2016. 508â€“521.
[61]XiaodongYuandMichelaBecchi.2013. GPUAccelerationOfRegularExpressionMatchingForLargeDatasets:ExploringTheImplementationSpace.In Computing
Frontiers Conference, CFâ€™13, Ischia, Italy, May 14 - 16, 2013, Hubertus Franke,
Alexander Heinecke, Krishna V. Palem, and Eli Upfal (Eds.). ACM, 18:1â€“18:10.
[62]Sai Zhang and Yuyin Sun. 2013. Automatically Synthesizing SQL Queries From
Input-OutputExamples.In 201328thIEEE/ACMInternationalConferenceonAu-
tomated Software Engineering, ASE 2013, Silicon Valley, CA, USA, November 11-15,
2013. 224â€“234.
[63]ZexuanZhong,JiaqiGuo,WeiYang,JianPeng,TaoXie,Jian-GuangLou,TingLiu,andDongmeiZhang.2018. SemRegex:ASemantics-BasedApproachForGenerat-ing Regular Expressions From Natural Language Specifications. In Proceedings of
the2018ConferenceonEmpiricalMethodsinNaturalLanguageProcessing,Brussels,
Belgium, October 31 - November 4, 2018. 1608â€“1618.
671