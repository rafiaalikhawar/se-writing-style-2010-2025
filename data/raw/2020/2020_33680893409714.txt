Thinking Aloudabout ConfusingCode
AQualitative Investigation ofProgram Comprehensionand Atoms ofConfusion
DanGopstein
New York University
New York, USAAnne-Laure Fayard
New York University
New York, USA
Sven Apel
SaarlandUniversity, SaarlandInformaticsCampus
GermanyJustinCappos
New York University
New York, USA
ABSTRACT
Atomsof confusion are small patterns of code thathave been em-
pirically validated to be difficult to hand-evaluate by programmers.
Previous research focused on defining and quantifying this phe-
nomenon,butnotonexplainingorcritiquingit.Inthiswork,we
address core omissions to the body of work on atoms of confusion,
focusingonthe‘how’and‘why’ofprogrammermisunderstanding.
We performed a think-aloud study in which we observed pro-
grammers,bothprofessionalsandstudents,astheyhand-evaluated
confusingcode.Weperformedaqualitativeanalysisofthedataand
found several surprising results, which explain previous results,
outline avenues offurther research, and suggestimprovements of
the researchmethodology.
Anotableobservationisthatcorrecthand-evaluationsdonotim-
plyunderstanding,andincorrectevaluationsnotmisunderstanding.
We believe this and other observations may be used to improve fu-
ture studies and models of program comprehension. We argue that
thinkingofconfusionasanatomicconstructmayposechallengesto
formulating new candidates for atoms of confusion. Ultimately, we
question whether hand-evaluation correctness is, itself, a sufficient
instrument to study program comprehension.
CCS CONCEPTS
•Software andits engineering →Softwareusability .
KEYWORDS
Program Understanding; Think-Aloud Study; Atoms of Confusion
ACMReference Format:
Dan Gopstein, Anne-Laure Fayard, Sven Apel, Justin Cappos. 2020. Think-
ingAloudaboutConfusingCode:AQualitativeInvestigationofProgram
ComprehensionandAtomsofConfusion.In Proceedingsofthe28thACM
JointEuropeanSoftwareEngineeringConferenceandSymposiumontheFoun-
dationsofSoftwareEngineering(ESEC/FSE’20),November8ś13,2020,Virtual
Event, USA. ACM, New York, NY, USA, 12pages.https://doi.org/10.1145/
3368089.3409714
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’20, November 8ś13, 2020, Virtual Event, USA
©2020 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-7043-1/20/11...$15.00
https://doi.org/10.1145/3368089.34097141 INTRODUCTION
Previousworkon atomsofconfusion[ 11]introducedamethodol-
ogy for discovering, measuring, and validating programmer misun-
derstandinginapreciseway.An atomofconfusion isthesmallest
snippet of code that will often confuse a programmer as to what
thecode’s output is. Previous work measuredcorrectness rates of
programmershand-evaluatingconfusingsnippetsandcompared
the rates to those for functionally equivalent code hypothesized to
be less confusing. Between the minimality of the code snippet and
itscomparisonagainstacontrol,theresearchonatomsofconfusion
wasdesignedtobebothpreciseandaccurate.Gopsteinetal.[ 11]
applied this protocol in an experiment with 73 participants and
analyzedthe results withmodern statisticaltechniques.
The study performed by Gopstein et al. was significant in that it
was empirical, objective, and quantitative. Code was found to be
confusingorreadilyunderstandablebasedonexperimentation,not
theory; the observationswere basedon performance, not opinion,
andtheextentofconfusionwasabletobepreciselyquantified.Thus,
theexperimentwasdesignedtomaximizeinternalvalidity[ 20].By
usingminimalcodesnippets,Gopsteinetal.couldbesurethatthey
wereonlymeasuringprecisecodeconstructs.Byusingfunctionally
equivalentcodesamplesascontrols,theywereabletodemonstrate
a direct relationship between the code and programmer confusion.
Despite Gopstein et al.’s precision and accuracy in design, it can
only tell us the outcome of programmers’ performance, but not
how or why they behaved that way. How can we know that the
causesofconfusionarethoseputforthbytheresearchers?Howcan
we knowthat misunderstandingsamongst multiple programmers
arehomogeneous.Howcanweevenknowthathand-evaluation
captures alltypes ofmisunderstanding?
Inshort,Gopsteinetal.’sstrongfocusoninternalvalidityand
objectivistrigordoesnottellthewholestory.Westudythesame
fundamental code snippets and hand-evaluation protocols as Gop-
stein et al., but augment the setting by having programmers think-
aloudastheyparticipate,followedbyasemi-structuredinterview
and discussion. This unique perspective on an existing method-
ologicalframeworkallowsustounderstandandscrutinizeexisting
work.Ourexperiencewithconductingaqualitativestudyaftera
quantitativeexperiment leadsusto believethe originalexperiment
could likely have been improved if a lightweight qualitative study
had been performed as a pilot during the design of the original
quantitative experiment.
605
ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA Dan Gopstein, Anne-Laure Fayard, SvenApel,JustinCappos
Our study offers insights into previous results as well as sev-
eral surprising observations that contradict previous assumptions,
including:
•Theoriginsofincorrectbeliefsaboutsemanticsdifferacross
programmers.
•Errors evaluating atom-containing code are often caused by
other,unrelatedaspectsofthe code snippet.
•Correctevaluationofasnippetdoesnotmeanaprogrammer
understoodits semantics.
•Our study reveals newtypes ofpotentialatoms.
InSection 4,weoutlinedescriptionsofhowandwhyprogram-
mersmademistakesoravoideddoingsoinsurprisingways.This
providesinsightintohowtomoreaccuratelyinterprettheresults
ofGopsteinetal.aswellasotherhand-evaluationprogramcompre-
hensionexperiments.InSection 5,weturnaneyetofutureresearch
andpropose potentialimprovements ornewresearchquestions.
A complete replication package for this study is provided at
https://atomsofconfusion.com/2020-think-aloud . The goal of the
replicationpackageistofacilitatetheunderstandingofourmethods
andobservationsaswellastoencouragingotherstoperformsimilar
studiesoftheirown.Whileweprovidetheoutcomesofouranalysis,
we recommend that anyone using thispackagestays opentonew
themes that mightemerge.The package contains:
•Preparatorymaterial,includingallcodesnippetsusedand
the scripts enlistedto assignthemto subjects.
•Interviewinstructions,includingapre-flightchecklist,meta-
protocolanduniversalanswerkeyusedtoincreasethere-
producibility ofthe semi-structuredinterviews.
•Raw Data, including anonymized transcripts and scans of
the subjects’ written notesfrom eachinterview.
•Analysis, including the labels assigned to the transcripts
during open coding, and the codebook usedin that process.
2 RELATED WORK
AtomsofConfusion. Thecoretopicthatinspiredourstudyisthe
concept of the atom of confusion , a small snippet of code, empiri-
callyvalidatedagainsthumansandproventobemoreconfusing
than other functionally equivalent code. Introduced by Gopstein et
al.[11],theconceptofatomofconfusionsreliesonthemismatch
between how programmers think the C programming language
worksversushowthespecificationdefinesit.Gopsteinetal.define
‘confusion’ as when aprogrammer isasked tohand-evaluate ade-
terministicand syntactically/semanticallyvalidpieceofcode,but
reports standard output that is different from what is mandated by
thelanguagespecification.Gopsteinetal.arguedthatthemostpre-
cise way to measure this phenomenon is with the smallest possible
piece of code that can cause misunderstanding in a programmer
while a similarly sized, functionally equivalent simplified ‘pair’
versionofthe code isableto be evaluatedwithouterror.
IntheoriginalstudyofGopsteinetal.,126codesnippets(each
averaging 4 source lines of code), from 63 pairs, representing 19
proposed atomswere tested in a human subjects experiment with
73participants.Eachsubjectwasshown84ofthecodesnippetsand
askedto recordwhat they thoughtwas the output of eachsnippet
program.Gopsteinetal.wereabletomeasurethecorrect/incorrect
response rates for each obfuscated/transformed snippet pair andtodetermine which code patterns were truly more confusing than
their counterpart.Of the 19 proposed atoms,15 met the statistical
significance requiredto be consideredaconfirmedatom.
Following the original studies, the notion of atoms of confusion
has been shown to be common in practice and correlated with
negativecodequalityindicatorssuchasbugdensityandsecurity
vulnerabilities [ 12]. The concept has also been investigated with
the open-source community through opinion surveys and pull-
requests [ 17]. This line of investigation confirms that atoms of
confusion are indeed confusing and prevalent across several di-
mensions. However, there has yet to be an investigation into the
mechanismwithwhichthatmisunderstandingoccurs.Ourresearch
setsoutto explainthe phenomenaobservedinprevious studies.
In an effort to expand the concept of atoms of confusion beyond
justtheClanguage,CastoradaptedittotheSwiftProgramminglan-
guage [4]. Castor used new methods of finding confusing patterns,
such as measuring the infrequency of occurrence in large code
basesandexpertopinion.Weproposethatobservingprogrammers
ina think-aloud study isan acutelyeffective means of identifying
specific sourcesofmisunderstandings.
QualitativeResearchinSoftwareEngineering. Withgoalsofunder-
standing how confusion arises in programmers and improving
methodologies for future research, we chose aqualitative method
to explain previous results and explore potential new research de-
signs.DespitethepositivesofGroundedTheory,wedecideditwas
notagoodfitforourstudy,aswewerealreadyfamiliarwithpre-
existingliteratureinthefield,andthesemi-structurednatureofour
inquirywasslightlytoorigidtofullybenefitfromGroundedThe-
ory.Still,wetookmanylessonsbothfromprimarysourcesofthe
technique[ 6,9],aswellasdescriptionsdesignedspecificallyforthe
software engineering field [ 22]. We used techniques recommended
fromthesetexts,suchascontinuousdataanalysis,(open)coding,
and memoing.Perhaps thebest high-level descriptionofour style
of study is described by Creswell as ‘explanatory sequential mixed
methods’,wherearesearchertakesanexistingquantitativestudy,
łanalyzes the results and then builds on the results to explain them
inmore detailwithqualitative researchž [ 7].
We modeled our research onqualitative studies in the software
engineeringfield,combiningelementsasnecessarytofitourneeds.
Röhmetal.usedahybriddesignconsistingequallyofobservations
and interviews, with the łobservation mainly targeting what devel-
opersdoandtheinterviewmainlytargetingthemotivationbehind
developer’sactionsž[ 18].Thisblendoftechniqueswasanatural
fitforus,aswecouldreanalyzeexistingobjectivedata,andthen
explain them based on the subjects’ (subjective) reports. For the
observation component, we chose a think-aloud protocol due to its
abilitytoprovideinsightsintoactivebehaviorsastheyarebeing
performed[ 5,21].Thismethodiswellsuitedtoanalyzingprogram
comprehensiontasks[ 3,8].However,publicperformanceandan
artificial code-reading environment have been linked to adverse
affectsoncognitiveload[ 2],whichmayaffectourresultsthough
not invalidatethemaltogether.
Oneofthemostpopularmethodsofanalyzingqualitativedata
is first using open coding to develop descriptive labels for data,
then using a hierarchical coding scheme to develop categories
from these codes [ 6,23]. This general technique has been used
606Thinking Aloudabout Confusing Code ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA
successfully many times in empirical software engineering and,
more specifically,forstudyingprogram comprehension. Seaman
givesathoroughoverviewofmanyofthesemethods[ 19].Inpartic-
ular,YamashitaandMoonenusedinterviewstodevelopataxonomy
ofdifficulties duringcodemaintenance[ 25].Wehaveemployeda
similar technique to develop our understanding of the ways pro-
grammers misinterpretatoms.
3 METHODS
WeusedaqualitativeapproachtohelpexplaintheresultsofGop-
stein et al. Towards that goal, we borrow many elements of exper-
imentaldesignfromtheirwork,butaugmentthemtofacilitatea
deeper,more flexibleinterpretation.
3.1 SourceCodeSelection
Gopstein et al.’s code snippets were divided by two dimensions:
whetherthesnippetcontaineda(potential)atomofconfusionor
not, and which type of atom it contained or not. After their experi-
ments,theydividedtheatomsintothecategoriesofbeingvalidated
as confusing or not. They tested 126 code snippets in total. For
our work, 126 were too many to test, given the enormous effort
involved in a think-aloud study. Instead, we selected 26 representa-
tive examples from the original set. We made sure in our corpus to
includeoneofeachtypeofatom,severalsampleswithoutatoms,
andcompleteobfuscated/transformedpairsofeachoftheproposed
atomsthat failedto meetstatisticalsignificance.
We wanted to investigate snippets that had shown confusing
properties in previous experiments, as well as snippets that had
been hypothesized to be confusing, but did not empirically demon-
strateconfusingpropertiesintheoriginalstudy.Thismeantthat,
in addition toverifiedatomsof confusion, wewantedtostudy hy-
pothesizedatomsofconfusionthathadpreviouslyfailedtomeet
statisticalsignificance.Additionally,wewantedtoobservesubjects
hand-evaluating non-confusing snippets, as a baseline for com-
prehensionofsimpleprograms.Sincemanysnippetswithatoms
removedaresimilartoeachother,beingsmallandcontainingalim-
ited set of language constructs, we did not make an effort to study
eachatomsnippet’s directtransformation.Forsnippetsthatwere
hypothesized,butnotconfirmedasconfusing,however,wedidtest
directtransformations,sinceanoverlyconfusingtransformation
has the power to confuse a subject and serve as a defective control.
Consequently,eachsubjectwasshown:
•5confirmedconfusing snippets(C)
•1confirmednot-confusingatomtransformation (NC)
•1hypothesizedbut not validatedconfusing snippet(HC)
•1transformation ofthe same HCsnippet(HNC)
Snippets were assigned to specific participants in using these
constraints, but otherwise distributed randomly by a script. The
script that we used to determine snippet selection is included in
our replication package.
3.2 Data Acquisition
The principle mechanism of our study is a think-aloud protocol
with a combined semi-structured interview and discussion. We
showed each subject 8 small code snippets of various degrees of
confusingnessfrompriorexperiments.Foreachcodesnippet,weaskedthesubjectstohand-evaluatethecodeandreportthestan-
dard output (results of the printfstatement). We then asked the
subjects to notate their confidence about their answer on a scale
from 1 (‘unsure’) to 6 (‘positive’). We also requested from each
subjectłWhileevaluatingeachprogrampleasespeakaloudyour
reasoning,thoughts,andactionsž.Thestudyleaderremainedinthe
room with the subject and audio recorded the entirety of the study.
Aftereachindividualevaluation,thestudyleaderfirstaskedsub-
jectswhytheychosethelevelconfidencetheyselected,andthen
proceededtoaskclarifyingquestionsaboutanyambiguouscom-
ments made by the subject. The study leader used a meta-protocol
toguidetheirinteractions.Themeta-protocolrecommendedspe-
cific situations to look for, questions to ask in these scenarios, and
canned answers for common questions. At this point, the study
leader attempted not to provide any information to the subject.
Afterall8codesnippetswerefinishedbeingevaluated,thesubjects
were given a questionnaire that asked about subject demograph-
ics,previousexperience,programminglanguagepreference,and
perceivedproficiency,amongother things. Afterthesubjectcom-
pleted the questionnaire, the study leader stepped the subject back
througheachofthecompletedcodesnippets,thistimeaskingmore
probing questions designed to start a back-and-forth dialog. At
thispoint,discussionswerecollaborativeanditerative;perhapsthe
studyleaderwouldaskaclarifyingquestiontowardsthesubject,
orthesubjectwouldask foranexplanation fromthestudyleader,
andthediscussionwouldproceedfromtheretoidentifytheroot
causesandprocessesthatledtouncertaintyormisunderstanding.
Any error in evaluation or understanding that the study leader
identifiedwasdissectedbothbythestudyleaderandthesubject
until the subject had a complete understanding of the mistake they
hadmade,andtheyhadcommunicatedtheirunderstandingoftheir
originalthoughtprocessandtheir misconception.
3.3 Subjects
Weselectedsubjectstorepresentprogrammersalongabroadrange
of experience, recruited from three general groups. Ultimately, we
interviewed 5 students, 4 professional C++ application developers,
and 5 professional authors of a popular C++ library. All subjects
identified as male, though this was not an intentional aspect of the
study design.A listofour subjectscan be foundinTable 1.
Allstudentsubjectswererecruitedfromthecomputerscience
masters program of NYU. All other subjects were recruited from
asinglelargeNorthAmericanWebtechnologycompany.Unsur-
prisingly,thereisamuchstrongerpreferenceforC++amongthe
subjects who work professionally with the language. Profession-
als also tend to be older, have more experience, and have higher
self-perceivedproficiencywithprogramming.
3.4 Analysis
Theanalysisbeganastheinterviewsthemselves,asthestudyleader
keptcontinuousnoteswhileeachsubjectspoke.Aftereachinter-
view, the study leader would go back to summarize and reframe
each set of observations. This included writing memos on develop-
ing patterns and theories as evidence for them grew. All-the-while
thesememoscontinuedtobecomparedandjuxtaposedagainstthe
newer data that continuedbe collected.
607ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA Dan Gopstein, Anne-Laure Fayard, SvenApel,JustinCappos
Table 1: Programmers recruitedto participate inthestudy
Subj. Group Age Preferred C/C++ Years
Language Proficiency Progr.
4168 Student 22 C++/Python 4 15
3316 Student 22 Go 3 4
4281 Student 24 C++ 4 7
9112 Student 21 JS/Kotlin 3 6
3787 Student 22 Python 4 7
6061 C++User 32 C++ 5 27
8888 C++User 35 C++ 5 29
4304 C++User 53 C++ 5 39
1879 C++User 48 C++ 5 34
1157 C++Librarian 37 C# 6 20
7640 C++Librarian 29 C++ 6 16
4642 C++Librarian 53 C++ 6 33
8697 C++Librarian 22 JS/C++ 4 5
1867 C++Librarian 29 C++ 5 9
Subsequently, subjects’ handwritten notes were digitally copied
and saved for analysis. We generated transcripts from the audio
recordingsoftheinterviews.Wereadthesetranscriptions,along-
sidethesubjects’writtennotes,usingopencodingtolabelpatterns
thatappearedinsubjectresponses.Opencoding,asdescribedby
Corbin and Strauss [ 6], is łBreaking data apart and delineating
conceptstostandforblocksofrawdata.Atthesametime,oneis
qualifyingthoseconceptsintermsoftheirpropertiesanddimen-
sionsž. This involves identifying interesting/repeated/surprising
facets of a text and marking them for later analysis. From these
codes, we formed higher level groupings of similar concepts. From
these,patternswereinducedthatformthebasisofourobservations,
hypotheses, andsuggestionsthat followinthis paper.
Theanalysiswasperformedinseveralbatches,intertwinedwith
data collection as new subjects were recruited and interviewed. As
one of the goals of this study was to explain Gopstein et al’s re-
sults, we began by recruiting, interviewing, and analyzing student
subjects, to obtain a sample similar and comparable to the original
sample.Weusedathree-foldanalysisstrategythatallowedusto
remainsensitivetoinsightsthatemergedfromdata[ 9],whilefo-
cusingonthequestionsthatemergedfromGopsteinetal’soriginal
study. Once the first set of interviews was completed, the study
leader read the transcripts to define emerging recurring themes
across subjects. After discussing with the other authors this first
list of common patterns, the study leader read the interviews a
second time to inductively generate codes through open coding of
ourdata.Wheneveranewcodewasdeveloped,itwasaddedtoa
runningcodebook,whichlistseverytypeofcodeused,alongwitha
brief description of when it is applicable. The full codebook as well
as each code’s application is included in our replication package
online.
Since codes were generated dynamically during open coding,
the coding process was performed iteratively. Any codes that were
generatedafterthecodingofatranscriptwerethenretroactively
applied to all transcripts that were previously coded without it.
This process was done in two phases. Whenever the last subject
ofagroupwascoded,alltheprevioustranscriptsfromthatsame
groupwouldbere-evaluatedtoaddthenewly-createdcodes.For
0 10 20 30 40
Years Programming345678Correct Answers1157 1867 1879
3316
37874168
4281 430446426061 7640 8697 8888
9112
Subject Groups
Student
C++ App. Dev.
C++ LibrarianFigure1:Subjects’performancerelativetoC/C++experience
example,whenthelaststudenttranscriptwascoded,allprevious
students’transcriptswerere-analyzedtoseewhetherthenewcodes
wereapplicable.Finally,whenall14transcriptsacrossallsubject
groups (student, C++ application developer, C++ librarian) were
analyzed, they were all read and recoded once more, this time with
the complete setofcodes.
We then engaged in a third phase of analysis in which the study
leader compared and contrasted across codes, and collapsed and
combinedthemintohigher-levelcategories.Thestudyleaderhad
regular meetings with the other authors to discuss and agree on
thedefinitionofthesehigh-orderconcepts.Intherestofthispaper,
these concepts are presented with specific quotes and interactions.
3.5 DescriptiveStatistics
Whilenotthefocusofthiswork,weprovideaquantitativeoverview
of the collected data because it gives important context for what
follows. In total, there were 8h18m of recorded audio, consisting
of about 82000 spoken words broken into roughly 3040 blocks
of speech by either the subjects or the study leader. There were
144 types of labels applied to 1740 phrases from the interviews.
Themostcommonthemesinthetextwere‘Unsure’,‘CorrectSe-
mantics’, ‘Simple’. Examples of less frequently occurring labels are:
‘Maintainability’,‘Previously Used’,and‘Unfamiliar Syntax’.
Therewere17codesnippetsevaluatedincorrectly.14errorswere
committed by4 students, 2by asingleC++application developer,
and1byaC++librarian,indicatingthatthestudentsmademore
errorsthanprofessionals,butthedifferenttypesofprofessionals
werenotwelldistinguished.Afullaccountingoferrors-per-subject
is depicted in Fig. 1. The types of snippets that generated errors
largelyfollowedwhatwaspreviouslyreportedbyGopsteinetal.,
albeit with less fidelity. There were no ‘transformed’ (non-atom)
snippets that were evaluated incorrectly, with all errors coming
from snippetsthat were designedas obfuscated.
4 MECHANISMS OFMISUNDERSTANDING
In this section, we analyze and discuss our observations pertaining
tothecausesofprogrammermisunderstandingswhileevaluating
atomsofconfusion.Weexplorehigh-levelpatternsinducedfrom
individualexamples discussedwithour subjects,specifically:
608Thinking Aloudabout Confusing Code ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA
•A taxonomy ofdifferenttypes oferrors
•Causes oferrorsbeyondatomofconfusions
•Cases when subjects evaluated code correctly despite being
mistakenaboutsemantics
Thediscussionsintroduceageneralizedpatterninferredfrom
the data, and also give specific examples in the form of quotes
taken from the subjects. Whenever quotes are given, they refer-
ence the subject and the associate code snippet in the form of
[subject-id:snippet-id].Forexample,ifsubject1234weredescribing
snippet56, we wouldwritełquote aboutcodež[1234:56].
4.1 Taxonomy ofConfusion
Gopstein et al. were careful to delineate types of confusing code
that were and were not relevant to their investigation. Specifically,
they excluded code that contained non-determinism, non-standard
features, high computational load, or reliance on a complex API.
The rationale was that they were interested in studying situations
in which a programmer would make an error based only on a
flawed understanding of a language’s semantics. To test this rea-
soning, we categorized every incorrect hand-evaluation and at-
tributed a primary (and sometimes secondary) high-level cause.
These causes naturally fell into four general groups of errors: unfa-
miliarity,misunderstanding ,languagetransfer ,andattention.The
first three would likely be considered ‘in-scope’ for Gopstein et al.,
while attention-related errors would likely fall into the category of
excluded types of confusion. Table 2lists each incorrectly evalu-
ated snippet, alongwith which high-level categoryof erroritwas
assignedto.Next,we describe the categoriesindetail.
Unfamiliarity. The subject appears to have never encountered this
phenomenon before, or at least does not recognize it in its current
form.Considerthe following example:
int V1 = 013;
łI assume the int is going to be thirteen,
because it doesn’t have to representthat
zeroinmemoryž [3316:105]
Inthiscase,thesubjectwasnotawarethataleadingzeromeans
the literal represents an octal value, and is stored with a value
equivalent to the decimal number 11, in this case. There is no
evidence that the subject had ever seen this notation before and
wasthenleftinferringthesemanticsofthisnotationbasedonlyon
hisownreasoning.Originally,thesubjectconsideredthataleading
zeromightcauseanerror,butultimatelyhesuggestedthatignoring
the leading zero might make sense for purposes of being able to
parse fixed-widthintegersfrom data files.
Allthesebehaviors are characteristic ofunfamiliarity:
•Noevidenceofprevious associationofthe construct
•Often questioning the code’svalidity
•Using logic to constructpotentialsemantics
Misunderstanding. Thesubjectisawareoftheconstruct,butuknowl-
inglyattributes incorrectsemantics to it,as inthis example:if (++V1 || ++V2) ...
łThis is pre-incrementand uh, what Ire-
member from whatI studiedisthat, you
know, before the statement is executed,
this willbe incrementedž [4281:79]
In this example, the subject recognized the pre-increment operator
and noted that the underlying variable would be incremented. The
subject believed thatfirst incrementationwould happen, andthen
the logical expression would be evaluated. Actually, it works the
otherway,thedisjunctionoperator( ||)mustfirstevaluateitsleft
operand, and only if that is true, it will evaluate the right operand,
incrementingitsvariable’svalue.Underthesubject’sconception,
V2wouldalwaysbe incremented,whichisnot accurate.
Unlikeunfamiliarity,when asubjectmisunderstands:
•They have seen the constructbefore
•They purport to have an understanding of it
•Theirunderstanding issomehowflawed
Language Transfer. The subject has seen similar code before, but
onlyinanotherprogramminglanguage.Fromtheotherlanguage,
they guess what the semantics mightbe inC:
int V1 = 013;
łWe have like different number base, but
forint.IknowPythonhassomethinglike
it,butinC,I’mnotsure.[InPython,the
0infront]means nothing.ž[9112:105]
In this example, the subject recognized the form of the octal literal,
however,hewasunsurewhetherornotitappliestoC.Hedescribed
howsimilarcodeworksinPython,andthenultimatelydecidedthe
0waslikelytobeignoredsincethatiswhathebelievedhappens
in Python. (N.b. in Python 2, 013is interpreted a decimal 11; in
Python3, 013isaparse error).
Languagetransfer iseasily identifiedwhen the subject:
•Mentionstheirunderstandingisderivedfromtheirknowl-
edge ofanotherprogramming language
Attention. The subject verbalizes correct semantics, but appears to
forget orignore an importantpieceof the computation:
printf("%d %dn", V1, V2)
łV2 is going to equal 1 and V1 is going to
equal 2 after that expression. And so it’s
going to print outone,twož[4304:61]
In this example the subject accurately described the state of the
variables ( V1is 2, and V2is 1), but then immediately went on to say
thatthevariableswereprintedwiththeirvaluesreversed.There
was no explanation for this what-so-ever, and the attribution of
‘attention’ is somewhat of a guess on the behalf of the study leader.
A misunderstandingisconsideredan attention problem when:
•Thesubjectappearstounderstandthesemanticsofthein-
volvedconstructs
•There isnootherobvious cause of the problem
609ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA Dan Gopstein, Anne-Laure Fayard, SvenApel,JustinCappos
Table 2: Incorrectly evaluatedsnippets.Including error description,categorization, and unexpectedadditionalatomsthat also appear
Subject Snippet Atom Mistake Category OtherAtoms
3316 45 Pointer Arithmetic Array as headerpointer/pointervs.value Unfamiliarity /Unfamiliarity
3316 19 Pre-Increment Failed to incrementvariable Misunderstanding /Attention
3316 11 Operator Precedence Booleanvalue ofinteger LanguageTransfer Implicit Predicate
3316 105 Literal Encoding Leadingzerois ignored Unfamiliarity
4281 79 LogicasControl ++xoperates beforestatement Misunderstanding Pre-Increment
4281 71 Preprocessor inStmt ifdetermines macrodefinition Unfamiliarity
9112 61 Comma Operator Mistook =for==/Comma operator Attention /Unfamiliarity Assignment asValue
9112 105 Literal Encoding Leadingzerois ignored LanguageTransfer
9112 79 LogicasControl Forgot short-circuit /thoughtit didn’t apply Attention /Misunderstanding
3787 11 Operator Precedence Booleanvalue ofinteger Unfamiliarity Implicit Predicate
3787 71 Preprocessor inStmt If selectspreprocessor Unfamiliarity
3787 109 OmittedCurly Brace Booleanvalue ofinteger Unfamiliarity Implicit Predicate
3787 37 MacroPrecedence Pre-evaluated macrocontents Unfamiliarity
3787 85 RepurposedVariable Booleanvalue ofvariable(not integer) Unfamiliarity Implicit Predicate
4304 61 Comma Operator Switched argument order Attention
4304 79 LogicasControl Falseoperandcausesshort-circuit Misunderstanding
4642 115 Type Conversion Float to integer is arounding conversion Misunderstanding
Summary. Wehavedefinedfourcategoriesoferrorthatdescribe
themistakesthatwesawinourstudy.Wedonotexpecttheyare
exhaustive of all comprehension errors. However, they capture the
essenceofthe issuesthat we happenedto witness.
4.2 UnexpectedCause ofError
Theverypremiseofearlierworkonatomsofconfusionworkrelied
ontheimplicitassumptionthatdifferentprogrammersmisinterpret
variousexamplesofconfusingcodeinthesame,predictableway.
For example, an atom of confusion might be called Operator Prece-
dence, and any time a subject makes an error evaluating this piece
ofcode,thespecificcauseofconfusionisassumedtobedirectlydue
to misinterpreting precedence of the infix operators in the snippet.
DespitethetightcontrolsimplementedbyGopsteinetal.,therewas
nowaytovalidatethatassumption.Inourwork,weseeevidence
bothinfavorandagainstthisassumption.Oneexamplethatshows
an incorrectlyattributedsourceof confusionhappens witha code
snippetofthe OperatorPrecedence atommentionedpreviously:
int V1 = 0;
if (0 && 1 || 2) {
V1 = 6;
} else {
V1 = 3;
}
printf("%d\n", V1);
The part that was assumed to be confusing was the precedence
of the logical operators in expression 0 && 1 || 2 . Two (both stu-
dents)ofour14subjectsincorrectlyevaluatedthelogicalexpression
above, however, the root cause of both errors were unrelated to
operatorprecedence.Subject3316saidłyoucannotevaluatetwo
totruež [3316:11],implying hedid notknow thatnon-zerovalues
are evaluated as truthy by a logical operator in C. Subject 3787’s
confusionwentslightlydeeper:łsowillthevariablewillbeaffected
by this or it will just completely skip thisž [3787:11], implying that
hebelievedalllogicalconditionsmustreferenceavariable.While
this code snippet was obviously confusing to these two subjects,it happened not to be the reason that was identified by previous
research.
To determine which of the errors made inour study were due
to the reasons assumed and which were due to unrelated misun-
derstanding,weanalyzedeachincorrectlyevaluatedsnippetand
attributed a simplified cause as to why each subject erred while
hand-evaluating asnippetinTable 2.
Ofthe17incorrectlyevaluatedsnippets,10appearedtobecaused
solely by the stated atom of confusion, as described in Gopstein
et al. In 7 cases, the cause of the confusion was either partially
or solely due to some other factor, potentially another atom or
atomcandidate.Subject4304’serrorinsnippet61appearedtobe
caused only by a lapse of attention, and is likely not caused by
anyatomofconfusionatall.Severaloftheinteractionsobserved
duringtheincorrectevaluationofothersnippetsprovidedevidence
formultiplenewtypesofatomsnotpreviouslyidentified.Thisis
discussedinmore detailinSection 5.1(PotentialNew Atoms ).
Summary. Despite causing confusion, atoms of confusion do not
necessarilycauseconfusionforthereasonimpliedbytheatom’s
title. This maybe dueto insufficient ‘minimality’, and perhaps the
snippetscould be written more carefullyto avoid this pitfall.
4.3 Correct forWrongReasons
There is a subtle problem with only collecting the output of the
subject’shand-evaluation.Itisonlypossibletomeasurewhetheror
nottheirevaluationresultedinthecorrectoutput,notwhetherthey
evaluatedthe code followingthecorrect semantics.Inthiswork,
weobservedseveralscenariosinwhichsubjectsreportedcorrect
output, but did so in a circuitous way. In Table 3, we collected
every example of a construct that was evaluated correctly, but
for the wrong reasons. The table lists which piece of code was
evaluated with wrong semantics, what the supposed or explicit
misunderstandingwas,andwhether or not thesubject proceeded
to ultimately evaluate the restof the snippetcorrectly.
610Thinking Aloudabout Confusing Code ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA
In our example on Operator Precedence , there were no wrong an-
swers that exhibited the expected misunderstanding of precedence
rules. This could be because precedence rules for logical operators
are not confusing. However, there is also another explanation pro-
vided by our investigation. Several subjects did express a lack of
understanding of operatorprecedence, however, due to the order-
ingoftheexpressionsinvolved,theywouldaccidentallycorrectly
evaluate the snippet anyway. Take, for example, subject 8697 who
explained łIf I recall correctly, the operator precedence is such that
AndandOrarethesame.Idon’tbelieveeitheroneofthemtakes
precedenceoverthe other,andso it’sjust left torightž[8697:11].
Thisunderstandingofthelanguagesemanticsisgenerallyincorrect,
however, the specific example enabled the subject to still evalu-
ate the example correctly. Had the snippet prompt instead asked
thesubjecttoevaluate 2 || 1 && 0 ,itislikelythathewouldhave
evaluated it incorrectly assuming the parenthesization would be
(2 || 1) && 0 instead of the actual parenthesization: 2 || (1 && 0) .
Unlike a simple error that leads to an incorrect output, a correct
response that arose from an incorrect evaluation often necessitates
multiple misunderstandings: one to initially generate an incorrect
response, and another to steer the evaluation back to being cor-
rect. For example, in snippet 49, subject 4281 did not understand
the parsing rules of the statement int V2 = V1 == 3 ? 2 : 4; , how-
ever, since he believed that ==was only valid to be used inside a
predicateclause(forexample,thefirstoperandoftheconditional
operator), the two misunderstandings canceled out, and left the
subjectevaluatingthe code correctly.
Summary. The implication for these types of errors on previous
work is significant. Misunderstandings like these may not result
inanincorrectresponseinacorrect/incorrectoutputexperiment
like the one of Gopstein et al.. So, if an experiment intends to be
measuringmisunderstanding,itmaywellbeunderestimatingthe
amount.
5 IMPLICATIONSAND PERSPECTIVES
During the course of this study, it became clear that many assump-
tionsthatweretakenforgrantedinpreviousworkmaynotalways
hold true. In this section, we discuss potential new areas to investi-
gateorimprovementsonolddesignsfornewstudiesgoingforward.
We address four specific facets of the previous work from a new
perspective:
•Newcandidates for atomsdiscoveredthroughobservation
•Limitationsofthe modelofatomsofconfusion
•Potentialpitfallsinhand-evaluation experiments
•The role ofqualitative methodsinquantitative work
5.1 Potential NewAtoms
Gopsteinetal.proposed19candidatecodepatterns aspotentially
confusingrelativetofunctionallyequivalentcode.Ofthese,4failed
to meetstatisticalsignificance; 15 patternswere validatedas atoms
ofconfusion.Despitethisexistingcorpusofknownconfusingcode
patterns, it is likely that there still exist more minimal patterns
of code that are confusing to programmers. We list here several
constructsthatappeartobeconfusingbasedonourobservations;
they mayprove to be atomsofconfusionuponfurther validation.UninitializedVariable. Severaloftheprogramsincludedinourstudy
declarevariablesanddonotinitializethemimmediately,onlyas-
signing values to them through the course of the program. Each
of these variables, being local in scope, begin life with an inde-
terminate value and only have a known value once it has been
assigned. In each snippet, the value of every variable is assigned
beforeitisread.Therefore,nocodehasunspecifiedorundefined
behavior. However, there were dozens of mentions of this concern
from subjects: łThe others are actually in an indeterminate state at
themomentbecausewehavenoguaranteeoflikeinJavathey’dbe
zero initialized, but this is, C you go to hell and you diež [1157:85].
Inmostcases,subjectsunderstoodthattherewasnounspecified
behavior, but that it was still bad practice: łThe intention is to,
to not have the, the like declared, declaration of an int that’s not
defined because it’s just a, uh, it’s a vector for bugsž [1867:50].
We noticed, however, several misconceptions around the seman-
tics of uninitialized values that either caused mistakes or likely
would have in a different context. For example, subject 9112 incor-
rectly evaluated snippet 61 in part due to this misunderstanding.
HerecalledhisunderstandingłFrommyexperiences[thedefault
value will be] either minus one or to the smallest number from the
systemž [9112:61] and then proceeded to use these values in the
snippet.Othersubjectsstillmanagedtonavigatethecodecorrectly
despite equally unfounded beliefs: łIt depends on the flavor of C
thatyou’reactuallyworkingin.Um,actuallyIdon’tknowforeven
today, I’m not sure if like the default, initialization... I think that
since C++11, they made sure that these are default initialized, so
they’dbe zero.But that’snot guaranteedinthe early versions of
Cž[4304:61].In thiscase,C++11doesnotallowforautomatically
initializedintegersinanon-static/non-globalcontext[ 14],andthat
has been the caseinthe standard,at least,since ANSIC [ 15].
Given these misunderstandings, it is likely that code containing
uninitializedvariablesisconfusingtoprogrammers.Theoriginal
workonatomsofconfusionspecificallyavoidstestingcodewith
unspecified/undefined behavior, however, making the testing of
thispotentialatomalittlechallenging.Oneinterestingfactthatcan
be tested is that integers in a static or global context are (and have
been since the ANSI standard) initialized to 0. So, one potential
snippetofatomcode could be:
Atom Candidate: Uninitialized Value
int x;
int main() {
printf("%d", x);
}
Obfuscatedint x = 0;
int main() {
printf("%d", x);
}
Simplified
Inthisexample,thestandard specifiesthat xisinitializedto 0and
therefore output is 0, however, several of our subjects would likely
believe the behaviorisunspecifiedorundefined.
Modulo Operator. In snippet 1, an example of the Implicit Predicate
atom, the modulooperator (writtenas %, and often verbally abbre-
viated‘mod’),wasusedasagenericnon-logicalexpressioninthe
condition of an ifstatement like: if (10 % 3) . While the name and
conceptofthemodulooperatorwasalwaysknownbyoursubjects,
theprecisesemanticsandevaluationwereoftenquestioned.One
611ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA Dan Gopstein, Anne-Laure Fayard, SvenApel,JustinCappos
Table 3: Every evaluationthat was correct, butfor thewrong reasons
Subj. Snippet Construct Misconception Ultimately
8697 1 Truthiness of 10 % 3 Knew10 % 3was non-zero, butdidnotknowits value Correct
8697 11 Precedenceof 1 && 2 || 0 && and||havethe same precedence Correct
3316 11 Precedenceof 1 && 2 || 0 Alloperators getevaluated from leftto right Incorrect
4281 79 Incrementation andshort-circuiting (a)Both operands getevaluated;(b) ++3 == 3 Incorrect
of++V1 || ++V2
4281 49 Precedenceof V2 = V1 == 3 ? 2 : 4 łdoubleequal-tocan onlybethereforthe condition checkž Correct
9112 61 Expressionvalue of (V2 = 1, 2) ł[assignment] just like return like nothing. So onlythe remainingvalue is 2ž Incorrect
subject,inparticular,knewverywellwhattheoperatorwasata
high level, but struggled to actually calculate its value. łI mean it’s
like, obviously it’s modulo operator, so it’s like kind of close to
the remainder... [subject elaborates more, but then pauses for 31
seconds trying to calculate the value of the operation] oh, okay.
Actually now that I think about it. I don’t really care what the
value is, I guess cause it’s like it’s just a conditional, so it’s like
youcanconvertittoBoolean.Um,sointhiscase,uh,itdoesnot
evenly divide into three is not evenly divided into 10. Uh, so there
is a remainder and of non zero value. So it’s true" [8697:1]. After
being prompted by the study leader, the subject explained that,
despite knowing the high-level description of the modulo operator,
hestruggledactuallycalculatingitsresult.Thestudyleaderpushed
himtotrytocalculatethevalueagain,towhichthesubjectresorted
tocountingonhisfingers,andstillfeelingveryunsureofhisresult:
łone,two,three.One,two,three,four,five,six,seven,eight,nine,10.
So that would be... Oh interesting. Actually. Not sure what though,
soit’sstartingat.Wouldthatbeoneorzero?Imeanit’s,itcan’tbe
zerobecauseit’sdoesn’tevenlydividež[8697:1].Despiteevaluating
every snippet correctly, had the study leader asked subject 8697 to
evaluate 10 % 3andreportitsvalue,hewouldnothavebeenable
to doso.
Evenbeyondthecomputationalabilityrequiredofthemodulo
operator,severalsubjectsalsoagreedthesemanticsoftheopera-
torwasunknowntothemwhentheoperandswerenon-positive.
łIt’s themod operator.Could have gotteninteresting ifthere were
negativeor eventsthatIhad tothinkaboutit...Likespecificallya
negative divisor would like I’d never think about that case... And I
guess they design it so that like if you flip the sign at both of them,
itshoulddothesamethingIthinkwasthere,uh,Idon’tremember.
There’sacouple oflogical waysto doit.ž[8888:1]
Giventhesecomments,itislikelythatthemodulooperatoris
itselfconfusing.Boththeexamplegiven,forcomputationalreasons,
but also usages with other operands. Below are examples of the
modulo operator being used with operands of various signs, which
maybe confusing as well.
Atom Candidates:Modulo Operator
Case Expression Value
TwoPositiveOperands 10 % 3 1
NegativeLeft Operand -10 % 3 -1
NegativeRightOperand 10 % -3 1
TwoNegativeOperands -10 % -3 -1
ZeroLeft Operand 0 % 3 0
ZeroRightOperand 10 % 0 undefinedOctalnotation (two reasons). Snippet105 testswhether program-
mersunderstandhow toprint an octalliteralinteger asadecimal
value.The relevantcode is:
int V1 = 013;
printf("%d\n", V1);
Thereweretwoincorrectevaluationsofthissnippet,bothbystu-
dents. One of the subjects, 3316, was not at all familiar with the
leading-zerosyntaxandassumeditwouldbeignored:łUmthere’sa
leadingzerothere.SoIassumetheintisgoingtobe13,um,because
itdoesn’thavetorepresentthatzeroinmemory.ž[3316:105].The
othersubject,9112,knewthatsomelanguagesrepresented octals
inthis waywhile othersdidn’t andmade the guess that C didnot.
Afterwards the study leader told 9112 that the leading zero did
meanoctal, andaskedthe subject toproceedfrom that point with
the new knowledge. From there, the subject was still unable to get
thecorrectresult:łIt’sabase8.AndIthinkperthismeansthatthe
outputfor the be adigit [sic], soit’s1plus8. It’s 9.ž[9112:105].
Betweenthesetwosubjects,wecanseethattherearetwodif-
ferenttypesofmisunderstandings,oneregardingthemeaningof
the leading-zero notation, and the other about how to translate be-
tweenoctal and decimal numbers. Perhapsthis indicatesthat there
may be room to reduce the complexityof the code snippet further,
byfactoringitintotwoseperatemore‘minimal’atomcandidates
instead.
Atom Candidates:OctalNotationand Conversion
Atom Candidate Code Value
Leading-ZeroNotation printf("%o", 07+010) 17
Decimal-to-OctalConversion printf("%o", 15) 17
StringasPointer. InC,astringisrepresentedasapointertoaseries
ofsequentialcharactersinmemory, wherethelastcharacterisin-
dicated by a null byte. This is why strings are declared as char*or
łpointertoacharacterž.Itwouldappear,though,thatthespecialized
nickname ‘string’ or something about its conventional representa-
tion may obscure its underlying structure to some programmers.
Snippet 91 was designed to test whether programmers understood
thattheargumentstothearray-subscriptoperator(squarebrackets
[])canbeswappedwithoutaffectingtheprogrambehavior.One
of our subjects nearly evaluated the snippet incorrectly not due to
misunderstanding the subscript operator, but instead because he
didnotrealizestringswerejustpointers:łIhaveseenitonsome
612Thinking Aloudabout Confusing Code ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA
of the class material once where, you know, that was, you know,
professor was just going through it and he said that this or that
wouldn’tmatter.AndI,Ididtryitwithan intbecauseIjustwanted
to check to be sure, it did work, but you know, I kind of initialized
anarraybeforeandthenItrieditlikethiswiththeindexandthe,
youknow,basepointer,butIhaven’tdonethatwithstrings...but
thisisnotabasepointer,butIdounderstandit’sastringandI’m
reallyshakywhenitcomestostringsinCž[4281:91].Itmightbe
valuabletomeasuretheconfusingnessofthepointerrepresentation
of strings independently, to learn how well subjects understand
them:
Atom Candidate: String as Pointer
void main() {
char*x = "abc";
char y = *(x + 1);
printf("%c", x);
}
Obfuscatedvoid main() {
char[] x = {'a','b','c'};
char y = x[1];
printf("%c", x);
}
Simplified
Logical Operator Outside of Condition. TheImplicit Predicate atom
impliesaperceivedconnectionbetweenconditionalstatementsand
logical operators. The atom shows that it is more confusing to use
anifstatement (for example) without an equality operator than
with one. Conversely, if programmers have learned a conventional
association between conditions and logical operators, perhaps the
presenceoflogicaloperatorsinabsenceofan ifstatementor while
loopisitself confusing.
Snippet 49, designed to test the Conditional Operator atom, also
caused perceived ambiguity over the precedence of its operators in
thisstatement: int V2 = V1 == 3 ? 2 : 4; Subject4281,unsureof
whethertoparsetheconditionalexpressionas: V1 == (3 ? 2 : 4) or
(V1 == 3) ? 2 : 4 madeastatementtothiseffect:ładoubleequal-
to can only be there for the conditionž [4281:49], and used this
reasoning to help infer rules about operator precedence. Despite
helpinghimcorrectlyevaluatesnippet49,thisunderstandingofthe
usageofthe ==operatorisincorrect.Actually,theequalityoperator
is used in an expression like any other, and can be used in any
context that can receive an int(specifically 1 or 0).To subject 4281,
however, the logical operator is inseparable from its conditional
context, and would not have a value if it were: łIt cannot be there
for any other reason but for a condition... Nothing comes out of
thisž [4281:49].
It would appear that the conventional relationship between con-
ditional statements and logicaloperands is so pervasive thatsome
programmershaveinducedthatitisbyspecification.Perhapsnever
havingseenalogicaloperatoroutsideofaselectorloopingstate-
ment, the programmer believes that itisnot allowedto happen.
Atom Candidate: Logical OperatorOutsideofCondition
void main() {
int x = 1 == 2;
printf("%d", x);
}
Obfuscatedvoid main() {
int x = 0
if (1 == 2) {
x = 1;
}
printf("%d", x);
}
Simplified5.2 Challenges oftheModel
Gopsteinetal.introducedthenotionofatomsofconfusionasaway
tosimplifytheprocessofprogramcomprehensiontoapointwhere
it can be precisely and reliably measured. The primary mechanism
forgainingthatprecisionwastheminimalityandatomicityofcode
snippets. Part of what our study is demonstrating is that talking
about code and human comprehension in such dichotomous terms
isnotthemostaccuratemodel.Wehaveseenseveralexamplesthat
undermined theconcept of homogeneity ofconfusion, minimality
of confusion, and evaluation as a precise proxy for comprehension.
Homogeneousmisunderstanding. ThewayGopsteinetal.presented
their15examplesofconfusingcodepatternsimpliedthatmisun-
derstandingwas a trait inherent to the code itself, independent of
thesubjectsonwhichtheywerevalidated.Whatwehaveseenin
our study is that there is considerable variance across our subjects’
typesofmisunderstandingsduringevaluation,evenforthesame
code snippet. Sometimes this is affected by obvious factors such
asexperience,butsometimesitissubtlefactorssuchaspersonal
experience with a given construct or even the specific mnemonics
aprogrammerhasusedtomemorizeaparticularquirkofthelan-
guage.Regardless,themoreevidencewesee,thelesslikelyitseems
thatanyparticularcodesnippetislikelytobeuniversallyconfusing
orsimpleacrossallprogrammers.Infact,itisunclearwhetheror
notspecificconstructscanbeselectedtobeconfusingforevena
specific demographic, as each programmer is an individual with
theirownmastery andmisconceptions unique to themselves.
One example is various programmers’ misunderstandings of the
Boolean value of integers when evaluated in a logical operation. In
C,valuesaregenerallyconsidered‘falsy’iftheyevaluateto 0and
‘truthy’ otherwise. For example, logical conjunction is specified
to behave as follows: łThe &&operator shall yield 1if both of its
operandscompare unequalto 0; otherwise,it yields 0.The result
hastype intž[13].However,weobservedseveraldifferentbeliefs
regarding the Boolean valueof integers.
Considerthesethree differentexamples of incorrectsemantics:
•The only valid integersinalogical contextare 1and0
śłyou cannot evaluate two to true, but you usually can
evaluate zero and one... to other boolean typesž [3316:11]
•Integersare not valid inalogical context,at all
śłIt’sconfusingbecausezeroandone...what?Whatdoes,
what’s zero and one, what does? How would I... I don’t
knowwhat itmeans.ž[3787:11]
•Allintegersare true because they exist
śłI mean we’re using zero here for the if, and zero is an
integer. So it, it is true. I mean zero does exist.ł [3787:109]
Given that there is such a diverse set of misunderstandings around
asingleconstruct,itmaynotbeappropriatetoclaimthatthereisa
singlesourceofconfusionthat causes allof them.
Mutually exclusive atoms of confusion, minimality, and atomicity.
PartofGopsteinetal.’srestrictionto‘minimal’codesnippetsmeant
thatnoexampleofanatomofconfusioncouldcontainanyother
confusing code beyondwhat was being tested.Unfortunately,this
necessarily precludes the possibility that two potential atoms of
confusionmightsharecommonconceptualground.Oneexample
concerns expressions with side effects. Several responses in our
613ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA Dan Gopstein, Anne-Laure Fayard, SvenApel,JustinCappos
studyhaveindicatedthatcodethatmutatesstateaspartofalarger
expressionisinherentlyconfusing.Examplesofthistypeofconfus-
ingcodecanbequiteminimal,suchas a = b++ora = b()(assuming
b()produces side effects). The first example has been shown to be
confusing as a Post-increment atom,while thesecond has not. Evi-
dence from our study and other studies [ 1], however, suggests that
thelatterisagoodcandidatetobeanatom.If,however,sideeffects
are shown to be confusing and become a new atom in their own
right, this makes existing atoms such as a && b()(Logic as Control
Flow)ora = (b(), c) (CommaOperator )non-minimal,sincethey
mustcontainthe Side-effectingExpression atom.Giventheconfusing
natureofshort-circuiting,though, the LogicasControlFlow atom
islikelytobesignificantlymoreconfusingthantheside-effecting
expressionitwouldcontain.Toputitdifferently, a && b()iscon-
fusing, it cannot have any part of it removed while retaining its
levelofconfusion,anditcannotbewrittenwithoutaside-effecting
expression. If side-effecting expressions are ever validated as an
atomofconfusion,thiswouldsuddenlycause a && b()tonolonger
beminimal,andthereforenotviableasanatomicunitofconfusion.
Thiscontradictionmightforceadifficultchoicebetweenseveral
valid atoms.Alternatively, itmaypointto aconceptual shortcom-
inginthedefinitionofatomsofconfusion.Perhapsthenotionof
atomicityislimited;theideathatthereisacertainthresholdlevelof
confusionbelowwhichcertaincodeissimpleandabovewhichitis
confusing.If,instead,weacceptthatallcodeexistsonaspectrumof
understandability, and some code is easier to understand and some
harder,there cannolongerbea conceptofaminimallyconfusing
pieceof code,because allbut thesmallestexpressionscanalways
bemadesmallerattheexpenseofsomeconfusingness.Conversely,
this lets us talk about several related, cooperatively non-atomic
pieces of code that have varying levels of confusingness despite all
sharingrelated constructs.For example, a && b++,a = b++,andb++.
Itislikely that eachisconfusing,but to differing degrees.
Evaluationvs.Comprehension. Perhapsthecoreassumptionofre-
searchonatomsofconfusionistheuseofthecorrectnessofsource
code evaluation as a proxy for program comprehension. In any
specificcontext,thiscorrespondencemayremainvalid,however,
evidence from our study indicates that individual understanding is
notmonotonic.Section 4.3(CorrectforWrongReason )demonstrates
thataprogrammerwhocanevaluateasmallsnippetofcodemay
be able to understand the same code in another context. Even in
circumstanceswheresubjectscorrectlyevaluatedasnippet,occa-
sionallycertainassumptionstheymadepossiblywouldnothave
beenmadeinthecontextofalargerprogram,orwouldnothave
leadthemto acorrectanswer inthat case.Consequently,the rela-
tionship between evaluation results and claims of comprehension
maynotalwaysbetrueforthetypesofcodeshowninthesestudies,
let alone generalize to more typical code seen in larger code bases.
5.3 Threatsto Validityin PreviousStudies
Outsideofconfusingprogrammingconstructs thathavepotential
tobeatomsthemselves,wediscoveredseveralunintentionalfea-
turesofthecodesnippetevaluationprotocol.Theseraisethreatsto
validityincodeevaluationstudiesofthetypeusedinGopsteinetal.
Eachoftheexamplesbelowrepresentexceptionstotheintendedre-
searchquestionsofGopsteinetal.Someintroduceconfusionwherethey should not, others add mechanisms of inferring correct an-
swers where they should not, and still others rely on non-standard
features ofthe C language.
5.3.1printfis Confusing. The basis for hand-evaluation experi-
mentsisforthesubjecttoreportthestandardoutputoftheprogram
in question. In C, the canonical method of generating standard out-
put is with the stdiofunction printf. It is famous for its esoteric
API thatisrarelyfully learnedbyusers.Manysubjects,especially
the professionals, called this out as a potential source of confusion:
łprintfandthepercentthingsIprettysureIremembermostofthem
and I’m pretty sure percent c prints the character, but I, I check the
manpageeverytimeIhavetouseonethose.ž[1879:91],andłwe’ve
got a float and we’re printf’ing it with a percent d I never know
aboutprintfsyntax, I never use it[nervous laughter]. ž[1867:115]
According to the original description of atoms of confusion, cer-
taintypesofconfusionwereexcludedfromthestudy,includingAPI
relatedconfusion,whichappearstobeexactlywhat printfinduces.
Potential alternatives include providing documentation along with
the experiment, or using C++’s coutobject, which does not require
a format specifier. Both of these solutions have downsides and
neither isideal, but abettersolution isworth considering.
5.3.2 Relying on the Correctness of the Example. The introductory
text to our study said łEach program compiles and runs without
errorž. A somewhat popular tool amongst subjects was to leverage
that facttomakeassumptionsaboutthecode.łI justremembered
everyprogramexecutes.Sothis,mythinkingofthisnotworking
iswrongž[3316:37].Inpractice,programmerslikelywillnothave
these types of assurances and cannot rely on the fact that arbitrary
code isguaranteednot to produce an error.
5.3.3 Variable Names. The snippets included in our study were
designednottoincludesemanticbeacons[ 24],whichmighttele-
graphthemeaningofthecodetotheprogrammerbeforetheyfully
comprehendhowitworks.Partofthisprocesswastherenamingof
all variables to V1,V2,V3, etc. However, there were examples where
perhaps the naming of the variables induced otherwise unlikely
errors. For example, in snippet 61, variables V1andV2contained
thevalues 2and1respectively,effectivelyswappingthecontents
ofthenamesandvalues.Subject4304madeitclearthatheknew
which variable contained which value, however, when writing his
responseheaccidentallyswappedthem.Oneobviouswaythismay
have happened was by subconsciously writing the number con-
tainedinthenameofthevariable,ratherthanthevalueitcontained.
Infutureexperiments,itmaybebeneficialtouseavariablenaming
scheme that willnot overlap withthe storedinformation.
5.3.4 Redefining Macros. The snippet included in our study to
represent the Preprocessor in Statement atom, contains a macro
redefinition.Therearetwo #define’softhesameidentifierinthe
same file, without an #undefbetween them. The C specification
(Section 6.10.3.2) [ 13] specifically says this is invalid: łan object-
like macro shall not be redefined by another #definepreprocessing
directivež.Andthiswasbroughtupbyoneofthesubjects:łright
here we have like, uh, a redefinition of both M1 and M2 to be
different things. Um,and I’m not positive.I, Ithink that’snot well
defined.Um,andIthinkthatshouldbeacompilererror,butitcould
alsobelikeoverwritetousethelikethelatteronež[7640:71].There
614Thinking Aloudabout Confusing Code ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA
wassomecontroversyherethoughasasecondsubjectclaimedit
wasvalid łLikeifyou’redefining avalue inthepreprocessor,and
it’s already set, but if you set it again, they will not warn you or
whatever.Itjustletsyouoverrideit.ž[8697:71].Interestingly,this
behavior is documented as being allowed by GCC: łIf a macro is
redefinedwithadefinitionthatisnoteffectivelythesameastheold
one,thepreprocessorissuesawarningandchangesthemacrotouse
thenewdefinitionž[ 10].Itisunclearwhetheradding #undef’swould
make the code less confusing, but the current version is not the
bestexamplefromwhichtobaseconclusionsaboutcomprehension.
AnotherfactorworthconsideringiswhethertheCpreprocessor,
arguablyanindependentlanguage,oughttobestudiedatthesame
time the C language proper, as the preprocessor is known to be
usedinwaysthat conflictwiththe underlying language[ 16].
5.3.5 Void Main. Presumably for brevity, all code snippets are
written using voidreturn types on the mainfunction. C technically
does not allow this (despite several compilers being permissive
aboutit),andmanyprofessionalscomplainedaboutit:łRightoff
the bat it’s void main, uh, which is, I feel like I’m back in Java land.
So, uh, it should be intž [8697:71], łThe thing I was a little tweaked
out by, is that void mainž [8888:73], łOh, so they are all void main.
Oh, that’s lovely.ž [1879:85], łUh, main is void. That’s a little bit
strange to mež [7640:19]. Changing the type of the mainfunction
tointwould also necessitate adding another line to each program,
returning 0.Thisreturnvaluemightinturncomplicatethesubjects’
understandingofwhatvaluetoreportas‘output’.Still,itisclear
thatvoid main isnot an acceptable idiom inastudy like this.
5.4 ImprovingQuantitativeExperiments
throughQualitativePilots
The previous sections outline many flaws in an otherwise thought-
fully designed quantitative experiment. We contend that issues
like these are not unique to this experiment, but likely manifest in
different forms in many program comprehension experiments. Our
experience illustrates how performing a qualitative study allowed
usto make visiblemanyissuesthat we didnot originallyforesee.
In our case, the quantitative and qualitative portions of these
studies were conducted sequentially as two separate endeavors.
Thefindingsofourstudymayhelpdesignfuturequantitativeex-
periments that explore some of the questions that emerged from
thisstudy.However,ifGopsteinetal.haddoneathink-aloudstudy
prior to designing their original experiment, they most probably
wouldhavefoundlimitationssimilartotheoneswefoundandcould
haveavoidedthem.Indeed,whileGopsteinetal.reportconducting
a pilot study for their experiment, it was solely done to estimate
statisticalpowertochooseasamplesize.Therefore,werecommend
toresearchersdevelopingnewtypesofprogramcomprehensionex-
periments to begin by validating their approach qualitatively prior
to conducting their full quantitative experiments. While the effort
involvedinourstudywassignificant,andprobablyprohibitiveto
researchers for whom it would be only a pilot test, we believe that
itispossibletousesimilarapproaches,yetinalesstimeconsum-
ing fashion. While we made sure to reach theoretical saturation
when analyzing our data, as this was a stand-alone study, the main
themes emerged after we analyzed the first half of the participants
andcould have informedthe designofaquantitative study.6 CONCLUSION
Atoms of confusion [ 11] are a model for conceptualizing, mea-
suring,andcomparingsmall,hard-to-evaluatepatternsinsource
code.Previousresearchusedexperimentalapproachestovalidate
and quantify the effectsof these patterns. To further contextualize
the existing body of work, and to provide a richer description of
subject’sunderlyingreasoning,weperformedaqualitativeinves-
tigation of the same phenomenon. Specifically, we conducted a
think-aloudstudyofprogrammershand-evaluatingatomsofcon-
fusion and their associated simplified code pairs. The observations
made in this paper offer insights for future research on atoms of
confusionaswellasformoregeneralhandevaluationstudieson
program comprehension.
Asthesecond(qualitative)studyinanexplanatorysequential
mixed-methods design [ 7], our study was designed to give context
to the results presented by Gopstein et al. [ 11]. We wanted to go
beyond the dichotomous data presented before, and describe more
than just whether or not a programmer correctly evaluated a code
snippet. We wanted to understand and describe how programmers
evaluated code, what steps they took, what pitfalls they hit, and
how they evaluated unknown constructs. We arrived at a com-
montaxonomythatwasabletonaturallycategorizemanyofthe
incorrect evaluations in our study and that shows that not all mis-
understandingscome from the same mechanism. We investigated
responses given bysubjects whose hand-evaluationswere correct
and learned that correct answers do not alwaysimply correct rea-
soning on behalf of the subject. By using a qualitative research
approach, we were able to see that, even for the data points that,
in a quantitative study, would look absolutely correct, there was
stillsignificantconfusionthatwouldotherwisegounnoticed.In-
sights like these allow us to look back on previous research and
understand it with new depth. We can see that hand-evaluation
studiesmaybeunder-reportingtheamountofmisunderstanding,
since correct responses are now shown not to necessarily imply
completeunderstanding.Furthermore,wecanseethat,justbecause
errorsare beingobserved,they are not alwaysdueto the factors
the experiment wasdesignedto test.
Beyond understanding previous work, we identified several key
factorsthatcanhelpdesignsimilarexperimentsinamorerigorous
wayaswellasentirelynewstudiestoexplorefurtherideas.Simple
changes can help give more accurate results such as avoiding com-
plex APIs like printf. We can expand the current understanding
of what code is confusing by empirically validating more atoms of
confusion. Finally, we have seen ways in which the current model
ofconfusionislimiting.Definingconfusionasadichotomousevent,
something that either occurs or not, simplifies a very complex phe-
nomenon. Instead, it may be valuable to consider a more flexible
andcomplexmodelofconfusion,onethatisbasedonobjectiveem-
piricalevidenceandquantitativemeasurementandthusaccounts
forarbitraryformsofcodeandthevariationbetweenprogrammers.
ACKNOWLEDGMENTS
WewanttothanktheparticipantsinourstudyfortheirtimeWe
are also grateful to Gennadiy Civil for helping to organize and
encourage thisresearch.This work was supportedinpart byNSF
grants 1444827 and1513457 as well as DFGgrant AP 206/14-1.
615ESEC/FSE ’20, November8ś13,2020,VirtualEvent, USA Dan Gopstein, Anne-Laure Fayard, SvenApel,JustinCappos
REFERENCES
[1]MarwenAbbes,FoutseKhomh,Yann-GaelGueheneuc,andGiulianoAntoniol.
2011. An empirical studyof the impact of twoantipatterns,Blob and Spaghetti
code, on program comprehension. In Proceedings ofthe European Conference on
SoftwareMaintenance and Reengineering . IEEE,181ś190.
[2]Mahnaz Behroozi, Alison Lui, Ian Moore, Denae Ford, and Chris Parnin. 2018.
Dazed: Measuring the cognitive load of solving technical interview problems
at the whiteboard. In Proceedings of the International Conference on Software
Engineering: New Ideas and Emerging Technologies Results (ICSE-NIER) . IEEE,
93ś96.
[3]TeresaBusjahn,CarstenSchulte,andAndreasBusjahn.2011. Analysisofcode
readingtogainmoreinsightinprogramcomprehension.In Proceedingsofthe
11thKoliCallingInternationalConferenceonComputingEducationResearch .ACM,
1ś9.
[4]Fernando Castor. 2018. Identifying confusing code in Swift programs. In Pro-
ceedings ofthe VI CBSoft Workshop on Visualization, Evolution, andMaintenance .
ACM.
[5]Elizabeth Charters. 2003. The use of think-aloud methods in qualitative research
anintroductiontothink-aloudmethods. BrockEducation:AJournalofEducational
Research and Practice 12,2 (2003), 68ś82.
[6]JulietCorbinandAnselmStrauss.2014. BasicsofQualitativeResearch:Techniques
and Proceduresfor Developing GroundedTheory . SagePublications.
[7]John W. Creswell and J. David Creswell. 2017. Research Design: Qualitative,
Quantitative, and MixedMethodsApproaches . SagePublications.
[8]Beth Davey. 1983. Think aloud: Modeling the cognitive processes of reading
comprehension. Journal ofReading 27,1 (1983), 44ś47.
[9]BarneyG.GlaserandAnselmL.Strauss.1967. TheDiscoveryofGroundedTheory:
Strategies for QualitativeResearch . AldinedeGruyter.
[10]GCCGNUCompilerCollection.(accessedMarch4,2020). TheCPreprocessor:Un-
defining and Redefining Macros .https://gcc.gnu.org/onlinedocs/cpp/Undefining-
and-Redefining-Macros.html
[11]DanGopstein,JakeIannacone,YuYan,LoisAnneDelong,YanyanZhuang,Martin
K.-C. Yeh, and Justin Cappos. 2017. Understanding misunderstandings in source
code. InProceedings of the Joint Meeting of the European Software Engineering
Conference and the ACM SIGSOFT Symposium on the Foundations of Software
Engineering . ACM,129ś139.
[12]Dan Gopstein, Hongwei Henry Zhou, Phyllis Frankl, and Justin Cappos. 2018.
Prevalence of confusing code in software projects: Atoms of Confusion inthewild.InProceedingsoftheInternationalConferenceonMiningSoftwareRepositories .
ACM,11pages.
[13] ISO. 1999. ISO/IEC9899:1999:ProgrammingLanguages ÐC . 538pages.
[14]ISO. 2011. ISO/IEC 14882:2011 Information technology Ð Programming languages
Ð C++(third ed.). http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_
detail.htm?csnumber=50372
[15]Brian W Kernighan and Dennis M Ritchie. 1998. The C Programming Language-
ANSICVersion.
[16]Jörg Liebig, Christian Kästner, and Sven Apel. 2011. Analyzing the discipline
ofpreprocessorannotationsin30millionlinesofCcode.In Proceedingsofthe
International ConferenceonAspect-OrientedSoftware Development . ACM, 191ś
202.
[17]Flávio Medeiros, Gabriel Lima, Guilherme Amaral, Sven Apel, Christian Kästner,
MárcioRibeiro, and Rohit Gheyi. 2019. An investigationofmisunderstanding
codepatternsinCopen-sourcesoftwareprojects. EmpiricalSoftwareEngineering
24,4 (2019), 1693ś1726.
[18]Tobias Röhm, Rebecca Tiarks, Rainer Koschke, and Walid Maalej. 2012. How do
professionaldeveloperscomprehendsoftware?.In ProceedingsoftheInternational
Conference onSoftwareEngineering . IEEE,255ś265.
[19]CarolynB.Seaman.1999. Qualitativemethodsinempiricalstudiesofsoftware
engineering. IEEE Transactions onSoftwareEngineering 25,4 (1999), 557ś572.
[20]Janet Siegmund, Norbert Siegmund, and Sven Apel. 2015. Views on internal
and external validity in empirical software engineering. In Proceedings of the
InternationalConference onSoftwareEngineering , Vol. 1.IEEE,9ś19.
[21]Maarten W. Van Someren, Yvonne F. Barnard, and Jacobijn A. C. Sandberg. 1994.
TheThinkAloudMethod:APracticalApproachtoModellingCognitiveProcesses .
Academic Press Inc.
[22]Klaas-Jan Stol, Paul Ralph, and Brian Fitzgerald. 2016. Grounded theory in
softwareengineeringresearch:Acriticalreviewandguidelines.In Proceedingsof
the InternationalConference onSoftwareEngineering . IEEE,120ś131.
[23]Anselm L. Strauss. 1987. Qualitative Analysis for Social Scientists . Cambridge
UniversityPress.
[24]SusanWiedenbeck. 1986. Beaconsin computerprogramcomprehension. Inter-
nationalJournal ofMan-MachineStudies 25,6 (1986), 697ś709.
[25]Aiko Yamashita and Leon Moonen. 2013. Towards a taxonomy of programming-
relateddifficultiesduringmaintenance.In ProceedingsoftheInternationalCon-
ference onSoftwareMaintenance . IEEE,424ś427.
616