Practical Inference ofNullabilityTypes
NimaKarimipour∗
nima.karimipour@email.ucr.edu
University ofCalifornia,Riverside
Riverside, California,USAJustinPham
jpham079@ucr.edu
University ofCalifornia,Riverside
Riverside, California,USA
LazaroClapp
lazaro@uber.com
UberTechnologies
SanFrancisco, California,USAManu Sridharan
manu@cs.ucr.edu
University ofCalifornia,Riverside
Riverside, California,USA
ABSTRACT
NullPointerException s (NPEs), caused by dereferencing null, fre-
quentlycausecrashesinJavaprograms.Pluggabletypecheckingis
highlyeﬀectiveinpreventingJavaNPEs.However,thisapproach
is diﬃcult to adopt for large, existing code bases, as it requires
manually inserting a signiﬁcant number of type qualiﬁers into the
code. Hence, a tool to automatically infer these qualiﬁers could
make adoption oftype-basedNPE prevention signiﬁcantly easier.
Wepresentanovelandpracticalapproachtoautomaticinference
of nullability type qualiﬁers for Java. Our technique searches for
asetofqualiﬁersthatmaximizestheamountofcodethatcanbe
successfullytypechecked.Thesearchusesthetypecheckerasa
blackboxoracle,easingcompatibilitywithexistingtools.However,
this approachcan be costly, as evaluating the impact of a qualiﬁer
requires re-running the checker. We present a technique for safely
evaluating many qualiﬁers in a single checker run, dramatically
reducingrunningtimes.Wealsodescribeextensionstomakethe
approach practical in areal-world deployment.
We implemented our approach in an open-source tool N/u.sc/l.sc/l.sc/hyphen.sc
A/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc ,designedtoworkwiththeNullAwaytypechecker.
We evaluated N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc ’s eﬀectiveness on both open-
source projects and commercial code. N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc re-
ducesthenumberofreportedNullAwayerrorsby69.5%onaverage.
Further,our optimizationsenable N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc to scale
to large Java programs. N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc has been highly
eﬀective in practice: in a production deployment, it has already
beenusedtoaddNullAwaycheckingto160productionmodules
totalingover1.3million lines ofJavacode.
CCSCONCEPTS
•Softwareanditsengineering →Softwareveriﬁcationand
validation .
KEYWORDS
pluggable type systems,nullsafety,staticanalysis,inference
∗Thisworkwas partiallycompleted during an internshipat Uber Technologies Inc.
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby theowner/author(s).
ACM ISBN 979-8-4007-0327-0/23/12.
https://doi.org/10.1145/3611643.3616326ACM Reference Format:
NimaKarimipour,JustinPham,LazaroClapp,andManuSridharan.2023.
Practical Inference of Nullability Types. In Proceedings of the 31st ACM
JointEuropeanSoftwareEngineeringConferenceandSymposiumontheFoun-
dations of Software Engineering (ESEC/FSE ’23), December 3–9, 2023, San
Francisco, CA, USA. ACM, New York, NY, USA, 12pages.https://doi.org/10.
1145/3611643.3616326
1 INTRODUCTION
NullPointerException s (NPEs), caused by a dereference of null,
areawell-knownandcommoncauseofcrashesinJavaprograms.
Hence,therehasbeenagreatdealofpastresearchonpreventing
nulldereferences(e.g.,[ 17,22,24,28]).Type-basedapproachesto
nullnesscheckingaregrowinginpopularity.Inthisapproach,types
includeinformationonwhethereachexpressionmayevaluateto
null,andonlyexpressionsthatcannotbe nullcanbedereferenced.
RecentlanguageslikeKotlin [21]andSwift [35]buildnullsafety
intotheirtypesystems.Further,pluggabletypecheckerslikethe
Checker Framework [ 9,28], Eradicate [10], Nullsafe [ 31], and Null-
Away[4]leveragetypequaliﬁers[ 13]toaddtype-basednullness
checkingtoJava.
Type-based nullness checking can be diﬃcult to adopt for exist-
ingJavacodebases,duetotheneedtomanuallyaddtypequaliﬁers
intothecode.Toenableincrementalandmodularchecking,type-
based nullness checkers require explicit nullability annotations on
ﬁeld, parameter, and return types. Hence, manual eﬀort is required
to annotate any existing program for a type-basedchecker. While
default assumptions for unannotated types reduces the annotation
burdenconsiderably[ 28],asigniﬁcantnumberofexplicitannota-
tionsmuststillbewritten.1Ourgoalistodevelopatoolforauto-
matically inferring nullabilityqualiﬁersforexistingcode,thereby
dramatically easingadoption of type-basednullness checking.
Wedesireapracticalinferencetoolthatcanbeusedwithreal-
world code bases and type checkers, and as such have three key
requirements.First,werequireatoolthatprovidesa“besteﬀort”
partialsolutionincaseswhereaprogramcannotbeveriﬁedwithout
code changes. Existing code may have real bugs, or may be correct
butwritteninastylethatisnotamenabletotype-basedveriﬁcation.
Insuchcases,aninferencetoolcanstillprovidesigniﬁcantvalueby
addingannotationsthatenabletypecheckingof mostoftheoriginal
program.Thisway,mostnewly-addedormodiﬁedcode(veryoften
1Banerjee et al . [4]report an average of roughly 13 explicit annotations per KLoC on
their open-sourcebenchmarks, ranging up to 46 annotationsper KLoC.
Thiswork islicensedunderaCreativeCommonsAttribution4.0Interna-
tional License.
1395
ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Nima Karimipour,JustinPham, Lazaro Clapp, andManu Sridharan
thesourceofdefects[ 26])willbetypechecked,whiledevelopers
can gradually adopt andenable checking for the remaining code.
Second,werequiretheinferencetooltoworkalongsideanex-
isting type checker implementation. Inference approaches often
require a type checkerthatsupports bothcheckingand inference
directly,e.g.,using constraintgeneration and solving.Ourtoolin-
fersannotationsfortheexistingproduction-qualityNullAwaytype
checker [ 4], which does not use constraints. While the constraint-
based approach is elegant and eﬃcient, re-implementation of a
complexcheckerlikeNullAwaytouseconstraintswouldrequire
a huge eﬀort. For example, NullAway employs ad hochandling
ofvariouscodingpatternsandlibraries(e.g.,streamlibrariesand
gRPC[15]) to reduce false positives [ 27], and this customized han-
dlinglogicwouldhavetobeencodedpreciselyusingconstraints.To
avoid re-implementation, we desire an inference approach that pri-
marily treats the type-checking tool as ablack-box oracle,relying
only onits reportederrorsto perform inference.
Third,werequire theinferencetooltobeperformant. Forour
use cases, the tool must be able to run in an overnight job (roughly
8hoursmaximum).Withalongerrunningtime,deploymentofthe
tool becomes less practical, due to the compute resources required,
and the fact that the target code could be changing frequently.
We are unaware of any existing approach that meets these three
requirements.
In this paper, we present a novel approach to nullability type
inference suited to these requirements. Given an unannotated pro-
gram,ourapproachsearchesforasetoftypequaliﬁersthatmini-
mizestheremainingnumberofNullAwayerrors,therebymaximiz-
ingthe amountofcodeNullAwayis ableto type check.Findinga
goodsetofqualiﬁersisnon-trivial;wefoundthateagerlyinsert-
ing all possible qualiﬁers could increasethe ﬁnal number of errors.
Our strategy evaluates candidate qualiﬁers using a bounded-depth
search, iteratedto aﬁxedpoint.
A naïve implementation of our search strategy is too slow for
large code bases. When treating the type checker as a black-box
oracle,evaluatingtheimpactofacandidatequaliﬁerontheerror
countrequiresre-runningthetypechecker.ThoughNullAwayis
highly optimized [ 4], each run still requires a re-compilation of the
code and can take tens of seconds or longer. For larger programs, a
straightforwardversion of our searchrequiredrunning over1,000
builds,makingthe tooltooslow.
Ourkeyinsightisthatmanyqualiﬁersimpacttheerrorcount
independently of each other. Since NullAway performs modular
checking, the code regions where new errors may appear due to
qualiﬁerinsertionarelocalizedandcanbecomputedaheadoftime.
Giventhisinformation,weconstructagraphrepresentingwhich
candidate qualiﬁers may “conﬂict” by causing new errors in an
overlapping region. Then, we use graph coloring to ﬁnd sets of
non-conﬂictingqualiﬁers,whichcanallbetestedsimultaneously
withinasingleNullAwaybuild.Withthisapproach,manyfewer
runsofNullAwayarerequired,dramaticallyreducingrunningtime
andmakingthe toolpractical.
Wealsodescribeextensionstoourtechniqueforhandlingreal-
world code patterns and deployment. We show how our algorithm
can incorporate usage information from client code when annotat-
ingalibrary,signiﬁcantlyeasingdeploymentinalarge,modular1classTest {
2+@Nullable Object f1 = null;
3+@SuppressWarnings("NullAway") Object f2 = null;
4+@Nullable Object f3 = null;
5+@Nullable Object f4 = null;
6+@Nullable Object f5 = f4;
7String m1() {
8returnf1 !=null? f1.toString() : f2.toString();
9}
10intm2() {
11 returnf3 !=null? f3.hashCode() : f2.hashCode();
12}
13+@Nullable Object m3() {
14 returnf4;
15}
16}
Figure1: Motivating examplefor inference. Greentext indi-
cates where annotationsareinserted by our technique. Our
tool chooses to suppress the error on line 3, to maximize the
amount ofcodechecked by NullAway.
codebase.And,wedescribeaspecializedhandlingofﬁeldinitial-
izationto betterhandle certaincommon patterns.
We implemented our approach in an open-source tool N/u.sc/l.sc/l.sc/hyphen.sc
A/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc ,whichgeneratesannotationssuitablefordirectly
enablingNullAwaychecking.Weperformedanextensiveempirical
evaluation,onbothopen-sourceprojectsandasetofcommercial
code modules at Uber Technologies Inc. (Uber). The evaluation
showed that N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc decreased the ﬁnal number of
errors reported by NullAway by an average of 69.5% (36.9%–90.1%).
Further,ouroptimizationswerecriticalforacceptableperformance,
reducing running time by an average of 6.1X (2.0X–17.8X) and
eliminating two timeouts. N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc is deployed at
Uber for direct use by developers, and it has beenhighly eﬀective:
ithasbeenusedtoenableNullAwaycheckingfor160production
modules, totaling over 1.3 million linesof code.
This paper makesthe following key contributions:
•We present a technique to infer type qualiﬁers that make
as much of an existing program as possible veriﬁable by
NullAway,whiletreating NullAwayas ablackbox oracle.
•Wedescribeanoptimizedsearchthatleveragesconﬂictde-
tection via graph coloring to simultaneously evaluate many
candidate qualiﬁers, reducing running time.
•We present an open-source implementation of the approach,
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc , and show its eﬀectiveness in an ex-
tensive experimental evaluation.
2 OVERVIEW
In this section, we give an overview of our nullability inference
technique and present relevant background. We illustrate our tech-
nique using the example code inFigure 1.
1396Practical Inference of Nullability Types ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
2.1 Type-BasedNullness Checking
Webrieﬂyintroducekeyideasoftype-basednullnesschecking;see
theliteraturefordetails[ 4,9,28].Type-basednullnesscheckersfor
Java use type qualiﬁers [ 13] to capture whether a type includes or
excludes null.ThesequaliﬁersarewritteninsourcecodeusingJava
annotations,preﬁxedwith @.Suchcheckerstypicallyuse @Nullable
toqualifyatypethatcontains null,and@NonNull foratypethatdoes
not.Anunqualiﬁedtypeistreatedas @NonNull bydefault,except
for local variables, whose qualiﬁers are inferred automatically [ 28].
Giventhesequaliﬁers,typecheckingguaranteesthata @Nullable
expression is never assigned to a @NonNull location, and that a
@Nullable expression is never dereferenced. Assuming object ﬁelds
are properlyinitialized,and thatallexecutingcode hasbeentype
checked,thesepropertiestogetherguaranteetheprogramwillbe
free of NPEs. For clarity, we defer discussing the impacts of ﬁeld
initialization checking to Section 6, and for now assume that all
@NonNull ﬁelds are appropriately initializedinaconstructor.
Consider the code example in Figure 1, ignoring the green in-
serted annotations. Running NullAway on this code will yield four
errors,oneforeachoflines 2to5,sinceeachlineassigns nullto
a@NonNull ﬁeld(@NonNull bydefaultsincetheyareunannotated).
These errors can be removed by changing the type qualiﬁer of
each ﬁeld to be @Nullable , e.g., writing @Nullable Object f2 on
line3. However, adding these qualiﬁers can lead to new NullAway
errors;e.g.,making f2 @Nullable causesanewerroronline 8,since
f2.toString() thendereferencesa @Nullable expression.Currently,
adding type-based nullness checking to an existing code base re-
quires repeatedly adding annotations and changing code manually
until noerrorsremain, atedious,time-consumingprocess.
To ensure null safety, type-based nullness checkers must also
enforcestandardsubtypingrulesformethodoverriding,i.e.,covari-
antreturntypesandcontravariantparametertypes.So,ifamethod
Super.m1(p) has a@NonNull return type and a @Nullable parameter
type,anoverridingmethod Sub.m1(p) (whereSub extends Super )
mustnothave a@Nullable return type or a @NonNull parameter
type;see further discussioninthe literature [ 4,28].
2.2 Inference Approach
Thegoalofourworkistoautomateasigniﬁcantportionofthework
required to adopt type-based nullness checking for pre-existing,
real-worldcodebases.Wefocusontheproblemofinferringasetof
@Nullable type qualiﬁers thatminimizesthenumber ofremaining
errors reported by NullAway. As noted in Section 1, we require
inference to use NullAway as a black-box oracle. Hence,checking
theimpactofasetofqualiﬁersonNullAway’serrorcountrequires
re-runningNullAwayonamodiﬁedversionoftheprogramwith
the qualiﬁers inserted. We only attempt to address errors ﬁxable
viaqualiﬁerinsertion,i.e.,errorsstemmingfromeitherassigning
a@Nullable expression into a @NonNull location or an incorrect
method override ( notdereferences of @Nullable expressions). From
such errors, we create a set of candidate ﬁxesbased on qualiﬁer
insertion,andthenuseNullAwaytotestifthoseﬁxesreducethe
overallerrorcount.
Determining the impact of a candidate ﬁx may require multiple
iterations, as ﬁxes can cause new errors which themselves are
amenable to ﬁxing. For Figure 1, adding a @Nullable qualiﬁer to ﬁxtheerroratline 3leadstotwonewerrorsatline 8andline11,both
duetodereferenceofa @Nullable expression.Sinceourapproach
cannotﬁxthesenewerrors,theline 3ﬁxincreasestheoverallerror
count and is not retained. It makes sense to leave this error for the
developer to handle, as the lack of null checks for f2on lines8
and11contradicttheinitializationof f2tonull,anditisunclear
howto automaticallyresolve this contradiction.
Addinga @Nullable qualiﬁerfortheerroronline 5alsocauses
twonewerrors,online 6andline14.However,thesenewerrors
canbeaddressedviatwomore @Nullable qualiﬁers(online 6and
the return type on line 13), and these qualiﬁers cause no further
errors, yieldingan overalldecrease. Our search discoversthe ﬁnal
solutionshowninFigure 1,whichincludesthesethreequaliﬁers.
We detailour iterative search strategy inSection 3.
To create a code change that can be adopted immediately, our
toolsuppressesanyremainingNullAwayerrorsafteritssearchis
complete;forFigure 1,weinsertthe @SuppressWarnings annotation
on line3. Adding suppressions is not ideal, since they may mask
realNPEbugsremaininginthecode.However,akeybeneﬁtofthis
approach is that afterremainingerrorsare suppressed, NullAway
can be enabled for all future builds of the code. Developers then
beneﬁtfromNullAwaycheckingforanysubsequentcode change
outsideofasuppressedregionoranynewly-writtencode,andre-
centcode changesare oftenthesource ofdefects [ 26]. Remaining
suppressions can be removed gradually as part of periodic code
cleanup eﬀorts. Alsonote that with this approach, the initial code
change enabling NullAway introduces no semantic changes (easing
code review) and can be generated with no manual eﬀort . Minimiz-
ing the number of remaining NullAway errors during inference
maximizes the amount of code subject to NullAway checking after
the inferredqualiﬁers are adopted.
2.3 Optimizing Performance
Anaïveimplementationofoursearchrunstooslowlyinpractice,
due to the cost of repeatedly running NullAway to evaluate candi-
datesolutions. Reducing running time therefore requiresreducing
thenumberofNullAwayrunsrequiredforinference.Thisreduction
could be achieved if multiple independent qualiﬁers could be evalu-
atedsimultaneously inasinglerunof NullAway.Twoqualiﬁersare
independent if any NullAway errors removed or caused by each
qualiﬁerareguaranteedtobeinnon-overlappingregionsofcode.
Achievingaspeeduprequireseﬃcientlycomputinglargegroups
ofindependent qualiﬁers.
Our ﬁrst key insight was that due to modular type checking,
the potential code regions where a @Nullable qualiﬁer may add or
removeerrorscanbecomputedpreciselyandcheaply.Forexample,
a@Nullable qualiﬁeronaﬁeldcanonlyimpacterrorcountswithin
methodsthatreadorwritetheﬁeld;newerrors cannotappearother
unrelatedmethods.So,fortheinitialerrorsinFigure 1,ourapproach
determines that the potentially impacted regions for @Nullable
qualiﬁers are m1forf1,m1andm2forf2,m2forf3,andm3forf4.2
Intuitively, many qualiﬁers in a large program may be indepen-
dent(e.g.,whentheyapplytoprivatestateofdistinctclasses),buta
questionremainsastohowtoquicklyﬁndlargesetsofindependent
2Each ﬁeld initializer (e.g. the right hand side of Object f5 = f4 ) is also a region,
whichweignoreherefor simplicity;seeSection 4.1for details.
1397ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Nima Karimipour,JustinPham, Lazaro Clapp, andManu Sridharan
Algorithm1 Pseudocode for unoptimizedsearch.
1:procedure F/i.sc/n.sc/d.scN/u.sc/l.sc/l.sc/a.sc/b.sc/l.sc/e.sc/Q_u.sc/a.sc/l.sc/i.sc/f.sc/i.sc/e.sc/r.sc/s.sc (/u1D443,/u1D451)
2:/u1D438←N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scE/r.sc/r.sc/o.sc/r.sc/s.sc(/u1D443)
3:/u1D439all←F/i.sc/x.scL/o.sc/c.sc/a.sc/t.sc/i.sc/o.sc/n.sc/s.sc(/u1D438)
4:/u1D439new←/u1D439all
5:while/u1D439new≠∅do
6: /u1D439good←E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc(/u1D443,/u1D439new,/u1D439all,/u1D451,/u1D438)
7: /u1D443←A/p.sc/p.sc/l.sc/y.scF/i.sc/x.sc/e.sc/s.sc(/u1D443,/u1D439good)
8: /u1D438←N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scE/r.sc/r.sc/o.sc/r.sc/s.sc(/u1D443)
9: /u1D439←F/i.sc/x.scL/o.sc/c.sc/a.sc/t.sc/i.sc/o.sc/n.sc/s.sc(/u1D438)
10: /u1D439new←/u1D439−/u1D439all
11: /u1D439all←/u1D439all∪/u1D439new
12:end while
13:return/u1D443
14:end procedure
15:procedure E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc (/u1D443,/u1D439,/u1D439all,/u1D451,/u1D438)
16:if/u1D451=0return/u1D439
17:/u1D439good←∅
18:for/u1D453∈/u1D439do
19: curFixes←{/u1D453}
20: for/u1D456∈[1,/u1D451]do
21: /u1D443′←A/p.sc/p.sc/l.sc/y.scF/i.sc/x.sc/e.sc/s.sc(/u1D443,curFixes)
22: /u1D438′←N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scE/r.sc/r.sc/o.sc/r.sc/s.sc(/u1D443′)
23: /u1D439′←F/i.sc/x.scL/o.sc/c.sc/a.sc/t.sc/i.sc/o.sc/n.sc/s.sc(/u1D438′)
24: if|/u1D438|−|/u1D438′|≥0then
25: /u1D439good←/u1D439good∪{curFixes}
26: break
27: end if
28: newFixes←/u1D439′−/u1D439all
29: ifnewFixes =∅then
30: break
31: else
32: curFixes←curFixes∪newFixes
33: end if
34: end for
35:end for
36:return/u1D439good
37:end procedure
qualiﬁers. Our second key insight was that groupsof independent
ﬁxes could be computed eﬃciently via graph coloring [ 18]. In com-
pilers, graph coloring is often used for register allocation [ 2]. In
ourscenario,twoﬁxesareindependentiftheirimpactedregions
donotoverlap.Weconstructagraphrepresentationwherenodes
represents sets of ﬁxes, and an edge between two nodes reﬂects
overlapping regions for their ﬁxes. This graph can be colored to
ﬁnd groups of ﬁxes that can be evaluated in a single NullAway
run. For our example, the f1,f3, andf4ﬁxes for Figure 1can all be
evaluated in a singlerun of NullAway (see Figure 2in Section 4).
Overall, the optimized approach reduces the number of NullAway
runsrequiredbytwoforFigure 1,andasshowninSection 8,the
reductions for real-world code are muchmore dramatic.3 SEARCH-BASED QUALIFIER INFERENCE
Inthissection,wepresentanunoptimizedversionofourinference
algorithmfor @Nullable qualiﬁers,tomakeclearhowourtechnique
explores and evaluates the space of possible qualiﬁers. In Section 4,
we present our graph-coloring-basedoptimizedsearch.
Pseudocode for the unoptimized technique appears in Algo-
rithm1.Givenanunannotatedprogram /u1D443andadepthlimit /u1D451for
evaluating ﬁxes, F/i.sc/n.sc/d.scN/u.sc/l.sc/l.sc/a.sc/b.sc/l.sc/e.sc/Q_u.sc/a.sc/l.sc/i.sc/f.sc/i.sc/e.sc/r.sc/s.sc (/u1D443,/u1D451)returns a mod-
iﬁed program with @Nullable qualiﬁers that reduce the number
of reported NullAway errors. It uses a procedure E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc
that,givenaprogram /u1D443,asetofcandidateﬁxes /u1D439,allpreviously-
considered ﬁxes /u1D439all, thedepth limit /u1D451, andthe NullAway errors /u1D438
for/u1D443, returns a set /u1D439goodof ﬁxes that reduce the NullAway error
count for /u1D443.
Bothproceduresmakeuseofthreekeysubroutines(whoseim-
plementationsarenotshown). N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scE/r.sc/r.sc/o.sc/r.sc/s.sc runsNullAway
to compute the errors it reports for a program /u1D443. Given a set of
errors/u1D438,F/i.sc/x.scL/o.sc/c.sc/a.sc/t.sc/i.sc/o.sc/n.sc/s.sc(/u1D438)ﬁrst determines the subset of errorsin
/u1D438that can be ﬁxed via @Nullable insertion (see Section 2.2). For
thatsubset,itreturnsasetcontaining ﬁxesforeacherror,i.e.,the
code locationswhere @Nullable should be inserted to ﬁx the error
(multiplelocationsmayberequiredforasingleinitializererror;see
Section6).Finally,givenaprogramandasetofﬁxes, A/p.sc/p.sc/l.sc/y.scF/i.sc/x.sc/e.sc/s.sc
returns anewprogram withthe ﬁxes inserted.
Thealgorithmproceedsasfollows. F/i.sc/n.sc/d.scN/u.sc/l.sc/l.sc/a.sc/b.sc/l.sc/e.sc/Q_u.sc/a.sc/l.sc/i.sc/f.sc/i.sc/e.sc/r.sc/s.sc
runs a ﬁxed-point loop (lines 5–12), inserting ﬁxes determined
byE/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc to reduce the error count until no new ﬁxes
canbefound.In E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc ,ifthedepthlimit /u1D451=0,allﬁxes
areassumedtobegood(line 16),leadingtotheireagerinsertion.
Otherwise, for each ﬁx /u1D453∈/u1D439, the algorithm iteratively applies /u1D453
andanynewﬁxesdiscoveredafterapplying /u1D453uptosomemaximum
depth/u1D451(lines18–35). In the ﬁrst iteration, only /u1D453itself is tested
(line19),withnewlydiscoveredﬁxesaddedtothe curFixessetfor
eachsubsequent iteration (lines 28–33).
A ﬁx/u1D453is determined to be good if the curFixesset of ﬁxes for /u1D453
doesnotincrease theNullAway errorcount (lines 24–27).We keep
ﬁxeseveniftheyyieldthesameerrorcounttoimprovehandlingof
ﬁx chains at lower depth limits. A ﬁx chain occurs when inserting
ﬁx/u1D4531causes a single new error with ﬁx /u1D4532,/u1D4532leads to/u1D4533, and so
on, where the ﬁnal ﬁx causes no new error. If good ﬁxes needed to
strictly reduce the error count, then discovering the goodness of /u1D4531
would require setting /u1D451to at least the length of the chain, reducing
performance.Withourapproach,theﬁxchainisappliedevenwith
depthlimit 1, dueto the outer ﬁxed-pointloop.
Algorithm 1isguaranteedtoterminate.Inanexecutionof F/i.sc/n.sc/d.sc/hyphen.sc
N/u.sc/l.sc/l.sc/a.sc/b.sc/l.sc/e.sc/Q_u.sc/a.sc/l.sc/i.sc/f.sc/i.sc/e.sc/r.sc/s.sc ,the/u1D439allsetofﬁxesgrowsmonotonically,and
numberofpossibleﬁxesforaprogramisﬁnite.So,eventually, /u1D439new
mustbecome emptyafter line 10,causing the loopto terminate.
Example. ConsiderapplyingAlgorithm 1totheFigure 1example,
with a depth limit /u1D451=2. In the ﬁrst iteration, /u1D439new={2,3,4,5},
representing the ﬁx locations for the initial errors reported by
NullAway.In E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc ,theﬁxes 2and4willbelabeledas
good at depth 1, since theyimmediately reducethe error count by
1. Fix3is not labeled as good, as it introduces errors that cannot
be ﬁxed with @Nullable annotations, but ﬁx 5is labeled good after
exploringtodepth2andapplyingsubsequentﬁxesatlines 6and13
1398Practical Inference of Nullability Types ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
(see Section 2.2discussion). So, /u1D439good={2,4,5,6,13}in the ﬁrst
ﬁxed-pointloopiteration.Nonewﬁxesareobservedafterapplying
/u1D439good,sothealgorithmconverges,yieldingtheﬁnalsetof @Nullable
qualiﬁers shown in Figure 1. For this example, the unoptimized
algorithmrequires7callsto N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scE/r.sc/r.sc/o.sc/r.sc/s.sc tocomputetheﬁnal
solution; Section 4willshowhowwe can reduce this number.
4 OPTIMIZED SEARCH
ThesearchalgorithmofSection 3runstooslowlyforlargercode
bases, due to running a large number of NullAway builds. Here,
we present optimizations to signiﬁcantly reduce this cost, based
on evaluatingmultipleindependent qualiﬁerssimultaneouslyina
build. We ﬁrst deﬁne the potentially-impacted regions of a qualiﬁer
(Section4.1),usedtodeterminewhenqualiﬁerscanbeevaluated
simultaneously. Then, we give details of our graph-coloring-based
searchalgorithm (Section 4.2).
4.1 Potentially-ImpactedRegions
Our optimizations exploit the fact that for a type-based nullness
checker,introducinga @Nullable qualiﬁeronanentity(ﬁeld,method
parameter, or method return) can only impact the ﬁnal error count
in regions of the code where the entity is directly used or overridden .
Thisfactstemsfromthemodularnatureofthetypechecking;since
nointer-proceduralanalysisisperformedbythecheckertodeter-
mine nullability, the impact of changed nullability for an entity
cannotpropagatebeyondthe procedures using the entity.
Aregionisamethod,aninitializerexpression(e.g.,thereadof f4
atline6inFigure 1),oraninitializerblock.Givenanentity /u1D452,the
potentially-impacted regions for/u1D452are the set of regions whose con-
tainederror count may change as the resultof adding a @Nullable
qualiﬁerto /u1D452.Wedeﬁne potentially-impactedregions for/u1D452asfollows:
•If/u1D452is a ﬁeld/u1D453, any region containing a read or write of /u1D453is
potentially-impacted.
•If/u1D452isaparameterorreturnofmethod /u1D436./u1D45A,then/u1D436./u1D45Aitselfis
potentiallyimpacted,asisanyregionthatcalls /u1D436./u1D45A.Further,
any method that overrides or is overridden by /u1D436./u1D45Ais also
potentiallyimpacted.
Regionsthatread /u1D452maycontainnewerrors,sinceonce /u1D452is@Nullable
it cannot be dereferenced or assigned to a @NonNull location. Simi-
larly,errorsmayberemovedfromregionsthatwrite /u1D452,sincewrites
of@Nullable values into /u1D452become legal. Overriding or overridden
methods may be impacted due to NullAway’s subtyping checks
(see Section 2.1). Potentially-impacted regions can be computed
using standard type-checking information, like a type hierarchy
andsymboltables.
4.2 OptimizedAlgorithm
Algorithm 2gives pseudocode for the key E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.scO/p.sc/t.sc pro-
cedureofouroptimizedsearch.Theoverallalgorithmretainsthe
F/i.sc/n.sc/d.scN/u.sc/l.sc/l.sc/a.sc/b.sc/l.sc/e.sc/Q_u.sc/a.sc/l.sc/i.sc/f.sc/i.sc/e.sc/r.sc/s.sc procedurefromAlgorithm 1,withthe
calltoE/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc atline6replacedwithacallto E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.sc/hyphen.sc
F/i.sc/x.sc/e.sc/s.scO/p.sc/t.sc .
E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.scO/p.sc/t.sc computesgroupsofindependentﬁxesusing
aconﬂictgraph .Eachnodeinthegraphrepresentsapairofarootﬁx
/u1D453and related ﬁxes curFixesbeing tested, the same state tracked for
each ﬁx by the main loop of E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc in Algorithm 1. GivenAlgorithm2 Optimizedsearch basedongraph coloring.
1:procedure E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.scO/p.sc/t.sc (/u1D443,/u1D439,/u1D439all,/u1D451,/u1D438)
2:if/u1D451=0return/u1D439
3:/u1D439good←∅
4:initNodes←{⟨root:/u1D453,curFixes:{/u1D453}⟩|/u1D453∈/u1D439}
5:/u1D43A←C/o.sc/n.sc/f.sc/l.sc/i.sc/c.sc/t.scG/r.sc/a.sc/p.sc/h.sc(initNodes)
6:for/u1D456∈[1,/u1D451]do
7: groups←C/o.sc/l.sc/o.sc/r.sc(/u1D43A)
8: toRemove←∅
9: for/u1D446∈/u1D454/u1D45F/u1D45C/u1D462/u1D45D/u1D460do
10: ﬁxes←/uniontext.1
/u1D45B∈/u1D446/u1D45B.curFixes
11: /u1D443′←A/p.sc/p.sc/l.sc/y.scF/i.sc/x.sc/e.sc/s.sc(/u1D443,ﬁxes)
12: /u1D438′←N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scE/r.sc/r.sc/o.sc/r.sc/s.sc(/u1D443′)
13: for/u1D45B∈/u1D446do
14: /u1D438/u1D45B←/uniontext.1
/u1D45F∈R/e.sc/g.sc/i.sc/o.sc/n.sc/s.sc(/u1D45B)E/r.sc/r.sc/o.sc/r.sc/s.scI/n.scR/e.sc/g.sc/i.sc/o.sc/n.sc(/u1D438,/u1D45F)
15: /u1D438′/u1D45B←/uniontext.1
/u1D45F∈R/e.sc/g.sc/i.sc/o.sc/n.sc/s.sc(/u1D45B)E/r.sc/r.sc/o.sc/r.sc/s.scI/n.scR/e.sc/g.sc/i.sc/o.sc/n.sc(/u1D438′,/u1D45F)
16: /u1D439′/u1D45B←F/i.sc/x.scL/o.sc/c.sc/a.sc/t.sc/i.sc/o.sc/n.sc/s.sc(/u1D438′/u1D45B)
17: if|/u1D438/u1D45B|−|/u1D438′/u1D45B|≥0then
18: /u1D439good←/u1D439good∪{/u1D45B.curFixes}
19: toRemove←toRemove∪{/u1D45B}
20: end if
21: newFixes←/u1D439′/u1D45B−/u1D439all
22: ifnewFixes =∅then
23: toRemove←toRemove∪{/u1D45B}
24: else
25: /u1D45B.curFixes←/u1D45B.curFixes∪newFixes
26: end if
27: end for
28: end for
29: /u1D43A←C/o.sc/n.sc/f.sc/l.sc/i.sc/c.sc/t.scG/r.sc/a.sc/p.sc/h.sc(/u1D43A.nodes−toRemove)
30:end for
31:return/u1D439good
32:end procedure
33:procedure C/o.sc/n.sc/f.sc/l.sc/i.sc/c.sc/t.scG/r.sc/a.sc/p.sc/h.sc (/u1D441)
34:conﬂictEdges←{(/u1D45B1,/u1D45B2)|/u1D45B1,/u1D45B2∈/u1D441
35: ∧R/e.sc/g.sc/i.sc/o.sc/n.sc/s.sc(/u1D45B1)∩R/e.sc/g.sc/i.sc/o.sc/n.sc/s.sc(/u1D45B2)≠∅}
36:return⟨nodes:/u1D441,edges:conﬂictEdges⟩
37:end procedure
38:procedure R/e.sc/g.sc/i.sc/o.sc/n.sc/s.sc(/u1D45B)
39:return/uniontext.1
/u1D453∈/u1D45B.curFixespotentially-impactedregionsfor /u1D453
40:end procedure
a set of nodes, the C/o.sc/n.sc/f.sc/l.sc/i.sc/c.sc/t.scG/r.sc/a.sc/p.sc/h.sc procedure constructs a conﬂict
graph, which contains an (undirected) edge between nodes /u1D45B1and
/u1D45B2iﬀthepotentially-impactedregionsfortheﬁxesin /u1D45B1.curFixes
and/u1D45B2.curFixesoverlap. With this representation, the ﬁxes for any
twonon-adjacent nodes are independent, and the impacts of all
theirﬁxes maybe evaluatedsimultaneously.
After constructing an initial conﬂict graph (line 5),E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.sc/hyphen.sc
F/i.sc/x.sc/e.sc/s.scO/p.sc/t.sc proceeds by iterating up to the depth limit (starting at
line6),similartotheline 20loopinE/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc inAlgorithm 1.
In each iteration, the algorithm computes sets of independent ﬁxes
bycoloringthecurrentconﬂictgraph(line 7).TheC/o.sc/l.sc/o.sc/r.scroutine
returnsasetofsetsofnodes groups,whereforeachset /u1D446∈/u1D454/u1D45F/u1D45C/u1D462/u1D45D/u1D460,
nopairofnodesin /u1D446isadjacentin /u1D43A.Hence,ﬁxescorrespondingto
1399ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Nima Karimipour,JustinPham, Lazaro Clapp, andManu Sridharan
allnodesin /u1D446canbeevaluatedsimultaneouslyinasingleNullAway
run. Our implementation uses a greedy coloring algorithm [ 18],
whichproduces suﬃciently goodresults for our needs.
For each group /u1D446(line9), we apply allcurrent ﬁxes for all nodes
in that group simultaneously, and run NullAway to compute an
updatedsetoferrors(lines 10to12).Thisyieldsasinglenewsetof
errors/u1D438′,fromwhichwemustextracttheerrorsspeciﬁctoeach
node/u1D45B, to determine if /u1D45B’s ﬁxes reduce the error count. We can do
so by ﬁnding original and new errors only in the impacted regions
for/u1D45B(lines14and15),which are guaranteed not to overlap with
anyothernodein /u1D446.Thelogicinlines 16–26isanalogoustothatin
lines23–33inAlgorithm 1,exceptthatinsteadofbreakingoutofthe
loop when a ﬁx is fully handled, the corresponding node is marked
forremovalfromtheconﬂictgraph.Afterprocessingallgroups,we
recomputetheconﬂictgraph(line 29)afterremovingmarkednodes,
andcontinuetothenextdepthlevel.Recomputingtheconﬂictgraph
is needed even if nonodes are removed,as the listof current ﬁxes
for each node may have changed, impacting the required edges
between nodes. In the end, E/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.scO/p.sc/t.sc returns the same
result asE/v.sc/a.sc/l.sc/u.sc/a.sc/t.sc/e.scF/i.sc/x.sc/e.sc/s.sc from Algorithm 1for the same inputs, but
withasmallernumber ofcalls to N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scE/r.sc/r.sc/o.sc/r.sc/s.sc .
3
2 4
5
Figure 2:Conﬂict graph
inﬁrstiterationofAlgo-
rithm2run on Figure 1.Example. Consider applying Al-
gorithm2to the Figure 1example,
again with /u1D451=2. Figure2shows
theinitialconﬂictgraphfortheex-
ample, capturing which ﬁxes have
overlappingimpactedregions.The
coloringofFigure 2showsthatﬁxes
2,4, and5can all be evaluated with
a single call to N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scE/r.sc/r.sc/o.sc/r.sc/s.sc .
Overall,thesameﬁnalresultiscom-
puted,butwith5callsto N/u.sc/l.sc/l.scA/w.sc/a.sc/y.sc/hyphen.sc
E/r.sc/r.sc/o.sc/r.sc/s.scas compared to 7 for Algo-
rithm1; real-world improvements
are more dramatic (see Section 8).
5 CLIENTCODE
Real-worldcodebasesareoftencomposedofmanyinter-dependent
modules, to enable more scalable development with large teams.
For scalability and ease of review, it would be very useful to be
able to apply nullability inference one module at a time for such
projects.Asdescribedthusfar,ourinferencealgorithmaccountsfor
NullAway errorswithin the code being annotated, which we term
thetargetcode. In a multi-module scenario, the target code would
be the single module being annotated. However, our presented
technique does not yet account for potential NullAway errors in
othermodulesdependentonthemodulebeingannotated,whichwe
refer to as clientcode. Ignoring client code can lead to undesirable
inference results. For example, if a public method mhas no calls
from within target code, inference will assume that making m’s
return type @Nullable will not introduce any new errors, even if
client code assumes mdoes not return null. Here we describe an
inference extension to account for assumptions made by clients of
the target code,crucial for usabilityinpractice.
A naïve approach to handling client code could simply compile
all client code alongside the target in each build and observe theimpact of ﬁxes in clients. We assume annotations cannot be added
toclientcode,soerrorsshouldonlybetreatedasﬁxableiftheﬁx
locationisinthetarget.Unfortunately,thisapproachdoesnotscale
to a large amount of client code (even with the optimizations of
Section4), as each individual build becomes much more expensive
when allclientcode isincluded.
Instead,wehandleclientcodeviaup-front cachingoftheimpacts
ofﬁxesonclients.Forsimplicity,hereweassumethatclientcode
only interacts with the target via calls to public methods; ﬁeld
accesses and method overriding can be handled similarly. Under
this assumption, ﬁxes in the target may impact the client in two
ways: (1) making a public return type @Nullable may cause new
client NullAway errors, and (2) making a public parameter type
@Nullable mayremoveclienterrors.Beforeourcoresearch,werun
up-frontbuildsofclientcodetoﬁndandcachetheclientimpacts
foreachsuchﬁx;wethenusethecachedinformationduringthe
searchandonlybuildthetargetcode.Empirically,thenumberof
up-frontbuildsrequiredwasfarfewerthanthenumberofbuilds
run during the search (see Section 8), so overall this caching yields
alarge speedup.
Our caching phase runs the following builds. First, we build the
clientcodewithunmodiﬁedtargetcode,andcacheallNullAway
errors in client code caused by passing a @Nullable expression to a
@NonNull targetmethodparameter(case(2)above).Then,werun
builds to cache the client errors introduced by making eachpublic
target method return @Nullable (case (1) above), noting when such
errors have a ﬁx location in the target. We dramatically reduce
the number of such builds needed for this phase by re-using the
graph coloring optimization of Section 4.2. With fully-cached in-
formation about relevant client errors and their ﬁx locations, we
augment Algorithms 1and2to use this information during the
search, requiring nofurther clientcode builds.
Resultequivalence. Thecachingschemedescribedabove canbe
generalizedtocachetheerrorscausedby anypotentialﬁx,whether
in target or client code. This more extensive caching could yield
further search speedups: when applying a set of ﬁxes /u1D439, if the
impacts of all ﬁxes in /u1D439are already cached, the cached information
couldbeusedtocomputetheoverallimpactof /u1D439,avoidingarunof
NullAway. Unfortunately, in certain cases the combined impacts of
individualﬁxesin /u1D439arenotequivalenttotheimpactofapplyingall
ﬁxesin/u1D439together.Thisoccursbecauseitispossibleforanewerror
to appear only when a pairof ﬁxes is introduced, but not when
eitherﬁxisaddedindividually.Considerthis excerpt:
classC {
Object f1 = newObject();
Object f2 = newObject();
[...]
voidm() {
f1 = f2;
f1.toString();
}
}
Say that due to NullAway errors in other code (not shown), the
search considers making f1andf2 @Nullable . NullAway reports
a dereference-of- @Nullable error at the f1.toString() call only if
1400Practical Inference of Nullability Types ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
bothf1andf2are@Nullable . If just f1is@Nullable , no error is
reported,since f2is@NonNull andassignedto f1before thecall.If
justf2is@Nullable , an error is reported at the f1 = f2assignment,
but not at the call. Due to such cases, cached information may
under-estimate the number of NullAway errors reported when
multiple ﬁxes are applied simultaneously. In our evaluation, we
neverobservedunexpectedNullAwayerrorsinclientcodedueto
this issue.
Weighting. Aquestionremainsofhowtoweightclientvs.target
NullAwayerrorsduringtheinferencesearch.E.g.,forasmalltarget
withalargeamountofclientcode,onemaywanttoweighterrorsin
thetargetmorehighlythanerrorsinclients.Bydefault, N/u.sc/l.sc/l.scA/w.sc/a.sc/y.sc/hyphen.sc
A/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc weightsallerrorsequally,butdiﬀerentweightingscan
easily be supported.
At Uber,N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc is being used to annotate indi-
vidual modules in a “monorepo” [ 33] containing hundreds of mod-
ules. Some modules are already checked with NullAway, and a key
requirementfor N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc isthatnonewNullAway
errorsshouldbeintroducedinothermoduleswhenannotatingatar-
get.Thisfeatureeasescodereview,sincethechangesintroducedby
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc aretherebylimitedtosemantics-preserving
changes to exactly one module, requiring limited review. Before
imposingthisrequirement,weobservedcaseswhere N/u.sc/l.sc/l.scA/w.sc/a.sc/y.sc/hyphen.sc
A/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc changescausednewerrorsindozensofothermodules:
the ﬁxes for these errors required reviews from many teams and
dramatically slowedadoption.
For this scenario, N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc includes a strict mode ,
in which it only adds annotations to the target if they do not cause
new errors in other modules. (In essence, strict mode applies an
inﬁnite weight to client errors.) Strict mode may increase the ﬁnal
number of remaining NullAway errors in the target. However, it
makes adoption of changes from N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc much
easier,andasnotedinSection 2.2,gettingthesechangesmerged
quickly provides an immediate beneﬁt, as new code and most code
modiﬁcationsinthe target then beneﬁtfrom NullAwaychecking.
6 INITIALIZATION
Beyond the checks discussed so far, NullAway also checks for
correct object initialization. Consider the example of Figure 3. The
t1,t2,andt3ﬁeldsaretreatedas @NonNull bydefault.However,the
TestInit constructor fails to initialize the ﬁelds, so they could still
benullat later reads (e.g., if useFields were called immediately
after the constructor). Hence, NullAway reports an initialization
error for the constructor. Our inference technique can handle such
acasebyinsertinga @Nullable annotationonallthreeﬁelds,which
removes the error. However, this leads to three new dereference-
of-@Nullable errors in the useFields method, and hence does not
decreasethe errorcount.
NullAway also supports initializer methods to capture cases
where ﬁelds are initialized after object construction but before
anyuse[ 4].FortheFigure 3example,assumetheintendedlifecy-
cleofTestInit isthatafterconstruction,the initmethodshould
beinvokedbeforeanyothermethodintheclass.Then,thederef-
erences in useFields are safe, as they will only occur after init
has run. Such protocols arise regularly in practice, e.g., for An-
droid activities [ 1]. NullAway treats any method annotated with1classTestInit {
2Object t1, t2, t3;
3TestInit() {}
4+@Initializer
5voidinit(Object o1, Object o2, Object o3) {
6t1 = o1;
7t2 = o2;
8t3 = o3;
9}
10intuseFields() {
11 // no null checks needed here
12 returnt1.hashCode() + t2.hashCode()
13 + t3.hashCode();
14}
15}
Figure 3:Example forillustrating initializationchecks.
@Initializer as a method that runs before all other methods in
the class, and reasons about ﬁeld initialization in such methods
appropriately. NullAway does notcheck that client classes actually
invoke@Initializer methods before other methods, and hence its
handling ofthis feature isunsound[ 4].
Ourapproachincludeslimitedsupportforinferring @Initializer
annotations.SinceNullAway’ssupportfor @Initializer isunsound,
we devised our approach toinfer @Initializer under narrow con-
ditions,aimingtoavoidintroducingincorrectannotations.Weonly
add@Initializer to amethod /u1D45Aif the following holds:
(1)/u1D45Amust write a @NonNull value to at least two otherwise-
uninitializedﬁelds,andthoseﬁeldscannotbeoverwritten
witha@Nullable valuebefore /u1D45Areturns.
(2)There can be at most one inferred @Initializer method per
class. If more than one method in /u1D45A’s class meets condition
1,/u1D45Amustbe the methodthat initializes the mostﬁelds.
Inferenceof @Initializer occursinaseparatepass,beforerunning
Algorithm 2,sothatthecoresearchdoesnotinsert @Nullable an-
notations on ﬁelds that are never null once @Initializer methods
are considered. For the Figure 3example, our approach would add
an@Initializer annotation to init, thereby removing all errors
reported for the class. In our evaluation, we inspected all intro-
duced@Initializer annotations to check that they reﬂected actual
lifecyclebehavior(see Section 8).
7 IMPLEMENTATION
We have implemented our approach in a tool N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/hyphen.sc
/t.sc/a.sc/t.sc/o.sc/r.sc, which is open source.3To compute potentially-impacted
regions for ﬁxes (Section 4.1), we implemented a code structure
scanner as an Error Prone plugin checker [ 12], which runs as part
of the Java compilation process (like NullAway). This scanner seri-
alizestherelevantinformationaboutusesofﬁelds,usesofmethods,
and the type hierarchy, as computed by the Java compiler. The
scannerisimplementedin1,220(non-blank,non-comment)lines
ofJava code.
3https://github.com/ucr-riple/NullAwayAnnotator
1401ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Nima Karimipour,JustinPham, Lazaro Clapp, andManu Sridharan
A separate component handles insertion of annotations into
source code. It leverages JavaParser [ 19] to discover annotation in-
sertion locations, and then inserts annotations using string manip-
ulationtoensurewhitespaceispreserved.Whitespacepreservation
is critical for making the tool usable in practice, as any unneces-
sary formatting modiﬁcations make changes harder to review. The
injector isimplementedin1,522 linesofJava code.
Finally, the core optimized search of N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc
(Section4.2) is implemented in roughly 4,300 lines of Java code. To
runN/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc , a developer must integrate NullAway
and the code structure scanner as part of their compilation scripts.
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc isbuild-systemindependent,asavariety
ofbuildsystemsareincommonuseintheJavaecosystem.Forease
ofimplementation,wemademinormodiﬁcationstoNullAwayto
serializeitsoutputinamachine-readableformat.Thisoutputcould
have beenparseddirectlyfrom NullAway’serror messages,butat
greater engineeringcost.
8 EVALUATION
In this section, we present an experimental evaluation of N/u.sc/l.sc/l.sc/hyphen.sc
A/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc , showing the eﬀectiveness of its inferred annota-
tionsandofour performance optimizations.
8.1 Experimentalsetupandresearch questions
Weevaluated N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc ontwoseparatedatasetsof
Java code bases. First, we used a collection of 14 open-source Java
projects from GitHub. From the most popular Java projects on
GitHub(asdeterminedbynumberofstars),wechose13projects
thatusetheGradlebuildsystem[ 14],toeaseintegrationofNull-
Awayand N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc ’sconﬁguration.Toensuregreater
diversity in the benchmarks, we limited the number of Android
projectstoﬁve.Finally,weincludedWALA:Util,amodulefromthe
WALAstaticanalysislibrary[ 37]maintainedbyoneoftheauthors,
toevaluateadoptingNullAwayvia N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc onan
open-source project (see Section 8.4). We did not create a larger
suite of open-source benchmarks due to the manual eﬀort required
tointegrateNullAwayand N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc intothebuild
scripts ofeachbenchmark.
Second, we used a set of 8 modules from Uber’s repository of
Javaservercode.Thesetargets(T1toT8)wereselectedonthebasis
ofaone-weeksamplingofproductioncrashlogs.Theyrepresented
thetop-8targetsbyNPEcountinthisdataset,excludingonetarget
onwhich N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc crashedandanytargetsthatwere
alreadyenrolledinNullAway(whichmaystillcontainNPEsdueto
third-party libraries [ 4]). At the time of our evaluation, targets T1
toT8were notalreadyenrolledontoNullAwayusing N/u.sc/l.sc/l.scA/w.sc/a.sc/y.sc/hyphen.sc
A/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc ; we avoided previously-enrolled targets so that all
experimentscouldberunwithasingletoolversion.SeeSection 8.4
forfurtherdiscussionregardingreal-worldusageof N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/hyphen.sc
/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc to enroll targets.
Table1gives the size and type of each benchmark. While the
open-source dataset represents standalone programs and libraries,
theUberdatasetconsistsofbuildtargets:programmodulesbuilt
and unit tested independently, but which serve as part of one or
more production services.Table 1: Benchmark types and sizes, and the error reduction
fromNullAwayAnnotator at depths 0, 1, and 5.
Benchmark Name KLoCNumber of Errors
Initial Depth0 Depth1 Depth5Open Source ProjectsFramework
Conductor 9.2K 159170(+6.9%) 44(-72.3%) 30(-81.1%)
Mockito 17.6K 20595(-53.7%) 47(-77.1%) 30(-85.4%)
SpringBoot 35.1K 777204(-73.7%) 184(-76.3%) 77(-90.1%)
GameEngine
LitiEngine 30.1K 480468(-2.5%) 191(-60.2%) 184(-61.7%)
LibGdx 92.1K15492314 (+49.4%) 516(-66.7%) 442(-71.5%)
Libraries
MPAndroid 16.1K 174489(+181.0%) 64(-63.2%) 53(-69.5%)
Glide 24.6K 287195(-32.1%) 112(-61.0%) 105(-63.4%)
EventBus 1.9K 4918(-63.3%) 12(-75.5%) 10(-79.6%)
Gson 8.0K 16138(-76.4%) 39(-75.8%) 28(-82.6%)
Eureka 8.0K 7470(-5.4%) 31(-58.1%) 25(-66.2%)
Retrofit 3.6K 2613(-50.0%) 13(-50.0%) 13(-50.0%)
CompilerTools
Jadx 39.8K 493865(+75.5%) 132(-73.2%) 124(-74.8%)
WALA:Util 19.5K 190294(+54.7%) 88(-53.6%) 76(-60.0%)
NetworkLibrary
Zuul 15.2K 20443(-78.9%) 31(-84.8%) 23(-88.7%)UberT1 35.7K 537454(-15.5%) 200(-62.8%) 187(-65.2%)
T2 81.7K1072 991(-7.6%) 328(-69.4%) 310(-71.1%)
T3 12.9K 229134(-41.5%) 46(-79.9%) 31(-86.5%)
T4 20.1K 11170(-36.9%) 70(-36.9%) 70(-36.9%)
T5 13.8K 222192(-13.5%) 126(-43.2%) 126(-43.2%)
T6 3.4K 4761(+29.8%) 10(-78.7%) 9 (-80.9%)
T7 5.9K 3528(-20.0%) 21(-40.0%) 19(-45.7%)
T8 14.8K 301166(-44.9%) 91(-69.8%) 76(-74.8%)
Usingthesetwodatasets,weseektoanswerthefollowingkey
researchquestions:
(1)IsN/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc eﬀective inreducing the number
ofreportedNullAwayerrorsfor thesebenchmarks?
(2)How does our technique compare with the strategy of ap-
plyingallpossible ﬁxes, interms of errorreduction?
(3)What is the impact of the depth limit (see Section 3) on tool
eﬀectiveness, in terms of number of errors removed and
running time?
(4)How much do our optimizations (Section 4) reduce running
time over unoptimized?
(5)Istheoutputof N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc anadequatebasisto
enable NullAway checking on previously-unannotated code
inaproduction setting?
Section8.2addresses questions 1–3, Section8.3addresses question
4,andSection 8.4addresses question 5.
Experiments for open-source benchmarks were performed on a
desktop with an 11th Gen Intel(R) Core(TM) i7-11700 @ 2.50GHz 8
coreCPUand32GBRAMrunningUbuntu20.04.5LTS.Experiments
atUberwereperformedinsideaLinuxcontaineronasharedAMD
EPYC 2.45GHz machine, with 24 cores per socket and 2 sockets
reporting 377 GB of RAM. We did not have dedicated access to this
machine during our measurements, but it usually stayed at low
utilization duringexperiments.
1402Practical Inference of Nullability Types ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
8.2 Error countreductionanddepthbound
We ﬁrst evaluated the eﬀectiveness of N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc at
reducing the number of errors reported by NullAway. Data on
this error reduction after running N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc with
various depth limits is shown in Table 1, with percentage changes
inparentheses.TheInitialcolumngivesthenumberofNullAway
errors before running inference. We show error reduction with
depthlimits 0,1,and5.RecallfromSection 3thatadepthlimitof
0correspondstoeagerlyinsertingallpossibleﬁxes,ignoringthe
impact onerrorcount.
Eager insertion of all possible ﬁxes (depth limit 0) always yields
moreremainingerrorsthandepth1,andsometimesyieldsahigher
number of errors than were reported on the original code! E.g., for
LibGdx, the number of reported NullAway errors increases from
1549to2314(49%moreerrors)atdepth0,andfor MpAndroid the
number of errors increases by 181%. These results show that our
searchstrategyproducesaﬁnalresultwithmanyfewererrorsthan
performingeager @Nullable insertion.
Todeterminetheimpactofthedepthlimit,weran N/u.sc/l.sc/l.scA/w.sc/a.sc/y.sc/hyphen.sc
A/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc withlimitsof1–10acrossallofourbenchmarks.We
observedthattheﬁnalnumberoferrorswasneverreducedfurther
going beyond depth 5. Also, the running time at depth 5 was an
averageof2.24Xthedepth1runningtime,areasonablecost.So,on
ourbenchmarksweconcludedthatdepth5yieldedthebesttradeoﬀ
between performance and error reduction, and we used that depth
limit for allsubsequent experiments.
At depth 5, we saw an average reduction of 69.5% in the num-
ber of NullAway errors reported when compared to the initial
code, ranging from 36.9% (for the T4Uber target) to 90.1% (for
SpringBoot ). The signiﬁcant reduction of errors from running
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc has multiple beneﬁts: it enables more code
to be checked immediately by NullAway via warning suppressions
(see Section 8.4), and it reduces the eﬀort required to eventually
enroll allthe code inNullAwaychecking.
8.3 Impactofoptimizations
Next,we evaluatedtheperformance impactofour graph-coloring
optimizations(Section 4),andourresultsappearinTable 2.Allcon-
ﬁgurationswererunwithadepthlimitof5andatimeoutof8hours.
We show both the overall running time in minutes, and also the
numberofNullAwaybuildsrunineachconﬁguration(nearlyallex-
ecution time of N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc is spent running NullAway
builds,onaverageover97%ofrunningtimeforouropen-source
benchmarks). For our benchmarks, we observe enormous reduc-
tionsinrunningtimeswiththegraphcoloringoptimizationover
unoptimized;thespeedupsrangefrom2.0X–17.8X,withanaverage
of 6.1X.Further, for T1and T2 we could not measure the speedup,
as the unoptimized run could not complete within an 8-hour limit.
Weobserveasimilarly-largereductioninnumberofbuildsre-
quired with optimizations enabled, showing that a signiﬁcant num-
berofthequaliﬁersevaluatedbyoursearchareinfactindependent.
Regardingthenumberofup-frontbuildsrequiredforclientcode
(Section5),weobservedanaverageof2.4buildsandamaximumof
8 across our benchmarks, small compared to the number of buildsTable2:Runningtimeandnumberofbuildsforunoptimized
andoptimized conﬁgurations.
Benchmark NameTime (Minutes) Number of builds
Unoptimized Optimized Unoptimized OptimizedOpen Source ProjectsConductor 28.9 6.3(4.6X) 351 115(3.1X)
Mockito 25.3 3.0(8.4X) 383 71(5.4X)
SpringBoot 461.7 26.0 (17.8X) 1427 113(12.6X)
LitiEngine 59.0 5.1(11.5X) 1122 98(11.4X)
LibGdx 339.2 27.7 (12.2X) 2320 195(11.9X)
MPAndroid 33.4 9.8(3.4X) 402 119(3.4X)
Glide 28.9 5.1(5.7X) 455 104(4.4X)
EventBus 1.5 0.5(3.0X) 77 26(3.0X)
Gson 9.2 1.8(5.1X) 181 66(2.7X)
Eureka 6.5 2.4(2.7X) 198 72(2.8X)
Retrofit 0.6 0.3(2.0X) 22 12(1.8X)
Jadx 68.7 10.5 (6.5X) 868 126(6.9X)
WALA:Util 76.11 12.37(6.2X) 547 76(7.2X)
Zuul 25.3 2.3(11.0X) 206 58(3.6X)UberT1 X 70.02(-) 593+ 77(-)
T2 X 114.02 (-) 706+ 89(-)
T3 183.19 44.42(4.1X) 404 91(4.4X)
T4 33.02 13.74(2.4X) 53 18(2.9X)
T5 292.06 61.28(4.8X) 559 110(5.1X)
T6 24.01 9.75 (2.5X) 59 19(3.1X)
T7 31.64 12.48(2.5X) 72 22(3.3X)
T8 374.44 71.69(5.2X) 842 154(5.5X)
Table3:Numberofannotationsinjectedby NullAwayAn-
notator .
Benchmark NameDepth5 Suppress-only
# @Nullable # Suppression % unchecked % uncheckedOpen Source ProjectsConductor 319 31 5.95% 22.6%
Mockito 322 31 3.6% 14.82%
SpringBoot 1331 81 1.99% 12.03%
LitiEngine 993 158 5.85% 12.08%
LibGdx 1426 459 4.77% 10.04%
MPAndroid 253 66 2.49% 6.27%
Glide 370 99 5.68% 9.57%
EventBus 71 9 5.44% 14.97%
Gson 202 21 5.2% 18.42%
Eureka 138 30 6.04% 11.71%
Retrofit 27 10 16.79% 17.1%
Jadx 509 139 4.98% 12.18%
WALA:Util 165 67 4.27% 7.66%
Zuul 164 27 5.13% 9.15%UberT1 501 177 8.54% 13.16%
T2 863 290 8.59% 15.09%
T3 320 28 3.89% 19.55%
T4 322 46 10.15% 13.64%
T5 231 103 14.61% 20.67%
T6 35 10 2.12% 10.18%
T7 88 19 4.42% 6.52%
T8 656 81 8.64% 7.66%
requiredduringsearch. We concludethat the graph-coloringopti-
mization provides an enormous beneﬁt and is essentialfor making
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc practical for larger programs.
1403ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Nima Karimipour,JustinPham, Lazaro Clapp, andManu Sridharan
8.4 Tooloutput andreal-worldusage
Here,wecharacterizetheinferredannotationsdiscoveredby N/u.sc/l.sc/l.sc/hyphen.sc
A/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc anddescribeitsreal-worldusagethusfar.Table 3
givesdataontheﬁnalsolutionsfoundby N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc
forourbenchmarks.Fordepth5,weshowthenumberof @Nullable
annotations inferred, the number of annotations inserted to sup-
pressremainingwarnings,andthepercentageofcodethatremains
uncheckedby NullAway dueto thesesuppressions.Wealso show
thepercentageof uncheckedcodefor abaseline conﬁguration,in
which all the errors initially reported by NullAway are suppressed
(without running inference). Due to a tool bug, for one benchmark
(T5)we addedone suppressionannotation manually.
Thenumberof @Nullable annotationsinsertedby N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/hyphen.sc
/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc is signiﬁcant (up to 1,426), reﬂecting the large amount of
manualworkotherwiserequiredtoadoptNullAway.Aftersuppres-
sionswereinsertedatdepth5,thepercentageofuncheckedcode
ranged from 1.99% to 16.79%, with an average of 6.32%. In compari-
sontothebaselineofsuppressingwithnoinference,thepercentage
ofuncheckedcode decreasedbyanaveragefactor of2.54X (0.89X
to 6.05X). For the one target where the amount of unchecked code
increased with inference (the Uber T8 module), the baseline sup-
presses many uninitialized ﬁeld warnings at the ﬁeld declarations,
whileinferencemakestheﬁelds @Nullable andaddssuppressions
on certain methods using the ﬁelds. Even though inference adds
many fewer suppressions(81 vs. 362forthe baseline), dueto the
placement of these suppressions on methods rather than ﬁelds, the
amount of unchecked code becomes higher. Table 1shows that
inferencestilldramaticallyreducesthenumberofNullAwayerrors
for this benchmark.
Overall, the data show that our inference allows for a much
greater amount of existing code to be immediately checked by
NullAway, yielding greater safety for future code modiﬁcations
withnomanual eﬀort.
Initializers Wemanuallyinspectedallinjected @Initializer anno-
tations, and all were correct exceptfor two in LibGdx. For the bad
cases, the method was in fact a setter not involved in initialization,
thoughitassignedvaluestomultipleﬁelds.Inthefuture,webelieve
wecanmake @Initializer inferencemoreaccuratebyleveraging
methodnaming patterns (e.g.,includingmethods withnames like
initwhileexcluding methodswhose names startwith set).
Deployment N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc hasbeendeployedatUberfor
self-serveusebydevelopers.Thusfar,ithasbeenusedtoenroll160
modulesinNullAwaychecking,consistingofroughly1.365million
lines of Java code. Running N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc on production
modules led to many bug ﬁxes and improvements in the tool it-
self, e.g., handling of code generation by annotation processors.
Themainlessonfromourexperiencethusfaristhat N/u.sc/l.sc/l.scA/w.sc/a.sc/y.sc/hyphen.sc
A/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc changes should as much as possible be scoped to a
single module and be semantics-preserving, to avoid long code
review cycles (see Section 5). A key issue with extended code re-
view is that the target and client code keeps evolving, and keeping
the inferred changes consistent with the evolving code requires
signiﬁcant manual eﬀort.
We also used N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc to enable NullAway check-
ingfortheWALA:Utilopen-sourcemodule,maintainedbyoneof
the paper authors. Here, we again found N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc ’ssupport for analyzing client code to be useful, as WALA:Util is
used by many other modules in the project, and we wanted the
annotations to capture that usage behavior. In studying the ﬁnal
output,wefoundseveralplaceswhere N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc in-
ferred a @Nullable annotation for a ﬁeld or method parameter, but
the author would have preferred to refactor the code to make that
location @NonNull. Automatically performing such code refactor-
ings and repairs is out of scope for N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc , but is a
fruitful avenue for further research.
The@Nullable annotations discussed above could be consid-
ered “false positives” since they do not match the annotations a
developer would have written by hand; we expect that similar
cases may have occurred in our other benchmarks. We have found
thatinsuchcases,introducingthedesireddeveloperannotations
usually also requires modifying executable program code. Any
change that modiﬁes executable code require much deeper review
than thechanges generated by N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc , whichare
semantics-preserving.Foreﬀectivedeployment,webelievefuture
repair approaches would be best deployed in combination with
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc ;N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc ’schangeswould
enable immediate NullAway checking with no review required,
andsubsequentautomatedrepairpatchescouldbereviewedand
incorporatedgradually.
8.5 Threatsto ValidityandLimitations
The main threat to the external validity of our evaluation is our
choice of benchmarks. We strove tochoose a diverse set of bench-
marksinaprincipledmanner(seeSection 8.1).Still,itispossible
thatonlesspopularopen-sourcebenchmarks,oronbenchmarks
using build systems besides Gradle, N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc will
belesseﬀective.And,itispossiblethat N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc is
particularly eﬀective for code written in the style used at Uber, but
thatitwillbelesseﬀectiveforotherproprietarycode.Regarding
internalvalidity,ourresultsmaybeimpactedbyimplementation
bugsinN/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc .Tocombatthisissue, N/u.sc/l.sc/l.scA/w.sc/a.sc/y.sc/hyphen.sc
A/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc has an extensive suite of unit and integration tests.
Further, for all benchmarks, we veriﬁed that the ﬁnal result of
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc was exactly the same with and without
optimizations enabled. We have also manually vetted the output of
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc onseveral Uber targets.
Alimitationof N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc isthatitdoesnotsupport
inferenceofallannotationssupportedbyNullAway.We donotyet
support inference of @Contract ,@RequiresNonNull , and@Ensures-
NonNullannotations, used to express pre- and post-conditions (e.g.,
thatsomeﬁeldofaparametermustbe @NonNull atmethodentry).
We focused on inference of @Nullable annotations initially, since it
providesalargebeneﬁtonitsown,butweplantosupportinference
ofpre-andpost-conditionannotationsinthefuture.Othernullness
checkers [ 28,31] support writing type qualiﬁers on generic type
arguments(e.g., List<@Nullable String> ),butNullAwaydoesnot.
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc does not currently support inference of
such qualiﬁers, but we are working to extend it with such support.
9 RELATED WORK
There is a wide and rich literature on classical type inference (or
typereconstruction)[ 32,Chapter22],whichfocusesondiscovering
1404Practical Inference of Nullability Types ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
whetherthereexistsa(complete)typingforanunannotatedpro-
graminagiventypesystem.Ourproblemdiﬀersfromtheclassical
case as we nearly always target programs where no such typing
exists,andourgoalistoﬁndamaximalsetofusefultypequaliﬁers
for such programs. As such, we focusour related work discussion
ontechniquesmorecloselyrelatedtoourtargetscenario,anddo
not discuss type inference work more broadly.
CheckerFrameworkInference[ 7]usesconstraint-basedanalysis
toinfertypes,andtheapproachhasbeenappliedsuccessfullyto
atypesystemsformeasurementunits[ 38].Thisapproachsolves
the constraints using MaxSAT, which could be adapted to output a
partialtypingfortheprogramwhentheconstraintsareunsatisﬁ-
able.Previousapproachestoimprovederrorexplanationfortype
inference[ 23,29,39]andmigrationofdynamically-typedprograms
tousegradualtypes[ 6,25,30]arealsobasedonconstraints,and
couldbesimilarlyadapted.However,asnotedinSection 1,were-
quire reuse of an existing checker implementation for ourscenario,
andcannotre-implement the checker using constraints.
The Checker Framework includes whole-program inference
(WPI) functionality [ 20] that works with unmodiﬁed pluggable
typesystemimplementations.Thetechniqueworksbyinserting
the most speciﬁc type qualiﬁer compatible with all expressions
written into an entity (a ﬁeld, parameter, or return value), running
toaﬁxedpoint.WPIisintegratedintotheCheckerFramework,and
hencecaninfermanyannotationsfromasinglerun.Ourtechnique
treatsthecheckerasablackbox,necessitatingtheoptimizations
of Section 4for better performance. Our less-coupled approach
makes it potentially easier to combine our technique with other
checkerimplementations,andweplantoexploreintegrationswith
theCheckerFramework.WPIis notguidedbyminimizingtheﬁ-
nal number of errors reported; its strategy resembles that of our
eagerinsertionofqualiﬁers,whichSection 8showed can increase
the ﬁnal number of errors. Also, our technique aims to generate
annotations a developerwould accept into their source code. WPI
may generate many annotations unrelated to any reported error,
which developers are unlikely to incorporate (to minimize clutter).
TheDaikondynamicinvariantdetector[ 11]caninfer @Nullable
annotations from dynamic behaviors [ 8]. This approach infers a
@Nullable qualiﬁeronlyforlocationsobservedtobe nullatruntime,
aguaranteethatanystaticapproachcannotprovide.Aswithany
dynamic approach, it requires that the target code to be executable
bythetoolandthatsomesetofsuitableinputsisavailable.Static
approacheslikeoursarecomplementary,astheyneednotbeableto
executetheprogramandcanaccountforallpossiblecodebehaviors.
Cascade[ 36]isaninteractivetypequaliﬁerinferencetoolthat
involvesprogrammersintheinferenceprocess.Cascadealsotargets
programswherecodechangesarelikelytoberequiredtomakethe
code type check. N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc aims to automate more of
thequaliﬁer inferenceprocess than Cascade. The twoapproaches
arecomplementary;afteradoptingtheinitialannotationsproposed
byN/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc , a developer could use a Cascade-like
toolto aid ingradually ﬁxing the remaining errors.
Recent workhas appliedmodernmachinelearningtechniques
totypeinference[ 16,34]andtoprogramrepairwhoseﬁxesmay
include type qualiﬁer insertion [ 3].We have not yetpursued such
techniques due to the amount of training data required; we are
notawareofapublicly-availabledatasetshowinghow @Nullablequaliﬁers are inserted to address type errors. In the future we plan
to investigate generation of training data [ 5] to further enable a
learning-basedapproach.NotethatTypeWriter[ 34]alsousesblack-
box executions of an extant type checker to evaluate candidate
types; we believe our graph-coloring optimization could be used to
reducethenumberoftypecheckerrunsrequiredbytheirtechnique.
10 CONCLUSIONS
Wehavepresentedanovelapproachtoinferenceofnullabilityqual-
iﬁers for Java programs, to enable applying nullness type checkers
to extant code bases. In contrast to many other techniques, our
approach treats the type checker as a black-box oracle and does
not require re-implementation of its logic. We deﬁned an eﬀective
search strategy for discovering a good set of qualiﬁers to insert,
andpresentedoptimizationstodramaticallyspeedupthesearch.
We implemented our approach in an open-source tool N/u.sc/l.sc/l.scA/w.sc/a.sc/y.sc/hyphen.sc
A/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc and evaluated it on both open-source and commercial
code bases. Our evaluation showed that N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc
scaled well, and that the inferred annotations signiﬁcantly reduced
the number of errors reported, enabling NullAway checking for
more existing code. N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc has already been used
to enable NullAway checking for 160 production modules at Uber.
In future work,we planto generalize our approach to other static
type andtype-qualiﬁer systems.
11 DATA AVAILABILITY
N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc is open source and available at https://
github.com/ucr-riple/NullAwayAnnotator .Further,wehavemade
an artifact available at https://zenodo.org/record/8271236 contain-
ingthecodefor N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc andscriptstorunitonour
open-sourcebenchmarks.
ACKNOWLEDGMENTS
We would like to thank all the Uber developers who contributed to
thisworkbyusing N/u.sc/l.sc/l.scA/w.sc/a.sc/y.scA/n.sc/n.sc/o.sc/t.sc/a.sc/t.sc/o.sc/r.sc toannotatetheircode
and providing feedback on the tool, with special thanks to Ameya
Ketkar, Sonal Mahajan, Yuxin Wang, Raj Barik, and Swati Gupta
for theirhelpcoordinating the initialcode enrollments.
This research was supported in part by the National Science
Foundation under grants CCF-2007024 and CCF-2312263, a gift
from Oracle Labs, and a Google Research Award. This research
was partially sponsored by the OUSD(R&E)/RT&L and was ac-
complished under Cooperative Agreement Number W911NF-20-2-
0267. The views and conclusions contained in this document are
those of the authors and should not be interpreted as representing
the oﬃcial policies, either expressed or implied, of the ARL and
OUSD(R&E)/RT&L or the U.S. Government. The U.S. Government
is authorized to reproduce and distribute reprints for Government
purposes notwithstanding any copyright notation herein.
REFERENCES
[1]ActivityLifecycle2022. TheActivityLifecycle. https://developer.android.com/
guide/components/activities/activity-lifecycle . Accessed:2022-04-12.
[2]AlfredV.Aho,MonicaS.Lam,RaviSethi,andJeﬀreyD.Ullman.2006. Compil-
ers: Principles, Techniques, and Tools (2nd Edition) . Addison-Wesley Longman
Publishing Co., Inc.,USA.
1405ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA Nima Karimipour,JustinPham, Lazaro Clapp, andManu Sridharan
[3]JohannesBader,AndrewScott,MichaelPradel,andSatishChandra.2019. Getaﬁx:
LearningtoFixBugsAutomatically. Proc.ACMProgram.Lang. 3,OOPSLA,Article
159(oct 2019),27pages. https://doi.org/10.1145/3360585
[4]SubarnoBanerjee,LazaroClapp,andManuSridharan.2019. NullAway:Practical
Type-basedNullSafetyforJava.In Proceedingsofthe201927thACMJointMeeting
on European Software Engineering Conference and Symposium on the Foundations
ofSoftwareEngineering (ESEC/FSE) .https://doi.org/10.1145/3338906.3338919
[5]Berkay Berabi, Jingxuan He, Veselin Raychev, and Martin T. Vechev. 2021. TFix:
LearningtoFixCodingErrorswithaText-to-TextTransformer.In Proceedings
ofthe38thInternationalConferenceonMachineLearning,ICML2021,18-24July
2021,VirtualEvent (ProceedingsofMachineLearningResearch,Vol.139) ,Marina
Meila and Tong Zhang (Eds.). PMLR, 780–791. http://proceedings.mlr.press/
v139/berabi21a.html
[6]JohnPeterCampora,ShengChen,MartinErwig,andEricWalkingshaw.2018.
MigratingGradualTypes. Proc.ACMProgram.Lang. 2,POPL,Article15(2018),
29pages. https://doi.org/10.1145/3158103
[7]CFInference2022. CheckerFrameworkInference. https://github.com/opprop/
checker-framework-inference . Accessed:2022-04-02.
[8]DaikonNullable 2022. Daikon AnnotateNullable support. http://plse.cs.
washington.edu/daikon/download/doc/daikon.html#AnnotateNullable . Ac-
cessed:2022-04-12.
[9]Werner Dietl, Stephanie Dietzel, Michael D. Ernst, Kıvanç Muşlu, and Todd
Schiller. 2011. Building and using pluggable type-checkers. In ICSE 2011, Pro-
ceedings of the 33rd International Conference on Software Engineering . Waikiki,
Hawaii, USA,681–690. https://doi.org/10.1145/1985793.1985889
[10]Eradicate 2022. Infer : Eradicate. https://fbinfer.com/docs/checker-eradicate
Accessed:2022-04-07.
[11]Michael D. Ernst, Jeﬀ H. Perkins, Philip J. Guo, Stephen McCamant, Carlos
Pacheco, Matthew S. Tschantz, and Chen Xiao. 2007. The Daikon system for
dynamicdetectionoflikelyinvariants. ScienceofComputerProgramming 69,1–3
(Dec. 2007),35–45. https://doi.org/10.1016/j.scico.2007.01.015
[12] ErrorProne 2022. ErrorProne. http://errorprone.info/ Accessed:2022-04-07.
[13]JeﬀreyS.Foster,ManuelFähndrich,andAlexanderAiken.1999. ATheoryofType
Qualiﬁers. In Proceedings of the 1999 ACM SIGPLAN Conference on Programming
LanguageDesignandImplementation(PLDI),Atlanta,Georgia,USA,May1-4,1999 .
192–203. https://doi.org/10.1145/301618.301665
[14] Gradle 2022. Gradle Build Tool. https://gradle.org . Accessed: 2022-04-03.
[15] gRPC 2022. gRPC. https://grpc.io . Accessed:2022-04-07.
[16]Vincent J. Hellendoorn, Christian Bird, Earl T. Barr, and Miltiadis Allamanis.
2018. DeepLearningTypeInference.In Proceedingsofthe201826thACMJoint
Meeting on European Software Engineering Conference and Symposium on the
Foundations of Software Engineering (Lake Buena Vista, FL, USA) (ESEC/FSE
2018). Association for Computing Machinery, New York, NY, USA, 152–162.
https://doi.org/10.1145/3236024.3236051
[17]DavidHovemeyer,JaimeSpacco,andWilliamPugh.2005. EvaluatingandTun-
ing a Static Analysis to Find Null Pointer Bugs. In Proceedings of the 6th ACM
SIGPLAN-SIGSOFTWorkshoponProgramAnalysisforSoftwareToolsandEngi-
neering(Lisbon,Portugal) (PASTE’05) .AssociationforComputingMachinery,
NewYork, NY, USA,13–19. https://doi.org/10.1145/1108792.1108798
[18]Thore Husfeldt. 2015. Graph colouring algorithms. https://doi.org/10.48550/
ARXIV.1505.05825 arXivpre-print 1505.05825.
[19] JavaParser2022. JavaParser. https://javaparser.org . Accessed:2022-04-02.
[20]MartinKellogg, Daniel Daskiewicz,Loi Ngo DucNguyen,Muyeed Ahmed,and
MichaelD.Ernst.2023. Pluggabletypeinferenceforfree.In ASE2023:Proceedings
of the 38th Annual International Conference on Automated Software Engineering .
[21]Kotlin2022. KotlinProgrammingLanguage. https://kotlinlang.org/ . Accessed:
2022-04-07.
[22]Alexey Loginov, Eran Yahav, Satish Chandra, Stephen Fink, Noam Rinetzky, and
Mangala Nanda. 2008. Verifying Dereference Safety via Expanding-Scope Analy-
sis.InProceedingsofthe2008InternationalSymposiumonSoftwareTestingand
Analysis(Seattle,WA,USA) (ISSTA’08) .AssociationforComputingMachinery,
NewYork, NY, USA,213–224. https://doi.org/10.1145/1390630.1390657[23]Calvin Loncaric, Satish Chandra, Cole Schlesinger, and Manu Sridharan. 2016. A
Practical Framework for Type Inference Error Explanation. SIGPLAN Not. 51, 10
(oct 2016),781–799. https://doi.org/10.1145/3022671.2983994
[24]RavichandhranMadhavanandRaghavanKomondoor.2011. Nulldereferencever-
iﬁcation via over-approximated weakest pre-conditions analysis. In Proceedings
ofthe26thAnnualACMSIGPLANConferenceonObject-OrientedProgramming,
Systems,Languages,andApplications,OOPSLA2011,partofSPLASH2011,Port-
land, OR, USA, October 22 - 27, 2011 . 1033–1052. https://doi.org/10.1145/2048066.
2048144
[25]Zeina Migeed and Jens Palsberg. 2020. What is Decidable about Gradual Types?
Proc.ACMProgram.Lang. 4,POPL,Article29(2020),29pages. https://doi.org/
10.1145/3371097
[26]NachiappanNagappanand ThomasBall.2005. Use ofrelativecodechurnmea-
surestopredictsystemdefectdensity.In 27thInternationalConferenceonSoft-
ware Engineering (ICSE 2005), 15-21 May 2005, St. Louis, Missouri, USA , Gruia-
CatalinRoman,WilliamG.Griswold,andBasharNuseibeh(Eds.).ACM,284–292.
https://doi.org/10.1145/1062455.1062514
[27]NAHandlers2022. NullAwayhandlerimplementations. https://github.com/uber/
NullAway/tree/master/nullaway/src/main/java/com/uber/nullaway/handlers .
Accessed:2022-04-07.
[28]Matthew M. Papi, Mahmood Ali, Telmo Luis Correa Jr., Jeﬀ H. Perkins, and
MichaelD.Ernst.2008. PracticalpluggabletypesforJava.In ISSTA2008,Proceed-
ingsofthe2008InternationalSymposiumonSoftwareTestingandAnalysis .Seattle,
WA, USA,201–212. https://doi.org/10.1145/1390630.1390656
[29]ZvonimirPavlinovic,TimKing,andThomasWies.2014. FindingMinimumType
Error Sources. In Proceedings of the 2014 ACM International Conference on Object
Oriented ProgrammingSystems Languages and Applications (OOPSLA) (Portland,
Oregon, USA) (OOPSLA ’14) . Association for Computing Machinery, New York,
NY, USA,525–542. https://doi.org/10.1145/2660193.2660230
[30]Luna Phipps-Costin, Carolyn Jane Anderson, Michael Greenberg, and Arjun
Guha. 2021. Solver-Based Gradual Type Migration. Proc. ACM Program. Lang. 5,
OOPSLA, Article111(oct 2021),27pages. https://doi.org/10.1145/3485488
[31]ArtemPianykh,IlyaZorin,andDmitryLyubarskiy.2023. Retroﬁttingnull-safety
ontoJavaatMeta. https://engineering.fb.com/2022/11/22/developer-tools/meta-
java-nullsafe/ Accessed:2023-02-01.
[32]Benjamin C. Pierce. 2002. Types and Programming Languages (1st ed.). The MIT
Press.
[33]Rachel Potvinand Josh Levenberg. 2016. WhyGoogle StoresBillions ofLines
ofCodeinaSingleRepository. Commun.ACM 59,7(jun2016),78–87. https:
//doi.org/10.1145/2854146
[34]Michael Pradel, Georgios Gousios,Jason Liu, and SatishChandra.2020. Type-
Writer:NeuralTypePredictionwithSearch-BasedValidation.In Proceedingsofthe
28thACMJointMeetingonEuropeanSoftwareEngineeringConferenceandSympo-
sium on the Foundations of Software Engineering . Association for Computing Ma-
chinery, New York, NY, USA, 209–220. https://doi.org/10.1145/3368089.3409715
[35]Swift 2022. Swift Programming Language. https://swift.org/ . Accessed: 2022-04-
07.
[36]Mohsen Vakilian, Amarin Phaosawasdi, Michael D. Ernst, and Ralph E. Johnson.
2015. Cascade:A Universal Programmer-Assisted Type Qualiﬁer Inference Tool.
InProceedings of the 37th International Conference on Software Engineering -
Volume 1 (Florence, Italy) (ICSE’15) . IEEE Press,234–245.
[37]WALA 2023. T.J. Watson Libraries for Analysis (WALA). http://wala.sourceforge.
net.
[38]Tongtong Xiang, Jeﬀ Y. Luo, and Werner Dietl. 2020. Precise inference of expres-
siveunitsofmeasurementtypes. Proc.ACMProgram.Lang. 4,OOPSLA(2020),
142:1–142:28. https://doi.org/10.1145/3428210
[39]DanfengZhang,AndrewC.Myers,DimitriosVytiniotis,andSimonPeyton-Jones.
2017. SHErrLoc:AStaticHolisticErrorLocator. ACMTrans.Program.Lang.Syst.
39,4,Article18(aug 2017),47pages. https://doi.org/10.1145/3121137
Received 2023-02-02; accepted 2023-07-27
1406