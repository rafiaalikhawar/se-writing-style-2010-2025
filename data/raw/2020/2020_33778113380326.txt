Revealing Injection Vulnerabilities by Leveraging Existing Tests
Katherine Hough1, Gebrehiwet Welearegai2, Christian Hammer2and Jonathan Bell1
1George Mason University, Fairfax, VA, USA
2University of Potsdam, Potsdam, Germany
khough2@gmu.edu,welearegai@uni-potsdam.de,hammer@cs.uni-potsdam.de,bellj@gmu.edu
Abstract
Codeinjectionattacks,liketheoneusedinthehigh-profile2017
Equifaxbreach,havebecomeincreasinglycommon,nowranking
#1onOWASP‚Äôslistofcriticalwebapplicationvulnerabilities.Static
analysesfordetectingthesevulnerabilitiescanoverwhelmdevelop-
ers with false positive reports. Meanwhile, most dynamic analyses
relyondetectingvulnerabilitiesastheyoccurinthefield,whichcan introduce a high performance overhead in production code.
This paper describes a new approach for detecting injection vul-
nerabilitiesinapplicationsbyharnessingthecombinedpowerof
human developers‚Äô test suites and automated dynamic analysis.
Our new approach, Rivulet, monitors the execution of developer-
written functional tests in order to detect information flows that
may be vulnerable to attack. Then, Rivulet uses a white-box test
generationtechniquetorepurposethose functionalteststocheck
if any vulnerable flow could be exploited. When applied to the ver-
sionofApacheStrutsexploitedinthe2017Equifaxattack,Rivulet
quicklyidentifiesthevulnerability,leveragingonlytheteststhat
existedinStrutsatthattime.WecomparedRivulettothestate-of-
the-artstaticvulnerabilitydetector Juliaonbenchmarks,finding
thatRivuletoutperformed Juliainbothfalsepositivesandfalse
negatives. We also used Rivulet to detect new vulnerabilities.
CCS Concepts
‚Ä¢Securityandprivacy ‚ÜíVulnerabilitymanagement ;Web
application security ;‚Ä¢Software and its engineering ‚ÜíSoft-
ware testing and debugging.
Keywords
injection attacks, vulnerability testing, taint tracking
ACM Reference Format:
KatherineHough,GebrehiwetWelearegai,ChristianHammerandJonathan
Bell. 2020. Revealing Injection Vulnerabilities by Leveraging Existing Tests.
In42nd International Conference on Software Engineering (ICSE ‚Äô20), May
23‚Äì29,2020,Seoul,RepublicofKorea. ACM,NewYork,NY,USA,13pages.
https://doi.org/10.1145/3377811.3380326
1 Introduction
Inthehigh-profile2017 Equifaxattack,millionsofindividuals‚Äô
private data was stolen, costing the firm nearly one and a halfbilliondollars in remediation efforts [
55]. This attack leveraged
acode injection exploit in Apache Struts (CVE-2017-5638) and is
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô20, May 23‚Äì29, 2020, Seoul, Republic of Korea
¬© 2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380326just one of over 8,200 similar code injection exploits discovered in
recentyearsinpopularsoftware[ 44].Codeinjectionvulnerabilities
havebeenexploitedinrepeatedattacksonUSelectionsystems[ 10,
18,39,61], in the theft of sensitive financial data [ 56], and in the
theft of millions of credit card numbers [ 33]. In the past several
years, code injection attacks have persistently ranked at the top
of the Open Web Application Security Project (OWASP) top ten
most dangerous web flaws [ 46]. Injection attacks can be damaging
evenforapplicationsthatare nottraditionallyconsideredcritical
targets, such as personal websites, because attackers can use them
as footholds to launch more complicated attacks.
In a code injection attack, an adversary crafts a malicious in-
put that gets interpreted by the application as code rather than
data.Theseweaknesses,‚Äúinjectionflaws,‚Äùaresodifficulttodetectthat rather than suggesting testing as a defense, OWASP suggests
thatdeveloperstrytoavoidusingAPIsthatmightbetargetedby
attackersaltogetheror enforcesite-wideinputfiltering.Consider
againtheEquifaxhack:theunderlyingweaknessthatwasexploited
was originally introduced in 2011 and sat undetected in production
aroundtheworld(notjustatEquifax)for sixyears[4,43].While
someexpertsblameEquifaxforthesuccessfulattack‚Äîapatchhadbeenreleasedtwomonthspriortotheattack,butwasnotapplied‚Äî
one really has to ask: how is it possible that critical vulnerabilities
go unnoticed in production software for so long?
Withtheexceptionofsafety-criticalandsimilar‚Äúhigh-assurance‚Äù
software,generalbestpracticescallfordeveloperstoextensively
testtheirapplications,toperformcodereviews,andperhapstorun
staticanalyzerstodetectpotentiallyweakpartsoftheirsoftware.
Unfortunately,testingisanever-endingprocess:howdodevelopers
knowthatthey‚Äôvetrulytestedallinputscenarios?Tocatchcode
injectionexploitsjust-in-time,researchershaveproposeddeployingdynamictainttracking frameworks,whichtrackinformationflows,
ensuringthatuntrustedinputsdonotflowintosensitivepartsof
applications, e.g.,interpreters [ 8,21,38,54,58,63]. However, these
approaches have prohibitive runtime overheads: even the most
performantcanimposeaslowdownofatleast10‚Äì20%andoftenfar
more [8,12,15,31]. Although black-box fuzzers can be connected
withtainttrackingtodetectvulnerabilitiesinthelab,itisdifficultto
use these approaches on stateful applications or those that require
structured inputs [ 23,32]. While some static analysis tools have
seen recent developeradoption [ 9,19,45], statically detecting code
injection vulnerabilities is challenging since static analysis tools
must perform interprocedural data flow analysis [7, 59, 60, 71].
Our key idea is to use dynamic taint tracking before deployment
toamplifydeveloper-writtenteststocheckforinjectionvulnera-
bilities.Theseintegrationteststypicallyperformfunctionalchecks.Ourapproachre-executestheseexistingtestcases, mutating values
thatarecontrolledbyusers(e.g., partsofeachofthetest‚ÄôsHTTP
requests) and detecting when these mutated values result in real
2842020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
attacks. To our knowledge, this is the firstapproach that combines
dynamic analysis with existing tests to detect injection attacks.
Key to our test amplification approach is a white-box context-
sensitiveinput generation strategy. For each user-controlled value,
state-of-the-art testing tools generate hundreds of attack strings to
testtheapplication[ 32,49,50].Byleveragingthecontextof how
that user-controlled value is used in security-sensitive parts of the
application,wecantriviallyruleoutmostofthecandidateattack
stringsforanygivenvalue,reducingthenumberofvaluestocheck
by orders of magnitude. Our testing-based approach borrows ideas
from both fuzzing and regression testing, and is language agnostic.
WeimplementedthisapproachintheJVM,creatingatoolthatwe
callRivulet.RivuletRevealsInjectionVUlnerabilitiesbyLeverag-
ingExistingTests,anddoesnotrequireaccesstoapplicationsource
code, and runs in commodity, off-the-shelf JVMs, integrating di-
rectly with the popular build automation platform Maven.
Likeanytesting-basedapproach,Rivuletisnotguaranteedto
detect all vulnerabilities. However, Rivulet guarantees that every
vulnerability that it reports meets strict criteria for demonstrating
an attack. We found that Rivulet performed as well as or betterthan a state-of-the-art static vulnerability detection tool [
59]o n
severalbenchmarks.RivuletdiscoverstheApacheStrutsvulner-
ability exploited in 2017 Equifax hack within minutes. When we
ran Rivulet with the open-source project Jenkins, Rivulet found
apreviouslyunknowncross-sitescriptingvulnerability,whichwasconfirmedbythedevelopers.Ontheeducationalproject iTrust[
22],
Rivuletfound5previouslyunknownvulnerabilities.Unlikethe
state-of-the-artstaticanalysistoolthatweused,Julia[ 59],Rivulet
did not show anyfalse positives.
Using dynamic analysis to detect injection vulnerabilities before
deployment is hard, and we have identified two key challenges
that have limited past attempts: (1) Unlike static analysis, dynamic
analysis requires a representative workload to execute the applica-
tion under analysis; and (2) For each potential attack vector, there
may be hundreds of input strings that should be checked. Rivulet
addressesthesechallenges,makingthefollowingkeycontributions:
‚Ä¢A technique for re-using functional test cases to detect secu-
rity vulnerabilities by modifying their inputs and oracles
‚Ä¢Context-sensitivemutationalinputgeneratorsforSQL,OGNL,
and XSS that handle complex, stateful applications
‚Ä¢Embedded attack detectors to verify whether rerunning a
test with new inputs leads to valid attacks
Rivulet is publicly available under the MIT license [24, 25].
2 Background and Motivating Example
Injectionvulnerabilitiescomeinavarietyofflavors,asattack-
ers may be able to insert different kinds of code into the target
application.Perhapsthemostclassictypeofinjectionattackis SQL
Injection(SQLI),whereattackerscancontrolthecontentsofanSQL
statement. For instance, consider this Java-like code snippet that is
intendedtoselectandthendisplaythedetailsofauserfromadata-
base:execQuery("SELECT * from Users where name = '" +
name +"'");. Ifanattackercanarbitrarilycontrolthevalueof
thenamevariable,thentheymayperformaSQLinjectionattack.
Forinstance,theattackercouldsupplythevalue name ="Bob'
OR '1'='1" which,whenjoinedtothequerystringwillproduce
wherename ='Bob'OR'1'='1',whichwouldresultin allrowsin this user table being selected. SQLI attacks may result in data
breaches, denial of service attacks, and privilege escalations.
Remote Code Execution (RCE) vulnerabilities are a form of injec-
tionvulnerabilitieswhereanattackercanexecutearbitrarycode
on an application server using the same system-level privileges as
the application itself. Command injection attacks are a particularly
dangerous form of RCE where an attacker may directly execute
shellcommandsontheserver.OtherRCEattacksmaytargetfea-
tures of the application runtime that parse and execute code in
other languages such as J2EE EL [47] or OGNL [66, 67].
Cross-siteScripting(XSS) vulnerabilitiesaresimilartoRCE,but
resultincodebeingexecutedbyauser‚Äôsbrowser,ratherthanon
theserver.XSSattacksoccurwhenausercancraftarequestthat
inserts arbitrary HTML, Javascript code, or both into the response
returnedbytheserver-sideapplication. Suchanattackmighthijack
a user‚Äôssession (allowingthe attackerto impersonatethe useron
that website), steal sensitive data, or inject key loggers. Server-side
XSSattacksmaybe reflectedorpersistent.ReflectedXSSattacksare
typically used in the context of a phishing scheme, where a user
is sent a link to a trusted website with the attack embedded in the
link. Persistent XSS attacks occur when a payload is stored in the
host system (e.g., in a database) and is presented to users who visit
the compromised site.
Developersdefendtheirsoftwarefrominjectionattacksthrough
input validation and sanitization. Broadly, validation is a set of
whitelistingtechniques,suchas:‚Äúonlyacceptinputsthatmatcha
limited set of characters,‚Äù while sanitization is a set of transforma-
tions that render attacks harmless, such as: ‚Äúescape all quotationmarks in user input.‚Äù Ideally, each user-controlled input (also re-
ferred to as a ‚Äútainted source‚Äù) that can reach critical methods that
may result in code execution (also referred to as a ‚Äúsensitive sink‚Äù)
willbeproperlysanitized,validated,orboth.Reachingsuchanideal
stateisnon-trivial[ 37].Hence,thekeychallengeindetectingthese
vulnerabilitiesistodetectflowsfromtaintedsourcestosensitive
sinks that have not been properly sanitized.
Listing1showsasimplifiedexampleoftwogenuinecross-site
scriptingvulnerabilities.Lines9and10showaparameterprovidedbytheuserflowingintotheresponsesentbacktothebrowser with-
outpropersanitization.Inthefirstcase(line9),thevulnerability
occurs despite an attempt to sanitize the user‚Äôs input (using the
ApacheCommons-Languagelibraryfunction escapeHtml4 ),and
in the second case (line 10), there is no sanitization at all.
1@Override
2public void doGet(HttpServletRequest request ,
HttpServletResponse response) throws IOException {
3String name = request.getPa rameter( "name");
4response.se tContentType( "text/html" );
5String es caped = StringEscapeUtils. escapeHtml4( name) ;
6String co ntent = "<a href=\"%s\">hello </a>" ;
7try( PrintWriter pw = response. getWriter()) {
8pw.println( "<html><body>" );
9pw.println(St ring.format(con tent , escaped));
10pw.println(St ring.format(con tent ,name) ) ;
11pw.println( "</body></html>" );
12}
13}
Listing1:TwoexampleXSSvulnerabilities. Anuntrusteduser
inputfromanHTTPrequestflowsintotheresponsetothebrowser
on lines 9 and 10.
2853. Attack Detection 1. Candidate Test Detection
<>‚Ä¶<><>‚Ä¶<>,

 
*+*+
	0-./Warning!
Execute Test with Dynamic Taint Tracking
,
 
*+)&0!)&0!
	0-./
RIVULET  Request Interceptor
)&0!)&0!
	0-./App Under Test2. Rerun Generation
,
 
*+*+
	01
2#1)2Rerun Config:
HTTP response value:
1"21%$$
%$$212*'%(+1)
21%$$
$$21)"2Run original test suite with 
taint tracking and collect 
resultsPotentially vulnerable tests and flows
Rerun each test with substitutionsSource-sink values and flows from 
reruns
Source: 	0-./Sink: 

HTTP response value:
1"21%$$
12*'%(+1)2
$$21)"2
Vulnerability not confirmed (contained 
in a comment)
Vulnerability confirmed by rerun!
Vulnerability Reproduction Script
Figure 1: High-Level Overview of Rivulet. Rivulet detects vulnerabilities in three phases. Key to our approach is the repeated
execution of developer-provided test cases with dynamic taint tracking. First, each developer-provided test is executed using taint tracking
to detect which tests expose potentially vulnerable data flows. HTTP requests made during a test are intercepted and parsed into their
syntacticelementswhicharethentaintedwithidentifyinginformation.Then,source-sinkflowsobservedduringtestexecutionarerecorded
and passed with contextual information to a rerun generator. The rerun generator creates rerun configurations using the supplied flow
and contextual information, and executes these reruns, swapping out developer-provided inputs for malicious payloads. Source-sink flows
observedduringtestre-executionarepassedtoanattackdetectorwhichverifiessource-sinkflowsthatdemonstrategenuinevulnerabilities.
In either case, providing the input string javascript:alert(
'XSS'); for the parameter "name"will result in JavaScript code
executing in the client‚Äôs browser if they click on the link. The
chosen sanitizer escapes any HTML characters in the input string
(i.e.,preventing an injection of a <script> tag), but isinsufficient
forthiscase,asanattackerneedonlypasstheprefix javascript:
intheirpayloadtocausecodetoexecutewhentheuserclickson
this link (many XSS attack payloads do not include brackets or
quotes for this reason [50]).
Tofix thisvulnerability,thedeveloperneedsto applyasanitiz-
ingfunctionthatpreventstheinsertionofJavaScriptcode.Static
analysistools,suchasthestate-of-the-artJuliaplatform[ 59],typ-
icallyassumethatlibrarymethodspre-definedassanitizersfora
class of attack (e.g., XSS sanitizers) eliminate vulnerabilities for the
dataflowsthattheyare appliedto.Inourtesting-basedapproach,
sanitizer methods do not need to be annotated by users. Instead
we test whether a flow is adequately sanitized by attempting to
generate a counterexample (i.e., a malicious payload that produces
a successful injection attack).
3 Approach Overview
Generatingteststhatexposetherichbehaviorofcomplicated,
statefulwebapplicationscanbequitedifficult.Forinstance,con-
sideravulnerabilityinahealthrecordsapplicationthatcanonly
be discovered by logging in to a system, submitting some health
data, and sending a message to a healthcare provider. Fuzzers have
longstruggledtogenerateinputsthatfollowamulti-stepworkflow
likethisexample[ 23,32].Instead,Rivuletbeginsbyexecutingthe
existing, ordinary test suite that developers have written, whichdoesnotneed to have any security checks included in it: in this
healthcaremessaging example, an existing testmight simplycheck
that the workflow completes without an error. As we showin our
evaluation (¬ß5), even small test suites can be used by Rivulet to
detect vulnerabilities.
Figure 1 shows a high-level overview of Rivulet‚Äôs three-step
processtodetectinjectionvulnerabilitiesinwebapplications.First,
Rivulet uses dynamic taint tracking while running each test toobserve data flows from ‚Äúsources,‚Äù untrusted system inputs con-
trolledbyapotentiallymaliciousactor,to‚Äúsinks,‚Äùsensitivepartsof
anapplicationthatmaybevulnerabletoinjectionattacks.These
source-sink flows do not necessarily represent vulnerabilities: it is
possible that a sanitizer function correctly protects the application.
Hence, when a source-sink flow is observed, Rivulet generatesmalicious payloads based on contextual information of the sinkmethod. Then, tests are re-executed and those untrusted source
valuesarereplacedwithgeneratedpayloads,probingforweakor
missing sanitizers. Lastly, specialized logic based on the type of
vulnerability, e.g.,XSS, is used as an oracle to determine whether a
re-execution demonstratesa successfulattack, thereby transform-
ing a functional test into a security test.
In thisway, source-sink flowsare verifiedas vulnerable onlyif
asuccessfulattackcanbedemonstratedusingaconcreteexploit.
This standard produces few false positives. Test reruns enable our
technique to consider input sanitization and validation without
requiringsanitizationandvalidationmethodstobeexplicitlyspeci-fiedormodeled.Verifyingwhetherasanitizerorvalidatoriscorrect
in all cases is a hard problem and beyond the scope of this work.
However, if a system sanitizes or validates input improperly before
it flows into a sink method, then one of the malicious payloadsmay be able to demonstrate a successful attack, causing the flowto be verified. Our implementation of Rivulet (described in ¬ß4)automatically detects SQL injection, remote code execution, and
cross-site scripting vulnerabilities: developers do not need to spec-
ifyanyadditionalsourcesorsinksinordertofindthesekindsof
vulnerabilities.Section4describes,indetail,thespecificstrategy
that Rivulet uses to find these kinds of vulnerabilities.
3.1 Detecting Candidate Tests
Rivuletco-optsexisting,functionaltestcasestotestforsecurity
properties by mutating user-controlled inputs and adding security-
basedoraclestodetectcodethatisvulnerabletoinjectionattacks.
We assume that developers write tests that demonstrate typical ap-
plicationbehavior,andourapproachreliesonautomatedtestingtodetectweakormissingsanitization.Thisassumptionisgroundedin
286bestpracticesforsoftwaredevelopment:weassumethatdevelopers
willimplementsomeformofautomatedfunctionaltestingbefore
scrutinizingtheirapplication forsecurityvulnerabilities. Rivulet
detects candidate tests by executing each test using dynamic taint
tracking,identifyingteststhatexposepotentiallyvulnerablesource-
sink flows,each of whichwe refer toas a violation. Byleveraging
developer tests, our approach can detect vulnerabilities that can
only be revealed through a complex sequence of actions. These
vulnerabilities can be difficult for test generation approaches to
detect, but are critical when dealing with stateful applications [ 32].
In this model, developers do notneed to write test cases that
demonstrateanattack‚Äîinstead,theyneedonlywritetestcases
that expose an information flow that is vulnerable to an attack. For
instance, consider a recent Apache Struts vulnerability (CVE-2017-
9791)thatalloweduser-providedwebforminputtoflowdirectly
into the Object-Graph Navigation Language (OGNL) engine. Struts
includes a sample application for keeping track of the names of
differentpeople,thisapplicationcanbeusedtodemonstratethis
vulnerability by placing an attack string in the ‚Äúsave person‚Äù form.
Todetectthisvulnerability,wedo notneedtoobserveatestcase
thatusesanattackstringintheinput,instead,weneedonlyobserveanytestthatsaves anystringthroughthisforminordertoobserve
the insecure informationflow. Once this isdetected, Rivulet, can
thenre-executeandperturbthetestcase,mutatingthevalueofthe
form field, eventually demonstrating the exploit.
3.2 Rerun Generation and Execution
The next phase in Rivulet‚Äôs vulnerability detection process
is to re-execute each test, perturbing the inputs that the serverreceivedfromthetestcaseinordertoaddmaliciouspayloads.A
significantchallengetoourapproachisinthepotentiallyenormous
number of reruns that Rivulet needs to perform in order to test
each potentially vulnerable source-sink flow. If an application has
thousands of tests, each of which may have dozensof potentially
vulnerableflows,itiscrucialtolimitthenumberoftimesthateach
test needs to be perturbed and re-executed. Unfortunately, it istypical to consider over 100different malicious XSS payloads for
eachpotentially vulnerable input [
32,50], and other attacks may
still call for dozens of malicious payloads.
Instead,Rivuletusesawhite-box,insituapproachtopayload
generation in order to drastically reduce the number of reruns
needed to evaluate a source-sink flow. Successful injection attacks
oftenneedtomodifythesyntacticstructureofaquery,documentorcommandfromwhatwasintendedbythedeveloper[
62].Bylooking
at the placement of taint tags (representing each source) within
structuredvaluesthatreachsinkmethods, i.e.,thesyntacticcontext
intowhichuntrustedvaluesflow,thenumberofpayloadsneeded
totestaflowcanbelimitedtoonlythosecapableofdisruptingthat
structure from the tainted portions of the value.
For instance, when an untrusted value reaches a sink method
vulnerabletoSQLinjectionattacks,developersusuallyintendfor
thevalue tobetreated asastring ornumericliteral. Considerthe
followingSQLquery: SELECT*FROManimals WHEREname ='
%Tiger%'; wheretheword Tigerisfoundtobetainted.Inorder
to modify the structure of the query, a payload must be able to end
the single-quoted string literal containing the tainted portion of
the query. Payloads which do not contain a single-quote would beineffective in this context, e.g.,payloads that aim to end double-
quotedstringliterals,anddonotneedtobetestedwhenevaluating
this flow. Rivulet uses a similar approach for generating payloads
for other kinds of attacks, as we will describe in ¬ß 4.2.
3.3 Attack Detection
Theattackdetectorcomponentprovidestheoracleforeachmod-
ifiedtest(removinganyexistingassertions),determiningifthenewinputresultedinasuccessfulattackonthesystemundertest.Thereisanaturalinterdependencebetweenpayloadgenerationandattackdetection.Attackdetectionlogicmustbeabletodeterminethesuc-cess of an attack using any of the payloads that could be generated
by Rivulet. Likewise, generated payloads should aim to trigger a
successfuldeterminationfromthedetectionlogic.Thisrelationshipcanbeusednotonlytoguidepayloadgeneration,butalsotoenable
stricter(andsimplertoimplement)criteriafordeterminingwhat
constitutes a successful attack. Specifically, it is not necessary torecognize all possible successful attacks, but instead, only those
generatedbythesystem.Furthermore,thisreducesthedifficulty
of formulating an appropriate detection procedure, particularly for
certaintypesofattacks.Rivulet‚Äôsattackdetectorsinspectboththe
taint tags and concrete values of data that reaches sensitive sinks.
4 Implementation
Our implementation of Rivulet for Java is built using the Phos-
phor taint tracking framework [ 8], and automatically configures
thepopularbuildandtestmanagementplatform Maventoperform
dynamic tainttracking during the executionof developer-written
tests,generatemaliciouspayloadsbasedonsource-sinkflowsob-
servedduring testexecution, andexecute testreruns.Developers
can use Rivulet by simply adding a single maven extension totheir build configuration file: Rivulet and Maven automatically
configuretherest.Outofthebox,Rivuletdetectscross-sitescript-ing, SQL injection, and OGNL injection vulnerabilities without any
additional configuration. Phosphor propagates taint tags by rewrit-
ing Java bytecode using the ASM bytecode instrumentation andanalysis framework [
51], and does not require access to applica-
tion orlibrary sourcecode. We chose Phosphorsince itis capable
ofperformingtainttrackingonallJavadatatypes,ensuringthat
Rivuletisnotlimitedinitsselectionofsourceandsinkmethods
to only methods that operate on strings.
4.1 Executing Tests with Dynamic Tainting
Rivulet‚Äôs approach for dynamic taint tracking within test cases
is key to its success. Taint tracking allows data to be annotated
with labels (or ‚Äútaint tags‚Äù), which are propagated through data
flows as the application runs. It is particularly critical to determine
wherethese tags are applied (the ‚Äúsource methods‚Äù) and how they
correspondtotheactualinputthatcouldcomefromauser,since
itisatthesesamesourcemethodsthatRivuletinjectsmalicious
values when rerunning tests.
ManyapproachestoapplyingtainttrackingtoHTTPrequests
in the JVM use high-level Java API methods as taint sources, such
asServletRequest.getParameter() for parameters or, for cook-
ies,HttpServletRequest.getCookies() [13,20,40,59].However,
theseapproachescanbebrittle:ifasinglesourceismissedoranew
version of the application engine is used (which adds new sources),
287theremaybefalsenegatives.Moreover,sinceapplicationmiddle-
ware (between the user‚Äôs socket request and these methods) per-
forms parsing and validation, mutating these values directly could
resultinfalsepositiveswhenreplayingandmutatingrequests.If
Rivulet performed its injection afterthe middleware parses the
HTTP request from the socket (i.e., as a user application reads a
value from the server middleware), Rivulet might generate some-
thingthatcouldneverhavepassedthemiddleware‚Äôsvalidation.For
instance,ifperformingareplacementonthemethod getCookies()
, Rivulet might try to generate a replacement value NAME=alert(
String.fromCharCode(88,88,83)) ,whichcould neverbeavalid
returnvaluefromthismethodsource,sinceHTTPcookiesmaynot
contain commas [41].
Instead of using existing Java methods as taint sources, Rivulet
uses bytecode instrumentation to intercept the bytes of HTTP
requestsdirectlyastheyarereadfromsockets.Interceptedbytesare
then buffered until a full request is read from the socket. Requests
readfromthesocketareparsedintotheirsyntacticelements, e.g.,
querystring,entity-body,andheaders.Eachelementthenpasses
throughataintsourcemethodwhichtaintsthecharactersofthe
element with the name of the source method, the index of the
characterintheelement,andanumberassignedtotherequestthat
was parsed. The original request is then reconstructed from the
taintedelementsandbrokendownbackintobyteswhicharepassed
totheobjectthatoriginallyreadfromthesocket.Thistechnique
allowsataintedvaluetobetracedbacktoarangeofindicesina
syntacticelementofaspecificrequest.Thus,thistaintingapproach
enables precise replacements to be made during test re-executions.
We have integrated Rivulet with the two most popular Java
HTTP servers,Tomcat[ 5] andJetty [ 68],using bytecodemanipu-
lation.RivuletmodifiescomponentsinTomcatandJettywhich
make method calls to read bytes from a network socket to instead
passthe receiverobject(i.e., thesocket) andargumentsofthecall
to the request interceptor. The interceptor reads bytes from anysocket passed to it, parses the bytes into a request and taints the
bytesbasedontheirsemanticlocationwithintheparsedrequest.
ItwouldbeeasytoaddsimilarsupporttootherJavawebservers,
however, Tomcat and Jetty are the most popular platforms by far.
4.2 Rerun Generation
Rivuletusesaneasy-to-reconfigure,predefinedsetofsinkmeth-
ods,whichweenumeratebyvulnerabilitytypebelow.Whenasink
methodiscalled,theargumentspassedtothecallarerecursively
checked for taint tags, i.e.,arguments are checked, the fields of
the arguments are checked, the fields of the fields of argumentschecked, and so on until to a fixed maximum checking depth isreached. If a tainted value is found during the checking process,a source-sink flow is recorded. When Rivulet finishes checking
theargumentsofthecall,itpassescontextualinformationandflow
information to a generator that handles the type of vulnerabilityassociated with the sink method that was called. The contextual
information consists of the receiver object of the sink method call
and the arguments of the call. The flow information consists of the
sourceinformationcontainedinthelabelsofthetaintedvaluesthat
were found and a description of the sink method that was called.
Rerun generators create rerun configurations identifying the
testcasethatshouldbererun,thedetectorthatshouldbeusedtodetermine whether a successful attack was demonstrated by the
rerun,theoriginalsource-sinkflowthatthererunistryingtoverify,
andatleastonereplacement.Replacementsdefineareplacement
value, information used to identify the source value that should be
replaced(targetinformation),andpossiblya‚Äústrategy‚Äùforhowthe
source value should be replaced. A replacement can either be built
as a ‚Äúpayload‚Äù replacement or a ‚Äúnon-payload‚Äù replacement.
Payload replacements are automatically assigned target infor-
mationandsometimesastrategybasedonflowinformation.For
example,thelabelsonataintedvaluethatreachedsomesinkmight
show that the value came from indices 6 ‚àí10 of the second call
tothesource getQueryString() .Onepayloadreplacementbuilt
off of that flow information would direct that the second time
getQueryString() iscalledthatitsreturnvalueshouldbereplaced
usingastrategythatreplacesonlyindicessixthroughtenwithare-placementvalue.Payloadreplacementsarehowmaliciouspayloadsarenormallyspecified,thuseveryrerunisrequired tohaveatleast
oneofthem.Non-payloadreplacementsareusefulforspecifying
secondary conditions that an attack may need in order to succeed,
such as changing the ‚ÄúContent-Type‚Äù header of a request.SQLInjection.
ThererungeneratorforSQLinjectionusesall java
.sql.Statement andjava.sql.Connection methods that accept
SQLcodeassinks,andconsidersthreeprimarySQLquerycontexts
in which a tainted value may appear: literals, comments, LIKEclauses. Tainted values appearing in other parts of the query aretreated similarly to unquoted literals. Tainted values appearingin LIKE clauses are also considered to be in literals, thus causeboth the payloads for tainted literals and tainted LIKE clauses to
begenerated.Ifataintedvalueappearsinaliteral,thegenerator
first determines the ‚Äúquoting‚Äù for the literal. A literal can be either
unquoted(likeanumericliteralmightbe),single-quoted,double-
quoted,orbacktick-quoted(usedfortableandcolumnidentifiersin
MySQL).Payloads fortaintedliterals areprefixedby astringthat
is based on the quoting of the literal in order to attempt to end the
literal.Thequotingcanalsobeusedtodetermineanappropriate
endingforpayloads.Ifataintedvalueappearsinacomment,the
generator first determines the characters used to end and startthe type of comment the value appears in. Payloads for tainted
comments are prefixed by the end characters for the comment and
ended with the start characters for the comment. If a tainted value
appearsinaLIKEclause,thegeneratorcreatespayloadscontaining
SQL wildcard characters.
Rivulet generates 2‚Äì5 SQL injection payloads for a tainted
valueinaparticularcontextoutof20uniquepayloadsthatcould
begeneratedforthesametaintedvalueacrossallofthecontexts
consideredbytheSQLinjectionrerungenerator.Ifwildcardpay-
loads for LIKE clause are not generated then only 2‚Äì3 payloads
aregeneratedpercontext.ThisisareductionfromKie≈ºun etal.‚Äôs
Ardilla, which uses 6 SQL injection patterns and does not consider
tainted backtick-quoted values, comments, or LIKE clauses [32].Cross-SiteScripting.
Rivuletusesspecialsinkcheckinglogicfor
XSS,checkingdataasitissentover-the-wiretothebrowser.The
overloadedvariantsof SocketChannel.write() areusedassink
methodsforXSSattacks.InordertogivetheXSSgeneratorallof
theHTMLcontentforasingleresponseatonce,Rivuletstoresthe
byteswrittentoasocketuntilafullresponsecanbeparsedfrom
thebytes.IftheparsedresponsecontainsHTMLcontentandthe
288HTML in the response‚Äôs entity-body contains a tainted value, then
that HTML is passed to the XSS rerun generator.
TheXSSrerungeneratorparsesHTMLcontentintoanHTML
document model using the Jsoup library [ 29]. This model is tra-
versed,generatingpayloadsforeachtaintedvalueencountered.The
XSSrerungeneratorconsiders5primaryHTMLdocumentcontexts
inwhichataintedvaluemayappear:tagnames,attributenames,
attribute values, text or data content, and comments. Different pay-
loadsarecapableofintroducingascript-triggeringmechanisminto
the document‚Äôs structuredepending on the context. Rivulet also
addressescontext-specificissueslikethequotingofattributevalues
or whether content is contained in an element which causes the
tokenizer to leave the data state during parsing [74].
TheXSSgeneratoralsoconsiderswhetherataintedvaluewas
placedinacontextthatwouldalreadybeclassifiedasanembedded
script or the address of an external script. Furthermore, if a tainted
value appears in a context that would be classified as an embedded
scriptthenthegeneratoralsodetermineswhetherthetaintedvalue
is contained within a string literal, template literal, or comment.
Rivulet generates 3‚Äì7 XSS payloads for a tainted value in a
particular context out of over 100 unique payloads that could begenerated for the same tainted value across all of the contexts
consideredbytheXSSrerungenerator.Bycomparison,OWASP‚Äôs
‚ÄúXSS Filter Evasion Cheat Sheet‚Äù features152 unique payloads for
cross-site scripting attacks [ 50] and Ardilla uses 106 patterns for
creating cross-site scripting attacks [32].Command and OGNL Injection.
The command injection rerun
generator creates payloads with common UNIX commands like ls,
considering java.lang.ProcessBuilder andjava.lang.Runtime
methods as sinks.
TheOGNLinjectionrerungeneratorcreatespayloadsthatfacili-
tateattackdetection.ItcanbedifficulttospecifygenericcriteriafordetectinganyOGNLinjectionattackbecausethelanguageisdesigned to allow users to execute ‚Äúnon-malicious‚Äù code. OGNL
expressionscanmodifyJavaobjects‚Äôproperties,accessJavaobjects‚Äô
propertiesandmakemethodcalls[ 66].ApplicationsusingOGNL
can limit the code that user specified expressions can execute by
whitelisting or blacklisting certain patterns [ 67]. The evaluation
of improperly validated OGNL expressions can enable a user to
executearbitrarycode.TheOGNLrerungeneratorusespayloads
that we collected from the Exploit Database [ 16] and simplified to
integrate more tightly with Rivulet‚Äôs attack detection mechanism.
RerunExecution. Rerunconfigurationscreatedbythererungen-
erators specify test cases that should be re-executed. Values arereplaced when they are assigned a label at a source method andthe information on the label being assigned to the value meetsthe criteria specified by one of the current rerun configuration‚Äôsreplacements. Replacements may dictate a strategy for replacingthe original value; strategies can specify ways of combining anoriginal value with a replacement value, a way of modifying the
replacementvalue,orboth.Forexample,astrategycouldspecify
that only a certain range of indices in the original value should be
replaced, that the replacement value should be percent encoded,
orboth.Rivuletautomaticallyconvertsvaluestoensurethatthe
typeofareplacementvalueisappropriate(e.g., convertingbetween
a string and a character array).4.3 Attack Detection
Rerun configurations specify which vulnerability-specific attack
detector should be used to check flows during a test re-execution.SQL Injection.
Our approach for detecting SQL injection attack
builds on Halfond et al.‚Äôs ‚Äúsyntax-aware evaluation‚Äù model, which
calls for checking that all parts of SQL queries except for string
and numeric literals come from trusted sources [ 21]. We determine
a SQL injection attack to be successful if a tainted SQL keyword
not contained in a literal or comment is found within a query that
reached a sink vulnerable to SQL injection. Alternatively, an attackisdeemedsuccessfulifasink-reachingquerycontainsa
LIKEclause
with an unescaped tainted wildcard character (i.e., %o r_ )a st h e
system could be vulnerable to a SQL wildcard denial-of-serviceattack[
49].TheattackdetectorforSQLinjectionusesANTLR,a
parser generation tool [ 65] and JSqlParser, a SQL statement parser
thatsupports multiple SQLdialects[ 30],to parseSQLstatements
that reach sink methods vulnerable to SQL injection attacks.Cross-SiteScripting.
TheWorldWideWebConsortium‚Äôs(W3C‚Äôs)
RecommendationforHTML5.2specifiesmechanismswhichcan
trigger the execution of embedded or external scripts: ‚Äúprocessing
of script elements,‚Äù ‚Äúnavigating to javascript: URLs,‚Äù ‚Äúevent han-dlers,‚Äù ‚Äúprocessing of technologies like SVG that have their own
scriptingfeatures‚Äù[ 73].OnlythesyntacticcomponentsofanHTML
document that are capable of activating a script-triggering mecha-
nism are vulnerable to script injections. As such, we determine the
successofanXSSattackbycheckingthesevulnerablecomponents.
Rivulet intercepts and buffers the bytes of HTTP responses
untilafullresponsecanbeparsedfromthebytes.Then,theparsed
documentischeckedforcomponentsthatcouldactivateascript-
triggeringmechanism.Dependingonthemechanismpotentially
activated by the component, a portion of the component is then
classifiedaseitheranembeddedscriptortheaddressofanexter-
nalscript.Thefollowingrulesareusedtoidentifyembeddedand
external scripts in the response: (1) The inner content of every
‚Äúscript‚Äùtagisclassifiedasanembeddedscript.(2)TheHTMLentity
decoded value of every ‚Äúsrc‚Äù attribute specified for a ‚Äúscript‚Äù tagis classified as an external script‚Äôs address. (3) The HTML entitydecoded value of every ‚Äúhref‚Äù attribute specified for a ‚Äúbase‚Äù tag
is classified as an external script‚Äôs address because of its potential
impactonelementsinthedocumentusingrelativeURLs.(4)The
HTMLentitydecodedvalueofeveryeventhandlerattribute, e.g.,
‚Äúonload,‚Äùspecifiedforanytagisclassifiedasanembeddedscript.
(5)TheHTMLentitydecodedvalueofeveryattributelistedashav-
ingaURLvalueinW3C‚ÄôsRecommendationforHTML5.2[ 73],e.g.,
the‚Äúhref‚Äùattribute,isexamined.Ifthedecodedvaluestartswith
‚Äújavascript:‚Äù,thentheportionofthedecodedvalueafter‚Äújavascript:‚Äù
is classified as an embedded script.
Embeddedscriptsarecheckedforvaluessuccessfullyinjected
into non-literal, non-commented portions of the script. To do so,
theportionsofthescriptthatarenotcontainedinJavaScriptstringliterals,templateliterals,orcommentsarecheckedforapredefined
targetstring.Thistargetstringisbasedonthemaliciouspayload
being used in the current test re-execution, e.g.,alertis an appro-
priate target string for the payload <script>alert(1)</script> ,
butotherpayloadsmayhavemorecomplicatedtargetstrings.Ifthe
targetstringisfoundinthenon-literal,non-commentedportions
289of the script and it is tainted, then the attack is deemed successful.
Sincethetargetstringmustbetaintedtobedeemedasuccessful
attack, a vulnerability will be reported only if an attacker could
inject that target string into the application.
Externalscriptaddressesarecheckedforsuccessfullyinjected
URLs that could potentially be controlled by a malicious actor. The
startofeachaddressischeckedforapredefinedtargetURL.The
target URL is based on the malicious payload being used in the
currenttestre-execution.IfthetargetURLisfoundatthestartof
an address and is tainted, then the attack is deemed successful.
TheXSSattackdetectorstoresbyteswrittentoasocketbycallsto
SocketChannel.write() untilafullresponsecanbeparsed(using
Jsoup [29]) from the bytes stored for a particular socket. The rules
described above are then applied to the document model parsedfrom the entity-body. The embedded script checks are also per-
formed using ANTLR [ 65] and a simplified grammar for JavaScript
to identify string literals, template literals, and comments.Command and OGNL Injection.
A command injection attack
is determined to be successful if any tainted value flows into asink vulnerable to command injection (such as
ProcessBuilder.
command() andRuntime.exec() ).Additionally,ifacallismadeto
ProcessBuilder.start() , the detector will deem an attack suc-
cessfulifthe‚Äúcommand‚Äùfieldofthereceiverobjectforthecallis
tainted. This relatively relaxed standard is a product of a lack oflegitimate reasons for allowing untrusted data to flow into thesesinks and the severity of the security risk that doing so presents.
This approach could be fine-tuned to perform more complicated
argumentparsing(similartotheXSSdetector),however,inpractice,
wefounditsufficient,producingnofalsepositivesonourevalua-
tionbenchmarks.WeuseasimilartactictotestforsuccessfulOGNL
injectionattackssincetheOGNLpayloadsgeneratedby Rivulet
are crafted to perform command injection attacks.
4.4 Limitations
Ourapproachisnotintendedtobecomplete;itisonlycapableof
detectingvulnerabilitiesfromsource-sinkflowsthatareexposedby
atestcase.Hence,Rivuletrequiresapplicationstohaveexisting
testcases,althoughwebelievethatthisisafairassumptiontomake,andinourevaluation,showthatRivuletcandetectarealvulnera-bilityevenwhenpresentedwithaverysmalltestsuite(forApache
Struts). This limitation could be mitigated by integrating our ap-
proachwithanautomatictestgenerationtechnique.Vulnerabilities
causedbyanondeterministicflowarehardfor Rivulettodetect,
eveniftheflowoccursduringtheoriginaltestrun,becausetheflow
may fail to occur during the re-execution of the test. Rivulet does
not detect XSS attacks which rely on an open redirection vulnera-
bility[69].Moregenerally,Rivuletcanonlydetectattacksthatwe
have constructed generators and detectors for, but this is primarily
a limitation of Rivulet‚Äôs implementation, and not its approach.
We note thateven static analysistools can only claimsoundness to
the extent that their model holds in the code under analysis: in our
empirical evaluation of a sound static-analysis tool, we found that
the static analyzer missed several vulnerabilities (¬ß5.1).
SincePhosphorisunabletotracktainttagsthroughcodeoutside
oftheJVM,Rivuletisalsounabletodoso.Asaresult,Rivulet
cannotdetectpersistentXSSvulnerabilitiescausedbyavaluestored
in an external database, but it can detect one caused by a valuestored in Java heap memory. We plan to propose extensions to
Phosphor to overcome this limitation, building off of work demon-
strating the feasibility of persisting taint tags in databases in the
Android-based TaintDroid system [ 64]. At present, Rivulet can
only detect vulnerabilities that result from explicit (data) flow, and
notthroughimplicit(control)flows,orside-channelssuchastiming
[53],alimitationsharedbymostothertools,includingJulia[ 59].
ExperimentalsupportforimplicitflowtrackinginPhosphormay
lift this limitation in the future. Despite these limitations, we have
found Rivulet to be effective at detecting injection vulnerabilities.
5 Evaluation
Weperformedanempiricalevaluationof Rivulet,withthegoal
of answering several research questions:
RQ1:How does Rivulet perform in comparison to a state-of-the-
art static analysis tool?
RQ2:Does Rivulet scale to large projects and their test suites?
RQ3:HowsignificantlydoesRivulet‚Äôscontextualpayloadgen-
eration reduce the number of reruns needed?
To answer these questions, we applied both Rivulet and the
state-of-the-art static analysis tool Julia [ 59] to several suites of
vulnerabilitydetectionbenchmarks.Thesecuratedbenchmarksare
intentionallyseededwithvulnerabilities,allowingustocompare
RivuletandJuliaintermsofbothprecisionandrecall.Wewerealso
abletouseoneofthesebenchmarkstocompareRivuletagainst
six commercial vulnerability detection tools. These benchmarksallow us to evaluate the efficacy of Rivulet‚Äôs attack generatorsanddetectors,butsincetheyaremicro-benchmarks,theydonot
provide much insight into how Rivulet performs when applied to
real, developer-provided test suites. To this end, we also applied
Rivulet to three larger applications and their test suites.
WeconductedallofourexperimentsonAmazon‚ÄôsEC2infras-
tructure, using a single ‚Äúc5d.4xlarge‚Äù instance with 16 3.0Ghz Intel
Xeon 8000-series CPUs and 32 of RAM, running Ubuntu 16.04 ‚Äúxe-
nial‚ÄùandOpenJDK1.8.0_222.WeevaluatedJuliabyusingtheJulia-
Cloud web portal, using the most recent version publicly available
asofAugust16,2019.Whenavailable(forJuliet-SQLI,Juliet-XSS
and all of OWASP), we re-use results reported by the Julia au-
thors[59].Whenweexecuteditourselves,weconfirmedourusage
of Julia through personal communication with a representative of
JuliaSoft, and greatly thank them for their assistance.
5.1 RQ1: Evaluating Rivulet on Benchmarks
Inordertoevaluatetheprecisionandrecallof RivuletandJulia,
we turn to third-party vulnerability detection benchmarks, specifi-
cally NIST‚Äôs Juliet Benchmark version 1.3 [ 42], OWASP‚Äôs Bench-
mark version 1.2 [ 48], Livshits‚Äô securibench-micro [ 36], and the
Application Vulnerability Scanner Evaluation Project‚Äôs WAVSEP
version 1.5 [ 11]. Each of these benchmarks contains test cases with
vulnerabilities that are representative of real vulnerabilities found
invariousapplications.Fromthesetests,wecancollectthenumber
of true positives and false negatives reported by each tool. The
benchmarksalsocontaintestcaseswithvariantsofthosevulner-
abilities that are notvulnerable, allowing us to also collect the
number of false positives and true negatives reported by each tool.
Each benchmark consists of a series of web servlets (and in
some cases, also non-servlet applications) that are tests well-suited
290Table1:Comparisonof RivuletandJulia[59]onthird-partybenchmarks. Foreachvulnerabilitytypeineachbenchmarksuitewe
show the total number of test cases (for both true and false alarm tests). For Rivulet and Julia, we report the number of true positives, false
positives, true negatives, false negatives, and analysis time in minutes. Times are aggregate for the whole benchmark suite.
#Test Cases Rivulet Julia
Suite Type True Alarm False Alarm TPFP TN FN Time TPFP TN FN Time
RCE 444 4444440 444 0 4440 444 0
Juliet SQL 2 ,220 2 ,2202,22002 ,220 0 2,22002 ,220 0
XSS 1 ,332 1 ,3321,33201 ,332 025
1,33201 ,332 033
RCE 126 12512601250 126201050
OWASP SQL 272 23227202320 272361960
XSS 246 209246020903
24619190015
Securibench-MicroSQL 3 0300 0 300 0
XSS 86 218502 1 117714 7 91
SQL 132 101320100 1320100WavSepXSS 79 7790702796102
for analysis by a static analyzer like Julia. However, Rivulet re-
quires executable, JUnit-style test cases to perform its analysis.Each servlet is designed to be its own standalone application to
analyze, and they are not stateful. Hence, for each benchmark, we
generatedJUnittestcasesthat requestedeachservletoverHTTP,
passingalongsomedefault,non-maliciousparametersasneeded.
Wherenecessary,wemodifiedbenchmarkstoresolveruntimeer-
rors, mostly related to invalid SQL syntax in the benchmark. We
ignoredseveraltestsfromsecuribench-microthatwerenotatall
suitabletodynamicanalysis(somehadinfiniteloops,whichwould
notresultinapagebeingreturnedtotheuser),andotherwisein-
cluded only tests for the vulnerabilities targeted by Rivulet (RCE,
SQLI and XSS). Most of these benchmarks have only been ana-
lyzed by static tools, and not executed, and hence, such issues may
nothavebeennoticedbypriorresearchers.Fortransparencyand
reproducibility,allbenchmarkcodeisincludedinthispaper‚Äôsac-
companying artifact [24].
Table1presentsourfindingsfromapplyingbothRivuletand
Julia to these benchmarks. Rivulet had near perfect recall and
precision,identifyingeverytruealarmtestcaseasatruepositive
but one, and every false alarm test case as a true negative. In three
interesting Securibench-Micro test cases, the test case was non-
deterministicallyvulnerable:withsomerandomprobabilitythetestcouldbevulnerableornot.Intwoofthesecases,Rivuleteventually
detected the vulnerability after repeated trials (the vulnerability
was exposed with a 50% probability and was revealed after just
several repeated trials). Ho wever, in the case that we report a false
negative (simplified andpresented in Listing 2),the probability of
anyattacksucceedingonthetestwasjust1 /232,andRivuletcould
not detect the vulnerability within a reasonable time bound. We
note that this particularly difficult case does not likely represent a
significant security flaw, since just like Rivulet, an attacker cannot control the probability that their attack would succeed. This
testcase likelyrepresentsthe worst-casepathologicalapplication
that Rivulet could encounter.
In comparison, Julia demonstrated both false positives and false
negatives. Many of the false positives were due to Julia‚Äôs lack ofsensitivityformultipleelementsinacollection,resultinginover-
taintingallelementsinacollection.WeconfirmedwithJuliaSoft
that the tool‚Äôs false negatives were not bugs, and instead generally
duetolimitationsinrecoveringexactdynamictargetsofmethod
callswhenthereceiverofamethodcallwasretrievedfromtheheap,
causing it to (incorrectly) assume a method call to not be a sink.
Listing 3 shows an example of one such case, where Julia reports a
vulnerabilityonLine3butnotonLine6sinceitisunabletopre-
ciselydeterminethedynamic targetofthesecond println.Unlike
theverytrickynon-deterministiccasethatRivuletstruggledto
detect,wenotethatthisformofdataflowisnotuncommon,and
thislimitationmaysignificantlyimpactJulia‚ÄôsabilitytodetectXSS
vulnerabilities in applications that pass the servlet‚Äôs PrintWriter
between various application methods.
We also collected execution times to analyze each entire bench-
mark for both tools. For Rivulet, we report the total time needed
toexecuteeachbenchmark(includinganynecessarysetup,such
as starting a MySQL server), and for Julia, we report the execution
time from the cloud service. Despite its need to execute thousands
of JUnit tests, Rivulet ran as fast or faster than Julia in all cases.
voiddoGet(HttpServletRequest req, H ttpServletResponse
resp) {
Random r = newRandom() ;
if(r.nextInt() == 3)
resp.getWriter() . println(req.getPara meter( "name"));
}
Listing 2: Simplified code of the vulnerability Rivuletmisses.r.nextInt() returns one of the 2
32integers randomly.
1private PrintWriter writer;
2voiddoGet(HttpServletRequest re q, HttpServletResponse
resp) {
3resp.getWriter() .pri ntln(req.ge tParameter( "dummy" ));
4//XSS reported on line above
5this.writer = resp.getWriter();
6this.writer.println(req.ge tParameter( "other" ));
7//No XSS reported on line above
8}
Listing 3: Example of a false negative reported by Julia
291Table2:ComparisonbetweenRivuletanddifferentvulner-
ability detection tools on the OWASP benchmark. For each
vulnerabilitytype,wereportthetruepositiverateandfalsepositive
rate for the tool. Each SAST-0*tool is one of: Checkmarx CxSAST,
Coverity Code Advisor, HP Fortify, IBM AppScan, Parasoft Jtest,
and Veracode SAST.
RCE SQL XSS
Tool TPR FPR TPR FPR TPR FPR
SAST-01 35%18%37%13%34%25%
SAST-02 67%42%94%62%67%42%
SAST-03 59%35%82%47%49%22%
SAST-04 72%42%83%51%66%40%
SAST-05 62%57%77%62%41%25%
SAST-06 100%100%100%90%85%45%
Rivulet 100% 0%100% 0%100% 0%
Most of Rivulet‚Äôs time on these benchmarks was spent on the
false positive tests, which act as a ‚Äúworst case scenario‚Äù for its exe-
cutiontime:if Rivuletcanconfirmaflowisvulnerablebasedona
singleattackpayload,then itneednottryotherre-runconfigura-
tionsforthatflow.However,onthefalsepositivecases,Rivulet
must try every possible payload (in the case of XSS, this is up to
7, although it may also try different encoding strategies for each
payload, depending on the source).
Unfortunately, it is not possible to report a direct comparison
between Rivulet and anycommercial tools(except for Julia)due
tolicensingrestrictions.However,the OW ASPbenchmarkisdis-
tributed with anonymized results from applying six proprietary
tools(CheckmarxCxSAST,CoverityCodeAdvisor,HPFortify,IBM
AppScan,ParasoftJtest,andVeracodeSAST)tothebenchmark,and
we report these results in comparison to Rivulet. Table 2 presents
theseresults(eachcommercialtoolisanonymized),showingthe
true positive rate and false positive rate for each tool. Rivulet
outperforms each of these commercial static analysis tools in both
true positive and false positive detection rates.
5.2 RQ2: Rivulet on Large Applications
Whilethebenchmarksevaluatedin¬ß5.1areusefulforevaluating
the potential to detect vulnerabilities, they are limited in that they
are micro-benchmarks. They help us make general claims about
how Rivulet might perform when applied to an arbitrary applica-
tion.However,sinceeachmicro-benchmarkisdesignedtobeeasily
executed (and indeed, we automatically generated tests to execute
them),itisnotpossibletojudgehowRivuletperformswhenusing
existing,developer-written, test cases on real applications.
ToprovidemoredetailedresultsonhowRivuletperformson
larger,realapplications,weappliedittothreedifferentopen-source
Java web applications and their existing JUnit test suites. iTrust
is an electronic health record system iteratively developed over25 semesters by students at North Carolina State University [
22,
26]. We evaluated iTrust version 1.23, the most recent version of
iTrust1 ‚Äî a newer ‚ÄúiTrust2‚Äù is under development, but has far less
functionalitythaniTrust1[ 22].ApriorversionofiTrustwasalso
usedintheevaluationofMohammadi etal.‚ÄôsXSSattacktestingtool,
althoughtheauthorswereunabletoprovideadetailedlistofthe
vulnerabilitiesthattheydetectedorthespecificversionofiTrustused [40]. We also assessed a recent revision, 8349cebb ,o fJenkins,
a popular open-source continuous integration server [ 28], using
itstestsuite. Strutsisanopen-sourcewebapplicationframework
library which is used to build enterprise software [ 3]. Struts is
distributed with sample applications that use the framework, as
wellasJUnittestsforthoseapplications.WeevaluatedRivuletwith
onesuchsampleapplication(rest-showcase ),usingStrutsversion
2.3.20_1, which is known to have a serious RCE vulnerability.
Table3presentstheresultsofthisexperiment,showingforeach
projectthenumberoftests,andthenforeachinjectioncategorythenumberofvulnerableflows,rerunsexecuted,rerunsthatsucceededin finding a vulnerability, and the number of unique vulnerabilities
found. Rivulet reported no false positives. We briefly discuss the
vulnerabilities that Rivulet detected in each application below.
IniTrust,RivuletdetectedfivepageswithXSSvulnerabilities,
where a user‚Äôs submitted form values were reflected back in the
page. While these values were in only five pages, each page had
multiple form inputs that were vulnerable, and hence, Rivulet re-
portedatotalof289differentrerunconfigurationsthatdemonstrate
these true vulnerabilities. There were no flows into SQL queries in
iTrust: while iTrust uses a MySQL database, it exclusively accesses
it through correct use of the preparedStatement API, which is
designed to properly escape all parameters. We reported all five
vulnerabilities to the iTrustdevelopers and submitted a patch.
WealsosubmittediTrusttotheJuliacloudplatformforanalysis,
which produced 278 XSS injection warnings. We did not have ade-
quateresourcestoconfirmhowmanyofthesewarningsarefalse
positives, but did check to ensure that Julia included all of the XSS
vulnerabilitiesthatRivuletreported.Wedescribeoneexamplethat
weclosely investigatedand foundto bea falsepositive reportedby
Julia.Thevulnerabilityconsistsofapagewithaformthatallows
the user to filter a list of hospital rooms and their occupants byfiltering on three criteria. After submitting the form, the criteria
submittedbytheuserareechoedbackonthepagewithoutpassing
throughanystandardsanitizer,henceJuliaraisesanalert.While
Rivuletdidnotalertthattherewasavulnerabilityonthispage,
itdidobservethesamepotentiallyvulnerabledataflow,andgen-
eratedandexecutedrerunconfigurationstotestit(notfindingit
to be vulnerable). We carefully inspected this code to confirm that
Rivulet‚Äôs assessment of these flows was correct, and found that
the filtercriteria would only bedisplayed onthe pageif therewere
any rooms that matched those criteria. The only circumstancesthat an exploit could succeed here would be if an administratorhad defined a hospital or ward named with a malicious string ‚Äî
inthatcase,thatsamemaliciousstringcouldbeusedinthefilter.
While perhaps not a best practice, this does not represent a serious
risk‚Äî anuntrustworthy administratorcould easilydo evenmore
nefarious actions than create the scenario to enable this exploit.
InJenkins, Rivulet detected a single XSS vulnerability, but
that vulnerability was exposed by multiple test cases, and hence,Rivulet created 9 distinct valid test rerun configurations thatdemonstrated the vulnerability. We contacted the developers of
Jenkins who confirmed the vulnerability, assignedit the identifier
CVE-2019-10406,andpatchedit.Jenkinsdoesnotuseadatabase,
and hence, had no SQL-related flows. We did not observe flows
fromuser-controlledinputstocommandexecutionAPIs.Jenkins‚Äô
292Table3:ResultsofexecutingRivuletonopen-sourceapplications. ForeachapplicationweshowthenumberoflinesofJavacode(as
measuredby cloc[14])thenumberoftestmethods,andthetimeittakestorunthosetestswithandwithoutRivulet.Foreachvulnerability
type,weshowthenumberofpotentiallyvulnerableflowsdetectedbyRivulet( Flows),thenaivenumberofrerunsthatwouldbeperformed
withoutRivulet‚Äôscontextualpayloadgenerators( Reruns n),theactualnumberofreruns( Reruns),thenumberofrerunssucceedingin
exposing a vulnerability (Crit), and the number of unique vulnerabilities discovered (Vuln). There were no SQL-related flows.
Time(Minutes) RCE XSS
Application LOC Tests Baseline Rivulet Flows Reruns nReruns Crit Vuln Flows Reruns nReruns Crit Vuln
iTrust 80,002 1 ,253 6239 0 00 0 0 124117,778 5 ,424 289 5
Jenkins 185,8529,330 851,140 0 0000534294,48913,56291
StrutsRest-Showcase 152 ,582 15 0.3 5532,609 2 ,609 4 1 96,254 228 0 0
slowerperformancewascausedprimarilybyitstestexecutioncon-
figuration,whichcallsforeverysingleJUnittestclasstoexecutein
itsownJVM,withitsownTomcatserverrunningJenkins.Hence,
for each test, a web server must be started, and Jenkins must be
deployedonthatserver.Thisprocessisgreatlyslowedbyload-time
dynamic bytecode instrumentation performed by Rivulet‚Äôs under-
lying taint tracking engine (Phosphor), and could be reduced by
hand-tuning Phosphor for this project.
InStruts,Rivuletdetectedacommandinjectionvulnerability,
CVE-2017-5638,thesameusedintheEquifaxattack(thisvulner-
abilitywasknowntoexistinthisrevision).Again,multipletests
exposedthevulnerability,andhenceRivuletgeneratedmultiple
rerunconfigurationsthatdemonstratethevulnerabilities.Inthis
revision of struts, a request with an invalid HTTP Content-Type
header cantrigger remote codeexecution, since thatheader flows
into the OGNL expression evaluation engine (CVE-2017-5638), and
Rivuletdemonstratesthisvulnerabilitybymodifyingheadersto
includeOGNLattackpayloads.Thestrutsapplicationdoesn‚Äôtusea
database, and hence, had no SQL-related flows.
The runtime for Rivulet varied from 5 minutes to about 19
hours. It is not unusual for automated testing tools (i.e., fuzzers)
to run for a full day, or even several weeks [ 34], and hence, we
believethateveninthecaseof Jenkins, Rivulet‚Äôsperformanceis
acceptable. Moreover, Rivulet‚Äôs test reruns could occur in parallel,
dramatically reducing the wall-clock time needed to execute it.
5.3 RQ3: Reduction in Reruns
ThisresearchquestionevaluatesRivulet‚Äôsreductioninthenum-
ber of reruns needed to test whether a given source-sink flow is
vulnerabletoanattackcomparedtoanaiveapproach.Todoso,we
considered the number of payloads that a more naive attack gener-
atorsuchasArdilla[ 32]orNavex[ 2]mightcreateforeachclassof
vulnerability,andthenestimatethenumberofrerunsneeded.To
estimate the number of payloads used for XSS testing, we referred
to the OWASP XSS testing cheat sheet, which has 152 distinct pay-
loads [50]. We assume that for RCE testing, the naive generator
would generate the same 12 payloads that Rivulet uses (Rivulet
does not use context in these payloads). We assume that the naive
generator will also consider multiple encoding schemes for each
payload(asRivuletdoes).Hence,toestimatethenumberofreruns
created by this naive generator, we divide the number of rerunsactually executed by the total number of payloads that Rivulet
couldcreate,andthenmultiplythisbythenumberofpayloadsthat
the naive generator would create (e.g., Reruns/7‚àó152 for XSS).Table 3 shows the number of reruns generated by this naive
generator as Reruns n. As expected, Rivulet generates far fewer
reruns, particularly with its XSS generator, where it generated 22 x
fewer reruns for Jenkins than the naive generator would have. Fur-
thermore,giventhatRivulettook19hourstocompleteonJenkins,
prior approaches that do not use Rivulet‚Äôs in situ rerun genera-
tionwouldbeinfeasiblefortheproject.Hence,weconcludethat
Rivulet‚Äôs context-sensitive payload generators are quite effective
at reducing the number of inputs needed to test if a source-sink
flow is vulnerable to attack.
5.4 Threats to Validity
Perhapsthegreatestthreattothevalidityofourexperimentalre-
sults comes from our selection of evaluation subjects. Researchers
and practitioners alike have long struggled to establish a repro-
duciblebenchmarkforsecurityvulnerabilitiesthatisrepresentative
of real-world flaws to enable a fair comparison of different tools[
34]. Thankfully, in the context of injection vulnerabilities, there
areseveralwell-regardedbenchmarks.Tofurtherreducethethreat
of benchmark selection, we used four such benchmarks (Juliet,
OWASP,Securibench-MicroandWavSep).Nonetheless,itispos-
sible that these benchmarks are not truly representative of real
defects ‚Äî perhaps we overfit to the benchmarks. However, we are
furtherencouraged because thesebenchmarksincludetest cases
thatexposetheknownlimitationsofbothRivuletandJulia:for
Rivulet,thebenchmarksuite containsvulnerabilitiesthatareex-
posedonlynon-deterministically,andforJulia,thebenchmarksuite
containsteststhatarenegativelyimpactedbytheimprecisionof
the static analysis. To aid reproducibility of our results, we have
made Rivulet (and scripts to run the benchmarks) available under
the MIT open source license [24, 25].
To demonstrate Rivulet‚Äôs ability to find vulnerabilities using
developer-written tests, we were unable to find any appropriate
benchmarks, and instead evaluate Rivulet on several open-source
projects. It is possible that these projects are not representativeof the wider population of web-based Java applications or their
tests.However,theprojectsthatweselecteddemonstrateawide
range of testing practices: Jenkins topping in with 9 ,330 tests, and
Struts with only 15, showing that Rivulet can successfully find
vulnerabilities even in projects with very few tests. We are quite
interestedinfindingindustrialcollaboratorssothatwecanapply
Rivulet to proprietary applications as well, however, we do not
have any such collaborators at this time.
2936 Related Work
Dynamictainttrackinghasbeenproposedasaruntimeapproach
to detect code injection attacks in production applications, as a
sort of last line of defense [ 8,21,38,54,58,63]. However, these
approachesaregenerallynotadoptedduetoprohibitiveruntime
overhead: even the most performant can impose a slowdown ofat least 10‚Äì20% and often far more [
8,12,15,31]. Although prior
work has used the term test amplification to refer to techniques
that automatically inject exceptions or system callbacks in existing
tests [1,75,76], we believe that Rivulet is the first to use dynamic
taint tracking to amplify test cases.
Avarietyofautomatedtestingtoolshavebeenproposedtode-
tect injection vulnerabilities before software is deployed. Thesetools differ from black-box testing tools in that they assume thatthe tester has access to the application server, allowing the toolto gather more precise feedback about the success of any givenattack. Kie≈ºun et al.‚Äôs Ardilla detects SQL injection and XSS vul-
nerabilities in PHP-based web applications through a white-box
testingapproach[ 32].Ardillausessymbolicexecutiontoexplore
different application states, then for each state, uses dynamic taint
tracking toidentify whichuser-controlled inputs flowto sensitive
sinks,generatingattackpayloadsforthoseinputsfromadictionaryof over 100 attack strings. Similar to Ardilla, Alhuzali et al.‚ÄôsNavex
automaticallydetectsinjectionvulnerabilitiesinPHPcodeusing
concolic execution to generate sequences of HTTP requests that
reach vulnerable sinks [ 2]. Rivulet improves on these approaches
byleveragingthecontextofthecompletevalueflowingintoeach
vulnerablesink,allowingittofocusitspayloadgenerationtoex-
cludeinfeasibleattackstrings.Thenaivererungeneratorthatwe
used as a comparison in our experiments roughly represents the
numberofattackstringsthatArdillawouldhavetested,showing
that Rivulet provides a significant reduction inputs tested. Unlike
thesesystems‚Äôautomatedinputgenerators,Rivuletusesdeveloper-
provided functional tests to perform its initial exploration of theapplication‚Äôs behavior, a technique that we found to work quite
well. If a more robust concolic execution tool were available for
Java, it would be quite interesting to apply a similar approach to
Rivulet,whichcouldreduceourrelianceondeveloper-provided
test cases to discover application behavior.
Othertoolstreattheapplicationundertestasablack-box,testing
forvulnerabilitiesbygeneratinginputsandobservingcommandsastheyaresenttoSQLservers,orHTMLasitisreturnedtobrowsers.Mohammadi etal.usedagrammar-basedapproachtogenerateover
200 XSS attack strings, however, our context-sensitive approach
considers the location of taint tags within the resulting document,
allowingRivulettoselectfarfewerpayloadsfortesting[ 40].Simos
et al.combined a grammar-based approach for generating SQL in-
jectionattackstringswithacombinatorialtestingmethodologyfortestingapplicationsforSQLinjectionvulnerabilities[
57].Thom√© et
al.‚ÄôsevolutionaryfuzzergeneratesinputstotriggerSQLinjection
vulnerabilities using a web crawler [ 70]. Others have considered
mutation-based approaches to detect SQL injection [ 6] and XML
injectionvulnerabilities[ 27].Incontrast,Rivuletusesdataflow
information to target only inputs that flow to vulnerable sinks.
While our work considers injection vulnerabilities that are trig-
gered throughcode that runson aweb server, otherwork focusesoninjectionvulnerabilitiesthatexistentirelyincodethatrunsin
clientbrowsers.Lekies etal.deployedatainttrackingengineinside
ofawebbrowser,tracedwhichdatasourcescouldflowintovulner-ablesinks,andthengeneratedXSSattacksbasedontheHTMLand
JavaScriptcontextsurroundingeachvalueatthesink[
35].Rivulet
also uses taint tracking to generate attack payloads, expanding
this approach to generate SQL and RCE injection attacks, and uses
existing test cases to expose non-trivial application behavior.
Avarietyofstatictaintanalysisapproacheshavealsobeenused
to detect injection vulnerabilities [ 7,59,60,71]. The most recent
and relevant is Julia, which uses an interprocedural, flow-sensitive
and context-sensitivestatic analysis to detectinjection vulnerabil-
ities [59]. Compared to a dynamic approach like Rivulet, static
approaches have the advantage of not needing to execute the code
underanalysis.However,inthepresenceofreflection,deepclass
hierarchies,anddynamiccodegeneration(allofwhichareoftenpresentinlargeJavawebapplications),statictoolstendtostrug-gle to balance between false positives and false negatives. In our
benchmark evaluation, we found that Rivulet outperformed Julia.
While Rivulet uses specialized input generation and attack de-
tectiontofindcodeinjectionvulnerabilities,avarietyoffuzzersuse
tainttrackingtoinsteadfindprogramcrashes.Forinstance,Buzz-
Fuzzusestainttrackingtotargetinputbytesthatflowtoasinkandreplace those bytes with large, small, and zero-valued integers [
17].
VUzzer takes a similar approach, but records values that inputs are
compared to in branches and uses those same values as inputs (e.g.,ifitsees
if(taintedData[49] == 105)... itwouldtryvalue105
intaintedData byte49)[ 52].Similarly,TaintScope usesfuzzingto
detect cases where fuzzed inputs flow through checksum-like rou-
tines and uses a symbolic representation of these checksum bytes
when generating new inputs in order to pass input validation [ 72].
Rivulet‚Äôs key novelties over existing taint-based fuzzers are itscontext-sensitive input generation whichenables the creation ofcomplex, relevant attacks and its attack detectors which report
injection vulnerabilities rather than just program crashes.
7 Conclusion
Despite many efforts to reduce their incidence in practice, code
injectionattacksremaincommon,andarerankedas#1onOWASP‚Äôs
most recent list of critical web application vulnerabilities [ 46]. We
havepresentedanewapproachtoautomaticallydetectthesevul-
nerabilitiesbeforesoftwareisreleased,byamplifyingexistingap-
plication tests with dynamic taint tracking. Rivulet applies novel,
context-sensitive,inputgeneratorstoefficientlyandeffectivelytestapplicationsforinjectionvulnerabilities.Onfourbenchmarksuites,Rivulet had near perfect precision and recall, detecting every true
vulnerability (except for one pathological case) and raising no false
alarms. Using developer-provided integration tests, Rivulet found
sixnewvulnerabilitiesandconfirmedoneoldvulnerabilityinthreelargeopen-sourceapplications.Rivuletispubliclyavailableunder
theMITlicense[ 25],andanartifactcontainingRIVULETandthe
experiments described in this paper is also publicly available [ 24].
Acknowledgements
WewouldliketothankPietroFerraraforhisassistancerunning
and interpreting the Juliaexperiments. Jonathan Bell‚Äôs group is
funded in part by NSF CCF-1763822, NSF CNS-1844880, and the
NSA under contract number H98230-18-D-008.
294References
[1]Christoffer Quist Adamsen, Gianluca Mezzetti, and Anders M√∏ller. 2015. System-
aticExecutionofAndroidTestSuitesinAdverseConditions.In Proceedingsof
the2015 InternationalSymposium onSoftware Testingand Analysis (ISSTA2015).
ACM, New York, NY, USA, 83‚Äì93. https://doi.org/10.1145/2771783.2771786
[2]AbeerAlhuzali,RigelGjomemo,BirhanuEshete,andV.N.Venkatakrishnan.2018.
NAVEX: Precise and Scalable Exploit Generation for Dynamic Web Applications.
InProceedings of the 27th USENIX Conference on Security Symposium (SEC‚Äô18).
USENIX Association, Berkeley, CA, USA, 377‚Äì392. http://dl.acm.org/citation.
cfm?id=3277203.3277232
[3] Apache Foundation. 2019. Apache Struts. https://struts.apache.org.
[4]ApacheFoundation.2019. ApacheStrutsReleaseHistory. https://struts.apache.
org/releases.html.
[5] Apache Foundation. 2019. Apache Tomcat. https://tomcat.apache.org.[6]
Dennis Appelt, Cu Duy Nguyen, Lionel C. Briand, and Nadia Alshahwan.
2014. Automated Testing for SQL Injection Vulnerabilities: An Input Muta-tion Approach. In Proceedings of the 2014 International Symposium on Soft-
ware Testing and Analysis (ISSTA 2014). ACM, New York, NY, USA, 259‚Äì269.
https://doi.org/10.1145/2610384.2610403
[7]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware
Taint Analysis for Android Apps. In 35th ACM SIGPLAN Conference on Program-
ming Language Design and Implementation (PLDI ‚Äô14). ACM, New York, NY, USA,
259‚Äì269. https://doi.org/10.1145/2594291.2594299
[8]Jonathan Bell and Gail Kaiser. 2014. Phosphor: Illuminating Dynamic Data
FlowinCommodityJVMs.In ACMInternationalConferenceonObjectOriented
Programming Systems Languages & Applications (OOPSLA ‚Äô14). ACM, New York,
NY, USA, 83‚Äì101. https://doi.org/10.1145/2660193.2660212
[9]AlBessey,KenBlock,BenChelf,AndyChou,BryanFulton,SethHallem,CharlesHenri-Gros,AsyaKamsky,ScottMcPeak,andDawsonEngler.2010. Afewbillion
lines of code later: using static analysis to find bugs in the real world. Commun.
ACM53 (February 2010), 66‚Äì75. Issue 2.
[10]Steve Bousquet. 2016. Criminal charges filed in hacking of Florida elections web-
sites. http://www.miamiherald.com/news/politics-government/article75670177.
html.
[11]ShayChen.2014. TheWebApplicationVulnerabilityScannerEvaluationProject.
https://code.google.com/archive/p/wavsep/.
[12]Winnie Cheng, Qin Zhao, Bei Yu, and Scott Hiroshige. 2006. TaintTrace: Effi-cient Flow Tracing with Dynamic Binary Rewriting. In 11th IEEE Symposium
on Computers and Communications (ISCC ‚Äô06). IEEE, Washington, DC, USA, 6.
https://doi.org/10.1109/ISCC.2006.158
[13]Erika Chin and David Wagner. 2009. Efficient Character-level Taint Tracking for
Java. InProceedings of the 2009 ACM Workshop on Secure Web Services (SWS ‚Äô09).
ACM, New York, NY, USA, 3‚Äì12. https://doi.org/10.1145/1655121.1655125
[14] Al Daniel. 2019. cloc: Count Lines of Code. https://github.com/AlDanial/cloc.
[15]William Enck, Peter Gilbert, Byung-Gon Chun, Landon P. Cox, Jaeyeon Jung,
PatrickMcDaniel,and AnmolN.Sheth.2010. TaintDroid:AnInformation-flow
TrackingSystemforRealtimePrivacyMonitoringonSmartphones.In OSDI‚Äô10.
USENIXAssociation,Berkeley,CA,USA,6. http://dl.acm.org/citation.cfm?id=
1924943.1924971
[16]Exploit Database. 2019. Offensive Security‚Äôs Exploit Database Archive. https:
//www.exploit-db.com.
[17]VijayGanesh,TimLeek,andMartinRinard.2009.Taint-BasedDirectedWhitebox
Fuzzing.In Proceedingsofthe31stInternationalConferenceonSoftwareEngineering
(ICSE ‚Äô09). IEEE Computer Society, USA, 474‚Äì484. https://doi.org/10.1109/ICSE.
2009.5070546
[18]Jeff Goldman. 2016. Researchers Find Russian Hacker Selling Access to U.S.Election Assistance Commission. https://www.esecurityplanet.com/hackers/researchers-find-russian-hacker-selling-access-to-u.s.-election-assistance-
commission.html.
[19]Google. 2019. Error-Prone: Catch Common Java Mistakes as Compile-Time
Errors. https://github.com/google/error-prone.
[20]Vivek Haldar, Deepak Chandra, and Michael Franz. 2005. Dynamic Taint Propa-
gation for Java. In Proceedings of the 21st Annual Computer Security Applications
Conference (ACSAC‚Äô05).IEEEComputerSociety,Washington,DC,USA,303‚Äì311.
https://doi.org/10.1109/CSAC.2005.21
[21]WilliamG.J.Halfond,AlessandroOrso,andPanagiotisManolios.2006. Using
PositiveTaintingandSyntax-awareEvaluationtoCounterSQLInjectionAttacks.
InSIGSOFT‚Äô06/FSE-14.ACM,NewYork,NY, USA,175‚Äì185. https://doi.org/10.
1145/1181775.1181797
[22]SarahHeckman,KathrynT.Stolee,andChristopherParnin.2018. 10+Yearsof
Teaching Software Engineering with Itrust: The Good, the Bad, and the Ugly. In
Proceedingsofthe40thInternationalConferenceonSoftwareEngineering:Software
EngineeringEducationandTraining (ICSE-SEET‚Äô18).ACM,NewYork,NY,USA,
1‚Äì4. https://doi.org/10.1145/3183377.3183393[23]Matthias H√∂schele and Andreas Zeller. 2017. Mining input grammars with
AUTOGRAM. In Proceedings of the 39th International Conference on Software
Engineering, ICSE 2017, Buenos Aires, Argentina, May 20-28, 2017 - Companion
Volume. 31‚Äì34. https://doi.org/10.1109/ICSE-C.2017.14
[24]Katherine Hough, Gebrehiwet Welearegai, Christian Hammer, and Jonathan Bell.
2020. Revealing Injection Vulnerabilities by Leveraging Existing Tests (Artifact).
(2020). https://doi.org/10.6084/m9.figshare.11592033
[25]Katherine Hough, Gebrehiwet Welearegai, Christian Hammer, and Jonathan Bell.
2020. Revealing Injection Vulnerabilities by Leveraging Existing Tests (GitHub).
https://github.com/gmu-swe/rivulet.
[26] iTrust Team. 2019. iTrust - GitHub. https://github.com/ncsu-csc326/iTrust.
[27]Sadeeq Jan, Cu D. Nguyen, and Lionel C. Briand. 2016. Automated and Effective
Testing of Web Services for XML Injection Attacks. In Proceedings of the 25th
International Symposium on Software Testing and Analysis (ISSTA 2016). ACM,
New York, NY, USA, 12‚Äì23. https://doi.org/10.1145/2931037.2931042
[28] Jenkins Project Developers. 2019. Jenkins. https://jenkins.io.[29] Jonathan Hedley. 2019. jsoup: Java HTML Parser. https://jsoup.org/.[30] JSqlParserProjectAuthors.2019. JSqlParser. http://jsqlparser.sourceforge.net/.[31]
Vasileios P. Kemerlis, Georgios Portokalidis, Kangkook Jee, and Angelos D.
Keromytis. 2012. Libdft: Practical Dynamic Data Flow Tracking for Commodity
Systems. In 8th ACM SIGPLAN/SIGOPS Conference on Virtual Execution Environ-
ments (VEE‚Äô12).ACM,NewYork,NY,USA,121‚Äì132. https://doi.org/10.1145/
2151024.2151042
[32]Adam Kie≈ºun, Philip J. Guo, Karthick Jayaraman, and Michael D. Ernst. 2009.
Automatic creation of SQL injection and cross-site scripting attacks. In ICSE
2009, Proceedings of the 31st International Conference on Software Engineering.
Vancouver, BC, Canada, 199‚Äì209.
[33]Tracy Kitten. 2013. Card Fraud Scheme: The Breached Victims. http://www.
bankinfosecurity.com/card-fraud-scheme-breached-victims-a-5941.
[34]George T. Klees, Andrew Ruef, Benjamin Cooper, Shiyi Wei, and Michael Hicks.
2018. EvaluatingFuzzTesting.In ProceedingsoftheACMConferenceonComputer
and Communications Security (CCS).
[35]Sebastian Lekies, Ben Stock, and Martin Johns. 2013. 25 Million Flows Later:
Large-scaleDetectionofDOM-basedXSS.In Proceedingsofthe2013ACMSIGSAC
ConferenceonComputer&#38;CommunicationsSecurity (CCS‚Äô13).ACM,New
York, NY, USA, 1193‚Äì1204. https://doi.org/10.1145/2508859.2516703
[36]Ben Livshits. 2005. Defining a Set of Common Benchmarks for Web Application
Security.In ProceedingsoftheWorkshoponDefiningtheStateoftheArtinSoftware
Security Tools.
[37]BenjaminLivshitsandStephenChong.2013. TowardsFullyAutomaticPlacement
ofSecuritySanitizersandDeclassifiers.In Proceedingsofthe40thAnnualACM
SIGPLAN-SIGACTSymposiumonPrinciplesofProgrammingLanguages(POPL‚Äô13).
ACM, New York, NY, USA, 385‚Äì398. https://doi.org/10.1145/2429069.2429115
[38]WesMasriandAndyPodgurski.2005. UsingDynamicInformationFlowAnalysis
toDetectAttacksAgainstApplications.In Proceedingsofthe2005Workshopon
SoftwareEngineeringforSecureSystems&Mdash;BuildingTrustworthyApplications
(SESS ‚Äô05). ACM, New York, NY, USA, 1‚Äì7. https://doi.org/10.1145/1082983.
1083216
[39]Rick Miller. 2016. "Foreign" hack attack on state voter registration
site. http://capitolfax.com/2016/07/21/foreign-hack-attack-on-state-voter-
registration-site/.
[40]M. Mohammadi, B. Chu, and H. R. Lipford. 2017. Detecting Cross-Site Script-ing Vulnerabilities through Automated Unit Testing. In 2017 IEEE Interna-
tional Conference on Software Quality, Reliability and Security (QRS). 364‚Äì373.
https://doi.org/10.1109/QRS.2017.46
[41]Lou Montulli and David M. Kristol. 2000. HTTP State Management Mechanism.
RFC 2965. https://doi.org/10.17487/RFC2965
[42]NationalInstituteofStandardsandTechnology.2017. JulietTestSuiteforJava.
https://samate.nist.gov/SRD/testsuite.php.
[43]NationalVulnerabilityDatabase.2017. CVE-2017-5638Detail. https://nvd.nist.
gov/vuln/detail/CVE-2017-5638.
[44]NationalVulnerabilityDatabase.2019. NationalVulnerabilityDatabasesearch
for ‚Äúexecute arbitrary commands‚Äù. https://nvd.nist.gov/vuln/search/results?form_type=Advanced&results_type=overview&query=execute+arbitrary+
commands&search_type=all.
[45]University of Maryland. 2019. FindBugs - Find Bugs in Java Programs. http:
//findbugs.sourceforge.net.
[46]Open Web Application Security Project. 2017. OWASP Top 10 - 2017 The TenMost Critical Web Application Security Risks. https://www.owasp.org/index.
php/Top_10-2017_Top_10.
[47]OpenWebApplicationSecurityProject.2019. ExpressionLanguageInjection.
https://www.owasp.org/index.php/Expression_Language_Injection.
[48]Open Web Application Security Project. 2019. OWASP Benchmark Project.
https://www.owasp.org/index.php/Benchmark.
[49]Open Web Application Security Project. 2019. Testing for SQL Wildcard At-
tacks(OWASP-DS-001). https://www.owasp.org/index.php/Testing_for_SQL_
Wildcard_Attacks_(OWASP-DS-001).
295[50]OpenWebApplicationSecurityProject.2019. XSSFilterEvasionCheatSheet.
https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet.
[51] OW2 Consortium. 2019. ASM. https://asm.ow2.io/.
[52]SanjayRawat,VivekJain,AshishKumar,LucianCojocar,CristianoGiuffrida,and
HerbertBos.2017. VUzzer:Application-awareEvolutionaryFuzzing.In NDSS.
https://www.vusec.net/download/?t=papers/vuzzer_ndss17.pdf
[53]A. Sabelfeld and A. C. Myers. 2006. Language-based Information-flow Security.
IEEE J.Sel. A. Commun. 21, 1 (Sept. 2006), 5‚Äì19. https://doi.org/10.1109/JSAC.
2002.806121
[54]Tejas Saoji, Thomas H. Austin, and Cormac Flanagan. 2017. Using Precise Taint
Tracking for Auto-sanitization. In Proceedings of the 2017 Workshop on Program-
ming Languages and Analysis for Security (PLAS ‚Äô17). ACM, New York, NY, USA,
15‚Äì24. https://doi.org/10.1145/3139337.3139341
[55]MatthewSchwartz.2019. Equifax‚ÄôsDataBreachCostsHit$1.4Billion. https://
www.bankinfosecurity.com/equifaxs-data-breach-costs-hit-14-billion-a-12473.
[56]AshwinSeshagiri.2015. HowHackersMade$1MillionbyStealingOneNews
Release. https://www.nytimes.com/2015/08/12/business/dealbook/how-hackers-
made-1-million-by-stealing-one-news-release.html?_r=0.
[57]Dimitris E. Simos, Jovan Zivanovic, and Manuel Leithner. 2019. Automated
Combinatorial Testing for Detecting SQL Vulnerabilities in Web Applications.
InProceedings of the 14th International Workshop on Automation of Software Test
(AST ‚Äô19). IEEE Press, Piscataway, NJ, USA, 55‚Äì61. https://doi.org/10.1109/AST.
2019.00014
[58]SooelSon,KathrynS.McKinley,andVitalyShmatikov.2013. Diglossia:detecting
code injection attacks with precision and efficiency. In CCS ‚Äô13. ACM, New York,
NY, USA, 12. https://doi.org/10.1145/2508859.2516696
[59]Fausto Spoto, Elisa Burato, Michael D. Ernst, Pietro Ferrara, Alberto Lovato,
DamianoMacedonio,andCiprianSpiridon.2019. StaticIdentificationofInjection
Attacks in Java. ACM Trans. Program. Lang. Syst. 41, 3, Article 18 (July 2019),
58 pages. https://doi.org/10.1145/3332371
[60]Manu Sridharan, Shay Artzi, Marco Pistoia, Salvatore Guarnieri, Omer Tripp,
andRyanBerg.2011. F4F:TaintAnalysisofFramework-basedWebApplications.
InOOPSLA ‚Äô11. ACM, 16. https://doi.org/10.1145/2048066.2048145
[61]DerekStaahl.2016. HackthattargetedArizonavoterdatabasewaseasytopre-
vent, expert says. http://www.azfamily.com/story/32945105/hack-that-targeted-
arizona-voter-database-was-easy-to-prevent-expert-says.
[62]Zhendong Su and Gary Wassermann. 2006. The Essence of Command Injection
Attacks in Web Applications. In Conference Record of the 33rd ACM SIGPLAN-
SIGACTSymposiumonPrinciplesofProgrammingLanguages (POPL‚Äô06) .ACM,
New York, NY, USA, 372‚Äì382. https://doi.org/10.1145/1111037.1111070
[63]G. Edward Suh, Jae W. Lee, David Zhang, and Srinivas Devadas. 2004. Secure
ProgramExecutionviaDynamicInformationFlowTracking.In ASPLOSXI.ACM,
New York, NY, USA, 85‚Äì96. https://doi.org/10.1145/1024393.1024404
[64]Yang Tang, Phillip Ames, Sravan Bhamidipati, Ashish Bijlani, Roxana Geambasu,
and Nikhil Sarda. 2012. CleanOS: Limiting Mobile Data Exposure with Idle
Eviction.In Presentedaspartofthe10thUSENIXSymposiumonOperatingSystems
DesignandImplementation(OSDI12).USENIX,Hollywood,CA,77‚Äì91. https:
//www.usenix.org/conference/osdi12/technical-sessions/presentation/tang
[65] Terence Parr. 2019. ANTLR. https://www.antlr.org/.
[66]The Apache Software Foundation. 2019. OGNL - Apache Commons OGNL -
DeveloperGuide.https://commons.apache.org/proper/commons-ognl/developer-
guide.html.
[67]The Apache Software Foundation. 2019. Security. https://struts.apache.org/
security/.
[68]The Eclipse Foundation. 2019. Jetty - Servlet Engine and Http Server. https:
//www.eclipse.org/jetty/.
[69]The MITRE Corporation. 2019. CWE-601: URL Redirection to Untrusted Site
(‚ÄôOpen Redirect‚Äô). https://cwe.mitre.org/data/definitions/601.html.
[70]JulianThom√©,AlessandraGorla,andAndreasZeller.2014. Search-basedSecurity
Testing of Web Applications. In Proceedings of the 7th International Workshop
onSearch-BasedSoftwareTesting (SBST2014).ACM,NewYork,NY,USA,5‚Äì14.
https://doi.org/10.1145/2593833.2593835
[71]OmerTripp,MarcoPistoia,StephenJ.Fink,ManuSridharan,andOmriWeisman.
2009. TAJ: Effective Taint Analysis of Web Applications. In PLDI ‚Äô09. ACM, New
York, NY, USA, 87‚Äì97. https://doi.org/10.1145/1542476.1542486
[72]Tielei Wang, Tao Wei, Guofei Gu, and Wei Zou. 2011. Checksum-Aware Fuzzing
CombinedwithDynamicTaintAnalysisandSymbolicExecution. ACMTrans.
Inf. Syst. Secur. 14, 2, Article Article 15 (Sept. 2011), 28 pages. https://doi.org/10.
1145/2019599.2019600
[73]WorldWideWebConsortium.2017. HTML5.2. https://www.w3.org/TR/html52/.
[74]World Wide Web Consortium. 2019. Parsing HTML Documents. https://html.
spec.whatwg.org/multipage/parsing.html.
[75]Pingyu Zhang and Sebastian Elbaum. 2012. Amplifying Tests to Validate Ex-
ception Handling Code. In Proceedings of the 34th International Conference on
Software Engineering (ICSE ‚Äô12). IEEE Press, Piscataway, NJ, USA, 595‚Äì605.
http://dl.acm.org/citation.cfm?id=2337223.2337293[76]Pingyu Zhang and Sebastian Elbaum. 2014. Amplifying Tests to Validate Ex-ception Handling Code: An Extended Study in the Mobile Application Do-
main.ACMTrans.Softw.Eng.Methodol. 23,4,Article32(Sept.2014),28pages.
https://doi.org/10.1145/2652483
296