Interface Compliance of Inline Assembly:
Automatically Check, Patch and ReÔ¨Åne
Fr√©d√©ric Recoules
Univ. Paris-Saclay, CEA, List
Saclay, France
frederic.recoules@cea.fr
Matthieu Lemerre
Univ. Paris-Saclay, CEA, List
Saclay, France
matthieu.lemerre@cea.frS√©bastien Bardin
Univ. Paris-Saclay, CEA, List
Saclay, France
sebastien.bardin@cea.fr
Laurent Mounier
Univ. Grenoble Alpes, VERIMAG
Grenoble, France
laurent.mounier@univ-grenoble-alpes.frRichard Bonichon
Tweag I/O
Paris, France
richard.bonichon@gmail.com
Marie-Laure Potet
Univ. Grenoble Alpes, VERIMAG
Grenoble, France
marie-laure.potet@univ-grenoble-alpes.fr
Abstract ‚ÄîInline assembly is still a common practice in low-
level C programming, typically for efÔ¨Åciency reasons or for
accessing speciÔ¨Åc hardware resources. Such embedded assembly
codes in the GNU syntax (supported by major compilers such
as GCC, Clang and ICC) have an interface specifying how the
assembly codes interact with the C environment. For simplicity
reasons, the compiler treats GNU inline assembly codes as
blackboxes and relies only on their interface to correctly glue
them into the compiled C code. Therefore, the adequacy between
the assembly chunk and its interface (named compliance) is
of primary importance, as such compliance issues can lead
to subtle and hard-to-Ô¨Ånd bugs. We propose RUSTI NA, the
Ô¨Årst automated technique for formally checking inline assembly
compliance, with the extra ability to propose (proven) patches and
(optimization) reÔ¨Ånements in certain cases. RUSTI NA is based
on an original formalization of the inline assembly compliance
problem together with novel dedicated algorithms. Our prototype
has been evaluated on 202 Debian packages with inline assembly
(2656 chunks), Ô¨Ånding 2183 issues in 85 packages ‚Äì 986 signiÔ¨Åcant
issues in 54 packages (including major projects such as ffmpeg
or ALSA), and proposing patches for 92% of them. Currently,
38 patches have already been accepted (solving 156 signiÔ¨Åcant
issues), with positive feedback from development teams.
I. I NTRODUCTION
Context. Inline assembly, i.e. embedding assembly code inside
a higher-level host language, is still a common practice in low-
level C/C++ programming, for efÔ¨Åciency reasons or for ac-
cessing speciÔ¨Åc hardware resources ‚Äì it is typically widespread
in resource-sensitive areas such as cryptography, multimedia,
drivers, system, automated trading or video games [1], [2].
Recoules et al. [1] estimate that 11% of Debian packages
written in C/C++ directly or indirectly depend on inline
assembly, including major projects such as GMP or ffmpeg,
while 28% of the top rated C projects on GitHub contain inline
assembly according to Rigger et al. [2].
Thus, compilers supply a syntax to embed assembly in-
structions in the source program. The most widespread is
theGNU inline assembly syntax, driven by GCC but also
supported by Clang or ICC. The GNU syntax provides an
interface specifying how the assembly code interacts withthe C environment. The compiler then treats GNU inline
assembly codes as blackboxes and relies only on this interface
to correctly insert them into the compiled C code1.
Problem. The problem with GNU inline assembly is twofold.
First, it is hard to write correctly2: inline assembly syntax [4]
is not beginner-friendly, the language itself is neither standard-
ized nor fully described, and some corner cases are deÔ¨Åned by
GCC implementation (with occasional changes from time to
time). Second, assembly chunks are treated as blackboxes, so
that the compiler does not do any sanity checks3andassumes
the embedded assembly code respects its declared interface.
Hence, in addition to usual functional bugs in the assem-
bly instructions themselves, inline assembly is also prone
tointerface compliance bugs, i.e., mismatches between the
declared interface and the real behavior of the assembly chunk
which can lead to subtle and hard-to-Ô¨Ånd bugs ‚Äì typically
incorrect results or crashes due to either subsequent compiler
optimizations or ill-chosen register allocation. In the end,
compliance issues can lead to severe bugs (segfault, deadlocks,
etc.) and, as they depend on low-level compiler choices, they
are hard to identify and can hide for years before being trig-
gered by a compiler update. For example, a 2005 compliance
bug introduced in the libatomic_obs library of lock-free
primitives for multithreading made deadlocks possible: it was
identiÔ¨Åed and patched only in 2010 (commit 03e48c1). A
similar bug was still lurking in another primitive in 2020 until
we automatically found and patched it (commit 05812c2). We
also found a 1997 interface compliance bug in glibc (leading
to asegfault in a string primitive) that was patched in 1999
(commit 7c97add), then reintroduced in 2002 after refactoring.
Goal and challenges. We address the challenge of helping
developers write safer inline assembly code by designing and
1Microsoft inline assembly is different and has no interface, see Sec. IX-C.
2From the llvm-dev mailing list [3]: ‚ÄúGCC-style inline assembly is notori-
ously hard to write correctly‚Äù.
3Note that syntactically incorrect assembly instructions are caught during
the translation from assembly to machine code.
12362021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00113
developing automated techniques helping to achieve interface
compliance, i.e. ensuring that both the assembly template and
its interface are consistent with each other . This is challenging
for several reasons:
DeÔ¨Åne The method must be built on a (currently missing)
proper formalization of interface compliance, both real-
istic and amenable to automated formal veriÔ¨Åcation;
Check, Patch & ReÔ¨Åne The method must be able to check
whether an assembly chunk complies with its interface,
but ideally it should also be able to automatically suggest
patches for bugs or code reÔ¨Ånements;
Wide applicability The method must be generic enough to
encompass several architectures, at least x86 and ARM.
Fehnker et al. [5] published the only attempt we know of
to inspect the interface written by the developer. Yet, their
deÔ¨Ånition of interface compliance is syntactic and incomplete
‚Äì for example they cannot detect the glibc issue mentioned
above. Moreover, they do not cover all subtleties of GCC inline
assembly (e.g., token constraints), consider only compliance
checking (neither patching nor reÔ¨Ånement) and the implemen-
tation is tightly bound to ARM (much simpler than x86).
Note that recent attempts for verifying codes mixing C and
assembly [1], [6] simply assume interface compliance.
Proposal and contributions. We propose RUSTI NA, the
Ô¨Årst sound technique for comprehensive automated interface
compliance checking, automated patch synthesis and interface
reÔ¨Ånements. We claim the following contributions:
a novel semantic andcomprehensive formalization of the
problem of interface compliance (Sec. IV), amenable to
formal veriÔ¨Åcation;
a new semantic method (Sec. V) to automatically verify
the compliance of inline assembly chunks, to generate
a corrective patch for the majority of compliance issues
and additionally to suggest interface reÔ¨Ånements;
thorough experiments (Sec. VII) of a prototype imple-
mentation (Sec. VI) on a large set of x86 real-world
examples (all inline assembly found in a Debian Linux
distribution) demonstrate that RUSTI NA is able to au-
tomatically check and curate a large code base (202
packages, 2640 assembly chunks) in a few minutes ,
detecting 2036 issues and solving 95% of them;
a study of current inline assembly coding practices
(Sec. VIII); besides identifying the common compliance
issues found in the wild (Sec. VII-A), we also exhibit 6
recurring patterns leading to the vast majority (97%) of
compliance issues and show that 5 of them rely on fragile
assumptions and can lead to serious bugs (Sec. VIII).
As the time of writing, 38 patches have already been
accepted by 7 projects, solving 156 signiÔ¨Åcant issues
(Sec. VII-C).
Summary. Inline assembly is a delicate practice. RUSTI NA
aids developers in achieving interface compliant inline assem-
bly code. Compliant assembly chunks can still be buggy but
RUSTI NAautomatically removes a whole class of problems.Our technique has already helped several renowned projects
Ô¨Åx code, with positive feedback from developers.
Note: supplementary material, including prototype and bench-
mark data, is available online [7].
II. C ONTEXT AND MOTIVATION
The code in Fig. 1 is an extract from libatomic_obs, commit
30cea1b dating back to early 2012. It was replaced 6 months
later by commit 64d81cd because it led to a segmentation
fault when compiled with Clang. By 2020, another la-
tent bug was still lurking until automatically discovered and
patched by our prototype RUSTI NA (commit 05812c2).
179AO_INLINE int
180AO_compare_double_and_swap_double_full (volatile AO_double_t *addr,
181 AO_t old_val1, AO_t old_val2,
182 AO_t new_val1, AO_t new_val2)
183{
184 charresult;
[. . .]
193 __asm__ __volatile__( "xchg %%ebx,%6;" /*swap GOT ptr and new_val1 */
194 "lock; cmpxchg8b %0; setz %1;"
195 "xchg %%ebx,%6;" /*restore ebx and edi */
196 :"=m"(*addr),"=a"(result)
197 :"m"(*addr),"d"(old_val2), "a"(old_val1),
198 "c"(new_val2), "D"(new_val1) :"memory" );
[. . .]
209 return(int) result;
210}
Figure 1:atomic_ops/sysdeps/gcc/x86.h @30cea1b
What the code is about. This function uses inline assembly to
implement the standard atomic primitive Compare And Swap
‚Äì i.e. write new_val in*addr if this latter still equals
toold_val (where 8-byte values old_val andnew_val
are split in 4-byte values old_val1 ,old_val2 , etc.). The
assembly statement (syntax discussed in Sec. III) comprises
assembly instructions (e.g., "lock; cmpxchg8b %0;" )
building an assembly template where some operands have been
replaced by tokens (e.g.,%0) that will be latter assigned by
the compiler. It also has a speciÔ¨Åcation, the interface , binding
together assembly registers, tokens and C expressions: line 196
declares the outputs , i.e. C values expected to be assigned
by the chunk; lines 197 and 198 declare the inputs , i.e. C
values the compiler should pass to the chunk. The string placed
before a C expression is called a constraint and indicates
the set of possible assembly operands this expression can be
bound to by the compiler. For instance, "d"(old_val2)
indicates that register %edx should be initialized with the
value ofold_val2 , while"=a"(result) indicates the
value ofresult should be collected from %eax . Token%0
introduced by "m"(*addr) is an indirect memory access:
its address, arbitrarily denoted &0here, can be bound to
several possibilities (cf. Fig. 5) ‚Äì including %esi or%ebx .
Fig. 2 gives the functional meaning of this binding along
with the semantics of the assembly instructions (where ‚Äú ::‚Äù is
the concatenation, ‚Äúc  ‚Äù a conditional assignment, ‚Äú efh::lg‚Äù
the bits extraction and ‚Äú zextn‚Äù the zero extension to size n).
This example allows us to introduce the concept of interface
compliance issues and the associated miscompilation prob-
lems: A) (framing condition) incomplete interfaces, possibly
1237193
193
194
194195
195
196
197
196
197
198  z(%edx ::%eax) =*(&0)
   %edx ::%eax *(&0)
z   *(&0) %ecx ::%ebx ·Ωë2
  %eax %eaxf31::8g::(zext8z)
%ebx %edi
   result %eaxf7::0g%ebx %edi  %edi new_val1  %ecx new_val2  %eax old_val1  %edx old_val2  &0addr
cmpxchg8b %0xchg%ebx,%edi
lock
setz%al
xchg%ebx,%edi
"=a"(result)"D"(new_val1)"c"(new_val2)"a"(old_val1)"d"(old_val2)"=m"(*addr)
Figure 2: Assembly statement semantics
leading to miscompilations due to wrong data dependencies;
B)(unicity) ambiguous interfaces, where the result depends
on compiler choices for token allocation.
A) An incomplete frame deÔ¨Ånition. Here, register %edx is
declared as read-only (by default, non-output locations are)
whereas it is overwritten by instruction cmpxchg8b (c.f.
Fig. 2).%edx should be declared as output as well.
Impact: The compiler exclusively relies on the interface to
know the framing-condition ‚Äì i.e. which locations are read
or written. When this information is incomplete, data de-
pendencies are miscalculated, potentially leading to incorrect
optimizations. Here, the compiler believes %edx still contains
old_val2 after the assembly chunk is executed, while it is
not the case.
Note that %ebx and%esi arenotmissing the output
attribute: while overwritten by the xchg instructions, they are
then restored to their initial value.
B) Ambiguous interface. Here, while most of the binding is
Ô¨Åxed, the compiler still has to bind &0according to constraint
"m". Yet, if the compiler rightfully chooses %ebx , the data
dependencies in the assembly itself differ from the expected
one: pointer addr is exchanged with new_val1 just before
being dereferenced, which is not the expected behaviour. The
problem here is that the result cannot be predicted as it depends
on token resolution from the compiler.
Impact: the function is likely to end up in a
segmentation fault when compiled by Clang.
Historically, GCC was not able to select %ebx and the bug
did not manifest, but Clang did not had such restriction.
The problem. These compliance issues are really hard
to Ô¨Ånd out either manually or syntactically. First, there
is here clearly no hint from the assembly template itself
("cmpxchg8b %0" ) that register %edx is modiÔ¨Åed. Second,
complex token binding and aliasing constraints must be taken
into account. Third, subtle data Ô¨Çows must be taken into
account ‚Äì for example a read-only value modiÔ¨Åed then restored
is not a compliance issue.
RUSTI NA insights. To circumvent these problems, we have
developed RUSTI NA, an automated tool to check inline
assembly compliance (i.e. formally verifying the absence of
compliance errors) and to patch the identiÔ¨Åed issues.RUSTI NA builds upon an original formalization of the
inline assembly interface compliance problem, encompassing
both framing and unicity . From that, our method lifts binary-
level Intermediate Representation (sketched in Fig. 2) and
adapt the classical data-Ô¨Çow analysis framework ( kill-gen [8])
in order to achieve sound interface compliance veriÔ¨Åcation ‚Äì
especially RUSTI NA reasons about token assignments. From
the expected interface, it infers for each token an overapprox-
imation of the set of valid locations and then computes the set
of locations that shall not be altered before the token is used.
Here, it deduces that writing in register %ebx may impact
token%0. Also, it detects that a write occurs in the read-only
register%edx , thus successfully reporting the two issues.
Moreover, RUSTI NA automatically suggests patches for the
two issues. For framing, Fig. 3 highlights the core differences
between the two versions ( %edx is now rightfully declared
as output with "=d" ) ‚Äì a similar patch now lives on the
current version of the function (commit 05812c2). For unicity,
it suggests to declare %ebx as clobber, yielding a working Ô¨Åx.
Yet, it also over-constrains the interface ‚Äì the syntax does not
allow a simple disequality between %0and%ebx . Developers
actually patched the issue in 2012 in a completely different
way by rewriting the assembly template (commit 64d81cd) ‚Äì
such a solution is out of RUSTI NA‚Äôs scope.
@@ -193,5 +193,6 @@
- __asm__ __volatile__("xchg %%ebx,%6;" / *swap GOT ptr and new_val1 */
+AO_t dummy;
+__asm__ __volatile__("xchg %%ebx,%7;" / *swap GOT ptr and new_val1 */
"lock; cmpxchg8b %0; setz %1;"
- "xchg %%ebx,%6;" / *restore ebx and edi */
- : "=m"(*addr), "=a"(result)
- : "m"(*addr), "d" (old_val2), "a" (old_val1),
+ "xchg %%ebx,%7;" / *restore ebx and edi */
+ : "=m"(*addr), "=a"(result), "=d" (dummy)
+ : "m"(*addr), "2" (old_val2), "a" (old_val1),
Figure 3: Frame-write corrective patch
Generic and automatic, our approach is well suited to handle
what expert developers failed to detect, while a simpler ‚Äúbad‚Äù
patterns detection approach would struggle against both the
combinatorial complexity induced by the size of architec-
ture instruction sets and the underlying reasoning complexity
(dataÔ¨Çow, token assignments). Overall, RUSTI NA found and
patched many other signiÔ¨Åcant issues in several well-known
open source projects (Sec. VII).
III. GNU INLINE ASSEMBLY SYNTAX
Overview. This feature allows the insertion of assembly in-
structions anywhere in the code without the need to call an
externally deÔ¨Åned function. Fig. 4 shows the concrete syntax
of an inline assembly block, which can either be basic when
it contains only the assembly template or extended when
it is supplemented by an interface . This section concerns
the latter only. The assembly statement consists of ‚Äúa series
of low-level instructions that convert input parameters to
output parameters‚Äù [4]. The interface binds C lvalues (i.e.,
expressions evaluating to C memory locations) and expressions
to assembly operands speciÔ¨Åed as input oroutput , and declares
a list of clobbered locations (i.e., registers or memory cells
1238whose values could change). For the sake of completeness,
the statement can also be tagged with volatile ,inline
orgoto qualiÔ¨Åers, which are irrelevant for interface compli-
ance, thus not discussed in this paper. The interface bindings
described above are written by string speciÔ¨Åcations, which
we will now explain.
Templates. The assembly text is given in the form of a for-
mattedstring template that, like printf , may contain so-
called token s (i.e., place holders). These start with %followed
by an optional modiÔ¨Åer and a reference to an entry of the in-
terface , either by name (an identiÔ¨Åer between square brackets)
or by a number denoting a positional argument. The compiler
preprocesses the template, substituting token s by assembly
operands according to the entries and the modiÔ¨Åers (note that
only a subset of x86 modiÔ¨Åers is fully documented [9]) and
then emits it as is in the assembly output Ô¨Åle.
hstatementi::=‚Äòasm‚Äô[‚Äòvolatile ‚Äô]‚Äò(‚Äôhtemplate :stringi[hinterfacei]‚Äò)‚Äô
hinterfacei::=‚Äò:‚Äô[houtputsi]‚Äò:‚Äô[hinputsi]‚Äò:‚Äô[hclobbersi]
houtputsi::=houtputi[‚Äò,‚Äôhoutputsi]
hinputsi::=hinputi[‚Äò,‚Äôhinputsi]
hclobbersi::=hclobber :stringi[‚Äò,‚Äôhclobbersi]
houtputi::= [ ‚Äò[‚ÄôhidentiÔ¨Åeri‚Äò]‚Äô]hconstraint :stringi‚Äò(‚ÄôhClvaluei‚Äò)‚Äô
hinputi::= [ ‚Äò[‚ÄôhidentiÔ¨Åeri‚Äò]‚Äô]hconstraint :stringi‚Äò(‚ÄôhCexpressioni‚Äò)‚Äô
Figure 4: Concrete syntax of an extended assembly chunk
Clobbers. They are names of hard registers whose values may
be modiÔ¨Åed by the execution of the statement, but not intended
as output. Clobbers must not overlap with inputs and outputs.
The"cc" keyword identiÔ¨Åes, when it exists, the conditional
Ô¨Çags register. The "memory" keyword instructs the compiler
that arbitrary memory could be accessed or modiÔ¨Åed.
a=f%eaxgb=f%ebxgc=f%ecxg
d=f%edxgS=f%esigD=f%edig
U=a[c[d q =Q=a[b[c[d
i=n=Z r=R=q[S[D[f%ebpg
p=frb+kri+cforrb2r[f%espg[f 0g
andri2r[f0gandk2f1;2;4;8g
andc2ig
m=f*pforp2pg g=i[r[m
Figure 5: GCC i386 architecture constraints
Constraints. A third language describes the set of valid
assembly operands for token assignment. The latter are of 3
kinds: an immediate value, a register or a memory location.
Fig. 5 gives a view of common atomic constraints (‚Äúletters‚Äù)
used in x86. Constraint entries can have more that one atomic
constraint (e.g., "rm" ), in which case the compiler chooses
among the union of operand choices. The language allows
to organize constraints into multiple alternatives , separated
by‚Äò,‚Äô. Additionally, matching constraint between an input
token and an output token forces them to be equal; early
clobber ‚Äò&‚Äôinforms the compiler that it must not attempt
to use the same operand for this output and any non-matchedinput; commutative pair ‚Äò%‚Äômakes an input and the next
one exchangeable.
Finally, output constraints must start either with ‚Äò=‚Äôfor the
write-only mode or with ‚Äò+‚Äôfor the read-write permission.
IV. F ORMALIZING INTERFACE COMPLIANCE
A. Extended assembly
Assembly chunks. We denote by C:asm a standard chunk
of assembly code. Such a chunk operates over a memory state
M:mstate , that is a map from location (registers of
the underlying architecture or memory cells) to basic values
(int8, int16, int32, etc.). We call A:valueset the set
of valid addresses for a given architecture. The value of an
expression in a given memory state is given by function
eval :mstateexpression7!value . The set of
valid assembly expressions is architecture-dependent (Fig. 5
is for i386). We abstract it as a set of expression s built
over registers, memory accesses *and operations. Finally, an
assembly chunk Ccan be executed in a memory state Mto
yield a new memory state M0with function exec :asm
mstate7!mstate . Fig. 6 recaps above functions and types.
exec :asmmstate7!mstate
eval :mstateexpression7!value
mstate :location7!value
expression ase::=value |register |*e|e+e|ee|...
location ::=register |value
register ::=%eax |%ebx |%ecx |%edx |... // case of x86
value :int8 |int16 |int32 |...
Figure 6: Assembly types
Assembly templates. Inline assembly does not directly use
assembly chunks, but rather assembly templates , denotedC:
asm, which are assembly chunks where some operands are
replaced by so-called tokens , i.e., placeholders for regular as-
semblyexpression s to be Ô¨Ålled by the compiler (formally,
they are identiÔ¨Åers %0,%1, etc.). Given a token assignment T:
token7!expression , we can turn an assembly template
C:asminto a regular assembly chunk C:asm using standard
syntactic substitution <>, denotedC<T>:asm. The value of
tokentthrough assignment Tis given by eval (M,T(t)).
Formal interface. We model an interfaceI,(BO,BI,ST,
SC,F) as a tuple consisting of output tokens BO:tokenset,
input tokens4BI:tokenset , amemory separation Ô¨ÇagF:
bool ,clobber registers SC:register set andvalid token
assignments ST:Tset.
Input and output tokens bind the assembly memory state
and the C environment. Informally, the locations pointed
to by tokens in BIareinput initialized by the value of
some C expressions while the values of the tokens in BO
areoutput to some C lvalues. BO[BIcontains all token
declarations and BO\BImay be non-empty;
4Actually, a concrete interface also contains initializer and collector expres-
sions in order to bind I/O assembly locations input and output to C. We skip
them for clarity, as they do not impact compliance.
1239If the Ô¨Çag Fis set to false, then assembly instructions
may have side-effects on the C environment ‚Äì otherwise
they operate on separate memory parts;
SCandSTprovide additional information about how
the compiler should instantiate the assembly template to
machine code: the clobber registers in SCcan be used for
temporary computations during the execution (their value
is possibly modiÔ¨Åed by the chunk), while STrepresents
all possible token assignments the compiler is allowed
to choose ‚Äì the GNU syntax typically leads to equality,
disequality and membership constraints between tokens
and (sets of) registers.
Extended assembly chunk. An extended assembly chunk
X,(C,I) is a pair made of an assembly template Cand its
related interface I. The assembly template is the operational
content of the chunk (modulo token assignment) while the
interface is a contract between the chunk, the C environment
and low-level location management.
B. (Detail) From GNU concrete syntax to formal interfaces
Let us see how the formal interface Iis derived from
concrete GNU syntax (Fig. 4). Tokens BOandBIcome from
the corresponding output and input lists except that: a) if an
output entry is declared using the '+' modiÔ¨Åer then it is added
to bothBOandBI; and b) if an input token and an output token
are necessarily mapped to the same register, they are uniÔ¨Åed.
Each register in the clobber list belong to SC. If the clobber list
contains"memory" , the memory separation Ô¨Çag Fis false,
true otherwise. The set STof valid token assignments Tis
formally derived in 3 steps:
1) collection of string constraints, splitting constraints by
alternative (i.e., ','):(token7!string)set ;
2) architecture-dependent (e.g., Fig. 5) evaluation of string
constraints: (token7!expression set)set ; rep-
resenting a disjunction of conjunctions of atomic mem-
bership constraints token2{exp, . . . ,exp };
3) Ô¨Çattening: ( token7!expression )set representing
a disjunction of conjunctions of atomic equality con-
straintstoken =expression ;
Still, token assignments must respect the following properties
(and are Ô¨Åltered out otherwise):
every output token maps to an assignable operand,
either aregister or a*eexpression ;
every output token maps to distinct location ;
eachtoken maps to a clobber-free expression
where a clobber-free expression is an expression without
any clobber register nor any early-clobber sub-expression (i.e.
containing the mapping of an early-clobber token , intro-
duced by the '&' modiÔ¨Åer).
Fig. 7 exempliÔ¨Åes the interface formalization of Fig. 1‚Äôs
chunk introduced in Sec. II. Tokens BOandBIsimply enu-
merate the present entries respectively in output and input lists
(L196-198). The 5thentry matches the same register %eax as
the second, %4is uniÔ¨Åed with %1. For the sake of brevity, we
split the set of token assignments into two parts: one invariantw.r.t. compiler choices, and one that may vary (we only list
4 of them but there are other valid combination of memory
references). Finally, it has no clobbered register and, because
of keyword "memory" , memory separation is false .
BO= {%0,%1},
BI= {%2,%3,%5,%6}
ST= { [%17!%eax ,%37!%edx ,%57!%ecx ,%67!%edi ] } // Ô¨Åxed assignments
{ [%07!*%esi ,%27!*%esi ], [%07!*%ebp ,%27!*%ebp ],// possible variations[%07!*%esi ,%27!*%ebp ], [%07!*%ebx ,%27!*%ebx ], ... }
SC=;
F=false
Figure 7: Formal interface I
C. Interface compliance
An extended assembly chunk X,(C,I) is said to be
interface compliant if it respects both the framing and the
unicity conditions that we deÔ¨Åne below.
Observational equivalences. As a Ô¨Årst step, we deÔ¨Åne an
equivalence relation=T
B;Fover memory states modulo a token
assignment T, a set of observed tokens Band a memory
separation Ô¨Çag F. We start by deÔ¨Åning an equivalence relation
T
B. We say that M1T
BM2if, for all tokentinB,
eval (M1,T(t)) =eval (M2,T(t)). We can generalize it to
any pair of token assignments T1andT2:M1T1;T2
BM2if,
for alltoken stinB,eval (M1,T1(t)) =eval (M2,T2(t)).
Then, we deÔ¨Åne an equivalence relationover memory states.
We say that M1M2if for all (address) location linA,
M1(l) =M2(l). The equivalence relation=T
B;Fover memory
states modulo a token assignment T(which can be generalized
to a pairT1andT2as above), a set of tokens Band a memory
separation Ô¨Çag Fis Ô¨Ånally deÔ¨Åned as:
M1=T
B;FM2if:M1T
BM2^(F=false impliesM1M2)
Framing condition. The framing condition restricts what can
be read and written by the assembly template. Given a token
assignment T, we deÔ¨Åne a location input (resp. location out-
put) as a location pointed by a input (resp. output) token. Then
the framing condition stipulates that: (frame-read) only initial
values from input location can be read; (frame-write) only
clobber registers and location output are allowed to be modi-
Ô¨Åed by the assembly template.
More formally, a location is assignable if it can be modiÔ¨Åed
(i.e., if it is mapped to by an output token t, belongs to the
clobber set SCor is a memory location Awhen there is no
separation:F), and non-assignable otherwise. We then have:
frame-write for allM, for allTinST, for all non assignable
location l:M(l) =exec (M,C<T>)(l).
frame-read for allM1,M2andTinSTsuch that
M1=T
BI;FM2:exec (M1,C<T>)=T
BO;Fexec (M2,C<T>),
Unicity. Informally, the unicity condition is respected when
the evaluation of output tokens is independent from the chosen
token assignment. More formally, for all M1,M2,T1andT2
inSTsuch thatM1=T1;T2
BI;FM2:
exec (M1,C<T1>)=T1;T2
BO;Fexec (M2,C<T2>).
Note that frame-read is a sub-case of unicity where T1=T2.
1240V. C HECK ,PATCH AND REFINE
Figure 8 presents an overview of RUSTI NA. The tool
takes as input a C Ô¨Åle containing inline assembly templates
in GNU syntax. From there, it parses the template code to
produce an intermediate representation (IR) of the template
C, and interprets the concrete interface to produce a formal
interfaceI. The tool then checks that the code complies
with its interface using dedicated static dataÔ¨Çow analysis .
If it succeeds, we have formally veriÔ¨Åed that the assembly
template complies with its interface. If not, our tool examines
the difference between the formal interface computed from
the code and the one extracted from speciÔ¨Åcation; it can
then produce a patch (if some elements of the interface were
forgotten) or reÔ¨Åne the interface (if the declared interface
is larger than needed). We cannot produce a patch in every
situation, in that case the tool reports a compliance alarm ‚Äì
they can be false alarms, but it rarely happens on real code.
Algorithms are fully detailed in the companion report [7].
A. Preliminary: code semantics extraction
Our analyses rely on Intermediate Representations (IR) for
binary code, coming from lifters [10], [11] developed for the
context of binary-level program analysis. We use the IR of
the B INSEC platform [12], [13] (Fig. 9), but all such IRs
are similar. They encode every machine code instruction into
a small well-deÔ¨Åned side-effect free language, typically an
imperative language over bitvector variables (registers) and
arrays (memory), providing jumps and conditional branches.
Still, code lifters do not operate directly on assembly templates
but on machine code, requiring a little extra-work to recover
the tokens. We replace each token in the assembly template by
a distinct register, use an existing assembler ( GAS) to transform
the new assembly chunk into machine code and then lift it to
IR. We perform the whole operation again where each token
is mapped to another register, so as to distinguish tokens from
hard-coded registers. Tokens are then replaced in IR by distinct
new variable names.
B. Compliance Checking
This section discusses our static interface compliance
checks. We rely on the dataÔ¨Çow analysis framework [8],
intensively used in compilers and software veriÔ¨Åcation. We
collect sets of locations (token ,register or the whole
memory ) as dataÔ¨Çow facts, then compare them against the sets
expected from the interface. Checking frame-write requires
aforward impact analysis , checking frame-read requires a
backward liveness analysis , and Ô¨Ånally unicity requires a
combination of both. Our techniques are over-approximated
in order to ensure soundness. Memory is considered as a
whole ‚Äì all memory accesses being squashed as memory ,
with a number of advantages: it closely follows the interface
mechanisms for memory, helps termination (the set of dataÔ¨Çow
facts is Ô¨Ånite) and saves us the complications of memory-
aware static analysis (heap or points-to). Finally, we propose
twoprecision optimizations in order to reduce the risk of false
positives (their impact is evaluated in Sec. VII-D).Frame-write. Check must ensure that non-assignable loca-
tions have the exact same value before and after the execution.
As Ô¨Årst approximation, a location that is never written (i.e.,
never on the Left Hand Side LHS of an assignment) safely
keeps its initial value ‚Äì since IR expressions are side-effect
free. Impact analysis iterates forward from the entry of the
chunk, collecting the set of LHS locations (either a token ,
aregister or the whole memory ). We then check that
each LHS location belongs to the set of declared assignable
locations (i.e. BO[SCtogether with memory if:F).
Frame-read. Check must ensure that no uninitialized location
is read. This requires to compute (an overapproximation of)
the set of livelocations (i.e. holding a value that may be read
before its next deÔ¨Ånition). Liveness analysis iterates backward
from the exit of the chunk, where output locations are live
(outputs tokens BO), computing dependencies of the Right
Hand Side (RHS) expression of found deÔ¨Ånitions until the
Ô¨Åx-point is reached. We then check at the entry point that
each live location belongs to the set of declared inputs (i.e.
BItogether with memory if:F).
Unicity. Check must ensure that compiler choices have no im-
pact on the chunk output. What may happen is that a location
is impacted or not by a preceding write depending on the token
assignment. To check that this does not happen, we Ô¨Årst deÔ¨Åne
a relation may_impact overlocation(incl. tokens) such
thatlmay_impact l0is false if we can prove that (writing
on)lhas no impact on (the evaluation of) l0‚Äì whatever the
token assignment. In our implementation, lmay_impact l0
returns false if there is no token assignment where lis a
sub-expression of l0. Then, using previous frame-write and
frame-read analyses, we Ô¨Ånally check at each assignment to
a locationlthat, for each live location l‚Äô,lmay_impact
l‚Äô returnsfalse .
We now sketch the implementation of may_impact . The
main challenge is to avoid enumerating all valid token as-
signmentsST(c.f. Sec. IV-B) . We compute over a smaller
set of abstract location facts location, indicating only
whether a location is a constant value ( Immediate ), a regis-
ter (Directregister ) or is used to compute the address
of a token ( Indirect register ). We abstract token as-
signments by reinterpreting the constraints over location,
yielding D:location7!locationset. We then
deÔ¨Åne the relation limpactl0overlocationas:
limpactl0=8
><
>:Direct rimpactDirect r :true
Direct rimpactIndirect r:true
others :false
Finally, we build the relation lmay_impact l‚Äô such that
it returnstrue (sound) except if one of the following holds:
nol,l0inD(l)D(l‚Äô) such that limpactl0;
lorl‚Äô belongs to SC;
landl‚Äô are tokens, lis early clobber ( "&");
lis equal to l‚Äô (independent of compiler choice).
1241GNU assembly template
GNU assembly interface+CIRtemplateC
Formal interface ICODE SEMANTICS
EXTRACTION
INTERFACE SEMANTICS
EXTRACTIONCHECK
PATCHFormally veriÔ¨Åed
compliance
Formally compliant
patch
Compliance alarm/remove_sign/check_sign
/check_sign
/remove_signFigure 8: Overview of RUSTI NA
inst := lv e|goto e |if e then goto e else goto e
lv := var |@[e]n
e := cst |lv|unop e |binop e e |e ? e : e
unop :=:| |zextn|sextn|extract i::j
binop := arith |bitwise |cmp |concat
arith := +| ||udiv |urem |sdiv |srem
bitwise :=^|_||shl|shr|sar
cmp := =|6=|>u|<u|>s|<s
Figure 9: The B INSEC intermediate representation
Our checkers are semantically sound in the sense that they
compute an overapproximation of the assembly template se-
mantics. Hence, successfully checking an extended assembly
chunk ensures it is interface-compliant .
Onthe other hand, our technique could report compliance
issues that do not exist (false positiv es). W e propose below
twoprecision impro vements :
1. Expr ession pr opagation In Fig. 1,frame-write check,
as is, would report a violation for%ebx and%esi because
they are written. Yet, it is a false positi vesince both end up
with their initial v alue. T o avoid it, we perform a symbolic
expression propagation for each written locat ion, inlining the
deÔ¨Ånition of written locations into their RHS e xpressions, and
performing IR-level syntactic simpliÔ¨Åcations ‚Äì such as 1+x 
1 =xorxx= 0. Then, at Ô¨Åxpoint, frame-write checks
before raising an alarm whether the original v alue has been
restored (no alarm) or not (alarm);
2. Bit-le velliveness dependency In Fig. 1,result takes
only the lowest byte of%eax . However,our basic technique
will count both z and%eax as li vewhile high bytes of
%eax are actually not ‚Äì such imprecisions may lead to
false alarms (Sec. VII-D). W e impro veour li veness analysis
to independently track the status of each location bit. F or
efÔ¨Åcienc y,we do not propag ate location bits b ut locations
equipped with a bitset representing the status of each of their
bits. W e modify propagation rules accordingly (especially bit
manipulations lik e extraction or concatenation), with bitwise
operations o verthe bitsets.
C. Interface Patching
When the compliance checking fails, RUSTINA tries to
generate a patch to Ô¨Åx the issue. As our dataÔ¨Ço w analysis infers
an over-approximated interf ace for the chunk under analysis,
we tak e adv antage of it to strengthen the current interf ace.
Framing condition. Webuild a patch that mak es the template
Ccompliant with its formal interfaceIas follo ws:
frame-write Any hard-coded re gister (resp. token) written
without belonging toSC(resp.BO) isadded;frame-read Any token read without belonging to BIand
without being initialized before, is added. Reading a register
before assigning it pre vents automatic patch generation5.
In both cases, an y direct access to a memory cell sets memory
separationFtofalse .
Wethen retroÔ¨Åt the changes of the formal interf ace in the
concrete syntax to produce the patch. Forinstance, in Fig. 3,
token%3(i.e.%edx ) violates theframe-write condition. W e
add a new output tok en%2:"=d"(dummy) bound to its old
initializer : "2"(old_val2) . Since we add a new tok en,
we tak e care to keep template ‚Äúnumbering‚Äù consistent.
When a framing issue patch is generated, the resulting chunk
isensured to meet the framing condition.
Unicity .We give to the f aulty re gister (resp. token) the
(resp. early) clobber status preventing it to be mis-assigned
to another token. Note ho wever that, since we over-constrain
the interf ace (the syntax does not allo w to declare a pair of
entries as distinct), the patch may failif there is no more v alid
token assignment.
When a unicity patch is generated, the resulting chunk is
ensured to be fully interface compliant if it still compiles.
D.Bonus: ReÔ¨Åning the interface
Even if overapproximated, the interf ace that is inferred by
RUSTINA during the check may be smaller than the declared
one, allo wing to produce reÔ¨Ånement patches removing unnec-
essary constraints in the interface ‚Äì which can in turn gi ve
more room to the compiler to produce smaller or faster code.
Wecan already remov e ne ver-read inputs, never-written
clobbers or undue"memory" keywords in absence of mem-
ory accesses6. There is another case where a"memory"
constraint can be remo ved. Indeed, as recommended in the
documentation, single-le velpointer acce sses can be declared
by common entries using the"m" placement constraint instead
of the (much more expensi ve)"memory" keyword.
Wedesign a dedicated ‚Äúpoints-to‚Äù analysis to identify the
candidates for this transformation. It is based on a dataÔ¨Ço w
analysis collecting, for each memory access, the precise loca-
tion (on the form token or symbol + offset) and size of the
access. If it succeeds, we can safely remo vethe"memory"
keyword and instead add a new entry (input "m", output
"=m" or both depending of the access pattern) for each of
the identiÔ¨Åed base pointers.
5If this is done on purpose, the chunk actually is out of this paper‚Äô s scope.
6These reÔ¨Ånements can be disabled for dummy constraints put on purpose.
1242Fig. 10 shows an example of reÔ¨Ånement happening in
libtomcrypt. In the original code, the "memory" constraint
was forgotten. We can see that (patch) reÔ¨Ånement produces a
Ô¨Åx that does not add the missing keyword, but instead changes
the way the content pointed by key is given to the chunk.
asm __volatile__ (
- "movl (%1),%0\n\t"
+ "movl %1,%0\n\t"
"bswapl %0\n\t"
- :"=r"(rk[0]): "r"(key));
+ :"=r"(rk[0]): "m"(*(uint32_t *)key));
Figure 10: Smart patch of a libtomcrypt chunk
VI. I MPLEMENTATION
We have implemented RUSTI NA, a prototype for interface
compliance analysis following the method described in Sec. V.
RUSTI NA is written in OCaml ( 3 kLOC), it is based on
Frama-C [14] for C manipulation (parsing, localization and
patch generation), B INSEC [12], [13] for IR lifting (including
basic syntactic simpliÔ¨Åcations), and GAS to translate assembly
into machine code. Our tool can handle a large portion of the
x86 and ARM instruction sets. Yet, Ô¨Çoat and system instruc-
tions are not supported (they are unsupported by B INSEC ).
Despite this, we handle 84% of assembly chunks found in a
Debian distribution (Sec. VII).
VII. E XPERIMENTAL EVALUATION
Research questions. We consider 5 research questions: RQ1.
Can RUSTI NA automatically check interface compliance on
assembly chunks found in the wild? RQ2. Incidentally,
how many assembly chunks exhibit a compliance issue, and
which ones are the most frequent? RQ3. Can RUSTI NA
automatically patch detected compliance issues? RQ4. What
is the real impact of the compliance issues reported and of the
generated patches? RQ5. What is the impact of RUSTI NA
design choices on the overall checking result?
Setup. All experiments are run on a regular Dell Precision
5510 laptop equipped with an Intel Xeon E3-1505M v5
processor and 32GB of RAM.
Benchmark. We run our prototype on allC-related x86inline
assembly chunks found in a Linux Debian 8.11 distribution ,
i.e., 3107 x86 chunks in 202 packages, including big inline
assembly users like ALSA, GMP or ffmpeg. We remove 451
out-of-scope chunks (i.e., containing either Ô¨Çoat or system
instructions), keeping 2656 chunks (85% of the initial dataset),
with mean size of 8 assembly instructions (max. size: 341).
A. Checking ( RQ1 ,RQ2 )
Table I sums up compliance checking results before (‚ÄúIni-
tial‚Äù) and after patching (‚ÄúPatched‚Äù) ‚Äì we focus here on the
Initial case.
Results. RUSTI NA reports in less than 2 min ( 40 ms per
chunk in average ) that 1292 chunks out of 2656 are (fully)
interface compliant (resp. 117 packages out of 202), while
1364 chunks (resp. 85 packages) have compliance issues.Table I: RUSTI NA application on Debian 8.11 x86
(a) Overview at package level
Packages considered 202average chunks 15
max chunks 384
Initial Patched
/check_sign‚Äì fully compliant 117 58% 178 88%
·ΩÆ1‚Äì only benign issues 31 15% 0 0%
/remove_sign‚Äì serious issues 54 27% 24 12%
(b) Overview at chunk level
Assembly chunks 3107
out-of-scope (e.g. Ô¨Çoats) 451
Relevant chunks 2656average size 8
max size 341
Initial Patched
/check_sign‚Äì fully compliant 1292 49% 2568 97%
·ΩÆ1‚Äì only benign issues 1070 40% 0 0%
/remove_sign‚Äì serious issues 294 11% 88 3%
(c) Overview of found issues
Initial Patched
Found issues 2183 183
signiÔ¨Åcant issues 986 183
frame-write 1718 0
·ΩÆ1‚Äì Ô¨Çag register clobbered 1197 55% 0 0%
/remove_sign‚Äì read-only input clobbered 17 1% 0 0%
/remove_sign‚Äì unbound register clobbered 436 20% 0 0%
/remove_sign‚Äì unbound memory access 68 3% 0 0%
frame-read 379 183
/remove_sign‚Äì non written write-only output 19 1% 0 0%
/remove_sign‚Äì unbound register read 183 8% 183 100%
/remove_sign‚Äì unbound memory access 177 8% 0 0%
unicity 86 4% 0 0%
Among the noncompliant ones, RUSTI NA allows to pinpoint
294 chunks (resp. 54 packages) with serious compliance issues
‚Äì according to our study in Sec. VIII we count an issue as
benign only when it corresponds to missing the Ô¨Çag register
as clobber (P1 in Sec. VIII).
Quality assessment. While chunks deemed compliant by
RUSTI NA are indeed supposed to be compliant (yet, it is
still useful to test it), compliance issues could be false alarms.
We evaluate these two cases with 4 elements. ( qa1) We
run RUSTI NA on known libatomic_obs and glibc compliance
bugs and on their patched versions : every time, RUSTI NA
returns the expected result. ( qa2) We consider 8 signiÔ¨Åcant
projects (Sec. VII-C), manually review all their faulty as-
sembly chunks (covering roughly 50% of the serious issues
reported in Table Ic) as well as randomly chosen compliant
chunks, and crosscheck results with RUSTI NA: they perfectly
match. ( qa3) For compliance proofs, we also run the checker
after patching: RUSTI NA deems all patched chunks com-
pliant. ( qa4) Several patches sent to developers have been
accepted (Sec. VII-C).
We conclude that results returned by RUSTI NAare good:
as expected, a chunk deemed compliant is compliant, and
reported compliance issues are most likely true alarms ‚Äì we
1243do not Ô¨Ånd any false alarm in our dataset.
ARM benchmark. We also run RUSTI NA on the ARM
versions of ffmpeg, GMP and libyuv (from Linux Debian
8.11) for a total of 394 chunks (average size 5, max. size
29). We found very few issues (78), all in ffmpeg and related
to the use of special Ô¨Çag q(accumulated saturations). Manual
review conÔ¨Årms them. Interestingly, the "cc" keywords are
not forgotten in other cases. As Ô¨Çags are explicit in ARM
mnemonics, coding practices are different than those for x86.
RQ1 :RUSTI NA is effective at compliance checking, in
terms of speed and precision ‚Äì yielding compliance proofs
and identifying compliance bugs with near-zero false alarm
rate. RUSTI NA is widely applicable: it runs on the full
Debian assembly chunk base and, without change, on 2
different architectures.
Compliance bugs in practice. Our pre vious precision analysis
allows to assume that a warning from the checker likely indi-
cates a true compliance issue. Hence, according to Tables Ia
and Ib, 1364/2656 chunks (resp. 85/202 packages) are not
interface-compliant, and 294 chunks (resp. 54 packages) have
signiÔ¨Åcant issues. According to Table Ic, 53% of signiÔ¨Åcant
issues come from unexpected writes, 38% from unexpected
reads while 9% are unicity problems.
RQ2 :About half of inline x86 assembly chunks found in the
wild is notinterface-compliant, and a signiÔ¨Åcant part (11%)
even exhibits signiÔ¨Åcant compliance issues ‚Äì affecting 27%
of the packages under analysis.
B.Patching ( RQ3 )
Results. Table I (column ‚ÄúPatched‚Äù) shows that R USTINA
performs well at patching compliance issues: in2 min , it
patches 92% of total issues (2000/2183), including 81%
of signiÔ¨Åcant issues (803/986). Overall, 1276 more chunks
(61 more packages) become fully compliant, reaching 97%
compliance on chunks ( 88% on packages).
The remaining issues (unbound register reads) are out of the
scope of patching. The y often correspond to the case where
some re gisters are used as global memory between assembly
chunks while only C variables can be declared as input in
inline assembly . This practice is howe verfragile (special case
of pattern P6 in Sec. VIII).
Quality assessment. Weassess the quality of the patches
adapting qa1andqa2from Sec. VII-A as follows: (qa0
1) On
known libatomic_obs and glibc compliance bugs, comparing
RUSTINA-generated patches to originals sho ws that they
are functionally equiv alent, with similar Ô¨Åx es. (qa0
2) We
manually r eview all (114) g enerated patches on 8 signiÔ¨Åcant
projects (Sec. VII-C) and check that they do Ô¨Åx the reported
compliance i ssues. Also, recall that patched chunks pass the
compliance checks (qa3) and that se veral patches ha vebeen
accepted by developers ( qa4). Ov erall, in most cases our
automatic patc hes ar e optimal and equivalent to the onesthat would be written by a human . Still, the"memory"
keyword may ha vea signiÔ¨Åcant impact on performance and
developers usually try to avoid it. Weaddress this issue with
reÔ¨Ånement (Sec. V-D). Finally, some unicity issues we found
were actually resolved by de velopers by (deeply) rewriting the
assembly template, instead of simply patching the interf ace.
RQ3 :RUSTI NA effectively generates patches for compli-
ance issues, in terms of speed and patch quality. RUSTI NA
can automatically curate a large code base, removing the vast
majority of compliance issues ‚Äì the remaining ones require
rewriting the code beyond mere interface compliance.
C.Real-life impact (RQ4 )
Wehave selected 8 signiÔ¨Åcant projects from our benchmark
(namely: ALSA, ffmpe g, haproxy , libatomic_obs, libtom-
crypt, UDPCast, xfstt, x264) to submit patches generated by
RUSTINA in order to get real-w orld feedback. Note that
submitting patches is time-consuming: patches must adhere to
the project policy and our generated patches cannot be directly
applied when the code uses macros (a common practice in
inline assembly) as RUSTINA works on preprocessed C Ô¨Åles.
Table III presents our results. Ov erall, we submitted 114
patches Ô¨Åxing 538 issues in the8projects. Feedback has
been v ery positi ve:38patches ha vealready been integrated,
Ô¨Åxing 156issues in 7projects (ALSA, haproxy, libatomic_obs,
libtomcrypt, UDPCast, xfstt, x264) ‚Äì developers clearly e x-
pressed their interest in using RUSTINA once released. The
ffmpe g patches are still under re view.
RQ4 :RUSTI NA helps efÔ¨Åciently deliver quality patches.
D.Internal e valuation: pr ecision optimizations (RQ5 )
The observ ed absence of false positi ves in Sec. VII-A
already tak es into account the two precision enhancers (bit-
level liveness analysis and symbolic e xpression propag ation)
presented in Sec. V -B. W e seek now to assess the impact
of these two improv ements o verthe f alse positi verate (fpr)
of R USTINA.Weran a basic v ersion of RUSTINA (no
expression propagation, no bit-le velliveness, b ut still the basic
IR simpliÔ¨Åcations done by BINSEC) on our whole benchmark.
It turns out that this basic version reports 127 false alarms (6%
fpr) ‚Äì 40frame-write (2% fpr) and 87 frame-read (23% fpr).
All these alarms concern potentially signiÔ¨Åcant issues. Re-
stricting to signiÔ¨Åcant issues, this amount to false positi verates
of 13% (total), 23% (frame-read ) and 8% ( frame-write ). It
turns out that our twooptimizations are complementary: bit-
level liveness analysis remo vesthe 87 false frame-read alarms
while e xpression propag ation remo vesthe 40 false frame-
write alarms.
Thetwo precision optimizations (expression folding, bit-level
liveness) upon RUSTI NA base technique are essential in
order to get a near-zero false alarm rate.
1244Table II: Inline assembly recurrent (compliance) error patterns
Pattern Omitted clobber Additional context Implicit protection Details Robust? # issues Known bug
P1"cc" ‚Äì compiler choice "cc" clobbered by default /check_sign(*) 1197 ‚Äì
P2%ebx register ‚Äì compiler choice %ebx protected in PIC mode /remove_sign(GCC5) 30 [15]
P3%esp register push/pop compiler choice %esp protected /remove_sign(GCC4.6) 5 [16]
P4"memory" single-chunk function function embedding functions treated separately /remove_sign(inlining, cloning) 285 [17]
P5 MMX register single-chunk function ABI MMX are ABI caller-saved /remove_sign(inlining, cloning) 363 ‚Äì
P6 XMM register disable XMM compiler option no XMM generation /remove_sign(cloning) 109 ‚Äì
(*) There are discussions on GCC mailing list to change that [18].
Table III: Submitted patches
Patched Fixed
Project About Status chunks issues Commit
ALSA Multimedia Applied 20 64/64 01d8a6e, 0fd7f0c
haproxy Network Applied 1 1/1 09568fd
libatomic_obs Multi-threading Applied 1 1/1 05812c2
libtomcrypt Cryptography Applied 2 2/2 cefff85
UDPCast Network Applied 2 2/2 20200328
xfstt X Server Applied 1 3/3 91c358e
x264 Multimedia Applied 11 83/83 69771
ffmpeg Multimedia Review 76 382/3821
1Including 27 non automatically patchable issues, manually Ô¨Åxed.
VIII. B AD CODING PRACTICES FOR INLINE ASSEMBLY
In this section, we aim to: 1) seek some sort of regularity be-
hind so many compliance issues, in order to understand while
developers introduce them in the Ô¨Årst place; 2) understand in
the same time why so many compliance issues do not turn
more often into observable bugs; 3) assess the risk of such
bugs to occur in the future.
Common error patterns for inline assembly. We have
identiÔ¨Åed 6 patterns (P1 to P6, see Table II) responsible for
91% of compliance issues (1986/2183) ‚Äì 80% of signiÔ¨Åcant
compliance issues (789/986). In each case, some input or
output declarations are missing, but surprisingly it almost
always concerns the same registers ( %ebx ,%esp ,"cc" ,
MMX or XMM registers) or memory , with similar coding
practices (e.g. no XMM declaration together with compiler
options for deactivating XMM, or no declaration of %ebx
together with surrounding push andpop). Hence, these
patterns are deliberate rather than mere coding errors.
Underlying implicit protections and their limits. It turns
out that each pattern builds on implicit protections (Table II).
We identiÔ¨Åed three main categories: ( 1) (P1-P2-P3) compiler
choices regarding inline assembly (e.g., ‚Äúprotected‚Äù registers,
default clobbers); ( 2) (P4-P5) the apparent protection offered
by putting a single assembly chunk inside a C function (relying
mostly on the limited interprocedural analysis abilities of
compilers); and ( 3) (P6) speciÔ¨Åc compiler options.
Yet, all these reasons are fragile : compiler choices may
change, and actually do, compilers enjoy more and more pow-
erful program analysis engines including very aggressive code
inlining like Link-time optimization (LTO), and refactoring
may affect the compilation context.
We now provide a precise analysis of each error pattern:
P1omitted "cc" keyword. x86 has been once a ‚Äúcc0‚Äù
architecture, i.e., any inline assembly statement implicitly
clobbered"cc" so it was not necessary to declare it as
written. As far as we know, compilers still unofÔ¨Åciallymaintain this special treatment for backward compatibil-
ity. However, some claim ‚Äúthat is ancient technology and
one day it will be gone completely, hopefully‚Äù [18];
P2omitted%ebx register. The Intel ABI states that %ebx
should be treated separately as a special PIC (Position
Independent Code) pointer register. Old version of GCC
(prior to version < 5.0) totally dedicated %ebx to that
role and refrained from binding it to an assembly chunk.
Still, some chunks actually require to use %ebx (e.g.
cmpxchg8b ) and people used tricks to use it anyway
without stating it. It becomes risky because current com-
pilers can now spill and use %ebx as they need;
P3omitted%esp register.%esp is here modiÔ¨Åed but
restored by push andpop. Yet, compilers may decide
to use%esp instead of %ebp to pass addresses of
local variables. In fact, it became the default behavior
since GCC version 4.6. Thus, code mixing local variable
references and push andpop may read the wrong index
of the stack, leading to unexpected issues;
P4omitted "memory" .Compilers‚Äô analysis are often per-
formed perfunction, with conservative assumptions on
the memory impact of called functions, limiting the
ability of the compiler to modify (optimize) the context
of chunks. This is no longer true in case of inlining where
assembly interface issues become more impactful;
P5omitted MMX register. For the same reason as above,
when a chunk is inside a function, it is also protected
by the ABI in use. The Intel ABI speciÔ¨Åes that MMX
registers are caller-saved, hence the compiler must ensure
that their value is restored when function exits. Yet,
inlining may break this pattern since the ABI barrier is
not there anymore once the function code is inlined;
P6omitted XMM register. Using parts of the architecture
out-of-reach of the compiler (the compiler cannot spill
them, typically through adequate command-line options)
is safe but fragile as it is sensitive to future refactoring (af-
fecting the compiler options). Moreover, newer compiler
options or hardware architecture updates can implicitly
reuse registers otherwise deactivated, e.g. XMM registers
reused as subpart of A VX registers.
Breaking patterns. We now seek to assess how fragile (or
not) these patterns are. Replaying known issues [15], [16],
[17] with current compilers shows that patterns P2 to P4 are
(still) unsafe. In addition, we conducted experiments to show
that current compilers do have the technical capacity to break
the patterns. We consider two main threat scenarios:
1245Cloning developers copy the chunk as is to another project
(bad but common development practice [19], [20]);
Inlining projects import the code as a library and compile it
statically with their code (link-time optimization).
We consider for each pattern 5 representative faulty chunks
from the 8 projects. For each chunk, we craft a toy example
aggressively tuned to call the (cloned or imported) chunk
in an optimization-prone context. For instance, as P5 & P6
issues involve SIMD registers, the corresponding chunks are
called within an inner loop while auto-vectorization is enabled
(-O3). Results are reported in column ‚ÄúRobust?‚Äù of Table II.
We actually break 5/6 patterns with code cloning (all but
P1), and 4/6 with code inlining, demonstrating that these
compliance issues should be considered plausible threats.
We identiÔ¨Åed a set of 6 recurring patterns leading to the
majority of compliance issues. All of them build on fragile
assumptions on the compiling chain. Especially, code cloning
and compiler code inlining are serious threats.
IX.DISCUSSION
A. Thr eats to validity
Weavoid bias as much as possible in our benchmark:
1) the benchmark is comprehensiv e: all Debian packages with
C-embedded inline assembly; 2) we mostly work on x86, but
still consider 394 ARM chunks from 3 popular projects. Our
prototype is based on tools already used in signiÔ¨Åcant case
studies [21], [22], [23], [24], including a well tested x86-
to-IR decoder [25]. Also, results ha vebeen crosscheck ed in
several w ays and some of them manually revie wed. So, we
feel conÔ¨Ådent in our main conclusions.
B. Limitations
Architectur e.Our implementation supports the architectures
of the BINSECplatform, currently x86-32 and ARMv7. This is
not a conceptual limitation, as our technique ultimately works
on a generic IR. As soon as a new architecture is available in
BINSEC, we will support it for free.
Float. Wedo not yet support Ô¨Çoat instructions as B INSEC
IR does not. While adding support in the IR is feasible b ut
time-consuming, our technique could also w ork solely with a
partial instruction support reduced to I/O information about
each instruction ‚Äì at the price of some false positiv es.
System instructions. Our formalization considers assembly
chunks as a deterministic way to con vertwell-identiÔ¨Åed inputs
from the C en vironment to outputs. But system instructions
often read or write locations hidden to the C conte xt (system
registers) and will thus appear to be non-deterministic ‚Äì
breaking either the framing or the unicity condition. Extending
our formalization is feasible, butit is useful only if the GNU
syntax is updated. Still, we consider that at most 13% of
assembly chunks used such instructions.C. Micr osoft inline assembly
Microsoft inline assembly (inline MASM) proposed in
Visual Studio [26] does not suffer from the same Ô¨Ça ws as
GNU‚Äôs. Indeed, each assembly instruction is kno wn by the
compiler such that no interface is required , and moreov er
developers can seamlessly write v ariables from C into the
assembly mnemonics. Yet, this solution is actually restricted
to a subset of the i386 instruction set, as the cost in term of
compiler de velopment is signiÔ¨Åcantly more important.
X.RELATEDWORK
Interface compliance. Fehnker et al. [5] tackle inline ass em-
bly compliance checking for ARM (patching and reÔ¨Ånement
are not addressed), b ut in a very limited way. This work
restricts compliance to the framing case (no unicity condition)
and is driven by assembly syntax rather than semantics,
making it less precise than ours ‚Äì for example, a saved-and-
restored re gister will be counted as a framing-write issue.
Moreov er,it does not handle neither memory nor tok en con-
straints (tok ens are assumed to be in registers and to be distinct
from each other). Finally , their implementation is strongly tied
to ARM with strong syntactic assumptions and their prototype
is evaluated only on 12 Ô¨Åles from a single project.
Assembly code lifting and mixed code veriÔ¨Åcation. Two
recent w orks [1], [6] lift GNU inline assembly to semantically
equiv alent C code in order to perform v eriÔ¨Åcation of mixed
codes combining C and inline assembly . Their work is com-
plementary to ours: their lifting assume interface compliance
butin turn they can pro vefunctional correctness of assembly
chunks. V erifying code mixing C and assembly has also been
activ e on Microsoft MASM assembly [27], [28], [29]. Yet,
inline MASM does not rely on interface (Sec. IX-C).
Binary-lev el analysis. While binary-le velsemantic anal ysis is
hard [30], [31], [32], [33], inline assembly chunks offer nice
structural properties [1] allo wing ef Ô¨Åcient and precise analysis.
Wealso beneÔ¨Åt from pre vious engineering efforts on generic
binary lifters [10], [11], [25].
XI. C ONCLUSION
Embedding GNU-lik e inline assembly into higher-le vellan-
guages such as C/C ++ allows higher performance, butat the
price of potential errors due either to the assembly glue or to
undue code optimizations as the compiler blindly trusts the
assembly interf ace. W e propose a no veltechnique to auto-
matically reason about inline assembly interf ace compliance,
based on a clean formalization of the problem. The technique
is implemented in R USTINA,the Ô¨Årst sound tool providing
comprehensiv e automated interface compliance checking as
well as automated patch synthesis and interface reÔ¨Ånements.
1246REFERENCES
[1] F. Recoules, S. Bardin, R. Bonichon, L. Mounier, and M. Potet,
‚ÄúGet rid of inline assembly through veriÔ¨Åcation-oriented lifting,‚Äù in
34th IEEE/ACM International Conference onAutomated Software
Engineering (ASE‚Äô19). IEEE, 2019.
[2] M. Rigger, S. Marr, S. Kell, D. Leopoldseder, and H. M√∂ssenb√∂ck, ‚ÄúAn
analysis of x86-64 inline assembly in c programs,‚Äù in Proceedings of
the14th ACM SIGPLAN/SIGOPS International Conference onVirtual
Execution Environments (VEE‚Äô18). ACM, 2018.
[3] O. Stannard, ‚Äú[llvm-dev] [rfc] checking inline assembly for validity,‚Äù
November 2018. [Online]. Available: http://lists.llvm.org/pipermail/
llvm-dev/2018-November/127968.html
[4] GCC, ‚ÄúExtended asm - assembler instructions with c expression
operands,‚Äù 2020. [Online]. Available: https://gcc.gnu.org/onlinedocs/
gcc/Extended-Asm.html
[5] A. Fehnker, R. Huuck, F. Rauch, and S. Seefried, ‚ÄúSome assembly
required - program analysis of embedded system code,‚Äù in Eighth
IEEE International Working Conference onSource Code Analysis and
Manipulation (SCAM‚Äô08), 2008.
[6] N. Corteggiani, G. Camurati, and A. Francillon, ‚ÄúInception: System-
wide security testing of real-world embedded systems software,‚Äù in 27th
USENIX Security Symposium. USENIX Association, 2018.
[7] F. Recoules, S. Bardin, R. Bonichon, M. Lemerre, L. Mounier, and
M. Potet, ‚ÄúRUSTI NA in a nutshell,‚Äù 2021. [Online]. Available: https:
//binsec.github.io/new/publication/1970/01/01/nutshell-icse-21.html
[8] G. A. Kildall, ‚ÄúA uniÔ¨Åed approach to global program optimization,‚Äù in
Proceedings ofthe1stAnnual ACM SIGACT-SIGPLAN Symposium
onPrinciples ofProgramming Languages, POPL‚Äô73. ACM, 1973.
[9] D. McCall, ‚ÄúUse of input/output operands in __asm__ templates
not fully documented,‚Äù 2007. [Online]. Available: https://gcc.gnu.org/
bugzilla/show_bug.cgi?id=30527
[10] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz, ‚ÄúBAP: A Binary
Analysis Platform,‚Äù in 23rd International Conference onComputer
Aided VeriÔ¨Åcation (CA V 2011). Springer, 2011.
[11] S. Bardin, P. Herrmann, J. Leroux, O. Ly, R. Tabary, and A. Vin-
cent, ‚ÄúThe BINCOA framework for binary code analysis,‚Äù in 23rd
International Conference onComputer Aided VeriÔ¨Åcation (CA V‚Äô11).
Springer, 2011.
[12] A. Djoudi and S. Bardin, ‚ÄúBinsec: Binary code analysis with low-level
regions,‚Äù in Tools andAlgorithms fortheConstruction andAnalysis of
Systems: 21st International Conference (TACAS‚Äô15). Springer, 2015.
[13] R. David, S. Bardin, T. D. Ta, L. Mounier, J. Feist, M. Potet, and J. Mar-
ion, ‚ÄúBINSEC/SE: A dynamic symbolic execution toolkit for binary-
level analysis,‚Äù in IEEE 23rd International Conference onSoftware
Analysis, Evolution, andReengineering (SANER‚Äô16). IEEE, 2016.
[14] F. Kirchner, N. Kosmatov, V . Prevosto, J. Signoles, and B. Yakobowski,
‚ÄúFrama-c: A software analysis perspective,‚Äù Formal Asp. Comput.,
vol. 27, no. 3, 2015.
[15] I. Maidanski, ‚ÄúFix compare_double_and_swap_double for
clang/x86 in pic mode,‚Äù September 2012. [On-
line]. Available: https://github.com/ivmai/libatomic_ops/commit/
64d81cd475b07c8a01b91a3be25e20eeca2d27ec
[16] ‚Äî‚Äî, ‚ÄúFix ao_compare_double_and_swap_double_full for gcc/x86
(pic mode),‚Äù Mars 2012. [Online]. Available: https://github.com/ivmai/
libatomic_ops/commit/30cea1b9ea06c4c25cc219e1197dfac8dfa52083
[17] P. Pelletier, ‚ÄúAdd "memory" as a clobber for bswap inline assembly,‚Äù
September 2011. [Online]. Available: https://github.com/libtom/
libtomcrypt/commit/cefff85550786ec869b39c0cb4a5904e88c84319
[18] S. Boessenkool, ‚ÄúBug 68095 ‚Äì comment 4,‚Äù 2015. [Online]. Available:
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68095#c4
[19] C. Parnin and C. Treude, ‚ÄúMeasuring api documentation on the web,‚Äù in
Proceedings ofthe2ndInternational Workshop onWeb 2.0forSoftware
Engineering. ACM, 2011.
[20] D. Yang, A. Hussain, and C. V . Lopes, ‚ÄúFrom query to usable code:
An analysis of stack overÔ¨Çow code snippets,‚Äù in Proceedings ofthe
13th International Conference onMining Software Repositories. ACM,
2016.
[21] S. Bardin, R. David, and J. Marion, ‚ÄúBackward-bounded
DSE: targeting infeasibility questions on obfuscated codes,‚Äù in
International Symposium on Security & Privacy (S&P‚Äô17). IEEE,
2017.[22] R. David, S. Bardin, J. Feist, L. Mounier, M. Potet, T. D. Ta, and
J. Marion, ‚ÄúSpeciÔ¨Åcation of concretization and symbolization poli-
cies in symbolic execution,‚Äù in Proceedings ofthe25th International
Symposium onSoftware Testing andAnalysis (ISSTA‚Äô16). ACM, 2016.
[23] L. Daniel, S. Bardin, and T. Rezk, ‚ÄúBinsec/rel: EfÔ¨Åcient relational
symbolic execution for constant-time at binary-level,‚Äù in International
Symposium onSecurity andPrivacy (SP‚Äô20). IEEE, 2020.
[24] J. Feist, L. Mounier, S. Bardin, R. David, and M. Potet, ‚ÄúFinding
the needle in the heap: combining static analysis and dynamic sym-
bolic execution to trigger use-after-free,‚Äù in Proceedings ofthe6th
Workshop onSoftware Security, Protection, andReverse Engineering,
SSPREW@ACSAC 2016. ACM, 2016.
[25] S. Kim, M. Faerevaag, M. Jung, S. Jung, D. Oh, J. Lee, and
S. K. Cha, ‚ÄúTesting intermediate representations for binary analysis,‚Äù
inProceedings ofthe32nd IEEE/ACM International Conference on
Automated Software Engineering (ASE‚Äô17). IEEE, 2017.
[26] Microsoft, ‚ÄúInline assembler,‚Äù August 2018. [On-
line]. Available: https://docs.microsoft.com/en-us/cpp/assembler/inline/
inline-assembler?view=vs-2019
[27] S. Maus, M. Moskal, and W. Schulte, ‚ÄúVx86: x86 assembler simulated
in c powered by automated theorem proving,‚Äù in 12th International
Conference onAlgebraic Methodology and Software Technology
(AMAST‚Äô08). Springer, 2008.
[28] S. Maus, ‚ÄúVeriÔ¨Åcation of hypervisor subroutines written in assembler,‚Äù
Ph.D. dissertation, University of Freiburg, Germany, 2011.
[29] S. Schmaltz and A. Shadrin, ‚ÄúIntegrated semantics of intermediate-
language c and macro-assembler for pervasive formal veriÔ¨Åcation of
operating systems and hypervisors from verisoftxt,‚Äù in 4thInternational
Conference on VeriÔ¨Åed Software: Theories, Tools, Experiments
(VSTTE‚Äô12). Springer, 2012.
[30] G. Balakrishnan and T. W. Reps, ‚ÄúWYSINWYX: what you see is not
what you execute,‚Äù ACM Trans. Program. Lang. Syst., vol. 32, no. 6,
2010.
[31] A. Djoudi, S. Bardin, and √â. Goubault, ‚ÄúRecovering high-level con-
ditions from binary programs,‚Äù in FM 2016: Formal Methods -21st
International Symposium. Springer, 2016.
[32] S. Bardin, P. Herrmann, and F. V√©drine, ‚ÄúReÔ¨Ånement-based CFG
reconstruction from unstructured programs,‚Äù in 12th International
Conference onVeriÔ¨Åcation, Model Checking, andAbstract Interpretation
(VMCAI‚Äô11). Springer, 2011.
[33] J. Kinder and D. Kravchenko, ‚ÄúAlternating Control Flow Reconstruc-
tion,‚Äù in 13th International Conference onVeriÔ¨Åcation, Model Checking,
andAbstract Interpretation (VMCAI‚Äô12). Springer, 2012.
1247