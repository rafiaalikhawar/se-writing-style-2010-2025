On Indirectly Dependent Documentation in the
Context of Code Evolution: A Study
Devika Sondhi, Avyakt Gupta, Salil Purandare, Ankit Rana, Deepanshu Kaushal and Rahul Purandare
IIIT-Delhi
New Delhi, India
fdevikas, avyakt17285, salil17093, ankit18381, deepanshu18388, purandareg@iiitd.ac.in
Abstract ‚ÄîA software system evolves over time due to factors
such as bug-Ô¨Åxes, enhancements, optimizations and deprecation.
As entities interact in a software repository, the alterations
made at one point may require the changes to be reÔ¨Çected
at various other points to maintain consistency. However, of-
ten less attention is given to making appropriate changes to
the documentation associated with the functions. Inconsistent
documentation is undesirable, since documentation serves as a
useful source of information about the functionality. This paper
presents a study on the prevalence of function documentations
that are indirectly or implicitly dependent on entities other than
the associated function. We observe a substantial presence of
such documentations, with 62% of the studied Javadoc comments
being dependent on other entities, as studied in 11 open-source
repositories implemented in Java. We comprehensively analyze
the nature of documentation updates made in 1288 commit logs
and study patterns to reason about the cause of dependency in
the documentation. Our Ô¨Åndings from the observed patterns may
be applied to suggest documentations that should be updated on
making a change in the repository.
Index Terms‚Äîcode evolution, GitHub repositories, documen-
tation, commits
I. I NTRODUCTION
A software system undergoes evolution over time. Changes
to software in this evolution process may be attributed to
factors such as enhancements, bug Ô¨Åxes, refactoring, and
deprecation of entities. ModiÔ¨Åcations made at one point in the
source code often require alterations at various other points
to ensure the expected behavior. While developers use test-
suites to verify that the changes to the code do not break any
functionality, in many cases, less attention is given to making
appropriate changes to the documentation associated with the
functions. Such inconsistencies are undesirable for developers
as well as users. A developer needs to obtain knowledge about
code components for performing enhancements and other
code-maintenance tasks. Documentation serves as a prominent
source for acquiring this knowledge [1], [2]. Additionally,
from a user‚Äôs perspective, reading the documentation is prefer-
able to deducing functionality from source code.
There have been research efforts to highlight inconsistencies
between different code fragments or between code and its
documentation (or comment) [3]‚Äì[6]. Past work has focused
on inconsistencies with function documentation when the di-
rectly associated function is modiÔ¨Åed. However, the documen-
tation may be dependent on several other entities. Consider
two snippets from a commit made in the Spring-Framework
Code change resulting in a documentation update in
another method
Fig. 1: Snippets from a commit log showing a code change
that triggers a documentation update in another Ô¨Åle.
project, as shown in Fig. 1. The commit is sourced from an
issue, SPR-16130 [7], which discusses altering the default
access control to make a client request to a server. The Ô¨Åeld
allowCredentials is by default set to enabled (or true),
allowing any site to make an XHR request with credentials.
The developers realize that this is not a secure conÔ¨Åguration
and resolve the issue by setting allowCredentials to dis-
abled (or false) by default. Fig.1 demonstrates how this code
change in one Ô¨Åle induces a critical documentation update for
theallowCredentials method in another Ô¨Åle.
As a project evolves, there may be several changes such as
the one discussed in this example. A developer may neglect
to update the documentation, especially when it is not directly
linked to the entity to which the changes have been made.
In this paper, we study method documentation and commits
logs of 11 open-source projects to observe trends on the
prevalence of function documentations that are indirectly or
14982021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)
1558-1225/21/$31.00 ¬©2021 IEEE
DOI 10.1109/ICSE43902.2021.00134
implicitly dependent on entities other than the function with
which they are associated. We Ô¨Ånd a substantial presence of
such documentations. We also observe that developers are
likely to leave the documentation inconsistent for a long period
of time in the process of making updates to the project.
Motivated by the extent and relevance of the problem of
inconsistent documentation caused by indirect dependencies,
we build a taxonomy of the types of documentation updates
that indicate dependencies on other changes. We observe that
the developers primarily enhance or Ô¨Åx the core description
of the functionality. We present patterns that indicate potential
relations between the source of an update, such as a code-
change, and the affected documentation, in order to infer the
cause of a dependency. We further discuss the implications of
these patterns for developers from the perspective of building
a warning system which indicates potential inconsistencies
introduced on making updates.
To summarize, this work makes the following contributions:
A study on the prevalence and the nature of indirect
dependencies in function documentations.
A comprehensive analysis of the nature of documentation
updates over 1288 commit logs extracted from 11 open-
source repositories. The analysis covers the role of devel-
opers in maintaining consistent documentation and builds
a taxonomy of the nature of documentation updates.
Patterns that induce indirect dependencies in documen-
tations. We discuss the implications of these patterns in
building applications to reduce documentation inconsis-
tencies in the context of code evolution.
A publicly available annotated dataset of commit logs
and methods with the above-mentioned analysis, to ease
possible future extensions.
II. R ELATED WORK
Code-comment inconsistency. Documentation-writing has
traditionally been done manually. Recent research has given
due attention to automated documentation generation [8],
[9]. However, the aspects of their quality and maintenance
are equally essential [2], [10]‚Äì[14]. Aghajani et al. study
documentation-related issues reported on different platforms
[10]. They build a taxonomy of such issues to suggest action-
able points. Our study complements these Ô¨Åndings.
Focusing on the correctness of the documentation, code-
comment inconsistencies have been studied in the past and
tools have been developed to detect such inconsistencies.
Wen et al. study the change-history of GitHub projects to
analyze how code and comment co-evolve [4]. They further
build a taxonomy of comment-related changes observed on the
analyzed commits. @tCOMMENT is a tool for testing Javadoc
comments that highlights inconsistencies related to method
properties speciÔ¨Åcally about null values and related exceptions
[15]. iComment is another tool that detects bad comments at
a function level [6]. The tool uses a template-based approach
by combining NLP, machine learning, and program analysis
to highlight gaps in the context of locking protocols. All these
studies and techniques are scoped to method-level granularityto analyze the inconsistencies between the method‚Äôs code
and the directly associated comments. We take a step further
to analyze how code-level or external changes could impact
Javadoc comments at various other points.
Several refactoring tools have been proposed to minimize
code-comment inconsistencies arising from refactoring [5],
[16], [17]. Eclipse‚Äôs Java development tools support automated
comment refactoring [17]. While Eclipse‚Äôs refactoring func-
tionality focuses on lexical matches for renaming identiÔ¨Åers,
Ratol et al. propose a lexical and semantic rules-based algo-
rithm to detect fragile comments in the context of performing
refactoring-based changes to identiÔ¨Åers in the code [5].
Risking changes in code evolution. Due to software
delivery pressures, developers may be rushed into completing
certain tasks, compromising the overall software quality. This
phenomenon is referred to as the technical debt [18]. Changes
occurring in the process of code evolution involve several
risks [19], [20]. Shihab et al. study various factors and their
effectiveness in detecting risky changes [21]. One of their
Ô¨Åndings suggests that developers are unreliable in identifying
the risks when changes are made that require related changes.
As risky changes incur debt in terms of more reviewing and
testing, it becomes essential to identify these risks.
Technical debt may also be intentionally introduced by
developers, referred to as self-admitted technical debt (SATD)
[22], [23]. This may involve introducing workarounds or sub-
optimal code to satisfy the basic requirement, or adding notes
for future releases. A study on code-comments suggests that
SATD may persist due to the code-comment inconsistent
changes after releases [22]. Hence, efforts to warn developers
about introducing SATD become essential. Our study is an
effort in this direction, by highlighting patterns that can
potentially aid in identifying the targets where the changes
are needed when a source is updated.
Information Foraging and Program Navigation. Past
works discuss programmer-navigation models on code, as
learnt from the programmer‚Äôs behavior to recommend naviga-
tion actions [20], [24]. Lawrance et al. propose a model that
uses a source code‚Äôs topology and its ‚Äòscent‚Äô to predict that the
programmer will visit a source code given a bug report [24].
Relying on the programmer‚Äôs behavior can make the approach
subjective, as is stated in one of these papers. Instead, our work
focuses on documentation updates and primarily contributes a
taxonomy of the nature of documentation-updates made in the
code evolution process. The application derived from our work
is a recommendation system for which we suggest objective
patterns to recommend points of documentation changes.
Change patterns in the context of code evolution.
Past studies obtained code evolution patterns to harness for
applications such as patch generation [25], [26], language
migration [27], code recommendation [28], change guidance
[3], [29], [30], and code completion [31]. Nguyen et al.
propose a technique to detect semantic code change patterns
using their tool, CPATMINER [32]. CPATMINER builds a
change-graph from the original and the altered code functions,
each represented as a program dependency graph (PDG).
1499Listing 1: Sample of a Javadoc comment for a method.
/**
*Replaces the existing container under test with
*a new container.
*This is useful when a single test method needs
*to create multiple containers while retaining
*the ability to use { @link #expectContents()
*expectContents()} and other related methods.
*
*@param newValue the new container instance
*@return the new container instance
*@throws IllegalArgumentException if the input
*is not a valid encoded container
*@since 1.0
*/
public Container resetContainer(Container newValue)
{ //..body }
The change-graph connects the two PDGs by drawing edges
between the unchanged nodes before and after the change.
This change-graph is analyzed to mine change-patterns. To
infer repetitiveness in change-patterns, CPATMINER checks
if the graphs are isomorphic. Mehta et al. propose a correlated
change analysis technique that applies machine learning on Ô¨Åle
commits to mine change-rules based on Ô¨Åles that frequently
change together [30]. These rules are used to suggest Ô¨Åles that
should be altered once a change is made in another correlated
Ô¨Åle. Their tool supports changes at Ô¨Åle-level granularity for
conÔ¨Åguration Ô¨Åles. While these techniques focus on learning
the changes made to the code and conÔ¨Ågurations, our study
focuses on code evolution from the perspective of inferring
the potential causes and patterns that result in inconsistent
documentations due to changes made in other related entities.
III. E XPERIMENT DESIGN
The objective of this study is to analyze the nature of in-
consistencies in documentations, as well as their causes, in the
context of code evolution. We analyze method documentation
and commit logs in open-source projects on GitHub that are
implemented in Java. Java has been ranked as one of the Ô¨Åve
most popular languages on GitHub over the last Ô¨Åve years
[33]. We scope our study to analyzing documentation updates
associated with methods, as method headers, in the code Ô¨Åle.
Listing 1 shows a Javadoc comment for a method, which is
the typical documentation format for code Ô¨Åles implemented
in Java.
A. Research Questions
One expects a documentation to describe the entity with
which it is directly associated. However, dependency of doc-
umentation on other entities would require maintaining the
consistency of the documentation with other changes within
or external to the project. We designed the Ô¨Årst research
question to study the prevalence of dependencies between a
method‚Äôs documentation and indirectly associated source code
and other entities. These other entities include documentations
associated with other methods, classes, interfaces, Ô¨Åelds, or
external sources, such as URL references to web pages. This
brings us to the Ô¨Årst RQ.TABLE I: Dataset analyzed in the study.
Repository Star-
Count*# Commit logs
extracted# Commit logs
analyzed
elasticsearch 50.2k 12742 344
spring-boot 49.5k 6507 128
RxJava 43.2k 376 64
spring-framework 38.5k 3854 510
guava 38.3k 545 72
retroÔ¨Åt 36.2k 171 2
dubbo 33.1k 1823 93
MPAndroidChart 31.3k 70 2
glide 29.6k 257 24
netty 24.3k 1063 47
gson 18.3k 57 2
Total 27465 1288
* as of May 2020
RQ1: Are documentations written independently?
We further study whether the maintenance of documentation
over time matters to the developers and users of the library
project. Hence, for the second RQ, we study discussions
over issue reports and pull requests to observe whether
documentation-related inconsistencies are highlighted.
RQ2: How often is the dependence of documentation high-
lighted through user and developer discussions?
Inconsistent documentations in a library can cause inconve-
nience to the developers and users of the library with respect to
program comprehension. To address the third RQ, we study
how often developers miss updating dependent documenta-
tions while making alterations to the repository.
RQ3: How often is the consistency of dependent documen-
tation with code maintained as the repository evolves?
After studying the existence and importance of the problem
of indirectly dependent documentation in the context of code
evolution, we carry out a deeper qualitative analysis of the
libraries through RQ 4 and RQ 5. This analysis reasons about
the patterns under which a documentation update is needed
and builds a taxonomy of the nature of documentation updates
made as a project evolves.
RQ4: What is the nature of updates made to documentation
to maintain consistency?
RQ5: What factors inÔ¨Çuence a documentation to be updated
with the evolution of repository?
B. Data Collection
We selected 11 top-starred repositories of libraries from
GitHub that are implemented in Java and documented in
English. These repositories are listed in Table I.
a) Methods and Commits Extraction: From the master
branch of each repository, our script randomly chose source
Ô¨Åles and used JavaParser [34] to extract 50 methods and their
1500Javadoc comments. We obtained 550 methods from 11 projects
to study RQ1. To study the remaining RQs, over each of the 11
repositories, we used the Git API to extract commit logs from
all branches spanning 2 years from June 15, 2018 to June 15,
2020. We extracted all the Ô¨Åles changed in a commit. GitHub
does not follow a mainline integration model; developers can
create branches for various purposes and merge the changes
into the stable branch once they are conÔ¨Ådent about it [35].
We only consider the non-merge commits to avoid analyzing
potentially duplicate updates. This resulted in the extraction of
27,465 commit logs (Table I). These commit logs were used
to study the changes made to the repository and their effect
on the documentations.
C. Analysis Procedure
We used a semi-automated approach to analyze the methods
and the commit logs, where Ô¨Åve of the authors performed the
task of annotating the observations.
1) RQ1: On the independence of documentation: We man-
ually studied the 550 methods and their Javadoc comments
extracted from 11 libraries to determine whether the documen-
tation is only inÔ¨Çuenced by the associated method‚Äôs source
code or whether there exists another entity inÔ¨Çuencing the
content of the documentation. The latter is a case of ‚Äòdepen-
dent‚Äô documentation. In order to characterize documentation
dependencies, we conducted a preliminary study on a set of
100 randomly selected methods from the obtained dataset of
methods. We checked whether each reference made by the
target documentation could be mapped to the method source
with which it is associated. In cases where we could not,
we identiÔ¨Åed the content mapped to other entities, which we
refer to as dependencies. In the process, we identiÔ¨Åed two key
features that indicate a dependency. Accordingly, the annotator
labelled a method documentation as ‚Äòdependent‚Äô if it satisÔ¨Åes
at least one of the following criteria.
The documentation has references to other entities that
are object types, methods, Ô¨Åelds, Ô¨Åle paths, or URLs.
The description of the documentation explains more than
what the associated method directly implements. This
description is either sourced from the invoked methods
or other external factors.
2) RQ2-5: On the importance of maintaining consistency
and understanding the nature of and the reasons behind
inconsistencies in the context of implicit dependencies: As
the focus of this study is the documentation associated with a
method, we shortlisted commit logs from the 27,465 extracted
logs which were more likely to highlight the indirect depen-
dencies of the documentation. Consider a scenario where both
a method‚Äôs source code and its documentation are updated; it is
likely that the documentation update is induced by the change
made to the associated method. However, in cases where only
the documentation of a method is being updated, there are
high chances of it being induced by changes made elsewhere.
Further, these changes may be sourced from either the same
commit in which the documentation is updated or from one
of the previous commits. Based on this idea, we shortlistedcommits that contained at least one method for which only the
documentation had been updated, that is, without any change
made to the corresponding method‚Äôs implementation (Ô¨Åltration
details in Section III-C2a). The annotators manually analyzed
these commits, as described later in this section.
a) Commit Filtration: To Ô¨Ålter out the unwanted commit
logs, we followed a two-stage process. For a given list of
commit IDs and the corresponding list of altered Ô¨Åles (de-
scribed in Section III-B0a), the Ô¨Årst stage uses the Git API
to get the parent commit ID of each commit. We used the
git diff command to compute the lines changed in a Ô¨Åle
between the two commits, commitid1 andcommitid2 . These
changes are in the form of insertion and deletion of lines. A
script stores all the changed lines in JSON format, with keys
ascommitid1_commitid2_filename and the values being
the arrays of line numbers of insertions and deletions.
To obtain methods that have been altered in a commit, the
second stage uses JavaParser alongside Git API to process the
JSON Ô¨Åle. From each key, our script parses the two commit
IDs and Ô¨Ålename. It then extracts the two versions of the Ô¨Åle
corresponding to the two commits. On each Ô¨Åle version, we
used JavaParser to visit all top-level class‚Äôs methods and get
the start and end lines of the code and its documentation. A
script compares these lines with the lines inserted or deleted
to extract the list of methods changed between two commits
for a given Ô¨Åle. The script shortlists commits that contain
at least one method in which only the documentation was
changed. Note that there may still exist other methods having
code-related changes in such commits. Applying this Ô¨Åltration
process, we shortlisted 1,288 commits (Table I).
b) Features Captured: We perform a qualitative analysis
on the shortlisted commits to capture various features associ-
ated with a commit log. As the study focuses on analyzing
dependencies in documentation associated with methods, we
use the following related terms throughout the paper.
Asource is an entity, such as changed code or a referred
URL, which inÔ¨Çuences the documentation of an indirectly
related method.
Atarget is a method whose documentation has been affected
by an indirectly related entity (the source).
Each annotator was provided with a JSON Ô¨Åle that con-
tained shortlisted commit IDs and corresponding lists of meth-
ods for which only documentation was modiÔ¨Åed. These meth-
ods were used to identify the sources and targets. Since we
want to capture the maintenance of documentation consistency
in the context of project evolution, the annotators analyzed
only the differential part of the documentations in the given
commit to log the observations. A documentation was labelled
as ‚Äòdependent‚Äô as per the two criteria discussed in Section
III-C1. Additionally, if the commit difference suggests that the
documentation change occurred due to a change made else-
where, such documentation was also labelled as ‚Äòdependent‚Äô.
The method associated with this documentation was labelled
as a target. Note that not all shortlisted commit logs necessarily
1501indicate an indirect documentation dependency. Although they
may appear in our shortlist, documentation updates such as
grammatical Ô¨Åxes or formatting changes are not dependencies.
Further, documentation updates may be directly sourced from
previous changes made to the associated method. As we scope
our study to indirectly induced documentation inconsistencies,
we ignored such direct updates during the analysis.
RQ2: On documentation being discussed: We studied
whether the maintenance of documentation matters to the
developers and the users of the libraries. The annotators
captured whether the commit log under analysis is linked to
any pull request or issue report such that the documentation
is the main topic of discussion over the thread.
RQ3: On maintaining the documentation consistency as the
repository evolves: We studied the prevalence of cases in
which a change is made to the project while the indirectly
dependent documentations are overlooked and changed much
later. Hence, an annotator captured whether a documentation
update is sourced from a change made in the same commit or
in a previous commit. The commit-change description and the
discussion thread on the related pull request or issue report
were used to obtain hints on the cause of a documentation
update. This aligns well with the most frequently highlighted
theme of ‚Äòchange description‚Äô by developers, as listed by Ram
et al. in their study on what constitutes a good code change
from the perspective of change-reviewability and change-
comprehension [36]. If the annotator did not Ô¨Ånd the source
of documentation update in the same commit, he/she searched
the linked discussion thread for potential references to previous
commits and studied the commit history of the method to Ô¨Ånd
the source of update. Further, on obtaining the previous com-
mit, the annotator also noted the time between the introduction
and the Ô¨Åxing of the documentation‚Äôs inconsistency.
RQ4: Nature of documentation updates to maintain consis-
tency: To understand how documentation is inÔ¨Çuenced by
various indirect changes, we studied the nature of updates
made to the documentations. As observed in our dataset,
documentation (a Javadoc comment) typically consists of a
description of the method‚Äôs functionality, parameters, returned
output, and extra information for detailed understanding. We
identiÔ¨Åed 6 main categories of the nature of documentation
updates described in Table II. We further identiÔ¨Åed 8 sub-
categories for ‚Äòdescription update‚Äô (Table II).
All the categories have been deÔ¨Åned to be exclusive of
each other, as also validated over our dataset used for the
analysis. This implies that every single update made to a
documentation gets categorized uniquely. However, it may still
be possible for different parts of a documentation to have
changes of different sub-nature, in the ‚Äòdescription update‚Äô
category. A typical commit log targets a single objective.
Hence, every dependent documentation update was assigned
with a single main category. Often, one type of documentation
update triggered by a code change can result in other types
of updates elsewhere. For instance, consider a case where the
introduction of a new method leads to the deprecation of an
older method. As a result, the developer adds a deprecationnote to the older method. This leads to the replacement of
references made by the documentation of other methods to
the older method (now deprecated) with the new method.
Hence, one would observe two categories of documentation
updates, ‚Äòmark deprecated‚Äô and ‚Äòdescription update‚Äô. However,
we know that the root type of the documentation update in
this case is ‚Äòmark deprecated‚Äô, despite the presence of other
updates. Therefore, for clarity, we captured only the root
update category for a commit log.
In case of a ‚Äòdescription update‚Äô, it may be possible to
assign multiple sub-categories to the documentation, owing to
updates in multiple sections. For instance, if an update is made
to the description of the functionality, and additionally, extra
references are introduced for further clariÔ¨Åcation, then both
sub-categories, ‚Äòbehavioral description‚Äô and ‚Äòextra suggestions
description‚Äô, shall be noted. An annotator assigned appropriate
category and sub-categories to the updates in the target‚Äôs
documentation in the commit.
RQ5: Relations that trigger documentation updates: To un-
derstand the scenarios for which documentation is more likely
to be updated, we studied the relations between the source
and the target. We obtained patterns that can be harnessed to
build applications. The annotators searched for the following
relations between the source and the target and logged patterns
of these relations for each commit log.
i. Referential relation : We captured whether the source
or the target makes direct references to each other in their
respective documentations. This relation indicates that if either
of these entities references the other, then a change in one will
potentially require updating the other‚Äôs documentation. Hence,
a signiÔ¨Åcant prevalence of such a pattern can be useful in
automating the process of shortlisting targets, given a source.
While analyzing a commit, for the extracted source and target
pairs, the annotator logged one of the following observations:
a) target‚Äôs documentation references the source, b) source‚Äôs
documentation references the target, c) both, d) none.
ii. Call-graph relation : A call-graph captures the control
Ô¨Çow relation between the methods calls made in a program.
We captured this relation between the source and the target
based on the idea that such relations would be reÔ¨Çected in the
program‚Äôs behavior, and hence are likely to be documented
by the developer. Therefore, in the context of alterations
to the code, the documentation may also require updates.
The annotator logged one of the following observations per
commit: a) target in the call-graph of source, b) source in the
call-graph of target, c) none. These relations were captured on
the call-graph generated using the Soot Framework [50].
iii. Inheritance relation : We investigated whether it is
common for the respective classes of the source and the
target to share a relationship based on inheritance. Certain
properties may get propagated by this relation, thereby creating
a dependency between the source and the target. Hence, for
each commit, the annotator captured the following observation
on the classes to which the source and the target belong: a)
target‚Äôs class inherits from source‚Äôs class, b) source‚Äôs class
inherits from target‚Äôs class, c) classes of source and target
1502TABLE II: Nature of documentation updates.
Category Description Example of a documentation update
1. Refactoring : Structural changes made to the references
in the documentation, which do not change the descrip-
tion of the functions or semantics.Elasticsearch commit 1a5e72e [37]: ‚Äú...When created through #with-
LocalReduction(SearchRequest, String[], String, long, boolean) , this
method returns.. ‚Äù replaced by ‚Äú...When created through #crossClus-
terSearch(SearchRequest, String[], String, long, boolean) , this method
returns.. ‚Äù due to the renaming of the referenced method.
2. Description update : Semantic update to the core de-
scription of the method.
2a.Behavioral description : Updates in the function-
ality‚Äôs intent description without making any direct
references to entities. This may occur due to change
in the source‚Äôs behavior without directly referencing it.MPAndroidChart commit fcc5af7 [38]: ‚ÄúCallbacks when the chart is scaled
/ zoomed via pinch zoom gesture. ‚Äù replaced by ‚ÄúCallbacks when the chart
is scaled / zoomed via pinch zoom / double-tap gesture . ‚Äùas the support for
double-tap zoom is added in another class that invokes the target method.
2b.Referential description : Updates in the references
to entities for enhancing the functionality‚Äôs intent de-
scription. These references may also be to class com-
ment to get further insights.Glide commit ed20643 [39]: ‚Äú..Previous calls to #apply( RequestOptions ).. ‚Äù
replaced by ‚Äú..Previous calls to #apply( BaseRequestOptions ).. ‚Äùwhere
BaseRequestOptions class is added as the parent of RequestOptions.
2c.Extra suggestions description : References to other
entities for additional details.Spring-framework commit 859923b [40]: Adding ‚Äú@see #getBeanType() ‚Äù
to the documentation of getBeanName() , as extra information.
2d.Parameter description : Updates in the description
of method parameters and constraints induced on them
by other entities.Elasticsearch commit 3f2a241 [41]: Addition of ‚Äú@param requestId see
ResponseHandlers#add(ResponseContext) for details‚Äù to the parameter
description, on addition of ResponseHandlers class.
2e.Return value description : Updates in the descrip-
tion of the return-values and their constraints.Guava commit 21cfbea [42]: ClariÔ¨Åcation added on the return type by
referencing SortedMap in the documentation ‚Äúthe returned map itself is
not necessarily a SortedMap‚Äù .
2f.Example description : Updating examples to de-
scribe the method usage or functionality, which may
also involve conÔ¨Åguring other entities.Guava commit 3dfee64 [43] : ‚ÄúExample: Files.Ô¨ÅleTraverser(). breadth-
First(‚Äú/‚Äù) may return Ô¨Åles ... [‚Äú/‚Äù, ‚Äú/etc‚Äù, ...‚Äù replaced by ‚ÄúExample:
Files.Ô¨ÅleTraverser(). depthFirstPreOrder(new File(‚Äú/‚Äù)) may return Ô¨Åles ...
[‚Äú/‚Äù, ‚Äú/etc‚Äù, ‚Äú/etc/conÔ¨Åg.txt‚Äù, ...‚Äù to include a more common example.
2g.Alternative reference description : Updating the
documentation with a reference to another method that
can serve as an alternate to the target method under
certain speciÔ¨Åc requirements.RxJava commit 6ba932c [44]: Documentation of target updated with an
alternative reference- ‚ÄúSimilar to Objects.requireNonNull but composes
the error message.. ‚Äù .
2h.TODO notes description : Updating a note left in
the documentation for future action having direct/indi-
rect references to other entities.Guava commit af3ee1c [45]: Documentation is added with a future ac-
tion due to a code-change made elsewhere- ‚ÄúTODO(user): remove the
addNode() calls, that‚Äôs now contractually guaranteed‚Äù .
3. Mark deprecated : Deprecation of the target method,
leading to referencing an alternative in the documenta-
tion.Spring-boot commit a63ab46 [46]: Deprecation note added to an existing
method when a new method is introduced- ‚Äú@deprecated in favor of
#setRSocketServerCustomizers(Collection) as of 2.2.7‚Äù
4. Exception type addition/update : Declaring or updat-
ing exception types in the documentation that may get
thrown by the target method.Spring-framework commit 71f3498 [47]: Exception was declared in the
Javadoc of a method as one of the callee method‚Äôs code was updated-
‚Äú@throws DecodingException if the metadata cannot be decoded‚Äù .
5. Referential typo Ô¨Åx : Typo Ô¨Åxes in the documentation
made in references to the source entities.Netty commit 8f01259 [48]: Incorrect reference to a method
in the documentation Ô¨Åxed from setmaxHeaderListSize(long) to
setMax HeaderListSize(long) .
6. Version update : Updating the documentation in the
context of certain platform or version dependencies.Guava commit 7fdf1a6 [49]: The documentation is updated
with a special instruction for Java 9 users- ‚ÄúJava 9 users: use
java.util.Objects.requireNonNullElse(Ô¨Årst, second) instead‚Äù .
share a common parent, d) source and target belong to same
class, e) none.
iv. Interface relation : As interfaces provide abstractions
that the implementing classes must adhere to, we studied the
prevalence of such a relation between the source and the
target‚Äôs class or interface in an attempt to infer the cause
of the dependency. For every commit, the annotator noted
the corresponding class or interface of the target and sourceand logged one of the following observations: a) target‚Äôs
class implements from source‚Äôs interface, b) source‚Äôs class
implements from target‚Äôs interface, c) classes/interfaces of
source and target implement/extend a common interface, d)
source and target belong to the same interface, e) none.
c) Inter-rater agreement: An agreement mechanism was
followed batch-wise in the process of analyzing the data.
Initially, each of the Ô¨Åve authors annotated 10 commit logs.
1503TABLE III: Free Marginal Kappa scores to evaluate the inter-
rater agreement.
Feature Analyzed Kappa
Score
Documentation has indirect dependency 0.88
Documentation update triggered by change made in the same
or previous commit1
If the update is sourced from a discussion on the documentation 0.89
Update induced from the change made in same or different Ô¨Åle 0.76
Nature of documentation update 0.84
Call-graph relation-type 0.74
Reference relation-type in the documentation 0.85
Inheritance relation-type 0.93
Interface relation-type 0.93
Then a group discussion was held among the authors to discuss
all 50 logs, to come to an agreement and check consistency
in the understanding. A second batch of 10 logs, analyzed
by each annotator, was validated by another annotator. To
capture the inter-rater agreement among the annotators, 10
randomly picked commit logs from the dataset were provided
to be independently analyzed by each of them. We computed
the free-marginal kappa agreement scores (Table III) [51] on
these annotations [52]. A kappa score of 0.88, which indicates
‚Äúalmost perfect agreement‚Äù [51], was obtained for the classi-
Ô¨Åcation of documentation updates as indirectly dependent or
independent. On obtaining a thorough understanding through
this exercise, all annotators continued to annotate a subset
of commit logs and marked their conÔ¨Ådence levels as high,
medium, or low, to associate with each annotation. All logs
marked as ‚Äòlow‚Äô were resolved in a group discussion and the
logs marked as ‚Äòmedium‚Äô were validated by another annotator.
IV. F INDINGS
With the design and experiments to explore the mentioned
RQs, we discuss the Ô¨Åndings in this section. We have made
all the Ô¨Åndings of the study, along with the dataset and the
scripts used to prepare it, available1.
A.RQ1: Are documentations written independently?
For 341 of the 550 analyzed Javadoc comments of methods,
we observed the prevalence of dependencies on indirectly
associated source code and other entities. Considering the two
criteria mentioned in Section III-C1 to mark a documenta-
tion as dependent, for 321 cases, the Javadoc comment had
references to the source of dependencies, while for 20 cases
the dependency was purely descriptive, without references to
the source. Fig. 2 shows a project-wise distribution of depen-
dencies with and without references. Across all projects, the
occurrence of dependent Javadoc comments ranged from 36%
to 74% (overall 62%). These numbers indicate a signiÔ¨Åcant
presence of dependencies that require the attention of the
developers in the context of making updates to the repositories.
Listing 2 shows a method for which the dependent Javadoc
comment describes the method that has been invoked by
sha256BytesToHex without directly referencing it. Fig.2
1https://github.com/pag-iiitd/DocDependencyListing 2: Javadoc comment that is dependent on the invoked
method without directly referencing it.
/**Returns the hex string of the given byte array
representing a SHA256 hash. */
public String sha256BytesToHex( byte [] bytes) {
synchronized (SHA_256_CHARS) {
return bytesToHex(bytes, SHA_256_CHARS);
}
}
dubbo
elasticsearch
glide
gson
guava
MPAndroidChart
netty
retrofit
RxJava
spring-boot
spring-framework
0 10 20 30 40 50Dependency with references Dependency with no reference No dependency
Fig. 2: Project-wise distribution of indirectly dependent and
independent method Javadocs studied for RQ1 with 50 meth-
ods analysed from each of the 11 projects.
represents the share of such cases in red. Cases like these make
it difÔ¨Åcult to automate the identiÔ¨Åcation of sources and poten-
tially require support from natural language processing tech-
niques, in addition to program analysis. The documentation
containing references had the following types of references: 1)
method, 2) Ô¨Åeld, 3) class object and exception types, 4) enum
types, 5) URL to external resources, and 6) package path.
Fig. 3 gives a taxonomy of the nature of dependent Javadoc
comments observed while studying for RQ1. Most of these
categories are similar to those stated in Table II; however,
note that the latter describes the nature of ‚Äòdocumentation
updates‚Äô, discussed later, while the former describes the nature
of dependent components in the whole ‚Äòdocumentation‚Äô.
Finding 1: There is a substantial presence of indirect
dependencies in the documentations, which requires the
attention of the developers in the context of making updates
to the repositories.
B.RQ2: How often is the dependence of documentation
highlighted through user and developer discussions?
Of the 1,288 shortlisted commit logs, we observed that
for 592 cases, the commit involved the updating of at least
one method‚Äôs documentation (the target) due to modiÔ¨Åcations
made at other places (the sources). A single commit may have
multiple targets and sources arising from cases where a) a set
of modiÔ¨Åcations collectively inÔ¨Çuence documentation of the
target, which leads to multiple sources, or b) a single change
induces documentation updates for multiple methods, resulting
in multiple targets. The nature of documentation update was
found to be highly similar in the case of multiple targets.
1504Example usage referencing 
other API calls to explain 
Nature of 
dependencies 
Auxiliary 
information Describe using method that calls 
the target method 
Platform/version 
speciÔ¨Åc dependency 
Exception thrown by 
the method (e.g. 
using @throws) 
To explain the 
functionality 
and behavior Describe using invoked 
methods/Ô¨Åelds/object or 
other entities Contains  ref. 
to source 
Without ref. 
to source 
Contains ref. 
to source 
Without ref. 
to source Reference class comment for 
details (‚Äúsee class comment.‚Äù) 
TODO notes with references to 
external entities 
@see tags to reference 
entities without explaining 
their role 
Deprecation note suggesting 
alternatives ConÔ¨Åguration details over a platform Specify constraints (‚ÄúThis method works on Java 
8‚Äù)
Reference an alternative for specialized 
platform requirement 
Reference to past/future version (‚Äúthis will be 
removed in v3.0‚Äù) Fig. 3: Nature of dependent updates observed for RQ1.
Finding 2: 46% of the commit logs in the dataset resolved
indirect dependencies in the method‚Äôs documentations.
This observation indicates that the maintenance of docu-
mentation matters to the developers. We further observed that
189 of 592 (32%) commits were sourced from discussions,
available on the thread of issue reports or pull requests, that
were speciÔ¨Åcally on documentation. The following are two
such comments quoted from the discussion threads:
‚ÄòThe link to the HLRC documentation for the async Put
Lifecycle method was never updated to the correct link. This
commit Ô¨Åxes that link. ‚Äô
‚ÄòQuestions on how to work with ActionPlu-
gin#getRestHandlerWrapper() come up in discussion forums
all the time. This change adds an example to the Javadoc
how this method should/could be used. ‚Äô
Finding 3: Maintenance of the documentation matters to
the developers and users of the repositories, as evident from
the discussion threads.
C.RQ3: How often is the consistency of dependent documen-
tation with code maintained as the repository evolves?
Ideally, any change made to the repository should be
reÔ¨Çected in the dependent documentations at the same time.
However, we observed that in reality, the documentation at a
point is often left inconsistent with the committed code. Of the
592 commit logs containing dependent documentation updates,
in 77 cases (13%), the documentation update was sourced
from changes made in past commits. Further, we observed
that this dependent documentation may be left inconsistent for
anywhere from 0 to 1988 days since the change that induced
the documentation update, with a mean resolution duration of
469.8 days and standard deviation of 565.7 days.
Finding 4: As the repository evolves, dependent documen-
tations may be left inconsistent for a long time.
(a) Project-wise distribution of nature of documentation updates.
(b) Distribution of sub-categories of ‚Äòdescription update‚Äô.
Fig. 4: Nature of documentation update.
D.RQ4: What is the nature of updates made to documentation
to maintain consistency?
For 325 of the 592 commit logs (54.9%) containing
dependent documentation updates, the target existed in a
different Ô¨Åle from the source. 48 of the 325 cases had
multiple targets of which some belonged to the same Ô¨Åle
as the source and others belonged to different Ô¨Åles. The
sources may also be external entities existing in a library
or a web resource different from the target, as observed
for 81 of 592 cases (13.7%). Such external dependencies
can pose challenges in tracking the updates. One such doc-
umentation update containing a link to a web-page is quoted
as‚ÄòThis can leave your server implementation vulnera-
ble to ‚Äúhttps://cwe.mitre.org/data/deÔ¨Ånitions/113.html‚Äù CWE-
113: Improper Neutralization of CRLF Sequences in HTTP
Headers (‚ÄòHTTP Response Splitting‚Äô). ‚Äô
Finding 5: Documentation may contain updates from ex-
ternal sources (not present in the target repository).
Fig. 4 shows the observed distribution of the nature of
updates made to method documentation. Fig. 4(a) indicates the
project-wise existence of different update categories described
in Table II. The grey fraction of each bar indicates the percent-
age of shortlisted commit logs with no indirectly dependent
1505documentation updates; these documentation updates were
either directly inÔ¨Çuenced by the associated method or grammar
or formatting Ô¨Åxes. Among the dependent documentation
updates, ‚Äòdescription update‚Äô dominated across all projects,
followed by ‚Äòmark deprecated‚Äô.
Each commit log with a ‚Äòdescription update‚Äô (386 of 592
commits) may be further described by one or more sub-
categories. We analyzed the description updates (Fig. 4(b)) and
observed that in most cases, the update enhanced or Ô¨Åxed the
description of the functionality by using references, covered
by the category ‚Äòreferential description‚Äô (203 of 386 cases).
The second most popular description update type was ‚Äòextra
suggestions description‚Äô (95 of 386 cases), to add or update
supplementary details by describing or referencing entities
for added clarity about the functionality. This was followed
by ‚Äòbehavioral updates‚Äô to clarify or Ô¨Åx the functionality
description. These observations indicate that while in most
cases the sources inÔ¨Çuence updates of the description of the
functionality, the developers also seek to maintain additional
details that normally act as supplementary references.
Finding 6: Developers seek to update the documentation
in a variety of ways. They mainly enhance or Ô¨Åx the core
description of the functionality, indicate deprecation by
referring to an alternative, or update the supplementary
details for better clarity about the method.
E.RQ5: What factors inÔ¨Çuence a documentation to be up-
dated with the evolution of repository?
To reason about the dependency caused in documentations,
we analyzed patterns in four types of relations between the
source and the target methods and their classes/interfaces. Fig.
5 shows a distribution of source and the target associations
across the four relations, as observed in our dataset.
Referential relation captures the association of source and
target through a reference to one in the other‚Äôs documentation.
Fig. 5(a) indicates that for 86.6% of the commits, either the
target‚Äôs or the source‚Äôs documentation mentioned the other.
In most cases, the target referenced the source (78.8% cases).
Hence, an alteration to the source, such as renaming the source
method, may induce an update to the target‚Äôs documentation.
The presence of such references may prove to be useful in
identifying the source given a target or a target given a source.
The latter is especially useful when the developer needs to
identify points (the targets) where documentation (or code)
needs to be updated after a source is modiÔ¨Åed.
Finding 7: The documentation of the source method often
has references to entities inÔ¨Çuencing it.
To further analyze the cause of such references, we explored
three types of programmatic relations between source and
target. Call-graph relation captures if the two are related by
a caller-callee relation (which may occur at any depth in the
call-graph). We observed that for 24% cases, such a relation
existed (Fig. 5(b)), with the target calling the source in most
of these cases. This indicates that the documentation of thetarget often describes or derives information from the called
entities, which induces a dependency.
We further analyzed if classes or interfaces corresponding to
source and target are related. A dominant case was observed
in which the source and the target are present in the same
class/interface (Fig. 5(c),(d)). This can be explained by the
usual practice of entities, such as methods or class Ô¨Åelds,
within a class interacting with each other. As a result, their
documentations are likely to have details that are dependent on
one another. There were a few instances where the correspond-
ing classes/interfaces of the source and target extended/imple-
mented the same parent class/interface, shared a parent-child
relation, or implemented the other‚Äôs interface. Inheritance aims
at propagating properties that get reÔ¨Çected in a child class. A
change in either the parent or its children must not violate
these properties. Similarly, an interface provides abstractions
that the implementing classes must adhere to. These relations
explain possible causes of dependencies in documentation, and
may also be useful in mitigating inconsistent documentation,
as we discuss in Section V.
Finding 8: Several programmatic relations such as caller-
callee pattern, inheritance of properties, and implementa-
tion of abstractions propagated by interface may inÔ¨Çuence
the content of the documentation of an entity.
Of the 592 commits having dependent documentation up-
dates, we observed that at least one of these four relations
categorized to a value other than ‚Äònone‚Äô for all but 11 cases.
Hence, searching for such patterns may help in identifying
sources and targets. For the 11 commits where none of the
patterns existed, we analyzed how else the source and the
target were related. We observed the following patterns.
Non-programmatic source which isn‚Äôt referenced in the
target‚Äôs documentation. Example: Example code in the
documentation was changed based on the recommended
convention in an RFC documentation.
Source and target accessing a common entity. For in-
stance, consider a class Ô¨Åeld which is accessed for
manipulation by the source and target methods, with the
documentation being derived from this behavior.
We plan to explore these patterns on the entire dataset as
future work in order to draw further insights.
V. D ISCUSSION
The discussed observations may Ô¨Ånd a direct use case for
developers in the form of a recommendation system to suggest
methods (targets) for which code or documentation should be
altered when a developer makes code changes to other entities
(sources). This would help prevent documentation inconsis-
tencies that arise as a project evolves. Some patterns that can
potentially be leveraged for the application are discussed in
this section.
In 6% of cases with dependent documentation updates, we
observed sources calling targets. This pattern is directly useful
for shortlisting methods to recommend for a documentation
1506(a) Referential relation
 (b) Call-graph relation
(c) Inheritance relation
 (d) Interface relation
Fig. 5: Relation between the source and the target as observed in 592 commit logs.
update using the program‚Äôs call-graph. On the other hand,
18% of cases with documentation updates involve targets
calling sources. This pattern could be applied to shortlist the
targets for a given source by maintaining a linkage graph for
the repository where edges exist from a programmatic entity
to all other entities that call or use it; the graph may be
dynamically updated for every code change. Hence, as a code
change occurs, all nodes directly or indirectly linked to it can
be shortlisted to check for documentation inconsistencies. A
similar linkage graph can be maintained to reÔ¨Çect inheritance
or interface relations. For a scalable and a meaningful rec-
ommendation, the described approach can be combined with
heuristics based on referential relations, which were found to
exist in abundance. For instance, the shortlisted linked entities
could be further processed such that the methods referencing
the source in their documentation or whose references appear
in the source‚Äôs documentation can be shortlisted for updating
the documentation. Several such heuristics can be developed
to leverage the observed patterns.
The recommendation may be extended to suggest documen-
tation changes for the identiÔ¨Åed targets. This would require
studying relations between the nature of code or documenta-
tion change made at the source and the nature of the induced
documentation update observed at the target. Combining these
relational insights with natural language processing techniques
could aid in building an IDE plugin for recommending docu-
mentation updates in addition to identifying methods for which
a documentation update is required.
VI. T HREATS TO VALIDITY
a) Construct validity: Inferences of the source and the
nature of documentation update are purely on openly available
artefacts such as discussion threads and commit history. Othermissing factors, such as in-person discussions between devel-
opers, may have inÔ¨Çuenced code and documentation changes.
The selection of only library projects was incidental. Apply-
ing our criterion to pick top-starred projects resulted in only
libraries and frameworks. One explanation for this trend could
be that libraries and frameworks are meant to be reusable for
further development, and hence, more developers use or star
them. Extending our analysis to non-library projects would
make for interesting future work.
b) Internal validity: To mitigate the possible subjectivity
in the analysis, which has been done by 5 annotators, we
followed a phase-wise approach to build common understand-
ing. We evaluated this understanding through an inter-rater
agreement exercise (Table III). Further, logs marked with
medium and low conÔ¨Ådence by an annotator were given to
other annotators to analyze independently (Section III-C2c).
For four cases with untraceable sources, we take a conserva-
tive approach by not considering the documentations to have
indirect dependencies.
c) External validity: The Ô¨Åltration criteria used to extract
the commit logs (Section III-C2a) may not cover all cases of
documentation updates that have been indirectly inÔ¨Çuenced in
a project. However, the criteria only give an underestimate; the
actual number of cases of dependent documentations is likely
to be higher, which makes the relevance of the problem even
stronger.
The study has been conducted on projects implemented in
Java. As Java is among the top 5 languages on GitHub, our
Ô¨Åndings may nonetheless be useful to a signiÔ¨Åcant fraction
of the developer community. With a considerable amount
of manual analysis involved and the underlying language-
dependency of the APIs used for data processing, we limited
the study to 11 projects. With the discussed patterns found
1507by the study, it opens an opportunity to automate some
components of the analysis and explore projects from more
languages and diverse classes.
VII. C ONCLUSION
We conducted a comprehensive study on 11 open-source
projects to analyze the prevalence and nature of documentation
dependencies on entities other than the associated function. We
analyzed 550 Javadoc comments and observed over 62% of
them to be indirectly dependent. We further analyzed 1288
commit logs to categorize the nature of updates made to
documentations, as induced by code-evolution changes and
external changes. To reason about the factors that induce
these inconsistencies in the documentation, we studied four
types of relations between the source and the target. We
observed the presence of references in the documentation
to be a dominant reason for the existence of dependencies.
Analyzing the programmatic relations between the source
and the target, we suggested applications of these patterns.
One such application is a recommendation system to suggest
methods for which documentation should be updated when a
developer makes changes in other sections of the repository.
The Ô¨Åndings of the study open several interesting problems.
One such problem would be to track updates in external
sources that can trigger documentation updates in the repos-
itory. As the domain of external sources is huge and mostly
non-programmatic in nature (such as web-pages), taking note
of their updates and inÔ¨Çuence on the target would be a
challenge. Further, there may exist unexplored patterns relating
the source and the target that can be leveraged to mitigate the
problem of inconsistent documentation. Combining program-
matic features, extracted by program analysis, and machine
learning approaches may aid in learning these patterns.
ACKNOWLEDGEMENTS
We thank the anonymous reviewers for their valuable feed-
back on this work. This work is supported in part by the
Department of Science and Technology (DST) (India), Science
and Engineering Research Board (SERB), Confederation of
Indian Industry (CII), Microsoft Research. We offer special
thanks to Sehaj Risham Kaur, who is no longer with us but
she has been an inspiration behind taking the initial idea of
the study to culmination.
REFERENCES
[1] S. C. B. de Souza, N. Anquetil, and K. M. de Oliveira, ‚ÄúA study of the
documentation essential to software maintenance,‚Äù in Proceedings of
the 23rd annual international conference on Design of communication:
documenting & designing for pervasive information , 2005, pp. 68‚Äì75.
[2] M. P. Robillard and R. Deline, ‚ÄúA Ô¨Åeld study of api learning obstacles,‚Äù
Empirical Software Engineering , vol. 16, no. 6, pp. 703‚Äì732, 2011.
[3] Y . Higo and S. Kusumoto, ‚ÄúHow often do unintended inconsistencies
happen? deriving modiÔ¨Åcation patterns and detecting overlooked code
fragments,‚Äù in 2012 28th IEEE International Conference on Software
Maintenance (ICSM) . IEEE, 2012, pp. 222‚Äì231.
[4] F. Wen, C. Nagy, G. Bavota, and M. Lanza, ‚ÄúA large-scale empirical
study on code-comment inconsistencies,‚Äù in 2019 IEEE/ACM 27th
International Conference on Program Comprehension (ICPC) . IEEE,
2019, pp. 53‚Äì64.[5] I. K. Ratol and M. P. Robillard, ‚ÄúDetecting fragile comments,‚Äù in
2017 32nd IEEE/ACM International Conference on Automated Software
Engineering (ASE) . IEEE, 2017, pp. 112‚Äì122.
[6] L. Tan, D. Yuan, G. Krishna, and Y . Zhou, ‚Äú/* icomment: Bugs or bad
comments?*,‚Äù in Proceedings of twenty-Ô¨Årst ACM SIGOPS symposium
on Operating systems principles , 2007, pp. 145‚Äì158.
[7] Spring-projects, Spring-framework. SPR-16130 , 2017 (October
30, 2017). [Online]. Available: https://github.com/spring-projects/
spring-framework/issues/20678
[8] P. W. McBurney and C. McMillan, ‚ÄúAutomatic source code summa-
rization of context for java methods,‚Äù IEEE Transactions on Software
Engineering , vol. 42, no. 2, pp. 103‚Äì119, 2015.
[9] G. Sridhara, E. Hill, D. Muppaneni, L. Pollock, and K. Vijay-Shanker,
‚ÄúTowards automatically generating summary comments for java meth-
ods,‚Äù in Proceedings of the IEEE/ACM international conference on
Automated software engineering , 2010, pp. 43‚Äì52.
[10] E. Aghajani, C. Nagy, O. L. Vega-M ¬¥arquez, M. Linares-V ¬¥asquez,
L. Moreno, G. Bavota, and M. Lanza, ‚ÄúSoftware documentation issues
unveiled,‚Äù in 2019 IEEE/ACM 41st International Conference on Software
Engineering (ICSE) . IEEE, 2019, pp. 1199‚Äì1210.
[11] V . Misra, J. S. K. Reddy, and S. Chimalakonda, ‚ÄúIs there a correlation
between code comments and issues? an exploratory study,‚Äù in Proceed-
ings of the 35th Annual ACM Symposium on Applied Computing , 2020,
pp. 110‚Äì117.
[12] G. Uddin and M. P. Robillard, ‚ÄúHow api documentation fails,‚Äù IEEE
Software , vol. 32, no. 4, pp. 68‚Äì75, 2015.
[13] B. Fluri, M. Wursch, and H. C. Gall, ‚ÄúDo code and comments co-
evolve? on the relation between source code and comment changes,‚Äù in
14th Working Conference on Reverse Engineering (WCRE 2007) . IEEE,
2007, pp. 70‚Äì79.
[14] A. Corazza, V . Maggio, and G. Scanniello, ‚ÄúOn the coherence between
comments and implementations in source code,‚Äù in 2015 41st Euromicro
Conference on Software Engineering and Advanced Applications . IEEE,
2015, pp. 76‚Äì83.
[15] S. H. Tan, D. Marinov, L. Tan, and G. T. Leavens, ‚Äú@ tcomment: Testing
javadoc comments to detect comment-code inconsistencies,‚Äù in 2012
IEEE Fifth International Conference on Software Testing, VeriÔ¨Åcation
and Validation . IEEE, 2012, pp. 260‚Äì269.
[16] S. Rebai, O. B. Sghaier, V . Alizadeh, M. Kessentini, and M. Chater,
‚ÄúInteractive refactoring documentation bot,‚Äù in 2019 19th Interna-
tional Working Conference on Source Code Analysis and Manipulation
(SCAM) . IEEE, 2019, pp. 152‚Äì162.
[17] M. Petito, ‚ÄúEclipse refactoring,‚Äù http://people. clarkson. edu/Àú
dhou/courses/EE564-s07/Eclipse-Refactoring. pdf , vol. 5, p. 2010, 2007.
[18] W. Cunningham, ‚ÄúThe wycash portfolio management system,‚Äù ACM
SIGPLAN OOPS Messenger , vol. 4, no. 2, pp. 29‚Äì30, 1992.
[19] A. Sarma, G. Bortis, and A. Van Der Hoek, ‚ÄúTowards supporting
awareness of indirect conÔ¨Çicts across software conÔ¨Åguration manage-
ment workspaces,‚Äù in Proceedings of the twenty-second IEEE/ACM
international conference on Automated software engineering , 2007, pp.
94‚Äì103.
[20] J. Czerwonka, R. Das, N. Nagappan, A. Tarvo, and A. Teterev, ‚ÄúCrane:
Failure prediction, change analysis and test prioritization in practice‚Äì
experiences from windows,‚Äù in 2011 Fourth IEEE International Confer-
ence on Software Testing, VeriÔ¨Åcation and Validation . IEEE, 2011, pp.
357‚Äì366.
[21] E. Shihab, A. E. Hassan, B. Adams, and Z. M. Jiang, ‚ÄúAn industrial
study on the risk of software changes,‚Äù in Proceedings of the ACM
SIGSOFT 20th International Symposium on the Foundations of Software
Engineering , 2012, pp. 1‚Äì11.
[22] A. Potdar and E. Shihab, ‚ÄúAn exploratory study on self-admitted
technical debt,‚Äù in 2014 IEEE International Conference on Software
Maintenance and Evolution . IEEE, 2014, pp. 91‚Äì100.
[23] Q. Huang, E. Shihab, X. Xia, D. Lo, and S. Li, ‚ÄúIdentifying self-admitted
technical debt in open source projects using text mining,‚Äù Empirical
Software Engineering , vol. 23, no. 1, pp. 418‚Äì451, 2018.
[24] J. Lawrance, R. Bellamy, M. Burnett, and K. Rector, ‚ÄúUsing information
scent to model the dynamic foraging behavior of programmers in main-
tenance tasks,‚Äù in Proceedings of the SIGCHI Conference on Human
Factors in Computing Systems , 2008, pp. 1323‚Äì1332.
[25] D. Kim, J. Nam, J. Song, and S. Kim, ‚ÄúAutomatic patch generation
learned from human-written patches,‚Äù in 2013 35th International Con-
ference on Software Engineering (ICSE) . IEEE, 2013, pp. 802‚Äì811.
1508[26] T. T. Nguyen, H. A. Nguyen, N. H. Pham, J. Al-Kofahi, and T. N.
Nguyen, ‚ÄúRecurring bug Ô¨Åxes in object-oriented programs,‚Äù in Pro-
ceedings of the 32nd ACM/IEEE International Conference on Software
Engineering-Volume 1 , 2010, pp. 315‚Äì324.
[27] H. Zhong, S. Thummalapenta, T. Xie, L. Zhang, and Q. Wang, ‚ÄúMining
api mapping for language migration,‚Äù in Proceedings of the 32nd
ACM/IEEE International Conference on Software Engineering-Volume
1, 2010, pp. 195‚Äì204.
[28] A. T. Nguyen, M. Hilton, M. Codoban, H. A. Nguyen, L. Mast,
E. Rademacher, T. N. Nguyen, and D. Dig, ‚ÄúApi code recommendation
using statistical learning from Ô¨Åne-grained changes,‚Äù in Proceedings of
the 2016 24th ACM SIGSOFT International Symposium on Foundations
of Software Engineering , 2016, pp. 511‚Äì522.
[29] T. Zimmermann, A. Zeller, P. Weissgerber, and S. Diehl, ‚ÄúMining
version histories to guide software changes,‚Äù IEEE Transactions on
Software Engineering , vol. 31, no. 6, pp. 429‚Äì445, 2005.
[30] S. Mehta, R. Bhagwan, R. Kumar, C. Bansal, C. Maddila, B. Ashok,
S. Asthana, C. Bird, and A. Kumar, ‚ÄúRex: Preventing bugs and miscon-
Ô¨Åguration in large services using correlated change analysis,‚Äù in 17th
USENIX Symposium on Networked Systems Design and Implementation
(NSDI 20) , 2020, pp. 435‚Äì448.
[31] R. Robbes and M. Lanza, ‚ÄúHow program history can improve code
completion,‚Äù in 2008 23rd IEEE/ACM International Conference on
Automated Software Engineering . IEEE, 2008, pp. 317‚Äì326.
[32] H. A. Nguyen, T. N. Nguyen, D. Dig, S. Nguyen, H. Tran, and M. Hilton,
‚ÄúGraph-based mining of in-the-wild, Ô¨Åne-grained, semantic code change
patterns,‚Äù in 2019 IEEE/ACM 41st International Conference on Software
Engineering (ICSE) . IEEE, 2019, pp. 819‚Äì830.
[33] Octoverse, GitHub, ‚ÄúGithub. the state of the octoverse 2019.‚Äù
2019, retrieved September 30, 2019. [Online]. Available: https:
//octoverse.github.com
[34] N. Smith, D. van Bruggen, and F. Tomassetti, ‚ÄúJavaparser: visited,‚Äù
Leanpub, oct. de , 2017.
[35] C. Bird, P. C. Rigby, E. T. Barr, D. J. Hamilton, D. M. German, and
P. Devanbu, ‚ÄúThe promises and perils of mining git,‚Äù in 2009 6th IEEE
International Working Conference on Mining Software Repositories .
IEEE, 2009, pp. 1‚Äì10.
[36] A. Ram, A. A. Sawant, M. Castelluccio, and A. Bacchelli, ‚ÄúWhat
makes a code change easier to review: an empirical investigation on
code change reviewability,‚Äù in Proceedings of the 2018 26th ACM Joint
Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering , 2018, pp. 201‚Äì212.[37] Elasticsearch, Elasticsearch. Commit 1a5e72e , 2019 (February 26,
2019). [Online]. Available: https://github.com/elastic/elasticsearch/
commit/1a5e72e2b4b
[38] MPAndroidchart, MPAndroidchart. Commit fcc5af71 , 2020 (January 22,
2020). [Online]. Available: https://github.com/PhilJay/MPAndroidChart/
commit/fcc5af71
[39] Glide, Glide. Commit ed20643fb , 2018 (September 6, 2018). [Online].
Available: https://github.com/bumptech/glide/commit/ed20643fb
[40] Spring-projects, Spring-framework. Commit 859923b , 2019 (June
11, 2019). [Online]. Available: https://github.com/spring-projects/
spring-framework/commit/859923b
[41] Elasticsearch, Elasticsearch. Commit 3f2a241 , 2018 (July 4, 2018).
[Online]. Available: https://github.com/elastic/elasticsearch/commit/
3f2a241b7f0
[42] Guava. Commit 21cfbea , 2019 (July 16, 2019). [Online]. Available:
https://github.com/google/guava/commit/21cfbea052
[43] Guava, Guava. Commit 3dfee64 , 2018 (December 6, 2018). [Online].
Available: https://github.com/google/guava/commit/3dfee64294
[44] ReactiveX, RxJava. Commit 6ba932c , 2019 (December 18, 2019).
[Online]. Available: https://github.com/ReactiveX/RxJava/commit/
6ba932c9a
[45] Guava, Guava. Commit af3ee1c , 2018 (October 27, 2018). [Online].
Available: https://github.com/google/guava/commit/af3ee1c598
[46] Spring-projects, Spring-boot. Commit a63ab46 , 2020 (April 28, 2020).
[Online]. Available: https://github.com/spring-projects/spring-boot/
commit/a63ab468a3
[47] Spring-framework. Commit 71f3498 , 2019 (September 2, 2019). [On-
line]. Available: https://github.com/spring-projects/spring-framework/
commit/71f3498
[48] Netty, Netty. Commit 8f01259 , 2018 (June 26, 2018). [Online].
Available: https://github.com/netty/netty/commit/8f01259833
[49] Guava, Guava. Commit 7fdf1a6 , 2019 (October 3, 2019). [Online].
Available: https://github.com/google/guava/commit/7fdf1a6431
[50] P. Lam, E. Bodden, O. Lhot ¬¥ak, and L. Hendren, ‚ÄúThe soot framework
for java program analysis: a retrospective,‚Äù in Cetus Users and Compiler
Infastructure Workshop (CETUS 2011) , vol. 15, 2011, p. 35.
[51] A. J. Viera, J. M. Garrett et al. , ‚ÄúUnderstanding interobserver agreement:
the kappa statistic,‚Äù Fam med , vol. 37, no. 5, pp. 360‚Äì363, 2005.
[52] J. J. Randolph, ‚ÄúOnline kappa calculator,‚Äù Retrieved October , vol. 20,
p. 2011, 2008.
1509