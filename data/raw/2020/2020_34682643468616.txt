Which Abbreviations ShouldBeExpanded?
YanjieJiang
SchoolofComputerScienceand
Technology, Beijing Instituteof
Technology
Beijing,China
jiangyanjie@bit.edu.cnHuiLiuâˆ—
SchoolofComputerScienceand
Technology, Beijing Instituteof
Technology
Beijing,China
Liuhui08@bit.edu.cnYuxiaZhang
SchoolofComputerScienceand
Technology, Beijing Instituteof
Technology
Beijing,China
yuxiazh@bit.edu.cn
NanNiu
DepartmentofElectricalEngineering
and ComputerScience, University of
Cincinnati
Cincinnati,USA
nan.niu@uc.eduYuhaiZhao
SchoolofComputerScienceand
Engineering, Northeastern University
Shenyang,China
zhaoyuhai@mail.neu.edu.cnLu Zhang
Key Laboratory ofHighConfidence
SoftwareTechnologies, Peking
University
Beijing,China
zhanglu@sei.pku.edu.cn
ABSTRACT
Abbreviationsarecommoninsourcecode.Properlydesignedab-
breviations may significantly facilitate typing, typesetting, and
reading of lengthy source code. However, abbreviations, if used
improperly, may also significantly reduce the readability and main-
tainabilityofsourcecode.Althoughafewautomatedapproaches
havebeenproposedtosuggestfulltermsforgivenabbreviations,
to the best of our knowledge, there is no automated approaches
tosuggestwhetherabbreviationsareusedproperly,i.e.,whether
they should be replaced with corresponding full terms. Notably,
itisoften challengingforinexperienceddevelopersandmaintain-
erstomakesuchdecisions.Tothisend,inthispaper,wepropose
an automated approach to assisting developers and maintainers
inmakingthedecisions.Therationaleoftheapproachisthatab-
breviationsshouldnotbeexpandediftheexpansionwouldresult
in unacceptably lengthy identifiers or if developers/maintainers
can easily figure outthe meaning (full terms) oftheabbreviations
based on their domain knowledge or contexts of the abbreviations.
From a corpus of programs, we leverage data mining techniques to
discovercommonabbreviationsthatarefrequentlyemployedby
various developers in similar contexts. The key of the data mining
is to turn the problem of mining common abbreviations into the
maximal clique problem that has been extensively studied. We sug-
gesttonotexpandgivenabbreviationifitmatchesatleastoneof
thediscoveredcommonabbreviations.Fromthesamecorpus,we
alsocalculatetheprobabilitydistributionforthelengthofdifferent
types of identifier, e.g., variable names and method names. The
probability distribution specifies how likely an identifier of type T
is composed of exactly ğ‘›characters. Our heuristic is to not expand
the abbreviation if the probability of its enclosing identifier would
âˆ—corresponding author
ESEC/FSE â€™21, August 23â€“28,2021, Athens,Greece
Â© 2021 Copyright held by theowner/author(s).
ACM ISBN 978-1-4503-8562-6/21/08.
https://doi.org/10.1145/3468264.3468616be reduced by the expansion. Finally, we also suggest to not ex-
pand the abbreviation if its full terms are contained in surrounding
contextsoftheabbreviation,i.e.,tokensonthesamesourcecode
line.Otherabbreviationsthatdonotreceivesuggestionsfromthe
proposedapproachareexpectedtobereplacedwiththeirfullterms.
Ourevaluationresultson1,818abbreviationsfromfiveopen-source
applications suggest that the proposed approach is accurate with a
highaccuracyof95%.
CCSCONCEPTS
â€¢Softwareanditsengineering â†’Softwaremaintenancetools ;
Software development techniques .
KEYWORDS
Abbreviation,Expansion,DataMining, Cliques, Software Quality
ACM Reference Format:
Yanjie Jiang, Hui Liu, Yuxia Zhang, Nan Niu, Yuhai Zhao, and Lu Zhang.
2021. Which Abbreviations Should Be Expanded?. In Proceedings of the 29th
ACM Joint European Software Engineering Conference and Symposium on
theFoundations of SoftwareEngineering(ESEC/FSEâ€™21), August 23â€“28,2021,
Athens,Greece. ACM,NewYork,NY,USA, 12pages.https://doi.org/10.1145/
3468264.3468616
1 INTRODUCTION
Identifiers,i.e.,namesofsoftwareentities,arecommoninsource
code.Theyaccountforthemajority(70%)ofsourcecodeintermsof
characters[ 21].Consequently,suchidentifierscomposedofnatural
language terms serve as the major source for software comprehen-
sion[16,17],andthustheimportanceofqualifiedidentifiersiswell
recognized [ 25,44]. For example,Avidan et al.[ 13] empirically in-
vestigated the effect of variable names on software comprehension,
and their empirical results suggest that meaningful variable names
areinstrumentalforcomprehension,andcaneffectivelyserveas
documentation for sourcecode.
Abbreviationsarewidelyemployedtoshortenidentifiers[ 39,41].
Developers often use a short abbreviation to replace a long term or
asequenceoftermsinidentifiers.Forexample,theyoftenuseâ€œe"to
This work is licensed under a Creative Commons Attribution 4.0 Interna-
tional License.
578
ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece YanjieJiang,HuiLiu, YuxiaZhang,Nan Niu,Yuhai Zhao,andLu Zhang
representâ€œexception",andpreferâ€œXMLParser"toâ€œExtensibleMarku-
pLanguageParser". Properly designed abbreviations may signifi-
cantly facilitate typing, typesetting, and reading of lengthy source
code. For example, the lengthy class name â€œExtensibleMarkupLan-
guageParser" makes it challenging to typeset the following simple
variabledeclaration:â€œ public ExtensibleMarkupLanguageParser
m_extensibleMarkupLanguageParser = new ExtensibleMarkup
LanguageParser(ExtensibleMarkupLanguageParser.DEFAULT)
;" because it is likely that the whole statement could not be shown
entirelywithinasingleline(dependingonthesizeofmonitors).The
length can be significantly reduced by replacing â€œExtensibleMarku-
pLanguage" with its well-known abbreviation â€œXML", and thus
thelengthystatementbecomesmuchshorter:â€œ public XMLParser
m_XMLParser = new XMLParser(XML-Parser.DEFAULT); ". The
latter is easier to type in and has a greater chance to be shown
entirely within a single line, which facilitates program comprehen-
sion.
However, abbreviations, if used improperly, may also signifi-
cantlyreducethereadabilityandmaintainabilityofsourcecode[ 30,
38].Abbreviationsâ€œs"(standingforâ€œstudents")andâ€œds"(standing
forâ€œdatasequence")aregoodexamplesofimproperusageofabbre-
viations. It could be difficult for developers other than the authors
to figure out the exact meaning of the abbreviations, which may
result in misunderstanding and incorrect usage of the enclosing
programs.Tothisend,afewautomatednovelapproacheshavebeen
proposedtosuggestfulltermsforgivenabbreviations[ 18,29,33].
Developersmayreplacetheabbreviationswithfulltermssuggested
by such tools by renaming [ 42,43]. Notably, it is highly beneficial
for authors of source code to replace improperly used confusing
abbreviationswithfullterms.Theauthorsâ€™replacementishighly
accurateandisdoneonceandforall.Althoughreaders/maintainers
ofthesourcecodemayleverageexpansiontoolstoguessthemean-
ingoftheconfusingabbreviations,theguesscouldbeinaccurate
anditshould be repeatedbyevery reader/maintainer.
Weconcludebasedontheprecedinganalysisthatcarefullyde-
signed abbreviations facilitate coding and improve readability of
sourcecodewhereasimproperlyusedabbreviationscouldreduce
readabilityofsourcecodeandresultin incorrectusages/modifica-
tion ofprograms.Althoughnovel approaches have beenproposed
tosuggestfulltermsofgivenabbreviations,tothebestofourknowl-
edge, there is no automated approaches to suggest whether abbre-
viations require expansion, i.e., whether they should be replaced
withcorrespondingfullterms.Notably,itisoftenchallengingfor
inexperienced developers and maintainers tomakesuch decisions
becausethereisnoquantitativeguidanceforthedecision,andit
fully depends ondevelopersâ€™ experience andintuitions.
To this end, in this paper, we propose an automated approach
(calledSmartExpander )todecidingwhetheragivenabbreviation
needstobeexpandedatall.Therationaleoftheapproachisthat
abbreviationsshouldnotbeexpandediftheexpansionwouldresult
in lengthy identifiers or if developers/maintainers can easily figure
out the meaning (full terms) of the abbreviations based on their
domain knowledge or contexts of the abbreviations. Consequently,
we design a sequence of heuristics according to the rationale to
pick up such abbreviations that do not require expansion. From
a corpus of source code, we leverage data mining techniques to
discovercommonabbreviationsthatarefrequentlyemployedbydifferentdevelopersinsimilarcontexts.Thekeyofthedatamining
is to turn the problem of mining common abbreviations into the
maximal clique problem [ 23] that has been extensively studied [ 15,
47].Theproposedapproachsuggeststonotexpandanabbreviation
if it matches at least one of the discovered common abbreviations.
From the same corpus of open-source programs, we also build the
probabilitydistributionmodelforthelengthofdifferenttypesof
identifier,e.g.,variablenames,methodnames,andclassnames.The
model specifies how likely an identifier of type T is composed
of exactlyğ‘›characters, noted as ğ‘ƒ(ğ‘‡,ğ‘›). Suppose that a given
abbreviationcomesfromidentifier ğ‘–ğ‘‘oftypeT,andreplacingthe
abbreviation with its full terms would increase the length of the
identifier from ğ‘˜toğ‘—characters. Our approach suggests to not
expandtheabbreviation if ğ‘ƒ(ğ‘‡,ğ‘—)<ğ‘ƒ(ğ‘‡,ğ‘˜). Finally,the proposed
approachsuggeststonotexpandtheabbreviationifitsfullterms
arecontainedinthe surroundingcontextsoftheabbreviation,i.e.,
tokensonthesamesourcecodeline.Otherabbreviationsthatdo
notreceivesuggestionsfromtheproposedapproachare expected
to be replacedwiththeirfull terms.
Theproposedapproachhasbeenevaluatedonopen-sourceap-
plications and our evaluation results suggest that the proposed
approach is accurate. We randomly sampled 1,818 abbreviations
from five open-source applications, and manually decided whether
they should be expanded. We applied the proposed approach to
thesampledabbreviations,andcompareditssuggestionsagainst
manual decisions. Our evaluation results suggest that the accuracy
of the proposed approach varies from 93% to 96%, with an average
of95%.
Thepaper makesthe following contributions:
â€¢An automated approach to deciding which abbreviations
should(orshouldnot)beexpanded.Tothebestofourknowl-
edge,it is the firstautomatedapproach for this task.
â€¢An extensive evaluation of the proposed approach on open-
source applications. The evaluation results suggest that the
proposedapproach isaccurate.
Therestofthepaperisstructuredasfollows.Section 2presentsa
shortreviewofrelatedresearch.Section 3proposestheapproachto
suggestwhetherabbreviationsareusedproperly.Section 4presents
anevaluationoftheproposedapproachonwell-knownopen-source
applications.Section 5providesconclusionsandpotentialfuture
work.
2 RELATED WORK
2.1 ExpansionofAbbreviations in SourceCode
Because of the popularity of abbreviations, a large number of auto-
matedapproaches[ 33]havebeenproposedtosuggestingfullterms
forabbreviationsinsourcecode,especially inidentifiers.Anintu-
itivewaytoexpandingabbreviationsistocompareabbreviations
againstgenericEnglishdictionariesandreturndictionarywords
thatmatchtheabbreviationsaccordingtopredefinedrules[ 22].For
example, an abbreviation matches a dictionary word if the abbrevi-
ationisaprefixofthedictionaryword.Theadvantageoflooking
up expansion in generic English dictionaries is twofold. First, such
dictionariesare ready for reuse.Second, suchdictionaries contain
almostallpossibleEnglishwords,andthusinmostcaseswecan
findmatchingtermsforgivenabbre viations.Howev er,itisquite
579Which Abbreviations Should Be Expanded? ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
often that for a given abbreviation there are a large number of
matching terms from a generic English dictionary. It remains chal-
lenging to choose the correct one from such a large number of
matchingterms.
Anotherintuitivewaytoabbreviationexpansionistolookupab-
breviation dictionaries [ 10]. An abbreviation dictionary contains a
list of well-known abbreviations as well as their corresponding full
terms. By looking up the dictionary, we can retrieve the full terms
for a given abbreviation accurately. However, such abbreviation
dictionaries are often constructed manually, which significantly
limits the size of such dictionaries [ 16]. As a result, matching algo-
rithms may fail frequently to retrieve matching items from such
dictionaries[ 26]incasethedictionariesdonotcontaintheabbre-
viations. Another problem with abbreviation dictionaries is that
thesameabbreviationmayhavedifferentmeaning(andthusdif-
ferent full terms) depending on its contexts. As a result, looking
up the abbreviation dictionaries alone may fail to select the correct
expansion.
Leveragingthecontextsofabbreviations(e.g.,surroundingsource
codeandcomments)couldsignificantlyincreasetheaccuracyofab-
breviation expansion [ 33]. For example, Corazza et al. [ 20], Lawrie
etal.[37]andGuerroujetal.[ 45]suggestedtosearchforfullterms
incommentsofsourcecode.Therationaleofsuchapproachesis
thatcommentsinsourcecodeexplainthesemanticsofsourcecode
and thus it is likely that we can find the full terms of abbrevia-
tions from the comments associated with the source code where
the abbreviations appear. However, developers rarely write com-
ments, which significantly reduces the chance of finding full terms
in comments. Caprile et al. [ 16] and Carvalho et al. [ 18] suggested
toexpandabbreviationsbylookingforfulltermsfromsurrounding
source code. Lawrie et al. [ 35] suggested to match a given abbre-
viation against full terms in the enclosing methods only. Hill et
al. [29] proposed a complex approach to search for full terms in
enclosing methods, enclosing classes, and enclosing projects in
order.Jiangetal.[ 34]proposedaparameter-specificapproachto
expand parameter abbreviations only by leveraging the relation-
shipbetweenargumentsandparameter:Ifanabbreviationcomes
fromanargument,theylookfor itsfulltermsinthecorresponding
parameter,andviceversa.Later,they[ 32,33]generalizedtheap-
proach to leverage various semantic relationships among software
entities, e.g., assignments between software entities, inclusion rela-
tion betweensoftware entities,invocationof methods, and access
offields/variables.Therationaleisthatsemanticallyrelatedentities
are likely to share some common concepts and thus their names
maycontainsomecommonterms.Newmanetal.[ 46]conducted
an empirical study to analyze 861 abbreviation-expansion pairs
extracted from five open-source applications. One of their interest-
ing findings is that documents of programming languages, project
documents,andsourcecodecontainsimilarnumbersofexpansions
whereas documents of programming languages are the primary
sourceofunique expansions.
Besidesthesourceoffullterms,matchingalgorithmsserveas
anothercornerstoneforabbreviationexpansion[ 33].Foragivenab-
breviationandgivensourceoffullterms(e.g.,dictionariesandcode
comments),abbreviationexpansiontoolsshouldleveragematching
algorithmstosearchforpotentialexpansionsfromthegivensource
(sequences of words). Apostolio et al. [ 12] proposed a matchingalgorithm where a word is taken as a potential expansion of an ab-
breviation if the abbreviation is a subsequence of the word. Lawrie
et al. [36] make suggestions only if the given abbreviation has a
singlepotentialexpansion,andignoresthecaseswheremultiple
potentialexpansionsareretrieved.Incontrast,Hilletal.[ 29]and
Carvalhoetal.[ 18]sortsuchpotentialexpansionsbasedontheir
frequency,andrecommendthetopone.Lawrieetal.[ 35]choosethe
one that has thehighestlexical similarity withthe givenabbrevia-
tion.Guerroujetal.[ 27]andCorazzaetal.[ 20]employgraph-based
matchingalgorithmsto search for the mostlikely expansions.
Suchnovelapproachestoabbreviationexpansionhavesignifi-
cantly facilitated program comprehension. However, none of them
couldbeleveragedtosuggestwhichabbreviationsshould(orshould
not)be expanded,as our approach does.
2.2 InfluenceofAbbreviations
Abbreviations are common in source code, and thus their negative
and positive effect is a big concern for software developers. To this
end,researchershaveconductedempiricalstudiestoinvestigatethe
negative/positive effect of such abbreviations. For example, Lawrie
et al. [38,39] consulted over 100 programmers and concluded that
identifiers made up of full words often lead to higher software
quality. However, they also suggested that in many cases replacing
fulltermswithwell-formedabbreviationswouldnotsignificantly
reduce software quality because shorter and meaningful identifiers
areeasiertorememberthanlongerones.Swidanetal.[ 50]analyzed
variablesinScratch,apopularblock-basedlanguageaimingatchil-
dren.TheiranalysisresultssuggestthatScratchprogrammersoften
preferlongeridentifiernamesthandevelopersinotherlanguages.
Hofmeister et al. [ 30] conducted an experimental study with 72
professional C# developers, requesting them to locate defects in
sourcecodesnippets.Theirevaluationresultssuggestthatfullterm
identifierscanspeedupfaultlocalizationby19%comparedtomean-
ingless single letters and abbreviations. Notably, single letters and
abbreviations are roughly equivalentwithregardtofault localiza-
tion. Schankin et al. [ 49] requested 88 Java developers to locate
semanticdefectsinsourcecodesnippets,andtheirevaluationre-
sultssuggestthatlongerandmoredescriptiveidentifiers canspeed
upfaultlocalizationby14%comparedtoshorterandlessdescrip-
tive identifiers. However, this effect disappears when developers
aresearchingforsyntaxerrorswherein-depthunderstandingof
the code isoften not required.
Although empirical studies introduced in the preceding para-
graphsuggestthatlongeridentifiersoftenleadtobetterreadability
ofsourcecode,theirnegativeimpactisnotnegligible.Forexample,
Binkleyetal.[ 14]conductedacasestudytoinvestigatethebalance
betweenlonger,moreexpressivenamesandlimitedprogrammer
memory resources. Their evaluation results suggest that longer
namesoftentakemoretimetoprocessandreducecorrectnessin
softwareengineeringtasks.Scannielloetal.[ 48,51]conducteda
controlledexperimentwherestudentswereaskedtofindandfix
faults in one of two alternative versions of the same program: One
with full-termed identifiers and the other with abbreviations. Their
evaluationresultssuggestthatabbreviationsdidnotresultinsig-
nificantnegativeeffectonthesoftwareengineeringtasks(i.e.,fault
location andbugfixing).
580ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece YanjieJiang,HuiLiu, YuxiaZhang,Nan Niu,Yuhai Zhao,andLu Zhang
Figure 1:Overview
Suchinterestingfindingsreveal bothpositive andnegativesides
ofabbreviations, whichinspiredthe work presentedin this paper.
3 APPROACH
In this section, we present an automated approach to assisting
developersandmaintainersindecidingwhichabbreviationsshould
(orshouldnot)beexpanded.AnoverviewispresentedinSection 3.1,
anddetailsare presentedin the following sections.
3.1 Overview
Fig.1presentstheoverviewoftheproposedapproach.Theproposed
approach is divided into two phases: offline mining (the left part of
Fig.1) and onlineclassification (theright partof Fig. 1).During the
offlineminingphase,theproposedapproachlearns fromacorpus
of source code and discovers a list of common abbreviations as
well as the probability distribution of identifiersâ€™ length. During
the online classification phase, the proposed approach applies a
sequence of heuristic-based filtering to determine whether a given
abbreviationshouldbeexpanded.Overall,theproposedapproach
works as follows:
â€¢Fromacorpusofsourcecode,weextractallidentifiers(i.e.,names
ofsoftwareentities)andclassifythemaccordingtoentitiesâ€™types
(e.g., variable names, method names, and class names). For each
type of identifiers, we calculate the probability distribution of
their length. The probability distribution specifies how likely an
identifier of type T is composed of exactly ğ‘›characters, noted as
ğ‘ƒ(ğ‘‡,ğ‘›).
â€¢From the same corpus, we extract all abbreviations. Lexically-
identicalabbreviationsregardlesswheretheyareextractedare
presented on a single graph where each abbreviation is repre-
sented as a node and weight of edges represent the context sim-
ilarity among lexically-identical abbreviations. In case there is
alargesubgraphwhereeachpairofnodesisconnectedwitha
short edge, the subgraph (called maximal clique ) represents a
commonabbreviation that iswidely usedin similar contexts.
â€¢Foragivenabbreviation ğ‘ğ‘ğ‘fromidentifier ğ‘–ğ‘‘oftypeT,replacing
the abbreviation with its full terms would increase the length
ofğ‘–ğ‘‘fromğ‘˜toğ‘—. We suggest to not expand the abbreviation if
ğ‘ƒ(ğ‘‡,ğ‘—)<ğ‘ƒ(ğ‘‡,ğ‘˜)(notedas Case1).
â€¢If the abbreviation ğ‘ğ‘ğ‘and its full terms appear on the same
source code line where the enclosing identifier is defined (noted
as Case2),we suggestto not expand it.
Figure 2:ProbabilityDistribution ofIdentifiersâ€™ Length
â€¢Iftherearealargenumberofabbreviationsinthesameproject
thatarelexicallyidenticalto ğ‘ğ‘ğ‘(notedasCase3),wesuggest
to not expand the abbreviation.
â€¢If there is a maximal clique whose abbreviations are lexically
identical toğ‘ğ‘ğ‘, and the average context similarity between ğ‘ğ‘ğ‘
andnodesinthecliqueisgreaterthanthreshold ğ›½(notedasCase
4),we suggestto not expand the abbreviation.
â€¢We suggest to expand ğ‘ğ‘ğ‘if it does not belong to any of the
preceding cases(i.e.,Cases1-4)
Detailsofthe key steps are presentedin the following sections.
3.2 StatisticAnalysis on Identifiersâ€™ Length
Lengthyidentifiershavenegativeeffectonthereadabilityofsource
code[14].Consequently,ifexpandingabbreviationsresultsinlengthy
identifiers,we should suggest to not expand them.
Fromacorpusofsourcecode,weextractallidentifiers,including
variable names,parameter names, methodnames, class names,and
fieldnames.Notably,weextractallidentifiersregardlessofwhether
theycontainabbreviations.Theresultingidentifiersaredividedinto
fivetypes:variablenames(includingfieldnames),parameternames,
methodnames,classnames,anditerationindexes.Iterationindexes
requireaspecialcategorybecausesuchindexes(e.g., ğ‘–andğ‘—)ar e
often significantly shorter than other variables. For each type of
identifiers, we calculate the probability distribution of their length.
The probability distribution specifies how likely an identifier of
type T is composed of exactly ğ‘›characters, noted as ğ‘ƒ(ğ‘‡,ğ‘›). For
example,theprobabilitydistributionformethodnamesispresented
in Fig.2where the horizontal axis presents the length of method
581Which Abbreviations Should Be Expanded? ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
names and vertical axis presents the probability for the length of a
methodname being equivalentto the horizontal axis.
Supposethattheabbreviationundertest(notedas ğ‘ğ‘ğ‘)comes
from identifier ğ‘–ğ‘‘of type T, and replacing the abbreviation with its
fulltermswouldincreasethelengthof ğ‘–ğ‘‘fromğ‘¥1toğ‘¥2.W elookup
the probability distribution modelof type ğ‘‡(e.g.,the one inFig. 2),
andretrievethecorrespondingprobabilitiesforlength ğ‘¥1andğ‘¥2,
respectively:
ğ‘1=ğ‘ƒ(ğ‘‡,ğ‘¥1) (1)
ğ‘2=ğ‘ƒ(ğ‘‡,ğ‘¥2) (2)
We suggest to not expand the abbreviation ğ‘ğ‘ğ‘in identifier ğ‘–ğ‘‘
ifğ‘ƒ(ğ‘‡,ğ‘¥2)<ğ‘ƒ(ğ‘‡,ğ‘¥1). The rationale of the heuristic is that the
lengthoftheidentifierbecomeslessacceptable(i.e.,lesspopular)
because of the abbreviation expansion, and thus we had better
not conduct the expansion. In this case, the proposed approach
terminatestheprocessonthegivenabbreviation.Otherwise,the
proposedapproachwouldapplyotherheuristics(asspecifiedinthe
followingsections) to the abbreviation to reachthe final decision.
3.3 Graph-BasedData Mining
Well-knownabbreviations(likeâ€œXML"andâ€œAI")arelesslikelyto
hindersourcecodecomprehensionbecausedevelopersandmain-
tainers could easily figure out their meaning (and full terms). To
this end, we would suggest to not expand such well-known ab-
breviations. A simple and intuitive way to tell whether a given
abbreviation is well-known is to look up abbreviation dictionar-
ies. However, such abbreviation dictionaries are often constructed
manuallyandthustheirsizesarelimited[ 33].Asaresult,somepop-
ularabbreviations,especiallythose thatbecame popularrecently,
may not be included in such manually constructed abbreviation
dictionaries.
Tothis end, in this paper, weleverage graph-based data mining
techniques [ 23] to identify well-known abbreviations from a large
corpusofsourcecode.Weextractallabbreviationsfromthecorpus.
Eachofthe resultingabbreviation isrepresentedas atuple:
ğ‘ğ‘ğ‘ğ‘–=<ğ‘ ğ‘¡ğ‘Ÿğ‘–,ğ‘ğ‘¥ğ‘¡ğ‘–> (3)
whereğ‘ ğ‘¡ğ‘Ÿğ‘–andğ‘ğ‘¥ğ‘¡ğ‘–are the text and context of the abbreviation,
respectively.Thecontextiscomposedofasequenceofidentifiers
that appear in the enclosing document (e.g., a Java file) of the
abbreviationinthesameorderastheyappearinthedocument.Such
identifiers are partitioned into tokens (including abbreviations) by
theheuristicsproposedby Jiangetal. [ 34].The contextisfinally
representedas asequenceoftokens:
ğ‘ğ‘¥ğ‘¡ğ‘–=<ğ‘¡1,...,ğ‘¡ğ‘›> (4)
Werepresentthecontextasafixed-lengthnumericalvectorwith
well-knownParagraph2vector [ 40].
ğ‘‰(ğ‘ğ‘¥ğ‘¡ğ‘–)=ğ‘ƒ2ğ‘‰(<ğ‘¡1,...,ğ‘¡ğ‘›>) (5)
whereğ‘‰(ğ‘ğ‘¥ğ‘¡ğ‘–)isthenumericalvectorand ğ‘ƒ2ğ‘‰isthemappingfrom
asequenceoftokensintoanumericalvector,i.e.,Paragraph2vector.
Notably, Paragraph2vector [ 40] is a deep learning-based algorithm
that is widely used to convert short texts in natural languages
into fixed-length numerical vectors. A significant advantage of
Paragraph2vector is that semantically related texts could result insimilarvectors,andthusthesimilarityoftheresultingvectorscould
be leveraged to represent the semantic similarity of the original
texts. Consequently, we compute the context similarity between
twoabbreviationsbasedonthecosinesimilarity[ 3]oftheresulting
vectors:
ğ‘†ğ‘–ğ‘šğ‘ğ‘¥ğ‘¡(ğ‘ğ‘ğ‘ğ‘–,ğ‘ğ‘ğ‘ğ‘—)=ğ‘†ğ‘–ğ‘š(ğ‘‰(ğ‘ğ‘¥ğ‘¡ğ‘–),ğ‘‰(ğ‘ğ‘¥ğ‘¡ğ‘—))
=ğ‘‰(ğ‘ğ‘¥ğ‘¡ğ‘–)Â·ğ‘‰(ğ‘ğ‘¥ğ‘¡ğ‘—)
/bardblğ‘‰(ğ‘ğ‘¥ğ‘¡ğ‘–)/bardbl/bardblex/bardblexğ‘‰(ğ‘ğ‘¥ğ‘¡ğ‘—)/bardblex/bardblex(6)
Abbreviations from the corpus are partitioned into different
groups according to the texts (i.e., ğ‘ ğ‘¡ğ‘Ÿğ‘–in Equation 3). Abbrevia-
tions within the same group are lexically identical, and thus we
call them lexically-identical abbreviations. For each group of the
abbreviations, we construct an undirected graph ğºwhere nodes
represent abbreviations in the group and weight of edges repre-
sent the context similarity between abbreviations (as defined in
Equation 6).
Graph-baseddataminingoftheproposedapproachistoidentify
common abbreviations thatare frequentlyused bydifferentdevel-
opers in similar contexts. We convert this task into a well-studied
maximal clique problem [23] as follows. A cliqueof a graph is a
subgraph where any two of the vertices are adjacent. Two vertices
inaundirectedgraphare adjacentifandonlyiftheyareconnected
byanedgeinthegraph.A maximalclique isacliquethatcannot
be extendedby includingone moreadjacentvertex,i.e., it isnot a
subset of a larger clique. The task to find out the maximal clique of
agivengraphiscalled maximalcliqueproblem [23].Thisproblem
hasbeenwell-studied,andalargenumberofefficientapproaches
havebeenproposed[ 24].Notably,intheoriginalgraph ğº,eachpair
ofverticesare adjacentnomatterhowsimilar(ordissimilar)they
are.Consequently,thewholegraphitselfistheonlymaximalclique.
To mine common abbreviations used in highly similar contexts, we
remove the edgebetween twoverticesifthe context similarity(as
defined in Equation 6) of two abbreviations (represented by the
twovertices) issmallerthanapredefinedthreshold ğ›¼.Asaresult,
amaximalcliqueoftheresultinggraph( ğºâ€²)representsapopular
abbreviationthatisemployedfrequentlyinhighlysimilarcontexts,
and thesizeof thecliqueindicatesitspopularity. Amaximal clique
could be representedas atriple:
ğ‘ğ‘™ğ‘ğ‘–=<ğ‘‡ğ‘¥ğ‘‡(ğ‘ğ‘™ğ‘ğ‘–),ğ‘‰(ğ‘ğ‘™ğ‘ğ‘–),ğ¸(ğ‘ğ‘™ğ‘ğ‘–)> (7)
whereğ‘ğ‘™ğ‘ğ‘–is a maximal clique, and ğ‘‡ğ‘¥ğ‘‡(ğ‘ğ‘™ğ‘ğ‘–)is the text of the
abbreviationsrepresentedbytheverticesontheclique. ğ‘‰(ğ‘ğ‘™ğ‘ğ‘–)and
ğ¸(ğ‘ğ‘™ğ‘ğ‘–)areverticesandedgesontheclique.Notably,toremoveless
popularabbreviations,weonlykeepsuchmaximalcliqueswhose
size (number ofvertex)isnoless threshold ğ›½.
3.4 Common-Abbreviation BasedFiltering
In the preceding section, we identify common abbreviations by
applying data mining techniques to a corpus of source code, re-
sulting in a set of maximal cliques. In this section, we compare
abbreviations under test against such common abbreviations, to
identify such abbreviations that are well-known to developers and
maintainers.
Suppose that the abbreviation under test is ğ‘ğ‘ğ‘ğ‘–=<ğ‘ ğ‘¡ğ‘Ÿğ‘–,ğ‘ğ‘¥ğ‘¡ğ‘–>.
Fromthemaximalcliquesgeneratedintheprecedingsection,we
retrieve such cliques where abbreviations are lexically identical
582ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece YanjieJiang,HuiLiu, YuxiaZhang,Nan Niu,Yuhai Zhao,andLu Zhang
toğ‘ğ‘ğ‘ğ‘–.Foreachoftheresultingcliqueswecomputetheaverage
contextsimilaritybetween ğ‘ğ‘ğ‘ğ‘–andabbreviationsonthe clique:
ğ‘ğ‘£ğ‘”ğ‘†ğ‘–ğ‘š(ğ‘ğ‘ğ‘ğ‘–,ğ‘ğ‘™ğ‘ğ‘—)=/summationtext.1
ğ‘ğ‘ğ‘ğ‘˜âˆˆğ‘‰(ğ‘ğ‘™ğ‘ğ‘—)ğ‘†ğ‘–ğ‘šğ‘ğ‘¥ğ‘¡(ğ‘ğ‘ğ‘ğ‘–,ğ‘ğ‘ğ‘ğ‘˜)
|ğ‘‰(ğ‘ğ‘™ğ‘ğ‘—)|,(8)
whereğ‘‰(ğ‘ğ‘™ğ‘ğ‘—)(asspecifiedinEquation 7)istheabbreviations(ver-
tices)ontheclique ğ‘ğ‘™ğ‘ğ‘—,andğ‘†ğ‘–ğ‘šğ‘ğ‘¥ğ‘¡computesthecontextsimilarity
between a pair of abbreviations as specified in Equation 6.I ft h e
resulting average similarity ğ‘ğ‘£ğ‘”ğ‘†ğ‘–ğ‘š(ğ‘ğ‘ğ‘ğ‘–,ğ‘ğ‘™ğ‘ğ‘—)is greater than ğ›¼,
we suggest to not expand the abbreviation ğ‘ğ‘ğ‘ğ‘–, and the proposed
approach terminatestheprocessing onthis abbreviation.
Some abbreviations, e.g, â€œPKCS"standingforâ€œPublicKey Cryp-
tograph Standards", are domain-specific, and thus they may be
missed by the graph-based data mining onlarge-scale source code
asspecifiedintheprecedingsection.Tothisend,wecomparethe
abbreviationundertest(notedas ğ‘ğ‘ğ‘ğ‘–)againstabbreviationswithin
the same project to determine whether the same abbreviation is
frequently used in different places within the same project. Conse-
quently, we retrieve allabbreviationswithinthe enclosingproject
ofğ‘ğ‘ğ‘ğ‘–,andcalculatethenumberofabbreviationsthatarelexically-
identical toğ‘ğ‘ğ‘ğ‘–. If this number is greater than a threshold ğ›¾,w e
suggestto not expand the abbreviation.
3.5 Context-BasedFiltering
Some abbreviations are easy to interpret/expand because their full
termsappearintheirsurroundingcontexts.Typicalexamplesare
presentedin the following code snippet:
1try {
2BufferedReader bufReader = new BufferedReader(new FileReader(
file));
3String line;
4while ((line = bufReader.readLine() ) != null) {
5 if (!line.equals ("")) {
6 int lenOfLine = line.length();
7 results.add( line + "," + lenOfLine);
8 }
9 }
10 bufReader.close();
11 }
12catch (Exception e) {
13 e.printStackTrace();
14 }
Thiscodesnippetcontainsafewidentifiersthatarecomposed
ofabbreviations,i.e.,â€œ bufReader "onLine2,â€œ lenOfLine "onLine6,
and â€œe" on Line 12. None of the abbreviations, however, requires
expansion because such abbreviations are easy to interpret. For
the first one (i.e., â€œ bufReader " on Line 2), we know its meaning
accordingtoitsdatatypeâ€œBufferedReader";Forthesecondone(i.e.,
â€œlenOfLine "onLine 6),wecanfigure outitsfullterm accordingto
the right side of the assignment (i.e., â€œlength()"); For the last one
(i.e., â€œe" on Line 12), we know exactly what it means because of the
data type (â€œException").
Toidentifysuchabbreviationsthatcouldbeeasilyinterpreted
via their surrounding contexts, the proposed approach works as
follows:
â€¢First,foranabbreviationundertest(notedas ğ‘ğ‘ğ‘ğ‘–),weextract
the whole line of source code where its enclosing identifier is
definedas the contextofthe abbreviation, notedas ğ¶ğ‘‡ğ‘‹(ğ‘ğ‘ğ‘ğ‘–).
â€¢Second,wedecomposethecontext ğ¶ğ‘‡ğ‘‹(ğ‘ğ‘ğ‘ğ‘–)intoasequence
oftokensaccordingtoblankspaces,capitalletters,andspecialcharacters, e.g., â€œ(" and â€œ)". The resulting sequence is noted as
ğ‘†ğ‘’ğ‘(ğ‘ğ‘ğ‘ğ‘–).
â€¢Third, supposing the full terms of the abbreviation is a sequence
ofwords<ğ‘¤1,...,ğ‘¤ğ‘›>,wesuggesttonotexpandtheabbrevia-
tionifallofthewordshaveequivalenttokensin ğ‘†ğ‘’ğ‘(ğ‘ğ‘ğ‘ğ‘–).T w o
tokens(words)areequivalentiftheyareidenticalorsharethe
same root. For example, â€œthread" and â€œthreads" are not identical,
buttheydosharethesameroot(â€œthread")andthustheyaretaken
asequivalent.Tothisend,weapplystemmingtosuchtokenswith
an open-sourceimplementationfrom StanfordUniversity[ 9].
Notably, if none of the heuristics specified in Sections 3.2-3.5
suggesttonot expanda givenabbreviation,theproposedapproach
bydefaultwouldsuggestto expand it.
4 EVALUATION
4.1 Research Questions
Theevaluation investigates the following research questions:
â€¢RQ1:Doallabbreviationsinwell-knownopen-sourceapplica-
tions require expansion? If not, what percentage of the abbrevia-
tionsshould(orshould not)be expanded?
â€¢RQ2:Istheproposedapproach( SmartExpander )accurateiniden-
tifyingabbreviationsthat should (orshould not)be expanded?
â€¢RQ3: How does the setting of the thresholds employed by the
proposedapproachinï¬‚uencetheperformanceof SmartExpander ?
â€¢RQ4:Howdoestheheuristicsinï¬‚uencetheperformanceof Smar-
tExpander ?
â€¢RQ5:IsSmartExpander scalable?
Theproposedapproach(called SmartExpander )isbasedonthe
assumptionthatnotallabbreviationsrequireexpansion.Investigat-
ingRQ1would validate the assumption. RQ2concerns the perfor-
mance(e.g.,precisionandrecall)ofSmartExpanderinclassifying
abbreviations with regard to their necessity of expansion. RQ3
concerns the setting of SmartExpander. As introduced in Section 3,
SmartExpander leverages a set of thresholds, i.e., ğ›¼(the minimal
contextsimilaritybetweenabbreviations)inSection 3.3,ğ›½(themin-
imal size of the maximal cliques) in Section 3.3, andğ›¾(the minimal
numberoflexically-identicalabbreviationswithinthesameproject)
inSection 3.4.Investigating RQ3helpsdevelopersandmaintainers
set the thresholds to maximize the performance of SmartExpander.
RQ4concernstheeffectoftheemployedheuristics.SmartExpander
is essentially a sequence of heuristics: length-based heuristic (Sec-
tion3.2),common-abbreviationbasedheuristic(Section 3.4),and
context-basedheuristic(Section 3.5).Byinvestigating RQ4,wemay
quantitativelyrevealthe effectoftheemployedheuristics. RQ5con-
cernsthescalabilityofSmartExpander,i.e.,whetherSmartExpander
can be appliedefficiently to large projects.
4.2 Subject Applications
Theevaluationisbasedonfivewell-knownopen-sourceapplica-
tions.AnoverviewofthesubjectapplicationsispresentedinTable 1.
DavMail[ 4]isanexchangegatewayallowinguserstouseanymail/-
calendarclienttocommunicatewithanexchangeserver.Itsgoal
istoprovidestandardcompliantprotocolsinfrontofproprietary
exchange. DocFetcher [ 5] is a desktop search application. It allows
to search the contents of files on local computer. DrJava [ 6]i sa
583Which Abbreviations Should Be Expanded? ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
Table 1:SubjectApplications
Application ID Full Names Domain Major Developers #Identifiers #Abbreviations
Mail DavMail Gateway eMail MickaÃ«l Guessant, Oleksandr Huziy andAndrÃ© K 11,192 3,813
Doc DocFetcher Search Engine Nam Quang Tran, Rob Croweandbitnik 11,686 3,831
DrJ DrJava IDE Corky Cartwright, Rebecca Smith, andCarolyn 66,099 26,105
Dubbo Apache Dubbo Distributed Computing ken.lj, IanLuo and Cvictory 60,277 20,897
jEdit jEdit TextEditor Andrea Citti, MartinRaspeandVolker Friedritz 32,104 11,976
Total: 181,358 66,622
Table 2:Not All AbbreviationsRequire Expansion
Applications #Samples #Positive #Negative Rate ofPositive
Mail 346 71 275 21%
Doc 346 88 258 25%
DrJ 378 63 315 17%
Dubbo 377 52 325 14%
jEdit 371 75 296 20%
TOTAL 1,818 349 1,469 19%
lightweight programming environment for Java designed to foster
test-driven software development. Apache Dubbo [ 1] is a high-
performance, Java-based RPC framework. jEdit [ 7] is a program-
merâ€™s text editor written in Java. These applications are selected
because of the following reasons. First, all of them are well-known
open-source applications,which facilitatereplication of the evalu-
ation.Second,theyarefromdifferentdomains,anddevelopedby
differentprogrammers.Constructingsuchacomprehensivedataset
mayimprovethegeneralityoftheconclusionsdrawnonthedataset.
Notably, SmartExpander requests a large corpus of high quality
source code for data mining as specified in Section 3.2and Sec-
tion3.3.Tothisend,wereusethedatasetcreatedbyAlonetal.[ 11]
as the corpus of source code. The dataset is composed of source
codefrom1,000top-rankedJavaapplicationsonGitHub.Suchap-
plicationsarefromdifferentdomainsandaredevelopedbydifferent
teams. In total, the dataset contains 39,631,241 lines of source code,
13,571,072 identifiers, and 1,048,552 abbreviations. Notably, this
corpus does not contain any of the five subject applications in
Table1.
4.3 Process
ToanswerRQ1,wesampledabbreviationsfromeachoftheinvolved
subject applications and manually decide which of them require
expansion. The size of the samples is determined by the number
ofabbreviationsinthesubjectapplications,andwecomputedthe
minimalsizeofthesampleswith SampleSizeCalculator [8]withan
error margin of 5% and confidence level of 95%. The resulting size
is presented in Table 2. Notably, all of the samples were picked up
randomly.Foreachoftheresulting1,818abbreviations,weasked
three developers to manually determine whether they should be
expanded.Eachofthethreedevelopershadthreetofiveyearsof
programming,andmorethanthreeyearsofJavaexperience.We
requested them to expand the abbreviations and make decisions
independently.Theywereallowedtoaccessthecontext,butwedidnot givethemtrainingordesignatedtimetoget familiarwiththe
subjectsystems.Incaseofinconsistence(ineitherexpansionsor
necessity ofexpansion),werequestedthemtodiscusstogetherto
reachanagreement.Duringtheevaluation,eachsamplereceived
exactly three labels from three participants. Following the paper
by Hallgren [ 28], we computed Cohenâ€™s Kappa coefficient [ 19] for
all coder pairs and used the arithmetic mean as the final Kappa.
TheCohenâ€™sKappacoefficientoftheirclassificationisupto0.76,
suggesting anexcellentagreement betweendifferentparticipants.
Fleissâ€™Kappa(0.75)alsoconfirmsthehighagreementamongpar-
ticipants. Notably, the resulting dataset, noted as GoldenSet , would
serve as a benchmark in the following evaluation. Sample abbre-
viations in GoldenSet are classified into two categories. The first
category, called positive samples , are composed of abbreviations
thatrequireexpansion.Theothersbelongtothesecondcategory,
callednegativesamples .
To answer RQ2, we applied SmartExpander to the GoldenSet ,
andcomparedthesuggestionsgeneratedbytheapproachagainst
manual decisions. A generated suggestion on a given abbreviation
is correct if and only if it is identical to the manual decision on
the same abbreviation (provided by the GoldenSet ). To measure the
performanceofSmartExpander,wecomputedclassificationmetrics,
i.e.,accuracy,precision, andrecall.
To answer RQ3, we changed the value of the thresholds and
repeated the evaluation as specified in the preceding paragraph.
Notably, we changed the value of a single threshold at a time to
explicitlyreveal the impactof each threshold.To answer RQ4, we
disabledoneoftheheuristicsatatimeandevaluatedthechangesof
the performance of SmartExpander on the same dataset (i.e., Gold-
enSet). Each of the heuristics was disabled once. To answer RQ5,
we recorded the time SmartExpander took to make suggestions,
andestimatedthe time complexityof SmartExpander.
4.4 RQ1: NotAll Abbreviations Require
Expansion
Table2presentstheresultsofthemanuallabeling(classification)of
thesampledabbreviations.Thesecondcolumnofthetablepresents
the size of the sample, i.e., how many abbreviations have been
picked up for manual labeling. The third column presents the num-
ber of positive abbreviations (among the samples) that request
expansion and the fourth column presents the number of negative
abbreviations that developers suggested to not expand. The last
column presents the rate of positive, i.e., how many percentages of
the samplesare suggestedto be expandedbythe participants.
From the table,we make the following observations:
584ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece YanjieJiang,HuiLiu, YuxiaZhang,Nan Niu,Yuhai Zhao,andLu Zhang
Table 3:PerformanceofSmartExpander
Applications #Sample #TP#FP#TN#FNAccuracyNegativeSamples PositiveSamples
Precision Recall Precision Recall
DavMail 346 7112263 096% 100% 96% 86% 100%
DocFetcher 346 771424411 93% 96% 95% 85% 88%
DrJava 378 5910305 496% 99% 97% 86% 94%
Dubbo 377 4414311 894% 97% 96% 76% 85%
jEdit 371 6712284 895% 97% 96% 85% 89%
Total 1,818 318621,407 31 95% 98% 96% 84% 91%
â€¢First, not all of the abbreviations require expansion. The partici-
pantssuggestedtonotexpandmorethaneightypercentageof
themanuallyanalyzedabbreviations,i.e.,1,469outofthe1,818
are manually classified as negative samples. The finding may
suggest that most of the abbreviations in well-known applica-
tionsareusedproperly,andarepreferredtotheirfullterms.This
findingmayalsoexplainwhy abbreviationsare common.
â€¢Second, the rate of positive/negative is stable, varying slightly
among subject applications. For example, the rate of negative
variesslightlyfrom75%to86%.Thisfindingmaysuggestthatthe
assumption(i.e.,notallabbreviationsrequireexpansion)holds
regardless of application domains and developers of software
applications.
Althoughonly19%=349/1,818ofthesampledabbreviationsshould
be expanded, considering the large number of abbreviations in
source code (e.g., more than twenty thousand abbreviations in
project Dubbo), there could be thousands of abbreviations in a sin-
gleprojectthatshouldbeexpanded.Furthermore,ourresearchcan
be in turn motivated by the fact that the majority of abbreviations
shouldnot be expandedindeed: Developers should not expand all
abbreviationswithautomatedexpansiontools.Instead,theyshould
employ our approach to validate the necessity before expansion.
Toidentifywhatkindofabbreviationsmaynotrequireexpan-
sion,wemanuallyanalyzedthe1,469negativeabbreviations.Our
analysisresultssuggestthatasignificantpart(35%=515/1,469)ofthe
negative abbreviations are popular and well-known abbreviations.
Themostpopularonesincludeâ€œdir"(â€œdirectory"),â€œbuf" (â€œbuffer"),
â€œmsg"(â€œmessage"),â€œurl"(â€œuniformresourcelocator"),andâ€œpos"(â€œpo-
sition").Suchabbreviationsarewell-known,andthuscouldbeused
safely without significantly negative effect in readability of source
code.Wealsoobservethat47%=691/1,469ofthenegativeabbrevi-
ationscomefromvariables/parameterswhosedatatypescontain
thecorrespondingfullterms.Atypicalexampleisâ€œFileInputStream
fis"where â€œfis"stands for â€œfile inputstream".
Fromthe precedinganalysis,we concludethatnot allabbrevia-
tions require expansion. Consequently, highly accurate approaches
to assisting developers and maintainers in deciding which abbrevi-
ationsshouldbe expandedcould be valuable.
4.5 RQ2: SmartExpanderIsAccurate
To answer RQ2, we applied SmartExpander to the sample abbrevia-
tionsfromthesubjectapplications.Evaluationresultsarepresented
inTable3where#ğ‘‡ğ‘ƒ,#ğ¹ğ‘ƒ,#ğ‘‡/u1D441,and#ğ¹/u1D441representthenumbers93% 93%96% 96%97%100%
92%94%96%98%100%
123456Accuracy
Length of Abbreviations (in characters)
Figure 3:ImpactofAbbreviationsâ€™ Length
of true positives, false positives, true negatives, and false nega-
tives,respectively.Notably,abbreviationsthatrequireexpansion
are called positive items, and thus true positives are those that
shouldbeexpandedandaresuggestedtobeexpanded.Precision
andrecallinprocessingnegativeexamplesare ğ‘‡/u1D441/(ğ‘‡/u1D441+ğ¹/u1D441)and
ğ‘‡/u1D441/(ğ‘‡/u1D441+ğ¹ğ‘ƒ),respectively.Precisionandrecallinprocessingpos-
itive examples are ğ‘‡ğ‘ƒ/(ğ‘‡ğ‘ƒ+ğ¹ğ‘ƒ)andğ‘‡ğ‘ƒ/(ğ‘‡ğ‘ƒ+ğ¹/u1D441), respectively.
From the table,we make the following observations:
â€¢First,SmartExpanderisaccurate.Most(95%)oftheabbreviations
are classified correctly, and only 5% of the abbreviations are
misclassified.
â€¢Second,SmartExpanderishighlyaccurateinpickingupnegative
examples, i.e., abbreviations that do not require expansion. In
retrievingsuchnegativeabbreviations,SmartExpanderreachesa
highprecision of98%andahigh recallof 96%.
â€¢The performance varies slightly among subject applications. For
example,itsminimalandmaximalaccuracyis93%(onDecFetcher)
and96%(onDavMailandDrJava),respectively.Itmaysuggest
that SmartExpander is accurate regardless of the application do-
mainsanddevelopers of the subjectapplications.
Tofurtherinvestigatethereasonsforincorrectclassification,we
manually analyzed the misclassified 93 abbreviations. Our analysis
results suggest that shorter abbreviations are more challenging
to classify than longer ones. Fig. 3illustrates how abbreviationsâ€™
length inï¬‚uences the performance (accuracy) of SmartExpander.
Fromthisfigure,weobservethattheaccuracyincreaseswiththe
increase in abbreviationsâ€™ length. We also notice that 53% (=49/93)
of the misclassified abbreviations are composed of no more than
two characters. One possible reason for the misclassification of
shorter abbreviations is that the same short abbreviation often has
585Which Abbreviations Should Be Expanded? ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
3HUIRUPDQFH$FFXUDF\ 3UHFLVLRQIRU1HJDWLYH,WHPV 5HFDOOIRU1HJDWLYH,WHPV 3U HFLVLRQIRU3RVLWLYH,WHPV 5HFDOOIRU3RVLWLYH,WHPV
Figure 4:InfluenceofThresholds
different interpretation (full terms) in different contexts. A typi-
cal example is the abbreviation â€œsb" in variable declaration â€œint
sb"fromjEdit[ 2].SmartExpandertakesitasacommonabbrevia-
tion for the given domain and suggests to not expand it because
abbreviationâ€œsb"appearsfrequentlywithinthesameapplication.
However, the expansion (â€œsmall buckets") of this abbreviation is
significantly different from that (â€œStringBuilder") of other common
abbreviations. Consequently, expanding this abbreviation helps re-
duce the confusion, and thus this abbreviation is manually labelled
aspositive (requiringexpansion).Notably, SmartExpander cannot
distinguish different abbreviations by their full expansions during
theofflinedataminingphasebecausetheirfullexpansionsareoften
unavailable.
Another reason for the misclassification is the limited corpus
ofsourcecodeleveragedbySmartExpandertodiscovercommon
abbreviations. For the evaluation, we only leveraged 1,000 open-
source Java applications for this task. As a result, some common
abbreviations, e.g., â€œJDK" (standing for â€œJava Development Kit"),
were missed because most of the leveraged applications did not
containsuchabbreviations.Consequently ,tofurther improveSmar-
tExpander,weshouldcollectmuchmoresourcecodefortheoffline
data mininginfuture.
We conclude based on the preceding analysis that SmartEx-
panderisaccurateregardlessofapplicationdomainsanddevelopers
ofthe subjectapplications.
4.6 RQ3: InfluenceofThresholds
SmartExpanderleveragesthe following thresholds:
â€¢ğ›¼:Theminimalcontextsimilaritybetweenabbreviationson
the samemaximal clique(called minimalcontext similarity ).
â€¢ğ›½: The minimal size of the maximal cliques that represent
common abbreviations (called minimal size of the maximal
cliques).
â€¢ğ›¾: The minimal times a domain-specific common abbreviation
should appear within a single project (called minimal popular-
ity ofdomainabbreviation ).
Intheprecedingevaluation,weleveragedthedefaultvaluesof
the thresholds ( ğ›¼=0.4,ğ›½=15,ğ›¾=25) that were set empirically.
To figure out the inï¬‚uence of different thresholds, we changed the
value of a single threshold at a time and kept intact the default
values of other thresholds. Our evaluation results are presented in
Fig.4.From this figure,we make the following observations:
â€¢First, all of the thresholds have significant inï¬‚uence on recall
in retrieving positive/negative items. Decrease in any of such
thresholdsresultsinreducedrecallinretrievingpositiveitems
andincreasedrecallinretrievingnegativeitems.Notably,such
thresholdsareleveragedtoselectpotentiallynegativeitems,and
thus reducing such thresholds (i.e., relaxing the condition for
theselection)wouldresultinmorepredictednegatives,which
in turn leads to few predicted positives. As a result, recall in
retrievingpositiveitemsisreducedwhereasrecallinretrieving
negative items isincreased.
â€¢Second, increase in any of such thresholds resulted in increased
precision in retrieving negative items and decreased precision in
retrievingpositiveitems.Increasingsuchthresholdsmakesthe
heuristicsmoreconservativeinpredictingnegativeitems.Asa
result, the precision inretrievingnegative items isincreased.
â€¢Finally,theeffectontheaccuracyismorecomplex.Thedefault
values of such thresholds ( ğ›¼=0.4,ğ›½=15,ğ›¾=25) resulted
inthemaximalaccuracywhereasdecreasingorincreasingthe
threshold valuesdecreasedin the accuracyof the approach.
Weconcludebasedontheprecedinganalysisthatthethresholds
havesignificantinï¬‚uenceontheperformanceofSmartExpander,
andthe defaultvaluesresult inthe maximal accuracy.
4.7 RQ4: Eï¬€ect ofHeuristics
As introduced in Section 3, SmartExpander is composed of a se-
quenceofheuristics:length-basedheuristic,context-basedheuristic,
and common-abbreviation based heuristic. To quantitatively inves-
tigatetheeffectofsuchheuristics,wedisabledoneofthematatime
and repeated the evaluation. Evaluation results are presented in
Table4where the first column specifies which heuristic is disabled.
From the table,we make the following observations:
â€¢All of the heuristics are indispensable. Disabling any of them
resultedinsignificantreductioninaccuracyofSmartExpander.
The reduction varied from 4 (disabling length-based heuristic) to
33percentagepoints(disablingcontext-basedheuristic).Thepre-
cision for positive abbreviations and recall for negative abbrevia-
tionssufferssimilarreductionsaswell.Thisfindingmaysuggest
that allthe heuristicsare useful andshould not be dropped.
â€¢Disabling any one of the heuristics could slightly increase the
recallin retrievingpositivesamples.Theincreasevariesfrom2
586ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece YanjieJiang,HuiLiu, YuxiaZhang,Nan Niu,Yuhai Zhao,andLu Zhang
Table 4:Eï¬€ectofHeuristics
Setting AccuracyNegativeSamples PositiveSamples
Precision Recall Precision Recall
Enabling All Heuristics (Default Setting) 95% 98% 96% 84% 91%
Disabling Length-based Heuristic 91% 98% 91% 71% 93%
Disabling Context-based Heuristic 62% 98% 54% 33% 95%
Disabling Common-abbreviation based Heuristic 74% 98% 69% 42% 95%
to4 percentagepoints.Notably, alltheheuristics are designedto
selectnegativesamples,anditemsnotselectedbysuchheuristics
are predicted as positive. Consequently, disabling any of the
heuristics would select few negative samples, and more samples
wouldbepredictedaspositive.Asaresult,therecallinretrieving
positive samples increased. However, we also notice that the
increase is minor. One possible reason is that such heuristics
werehighlyaccurateinselectingnegativeitems,andthusonlya
smallpart(31out1,438)ofthepositiveitemswereimproperly
predictedas negative (i.e.,false negatives)bysuch heuristics.
â€¢Disabling any of the heuristics dose not have any non-negligible
effect on the precision in processing negative abbreviations. The
actual precision in the third column of Table 4should be 97.84%,
98.095%,97.83%,and 98.16%,respectively. Fromsuchvalues, we
canobserveminorchangesinthepr ecision.Ho wever,wepresent
allsuchvaluesinTable 4as98%byroundingthemtothenearest
whole numbers. One possibility reason for such minor impact
is thatalltheheuristics areleveragedindependentlytopick up
negativeabbreviations,andallofthemarehighlyaccurate.As
a result, disabling any of them would not reduce the precision
becausetheremainingheuristicswerehighlyaccurateinpicking
negative abbreviations.
â€¢Disablinganyoftheheuristicsresulted insignificantreduction
in recall for negative abbreviations. The reduction varies from 5
to 42 percentage points. The reason is that the heuristics were
leveraged in parallel to pick up negative abbreviations, and thus
disablinganyofthemwouldreducethenumberoftruenegatives
(andpredictednegativesaswell)thatinturnreducedrecallfor
negative items.
â€¢Context-basedheuristichasthegreatesteffectontheaccuracy
ofSmartExpander.Disablingitreducedtheaccuracyfrom95%to
62%. One possible reason is that a large number of abbreviations
come from names of variables and parameters, and their full
terms appear in the data types of the enclosing variables/param-
eters. A typical example is parameter â€œException e". Disabling
thecontext-basedheuristicwouldmisclassifysuchabbreviations,
whichresultsinsignificantreductionintheperformanceofSmar-
tExpander. Notably, common-abbreviation based heuristic has
the second greatest effect, and disabling it reduced the accuracy
significantly from 95% to 74%. One possible reason is that this
heuristic identified a large number of common abbreviations
successfullyandsuggestedcorrectlyto not expand them.
Fromtheprecedinganalysis,weconcludethatalloftheleveraged
heuristicsare indispensable.Table 5:RuntimeofOnline Classification (in Seconds)
Applications KLOC #Samples Time (s)Time(s)per
Abbreviation
Mail 44 346 108 0.31
Doc 38 346 110 0.32
DrJ 185 378 130 0.34
Dubbo 186 377 154 0.41
jEdit 212 371 163 0.44
TOTAL 666 1,818 665 0.37
0123456
10000 20000 30000 40000 50000 60000Time (hours)
Size of Corpus (KLOC)
Figure 5:ScalabilityofOï¬€line Data Mining
4.8 RQ5: Scalability
ToanswerRQ5,weinvestigatedthescalabilityofSmartExpander
by analyzing the average execution time of SmartExpander on a
single abbreviation. The evaluation is conducted on a personal
computer with Intel Core i7-6700, 16GB RAM, and Windows 10.
Our evaluation results are presented in Table 5whose last column
presentshowmanysecondsSmartExpandertooktoclassifyasingle
abbreviation (i.e., ğ‘‡ğ‘–ğ‘šğ‘’divide by #ğ‘†ğ‘ğ‘šğ‘ğ‘™ğ‘’ğ‘ ). From this table, we
observe that SmartExpander is highly efficient in classifying abbre-
viations.Onaverage,ittookonly 0.37secondstoclassifyasingle
abbreviation. We also observe that time increased slightly with the
increaseofapplicationsize.Onthesmallestapplications( Mail),the
averageprocessingtimeis0.31secondswhereasitincreasedto0.44
seconds on the largest application ( jEdit). One possible reason is
thattheapproachshouldvisitallidentificationswiththeapplica-
tion to determine whether the abbreviation under test represents a
domain-specific common abbreviation (as specified inSection 3.4).
587Which Abbreviations Should Be Expanded? ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece
Thetimecomplexityofthevisitislinearlydependentonthesize
ofthe applications.
Wealsoinvestigatethetimeofofflinedataminingasspecifiedin
Sections3.2-3.3. Compared to the online classification, offline data
miningismuchmoretime-consuming.Ittook4.9hourstofinish
the mining on1,000 applications (containing morethan 50million
lines of source code). To further analyze how the execution time is
inï¬‚uencedbythesizeofsourcecode(called corpus)involvedinthe
data mining, we reduced the size byremoving 200 application at a
timeandrepeatedtheofflinedataminingontheupdatedcorpus.
Our evaluation results are present in Fig. 5. From this figure, we
observe that the execution time is overall linearly dependent on
the size ofthe corpus.
WeconcludefromtheprecedinganalysisthatSmartExpander
(including both offline data mining and online classification) is
efficientandscalable.
4.9 Threatsto Validity
Athreattoconstructvalidityisthatthemanuallabelling(classifica-
tion) of the sampled abbreviations could be incorrect. On one side,
the participants lack system knowledge of the subject applications.
On the other side, the classification is essentially subjective, and
thus it is likely that different participants assign different labels
tothe same abbreviations. However,such inaccurate labels served
as the ground truth for the evaluation, and thus the evaluation
results could be inaccurate. To reduce the threat, we asked three
participants to label abbreviations independently, and requested
them to reach an agreement by discussion in case of inconsistency.
Another threat to validity concerning the manual golden-set
creationisbiasedtooragainstSmartExpander.Iftheparticipants
known in advance how SmartExpander works, they might classify
theabbreviationsasSmartExpanderdoes,whichmayseriouslybias
theevaluationresults.Toreducethethreat,weexcludedtheauthors
of the paper from the manual creation, and recruited developers
whowere not aware ofSmartExpander.
Athreattotheexternalvalidityisthatonly5applicationsand
1,818 abbreviations were involved in the evaluation. The limited
numberofinvolvedapplicationsandabbreviationsmaythreaten
thegeneralityoftheconclusions,i.e.,theextenttowhichsuchcon-
clusions canbe generalized to other situations (otherapplications
andabbreviations).Toreducethethreat,weselectedwell-known
applications from different domains and developed by different
teams.EvaluationresultssuggestthatSmartExpanderisaccurate
on each of the subject applications, regardless of their difference in
domainsanddevelopers.Tofurtherimprovethe generalityofthe
conclusions in future, however, evaluation on more applications
andmore abbreviationsshould be conducted.
Another threat to the external validity is that we sampled abbre-
viationswithoutconsideringtheirassociatedelementtypes(e.g.,
variableorclassnames).Ifthedistributionofabbreviationspertype
in the sample does not follow the distribution in the population, it
maynegativelyimpactthe validity ofthe study.
The replication package, including implementation of SmartEx-
pander,subject applications,manuallylabelledabbreviations,and
the corpusofsourcecode,is publiclyavailable at [ 31].5 CONCLUSIONSAND FUTUREWORK
Abbreviationsarefrequentlyusedtoshortenidentifiersinsource
code,whichsignificantlyfacilitatestypingandtypesettingofsource
code,especiallycomplexandlengthy expressions. However, ifused
improperly, abbreviationsmayresultinlow readabilityandmain-
tainability of source code. Although approaches haven been pro-
posedtosuggestfulltermsforabbreviations,westilllackautomated
tools in deciding which abbreviations should (or should not) be
replacedwiththeirfullterms.Tothisend,inthispaper,wepropose
such an automated approach based on a sequence of heuristics.
Suchheuristicsconcerndifferentaspectsoftheabbreviations,i.e.,
length, popularity, and contexts. We evaluated the proposed ap-
proach with a large dataset containing 1,818 abbreviations. Our
evaluation results suggest that the proposed approach is accurate,
andthe averageaccuracyis95%.
In future, we would like to investigate how well the proposed
approachcancooperatewithabbreviationexpansiontools.Thecol-
laborationistwofold.Ononeside,ourapproachcouldbeleveraged
toexcludealargenumberofabbreviationsthatdonotrequireex-
pansion. As a result, abbreviation expansion tools can ignore such
abbreviations, and suggest developers with expansions (full terms)
for other abbreviations only. On the other side, the length-based
heuristic (Section 3.2) and the context-based heuristic (Section 3.5)
oftheproposedapproachrequestfulltermsoftheabbreviationsun-
der test. In the evaluation part, we suppose that such full terms are
available (provided manually or by automated tools). In future, we
wouldliketoinvestigatewhethertheautomatedabbreviationex-
pansiontoolscouldserveasthesourceofsuchfulltermsrequested
by the proposed approach, and to what extent its performance
would be inï¬‚uenced by the inaccurate expansions suggested by
such abbreviation expansion tools. It could be fruitful to explore
inmoredepththefactorsconsideredbydeveloperstomaketheir
decisioninabbreviationexpansion,andtoinvestigatethecauses
of disagreement. Finally, to increase the impact of the approach,
wewilldeployourtoolinsomeopen-sourceprojectsandaskfor
developersâ€™ feedbackonthe use of the tool.
ACKNOWLEDGMENTS
The authors would like to say thanks to anonymous reviewers for
their insightful comments and suggestions. This work was spon-
sored in part by the National Natural Science Foundation of China
(61772071,61690205,and61772124).
REFERENCES
[1] 2021. Apache Dubbo. https://github.com/apache/dubbo .
[2]2021. CBZip2OutputStream.java. https://github.com/romuloceccon/jedit/blob/
master/installer/CBZip2OutputStream.java#L969 .
[3] 2021. Cosine Similarity. https://en.wikipedia.org/wiki/Cosine_similarity .
[4] 2021. DavMail Gateway. https://github.com/mguessan/davmail .
[5] 2021. DocFetcher. https://github.com/vivainio/docfetcher .
[6] 2021. DrJava. https://github.com/DrJavaAtRice/drjava .
[7] 2021. jEdit. https://github.com/romuloceccon/jedit .
[8] 2021. Sample Size Calculator. https://www.surveysystem.com/sscalc.htm .
[9]2021. StanfordNLP. https://github.com/stanfordnlp/CoreNLP/blob/master/src/
edu/stanford/nlp/process/Stemmer.java .
[10]Eytan Adar. 2004. SaRAD: a Simple and Robust Abbreviation Dictionary. Bioin-
form.20,4 (2004), 527â€“533. https://doi.org/10.1093/bioinformatics/btg439
[11]UriAlon,MeitalZilberstein,OmerLevy,andEranYahav.2019.code2vec:learning
distributedrepresentationsofcode. Proc.ACMProgram.Lang. 3,POPL(2019),
40:1â€“40:29. https://doi.org/10.1145/3290353
588ESEC/FSE â€™21, August 23â€“28, 2021,Athens,Greece YanjieJiang,HuiLiu, YuxiaZhang,Nan Niu,Yuhai Zhao,andLu Zhang
[12]A Apostolio and C Guerra. 1985. A fast linear space algorithm for computing
longest common subsequences. (1985).
[13]EranAvidanandDrorG.Feitelson.2017. Effectsofvariablenamesoncompre-
hensionanempiricalstudy.In Proceedingsofthe25thInternationalConference
on Program Comprehension, ICPC 2017, Buenos Aires, Argentina, May 22-23, 2017 ,
Giuseppe Scanniello, David Lo, and Alexander Serebrenik (Eds.). IEEE Computer
Society, 55â€“65. https://doi.org/10.1109/ICPC.2017.27
[14]DavidW.Binkley,DawnJ.Lawrie,SteveMaex,andChristopherMorrell.2009.
Identifierlengthandlimitedprogrammermemory. Sci.Comput.Program. 74,7
(2009), 430â€“445. https://doi.org/10.1016/j.scico.2009.02.006
[15]ImmanuelM.Bomze,MarcoBudinich,PanosM.Pardalos,andMarcelloPelillo.
1999. TheMaximumCliqueProblem. In HandbookofCombinatorialOptimization ,
Ding-ZhuDuandPanosM.Pardalos(Eds.).Springer,1â€“74. https://doi.org/10.
1007/978-1-4757-3023-4_1
[16]CaprileandTonella.2000. Restructuringprogramidentifiernames.In Proceedings
2000 International Conference onSoftware Maintenance . 97â€“107. https://doi.org/
10.1109/ICSM.2000.883022
[17]C. Caprile and P. Tonella. 1999. Nomen est omen: analyzing the language of
function identifiers. In Sixth Working Conference on Reverse Engineering (Cat.
No.PR00303) . 112â€“122. https://doi.org/10.1109/WCRE.1999.806952
[18]NunoRamosCarvalho, JosÃ©JoÃ£oAlmeida,PedroRangel Henriques,andMaria
JoÃ£o Varanda Pereira. 2015. From source code identifiers to natural language
terms.J.Syst.Softw. 100(2015),117â€“128. https://doi.org/10.1016/j.jss.2014.10.013
[19]JacobCohen.1960. Acoefficientofagreementfornominalscales. Educational
and psychological measurement 20,1 (1960), 37â€“46.
[20]AnnaCorazza,SergioDiMartino,andValerioMaggio.2012. LINSEN:Aneffi-
cientapproachtosplitidentifiersandexpandabbreviations.In 28thIEEEInterna-
tionalConferenceonSoftwareMaintenance,ICSM2012,Trento,Italy,September
23-28, 2012 . IEEE Computer Society, 233â€“242. https://doi.org/10.1109/ICSM.2012.
6405277
[21]FlorianDeissenboeckandMarkusPizka.2006. Conciseandconsistentnaming.
Softw. Qual. J. 14, 3 (2006),261â€“282. https://doi.org/10.1007/s11219-006-9219-1
[22]Oxford English Dictionary. 1989. Oxford English Dictionary. Simpson, John A. &
Weiner,EdmundS.C. (1989).
[23]DavidEppstein,MaartenLÃ¶ffler,andDarrenStrash.2013. Listingallmaximal
cliquesinlargesparsereal-worldgraphs. JournalofExperimentalAlgorithmics
(JEA)18(2013), 3â€“1.
[24]David Eppstein and Darren Strash. 2011. Listing all maximal cliques in large
sparsereal-worldgraphs.In InternationalSymposiumonExperimentalAlgorithms .
Springer, 364â€“375.
[25]Sarah Fakhoury, Yuzhan Ma, Venera Arnaoudova, and Olusola O. Adesope. 2018.
Theeffectof poorsourcecodelexicon andreadabilityondevelopersâ€™cognitive
load. InProceedings of the 26th Conference on Program Comprehension, ICPC 2018,
Gothenburg,Sweden,May27-28,2018 ,FoutseKhomh,ChanchalK.Roy,andJanet
Siegmund (Eds.). ACM,286â€“296. https://doi.org/10.1145/3196321.3196347
[26]HenryFeild,DavidBinkley,andDawnLawrie.2006. Anempiricalcomparisonof
techniquesforextractingconceptabbreviationsfromidentifiers.In Proceedings
of IASTED International Conference on Software Engineering and Applications
(SEAâ€™06).
[27]LatifaGuerrouj,PhilippeGalinier,Yann-GaÃ«lGuÃ©hÃ©neuc,GiulianoAntoniol,and
Massimiliano Di Penta. 2012. TRIS: A Fast and Accurate Identifiers Splitting and
ExpansionAlgorithm.In 201219thWorkingConferenceonReverseEngineering .
103â€“112. https://doi.org/10.1109/WCRE.2012.20
[28]Kevin A Hallgren. 2012. Computing Inter-Rater Reliability for Observational
Data:AnOverviewandTutorial. TutorQuantMethodsPsychol 8,1(2012),23â€“34.
[29]Emily Hill, Zachary P. Fry, Haley Boyd, Giriprasad Sridhara, Yana Novikova,
Lori L. Pollock, and K. Vijay-Shanker. 2008. AMAP: automatically mining ab-
breviationexpansionsinprogramstoenhancesoftwaremaintenancetools.In
Proceedings of the 2008 International Working Conference on Mining Software
Repositories, MSR 2008 (Co-located with ICSE), Leipzig, Germany, May 10-11, 2008,
Proceedings ,AhmedE.Hassan,MicheleLanza,andMichaelW.Godfrey(Eds.).
ACM,79â€“88. https://doi.org/10.1145/1370750.1370771
[30]Johannes C. Hofmeister, Janet Siegmund, and Daniel V. Holt. 2019. Shorter
identifier names take longer to comprehend. Empir. Softw. Eng. 24, 1 (2019),
417â€“443. https://doi.org/10.1007/s10664-018-9621-x
[31]Yanjie Jiang. 2021. SmartExpander and Replication Package. https://github.com/
jiangyanjie/smartExpander .
[32]Yanjie Jiang, Hui Liu, Jiahao Jin, and Lu Zhang. 2020. Automated Expansion
of Abbreviations Based on Semantic Relation and Transfer Expansion. IEEE
TransactionsonSoftwareEngineering (2020),1â€“1. https://doi.org/10.1109/TSE.
2020.2995736
[33]YanjieJiang,HuiLiu,andLuZhang.2019. SemanticRelationBasedExpansion
of Abbreviations. In Proceedings of the 2019 27th ACM Joint Meeting on European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering (Tallinn,Estonia) (ESEC/FSE2019) .AssociationforComputingMa-
chinery, New York, NY, USA, 131â€“141. https://doi.org/10.1145/3338906.3338929[34]Yanjie Jiang, Hui Liu, Jiaqi Zhu, and Lu Zhang. 2020. Automatic and Accu-
rateExpansionofAbbreviationsinParameters. IEEETransactionsonSoftware
Engineering 46,7 (2020), 732â€“747. https://doi.org/10.1109/TSE.2018.2868762
[35]Dawn J. Lawrie and David W. Binkley. 2011. Expanding identifiers to normalize
sourcecodevocabulary.In IEEE27thInternationalConferenceonSoftwareMainte-
nance, ICSM 2011, Williamsburg, VA, USA, September 25-30, 2011 . IEEE Computer
Society, 113â€“122. https://doi.org/10.1109/ICSM.2011.6080778
[36]DawnJ.Lawrie,DavidW.Binkley,andChristopher Morrell.2010. Normalizing
Source Code Vocabulary. In 17th Working Conference on Reverse Engineering,
WCRE 2010, 13-16 October 2010, Beverly, MA, USA , Giuliano Antoniol, Martin
Pinzger, and Elliot J. Chikofsky (Eds.). IEEE Computer Society, 3â€“12. https:
//doi.org/10.1109/WCRE.2010.10
[37]DawnJ.Lawrie,HenryFeild,andDavidW.Binkley.2007. ExtractingMeaning
fromAbbreviatedIdentifiers.In SeventhIEEEInternationalWorkshoponSource
CodeAnalysisandManipulation(SCAM2007),September30-October1,2007,Paris,
France. IEEE Computer Society, 213â€“222. https://doi.org/10.1109/SCAM.2007.17
[38]DawnJ.Lawrie,ChristopherMorrell,HenryFeild,andDavidW.Binkley.2006.
Whatâ€™sinaName?AStudyofIdentifiers.In 14thInternationalConferenceonPro-
gramComprehension(ICPC2006),14-16June2006,Athens,Greece .IEEEComputer
Society, 3â€“12. https://doi.org/10.1109/ICPC.2006.51
[39]DawnJ.Lawrie,ChristopherMorrell,HenryFeild,andDavidW.Binkley.2007.
Effective identifier names for comprehension and memory. Innov. Syst. Softw.
Eng.3,4 (2007), 303â€“318. https://doi.org/10.1007/s11334-007-0031-2
[40]Quoc V.Le and TomÃ¡s Mikolov.2014. Distributed Representations of Sentences
andDocuments.In Proceedingsofthe31thInternationalConferenceonMachine
Learning,ICML2014,Beijing,China,21-26June2014 (JMLRWorkshopandCon-
ference Proceedings, Vol. 32) . JMLR.org, 1188â€“1196. http://proceedings.mlr.press/
v32/le14.html
[41]Guangjie Li, Hui Liu, Ge Li, Sijie Shen, and Hanlin Tang. 2020. LSTM-based
argument recommendation for non-API methods. Sci. China Inf. Sci. 63, 9 (2020),
1â€“22.https://doi.org/10.1007/s11432-019-2830-8
[42]Guangjie Li, Hui Liu, and Ally S. Nyamawe. 2020. A Survey on Renamings of
SoftwareEntities. ACMComput.Surv. 53,2(2020),41:1â€“41:38. https://doi.org/
10.1145/3379443
[43]HuiLiu,QiurongLiu,YangLiu,andZhoudingWang.2015. IdentifyingRenaming
Opportunities by Expanding Conducted Rename Refactorings. IEEE Transactions
on Software Engineering 41, 9 (2015), 887â€“900. https://doi.org/10.1109/TSE.2015.
2427831
[44]MirceaLunguandJanKurÅ¡.2013. Onplanninganevaluationoftheimpactof
identifiernamesonthereadabilityandqualityofsmalltalkprograms.In 20132nd
International Workshop on User Evaluations for Software Engineering Researchers
(USER). 13â€“15.https://doi.org/10.1109/USER.2013.6603079
[45]Nioosha Madani, Latifa Guerrouj, Massimiliano Di Penta, Yann-GaÃ«l GuÃ©hÃ©neuc,
andGiulianoAntoniol.2010. RecognizingWordsfromSourceCodeIdentifiers
UsingSpeechRe cognitionTechniques. In 14thEuropeanConferenceonSoftware
Maintenance and Reengineering, CSMR 2010, 15-18 March 2010, Madrid, Spain ,
RafaelCapilla,Rudolf Ferenc,and JuanC.DueÃ±as(Eds.).IEEE ComputerSociety,
68â€“77.https://doi.org/10.1109/CSMR.2010.31
[46]Christian Donald Newman, Michael John Decker, Reem S. Alsuhaibani, Anthony
Peruma,DishantKaushik,andEmilyHill.2019. AnEmpiricalStudyofAbbrevia-
tionsandExpansionsinSoftwareArtifacts.In 2019IEEEInternational Conference
onSoftware Maintenance and Evolution, ICSME 2019,Cleveland,OH,USA, Septem-
ber29-October4,2019 .IEEE,269â€“279. https://doi.org/10.1109/ICSME.2019.00040
[47]Patric RJ Ã–stergÃ¥rd. 2002. A fast algorithm for the maximum clique problem.
DiscreteAppliedMathematics 120, 1-3 (2002), 197â€“207.
[48]Giuseppe Scanniello and Michele Risi. 2013. Dealing with Faults in Source Code:
Abbreviatedvs.Full-WordIdentifierNames.In 2013IEEEInternationalConference
onSoftwareMaintenance,Eindhoven,TheNetherlands,September22-28,2013 .IEEE
Computer Society, 190â€“199. https://doi.org/10.1109/ICSM.2013.30
[49]AndreaSchankin,AnnikaBerger,DanielV.Holt,JohannesC.Hofmeister,Till
Riedel,andMichaelBeigl.2018. Descriptivecompoundidentifiernamesimp rove
source code comprehension. In Proceedings of the 26th Conference on Program
Comprehension, ICPC 2018, Gothenburg, Sweden, May 27-28, 2018 , Foutse Khomh,
Chanchal K. Roy, and Janet Siegmund (Eds.). ACM, 31â€“40. https://doi.org/10.
1145/3196321.3196332
[50]Alaaeddin Swidan, Alexander Serebrenik, and Felienne Hermans. 2017. How
do Scratch Programmers Name Variables and Procedures?. In 17th IEEE Inter-
nationalWorkingConferenceonSourceCodeAnalysisandManipulation,SCAM
2017, Shanghai, China, September 17-18, 2017 . IEEE Computer Society, 51â€“60.
https://doi.org/10.1109/SCAM.2017.12
[51]Porfirio Tramontana, Michele Risi, and Giuseppe Scanniello. 2014. Studying
abbreviated vs. full-word identifier names when dealing with faults: an external
replication. In 2014 ACM-IEEE International Symposium on Empirical Software
Engineering and Measurement, ESEM â€™14, Torino, Italy, September 18-19, 2014 ,
Maurizio Morisio, Tore DybÃ¥, and Marco Torchiano (Eds.). ACM, 64:1. https:
//doi.org/10.1145/2652524.2652593
589