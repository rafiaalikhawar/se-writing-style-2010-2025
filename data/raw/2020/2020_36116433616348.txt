BigDataflow: A Distributed Interprocedural Dataflow Analysis
Framework
Zewen Sun∗
Nanjing University, China
sunzew@smail.nju.edu.cnDuanchenXu∗
Nanjing University, China
mf1933108@smail.nju.edu.cnYiyu Zhang∗
Nanjing University, China
zhangyy0721@smail.nju.edu.cn
Yun Qi∗
Nanjing University, China
mf20330058@smail.nju.edu.cnYueyangWang∗
Nanjing University, China
181860105@smail.nju.edu.cnZhiqiang Zuo∗†
Nanjing University, China
zqzuo@nju.edu.cn
Zhaokang Wang∗
Nanjing University, China
wang.zk@foxmail.comYueLi∗
Nanjing University, China
yueli@nju.edu.cnXuandongLi∗
Nanjing University, China
lxd@nju.edu.cn
Qingda Lu
AlibabaGroup, UnitedStates
qingda.lu@alibaba-inc.comWenwen Peng
AlibabaGroup, China
wenwen.pww@alibaba-inc.comShengjianGuo
Baidu Research,UnitedStates
guosj@vt.edu
ABSTRACT
Apart from forming the backbone of compileroptimization, static
data/f_lowanalysishasbeenwidelyappliedinavastvarietyofappli-
cations,suchasbugdetection,privacyanalysis,programcompre-
hension,etc.Despiteitsimportance,performinginterprocedural
data/f_low analysis on large-scale programs is well known to be
challenging. In this paper, we propose a novel distributed analysis
framework supporting the general interprocedural data/f_low analy-
sis. Inspired by large-scale graph processing, we devise a dedicated
distributedworklistalgorithmtailoredforinterproceduraldata/f_low
analysis. We implement the algorithm and develop a distributed
frameworkcalledBigData/f_lowrunningonalarge-scalecluster.The
experimental results validate the promising performance of Big-
Data/f_low – it can /f_inish analyzing the program of millions lines of
code in minutes. Compared with the state-of-the-art, BigData/f_low
achieves muchmore analysiseﬃciency.
CCS CONCEPTS
•Software and its engineering →General programming lan-
guages;•Theoryofcomputation →Programanalysis ;•Com-
puting methodologies →Distributedalgorithms.
KEYWORDS
interproceduraldata/f_lowanalysis,distributedcomputing
∗AlsowithStateKeyLaboratoryforNovelSoftwareTechnologyatNanjingUniversity.
†Corresponding author.
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forpro/f_itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe/f_irstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeci/f_icpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’23, December 3–9, 2023, San Francisco, CA,USA
©2023 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 979-8-4007-0327-0/23/12...$15.00
https://doi.org/10.1145/3611643.3616348ACMReference Format:
ZewenSun,DuanchenXu,YiyuZhang,YunQi,YueyangWang,Zhiqiang
Zuo, Zhaokang Wang, Yue Li, Xuandong Li, Qingda Lu, Wenwen Peng,
and Shengjian Guo. 2023. BigData/f_low: A Distributed Interprocedural
Data/f_lowAnalysisFramework.In Proceedingsofthe31stACMJointEuropean
Software Engineering Conference and Symposium on the Foundations of Soft-
wareEngineering(ESEC/FSE’23),December3–9,2023,SanFrancisco,CA,USA.
ACM,NewYork,NY,USA, 13pages.https://doi.org/10.1145/3611643.3616348
1 INTRODUCTION
Data/f_lowanalysisisatechniqueforstaticallygatheringprogram
information at program points along the program’s control /f_low.
Besidesformingthebackboneofcompileroptimization,ithasbeen
adopted in many other signi/f_icant application areas, including bug
detection [ 37,45], security vulnerability discovery [ 22], privacy
analysis [ 3], program testing/debugging [ 43,49], etc. In a data/f_low
analysis, a separate data/f_low fact is maintained at each program
point under the control /f_low graph (CFG) representation. Based
on the eﬀect of each statement, a transfer function is applied to
transformthe data/f_low factaccordinglyalong the CFG. The trans-
formation process is performed iteratively via a worklist algorithm
until a /f_ixed point is reached [ 29], meaning that all the data/f_low
facts are unchangedanymore.
Challenges. Despite its importance, performing interprocedural
data/f_low analysis on large-scale systems code is well known to be
challenging. First, as modern real-world programs are usually of
largescale(likemillionlinesofcode),maintainingsolutionsatall
program points with limited memorycan hardly be scalable. Even
worse,forcertainanalysis,thedata/f_lowsolutionmaintainedateach
pointitselfishighlyspace-intensive.Althoughpriorworkattempts
to adopt sparse representations [ 7,15,33,45], the huge memory
consumption still severely limits the scalability. As evidenced by
recentstudies[ 41,53],theanalysisoversparsevalue-/f_lowgraph
can easily exceed hundreds of Gigabytes, showing the memory
consumptionafactualbottleneck.Second,thecomputationof/f_low-
sensitive analysisrequires updating the data/f_low factwith respect
1431ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA ZewenSun,et al.
toeachstatementalongtheCFGbyperformingthetransferfunc-
tion. The process is highly computation-intensive because: (1) the
amountoftransferfunctionexecutedisatleastlinearinthenumber
ofprogramstatements,whichislarge-scalegiventhemodernlarge-
sizesoftwareunderanalysis;(2)thecomputationofeachtransfer
function is perhaps expensive as well. For instance, in the /f_low-
sensitive pointer/aliasanalysis, thedata/f_lowfact at eachprogram
point should capture the aliasinformation among allthe variables
in the entire program. Updating variable relations by each transfer
function consumeshigh CPUcycles.
State-of-the-Art. Toaccelerateinterproceduraldata/f_lowanaly-
sis,afewattemptstodistribute/parallelizethecomputationhave
been made. For distributed approaches, Garbervetsky et al. [ 10]
presented a distributed worklist algorithm on the basis of the actor
model.Howeverasstatedexplicitlyintheirpaper,itcannotsupport
the standard data/f_low analysis due to the lack of /f_low ordering be-
tweenactors.Albarghouthietal.[ 2]parallelizedthedemand-driven
top-down analyses based on MapReduce paradigm. They only tar-
getedveri/f_icationandsoftwaremodelcheckingwithoutsupporting
data/f_lowanalysis.BigSpa[ 14,51]supportsthedistributedaccelera-
tionforCFLreachability-basedanalysis[ 34].Unfortunately,alot
of data/f_low analyses, e.g., cache analysis and numerical analysis,
do not belong to this category. Greathouse et al. [ 13] proposed
scalabledata/f_lowanalysis.However,theyfocusedondynamicanal-
ysisratherthanstaticanalysis.Inbrief,thereexistnodistributed
systemssupportingstaticdata/f_lowanalysis.
Asforparallelapproaches,LeeandRyder[ 23]exploitedalgorith-
micparallelismtoacceleratedata/f_lowanalysis.Rodriguezetal.[ 36]
proposedanactormodel-basedparallelalgorithmforinterprocedu-
ral/f_initedistributivesubset(IFDS)analysis[ 35].Moreover,some
researchers[ 31,44]alsostudiedparallelalgorithmsforpointeranal-
ysis. Note that the above approaches only support speci/f_ic analysis
rather than the general class of data/f_low analyses. More impor-
tantly,theyrelyheavilyonmemoryforcomputation.Thereisno
doubt that they can rarely scale to large systems such as Linux
kernel[1,53].Recently,Zuoetal.[ 53]developedChianina,asin-
gle machine-based analysis framework which can scale general
data/f_low analysis to millions lines of code. Unfortunately, due to
the involvement of disks, it readily takes hours or even days to
/f_inishtheanalysisforlarge-scaleprograms.Suchineﬃciencycan
hardly meet the requirement of quick analysis response (usually
in minutes) in the modern continuous integration and deployment
(CI/CD) pipelines [ 8,38].
OurWork. Withtheadventofcloudcomputing,thelarge-scale
distributed cluster of commodity computers has become prevalent.
Itnotonlyoﬀerspowerfulcomputingcapability,butnowadayscan
beeasilyaccessiblebyasingledeveloper.Exploitingcloudresources
for static analysis would be the promising breakthrough point for
achieving both signi/f_icant scalability and eﬃciency. However, as
mentioned earlier, there exists no distributed system running on a
cluster whichcan support the general data/f_low analysis.Adapting
theexistingparallelalgorithms(suchasChianina)todistributeden-
vironmentisnon-trivial.Parallelalgorithmsonlyfocusoncomputa-
tion on shared memory, which lacks the consideration of partition-
ing, task dispatching, fault tolerance, and eﬃcient communications
between cluster nodes. None of the existing parallel approachescan directly do it without re-designing and re-implementing the
system. In this work, we propose a novel system that can leverage
large-scaledistributedcloudresourcestoscaleandacceleratethe
general class of interprocedural data/f_low analyses. In particular,
itonlytakesminutestoanalyzetheprogramsofmillionslinesof
code providedthat acluster of 125commodity PCs.
Inspiredbylarge-scalegraphprocessing[ 20,27,28],werevisit
thetraditionalworklistalgorithmfromtheperspectiveof distributed
vertex-centriccomputationmodel ,anddeviseadedicateddistributed
worklistalgorithmtailoredforinterproceduraldata/f_lowanalysis.
Weimplementthedistributedalgorithmatopthegeneraldistributed
graphprocessingplatform( i.e.,ApacheGiraph[ 6,39])anddevelop
a framework named BigData/f_low running on the cloud so as to
take full advantage of the modern distributed computing resources.
The underlying platform ( i.e., Apache Giraph) provides the basic
functionalitiestosupportreliableandrobustdistributedprocessing,
includinginput partitioning,task dispatching,cross-nodecommu-
nications,andfaulttolerance.BigData/f_low,asagenericframework,
provides severalAPIstospecifythetransferfunctions andmerge
operatorsimilartoothermonotonedata/f_lowframeworks[ 5,32],
thusalleviatingtheburdenofimplementingvariousclientanaly-
ses. By/f_illing these APIs,users canreadily implement a particular
data/f_lowanalysisontop of BigData/f_low.
Contributions. The contributionsare listedas follows:
•We devise an optimized distributed vertex-centric computa-
tion model to accelerate staticdata/f_low analysis by leverag-
inglarge-scale cloud resources.
•We develop and implement a distributed data/f_low analy-
sisframeworkcalledBigData/f_lowrunningonareal-world
cloud,whichprovidesavarietyofhigh-levelAPIstoeasily
implement clientdata/f_lowanalyses.
•We evaluate the performance and scalability of BigData/f_low
over large-scale real-world software systems (e.g., Firefox
and Linux kernel). The experimental results validate the
promisingperformanceofBigData/f_low—itcan/f_inishanalyz-
ingthe program of millions linesof code inminutes.
Outlines. The rest ofthepaper isorganized asfollows.§ 2gives
the necessary background of data/f_low analysis and distributed
graphprocessing. § 3presents the distributed worklistalgorithms
proposed,followedbytheimplementationdetailsofBigData/f_low
in §4. We discuss the programming model provided by our frame-
work to implement various client analyses in § 5. §6describes the
empiricalevaluationofBigData/f_lowintermsofperformanceand
scalability.Wegivecertaindiscussionsin§ 7andreviewtherelated
work in§ 8.Finally,§ 9concludes.
2 BACKGROUND
2.1 IntraproceduralData/f_lowAnalysis
Data/f_low analysis is a technique for gathering program informa-
tionwithrespecttovariousprogrampointsalongprogram/f_lows.A
clientdata/f_lowanalysiscanusuallybeformulatedasaninstanceof
themonotonedata/f_lowanalysisframework[ 19,21],whichconsists
of the analysis domain including operations to copy and merge
domain elements, and the transfer functions over domain elements
with respect to each type of statement in the control /f_low graph
1432BigDataflow: A DistributedInterproceduralDataflowAnalysis Framework ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
(CFG). An iterative worklist algorithm then takes as input an in-
stance of the monotone framework, performs the transfer function
for each program statement iteratively along the CFG, and com-
putesa/f_ixedpointastheanalysisresult[ 18].Algorithm 1shows
the worklist algorithm for forwardanalysisindetail.
Foreachstatement /u1D458intheCFG,twoelements IN/u1D458andOUT/u1D458
representtheincomingandoutgoingdata/f_lowfacts,respectively.
At each merging point of CFG in which case a node /u1D458has multiple
predecessors /u1D45D∈/u1D45D/u1D45F/u1D452/u1D451/u1D460(/u1D458), the incoming data/f_low fact IN/u1D458of
node/u1D458is the combination of all the outgoing facts OUT/u1D45D(shown
as Line4) where⊗indicates the merge operator speci/f_ied by users
which can be meet (for must-analysis) or join (for may-analysis).
Atransferfunctionforstatement /u1D458thentakesasinput IN/u1D458and
returns the new outgoing fact, as shown by Line 5. The worklist
algorithmisconductedalongtheCFGtoupdatethedata/f_lowele-
mentsIN/u1D458andOUT/u1D458for each statement in an iterative manner
until a /f_ixed point is reached, meaning that all the data/f_low facts
are unchangedanymore [ 18].
Algorithm1: Worklist Algorithm for ForwardAnalysis
1W←{allthe entry statements ofthe CFG}
2repeat
3remove/u1D458fromW
4IN/u1D458←⊗/u1D45D∈preds(/u1D458)OUT/u1D45D/*mergefunction*/
5Temp←(IN /u1D458\/u1D43E/u1D43C/u1D43F/u1D43F/u1D458)∪/u1D43A/u1D438/u1D441/u1D458/*transfer function*/
6ifTemp≠OUT/u1D458then
7OUT/u1D458←Temp
8W←W∪ succs(/u1D458)
9untilW≡∅
2.2 Interprocedural Data/f_lowAnalysis
Interprocedural data/f_low analysis takes into account the propa-
gation of data/f_low values across multiple procedures. Context-
sensitive interprocedural analysis distinguishes the distinct calls of
a procedure to eliminate the invalid paths, thus achieving high pre-
cision. Generally, there exist two dominant approaches to context-
sensitiveinterproceduralanalysis,namelythe summary-based(or
functional)approach andthecloning-based approach [40].
Thesummary-basedapproachcommonlyconstructsasummary
(transfer)functionforeachprocedure.Ateachcallsitewherethe
procedure is invoked, the analysis computes the eﬀects of the pro-
cedurebydirectlyapplyingthesummaryfunctiontothespeci/f_ic
inputs at the call site. As such, the re-analysis of the procedure
bodyisavoidedwhileenablingcontextsensitivity.However,itis
not possible to construct such (symbolic) summary functions in
general. Take the pointer analysis as an example, we can hardly
establish a succinct summarization for each procedure since the
eﬀectsofaprocedureareheavilydependentofthealiasrelationsof
theinputsateachcallsite.Theevaluationofasummaryfunctionon
a particular input maynotbe cheaper than reanalyzing thewhole
procedure [ 48]. Another option is the explicit representation, a.k.a.
tabulation method or partial transfer functions [ 30,48]. Given a
/f_inite lattice, it enumerates the summary function as input-output
data/f_lowvaluepairsforeachprocedure.Theoutputvalueofasum-
maryfunctioncanbedirectlyexploitedwhentheidenticalinputvalueisencounteredagainforthesameprocedure.However,asa
largenumberofstatesneedtobemaintained,thisapproachusually
suﬀers from huge spaceconsumption.
The alternative of achieving context-sensitivity is a cloning-
based approach, where a separate clone of the procedure body
is created at each callsite [ 9,47]. As such, each procedure is re-
analyzedunder each callingcontext,preventingtheanalysisfrom
propagatingdata/f_lowvaluesalonginvalidpaths.Inthiswork,we
adopt the cloning-based approach to achieve context-sensitivity.
The basicanalysis logic ofinterprocedural analysisis thesameas
that of intraprocedural analysis shown as Algorithm 1, except that
theCFGbecomestheinterproceduralCFG.Morespeci/f_ically,tocon-
struct the interprocedural CFG, the CFG for each function is /f_irstly
generated.Basedonapre-computedcallgraph,theCFGforeach
functionisclonedandincorporatedintothatofeachofitscallersby
creating assignment edges to connect vertices representing formal
parameters and actual arguments. In order to achieve the sweet
spot between scalability and precision, we can actually perform
cloningonlyatcertainlevels,whichistheoreticallyequivalentto
the/u1D458-CFA callstringapproach [ 42].
2.3 Vertex-Centric GraphProcessing
With the inception of Pregel system [ 27], vertex-centric graph pro-
cessingbecomesahotspotinthelarge-scalegraphprocessingcom-
munity [20]. Following Pregel, various algorithmic techniques and
systems were proposed,such asasynchronous model (GraphLab
[25]),in-memorydataparallelmodel(GraphX[ 12]).Peopleareable
toachieveeﬃcient,scalable,andfault-tolerantgraphcomputing
onalarge clusterofcomputers byleveragingthesesystems.
Algorithm2: Synchronous Vertex-centricGraphProcessing
Data:A:the setofactiveverticesduringprocessing
1repeat
2foreachvertex/u1D458∈Ado inparallel /*doneby system*/
3 Remove/u1D458fromA/*doneby system*/
4 /*perform user-speci/f_ied logic for each vertex, in particular
includingGather, ApplyandScatter*/
5M/u1D458←Gather(/u1D458)/*gathermessagesorinformation
from neighbors*/
6D/u1D458←Apply(M/u1D458,/u1D458)/*updatevalue ofkbased on
gathered information*/
7⟨M,A′⟩←Scatter(D/u1D458,/u1D458)/*activate newvertices
and/or sendout messages*/
8/*synchronize beforenext superstep*/
9Synchronize ()/*doneby system*/
10A←A′/*doneby system*/
11untilA≡∅
Algorithm 2gives the pseudo-code of a synchronous vertex-
centric processing algorithm. Given an initialized set of active ver-
tices,itconductsaniterative computation where eachiteration is
termed as a superstep. At each superstep, all the active vertices in
Aare processed in a distributed and parallel way across the en-
tire cluster. Over each active vertex /u1D458, Gather-Apply-Scatter (a.k.a.,
1433ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA ZewenSun,et al.
GAS model) is performed [ 11]. At /f_irst, the messages or informa-
tionfromitsneighborsaregathered(Line 5).AttheApplyphase,
it updates its associated value D/u1D458according to its current value
and the information gathered (Line 6). Based on the newly com-
putedvalue,itupdatestheactiveverticesaccordingly,and/orsends
necessarymessagestoitsneighbors(Line 7)attheScatterphase.
Beforethenextsuperstep,allthemessagesgeneratedatthecurrent
superstep and active vertices are synchronized (Lines 9-10). The
wholecomputationterminatesuntil noactive vertex isgenerated.
Note that vertex-centric graph processing [ 11,27,28] is a pro-
grammingmodelforimplementing graphprocessingapplications.
Userswritegraphalgorithmsfromtheperspectiveofvertices.They
only need to specify the code executed at each vertex, particu-
larlyGather-Apply-Scatterfunctions(Lines 5-7).Theunderlying
graphprocessingsystemisresponsiblefordividingtheinputlarge-
scalegraphintomultiplepartitions,loadingpartitionsintodiﬀer-
ent cluster nodes, launching multiple threads/processes to execute
user-de/f_ined code simultaneously, performing necessarysynchro-
nizations,optimizingcommunicationamongnodes,maintaining
replicas to ensure faulttolerance,etc.
In this work, we take inspiration from vertex-centric graph
processing, design and implement a distributed framework Big-
Data/f_low tailored to interprocedural data/f_low analysis of large-
scalecode.Similartotheexistinggeneral-purposegraphsystems,
BigData/f_lowprovidesuser-friendlyAPIs( e.g.,mergeandtransfer
functions)based onwhichuserscan readilyimplementtheir own
clientanalyseswithoutworryingaboutscalability.Theintrinsicsys-
tem support under BigData/f_low ensures the distributed capability
inlifting the sophisticatedanalysisto large-scale programs.
3 DISTRIBUTED VERTEX-CENTRIC
WORKLIST ALGORITHM
Inspired by large-scale graph processing, we revisit the classic
worklist algorithm of data/f_low analysis (Algorithm 1) from the
perspective of vertex-centric computation model (Algorithm 2),
andaccordinglypresentour/f_irstdistributedworklistalgorithm, i.e.,
Algorithm 3in§3.1.Thisalgorithmfaithfullyfollowstheclassic
worklistalgorithm,andthusitiseasytounderstand;however,its
scalability isalso limitedunder thedistributed setting.Asaresult,
in§3.2,wefurtherproposeanoptimizedalgorithmthatachieves
betterperformance thanAlgorithm 3as demonstratedin§ 6.
3.1 DistributedWorklist Algorithm
By directly instantiating Gather-Apply-Scatter interface and other
respective data structures in Algorithm 2, we devise the /f_irst dis-
tributed worklist algorithm for data/f_low analysis, which is listed as
Algorithm 3.
Our/f_irstworklistalgorithmtakesasinputalargeinterprocedural
control /f_low graph (CFG) or an arbitrary sparse representation
[7,16,33]. At the beginning, all the entry vertices in the input
CFGareaddedtoWastheinitialactivevertices(Line 1).During
each superstep, the underlying system launches a large number
ofthreads/processestohandlethecomputationoneachvertexin
parallel(Line 3).Oneachvertex /u1D458,allthedata/f_lowfactsfrom /u1D458’s
predecessors are /f_irstly gathered (Line 5). This can be implemented
bydirectlyinvokingtheexistingAPIsprovidedbypull-basedgraphAlgorithm3: Distributed Worklist Algorithm
Data:W:the list ofallactiveverticesduringanalysis;
DS/u1D458:{OUT /u1D45D|/u1D45D∈/u1D45D/u1D45F/u1D452/u1D451/u1D460(/u1D458)}aset containingallthe
data/f_lowfacts of /u1D458’spredecessors
1W←{allthe entry verticesin CFG}
2repeat
3foreachCFG vertex /u1D458∈Wdo inparallel /*doneby */
4 Remove/u1D458fromW/*doneby system*/
5DS/u1D458←GatherAll(/u1D458)/*gatherallthe predecessors’
data/f_lowfacts*/
6IN′
/u1D458←Merge(DS/u1D458)/*merge*/
7OUT′
/u1D458←Transfer(IN′
/u1D458,/u1D458)/*transfer*/
8 ifPropagate (OUT/u1D458,OUT′
/u1D458)then/*propagate*/
9OUT/u1D458←OUT′
/u1D458
10W′←W′∪succs(/u1D458)
11Synchronize ()/*doneby system*/
12W←W′/*doneby system*/
13untilW≡∅
systems (e.g., PowerGraph [ 11]) or designing a pulling mechanism
on top of push-based systems (such as Giraph [ 6]). Next a Merge
function takes all the data/f_low facts gathered from predecessors
(i.e.,DS/u1D458)asinput,andproducestheincomingdata/f_lowfact IN′
/u1D458
(Line6). A transfer function is then performed to generate the new
outgoing data/f_low fact OUT′
/u1D458(Line7). After that, we check if the
updateddata/f_lowfact OUT′
/u1D458isdiﬀerentfromthat( i.e.,OUT/u1D458)at
previoussuperstep.Ifso,thepropagationisemployedtoupdatethe
data/f_lowfactasthenewlycomputedvalue(Line 9).Simultaneously,
all of/u1D458’s successors are activated and put into active list W′for
the nextsuperstep (Line 10).
(a)initial state
 (b)gather and merge
 (c)transferandpropagate
Figure 1:Onesuperstep computation at vertex 4 inAlgo. 3.
Example. Figure1illustratesthecomputationprocedureatvertex
4intheabovealgorithm,wheretheverticeswithyellowbackground
areactive.Vertices 1,2,3arethepredecessorsof 4,and5,6areits
successors. Suppose that at the beginning of a certain superstep,
the active vertex 4has its outgoing data/f_low fact OUT4. Prede-
cessor1hasthenewlyupdated fact OUT′
1,whilepredecessors 2
and3hold the old data/f_low facts OUT2andOUT3, respectively
(shown as Figure 1a). Firstly, all the predecessors’ data/f_low facts
aregatheredasDS4={OUT′
1,OUT2,OUT3}andIN′
4isgen-
eratedbymerging DS4showninFigure 1b.OUT′
4iscomputed
by performing transfer function on IN′
4. Assuming thatOUT′
4
is diﬀerent fromOUT4, propagation is employed so that all the
successors 5and6are markedas active shownas Figure 1c.
1434BigDataflow: A DistributedInterproceduralDataflowAnalysis Framework ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Despitethattheabovealgorithmsucceedsinleveraginglarge-
scaledistributedcomputingresourcestoacceleratedata/f_lowanal-
ysis, it may still suﬀer from poor scalability especially when an-
alyzing large-scale programs such as the Linux kernel or Firefox
(elaboratedshortlyin§ 6).AsshowninAlgorithm 3,eachvertex
hastocollectafullsetofdata/f_lowfactsassociatedwithallitsprede-
cessors(i.e.,DS/u1D458)for computation.In the worst case, the data/f_low
factofeachvertexwouldbemademultiplecopieseachofwhich
is sent to one of its successors. As a result, the total number of
data/f_lowfacts heldin memoryandpassed acrossnetworks grows
exponentiallywiththesizeofinterproceduralcontrol/f_lowgraph
underanalysis.This numbercould be super largeinpracticeespe-
cially when performing context-sensitive analysis over large-scale
programs. Passing/gathering a huge number of expensive data/f_low
factsnotonlyexhauststhepreciousmemoryofaclusterquickly
but also increases the burden of network communications, leading
to poor scalability. We implemented Algorithm 3as a prototype
named BigData/f_low-classic and conducted the empirical evalua-
tionofit.Theexperimentalresultsdiscussedshortlyin§ 6show
that BigData/f_low-classic works well for medium-size programs,
but quickly runs out of memory on a 500-worker cluster when
analyzinglarge-scaleprograms,suchastheLinuxkernelorFire-
fox. In the following (§ 3.2), we propose an optimized algorithm
which addresses the aforementioned limitations by signi/f_icantly
pruningawaythedatagathered,thusachievingbetterscalability
andperformance.
3.2 OptimizedDistributedWorklist Algorithm
Algorithm4: Optimized Distributed Worklist Algorithm
Data:W:the list ofallactiveverticesduringanalysis;
M/u1D458:{OUT′/u1D45D|pis apredecessor ofk }asetcontaining
the data/f_lowfacts of /u1D458’spredecessorswhichareupdated at
previous superstep
1W←{allthe entry verticesin CFG}
2repeat
3foreachCFG vertex /u1D458∈Wdo inparallel
4 Remove/u1D458fromW
5M/u1D458←GatherMessages(/u1D458)/*gatherdata/f_lowfacts of
the updated predecessors*/
6IN′
/u1D458←Merge(M/u1D458,IN/u1D458)/*merge*/
7OUT′
/u1D458←Transfer(IN′
/u1D458,/u1D458)/*transfer*/
8 ifPropagate (OUT/u1D458,OUT′
/u1D458)then/*propagate*/
9OUT/u1D458←OUT′
/u1D458
10 foreachsuccessor/u1D451of/u1D458do
11 SendMessages(/u1D451,OUT′
/u1D458)/*send the updated
data/f_lowfacts to successors*/
12 W′←W′∪{/u1D451}
13IN/u1D458←IN′
/u1D458
14Synchronize ()/*doneby system*/
15W←W′/*doneby system*/
16untilW≡∅
Asdiscussedearlier,eachactivevertexrequiresthedata/f_lowfacts
associated with all its predecessors to complete the computationintheoriginalworklistalgorithm( i.e.,Line4ofAlgorithm 1and
Line6ofAlgorithm 3).Thatiswhyextensivedata/f_lowfactshaveto
be transferred across the cluster network and then merged locally
on each vertex, resulting in poor scalability. To tackle the problem,
we devise an optimized algorithm which prunes the data/f_low facts
to be gathered. In particular, instead of gathering the full set of
data/f_low facts from all the predecessors, only the predecessors’
data/f_lowfactsthatarenewlyupdatedattheprevioussuperstepare
passedandmerged.Sinceasigni/f_icantportionofdata/f_lowfactsare
not changed at one superstep, the optimized algorithm can thus
pruneawaymanyunnecessaryandmemory-consumingdata/f_low
factstobegathered,greatlyreducingtheoverallmessagetraﬃcand
computation cycles for merging. We will discuss the correctness
of such optimization – it produces the same analysis results as the
originalalgorithm, andgive the formalproof shortlyin§ 3.3.
We propose an optimized distributed worklist algorithm shown
asAlgorithm 4.Foreachactivevertex /u1D458,onlythesetofpredeces-
sors’ data/f_low facts which are updated at previous superstep are
gathered.Thiscanbeachievedviathepush-basedmessagepass-
ingmechanism.Speci/f_ically,eachvertex /u1D458passivelyreceives the
messagespassedtoit( i.e.,M/u1D458)fromitspredecessorsatprevious
superstep (Line 5). Each message in fact corresponds to a data/f_low
fact sent from one of the predecessors which is updated at the pre-
vious superstep. Subsequently, the data/f_low facts OUT′/u1D45D∈M/u1D458
aremergedwiththeincomingdata/f_lowfactof /u1D458atlastsuperstep
(i.e.,IN/u1D458)togeneratethenewincomingdata/f_lowfact( i.e.,IN′
/u1D458)
(Line6).We thenupdatethedata/f_low factaccordinglyvia atrans-
fer function (Line 7). Next we check if the updated data/f_low fact
OUT′
/u1D458isdiﬀerentfromthat( i.e.,OUT/u1D458)atprevioussuperstep.If
so, the propagation is employed to update the data/f_low fact as the
newlycomputedvalue(Line 9).Atthesametime, OUT′
/u1D458issent
asa message to eachofitssuccessors /u1D451(Line11),while activating
/u1D451for the nextsuperstep (Line 12).
(a)initial state
 (b)gather and merge
 (c)transferandpropagate
Figure 2:Onesuperstep computation at vertex 4 inAlgo. 4.
Example. Figure2illustratesthecomputationprocedureatvertex
4in Algorithm 4for the same example as Figure 1. Suppose that at
the beginning of a certain superstep, the active vertex 4’s predeces-
sor1has the newly updated fact OUT′
1and sends it as a message
to4atthelastsuperstepdenotedbythedashedarrowsinFigure
2a.The messageisgatheredas M4={OUT′
1}andthenIN′
4is
generatedbyincrementallymergingthedata/f_lowfacts in M4with
IN4shown as Figure 2b. Finally as shown by Figure 2c,OUT′
4
iscomputedbyperformingtransferfunctionon IN′
4.Assuming
thatOUT′
4isdiﬀerentfromOUT4,propagationisemployedto
send the newly updated OUT′
4to all the successors 5and6while
marking themas active.
1435ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA ZewenSun,et al.
3.3 CorrectnessProofofOptimized Algorithm
The underlying rationale of such optimization is that the merge
operation for the general monotone data/f_low analysis satis/f_ies the
accumulative property. In other words, on each active vertex /u1D458,
mergingonlytheupdateddata/f_lowfactsof /u1D458’spredecessorswith
theoldIN/u1D458oflastsuperstepshouldproduceidenticalresultsto
that merging the full set of data/f_low facts of all its predecessors.
The following Theorem 1gives its formalde/f_inition.
Theorem1 (Accumulative Property ).Given an active vertex /u1D458
at superstep /u1D456. Let/u1D45D/u1D45F/u1D452/u1D451/u1D460(/u1D458)be the set of /u1D458’s predecessors. With-
out loss of generality, suppose at superstep /u1D456−1, a partial set
of/u1D458’s predecessors i.e.,/u1D443′(/u1D458) ⊆/u1D45D/u1D45F/u1D452/u1D451/u1D460(/u1D458)update their outgo-
ing data/f_low facts, while the outgoing facts of the remaining i.e.,
/u1D443(/u1D458)=/u1D45D/u1D45F/u1D452/u1D451/u1D460(/u1D458)−/u1D443′(/u1D458)stay unchanged.IN/u1D458andIN′
/u1D458indicate
theincomingdata/f_lowfactof /u1D458atsuperstep /u1D456−1and/u1D456,respectively.
Theaccumulative propertyissatis/f_iedif andonlyif thefollowing
equation holds.
IN′
/u1D458≡IN/u1D458⊗(⊗/u1D45D∈P′(/u1D458)OUT′
/u1D45D)
i.e.,
(⊗/u1D45D∈P(/u1D458)OUT/u1D45D)⊗(⊗/u1D45D∈P′(/u1D458)OUT′
/u1D45D)≡
(⊗/u1D45D∈preds(/u1D458)OUT/u1D45D)⊗(⊗/u1D45D∈P′(/u1D458)OUT′
/u1D45D)
Proof.Generally, there are two cases of monotone data/f_low
analysis, namely (1) increasing analysis with the join operator ⊔
and(2) decreasing analysiswiththe meetoperator ⊓.
For case (1):⊗=⊔and for each predecessor /u1D45D∈/u1D443′(/u1D458),
OUT/u1D45D≤ OUT′/u1D45Dholds where≤denotes the partial order re-
lationand≤isre/f_lexive,anti-symmetricandtransitiveaccording
to its de/f_inition.
As de/f_ined by the⊔operator which computes the least upper
boundoftwoelementsinthelattice,thefollowinginequality 3.1
holds.
OUT′
/u1D45D≤OUT/u1D45D⊔OUT′
/u1D45D (3.1)
Given thatOUT/u1D45D≤ OUT′/u1D45D(for increasing analysis) and
OUT′/u1D45D≤OUT′/u1D45D(≤isre/f_lexive),the following can be deduced:
OUT/u1D45D⊔OUT′
/u1D45D≤OUT′
/u1D45D (3.2)
As≤isanti-symmetric,giveninequalities 3.1and3.2hold,we
can imply the following equation 3.3.
OUT′
/u1D45D≡OUT/u1D45D⊔OUT′
/u1D45D (3.3)
Therefore,for all /u1D45D∈P′(/u1D458),the following equation 3.4holds.
⊔/u1D45D∈P′(/u1D458)OUT′
/u1D45D≡⊔/u1D45D∈P′(/u1D458)(OUT/u1D45D⊔OUT′
/u1D45D)(3.4)
Becausethe⊔operatorinmonotonedata/f_lowanalysisisboth
associative andcommutative,we can imply that:
⊔/u1D45D∈P′(/u1D458)OUT′
/u1D45D≡(⊔/u1D45D∈P′(/u1D458)OUT/u1D45D) ⊔ (⊔/u1D45D∈P′(/u1D458)OUT′
/u1D45D)
(3.5)
Byjoining⊔/u1D45D∈P(/u1D458)OUT/u1D45Dwithbothsidesoftheequation 3.5,
we can getthe following:
(⊔/u1D45D∈P(/u1D458)OUT/u1D45D) ⊔ (⊔/u1D45D∈P′(/u1D458)OUT′
/u1D45D)≡
(⊔/u1D45D∈P(/u1D458)OUT/u1D45D)⊔((⊔/u1D45D∈P′(/u1D458)OUT/u1D45D)⊔(⊔/u1D45D∈P′(/u1D458)OUT′
/u1D45D))
(3.6)Andfurther equation 3.7isdeducedsince⊔isassociative.
(⊔/u1D45D∈P(/u1D458)OUT/u1D45D) ⊔ (⊔/u1D45D∈P′(/u1D458)OUT′
/u1D45D)≡
((⊔/u1D45D∈P(/u1D458)OUT/u1D45D)⊔(⊔/u1D45D∈P′(/u1D458)OUT/u1D45D))⊔(⊔/u1D45D∈P′(/u1D458)OUT′
/u1D45D)
(3.7)
Since equation 3.8holds,
(⊔/u1D45D∈P(/u1D458)OUT/u1D45D) ⊔ (⊔/u1D45D∈P′(/u1D458)OUT/u1D45D)≡⊔/u1D45D∈preds(/u1D458)OUT/u1D45D
(3.8)
The /f_inal equation 3.9for case(1) isthus proved.
(⊔/u1D45D∈P(/u1D458)OUT/u1D45D) ⊔ (⊔/u1D45D∈P′(/u1D458)OUT′
/u1D45D)≡
(⊔/u1D45D∈preds(/u1D458)OUT/u1D45D) ⊔ (⊔/u1D45D∈P′(/u1D458)OUT′
/u1D45D)(3.9)
Example. Weusethevertex4inFigure 2asanexampletodemon-
strate the proof procedure. Assuming that /u1D458=4,/u1D45D/u1D45F/u1D452/u1D451/u1D460(4)=
{1,2,3}. Given that at previous superstep, predecessor 1 updates
its outgoing data/f_low fact, thus /u1D443′(4)={1}and/u1D443(4)=/u1D45D/u1D45F/u1D452/u1D451/u1D460(4)−
/u1D443′(4)={2,3}. The incoming data/f_low fact of 4at previous and
current supersteps are IN4andIN′
4, respectively. For case (1),
suppose each data/f_low fact corresponds to a set. The join opera-
tor⊔indicatesthesetunion ∪.Thepartialorderrelation ≤isset
inclusion⊆.Validatingtheaccumulativepropertyspeci/f_ictothis
example isto prove the following equation holds:
IN′
4≡IN4∪OUT′
1
Giventhejoinoperator ∪andpartialorderrelation ⊆,itisappar-
ent thatthe equation OUT′
1≡OUT 1∪OUT′
1holds according
to3.1and3.2.
OUT′
1≡OUT 1∪OUT′
1
3.6=⇒(OUT 2∪OUT 3)∪OUT′
1≡
(OUT2∪OUT 3)∪(OUT 1∪OUT′
1)
3.7=⇒(OUT 2∪OUT 3)∪OUT′
1≡
(OUT2∪OUT 3∪OUT 1)∪OUT′
1
3.8=⇒IN′
4≡IN4∪OUT′
1
For case (2):⊗=⊓and for each predecessor /u1D45D∈/u1D443′(/u1D458),
OUT′/u1D45D≤OUT/u1D45Dholds.We can followthe similar proof logic.
Asthemeet⊓operatorcalculatesthegreatestlowerboundof
elements, the following inequality 3.10holds.
OUT/u1D45D⊓OUT′
/u1D45D≤OUT′
/u1D45D (3.10)
Given thatOUT′/u1D45D≤ OUT/u1D45D(for decreasing analysis) and
OUT′/u1D45D≤OUT′/u1D45D(≤isre/f_lexive),the following can be deduced:
OUT′
/u1D45D≤OUT/u1D45D⊓OUT′
/u1D45D (3.11)
As≤is anti-symmetric, given inequalities 3.10and3.11, the
following equation 3.12can be concluded.
OUT′
/u1D45D≡OUT/u1D45D⊓OUT′
/u1D45D (3.12)
1436BigDataflow: A DistributedInterproceduralDataflowAnalysis Framework ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Therefore,we can imply the following equations.
⊓/u1D45D∈P′(/u1D458)OUT′
/u1D45D≡⊓/u1D45D∈P′(/u1D458)(OUT/u1D45D⊓OUT′
/u1D45D)
⇒⊓/u1D45D∈P′(/u1D458)OUT′
/u1D45D≡(⊓/u1D45D∈P′(/u1D458)OUT/u1D45D) ⊓ (⊓/u1D45D∈P′(/u1D458)OUT′
/u1D45D)
⇒(⊓/u1D45D∈P(/u1D458)OUT/u1D45D) ⊓ (⊓/u1D45D∈P′(/u1D458)OUT′
/u1D45D)≡
(⊓/u1D45D∈P(/u1D458)OUT/u1D45D)⊓((⊓/u1D45D∈P′(/u1D458)OUT/u1D45D) ⊓ (⊓/u1D45D∈P′(/u1D458)OUT′
/u1D45D))
⇒(⊓/u1D45D∈P(/u1D458)OUT/u1D45D) ⊓ (⊓/u1D45D∈P′(/u1D458)OUT′
/u1D45D)≡
((⊓/u1D45D∈P(/u1D458)OUT/u1D45D) ⊓ (⊓/u1D45D∈P′(/u1D458)OUT/u1D45D))⊓(⊓/u1D45D∈P′(/u1D458)OUT′
/u1D45D)
⇒(⊓/u1D45D∈P(/u1D458)OUT/u1D45D) ⊓ (⊓/u1D45D∈P′(/u1D458)OUT′
/u1D45D)≡
(⊓/u1D45D∈preds(/u1D458)OUT/u1D45D) ⊓ (⊓/u1D45D∈P′(/u1D458)OUT′
/u1D45D) (3.13)
As equations 3.9and3.13hold for each case, we ultimately com-
plete the proofofTheorem 1.
□
4 IMPLEMENTATION
WeimplementedBigData/f_lowbyfollowingthedistributedworklist
algorithm on top of Apache Giraph 1.4.01, a well-maintained open
sourceJava implementationofPregel[ 6,39].
Giraph replicates Pregel’s concepts and adds several new fea-
tures to this model, including master computation, out-of-core
computation, and sharded aggregators, etc. In particular, Giraph
/f_irstdividestheinputgraphintoanumberofpartitionsbasedon
Hadoopdistributed/f_ile system.WithineachsuperstepoftheBSP
model, Giraph launches multiple workers and enables each worker
to process a partition separately in a distributed way. Giraph oﬀers
multipleeﬀectivepartitioningschemes,whichBigData/f_lowdirectly
adopts to achieve goodworkload balanceandscalability.
Besides, BigData/f_low leverages two extra options oﬀeredby Gi-
raphtorealizethepulled-basedworklistalgorithm.(1)BasicCompu-
tation Class. BasicComputationis a general option for performing
computations in Giraph. It can be used to access the graph’s infor-
mation,suchasthesuperstepIDandinformationofverticesand
edges. We extend it to distinguish analysis phase and acquire edge
informationintheimplementationofBigData/f_low.(2)Broadcast
Class.Broadcastisthesimplestwayformasternodetocommuni-
cate with worker nodes in the scope of the entire cluster, ensuring
that all vertices access the same information. BigData/f_low exploits
this feature to broadcast workers ofentry nodes inCFG.
5 PROGRAMMING MODEL
BigData/f_lowasaframeworksupportingthegeneralinterprocedural
data/f_lowanalysis,providesasetofnecessaryAPIstousers.Users
readily implement a particular client analysis based on these APIs
byspecifyingtheinformationofinputCFG,thedata/f_lowequations
(i.e.,merge,transfer),andthepropagationlogic.Inthefollowing,
we /f_irst discuss the crucial APIs provided by BigData/f_low, then
demonstrate how to implement a client analysis based on the APIs.
5.1 APIs
Givenacontrol/f_lowgraphorothersparserepresentation[ 16,33],
BigData/f_low takes it as input and constructs the graph in memory.
During a data/f_low analysis, each vertex in the CFG maintains a
1https://giraph.apache.org/data/f_lowfact,aswellastheprogramstatementsassociated.Lines
1-4inlisting 1showtheabstractclassof VertexAttribute ,which
de/f_inestwomembers:data/f_lowfactofabstractclass Factandstate-
mentsofclass Stmts.Data/f_lowfactdescribesthedata/f_lowinforma-
tion computed at each program point during analysis. The abstract
classFact(Line6)leavesuserstheinterfaceforspecifyingapar-
ticular type of data/f_low fact in a client analysis. Stmts(Lines9-11)
describesthesetofstatementsassociatedwiththevertex,which
determines the logic of transfer functions. In a statement-level
data/f_low analysis,data/f_low factis associatedwitheachstatement,
whereaninstanceof Stmtscontainsonesinglestatement.While
inabasicblock-levelanalysis,eachinstanceof Stmtsindicatesa
setofstatements inabasic block.
Listing 1:The APIs.
1abstract class VertexAttribute{
2Fact fact;
3Stmts stmts;
4}
5
6abstract class Fact{}
7
8abstract class Stmt {}
9classStmts {
10Stmt[] stmts;
11}
12
13interface Analysis {
14Fact merge(Set<Fact> predFacts, Fact oldIN);
15Fact transfer(Stmts stmts, Fact inFact);
16boolean propagate(Fact oldFact, Fact newFact);
17}
Besidestheabovecrucialdatastructures,threenecessarycom-
ponents of data/f_low analysis are de/f_ined in the Analysis interface
shown as Lines 13-17in listing 1. Whenever the computation on a
vertex/u1D458islaunched, merge() is/f_irstinvokedtotakethenewlyup-
dateddata/f_lowfactsofpredecessorstogetherwiththeoldincoming
fact, and produce a new incoming data/f_low fact for /u1D458. In general,
themergeoperationcanbeunionorintersectiondependingonthe
speci/f_icclientanalysis.Usersoverride merge()tospecifytheex-
act logic. Taking the incoming data/f_low fact produced by merge()
and the statements as input, transfer() computes the outgoing
data/f_low fact accordingly. Users are required to specify the particu-
lar transformation logic by overriding transfer() for a particular
clientanalysis. propagate() describestheconditionsforpropagat-
ing data/f_low facts to successors. Usually, propagation is decided
bythecomparisonbetweenoldfactandnewfact.Useroverrides
propagate() to de/f_ineconcrete terminationcondition.
5.2 AnExample ofAliasAnalysis
Weuseacontext-and/f_low-sensitivealiasanalysisasanexampleto
illustrate how to use the APIs to implement a client analysis. Flow-
sensitivealiasanalysiscomputesthealiasrelationsbetweenpointer
variablesateach program point. As afundamental analysis, ithas
beenwidelyusedinvariousapplicationsincludingbugdetection,
security enforcement, optimizations, etc.
We adopt function cloning to achieve context-sensitivity [ 9,53].
The input CFG to BigData/f_low actually corresponds to a cloned
interprocedural CFG. Taking the inlined ICFG as input, we /f_irst
de/f_ineaparticularsubclass AliasStmt toinstantiateeachstatement
for alias analysis. Its detailed implementation is omitted due to
1437ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA ZewenSun,et al.
space limit. Stmtshasonly one Stmtinstanceas we would like to
analyze the alias information at the granularity of statement. Here
weadopttheprogramexpressiongraph(PEG)[ 50]asadata/f_lowfact
torepresent thealias informationateachprogrampoint. Assuch,
eachobjectof Factisinstantiatedasa PEGinstance.Next, merge()
isachievedasunionoftheupdatedPEGsfrompredecessorswith
the old incoming fact. Within the overridden transfer() , edge
addition and/or deletion are performed on PEG according to the
semantics of each type of statement. If the old PEG and newly
updated PEG are isomorphic, propagate() returns false and the
vertex becomes inactive.
Listing2:Theimplementationof/f_low-sensitivealiasanalysis
on top ofBigData/f_low.
1public class AliasStmt extends Stmt{...}
2classAliasVertexAttribute extends VertexAttribute
3{
4super();
5fact = newPEG();
6}
7
8classAliasAnalysis implements Analysis{
9Fact merge(Set<Fact> predFacts, Fact oldIN) {
10 PEG peg = (PEG)oldIn;
11 for(Fact item : predFacts) {
12 if(item == null)continue ;
13 PEG prePEG = (PEG)item;
14 peg.merge(prePEG);
15 }
16 return peg;
17}
18Fact transfer(Stmts stmts, Fact fact) {
19 PEG peg = (PEG)fact;
20 switch (stmts[0].getType()) {
21 caseLoad:
22 transfer_load(peg,(AliasStmt)stmts[0]);
23 break;
24 //...
25 }
26 return peg;
27}
28boolean propagate(Fact oldFact, Fact newFact) {
29 if(oldFact == null)return true ;
30 PEG newPEG = (PEG)newFact;
31 PEG oldPEG = (PEG)oldFact;
32 return !newPEG.consistent(oldPEG);
33}
34}
As can be seen, to implement a client analysis on top of Big-
Data/f_low,usersonlyneedtospecifythenecessaryfunctionalities
speci/f_ictoclient analysis,without worryingaboutanyimplemen-
tation details of the underlying worklist algorithm as well as other
system-side optimizations.
6 EVALUATION
Our evaluation focuses onthe following three questions:
•Q1: What is the overall performance of BigData/f_low given a
richsetofdistributedcomputing resources?(§ 6.1)
•Q2: How does BigData/f_low perform compared with other
competitive analysissystems/tools?(§ 6.2)
•Q3:Whatabouttheperformanceof BigData/f_lowgiventhe
varyingnumbers ofcores andresources?(§ 6.3)
Subjects. To measure the performance of BigData/f_low on scal-
ing large programs, we selected /f_ive real-world software as the
experimentalsubjects, includingLinuxkernel,Firefox,PostgreSQL,Table 1:Characteristicsofsubject programs.
Subject Version #LoC#Functions Description
Linux 5.217.5M 565Koperating system
Firefox 67.07.9M 770K web browser
PostgreSQL 12.21.0M 30Kdatabase system
OpenSSL 1.1.1519K 12K TLSprotocol
H/t_tpd 2.4.39 196K 6K web server
OpenSSL, and Apache Httpd. Table 1lists detailed information
about the subjects, such as the version (Version), the number of
lines of code (#LoC), the number of functions (#Functions), and its
description.
Reference Tools. To validate the advantage of BigData/f_low in
termsofperformanceandscalabilityonlarge-scaleprograms,we
selected the existing parallel/distributed analysis systems/tools
as the competitors. For parallel algorithms, we chose Chianina
[53], the most recent and state-of-the-art parallel system scaling
context - and /f_low-sensitive analysis to large-scale C programs.
Chianina is implemented in C/C++, and leverages two-level par-
allel computation model and out-of-core disk support to achieve
both analysis eﬃciency and scalability. We ignore other sequen-
tial analysis algorithms [ 16,45] since it has been validated that
Chianina outperforms them [ 53]. For distributed work, since there
exist no distributed systems supporting data/f_low analysis, we used
BigData/f_low-classic, the version implemented based on the dis-
tributed classic worklist algorithm shown as Algorithm 3as the
referencetool.Bydefault,BigData/f_lowisimplementedusingthe
optimizedversion( i.e.,Algorithm 4).
Hardware and So/f_tware Se/t_tings. All experiments were con-
ductedintheAlibabaCloudenvironment.BothBigData/f_lowand
BigData/f_low-classicaredeployedonaclusterconsistingof125Elas-
tic Compute Service (ECS)2nodes with Alibaba Elastic MapReduce
(EMR)installed.Eachnode(inparticular ecs.r7.2xlarge )isequipped
with8virtualCPUcoresbasedonIntelXeonScalableprocessors
and 64GB memory, running CentOS 7.4. The adopted EMR version
is3.14.0correspondingtoHadoop2.7.2andGiraph1.4.0.Tocom-
parewithChianinawhichcanonlyrunonasingle-machinewith
sharedmemory,weusedthemostpowerfulservernodeavailablein
theUS(Virginia)region, i.e.,ecs.r6.26xlarge with104virtualcores,
768G memory,and1T SSD-backedcloud disk.
Client Analyses. In the experiments, we implemented two client
analyses,namelycontext-sensitive/f_low-sensitivealiasanalysisand
instruction cache analysis, on top of BigData/f_low, BigData/f_low-
classic, and Chianina. The alias analysis is same as the example
discussed in § 5.2. For cache analysis, we followed the abstract
model of LRU caches in [ 26] that adopts the set-associative or-
ganization. The con/f_iguration is set as 512 cache lines with LRU
replacementstrategyenabled.Theanalysiscomputesacachemodel
at each program point and decides a cache hit ormiss. We chose
the above two analyses for several reasons: 1) both analyses are
fundamental and widely-used; 2) they are expensive and hardly
scalable given their memory-intensive data/f_lowfact and compute-
intensive transfer function; 3) they fall into the two cases of the
2https://www.alibabacloud.com/product/ecs
1438BigDataflow: A DistributedInterproceduralDataflowAnalysis Framework ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
Table2:Overallperformance:columns#PAliasesand#BCachedindicatethenumberofaliaspairsandthenumberofpotentially
cachedmemoryblocks;columns#Workers,#PMem,TimeandCostrepresentthenumberofworkersused,thesizeofpeak
memory consumed, the total analysis time, and the rental cost of cloud resources, respectively; #Part. indicates the number of
partitions;-indicates out-of-memory error; (a) and(b)report theresults foralias andcacheanalysis, respectively.
(a)AliasAnalysis
BigData/f_low BigData/f_low-classic Chianina
Subject #PAliases #Workers #PMem TimeCost #Workers #PMem TimeCost #Part. #PMem Time Cost
Linux 12.5B 350 3.5T16.7mins $15.8 350 - -- 4 453.4G 17.4hrs $110.4
Firefox 11.5B 140 1.2T16.5mins $15.6 140 - -- 4 131.6G 5.3hrs $33.6
PostgreSQL 727.0M 50 329.7G 2.8mins $2.6 50 330.7G 4.9mins $4.6 1 61.9G50.4mins $5.3
OpenSSL 734.8M 30 285.3G 3.5mins $3.3 30 329.8G 6.8mins $6.4 1 43.2G35.4mins $3.7
H/t_tpd 183.1M 10 119.9G 2.8mins $2.6 10 137.9G 4.0mins $3.8 1 14.2G11.2mins $1.2
(b)Instruction Cache Analysis
BigData/f_low BigData/f_low-classic Chianina
Subject #BCached #Workers #PMem TimeCost #Workers #PMem TimeCost #Part. #PMem TimeCost
Linux 21.5B 500 5.6T44.4mins $42.0 500 - -- 4 555.4G 9.4hrs$59.6
Firefox 15.8B 400 4.4T39.0mins $36.9 400 - -- 4 351.5G 7.2hrs$45.7
PostgreSQL 1.4B 180 1.1T3.2mins $3.0 180 1.1T6.5mins $6.1 1 115.3G 38.1mins $4.0
OpenSSL 2.8B 180 1.3T6.9mins $6.5 180 1.5T13.4mins $12.7 1 227.6G 1.7hrs$10.8
H/t_tpd 782.0M 100 684.3G 3.0mins $2.8 100 781.3G 4.6mins $4.4 1 58.3G18.5mins $2.0
accumulative property in § 3.3respectively, thereby validating the
proofmore comprehensively.
Thecontext-sensitivityisachievedviafullyfunctioncloning( i.e.,
∞-CFA). We start the cloning based upon a call graph constructed
by using a lightweight inclusion-based context-insensitive pointer
analysiswithsupportforfunctionpointers.Tohandlerecursion,
we/f_irstidentifythestronglyconnectedcomponents(SCCs)over
thepre-computedcallgraph.FunctionsnotinanySCCenjoyfull
contextsensitivity.Whereas,level-2call-stringsensitivity( i.e.,us-
ing 2 top-most callsites as the distinguishing context) is used for
those within SCCs. Note that function cloning is NOT the core
contributionofthiswork.Userscanadopttheclassicalk-limited
context-sensitivityorotherselectivecontext-sensitivitytechniques
[17,24]. This can be done by launching a cheap pre-analysis to
understand the contexts desired, and then performing selective
function cloning.
For each client analysis, the version implemented on top of Big-
Data/f_low, BigData/f_low-classic and Chianina are identical and pos-
sessthesameanalysisprecision.Wecheckedtheanalysisresults
of three tools and validated they are consistent. Speci/f_ically, we
comparedthetotalnumberofaliaspairs(includingbothmemory
aliasandvaluealias)generatedforaliasanalysis,andthetotalnum-
ber of potentially cached memory blocks for cache analysis. The
columns #PAliases and #BCached in Table 2list the exact numbers.
6.1 OverallPerformance
Tables2aand2bdemonstrate the performance of BigData/f_low
when analyzing the /f_ive real-world subjects. Columns #Workers,
#PMem,andTimeindicatethenumberofworkersused(oneworker
correspondingtoonephysicalcore),theamountofpeakmemory
consumed,andthe totalanalysistime,respectively.
It is well known that the complexity of a particular data/f_low
analysis is heavily dependent on many factors, such as the size,
density,structureofthecontrol/f_lowgraph,andthesemanticsof
program under analysis. Thereby, it is diﬃcult to give a generalformula that can /f_igure out the ideal number of workers needed.
Whatwecando istoestimateanumberas smallaspossiblesoas
totheanalysistaskcanbecompletedsuccessfullyandeﬃciently.
To this end, we /f_irst run a small sample of the analysis (e.g., 1/50 of
theinputgraph)onasmalltestclusterwith10nodes.Basedonthe
resource utilization data monitored, we estimate an initial number
roughly.Next,weruntheanalysisontheinitialnumberofworkers.
If the task fails due to insuﬃcient memory, the number of workers
isdoubleduntil the analysiscan succeed.
As can be seen, the peak memory consumed in both alias analy-
sisandinstructioncacheanalysiscaneasilyreachseveralterabytes
for large-scale programs, such as the Linux kernel and Firefox, due
to the memory-intensive data/f_low fact and the huge number of
program points. Even for the smallest subject Httpd, performing
the context- and /f_low-sensitive analysis takes more than a hun-
dred or even several hundreds of gigabytes. This is consistent with
the claim in [ 1] that memory would be the major bottleneck for
analysis to scale to large programs. By leveraging the enormous
amount of memory and computing resources in a cloud environ-
ment, BigData/f_low manages to analyze all the subjects successfully
and eﬃciently. Thealias analysis canbe completedwithin 20 min-
utesforallsubjects;themoreexpensivecacheanalysistakesless
than45 minutesfor the Linux kernel with500workers.
6.2 Comparisonwith OtherFrameworks
Given the identical version of the clientanalysis implemented, we
comparedBigData/f_lowagainstBigData/f_low-classicandChianina
withrespecttoperformanceandcost.ColumnsunderBigData/f_low-
classicandChianinainTable 2aand2bshowthedetailedresults
ofBigData/f_low-classic andChianina, respectively.
Chianina. AsChianinacanonlyrunonasingle-machinewith
sharedmemory,werentedthemostpowerfulservernodewith104
virtualcores,768Gmemory,and1TSSDavailableintheUS(Vir-
ginia) region of Alibaba Cloud. In terms of analysis time, Chianina
1439ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA ZewenSun,et al.
with 104 threads takes more than 17 hours and 9 hours to /f_inish
alias analysis and cache analysis over Linux. While BigData/f_low
completesaliasandcacheanalysiswithin20and45minutesundera
cluster,respectively.Itshowsthatdistributedparallelismenabledby
BigData/f_lowindeedacceleratestheanalysissigni/f_icantly(upto62x
and12xforaliasanalysisandcacheanalysisonLinux,respectively).
NotethatBigData/f_lowtakesmoretimeforcacheanalysisthanalias
analysisonallthesubjects,whereasChianinadoesnot.Thiscanbe
explained from two aspects. First, cache analysis is more memory-
intensive than alias analysis. The cache analysis on BigData/f_low
implemented in Java deservedly pays more GC time. Second, as
observed, the alias analysis running on Chianina has low CPU util-
ity due to load imbalance and excessive thread-switching costs for
certain subjects ( e.g., Linux) when a large number of threads are
enabledonasinglemachine.
As the computing resources used by BigData/f_low and Chianina
are diﬀerent, we cannot simply derive that BigData/f_low outper-
forms Chianina. For the sake of fairness, we measured the exact
amount of rental costs of cloud resources in dollars paid by Big-
Data/f_low and Chianina for completing the identical analysis. As
cloud providers generally adopt auni/f_iedpricing strategy, there is
little diﬀerence in the price of nodes with similar resources across
diﬀerent providers. Without loss of generality, we calculated the
costbymultiplyingtheanalysistimeandtheoﬃcialpay-as-you-go
hourlypriceofAlibabaCloudinUS(Virginia)region3. Inpartic-
ular, at the time of submission, each node ecs.r7.2xlarge used by
BigData/f_low takes $0.454/hour. The price of the entire cluster is
0.454*125, i.e.,$56.75/hour.Thesingle ecs.r6.26xlarge servernode
usedbyChianinatakes$6.344/hour.ThecostcolumnsinTable 2
showthedetailedresults.Ascanbeseen,BigData/f_lowspendslower
rental costs than Chianina over all the subjects except for Httpd.
AlthoughthepriceoftheclusterusedbyBigData/f_low($56.75/hour)
is much higher than that of the single server used by Chianina
($6.344/hour), BigData/f_low takes much less time to /f_inish the anal-
ysis than Chianina. We can thus conclude that BigData/f_low is able
tooﬀer signi/f_icantlyhigheranalysiseﬃciency forlarge-scalepro-
grams, whiletaking fewer costscomparedto Chianina.
Regarding memoryconsumption, BigData/f_lowapparentlycon-
sumesmuchmorememorythanChianina.Thereareseveralrea-
sons.(1)Chianinaisadisk-basedsystemwherethememorycon-
sumptionisstronglyrestricted.Itwillleveragediskstomaintain
thehugeamountofdataoncethememoryconsumptionexceeds
acertainthreshold.Incontrast,BigData/f_lowprefersutilizingthe
memoryoneachnodetoperformcommunicationsandaccelerate
theanalysis. (2)BigData/f_lowisimplementedinJava,whileChian-
ina is implemented inC/C++. NodoubtChianinawouldhave less
memory footprint than BigData/f_low. (3) BigData/f_low is running on
topof Giraph.Toachieve faulttolerance, Giraphneedsto maintain
extra(e.g.,3)replicasforallthedatastored.Moreover,forcertain
global data used in the analysis, BigData/f_low has to broadcast it on
every node,leadingto extramemory consumption.
BigDataflow-classic. As numerous redundant and expensive
data/f_low facts were transmitted in the network and gathered at
eachvertex,BigData/f_low-classicfailedtoanalyzethelarge-scale
subjects in ourexperiments ( i.e., Linux and Firefox) giventhe same
3https://www.alibabacloud.com/zh/product/ecs-pricing-list/encomputing resources as BigData/f_low. It validates thatBigData/f_low
doessavememoryresources,thusoﬀeringbetterscalabilitythan
BigData/f_low-classic. For the analyses which both BigData/f_low-
classic and BigData/f_low successfully complete, BigData/f_low exclu-
sively outperforms BigData/f_low-classic in terms of time eﬃciency.
This is because BigData/f_low-classic requires more data transferred
andmergedthanBigData/f_lowto accomplishthe same analysis.
6.3 Scalability
TounderstandthescalabilityofBigData/f_low,wemeasuredtheanal-
ysistimeinsecondsandpeakmemoryconsumptioningigabytes
forbothaliasanalysisandcacheanalysisgivendiﬀerentnumbersof
workers.Figures 3and4show thedetailed performance resultsof
alias analysis and cache analysis on OpenSSL, respectively, where
the x-axis indicatesthe numberofworkers,and y-axisrepresents
thetimeorpeakmemoryused.HereonlythedataofPostgreSQLis
reported.Othersubjectsshowasimilar trend to that of OpenSSL.
(a)time
 (b)peak memory
Figure 3: The time (a) and peak memory (b) used for alias
analysis on OpenSSL with varying numberofworkers.
(a)time
 (b)peak memory
Figure 4:Thetime (a)and peakmemory (b)used for cache
analysis on OpenSSL with varying numberofworkers.
For alias analysis, the time taken by BigData/f_low follows a V-
bottompatternshownasFigure 3a.Whenlessworkersareavail-
able(i.e.,40),thetotalmemorycapacityjustsatis/f_iestheanalysis
need. With the number of workers increasing from 40 to 80, in-
creased parallelismis translated to higherperformance. Therefore,
theoverallrunningtimeshowsadescendingtrend.However,the
communication cost among workers is monotonically increased
withthegrowthofworkersinvolved.Oncetheperformancebene/f_it
ofparallelismisnolongersuperiortotheincreasedcommunication
cost among workers, time climbs steadily. As such, for the speci/f_ic
analysis, having 80 workers provides the best trade-oﬀ between
parallelismbene/f_itandcommunicationcost,leadingtotheshortest
running time of all the tested parallel schedules. It implies that
in practice we can seek a sweet spot of parallelism for diﬀerent
1440BigDataflow: A DistributedInterproceduralDataflowAnalysis Framework ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
subjects according to the tendency of running time as the num-
ber of workers changes. This is particularly meaningful because 1)
cloudresourcesareondemandandchargedonactualusage;and
2)performingdata/f_lowanalysisonthesamelarge-scaleprogram
could be an iterative process as the program evolves constantly.
In terms of the peak memory usage, as more threads/processes
consume more memory space, it is not surprising that it shows an
ascending trendwith the growth of workersin Figure 3b.Figure4
showssimilartrendsforcacheanalysis.AscanbereadfromFigure
4a,with160workersavailable,BigData/f_lowsuccessfully/f_inishes
thecacheanalysis.Thebestperformanceisachievedgivenmore
workers ( i.e., 180). After that point, more analysis time is needed
withthe increasing number ofworkers.
7 DISCUSSION
Usage Scenarios. BigData/f_low oﬀers the distributed capability in
lifting sophisticated data/f_low analysis to large-scale programs. It’s
highlyvaluablefororganizationswithlargecodebasestoanalyze,
while often with their own cluster deployed. In such scenarios,
BigData/f_lowreadilyoﬀersbothhigh-speedandscalableanalysisto
ultra-large-scale programs.
Soundness. Likeotheranalysisframeworks(e.g.,SootandWALA),
users implement a particular client analysis by specifying its corre-
spondingmergeandtransferfunctions.Itistheanalysisdeveloper’s
responsibilitytoensurethesoundnessoftheiranalysis;BigData/f_low
faithfullyexecuteswhateverhasbeenimplementedbythedevel-
opers. As for the underlying framework, we adopted the classic
worklistalgorithm[ 18],anddirectlyimplementeditbasedonthe
vertex-centric computation model. Its soundness stays unchanged.
8 RELATED WORK
8.1 ParallelandDistributedStatic Analysis
Over the past decades, a few attempts have been made to speed
upstaticprogramanalysisbyleveragingparallelanddistributed
computingfacilities.LeeandRyder[ 23]exploitedalgorithmicparal-
lelismtoacceleratedata/f_lowanalysis.Rodriguezetal.[ 36]proposed
aparallelalgorithmforIFDS-baseddata/f_lowanalysis[ 35]basedon
theactormodel,whichrequiresthetransferfunctiontobedistribu-
tiveovermeetoperators.NagarajandGovindarajan[ 31]utilized
Intel Threading Building Blocks to design a parallel /f_low-sensitive
pointer analysis algorithm. Su et al. [ 44] proposed parallel CFL-
reachability-based/f_low-insensitivepointeranalysis.Importantly,
all the above approaches rely heavily on memory for computation.
They can rarelyscaleto large systemssuch as Linux kernel.
Following the line of systemizing program analysis, various sys-
tems are developed to support scalable interprocedural analysis.
Graspan[ 46,52]andBigSpa[ 51]scalethecontext-sensitiveCFL-
reachability analysis [ 34] in a single machine and distributed en-
vironment, respectively. Unfortunately, many data/f_low analyses
cannotfallintothiscategory,suchascacheanalysisandinterval
analysis. Chianina [ 53] is an out-of-core graph system perform-
ingthecontext-and/f_low-sensitiveanalysesinparallel.However,
restrictedbythelimitedparallelcomputingresourcesinasingle
machine, itisineﬃcient when analyzing large-scale systemscode.Fordistributedwork,Albarghouthietal.[ 2]tooktheinspirations
fromMapReduceparadigmandparallelizedthedemand-driventop-
down analyses,suchasveri/f_ication and softwaremodel checking.
Theyfailedtosupportdata/f_lowanalysis.Garbervetskyetal.[ 10]
recentlydevisedadistributedworklistalgorithmbasedontheactor
model.However,itdoesnotsupportthestandarddata/f_lowanalysis
duetotheabsenceof/f_loworderingbetweenactors.Christakiset
al.[8]exploredinputsplittingstrategiestoanalyzediﬀerentcode
pieces on parallel partitions independently. However, as stated
explicitly, the splitting causes analysis imprecision due to the in-
formation loss across separate partitions. Greathouse et al. [ 13]
extendeddynamicdata/f_lowanalyseswitha novel samplingsystem
to achieve low runtime overhead. Apparently, they only focused
ondynamic analysisratherthanstaticdata/f_lowanalysis.
8.2 Vertex-Centric GraphProcessing
Vertex-centricmodelhasbeentightlyincorporatedintodistributed
processing frameworks to tackle the challenge of large-scale graph
processing. Based on that, Pregel [ 27] is the pioneering system
supporting general graph applications. Pregel adopts BSP model to
accelerate the intensive computation. Following the idea of Pregel,
ApacheGiraph[ 4]isimplementedinJavaasanopensourcesystem.
FollowingPregel,moreadvancedvertex-centricmodelsandvari-
ants have been proposed. GraphLab [ 25] supports asynchronous
vertexcomputationbasedonChandy-Lamportsnapshotswithout
haltingtheentireprogram.GraphX[ 12]isagraphsystembased
onResilient DistributedDataset (a.k.a.,RDD) abstraction.
Notethatalltheabovegraphsystemsarededicatedtothegeneral
graph applications. None of them can directly scale the interproce-
duraldata/f_low analysiswell.Asa result,weproposeBigData/f_low,
the /f_irstdistributedsystemtailoredto data/f_lowanalysis.
9 CONCLUSION
Thispaperproposesadistributedinterproceduraldata/f_lowanalysis
framework named BigData/f_low. By leveraging the large amount
of memory and CPU cores in the cloud, BigData/f_low greatly im-
proves the scalability of data/f_low analysis for analyzing large-scale
programs.Theexperimentsconductedinareal-worldcloudenvi-
ronmentvalidatethatBigData/f_lownotonlyscalescontext-sensitive
data/f_low analysis to million lines of code, but also completes such
analysis in a highly eﬃcient manner. It can be expected that we
could achieve nearly on-the-/f_ly analysis of industrial-scale code-
basesbyleveragingmodern cloud computing facilities.
10 DATA AVAILABILITY
BigData/f_low is publicly available: https://github.com/BigData/f_low-
system.Alltheexperimentaldatacanbeaccessedviathelink: https:
///f_igshare.com/articles/dataset/material_fse23_zip/21971945/3 .
ACKNOWLEDGMENTS
We would like to thank all the anonymous reviewers for their
valuablecomments.ThisworkispartiallysupportedbytheNational
Natural Science Foundation of China (Grant No. 62272217), the
Fundamental Research Funds for the Central Universities (Grant
No.020214380104)andAlibabaGroupviatheAlibabaInnovation
Research(AIR)program.
1441ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA ZewenSun,et al.
REFERENCES
[1]Alex Aiken, Suhabe Bugrara, Isil Dillig, Thomas Dillig, Brian Hackett, and Peter
Hawkins. [n.d.]. An Overview of the Saturn Project. In PASTE(San Diego,
California, USA) (PASTE ’07) . ACM, 43–48. https://doi.org/10.1145/1251535.
1251543
[2] Aws Albarghouthi, Rahul Kumar, Aditya V. Nori,and Sriram K. Rajamani. 2012.
ParallelizingTop-downInterproceduralAnalyses.In PLDI(Beijing,China) (PLDI
’12). ACM,217–228. https://doi.org/10.1145/2254064.2254091
[3]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware
TaintAnalysisforAndroidApps.In PLDI(Edinburgh,UnitedKingdom) (PLDI
’14). ACM,259–269. https://doi.org/10.1145/2594291.2594299
[4]Ching Avery. 2011. Giraph: Large-scale graph processing infrastructure on
hadoop.Proceedingsofthe Hadoop Summit. SantaClara 11,3 (2011), 5–9.
[5]CraigChambers, JeﬀreyDean,andDavidGrove.1996. FrameworksforIntra-and
Interprocedural Data/f_low Analysis . Technical Report. University of Washington.
[6]AveryChing,SergeyEdunov,MajaKabiljo,DionysiosLogothetis,andSambavi
Muthukrishnan. 2015. One TrillionEdges: GraphProcessing at Facebook-Scale.
Proc.VLDBEndow. 8,12(aug2015),1804–1815. https://doi.org/10.14778/2824032.
2824077
[7]Jong-DeokChoi,RonCytron,andJeanneFerrante.1991. AutomaticConstruction
of Sparse DataFlow Evaluation Graphs. In POPL(Orlando, Florida,USA) (POPL
’91). ACM,NewYork, NY, USA,55–66. https://doi.org/10.1145/99583.99594
[8]MariaChristakis,ThomasCottenier,AntonioFilieri,LinghuiLuo,MuhammadNu-
mairMansur,LeePike,NicolásRosner,MartinSchäf,AritraSengupta,andWillem
Visser. 2022. Input Splitting for Cloud-Based Static Application Security Testing
Platforms.In Proceedingsofthe30thACMJointEuropeanSoftwareEngineering
ConferenceandSymposiumontheFoundationsofSoftwareEngineering (Singapore,
Singapore) (ESEC/FSE2022) .AssociationforComputingMachinery,NewYork,
NY, USA,1367–1378. https://doi.org/10.1145/3540250.3558944
[9]Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. 1994. Context-sensitive
Interprocedural Points-to Analysis in the Presence of Function Pointers. In PLDI
(Orlando,Florida,USA) (PLDI’94) .ACM,NewYork,NY,USA,242–256. https:
//doi.org/10.1145/178243.178264
[10]DiegoGarbervetsky,EdgardoZoppi,andBenjaminLivshits.2017. TowardFull
Elasticity in Distributed Static Analysis: The Case of Callgraph Analysis. In
ESEC/FSE (Paderborn,Germany) (ESEC/FSE2017) .ACM,442–453. https://doi.
org/10.1145/3106237.3106261
[11]JosephE.Gonzalez,YuchengLow,HaijieGu,DannyBickson,andCarlosGuestrin.
2012. PowerGraph: Distributed Graph-parallel Computation on Natural Graphs.
InOSDI(Hollywood,CA, USA) (OSDI’12) . USENIXAssociation, 17–30.
[12]JosephE.Gonzalez,ReynoldS.Xin,AnkurDave,DanielCrankshaw,MichaelJ.
Franklin, and Ion Stoica. 2014. GraphX: Graph Processing in a Distributed
Data/f_low Framework. In OSDI(Broom/f_ield, CO) (OSDI’14) . USENIX Association,
599–613.
[13]Joseph L. Greathouse, Chelsea LeBlanc, Todd Austin, and Valeria Bertacco. 2011.
Highlyscalabledistributeddata/f_lowanalysis.In InternationalSymposiumonCode
Generation and Optimization (CGO 2011) . 277–288. https://doi.org/10.1109/CGO.
2011.5764695
[14]Rong Gu, Zhiqiang Zuo, Xi Jiang, Han Yin, Zhaokang Wang, Linzhang Wang,
Xuandong Li, and Yihua Huang. 2021. Towards Eﬃcient Large-Scale Interproce-
duralProgramStaticAnalysisonDistributedData-ParallelComputation. IEEE
Trans.ParallelDistrib.Syst. 32,4(apr2021), 867–883. https://doi.org/10.1109/
TPDS.2020.3036190
[15] Ben Hardekopf and Calvin Lin. 2009. Semi-Sparse Flow-SensitivePointer Anal-
ysis. InPOPL. Association for Computing Machinery, New York, NY, USA.
https://doi.org/10.1145/1480881.1480911
[16]BenHardekopfandCalvinLin.2011. Flow-sensitivePointerAnalysisforMillions
ofLinesofCode.In CGO (CGO’11) .IEEEComputerSociety,Washington,DC,
USA,289–298. http://dl.acm.org/citation.cfm?id=2190025.2190075
[17]MinseokJeon,SehunJeong,andHakjooOh.2018. PreciseandScalablePoints-
to Analysis via Data-Driven Context Tunneling. Proc. ACM Program. Lang. 2,
OOPSLA, Article140(oct 2018),29pages. https://doi.org/10.1145/3276510
[18]JohnB.KamandJeﬀreyD.Ullman.1976. GlobalDataFlowAnalysisandIterative
Algorithms. J.ACM23,1(Jan.1976),158–171. https://doi.org/10.1145/321921.
321938
[19]John B. Kam and Jeﬀrey D. Ullman. 1977. Monotone Data Flow Analysis Frame-
works.ActaInf.7,3 (Sept.1977),305–317. https://doi.org/10.1007/BF00290339
[20]Arijit Khan. 2016. Vertex-Centric Graph Processing: The Good, the Bad, and the
Ugly. (12 2016).
[21]GaryA.Kildall.1973. AUni/f_iedApproachtoGlobalProgramOptimization.In
POPL(Boston,Massachusetts) (POPL’73) .ACM,NewYork,NY,USA,194–206.
https://doi.org/10.1145/512927.512945
[22]Sungho Lee, Julian Dolby, and Sukyoung Ryu. 2016. HybriDroid: Static analysis
frameworkforAndroidhybridapplications.In 201631st(ASE) .250–261. https:
//doi.org/10.1145/2970276.2970368[23]Yong-fong Lee and Barbara G Ryder. 1992. A comprehensive approach to par-
allel data /f_low analysis. In Proceedings of the 6th International Conference on
Supercomputing . 236–247.
[24]YueLi,TianTan,AndersMøller,andYannisSmaragdakis.2018. Precision-Guided
Context Sensitivity for Pointer Analysis. Proc. ACM Program. Lang. 2, OOPSLA,
Article141(oct 2018),29pages. https://doi.org/10.1145/3276511
[25]YuchengLow,JosephGonzalez,AapoKyrola,DannyBickson,CarlosGuestrin,
and Joseph M Hellerstein. 2012. Distributed graphlab: A framework for machine
learning in the cloud. arXiv preprint arXiv:1204.6078 (2012).
[26]Mingsong Lv, Nan Guan, Jan Reineke, Reinhard Wilhelm, and Wang Yi. 2016. A
SurveyonStaticCacheAnalysisforReal-TimeSystems. LeibnizTrans.Embed.
Syst.3,1 (2016), 05:1–05:48. https://doi.org/10.4230/LITES-v003-i001-a005
[27]GrzegorzMalewicz,MatthewH.Austern,AartJ.CBik,JamesC.Dehnert,Ilan
Horn,NatyLeiser,andGrzegorzCzajkowski.2010. Pregel:ASystemforLarge-
scaleGraphProcessing.In SIGMOD (Indianapolis,Indiana,USA) (SIGMOD’10) .
ACM,135–146. https://doi.org/10.1145/1807167.1807184
[28]Robert Ryan McCune, Tim Weninger, and Greg Madey. 2015. Thinking like a
vertex:asurveyofvertex-centricframeworksforlarge-scaledistributedgraph
processing. CSUR48,2 (2015), 1–39.
[29]David Melski and Thomas W. Reps. 1997. Interconveritibility of Set Constraints
and Context-Free Language Reachability. In PEPM. 74–89. https://doi.org/10.
1145/258993.259006
[30]Brian R. Murphy and Monica S. Lam. 1999. Program Analysis with Partial
Transfer Functions. In PEPM(Boston, Massachusetts, USA) (PEPM ’00) . ACM,
NewYork, NY, USA,94–103. https://doi.org/10.1145/328690.328703
[31]VaivaswathaNagarajandRGovindarajan.2013. Parallel/f_low-sensitivepointer
analysis by graph-rewriting. In IEEE. IEEE, 19–28. https://doi.org/10.1109/PACT.
2013.6618800
[32]Flemming Nielson, Hanne R. Nielson, and Chris Hankin. 1999. Principles of
ProgramAnalysis . Springer-Verlag, Berlin, Heidelberg.
[33]G. Ramalingam.2002. On SparseEvaluation Representations. Theor. Comput.Sci.
277, 1-2 (April2002),119–147. https://doi.org/10.1016/S0304-3975(00)00315-7
[34]Thomas Reps. 1997. Program Analysis via Graph Reachability. In ILPS(Port
Washington, NewYork, USA) (ILPS ’97) . MITPress,5–19.
[35]ThomasReps,SusanHorwitz,andMoolySagiv.1995. PreciseInterprocedural
Data/f_low Analysis via Graph Reachability. In POPL(San Francisco, California,
USA)(POPL ’95) . ACM,49–61. https://doi.org/10.1145/199448.199462
[36]Jonathan Rodriguez and Ondřej Lhoták. 2011. Actor-based Parallel Data/f_low
Analysis. In CC(Saarbr&#252;cken, Germany) (CC’11/ETAPS’11) . 179–197.
[37]CaitlinSadowski,EdwardAftandilian,AlexEagle,LiamMiller-Cushon,andCiera
Jaspan.2018. LessonsfromBuildingStaticAnalysisToolsatGoogle. Commun.
ACM61,4 (March2018),58–66. https://doi.org/10.1145/3188720
[38]CaitlinSadowski,JeﬀreyvanGogh,Ciera Jaspan,EmmaSöderberg,andCollin
Winter. 2015. Tricorder: Building a Program Analysis Ecosystem. In Proceedings
of the 37th International Conference on Software Engineering - Volume 1 (Florence,
Italy)(ICSE’15) . IEEE Press,598–608. https://doi.org/10.1109/ICSE.2015.76
[39]Roman Shaposhnik, Claudio Martella, and Dionysios Logothetis. 2015. Practical
GraphAnalytics with ApacheGiraph (1sted.). Apress,USA.
[40]MSharirandAPnueli.1978. Twoapproachestointerproceduraldata/f_lowanalysis .
NewYorkUniv.Comput.Sci.Dept.,NewYork,NY. https://cds.cern.ch/record/
120118
[41]QingkaiShi,XiaoXiao,RongxinWu,JinguoZhou,GangFan,andCharlesZhang.
2018. Pinpoint: Fast and Precise Sparse Value Flow Analysis for Million Lines
of Code. In PLDI(Philadelphia, PA, USA) (PLDI 2018) . ACM, 693–706. https:
//doi.org/10.1145/3192366.3192418
[42]Olin Grigsby Shivers. 1991. Control-/f_low Analysis of Higher-order Languages
of Taming Lambda . Ph.D. Dissertation. Pittsburgh, PA, USA. UMI Order No.
GAX91-26964.
[43]TingSu,KeWu,WeikaiMiao,GeguangPu,JifengHe,YutingChen,andZhendong
Su. 2017. A Survey on Data-Flow Testing. ACM Comput. Surv. 50, 1, Article 5
(mar2017),35pages. https://doi.org/10.1145/3020266
[44]Yu Su, Ding Ye, and Jingling Xue. 2014. Parallel pointer analysis with c/f_l-
reachability. In 2014 43rd International Conference on Parallel Processing . IEEE,
451–460. https://doi.org/10.1109/ICPP.2014.54
[45]YuleiSuiandJinglingXue.2016. SVF:InterproceduralStaticValue-FlowAnalysis
in LLVM. In CC(Barcelona, Spain) (CC 2016) . Association for Computing Ma-
chinery, New York, NY, USA, 265–266. https://doi.org/10.1145/2892208.2892235
[46]KaiWang,AftabHussain,ZhiqiangZuo,GuoqingXu,andArdalanAmiriSani.
[n.d.]. Graspan:ASingle-machineDisk-basedGraphSystemforInterprocedural
Static Analyses of Large-scale Systems Code. In ASPLOS(Xi’an, China) (ASPLOS
’17). 389–404. https://doi.org/10.1145/3037697.3037744
[47]John Whaley and Monica S. Lam. 2004. Cloning-based Context-sensitive Pointer
Alias Analysis Using Binary Decision Diagrams. In PLDI(Washington DC, USA)
(PLDI’04) .ACM,NewYork, NY,USA,131–144. https://doi.org/10.1145/996841.
996859
[48]RobertP.WilsonandMonicaS.Lam.1995. EﬃcientContext-sensitivePointer
Analysis for C Programs. In PLDI(La Jolla, California, USA) (PLDI ’95) . ACM,
NewYork, NY, USA,1–12. https://doi.org/10.1145/207110.207111
1442BigDataflow: A DistributedInterproceduralDataflowAnalysis Framework ESEC/FSE ’23, December3–9, 2023,San Francisco, CA, USA
[49]Roland Wismüller. 1994. Debugging of Globally Optimized Programs Using
Data Flow Analysis. In PLDI(Orlando, Florida,USA) (PLDI ’94) . Association for
ComputingMachinery,NewYork,NY,USA,278–289. https://doi.org/10.1145/
178243.178430
[50]Xin Zheng and Radu Rugina. 2008. Demand-driven alias analysis for C. In POPL.
197–208. https://doi.org/10.1145/1328438.1328464
[51]ZhiqiangZuo,RongGu,XiJiang,ZhaokangWang,YihuaHuang,LinzhangWang,
and Xuandong Li. 2019. BigSpa: An Eﬃcient Interprocedural Static Analysis
EngineintheCloud.In IPDPS (IPDPS’19) .https://doi.org/10.1109/IPDPS.2019.
00086[52]Zhiqiang Zuo, Kai Wang, Aftab Hussain, Ardalan Amiri Sani, Yiyu Zhang, Shen-
ming Lu, Wensheng Dou, Linzhang Wang, Xuandong Li, Chenxi Wang, and
GuoqingHarry Xu.2021. SystemizingInterproceduralStatic Analysis of Large-
ScaleSystemsCodewithGraspan. ACMTrans.Comput.Syst. 38,1–2,Article4
(jul2021),39pages. https://doi.org/10.1145/3466820
[53]Zhiqiang Zuo, Yiyu Zhang, Qiuhong Pan, Shenming Lu, Yue Li, Linzhang Wang,
Xuandong Li, and Guoqing Harry Xu. 2021. Chianina: an evolving graph system
for/f_low-and context-sensitiveanalyses of millionlinesof Ccode.In PLDI.914–
929.https://doi.org/10.1145/3453483.3454085
Received 2023-02-02; accepted 2023-07-27
1443