Multi-PhaseInvariant Synthesis
Daniel Riley
FloridaStateUniversity
UnitedStates
driley@cs.fsu.eduGrigoryFedyukovich
FloridaStateUniversity
UnitedStates
grigory@cs.fsu.edu
ABSTRACT
Loops with multiple phases are challenging to verify because they
requiredisjunctiveinvariants.Invariantscouldalsohavetheformof
implicationbetweenapreconditionforthephaseandalemmathat
is valid throughout the phase. Such invariant structure is however
not widely supported in state-of-the-art verification. We present a
novel SMT-based approach to synthesize implication invariants for
multi-phaseloops.OurtechniquecomputesModelBasedProjec-
tions to discover the programâ€™s phases and leverages data learning
togetrelationshipsamongloopvariablesatanarbitraryplaceinthe
loop. It is effective in the challenging cases of mutually-dependent
periodic phases, where many implication invariants need to be
discovered simultaneously. Our approach has shown promising re-
sultsinitsabilitytoverifyprogramswithcomplexphasestructures.
We have implemented and evaluated our algorithm against several
state-of-the-artsolvers.
CCS CONCEPTS
Â·Software and its engineering â†’Formal software verifica-
tion.
KEYWORDS
automated safety verification, inductive invariant synthesis, satisfi-
abilitymodulotheories,modelbasedprojection
ACMReference Format:
Daniel Riley and Grigory Fedyukovich. 2022. Multi-Phase Invariant Syn-
thesis. In Proceedings of the 30th ACM Joint European Software Engineering
ConferenceandSymposium on the Foundationsof SoftwareEngineering(ES-
EC/FSEâ€™22),November14Å›18,2022,Singapore,Singapore. ACM,NewYork,
NY, USA, 13pages.https://doi.org/10.1145/3540250.3549166
1 INTRODUCTION
Automatedsoftwareverificationtoolsoftendelegatetheircomputa-
tionaltasks tosolversforSatisfiability ModuloTheories (SMT)and
Constrained Horn Clauses (CHC). The latter aims at synthesizing
inductive invariants for loops and recursive calls, and it enables
sound reasoning about software safety. Existing CHC solvers ex-
tensively rely on SMT solvers. The ability to discover a solution
often critically depends on the capabilities of the SMT solver to
apply interpolation or quantifier elimination. Recently proposed
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™22, November 14Å›18,2022, Singapore, Singapore
Â©2022 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-9413-0/22/11...$15.00
https://doi.org/10.1145/3540250.3549166guess-and-check methods [ 18,50,54], while still relying on SMT
solvers to prove invariants, are guided by external sources, such as
user-providedgrammars,templates,orconcretedatatogenerate
differentpiecesofinvariants.
Programsthatdisplaycontrol-flowdivergenceinthebodiesof
theirloopsusuallyrequire multi-phaseinvariants thatareusually
disjunctiveandaremoredifficulttoinfer[ 5,46,56,57].Ourworkis
motivatedbytheneedforimprovedmethodstoverifymulti-phased
systemsusedinseveral fields, specifically:
â€¢Control software and reactive systems perform tasks depending
on their environment [ 3,35,46]. Such changes boil down to
phases, where the behavior of the system will be different based
on the conditions. These systems are often safety critical such
as self-driving systems, flight software, or medical diagnostic
software.
â€¢Multi-phase loops may arise from a common transformation
technique such as loop flattening [ 42], used by verification fron-
tends when translating from a programming language such as C
orJavainto CHCs[ 28]. Verification systemshavebecome more
modular,withsolversinthebackendrelyingonfrontendsystems
to translate a given program. Consequently the backend solvers
do not always have control over the result of the translation and
can be given multi-phase loops even if the source program does
not have them.
â€¢Termination checking is often reduced to safety verification [ 11,
21,40]. A ranking function is found to overestimate the number
of iterations of a loop. In a complicated case of lexicographic
ranking functionsynthesis [ 12,40,62], variousprogram phases
need to be analyzed. Multi-phase invariants may help in these
cases.
Our new approach to multi-phase invariant synthesis aims to
find predicates that have the form of implication, where the left-
handsideiscalleda phaseguard uniquelydescribingwhenacertain
phaseisenabled,andtheright-handsideiscalleda phaselemma .
Implicationsbydefinitionencodeadisjunction,sotheirusehere
intuitively captures the disjunctive nature of multi-phase loops.
Generation of phase lemmas is challenging because they should
be valid under their phase guards. In this paper we describe a new
algorithm to derive both phase lemmas and their phase guards
automatically.
We build on top of the Houdini [23] strategy, where invariants
are selected from a set of candidates. The synthesis loop can be pa-
rameterized by grammars, be data-driven, or follow some semantic
inference rules.Itbegins similarlyto manytraditional algorithms,
i.e., by guessing candidates and checking their inductiveness using
an SMT solver. Our main idea is to synthesize a phase guard for
each candidate that fails the inductiveness check, thus, weakening
it. Intuitively, a phase guard represents a set of states, for which
the failedcandidate isinductive.
607
ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Daniel Riley andGrigory Fedyukovich
Program
Weaken
PropagateEnum
Cands
Lemmas 
FoundHoudini
Safe
inductive
invariantSyGuS
Data 
LearningData 
Learning
+ 
Fast 
Forwarding
Quantifier 
Elimination
inductive
lemma
Figure 1:Architecture of ImplCheck .
Our first main insight is that phase guards are computed by
aModel-BasedProjection(MBP)[ 7,37]thatunder-approximates
quantifierelimination(QE)overtheloopbody.Becauseadiverging
control-flow can be represented as a disjunctive formula, its under-
approximation(adisjunct)encodesaloopphase.WeuseanMBP
algorithm to lazily [ 45] compute all phase guards and organize
theminadecision tree.
Thesecondimportantdesignchoiceistheuseofdatatracesfrom
a particular phase for discoveringphase lemmas. For numeric pro-
grams,existingmethods[ 19,38,47,60]havealreadyproventheir
success,but they criticallydepend onrelevantdata. We propose a
newmethodfordatacollectionusinganSMTsolverthattakesa
bounded unrolling of a phase beginning at a state where the phase
guard does not hold and proceeds to states where it holds. This
avoidsthecreationofthefullunrollingthatexecutestheloopfrom
its initial state upuntil the entry to the current phase.However,a
naive application ofthisidea mayresult insome importantcom-
putation from a previous phase not being taken into account. To
mitigatethis,ouralgorithmreusestheinvariantsfromtheprevious
phases and any global invariants1, if they have already been found.
The high-level overview of the approach is shown in Fig. 1. The
algorithm takes a program encoded in CHCs, then extracts and
organizes itsphases intoadecision tree. The search ofcandidates
begins with an enumerative approach that supplies an initial set
of candidates, which, if they fail the Houdini check, are passed to
ourweakeningengine.Theenumerationblockofourframeworkis
parameterizeable by any paradigm which synthesizes expressions,
including a Syntax-Guided Synthesis [ 2] (SyGuS) approach and/or
adatalearner[ 60]thatextractsinvariantsfromboundedbehaviors.
InWeaken-and-Propagate ,candidatesaresynthesizedintothe
form of implication, with the premise being a phase guard and the
conclusion being a phase lemma. These implication candidates are
passed to Houdini to calculate their inductive subset. When the
collection of Lemmasreturned by Houdini is strong enough to
blockthe errorstates, the program isverified safe.
1A globalinvariantis one that is not associated with a phase guard .Ournew algorithm has beenimplemented in a tool called Impl-
Checkontopofthe FreqHorn [18]CHCsolverandthe Z3[14]
SMT solver and uses their quantifier elimination, MBP, and data
learning algorithms. We have evaluated it against state-of-the-art
on a set of public benchmarks. Of particular interest are a sub-
set from CHC-COMP, that include a variety of phase structures
within their loops, which we believe tests the robustness of our ap-
proach.Thesetofexperimentsconfirmsthat ImplCheck iscapable
of inferring a much larger set of multi-phase invariants than the
competitorsandthatitsoverheadwhilerunningonsingle-phase
benchmarks issmall.
Therestofthepaperisstructuredasfollows.Weproceedwith
an illustrating example in Sect. 2and a brief background in Sect. 3.
Sect.4summarizesourcontributionsonsynthesizingphaseguards
usingMBPandorganizingtheminadecisiontree.Theoverviewof
thealgorithmisthenpresentedinSect. 5.Sect.6givestwostrategies
on synthesizing phase lemmas: by propagation using quantifier
elimination (a general approach), and accelerateddata-learning (an
approach designed for numeric programs). The implementation
is briefly reported in Sect. 7, and the evaluation and comparison
against the state-of-the-artisdetailedinSect. 8.
2 ILLUSTRATING EXAMPLE
TheprograminFig. 2illustratesthemainconceptsofourapproach.
It has three variables: xalways increments, yis assigned nondeter-
ministically,and zincrementsconditionally.Theloopbodyhasa
singleconditionalanduptothreedifferentphases,dependingon
thevalueof y.TheplotinFig. 2depictsthecasewhen yispositive,
andthustheloopgoestothreephases:1)fromtheinitialstateuntil
the guard starts to hold, 2) when the guard holds, and 3) when the
guard does not hold anymore. After the loop terminates and if yis
positiveand xissufficientlylarge,ourgoalistoprovethat zequals
1000.
A safety property canbe proved byfinding an inductive invari-
antwhichintuitively1)isimpliedbytheinitialstatesformula,2)is
closed under the transition relation, and 3) implies the safety prop-
erty.Aninductiveinvariantforourillustrationprogramisgiven
in Fig.5. It is nontrivial: in our experiments, ten state-of-the-art in-
variant synthesizers failed to discover it automatically within a one
hourtimeout.Intuitively,theinvariantdescribesarelationbetween
variables x,y, andzin three phases of the loop when yis positive:
ifxis sufficiently smallthen zremainsatzero,then zandxgrow
simultaneouslyuntilatsomepoint zreaches1000andstagnates.
Ouralgorithmgeneratesanindividualinvariant(calleda lemma)
for each of the three phases and then conjoins them together. Each
lemma has the form of an implication, its antecedent is called a
phaseguard ,andits consequent iscalleda phase lemma .
Todiscoverphaseguards,ourapproachanalyzesthecontrolflow
of the program and organizes its phase-reachability information in
adecisiontree (DT),showninFig. 3.DTapproximatestheorderand
conditions of visiting all possible phases. That is, if yis positive,
thenğ‘¦>ğ‘¥div1000holdsatthebeginning, ğ‘¦=ğ‘¥div1000holds
after some iterations, and ğ‘¦<ğ‘¥div1000holds at the end (and
thustherightmostbranchoftheDThasdepththree).Ingeneral,we
canshowthateveryprogramhasonlyafinitenumberofphases,
608Multi-Phase Invariant Synthesis ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
intx,y,z;
x,z= 0;
y=nondetInt ();
while(*) {
if(y==x/1000)
z++;
x++;
}
if(y> 0 &&
x> 1000*( y+ 1))
assert(z== 1000);x
yzvalues of variables
iterationsphase 2 phase 1 phase 3
0
Figure 2:C-likeprogram with amulti-phase loop.
âŠ¤
ğ‘¦<0âˆ§ğ‘¦<ğ‘¥div1000 ğ‘¦=0âˆ§ğ‘¦=ğ‘¥div1000 ğ‘¦>0âˆ§ğ‘¦>ğ‘¥div1000
ğ‘¦=0âˆ§ğ‘¦<ğ‘¥div1000 ğ‘¦>0âˆ§ğ‘¦=ğ‘¥div1000
ğ‘¦>0âˆ§ğ‘¦<ğ‘¥div1000
Figure 3:Decision tree forphase-guard selection.
First phase
x y z
0 5 0
1 5 0
2 5 0Second phase
x y z
5001 5 1
5002 5 2
5003 5 3Third phase
x y z
6000 5 1000
6001 5 1000
6002 5 1000
Figure 4:Data matricescapturing variable values.
Invâ†¦â†’ğœ†ğ‘¥,ğ‘¦,ğ‘§.
ğ‘¦>0âˆ§ğ‘¦>ğ‘¥div1000=â‡’ğ‘§=0âˆ§
ğ‘¦>0âˆ§ğ‘¦=ğ‘¥div1000=â‡’ğ‘§=ğ‘¥âˆ’1000ğ‘¦âˆ§
ğ‘¦>0âˆ§ğ‘¦<ğ‘¥div1000=â‡’ğ‘§=1000
Figure 5:Safe inductive invariant.
precomputed before the analysis, so our algorithm can cheaply
traversethe DTmultiple times throughout the verification.
To discover phase lemmas, we can in principle follow various
techniques,fromguess-and-checktofixpointcomputation.How-
ever, for numeric programs, the most effective approach in our
experienceisbasedondatalearningand Houdini.Itbeginswith
constructingadatamatrixforallthephasesindividually(shownin
Fig.4)andinferringrelationshipsbetweenvariables.Forthefirst
phase, the process is straightforward: a value for yis randomly
picked: and if it is positive then we have to follow the rightmost
branch of the DT. Thus, the values for xandzin the first three
iterationsareinferred precisely,givingusaphase lemma ğ‘§=0to
be associated with the phase guard ğ‘¦>0âˆ§ğ‘¦>ğ‘¥div1000. Then,
thechosenbranchoftheDTleadsustothesecondphase(i.e.,in
whichğ‘¦>0âˆ§ğ‘¦=ğ‘¥div1000holds). The data matrix creation
in this case is trickier since for ğ‘¦=5we would have to unwind
the loop 5000 times (which is expensive). Instead, we simulate thisusing a technique called fast-forwarding : the loop unrolling begins
atanarbitraryiteration,suchthatthefirstphaseguardholdsatthe
beginning, but the second guard holds at the end. For our exam-
ple,it issufficient toget theseconddata matrixand consequently
the second phase lemma ğ‘§=ğ‘¥âˆ’1000ğ‘¦. Lastly, the third phase is
computed similarly, and the conjunction of them is sufficient for
provingthe safetyproperty inthe program.
3 BACKGROUND
This paper approaches the problem of automated software verifica-
tion by reduction to Satisfiability Modulo Theories (SMT) problems.
3.1 LogicNotation andMainRoutines
Automated SMT solvers determine the existence of a satisfying
assignmenttovariables(alsocalleda model)ofafirst-orderlogic
formula. We write M|=ğœ‘to denote that a model Msatisfies a
formulağœ‘(andâˆƒM|=ğœ‘to denote the satisfiability of ğœ‘). Formula
ğœ‘is logically stronger than formula ğœ“(denotedğœ‘=â‡’ğœ“), if every
model of ğœ‘also satisfies ğœ“. The unsatisfiability of formula ğœ‘is
denotedğœ‘=â‡’false. By writing ğœ“(ğ‘¥), we denote a predicate over
free variables ğ‘¥.We useiteto denote if-then-else .
For a formula ğœ‘, terms/formulas ğ‘andğ‘, we write ğœ‘[ğ‘/ğ‘]to de-
noteğœ‘after all instances of ğ‘are replaced by ğ‘. For a set of terms/-
formulas ğ‘‹and a mapping Mfromğ‘‹to other terms/formulas,
ğœ‘[M/ğ‘‹]denotesthesimultaneousreplacementofall ğ‘¥1,ğ‘¥2,...âˆˆğ‘‹
byM(ğ‘¥1),M(ğ‘¥2),...,respectively.
ByÎ¨wedenotethespaceofallpossiblequantifier-freeformu-
las in our background theory and by Varsa sequence of possible
variables. Because in the paper we mainly deal with conjunctive
formulas (which are created by adding/dropping conjuncts), we
sometimes slightly abuse the notation and refer to ğ‘†âˆˆ2Î¨as a
conjunction ofallits elements, i.e.,/logicalandtext.1
ğ‘âˆˆğ‘†ğ‘.
Theproblem ofquantifier eliminationis fora given âˆƒ/vecğ‘¦.ğœ“(/vecğ‘¥,/vecğ‘¦)
to generate an equivalent /vecğ‘¦-free formula, and it can be approached
by converting ğœ“(/vecğ‘¥,/vecğ‘¦)to DNF, eliminating quantifiers from each
disjunct, and disjoining the results. Our main insight, instead, is to
buildthephaseguardgenerationengineontopofanotionofModel-
BasedProjection(MBP)[ 7]thatunder-approximatesQEwithout
converting to DNF. Specifically, one could compute a number of
MBPslazily, anddisjoin them.The number of MBPsis in practice
significantly lower than the number of disjuncts in the DNF of the
same formula, whichyieldssignificant performance gains.
Definition3.1. Givenaformula ğœ“over/vecğ‘¥,/vecğ‘¦,andamodel M,an
MBP/vecğ‘¦(M,ğœ“)isa/vecğ‘¦-free formula if the following hold:
ifM|=ğœ“(/vecğ‘¥,/vecğ‘¦)then M|=MBP/vecğ‘¦(M,ğœ“)
MBP/vecğ‘¦(M,ğœ“)=â‡’ âˆƒ/vecğ‘¦.ğœ“(/vecğ‘¥,/vecğ‘¦)
Forlinearintegerarithmetic,anMBPforformula ğœ“anditsmodel
Mcan be constructed from literals of formula ğœ“, converted to the
Negation Normal Form (NNF), finding literals that evaluate to true
onM,andeliminating Varsâ€²fromtheirconjunction.Moreformally,
itispresentedinAlgorithm 1.Wedeferanexampleofthealgorithm
run to Sect. 4.1, where it is used in the context of multi-phase
program verification.
609ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Daniel Riley andGrigory Fedyukovich
Algorithm1: MBPVarsâ€²(M,ğœ‘): basic MBP construction
Input: M: model,ğœ‘(Vars,Varsâ€²): formula
Output:ğœ“:Varsâ€²-free MBP
1ğœ‘â†toNNF(ğœ‘);
2ğœ“(Vars,Varsâ€²)â†{â„“|â„“âˆˆliterals(ğœ‘)âˆ§M|=â„“};
3returnQE(Varsâ€²,âˆƒVarsâ€².ğœ“(Vars,Varsâ€²));
3.2 ProgramsandTransitionSystems
We view programs as transition systems and throughout the paper
use both terms interchangeably2.
Definition3.2. Atransitionsystem PisatupleâŸ¨VarsâˆªVarsâ€²,Init,TrâŸ©,
whereVarsandVarsâ€²arecopiesofthe sequenceofvariablesatthe
beginning and the end of a transition, respectively; InitandTr
are the symbolicencodings ofthe initial states and thetransition
relation.
A program ğ‘ƒand an encoding Badoferror states define aver-
ification problem , which is satisfiable if the set of error states is
unreachable. If satisfiable, a solution of a verification problem is
asafeinductiveinvariant ,representedbyaformula Invsuchthat:
Invover-approximates Init, is closed under Tr, andInvis strong
enough to blockallerrorstates.
Definition 3.3. Givenğ‘ƒ=âŸ¨VarsâˆªVarsâ€²,Init,TrâŸ©; a formula Invis
asafeinductiveinvariant ifthefollowingconditions(respectively
calledan initiation,aconsecution,andasafety) hold:
Init(Vars)=â‡’Inv(Vars) (1)
Inv(Vars)âˆ§Tr(Vars,Varsâ€²)=â‡’Inv(Varsâ€²) (2)
Inv(Vars)âˆ§Bad(Vars)=â‡’false (3)
Example3.4. Theproblemoffindinganinductiveinvariantfor
program inFig. 2can be formulatedas follows.
ğ‘¥=0âˆ§ğ‘§=0=â‡’Inv(ğ‘¥,ğ‘¦,ğ‘§)
Inv(ğ‘¥,ğ‘¦,ğ‘§)âˆ§ğ‘¥â€²=ğ‘¥+1âˆ§ğ‘¦â€²=ğ‘¦âˆ§
ğ‘§â€²=ite(ğ‘¦=ğ‘¥div1000,ğ‘§+1,ğ‘§)=â‡’Inv(ğ‘¥â€²,ğ‘¦â€²,ğ‘§â€²)
Inv(ğ‘¥,ğ‘¦,ğ‘§)âˆ§ğ‘¦>0âˆ§
ğ‘¥>1000(ğ‘¦+1)âˆ§Â¬(ğ‘§â‰¥1000)=â‡’false
3.3 Data Learning
Weusedatalearningtodiscoverinductiveinvariantsbyexamining
programtraces.Tracesaregatheredasafiniteunrollingbasedona
BoundedModelChecking (BMC) formula [ 6].
Anunrolling of length ğ‘šof a program ğ‘ƒ=âŸ¨Vars,Init,TrâŸ©is a
conjunction:
unrl(Vars,...,Vars(ğ‘š))def=
Init(Vars)âˆ§Tr(Vars,Varsâ€²)âˆ§...âˆ§Tr(Vars(ğ‘šâˆ’1),Vars(ğ‘š))
witheach ğ‘–, ğ‘—,ğ‘˜,ğ‘›,suchthat ğ‘–â‰ ğ‘—andğ‘˜â‰ ğ‘›,Vars(ğ‘–)[ğ‘˜]â‰ Vars(ğ‘—)[ğ‘›].
Notethatwerelyonsequences(ratherthanonsets)ofvariables
Vars, and we can extract the ğ‘›thvariable of VarsviaVars[ğ‘›]. This
is useful for obtaining data to learn predicates, which consist of
2Althoughthepresentationassumessingle-loopprograms,ourimplementationworks
also for programswith multiple loops.values for each variable in each iteration of the program. It can be
either obtained by a dynamic execution, or extracted from a model,
M|=unrl(Vars,...,Vars(ğ‘š)), for some unrolling of the program.
The valuesobtainedfrom the modelare then storedinamatrix.
Anğ‘šÃ—ğ‘›matrixğ´is composed of ğ‘šrows representing the
iterationsofaprogramandof ğ‘›columnsrepresentingthevalueofa
variableVars[ğ‘—].Eachelement, ğ´[ğ‘–, ğ‘—],ofğ´holdsthevalueinthe ğ‘–th
iterationofthe ğ‘—thvariable,thatis,if M|=unrl(Vars,...,Vars(ğ‘š))
thenğ´[ğ‘–, ğ‘—]def=M(Vars(ğ‘–)[ğ‘—]).
Fig.4showsthreeexamplematricesrepresentingthreedifferent
phases of Example 3.4. An unrolling for our motivating example
begins at the initial state and captures the information shown in
theFirst Phase matrix of Fig. 4. For instance, the first matrix is
computedfromamodelof unrl(Vars,Varsâ€²,Varsâ€²â€²),containedof Init
and two copies of Tr. After an unrolling, data learning proceeds to
analyze the resultingmatrix.
From linear algebra, given a vector space Vover a field F, its
basisB={b1,...,bğ‘–}is the minimal subset of Vif every vector
ğ‘£âˆˆVcanbewrittenasalinearcombinationof B.Thebasis Bof
thenullspace,thesetofallvectorsthatwhenmultipliedby ğ´equal
to/vec0,ofğ´producescandidateinvariants[ 60].Invariantsfoundfrom
basisvectorstaketheshapeofequalities, ğ‘1ğ‘¥1+ğ‘2ğ‘¥2+...ğ‘ğ‘–ğ‘¥ğ‘–=0.
Example 3.5. Letğ´be the matrix of Second Phase in Fig.4.
Solvingğ´/vecğ‘=0, the solution for/vecğ‘is/parenleftBigâˆ’1
1000
1/parenrightBig
. Then the candidate
invariantis ğ‘§=ğ‘¥âˆ’1000ğ‘¦.
A weakness of this approach stems from the construction of the
datamatrixusedtoproducecandidateinvariantsforanarbitrary
phaseÅ›itwouldrequireconstructingpotentiallylargeunrollings.
We willexplore awayaround this weakness inSect. 6.
3.4 InductiveSubset Extraction
In this paper, we target invariants composedfrom multiple lemmas
i.e.,Inv=â„“0âˆ§...âˆ§â„“ğ‘›, where each â„“ğ‘–passes the initiation and
consecution checks from Def. 3.3. Thus, invariants can be found by
anenumerationofcandidateformulasandfindingasubsetofthem,
suchthattheirconjunctionfulfillsthethird(safety)checkaswell.
Givenaninitialsetofformulas(eithercapturedinapredetermined
grammar[ 50,54],obtainedfromsyntax[ 18],orbehaviors[ 19,47]),
anenumerativeapproachaimsatgraduallynarrowingittoasubset
the conjunction of which is a solution. The Houdini algorithm,
showninAlgorithm 2,findsformulasthatpasstheinitiationand
thencontinuestoiterativelyremovebadcandidatesusingsocalled
counterexamples-to-induction .Iftheremainingcandidatesarenot
consistent withthe setof errorstates, the program issafe.
Example 3.6. LetCands={ğ‘§=0,ğ‘§â‰¥0}for Example 3.4, then
Algorithm 2iterates two times. First it finds that ğ‘§=0is not
inductive, e.g., by finding model M={ğ‘¥â†¦â†’5000,ğ‘¦â†¦â†’5,ğ‘§â†¦â†’
0,ğ‘¥â€²â†¦â†’5001,ğ‘¦â€²â†¦â†’5,ğ‘§â€²â†¦â†’1}, and it keeps only ğ‘§â‰¥0because
M(ğ‘§â€²)â‰¥0. Second, it finds that ğ‘§â‰¥0is inductive (and returned as
alemma),whichis, however,not enough for provingthe safety.
While the algorithm is useful for finding conjunctive invariants,
its weakness is in a too aggressive weakening (i.e., keeping or
dropping the entire candidate). However, the dropped candidate
610Multi-Phase Invariant Synthesis ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Algorithm2: Houdini(ğ‘ƒ,Bad,Cands),cf.[23]
Input:ğ‘ƒ=âŸ¨VarsâˆªVarsâ€²,Init,TrâŸ©:program; Bad:errorstates
Candsâˆˆ2Î¨
Output:resâˆˆâŸ¨safe,unknownâŸ©,setLemmasâŠ†Cands: of
inductive lemmas
1Candsâ†{ğ‘âˆˆCands|Init(Vars)=â‡’ğ‘(Vars)};
2whileâˆƒM,s.t.
M|=Cands(Vars)âˆ§Tr(Vars,Varsâ€²)âˆ§Â¬Cands(Varsâ€²)do
3Candsâ†{ğ‘âˆˆCands|M|=ğ‘(Varsâ€²)};
4ifCands(Vars)âˆ§Bad(Vars)=â‡’falsethen
5returnsafe,Cands;
6returnunknown ,Cands;
ğ‘§=0can be weakened in another way, by adding a phase guard,
as inFig. 5.Our novel weakeningstrategyisdiscussedinSect. 5.
4 PHASEREACHABILITYTREE
Thereasonforcontrol-flowdivergencecanoftenbeextracteddi-
rectlyfromtransitionrelations3.Whenatransitionrelationisin
adisjunctivenormalform(DNF),theneachdisjunctrepresentsa
group of programexecutionsbelonging to the same phase.For de-
terministic programs, these disjuncts have conditions on the states
atthebeginningofatransition(usuallycalled sourcestates),that
has to be true for all executions in the corresponding phase. These
conditions are quite important for our invariant synthesis since
they can be used to weaken candidates that do not pass a Houdini
run,andthuswecallthem phaseguards .Obtainingphaseguards
inourapproachproceedsintwostages.First,ouralgorithmcom-
putesafinitenumberofphasesfromthetransitionrelationusing
quantifierelimination(QE).Theresultingformulasrepresentphase
reachabilityinformationthat arearrangedinadecisiontree (DT),
and lastly strengthened based on their position in the DT to reflect
somecontext-specific information.
4.1 Model-BasedProjectionsas PhaseGuards
Informally, a guard is a description of a subset of source states that
needtobetrueforalltransitionsofthephase.Insteadofconverting
atransitionrelationtoDNF,andthenapplyingQEtogetaguard
for each disjunct, our approach picks one representative transition
ofaphaseandidentifiesitsphaseguard.Atransitionisrepresented
by a model of the Trformula over source and destination vari-
ablesVarsandVarsâ€². Thus, we have to compute an MBP of formula
âˆƒVarsâ€².Tr(Vars,Varsâ€²)basedonthat model.
Example4.1. RecallExample 3.4,inwhichthetransitionrelation
isas follows.
ğ‘¥â€²=ğ‘¥+1âˆ§ğ‘¦â€²=ğ‘¦âˆ§ğ‘§â€²=ite(ğ‘¦=ğ‘¥div1000,ğ‘§+1,ğ‘§)
3The main benefit of conducting an analysis over this symbolic encoding (vs over
theprogramâ€™ssourcecode)isthattheapproachislanguage-agnostic.Furthermore,
isisalsoinsensitivetotheverificationfrontendthatdoestheencoding.Specifically,
tools often perform various program transformations, including ones that change the
control-flowstructure,sometimesdrastically.Thus,thephasereachabilityinformation
obtained fromthe source-code level maynot be adequateat the level of the symbolic
encoding.Algorithm3: AllMBP Varsâ€²(M,ğœ‘)
Input:ğœ‘(Vars,Varsâ€²): formula
Output:MBPs:Varsâ€²-free setof Model-BasedProjections
1MBPsâ†âˆ…;
2whiletruedo
3ifâˆƒM|=ğœ‘(Vars,Varsâ€²)âˆ§/logicalandtext.1
ğ‘–Â¬MBPsğ‘–(Vars)then
4 MBPsâ†MBPsâˆª{MBPVarsâ€²(M,ğœ‘(Vars,Varsâ€²))};
5else
6 returnMBPs;
The formula is satisfied by the model M={ğ‘¥â†¦â†’0,ğ‘¦â†¦â†’1,ğ‘§â†¦â†’
0,ğ‘¥â€²â†¦â†’1,ğ‘¦â€²â†¦â†’1,ğ‘§â€²â†¦â†’0}, thus we proceed to generating an MBP.
Algorithm 1then splits the transitionrelation intoliterals:
literals(Tr)={ğ‘¥â€²=ğ‘¥+1,ğ‘§â€²=ğ‘§+1,ğ‘§â€²=ğ‘§,ğ‘¦â€²=ğ‘¦,
ğ‘¦<ğ‘¥div1000,ğ‘¦=ğ‘¥div1000,ğ‘¦>ğ‘¥div1000}
It is easy to see that after collecting literals that are satisfied by M
and conjoining them, we can get an under-approximation of the
transitionrelation that only describes the firstphase:
ğ‘¦>ğ‘¥div1000âˆ§ğ‘¥â€²=ğ‘¥+1âˆ§ğ‘§â€²=ğ‘§âˆ§ğ‘¦â€²=ğ‘¦
Lastly, by eliminating ğ‘¥â€²,ğ‘¦â€², andğ‘§â€², we get the first phase guard
ğ‘¦>ğ‘¥div1000.
Toobtainalloftheguards,werepeattheprocessofgathering
models of Trthat are not covered by the previously generated
guards,as presentedinAlgorithm 3.
4.2 OrganizingPhaseGuardsinaDecisionTree
Itisconvenienttorepresentphasesinadecisiontree,thatiscom-
puted exactly once, prior to the invariant synthesis run. We in-
troducethenotionofaphase-reachabilitytreetoapproximateall
possibleexecutionscenarios,assumingthatthephaseguardsare
alreadycomputed.Intuitively,itgatherssequencesofphasesthat
could be visited by a program: the feasibility of every transition is
checkedbyan SMTsolver using the symbolic encoding of ğ‘ƒ.
Definition 4.2. Given a program ğ‘ƒ=âŸ¨VarsâˆªVarsâ€²,Init,TrâŸ©, a
phase-reachability tree DTPis a quadrupleâŸ¨ğ‘‰,ğ¸,ğ‘Ÿ,ğ‘âŸ©of sets of
vertices from some set ğ‘‰, edgesğ¸âŠ†ğ‘‰Ã—ğ‘‰, a rootğ‘Ÿâˆˆğ‘‰, and a
vertex-labelingfunction ğ‘:ğ‘‰â†’Î¨such that:
â€¢for allâŸ¨ğ‘Ÿ,ğ‘£âŸ©âˆˆğ¸: formula Init(Vars)âˆ§ğ‘(ğ‘£)(Vars)issatisfiable,
â€¢for allâŸ¨ğ‘£1,ğ‘£2âŸ©âˆˆğ¸,whereğ‘£1â‰ ğ‘Ÿ:
ğ‘(ğ‘£1)(Vars)âˆ§Tr(Vars,Varsâ€²)âˆ§ğ‘(ğ‘£2)(Varsâ€²)issatisfiable,
â€¢for all paths ğœ‹=âŸ¨ğ‘Ÿ,ğ‘£1,...,ğ‘£ğ‘›âŸ©inDTP, for every two vertices,
ğ‘£ğ‘–,ğ‘£ğ‘—âˆˆğœ‹: formulas ğ‘(ğ‘£ğ‘–)andğ‘(ğ‘£ğ‘—)are equisatisfiable only if
ğ‘–=ğ‘—.
Everypath ğœ‹inDTPcorrespondsto(aprefix)ofsomeexecution
ofğ‘ƒ,possiblyspurious.Whilethe DTPgivesusincompleteinfor-
mationaboutprogramtraces,itisoftensufficienttoderivephase
invariants,anditischeaptocompute.Notethatgettingthemost
precisephase-reachabilityinformationforaprogramcouldbediffi-
cult(evenimpossible)sinceitmayrequireknowingsomeauxiliary
(helper) invariants. However, even a coarse DTPfits well for the
purposes of our approach, which reasons automatically in terms
611ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Daniel Riley andGrigory Fedyukovich
Algorithm4: StrenDT(ğ‘ƒ,DTP)
Input:ğ‘ƒ=âŸ¨VarsâˆªVarsâ€²,Init,TrâŸ©: program,
DTP=âŸ¨ğ¸,ğ‘‰,ğ‘Ÿ,ğ‘âŸ©: phase-reachabilitytree
Output:DTP: augmentedphase-reachabilitytree
1forâŸ¨ğ‘¢,ğ‘£âŸ©âˆˆğ¸do
2ifğ‘¢=ğ‘Ÿthen
3 ğœ‘â†abduce(Init(Vars)=â‡’ğ‘(ğ‘£)(Vars));
4else
5 ğœ‘â†abduce(ğ‘(ğ‘¢)(Vars)âˆ§Tr(Vars,Varsâ€²)âˆ§
Â¬ğ‘(ğ‘¢)(Varsâ€²)=â‡’ğ‘(ğ‘£)(Varsâ€²));
6ifğœ‘Ì¸=â‡’falseand
ğœ‘(Vars)âˆ§Tr(Vars,Varsâ€²)=â‡’ğœ‘(Varsâ€²)then
7 forğ‘¤âˆˆsubtree(DTP,ğ‘£)do
8 ğ‘(ğ‘¤)â†ğ‘(ğ‘¤)âˆ§ğœ‘;
of batches of loop iterations and discovers some Å‚locally inductiveÅ¾
factsaboutphases(see Sect. 5).
Weslightlyabusethenotation,andforanedge âŸ¨ğ‘¢,ğ‘£âŸ©,wereferto
the phase associatedwith ğ‘¢(resp.ğ‘£) as to a Å‚parentÅ¾ (resp. Å‚childÅ¾)
phase. Construction of the DTPfrom the set of phase guards ğº
returnedbyAlgorithm 3isratherstraightforward:itposesanumber
of SMT checks, as shown in Def. 4.2, given a set of phase guards
and the symbolic encoding of ğ‘ƒ. At each Å‚parentÅ¾ phase ğ‘£ğ‘–and
each potential Å‚childÅ¾ phase ğ‘£ğ‘—from some ğºğ‘–âŠ†ğº, the reachability
is checked by posing a satisfiability query to an SMT solver. If
successful, edgeâŸ¨ğ‘£ğ‘–,ğ‘£ğ‘—âŸ©is added to ğ¸, and the construction process
recursesfor ğ‘£ğ‘—andğºğ‘–\{ğ‘£ğ‘—}. Unsatisfiability ofsomereachability
formula guarantees that it is impossible in general to have a phase
ğ‘£ğ‘—right after ğ‘£ğ‘–.
Note that by construction, some elements of the initial ğºmay
appear in the final DTPseveral times, but only once per path. That
is, each path ğœ‹captures only phase guards without repetitions:
even if a phase of ğ‘ƒis visited multiple times during ğœ‹, the phase
guardoccursin ğœ‹exactlyonce.Inthecaseofinterleavingphases,
traversalofthe DTPÅ‚cyclesÅ¾through ğœ‹.Thus,theconstructed DTP
alwayshasafinitedepthwhichmakesitconvenientforthefurther
synthesis process.
4.3 Context-Specific PhaseGuard
Strengthening
WhileourprimarysourceofphaseguardsistheMBPprocedure,
insomecases,thediscoveredformulasarenotstrongenoughtobe
phaseguards.Ourmotivating example illustrates thiscase. Recall
Example4.1, in which formula ğ‘¦>ğ‘¥div1000is generated. How-
ever,if we use it solely(i.e.,without conjoining with ğ‘¦>0)inthe
phase guardfor someinvariants, our algorithm will not be able to
produce the desiredinvariants,as inFig. 5.
Intuitively,phaseguardstrengtheningisneededtobringmore
context information into the phases, e.g., if a value of some vari-
able(s) is unknown at the initial state, then the loop may have
severaldifferentphasescenarios,dependingontherangesofpossi-
blevaluesofthatvariable(s).Inordertobringthisspecificphase-
reachabilityinformationtoinvariants,weperform strengthening of
DTPafter itisgeneratedfrom MBPs inSect. 4.2.Algorithm 4gives pseudocode of the algorithm. It has two parts:
discovery of strengthening, and its propagation to the subtree. The
algorithmtraversesthetree top-to-bottom andfindsedges,where
theendaÅ‚parentÅ¾phasedoesnotimplythebeginningoftheÅ‚childÅ¾
phase. The main idea is to infer a (reasonably weaker) condition
underwhichtheÅ‚childÅ¾phaseisreachable,andthenaddittothe
phase guard of the Å‚child phaseÅ¾. This is commonly achieved by
abduction[ 15],and ourpseudocode usesthefollowing implemen-
tation basedonquantifierelimination:
abduce(ğ´(Vars)=â‡’ğµ(Vars))def=QE(âˆ€Vars\ğ‘Š .ğ´=â‡’ğµ)
whereğ‘Šisasubsetof Vars,whichcanbefoundheuristically.Inour
implementation, we enumerate different ğ‘Šuntil abduction results
in a formula, that is non-trivial and locally inductive. Then it is
conjoined to all phase guards associated with the vertices in the
subtree.
Example4.3. For Example 4.1,theneed ofstrengtheningofthe
phaseguardisrevealedbysolving the validity of formula:
ğ‘¥=0âˆ§ğ‘§=0=â‡’ğ‘¦>ğ‘¥div1000
Because the implication does not hold, we aim at finding a (reason-
ably weaker) predicate ğœ‘to be conjoined with the antecedent to
make the implication valid. Because there is only one model for
formulağ‘¥=0âˆ§ğ‘§=0, then constraining ğ‘¥orğ‘§makes no sense.
Thus, the abducible predicate ğœ‘has to be applied to variable ğ‘¦, and
itcan be foundbyQE over the following formula:
Â¬QE(âˆƒğ‘¥,ğ‘§.(ğ‘¥=0âˆ§ğ‘§=0âˆ§ğ‘¦â‰¤ğ‘¥div1000)).
The resultingformula ğ‘¦>0islocally inductive,
Strengthening produced this way is not unique, and in principle
thisproceduremayberepeatedseveraltimes,thatcanfurtherbe
exploitedbyseveral(maybe,parallel)runsofthemainalgorithm
(see thenextsection). Itisalsopossible toinferstrengtheningof
DTPbeginning from the query in the reverse order. We omit these
extensionsofour approach inthe interestof savingspace.
5 INVARIANTSYNTHESIS BASEDON PHASE
REACHABILITYTREE
In this section, we present our core contribution: an automated
algorithmto discovermulti-phaseinvariants. Itrelies onthe phase-
reachability tree DTP, precomputed (and possibly strengthened) as
shown in Sect. 4. The main insights are to search for candidates,
that do not pass the initiation/inductiveness checks in Houdini, to
attempttoweakenthemusingphasesfrom DTP,and(importantly),
togeneratenewcandidates forthenextphases.Whilethissection
focuses on conveying the main ideas, the two important design
choicesfor newcandidate generationare deferredto Sect. 6.
5.1 Overview
Algorithm 5givesanoverviewofourapproach.Ittakesasinput
a set of candidates for invariants, which can be originated from
any external source like data learning (recall Sect. 3.3), SyGuS,
e.g.[18,50,54], orany setof predeterminedtemplates.
ThealgorithmtheninvokesAlgorithm 2tocomputeaninductive
subsetoflemmasfromthegivensetofcandidates.Iftheconjunc-
tion of lemmas is safe, the program is correct, and the algorithm
612Multi-Phase Invariant Synthesis ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Algorithm5: ImplCheck(ğ‘ƒ,Cands,PhaseInvs ,DTP).
Input:ğ‘ƒ=âŸ¨VarsâˆªVarsâ€²,Init,TrâŸ©: program; Candsâˆˆ2Î¨,
PhaseInvsâˆˆ2Î¨,DTP: precomputed
phase-reachabilitytree
Output:inductive Lemmasâˆˆ2Î¨
1âŸ¨res,LemmasâŸ©â†Houdini(ğ‘ƒ,CandsâˆªPhaseInvs);
2ifres=safethen return safe;
3ifCands\Lemmas=âˆ…then return unknown ;
4pickâ„“âˆˆCands\Lemmas;
5PhaseInvsâ†
WeakenAndPropagate (ğ‘ƒ,â„“,DTP)âˆªPhaseInvs ;
6returnImplCheck(ğ‘ƒ,Cands\{â„“},PhaseInvs ,DTP);
Algorithm6: WeakenAndPropagate (ğ‘ƒ,â„“,DTP).
Input:ğ‘ƒ=âŸ¨VarsâˆªVarsâ€²,Init,TrâŸ©: program; â„“âˆˆÎ¨: an
invariantcandidate; DTP=âŸ¨ğ‘‰,ğ¸,ğ‘Ÿ,ğ‘âŸ©:
phase-reachabilitytree
Output:Candsâˆˆ2Î¨
1Candsâ†âˆ…;
2for{ğ‘£1,...,ğ‘£ğ‘›}âˆˆpaths(DTP)do
3forğ‘–=1,...ğ‘›do
4 â„“ğ‘–â†â„“;
5 forğ‘—=(ğ‘–âˆ’1),...,0do
6 â„“ğ‘—â†BwPropagate(ğ‘ƒ,â„“ğ‘—+1,ğ‘(ğ‘£ğ‘—),ğ‘(ğ‘£ğ‘—+1),ğ‘˜);
7 forğ‘—=(ğ‘–+1),...,ğ‘›do
8 â„“ğ‘—â†FwPropagate(ğ‘ƒ,â„“ğ‘—âˆ’1,ğ‘(ğ‘£ğ‘—âˆ’1),ğ‘(ğ‘£ğ‘—),ğ‘˜);
9 Candsâ†Candsâˆª/braceleftbig
ğœ†Vars.(ğ‘(ğ‘£ğ‘š)(Vars)=â‡’â„“ğ‘š(Vars))/bracerightbigğ‘›
ğ‘š=0;
10returnCands;
terminates(line 2).Otherwise,itpicksacandidate â„“thatfailediniti-
ation(1)and/or consecution (2), then searches for a suitable phase
amongverticesof DTPthatcanweaken â„“(line4).Theweakening
and new candidate generation is performed in Algorithm 6. Lastly,
a set of new phase candidates is unified with the set of candidates
tobecheckedby Houdini inthenextrecursivecallofAlgorithm 5.
A phase lemma has the form of implication, and it is guessed in
Algorithm 6(line9) by composing a guard, as the left-hand side
of the implication, and a formula â„“, taken either from the initial
candidatesetorderivedfromitastheright-handside.Algorithm 6
is iterative in nature: it generates sequences of phase candidates,
followingtheactualpathsof DTP.Thatis,ifaphasecandidateis
created for the initial candidate â„“and anğ‘–thphase of some path ğœ‹,
thenthealgorithmseekstopropagate â„“backwardtothe(ğ‘–âˆ’1)th
phaseofğœ‹,forwardto(ğ‘–+1)thphase,andifsuccessful,evenfurther.
Example 5.1. Recall Example 3.6and failed candidate ğ‘§=0
for Example 3.4. Following the rightmost path of DTPin Fig.3,
thealgorithmguessesthefirstconjunctofinvariantinFig. 5and
proceedsto the nexttwophases.
Soundnessofouralgorithmisimmediate:sincebasedon Hou-
dini,itonlyterminateswith safewhenalltheconditionsofDef. 3.3
are fulfilledbyan external SMTsolver.Theorem 5.2 (Termination). Assuming termination of Houdini
and oftheSMT solver,thenAlgorithm 5will terminate.
Given an initial set of candidate invariants, ğ‘, and a formula Tr,
there can only be a finite number of phase guards, ğ‘€, produced
by quantifier elimination. These two pieces are the input to Al-
gorithm5. On each iteration a candidate, â„“, is picked and sent to
Algorithm 6toattempttoconnectitwithaphase,line 9ofAlgo-
rithm6. The loop in Algorithm 6will terminate when all phases of
theTrhavebeenexplored(i.e.,allpathsin DTPhavebeenexplored,
of which there can be only a finite many), or when a candidate has
been matchedwithits appropriate phase.
There aretwoconditionsfor Algorithm 5to terminate,bothof
whichareguaranteed.Either Houdini returnswitharesult safe
(line2),orthealgorithmrunsoutofcandidatestocheckandreturns
unknown (line3).Thealgorithmconsidersatmostapolynomial
number of distinct candidates, meaning if no safeinvariant is
found,theresult unknown isreturnedafterthesetofcandidates
isexhausted.
5.2 Optimizations
Forreadabilitypurposes,Algorithm 6ispresentedinanoversimpli-
fied form, so a direct implementation of which could be inefficient.
Specifically,twoouternestedloopsattempttomatchcandidate â„“
witheverypossiblephase(often,severaltimes).Inpractice,there
are many optimization opportunities (which we have in the imple-
mentation) that check the consistency of â„“and each phase ğ‘(ğ‘£ğ‘–)
beforecreatingcandidates.Inparticular,beforeproceedingtoline 4,
we require the following.
â€¢For the head ğ‘£1ofevery path,we require that
Init(Vars)âˆ§ğ‘(ğ‘£1)(Vars)=â‡’â„“(Vars)isvalidsinceotherwisethe
initiationcondition ( 1) wouldnot hold.
â€¢Similarly, for every ğ‘£ğ‘–, we require that ğ‘(ğ‘£ğ‘–)(Vars)âˆ§â„“(Vars)âˆ§
Tr(Vars,Varsâ€²)âˆ§ğ‘(ğ‘£ğ‘–+1)(Varsâ€²)is satisfiable (we do not use a
stronger constraint involving the validity here since we may
not know the precise reachability information at an arbitrary
phase).
Additionally:
â€¢Every edge of DTPneeds to be processed only once (for some
path),andshould be skippedinthe otherpaths.
â€¢Lemma propagation may be ineffective, i.e., depending on the
strategy (to be presented in Sect. 6), it may return trueorfalse
candidates. The loops at lines 6and8break in this case, and the
algorithm proceedsto anewphaseorcandidate.
In practice, it is rarely the case that many candidates require
all iterations of triple-nested loops in Algorithm 6. Recall, that
input candidates to this algorithm are failed by Houdini, so our
expectation then is that they will work only on a subset of phas-
es/paths.Thus,inpractice,theaforementionedoptimizationsare
often sufficient to preventthe algorithm from diverging.
6 SYNTHESIS OFPHASELEMMAS
In this section, we describe our lemma synthesis strategies for
Algorithm 6that are specifically tailored to a more semantically-
aware search, based respectively on candidate propagation and
data learning. These two approaches are used in Algorithm 6at
613ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Daniel Riley andGrigory Fedyukovich
ğ‘¥=0âˆ§ğ‘¦=767976âˆ§ğ‘§=0=â‡’Inv(ğ‘¥,ğ‘¦,ğ‘§)
Inv(ğ‘¥,ğ‘¦,ğ‘§)âˆ§ğ‘¥â€²=ğ‘¥+1âˆ§ğ‘¦â€²=ğ‘¦âˆ’1âˆ§
ğ‘§â€²=ite((ğ‘¥âˆ’ğ‘¦)mod3=1,ğ‘§+3,ğ‘§)=â‡’Inv(ğ‘¥â€²,ğ‘¦â€²,ğ‘§â€²)
Inv(ğ‘¥,ğ‘¦,ğ‘§)âˆ§ğ‘¥â‰¥280275âˆ§Â¬(ğ‘§â‰¥280275)=â‡’false
Figure 6:Transition system encoding.
the callFw/BwPropagate . The difference between these can be
treatedasademarcationbetweenamore-generalinstantiationof
our algorithm (Sect. 6.1) and the one specific to arithmetic theories
(Sect.6.2).
6.1 PhasePropagation usingQuantifier
Elimination
Intuitively, once a candidate invariant and its phase guard is cre-
ated, we can try to propagate it to the next phase, i.e., to a loop
iteration where another phase guard holds, based onour DTP. For
any background theory that admits Quantifier Elimination (QE),
Algorithm 6can propagatecandidates using Def. 6.1.
Definition6.1. Givenatransitionrelation Tr(Vars,Varsâ€²),anda
phasecandidate ğ‘”(Vars)=â‡’â„“(Vars),andanextphaseguard gğ‘›ğ‘’ğ‘¥ğ‘¡,
theFwPropagate methodcomputes acandidate as follows:
QE(âˆƒVars.Tr(Vars,Varsâ€²)âˆ§g(Vars)âˆ§
â„“(Vars)âˆ§gğ‘›ğ‘’ğ‘¥ğ‘¡(Varsâ€²))[Vars/Varsâ€²]
TheBwPropagate methodcomputes acandidate as follows:
QE(âˆ€Varsâ€².Tr(Vars,Varsâ€²)âˆ§gğ‘›ğ‘’ğ‘¥ğ‘¡(Vars)âˆ§g(Varsâ€²)=â‡’â„“(Varsâ€²))
Example6.2. Fig.6gives aprogram with three phases,and its
inductive invariantisas follows.
Invâ†¦â†’ğœ†ğ‘¥,ğ‘¦,ğ‘§.ğ‘¥+ğ‘¦=767976âˆ§
(ğ‘¥âˆ’ğ‘¦)mod3=0=â‡’ğ‘¥=ğ‘§âˆ§
(ğ‘¥âˆ’ğ‘¦)mod3=1=â‡’ğ‘¥âˆ’ğ‘§=2âˆ§
(ğ‘¥âˆ’ğ‘¦)mod3=2=â‡’ğ‘¥âˆ’ğ‘§=1
Forward reasoning begins with an analysis of the initial state:
ğ‘¥+ğ‘¦=767976andğ‘¥=ğ‘§directlyfollowfromtheinitialassignments
to the variables. While the former is a global invariant in contrast,
the latter needs the phase guard (ğ‘¥âˆ’ğ‘¦)mod3=0. In order to
propagate this candidate forward, we note that under this phase, ğ‘¥
grows by one and ğ‘§does not change, thus if ğ‘¥was equal to ğ‘§then
ğ‘¥â€²âˆ’ğ‘§â€²=1,giving usthe nextcandidate ğ‘¥âˆ’ğ‘§=1.
In practice, propagated candidates are often too strong because
theydescribeexactlywhathappensinthenextstepafterswitching
toanewphase.Inmanyothercases,helperinvariantsneedtobe
discovered prior to quantifier elimination, otherwise the synthesis
proceduredoesnothaveenoughinformationabout theswitching
state. This motivatesus to designalternative strategies forsynthe-
sizingphaselemmasincertaintheories.
6.2 Fast-Forwarding to Data Candidates
Numerictheoriesenjoywell-knownapproacheslike[ 60]todata-
driven invariant generation. Gathering data for the early phases ofAlgorithm7: FwPropagate(ğ‘ƒ,Inv(Vars),g,gğ‘›ğ‘’ğ‘¥ğ‘¡,ğ‘˜):
data gatheringat arbitrary point.
Input:ğ‘ƒ=âŸ¨VarsâˆªVarsâ€²,Init,TrâŸ©: program;
Inv: invariant; g: phase-guard; gğ‘›ğ‘’ğ‘¥ğ‘¡: the next
phase-guard; ğ‘˜: unrolling bound
Output:ğ·ğ‘€: data matrixto be usedfor data learning
1unrlâ†g(Vars)âˆ§Inv(Vars)âˆ§gğ‘›ğ‘’ğ‘¥ğ‘¡(Varsâ€²);
2forğ‘âˆˆ[1,ğ‘˜]do
3unrlâ†unrlâˆ§Tr(Vars(ğ‘),Vars(ğ‘+1));
4letMbe s.t. M|=unrl;
5ifM=âˆ…then
6returnâˆ…;
7forğ‘âˆˆ[1,ğ‘˜]do
8ifM|=gğ‘›ğ‘’ğ‘¥ğ‘¡(Vars(ğ‘))then
9 ğ·ğ‘€â†addRow(ğ·ğ‘€, M(Vars(ğ‘)));
10candFromGaussJordan (ğ·ğ‘€);
11return;
anexecutionistrivialsincetheunrollingbeginsfromthe Initstate,
recallSect. 3.3.Anaiveapproachwouldunrolltheprogramwhile
thefirstphaseguardholds.Theresultingmatrixwouldproducea
candidate lemma for the phase, however, this is not scalable due to
thetaxingnatureoflargeprogramunrollings.Tosolvethisproblem,
we produce useful data in a more economical way with the notion
ofÅ‚fast-forwardingÅ¾.4
Tostart,atraceisproducedasinAlgorithm 7(line3)ofsome
lengthğ‘˜5.Thenthesupportinglemmas6,aphaseguard,andthe
next phase guard are added (line 1). By providing a phase guard
(g(Vars)in(4))wearerequiringtheunrollingtobeginataparticular
pointintheexecution.Importantly,wealsoprovide Inv(Vars),all
lemmaslearnedsofar,andthe phaselemmasassociatedwith g.
g(Vars)âˆ§Inv(Vars)âˆ§Tr(Vars,Varsâ€²)âˆ§gğ‘›ğ‘’ğ‘¥ğ‘¡(Varsâ€²)âˆ§(4)
Tr(Varsâ€²,Varsâ€²â€²)âˆ§...âˆ§ğ‘‡ğ‘Ÿ(Vars(ğ‘˜âˆ’1),Vars(ğ‘˜))
An invariantfor the program inthe examplefromFig. 7requires
asupportinglemmatodiscover,andmustbeprovidedtothesolver
beforeanunrollingbegins(line 1ofAlgorithm 7).Otherwisethe
invalidmatrix NoGuard orLemmas inFig.8maybe produced.
If the solver is provided with the lemma ğ‘¥â‰¥ğ‘¦(line1), then it
canproducevalidinformationtocreatetheothertwomatricesin
Fig.8,oneforeachphase.Eachrevealsaphaselemmathattogether
withtheirphaseguardverifies the program.
TheEvenphase matrix has a basis vector of/parenleftbigâˆ’1
2/parenrightbigwhich yields
the phase lemma ğ‘¥=2ğ‘¦. Applying the next guard, ğ‘¥mod2=1
yields the phase lemma ğ‘¥=2ğ‘¦âˆ’1. The algorithm then terminates
withthe invariant:
Invâ†¦â†’ğœ†ğ‘¥,ğ‘¦.ğ‘¥mod2=0=â‡’ğ‘¥=2ğ‘¦âˆ§
ğ‘¥mod2=1=â‡’ğ‘¥=2ğ‘¦âˆ’1
4AÅ‚fast-backwardingÅ¾conceptisdefinedsimilarlyandskippedintheinterestofspace.
5Ourimplementationusesavalueof10for ğ‘˜.Thisisdonetokeepunrollingssmallfor
performancereasons.Howevervaluesofupto30havebeentriedwithnoimprovement
to the outcomes.
6Supporting lemmas arethe previouslylearned lemmas from earlieriterations.
614Multi-Phase Invariant Synthesis ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
ğ‘¥=0âˆ§ğ‘¦=0=â‡’Inv(ğ‘¥,ğ‘¦)
Inv(ğ‘¥,ğ‘¦)âˆ§ğ‘¥â€²=ğ‘¥+1âˆ§
ğ‘¦â€²=ite(ğ‘¥mod2=0,ğ‘¦+1,ğ‘¦)=â‡’Inv(ğ‘¥â€²,ğ‘¦â€²)
Inv(ğ‘¥,ğ‘¦)âˆ§ğ‘¥=20000âˆ§Â¬(ğ‘¦=10000)=â‡’false
Figure 7:Transition system with alternatingphases.
NoGrd orLms
x y
-1 1
1 2
3 3Even phase
x y
2 1
4 2
6 3Oddphase
x y
1 1
3 2
5 3
Figure 8:Matrices produced foreachphase ofFig. 7.
The importance of our Å‚fast-forwardingÅ¾ technique lies in its
abilitytosynthesizedifficulttoinferlemmas,andassociatethem
with their phase. The expression ğ‘¥=2ğ‘¦âˆ’1is such an example,
sinceonitsownitisnoteasytodiscover,andthentocoupleitwith
thecorrectphaseguardisadifficulttask.Fast-forwardingtackles
thosetwochallengeswiththedatalearningapproachconnectedto
aparticularphase.
7 IMPLEMENTATION
We have implemented our algorithm, called ImplCheck , in the
latest version of the FreqHorn tool [18].FreqHorn follows the
SyGuS paradigm to guess-and-check for invariants derived from
syntax and data. We leverage this design to start the ImplCheck
algorithm.Thedecisiontreecontaining MBPsisbuiltintheearly
stagesofan execution,andonly onceinan execution.
Candidatesthatfailtheinitialinductivenesscheck (2)moveinto
Algorithm 5,whereweidentifythephasethatthecandidatebelongs
toinAlgorithm 6.Algorithm 6takesMBPsfromthedecisiontreeto
test as phase-guards, described in Sect. 4. If a guard is successfully
found, the guard and candidate are made into a phase-invariant in
the form ofimplication.
New candidates are also discovered by our data learning tech-
niquefromSect. 6.2.Weusephaseguardsandlearnedlemmasto
createanunrollingandthenobtainadatamatrixfromtheunrolling.
WithÅ‚fast-forwardingÅ¾weareabletoprobeaparticularphaseof
the program and connect lemmas discovered by the data learner
withthe phaseguardas anewphaseinvariant.
Additionally,weleveragethe candidatepropagation featureof
FreqHorn butmakeitmore phase-aware (recallSect. 6.1), which
allowsfor lifting successfulcandidates to the nextphase.
8 EVALUATION
We are interestedinansweringthe following researchquestions:
â€¢RQ1: How effective is ImplCheck in solving multi-phase bench-
markscomparedto state-of-the-artCHCsolvers?
â€¢RQ2:Howcrucialaredatalearningviafast-forwardingandMBP
strengthening to solving multi-phase benchmarks?
â€¢RQ3:Howdoes ImplCheck performonalargesetofwellstudied
benchmarks?Throughout this section we discuss these questions in the context
ofour experimental results. The results are summarizedinTab. 1.
ExperimentalResults. ImplCheck hasbeencomparedagainst
CHCsolvers FreqHorn [18],PCSat[58],IC3IA[13],GSpacer [38],
Spacer[37],Hoice[10],Eldarica [32],andGolem[8],andSyGuS
solversLoopInvGen [52], andCVC5[54]. Since the input to all of
these tools adheres to the SMT-LIB2 format (or the sister SyGuS-
format),wedonotcomparetoothersoftwareverificationtoolsthat
wouldrequireadditionalsymbolicexecution/encodingofprograms
to symbolic constraints, making the experimental comparison less
fair.
RQ1. We analyzed the performance of ImplCheck on 54 safe
multi-phasebenchmarkspreviouslystudiedby Golem[8].These
programs are over integers and have single loops with a variety of
phasestructures.
With a 5 minute timeout, ImplCheck can solve 44 of the 54,
thelargestnumberofallthetoolsinthecomparison. FreqHorn
cansolve28. Eldarica performedthebestoutofthecomparison
tools,solving25ofthemulti-phasebenchmarks. Eldarica â€™sability
to solve these likely comes from its use of disjunctive interpola-
tion [56].GSpacer solved 19, Hoice, andGolemeach solved 17.
PCSatandIC3IAeach solved 15 respectively, while CVC5and
Spacersolved 11 and 10. Finally, LoopInvGen solved 9. These
results are displayedinTable 1.
Thereare10benchmarksthatareonlysolvedby ImplCheck ,and
onesuchexamplefortheothertools,whichisuniquelysolvedby
Golem. These results show that ImplCheck is capable of verifying
avarietyofphasestructures.
RQ2.Wecomparedtheperformanceof ImplCheck invarious
configurations,isolatingthesubsystemsofthealgorithmtohigh-
light their impact. A summary of the results is in Table 2, which
displays the lemma synthesis method, the direction of propagation,
the number solved,the averageandthe median time to solve.
The subsystems are described in Sect. 4-6. In summary, Phase-
Datagenerates lemmas using the fast-forwarding data learning
technique, PhaseProp propagateslemmasacrossphases,and Stren-
MBPstrengthenstheguardsintheDT. FwdPropagate andBwd-
Propagate determine thedirection oftraversalthroughthe pro-
gram.Bydefaultbothforwardandbackwardpropagationareen-
abled,but we explicitly disableone to parse outtheir impact.
Data learning with fast-forwarding, PhaseData , turns out to be
themostimpactfulsubsystemonitsown.Thisfeature,withforward
propagation, solves 40 benchmarks. PhaseProp with backward
propagation solves a similar number of benchmarks as forward,
and proves to be a useful tactic for some cases, with two examples
solvedby Bwdthat are not solvedwith Fwd.
The combination of the three options, PhaseData ,PhaseProp ,
andStrenMBP , along with FwdPropagate solves the highest
number of benchmarks at 41. There is a noticeable time cost across
the tests however, with the median solve time around two seconds
instead of below one second. PhaseData is able to solve many
more of the examples below one second than the three options
togethercan.
It is worth noting that even the worst configuration of Impl-
Check,PhaseData Bwd , still outperforms all of the tools used for
comparison.
615ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Daniel Riley andGrigory Fedyukovich
Table 1:Timingsinseconds( ğœ–standsforaruntime less than asecond; âˆstandsfornotsolved).
Benchmark ImplCheck FreqHorn GSpacer Spacer IC3IA LoopInvGen Eldarica CVC5 Hoice PCSat Golem
s_split_01 ğœ– 1.88 4.38 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_02 ğœ– 6.91 ğœ–62.10âˆ âˆ âˆ âˆ ğœ–âˆ188.31
s_split_03 1.63 73.55 âˆ âˆ âˆ âˆ 1.06âˆ ğœ–14.39âˆ
s_split_04 2.47 1.92 ğœ–âˆ âˆ âˆ 3.48âˆ5.29âˆ âˆ
s_split_05 ğœ– ğœ– ğœ– ğœ– ğœ– ğœ– ğœ– 2.40 ğœ–1.42 ğœ–
s_split_06 ğœ–âˆ 2.35âˆ âˆ âˆ 3.63âˆ âˆ 14.54âˆ
s_split_07 ğœ– ğœ– ğœ– âˆ ğœ–âˆ 1.11 20.50 ğœ–1.79âˆ
s_split_08 2.83 2.83 âˆ âˆ âˆ âˆ âˆ âˆ âˆ 1.35âˆ
s_split_09 ğœ– 3.89âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_10 ğœ– 10.84âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_11 ğœ– 37.60âˆ âˆ âˆ âˆ âˆ âˆ ğœ–âˆ âˆ
s_split_12 ğœ– 18.97âˆ âˆ âˆ âˆ 1.22âˆ âˆ âˆ âˆ
s_split_13 âˆ âˆ âˆ âˆ ğœ– ğœ– ğœ– 10.37 ğœ–1.74 ğœ–
s_split_14 âˆ âˆ âˆ âˆ âˆ âˆ 26.38âˆ âˆ âˆ 18.60
s_split_15 1.41 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_16 10.93 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_17 1.07 18.15 âˆ âˆ ğœ–âˆ 7.29âˆ âˆ 2.62 3.26
s_split_18 âˆ âˆ ğœ–âˆ âˆ âˆ 2.75âˆ ğœ–31.39 ğœ–
s_split_19 ğœ–âˆ ğœ– ğœ– ğœ– 21.98 ğœ–âˆ âˆ âˆ ğœ–
s_split_20 ğœ–âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_21 ğœ– ğœ– âˆ 53.81 21.31 âˆ 9.88âˆ ğœ–âˆ ğœ–
s_split_22 2.62 73.15 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_23 ğœ– ğœ– ğœ– âˆ ğœ– 1.89 1.52 ğœ– ğœ– 1.51 ğœ–
s_split_24 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ 189.53
s_split_25 âˆ âˆ âˆ âˆ âˆ âˆ 9.19 ğœ–âˆ âˆ ğœ–
s_split_26 ğœ– ğœ– 40.40âˆ ğœ– 1.09âˆ ğœ–âˆ1.24âˆ
s_split_27 1.96 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_28 ğœ– 54.00âˆ155.19 66.03 34.30 1.30 286.28 âˆ âˆ âˆ
s_split_29 108.69 âˆ 21.88âˆ âˆ âˆ 32.18âˆ âˆ âˆ âˆ
s_split_30 âˆ âˆ âˆ âˆ 3.17âˆ âˆ âˆ âˆ âˆ ğœ–
s_split_31 4.72 4.72 âˆ âˆ âˆ âˆ 1.29âˆ âˆ âˆ âˆ
s_split_32 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_33 ğœ–âˆ âˆ âˆ âˆ 2.15âˆ âˆ âˆ âˆ âˆ
s_split_34 1.99 âˆ ğœ–126.86 253.89 3.94 5.24 âˆ4.51 264.58 âˆ
s_split_35 âˆ âˆ ğœ–âˆ âˆ âˆ 1.55âˆ âˆ âˆ âˆ
s_split_36 ğœ– ğœ– ğœ– âˆ ğœ– ğœ– 1.08 ğœ– ğœ– 1.24 ğœ–
s_split_37 2.83 âˆ ğœ– ğœ– ğœ– âˆ 13.94âˆ107.56âˆ ğœ–
s_split_38 92.12 6.90 ğœ–âˆ ğœ–âˆ 1.09âˆ ğœ–1.86 ğœ–
s_split_39 ğœ– ğœ– 8.48 44.05 2.08 âˆ 2.05 50.78 ğœ–1.37 ğœ–
s_split_40 âˆ âˆ âˆ 153.13âˆ âˆ âˆ âˆ âˆ âˆ 4.44
s_split_41 ğœ– 139.37âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_42 ğœ–âˆ ğœ–âˆ âˆ âˆ 3.61 11.33 ğœ–1.56âˆ
s_split_43 3.15 129.51 âˆ âˆ âˆ âˆ âˆ âˆ ğœ–âˆ âˆ
s_split_44 1.22 104.14 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_45 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_46 ğœ– 255.42 276.28 30.23 âˆ âˆ ğœ–33.33âˆ âˆ âˆ
s_split_47 1.65 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_48 ğœ–âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_49 ğœ–âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_50 3.64 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_51 1.22 70.94 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_52 ğœ– 88.14âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_53 3.24 âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
s_split_54 ğœ– 58.05âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ âˆ
Total Solved 44 28 19 10 15 9 25 11 17 15 17
Uniquely Solved 10 0 0 0 0 0 0 0 0 0 1
AvgTime/Solved 6.18 41.48 18.78 62.58 23.13 7.45 5.38 37.77 7.07 22.84 23.80
Median Time/Solved ğœ– 8.88 ğœ–48.93 ğœ– 1.89 1.55 10.37 ğœ–1.74 ğœ–
Table 2:Summary of ImplCheck subsystems.
Benchmark
PhaseData
BwdPropagate
PhaseData
FwdPropagate
PhaseProp
BwdPropagate
PhaseProp
FwdPropagate
PhaseData
+StrenMBP
BwdPropagate
PhaseData
+StrenMBP
FwdPropagate
PhaseProp
+StrenMBP
BwdPropagate
PhaseProp
+StrenMBP
FwdPropagate
PhaseData
+PhaseProp
BwdPropagate
PhaseData
+PhaseProp
FwdPropagate
PhaseData
+PhaseProp
+StrenMBP
BwdPropagate
PhaseData
+PhaseProp
+StrenMBP
FwdPropagate
TotalSolved 29 40 31 33 30 39 31 34 29 40 32 41
AvgTime/Solved 24.15 18.72 17.81 21.34 17.03 3.33 20.49 28.12 15.22 7.40 28.92 4.30
Median Time/Solved ğœ– ğœ– ğœ– 1.07 2.30 ğœ– 1.03 1.06 1.23 1.72 3.06 2.06
616Multi-Phase Invariant Synthesis ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
Table 3:Summary ofresults overgeneralbenchmarks.
Benchmark ImplCheck FreqHorn Eldarica GSpacer Golem IC3IA
Total Solved 244 237 237 224 149 206
AvgTime/Solved 11.19 6.71 4.43 2.93 5.28 5.43
Median Time/Solved 3.43 1.93 1.06 ğœ– ğœ– ğœ–
RQ3.Wecomparedtheperformanceof ImplCheck onasetof
277wellstudiedbenchmarkstakenfrompreviousliterature[ 16Å›
19,25].Thissetofbenchmarkscoversbothsingleloopandmulti-
loop programs, with the multi-loop programs having either nested
loopsorconsecutive loops.
Whatweaimtoshowisthattheoverheadfrom ImplCheck is
notprohibitivelylargeonmoregeneralcases.TheresultsinTable 3
show that ImplCheck is abletoverifymore benchmarksthanthe
other tools, and the average overhead for examples solved by both
ImplCheck andFreqHorn isonly4.5seconds. ImplCheck solves
244ofthe277and FreqHorn solves237.Thisresultisencouraging
because it shows that ImplCheck is not pinned to solving one
programtype(ie.multi-phase)andaddsonlyasmalloverheadto
theseexamples.
9 THREATS TO VALIDITY
OurapproachhasbeenbuiltundertheconsiderationofLIAandthe
assumptionthattheunderlyingtheoryadmitsquantifierelimina-
tionforMBPgeneration.Toextendthisapproachtoothernumeric
theorieswewouldneedtoconsiderhowtogenerate MBPssince
theyarecrucialtoourphasefindingalgorithm.ForBooleanpro-
grams,sinceourfast-forwardalgorithmreliesondatalearningwith
integers, we could instead rely on a QE approach to solve those
problems.
ImplCheck isaCHCSolverandtakestheoutputofaverification
front end, like SeaHorn [ 27]. We rely on the correctness of the
translationfromthesourcecodefortheinputtoouralgorithm.Ifthe
translationresultsinmulti-phaseloops,webelieveouralgorithm
wouldhave successverifying thosecases.
Our analysis of program phases, and the construction of our
DTP, in a worst case scenario could be exponentially expensive.
However,inpracticethisanalysisiscompletedinlessthanasecond
forbothmulti-phaseexamplesandthebenchmarksinthelargeset,
including MBPstrengthening.
10 RELATED WORK
InductiveInvariantSynthesis. There are many automatedsoft-
ware verification approaches that discover proofs in the form of an
inductiveinvariant[ 1,4,9,16,23,24,26,29Å›31,34,36,37,39,41,44].
There are many barriers to this problem, mainly due to its unde-
cidability, requiring us to continue to look into this problem and
consistentlyenlargetheapplicabilityofthetools.Whilemanymeth-
ods have been successfully used for invariant synthesis, the vast
majority donot reliably solve the caseofmulti-phasedloops.
SyGuS[2]isalsousedforgeneratingsafeinductiveinvariants
with the help of either a user provided grammar [ 52,54], or an
automaticallygeneratedone[ 18].Thereareseveralpositivestothis
approach,and ImplCheck takesadvantageofenumerationearlyin
theexecutiontofindaninitialsetofcandidates.Providingadetailed,fine-grain, grammar could in theory allow for the verification of
multi-phase programs with previous SyGuSapproaches. However,
the grammar would need to include details about the construction
ofimplicationsandthe needfor supportinglemmas.
Multi-phase Loops. Verification of loops with phases requires
disjunctiveinvariants,andhasbeenthesubjectofseveralworks[ 5,
56,64]. The studies to synthesize disjunctive invariants appears
inseveralfields,suggestingthisisanimportantproblemtosolve.
Workonthisproblemhaseitherreliedonexplicitlysplittingaloop
ofconsecutivephases[ 59],neededauser-providedgrammarand
interaction[ 22],orusedabstractiontechniqueswhichÅ‚naturallyÅ¾
include disjunctions [ 64]. Other work on disjunctive invariant syn-
thesiswereapproachedbyAbstractInterpretation[ 46,57],GrÃ¶bner
basis computation [ 33], andSyGuS[53]. An approach to loop sum-
marization[ 61]reasonsaboutprogramphasesusingÅ‚lazyÅ¾QE,but
does not connectthemwithsupportinginvariants.
Noneoftheseofferashighadegreeofflexibilityasourapproach:
our fast-forwarding technique is effective in finding non-trivial
invariantsthatarehardfortechniquesworkinginrigiddomains,
andtheymayrequiresupportinginvariantstocompleteverification.
Ourapproachisalsoagnostictothesyntacticloopstructureofa
programandaimsat recovering itfromthesymbolicencoding(that
e.g.,could flatten nestedloops).
Data-driven Approaches. Previous work such as [ 20,43,47,
51,60] use data derived from a given program to aid the inference
of candidate invariants. At the core of these approaches is a guess-
and-check structure,wherethe guessphaseusesdatacollectedfrom
program traces and the checkphase gathers data from counter-
examples. Invariants in the form of both inequality and equality
can be synthesized from traces using techniques from [ 48,49]. Ma-
chine learning techniques for verification [ 25,63] also use counter-
example-derived data. It is our extension of the data-driven ap-
proach,withour fast-forwardingtechniquetoproduce aprogram
traceatanarbitrarypointinaprogramsexecution(typicallyaround
the pointsofaphasechange), that setsour work apart.
11 CONCLUSION
Wehavepresentedanovelapproachtosynthesizesafeinductive
invariants by implicit splitting of program phases, and we have
augmented the FreqHorn algorithm to use our new technique,
calledImplCheck .Our approachusesModel BasedProjectionsto
discoverphaseguards,storedinadecisiontree,anditusesadata
learning technique to discover phase lemmas. Key pieces of this
approach are the ability to accurately fast-forward an unrolling to
generate meaningfuldata and generatethese two ingredients. We
have demonstratedthe usefulness of our approach by successfully
solving anumber ofchallenging verification tasks.
Motivation for future improvements to our approach include
investigatingthebenchmarkssolvedbyothertoolsbutnot Impl-
Checkand improving the efficiencyof our algorithm. Support for
arraysandalgebraicdatatypesisalsoagoalforfuturedevelopment.
Artifact Available. A virtual machine isavailable to reproduce
the reportedresults [ 55].
Acknowledgements. This work was partially supported by the
National ScienceFoundationgrant 2106949.
617ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore Daniel Riley andGrigory Fedyukovich
REFERENCES
[1]Aws Albarghouthi, Arie Gurfinkel, and Marsha Chechik. 2012. From Under-
Approximations to Over-Approximations and Back. In TACAS (LNCS, Vol. 7214) .
Springer, 157Å›172.
[2]Rajeev Alur, Rastislav BodÃ­k, Garvit Juniwal, Milo M. K. Martin, Mukund
Raghothaman, Sanjit A. Seshia, Rishabh Singh, Armando Solar-Lezama, Em-
ina Torlak, and Abhishek Udupa. 2013. Syntax-Guided Synthesis. In FMCAD.
IEEE,1Å›17.
[3]Tewodros A. Beyene, Swarat Chaudhuri, Corneliu Popeea, and Andrey Ry-
balchenko. 2014. A constraint-based approach to solving games on infinite
graphs.In The41stAnnualACMSIGPLAN-SIGACTSymposiumonPrinciplesof
Programming Languages, POPL â€™14, San Diego, CA, USA, January 20-21, 2014 ,
SureshJagannathanand PeterSewell(Eds.).ACM,221Å›234. https://doi.org/10.
1145/2535838.2535860
[4]Dirk Beyer, Matthias Dangl, and Philipp Wendler. 2015. Boosting k-Induction
withContinuously-RefinedInvariants.In CAV,PartI (LNCS,Vol.9206) .622Å›640.
[5]DirkBeyer,ThomasA.Henzinger,RupakMajumdar,andAndreyRybalchenko.
2007. Path invariants. In Proceedings of the ACM SIGPLAN 2007 Conference on
ProgrammingLanguageDesignandImplementation,SanDiego,California,USA,
June10-13,2007 ,JeanneFerranteandKathrynS.McKinley(Eds.).ACM,300Å›309.
https://doi.org/10.1145/1250734.1250769
[6]A.Biere,A.Cimatti,E.M.Clarke,O.Strichman,andY.Zhu.2003. BoundedModel
Checking. AdvancesinComputers 58(2003), 118Å›149.
[7]Nikolaj BjÃ¹rner andMikolÃ¡s Janota. 2015. Playingwith QuantifiedSatisfaction.
InLPAR (short papers) (EPiCSeriesinComputing, Vol.35) . EasyChair, 15Å›27.
[8]MartinBlicha,GrigoryFedyukovich,AnttiE.J.HyvÃ¤rinen,andNatashaShary-
gina. 2022. TransitionPower Abstractions for Deep Counterexample Detection.
InToolsandAlgorithmsfortheConstructionandAnalysisofSystems ,DanaFisman
and GrigoreRosu(Eds.).SpringerBerlin Heidelberg.
[9]AaronR.Bradley.2012. UnderstandingIC3.In SAT (LNCS,Vol.7317) .Springer,
1Å›14.
[10]Adrien Champion, Naoki Kobayashi, and Ryosuke Sato. 2018. HoIce: An ICE-
Based Non-linear Horn Clause Solver. In APLAS (LNCS, Vol. 11275) . Springer,
146Å›156.
[11]Byron Cook, Andreas Podelski, and Andrey Rybalchenko. 2006. Termination
proofsfor systems code. In PLDI. ACM,415Å›426.
[12]ByronCook,AbigailSee,andFlorianZuleger.2013. Ramseyvs.Lexicographic
Termination Proving. In TACAS (LNCS,Vol.7795) . Springer, 47Å›61.
[13]Jakub Daniel,Alessandro Cimatti,Alberto Griggio,StefanoTonetta, andSergio
Mover. 2016. Infinite-State Liveness-to-Safety via Implicit Abstraction and Well-
Founded Relations.In CAV,Part I (LNCS,Vol.9779) . Springer, 271Å›291.
[14]Leonardo MendonÃ§a de Moura and Nikolaj BjÃ¹rner. 2008. Z3: An Efficient SMT
Solver.In TACAS (LNCS,Vol.4963) . Springer, 337Å›340.
[15]Isil Dillig and Thomas Dillig. 2013. Explain: A Tool for Performing Abductive
Inference. In CAV (LNCS,Vol.8044) . 684Å›689.
[16]IsilDillig,ThomasDillig,BoyangLi,andKennethL.McMillan.2013. Inductive
invariantgenerationviaabductiveinference. In OOPSLA. ACM,443Å›456.
[17]Grigory Fedyukovich and Rastislav BodÃ­k. 2018. Accelerating Syntax-Guided
Invariant Synthesis.In TACAS, Part I (LNCS,Vol.10805) . Springer, 251Å›269.
[18]Grigory Fedyukovich, Samuel Kaufman, and Rastislav BodÃ­k. 2017. Sampling
Invariantsfrom Frequency Distributions.In FMCAD. IEEE,100Å›107.
[19]GrigoryFedyukovich,SumanthPrabhu,KumarMadhukar,andAartiGupta.2018.
Solving Constrained Horn Clauses Using Syntax and Data. In FMCAD. IEEE,
170Å›178.
[20]Grigory Fedyukovich, Sumanth Prabhu, Kumar Madhukar, and Aarti Gupta.
2019. Quantified InvariantsviaSyntax-GuidedSynthesis.In CAV,PartI (LNCS,
Vol.11561) . Springer, 259Å›277.
[21]Grigory Fedyukovich, Yueling Zhang, and Aarti Gupta. 2018. Syntax-Guided
Termination Analysis. In CAV, Part I (LNCS,Vol.10981) . Springer, 124Å›143.
[22]Yotam M. Y. Feldman, James R. Wilcox, Sharon Shoham, and Mooly Sagiv. 2019.
Inferring Inductive Invariants from Phase Structures. In CAV, Part II (LNCS,
Vol.11562) . Springer, 405Å›425.
[23]CormacFlanaganandK.RustanM.Leino.2001.Houdini:anAnnotationAssistant
for ESC/Java.In FME (LNCS, Vol.2021) . Springer, 500Å›517.
[24]PranavGarg, ChristofLÃ¶ding, P.Madhusudan, andDanielNeider. 2014. ICE:A
RobustFrameworkforLearningInvariants.In CAV (LNCS,Vol.8559) .Springer,
69Å›87.
[25]Pranav Garg, Daniel Neider, P. Madhusudan, and Dan Roth. 2016. Learning
invariants using decision trees and implication counterexamples. In POPL. ACM,
499Å›512.
[26]Sumit Gulwani and Nebojsa Jojic. 2007. Program verification as probabilistic
inference. In POPL. ACM,277Å›289.
[27]Arie Gurfinkel, Temesghen Kahsai, Anvesh Komuravelli, and Jorge A. Navas.
2015. The SeaHorn Verification Framework. In CAV (LNCS, Vol. 9206) . Springer,
343Å›361.
[28]ArieGurfinkelandJorgeANavas.2019. AutomaticProgramVerificationwith
SEAHORN. In EngineeringSecureandDependableSoftwareSystems .IOSPress,83Å›111.
[29]Matthias Heizmann, Jochen Hoenicke, and Andreas Podelski. 2010. Nested
interpolants.In POPL. ACM,471Å›482.
[30]Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar, and Kenneth L. McMillan.
2004. Abstractionsfrom proofs. In POPL. ACM,232Å›244.
[31]HosseinHojjat,FilipKonecnÃ½,FlorentGarnier,RaduIosif,ViktorKuncak,and
Philipp RÃ¼mmer. 2012. A Verification Toolkit for Numerical Transition Systems -
ToolPaper. In FM (LNCS,Vol.7436) . Springer, 247Å›251.
[32]Hossein Hojjat and Philipp RÃ¼mmer. 2018. The ELDARICA Horn Solver. In
FMCAD. IEEE,158Å›164.
[33]AndreasHumenberger,MaximilianJaroschek,andLauraKovÃ¡cs.2018. Invariant
GenerationforMulti-PathLoopswithPolynomialAssignments.In VMCAI (LNCS,
Vol.10747) . Springer, 226Å›246.
[34]Dejan Jovanovic and Bruno Dutertre. 2016. Property-directed k-induction. In
FMCAD. IEEE,85Å›92.
[35]Andreas Katis, Grigory Fedyukovich, Huajun Guo, Andrew Gacek, John Backes,
Arie Gurfinkel, and Michael W. Whalen. 2018. Validity-Guided Synthesis of
ReactiveSystemsfromAssume-GuaranteeContracts.In TACAS,PartII (LNCS,
Vol.10806) . Springer, 176Å›193.
[36]Zachary Kincaid, Jason Breck, Ashkan Forouhi Boroujeni, and Thomas W. Reps.
2017. Compositional recurrenceanalysis revisited.In PLDI. ACM,248Å›262.
[37]AnveshKomuravelli, Arie Gurfinkel,and SagarChaki. 2014. SMT-BasedModel
Checking for RecursivePrograms. In CAV (LNCS,Vol.8559) . 17Å›34.
[38]Hari Govind Vediramana Krishnan, YuTing Chen, Sharon Shoham, and Arie
Gurfinkel.2020. GlobalGuidanceforLocalGeneralizationinModelChecking.
InCAV (LNCS,Vol.12225) . Springer, 101Å›125.
[39]HariGovindVediramanaKrishnan,GrigoryFedyukovich,andArieGurfinkel.
2020. Word Level Property Directed Reachability. In ICCAD. IEEE,1Å›9.
[40]Ton Chanh Le, Shengchao Qin, and Wei-Ngan Chin. 2015. Termination and
non-termination specification inference. In PLDI. ACM,489Å›498.
[41]Ton Chanh Le, Guolong Zheng, and ThanhVu Nguyen. 2019. SLING: using
dynamic analysis to infer program invariants in separation logic. In PLDI. ACM,
788Å›801.
[42]Jongeun Lee, Seongseok Seo, Hongsik Lee, and Hyeon Uk Sim. 2014. Flattening-
basedmappingofimperfectloopnestsforCGRAs?.In 2014InternationalCon-
ference on Hardware/Software Codesign and System Synthesis, CODES+ISSS 2014,
UttarPradesh,India,October12-17,2014 ,RaduMarculescuandGabrielaNicolescu
(Eds.).ACM,9:1Å›9:10. https://doi.org/10.1145/2656075.2656085
[43]Hong Lu, Jiacheng Gui, Chengyi Wang, and Hao Huang. 2020. A Novel Data-
Driven Approach for Generating Verified Loop Invariants. In International Sym-
posium on Theoretical Aspects of Software Engineering, TASE 2020, Hangzhou,
China, December 11-13, 2020 , Toshiaki Aoki and Qin Li (Eds.). IEEE, 9Å›16.
https://doi.org/10.1109/TASE49443.2020.00011
[44]KennethL.McMillan.2014. LazyAnnotationRevisited.In CAV (LNCS,Vol.8559) .
Springer, 243Å›259.
[45]DavidMonniaux. 2010. QuantifierEliminationbyLazy Model Enumeration. In
Computer Aided Verification, 22nd International Conference, CAV 2010, Edinburgh,
UK,July15-19,2010.Proceedings (LectureNotesinComputerScience,Vol.6174) ,
Tayssir Touili, Byron Cook, and Paul B. Jackson (Eds.). Springer, 585Å›599. https:
//doi.org/10.1007/978-3-642-14295-6_51
[46]David Monniaux and Martin Bodin. 2011. Modular Abstractions of Reactive
NodesUsingDisjunctiveInvariants.In APLAS (LNCS,Vol.7078) .Springer,19Å›33.
[47]ThanhVu Nguyen, Timos Antonopoulos, Andrew Ruef, and Michael Hicks. 2017.
Counterexample-guidedapproach tofinding numerical invariants. In ESEC/FSE .
ACM,605Å›615.
[48]ThanhVuNguyen,Deepak Kapur, Westley Weimer, and StephanieForrest.2012.
Using dynamic analysis to discover polynomial and array invariants. In 34th
InternationalConferenceonSoftwareEngineering,ICSE2012,June2-9,2012,Zurich,
Switzerland ,MartinGlinz,GailC.Murphy,andMauroPezzÃ¨(Eds.).IEEECom-
puter Society, 683Å›693. https://doi.org/10.1109/ICSE.2012.6227149
[49]ThanhVuNguyen,Deepak Kapur, Westley Weimer, and StephanieForrest.2014.
DIG:ADynamicInvariantGeneratorforPolynomialandArrayInvariants. ACM
Trans. Softw. Eng. Methodol. 23, 4 (2014), 30:1Å›30:30. https://doi.org/10.1145/
2556782
[50]SaswatPadhi,ToddD.Millstein,AdityaV.Nori,andRahulSharma.2019. Overfit-
tinginSynthesis:TheoryandPractice.In CAV,PartI (LNCS,Vol.11561) .Springer,
315Å›334.
[51]SaswatPadhi,RahulSharma,andToddMillstein.2016. Data-drivenprecondition
inferencewith learned features. ACMSIGPLAN Notices 51,6 (2016), 42Å›56.
[52]SaswatPadhi,RahulSharma,andToddD.Millstein.2016. Data-DrivenPrecondi-
tionInferencewithLearnedFeatures.In PLDI.42Å›56.https://doi.org/10.1145/
2908080.2908099
[53]Sumanth Prabhu, Kumar Madhukar, and R Venkatesh. 2018. Efficiently learning
safetyproofs fromappearanceaswellas behaviours.In SAS (LNCS,Vol. 11002) .
Springer, 326Å›343.
[54]AndrewReynolds, HanielBarbosa,AndresNÃ¶tzli, ClarkW.Barrett,and Cesare
Tinelli. 2019. cvc4sy: Smart and Fast Term Enumeration for Syntax-Guided
Synthesis.In CAV,Part II (LNCS,Vol.11562) . Springer, 74Å›83.
618Multi-Phase Invariant Synthesis ESEC/FSE â€™22, November14Å›18, 2022,Singapore, Singapore
[55]Daniel Riley and Grigory Fedyukovich. 2022. Artifact for Multi-Phase Invariant
Synthesis. (Aug 2022). https://doi.org/10.5281/zenodo.7047061
[56]Philipp RÃ¼mmer, Hossein Hojjat, and Viktor Kuncak. 2013. Disjunctive Inter-
polantsforHorn-ClauseVerification.In ComputerAidedVerification-25thInterna-
tionalConference,CAV2013,SaintPetersburg,Russia,July13-19,2013.Proceedings
(Lecture Notes in Computer Science, Vol. 8044) , Natasha Sharygina and Helmut
Veith(Eds.).Springer, 347Å›363. https://doi.org/10.1007/978-3-642-39799-8_24
[57]SriramSankaranarayanan,FranjoIvancic,IlyaShlyakhter,andAartiGupta.2006.
Static Analysis in Disjunctive Numerical Domains. In SAS (LNCS, Vol. 4134) .
Springer, 3Å›17.
[58]Yuki Satake, Hiroshi Unno, and Hinata Yanagi. 2020. Probabilistic Inference
forPredicateConstraintSatisfaction.In AAAI.AAAIPress,1644Å›1651. https:
//aaai.org/ojs/index.php/AAAI/article/view/5526
[59]Rahul Sharma, Isil Dillig, Thomas Dillig, and Alex Aiken. 2011. Simplifying
LoopInvariantGenerationUsingSplitterPredicates.In CAV (LNCS,Vol.6806) .
Springer, 703Å›719.
[60]Rahul Sharma, Saurabh Gupta, Bharath Hariharan, Alex Aiken, Percy Liang, and
Aditya V. Nori. 2013. A Data Driven Approach for Algebraic Loop Invariants. InESOP (LNCS,Vol.7792) . Springer, 574Å›592.
[61]JakeSilvermanandZacharyKincaid.2019. LoopSummarizationwithRational
Vector Addition Systems. In Computer Aided Verification - 31st International
Conference, CAV 2019, New York City, NY, USA, July 15-18, 2019, Proceedings, Part
II (LectureNotesinComputerScience,Vol.11562) ,IsilDilligandSerdarTasiran
(Eds.).Springer, 97Å›115. https://doi.org/10.1007/978-3-030-25543-5_7
[62]Caterina Urban, Arie Gurfinkel, and Temesghen Kahsai. 2016. Synthesizing
RankingFunctionsfromBitsandPieces.In TACAS (LNCS,Vol.9636) .Springer,
54Å›70.
[63]He Zhu, Stephen Magill, and Suresh Jagannathan. 2018. A data-driven CHC
solver. In PLDI. ACM,707Å›721.
[64]Florian Zuleger, Sumit Gulwani, Moritz Sinn, and Helmut Veith. 2011. Bound
Analysis of Imperative Programs with the Size-Change Abstraction. In Static
Analysis - 18th International Symposium, SAS 2011, Venice, Italy, September 14-16,
2011. Proceedings (Lecture Notes in Computer Science, Vol. 6887) , Eran Yahav (Ed.).
Springer, 280Å›297. https://doi.org/10.1007/978-3-642-23702-7_22
619