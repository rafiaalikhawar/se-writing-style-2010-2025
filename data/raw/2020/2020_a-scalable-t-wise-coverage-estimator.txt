A Scalable t-wise Coverage Estimator
Eduard Baranov
Universite catholique de Louvain
Belgium
eduard.baranov@uclouvain.beSourav Chakraborty
Indian Statistical Institute
India
sourav@isical.ac.inAxel Legay
Universite catholique de Louvain
Belgium
axel.legay@uclouvain.be
Kuldeep S. Meel
National University of Singapore
Singapore
meel@comp.nus.edu.sgVinodchandran N. Variyam
University of Nebraska-Lincoln
USA
vinod@unl.edu
ABSTRACT
Owingtothepervasivenessofsoftwareinourmodernlives,soft-
waresystemshaveevolvedtobehighlyconfigurable.Combinatorial
testinghasemergedasadominantparadigmfortestinghighlycon-
figurable systems. Often constraints are employed to define the
environmentswhereagivensystemundertest(SUT)isexpected
towork.Therefore,therehasbeenasustainedinterestindesigning
constraint-basedtestsuitegenerationtechniques.Asignificantgoaloftestsuitegenerationtechniquesistoachieve
ğ‘¡-wisecoveragefor
higher values of ğ‘¡. Therefore, designing scalable techniques that
can estimate ğ‘¡-wise coverage for a given set of tests and/or the
estimationofmaximumachievable ğ‘¡-wisecoverageunderagiven
set of constraints is of crucial importance. The existing estimation
techniques face significant scalability hurdles.
The primary scientific contribution of this work is the design of
scalablealgorithmswithmathematicalguaranteestoestimate(i)
ğ‘¡-wise coverage for a given set of tests, and (ii) maximum ğ‘¡-wise
coverageforagivensetofconstraints.Inparticular,wedesigna
scalableframework ApproxCov thattakesinatestset U,acoverage
parameter ğ‘¡,atoleranceparameter ğœ€,andaconfidenceparameter ğ›¿,
and returns an estimate of the ğ‘¡-wise coverage of Uthat is guaran-
teedtobewithin (1Â±ğœ€)-factorofthegroundtruthwithprobability
atleast1âˆ’ğ›¿.Wedesignascalableframework ApproxMaxCov that,
foragivenformula F,acoverageparameter ğ‘¡,atoleranceparameter
ğœ€,andaconfidenceparameter ğ›¿,outputsanapproximationwhichis
guaranteedtobewithin (1Â±ğœ€)factorofthemaximumachievable ğ‘¡-
wisecoverageunder F,withprobability â‰¥1âˆ’ğ›¿.Ourcomprehensive
evaluation demonstrates that ApproxCov andApproxMaxCov can
handlebenchmarksthatarebeyondthereachofcurrentstate-of-
the-artapproaches.Webelievethattheavailabilityof ApproxCov
andApproxMaxCov will enable test suite designers to evaluate the
effectivenessoftheirgeneratorsandtherebysignificantlyimpact
the development of combinatorial testing techniques.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510218KEYWORDS
Configurable software, ğ‘¡-wise coverage, Approximation
ACM Reference Format:
EduardBaranov,SouravChakraborty,AxelLegay,KuldeepS.Meel,andVin-
odchandran N. Variyam. 2022. A Scalable t-wise Coverage Estimator. In
44thInternationalConferenceonSoftwareEngineering(ICSEâ€™22),May21â€“
29, 2022, Pittsburgh, PA, USA. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3510003.3510218
1 INTRODUCTION
For the past 50 years, software systems have permeated nearly all
aspectsofourlives,includingcriticaldomainssuchasautonomous
driving,criminalsentencing,surveillance,andhealthcare.Giventhe
diversity of application scenarios, a software system is designed to
behighlyconfigurabletoallowwidespreadadoption[ 50].Economic
factorsalsosupportthedesignofhighlyconfigurablesystems.It
is desirable for a software vendor to develop a general-purposesoftware with a large number of configurations to allow client-
levelcustomizationwithoutnecessarilyrequiringredesignofthe
underlyingsoftwarearchitecture.Atthesametime,giventheusageofsoftwareincriticaldomainssuchashealthcare,softwarefailures
can have serious adverse effects. Therefore, the testing of software
systems is of paramount interest.
Aconfigurationofasystemreferstotheassignmentofvaluesto
alltheconfigurablefeaturesofthesystem.Configurabilitydoesnot
come without a price: feature dependencies are common [ 54] and
could lead to variability bugs appearing only in some configura-
tions.Astraightforwardtestingstrategywouldbetocheckwhether
the system behaves as intended for every possible configuration.
However,suchanapproachisnotpracticalforreal-lifesystems[ 33]
as it is common to have thousands of features in modern software
systemsresulting ina prohibitivelylarge numberofpossible con-
figurations[ 4,5].Thecombinatorialexplosionofthepossibleset
ofconfigurationsisperhapsbestillustratedbytheobservationthat
embeddedLinuxkernelformicro-controllershasover7 .7Ã—10417
configurations [52].
Thecurseofconfigurationexplosionhasbeenwellknownfor
over three decades, and consequently, the area of combinatorial
testinghasemergedasthedominantparadigmfortestingofhighly
configurable systems [ 15,27,34,40,43,47,62,63,68]. The devel-
opment of combinatorial testing techniques, in large part, has been
motivatedbytheobservationthatformostsystems,interactions
amongasmallnumberoffeaturesaresufficienttotriggerthebuggy
behavior. An influential study by NIST observed that up to 6 âˆ’wise,
362022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Eduard Baranov, Sourav Chakraborty, Axel Legay, Kuldeep S. Meel, and Vinodchandran N. Variyam
interactions among parameters are responsible for most of the
bugs[33].Anotherstudyshowedthatdiscoveredvariabilitybugs
in Linux kernel involve up to 5 âˆ’wise feature interactions [ 1]. In
combinatorial testing, we are often interested in maximizing ğ‘¡-wise
coverage1, which measures the fraction of ğ‘¡-sized combinations of
features appearing in the test suite over all possible ğ‘¡-sized combi-
nations of features. A test suite that can achieve ğ‘¡-wise coverage
of1isalsocalleda ğ‘¡-coveringarrayintheliterature,i.e.,for ğ‘›bi-
nary features, a ğ‘¡-covering array Uhas all the/parenleftbigğ‘›
ğ‘¡/parenrightbig2ğ‘¡combinations
appearing in itself.
The complexity of test suite design is exacerbated by the ob-
servationthatnoteveryconfigurationistypicallyallowedbythe
system, and often constraints are employed to describe the valid
set of configurations. In the real world, these constraints represent
scenarios for which the systems are expected to work correctly.
For example, one of the widely used SPLC challenge benchmark
uLinuxconsistsofconstraintstocapturethevariabilitymodelin
KConfig [ 52]. Therefore, given a set of constraints, the possible
ğ‘¡-wisecombinationsoffeaturesaredefinedonlyoverthesatisfying
assignments of these constraints. At this point, it is perhaps worth
emphasizing that even for the case when there are noconstraints,
the size of a ğ‘¡-covering array for ğ‘›features is Î©(2ğ‘¡logğ‘›)[55]. The
presenceofconstraintsbringsadditionalcomplicationstothede-
sign of ğ‘¡-covering array.
Given the practical importance of the combinatorial testing, the
problem of efficient design of the test suite has witnessed a sus-
tained interest for over three decades, evidenced by the diverse set
oftechniquesrangingfromevolutionaryalgorithms[ 6,14,37]to
constraint-basedsystems[ 12,17]proposedovertheyears.Thepro-
posal of these techniques is often accompanied by measurement of
ğ‘¡-wise coverage over benchmarks with small ğ‘›as the computation
ofğ‘¡-coverage for large values of ğ‘›is considered impractical. Given
a test suite Uand a set of constraints Fover the parameters, the
estimationof ğ‘¡-wisecoveragerequiresustoestimatethenumber
ofğ‘¡-combinations of features appearing in the test suite Uand
the number of possible ğ‘¡-combinations over the solutions of F. For
the former computation, the state-of-the-art techniques maintain a
hash map of size O(/parenleftbigğ‘›
ğ‘¡/parenrightbig2ğ‘¡), and the map is updated for every ele-
mentofU.Furthermore,tocomputethepossible ğ‘¡-combinations
overthesolutionsof F,thebest-knownalgorithmscheckwhether F
conjuncted with a ğ‘¡-combination (expressed as a conjunction of lit-
erals)issatisfiable2.Unfortunately,formostpracticalinstances,the
computationofboththequantitiesisbeyondthereachofthestate-
of-the-art techniques. The limitations of the current techniques
forğ‘¡-wise coverage estimations are illustrated in reliance on small
benchmarks or extremely small-sized test suites whenever com-parisonsacrossdifferenttestsuitegenerationmethodologiesare
presented.Inthiscontext,weask: Canwedesignscalablealgorithms
to closely estimate ğ‘¡-wise coverage with rigorous guarantees?
1.1 Our Contribution
Theprimarycontributionofourworkisanaffirmativeanswerto
theabovequestion.Wedesign,tothebestofourknowledge,the
1defined formally in Section 2
2An alternate approach would be to enumerate all the solutions of ğ¹, but for most
formulas of interest, the number of solutions is too large to enumerate.firstscalabletechniquethatprovidesrigorousestimatesof ğ‘¡-wise
coverage. In particular, we present:
(1)A scalable Monte Carlo-based algorithm ApproxCov that
takesinatestsuite U,acoverageparameter ğ‘¡,atolerance
parameter ğœ€, a confidence parameter ğ›¿as input, and returns
an estimate of |Covt(U)|that is mathematically guaranteed
tobewithin (1Â±ğœ€)-factorofthegroundtruthwithprobability
atleast1 âˆ’ğ›¿,whereCovt(U)isthesetofall ğ‘¡-wisecover-
agesofelementsin Uand|Â·|isasetcardinality. ApproxCov
takes only O(2ğ‘¡Â·ğ‘¡logğ‘›)(for a constant ğœ€andğ›¿) space in
contrast to the space requirement of O(/parenleftbigğ‘›
ğ‘¡/parenrightbig2ğ‘¡)for the ex-
isting techniques. Therefore, for small ğ‘¡<6, we achieve a
reduction from ğ‘‚(ğ‘›ğ‘¡)toğ‘‚(ğ‘¡logğ‘›). The running time of the
algorithm is also scalable for instances with parameters that
are currently used in practice.
(2)A scalable counting-based algorithm ApproxMaxCov that
takesinformula F,acoverageparameter ğ‘¡,atolerancepa-
rameter ğœ€,andaconfidenceparameter ğ›¿asinput,andreturns
anestimateof |Covt(Sol(F))|thatisguaranteedtobewithin
(1Â±ğœ€)-factor of the ground truth with probability at least
1âˆ’ğ›¿.ApproxMaxCov reducescomputationof |Covt(Sol(F))|
to theproblem of projected modelcounting. Our reduction
allowsustobuildon therecentadvancesinhashing-based
paradigm for projected model counting [ 9,11,24,59,60],
andweemploystate-of-the-arthashing-basedapproximate
model counter ApproxMC4 [58].
(3)Wedemonstratetheeffectivenessof ApproxCov andApprox-
MaxCovvia implementations in Python3and a comprehen-
sive experimental study. We observe that while the current
stateofthearttechniquesfailtocomputecoverageforbe-
yond ğ‘¡=2,ApproxCov andApproxMaxCov can efficiently
handle ğ‘¡âˆˆ{2,3,4,5,6}(and beyond ğ‘¡=6). Furthermore,
forğ‘¡=2 on feature models with thousands of features,
weobservesignificantruntimeimprovement:inparticular,
ApproxCov achievesfrom2to136factorspeedupoverprior
state of the art BLMCov, whileApproxMaxCov achieves
from6to86factorspeedupoverpriorstateofthearttech-
niqueBLMMaxCov.
(4)Weshowgeneralizationsof ApproxCov andApproxMaxCov
toestimate ğ‘¡-wisecoverageonconfigurablesystemswhere
each feature can take values from a discrete domain. We
demonstrate with experimental evaluation that the general-
izedalgorithmsareeffectiveandcanprovidecloseestimation
ofğ‘¡-wise coverage.
Few words are in order to explain the critical enabler for the
scalabilityof ApproxCov andApproxMaxCov :Fromourviewpoint,
the scalability of ApproxCov owes to the simple but creative usage
oftheMonteCarlo-basedstrategy,whilefor ApproxMaxCov ,the
reductiontoprojectedmodelcountingallowsustoemployandreap
thebenefits oftherecent progressinthe developmentofhashing-
based techniques [9, 11, 58, 59].
Significanceofourcontribution: Combinatorialtestingisadom-
inant testing methodology in large and complex software systems.
Therefore it is vital to have tools that allow us to compare differ-
ent test suite generation techniques. Our algorithms ApproxCov
3https://github.com/meelgroup/approxcov
37
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. A Scalable t-wise Coverage Estimator ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
andApproxMaxCov provide the combinatorial testing community
soundtoolstocomparedifferenttestsuitegenerationtechniques
forlargebenchmarks.Asanimmediateimpact,weexpectourtech-
niques to allow a thorough comparison of the recently proposed
techniquesinCITcommunity[ 3,39]forlargeinstances,whichwas
notfeasiblewiththestateoftheart.Thefactthatouralgorithms
are grounded on guarantees that are mathematically proved makes
them an attractive toolset in downstream applications.
Organization: The rest of the paper is organized as follows. We
present notation and preliminaries in Section 2. We present related
workinSection3.Wethenpresentthetechnicalcontributionofthe
paperinSection4: ApproxCov inSection4.1and ApproxMaxCov
in Section 4.2. In Section 5 we present experimental results over
acomprehensivesetofbenchmarks.Finally,inSection6,wegive
concluding remarks.
2 NOTATIONS AND PRELIMINARIES
2.1 Boolean Formulas
A literal is a Boolean variable or its negation. A clause is a disjunc-
tion of a set of literals. A propositional formula Fin conjunctive
normal form (CNF) is a conjunction of clauses. Vars(F)denotes
the set of variables appearing in F. TheVars(F)is also called the
supportofF.Asatisfying assignment orwitnessofF, denoted by
ğœ, is an assignment of truth values to variables in its support such
thatFevaluatestotrue.Weoftenrepresentanassignmentbythe
setofliteralsthatmakethevariablestrue.Thatis,anassignment
ofTrueto variable ğ‘¥is represented as ğ‘¥and assignment of Falseto
ğ‘¥is represented as Â¬ğ‘¥. We also use the binary bit 1 (0) to represent
True(respectively, False) and binary strings to represent an assign-
ment.Wedenotethesetofallsatisfyingassignmentsof FasSol(F).
Givenasetofvariables ğ‘†âŠ†Vars(F),weuseSol(F)â†“Stodenotethe
projection of Sol(F)onğ‘†.
Example. Consider the formula Fover 4 variables {ğ‘¥1,ğ‘¥2,ğ‘¥3,ğ‘¥4}
given by:
F=(ğ‘¥1âˆ¨ğ‘¥3)âˆ§(Â¬ ğ‘¥1âˆ¨Â¬ğ‘¥3)âˆ§(ğ‘¥1âˆ¨Â¬ğ‘¥2)âˆ§(ğ‘¥3âˆ¨Â¬ğ‘¥4).
Sol(F)={0010,0011,1000,1100}.Intheliteralrepresentationthe
assignment 0010 is represented as {Â¬ğ‘¥1,Â¬ğ‘¥2,ğ‘¥3,Â¬ğ‘¥4}. Let ğ‘†=
{ğ‘¥1,ğ‘¥2}, then|Sol(F)â†“S|={00,10,11}.
Thepropositionalmodelcountingproblem istocompute |Sol(F)â†“S|
foragivenCNFformula Fandprojectionset ğ‘†âŠ†Vars(F).Aproba-
blyapproximatelycorrect (orPAC)counterforBooleanformulasisa
probabilistic algorithm that takes as inputs a formula F, a sampling
setğ‘†âŠ†Vars(F), a tolerance parameter ğœ€âˆˆ(0,1), and a confidence
parameter ğ›¿âˆˆ(0,1], and returns a count ğ‘such that
Pr/bracketleftBig
(1âˆ’ğœ–)|Sol(F)â†“S|â‰¤ğ‘â‰¤(1+ğœ€)|Sol(F)â†“S|/bracketrightBig
â‰¥1âˆ’ğ›¿.
2.2 t-wise Coverage
Theformulationofcombinatorialinteractiontesting(CIT)assignsa
variablecorrespondingtoeveryfeatureofasoftwaresystem.While,
inpracticeeachfeaturecantakeafinitenumberofvalues,inthethe
paper we consider the binary version, where each feature can take
twostates: TrueorFalse.Let ğ‘‹={ğ‘¥1,Â·Â·Â·,ğ‘¥ğ‘›}bethesetofallthe
variables(correspondingto ğ‘›features).Thenaconfiguration ğœofthe system can be represented as an element of the set/producttext.1
ğ‘–{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–}.
For example, for ğ‘‹={ğ‘¥1,ğ‘¥2,ğ‘¥3},ğœ={ğ‘¥1,Â¬ğ‘¥2,ğ‘¥3}is an example
of a configuration.
Givenaconfiguration ğœrepresentedasasetofliterals,wedefine
theğ‘¡-wise coverage of ğœdenoted by Covt(ğœ)={ğ‘‡âŠ†ğœ||ğ‘‡|=ğ‘¡},
the set of all subsets of literals of the size ğ‘¡inğœ.Covt(ğœ)repre-
sents the set of ğ‘¡-sized feature combinations due to ğœ.W ec a n
extend the notion of Covtto a setUâŠ†/producttext.1
ğ‘–{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–}of configura-
tions asCovt(U)=/uniontext.1
ğœâˆˆUCovt(ğœ). For a given ğœ,|Covt(ğœ)|=/parenleftbig|ğ‘‹|
ğ‘¡/parenrightbig=/parenleftbigğ‘›
ğ‘¡/parenrightbig. However, this does not imply |Covt(U)|=|ğ‘ˆ|Ã—/parenleftbig|ğ‘‹|
ğ‘¡/parenrightbig
since|Covt(ğœ1)âˆªCovt(ğœ2)|isnotnecessarilyequalto |Covt(ğœ1)|+
|Covt(ğœ2)|duetonon-emptyintersectionof Covt(ğœ1)andCovt(ğœ2).
Alsonotethat,for/producttext.1
ğ‘–{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–},thesetofallpossibleconfigurations
|Covt(/producttext.1
ğ‘–{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–})|=2ğ‘¡/parenleftbig|ğ‘‹|
ğ‘¡/parenrightbig. We will call Covt(/producttext.1
ğ‘–{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–})the
universeand denote it by Î©. The above discussion leads to the fol-
lowing observation which is crucial for the proof of correctness of
our algorithm.
Observation 2.1. For anyUâ‰ âˆ…over a set of variables ğ‘‹and
any1â‰¤ğ‘¡â‰¤|ğ‘‹|,
/parenleftbigg|ğ‘‹|
ğ‘¡/parenrightbigg
â‰¤|Covt(U)| â‰¤2ğ‘¡/parenleftbigg|ğ‘‹|
ğ‘¡/parenrightbigg
.
Wewillbeinterestedinthecoverageofasetofconfigurations
thatsatisfycertainconstraintsoverthefeatures.Wewillfocuson
constraints represented by a Boolean formula F. For a set UâŠ†
Sol(F),the ğ‘¡-wisefractionalcoverageofaset Uwithrespecttoa
formulaF, denoted by FracCov t(U,F)is defined as follows:
FracCov t(U,F)=|Covt(U)|
|Covt(Sol(F))|
Example. To illustrate the notions, let us consider again the CNF
formulaF
F=(ğ‘¥1âˆ¨ğ‘¥3)âˆ§(Â¬ ğ‘¥1âˆ¨Â¬ğ‘¥3)âˆ§(ğ‘¥1âˆ¨Â¬ğ‘¥2)âˆ§(ğ‘¥3âˆ¨Â¬ğ‘¥4).
Thefollowingtablelists Covt(Sol(F))forğ‘¡=2.Forcompactness,
we use the bit representation of the assignments and coverage. For
example, a set of literals {Â¬ğ‘¥1,Â¬ğ‘¥2}is listed as 00 in the column
indexed(1,2).|Covt(Sol(F))|=17. For ğ‘ˆ={0010,0011}(shaded
in the table), |Covt(U)|=9.FracCov t(U,F)=9/17.
2-tuples
Sol(F)(1,2)(1,3)(1,4)(2,3)(2,4)(3,4)
0010 000100010010
0011 000101010111
1000 10 10 10 00 00 00
1100 11 10 10 10 10 00
Total 323333
ForU112122
Table 1: Coverage for example formula F
38
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Eduard Baranov, Sourav Chakraborty, Axel Legay, Kuldeep S. Meel, and Vinodchandran N. Variyam
3 RELATED WORK
3.1 Combinatorial Testing
Sincetheintroductionofcombinatorialtestinginthe1980sasan
effectiveoptionforconfigurablesystems[ 40,62],steadyprogress
hasbeen reportedonthis topic.Werefer thereaderto [34,47,63]
foradetailedoverviewofthe topic.Intheclassicalcombinatorial
testing,thegoalistodesignatestsuite Usuchthat |Covt(U)|=/parenleftbigğ‘›
ğ‘¡/parenrightbig2ğ‘¡.Suchatestsuitisalsoknownasacoveringarrayformally
defined in [ 57]. Covering arrays are orthogonal arrays or matri-
ces with rows representing configurations of a system and ev-
ery possible t-sized combination of variables appears at least inone column. Over the decades, the construction of covering ar-
rays has witnessed a wide variety of approaches including greedy
search [2,13,28,36,37,41,61,65,67], divide-and-compose [ 51],
genetic algorithms [42], and tabu search [25, 48].
Modern software systems have a large number of features, and
the design of covering array is often impractical for ğ‘¡>2. Fur-
thermore,themodernsoftwareshaveassociatedvariabilitymod-
els, and not every configuration is valid, and therefore, cannotact as a test. In this context, constraints are employed to capturethe associated variability models or the scenarios under which asoftware is expected to behave as per specifications. Combinato-
rialtestinginsuchaconstraintsettingiscalledconstrainedcom-
binatorial testing [ 7]. The presence of constraints has led to the
development of techniques that rely on the progress in combinato-
rialsolversoverthepastthreedecades.Severalapproacheshave
been proposed that seek to sample solutions subject to constraints.
These approaches resulted in BDD-based techniques [ 35], random
seeding of DPLL-based SAT solvers [ 46], Markov Chain Monte
Carlo-basedmethods[ 29â€“31,66],intervalpropagationandbelief
networks-based methods [ 16,22], MaxSAT-based techniques such
asQuicksampler[ 19],hashing-basedapproaches[ 8,10,58],knowl-
edgecompilation-based approachessuchas KUS[ 56],WAPS[ 26],
and Baital [3].
3.2 Model Counting
Valiant initiated the complexity theoretic study of model counting
andshowedthattheproblemofmodelcountingforCNFformulais
#P-complete [ 64]. The problem of projected model counting which
we employ in this paper is shown to be # Â·NP-complete [ 18]. Given
the computational intractability of (projected) model counting, we
are often interested in (ğœ€,ğ›¿)-approximations of the exact count,
where the goal is to obtain an (1Â±ğœ–)multiplicative approximation
of the exact count with probability at least (1âˆ’ğ›¿). Hashing-based
techniques have emerged as a dominant paradigm seeking scalabil-
ity while providing (ğœ€,ğ›¿)-approximation guarantees. The core idea
of hashing-based techniques is to employ pairwise independenthash functions to partition the solution space into roughly equal
smallcellsofsolutions.Then,werandomlychooseoneofthesmall
cells, enumerate all the solutions using a SAT solver one by one.
Thenumberofsolutionsisestimatedtobesimplythenumberof
solutions in the cell multiplied by the total number of cells. Thepairwise independent hash functions can be realized using XOR-based hash functions. The hashing-based techniques trace theirorigintoStockmeyerâ€™sseminalwork[
60],subsequentlypursued
by Gomes, Sabharwal, and Selman [23].Chakraborty, Meel, and Vardi proposed the first scalable approx-
imate model counter, ApproxMC, which invoked the underlying
SAT solver, CryptoMiniSat ,O(ğ‘›)times (where ğ‘›is the number of
variables in the original formula). Subsequently, Chakraborty et
al[11]reducedthenumberofSATcallsfrom O(ğ‘›)toO(logğ‘›);the
corresponding counter was called ApproxMC2. Soos and Meel [ 59]
soughttoimprovetheunderlyingSATsolverâ€™sarchitecture;their
new architecture, called BIRD, achieved significant performance
improvement. ApproxMC is currently in its fourth generation, Ap-
proxMC5 [45, 58]4.
3.3 ğ‘¡-wise Coverage Estimation
While combinatorial testing has witnessed over four decades of
sustainedinterestsfromtheoreticiansandpractitioners,thetech-
niquestoestimate |CovU|and|CovSol(F)|haveratherbeenlargely
underexplored. Given a set U, the state of the art technique main-
tains a map of the ğ‘¡-wise combinations seen in U. In the case of a
givenformula F,observethatevery ğ‘¡-combinationcanbeexpressed
as a conjunction of ğ‘¡literals, say ğœ‹. Given such a ğœ‹, the state of the
art techniques simply invoke a SAT solver to check whether Fâˆ§ğœ‹
issatisfiable.Inourwork,weusetheimplementationofthesetech-
niques due to Baranov, Legay, and Meel [ 3], which was used in the
evaluationofthecurrentstateofthearttestgeneratorsuite,Baital5.
We useBLMCov andBLMMaxCov to denote the implementations
for computations of Covt(U)andCovt(Sol(F))respectively. To
the best of our knowledge, BLMCov andBLMMaxCov represent
thecurrentstateoftheart;anassertionconfirmedbytheauthors
of both the recently published studies in SE community [3, 39].
4 ALGORITHMS
In this section we present two algorithms. The first algorithm
ApproxCov (presented in Section 4.1) estimates |Covt(U)|. More
precisely ApproxCov takes as input a set UâŠ‚/producttext.1
ğ‘–{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–}, error
parameter 0 <ğœ–<1, and a confidence parameter 0 <ğ›¿<1, and
outputs a number that, with probability at least (1âˆ’ğ›¿),i sbe t w ee n
(1âˆ’ğœ–)|Covt(U)|and(1+ğœ–)|Covt(U)|.
InSection4.2wepresentanotheralgorithm ApproxMaxCov that
givenaBooleanformula F,estimates |Covt(Sol(F))|.Moreprecisely,
ApproxMaxCov takes as input F, an error parameter 0 <ğœ–<1 and
a confidence parameter 0 <ğ›¿<1 and outputs a number that, with
probability at least (1âˆ’ğ›¿), is between (1âˆ’ğœ–)|Covt(Sol(F))|and
(1+ğœ–)|Covt(Sol(F))|.
UsingApproxCov andApproxMaxCov wecanestimatethevalue
ofFracCov t(U,F).GivenaBooleanformula FandasetUâŠ‚Sol(F),
sayweuse ApproxCov (U,ğœ–1,ğ›¿1)andApproxMaxCov (F,ğœ–2,ğ›¿2)to
obtainestimatesfor |Covt(U)|and|Covt(Sol(F))|respectively.Let
Out1betheoutputof ApproxCov (U,ğœ–1,ğ›¿1)andOut2betheoutput
ofApproxMaxCov (F,ğœ–2,ğ›¿2). So we have with probability at least
(1âˆ’ğ›¿1)the following Equation 1 and with probability (1âˆ’ğ›¿2)the
Equation 2 holds.
(1âˆ’ğœ–1)|Covt(U)| â‰¤Out1â‰¤(1+ğœ–1)|Covt(U)|,(1)
(1âˆ’ğœ–2)|Covt(Sol(F))| â‰¤Out2â‰¤(1+ğœ–2)|Covt(Sol(F))|.(2)
4WhilebetaversionofApproxMC5isreleased;ApproxMC4â€™sdeveloperrecommend
usage of ApproxMC4
5We use the implementation available at https://github.com/meelgroup/baital
39
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. A Scalable t-wise Coverage Estimator ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
So, by union bound, with probability at least (1âˆ’ğ›¿1âˆ’ğ›¿2)both
the above equations work.Thus with probability (1âˆ’ğ›¿1âˆ’ğ›¿2)we
have
(1âˆ’ğœ–1)
(1+ğœ–2)|Covt(U)|
|Covt(Sol(F))|â‰¤Out1
Out2â‰¤(1+ğœ–1)
(1âˆ’ğœ–2)|Covt(U)|
|Covt(Sol(F))|.(3)
Thus given a Boolean formula F, a setUâŠ‚Sol(F),a ne r r o r
parameter ğœ–andaconfidenceparameter ğ›¿,ifw eset ğœ–1,ğœ–2,ğ›¿1and
ğ›¿2appropriately we will be able to give an (1Â±ğœ–)-multiplicative
estimateof FracCov t(U,F)withprobability (1âˆ’ğ›¿).Forexample,
let us set ğœ–1=ğœ–2=ğœ–
2+ğœ–andğ›¿1=ğ›¿2=ğ›¿/2. Note that in that case
(1+ğœ–1)/(1âˆ’ğœ–2)isatmost (1+ğœ–)and(1âˆ’ğœ–1)/(1+ğœ–2)isatleast (1âˆ’ğœ–).
Thenbyusing ApproxCov (U,ğœ–1,ğ›¿1)andApproxMaxCov (F,ğœ–2,ğ›¿2)
to estimate |Covt(U)|and|Covt(Sol(F))|respectively, from Equa-
tion 3, we have with probability at least (1âˆ’ğ›¿)
(1âˆ’ğœ–)FracCov t(U,F)â‰¤Out1
Out2â‰¤(1+ğœ–)FracCov t(U,F).
4.1 Counting the Coverage of a Test Suit
The intuition behind the ApproxCov is similar to the Monte-Carlo
method.Givenasetofvariables ğ‘‹={ğ‘¥1,...,ğ‘¥ğ‘›},consideratestset
UâŠ†/producttext.1
ğ‘–{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–}and the universe set Î©:=Covt(/producttext.1
ğ‘–{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–})with
allpossible ğ‘¡-wisecoveragetuples(thesetwithallcombinationsof
sizeğ‘¡thatcanbeobtainedwithvariablesfrom ğ‘‹).Thealgorithm
picks a set Sof size â„“of random ğ‘¡-wise coverage tuples from Î©
(â„“is appropriately chosen based on the input parameters). Then it
counts the number of elements from Sthat is realizable by at least
oneofthetestsin U(membershipin Covt(U)).Letthisnumber
beğ‘š. Then the output of the algorithm isğ‘š
â„“Â·|Î©|.
In detail, ApproxCov shown in Algorithm 1 starts by setting
the size of sample set that it would be picking depending on the
parameters ğœ€andğ›¿.I nt h eForloop between line 3 and line 7 we
pickâ„“samples uniformly at random from Î©. The sampling is done
intwosteps.Foreachsample,atfirstweselectuniformly ğ‘¡variables
tobeusedinasampleatline4.Atthesecondstepweselectavalueforeachvariableatrandomatline5.Notethatthisproceduregives
a random element of Î©as the universe set can also be written as
Î©=/braceleftBigg
ğ‘¤âˆˆ/productdisplay.1
ğ‘–âˆˆğ‘‡{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–}/barex/barexğ‘‡âŠ†/parenleftbigg[ğ‘›]
ğ‘¡/parenrightbigg/bracerightBigg
,
where/parenleftbig[ğ‘›]
ğ‘¡/parenrightbigis the set of all subsets of the set {1,...,ğ‘›}of size ğ‘¡.
Samples are stored in a map M, where the values indicate
whetherthesampleisrealizablebyatleastonetestin U,initialized
to0.Notethattheremaybesomeelementsthatarepickedmultiple
times.Inthatcasewewillkeepallthecopiesinthemap M,inother
words,Mis actually a multi-map. In the nested forloops between
line 8 and line 14 we update values of the map Mif a sampled
element is a subset of any of the ğœâˆˆU. Finally, in line 15 we sum
thevariablescorrespondingtotheelementsin Mandoutputthe
value multiplied with an appropriate scaling number.
Theorem4.1. Letğ‘‹={ğ‘¥1,...,ğ‘¥ğ‘›}bethesetof ğ‘›variablesand
letUbeanysubsetof/producttext.1
ğ‘–{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–}.Thenforanypositiveinteger ğ‘¡and
positiverealnumbers 0<ğœ–,ğ›¿<1,withprobabilityatleast (1âˆ’ğ›¿)
the output of ApproxCov is an(1Â±ğœ–)-multiplicative approximationAlgorithm 1 ApproxCov (U,ğœ–,ğ›¿)
1:â„“â†/ceilingleftBig
32ğ‘¡
ğœ–2ln(2/ğ›¿)/ceilingrightBig
2:Initialise M=âˆ…
3:forğ‘˜=1;ğ‘˜â‰¤â„“;ğ‘˜++do
4:Pick a random ğ‘‡ğ‘˜from/parenleftbig[ğ‘›]
ğ‘¡/parenrightbig
5:Pick a random ğ‘¤ğ‘˜from/producttext.1
ğ‘–âˆˆğ‘‡ğ‘˜{ğ‘¥ğ‘–,Â¬ğ‘¥ğ‘–}
6:Putğ‘¤ğ‘˜â†’0 intoM
7:end for
8:forğœâˆˆUdo
9:forğ‘˜=1;ğ‘˜â‰¤â„“;ğ‘˜++do
10: ifğ‘¤ğ‘˜âŠ†ğœthen
11: UpdateM[ğ‘¤ğ‘˜]to 1
12: end if
13:end for
14:end for
15:Output(ğ‘›
ğ‘¡)2ğ‘¡
â„“/summationtext.1â„“
ğ‘˜=1M[ğ‘¤ğ‘˜]
of the|Covt(U)|. That is, with probability at least (1âˆ’ğ›¿),
(1âˆ’ğœ–)|Covt(U)| â‰¤/parenleftbigğ‘›
ğ‘¡/parenrightbig2ğ‘¡
â„“â„“/summationdisplay.1
ğ‘˜=1M[ğ‘¤ğ‘˜]â‰¤(1+ğœ–)|Covt(U)| .
Moreover, the amount of space needed is ğ‘‚/parenleftBig/ceilingleftBig
32ğ‘¡
ğœ–2ln(2/ğ›¿)/ceilingrightBig
ğ‘¡âŒˆlog2ğ‘›âŒ‰/parenrightBig
and the run time is ğ‘‚/parenleftBig/ceilingleftBig
32ğ‘¡
ğœ–2ln(2/ğ›¿)/ceilingrightBig
ğ‘¡âŒˆlog2ğ‘›âŒ‰|U|/parenrightBig
.
4.2 Counting the Coverage with Constraints
In this section we present the algorithm ApproxMaxCov for esti-
mating|Covt(Sol(F))|. Notice that it is not straightforward to use
ApproxCov toestimatethisquantityas Sol(F)isnotgivenexplic-
itly. Hence we design a new algorithm ApproxMaxCov that uses
aprojectedmodelcountingalgorithmonarelatedformula.Itisa
two-stepalgorithmshowninAlgorithm2.ForaBooleanformula
Fon variable set ğ‘‹, it will first construct a new Boolean formula
GFonvariableset ğ‘‹âˆªğ‘†,where ğ‘†isanadditionalsetofvariables,
such that
|Covt(Sol(F))|=|Sol(GF
â†“{S})| (4)
Then it will use an approximate projected model counting al-
gorithm (which we call ApproxCount )o nGFto output an (ğœ–,ğ›¿)
estimate of |Covt(Sol(F))|. Several algorithms are known for the
approximatemodelcountingproblemandwediscusstheonewe
useinSection5.Sincetheoutputof ApproxCount isguaranteedto
bewithin (1Â±ğœ€)of|Sol(GF
â†“{S})|withprobabilityatleast (1âˆ’ğ›¿),
theoutputof ApproxMaxCov isalsobetween (1âˆ’ğœ–)|Covt(Sol(F))|
and(1+ğœ–)|Covt(Sol(F))|, with probability at least (1âˆ’ğ›¿).
Algorithm 2 ApproxMaxCov (ğ¹,ğ‘¡,ğœ€,ğ›¿)
1:(GF,ğ‘†)â†ConstructGFormula (ğ¹)
2:ğ‘â†ApproxCount (GF,ğ‘†,ğœ€,ğ›¿)
3:return ğ‘
Thus the correctness of the algorithm ApproxMaxCov follows
onceweshowthattheformula GF(ğ‘‹,ğ‘†)satisfiestheconditionin
Equation 4.
40
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Eduard Baranov, Sourav Chakraborty, Axel Legay, Kuldeep S. Meel, and Vinodchandran N. Variyam
Lemma 4.2.
|Covt(Sol(F))|=|Sol(GF
â†“{S})|
We now present the main idea of the construction of GF.
Construction of GF:Intuitively, GFencodesFandallthe ğ‘¡-wise
coverage tuples contained in Sol(F). Given natural numbers ğ‘›and
ğ‘¡,andaBooleanformula Fonğ‘›variables ğ‘‹={ğ‘¥0,...,ğ‘¥ğ‘›âˆ’1}6we
willdefineanewBooleanformula GFonğ‘›+ğ‘¡âŒˆlog2ğ‘›âŒ‰+ğ‘¡variables.
First ğ‘›variables are the variables of ğ¹. The remaining set of
variables ğ‘†can be partitioned into ğ‘¡+1 groups: ğ‘Œ1,...,ğ‘Œğ‘¡of size
âŒˆlog2ğ‘›âŒ‰andğ‘={ğ‘§1,...,ğ‘§ğ‘¡}. Intuitively, ğ‘†encodes a subset of
indices{1,Â·Â·Â·,ğ‘›}of size ğ‘¡:ğ‘Œğ‘–is a bit-vector that encodes the ğ‘–ğ‘¡â„
integer in the subset and ğ‘§ğ‘–is its value in ğ‘‹. To ensure that only
elementsof Covt(Sol(F))canbeassignedtotheset ğ‘†,weextendthe
formulaFwithadditionalconstraintsthatisencodedinaformula ğ¹/prime
andtheformula GFisconstructedasaconjunctionof ğ¹andğ¹/prime.For
a binary string ğ‘¦ğ‘–of length âŒˆlog2ğ‘›âŒ‰, letval(ğ‘¦ğ‘–)denote the number
encodedbyabinaryassignmenttothevariablesin ğ‘Œ.ğ¹/primeisaformula
over variable ğ‘Œâˆªğ‘that encodes the following requirements.
(1) 0â‰¤val(ğ‘¦ğ‘–)<ğ‘›for all 1â‰¤ğ‘–â‰¤ğ‘¡.
(2)val(ğ‘¦ğ‘–)<val(ğ‘¦ğ‘–+1)for all 1 â‰¤ğ‘–â‰¤ğ‘¡âˆ’1. This constraint
togetherwith(1)ensuresthatthetuple /angbracketleftğ‘¦1,Â·Â·Â·,ğ‘¦ğ‘¡/angbracketrightencodes
asubsetofindicesofsize ğ‘¡(sameindexcannotappearina
combination multiple times and each set can have only one
representation).
(3)ğ‘¥val(ğ‘¦ğ‘–)=ğ‘§ğ‘–forall1â‰¤ğ‘–â‰¤ğ‘¡.Thisconstraintensuresthatthe
binaryassignmentvariables ğ‘Œâˆªğ‘encodesa ğ‘¡-wisecoverage
tuple contained in the assignment to F.
With this intuition it is easy to see that the number of differ-
ent valid assignments to the set ğ‘†=ğ‘Œâˆªğ‘is the desired value
|Covt(Sol(F))|.
5 EXPERIMENTS
Inthissectionweevaluatetheprecisionandefficiencyofalgorithms
ApproxCov andApproxMaxCov .Bothalgorithmshavebeenimple-
mentedinPython 3. ApproxMaxCov implementationusesa state-
of-the-arttoolApproxMC4[ 11,58,59]forApproxCount subroutine
(forapproximateprojectedmodelcounting).Intheevaluationofthe
algorithms, we wantto validate that the implementationachieves
the theoretical results on the estimation accuracy and to compare
the performance of the algorithms with the existing approaches.
Therefore, we pose the following research questions:
â€¢RQ1andRQ2: Are approximations of ApproxCov and
ApproxMaxCov close to the correct values and within the
boundary provided by PAC guarantees?
â€¢RQ3andRQ4:A r eApproxCov andApproxMaxCov faster
and more scalable than the existing approaches?
As discussed in Section 4, an estimate of FracCov t(U,F)for
a given sample set Uand a formula Fcan be computed with
ApproxCov andApproxMaxCov .Suchanestimateinformsusofthe
ğ‘¡-coverage achieved by a given test suite with respect to the maxi-
mum possible ğ‘¡-wise coverage subject to the set of constraints F.
Evaluation of FracCov t(U,F)is covered by the following research
question:
6Choosing {ğ‘¥0,...,ğ‘¥ ğ‘›âˆ’1}instead of {ğ‘¥1,...,ğ‘¥ ğ‘›}is for easiness of presentation.â€¢RQ5Can algorithms ApproxCov andApproxMaxCov be
usedtoestimate FracCov t(U,F)andprovideacloseapprox-
imation to the correct result?
Asnotedearlier,itiswell known[ 3,39]thattypicallytechniques
used for binary domains can be scalably lifted to discrete domains.
We describe the extensions of ApproxCov andApproxMaxCov for
the general case along with empirical studies in the end of the
section.
5.1 Benchmarks & Experimental Setup
Fortheexperimentsweselectedalargenumberofpubliclyavail-
ablefeaturemodelsfromreal-worldconfigurablesystemsthatwere
usedintheliteraturefortheevaluationofsamplingtools.Inpar-
ticular, we took 123 benchmarks appeared in [ 3,32,38,52,53].
Thebenchmarkshavebetween565and11254variables,between
1164 and 62183 clauses, and between 9 .7Ã—1013and 7 .7Ã—10417
solutions. Unfortunately, existing approaches are not capable to
compute |Covt(U)|and|Covt(Sol(F))|forğ‘¡â‰¥3 on large bench-
marks. Therefore, in order to check approximations for ğ‘¡â‰¥3w e
have selected smaller benchmarks from [ 44]. In particular we have
sortedthebenchmarksbythenumberofvariablesandrandomly
selected1foreachvaluebetween10and500providing111extra
benchmarks.Intheremainderofthesectionwewouldreference
the first 123 benchmarks as â€˜largeâ€™ and the last 111 as â€˜smallâ€™.
Theevaluationof ApproxCov requiressamplesets,thereforewe
generated them with 3 publicly available tools â€”WAPS [ 26], Quick-
sampler[ 20],andBaital[ 3]â€”foreachofthe234benchmarks.Each
samplesetcontains1000samples.SinceQuicksamplercangenerate
unsatisfiable samples that are filtered afterwards, we generated
moresampleswiththistoolandselectedthefirst1000validones.
Notethatforseveralbenchmarks,evenafterrequesting100000sam-
ples,Quicksampler outputcontained lessthan1000 validsamples,
therefore we did not consider such sample sets in the experiments.
Thus, we used 674 sample sets for the experiment. Similarly to the
featuremodels,wewouldcallsamplesetsoriginatingfromthefirst
123 feature models as â€˜largeâ€™ and the remaining would be â€˜smallâ€™.
All experiments were conducted on a high performance com-
putercluster,eachnodeconsistingof2xE5-2690v3CPUswith2x12
real cores and 96GB of RAM.
5.2 Methodology
Theevaluationof ApproxCov isfocusedon RQ1andRQ3.Inour
experiment we used ApproxCov to approximate |Covt(U)|for
ğ‘¡âˆˆ[2,6]on 674 sample sets described above. We used ğœ€andğ›¿
equal to 0 .05.ApproxCov computations have been performed 10
timeswithoutfixedrandomseedandintheresultswereportthe
meanrunningtimeandtheworst-caseoutput;i.e.theoutputfar-
thest from the |Covt(U)|. For comparison, we have performed the
same computationswith BLMCov [3]. Thetimeout was setto 3600
seconds and the memory limit was set to 4Gb for both the tools.
The evaluation of ApproxMaxCov is focused on RQ2andRQ4.
In our experiments we approximated |Covt(Sol(F))|on 234 bench-
marks for ğ‘¡âˆˆ[2,6]. We used ğ›¿=ğœ€=0.05. Similarly to the previ-
ousexperiment,allcomputationswith ApproxMaxCov havebeen
performed 10 times without fixed random seed. For comparison,
we have performed the same computations with BLMMaxCov [3].
41
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. A Scalable t-wise Coverage Estimator ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Figure 1: Comparison of execution time of ApproxCov andBLMCov
on 674 sample sets for ğ‘¡=2. X axis shows BLMCov time in seconds,
Y axis shows ApproxCov time in seconds. Red line indicates equal
time. Among 3 points at the right border, 2 correspond to timeout
ofBLMCov and 1 corresponds to 3295 seconds for BLMCov.
Originally,thetimeoutwassetto3600secondsforbothtools.Unfor-
tunately,BLMMaxCov isabletocomputeonly2â€˜largeâ€™benchmarks
within thistimeout for ğ‘¡=2. Therefore, weraised the timeout for
BLMMaxCov to 28800 seconds. The memory limit was set to 4Gb.
Fortheevaluationof RQ5weusedtheresultsfromthetwoprevi-
ousexperiments:theestimationof FracCov t(U,F)isobtainedbydi-
vidingthe ğ‘–ğ‘¡â„resultofApproxCov bythe ğ‘–ğ‘¡â„resultofApproxMaxCov
on the corresponding feature model. The 10 generated approxima-
tions havebeen compared withthe correct valuescomputed with
BLMCov andBLMMaxCov .Confidenceparametersof FracCov t(U,F)
are derived from the selection of ğœ€andğ›¿in the computation of
Approx-CovandApproxMaxCov: ğ›¿=0.0975, ğœ€=0.105.
5.3 Results for ApproxCov
In the first experiment we computed |Covt(U)|withApproxCov
andBLMCov.For ğ‘¡=2,ApproxCov havesuccessfullyterminated
onallsamplesetswithin25seconds. BLMCov hastimedouton2
benchmarks.Comparingthecomputationtimefor ğ‘¡=2between
BLMCov andApproxCov ,BLMCov was faster on sample sets with
fewvariables.Amonglargesamplesetswithmorethan500vari-
ables, only 3 were faster with BLMCov, while on the rest of the
setsApproxCov wasfrom2to136timesfaster.Timecomparisonis
shown Figure 1; among 3 points on the right border, 2 correspond
to timeouts of BLMCov and the remaining corresponds to 3295
seconds for BLMCov. Slower performance on smaller benchmarks
is explained by the fact that the number of picked elements de-
pendsontheselected ğœ€andğ›¿parametersratherthanthenumber
of variables.Note thaton thesmallest benchmarksthe number of
combinationstopickisgreaterthanthetotalnumberofdifferent
combinations.Insuchcases allcombinationsareselectedandthe
result is an exact value rather than approximation.
Figure2:Approximationerrorof ApproxCov forğ‘¡=2on672sample
setscomputedas ğ‘šğ‘ğ‘¥(ğ‘ğ‘ğ‘ (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–âˆ’|Cov2(U)|)/|Cov2(U)|),where
ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–is approximation returned by ApproxCov on theğ‘–ğ‘¡â„run. 2
samplesetsthattimedoutwith BLMCov arenotusedinthisfigure.
Figure3: ApproxCov executiontimeon674samplesetsfor ğ‘¡âˆˆ[2,6].
X axis shows the value of ğ‘¡, Y axis shows time in seconds.
To check the accuracy of ApproxCov approximation, we com-
paredtheapproximationresultswiththecorrectvalueof |Cov2(U)|
computedby BLMCov.Foreachsamplesetwetookthemaximal
valueof ğ‘ğ‘ğ‘ (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡âˆ’|Cov2(U)|)/|Cov 2(U)|among10 ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ğ‘ of
ApproxCov . Figure 2 shows the histogram of errors, the largest
error was 0.0315 which is smaller than selected ğœ€.
Forğ‘¡â‰¥3,BLMCov has successfully terminated only on few
â€™smallâ€™ benchmarks within the given time and memory budget: 292
benchmarks for ğ‘¡=3, 76 for ğ‘¡=4, 36 for ğ‘¡=5, and 22 for ğ‘¡=6. In
comparison, ApproxCov terminated on all benchmarks within 650
secondsforall ğ‘¡â‰¤6.Theexecutiontimeforvariousvaluesof ğ‘¡is
showninFigure3.TheapproximationaccuracywaswithinPAC
guarantees:thelargesterrorwas0.0369.Thehistogramoferrors
on benchmarks computed by BLMCov is shown in Figure 4.
Our experiment shows that the results of the ApproxCov are
close to the |Cov2(U)|and within the selected boundary from
PAC guarantees, thus answering RQ1. Comparison of execution
timeallows ustogive apositiveanswer to RQ3:ApproxCov iscan
compute |Covt(U)|forğ‘¡=6, while existing method fails on half
of the sample sets for ğ‘¡=3.
42
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Eduard Baranov, Sourav Chakraborty, Axel Legay, Kuldeep S. Meel, and Vinodchandran N. Variyam
Figure 4: Approximation error of ApproxCov forğ‘¡âˆˆ[3,6]on all
benchmarks on which BLMCov has successfully terminated - 426
elements in total. The error is computed as ğ‘šğ‘ğ‘¥(ğ‘ğ‘ğ‘ (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–âˆ’
|Covt(U)|)/|Covt(U)|),whereğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–isapproximationreturnedby
ApproxCov on theğ‘–ğ‘¡â„run.
Figure 5: Approximation error of ApproxMaxCov forğ‘¡=2on 221
benchmarks on which BLMMaxCov terminated. The error is com-
puted as ğ‘šğ‘ğ‘¥(ğ‘ğ‘ğ‘ (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–âˆ’|Cov2(Sol(F))|)/|Cov2(Sol(F))|), where
ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–the approximation returned by ApproxMaxCov onğ‘–ğ‘¡â„run.
5.4 Results for ApproxMaxCov
ApproxMaxCov have successfully terminated on all benchmarks
forğ‘¡=2 within 360 seconds except 1 benchmark that required
1720seconds.Forcomparison, BLMMaxCov hassuccessfullyter-
minated only on 2 â€˜largeâ€™ benchmarks for ğ‘¡=2 with 3600 seconds
timeout.Afterraisingtimeoutto28800secondsitsucceededon221
benchmarks out of 234. The speedup factor ofApproxMaxCov on
large benchmarks have range between 6 and 86.
To check the accuracy of ApproxMaxCov approximation, we
compared it with Cov2(Sol(F)). For each benchmark, we took
the maximal value of ğ‘ğ‘ğ‘ (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡âˆ’|Cov2(Sol(F))|)/|Cov 2(Sol(F)|
among 10 ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ğ‘ ofApproxMaxCov . Results for 8 benchmarks are
showninTable2.Figure5showsthehistogramoferrors,thelargest
error was 0.0058 which is smaller than selected ğœ€.
For larger values of ğ‘¡,ApproxMaxCov timed out of 3600 sec-
ondsonthelargestbenchmarkfor ğ‘¡â‰¥4andononemorebench-
mark for ğ‘¡=6. Further exploration of these 2 benchmarks showed
thatApproxMaxCov cangenerateallresultswithin8500seconds.
The execution time for various values of ğ‘¡is shown in Figure 6.Benchmark Ground Truth ApproxMaxCov Error
buildroot 621270 622592 0.0021
busybox_1_28_0 1965023 1967616 0.0013ecos-icse11 2910229 2913280 0.0010financial 917150 919040 0.0021
mpc50 2719748 2713600 0.0023
phycore 3008140 3015680 0.0025psim 2591638 2597888 0.0024
sleb 2624832 2630656 0.0022
Table 2: Comparison of ApproxMaxCov approximations with
|Cov2(Sol(F))|. First column shows the benchmark, second and
thirdcolumnsshows |Cov2(Sol(F))|andworst ApproxMaxCov result
from 10 runs, and the last column is computed as (ğ‘ğ‘ğ‘ (ğ‘ğ‘œğ‘™ğ‘¢ğ‘šğ‘›3âˆ’
|Cov2(Sol(F))|)/|Cov2(Sol(F))|).
Figure 6: ApproxMaxCov execution time on 234 benchmarks for ğ‘¡âˆˆ
[2,6]. X axis shows the value of ğ‘¡, Y axis shows time in seconds.
Points on the top border correspond to timeouts.
Figure 7: Approximation error of ApproxMaxCov forğ‘¡âˆˆ[3,6]on
all benchmarks on which BLMMaxCov has successfully terminated
- 114 elements in total. The error is computed as ğ‘šğ‘ğ‘¥(ğ‘ğ‘ğ‘ (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–âˆ’
|Covt(Sol(F))|)/|Covt(Sol(F))|),where ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–theapproximationre-
turned by ApproxMaxCov onğ‘–ğ‘¡â„run.
43
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. A Scalable t-wise Coverage Estimator ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Figure8:Approximationerrorof FracCov t(U,F)forğ‘¡âˆˆ[3,6]onall
benchmarks on which both BLMCov andBLMMaxCov have success-
fully terminated - 952 elements in total. It has been computed as
ğ‘šğ‘ğ‘¥(ğ‘ğ‘ğ‘ (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–âˆ’FracCov t(U,F))/FracCov t(U,F)),where ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–is
aquotientofapproximationsreturnedby ApproxCov ontheğ‘–ğ‘¡â„run
and of approximation returned by ApproxMaxCov on theğ‘–ğ‘¡â„run on
the corresponding feature model.
BLMMaxCov was able to compute 81 benchmarks for ğ‘¡=3, 19 for
ğ‘¡=4,9for ğ‘¡=5,andonly5for ğ‘¡=6.Comparisonofapproxima-
tionwith |Covt(Sol(F))|showedthelargesterrorof0.0086which
iswithinPACguarantees.TheerrorhistogramisshowninFigure7
Theexperimentshowsthatresultscomputedby ApproxMaxCov
are close to Covt(Sol(F))and within the selected boundary from
PAC guarantees ( RQ2).ApproxMaxCov was significantly faster
thantheexistingmethodsonlargebenchmarksandwasabletoout-
puttheresultonthebenchmarksupto ğ‘¡=6,where BLMMaxCov
timed out on several benchmarks even with a large time budget on
ğ‘¡=2, thus allowing us to positively answer to RQ4.
5.5 Approximation of FracCov t(U,F)
The approximations of FracCov t(U,F)have been obtained by tak-
ingpairsofresultsof ApproxCov andApproxMaxCov .Wereport
theworstapproximationobtainedbythismethod.Resultsfor15
sample sets are shown in Table 3 and the histogram of errors isshown in Figure 8. The largest error was 0.038 which is smaller
than the derived ğœ€.
This result shows that the approximation of FracCov t(U,F)ob-
tained with ApproxCov andApproxMaxCov is close to the correct
value. Moreover, considering the scalability of both approximation
algorithms,theapproximationcanbecomputedonallbenchmarks
except 6 for ğ‘¡=6, while existing methods succeeded only on 13,
thus positively answering RQ5.
5.6 Extension to the General Case
Inthissectionwedescribehowalgorithms ApproxCov andApprox-
MaxCov can be generalized to arbitrary alphabet size: the case
whereeachfeaturecantakeafinitenumberofvalues.Inthesecond
part of this subsection we provide results for empirical evaluation.
5.6.1 Generalization of Algorithms. The generalization of Approx-
Covrequires a few changes in Algorithm 1, yet the general idea of
checking inclusion into Covt(U)of randomly selected combina-
tionsremainsthesame.Inparticular,inlines1and15weneedtoBenchmark Ground Truth Approximation
baital_busybox_1_28_0 0.994542 0.993025waps_busybox_1_28_0 0.985651 0.983794quick_busybox_1_28_0 0.253179 0.256468
baital_ecos-icse11 0.975684 0.975041waps_ecos-icse11 0.790062 0.788512quick_ecos-icse11 0.282384 0.277069
baital_mpc50 0.980516 0.974432
waps_mpc50 0.797631 0.789341
quick_mpc50 0.538494 0.546906
baital_phycore 0.965864 0.961093waps_phycore 0.774117 0.782127quick_phycore 0.513699 0.519799
baital_psim 0.975527 0.971872
waps_psim 0.792510 0.785056
quick_psim 0.494380 0.498117
Table 3: Approximation of FracCov 2(U,F). Confidence parameters
areğ›¿=0.0975,ğœ€=0.105.
changethenumberofselectedcombinationsandthefinalmultipliertoensurethattheapproximationiswithinthePACguarantees.The
secondchangeistheuniform selection ofcombinationsintheset
taking into account the number of values each feature can take.Indeed, the sampling shall choose a feature with multiple values
more often than binary features.
The generalization of ApproxMaxCov is re-implemented, as fol-
lows:westartwithaformula FencodedwithQuantifier-FreeBit-
Vectorlogic(QF_BV)representingconstraintsoftheconfigurable
system.ThefirststepistoconstructaQF_BVformula GFbyextend-
ingFwithconstraintspresentedinSection4.2.Atthenextstepthe
formulaGFis converted into CNF. We use the SMT solver z3 with
the following tactics: Then(simplify, bit-blast, tseitin-cnf) (Boolean
variablesareaddedtokeeptrackoftheoriginalvariables).Inthe
resulted CNF formula we approximately compute the number of
solutions projected to the set ğ‘†with ApproxMC.
5.6.2 Empirical Results. To illustrate that ApproxCov can directly
operateoninstanceswithoutreductiontoBooleanvalues,weexper-imentedwiththeimplementationof
ApproxCov forfeaturemodels
without binarization. Our benchmark suite consisted of 35 feature
modelsand35samplesetsfrom[ 21].Thefeaturemodelshaveupto
200variableshavingbetween2and6values.Weusedthesameclus-ter,
ğœ€=ğ›¿=0.05forboth ApproxCov andApproxMaxCov .Forcom-
parisonweusedslightmodificationsof BLMCov andBLMMaxCov :
the former just needed to be capable to read the new inputs, while
in the latter we additionally replaced calls to SAT solver with calls
to SMT solver (z3).
Thetimeoutswere3600secondsfor BLMCov,ApproxCov ,and
ApproxMaxCov ,and14400secondsfor BLMMaxCov .Memorylimit
was 4Gb. Both ApproxCov andApproxMaxCov have been run 10
times, we report mean time among 10 runs and the furthest result
from the exact value computed with BLMCov andBLMMaxCov.
44
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Eduard Baranov, Sourav Chakraborty, Axel Legay, Kuldeep S. Meel, and Vinodchandran N. Variyam
Figure 9: Comparison of execution time of ApproxCov andBLMCov
forğ‘¡âˆˆ[2,6]onsamplesetsonwhich BLMCov havesuccessfullyter-
minated - 99 points in total. X axis shows BLMCov time in seconds,
Y axis shows ApproxCovGeneral time in seconds. Red line indicates
equal time.
Figure 10: Approximation error of ApproxCov forğ‘¡âˆˆ[2,6]on 99
samplesetsonwhich BLMCov havesuccessfullyterminated.Theer-
roriscomputedas ğ‘šğ‘ğ‘¥(ğ‘ğ‘ğ‘ (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–âˆ’|Covt(U)|)/|Covt(U)|),where
ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–is approximation returned by ApproxCov on theğ‘–ğ‘¡â„run.
ApproxCov have successfully terminated on all benchmarks for
ğ‘¡âˆˆ[2,6]within 150 seconds. BLMCov has failed 15 benchmarks
forğ‘¡=4,30for ğ‘¡=5,and31for ğ‘¡=6withOut-of-Memoryerror.
The comparison of execution times is shown on a Figure 9. Due
to the small size of benchmarks, BLMCov was faster on many of
them.TheapproximationerrorisshowninFigure10,thelargest
value was 0.0098.
ApproxMaxCov havesuccessfullyterminatedonallbenchmarks
forğ‘¡âˆˆ[2,4]within within the given timeout of 3600 seconds. 2
benchmarks for ğ‘¡=5 and 16 benchmarks for ğ‘¡=6 have timed out.
BLMMaxCov hasmanagedtoterminateon4benchmarksfor ğ‘¡=3
andonlyon1benchmarkfor ğ‘¡=4within14400secondstimeout.
Theapproximationerrorisshownin11,thelargestvaluewas0.005.
Figure11:Approximationerrorof ApproxMaxCov forğ‘¡âˆˆ[2,3]on40
benchmarks on which BLMMaxCov terminated. The error is com-
puted as ğ‘šğ‘ğ‘¥(ğ‘ğ‘ğ‘ (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–âˆ’|Covt(Sol(F))|)/|Covt(Sol(F))|), where
ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘–the approximation returned by ApproxMaxCov onğ‘–ğ‘¡â„run.
5.7 Threats to Validity
Internal Validity. Our algorithms provide an estimation of the re-
sultwith ProbablyApproximatelyCorrect guarantees,andseveral
runs may not yield identical results. To mitigate this threat we
provide theoretical proofs that bound the potential error, and inthe experiments we run each benchmark multiple times. In theobtainedresultsthedifferencebetweenmultiplerunswasbelow0
.06 forApproxCov and below 0 .021 forApproxMaxCov , and on
allbenchmarkstheworstapproximationwasalwayswithinPAC
guarantees interval for both algorithms.
ExternalValidity. Tomitigatethethreatofnon-generalizabilityof
our studywe haveuseda large number ofbenchmarks used before
in several prior studies [ 3,32,38,44,49,53]. These benchmarks
cover a wide range in the number of variables, clauses, and config-
urations.
6 CONCLUSION
Scalable and efficient computation of ğ‘¡-wise coverage is of pivotal
importance for Combinatorial testing. In this work, we proposealgorithmsforestimating
ğ‘¡-wisecoverageforagivensetoftests
and also for tests sets with a given set of constraints. In particular,
wepresent(1)ascalableMonte-Carlobasedframework ApproxCov
thatisguaranteedtoestimatethesizeofthecoverageofforagivensetoftestswithin
(1Â±ğœ€)-factorofthegroundtruthwithprobability
at least 1 âˆ’ğ›¿for given ğœ€andğ›¿; (2) a scalable counting-based frame-
workApproxMaxCov that estimates maximal achievable coverage
for a given formula and guarantees it to be within (1Â±ğœ€)-factor
withprobabilityatleast1 âˆ’ğ›¿forgiven ğœ€andğ›¿.Theapproachhave
been evaluated on a large set of benchmarks involving up to 11000
variables and we have shown that both frameworks can provide
highlyaccurateresultsevenforestimationof6-wisecoverageof
features. We also extended the frameworks to also include non-
binarydomains.Ourworkopensthepossibilitytocomparevarious
testsetgeneratorswiththepresentedframeworks.Animportant
direction for future work would be to perform an extensive evalua-
tion of the existing test set generators by estimating the maximum
achievable ğ‘¡-wisecoverageandexploringthepossibilitytoimprove
them based on the evaluation results.
45
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. A Scalable t-wise Coverage Estimator ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
ACKNOWLEDGEMENTS
This work was supported in part by EU H2020 project Serums
(826278-SERUMS-H2020-SC1-FA-DTS-2018-2020), by National Sci-
ence Foundation USA (NSF HDR:TRIPODS-1934884), and by Na-
tionalResearchFoundationSingaporeunderitsNRFFellowshipPro-
gramme [NRF-NRFFAI1-2019-0004] and AI Singapore Programme
[AISG-RP-2018-005]. Any opinions, findings and conclusions or
recommendations expressed in this material are those of the au-
thor(s)anddonotreflecttheviewsofNationalResearchFoundation,
Singapore.
REFERENCES
[1]Iago Abal, Claus Brabrand, and Andrzej Wasowski. 2014. 42 variability bugs
inthelinuxkernel:aqualitativeanalysis.In Proceedingsofthe29thACM/IEEE
international conference on Automated software engineering. 421â€“432.
[2]Mustafa Al-Hajjaji, Sebastian Krieter, Thomas ThÃ¼m, Malte Lochau, and Gunter
Saake.2016. IncLing:efficientproduct-linetestingusingincrementalpairwise
sampling. ACM SIGPLAN Notices 52, 3 (2016), 144â€“155.
[3]Eduard Baranov, Axel Legay, and Kuldeep S. Meel. 2020. Baital: an adaptive
weighted sampling approach for improved t-wise coverage. In ESEC/FSE â€™20:
28th ACM Joint European Software Engineering Conference and Symposium on
the Foundations of Software Engineering, Virtual Event, USA, November 8-13, 2020.
1114â€“1126. https://doi.org/10.1145/3368089.3409744
[4]Thorsten Berger, Ralf Rublack, Divya Nair, Joanne M Atlee, Martin Becker,
Krzysztof Czarnecki, and Andrzej Wasowski. 2013. A survey of variability mod-
eling in industrial practice. In Proceedings of the Seventh International Workshop
on Variability Modelling of Software-intensive Systems. 1â€“8.
[5]ThorstenBerger,StevenShe,RafaelLotufo,AndrzejWasowski,andKrzysztof
Czarnecki. 2013. A study of variability models and languages in the systems
software domain. IEEE Transactions on Software Engineering 39, 12 (2013), 1611â€“
1640.
[6]RenÃ©e C Bryce and Charles J Colbourn. 2009. A density-based greedy algorithm
for higher strength covering arrays. Software Testing, Verification and Reliability
19, 1 (2009), 37â€“53.
[7]Andrea Calvagna and Angelo Gargantini. 2010. A formal logic approach to
constrainedcombinatorialtesting. JournalofAutomatedReasoning 45,4(2010),
331â€“358.
[8]Supratik Chakraborty, Kuldeep S. Meel, and Moshe Y. Vardi. 2013. A Scalable
and Nearly Uniform Generator of SAT Witnesses. In P r oc .o fC A V . 608â€“623.
[9]Supratik Chakraborty, Kuldeep S. Meel, and Moshe Y. Vardi. 2013. A Scalable
Approximate Model Counter. In P r oc .o fC P . 200â€“216.
[10]Supratik Chakraborty, Kuldeep S. Meel, and Moshe Y. Vardi. 2014. Balancing
Scalability and Uniformity in SAT Witness Generator. In P r oc .o fD A C . 1â€“6.
[11]SupratikChakraborty,KuldeepS.Meel,andMosheY.Vardi.2016. Algorithmic
ImprovementsinApproximateCountingforProbabilisticInference:FromLinear
to Logarithmic SAT Calls. In Proc. of IJCAI.
[12]TsongYuehChen,HingLeung,andIKMak.2004. Adaptiverandomtesting.In
Annual Asian Computing Science Conference. Springer, 320â€“329.
[13]Anastasia Cmyrev and Ralf Reissing. 2014. Efficient and effective testing ofautomotive software product lines. King Mongkuts University of Technology
NorthBangkokInternationalJournalofAppliedScienceandTechnology 7,2(2014),
53â€“57.
[14]DavidM.Cohen,SiddharthaR.Dalal,MichaelL.Fredman,andGardnerC.Patton.
1997. The AETG system: An approach to testing based on combinatorial design.
IEEE Transactions on Software Engineering 23, 7 (1997), 437â€“444.
[15]MyraB.Cohen,PeterB.Gibbons,WarwickB.Mugridge,andCharlesJ.Colbourn.
[n.d.]. Constructing Test Suites for Interaction Testing. In Proceedings of the
25thInternational ConferenceonSoftware Engineering,May3-10,2003, Portland,
Oregon, USA. 38â€“48.
[16]R. Dechter, K. Kask, E. Bin, and R. Emek. 2002. Generating Random Solutions for
Constraint Satisfaction Problems. In Proc. of AAAI/IAAI. 15â€“21.
[17]Joe W Duran and Simeon C Ntafos. 1984. An evaluation of random testing. IEEE
transactions on Software Engineering 4 (1984), 438â€“444.
[18]Arnaud Durand, Miki Hermann, and Phokion G Kolaitis. 2005. Subtractive
reductions andcomplete problems forcounting complexity classes. Theoretical
Computer Science 340, 3 (2005), 496â€“513.
[19]Rafael Dutra, Kevin Laeufer, Jonathan Bachrach, and Koushik Sen. 2018. Effi-
cient sampling of SAT solutions for testing. In 2018 IEEE/ACM 40th International
Conference on Software Engineering (ICSE). IEEE, 549â€“559.
[20]RafaelDutra,KevinLaeufer,JonathanBachrach,andKoushikSen.2018. Efficient
sampling of SAT solutions for testing. In Proc. of ICSE. 549â€“559.
[21]Brady J Garvin, Myra B Cohen, and Matthew B Dwyer. 2009. An improved
meta-heuristicsearchforconstrainedinteractiontesting.In 20091stInternationalSymposium on Search Based Software Engineering. IEEE, 13â€“22.
[22]V.GogateandR.Dechter.2006. ANewAlgorithmforSamplingCSPSolutions
Uniformly at Random. In P r oc .o fC P . 711â€“715.
[23]CarlaP.Gomes,AshishSabharwal,andBartSelman.2006. Modelcounting:A
new strategy for obtaining good bounds. In Proc. of AAAI. 54â€“61.
[24]CarlaP.Gomes, AshishSabharwal,andBartSelman.2007. Near-Uniformsam-
pling of combinatorialspaces using XOR constraints.In Proc. ofNIPS. 670â€“676.
[25]Loreto Gonzalez-Hernandez, Nelson Rangel-Valdez, and Jose Torres-Jimenez.
2010. Constructionofmixedcoveringarraysofvariablestrengthusingatabu
search approach. In International Conference on Combinatorial Optimization and
Applications. Springer, 51â€“64.
[26]Rahul Gupta, Shubham Sharma, Subhajit Roy, and Kuldeep S. Meel. 2019. WAPS:
Weighted and Projected Sampling. In Proceedings of Tools and Algorithms for the
Construction and Analysis of Systems (TACAS).
[27]Yue Jia, Myra B. Cohen, Mark Harman, and Justyna Petke. 2015. Learning Com-
binatorialInteractionTestGenerationStrategiesUsingHyperheuristicSearch.
In37thIEEE/ACMInternationalConferenceonSoftwareEngineering,ICSE2015,
Florence, Italy, May 16-24, 2015, Volume 1. IEEE Computer Society, 540â€“550.
[28]Martin Fagereng Johansen, Ã˜ystein Haugen, and Franck Fleurey. 2012. Analgorithm for generating t-wise covering arrays from large feature models. In
Proceedingsofthe16thInternationalSoftwareProductLineConference-Volume1.
46â€“55.
[29]R.M. Karp and M. Luby. 1983. Monte-Carlo algorithms for enumeration and
reliability problems. Proc. of FOCS (1983).
[30]RichardMKarp,MichaelLuby,andNealMadras.1989. Monte-CarloApproxima-
tionAlgorithmsforEnumerationProblems. JournalofAlgorithms 10,3(1989),
429â€“448.
[31]Nathan Kitchen. 2010. Markov Chain Monte Carlo stimulus generation for con-
strained random simulation. Ph.D. Dissertation. UC Berkeley.
[32]Alexander KnÃ¼ppel,Thomas ThÃ¼m,Stephan Mennicke,Jens Meinicke,and Ina
Schaefer. 2017. Is there a mismatch between real-world feature models and
product-lineresearch?.In Proceedingsofthe201711thJointMeetingonFoundations
of Software Engineering. ACM, 291â€“302.
[33]D Richard Kuhn, Raghu N Kacker, and Yu Lei. 2010. Practical combinatorial
testing.NIST special Publication 800, 142 (2010), 142.
[34]DRichardKuhn,RaghuNKacker,andYuLei.2013. Introductiontocombinatorial
testing. CRC press.
[35]James H Kukula and Thomas R Shiple. 2000. Building circuits from relations. In
P r oc .o fC A V .
[36]Yu Lei, Raghu Kacker, D Richard Kuhn, Vadim Okun, and James Lawrence. 2007.
IPOG:Ageneralstrategyfort-waysoftwaretesting.In 14thAnnualIEEEInterna-
tionalConferenceandWorkshopsontheEngineeringofComputer-BasedSystems
(ECBSâ€™07). IEEE, 549â€“556.
[37]Yu Lei, Raghu Kacker, D Richard Kuhn, Vadim Okun, and James Lawrence. 2008.
IPOG/IPOG-D: efficient test generation for multi-way combinatorial testing.
Software Testing, Verification and Reliability 18, 3 (2008), 125â€“148.
[38]JiaHuiLiang,VijayGanesh,KrzysztofCzarnecki,andVenkateshRaman.2015.
Sat-basedanalysisoflargereal-worldfeaturemodelsiseasy.In Proceedingsof
the 19th International Conference on Software Product Line. ACM, 91â€“100.
[39]ChuanLuo,BinqiSun,BoQiao,JunjieChen,HongyuZhang,JinkunLin,Qing-
wei Lin, and Dongmei Zhang. 2021. LS-Sampling: An Effective Local Search
Based Sampling Approach for Achieving High t-Wise Coverage (ESEC/FSE 2021).
1081â€“1092.
[40]Robert Mandl. 1985. Orthogonal Latin squares: an application of experiment
design to compiler testing. Commun. ACM 28, 10 (1985), 1054â€“1058.
[41]DusicaMarijan,ArnaudGotlieb,SagarSen,andAymericHervieu.2013. Practicalpairwisetestingforsoftwareproductlines.In Proceedingsofthe17thinternational
software product line conference. 227â€“235.
[42]JamesDMcCaffrey.2009. Generationofpairwisetestsetsusingageneticalgo-
rithm. In 2009 33rd annual IEEE international computer software and applications
conference, Vol. 1. IEEE, 626â€“631.
[43]FlÃ¡vio Medeiros, Christian KÃ¤stner, MÃ¡rcio Ribeiro, Rohit Gheyi, and Sven Apel.
2016. A comparison of 10 sampling algorithms for configurable systems. In 2016
IEEE/ACM 38th International Conference on Software Engineering (ICSE). IEEE,
643â€“654.
[44]Kuldeep S. Meel. 2020. Model counting and uniform sampling instances. https:
//doi.org/https:/doi.org/10.5281/zenodo.3793090
[45]Kuldeep S Meel and S Akshay. 2020. Sparse hashing for scalable approximate
model counting: Theory and practice. In Proc. of LICS.
[46]MatthewWMoskewicz,ConorFMadigan,YingZhao,LintaoZhang,andSharad
Malik. 2001. Chaff: Engineering an efficient SAT solver. In P r oc .o fD A C .
[47]ChanghaiNieandHaretonLeung.2011. Asurveyofcombinatorialtesting. ACM
Computing Surveys (CSUR) 43, 2 (2011), 1â€“29.
[48]Kari J Nurmela. 2004. Upper bounds for covering arrays by tabu search. Discrete
applied mathematics 138, 1-2 (2004), 143â€“152.
[49]Jeho Oh, Paul Gazzillo, and Don S. Batory. 2019. t-wise coverage by uniform
sampling.In Proceedingsofthe23rdInternationalSystemsandSoftwareProduct
46
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Eduard Baranov, Sourav Chakraborty, Axel Legay, Kuldeep S. Meel, and Vinodchandran N. Variyam
LineConference,SPLC2019,VolumeA,Paris,France,September9-13,2019.15:1â€“
15:4.
[50]David Lorge Parnas. 1976. On the design and development of program families.
IEEE Transactions on software engineering 1 (1976), 1â€“9.
[51]Gilles Perrouin, Sagar Sen, Jacques Klein, Benoit Baudry, and Yves Le Traon.
2010. Automated and scalable t-wise test case generation strategies for software
productlines.In 2010Thirdinternationalconferenceonsoftwaretesting,verification
and validation. IEEE, 459â€“468.
[52]Tobias Pett, Thomas ThÃ¼m, Tobias Runge, Sebastian Krieter, Malte Lochau, and
InaSchaefer.[n.d.].ProductSamplingforProductLines:TheScalabilityChallenge.
([n.d.]).
[53]Quentin Plazar, Mathieu Acher, Gilles Perrouin, Xavier Devroey, and Maxime
Cordy. 2019. Uniform sampling of sat solutions for configurable systems: Are
wethereyet?.In 201912thIEEEConferenceonSoftwareTesting,Validationand
Verification (ICST). IEEE, 240â€“251.
[54]Iran Rodrigues, MÃ¡rcio Ribeiro, FlÃ¡vio Medeiros, Paulo Borba, Baldoino Fonseca,
andRohitGheyi. 2016. Assessingfine-grainedfeaturedependencies. Inf.Softw.
Technol.78 (2016), 27â€“52. https://doi.org/10.1016/j.infsof.2016.05.006
[55]Gadiel Seroussi and Nader H Bshouty. 1988. Vector sets for exhaustive testing of
logic circuits. IEEE Transactions on Information Theory 34, 3 (1988), 513â€“522.
[56]ShubhamSharma,RahulGupta,SubhajitRoy,andKuldeepS.Meel.2018. Knowl-
edge Compilation meets Uniform Sampling. In Proc. of LPAR-22. 620â€“636.
[57]NeilJASloane.1993. Coveringarraysandintersectingcodes. Journalofcombi-
natorial designs 1, 1 (1993), 51â€“63. https://doi.org/10.1002/jcd.3180010106
[58]MateSoos,StephanGocht,andKuldeepSMeel.2020. Tinted,Detached,andLazyCNF-XORsolvinganditsApplicationstoCountingandSampling.In International
Conference on Computer Aided Verification (CAV).[59]Mate Soos and Kuldeep S Meel. 2019. BIRD: Engineering an Efficient CNF-XOR
SAT Solver and its Applications to Approximate Model Counting. In Proc. of
AAAI.
[60]Larry Stockmeyer. 1983. The complexity of approximate counting. In Proc. of
STOC. 118â€“126.
[61]Reinhard Tartler, Daniel Lohmann, Christian Dietrich, Christoph Egger, and
Julio Sincero. 2011. Configuration coverage in the analysis of large-scale system
software. In Proceedings of the 6th Workshop on Programming Languages and
Operating Systems. 1â€“5.
[62]Keizo Tatsumi. 1987. Test case design support system. In Proc. International
Conference on Quality Control (ICQCâ€™87). 615â€“620.
[63]Thomas ThÃ¼m, Sven Apel, Christian KÃ¤stner, Ina Schaefer, and Gunter Saake.
2014. Aclassificationandsurveyofanalysisstrategiesforsoftwareproductlines.
ACM Computing Surveys (CSUR) 47, 1 (2014), 1â€“45.
[64]Leslie G. Valiant. 1979. The complexity of enumeration and reliability problems.
SIAM J. Comput. 8, 3 (1979), 410â€“421.
[65]Ziyuan Wang, Baowen Xu, and Changhai Nie. 2008. Greedy heuristic algo-
rithms to generate variable strength combinatorial test suite. In 2008 The Eighth
International Conference on Quality Software. IEEE, 155â€“160.
[66] Wei Wei and Bart Selman. 2005. A new approach to model counting. In Proc. of
SAT.
[67]Akihisa Yamada, Armin Biere, Cyrille Artho, Takashi Kitamura, and Eun-Hye
Choi.2016.Greedycombinatorialtestcasegenerationusingunsatisfiablecores.InProceedingsofthe31stIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering. 614â€“624.
[68]Cemal Yilmaz, Sandro FouchÃ©, Myra B. Cohen, Adam A. Porter, GÃ¼lsen DemirÃ¶z,
andUgurKoc.2014. MovingForwardwithCombinatorialInteractionTesting.
Computer 47, 2 (2014), 37â€“45.
47
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:50:18 UTC from IEEE Xplore.  Restrictions apply. 