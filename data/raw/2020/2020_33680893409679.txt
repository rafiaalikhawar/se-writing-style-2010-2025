Mining Input Grammars fromDynamic ControlFlow
Rahul Gopinath
rahul.gopinath@cispa.saarland
CISP
A Helmholtz Center for
InformationSecurity
Saarbrücken, Saarland,GermanyBjörnMathis
bjoern.mathis@cispa.saarland
CISPA Helmholtz Center for
InformationSecurity
Saarbrücken, Saarland,GermanyAndreas Zeller
zeller@cispa.saarland
CISPA Helmholtz Center for
InformationSecurity
Saarbrücken, Saarland,Germany
ABSTRACT
One of the key properties of a program is its input specification.
Having a formal input specification can be critical in fields such as
vulnerability analysis, reverse engineering, software testing, clone
detection,orrefactoring.Unfortunately,accurateinputspecifica-
tionsfor typical programs are often unavailableor outof date.
Inthispaper,wepresentageneralalgorithmthattakesaprogram
andasmallsetofsampleinputsandautomaticallyinfersareadable
context-freegrammarcapturingtheinputlanguageoftheprogram.
We infer the syntactic input structure only by observing access
ofinputcharactersatdifferentlocationsoftheinputparser.This
works on all stack based recursive descent input parsers, including
parsercombinators,andworksentirelywithoutprogramspecific
heuristics.Our Mimidprototypeproducedaccurateandreadable
grammarsforavarietyofevaluationsubjects,includingcomplex
languagessuch as JSON, TinyC, andJavaScript.
CCS CONCEPTS
·Softwareanditsengineering →Softwarereverseengineer-
ing;Dynamicanalysis ;·Theoryofcomputation →Grammars
andcontext-free languages.
KEYWORDS
context-free grammar, dynamic analysis, fuzzing, dataflow, control-
flow
ACM Reference Format:
Rahul Gopinath, Björn Mathis, and Andreas Zeller. 2020. Mining Input 
Grammars from Dynamic Control Flow. In Proceedings of the 28th ACM 
Joint European Software Engineering Conference and Symposium on the Foun-
dations of Software Engineering (ESEC/FSE ’20), November 8ś13, 2020, Virtual 
Event, USA. ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/ 
3368089.3409679
1 INTRODUCTION
One of the key properties of a program is its input specification.
Having a formal input specification is important in diverse fields
such as reverse engineering [18], program refactoring [29], and
program comprehension [23, 44]. To generate complex system in-
puts for testing, a specification for the input language is practically
mandatory [12, 27, 32]
ESEC/FSE ’20, November 8ś13, 2020, Virtual Event, USA
© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-7043-1/20/11.
https://doi.org/10.1145/3368089.3409679⟨START⟩::=⟨ json_raw⟩
⟨json_raw⟩::=‘"’⟨json_string′⟩|‘[’⟨json_list′⟩|‘{’⟨json_dict′⟩
|⟨json_number′⟩|‘ true’|‘false’|‘null’
⟨json_number′⟩::=⟨ json_number⟩+
|⟨
json_number⟩+‘ e’⟨json_number⟩+
⟨
json_number⟩::=‘ +’|‘-’|‘.’|‘[0-9]’|‘E’|‘e’
⟨json_string′⟩::=⟨json_string⟩∗‘"’
⟨json_list′⟩::=‘]’
|⟨json_raw⟩(‘,’⟨json_raw⟩)∗‘]’
|(‘,’⟨json_raw⟩)+(‘,’⟨json_raw⟩)∗‘]’
⟨json_dict′⟩::=‘}’
|(‘"’⟨json_string′⟩‘:’⟨json_raw⟩‘,’)∗
‘"’⟨json_string′⟩‘:’⟨json_raw⟩‘}’
⟨json_string⟩::=‘’|‘!’|‘#’|‘$’|‘%’|‘&’|‘’’
|‘*’|‘+’|‘-’|‘,’|‘.’|‘/’|‘:’|‘;’
|‘<’|‘=’|‘>’|‘?’|‘@’|‘[’|‘]’|‘^’| ’_’,’‘’,
|‘{’|‘|’|‘}’|‘~’
|‘[A-Za-z0-9]’ |‘\’⟨decode_escape⟩
⟨
decode_escape⟩::=‘"’|‘/’|‘b’|‘f’|‘n’|‘r’|‘t’
Figure 1:JSONgrammarextracted from microjson.p y.
However, formalinput specifications are seldom available, and
whentheyare,theymaybeincomplete[ 14],obsolete,orinaccurate
withrespecttotheprogram[ 47].Unfortunately,determiningthe
input language of a program is a non-trivial problem even when
the source code is available [ 27]. Therefore, obtaining input models
automatically bears greatpromise for software engineering.
While researchers have tried to tackle the problem of grammar
recoveryusingblack-boxapproaches[ 14,48],theseminalpaperby
AngluinandKharitonov[ 11]showsthatapureblack-boxapproach
isdoomedtofailureas therecannotbeapolynomialtimealgorithm in
termsofthenumberofqueriesneededforrecoveringacontext-free
grammarfrommembershipqueriesalone.Hence,only white-box
approachesthattakeprogramsemanticsintoaccountcanobtain
an accurateinputspecification.
The first white-box approach to extract input structures from
programs is the work by Lin et al. [ 39,40], which recovers parse
treesfrominputsusingacombinationofstaticanddynamicanal-
ysis. However, Lin et al. stop at recovering the parse trees with
limited labeling, and the recovery of a grammar from the parse
trees is non-trivial (as the authors recognize in the paper, and as
indicated by the limited number publications in this topic even
thoughrecoveringsuchagrammarisimportantinmanyareasof
software engineering).
172This work is licensed under a Creative Commons Attribution International 4.0 License.
ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA RahulGopinath, Björn Mathis, Andreas Zeller
The one approach so far that extracts human-readable input
grammarsfromprogramsis Autogram [33]byHöscheleetal.Given
aprogramandasetofinputs, Autogram extractsanapproximate
context-freegrammaroftheprogram’sinputlanguage.Itdoessoby
tracking the dynamic data flow betweenvariables at different loca-
tions:Ifapartoftheinputisassignedtoavariablecalled protocol ,
this substringforms a ⟨protocol⟩nonterminal inthe grammar.
While dynamic data flows produce well-structured grammars
on a number of subjects, the approach depends on a number of
assumptions, the most important being that some data flow to a
uniquevariable hastobethereinthefirstplace.Ifaprogramaccepts
astructuredinputwhereonlypartoftheinputissavedandused,
there isnodata flowto learn from inthe unsavedparts.
Second,learningfromdynamicdataflowsrequiresspecialheuris-
ticstoworkaroundcommonparsingpatternsidentified;thedata
flow induced by a parser lookahead, for instance, has to be ignored
asitwouldotherwisebreakthemodel[ 33].Finally,commonpat-
terns such as passing the complete input as an array with an index
indicatingcurrentparsestatuscanbreakthesubsumptionmodel.
These shortcomings limit learning from data flows to a small class
ofinputprocessors.
Inthispaper,wedescribea generalalgorithm torecoverthe input
grammar from a program without any of these limitations. Rather
thanbeing based on data flows to unique variables,it recovers the
inputgrammarfrom dynamiccontrolflow andhowinputcharacters
areaccessedfromdifferentlocationsintheparser.Ouralgorithm
works regardless of whether and how the parsed data is stored
and requires no heuristics to identify parsing patterns. It works on
allprogram stack basedrecursive descent parsers,including mod-
ern techniquessuch as parser combinators.The recursive descent
family ofparsers makesup 80% ofthe top programming language
parsers onGitHub[ 41].
Theresultinggrammarsarewell-structuredandveryreadable.
As an example, consider the JSON grammar shown in Figure 1,
which our Mimidprototype extracted from microjson.py .1Each
JSONelementhasitsownproductionrule; ⟨json_number⟩,forin-
stance, lists a number as astring of digits. Rules capture the recur-
sivenatureoftheinput:A ⟨json_list’⟩contains⟨json_raw⟩elements,
whichinturnareotherJSONvalues.Allidentifiersofnonterminals
are derived from the names of the input functions that consume
them. All this makes for very readable grammars that can be easily
understood,adapted,andextended.
Whydoweemphasizethe readability ofextractedgrammars?
Recoveringreadablegrammarsisimportantinanumberofareas
insoftware engineering[ 46].
•Therecoveredgrammarrepresentstheinputspecificationof
thegivenprogramandprovidesanoverviewofhowthepro-
gramprocessesitsinputs.Thiscanbeusedforunderstanding
theprogramandidentifyingwherepossiblevulnerabilities
lie. The grammar recovered can be useful for identifying
the difference between differing implementations, and even
foridentifyinghowtheinputspecificationchangedacross
revisions, andidentifying compatibilityissues.
•Alargenumberofrecentbugshavebeencausedbyincor-
rectlyimplementedparsersforcommonspecifications [ 43].
1Weremoved rulespertainingto whitespace processing for clarity.Recoveringtheactualgrammaroftheinputsacceptedbythe
program can helpusidentifythe problematic parts easily.
•Another important use of grammar is for debugging where
techniques such as hierarchical delta debugging [ 42] can
onlybeappliedifonehastheprograminputgrammar.An
inputgrammar for a givenprogram can also be of use ifone
wantstorepairdamagedinputs[ 37].Inallthesecases,the
inputsneedto be decomposedintosmallerfragments.
•When using a grammar as an input producer for testing,
readable grammars allow testersto refine the grammar with
specific inputs such as logins, passwords, or exploits. Given
such a grammar, one can contract the grammar such that
only specific subparts are generated if one is first able to un-
derstand what partsofthe grammarcorrespondto thepart
that one is interested in. If even a partial human readable
grammarisavailable,itcanbeexpandedwithhumanknowl-
edge on features where the miner may not have sufficient
inputs or identify vulnerabilities through human inspection
of the grammar (e.g. allowing special characters in user-
names).Fuzzerscanonlyallowforsuchcontrolifthemodel
ishuman-readable.
Intheremainderofthispaper,wefirstillustrateourapproach
on a simple, self-contained example in Section 2 . We then detail
our contributions:
(1)Weprovideageneralalgorithmforderivingthecontext-free
approximationofaninputlanguagefromarecursivedescent
parser. Our approach relies on tracking character accesses in
theinputbuffer (Section3),whichiseasytoimplementfor
avarietyoflanguagesthatsupportstringwrappers,orthe
source can be transformed to support such wrappers, or
dynamic taint information is available. From the tracked
accesses, we then infer parse trees (Section 4 ), which we
generalizebymeansof activelearning2,beforepassingthem
to our grammar inference ( Section 5). Our approach distills
the developer supplied method names and input processing
structure to produce human-readableinputgrammars.
(2)We evaluate our approach using subjects in both Python
andCand recover complex grammars such as JavaScript
andTinyC. For the evaluation, we assess both precision and
recall (Section 6) of our grammars. When compared against
learning from dynamic data flows (so far the only approach
forinferenceofhuman-readablegrammars),wefoundour
approach to be superior inboth precision andrecall.
(3)In our evaluation, we also show that our approach is ap-
plicable in contexts in which no usable data flow of input
fragmentstovariablesexistssuchasmodernparsingtech-
niqueslike parsercombinators whichmakethestateofthe
art for writing secure parsers [ 17,19].
After discussing limitations ( Section 7 ) and related work ( Sec-
tion 8),Section 9 closes with conclusion and future work. The
complete sourcecode ofour approach andevaluation isavailable.
2The term active learning was first used by Dana Angluin [ 10] for grammar learning.
173Mining Input Grammarsfrom Dynamic Control Flow ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
1 defdigit(i):
2 return iin"0123456789"
3
4 defparse_num(s,i):
5 n =''
6 whilei !=len(s)anddigit(s[i]):
7 n += s[i]
8 i = i +1
9 return i, n
10
11 defparse_paren(s, i):
12 assert s[i] == '('
13 i, v = parse_expr(s, i+1)
14 ifi ==len(s):raiseEx(s, i)
15 assert s[i] == ')'
16 return i+1, v
17
18 defparse_expr(s, i = 0):
19 expr, is_op = [], True
20 whilei <len(s):
21 c = s[i]
22 ifdigit(c):
23 if not is_op: raiseEx(s,i)
24 i,num = parse_num(s,i)
25 expr.append(num)
26 is_op = False
27 elifcin['+','-','*','/']:
28 ifis_op: raiseEx(s,i)
29 expr.append(c)
30 is_op, i = True, i + 1
31 elifc =='(':
32 if not is_op: raiseEx(s,i)
33 i, cexpr = parse_paren(s, i)
34 expr.append(cexpr)
35 is_op = False
36 elifc ==')':break
37 else:raiseEx(s,i)
38 ifis_op: raiseEx(s,i)
39 return i, expr
40
41 defmain(arg):
42 return parse_expr(arg)
43
Figure 2:APython parser formath expressions
2 OURAPPROACHINA NUTSHELL
Howdoesourapproachwork?Weuselightweightinstrumentation
totrackdynamiccontrolflow andlightweightstringwrappers(or
dynamic taint information if available) to identify in which control
flow nodes specific input characters are accessed. The character
accessesaswellasthecorrespondingcontrol flownodesarethen
logged. A parse tree of the input string is extracted from that trace
using the following rules(whichmostly followLin etal.[ 39]):
(1)Arecursivedescentparsertriesalternativesrulesuntilthe
first successful parse, and a character is not accessed after
it was successfully parsed. Hence, the method call that ac-
cessesaparticularinputcharacterlast directlyconsumes that
character. E.g. if a call to digit()is the last to access the
digit3,then3isconsumedbythat callto digit().
(2)Amethodcall indirectlyconsumes acharacterifoneofthe
nestedmethodcalls consumes that character.
(3)A control flow node such as a conditional (e.g. if) or loop
(e.g.while) is regarded as a pseudo method. The name for
the pseudo method is derived from the parent method name
andaunique identifier.⟨parse_expr⟩
⟨while(1)⟩
⟨if(1)⟩
⟨parse_num⟩
⟨digit⟩
’9’⟨while(1)⟩
⟨if(1)⟩
’+’⟨while(1)⟩
⟨if(1)⟩
⟨parse_num⟩
⟨digit⟩
’3’⟨while(1)⟩
⟨if(1)⟩
’/’⟨while(1)⟩
⟨if(1)⟩
⟨parse_num⟩
⟨digit⟩
’4’
Figure 3:Derivationtree for 9+3/4
(4)Namesofmethodsthat consumesomepartoftheinputare
used as the nonterminal symbol for the corresponding node
inthe parse tree for that part.
As an example, consider Figure 2showing a complete Python
programthatacceptsmathematicalexpressionsusingarecursive
descentparser.Runningitwithanargument 9+3/4yieldsthetenta-
tiveparsetreeshowninFigure 3.Themethod parse_num() ,which
parsesnumeric elements, becomesthe nonterminal⟨parse_num⟩in
the parse tree ( Figure 3), representing inputnumeric elements.
The parse tree is then processed further to correctly identify
compatible nonterminal nodes withthe following steps:
(1)Collectandgroupnodesbythenamesoftheir nonterminal
symbols.
(2)Identify subdivisions within each nonterminal group by sub-
stitutingnodeswitheachotherinthecorrespondingparse
trees andverifying the validity of resultingparse trees.
(3)Generate unique nonterminal symbols for identified sub-
groupsand updatethem inthe correspondingnodes inthe
parse trees. This gives usaccurately labelledparse trees.
We thenuse thisaccurately labelledparsetrees toinfer agrammar:
(1)Eachnodeinaparsetreeiscollected,andthe nonterminal
symbolbecomes a nonterminal inthe generatedgrammar.
(2)Each sequence of terminalandnonterminal symbols from
childnodesofthe nonterminal becomesapossibleexpansion
rulefor that nonterminal .
(3)Apply the prefix-tree acceptor algorithm [ 25] to identify
regularright handsides[ 36]dueto loopsandconditionals.
(4)Applygeneralizationoftokenssuchasconvertingaseenlist
ofintegersto an expressionthat can generateany integer.
(5) Compactandcleanup the grammar.
Weextractsuchparsetreesfor anumberofgiveninputs.Next,
we traverse each tree and identify loopnodes that are similar as
we detail in Section 4.1. This results in parse trees where similar
nodes have similar names. Finally, we construct the grammar by
recursively traversing each parse tree and collecting the name and
children typesandnames for eachnode.The nodenames become
nonterminal symbols in the grammar, and each set of children
becomesonepossibleexpansioninthegrammarbeingconstructed.
Thechildnodesthatrepresentcharactersbecometerminalsymbols
inthe constructedgrammar.
For our example, the final result is the grammar in Figure 4,
whichexactlyreflectsthecapabilitiesoftheprogramin Figure2.
174ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA RahulGopinath, Björn Mathis, Andreas Zeller
⟨START⟩::=(⟨parse_expr⟩[*+-/])∗⟨parse_expr⟩
⟨parse_expr⟩::=⟨parse_num⟩|⟨parse_paren⟩
⟨parse_paren⟩::=‘(’⟨parse_expr⟩‘)’
⟨parse_num⟩::=⟨parse_digit⟩+
⟨digit⟩::=‘0’|‘1’|‘2’|‘3’|‘4’|‘5’|‘6’|‘7’|‘8’|‘9’
Figure 4:Agrammarderived fromtheparser in Figure 2
Again,thegrammarisreadablewithnear-textbookqualityandwell
reflectsthe inputstructure.
3 TRACKINGCONTROLFLOWAND
COMPARISONS
Let us now start with describing the details of how we infer the
parse tree from dynamiccontrolflow.
Fortrackingthecontrol flow,we programmaticallymodify the
parser source. We insert a tracker for both a method entry and
an exitaswell astrackers forcontrolflow entry and exitforany
conditionsandloops.Forthepurposesofourapproach,weconsider
these control structures as pseudo methods . Every such method call
(both true and pseudo method calls) gets a unique identifier from a
countersuchthatachildofthecurrentmethodoralatermethod
callgetsalarger newmethodidentifier thanthe currentone.
InPython,fortrackingthecharacteraccessesbeingmade,we
simply wrap the input string in a proxy object that log access to
characters.Weannotateeachcharacteraccessedwiththecurrent
method name. For C, the above information is recovered using a
lightweightdynamictaint framework.
What if one can not distinguish parsing functions? In such case,
one can simply conservatively instrument allfunctions. Given that
weonlylogaccesstotheinitialbuffer,thenon-parsingfunctions
will have no effect (except on performance) on the parse trees
generated.Anotherapproachwouldbetomakeuseofstaticanalysis
to identify parsingfunctions that mightaccess the initial buffer,
andinsert trackers only onthosefunctions.
Inbothlanguages,westoptrackingassoonastheinputistrans-
formedorcopiedintoadifferentdatastructure(ifthereisalexer,
we continue the trackingintothe parser stage)3.
Wenotethat accessto thesourcecodeisnotarequirement.So
long as one can track access to the initial input string and identify
methodcalls(bytheiraddressifweareanalysingabinary)onecan
recover the requiredinformation.
4 FROM TRACES TO PARSETREES
Theprevioussectionshowedhowtoannotatetheexecutiontree
withindexesoftheinputstringaccessedbyeachmethodcall.At
this point, however, there can be multiple accesses by different
methods at the same input index. To assign specific indexes to
specificmethodcalls,wefollowasimplestrategyinformedfrom
the characteristics of recursive descent parsers: The last method
callthat accessed a character directly consumes that character, and
its parentmethodcalls indirectlyconsumethat character4.
3This is one of the main differences of our technique from both Lin et al. [ 40] and
Höschele et al. [ 33] whotrack dynamictaintsthroughout the program.
4Wenote thatthis isone of the majordifference of our technique fromLin et al. [ 40]
who define parsing points as thelastpointthecharacterwas used beforetheparsingWe now resolve the ownership of input index ranges between
nodes. Given any node, we obtain the starting and ending indexes
that were consumed by the node. If no other node has consumed
anycharacterwithinthatrange,thecurrentnode directlyowns that
range, and all its parent nodes indirectly own that range. If a range
overlap is found between a parent node and a child node, the tie is
decided in favor of the child, with the child node directly owning
theoverlap,andtheparentnode indirectlyowning theoverlap.If
anoverlapisfoundbetweentwosiblingnodes,thetieisdecided
in favor of the sibling that accessed the part last (as the last access
to the character defines the consumer method). The sibling that is
intheoverlapisrecursivelyscanned,andanydescendentofthat
node that are containedinthe overlap are removed.
Once the indexes are associated with method call identifiers,
wegeneratea calltreewitheachmethodidentifierarrangedsuch
that methods called from a given method are its children. The
directly ownedinput indexes are addedas the leafnodes from the
correspondingmethodcallnode.Asthereisnooverlap,suchatree
can be consideredas a parse tree for the given inputstring.
The parse tree at this point is given in Figure 5a, which we call
thenon-generalized parsetreeoftheinputstring.InFigure 5a,each
pseudo method has a list of values in parenthesis, in the following
format. The last value in the parenthesis is the identifier for the
controlflownodetaken.Thatis,givenanodenameas ⟨if(2:0,3:1)⟩,
theidentifieris 3:1.Itindicatesthatthecorresponding ifstatement
wasthethirdconditionalintheprogram,andtheexecutiontook
the first ( if) branch of the conditional. If the identifier was 3:2,
itwouldindicatethattheexecutiontookthe elsebranch,andfor
larger values, it indicates the corresponding branch of a cascading
ifstatementoracasestatement.In thecaseofloops,thereisonly
a single branch that has child nodes, and hence this is indicated by
0.Thevaluesbeforetheidentifiercorrespondtotheidentifiersof
the pseudo-method parents of this node until the first method call.
Thatis, the⟨if(2:0,3:1)⟩hasa parentnode thatis a loop,and it is
the secondloopinthe program.
While we have produced a parse tree, it is not yet in a format
fromwhichwecanrecoverthecontext-freegrammar.Tobeable
todoso,weneedaccuratelylabeledparsetreeswhereanygiven
nodecan be replacedby anodeofsimilarkind withoutaffecting
the parse validity of the string. The problem here is that not all
iterationsofloopsarereplaceablewitheachother.Thatis,loopscan
be influenced by the previous iterations. For example, consider the
derivationtreeinFigure 5a.Ifoneconsiderseachiterationofthe
looptobeone alternateexpansion tothecorresponding nonterminal ,
the rulerecoveredis:
⟨expr⟩→num |+|/
However,thisisincorrectasasinglefree-standingoperatorsuch
as+is not a validvalue.The problem is that is_opencodesa link
betweendifferentiterations.Hence,weannotateeachindividual
iterationandleaverecoveringtheactualrepeatingstructureforthe
nextstep.Asimilarproblemoccurswithmethodcallstoo.Inthe
producedparsetreeweassumethatanygiven nonterminal Ðsay
⟨parse_num⟩Ðcanbereplacedbyanotherinstanceof ⟨parse_num⟩
pointofitssuccessor.Theproblemwithsuchanapproachisthatreal-worldparsers
mayaccess characters out of order. See Section8.2 for details.
175Mining Input Grammarsfrom Dynamic Control Flow ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
⟨parse_expr⟩
⟨while(1:0)⟩
⟨if(1:0,1:1)⟩
⟨parse_num⟩
⟨digit⟩
’9’⟨while(1:0)⟩
⟨if(1:0,1:2)⟩
’+’⟨while(1:0)⟩
⟨if(1:0,1:1)⟩
⟨parse_num⟩
⟨digit⟩
’3’⟨while(1:0)⟩
⟨if(1:0,1:2)⟩
’/’⟨while(1:0)⟩
⟨if(1:0,1:1)⟩
⟨parse_num⟩
⟨digit⟩
’4’
(a) Non-generalized parse tree. The number before colon indicates
theparticularpseudo-method,andnumberafterthecolonidentifies
thealternativeifany.Thatis, if(... 5:2) isthefifth ifwhoseelse
branch was taken. The pseudo methodstack isinside‘()’.⟨parse_expr⟩
⟨while(1:1)⟩
⟨if(1:1,1:1)⟩
⟨parse_num⟩
⟨digit⟩
’9’⟨while(1:0)⟩
⟨if(1:0,1:2)⟩
’+’.⟨while(1:1)⟩
⟨if(1:1,1:1)⟩
⟨parse_num⟩
⟨digit⟩
’3’⟨while(1:0)⟩
⟨if(1:0,1:2)⟩
’/’.⟨while(1:1)⟩
⟨if(1:1,1:1)⟩
⟨parse_num⟩
⟨digit⟩
’4’
(b)Generalizedparsetree.Thenumberinsuffixaftercolonindicates
the generalized identifier after validating replacements. As before,
the pseudo method stack is contained in the parenthesis, which is
also updatedwhen theparentis updatedduring generalization.
Figure 5: Parse trees for 9+3/4. The prefix before colon indicates the static identifier of the control structure in the method.
Thatis, thefirst ifgets theprefix 1:.The suffix isexplained above.
withoutaffecting thevalidityof thestring.However, thisassump-
tion may not hold true in every case. The behavior of a method
may be influenced by a number of factors including its parameters
andthe globalenvironment. We fixthis inthe nextstep.
4.1 ActiveLearning ofLabeling
To determine the precise labeling of each node, we first collect
eachnodefromeachparsetreeandgroupthembythenameofthe
nonterminal .Thatis,all⟨parse_num⟩nodesgotogether,sodoall
⟨if(1:0,1:1)⟩.
Next, the challenge is to identify the buckets under the grouped
nodesthatarecompatiblewitheachother.Weconsideranodeas
replaceable with anotherif the string producedfrom a parse tree
where the first node is replaced by the second is parsed correctly ś
thatis,thegeneratedstringisparsedwithoutanyerrors,andthe
parsetreegenerated from thenewparsehasthe samestructure as
thetreegeneratedbyreplacingthenode.Anodeis compatible with
anotherif both nodes are replaceable witheachother.
Unfortunately,compatibilityisnot transitive ifonelooksatparse
validity.For example,say, there are three wordsin a language Ð a,
b,andac.Eachwordiscomposedofindividual letters.Inthecase
ofa,andb,thecorrespondingletter,andfor ac,theletters a,andc.
⟨start⟩::=⟨word1⟩|⟨word2⟩|⟨word3⟩
⟨word1⟩::=⟨letter_a⟩
⟨word2⟩::=⟨letter_b⟩
⟨word3⟩::=⟨letter_a⟩⟨letter_c⟩
⟨letter_a⟩::=‘a’
⟨letter_b⟩::=‘b’
⟨letter_c⟩::=‘c’
Now,considerthe parse trees of a,b,andac.
(⟨start⟩(⟨word1⟩(⟨letter_a⟩’a’)))
(⟨start⟩(⟨word2⟩(⟨letter_b⟩’b’)))
(⟨start⟩(⟨word3⟩(⟨letter_a⟩’a’) (⟨letter_c⟩’c’)))
Here,thenodes⟨letter_a⟩acrossparsetreesarecompatiblebecause
thegeneratedstringsareexactlythesame.Next,the ⟨letter_a⟩under
⟨word1⟩is compatible with ⟨letter_b⟩under⟨word2⟩. The gener-
ated strings are aandb. So, is the node⟨letter_b⟩under⟨word2⟩compatible with⟨letter_a⟩under⟨word3⟩? Unfortunately not, as
the stringgeneratedfrom
(⟨start⟩(⟨word3⟩(⟨letter_b⟩’b’) (⟨letter_c⟩’c’)))
isbcwhichisnot inthe language.
Thismeansthatfortheaccurateidentificationofuniquenode
labels, each node has to be compared with all other nodes with
the same name, which gives us a complexity of O(n2)in the worst
case in terms of the number of nodes. However, we found that the
assumption of transitivity rarely breaks, and even then, the inac-
curacyinducedaffectslessthan10%ofinputsgeneratedfromthe
grammar(Seetheevaluationof mathexpr.py ).Sincetheassumption
oftransitivity allows us to reduce the computational effort, our
evaluation is implemented assuming transitivity of compatibility.5
Oncewehaveidentifiedthecompatibilitybuckets,wecanupdate
the nodes in them with unique suffixes corresponding to each
bucket and update the node name of each one with the suffix. In
the case of loop nodes, we also update the stack name of this node
in all the descendent elements of this node Ð all descendent nodes
up to the next non-pseudo method call. The idea here is that if
there are two unique loop iterations that are incompatible with
each other, then any other control flow nodes inside that loops
such asconditionals shouldalsobe considered incompatible even
ifthesamealternativepathistakenintheconditionalduringthe
executionofboth iterations.
Once the process is complete, all the nodes in all the parse trees
will be labeled with consistent and correct identifiers. These can
then be extracted to produce the correct grammar. The generalized
counterpartto Figure 3isgiven inFigure 5b.
4.2 ActiveLearning ofNullability
Some of the loops may be skipped completely Ð e.g., an empty
objectinJSON.Thesecanbeidentifiedusing activelearning .The
idea is to replace all consecutive loopnodes that are the children
of a given node in a given parse tree. Then check the validity of
thestringproducedfromthattree.Iftheparsestructureofthenew
5Wenotethatauserofourtechniquedoesnotneedtorelyonthisassumption.One
can choose to do the complete O(n2)verification, or can choose anything in between
that and the fasterbutapproximate version.
176ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA RahulGopinath, Björn Mathis, Andreas Zeller
stringiscorrect,andthiscanbedoneonallparsetreesandatall
pointswhere this ispossible,the loopismarkedas nullable.
Forconditionalnodes,whetheran ifnodecanbeskippedcanbe
determinedstaticallywithoutactivelearning,bysimplychecking
for the presence of an elsebranch. However, ifconditionals may
be labeled incorrectly. For example, consider this set of statements:
1 ifg_validate:
2 validate_header(header)
While the ifdoes not have an elsebranch, we do not know
whether the body of the conditional can be skipped or not. In
particular, the g_validate may be a global configuration option
whichmaymeanthatitisalwaysenabledoralwaysdisabledfor
specific kindsof parse trees. While we have not found such condi-
tionalsinoursubjects,ifadditionalaccuracyisdesired,theoptional
parts ofconditionals mayalsobe verifiedusing active learning.
Withthis,ourtreesareaccuratelylabeledandreadyforinferring
grammars from them.
5 GRAMMARINFERENCE
For constructing a grammar out of parse trees, we traverse each
parse tree starting from the top. Each node we see, if it is not a
character node, is marked as a nonterminal in the grammar. The
children are placed as the rule for expansion of the nonterminal in
the grammar. If the child is a non-character node, the token in the
expansion will be a reference to the corresponding nonterminal in
the grammar. There may be multiple alternate expansions to the
samenonterminal evenfromthesametreeasthesamemethodcall
maybe maderecursively.This isdetailedinAlgorithm 1.
Algorithm1 Extracting the basic grammar
function extract_grammar (node,grammar)
name,uid,children,stack⇐node
a_name⇐name+uid+stack
rule⇐[]
ifa_name/nelementдrammar then
grammar[a_name]⇐{rule}
else
grammar[a_name].add(rule)
ifchildren=∅then
returnterminal,a_name
else
forchild←childrendo
kind,cname⇐extract_grammar(child)
ifkind=terminalthen
rule+=to_terminal(cname)
else
rule+=to_nonterminal(cname)
returnnonterminal,a_name
Anadditionalchallengecomesfromidentifyingrepeatingpat-
terns. From the various solutions of this problem [ 25], we chose amodificationofthe prefixtreeacceptor algorithm6.Oncewerunthe
modified PTAalgorithm, the previous grammaristransformedto:
⟨expr⟩→while:1
⟨expr⟩→(while:1 while:2)+ while:1
⟨while:1⟩→if:1
⟨if:1⟩→num
⟨while:2⟩→+
Thewhile:<n> can be replaced by the regular expression sum-
mariesofthecorrespondingrulesrecursively.Here,thisgivesus
the regularexpression:
⟨expr⟩→num |(num[+])+ num
Whilegeneralizing,wecanreplaceany +with∗providedallthe
itemsinsidethegrouparenullable.Similarly,whenmergingregular
expressionscorrespondingtoconditionals,onecanadd (...|)i.e.anϵ
alternative, provided the corresponding ifcondition was nullable.
These steps generate the right hand side regular expressions in
Figure 4 for a simple program given in Figure 2. For details on
learningregularexpressionsfromsamples,seeHiguera[ 22].The
grammar derived from microjson.py after removing differences due
towhite spaces isgiven in Figure 1.
5.1 Generalizing Tokens
Thegrammarwehavegeneratedsofarisafaithfulreproductionof
theparsingprocess.Thisgrammarishowevernotcompletewith
respect tothe generalization.The reason is that typicallanguages
relyonexternal libccallssuchas strtod,strtof,andstrstr.Theinternal
structure oftheportionsthusparsedarelosttooursimpletracer.
Hence,weneedtorecoverthestructureoftheseitemsseparately.
Asimilarproblemalsooccursinparsersthatusesaninitial scanner
thatfeedstokens into parser.Theseresultin nonterminal symbols
whichsimply contain alonglistof tokens such as
⟨int⟩::=‘786022139’ |‘1101’|‘934’|‘898880’|‘1’
which need to be generalized.The solution here is a simple gener-
alization,withthe following steps.
(1) Collectall terminalsymbolsinthe grammar.
(2) Spliteach terminalsymbolintoindividualcharacters.
(3)Widenthe character into itsparent group. E.g. Givena char-
acter ‘1’, widen it first to ‘ ⟨digit⟩’, then to ‘⟨alphanum⟩’, and
lastlyto‘⟨anychar⟩’,checkingtomakesurethateachwiden-
ing is accepted by the program, and is parsed in the same
manner.
(4) Deduplicatethe resultinggrammar
(5)Apply regular expression learning using the PTA algorithm
to obtain the fully generalizedgrammar.
5.2 Producinga CompactGrammar
At this point, the mined grammar is readable but verbose. There
are a number of transformations that one can take to reduce its
verbosity withoutchanging thelanguagedefined bythegrammar.
Theseare as follows:
6Unliketheoriginal PTA,whichconsidersonlyrepeatingpatternsofsinglecharacters,
wefirstscanforandidentifyrepeatingpatternsofanyblocksize.Wenextscanthe
inputs for any instances of the identified repeating patterns. These inputs are then
chunked and considered as the alphabets as in the original PTAalgorithm.
177Mining Input Grammarsfrom Dynamic Control Flow ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
(1)If there is any nonterminal that is defined by a single rule
with a single token, delete the key from the grammar and
replace allreferences to that key withthe token instead.
(2)Iftherearemultiplekeyswiththesameruleset,chooseone,
delete the rest, and update the references to other keys with
the chosenone.
(3)Ifthere are duplicate rulesunderthe same key, remove the
redundantrules.
(4) Remove any rulethat isthe same as the key itdefines.
(5)If there is any key that is referred to on a single rule on a
singletoken,andthekeyisdefinedbyjustonerule, delete
thekeyfromthegrammarandreplacethereferencetothe
key withthe rule.
We repeat these steps as long as the number of rules in the
grammardecreasesineachcycle.Thisproducesasmallergrammar
that definesthe same language.
6 EVALUATION
We compare our approach of learning grammars from dynamic
controlflowwiththestateoftheart,namelylearninggrammars
from dynamic data flow, as embodied in the Autogram tool [33].
The original Autogram implementation extracts input grammars
from Java programsÐin contrast to our Mimidprototype, which
worksonPythonandCprograms.Forourcomparison,wetherefore
relied on the code from Mining Input Grammars [51] from Zeller et
al., which embodies the Autogram approach by learning grammars
fromdynamicdataflowofPythonprograms.Asweareinterestedin
comparingalgorithms,ratherthantools,foralldifferencesinresults,
we investigate howmuchthey are dueto conceptual differences.
WealsonotethatthePythonimplementationoflearningfrom
dynamicdataflowsdoesnotimplementgeneralizationofcharacter
sets to regular expressions (unlike the original Autogram tool [33]).
ForafaircomparisonsofPythonsubjects,wethushavedisabled
Mimidgeneralizationofcharactersetstolargerregularexpressions.
For C subjects,generalization ofcharacter setsisenabled.
Our researchquestionsare as follows:
RQ 1.Howaccurateare the derivedgrammars as producers?
RQ 2.Howaccurateare the derivedgrammars as parsers?
RQ 3.Canoneapply Mimidtomodernparsingtechniquessuch
as combinatory parsing?
6.1 Subjects
Wefocusedonsubjectsthatdemonstrateddifferentstylesofwriting
recursive descentparsers, withdifferent levels ofgrammars,with
and without a lexing stage, and in different implementation lan-
guages. Our subjects were the following (the kind of the grammar
śregularorcontextfree isindicatedinparenthesis).
calc.py(CFG) ś a simple recursive descent program written in
textbookstylefromtheCodeproject[ 1],simplifiedandcon-
vertedtoPython.Italso formstherunningexamplein Sec-
tion2.Weusedselfgeneratedexpressionstominethegram-
mar andevaluate.
mathexpr.py (CFG)śamoreadvancedexpressionevaluatorfrom
theCodeproject[ 5].Itincludespre-definedconstants,method
calls, andthe ability todefine variables. Asin the casewithcalc.py, we used self generated expressions and test cases to
minethe grammarandevaluate.
cgidecode.py (RG) ś the cgidecode.py Python implementation
from the chapter on Code Coverage [49] from Zeller et al.
This is an example of a parser that is a simple state machine.
It is not recursive and hence does not use the stack. For
cgidecode.py, we used self generated expressions to mine
the grammarandevaluate.
urlparse.py (RG)śtheURLparserofthePython urlliblibrary[9].
Anexampleofanadhocparsingwithlittleorderingbetween
how the parts are parsed. For initial mining and evaluation,
we used the URLs generated from passing tests using the
test_urllib.py inthePythondistribution.Wealsousedahand-
written grammarto generateinputsas we detaillater.
microjson.py (CFG)śaminimalJSONparserfromGithub[ 6].We
fixed a few bugs in this project during the course of extract-
ingitsgrammar(mergedupstream).Formining,wechoseten
simplesamplesthatexploredallcodepathsintheparser.For
ourevaluation,weused100samplesofJSONgeneratedfrom
the following JSON API end points: api.duckduckgo.com ,de-
veloper.github.com ,api.github.com ,dictionaryapi.com ,word-
sapi.com,tech.yandex.com . We also added sample JSON files
fromjson.org,json-schema.org ,jsonlint,www.w3schools.com ,
andopensource.adobe.com .
parseclisp.py (CFG)śTheconversionofans-expressionParser
using Parsec[ 4] toPyParsec. We used a golden grammar (a
given correctgrammar) to generateinputs.
tiny.c(CFG)śaminimalCcompilerimplementedinC[ 8].The
tinycparserusesaseparatelexingstage.Weusedagolden
grammargiven inthe tinycsourceto generatethe inputs.
mjs.c(CFG) ś a minimal Javascript interpreter implemented in
C [7]. We used the ANTLR grammar for JavaScript from the
ANTLR projectto generateinputs.
jsonparser.c (CFG)śafast JSON parser implementedinC [ 3].
6.2 RQ 1. GrammarAccuracyas Producer
For our experiments, we used both learning from dynamic data
flows (Autogram ; [33]) and learning from dynamic controlflow
(Mimid;ourapproach)onthe samesetofsamplesandgenerated
agrammarfromeachapproachforeachprogram.Thisgrammar
was then used to generate inputs to fuzz the program using the
GrammarFuzzer [50]. The number of inputs that were accepted by
the subjectprogram isgiven inTable 1.
Grammarsinferred from dynamic control flow produce more
correctinputsthandynamic dataflow.
To assess and understand the differences in results between
learningfromdataflowandcontrolflow,wemanuallyexamined
the grammars produced where a large difference was visible. As
an implementation for learning from dynamic data flows was only
available for Python,we only look at thesesubjectsindetail.
6.2.1calc.py.A snippet of the grammar learned from dynamic
data flowfor calc.pyisgiven below.
178ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA RahulGopinath, Björn Mathis, Andreas Zeller
Table 1: Inputs generated by inferred grammars that were
accepted by theprogram (1,000inputs each)
from data flows from controlflows
(state ofthe art) (our approach)
calc.py 36.5% 100.0%
mathexpr.py 30.3% 87.5%
cgidecode.py 47.8% 100.0%
urlparse.py 100.0% 100.0%
microjson.py 53.8% 98.7%
parseclisp.py 100.0% 99.3%
jsonparser.c n/a 100.0%
tiny.c n/a 100.0%
mjs.c n/a 95.4%
⟨START⟩::=⟨init@884:self⟩
⟨init@884:self⟩::=⟨expr@26:c⟩‘0’‘0’
|⟨expr@26:c⟩‘3’⟨expr@26:c⟩⟨expr@29:num⟩
⟨expr@26:c⟩‘*’⟨expr@29:num⟩‘*’‘4’
|⟨expr@26:c⟩‘1’⟨expr@26:c⟩⟨expr@26:c⟩‘0’⟨expr@26:c⟩‘2’
|⟨expr@26:c⟩‘1’‘0’‘0’) ...
The grammar from our approach (dynamic control flow) for the
sameprogramusingsameminingsampleisgiveninFigure 4.An
examinationshowsthattherules derivedfromdynamicdataflow
werenotasgeneralasours.Thatis,thegrammargeneratedfrom
dynamic data flow is enumerative at the expense of generality.
Whydoesthishappen?Thereasonisthat parse_expr() andother
functions in calc.pyaccept abufferof input characters, with an
index specifying the current parse location. learning from dynamic
data flow relies on fragmented values being passed into method
calls for successful extraction of parts and hence the derivation of
tree structure. Here, the first call creates a linear tree with each
nested method claiming theentirety ofthebuffer,andthis defeats
the learningalgorithm.
Thisisnotamatterofbetterimplementation.Theoriginal Auto-
gramimplementation [ 33] relies on parameters to the method calls
to contain only parts of the input. While any algorithm learning
from dynamic data flows may choose to ignore the method param-
eters,anyuseofasimilarbufferinsidethemethodwillcausethe
algorithmtofailunlessitisabletoidentifysuchspuriousvariables.
6.2.2mathexpr.py .Formathexpr.py , the situation was again simi-
lar.Learning fromdynamicdataflow wasunabletoabstractany
rules. The mathexpr.py program uses a variation of the strategy
usedbycalc.pyforparsing.Itstorestheinputinaninternalbufferin
theclassandstorestheindextothebufferasthelocationbeingcur-
rentlyparsed.Forsimilarreasonsasbefore,learningfromdynamic
dataflowsfailstoextractthepartsofthebuffer.Ourapproachof
learningfromdynamiccontrolflow,ontheotherhand,produced
an almost correct grammar, correctly identifying constants and
external variables. The single mistake found (which was the cause
ofmultiple invalidoutputs)was instructive.The mathexpr.py pro-
gram pre-defines letters from atozas constants. Further, it also
definesfunctionssuchas exp().Thefunctionnamesarechecked
in the same place as the constants are parsed. Mimidfound thatthe function names are composed of letters, and some of the let-
ters in the function names are compatible with the single letter
variablesÐthey can be exchanged and still produce correct values.
Since we assumed transitivity ,Mimidassumed that all letters in
function names are compatible with single letter constants. This
assumption produced function names such as eep(), which failed
the inputvalidation.
6.2.3microjson.py .Themicrojson.py grammar inferred from dy-
namicdataflowproducesmorethan50%validinputswhencom-
pared to 98.2% from Mimid. Further, we note that the 50% valid
inputs paints a more robust picture than the actual situation. That
is, the grammar recovered from dynamic data flows for microj-
son.pyis mostly an enumeration of the values seen during min-
ing.The reasonisthat microjson.py usesadatastructure JStream
which internally contains a StringIO buffer of data. This data
structureispassedasmethodparametersforallmethodcalls,e.g.
_from_json_string(stm) . Hence, every call to the data structure
gets the complete buffer with no chance of breaking it apart. We
notethatitispossibletoworkaroundthisproblem byessentially
ignoringmethodparametersandfocusingmoreonreturnvalues.
The problem with the data structure can also be worked around
by modifying the data structure to hold only the remaining data to
beparsed. Thishowever, requiressomespecific knowledgeofthe
program being analyzed. Learning from dynamic control flow with
Mimid, on the other hand, is not affected by the problem of buffers
at allandrecovers acomplete grammar.
6.2.4urlparse.py .Forurlparse.py ,neithergrammarslearnedfrom
data flow nor those learned from control flows performed well (the
inferred grammar could recognize less than 10% of the samples)
due to the inability to generalize strings. Since we were interested
in comparing the capabilities of both algorithms in detecting a
structure,werestrictedourminingsampletoonlycontainaspecific
set of strings. The urlparse.py program splits the given input to
⟨scheme⟩,⟨netloc⟩,⟨query⟩, and⟨fragment⟩based on delimiters.
In particular, the internal structure of ⟨netloc⟩and⟨query⟩were
ignoredbythe urlparse.py .
Hence,wewroteagrammarfor urlparse.py whichcontaineda
list of specific strings for each part. Next, we generated 100 inputs
eachusingtheGrammarFuzzerandvalidatedeachbycheckingthe
stringwiththeprogram.Wethenusedthesestringsasaminingset.
With this mining set, the grammars learned from both data flow
andcontrolflowcould produce 100% correctinputs.
6.2.5parseclisp.py .Similar to other subjects, the grammar gener-
ated byAutogram was enumerativewhich resulted in 100%gener-
atedinputsacceptedbytheprogram(onlypreviouslyseeninputs
couldbegenerated)whileresultinginmuchlowerinputsproduced
by the golden grammar being accepted by the recovered grammar.
Thegrammarrecoveredby Mimidontheotherhandcouldparse
80.6% ofthe inputsproducedbythe goldengrammar.
6.2.6jsonparser.c .The program jsonparser.c is inC, and hence
there is no evaluation using Autogram . However, we note that
grammarrecoveredusing Mimidhad100% accuracyinproducing
valid inputswhen usedfor fuzzing.
179Mining Input Grammarsfrom Dynamic Control Flow ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
Table 2: Inputs generated by a golden grammar that were
acceptedbytheinferredgrammarparser(1,000inputseach
exceptmicrojson.py which used 100 externalinputs)
from data flows from controlflows
(state ofthe art) (our approach)
calc.py 0.0% 100.0%
mathexpr.py 0.0% 92.7%
cgidecode.py 35.1% 100.0%
urlparse.py 100.0% 96.4%
microjson.py 0.0% 93.0%
parseclisp.py 37.6% 80.6%
jsonparser.c n/a 83.8%
tiny.c n/a 92.8%
mjs.c n/a 95.9%
6.2.7tiny.c.The program tiny.cis also in C, and hence there is
noevaluationusing Autogram .However,likefor jsonparser.c ,the
grammarrecoveredusing Mimidcould produce 100%valid inputs
when fuzzing.
6.2.8mjs.c.Theprogram tiny.cisalsoaCsubjectwithnoevalua-
tionpossible using Autogram .We found thatthe inputs produced
by thegrammarrecovered using Mimidwere almostalways valid
(95.4%).
6.3 RQ 2. GrammarAccuracyas Parser
For our second question, we want to assess whether correct inputs
wouldalsobeacceptedbyourinferredgrammars.Inordertoobtain
correctinputs,weusedvariousapproachesasavailablefordifferent
grammars. For calc.pyandmathexpr.py , we wrote a grammar by
hand.Next,we usedthisgrammartogenerateasetofinputsthat
were then run through the subject programs to check whether the
inputswerevalid.Wecollected1,000suchinputsforbothprograms.
Next,theseinputswerefedintoparsersusinggrammarsminedfrom
dynamiccontrolflow( Mimid)anddynamicdataflow( Autogram ).
We used the Iterative Earley Parser from [52] for verifying that the
inputswere parsedbythe given grammar.
Forurlparse.py , we used the same grammar for parsing that we
alreadyhadusedtogeneratemininginputs.Weagaincollecteda
set of valid inputs and verified that the inferred grammar is able to
parse these inputs. For microjson.py , we used the collected JSON
documents as described above. The largest document was 2,840
lines long. We then verified whether the grammar inferred by each
algorithmcouldparsetheseinputs.Ourresultsaregivenin Table2.
Asonewouldexpect,grammarsfromdataflowcannotparsetheex-
pressionsfrom calc.pyandmathexpr.py grammars.For cgidecode.py ,
grammars from data flow performed poorly, while grammars from
dynamiccontrolflow( Mimid)achieved100%accuracy.Asweex-
pected, grammars from dynamic control flow performed better for
microjson.py too,withmorethan90%oftheinputsamplesrecog-
nizedbythe inferredgrammar.
Grammarsinferred from dynamiccontrol flow acceptmore
correctinputsthanthosefrom dynamic dataflow.The outlier is urlparse.py , for which grammars from dynamic
data flow achieved 100% while grammars from dynamic control
flow (Mimid) performed slightly worse (but still more than 90%
inputstringsrecognizedbytheinferredgrammar).Aninspection
of the source code of the subject program reveals that it violated
one of the assumptions of Mimid. Namely, urlparse.py searches for
character strings in the entirety of its input rather than restricting
searchestounparsedpartsoftheprogram.Forexample,itsearches
for URL fragments (delimited by #) starting from the first location
in the input. When this happens, Mimidhas no way to tell these
spuriousaccessesapart from the true parsing.
Wehavenocomparisonsfrom Autogram fortheCsubjects.How-
ever,thegrammarrecoveredby Mimidforeachofthe Csubjects
couldparsealmostallinputsproducedbythegoldengrammarÐ
jsonparser.c (83.8%),tiny.c(92.8%),and mjs.c(95.9%).
6.4 RQ 3. Modern ParsingTechniques
While the large majority of parsers is written by hand in thetradi-
tional recursive descent approach [ 41], another parsing technique
has become popular recently. Parser combinators [19] are recom-
mendedoverparsergeneratorsduetothevariousinflexibilitiessuch
as handling ambiguities, context-sensitive features [ 38], and bad
errormessages[ 35]7whenusingparsergenerators.Indeed,parser
combinators are often recommended [ 17] as recognizers where no
usable dataflow to unique variables exist. Combinatory parsers are
parsers that are built from small primitive parsers that recognize a
single literal at a time. These are combined using two operations Ð
sequencing( AndThen),andalternation( OrElse).Giventhatthese
parsersfollowafixedrecipeforcombinations,recoveringthegram-
marfromarepresentativecombinatoryparserthatusesprimitive
parsers as well as the two operations is sufficient to show that
Mimidcan recovergrammars from any such combinatory parsers
howevercomplex.Hence,toverifythatourtechniquecanindeed
recoverthegrammarfromparserswrittenusingthe combinatory
parsingapproach,weincludearepresentativecombinatoryparsing
recognizer ( parseclisp.py ) inour subjects.
As our results in Table 1andTable 2show, our technique is not
challengedbythis kindof parsers.
Mimid is not challenged bycombinatoryparsers.
7 LIMITATIONS
Our work issubjectto the following importantlimitations.
Approximation. Aninterpreterforaprogramminglanguageor
a data format for specific applications often have additional
restrictions beyond the initial parsing stage. We only try to
recover the grammar from the initial parser, andhence, the
grammarrecoveredisanapproximationandcapturesonly
the syntactic part not the semantic rules. We assume that
inputisparsedaslongasitissubjecttołsyntacticžcharacter
andstringcomparisonsandstorageonly;and processed as
7In the words of a commenter ( https://news.ycombinator.com/item?id=18400717 ) łget-
ting a reasonable error message out of YACC style parser generators is as fun as
poking yourself in the eye with a sharp stickž. GCC ( http://gcc.gnu.org/wiki/New_C_
Parser), and CLANG ( http://clang.llvm.org/features.html#unifiedparser ) use handwrit-
tenparsers for the same reason.
180ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA RahulGopinath, Björn Mathis, Andreas Zeller
other łsemanticž operations such as arithmetics are being
applied.
Table-driven parsers. Intable-driven parsers, control flow and
stack are not explicitly encoded into the program, but an
implicitpartoftheparserstate.Wedonotattemptgrammar
recovery from table driven parsers with Mimid.
Sampleinputs. The features of grammars produced by Mimidre-
flectthefeaturesoftheinputsitisprovidedwith:Ifafeature
is not present in the input set, it will not be present in the
resultinggrammareither.Newtestgeneratorsspecifically
targeting input processors [ 41]could be able to create such
inputsetsautomatically.
Reparsing. SinceMimidtracks only the lastaccess of a character,
it can get confused if an ad hoc parser reparses a previously
parsed input. This problem can be addressed by exploring
multiple candidates for consumption and comparing the
resultinggrammarstructure.
8 RELATED WORK
Learningtheinputlanguageofagivenprogramisanestablished
line of research. There is a large body of work [ 22,30,31] and a
community[ 2]devotedtolearninggrammarsthroughblack-box
approaches.However,asnotedin Section1,therearefundamen-
tal limits [ 11] to this technique, which also apply to statistical
approaches such as Learn&Fuzz [ 28], PULSAR [ 26],Neural byte
sieve[45], andNEUZZ[24]. Wethus focuson gray andwhite-box
techniques.
8.1 Learning Context-FreeGrammars
Autogram [33]istheapproachclosesttoours. Autogram usesthe
program code in a dynamic,white-box fashion. Given a program
and a set of inputs, Autogram usesdynamic taints to identify the
dataflow fromtheinputtostringfragmentsfoundduringexecution.
Theseentitiesareassociatedwithcorrespondingmethodcallsin
the call tree, and each entity is assigned an input interval that
specifies start and end indices of the string found in that entity
duringexecution.Usingasubsumptionrelation,theseintervalsare
collatedintoaparsetree;thegrammarforthatparsetreecanbe
recoveredbyrecursivelydescendingintothetree.Whilelearning
from dynamic data flows can produce very readable and usable
grammars, its success depends on having a data flow to track. If
partsof theinputare notstoredin somevariable, thereisnodata
flowtolearnfrom.Iftheparserskipspartsoftheinput(say,toscan
overacomment),thiswillnotresultinadataflow.Conversely,data
canflowinto multiplevariables, causinganothersetofproblems.
Ifaparserusesmultiplefunctions,whoseparametersareabuffer
pointerandanindexintothebuffer,theneachofthesefunctions
gets the entire buffer as a data flow. Such programming idioms
maybelessfrequentinJava(thesubjects Autogram aimsat),butin
generalwouldrequire expensive anddifficult disambiguation.
In contrast, our approachtracks allaccessesof individual char-
acters,nomatterwhethertheywouldbestored.Ourassumption
that the last function accessing a character is the consumer of this
character (and hence parsing a nonterminal ) still produces very
readableandaccurategrammars.8.2 RecoveringParse Trees
Lin et al. [ 39,40] show how to recover parse trees from inputs
using a combination of static and dynamic analysis. Theyobserve
thatthestructureoftheinputisinducedbythewayitspartsare
used during execution, and provide two approaches for recovering
bottom-upandtop-downparsetrees.Similar toourapproach,they
construct a call tree which contains the method calls, and crucially,
the conditionals and individual loop iterations. Next, they identify
whichnodesinthecalltreeconsumewhichcharactersintheinput
string. Their key idea is a parsing point where they consider a
particularcharactertohavebeenconsumed.Theparsingpointofa
character is the last point that the character was usedbefore the
parsing point of its successor. A character is used when a value
derivedfromit isaccessedÐthatis,theinputlabelsarepropagated
throughvariable assignments muchlike taints.
A problem with this approach is that it onlyconsiders well writ-
ten parsers in the text book style that consumes characters one
byonebeforethenextcharacterisparsed.Unfortunately,inreal
world handwritten parsers, one cannot always have this guarantee.
For example, the Python URL parser first checks if a given URL
containsanyfragment(indicatedbythedelimiter #),andifthere
is,thefragmentissplitfromtheURL.Next,intheremaining prefix,
thequerystringischecked,whichisindicatedbythedelimiter ?,
which is then separated out from the path. Finally, the parameters
thatareencodedinthepathusing ;areparsedfromthepathleft
over fromthe above steps. Thiskind of processing isby no means
rare. A common pattern is to split the input string into fields using
delimiters such as commas and then parse the individual fields. All
this means that the parsing points by Lin et al. will occur much
beforetheactualparse.Linetal.notethatonecannotsimplyuse
thelastuseofalabelasitsparsingpointbecausethevaluesderived
from itmaybe accessedafter the parsingphase.
Mimidusesthesame lastusestrategy,butgetsaroundthisprob-
lem by only tracking access to the original input buffer. Mimid
stops tracking as soon as the input is transformed, which makes
theMimidinstrumentationlightweight, andgrammars accurate.
Finally,Linetal.stopatparsetrees.Whiletheyshowhowthe
function names can form the nonterminal symbols, their approach
stops at identifying control flow nodes and makes no attempt to
eitheridentifycompatiblenodesortheiterationorder,ortorecover
agrammarwhichneedssomethingsimilartothe prefixtreeacceptor
algorithmtogeneralizeovermultipletrees,eachofwhichisneeded
toaccurately label the parse tree.
8.3 Testingwith Grammar-Like Structures
GRIMOIRE by Blazytko et al. [ 15] is an end-to-end grey-box fuzzer
thatusesthenewcoverageobtainedbyinputstosynthesizea gram-
marlikestructure whilefuzzing.Therearetwomajorshortcomings
withthegrammarlikestructuresgeneratedby GRIMOIRE .First,ac-
cording to the authors [ 15, Section 3, last paragraph], the grammar
likestructurecontainsaflathierarchyandcontainsasingle non-
terminaldenotedby □.Thisnonterminal canbeexpandedtoany
of the łproduction rulesž which are input fragments with the same
nonterminal □insertedinthem,producinggapsthatcanbefilled
in. Real world applications, however, often have multiple nestings,
whereonlyaparticularkindofitemscanbeinsertedÐe.gnumbers,
181Mining Input Grammarsfrom Dynamic Control Flow ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA
strings, etc. These kinds of structures cannot be represented by the
grammar like structure without loss of accuracy. Second, as the
grammarstructurederivedby GRIMOIRE isessentiallyalonglistof
templates,the grammar islikely tobe uninterpretable byhumans.
Othertoolsthatinfergrammarlikestructuresduringtestgen-
erationinclude GLADE[14]andREINAM [48](basedon GLADE),
both of which are black-box approaches, and thus subject to the
constraints of black-box approaches. Bastani et al. provide a proof
that aparenthesis (Dyck) languagecanbe inferred by the GLADE
algorithm in O(n4)time in terms of the seed length. This, however,
can not be generalizedto the generalcontext-free class [ 11].
NeitherGRIMOIRE ,GLADE, orREINAM allow to export the
inferred input structures, as they focus on test generation rather
thangrammarextraction.
8.4 Learning Finite State Models
The idea of using dynamic traces for inferring models of the un-
derlying softwaregoes backto Hungaretal.[ 34],learning afinite
statemodelrepresentationofaprogram;Walkingshawetal.[ 47]
later refined this approach using queries. Such models represent
legalsequencesof(input) eventsandthuscorrespondtotheinput
languageoftheprogram.Whileourapproachcouldalsobeapplied
toeventsequencesratherthancharactersequences,itfocuseson
recovering syntactic (context-free) input structures. Another re-
latedworkbyBafanteetal.[ 16]usesamethodsimilartooursto
group similar nodes duringautomataapproximation.
8.5 Domain-Specific Approaches
Polyglot [ 18] and Prospex [ 20] reverse engineer network proto-
cols. They track how the program under test accesses its input
data, recovering fixed-length fields, direction fields, and separa-
tors.Tupni[ 21]fromCuietal.usessimilartechniquestoreverse
engineerbinaryfileformats;forinstance,elementsequencesare
identifiedfromloopsthatprocessanunboundedsequenceofele-
ments.AuthScan[ 13]fromBaietal.usessourcecodeanalysisto
extract web authentication protocols from implementations. None
ofthesegeneralizes to recursive inputstructures.
9 CONCLUSION AND FUTUREWORK
Many activities of software engineering benefit from formal input
modelsforaprogram.However,formalinputmodelsareseldom
available, and even then, the model can be incomplete, obsolete,
orinaccurate with respect to theactual implementation. Inferring
inputgrammarsfromdynamiccontrolflow,asintroducedinthis
paper, produces readablegrammarsthataccuratelydescribe input
syntax. Improving overthe state of the art,which uses data flowto
identifygrammars,ourapproachcaninfergrammarseveninthe
absenceofdataflowanddoesnotrequireheuristicsforcommon
parsing patterns. As we show in our evaluation, our approach is
superiortothestateoftheartbothinprecisionandrecallandis
applicabletoawiderangeofparsers,uptoinputlanguagessuch
as JSON, JavaScript, or TinyC whose complexity far exceeds the
previous state ofthe art.
Thecompletecodeofourapproach,includingsubjectsandex-
perimental data,isavailable as aself-containedJupyter notebook:
https://github.com/vrthra/mimidREFERENCES
[1][n.d.]. TheCodeproject. https://www.codeproject.com/Articles/88435/Simple-
Guide-to-Mathematical-Expression-Parsing .
[2][n.d.].HomeoftheInternationalCommunityinterestedinGrammaticalInference.
https://grammarlearning.org .
[3] [n.d.]. JSONParser. https://github.com/HarryDC/JsonParser .
[4] [n.d.]. LispParser. https://hackage.haskell.org/package/lispparser .
[5][n.d.]. Mathematical Expressions Parser. https://github.com/louisfisch/
mathematical-expressions-parser .
[6][n.d.]. Microjson ś a minimal JSON parser. https://github.com/phensley/
microjson .
[7] [n.d.]. MJS. https://github.com/cesanta/mjs .
[8] [n.d.]. TinyC. https://github.com/TinyCC/TinyCC .
[9][n.d.]. URLLibParser. https://github.com/python/cpython/blob/3.6/Lib/urllib/
parse.py.
[10]Dana Angluin. 1987. Learning Regular Sets from Queries and Counterexamples.
Inf. Comput. 75, 2 (Nov. 1987), 87ś106. https://doi.org/10.1016/0890-5401(87)
90052-6
[11]Dana Angluin and Michael Kharitonov. 1995. When Won’t Membership Queries
Help?J.Comput. SystemSci. 50,2 (1995), 336ś355.
[12]Cornelius Aschermann, Tommaso Frassetto, Thorsten Holz, Patrick Jauernig,
Ahmad-Reza Sadeghi, and Daniel Teuchert. 2019. NAUTILUS: Fishing for Deep
BugswithGrammars.In TheNetworkandDistributedSystemSecuritySymposium .
[13]GuangdongBai,JikeLei,GuozhuMeng,SaiSathyanarayanVenkatraman,Prateek
Saxena,JunSun,YangLiu,andJinSongDong.2013. AUTHSCAN:AutomaticEx-
traction of Web Authentication Protocols from Implementations. In The Network
and DistributedSystemSecuritySymposium . The Internet Society.
[14]Osbert Bastani, Rahul Sharma, Alex Aiken, and Percy Liang. 2017. Synthesiz-
ing Program Input Grammars. In ACM SIGPLAN Conference on Programming
Language Designand Implementation . ACM,NewYork, NY, USA,95ś110.
[15]Tim Blazytko, Cornelius Aschermann, Moritz Schlögel, Ali Abbasi, Sergej Schu-
milo, Simon Wörner, and Thorsten Holz. 2019. GRIMOIRE: Synthesizing
Structure while Fuzzing. In 28th USENIX Security Symposium (USENIX Secu-
rity 19). 1985ś2002. https://www.syssec.ruhr-uni-bochum.de/media/emma/
veroeffentlichungen/2019/06/03/grimoire.pdf
[16]Guillaume Bonfante, Jean-Yves Marion, and Thanh Dinh Ta. 2014. Malware
Message Classification by Dynamic Analysis. In Foundations and Practice of
Security-7thInternationalSymposium,FPS2014,Montreal,QC,Canada,November
3-5, 2014. Revised Selected Papers (Lecture Notes in Computer Science) , Frédéric
Cuppens, Joaquín García-Alfaro, A. Nur Zincir-Heywood, and Philip W. L. Fong
(Eds.),Vol.8930.Springer,112ś128. https://doi.org/10.1007/978-3-319-17040-4_8
[17]SergeyBratus,LarsHermerschmidt,SvenM.Hallberg,MichaelE.Locasto,Falcon
Momot,MeredithL. Patterson,and AnnaShubina.2017. Curing the Vulnerable
Parser:Design Patterns for SecureInput Handling. ;login:42(2017).
[18]Juan Caballero, Heng Yin, Zhenkai Liang, and Dawn Song. 2007. Polyglot: Auto-
maticExtractionofProtocolMessageFormatUsingDynamicBinaryAnalysis.
InACM Conference on Computer and Communications Security . ACM, New York,
NY, USA,317ś329. https://doi.org/10.1145/1315245.1315286
[19]Pierre Chifflier and Geoffroy Couprie. 2017. Writing parsers like it is 2017. In
2017IEEE Securityand Privacy Workshops (SPW) . IEEE,80ś92.
[20]PaoloMilaniComparetti,GilbertWondracek,ChristopherKruegel,andEngin
Kirda.2009. Prospex:ProtocolSpecificationExtraction.In IEEESymposiumon
Security and Privacy . IEEE Computer Society, Washington, DC, USA, 110ś125.
https://doi.org/10.1109/SP.2009.14
[21]WeidongCui,MarcusPeinado,KarlChen,HelenJ.Wang,andLuisIrun-Briz.2008.
Tupni: Automatic ReverseEngineeringof InputFormats. In ACM Conference on
Computer and Communications Security . ACM,NewYork, NY, USA,391ś402.
[22]ColinDe laHiguera.2010. Grammatical inference: learning automata andgram-
mars. CambridgeUniversityPress.
[23]Jean-Christophe Deprez and Arun Lakhotia. 2000. A Formalism to Automate
Mapping from ProgramFeaturesto Code.. In IWPC. 69ś78.
[24]KexinPeiDongdongShi.2019. NEUZZ:EfficientFuzzingwithNeuralProgram
Smoothing. IEEE S&P (Jan. 2019). http://par.nsf.gov/biblio/10097303
[25]HenningFernau.2009. Algorithmsforlearningregularexpressionsfrompositive
data.Informationand Computation 207, 4 (2009), 521ś541.
[26]HugoGascon,ChristianWressnegger,FabianYamaguchi,DanielArp,andKonrad
Rieck. 2015. Pulsar: Stateful black-box fuzzing of proprietary network protocols.
InInternationalConferenceonSecurityandPrivacyinCommunicationSystems .
Springer, 330ś347.
[27]PatriceGodefroid,AdamKiezun,andMichaelY.Levin.2008. Grammar-based
WhiteboxFuzzing.In ACMSIGPLANConferenceonProgrammingLanguageDesign
and Implementation . ACM,NewYork, NY, USA,206ś215.
[28]PatriceGodefroid,HilaPeleg,andRishabhSingh.2017. Learn&Fuzz:Machine
LearningforInputFuzzing.In Proceedingsofthe32ndIEEE/ACMInternational
ConferenceonAutomatedSoftwareEngineering(ASE2017) .IEEEPress,Piscataway,
NJ, USA,50ś59. http://dl.acm.org/citation.cfm?id=3155562.3155573
182ESEC/FSE ’20, November8–13,2020,VirtualEvent, USA RahulGopinath, Björn Mathis, Andreas Zeller
[29]BenediktHauptmann,ElmarJuergens,andVolkmarWoinke.2015. Generating
refactoring proposals to remove clones from automated system tests. In Proceed-
ings of the 2015 IEEE 23rd International Conference on Program Comprehension .
IEEE Press,115ś124.
[30]JeffreyHeinz, Colin De la Higuera, andMenno Van Zaanen.2015. Grammatical
inferenceforcomputationallinguistics. SynthesisLecturesonHumanLanguage
Technologies 8,4 (2015), 1ś139.
[31]JeffreyHeinzandJoséMSempere.2016. Topicsingrammaticalinference .Vol.465.
Springer.
[32]Christian Holler, Kim Herzig, and Andreas Zeller. 2012. Fuzzing with Code
Fragments. In Proceedings of the 21st USENIX Conference on Security Symposium
(Security’12) . USENIX Association, Berkeley, CA, USA, 38ś38. https://www.
usenix.org/system/files/conference/usenixsecurity12/sec12-final73.pdf
[33]Matthias Höschele and Andreas Zeller. 2016. Mining Input Grammars from
DynamicTaints.In IEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering . ACM,NewYork, NY, USA,720ś725.
[34]H.Hungar,T.Margaria,andB.Steffen.2003. Test-basedmodelgenerationfor
legacy systems. In International Test Conference, 2003. Proceedings. ITC 2003. ,
Vol. 2.150ś159Vol.2. https://doi.org/10.1109/TEST.2003.1271205
[35]Clinton L Jeffery. 2003. Generating LR syntax error messages from examples.
ACMTransactionsonProgrammingLanguagesandSystems(TOPLAS) 25,5(2003),
631ś640.
[36]Trevor Jim and Yitzhak Mandelbaum. 2010. Efficient Earley parsing with regular
right-handsides. ElectronicNotesinTheoreticalComputerScience 253,7(2010),
135ś148.
[37]LukasKirschner,EzekielO.Soremekun,andAndreasZeller.2020. Debugging
Inputs.In InternationalConference onSoftwareEngineering . ACM.
[38]Nicolas Laurent and Kim Mens. 2016. Taming context-sensitive languages with
principledstatefulparsing.In Proceedingsofthe2016ACMSIGPLANInternational
Conference onSoftwareLanguage Engineering . ACM,15ś27.
[39]Zhiqiang Lin and Xiangyu Zhang. 2008. Deriving Input Syntactic Structure
from Execution. In ACM SIGSOFT Symposium on The Foundations of Software
Engineering . ACM,NewYork, NY, USA,83ś93.
[40]Zhiqiang Lin, Xiangyu Zhang, and Dongyan Xu. 2010. Reverse Engineering
Input Syntactic Structure from Program Execution and Its Applications. IEEE
TransactionsonSoftware Engineering 36,5(Sept.2010),688ś703. https://doi.org/
10.1109/TSE.2009.54
[41]BjörnMathis,RahulGopinath,MichaëlMera,AlexanderKampmann,Mathias
Höschele, and Andreas Zeller. 2019. Parser Directed Fuzzing. In ACM SIGPLANConference on Programming Language Design and Implementation . ACM, New
York, NY, USA.
[42]GhassanMisherghiandZhendongSu.2006. HDD:hierarchicalDeltaDebugging.
Proceedings - International Conference on Software Engineering 2006, 142ś151.
https://doi.org/10.1145/1134307
[43]F.Momot,S.Bratus,S.M.Hallberg,andM.L.Patterson.2016. TheSevenTurrets
of Babel: A Taxonomy of LangSec Errors and How to Expunge Them. In 2016
IEEECybersecurityDevelopment(SecDev) .45ś52. https://doi.org/10.1109/SecDev.
2016.019
[44]VáclavRajlichandNormanWilde.2002. Theroleofconceptsinprogramcompre-
hension.In Proceedings10thInternationalWorkshoponProgramComprehension .
IEEE,271ś278.
[45]MohitRajpal,WilliamBlum,andRishabhSingh.2017. Notallbytesareequal:
Neural byte sieve for fuzzing. CoRRabs/1711.04596 (2017). arXiv: 1711.04596
http://arxiv.org/abs/1711.04596
[46]AndrewStevensonandJamesR.Cordy.2014. ASurveyofGrammaticalInference
inSoftwareEngineering. ScienceofComputerProgramming 96,P4(Dec.2014),
444ś459. https://doi.org/10.1016/j.scico.2014.05.008
[47]Neil Walkinshaw, Kirill Bogdanov, Mike Holcombe, and Sarah Salahuddin. 2007.
ReverseEngineeringStateMachines byInteractive GrammarInference.In Work-
ing Conference on Reverse Engineering . IEEE Computer Society, Washington, DC,
USA,209ś218. https://doi.org/10.1109/WCRE.2007.45
[48]Zhengkai Wu,Evan Johnson, WeiYang, OsbertBastani, Dawn Song, Jian Peng,
andTaoXie.2019. REINAM:reinforcementlearningforinput-grammarinference.
InACMSIGSOFTSymposiumonTheFoundationsofSoftwareEngineering .488ś498.
https://doi.org/10.1145/3338906.3338958
[49]AndreasZeller,RahulGopinath,MarcelBöhme,GordonFraser,andChristian
Holler.2019. CodeCoverage. In GeneratingSoftwareTests .SaarlandUniversity.
https://www.fuzzingbook.org/html/Coverage.html
[50]AndreasZeller,RahulGopinath,MarcelBöhme,GordonFraser,andChristian
Holler. 2019. Efficient Grammar Fuzzing. In Generating Software Tests . Saarland
University. https://www.fuzzingbook.org/html/GrammarFuzzer.html
[51]AndreasZeller,RahulGopinath,MarcelBöhme,GordonFraser,andChristian
Holler. 2019. Mining Input Grammars. In Generating Software Tests . Saarland
University. https://www.fuzzingbook.org/html/GrammarFuzzer.html
[52]AndreasZeller,RahulGopinath,MarcelBöhme,GordonFraser,andChristian
Holler.2019. ParsingInputs. In GeneratingSoftwareTests .SaarlandUniversity.
https://www.fuzzingbook.org/html/GrammarFuzzer.html
183