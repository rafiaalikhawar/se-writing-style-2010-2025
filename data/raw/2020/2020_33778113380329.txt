Debugging Inputs
Lukas Kirschner
CISPA – Helmholtz Center for
Information Security
Saarbrücken, Germany
s8lukirs@stud.uni-saarland.deEzekiel Soremekun
CISPA – Helmholtz Center for
Information Security
Saarbrücken, Germany
ezekiel.soremekun@cispa.saarlandAndreas Zeller
CISPA – Helmholtz Center for
Information Security
Saarbrücken, Germany
zeller@cispa.saarland
ABSTRACT
Whenaprogramfailstoprocessaninput,itneednotbethepro-
gramcodethatisatfault.Itcanalsobethattheinputdataisfaulty,
for instance as result of data corruption. To get the data processed,
one then has to debug the input data —that is, (1) identifywhich
parts of the input data prevent processing, and (2) recoveras much
of the (valuable) input data as possible. In this paper, we present a
general-purpose algorithm called ddmaxthat addresses these prob-
lemsautomatically.Throughexperiments, ddmaxmaximizesthe
subset of the input that can still be processed by the program, thus
recoveringandrepairingasmuchdataaspossible;thedifference
between the original failing input and the “maximized” passing
input includes all input fragments that could not be processed. To
thebestofourknowledge, ddmaxisthefirstapproachthatfixes
faults in the input data without requiring program analysis. In our
evaluation, ddmaxrepaired about 69% of input files and recovered
about 78% of data within one minute per input.
1 INTRODUCTION
In the last decade, techniques for automated debugging and repair
have seen great interest in research and practice. A recent sur-
vey [54] lists more than 100 papers on automatic fault localization
andrepair.Recently,socialnetworkinggiantFacebookprovidedde-
velopers with automatically generated repair suggestions for every
failure report of its apps [ 37]. Almost all of these techniques focus
onprogramcode, attemptingtoidentifypossiblefaultlocationsin
thecodeandsynthesizingfixesforthiscode.However,whenapro-
gramfailsonsomeinput,itneednotbetheprogramcodethatisat
fault. Hardware failures, hardware aging, transmission errors may
allcausedatatogetcorrupted.Incomputerhardware,radiationcan
impact memory cells, leading to bit flips and again data corruption.
And finally, data can be corrupted through software bugs, with the
processingsoftwarewritingoutmalformedorincompletedata.If
data is corrupted, the easiest remedy is to use a backup. But if abackupdoesnotexist(oristooold,orfailstobeprocessed),onemay want to recover as much data as possible from the existing
data—or in other words, debug the data.
Someprogramscomewithapplication-specificmeanstorecover
data. Input parsers can recover from syntactical errors by apply-
ing sophisticatedrecovery strategies; in aprogramming language,
this may involve skipping the current statement or function and
Publication rights licensed to ACM. ACM acknowledges that this contribution was
authoredor co-authoredbyanemployee, contractororaffiliateof anationalgovern-
ment.Assuch,theGovernmentretainsanonexclusive,royalty-freerighttopublishor
reproduce this article, or to allow others to do so, for Government purposes only.
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
© 2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-7121-6/20/05...$15.00
https://doi.org/10.1145/3377811.3380329{"item":"Apple","price":**3.45}
Figure 1: Failing JSON input
{
Figure 2: Failing input reduced with ddmin
{"item":"Apple","price":3.45}
Figure 3: Failing input repaired with ddmax
**
Figure 4: Difference between failing and repaired input
resuming with the next one [ 23]. When detecting a corrupted or
incomplete file, Microsoft Office programs may attempt to recover
from the error, using a number of undisclosed approaches [ 52].
When a program does notimplement a good recovery strategy,
though, usersare leftto their owndevices, usinggeneral-purpose
editors to identify file contents and possible corrupted parts.
As listed above, general-purpose automated debugging tech-
niques focus on faults in code and do not provide much help in
suchsituations,astheywouldregularlyidentifytheinputparser
and its error-handling code as being associated with the fault. The
deltadebugging (ddmin)algorithm[56], however, focusesoniden-
tifying error causes in the input; in repeated runs with reduced
inputs,itsimplifiesafailure-inducinginputdowntoaminimum
thatreproducestheerror.Unfortunately,deltadebuggingisnota
goodfit:appliedtoinvalidinputs,itproducesthesmallestsubset
of the input that also produces an input error—typically a singlecharacter.Asanexample,considerFigure1,aJSONinputwithasyntax error; ddminproduces the reduced input in Figure 2, con-
sisting ofa single {character, whichalso producesa syntax error.
This is neither helpful for diagnosis nor a basis for data recovery.
In this paper, we introduce a generic input repair method that
automatically (1) identifies which parts of the input data prevent
processing, and (2) recoversas much of the (valuable) input data
as possible. Like ddmin, our approach runs the program under test
repeatedlywithdifferentsubsetsoftheinput,assessingwhetherthe subset can be processed or not. Also, it does not need anykind of program analysis and can thus be used in a wide range
of settings. Unlike ddmin, however, which aims at minimizing the
failure-inducinginput,our ddmaxalgorithmaimsat maximizing
752020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)
thepassinginput.Itsresultisasubsetoftheinputthat(1)canbe
successfully processed and (2) is 1-maximal: no further element
from the failing input can be added without causing the input to
become invalid again.
Applied on our example from Figure 1, ddmaxproduces the “re-
paired”(passing)inputsubsetinFigure3,inwhichtheconfounding
**characters (and nothing else) are removed. The difference be-
tweentheoriginalinput(Figure1)andtherepairedinput(Figure3),
listed in Figure 4, actually makes a precisediagnosis of the failure
cause and can be given to developers for further debugging steps.
Note that while ddmaxrecovers a maximum of data,it does
not recover a maximum of information ; in our example, we do not
know whether 3.45actually is the correct price. However, the
repaired input can now be read and processed by the programathand,enablinghumanstoreadandchecktheirdocumentand
engage into additional recovery steps.
Although, many applications produce error messages when pro-
cessinginvalidinputs,mosterrormesagesarevague.Often,applica-tionssimplyreportthataninputiscorrupted,withoutrepairingthe
inputorprovidingthereasonfortheinvalidity.However, ddmax
identifies the invalid input fragment quickly (for debuggers) while
also preserving a maximum of content (for end users).
The remainder of this paper makes the following contributions:
An empirical study of invalid inputs in practice. Weevaluate
the prevalence of invalid input in the wild (Section 2). We
crawled thousands of input files from githuband determine
the set of valid and invalid files. We find that invalid inputsare common in practice, about four percent (295 files) of all
input files (7835 files) crawled from github were invalid.
Generic input repair with minimal data loss. Weintroducethe
ddmaxalgorithm,automaticallyrecoveringamaximumof
datafromagivenfailure-inducinginput(Section 3).Tothe
bestofourknowledge, ddmaxisthefirstinputrepairtech-
niquethatcanbeappliedtoarbitraryinputsandprograms
without additional knowledge on input formats or program
code. In its evaluation on eight subjects and three input for-
mats, using real-world invalid inputs as well as synthetic
corruptions,wefindthat ddmaxiseffective:Itrepairs69%
ofcorruptedinputsandrecoversabout78%ofdata,withina
time budget of one minute per input.
An efficient syntactical input repair technique. Weintroduce
avariantof ddmaxthatmakesuseofa grammar toparsein-
putsintoderivationtreesandtomaximizeinputsbypruningpartsofthetreethatcouldnotberead(Section4);thisvastly
speedsupinput repair. In its evaluation, syntactic ddmaxis
faster and more efficient than the lexical variant.
Identifying faults in input data. Thedifferencebetweenthe“re-
paired”inputby ddmaxandtheoriginalinputcontainsall
parts of the input that prevented the data from being pro-
cessed in the first place. Section 5 shows that this difference
precisely characterizes the fault in the input.
Afterdiscussing limitations(Section6), threatstovalidity (Sec-
tion 7) and related work (Section 8), we close with conclusion and
future work (Section 9).Table 1: Subject Programs
Subject Input Prog. Size Maturity
Program Format Lang. (in KLOC) (1stCommit)
Blender OBJ C/C++ 1800 Jan. 1994
Assimp OBJ C++ 88.9 July 2002
Appleseed OBJ C++ 600.1 May 2009
JQ JSON C 20.2 July 2012
JSONSimple JSON Java 2.6 Nov. 2008
Minimal-JSON JSON Java 6.4 Feb. 2013
Graphviz DOT C 1140 Sep. 1991
Gephi DOT Java 166.1 July 2008
Table 2: Input Grammar Details
Grammar Size (LOC) #ParserRules #LexerRules
JSON 79 5 9
Wave. OBJ 271 13 42
DOT 181 14 15
2 PREVALENCE OF INVALID INPUTS
Before we start repairing inputs, let us first answer the question of
howrelevantthe problem is. Is it actually possible that some appli-
cationcannotopenadatafile?Andwouldtherebefilesclaiming
toadheretosomeformatifinfact,theyarenot?Toanswersuch
questions, let us go and catch some invalid inputs in the wild.
2.1 Evaluation Setup
Subject Programs. In this paper, we use eight programs as test
subjects,namely Blender[17],Assimp[5],Appleseed [43],JQ[15],
JSON-Simple [30],Minimal-JSON [51],Graphviz [47], and finally
Gephi[19].Eachinputformatwasevaluatedwiththreesubjects,
exceptfor DOTwhichwasevaluatedwithtwoprograms.Allour
subject programs are open source C,C++orJavaprograms. On
average, these programs have 478 KLOC and a maturity of over
14 years. Table 1 highlights the properties of our subject programs.
Grammars. Wehavecollectedthegrammarsforoursubjectsfrom
theANTLR Grammar repository [20]. We chose complex and large
grammarsfordata-richinputformatsusedintwopopulardomains,
namely graphics domain (i.e. Wave. OBJ and DOT) and data ex-
changedomain(i.e.JSON).Toensurethegrammarsweresound,we
testedthemwith50validcrawledfilesforeachinputformat.We
modified the Wavefront OBJ grammar since its ANTLR grammar
was only a subset of the official Wavefront OBJ specificiation [ 42].
TheJSONandDOTwereusedunmodifiedsincetheymatchedtheof-
ficialspecificiations[ 11,31].Onaverage,thegrammarsarewritten
in 177 LOC, with 11 parser rules and 22 lexer rules (cf. Table 2).
Mining and Filtering Input Files. Table 3 highlights the details
oftheinputfilesinourcorpus.Wecrawledforaspecificfileformat
usingthefileextension(e.g.“.json ”fortheJSONinputformat).In
total, we collected a corpus of 9544 input files (cf. #Crawled Files in
Table3)usingthe GithubAPI forcrawling[ 27].Then,wedeletedall
filesthatareemptyorduplicated,aswellastheinputfilesthathave
adifferentinputformatdespitehavingtheintendedfilenamesuffix
76Table 3: Mined Input Files
Input #Crawled #Unique #Valid #Invalid Cause of Invalidity (#files rejected by) Mean Valid Mean Invalid
Format Files Files Files Files Grammar ≥1 subject All subjects Size (KiB) Size (KiB)
JSON 8654 7006 6948 222 164 58 52 12.84 0.78
Wave. OBJ 509 480 455 25 02 5 0 401.57 64.15
DOT 381 349 303 48 24 6 4 4.74 2.88
(e.g. a Wavefront OBJ file has the same suffix “.obj” as a binary OBJ
filethatwascreatedbyacompiler).Thisresultedin7835unique
input files (cf. #Unique files ). We also separated files that contain
unsupportedgrammarextensions.Inparticular,forJSONandDOT,
weremoved166inputfiles(cf.#GrammarFiles )thatonlycontain
literals like a number or a string (e.g. which are invalid JSON [ 11])
andJSONfilesthatcontainmultipleJSONfilesappendedtoeach
other, as written by some programs.
To determine actual invalid input files (cf. #Invalid ), wefilter
out the valid input files from the set of unique files by checking
that (1) the file does not lead to a lexing/parsing error when parsed
byANTLRand (2) the file was successfully opened by all subject
programs (of the input format) without crashing (using the test
oracleinSection2.1).Intotal,7702inputfiles(cf.#ValidFiles )passed
the check of the filtering process and the remaining 295 input
filesrepresentoursetofreal-worldinvalidfiles(cf.#InvalidFiles ).
Exactly 166 inputs were rejected by ANTLR, this is shown in Table
3(cf. Cause of Invalidity: Grammar).
Test Oracle. In our setup, the test oracle forddmaxis acrashing
oracle.Aninputistreatedas invalidifitcrashesthesubjectprogram,
or the result of the subject is empty, or the subject takes more than
10 seconds to process the input1. A program run is considered a
crashifthesubjectprogramreturnsanon-zeroexitvalue.Evenifa
subjectreportsanerror,itisonlyconsideredacrashifitalsoreturns
a non-zero exit value. Opening a validfile, however, produces a
non-empty output after 10 seconds and does not crash the subject
program. The test oracle does not use ANTLR as an invalidity
criterium for (lexical) ddmax, because the goal is to repair an input
withfeedbackfromasubjectprogram,withouttheknowledgeof
the input grammar. Although, syntactic ddmaxemploys ANTLR
to build its initial AST, it does not obtain feedback from ANTLR
during repair, i.e. when the AST is being modified.
To automate tests, we ensure that all subject programs have a
fullcommand-lineinterface(CLI)supportora Java/Python API.
The test oracle was implemented in 890 LOC of Javaand 412 LOC
ofPythoncode.
2.2 Evaluation
RQ1: How prevalent are invalid inputs in practice? Invalid
input files are common. About four percent of all inputs in our
corpus(295files)wereinvalid(cf.Table3);theywereeitherrejectedbysubjectprogram(s)ortheinputgrammar.Specifically,abouttwo
percent of the input files (129 files) in our sample were rejected by
atleast onesubjectprogram;however, lessthan1%(56 files)were
rejected by allsubject programs in our evaluation setup.
1Thisexecutiontimeof10secondswasdeterminedasamaximumopeningtimeto
successfully process all valid input files in our evaluation corpus.A common cause of invalidity is wrong syntax, missing or non-
conforming elements. Many input files were invalid because of
single character errors, such as a deleted character, a missing char-
acteroranextraneouscharacter.Forinstance,someJSONinputs
wereinvalidduetodeletionsofcharacterssuchasquotes,paren-
thesesandbraces.Theseerrorsaredifficulttofindbecausetheyare
oftenhiddeninlargedocuments.Forexample,oursetofcrawled
OBJ files contained many files of about 300KiB with one corrupted
line(e.g.aninvalidcharacterinsidea“usemtl”statement).Tofix
suchanerrorbyhand,onewouldhavetoscrollthroughthousands
of lines of code and find this single corrupted character. Other
sourcesofinvalidityincludetheadditionofelementsthatdonot
conformwiththeinputspecification.SomeJSONfilescontainedcomments that begin with the "$" character. Comments are notpermitted in JSON, however, this was common practice in some
JSON files and a few parsers support comments (e.g. Google Gson).
In our sample of GitHub files, four percent could not be processed
either by the input grammar or at least one subject program.
3 LEXICAL REPAIR
Now that we have established that there are actually files that
cannotbeproperlyparsedoropened,letusintroducethe ddmax
algorithm for recovering and repairing invalid input. ddmaxworks
on a character-by-character basis; we thus call it lexical ddmax .
3.1 Delta Debugging
Ourddmaxtechnique can be seen as a variation on the minimizing
delta debugging algorithm, a technique for automatically reducing
failure-inducing inputs by means of systematic tests. The reduction
problemis modeled as follows: Configurations consisting of indi-
vidual(input)elementswhichmayormaynotbepresent.There
are two configurations: a passing configuration cand afailing
configuration c. The passing configuration ctypically stands for
an empty or trivial input ( c=∅), and the failing configuration
c⊃cstands for the failure-inducing input in question. In our
example from Section 1, the failing configuration would be
c={"item":"Apple","price":**3.45}(1)
Zelleretal.[ 56]definethe ddminalgorithmasfollows. ddmin
producesoneset c/prime
withc⊂c/prime
⊆c,wherec/prime
hasaminimalsize
overall. It works by testing sets c/primethat liebetweencandc(i.e.,
c⊆c/prime⊆c). A test involves running the original program on the
newlysynthesizedinput c/prime.Theoutcome test(c/prime)ofthetest—either
(passing), (failing),or (unresolved)—determinesalgorithm
progress: Whenever a subset c/prime⊆cfails (test(c/prime)=),ddmin
further narrows down the difference between c/primeandc.I no u r
77Maximizing Delta Debugging Algorithm
Lettestandcbe given such that test(∅)=∧test(c)=hold.
The goal is to find c/prime
=ddmax(c)such that c/prime
⊂c,test(c/prime
)=, and Δ=c−c/prime
is 1-minimal.
Themaximizing Delta Debugging algorithm ddmax( c)is
ddmax(c)=ddmax2(∅,2)where
ddmax2(c/prime
,n)=⎧⎪⎪⎪⎪⎪ ⎨
⎪⎪⎪⎪⎪⎩ddmax
2(c−Δi,2) if∃i∈{1,...,n}·test(c−Δi)=(“increase to complement”)
ddmax2/parenleftbigc/prime
∪Δi,max(n−1,2)/parenrightbigelse if ∃i∈{1,...,n}·test(c/prime
∪Δi)=(“increase to subset”)
ddmax2/parenleftbigc/prime
,min(|c|,2n)/parenrightbigelse ifn<|c−c/prime
|(“increase granularity”)
c/prime
 otherwise (“done”).
where Δ=c−c/prime
=Δ1∪Δ2∪···∪ Δn, allΔiare pairwise disjoint, and ∀Δi·|Δi|≈|c−c/prime
|/nholds.
The recursion invariant (and thus precondition) for ddmax2istest(c/prime
)=∧n≤|Δ|.
Figure 5: Maximizing Lexical Delta Debugging algorithm
example from Section 1, Figure 2 shows a typical ddminoutputc/prime
:
The one character in the input suffices to cause the (syntax) error.
Whenchoosinganewcandidate c/prime,ddmininitiallysplitsthesets
to be tested in half; as long as tests always pass or fail, this is as
efficient as a binary search. If tests are unresolved (say, because
the input is invalid), ddminresorts to cutting quarters, eighths, six-
teenthsoftheinput(ddmin ).Eventually, ddmintestseachremaining
element (character) for its relevance in producing the failure.
3.2 The ddmaxAlgorithm
Our definition of ddmaxis shown in Figure 5. ddmaxuses the
samesettingas ddmin;however,ratherthan minimizing thefailure-
inducinginput c,itstartswithapassinginput c/prime
=c;likeddmin,
it assumes for simplicity that c=∅holds. It then maximizes c/prime
,
systematically minimizing the difference between c/prime
andcusing
thesametechniquesas ddmin(firstprogressingwithlargediffer-
ences, then smaller and smaller differences), until every remaining
difference would cause c/prime
to fail. This makes ddmaxact in exact
symmetryto ddmin,andcomplementstheoriginaldefinitionsof
ddandddmin[56].
3.3 AddmaxExample
How does ddmaxwork? Let us illustrate it on the example from
Section1.Wehave cdefinedasinEquation(1),above,andevaluate
ddmax(c)to obtain c/prime
, the maximal subset of cthat passes the
test (i.e., that can be still be processed by our JSON application
at hand). We now invoke ddmax(c)and getddmax2(∅,2)—that is,
c/prime
=∅andn=2.The set c/prime
willcontinually holdmoreand more
characters, and nwill hold the current granularity.
ddmax2determines Δ=c−c/prime
=c−∅=c, and splits it into
two parts Δ1∪Δ2=Δ:
Δ1="price":**3.45}
Δ2={"item":"Apple",
Aspartof“increasetocomplement”, ddmax2firsttests c−Δ1
(which is Δ2) and then c=Δ2(which is Δ1). Neither of both is
a valid JSON input, hence the tests do not pass. In “increase tosubset”, the sets to be tested are
c/prime
∪Δ1=(∅ ∪Δ1)=Δ1andc/prime
∪Δ2=(∅∪Δ2)=Δ2;wealreadyknowthatthesetestsdonot
pass. Hence, we “increase granularity” and double nton=4.
Withn=4, we now split Δinto four parts Δ1∪···∪ Δ4=Δ:
Δ1={"item": Δ2="Apple",
Δ3="price": Δ4=**3.45}
In “increase to complement”, the tests run on the failing set c
withoutthe individual Δi—that is:
c−Δ1="Apple","price":**3.45}
c−Δ2={"item":"price":**3.45}
c−Δ3={"item":"Apple",**3.45}
c−Δ4={"item":"Apple","price":
None of these inputs is syntactically valid JSON, and no test
passes; so ddmaxfurther increases granularity to n=8. In this
round,againnoneofthe Δipass;butoneofthecomplementsdoes:
c−Δ6={"item":"Apple","price":45}
with Δ6=**3.
Thesetc−Δ6isindeedasyntacticallyvalidJSONinput,and
test(c−Δ6)passes(“increasetocomplement”).Atthispoint,we
have recovered31
36=86% of the input data already.
Canweaddmorecharacters?Followingthe ddmaxdefinition,we
reinvokeddmax2withc/prime
=c−Δ6.Now,theremainingdifference
between c/prime
andcisΔ6as above. We restart with n=2 and
decompose the remaining Δ=c−c/prime
=Δ6intoΔ61andΔ62:
Δ61=** Δ62=3.
Now,c−Δ61passes, yielding the syntactically correct input:
c−Δ61={"item":"Apple","price":3.45}
A further iteration will also recover the space character before the
number, eventually yielding the repaired input in Figure 3 and the
remaining difference Δin Figure 4.
The example demonstrates two important properties of ddmax:
78Corrupted
filessyntactic
ddmax
lexicalddmaxParse TreeANTLRGrammar
Repaired
File
Subject
ProgramDifferencing Size Change
LevenshteinP-Hash
MutateValid
crawled Files
ddminReal-World
invalid filesSize ChangeFilterAll
crawled filesTest Driver
Delta-DebuggingANTLR
23
4 56
7
81
Figure 6: Workflow of the ddmaxevaluation
•ddmaxisthorough. Itsresultc/prime
is1-maximal —thatis,adding
any further character from cwill no longer pass. Formally,
this means that ∀δi∈c−c/prime
·test/parenleftbigc/prime
∪{δi}/parenrightbig/nequalholds.2
•ddmaxcan beslow. The complexity ofddmaxis the same as
ddmin—in the worst case, the number of tests carried out
byddmax(c)is|c|2+3|c|;andinthebestcase—ifthereis
only one failure-inducing change Δi∈c, and all cases that
donotinclude Δipass, then the number of tests tis limited
byt≤2log2(|c|).
In practice, as with ddmin, things will be somewhere be-
tween the two extremes; but keep in mind that at maximum
granularity, ddmaxrunsatleast |c−c/prime
|tests—thatis,one
testfor everycharacter thatpossibly stillcouldbe restored.
With these properties, what we get with ddmaxis an algorithm
that guarantees a maximum of data recovery, albeit at the price of
possibly running a large number of tests.
3.4 Evaluation Setup
Workflow. Figure6showstheworkflowofourevaluation.First,
wecollectreal-worldinvalidinputfilesfromthesetof crawledfiles,
accordingtoSection2.Thosefilesarethenfilteredintoasetofvalidfilesandasetofinvalidfiles(Step.1)andduplicatesandfileswitha
wrong format are deleted. Secondly, we select and mutate 50 valid
crawled files to produce an additional set of corrupted input files
(Step. 2). Then, we feed a invalid file to eachsubject program, and
theANTLRparser framework (Step. 3). ANTLRexecutes its default
errorrecoverystrategy whilegeneratingaparsetreefortheinput.
Next, we feed the invalid file to lexical ddmax (Step. 4). Lexical
ddmaxteststheinputunderrepairrepeatedlyusingthefeedback
from the subject program (Step. 5). Then, we feed the original
crawled files and the resulting repaired file from each technique to
thedifferencing framework (Step. 6), which computes the change in
filesize,Levenshteindistance andperceptivehashvalue forbothfiles.
Wesavethefeedbackfromoursubjectprogram(Step.7).Finally,
2Both maximality and complexity properties are proven in a way analogous to the
properties of ddminin [56].to ensure the quality of our approach, we also execute ddminon
thereal-worldinvalidinputs(Step.8)andreportthecontentand
size of the result.
Lexicalddmax wasimplementedin595LOCof Javacode.ANTLR
also implements an inbuilt error recovery strategy which is de-
signedtorecoverfromlexingorparsingerrors(e.g.missing/wrong
tokens or incomplete parse trees) [28].
Mutations. In addition to the real-world invalid inputs (cf. Sec-
tion 2), we also simulate real-world data corruption by applying
byte-level mutations on valid input files. These mutations were
chosen because they are similar to the corruptions observed in
real-worldinvalidfiles(seeSection2andSection5).Weperformthe
followingmutationsatarandompositionineachvalidinputfile:
byte insertion, byte deletion andbyte flip. To simulate single data
corruption, we randomly choose one of these mutations and apply
it once on the valid input file. For multiple data corruptions,w e
perform up to 16 random mutations on each input file. A mutation
isonlysuccessful(foraninputformat),if atleastoneofthesubject
programs(thatpassesbefore)failsafterthemutation.Thesecriteria
is similar to how we collected invalid input files in the wild.
MetricsandMeasures. Inordertodeterminethequalityof ddmax
repair, we use the following metrics and tools:
(1)FileSize: Wemeasurethe filesizeoftheinputsrecovered
byddmaxand thedifference in file size between the original
validinput andtherepairedfile.Weusethesemeasurements
to account for the amount of data recovered by ddmaxas
well as the amount of data loss incurred.
(2)Levenshtein Distance: Additionally, we measure data loss
usingtheLevenshteindistancemetric[ 34],measuringthe
edit distance betweenvalid input andrepaired file.
(3)PerceptiveImageDifference: Inordertomeasurethe (se-
mantic) information loss incurred by ddmax, we calculate
thehashvalueofour3Dimages,i.e. Wavefront OBJ format.
Wecomputetheimagedistanceofour3Dimagefilesbyren-
dering both the repaired image and the original valid image
79intoseveral2Dimagesfromthreedifferentcameraangles
andthreescales,thenmeasuringthe2Dimagedistanceof
all nine images. We compare these images using the Python
ImageHash library [7]inordertoobtainagoodapproxi-
mationoftherealimagedifferencebetweenthosetwo3D
modelsasa perceptiveimagedifference betweenbothimages.
In our setup, we use two rendering engines (Blender [ 17]
and Appleseed [43]) to render the images.
ResearchProtocol. For eachinput format,we collectreal-world
invalidinputfiles.Secondly,weperformsingleandmultiplemu-
tationson50validinputdocuments.Then,weexecuteallfileson
thedifferentsubjectprograms,inordertodeterminethenumber
of input files which fail for each subjectprogram. We proceed to
runlexical ddmax on each invalid or mutated input file. In particu-
lar,weareinterestedindeterminingthefollowing:(1.) Baseline:
thenumberofinvalidinputfileswhichareacceptedbyasubject
program as valid inputs (i.e. non-failure-inducing inputs processed
bytheprogramwithoutleadingtoacrash),inordertomeasurethe
effectiveness of the built-in error recovery feature of the program;
and(2.)ANTLR: thenumber ofinvalid inputswhichare repaired
byANTLRinbuilt errorrecoverystrategy ;(3)Lexical:thenumber
of invalid inputs which are repaired by lexical DDMax.
All experiments were conducted on a Lenovo Thinkpad with
fourphysicalcoresand 8GBofRAM,specificallyanIntel(R)Core
i72720qm@2.20GHz,8virtualcores,running64-bitArchLinux.
All our prototypes are single-threaded.
3.5 Evaluation
 0 50 100 150 200 250 300 350 400
Baseline ANTLR Lex. ddmax Syn. ddmax# Repaired Input Files
TechniquesReal-World Invalid Inputs
Single MutationsMultiple Mutations
Figure 7: Number of Repaired Files for Each Technique
RQ2: How effective is lexical ddmax in repairing invalid in-
putdocumentswithinatimebudgetofoneminuteperfile?
Lexical ddmax repaired about two-thirds (66%) of all invalid inputs
(cf.Table4).Italsooutperformedboththein-builtrepairstrategy
ofthesubjectprograms(Baseline )andtheANTLRerrorrecovery
strategy(ANTLR ),bothofwhichrepaired14%and40%ofallinvalid
input files respectively. Specifically, lexical ddmax repaired over
four times as many invalid input files as the Baselineand 66% more
invalidinputfilesthanANTLR(cf.Figure7).Theperformanceof
lexical ddmax was significantly better for both all mutations.Table 4:ddmaxEffectiveness on All Invalid Inputs
Invalid. Format #Possible # repaired input files
Type (#subjects) Repairs Base. ANTLR Lex. Syn.
Real
WorldJSON (3) 167 04 0 3 8 6 2
OBJ (3) 33 1 8 24 25
DOT (2) 6424 25 30 31
Single
Mut.JSON (3) 150 4 80 115 127
OBJ (3) 150 34 82 146 144
DOT (2) 100 43 66 92 82
Multiple
Mut.JSON (3) 150 4 45 79 112
OBJ (3) 150 3 29 127 126
DOT (2) 100 40 47 51 63
Total (3) 1064 153 422 702 772
 0 50 100 150 200 250
real single mult. real single mult. real single mult. real single mult.File Size (KB)
Techniquesmean_data_recovered
mean_data_loss
Syn.ddmax Lex.ddmax ANTLR Baseline
Figure 8: Data Recovered and Data Loss for all Inputs
Lexical ddmax repaired about two-thirds of all invalid inputs and
significantly outperforms both the basline and ANTLR.
RQ3:Howmuchdatais recovered bylexicalddmax andhow
much is the data loss incurred by lexical ddmax ?In terms
of recovery rate, lexical ddmax performs slightly worse than the
other techniques, with a recovery rate of 75% on real-world invalid
inputs,86%onsingledatacorruption,andabout43%onmultiple
data corruption (see Figure 8). For both types of data invalidity, the
baselineandANTLRmaintain an almost perfect data recovery rate
(approximately 100%).
Lexicalddmax recovered most (75% and 65%) of the data in
real-world invalid inputs and mutated input files respectively.
Intheory, lexical ddmax isguaranteedtoensureminimaldata
loss for all repairs. However, due to large file sizes and timeout
constraintsinourexperimentalsetup, lexical ddmax oftenhaltsbe-
fore the maximal valid data is recovered. In our experiment, lexical
ddmaxhadtimedoutfor163inputfilesduringrepair.Inorderto
inspect the data recovery rate of each approach in a more balanced
setting, we examined the set of input files that were repaired bybothANTLRandlexical ddmax , beforelexical ddmax timed out.
In total, 109 repairs were accomplished by both lexical ddmaxand
80Table5:ddmaxEfficiencyonAllInvalidInputsforeachtech-
nique (A) Baseline, (B) ANTLR, (C) Lexical ddmax, (D) Syn-
tacticddmax.
Invalid. Inp. Runtime (sec.) #Runs
Type Form AB C D CD
Real
WorldJSON 2 2 1227 153 341525 6029
OBJ44 47 2065 1279 6253 3164
DOT48 166 3828 3018 2783 1162
Single
Mut.JSON 4 4 1584 1065 45651 129659
OBJ491 672 6151 4083 3809 1352
DOT58 60 1239 1244 6077 4565
Multiple
Mut.JSON10 10 5903 2153 1194577 448801
OBJ624 728 9938 8132 8577 5043
DOT60 60 3365 2241 34876 11956
Mean 153 200 3981 2624 72296 70049
ANTLR,beforeatimeout.Thedatalossof lexical ddmax isminimal
and comparable to ANTLR, this holds for bothsingle and multiple
datacorruptionfortheintersectingsetbeforetimeout.Infact,on
average,lexical ddmax recovered 1.724 KiB of data, and ANTLR
recovered 1.548 KiB.
Overall, lexical ddmax incurs minimal data loss during repair: It
recovers similar amount of data from invalid input files, in
comparison to ANTLR.
RQ4: How efficient islexical ddmax in repairing invalid in-
put documents? Onaverage,ittooklessthantwominutes(1.3
minutes)torepairafile(cf.Figure13).Incomparison,boththe Base-
lineandANTLRhadanexecutiontimeof3and4secondsperinput
file respectively. This indicates that lexical ddmax is more time-
consuming than both the BaselineandANTLR. This is expected
sinceddmaxrequires multiple executions of the subject programs
(as indicated in lexical #Runs in Table 5).
Lexicalddmaxisrelativelyfastinrepairinganinvalidinputfile:it
takes less than two minutes (78 seconds) on average.
4 SYNTACTIC REPAIR
We have seen that ddmaxis general, but also slow:If one wants to
recoveramaximumofdata,itrunsasingletestforeverycandidate
character that can be recovered. Is it possible to s peed things up,
possiblybyleveraginginformationontheinputformat?Tothisend,
weintroducethe syntactic ddmax algorithm,whichimprovesthe
performance of ddmaxusing the knowledge of the input grammar.
The key insight is to execute ddmaxon theparse tree of the
input,insteadoftheinputcharacters.Here,weanalyzetheinput
at the syntactical level, rather than the lexical level. This improves
the runtime and general performance of the ddmaxalgorithm. The
mainbenefitoftheapproachisthatitenables ddmaxtoreasonata
more coarse-grained level by testing on the input structure. Lexical
ddmaxmaytakethousandsoftestruns,dependingonthesizeofthe
input,infactitsnumberofrunsisboundtothenumberofcharacters
in the input. However, syntactic ddmax is bound to the numberof
terminal nodes in the parsetree, which is typically smallerthan thenumberofcharactersintheinput.Thus, syntacticddmax caneasily
exclude corrupted parse tree nodes or subtrees during test runs.
Additionally, the knowledge of the input structure ensures that the
resulting recovered inputs are syntactically valid. This helps in the
case of syntax errors, large corrupted input region(s) and multiple
data corruptions on the input (structure).
{"item":"Apple","price"3.45}
Figure 9: Failing JSON input with missing colon
Specifically,thesyntactic ddmaxalgorithmtakesasinputa parse
treefor the corrupted input file (cf. Figure 11) and obtains a pre-
orderlistofterminalsintheparsetree.Forinstance,considerthe
corrupted JSON input in Figure 9. Repairing this input using the
lexical ddmax algorithm results in the JSON input in Figure 10,
whichwouldtakeover 100testruns.Evenforthissmallexample,
syntacticddmax enhancestheperformanceof ddmaxwiththeinput
grammar,reducingthenumberoftestrunsof ddmaxtonineand
improving performance by ten fold.
{"item":"Apple"}
Figure 10: Repaired JSON input by ddmax
Torepairtheinput(cf.Figure9),syntactic ddmaxfirstparsesthe
inputintoaparsetree3,showninFigure11.Next,werunthe ddmax
algorithmontheparsetree,removingterminalnodes(insteadof
single characters) in each iteration of ddmax4. We define cas our
failing configuration, which contains the terminal nodes of the
parse tree from Figure 11.
Let us run the ddmaxalgorithm on our example terminal nodes.
Weinvoke ddmax(c)whichresultsin ddmax2(∅,2),soinside ddmax2,
we havec/prime
=∅andn=2. At first, our Δis split into two parts5:
Δ1={"item":"Apple"
Δ2=,Error}
Runningtest(c−Δ1)andtest(c−Δ2)bothfail( =).Weareatthe
first run, so with c/prime
=∅,c/prime
∪Δ1=c−Δ2andc/prime
∪Δ2=c−Δ1
which also both fail in the “increase to subset” step. Next, we set
n=4 and restart ddmax2(c/prime
,n).
Withn=4, in the “increase to complement” and “increase to
subset” steps, we get
Δ1={"item" Δ2=:"Apple"
Δ3=,Error Δ4=}
3ANTLRis capable of generating a parse tree for corrupted input files, it summarizes
syntactically wrong symbols or trees into error nodes (similar to Figure 11).
4Removing only the error node in the parse tree does not necessarily result in a
non-failure-inducing input.
5Note that checking for only syntactically valid subsets of the programs (e.g. using
thegrammaronly)isnotsufficienttorepairtheinput.Weleveragetheapplication,
sincethe semanticsandintendeduse oftheinput fileareencodedin thelogicofthe
applcation.
81/angbracketleftJSON/angbracketright
{ /angbracketleftdict/angbracketright
/angbracketleftstring/angbracketright
"item":"Apple", Error}
Figure 11: Parse tree of Figure 9
Inthe“increasetocomplement”step,wefindthat test(c−Δ3)=
,sowerepeatouralgorithmwith c/prime
=c−Δ3andn=2,getting
Δ1=, Δ2=Error
Since neither test(c−Δi)nortest(c/prime
∪Δi)passes for any iand
n=|c−c/prime
|=2,wearedoneandendupwiththeremaininginput
seeninFigure10.Forthisexample,the syntacticddmax runneeded
only 9 test runs of the subject program to repair the faulty input.
Let us now take a look at the complexity of our algorithm. As
mentioned in Section 3, ddmaxhas a worst-case complexity of t=
|c|2+3|c|testrunsandabest-casecomplexityof t≤2log2(|c|).
Intuitively, the complexity of syntactic ddmax is similar to the
complexityof ddmax,exceptthatitisboundedbythenumberof
terminalnodesinsteadofthenumberofcharacters.Intheworst
case,aninput’sparsetreehasasmanyterminalnodesascharacters.
However, real-world input formats have keywords, data types and
characterclassestoaggregrategroupofcharactersintoterminals
(e.g. string and integers). This reduces the number of terminal
nodes and the required number of test runs for syntactic ddmax .I t
therefore speedsup ddmaxby decreasing thenumber of elements
tomaximizewith ddmax.ConsidertheexampleinFigure9,there
are 33 single characters to search with lexical ddmax , which are
parsedinto7terminalnodesfor syntacticddmax .Ingeneral,wecan
assume that with an average terminal node length of ncharacters,
we have a worst-case complexity of/parenleftBig|c|
n/parenrightBig2
+3|c|
ntest runs and a
best-case complexity of t≤2log2(|c|
n)test runs.
4.1 Evaluation Setup
Implementation. Syntacticddmax wasimplementedin1084LOC
ofJavacode, this implementation is built on top of the ANTLR4.5
parser generatorframework [ 44] foreach input grammar.Overall,
theimplementationof syntacticddmax differsfromthatof lexical
ddmaxin Section 3.4, because of its use of the input grammar and
parsetree.Specifically, Syntactic ddmax usestheANTLRparsetree
(from Step. 3 in Figure 6) to repair invalid inputs. In our evaluation,
we feed the invalid real-world files into our syntactic ddmax,w e
proceedtorun syntactic ddmax oneachinvalidinputfileandevalu-
ate the change in file size (i.e. the data loss on byte-level). Syntactic
ddmaxteststheinputunderrepairrepeatedlyusingthefeedback
from the subject program (Step. 5). In addition to the research pro-
tocolinSection3.4,wefeedallinvalidinputfilesto syntacticddmax
and measure the number of invalid files which are repaired by oursyntactic DDMax using the input grammar, this measure is termed
Syntactic.
4.2 Evaluation
RQ5: How effective is syntactic ddmax in repairing invalid
input documents within a time budget of one minute per
file?Syntactic ddmax repaired about three-quarters (73%) of all
invalid inputs in our evaluation (cf. Table 4). Overall, it is about
10% more effective than lexical ddmax (cf. Figure 7). It significantly
outperformed both the built-in repair strategies of the subject pro-
gramsand ANTLR,itrepairedfivetimesasmanyfilesasthesubject
programs, and almost twice as many files as ANTLR(cf. Table 4).
Thisconfirmsourhypothesis(inRQ2 )thatddmaxcanbenefitfrom
the knowledge of the input grammar.
Syntacticddmaxrepairedaboutthree-quartersofallinvalidinputs
and it is more effective than lexical ddmax, for all invalid inputs.
RQ6: How much data is recovered bysyntactic ddmax and
howmuchisthe dataloss incurredby syntacticddmax ?On
average,syntactic ddmax (89%) has a higher data recovery rate
in comparison to lexical ddmax (58%) for all invalid inputs. For
single data corruption, the data recovery rate of syntactic ddmax
is similar to that of ANTLRand thebaseline, when using mean
file size as a metric.On multiple data corruption, syntactic ddmax
recoveredabout84%ofthedataintheinputfiles( cf.Figure8).Forall
invalid inputs, the baselineandANTLRmaintain an almost perfect
datarecoveryrate(approximately100%).Evidently,thedataloss
incurred by both ANTLRand thebaselineis negligible.
Syntactic ddmax hasa high data recovery rate, recovering most
(89%) of the data in invalid input files.
Thedatalossincurredby ddmaxisverylow,intermsoftheedit
distance between the recovered file and the valid file. Across allmutations, it is less than 50% worse off than ANTLR, as captured
bytheLevenshteindistance (cf.Figure12).Inparticular,themean
edit distance of the repaired file and the originally valid inputfile is less than four for the baselineand about 24 for ANTLR.A s
expected, the Levenshtein distance is lower (21–28) for single data
corruptions for lexicalandsyntactical ddmax respectively, and
higherformultiplecorruptions(76–77).Oninspection,wefound
that the high loss of ddmaxis due to early timeouts for large input
files,indeed, ddmaxfindsavalidsubset,buttimesoutbeforethe
maximal subset is reached. For Wavefront OBJ files, the perceptive
image difference shows us similar scaling result as the Levenshtein
distance. While it shows small results for Baseline and ANTLR
(0.1 and 29.7, respectively), the results for lexicalandsyntactical
ddmaxarehigher(76.4and51.9),thusthedifferencebetweenthe
unmodified image and the repaired image is larger.
We conduct our evaluation of minimal data loss similarly to
the setting in RQ3 (cf. Section 3.4). As expected, syntactic ddmax
recoveredslightlylessdata,exactly1.720KiBonaverage.Thisis
becausesyntactic ddmax removes terminal nodes, a terminal node
maycontainmorecharactersthanthenumberofmutatedcharac-
tersinthenode.Insummary,withahighenoughtimeout lexical
ddmaxisguaranteedtoachieveminimaldataloss,thisguarantee
82 0 50 100 150 200
Baseline ANTLR Lex. ddmax Syn. ddmaxData Loss
TechniquesMean Difference in File Size (KB)
Mean Levenshtein Distance
Mean Perceptive Image Difference (PHASH)
Figure 12: Data Loss Incurred for All Mutations
does not hold for syntactic ddmax , since it operates at the parse
tree level rather than the byte level.
Overall, syntactic ddmax incurs comparatively similar data loss
during repair as lexical ddmax.
RQ7: How efficient issyntactic ddmax in repairing invalid
input documents? Syntactic ddmax improves over the runtime
performance of lexical ddmax (cf. RQ4 Section 3.4 ). It improves
overlexical ddmax by 34%, its execution time is about two-third
of the running time of lexical ddmax. Specifically, syntactic ddmax
is quicker, ittook approximatelyone minuteto repaira singlefile,
but requires a grammar and a parse tree6.
Syntactic ddmax is faster in repairing an invalid input file: it takes
less than one minute to repair a file on average.
 0.1 1 10 100 1000 10000 100000 1x106 1x107
Baseline ANTLR Lex. ddmax Syn. ddmaxRuntime (ms)
TechniquesMean runt ime per repa ired input file
1443.51882.737997.825153.9
Figure13:MeanRuntimeperInputFileforEachTechnique
6Depending on the grammar and on the input file size, generating a parse tree should
take less than a second.5 DIAGNOSTIC QUALITY
Even though ddmaxis primarily meant for repairing data, its maxi-
mized input can also be useful for diagnostics and debugging. In
particular, ddmaxdiagnosis is the difference Δbetween the failing
and maximal passing input. This is a minimal failure cause, which
isnecessarytodebugtheinput.Mostnotably,the Δfromddmax
includes allinput characters that are failure-inducing, whereas
ddmininclude only a minimal subset.
5.1 Evaluation Setup
Tocomparativelyevaluatethediagnosticutilityof ddmax,w eco-
pareddmaxdiagnoses to the established state of the art input diag-
nosisapproach ddmin.Inourevaluation,wecomparethe ddmax
diagnosis to ddmin, we do not compare to the general delta debug-
ging (DD) algorithm. This is because DD is not suited for repairing
inputs. Although, DD would produce a passing and a failing input
with a minimal difference between them. This DD difference could
beassmallastheddmaxdifferencebetweenthemaximalpassing
input and the original failing input, and have similar diagnostic
quality; also, DD would likely be faster. However, DD does not
havethegoalofminimizingdataloss,andthusthepassinginput
resultingfromgeneralDDmayactuallybeclosetoaminimalinput
cutting away all the original context.
Byconstruction,DD(and ddmin)canminimize(andthuslose)
all the context of the original failure. For instance, if there is aflag in the input that activates the faulty function, and DD (andddmin) will remove that flag, causing the program to pass, then
this single flag will end up as failure-inducing input. On the other
hand,ddmaxwould preserve as much of the original context as
possiblebyconstruction.Itistheseexperiencesthathavedriven
us to experiment with DD alternatives such as ddmaxandddmin.
Weimplementeda ddminalgorithmfollowingthedeltadebug-
gingalgorithmin[ 56]in450LOCofJavacode.Our ddminimple-
mentation uses both the subject program and ANTLR as oracles to
minimize an invalid input, in order to ensure that ddmindiagno-
sisissyntacticallyvalid.Thisensuresthat ddmindoesnotreport
a valid subset that may trigger a failure due to syntactic invalid-ity (e.g. in cf. Figure 2 in Section 1), since ANTLR can parse the
ddmindiagnosis,butthesubjectprogramcrashes.Then,wefeed
the real-world invalid files into our ddminimplementation (as seen
in Figure 6 Step. 8) and compare the diagnosis generated by ddmin
to that of ddmax.
Weareinterestedinevaluatingthesoundnessandcompleteness
of bothddmin, usingddmaxdiagnoses as the “ground truth”. To
be fair to both approaches, we consider the intersection of the
diagnosesforboth ddminandddmaxthatfinishedexecutionbefore
a time-out, this a set of 66 input files in total (cf. Table 6).
5.2 Evaluation
RQ8: How effective isddmaxin diagnosing the root cause
ofinvalidinputs,especiallyincomparisonto ddmin?Given
thatddmaxwas completely executed without a timeout, the repair
ofddmaxis themaximal passing input andddmaxdiagnosis is the
minimal failure cause. As expected ddmindiagnosis is significantly
larger(21timesmore)thanthe ddmaxdiagnosis,hence,itcontains
a significant amount (33%) of the maximal passing input, which
83Table6:DiagnosticQualityonReal-WorldInvalidInputsfor
A/circlecopyrtddminandB/circlecopyrtddmaxdiagnoses, and C/circlecopyrtddmaxrepair.
Format Diagnosis (B) Repair (B) Intersection (%)
(#inputs) AB CA∩BA∩C
JSON (21) 2.909 19.095 103.476 13.88 23.18
OBJ (18) 2.722 1.000 189.000 18.03 11.46
DOT (27) 376.654 1.115 675.346 5.76 54.64
Mean 155.754 6.804 360.747 11.69 32.85
is considered noise in the diagnosis ( cf.A∩Cin Table 6). Ad-
ditionally, ddmindiagnosisonlycontainsasmallportion(12%)of
the minimal failure cause required to diagnose the input invalidity
(cf.A∩BinTable6).Thisresultshowsthat ddmaxdiagnosisis
more effective for input debugging in comparison to the state of
the art,ddmin.
On average, only one-eighth (12%) of a ddmin diagnosis contains
the minimal failure cause and about one-third (33%) of ddmin
diagnosis contains the maximal passing input.
6 LIMITATIONS
Bothddmaxvariants are limited in the following ways:
Repair to subsets only. Bothddmaxvariantswillreturnastrict
lexicalorsyntactical subsetoftheoriginalfailure-inducing
input.Theassumptionisthatonlydatashouldberestored
that already is there (rather than synthesizing new data, for
instance).Iftheinputformathasseveralcontext-sensitive
dependencies, such as checksums, hashes, encryption, or
references, a strict lexical or syntactical subset might be
small to the point of being useless.
Data repair, not information repair. Bothddmaxvariants are
set torecover as much dataas possible,but not necessarily
information. Eventhoughtherepairedinputmaybelexically
orsyntacticallyclosetothe(presumed)originalinput,itcan
have very different semantics. Users therefore are advisedto thoroughly check the repaired input for inconsistencies;
thegoalofthisworkisto enableuserstoloadtheinputinto
their program such that they can engage in this task.
Input Semantics. Although, ddmaxobtainssome“semantic”in-
formation from the feedback of the subject program itself,
thisfeedbackislimitedtofailurecharacteristics,i.e.“pass”
or “fail”. However, it is possible to extend ddmaxto include
(domain-specific)semanticchecks,whichcouldeitherbede-
finedasthe executionofspecific program artifactssuchasa
specific branch, or programmatically defined by a developer
(e.g. as an expected program output).
Multiple errors and multiple repairs. If there are multiple er-
rors in an input, ddmaxwill produce a maximum input that
repairs all of them. However, if there are multiple ways to
repair the input, ddmax will produce only one of them. This
property is shared with delta debugging and its variants,
whichalsopickalocalminimumratherthansearchingfora
globalone.However,itwouldbeeasytomodify ddmaxto
assess all alternative repairs rather than the first repair.7 THREATS TO VALIDITY
Our evaluation is limited to the following threats to validity:
External validity refers to the generalizability of our approach
and results. We have evaluated our approach on a small set
ofapplicationsandinputgrammars.Thereisathreatthat
ddmaxdoesnotgeneralizetootherapplicationsandgram-
mars. However, we have mitigated this threat by evaluating
ddmaxusingmaturesubjectprogramswithvaryinginput
sizes.Oursubjectshave478KLOCand14yearsmaturity,on
average,makingusconfidentthatourapproachwillwork
on a large variety of applications and invalid inputs.
Internal validity isthreatenedbyincorrectnessofourimplemen-
tation,specificallywhetherwehavecorrectlyadapted ddmin
toddmaxfor input repair. We mitigate this threat by testing
ourimplementationonsmallerinputsandsimplergrammars,
in order to ensure our implementation works as expected.
Construct validity is threatened by our test oracle, and conse-
quently the error-handling implementation of the subject.
For instance, an application which silently handles excep-
tions would not provide ddmaxwith useful feedback during
testruns.Wecheckedthattherenderedinputproducedby
thesubjectisnon-empty,aftera10secondtimeout,which
was sufficient to identify failure-inducing inputs.
8 RELATED WORK
There is a large body of work concerning the interplay of program,
inputs, and faults. We discuss the most important related works.
Document Recovery hasthegoaltofixbrokeninputdocuments.
Docovery[ 33]usessymbolicexecutiontomanipulatecor-
ruptedinputdocumentsinamannerthatforcestheprogram
tofollowanalternativeerror-freepath.Incontrastto ddmax,
thisisawhite-boxapproachthatanalyzestheprogrampaths
executed by the failure-inducing inputs. S-DAGS [ 49]i sa
semi-automatic technique that enforces formal (semantic)consistency constraints on inputs documents in a collabo-
rative document editing scenario. Both of these approaches
require program analysis.
Input Rectification aimsattransforminginvalidinputsintoin-
puts that behave acceptably. Input rectifiers[35,48] address
this problem by learning a set of constraints from typical
inputs,thentransformingamaliciousinputintoabenignin-
put that satisfies the learned constraints. In contrast, ddmax
does notlearn constraintsbut rather employsthe feedback
fromtheprogram’sexecution(andagrammar)todetermine
an acceptable subset of the input. In comparison to security-
critical rectification, its goal is maximal data recovery.
Input Debugging. Numerousresearchershaveexaminedtheprob-
lemofsimplifyingfailure-inducinginputs[ 10,39,50,56].In
particular, [ 39] (HDD) and [ 50] are closely related to ddmax.
Bothapproachesusetheinputstructuretosimplifyinputs,
albeit without an input grammar. Unlike ddmax, these ap-
proachesdonotrecovermaximalvaliddatafromthefailure-
inducing input, but rather minimize the input like ddmin.
Data Diversity [2] transforms an invalid input into a valid input
that generates an equivalent result, in orderto improve soft-
warereliability.Thisisachievedbyfindingtheregionsofthe
84input space that causes a fault, and re-expressing a failing
inputtoavoidthefaultyinputregions.Incontrast, ddmax
does not require program analysis; it only needs a means to
assess whether the program can process the input or not.
Data Structure Repair iterativelyfixescorrupteddatastructures
byenforcingtheyconformtoconsistencyconstraints[ 12–
14,26]. These constraints can be extracted, specified and en-
forced with predicates [ 16], model-based systems [ 13], goal-
directedreasoning[ 14],dynamicsymbolicexecution[ 26]or
invariants [ 12]. On the one hand, the goal of data structure
repairistoensureaprogramexecutessafelyandacceptably,
despite data structure corruption. On the other hand, the
goal ofddmaxis to repair the input in order to avoid the
corruption of the program’s internal data structure.
Syntactic Error Recovery. Parsers and compilers implement nu-
merous syntax error recovery schemes [ 6,23]. Most ap-
proaches involve a plethora of operations including inser-
tion,deletionandreplacementofsymbols[ 3,4,9],extending
forward or backwards from a parser error [ 8,38], or more
general methods of recovery and diagnosis [ 1,32]. Unlike
ddmax, these schemes ensure the compiler does not halt
while parsing; the input still would not automatically fixed.
Data Cleaning and Repair. Severalresearchershaveaddressed
theproblemofdatacleaningofdatabasesystems.Mostap-
proachesautomaticallyanalysethedatabasetoremovenoisy
data or fill in missing data [ 24,55]. Other approaches al-
low developers to write and apply logical rules on the data-
base[18,21,29,36,45,46].Incontrastto ddmax,allofthese
approaches repair database systems, not raw user inputs.
Data Testing and Debugging aimstoidentifysystemerrorscaused
by well-formed but incorrect data while a user modifies a
database[ 40].Forinstance,continuousdatatesting(CDT)[ 41]
identfieslikelydataerrorsbycontinuouslyexecutingdomain-
specfic test queries, in order to warn users of test failures.
DATAXRAY[ 53]alsoinvestigatestheunderlyingconditions
that cause data bugs, it reveals hidden connections and com-
mon properties among data errors. In contrast to ddmax,
theseapproachesaimtoguarddatafromnewerrorsbyde-
tecting data errors in database systems during modification.
9 CONCLUSION AND FUTURE WORK
Withddmax, wehave presented the first generictechnique forau-
tomaticallyrepairingfailure-inducinginputs—thatis,recovering
a maximal subset of the input that can still be processed by the
programathand. ddmaxisavariantofdeltadebuggingthatmax-
imizes the passing input, both at a lexical and a syntactical level;
itrequiresnothingmorethantheabilitytoautomaticallyrunthe
program with a given input. In our evaluation, we find that ddmax
fully repairs 79% of invalid input files. Both variants of ddmaxcan
be easily implemented and deployed in a large variety of contexts.
as they do not require any kind of program analysis.
Our work opens the door for a number of exciting research
opportunities. Our future work will focus on the following issues:
Synthesizing input structures. Going for a strict lexical or syn-
tactical subset of the failure-inducing input is a conserva-
tive strategy; yet, there canbe cases where addinga smallamountoflexicalorsyntacticalelementscanhelptorecover
even more information. We are investigating appropriate
grammar-basedproductionstrategiesaswellashybridstrate-
gies that leverage both syntactical and lexical progression.
Learned grammars. Right now, our syntactical variant of ddmax
requiresaninputgrammarto startwith.Weareinvestigat-
ingwhethersuchagrammarcanalsobe inferredfromthe
program at hand[ 22,25], thus freeingusers or developers
from having to provide a grammar.
From input repair to code repair. A minimal difference Δbe-
tween a maximized passing and a full failure-inducing input
also brings great opportunities for fault localization and
repair.Forinstance,whatisthecodeexecutedbythefailure-
inducing input, but not by the maximized passing input?
Whatarethedifferencesinvariablevalues?Suchdifferences
in execution can help developers to further narrow down
failure causes as well as synthesizing code repairs.
End-user debugging. Our input repair technique needs no spe-
cific knowledge on program code, and could thus also be
appliedbyendusers.Weareinvestigatingappropriatestrate-giestocommunicatetheresultsofourrepairandinformationaboutconflictingdocumentpartstoendusers,suchthatthey
canfix the problem without having to fix the program.
Hybrid repair. Lexicalandsyntactic ddmaxcanbecombinedsuch
that after syntactic ddmaxis executed on the parse tree,
lexicalddmaxfurther repairs the text in the faulty nodes.
This combination reduces the number of iterations and the
executiontime,incomparisontolexical ddmax.Moreover,
it improves on the effectiveness of syntactic ddmax.
Semantic Input Repair. It is possible to extend the ddmaxtest
oracle to include checks for desirable “semantic” proper-ties other than failure characteristics (i.e. pass or fail). Forinstance, the test oracle can be extedned to check if somefunction is triggered or some specific output is produced,
such“semantic”checkswouldensurethattheresultingmax-
imizedpassinginputissemanticallysimilartotheoriginal
input and avoids the failure.
Fuzzing. Bothvariantsof ddmaxcanbeappliedtoimprovesoft-
ware fuzzing. For instance, mutational fuzzing techniques
often modify seed inputs to find bugs in the program. Often,
these inputs become malformed after mutation, ddmaxcan
beapplied torepairsuchinputs,inorderto ensure thatthey
are valid, and consequently, cover program logic.
Our implementations of ddmaxas well as all experimental data
is available as a replication package at
https://tinyurl.com/debugging-inputs-icse-2020
ACKNOWLEDGMENTS
Wethanktheanonymousreviewersfortheirhelpfulcomments.Spe-
cialthanksgotoSaschaJustfordiscussionsonpaperandideas.This
work was (partially) funded by Deutsche Forschungsgemeinschaft,
Project “Extracting and Mining of Probabilistic Event Structures
from Software Systems (EMPRESS)”.
85REFERENCES
[1]AlfredVAhoandThomasGPeterson.1972.Aminimumdistanceerror-correcting
parser for context-free languages. SIAM J. Comput. 1, 4 (1972), 305–312.
[2]Paul Eric Ammann and John C Knight. 1988. Data diversity: An approach to
software fault tolerance. Ieee transactions on computers 4 (1988), 418–425.
[3]S.O.AndersonandRolandCarlBackhouse.1981.Locallyleast-costerrorrecovery
inEarley’salgorithm. ACMTransactionsonProgrammingLanguagesandSystems
(TOPLAS) 3, 3 (1981), 318–347.
[4]S.O.Anderson,RolandCarlBackhouse,E.H.Bugge,andCPStirling.1983. An
assessment of locally least-cost error recovery. Comput. J. 26, 1 (1983), 15–24.
[5] assimp team. 2018. The Open-Asset-Importer-Lib. http://www.assimp.org[6]
RolandCBackhouse.1979. Syntaxofprogramminglanguages:theoryandpractice.
Prentice-Hall, Inc.
[7] Johannes Buchner. 2017. ImageHash 4.0. https://pypi.org/project/ImageHash/[8]
Michael Burke and Gerald A. Fisher Jr. 1982. A practical method for syntactic
error diagnosis and recovery. Vol. 17. ACM.
[9] Carl Cerecke. 2003. Locally least-cost error repair in LR parsers. (2003).
[10]JamesClauseandAlessandroOrso.2009. Penumbra:Automaticallyidentifying
failure-relevantinputsusingdynamictainting.In Proceedingsoftheeighteenth
international symposium on Software testing and analysis. ACM, 249–260.
[11]Douglas Crockford. 2017. ECMA-404 The JSON Data Interchange Standard.
https://www.json.org/
[12]BrianDemsky,MichaelD.Ernst,PhilipJ.Guo,StephenMcCamant,JeffH.Perkins,
and Martin Rinard. 2006. Inference and Enforcement of Data Structure Con-sistency Specifications. In Proceedings of the 2006 International Symposium on
Software Testing and Analysis (ISSTA ’06). ACM, New York, NY, USA, 233–244.
https://doi.org/10.1145/1146238.1146266
[13]Brian Demsky and Martin Rinard. 2003. Automatic Detection and Repair of
ErrorsinDataStructures. SIGPLANNot. 38,11(Oct.2003),78–95. https://doi.
org/10.1145/949343.949314
[14]B.DemskyandM.Rinard.2005. Datastructurerepairusinggoal-directedreason-
ing.InProceedings.27thInternationalConferenceonSoftwareEngineering,2005.
ICSE 2005. 176–185. https://doi.org/10.1109/ICSE.2005.1553560
[15]StephenDolan.2018. Command-lineJSONprocessor. https://stedolan.github.
io/jq/
[16]BassemElkarabliehandSarfrazKhurshid.2008. Juzi:Atoolforrepairingcomplex
data structures. In Proceedings of the 30th international conference on Software
engineering. ACM, 855–858.
[17]Blender Foundation. 2018. blender.org - Home of the Blender project - Free and
Open 3D Creation Software. https://www.blender.org
[18]HelenaGalhardas,DanielaFlorescu,DennisShasha,andEricSimon.2000. AJAX:
An extensible data cleaning tool. ACM Sigmod Record 29, 2 (2000), 590.
[19] Gephi. 2018. The Open Graph Viz Platform. https://gephi.org/[20]
GitHub. 2018. Grammars written for ANTLR v4. https://github.com/antlr/
grammars-v4
[21]Lukasz Golab, Howard Karloff, Flip Korn, and Divesh Srivastava. 2010. Data
auditor:Exploringdataqualityandsemanticsusingpatterntableaux. Proceedings
of the VLDB Endowment 3, 1-2 (2010), 1641–1644.
[22]RahulGopinath,BjörnMathis,MathiasHöschele,AlexanderKampmann,andAn-
dreas Zeller. 2018. Sample-Free Learning of Input Grammars for Comprehensive
Software Fuzzing. arXiv preprint arXiv:1810.08289 (2018).
[23]K Hammond and Victor J. Rayward-Smith. 1984. A survey on syntactic error
recovery and repair. Computer Languages 9, 1 (1984), 51–67.
[24]MauricioAHernándezandSalvatoreJStolfo.1995. Themerge/purgeproblem
for large databases. ACM Sigmod Record 24, 2 (1995), 127–138.
[25]Matthias Höschele and Andreas Zeller. 2017. Mining input grammars with
AUTOGRAM. In Proceedings of the 39th International Conference on Software
Engineering Companion. IEEE Press, 31–34.
[26]IshtiaqueHussainandChristophCsallner.2010. Dynamicsymbolicdatastructure
repair. In Software Engineering, 2010 ACM/IEEE 32nd International Conference on,
Vol. 2. IEEE, 215–218.
[27] GitHub Inc. 2018. REST API v3. https://developer.github.com/v3/[28]
ANTLR 4.7.1 API JavaDocs. 2018. Class DefaultErrorStrategy. https://www.
antlr.org/api/Java/org/antlr/v4/runtime/DefaultErrorStrategy.html
[29]Shawn R Jeffery, Gustavo Alonso, Michael J Franklin, Wei Hong, and Jennifer
Widom. 2006. A pipelined framework for online cleaning of sensor data streams.
In22ndInternationalConferenceonDataEngineering(ICDE’06).IEEE,140–140.
[30]jsonsimple.2018.AsimpleJavatoolkitforJSON. https://github.com/fangyidong/
json-simple[31]Eleftherios Koutsofios, Stephen North, et al .1991.Drawing graphs with dot.
TechnicalReport.TechnicalReport910904-59113-08TM,AT&TBellLaboratories,
Murray Hill, NJ.
[32]Tomasz Krawczyk. 1980. Error correction by mutational grammars. Inform.
Process. Lett. 11, 1 (1980), 9–15.
[33]TomaszKuchta,CristianCadar,MiguelCastro,andManuelCosta.2014.Docovery:
TowardGenericAutomaticDocumentRecovery.In InternationalConferenceon
Automated Software Engineering (ASE 2014). 563–574.
[34]Vladimir I. Levenshtein. 1966. Binary codes capable of correcting deletions,
insertions, and reversals. In Soviet physics doklady, Vol. 10. 707–710.
[35]FanLong,VijayGanesh,MichaelCarbin,SteliosSidiroglou,andMartinRinard.
2012. Automatic Input Rectification. In Proceedings of the 34th International
Conferenceon SoftwareEngineering (ICSE ’12) .IEEEPress, Piscataway,NJ,USA,
80–90. http://dl.acm.org/citation.cfm?id=2337223.2337233
[36]Dominik Luebbers, Udo Grimmer, and Matthias Jarke. 2003. Systematic de-
velopment of data mining-based data quality tools. In Proceedings 2003 VLDB
Conference. Elsevier, 548–559.
[37]AlexandruMarginean,JohannesBader,SatishChandra,MarkHarman,YueJia,
KeMao,AlexanderMols,andAndrewScott.2019. Sapfix:Automatedend-to-end
repair at scale. In Proceedings of the 41st International Conference on Software
Engineering: Software Engineering in Practice. IEEE Press, 269–278.
[38]Jon Mauney and Charles N. Fischer. 1982. A forward move algorithm for LL and
LR parsers. ACM SIGPLAN Notices 17, 6 (1982), 79–87.
[39]GhassanMisherghiandZhendongSu.2006. HDD:HierarchicalDeltaDebugging.
InProceedings of the 28th international conference on Software engineering. ACM,
142–151.
[40]KıvançMuşlu,YuriyBrun,andAlexandraMeliou.2013. Datadebuggingwith
continuous testing. In Proceedings of the 2013 9th Joint Meeting on Foundations of
Software Engineering. 631–634.
[41]KıvançMuşlu,YuriyBrun,andAlexandraMeliou.2015. Preventingdataerrors
withcontinuoustesting.In Proceedingsofthe2015InternationalSymposiumon
Software Testing and Analysis. 373–384.
[42]University of Utah. 2003. Wavefront OBJ Specification. https://www.cs.utah.
edu/~boulos/cs3505/obj_spec.pdf
[43]TheappleseedHQOrganization.2018. appleseed -Amodern,open-sourcepro-
duction renderer. https://appleseedhq.net
[44] Terence Parr. 2018. ANTLR. http://www.antlr.org[45]
Ravali Pochampally, Anish Das Sarma, Xin Luna Dong,Alexandra Meliou, and
Divesh Srivastava. 2014. Fusing data with correlations. In Proceedings of the 2014
ACM SIGMOD international conference on Management of data. 433–444.
[46]Vijayshankar Raman and Joseph M Hellerstein. 2001. Potter’s wheel: An interac-
tive data cleaning system. In VLDB, Vol. 1. 381–390.
[47]AT&T Labs Research. 2018. Graphviz - Graph Visualization Software. https:
//www.graphviz.org/
[48]MartinC.Rinard.2007. LivingintheComfortZone.In Proceedingsofthe22Nd
AnnualACMSIGPLANConferenceonObject-orientedProgrammingSystemsand
Applications (OOPSLA ’07). ACM, New York, NY, USA, 611–622. https://doi.org/
10.1145/1297027.1297072
[49]JanScheffczyk,UweMBorghoff,PeterRödig,andLotharSchmitz.2004. S-DAGs:
Towards efficient document repair generation. In Proc. of the 2nd Int. Conf. on
Computing, Communications and Control Technologies, Vol. 2. 308–313.
[50]Chad D. Sterling and Ronald A. Olsson. 2007. Automated bug isolation via
program chipping. Software: Practice and Experience 37, 10 (2007), 1061–1086.
[51]Ralf Sternberg. 2018. minimal-json - A fast and small JSON parser and writer for
Java. https://github.com/ralfstx/minimal-json
[52]MicrosoftSupport.2018. HowtorecoveralostWorddocument. https://support.
microsoft.com/en-us/help/316951
[53]XiaolanWang,MaryFeng,YueWang,XinLunaDong,andAlexandraMeliou.
2015. Errordiagnosisanddataprofilingwithdatax-ray. ProceedingsoftheVLDB
Endowment 8, 12 (2015), 1984–1987.
[54]W Eric Wong, Ruizhi Gao, Yihao Li, Rui Abreu, and Franz Wotawa. 2016. A
survey on software fault localization. IEEE Transactions on Software Engineering
42, 8 (2016), 707–740.
[55]HuiXiong,GauravPandey,MichaelSteinbach,andVipinKumar.2006.Enhancing
data analysis with noise removal. IEEE Transactions on Knowledge and Data
Engineering 18, 3 (2006), 304–319.
[56]Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-InducingInput. IEEETrans.Softw.Eng. 28,2(Feb.2002),183–200. https://doi.
org/10.1109/32.988498
86