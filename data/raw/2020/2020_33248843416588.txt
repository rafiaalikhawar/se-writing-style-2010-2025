A Predictive Analysis for Detecting Deadlock in MPI Programs
Yu Huang
Southwestern University of Finance
and Economics
yuhuang@swufe.edu.cnBenjamin Ogles
Brigham Young University
benjaminogles@gmail.comEric Mercer
Brigham Young University
egm@cs.byu.edu
ABSTRACT
A common problem in MPI programs is deadlock: when two or
moreprocessesareblockedindefinitelyduetoacircularcommu-
nication dependency. Automatically detecting deadlock is difficult
due to its schedule-dependent nature. This paper presents a predic-
tiveanalysisforsingle-pathMPIprogramsthatobservesasingle
programexecutionandthendetermineswhetheranyotherfeasible
scheduleoftheprogramcanleadtoadeadlock.Theanalysisworks
by identifying problematic communication patterns in a depen-dency graph to form a set of deadlock candidates. The deadlock
candidatesarefilteredbyanabstractmachineandultimatelytested
for reachability by an SMT solver with an efficient encoding fordeadlock. This approach quickly yields a set of high probability
deadlock candidates useful for reasoning about complex codes and
yieldshigherperformanceoverallinmanycasescomparedtoother
state-of-the-art analyses.The analysis issound and completefor
single-path MPI programs on a given input.
CCS CONCEPTS
•Software and its engineering →Formal software verifica-
tion;Distributed programming languages.
KEYWORDS
deadlock, predictive analysis, abstract machine, cycle detection
ACM Reference Format:
YuHuang,BenjaminOgles,andEricMercer.2020.APredictiveAnalysis
forDetectingDeadlockinMPIPrograms.In 35thIEEE/ACMInternational
ConferenceonAutomatedSoftwareEngineering(ASE’20),September21–25,
2020, Virtual Event, Australia. ACM, New York, NY, USA, 11 pages. https:
//doi.org/10.1145/3324884.3416588
1 INTRODUCTION
Themessagepassinginterface (MPI)isthe defactostandardforcom-
municationandsynchronizationinhighperformancedistributed
programs. MPI programs contain a finite set of processes that send
and receive messages concurrently. A common error in MPI pro-
grams, referred to as deadlock, occurs when one or more processes
block indefinitely due to a circular communication dependency.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’20, September 21–25, 2020, Virtual Event, Australia
© 2020 Association for Computing Machinery.
ACM ISBN 978-1-4503-6768-4/20/09...$15.00
https://doi.org/10.1145/3324884.3416588This paper presents an analysis for detecting deadlock in a sub-
classofMPIprogramscalled single-pathprograms [10]wherethe
order of actions issued by each process is deterministic for a given
input.Single-pathprogramsthereforeexhibitalimited,thoughstill
significant, set of non-deterministic behaviors due to message race.
Messageraceoccurswhentwoormoremessagesaresentcon-
currently to the same process that has not specified a source for its
next receive. An MPI program that terminates successfully in one
executionmaydeadlockinanotherexecutiondependingonhow
message race is resolved by the runtime.
Theanalysispresentedinthispaperis predictive becauseitob-
serves a single schedule over message race and finds a different
feasibleschedulethatleadstoadeadlockonthesameinput.The
new schedule preserves the order of actions in each process and is
thereforeguaranteedtobeafeasibleexecutionofthesingle-path
program. Finding such a schedule is an NP-Complete problem and
can be encoded as a propositional formula [10].
Theseformulascangrowprohibitivelylargeformanyprograms
because they must encode what it means to deadlock generally. In
contrast,theapproachpresentedinthispaperonlyencodeswhatit
means to deadlock at a specific point in the program. This simpler
encoding is used on a filtered set of likely deadlock candidates.
The analysis proceeds in three increasingly precise stages:
(1)A conservative set of deadlock candidates is extracted from
the cycles of a dependency graph defined over the observed
execution.
(2)Eachcandidateistestedforreachabilityinanabstractma-
chine that implements an abstract semantics for the pre-
sented MPI programming model.
(3)The feasibility of the remaining candidates is determined by
encoding each as a separate SMT problem.
Each of these stagespresents its own research challenges. First,
highly non-deterministic MPI programs yield large dependency
graphswithahugenumberofcycles.Anaiveenumerationofall
cycles would not scale to these programs. This paper presents a
strict characterization of which cycles may be deadlock candidates
andamodificationofJohnson’salgorithm[ 18]thatonlyenumerates
such cycles.
Second,tobe aneffectivefilteringmechanism, theabstractma-
chine must be able to accept all feasible deadlock cycles and reject
mostinfeasibledeadlockcyclesbasedononlyoneabstractexecu-
tion.Inotherwords,themachinemustbeprovablypreciseandthe
schedulechosenbytheabstractmachineexecutionmustnotlead
to spurious results. Proofs for both of these properties are given in
the full paper [2].
Finally, the SMT encoding is adapted from an encoding devel-
oped by Huang et al [ 16] that can only describe schedules over
messagerace thatformcomplete executions(e.g., theendof each
182020 35th IEEE/ACM International Conference on Automated Software Engineering (ASE)
a: : = n b | b b
nb ::= (sipsrc dst )
|(ripsrc dst )
bb ::= (wipi)
|(bipд)
src ::= p|∗
dst ::= p
Figure 1: Types of Actions a ∈A.
process is reached). The witness execution, which is an execution
thatactuallydoesdeadlockatthepredictedprogramlocation,fora
feasible deadlock candidate is necessarily incomplete. Therefore,
the encoding is adapted to describe partial executions that dead-
lockataspecificpoint.Thisisachievedbyaddingoneadditional
boolean variable for every encoded MPI operation that represents
itscompletionstateinthewitnessexecution.Operationsinthepro-
cessesnamedbythedeadlockcandidateareassertedascomplete
uptothedeadlockpointwhilethecompletionstateofoperations
intheotherprocessesisresolvedbytheSMTsolverasneededto
reach the deadlock.
The analysis supports multiple buffer settings and is sound and
complete for single-path programs on a given input (i.e., it reports
adeadlockifandonlyifthereisareachabledeadlock).Empirical
results show that, in many cases, the staged analysis is far more
efficientthanencodingthedeadlockproblemasanSMTformula
directly [10,11] or analyzing the program with a model checker [ 4,
25, 30].
2 PRELIMINARIES
We formalize an observed MPI program execution as a concurrent
trace program (CTP). A CTP is a set of observed communication
actionsA⊂AwhereAis the set of all possible MPI actions.
Thesyntaxandstructureofactionsin AisshowninFigure1.
Each action has a unique identifier i∈Nand an owning process
p∈P(A)whereP(A)is the set of all processes in the CTP A. For
a set of actions Xand for each process p∈P(X),Xp⊆Xis the
projection of the actions in Xonto the process p.
Non-blockingactionsareusedtoasynchronouslysend( s)and
receive(r)messagesbetweenprocesses.Thesourceanddestination
processes for a message are indicated by process identifiers in the
bodyoftheseactionswherethesourceprocessforareceivecanbe
∗toallowfor wildcardreceive.Awildcardreceiveacceptsmessages
from any source process.
The messages are held in buffers allocated by the user program
andcopiedfromsourcetodestinationbuffersbyanMPIruntime.
Data buffers are not explicitly represented in this presentation
becausethevaluesofmessagesdonotaffecttheschedulesofsingle-
path programs.
Blocking actions are used to halt a process until some condition
becomestrue,possiblysynchronizingtwoormoreprocesses.The
wait(w)actionblocksuntilthedatabufferofanon-blockingaction
is available (i.e., when data has been copied out of (into) a send
(receive) buffer). The barrier ( b) action blocks until each process
in a group (indicated with a unique identifier д) has reached thesame barrier. Blocking send and receive actions are not included in
Abecause they are accurately modeled by placing a wait action
directly after the non-blocking action.
For the remaining sections, we fix a CTP A. For simplicity in the
presentation of the analysis and accompanying proofs, we assume
that the last action in each process p∈P(A)is a barrier action
(bippд)for some group д∈G(A)whereG(A)is the set of barrier
groups in A. This assumption does not affect the programs we
analyze as we can always extend the observed CTP with theseactions. The added barrier action at the end of each process is
necessarytomodelallpotentialdeadlocksinthedependencygraph
including those arising from wildcard receives.
Thedisjointsetsofsend,receive,waitandbarrieractionsin A
aredenotedrespectivelyby S(A),R(A),W(A),B(A).Foranaction
a∈A,id(a)andpid(a)denote the action and process identifiers
ofa. For an action a∈S(A)∪R(A),src(a)anddst(a)denote the
source and destination process of a. Of course, src(a)=pid(a)and
dst(a)=pid(a)for sends and receives respectively.
For an action a∈W(A),req(a)is the non-blocking action that a
waits for. For an action a∈B(A),д=grp(a)is the group identifier
foraandBд(A)is the set of actions in that group.
Foraprocess p∈P(A),theactionsownedby parealwaysissued
sequentially.Thisconstraintcanbecapturedasapartialorderover
Aifweassumethatactionidentifierswereassignedinascending
order while observing the original execution.
Definition 2.1 (Process order). Process order is a partial order
(A,≤Apo)where
∀a,a/prime∈A:a≤A
poa/prime⇐⇒pid(a)=pid(a/prime)∧id(a)≤id(a/prime)
ForDefinition2.1andsimilarlyforanyotherpartialorderdefined
in this paper, we use <Apoto mean the partial order with reflexivity
removed and we omit Afrom the notation when it is clear from
context.
3 EXAMPLE
Figure2showsafeasiblecompleteexecutionforasimpleCTP.Each
column is a separate process where actions are listed in ≤poorder.
The vertical spacing represents the total order over the actions
in the observed execution. We refer to actions by their unique
identifiers.
Inthisexample,thewildcardreceive0canmatchwith either1
or3.Inthecompleteexecution0matcheswith1,leaving3tomatch
with 4. If this message race is resolved in the opposite direction,
matching 0 with 3, a deadlock occurs.
Our analysis detects the deadlock by identifying the program
locations{(w906),(w11 1 4),(w721)}as a deadlock candidate.
ThedeadlockcandidateisextractedfromthecycleshowninFig-
ure 3. Figure 4 shows the witness execution for this deadlock. Here6iswaitingforitsonlymatch:8.Thisprevents10frombeingissued
and matching with 4, which in turn prevents 12 from being issued
and matching with 1.
The graph for Figure 2 contains 22 nodes and 36 edges. Our
algorithmdetects threedeadlock cyclesinthis graph.In thiscase,
none of the cycles are filtered away by the abstract machine, even
though only one predicts a feasible deadlock. The other two cycles
predict infeasible deadlocks.
19(r01∗1)
(s1221)
(w210)
(s3001)
(r4101)
(w503)
(s6002)
(w721)
(r8202)
(w906)
(s1 0001)
(w1 114)
(r12 1∗1)
(w1 301 0)
(w1 411 1)
(w1 528)
(b1 600)
(b1 710)
(b1 820)
Figure 2: Example CTP with hidden deadlock.
{(6,9),(9,10),(10,4),(4,11),(11,12),(12,1),(1,7),(7,8),(8,6)}
Figure 3: Cycle for deadlock in Figure 2.
(s3001)
(r01∗1)
(w503)
(s6002)
(w210)
(r4101)
(s1221)
(w906)
(w1 114)
(w721)
Figure 4: Witness execution for deadlock in Figure 3.
TheSMTencodingverifiesthefeasibilityofeachdeadlockcy-
cle by encoding a deadlock at the candidate location. To find the
execution shown in Figure 4 for example, the formula encodes astate where 7, 9 and 11 are issued and where 1, 4 and 6 cannot
find any match. The satisfying assignment for the variables in the
formula can be used to construct the witness execution, including
the details of which matches were made.
Theinfeasiblecyclesreporttheprogramlocations (b1710)and
(w721)in two different candidates. In other words, they each
predictthattheprograminFigure2canbere-orderedtoreacha
state where action 1 is waiting for process 1 to issue a compatible
matchbutprocess1iswaitingtofinish.Thistypeofdeadlockdoes
occur in some programs and is discussed in Section 6. However, in
thiscaseitisclearthatifprocess1reachesaction17,aspredictedin
the deadlock candidates, either action 0 or 12 must be available to
match with action 1, making these candidates infeasible. It may beIssueTransition
a∈A\I<−1po[a]⊆I(<−1po[a]∩(W(A)∪B(A)))⊆M
/angbracketleftA,I,M/angbracketright→/angbracketleftA,I∪{a},M/angbracketright
Match-Send-Recv Transition
a,a/prime∈I\Ma∈S(A)a/prime∈R(A)dst(a)=dst(a/prime)
src(a/prime)∈{src(a),∗}(<−1mo[a]∪<−1mo[a/prime])⊆M
/angbracketleftA,I,M/angbracketright→/angbracketleftA,I,M∪{a,a/prime}/angbracketright
Match-Wait Transition
a∈I\Ma∈W(A)<−1mo[a]⊆M
/angbracketleftA,I,M/angbracketright→/angbracketleftA,I,M∪{a}/angbracketright
Match-Barrier Transition
д∈G(A)∀a∈Bд(A),a∈I∧<−1mo[a]⊆M
/angbracketleftA,I,M/angbracketright→/angbracketleftA,I,M∪Bд(A)/angbracketright
Figure 5: Transition Rules for Concrete Semantics.
possibletoextendtheabstractmachinewithsomecountinglogic
to filter these candidates but our empirical results (Section 9) show
that it already filters a majority of the cycles detected in our set of
benchmarks.
4 SEMANTICS OF CONCURRENT TRACE
PROGRAMS
In this section, we extend the semantics presented by Forejt etal. [
10] to accomodate barrier groups and simpler proofs of cor-
rectness for our analysis. The semantics of Ais given by a finite
statemachineF(A)=/angbracketleftQ,q0,→/angbracketrightwhereQ⊆2A×2A×2Aisthe
set of states, q0=/angbracketleftA,∅,∅/angbracketrightis the start state and →⊆Q×Q is the
transition relation. In a state q=/angbracketleftA,I,M/angbracketright,Ais the set of actions
in the CTP, I⊆Ais the setof actions that havebeen issued to the
runtime, and M⊆Iis the set of actions that have been matched.
Sendandreceiveactionsarematchedtogetherbytheruntime
whentheirsourceanddestinationprocessesarecompatible.Wait
actions do not match other actions but are instead “matched” with
themselves after their associated message request is matched. Fi-
nally, barrier actions match the other actions in their group when
they have all been issued.
Someactionsinthesameprocessmaybematchedinanorder
differentfromhowtheywereissuedwhileothersmustbematched
intheordertheywereissued.Thisconstraintiscapturedbytwo
more partial orders.
Definition4.1(Queueorder). Queueorderisapartialorder (A,≤Aqo
)where for all actions a,a/prime∈A,a≤Aqoa/primeif and only if a≤Apoa/prime
and one of the following is true:
(1){a,a/prime}⊆S(A)∧dst(a)=dst(a/prime)
(2){a,a/prime}⊆R(A)∧src(a)∈{src(a/prime),∗}
20Definition 4.1 defines a first-in-first-out (FIFO) ordering over
messagescommunicatedonthesameendpoint.Withoneexception,
this order fully supports the “non-overtaking” property of ordered
messages as defined in the MPI standard. The exception occurs
whenadeterministicreceiveisfollowedbyawildcardreceivein
the same process.
In this case, FIFO ordering over the two receive actions is en-
forced only if they can both match the same send action. This
condition is schedule-dependent as its value changes depending
onwhetherasendactionhasbeenissuedthatcanmatchthefirst
receiveactionwhenthesecondactionisissued.Asin[ 10],weleave
such receive actions unordered.
Definition4.2(Matchorder). Matchorderisapartialorder (A,≤Amo
)where for all actions a,a/prime∈A,a≤Amoa/primeif and only if a≤Apoa/prime
and one of the following is true:
(1)a≤Aqoa/prime
(2)a∈W(A)∪B(A)
(3)a∈S(A)∪R(A)∧a/prime∈W(A)∧a=req(a/prime)
Definition 4.2 ensures that (1) queue order is preserved when
messages are matched, (2) blocking actions are matched beforesubseqent actions in the same process and (3) message requests
arematchedbeforetheirassociatedwaitactions.Withmatchorder
defined, we can define the transition relation →shown in Figure 5.
Given a relation Qover a set Xand an element x∈X,Q−1[x]=
{y∈X:yQx}is the preimage of xunderQ. TheIssuetransition
issuesanewactionwhenalloftheactionsprecedingitinthesame
process have been issued and all of the blocking actions preceding
it in the same process have been matched. The Match-Send-Recv
transitions complete type compatible matches when their match
order dependencies have been satisfied.
Notethatthedefinitionofthe Match-Wait transitionin→re-
quiresthatthe Match-Send-Recv transitionhascompletedforthe
messagerequestofthewaitaction.Thiseffectivelyforcesexecu-
tionstofollowa rendevousprotocol wherewaitingforacommuni-
cation causes the process to block until the full message transfer is
completed.Thisisincontrasttoanequallyvalidprotocolwhere
wait actions are matched as soon as the data buffer used in the
message request is available.
Wechoosetousetherendevousprotocolbecauseitisequivalent
to a zero-buffer runtime. In a buffered runtime, sent messages can
becopiedintosystembuffersbeforematchingreceiveactionsare
issuedinordertofreeupuserbuffersmorequickly.Inazero-buffer
runtime, this buffering never occurs and the user buffer is only
available after the message transfer has completed.
Ouranalysiscanalsosupportanotherimportantbuffersetting
forMPIprograms:theinfinite-buffersetting.Inaninfinite-buffer
runtime, sent messages are buffered without limit. The Match-
Waittransitionisincompatiblewiththisbuffersetting.Ratherthan
creating new transition rules however, we completely support the
infinite-buffer setting by removing wait actions from the CTP that
wait on send actions.
5 DEADLOCK
Thissectionformalizestheproblemstatementfordetectingdead-
lock inA. The definitions are given in terms of a generic transitionrelationδ⊆Q×Q because wereuse them laterwith the abstract
transistion relation.
LetΣq
δ⊆Qdenote the reachable states of Afrom the state q
with respect to a transition relation δ:
Σq
δ={q/prime∈Q:(q,q/prime)∈δ∗}
whereδ∗denotes the transitive closure of δ.
Definition5.1(Deadlock). Astateq=/angbracketleftA,I,M/angbracketrightisdeadlockedwith
respect to a transition relation δif there are no enabled transitions
and there are actions left to be issued or matched:
Deadδ(q)⇐⇒(I/nequalA∨M/nequalA)∧(∀q/prime∈Q,(q,q/prime)/nelementδ)
The deadlock discovery problem, given in Definition 5.2, asks
whetherF(A)can reach a deadlocked state. This problem is NP-
Completeandcanbedirectlyencodedasapropositionalformula[ 10].
Definition 5.2 (Deadlock discovery problem).
∃q∈Σq0
δ,Deadδ(q)
The search for an arbitrary feasible deadlock state can be ex-
tremely expensive for many programs. We can give the search a
kindofheadstartbyfindingasimplewaytocharacterizethetypes
ofstatesthatmaydeadlock.Aconvenientwaytodescribeastate
is by itscontrol point. The control point of a state is simply the set
of last issued actions from each process:
Ctrl(/angbracketleftA,I,M/angbracketright)={a∈I:∀a/prime∈Ipid(a),a/prime≤poa}.
Ifweonlyprovidethelastissuedactionforasubsetofprocess,we
obtain a partial control point that describes the collection of states
whichincludeitasasubsetoftheircontrolpoints.Definition5.3
augments the problem statement in Definition 5.2 to ask for a
deadlock state that matches a partial program point D(also called
a deadlock candidate).
Definition 5.3 (Constrained deadlock discovery problem).
∃q∈Σq0
δ,D⊆Ctrl(q)∧Deadδ(q)
6 DEPENDENCY GRAPH
This section presents a technique for generating a sound set of
deadlockcandidates D(A)forA.Thesoundnesspropertyaccording
to Definition 5.3 is formally stated in the following theorem.
Theorem 6.1 (Deadlock candidates sound). For all states q∈
Σq0
→,I fDead→(q), then∃d∈D(A),d⊆Ctrl(q).
Wegenerate D(A)bydetectingcyclesinagraph (N,E)where
N=A∪{⊥p:p∈P(A)}is the set of nodes and E:N×Nis the
set of edges. The node ⊥pis used to explicitly represent the end of
processpinthegraph.Anedge (a,a/prime)∈Erepresentsapotential
communicationdependencyof a/primeonainsomeexecutionof A.A
proofthatourtechniquesatisfiesTheorem6.1,alongwithproofs
fortheothertheoremsstatedinthispaper,isgivenintheappendix
of the full paper [2].
Beforepresenting thedependency graph,we describehow one
of its cycles can represent a deadlock. This not only motivates the
rules for adding edges to the graph, but also leads to a preciseunderstanding of the type of cycle the analysis must report andthe types it can ignore. This is important because the graphs we
21build may contain a huge number of cycles which are expensive to
enumerate.Themorewecanignore,themoreefficientouranalysis
will be.
Fix a deadlock state q∈Σq0
→with control point D=Ctrl(q). For
each process p∈P(A), there is an action a∈Dwithp=pid(a).
Wewilldefineafewnewtermsthatallowustotalkaboutwhy ais
blockingpfrom progressing in the state q.
First,wecall athedeadlockaction forp.Next,let a/primebetheearliest
actionin pthatisissuedin qbutnotmatchedwith a/prime≤moa.W e
calla/primetheorphanedaction forp.Finallylet a/prime/primebeanactionthatis
not issued in qbut would allow pto progress if it is matched with
a.Wecalla/prime/primetheparentaction.Iftheparentactiondoesnotexist,
it is represented in the graph by a ⊥node (discussed more below).
Wewillusethefollowingdefinitiontotranslatetheseconceptsto
the context of a path of edges in E.
Definition 6.2 (Deadlock path). Let(a0,a1),...,(an−1,an)bea
path of edges in E. This path is a deadlock path for the process
p∈P(A)if
(1)pid(a0)/nequalpand
(2)pid(ai)=pfor alli∈{1...n}and
(3) for some i∈{1...n−1},ai∈W(A)∪B(A).
Inadeadlockpath (a0,a1),...,(an−1,an)fortheprocess p,a0
anda1are interpreted as parent and orphan actions of p. The edge
connecting them represents the possibility that a1may depend
ona0being issued and available to match to complete in some
execution.Theearliestblockingactionissuedby pandcontained
in the path is interpreted as the deadlock action of p.
Definition6.2requiresthatthedeadlockactionnotbethelast
actioninthepath.Thisisbecauseadeadlockcycleisconstructedby
composingthedeadlockpathsoftwoormoreprocesses.Inother
wordsanin the deadlock path of pwill be the parent action in
a different deadlock path for some process p/prime/nequalp. The deadlock
actioncannotalsobeaparentactionbecausethedeadlockaction
is issued and ready to match by definition.
Definition6.3(Deadlockcycle). Acycleofedgesin Eisadeadlock
cycleifitcanbeconstructedfromasetofdeadlockpathswhereeach
process in the program contributes at most one path. Additionally,
theorphanedactionofeachdeadlockpathmustnotbeacompatible
match for the orphaned action of any other deadlock path in the
cycle.Otherwise,thepotentialdeadlockstatewouldquicklyunwind
by matching the two issued orphaned actions.
The candidate of a deadlock cycle is the set of deadlock actions
fromitspaths.Weconstruct D(A)byextractingthecandidatefrom
each deadlock cycle in the graph. The proof of Theorem 6.1, re-
ferredto thefull paper[ 2],shows thatfor everyfeasible deadlock
state,thereisacorrespondingcyclein EthatconformstoDefini-
tion6.3andyieldsamatchingpartialcontrolpoint.Thefirststep
toconstructing Eistoknow which actionscanmatchtogetherin
an execution of A.
Definition 6.4 (Potential matches). For an action a∈A,M(a)
denotes the set of actions that can be matched with ain some
transition between reachable states of A. More precisely, if M(q)
denotes the matched set in the state q, then
M(a)={a/prime:∃q,q/prime∈Σq0
→,q→q/prime∧{a,a/prime}⊆M(q/prime)\M(q)}\{a}.Note that fully determining Mis as hard as the deadlock discov-
ery problem itself. Fortunately, Mmust only be over approximated
to ensurethat thewhole analysisis sound.A simple overapproxi-
mation would include every compatible match of the action ain
M(a). However, the analysis presented in this paper uses the more
preciseapproximationgivenin[ 15]whichresultsinfewerspurious
cycles.
Definition 6.5 (Edges). An edge (a,⊥pid(a))is added to Efor
everya∈A. Otheredges areadded between twoactions a,a/prime∈A
according to the following rules:
(1) Ifa<moa/primethen(a,a/prime)∈E.
(2) Ifa/prime∈M(a), then(a,a/prime),(a/prime,a)∈E.
(3)Ifa,a/prime∈R(A)such that a<poa/prime∧src(a)=∗∧src(a/prime)/nequal∗,
then(⊥src(a/prime),a/prime)∈E.
(4)Ifa∈S(A)anda/prime∈R(A)such that dst(a)=dst(a/prime)and
src(a/prime)=∗, then(⊥dst(a),a)∈E.
Rule one of Definition 6.5 is an obvious preservation of the
semantics presented in Section 4. It is necessary for connecting
deadlockactionstootheractionsinthetailofadeadlockpath.It
also ensures that wait actions (often a deadlock action) have an
incoming edge from their associated message request (often an
orphaned action).
The rest of the rules ensure that parent actions are connected to
orphan actions in any scenario. The most obvious occurs in rule
two whenthe actionscan form amatch. Theedge isbidirectional
becausewedon’tknowwhichactionwillbetheorphanedaction
and which will be the parent action in a given deadlock.
Rules three and four add edges to encode the possibility of mes-
sagestarvation.Messagestarvationoccurswhenwildcardreceive
actionsarematchedwithsendactionsinanunintendedwaythat
leavessubsequentsendandreceiveactionswithoutanypotential
future matches. In this type of deadlock the parent action does not
existintheprogram(theorphanedactioniswaitingforanaction
that will never be issued). The added ⊥node at the end of every
process takes the place of the parent action in these cases.
Notethatwedonotneedaruleforaddinganedgefrom ⊥nodes
towildcardreceiveactionsbecauseifawildcardreceiveactionis
starved,thentheresultingdeadlockwouldhavebeendeterministic.
There is no need for analysis in this case, as the deadlock occurs
no matter how you schedule the program.
These rules will inevitably generate graphs with many spurious
cyclesthatobviouslydonotcorrespondtorealdeadlockstates.For
example,thesecondrulealoneformsatrivialcyclebetweentwo
potentially matching actions. We only want to enumerate cycles
that match Definition 6.3.
By default, Johnson’s algorithm for enumerating the elementary
cyclesofadirectedgraph[ 18]willenumerateallofthespurious
cycles. Algorithm 1 presents a simple boolean function that can be
added to Johnson’s algorithm to ensure only deadlock cycles are
visited.
Johnson’s algorithm searches for cycles in one strongly con-
nected component at a time according to a user-defined order. We
extend≤potoatotalorderoverthenodesinthegraph.Thecompo-
nentcontainingtheleastnode sissearchedfirstand sisvisitedfirst.
The global variable stackmaintains a normal depth first search
stack of visited nodes.
22Algorithm1 Determinewhethertheedge (v,w)canpossiblyreach
a deadlock cycle starting at s
1:procedure DeadlockEdge( v,w,s)
2:ifpid(v)=pid(w)then
3: returntrue
4:ifblock_count (stack,pid(v))=0then
5: returnfalse
6:ifblock_count (stack,pid(v))=1∧v∈W(A)∪B(A)
then
7: returnfalse
8:if∃a∈orphaned (stack),can_match (a,w)then
9: returnfalse
10:ifw/nequalsthen
11: return∀a∈stack,pid(a)/nequalpid(w)
12:returnfalse
Theresultofthechosenorderisthat sisalwaystheorphaned
action of the first deadlock path visited by the algorithm. Our spe-
cialized depth first search visits the successor wof the current
nodevwhen DeadlockEdge( v,w,s) returnstrue. This ensures that
the stack is always extending to a valid deadlock path according
to Definition 6.2.
Theblock_count functionreturnsthenumberofblockingac-
tions in a given process that have been visited by the current stack.
Thecan_match functiondetermineswhethertwoactionsmayform
acompatiblematchbasedontheirtypesandendpoints.Finally,the
orphaned functionreturnstheorphanedactionfromeachdeadlock
path in the current stack.
Lines2-3ofAlgorithm1allowthetailofthecurrentdeadlock
path on the stack to be extended along the same process (rule
one in Definition 6.2). If the condition on line 2 is false, then v
andware the parent and orphaned actions for a new deadlock
path. Lines 4-7 ensure that the current deadlock path contains adeadlock action that is not also a parent action for
w(rules two
andthreeinDefinition6.2).Lines8-9ensurethatorphanedactions
cannot match other orphaned actions (Definition 6.3).Lines 10-11
ensure that each process only contributes one path to the cycle
(also Definition 6.3). The final case occurs when wis equal to sand
a cycle is formed.
Inourimplementation,wealsoensurethatduplicatedeadlock
candidates are not reported by keeping track of how actions are
orphaned.Ifthetailofalongdeadlockpathcanreachanorphan
action in another process from two different parent actions, it is
simple to only enumerate one such deadlock cycle. This is left out
of Algorithm 1 for clarity.
7 ABSTRACT SEMANTICS OF CONCURRENT
TRACE PROGRAMS
Thissectiondefinesanabstractmachine /hatwideF(A)=/angbracketleftQ,q0,→abs/angbracketrightthat
augmentsthesemanticsofCTPstoefficientlyfilterawayinfeasible
deadlock candidates. This filtering is an important stage in theanalysis because it can drastically reduce the number of calls tothe SMT solver. The abstract transition relation
→absis shown
inFigure6withthebarriertransitionomittedasitisunchangedIssue-Send Transition
a∈S(A)\I<−1po[a]⊆I(<−1po[a]∩(W(A)∪B(A)))⊆M
s=(s(id(a)−1)pid(a)∗dst(a))
/angbracketleftA,I,M/angbracketright→/angbracketleftA∪{s},I∪{s,a},M/angbracketright
Issue-Other Transition
a∈A\Ia/nelementS(A)<−1po[a]⊆I
(<−1po[a]∩(W(A)∪B(A)))⊆M
/angbracketleftA,I,M/angbracketright→/angbracketleftA,I∪{a},M/angbracketright
Match-Send-Recv Transition
a,a/prime∈(I\M)a∈S(A)a/prime∈R(A)dst(a)=dst(a/prime)
src(a/prime)=src(a)(<−1mo[a]∪<−1mo[a/prime])⊆M
/angbracketleftA,I,M/angbracketright→abs/angbracketleftA,I,M∪{a,a/prime}/angbracketright
Match-Wait Transition
a∈I\Ma∈W(A)
s=(s(id(req(a))−1)pid(req(a))∗dst(req(a)))
req(a)∈M∨(req(a)∈S(A)∧s∈M)
/angbracketleftA,I,M/angbracketright→abs/angbracketleftA,I,M∪{a}/angbracketright
Figure 6: Transition Rules for Abstract Semantics.
from→.Inthistransitionrelationwecreateadedicated wildcard
endpointfor each source process. This eliminates the possibility of
message starvation.
TheIssue-Send transition generates a fresh wildcard send for
thenewendpointandissuesitalongsidetheoriginalsendaction.A
wait on the original send action is allowed to match in the Match-
Waittransition if either the original send orthe wildcard send has
beenmatched.Thewildcardsendisonlyallowedtomatchwildcard
receiveactionsissuedbythedestinationprocessandtheoriginal
send action is only allowed to match deterministic receive actions.
We filter a deadlock candidate Dby deriving a CTP ADthat
containstheactionsin D,theactionsprocessorderedbeforeactions
inDand all of the actions in other processes:
AD=/uniondisplay
a∈D≤−1
po[a]∪/uniondisplay
p/nelementP(D)Ap
We then attempt to execute /hatwideF(AD)to determine whether
∃q∈Σq0
→abs,D⊆Ctrl(q)∧Dead→abs(q)
NotethatthisisjustDefinition5.3withtheabstracttransition
relation substituted in. If the abstract execution is able to issue
everyactionin D,thenthecandidatemayrepresentarealdeadlock
and it is added to the set of candidates to be encoded as an SMT
formula. Otherwise, the candidate is infeasible and is discarded.
23Match order/logicalanddisplay
a∈AD/logicalanddisplay
a/prime∈<−1mo[a](ca=⇒ca/prime)∧ta/prime<ta
Queue Order/logicalanddisplay
a∈S(AD)∪R(AD)/logicalanddisplay
a/prime∈<−1qo[a]ma/prime<ma
Barriers/logicalanddisplay
a∈B(AD)/logicalanddisplay
a/prime∈Bgrp(a)(AD)ta=ta/prime
Matches/logicalanddisplay
a∈S(AD)∪R(AD)(ca=⇒/logicalordisplay
a/prime∈MD(a)\OMATCH(a,a/prime))
Reach/logicalanddisplay
a∈D/logicalanddisplay
a/prime∈<−1mo[a]\Oca/prime
Deadlock/logicalanddisplay
a∈D∪O¬ca
No matches/logicalanddisplay
a∈O/logicalanddisplay
a/prime∈MD(a)ca/prime
Figure 7: Constraints in the formula F
The abstract machine is sound if it never discards a reachable
control point. Let the set of reachable control points from a state q
and a transition relation δbeCq
δ.
Cq
δ={Ctrl(q/prime):q/prime∈Σq
δ}
Theorem7.1statesthatthereachablecontrolpointsoftheab-
stractmachinesubsumesthereachablecontrolpointsofthecon-
crete machine. Theorem 7.2 states that if the abstract machine
cannotissueeveryactioninthedeadlockcandidateinoneexecu-
tion, it will not be able to issue them all in any execution. Together
these theorems prove that the candidate Dcan be filtered away in
a single execution of the abstract machine when it fails to issue all
of the actions in D.
Theorem7.1(Abstractcandidatesimulation). Letq∈Σq0
→
andq/prime∈Σq0
→absbe a concrete and abstract state reachable from
the start state q0.I fCtrl(q)=Ctrl(q/prime), then for all control points
D∈Cq
→, it follows that D∈Cq/prime
→abs.
Theorem 7.2 (Abstract deadlock deterministic). Letq∈
Σq0
→absbe a reachable abstract state with Dead→abs(q).I fD/notsubseteql
Ctrl(q), then for all q/prime∈Σq0
→abs,D/notsubseteqlCtrl(q/prime).
8 SMT ENCODING
If/hatwideF(AD)isabletoissueeachactioninthecandidate D,thenitis
usedtoconstructanSMTformula F.Asatisfyingassignmentfor
Fcan be used to construct a witness execution for the deadlock
candidate. If Fis unsatisfiable, then there is no feasible deadlock
statethatcontains Daspartofitscontrolpoint.Theencodingis
anextensionoftheonedesignedbyHuangetal.[ 16]forfinding
zero-buffer compatible executions of MPI programs.
LetMDbe an over approximated set of match pairs for AD.
For each action a∈AD, the encoding creates an integer variabletato hold its completion timestamp in the witness execution. If
a∈S(AD)∪R(AD), then the encoding also creates an integer
variablematoreferencethetimestampoftheactionthatmatches a.
Addtionally, wais used as another name for twwherew∈W(AD)
anda=req(w).Thenewencodingaddsabooleanvariable cafor
everyactionthatistrueif amustbeissuedandcompletedinthe
witness execution.
The rulesfor theencoding are shownin Figure 7.The Match
orderandQueueorderconstraintspreservethemeaningof <mo
and<qointheencoding.Anactioncanonlycompleteifits <mo
predecessors have completed and the timestamps must reflect that.
Additionally, matches must conform to the non-overtaking guaran-
tee of MPI executions. In all cases, constraints are omitted when
theyareobviouslyredundantwithrespecttoexistingconstraints
and the transitivity of <and=over the integers.
The Barriers constraint encodes the inter-process synchroniza-
tionbehaviorofbarrieractionsbyassertingthatgroupscompleteat
thesametime.Allothertimestamps,including maforeacha∈AD,
are asserted to be distinct.
The Matches constraint forces send and receive actions to find
a match if they must complete in the witness execution. Some
matchesarenotallowedassumingtheexecutionendsinadeadlock
parked at the actions in D. Specifically, let Odenote the set of
orphaned send and receive actions for the candidate D.
O={a∈AD:∃a/prime∈W(AD)∩D,a=req(a/prime)}
The Matches constraint purposely excludes the actions in Oas
they should not be matched in the witness execution.
InSection4,asendandreceiveactionwerematchedbycopying
them from the issued set into the matched set together. After that,
theirwaitactionswereallowedtocomplete.Thissemanticmeaningispreservedintheencodingbythe
MATCH(a,a/prime)constraintwhich
expands to
ca/prime∧ta=ma/prime∧ta/prime=ma∧ta<wa/prime∧ta/prime<wa.
First,thisconstraintrecordsthat a/primeiscompletedbythematch.
Second, the actions complete together by recording the timestamp
oftheotherinthe mvariables.Finally,bothtimestampsarerequired
to precede the timestamps of both wait actions. Note that in theinfinite-buffersetting,thewaitforthesendactiondoesnotexist
and so one of these constraints is omitted.
TheReachconstraintassertsthateverypredecessoroftheac-
tionsinDiscompletedexcepttheactionsin O.Inotherwords,it
asserts that the deadlock Dis reachable.
TheDeadlock constraint simply asserts that the deadlock ac-
tions inDand the orphaned actions in Oare not complete. The
No matches constraint ensures that any issued actions that could
untangle the deadlock are complete, thus forcing them to findmatches that exclude the deadlock and orphaned actions. Givena satisfying assignment of the variables in
F, the witness execu-
tioncanbeconstructedfromthe ttimestampvariableswhilethe
matches made can be recovered by consulting the mvariables.
9 EXPERIMENTS
The runtime trace for our approach is observed through code in-
strumentation.TheMPICHlibraryisusedfortheactualruntime
[23].ThetranslationofanobservedMPIexecutiontracetoaCTPis
24Table 1: Tests on Selected Benchmarks
Name #Procs #Calls BDTmISP Tm MOPPER Tm MOPPER-o Tm Aislinn Tm
Monte4350√0.037s 0.223s 0.244s 0.258s 1.665s
∞ 0.002s 0.957s 0.496s 0.488s 1.672s
8750√0.055s TO 0.503s 0.619s 186.190s
∞ 0.007s TO 1.357s 1.870s 175.042s
161550√0.206s TO 2.406s 2.302s TO
∞ 0.052s TO TO TO TO
Integrate836∞ 0.002s >1000s 0.328s 0.303s 3.832s
1046∞ 0.006s TO 23.186s 0.392s 16.028s
1676∞ 0.01s TO TO 2.050s TO
Diffusion2D4520√0.325s TO N/AcN/Ac1.245s
∞ 0.049s 32.005s 0.521s 0.486s 1.232s
81080√0.761s TO N/AcN/Ac135.273s
∞ 0.06s TO TO 0.792s 86.112s
Floyd8120∞ 0.071s TO 3.472s 0.623s TO
16256∞ 0.133s TO 24.814s 1.256s TO
GE856∞ 0.001s 1.054s 1.172s 1.809s N/Aa
16120∞ 0.004s 1.426s 3.972s 5.139s N/Aa
Heat16312∞√0.457s TO 3.092s 2.205s N/Ab
32632∞√1.359s TO 5.331s 5.068s N/Ab
IS648280 0.03s45.471s 0.621s 0.599s N/Ab
∞ 0.01s46.565s 0.589s 0.602s N/Ab
128166000.014s148.251s 1.394s 1.530s N/Ab
∞ 0.024s150.570s 1.767s 1.539s N/Ab
256322400.036s561.294s 8.328s 7.731s N/Ab
∞ 0.07s476.516s 12.714s 4.367s N/Ab
aAislinn aborts the verification for unknown exceptions after 2 minutes of running.
bAislinn does not support some MPI calls in the program.
cMOPPER is not launched because the process of trace generation finds a deadlock.
largelytrivialandproceedsasexpected.Anythingoutsidemessage
passingasdefinedinthispaperisignored.Somecaremustbetaken
with collective operations but it is all mechanical.
The SMT solver Z3 is used by our approach for validation [ 6].
TheexperimentsarerunonanInteli5QuadCoreprocessorwith
8 GB of memory running Ubuntu 14.04 LTS. A time limit of 30
minutes is set for each test. The test aborts the verification process
ifitdoesnotcompletewithinthetimelimit.Therestofthissection
compares our approach to other existing tools.
9.1 Results
Theexperimentscomparetheperformanceofourapproachwith
three state-of-the-art MPI verifiers MOPPER, a SAT based tool [ 10,
11],ISP,adynamicanalyzer[ 25,30],andAislinn,anotherdynamic
analyzer[ 4].MOPPERisatracebasedverifierthatchecksthesame
behaviors described in this paper. Therefore, the comparison toour approach is direct. The experiments compare the results of
two versions of MOPPER, the original tool [ 11] and the optimized
tool [10]. ISP is a general verification tool that is not specialized
to only deadlock but includes races and user defined assertions.
The comparison to our approach is intended to convey the benefit
of specialization to just deadlock and suggest that similar gainsmaybefoundinspecializingtojustdataraceorassertions.Aislinn
is a dynamic verifier that covers two buffering choices for each
send operation in a program. In other words, Aislinn detects more
behaviors than those in the infinite buffer semantics (buffering
provided for all sends) and the zero buffer semantics (no buffer for
anysend).Inordertocomparetoourapproach,wesetthebufferingmodeforAislinnto“eager”(equivalenttotheinfinitebuffersetting)
and “rendezvous” (equivalent to the zero buffer setting).
The results of the comparison are in Table 1. The column “B”
represents the buffering setting in the runtime. The column “D”
indicatestheexistenceofdeadlocks.Thecolumn“Tm”isthetimeofrunningourapproachandconstraintsolvingifnecessary.The“Tm”
column for ISP is the running time of dynamic analysis. The “Tm”
columnsforMOPPERandoptimizedMOPPERareforconstraint
generationandsolving.The“Tm”columnforAislinnistherunningtimeofthetoolforeither“eager”modeor“rendezvous”mode.The
notation “TO” means “timeout” (exceeding the time limit setfor
each test). The notation “N/A” means “not available”.
259.2 Benchmarks
Monte[5]implementstheMonteCarlomethodbyamaster-slave
model. The program has a deadlock trace under the zero buffer
setting.
Integrate[1]implementsthealgorithmthatcomputesanintegral
of thesinfunction by using a large number of wildcard receives to
match the sends from multiple sources.
Diffusion2D [1]hasaninterestingcomputationpatternthatuses
barriers to “partition” the message communication into several
sections.Amessagefromasendcanbeonlyreceivedinacommon
section. Deadlock occurs under the zero buffer setting.
Floyd[33] implements the shortest path algorithm for all the
pairs of nodes. The message communication is only built between
any two successive processes.
GE[33] is a message passing implementation for Gaussian Elim-
ination.Messagesarecommunicatedbyissuingseveralwildcard
receives on each node.
Heat[24] implements the solution of the heat conduction equa-
tion. The communication pattern for this benchmark contains sev-
eral message starvation deadlocks.
IS[3]implementsthesolutionofintegersorting.Themessage
passing in this benchmark is deterministic.
9.3 Discussion
Thecomparisonoftimecosttothethreeexistingstate-of-the-art
tools demonstrates that our approach is much more efficient for
deadlock detection in many cases. For the benchmark programs
with a small number of processes (e.g., Montewith 4 processes), all
thetoolsareabletofinishthetestsveryquickly.However,asthe
thenumberofprocessesgrows,implyingthatthebenchmarkhas
a much higher degree of non-determinism, ISP and Aislinn both
have unexpectedly high time costs for the tests (e.g., Floydwith 16
processes),andeventimeoutforsometests.Overall,MOPPERis
much quicker than the other two tools. The optimized MOPPER is
evenmoreefficient,especiallyforlarge,complicatedbenchmarks
(e.g.,Integrate with 16 processes). However, it still suffers from the
scalabilityproblemforafewtests(e.g., Montewith16processes).In
contrast, our approach is able to finish most tests under a second.
9.4 Effectiveness of Filtering
Table 2 shows the effectiveness of the cycle detection algorithm
andtheabstractmachineasafilteringmechanism.Eachtestshown
inTable2is anexhaustive enumeration onthe detected deadlock
candidatesbyourapproach.Thetesthereisdifferentfromthose
in Table 1 as the enumeration does not terminate even if a feasible
deadlock is validated. Therefore, some tests in Table 2 may takemuch more time to run. The times are not recorded in Table 2
astheyaremeaninglessforactualdeadlockanalysis.Thecolumn
“#Edges”recordsthenumberofedgesinthedependencygraph.The
column “#Instances” records the number of deadlock candidates.
The column “#Filtered” records the number of deadlock candidates
filtered away by the abstract machine. The column “#Deadlock”
records the number of real deadlocks.
ThenumbersshowninTable2indicatethattheabstractmachine
in our analysis has a high precision for filtering out infeasibledeadlocks. The percentage of filtered deadlock instances amongTable 2: Enumerating All Candidates on Benchmarks
Name #ProcsB#Edges#Instances #Filtered #Deadlock
Monte 4090 9 7 1
Monte 80286 19 13 1
Monte 160966 44 30 1
Integrate 8∞246 0 0 0
Integrate 10∞370 0 0 0
Integrate 16∞886 0 0 0
Diffusion2D 40385 16 13 3
Diffusion2D 4∞385 0 0 0
Diffusion2D 801135 46 45 1
Diffusion2D 8∞1135 0 0 0
Floyd 8∞1170 0 0 0
Floyd 16∞2754 0 0 0
GE 8∞186 0 0 0
GE 16∞522 0 0 0
Heat 16∞1458 104 102 2
Heat 32∞3458 454 452 2
IS 640442 0 0 0
IS 1280890 0 0 0
IS 25601786 0 0 0
all the detected instances varies for the test. But if an instance isnot filtered, then it is often a real deadlock. The modified cycle
detectionalgorithmisalsoeffectiveatenumeratingasmallnumber
of cycles for very large graphs with a huge number of spurious
cycles.
10 RELATED WORK
Muchoftheliteratureonpredictiveprogramanalysisfocuseson
detecting as many errors as possible from a single observed execu-
tion [8,20]. As mentioned in Section 1, the analysis presented here
ismaximallypredictiveforsingle-pathprogramsbutcannotreason
about messages that are issued in a schedule-dependent manner.
Instead,thispaperfocusesonimprovingtheefficiencyofanSMT
basedanalysisforsingle-pathprogramswhileleavingextensions
to more general programs as future work.
The approach in this paper is inspired by several works. Joshi
et al. proposed a method for multi-threaded Java programs by first
detecting potential lock dependency cycles with a imprecise dy-
namicanalyzerandthenfindingrealdeadlocksbyarandomthread
schedulerwithhighprobability[ 19].Therefiningstrategyofthe
work inspires the staged approach taken in this paper, but the tool
presentedinthispaperisguaranteedtoreportadeadlockifitexists
in the single-path program.
Sherlockisatoolthatusesconcolicexecutionfordeadlockdetec-
tion in Java programs [ 8]. The key idea is similar to our approach:
findingpotentialdeadlocks,andthensearchingforafeasiblesched-
ule that leads to the deadlock. The difference is that Sherlock re-
peatedly finds alternate schedules through solving constraints that
describenewpermutationsofpreviouslyobservedschedulesrather
than leveraging an abstract machine to filter out false deadlocks.
26ApreciseSMTencodingtechniquewasproposedbyHuanget
al. for verifying properties over MCAPI programs containing mes-
sagerace[ 17].Theencodingdoesnotrequireaprecisematchset
and wasextended tochecking zerobuffer incompatibility forMPI
programs[ 16].This techniqueisadapted forvalidatingdeadlocks
in this paper.
The POE approach is a dynamic partial order reduction solu-
tion [9] for MPI program verification [ 25,30]. The approach was
extended to POE MSE, which first uses a precise happens-before
relation to find the potential sends that may cause different behav-
iorsbased onthe initialtrace, thenreplays theexecutionat each
potentialsendwithadifferentchoice,i.e.bufferingthesendinstead
of matching it [31].
MOPPER is an MPI deadlock detector based on boolean satis-
fiability encoding [ 10,11]. While the solution is precise, the size
oftheencodingiscubicmeaningitonlyscalestoalowdegreeof
message non-determinism.
CIVL isa model checker thatuses symbolic executionto verify
anumberofsafetypropertiesofvarioustypesofconcurrentpro-
grams including message passing programs [ 28,29,34]. The tool is
outperformed by MOPPER.
AnextensiontothemodelcheckerSPIN[ 14],isMPI-SPINthatis
specifictoverifyingMPIprograms[ 26,27].Sinceamassivenumber
of states are explored, the work is not scalable.
Böhm et al. provide an approach that aims to find deadlocks for
an MPI program under both environments of synchronization and
no synchronization [ 4]. The approach first uses standard partial
orderreductiontofinddeadlocksassumingtheenvironmenthas
no synchronization. It then uses an algorithm to search missed
deadlocks by enforcing synchronization in the basic operations
such as send and collective operations.
MPI-Checkerisastaticanalyzerbasedonabstractsyntaxtree
ofthesourcecodeofMPIprograms[ 7].Thetoolisabletocheck
manyerrorsinaprogram,However,itislimitedtocheckdeadlocks
caused by complicated semantics of communication.
ParTypes is a type-based approach for verifying MPI programs
bydevelopingaprotocollanguageforatypesystem[ 22].Sincethe
approach is able to avoid traversing the state space, the analysis is
scalable for large programs.
Umpire is an approach of runtime verification for checking mul-
tipleMPIerrorssuchasdeadlockandresourcetracking[ 32].The
errorcheckingistakenby spawningonemanagerthreadandsev-
eral outfielder threads in the execution of an MPI program. An
extensiontoUmpireisMarmot[ 21].Theworkusesacentralized
serverinsteadofmultiplethreadsforerrorchecking.Anotherex-
tension to Umpire is MUST [ 12,13]. The structure of MUST allows
the users to execute the error checking either in an applicationprocess itself or in extra processes that are used to offload these
analyses.However,just likeUmpireand Marmot,theapproachis
neither sound nor complete for deadlock detection.
11 CONCLUSION
This paper presents a new approach that automatically detects
deadlocks in single-path MPI programs after observing a singleexecution. The approach leverages a simple characterization of
deadlock to efficiently detect deadlock candidates in a dependencygraph. An abstract machine is used to quickly disregard many
infeasible candidates while the remaining candidates are precisely
validatedbyanSMTsolverwithanefficientencodingfordeadlock.
The approach is sound and complete for deadlock detection in any
single-path MPI program on a given input. Experiments show that
thenewapproachfinishestypicalbenchmarkswithinonly1second
whiletheotherstate-of-the-artMPIverifierstimeout.Futurework
considers more filtering techniques and extending the approachto support multiple-path MPI programs with more complicated
structures.
REFERENCES
[1] FEVS benchmark. http://vsl.cis.udel.edu/fevs/index.html.
[2]The full version of paper. https://bitbucket.org/byu-vv/mpi-deadlock-
patterns/raw/815d5f224d43424b14b3c30f1a37ba19de75ad12/paper-long.pdf.
[3]David Bailey, E Barszcz, Barton J.T, Browning D.S, Carter R.L, Dagum D, Fatoohi
R.A, Paul Frederickson, Lasinski T.A, Robert Schreiber, Horst Simon, Venkat
Venkatakrishnan,andWeeratungaK. Thenasparallelbenchmarks. International
Journal of High Performance Computing Applications, 5:63–73, 09 1991.
[4]Stanislav Böhm, Ondrej Meca, and Petr Jancar. State-space reduction of non-
deterministically synchronizing systems applicable to deadlock detection in MPI.
InFM 2016: Formal Methods - 21st International Symposium, Limassol, Cyprus,
November 9-11, 2016, Proceedings, pages 102–118, 2016.
[5] J. Burkardt. MPI Examples.
[6]Leonardo de Moura and Nikolaj Bjørner. Z3: An efficient SMT solver. In TACAS,
volume 4963, pages 337–340. Springer, Heidelberg, 2008.
[7]Alexander Droste, Michael Kuhn, and Thomas Ludwig. Mpi-checker: static
analysisforMPI. In ProceedingsoftheSecondWorkshopontheLLVMCompiler
InfrastructureinHPC,LLVM2015,Austin,Texas,USA,November15,2015,pages
3:1–3:10, 2015.
[8]Mahdi Eslamimehr and Jens Palsberg. Sherlock: scalable deadlock detection for
concurrent programs. In Proceedings of the 22nd ACM SIGSOFT International
Symposiumon Foundationsof SoftwareEngineering,(FSE-22), HongKong,China,November 16 - 22, 2014, pages 353–365, 2014.
[9]
CormacFlanaganandPatriceGodefroid. Dynamicpartial-orderreductionfor
model checking software. In POPL, pages 110–121, 2005.
[10]Vojtech Forejt, Saurabh Joshi, Daniel Kroening, Ganesh Narayanaswamy, andSubodh Sharma. Precise predictive analysis for discovering communication
deadlocksinMPIprograms. ACMTrans.Program.Lang.Syst.,39(4):15:1–15:27,
2017.
[11] Vojtech Forejt, Daniel Kroening, Ganesh Narayanaswamy, and Subodh Sharma.
Precise predictive analysis for discovering communication deadlocks in MPI
programs. In FM2014:FormalMethods-19thInternationalSymposium,Singapore,
May 12-16, 2014. Proceedings, pages 263–278, 2014.
[12]Tobias Hilbrich, Joachim Protze, Martin Schulz, Bronis R. de Supinski, and
MatthiasS.Müller. MPIruntimeerrordetectionwithMUST:advancesindead-
lock detection. In SC Conference on High Performance Computing Networking,
Storage and Analysis, SC ’12, Salt Lake City, UT, USA - November 11 - 15, 2012,
page 30, 2012.
[13]Tobias Hilbrich, Martin Schulz, Bronis R. de Supinski, and Matthias S. Müller.MUST: A scalable approach to runtime error detection in MPI programs. In
Tools for High Performance Computing 2009 - Proceedings of the 3rd International
Workshop on Parallel Tools for High Performance Computing, September 2009, ZIH,
Dresden, pages 53–66, 2009.
[14]Gerard J. Holzmann. The model checker SPIN. IEEE Trans. Software Eng.,
23(5):279–295, 1997.
[15]Yu Huang, Kai Gong, and Eric Mercer. An efficient algorithm for match pair
approximation in message passing. Parallel Computing, 91:102585, 2020.
[16]YuHuangandEricMercer. DetectingMPIzerobufferincompatibilitybySMT
encoding. NFM, 2015.
[17]YuHuang,EricMercer,andJayMcCarthy. ProvingMCAPIexecutionsarecorrect
using SMT. In ASE, pages 26–36, 2013.
[18]DonaldB.Johnson. Findingalltheelementarycircuitsofadirectedgraph. SIAM
J. Comput., 4(1):77–84, 1975.
[19]Pallavi Joshi, Chang-Seo Park, Koushik Sen, and Mayur Naik. A randomized
dynamicprogramanalysistechniquefordetectingrealdeadlocks. In PLDI,pages
110–120, 2009.
[20]Christian Gram Kalhauge and Jens Palsberg. Sound deadlock prediction. Pro-
ceedings of the ACM on Programming Languages, 2(OOPSLA):1–29, 2018.
[21]Bettina Krammer, Katrin Bidmon, Matthias S. Müller, and Michael M. Resch.
MARMOT:anMPIanalysisand checkingtool. In ParallelComputing:Software
Technology, Algorithms, Architectures and Applications, PARCO 2003, Dresden,
Germany, pages 493–500, 2003.
27[22]HugoA.López,EduardoR.B.Marques,FranciscoMartins,NicholasNg,César
Santos, Vasco Thudichum Vasconcelos, and Nobuko Yoshida. Protocol-based
verification of message-passing parallel programs. In Proceedings of the 2015
ACMSIGPLANInternationalConferenceonObject-OrientedProgramming,Systems,
Languages,and Applications,OOPSLA2015, partofSPLASH 2015,Pittsburgh,PA,
USA, October 25-30, 2015, pages 280–298, 2015.
[23] MPICH. High-Performance Portable MPI. http://www.mpich.org.
[24]Matthias S. Mueller, Ganesh Gopalakrishnan, Bronis R. de Supinski, David
Lecomber,andTobiasHilbrich. DealingwithMPIBugsatScale:BestPractices.
InAutomatic Detection, Debugging, and Formal Verification, 2011.
[25]Subodh Sharma, Ganesh Gopalakrishnan, and Greg Bronevetsky. A sound re-
duction of persistent-setsfor deadlock detection inMPI applications. In Formal
Methods:FoundationsandApplications-15thBrazilianSymposium,SBMF2012,
Natal, Brazil, September 23-28, 2012. Proceedings, pages 194–209, 2012.
[26] Stephen Siegel. Verifying parallel programs with MPI-Spin. In PVM/MPI, pages
13–14, 2007.
[27]Stephen F. Siegel. Model checking nonblocking MPI programs. In VMCAI, pages
44–58, 2007.
[28]StephenF.Siegel,MatthewB.Dwyer,GaneshGopalakrishnan,ZiqingLuo,Zvon-
imirRakamaric,RajeevThakur,ManchunZheng,andTimothyK.Zirkel. Civl:
The concurrency intermediate verification language. Technical Report UD-CIS-
2014/001, Department of Computer and Information Sciences, University of
Delaware, 2014.
[29]Stephen F. Siegel, Manchun Zheng, Ziqing Luo, Timothy K. Zirkel, Andre V.Marianiello, John G. Edenhofner, Matthew B. Dwyer, and Michael S. Rogers.CIVL: the concurrency intermediate verification language. In Proceedings of the
InternationalConferenceforHighPerformanceComputing,Networking,Storage
and Analysis,SC 2015,Austin, TX,USA, November15-20, 2015, pages61:1–61:12,
2015.
[30]Sarvani S. Vakkalanka, Subodh Sharma, Ganesh Gopalakrishnan, and Robert M.
Kirby. ISP:atoolformodelcheckingMPIprograms. In PPOPP,pages285–286,
2008.
[31]SarvaniS.Vakkalanka,AnhVo,GaneshGopalakrishnan,andRobertM.Kirby.
Precisedynamicanalysisforslackelasticity:Addingbufferingwithoutadding
bugs. InRecent Advances in the Message Passing Interface - 17th European MPI
Users’GroupMeeting,EuroMPI2010,Stuttgart,Germany,September12-15,2010.
Proceedings, pages 152–159, 2010.
[32]Jeffrey S. Vetter and Bronis R. de Supinski. Dynamic software testing of MPI
applicationswithumpire. In ProceedingsSupercomputing2000,November4-10,
2000, Dallas, Texas, USA. IEEE Computer Society, CD-ROM, page 51, 2000.
[33]Ruini Xue, Xuezheng Liu, Ming Wu, Zhenyu Guo, Wenguang Chen, Weimin
Zheng, Zheng Zhang, and Geoffrey M. Voelker. MPIWiz: subgroup reproducible
replay of mpi applications. In Proceedings of the 14th ACM SIGPLAN Symposium
on Principles and Practice of Parallel Programming, PPOPP 2009, Raleigh, NC, USA,
February 14-18, 2009, pages 251–260, 2009.
[34]Manchun Zheng, Michael S. Rogers, Ziqing Luo, Matthew B. Dwyer, andStephen F. Siegel. CIVL: formal verification of parallel programs. In 30th
IEEE/ACM International Conference on Automated Software Engineering, ASE
2015, Lincoln, NE, USA, November 9-13, 2015, pages 830–835, 2015.
28