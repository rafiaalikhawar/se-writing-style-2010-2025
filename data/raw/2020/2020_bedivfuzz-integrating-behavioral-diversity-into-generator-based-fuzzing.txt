BeDivFuzz: Integrating Behavioral Diversity into
Generator-based Fuzzing
Hoang Lam Nguyen
Humboldt-UniversitÃ¤t zu Berlin
Germany
nguyehoa@informatik.hu-berlin.deLars Grunske
Humboldt-UniversitÃ¤t zu Berlin
Germany
grunske@informatik.hu-berlin.de
ABSTRACT
A popular metric to evaluate the performance of fuzzers is branch
coverage.However,weargue thatfocusingsolelyoncoveringmany
differentbranches(i.e., the richness)isnotsufficient sincethema-
jority of the covered branches may have been exercised only once,
which does not inspire a high confidence in the reliability of the
covered code. Instead, the distribution of the executed branches
(i.e., theevenness) should also be considered. That is, behavioral
diversity is only given if the generated inputs not only trigger
manydifferentbranches,butalsotriggerthemevenlyoftenwith
diverseinputs.WeintroduceBeDivFuzz,afeedback-drivenfuzzing
technique for generator-based fuzzers. BeDivFuzz distinguishes
betweenstructure-preserving andstructure-changing mutations in
thespaceofsyntacticallyvalidinputs,andbiasesitsmutationstrat-
egytowardsvalidityandbehavioraldiversitybasedonthereceived
programfeedback.WehaveevaluatedBeDivFuzzonAnt,Maven,
Rhino, Closure, Nashorn, and Tomcat. The results show that Be-
DivFuzzachievesbetter behavioraldiversitythan thestateof the
art, measured byestablished biodiversity metrics, namely theHill
numbers, from the field of ecology.
KEYWORDS
Structure-aware fuzzing, behavioral diversity, random testing
ACM Reference Format:
HoangLamNguyenandLarsGrunske.2022.BeDivFuzz:IntegratingBehav-
ioral Diversityinto Generator-based Fuzzing.In 44th InternationalConfer-
enceonSoftwareEngineering(ICSEâ€™22),May21â€“29,2022,Pittsburgh,PA,USA.
ACM,NewYork,NY,USA,13pages.https://doi.org/10.1145/3510003.3510182
1 INTRODUCTION
Traditionally, fuzzing tools (e.g., [ 9,26,33,34,43,47,53]) have
beenusedtoevaluatethesoftwareundertest(SUT)withrespect
to security and robustness properties. Typically, vulnerabilities are
foundbyfeedingtheSUTmalformedinputs,potentiallyresulting
in unexpected program behavior, which can be identified usinge.g., memory and safety oracles [
29,37,41]. Since most of the
vulnerabilities emerge due to incorrect handling of unexpected
inputs,security-orientedfuzzersusuallytargettheinputparsing
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Â© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-9221-1/22/05...$15.00
https://doi.org/10.1145/3510003.3510182andprocessingstagesoftheSUT.Recently,thereisatrend[ 3,32,
35,45,51,54] to use fuzzers to test the actual core functionality of
the SUT, rather than the early input processing stages only. The
challengeoftestingthecorefunctionalityofaprogramthatexpects
complexstructuredinputsismainlyduetothefollowingproblems:
(1)The input must be syntactically valid (i.e., conform to the
expectedstructure/type)inordertobeparseablebytheSUT.
(2)The input must satisfy any additional semantic validity con-
straints(e.g.,assertionsor repOkmethods[ 27])toactually
reach the core program functionality.
(3)Thegenerated inputsmust exhibitsome sortof diversityin
order to trigger diverse behavior.
Thetechniquestargetingthisproblemtypicallyrelyonaninput
specification (e.g., a grammar) that describes the expected inputstructure to produce inputs of the expected format. Generator-
based fuzzers like Zest [ 32] follow an imperative approach, where
thetesterimplementsa generator programthatisabletoproduce
syntactically valid inputs. Zest uses code coverage and validity
feedbacktosearchforinputsthatexercisemanydifferentbranches
in the semantic analysis stages of the SUT. That is, the goal of Zest
istocoverasmuchofthesemanticprogrambehavioraspossible.
A more recent technique, RLCheck [ 35], utilizes reinforcement
learningtoautomaticallyguidethegeneratortowardshighinput
diversity,i.e., inputsthat exercise differenttraces. However,while
RLCheckisabletoproducealargenumberofdiverseinputsthat
triggerspecific behaviors, it fails to cover many different behaviors.
We are interested in a technique that is able to not only cover
many different behaviors, but also test these behaviors in a diverse
manner. That is, we aim for an even distribution of exercised be-
haviors, rather than focusing our testing effort solely on particular
behaviors. A simplified illustration of this idea can be found in
Figure1.Inthefigure,thegreyareasintheinputspacerepresent
thevalidinputs(i.e.,inputsthattriggerthecorefunctionalityofthe
SUT),whereasthewhiteareasrepresentotherinvalidinputs(e.g.,
inputsthatonlytriggererrorhandlingcode).Traditionalfuzzers
like AFL [ 53], as depicted in Figure 1.a, tend to produce malformed
inputs and hence only cover a small proportion of the valid be-havior. Further, the distribution of the triggered valid behaviormostly concentrates on the more likely branches. On the otherhand, validity-focused fuzzers like Zest and RLCheck (cf. Figure
1.b) either only focus on covering many different behaviors (but
not their diverse execution, indicated by grey areas with a low
concentration of green crosses) or disproportionally test particular
behaviorsonly(indicatedbythesmallareaswithahighnumberofgreen crosses). Our proposed technique, BeDivFuzz (cf. Figure 1.c),
avoids this problem by searching for many different valid inputs
while evenly testing the behaviors in a diverse manner.
2492022 IEEE/ACM 44th International Conference on Software Engineering (ICSE)
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Hoang Lam Nguyen and Lars GrunskeInput Space(a) Traditional Fuzzer (AFL, libfuzzer,...)
Input Space(b) Validity Fuzzer (Zest, RLCheck)
Input Space(c) Behavioral Diversity (BeDivFuzz)Behavior SpaceBranch Hit Counts/Call Frequencies
Likely Branches Rare Branches
Behavior SpaceBranch Hit Counts/Call Frequencies
Likely Branches Rare Branches
Behavior SpaceBranch Hit Counts/Call Frequencies
Likely Branches Rare Branches
Figure 1: Illustrative simplified motivation for BeDivFuzz. In the input space, the white and grey areas represent invalid and
validinputareasfortheSUT,respectively.Thegreencrossesrepresentvalidtestinputs,whiletheredcrossesrepresentinvalid
inputs.Inlinewith[39],weusebranchhitcountsandcallfrequenciesasanillustrativemetrictorepresentthebehaviorspace.
Inparticular,BeDivFuzzdistinguishesbetween structure-changing
andstructure-preserving mutations. Performing structure-changing
mutationsallowstosearchfornewprogrambehaviorthatisonly
triggered if the input satisfies particular structural properties. In
contrast, the structure-preserving mutations allow to target spe-
cific behavior of the code with different variants of the same input
structure,effectivelytestingthetargetedbehaviorinadiverseman-
ner. BeDivFuzz uses an adaptive mutation strategy that utilizesthe received program feedback to guide the search towards high
behavioral diversity. In order to determine the behavioral diversity
ofafuzzingcampaign,weproposeanovelmetricthatincorporates
both the number of covered branches and the branch execution
distribution over all unique traces.
NoveltyandContributions. Overall,weprovidethefollowing
key contributions:
â€¢WepresentBeDivFuzz,anovelfuzzingapproachthatgenerates
valid and behaviorally diverse inputs.
â€¢We propose to utilize Hill numbers [ 17], a common metric
forspeciesdiversityfromecology,toquantifythebehavioral
diversity of the covered branches by a fuzzing campaign.
â€¢We evaluate BeDivFuzz based on several fuzzing campaigns
withXMLandJavaScriptSUTs,namelyAnt,Maven,Closure,
Rhino, Nashorn, and Tomcat.
â€¢We provide the source code of BeDivFuzz and a replication
package of our results at https://github.com/hub-se/BeDivFuzz.
SignificanceoftheContributions. Weprovideanovelmetric
thatquantifiesthe behavioraldiversity ofafuzzingcampaignand
proposeatechniquethatimprovesuponthecurrentstate-of-the-art
w.r.t. to that metric. The proposed metric shifts the focus of simply1def generate_tree(depth=0):
2 value = random.randint(0, 10)
3 tree = BinaryTree(value)
4 ifdepth >= MAX_DEPTH:
5 return tree
6 ifrandom.choose([True, False]):
7 tree.left = generate_tree(depth+1)
8 ifrandom.choose([True, False]):
9 tree.right = generate_tree(depth+1)
10 return tree
Figure2:Asimplebinarytreegenerator.Adaptedfrom[35].
covering many behaviors (i.e., branch coverage) to diversely testing
manydifferentbehaviors.Thus,itwillpotentiallyserveasastepping
stone towards future systematic evaluations of a SUT with respect
to reliability and correctness after the termination of a fuzzing
campaign [6, 7], as desired in practical software engineering.
2 BACKGROUND
2.1 Generator-Based Fuzzing
Fuzzing (also known as fuzz testing) attempts to find bugs and
crashes in software through random input generation. A common
challenge in fuzzing is to produce test inputs for programs that ex-
pect complex structured inputs (e.g., compilers). Effectively testing
thesetypesofprogramsischallengingduetothefollowingreasons:
250
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. BeDivFuzz: Integrating Behavioral Diversity into Generator-based Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
(i)Thegeneratedinputsmustbe syntactically validinordertobe
successfully parsed by the program. (ii) The input must also satisfy
any additional semantic validity constraints in order to actually
exercisetheSUTâ€™scorefunctionality.(iii)Thetestinputshavetobe
diverseenoughtoexecuteavarietyofdifferentprogrambehavior.
Structure-awarefuzzerstypicallyapproachthisproblembyutilizing
domain-specificknowledgeabouttheexpectedinputtypeorformat.
Onewaytoprovidethisknowledgetothefuzzerisviaadeclara-
tive input specification (e.g., a grammar [ 2,14,16,18,30,39,48]).
Alternatively, the tester may write an imperative generator pro-
gramthatrandomlysamplessyntacticallyvalidinputs,anapproach
known as generator-based fuzzing [19,31,32]. For example, Fig-
ure 2 shows the pseudocode for a generator that produces random
binary trees, which will serve as the running example throughout
the paper. The function generate_tree first samples a random
integervaluebetween0and10(Line2)toinstantiatetherootnode
(Line 3). If a user-defined maximum depth has been reached, the
generatednodeisreturned(Lines4â€“5).Otherwise,thegenerator
non-deterministically decides whether to generate left and rightchild nodes, in which case
generate_tree is recursively called
(Lines 6â€“9). The output of the generator thus depends on the se-
quenceof randomchoices madeduringthegenerationprocess.In
the example, the sequence of random choices precisely determines
the shape of the binary tree and all the tree node values. As a con-
crete example, consider the following random choice sequence for
the call of generate_tree (MAX_DEPTH = 5):
Random choice â†’result Context
random.randint â†’3Root: node value (Line 2)
random.choose â†’False Root: generate left child? (Line 6)
random.choose â†’False Root: generate right child? (Line 8)
This sequence of random choices would result in a â€binary-treeâ€
consistingofasinglerootnodewiththevalue3andnochildnodes:
3
Togiveadifferentexample,considerthefollowingchoicesequence:
Random choice â†’result Context
random.randint â†’3Root: node value (Line 2)
random.choose â†’True Root: generate left child? (Line 6)
random.randint â†’5Left child: node value (Line 2)
random.choose â†’False Left child: gen. left child? (Line 6)
random.choose â†’False Left child: gen. right child? (Line 8)
random.choose â†’True Root: generate right child? (Line 8)
random.randint â†’7Right child: node value (Line 2)
random.choose â†’False Right child: gen. left child? (Line 6)
random.choose â†’False Right child: gen. right child? (Line 8)
The corresponding binary tree consists of a root node with the
value 3 and leaf nodes with the values 5 and 7 as the left and right
child, respectively:3
5 7Atypicalchallengeingenerator-basedtestingariseswhenthe
inputisexpectedtosatisfycomplexsemanticvalidityconstraints
that are not explicitly considered by the generator. To continuethe current example, the SUT may expect the generated tree tobe sorted (e.g., a binary search tree) or height-balanced (e.g., an
AVLtree).Inthiscase,randominputsamplingisusuallynotvery
effectiveasmostofthegeneratedinputswillberejectedbytheSUT.
Instead, recent techniques bias the generator towards producing
validinputsbydirectlycontrollingtherandomchoicesmadeduring
the input generation process.
Zest[32]reliesonthefactthattheimplementationofrandom
number generators usually depends on a pseudo-random source of
untypedbits,whichPadhyeetal.refertoas parameters.Specifically,
random values of a particular type are generated by consuming
and interpreting a fixed number of parameters. For instance, a ran-
dombooleanvaluemaybesampledbyconsumingonebitfromthesourceofuntypedparameters,whichistheninterpretedas
Falseif
itiszeroandotherwiseas True.Thepseudo-randomnatureofthis
methodensuresthatusingthesamerandomseedalwaysgenerates
thesamesequenceofparameters.Foragivengenerator,thiswill
producethesamesequenceofrandomchoices,effectivelyresulting
inthesamegeneratedinput.Ontheotherhand,bymutatingthe
untyped parameter sequence, the sequence of random choices can
be altered, which corresponds to complex structural mutations in
theinputdomain.Forexample,mutatingtheparametersthatare
consumed by the first call to random.randint() (Figure 2, Line 2)
resultsinthevalueoftherootnodetobemutated.Similarly,mu-
tating the parameters corresponding to a call to random.choose()
(Line 6) may change the decision on whether a left child node will
begenerated.Asaresult,bycontrollingthesequenceofparameters,
itispossibletodirectlycontroltheoutputoftheinputgenerator.
Zest [32] exploits this insight by performing a feedback-directed
parametersearchtoguidethegeneratorstowardshighcoverage
inthesemanticanalysisstages.Contrary,RLCheck[ 35]employs
reinforcementlearningtoautomaticallylearna guidethatleadsthe
generatortoproducediversevalidinputs(w.r.t.avalidityfunction).
2.2 Hill-Numbers
In the field of ecology, researchers are interested in quantifying
thebiodiversityofanassemblagebasedonasampleofspecies.A
commonlyusedclassofdiversitymetricsaretheHillnumbers[ 17].
TheHillnumbersconsiderbothspeciesrichness(i.e.,thetotalnum-
berofdifferentspecies)andspeciesabundances(i.e.,thenumber
of individuals per species) in a sample, and are defined as follows:
Definition 2.1 (Hill number of order ğ‘).Letğ‘†be the species rich-
nessandğ‘ğ‘–therelativeabundanceofthe ğ‘–-thspeciesinthedataset.
TheHillnumberoforder ğ‘isdefinedas(ğ‘ğ·istheoriginalnotation):
ğ‘ğ·=ğ·(ğ‘)=/parenleftBiggğ‘†/summationdisplay.1
ğ‘–=1ğ‘ğ‘
ğ‘–/parenrightBigg1/(1âˆ’ğ‘)
(1)
Forğ‘=1, Equation 1 is undefined, but its limit for ğ‘â†’1 corre-
sponds to the exponential of the Shannon(-Wiener) index [38, 40]:
1ğ·=ğ·(1)=lim
ğ‘â†’1ğ‘ğ·=exp/parenleftBigg
âˆ’ğ‘†/summationdisplay.1
ğ‘–=1ğ‘ğ‘–logğ‘ğ‘–/parenrightBigg
(2)
251
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Hoang Lam Nguyen and Lars Grunske
Theorder ğ‘determinesthesensitivityofthemetrictotherelative
species abundances, where typically measures for ğ‘âˆˆ{0,1,2}
are reported. For ğ‘=0, the relative species abundances are not
considered at all and ğ·(0)corresponds to the total number of
speciesinthedataset (i.e.,therichness).For ğ‘=1,thespeciesare
weighted in proportion to their relative abundances, which is why
ğ·(1)canbeinterpretedastheeffectivenumberofâ€typicalâ€species.
Forğ‘=2,moreweightisgiventothemostabundantspeciesand
therarerspeciesarediscounted.Asaresult, ğ·(2)canbeinterpreted
as the effective number of â€commonâ€ or dominant species.
3 APPROACH
In this section, we first describe our approach to extend generator-
basedfuzzingwiththeabilitytoproducemorebehaviorallydiverse
inputs(Section3.1â€“3.3).Then,weintroduceanovelmetrictoquan-
tify the behavioral diversity of a fuzzing campaign based on Hill
numbers (Section 3.4).
3.1 Overview
The key idea of our approach can be summarized as follows: (i) We
searchforinteresting inputstructures inthespaceofvalidinputs
throughstructure-changing mutations. (ii) We produce different
variantsofthesameinputstructurebyapplying structure-preserving
mutationswiththegoalofexploringdiverseexecutiontraces.To
bias the input generation towards high behavioral diversity, we
observe the coverage and validity feedback from the program after
every execution and adapt the mutation strategy accordingly.
3.2 Structural Parameter Splitting
As described in Section 2.1, the non-determinism of the input gen-
eration process is entirely controlled by the sequence of randomchoices made. Our first insight is that the choices can be classi-fied into two different types: structural choices andvalue choices,
dependingontheirinfluenceonthecontrol-flowbehaviorofthe
generator.Basedonthenotionofa choicepoint byReddyetal.[ 35],
we define these choice types as follows:
Definition3.1 (StructuralandValuechoices) .Letthechoicepoint
ğ‘be a tuple (â„“,ğ¶), whereâ„“âˆˆLis a program location in the gener-
atorğºandğ¶âŠ†Cis a finite domain of choices. The choice point
ğ‘is said to produce structural choices if the evaluation of a branch
condition at some point during the execution of ğºdepends on the
choiceğ‘âˆˆğ¶. Otherwise, ğ‘is said to produce value choices.
Forexample,thechoicepoint ğ‘1=(Line2, [0, 1, ..., 10] )
in Figure 2 produces value choices, since no branch condition in
generate_tree dependsonthatchoice.Ontheotherhand,both
choicepoints ğ‘2=(Line6, [True, False] )andğ‘3=(Line8, [True,
False])producestructuralchoices,sincethecorrespondingchoices
directlyinfluencethebranchingbehaviorofthegenerator ğº(i.e.,
the decision on whether to generate child nodes or not).
Based on this insight, our first idea is to splitthe sequence of
untypedparametersintotwodistinctparametersequencesbased
on the choice type they are used for:
(1)Astructuralparametersequence tobeconsumedbystructural
choice points.(2)Avalue parameter sequence to be consumed by value choice
points.
That is, we can now represent each input as a tuple (ğœğ‘ ,ğœğ‘£), where
ğœğ‘ andğœğ‘£represent the structural and value parameters consumed
by the input generator, respectively. To further illustrate this idea,consider the following binary tree:
3
5 7
Thecorrespondingparametersequence ğœ(shownastypedchoice
values for the sake of simplicity) is given by: ğœ=3,True,5,False,
False,True,7,False,False
Here,thestructuralchoicesconsistsofallthebooleanandthe
value choices of all the integer values. Therefore, we can represent
thisparametersequencebythefollowingtwodistinctsequences:
ğœğ‘ =True,False,False,True,False,Falseandğœğ‘£=3,5,7.
Thischangeinhowtheparametersforageneratorarehandledis
a key idea of our approach, since it gives us access to the following
operations and concepts.
First, it enables us to perform more controlled mutations on the
input.Inparticular,bymutatingthestructuralparametersequence,
we can directly mutate the structural choices made during the
input generation process. By definition, the change of structural
choices eventually results in a change of the control-flow behavior
inthegenerator,whichtypicallyproducesaninputwithadifferentstructure.Forexample,ifweconsiderthebinarytreegeneratorfrom
Figure2,mutatingthestructuralparameterschangestheboolean
decisionsonthegenerationofchildnodes.Ontheotherhand,by
mutatingthevalueparametersonly,thecontrol-flowbehaviorof
the generator is preserved, yet different value choices are sampled.
In the case of the binary tree generator, mutating value parameters
resultsinmutatedchoicesforthenodevalues,whilekeepingthe
shape of the binary tree unmodified. Overall, the access to these
structure-changingandstructure-preservingmutationsallowsus
to explore the input space in a more controlled manner.
The second benefit of separating the structural and value pa-
rameters is that it allows us to synthesize an abstract input from a
concrete input:
Definition3.2 (AbstractInput,StructuralSignature) .Letğ‘–bean
inputgeneratedbyagenerator ğº,ğœğ‘ =ğ‘ğ‘ 1,ğ‘ğ‘ 2,...,ğ‘ğ‘ ğ‘›bethecorre-
spondingsequenceofstructuralparameters,and ğœğ‘£=ğ‘ğ‘£1,ğ‘ğ‘£2,...,ğ‘ğ‘£ğ‘š
bethecorrespondingsequenceofvalueparametersmadeby ğºdur-
ing the generation of ğ‘–. Theabstract input ğ´(ğ‘–)of the input ğ‘–is
the input that is obtained by setting all value parameters in ğœğ‘£
as unspecified (or symbolic), while fixing the concrete structural
parameters ğœğ‘ . The sequence of concrete structural parameters ğœğ‘ 
is called the structural signature ofğ´(ğ‘–).
Intuitively, the abstract input represents the structural skeleton
oftheinput,whichmaybeconcretizedbyspecifyingthemissing
value parameters. In our running example, the abstract input of
a generated binary tree would correspond to a binary tree with
the same shape but unspecified node values. As an example, for
252
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. BeDivFuzz: Integrating Behavioral Diversity into Generator-based Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
the above described tree, the abstract input ğ´(ğ‘¡)fixes the struc-
turalparameters ğœğ‘ andleavesthevalueparameters ğœğ‘£unspecified
(ğ‘ğ‘£1,ğ‘ğ‘£2,ğ‘ğ‘£3), i.e.:ğ‘ğ‘£1
ğ‘ğ‘£2 ğ‘ğ‘£3
ğœğ‘ =True,False,False,True,False,False
ğœğ‘£=ğ‘ğ‘£1,ğ‘ğ‘£2,ğ‘ğ‘£3
Thestructuralsignature(i.e.,thesequenceofstructuralparameters
ğœğ‘ )o fğ´(ğ‘¡)thus describes the set of all binary trees consisting
of three nodes: a root node that is connected to two child nodes
whereeach nodehas avaluebetween 0and 10(thedomain ofthe
choice point ğ‘1= (Line 2, [0, 1, ..., 10] )). Since we represent
each input as a tuple (ğœğ‘ ,ğœğ‘£), we can easily check whether two
inputs share the same abstract input by comparing their structural
signatures.Thisisanothercrucialaspectofourapproach,asthis
propertyallowsustoreasonabouttheexploredinputspaceona
higherlevel.Inparticular,ourapproachusestheconceptofabstract
inputsinordertoidentifyinterestinginputstructuresthatexercise
new behavior.
3.3 Feedback-Driven Search Strategy
Thefuzzingalgorithmof BeDivFuzzispresentedinAlgorithm1.It
isbasedonthecoverage-guidedZestalgorithmforgenerator-based
fuzzing,andisextendedbyintegratingtheconceptsofstructural
parameter splitting and abstract input structures. In particular, the
two key components of the BeDivFuzz algorithm consist of:
(1)An adaptive mutation strategy that biases input generation
towards high behavioral diversity, and
(2)A fuzzing heuristic that guides the search strategy based on
the structural properties of the input.
We highlight these main innovations in Algorithm 1 in grey.
Algorithm 1: BeDivFuzz Algorithm
Input :programğ‘, generator ğ‘”
Output:a set of test inputs, a set of failing inputs
1ğ‘„â†{random} /* Initial seed input */
2ğ¹â†âˆ… /* Failing parameters */
3ğ¶â†âˆ… /* Total coverage */
4ğ‘‡â†âˆ… /* Unique traces */
5ğ‘†â†âˆ… /* Interesting valid input structures */
6repeat
7for(ğœğ‘ ,ğœğ‘£)inğ‘„do
8 for1â‰¤ğ‘–â‰¤numChildren( ğœğ‘ ,ğœğ‘£)do
9 Ëœğœğ‘ ,Ëœğœğ‘£â†mutateAdaptive (ğœğ‘ ,ğœğ‘£)
10 inputâ†ğ‘”(ğœğ‘ ,ğœğ‘£)
11 coverage,resultâ†run(ğ‘,input)
12 ifresult=Failurethen /* Save failures */
13 ğ¹â†ğ¹âˆª{(ğœğ‘ ,ğœğ‘£)}
14 else /* Check if input has interesting structure */
15 ifresult=Valid and coverage/notsubseteqlğ¶andğœğ‘ âˆ‰ğ‘†then
16 ğ‘„â†ğ‘„âˆª{(ğœğ‘ ,ğœğ‘£)} /* Add to queue */
17 ğ‘†â†ğ‘†âˆª{ğœğ‘ } /* Add saved structure */
18 updateCoverageStats( coverage,result,ğ¶,ğ‘‡)
19untilgiven time budget expires
20returnğ‘”(ğ‘„),ğ‘”(ğ¹)SimilartoZest(andothercoverage-guidedfuzzers),wemaintain
a queueğ‘„of interesting inputs, which is initially seeded with a
random value (Line 1). While Zest operates on single parameter
sequences ğœ,BeDivFuzzoperatesontuples (ğœğ‘ ,ğœğ‘£)ofsplitparame-
tersequences.Forthesakeofbrevity,intheremainderofthispaper
wewillusetheterm parameters whenreferringtotuples (ğœğ‘ ,ğœğ‘£)
of split parameter sequences. Throughout the fuzzing campaign,the algorithm maintains basic bookkeeping data, such as the set
of failing parameters and the current branch coverage (Lines 2â€“3).
Additionally, BeDivFuzz keeps track of all unique coverage traces
(Line 4) and the set of interesting abstract input structures (Line 5).
The set of unique coverage traces is used to adaptively bias the
mutationstrategy,describedinmoredetailattheendofthissec-
tion.The setof abstractinput structuresis utilizedby BeDivFuzz
to guide the search within the space of valid inputs.
The main fuzzing loop (Lines 6â€“19) has the same structure as
other coverage-guided fuzzers, described as follows: First, a pa-
rametersequenceisselectedfromthequeue(Line7),afterwhich
the number of child parameters is determined (Line 8). We usethe same heuristic as Zest, which computes the number of child
parametersbasedonthecoverageoftheparentinput.Eachchild
isgeneratedbyperformingoneormoremutationsontheparent
parametersequence(Line9).Themutatedparametersarethenusedtogenerateaconcreteinputusingtheprovidedgenerator(Line10).
Afterwards,thesystemundertestisexecutedwiththegenerated
input, which yields the code coverage and the validity feedback
(Line 11). The validity feedback is stored in the variable resultand
can be any of {Valid,Invalid,Failure}. In the case of Failure,
the current parameters are saved to the set of failures (Line 13).
Otherwise, the algorithm heuristically decides whether the currentparameters should be saved to the queue (i.e., if the parameters are
interestingenoughtobefurthermutated)basedontheobserved
executionresults(Line15).Thisisbydefaultthecaseiftheinput
is (1) valid, (2) exercises new coverage, and (3) represents an input
structure thathas not been previouslyadded to the queue.Finally,
the bookkeeping-data is updated (Line 18). This includes updating
the branch coverage and the set of unique coverage traces.
As described in Section 3.2, BeDivFuzz is able to distinguish be-
tweenstructure-changing andstructure-preserving mutations.This
isdonebyperformingmutationsoneitherthestructuralparameters
ğœğ‘ oronthevalueparameters ğœğ‘£.Performingstructure-changing
mutationsallowstosearchfornewprogrambehaviorthatisonly
triggered if the input satisfies particular structural properties. Incontrast, structure-preserving mutations allow to test a specific
behaviorofthecodewithdifferentvariantsoftheinput(i.e.,inputs
with the same abstract structure but different values).
Inordertodecidewhichtypeofmutationtoperform,BeDivFuzz
keeps track of the types of mutations that have been performed on
aparametersequenceandobserveswhethertheresultinginputhasresultedintheexecutionofa uniquetrace.Thefollowingmutations
arethenbiasedtowardsthemutationoperatorthatismorelikely
toproduceuniqueexecutiontraces,asillustratedinAlgorithm2.
Specifically, with a probability of ğœ–, a random type of mutation
is performed. Otherwise, the mutation type is chosen based on
heuristicscores ğ‘…ğ‘ andğ‘…ğ‘£forthestructuralandvaluemutations,
respectively (Line 6). For a given mutation type ğ‘¥, the score is
calculated as the fraction of inputs that have exercised a unique
253
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Hoang Lam Nguyen and Lars Grunske
trace(ğ‘ˆğ‘¥)outofalltheinputsthatweregeneratedbytherespective
mutation type ( ğ‘ğ‘¥), i.e.:
ğ‘…ğ‘¥=ğ‘ˆğ‘¥
ğ‘ğ‘¥ğ‘¥âˆˆ{ğ‘ ,ğ‘£} (3)
Thus,webiastheselectionofthemutationoperatortowardspro-
ducing inputs that diversely exercise particular behaviors, while
relyingonthestructuralsearchheuristicinAlgorithm1(Line15)
to discover new behaviors.
Algorithm 2: Adaptive Mutation Strategy
Input :structural parameters ğœğ‘ , value parameters ğœğ‘£, exploration factor ğœ–
Output:mutated parameters Ëœğœğ‘ ,Ëœğœğ‘£
1ifuniformRandom ()<ğœ–then
2ifrandomBoolean() then /* Mutate either of the params */
3 return(mutate(ğœğ‘ ),ğœğ‘£)
4else
5 return(ğœğ‘ ,mutate(ğœğ‘£))
6ğ‘…ğ‘ ,ğ‘…ğ‘£â†calculateScores ()/* Score by mutation type (Eq. 4) */
7ifğ‘…ğ‘ â‰ ğ‘…ğ‘£then /* Perform most promising mutation */
8ifğ‘…ğ‘ >ğ‘…ğ‘£then
9 return(mutate(ğœğ‘ ),ğœğ‘£) /* Mutate structural params */
10else
11 return(ğœğ‘ ,mutate(ğœğ‘£)) /* Mutate value params */
12else
13goto2 /* Resort to random mutation */
3.4 A Metric for Behavioral Diversity
Aspartofthiswork,weareinterestedinestablishinganotionof
behavioral diversity in the context of fuzz testing. In particular, we
propose to use Hill numbers (Section 2.2), or effective number of
species[17]. The inspiration for this metric stems from the STADS
(SoftwareTestingandAnalysisasDiscoveryofSpecies )framework
introduced by BÃ¶hme [ 6]. In this framework, BÃ¶hme links the sam-
pling process in an assemblage for species discovery to the process
of sampling from the programâ€™s input space to discover particular
featuresoftheinputâ€™sexecution(e.g.,coveredbranches,reached
program states). However, rather than using the framework to
estimatespeciesdiscoveryprobabilities[ 6,7],webuilduponthe
sameconnectionbetweenecologyandsoftwaretestingbyapplying
an established biodiversity index â€” known as Hill numbers â€” to
quantify the behavioral diversity of a fuzzing campaign.
We apply this diversity measure to the context of fuzzing as fol-
lows.Considerafuzzingcampaign,whereafuzzer ğ¹samplesinputs
ğ¼tofuzzaprogram ğ‘ƒ.Executing ğ‘ƒwithaninput ğ‘–âˆˆğ¼resultsina
traceğ‘¡(ğ‘–)thatconsistsofthesequenceofbranchesvisitedduring
the execution. Each branch ğ‘that has been covered by at least one
inputğ‘–cannowbeseenasaspecies.Theabundanceofaspecies
(i.e.,ofacoveredbranch ğ‘)canthenbecomputedasthenumber
ğ‘(ğ‘)ofuniquetraces thathaveexecutedthebranch ğ‘(thebranch
execution count). Given these measures, we can now quantify the
behavioral diversity of a fuzzing campaign as the Hill numbers
computed over the distribution of branch execution counts.
Definition3.3 (BehavioralDiversity) .Letğ¼bethesetofinputsgen-
eratedbyafuzzerduringafuzzingcampaign,andlet ğ¶:B â†¦â†’N>0
be a function that maps a covered branch ğ‘âˆˆBto its relative exe-
cutioncountoveralluniquetraces.Then,the behavioraldiversityof orderğ‘is defined as:
ğµ(ğ‘)=/parenleftBigg/summationdisplay.1
ğ‘âˆˆBğ¶(ğ‘)ğ‘/parenrightBigg1/(1âˆ’ğ‘)
(4)
Intuitively, this measure quantifies the effective number of di-
verselycoveredbranches,thatis,thenumberofbranchesthatwere
equallyoftenexecutedbydiverseinputs(i.e.,inputswithunique
traces). While ğµ(0)is equal to the number of covered branches
(since it equally weights rare and common branches), ğµ(1)weights
branchesbytheirrelativeexecutioncountsandcanthusbeinter-
pretedastheâ€effectivenumberoftypicallycoveredbranchesâ€. ğµ(2)
gives more weight to common branches and can be seen as the
â€effective number of common branchesâ€.
In the context of fuzzing, behavioral diversity considers the dis-
tributionofdiversebranchexecutioncountsinordertomeasure
thedegreeofexplorationbiastowardsspecificprogrambehavior.
Higher numbers indicate that a fuzzer is diversely exploring more
branches,whereas lownumbersmean thatthefuzzer isspending
mostoftheresourcesexploringthesamefewbehaviors.Lowbe-
havioral diversity is most evident for random blackbox-techniques,
which may be able to spuriously cover many branches, but ulti-
matelyexercisethesamelikelycoderegionsoverandoveragain.
Especially for â€œunsuccessfulâ€ fuzz campaigns where no bugs are
found,behavioraldiversitycanprovidevaluableinsightsintothe
progressofafuzzerasacomplementarymetrictobranchcoverage.
Forinstance,practitionersmayconsidermorediverselyexecuted
branchesasmore reliablethanlessdiversely executedones,since
they have been tested more â€œthoroughlyâ€. On the other hand, re-
searchers may tune their fuzzers to repeatedly target less diversely
executed branches in order to increase the overall confidence in
the reliability of the respective behavior.
4 EVALUATION
Inthissection,weevaluatetheeffectivenessof BeDivFuzzingener-
atinginputsthatexhibitdiversebehavior.Wecompareourapproach
against three techniques: RLCheck [ 35], Zest [32], and an imple-
mentationofQuickcheck[ 12]fromtheJQF[ 31]fuzzingframework.
In particular, we seek to answer the following research questions:
RQ1IsBeDivFuzzabletoeffectivelyproducediversevalidinputs
for real-world benchmarks? (Section 4.2)
RQ2Do the inputs generated by BeDivFuzz have a higher be-
havioral diversity compared to state-of-the-art techniques?
(Section 4.3)
RQ3HowdoesBeDivFuzzperformintermsoffaultfindingca-
pabilities? (Section 4.4)
4.1 Study Design
Baseline Techniques. We compare against two state-of-the-art tech-
niquesingenerator-basedtesting,namelyRLCheck[ 35]andZest[ 32].
RLCheck uses reinforcement learning in order to automaticallylearn aguidethat leads the generator towards producing many
diversevalidinputs.Zestisagenerator-basedfuzzerthatintegrates
validity feedback into a coverage-guided search algorithm to effec-
tivelycoverthesemanticanalysiscode.Wealsocompareagainst
a Java version of Quickcheck [ 12] by running Zest without code
coverage and validityfeedback, as donein the original evaluation
254
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. BeDivFuzz: Integrating Behavioral Diversity into Generator-based Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
of RLCheck. That is, Quickcheck performs random sampling of
inputs using the generator.
Experimental Subjects. Our evaluation is conducted on six real-
world benchmarks,namely Apache Ant,Apache Maven, Mozilla
Rhino,GoogleClosureCompiler,OracleNashorn,andApacheTom-
cat.Thefirstfoursubjectshavebeenusedintheoriginalevaluations
of Zest [32] and RLCheck [35]; we add two additional subjects for
a broader benchmark. In addition, we have updated the subjects
to the latest versions available at the time when we conducted the
experiments. Inputs for Ant, Maven, and Tomcat are generated by
an XML generator, whereas Rhino, Closure, and Nashorn use a
JavaScript code generator.
Configuration. We run all baseline techniques with their default
configurations.InordertorunNashornandTomcatwithRLCheck,
weuseconfigurationfilesbasedonthoseprovidedforRhinoand
Mavenbytheoriginalauthors,respectively.ForBeDivFuzz,weuse
ğœ–=0.2astheprobabilitytoperformarandommutation.Further,we
provideresultsfortwoconfigurationsof BeDivFuzz,whichwerefer
to asBeDivFuzz-structure and BeDivFuzz-simple. BeDivFuzz-
structure utilizes both structural mutations and analysis of input
structure novelty, whereas BeDivFuzz-simple only employs struc-
tural mutations. In order to make the input generators used by
Zestcompatiblewithourtechnique,wemanuallyextendedthemto
handle split parameter sequences and annotated the choice points
with the type of choice they produce. However, we note that the
latter could also be done automatically through data-flow analysis.
Implementation. We have implemented BeDivFuzz [ 4] as an exten-
sion of Zest in JQF [ 31]. JQF is a framework for generator-based
testinginJavaandimplementsdifferentfuzzingalgorithms,includ-
ing the Zest algorithm and AFL-like fuzzing for Java programs.
Experimental Parameters. FortheevaluationofRQ1(inputdiver-
sity) and RQ2 (behavioral diversity), we run each experiment with
atimeoutof1hour.TheoriginalevaluationofRLCheck[ 35]was
conducted with a timeout of 5 minutes, as the authors assumed
aproperty-basedtestingcontextwherethegeneratoristypically
executed only for a short time. While a 5 minute timeout may
seem short compared to common timeouts in fuzzing evaluations,
itshouldalsobenotedthatcollectingcoveragemetricsforblack-
boxmethods(e.g.,QuickcheckorRLCheck)issignificantlymore
expensivethanforgreyboxmethods(e.g.,ZestorBeDivFuzz).In
particular, the inputs for blackbox techniques first need to be gen-
eratedontheuninstrumentedSUTuntiltimeout,andsubsequently
be replayed on the instrumented version of the SUT. This is neces-
sary to allow for a fair comparison against greybox methods, since
instrumentationaddsadditionaloverhead.However,thismethodol-
ogy results in significantly longer experimental runtimes1.O nt h e
otherhand,coveragedatamaynotbemeaningfuliftimeoutsare
tooshort,sincecoverage-guidedalgorithmstypicallyneedsometime to become effective. Thus, for the evaluation of RQ1 (input
diversity)andRQ2(behavioraldiversity),weextendthetimeoutfor
each experiment to 1 hour. We further justify this decision by our
observation that coverage has plateaued in almost all experiments
1Inourexperiments,wehaveobservedupto 50Ã—longerruntimeswhencomputing
coverage for Quickcheck and RLCheck.after this timeout. However, for RQ3 (fault finding capabilities), we
extendthetimeoutto24hours,sinceevaluationsthatfocusonbug
metrics should be performed with longer timeouts, as suggested
by Klees et al. [ 23]. To account for the variability of the results due
torandomness,weperform30repetitions.Statistical significance
is assessed using the Mann-Whitney ğ‘ˆtest (also known as the
Wilcoxonrank-sumtest)with ğ›¼=0.01,assuggestedbyArcuriand
Briand [1] for randomized algorithms.
As for hardware, we conducted all experiments on a server with
anIntel(R)Xeon(R)E7-48802.5GHzCPUand1TBofRAMrunning
openSUSE Leap 15.
4.2 RQ1: Generating Diverse Valid Inputs
WeanswerRQ1byassessingthenumberofdiversevalidinputsgen-
erated by BeDivFuzz compared to the baseline techniques. Similar
to Reddy et al. [ 35], we consider diverse valid inputs as inputs that
exercisedifferenttraces,ratherthaninputsthatareonlyuniqueon
thebyteorstringlevel.TheresultsarevisualizedinFigure3.The
left column shows for each benchmark subject the percentage of all
generated inputsthat were diversevalid inputs,whereas the right
column depicts the totalnumber of diverse valid inputs.
If we consider the percentages of generated diverse valid inputs,
theresultsindicatethat BeDivFuzziscompetitivewiththe current
state-of-the-art. For all benchmark subjects, both configurationsof BeDivFuzz outperform Zest and Quickcheck as they are ableto maintain a high percentage of diverse valid inputs and even
increaseitovertimeforseveralsubjects.However,intwooutofsix
subjects,RLChecksignificantlyoutperforms BeDivFuzz,whichis
most notable in the Maven benchmark where the mean percentage
of diverse valid inputs is about 6% and 10% higher compared to
BeDivFuzz-structure and BeDivFuzz-simple, respectively.
The plots for Ant show a high variability in the performance of
BeDivFuzz,whichisduetothedifficultyoffindingthefirstvalid
inputforthissubject.ThisindicatesthatBeDivFuzzcanpotentially
benefitfromaninitialvalidseedinput.ThesameappliestoZest,
which also further mutates invalid inputs by default, thus poten-
tially wasting resources by initially exploring the error handlingcode of the SUT. On the other hand, the efficiency of RLCheckallows it to quickly find a valid input and exploit the obtained
information to generate further diverse valid inputs.
On our newly added subjects Nashorn and Tomcat, RLCheck
does not perform as well as on the other benchmarks. This canpotentially be attributed to the fact that the new subjects have
verysimplevalidityfunctions,whiledifferentbehaviormayonly
be triggered by specific input structures. We assume that since
RLCheckonlyreliesonthevalidityfeedback,itisunabletolearn
anymeaningful policyasalmost anygeneratedinput isvalid,but
not necessarily diverse valid. As a result, RLCheck might be prone
to overfit to a valid, yet uninteresting space of inputs (with regard
to the triggered program behavior). In contrast to that, BeDivFuzz
also utilizes code coverage to identify whether an input with a
unique structure exercises interesting behavior or not.
While the results indicate that BeDivFuzz is highly effective
in generating diverse valid inputs, the total numbers (Figure 3,right column) show that our approach is mostly limited by itsefficiency. Overall, BeDivFuzz only performs better than Zest in
255
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Hoang Lam Nguyen and Lars Grunske
BeDiv-structure
BeDiv-simpleRLCheck
ZestQuickCheck
0 20 40 60
Time (min)0%10% % Diverse Valid
0 20 40 60
Time (min)020k40k Diverse Valids
(a) Ant
0 20 40 60
Time (min)0%20% % Diverse Valid
0 20 40 60
Time (min)0500k1mDiverse Valids
(b) Maven
0 20 40 60
Time (min)25%50%75% % Diverse Valid
0 20 40 60
Time (min)0500k1mDiverse Valids
(c) Rhino
0 20 40 60
Time (min)0%50% % Diverse Valid
0 20 40 60
Time (min)0500k Diverse Valids
(d) Closure
0 20 40 60
Time (min)0%25%50% % Diverse Valid
0 20 40 60
Time (min)020k40k Diverse Valids
(e) Nashorn
0 20 40 60
Time (min)60%80%100% % Diverse Valid
0 20 40 60
Time (min)01m Diverse Valids
(f) Tomcat
Figure 3: Percent (left) and absolute number (right) of di-
verse valid inputs (i.e., valid inputs with different traces).termsofgeneratingmanydiversevalidinputs.Whencomparing
bothconfigurationsof BeDivFuzz,BeDivFuzz-structuretendsto
haveaslightedgeduetotheaddedanalysisofinputstructures,but
thedifferences aregenerallynot significant. However BeDivFuzz,
is outperformed by both RLCheck and Quickcheck for most ofthe benchmark subjects. This can be explained as follows. LikeZest, BeDivFuzz requires the SUT to be instrumented in orderto collect code coverage. This results in a significant slowdownof execution time (around 10â€“100
Ã—slower), effectively reducing
the total number of diverse valid inputs that can potentially begenerated. On the other hand, while RLCheck has a comparable
effectiveness to BeDivFuzz, the blackbox approach makes it much
moreefficient.Nevertheless,thisisanacceptabletrade-off,since
our main focus is not on producing a large number of diverse valid
inputs. Instead, the overall goal of BeDivFuzz is to exercise diverse
behavior, which we evaluate in the following section.
4.3 RQ2: Diverse Execution of Program
Behavior
In this section, we seek to answer RQ2, that is, whether BeDiv-
Fuzzisabletogeneratetestinputsthathaveahigherbehavioral
diversity compared to the baseline techniques. We measure the
behavioral diversity by the behavioral diversity index ğµ(ğ‘)of order
ğ‘, definedin Equation4. In particular,we compare thebehavioral
diversityindicesfor ğ‘âˆˆ{0,1,2},sinceinthefieldofecology,Hill
numbersareusuallyreportedfortheseordersaswell.Recallthat
the behavioral diversity ğµ(ğ‘)can be interpreted as follows:
ğ‘=0:Thetotalnumberofcoveredbranches(i.e.,branchcoverage)
ğ‘=1: The effective number of typically executed branches
ğ‘=2: The effective number of commonly executed branches
Theeffectivenumber ofasetofcoveredbranchescanbeseenasthe
number of branches executed by the proportionally same number
ofdiverseinputs.Wearemostlyinterestedintheresultsfor ğµ(1)
andğµ(2),sincetheyemphasizetherelativeexecutioncountsofthe
typical and more common branches, respectively.
TheresultsareshowninFigure4.Fromlefttoright,thecolumns
depict the behavioral diversity of increasing order ğ‘(from 0 to
2). The first column shows for each subject and technique thebehavioral diversity of order 0, i.e., the total number of covered
branches.WhileRLCheckisabletogeneratethehighestnumber
of diverse valid inputs (Section 4.3), it performs the worst in terms
ofbranchcoverage.Whencomparingtheotherapproaches,both
configurations of BeDivFuzz have coveredthe highestnumber of
branches in three out of six benchmarks (Ant, Maven, Nashorn),
with BeDivFuzz-simple additionally outperforming all other tech-
niquesinTomcat.However,QuickcheckoutperformsBeDivFuzz
in the two remaining benchmarks (Rhino and Closure). Compar-
ingagainstZest,BeDivFuzzisonlysignificantlyoutperformedinClosure, and also in Tomcat for BeDivFuzz-structure.
ThesecondcolumnofFigure4comparesthedifferenttechniques
w.r.t.the ğµ(1)metric,i.e.,theeffectivenumberofâ€typicallyâ€exe-
cutedbranches.Here,asimilartrendintheresultscanbeobserved.
WhiletherelativeperformanceofRLCheckremainsthesame,both
configurationsof BeDivFuzzperformsignificantlybetterthanall
baseline approaches in four out of six benchmarks (Maven, Rhino,
Closure,Nashorn).Mostinterestingly,whencomparingagainstthe
256
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. BeDivFuzz: Integrating Behavioral Diversity into Generator-based Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
BeDiv-structure BeDiv-simple RLCheck Zest QuickCheck
0 20 40 60
Time (min)2k4kB(0)
0 20 40 60
Time (min)1k2k3kB(1)
0 20 40 60
Time (min)1k2k3kB(2)
(a) Ant
0 20 40 60
Time (min)1k2kB(0)
0 20 40 60
Time (min)5001k1.5kB(1)
0 20 40 60
Time (min)5001k1.5kB(2)
(b) Maven
0 20 40 60
Time (min)2.5k5kB(0)
0 20 40 60
Time (min)2k4kB(1)
0 20 40 60
Time (min)1k2k3kB(2)
(c) Rhino
0 20 40 60
Time (min)10k20kB(0)
0 20 40 60
Time (min)5k10kB(1)
0 20 40 60
Time (min)5k10kB(2)
(d) Closure
0 20 40 60
Time (min)100200300B(0)
0 20 40 60
Time (min)100200B(1)
0 20 40 60
Time (min)100200B(2)
(e) Nashorn
0 20 40 60
Time (min)2k4kB(0)
0 20 40 60
Time (min)1k2k3kB(1)
0 20 40 60
Time (min)1k2k3kB(2)
(f) Tomcat
Figure 4: From left to right: Behavioral diversity of increasing order 0 to 2.
257
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Hoang Lam Nguyen and Lars Grunske
plotsofthefirstcolumn( ğµ(0),i.e.,numberofcoveredbranches),
BeDivFuzznowoutperformsbothQuickcheckandZestinRhino
andClosure.Intheremainingbenchmarks(AntandTomcat),the
performanceofZestiscomparabletoBeDivFuzz.Anotherobser-
vationisthatthe ğµ(1)valueof BeDivFuzztendstoincreaseover
time, most noticeable on Ant, Rhino, and Closure. This indicates
thattheinputsgeneratedbyBeDivFuzznotonlydiverselyexecute
a fixed set of behaviors. Instead, BeDivFuzz is able to continu-
ously increase the coverage of new behaviors while maintaining
the overall diversity of the triggered behavior. In contrast, the ğµ(1)
metric even slightly decreases over time for Quickcheck in the Clo-surebenchmark.Apossibleexplanationforthisobservationisthat
Quickcheckispronetodisproportionatelyoftentriggerthemost
likelybehaviorsintheSUT.Ontheotherhand,mostoftheother
covered branches may have been executed only a few times by
chance.Thisincreasingâ€unevennessâ€inexecutedbehaviorcould
consequently result in a decline of the ğµ(1)value.
The third column shows the results for the ğµ(2)metric, i.e., the
effectivenumberofcommonlyexecutedbranches.Again,infour
outofsixbenchmarks(Maven,Rhino,Closure,Nashorn),BeDiv-
Fuzzperformssignificantlybetterthanallbaselineapproaches.For
the Rhino and Closure benchmark, the difference between BeDi-vFuzz and the baselines even increased compared to the results
of theğµ(1)metric (center column). That is, both configurations of
BeDivFuzz generate inputs that trigger â€commonâ€ behavior in a
more diverse manner compared to the baselines.
Throughout the experiments, when comparing the two configu-
rationsof BeDivFuzz,wehaveobservedthatBeDivFuzz-structuregenerallyperformsbetterforshortertimeouts(
â‰¤5minutes).Since
BeDivFuzz-structureonlysavesinputstothequeueiftheyex-
hibit a new input structure, the queue of saved inputs contains
less, but more (structurally) diverse inputs. As a result, BeDivFuzz-
structureinitiallyexploresmorediversebehavior,buttheplain
adaptivemutationstrategyof BeDivFuzz-simpleseemstobesuf-
ficient to eventually discover these behaviors as well. Thus, the
moreexplorativenatureof BeDivFuzz-structuremaybemore
suitable for contexts where runtimes are required to be short (e.g.,
property-based testing).
4.4 RQ3: Finding Faults
Table 1 shows the list of crashes that were discovered after a time-
outof24hours,deduplicatedbybenchmarkandexceptiontype(as
done in the evaluations of Zest and RLCheck). To answer RQ3, we
comparethedifferentapproachesconcerningthediscoverytimes
and the reliability of triggering a particular crash. The results in-dicatethatRLCheckperformstheworstintermsoffaultfindingcapabilities, as this approach has triggered the least number of
crashes.Incontrast,Zestperformsthebestasithasfoundoneaddi-
tional crash compared to BeDivFuzz and Quickcheck, though this
crash was only found in 16% of the trials. This is is most likely due
to the coverage-guided algorithm of Zest that allows to effectively
explore deeper paths in the semantic analysis stage compared toQuickcheck.Ontheotherhand,whileBeDivFuzzalsoleverages
coverage guidance, the approach focuses more on diversely execut-
ing many different behaviors through controlled mutations. Thus,BeDivFuzz may miss interesting edge cases that are more likely to
be produced by completely random mutations.
ComparingthemetricsforthebugsfoundbyBeDivFuzz,Zest,
and Quickcheck, it can be noted that Quickcheck finds the crashes
faster and more reliably. The crashes in Closure and Rhino are typ-
ically found within minutes by Quickcheck, while BeDivFuzz and
Zest require hours to discover most of the crashes. This result can
potentially be explained by results in Section 4.3, which show that
Quickcheck already achieved high coverage after a few minutes in
thesesubjects.Incontrast,thesearchalgorithmsof BeDivFuzzand
Zestmighthaveprioritizedexploringotherpartsoftheprogram,
before eventually discovering the crash-inducing behaviors.
Interestingly,BeDivFuzz-structuretendstofindcrashesfaster
than BeDivFuzz-simple, which suggests the importance of the
structural novelty heuristic for fault finding.
4.5 Threats to Validity
Internal Validity. To avoid potential systematic errors that could
posethreatstointernalvalidity,wehavedesignedourexperiments
(replicationcount,timeout,etc.)basedontheguidelinesprovidedby
Kleesetal.[ 23].Additionally,wehavereusedexistingandavailable
implementationsofthebaselinefuzzerswithconformingparameter
settingsfromtheevaluationofRLCheck[ 35].Theparametersfor
BeDivFuzzarenottuned;thuswecanprovideafairandrealistic
comparative evaluation of the different approaches.External Validity.
Ourevaluationfocusesonlyonsixprograms
(Ant,Maven,Rhino,Closure,Nashorn,andTomcat)withtwodiffer-
entinputformats,namelyXMLandJavaScript.Whetherourresults
can be generalized to other programs and other input formats isa threat to external validity. However, the programs under test
represent complex, long-living, and mature programs with a wide-
spread adoption. Thus, we argue that an application of BeDivFuzz
to similar programs would produce similar results.ConstructValidity.
Themainquestiontowardsconstructvalidity
iswhethertheHillnumbers[ 17]forspeciesdiversityareactually
agoodmetrictoevaluatethebehavioraldiversityofthecovered
branchesinafuzzingcampaign.Wearguethatbehavioraldiversity
is given not only if many different behaviors are covered (i.e., a
highbranchcoverage),buteachofthedifferentbehaviorsisequally
covered by many diverse inputs. Utilizing Hill numbers as a metric
specifically accounts for the possible variations in the diverse exe-
cutionof differentbehaviors, whichmay differgreatlydepending
on the chosen fuzzing technique as shown in our evaluation.
5 RELATED WORK
DiversityinFuzzingandSearch-basedTestCaseGeneration
There have been several fuzzing and search-based test case gen-
erationapproachesthattargetdiversityasoneoftheirobjectives.
Theseapproachescanbeclassifiedintoapproachesthata)aimto
achieve diversity in the input space [ 5,11,28,39,46]o rb )i nt h e
coveredbehavioroftheprogramundertestwhenexecutingthetestcases.OneoftheearlierapproachesinthefirstcategoryisAdaptiveRandomTesting(ART)[
11],ablackboxtestingapproachthataims
to distribute the test cases over the entire input space. Technically,
ART selects the next test case that maximizes the minimal distance
to allalready executedtest cases. Asimilar approachis applied in
258
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. BeDivFuzz: Integrating Behavioral Diversity into Generator-based Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Crash-ID BeDiv-simple BeDiv-structure Zest Quickcheck RLCheck
closure.StringIndexOutOfBoundsException 645 (76%) 473 (73%) 82 (100%) 3 (100%) -
closure.NullPointerException 425 (100%) 347 (100%) 149 (100%) 4 (100%) 7 (100%)
closure.RuntimeException 121 (100%) 88 (100%) 5 (100%) <1 (100%) 6 (100%)
rhino.ArrayIndexOutOfBoundsException - - 960 (16%) - -
rhino.ClassCastException 650 (40%) 371 (33%) 606 (56%) 192 (100%) -
rhino.IllegalStateException 1 (100%) 2 (100%) 1 (100%) <1 (100%) <1 (100%)
rhino.NullPointerException 11 (100%) 7 (100%) 5 (100%) <1 (100%) -
rhino.VerifyError 543 (80%) 452 (83%) 212 (100%) 6 (100%) 9 (100%)
nashorn.AssertionError 44 (100%) 48 (100%) 487 (66%) 125 (100%) -
Table 1: Average time (in minutes) and reliability of triggering a particular crash.
thetoolDIG[ 5]fortestingweb-basedapplications.Thedistance
of test cases is computed based on the sequences of actions that
traversethenavigationalmodelofthewebapplication.Insearch-
basedtesting,Sapienzğ‘‘ğ‘–ğ‘£[46]aimstomaintainandimproveaset
of test cases for mobile applications that trigger diverse inputs,
measuredbythedistanceoftestinputsequences.Theâ€œUncommon
inputsâ€ strategy from Soremekun et al. [ 39] creates inputs based
onaninvertedprobabilisticgrammar.Iftheoriginalprobabilistic
grammar is learned from a set of common samples, the hypothesis
is that inverting the probabilities would lead to uncommon and
more diverse inputs.
BeDivFuzz belongs to the second category of approaches since
wefocusonbehavioraldiversityandachievinginputdiversityas
abyproduct.A firststeptowardsbehavioraldiversityis takenin
any greybox fuzzing approach (e.g., [ 2,8,9,15,24â€“26,43,53]) that
aim to maximize some coverage metric in the SUT, such as branch
or statement coverage. The feedback loop in these greybox fuzzing
approachesimplementsanoveltysearchthatvaluestestinputsthat
provideadditional coverage.Thisfeedback loopisalso presentin
hybrid fuzzing approaches (e.g., [ 34,42,52]) that combine greybox
fuzzing with symbolic execution [ 10,13,22,50] or concolic test-
ing [36]. Furthermore, the general idea of greybox fuzzing is taken
a step further in FairFuzz [ 24], VUzzer [ 34], and TortoiseFuzz [ 49].
FairFuzzisanAFL[ 53]extensionwiththegoaloftriggeringrare
branches.ThemainideaofFairFuzzistolearnmutationmasksand
areas that have a higher chance of hitting these rare branches. Tor-
toiseFuzzandVUzzerinsteadprioritizeexplorationofcoderegions
with a high chance of containing a vulnerability. In the case of
VUzzer, the goal is to cover error-handling code, and TortoiseFuzz
aims to cover memory access operations.
In contrast to all these approaches, we argue that just hitting
abranchoncedoesnotprovidebehavioraldiversity.Theexisting
approachesbasicallyaimtooptimizethe ğµ(0)metric(i.e.,branch
coverage)inFigure4,whereasBeDivFuzzalsoprovidesbehavioral
diversity and scores well on the ğµ(1)andğµ(2)metrics.
Fuzzing and Generation of Valid Inputs The generation of
syntacticallyandsemanticallyvalidinputshasalwaysbeenthetar-
getofmodernfuzzingapproaches.Concerningsyntacticallycorrectinputs,thecommonapproachistousemodelstodescribetheinput
structure. Examples are input specifications [ 20,21,44] or gram-
mars [2,14,16,18,30,39,48]. However , having just syntactically
correctinputsisoftennotenough,andtoexploredeeperregions
of the SUT, semantic validity of the inputs is required. Zest [ 32]utilizesvalidityandcodecoveragefeedbacktoproduceinputswith
high semantic coverage. BeDivFuzz is based on the same feedback
mechanismasZest,butextendsitwithnovelstructuralmutation
operators and a structure-aware fuzzing heuristic. RLCheck [ 35]
usesreinforcement-learningtolearnapolicytoguidethegenerator
towardshighinputdiversity.Similarly,BeDivFuzzautomatically
adapts its mutation strategy based on the received feedback. While
ourapproachisbuiltontopoftheseapproaches,themaindistin-
guishingfactoristhatwealsoaimtoproducediversebehavioral
inputstohaveamoresystematicexplorationoftheSUTâ€™sbehavior.
6 CONCLUSION AND FUTURE WORK
In this paper, we have described an approach to generate test in-puts with high behavioral diversity. That is, our approach doesnot only aim to coveras many behaviors as possible, but also to
diversely execute the different behaviors.The key to our approach
istodistinguishbetween structure-changingmutations thatallow
tosearchfornewbehaviorstriggeredbyspecificinputstructures,
andstructure-preserving mutationstodiverselyexecuteaparticular
behavior.Thismethodiscomplementedbyanadaptivemutation
strategy and a new fuzzing heuristic that is based on the structural
novelty of an input. We implemented this approach in BeDivFuzz,
and show that it outperforms the current state-of-the-art w.r.t. to a
novel measure of behavioral diversity that is inspired by a popular
biodiversity metrics in ecology â€” Hill-numbers. In future work, we
wouldliketoprovideguaranteesforourapproachbyevaluating
measures such as the residual risk [ 7] and reliability of a SUT after
we terminate a fuzzing campaign.
ACKNOWLEDGMENTS
We would like to thank the anonymous reviewers for their insight-
fulcommentsandsuggestions,whichhelpedtoimprovethispaper.
This research was partially funded by the Deutsche Forschungs-
gemeinschaft(DFG,GermanResearchFoundation)â€“GR3634/7-1
ProCI(421921612);GR3634/6-1FLASH(261444241);GR3634/4-2
Emperor (392561203).
REFERENCES
[1]AndreaArcuriandLionelBriand.2014. AHitchhikerâ€™sguidetostatisticaltests
forassessingrandomizedalgorithmsinsoftwareengineering. SoftwareTesting,
VerificationandReliability 24,3(2014),219â€“250. https://doi.org/10.1002/stvr.1486
[2]Cornelius Aschermann, Tommaso Frassetto, Thorsten Holz, Patrick Jauernig,
Ahmad-Reza Sadeghi, and Daniel Teuchert. 2019. NAUTILUS: Fishing for Deep
BugswithGrammars.In 26thAnnualNetworkandDistributedSystemSecurity
259
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA Hoang Lam Nguyen and Lars Grunske
Symposium, NDSS 2019. The Internet Society. https://www.ndss-symposium.
org/ndss-paper/nautilus-fishing-for-deep-bugs-with-grammars/
[3]CorneliusAschermann,SergejSchumilo,AliAbbasi,andThorstenHolz.2020.
Ijon:ExploringDeepStateSpacesviaFuzzing.In 2020IEEESymposiumonSecurity
and Privacy, SP 2020. IEEE, 1597â€“1612. https://doi.org/10.1109/SP40000.2020.
00117
[4]BeDivFuzz. 2022. Source code and replication package. https://github.com/hub-
se/BeDivFuzz.
[5]MatteoBiagiola,AndreaStocco,FilippoRicca,andPaoloTonella.2019. Diversity-
basedwebtestgeneration.In ProceedingsoftheJointMeetingonEuropeanSoftware
EngineeringConferenceandSymposiumontheFoundationsofSoftwareEngineering,
ESEC/SIGSOFT FSE. ACM, 142â€“153.
[6]MarcelBÃ¶hme.2018. STADS:SoftwareTestingasSpeciesDiscovery. ACMTrans.
Softw. Eng. Methodol. 27, 2, Article 7 (June 2018), 52 pages. https://doi.org/10.
1145/3210309
[7]MarcelBÃ¶hme,DanushkaLiyanage,andValentinWÃ¼stholz.2021. Estimatingresidual risk in greybox fuzzing. In ESEC/FSE â€™21: 29th ACM Joint European
SoftwareEngineeringConferenceandSymposiumontheFoundationsofSoftware
Engineering, Athens, Greece, August 23-28, 2021, Diomidis Spinellis, GeorgiosGousios, Marsha Chechik, and Massimiliano Di Penta (Eds.). ACM, 230â€“241.
https://doi.org/10.1145/3468264.3468570
[8]MarcelBÃ¶hme,Van-ThuanPham,Manh-DungNguyen,andAbhikRoychoudhury.
2017. Directed Greybox Fuzzing. In Proceedings of the 2017 ACM SIGSAC Confer-
enceonComputerandCommunicationsSecurity (Dallas,Texas,USA) (CCSâ€™17).
ACM, New York, NY, USA, 2329â€“2344. https://doi.org/10.1145/3133956.3134020
[9]Marcel BÃ¶hme, Van-Thuan Pham, and Abhik Roychoudhury. 2016. Coverage-
basedGreyboxFuzzingAsMarkovChain.In Proceedingsofthe2016ACMSIGSAC
ConferenceonComputerandCommunicationsSecurity (Vienna,Austria) (CCSâ€™16).
ACM, New York, NY, USA, 1032â€“1043. https://doi.org/10.1145/2976749.2978428
[10]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
AutomaticGenerationofHigh-coverageTestsforComplexSystemsPrograms.
InProceedings of the 8th USENIX Conference on Operating Systems Design and
Implementation (San Diego, California) (OSDIâ€™08). USENIX Association, Berkeley,
CA, USA, 209â€“224. http://dl.acm.org/citation.cfm?id=1855741.1855756
[11]TsongYuehChen,HingLeung,andI.K.Mak.2004. AdaptiveRandomTesting.
InAdvancesinComputerScience-ASIAN2004,Higher-LevelDecisionMaking,9th
AsianComputingScienceConference(LectureNotesinComputerScience,Vol.3321),
Michael J. Maher (Ed.). Springer, 320â€“329. https://doi.org/10.1007/978-3-540-
30502-6_23
[12]Koen Claessen and John Hughes. 2000. QuickCheck: a lightweight tool for
randomtestingofHaskellprograms.In ProceedingsoftheFifthACMSIGPLAN
InternationalConferenceonFunctionalProgramming(ICFPâ€™00),Montreal,Canada,
September 18-21, 2000, Martin Odersky and Philip Wadler (Eds.). ACM, 268â€“279.
https://doi.org/10.1145/351240.351266
[13]Lori A. Clarke. 1976. A System to Generate Test Data and Symbolically Execute
Programs. IEEETransactionsonSoftwareEngineering SE-2,3(Sept1976),215â€“222.
https://doi.org/10.1109/TSE.1976.233817
[14]Martin Eberlein, Yannic Noller, Thomas Vogel, and Lars Grunske. 2020. Evo-lutionary Grammar-Based Fuzzing. In Proceedings of the 12th Symposium on
Search-Based Software Engineering (SSBSE 2020).
[15]ShuitaoGan,ChaoZhang,XiaojunQin,XuwenTu,KangLi,ZhongyuPei,and
Zuoning Chen. 2018. CollAFL: Path Sensitive Fuzzing. In 2018 IEEE Symposium
on Security and Privacy, SP 2018, Proceedings, 21-23 May 2018. IEEE Computer
Society, 679â€“696. https://doi.org/10.1109/SP.2018.00040
[16]PatriceGodefroid,AdamKiezun,andMichaelY.Levin.2008. Grammar-Based
Whitebox Fuzzing. In Proceedings of the 29th ACM SIGPLAN Conference on
Programming Language Design and Implementation (Tucson, AZ, USA) (PLDI
â€™08). Association for Computing Machinery, New York, NY, USA, 206â€“215.
https://doi.org/10.1145/1375581.1375607
[17]Mark Hill. 1973. Diversity and Evenness: A Unifying Notation and Its Conse-
quences. Ecology54 (03 1973), 427â€“432. https://doi.org/10.2307/1934352
[18]Christian Holler, Kim Herzig, and Andreas Zeller. 2012. Fuzzing with Code
Fragments. In Presented as part of the 21st USENIX Security Symposium (USENIX
Security 12). USENIX, Bellevue, WA, 445â€“458.
[19]PaulHolser.2014. junit-quickcheck:Property-basedtesting,JUnit-style. https:
//pholser.github.io/junit-quickcheck. Accessed: August 26, 2021.
[20] William Johansson, Martin Svensson, Ulf E. Larson, Magnus Almgren, and Vin-
cenzo Gulisano. 2014. T-Fuzz: Model-Based Fuzzing for Robustness Testingof Telecommunication Protocols. In Seventh IEEE International Conference on
SoftwareTesting,VerificationandValidation,ICST2014.IEEEComputerSociety,
323â€“332. https://doi.org/10.1109/ICST.2014.45
[21]Rauli Kaksonen, M. Laakso, and A. Takanen. 2001. System Security Assessment
through Specification Mutations and Fault Injection. In Communications and
MultimediaSecurityIssuesoftheNewCentury,ProceedingsoftheIFIPTC6/TC11
International Conference on Communications and Multimedia Security Issues (IFIP
Conference Proceedings, Vol. 192), Ralf Steinmetz, Jana Dittmann, and Martin
Steinebach (Eds.). Kluwer.[22]James C. King. 1976. Symbolic Execution and Program Testing. Commun. ACM
19, 7 (July 1976), 385â€“394. https://doi.org/10.1145/360248.360252
[23]GeorgeKlees,AndrewRuef,BenjiCooper,ShiyiWei,andMichaelHicks.2018.
Evaluating Fuzz Testing. In Proceedings of the 2018 ACM SIGSAC Conf. on Comp.
and Comm. Security (Toronto, Canada) (CCS â€™18). ACM, New York, NY, USA,
2123â€“2138. https://doi.org/10.1145/3243734.3243804
[24]CarolineLemieuxandKoushikSen.2018. FairFuzz:ATargetedMutationStrat-
egy for Increasing Greybox Fuzz Testing Coverage. In Proceedings of the 33rd
ACM/IEEE Int. Conf. on Automated Software Engineering (Montpellier, France)
(ASE2018).ACM,NewYork,NY,USA,475â€“485. https://doi.org/10.1145/3238147.
3238176
[25]Yuekang Li, Bihuan Chen, Mahinthan Chandramohan, Shang-Wei Lin, YangLiu, and Alwen Tiu. 2017. Steelix: Program-state Based Binary Fuzzing. In
Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering
(Paderborn, Germany) (ESEC/FSE 2017). ACM, New York, NY, USA, 627â€“637.
https://doi.org/10.1145/3106237.3106295
[26]libFuzzer. 2020. A library for coverage-guided fuzz testing - LLVM 3.9 documen-
tation. http://llvm.org/docs/LibFuzzer.html. Accessed: August 26, 2020.
[27]B.LiskovandJ.Guttag.1986. Abstractionandspecificationinprogramdevelopment.
MIT Press Cambridge, MA, USA.
[28]Hector D. Menendez and David Clark. 2021. Hashing Fuzzing: Introducing InputDiversitytoImproveCrashDetection. IEEETransactionsonSoftwareEngineering
(2021).
[29]SantoshNagarakatte,JianzhouZhao,MiloM.K.Martin,andSteveZdancewic.
2009. SoftBound:highlycompatibleandcompletespatialmemorysafetyforc.
InProceedingsofthe2009ACMSIGPLAN ConferenceonProgrammingLanguage
Design and Implementation, PLDI 2009, Dublin, Ireland, June 15-21, 2009, Michael
HindandAmerDiwan(Eds.).ACM,245â€“258. https://doi.org/10.1145/1542476.
1542504
[30] Hoang Lam Nguyen, Nebras Nassar,Timo Kehrer, and LarsGrunske. 2020. Mo-
Fuzz: A Fuzzer Suite for Testing Model-Driven Software Engineering Tools.In35th IEEE/ACM International Conference on Automated Software Engineer-
ing, ASE 2020, Melbourne, Australia, September 21-25, 2020. IEEE, 1103â€“1115.
https://doi.org/10.1145/3324884.3416668
[31]Rohan Padhye, Caroline Lemieux, and Koushik Sen. 2019. JQF: coverage-guided
property-based testing in Java. In Proceedings of the 28th ACM SIGSOFT In-
ternational Symposium on Software Testing and Analysis, ISSTA 2019, Beijing,
China,July15-19,2019,DongmeiZhangandAndersMÃ¸ller(Eds.).ACM,398â€“401.
https://doi.org/10.1145/3293882.3339002
[32]Rohan Padhye, Caroline Lemieux, Koushik Sen, Mike Papadakis, and YvesLe Traon. 2019. Semantic Fuzzing with Zest. In Proceedings of the 28th ACM
SIGSOFT International Symposium on Software Testing and Analysis (Beijing,
China)(ISSTA 2019). ACM, New York, NY, USA, 329â€“340. https://doi.org/10.
1145/3293882.3330576
[33]Peach Tech. 2020. Peach Fuzzer Platform. https://www.peach.tech/products/
peach-fuzzer/peach-platform/. Accessed: August 26, 2020.
[34]Sanjay Rawat, Vivek Jain, Ashish Kumar, Lucian Cojocar, Cristiano Giuffrida,and Herbert Bos. 2017. VUzzer: Application-aware Evolutionary Fuzzing. In24th Annual Network and Distributed System Security Symposium, NDSS 2017,San Diego, California, USA, February 26 - March 1, 2017. The Internet Soci-
ety. https://www.ndss-symposium.org/ndss2017/ndss-2017-programme/vuzzer-
application-aware-evolutionary-fuzzing/
[35]SameerReddy,CarolineLemieux,RohanPadhye,andKoushikSen.2020. Quicklygeneratingdiversevalidtestinputswithreinforcementlearning.In ICSEâ€™20:42nd
International Conference on Software Engineering, 2020, Gregg Rothermel and
Doo-HwanBae(Eds.).ACM,1410â€“1421. https://doi.org/10.1145/3377811.3380399
[36]Koushik Sen. 2007. Concolic Testing. In Proceedings of the Twenty-second
IEEE/ACM International Conference on Automated Software Engineering (At-
lanta, Georgia, USA) (ASE â€™07). ACM, New York, NY, USA, 571â€“572. https:
//doi.org/10.1145/1321631.1321746
[37]Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy
Vyukov. 2012. AddressSanitizer: A Fast Address Sanity Checker. In 2012 USENIX
AnnualTechnicalConference,Boston,MA,USA,June13-15,2012,GernotHeiser
and Wilson C. Hsieh (Eds.). USENIX Association, 309â€“318. https://www.usenix.
org/conference/atc12/technical-sessions/presentation/serebryany
[38]ClaudeE.Shannon.1948. Amathematicaltheoryofcommunication. BellSyst.
Tech. J.27, 3 (1948), 379â€“423. https://doi.org/10.1002/j.1538-7305.1948.tb01338.x
[39]EzekielSoremekun,EstebanPavese,NikolasHavrikov,LarsGrunske,andAn-
dreas Zeller. 2020. Inputs from Hell: Learning Input Distributions for Grammar-
Based Test Generation. IEEE Transactions on Software Engineering (2020).
[40]Ian F. Spellerberg and Peter J. Fedor. 2003. A tribute to Claude Shannon
(1916â€“2001) and a plea for more rigorous use of species richness, species di-
versity and the â€˜Shannonâ€“Wienerâ€™ Index. Global Ecology and Biogeography 12, 3
(2003), 177â€“179. https://doi.org/10.1046/j.1466-822X.2003.00015.x
[41]Evgeniy Stepanov and Konstantin Serebryany. 2015. MemorySanitizer: fast
detectorofuninitializedmemoryuseinC++.In Proceedingsofthe13thAnnual
IEEE/ACMInternationalSymposiumonCodeGenerationandOptimization,CGO
2015, Kunle Olukotun, Aaron Smith, Robert Hundt, and Jason Mars (Eds.). IEEE
260
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. BeDivFuzz: Integrating Behavioral Diversity into Generator-based Fuzzing ICSE â€™22, May 21â€“29, 2022, Pittsburgh, PA, USA
Computer Society, 46â€“55. https://doi.org/10.1109/CGO.2015.7054186
[42]NickStephens,JohnGrosen,ChristopherSalls,AndrewDutcher,RuoyuWang,
Jacopo Corbetta, Yan Shoshitaishvili, Christopher Kruegel, and Giovanni Vi-
gna. 2016. Driller: Augmenting Fuzzing Through Selective Symbolic Exe-
cution. In 23rd Annual Network and Distributed System Security Symposium,
NDSS2016,SanDiego,California,USA,February21-24,2016.TheInternetSoci-
ety. http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2017/09/
driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf
[43]RobertSwieckiandFelixGrÃ¶bert.2021. honggfuzz. https://github.com/google/
honggfuzz. Accessed: August 26, 2021.
[44]PeachTech.2018. PeachFuzzer. https://www.peach.tech/products/peach-fuzzer/.
Accessed: 2018-01-28.
[45]Luca Della Toffola, Cristian-Alexandru Staicu, and Michael Pradel. 2017. Saying
â€™hi!â€™ is not enough: mining inputs for effective test generation. In Proceedings of
the 32nd IEEE/ACM International Conference on Automated Software Engineering,
ASE2017,GrigoreRosu,MassimilianoDiPenta,andTienN.Nguyen(Eds.).IEEE
Computer Society, 44â€“49. https://doi.org/10.1109/ASE.2017.8115617
[46]Thomas Vogel, Chinh Tran, and Lars Grunske. 2021. A comprehensive empirical
evaluationofgeneratingtestsuitesformobileapplicationswithdiversity. Inf.
Softw. Technol. 130 (2021), 106436. https://doi.org/10.1016/j.infsof.2020.106436
[47]Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2017. Skyfire: Data-DrivenSeedGenerationforFuzzing. In 2017IEEESymposium onSecurityandPrivacy,
SP 2017, San Jose, CA, USA, May 22-26, 2017. IEEE Computer Society, 579â€“594.
https://doi.org/10.1109/SP.2017.23
[48]Junjie Wang, Bihuan Chen, Lei Wei, and Yang Liu. 2019. Superion: grammar-aware greybox fuzzing. In Proceedings of the 41st International Conference on
Software Engineering, ICSE 2019. IEEE / ACM, 724â€“735. https://doi.org/10.1109/ICSE.2019.00081
[49]YanhaoWang,XiangkunJia,YuweiLiu,KyleZeng,TiffanyBao,DinghaoWu,andPuruiSu.2020. NotAllCoverageMeasurementsAreEqual:FuzzingbyCoverage
Accounting for Input Prioritization. In 27th Annual Network and Distributed
System Security Symposium, NDSS 2020. The Internet Society.
[50]GuoweiYang,SuzettePerson,NehaRungta,andSarfrazKhurshid.2014. Directed
Incremental Symbolic Execution. ACM Trans. Softw. Eng. Methodol. 24, 1 (2014),
3:1â€“3:42. https://doi.org/10.1145/2629536
[51]GuixinYe,ZhanyongTang,ShinHweiTan,SongfangHuang,DingyiFang,Xi-
aoyang Sun, Lizhong Bian, Haibo Wang, and Zheng Wang. 2021. Automated
conformancetestingforJavaScriptenginesviadeepcompilerfuzzing.In PLDIâ€™21:
42ndACMSIGPLANInternationalConferenceonProgrammingLanguageDesign
andImplementation,StephenN.FreundandEranYahav(Eds.).ACM,435â€“450.
https://doi.org/10.1145/3453483.3454054
[52]InsuYun,SanghoLee,MengXu,YeongjinJang,andTaesooKim.2018. QSYM:APracticalConcolicExecutionEngineTailoredforHybridFuzzing.In 27thUSENIX
SecuritySymposium,USENIXSecurity2018,WilliamEnckandAdriennePorter
Felt(Eds.).USENIXAssociation,745â€“761. https://www.usenix.org/conference/
usenixsecurity18/presentation/yun
[53]MichalZalewski.2021. AmericanFuzzyLop(AFL)-asecurity-orientedfuzzer.
http://lcamtuf.coredump.cx/afl/. Accessed: August 26, 2021.
[54]Peiyuan Zong, Tao Lv, Dawei Wang, Zizhuang Deng, Ruigang Liang, and Kai
Chen. 2020. FuzzGuard: Filtering out Unreachable Inputs in Directed Grey-box
FuzzingthroughDeepLearning.In 29thUSENIXSecuritySymposium,USENIX
Security 2020, Srdjan Capkun and Franziska Roesner (Eds.). USENIX Association,
2255â€“2269. https://www.usenix.org/conference/usenixsecurity20/presentation/
zong
261
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 07:52:58 UTC from IEEE Xplore.  Restrictions apply. 