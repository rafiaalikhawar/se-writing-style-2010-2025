CiFi: V ersatile Analysis of Class and Field
Immutability
1stTobias Roth
Software Technology
Technische Universit ¨at
Darmstadt, Germany
roth@cs.tu-darmstadt.de2ndDominik Helm
Software Technology
Technische Universit ¨at
Darmstadt, Germany
helm@cs.tu-darmstadt.de3rdMichael Reif
Software Technology
Technische Universit ¨at
Darmstadt, Germany
mi.reif.mr@gmail.com4thMira Mezini
Software Technology
Technische Universit ¨at
Darmstadt, Germany
mezini@cs.tu-darmstadt.de
Abstract —Reasoning about immutability is important for pre-
venting bugs, e.g., in multi-threaded software. So far, static
analysis to infer immutability properties has mostly focused
on individual objects and references. Reasoning about ﬁeldsand entire classes, while signiﬁcantly simpler, has gained lessattention. Even a consistently used terminology is missing, whichmakes it difﬁcult to implement analyses that rely on immutabilityinformation. We propose a model for class and ﬁeld immutabilitythat uniﬁes terminology for immutability ﬂavors consideredby previous work and covers new levels of immutability tohandle lazy initialization and immutability dependent on generictype parameters. Using the OPAL static analysis framework,
we implement CiFi, a set of modular, collaborating analyses
for different ﬂavors of immutability, inferring the propertiesdeﬁned in our model. Additionally, we propose a benchmarkof representative test cases for class and ﬁeld immutability. Weuse the benchmark to showcase CiFi’s precision and recall incomparison to state of the art and use CiFi to study the prevalenceof immutability in real-world libraries, showcasing the practicalquality and relevance of our model.
Index T erms—class and ﬁeld immutability, static analysis
I. I NTRODUCTION
Immutability is the property of a program element stating
that it is unchangeable or not changed after its creation [1].
The immutability property is important for program correctness
and security: Immutable data structures are not prone to race
conditions in multi-threaded applications [2]–[4]. Immutable
values are less prone to security issues, hence recommended by
the Secure Coding Guidelines for Java SE [5]. Some APIs, like
Java’s Map interface, assume objects, used as keys, not to be
mutated1[6]. Immutability is also a prerequisite for precisely
deriving other properties, e.g., method purity [7], [8].
In this paper, we focus on immutability of classes and
ﬁelds. Previous research on immutability has often focused
on individual objects and references [8]–[12]. However, ithas been argued [13], [14] that focusing on classes andﬁelds simpliﬁes the implementation of systems that enforce
immutability restrictions2and their usage by developers.
We address the following limitations of the state of the art
in checking and enforcing class and ﬁeld immutability.
First, existing approaches address only individual speciﬁc lev-
els of immutability. For instance, with their final , resp. val
1Mutations that don’t effect equals() comparisons are allowed.
2Immutability restrictions can be, e.g., in the form of annotations.annotations, the Java and Scala programming languages support
a weak level of immutability called non-assignability [1], [8].
Coblenz et al. [14] and Porat et al. [15] deal only with
transitive immutability, where every value referred to directly
or transitively by a transitively immutable class or ﬁeld is
immutable. Nelson et al. [16], on the other hand, deal withnon-transitive immutability of ﬁelds, where non-transitive
immutability only guarantees that the respective ﬁeld is non-
assignable. However, none of the approaches handles both
transitive and non-transitive immutability.
Second, existing approaches do not properly cover com-
mon programming patterns, as we elaborate in Section II.Examples of programming patterns that are not properlyhandled are lazy initialization and generic type parametersoften found in collections and collection-like classes (e.g.
java.util.Optional ). With lazy initialization (cf. List-
ing 1), a ﬁeld is assigned only when it is accessed for the ﬁrsttime. Here, the ﬁeld cannot just be restricted to assignments in
the class’ constructor. In turn, care has to be taken to ensure
that really only a single initialization can be performed. Also,
it has to be ensured that the ﬁeld cannot be observed before
its initialization, as observing different values before and afterinitialization contradicts the guarantees that immutability aims
to provide. Generic classes require special treatment, too, as
their immutability can depend on the immutability of their type
parameters. In Listing 2, the immutability of class Generic
depends on the type parameter Tused for the ﬁnal ﬁeld t.
1class C{
2 private Object object;
3 public synchronized Object getObject() {
4 if(object==null)
5 object = new Object();
6 return object;
7}}
Listing 1. Thread-safe Lazy Initialization Example
1class Generic<T> {
2 private ﬁnal Tt ;
3 public Gen(T t){ this. t=t ;}
4}
Listing 2. Dependently Immutable Class Example
Finally, we lack a common model that provides uniﬁed
terminology for different levels of class and ﬁeld immutability.
9792021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)
Work licensed under Creative Commons Attribution 4.0 License. https://creativecommons.org/licenses/by/4.0/
DOI 10.1109/ASE51524.2021.000902021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE) | 978-1-6654-0337-5/21/$31.00 ©2021 IEEE | DOI: 10.1109/ASE51524.2021.9678903
For instance, deep respectively shallow immutability are used
[1], or just immutability [17] to refer to the same concepts
as(non)-transitive immutability. Hence, we need a uniﬁed
model that not only considers trivial cases, like ﬁnal ﬁelds
with immutable types, but also common programming patterns
such as lazy initialization and generic classes.
The work presented here addresses the above limitations.
First, we deﬁne a model for class and ﬁeld immutability that
incorporates all relevant levels of immutability and precisely
deﬁnes their meaning and relations, thus establishing a consis-
tent terminology. Second, based on the model, we deﬁne CiFi,
a set of modular, independent, collaborating static analysesto infer the different levels of immutability for ﬁelds and
classes, including entire class hierarchies. CiFi uses our OP AL
framework [18] and can be used to reason about codebases
and their immutability guarantees directly by developers or by
further analyses.
We evaluate our work along several dimensions. First, we
demonstrate the expressiveness of the proposed model by
categorizing it along the classiﬁcation system for immutability
support proposed by Coblenz et al. [13]. Second, weevaluate CiFi against CiFi-Bench, a set of handcrafted test
cases annotated with immutability properties. To the bestof our knowledge, such a benchmark did not exist yet –
CiFi-Bench can be used to guide and test other analyses of
class and ﬁeld immutability. We use it to evaluate Glacier, the
state of the art in class- and ﬁeld-immutability enforcement,
to compare its precision and recall with those of CiFi. Finally,
we investigate the extent to which immutability ﬂavors (e.g.,
class and ﬁeld immutability) and levels (e.g., mutable, or
(non-)transitively immutable) deﬁned in our model are found
in real-world libraries. In short, we show that CiFi (i) precisely
identiﬁes important immutability patterns, while soundily
over-approximating remaining edge cases, (ii) thereby clearly
outperforms Glacier, and (iii) identiﬁes signiﬁcant amounts of
immutable data in real-world libraries.
To recap, our contributions are:
•A literature survey on the deﬁnitions and terminology
used for class and ﬁeld immutability (Section II).
•A comprehensive, ﬁne-grained lattice-based model of all
relevant levels of class and ﬁeld immutability (Section III).
•CiFi, a set of modular, collaborating static analyses that
infer the properties deﬁned in the model (Section IV).
•A handcrafted benchmark to serve as a ground truth for
class and ﬁeld immutability analyses (Section V -B1).
•An extensive evaluation of CiFi based on the benchmark,
real-world libraries, and the state of the art (Section V).
We discuss threats to validity in Section VI, present further
related work regarding object and reference immutability in
Section VII, and conclude the paper in Section VIII.
II. S TAT E OFTHE ART
We survey prior work on different levels of class and ﬁeld
immutability. In lack of an existing consistent terminology, we
use the original names for the considered levels.Weak levels of immutability enforcement have been part of
programming language design since decades. In Scala, ﬁelds
can be declared with the keyword val which corresponds
to Java’s final modiﬁer. These constructs prevent the ﬁeld
from being reassigned, but give no guarantee that the object
referenced by the ﬁeld is immutable. With case classes in Scala
and Records [19] introduced in Java 16, these languages also
offer classes that store data in ﬁelds that, implicitly, cannot bereassigned. However, mutable objects can be assigned to them.
To sum up, while the above language features underline the
importance of immutability, they enforce only weak guarantees
that other authors call non-assignability [1], [8].
Potanin et al. [1] introduce the terms shallow and deep
immutability to distinguish between non-assignable ﬁelds
referring to mutable objects or arrays (shallow) and non-assignable ﬁelds (transitively) referring to objects or arraysthat cannot be mutated either (deep). Listing 3 illustratesboth cases. The ﬁnal (non-assignable) ﬁeld
srefers to a
java.util.String (known to be deeply immutable), thus,
sisdeeply immutable. In contrast, the public ﬁeld iArr refers
to an array that can be mutated outside its class (arrays are
mutable), thus, iArr isshallowly immutable.
1public ﬁnal String s = ”string”; // deeply immutable
2public ﬁnal int[] iArr = {42} ;// shallowly immutable
Listing 3. Deep/Shallow Immutability Example
Coblenz et al. [13] use different terms for the same immutability
concepts, namely non-transitive for shallow and transitive for
deep. Their Glacier [14] system uses annotations for Javaclasses and ﬁelds, with
@Immutable enforcing transitive
immutability and@MaybeMutable stating that a ﬁeld or
class is not guaranteed to be transitively immutable. Gordon etal. [2] call transitively immutable ﬁelds just immutable, whereas
Nelson et al. [16] use the term immutable forfinal ﬁelds,
i.e., ﬁelds only guaranteed to be non-transitively immutable.
Glacier has no direct support for non-assignability or non-
transitive immutability, arguing that non-transitive immutabilityprovides only weak guarantees [13]. In order for a class
Cto be
@Immutable in Glacier, (a) all ﬁelds of Cmust be transitively
immutable and may only be assigned in the class’ constructors,
and (b) Cmust have only @Immutable subclasses. Because
of (a), Glacier cannot handle cases where ﬁelds are assigned
outside a constructor, e.g., in lazy initialization. For generic
classes annotated as @Immutable ,Glacier enforces that type
parameters are instantiated with @Immutable types. This is
overly conservative, as type parameters do not necessarilyinﬂuence a class’ immutability. Also, it prevents generic
immutable classes such as immutable collections from being
annotated @Immutable if they are used to store mutable or
non-transitively immutable data.
Porat et al. [15] propose an inter-procedural data-ﬂow
analysis to detect transitively immutable classes and ﬁelds
in Java. According to their deﬁnition, a ﬁeld is immutable if
its value or referee is not mutated after being assigned in the
static initializer or constructor. Like Glacier, this restrictiveimmutability deﬁnition cannot handle lazy initialization. A
980class is said to be immutable, if all of its non-static ﬁelds are
immutable. The approach was implemented and evaluated on
the Java Development Kit (JDK) 1.2 (released in 1998); thus,
it lacks support for newer features of Java, e.g., generics.
Kjolstad et al. [17] use the term immutable for classes
that have only transitively immutable instance ﬁelds. Their
refactoring tool Immutator transforms mutable classes to
immutable ones in order to beneﬁt from the guarantees provided
by transitive immutability. To ensure that all ﬁelds are initialized
in the constructor, Immutator adds two new constructors: A
public one without parameters initializes all ﬁelds with a default
value and a private one taking an initialization parameter for
each ﬁeld. Finally, it rewrites all methods mutating the transitive
state into factory methods and all client methods such that they
access class instances in an immutable way. Immutator makes
transformed classes final to prohibit mutable subclasses.
Thus, the refactoring is limited to classes without subclasses.
With ﬁelds made final , lazy initialization is not possible.
Also, Immutator does not handle generic classes.
/squaresolidThe survey of the state of the art in analyzing class and ﬁeld
immutability reveals that we lack a consistent terminology
for class and ﬁeld immutability. While some authors use deep
and shallow, others use transitive and non-transitive. Still
others use immutable with different meanings.
/squaresolidNone of the existing approaches can simultaneously handle
both non-transitive and transitive immutability. Also, none
of the presented approaches can recognize lazy initialization
and properly handle immutability of generic classes.
/squaresolidEach approach focuses on a ﬁxed composition of im-
mutability ﬂavors, e.g., class and ﬁeld immutability, and
a single level—most often transitive immutability—and it is
not possible for client analyses to get information for other
immutability ﬂavors or levels.
III. M ODEL
We present our uniﬁed model of immutability properties for
ﬁelds, classes, and types along with their order and relations
structured in lattices. While they are simple chains only, this
is in line with the OPAL framework’s [18] terminology andrequirements. We exemplify the properties with Java codesnippets, but the model can be used for any object-oriented
language.
A. Field Assignability
Potanin et al. [1] deﬁne assignability to indicate whether
a static or instance ﬁeld is or can be reassigned after it
is initialized. We extend on that, deﬁning several levelsof assignability which we elaborate below. Their order is
illustrated in Fig. 1.
1) (Effectively) Non-Assignable Fields: Fields can explicitly
be enforced to be non-assignable, e.g., using Java’s final
keyword, or can be effectively non-assignable because there is
no reassignment present and none can be added through other
code that is not analyzed.
Deﬁnition 1: A ﬁeld is non-assignable if it is only assigned
once and cannot be reassigned.Deﬁnition 2: A ﬁeld is effectively non-assignable if it cannot
be observed with different values.
This distinction allows to ﬁnd ﬁelds that are not yet enforced
to be non-assignable but could be made so. Examples for bothcases are given in Listing 4. The ﬁeld
imm (Line 2) is final
and, thus, it is only assigned once (during the execution of
the implicit constructor). As a result, it cannot be reassigned.
Similarly, the ﬁeld effImm (Line 3) is initialized only once and
is never reassigned again. As effImm is declared private ,
no code outside of class Ccan assign to it, thus rendering it
effectively non-assignable.
1class C{
2 private ﬁnal int imm = 42;
3 private int effImm = 42;
4}
Listing 4. (Effectively) Non-Assignable Fields
2) Lazily Initialized Fields: This is a common pattern used
to avoid the cost of computing or storing a value if it is
never accessed, while performing the computation only once
if it is accessed repeatedly. It is often implemented by a ﬁeld
accessible only through a single method that only computes
and stores the value if the ﬁeld still has its default value.
An example of a lazily initialized ﬁeld was given in Listing 1.
As the ﬁeld object isprivate , no other code can access the
ﬁeld except through the method getObject . This method will
initialize the ﬁeld object only if its value is still null .A s
the method is synchronized , it is guaranteed that the ﬁeld
is only initialized once, even in the presence of multi-threaded
execution. Without the synchronized annotation, the ﬁeld
object could be assigned to more than once. This happens if
concurrent threads each see object at its default state ( null )
in Line 4 before any of them performs the assignment in Line 5.
In this case, each thread may assign a different instance to
object , with only the last assignment being persistent. Y et,
for programs known to be single-threaded, one can still providea valuable guarantee. For this reason, we deﬁne two properties
related to lazy initialization: lazily initialized (Deﬁnition 3)
and unsafely lazily initialized (Deﬁnition 4):
Deﬁnition 3: A ﬁeld is lazily initialized, if its lifetime can
be divided into two distinct phases: During the ﬁrst phase,
no accesses to the referenced value are made except to check
whether the ﬁeld must be transferred to the second phase.
During the second phase, the ﬁeld is effectively non-assignable.
Deﬁnition 4: A ﬁeld is unsafely lazily initialized if, as long
as only one thread accesses it, its lifetime can be divided into
two distinct phases: During the ﬁrst phase, no accesses to the
referenced value are made except to check whether the ﬁeld
must be transferred to the second phase. During the second
phase, the ﬁeld is effectively non-assignable.
3) Assignable Fields: Assignable is the top (least precise)
value of the ﬁeld-assignability lattice:
Deﬁnition 5: A ﬁeld is assignable if none of the previous
deﬁnitions apply.
981assignable
unsafely lazily initialized
lazily initialized
effectively non-assignable
non-assignable
Fig. 1. Field-Assignability Lattice
Fig. 1 gives the lattice order of the previously deﬁned levels
of assignability based on the provided guarantees: while non-
assignable ﬁelds cannot be assigned outside the constructor,
effectively non-assignable ﬁelds could be reassigned but
provably are not. In turn, (unsafely) lazily initialized ﬁelds are
reassigned once. However, they can be observed before they
are initialized only by the check for the default value.
B. Field Immutability
Field immutability combines assignability of a given static
or instance ﬁeld fwith the immutability of f’s value. Our
lattice for ﬁeld immutability is shown in Fig. 2. The top (least
precise) value of the ﬁeld-immutability lattice is mutable:
Deﬁnition 6: A ﬁeld is mutable if and only if it is assignable.
For the purpose of this deﬁnition, we treat an unsafely lazily
initialized ﬁeld as assignable if it is unknown whether multiple
threads might access the ﬁeld.
If a ﬁeld fis not assignable, its immutability depends on the
immutability of the values fcan potentially refer to. Primitive
values are always immutable. Array values are mutable (Java
has no concept of immutable arrays), hence, the immutability
of a ﬁeld fthat refers to an array arr depends on whether
arr or any of its elements is actually mutated or could be
mutated by unknown code. The same applies to objects values,
too. However, unlike arrays, for some objects it is possible
to infer whether such mutation is actually possible either by
inspecting the static type of for by analyzing the potential
runtime types of objects that fmay refer to. Line 2 in Listing 5
illustrates a non-assignable ﬁeld that refers to an array that is
not and cannot be mutated. Line 3 illustrates a non-assignable
ﬁeld of type java.lang.String —known to be immutable.
1class C{
2 private ﬁnal int[] iArr = new int[]{ 1, 2, 3, 4 };
3 private ﬁnal String ﬁnalString = ”ﬁnal string”;
4}
Listing 5. Field Immutability Example
Our immutability lattice distinguishes between transitively
immutable and non-transitively immutable ﬁelds:
Deﬁnition 7: A ﬁeld is transitively immutable if it is not
assignable and no object (or array) that can transitively be
reached through the ﬁeld can ever be mutated.
Deﬁnition 8: A ﬁeld is non-transitively immutable if it is
not assignable, but objects (or arrays) transitively reachable
through the ﬁeld might be mutated.mutable
non-transitively immutable
dependently immutable
transitively immutable
Fig. 2. Immutability Lattice
Finally, we deﬁne the level dependently immutable, which
models the effect of generic types on immutability. A ﬁeld
with a generic type T(i.e.,private final T t; ) that is
not assignable (including unsafely lazily initialized only if it
is known that only one thread accesses the ﬁeld) can either
betransitively ornon-transitively immutable depending on the
concrete runtime type of T. Thus, we say that such a ﬁeld is
dependently immutable. The property dependently immutable
is—as generic types are—parameterized over all types that
inﬂuence the reference’s immutability, e.g., above generically
typed ﬁeld tis said to be dependently immutable for T.
Deﬁnition 9: A ﬁeld is dependently immutable if it is not
assignable and the (transitive) immutability of the referenced
object depends on at least one generic type parameter.
C. Class and Type Immutability
To determine whether a ﬁeld is transitively immutable or
not, we need information about class and type immutability.
Class immutability takes the same values as ﬁeld immutability,
i.e., the ones given in Fig. 2 and is deﬁned through ﬁeld
immutability as follows:
Deﬁnition 10: The immutability of a class is the least
upper bound (join) of the immutability of all of its instance
ﬁelds, respecting specialization of generic types for dependently
immutable ﬁelds.
As a corollary, class immutability is the least upper bound
(join) of the immutability of all possible instances of that class
(because the instance ﬁelds’ immutability is determined by
the immutability of their values, which make up the state of
the class’ instances). Not all instances of a class necessarily
have the same immutability property. The following factors
can lead to a more precise immutability of a particular instance
in comparison to the immutability of its class:
Firstly, while some instance ﬁeld fof a class Cmay, in
general, not be effectively non-assignable, it may provably not
be assigned to for a particular instance o. This is, e.g., the
case, if no method that assigns to fever gets invoked on o.
Secondly, during the creation of a particular instance oof a
generic class, type parameters can be substituted by concrete
types. This determines whether dependently immutable ﬁelds of
oare actually transitively or non-transitively immutable. Finally,
while the declared type of a ﬁeld fmight not be transitively
immutable, the concrete object assigned to fcan be, in which
casefbecomes transitively immutable after assignment. Thus,
an instance of a class with ﬁelds that are not transitively
immutable can still be transitively immutable depending on how
982Escape
Field Assignability Field Immutability
Class Immutability Type Immutabilitydependency
cyclic dep.
Fig. 3. Analysis Dependencies
it is created. This is illustrated in Listing 6. Depending on the
constructor used, the ﬁeld nonTransitive in Line 2 can be
assigned either a MutableClass or an ImmutableClass
instance. While an instance of Ccreated with the ﬁrst
constructor is non-transitively immutable, one created with
the second constructor is transitively immutable.
1class C{
2 private ﬁnal Object nonTransitive;
3 public C(MutableClass mc) {nonTransitive = mc; }
4 public C(ImmutableClass ic) {nonTransitive = ic; }
5}
Listing 6. Immutability Dependent on Constructor
It is often useful to determine the immutability at the level
of types, e.g., to quickly determine whether a ﬁeld of a given
static type can be transitively immutable. In object-oriented
languages, a type is either populated by one class (of the same
name as the type) and all of its (potential) subclasses or byan interface (of the same name as the type) and all of itsimplementing classes. Type immutability is deﬁned through
class immutability and also uses the lattice from Fig. 2.
Deﬁnition 11: The immutability of a type is the least upper
bound of the immutability of all classes populating that type.
As a corollary, the type of a final class has the same
immutability as the class. Depending on the analysis scenario,
the set of potential subclasses may not be known completely,
e.g., when analyzing an extensible library; in this case the type
must conservatively be considered to be mutable [15], [20].
IV . C IFI:A NALYSIS IMPLEMENT A TION
CiFi implements the presented model as a set of collaborat-
ing modular analyses for ﬁeld assignability and for ﬁeld, class,
and type immutability based on our static analyses framework
OP AL [21]. OP AL enables the composition of decoupled inter-
dependent static analyses that collaborate via a blackboardarchitecture [18] model for ﬁxed-point computations. The
results of CiFi can be used to derive immutability guarantees
introduced in Section I or to reveal their possible absence.
A. Overall Architecture of CiFi
Fig. 3 shows the dependencies between CiFi’s analyses.
Field immutability depends on ﬁeld assignability and type
immutability. The latter depends on class immutability, which,
in turn, depends on ﬁeld immutability. The analysis for ﬁeld
assignability depends on an escape analysis for determining
effective non-assignability of ﬁelds. This analysis is not shown
in bold font as we used an escape analysis provided by OP AL.As indicated by the red arrows in Fig. 3, there is a circular
dependency of analyses. Thanks to OP AL ’s blackboard archi-
tecture and ﬁxed-point solver, analyses, including cyclically
dependent ones, execute in an interleaved way, even if otherwise
autonomous. Thus, despite the cycle, our analyses can proﬁt
from the intermediate results of each other. This simpliﬁesthe implementation of CiFi’s analyses and enables to easilyexchange their implementation or add further analyses for
trading off precision, soundiness, and performance.
B. Field-Assignability Analysis
The ﬁeld-assignability analysis is based on the respective
lattice (cf. Fig. 1) and is a prerequisite for the ﬁeld-immutability
analysis. We omit a discussion of more trivial aspects and focus
on handling assignments outside of constructors. Simpliﬁed
pseudocode for handling lazy initialization is shown in Listing 7.
The analysis checks whether an initialization is only performed
after a default-value check (e.g., null in case of objects) has
succeeded (Line 2). To determine thread safety, the analysis
checks whether the initialization is performed in a synchronized
method or a block synchronized on the object holding the
ﬁeld (Line 3). Furthermore, the analysis ensures that even if
exceptions are thrown within the lazy initialization method,
either the ﬁeld is guaranteed to be written before its value is
returned, or its value is not returned at all (Line 4).
1fun isFieldLazilyInitialized(ﬁeld):
2 if(initializationNotWithinDefaultV alueCheck(ﬁeld) ||
3 initializationNotSynchronized(ﬁeld) ||
4 exceptionsLeakUninitializedField(ﬁeld)) false
5 else true
Listing 7. Lazy Initialization Recognition (Pseudocode)
Additionally, CiFi is able to recognize ﬁelds that are assigned
only on freshly created instances before they can be accessed
elsewhere. For this purpose CiFi checks that the instance does
not escape before it is returned. This pattern, illustrated in
Listing 8, is often used to implement the clone method.
1class C{
2 private int i;
3 public C clone(){
4 Cc=new C();
5 c . i=i ;
6 return c;
7 }
8}
Listing 8. Clone Pattern
C. Field-Immutability Analysis
The ﬁeld-immutability analysis combines results from anal-
yses for ﬁeld assignability and class and type immutability. Its
logic is sketched in Listing 9. It always considers assignable
ﬁelds mutable (Line 2). For all other ﬁelds, it checks whether allobjects assigned to the ﬁeld can be identiﬁed (Line 3). If this isthe case, the join of the respective class immutability propertiesis computed and used (Line 4), otherwise the immutability for
the ﬁeld’s static type is checked (Line 5).
9831fun getFieldImmutability(ﬁeld):
2 if(isFieldAssignable(ﬁeld)) Mutable
3 else if (canAllAssignedObjectsBeIdentiﬁed(ﬁeld))
4 join(getAssignedObjects(ﬁeld).map( .getClassImmutability))
5 else if (getTypeImmutability(ﬁeld)==TransitivelyImmutable)
6 TransitivelyImmutable
7 else if (hasGenericType(ﬁeld)) // Dependent Immutablity
8 if(onlyTransitivelyImmutableTypeParams(ﬁeld))
9 TransitivelyImmutable
10 else if (hasANotTransitivelyImmutableTypeParam(ﬁeld))
11 NonTransitivelyImmutable
12 else DependentlyImmutable
13 else NonTransitivelyImmutable
Listing 9. Field Immutability Analysis (Pseudocode)
The analysis recognizes dependently immutable ﬁelds using
information from the ﬁeld’s Signature attribute in the Java
Bytecode. If the Signature attribute contains generic type
parameters, the ﬁeld might be dependently immutable (Line 7).
In this case, it is checked whether all generic type parameters
are instantiated with transitively immutable types (Line 8);
if this is the case, the ﬁeld is transitively immutable. It is
next checked whether at least one generic type parameter was
instantiated with a type that is non-transitively immutable or
mutable (Line 10). In this case, the ﬁeld is non-transitively
immutable. If neither of the latter two cases applies, the ﬁeld
is dependently immutable (Line 12).
This handling of ﬁelds with generic types is exempli-
ﬁed in Listing 10. First note that class GC isdependently
immutable for T because of its generically typed ﬁeld
genericField (Line 2). For ﬁeld gcTransitive in
Line 6, the single generic type parameter is instantiated
with the transitively immutable type java.lang.Integer .
Thus, gcTransitive is also transitively immutable. In
turn, the generic type parameter of ﬁeld gcMutable in
Line 7 is instantiated with the (presumably mutable) type
MutableClass . Thus, gcMutable is only non-transitively
immutable. Finally, for ﬁeld gcGeneric in Line 8, the
generic type parameter is instantiated with another generic type
parameter, T. Thus, gcGeneric is dependently immutable.
1ﬁnal class GC<T> {
2 private ﬁnal T genericField;
3 public GC(T value){ this.genericField = value; }
4}
5class C<T> {
6 private ﬁnal GC<Integer> gcTransitive;
7 private ﬁnal GC<MutableClass> gcMutable;
8 private ﬁnal GC<T> gcGeneric;
9 [...]
10 }
Listing 10. Dependent Immutability
D. Class- and Type-Immutability Analysis
The class-immutability analysis of a class Cjoins the
immutability of C’s parent class and the immutability of the
instance ﬁelds declared in C(cf. Deﬁnition 10). Simpliﬁed pseu-
docode of its logic is shown in Listing 11. Note that interfacesimplemented by
Cdo not have to be considered as they cannot
contain instance ﬁelds. As analyzing java.lang.String ’simmutability is far from trivial, CiFi is conﬁgured to treat it as
transitively immutable. This is in line with other immutability
analyses (e.g., [15]) that are conﬁgured similarly. Also, we do
not consider specialization of generic type parameters.
1fun getClassImmutability(class):
2 classImm = getClassImmutability(getSuperClass(class))
3 for ﬁeld in class.instanceFields
4 ﬁeldImm = getFieldImmutability(ﬁeld)
5 if(ﬁeldImm >classImm) classImm = ﬁeldImm
6 classImm
Listing 11. Class Immutability Analysis (Pseudocode)
The type-immutability analysis’ logic is sketched in List-
ing 12. It follows the deﬁnition of type immutability in
Deﬁnition 11, joining the individual classes’ immutability
properties while taking into consideration whether the analysis
is performed in a closed- or open-world scenario (Line 2).
1fun getTypeImmutability(class):
2 if(isExtensible(class)) return Mutable
3 typeImm = getClassImmutability(class)
4 for subclass in class.allSubclasses
5 classImm = getClassImmutability(subclass)
6 if(classImm >typeImm) typeImm = classImm
7 typeImm
Listing 12. Type Immutability Analysis (Pseudocode)
While other tools usually support only one (cf. [13]), CiFi lets
users conﬁgure either open- or closed-world assumption. Underopen-world assumption, it assumes classes can be added to all
packages except for subpackages of java3and all non-ﬁnal
classes can be extended. Under closed-world assumption, itassumes no classes can be added to existing packages and
existing classes cannot be extended. However, public ﬁelds
and methods are assumed to be accessible.
E. Threats To Soundness
CiFi does not consider any ﬁeld access by means of reﬂection,
sun.misc.Unsafe , or native methods calls. Such accesses,
potentially anywhere in the program, cannot reliably be linked
to speciﬁc ﬁelds. Consciously omitting such features in order
to improve precision is called soundiness by Livshits et al. [22].
Doing so is in line with other state-of-the-art static immutability
analyses; e.g., Porat et al. [15] do not consider native code and
“dynamic effects resulting from reﬂection” in their class- and
ﬁeld-immutability analyses.
V. E V ALUA TION
Our evaluation4targets the following research questions:
RQ1 How expressive is our model relative to the classiﬁcation
of immutability facets deﬁned by Coblenz et al. [13]?
RQ2 How precisely and soundily does CiFi fulﬁll our model?
RQ3 How does CiFi compare to the state of the art5with
respect to the previous question?
3The classloader usually prohibits adding new classes to these packages.
4For reproducibility: https://doi.org/10.5281/zenodo.5227231
5We consider Glacier [14] (cf. Section II) as the state-of-the-art approach
in enforcing class and ﬁeld immutability.
984RQ4 Does our model reﬂect immutability facets in the real
world?
The rationale for these questions is as follows. Once we
demonstrate the model’s conceptual quality ( RQ1 ) and check
that CiFi precisely and soundily implements it ( RQ2 ,RQ3 ),
we use CiFi to assess the model’s practical quality (RQ4).
A. Expressiveness of the Model
For RQ1 , we use the system that Coblenz et al. [13] proposed
for classifying mutability restrictions along several dimensions.
a) Type of Restriction: Our model considers the im-
mutability of ﬁelds, classes and types, not just read-only
restrictions on individual references. This provides stronger
guarantees for developers [13]. We also consider assignability
for ﬁelds. We do not consider ownership of objects, which we
discuss in Section VII together with read-only restrictions.
b) Scope: Our model focuses on class immutability, which
Coblenz et al. [13] point out to be frequently needed.
c) Transitivity: We consider both transitive and non-
transitive immutability. This enables a more ﬁne-grained view
compared to systems surveyed by Coblenz et al.
d) Initialization: We do not support explicit relaxing of
restrictions during initialization. However, our deﬁnition of lazy
initialization also encompasses delayed initialization, if ﬁelds
are assigned only once, also enabling cyclic data structures.
e) Abstract vs. Concrete State: We consider the set of all
instance ﬁelds of an object, i.e., its concrete state. Immutability
can also be deﬁned on abstract state [9], [11]6, encoded by
annotations. Assuming such annotations are available, our
model can be applied to abstract state, too.
f) Backward Compatibility: Our approach performs static
analysis to infer immutability; it does not require developers touse speciﬁc language features or annotations. Thus, it is soundy
regardless of potentially unknown code interfacing with the
analyzed software when used with an open-world assumption.
If the analyzed program cannot be extended, a closed-world
assumption can be used to uncover more immutability.
g) Enforcement: We infer immutability instead of enforc-
ing it, but do provide static guarantees on immutability. Static
enforcement may burden developers if they have to annotate
all relevant program constructs [13]. This concern does not
apply to our automated inference.
h) Polymorphism: Handling mutable and immutable
parameters of functions is not applicable to our approach that
infers actual immutability instead of enforcing restrictions.
/squaresolidOur model is more expressive than approaches surveyed
by Coblenz et al. [13] without completely covering thedescribed design space. To balance expressiveness with
usability [14], we focus on ﬁelds, classes, and types, which
improves usability [13], [14]. Yet, the model can be easily
extended, e.g., with object or reference immutability. Such
extensions are well-supported by CiFi’s inference approach
(no annotations) and its modular architecture, enabling
to plug-and-play analyses depending on what results are
considered relevant.
6Excluding some non-essential state, e.g., ﬁelds used for caching.B. Precision and Recall
A ground truth is needed to validate precision and recall
of CiFi and other analyses w.r.t. our model. To the best of
our knowledge, no benchmark for class and ﬁeld immutability
exists that could be annotated with our model’s properties.
Thus, we handcrafted CiFi-Bench.
1) Benchmark: CiFi-Bench7includes a total of more than
470 test cases for all immutability levels deﬁned in our model,
organized into 13 categories:
•Assignability: different (effectively) (non-)assignable ﬁelds
including clone pattern (counter)examples.
•General: simple cases, e.g., static ﬁelds, interfaces, trivially
transitively immutable and mutable classes.
•Known Types
– Single: cases where a single concrete object is assigned
to a ﬁeld, yielding stronger immutability guarantees than
possible to infer from the ﬁeld’s static type.
– Multiple: cases where different objects can be assigned
to a ﬁeld and stronger immutability guarantees can be
inferred than possible from the ﬁeld’s static type, includingcases where concrete objects or only their types are known.
•Generic
– Simple: cases of immutability in combination with generic
types, i.e., dependent immutability.
– Extended: advanced usages of generics such as multiple
nested generic types and generic types with bounds.
•Arrays
– Non-Transitive: cases with mutable arrays resulting in
non-transitively immutable ﬁelds.
– Transitive: cases with arrays that cannot be or are not
mutated, resulting in transitively immutable ﬁelds.
•Lazy Initialization
– Arrays: cases of lazy initialization of array typed ﬁelds.
– Objects: cases of thread-safely as well as unsafely lazily
initialized ﬁelds with object types.
– Primitive Types: lazy initialization without synchroniza-
tion which can be thread-safe for primitive types.
– Scala Lazy val: an example modeled after Scala 2.12’s
implementation of lazy val [23].
•String: a class with two ﬁelds modeled after the
shared char array and hashCode method of
java.lang.String.
We annotated ﬁelds, classes, and types with the respective
assignability and immutability properties as expected with anopen-world assumption.
2) Results for CiFi: For each test case tc, CiFi either
produces the precise value annotated in tc(in ﬁve categories),
or a soundy over-approximation, i.e., a value further up in the
respective lattice, which is less precise than possible but can
be soundily used by further analyses/optimizations. CiFi did
not produce any unsoundy results, i.e., values further down in
the lattice. In some more detail, the results are as follows:
7https://github.com/opalj/CiFi-Benchmark
985•CiFi inferred immutability properties precisely for the cate-
gories: Assignability, General, Known Types, Generic/Sim-
ple, Arrays/Non-Transitive, Lazy Initialization/Arrays, and
Lazy Initialization/Objects.
•In category Generic/Extended, CiFi soundily over-
approximates some complex test cases such as doublynested generic classes (
Gen<Gen<T>> ), generic cases
with bounds, and more complex lazy initialization patterns
than the one we described in Section IV -B . For doubly
nested generics, the approximation is not mutable,b u t non-
transitively immutable, retaining some precision. Generic
classes with bounds are soundily over-approximated as
dependently immutable.
•InArrays/Transitive, CiFi soundily over-approximates
all tests to non-transitively immutable, and in Lazy
Initialization/Primitive Types tounsafely lazily initialized
orassignable. All test cases in Lazy Initialization/Scala
Lazy V al and String are soundily over-approximated to
assignable, except for the ﬁeld referring to the ﬁnal
char array in the category String which is soundily over-
approximated to non-transitively immutable.
/squaresolidCiFi matches the annotated properties of the benchmark
either precisely or soundily over-approximates them. Theobserved over-approximations are due to missing supportfor the respective features. Leaving complex features outof scope when the expected beneﬁt is small is in line withother immutability analyses [15]. Handling these complexfeatures precisely would not lead to considerably more
immutability being recognized, as they represent rare corner
cases. Handling each of these corner cases would only
prevent few over-approximations.
C. Comparison with Glacier
To answer RQ3 , we run Glacier [14], the state-of-the-art
tool for enforcing class and ﬁeld immutability on CiFi-Bench.
As Glacier only considers transitive immutability, we can
only evaluate it w.r.t. this level of immutability. Hence, we
annotated all classes and ﬁelds of CiFi-Bench with Glacier’s
@Immutable annotation. We consider Glacier to pass a test if
either of the following holds: (a) it does not output an error fortransitively immutable ﬁelds and classes, (b) it outputs such an
error for ﬁelds and classes that are not transitively immutable
(since Glacier, does not handle non-transitive or dependent
immutability, respective ﬁelds have to be considered mutable).
The results for each category are as follows.
•For category Known Types/Multiple, Glacier can enforce
transitive immutability.
•For two cases in General resp. Known Types/Single,
Glacier produces unsound results. First, Glacier treatsboth
@Immutable and@MaybeMutable classes as
subtypes of java.lang.Object . Thus, a mutable
object can be assigned to an @Immutable ﬁeld of type
Object . Second, while Glacier prohibits assignments
to ﬁelds outside of the constructor, it does not check
whether a ﬁeld being assigned in a constructor belongs tothe object being constructed. Thus, @Immutable ﬁelds
can be mutated while constructing other objects. Both
cases are shown in Listing 13.
1 @Immutable class C{
2 @Immutable private Object o;
3 public C(C parent, Object o){ parent.o = o; }
4}
Listing 13. Glacier Unsoundness Example
•Glacier was unsound in three Assignability tests. Two
are again due to @MaybeMutable being a subtype of
java.lang.Object , but the third one revealed another
issue: Glacier ignores compound-assignment operators
like+=. Thus, primitive or java.lang.String ﬁelds
can be mutated outside of constructors. In CiFi, suchomissions are less likely to occur accidentally as it
analyzes bytecode. Additionally, Glacier could not handle
the clone pattern cases properly because of assignments
outside of constructors.
•Glacier passed all test cases in Generic as it enforces that
only@Immutable types are used for type parameters
of@Immutable classes and only @Immutable classes
can extend @Immutable classes. But this means that
Glacier cannot handle dependent immutability, which
results in lost opportunities for being more precise.
•In category Arrays, non-transitively immutable ﬁelds are
handled correctly. Some transitively immutable ﬁeldsare also enforced correctly, but require four anno-tations:
@Immutable int @Immutable[] arr =
new @Immutable int @Immutable[5]; Glacier
cannot enforce transitive immutability where array ele-
ments are not mutated, despite not being @Immutable .
•In category Lazy Initialization, Glacier cannot enforce tran-
sitive immutability due to its rule that in @Immutable
classes, ﬁelds may only be assigned in constructors.
•In category String, Glacier handles the case concerning
thechar array shared between identical strings precisely,
but it cannot enforce immutability for the lazily initialized
ﬁeld caching the hashCode method’s result.
/squaresolidGlacier can only recognize transitive immutability com-
pared to CiFi’s ﬁne-grained immutability results.
/squaresolidGlacier shows three cases of unsoundness.
/squaresolidWhile Glacier strictly enforces transitive immutability for
generics, including nested and bounded generic types, it lacks
the ﬂexibility of dependent immutability to allow generic
classes to be treated differently depending on whether they
are instantiated with transitively immutable types or not.
Additionally, Glacier does not handle lazy initialization.
/squaresolidTo recap, CiFi is more soundy and often more precise than
Glacier without requiring manual effort for annotations. As
a result, CiFi can be applied easily to existing codebases
and third-party code, even if source code is not available.
D. Immutability Prevalence
To answer RQ4 , we analyzed the following libraries: Open-
JDK 1.8.0 292, Google Guava 30.1.1, Eclipse Collections
986T ABLE I
LIBRARY RESUL TS ASSIGNABILITY (O PEN WORLD )
Library ass. unsafe l. i. l. i. eff. non ass. non ass./summationtext
OpenJDK 26 684 351 189 8 615 58 115 93 954
Eclipse 2 380 0 0 30 11 478 13 888
Guava 656 12 0 4 3 215 3 887
Apache 275 18 0 4 652 949
Scala 1 249 0 0 4 5 373 6 626
ass. = assignable, l. i. = lazily initialized, eff. = effectively
T ABLE II
LIBRARY RESUL TS IMMUT ABILITY (O PEN WORLD )
Library Analysis mutable non-tra. dep. tra./summationtexttime (s)
Field 27 035 23 004 78 43 837 93 9545.47OpenJDK Class 12 398 4 259 27 5 393 22 077(6.17)Type 20 155 1 475 6 3 203 24 839
Field 2 380 7 620 142 3 746 13 8881.56Eclipse Class 883 4 410 61 2 247 7 601(2.72)Type 6 186 364 41 1 057 7 648
Field 668 1 995 35 1 189 3 8871.06Guava Class 636 785 17 721 2 159(1.79)Type 1 697 195 9 391 2 292
Fields 293 360 18 278 9490.81Apache Class 262 147 7 69 485(1.66)Type 424 49 1 50 524
Field 1 249 3 433 344 1 600 6 6261.57Scala Class 490 2 109 74 1 150 3 823(5.50)Type 3 331 661 60 430 4 482
dep. = dependently immutable, tra. = transitively immutable
10.4, Apache Commons Collections 4.4.4., and Scala 2.12.10.
We performed the evaluation on a server with two AMD(R)
EPYC(R) 7542 CPUs (32 cores / 64 threads each) @ 2.90
GHz and 512 GB RAM. For runtimes, we report the median
of 15 executions as runtimes of OPAL vary signiﬁcantly.
CiFi was run using OpenJDK 1.8.0 292, Scala 2.12.13, and
the Scala build tool sbt 1.4.6 with 32 GB of heap memory. In
this experiment, we applied an open-world assumption. Toease analysis, OP AL replaces
invokedynamic bytecode
instructions with synthetic ﬁelds and classes that are alsoincluded in the result ﬁgures. The number of ﬁelds havingthe respective levels of assignability and the total numberof analyzed ﬁelds are shown in Table I. Results for theﬁeld-,
class-, and type-immutability analyses are given in
Table II, listing the number of entities with respective levels of
immutability, total count and execution time for all analyses
combined. Total runtime including preparatory steps, e.g.,
loading the libraries’ ﬁles is given in parentheses. While the
numbers for types include interfaces, those for classes do not
(interfaces don’t contain potentially mutable state).
The results provide empirical evidence that most of the
immutability properties deﬁned in Section III are prevalent in
real-world libraries. Even if absolute numbers for dependent
immutability appear to be low, one has to consider that generic
classes are often widely used collections and thus can havea signiﬁcant impact. We found several hundreds of safelyT ABLE III
LIBRARY RESUL TS ASSIGNABILITY (C LOSED WORLD )
Library ass. unsafe l. i. l. i. eff. non ass. non ass./summationtext
OpenJDK 22 885 435 198 12 321 58 115 93 954
Eclipse 2 380 0 0 30 11 478 13 888
Guava 598 30 0 44 3 215 3 887
Apache 269 21 0 7 652 949
Scala 1 249 0 0 4 5 373 6 626
ass. = assignable, l. i. = lazily initialized, eff. = effectively
T ABLE IV
LIBRARY RESUL TS IMMUT ABILITY (C LOSED WORLD )
Library Analysis mutable non-tra. dep. tra./summationtexttime (s)
Field 23 320 24 269 80 46 285 93 9547.61OpenJDK Class 11 573 4 741 31 5 732 22 077(8.58)Type 13 378 5 225 35 6 201 24 839
Field 2 380 7 595 142 3 771 13 8881.92Eclipse Class 883 4 397 61 2 260 7 601(3.27)Type 950 4 552 60 2 086 7 648
Field 628 1 931 36 1 292 3 8871.58Guava Class 633 773 18 735 2 159(2.35)Type 715 848 20 709 2 292
Fields 290 353 18 288 9491.17Apache Class 262 142 9 72 485(1.98)Type 294 146 9 75 524
Field 1 249 3 314 359 1 704 6 6262.48Scala Class 490 2 064 96 1 173 3 823(6.53)Type 770 2 196 134 1 382 4 482
dep. = dependently immutable, tra. = transitively immutable
and unsafely lazily initialized ﬁelds in the JDK and some
in Guava and Apache Commons Collections, but none in
Eclipse Collections. We studied the latter library’s source code
and indeed Eclipse Collections seems not to use any lazy
initialization at all. CiFi does not (yet) handle Scala’s lazy
val , but lazy initialization is a prominent feature of the Scala
language, too. We can also see that all libraries have signiﬁcant
quantities of (effectively) non-assignable ﬁelds; OpenJDK has
about 46% of transitively immutable ﬁelds, while the otherlibraries have mostly non-transitively immutable ﬁelds. All
libraries also have signiﬁcant shares of (non-)transitively and
dependently immutable classes, ranging from 43% to 88%. To
recap, the results presented so far signify the relevance of our
immutability model in practice. The properties of the model
prevail despite the fact that CiFi over-approximates the model
in several cases (cf. RQ2 ) and that it was executed with a
conservative open-world assumption. To investigate the effect
of the latter, we re-executed CiFi on the same libraries withthe same setup but with a closed-world assumption. Results
for ﬁeld assignability are given in Table III and for the other
analyses in Table IV. Comparing to the open-world scenario
(cf. Tables I and II), we make the following observations.
First, the number of types with stronger immutability
guarantees increases signiﬁcantly. This is to be expected, as no
subclasses can be added in the closed-world scenario. Second,
the impact on the number of ﬁelds and classes found to
987exhibit different levels of assignability and immutability is
minimal. Differences are most signiﬁcant for OpenJDK, where
14.2% of formerly assignable and 13.7% of formerly mutable
ﬁelds and 6.7% of formerly mutable classes exhibit stronger
guarantees for assignability or immutability, respectively. The
increased number of types with stronger immutability guar-
antees does not proportionally inﬂuence ﬁeld immutabilitydue to the high percentage of ﬁelds with primitive types or
typejava.lang.String (e.g, >50% in OpenJDK). Third,
the runtime increased by 23% up to 58%. This is becausein an open-world scenario, we avoid performing expensive
computations, e.g., for extensible types or for protected non-
ﬁnal ﬁelds in extensible classes, which are just mutable.
/squaresolidAll immutability levels and ﬂavors of our model are
prevalent in real-world libraries. This means that (a) the
deﬁnitions in our model reﬂect immutability in practice and
(b) the versatile inference of CiFi is needed to consider ﬁne-
grained levels and diverse ﬂavors of immutability.
/squaresolidExcept for type immutability, applying an open-world
assumption does not seem to signiﬁcantly reduce precision
while consuming signiﬁcantly less computation time. Thus, it
may be beneﬁcial to use an open-world assumption even if
all program code is available. CiFi gives users the ﬂexibility
to choose between an open- and a closed-world assumption.
VI. T HREA TS TO VALIDITY
An internal validity threat arises if CiFi-Bench does not
cover relevant aspects of class and/or ﬁeld immutability, or if
its test cases are annotated incorrectly. To mitigate this threat,
tests were created by one author based on the literature survey
and checked by a second author. All authors have years of
experience in static analysis and immutability research.
An external threat to validity arises if the libraries used for
evaluation are not representative of real-world immutability.
However, we chose well-known libraries of signiﬁcant size that
include a signiﬁcant number of data structures many of which
are documented to be immutable. The Scala standard library
also provides an insight into immutability for Java Virtual
Machine bytecode not compiled from Java source code.
VII. R ELA TED WORK
In this section, we discuss approaches to object and reference
immutability. They are related but not the main focus of this
work. We surveyed approaches that, like our work, address
class and ﬁeld immutability in Section II.
Haack et al. [4] distinguish observational and state-based
immutability. Observational immutability describes that anobserver is not able to see any difference in an object atany two points in time after its initialization. State-basedimmutability describes that the internal state of an objectdoes not change at all. Like in our model, for state-basedimmutability, the distinction is made between transitive andnon-transitive immutability. Haack et al. express their beliefthat observational immutability is more intuitive while state-
based immutability is better-suited for static analysis. This isin line with our approach which also considers state-based
immutability.
Potanin et al. [1] distinguish between abstractly immutable
objects that may change their internal representation whilepreserving their semantics as visible by their clients andrepresentationally immutable objects that never change their
internal representation. This corresponds to observational and
state-based immutability as used by Haack et al.
Zibin et al. [11] enforce transitive immutability of ﬁelds that
belong to an object’s abstract state with their language extension
Immutability Generic Java (IGJ) that uses Java generics to
describe the immutability of a class through an additional type
parameter (Mutable, Immutable,o rReadOnly).
Ownership Immutability Generic Java (OIGJ) [24] by Zibin
et al. uses ownership to enforce object immutability. As only an
object’s owner can mutate it, it is easy to check for mutations
if the owner is known. Leino et al. [25] also use ownership tofreeze any object at any time during program execution. When
an object is frozen, its owner is changed to be the freezer
object. As that object is not exposed to the rest of the program,
and as changing ﬁelds requires ownership, the frozen object
becomes immutable and cannot be unfrozen again. This applies
to objects owned transitively by the frozen object as well.
For references, the readonly property has been studied
extensively [8]–[12], [26]–[28]. Tschantz and Ernst use it in
the Javari type system [9]. Through a readonly reference,
the referenced object and all transitively referenced objects
belonging to the abstract state of the referenced object cannot
be mutated, while they may still be mutated through otherreferences. Thus, readonly is different from the transitive
immutability property – the latter requires the referenced
object, including all transitively referenced objects, to beimmutable through any reference. Additionally, a romaybe
modiﬁer expresses polymorphic immutability of references,
i.e., whether the reference returned by a method is mutable or
not depends on the context in which the method is accessed and
whether the object referred to by this reference, also transitively,
is mutated or not. That is, a method may return a potentially
mutable but not yet escaped object as romaybe, allowing the
caller to treat it as immutable or mutate it. To support lazy
initialization, it is possible to exclude lazy initialized ﬁelds fromthe abstract state in Javari (cf. [8]). Gordon et al. [2] describe asimilar concept to readonly, but use the term readable instead.
Huang et al. use Javari as a basis for their type system
ReIm and their immutability and purity analysis ReImInfer [8].
However, they use polyread instead of romaybe. Additionally,
while Javari’s readonly modiﬁer refers to the abstract state,
herereadonly applies to the concrete state of the referenced
object, i.e., it includes all ﬁelds and referenced objects.
Milanova and Dong [29] build upon ReIm to infer and check
object immutability by combining a reference immutabilityanalysis with escape analysis. They consider transitive im-mutability, enforcing that no transitively referenced values,
objects, or arrays of an immutable object are mutated. They
also address delayed object initialization with their endorse
modiﬁer for statements. This results in the analysis ignoring the
988statement’s effects on immutability, which is, e.g., necessary to
support circular initialization. With the unstrict block, Gordon
et al. [2] present a similar approach.
Quinonez et al. [10] ﬁnd it “tedious and error-prone” to
manually add modiﬁers like readonly to existing code bases.
They propose to infer them automatically with Javariﬁer, which
can also infer Javari’s modiﬁers for arrays and their values as
well as for the type parameters of generic classes.
Boyland [30] cautioned against adding readonly to the Java
language because its transitive rule would be too restrictive
while it cannot prevent harmful observational exposure, i.e., the
state of a mutable ﬁeld can be seen via a readonly reference
while it can be modiﬁed through another reference. This leads
to problems, e.g., in multi-threading contexts or when a client
expects a non-mutable object. Our model is in line with Boyland
and considers the immutability of an entire class rather than the
immutability through a given reference. This avoids harmful
observational exposure because a transitively immutable class
has only transitively immutable instances.
VIII. C ONCLUSION
We proposed a comprehensive, ﬁne-grained lattice model for
ﬁeld assignability and for ﬁeld, class, and type immutability.
Based on a literature survey, the model uniﬁes the terminologyof the research area, which has so far been used inconsistently.
Unlike the state of the art, the model distinguishes betweenthese different ﬂavors of immutability and provides levelsof immutability to represent relevant aspects such as lazily
initialized ﬁelds and dependent immutability for generic classes.
As we have shown, our model covers a wider range of
immutability than previous models. Accompanying this model,
we provide CiFi-Bench, a handcrafted set of test cases to serve
as a ground truth for class- and ﬁeld-immutability analyses.
We introduced CiFi, a set of modular analyses for each of
the immutability ﬂavors of our model. We used CiFi-Bench to
showcase CiFi’s precision and recall, then used CiFi to study
the prevalence of immutability in real-world libraries.
In future work, we plan to investigate possibilities to
increase CiFi’s precision further without degrading its runtimeperformance disproportionately. This may include the ability to
precisely ﬁnd more lazy initialization patterns and additional
support for generic type parameters, e.g., regarding theirinstantiation or their statically provided bounds. It is also
possible to extend CiFi with further modular analyses, e.g., for
object or reference immutability.
ACKNOWLEDGMENTS
This research work has been funded by the German Federal
Ministry of Education and Research and the Hessian Ministry
of Higher Education, Research, Science and the Arts within
their joint support of the National Research Center for Applied
Cybersecurity A THENE and by the German Research Foun-
dation (DFG) as part of Collaborative Research Centre 1119
CROSSING.REFERENCES
[1] A. Potanin, J. ¨Ostlund, Y . Zibin, and M. D. Ernst, “Immutability,” in
Aliasing in Object-Oriented Programming. Berlin, Heidelberg: Springer-
V erlag, 2013, pp. 233–269.
[2] C. S. Gordon, M. Parkinson, J. Parsons, A. Bromﬁeld, and J. Duffy,
“Uniqueness and Reference Immutability for Safe Parallelism,” Microsoft
Research, Tech. Rep. MSR-TR-2012-79, October 2012.
[3] P . Helland, “Immutability changes everything,” Communications of the
ACM , vol. 59, no. 1, pp. 64–70, 2015.
[4] C. Haack, E. Poll, and A. Schubert, “Immutable objects in Java,” in
Programming Languages and Systems, ser. ESOP’07. Springer Berlin
Heidelberg, 2007, pp. 347–362.
[5] Oracle. (2020, Sep.) Secure Coding Guidelines for Java SE. Oracle.
https://www.oracle.com/java/technologies/javase/seccodeguide.html.
[6] Oracle. (2021) Map (Java SE 16 & JDK 16). https://docs.oracle.com/en/
java/javase/16/docs/api/java.base/java/util/Map.html. Oracle.
[7] D. Helm, F. K ¨ubler, M. Eichberg, M. Reif, and M. Mezini, “A Uniﬁed
Lattice Model and Framework for Purity Analyses,” in Proceedings of
the 33rd ACM/IEEE International Conference on Automated Software
Engineering, ser. ASE’18. New Y ork, NY , USA: ACM, 2018, pp.
340–350.
[8] W . Huang, A. Milanova, W . Dietl, and M. D. Ernst, “Reim & ReImInfer:
Checking and Inference of Reference Immutability and Method Purity,”
inProceedings of the ACM International Conference on Object Oriented
Programming Systems Languages and Applications, ser. OOPSLA ’12.
New Y ork, NY , USA: ACM, 2012, pp. 879–896.
[9] M. S. Tschantz and M. D. Ernst, “Javari: Adding reference immutability
to Java,” in Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2005), San Diego, CA, USA, October 18–20,
2005, pp. 211–230.
[10] J. Quinonez, M. S. Tschantz, and M. D. Ernst, “Inference of reference
immutability,” in ECOOP 2008 — Object-Oriented Programming, 22nd
European Conference, ser. ECOOP’08, Paphos, Cyprus, Jul. 2008, pp.
616–641.
[11] Y . Zibin, A. Potanin, M. Ali, S. Artzi, A. Kie—un, and M. D. Ernst,
“Object and Reference Immutability Using Java Generics,” in Proceedings
of the the 6th Joint Meeting of the European Software Engineering
Conference and the ACM SIGSOFT Symposium on The F oundations of
Software Engineering, ser. ESEC-FSE’07. New Y ork, NY , USA: ACM,
2007, pp. 75–84.
[12] J. T. Boyland, J. Noble, and W . Retert, “Capabilities for Sharing: A
Generalisation of Uniqueness and Read-Only,” in ECOOP, 2001.
[13] M. Coblenz, J. Sunshine, J. Aldrich, B. Myers, S. Weber, and F. Shull,
“Exploring language support for immutability,” in 2016 IEEE/ACM 38th
International Conference on Software Engineering (ICSE), 2016, pp.
736–747.
[14] M. Coblenz, W. Nelson, J. Aldrich, B. Myers, and J. Sunshine,
“Glacier: Transitive class immutability for Java,” in 2017 IEEE/ACM 39th
International Conference on Software Engineering (ICSE). IEEE, 2017,
pp. 496–506.
[15] S. Porat, M. Biberstein, L. Koved, and B. Mendelson, “Automatic
detection of immutable ﬁelds in Java.” in CASCON, 2000, p. 10.
[16] S. Nelson, D. J. Pearce, and J. Noble, “Proﬁling ﬁeld initialisation in
Java,” in International Conference on Runtime V eriﬁcation. Springer,
2012, pp. 292–307.
[17] F. B. Kjolstad, D. Dig, G. Acevedo, and M. Snir, “Refactoring for
immutability,” University of Illinois, Tech. Rep., 2010.
[18] D. Helm, F. K ¨ubler, M. Reif, M. Eichberg, and M. Mezini, “Modular
collaborative program analysis in OPAL,” in Proceedings of the 28th
ACM Joint Meeting on European Software Engineering Conference
and Symposium on the F oundations of Software Engineering ,s e r .
ESEC/FSE’20, 2020, pp. 184–196.
[19] G. Bierman. (2021, Mar) JEP 395: Records. Oracle.
https://openjdk.java.net/jeps/395.
[20] M. Reif, M. Eichberg, B. Hermann, J. Lerch, and M. Mezini, “Call
graph construction for Java libraries,” in Proceedings of the 2016 24th
ACM SIGSOFT International Symposium on F oundations of Software
Engineering, ser. ISST A ’16, 2016, pp. 474–486.
[21] M. Eichberg, F. K ¨ubler, D. Helm, M. Reif, G. Salvaneschi, and M. Mezini,
“Lattice Based Modularization of Static Analyses,” in Companion
Proceedings for the ISSTA/ECOOP 2018 Workshops , ser. ISST A ’18.
New Y ork, NY , USA: ACM, 2018, pp. 113–118.
989[22] B. Livshits, M. Sridharan, Y . Smaragdakis, O. Lhot ´ak, J. N. Amaral, B.-
Y . E. Chang, S. Z. Guyer, U. P . Khedker, A. Møller, and D. V ardoulakis,
“In defense of soundiness: A manifesto,” Communications of the ACM,
vol. 58, no. 2, pp. 44–46, 2015.
[23] A. Prokopec, D. Petrashko, M. Garcia, J. Zaugg, H. Plociniczak, V . Klang,
and M. Odersky. (2021, Apr) SIP-20 - Improved Lazy V als Initialization.
https://docs.scala-lang.org/sips/improved-lazy-val-initialization.html.
[24] Y . Zibin, A. Potanin, P . Li, M. Ali, and M. D. Ernst, “Ownership and
Immutability in Generic Java,” SIGPLAN Not., vol. 45, no. 10, pp. 598–
617, Oct. 2010.
[25] K. R. M. Leino, P . M ¨uller, and A. Wallenburg, “Flexible immutability with
frozen objects,” in Working Conference on V eriﬁed Software: Theories,
Tools, and Experiments. Springer, 2008, pp. 192–208.
[26] A. Birka and M. D. Ernst, “A practical type system and language forreference immutability,” ACM SIGPLAN Notices, vol. 39, no. 10, pp.
35–49, 2004.
[27] W . Dietl and P . M ¨uller, “Universes: Lightweight Ownership for JML.”
Journal of Object Technology, vol. 4, no. 8, pp. 5–32, 2005.
[28] G. Kniesel and D. Theisen, “JAC—access right based encapsulation for
Java,” Software: Practice and Experience, vol. 31, no. 6, pp. 555–576,
2001.
[29] A. Milanova and Y . Dong, “Inference and Checking of Object Immutabil-
ity,” in Proceedings of the 13th International Conference on Principles
and Practices of Programming on the Java Platform: Virtual Machines,
Languages, and Tools, ser. PPPJ’16. New Y ork, NY , USA: ACM, 2016,
pp. 6:1–6:12.
[30] J. Boyland, “Why we should not add readonly to Java (yet).” Journal of
Object Technology, vol. 5, no. 5, pp. 5–29, 2006.
990