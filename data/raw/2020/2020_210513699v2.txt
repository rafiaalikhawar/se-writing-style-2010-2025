Accelerating JavaScript Static Analysis via Dynamic Shortcuts
(Extended Version)
Joonyoung Parkâˆ—
Korea Advanced Institute of Science and Technology
Daejeon, South Korea
gmb55@kaist.ac.krJihyeok Parkâˆ—
Korea Advanced Institute of Science and Technology
Daejeon, South Korea
jhpark0223@kaist.ac.kr
Dongjun Youn
Korea Advanced Institute of Science and Technology
Daejeon, South Korea
f52985@kaist.ac.krSukyoung Ryu
Korea Advanced Institute of Science and Technology
Daejeon, South Korea
sryu.cs@kaist.ac.kr
ABSTRACT
JavaScript has become one of the most widely used programming
languages for web development, server-side programming, and
even micro-controllers for IoT. However, its extremely functional
and dynamic features degrade the performance and precision of
static analysis. Moreover, the variety of built-in functions and host
environments requires excessive manual modeling of their behav-
iors. To alleviate these problems, researchers have proposed various
ways to leverage dynamic analysis during JavaScript static analysis.
However, they do not fully utilize the high performance of dynamic
analysis and often sacrifice the soundness of static analysis.
In this paper, we present dynamic shortcuts , a new technique
to flexibly switch between abstract and concrete execution dur-
ing JavaScript static analysis in a sound way. It can significantly
improve the analysis performance and precision by using highly-
optimized commercial JavaScript engines and lessen the modeling
efforts for opaque code. We actualize the technique via SAFE DS, an
extended combination of SAFE and Jalangi, a static analyzer and a
dynamic analyzer, respectively. We evaluated SAFE DSusing 269 of-
ficial tests of Lodash 4 library. Our experiment shows that SAFE DS
is 7.81 xfaster than the baseline static analyzer, and it improves the
precision to reduce failed assertions by 12.31% on average for 22
opaque functions.
CCS CONCEPTS
â€¢Software and its engineering â†’Software testing and de-
bugging .
KEYWORDS
JavaScript, static analysis, dynamic analysis, dynamic shortcut,
sealed execution
âˆ—Both authors contributed equally to the paper.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Â©2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8562-6/21/08. . . $15.00
https://doi.org/10.1145/3468264.3468556ACM Reference Format:
Joonyoung Park, Jihyeok Park, Dongjun Youn, and Sukyoung Ryu. 2021.
Accelerating JavaScript Static Analysis via Dynamic Shortcuts (Extended
Version). In Proceedings of the 29th ACM Joint European Software Engineer-
ing Conference and Symposium on the Foundations of Software Engineering
(ESEC/FSE â€™21), August 23â€“28, 2021, Athens, Greece. ACM, New York, NY,
USA, 16 pages. https://doi.org/10.1145/3468264.3468556
1 INTRODUCTION
Over the past decades, the rise of JavaScript as the de facto lan-
guage for web development has expanded its reach to diverse
fields. Node.js [ 5] supports server-side programming, React Na-
tive [ 6] and Electron [ 1] produce cross-platform applications, and
Moddable [ 4] and Espruino [ 2] provide JavaScript environments in
micro-controllers for IoT. Such wide prevalent uses place JavaScript
at #7 programming language in the TIOBE Programming Commu-
nity index1. Thus, researchers have developed static analyzers such
as JSAI [ 20], TAJS [ 19], WALA [ 40], and SAFE [ 25,36] to under-
stand behaviors of JavaScript programs and to detect their bugs in
a sound manner.
However, static analysis of real-world JavaScript programs suf-
fers from immensely functional and dynamic features of JavaScript
such as callback functions, first-class property names, and dynamic
code generation. While they provide flexibility in software devel-
opment, it is challenging to statically analyze such features. To
overcome these problems, researchers have proposed several anal-
ysis techniques: advanced string domains [ 10,26,29], loop sensi-
tivity [ 30,31], analysis based on property relations [ 23,24,28,40],
and on-demand backward analysis [41].
At the same time, JavaScript host environments require excessive
manual modeling of their behaviors for static analysis. Because
built-in functions and host-dependent functions are implemented
in native languages like C and C++ instead of JavaScript, their code
isopaque during static analysis. Thus, static analyzers often model
their behaviors manually, which is error-prone, tedious, and labor-
intensive. While researchers have proposed automatic modeling
techniques [ 11,32], since they utilize only type information, they
generate imprecise models compared with the manual approach.
To alleviate these problems, researchers have leveraged dynamic
analysis during static analysis. Unlike static analyzers that run on
their own interpreters, dynamic analyzers such as Jalangi [ 39] and
1https://www.tiobe.com/tiobe-index/arXiv:2105.13699v2  [cs.SE]  1 Jun 2021ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Park and Park, et al.
Figure 1: Performance of a dynamic analyzer and a static an-
alyzer for a subset of the SunSpider benchmark
DLint [ 17] run on highly-optimized commercial JavaScript engines,
which makes them much faster than static analyzers. Figure 1 shows
that the dynamic analyzer Jalangi is 34.8x faster than the static
analyzer SAFE for a subset of the SunSpider [ 8] benchmark that
is input-independent and deterministic. Using high performance
dynamic analysis, researchers have reduced the scope of static
analysis [ 38,43] and constructed initial abstract states [ 34,37] and
automatic modeling of opaque code [33].
Unfortunately, existing techniques using dynamic analysis for
static analysis have two limitations: 1) they do not fully utilize
the high performance of dynamic analysis, and 2) they sacrifice
the soundness of static analysis. Most of them are staged analyses ,
which first extract specific information via dynamic analysis and
utilize it in static analysis. SchÃ¤fer et al . [38] identify determinate
expressions that always have the same values at given program
points, Wei and Ryder [43] extract dynamic values to change ex-
pressions to certain literals, and Park et al. [ 34,37] dump the initial
states of a certain host environment or the entry of an event handler.
However, because they do not utilize dynamic analysis as soon as
static analysis begins, they do not get performance benefits since
then. Moreover, they sacrifice the soundness of static analysis by
performing dynamic analysis. For example, the SRA model [ 33] uses
dynamic analysis for opaque code with abstract arguments during
static analysis. When the abstract arguments represent an infinite
number of values, it randomly samples finite concrete values for
the abstract arguments, which makes the analysis result unsound
due to missing concrete values.
In this paper, we present dynamic shortcuts , a new technique
to flexibly switch between abstract and concrete execution during
JavaScript static analysis in a sound way. During static analysis,
one can take a dynamic shortcut, which consists of three parts: 1)
converting the current abstract state to its corresponding sealed
state, 2) performing sealed execution on the sealed state, and 3)
converting the result of the sealed execution to its corresponding
abstract state. Our key observation is that we can use the fast
concrete execution for specific program parts while preserving the
soundness if they do not use abstract values. For example, consider
static analysis of the following JavaScript code:
var v = ... // an abstract value
var obj = { p1: v }, y = "p";
x = obj [y + 1];
Because ystores a string "p", the expression y + 1 evaluates to a
string "p1"and x = obj[y + 1] assigns the abstract value of vstoredinobj.p1 to the variable x. Note that even though objcontains an
abstract value v, because the third line does not â€œuseâ€ the value of
vbut only â€œpassesâ€ it to the variable x, we can concretely execute
the code. Based on this observation, we introduce sealed execution,
which is concrete execution using sealed values . A sealed value is
a symbol that represents an abstract value in sealed execution; it
signals the end of the current dynamic shortcut when the sealed
execution tries to access its value. To evaluate our technique, we
implemented SAFE DSusing SAFE and Jalangi and analyzed 269
official tests of Lodash 4 library.
The contributions of this paper include the following:
â€¢We present a novel technique for JavaScript static analysis
to leverage the high performance of dynamic analysis using
dynamic shortcuts. We formally define the technique and
prove its soundness and termination.
â€¢We actualize the proposed technique in SAFE DS, an extended
combination of SAFE and Jalangi.
â€¢For empirical evaluation, we analyzed 269 official tests of
Lodash 4 library. The experiment shows that SAFE DSoutper-
forms SAFE 7.81 xon average. Moreover, by using dynamic
shortcuts instead of manual modeling for 22 opaque func-
tions, SAFE DSimproves the analysis precision to reduce
failed assertions by 12.31% on average.
In the remainder of this paper, Section 2 explains the motiva-
tion of this work with a simple example. Section 3 formalizes the
language-agnostic part of the technique in the abstract interpreta-
tion framework. Then, we extend the formalization with JavaScript
specific features in Section 4. Section 5 describes important details
of the SAFE DSimplementation. We explain the evaluation results
ofSAFE DSwith real-world benchmarks in Section 6. Section 7
discusses related work and Section 8 concludes.
2 MOTIVATION
This section explains the motivation of dynamic shortcuts using
real-world examples in Figure 2. We describe their behaviors and
explain how we can utilize dynamic shortcuts during static analysis.
Figure 2(a) shows the concat function defined in Lodash library [ 3]
(v4.17.20); it is the most popular npm package2and 131,517 npm
packages have a dependency on it. The concat function creates a
new array concatenating given arrays or values. It first checks the
length of arguments on lines 1â€“3. Then, it stores the first argument
toarray on line 4 and copies the remaining arguments to argson
lines 5â€“8. On line 9, it checks whether array is an array object using
the built-in function isArray . If so, it creates a new array by copying
the given array via copyArray ; otherwise, it creates a singleton array
[array] . Finally, it flattens argsvia baseFlatten and pushes the result
to the new array on line 11.
Figure 2(b) and Figure 2(c) show use cases of the concat function in
thezoom.us [9] site. It is the homepage of Zoom, a videotelephony
software by Zoom Video Communications and it is ranked as the
15th popular web site according to Alexa3in February 2021.
Dynamic shortcuts with concrete values. When a function is called
with concrete values, we can perform dynamic analysis instead of
2https://www.npmjs.com/browse/depended
3https://www.alexa.com/siteinfo/zoom.usAccelerating JavaScript Static Analysis via Dynamic Shortcuts (Extended Version) ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
1 function concat () {
2 var length = arguments . length ;
3 if(! length ) return [];
4 var array = arguments [0] ,
5 args = Array ( length - 1) ,
6 index = length ;
7 while (index --)
8 args [index -1] = arguments [ index ];
9 return arrayPush ( isArray ( array ) ?
10 copyArray ( array ) : [ array ],
11 baseFlatten (args , 1));
12 }
(a) Lodashâ€™s concat function
13 function changeCountry (G) { ...
14 if(G. selectedVal === "US" && state ) {
15 // deterministic arguments of `concat `
16 state . items = _. concat ([[ " Other ", " Other "]],
17 WebinarBase . questions . state . items );
18 state . selectedVal = _. head (_. head (C. items ));
19 }
20 }
(b) Call of concat with concrete values
22 function getData (e) {
23 var option = ... // option for server connection
24 post ( option ). then ( function (e) {
25 if(e. total_records && e. total_records > 0) {
26 // non - deterministic arguments of `concat `
27 this . pastEvents =
28 _. concat ( this . pastEvents , e. events );
29 this . total = e. total_records ;
30 }else this . noPastData = !0
31 })
32 }
(c) Call of concat with abstract values
Figure 2: Lodash library function and its uses in zoom.us
static analysis. For example, changeCountry in Figure 2(b) is invoked
when a user selects a country from a drop-down list in the regis-
tration page. It calls the concat function to update the drop-down
list of states or provinces on lines 16â€“17. However, when the user
selects â€œUnited States of America,â€ which is "US", two arguments
are pre-defined with deterministic values; the first one is an array
literal [["Other", "Other"]] and the second one is an array of pairs
of abbreviations and names of the states defined as follows:
WebinarBase . questions . state . items =
[["AL"," Alabama "], ... , ["WY", " Wyoming "]]
Moreover, thisalso has a concrete value, the Lodash top-level ob-
ject _. Thus, we can perform dynamic analysis by invoking concat
with _as its thisvalue and the above concrete values as arguments.
By skipping the analysis of the function call on lines 17â€“18 and
utilizing the result of dynamic analysis, it improved the analysis
performance.
Dynamic shortcuts with abstract values. Even when a function is
called with abstract values, we can still perform dynamic analysis
using sealed execution. For example, getData in Figure 2(c) is invoked
when a user clicks the â€œLoad Moreâ€ button to load more Zoom events
in the â€œWebinars & Eventsâ€ page. It sends a POST request to a serverProperty Value
âŠ¤ğœ”evt
"length"ğœ”int
(a)this.pastEventsProperty Value
0ğœ”evt
Â·Â·Â·Â·Â·Â·
7ğœ”evt
"length" 8
(b)e.events
Figure 3: Concrete objects with sealed values
and receives additional events eon line 24. Then, eight events in
e.events are appended to this .pastEvents using concat on lines 27â€“28.
However, the arguments of concat are not deterministic because 1)
the event list stored in this .pastEvents is continuously grown for
each load and 2) the events stored in e.events are dependent on the
data given from the server.
To perform dynamic analysis with abstract values, we seal ab-
stract values with sealed values as in Figure 3. Two sealed values
ğœ”evtandğœ”intrepresent an event object and an integer, respectively.
Then, we can perform dynamic analysis successfully until line 9. On
line 2, length is2; on line 4, array points to this .pastEvents ; on lines
5â€“8, argsstores an array with a single object stored in e.events ; and
on line 9, isArray(array) istrue. However, dynamic analysis fails for
copyArray(array) on line 10 because the value of the length property
ofarray is the sealed value ğœ”int. Then, we stop the sealed execu-
tion, convert the current sealed state to its corresponding abstract
state, and resume the static analysis from line 10. Because sealed
execution leverages fast dynamic analysis as long as possible, the
overall analysis becomes more scalable.
Dynamic shortcuts for opaque functions. As the previous two
examples additionally show, using dynamic shortcuts lessens the
burden of modeling opaque functions from static analysis, and it
can even improve the analysis precision. On line 9, since the isArray
function is a JavaScript built-in library function, it is implemented
in a native language of the host environment, which often requires
manual modeling of its behaviors for JavaScript static analysis.
Assuming that a static analyzer models isArray to return the boolean
top valueâŠ¤ğ‘that encompasses both trueand false , static analysis
of the ternary conditional expression on lines 9â€“10 analyzes both
branches copyArray(array) and [array] , even though [array] is never
reachable in the example code. On the contrary, using dynamic
shortcuts, static analysis does not need to model isArray . It can
perform sealed execution for isArray , which returns a more precise
result truethanâŠ¤ğ‘.
3 DYNAMIC SHORTCUTS
In this section, we formally define static analysis using dynamic
shortcuts by introducing sealed execution in the abstract interpre-
tation framework. We extend the formalization of abstract inter-
pretation of Cousot and Cousot [13,14]and views-based analysis
sensitivity of Kim et al . [21] . For dynamic shortcuts, we define sealed
execution with a sealed domain and abstract instantiation maps. To
combine sensitive abstract interpretation and sealed execution, we
define a combined domain of sensitive abstract domain and sealed
domain and explain it with a simple example. Finally, we proveESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Park and Park, et al.
â€¢l0if(xâ‰¥0)â€¢ l1x=x;
elseâ€¢l2x=âˆ’x;
â€¢l3x=âˆ’x;â€¢l4
Figure 4: Negation of the absolute value of x
the soundness and termination property of abstract interpretation
using the combined domain.
3.1 Concrete Semantics
We define a program ğ‘ƒas a state transition system (S,{,Sğœ„). A
program starts with an initial state in Sğœ„and the transition relation
{âŠ†SÃ—Sdescribes how states are transformed to other states. A
collecting semantics Jğ‘ƒK={ğœâˆˆS|ğœğœ„âˆˆSğœ„âˆ§ğœğœ„{âˆ—ğœ}consists
of reachable states from initial states of the program ğ‘ƒ. We can
compute it using a transfer function ğ¹:Dâ†’Das follows:
Jğ‘ƒK=limğ‘›â†’âˆğ¹ğ‘›(ğ‘‘ğœ„)ğ¹(ğ‘‘)=ğ‘‘âŠ”step(ğ‘‘)
where the concrete domain D=P(S)is a complete lattice with âˆª,
âˆ©, andâŠ†as its join(âŠ”), meet(âŠ“), and partial order( âŠ‘) operators. The
set of states ğ‘‘ğœ„denotes the initial states Sğœ„. The one-step execution
step :Dâ†’Dtransforms states using the transition relation {:
step(ğ‘‘)={ğœâ€²|ğœâˆˆğ‘‘âˆ§ğœ{ğœâ€²}.
For example, the code in Figure 4 is a simple program that calcu-
lates the negation of the absolute value of the variable x. States are
pairs of labels and integers stored in x:S=LÃ—N. Assume that the
initial states are Sğœ„={(l0,âˆ’42)}, which denotes that the program
starts at l0with the variable xof valueâˆ’42. Then, it executes with
the following trace:
(l0,âˆ’42){(l2,âˆ’42){(l3,42){(l4,âˆ’42)
3.2 Abstract Interpretation
Abstract interpretation [ 13,14] over-approximates the transfer func-
tionğ¹as an abstract transfer function ğ¹#:D#â†’D#to get an
abstract semantics Jğ‘ƒK#in finite iterations as follows:
Jğ‘ƒK#=limğ‘›â†’âˆ(ğ¹#)ğ‘›(ğ‘‘#
ğœ„)
We define a state abstraction Dâˆ’âˆ’âˆ’â†’â†âˆ’âˆ’âˆ’
ğ›¼ğ›¾
D#as a Galois connection
between the concrete domain Dand an abstract domain D#with a
concretization function ğ›¾and an abstraction function ğ›¼. The initial
abstract state ğ‘‘#ğœ„âˆˆD#represents an abstraction of the initial state
set:ğ‘‘ğœ„âŠ†ğ›¾(ğ‘‘#ğœ„). The abstract transfer function ğ¹#:D#â†’D#
is defined as ğ¹#(ğ‘‘#)=ğ‘‘#âŠ”step#(ğ‘‘#)with an abstract one-step
execution step#:D#â†’D#. For a sound state abstraction, the join
operator and the abstract one-step execution should satisfy the
following conditions:
âˆ€ğ‘‘#
0,ğ‘‘#
1âˆˆD#.ğ›¾(ğ‘‘#
0)âˆªğ›¾(ğ‘‘#
1)âŠ†ğ›¾(ğ‘‘#
0âŠ”ğ‘‘#
1) (1)
âˆ€ğ‘‘#âˆˆD#.stepâ—¦ğ›¾(ğ‘‘#)âŠ†ğ›¾â—¦step#(ğ‘‘#) (2)
A simple example abstract domain is D#Â±=P({âˆ’,+,0})with
set operators as domain operators; âˆ’denotes negative integers,
+positive integers, and 0zero. Assume that we analyze the code
in Figure 4 with the abstract domain and the initial abstract state
ğ‘‘#ğœ„={âˆ’}. Then, the analysis result is {âˆ’,+}because xcan havea positive value by executing x=âˆ’xbut there is no way for xto
have 0in this program.
3.3 Analysis Sensitivity
Abstract interpretation is often defined with analysis sensitivity to
increase the precision of static analysis. A sensitive abstract domain
D#
ğ›¿:Î â†’D#is defined with a view abstraction ğ›¿:Î â†’Dthat
provides multiple points of views for reachable states during static
analysis. It maps a finite number of views Î to sets of states D. Each
viewğœ‹âˆˆÎ represents a set of states ğ›¿(ğœ‹)and each state is included
in a unique view:âˆ€ğœâˆˆS.ğœâˆˆğ›¿(ğœ‹)â‡’âˆ€ğœ‹â€²âˆˆÎ .ğœâˆˆğ›¿(ğœ‹â€²)â‡’ğœ‹=
ğœ‹â€². Asensitive state abstraction Dâˆ’âˆ’âˆ’âˆ’â†’â†âˆ’âˆ’âˆ’âˆ’
ğ›¼ğ›¿ğ›¾ğ›¿D#
ğ›¿is a Galois connection
between the concrete domain Dand the sensitive abstract domain
D#
ğ›¿with the following concretization function:
ğ›¾ğ›¿(ğ‘‘#
ğ›¿)=Ã˜
ğœ‹âˆˆÎ ğ›¿(ğœ‹)âˆ©ğ›¾â—¦ğ‘‘#
ğ›¿(ğœ‹)
With analysis sensitivities, the abstract one-step execution step#
ğ›¿:
D#
ğ›¿â†’D#
ğ›¿is defined as follows:
step#
ğ›¿(ğ‘‘#
ğ›¿)=ğœ†ğœ‹âˆˆÎ .Ã„
ğœ‹â€²âˆˆÎ Jğœ‹â€²â†’ğœ‹K#â—¦ğ‘‘#
ğ›¿(ğœ‹â€²)
where Jğœ‹â€²â†’ğœ‹K#:D#â†’D#is an abstract semantics of a view
transition from a view ğœ‹â€²to another view ğœ‹. It should satisfy the
following condition for the soundness of the analysis:
âˆ€ğ‘‘#âˆˆD#.step(ğ›¾(ğ‘‘#)âˆ©ğ›¿(ğœ‹â€²))âˆ©ğ›¿(ğœ‹)âŠ†ğ›¾â—¦Jğœ‹â€²â†’ğœ‹K#(ğ‘‘#)
One of the most widely-used analysis sensitivity is flow sensi-
tivity defined with a flow-sensitive view abstraction ğ›¿FS:Lâ†’D
where:
âˆ€lâˆˆL.ğ›¿FS(l)={ğœ|ğœ=(l,_)}
If we apply the flow sensitivity for the above example with the initial
abstract state[l0â†¦â†’{âˆ’,0,+}], the analysis result is as follows:
L l0 l1 l2 l3 l4
D#Â±âˆ’,0,+0,+âˆ’0,+âˆ’,0
3.4 Sealed Execution
We define sealed execution by extending the transition relation
{as a sealed transition relation {ğœ”on sealed states. First, we
extend concrete states Sto sealed states Sğœ”by extending values V
with sealed values Î©. We also define the sealed transition relation
{ğœ”âŠ†Sğœ”Ã—Sğœ”. We use the notation {ğ‘˜ğœ”forğ‘˜repetition of {ğœ”,
and writeğœğœ”{ğœ”âŠ¥whenğœğœ”does not have any sealed transitions
to other sealed states. We define the validity of sealed execution as
follows:
Definition 3.1 (Validity). The sealed transition relation is valid
when the following condition is satisfied for any sealed states ğœğœ”
andğœâ€²ğœ”:
ğœğœ”{ğœ”ğœâ€²
ğœ”â‡”âˆ€ğ‘šâˆˆM.{ğœâ€²|ğœğœ”|ğ‘š{ğœâ€²}={ğœâ€²
ğœ”|ğ‘š}
where M:Î©â†’Vrepresent instantiation maps from sealed values
to concrete values, and ğœğœ”|ğ‘šdenotes a state produced by replacing
each sealed value ğœ”inğœğœ”with its corresponding value ğ‘š(ğœ”)using
the instantiation map ğ‘šâˆˆM.Accelerating JavaScript Static Analysis via Dynamic Shortcuts (Extended Version) ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Sealed execution is different from traditional symbolic execu-
tion [ 22] in that it supports only sealed values instead of symbolic
expressions and path constraints. For example, the following trace
represents traditional symbolic execution of the running example
in Figure 4:
(l1,ğœ”)[ğœ”â‰¥0]{(l3, ğœ”)[ğœ”â‰¥0]{(l4,âˆ’ğœ”)[ğœ”â‰¥0]
{(l0,ğœ”)[âˆ…]{
(l2,ğœ”)[ğœ”<0]{(l3,âˆ’ğœ”)[ğœ”<0]{(l4, ğœ”)[ğœ”<0]
It first assigns a symbolic value ğœ”to the variable xat l0. For the
conditional branch, it creates two symbolic states with different
path conditions ğœ”â‰¥0andğœ”<0for true and false branches,
respectively. After executing statements x=xandx=âˆ’x, the
variable xstores symbolic expressions ğœ”andâˆ’ğœ”at l3, respectively.
Similarly, xstoresâˆ’ğœ”andğœ”at l4. However, sealed execution stops
at l0as follows:
(l0,ğœ”){ğœ”âŠ¥
because the branch requires the actual value of the sealed value ğœ”.
To define an abstract domain that contains sealed states, we
define abstract instantiation maps M#:Î©â†’V#from sealed values
to abstract values. Its concretization function ğ›¾ğ‘š:M#â†’P( M)
is defined with the concretization function ğ›¾ğ‘£:V#â†’P( V)for
values as follows:
ğ›¾ğ‘š(ğ‘š#)={ğ‘š|âˆ€ğœ”âˆˆÎ©.ğ‘š(ğœ”)âˆˆğ›¾â—¦ğ‘š#(ğœ”)}
The instantiation of a given sealed state ğœğœ”âˆˆSğœ”with an abstract
instantiation map ğ‘š#âˆˆM#is defined as follows:
ğœğœ”|ğ‘š#={ğœğœ”|ğ‘š|ğ‘šâˆˆğ›¾ğ‘š(ğ‘š#)}
Now, we define a sealed domain as follows:
Definition 3.2 (Sealed Domain). Asealed domain Dğœ”:P(M#Ã—
Sğœ”)is defined with the concretization function ğ›¾ğœ”:Dğœ”â†’Dand
the sealed one-step execution stepğœ”:Dğœ”â†’Dğœ”such that
ğ›¾ğœ”(ğ‘‘ğœ”)=Ã˜
{ğœğœ”|ğ‘š#|(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”} (3)
stepğœ”(ğ‘‘ğœ”)={(ğ‘š#,ğœâ€²
ğœ”)|(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”âˆ§ğœğœ”{ğœ”ğœâ€²
ğœ”} (4)
3.5 Combined Domain
We now define a combined domain of a given sensitive abstract
domain with the sealed domain and its one-step execution.
Definition 3.3 (Combined Domain). Acombined domain iseD=
D#
ğ›¿Ã—Dğœ”and its concretization function eğ›¾:eDâ†’Dand join
operator are defined as follows:
eğ›¾((ğ‘‘#
ğ›¿,ğ‘‘ğœ”))=ğ›¾ğ›¿(ğ‘‘#
ğ›¿)âˆªğ›¾ğœ”(ğ‘‘ğœ”) (5)
(ğ‘‘#
ğ›¿,ğ‘‘ğœ”)âŠ”(ğ‘‘#
ğ›¿â€²,ğ‘‘ğœ”â€²)=(ğ‘‘#
ğ›¿âŠ”ğ‘‘#
ğ›¿â€²,ğ‘‘ğœ”âˆªğ‘‘ğœ”â€²) (6)
Before defining the one-step execution for the combined domain,
we introduce analysis elements to easily configure different types
of abstract states in the sensitive abstract domain and the sealed
domain.
Definition 3.4 (Analysis Elements). Ananalysis element ğœ–âˆˆE=
(Î Ã—D#)âŠ(M#Ã—Sğœ”)is either 1) a pair of a view and an abstract
state in a sensitive abstract domain D#
ğ›¿, or 2) a pair of an abstractinstantiation map and a sealed state in a sealed domain Dğœ”. Its
concretization function ğ›¾ğœ–:Eâ†’Dis defined as follows:
ğ›¾ğœ–(ğœ–)=ğ›¿(ğœ‹)âˆ©ğ›¾(ğ‘‘#)if(ğœ‹,ğ‘‘#)=ğœ–
ğœğœ”|ğ‘š# if(ğ‘š#,ğœğœ”)=ğœ–
Moreover, to freely convert between different kinds of analysis
elements, we define two converters:
ğœğœ”:(Î Ã—D#)â†©â†’(M#Ã—Sğœ”) (7)
ğœ#:(Î Ã—D#)â†(M#Ã—Sğœ”) (8)
While the converter ğœ#is total, the other one ğœğœ”ispartial . Thus,
it is possible to convert an analysis element (ğœ‹,ğ‘‘#)in a sensitive
abstract domain to another analysis element in a sealed domain only
if the convert ğœğœ”is defined:(ğœ‹,ğ‘‘#)âˆˆDom(ğœğœ”). In addition, they
should convert given analysis elements without loss of information
for allğœ–âˆˆE:
ğœğœ”(ğœ–)=ğœ–â€²â‡’ğœ–=ğœ#(ğœ–â€²)
ğ›¾ğœ–(ğœ–)=ğ›¾ğœ–(ğœ–â€²)
Now, we define the combined one-step execution gstep :eDâ†’eD
with two converters ğœğœ”andğœ#. It consists of two steps: 1) the reform
step converts analysis elements if a new sealed execution starts or
an existing one stops, and 2) the execution step performs execution
of each analysis element using the abstract one-step execution step#
ğ›¿
in the sensitive abstract domain and the sealed one-step execution
stepğœ”in the sealed domain.
Definition 3.5 (Combined One-Step Execution). Acombined one-
step execution gstep :eDâ†’eDis define as follows:
gstep(eğ‘‘)=(step#
ğ›¿(ğ‘‘#
ğ›¿),stepğœ”(ğ‘‘ğœ”))
where(ğ‘‘#
ğ›¿,ğ‘‘ğœ”)=reform(eğ‘‘).
From a given combined state eğ‘‘, the reform function makes anal-
ysis elements and converts them if a new sealed execution be-
gins or an existing sealed execution terminates. Specifically, for
an analysis element (ğœ‹,ğ‘‘#)in the sensitive abstract domain, if the
converterğœğœ”is defined for it, reform introduces a new sealed exe-
cution by converting the analysis element to its corresponding one
(ğ‘š#,ğœğœ”)=ğœğœ”((ğœ‹,ğ‘‘#))in the sealed domain. On the other hand,
for an analysis element (ğ‘š#,ğœğœ”)in the sealed domain, if it does
not have any sealed states to transit to, ğœğœ”{ğœ”âŠ¥, the sealed execu-
tion for(ğ‘š#,ğœğœ”)terminates. It converts the analysis element to its
corresponding one (ğœ‹,ğ‘‘#)=ğœ#((ğ‘š#,ğœğœ”))in the sensitive abstract
domain and merges the current abstract state stored in ğœ‹withğ‘‘#.
To formally define the reform function, we first define a reformğœ–
function for analysis elements using two converters.
Definition 3.6 ( reformğœ–).The function reformğœ–:Eâ†’Efor
analysis elements is defined as follows:
reformğœ–(ğœ–)=ï£±ï£´ï£´ ï£²
ï£´ï£´ï£³ğœğœ”(ğœ–)ifğœ–=(ğœ‹,ğ‘‘#)âˆ§ğœ–âˆˆDom(ğœğœ”)
ğœ#(ğœ–)ifğœ–=(ğ‘š#,ğœğœ”)âˆ§ğœğœ”{ğœ”âŠ¥
ğœ– Otherwise
Definition 3.7 ( reform ).The reform function reform :eDâ†’eDfor
combined states is defined as follows:
reform((ğ‘‘#
ğ›¿,ğ‘‘ğœ”))=
ğœ†ğœ‹.Ã„
{ğ‘‘#|(ğœ‹,ğ‘‘#)âˆˆğ¸},ğ¸âˆ©(M#Ã—Sğœ”)ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Park and Park, et al.
(a) Notations
 (b)x=0
 (c)x>0
 (d)xâˆˆN
Figure 5: Abstract interpretation using a combined domain for the running example with different initial values for x.
where
ğ¸=Â¤reformğœ–({(ğœ‹,ğ‘‘#
ğ›¿(ğœ‹))|ğœ‹âˆˆÎ }âˆªğ‘‘ğœ”)
and the dot notation Â¤ğ‘“denotes the element-wise extended function
of a function ğ‘“.
3.6 Examples
Now, we show examples of abstract interpretation with a combined
domain. Figure 5 depicts the flow of analysis for the running ex-
ample in Figure 4 with three different initial sets of values for the
variable x. In this example, we use the abstract domain {âˆ’,0,+}for
integers stored in xas introduced in Section 3.2, and the flow sensi-
tivity that utilizes the labels of states as their views as introduced
in Section 3.3. For brevity, we use concatenation of abstract values
so thatâˆ’0denotes the set{âˆ’,0}.
Figure 5(a) presents notations used in each graph. A solid box
denotes an analysis element that is a pair of a label land an abstract
stateğ‘‘#. A pair enclosed by angle brackets denotes an analysis
element that is a pair of an abstract instantiation map ğ‘š#and a
sealed state ğœğœ”. In fact, the sealed state part (right) of each pair in
graphs contains only the value of the variable of xwithout its label.
For brevity, we represent its label by locating it next to a node with
its label. A solid line is a view transition Jlâ†’ lâ€²K#from a label l
to another one lâ€². A dotted line is a sealed transition {ğœ”. Three
solid lines with circled labels denote two converters ğœ#,ğœğœ”and the
join operatorâŠ”.
Figure 5(b) shows the analysis with the combined domain when
the initial value of xis0. First, in the reform step, the converter ğœğœ”
converts the analysis element (l0,0)to another analysis element
âŸ¨âˆ…,0âŸ©with the label l0. It does not introduce any sealed values
because the value represents only a single value. Until the end of the
program, the sealed execution from âŸ¨âˆ…,0âŸ©successfully continues.
Because there is no more possible sealed transition for the sealed
stateâŸ¨âˆ…,0âŸ©with l4, it is converted to(l4,0)via the converter ğœ#.
Instead of a single value, assume that the initial value of xis
one of any positive integers. Figure 5(c) describes the analysis flow
for the case. The initial abstract value at the label l0is+and it
is impossible to convert it to any sealed values because the next
program statement requires the actual value stored in the variable
xfor the branch condition xâ‰¥0. Thus, it performs view transition
Jl0â†’ l1K#from the label l0to another one l1for the abstract value
+and the result is also +. Now, the analysis element (l1,+)can be
converted toâŸ¨ğœ”â†¦â†’+,ğœ”âŸ©with the label l1. This sealed execution stepterminates in the label l3because the next statement is x=âˆ’xand
the negation operator requires the actual value of x. It is converted
to(l3,+)viağœ#, performs the view transition, and results in (l4,âˆ’).
For the last case, we assume that all integers are possible for
the initial value of the variable xas described in Figure 5(d). While
it reaches the false branch in the label l2unlike previous cases, it
cannot perform dynamic shortcuts because the statement in the
false branch is x=âˆ’x, which requires the actual value of x. At the
label l3, there are two analysis elements: 1) (l3,+)introduced by the
view transition from the label l2withâˆ’, and 2)âŸ¨ğœ”â†¦â†’0+,ğœ”âŸ©with l3
introduced by sealed execution started at l1. Since it is not possible
to perform sealed execution for both elements, the second one is
converted to(l3,0+)and merged with+at l3via the join operator
âŠ”. Finally, the view transition Jl3â†’ l4K#from l3to l4is performed
to the merged abstract state 0+and the result isâˆ’0.
3.7 Soundness and Termination
The converter ğœğœ”and the sealed transition {ğœ”are keys to configure
the introduction and termination of sealed execution. To ensure
thesoundness andtermination of an abstract interpretation defined
with a combined domain of a sensitive abstract domain and a sealed
domain, the following conditions should hold.
Theorem 3.8 (Soundness and Termination). An abstract in-
terpretation with dynamic shortcuts is sound andterminates in a
finite time if:
â€¢the abstract transfer function ğ¹#is sound,
â€¢the sensitive abstract domain D#
ğ›¿has a finite height,
â€¢the sealed transition {ğœ”is valid, and
â€¢there existsğ‘<âˆsuch that
âˆ€ğœ–âˆˆE.ğœğœ”(ğœ–)=(ğ‘š#,ğœğœ”)â‡’ğœğœ”{ğ‘˜
ğœ”âŠ¥âˆ§1<ğ‘˜â‰¤ğ‘ (9)
For soundness proof, we should prove two conditions presented
in Section 3.2: (10) for the join operator âŠ”and (2) for the combined
one-step execution. The core idea of the proof is to use Lemma 3.12
and Lemma 3.11 for the sealed one-step execution stepğœ”and the
reform function, respectively. On the other hand, the core idea of
the termination proof is to use the property that the second and the
fourth conditions provide upper bounds of the number of sensitive
abstract states and the number of sealed states, respectively. We
formally define and prove the property using time to live (TTL)
functions of sealed states, TTLğ‘–for each iteration ğ‘–â‰¥0, and prove
the termination using them. Now, we assume that its all conditionsAccelerating JavaScript Static Analysis via Dynamic Shortcuts (Extended Version) ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
in Theorem 3.8 are hold and rephrase the soundness as Theorem 3.9
andtermination as Theorem 3.15.
3.7.1 Soundness.
Theorem 3.9 (Soundness). The abstract interpretation using the
combined domain eDissound if
âˆ€eğ‘‘0,eğ‘‘1âˆˆeD.eğ›¾(eğ‘‘0)âˆªeğ›¾(eğ‘‘1)âŠ†eğ›¾(eğ‘‘0âŠ”eğ‘‘1) (10)
âˆ€eğ‘‘âˆˆeD.stepâ—¦eğ›¾(eğ‘‘)âŠ†eğ›¾â—¦gstep(eğ‘‘) (11)
Proof. First, we prove that the abstract transfer function eğ¹:
eDâ†’eDdefined as eğ¹(eğ‘‘)=eğ‘‘âŠ”gstep(eğ‘‘)is sound
ğ¹â—¦eğ›¾(eğ‘‘)=eğ›¾(eğ‘‘)âˆªstepâ—¦eğ›¾(eğ‘‘)
âŠ†eğ›¾(eğ‘‘)âˆªeğ›¾â—¦gstep(eğ‘‘) (âˆµcondition (11))
âŠ†eğ›¾(eğ‘‘âŠ”gstep(eğ‘‘)) (âˆµcondition (10))
=eğ›¾â—¦eğ¹(eğ‘‘)
Then, the abstract semanticsgJğ‘ƒK=limğ‘›â†’âˆ(eğ¹)ğ‘›(eğ‘‘ğœ„)is also sound
because it is defined with a sound abstract transfer function eğ¹using
the combined one-step execution gstep. â–¡
Now, we should show that two conditions about the soundness of
the join operator (10) and the soundness of the combined one-step
execution (11) in Theorem 3.9 hold.
First, we prove the soundness of the join operator (10) in Lemma 3.10.
Lemma 3.10 (Soundness of âŠ”).
âˆ€eğ‘‘0,eğ‘‘1âˆˆeD.eğ›¾(eğ‘‘0)âˆªeğ›¾(eğ‘‘1)âŠ†eğ›¾(eğ‘‘0âŠ”eğ‘‘1)
Proof.
eğ›¾((ğ‘‘#
ğ›¿,ğ‘‘ğœ”))âˆªeğ›¾((ğ‘‘#
ğ›¿â€²,ğ‘‘ğœ”â€²))
=ğ›¾ğ›¿(ğ‘‘#
ğ›¿)âˆªğ›¾ğœ”(ğ‘‘ğœ”)âˆªğ›¾ğ›¿(ğ‘‘#
ğ›¿â€²)âˆªğ›¾ğœ”(ğ‘‘ğœ”â€²)
=(ğ›¾ğ›¿(ğ‘‘#
ğ›¿)âˆªğ›¾ğ›¿(ğ‘‘#
ğ›¿â€²))âˆª(ğ›¾ğœ”(ğ‘‘ğœ”)âˆªğ›¾ğœ”(ğ‘‘ğœ”â€²))
âŠ†ğ›¾ğ›¿(ğ‘‘#
ğ›¿âŠ”ğ‘‘#
ğ›¿â€²)âˆª(ğ›¾ğœ”(ğ‘‘ğœ”)âˆªğ›¾ğœ”(ğ‘‘ğœ”â€²))
(âˆµD#
ğ›¿is sound)
=ğ›¾ğ›¿(ğ‘‘#
ğ›¿âŠ”ğ‘‘#
ğ›¿â€²)âˆªğ›¾ğœ”(ğ‘‘ğœ”âˆªğ‘‘ğœ”â€²)
=eğ›¾((ğ‘‘#
ğ›¿âŠ”ğ‘‘#
ğ›¿â€²,ğ‘‘ğœ”âˆªğ‘‘ğœ”â€²))
=eğ›¾((ğ‘‘#
ğ›¿,ğ‘‘ğœ”)âŠ”(ğ‘‘#
ğ›¿â€²,ğ‘‘ğœ”â€²))
â–¡
For the condition (11), we first prove two properties of the reform
function in Lemma 3.11. Using the properties, we prove the sound-
ness of the sealed one-step execution in Lemma 3.12. Finally, we
prove the soundness of the combined one-step execution (11) in
Lemma 3.13.
Lemma 3.11 (Properties of reform ).For a given combined state
eğ‘‘âˆˆeD, the reform function satisfies the following two properties:
â€¢eğ›¾(eğ‘‘)âŠ†eğ›¾â—¦reform(eğ‘‘)
â€¢âˆ€(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”.âˆƒğœâ€²ğœ”âˆˆSğœ”.s.t.ğœğœ”{ğœ”ğœâ€²ğœ”
where(ğ‘‘#
ğ›¿,ğ‘‘ğœ”)=reform(eğ‘‘)
Proof.
eğ›¾(eğ‘‘)âŠ†eğ›¾â—¦reform(eğ‘‘)eğ›¾((ğ‘‘#
ğ›¿,ğ‘‘ğœ”))
=ğ›¾ğ›¿(ğ‘‘#
ğ›¿)âˆªğ›¾ğœ”(ğ‘‘ğœ”)
=Ã
ğœ‹âˆˆÎ ğ›¿(ğœ‹)âˆ©ğ›¾â—¦ğ‘‘#
ğ›¿(ğœ‹)
âˆª 
Ã
(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”ğœğœ”|ğ‘š#!
=Ã
ğœ‹âˆˆÎ ğ›¾ğœ–((ğœ‹,ğ‘‘#
ğ›¿(ğœ‹)))
âˆª 
Ã
(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”ğ›¾ğœ–((ğ‘š#,ğœğœ”))!
=Â¤ğ›¾ğœ–({(ğœ‹,ğ‘‘#
ğ›¿(ğœ‹))|ğœ‹âˆˆÎ }âˆªğ‘‘ğœ”)
=Â¤ğ›¾ğœ–(Â¤reformğœ–({(ğœ‹,ğ‘‘#
ğ›¿(ğœ‹))|ğœ‹âˆˆÎ }âˆªğ‘‘ğœ”))
âˆµ(Trivially,âˆ€ğœ–âˆˆE.ğ›¾ğœ–(ğœ–)=ğ›¾ğœ–â—¦reformğœ–(ğœ–))
=Â¤ğ›¾ğœ–(ğ¸)
âˆµ(See the definition of ğ¸in Definition 3.7)
= 
Ã
(ğœ‹,ğ‘‘#)âˆˆğ¸ğ›¾ğœ–((ğœ‹,ğ‘‘#))!
âˆª 
Ã
(ğ‘š#,ğœğœ”)âˆˆğ¸ğ›¾ğœ–((ğ‘š#,ğœğœ”))!
= 
Ã
(ğœ‹,ğ‘‘#)âˆˆğ¸ğ›¿(ğœ‹)âˆ©ğ›¾(ğ‘‘#)!
âˆª 
Ã
(ğ‘š#,ğœğœ”)âˆˆğ¸ğœğœ”|ğ‘š#!
= 
Ã
ğœ‹âˆˆÎ Ã
(ğœ‹,ğ‘‘#)âˆˆğ¸ğ›¿(ğœ‹)âˆ©ğ›¾(ğ‘‘#)!
âˆª 
Ã
(ğ‘š#,ğœğœ”)âˆˆğ¸ğœğœ”|ğ‘š#!
= 
Ã
ğœ‹âˆˆÎ ğ›¿(ğœ‹)âˆ© 
Ã
(ğœ‹,ğ‘‘#)âˆˆğ¸ğ›¾(ğ‘‘#)!!
âˆª 
Ã
(ğ‘š#,ğœğœ”)âˆˆğ¸ğœğœ”|ğ‘š#!
âŠ† 
Ã
ğœ‹âˆˆÎ ğ›¿(ğœ‹)âˆ©ğ›¾ 
Ãƒ
(ğœ‹,ğ‘‘#)âˆˆğ¸ğ‘‘#!!
âˆª 
Ã
(ğ‘š#,ğœğœ”)âˆˆğ¸ğœğœ”|ğ‘š#!
=ğ›¾ğ›¿ 
ğœ†ğœ‹.Ãƒ
(ğœ‹,ğ‘‘#)âˆˆğ¸ğ‘‘#!
âˆªğ›¾ğœ”(ğ¸âˆ©(M#Ã—Sğœ”))
=eğ›¾ 
ğœ†ğœ‹.Ãƒ
(ğœ‹,ğ‘‘#)âˆˆğ¸ğ‘‘#,ğ¸âˆ©(M#Ã—Sğœ”)!
=eğ›¾â—¦reform((ğ‘‘#
ğ›¿,ğ‘‘ğœ”))
âˆ€(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”.âˆƒğœâ€²ğœ”âˆˆSğœ”.s.t.ğœğœ”{ğœ”ğœâ€²ğœ”
For a given(ğ‘š#,ğœğœ”) âˆˆğ‘‘ğœ”, there exists an analysis element
ğœ–âˆˆEsuch that reformğœ–(ğœ–)=(ğ‘š#,ğœğœ”). According to the defini-
tion of reformğœ–in Definition 3.6, there are two possible cases: ğœ–=
(ğ‘š#,ğœğœ”)âˆ§âˆƒğœâ€²ğœ”âˆˆSğœ”.s.tğœğœ”{ğœ”ğœâ€²ğœ”orğœ–=(ğœ‹,ğ‘‘#)âˆ§ğœ–âˆˆDom(ğœğœ”).
We separately consider those two cases:
â€¢ğœ–=(ğ‘š#,ğœğœ”)âˆ§âˆƒğœâ€²ğœ”âˆˆSğœ”.s.tğœğœ”{ğœ”ğœâ€²ğœ”
By definition,âˆƒğœâ€²ğœ”âˆˆSğœ”.s.tğœğœ”{ğœ”ğœâ€²ğœ”
â€¢ğœ–=(ğœ‹,ğ‘‘#)âˆ§ğœ–âˆˆDom(ğœğœ”)
By the condition 9 in the Theorem 3.8,
âˆƒğ‘˜>1.ğœğœ”{ğ‘˜ğœ”âŠ¥. Thus,âˆƒğœâ€²ğœ”âˆˆSğœ”.s.tğœğœ”{ğœ”ğœâ€²ğœ”
â–¡
Lemma 3.12 (Soundness of stepğœ”).The sealed one-step execution
stepğœ”is sound:
stepâ—¦ğ›¾ğœ”(ğ‘‘ğœ”)âŠ†ğ›¾ğœ”â—¦stepğœ”(ğ‘‘ğœ”)
Proof.
stepâ—¦ğ›¾ğœ”(ğ‘‘ğœ”)
=step(Ã{ğœğœ”|ğ‘š#|(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”})
={ğœâ€²|(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”âˆ§ğœâˆˆğœğœ”|ğ‘š#âˆ§ğœ{ğœâ€²})
={ğœâ€²|(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”âˆ§ğ‘šâˆˆğ›¾ğ‘š(ğ‘š#)âˆ§ğœğœ”|ğ‘š{ğœâ€²})
={ğœâ€²|(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”âˆ§ğ‘šâˆˆğ›¾ğ‘š(ğ‘š#)âˆ§ğœğœ”|ğ‘š{ğœâ€²
âˆ§ğœğœ”{ğœ”ğœâ€²ğœ”})
(âˆµSecond property in Lemma reflemma:reform )ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Park and Park, et al.
={ğœâ€²ğœ”|ğ‘š|(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”âˆ§ğ‘šâˆˆğ›¾ğ‘š(ğ‘š#)âˆ§ğœğœ”{ğœ”ğœâ€²ğœ”}
(âˆµValidity of {ğœ”)
=Ã{ğœâ€²ğœ”|ğ‘š#|(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”âˆ§ğœğœ”{ğœ”ğœâ€²ğœ”}
=ğ›¾ğœ”({(ğ‘š#,ğœâ€²ğœ”)|(ğ‘š#,ğœğœ”)âˆˆğ‘‘ğœ”âˆ§ğœğœ”{ğœ”ğœâ€²ğœ”})
=ğ›¾ğœ”â—¦stepğœ”(ğ‘‘ğœ”)
â–¡
Lemma 3.13 (Soundness of gstep).The combined one-step execu-
tiongstep is sound:
âˆ€eğ‘‘âˆˆeD.stepâ—¦eğ›¾(eğ‘‘)âŠ†eğ›¾â—¦gstep(eğ‘‘)
Proof.
stepâ—¦eğ›¾(eğ‘‘)
âŠ†stepâ—¦eğ›¾((ğ‘‘#
ğ›¿,ğ‘‘ğœ”))
(âˆµFirst property in Lemma 3.11
where(ğ‘‘#
ğ›¿,ğ‘‘ğœ”)=reform(eğ‘‘).)
=step(ğ›¾ğ›¿(ğ‘‘#
ğ›¿)âˆªğ›¾ğœ”(ğ‘‘ğœ”))
=step(ğ›¾ğ›¿(ğ‘‘#
ğ›¿))âˆªstep(ğ›¾ğœ”(ğ‘‘ğœ”))
âŠ†ğ›¾ğ›¿â—¦step#
ğ›¿(ğ‘‘#
ğ›¿)âˆªstep(ğ›¾ğœ”(ğ‘‘ğœ”))
(âˆµstep#
ğ›¿is sound.)
âŠ†ğ›¾ğ›¿â—¦step#
ğ›¿(ğ‘‘#
ğ›¿)âˆªğ›¾ğœ”â—¦stepğœ”((ğ‘‘ğœ”))
(âˆµand Lemma 3.12)
=eğ›¾((step#
ğ›¿(ğ‘‘#
ğ›¿),stepğœ”(ğ‘‘ğœ”)))
=eğ›¾â—¦gstep(eğ‘‘)
â–¡
3.8 Termination
Before proving the termination of the abstract interpretation using
the combined domain eD, we define several notations. The initial
abstract state eğ‘‘ğœ„=(ğ‘‘#
ğ›¿ğœ„,âˆ…)is pair of the initial abstract state of the
sensitive abstract domain D#
ğ›¿and an empty set. For each iteration
ğ‘–â‰¥0, we define the ğ‘–-th result of abstract interpretation eğ¹ğ‘–(eğ‘‘ğœ„)=
eğ‘‘ğ‘–=(ğ‘‘#
ğ›¿ğ‘–,ğ‘‘ğœ”ğ‘–)and the difference set Î”ğ‘–=ğ‘‘ğœ”ğ‘–+1\ğ‘‘ğœ”ğ‘–. For simplicity,
we define Î”ğ‘–asâˆ…forğ‘–<0. Moreover, we define a lifted version of
sealed relation Ë†{ğœ”âŠ†(M#Ã—Sğœ”)Ã—(M#Ã—Sğœ”)as follows:
(ğ‘š#,ğœğœ”)Ë†{ğœ”(ğ‘š#,ğœâ€²
ğœ”)â‡”ğœğœ”{ğœ”ğœâ€²
ğœ”
Using the lifted relation, we define the time to live (TTL) function
of sealed states TTLğ‘–:Î”ğ‘–â†’Nfor each iteration ğ‘–â‰¥0as follows:
Definition 3.14 (TTL Function).
TTLğ‘–(ğœ–ğœ”)=ğ‘âˆ’1(ifğ·=âˆ…)
min(Â¤TTLğ‘–âˆ’1(ğ·))âˆ’ 1(otherwise)
whereğ·={ğœ–â€²ğœ”âˆˆÎ”ğ‘–âˆ’1|ğœ–â€²ğœ”Ë†{ğœ”ğœ–ğœ”}
Based on the notations, we formally prove the termination prop-
erty as follows:
Theorem 3.15 (Termination). The abstract interpretation using
the combined domain eDterminates in a finite time if
âˆƒğ‘›.âˆ€ğ‘šâ‰¥ğ‘›.ğ‘‘#
ğ›¿ğ‘š=ğ‘‘#
ğ›¿ğ‘›(12)
âˆ€ğ‘–â‰¥0.âˆ€ğœ–ğœ”âˆˆÎ”ğ‘–.0<TTLğ‘–(ğœ–ğœ”)<ğ‘ (13)
âˆ€ğ‘–>0.ğ‘‘#
ğ›¿ğ‘–âˆ’1=ğ‘‘#
ğ›¿ğ‘–â‡’
sup(Â¤TTLğ‘–(Î”ğ‘–))â‰¤ sup(Â¤TTLğ‘–âˆ’1(Î”ğ‘–âˆ’1))âˆ’ 1(14)Proof. By the condition (12), there exists ğ‘›âˆˆNsuch thatğ‘‘#
ğ›¿ğ‘š=
ğ‘‘#
ğ›¿ğ‘›for allğ‘šâ‰¥ğ‘›. By the condition (13), the TTL of each sealed
state in Î”ğ‘›is bounded by ğ‘:
sup(Â¤TTLğ‘›(Î”ğ‘›))<ğ‘
. Then, the upper bound of TTL for sealed states in each difference
set after the ğ‘›âˆ’th iteration is decreased by the condition (14):
âˆ€ğ‘–>0.sup(Â¤TTLğ‘›+ğ‘–(Î”ğ‘›+ğ‘–))â‰¤ sup(Â¤TTLğ‘›+ğ‘–âˆ’1(Î”ğ‘›+ğ‘–âˆ’1))âˆ’ 1
. which implies that
sup(Â¤TTLğ‘›+ğ‘–(Î”ğ‘›+ğ‘–))â‰¤ sup(Â¤TTLğ‘›(Î”ğ‘›))âˆ’ğ‘–<ğ‘âˆ’ğ‘–
Therefore, for ğ‘—â‰¥ğ‘,
sup(Â¤TTLğ‘›+ğ‘—(Î”ğ‘›+ğ‘—))<ğ‘âˆ’ğ‘—â‰¤0
Notice that again by the condition (13),
ğ‘–ğ‘›ğ‘“(Â¤TTLğ‘›+ğ‘—(Î”ğ‘›+ğ‘—))>0
meaning that
ğ‘–ğ‘›ğ‘“(Â¤TTLğ‘›+ğ‘—(Î”ğ‘›+ğ‘—))>sup(Â¤TTLğ‘›+ğ‘—(Î”ğ‘›+ğ‘—))
which implies Î”ğ‘›+ğ‘—=âˆ…andğ‘‘ğœ”ğ‘›+ğ‘—+1=ğ‘‘ğœ”ğ‘›+ğ‘—. Therefore, for all
ğ‘šâ‰¥ğ‘›+ğ‘,
ğ‘‘#
ğ›¿ğ‘š=ğ‘‘#
ğ›¿ğ‘›+ğ‘âˆ§ğ‘‘ğœ”ğ‘š=ğ‘‘ğœ”ğ‘›+ğ‘
and
eğ‘‘ğ‘š=eğ‘‘ğ‘›+ğ‘
which means the abstract interpretation using the combined domain
eDterminates in ğ‘›+ğ‘iterations. â–¡
Now, we should show that three conditions about the termination
of the sensitive abstract interpretation (12), the bound of TTL for
sealed states in difference sets (13), and the decrease of their upper
bounds (14) in Theorem 3.15 hold.
First, we prove the termination of the sensitive abstract interpre-
tation (12) in Lemma 3.16.
Lemma 3.16 (Termination of Sensitive Abstract Interpre-
tation).
âˆƒğ‘›.âˆ€ğ‘šâ‰¥ğ‘›.ğ‘‘#
ğ›¿ğ‘š=ğ‘‘#
ğ›¿ğ‘›
Proof. Note that for all ğ‘‘#
ğ›¿,ğ‘‘#
ğ›¿â€²âˆˆD#
ğ›¿that satisfies eğ¹((ğ‘‘#
ğ›¿,_))=
(ğ‘‘#
ğ›¿â€²,_),
eğ¹((ğ‘‘#
ğ›¿,_))=(ğ‘‘#
ğ›¿,_)âŠ”gstep((ğ‘‘#
ğ›¿,_))
=(ğ‘‘#
ğ›¿,_)âŠ”( _,_)=(ğ‘‘#
ğ›¿âŠ”_,_)
=(ğ‘‘#
ğ›¿â€²,_)
which implies ğ‘‘#
ğ›¿âŠ‘ğ‘‘#
ğ›¿â€². Since eğ¹((ğ‘‘#
ğ›¿ğ‘–,_))=(ğ‘‘#
ğ›¿ğ‘–+1,_),ğ‘‘#
ğ›¿ğ‘–âŠ‘ğ‘‘#
ğ›¿ğ‘–+1
holds for all ğ‘–â‰¥0. Then,ğ‘‘#
ğ›¿0âŠ‘ğ‘‘#
ğ›¿1âŠ‘ğ‘‘#
ğ›¿2Â·Â·Â·is an ascending chain.
Since the height of the sensitive abstract domain D#
ğ›¿is finite, the
ascending chain condition is also hold. Therefore, there exists n
such that for all ğ‘šâ‰¥ğ‘›,ğ‘‘#
ğ›¿ğ‘š=ğ‘‘#
ğ›¿ğ‘›. â–¡
Then, we prove two remaining conditions (13) and (14). We
first prove two properties of difference sets in Lemma 3.17 and
Corollary 3.18, and a property of TTL in Lemma 3.19. Using them,
we prove the bound of TTL for sealed states in difference sets (13)
in Corollary 3.20 and the decrease of their upper bounds (14) in
Lemma 3.21.Accelerating JavaScript Static Analysis via Dynamic Shortcuts (Extended Version) ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Lemma 3.17.
âˆ€ğ‘–â‰¥0.âˆ€ğœ–ğœ”âˆˆÎ”ğ‘–.
âˆƒğœ‹.ğœğœ”((ğœ‹,ğ‘‘#
ğ›¿ğ‘–(ğœ‹)))Ë†{ğœ”ğœ–ğœ”âˆ¨âˆƒğœ–â€²ğœ”âˆˆÎ”ğ‘–âˆ’1.ğœ–â€²ğœ”Ë†{ğœ”ğœ–ğœ”
Proof. Letğ‘–âˆˆNandğœ–ğœ”âˆˆÎ”ğ‘–=ğ‘‘ğœ”ğ‘–+1\ğ‘‘ğœ”ğ‘–given. By definition,
ğ‘‘ğœ”ğ‘–+1=ğ‘‘ğœ”ğ‘–âˆªstepğœ”(ğ‘‘ğœ”ğ‘–â€²)
where
(_,ğ‘‘ğœ”ğ‘–â€²)=reform(ğ‘‘#
ğ›¿ğ‘–,ğ‘‘ğœ”ğ‘–)
Note thatğœ–ğœ”âˆˆstepğœ”(ğ‘‘ğœ”ğ‘–â€²), and by definition of stepğœ”, there
exists some ğœ–â€²ğœ”âˆˆğ‘‘ğœ”ğ‘–â€²that satisfies ğœ–â€²ğœ”Ë†{ğœ”ğœ–ğœ”. Now, by definition
ofreform ,
ğ‘‘ğœ”ğ‘–â€²=Â¤reformğœ–({(ğœ‹,ğ‘‘#
ğ›¿ğ‘–(ğœ‹))|ğœ‹âˆˆÎ }âˆªğ‘‘ğœ”ğ‘–)âˆ©(M#Ã—Sğœ”)
This means there exists ğœ–âˆˆ {(ğœ‹,ğ‘‘#
ğ›¿ğ‘–(ğœ‹)) |ğœ‹âˆˆÎ }âˆªğ‘‘ğœ”ğ‘–that
satisfies reformğœ–(ğœ–)=ğœ–â€²ğœ”. We have two possible cases for ğœ–.
â€¢ğœ–âˆˆ{(ğœ‹,ğ‘‘#
ğ›¿ğ‘–(ğœ‹))|ğœ‹âˆˆÎ }
In this case, reformğœ–(ğœ–)=ğœğœ”(ğœ–)=ğœ–â€²ğœ”and the left condition
for conclusion is satisfied.
â€¢ğœ–âˆˆğ‘‘ğœ”ğ‘–
In this case, reformğœ–(ğœ–)=ğœ–=ğœ–â€²ğœ”. Now, letâ€™s assume that
ğœ–âˆˆğ‘‘ğœ”ğ‘–âˆ’1. In that case, ğœ–would be preserved after reform
step, that is, ğœ–âˆˆğ‘‘ğœ”ğ‘–âˆ’1â€². Then, by definition of stepğœ”,ğœ–ğœ”âˆˆ
stepğœ”(ğ‘‘ğœ”ğ‘–âˆ’1â€²)âŠ†ğ‘‘ğœ”ğ‘–which contradicts to the fact that ğœ–ğœ”âˆˆ
Î”ğ‘–. Therefore, ğœ–âˆ‰ğ‘‘ğœ”ğ‘–âˆ’1, that is,ğœ–âˆˆğ‘‘ğœ”ğ‘–\ğ‘‘ğœ”ğ‘–âˆ’1=Î”ğ‘–, and
the right condition for conclusion is satisfied.
â–¡
Corollary 3.18.
âˆ€ğ‘–>0.ğ‘‘#
ğ›¿ğ‘–âˆ’1=ğ‘‘#
ğ›¿ğ‘–â‡’âˆ€ğœ–ğœ”âˆˆÎ”ğ‘–.
âˆƒğœ–â€²ğœ”âˆˆÎ”ğ‘–âˆ’1.ğœ–â€²ğœ”Ë†{ğœ”ğœ–ğœ”
Proof. The proof goes same as the previous lemma, until the
point where we divide the case for ğœ–. Letâ€™s assume that the first
case holds, that is,
ğœ–âˆˆ{(ğœ‹,ğ‘‘#
ğ›¿ğ‘–(ğœ‹))|ğœ‹âˆˆÎ }
Sinceğ‘‘#
ğ›¿ğ‘–âˆ’1=ğ‘‘#
ğ›¿ğ‘–,
ğœ–âˆˆ{(ğœ‹,ğ‘‘#
ğ›¿ğ‘–âˆ’1(ğœ‹))|ğœ‹âˆˆÎ }
In that case, ğœ–would be transformed after reform step, that is,
ğœğœ”(ğœ–)=ğœ–â€²ğœ”âˆˆğ‘‘ğœ”ğ‘–âˆ’1â€². Then, by definition of stepğœ”,ğœ–ğœ”âˆˆstepğœ”(ğ‘‘ğœ”ğ‘–âˆ’1â€²)âŠ†
ğ‘‘ğœ”ğ‘–which contradicts to the fact that ğœ–ğœ”âˆˆÎ”ğ‘–. Therefore, only
second case holds and the right conclusion in previous lemma is
satisfied. â–¡
Lemma 3.19 (Property of TTL).
âˆ€ğ‘–â‰¥0.âˆ€ğœ–ğœ”âˆˆÎ”ğ‘–.TTLğ‘–(ğœ–ğœ”)=ğ‘˜â‡’
ğ‘˜<ğ‘âˆ§âˆƒ(ğœ‹,ğ‘‘#).(ğœğœ”((ğœ‹,ğ‘‘#))Ë†{(ğ‘âˆ’ğ‘˜)
ğœ”ğœ–ğœ”)
Proof. We prove by induction on ğ‘–. Letğœ–ğœ”âˆˆÎ”ğ‘–.
â€¢Ifğ‘–=0,TTL 0(ğœ–ğœ”)=ğ‘âˆ’1<ğ‘and since only left conclusion
of lemma 3.17 can hold, there exists view ğœ‹s.t.ğœğœ”(ğœ‹,ğ‘‘#
ğ›¿0(ğœ‹))Ë†{1
ğœ”ğœ–ğœ”.â€¢Ifğ‘–>0, we have two cases for ğ·={ğœ–â€²ğœ”âˆˆÎ”ğ‘–âˆ’1|ğœ–â€²ğœ”Ë†{ğœ”ğœ–ğœ”}.
Ifğ·=âˆ…, the argument is similar as ğ‘–=0case. Otherwise,
letğœ–â€²ğœ”=ğ‘ğ‘Ÿğ‘”ğ‘šğ‘–ğ‘›
xâˆˆğ·TTLğ‘–âˆ’1(ğ‘¥).
By induction hypothesis, we have
ğ‘˜â€²=TTLğ‘–âˆ’1(ğœ–â€²
ğœ”)<ğ‘
and there exists(ğœ‹,ğ‘‘#)such that
ğœ–â€²â€²
ğœ”=ğœğœ”((ğœ‹,ğ‘‘#))Ë†{(ğ‘âˆ’ğ‘˜â€²)
ğœ”ğœ–â€²
ğœ”.
By definition of TTLğ‘–,TTLğ‘–(ğœ–ğœ”)=TTLğ‘–(ğœ–â€²ğœ”)âˆ’1, andğ‘˜=
ğ‘˜â€²âˆ’1. Then,
ğ‘˜=ğ‘˜â€²âˆ’1<ğ‘âˆ’1<ğ‘
andğœ–â€²â€²ğœ”Ë†{(ğ‘âˆ’ğ‘˜âˆ’1)
ğœ”ğœ–â€²ğœ”withğœ–â€²ğœ”Ë†{ğœ”ğœ–ğœ”implies that
ğœ–â€²â€²
ğœ”Ë†{(ğ‘âˆ’ğ‘˜)
ğœ”ğœ–ğœ”.
â–¡
Corollary 3.20.
âˆ€ğ‘–â‰¥0.âˆ€ğœ–ğœ”âˆˆÎ”ğ‘–.0<TTLğ‘–(ğœ–ğœ”)<ğ‘
Proof. We already proved ğ‘˜=TTLğ‘–(ğœ–ğœ”)<ğ‘. Now, letâ€™s as-
sume thatğ‘˜â‰¤0. By previous lemma, there exists (ğœ‹,ğ‘‘#)such
that
(ğœğœ”((ğœ‹,ğ‘‘#))Ë†{(ğ‘âˆ’ğ‘˜)
ğœ”ğœ–ğœ”)
Sinceğ‘âˆ’ğ‘˜â‰¥ğ‘, this implies that there exists ğœ–â€²ğœ”such that
(ğœğœ”((ğœ‹,ğ‘‘#))Ë†{ğ‘
ğœ”ğœ–â€²
ğœ”)
However, this contradicts to the condition (9) of ğœğœ”that says if
(ğœ‹,ğ‘‘#)is in domain of ğœğœ”, the number of possible {ğœ”from state
ofğœğœ”((ğœ‹,ğ‘‘#))is at mostğ‘âˆ’1. Therefore, ğ‘˜>0.â–¡
Lemma 3.21.
âˆ€ğ‘–>0.ğ‘‘#
ğ›¿ğ‘–âˆ’1=ğ‘‘#
ğ›¿ğ‘–â‡’
sup(Â¤TTLğ‘–(Î”ğ‘–))â‰¤ sup(Â¤TTLğ‘–âˆ’1(Î”ğ‘–âˆ’1))âˆ’ 1
Proof. Letğœ–ğœ”âˆˆÎ”ğ‘–. By Corollary 3.18, the set
ğ·={ğœ–â€²
ğœ”âˆˆÎ”ğ‘–âˆ’1|ğœ–â€²
ğœ”Ë†{ğœ”ğœ–ğœ”}
is non-empty, and for some ğœ–â€²ğœ”âˆˆÎ”ğ‘–âˆ’1,
TTLğ‘–(ğœ–ğœ”)=TTLğ‘–âˆ’1(ğœ–â€²
ğœ”)âˆ’1â‰¤sup(Â¤TTLğ‘–âˆ’1(Î”ğ‘–âˆ’1))âˆ’ 1
Since it holds for every ğœ–ğœ”âˆˆÎ”ğ‘–,
sup(Â¤TTLğ‘–(Î”ğ‘–))â‰¤ sup(Â¤TTLğ‘–âˆ’1(Î”ğ‘–âˆ’1))âˆ’ 1
â–¡
4 DYNAMIC SHORTCUTS FOR JAVASCRIPT
In this section, we introduce the core language of JavaScript that
supports first-class functions, open objects, and first-class property
names, and define sealed execution of the core language for dynamic
shortcuts.ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Park and Park, et al.
ğœ{ğœ
ğ‘ƒ(l)=ğ‘Ÿ=ğ‘’ ğœâŠ¢ğ‘Ÿğ‘Ÿâ‡’ğ‘™ ğœâŠ¢ğ‘’ğ‘’â‡’ğ‘£
ğœ=(l,ğ‘€,ğ‘,ğ‘){(next(l),ğ‘€[ğ‘™â†¦â†’ğ‘£],ğ‘,ğ‘)ğ‘ƒ(l)=ğ‘Ÿ={}ğœâŠ¢ğ‘Ÿğ‘Ÿâ‡’ğ‘™ ğ‘â€²=(a fresh object address)
ğœ=(l,ğ‘€,ğ‘,ğ‘){(next(l),ğ‘€[ğ‘™â†¦â†’ğ‘â€²],ğ‘,ğ‘)
ğ‘ƒ(l)=ğ‘Ÿ=ğ‘’ğ‘“(ğ‘’ğ‘)ğœâŠ¢ğ‘Ÿğ‘Ÿâ‡’ğ‘™ ğœâŠ¢ğ‘’ğ‘’ğ‘“â‡’ğœ†ğ‘¥. lğ‘
ğœâŠ¢ğ‘’ğ‘’ğ‘â‡’ğ‘£ğ‘ğ‘â€²=(a fresh environment address)
ğœ=(l,ğ‘€,ğ‘,ğ‘){(lğ‘,ğ‘€[(ğ‘â€²,ğ‘¥)â†¦â†’ğ‘£ğ‘],ğ‘[ğ‘â€²â†¦â†’(ğ‘,next(l),ğ‘™)],ğ‘â€²)ğ‘ƒ(l)=retğ‘’ ğœâŠ¢ğ‘’ğ‘’â‡’ğ‘£ ğ‘(ğ‘)=(ğ‘â€²,lâ€²,ğ‘™)
ğœ=(l,ğ‘€,ğ‘,ğ‘){(lâ€²,ğ‘€[ğ‘™â†¦â†’ğ‘£],ğ‘,ğ‘â€²)
ğ‘ƒ(l)=ifğ‘’lâ€²ğœâŠ¢ğ‘’ğ‘’â‡’true
ğœ=(l,ğ‘€,ğ‘,ğ‘){(lâ€²,ğ‘€,ğ‘,ğ‘)ğ‘ƒ(l)=ifğ‘’lâ€²ğœâŠ¢ğ‘’ğ‘’â‡’false
ğœ=(l,ğ‘€,ğ‘,ğ‘){(next(l),ğ‘€,ğ‘,ğ‘)
ğœâŠ¢ğ‘Ÿğ‘Ÿâ‡’ğ‘™
ğœ=(l,ğ‘€,ğ‘,ğ‘)âŠ¢ğ‘Ÿğ‘¥â‡’(ğ‘,ğ‘¥)ğœâŠ¢ğ‘’ğ‘’0â‡’ğ‘0ğœâŠ¢ğ‘’ğ‘’1â‡’ğ‘£1ğ‘£1âˆˆVstr
ğœ=(l,ğ‘€,ğ‘,ğ‘)âŠ¢ğ‘Ÿğ‘’0[ğ‘’1]â‡’(ğ‘0,ğ‘£1)
ğœâŠ¢ğ‘’ğ‘’â‡’ğ‘£
ğœ=(l,ğ‘€,ğ‘,ğ‘)âŠ¢ğ‘’ğ‘£pâ‡’ğ‘£p ğœ=(l,ğ‘€,ğ‘,ğ‘)âŠ¢ğ‘’ğœ†ğ‘¥. lâ€²â‡’ğœ†ğ‘¥. lâ€²ğœâŠ¢ğ‘Ÿğ‘Ÿâ‡’ğ‘™ ğ‘™âˆˆDom(ğ‘€)
ğœ=(l,ğ‘€,ğ‘,ğ‘)âŠ¢ğ‘’ğ‘Ÿâ‡’ğ‘€(ğ‘™)
ğœâŠ¢ğ‘’ğ‘’1â‡’ğ‘£1Â·Â·Â·ğœâŠ¢ğ‘’ğ‘’ğ‘›â‡’ğ‘£ğ‘›
ğœ=(l,ğ‘€,ğ‘,ğ‘)âŠ¢ğ‘’op(ğ‘’1,Â·Â·Â·,ğ‘’ğ‘›)â‡’ op(ğ‘£1,Â·Â·Â·,ğ‘£ğ‘›)
Figure 6: The transition relation for the core language of JavaScript
4.1 Core Language of JavaScript
Programs ğ‘ƒ::=(l:ğ‘–)âˆ—
Labels lâˆˆ L
Instructions ğ‘–::=ğ‘Ÿ=ğ‘’|ğ‘Ÿ={}|ğ‘Ÿ=ğ‘’(ğ‘’)|retğ‘’|ifğ‘’l
References ğ‘Ÿ::=ğ‘¥|ğ‘’[ğ‘’]
Expressions ğ‘’::=ğ‘£p|ğœ†ğ‘¥. l|ğ‘Ÿ|op(ğ‘’âˆ—)
A programğ‘ƒis a sequence of labeled instructions. An instruction
ğ‘–is an expression assignment, an object creation, a function call,
a return instruction, or a branch. A reference ğ‘Ÿis a variable or a
property access of an object. An expression ğ‘’is a primitive, a lambda
function, a reference, or an operation between other expressions.
States ğœâˆˆS=LÃ—MÃ— CÃ—Aenv
Memories ğ‘€âˆˆM=Lfinâˆ’âˆ’â†’V
Contexts ğ‘âˆˆC=Aenvfinâˆ’âˆ’â†’(AenvÃ—LÃ— L)
Locations ğ‘™âˆˆL=(AenvÃ—X)âŠ(AobjÃ—Vstr)
Values ğ‘£âˆˆV=VpâŠAobjâŠF
Primitives ğ‘£pâˆˆVp=VstrâŠÂ·Â·Â·
Addresses ğ‘âˆˆA=AenvâŠAobj
Functions ğœ†ğ‘¥. lâˆˆF=XÃ—L
States Sconsist of labelsL, memoriesM, contexts C, and en-
vironment addresses Aenv. A memory ğ‘€âˆˆM is a finite mapping
from locations to values. A context ğ‘âˆˆCis a finite mapping from
environment addresses to tuple of environment addresses, return
labels, and left-hand side locations. A location ğ‘™âˆˆLis a variable or
an object property; a variable location consists of an environment
address and its name, and an object property location consists of an
object address and a string value. A value ğ‘£âˆˆVis a primitive, an
address, or a function value. An address ğ‘âˆˆAis an environmentaddress or an object address. A function value ğœ†ğ‘¥. lâˆˆFconsists of
a parameter name and a body label. In the core language, the closed
scoping is used for functions for brevity, thus only parameters and
local variables are accessible in a function body.
We formulate the concrete semantics of the core language as
described in Figure 6. The transition relation between concrete
states is defined with the semantics of references and expressions
using two different forms ğœâŠ¢ğ‘Ÿğ‘Ÿâ‡’ğ‘™andğœâŠ¢ğ‘’ğ‘’â‡’ğ‘£, respec-
tively. The initial states are Sğœ„={(lğœ„,âˆ…,ğœ–,ğ‘ top)}where lğœ„denotes
the initial label, ğœ–empty map, and ğ‘topthe top-level environment
address. The function next returns the next label of a given label in
the current program ğ‘ƒ.
4.2 Abstract Semantics
In the abstract semantics of the core language, we use the flow
sensitivity with a flow sensitive view abstraction ğ›¿FS:Lâ†’Dthat
discriminates states using their labels: âˆ€lâˆˆL.ğ›¿FS(l)={ğœâˆˆS|
ğœ=(l,_,_,_)}. Thus, the sensitive abstract domain is defined as
D#
ğ›¿=Lâ†’D#. We define an abstract state ğ‘‘#âˆˆD#as a tuple of
an abstract memory, an abstract context, an abstract address, and
an abstract counter as follows:
Abstract states ğ‘‘#âˆˆD#=M#Ã—C#Ã—A#Ã—N#
Abstract memories ğ‘€#âˆˆM#=L#finâˆ’âˆ’â†’V#
Abstract locations ğ‘™#âˆˆL#=(A#Ã—X)âŠ(A#Ã—Vstr)
Abstract addresses ğ‘#âˆˆA#=L
Abstract contexts ğ‘#âˆˆC#=A#finâˆ’âˆ’â†’P( A#Ã—Î Ã—P(L#))
Abstract counters ğ‘›#âˆˆN#=A#â†’{0#,1#,â‰¥2#}
Abstract values ğ‘£#âˆˆV#=P(VpâŠA#âŠF)Accelerating JavaScript Static Analysis via Dynamic Shortcuts (Extended Version) ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Jğœ‹â†’ğœ‹â€²K#:D#â†’D#
ğ‘‘#=(ğ‘€#,ğ‘#,ğ‘#,ğ‘›#)
ğ‘ƒ(l)=ğ‘Ÿ=ğ‘’ Jğ‘ŸK#
ğ‘Ÿ(ğ‘‘#)=ğ¿ Jğ‘’K#
ğ‘’(ğ‘‘#)=ğ‘£#
Jlâ†’next(l)K#(ğ‘‘#)=(ğ‘€#[ğ¿Â¤â†¦â†’ğ‘£#],ğ‘#,ğ‘#,ğ‘›#)ğ‘‘#=(ğ‘€#,ğ‘#,ğ‘#,ğ‘›#)
ğ‘ƒ(l)=ğ‘Ÿ={} Jğ‘ŸK#
ğ‘Ÿ(ğ‘‘#)=ğ¿ ğ‘#
obj=l
Jlâ†’next(l)K#(ğ‘‘#)=(ğ‘€#[ğ¿Â¤â†¦â†’{ğ‘#
obj}],ğ‘#,ğ‘#,inc(ğ‘›#,ğ‘#
obj))
ğ‘‘#=(ğ‘€#,ğ‘#,ğ‘#,ğ‘›#)ğ‘ƒ(l)=ğ‘Ÿ=ğ‘’ğ‘“(ğ‘’ğ‘)
Jğ‘ŸK#
ğ‘Ÿ(ğ‘‘#)=ğ¿ ğœ†ğ‘¥. lğ‘âˆˆJğ‘’ğ‘“K#
ğ‘’(ğ‘‘#) Jğ‘’ğ‘K#
ğ‘’(ğ‘‘#)=ğ‘£#
ğ‘
ğ‘#
env=lğ‘ğ‘#
env=ğ‘#[ğ‘#
envâ†¦â†’ğ‘#(ğ‘#
env)âˆª{(ğ‘#,next(l),ğ¿)}]
Jlâ†’ lğ‘K#(ğ‘‘#)=(ğ‘€#[(ğ‘#
env,ğ‘¥)â†¦â†’ğ‘£#
ğ‘],ğ‘#
env,ğ‘#
env,inc(ğ‘›#,ğ‘#
env))ğ‘‘#=(ğ‘€#,ğ‘#,ğ‘#,ğ‘›#)
ğ‘ƒ(l)=retğ‘’ Jğ‘’K#
ğ‘’(ğ‘‘#)=ğ‘£#(ğ‘#
ret,lâ€²,ğ¿)âˆˆğ‘#(ğ‘#)
Jlâ†’ lâ€²K#(ğ‘‘#)=(ğ‘€#[ğ¿Â¤â†¦â†’ğ‘£#],ğ‘#,ğ‘#
ret,ğ‘›#)
ğ‘ƒ(l)=ifğ‘’lâ€²trueâˆˆJğ‘’K#
ğ‘’(ğ‘‘#)
Jlâ†’ lâ€²K#(ğ‘‘#)=ğ‘‘#ğ‘ƒ(l)=ifğ‘’lâ€²falseâˆˆJğ‘’K#
ğ‘’(ğ‘‘#)
Jlâ†’next(l)K#(ğ‘‘#)=ğ‘‘#
Jğ‘ŸK#
ğ‘Ÿ:D#â†’P( L#)
ğ‘‘#=(ğ‘€#,ğ‘#,ğ‘#,ğ‘›#)
Jğ‘¥K#
ğ‘Ÿ(ğ‘‘#)={(ğ‘#,ğ‘¥)}ğ‘‘#=(ğ‘€#,ğ‘#,ğ‘#,ğ‘›#)
ğ´=Jğ‘’0K#
ğ‘’(ğ‘‘#)âˆ©A#ğ‘†=Jğ‘’1K#
ğ‘’(ğ‘‘#)âˆ©Vstr
Jğ‘’0[ğ‘’1]K#
ğ‘Ÿ(ğ‘‘#)=ğ´Ã—ğ‘†
Jğ‘’K#
ğ‘’:D#â†’V#
Jğ‘£pK#
ğ‘’(ğ‘‘#)={ğ‘£p} Jğœ†ğ‘¥. lK#
ğ‘’(ğ‘‘#)={ğœ†ğ‘¥. l}ğ‘‘#=(ğ‘€#,ğ‘#,ğ‘#,ğ‘›#)ğ‘£#=Ã„
{ğ‘€#(ğ‘™#)|ğ‘™#âˆˆJğ‘ŸK#
ğ‘Ÿ(ğ‘‘#)}
Jğ‘ŸK#
ğ‘’(ğ‘‘#)=ğ‘£#
Jğ‘’1K#
ğ‘’(ğ‘‘#)=ğ‘£#
1Â·Â·Â· Jğ‘’ğ‘›K#
ğ‘’(ğ‘‘#)=ğ‘£#
ğ‘›
Jop(ğ‘’1,Â·Â·Â·,ğ‘’ğ‘›)K#
ğ‘’(ğ‘‘#)=Â¤op(ğ‘£#
1,Â·Â·Â·,ğ‘£#
ğ‘›)
Figure 7: The semantics of view transition for the core language of JavaScript
An abstract memory ğ‘€#âˆˆM#is a finite mapping from abstract
locations L#to abstract values V#. Abstract locations L#are pairs
of abstract addresses with variable names or string values. Abstract
addresses A#are defined with the allocation-site abstraction that
partitions concrete addresses Abased on their allocation sites L.
Abstract contexts C#are finite maps from abstract addresses to
powersets of triples of abstract addresses, views, and powerset of
abstract locations. For abstract counting [27, 35] in static analysis,
we define abstract counters N#that are mappings from abstract
addresses to their abstract counts representing how many times
each abstract address has been allocated; 0#denotes that it has
never been allocated, 1#once, andâ‰¥2#more than or equal to twice.
We define the semantics of the view transition for the core lan-
guage. For abstract memories, we use the notation ğ‘€#[ğ¿Â¤â†¦â†’ğ‘£#]
to represent the update of multiple abstract locations in ğ¿with
the abstract value ğ‘£#. It performs the strong update if the abstract
address for an abstract location (ğ‘#,_)âˆˆğ¿is singleton: ğ‘›#(ğ‘#)=1#.
Otherwise, it performs the weak update for the analysis soundness.
We use the increment function inc:N#Ã—A#â†’N#of the abstract
counter defined as follows:
inc(ğ‘›#)(ğ‘#
0)=ğœ†ğ‘#âˆˆA#.ï£±ï£´ï£´ ï£²
ï£´ï£´ï£³1#ifğ‘#=ğ‘#
0âˆ§ğ‘›#(ğ‘#
0)=0#
â‰¥2#ifğ‘#=ğ‘#
0âˆ§ğ‘›#(ğ‘#
0)=1#
ğ‘›#(ğ‘#)otherwise4.3 Sealed Execution
We define sealed states by not only extending the concrete values
Vwith sealed values Î©but also adding the abstract counters N#:
Sğœ”=LÃ—MÃ— CÃ—AenvÃ—N#
C=Aenvfinâˆ’âˆ’â†’((AenvÃ—LÃ— L)âŠÎ©)
V=VpâŠAobjâŠFâŠÎ©
N#=Aobjâ†’{0#,1#,â‰¥2#}
Because JavaScript provides open objects, the properties of ob-
jects can be dynamically added or deleted. Moreover, since object
properties are string values that can be constructed at run time, it
is difficult to perform sound strong updates in static analysis. To
check the possibility of strong updates during sealed execution, we
augment its states with the abstract counters N#.
For each abstract value in a given abstract state, if the abstract
value denotes a single concrete value, the converter ğœğœ”:(Î Ã—D#)â†’
(M#Ã—Sğœ”)keeps it; otherwise, ğœğœ”replaces the abstract value with
its unique identifier and maintains the mapping from the unique
identifier to the abstract value to construct an abstract instantiation
map. The opposite converter ğœ#:(M#Ã—Sğœ”)â†’( Î Ã—D#)recovers
abstract values from their unique identifiers using the abstract
instantiation map. We define the sealed transition relation {ğœ”
only if the next step does not require actual values of any sealed
values. Otherwise, a given sealed state does not have any sealedESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Park and Park, et al.
transitions to apply. For example, we add the following rule:
ğ‘ƒ(l)=retğ‘’ ğœğœ”âŠ¢ğ‘’ğ‘’â‡’ğ‘£ ğ‘(ğ‘)âˆˆÎ©
ğœğœ”=(l,ğ‘€,ğ‘,ğ‘,ğ‘›#){ğœ”âŠ¥
for the retstatement. We extend each rule of the concrete semantics
to support such behaviors of sealed values.
5 IMPLEMENTATION
We implemented JavaScript static analysis using dynamic short-
cuts presented in Section 4 in a prototype implementation dubbed
SAFE DS. The tool is an extension of an existing state-of-the-art
JavaScript static analyzer SAFE [ 25,36] with a dynamic analyzer
Jalangi [ 39], and it is an open-source project and available online4.
In this section, we introduce challenges and solutions in implement-
ing dynamic shortcuts on existing JavaScript analyzers.
Sealed Values. The main challenge of implementing dynamic
shortcuts is to support sealed execution on an existing JavaScript
engine. To represent an abstract value, we use the Proxy object intro-
duced in ECMAScript 6 (2015, ES6) [ 7], which allows developers to
handle internal behaviors of specific objects such as property reads
and writes and implicit conversions. We are inspired by Mimic [18],
which used Proxy to capture accesses from internals of opaque func-
tions. When the dynamic analyzer constructs an execution environ-
ment at the start of a dynamic shortcut, it creates Proxy objects to
represent abstract values via the following getSealedValue function:
1 function getSealedValue () {
2 function detect () { /* access detection */ }
3 return new Proxy ( function () {}, {
4 getPrototypeOf : detect , ...
5 construct : detect
6 }); }
7 var x = getSealedValue ();
8 var y = x;
9 var z = x + 1;
The function creates a sealed value as a proxy object with a dummy
function object and a handler for all 13 traps using an access de-
tection function detect . A sealed value invokes the function detect
when any of 13 pre-defined traps are operated on the object, which
enables us to determine whether an object is sealed or not. For
example, the variable ysuccessfully points to the same sealed value
stored in x, but the program invokes the function detect on line
9 because x + 1 requires the actual value of the sealed value. In
addition, we instrument unary and binary operations in Jalangi so
that we can detect all the accesses on the sealed value beyond the 13
traps provided by Proxy . Using this idea, we successfully extended
the JavaScript engine to support sealed execution.
Synchronization of Control Points. For seamless interaction be-
tween static analysis and sealed execution, synchronization of con-
trol points in both sides is necessary. The SAFE static analyzer and
the Jalangi dynamic analyzer have their own notations for control
points that are not directly compatible. We use the source-code loca-
tion of a target program as a key to synchronize. Even though they
use different parsers and we faced numerous location mismatches
4https://github.com/kaist-plrg/safe-dsfor corner cases, we could synchronize control points of two an-
alyzers by using the closest match of their source-code locations
rather than using their exact match.
Function-Level Dynamic Shortcut. A dynamic shortcut is acti-
vated when the current abstract state passes the filter checker .
Because SAFE and Jalangi are implemented in different languages,
Scala and JavaScript, respectively, we represent abstract states as
JSON objects and communicate between analyzers by passing JSON
objects through a localhost server. If the filter admits dynamic short-
cuts generously, the analysis may suffer from frequent communi-
cations between static and dynamic analyzers. To adjust such a
burden, SAFE DSsupports only function-level dynamic shortcuts by
activating dynamic shortcuts in function entries and deactivating
them in their corresponding function exits.
Termination. To guarantee the termination of static analysis
using dynamic shortcuts, the converter ğœğœ”should pass an analysis
element(ğœ‹,ğ‘‘#)only when it terminates in a time bound ğ‘. Since
statically checking the termination property is difficult, we simply
perform sealed execution with a pre-determined time limit of 5
seconds. When it times out, we treat it as a failure in conversion;
otherwise, we use the result of sealed execution.
6 EVALUATION
We evaluate SAFE DSusing the following research questions:
â€¢RQ1) Analysis Speed-up: How much analysis time is re-
duced by using dynamic shortcuts?
â€¢RQ2) Precision Improvement: How much analysis preci-
sion is improved by using dynamic shortcuts?
â€¢RQ3) Opaque Function Coverage: How many opaque
functions are covered only by dynamic shortcuts?
We selected the official 306 tests of Lodash 4 (v.4.17.20)5used in the
examples in Section 2 as our evaluation target. Recent work [ 28,41]
also used the tests to evaluate their techniques. Among them, we
filtered out 37 tests that use JavaScript language features SAFE does
not support such as dynamic code generation using Function , getters
and setters, and browser-specific features like __proto__ . Thus, we
used 269 out of 306 tests for the evaluation of SAFE DSand compared
its evaluation results with those of the baseline analyzer, SAFE.
For both SAFE and SAFE DS, we used 400-depth, 10-length loop
strings and 30-length call strings for precise analysis, and added
some incomplete models for opaque functions to soundly analyze
Lodash tests. We performed our experiments on a Ubuntu machine
equipped with 4.2GHz Quad-Core Intel Core i7 and 32GB of RAM.
6.1 Analysis Speed-up
We evaluated the effectiveness of dynamic shortcuts by static anal-
ysis of 269 Lodash 4 tests with and without dynamic shortcuts.
Figure 8 depicts cumulative distribution charts for their analysis
time and a box plot in a logarithmic scale for speed up after ap-
plying dynamic shortcuts. In the upper chart, the ğ‘¥-axis is time
and theğ‘¦-axis shows the number of tests within the time. While
the baseline analysis (no-DS) finished analysis of 200 out of 269
tests within 5 minutes, our tool (DS) finished analysis of 265 tests
5https://github.com/lodash/lodash/blob/4.17.20/test/test.jsAccelerating JavaScript Static Analysis via Dynamic Shortcuts (Extended Version) ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
Figure 8: Analysis time for Lodash 4 original tests without
(no-DS) and with (DS) dynamic shortcuts within 5 minutes
Figure 9: Analysis time for Lodash 4 abstracted tests without
(no-DS) and with (DS) dynamic shortcuts within 5 minutes
using dynamic shortcuts. For finished tests, the average analysis
time is 49.46 seconds for no-DS and 3.21 seconds for DS. Among
200 tests analyzed by no-DS, one test is timeout in DS, thus 199
tests are analyzable by both analyzers. For them, we depict the box
plot for analysis speed up by dynamic shortcuts. It shows that DS
outperforms no-DS up to 83.71 xand 22.30 xon average. Only for
one test using _.sample , which randomly samples a value from a
given array, DS showed 0.36 xspeed of no-DS due to 24 times uses
of dynamic shortcuts.
Note that since most tests use concrete values instead of non-
deterministic inputs, they can be analyzed by a few number of dy-
namic shortcuts. In fact, among 269 tests, 259 tests are analyzed by a
single dynamic shortcut without using abstract semantics. However,
in real-world JavaScript programs, arguments of library functions
may include non-deterministic inputs. To evaluate SAFE DSin a
real-world setting, we modified the tests to use abstract values. We
made abstract values by randomly selecting literals and replacing
one of them with its corresponding abstract value. For example,
if we select a numeric literal 42, we modified it to the abstract nu-
meric valueâŠ¤num, which represents all the numeric values. In the
remaining section, we evaluated SAFE DSusing the original tests
and the abstracted tests.
For abstracted tests as well, DS outperformed no-DS. Figure 9
shows the analysis time of the abstracted tests. Among 269 ab-
stracted tests, no-DS finished analysis of 158 tests within 5 minutes,
but DS finished analysis of 193 tests. For finished tests, the average
analysis time is 44.88 seconds for no-DS and 19.05 seconds for DS.
Among 158 tests analyzed by no-DS, DS timed-out for 2 tests. For
156 tests analyzable by both analyzers, DS outperformed no-DS
up to 78.07 xand 7.81 xon average. Except for 9 test cases, using
dynamic shortcuts did show speed-ups.
Figure 10: Analysis time ratio for 156 abstracted tests
Unlike for the original tests, analysis of 156 abstracted tests in-
voked 20.35 dynamic shortcuts. Because taking a dynamic shortcut
requires conversion between abstract states and sealed values and
their exchanges between the static analyzer and the dynamic an-
alyzer, using dynamic shortcuts multiple times may incur more
performance overhead than performance benefits by using sealed
execution. One conjecture is that the communication cost between
the static analyzer and the dynamic analyzer may be proportional
to the number of dynamic shortcuts.
To experimentally evaluate the conjecture, we investigated the
relationship between the communication cost (Comm. Cost) be-
tween analyzers and the number of dynamic shortcuts. For 199
original tests, Comm. Cost was only 1.58% compared to the analysis
time of no-DS. However, for 156 abstracted tests, Comm. Cost was
31.06% compared to the analysis time of no-DS. Figure 10 presents
the analysis time ratio for 156 abstracted tests. The ğ‘¥-axis repre-
sents the time ratio normalized by the total analysis time of no-DS
and theğ‘¦-axis denotes the number of dynamic shortcuts and the
number of corresponding tests. For all 156 tests, Comm. Cost is
larger than both the static analysis time (Static) and the dynamic
analysis time (Dynamic). When dynamic shortcuts are performed
less than 10 times, Comm. Cost is modest compared to the base-
line static analysis time. However, the more dynamic shortcuts
are performed, the less the performance benefits by using dynamic
shortcuts. Specifically, when dynamic shortcuts are performed more
than 30 times, Comm. Cost is even larger than half of cost of no-DS.
Based on this evaluation result, we believe that we can leverage
dynamic shortcuts by optimizing Comm. Cost between the static
analyzer and the dynamic analyzer. One possible approach is to
reduce the sizes of JSON objects that represent abstract and sealed
states by representing only their updated parts. Another approach
could be to use a communication system faster than a localhost
server for passing JSON objects.
6.2 Precision Improvement
To evaluate the analysis precision improvement of dynamic short-
cuts, we measured the number of failed assertions produced by
no-DS and DS. Because both no-DS and DS are sound, high (low)
number of failed assertions denotes low (high) analysis precision.
Figure 11 depicts the comparison of the analysis precision be-
tween no-DS and DS. The ğ‘¥-axis and the ğ‘¦-axis denote the number
of failed assertions produced by no-DS and DS, respectively. For
example, if both DS and no-DS failed 4 assertions in an original test,
the figure shows a circle at the point (4, 4). Since multiple circles
can be at the same point if both DS and no-DS failed the sameESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Park and Park, et al.
Table 1: Number of original (orig.) and abstracted (abs.) tests using dynamic shortcuts only for each JavaScript built-in library
Object Function# ReplacedObject Function# ReplacedObject Function# Replaced
orig. abs. orig. abs. orig. abs.
Array 204 / 205 119 / 141 String 20 / 20 13 / 14 Object 265 / 265 181 / 193
new Array 0 / 0 0 / 7 toString 0 / 0 0 / 14 getPrototypeOf 56 / 56 34 / 35
isArray 264 / 265 181 / 193 valueOf 0 / 0 0 / 20 create 265 / 265 193 / 193
concat 265 / 265 189 / 193 charAt 8 / 8 6 / 6ObjectdefineProperty 265 / 265 190 / 193
join 265 / 265 193 / 193 charCodeAt 15 / 15 8 / 8 freeze 1 / 1 1 / 1
pop 25 / 25 14 / 14 indexOf 2 / 2 1 / 1 keys 265 / 265 191 / 193
Arraypush 265 / 265 186 / 193Stringmatch 26 / 26 16 / 18 toString 264 / 265 138 / 193
reverse 10 / 10 6 / 6 replace 56 / 56 31 / 37 hasOwnProperty 265 / 265 190 / 193
shift 3 / 3 2 / 2 slice 265 / 265 191 / 193 JSON stringify 1 / 1 1 / 1
slice 265 / 265 193 / 193 split 5 / 5 2 / 2 parseInt 2 / 2 1 / 2
sort 69 / 69 38 / 39 substring 214 / 214 136 / 145 Global isNaN 15 / 15 11 / 40
splice 25 / 25 9 / 12 toLowerCase 215 / 215 135 / 146 isFinite 3 / 3 1 / 1
unshift 2 / 2 2 / 2 toUpperCase 11 / 11 6 / 7 RegExp 265 / 265 193 / 193
indexOf 94 / 94 61 / 66 fromCharCode 1 / 1 1 / 1RegExpnew RegExp 0 / 0 0 / 1
every 92 / 92 43 / 47 Date new Date 0 / 1 0 / 1 exec 265 / 265 193 / 193
ceil 37 / 38 20 / 21 Number 2 / 2 2 / 2 test 264 / 265 185 / 193
floor 16 / 18 8 / 10 Number toFixed 1 / 1 0 / 0 Error 1 / 1 0 / 1
Mathmax 264 / 265 179 / 193 valueOf 0 / 0 0 / 28 Error new RangeError 0 / 0 0 / 2
min 64 / 64 31 / 44 toString 265 / 265 193 / 193 new TypeError 0 / 0 0 / 7
pow 11 / 11 6 / 6 Function apply 263 / 265 133 / 193BooleanBoolean 3 / 3 2 / 2
round 2 / 2 1 / 1 call 259 / 265 50 / 193 valueof 0 / 0 0 / 7
(a) 199 original tests
 (b) 156 abstracted tests
Figure 11: Failed assertions of analysis without (no-DS) and
with (DS) dynamic shortcuts
number of assertions, we use darker gray to denote a larger number
of tests in a heat-map form. The darker the circle is, the more tests
it indicates. The dotted line denotes the ğ‘¦=ğ‘¥line and all the circles
are below or on the line, which means DS produces less or equal
numbers of assertions compared to no-DS for all tests. On the other
hand, the solid line denotes the average improvement, which is the
ratio of the total number of failed assertions produced by no-DS to
that produced by DS. For 199 original tests that are analyzable by
both analyzers, Figure 11(a) shows that dynamic shortcuts reduced
the number of failed assertions by 92.79% on average. For 156 ab-
stracted tests that are analyzable by both analyzers, Figure 11(b)
shows that dynamic shortcuts successfully cut down the number of
failed assertions by 12.31% on average. Thus, on average, dynamic
shortcuts removed analysis of 92.79% and 12.31% failed assertions
for original and abstracted tests, respectively.
6.3 Opaque Function Coverage
To evaluate how much manual modeling efforts of opaque func-
tions are reduced by dynamic shortcuts, we measured the number
of tests for which opaque functions are analyzed only by dynamic
analysis not by static analysis. Table 1 summarizes the result. For
265 original tests and 193 abstracted tests that DS finished analysis,
we measured the number of tests that use only dynamic shortcuts
instead of manual modeling for each JavaScript built-in library
function. For each row, Object column denotes a built-in object,Function a function name, and # Replaced the number of tests
successfully replacing manual modeling via dynamic shortcuts over
the total number of tests using the target function. For example,
the first row in the leftmost side describes that Array is used in 205
original tests and 141 abstracted tests. Among them, 204 original
tests and 119 abstracted tests are successfully analyzed by using
dynamic shortcuts instead of manual modeling of Array . Each filled
cell describes a fully replaceable case. Therefore, dynamic shortcuts
effectively lessen the burden of manual modeling for JavaScript
built-in functions. For the original tests, 45 out of 63 built-in func-
tions are replaceable for them. For the abstracted tests, 22 built-in
functions are analyzed by only dynamic shortcuts.
7 RELATED WORK
Combined Analysis. The most related previous work is combined
analysis that utilizes dynamic analysis during Java static analy-
sis introduced by Toman and Grossman [42]. They proved that
their combined analysis is sound and showed that it could signifi-
cantly improve the precision and performance of Java static analysis
by evaluating their tool, Concerto . However, their approach has
several limitations compared with dynamic shortcuts. First, it syn-
tactically divides a given program to applications parts for static
analysis and frameworks parts for dynamic analysis. Thus, it cannot
freely switch between static analysis and dynamic analysis. It is
even impossible to perform both static and dynamic analysis of the
same program part in different contexts. In addition, while they
introduced mostly-concrete interpretation similar to our sealed exe-
cution, it supports only a special unknown value that represents any
possible value. Thus, it cannot preserve the precision of complex
abstract domains [ 23,24,29,35] frequently used in JavaScript static
analysis. On the contrary, sealed execution automatically detects
when to switch to static analysis to use abstract semantics for ab-
stract values. Finally, Concerto preserves the soundness when a
program satisfies the state separation hypothesis . It assumes that the
states of application parts and framework parts are not interrogated
or manipulated by each other. While the assumption may be reason-
able for static analysis of Java applications using external libraries,Accelerating JavaScript Static Analysis via Dynamic Shortcuts (Extended Version) ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece
it is not satisfied for JavaScript programs in general. Unlike their
approach, our approach does not have any assumptions between
static and dynamic analysis parts.
Concolic Execution. Concolic execution [ 15] is closely related to
dynamic shortcuts because it also leverages concrete execution for
symbolic execution. Symbolic execution [ 22] is an execution of a
program with symbolic values, and it can be treated as an abstract
interpretation with symbolic expressions and path constraints. To
resolve path constraints with symbolic expressions, symbolic execu-
tion engines such as KLEE [ 12] and SAGE [ 16] utilize Satisfiability
Modulo Theory (SMT) solvers as back-end modules. On the con-
trary, we formalized dynamic shortcuts as a technique to combine
concrete execution with a general abstract interpretation, not only
with symbolic execution. Thus, dynamic shortcuts are theoretically
applicable to any kind of abstract interpretation, including symbolic
execution, and it is a more general definition of concolic execution.
Automatic Modeling. For static analysis of JavaScript programs,
modeling behaviors of built-in libraries or host-dependent func-
tions is necessary because they are opaque code. Since manual
modeling is error-prone and labor-intensive, researchers [ 11,32]
have utilized type information to automatically model their behav-
iors. However, type is not enough to reflect complex semantics and
side-effects. To alleviate the problem, Heule et al . [18] introduced a
technique to infer JavaScript code for opaque code using concrete
execution. They leveraged ES6 Proxy objects to collect partial execu-
tion traces from opaque code and synthesized JavaScript code using
the extracted behaviors. Instead of synthesizing JavaScript code,
Park et al . [33] presented a Sample-Run-Abstract (SRA) approach
for on-demand modeling focusing on the current abstract states
during static analysis by sampling well-distributed concrete states.
However, all the previous work sacrifice the soundness of static
analysis. On the contrary, while dynamic shortcuts is not always
applicable to opaque functions, it is sound if it is applicable.
Pruning Analysis Scope. Another approach to utilize dynamic
analysis for JavaScript static analysis is to prune the scope of anal-
ysis. SchÃ¤fer et al . [38] proposed dynamic determinacy analysis.
They specialized target source code with determinacy facts so that
static analysis can get benefits from elimination of evaland con-
stant property names. Wei and Ryder [43] introduced blended taint
analysis , which specializes JavaScript dynamic language features
such as dynamic code generation or variadic function calls. It first
performs dynamic analysis to collect traces with concrete values
used in dynamic language features and restricts the semantics of
features based on the collected traces during static analysis. Park
et al. [34,37]utilize three points to reduce analysis scope: initial
states, dynamically loaded files, and event handlers. Unfortunately,
all the above approaches except [ 38] do not preserve soundness of
static analysis unlike our approach using dynamic shortcuts.
8 CONCLUSION
We presented a novel technique for JavaScript static analysis using
dynamic shortcuts . It can significantly accelerate static analysis and
lessen the modeling efforts for opaque code by freely leveraging
high performance of dynamic analysis for concretely executableprogram parts. To maximize such benefits, we proposed sealed exe-
cution , which performs concrete execution using sealed values for
abstract values. We formally defined static analysis using dynamic
shortcuts in the abstract interpretation framework and proved its
soundness and termination. We developed SAFE DSas a prototype
implementation of the proposed approach by extending a combi-
nation of the state-of-the-art static and dynamic analyzers SAFE
and Jalangi. Our tool accelerates the speed of static analysis 22.30 x
for original tests and 7.81 xfor abstracted tests of Lodash 4 library.
Moreover, it reduces the number of failed assertions by 12.31% by
using sealed execution instead of manual modeling for 22 opaque
functions on average.
ACKNOWLEDGEMENTS
This work was supported by National Research Foundation of Korea
(NRF) (Grants NRF-2017R1A2B3012020 and 2017M3C4A7068177).
REFERENCES
[1]2020. Electron - A framework for cross-platform desktop apps with JavaScript,
HTML, and CSS . Retrieved May 25, 2021 from https://www.electronjs.org/
[2]2020. Espruino - An open-source JavaScript interpreter for microcontrollers . Re-
trieved May 25, 2021 from https://www.espruino.com/
[3]2020. Lodash - A modern JavaScript library delivering modularity, performance,
and extras . Retrieved May 25, 2021 from https://lodash.com/
[4]2020. Moddable - Tools to create open IoT products using standard JavaScript on low
cast microcontrollers . Retrieved May 25, 2021 from https://www.moddable.com/
[5]2020. Node.js - A JavaScript runtime built on Chromeâ€™s V8 JavaScript engine .
Retrieved May 25, 2021 from https://nodejs.org/
[6]2020. React Native - A framework for building native apps using React . Retrieved
May 25, 2021 from https://reactnative.dev/
[7]2020. Standard ECMA-262 6th Edition, ECMAScript 2015 Language Specification .
Retrieved May 25, 2021 from https://262.ecma-international.org/6.0/
[8]2020. SunSpider Javascript Benchmark . Retrieved May 25, 2021 from https:
//webkit.org/perf/sunspider/sunspider.html
[9]2020. Zoom - A videotelephony software program developed by Zoom Video Com-
munications . Retrieved May 25, 2021 from https://zoom.us/
[10] Roberto Amadini, Alexander Jordan, Graeme Gange, FranÃ§ois Gauthier, Peter
Schachte, Harald SÃ¸ndergaard, Peter J Stuckey, and Chenyi Zhang. 2017. Com-
bining String Abstract Domains for JavaScript Analysis: An Evaluation. In Pro-
ceedings of the 23rd International Conference on Tools and Algorithms for the
Construction and Analysis of Systems (TACAS) . https://doi.org/10.1007/978-3-
662-54577-5_3
[11] SungGyeong Bae, Hyunghun Cho, Inho Lim, and Sukyoung Ryu. 2014. SAFE-
WAPI: Web API Misuse Detector for Web Applications. In Proceedings of the 22nd
ACM SIGSOFT International Symposium on Foundations of Software Engineering
(FSE) . https://doi.org/10.1145/2635868.2635916
[12] Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems Programs.
InProceedings of the 8th USENIX Symposium on Operating Systems Design and
Implementation (OSDI) , Vol. 8. 209â€“224. https://dl.acm.org/doi/10.5555/1855741.
1855756
[13] Patrick Cousot and Radhia Cousot. 1977. Abstract Interpretation: A Unified
Lattice Model for Static Analysis of Programs by Construction or Approximation
of Fixpoints. In Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on
Principles of Programming languages (POPL) . https://doi.org/10.1145/512950.
512973
[14] Patrick Cousot and Radhia Cousot. 1992. Abstract interpretation frameworks.
Journal of Logic and Computation (JLC) 2, 4 (1992), 511â€“547. https://doi.org/10.
1093/logcom/2.4.511
[15] Patrice Godefroid, Nils Klarlund, and Koushik Sen. 2005. DART: Directed auto-
mated random testing. In Proceedings of the ACM SIGPLAN conference on Pro-
gramming language design and implementation (PLDI) . https://doi.org/10.1145/
1065010.1065036
[16] Patrice Godefroid, Michael Y Levin, and David Molnar. 2012. SAGE: Whitebox
Fuzzing for Security Testing. Communications of the ACM (CACM) 55, 3 (2012),
40â€“44. https://doi.org/10.1145/2093548.2093564
[17] Liang Gong, Michael Pradel, Manu Sridharan, and Koushik Sen. 2015. DLint:
Dynamically Checking Bad Coding Practices in JavaScript. In Proceedings of the
24th International Symposium on Software Testing and Analysis (ISSTA) . https:
//doi.org/10.1145/2771783.2771809ESEC/FSE â€™21, August 23â€“28, 2021, Athens, Greece Park and Park, et al.
[18] Stefan Heule, Manu Sridharan, and Satish Chandra. 2015. Mimic: Computing
Models for Opaque Code. In Proceedings of the 10th Joint Meeting of the European
Software Engineering Conference and the ACM SIGSOFT Symposium on the Founda-
tions of Software Engineering (ESEC/FSE) . https://doi.org/10.1145/2786805.2786875
[19] Simon Holm Jensen, Anders MÃ¸ller, and Peter Thiemann. 2009. Type Analysis for
JavaScript. In Proceedings of the 16th International Symposium on Static Analysis
(SAS) . https://doi.org/10.1007/978-3-642-03237-0_17
[20] Vineeth Kashyap, Kyle Dewey, Ethan A. Kuefner, John Wagner, Kevin Gib-
bons, John Sarracino, Ben Wiedermann, and Ben Hardekopf. 2014. JSAI: A
Static Analysis Platform for JavaScript. In Proceedings of the 22nd ACM SIG-
SOFT International Symposium on Foundations of Software Engineering (FSE) .
https://doi.org/10.1145/2635868.2635904
[21] Se-Won Kim, Xavier Rival, and Sukyoung Ryu. 2018. A Theoretical Foundation
of Sensitivity in an Abstract Interpretation Framework. ACM Transactions on
Programming Languages and Systems (TOPLAS) 40, 3 (2018), 1â€“44. https://doi.
org/10.1145/3230624
[22] James C King. 1976. Symbolic execution and program testing. Communications
of the ACM (CACM) 19, 7 (1976), 385â€“394. https://doi.org/10.1145/360248.360252
[23] Yoonseok Ko, Xavier Rival, and Sukyoung Ryu. 2017. Weakly Sensitive Analysis
for Unbounded Iteration over JavaScript Objects. In Proceedings of the 15th Asian
Symposium on Programming Languages and Systems (APLAS) . https://doi.org/10.
1007/978-3-319-71237-6_8
[24] Yoonseok Ko, Xavier Rival, and Sukyoung Ryu. 2019. Weakly sensitive analysis
for JavaScript object-manipulating programs. Software: Practice and Experience
(SPE) 49, 5 (2019), 840â€“884. https://doi.org/10.1002/spe.2676
[25] Hongki Lee, Sooncheol Won, Joonho Jin, Junhee Cho, and Sukyoung Ryu. 2012.
SAFE: Formal Specification and Implementation of a Scalable Analysis Framework
for ECMAScript. In Proceedings of 19th International Workshop on Foundations of
Object-Oriented Languages (FOOL) .
[26] Magnus Madsen and Esben Andreasen. 2014. String Analysis for Dynamic
Field Access. In Proceedings of the 23rd International Conference on Compiler
Construction (CC) . https://doi.org/10.1007/978-3-642-54807-9_12
[27] Matthew Might and Olin Shivers. 2006. Improving Flow Analyses via Î“CFA:
Abstract Garbage Collection and Counting. In Proceedings of the 11th ACM
SIGPLAN International Conference on Functional Programming (ICFP) . https:
//doi.org/10.1145/1159803.1159807
[28] Benjamin Barslev Nielsen and Anders MÃ¸ller. 2020. Value Partitioning: A
Lightweight Approach to Relational Static Analysis for JavaScript. In Proceed-
ings of the 34th European Conference on Object-Oriented Programming (ECOOP) .
https://doi.org/10.4230/LIPIcs.ECOOP.2020.16
[29] Changhee Park, Hyeonseung Im, and Sukyoung Ryu. 2016. Precise and Scalable
Static Analysis of jQuery using a Regular Expression Domain. In Proceedings
of the 12th Symposium on Dynamic Languages (DLS) . https://doi.org/10.1145/
2989225.2989228
[30] Changhee Park, Hongki Lee, and Sukyoung Ryu. 2018. Static analysis of JavaScript
libraries in a scalable and precise way using loop sensitivity. Software: Practice
and Experience (SPE) 48, 4 (2018), 911â€“944. https://doi.org/10.1002/spe.2676
[31] Changhee Park and Sukyoung Ryu. 2015. Scalable and Precise Static Analysis of
JavaScript Applications via Loop-Sensitivity. In Proceedings of the 29th EuropeanConference on Object-Oriented Programming (ECOOP) . https://doi.org/10.4230/
LIPIcs.ECOOP.2015.735
[32] Jihyeok Park. 2014. JavaScript API misuse detection by using typescript. In
Proceedings of the companion publication of the 13th international conference on
Modularity . https://doi.org/10.1145/2584469.2584472
[33] Joonyoung Park, Alexander Jordan, and Sukyoung Ryu. 2019. Automatic Mod-
eling of Opaque Code for JavaScript Static Analysis. In Proceedings of the 22nd
International Conference on Fundamental Approaches to Software Engineering
(FASE) . https://doi.org/10.1007/978-3-030-16722-6_3
[34] Joonyoung Park, Inho Lim, and Sukyoung Ryu. 2016. Battles with False Positives
in Static Analysis of JavaScript Web Applications in the Wild. In Proceedings of
the 38th IEEE/ACM International Conference on Software Engineering Companion
(ICSE-C) . https://doi.org/10.1145/2889160.2889227
[35] Jihyeok Park, Xavier Rival, and Sukyoung Ryu. 2017. Revisiting Recency Abstrac-
tion for JavaScript: Towards an Intuitive, Compositional, and Efficient Heap Ab-
straction. In Proceedings of the 6th ACM SIGPLAN International Workshop on State
Of the Art in Program Analysis (SOAP) . https://doi.org/10.1145/3088515.3088516
[36] Jihyeok Park, Yeonhee Ryou, Joonyoung Park, and Sukyoung Ryu. 2017. Anal-
ysis of JavaScript Web Applications Using SAFE 2.0. In Proceedings of the 39th
IEEE/ACM International Conference on Software Engineering Companion (ICSE-C) .
https://doi.org/10.1109/ICSE-C.2017.4
[37] Joonyoung Park, Kwangwon Sun, and Sukyoung Ryu. 2018. EventHandler-
Based Analysis Framework for Web Apps Using Dynamically Collected States.
InProceedings of the 21st International Conference on Fundamental Approaches to
Software Engineering (FASE) . https://doi.org/10.1007/978-3-319-89363-1_8
[38] Max SchÃ¤fer, Manu Sridharan, Julian Dolby, and Frank Tip. 2013. Dynamic
Determinacy Analysis. In Proceedings of the 34th annual ACM SIGPLAN conference
on Programming Language Design and Implementation (PLDI) . https://doi.org/10.
1145/2499370.2462168
[39] Koushik Sen, Swaroop Kalasapur, Tasneem Brutch, and Simon Gibbs. 2013.
Jalangi: A Selective Record-Replay and Dynamic Analysis Framework for
JavaScript. In Proceedings of the 10th Joint Meeting of the European Software
Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of
Software Engineering (ESEC/FSE) . https://doi.org/10.1145/2491411.2491447
[40] Manu Sridharan, Julian Dolby, Satish Chandra, Max SchÃ¤fer, and Frank Tip. 2012.
Correlation Tracking for Points-To Analysis of JavaScript. In Proceedings of the
26th European Conference on Object-Oriented Programming (ECOOP) . https:
//doi.org/10.1007/978-3-642-31057-7_20
[41] Benno Stein, Benjamin Barslev Nielsen, Bor-Yuh Evan Chang, and Anders MÃ¸ller.
2019. Static Analysis with Demand-Driven Value Refinement. In Proceedings
of the 34th ACM SIGPLAN conference on Object-Oriented Programming, Systems,
Languages, and Applications (OOPSLA) . https://doi.org/10.1145/3360566
[42] John Toman and Dan Grossman. 2019. Concerto: A Framework for Combined
Concrete and Abstract Interpretation. In Proceedings of the 46th ACM SIGPLAN
Symposium on Principles of Programming Languages (POPL) . https://doi.org/10.
1145/3290356
[43] Shiyi Wei and Barbara G Ryder. 2013. Practical Blended Taint Analysis for
JavaScript. In Proceedings of the 22th International Symposium on Software Testing
and Analysis (ISSTA) . https://doi.org/10.1145/2483760.2483788